<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecompiler/BytecodeGenerator.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../bytecode/Watchpoint.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="BytecodeGenerator.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecompiler/BytecodeGenerator.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  47 #include &quot;JSFixedArray.h&quot;
  48 #include &quot;JSFunction.h&quot;
  49 #include &quot;JSGeneratorFunction.h&quot;
  50 #include &quot;JSImmutableButterfly.h&quot;
  51 #include &quot;JSLexicalEnvironment.h&quot;
  52 #include &quot;JSTemplateObjectDescriptor.h&quot;
  53 #include &quot;LowLevelInterpreter.h&quot;
  54 #include &quot;Options.h&quot;
  55 #include &quot;PreciseJumpTargetsInlines.h&quot;
  56 #include &quot;StackAlignment.h&quot;
  57 #include &quot;StrongInlines.h&quot;
  58 #include &quot;SuperSamplerBytecodeScope.h&quot;
  59 #include &quot;UnlinkedCodeBlock.h&quot;
  60 #include &quot;UnlinkedEvalCodeBlock.h&quot;
  61 #include &quot;UnlinkedFunctionCodeBlock.h&quot;
  62 #include &quot;UnlinkedMetadataTableInlines.h&quot;
  63 #include &quot;UnlinkedModuleProgramCodeBlock.h&quot;
  64 #include &quot;UnlinkedProgramCodeBlock.h&quot;
  65 #include &lt;wtf/BitVector.h&gt;
  66 #include &lt;wtf/CommaPrinter.h&gt;

  67 #include &lt;wtf/SmallPtrSet.h&gt;
  68 #include &lt;wtf/StdLibExtras.h&gt;
  69 #include &lt;wtf/text/WTFString.h&gt;
  70 
  71 namespace JSC {
  72 
  73 template&lt;typename CallOp, typename = std::true_type&gt;
  74 struct VarArgsOp;
  75 
  76 template&lt;typename CallOp&gt;
  77 struct VarArgsOp&lt;CallOp, std::enable_if_t&lt;std::is_same&lt;CallOp, OpTailCall&gt;::value, std::true_type&gt;&gt; {
  78     using type = OpTailCallVarargs;
  79 };
  80 
  81 
  82 template&lt;typename CallOp&gt;
  83 struct VarArgsOp&lt;CallOp, std::enable_if_t&lt;!std::is_same&lt;CallOp, OpTailCall&gt;::value, std::true_type&gt;&gt; {
  84     using type = OpCallVarargs;
  85 };
  86 
</pre>
<hr />
<pre>
  97     m_location = location;
  98 
  99     for (auto offset : m_unresolvedJumps) {
 100         auto instruction = generator.m_writer.ref(offset);
 101         int target = m_location - offset;
 102 
 103 #define CASE(__op) \
 104     case __op::opcodeID:  \
 105         instruction-&gt;cast&lt;__op&gt;()-&gt;setTargetLabel(BoundLabel(target), [&amp;]() { \
 106             generator.m_codeBlock-&gt;addOutOfLineJumpTarget(instruction.offset(), target); \
 107             return BoundLabel(); \
 108         }); \
 109         break;
 110 
 111         switch (instruction-&gt;opcodeID()) {
 112         CASE(OpJmp)
 113         CASE(OpJtrue)
 114         CASE(OpJfalse)
 115         CASE(OpJeqNull)
 116         CASE(OpJneqNull)


 117         CASE(OpJeq)
 118         CASE(OpJstricteq)
 119         CASE(OpJneq)
 120         CASE(OpJneqPtr)
 121         CASE(OpJnstricteq)
 122         CASE(OpJless)
 123         CASE(OpJlesseq)
 124         CASE(OpJgreater)
 125         CASE(OpJgreatereq)
 126         CASE(OpJnless)
 127         CASE(OpJnlesseq)
 128         CASE(OpJngreater)
 129         CASE(OpJngreatereq)
 130         CASE(OpJbelow)
 131         CASE(OpJbeloweq)
 132         default:
 133             ASSERT_NOT_REACHED();
 134         }
 135 #undef CASE
 136     }
</pre>
<hr />
<pre>
 166     if (m_type == GeneratorForward) {
 167         m_label-&gt;m_unresolvedJumps.append(m_savedTarget);
 168         return 0;
 169     }
 170 
 171     return m_savedTarget;
 172 }
 173 
 174 void Variable::dump(PrintStream&amp; out) const
 175 {
 176     out.print(
 177         &quot;{ident = &quot;, m_ident,
 178         &quot;, offset = &quot;, m_offset,
 179         &quot;, local = &quot;, RawPointer(m_local),
 180         &quot;, attributes = &quot;, m_attributes,
 181         &quot;, kind = &quot;, m_kind,
 182         &quot;, symbolTableConstantIndex = &quot;, m_symbolTableConstantIndex,
 183         &quot;, isLexicallyScoped = &quot;, m_isLexicallyScoped, &quot;}&quot;);
 184 }
 185 











 186 ParserError BytecodeGenerator::generate()
 187 {
 188     m_codeBlock-&gt;setThisRegister(m_thisRegister.virtualRegister());
 189 
 190     emitLogShadowChickenPrologueIfNecessary();
 191 
 192     // If we have declared a variable named &quot;arguments&quot; and we are using arguments then we should
 193     // perform that assignment now.
 194     if (m_needToInitializeArguments)
 195         initializeVariable(variable(propertyNames().arguments), m_argumentsRegister);
 196 
 197     if (m_restParameter)
 198         m_restParameter-&gt;emit(*this);
 199 
 200     {
 201         RefPtr&lt;RegisterID&gt; temp = newTemporary();
 202         RefPtr&lt;RegisterID&gt; tolLevelScope;
 203         for (auto functionPair : m_functionsToInitialize) {
 204             FunctionMetadataNode* metadata = functionPair.first;
 205             FunctionVariableType functionType = functionPair.second;
</pre>
<hr />
<pre>
 228                     tolLevelScope = newBlockScopeVariable();
 229                     move(tolLevelScope.get(), tolLevelObjectScope.get());
 230                 }
 231                 emitPutToScope(tolLevelScope.get(), Variable(metadata-&gt;ident()), temp.get(), ThrowIfNotFound, InitializationMode::NotInitialization);
 232             } else
 233                 RELEASE_ASSERT_NOT_REACHED();
 234         }
 235     }
 236 
 237     bool callingClassConstructor = constructorKind() != ConstructorKind::None &amp;&amp; !isConstructor();
 238     if (!callingClassConstructor)
 239         m_scopeNode-&gt;emitBytecode(*this);
 240     else {
 241         // At this point we would have emitted an unconditional throw followed by some nonsense that&#39;s
 242         // just an artifact of how this generator is structured. That code never runs, but it confuses
 243         // bytecode analyses because it constitutes an unterminated basic block. So, we terminate the
 244         // basic block the strongest way possible.
 245         emitUnreachable();
 246     }
 247 
<span class="line-modified"> 248     for (auto&amp; tuple : m_catchesToEmit) {</span>
 249         Ref&lt;Label&gt; realCatchTarget = newLabel();
<span class="line-modified"> 250         OpCatch::emit(this, std::get&lt;1&gt;(tuple), std::get&lt;2&gt;(tuple));</span>


 251         realCatchTarget-&gt;setLocation(*this, m_lastInstruction.offset());








 252         m_codeBlock-&gt;addJumpTarget(m_lastInstruction.offset());
 253 
 254 
<span class="line-removed"> 255         TryData* tryData = std::get&lt;0&gt;(tuple);</span>
 256         emitJump(tryData-&gt;target.get());
 257         tryData-&gt;target = WTFMove(realCatchTarget);
 258     }
 259 
 260     m_staticPropertyAnalyzer.kill();
 261 
 262     for (auto&amp; range : m_tryRanges) {
 263         int start = range.start-&gt;bind();
 264         int end = range.end-&gt;bind();
 265 
 266         // This will happen for empty try blocks and for some cases of finally blocks:
 267         //
 268         // try {
 269         //    try {
 270         //    } finally {
 271         //        return 42;
 272         //        // *HERE*
 273         //    }
 274         // } finally {
 275         //    print(&quot;things&quot;);
</pre>
<hr />
<pre>
 290 
 291         UnlinkedHandlerInfo info(static_cast&lt;uint32_t&gt;(start), static_cast&lt;uint32_t&gt;(end),
 292             static_cast&lt;uint32_t&gt;(range.tryData-&gt;target-&gt;bind()), range.tryData-&gt;handlerType);
 293         m_codeBlock-&gt;addExceptionHandler(info);
 294     }
 295 
 296 
 297     if (isGeneratorOrAsyncFunctionBodyParseMode(m_codeBlock-&gt;parseMode()))
 298         performGeneratorification(*this, m_codeBlock.get(), m_writer, m_generatorFrameSymbolTable.get(), m_generatorFrameSymbolTableIndex);
 299 
 300     RELEASE_ASSERT(static_cast&lt;unsigned&gt;(m_codeBlock-&gt;numCalleeLocals()) &lt; static_cast&lt;unsigned&gt;(FirstConstantRegisterIndex));
 301     m_codeBlock-&gt;setInstructions(m_writer.finalize());
 302 
 303     m_codeBlock-&gt;shrinkToFit();
 304 
 305     if (m_expressionTooDeep)
 306         return ParserError(ParserError::OutOfMemory);
 307     return ParserError(ParserError::ErrorNone);
 308 }
 309 
<span class="line-modified"> 310 BytecodeGenerator::BytecodeGenerator(VM&amp; vm, ProgramNode* programNode, UnlinkedProgramCodeBlock* codeBlock, DebuggerMode debuggerMode, const VariableEnvironment* parentScopeTDZVariables)</span>
<span class="line-modified"> 311     : m_shouldEmitDebugHooks(Options::forceDebuggerBytecodeGeneration() || debuggerMode == DebuggerOn)</span>
 312     , m_scopeNode(programNode)
 313     , m_codeBlock(vm, codeBlock)
 314     , m_thisRegister(CallFrame::thisArgumentOffset())
 315     , m_codeType(GlobalCode)
<span class="line-modified"> 316     , m_vm(&amp;vm)</span>
 317     , m_needsToUpdateArrowFunctionContext(programNode-&gt;usesArrowFunction() || programNode-&gt;usesEval())
 318 {
 319     ASSERT_UNUSED(parentScopeTDZVariables, !parentScopeTDZVariables-&gt;size());
 320 
 321     for (auto&amp; constantRegister : m_linkTimeConstantRegisters)
 322         constantRegister = nullptr;
 323 
 324     allocateCalleeSaveSpace();
 325 
 326     m_codeBlock-&gt;setNumParameters(1); // Allocate space for &quot;this&quot;
 327 
 328     emitEnter();
 329 
 330     allocateAndEmitScope();
 331 
<span class="line-removed"> 332     emitCheckTraps();</span>
<span class="line-removed"> 333 </span>
 334     const FunctionStack&amp; functionStack = programNode-&gt;functionStack();
 335 
 336     for (auto* function : functionStack)
 337         m_functionsToInitialize.append(std::make_pair(function, TopLevelFunctionVariable));
 338 
 339     if (Options::validateBytecode()) {
 340         for (auto&amp; entry : programNode-&gt;varDeclarations())
 341             RELEASE_ASSERT(entry.value.isVar());
 342     }
 343     codeBlock-&gt;setVariableDeclarations(programNode-&gt;varDeclarations());
 344     codeBlock-&gt;setLexicalDeclarations(programNode-&gt;lexicalVariables());
 345     // Even though this program may have lexical variables that go under TDZ, when linking the get_from_scope/put_to_scope
 346     // operations we emit we will have ResolveTypes that implictly do TDZ checks. Therefore, we don&#39;t need
 347     // additional TDZ checks on top of those. This is why we can omit pushing programNode-&gt;lexicalVariables()
 348     // to the TDZ stack.
 349 
 350     if (needsToUpdateArrowFunctionContext()) {
 351         initializeArrowFunctionContextScopeIfNeeded();
 352         emitPutThisToArrowFunctionContextScope();
 353     }
 354 }
 355 
<span class="line-modified"> 356 BytecodeGenerator::BytecodeGenerator(VM&amp; vm, FunctionNode* functionNode, UnlinkedFunctionCodeBlock* codeBlock, DebuggerMode debuggerMode, const VariableEnvironment* parentScopeTDZVariables)</span>
<span class="line-modified"> 357     : m_shouldEmitDebugHooks(Options::forceDebuggerBytecodeGeneration() || debuggerMode == DebuggerOn)</span>
 358     , m_scopeNode(functionNode)
 359     , m_codeBlock(vm, codeBlock)
 360     , m_codeType(FunctionCode)
<span class="line-modified"> 361     , m_vm(&amp;vm)</span>
 362     , m_isBuiltinFunction(codeBlock-&gt;isBuiltinFunction())
 363     , m_usesNonStrictEval(codeBlock-&gt;usesEval() &amp;&amp; !codeBlock-&gt;isStrictMode())
 364     // FIXME: We should be able to have tail call elimination with the profiler
 365     // enabled. This is currently not possible because the profiler expects
 366     // op_will_call / op_did_call pairs before and after a call, which are not
 367     // compatible with tail calls (we have no way of emitting op_did_call).
 368     // https://bugs.webkit.org/show_bug.cgi?id=148819
 369     , m_inTailPosition(Options::useTailCalls() &amp;&amp; !isConstructor() &amp;&amp; constructorKind() == ConstructorKind::None &amp;&amp; isStrictMode())
 370     , m_needsToUpdateArrowFunctionContext(functionNode-&gt;usesArrowFunction() || functionNode-&gt;usesEval())
 371     , m_derivedContextType(codeBlock-&gt;derivedContextType())
 372 {
 373     for (auto&amp; constantRegister : m_linkTimeConstantRegisters)
 374         constantRegister = nullptr;
 375 
<span class="line-removed"> 376     if (m_isBuiltinFunction)</span>
<span class="line-removed"> 377         m_shouldEmitDebugHooks = false;</span>
<span class="line-removed"> 378 </span>
 379     allocateCalleeSaveSpace();
 380 
<span class="line-modified"> 381     SymbolTable* functionSymbolTable = SymbolTable::create(*m_vm);</span>
 382     functionSymbolTable-&gt;setUsesNonStrictEval(m_usesNonStrictEval);
 383     int symbolTableConstantIndex = 0;
 384 
 385     FunctionParameters&amp; parameters = *functionNode-&gt;parameters();
 386     // http://www.ecma-international.org/ecma-262/6.0/index.html#sec-functiondeclarationinstantiation
 387     // This implements IsSimpleParameterList in the Ecma 2015 spec.
 388     // If IsSimpleParameterList is false, we will create a strict-mode like arguments object.
 389     // IsSimpleParameterList is false if the argument list contains any default parameter values,
 390     // a rest parameter, or any destructuring patterns.
 391     // If we do have default parameters, destructuring parameters, or a rest parameter, our parameters will be allocated in a different scope.
 392     bool isSimpleParameterList = parameters.isSimpleParameterList();
 393 
 394     SourceParseMode parseMode = codeBlock-&gt;parseMode();
 395 
 396     bool containsArrowOrEvalButNotInArrowBlock = ((functionNode-&gt;usesArrowFunction() &amp;&amp; functionNode-&gt;doAnyInnerArrowFunctionsUseAnyFeature()) || functionNode-&gt;usesEval()) &amp;&amp; !m_codeBlock-&gt;isArrowFunction();
<span class="line-modified"> 397     bool shouldCaptureSomeOfTheThings = m_shouldEmitDebugHooks || functionNode-&gt;needsActivation() || containsArrowOrEvalButNotInArrowBlock;</span>
 398 
<span class="line-modified"> 399     bool shouldCaptureAllOfTheThings = m_shouldEmitDebugHooks || codeBlock-&gt;usesEval();</span>
 400     bool needsArguments = ((functionNode-&gt;usesArguments() &amp;&amp; !codeBlock-&gt;isArrowFunction()) || codeBlock-&gt;usesEval() || (functionNode-&gt;usesArrowFunction() &amp;&amp; !codeBlock-&gt;isArrowFunction() &amp;&amp; isArgumentsUsedInInnerArrowFunction()));
 401 
 402     if (isGeneratorOrAsyncFunctionBodyParseMode(parseMode)) {
 403         // Generator and AsyncFunction never provides &quot;arguments&quot;. &quot;arguments&quot; reference will be resolved in an upper generator function scope.
 404         needsArguments = false;
<span class="line-removed"> 405 </span>
<span class="line-removed"> 406         // Generator and AsyncFunction uses the var scope to save and resume its variables. So the lexical scope is always instantiated.</span>
<span class="line-removed"> 407         shouldCaptureSomeOfTheThings = true;</span>
 408     }
 409 
 410     if (isGeneratorOrAsyncFunctionWrapperParseMode(parseMode) &amp;&amp; needsArguments) {
 411         // Generator does not provide &quot;arguments&quot;. Instead, wrapping GeneratorFunction provides &quot;arguments&quot;.
 412         // This is because arguments of a generator should be evaluated before starting it.
 413         // To workaround it, we evaluate these arguments as arguments of a wrapping generator function, and reference it from a generator.
 414         //
 415         //    function *gen(a, b = hello())
 416         //    {
 417         //        return {
 418         //            @generatorNext: function (@generator, @generatorState, @generatorValue, @generatorResumeMode, @generatorFrame)
 419         //            {
 420         //                arguments;  // This `arguments` should reference to the gen&#39;s arguments.
 421         //                ...
 422         //            }
 423         //        }
 424         //    }
 425         shouldCaptureSomeOfTheThings = true;
 426     }
 427 
</pre>
<hr />
<pre>
 439             return true;
 440         }
 441         return functionNode-&gt;captures(uid);
 442     });
 443     auto varKind = [&amp;] (UniquedStringImpl* uid) -&gt; VarKind {
 444         return captures(uid) ? VarKind::Scope : VarKind::Stack;
 445     };
 446 
 447     m_calleeRegister.setIndex(CallFrameSlot::callee);
 448 
 449     initializeParameters(parameters);
 450     ASSERT(!(isSimpleParameterList &amp;&amp; m_restParameter));
 451 
 452     emitEnter();
 453 
 454     if (isGeneratorOrAsyncFunctionBodyParseMode(parseMode))
 455         m_generatorRegister = &amp;m_parameters[1];
 456 
 457     allocateAndEmitScope();
 458 
<span class="line-removed"> 459     emitCheckTraps();</span>
<span class="line-removed"> 460 </span>
 461     if (functionNameIsInScope(functionNode-&gt;ident(), functionNode-&gt;functionMode())) {
 462         ASSERT(parseMode != SourceParseMode::GeneratorBodyMode);
 463         ASSERT(!isAsyncFunctionBodyParseMode(parseMode));
 464         bool isDynamicScope = functionNameScopeIsDynamic(codeBlock-&gt;usesEval(), codeBlock-&gt;isStrictMode());
 465         bool isFunctionNameCaptured = captures(functionNode-&gt;ident().impl());
 466         bool markAsCaptured = isDynamicScope || isFunctionNameCaptured;
 467         emitPushFunctionNameScope(functionNode-&gt;ident(), &amp;m_calleeRegister, markAsCaptured);
 468     }
 469 
 470     if (shouldCaptureSomeOfTheThings)
 471         m_lexicalEnvironmentRegister = addVar();
 472 
<span class="line-modified"> 473     if (shouldCaptureSomeOfTheThings || vm.typeProfiler())</span>
 474         symbolTableConstantIndex = addConstantValue(functionSymbolTable)-&gt;index();
 475 
 476     // We can allocate the &quot;var&quot; environment if we don&#39;t have default parameter expressions. If we have
 477     // default parameter expressions, we have to hold off on allocating the &quot;var&quot; environment because
 478     // the parent scope of the &quot;var&quot; environment is the parameter environment.
 479     if (isSimpleParameterList)
 480         initializeVarLexicalEnvironment(symbolTableConstantIndex, functionSymbolTable, shouldCaptureSomeOfTheThings);
 481 
 482     // Figure out some interesting facts about our arguments.
 483     bool capturesAnyArgumentByName = false;
 484     if (functionNode-&gt;hasCapturedVariables()) {
 485         FunctionParameters&amp; parameters = *functionNode-&gt;parameters();
 486         for (size_t i = 0; i &lt; parameters.size(); ++i) {
 487             auto pattern = parameters.at(i).first;
 488             if (!pattern-&gt;isBindingNode())
 489                 continue;
 490             const Identifier&amp; ident = static_cast&lt;const BindingNode*&gt;(pattern)-&gt;boundProperty();
 491             capturesAnyArgumentByName |= captures(ident.impl());
 492         }
 493     }
</pre>
<hr />
<pre>
 516         // use DirectArguments. With ScopedArguments, we lift all of our arguments into the
 517         // activation.
 518 
 519         if (capturesAnyArgumentByName) {
 520             functionSymbolTable-&gt;setArgumentsLength(vm, parameters.size());
 521 
 522             // For each parameter, we have two possibilities:
 523             // Either it&#39;s a binding node with no function overlap, in which case it gets a name
 524             // in the symbol table - or it just gets space reserved in the symbol table. Either
 525             // way we lift the value into the scope.
 526             for (unsigned i = 0; i &lt; parameters.size(); ++i) {
 527                 ScopeOffset offset = functionSymbolTable-&gt;takeNextScopeOffset(NoLockingNecessary);
 528                 functionSymbolTable-&gt;setArgumentOffset(vm, i, offset);
 529                 if (UniquedStringImpl* name = visibleNameForParameter(parameters.at(i).first)) {
 530                     VarOffset varOffset(offset);
 531                     SymbolTableEntry entry(varOffset);
 532                     // Stores to these variables via the ScopedArguments object will not do
 533                     // notifyWrite(), since that would be cumbersome. Also, watching formal
 534                     // parameters when &quot;arguments&quot; is in play is unlikely to be super profitable.
 535                     // So, we just disable it.
<span class="line-modified"> 536                     entry.disableWatching(*m_vm);</span>
 537                     functionSymbolTable-&gt;set(NoLockingNecessary, name, entry);
 538                 }
<span class="line-modified"> 539                 OpPutToScope::emit(this, m_lexicalEnvironmentRegister, UINT_MAX, virtualRegisterForArgument(1 + i), GetPutInfo(ThrowIfNotFound, LocalClosureVar, InitializationMode::NotInitialization), symbolTableConstantIndex, offset.offset());</span>
 540             }
 541 
 542             // This creates a scoped arguments object and copies the overflow arguments into the
 543             // scope. It&#39;s the equivalent of calling ScopedArguments::createByCopying().
 544             OpCreateScopedArguments::emit(this, m_argumentsRegister, m_lexicalEnvironmentRegister);
 545         } else {
 546             // We&#39;re going to put all parameters into the DirectArguments object. First ensure
 547             // that the symbol table knows that this is happening.
 548             for (unsigned i = 0; i &lt; parameters.size(); ++i) {
 549                 if (UniquedStringImpl* name = visibleNameForParameter(parameters.at(i).first))
 550                     functionSymbolTable-&gt;set(NoLockingNecessary, name, SymbolTableEntry(VarOffset(DirectArgumentsOffset(i))));
 551             }
 552 
 553             OpCreateDirectArguments::emit(this, m_argumentsRegister);
 554         }
 555     } else if (isSimpleParameterList) {
 556         // Create the formal parameters the normal way. Any of them could be captured, or not. If
 557         // captured, lift them into the scope. We cannot do this if we have default parameter expressions
 558         // because when default parameter expressions exist, they belong in their own lexical environment
 559         // separate from the &quot;var&quot; lexical environment.
 560         for (unsigned i = 0; i &lt; parameters.size(); ++i) {
 561             UniquedStringImpl* name = visibleNameForParameter(parameters.at(i).first);
 562             if (!name)
 563                 continue;
 564 
 565             if (!captures(name)) {
 566                 // This is the easy case - just tell the symbol table about the argument. It will
 567                 // be accessed directly.
 568                 functionSymbolTable-&gt;set(NoLockingNecessary, name, SymbolTableEntry(VarOffset(virtualRegisterForArgument(1 + i))));
 569                 continue;
 570             }
 571 
 572             ScopeOffset offset = functionSymbolTable-&gt;takeNextScopeOffset(NoLockingNecessary);
 573             const Identifier&amp; ident =
 574                 static_cast&lt;const BindingNode*&gt;(parameters.at(i).first)-&gt;boundProperty();
 575             functionSymbolTable-&gt;set(NoLockingNecessary, name, SymbolTableEntry(VarOffset(offset)));
 576 
<span class="line-modified"> 577             OpPutToScope::emit(this, m_lexicalEnvironmentRegister, addConstant(ident), virtualRegisterForArgument(1 + i), GetPutInfo(ThrowIfNotFound, LocalClosureVar, InitializationMode::NotInitialization), symbolTableConstantIndex, offset.offset());</span>
 578         }
 579     }
 580 
 581     if (needsArguments &amp;&amp; (codeBlock-&gt;isStrictMode() || !isSimpleParameterList)) {
 582         // Allocate a cloned arguments object.
 583         OpCreateClonedArguments::emit(this, m_argumentsRegister);
 584     }
 585 
 586     // There are some variables that need to be preinitialized to something other than Undefined:
 587     //
 588     // - &quot;arguments&quot;: unless it&#39;s used as a function or parameter, this should refer to the
 589     //   arguments object.
 590     //
 591     // - functions: these always override everything else.
 592     //
 593     // The most logical way to do all of this is to initialize none of the variables until now,
 594     // and then initialize them in BytecodeGenerator::generate() in such an order that the rules
 595     // for how these things override each other end up holding. We would initialize &quot;arguments&quot; first,
 596     // then all arguments, then the functions.
 597     //
</pre>
<hr />
<pre>
 633 
 634             m_needToInitializeArguments = true;
 635         }
 636     }
 637 
 638     for (FunctionMetadataNode* function : functionNode-&gt;functionStack()) {
 639         const Identifier&amp; ident = function-&gt;ident();
 640         createVariable(ident, varKind(ident.impl()), functionSymbolTable);
 641         m_functionsToInitialize.append(std::make_pair(function, NormalFunctionVariable));
 642     }
 643     for (auto&amp; entry : functionNode-&gt;varDeclarations()) {
 644         ASSERT(!entry.value.isLet() &amp;&amp; !entry.value.isConst());
 645         if (!entry.value.isVar()) // This is either a parameter or callee.
 646             continue;
 647         if (shouldCreateArgumentsVariableInParameterScope &amp;&amp; entry.key.get() == propertyNames().arguments.impl())
 648             continue;
 649         createVariable(Identifier::fromUid(m_vm, entry.key.get()), varKind(entry.key.get()), functionSymbolTable, IgnoreExisting);
 650     }
 651 
 652 
<span class="line-modified"> 653     m_newTargetRegister = addVar();</span>


 654     switch (parseMode) {
 655     case SourceParseMode::GeneratorWrapperFunctionMode:
 656     case SourceParseMode::GeneratorWrapperMethodMode:
 657     case SourceParseMode::AsyncGeneratorWrapperMethodMode:
 658     case SourceParseMode::AsyncGeneratorWrapperFunctionMode: {
 659         m_generatorRegister = addVar();
 660 
 661         // FIXME: Emit to_this only when Generator uses it.
 662         // https://bugs.webkit.org/show_bug.cgi?id=151586
 663         emitToThis();
 664 
 665         move(m_generatorRegister, &amp;m_calleeRegister);
 666         emitCreateThis(m_generatorRegister);
 667         break;
 668     }
 669 
 670     case SourceParseMode::AsyncArrowFunctionMode:
 671     case SourceParseMode::AsyncMethodMode:
 672     case SourceParseMode::AsyncFunctionMode: {
 673         ASSERT(!isConstructor());
</pre>
<hr />
<pre>
 691 
 692         CallArguments args(*this, nullptr, 1);
 693         emitLoad(args.thisRegister(), jsUndefined());
 694 
 695         auto&amp; builtinNames = propertyNames().builtinNames();
 696         auto varPromiseConstructor = variable(m_isBuiltinFunction ? builtinNames.InternalPromisePrivateName() : builtinNames.PromisePrivateName());
 697         move(scope.get(), emitResolveScope(scope.get(), varPromiseConstructor));
 698         emitGetFromScope(args.argumentRegister(0), scope.get(), varPromiseConstructor, ThrowIfNotFound);
 699 
 700         // JSTextPosition(int _line, int _offset, int _lineStartOffset)
 701         JSTextPosition divot(m_scopeNode-&gt;firstLine(), m_scopeNode-&gt;startOffset(), m_scopeNode-&gt;lineStartOffset());
 702         emitCall(promiseCapabilityRegister(), newPromiseCapability.get(), NoExpectedFunction, args, divot, divot, divot, DebuggableCall::No);
 703         break;
 704     }
 705 
 706     case SourceParseMode::AsyncGeneratorBodyMode:
 707     case SourceParseMode::AsyncFunctionBodyMode:
 708     case SourceParseMode::AsyncArrowFunctionBodyMode:
 709     case SourceParseMode::GeneratorBodyMode: {
 710         // |this| is already filled correctly before here.
<span class="line-modified"> 711         emitLoad(m_newTargetRegister, jsUndefined());</span>

 712         break;
 713     }
 714 
 715     default: {
 716         if (SourceParseMode::ArrowFunctionMode != parseMode) {
 717             if (isConstructor()) {
<span class="line-modified"> 718                 move(m_newTargetRegister, &amp;m_thisRegister);</span>

 719                 if (constructorKind() == ConstructorKind::Extends) {
 720                     moveEmptyValue(&amp;m_thisRegister);
 721                 } else
 722                     emitCreateThis(&amp;m_thisRegister);
 723             } else if (constructorKind() != ConstructorKind::None)
 724                 emitThrowTypeError(&quot;Cannot call a class constructor without |new|&quot;);
 725             else {
 726                 bool shouldEmitToThis = false;
 727                 if (functionNode-&gt;usesThis() || codeBlock-&gt;usesEval() || m_scopeNode-&gt;doAnyInnerArrowFunctionsUseThis() || m_scopeNode-&gt;doAnyInnerArrowFunctionsUseEval())
 728                     shouldEmitToThis = true;
 729                 else if ((functionNode-&gt;usesSuperProperty() || m_scopeNode-&gt;doAnyInnerArrowFunctionsUseSuperProperty()) &amp;&amp; !codeBlock-&gt;isStrictMode()) {
 730                     // We must emit to_this when we&#39;re not in strict mode because we
 731                     // will convert |this| to an object, and that object may be passed
 732                     // to a strict function as |this|. This is observable because that
 733                     // strict function&#39;s to_this will just return the object.
 734                     //
 735                     // We don&#39;t need to emit this for strict-mode code because
 736                     // strict-mode code may call another strict function, which will
 737                     // to_this if it directly uses this; this is OK, because we defer
 738                     // to_this until |this| is used directly. Strict-mode code might
 739                     // also call a sloppy mode function, and that will to_this, which
 740                     // will defer the conversion, again, until necessary.
 741                     shouldEmitToThis = true;
 742                 }
 743 
 744                 if (shouldEmitToThis)
 745                     emitToThis();
 746             }
 747         }
 748         break;
 749     }
 750     }
 751 
 752     // We need load |super| &amp; |this| for arrow function before initializeDefaultParameterValuesAndSetupFunctionScopeStack
 753     // if we have default parameter expression. Because |super| &amp; |this| values can be used there
 754     if ((SourceParseModeSet(SourceParseMode::ArrowFunctionMode, SourceParseMode::AsyncArrowFunctionMode).contains(parseMode) &amp;&amp; !isSimpleParameterList) || parseMode == SourceParseMode::AsyncArrowFunctionBodyMode) {
 755         if (functionNode-&gt;usesThis() || functionNode-&gt;usesSuperProperty())
 756             emitLoadThisFromArrowFunctionLexicalEnvironment();
 757 
<span class="line-modified"> 758         if (m_scopeNode-&gt;usesNewTarget() || m_scopeNode-&gt;usesSuperCall())</span>
 759             emitLoadNewTargetFromArrowFunctionLexicalEnvironment();
 760     }
 761 
 762     if (needsToUpdateArrowFunctionContext() &amp;&amp; !codeBlock-&gt;isArrowFunction()) {
 763         bool canReuseLexicalEnvironment = isSimpleParameterList;
 764         initializeArrowFunctionContextScopeIfNeeded(functionSymbolTable, canReuseLexicalEnvironment);
 765         emitPutThisToArrowFunctionContextScope();
 766         emitPutNewTargetToArrowFunctionContextScope();
 767         emitPutDerivedConstructorToArrowFunctionContextScope();
 768     }
 769 
 770     // All &quot;addVar()&quot;s needs to happen before &quot;initializeDefaultParameterValuesAndSetupFunctionScopeStack()&quot; is called
 771     // because a function&#39;s default parameter ExpressionNodes will use temporary registers.
 772     pushTDZVariables(*parentScopeTDZVariables, TDZCheckOptimization::DoNotOptimize, TDZRequirement::UnderTDZ);
 773 
 774     Ref&lt;Label&gt; catchLabel = newLabel();
 775     TryData* tryFormalParametersData = nullptr;
 776     bool needTryCatch = isAsyncFunctionWrapperParseMode(parseMode) &amp;&amp; !isSimpleParameterList;
 777     if (needTryCatch) {
 778         Ref&lt;Label&gt; tryFormalParametersStart = newEmittedLabel();
 779         tryFormalParametersData = pushTry(tryFormalParametersStart.get(), catchLabel.get(), HandlerType::SynthesizedCatch);
 780     }
 781 
 782     initializeDefaultParameterValuesAndSetupFunctionScopeStack(parameters, isSimpleParameterList, functionNode, functionSymbolTable, symbolTableConstantIndex, captures, shouldCreateArgumentsVariableInParameterScope);
 783 
 784     if (needTryCatch) {
 785         Ref&lt;Label&gt; didNotThrow = newLabel();
 786         emitJump(didNotThrow.get());
 787         emitLabel(catchLabel.get());
 788         popTry(tryFormalParametersData, catchLabel.get());
 789 
 790         RefPtr&lt;RegisterID&gt; thrownValue = newTemporary();
<span class="line-modified"> 791         RegisterID* unused = newTemporary();</span>
<span class="line-removed"> 792         emitCatch(unused, thrownValue.get(), tryFormalParametersData);</span>
 793 
 794         // return promiseCapability.@reject(thrownValue)
<span class="line-modified"> 795         RefPtr&lt;RegisterID&gt; reject = emitGetById(newTemporary(), promiseCapabilityRegister(), m_vm-&gt;propertyNames-&gt;builtinNames().rejectPrivateName());</span>
 796 
 797         CallArguments args(*this, nullptr, 1);
 798         emitLoad(args.thisRegister(), jsUndefined());
 799         move(args.argumentRegister(0), thrownValue.get());
 800 
 801         JSTextPosition divot(functionNode-&gt;firstLine(), functionNode-&gt;startOffset(), functionNode-&gt;lineStartOffset());
 802 
 803         RefPtr&lt;RegisterID&gt; result = emitCall(newTemporary(), reject.get(), NoExpectedFunction, args, divot, divot, divot, DebuggableCall::No);
<span class="line-modified"> 804         emitReturn(emitGetById(newTemporary(), promiseCapabilityRegister(), m_vm-&gt;propertyNames-&gt;builtinNames().promisePrivateName()));</span>
 805 
 806         emitLabel(didNotThrow.get());
 807     }
 808 
 809     // If we don&#39;t have  default parameter expression, then loading |this| inside an arrow function must be done
 810     // after initializeDefaultParameterValuesAndSetupFunctionScopeStack() because that function sets up the
 811     // SymbolTable stack and emitLoadThisFromArrowFunctionLexicalEnvironment() consults the SymbolTable stack
 812     if (SourceParseModeSet(SourceParseMode::ArrowFunctionMode, SourceParseMode::AsyncArrowFunctionMode).contains(parseMode) &amp;&amp; isSimpleParameterList) {
 813         if (functionNode-&gt;usesThis() || functionNode-&gt;usesSuperProperty())
 814             emitLoadThisFromArrowFunctionLexicalEnvironment();
 815 
<span class="line-modified"> 816         if (m_scopeNode-&gt;usesNewTarget() || m_scopeNode-&gt;usesSuperCall())</span>
 817             emitLoadNewTargetFromArrowFunctionLexicalEnvironment();
 818     }
 819 
 820     // Set up the lexical environment scope as the generator frame. We store the saved and resumed generator registers into this scope with the symbol keys.
 821     // Since they are symbol keyed, these variables cannot be reached from the usual code.
 822     if (isGeneratorOrAsyncFunctionBodyParseMode(parseMode)) {
<span class="line-modified"> 823         ASSERT(m_lexicalEnvironmentRegister);</span>
<span class="line-removed"> 824         m_generatorFrameSymbolTable.set(*m_vm, functionSymbolTable);</span>
 825         m_generatorFrameSymbolTableIndex = symbolTableConstantIndex;
<span class="line-modified"> 826         move(generatorFrameRegister(), m_lexicalEnvironmentRegister);</span>








 827         emitPutById(generatorRegister(), propertyNames().builtinNames().generatorFramePrivateName(), generatorFrameRegister());
 828     }
 829 
 830     bool shouldInitializeBlockScopedFunctions = false; // We generate top-level function declarations in ::generate().
 831     pushLexicalScope(m_scopeNode, TDZCheckOptimization::Optimize, NestedScopeType::IsNotNested, nullptr, shouldInitializeBlockScopedFunctions);
 832 }
 833 
<span class="line-modified"> 834 BytecodeGenerator::BytecodeGenerator(VM&amp; vm, EvalNode* evalNode, UnlinkedEvalCodeBlock* codeBlock, DebuggerMode debuggerMode, const VariableEnvironment* parentScopeTDZVariables)</span>
<span class="line-modified"> 835     : m_shouldEmitDebugHooks(Options::forceDebuggerBytecodeGeneration() || debuggerMode == DebuggerOn)</span>
 836     , m_scopeNode(evalNode)
 837     , m_codeBlock(vm, codeBlock)
 838     , m_thisRegister(CallFrame::thisArgumentOffset())
 839     , m_codeType(EvalCode)
<span class="line-modified"> 840     , m_vm(&amp;vm)</span>
 841     , m_usesNonStrictEval(codeBlock-&gt;usesEval() &amp;&amp; !codeBlock-&gt;isStrictMode())
 842     , m_needsToUpdateArrowFunctionContext(evalNode-&gt;usesArrowFunction() || evalNode-&gt;usesEval())
 843     , m_derivedContextType(codeBlock-&gt;derivedContextType())
 844 {
 845     for (auto&amp; constantRegister : m_linkTimeConstantRegisters)
 846         constantRegister = nullptr;
 847 
 848     allocateCalleeSaveSpace();
 849 
 850     m_codeBlock-&gt;setNumParameters(1);
 851 
 852     pushTDZVariables(*parentScopeTDZVariables, TDZCheckOptimization::DoNotOptimize, TDZRequirement::UnderTDZ);
 853 
 854     emitEnter();
 855 
 856     allocateAndEmitScope();
 857 
<span class="line-removed"> 858     emitCheckTraps();</span>
<span class="line-removed"> 859 </span>
 860     for (FunctionMetadataNode* function : evalNode-&gt;functionStack()) {
 861         m_codeBlock-&gt;addFunctionDecl(makeFunction(function));
 862         m_functionsToInitialize.append(std::make_pair(function, TopLevelFunctionVariable));
 863     }
 864 
 865     const VariableEnvironment&amp; varDeclarations = evalNode-&gt;varDeclarations();
 866     Vector&lt;Identifier, 0, UnsafeVectorOverflow&gt; variables;
 867     Vector&lt;Identifier, 0, UnsafeVectorOverflow&gt; hoistedFunctions;
 868     for (auto&amp; entry : varDeclarations) {
 869         ASSERT(entry.value.isVar());
<span class="line-modified"> 870         ASSERT(entry.key-&gt;isAtomic() || entry.key-&gt;isSymbol());</span>
 871         if (entry.value.isSloppyModeHoistingCandidate())
 872             hoistedFunctions.append(Identifier::fromUid(m_vm, entry.key.get()));
 873         else
 874             variables.append(Identifier::fromUid(m_vm, entry.key.get()));
 875     }
 876     codeBlock-&gt;adoptVariables(variables);
 877     codeBlock-&gt;adoptFunctionHoistingCandidates(WTFMove(hoistedFunctions));
 878 
<span class="line-modified"> 879     if (evalNode-&gt;usesSuperCall() || evalNode-&gt;usesNewTarget())</span>
 880         m_newTargetRegister = addVar();
 881 
 882     if (codeBlock-&gt;isArrowFunctionContext() &amp;&amp; (evalNode-&gt;usesThis() || evalNode-&gt;usesSuperProperty()))
 883         emitLoadThisFromArrowFunctionLexicalEnvironment();
 884 
<span class="line-modified"> 885     if (evalNode-&gt;usesSuperCall() || evalNode-&gt;usesNewTarget())</span>
 886         emitLoadNewTargetFromArrowFunctionLexicalEnvironment();
 887 
 888     if (needsToUpdateArrowFunctionContext() &amp;&amp; !codeBlock-&gt;isArrowFunctionContext() &amp;&amp; !isDerivedConstructorContext()) {
 889         initializeArrowFunctionContextScopeIfNeeded();
 890         emitPutThisToArrowFunctionContextScope();
 891     }
 892 
 893     bool shouldInitializeBlockScopedFunctions = false; // We generate top-level function declarations in ::generate().
 894     pushLexicalScope(m_scopeNode, TDZCheckOptimization::Optimize, NestedScopeType::IsNotNested, nullptr, shouldInitializeBlockScopedFunctions);
 895 }
 896 
<span class="line-modified"> 897 BytecodeGenerator::BytecodeGenerator(VM&amp; vm, ModuleProgramNode* moduleProgramNode, UnlinkedModuleProgramCodeBlock* codeBlock, DebuggerMode debuggerMode, const VariableEnvironment* parentScopeTDZVariables)</span>
<span class="line-modified"> 898     : m_shouldEmitDebugHooks(Options::forceDebuggerBytecodeGeneration() || debuggerMode == DebuggerOn)</span>
 899     , m_scopeNode(moduleProgramNode)
 900     , m_codeBlock(vm, codeBlock)
 901     , m_thisRegister(CallFrame::thisArgumentOffset())
 902     , m_codeType(ModuleCode)
<span class="line-modified"> 903     , m_vm(&amp;vm)</span>
 904     , m_usesNonStrictEval(false)
 905     , m_needsToUpdateArrowFunctionContext(moduleProgramNode-&gt;usesArrowFunction() || moduleProgramNode-&gt;usesEval())
 906 {
 907     ASSERT_UNUSED(parentScopeTDZVariables, !parentScopeTDZVariables-&gt;size());
 908 
 909     for (auto&amp; constantRegister : m_linkTimeConstantRegisters)
 910         constantRegister = nullptr;
 911 
<span class="line-removed"> 912     if (m_isBuiltinFunction)</span>
<span class="line-removed"> 913         m_shouldEmitDebugHooks = false;</span>
<span class="line-removed"> 914 </span>
 915     allocateCalleeSaveSpace();
 916 
<span class="line-modified"> 917     SymbolTable* moduleEnvironmentSymbolTable = SymbolTable::create(*m_vm);</span>
 918     moduleEnvironmentSymbolTable-&gt;setUsesNonStrictEval(m_usesNonStrictEval);
 919     moduleEnvironmentSymbolTable-&gt;setScopeType(SymbolTable::ScopeType::LexicalScope);
 920 
<span class="line-modified"> 921     bool shouldCaptureAllOfTheThings = m_shouldEmitDebugHooks || codeBlock-&gt;usesEval();</span>
 922     if (shouldCaptureAllOfTheThings)
 923         moduleProgramNode-&gt;varDeclarations().markAllVariablesAsCaptured();
 924 
 925     auto captures = [&amp;] (UniquedStringImpl* uid) -&gt; bool {
 926         return moduleProgramNode-&gt;captures(uid);
 927     };
 928     auto lookUpVarKind = [&amp;] (UniquedStringImpl* uid, const VariableEnvironmentEntry&amp; entry) -&gt; VarKind {
 929         // Allocate the exported variables in the module environment.
 930         if (entry.isExported())
 931             return VarKind::Scope;
 932 
 933         // Allocate the namespace variables in the module environment to instantiate
 934         // it from the outside of the module code.
 935         if (entry.isImportedNamespace())
 936             return VarKind::Scope;
 937 
 938         if (entry.isCaptured())
 939             return VarKind::Scope;
 940         return captures(uid) ? VarKind::Scope : VarKind::Stack;
 941     };
 942 
 943     emitEnter();
 944 
 945     allocateAndEmitScope();
 946 
<span class="line-removed"> 947     emitCheckTraps();</span>
<span class="line-removed"> 948 </span>
 949     m_calleeRegister.setIndex(CallFrameSlot::callee);
 950 
 951     m_codeBlock-&gt;setNumParameters(1); // Allocate space for &quot;this&quot;
 952 
 953     // Now declare all variables.
 954 
<span class="line-modified"> 955     createVariable(m_vm-&gt;propertyNames-&gt;builtinNames().metaPrivateName(), VarKind::Scope, moduleEnvironmentSymbolTable, VerifyExisting);</span>
 956 
 957     for (auto&amp; entry : moduleProgramNode-&gt;varDeclarations()) {
 958         ASSERT(!entry.value.isLet() &amp;&amp; !entry.value.isConst());
 959         if (!entry.value.isVar()) // This is either a parameter or callee.
 960             continue;
 961         // Imported bindings are not allocated in the module environment as usual variables&#39; way.
 962         // These references remain the &quot;Dynamic&quot; in the unlinked code block. Later, when linking
 963         // the code block, we resolve the reference to the &quot;ModuleVar&quot;.
 964         if (entry.value.isImported() &amp;&amp; !entry.value.isImportedNamespace())
 965             continue;
 966         createVariable(Identifier::fromUid(m_vm, entry.key.get()), lookUpVarKind(entry.key.get(), entry.value), moduleEnvironmentSymbolTable, IgnoreExisting);
 967     }
 968 
 969     VariableEnvironment&amp; lexicalVariables = moduleProgramNode-&gt;lexicalVariables();
 970     instantiateLexicalVariables(lexicalVariables, moduleEnvironmentSymbolTable, ScopeRegisterType::Block, lookUpVarKind);
 971 
 972     // We keep the symbol table in the constant pool.
 973     RegisterID* constantSymbolTable = nullptr;
<span class="line-modified"> 974     if (vm.typeProfiler())</span>
 975         constantSymbolTable = addConstantValue(moduleEnvironmentSymbolTable);
 976     else
<span class="line-modified"> 977         constantSymbolTable = addConstantValue(moduleEnvironmentSymbolTable-&gt;cloneScopePart(*m_vm));</span>
 978 
 979     pushTDZVariables(lexicalVariables, TDZCheckOptimization::Optimize, TDZRequirement::UnderTDZ);
 980     bool isWithScope = false;
 981     m_lexicalScopeStack.append({ moduleEnvironmentSymbolTable, m_topMostScope, isWithScope, constantSymbolTable-&gt;index() });
 982     emitPrefillStackTDZVariables(lexicalVariables, moduleEnvironmentSymbolTable);
 983 
 984     // makeFunction assumes that there&#39;s correct TDZ stack entries.
 985     // So it should be called after putting our lexical environment to the TDZ stack correctly.
 986 
 987     for (FunctionMetadataNode* function : moduleProgramNode-&gt;functionStack()) {
 988         const auto&amp; iterator = moduleProgramNode-&gt;varDeclarations().find(function-&gt;ident().impl());
 989         RELEASE_ASSERT(iterator != moduleProgramNode-&gt;varDeclarations().end());
 990         RELEASE_ASSERT(!iterator-&gt;value.isImported());
 991 
 992         VarKind varKind = lookUpVarKind(iterator-&gt;key.get(), iterator-&gt;value);
 993         if (varKind == VarKind::Scope) {
 994             // http://www.ecma-international.org/ecma-262/6.0/#sec-moduledeclarationinstantiation
 995             // Section 15.2.1.16.4, step 16-a-iv-1.
 996             // All heap allocated function declarations should be instantiated when the module environment
 997             // is created. They include the exported function declarations and not-exported-but-heap-allocated
</pre>
<hr />
<pre>
1304 
1305     // Allocate new label ID.
1306     m_labels.append();
1307     return m_labels.last();
1308 }
1309 
1310 Ref&lt;Label&gt; BytecodeGenerator::newEmittedLabel()
1311 {
1312     Ref&lt;Label&gt; label = newLabel();
1313     emitLabel(label.get());
1314     return label;
1315 }
1316 
1317 void BytecodeGenerator::recordOpcode(OpcodeID opcodeID)
1318 {
1319     ASSERT(m_lastOpcodeID == op_end || (m_lastOpcodeID == m_lastInstruction-&gt;opcodeID() &amp;&amp; m_writer.position() == m_lastInstruction.offset() + m_lastInstruction-&gt;size()));
1320     m_lastInstruction = m_writer.ref();
1321     m_lastOpcodeID = opcodeID;
1322 }
1323 
<span class="line-modified">1324 void BytecodeGenerator::alignWideOpcode()</span>








1325 {
1326 #if CPU(NEEDS_ALIGNED_ACCESS)
<span class="line-modified">1327     while ((m_writer.position() + 1) % OpcodeSize::Wide)</span>
1328         OpNop::emit&lt;OpcodeSize::Narrow&gt;(this);
1329 #endif
1330 }
1331 
1332 void BytecodeGenerator::emitLabel(Label&amp; l0)
1333 {
1334     unsigned newLabelIndex = instructions().size();
1335     l0.setLocation(*this, newLabelIndex);
1336 
1337     if (m_codeBlock-&gt;numberOfJumpTargets()) {
1338         unsigned lastLabelIndex = m_codeBlock-&gt;lastJumpTarget();
1339         ASSERT(lastLabelIndex &lt;= newLabelIndex);
1340         if (newLabelIndex == lastLabelIndex) {
1341             // Peephole optimizations have already been disabled by emitting the last label
1342             return;
1343         }
1344     }
1345 
1346     m_codeBlock-&gt;addJumpTarget(newLabelIndex);
1347 
1348     // This disables peephole optimizations when an instruction is a jump target
1349     m_lastOpcodeID = op_end;
1350 }
1351 
1352 void BytecodeGenerator::emitEnter()
1353 {
1354     OpEnter::emit(this);
1355 
1356     if (LIKELY(Options::optimizeRecursiveTailCalls())) {
1357         // We must add the end of op_enter as a potential jump target, because the bytecode parser may decide to split its basic block
1358         // to have somewhere to jump to if there is a recursive tail-call that points to this function.
1359         m_codeBlock-&gt;addJumpTarget(instructions().size());
1360         // This disables peephole optimizations when an instruction is a jump target
1361         m_lastOpcodeID = op_end;
1362     }
1363 }
1364 
1365 void BytecodeGenerator::emitLoopHint()
1366 {
1367     OpLoopHint::emit(this);
<span class="line-removed">1368     emitCheckTraps();</span>
1369 }
1370 
1371 void BytecodeGenerator::emitJump(Label&amp; target)
1372 {
1373     OpJmp::emit(this, target.bind(this));
1374 }
1375 
<span class="line-removed">1376 void BytecodeGenerator::emitCheckTraps()</span>
<span class="line-removed">1377 {</span>
<span class="line-removed">1378     OpCheckTraps::emit(this);</span>
<span class="line-removed">1379 }</span>
<span class="line-removed">1380 </span>
1381 void ALWAYS_INLINE BytecodeGenerator::rewind()
1382 {
1383     ASSERT(m_lastInstruction.isValid());
1384     m_lastOpcodeID = op_end;
1385     m_writer.rewind(m_lastInstruction);
1386 }
1387 
1388 template&lt;typename BinOp, typename JmpOp&gt;
1389 bool BytecodeGenerator::fuseCompareAndJump(RegisterID* cond, Label&amp; target, bool swapOperands)
1390 {

1391     auto binop = m_lastInstruction-&gt;as&lt;BinOp&gt;();
1392     if (cond-&gt;index() == binop.m_dst.offset() &amp;&amp; cond-&gt;isTemporary() &amp;&amp; !cond-&gt;refCount()) {
1393         rewind();
1394 
1395         if (swapOperands)
1396             std::swap(binop.m_lhs, binop.m_rhs);
1397 
1398         JmpOp::emit(this, binop.m_lhs, binop.m_rhs, target.bind(this));
1399         return true;
1400     }
1401     return false;
1402 }
1403 
1404 template&lt;typename UnaryOp, typename JmpOp&gt;
1405 bool BytecodeGenerator::fuseTestAndJmp(RegisterID* cond, Label&amp; target)
1406 {

1407     auto unop = m_lastInstruction-&gt;as&lt;UnaryOp&gt;();
1408     if (cond-&gt;index() == unop.m_dst.offset() &amp;&amp; cond-&gt;isTemporary() &amp;&amp; !cond-&gt;refCount()) {
1409         rewind();
1410 
1411         JmpOp::emit(this, unop.m_operand, target.bind(this));
1412         return true;
1413     }
1414     return false;
1415 }
1416 
1417 void BytecodeGenerator::emitJumpIfTrue(RegisterID* cond, Label&amp; target)
1418 {
<span class="line-modified">1419 </span>
<span class="line-modified">1420     if (m_lastOpcodeID == op_less) {</span>
<span class="line-modified">1421         if (fuseCompareAndJump&lt;OpLess, OpJless&gt;(cond, target))</span>
<span class="line-modified">1422             return;</span>
<span class="line-modified">1423     } else if (m_lastOpcodeID == op_lesseq) {</span>
<span class="line-modified">1424         if (fuseCompareAndJump&lt;OpLesseq, OpJlesseq&gt;(cond, target))</span>
<span class="line-modified">1425             return;</span>
<span class="line-modified">1426     } else if (m_lastOpcodeID == op_greater) {</span>
<span class="line-modified">1427         if (fuseCompareAndJump&lt;OpGreater, OpJgreater&gt;(cond, target))</span>
<span class="line-modified">1428             return;</span>
<span class="line-modified">1429     } else if (m_lastOpcodeID == op_greatereq) {</span>
<span class="line-modified">1430         if (fuseCompareAndJump&lt;OpGreatereq, OpJgreatereq&gt;(cond, target))</span>
<span class="line-modified">1431             return;</span>
<span class="line-modified">1432     } else if (m_lastOpcodeID == op_eq) {</span>
<span class="line-modified">1433         if (fuseCompareAndJump&lt;OpEq, OpJeq&gt;(cond, target))</span>
<span class="line-modified">1434             return;</span>
<span class="line-modified">1435     } else if (m_lastOpcodeID == op_stricteq) {</span>
<span class="line-modified">1436         if (fuseCompareAndJump&lt;OpStricteq, OpJstricteq&gt;(cond, target))</span>
<span class="line-modified">1437             return;</span>
<span class="line-modified">1438     } else if (m_lastOpcodeID == op_neq) {</span>
<span class="line-modified">1439         if (fuseCompareAndJump&lt;OpNeq, OpJneq&gt;(cond, target))</span>
<span class="line-modified">1440             return;</span>
<span class="line-modified">1441     } else if (m_lastOpcodeID == op_nstricteq) {</span>
<span class="line-modified">1442         if (fuseCompareAndJump&lt;OpNstricteq, OpJnstricteq&gt;(cond, target))</span>
<span class="line-modified">1443             return;</span>
<span class="line-modified">1444     } else if (m_lastOpcodeID == op_below) {</span>
<span class="line-modified">1445         if (fuseCompareAndJump&lt;OpBelow, OpJbelow&gt;(cond, target))</span>
<span class="line-modified">1446             return;</span>
<span class="line-modified">1447     } else if (m_lastOpcodeID == op_beloweq) {</span>
<span class="line-modified">1448         if (fuseCompareAndJump&lt;OpBeloweq, OpJbeloweq&gt;(cond, target))</span>
<span class="line-modified">1449             return;</span>
<span class="line-modified">1450     } else if (m_lastOpcodeID == op_eq_null &amp;&amp; target.isForward()) {</span>
<span class="line-modified">1451         if (fuseTestAndJmp&lt;OpEqNull, OpJeqNull&gt;(cond, target))</span>
<span class="line-modified">1452             return;</span>
<span class="line-modified">1453     } else if (m_lastOpcodeID == op_neq_null &amp;&amp; target.isForward()) {</span>
<span class="line-modified">1454         if (fuseTestAndJmp&lt;OpNeqNull, OpJneqNull&gt;(cond, target))</span>
<span class="line-modified">1455             return;</span>




1456     }
1457 
1458     OpJtrue::emit(this, cond, target.bind(this));
1459 }
1460 
1461 void BytecodeGenerator::emitJumpIfFalse(RegisterID* cond, Label&amp; target)
1462 {
<span class="line-modified">1463     if (m_lastOpcodeID == op_less &amp;&amp; target.isForward()) {</span>
<span class="line-modified">1464         if (fuseCompareAndJump&lt;OpLess, OpJnless&gt;(cond, target))</span>
<span class="line-modified">1465             return;</span>
<span class="line-modified">1466     } else if (m_lastOpcodeID == op_lesseq &amp;&amp; target.isForward()) {</span>
<span class="line-modified">1467         if (fuseCompareAndJump&lt;OpLesseq, OpJnlesseq&gt;(cond, target))</span>
<span class="line-modified">1468             return;</span>
<span class="line-modified">1469     } else if (m_lastOpcodeID == op_greater &amp;&amp; target.isForward()) {</span>
<span class="line-modified">1470         if (fuseCompareAndJump&lt;OpGreater, OpJngreater&gt;(cond, target))</span>
<span class="line-modified">1471             return;</span>
<span class="line-modified">1472     } else if (m_lastOpcodeID == op_greatereq &amp;&amp; target.isForward()) {</span>
<span class="line-modified">1473         if (fuseCompareAndJump&lt;OpGreatereq, OpJngreatereq&gt;(cond, target))</span>
<span class="line-modified">1474             return;</span>
<span class="line-modified">1475     } else if (m_lastOpcodeID == op_eq &amp;&amp; target.isForward()) {</span>
<span class="line-modified">1476         if (fuseCompareAndJump&lt;OpEq, OpJneq&gt;(cond, target))</span>
<span class="line-modified">1477             return;</span>
<span class="line-modified">1478     } else if (m_lastOpcodeID == op_stricteq &amp;&amp; target.isForward()) {</span>
<span class="line-modified">1479         if (fuseCompareAndJump&lt;OpStricteq, OpJnstricteq&gt;(cond, target))</span>
<span class="line-modified">1480             return;</span>
<span class="line-modified">1481     } else if (m_lastOpcodeID == op_neq &amp;&amp; target.isForward()) {</span>
<span class="line-modified">1482         if (fuseCompareAndJump&lt;OpNeq, OpJeq&gt;(cond, target))</span>
<span class="line-modified">1483             return;</span>
<span class="line-modified">1484     } else if (m_lastOpcodeID == op_nstricteq &amp;&amp; target.isForward()) {</span>
<span class="line-modified">1485         if (fuseCompareAndJump&lt;OpNstricteq, OpJstricteq&gt;(cond, target))</span>
<span class="line-modified">1486             return;</span>
<span class="line-modified">1487     } else if (m_lastOpcodeID == op_below &amp;&amp; target.isForward()) {</span>
<span class="line-modified">1488         if (fuseCompareAndJump&lt;OpBelow, OpJbeloweq&gt;(cond, target, true))</span>
<span class="line-modified">1489             return;</span>
<span class="line-modified">1490     } else if (m_lastOpcodeID == op_beloweq &amp;&amp; target.isForward()) {</span>
<span class="line-modified">1491         if (fuseCompareAndJump&lt;OpBeloweq, OpJbelow&gt;(cond, target, true))</span>
<span class="line-modified">1492             return;</span>
<span class="line-modified">1493     } else if (m_lastOpcodeID == op_not) {</span>
<span class="line-modified">1494         if (fuseTestAndJmp&lt;OpNot, OpJtrue&gt;(cond, target))</span>
<span class="line-modified">1495             return;</span>
<span class="line-modified">1496     } else if (m_lastOpcodeID == op_eq_null &amp;&amp; target.isForward()) {</span>
<span class="line-modified">1497         if (fuseTestAndJmp&lt;OpEqNull, OpJneqNull&gt;(cond, target))</span>
<span class="line-modified">1498             return;</span>
<span class="line-modified">1499     } else if (m_lastOpcodeID == op_neq_null &amp;&amp; target.isForward()) {</span>
<span class="line-modified">1500         if (fuseTestAndJmp&lt;OpNeqNull, OpJeqNull&gt;(cond, target))</span>
<span class="line-modified">1501             return;</span>





1502     }
1503 
1504     OpJfalse::emit(this, cond, target.bind(this));
1505 }
1506 
1507 void BytecodeGenerator::emitJumpIfNotFunctionCall(RegisterID* cond, Label&amp; target)
1508 {
1509     OpJneqPtr::emit(this, cond, Special::CallFunction, target.bind(this));
1510 }
1511 
1512 void BytecodeGenerator::emitJumpIfNotFunctionApply(RegisterID* cond, Label&amp; target)
1513 {
1514     OpJneqPtr::emit(this, cond, Special::ApplyFunction, target.bind(this));
1515 }
1516 
1517 bool BytecodeGenerator::hasConstant(const Identifier&amp; ident) const
1518 {
1519     UniquedStringImpl* rep = ident.impl();
1520     return m_identifierMap.contains(rep);
1521 }
</pre>
<hr />
<pre>
1687     return emitUnaryOp&lt;OpToString&gt;(dst, src);
1688 }
1689 
1690 RegisterID* BytecodeGenerator::emitTypeOf(RegisterID* dst, RegisterID* src)
1691 {
1692     return emitUnaryOp&lt;OpTypeof&gt;(dst, src);
1693 }
1694 
1695 RegisterID* BytecodeGenerator::emitInc(RegisterID* srcDst)
1696 {
1697     OpInc::emit(this, srcDst);
1698     return srcDst;
1699 }
1700 
1701 RegisterID* BytecodeGenerator::emitDec(RegisterID* srcDst)
1702 {
1703     OpDec::emit(this, srcDst);
1704     return srcDst;
1705 }
1706 
<span class="line-modified">1707 template&lt;typename EqOp&gt;</span>
<span class="line-removed">1708 RegisterID* BytecodeGenerator::emitEqualityOp(RegisterID* dst, RegisterID* src1, RegisterID* src2)</span>
1709 {



1710     if (m_lastInstruction-&gt;is&lt;OpTypeof&gt;()) {
1711         auto op = m_lastInstruction-&gt;as&lt;OpTypeof&gt;();
1712         if (src1-&gt;index() == op.m_dst.offset()
1713             &amp;&amp; src1-&gt;isTemporary()
1714             &amp;&amp; m_codeBlock-&gt;isConstantRegisterIndex(src2-&gt;index())
1715             &amp;&amp; m_codeBlock-&gt;constantRegister(src2-&gt;index()).get().isString()) {
1716             const String&amp; value = asString(m_codeBlock-&gt;constantRegister(src2-&gt;index()).get())-&gt;tryGetValue();
1717             if (value == &quot;undefined&quot;) {
1718                 rewind();
1719                 OpIsUndefined::emit(this, dst, op.m_value);
<span class="line-modified">1720                 return dst;</span>
1721             }
1722             if (value == &quot;boolean&quot;) {
1723                 rewind();
1724                 OpIsBoolean::emit(this, dst, op.m_value);
<span class="line-modified">1725                 return dst;</span>
1726             }
1727             if (value == &quot;number&quot;) {
1728                 rewind();
1729                 OpIsNumber::emit(this, dst, op.m_value);
<span class="line-modified">1730                 return dst;</span>
1731             }
1732             if (value == &quot;string&quot;) {
1733                 rewind();
1734                 OpIsCellWithType::emit(this, dst, op.m_value, StringType);
<span class="line-modified">1735                 return dst;</span>
1736             }
1737             if (value == &quot;symbol&quot;) {
1738                 rewind();
1739                 OpIsCellWithType::emit(this, dst, op.m_value, SymbolType);
<span class="line-modified">1740                 return dst;</span>
1741             }
1742             if (Options::useBigInt() &amp;&amp; value == &quot;bigint&quot;) {
1743                 rewind();
1744                 OpIsCellWithType::emit(this, dst, op.m_value, BigIntType);
<span class="line-modified">1745                 return dst;</span>
1746             }
1747             if (value == &quot;object&quot;) {
1748                 rewind();
1749                 OpIsObjectOrNull::emit(this, dst, op.m_value);
<span class="line-modified">1750                 return dst;</span>
1751             }
1752             if (value == &quot;function&quot;) {
1753                 rewind();
1754                 OpIsFunction::emit(this, dst, op.m_value);
<span class="line-modified">1755                 return dst;</span>
1756             }
1757         }
1758     }
1759 
<span class="line-modified">1760     EqOp::emit(this, dst, src1, src2);</span>
<span class="line-removed">1761     return dst;</span>
1762 }
1763 
1764 void BytecodeGenerator::emitTypeProfilerExpressionInfo(const JSTextPosition&amp; startDivot, const JSTextPosition&amp; endDivot)
1765 {
<span class="line-modified">1766     ASSERT(vm()-&gt;typeProfiler());</span>
1767 
1768     unsigned start = startDivot.offset; // Ranges are inclusive of their endpoints, AND 0 indexed.
1769     unsigned end = endDivot.offset - 1; // End Ranges already go one past the inclusive range, so subtract 1.
1770     unsigned instructionOffset = instructions().size() - 1;
1771     m_codeBlock-&gt;addTypeProfilerExpressionInfo(instructionOffset, start, end);
1772 }
1773 
1774 void BytecodeGenerator::emitProfileType(RegisterID* registerToProfile, ProfileTypeBytecodeFlag flag)
1775 {
<span class="line-modified">1776     if (!vm()-&gt;typeProfiler())</span>
1777         return;
1778 
1779     if (!registerToProfile)
1780         return;
1781 
<span class="line-modified">1782     OpProfileType::emit(this, registerToProfile, 0, flag, { }, resolveType());</span>
1783 
1784     // Don&#39;t emit expression info for this version of profile type. This generally means
1785     // we&#39;re profiling information for something that isn&#39;t in the actual text of a JavaScript
1786     // program. For example, implicit return undefined from a function call.
1787 }
1788 
1789 void BytecodeGenerator::emitProfileType(RegisterID* registerToProfile, const JSTextPosition&amp; startDivot, const JSTextPosition&amp; endDivot)
1790 {
1791     emitProfileType(registerToProfile, ProfileTypeBytecodeDoesNotHaveGlobalID, startDivot, endDivot);
1792 }
1793 
1794 void BytecodeGenerator::emitProfileType(RegisterID* registerToProfile, ProfileTypeBytecodeFlag flag, const JSTextPosition&amp; startDivot, const JSTextPosition&amp; endDivot)
1795 {
<span class="line-modified">1796     if (!vm()-&gt;typeProfiler())</span>
1797         return;
1798 
1799     if (!registerToProfile)
1800         return;
1801 
<span class="line-modified">1802     OpProfileType::emit(this, registerToProfile, 0,  flag, { }, resolveType());</span>
1803     emitTypeProfilerExpressionInfo(startDivot, endDivot);
1804 }
1805 
1806 void BytecodeGenerator::emitProfileType(RegisterID* registerToProfile, const Variable&amp; var, const JSTextPosition&amp; startDivot, const JSTextPosition&amp; endDivot)
1807 {
<span class="line-modified">1808     if (!vm()-&gt;typeProfiler())</span>
1809         return;
1810 
1811     if (!registerToProfile)
1812         return;
1813 
1814     ProfileTypeBytecodeFlag flag;
<span class="line-modified">1815     int symbolTableOrScopeDepth;</span>
1816     if (var.local() || var.offset().isScope()) {
1817         flag = ProfileTypeBytecodeLocallyResolved;
1818         ASSERT(var.symbolTableConstantIndex());
<span class="line-modified">1819         symbolTableOrScopeDepth = var.symbolTableConstantIndex();</span>
1820     } else {
1821         flag = ProfileTypeBytecodeClosureVar;
<span class="line-modified">1822         symbolTableOrScopeDepth = localScopeDepth();</span>
1823     }
1824 
1825     OpProfileType::emit(this, registerToProfile, symbolTableOrScopeDepth, flag, addConstant(var.ident()), resolveType());
1826     emitTypeProfilerExpressionInfo(startDivot, endDivot);
1827 }
1828 
1829 void BytecodeGenerator::emitProfileControlFlow(int textOffset)
1830 {
<span class="line-modified">1831     if (vm()-&gt;controlFlowProfiler()) {</span>
1832         RELEASE_ASSERT(textOffset &gt;= 0);
1833 
1834         OpProfileControlFlow::emit(this, textOffset);
1835         m_codeBlock-&gt;addOpProfileControlFlowBytecodeOffset(m_lastInstruction.offset());
1836     }
1837 }
1838 
1839 unsigned BytecodeGenerator::addConstantIndex()
1840 {
1841     unsigned index = m_nextConstantOffset;
1842     m_constantPoolRegisters.append(FirstConstantRegisterIndex + m_nextConstantOffset);
1843     ++m_nextConstantOffset;
1844     return index;
1845 }
1846 
1847 RegisterID* BytecodeGenerator::emitLoad(RegisterID* dst, bool b)
1848 {
1849     return emitLoad(dst, jsBoolean(b));
1850 }
1851 
</pre>
<hr />
<pre>
1957 
1958 void BytecodeGenerator::pushLexicalScope(VariableEnvironmentNode* node, TDZCheckOptimization tdzCheckOptimization, NestedScopeType nestedScopeType, RegisterID** constantSymbolTableResult, bool shouldInitializeBlockScopedFunctions)
1959 {
1960     VariableEnvironment&amp; environment = node-&gt;lexicalVariables();
1961     RegisterID* constantSymbolTableResultTemp = nullptr;
1962     pushLexicalScopeInternal(environment, tdzCheckOptimization, nestedScopeType, &amp;constantSymbolTableResultTemp, TDZRequirement::UnderTDZ, ScopeType::LetConstScope, ScopeRegisterType::Block);
1963 
1964     if (shouldInitializeBlockScopedFunctions)
1965         initializeBlockScopedFunctions(environment, node-&gt;functionStack(), constantSymbolTableResultTemp);
1966 
1967     if (constantSymbolTableResult &amp;&amp; constantSymbolTableResultTemp)
1968         *constantSymbolTableResult = constantSymbolTableResultTemp;
1969 }
1970 
1971 void BytecodeGenerator::pushLexicalScopeInternal(VariableEnvironment&amp; environment, TDZCheckOptimization tdzCheckOptimization, NestedScopeType nestedScopeType,
1972     RegisterID** constantSymbolTableResult, TDZRequirement tdzRequirement, ScopeType scopeType, ScopeRegisterType scopeRegisterType)
1973 {
1974     if (!environment.size())
1975         return;
1976 
<span class="line-modified">1977     if (m_shouldEmitDebugHooks)</span>
1978         environment.markAllVariablesAsCaptured();
1979 
<span class="line-modified">1980     SymbolTable* symbolTable = SymbolTable::create(*m_vm);</span>
1981     switch (scopeType) {
1982     case ScopeType::CatchScope:
1983         symbolTable-&gt;setScopeType(SymbolTable::ScopeType::CatchScope);
1984         break;
1985     case ScopeType::LetConstScope:
1986         symbolTable-&gt;setScopeType(SymbolTable::ScopeType::LexicalScope);
1987         break;
1988     case ScopeType::FunctionNameScope:
1989         symbolTable-&gt;setScopeType(SymbolTable::ScopeType::FunctionNameScope);
1990         break;
1991     }
1992 
1993     if (nestedScopeType == NestedScopeType::IsNested)
1994         symbolTable-&gt;markIsNestedLexicalScope();
1995 
1996     auto lookUpVarKind = [] (UniquedStringImpl*, const VariableEnvironmentEntry&amp; entry) -&gt; VarKind {
1997         return entry.isCaptured() ? VarKind::Scope : VarKind::Stack;
1998     };
1999 
2000     bool hasCapturedVariables = instantiateLexicalVariables(environment, symbolTable, scopeRegisterType, lookUpVarKind);
2001 
2002     RegisterID* newScope = nullptr;
2003     RegisterID* constantSymbolTable = nullptr;
2004     int symbolTableConstantIndex = 0;
<span class="line-modified">2005     if (vm()-&gt;typeProfiler()) {</span>
2006         constantSymbolTable = addConstantValue(symbolTable);
2007         symbolTableConstantIndex = constantSymbolTable-&gt;index();
2008     }
2009     if (hasCapturedVariables) {
2010         if (scopeRegisterType == ScopeRegisterType::Block) {
2011             newScope = newBlockScopeVariable();
2012             newScope-&gt;ref();
2013         } else
2014             newScope = addVar();
2015         if (!constantSymbolTable) {
<span class="line-modified">2016             ASSERT(!vm()-&gt;typeProfiler());</span>
<span class="line-modified">2017             constantSymbolTable = addConstantValue(symbolTable-&gt;cloneScopePart(*m_vm));</span>
2018             symbolTableConstantIndex = constantSymbolTable-&gt;index();
2019         }
2020         if (constantSymbolTableResult)
2021             *constantSymbolTableResult = constantSymbolTable;
2022 
2023         OpCreateLexicalEnvironment::emit(this, newScope, scopeRegister(), VirtualRegister { symbolTableConstantIndex }, addConstantValue(tdzRequirement == TDZRequirement::UnderTDZ ? jsTDZValue() : jsUndefined()));
2024 
2025         move(scopeRegister(), newScope);
2026 
2027         pushLocalControlFlowScope();
2028     }
2029 
2030     bool isWithScope = false;
2031     m_lexicalScopeStack.append({ symbolTable, newScope, isWithScope, symbolTableConstantIndex });
2032     pushTDZVariables(environment, tdzCheckOptimization, tdzRequirement);
2033 
2034     if (tdzRequirement == TDZRequirement::UnderTDZ)
2035         emitPrefillStackTDZVariables(environment, symbolTable);
2036 }
2037 
</pre>
<hr />
<pre>
2151     ASSERT(m_codeType == EvalCode);
2152 
2153     dst = finalDestination(dst);
2154     OpResolveScopeForHoistingFuncDeclInEval::emit(this, kill(dst), m_topMostScope, addConstant(property));
2155     return dst;
2156 }
2157 
2158 void BytecodeGenerator::popLexicalScope(VariableEnvironmentNode* node)
2159 {
2160     VariableEnvironment&amp; environment = node-&gt;lexicalVariables();
2161     popLexicalScopeInternal(environment);
2162 }
2163 
2164 void BytecodeGenerator::popLexicalScopeInternal(VariableEnvironment&amp; environment)
2165 {
2166     // NOTE: This function only makes sense for scopes that aren&#39;t ScopeRegisterType::Var (only function name scope right now is ScopeRegisterType::Var).
2167     // This doesn&#39;t make sense for ScopeRegisterType::Var because we deref RegisterIDs here.
2168     if (!environment.size())
2169         return;
2170 
<span class="line-modified">2171     if (m_shouldEmitDebugHooks)</span>
2172         environment.markAllVariablesAsCaptured();
2173 
2174     auto stackEntry = m_lexicalScopeStack.takeLast();
2175     SymbolTable* symbolTable = stackEntry.m_symbolTable;
2176     bool hasCapturedVariables = false;
2177     for (auto&amp; entry : environment) {
2178         if (entry.value.isCaptured()) {
2179             hasCapturedVariables = true;
2180             continue;
2181         }
2182         SymbolTableEntry symbolTableEntry = symbolTable-&gt;get(NoLockingNecessary, entry.key.get());
2183         ASSERT(!symbolTableEntry.isNull());
2184         VarOffset offset = symbolTableEntry.varOffset();
2185         ASSERT(offset.isStack());
2186         RegisterID* local = &amp;registerFor(offset.stackOffset());
2187         local-&gt;deref();
2188     }
2189 
2190     if (hasCapturedVariables) {
2191         RELEASE_ASSERT(stackEntry.m_scope);
2192         emitPopScope(scopeRegister(), stackEntry.m_scope);
2193         popLocalControlFlowScope();
2194         stackEntry.m_scope-&gt;deref();
2195     }
2196 
2197     m_TDZStack.removeLast();
2198     m_cachedVariablesUnderTDZ = { };
2199 }
2200 
2201 void BytecodeGenerator::prepareLexicalScopeForNextForLoopIteration(VariableEnvironmentNode* node, RegisterID* loopSymbolTable)
2202 {
2203     VariableEnvironment&amp; environment = node-&gt;lexicalVariables();
2204     if (!environment.size())
2205         return;
<span class="line-modified">2206     if (m_shouldEmitDebugHooks)</span>
2207         environment.markAllVariablesAsCaptured();
2208     if (!environment.hasCapturedVariables())
2209         return;
2210 
2211     RELEASE_ASSERT(loopSymbolTable);
2212 
2213     // This function needs to do setup for a for loop&#39;s activation if any of
2214     // the for loop&#39;s lexically declared variables are captured (that is, variables
2215     // declared in the loop header, not the loop body). This function needs to
2216     // make a copy of the current activation and copy the values from the previous
2217     // activation into the new activation because each iteration of a for loop
2218     // gets a new activation.
2219 
2220     auto stackEntry = m_lexicalScopeStack.last();
2221     SymbolTable* symbolTable = stackEntry.m_symbolTable;
2222     RegisterID* loopScope = stackEntry.m_scope;
2223     ASSERT(symbolTable-&gt;scopeSize());
2224     ASSERT(loopScope);
2225     Vector&lt;std::pair&lt;RegisterID*, Identifier&gt;&gt; activationValuesToCopyOver;
2226 
</pre>
<hr />
<pre>
2471         return dst;
2472     } }
2473 
2474     RELEASE_ASSERT_NOT_REACHED();
2475 }
2476 
2477 RegisterID* BytecodeGenerator::emitPutToScope(RegisterID* scope, const Variable&amp; variable, RegisterID* value, ResolveMode resolveMode, InitializationMode initializationMode)
2478 {
2479     switch (variable.offset().kind()) {
2480     case VarKind::Stack:
2481         move(variable.local(), value);
2482         return value;
2483 
2484     case VarKind::DirectArgument:
2485         OpPutToArguments::emit(this, scope, variable.offset().capturedArgumentsOffset().offset(), value);
2486         return value;
2487 
2488     case VarKind::Scope:
2489     case VarKind::Invalid: {
2490         GetPutInfo getPutInfo(0);
<span class="line-modified">2491         int scopeDepth;</span>
2492         ScopeOffset offset;
2493         if (variable.offset().isScope()) {
2494             offset = variable.offset().scopeOffset();
2495             getPutInfo = GetPutInfo(resolveMode, LocalClosureVar, initializationMode);
<span class="line-modified">2496             scopeDepth = variable.symbolTableConstantIndex();</span>
2497         } else {
2498             ASSERT(resolveType() != LocalClosureVar);
2499             getPutInfo = GetPutInfo(resolveMode, resolveType(), initializationMode);
<span class="line-modified">2500             scopeDepth = localScopeDepth();</span>
2501         }
<span class="line-modified">2502         OpPutToScope::emit(this, scope, addConstant(variable.ident()), value, getPutInfo, scopeDepth, !!offset ? offset.offset() : 0);</span>
2503         m_codeBlock-&gt;addPropertyAccessInstruction(m_lastInstruction.offset());
2504         return value;
2505     } }
2506 
2507     RELEASE_ASSERT_NOT_REACHED();
2508 }
2509 
2510 RegisterID* BytecodeGenerator::initializeVariable(const Variable&amp; variable, RegisterID* value)
2511 {
2512     RELEASE_ASSERT(variable.offset().kind() != VarKind::Invalid);
2513     RegisterID* scope = emitResolveScope(nullptr, variable);
2514     return emitPutToScope(scope, variable, value, ThrowIfNotFound, InitializationMode::NotInitialization);
2515 }
2516 
2517 RegisterID* BytecodeGenerator::emitInstanceOf(RegisterID* dst, RegisterID* value, RegisterID* basePrototype)
2518 {
2519     OpInstanceof::emit(this, dst, value, basePrototype);
2520     return dst;
2521 }
2522 
</pre>
<hr />
<pre>
2588 
2589 RegisterID* BytecodeGenerator::emitPutById(RegisterID* base, RegisterID* thisValue, const Identifier&amp; property, RegisterID* value)
2590 {
2591     ASSERT_WITH_MESSAGE(!parseIndex(property), &quot;Indexed properties should be handled with put_by_val.&quot;);
2592 
2593     unsigned propertyIndex = addConstant(property);
2594 
2595     OpPutByIdWithThis::emit(this, base, thisValue, propertyIndex, value);
2596 
2597     return value;
2598 }
2599 
2600 RegisterID* BytecodeGenerator::emitDirectPutById(RegisterID* base, const Identifier&amp; property, RegisterID* value, PropertyNode::PutType putType)
2601 {
2602     ASSERT_WITH_MESSAGE(!parseIndex(property), &quot;Indexed properties should be handled with put_by_val(direct).&quot;);
2603 
2604     unsigned propertyIndex = addConstant(property);
2605 
2606     m_staticPropertyAnalyzer.putById(base, propertyIndex);
2607 
<span class="line-modified">2608     PutByIdFlags type = (putType == PropertyNode::KnownDirect || property != m_vm-&gt;propertyNames-&gt;underscoreProto) ? PutByIdIsDirect : PutByIdNone;</span>
2609     OpPutById::emit(this, base, propertyIndex, value, type);
2610     m_codeBlock-&gt;addPropertyAccessInstruction(m_lastInstruction.offset());
2611     return value;
2612 }
2613 
2614 void BytecodeGenerator::emitPutGetterById(RegisterID* base, const Identifier&amp; property, unsigned attributes, RegisterID* getter)
2615 {
2616     unsigned propertyIndex = addConstant(property);
2617     m_staticPropertyAnalyzer.putById(base, propertyIndex);
2618 
2619     OpPutGetterById::emit(this, base, propertyIndex, attributes, getter);
2620 }
2621 
2622 void BytecodeGenerator::emitPutSetterById(RegisterID* base, const Identifier&amp; property, unsigned attributes, RegisterID* setter)
2623 {
2624     unsigned propertyIndex = addConstant(property);
2625     m_staticPropertyAnalyzer.putById(base, propertyIndex);
2626 
2627     OpPutSetterById::emit(this, base, propertyIndex, attributes, setter);
2628 }
</pre>
<hr />
<pre>
2680 
2681     emitDirectPutById(m_generatorRegister, propertyNames().builtinNames().asyncGeneratorQueueFirstPrivateName(), emitLoad(nullptr, jsNull()), PropertyNode::KnownDirect);
2682     emitDirectPutById(m_generatorRegister, propertyNames().builtinNames().asyncGeneratorQueueLastPrivateName(), emitLoad(nullptr, jsNull()), PropertyNode::KnownDirect);
2683 }
2684 
2685 RegisterID* BytecodeGenerator::emitDeleteById(RegisterID* dst, RegisterID* base, const Identifier&amp; property)
2686 {
2687     OpDelById::emit(this, dst, base, addConstant(property));
2688     return dst;
2689 }
2690 
2691 RegisterID* BytecodeGenerator::emitGetByVal(RegisterID* dst, RegisterID* base, RegisterID* property)
2692 {
2693     for (size_t i = m_forInContextStack.size(); i--; ) {
2694         ForInContext&amp; context = m_forInContextStack[i].get();
2695         if (context.local() != property)
2696             continue;
2697 
2698         if (context.isIndexedForInContext()) {
2699             auto&amp; indexedContext = context.asIndexedForInContext();
<span class="line-modified">2700             OpGetByVal::emit&lt;OpcodeSize::Wide&gt;(this, kill(dst), base, indexedContext.index());</span>






2701             indexedContext.addGetInst(m_lastInstruction.offset(), property-&gt;index());
2702             return dst;
2703         }
2704 

2705         StructureForInContext&amp; structureContext = context.asStructureForInContext();
<span class="line-modified">2706         OpGetDirectPname::emit&lt;OpcodeSize::Wide&gt;(this, kill(dst), base, property, structureContext.index(), structureContext.enumerator());</span>
2707 
2708         structureContext.addGetInst(m_lastInstruction.offset(), property-&gt;index());
2709         return dst;
2710     }
2711 
2712     OpGetByVal::emit(this, kill(dst), base, property);
2713     return dst;
2714 }
2715 
2716 RegisterID* BytecodeGenerator::emitGetByVal(RegisterID* dst, RegisterID* base, RegisterID* thisValue, RegisterID* property)
2717 {
2718     OpGetByValWithThis::emit(this, kill(dst), base, thisValue, property);
2719     return dst;
2720 }
2721 
2722 RegisterID* BytecodeGenerator::emitPutByVal(RegisterID* base, RegisterID* property, RegisterID* value)
2723 {
2724     OpPutByVal::emit(this, base, property, value);
2725     return value;
2726 }
</pre>
<hr />
<pre>
2829     if (!environment.size())
2830         return;
2831 
2832     TDZNecessityLevel level;
2833     if (requirement == TDZRequirement::UnderTDZ) {
2834         if (optimization == TDZCheckOptimization::Optimize)
2835             level = TDZNecessityLevel::Optimize;
2836         else
2837             level = TDZNecessityLevel::DoNotOptimize;
2838     } else
2839         level = TDZNecessityLevel::NotNeeded;
2840 
2841     TDZMap map;
2842     for (const auto&amp; entry : environment)
2843         map.add(entry.key, entry.value.isFunction() ? TDZNecessityLevel::NotNeeded : level);
2844 
2845     m_TDZStack.append(WTFMove(map));
2846     m_cachedVariablesUnderTDZ = { };
2847 }
2848 
<span class="line-modified">2849 CompactVariableMap::Handle BytecodeGenerator::getVariablesUnderTDZ()</span>
2850 {
<span class="line-modified">2851     if (m_cachedVariablesUnderTDZ)</span>




2852         return m_cachedVariablesUnderTDZ;

2853 
2854     // We keep track of variablesThatDontNeedTDZ in this algorithm to prevent
2855     // reporting that &quot;x&quot; is under TDZ if this function is called at &quot;...&quot;.
2856     //
2857     //     {
2858     //         {
2859     //             let x;
2860     //             ...
2861     //         }
2862     //         let x;
2863     //     }
2864     SmallPtrSet&lt;UniquedStringImpl*, 16&gt; variablesThatDontNeedTDZ;
2865     VariableEnvironment environment;
2866     for (unsigned i = m_TDZStack.size(); i--; ) {
2867         auto&amp; map = m_TDZStack[i];
2868         for (auto&amp; entry : map)  {
2869             if (entry.value != TDZNecessityLevel::NotNeeded) {
2870                 if (!variablesThatDontNeedTDZ.contains(entry.key.get()))
2871                     environment.add(entry.key.get());
2872             } else
2873                 variablesThatDontNeedTDZ.add(entry.key.get());
2874         }
2875     }
2876 
<span class="line-modified">2877     m_cachedVariablesUnderTDZ = m_vm-&gt;m_compactVariableMap-&gt;get(environment);</span>




2878     return m_cachedVariablesUnderTDZ;
2879 }
2880 
2881 void BytecodeGenerator::preserveTDZStack(BytecodeGenerator::PreservedTDZStack&amp; preservedStack)
2882 {
2883     preservedStack.m_preservedTDZStack = m_TDZStack;
2884 }
2885 
2886 void BytecodeGenerator::restoreTDZStack(const BytecodeGenerator::PreservedTDZStack&amp; preservedStack)
2887 {
2888     m_TDZStack = preservedStack.m_preservedTDZStack;
2889     m_cachedVariablesUnderTDZ = { };
2890 }
2891 
2892 RegisterID* BytecodeGenerator::emitNewObject(RegisterID* dst)
2893 {
2894     OpNewObject::emit(this, dst, 0);
2895     m_staticPropertyAnalyzer.newObject(dst, m_lastInstruction);
2896 
2897     return dst;
2898 }
2899 
2900 JSValue BytecodeGenerator::addBigIntConstant(const Identifier&amp; identifier, uint8_t radix, bool sign)
2901 {
2902     return m_bigIntMap.ensure(BigIntMapEntry(identifier.impl(), radix, sign), [&amp;] {
<span class="line-modified">2903         auto scope = DECLARE_CATCH_SCOPE(*vm());</span>
2904         auto parseIntSign = sign ? JSBigInt::ParseIntSign::Signed : JSBigInt::ParseIntSign::Unsigned;
<span class="line-modified">2905         JSBigInt* bigIntInMap = JSBigInt::parseInt(nullptr, *vm(), identifier.string(), radix, JSBigInt::ErrorParseMode::ThrowExceptions, parseIntSign);</span>
2906         // FIXME: [ESNext] Enables a way to throw an error on ByteCodeGenerator step
2907         // https://bugs.webkit.org/show_bug.cgi?id=180139
2908         scope.assertNoException();
2909         RELEASE_ASSERT(bigIntInMap);
2910         addConstantValue(bigIntInMap);
2911 
2912         return bigIntInMap;
2913     }).iterator-&gt;value;
2914 }
2915 
2916 JSString* BytecodeGenerator::addStringConstant(const Identifier&amp; identifier)
2917 {
2918     JSString*&amp; stringInMap = m_stringMap.add(identifier.impl(), nullptr).iterator-&gt;value;
2919     if (!stringInMap) {
2920         stringInMap = jsString(vm(), identifier.string());
2921         addConstantValue(stringInMap);
2922     }
2923     return stringInMap;
2924 }
2925 
<span class="line-modified">2926 RegisterID* BytecodeGenerator::addTemplateObjectConstant(Ref&lt;TemplateObjectDescriptor&gt;&amp;&amp; descriptor)</span>
2927 {
<span class="line-modified">2928     JSTemplateObjectDescriptor* descriptorValue = m_templateObjectDescriptorMap.ensure(descriptor.copyRef(), [&amp;] {</span>
<span class="line-modified">2929         return JSTemplateObjectDescriptor::create(*vm(), WTFMove(descriptor));</span>

2930     }).iterator-&gt;value;
<span class="line-removed">2931 </span>
2932     int index = addConstantIndex();
2933     m_codeBlock-&gt;addConstant(descriptorValue);
2934     return &amp;m_constantPoolRegisters[index];
2935 }
2936 
2937 RegisterID* BytecodeGenerator::emitNewArrayBuffer(RegisterID* dst, JSImmutableButterfly* array, IndexingType recommendedIndexingType)
2938 {
2939     OpNewArrayBuffer::emit(this, dst, addConstantValue(array), recommendedIndexingType);
2940     return dst;
2941 }
2942 
2943 RegisterID* BytecodeGenerator::emitNewArray(RegisterID* dst, ElementNode* elements, unsigned length, IndexingType recommendedIndexingType)
2944 {
2945     Vector&lt;RefPtr&lt;RegisterID&gt;, 16, UnsafeVectorOverflow&gt; argv;
2946     for (ElementNode* n = elements; n; n = n-&gt;next()) {
2947         if (!length)
2948             break;
2949         length--;
2950         ASSERT(!n-&gt;value()-&gt;isSpreadExpression());
2951         argv.append(newTemporary());
</pre>
<hr />
<pre>
3036     return dst;
3037 }
3038 
3039 RegisterID* BytecodeGenerator::emitNewArrowFunctionExpression(RegisterID* dst, ArrowFuncExprNode* func)
3040 {
3041     ASSERT(SourceParseModeSet(SourceParseMode::ArrowFunctionMode, SourceParseMode::AsyncArrowFunctionMode).contains(func-&gt;metadata()-&gt;parseMode()));
3042     emitNewFunctionExpressionCommon(dst, func-&gt;metadata());
3043     return dst;
3044 }
3045 
3046 RegisterID* BytecodeGenerator::emitNewMethodDefinition(RegisterID* dst, MethodDefinitionNode* func)
3047 {
3048     ASSERT(isMethodParseMode(func-&gt;metadata()-&gt;parseMode()));
3049     emitNewFunctionExpressionCommon(dst, func-&gt;metadata());
3050     return dst;
3051 }
3052 
3053 RegisterID* BytecodeGenerator::emitNewDefaultConstructor(RegisterID* dst, ConstructorKind constructorKind, const Identifier&amp; name,
3054     const Identifier&amp; ecmaName, const SourceCode&amp; classSource)
3055 {
<span class="line-modified">3056     UnlinkedFunctionExecutable* executable = m_vm-&gt;builtinExecutables()-&gt;createDefaultConstructor(constructorKind, name);</span>
3057     executable-&gt;setInvalidTypeProfilingOffsets();
3058     executable-&gt;setEcmaName(ecmaName);
3059     executable-&gt;setClassSource(classSource);
3060 
3061     unsigned index = m_codeBlock-&gt;addFunctionExpr(executable);
3062 
3063     OpNewFuncExp::emit(this, dst, scopeRegister(), index);
3064     return dst;
3065 }
3066 
3067 RegisterID* BytecodeGenerator::emitNewFunction(RegisterID* dst, FunctionMetadataNode* function)
3068 {
3069     unsigned index = m_codeBlock-&gt;addFunctionDecl(makeFunction(function));
3070     if (isGeneratorWrapperParseMode(function-&gt;parseMode()))
3071         OpNewGeneratorFunc::emit(this, dst, scopeRegister(), index);
3072     else if (function-&gt;parseMode() == SourceParseMode::AsyncFunctionMode)
3073         OpNewAsyncFunc::emit(this, dst, scopeRegister(), index);
3074     else if (isAsyncGeneratorWrapperParseMode(function-&gt;parseMode()))
3075         OpNewAsyncGeneratorFunc::emit(this, dst, scopeRegister(), index);
3076     else
3077         OpNewFunc::emit(this, dst, scopeRegister(), index);
3078     return dst;
3079 }
3080 
3081 void BytecodeGenerator::emitSetFunctionNameIfNeeded(ExpressionNode* valueNode, RegisterID* value, RegisterID* name)
3082 {
3083     if (valueNode-&gt;isBaseFuncExprNode()) {
3084         FunctionMetadataNode* metadata = static_cast&lt;BaseFuncExprNode*&gt;(valueNode)-&gt;metadata();
3085         if (!metadata-&gt;ecmaName().isNull())
3086             return;
3087     } else if (valueNode-&gt;isClassExprNode()) {
3088         ClassExprNode* classExprNode = static_cast&lt;ClassExprNode*&gt;(valueNode);
3089         if (!classExprNode-&gt;ecmaName().isNull())
3090             return;
<span class="line-modified">3091         if (classExprNode-&gt;hasStaticProperty(m_vm-&gt;propertyNames-&gt;name))</span>
3092             return;
3093     } else
3094         return;
3095 
3096     // FIXME: We should use an op_call to an internal function here instead.
3097     // https://bugs.webkit.org/show_bug.cgi?id=155547
3098     OpSetFunctionName::emit(this, value, name);
3099 }
3100 
3101 RegisterID* BytecodeGenerator::emitCall(RegisterID* dst, RegisterID* func, ExpectedFunction expectedFunction, CallArguments&amp; callArguments, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, DebuggableCall debuggableCall)
3102 {
3103     return emitCall&lt;OpCall&gt;(dst, func, expectedFunction, callArguments, divot, divotStart, divotEnd, debuggableCall);
3104 }
3105 
3106 RegisterID* BytecodeGenerator::emitCallInTailPosition(RegisterID* dst, RegisterID* func, ExpectedFunction expectedFunction, CallArguments&amp; callArguments, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, DebuggableCall debuggableCall)
3107 {
3108     if (m_inTailPosition) {
3109         m_codeBlock-&gt;setHasTailCalls();
3110         return emitCall&lt;OpTailCall&gt;(dst, func, expectedFunction, callArguments, divot, divotStart, divotEnd, debuggableCall);
3111     }
</pre>
<hr />
<pre>
3196                     RefPtr&lt;RegisterID&gt; argumentRegister = emitNode(callArguments.argumentRegister(0), expression);
3197                     OpSpread::emit(this, argumentRegister.get(), argumentRegister.get());
3198 
3199                     return emitCallVarargs&lt;typename VarArgsOp&lt;CallOp&gt;::type&gt;(dst, func, callArguments.thisRegister(), argumentRegister.get(), newTemporary(), 0, divot, divotStart, divotEnd, debuggableCall);
3200                 }
3201             }
3202             RefPtr&lt;RegisterID&gt; argumentRegister;
3203             argumentRegister = expression-&gt;emitBytecode(*this, callArguments.argumentRegister(0));
3204             RefPtr&lt;RegisterID&gt; thisRegister = move(newTemporary(), callArguments.thisRegister());
3205             return emitCallVarargs&lt;typename VarArgsOp&lt;CallOp&gt;::type&gt;(dst, func, callArguments.thisRegister(), argumentRegister.get(), newTemporary(), 0, divot, divotStart, divotEnd, debuggableCall);
3206         }
3207         for (; n; n = n-&gt;m_next)
3208             emitNode(callArguments.argumentRegister(argument++), n);
3209     }
3210 
3211     // Reserve space for call frame.
3212     Vector&lt;RefPtr&lt;RegisterID&gt;, CallFrame::headerSizeInRegisters, UnsafeVectorOverflow&gt; callFrame;
3213     for (int i = 0; i &lt; CallFrame::headerSizeInRegisters; ++i)
3214         callFrame.append(newTemporary());
3215 
<span class="line-modified">3216     if (m_shouldEmitDebugHooks &amp;&amp; debuggableCall == DebuggableCall::Yes)</span>
3217         emitDebugHook(WillExecuteExpression, divotStart);
3218 
3219     emitExpressionInfo(divot, divotStart, divotEnd);
3220 
3221     Ref&lt;Label&gt; done = newLabel();
3222     expectedFunction = emitExpectedFunctionSnippet(dst, func, expectedFunction, callArguments, done.get());
3223 
3224     if (opcodeID == op_tail_call)
3225         emitLogShadowChickenTailIfNecessary();
3226 
3227     // Emit call.
3228     ASSERT(dst);
3229     ASSERT(dst != ignoredResult());
3230     CallOp::emit(this, dst, func, callArguments.argumentCountIncludingThis(), callArguments.stackOffset());
3231 
3232     if (expectedFunction != NoExpectedFunction)
3233         emitLabel(done.get());
3234 
3235     return dst;
3236 }
3237 
3238 RegisterID* BytecodeGenerator::emitCallVarargs(RegisterID* dst, RegisterID* func, RegisterID* thisRegister, RegisterID* arguments, RegisterID* firstFreeRegister, int32_t firstVarArgOffset, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, DebuggableCall debuggableCall)
3239 {
3240     return emitCallVarargs&lt;OpCallVarargs&gt;(dst, func, thisRegister, arguments, firstFreeRegister, firstVarArgOffset, divot, divotStart, divotEnd, debuggableCall);
3241 }
3242 
3243 RegisterID* BytecodeGenerator::emitCallVarargsInTailPosition(RegisterID* dst, RegisterID* func, RegisterID* thisRegister, RegisterID* arguments, RegisterID* firstFreeRegister, int32_t firstVarArgOffset, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, DebuggableCall debuggableCall)
3244 {
3245     if (m_inTailPosition)
3246         return emitCallVarargs&lt;OpTailCallVarargs&gt;(dst, func, thisRegister, arguments, firstFreeRegister, firstVarArgOffset, divot, divotStart, divotEnd, debuggableCall);
3247     return emitCallVarargs&lt;OpCallVarargs&gt;(dst, func, thisRegister, arguments, firstFreeRegister, firstVarArgOffset, divot, divotStart, divotEnd, debuggableCall);
3248 }
3249 
3250 RegisterID* BytecodeGenerator::emitConstructVarargs(RegisterID* dst, RegisterID* func, RegisterID* thisRegister, RegisterID* arguments, RegisterID* firstFreeRegister, int32_t firstVarArgOffset, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, DebuggableCall debuggableCall)
3251 {
3252     return emitCallVarargs&lt;OpConstructVarargs&gt;(dst, func, thisRegister, arguments, firstFreeRegister, firstVarArgOffset, divot, divotStart, divotEnd, debuggableCall);
3253 }
3254 
3255 RegisterID* BytecodeGenerator::emitCallForwardArgumentsInTailPosition(RegisterID* dst, RegisterID* func, RegisterID* thisRegister, RegisterID* firstFreeRegister, int32_t firstVarArgOffset, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, DebuggableCall debuggableCall)
3256 {
<span class="line-modified">3257     ASSERT(m_inTailPosition);</span>

3258     return emitCallVarargs&lt;OpTailCallForwardArguments&gt;(dst, func, thisRegister, nullptr, firstFreeRegister, firstVarArgOffset, divot, divotStart, divotEnd, debuggableCall);
3259 }
3260 
3261 template&lt;typename VarargsOp&gt;
3262 RegisterID* BytecodeGenerator::emitCallVarargs(RegisterID* dst, RegisterID* func, RegisterID* thisRegister, RegisterID* arguments, RegisterID* firstFreeRegister, int32_t firstVarArgOffset, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, DebuggableCall debuggableCall)
3263 {
<span class="line-modified">3264     if (m_shouldEmitDebugHooks &amp;&amp; debuggableCall == DebuggableCall::Yes)</span>
3265         emitDebugHook(WillExecuteExpression, divotStart);
3266 
3267     emitExpressionInfo(divot, divotStart, divotEnd);
3268 
3269     if (VarargsOp::opcodeID == op_tail_call_varargs)
3270         emitLogShadowChickenTailIfNecessary();
3271 
3272     // Emit call.
3273     ASSERT(dst != ignoredResult());
3274     VarargsOp::emit(this, dst, func, thisRegister, arguments ? arguments : VirtualRegister(0), firstFreeRegister, firstVarArgOffset);
3275     return dst;
3276 }
3277 
3278 void BytecodeGenerator::emitLogShadowChickenPrologueIfNecessary()
3279 {
<span class="line-modified">3280     if (!m_shouldEmitDebugHooks &amp;&amp; !Options::alwaysUseShadowChicken())</span>
3281         return;
3282     OpLogShadowChickenPrologue::emit(this, scopeRegister());
3283 }
3284 
3285 void BytecodeGenerator::emitLogShadowChickenTailIfNecessary()
3286 {
<span class="line-modified">3287     if (!m_shouldEmitDebugHooks &amp;&amp; !Options::alwaysUseShadowChicken())</span>
3288         return;
3289     OpLogShadowChickenTail::emit(this, thisRegister(), scopeRegister());
3290 }
3291 
3292 void BytecodeGenerator::emitCallDefineProperty(RegisterID* newObj, RegisterID* propertyNameRegister,
3293     RegisterID* valueRegister, RegisterID* getterRegister, RegisterID* setterRegister, unsigned options, const JSTextPosition&amp; position)
3294 {
3295     DefinePropertyAttributes attributes;
3296     if (options &amp; PropertyConfigurable)
3297         attributes.setConfigurable(true);
3298 
3299     if (options &amp; PropertyWritable)
3300         attributes.setWritable(true);
3301     else if (valueRegister)
3302         attributes.setWritable(false);
3303 
3304     if (options &amp; PropertyEnumerable)
3305         attributes.setEnumerable(true);
3306 
3307     if (valueRegister)
</pre>
<hr />
<pre>
3464     return dst;
3465 }
3466 
3467 void BytecodeGenerator::emitPopScope(RegisterID* dst, RegisterID* scope)
3468 {
3469     RefPtr&lt;RegisterID&gt; parentScope = emitGetParentScope(newTemporary(), scope);
3470     move(dst, parentScope.get());
3471 }
3472 
3473 void BytecodeGenerator::emitPopWithScope()
3474 {
3475     emitPopScope(scopeRegister(), scopeRegister());
3476     popLocalControlFlowScope();
3477     auto stackEntry = m_lexicalScopeStack.takeLast();
3478     stackEntry.m_scope-&gt;deref();
3479     RELEASE_ASSERT(stackEntry.m_isWithScope);
3480 }
3481 
3482 void BytecodeGenerator::emitDebugHook(DebugHookType debugHookType, const JSTextPosition&amp; divot)
3483 {
<span class="line-modified">3484     if (!m_shouldEmitDebugHooks)</span>
3485         return;
3486 
3487     emitExpressionInfo(divot, divot, divot);
3488     OpDebug::emit(this, debugHookType, false);
3489 }
3490 
3491 void BytecodeGenerator::emitDebugHook(DebugHookType debugHookType, unsigned line, unsigned charOffset, unsigned lineStart)
3492 {
3493     emitDebugHook(debugHookType, JSTextPosition(line, charOffset, lineStart));
3494 }
3495 
3496 void BytecodeGenerator::emitDebugHook(StatementNode* statement)
3497 {
3498     // DebuggerStatementNode will output its own special debug hook.
3499     if (statement-&gt;isDebuggerStatement())
3500         return;
3501 
3502     emitDebugHook(WillExecuteStatement, statement-&gt;position());
3503 }
3504 
3505 void BytecodeGenerator::emitDebugHook(ExpressionNode* expr)
3506 {
3507     emitDebugHook(WillExecuteStatement, expr-&gt;position());
3508 }
3509 
3510 void BytecodeGenerator::emitWillLeaveCallFrameDebugHook()
3511 {
3512     RELEASE_ASSERT(m_scopeNode-&gt;isFunctionNode());
3513     emitDebugHook(WillLeaveCallFrame, m_scopeNode-&gt;lastLine(), m_scopeNode-&gt;startOffset(), m_scopeNode-&gt;lineStartOffset());
3514 }
3515 
<span class="line-modified">3516 FinallyContext* BytecodeGenerator::pushFinallyControlFlowScope(Label&amp; finallyLabel)</span>
3517 {
<span class="line-modified">3518     ControlFlowScope scope(ControlFlowScope::Finally, currentLexicalScopeIndex(), FinallyContext(m_currentFinallyContext, finallyLabel));</span>
3519     m_controlFlowScopeStack.append(WTFMove(scope));
3520 
3521     m_finallyDepth++;
<span class="line-modified">3522     m_currentFinallyContext = &amp;m_controlFlowScopeStack.last().finallyContext;</span>
<span class="line-removed">3523     return m_currentFinallyContext;</span>
3524 }
3525 
<span class="line-modified">3526 FinallyContext BytecodeGenerator::popFinallyControlFlowScope()</span>
3527 {
3528     ASSERT(m_controlFlowScopeStack.size());
3529     ASSERT(m_controlFlowScopeStack.last().isFinallyScope());
3530     ASSERT(m_finallyDepth &gt; 0);
3531     ASSERT(m_currentFinallyContext);
3532     m_currentFinallyContext = m_currentFinallyContext-&gt;outerContext();
3533     m_finallyDepth--;
<span class="line-modified">3534     return m_controlFlowScopeStack.takeLast().finallyContext;</span>
3535 }
3536 
3537 LabelScope* BytecodeGenerator::breakTarget(const Identifier&amp; name)
3538 {
3539     shrinkToFit(m_labelScopes);
3540 
3541     if (!m_labelScopes.size())
3542         return nullptr;
3543 
3544     // We special-case the following, which is a syntax error in Firefox:
3545     // label:
3546     //     break;
3547     if (name.isEmpty()) {
3548         for (int i = m_labelScopes.size() - 1; i &gt;= 0; --i) {
3549             LabelScope&amp; scope = m_labelScopes[i];
3550             if (scope.type() != LabelScope::NamedLabel)
3551                 return &amp;scope;
3552         }
3553         return nullptr;
3554     }
</pre>
<hr />
<pre>
3625         result
3626     });
3627 
3628     return result;
3629 }
3630 
3631 void BytecodeGenerator::popTry(TryData* tryData, Label&amp; end)
3632 {
3633     m_usesExceptions = true;
3634 
3635     ASSERT_UNUSED(tryData, m_tryContextStack.last().tryData == tryData);
3636 
3637     m_tryRanges.append(TryRange {
3638         m_tryContextStack.last().start.copyRef(),
3639         end,
3640         m_tryContextStack.last().tryData
3641     });
3642     m_tryContextStack.removeLast();
3643 }
3644 
<span class="line-modified">3645 void BytecodeGenerator::emitCatch(RegisterID* exceptionRegister, RegisterID* thrownValueRegister, TryData* data)</span>
3646 {
<span class="line-modified">3647     m_catchesToEmit.append(CatchEntry { data, exceptionRegister, thrownValueRegister });</span>














3648 }
3649 
3650 void BytecodeGenerator::restoreScopeRegister(int lexicalScopeIndex)
3651 {
3652     if (lexicalScopeIndex == CurrentLexicalScopeIndex)
3653         return; // No change needed.
3654 
3655     if (lexicalScopeIndex != OutermostLexicalScopeIndex) {
3656         ASSERT(lexicalScopeIndex &lt; static_cast&lt;int&gt;(m_lexicalScopeStack.size()));
3657         int endIndex = lexicalScopeIndex + 1;
3658         for (size_t i = endIndex; i--; ) {
3659             if (m_lexicalScopeStack[i].m_scope) {
3660                 move(scopeRegister(), m_lexicalScopeStack[i].m_scope);
3661                 return;
3662             }
3663         }
3664     }
3665     // Note that if we don&#39;t find a local scope in the current function/program,
3666     // we must grab the outer-most scope of this bytecode generation.
3667     move(scopeRegister(), m_topMostScope);
</pre>
<hr />
<pre>
3679     ASSERT(scopeDelta &lt;= m_controlFlowScopeStack.size());
3680     if (!scopeDelta)
3681         return CurrentLexicalScopeIndex;
3682 
3683     ControlFlowScope&amp; targetScope = m_controlFlowScopeStack[targetLabelScopeDepth];
3684     return targetScope.lexicalScopeIndex;
3685 }
3686 
3687 void BytecodeGenerator::emitThrow(RegisterID* exc)
3688 {
3689     m_usesExceptions = true;
3690     OpThrow::emit(this, exc);
3691 }
3692 
3693 RegisterID* BytecodeGenerator::emitArgumentCount(RegisterID* dst)
3694 {
3695     OpArgumentCount::emit(this, dst);
3696     return dst;
3697 }
3698 
<span class="line-modified">3699 int BytecodeGenerator::localScopeDepth() const</span>
3700 {
3701     return m_localScopeDepth;
3702 }
3703 
3704 int BytecodeGenerator::labelScopeDepth() const
3705 {
3706     unsigned depth = localScopeDepth() + m_finallyDepth;
3707     ASSERT(depth == m_controlFlowScopeStack.size());
3708     return depth;
3709 }
3710 
3711 void BytecodeGenerator::emitThrowStaticError(ErrorType errorType, RegisterID* raw)
3712 {
3713     RefPtr&lt;RegisterID&gt; message = newTemporary();
3714     emitToString(message.get(), raw);
3715     OpThrowStaticError::emit(this, message.get(), errorType);
3716 }
3717 
3718 void BytecodeGenerator::emitThrowStaticError(ErrorType errorType, const Identifier&amp; message)
3719 {
</pre>
<hr />
<pre>
3942         return false;
3943     return registerID-&gt;index() == CallFrame::argumentOffset(argumentNumber);
3944 }
3945 
3946 bool BytecodeGenerator::emitReadOnlyExceptionIfNeeded(const Variable&amp; variable)
3947 {
3948     // If we&#39;re in strict mode, we always throw.
3949     // If we&#39;re not in strict mode, we throw for &quot;const&quot; variables but not the function callee.
3950     if (isStrictMode() || variable.isConst()) {
3951         emitThrowTypeError(Identifier::fromString(m_vm, ReadonlyPropertyWriteError));
3952         return true;
3953     }
3954     return false;
3955 }
3956 
3957 void BytecodeGenerator::emitEnumeration(ThrowableExpressionData* node, ExpressionNode* subjectNode, const ScopedLambda&lt;void(BytecodeGenerator&amp;, RegisterID*)&gt;&amp; callBack, ForOfNode* forLoopNode, RegisterID* forLoopSymbolTable)
3958 {
3959     bool isForAwait = forLoopNode ? forLoopNode-&gt;isForAwait() : false;
3960     ASSERT(!isForAwait || (isForAwait &amp;&amp; isAsyncFunctionParseMode(parseMode())));
3961 
<span class="line-removed">3962     CompletionRecordScope completionRecordScope(*this);</span>
<span class="line-removed">3963 </span>
3964     RefPtr&lt;RegisterID&gt; subject = newTemporary();
3965     emitNode(subject.get(), subjectNode);
3966     RefPtr&lt;RegisterID&gt; iterator = isForAwait ? emitGetAsyncIterator(subject.get(), node) : emitGetIterator(subject.get(), node);
3967     RefPtr&lt;RegisterID&gt; nextMethod = emitGetById(newTemporary(), iterator.get(), propertyNames().next);
3968 
3969     Ref&lt;Label&gt; loopDone = newLabel();
3970     Ref&lt;Label&gt; tryStartLabel = newLabel();
3971     Ref&lt;Label&gt; finallyViaThrowLabel = newLabel();
3972     Ref&lt;Label&gt; finallyLabel = newLabel();
3973     Ref&lt;Label&gt; catchLabel = newLabel();
3974     Ref&lt;Label&gt; endCatchLabel = newLabel();
3975 
3976     // RefPtr&lt;Register&gt; iterator&#39;s lifetime must be longer than IteratorCloseContext.
<span class="line-modified">3977     FinallyContext* finallyContext = pushFinallyControlFlowScope(finallyLabel.get());</span>

3978 
3979     {
3980         Ref&lt;LabelScope&gt; scope = newLabelScope(LabelScope::Loop);
3981         RefPtr&lt;RegisterID&gt; value = newTemporary();
3982         emitLoad(value.get(), jsUndefined());
3983 
3984         emitJump(*scope-&gt;continueTarget());
3985 
3986         Ref&lt;Label&gt; loopStart = newLabel();
3987         emitLabel(loopStart.get());
3988         emitLoopHint();
3989 
3990         emitLabel(tryStartLabel.get());
3991         TryData* tryData = pushTry(tryStartLabel.get(), finallyViaThrowLabel.get(), HandlerType::SynthesizedFinally);
3992         callBack(*this, value.get());
3993         emitJump(*scope-&gt;continueTarget());
3994 
3995         // IteratorClose sequence for abrupt completions.
3996         {
3997             // Finally block for the enumeration.
3998             emitLabel(finallyViaThrowLabel.get());
3999             popTry(tryData, finallyViaThrowLabel.get());
4000 
4001             Ref&lt;Label&gt; finallyBodyLabel = newLabel();
4002             RefPtr&lt;RegisterID&gt; finallyExceptionRegister = newTemporary();
<span class="line-removed">4003             RegisterID* unused = newTemporary();</span>
4004 
<span class="line-modified">4005             emitCatch(completionValueRegister(), unused, tryData);</span>
<span class="line-modified">4006             emitSetCompletionType(CompletionType::Throw);</span>
<span class="line-removed">4007             move(finallyExceptionRegister.get(), completionValueRegister());</span>
4008             emitJump(finallyBodyLabel.get());
4009 
4010             emitLabel(finallyLabel.get());
4011             moveEmptyValue(finallyExceptionRegister.get());
4012 

4013             emitLabel(finallyBodyLabel.get());
4014             restoreScopeRegister();
4015 
4016             Ref&lt;Label&gt; finallyDone = newLabel();
4017 
4018             RefPtr&lt;RegisterID&gt; returnMethod = emitGetById(newTemporary(), iterator.get(), propertyNames().returnKeyword);
4019             emitJumpIfTrue(emitIsUndefined(newTemporary(), returnMethod.get()), finallyDone.get());
4020 
4021             Ref&lt;Label&gt; returnCallTryStart = newLabel();
4022             emitLabel(returnCallTryStart.get());
4023             TryData* returnCallTryData = pushTry(returnCallTryStart.get(), catchLabel.get(), HandlerType::SynthesizedCatch);
4024 
4025             CallArguments returnArguments(*this, nullptr);
4026             move(returnArguments.thisRegister(), iterator.get());
4027             emitCall(value.get(), returnMethod.get(), NoExpectedFunction, returnArguments, node-&gt;divot(), node-&gt;divotStart(), node-&gt;divotEnd(), DebuggableCall::No);
4028 
4029             if (isForAwait)
4030                 emitAwait(value.get());
4031 
4032             emitJumpIfTrue(emitIsObject(newTemporary(), value.get()), finallyDone.get());
4033             emitThrowTypeError(&quot;Iterator result interface is not an object.&quot;_s);
4034 
4035             emitLabel(finallyDone.get());
<span class="line-modified">4036             emitFinallyCompletion(*finallyContext, completionTypeRegister(), endCatchLabel.get());</span>
4037 
4038             popTry(returnCallTryData, finallyDone.get());
4039 
4040             // Catch block for exceptions that may be thrown while calling the return
4041             // handler in the enumeration finally block. The only reason we need this
4042             // catch block is because if entered the above finally block due to a thrown
4043             // exception, then we want to re-throw the original exception on exiting
4044             // the finally block. Otherwise, we&#39;ll let any new exception pass through.
4045             {
4046                 emitLabel(catchLabel.get());

4047                 RefPtr&lt;RegisterID&gt; exceptionRegister = newTemporary();
<span class="line-modified">4048                 RegisterID* unused = newTemporary();</span>
<span class="line-removed">4049                 emitCatch(exceptionRegister.get(), unused, returnCallTryData);</span>
4050                 // Since this is a synthesized catch block and we&#39;re guaranteed to never need
4051                 // to resolve any symbols from the scope, we can skip restoring the scope
4052                 // register here.
4053 
4054                 Ref&lt;Label&gt; throwLabel = newLabel();
4055                 emitJumpIfTrue(emitIsEmpty(newTemporary(), finallyExceptionRegister.get()), throwLabel.get());
4056                 move(exceptionRegister.get(), finallyExceptionRegister.get());
4057 
4058                 emitLabel(throwLabel.get());
4059                 emitThrow(exceptionRegister.get());
4060 
4061                 emitLabel(endCatchLabel.get());
4062             }
4063         }
4064 
4065         emitLabel(*scope-&gt;continueTarget());
4066         if (forLoopNode) {
4067             RELEASE_ASSERT(forLoopNode-&gt;isForOfNode());
4068             prepareLexicalScopeForNextForLoopIteration(forLoopNode, forLoopSymbolTable);
4069             emitDebugHook(forLoopNode-&gt;lexpr());
</pre>
<hr />
<pre>
4087         }
4088     }
4089     emitLabel(loopDone.get());
4090 }
4091 
4092 RegisterID* BytecodeGenerator::emitGetTemplateObject(RegisterID* dst, TaggedTemplateNode* taggedTemplate)
4093 {
4094     TemplateObjectDescriptor::StringVector rawStrings;
4095     TemplateObjectDescriptor::OptionalStringVector cookedStrings;
4096 
4097     TemplateStringListNode* templateString = taggedTemplate-&gt;templateLiteral()-&gt;templateStrings();
4098     for (; templateString; templateString = templateString-&gt;next()) {
4099         auto* string = templateString-&gt;value();
4100         ASSERT(string-&gt;raw());
4101         rawStrings.append(string-&gt;raw()-&gt;impl());
4102         if (!string-&gt;cooked())
4103             cookedStrings.append(WTF::nullopt);
4104         else
4105             cookedStrings.append(string-&gt;cooked()-&gt;impl());
4106     }
<span class="line-modified">4107     RefPtr&lt;RegisterID&gt; constant = addTemplateObjectConstant(TemplateObjectDescriptor::create(WTFMove(rawStrings), WTFMove(cookedStrings)));</span>
4108     if (!dst)
4109         return constant.get();
4110     return move(dst, constant.get());
4111 }
4112 
4113 RegisterID* BytecodeGenerator::emitGetGlobalPrivate(RegisterID* dst, const Identifier&amp; property)
4114 {
4115     dst = tempDestination(dst);
4116     Variable var = variable(property);
4117     if (RegisterID* local = var.local())
4118         return move(dst, local);
4119 
4120     RefPtr&lt;RegisterID&gt; scope = newTemporary();
4121     move(scope.get(), emitResolveScope(scope.get(), var));
4122     return emitGetFromScope(dst, scope.get(), var, ThrowIfNotFound);
4123 }
4124 
4125 RegisterID* BytecodeGenerator::emitGetEnumerableLength(RegisterID* dst, RegisterID* base)
4126 {
4127     OpGetEnumerableLength::emit(this, dst, base);
</pre>
<hr />
<pre>
4380 {
4381     if (!localRegister)
4382         return;
4383     unsigned bodyBytecodeEndOffset = instructions().size();
4384     m_forInContextStack.last()-&gt;asStructureForInContext().finalize(*this, m_codeBlock.get(), bodyBytecodeEndOffset);
4385     m_forInContextStack.removeLast();
4386 }
4387 
4388 RegisterID* BytecodeGenerator::emitRestParameter(RegisterID* result, unsigned numParametersToSkip)
4389 {
4390     RefPtr&lt;RegisterID&gt; restArrayLength = newTemporary();
4391     OpGetRestLength::emit(this, restArrayLength.get(), numParametersToSkip);
4392 
4393     OpCreateRest::emit(this, result, restArrayLength.get(), numParametersToSkip);
4394 
4395     return result;
4396 }
4397 
4398 void BytecodeGenerator::emitRequireObjectCoercible(RegisterID* value, const String&amp; error)
4399 {
<span class="line-removed">4400     // FIXME: op_jneq_null treats &quot;undetectable&quot; objects as null/undefined. RequireObjectCoercible</span>
<span class="line-removed">4401     // thus incorrectly throws a TypeError for interfaces like HTMLAllCollection.</span>
4402     Ref&lt;Label&gt; target = newLabel();
<span class="line-modified">4403     OpJneqNull::emit(this, value, target-&gt;bind(this));</span>
4404     emitThrowTypeError(error);
4405     emitLabel(target.get());
4406 }
4407 
4408 void BytecodeGenerator::emitYieldPoint(RegisterID* argument, JSAsyncGeneratorFunction::AsyncGeneratorSuspendReason result)
4409 {
4410     Ref&lt;Label&gt; mergePoint = newLabel();
4411     unsigned yieldPointIndex = m_yieldPoints++;
4412     emitGeneratorStateChange(yieldPointIndex + 1);
4413 
4414     if (parseMode() == SourceParseMode::AsyncGeneratorBodyMode) {
4415         int suspendReason = static_cast&lt;int32_t&gt;(result);
4416         emitPutById(generatorRegister(), propertyNames().builtinNames().asyncGeneratorSuspendReasonPrivateName(), emitLoad(nullptr, jsNumber(suspendReason)));
4417     }
4418 
4419     // Split the try range here.
4420     Ref&lt;Label&gt; savePoint = newEmittedLabel();
4421     for (unsigned i = m_tryContextStack.size(); i--;) {
4422         TryContext&amp; context = m_tryContextStack[i];
4423         m_tryRanges.append(TryRange {
4424             context.start.copyRef(),
4425             savePoint.copyRef(),
4426             context.tryData
4427         });
4428         // Try range will be restared at the merge point.
4429         context.start = mergePoint.get();
4430     }
4431     Vector&lt;TryContext&gt; savedTryContextStack;
4432     m_tryContextStack.swap(savedTryContextStack);
4433 
4434 
4435 #if CPU(NEEDS_ALIGNED_ACCESS)
4436     // conservatively align for the bytecode rewriter: it will delete this yield and
4437     // append a fragment, so we make sure that the start of the fragments is aligned
<span class="line-modified">4438     while (m_writer.position() % OpcodeSize::Wide)</span>
4439         OpNop::emit&lt;OpcodeSize::Narrow&gt;(this);
4440 #endif
4441     OpYield::emit(this, generatorFrameRegister(), yieldPointIndex, argument);
4442 
4443     // Restore the try contexts, which start offset is updated to the merge point.
4444     m_tryContextStack.swap(savedTryContextStack);
4445     emitLabel(mergePoint.get());
4446 }
4447 
4448 RegisterID* BytecodeGenerator::emitYield(RegisterID* argument, JSAsyncGeneratorFunction::AsyncGeneratorSuspendReason result)
4449 {
4450     emitYieldPoint(argument, result);
4451 
4452     Ref&lt;Label&gt; normalLabel = newLabel();
4453     RefPtr&lt;RegisterID&gt; condition = newTemporary();
4454     emitEqualityOp&lt;OpStricteq&gt;(condition.get(), generatorResumeModeRegister(), emitLoad(nullptr, jsNumber(static_cast&lt;int32_t&gt;(JSGeneratorFunction::GeneratorResumeMode::NormalMode))));
4455     emitJumpIfTrue(condition.get(), normalLabel.get());
4456 
4457     Ref&lt;Label&gt; throwLabel = newLabel();
4458     emitEqualityOp&lt;OpStricteq&gt;(condition.get(), generatorResumeModeRegister(), emitLoad(nullptr, jsNumber(static_cast&lt;int32_t&gt;(JSGeneratorFunction::GeneratorResumeMode::ThrowMode))));
</pre>
<hr />
<pre>
4668 void BytecodeGenerator::emitGeneratorStateChange(int32_t state)
4669 {
4670     RegisterID* completedState = emitLoad(nullptr, jsNumber(state));
4671     emitPutById(generatorRegister(), propertyNames().builtinNames().generatorStatePrivateName(), completedState);
4672 }
4673 
4674 bool BytecodeGenerator::emitJumpViaFinallyIfNeeded(int targetLabelScopeDepth, Label&amp; jumpTarget)
4675 {
4676     ASSERT(labelScopeDepth() - targetLabelScopeDepth &gt;= 0);
4677     size_t numberOfScopesToCheckForFinally = labelScopeDepth() - targetLabelScopeDepth;
4678     ASSERT(numberOfScopesToCheckForFinally &lt;= m_controlFlowScopeStack.size());
4679     if (!numberOfScopesToCheckForFinally)
4680         return false;
4681 
4682     FinallyContext* innermostFinallyContext = nullptr;
4683     FinallyContext* outermostFinallyContext = nullptr;
4684     size_t scopeIndex = m_controlFlowScopeStack.size() - 1;
4685     while (numberOfScopesToCheckForFinally--) {
4686         ControlFlowScope* scope = &amp;m_controlFlowScopeStack[scopeIndex--];
4687         if (scope-&gt;isFinallyScope()) {
<span class="line-modified">4688             FinallyContext* finallyContext = &amp;scope-&gt;finallyContext;</span>
4689             if (!innermostFinallyContext)
4690                 innermostFinallyContext = finallyContext;
4691             outermostFinallyContext = finallyContext;
4692             finallyContext-&gt;incNumberOfBreaksOrContinues();
4693         }
4694     }
4695     if (!outermostFinallyContext)
4696         return false; // No finallys to thread through.
4697 
4698     auto jumpID = bytecodeOffsetToJumpID(instructions().size());
4699     int lexicalScopeIndex = labelScopeDepthToLexicalScopeIndex(targetLabelScopeDepth);
4700     outermostFinallyContext-&gt;registerJump(jumpID, lexicalScopeIndex, jumpTarget);
4701 
<span class="line-modified">4702     emitSetCompletionType(jumpID);</span>
4703     emitJump(*innermostFinallyContext-&gt;finallyLabel());
4704     return true; // We&#39;ll be jumping to a finally block.
4705 }
4706 
4707 bool BytecodeGenerator::emitReturnViaFinallyIfNeeded(RegisterID* returnRegister)
4708 {
4709     size_t numberOfScopesToCheckForFinally = m_controlFlowScopeStack.size();
4710     if (!numberOfScopesToCheckForFinally)
4711         return false;
4712 
4713     FinallyContext* innermostFinallyContext = nullptr;
4714     while (numberOfScopesToCheckForFinally) {
4715         size_t scopeIndex = --numberOfScopesToCheckForFinally;
4716         ControlFlowScope* scope = &amp;m_controlFlowScopeStack[scopeIndex];
4717         if (scope-&gt;isFinallyScope()) {
<span class="line-modified">4718             FinallyContext* finallyContext = &amp;scope-&gt;finallyContext;</span>
4719             if (!innermostFinallyContext)
4720                 innermostFinallyContext = finallyContext;
4721             finallyContext-&gt;setHandlesReturns();
4722         }
4723     }
4724     if (!innermostFinallyContext)
4725         return false; // No finallys to thread through.
4726 
<span class="line-modified">4727     emitSetCompletionType(CompletionType::Return);</span>
<span class="line-modified">4728     emitSetCompletionValue(returnRegister);</span>
4729     emitJump(*innermostFinallyContext-&gt;finallyLabel());
4730     return true; // We&#39;ll be jumping to a finally block.
4731 }
4732 
<span class="line-modified">4733 void BytecodeGenerator::emitFinallyCompletion(FinallyContext&amp; context, RegisterID* completionTypeRegister, Label&amp; normalCompletionLabel)</span>
4734 {
4735     if (context.numberOfBreaksOrContinues() || context.handlesReturns()) {
<span class="line-modified">4736         emitJumpIf&lt;OpStricteq&gt;(completionTypeRegister, CompletionType::Normal, normalCompletionLabel);</span>
4737 
4738         FinallyContext* outerContext = context.outerContext();
4739 
4740         size_t numberOfJumps = context.numberOfJumps();
4741         ASSERT(outerContext || numberOfJumps == context.numberOfBreaksOrContinues());
4742 

4743         for (size_t i = 0; i &lt; numberOfJumps; i++) {
4744             Ref&lt;Label&gt; nextLabel = newLabel();
4745             auto&amp; jump = context.jumps(i);
<span class="line-modified">4746             emitJumpIf&lt;OpNstricteq&gt;(completionTypeRegister, jump.jumpID, nextLabel.get());</span>




















4747 
4748             restoreScopeRegister(jump.targetLexicalScopeIndex);
<span class="line-modified">4749             emitSetCompletionType(CompletionType::Normal);</span>
4750             emitJump(jump.targetLabel.get());
4751 
4752             emitLabel(nextLabel.get());
4753         }
4754 

4755         if (outerContext) {
<span class="line-modified">4756             // We are not the outermost finally.</span>
<span class="line-modified">4757             bool hasBreaksOrContinuesNotCoveredByJumps = context.numberOfBreaksOrContinues() &gt; numberOfJumps;</span>
<span class="line-modified">4758             if (hasBreaksOrContinuesNotCoveredByJumps || context.handlesReturns())</span>
<span class="line-modified">4759                 emitJumpIf&lt;OpNstricteq&gt;(completionTypeRegister, CompletionType::Throw, *outerContext-&gt;finallyLabel());</span>
































































4760 
4761         } else {
4762             // We are the outermost finally.
4763             if (context.handlesReturns()) {
4764                 Ref&lt;Label&gt; notReturnLabel = newLabel();
<span class="line-modified">4765                 emitJumpIf&lt;OpNstricteq&gt;(completionTypeRegister, CompletionType::Return, notReturnLabel.get());</span>











4766 
4767                 emitWillLeaveCallFrameDebugHook();
<span class="line-modified">4768                 emitReturn(completionValueRegister(), ReturnFrom::Finally);</span>
4769 
4770                 emitLabel(notReturnLabel.get());
4771             }
4772         }
4773     }
<span class="line-removed">4774     emitJumpIf&lt;OpNstricteq&gt;(completionTypeRegister, CompletionType::Throw, normalCompletionLabel);</span>
<span class="line-removed">4775     emitThrow(completionValueRegister());</span>
<span class="line-removed">4776 }</span>
4777 
<span class="line-modified">4778 bool BytecodeGenerator::allocateCompletionRecordRegisters()</span>
<span class="line-modified">4779 {</span>
<span class="line-removed">4780     if (m_completionTypeRegister)</span>
<span class="line-removed">4781         return false;</span>
4782 
<span class="line-modified">4783     ASSERT(!m_completionValueRegister);</span>
<span class="line-removed">4784     m_completionTypeRegister = newTemporary();</span>
<span class="line-removed">4785     m_completionValueRegister = newTemporary();</span>
4786 
<span class="line-modified">4787     emitSetCompletionType(CompletionType::Normal);</span>
<span class="line-modified">4788     moveEmptyValue(m_completionValueRegister.get());</span>
<span class="line-modified">4789     return true;</span>
<span class="line-modified">4790 }</span>





4791 
<span class="line-modified">4792 void BytecodeGenerator::releaseCompletionRecordRegisters()</span>
<span class="line-removed">4793 {</span>
<span class="line-removed">4794     ASSERT(m_completionTypeRegister &amp;&amp; m_completionValueRegister);</span>
<span class="line-removed">4795     m_completionTypeRegister = nullptr;</span>
<span class="line-removed">4796     m_completionValueRegister = nullptr;</span>
4797 }
4798 
4799 template&lt;typename CompareOp&gt;
4800 void BytecodeGenerator::emitJumpIf(RegisterID* completionTypeRegister, CompletionType type, Label&amp; jumpTarget)
4801 {
4802     RefPtr&lt;RegisterID&gt; tempRegister = newTemporary();
4803     RegisterID* valueConstant = addConstantValue(jsNumber(static_cast&lt;int&gt;(type)));
4804     OperandTypes operandTypes = OperandTypes(ResultType::numberTypeIsInt32(), ResultType::unknownType());
4805 
<span class="line-modified">4806     auto equivalenceResult = emitBinaryOp&lt;CompareOp&gt;(tempRegister.get(), valueConstant, completionTypeRegister, operandTypes);</span>
4807     emitJumpIfTrue(equivalenceResult, jumpTarget);
4808 }
4809 




























4810 void ForInContext::finalize(BytecodeGenerator&amp; generator, UnlinkedCodeBlock* codeBlock, unsigned bodyBytecodeEndOffset)
4811 {
4812     // Lexically invalidating ForInContexts is kind of weak sauce, but it only occurs if
4813     // either of the following conditions is true:
4814     //
4815     // (1) The loop iteration variable is re-assigned within the body of the loop.
4816     // (2) The loop iteration variable is captured in the lexical scope of the function.
4817     //
4818     // These two situations occur sufficiently rarely that it&#39;s okay to use this style of
4819     // &quot;analysis&quot; to make iteration faster. If we didn&#39;t want to do this, we would either have
4820     // to perform some flow-sensitive analysis to see if/when the loop iteration variable was
4821     // reassigned, or we&#39;d have to resort to runtime checks to see if the variable had been
4822     // reassigned from its original value.
4823 
4824     for (unsigned offset = bodyBytecodeStartOffset(); isValid() &amp;&amp; offset &lt; bodyBytecodeEndOffset;) {
4825         auto instruction = generator.instructions().at(offset);
4826         OpcodeID opcodeID = instruction-&gt;opcodeID();
4827 
4828         ASSERT(opcodeID != op_enter);
4829         computeDefsForBytecodeOffset(codeBlock, opcodeID, instruction.ptr(), [&amp;] (VirtualRegister operand) {
4830             if (local()-&gt;virtualRegister() == operand)
4831                 invalidate();
4832         });
4833         offset += instruction-&gt;size();
4834     }
4835 }
4836 
4837 void StructureForInContext::finalize(BytecodeGenerator&amp; generator, UnlinkedCodeBlock* codeBlock, unsigned bodyBytecodeEndOffset)
4838 {
4839     Base::finalize(generator, codeBlock, bodyBytecodeEndOffset);
4840     if (isValid())
4841         return;
4842 
4843     OpcodeID lastOpcodeID = generator.m_lastOpcodeID;
4844     InstructionStream::MutableRef lastInstruction = generator.m_lastInstruction;
4845     for (const auto&amp; instTuple : m_getInsts) {
4846         unsigned instIndex = std::get&lt;0&gt;(instTuple);
4847         int propertyRegIndex = std::get&lt;1&gt;(instTuple);
4848         auto instruction = generator.m_writer.ref(instIndex);
4849         auto end = instIndex + instruction-&gt;size();
<span class="line-modified">4850         ASSERT(instruction-&gt;isWide());</span>
4851 
4852         generator.m_writer.seek(instIndex);
4853 
4854         auto bytecode = instruction-&gt;as&lt;OpGetDirectPname&gt;();
4855 
4856         // disable peephole optimizations
4857         generator.m_lastOpcodeID = op_end;
4858 
4859         // Change the opcode to get_by_val.
4860         // 1. dst stays the same.
4861         // 2. base stays the same.
4862         // 3. property gets switched to the original property.
<span class="line-modified">4863         OpGetByVal::emit&lt;OpcodeSize::Wide&gt;(&amp;generator, bytecode.m_dst, bytecode.m_base, VirtualRegister(propertyRegIndex));</span>
4864 
4865         // 4. nop out the remaining bytes
4866         while (generator.m_writer.position() &lt; end)
4867             OpNop::emit&lt;OpcodeSize::Narrow&gt;(&amp;generator);
4868     }
4869     generator.m_writer.seek(generator.m_writer.size());
4870     if (generator.m_lastInstruction.offset() + generator.m_lastInstruction-&gt;size() != generator.m_writer.size()) {
4871         generator.m_lastOpcodeID = lastOpcodeID;
4872         generator.m_lastInstruction = lastInstruction;
4873     }
4874 }
4875 
4876 void IndexedForInContext::finalize(BytecodeGenerator&amp; generator, UnlinkedCodeBlock* codeBlock, unsigned bodyBytecodeEndOffset)
4877 {
4878     Base::finalize(generator, codeBlock, bodyBytecodeEndOffset);
4879     if (isValid())
4880         return;
4881 
4882     for (const auto&amp; instPair : m_getInsts) {
4883         unsigned instIndex = instPair.first;
4884         int propertyRegIndex = instPair.second;
<span class="line-removed">4885         // FIXME: we should not have to force this get_by_val to be wide, just guarantee that propertyRegIndex fits</span>
<span class="line-removed">4886         // https://bugs.webkit.org/show_bug.cgi?id=190929</span>
4887         generator.m_writer.ref(instIndex)-&gt;cast&lt;OpGetByVal&gt;()-&gt;setProperty(VirtualRegister(propertyRegIndex), []() {
4888             ASSERT_NOT_REACHED();
4889             return VirtualRegister();
4890         });
4891     }
4892 }
4893 
4894 void StaticPropertyAnalysis::record()
4895 {
4896     auto* instruction = m_instructionRef.ptr();
4897     auto size = m_propertyIndexes.size();
4898     switch (instruction-&gt;opcodeID()) {
4899     case OpNewObject::opcodeID:
4900         instruction-&gt;cast&lt;OpNewObject&gt;()-&gt;setInlineCapacity(size, []() {
4901             return 255;
4902         });
4903         return;
4904     case OpCreateThis::opcodeID:
4905         instruction-&gt;cast&lt;OpCreateThis&gt;()-&gt;setInlineCapacity(size, []() {
4906             return 255;
</pre>
</td>
<td>
<hr />
<pre>
  47 #include &quot;JSFixedArray.h&quot;
  48 #include &quot;JSFunction.h&quot;
  49 #include &quot;JSGeneratorFunction.h&quot;
  50 #include &quot;JSImmutableButterfly.h&quot;
  51 #include &quot;JSLexicalEnvironment.h&quot;
  52 #include &quot;JSTemplateObjectDescriptor.h&quot;
  53 #include &quot;LowLevelInterpreter.h&quot;
  54 #include &quot;Options.h&quot;
  55 #include &quot;PreciseJumpTargetsInlines.h&quot;
  56 #include &quot;StackAlignment.h&quot;
  57 #include &quot;StrongInlines.h&quot;
  58 #include &quot;SuperSamplerBytecodeScope.h&quot;
  59 #include &quot;UnlinkedCodeBlock.h&quot;
  60 #include &quot;UnlinkedEvalCodeBlock.h&quot;
  61 #include &quot;UnlinkedFunctionCodeBlock.h&quot;
  62 #include &quot;UnlinkedMetadataTableInlines.h&quot;
  63 #include &quot;UnlinkedModuleProgramCodeBlock.h&quot;
  64 #include &quot;UnlinkedProgramCodeBlock.h&quot;
  65 #include &lt;wtf/BitVector.h&gt;
  66 #include &lt;wtf/CommaPrinter.h&gt;
<span class="line-added">  67 #include &lt;wtf/Optional.h&gt;</span>
  68 #include &lt;wtf/SmallPtrSet.h&gt;
  69 #include &lt;wtf/StdLibExtras.h&gt;
  70 #include &lt;wtf/text/WTFString.h&gt;
  71 
  72 namespace JSC {
  73 
  74 template&lt;typename CallOp, typename = std::true_type&gt;
  75 struct VarArgsOp;
  76 
  77 template&lt;typename CallOp&gt;
  78 struct VarArgsOp&lt;CallOp, std::enable_if_t&lt;std::is_same&lt;CallOp, OpTailCall&gt;::value, std::true_type&gt;&gt; {
  79     using type = OpTailCallVarargs;
  80 };
  81 
  82 
  83 template&lt;typename CallOp&gt;
  84 struct VarArgsOp&lt;CallOp, std::enable_if_t&lt;!std::is_same&lt;CallOp, OpTailCall&gt;::value, std::true_type&gt;&gt; {
  85     using type = OpCallVarargs;
  86 };
  87 
</pre>
<hr />
<pre>
  98     m_location = location;
  99 
 100     for (auto offset : m_unresolvedJumps) {
 101         auto instruction = generator.m_writer.ref(offset);
 102         int target = m_location - offset;
 103 
 104 #define CASE(__op) \
 105     case __op::opcodeID:  \
 106         instruction-&gt;cast&lt;__op&gt;()-&gt;setTargetLabel(BoundLabel(target), [&amp;]() { \
 107             generator.m_codeBlock-&gt;addOutOfLineJumpTarget(instruction.offset(), target); \
 108             return BoundLabel(); \
 109         }); \
 110         break;
 111 
 112         switch (instruction-&gt;opcodeID()) {
 113         CASE(OpJmp)
 114         CASE(OpJtrue)
 115         CASE(OpJfalse)
 116         CASE(OpJeqNull)
 117         CASE(OpJneqNull)
<span class="line-added"> 118         CASE(OpJundefinedOrNull)</span>
<span class="line-added"> 119         CASE(OpJnundefinedOrNull)</span>
 120         CASE(OpJeq)
 121         CASE(OpJstricteq)
 122         CASE(OpJneq)
 123         CASE(OpJneqPtr)
 124         CASE(OpJnstricteq)
 125         CASE(OpJless)
 126         CASE(OpJlesseq)
 127         CASE(OpJgreater)
 128         CASE(OpJgreatereq)
 129         CASE(OpJnless)
 130         CASE(OpJnlesseq)
 131         CASE(OpJngreater)
 132         CASE(OpJngreatereq)
 133         CASE(OpJbelow)
 134         CASE(OpJbeloweq)
 135         default:
 136             ASSERT_NOT_REACHED();
 137         }
 138 #undef CASE
 139     }
</pre>
<hr />
<pre>
 169     if (m_type == GeneratorForward) {
 170         m_label-&gt;m_unresolvedJumps.append(m_savedTarget);
 171         return 0;
 172     }
 173 
 174     return m_savedTarget;
 175 }
 176 
 177 void Variable::dump(PrintStream&amp; out) const
 178 {
 179     out.print(
 180         &quot;{ident = &quot;, m_ident,
 181         &quot;, offset = &quot;, m_offset,
 182         &quot;, local = &quot;, RawPointer(m_local),
 183         &quot;, attributes = &quot;, m_attributes,
 184         &quot;, kind = &quot;, m_kind,
 185         &quot;, symbolTableConstantIndex = &quot;, m_symbolTableConstantIndex,
 186         &quot;, isLexicallyScoped = &quot;, m_isLexicallyScoped, &quot;}&quot;);
 187 }
 188 
<span class="line-added"> 189 FinallyContext::FinallyContext(BytecodeGenerator&amp; generator, Label&amp; finallyLabel)</span>
<span class="line-added"> 190     : m_outerContext(generator.m_currentFinallyContext)</span>
<span class="line-added"> 191     , m_finallyLabel(&amp;finallyLabel)</span>
<span class="line-added"> 192 {</span>
<span class="line-added"> 193     ASSERT(m_jumps.isEmpty());</span>
<span class="line-added"> 194     m_completionRecord.typeRegister = generator.newTemporary();</span>
<span class="line-added"> 195     m_completionRecord.valueRegister = generator.newTemporary();</span>
<span class="line-added"> 196     generator.emitLoad(completionTypeRegister(), CompletionType::Normal);</span>
<span class="line-added"> 197     generator.moveEmptyValue(completionValueRegister());</span>
<span class="line-added"> 198 }</span>
<span class="line-added"> 199 </span>
 200 ParserError BytecodeGenerator::generate()
 201 {
 202     m_codeBlock-&gt;setThisRegister(m_thisRegister.virtualRegister());
 203 
 204     emitLogShadowChickenPrologueIfNecessary();
 205 
 206     // If we have declared a variable named &quot;arguments&quot; and we are using arguments then we should
 207     // perform that assignment now.
 208     if (m_needToInitializeArguments)
 209         initializeVariable(variable(propertyNames().arguments), m_argumentsRegister);
 210 
 211     if (m_restParameter)
 212         m_restParameter-&gt;emit(*this);
 213 
 214     {
 215         RefPtr&lt;RegisterID&gt; temp = newTemporary();
 216         RefPtr&lt;RegisterID&gt; tolLevelScope;
 217         for (auto functionPair : m_functionsToInitialize) {
 218             FunctionMetadataNode* metadata = functionPair.first;
 219             FunctionVariableType functionType = functionPair.second;
</pre>
<hr />
<pre>
 242                     tolLevelScope = newBlockScopeVariable();
 243                     move(tolLevelScope.get(), tolLevelObjectScope.get());
 244                 }
 245                 emitPutToScope(tolLevelScope.get(), Variable(metadata-&gt;ident()), temp.get(), ThrowIfNotFound, InitializationMode::NotInitialization);
 246             } else
 247                 RELEASE_ASSERT_NOT_REACHED();
 248         }
 249     }
 250 
 251     bool callingClassConstructor = constructorKind() != ConstructorKind::None &amp;&amp; !isConstructor();
 252     if (!callingClassConstructor)
 253         m_scopeNode-&gt;emitBytecode(*this);
 254     else {
 255         // At this point we would have emitted an unconditional throw followed by some nonsense that&#39;s
 256         // just an artifact of how this generator is structured. That code never runs, but it confuses
 257         // bytecode analyses because it constitutes an unterminated basic block. So, we terminate the
 258         // basic block the strongest way possible.
 259         emitUnreachable();
 260     }
 261 
<span class="line-modified"> 262     for (auto&amp; handler : m_exceptionHandlersToEmit) {</span>
 263         Ref&lt;Label&gt; realCatchTarget = newLabel();
<span class="line-modified"> 264         TryData* tryData = handler.tryData;</span>
<span class="line-added"> 265 </span>
<span class="line-added"> 266         OpCatch::emit(this, handler.exceptionRegister, handler.thrownValueRegister);</span>
 267         realCatchTarget-&gt;setLocation(*this, m_lastInstruction.offset());
<span class="line-added"> 268         if (handler.completionTypeRegister.isValid()) {</span>
<span class="line-added"> 269             RegisterID completionTypeRegister { handler.completionTypeRegister };</span>
<span class="line-added"> 270             CompletionType completionType =</span>
<span class="line-added"> 271                 tryData-&gt;handlerType == HandlerType::Finally || tryData-&gt;handlerType == HandlerType::SynthesizedFinally</span>
<span class="line-added"> 272                 ? CompletionType::Throw</span>
<span class="line-added"> 273                 : CompletionType::Normal;</span>
<span class="line-added"> 274             emitLoad(&amp;completionTypeRegister, completionType);</span>
<span class="line-added"> 275         }</span>
 276         m_codeBlock-&gt;addJumpTarget(m_lastInstruction.offset());
 277 
 278 

 279         emitJump(tryData-&gt;target.get());
 280         tryData-&gt;target = WTFMove(realCatchTarget);
 281     }
 282 
 283     m_staticPropertyAnalyzer.kill();
 284 
 285     for (auto&amp; range : m_tryRanges) {
 286         int start = range.start-&gt;bind();
 287         int end = range.end-&gt;bind();
 288 
 289         // This will happen for empty try blocks and for some cases of finally blocks:
 290         //
 291         // try {
 292         //    try {
 293         //    } finally {
 294         //        return 42;
 295         //        // *HERE*
 296         //    }
 297         // } finally {
 298         //    print(&quot;things&quot;);
</pre>
<hr />
<pre>
 313 
 314         UnlinkedHandlerInfo info(static_cast&lt;uint32_t&gt;(start), static_cast&lt;uint32_t&gt;(end),
 315             static_cast&lt;uint32_t&gt;(range.tryData-&gt;target-&gt;bind()), range.tryData-&gt;handlerType);
 316         m_codeBlock-&gt;addExceptionHandler(info);
 317     }
 318 
 319 
 320     if (isGeneratorOrAsyncFunctionBodyParseMode(m_codeBlock-&gt;parseMode()))
 321         performGeneratorification(*this, m_codeBlock.get(), m_writer, m_generatorFrameSymbolTable.get(), m_generatorFrameSymbolTableIndex);
 322 
 323     RELEASE_ASSERT(static_cast&lt;unsigned&gt;(m_codeBlock-&gt;numCalleeLocals()) &lt; static_cast&lt;unsigned&gt;(FirstConstantRegisterIndex));
 324     m_codeBlock-&gt;setInstructions(m_writer.finalize());
 325 
 326     m_codeBlock-&gt;shrinkToFit();
 327 
 328     if (m_expressionTooDeep)
 329         return ParserError(ParserError::OutOfMemory);
 330     return ParserError(ParserError::ErrorNone);
 331 }
 332 
<span class="line-modified"> 333 BytecodeGenerator::BytecodeGenerator(VM&amp; vm, ProgramNode* programNode, UnlinkedProgramCodeBlock* codeBlock, OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode, const VariableEnvironment* parentScopeTDZVariables)</span>
<span class="line-modified"> 334     : m_codeGenerationMode(codeGenerationMode)</span>
 335     , m_scopeNode(programNode)
 336     , m_codeBlock(vm, codeBlock)
 337     , m_thisRegister(CallFrame::thisArgumentOffset())
 338     , m_codeType(GlobalCode)
<span class="line-modified"> 339     , m_vm(vm)</span>
 340     , m_needsToUpdateArrowFunctionContext(programNode-&gt;usesArrowFunction() || programNode-&gt;usesEval())
 341 {
 342     ASSERT_UNUSED(parentScopeTDZVariables, !parentScopeTDZVariables-&gt;size());
 343 
 344     for (auto&amp; constantRegister : m_linkTimeConstantRegisters)
 345         constantRegister = nullptr;
 346 
 347     allocateCalleeSaveSpace();
 348 
 349     m_codeBlock-&gt;setNumParameters(1); // Allocate space for &quot;this&quot;
 350 
 351     emitEnter();
 352 
 353     allocateAndEmitScope();
 354 


 355     const FunctionStack&amp; functionStack = programNode-&gt;functionStack();
 356 
 357     for (auto* function : functionStack)
 358         m_functionsToInitialize.append(std::make_pair(function, TopLevelFunctionVariable));
 359 
 360     if (Options::validateBytecode()) {
 361         for (auto&amp; entry : programNode-&gt;varDeclarations())
 362             RELEASE_ASSERT(entry.value.isVar());
 363     }
 364     codeBlock-&gt;setVariableDeclarations(programNode-&gt;varDeclarations());
 365     codeBlock-&gt;setLexicalDeclarations(programNode-&gt;lexicalVariables());
 366     // Even though this program may have lexical variables that go under TDZ, when linking the get_from_scope/put_to_scope
 367     // operations we emit we will have ResolveTypes that implictly do TDZ checks. Therefore, we don&#39;t need
 368     // additional TDZ checks on top of those. This is why we can omit pushing programNode-&gt;lexicalVariables()
 369     // to the TDZ stack.
 370 
 371     if (needsToUpdateArrowFunctionContext()) {
 372         initializeArrowFunctionContextScopeIfNeeded();
 373         emitPutThisToArrowFunctionContextScope();
 374     }
 375 }
 376 
<span class="line-modified"> 377 BytecodeGenerator::BytecodeGenerator(VM&amp; vm, FunctionNode* functionNode, UnlinkedFunctionCodeBlock* codeBlock, OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode, const VariableEnvironment* parentScopeTDZVariables)</span>
<span class="line-modified"> 378     : m_codeGenerationMode(codeGenerationMode)</span>
 379     , m_scopeNode(functionNode)
 380     , m_codeBlock(vm, codeBlock)
 381     , m_codeType(FunctionCode)
<span class="line-modified"> 382     , m_vm(vm)</span>
 383     , m_isBuiltinFunction(codeBlock-&gt;isBuiltinFunction())
 384     , m_usesNonStrictEval(codeBlock-&gt;usesEval() &amp;&amp; !codeBlock-&gt;isStrictMode())
 385     // FIXME: We should be able to have tail call elimination with the profiler
 386     // enabled. This is currently not possible because the profiler expects
 387     // op_will_call / op_did_call pairs before and after a call, which are not
 388     // compatible with tail calls (we have no way of emitting op_did_call).
 389     // https://bugs.webkit.org/show_bug.cgi?id=148819
 390     , m_inTailPosition(Options::useTailCalls() &amp;&amp; !isConstructor() &amp;&amp; constructorKind() == ConstructorKind::None &amp;&amp; isStrictMode())
 391     , m_needsToUpdateArrowFunctionContext(functionNode-&gt;usesArrowFunction() || functionNode-&gt;usesEval())
 392     , m_derivedContextType(codeBlock-&gt;derivedContextType())
 393 {
 394     for (auto&amp; constantRegister : m_linkTimeConstantRegisters)
 395         constantRegister = nullptr;
 396 



 397     allocateCalleeSaveSpace();
 398 
<span class="line-modified"> 399     SymbolTable* functionSymbolTable = SymbolTable::create(m_vm);</span>
 400     functionSymbolTable-&gt;setUsesNonStrictEval(m_usesNonStrictEval);
 401     int symbolTableConstantIndex = 0;
 402 
 403     FunctionParameters&amp; parameters = *functionNode-&gt;parameters();
 404     // http://www.ecma-international.org/ecma-262/6.0/index.html#sec-functiondeclarationinstantiation
 405     // This implements IsSimpleParameterList in the Ecma 2015 spec.
 406     // If IsSimpleParameterList is false, we will create a strict-mode like arguments object.
 407     // IsSimpleParameterList is false if the argument list contains any default parameter values,
 408     // a rest parameter, or any destructuring patterns.
 409     // If we do have default parameters, destructuring parameters, or a rest parameter, our parameters will be allocated in a different scope.
 410     bool isSimpleParameterList = parameters.isSimpleParameterList();
 411 
 412     SourceParseMode parseMode = codeBlock-&gt;parseMode();
 413 
 414     bool containsArrowOrEvalButNotInArrowBlock = ((functionNode-&gt;usesArrowFunction() &amp;&amp; functionNode-&gt;doAnyInnerArrowFunctionsUseAnyFeature()) || functionNode-&gt;usesEval()) &amp;&amp; !m_codeBlock-&gt;isArrowFunction();
<span class="line-modified"> 415     bool shouldCaptureSomeOfTheThings = shouldEmitDebugHooks() || functionNode-&gt;needsActivation() || containsArrowOrEvalButNotInArrowBlock;</span>
 416 
<span class="line-modified"> 417     bool shouldCaptureAllOfTheThings = shouldEmitDebugHooks() || codeBlock-&gt;usesEval();</span>
 418     bool needsArguments = ((functionNode-&gt;usesArguments() &amp;&amp; !codeBlock-&gt;isArrowFunction()) || codeBlock-&gt;usesEval() || (functionNode-&gt;usesArrowFunction() &amp;&amp; !codeBlock-&gt;isArrowFunction() &amp;&amp; isArgumentsUsedInInnerArrowFunction()));
 419 
 420     if (isGeneratorOrAsyncFunctionBodyParseMode(parseMode)) {
 421         // Generator and AsyncFunction never provides &quot;arguments&quot;. &quot;arguments&quot; reference will be resolved in an upper generator function scope.
 422         needsArguments = false;



 423     }
 424 
 425     if (isGeneratorOrAsyncFunctionWrapperParseMode(parseMode) &amp;&amp; needsArguments) {
 426         // Generator does not provide &quot;arguments&quot;. Instead, wrapping GeneratorFunction provides &quot;arguments&quot;.
 427         // This is because arguments of a generator should be evaluated before starting it.
 428         // To workaround it, we evaluate these arguments as arguments of a wrapping generator function, and reference it from a generator.
 429         //
 430         //    function *gen(a, b = hello())
 431         //    {
 432         //        return {
 433         //            @generatorNext: function (@generator, @generatorState, @generatorValue, @generatorResumeMode, @generatorFrame)
 434         //            {
 435         //                arguments;  // This `arguments` should reference to the gen&#39;s arguments.
 436         //                ...
 437         //            }
 438         //        }
 439         //    }
 440         shouldCaptureSomeOfTheThings = true;
 441     }
 442 
</pre>
<hr />
<pre>
 454             return true;
 455         }
 456         return functionNode-&gt;captures(uid);
 457     });
 458     auto varKind = [&amp;] (UniquedStringImpl* uid) -&gt; VarKind {
 459         return captures(uid) ? VarKind::Scope : VarKind::Stack;
 460     };
 461 
 462     m_calleeRegister.setIndex(CallFrameSlot::callee);
 463 
 464     initializeParameters(parameters);
 465     ASSERT(!(isSimpleParameterList &amp;&amp; m_restParameter));
 466 
 467     emitEnter();
 468 
 469     if (isGeneratorOrAsyncFunctionBodyParseMode(parseMode))
 470         m_generatorRegister = &amp;m_parameters[1];
 471 
 472     allocateAndEmitScope();
 473 


 474     if (functionNameIsInScope(functionNode-&gt;ident(), functionNode-&gt;functionMode())) {
 475         ASSERT(parseMode != SourceParseMode::GeneratorBodyMode);
 476         ASSERT(!isAsyncFunctionBodyParseMode(parseMode));
 477         bool isDynamicScope = functionNameScopeIsDynamic(codeBlock-&gt;usesEval(), codeBlock-&gt;isStrictMode());
 478         bool isFunctionNameCaptured = captures(functionNode-&gt;ident().impl());
 479         bool markAsCaptured = isDynamicScope || isFunctionNameCaptured;
 480         emitPushFunctionNameScope(functionNode-&gt;ident(), &amp;m_calleeRegister, markAsCaptured);
 481     }
 482 
 483     if (shouldCaptureSomeOfTheThings)
 484         m_lexicalEnvironmentRegister = addVar();
 485 
<span class="line-modified"> 486     if (isGeneratorOrAsyncFunctionBodyParseMode(parseMode) || shouldCaptureSomeOfTheThings || shouldEmitTypeProfilerHooks())</span>
 487         symbolTableConstantIndex = addConstantValue(functionSymbolTable)-&gt;index();
 488 
 489     // We can allocate the &quot;var&quot; environment if we don&#39;t have default parameter expressions. If we have
 490     // default parameter expressions, we have to hold off on allocating the &quot;var&quot; environment because
 491     // the parent scope of the &quot;var&quot; environment is the parameter environment.
 492     if (isSimpleParameterList)
 493         initializeVarLexicalEnvironment(symbolTableConstantIndex, functionSymbolTable, shouldCaptureSomeOfTheThings);
 494 
 495     // Figure out some interesting facts about our arguments.
 496     bool capturesAnyArgumentByName = false;
 497     if (functionNode-&gt;hasCapturedVariables()) {
 498         FunctionParameters&amp; parameters = *functionNode-&gt;parameters();
 499         for (size_t i = 0; i &lt; parameters.size(); ++i) {
 500             auto pattern = parameters.at(i).first;
 501             if (!pattern-&gt;isBindingNode())
 502                 continue;
 503             const Identifier&amp; ident = static_cast&lt;const BindingNode*&gt;(pattern)-&gt;boundProperty();
 504             capturesAnyArgumentByName |= captures(ident.impl());
 505         }
 506     }
</pre>
<hr />
<pre>
 529         // use DirectArguments. With ScopedArguments, we lift all of our arguments into the
 530         // activation.
 531 
 532         if (capturesAnyArgumentByName) {
 533             functionSymbolTable-&gt;setArgumentsLength(vm, parameters.size());
 534 
 535             // For each parameter, we have two possibilities:
 536             // Either it&#39;s a binding node with no function overlap, in which case it gets a name
 537             // in the symbol table - or it just gets space reserved in the symbol table. Either
 538             // way we lift the value into the scope.
 539             for (unsigned i = 0; i &lt; parameters.size(); ++i) {
 540                 ScopeOffset offset = functionSymbolTable-&gt;takeNextScopeOffset(NoLockingNecessary);
 541                 functionSymbolTable-&gt;setArgumentOffset(vm, i, offset);
 542                 if (UniquedStringImpl* name = visibleNameForParameter(parameters.at(i).first)) {
 543                     VarOffset varOffset(offset);
 544                     SymbolTableEntry entry(varOffset);
 545                     // Stores to these variables via the ScopedArguments object will not do
 546                     // notifyWrite(), since that would be cumbersome. Also, watching formal
 547                     // parameters when &quot;arguments&quot; is in play is unlikely to be super profitable.
 548                     // So, we just disable it.
<span class="line-modified"> 549                     entry.disableWatching(m_vm);</span>
 550                     functionSymbolTable-&gt;set(NoLockingNecessary, name, entry);
 551                 }
<span class="line-modified"> 552                 OpPutToScope::emit(this, m_lexicalEnvironmentRegister, UINT_MAX, virtualRegisterForArgument(1 + i), GetPutInfo(ThrowIfNotFound, LocalClosureVar, InitializationMode::NotInitialization), SymbolTableOrScopeDepth::symbolTable(VirtualRegister { symbolTableConstantIndex }), offset.offset());</span>
 553             }
 554 
 555             // This creates a scoped arguments object and copies the overflow arguments into the
 556             // scope. It&#39;s the equivalent of calling ScopedArguments::createByCopying().
 557             OpCreateScopedArguments::emit(this, m_argumentsRegister, m_lexicalEnvironmentRegister);
 558         } else {
 559             // We&#39;re going to put all parameters into the DirectArguments object. First ensure
 560             // that the symbol table knows that this is happening.
 561             for (unsigned i = 0; i &lt; parameters.size(); ++i) {
 562                 if (UniquedStringImpl* name = visibleNameForParameter(parameters.at(i).first))
 563                     functionSymbolTable-&gt;set(NoLockingNecessary, name, SymbolTableEntry(VarOffset(DirectArgumentsOffset(i))));
 564             }
 565 
 566             OpCreateDirectArguments::emit(this, m_argumentsRegister);
 567         }
 568     } else if (isSimpleParameterList) {
 569         // Create the formal parameters the normal way. Any of them could be captured, or not. If
 570         // captured, lift them into the scope. We cannot do this if we have default parameter expressions
 571         // because when default parameter expressions exist, they belong in their own lexical environment
 572         // separate from the &quot;var&quot; lexical environment.
 573         for (unsigned i = 0; i &lt; parameters.size(); ++i) {
 574             UniquedStringImpl* name = visibleNameForParameter(parameters.at(i).first);
 575             if (!name)
 576                 continue;
 577 
 578             if (!captures(name)) {
 579                 // This is the easy case - just tell the symbol table about the argument. It will
 580                 // be accessed directly.
 581                 functionSymbolTable-&gt;set(NoLockingNecessary, name, SymbolTableEntry(VarOffset(virtualRegisterForArgument(1 + i))));
 582                 continue;
 583             }
 584 
 585             ScopeOffset offset = functionSymbolTable-&gt;takeNextScopeOffset(NoLockingNecessary);
 586             const Identifier&amp; ident =
 587                 static_cast&lt;const BindingNode*&gt;(parameters.at(i).first)-&gt;boundProperty();
 588             functionSymbolTable-&gt;set(NoLockingNecessary, name, SymbolTableEntry(VarOffset(offset)));
 589 
<span class="line-modified"> 590             OpPutToScope::emit(this, m_lexicalEnvironmentRegister, addConstant(ident), virtualRegisterForArgument(1 + i), GetPutInfo(ThrowIfNotFound, LocalClosureVar, InitializationMode::NotInitialization), SymbolTableOrScopeDepth::symbolTable(VirtualRegister { symbolTableConstantIndex }), offset.offset());</span>
 591         }
 592     }
 593 
 594     if (needsArguments &amp;&amp; (codeBlock-&gt;isStrictMode() || !isSimpleParameterList)) {
 595         // Allocate a cloned arguments object.
 596         OpCreateClonedArguments::emit(this, m_argumentsRegister);
 597     }
 598 
 599     // There are some variables that need to be preinitialized to something other than Undefined:
 600     //
 601     // - &quot;arguments&quot;: unless it&#39;s used as a function or parameter, this should refer to the
 602     //   arguments object.
 603     //
 604     // - functions: these always override everything else.
 605     //
 606     // The most logical way to do all of this is to initialize none of the variables until now,
 607     // and then initialize them in BytecodeGenerator::generate() in such an order that the rules
 608     // for how these things override each other end up holding. We would initialize &quot;arguments&quot; first,
 609     // then all arguments, then the functions.
 610     //
</pre>
<hr />
<pre>
 646 
 647             m_needToInitializeArguments = true;
 648         }
 649     }
 650 
 651     for (FunctionMetadataNode* function : functionNode-&gt;functionStack()) {
 652         const Identifier&amp; ident = function-&gt;ident();
 653         createVariable(ident, varKind(ident.impl()), functionSymbolTable);
 654         m_functionsToInitialize.append(std::make_pair(function, NormalFunctionVariable));
 655     }
 656     for (auto&amp; entry : functionNode-&gt;varDeclarations()) {
 657         ASSERT(!entry.value.isLet() &amp;&amp; !entry.value.isConst());
 658         if (!entry.value.isVar()) // This is either a parameter or callee.
 659             continue;
 660         if (shouldCreateArgumentsVariableInParameterScope &amp;&amp; entry.key.get() == propertyNames().arguments.impl())
 661             continue;
 662         createVariable(Identifier::fromUid(m_vm, entry.key.get()), varKind(entry.key.get()), functionSymbolTable, IgnoreExisting);
 663     }
 664 
 665 
<span class="line-modified"> 666     if (functionNode-&gt;needsNewTargetRegisterForThisScope() || isNewTargetUsedInInnerArrowFunction() || codeBlock-&gt;usesEval())</span>
<span class="line-added"> 667         m_newTargetRegister = addVar();</span>
<span class="line-added"> 668 </span>
 669     switch (parseMode) {
 670     case SourceParseMode::GeneratorWrapperFunctionMode:
 671     case SourceParseMode::GeneratorWrapperMethodMode:
 672     case SourceParseMode::AsyncGeneratorWrapperMethodMode:
 673     case SourceParseMode::AsyncGeneratorWrapperFunctionMode: {
 674         m_generatorRegister = addVar();
 675 
 676         // FIXME: Emit to_this only when Generator uses it.
 677         // https://bugs.webkit.org/show_bug.cgi?id=151586
 678         emitToThis();
 679 
 680         move(m_generatorRegister, &amp;m_calleeRegister);
 681         emitCreateThis(m_generatorRegister);
 682         break;
 683     }
 684 
 685     case SourceParseMode::AsyncArrowFunctionMode:
 686     case SourceParseMode::AsyncMethodMode:
 687     case SourceParseMode::AsyncFunctionMode: {
 688         ASSERT(!isConstructor());
</pre>
<hr />
<pre>
 706 
 707         CallArguments args(*this, nullptr, 1);
 708         emitLoad(args.thisRegister(), jsUndefined());
 709 
 710         auto&amp; builtinNames = propertyNames().builtinNames();
 711         auto varPromiseConstructor = variable(m_isBuiltinFunction ? builtinNames.InternalPromisePrivateName() : builtinNames.PromisePrivateName());
 712         move(scope.get(), emitResolveScope(scope.get(), varPromiseConstructor));
 713         emitGetFromScope(args.argumentRegister(0), scope.get(), varPromiseConstructor, ThrowIfNotFound);
 714 
 715         // JSTextPosition(int _line, int _offset, int _lineStartOffset)
 716         JSTextPosition divot(m_scopeNode-&gt;firstLine(), m_scopeNode-&gt;startOffset(), m_scopeNode-&gt;lineStartOffset());
 717         emitCall(promiseCapabilityRegister(), newPromiseCapability.get(), NoExpectedFunction, args, divot, divot, divot, DebuggableCall::No);
 718         break;
 719     }
 720 
 721     case SourceParseMode::AsyncGeneratorBodyMode:
 722     case SourceParseMode::AsyncFunctionBodyMode:
 723     case SourceParseMode::AsyncArrowFunctionBodyMode:
 724     case SourceParseMode::GeneratorBodyMode: {
 725         // |this| is already filled correctly before here.
<span class="line-modified"> 726         if (m_newTargetRegister)</span>
<span class="line-added"> 727             emitLoad(m_newTargetRegister, jsUndefined());</span>
 728         break;
 729     }
 730 
 731     default: {
 732         if (SourceParseMode::ArrowFunctionMode != parseMode) {
 733             if (isConstructor()) {
<span class="line-modified"> 734                 if (m_newTargetRegister)</span>
<span class="line-added"> 735                     move(m_newTargetRegister, &amp;m_thisRegister);</span>
 736                 if (constructorKind() == ConstructorKind::Extends) {
 737                     moveEmptyValue(&amp;m_thisRegister);
 738                 } else
 739                     emitCreateThis(&amp;m_thisRegister);
 740             } else if (constructorKind() != ConstructorKind::None)
 741                 emitThrowTypeError(&quot;Cannot call a class constructor without |new|&quot;);
 742             else {
 743                 bool shouldEmitToThis = false;
 744                 if (functionNode-&gt;usesThis() || codeBlock-&gt;usesEval() || m_scopeNode-&gt;doAnyInnerArrowFunctionsUseThis() || m_scopeNode-&gt;doAnyInnerArrowFunctionsUseEval())
 745                     shouldEmitToThis = true;
 746                 else if ((functionNode-&gt;usesSuperProperty() || m_scopeNode-&gt;doAnyInnerArrowFunctionsUseSuperProperty()) &amp;&amp; !codeBlock-&gt;isStrictMode()) {
 747                     // We must emit to_this when we&#39;re not in strict mode because we
 748                     // will convert |this| to an object, and that object may be passed
 749                     // to a strict function as |this|. This is observable because that
 750                     // strict function&#39;s to_this will just return the object.
 751                     //
 752                     // We don&#39;t need to emit this for strict-mode code because
 753                     // strict-mode code may call another strict function, which will
 754                     // to_this if it directly uses this; this is OK, because we defer
 755                     // to_this until |this| is used directly. Strict-mode code might
 756                     // also call a sloppy mode function, and that will to_this, which
 757                     // will defer the conversion, again, until necessary.
 758                     shouldEmitToThis = true;
 759                 }
 760 
 761                 if (shouldEmitToThis)
 762                     emitToThis();
 763             }
 764         }
 765         break;
 766     }
 767     }
 768 
 769     // We need load |super| &amp; |this| for arrow function before initializeDefaultParameterValuesAndSetupFunctionScopeStack
 770     // if we have default parameter expression. Because |super| &amp; |this| values can be used there
 771     if ((SourceParseModeSet(SourceParseMode::ArrowFunctionMode, SourceParseMode::AsyncArrowFunctionMode).contains(parseMode) &amp;&amp; !isSimpleParameterList) || parseMode == SourceParseMode::AsyncArrowFunctionBodyMode) {
 772         if (functionNode-&gt;usesThis() || functionNode-&gt;usesSuperProperty())
 773             emitLoadThisFromArrowFunctionLexicalEnvironment();
 774 
<span class="line-modified"> 775         if (m_scopeNode-&gt;needsNewTargetRegisterForThisScope())</span>
 776             emitLoadNewTargetFromArrowFunctionLexicalEnvironment();
 777     }
 778 
 779     if (needsToUpdateArrowFunctionContext() &amp;&amp; !codeBlock-&gt;isArrowFunction()) {
 780         bool canReuseLexicalEnvironment = isSimpleParameterList;
 781         initializeArrowFunctionContextScopeIfNeeded(functionSymbolTable, canReuseLexicalEnvironment);
 782         emitPutThisToArrowFunctionContextScope();
 783         emitPutNewTargetToArrowFunctionContextScope();
 784         emitPutDerivedConstructorToArrowFunctionContextScope();
 785     }
 786 
 787     // All &quot;addVar()&quot;s needs to happen before &quot;initializeDefaultParameterValuesAndSetupFunctionScopeStack()&quot; is called
 788     // because a function&#39;s default parameter ExpressionNodes will use temporary registers.
 789     pushTDZVariables(*parentScopeTDZVariables, TDZCheckOptimization::DoNotOptimize, TDZRequirement::UnderTDZ);
 790 
 791     Ref&lt;Label&gt; catchLabel = newLabel();
 792     TryData* tryFormalParametersData = nullptr;
 793     bool needTryCatch = isAsyncFunctionWrapperParseMode(parseMode) &amp;&amp; !isSimpleParameterList;
 794     if (needTryCatch) {
 795         Ref&lt;Label&gt; tryFormalParametersStart = newEmittedLabel();
 796         tryFormalParametersData = pushTry(tryFormalParametersStart.get(), catchLabel.get(), HandlerType::SynthesizedCatch);
 797     }
 798 
 799     initializeDefaultParameterValuesAndSetupFunctionScopeStack(parameters, isSimpleParameterList, functionNode, functionSymbolTable, symbolTableConstantIndex, captures, shouldCreateArgumentsVariableInParameterScope);
 800 
 801     if (needTryCatch) {
 802         Ref&lt;Label&gt; didNotThrow = newLabel();
 803         emitJump(didNotThrow.get());
 804         emitLabel(catchLabel.get());
 805         popTry(tryFormalParametersData, catchLabel.get());
 806 
 807         RefPtr&lt;RegisterID&gt; thrownValue = newTemporary();
<span class="line-modified"> 808         emitOutOfLineCatchHandler(thrownValue.get(), nullptr, tryFormalParametersData);</span>

 809 
 810         // return promiseCapability.@reject(thrownValue)
<span class="line-modified"> 811         RefPtr&lt;RegisterID&gt; reject = emitGetById(newTemporary(), promiseCapabilityRegister(), m_vm.propertyNames-&gt;builtinNames().rejectPrivateName());</span>
 812 
 813         CallArguments args(*this, nullptr, 1);
 814         emitLoad(args.thisRegister(), jsUndefined());
 815         move(args.argumentRegister(0), thrownValue.get());
 816 
 817         JSTextPosition divot(functionNode-&gt;firstLine(), functionNode-&gt;startOffset(), functionNode-&gt;lineStartOffset());
 818 
 819         RefPtr&lt;RegisterID&gt; result = emitCall(newTemporary(), reject.get(), NoExpectedFunction, args, divot, divot, divot, DebuggableCall::No);
<span class="line-modified"> 820         emitReturn(emitGetById(newTemporary(), promiseCapabilityRegister(), m_vm.propertyNames-&gt;builtinNames().promisePrivateName()));</span>
 821 
 822         emitLabel(didNotThrow.get());
 823     }
 824 
 825     // If we don&#39;t have  default parameter expression, then loading |this| inside an arrow function must be done
 826     // after initializeDefaultParameterValuesAndSetupFunctionScopeStack() because that function sets up the
 827     // SymbolTable stack and emitLoadThisFromArrowFunctionLexicalEnvironment() consults the SymbolTable stack
 828     if (SourceParseModeSet(SourceParseMode::ArrowFunctionMode, SourceParseMode::AsyncArrowFunctionMode).contains(parseMode) &amp;&amp; isSimpleParameterList) {
 829         if (functionNode-&gt;usesThis() || functionNode-&gt;usesSuperProperty())
 830             emitLoadThisFromArrowFunctionLexicalEnvironment();
 831 
<span class="line-modified"> 832         if (m_scopeNode-&gt;needsNewTargetRegisterForThisScope())</span>
 833             emitLoadNewTargetFromArrowFunctionLexicalEnvironment();
 834     }
 835 
 836     // Set up the lexical environment scope as the generator frame. We store the saved and resumed generator registers into this scope with the symbol keys.
 837     // Since they are symbol keyed, these variables cannot be reached from the usual code.
 838     if (isGeneratorOrAsyncFunctionBodyParseMode(parseMode)) {
<span class="line-modified"> 839         m_generatorFrameSymbolTable.set(m_vm, functionSymbolTable);</span>

 840         m_generatorFrameSymbolTableIndex = symbolTableConstantIndex;
<span class="line-modified"> 841         if (m_lexicalEnvironmentRegister)</span>
<span class="line-added"> 842             move(generatorFrameRegister(), m_lexicalEnvironmentRegister);</span>
<span class="line-added"> 843         else {</span>
<span class="line-added"> 844             // It would be possible that generator does not need to suspend and resume any registers.</span>
<span class="line-added"> 845             // In this case, we would like to avoid creating a lexical environment as much as possible.</span>
<span class="line-added"> 846             // op_create_generator_frame_environment is a marker, which is similar to op_yield.</span>
<span class="line-added"> 847             // Generatorification inserts lexical environment creation if necessary. Otherwise, we convert it to op_mov frame, `undefined`.</span>
<span class="line-added"> 848             OpCreateGeneratorFrameEnvironment::emit(this, generatorFrameRegister(), scopeRegister(), VirtualRegister { symbolTableConstantIndex }, addConstantValue(jsUndefined()));</span>
<span class="line-added"> 849         }</span>
 850         emitPutById(generatorRegister(), propertyNames().builtinNames().generatorFramePrivateName(), generatorFrameRegister());
 851     }
 852 
 853     bool shouldInitializeBlockScopedFunctions = false; // We generate top-level function declarations in ::generate().
 854     pushLexicalScope(m_scopeNode, TDZCheckOptimization::Optimize, NestedScopeType::IsNotNested, nullptr, shouldInitializeBlockScopedFunctions);
 855 }
 856 
<span class="line-modified"> 857 BytecodeGenerator::BytecodeGenerator(VM&amp; vm, EvalNode* evalNode, UnlinkedEvalCodeBlock* codeBlock, OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode, const VariableEnvironment* parentScopeTDZVariables)</span>
<span class="line-modified"> 858     : m_codeGenerationMode(codeGenerationMode)</span>
 859     , m_scopeNode(evalNode)
 860     , m_codeBlock(vm, codeBlock)
 861     , m_thisRegister(CallFrame::thisArgumentOffset())
 862     , m_codeType(EvalCode)
<span class="line-modified"> 863     , m_vm(vm)</span>
 864     , m_usesNonStrictEval(codeBlock-&gt;usesEval() &amp;&amp; !codeBlock-&gt;isStrictMode())
 865     , m_needsToUpdateArrowFunctionContext(evalNode-&gt;usesArrowFunction() || evalNode-&gt;usesEval())
 866     , m_derivedContextType(codeBlock-&gt;derivedContextType())
 867 {
 868     for (auto&amp; constantRegister : m_linkTimeConstantRegisters)
 869         constantRegister = nullptr;
 870 
 871     allocateCalleeSaveSpace();
 872 
 873     m_codeBlock-&gt;setNumParameters(1);
 874 
 875     pushTDZVariables(*parentScopeTDZVariables, TDZCheckOptimization::DoNotOptimize, TDZRequirement::UnderTDZ);
 876 
 877     emitEnter();
 878 
 879     allocateAndEmitScope();
 880 


 881     for (FunctionMetadataNode* function : evalNode-&gt;functionStack()) {
 882         m_codeBlock-&gt;addFunctionDecl(makeFunction(function));
 883         m_functionsToInitialize.append(std::make_pair(function, TopLevelFunctionVariable));
 884     }
 885 
 886     const VariableEnvironment&amp; varDeclarations = evalNode-&gt;varDeclarations();
 887     Vector&lt;Identifier, 0, UnsafeVectorOverflow&gt; variables;
 888     Vector&lt;Identifier, 0, UnsafeVectorOverflow&gt; hoistedFunctions;
 889     for (auto&amp; entry : varDeclarations) {
 890         ASSERT(entry.value.isVar());
<span class="line-modified"> 891         ASSERT(entry.key-&gt;isAtom() || entry.key-&gt;isSymbol());</span>
 892         if (entry.value.isSloppyModeHoistingCandidate())
 893             hoistedFunctions.append(Identifier::fromUid(m_vm, entry.key.get()));
 894         else
 895             variables.append(Identifier::fromUid(m_vm, entry.key.get()));
 896     }
 897     codeBlock-&gt;adoptVariables(variables);
 898     codeBlock-&gt;adoptFunctionHoistingCandidates(WTFMove(hoistedFunctions));
 899 
<span class="line-modified"> 900     if (evalNode-&gt;needsNewTargetRegisterForThisScope())</span>
 901         m_newTargetRegister = addVar();
 902 
 903     if (codeBlock-&gt;isArrowFunctionContext() &amp;&amp; (evalNode-&gt;usesThis() || evalNode-&gt;usesSuperProperty()))
 904         emitLoadThisFromArrowFunctionLexicalEnvironment();
 905 
<span class="line-modified"> 906     if (evalNode-&gt;needsNewTargetRegisterForThisScope())</span>
 907         emitLoadNewTargetFromArrowFunctionLexicalEnvironment();
 908 
 909     if (needsToUpdateArrowFunctionContext() &amp;&amp; !codeBlock-&gt;isArrowFunctionContext() &amp;&amp; !isDerivedConstructorContext()) {
 910         initializeArrowFunctionContextScopeIfNeeded();
 911         emitPutThisToArrowFunctionContextScope();
 912     }
 913 
 914     bool shouldInitializeBlockScopedFunctions = false; // We generate top-level function declarations in ::generate().
 915     pushLexicalScope(m_scopeNode, TDZCheckOptimization::Optimize, NestedScopeType::IsNotNested, nullptr, shouldInitializeBlockScopedFunctions);
 916 }
 917 
<span class="line-modified"> 918 BytecodeGenerator::BytecodeGenerator(VM&amp; vm, ModuleProgramNode* moduleProgramNode, UnlinkedModuleProgramCodeBlock* codeBlock, OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode, const VariableEnvironment* parentScopeTDZVariables)</span>
<span class="line-modified"> 919     : m_codeGenerationMode(codeGenerationMode)</span>
 920     , m_scopeNode(moduleProgramNode)
 921     , m_codeBlock(vm, codeBlock)
 922     , m_thisRegister(CallFrame::thisArgumentOffset())
 923     , m_codeType(ModuleCode)
<span class="line-modified"> 924     , m_vm(vm)</span>
 925     , m_usesNonStrictEval(false)
 926     , m_needsToUpdateArrowFunctionContext(moduleProgramNode-&gt;usesArrowFunction() || moduleProgramNode-&gt;usesEval())
 927 {
 928     ASSERT_UNUSED(parentScopeTDZVariables, !parentScopeTDZVariables-&gt;size());
 929 
 930     for (auto&amp; constantRegister : m_linkTimeConstantRegisters)
 931         constantRegister = nullptr;
 932 



 933     allocateCalleeSaveSpace();
 934 
<span class="line-modified"> 935     SymbolTable* moduleEnvironmentSymbolTable = SymbolTable::create(m_vm);</span>
 936     moduleEnvironmentSymbolTable-&gt;setUsesNonStrictEval(m_usesNonStrictEval);
 937     moduleEnvironmentSymbolTable-&gt;setScopeType(SymbolTable::ScopeType::LexicalScope);
 938 
<span class="line-modified"> 939     bool shouldCaptureAllOfTheThings = shouldEmitDebugHooks() || codeBlock-&gt;usesEval();</span>
 940     if (shouldCaptureAllOfTheThings)
 941         moduleProgramNode-&gt;varDeclarations().markAllVariablesAsCaptured();
 942 
 943     auto captures = [&amp;] (UniquedStringImpl* uid) -&gt; bool {
 944         return moduleProgramNode-&gt;captures(uid);
 945     };
 946     auto lookUpVarKind = [&amp;] (UniquedStringImpl* uid, const VariableEnvironmentEntry&amp; entry) -&gt; VarKind {
 947         // Allocate the exported variables in the module environment.
 948         if (entry.isExported())
 949             return VarKind::Scope;
 950 
 951         // Allocate the namespace variables in the module environment to instantiate
 952         // it from the outside of the module code.
 953         if (entry.isImportedNamespace())
 954             return VarKind::Scope;
 955 
 956         if (entry.isCaptured())
 957             return VarKind::Scope;
 958         return captures(uid) ? VarKind::Scope : VarKind::Stack;
 959     };
 960 
 961     emitEnter();
 962 
 963     allocateAndEmitScope();
 964 


 965     m_calleeRegister.setIndex(CallFrameSlot::callee);
 966 
 967     m_codeBlock-&gt;setNumParameters(1); // Allocate space for &quot;this&quot;
 968 
 969     // Now declare all variables.
 970 
<span class="line-modified"> 971     createVariable(m_vm.propertyNames-&gt;builtinNames().metaPrivateName(), VarKind::Scope, moduleEnvironmentSymbolTable, VerifyExisting);</span>
 972 
 973     for (auto&amp; entry : moduleProgramNode-&gt;varDeclarations()) {
 974         ASSERT(!entry.value.isLet() &amp;&amp; !entry.value.isConst());
 975         if (!entry.value.isVar()) // This is either a parameter or callee.
 976             continue;
 977         // Imported bindings are not allocated in the module environment as usual variables&#39; way.
 978         // These references remain the &quot;Dynamic&quot; in the unlinked code block. Later, when linking
 979         // the code block, we resolve the reference to the &quot;ModuleVar&quot;.
 980         if (entry.value.isImported() &amp;&amp; !entry.value.isImportedNamespace())
 981             continue;
 982         createVariable(Identifier::fromUid(m_vm, entry.key.get()), lookUpVarKind(entry.key.get(), entry.value), moduleEnvironmentSymbolTable, IgnoreExisting);
 983     }
 984 
 985     VariableEnvironment&amp; lexicalVariables = moduleProgramNode-&gt;lexicalVariables();
 986     instantiateLexicalVariables(lexicalVariables, moduleEnvironmentSymbolTable, ScopeRegisterType::Block, lookUpVarKind);
 987 
 988     // We keep the symbol table in the constant pool.
 989     RegisterID* constantSymbolTable = nullptr;
<span class="line-modified"> 990     if (shouldEmitTypeProfilerHooks())</span>
 991         constantSymbolTable = addConstantValue(moduleEnvironmentSymbolTable);
 992     else
<span class="line-modified"> 993         constantSymbolTable = addConstantValue(moduleEnvironmentSymbolTable-&gt;cloneScopePart(m_vm));</span>
 994 
 995     pushTDZVariables(lexicalVariables, TDZCheckOptimization::Optimize, TDZRequirement::UnderTDZ);
 996     bool isWithScope = false;
 997     m_lexicalScopeStack.append({ moduleEnvironmentSymbolTable, m_topMostScope, isWithScope, constantSymbolTable-&gt;index() });
 998     emitPrefillStackTDZVariables(lexicalVariables, moduleEnvironmentSymbolTable);
 999 
1000     // makeFunction assumes that there&#39;s correct TDZ stack entries.
1001     // So it should be called after putting our lexical environment to the TDZ stack correctly.
1002 
1003     for (FunctionMetadataNode* function : moduleProgramNode-&gt;functionStack()) {
1004         const auto&amp; iterator = moduleProgramNode-&gt;varDeclarations().find(function-&gt;ident().impl());
1005         RELEASE_ASSERT(iterator != moduleProgramNode-&gt;varDeclarations().end());
1006         RELEASE_ASSERT(!iterator-&gt;value.isImported());
1007 
1008         VarKind varKind = lookUpVarKind(iterator-&gt;key.get(), iterator-&gt;value);
1009         if (varKind == VarKind::Scope) {
1010             // http://www.ecma-international.org/ecma-262/6.0/#sec-moduledeclarationinstantiation
1011             // Section 15.2.1.16.4, step 16-a-iv-1.
1012             // All heap allocated function declarations should be instantiated when the module environment
1013             // is created. They include the exported function declarations and not-exported-but-heap-allocated
</pre>
<hr />
<pre>
1320 
1321     // Allocate new label ID.
1322     m_labels.append();
1323     return m_labels.last();
1324 }
1325 
1326 Ref&lt;Label&gt; BytecodeGenerator::newEmittedLabel()
1327 {
1328     Ref&lt;Label&gt; label = newLabel();
1329     emitLabel(label.get());
1330     return label;
1331 }
1332 
1333 void BytecodeGenerator::recordOpcode(OpcodeID opcodeID)
1334 {
1335     ASSERT(m_lastOpcodeID == op_end || (m_lastOpcodeID == m_lastInstruction-&gt;opcodeID() &amp;&amp; m_writer.position() == m_lastInstruction.offset() + m_lastInstruction-&gt;size()));
1336     m_lastInstruction = m_writer.ref();
1337     m_lastOpcodeID = opcodeID;
1338 }
1339 
<span class="line-modified">1340 void BytecodeGenerator::alignWideOpcode16()</span>
<span class="line-added">1341 {</span>
<span class="line-added">1342 #if CPU(NEEDS_ALIGNED_ACCESS)</span>
<span class="line-added">1343     while ((m_writer.position() + 1) % OpcodeSize::Wide16)</span>
<span class="line-added">1344         OpNop::emit&lt;OpcodeSize::Narrow&gt;(this);</span>
<span class="line-added">1345 #endif</span>
<span class="line-added">1346 }</span>
<span class="line-added">1347 </span>
<span class="line-added">1348 void BytecodeGenerator::alignWideOpcode32()</span>
1349 {
1350 #if CPU(NEEDS_ALIGNED_ACCESS)
<span class="line-modified">1351     while ((m_writer.position() + 1) % OpcodeSize::Wide32)</span>
1352         OpNop::emit&lt;OpcodeSize::Narrow&gt;(this);
1353 #endif
1354 }
1355 
1356 void BytecodeGenerator::emitLabel(Label&amp; l0)
1357 {
1358     unsigned newLabelIndex = instructions().size();
1359     l0.setLocation(*this, newLabelIndex);
1360 
1361     if (m_codeBlock-&gt;numberOfJumpTargets()) {
1362         unsigned lastLabelIndex = m_codeBlock-&gt;lastJumpTarget();
1363         ASSERT(lastLabelIndex &lt;= newLabelIndex);
1364         if (newLabelIndex == lastLabelIndex) {
1365             // Peephole optimizations have already been disabled by emitting the last label
1366             return;
1367         }
1368     }
1369 
1370     m_codeBlock-&gt;addJumpTarget(newLabelIndex);
1371 
1372     // This disables peephole optimizations when an instruction is a jump target
1373     m_lastOpcodeID = op_end;
1374 }
1375 
1376 void BytecodeGenerator::emitEnter()
1377 {
1378     OpEnter::emit(this);
1379 
1380     if (LIKELY(Options::optimizeRecursiveTailCalls())) {
1381         // We must add the end of op_enter as a potential jump target, because the bytecode parser may decide to split its basic block
1382         // to have somewhere to jump to if there is a recursive tail-call that points to this function.
1383         m_codeBlock-&gt;addJumpTarget(instructions().size());
1384         // This disables peephole optimizations when an instruction is a jump target
1385         m_lastOpcodeID = op_end;
1386     }
1387 }
1388 
1389 void BytecodeGenerator::emitLoopHint()
1390 {
1391     OpLoopHint::emit(this);

1392 }
1393 
1394 void BytecodeGenerator::emitJump(Label&amp; target)
1395 {
1396     OpJmp::emit(this, target.bind(this));
1397 }
1398 





1399 void ALWAYS_INLINE BytecodeGenerator::rewind()
1400 {
1401     ASSERT(m_lastInstruction.isValid());
1402     m_lastOpcodeID = op_end;
1403     m_writer.rewind(m_lastInstruction);
1404 }
1405 
1406 template&lt;typename BinOp, typename JmpOp&gt;
1407 bool BytecodeGenerator::fuseCompareAndJump(RegisterID* cond, Label&amp; target, bool swapOperands)
1408 {
<span class="line-added">1409     ASSERT(canDoPeepholeOptimization());</span>
1410     auto binop = m_lastInstruction-&gt;as&lt;BinOp&gt;();
1411     if (cond-&gt;index() == binop.m_dst.offset() &amp;&amp; cond-&gt;isTemporary() &amp;&amp; !cond-&gt;refCount()) {
1412         rewind();
1413 
1414         if (swapOperands)
1415             std::swap(binop.m_lhs, binop.m_rhs);
1416 
1417         JmpOp::emit(this, binop.m_lhs, binop.m_rhs, target.bind(this));
1418         return true;
1419     }
1420     return false;
1421 }
1422 
1423 template&lt;typename UnaryOp, typename JmpOp&gt;
1424 bool BytecodeGenerator::fuseTestAndJmp(RegisterID* cond, Label&amp; target)
1425 {
<span class="line-added">1426     ASSERT(canDoPeepholeOptimization());</span>
1427     auto unop = m_lastInstruction-&gt;as&lt;UnaryOp&gt;();
1428     if (cond-&gt;index() == unop.m_dst.offset() &amp;&amp; cond-&gt;isTemporary() &amp;&amp; !cond-&gt;refCount()) {
1429         rewind();
1430 
1431         JmpOp::emit(this, unop.m_operand, target.bind(this));
1432         return true;
1433     }
1434     return false;
1435 }
1436 
1437 void BytecodeGenerator::emitJumpIfTrue(RegisterID* cond, Label&amp; target)
1438 {
<span class="line-modified">1439     if (canDoPeepholeOptimization()) {</span>
<span class="line-modified">1440         if (m_lastOpcodeID == op_less) {</span>
<span class="line-modified">1441             if (fuseCompareAndJump&lt;OpLess, OpJless&gt;(cond, target))</span>
<span class="line-modified">1442                 return;</span>
<span class="line-modified">1443         } else if (m_lastOpcodeID == op_lesseq) {</span>
<span class="line-modified">1444             if (fuseCompareAndJump&lt;OpLesseq, OpJlesseq&gt;(cond, target))</span>
<span class="line-modified">1445                 return;</span>
<span class="line-modified">1446         } else if (m_lastOpcodeID == op_greater) {</span>
<span class="line-modified">1447             if (fuseCompareAndJump&lt;OpGreater, OpJgreater&gt;(cond, target))</span>
<span class="line-modified">1448                 return;</span>
<span class="line-modified">1449         } else if (m_lastOpcodeID == op_greatereq) {</span>
<span class="line-modified">1450             if (fuseCompareAndJump&lt;OpGreatereq, OpJgreatereq&gt;(cond, target))</span>
<span class="line-modified">1451                 return;</span>
<span class="line-modified">1452         } else if (m_lastOpcodeID == op_eq) {</span>
<span class="line-modified">1453             if (fuseCompareAndJump&lt;OpEq, OpJeq&gt;(cond, target))</span>
<span class="line-modified">1454                 return;</span>
<span class="line-modified">1455         } else if (m_lastOpcodeID == op_stricteq) {</span>
<span class="line-modified">1456             if (fuseCompareAndJump&lt;OpStricteq, OpJstricteq&gt;(cond, target))</span>
<span class="line-modified">1457                 return;</span>
<span class="line-modified">1458         } else if (m_lastOpcodeID == op_neq) {</span>
<span class="line-modified">1459             if (fuseCompareAndJump&lt;OpNeq, OpJneq&gt;(cond, target))</span>
<span class="line-modified">1460                 return;</span>
<span class="line-modified">1461         } else if (m_lastOpcodeID == op_nstricteq) {</span>
<span class="line-modified">1462             if (fuseCompareAndJump&lt;OpNstricteq, OpJnstricteq&gt;(cond, target))</span>
<span class="line-modified">1463                 return;</span>
<span class="line-modified">1464         } else if (m_lastOpcodeID == op_below) {</span>
<span class="line-modified">1465             if (fuseCompareAndJump&lt;OpBelow, OpJbelow&gt;(cond, target))</span>
<span class="line-modified">1466                 return;</span>
<span class="line-modified">1467         } else if (m_lastOpcodeID == op_beloweq) {</span>
<span class="line-modified">1468             if (fuseCompareAndJump&lt;OpBeloweq, OpJbeloweq&gt;(cond, target))</span>
<span class="line-modified">1469                 return;</span>
<span class="line-modified">1470         } else if (m_lastOpcodeID == op_eq_null &amp;&amp; target.isForward()) {</span>
<span class="line-modified">1471             if (fuseTestAndJmp&lt;OpEqNull, OpJeqNull&gt;(cond, target))</span>
<span class="line-modified">1472                 return;</span>
<span class="line-modified">1473         } else if (m_lastOpcodeID == op_neq_null &amp;&amp; target.isForward()) {</span>
<span class="line-modified">1474             if (fuseTestAndJmp&lt;OpNeqNull, OpJneqNull&gt;(cond, target))</span>
<span class="line-modified">1475                 return;</span>
<span class="line-added">1476         } else if (m_lastOpcodeID == op_is_undefined_or_null &amp;&amp; target.isForward()) {</span>
<span class="line-added">1477             if (fuseTestAndJmp&lt;OpIsUndefinedOrNull, OpJundefinedOrNull&gt;(cond, target))</span>
<span class="line-added">1478                 return;</span>
<span class="line-added">1479         }</span>
1480     }
1481 
1482     OpJtrue::emit(this, cond, target.bind(this));
1483 }
1484 
1485 void BytecodeGenerator::emitJumpIfFalse(RegisterID* cond, Label&amp; target)
1486 {
<span class="line-modified">1487     if (canDoPeepholeOptimization()) {</span>
<span class="line-modified">1488         if (m_lastOpcodeID == op_less &amp;&amp; target.isForward()) {</span>
<span class="line-modified">1489             if (fuseCompareAndJump&lt;OpLess, OpJnless&gt;(cond, target))</span>
<span class="line-modified">1490                 return;</span>
<span class="line-modified">1491         } else if (m_lastOpcodeID == op_lesseq &amp;&amp; target.isForward()) {</span>
<span class="line-modified">1492             if (fuseCompareAndJump&lt;OpLesseq, OpJnlesseq&gt;(cond, target))</span>
<span class="line-modified">1493                 return;</span>
<span class="line-modified">1494         } else if (m_lastOpcodeID == op_greater &amp;&amp; target.isForward()) {</span>
<span class="line-modified">1495             if (fuseCompareAndJump&lt;OpGreater, OpJngreater&gt;(cond, target))</span>
<span class="line-modified">1496                 return;</span>
<span class="line-modified">1497         } else if (m_lastOpcodeID == op_greatereq &amp;&amp; target.isForward()) {</span>
<span class="line-modified">1498             if (fuseCompareAndJump&lt;OpGreatereq, OpJngreatereq&gt;(cond, target))</span>
<span class="line-modified">1499                 return;</span>
<span class="line-modified">1500         } else if (m_lastOpcodeID == op_eq &amp;&amp; target.isForward()) {</span>
<span class="line-modified">1501             if (fuseCompareAndJump&lt;OpEq, OpJneq&gt;(cond, target))</span>
<span class="line-modified">1502                 return;</span>
<span class="line-modified">1503         } else if (m_lastOpcodeID == op_stricteq &amp;&amp; target.isForward()) {</span>
<span class="line-modified">1504             if (fuseCompareAndJump&lt;OpStricteq, OpJnstricteq&gt;(cond, target))</span>
<span class="line-modified">1505                 return;</span>
<span class="line-modified">1506         } else if (m_lastOpcodeID == op_neq &amp;&amp; target.isForward()) {</span>
<span class="line-modified">1507             if (fuseCompareAndJump&lt;OpNeq, OpJeq&gt;(cond, target))</span>
<span class="line-modified">1508                 return;</span>
<span class="line-modified">1509         } else if (m_lastOpcodeID == op_nstricteq &amp;&amp; target.isForward()) {</span>
<span class="line-modified">1510             if (fuseCompareAndJump&lt;OpNstricteq, OpJstricteq&gt;(cond, target))</span>
<span class="line-modified">1511                 return;</span>
<span class="line-modified">1512         } else if (m_lastOpcodeID == op_below &amp;&amp; target.isForward()) {</span>
<span class="line-modified">1513             if (fuseCompareAndJump&lt;OpBelow, OpJbeloweq&gt;(cond, target, true))</span>
<span class="line-modified">1514                 return;</span>
<span class="line-modified">1515         } else if (m_lastOpcodeID == op_beloweq &amp;&amp; target.isForward()) {</span>
<span class="line-modified">1516             if (fuseCompareAndJump&lt;OpBeloweq, OpJbelow&gt;(cond, target, true))</span>
<span class="line-modified">1517                 return;</span>
<span class="line-modified">1518         } else if (m_lastOpcodeID == op_not) {</span>
<span class="line-modified">1519             if (fuseTestAndJmp&lt;OpNot, OpJtrue&gt;(cond, target))</span>
<span class="line-modified">1520                 return;</span>
<span class="line-modified">1521         } else if (m_lastOpcodeID == op_eq_null &amp;&amp; target.isForward()) {</span>
<span class="line-modified">1522             if (fuseTestAndJmp&lt;OpEqNull, OpJneqNull&gt;(cond, target))</span>
<span class="line-modified">1523                 return;</span>
<span class="line-modified">1524         } else if (m_lastOpcodeID == op_neq_null &amp;&amp; target.isForward()) {</span>
<span class="line-modified">1525             if (fuseTestAndJmp&lt;OpNeqNull, OpJeqNull&gt;(cond, target))</span>
<span class="line-added">1526                 return;</span>
<span class="line-added">1527         } else if (m_lastOpcodeID == op_is_undefined_or_null &amp;&amp; target.isForward()) {</span>
<span class="line-added">1528             if (fuseTestAndJmp&lt;OpIsUndefinedOrNull, OpJnundefinedOrNull&gt;(cond, target))</span>
<span class="line-added">1529                 return;</span>
<span class="line-added">1530         }</span>
1531     }
1532 
1533     OpJfalse::emit(this, cond, target.bind(this));
1534 }
1535 
1536 void BytecodeGenerator::emitJumpIfNotFunctionCall(RegisterID* cond, Label&amp; target)
1537 {
1538     OpJneqPtr::emit(this, cond, Special::CallFunction, target.bind(this));
1539 }
1540 
1541 void BytecodeGenerator::emitJumpIfNotFunctionApply(RegisterID* cond, Label&amp; target)
1542 {
1543     OpJneqPtr::emit(this, cond, Special::ApplyFunction, target.bind(this));
1544 }
1545 
1546 bool BytecodeGenerator::hasConstant(const Identifier&amp; ident) const
1547 {
1548     UniquedStringImpl* rep = ident.impl();
1549     return m_identifierMap.contains(rep);
1550 }
</pre>
<hr />
<pre>
1716     return emitUnaryOp&lt;OpToString&gt;(dst, src);
1717 }
1718 
1719 RegisterID* BytecodeGenerator::emitTypeOf(RegisterID* dst, RegisterID* src)
1720 {
1721     return emitUnaryOp&lt;OpTypeof&gt;(dst, src);
1722 }
1723 
1724 RegisterID* BytecodeGenerator::emitInc(RegisterID* srcDst)
1725 {
1726     OpInc::emit(this, srcDst);
1727     return srcDst;
1728 }
1729 
1730 RegisterID* BytecodeGenerator::emitDec(RegisterID* srcDst)
1731 {
1732     OpDec::emit(this, srcDst);
1733     return srcDst;
1734 }
1735 
<span class="line-modified">1736 bool BytecodeGenerator::emitEqualityOpImpl(RegisterID* dst, RegisterID* src1, RegisterID* src2)</span>

1737 {
<span class="line-added">1738     if (!canDoPeepholeOptimization())</span>
<span class="line-added">1739         return false;</span>
<span class="line-added">1740 </span>
1741     if (m_lastInstruction-&gt;is&lt;OpTypeof&gt;()) {
1742         auto op = m_lastInstruction-&gt;as&lt;OpTypeof&gt;();
1743         if (src1-&gt;index() == op.m_dst.offset()
1744             &amp;&amp; src1-&gt;isTemporary()
1745             &amp;&amp; m_codeBlock-&gt;isConstantRegisterIndex(src2-&gt;index())
1746             &amp;&amp; m_codeBlock-&gt;constantRegister(src2-&gt;index()).get().isString()) {
1747             const String&amp; value = asString(m_codeBlock-&gt;constantRegister(src2-&gt;index()).get())-&gt;tryGetValue();
1748             if (value == &quot;undefined&quot;) {
1749                 rewind();
1750                 OpIsUndefined::emit(this, dst, op.m_value);
<span class="line-modified">1751                 return true;</span>
1752             }
1753             if (value == &quot;boolean&quot;) {
1754                 rewind();
1755                 OpIsBoolean::emit(this, dst, op.m_value);
<span class="line-modified">1756                 return true;</span>
1757             }
1758             if (value == &quot;number&quot;) {
1759                 rewind();
1760                 OpIsNumber::emit(this, dst, op.m_value);
<span class="line-modified">1761                 return true;</span>
1762             }
1763             if (value == &quot;string&quot;) {
1764                 rewind();
1765                 OpIsCellWithType::emit(this, dst, op.m_value, StringType);
<span class="line-modified">1766                 return true;</span>
1767             }
1768             if (value == &quot;symbol&quot;) {
1769                 rewind();
1770                 OpIsCellWithType::emit(this, dst, op.m_value, SymbolType);
<span class="line-modified">1771                 return true;</span>
1772             }
1773             if (Options::useBigInt() &amp;&amp; value == &quot;bigint&quot;) {
1774                 rewind();
1775                 OpIsCellWithType::emit(this, dst, op.m_value, BigIntType);
<span class="line-modified">1776                 return true;</span>
1777             }
1778             if (value == &quot;object&quot;) {
1779                 rewind();
1780                 OpIsObjectOrNull::emit(this, dst, op.m_value);
<span class="line-modified">1781                 return true;</span>
1782             }
1783             if (value == &quot;function&quot;) {
1784                 rewind();
1785                 OpIsFunction::emit(this, dst, op.m_value);
<span class="line-modified">1786                 return true;</span>
1787             }
1788         }
1789     }
1790 
<span class="line-modified">1791     return false;</span>

1792 }
1793 
1794 void BytecodeGenerator::emitTypeProfilerExpressionInfo(const JSTextPosition&amp; startDivot, const JSTextPosition&amp; endDivot)
1795 {
<span class="line-modified">1796     ASSERT(shouldEmitTypeProfilerHooks());</span>
1797 
1798     unsigned start = startDivot.offset; // Ranges are inclusive of their endpoints, AND 0 indexed.
1799     unsigned end = endDivot.offset - 1; // End Ranges already go one past the inclusive range, so subtract 1.
1800     unsigned instructionOffset = instructions().size() - 1;
1801     m_codeBlock-&gt;addTypeProfilerExpressionInfo(instructionOffset, start, end);
1802 }
1803 
1804 void BytecodeGenerator::emitProfileType(RegisterID* registerToProfile, ProfileTypeBytecodeFlag flag)
1805 {
<span class="line-modified">1806     if (!shouldEmitTypeProfilerHooks())</span>
1807         return;
1808 
1809     if (!registerToProfile)
1810         return;
1811 
<span class="line-modified">1812     OpProfileType::emit(this, registerToProfile, { }, flag, { }, resolveType());</span>
1813 
1814     // Don&#39;t emit expression info for this version of profile type. This generally means
1815     // we&#39;re profiling information for something that isn&#39;t in the actual text of a JavaScript
1816     // program. For example, implicit return undefined from a function call.
1817 }
1818 
1819 void BytecodeGenerator::emitProfileType(RegisterID* registerToProfile, const JSTextPosition&amp; startDivot, const JSTextPosition&amp; endDivot)
1820 {
1821     emitProfileType(registerToProfile, ProfileTypeBytecodeDoesNotHaveGlobalID, startDivot, endDivot);
1822 }
1823 
1824 void BytecodeGenerator::emitProfileType(RegisterID* registerToProfile, ProfileTypeBytecodeFlag flag, const JSTextPosition&amp; startDivot, const JSTextPosition&amp; endDivot)
1825 {
<span class="line-modified">1826     if (!shouldEmitTypeProfilerHooks())</span>
1827         return;
1828 
1829     if (!registerToProfile)
1830         return;
1831 
<span class="line-modified">1832     OpProfileType::emit(this, registerToProfile, { },  flag, { }, resolveType());</span>
1833     emitTypeProfilerExpressionInfo(startDivot, endDivot);
1834 }
1835 
1836 void BytecodeGenerator::emitProfileType(RegisterID* registerToProfile, const Variable&amp; var, const JSTextPosition&amp; startDivot, const JSTextPosition&amp; endDivot)
1837 {
<span class="line-modified">1838     if (!shouldEmitTypeProfilerHooks())</span>
1839         return;
1840 
1841     if (!registerToProfile)
1842         return;
1843 
1844     ProfileTypeBytecodeFlag flag;
<span class="line-modified">1845     SymbolTableOrScopeDepth symbolTableOrScopeDepth;</span>
1846     if (var.local() || var.offset().isScope()) {
1847         flag = ProfileTypeBytecodeLocallyResolved;
1848         ASSERT(var.symbolTableConstantIndex());
<span class="line-modified">1849         symbolTableOrScopeDepth = SymbolTableOrScopeDepth::symbolTable(VirtualRegister { var.symbolTableConstantIndex() });</span>
1850     } else {
1851         flag = ProfileTypeBytecodeClosureVar;
<span class="line-modified">1852         symbolTableOrScopeDepth = SymbolTableOrScopeDepth::scopeDepth(localScopeDepth());</span>
1853     }
1854 
1855     OpProfileType::emit(this, registerToProfile, symbolTableOrScopeDepth, flag, addConstant(var.ident()), resolveType());
1856     emitTypeProfilerExpressionInfo(startDivot, endDivot);
1857 }
1858 
1859 void BytecodeGenerator::emitProfileControlFlow(int textOffset)
1860 {
<span class="line-modified">1861     if (shouldEmitControlFlowProfilerHooks()) {</span>
1862         RELEASE_ASSERT(textOffset &gt;= 0);
1863 
1864         OpProfileControlFlow::emit(this, textOffset);
1865         m_codeBlock-&gt;addOpProfileControlFlowBytecodeOffset(m_lastInstruction.offset());
1866     }
1867 }
1868 
1869 unsigned BytecodeGenerator::addConstantIndex()
1870 {
1871     unsigned index = m_nextConstantOffset;
1872     m_constantPoolRegisters.append(FirstConstantRegisterIndex + m_nextConstantOffset);
1873     ++m_nextConstantOffset;
1874     return index;
1875 }
1876 
1877 RegisterID* BytecodeGenerator::emitLoad(RegisterID* dst, bool b)
1878 {
1879     return emitLoad(dst, jsBoolean(b));
1880 }
1881 
</pre>
<hr />
<pre>
1987 
1988 void BytecodeGenerator::pushLexicalScope(VariableEnvironmentNode* node, TDZCheckOptimization tdzCheckOptimization, NestedScopeType nestedScopeType, RegisterID** constantSymbolTableResult, bool shouldInitializeBlockScopedFunctions)
1989 {
1990     VariableEnvironment&amp; environment = node-&gt;lexicalVariables();
1991     RegisterID* constantSymbolTableResultTemp = nullptr;
1992     pushLexicalScopeInternal(environment, tdzCheckOptimization, nestedScopeType, &amp;constantSymbolTableResultTemp, TDZRequirement::UnderTDZ, ScopeType::LetConstScope, ScopeRegisterType::Block);
1993 
1994     if (shouldInitializeBlockScopedFunctions)
1995         initializeBlockScopedFunctions(environment, node-&gt;functionStack(), constantSymbolTableResultTemp);
1996 
1997     if (constantSymbolTableResult &amp;&amp; constantSymbolTableResultTemp)
1998         *constantSymbolTableResult = constantSymbolTableResultTemp;
1999 }
2000 
2001 void BytecodeGenerator::pushLexicalScopeInternal(VariableEnvironment&amp; environment, TDZCheckOptimization tdzCheckOptimization, NestedScopeType nestedScopeType,
2002     RegisterID** constantSymbolTableResult, TDZRequirement tdzRequirement, ScopeType scopeType, ScopeRegisterType scopeRegisterType)
2003 {
2004     if (!environment.size())
2005         return;
2006 
<span class="line-modified">2007     if (shouldEmitDebugHooks())</span>
2008         environment.markAllVariablesAsCaptured();
2009 
<span class="line-modified">2010     SymbolTable* symbolTable = SymbolTable::create(m_vm);</span>
2011     switch (scopeType) {
2012     case ScopeType::CatchScope:
2013         symbolTable-&gt;setScopeType(SymbolTable::ScopeType::CatchScope);
2014         break;
2015     case ScopeType::LetConstScope:
2016         symbolTable-&gt;setScopeType(SymbolTable::ScopeType::LexicalScope);
2017         break;
2018     case ScopeType::FunctionNameScope:
2019         symbolTable-&gt;setScopeType(SymbolTable::ScopeType::FunctionNameScope);
2020         break;
2021     }
2022 
2023     if (nestedScopeType == NestedScopeType::IsNested)
2024         symbolTable-&gt;markIsNestedLexicalScope();
2025 
2026     auto lookUpVarKind = [] (UniquedStringImpl*, const VariableEnvironmentEntry&amp; entry) -&gt; VarKind {
2027         return entry.isCaptured() ? VarKind::Scope : VarKind::Stack;
2028     };
2029 
2030     bool hasCapturedVariables = instantiateLexicalVariables(environment, symbolTable, scopeRegisterType, lookUpVarKind);
2031 
2032     RegisterID* newScope = nullptr;
2033     RegisterID* constantSymbolTable = nullptr;
2034     int symbolTableConstantIndex = 0;
<span class="line-modified">2035     if (shouldEmitTypeProfilerHooks()) {</span>
2036         constantSymbolTable = addConstantValue(symbolTable);
2037         symbolTableConstantIndex = constantSymbolTable-&gt;index();
2038     }
2039     if (hasCapturedVariables) {
2040         if (scopeRegisterType == ScopeRegisterType::Block) {
2041             newScope = newBlockScopeVariable();
2042             newScope-&gt;ref();
2043         } else
2044             newScope = addVar();
2045         if (!constantSymbolTable) {
<span class="line-modified">2046             ASSERT(!shouldEmitTypeProfilerHooks());</span>
<span class="line-modified">2047             constantSymbolTable = addConstantValue(symbolTable-&gt;cloneScopePart(m_vm));</span>
2048             symbolTableConstantIndex = constantSymbolTable-&gt;index();
2049         }
2050         if (constantSymbolTableResult)
2051             *constantSymbolTableResult = constantSymbolTable;
2052 
2053         OpCreateLexicalEnvironment::emit(this, newScope, scopeRegister(), VirtualRegister { symbolTableConstantIndex }, addConstantValue(tdzRequirement == TDZRequirement::UnderTDZ ? jsTDZValue() : jsUndefined()));
2054 
2055         move(scopeRegister(), newScope);
2056 
2057         pushLocalControlFlowScope();
2058     }
2059 
2060     bool isWithScope = false;
2061     m_lexicalScopeStack.append({ symbolTable, newScope, isWithScope, symbolTableConstantIndex });
2062     pushTDZVariables(environment, tdzCheckOptimization, tdzRequirement);
2063 
2064     if (tdzRequirement == TDZRequirement::UnderTDZ)
2065         emitPrefillStackTDZVariables(environment, symbolTable);
2066 }
2067 
</pre>
<hr />
<pre>
2181     ASSERT(m_codeType == EvalCode);
2182 
2183     dst = finalDestination(dst);
2184     OpResolveScopeForHoistingFuncDeclInEval::emit(this, kill(dst), m_topMostScope, addConstant(property));
2185     return dst;
2186 }
2187 
2188 void BytecodeGenerator::popLexicalScope(VariableEnvironmentNode* node)
2189 {
2190     VariableEnvironment&amp; environment = node-&gt;lexicalVariables();
2191     popLexicalScopeInternal(environment);
2192 }
2193 
2194 void BytecodeGenerator::popLexicalScopeInternal(VariableEnvironment&amp; environment)
2195 {
2196     // NOTE: This function only makes sense for scopes that aren&#39;t ScopeRegisterType::Var (only function name scope right now is ScopeRegisterType::Var).
2197     // This doesn&#39;t make sense for ScopeRegisterType::Var because we deref RegisterIDs here.
2198     if (!environment.size())
2199         return;
2200 
<span class="line-modified">2201     if (shouldEmitDebugHooks())</span>
2202         environment.markAllVariablesAsCaptured();
2203 
2204     auto stackEntry = m_lexicalScopeStack.takeLast();
2205     SymbolTable* symbolTable = stackEntry.m_symbolTable;
2206     bool hasCapturedVariables = false;
2207     for (auto&amp; entry : environment) {
2208         if (entry.value.isCaptured()) {
2209             hasCapturedVariables = true;
2210             continue;
2211         }
2212         SymbolTableEntry symbolTableEntry = symbolTable-&gt;get(NoLockingNecessary, entry.key.get());
2213         ASSERT(!symbolTableEntry.isNull());
2214         VarOffset offset = symbolTableEntry.varOffset();
2215         ASSERT(offset.isStack());
2216         RegisterID* local = &amp;registerFor(offset.stackOffset());
2217         local-&gt;deref();
2218     }
2219 
2220     if (hasCapturedVariables) {
2221         RELEASE_ASSERT(stackEntry.m_scope);
2222         emitPopScope(scopeRegister(), stackEntry.m_scope);
2223         popLocalControlFlowScope();
2224         stackEntry.m_scope-&gt;deref();
2225     }
2226 
2227     m_TDZStack.removeLast();
2228     m_cachedVariablesUnderTDZ = { };
2229 }
2230 
2231 void BytecodeGenerator::prepareLexicalScopeForNextForLoopIteration(VariableEnvironmentNode* node, RegisterID* loopSymbolTable)
2232 {
2233     VariableEnvironment&amp; environment = node-&gt;lexicalVariables();
2234     if (!environment.size())
2235         return;
<span class="line-modified">2236     if (shouldEmitDebugHooks())</span>
2237         environment.markAllVariablesAsCaptured();
2238     if (!environment.hasCapturedVariables())
2239         return;
2240 
2241     RELEASE_ASSERT(loopSymbolTable);
2242 
2243     // This function needs to do setup for a for loop&#39;s activation if any of
2244     // the for loop&#39;s lexically declared variables are captured (that is, variables
2245     // declared in the loop header, not the loop body). This function needs to
2246     // make a copy of the current activation and copy the values from the previous
2247     // activation into the new activation because each iteration of a for loop
2248     // gets a new activation.
2249 
2250     auto stackEntry = m_lexicalScopeStack.last();
2251     SymbolTable* symbolTable = stackEntry.m_symbolTable;
2252     RegisterID* loopScope = stackEntry.m_scope;
2253     ASSERT(symbolTable-&gt;scopeSize());
2254     ASSERT(loopScope);
2255     Vector&lt;std::pair&lt;RegisterID*, Identifier&gt;&gt; activationValuesToCopyOver;
2256 
</pre>
<hr />
<pre>
2501         return dst;
2502     } }
2503 
2504     RELEASE_ASSERT_NOT_REACHED();
2505 }
2506 
2507 RegisterID* BytecodeGenerator::emitPutToScope(RegisterID* scope, const Variable&amp; variable, RegisterID* value, ResolveMode resolveMode, InitializationMode initializationMode)
2508 {
2509     switch (variable.offset().kind()) {
2510     case VarKind::Stack:
2511         move(variable.local(), value);
2512         return value;
2513 
2514     case VarKind::DirectArgument:
2515         OpPutToArguments::emit(this, scope, variable.offset().capturedArgumentsOffset().offset(), value);
2516         return value;
2517 
2518     case VarKind::Scope:
2519     case VarKind::Invalid: {
2520         GetPutInfo getPutInfo(0);
<span class="line-modified">2521         SymbolTableOrScopeDepth symbolTableOrScopeDepth;</span>
2522         ScopeOffset offset;
2523         if (variable.offset().isScope()) {
2524             offset = variable.offset().scopeOffset();
2525             getPutInfo = GetPutInfo(resolveMode, LocalClosureVar, initializationMode);
<span class="line-modified">2526             symbolTableOrScopeDepth = SymbolTableOrScopeDepth::symbolTable(VirtualRegister { variable.symbolTableConstantIndex() });</span>
2527         } else {
2528             ASSERT(resolveType() != LocalClosureVar);
2529             getPutInfo = GetPutInfo(resolveMode, resolveType(), initializationMode);
<span class="line-modified">2530             symbolTableOrScopeDepth = SymbolTableOrScopeDepth::scopeDepth(localScopeDepth());</span>
2531         }
<span class="line-modified">2532         OpPutToScope::emit(this, scope, addConstant(variable.ident()), value, getPutInfo, symbolTableOrScopeDepth, !!offset ? offset.offset() : 0);</span>
2533         m_codeBlock-&gt;addPropertyAccessInstruction(m_lastInstruction.offset());
2534         return value;
2535     } }
2536 
2537     RELEASE_ASSERT_NOT_REACHED();
2538 }
2539 
2540 RegisterID* BytecodeGenerator::initializeVariable(const Variable&amp; variable, RegisterID* value)
2541 {
2542     RELEASE_ASSERT(variable.offset().kind() != VarKind::Invalid);
2543     RegisterID* scope = emitResolveScope(nullptr, variable);
2544     return emitPutToScope(scope, variable, value, ThrowIfNotFound, InitializationMode::NotInitialization);
2545 }
2546 
2547 RegisterID* BytecodeGenerator::emitInstanceOf(RegisterID* dst, RegisterID* value, RegisterID* basePrototype)
2548 {
2549     OpInstanceof::emit(this, dst, value, basePrototype);
2550     return dst;
2551 }
2552 
</pre>
<hr />
<pre>
2618 
2619 RegisterID* BytecodeGenerator::emitPutById(RegisterID* base, RegisterID* thisValue, const Identifier&amp; property, RegisterID* value)
2620 {
2621     ASSERT_WITH_MESSAGE(!parseIndex(property), &quot;Indexed properties should be handled with put_by_val.&quot;);
2622 
2623     unsigned propertyIndex = addConstant(property);
2624 
2625     OpPutByIdWithThis::emit(this, base, thisValue, propertyIndex, value);
2626 
2627     return value;
2628 }
2629 
2630 RegisterID* BytecodeGenerator::emitDirectPutById(RegisterID* base, const Identifier&amp; property, RegisterID* value, PropertyNode::PutType putType)
2631 {
2632     ASSERT_WITH_MESSAGE(!parseIndex(property), &quot;Indexed properties should be handled with put_by_val(direct).&quot;);
2633 
2634     unsigned propertyIndex = addConstant(property);
2635 
2636     m_staticPropertyAnalyzer.putById(base, propertyIndex);
2637 
<span class="line-modified">2638     PutByIdFlags type = (putType == PropertyNode::KnownDirect || property != m_vm.propertyNames-&gt;underscoreProto) ? PutByIdIsDirect : PutByIdNone;</span>
2639     OpPutById::emit(this, base, propertyIndex, value, type);
2640     m_codeBlock-&gt;addPropertyAccessInstruction(m_lastInstruction.offset());
2641     return value;
2642 }
2643 
2644 void BytecodeGenerator::emitPutGetterById(RegisterID* base, const Identifier&amp; property, unsigned attributes, RegisterID* getter)
2645 {
2646     unsigned propertyIndex = addConstant(property);
2647     m_staticPropertyAnalyzer.putById(base, propertyIndex);
2648 
2649     OpPutGetterById::emit(this, base, propertyIndex, attributes, getter);
2650 }
2651 
2652 void BytecodeGenerator::emitPutSetterById(RegisterID* base, const Identifier&amp; property, unsigned attributes, RegisterID* setter)
2653 {
2654     unsigned propertyIndex = addConstant(property);
2655     m_staticPropertyAnalyzer.putById(base, propertyIndex);
2656 
2657     OpPutSetterById::emit(this, base, propertyIndex, attributes, setter);
2658 }
</pre>
<hr />
<pre>
2710 
2711     emitDirectPutById(m_generatorRegister, propertyNames().builtinNames().asyncGeneratorQueueFirstPrivateName(), emitLoad(nullptr, jsNull()), PropertyNode::KnownDirect);
2712     emitDirectPutById(m_generatorRegister, propertyNames().builtinNames().asyncGeneratorQueueLastPrivateName(), emitLoad(nullptr, jsNull()), PropertyNode::KnownDirect);
2713 }
2714 
2715 RegisterID* BytecodeGenerator::emitDeleteById(RegisterID* dst, RegisterID* base, const Identifier&amp; property)
2716 {
2717     OpDelById::emit(this, dst, base, addConstant(property));
2718     return dst;
2719 }
2720 
2721 RegisterID* BytecodeGenerator::emitGetByVal(RegisterID* dst, RegisterID* base, RegisterID* property)
2722 {
2723     for (size_t i = m_forInContextStack.size(); i--; ) {
2724         ForInContext&amp; context = m_forInContextStack[i].get();
2725         if (context.local() != property)
2726             continue;
2727 
2728         if (context.isIndexedForInContext()) {
2729             auto&amp; indexedContext = context.asIndexedForInContext();
<span class="line-modified">2730             kill(dst);</span>
<span class="line-added">2731             if (OpGetByVal::checkWithoutMetadataID&lt;OpcodeSize::Narrow&gt;(this, dst, base, property))</span>
<span class="line-added">2732                 OpGetByVal::emitWithSmallestSizeRequirement&lt;OpcodeSize::Narrow&gt;(this, dst, base, indexedContext.index());</span>
<span class="line-added">2733             else if (OpGetByVal::checkWithoutMetadataID&lt;OpcodeSize::Wide16&gt;(this, dst, base, property))</span>
<span class="line-added">2734                 OpGetByVal::emitWithSmallestSizeRequirement&lt;OpcodeSize::Wide16&gt;(this, dst, base, indexedContext.index());</span>
<span class="line-added">2735             else</span>
<span class="line-added">2736                 OpGetByVal::emit&lt;OpcodeSize::Wide32&gt;(this, dst, base, indexedContext.index());</span>
2737             indexedContext.addGetInst(m_lastInstruction.offset(), property-&gt;index());
2738             return dst;
2739         }
2740 
<span class="line-added">2741         // We cannot do the above optimization here since OpGetDirectPname =&gt; OpGetByVal conversion involves different metadata ID allocation.</span>
2742         StructureForInContext&amp; structureContext = context.asStructureForInContext();
<span class="line-modified">2743         OpGetDirectPname::emit&lt;OpcodeSize::Wide32&gt;(this, kill(dst), base, property, structureContext.index(), structureContext.enumerator());</span>
2744 
2745         structureContext.addGetInst(m_lastInstruction.offset(), property-&gt;index());
2746         return dst;
2747     }
2748 
2749     OpGetByVal::emit(this, kill(dst), base, property);
2750     return dst;
2751 }
2752 
2753 RegisterID* BytecodeGenerator::emitGetByVal(RegisterID* dst, RegisterID* base, RegisterID* thisValue, RegisterID* property)
2754 {
2755     OpGetByValWithThis::emit(this, kill(dst), base, thisValue, property);
2756     return dst;
2757 }
2758 
2759 RegisterID* BytecodeGenerator::emitPutByVal(RegisterID* base, RegisterID* property, RegisterID* value)
2760 {
2761     OpPutByVal::emit(this, base, property, value);
2762     return value;
2763 }
</pre>
<hr />
<pre>
2866     if (!environment.size())
2867         return;
2868 
2869     TDZNecessityLevel level;
2870     if (requirement == TDZRequirement::UnderTDZ) {
2871         if (optimization == TDZCheckOptimization::Optimize)
2872             level = TDZNecessityLevel::Optimize;
2873         else
2874             level = TDZNecessityLevel::DoNotOptimize;
2875     } else
2876         level = TDZNecessityLevel::NotNeeded;
2877 
2878     TDZMap map;
2879     for (const auto&amp; entry : environment)
2880         map.add(entry.key, entry.value.isFunction() ? TDZNecessityLevel::NotNeeded : level);
2881 
2882     m_TDZStack.append(WTFMove(map));
2883     m_cachedVariablesUnderTDZ = { };
2884 }
2885 
<span class="line-modified">2886 Optional&lt;CompactVariableMap::Handle&gt; BytecodeGenerator::getVariablesUnderTDZ()</span>
2887 {
<span class="line-modified">2888     if (m_cachedVariablesUnderTDZ) {</span>
<span class="line-added">2889         if (!m_hasCachedVariablesUnderTDZ) {</span>
<span class="line-added">2890             ASSERT(m_cachedVariablesUnderTDZ.environment().toVariableEnvironment().isEmpty());</span>
<span class="line-added">2891             return WTF::nullopt;</span>
<span class="line-added">2892         }</span>
2893         return m_cachedVariablesUnderTDZ;
<span class="line-added">2894     }</span>
2895 
2896     // We keep track of variablesThatDontNeedTDZ in this algorithm to prevent
2897     // reporting that &quot;x&quot; is under TDZ if this function is called at &quot;...&quot;.
2898     //
2899     //     {
2900     //         {
2901     //             let x;
2902     //             ...
2903     //         }
2904     //         let x;
2905     //     }
2906     SmallPtrSet&lt;UniquedStringImpl*, 16&gt; variablesThatDontNeedTDZ;
2907     VariableEnvironment environment;
2908     for (unsigned i = m_TDZStack.size(); i--; ) {
2909         auto&amp; map = m_TDZStack[i];
2910         for (auto&amp; entry : map)  {
2911             if (entry.value != TDZNecessityLevel::NotNeeded) {
2912                 if (!variablesThatDontNeedTDZ.contains(entry.key.get()))
2913                     environment.add(entry.key.get());
2914             } else
2915                 variablesThatDontNeedTDZ.add(entry.key.get());
2916         }
2917     }
2918 
<span class="line-modified">2919     m_cachedVariablesUnderTDZ = m_vm.m_compactVariableMap-&gt;get(environment);</span>
<span class="line-added">2920     m_hasCachedVariablesUnderTDZ = !environment.isEmpty();</span>
<span class="line-added">2921     if (!m_hasCachedVariablesUnderTDZ)</span>
<span class="line-added">2922         return WTF::nullopt;</span>
<span class="line-added">2923 </span>
2924     return m_cachedVariablesUnderTDZ;
2925 }
2926 
2927 void BytecodeGenerator::preserveTDZStack(BytecodeGenerator::PreservedTDZStack&amp; preservedStack)
2928 {
2929     preservedStack.m_preservedTDZStack = m_TDZStack;
2930 }
2931 
2932 void BytecodeGenerator::restoreTDZStack(const BytecodeGenerator::PreservedTDZStack&amp; preservedStack)
2933 {
2934     m_TDZStack = preservedStack.m_preservedTDZStack;
2935     m_cachedVariablesUnderTDZ = { };
2936 }
2937 
2938 RegisterID* BytecodeGenerator::emitNewObject(RegisterID* dst)
2939 {
2940     OpNewObject::emit(this, dst, 0);
2941     m_staticPropertyAnalyzer.newObject(dst, m_lastInstruction);
2942 
2943     return dst;
2944 }
2945 
2946 JSValue BytecodeGenerator::addBigIntConstant(const Identifier&amp; identifier, uint8_t radix, bool sign)
2947 {
2948     return m_bigIntMap.ensure(BigIntMapEntry(identifier.impl(), radix, sign), [&amp;] {
<span class="line-modified">2949         auto scope = DECLARE_CATCH_SCOPE(vm());</span>
2950         auto parseIntSign = sign ? JSBigInt::ParseIntSign::Signed : JSBigInt::ParseIntSign::Unsigned;
<span class="line-modified">2951         JSBigInt* bigIntInMap = JSBigInt::parseInt(nullptr, vm(), identifier.string(), radix, JSBigInt::ErrorParseMode::ThrowExceptions, parseIntSign);</span>
2952         // FIXME: [ESNext] Enables a way to throw an error on ByteCodeGenerator step
2953         // https://bugs.webkit.org/show_bug.cgi?id=180139
2954         scope.assertNoException();
2955         RELEASE_ASSERT(bigIntInMap);
2956         addConstantValue(bigIntInMap);
2957 
2958         return bigIntInMap;
2959     }).iterator-&gt;value;
2960 }
2961 
2962 JSString* BytecodeGenerator::addStringConstant(const Identifier&amp; identifier)
2963 {
2964     JSString*&amp; stringInMap = m_stringMap.add(identifier.impl(), nullptr).iterator-&gt;value;
2965     if (!stringInMap) {
2966         stringInMap = jsString(vm(), identifier.string());
2967         addConstantValue(stringInMap);
2968     }
2969     return stringInMap;
2970 }
2971 
<span class="line-modified">2972 RegisterID* BytecodeGenerator::addTemplateObjectConstant(Ref&lt;TemplateObjectDescriptor&gt;&amp;&amp; descriptor, int endOffset)</span>
2973 {
<span class="line-modified">2974     auto result = m_templateObjectDescriptorSet.add(WTFMove(descriptor));</span>
<span class="line-modified">2975     JSTemplateObjectDescriptor* descriptorValue = m_templateDescriptorMap.ensure(endOffset, [&amp;] {</span>
<span class="line-added">2976         return JSTemplateObjectDescriptor::create(vm(), result.iterator-&gt;copyRef(), endOffset);</span>
2977     }).iterator-&gt;value;

2978     int index = addConstantIndex();
2979     m_codeBlock-&gt;addConstant(descriptorValue);
2980     return &amp;m_constantPoolRegisters[index];
2981 }
2982 
2983 RegisterID* BytecodeGenerator::emitNewArrayBuffer(RegisterID* dst, JSImmutableButterfly* array, IndexingType recommendedIndexingType)
2984 {
2985     OpNewArrayBuffer::emit(this, dst, addConstantValue(array), recommendedIndexingType);
2986     return dst;
2987 }
2988 
2989 RegisterID* BytecodeGenerator::emitNewArray(RegisterID* dst, ElementNode* elements, unsigned length, IndexingType recommendedIndexingType)
2990 {
2991     Vector&lt;RefPtr&lt;RegisterID&gt;, 16, UnsafeVectorOverflow&gt; argv;
2992     for (ElementNode* n = elements; n; n = n-&gt;next()) {
2993         if (!length)
2994             break;
2995         length--;
2996         ASSERT(!n-&gt;value()-&gt;isSpreadExpression());
2997         argv.append(newTemporary());
</pre>
<hr />
<pre>
3082     return dst;
3083 }
3084 
3085 RegisterID* BytecodeGenerator::emitNewArrowFunctionExpression(RegisterID* dst, ArrowFuncExprNode* func)
3086 {
3087     ASSERT(SourceParseModeSet(SourceParseMode::ArrowFunctionMode, SourceParseMode::AsyncArrowFunctionMode).contains(func-&gt;metadata()-&gt;parseMode()));
3088     emitNewFunctionExpressionCommon(dst, func-&gt;metadata());
3089     return dst;
3090 }
3091 
3092 RegisterID* BytecodeGenerator::emitNewMethodDefinition(RegisterID* dst, MethodDefinitionNode* func)
3093 {
3094     ASSERT(isMethodParseMode(func-&gt;metadata()-&gt;parseMode()));
3095     emitNewFunctionExpressionCommon(dst, func-&gt;metadata());
3096     return dst;
3097 }
3098 
3099 RegisterID* BytecodeGenerator::emitNewDefaultConstructor(RegisterID* dst, ConstructorKind constructorKind, const Identifier&amp; name,
3100     const Identifier&amp; ecmaName, const SourceCode&amp; classSource)
3101 {
<span class="line-modified">3102     UnlinkedFunctionExecutable* executable = m_vm.builtinExecutables()-&gt;createDefaultConstructor(constructorKind, name);</span>
3103     executable-&gt;setInvalidTypeProfilingOffsets();
3104     executable-&gt;setEcmaName(ecmaName);
3105     executable-&gt;setClassSource(classSource);
3106 
3107     unsigned index = m_codeBlock-&gt;addFunctionExpr(executable);
3108 
3109     OpNewFuncExp::emit(this, dst, scopeRegister(), index);
3110     return dst;
3111 }
3112 
3113 RegisterID* BytecodeGenerator::emitNewFunction(RegisterID* dst, FunctionMetadataNode* function)
3114 {
3115     unsigned index = m_codeBlock-&gt;addFunctionDecl(makeFunction(function));
3116     if (isGeneratorWrapperParseMode(function-&gt;parseMode()))
3117         OpNewGeneratorFunc::emit(this, dst, scopeRegister(), index);
3118     else if (function-&gt;parseMode() == SourceParseMode::AsyncFunctionMode)
3119         OpNewAsyncFunc::emit(this, dst, scopeRegister(), index);
3120     else if (isAsyncGeneratorWrapperParseMode(function-&gt;parseMode()))
3121         OpNewAsyncGeneratorFunc::emit(this, dst, scopeRegister(), index);
3122     else
3123         OpNewFunc::emit(this, dst, scopeRegister(), index);
3124     return dst;
3125 }
3126 
3127 void BytecodeGenerator::emitSetFunctionNameIfNeeded(ExpressionNode* valueNode, RegisterID* value, RegisterID* name)
3128 {
3129     if (valueNode-&gt;isBaseFuncExprNode()) {
3130         FunctionMetadataNode* metadata = static_cast&lt;BaseFuncExprNode*&gt;(valueNode)-&gt;metadata();
3131         if (!metadata-&gt;ecmaName().isNull())
3132             return;
3133     } else if (valueNode-&gt;isClassExprNode()) {
3134         ClassExprNode* classExprNode = static_cast&lt;ClassExprNode*&gt;(valueNode);
3135         if (!classExprNode-&gt;ecmaName().isNull())
3136             return;
<span class="line-modified">3137         if (classExprNode-&gt;hasStaticProperty(m_vm.propertyNames-&gt;name))</span>
3138             return;
3139     } else
3140         return;
3141 
3142     // FIXME: We should use an op_call to an internal function here instead.
3143     // https://bugs.webkit.org/show_bug.cgi?id=155547
3144     OpSetFunctionName::emit(this, value, name);
3145 }
3146 
3147 RegisterID* BytecodeGenerator::emitCall(RegisterID* dst, RegisterID* func, ExpectedFunction expectedFunction, CallArguments&amp; callArguments, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, DebuggableCall debuggableCall)
3148 {
3149     return emitCall&lt;OpCall&gt;(dst, func, expectedFunction, callArguments, divot, divotStart, divotEnd, debuggableCall);
3150 }
3151 
3152 RegisterID* BytecodeGenerator::emitCallInTailPosition(RegisterID* dst, RegisterID* func, ExpectedFunction expectedFunction, CallArguments&amp; callArguments, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, DebuggableCall debuggableCall)
3153 {
3154     if (m_inTailPosition) {
3155         m_codeBlock-&gt;setHasTailCalls();
3156         return emitCall&lt;OpTailCall&gt;(dst, func, expectedFunction, callArguments, divot, divotStart, divotEnd, debuggableCall);
3157     }
</pre>
<hr />
<pre>
3242                     RefPtr&lt;RegisterID&gt; argumentRegister = emitNode(callArguments.argumentRegister(0), expression);
3243                     OpSpread::emit(this, argumentRegister.get(), argumentRegister.get());
3244 
3245                     return emitCallVarargs&lt;typename VarArgsOp&lt;CallOp&gt;::type&gt;(dst, func, callArguments.thisRegister(), argumentRegister.get(), newTemporary(), 0, divot, divotStart, divotEnd, debuggableCall);
3246                 }
3247             }
3248             RefPtr&lt;RegisterID&gt; argumentRegister;
3249             argumentRegister = expression-&gt;emitBytecode(*this, callArguments.argumentRegister(0));
3250             RefPtr&lt;RegisterID&gt; thisRegister = move(newTemporary(), callArguments.thisRegister());
3251             return emitCallVarargs&lt;typename VarArgsOp&lt;CallOp&gt;::type&gt;(dst, func, callArguments.thisRegister(), argumentRegister.get(), newTemporary(), 0, divot, divotStart, divotEnd, debuggableCall);
3252         }
3253         for (; n; n = n-&gt;m_next)
3254             emitNode(callArguments.argumentRegister(argument++), n);
3255     }
3256 
3257     // Reserve space for call frame.
3258     Vector&lt;RefPtr&lt;RegisterID&gt;, CallFrame::headerSizeInRegisters, UnsafeVectorOverflow&gt; callFrame;
3259     for (int i = 0; i &lt; CallFrame::headerSizeInRegisters; ++i)
3260         callFrame.append(newTemporary());
3261 
<span class="line-modified">3262     if (shouldEmitDebugHooks() &amp;&amp; debuggableCall == DebuggableCall::Yes)</span>
3263         emitDebugHook(WillExecuteExpression, divotStart);
3264 
3265     emitExpressionInfo(divot, divotStart, divotEnd);
3266 
3267     Ref&lt;Label&gt; done = newLabel();
3268     expectedFunction = emitExpectedFunctionSnippet(dst, func, expectedFunction, callArguments, done.get());
3269 
3270     if (opcodeID == op_tail_call)
3271         emitLogShadowChickenTailIfNecessary();
3272 
3273     // Emit call.
3274     ASSERT(dst);
3275     ASSERT(dst != ignoredResult());
3276     CallOp::emit(this, dst, func, callArguments.argumentCountIncludingThis(), callArguments.stackOffset());
3277 
3278     if (expectedFunction != NoExpectedFunction)
3279         emitLabel(done.get());
3280 
3281     return dst;
3282 }
3283 
3284 RegisterID* BytecodeGenerator::emitCallVarargs(RegisterID* dst, RegisterID* func, RegisterID* thisRegister, RegisterID* arguments, RegisterID* firstFreeRegister, int32_t firstVarArgOffset, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, DebuggableCall debuggableCall)
3285 {
3286     return emitCallVarargs&lt;OpCallVarargs&gt;(dst, func, thisRegister, arguments, firstFreeRegister, firstVarArgOffset, divot, divotStart, divotEnd, debuggableCall);
3287 }
3288 
3289 RegisterID* BytecodeGenerator::emitCallVarargsInTailPosition(RegisterID* dst, RegisterID* func, RegisterID* thisRegister, RegisterID* arguments, RegisterID* firstFreeRegister, int32_t firstVarArgOffset, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, DebuggableCall debuggableCall)
3290 {
3291     if (m_inTailPosition)
3292         return emitCallVarargs&lt;OpTailCallVarargs&gt;(dst, func, thisRegister, arguments, firstFreeRegister, firstVarArgOffset, divot, divotStart, divotEnd, debuggableCall);
3293     return emitCallVarargs&lt;OpCallVarargs&gt;(dst, func, thisRegister, arguments, firstFreeRegister, firstVarArgOffset, divot, divotStart, divotEnd, debuggableCall);
3294 }
3295 
3296 RegisterID* BytecodeGenerator::emitConstructVarargs(RegisterID* dst, RegisterID* func, RegisterID* thisRegister, RegisterID* arguments, RegisterID* firstFreeRegister, int32_t firstVarArgOffset, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, DebuggableCall debuggableCall)
3297 {
3298     return emitCallVarargs&lt;OpConstructVarargs&gt;(dst, func, thisRegister, arguments, firstFreeRegister, firstVarArgOffset, divot, divotStart, divotEnd, debuggableCall);
3299 }
3300 
3301 RegisterID* BytecodeGenerator::emitCallForwardArgumentsInTailPosition(RegisterID* dst, RegisterID* func, RegisterID* thisRegister, RegisterID* firstFreeRegister, int32_t firstVarArgOffset, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, DebuggableCall debuggableCall)
3302 {
<span class="line-modified">3303     // We must emit a tail call here because we did not allocate an arguments object thus we would otherwise have no way to correctly make this call.</span>
<span class="line-added">3304     ASSERT(m_inTailPosition || !Options::useTailCalls());</span>
3305     return emitCallVarargs&lt;OpTailCallForwardArguments&gt;(dst, func, thisRegister, nullptr, firstFreeRegister, firstVarArgOffset, divot, divotStart, divotEnd, debuggableCall);
3306 }
3307 
3308 template&lt;typename VarargsOp&gt;
3309 RegisterID* BytecodeGenerator::emitCallVarargs(RegisterID* dst, RegisterID* func, RegisterID* thisRegister, RegisterID* arguments, RegisterID* firstFreeRegister, int32_t firstVarArgOffset, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, DebuggableCall debuggableCall)
3310 {
<span class="line-modified">3311     if (shouldEmitDebugHooks() &amp;&amp; debuggableCall == DebuggableCall::Yes)</span>
3312         emitDebugHook(WillExecuteExpression, divotStart);
3313 
3314     emitExpressionInfo(divot, divotStart, divotEnd);
3315 
3316     if (VarargsOp::opcodeID == op_tail_call_varargs)
3317         emitLogShadowChickenTailIfNecessary();
3318 
3319     // Emit call.
3320     ASSERT(dst != ignoredResult());
3321     VarargsOp::emit(this, dst, func, thisRegister, arguments ? arguments : VirtualRegister(0), firstFreeRegister, firstVarArgOffset);
3322     return dst;
3323 }
3324 
3325 void BytecodeGenerator::emitLogShadowChickenPrologueIfNecessary()
3326 {
<span class="line-modified">3327     if (!shouldEmitDebugHooks() &amp;&amp; !Options::alwaysUseShadowChicken())</span>
3328         return;
3329     OpLogShadowChickenPrologue::emit(this, scopeRegister());
3330 }
3331 
3332 void BytecodeGenerator::emitLogShadowChickenTailIfNecessary()
3333 {
<span class="line-modified">3334     if (!shouldEmitDebugHooks() &amp;&amp; !Options::alwaysUseShadowChicken())</span>
3335         return;
3336     OpLogShadowChickenTail::emit(this, thisRegister(), scopeRegister());
3337 }
3338 
3339 void BytecodeGenerator::emitCallDefineProperty(RegisterID* newObj, RegisterID* propertyNameRegister,
3340     RegisterID* valueRegister, RegisterID* getterRegister, RegisterID* setterRegister, unsigned options, const JSTextPosition&amp; position)
3341 {
3342     DefinePropertyAttributes attributes;
3343     if (options &amp; PropertyConfigurable)
3344         attributes.setConfigurable(true);
3345 
3346     if (options &amp; PropertyWritable)
3347         attributes.setWritable(true);
3348     else if (valueRegister)
3349         attributes.setWritable(false);
3350 
3351     if (options &amp; PropertyEnumerable)
3352         attributes.setEnumerable(true);
3353 
3354     if (valueRegister)
</pre>
<hr />
<pre>
3511     return dst;
3512 }
3513 
3514 void BytecodeGenerator::emitPopScope(RegisterID* dst, RegisterID* scope)
3515 {
3516     RefPtr&lt;RegisterID&gt; parentScope = emitGetParentScope(newTemporary(), scope);
3517     move(dst, parentScope.get());
3518 }
3519 
3520 void BytecodeGenerator::emitPopWithScope()
3521 {
3522     emitPopScope(scopeRegister(), scopeRegister());
3523     popLocalControlFlowScope();
3524     auto stackEntry = m_lexicalScopeStack.takeLast();
3525     stackEntry.m_scope-&gt;deref();
3526     RELEASE_ASSERT(stackEntry.m_isWithScope);
3527 }
3528 
3529 void BytecodeGenerator::emitDebugHook(DebugHookType debugHookType, const JSTextPosition&amp; divot)
3530 {
<span class="line-modified">3531     if (!shouldEmitDebugHooks())</span>
3532         return;
3533 
3534     emitExpressionInfo(divot, divot, divot);
3535     OpDebug::emit(this, debugHookType, false);
3536 }
3537 
3538 void BytecodeGenerator::emitDebugHook(DebugHookType debugHookType, unsigned line, unsigned charOffset, unsigned lineStart)
3539 {
3540     emitDebugHook(debugHookType, JSTextPosition(line, charOffset, lineStart));
3541 }
3542 
3543 void BytecodeGenerator::emitDebugHook(StatementNode* statement)
3544 {
3545     // DebuggerStatementNode will output its own special debug hook.
3546     if (statement-&gt;isDebuggerStatement())
3547         return;
3548 
3549     emitDebugHook(WillExecuteStatement, statement-&gt;position());
3550 }
3551 
3552 void BytecodeGenerator::emitDebugHook(ExpressionNode* expr)
3553 {
3554     emitDebugHook(WillExecuteStatement, expr-&gt;position());
3555 }
3556 
3557 void BytecodeGenerator::emitWillLeaveCallFrameDebugHook()
3558 {
3559     RELEASE_ASSERT(m_scopeNode-&gt;isFunctionNode());
3560     emitDebugHook(WillLeaveCallFrame, m_scopeNode-&gt;lastLine(), m_scopeNode-&gt;startOffset(), m_scopeNode-&gt;lineStartOffset());
3561 }
3562 
<span class="line-modified">3563 void BytecodeGenerator::pushFinallyControlFlowScope(FinallyContext&amp; finallyContext)</span>
3564 {
<span class="line-modified">3565     ControlFlowScope scope(ControlFlowScope::Finally, currentLexicalScopeIndex(), &amp;finallyContext);</span>
3566     m_controlFlowScopeStack.append(WTFMove(scope));
3567 
3568     m_finallyDepth++;
<span class="line-modified">3569     m_currentFinallyContext = &amp;finallyContext;</span>

3570 }
3571 
<span class="line-modified">3572 void BytecodeGenerator::popFinallyControlFlowScope()</span>
3573 {
3574     ASSERT(m_controlFlowScopeStack.size());
3575     ASSERT(m_controlFlowScopeStack.last().isFinallyScope());
3576     ASSERT(m_finallyDepth &gt; 0);
3577     ASSERT(m_currentFinallyContext);
3578     m_currentFinallyContext = m_currentFinallyContext-&gt;outerContext();
3579     m_finallyDepth--;
<span class="line-modified">3580     m_controlFlowScopeStack.removeLast();</span>
3581 }
3582 
3583 LabelScope* BytecodeGenerator::breakTarget(const Identifier&amp; name)
3584 {
3585     shrinkToFit(m_labelScopes);
3586 
3587     if (!m_labelScopes.size())
3588         return nullptr;
3589 
3590     // We special-case the following, which is a syntax error in Firefox:
3591     // label:
3592     //     break;
3593     if (name.isEmpty()) {
3594         for (int i = m_labelScopes.size() - 1; i &gt;= 0; --i) {
3595             LabelScope&amp; scope = m_labelScopes[i];
3596             if (scope.type() != LabelScope::NamedLabel)
3597                 return &amp;scope;
3598         }
3599         return nullptr;
3600     }
</pre>
<hr />
<pre>
3671         result
3672     });
3673 
3674     return result;
3675 }
3676 
3677 void BytecodeGenerator::popTry(TryData* tryData, Label&amp; end)
3678 {
3679     m_usesExceptions = true;
3680 
3681     ASSERT_UNUSED(tryData, m_tryContextStack.last().tryData == tryData);
3682 
3683     m_tryRanges.append(TryRange {
3684         m_tryContextStack.last().start.copyRef(),
3685         end,
3686         m_tryContextStack.last().tryData
3687     });
3688     m_tryContextStack.removeLast();
3689 }
3690 
<span class="line-modified">3691 void BytecodeGenerator::emitOutOfLineCatchHandler(RegisterID* thrownValueRegister, RegisterID* completionTypeRegister, TryData* data)</span>
3692 {
<span class="line-modified">3693     RegisterID* unused = newTemporary();</span>
<span class="line-added">3694     emitOutOfLineExceptionHandler(unused, thrownValueRegister, completionTypeRegister, data);</span>
<span class="line-added">3695 }</span>
<span class="line-added">3696 </span>
<span class="line-added">3697 void BytecodeGenerator::emitOutOfLineFinallyHandler(RegisterID* exceptionRegister, RegisterID* completionTypeRegister, TryData* data)</span>
<span class="line-added">3698 {</span>
<span class="line-added">3699     RegisterID* unused = newTemporary();</span>
<span class="line-added">3700     ASSERT(completionTypeRegister);</span>
<span class="line-added">3701     emitOutOfLineExceptionHandler(exceptionRegister, unused, completionTypeRegister, data);</span>
<span class="line-added">3702 }</span>
<span class="line-added">3703 </span>
<span class="line-added">3704 void BytecodeGenerator::emitOutOfLineExceptionHandler(RegisterID* exceptionRegister, RegisterID* thrownValueRegister, RegisterID* completionTypeRegister, TryData* data)</span>
<span class="line-added">3705 {</span>
<span class="line-added">3706     VirtualRegister completionTypeVirtualRegister = completionTypeRegister ? completionTypeRegister : VirtualRegister();</span>
<span class="line-added">3707     m_exceptionHandlersToEmit.append({ data, exceptionRegister, thrownValueRegister, completionTypeVirtualRegister });</span>
3708 }
3709 
3710 void BytecodeGenerator::restoreScopeRegister(int lexicalScopeIndex)
3711 {
3712     if (lexicalScopeIndex == CurrentLexicalScopeIndex)
3713         return; // No change needed.
3714 
3715     if (lexicalScopeIndex != OutermostLexicalScopeIndex) {
3716         ASSERT(lexicalScopeIndex &lt; static_cast&lt;int&gt;(m_lexicalScopeStack.size()));
3717         int endIndex = lexicalScopeIndex + 1;
3718         for (size_t i = endIndex; i--; ) {
3719             if (m_lexicalScopeStack[i].m_scope) {
3720                 move(scopeRegister(), m_lexicalScopeStack[i].m_scope);
3721                 return;
3722             }
3723         }
3724     }
3725     // Note that if we don&#39;t find a local scope in the current function/program,
3726     // we must grab the outer-most scope of this bytecode generation.
3727     move(scopeRegister(), m_topMostScope);
</pre>
<hr />
<pre>
3739     ASSERT(scopeDelta &lt;= m_controlFlowScopeStack.size());
3740     if (!scopeDelta)
3741         return CurrentLexicalScopeIndex;
3742 
3743     ControlFlowScope&amp; targetScope = m_controlFlowScopeStack[targetLabelScopeDepth];
3744     return targetScope.lexicalScopeIndex;
3745 }
3746 
3747 void BytecodeGenerator::emitThrow(RegisterID* exc)
3748 {
3749     m_usesExceptions = true;
3750     OpThrow::emit(this, exc);
3751 }
3752 
3753 RegisterID* BytecodeGenerator::emitArgumentCount(RegisterID* dst)
3754 {
3755     OpArgumentCount::emit(this, dst);
3756     return dst;
3757 }
3758 
<span class="line-modified">3759 unsigned BytecodeGenerator::localScopeDepth() const</span>
3760 {
3761     return m_localScopeDepth;
3762 }
3763 
3764 int BytecodeGenerator::labelScopeDepth() const
3765 {
3766     unsigned depth = localScopeDepth() + m_finallyDepth;
3767     ASSERT(depth == m_controlFlowScopeStack.size());
3768     return depth;
3769 }
3770 
3771 void BytecodeGenerator::emitThrowStaticError(ErrorType errorType, RegisterID* raw)
3772 {
3773     RefPtr&lt;RegisterID&gt; message = newTemporary();
3774     emitToString(message.get(), raw);
3775     OpThrowStaticError::emit(this, message.get(), errorType);
3776 }
3777 
3778 void BytecodeGenerator::emitThrowStaticError(ErrorType errorType, const Identifier&amp; message)
3779 {
</pre>
<hr />
<pre>
4002         return false;
4003     return registerID-&gt;index() == CallFrame::argumentOffset(argumentNumber);
4004 }
4005 
4006 bool BytecodeGenerator::emitReadOnlyExceptionIfNeeded(const Variable&amp; variable)
4007 {
4008     // If we&#39;re in strict mode, we always throw.
4009     // If we&#39;re not in strict mode, we throw for &quot;const&quot; variables but not the function callee.
4010     if (isStrictMode() || variable.isConst()) {
4011         emitThrowTypeError(Identifier::fromString(m_vm, ReadonlyPropertyWriteError));
4012         return true;
4013     }
4014     return false;
4015 }
4016 
4017 void BytecodeGenerator::emitEnumeration(ThrowableExpressionData* node, ExpressionNode* subjectNode, const ScopedLambda&lt;void(BytecodeGenerator&amp;, RegisterID*)&gt;&amp; callBack, ForOfNode* forLoopNode, RegisterID* forLoopSymbolTable)
4018 {
4019     bool isForAwait = forLoopNode ? forLoopNode-&gt;isForAwait() : false;
4020     ASSERT(!isForAwait || (isForAwait &amp;&amp; isAsyncFunctionParseMode(parseMode())));
4021 


4022     RefPtr&lt;RegisterID&gt; subject = newTemporary();
4023     emitNode(subject.get(), subjectNode);
4024     RefPtr&lt;RegisterID&gt; iterator = isForAwait ? emitGetAsyncIterator(subject.get(), node) : emitGetIterator(subject.get(), node);
4025     RefPtr&lt;RegisterID&gt; nextMethod = emitGetById(newTemporary(), iterator.get(), propertyNames().next);
4026 
4027     Ref&lt;Label&gt; loopDone = newLabel();
4028     Ref&lt;Label&gt; tryStartLabel = newLabel();
4029     Ref&lt;Label&gt; finallyViaThrowLabel = newLabel();
4030     Ref&lt;Label&gt; finallyLabel = newLabel();
4031     Ref&lt;Label&gt; catchLabel = newLabel();
4032     Ref&lt;Label&gt; endCatchLabel = newLabel();
4033 
4034     // RefPtr&lt;Register&gt; iterator&#39;s lifetime must be longer than IteratorCloseContext.
<span class="line-modified">4035     FinallyContext finallyContext(*this, finallyLabel.get());</span>
<span class="line-added">4036     pushFinallyControlFlowScope(finallyContext);</span>
4037 
4038     {
4039         Ref&lt;LabelScope&gt; scope = newLabelScope(LabelScope::Loop);
4040         RefPtr&lt;RegisterID&gt; value = newTemporary();
4041         emitLoad(value.get(), jsUndefined());
4042 
4043         emitJump(*scope-&gt;continueTarget());
4044 
4045         Ref&lt;Label&gt; loopStart = newLabel();
4046         emitLabel(loopStart.get());
4047         emitLoopHint();
4048 
4049         emitLabel(tryStartLabel.get());
4050         TryData* tryData = pushTry(tryStartLabel.get(), finallyViaThrowLabel.get(), HandlerType::SynthesizedFinally);
4051         callBack(*this, value.get());
4052         emitJump(*scope-&gt;continueTarget());
4053 
4054         // IteratorClose sequence for abrupt completions.
4055         {
4056             // Finally block for the enumeration.
4057             emitLabel(finallyViaThrowLabel.get());
4058             popTry(tryData, finallyViaThrowLabel.get());
4059 
4060             Ref&lt;Label&gt; finallyBodyLabel = newLabel();
4061             RefPtr&lt;RegisterID&gt; finallyExceptionRegister = newTemporary();

4062 
<span class="line-modified">4063             emitOutOfLineFinallyHandler(finallyContext.completionValueRegister(), finallyContext.completionTypeRegister(), tryData);</span>
<span class="line-modified">4064             move(finallyExceptionRegister.get(), finallyContext.completionValueRegister());</span>

4065             emitJump(finallyBodyLabel.get());
4066 
4067             emitLabel(finallyLabel.get());
4068             moveEmptyValue(finallyExceptionRegister.get());
4069 
<span class="line-added">4070             // Finally fall through case.</span>
4071             emitLabel(finallyBodyLabel.get());
4072             restoreScopeRegister();
4073 
4074             Ref&lt;Label&gt; finallyDone = newLabel();
4075 
4076             RefPtr&lt;RegisterID&gt; returnMethod = emitGetById(newTemporary(), iterator.get(), propertyNames().returnKeyword);
4077             emitJumpIfTrue(emitIsUndefined(newTemporary(), returnMethod.get()), finallyDone.get());
4078 
4079             Ref&lt;Label&gt; returnCallTryStart = newLabel();
4080             emitLabel(returnCallTryStart.get());
4081             TryData* returnCallTryData = pushTry(returnCallTryStart.get(), catchLabel.get(), HandlerType::SynthesizedCatch);
4082 
4083             CallArguments returnArguments(*this, nullptr);
4084             move(returnArguments.thisRegister(), iterator.get());
4085             emitCall(value.get(), returnMethod.get(), NoExpectedFunction, returnArguments, node-&gt;divot(), node-&gt;divotStart(), node-&gt;divotEnd(), DebuggableCall::No);
4086 
4087             if (isForAwait)
4088                 emitAwait(value.get());
4089 
4090             emitJumpIfTrue(emitIsObject(newTemporary(), value.get()), finallyDone.get());
4091             emitThrowTypeError(&quot;Iterator result interface is not an object.&quot;_s);
4092 
4093             emitLabel(finallyDone.get());
<span class="line-modified">4094             emitFinallyCompletion(finallyContext, endCatchLabel.get());</span>
4095 
4096             popTry(returnCallTryData, finallyDone.get());
4097 
4098             // Catch block for exceptions that may be thrown while calling the return
4099             // handler in the enumeration finally block. The only reason we need this
4100             // catch block is because if entered the above finally block due to a thrown
4101             // exception, then we want to re-throw the original exception on exiting
4102             // the finally block. Otherwise, we&#39;ll let any new exception pass through.
4103             {
4104                 emitLabel(catchLabel.get());
<span class="line-added">4105 </span>
4106                 RefPtr&lt;RegisterID&gt; exceptionRegister = newTemporary();
<span class="line-modified">4107                 emitOutOfLineFinallyHandler(exceptionRegister.get(), finallyContext.completionTypeRegister(), returnCallTryData);</span>

4108                 // Since this is a synthesized catch block and we&#39;re guaranteed to never need
4109                 // to resolve any symbols from the scope, we can skip restoring the scope
4110                 // register here.
4111 
4112                 Ref&lt;Label&gt; throwLabel = newLabel();
4113                 emitJumpIfTrue(emitIsEmpty(newTemporary(), finallyExceptionRegister.get()), throwLabel.get());
4114                 move(exceptionRegister.get(), finallyExceptionRegister.get());
4115 
4116                 emitLabel(throwLabel.get());
4117                 emitThrow(exceptionRegister.get());
4118 
4119                 emitLabel(endCatchLabel.get());
4120             }
4121         }
4122 
4123         emitLabel(*scope-&gt;continueTarget());
4124         if (forLoopNode) {
4125             RELEASE_ASSERT(forLoopNode-&gt;isForOfNode());
4126             prepareLexicalScopeForNextForLoopIteration(forLoopNode, forLoopSymbolTable);
4127             emitDebugHook(forLoopNode-&gt;lexpr());
</pre>
<hr />
<pre>
4145         }
4146     }
4147     emitLabel(loopDone.get());
4148 }
4149 
4150 RegisterID* BytecodeGenerator::emitGetTemplateObject(RegisterID* dst, TaggedTemplateNode* taggedTemplate)
4151 {
4152     TemplateObjectDescriptor::StringVector rawStrings;
4153     TemplateObjectDescriptor::OptionalStringVector cookedStrings;
4154 
4155     TemplateStringListNode* templateString = taggedTemplate-&gt;templateLiteral()-&gt;templateStrings();
4156     for (; templateString; templateString = templateString-&gt;next()) {
4157         auto* string = templateString-&gt;value();
4158         ASSERT(string-&gt;raw());
4159         rawStrings.append(string-&gt;raw()-&gt;impl());
4160         if (!string-&gt;cooked())
4161             cookedStrings.append(WTF::nullopt);
4162         else
4163             cookedStrings.append(string-&gt;cooked()-&gt;impl());
4164     }
<span class="line-modified">4165     RefPtr&lt;RegisterID&gt; constant = addTemplateObjectConstant(TemplateObjectDescriptor::create(WTFMove(rawStrings), WTFMove(cookedStrings)), taggedTemplate-&gt;endOffset());</span>
4166     if (!dst)
4167         return constant.get();
4168     return move(dst, constant.get());
4169 }
4170 
4171 RegisterID* BytecodeGenerator::emitGetGlobalPrivate(RegisterID* dst, const Identifier&amp; property)
4172 {
4173     dst = tempDestination(dst);
4174     Variable var = variable(property);
4175     if (RegisterID* local = var.local())
4176         return move(dst, local);
4177 
4178     RefPtr&lt;RegisterID&gt; scope = newTemporary();
4179     move(scope.get(), emitResolveScope(scope.get(), var));
4180     return emitGetFromScope(dst, scope.get(), var, ThrowIfNotFound);
4181 }
4182 
4183 RegisterID* BytecodeGenerator::emitGetEnumerableLength(RegisterID* dst, RegisterID* base)
4184 {
4185     OpGetEnumerableLength::emit(this, dst, base);
</pre>
<hr />
<pre>
4438 {
4439     if (!localRegister)
4440         return;
4441     unsigned bodyBytecodeEndOffset = instructions().size();
4442     m_forInContextStack.last()-&gt;asStructureForInContext().finalize(*this, m_codeBlock.get(), bodyBytecodeEndOffset);
4443     m_forInContextStack.removeLast();
4444 }
4445 
4446 RegisterID* BytecodeGenerator::emitRestParameter(RegisterID* result, unsigned numParametersToSkip)
4447 {
4448     RefPtr&lt;RegisterID&gt; restArrayLength = newTemporary();
4449     OpGetRestLength::emit(this, restArrayLength.get(), numParametersToSkip);
4450 
4451     OpCreateRest::emit(this, result, restArrayLength.get(), numParametersToSkip);
4452 
4453     return result;
4454 }
4455 
4456 void BytecodeGenerator::emitRequireObjectCoercible(RegisterID* value, const String&amp; error)
4457 {


4458     Ref&lt;Label&gt; target = newLabel();
<span class="line-modified">4459     OpJnundefinedOrNull::emit(this, value, target-&gt;bind(this));</span>
4460     emitThrowTypeError(error);
4461     emitLabel(target.get());
4462 }
4463 
4464 void BytecodeGenerator::emitYieldPoint(RegisterID* argument, JSAsyncGeneratorFunction::AsyncGeneratorSuspendReason result)
4465 {
4466     Ref&lt;Label&gt; mergePoint = newLabel();
4467     unsigned yieldPointIndex = m_yieldPoints++;
4468     emitGeneratorStateChange(yieldPointIndex + 1);
4469 
4470     if (parseMode() == SourceParseMode::AsyncGeneratorBodyMode) {
4471         int suspendReason = static_cast&lt;int32_t&gt;(result);
4472         emitPutById(generatorRegister(), propertyNames().builtinNames().asyncGeneratorSuspendReasonPrivateName(), emitLoad(nullptr, jsNumber(suspendReason)));
4473     }
4474 
4475     // Split the try range here.
4476     Ref&lt;Label&gt; savePoint = newEmittedLabel();
4477     for (unsigned i = m_tryContextStack.size(); i--;) {
4478         TryContext&amp; context = m_tryContextStack[i];
4479         m_tryRanges.append(TryRange {
4480             context.start.copyRef(),
4481             savePoint.copyRef(),
4482             context.tryData
4483         });
4484         // Try range will be restared at the merge point.
4485         context.start = mergePoint.get();
4486     }
4487     Vector&lt;TryContext&gt; savedTryContextStack;
4488     m_tryContextStack.swap(savedTryContextStack);
4489 
4490 
4491 #if CPU(NEEDS_ALIGNED_ACCESS)
4492     // conservatively align for the bytecode rewriter: it will delete this yield and
4493     // append a fragment, so we make sure that the start of the fragments is aligned
<span class="line-modified">4494     while (m_writer.position() % OpcodeSize::Wide32)</span>
4495         OpNop::emit&lt;OpcodeSize::Narrow&gt;(this);
4496 #endif
4497     OpYield::emit(this, generatorFrameRegister(), yieldPointIndex, argument);
4498 
4499     // Restore the try contexts, which start offset is updated to the merge point.
4500     m_tryContextStack.swap(savedTryContextStack);
4501     emitLabel(mergePoint.get());
4502 }
4503 
4504 RegisterID* BytecodeGenerator::emitYield(RegisterID* argument, JSAsyncGeneratorFunction::AsyncGeneratorSuspendReason result)
4505 {
4506     emitYieldPoint(argument, result);
4507 
4508     Ref&lt;Label&gt; normalLabel = newLabel();
4509     RefPtr&lt;RegisterID&gt; condition = newTemporary();
4510     emitEqualityOp&lt;OpStricteq&gt;(condition.get(), generatorResumeModeRegister(), emitLoad(nullptr, jsNumber(static_cast&lt;int32_t&gt;(JSGeneratorFunction::GeneratorResumeMode::NormalMode))));
4511     emitJumpIfTrue(condition.get(), normalLabel.get());
4512 
4513     Ref&lt;Label&gt; throwLabel = newLabel();
4514     emitEqualityOp&lt;OpStricteq&gt;(condition.get(), generatorResumeModeRegister(), emitLoad(nullptr, jsNumber(static_cast&lt;int32_t&gt;(JSGeneratorFunction::GeneratorResumeMode::ThrowMode))));
</pre>
<hr />
<pre>
4724 void BytecodeGenerator::emitGeneratorStateChange(int32_t state)
4725 {
4726     RegisterID* completedState = emitLoad(nullptr, jsNumber(state));
4727     emitPutById(generatorRegister(), propertyNames().builtinNames().generatorStatePrivateName(), completedState);
4728 }
4729 
4730 bool BytecodeGenerator::emitJumpViaFinallyIfNeeded(int targetLabelScopeDepth, Label&amp; jumpTarget)
4731 {
4732     ASSERT(labelScopeDepth() - targetLabelScopeDepth &gt;= 0);
4733     size_t numberOfScopesToCheckForFinally = labelScopeDepth() - targetLabelScopeDepth;
4734     ASSERT(numberOfScopesToCheckForFinally &lt;= m_controlFlowScopeStack.size());
4735     if (!numberOfScopesToCheckForFinally)
4736         return false;
4737 
4738     FinallyContext* innermostFinallyContext = nullptr;
4739     FinallyContext* outermostFinallyContext = nullptr;
4740     size_t scopeIndex = m_controlFlowScopeStack.size() - 1;
4741     while (numberOfScopesToCheckForFinally--) {
4742         ControlFlowScope* scope = &amp;m_controlFlowScopeStack[scopeIndex--];
4743         if (scope-&gt;isFinallyScope()) {
<span class="line-modified">4744             FinallyContext* finallyContext = scope-&gt;finallyContext;</span>
4745             if (!innermostFinallyContext)
4746                 innermostFinallyContext = finallyContext;
4747             outermostFinallyContext = finallyContext;
4748             finallyContext-&gt;incNumberOfBreaksOrContinues();
4749         }
4750     }
4751     if (!outermostFinallyContext)
4752         return false; // No finallys to thread through.
4753 
4754     auto jumpID = bytecodeOffsetToJumpID(instructions().size());
4755     int lexicalScopeIndex = labelScopeDepthToLexicalScopeIndex(targetLabelScopeDepth);
4756     outermostFinallyContext-&gt;registerJump(jumpID, lexicalScopeIndex, jumpTarget);
4757 
<span class="line-modified">4758     emitLoad(innermostFinallyContext-&gt;completionTypeRegister(), jumpID);</span>
4759     emitJump(*innermostFinallyContext-&gt;finallyLabel());
4760     return true; // We&#39;ll be jumping to a finally block.
4761 }
4762 
4763 bool BytecodeGenerator::emitReturnViaFinallyIfNeeded(RegisterID* returnRegister)
4764 {
4765     size_t numberOfScopesToCheckForFinally = m_controlFlowScopeStack.size();
4766     if (!numberOfScopesToCheckForFinally)
4767         return false;
4768 
4769     FinallyContext* innermostFinallyContext = nullptr;
4770     while (numberOfScopesToCheckForFinally) {
4771         size_t scopeIndex = --numberOfScopesToCheckForFinally;
4772         ControlFlowScope* scope = &amp;m_controlFlowScopeStack[scopeIndex];
4773         if (scope-&gt;isFinallyScope()) {
<span class="line-modified">4774             FinallyContext* finallyContext = scope-&gt;finallyContext;</span>
4775             if (!innermostFinallyContext)
4776                 innermostFinallyContext = finallyContext;
4777             finallyContext-&gt;setHandlesReturns();
4778         }
4779     }
4780     if (!innermostFinallyContext)
4781         return false; // No finallys to thread through.
4782 
<span class="line-modified">4783     emitLoad(innermostFinallyContext-&gt;completionTypeRegister(), CompletionType::Return);</span>
<span class="line-modified">4784     move(innermostFinallyContext-&gt;completionValueRegister(), returnRegister);</span>
4785     emitJump(*innermostFinallyContext-&gt;finallyLabel());
4786     return true; // We&#39;ll be jumping to a finally block.
4787 }
4788 
<span class="line-modified">4789 void BytecodeGenerator::emitFinallyCompletion(FinallyContext&amp; context, Label&amp; normalCompletionLabel)</span>
4790 {
4791     if (context.numberOfBreaksOrContinues() || context.handlesReturns()) {
<span class="line-modified">4792         emitJumpIf&lt;OpStricteq&gt;(context.completionTypeRegister(), CompletionType::Normal, normalCompletionLabel);</span>
4793 
4794         FinallyContext* outerContext = context.outerContext();
4795 
4796         size_t numberOfJumps = context.numberOfJumps();
4797         ASSERT(outerContext || numberOfJumps == context.numberOfBreaksOrContinues());
4798 
<span class="line-added">4799         // Handle Break or Continue completions that jumps into this FinallyContext.</span>
4800         for (size_t i = 0; i &lt; numberOfJumps; i++) {
4801             Ref&lt;Label&gt; nextLabel = newLabel();
4802             auto&amp; jump = context.jumps(i);
<span class="line-modified">4803             emitJumpIf&lt;OpNstricteq&gt;(context.completionTypeRegister(), jump.jumpID, nextLabel.get());</span>
<span class="line-added">4804 </span>
<span class="line-added">4805             // This case is for Break / Continue completions from an inner finally context</span>
<span class="line-added">4806             // with a jump target that is not beyond the next outer finally context:</span>
<span class="line-added">4807             //</span>
<span class="line-added">4808             //     try {</span>
<span class="line-added">4809             //         for (... stuff ...) {</span>
<span class="line-added">4810             //             try {</span>
<span class="line-added">4811             //                 continue; // Sets completionType to jumpID of top of the for loop.</span>
<span class="line-added">4812             //             } finally {</span>
<span class="line-added">4813             //             } // Jump to top of the for loop on completion.</span>
<span class="line-added">4814             //         }</span>
<span class="line-added">4815             //     } finally {</span>
<span class="line-added">4816             //     }</span>
<span class="line-added">4817             //</span>
<span class="line-added">4818             // Since the jumpID is targetting a label that is inside the outer finally context,</span>
<span class="line-added">4819             // we can jump to it directly on completion of this finally context: there is no intermediate</span>
<span class="line-added">4820             // finally blocks to run. After the Break / Continue, we will contnue execution as normal.</span>
<span class="line-added">4821             // So, we&#39;ll set the completionType to Normal (on behalf of the target) before we jump.</span>
<span class="line-added">4822             // We can also set the completion value to undefined, but it will never be used for normal</span>
<span class="line-added">4823             // completion anyway. So, we&#39;ll skip setting it.</span>
4824 
4825             restoreScopeRegister(jump.targetLexicalScopeIndex);
<span class="line-modified">4826             emitLoad(context.completionTypeRegister(), CompletionType::Normal);</span>
4827             emitJump(jump.targetLabel.get());
4828 
4829             emitLabel(nextLabel.get());
4830         }
4831 
<span class="line-added">4832         // Handle completions that take us out of this FinallyContext.</span>
4833         if (outerContext) {
<span class="line-modified">4834             if (context.handlesReturns()) {</span>
<span class="line-modified">4835                 Ref&lt;Label&gt; isNotReturnLabel = newLabel();</span>
<span class="line-modified">4836                 emitJumpIf&lt;OpNstricteq&gt;(context.completionTypeRegister(), CompletionType::Return, isNotReturnLabel.get());</span>
<span class="line-modified">4837 </span>
<span class="line-added">4838                 // This case is for Return completion from an inner finally context:</span>
<span class="line-added">4839                 //</span>
<span class="line-added">4840                 //     try {</span>
<span class="line-added">4841                 //         try {</span>
<span class="line-added">4842                 //             return result; // Sets completionType to Return, and completionValue to result.</span>
<span class="line-added">4843                 //         } finally {</span>
<span class="line-added">4844                 //         } // Jump to outer finally on completion.</span>
<span class="line-added">4845                 //     } finally {</span>
<span class="line-added">4846                 //     }</span>
<span class="line-added">4847                 //</span>
<span class="line-added">4848                 // Since we know there&#39;s at least one outer finally context (beyond the current context),</span>
<span class="line-added">4849                 // we cannot actually return from here. Instead, we pass the completionType and completionValue</span>
<span class="line-added">4850                 // on to the next outer finally, and let it decide what to do next on its completion. The</span>
<span class="line-added">4851                 // outer finally may or may not actual return depending on whether it encounters an abrupt</span>
<span class="line-added">4852                 // completion in its body that overrrides this Return completion.</span>
<span class="line-added">4853 </span>
<span class="line-added">4854                 move(outerContext-&gt;completionTypeRegister(), context.completionTypeRegister());</span>
<span class="line-added">4855                 move(outerContext-&gt;completionValueRegister(), context.completionValueRegister());</span>
<span class="line-added">4856                 emitJump(*outerContext-&gt;finallyLabel());</span>
<span class="line-added">4857 </span>
<span class="line-added">4858                 emitLabel(isNotReturnLabel.get());</span>
<span class="line-added">4859             }</span>
<span class="line-added">4860 </span>
<span class="line-added">4861             bool hasBreaksOrContinuesThatEscapeCurrentFinally = context.numberOfBreaksOrContinues() &gt; numberOfJumps;</span>
<span class="line-added">4862             if (hasBreaksOrContinuesThatEscapeCurrentFinally) {</span>
<span class="line-added">4863                 Ref&lt;Label&gt; isThrowOrNormalLabel = newLabel();</span>
<span class="line-added">4864                 emitJumpIf&lt;OpBeloweq&gt;(context.completionTypeRegister(), CompletionType::Throw, isThrowOrNormalLabel.get());</span>
<span class="line-added">4865 </span>
<span class="line-added">4866                 // A completionType above Throw means we have a Break or Continue encoded as a jumpID.</span>
<span class="line-added">4867                 // We already ruled out Return above.</span>
<span class="line-added">4868                 static_assert(CompletionType::Throw &lt; CompletionType::Return &amp;&amp; CompletionType::Throw &lt; CompletionType::Return, &quot;jumpIDs are above CompletionType::Return&quot;);</span>
<span class="line-added">4869 </span>
<span class="line-added">4870                 // This case is for Break / Continue completions in an inner finally context:</span>
<span class="line-added">4871                 //</span>
<span class="line-added">4872                 // 10: label:</span>
<span class="line-added">4873                 // 11: try {</span>
<span class="line-added">4874                 // 12:     try {</span>
<span class="line-added">4875                 // 13:         for (... stuff ...)</span>
<span class="line-added">4876                 // 14:             break label; // Sets completionType to jumpID of label.</span>
<span class="line-added">4877                 // 15:     } finally {</span>
<span class="line-added">4878                 // 16:     } // Jumps to outer finally on completion.</span>
<span class="line-added">4879                 // 17:  } finally {</span>
<span class="line-added">4880                 // 18:  }</span>
<span class="line-added">4881                 //</span>
<span class="line-added">4882                 // The break (line 14) says to continue execution at the label at line 10. Before we can</span>
<span class="line-added">4883                 // goto line 10, the inner context&#39;s finally (line 15) needs to be run, followed by the</span>
<span class="line-added">4884                 // outer context&#39;s finally (line 17). &#39;outerContext&#39; being non-null above tells us that</span>
<span class="line-added">4885                 // there is at least one outer finally context that we need to run after we complete the</span>
<span class="line-added">4886                 // current finally. Note that unless the body of the outer finally abruptly completes in a</span>
<span class="line-added">4887                 // different way, that outer finally also needs to complete with a Break / Continue to</span>
<span class="line-added">4888                 // the same target label. Hence, we need to pass the jumpID in this finally&#39;s completionTypeRegister</span>
<span class="line-added">4889                 // to the outer finally. The completion value for Break and Continue according to the spec</span>
<span class="line-added">4890                 // is undefined, but it won&#39;t ever be used. So, we&#39;ll skip setting it.</span>
<span class="line-added">4891                 //</span>
<span class="line-added">4892                 // Note that all we&#39;re doing here is passing the Break / Continue completion to the next</span>
<span class="line-added">4893                 // outer finally context. We don&#39;t worry about finally contexts beyond that. It is the</span>
<span class="line-added">4894                 // responsibility of the next outer finally to determine what to do next at its completion,</span>
<span class="line-added">4895                 // and pass on to the next outer context if present and needed.</span>
<span class="line-added">4896 </span>
<span class="line-added">4897                 move(outerContext-&gt;completionTypeRegister(), context.completionTypeRegister());</span>
<span class="line-added">4898                 emitJump(*outerContext-&gt;finallyLabel());</span>
<span class="line-added">4899 </span>
<span class="line-added">4900                 emitLabel(isThrowOrNormalLabel.get());</span>
<span class="line-added">4901             }</span>
4902 
4903         } else {
4904             // We are the outermost finally.
4905             if (context.handlesReturns()) {
4906                 Ref&lt;Label&gt; notReturnLabel = newLabel();
<span class="line-modified">4907                 emitJumpIf&lt;OpNstricteq&gt;(context.completionTypeRegister(), CompletionType::Return, notReturnLabel.get());</span>
<span class="line-added">4908 </span>
<span class="line-added">4909                 // This case is for Return completion from the outermost finally context:</span>
<span class="line-added">4910                 //</span>
<span class="line-added">4911                 //     try {</span>
<span class="line-added">4912                 //         return result; // Sets completionType to Return, and completionValue to result.</span>
<span class="line-added">4913                 //     } finally {</span>
<span class="line-added">4914                 //     } // Executes the return of the completionValue.</span>
<span class="line-added">4915                 //</span>
<span class="line-added">4916                 // Since we know there&#39;s no outer finally context (beyond the current context) to run,</span>
<span class="line-added">4917                 // we can actually execute a return for this Return completion. The value to return</span>
<span class="line-added">4918                 // is whatever is in the completionValueRegister.</span>
4919 
4920                 emitWillLeaveCallFrameDebugHook();
<span class="line-modified">4921                 emitReturn(context.completionValueRegister(), ReturnFrom::Finally);</span>
4922 
4923                 emitLabel(notReturnLabel.get());
4924             }
4925         }
4926     }



4927 
<span class="line-modified">4928     // By now, we&#39;ve rule out all Break / Continue / Return completions above. The only remaining</span>
<span class="line-modified">4929     // possibilities are Normal or Throw.</span>


4930 
<span class="line-modified">4931     emitJumpIf&lt;OpNstricteq&gt;(context.completionTypeRegister(), CompletionType::Throw, normalCompletionLabel);</span>


4932 
<span class="line-modified">4933     // We get here because we entered this finally context with Throw completionType (i.e. we have</span>
<span class="line-modified">4934     // an exception that we need to rethrow), and we didn&#39;t encounter a different abrupt completion</span>
<span class="line-modified">4935     // that overrides that incoming completionType. All we have to do here is re-throw the exception</span>
<span class="line-modified">4936     // captured in the completionValue.</span>
<span class="line-added">4937     //</span>
<span class="line-added">4938     // Note that unlike for Break / Continue / Return, we don&#39;t need to worry about outer finally</span>
<span class="line-added">4939     // contexts. This is because any outer finally context (if present) will have its own exception</span>
<span class="line-added">4940     // handler, which will take care of receiving the Throw completion, and re-capturing the exception</span>
<span class="line-added">4941     // in its completionValue.</span>
4942 
<span class="line-modified">4943     emitThrow(context.completionValueRegister());</span>




4944 }
4945 
4946 template&lt;typename CompareOp&gt;
4947 void BytecodeGenerator::emitJumpIf(RegisterID* completionTypeRegister, CompletionType type, Label&amp; jumpTarget)
4948 {
4949     RefPtr&lt;RegisterID&gt; tempRegister = newTemporary();
4950     RegisterID* valueConstant = addConstantValue(jsNumber(static_cast&lt;int&gt;(type)));
4951     OperandTypes operandTypes = OperandTypes(ResultType::numberTypeIsInt32(), ResultType::unknownType());
4952 
<span class="line-modified">4953     auto equivalenceResult = emitBinaryOp&lt;CompareOp&gt;(tempRegister.get(), completionTypeRegister, valueConstant, operandTypes);</span>
4954     emitJumpIfTrue(equivalenceResult, jumpTarget);
4955 }
4956 
<span class="line-added">4957 void BytecodeGenerator::pushOptionalChainTarget()</span>
<span class="line-added">4958 {</span>
<span class="line-added">4959     m_optionalChainTargetStack.append(newLabel());</span>
<span class="line-added">4960 }</span>
<span class="line-added">4961 </span>
<span class="line-added">4962 void BytecodeGenerator::popOptionalChainTarget()</span>
<span class="line-added">4963 {</span>
<span class="line-added">4964     ASSERT(m_optionalChainTargetStack.size());</span>
<span class="line-added">4965     emitLabel(m_optionalChainTargetStack.takeLast().get());</span>
<span class="line-added">4966 }</span>
<span class="line-added">4967 </span>
<span class="line-added">4968 void BytecodeGenerator::popOptionalChainTarget(RegisterID* dst, bool isDelete)</span>
<span class="line-added">4969 {</span>
<span class="line-added">4970     Ref&lt;Label&gt; endLabel = newLabel();</span>
<span class="line-added">4971     emitJump(endLabel.get());</span>
<span class="line-added">4972 </span>
<span class="line-added">4973     popOptionalChainTarget();</span>
<span class="line-added">4974     emitLoad(dst, isDelete ? jsBoolean(true) : jsUndefined());</span>
<span class="line-added">4975 </span>
<span class="line-added">4976     emitLabel(endLabel.get());</span>
<span class="line-added">4977 }</span>
<span class="line-added">4978 </span>
<span class="line-added">4979 void BytecodeGenerator::emitOptionalCheck(RegisterID* src)</span>
<span class="line-added">4980 {</span>
<span class="line-added">4981     ASSERT(m_optionalChainTargetStack.size());</span>
<span class="line-added">4982     emitJumpIfTrue(emitIsUndefinedOrNull(newTemporary(), src), m_optionalChainTargetStack.last().get());</span>
<span class="line-added">4983 }</span>
<span class="line-added">4984 </span>
4985 void ForInContext::finalize(BytecodeGenerator&amp; generator, UnlinkedCodeBlock* codeBlock, unsigned bodyBytecodeEndOffset)
4986 {
4987     // Lexically invalidating ForInContexts is kind of weak sauce, but it only occurs if
4988     // either of the following conditions is true:
4989     //
4990     // (1) The loop iteration variable is re-assigned within the body of the loop.
4991     // (2) The loop iteration variable is captured in the lexical scope of the function.
4992     //
4993     // These two situations occur sufficiently rarely that it&#39;s okay to use this style of
4994     // &quot;analysis&quot; to make iteration faster. If we didn&#39;t want to do this, we would either have
4995     // to perform some flow-sensitive analysis to see if/when the loop iteration variable was
4996     // reassigned, or we&#39;d have to resort to runtime checks to see if the variable had been
4997     // reassigned from its original value.
4998 
4999     for (unsigned offset = bodyBytecodeStartOffset(); isValid() &amp;&amp; offset &lt; bodyBytecodeEndOffset;) {
5000         auto instruction = generator.instructions().at(offset);
5001         OpcodeID opcodeID = instruction-&gt;opcodeID();
5002 
5003         ASSERT(opcodeID != op_enter);
5004         computeDefsForBytecodeOffset(codeBlock, opcodeID, instruction.ptr(), [&amp;] (VirtualRegister operand) {
5005             if (local()-&gt;virtualRegister() == operand)
5006                 invalidate();
5007         });
5008         offset += instruction-&gt;size();
5009     }
5010 }
5011 
5012 void StructureForInContext::finalize(BytecodeGenerator&amp; generator, UnlinkedCodeBlock* codeBlock, unsigned bodyBytecodeEndOffset)
5013 {
5014     Base::finalize(generator, codeBlock, bodyBytecodeEndOffset);
5015     if (isValid())
5016         return;
5017 
5018     OpcodeID lastOpcodeID = generator.m_lastOpcodeID;
5019     InstructionStream::MutableRef lastInstruction = generator.m_lastInstruction;
5020     for (const auto&amp; instTuple : m_getInsts) {
5021         unsigned instIndex = std::get&lt;0&gt;(instTuple);
5022         int propertyRegIndex = std::get&lt;1&gt;(instTuple);
5023         auto instruction = generator.m_writer.ref(instIndex);
5024         auto end = instIndex + instruction-&gt;size();
<span class="line-modified">5025         ASSERT(instruction-&gt;isWide32());</span>
5026 
5027         generator.m_writer.seek(instIndex);
5028 
5029         auto bytecode = instruction-&gt;as&lt;OpGetDirectPname&gt;();
5030 
5031         // disable peephole optimizations
5032         generator.m_lastOpcodeID = op_end;
5033 
5034         // Change the opcode to get_by_val.
5035         // 1. dst stays the same.
5036         // 2. base stays the same.
5037         // 3. property gets switched to the original property.
<span class="line-modified">5038         OpGetByVal::emit&lt;OpcodeSize::Wide32&gt;(&amp;generator, bytecode.m_dst, bytecode.m_base, VirtualRegister(propertyRegIndex));</span>
5039 
5040         // 4. nop out the remaining bytes
5041         while (generator.m_writer.position() &lt; end)
5042             OpNop::emit&lt;OpcodeSize::Narrow&gt;(&amp;generator);
5043     }
5044     generator.m_writer.seek(generator.m_writer.size());
5045     if (generator.m_lastInstruction.offset() + generator.m_lastInstruction-&gt;size() != generator.m_writer.size()) {
5046         generator.m_lastOpcodeID = lastOpcodeID;
5047         generator.m_lastInstruction = lastInstruction;
5048     }
5049 }
5050 
5051 void IndexedForInContext::finalize(BytecodeGenerator&amp; generator, UnlinkedCodeBlock* codeBlock, unsigned bodyBytecodeEndOffset)
5052 {
5053     Base::finalize(generator, codeBlock, bodyBytecodeEndOffset);
5054     if (isValid())
5055         return;
5056 
5057     for (const auto&amp; instPair : m_getInsts) {
5058         unsigned instIndex = instPair.first;
5059         int propertyRegIndex = instPair.second;


5060         generator.m_writer.ref(instIndex)-&gt;cast&lt;OpGetByVal&gt;()-&gt;setProperty(VirtualRegister(propertyRegIndex), []() {
5061             ASSERT_NOT_REACHED();
5062             return VirtualRegister();
5063         });
5064     }
5065 }
5066 
5067 void StaticPropertyAnalysis::record()
5068 {
5069     auto* instruction = m_instructionRef.ptr();
5070     auto size = m_propertyIndexes.size();
5071     switch (instruction-&gt;opcodeID()) {
5072     case OpNewObject::opcodeID:
5073         instruction-&gt;cast&lt;OpNewObject&gt;()-&gt;setInlineCapacity(size, []() {
5074             return 255;
5075         });
5076         return;
5077     case OpCreateThis::opcodeID:
5078         instruction-&gt;cast&lt;OpCreateThis&gt;()-&gt;setInlineCapacity(size, []() {
5079             return 255;
</pre>
</td>
</tr>
</table>
<center><a href="../bytecode/Watchpoint.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="BytecodeGenerator.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>