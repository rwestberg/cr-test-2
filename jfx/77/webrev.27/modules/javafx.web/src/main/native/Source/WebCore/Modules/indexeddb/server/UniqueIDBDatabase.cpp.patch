diff a/modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/server/UniqueIDBDatabase.cpp b/modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/server/UniqueIDBDatabase.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/server/UniqueIDBDatabase.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/server/UniqueIDBDatabase.cpp
@@ -39,23 +39,74 @@
 #include "IDBServer.h"
 #include "IDBTransactionInfo.h"
 #include "IDBValue.h"
 #include "Logging.h"
 #include "SerializedScriptValue.h"
+#include "StorageQuotaManager.h"
 #include "UniqueIDBDatabaseConnection.h"
 #include <JavaScriptCore/AuxiliaryBarrierInlines.h>
-#include <JavaScriptCore/HeapInlines.h>
+#include <JavaScriptCore/JSCInlines.h>
 #include <JavaScriptCore/StrongInlines.h>
-#include <JavaScriptCore/StructureInlines.h>
 #include <wtf/MainThread.h>
 #include <wtf/NeverDestroyed.h>
 #include <wtf/Scope.h>
 
 namespace WebCore {
 using namespace JSC;
 namespace IDBServer {
 
+static const uint64_t defaultWriteOperationCost = 4;
+
+static inline uint64_t estimateSize(const IDBKeyData& keyData)
+{
+    uint64_t size = 4;
+    switch (keyData.type()) {
+    case IndexedDB::KeyType::String:
+        size += keyData.string().sizeInBytes();
+        break;
+    case IndexedDB::KeyType::Binary: {
+        size += keyData.binary().size();
+        break;
+    }
+    case IndexedDB::KeyType::Array:
+        for (auto& data : keyData.array())
+            size += estimateSize(data);
+        break;
+    default:
+        break;
+    }
+    return size;
+}
+
+static inline uint64_t estimateSize(const IDBValue& value)
+{
+    uint64_t size = 4;
+    size += value.data().size();
+    for (auto& url : value.blobURLs())
+        size += url.sizeInBytes();
+    for (auto& path : value.blobFilePaths())
+        size += path.sizeInBytes();
+    return size;
+}
+
+static inline uint64_t estimateSize(const IDBIndexInfo& info)
+{
+    uint64_t size = 4;
+    size += info.name().sizeInBytes();
+    return size;
+}
+
+static inline uint64_t estimateSize(const IDBObjectStoreInfo& info)
+{
+    uint64_t size = 4;
+    size += info.name().sizeInBytes();
+    // FIXME: estimate keyPath.
+    for (auto& indexInfo : info.indexMap().values())
+        size += estimateSize(indexInfo);
+    return size;
+}
+
 UniqueIDBDatabase::UniqueIDBDatabase(IDBServer& server, const IDBDatabaseIdentifier& identifier)
     : m_server(server)
     , m_identifier(identifier)
     , m_operationAndTransactionTimer(*this, &UniqueIDBDatabase::operationAndTransactionTimerFired)
 {
@@ -116,23 +167,76 @@
 #endif
 
     return m_versionChangeDatabaseConnection;
 }
 
+static inline String quotaErrorMessageName(const char* taskName)
+{
+    return makeString("Failed to ", taskName, " in database because not enough space for domain");
+}
+
+void UniqueIDBDatabase::requestSpace(uint64_t taskSize, const char* taskName, CompletionHandler<void(Optional<IDBError>&&)>&& callback)
+{
+    m_server->requestSpace(m_identifier.origin(), taskSize, [weakThis = makeWeakPtr(this), this, taskName, callback = WTFMove(callback)](auto decision) mutable {
+        if (!weakThis) {
+            callback(IDBError { UnknownError });
+            return;
+        }
+
+        if (m_owningPointerForClose) {
+            // We are closing the database, there is no point in trying to modify the database at that point.
+            callback(IDBError { UnknownError });
+            return;
+        }
+
+        switch (decision) {
+        case StorageQuotaManager::Decision::Deny:
+            callback(IDBError { QuotaExceededError, quotaErrorMessageName(taskName) });
+            return;
+        case StorageQuotaManager::Decision::Grant:
+            callback({ });
+        };
+    });
+}
+
+void UniqueIDBDatabase::waitForRequestSpaceCompletion(CompletionHandler<void(Optional<IDBError>&&)>&& callback)
+{
+    requestSpace(0, "", WTFMove(callback));
+}
+
 void UniqueIDBDatabase::performCurrentOpenOperation()
 {
     LOG(IndexedDB, "(main) UniqueIDBDatabase::performCurrentOpenOperation (%p)", this);
 
     ASSERT(m_currentOpenDBRequest);
     ASSERT(m_currentOpenDBRequest->isOpenRequest());
 
     if (!m_databaseInfo) {
         if (!m_isOpeningBackingStore) {
             m_isOpeningBackingStore = true;
-            postDatabaseTask(createCrossThreadTask(*this, &UniqueIDBDatabase::openBackingStore, m_identifier));
+            // We do not know whether this is an existing or a new database.
+            // We set a small cost so that it is not possible to open an infinite number of database.
+            m_server->requestSpace(m_identifier.origin(), defaultWriteOperationCost, [this, weakThis = makeWeakPtr(this)](auto decision) mutable {
+                if (!weakThis)
+                    return;
+
+                if (m_owningPointerForClose)
+                    return;
+
+                switch (decision) {
+                case StorageQuotaManager::Decision::Deny: {
+                    auto result = IDBResultData::error(m_currentOpenDBRequest->requestData().requestIdentifier(), IDBError { QuotaExceededError, quotaErrorMessageName("openDatabase") });
+                    m_currentOpenDBRequest->connection().didOpenDatabase(result);
+                    m_currentOpenDBRequest = nullptr;
+                    m_isOpeningBackingStore = false;
+                    break;
+                }
+                case StorageQuotaManager::Decision::Grant:
+                    this->postDatabaseTask(createCrossThreadTask(*this, &UniqueIDBDatabase::openBackingStore, m_identifier));
+                };
+            });
         }
-
         return;
     }
 
     // If we previously started a version change operation but were blocked by having open connections,
     // we might now be unblocked.
@@ -238,23 +342,27 @@
 
     uint64_t deletedVersion = 0;
 
     if (m_backingStore) {
         m_backingStore->deleteBackingStore();
+        m_newDatabaseSize = m_backingStore->databaseSize();
+
         m_backingStore = nullptr;
         m_backingStoreSupportsSimultaneousTransactions = false;
         m_backingStoreIsEphemeral = false;
     } else {
-        auto backingStore = m_server.createBackingStore(identifier);
+        auto backingStore = m_server->createBackingStore(identifier);
+        m_currentDatabaseSize = backingStore->databaseSize();
 
         IDBDatabaseInfo databaseInfo;
         auto error = backingStore->getOrEstablishDatabaseInfo(databaseInfo);
         if (!error.isNull())
             LOG_ERROR("Error getting database info from database %s that we are trying to delete", identifier.debugString().utf8().data());
 
         deletedVersion = databaseInfo.version();
         backingStore->deleteBackingStore();
+        m_newDatabaseSize = backingStore->databaseSize();
     }
 
     postDatabaseTaskReply(createCrossThreadTask(*this, &UniqueIDBDatabase::didDeleteBackingStore, deletedVersion));
 }
 
@@ -274,11 +382,11 @@
     ASSERT(isMainThread());
 
     m_operationAndTransactionTimer.stop();
 
     RELEASE_ASSERT(!m_owningPointerForClose);
-    m_owningPointerForClose = m_server.closeAndTakeUniqueIDBDatabase(*this);
+    m_owningPointerForClose = m_server->closeAndTakeUniqueIDBDatabase(*this);
 
     postDatabaseTask(createCrossThreadTask(*this, &UniqueIDBDatabase::shutdownForClose));
 }
 
 void UniqueIDBDatabase::shutdownForClose()
@@ -286,10 +394,15 @@
     ASSERT(!isMainThread());
     ASSERT(m_owningPointerForClose.get() == this);
 
     LOG(IndexedDB, "(db) UniqueIDBDatabase::shutdownForClose");
 
+    if (m_backingStore) {
+        m_backingStore->close();
+        m_newDatabaseSize = m_backingStore->databaseSize();
+    }
+
     m_backingStore = nullptr;
     m_backingStoreSupportsSimultaneousTransactions = false;
     m_backingStoreIsEphemeral = false;
 
     if (!m_databaseQueue.isEmpty()) {
@@ -303,10 +416,12 @@
 
 void UniqueIDBDatabase::didShutdownForClose()
 {
     ASSERT(m_databaseReplyQueue.isEmpty());
     m_databaseReplyQueue.kill();
+
+    updateSpaceUsedIfNeeded();
 }
 
 void UniqueIDBDatabase::didDeleteBackingStore(uint64_t deletedVersion)
 {
     ASSERT(isMainThread());
@@ -327,17 +442,19 @@
 
     // If this UniqueIDBDatabase was brought into existence for the purpose of deleting the file on disk,
     // we won't have a m_mostRecentDeletedDatabaseInfo. In that case, we'll manufacture one using the
     // passed in deletedVersion argument.
     if (!m_mostRecentDeletedDatabaseInfo)
-        m_mostRecentDeletedDatabaseInfo = std::make_unique<IDBDatabaseInfo>(m_identifier.databaseName(), deletedVersion);
+        m_mostRecentDeletedDatabaseInfo = makeUnique<IDBDatabaseInfo>(m_identifier.databaseName(), deletedVersion);
 
     if (m_currentOpenDBRequest) {
         m_currentOpenDBRequest->notifyDidDeleteDatabase(*m_mostRecentDeletedDatabaseInfo);
         m_currentOpenDBRequest = nullptr;
     }
 
+    updateSpaceUsedIfNeeded();
+
     m_deleteBackingStoreInProgress = false;
 
     if (m_hardClosedForUserDelete)
         return;
 
@@ -354,11 +471,11 @@
 {
     ASSERT(isMainThread());
     LOG(IndexedDB, "(main) UniqueIDBDatabase::handleDatabaseOperations - There are %u pending", m_pendingOpenDBRequests.size());
     ASSERT(!m_hardClosedForUserDelete);
 
-    if (m_deleteBackingStoreInProgress)
+    if (m_deleteBackingStoreInProgress || m_isOpeningBackingStore)
         return;
 
     clearStalePendingOpenDBRequests();
 
     if (m_versionChangeDatabaseConnection || m_versionChangeTransaction || (m_currentOpenDBRequest && !m_currentOpenDBRequest->connection().isClosed())) {
@@ -421,34 +538,46 @@
     ASSERT(isMainThread());
     static uint64_t currentID = 0;
     return ++currentID;
 }
 
-uint64_t UniqueIDBDatabase::storeCallbackOrFireError(ErrorCallback&& callback)
+uint64_t UniqueIDBDatabase::storeCallbackOrFireError(ErrorCallback&& callback, uint64_t taskSize)
 {
     if (m_hardClosedForUserDelete) {
         callback(IDBError::userDeleteError());
         return 0;
     }
 
     uint64_t identifier = generateUniqueCallbackIdentifier();
     ASSERT(!m_errorCallbacks.contains(identifier));
     m_errorCallbacks.add(identifier, WTFMove(callback));
+
+    if (taskSize) {
+        m_server->increasePotentialSpaceUsed(m_identifier.origin(), taskSize);
+        m_pendingSpaceIncreasingTasks.add(identifier, taskSize);
+    }
+
     m_callbackQueue.append(identifier);
     return identifier;
 }
 
-uint64_t UniqueIDBDatabase::storeCallbackOrFireError(KeyDataCallback&& callback)
+uint64_t UniqueIDBDatabase::storeCallbackOrFireError(KeyDataCallback&& callback, uint64_t taskSize)
 {
     if (m_hardClosedForUserDelete) {
         callback(IDBError::userDeleteError(), { });
         return 0;
     }
 
     uint64_t identifier = generateUniqueCallbackIdentifier();
     ASSERT(!m_keyDataCallbacks.contains(identifier));
     m_keyDataCallbacks.add(identifier, WTFMove(callback));
+
+    if (taskSize) {
+        m_server->increasePotentialSpaceUsed(m_identifier.origin(), taskSize);
+        m_pendingSpaceIncreasingTasks.add(identifier, taskSize);
+    }
+
     m_callbackQueue.append(identifier);
     return identifier;
 }
 
 uint64_t UniqueIDBDatabase::storeCallbackOrFireError(GetResultCallback&& callback)
@@ -509,32 +638,53 @@
     ASSERT(!m_versionChangeTransaction);
     ASSERT(m_currentOpenDBRequest);
     ASSERT(m_currentOpenDBRequest->isOpenRequest());
     ASSERT(m_versionChangeDatabaseConnection);
 
-    auto operation = WTFMove(m_currentOpenDBRequest);
-
-    uint64_t requestedVersion = operation->requestData().requestedVersion();
+    uint64_t requestedVersion = m_currentOpenDBRequest->requestData().requestedVersion();
     if (!requestedVersion)
         requestedVersion = m_databaseInfo->version() ? m_databaseInfo->version() : 1;
 
-    addOpenDatabaseConnection(*m_versionChangeDatabaseConnection);
-
     m_versionChangeTransaction = &m_versionChangeDatabaseConnection->createVersionChangeTransaction(requestedVersion);
-    m_databaseInfo->setVersion(requestedVersion);
-
     m_inProgressTransactions.set(m_versionChangeTransaction->info().identifier(), m_versionChangeTransaction);
-    postDatabaseTask(createCrossThreadTask(*this, &UniqueIDBDatabase::beginTransactionInBackingStore, m_versionChangeTransaction->info()));
 
-    auto result = IDBResultData::openDatabaseUpgradeNeeded(operation->requestData().requestIdentifier(), *m_versionChangeTransaction);
-    operation->connection().didOpenDatabase(result);
+    postDatabaseTask(createCrossThreadTask(*this, &UniqueIDBDatabase::performStartVersionChangeTransaction, m_versionChangeTransaction->info()));
 }
 
-void UniqueIDBDatabase::beginTransactionInBackingStore(const IDBTransactionInfo& info)
+void UniqueIDBDatabase::performStartVersionChangeTransaction(const IDBTransactionInfo& info)
 {
-    LOG(IndexedDB, "(db) UniqueIDBDatabase::beginTransactionInBackingStore");
-    m_backingStore->beginTransaction(info);
+    LOG(IndexedDB, "(db) UniqueIDBDatabase::performStartVersionChangeTransaction");
+
+    IDBError error = m_backingStore->beginTransaction(info);
+    postDatabaseTaskReply(createCrossThreadTask(*this, &UniqueIDBDatabase::didPerformStartVersionChangeTransaction, error));
+}
+
+void UniqueIDBDatabase::didPerformStartVersionChangeTransaction(const IDBError& error)
+{
+    LOG(IndexedDB, "(main) UniqueIDBDatabase::didPerformStartVersionChangeTransaction");
+
+    // Open request may already be canceled by client or user, or connection to client is lost.
+    if (!m_versionChangeDatabaseConnection)
+        return;
+
+    ASSERT(m_currentOpenDBRequest);
+    ASSERT(m_versionChangeTransaction);
+    auto operation = WTFMove(m_currentOpenDBRequest);
+    IDBResultData result;
+    if (error.isNull()) {
+        addOpenDatabaseConnection(*m_versionChangeDatabaseConnection);
+        m_databaseInfo->setVersion(m_versionChangeTransaction->info().newVersion());
+        result = IDBResultData::openDatabaseUpgradeNeeded(operation->requestData().requestIdentifier(), *m_versionChangeTransaction);
+        operation->connection().didOpenDatabase(result);
+    } else {
+        m_versionChangeDatabaseConnection->abortTransactionWithoutCallback(*m_versionChangeTransaction);
+        m_versionChangeDatabaseConnection = nullptr;
+        result = IDBResultData::error(operation->requestData().requestIdentifier(), error);
+        operation->connection().didOpenDatabase(result);
+    }
+
+    invokeOperationAndTransactionTimer();
 }
 
 void UniqueIDBDatabase::maybeNotifyConnectionsOfVersionChange()
 {
     ASSERT(m_currentOpenDBRequest);
@@ -630,14 +780,18 @@
 {
     ASSERT(!isMainThread());
     LOG(IndexedDB, "(db) UniqueIDBDatabase::openBackingStore (%p)", this);
 
     ASSERT(!m_backingStore);
-    m_backingStore = m_server.createBackingStore(identifier);
+    m_backingStore = m_server->createBackingStore(identifier);
     m_backingStoreSupportsSimultaneousTransactions = m_backingStore->supportsSimultaneousTransactions();
     m_backingStoreIsEphemeral = m_backingStore->isEphemeral();
 
+    // QuotaUser should have initiliazed storage usage, which contains the
+    // size of this database.
+    m_currentDatabaseSize = m_backingStore->databaseSize();
+
     IDBDatabaseInfo databaseInfo;
     auto error = m_backingStore->getOrEstablishDatabaseInfo(databaseInfo);
 
     postDatabaseTaskReply(createCrossThreadTask(*this, &UniqueIDBDatabase::didOpenBackingStore, databaseInfo, error));
 }
@@ -645,16 +799,18 @@
 void UniqueIDBDatabase::didOpenBackingStore(const IDBDatabaseInfo& info, const IDBError& error)
 {
     ASSERT(isMainThread());
     LOG(IndexedDB, "(main) UniqueIDBDatabase::didOpenBackingStore");
 
-    m_databaseInfo = std::make_unique<IDBDatabaseInfo>(info);
+    m_databaseInfo = makeUnique<IDBDatabaseInfo>(info);
     m_backingStoreOpenError = error;
 
     ASSERT(m_isOpeningBackingStore);
     m_isOpeningBackingStore = false;
 
+    updateSpaceUsedIfNeeded();
+
     if (m_hardClosedForUserDelete)
         return;
 
     handleDatabaseOperations();
 }
@@ -662,11 +818,27 @@
 void UniqueIDBDatabase::createObjectStore(UniqueIDBDatabaseTransaction& transaction, const IDBObjectStoreInfo& info, ErrorCallback callback)
 {
     ASSERT(isMainThread());
     LOG(IndexedDB, "(main) UniqueIDBDatabase::createObjectStore");
 
-    uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));
+    auto taskSize = defaultWriteOperationCost + estimateSize(info);
+    requestSpace(taskSize, "createObjectStore", [this, taskSize, transaction = makeWeakPtr(transaction), info, callback = WTFMove(callback)](auto error) mutable {
+        if (error) {
+            callback(WTFMove(*error));
+            return;
+        }
+        if (!transaction) {
+            callback(IDBError { UnknownError });
+            return;
+        }
+        this->createObjectStoreAfterQuotaCheck(taskSize, *transaction, info, WTFMove(callback));
+    });
+}
+
+void UniqueIDBDatabase::createObjectStoreAfterQuotaCheck(uint64_t taskSize, UniqueIDBDatabaseTransaction& transaction, const IDBObjectStoreInfo& info, ErrorCallback callback)
+{
+    uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback), taskSize);
     if (!callbackID)
         return;
 
     postDatabaseTask(createCrossThreadTask(*this, &UniqueIDBDatabase::performCreateObjectStore, callbackID, transaction.info().identifier(), info));
 }
@@ -697,10 +869,25 @@
 void UniqueIDBDatabase::deleteObjectStore(UniqueIDBDatabaseTransaction& transaction, const String& objectStoreName, ErrorCallback callback)
 {
     ASSERT(isMainThread());
     LOG(IndexedDB, "(main) UniqueIDBDatabase::deleteObjectStore");
 
+    waitForRequestSpaceCompletion([this, transaction = makeWeakPtr(transaction), objectStoreName, callback = WTFMove(callback)](auto error) mutable {
+        if (error) {
+            callback(WTFMove(*error));
+            return;
+        }
+        if (!transaction) {
+            callback(IDBError { UnknownError });
+            return;
+        }
+        this->deleteObjectStoreAfterQuotaCheck(*transaction, objectStoreName, WTFMove(callback));
+    });
+}
+
+void UniqueIDBDatabase::deleteObjectStoreAfterQuotaCheck(UniqueIDBDatabaseTransaction& transaction, const String& objectStoreName, ErrorCallback callback)
+{
     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));
     if (!callbackID)
         return;
 
     auto* info = m_databaseInfo->infoForExistingObjectStore(objectStoreName);
@@ -738,11 +925,27 @@
 void UniqueIDBDatabase::renameObjectStore(UniqueIDBDatabaseTransaction& transaction, uint64_t objectStoreIdentifier, const String& newName, ErrorCallback callback)
 {
     ASSERT(isMainThread());
     LOG(IndexedDB, "(main) UniqueIDBDatabase::renameObjectStore");
 
-    uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));
+    auto taskSize = defaultWriteOperationCost + newName.sizeInBytes();
+    requestSpace(taskSize, "renameObjectStore", [this, taskSize, transaction = makeWeakPtr(transaction), objectStoreIdentifier, newName, callback = WTFMove(callback)](auto error) mutable {
+        if (error) {
+            callback(WTFMove(*error));
+            return;
+        }
+        if (!transaction) {
+            callback(IDBError { UnknownError });
+            return;
+        }
+        this->renameObjectStoreAfterQuotaCheck(taskSize, *transaction, objectStoreIdentifier, newName, WTFMove(callback));
+    });
+}
+
+void UniqueIDBDatabase::renameObjectStoreAfterQuotaCheck(uint64_t taskSize, UniqueIDBDatabaseTransaction& transaction, uint64_t objectStoreIdentifier, const String& newName, ErrorCallback callback)
+{
+    uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback), taskSize);
     if (!callbackID)
         return;
 
     auto* info = m_databaseInfo->infoForExistingObjectStore(objectStoreIdentifier);
     if (!info) {
@@ -779,10 +982,25 @@
 void UniqueIDBDatabase::clearObjectStore(UniqueIDBDatabaseTransaction& transaction, uint64_t objectStoreIdentifier, ErrorCallback callback)
 {
     ASSERT(isMainThread());
     LOG(IndexedDB, "(main) UniqueIDBDatabase::clearObjectStore");
 
+    waitForRequestSpaceCompletion([this, transaction = makeWeakPtr(transaction), objectStoreIdentifier, callback = WTFMove(callback)](auto error) mutable {
+        if (error) {
+            callback(WTFMove(*error));
+            return;
+        }
+        if (!transaction) {
+            callback(IDBError { UnknownError });
+            return;
+        }
+        this->clearObjectStoreAfetQuotaCheck(*transaction, objectStoreIdentifier, WTFMove(callback));
+    });
+}
+
+void UniqueIDBDatabase::clearObjectStoreAfetQuotaCheck(UniqueIDBDatabaseTransaction& transaction, uint64_t objectStoreIdentifier, ErrorCallback callback)
+{
     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));
     if (!callbackID)
         return;
     postDatabaseTask(createCrossThreadTask(*this, &UniqueIDBDatabase::performClearObjectStore, callbackID, transaction.info().identifier(), objectStoreIdentifier));
 }
@@ -810,24 +1028,47 @@
 void UniqueIDBDatabase::createIndex(UniqueIDBDatabaseTransaction& transaction, const IDBIndexInfo& info, ErrorCallback callback)
 {
     ASSERT(isMainThread());
     LOG(IndexedDB, "(main) UniqueIDBDatabase::createIndex");
 
-    uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));
+    auto taskSize = defaultWriteOperationCost + estimateSize(info);
+    requestSpace(taskSize, "createIndex", [this, taskSize, transaction = makeWeakPtr(transaction), info, callback = WTFMove(callback)](auto error) mutable {
+        if (error) {
+            callback(WTFMove(*error));
+            return;
+        }
+        if (!transaction) {
+            callback(IDBError { UnknownError });
+            return;
+        }
+        this->createIndexAfterQuotaCheck(taskSize, *transaction, info, WTFMove(callback));
+    });
+}
+
+void UniqueIDBDatabase::createIndexAfterQuotaCheck(uint64_t taskSize, UniqueIDBDatabaseTransaction& transaction, const IDBIndexInfo& info, ErrorCallback callback)
+{
+    uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback), taskSize);
     if (!callbackID)
         return;
     postDatabaseTask(createCrossThreadTask(*this, &UniqueIDBDatabase::performCreateIndex, callbackID, transaction.info().identifier(), info));
 }
 
 void UniqueIDBDatabase::performCreateIndex(uint64_t callbackIdentifier, const IDBResourceIdentifier& transactionIdentifier, const IDBIndexInfo& info)
 {
     ASSERT(!isMainThread());
     LOG(IndexedDB, "(db) UniqueIDBDatabase::performCreateIndex");
 
+    IDBError error;
     ASSERT(m_backingStore);
-    IDBError error = m_backingStore->createIndex(transactionIdentifier, info);
+    if (!m_backingStore) {
+        RELEASE_LOG_ERROR(IndexedDB, "%p - UniqueIDBDatabase::performCreateIndex: m_backingStore is null", this);
+        error = IDBError(InvalidStateError, "Backing store is invalid for call to create index"_s);
+        postDatabaseTaskReply(createCrossThreadTask(*this, &UniqueIDBDatabase::didPerformCreateIndex, callbackIdentifier, error, info));
+        return;
+    }
 
+    error = m_backingStore->createIndex(transactionIdentifier, info);
     postDatabaseTaskReply(createCrossThreadTask(*this, &UniqueIDBDatabase::didPerformCreateIndex, callbackIdentifier, error, info));
 }
 
 void UniqueIDBDatabase::didPerformCreateIndex(uint64_t callbackIdentifier, const IDBError& error, const IDBIndexInfo& info)
 {
@@ -847,10 +1088,25 @@
 void UniqueIDBDatabase::deleteIndex(UniqueIDBDatabaseTransaction& transaction, uint64_t objectStoreIdentifier, const String& indexName, ErrorCallback callback)
 {
     ASSERT(isMainThread());
     LOG(IndexedDB, "(main) UniqueIDBDatabase::deleteIndex");
 
+    waitForRequestSpaceCompletion([this, transaction = makeWeakPtr(transaction), objectStoreIdentifier, indexName, callback = WTFMove(callback)](auto error) mutable {
+        if (error) {
+            callback(WTFMove(*error));
+            return;
+        }
+        if (!transaction) {
+            callback(IDBError { UnknownError });
+            return;
+        }
+        this->deleteIndexAfterQuotaCheck(*transaction, objectStoreIdentifier, indexName, WTFMove(callback));
+    });
+}
+
+void UniqueIDBDatabase::deleteIndexAfterQuotaCheck(UniqueIDBDatabaseTransaction& transaction, uint64_t objectStoreIdentifier, const String& indexName, ErrorCallback callback)
+{
     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));
     if (!callbackID)
         return;
 
     auto* objectStoreInfo = m_databaseInfo->infoForExistingObjectStore(objectStoreIdentifier);
@@ -897,11 +1153,27 @@
 void UniqueIDBDatabase::renameIndex(UniqueIDBDatabaseTransaction& transaction, uint64_t objectStoreIdentifier, uint64_t indexIdentifier, const String& newName, ErrorCallback callback)
 {
     ASSERT(isMainThread());
     LOG(IndexedDB, "(main) UniqueIDBDatabase::renameIndex");
 
-    uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));
+    auto taskSize = defaultWriteOperationCost + newName.sizeInBytes();
+    requestSpace(taskSize, "renameIndex", [this, taskSize, transaction = makeWeakPtr(transaction), objectStoreIdentifier, indexIdentifier, newName, callback = WTFMove(callback)](auto error) mutable {
+        if (error) {
+            callback(WTFMove(*error));
+            return;
+        }
+        if (!transaction) {
+            callback(IDBError { UnknownError });
+            return;
+        }
+        this->renameIndexAfterQuotaCheck(taskSize, *transaction, objectStoreIdentifier, indexIdentifier, newName, WTFMove(callback));
+    });
+}
+
+void UniqueIDBDatabase::renameIndexAfterQuotaCheck(uint64_t taskSize, UniqueIDBDatabaseTransaction& transaction, uint64_t objectStoreIdentifier, uint64_t indexIdentifier, const String& newName, ErrorCallback callback)
+{
+    uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback), taskSize);
     if (!callbackID)
         return;
 
     auto* objectStoreInfo = m_databaseInfo->infoForExistingObjectStore(objectStoreIdentifier);
     if (!objectStoreInfo) {
@@ -951,31 +1223,26 @@
 void UniqueIDBDatabase::putOrAdd(const IDBRequestData& requestData, const IDBKeyData& keyData, const IDBValue& value, IndexedDB::ObjectStoreOverwriteMode overwriteMode, KeyDataCallback callback)
 {
     ASSERT(isMainThread());
     LOG(IndexedDB, "(main) UniqueIDBDatabase::putOrAdd");
 
-    uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));
-    if (!callbackID)
-        return;
-    postDatabaseTask(createCrossThreadTask(*this, &UniqueIDBDatabase::performPutOrAdd, callbackID, requestData.transactionIdentifier(), requestData.objectStoreIdentifier(), keyData, value, overwriteMode));
-}
-
-VM& UniqueIDBDatabase::databaseThreadVM()
-{
-    ASSERT(!isMainThread());
-    static VM* vm = &VM::create().leakRef();
-    return *vm;
+    auto taskSize = defaultWriteOperationCost + estimateSize(keyData) + estimateSize(value);
+    requestSpace(taskSize, "putOrAdd", [this, taskSize, requestData, keyData, value, callback = WTFMove(callback), overwriteMode](auto error) mutable {
+        if (error) {
+            callback(WTFMove(*error), { });
+            return;
+        }
+        this->putOrAddAfterQuotaCheck(taskSize, requestData, keyData, value, overwriteMode, WTFMove(callback));
+    });
 }
 
-ExecState& UniqueIDBDatabase::databaseThreadExecState()
+void UniqueIDBDatabase::putOrAddAfterQuotaCheck(uint64_t taskSize, const IDBRequestData& requestData, const IDBKeyData& keyData, const IDBValue& value, IndexedDB::ObjectStoreOverwriteMode overwriteMode, KeyDataCallback callback)
 {
-    ASSERT(!isMainThread());
-
-    static NeverDestroyed<Strong<JSGlobalObject>> globalObject(databaseThreadVM(), JSGlobalObject::create(databaseThreadVM(), JSGlobalObject::createStructure(databaseThreadVM(), jsNull())));
-
-    RELEASE_ASSERT(globalObject.get()->globalExec());
-    return *globalObject.get()->globalExec();
+    uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback), taskSize);
+    if (!callbackID)
+        return;
+    postDatabaseTask(createCrossThreadTask(*this, &UniqueIDBDatabase::performPutOrAdd, callbackID, requestData.transactionIdentifier(), requestData.objectStoreIdentifier(), keyData, value, overwriteMode));
 }
 
 void UniqueIDBDatabase::performPutOrAdd(uint64_t callbackIdentifier, const IDBResourceIdentifier& transactionIdentifier, uint64_t objectStoreIdentifier, const IDBKeyData& keyData, const IDBValue& originalRecordValue, IndexedDB::ObjectStoreOverwriteMode overwriteMode)
 {
     ASSERT(!isMainThread());
@@ -985,10 +1252,17 @@
     ASSERT(objectStoreIdentifier);
 
     IDBKeyData usedKey;
     IDBError error;
 
+    if (!m_backingStore) {
+        RELEASE_LOG_ERROR(IndexedDB, "%p - UniqueIDBDatabase::performPutOrAdd: m_backingStore is null", this);
+        error = IDBError(InvalidStateError, "Backing store is invalid for call to put or add"_s);
+        postDatabaseTaskReply(createCrossThreadTask(*this, &UniqueIDBDatabase::didPerformPutOrAdd, callbackIdentifier, error, usedKey));
+        return;
+    }
+
     auto* objectStoreInfo = m_backingStore->infoForObjectStore(objectStoreIdentifier);
     if (!objectStoreInfo) {
         error = IDBError(InvalidStateError, "Object store cannot be found in the backing store"_s);
         postDatabaseTaskReply(createCrossThreadTask(*this, &UniqueIDBDatabase::didPerformPutOrAdd, callbackIdentifier, error, usedKey));
         return;
@@ -1022,53 +1296,21 @@
             postDatabaseTaskReply(createCrossThreadTask(*this, &UniqueIDBDatabase::didPerformPutOrAdd, callbackIdentifier, error, usedKey));
             return;
         }
     }
 
-    // 3.4.1.2 Object Store Storage Operation
-    // If ObjectStore has a key path and the key is autogenerated, then inject the key into the value
-    // using steps to assign a key to a value using a key path.
-    ThreadSafeDataBuffer injectedRecordValue;
-    if (usedKeyIsGenerated && objectStoreInfo->keyPath()) {
-        VM& vm = databaseThreadVM();
-        JSLockHolder locker(vm);
-        auto scope = DECLARE_THROW_SCOPE(vm);
-
-        auto value = deserializeIDBValueToJSValue(databaseThreadExecState(), originalRecordValue.data());
-        if (value.isUndefined()) {
-            postDatabaseTaskReply(createCrossThreadTask(*this, &UniqueIDBDatabase::didPerformPutOrAdd, callbackIdentifier, IDBError(ConstraintError, "Unable to deserialize record value for record key injection"_s), usedKey));
-            return;
-        }
-
-        if (!injectIDBKeyIntoScriptValue(databaseThreadExecState(), usedKey, value, objectStoreInfo->keyPath().value())) {
-            postDatabaseTaskReply(createCrossThreadTask(*this, &UniqueIDBDatabase::didPerformPutOrAdd, callbackIdentifier, IDBError(ConstraintError, "Unable to inject record key into record value"_s), usedKey));
-            return;
-        }
-
-        auto serializedValue = SerializedScriptValue::create(databaseThreadExecState(), value);
-        if (UNLIKELY(scope.exception())) {
-            postDatabaseTaskReply(createCrossThreadTask(*this, &UniqueIDBDatabase::didPerformPutOrAdd, callbackIdentifier, IDBError(ConstraintError, "Unable to serialize record value after injecting record key"_s), usedKey));
-            return;
-        }
-
-        injectedRecordValue = ThreadSafeDataBuffer::copyVector(serializedValue->data());
-    }
-
     // 3.4.1 Object Store Storage Operation
     // ...If a record already exists in store ...
     // then remove the record from store using the steps for deleting records from an object store...
     // This is important because formally deleting it from from the object store also removes it from the appropriate indexes.
     error = m_backingStore->deleteRange(transactionIdentifier, objectStoreIdentifier, usedKey);
     if (!error.isNull()) {
         postDatabaseTaskReply(createCrossThreadTask(*this, &UniqueIDBDatabase::didPerformPutOrAdd, callbackIdentifier, error, usedKey));
         return;
     }
 
-    if (injectedRecordValue.data())
-        error = m_backingStore->addRecord(transactionIdentifier, *objectStoreInfo, usedKey, { injectedRecordValue, originalRecordValue.blobURLs(), originalRecordValue.sessionID(), originalRecordValue.blobFilePaths() });
-    else
-        error = m_backingStore->addRecord(transactionIdentifier, *objectStoreInfo, usedKey, originalRecordValue);
+    error = m_backingStore->addRecord(transactionIdentifier, *objectStoreInfo, usedKey, originalRecordValue);
 
     if (!error.isNull()) {
         postDatabaseTaskReply(createCrossThreadTask(*this, &UniqueIDBDatabase::didPerformPutOrAdd, callbackIdentifier, error, usedKey));
         return;
     }
@@ -1091,10 +1333,21 @@
 void UniqueIDBDatabase::getRecord(const IDBRequestData& requestData, const IDBGetRecordData& getRecordData, GetResultCallback callback)
 {
     ASSERT(isMainThread());
     LOG(IndexedDB, "(main) UniqueIDBDatabase::getRecord");
 
+    waitForRequestSpaceCompletion([this, requestData, getRecordData, callback = WTFMove(callback)](auto error) mutable {
+        if (error) {
+            callback(WTFMove(*error), { });
+            return;
+        }
+        this->getRecordAfterQuotaCheck(requestData, getRecordData, WTFMove(callback));
+    });
+}
+
+void UniqueIDBDatabase::getRecordAfterQuotaCheck(const IDBRequestData& requestData, const IDBGetRecordData& getRecordData, GetResultCallback callback)
+{
     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));
     if (!callbackID)
         return;
 
     if (uint64_t indexIdentifier = requestData.indexIdentifier())
@@ -1106,10 +1359,21 @@
 void UniqueIDBDatabase::getAllRecords(const IDBRequestData& requestData, const IDBGetAllRecordsData& getAllRecordsData, GetAllResultsCallback callback)
 {
     ASSERT(isMainThread());
     LOG(IndexedDB, "(main) UniqueIDBDatabase::getAllRecords");
 
+    waitForRequestSpaceCompletion([this, requestData, getAllRecordsData, callback = WTFMove(callback)](auto error) mutable {
+        if (error) {
+            callback(WTFMove(*error), { });
+            return;
+        }
+        this->getAllRecordsAfterQuotaCheck(requestData, getAllRecordsData, WTFMove(callback));
+    });
+}
+
+void UniqueIDBDatabase::getAllRecordsAfterQuotaCheck(const IDBRequestData& requestData, const IDBGetAllRecordsData& getAllRecordsData, GetAllResultsCallback callback)
+{
     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));
     if (!callbackID)
         return;
 
     postDatabaseTask(createCrossThreadTask(*this, &UniqueIDBDatabase::performGetAllRecords, callbackID, requestData.transactionIdentifier(), getAllRecordsData));
@@ -1173,10 +1437,21 @@
 void UniqueIDBDatabase::getCount(const IDBRequestData& requestData, const IDBKeyRangeData& range, CountCallback callback)
 {
     ASSERT(isMainThread());
     LOG(IndexedDB, "(main) UniqueIDBDatabase::getCount");
 
+    waitForRequestSpaceCompletion([this, requestData, range, callback = WTFMove(callback)](auto error) mutable {
+        if (error) {
+            callback(WTFMove(*error), { });
+            return;
+        }
+        this->getCountAfterQuotaCheck(requestData, range, WTFMove(callback));
+    });
+}
+
+void UniqueIDBDatabase::getCountAfterQuotaCheck(const IDBRequestData& requestData, const IDBKeyRangeData& range, CountCallback callback)
+{
     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));
     if (!callbackID)
         return;
     postDatabaseTask(createCrossThreadTask(*this, &UniqueIDBDatabase::performGetCount, callbackID, requestData.transactionIdentifier(), requestData.objectStoreIdentifier(), requestData.indexIdentifier(), range));
 }
@@ -1206,10 +1481,21 @@
 void UniqueIDBDatabase::deleteRecord(const IDBRequestData& requestData, const IDBKeyRangeData& keyRangeData, ErrorCallback callback)
 {
     ASSERT(isMainThread());
     LOG(IndexedDB, "(main) UniqueIDBDatabase::deleteRecord");
 
+    waitForRequestSpaceCompletion([this, requestData, keyRangeData, callback = WTFMove(callback)](auto error) mutable {
+        if (error) {
+            callback(WTFMove(*error));
+            return;
+        }
+        this->deleteRecordAfterQuotaCheck(requestData, keyRangeData, WTFMove(callback));
+    });
+}
+
+void UniqueIDBDatabase::deleteRecordAfterQuotaCheck(const IDBRequestData& requestData, const IDBKeyRangeData& keyRangeData, ErrorCallback callback)
+{
     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));
     if (!callbackID)
         return;
     postDatabaseTask(createCrossThreadTask(*this, &UniqueIDBDatabase::performDeleteRecord, callbackID, requestData.transactionIdentifier(), requestData.objectStoreIdentifier(), keyRangeData));
 }
@@ -1235,10 +1521,21 @@
 void UniqueIDBDatabase::openCursor(const IDBRequestData& requestData, const IDBCursorInfo& info, GetResultCallback callback)
 {
     ASSERT(isMainThread());
     LOG(IndexedDB, "(main) UniqueIDBDatabase::openCursor");
 
+    waitForRequestSpaceCompletion([this, requestData, info, callback = WTFMove(callback)](auto error) mutable {
+        if (error) {
+            callback(WTFMove(*error), { });
+            return;
+        }
+        this->openCursorAfterQuotaCheck(requestData, info, WTFMove(callback));
+    });
+}
+
+void UniqueIDBDatabase::openCursorAfterQuotaCheck(const IDBRequestData& requestData, const IDBCursorInfo& info, GetResultCallback callback)
+{
     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));
     if (!callbackID)
         return;
     postDatabaseTask(createCrossThreadTask(*this, &UniqueIDBDatabase::performOpenCursor, callbackID, requestData.transactionIdentifier(), info));
 }
@@ -1265,10 +1562,21 @@
 void UniqueIDBDatabase::iterateCursor(const IDBRequestData& requestData, const IDBIterateCursorData& data, GetResultCallback callback)
 {
     ASSERT(isMainThread());
     LOG(IndexedDB, "(main) UniqueIDBDatabase::iterateCursor");
 
+    waitForRequestSpaceCompletion([this, requestData, data, callback = WTFMove(callback)](auto error) mutable {
+        if (error) {
+            callback(WTFMove(*error), { });
+            return;
+        }
+        this->iterateCursorAfterQuotaCheck(requestData, data, WTFMove(callback));
+    });
+}
+
+void UniqueIDBDatabase::iterateCursorAfterQuotaCheck(const IDBRequestData& requestData, const IDBIterateCursorData& data, GetResultCallback callback)
+{
     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));
     if (!callbackID)
         return;
     postDatabaseTask(createCrossThreadTask(*this, &UniqueIDBDatabase::performIterateCursor, callbackID, requestData.transactionIdentifier(), requestData.cursorIdentifier(), data));
 }
@@ -1308,17 +1616,18 @@
     LOG(IndexedDB, "(main) UniqueIDBDatabase::didPerformIterateCursor");
 
     performGetResultCallback(callbackIdentifier, error, result);
 }
 
-bool UniqueIDBDatabase::prepareToFinishTransaction(UniqueIDBDatabaseTransaction& transaction)
+bool UniqueIDBDatabase::prepareToFinishTransaction(UniqueIDBDatabaseTransaction& transaction, UniqueIDBDatabaseTransaction::State state)
 {
     auto takenTransaction = m_inProgressTransactions.take(transaction.info().identifier());
     if (!takenTransaction)
         return false;
 
     ASSERT(!m_finishingTransactions.contains(transaction.info().identifier()));
+    takenTransaction->setState(state);
     m_finishingTransactions.set(transaction.info().identifier(), WTFMove(takenTransaction));
 
     return true;
 }
 
@@ -1327,15 +1636,30 @@
     ASSERT(isMainThread());
     LOG(IndexedDB, "(main) UniqueIDBDatabase::commitTransaction - %s", transaction.info().identifier().loggingString().utf8().data());
 
     ASSERT(transaction.databaseConnection().database() == this);
 
+    waitForRequestSpaceCompletion([this, transaction = makeWeakPtr(transaction), callback = WTFMove(callback)](auto error) mutable {
+        if (error) {
+            callback(WTFMove(*error));
+            return;
+        }
+        if (!transaction) {
+            callback(IDBError { UnknownError });
+            return;
+        }
+        this->commitTransactionAfterQuotaCheck(*transaction, WTFMove(callback));
+    });
+}
+
+void UniqueIDBDatabase::commitTransactionAfterQuotaCheck(UniqueIDBDatabaseTransaction& transaction, ErrorCallback callback)
+{
     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));
     if (!callbackID)
         return;
 
-    if (!prepareToFinishTransaction(transaction)) {
+    if (!prepareToFinishTransaction(transaction, UniqueIDBDatabaseTransaction::State::Committing)) {
         if (!m_openDatabaseConnections.contains(&transaction.databaseConnection())) {
             // This database connection is closing or has already closed, so there is no point in messaging back to it about the commit failing.
             forgetErrorCallback(callbackID);
             return;
         }
@@ -1359,27 +1683,58 @@
 void UniqueIDBDatabase::didPerformCommitTransaction(uint64_t callbackIdentifier, const IDBError& error, const IDBResourceIdentifier& transactionIdentifier)
 {
     ASSERT(isMainThread());
     LOG(IndexedDB, "(main) UniqueIDBDatabase::didPerformCommitTransaction - %s", transactionIdentifier.loggingString().utf8().data());
 
-    performErrorCallback(callbackIdentifier, error);
+    IDBError result = error;
+    auto transaction = m_finishingTransactions.get(transactionIdentifier);
+    switch (transaction->state()) {
+    case UniqueIDBDatabaseTransaction::State::Aborted:
+        result = IDBError { UnknownError, "Transaction is already aborted"_s };
+        break;
+    case UniqueIDBDatabaseTransaction::State::Committed:
+        result = transaction->result();
+        break;
+    case UniqueIDBDatabaseTransaction::State::Committing:
+        break;
+    case UniqueIDBDatabaseTransaction::State::Running:
+    case UniqueIDBDatabaseTransaction::State::Aborting:
+        ASSERT_NOT_REACHED();
+    }
+
+    performErrorCallback(callbackIdentifier, result);
 
     transactionCompleted(m_finishingTransactions.take(transactionIdentifier));
 }
 
-void UniqueIDBDatabase::abortTransaction(UniqueIDBDatabaseTransaction& transaction, ErrorCallback callback)
+void UniqueIDBDatabase::abortTransaction(UniqueIDBDatabaseTransaction& transaction, WaitForPendingTasks waitForPendingTasks, ErrorCallback callback)
 {
     ASSERT(isMainThread());
     LOG(IndexedDB, "(main) UniqueIDBDatabase::abortTransaction - %s", transaction.info().identifier().loggingString().utf8().data());
 
     ASSERT(transaction.databaseConnection().database() == this);
 
+    if (waitForPendingTasks == WaitForPendingTasks::Yes) {
+        waitForRequestSpaceCompletion([this, transaction = makeWeakPtr(transaction), callback = WTFMove(callback)](auto&& error) mutable {
+            if (error) {
+                callback(WTFMove(*error));
+                return;
+            }
+            if (!transaction) {
+                callback(IDBError { UnknownError });
+                return;
+            }
+            this->abortTransaction(*transaction, WaitForPendingTasks::No, WTFMove(callback));
+        });
+        return;
+    }
+
     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));
     if (!callbackID)
         return;
 
-    if (!prepareToFinishTransaction(transaction)) {
+    if (!prepareToFinishTransaction(transaction, UniqueIDBDatabaseTransaction::State::Aborting)) {
         if (!m_openDatabaseConnections.contains(&transaction.databaseConnection())) {
             // This database connection is closing or has already closed, so there is no point in messaging back to it about the abort failing.
             forgetErrorCallback(callbackID);
             return;
         }
@@ -1429,14 +1784,15 @@
 
     if (m_versionChangeTransaction && m_versionChangeTransaction->info().identifier() == transactionIdentifier) {
         ASSERT(m_versionChangeTransaction == transaction);
         ASSERT(!m_versionChangeDatabaseConnection || &m_versionChangeTransaction->databaseConnection() == m_versionChangeDatabaseConnection);
         ASSERT(m_versionChangeTransaction->originalDatabaseInfo());
-        m_databaseInfo = std::make_unique<IDBDatabaseInfo>(*m_versionChangeTransaction->originalDatabaseInfo());
+        m_databaseInfo = makeUnique<IDBDatabaseInfo>(*m_versionChangeTransaction->originalDatabaseInfo());
     }
 
-    performErrorCallback(callbackIdentifier, error);
+    IDBError result = transaction->state() == UniqueIDBDatabaseTransaction::State::Aborted ? transaction->result() : error;
+    performErrorCallback(callbackIdentifier, result);
 
     transactionCompleted(WTFMove(transaction));
 }
 
 void UniqueIDBDatabase::transactionDestroyed(UniqueIDBDatabaseTransaction& transaction)
@@ -1448,10 +1804,17 @@
 void UniqueIDBDatabase::connectionClosedFromClient(UniqueIDBDatabaseConnection& connection)
 {
     ASSERT(isMainThread());
     LOG(IndexedDB, "(main) UniqueIDBDatabase::connectionClosedFromClient - %s (%" PRIu64 ")", connection.openRequestIdentifier().loggingString().utf8().data(), connection.identifier());
 
+    if (m_serverClosePendingDatabaseConnections.contains(&connection)) {
+        m_serverClosePendingDatabaseConnections.remove(&connection);
+        if (m_hardClosedForUserDelete)
+            maybeFinishHardClose();
+        return;
+    }
+
     Ref<UniqueIDBDatabaseConnection> protectedConnection(connection);
     m_openDatabaseConnections.remove(&connection);
 
     if (m_versionChangeDatabaseConnection == &connection) {
         if (m_versionChangeTransaction) {
@@ -1527,14 +1890,16 @@
 void UniqueIDBDatabase::confirmDidCloseFromServer(UniqueIDBDatabaseConnection& connection)
 {
     ASSERT(isMainThread());
     LOG(IndexedDB, "UniqueIDBDatabase::confirmDidCloseFromServer - %s (%" PRIu64 ")", connection.openRequestIdentifier().loggingString().utf8().data(), connection.identifier());
 
+    if (!m_serverClosePendingDatabaseConnections.contains(&connection))
+        return;
+    m_serverClosePendingDatabaseConnections.remove(&connection);
+
     if (m_hardClosedForUserDelete)
         maybeFinishHardClose();
-    ASSERT(m_serverClosePendingDatabaseConnections.contains(&connection));
-    m_serverClosePendingDatabaseConnections.remove(&connection);
 }
 
 void UniqueIDBDatabase::enqueueTransaction(Ref<UniqueIDBDatabaseTransaction>&& transaction)
 {
     LOG(IndexedDB, "UniqueIDBDatabase::enqueueTransaction - %s", transaction->info().loggingString().utf8().data());
@@ -1757,17 +2122,20 @@
 }
 
 void UniqueIDBDatabase::postDatabaseTask(CrossThreadTask&& task)
 {
     m_databaseQueue.append(WTFMove(task));
-    m_server.postDatabaseTask(createCrossThreadTask(*this, &UniqueIDBDatabase::executeNextDatabaseTask));
+    m_server->postDatabaseTask(createCrossThreadTask(*this, &UniqueIDBDatabase::executeNextDatabaseTask));
 }
 
 void UniqueIDBDatabase::postDatabaseTaskReply(CrossThreadTask&& task)
 {
+    if (m_backingStore)
+        m_newDatabaseSize = m_backingStore->databaseSize();
+
     m_databaseReplyQueue.append(WTFMove(task));
-    m_server.postDatabaseTaskReply(createCrossThreadTask(*this, &UniqueIDBDatabase::executeNextDatabaseTaskReply));
+    m_server->postDatabaseTaskReply(createCrossThreadTask(*this, &UniqueIDBDatabase::executeNextDatabaseTaskReply));
 }
 
 void UniqueIDBDatabase::executeNextDatabaseTask()
 {
     ASSERT(!isMainThread());
@@ -1826,10 +2194,13 @@
 {
     LOG(IndexedDB, "UniqueIDBDatabase::immediateCloseForUserDelete - Cancelling (%i, %i, %i, %i) callbacks", m_errorCallbacks.size(), m_keyDataCallbacks.size(), m_getResultCallbacks.size(), m_countCallbacks.size());
 
     ASSERT(isMainThread());
 
+    m_pendingSpaceIncreasingTasks.clear();
+    m_server->resetSpaceUsed(m_identifier.origin());
+
     // Error out all transactions
     for (auto& identifier : copyToVector(m_inProgressTransactions.keys()))
         m_inProgressTransactions.get(identifier)->abortWithoutCallback();
 
     ASSERT(m_inProgressTransactions.isEmpty());
@@ -1876,10 +2247,15 @@
     // Close all open connections
     auto openDatabaseConnections = m_openDatabaseConnections;
     for (auto& connection : openDatabaseConnections)
         connectionClosedFromServer(*connection);
 
+    if (m_versionChangeDatabaseConnection) {
+        connectionClosedFromServer(*m_versionChangeDatabaseConnection);
+        m_versionChangeDatabaseConnection = nullptr;
+    }
+
     // Cancel the operation timer
     m_operationAndTransactionTimer.stop();
 
     // Set up the database to remain alive-but-inert until all of its background activity finishes and all
     // database connections confirm that they have closed.
@@ -1891,16 +2267,41 @@
     if (m_owningPointerForClose)
         return;
 
     // Otherwise, this database is still potentially active.
     // So we'll have it own itself and then perform a clean unconditional delete on the background thread.
-    m_owningPointerForClose = m_server.closeAndTakeUniqueIDBDatabase(*this);
+    m_owningPointerForClose = m_server->closeAndTakeUniqueIDBDatabase(*this);
     postDatabaseTask(createCrossThreadTask(*this, &UniqueIDBDatabase::performUnconditionalDeleteBackingStore));
 }
 
+void UniqueIDBDatabase::updateSpaceUsedIfNeeded(Optional<uint64_t> optionalCallbackIdentifier)
+{
+    ASSERT(isMainThread());
+
+    if (optionalCallbackIdentifier) {
+        uint64_t callbackIdentifier = optionalCallbackIdentifier.value();
+        auto iterator = m_pendingSpaceIncreasingTasks.find(callbackIdentifier);
+        if (iterator != m_pendingSpaceIncreasingTasks.end()) {
+            m_server->decreasePotentialSpaceUsed(m_identifier.origin(), iterator->value);
+            m_pendingSpaceIncreasingTasks.remove(iterator);
+        }
+    }
+
+    uint64_t databaseSize = m_newDatabaseSize;
+    if (databaseSize != m_currentDatabaseSize) {
+        if (databaseSize > m_currentDatabaseSize)
+            m_server->increaseSpaceUsed(m_identifier.origin(), databaseSize - m_currentDatabaseSize);
+        else
+            m_server->decreaseSpaceUsed(m_identifier.origin(), m_currentDatabaseSize - databaseSize);
+        m_currentDatabaseSize = databaseSize;
+    }
+}
+
 void UniqueIDBDatabase::performErrorCallback(uint64_t callbackIdentifier, const IDBError& error)
 {
+    updateSpaceUsedIfNeeded(callbackIdentifier);
+
     auto callback = m_errorCallbacks.take(callbackIdentifier);
     ASSERT(callback || m_hardClosedForUserDelete);
     if (callback) {
         callback(error);
         ASSERT(m_callbackQueue.first() == callbackIdentifier);
@@ -1908,10 +2309,12 @@
     }
 }
 
 void UniqueIDBDatabase::performKeyDataCallback(uint64_t callbackIdentifier, const IDBError& error, const IDBKeyData& resultKey)
 {
+    updateSpaceUsedIfNeeded(callbackIdentifier);
+
     auto callback = m_keyDataCallbacks.take(callbackIdentifier);
     ASSERT(callback || m_hardClosedForUserDelete);
     if (callback) {
         callback(error, resultKey);
         ASSERT(m_callbackQueue.first() == callbackIdentifier);
@@ -1952,20 +2355,57 @@
     }
 }
 
 void UniqueIDBDatabase::forgetErrorCallback(uint64_t callbackIdentifier)
 {
+    updateSpaceUsedIfNeeded(callbackIdentifier);
+
     ASSERT(m_errorCallbacks.contains(callbackIdentifier));
     ASSERT(m_callbackQueue.last() == callbackIdentifier);
     m_callbackQueue.removeLast();
     m_errorCallbacks.remove(callbackIdentifier);
 }
 
-void UniqueIDBDatabase::setQuota(uint64_t quota)
+void UniqueIDBDatabase::abortTransactionOnMainThread(UniqueIDBDatabaseTransaction& transaction)
 {
-    if (m_backingStore)
-        m_backingStore->setQuota(quota);
+    transaction.setResult(m_backingStore->abortTransaction(transaction.info().identifier()));
+    transaction.setState(UniqueIDBDatabaseTransaction::State::Aborted);
+}
+
+void UniqueIDBDatabase::commitTransactionOnMainThread(UniqueIDBDatabaseTransaction& transaction)
+{
+    transaction.setResult(m_backingStore->commitTransaction(transaction.info().identifier()));
+    transaction.setState(UniqueIDBDatabaseTransaction::State::Committed);
+}
+
+void UniqueIDBDatabase::finishActiveTransactions()
+{
+    ASSERT(isMainThread());
+
+    for (auto& identifier : copyToVector(m_inProgressTransactions.keys())) {
+        auto transaction = m_inProgressTransactions.get(identifier);
+        abortTransactionOnMainThread(*transaction);
+    }
+
+    for (auto& identifier : copyToVector(m_finishingTransactions.keys())) {
+        if (!m_backingStore->hasTransaction(identifier))
+            continue;
+
+        auto transaction = m_finishingTransactions.get(identifier);
+        switch (transaction->state()) {
+        case UniqueIDBDatabaseTransaction::State::Aborting:
+            abortTransactionOnMainThread(*transaction);
+            break;
+        case UniqueIDBDatabaseTransaction::State::Committing:
+            commitTransactionOnMainThread(*transaction);
+            break;
+        case UniqueIDBDatabaseTransaction::State::Running:
+        case UniqueIDBDatabaseTransaction::State::Aborted:
+        case UniqueIDBDatabaseTransaction::State::Committed:
+            ASSERT_NOT_REACHED();
+        }
+    }
 }
 
 } // namespace IDBServer
 } // namespace WebCore
 
