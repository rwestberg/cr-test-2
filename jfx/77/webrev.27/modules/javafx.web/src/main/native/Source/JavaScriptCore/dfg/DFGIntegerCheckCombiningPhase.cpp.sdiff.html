<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGIntegerCheckCombiningPhase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGInPlaceAbstractState.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGIntegerRangeOptimizationPhase.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGIntegerCheckCombiningPhase.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
128         }
129 
130         bool operator!() const { return !m_key &amp;&amp; !m_addend; }
131 
132         void dump(PrintStream&amp; out) const
133         {
134             out.print(m_key, &quot; + &quot;, m_addend);
135         }
136 
137         RangeKey m_key;
138         int32_t m_addend { 0 };
139     };
140 
141     struct Range {
142         void dump(PrintStream&amp; out) const
143         {
144             out.print(&quot;(&quot;, m_minBound, &quot; @&quot;, m_minOrigin, &quot;) .. (&quot;, m_maxBound, &quot; @&quot;, m_maxOrigin, &quot;), count = &quot;, m_count, &quot;, hoisted = &quot;, m_hoisted);
145         }
146 
147         int32_t m_minBound { 0 };
<span class="line-removed">148         CodeOrigin m_minOrigin;</span>
149         int32_t m_maxBound { 0 };

150         CodeOrigin m_maxOrigin;
151         unsigned m_count { 0 }; // If this is zero then the bounds won&#39;t necessarily make sense.
152         bool m_hoisted { false };
153         Node* m_dependency { nullptr };
154     };
155 
156     IntegerCheckCombiningPhase(Graph&amp; graph)
157         : Phase(graph, &quot;integer check combining&quot;)
158         , m_insertionSet(graph)
159     {
160     }
161 
162     bool run()
163     {
164         ASSERT(m_graph.m_form == SSA);
165 
166         m_changed = false;
167 
168         for (BlockIndex blockIndex = m_graph.numBlocks(); blockIndex--;)
169             handleBlock(blockIndex);
</pre>
</td>
<td>
<hr />
<pre>
128         }
129 
130         bool operator!() const { return !m_key &amp;&amp; !m_addend; }
131 
132         void dump(PrintStream&amp; out) const
133         {
134             out.print(m_key, &quot; + &quot;, m_addend);
135         }
136 
137         RangeKey m_key;
138         int32_t m_addend { 0 };
139     };
140 
141     struct Range {
142         void dump(PrintStream&amp; out) const
143         {
144             out.print(&quot;(&quot;, m_minBound, &quot; @&quot;, m_minOrigin, &quot;) .. (&quot;, m_maxBound, &quot; @&quot;, m_maxOrigin, &quot;), count = &quot;, m_count, &quot;, hoisted = &quot;, m_hoisted);
145         }
146 
147         int32_t m_minBound { 0 };

148         int32_t m_maxBound { 0 };
<span class="line-added">149         CodeOrigin m_minOrigin;</span>
150         CodeOrigin m_maxOrigin;
151         unsigned m_count { 0 }; // If this is zero then the bounds won&#39;t necessarily make sense.
152         bool m_hoisted { false };
153         Node* m_dependency { nullptr };
154     };
155 
156     IntegerCheckCombiningPhase(Graph&amp; graph)
157         : Phase(graph, &quot;integer check combining&quot;)
158         , m_insertionSet(graph)
159     {
160     }
161 
162     bool run()
163     {
164         ASSERT(m_graph.m_form == SSA);
165 
166         m_changed = false;
167 
168         for (BlockIndex blockIndex = m_graph.numBlocks(); blockIndex--;)
169             handleBlock(blockIndex);
</pre>
</td>
</tr>
</table>
<center><a href="DFGInPlaceAbstractState.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGIntegerRangeOptimizationPhase.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>