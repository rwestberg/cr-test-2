<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/InternalFunction.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  *  Copyright (C) 1999-2002 Harri Porten (porten@kde.org)
  3  *  Copyright (C) 2001 Peter Kelly (pmk@post.com)
  4  *  Copyright (C) 2004-2019 Apple Inc. All rights reserved.
  5  *
  6  *  This library is free software; you can redistribute it and/or
  7  *  modify it under the terms of the GNU Library General Public
  8  *  License as published by the Free Software Foundation; either
  9  *  version 2 of the License, or (at your option) any later version.
 10  *
 11  *  This library is distributed in the hope that it will be useful,
 12  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 13  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 14  *  Library General Public License for more details.
 15  *
 16  *  You should have received a copy of the GNU Library General Public License
 17  *  along with this library; see the file COPYING.LIB.  If not, write to
 18  *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 19  *  Boston, MA 02110-1301, USA.
 20  *
 21  */
 22 
 23 #include &quot;config.h&quot;
 24 #include &quot;InternalFunction.h&quot;
 25 
 26 #include &quot;FunctionPrototype.h&quot;
 27 #include &quot;JSGlobalObject.h&quot;
 28 #include &quot;JSString.h&quot;
 29 #include &quot;JSCInlines.h&quot;
 30 
 31 namespace JSC {
 32 
 33 STATIC_ASSERT_IS_TRIVIALLY_DESTRUCTIBLE(InternalFunction);
 34 
 35 const ClassInfo InternalFunction::s_info = { &quot;Function&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(InternalFunction) };
 36 
 37 InternalFunction::InternalFunction(VM&amp; vm, Structure* structure, NativeFunction functionForCall, NativeFunction functionForConstruct)
 38     : JSDestructibleObject(vm, structure)
 39     , m_functionForCall(functionForCall)
 40     , m_functionForConstruct(functionForConstruct ? functionForConstruct : callHostFunctionAsConstructor)
 41 {
 42     // exec-&gt;vm() wants callees to not be large allocations.
 43     RELEASE_ASSERT(!isLargeAllocation());
 44     ASSERT_WITH_MESSAGE(m_functionForCall, &quot;[[Call]] must be implemented&quot;);
 45     ASSERT(m_functionForConstruct);
 46 }
 47 
 48 void InternalFunction::finishCreation(VM&amp; vm, const String&amp; name, NameVisibility nameVisibility)
 49 {
 50     Base::finishCreation(vm);
 51     ASSERT(jsDynamicCast&lt;InternalFunction*&gt;(vm, this));
 52     ASSERT(methodTable(vm)-&gt;getCallData == InternalFunction::info()-&gt;methodTable.getCallData);
 53     ASSERT(methodTable(vm)-&gt;getConstructData == InternalFunction::info()-&gt;methodTable.getConstructData);
 54     ASSERT(type() == InternalFunctionType);
 55     JSString* nameString = jsString(&amp;vm, name);
 56     m_originalName.set(vm, this, nameString);
 57     if (nameVisibility == NameVisibility::Visible)
 58         putDirect(vm, vm.propertyNames-&gt;name, nameString, PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum);
 59 }
 60 
 61 void InternalFunction::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
 62 {
 63     InternalFunction* thisObject = jsCast&lt;InternalFunction*&gt;(cell);
 64     ASSERT_GC_OBJECT_INHERITS(thisObject, info());
 65     Base::visitChildren(thisObject, visitor);
 66 
 67     visitor.append(thisObject-&gt;m_originalName);
 68 }
 69 
 70 const String&amp; InternalFunction::name()
 71 {
 72     const String&amp; name = m_originalName-&gt;tryGetValue();
 73     ASSERT(name); // m_originalName was built from a String, and hence, there is no rope to resolve.
 74     return name;
 75 }
 76 
 77 const String InternalFunction::displayName(VM&amp; vm)
 78 {
 79     JSValue displayName = getDirect(vm, vm.propertyNames-&gt;displayName);
 80 
 81     if (displayName &amp;&amp; isJSString(displayName))
 82         return asString(displayName)-&gt;tryGetValue();
 83 
 84     return String();
 85 }
 86 
 87 CallType InternalFunction::getCallData(JSCell* cell, CallData&amp; callData)
 88 {
 89     auto* function = jsCast&lt;InternalFunction*&gt;(cell);
 90     ASSERT(function-&gt;m_functionForCall);
 91     callData.native.function = function-&gt;m_functionForCall;
 92     return CallType::Host;
 93 }
 94 
 95 ConstructType InternalFunction::getConstructData(JSCell* cell, ConstructData&amp; constructData)
 96 {
 97     auto* function = jsCast&lt;InternalFunction*&gt;(cell);
 98     if (function-&gt;m_functionForConstruct == callHostFunctionAsConstructor)
 99         return ConstructType::None;
100     constructData.native.function = function-&gt;m_functionForConstruct;
101     return ConstructType::Host;
102 }
103 
104 const String InternalFunction::calculatedDisplayName(VM&amp; vm)
105 {
106     const String explicitName = displayName(vm);
107 
108     if (!explicitName.isEmpty())
109         return explicitName;
110 
111     return name();
112 }
113 
114 Structure* InternalFunction::createSubclassStructureSlow(ExecState* exec, JSValue newTarget, Structure* baseClass)
115 {
116     VM&amp; vm = exec-&gt;vm();
117     auto scope = DECLARE_THROW_SCOPE(vm);
118     ASSERT(!newTarget || newTarget.isConstructor(vm));
119     ASSERT(newTarget &amp;&amp; newTarget != exec-&gt;jsCallee());
120 
121     ASSERT(baseClass-&gt;hasMonoProto());
122 
123     // newTarget may be an InternalFunction if we were called from Reflect.construct.
124     JSFunction* targetFunction = jsDynamicCast&lt;JSFunction*&gt;(vm, newTarget);
125     JSGlobalObject* lexicalGlobalObject = exec-&gt;lexicalGlobalObject();
126 
127     if (LIKELY(targetFunction)) {
128         Structure* structure = targetFunction-&gt;rareData(vm)-&gt;internalFunctionAllocationStructure();
129         if (LIKELY(structure &amp;&amp; structure-&gt;classInfo() == baseClass-&gt;classInfo()))
130             return structure;
131 
132         // Note, Reflect.construct might cause the profile to churn but we don&#39;t care.
133         JSValue prototypeValue = newTarget.get(exec, vm.propertyNames-&gt;prototype);
134         RETURN_IF_EXCEPTION(scope, nullptr);
135         if (JSObject* prototype = jsDynamicCast&lt;JSObject*&gt;(vm, prototypeValue))
136             return targetFunction-&gt;rareData(vm)-&gt;createInternalFunctionAllocationStructureFromBase(vm, lexicalGlobalObject, prototype, baseClass);
137     } else {
138         JSValue prototypeValue = newTarget.get(exec, vm.propertyNames-&gt;prototype);
139         RETURN_IF_EXCEPTION(scope, nullptr);
140         if (JSObject* prototype = jsDynamicCast&lt;JSObject*&gt;(vm, prototypeValue)) {
141             // This only happens if someone Reflect.constructs our builtin constructor with another builtin constructor as the new.target.
142             // Thus, we don&#39;t care about the cost of looking up the structure from our hash table every time.
143             return vm.structureCache.emptyStructureForPrototypeFromBaseStructure(lexicalGlobalObject, prototype, baseClass);
144         }
145     }
146 
147     return baseClass;
148 }
149 
150 
151 } // namespace JSC
    </pre>
  </body>
</html>