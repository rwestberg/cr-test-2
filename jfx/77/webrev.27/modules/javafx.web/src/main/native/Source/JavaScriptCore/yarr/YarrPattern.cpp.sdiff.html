<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/yarr/YarrPattern.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="YarrParser.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="YarrPattern.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/yarr/YarrPattern.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  25  */
  26 
  27 #include &quot;config.h&quot;
  28 #include &quot;YarrPattern.h&quot;
  29 
  30 #include &quot;Options.h&quot;
  31 #include &quot;Yarr.h&quot;
  32 #include &quot;YarrCanonicalize.h&quot;
  33 #include &quot;YarrParser.h&quot;
  34 #include &lt;wtf/DataLog.h&gt;
  35 #include &lt;wtf/Optional.h&gt;
  36 #include &lt;wtf/StackPointer.h&gt;
  37 #include &lt;wtf/Threading.h&gt;
  38 #include &lt;wtf/Vector.h&gt;
<span class="line-removed">  39 #include &lt;wtf/text/WTFString.h&gt;</span>
  40 
  41 namespace JSC { namespace Yarr {
  42 
  43 #include &quot;RegExpJitTables.h&quot;
  44 
  45 class CharacterClassConstructor {
  46 public:
  47     CharacterClassConstructor(bool isCaseInsensitive, CanonicalMode canonicalMode)
  48         : m_isCaseInsensitive(isCaseInsensitive)
<span class="line-removed">  49         , m_hasNonBMPCharacters(false)</span>
  50         , m_anyCharacter(false)

  51         , m_canonicalMode(canonicalMode)
  52     {
  53     }
  54 
  55     void reset()
  56     {
  57         m_matches.clear();
  58         m_ranges.clear();
  59         m_matchesUnicode.clear();
  60         m_rangesUnicode.clear();
<span class="line-removed">  61         m_hasNonBMPCharacters = false;</span>
  62         m_anyCharacter = false;

  63     }
  64 
  65     void append(const CharacterClass* other)
  66     {
  67         for (size_t i = 0; i &lt; other-&gt;m_matches.size(); ++i)
  68             addSorted(m_matches, other-&gt;m_matches[i]);
  69         for (size_t i = 0; i &lt; other-&gt;m_ranges.size(); ++i)
  70             addSortedRange(m_ranges, other-&gt;m_ranges[i].begin, other-&gt;m_ranges[i].end);
  71         for (size_t i = 0; i &lt; other-&gt;m_matchesUnicode.size(); ++i)
  72             addSorted(m_matchesUnicode, other-&gt;m_matchesUnicode[i]);
  73         for (size_t i = 0; i &lt; other-&gt;m_rangesUnicode.size(); ++i)
  74             addSortedRange(m_rangesUnicode, other-&gt;m_rangesUnicode[i].begin, other-&gt;m_rangesUnicode[i].end);
  75     }
  76 
  77     void appendInverted(const CharacterClass* other)
  78     {
  79         auto addSortedInverted = [&amp;](UChar32 min, UChar32 max,
  80             const Vector&lt;UChar32&gt;&amp; srcMatches, const Vector&lt;CharacterRange&gt;&amp; srcRanges,
  81             Vector&lt;UChar32&gt;&amp; destMatches, Vector&lt;CharacterRange&gt;&amp; destRanges) {
  82 
</pre>
<hr />
<pre>
 224                 if (!(lo &amp; 1))
 225                     addSortedRange(m_rangesUnicode, lo - 1, lo - 1);
 226                 if (end &amp; 1)
 227                     addSortedRange(m_rangesUnicode, end + 1, end + 1);
 228                 break;
 229             }
 230 
 231             if (hi == end)
 232                 return;
 233 
 234             ++info;
 235             lo = info-&gt;begin;
 236         };
 237 
 238     }
 239 
 240     std::unique_ptr&lt;CharacterClass&gt; charClass()
 241     {
 242         coalesceTables();
 243 
<span class="line-modified"> 244         auto characterClass = std::make_unique&lt;CharacterClass&gt;();</span>
 245 
 246         characterClass-&gt;m_matches.swap(m_matches);
 247         characterClass-&gt;m_ranges.swap(m_ranges);
 248         characterClass-&gt;m_matchesUnicode.swap(m_matchesUnicode);
 249         characterClass-&gt;m_rangesUnicode.swap(m_rangesUnicode);
<span class="line-removed"> 250         characterClass-&gt;m_hasNonBMPCharacters = hasNonBMPCharacters();</span>
 251         characterClass-&gt;m_anyCharacter = anyCharacter();

 252 
<span class="line-removed"> 253         m_hasNonBMPCharacters = false;</span>
 254         m_anyCharacter = false;

 255 
 256         return characterClass;
 257     }
 258 
 259 private:
 260     void addSorted(UChar32 ch)
 261     {
 262         addSorted(isASCII(ch) ? m_matches : m_matchesUnicode, ch);
 263     }
 264 
 265     void addSorted(Vector&lt;UChar32&gt;&amp; matches, UChar32 ch)
 266     {
 267         unsigned pos = 0;
 268         unsigned range = matches.size();
 269 
<span class="line-modified"> 270         if (!U_IS_BMP(ch))</span>
<span class="line-removed"> 271             m_hasNonBMPCharacters = true;</span>
 272 
 273         // binary chop, find position to insert char.
 274         while (range) {
 275             unsigned index = range &gt;&gt; 1;
 276 
 277             int val = matches[pos+index] - ch;
 278             if (!val)
 279                 return;
 280             else if (val &gt; 0) {
 281                 if (val == 1) {
 282                     UChar32 lo = ch;
 283                     UChar32 hi = ch + 1;
 284                     matches.remove(pos + index);
 285                     if (pos + index &gt; 0 &amp;&amp; matches[pos + index - 1] == ch - 1) {
 286                         lo = ch - 1;
 287                         matches.remove(pos + index - 1);
 288                     }
 289                     addSortedRange(isASCII(ch) ? m_ranges : m_rangesUnicode, lo, hi);
 290                     return;
 291                 }
</pre>
<hr />
<pre>
 300                         matches.remove(pos + index + 1);
 301                     }
 302                     addSortedRange(isASCII(ch) ? m_ranges : m_rangesUnicode, lo, hi);
 303                     return;
 304                 }
 305                 pos += (index+1);
 306                 range -= (index+1);
 307             }
 308         }
 309 
 310         if (pos == matches.size())
 311             matches.append(ch);
 312         else
 313             matches.insert(pos, ch);
 314     }
 315 
 316     void addSortedRange(Vector&lt;CharacterRange&gt;&amp; ranges, UChar32 lo, UChar32 hi)
 317     {
 318         size_t end = ranges.size();
 319 


 320         if (!U_IS_BMP(hi))
<span class="line-modified"> 321             m_hasNonBMPCharacters = true;</span>
 322 
 323         // Simple linear scan - I doubt there are that many ranges anyway...
 324         // feel free to fix this with something faster (eg binary chop).
 325         for (size_t i = 0; i &lt; end; ++i) {
 326             // does the new range fall before the current position in the array
 327             if (hi &lt; ranges[i].begin) {
 328                 // Concatenate appending ranges.
 329                 if (hi == (ranges[i].begin - 1)) {
 330                     ranges[i].begin = lo;
 331                     return;
 332                 }
 333                 ranges.insert(i, CharacterRange(lo, hi));
 334                 return;
 335             }
 336             // Okay, since we didn&#39;t hit the last case, the end of the new range is definitely at or after the begining
 337             // If the new range start at or before the end of the last range, then the overlap (if it starts one after the
 338             // end of the last range they concatenate, which is just as good.
 339             if (lo &lt;= (ranges[i].end + 1)) {
 340                 // found an intersect! we&#39;ll replace this entry in the array.
 341                 ranges[i].begin = std::min(ranges[i].begin, lo);
</pre>
<hr />
<pre>
 392 
 393                         mergeRangesFrom(ranges, rangesIndex);
 394                     } else
 395                         matchesIndex++;
 396                 }
 397             }
 398         };
 399 
 400         coalesceMatchesAndRanges(m_matches, m_ranges);
 401         coalesceMatchesAndRanges(m_matchesUnicode, m_rangesUnicode);
 402 
 403         if (!m_matches.size() &amp;&amp; !m_matchesUnicode.size()
 404             &amp;&amp; m_ranges.size() == 1 &amp;&amp; m_rangesUnicode.size() == 1
 405             &amp;&amp; m_ranges[0].begin == 0 &amp;&amp; m_ranges[0].end == 0x7f
 406             &amp;&amp; m_rangesUnicode[0].begin == 0x80 &amp;&amp; m_rangesUnicode[0].end == 0x10ffff)
 407             m_anyCharacter = true;
 408     }
 409 
 410     bool hasNonBMPCharacters()
 411     {
<span class="line-modified"> 412         return m_hasNonBMPCharacters;</span>





 413     }
 414 
 415     bool anyCharacter()
 416     {
 417         return m_anyCharacter;
 418     }
 419 
 420     bool m_isCaseInsensitive : 1;
<span class="line-removed"> 421     bool m_hasNonBMPCharacters : 1;</span>
 422     bool m_anyCharacter : 1;


 423     CanonicalMode m_canonicalMode;
 424 
 425     Vector&lt;UChar32&gt; m_matches;
 426     Vector&lt;CharacterRange&gt; m_ranges;
 427     Vector&lt;UChar32&gt; m_matchesUnicode;
 428     Vector&lt;CharacterRange&gt; m_rangesUnicode;
 429 };
 430 
 431 class YarrPatternConstructor {
 432 public:
 433     YarrPatternConstructor(YarrPattern&amp; pattern, void* stackLimit)
 434         : m_pattern(pattern)
 435         , m_characterClassConstructor(pattern.ignoreCase(), pattern.unicode() ? CanonicalMode::Unicode : CanonicalMode::UCS2)
 436         , m_stackLimit(stackLimit)
 437     {
<span class="line-modified"> 438         auto body = std::make_unique&lt;PatternDisjunction&gt;();</span>
 439         m_pattern.m_body = body.get();
 440         m_alternative = body-&gt;addNewAlternative();
 441         m_pattern.m_disjunctions.append(WTFMove(body));
 442     }
 443 
 444     ~YarrPatternConstructor()
 445     {
 446     }
 447 
 448     void resetForReparsing()
 449     {
 450         m_pattern.resetForReparsing();
 451         m_characterClassConstructor.reset();
 452 
<span class="line-modified"> 453         auto body = std::make_unique&lt;PatternDisjunction&gt;();</span>
 454         m_pattern.m_body = body.get();
 455         m_alternative = body-&gt;addNewAlternative();
 456         m_pattern.m_disjunctions.append(WTFMove(body));
 457     }
 458 
 459     void saveUnmatchedNamedForwardReferences()
 460     {
 461         m_unmatchedNamedForwardReferences.shrink(0);
 462 
 463         for (auto&amp; entry : m_pattern.m_namedForwardReferences) {
 464             if (!m_pattern.m_captureGroupNames.contains(entry))
 465                 m_unmatchedNamedForwardReferences.append(entry);
 466         }
 467     }
 468 
 469     void assertionBOL()
 470     {
 471         if (!m_alternative-&gt;m_terms.size() &amp;&amp; !m_invertParentheticalAssertion) {
 472             m_alternative-&gt;m_startsWithBOL = true;
 473             m_alternative-&gt;m_containsBOL = true;
</pre>
<hr />
<pre>
 585             return;
 586         }
 587         m_alternative-&gt;m_terms.append(PatternTerm(newCharacterClass.get(), m_invertCharacterClass));
 588         m_pattern.m_userCharacterClasses.append(WTFMove(newCharacterClass));
 589     }
 590 
 591     void atomParenthesesSubpatternBegin(bool capture = true, Optional&lt;String&gt; optGroupName = WTF::nullopt)
 592     {
 593         unsigned subpatternId = m_pattern.m_numSubpatterns + 1;
 594         if (capture) {
 595             m_pattern.m_numSubpatterns++;
 596             if (optGroupName) {
 597                 while (m_pattern.m_captureGroupNames.size() &lt; subpatternId)
 598                     m_pattern.m_captureGroupNames.append(String());
 599                 m_pattern.m_captureGroupNames.append(optGroupName.value());
 600                 m_pattern.m_namedGroupToParenIndex.add(optGroupName.value(), subpatternId);
 601             }
 602         } else
 603             ASSERT(!optGroupName);
 604 
<span class="line-modified"> 605         auto parenthesesDisjunction = std::make_unique&lt;PatternDisjunction&gt;(m_alternative);</span>
 606         m_alternative-&gt;m_terms.append(PatternTerm(PatternTerm::TypeParenthesesSubpattern, subpatternId, parenthesesDisjunction.get(), capture, false));
 607         m_alternative = parenthesesDisjunction-&gt;addNewAlternative();
 608         m_pattern.m_disjunctions.append(WTFMove(parenthesesDisjunction));
 609     }
 610 
 611     void atomParentheticalAssertionBegin(bool invert = false)
 612     {
<span class="line-modified"> 613         auto parenthesesDisjunction = std::make_unique&lt;PatternDisjunction&gt;(m_alternative);</span>
 614         m_alternative-&gt;m_terms.append(PatternTerm(PatternTerm::TypeParentheticalAssertion, m_pattern.m_numSubpatterns + 1, parenthesesDisjunction.get(), false, invert));
 615         m_alternative = parenthesesDisjunction-&gt;addNewAlternative();
 616         m_invertParentheticalAssertion = invert;
 617         m_pattern.m_disjunctions.append(WTFMove(parenthesesDisjunction));
 618     }
 619 
 620     void atomParenthesesEnd()
 621     {
 622         ASSERT(m_alternative-&gt;m_parent);
 623         ASSERT(m_alternative-&gt;m_parent-&gt;m_parent);
 624 
 625         PatternDisjunction* parenthesesDisjunction = m_alternative-&gt;m_parent;
 626         m_alternative = m_alternative-&gt;m_parent-&gt;m_parent;
 627 
 628         PatternTerm&amp; lastTerm = m_alternative-&gt;lastTerm();
 629 
 630         unsigned numParenAlternatives = parenthesesDisjunction-&gt;m_alternatives.size();
 631         unsigned numBOLAnchoredAlts = 0;
 632 
 633         for (unsigned i = 0; i &lt; numParenAlternatives; i++) {
</pre>
<hr />
<pre>
 679     {
 680         ASSERT(m_pattern.m_namedGroupToParenIndex.find(subpatternName) != m_pattern.m_namedGroupToParenIndex.end());
 681         atomBackReference(m_pattern.m_namedGroupToParenIndex.get(subpatternName));
 682     }
 683 
 684     bool isValidNamedForwardReference(const String&amp; subpatternName)
 685     {
 686         return !m_unmatchedNamedForwardReferences.contains(subpatternName);
 687     }
 688 
 689     void atomNamedForwardReference(const String&amp; subpatternName)
 690     {
 691         m_pattern.m_namedForwardReferences.appendIfNotContains(subpatternName);
 692         m_alternative-&gt;m_terms.append(PatternTerm::ForwardReference());
 693     }
 694 
 695     // deep copy the argument disjunction.  If filterStartsWithBOL is true,
 696     // skip alternatives with m_startsWithBOL set true.
 697     PatternDisjunction* copyDisjunction(PatternDisjunction* disjunction, bool filterStartsWithBOL = false)
 698     {





 699         std::unique_ptr&lt;PatternDisjunction&gt; newDisjunction;
 700         for (unsigned alt = 0; alt &lt; disjunction-&gt;m_alternatives.size(); ++alt) {
 701             PatternAlternative* alternative = disjunction-&gt;m_alternatives[alt].get();
 702             if (!filterStartsWithBOL || !alternative-&gt;m_startsWithBOL) {
 703                 if (!newDisjunction) {
<span class="line-modified"> 704                     newDisjunction = std::make_unique&lt;PatternDisjunction&gt;();</span>
 705                     newDisjunction-&gt;m_parent = disjunction-&gt;m_parent;
 706                 }
 707                 PatternAlternative* newAlternative = newDisjunction-&gt;addNewAlternative();
 708                 newAlternative-&gt;m_terms.reserveInitialCapacity(alternative-&gt;m_terms.size());
 709                 for (unsigned i = 0; i &lt; alternative-&gt;m_terms.size(); ++i)
 710                     newAlternative-&gt;m_terms.append(copyTerm(alternative-&gt;m_terms[i], filterStartsWithBOL));
 711             }
 712         }
 713 





 714         if (!newDisjunction)
 715             return 0;
 716 
 717         PatternDisjunction* copiedDisjunction = newDisjunction.get();
 718         m_pattern.m_disjunctions.append(WTFMove(newDisjunction));
 719         return copiedDisjunction;
 720     }
 721 
 722     PatternTerm copyTerm(PatternTerm&amp; term, bool filterStartsWithBOL = false)
 723     {





 724         if ((term.type != PatternTerm::TypeParenthesesSubpattern) &amp;&amp; (term.type != PatternTerm::TypeParentheticalAssertion))
 725             return PatternTerm(term);
 726 
 727         PatternTerm termCopy = term;
 728         termCopy.parentheses.disjunction = copyDisjunction(termCopy.parentheses.disjunction, filterStartsWithBOL);
 729         m_pattern.m_hasCopiedParenSubexpressions = true;
 730         return termCopy;
 731     }
 732 
 733     void quantifyAtom(unsigned min, unsigned max, bool greedy)
 734     {
 735         ASSERT(min &lt;= max);
 736         ASSERT(m_alternative-&gt;m_terms.size());
 737 
 738         if (!max) {
 739             m_alternative-&gt;removeLastTerm();
 740             return;
 741         }
 742 
 743         PatternTerm&amp; term = m_alternative-&gt;lastTerm();
</pre>
<hr />
<pre>
 820                     alternative-&gt;m_hasFixedSize = false;
 821                 } else if (m_pattern.unicode()) {
 822                     Checked&lt;unsigned, RecordOverflow&gt; tempCount = term.quantityMaxCount;
 823                     tempCount *= U16_LENGTH(term.patternCharacter);
 824                     if (tempCount.hasOverflowed())
 825                         return ErrorCode::OffsetTooLarge;
 826                     currentInputPosition += tempCount;
 827                 } else
 828                     currentInputPosition += term.quantityMaxCount;
 829                 break;
 830 
 831             case PatternTerm::TypeCharacterClass:
 832                 term.inputPosition = currentInputPosition.unsafeGet();
 833                 if (term.quantityType != QuantifierFixedCount) {
 834                     term.frameLocation = currentCallFrameSize;
 835                     currentCallFrameSize += YarrStackSpaceForBackTrackInfoCharacterClass;
 836                     alternative-&gt;m_hasFixedSize = false;
 837                 } else if (m_pattern.unicode()) {
 838                     term.frameLocation = currentCallFrameSize;
 839                     currentCallFrameSize += YarrStackSpaceForBackTrackInfoCharacterClass;
<span class="line-modified"> 840                     currentInputPosition += term.quantityMaxCount;</span>
<span class="line-modified"> 841                     alternative-&gt;m_hasFixedSize = false;</span>








 842                 } else
 843                     currentInputPosition += term.quantityMaxCount;
 844                 break;
 845 
 846             case PatternTerm::TypeParenthesesSubpattern:
 847                 // Note: for fixed once parentheses we will ensure at least the minimum is available; others are on their own.
 848                 term.frameLocation = currentCallFrameSize;
 849                 if (term.quantityMaxCount == 1 &amp;&amp; !term.parentheses.isCopy) {
 850                     currentCallFrameSize += YarrStackSpaceForBackTrackInfoParenthesesOnce;
 851                     error = setupDisjunctionOffsets(term.parentheses.disjunction, currentCallFrameSize, currentInputPosition.unsafeGet(), currentCallFrameSize);
 852                     if (hasError(error))
 853                         return error;
 854                     // If quantity is fixed, then pre-check its minimum size.
 855                     if (term.quantityType == QuantifierFixedCount)
 856                         currentInputPosition += term.parentheses.disjunction-&gt;m_minimumSize;
 857                     term.inputPosition = currentInputPosition.unsafeGet();
 858                 } else if (term.parentheses.isTerminal) {
 859                     currentCallFrameSize += YarrStackSpaceForBackTrackInfoParenthesesTerminal;
 860                     error = setupDisjunctionOffsets(term.parentheses.disjunction, currentCallFrameSize, currentInputPosition.unsafeGet(), currentCallFrameSize);
 861                     if (hasError(error))
</pre>
<hr />
<pre>
1069                 return;
1070 
1071             size_t endIndex = termIndex;
1072             if (firstExpressionTerm &gt;= endIndex)
1073                 return;
1074 
1075             if (!containsCapturingTerms(alternative, firstExpressionTerm, endIndex)) {
1076                 for (termIndex = terms.size() - 1; termIndex &gt;= endIndex; --termIndex)
1077                     terms.remove(termIndex);
1078 
1079                 for (termIndex = firstExpressionTerm; termIndex &gt; 0; --termIndex)
1080                     terms.remove(termIndex - 1);
1081 
1082                 terms.append(PatternTerm(startsWithBOL, endsWithEOL));
1083 
1084                 m_pattern.m_containsBOL = false;
1085             }
1086         }
1087     }
1088 


1089 private:
1090     bool isSafeToRecurse() const
1091     {
1092         if (!m_stackLimit)
1093             return true;
1094         ASSERT(Thread::current().stack().isGrowingDownward());
1095         int8_t* curr = reinterpret_cast&lt;int8_t*&gt;(currentStackPointer());
1096         int8_t* limit = reinterpret_cast&lt;int8_t*&gt;(m_stackLimit);
1097         return curr &gt;= limit;
1098     }
1099 
1100     YarrPattern&amp; m_pattern;
1101     PatternAlternative* m_alternative;
1102     CharacterClassConstructor m_characterClassConstructor;
1103     Vector&lt;String&gt; m_unmatchedNamedForwardReferences;
1104     void* m_stackLimit;

1105     bool m_invertCharacterClass;
1106     bool m_invertParentheticalAssertion { false };
1107 };
1108 
1109 ErrorCode YarrPattern::compile(const String&amp; patternString, void* stackLimit)
1110 {
1111     YarrPatternConstructor constructor(*this, stackLimit);
1112 
<span class="line-removed">1113     if (m_flags == InvalidFlags)</span>
<span class="line-removed">1114         return ErrorCode::InvalidRegularExpressionFlags;</span>
<span class="line-removed">1115 </span>
1116     {
1117         ErrorCode error = parse(constructor, patternString, unicode());
1118         if (hasError(error))
1119             return error;
1120     }
1121 
1122     // If the pattern contains illegal backreferences reset &amp; reparse.
1123     // Quoting Netscape&#39;s &quot;What&#39;s new in JavaScript 1.2&quot;,
1124     //      &quot;Note: if the number of left parentheses is less than the number specified
1125     //       in \#, the \# is taken as an octal escape as described in the next row.&quot;
1126     if (containsIllegalBackReference() || containsIllegalNamedForwardReferences()) {
1127         if (unicode())
1128             return ErrorCode::InvalidBackreference;
1129 
1130         unsigned numSubpatterns = m_numSubpatterns;
1131 
1132         constructor.saveUnmatchedNamedForwardReferences();
1133         constructor.resetForReparsing();
1134         ErrorCode error = parse(constructor, patternString, unicode(), numSubpatterns);
1135         ASSERT_UNUSED(error, !hasError(error));
1136         ASSERT(numSubpatterns == m_numSubpatterns);
1137     }
1138 
1139     constructor.checkForTerminalParentheses();
1140     constructor.optimizeDotStarWrappedExpressions();
1141     constructor.optimizeBOL();
1142 



1143     {
1144         ErrorCode error = constructor.setupOffsets();
1145         if (hasError(error))
1146             return error;
1147     }
1148 
1149     if (Options::dumpCompiledRegExpPatterns())
1150         dumpPattern(patternString);
1151 
1152     return ErrorCode::NoError;
1153 }
1154 
<span class="line-modified">1155 YarrPattern::YarrPattern(const String&amp; pattern, RegExpFlags flags, ErrorCode&amp; error, void* stackLimit)</span>
1156     : m_containsBackreferences(false)
1157     , m_containsBOL(false)
1158     , m_containsUnsignedLengthPattern(false)
1159     , m_hasCopiedParenSubexpressions(false)
1160     , m_saveInitialStartValue(false)
1161     , m_flags(flags)
1162 {

1163     error = compile(pattern, stackLimit);
1164 }
1165 
1166 void indentForNestingLevel(PrintStream&amp; out, unsigned nestingDepth)
1167 {
1168     out.print(&quot;    &quot;);
1169     for (; nestingDepth; --nestingDepth)
1170         out.print(&quot;  &quot;);
1171 }
1172 
1173 void dumpUChar32(PrintStream&amp; out, UChar32 c)
1174 {
1175     if (c &gt;= &#39; &#39;&amp;&amp; c &lt;= 0xff)
1176         out.printf(&quot;&#39;%c&#39;&quot;, static_cast&lt;char&gt;(c));
1177     else
1178         out.printf(&quot;0x%04x&quot;, c);
1179 }
1180 
1181 void dumpCharacterClass(PrintStream&amp; out, YarrPattern* pattern, CharacterClass* characterClass)
1182 {
</pre>
<hr />
<pre>
1304         break;
1305     case TypeAssertionWordBoundary:
1306         out.println(&quot;word boundary&quot;);
1307         break;
1308     case TypePatternCharacter:
1309         out.printf(&quot;character &quot;);
1310         out.printf(&quot;inputPosition %u &quot;, inputPosition);
1311         if (thisPattern-&gt;ignoreCase() &amp;&amp; isASCIIAlpha(patternCharacter)) {
1312             dumpUChar32(out, toASCIIUpper(patternCharacter));
1313             out.print(&quot;/&quot;);
1314             dumpUChar32(out, toASCIILower(patternCharacter));
1315         } else
1316             dumpUChar32(out, patternCharacter);
1317         dumpQuantifier(out);
1318         if (quantityType != QuantifierFixedCount)
1319             out.print(&quot;,frame location &quot;, frameLocation);
1320         out.println();
1321         break;
1322     case TypeCharacterClass:
1323         out.print(&quot;character class &quot;);

1324         dumpCharacterClass(out, thisPattern, characterClass);
1325         dumpQuantifier(out);
1326         if (quantityType != QuantifierFixedCount || thisPattern-&gt;unicode())
1327             out.print(&quot;,frame location &quot;, frameLocation);
1328         out.println();
1329         break;
1330     case TypeBackReference:
1331         out.print(&quot;back reference to subpattern #&quot;, backReferenceSubpatternId);
1332         out.println(&quot;,frame location &quot;, frameLocation);
1333         break;
1334     case TypeForwardReference:
1335         out.println(&quot;forward reference&quot;);
1336         break;
1337     case TypeParenthesesSubpattern:
1338         if (m_capture)
1339             out.print(&quot;captured &quot;);
1340         else
1341             out.print(&quot;non-captured &quot;);
1342 
1343         FALLTHROUGH;
</pre>
<hr />
<pre>
1403     if (ignoreCase())
1404         out.print(&quot;i&quot;);
1405     if (multiline())
1406         out.print(&quot;m&quot;);
1407     if (unicode())
1408         out.print(&quot;u&quot;);
1409     if (sticky())
1410         out.print(&quot;y&quot;);
1411 }
1412 
1413 void YarrPattern::dumpPattern(const String&amp; patternString)
1414 {
1415     dumpPattern(WTF::dataFile(), patternString);
1416 }
1417 
1418 void YarrPattern::dumpPattern(PrintStream&amp; out, const String&amp; patternString)
1419 {
1420     out.print(&quot;RegExp pattern for &quot;);
1421     dumpPatternString(out, patternString);
1422 
<span class="line-modified">1423     if (m_flags != NoFlags) {</span>
<span class="line-modified">1424         bool printSeperator = false;</span>
1425         out.print(&quot; (&quot;);
1426         if (global()) {
1427             out.print(&quot;global&quot;);
<span class="line-modified">1428             printSeperator = true;</span>
1429         }
1430         if (ignoreCase()) {
<span class="line-modified">1431             if (printSeperator)</span>
1432                 out.print(&quot;|&quot;);
1433             out.print(&quot;ignore case&quot;);
<span class="line-modified">1434             printSeperator = true;</span>
1435         }
1436         if (multiline()) {
<span class="line-modified">1437             if (printSeperator)</span>
1438                 out.print(&quot;|&quot;);
1439             out.print(&quot;multiline&quot;);
<span class="line-modified">1440             printSeperator = true;</span>
1441         }
1442         if (unicode()) {
<span class="line-modified">1443             if (printSeperator)</span>
1444                 out.print(&quot;|&quot;);
1445             out.print(&quot;unicode&quot;);
<span class="line-modified">1446             printSeperator = true;</span>
1447         }
1448         if (sticky()) {
<span class="line-modified">1449             if (printSeperator)</span>
1450                 out.print(&quot;|&quot;);
1451             out.print(&quot;sticky&quot;);
<span class="line-removed">1452             printSeperator = true;</span>
1453         }
1454         out.print(&quot;)&quot;);
1455     }
1456     out.print(&quot;:\n&quot;);
1457     if (m_body-&gt;m_callFrameSize)
1458         out.print(&quot;    callframe size: &quot;, m_body-&gt;m_callFrameSize, &quot;\n&quot;);
1459     m_body-&gt;dump(out, this);
1460 }
1461 
1462 std::unique_ptr&lt;CharacterClass&gt; anycharCreate()
1463 {
<span class="line-modified">1464     auto characterClass = std::make_unique&lt;CharacterClass&gt;();</span>
1465     characterClass-&gt;m_ranges.append(CharacterRange(0x00, 0x7f));
1466     characterClass-&gt;m_rangesUnicode.append(CharacterRange(0x0080, 0x10ffff));
<span class="line-modified">1467     characterClass-&gt;m_hasNonBMPCharacters = true;</span>
1468     characterClass-&gt;m_anyCharacter = true;
1469     return characterClass;
1470 }
1471 
1472 } } // namespace JSC::Yarr
</pre>
</td>
<td>
<hr />
<pre>
  19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  25  */
  26 
  27 #include &quot;config.h&quot;
  28 #include &quot;YarrPattern.h&quot;
  29 
  30 #include &quot;Options.h&quot;
  31 #include &quot;Yarr.h&quot;
  32 #include &quot;YarrCanonicalize.h&quot;
  33 #include &quot;YarrParser.h&quot;
  34 #include &lt;wtf/DataLog.h&gt;
  35 #include &lt;wtf/Optional.h&gt;
  36 #include &lt;wtf/StackPointer.h&gt;
  37 #include &lt;wtf/Threading.h&gt;
  38 #include &lt;wtf/Vector.h&gt;

  39 
  40 namespace JSC { namespace Yarr {
  41 
  42 #include &quot;RegExpJitTables.h&quot;
  43 
  44 class CharacterClassConstructor {
  45 public:
  46     CharacterClassConstructor(bool isCaseInsensitive, CanonicalMode canonicalMode)
  47         : m_isCaseInsensitive(isCaseInsensitive)

  48         , m_anyCharacter(false)
<span class="line-added">  49         , m_characterWidths(CharacterClassWidths::Unknown)</span>
  50         , m_canonicalMode(canonicalMode)
  51     {
  52     }
  53 
  54     void reset()
  55     {
  56         m_matches.clear();
  57         m_ranges.clear();
  58         m_matchesUnicode.clear();
  59         m_rangesUnicode.clear();

  60         m_anyCharacter = false;
<span class="line-added">  61         m_characterWidths = CharacterClassWidths::Unknown;</span>
  62     }
  63 
  64     void append(const CharacterClass* other)
  65     {
  66         for (size_t i = 0; i &lt; other-&gt;m_matches.size(); ++i)
  67             addSorted(m_matches, other-&gt;m_matches[i]);
  68         for (size_t i = 0; i &lt; other-&gt;m_ranges.size(); ++i)
  69             addSortedRange(m_ranges, other-&gt;m_ranges[i].begin, other-&gt;m_ranges[i].end);
  70         for (size_t i = 0; i &lt; other-&gt;m_matchesUnicode.size(); ++i)
  71             addSorted(m_matchesUnicode, other-&gt;m_matchesUnicode[i]);
  72         for (size_t i = 0; i &lt; other-&gt;m_rangesUnicode.size(); ++i)
  73             addSortedRange(m_rangesUnicode, other-&gt;m_rangesUnicode[i].begin, other-&gt;m_rangesUnicode[i].end);
  74     }
  75 
  76     void appendInverted(const CharacterClass* other)
  77     {
  78         auto addSortedInverted = [&amp;](UChar32 min, UChar32 max,
  79             const Vector&lt;UChar32&gt;&amp; srcMatches, const Vector&lt;CharacterRange&gt;&amp; srcRanges,
  80             Vector&lt;UChar32&gt;&amp; destMatches, Vector&lt;CharacterRange&gt;&amp; destRanges) {
  81 
</pre>
<hr />
<pre>
 223                 if (!(lo &amp; 1))
 224                     addSortedRange(m_rangesUnicode, lo - 1, lo - 1);
 225                 if (end &amp; 1)
 226                     addSortedRange(m_rangesUnicode, end + 1, end + 1);
 227                 break;
 228             }
 229 
 230             if (hi == end)
 231                 return;
 232 
 233             ++info;
 234             lo = info-&gt;begin;
 235         };
 236 
 237     }
 238 
 239     std::unique_ptr&lt;CharacterClass&gt; charClass()
 240     {
 241         coalesceTables();
 242 
<span class="line-modified"> 243         auto characterClass = makeUnique&lt;CharacterClass&gt;();</span>
 244 
 245         characterClass-&gt;m_matches.swap(m_matches);
 246         characterClass-&gt;m_ranges.swap(m_ranges);
 247         characterClass-&gt;m_matchesUnicode.swap(m_matchesUnicode);
 248         characterClass-&gt;m_rangesUnicode.swap(m_rangesUnicode);

 249         characterClass-&gt;m_anyCharacter = anyCharacter();
<span class="line-added"> 250         characterClass-&gt;m_characterWidths = characterWidths();</span>
 251 

 252         m_anyCharacter = false;
<span class="line-added"> 253         m_characterWidths = CharacterClassWidths::Unknown;</span>
 254 
 255         return characterClass;
 256     }
 257 
 258 private:
 259     void addSorted(UChar32 ch)
 260     {
 261         addSorted(isASCII(ch) ? m_matches : m_matchesUnicode, ch);
 262     }
 263 
 264     void addSorted(Vector&lt;UChar32&gt;&amp; matches, UChar32 ch)
 265     {
 266         unsigned pos = 0;
 267         unsigned range = matches.size();
 268 
<span class="line-modified"> 269         m_characterWidths |= (U_IS_BMP(ch) ? CharacterClassWidths::HasBMPChars : CharacterClassWidths::HasNonBMPChars);</span>

 270 
 271         // binary chop, find position to insert char.
 272         while (range) {
 273             unsigned index = range &gt;&gt; 1;
 274 
 275             int val = matches[pos+index] - ch;
 276             if (!val)
 277                 return;
 278             else if (val &gt; 0) {
 279                 if (val == 1) {
 280                     UChar32 lo = ch;
 281                     UChar32 hi = ch + 1;
 282                     matches.remove(pos + index);
 283                     if (pos + index &gt; 0 &amp;&amp; matches[pos + index - 1] == ch - 1) {
 284                         lo = ch - 1;
 285                         matches.remove(pos + index - 1);
 286                     }
 287                     addSortedRange(isASCII(ch) ? m_ranges : m_rangesUnicode, lo, hi);
 288                     return;
 289                 }
</pre>
<hr />
<pre>
 298                         matches.remove(pos + index + 1);
 299                     }
 300                     addSortedRange(isASCII(ch) ? m_ranges : m_rangesUnicode, lo, hi);
 301                     return;
 302                 }
 303                 pos += (index+1);
 304                 range -= (index+1);
 305             }
 306         }
 307 
 308         if (pos == matches.size())
 309             matches.append(ch);
 310         else
 311             matches.insert(pos, ch);
 312     }
 313 
 314     void addSortedRange(Vector&lt;CharacterRange&gt;&amp; ranges, UChar32 lo, UChar32 hi)
 315     {
 316         size_t end = ranges.size();
 317 
<span class="line-added"> 318         if (U_IS_BMP(lo))</span>
<span class="line-added"> 319             m_characterWidths |= CharacterClassWidths::HasBMPChars;</span>
 320         if (!U_IS_BMP(hi))
<span class="line-modified"> 321             m_characterWidths |= CharacterClassWidths::HasNonBMPChars;</span>
 322 
 323         // Simple linear scan - I doubt there are that many ranges anyway...
 324         // feel free to fix this with something faster (eg binary chop).
 325         for (size_t i = 0; i &lt; end; ++i) {
 326             // does the new range fall before the current position in the array
 327             if (hi &lt; ranges[i].begin) {
 328                 // Concatenate appending ranges.
 329                 if (hi == (ranges[i].begin - 1)) {
 330                     ranges[i].begin = lo;
 331                     return;
 332                 }
 333                 ranges.insert(i, CharacterRange(lo, hi));
 334                 return;
 335             }
 336             // Okay, since we didn&#39;t hit the last case, the end of the new range is definitely at or after the begining
 337             // If the new range start at or before the end of the last range, then the overlap (if it starts one after the
 338             // end of the last range they concatenate, which is just as good.
 339             if (lo &lt;= (ranges[i].end + 1)) {
 340                 // found an intersect! we&#39;ll replace this entry in the array.
 341                 ranges[i].begin = std::min(ranges[i].begin, lo);
</pre>
<hr />
<pre>
 392 
 393                         mergeRangesFrom(ranges, rangesIndex);
 394                     } else
 395                         matchesIndex++;
 396                 }
 397             }
 398         };
 399 
 400         coalesceMatchesAndRanges(m_matches, m_ranges);
 401         coalesceMatchesAndRanges(m_matchesUnicode, m_rangesUnicode);
 402 
 403         if (!m_matches.size() &amp;&amp; !m_matchesUnicode.size()
 404             &amp;&amp; m_ranges.size() == 1 &amp;&amp; m_rangesUnicode.size() == 1
 405             &amp;&amp; m_ranges[0].begin == 0 &amp;&amp; m_ranges[0].end == 0x7f
 406             &amp;&amp; m_rangesUnicode[0].begin == 0x80 &amp;&amp; m_rangesUnicode[0].end == 0x10ffff)
 407             m_anyCharacter = true;
 408     }
 409 
 410     bool hasNonBMPCharacters()
 411     {
<span class="line-modified"> 412         return m_characterWidths &amp; CharacterClassWidths::HasNonBMPChars;</span>
<span class="line-added"> 413     }</span>
<span class="line-added"> 414 </span>
<span class="line-added"> 415     CharacterClassWidths characterWidths()</span>
<span class="line-added"> 416     {</span>
<span class="line-added"> 417         return m_characterWidths;</span>
 418     }
 419 
 420     bool anyCharacter()
 421     {
 422         return m_anyCharacter;
 423     }
 424 
 425     bool m_isCaseInsensitive : 1;

 426     bool m_anyCharacter : 1;
<span class="line-added"> 427     CharacterClassWidths m_characterWidths;</span>
<span class="line-added"> 428 </span>
 429     CanonicalMode m_canonicalMode;
 430 
 431     Vector&lt;UChar32&gt; m_matches;
 432     Vector&lt;CharacterRange&gt; m_ranges;
 433     Vector&lt;UChar32&gt; m_matchesUnicode;
 434     Vector&lt;CharacterRange&gt; m_rangesUnicode;
 435 };
 436 
 437 class YarrPatternConstructor {
 438 public:
 439     YarrPatternConstructor(YarrPattern&amp; pattern, void* stackLimit)
 440         : m_pattern(pattern)
 441         , m_characterClassConstructor(pattern.ignoreCase(), pattern.unicode() ? CanonicalMode::Unicode : CanonicalMode::UCS2)
 442         , m_stackLimit(stackLimit)
 443     {
<span class="line-modified"> 444         auto body = makeUnique&lt;PatternDisjunction&gt;();</span>
 445         m_pattern.m_body = body.get();
 446         m_alternative = body-&gt;addNewAlternative();
 447         m_pattern.m_disjunctions.append(WTFMove(body));
 448     }
 449 
 450     ~YarrPatternConstructor()
 451     {
 452     }
 453 
 454     void resetForReparsing()
 455     {
 456         m_pattern.resetForReparsing();
 457         m_characterClassConstructor.reset();
 458 
<span class="line-modified"> 459         auto body = makeUnique&lt;PatternDisjunction&gt;();</span>
 460         m_pattern.m_body = body.get();
 461         m_alternative = body-&gt;addNewAlternative();
 462         m_pattern.m_disjunctions.append(WTFMove(body));
 463     }
 464 
 465     void saveUnmatchedNamedForwardReferences()
 466     {
 467         m_unmatchedNamedForwardReferences.shrink(0);
 468 
 469         for (auto&amp; entry : m_pattern.m_namedForwardReferences) {
 470             if (!m_pattern.m_captureGroupNames.contains(entry))
 471                 m_unmatchedNamedForwardReferences.append(entry);
 472         }
 473     }
 474 
 475     void assertionBOL()
 476     {
 477         if (!m_alternative-&gt;m_terms.size() &amp;&amp; !m_invertParentheticalAssertion) {
 478             m_alternative-&gt;m_startsWithBOL = true;
 479             m_alternative-&gt;m_containsBOL = true;
</pre>
<hr />
<pre>
 591             return;
 592         }
 593         m_alternative-&gt;m_terms.append(PatternTerm(newCharacterClass.get(), m_invertCharacterClass));
 594         m_pattern.m_userCharacterClasses.append(WTFMove(newCharacterClass));
 595     }
 596 
 597     void atomParenthesesSubpatternBegin(bool capture = true, Optional&lt;String&gt; optGroupName = WTF::nullopt)
 598     {
 599         unsigned subpatternId = m_pattern.m_numSubpatterns + 1;
 600         if (capture) {
 601             m_pattern.m_numSubpatterns++;
 602             if (optGroupName) {
 603                 while (m_pattern.m_captureGroupNames.size() &lt; subpatternId)
 604                     m_pattern.m_captureGroupNames.append(String());
 605                 m_pattern.m_captureGroupNames.append(optGroupName.value());
 606                 m_pattern.m_namedGroupToParenIndex.add(optGroupName.value(), subpatternId);
 607             }
 608         } else
 609             ASSERT(!optGroupName);
 610 
<span class="line-modified"> 611         auto parenthesesDisjunction = makeUnique&lt;PatternDisjunction&gt;(m_alternative);</span>
 612         m_alternative-&gt;m_terms.append(PatternTerm(PatternTerm::TypeParenthesesSubpattern, subpatternId, parenthesesDisjunction.get(), capture, false));
 613         m_alternative = parenthesesDisjunction-&gt;addNewAlternative();
 614         m_pattern.m_disjunctions.append(WTFMove(parenthesesDisjunction));
 615     }
 616 
 617     void atomParentheticalAssertionBegin(bool invert = false)
 618     {
<span class="line-modified"> 619         auto parenthesesDisjunction = makeUnique&lt;PatternDisjunction&gt;(m_alternative);</span>
 620         m_alternative-&gt;m_terms.append(PatternTerm(PatternTerm::TypeParentheticalAssertion, m_pattern.m_numSubpatterns + 1, parenthesesDisjunction.get(), false, invert));
 621         m_alternative = parenthesesDisjunction-&gt;addNewAlternative();
 622         m_invertParentheticalAssertion = invert;
 623         m_pattern.m_disjunctions.append(WTFMove(parenthesesDisjunction));
 624     }
 625 
 626     void atomParenthesesEnd()
 627     {
 628         ASSERT(m_alternative-&gt;m_parent);
 629         ASSERT(m_alternative-&gt;m_parent-&gt;m_parent);
 630 
 631         PatternDisjunction* parenthesesDisjunction = m_alternative-&gt;m_parent;
 632         m_alternative = m_alternative-&gt;m_parent-&gt;m_parent;
 633 
 634         PatternTerm&amp; lastTerm = m_alternative-&gt;lastTerm();
 635 
 636         unsigned numParenAlternatives = parenthesesDisjunction-&gt;m_alternatives.size();
 637         unsigned numBOLAnchoredAlts = 0;
 638 
 639         for (unsigned i = 0; i &lt; numParenAlternatives; i++) {
</pre>
<hr />
<pre>
 685     {
 686         ASSERT(m_pattern.m_namedGroupToParenIndex.find(subpatternName) != m_pattern.m_namedGroupToParenIndex.end());
 687         atomBackReference(m_pattern.m_namedGroupToParenIndex.get(subpatternName));
 688     }
 689 
 690     bool isValidNamedForwardReference(const String&amp; subpatternName)
 691     {
 692         return !m_unmatchedNamedForwardReferences.contains(subpatternName);
 693     }
 694 
 695     void atomNamedForwardReference(const String&amp; subpatternName)
 696     {
 697         m_pattern.m_namedForwardReferences.appendIfNotContains(subpatternName);
 698         m_alternative-&gt;m_terms.append(PatternTerm::ForwardReference());
 699     }
 700 
 701     // deep copy the argument disjunction.  If filterStartsWithBOL is true,
 702     // skip alternatives with m_startsWithBOL set true.
 703     PatternDisjunction* copyDisjunction(PatternDisjunction* disjunction, bool filterStartsWithBOL = false)
 704     {
<span class="line-added"> 705         if (UNLIKELY(!isSafeToRecurse())) {</span>
<span class="line-added"> 706             m_error = ErrorCode::PatternTooLarge;</span>
<span class="line-added"> 707             return 0;</span>
<span class="line-added"> 708         }</span>
<span class="line-added"> 709 </span>
 710         std::unique_ptr&lt;PatternDisjunction&gt; newDisjunction;
 711         for (unsigned alt = 0; alt &lt; disjunction-&gt;m_alternatives.size(); ++alt) {
 712             PatternAlternative* alternative = disjunction-&gt;m_alternatives[alt].get();
 713             if (!filterStartsWithBOL || !alternative-&gt;m_startsWithBOL) {
 714                 if (!newDisjunction) {
<span class="line-modified"> 715                     newDisjunction = makeUnique&lt;PatternDisjunction&gt;();</span>
 716                     newDisjunction-&gt;m_parent = disjunction-&gt;m_parent;
 717                 }
 718                 PatternAlternative* newAlternative = newDisjunction-&gt;addNewAlternative();
 719                 newAlternative-&gt;m_terms.reserveInitialCapacity(alternative-&gt;m_terms.size());
 720                 for (unsigned i = 0; i &lt; alternative-&gt;m_terms.size(); ++i)
 721                     newAlternative-&gt;m_terms.append(copyTerm(alternative-&gt;m_terms[i], filterStartsWithBOL));
 722             }
 723         }
 724 
<span class="line-added"> 725         if (hasError(error())) {</span>
<span class="line-added"> 726             newDisjunction = 0;</span>
<span class="line-added"> 727             return 0;</span>
<span class="line-added"> 728         }</span>
<span class="line-added"> 729 </span>
 730         if (!newDisjunction)
 731             return 0;
 732 
 733         PatternDisjunction* copiedDisjunction = newDisjunction.get();
 734         m_pattern.m_disjunctions.append(WTFMove(newDisjunction));
 735         return copiedDisjunction;
 736     }
 737 
 738     PatternTerm copyTerm(PatternTerm&amp; term, bool filterStartsWithBOL = false)
 739     {
<span class="line-added"> 740         if (UNLIKELY(!isSafeToRecurse())) {</span>
<span class="line-added"> 741             m_error = ErrorCode::PatternTooLarge;</span>
<span class="line-added"> 742             return PatternTerm(term);</span>
<span class="line-added"> 743         }</span>
<span class="line-added"> 744 </span>
 745         if ((term.type != PatternTerm::TypeParenthesesSubpattern) &amp;&amp; (term.type != PatternTerm::TypeParentheticalAssertion))
 746             return PatternTerm(term);
 747 
 748         PatternTerm termCopy = term;
 749         termCopy.parentheses.disjunction = copyDisjunction(termCopy.parentheses.disjunction, filterStartsWithBOL);
 750         m_pattern.m_hasCopiedParenSubexpressions = true;
 751         return termCopy;
 752     }
 753 
 754     void quantifyAtom(unsigned min, unsigned max, bool greedy)
 755     {
 756         ASSERT(min &lt;= max);
 757         ASSERT(m_alternative-&gt;m_terms.size());
 758 
 759         if (!max) {
 760             m_alternative-&gt;removeLastTerm();
 761             return;
 762         }
 763 
 764         PatternTerm&amp; term = m_alternative-&gt;lastTerm();
</pre>
<hr />
<pre>
 841                     alternative-&gt;m_hasFixedSize = false;
 842                 } else if (m_pattern.unicode()) {
 843                     Checked&lt;unsigned, RecordOverflow&gt; tempCount = term.quantityMaxCount;
 844                     tempCount *= U16_LENGTH(term.patternCharacter);
 845                     if (tempCount.hasOverflowed())
 846                         return ErrorCode::OffsetTooLarge;
 847                     currentInputPosition += tempCount;
 848                 } else
 849                     currentInputPosition += term.quantityMaxCount;
 850                 break;
 851 
 852             case PatternTerm::TypeCharacterClass:
 853                 term.inputPosition = currentInputPosition.unsafeGet();
 854                 if (term.quantityType != QuantifierFixedCount) {
 855                     term.frameLocation = currentCallFrameSize;
 856                     currentCallFrameSize += YarrStackSpaceForBackTrackInfoCharacterClass;
 857                     alternative-&gt;m_hasFixedSize = false;
 858                 } else if (m_pattern.unicode()) {
 859                     term.frameLocation = currentCallFrameSize;
 860                     currentCallFrameSize += YarrStackSpaceForBackTrackInfoCharacterClass;
<span class="line-modified"> 861                     if (term.characterClass-&gt;hasOneCharacterSize() &amp;&amp; !term.invert()) {</span>
<span class="line-modified"> 862                         Checked&lt;unsigned, RecordOverflow&gt; tempCount = term.quantityMaxCount;</span>
<span class="line-added"> 863                         tempCount *= term.characterClass-&gt;hasNonBMPCharacters() ? 2 : 1;</span>
<span class="line-added"> 864                         if (tempCount.hasOverflowed())</span>
<span class="line-added"> 865                             return ErrorCode::OffsetTooLarge;</span>
<span class="line-added"> 866                         currentInputPosition += tempCount;</span>
<span class="line-added"> 867                     } else {</span>
<span class="line-added"> 868                         currentInputPosition += term.quantityMaxCount;</span>
<span class="line-added"> 869                         alternative-&gt;m_hasFixedSize = false;</span>
<span class="line-added"> 870                     }</span>
 871                 } else
 872                     currentInputPosition += term.quantityMaxCount;
 873                 break;
 874 
 875             case PatternTerm::TypeParenthesesSubpattern:
 876                 // Note: for fixed once parentheses we will ensure at least the minimum is available; others are on their own.
 877                 term.frameLocation = currentCallFrameSize;
 878                 if (term.quantityMaxCount == 1 &amp;&amp; !term.parentheses.isCopy) {
 879                     currentCallFrameSize += YarrStackSpaceForBackTrackInfoParenthesesOnce;
 880                     error = setupDisjunctionOffsets(term.parentheses.disjunction, currentCallFrameSize, currentInputPosition.unsafeGet(), currentCallFrameSize);
 881                     if (hasError(error))
 882                         return error;
 883                     // If quantity is fixed, then pre-check its minimum size.
 884                     if (term.quantityType == QuantifierFixedCount)
 885                         currentInputPosition += term.parentheses.disjunction-&gt;m_minimumSize;
 886                     term.inputPosition = currentInputPosition.unsafeGet();
 887                 } else if (term.parentheses.isTerminal) {
 888                     currentCallFrameSize += YarrStackSpaceForBackTrackInfoParenthesesTerminal;
 889                     error = setupDisjunctionOffsets(term.parentheses.disjunction, currentCallFrameSize, currentInputPosition.unsafeGet(), currentCallFrameSize);
 890                     if (hasError(error))
</pre>
<hr />
<pre>
1098                 return;
1099 
1100             size_t endIndex = termIndex;
1101             if (firstExpressionTerm &gt;= endIndex)
1102                 return;
1103 
1104             if (!containsCapturingTerms(alternative, firstExpressionTerm, endIndex)) {
1105                 for (termIndex = terms.size() - 1; termIndex &gt;= endIndex; --termIndex)
1106                     terms.remove(termIndex);
1107 
1108                 for (termIndex = firstExpressionTerm; termIndex &gt; 0; --termIndex)
1109                     terms.remove(termIndex - 1);
1110 
1111                 terms.append(PatternTerm(startsWithBOL, endsWithEOL));
1112 
1113                 m_pattern.m_containsBOL = false;
1114             }
1115         }
1116     }
1117 
<span class="line-added">1118     ErrorCode error() { return m_error; }</span>
<span class="line-added">1119 </span>
1120 private:
1121     bool isSafeToRecurse() const
1122     {
1123         if (!m_stackLimit)
1124             return true;
1125         ASSERT(Thread::current().stack().isGrowingDownward());
1126         int8_t* curr = reinterpret_cast&lt;int8_t*&gt;(currentStackPointer());
1127         int8_t* limit = reinterpret_cast&lt;int8_t*&gt;(m_stackLimit);
1128         return curr &gt;= limit;
1129     }
1130 
1131     YarrPattern&amp; m_pattern;
1132     PatternAlternative* m_alternative;
1133     CharacterClassConstructor m_characterClassConstructor;
1134     Vector&lt;String&gt; m_unmatchedNamedForwardReferences;
1135     void* m_stackLimit;
<span class="line-added">1136     ErrorCode m_error { ErrorCode::NoError };</span>
1137     bool m_invertCharacterClass;
1138     bool m_invertParentheticalAssertion { false };
1139 };
1140 
1141 ErrorCode YarrPattern::compile(const String&amp; patternString, void* stackLimit)
1142 {
1143     YarrPatternConstructor constructor(*this, stackLimit);
1144 



1145     {
1146         ErrorCode error = parse(constructor, patternString, unicode());
1147         if (hasError(error))
1148             return error;
1149     }
1150 
1151     // If the pattern contains illegal backreferences reset &amp; reparse.
1152     // Quoting Netscape&#39;s &quot;What&#39;s new in JavaScript 1.2&quot;,
1153     //      &quot;Note: if the number of left parentheses is less than the number specified
1154     //       in \#, the \# is taken as an octal escape as described in the next row.&quot;
1155     if (containsIllegalBackReference() || containsIllegalNamedForwardReferences()) {
1156         if (unicode())
1157             return ErrorCode::InvalidBackreference;
1158 
1159         unsigned numSubpatterns = m_numSubpatterns;
1160 
1161         constructor.saveUnmatchedNamedForwardReferences();
1162         constructor.resetForReparsing();
1163         ErrorCode error = parse(constructor, patternString, unicode(), numSubpatterns);
1164         ASSERT_UNUSED(error, !hasError(error));
1165         ASSERT(numSubpatterns == m_numSubpatterns);
1166     }
1167 
1168     constructor.checkForTerminalParentheses();
1169     constructor.optimizeDotStarWrappedExpressions();
1170     constructor.optimizeBOL();
1171 
<span class="line-added">1172     if (hasError(constructor.error()))</span>
<span class="line-added">1173         return constructor.error();</span>
<span class="line-added">1174 </span>
1175     {
1176         ErrorCode error = constructor.setupOffsets();
1177         if (hasError(error))
1178             return error;
1179     }
1180 
1181     if (Options::dumpCompiledRegExpPatterns())
1182         dumpPattern(patternString);
1183 
1184     return ErrorCode::NoError;
1185 }
1186 
<span class="line-modified">1187 YarrPattern::YarrPattern(const String&amp; pattern, OptionSet&lt;Flags&gt; flags, ErrorCode&amp; error, void* stackLimit)</span>
1188     : m_containsBackreferences(false)
1189     , m_containsBOL(false)
1190     , m_containsUnsignedLengthPattern(false)
1191     , m_hasCopiedParenSubexpressions(false)
1192     , m_saveInitialStartValue(false)
1193     , m_flags(flags)
1194 {
<span class="line-added">1195     ASSERT(m_flags != Flags::DeletedValue);</span>
1196     error = compile(pattern, stackLimit);
1197 }
1198 
1199 void indentForNestingLevel(PrintStream&amp; out, unsigned nestingDepth)
1200 {
1201     out.print(&quot;    &quot;);
1202     for (; nestingDepth; --nestingDepth)
1203         out.print(&quot;  &quot;);
1204 }
1205 
1206 void dumpUChar32(PrintStream&amp; out, UChar32 c)
1207 {
1208     if (c &gt;= &#39; &#39;&amp;&amp; c &lt;= 0xff)
1209         out.printf(&quot;&#39;%c&#39;&quot;, static_cast&lt;char&gt;(c));
1210     else
1211         out.printf(&quot;0x%04x&quot;, c);
1212 }
1213 
1214 void dumpCharacterClass(PrintStream&amp; out, YarrPattern* pattern, CharacterClass* characterClass)
1215 {
</pre>
<hr />
<pre>
1337         break;
1338     case TypeAssertionWordBoundary:
1339         out.println(&quot;word boundary&quot;);
1340         break;
1341     case TypePatternCharacter:
1342         out.printf(&quot;character &quot;);
1343         out.printf(&quot;inputPosition %u &quot;, inputPosition);
1344         if (thisPattern-&gt;ignoreCase() &amp;&amp; isASCIIAlpha(patternCharacter)) {
1345             dumpUChar32(out, toASCIIUpper(patternCharacter));
1346             out.print(&quot;/&quot;);
1347             dumpUChar32(out, toASCIILower(patternCharacter));
1348         } else
1349             dumpUChar32(out, patternCharacter);
1350         dumpQuantifier(out);
1351         if (quantityType != QuantifierFixedCount)
1352             out.print(&quot;,frame location &quot;, frameLocation);
1353         out.println();
1354         break;
1355     case TypeCharacterClass:
1356         out.print(&quot;character class &quot;);
<span class="line-added">1357         out.printf(&quot;inputPosition %u &quot;, inputPosition);</span>
1358         dumpCharacterClass(out, thisPattern, characterClass);
1359         dumpQuantifier(out);
1360         if (quantityType != QuantifierFixedCount || thisPattern-&gt;unicode())
1361             out.print(&quot;,frame location &quot;, frameLocation);
1362         out.println();
1363         break;
1364     case TypeBackReference:
1365         out.print(&quot;back reference to subpattern #&quot;, backReferenceSubpatternId);
1366         out.println(&quot;,frame location &quot;, frameLocation);
1367         break;
1368     case TypeForwardReference:
1369         out.println(&quot;forward reference&quot;);
1370         break;
1371     case TypeParenthesesSubpattern:
1372         if (m_capture)
1373             out.print(&quot;captured &quot;);
1374         else
1375             out.print(&quot;non-captured &quot;);
1376 
1377         FALLTHROUGH;
</pre>
<hr />
<pre>
1437     if (ignoreCase())
1438         out.print(&quot;i&quot;);
1439     if (multiline())
1440         out.print(&quot;m&quot;);
1441     if (unicode())
1442         out.print(&quot;u&quot;);
1443     if (sticky())
1444         out.print(&quot;y&quot;);
1445 }
1446 
1447 void YarrPattern::dumpPattern(const String&amp; patternString)
1448 {
1449     dumpPattern(WTF::dataFile(), patternString);
1450 }
1451 
1452 void YarrPattern::dumpPattern(PrintStream&amp; out, const String&amp; patternString)
1453 {
1454     out.print(&quot;RegExp pattern for &quot;);
1455     dumpPatternString(out, patternString);
1456 
<span class="line-modified">1457     if (m_flags) {</span>
<span class="line-modified">1458         bool printSeparator = false;</span>
1459         out.print(&quot; (&quot;);
1460         if (global()) {
1461             out.print(&quot;global&quot;);
<span class="line-modified">1462             printSeparator = true;</span>
1463         }
1464         if (ignoreCase()) {
<span class="line-modified">1465             if (printSeparator)</span>
1466                 out.print(&quot;|&quot;);
1467             out.print(&quot;ignore case&quot;);
<span class="line-modified">1468             printSeparator = true;</span>
1469         }
1470         if (multiline()) {
<span class="line-modified">1471             if (printSeparator)</span>
1472                 out.print(&quot;|&quot;);
1473             out.print(&quot;multiline&quot;);
<span class="line-modified">1474             printSeparator = true;</span>
1475         }
1476         if (unicode()) {
<span class="line-modified">1477             if (printSeparator)</span>
1478                 out.print(&quot;|&quot;);
1479             out.print(&quot;unicode&quot;);
<span class="line-modified">1480             printSeparator = true;</span>
1481         }
1482         if (sticky()) {
<span class="line-modified">1483             if (printSeparator)</span>
1484                 out.print(&quot;|&quot;);
1485             out.print(&quot;sticky&quot;);

1486         }
1487         out.print(&quot;)&quot;);
1488     }
1489     out.print(&quot;:\n&quot;);
1490     if (m_body-&gt;m_callFrameSize)
1491         out.print(&quot;    callframe size: &quot;, m_body-&gt;m_callFrameSize, &quot;\n&quot;);
1492     m_body-&gt;dump(out, this);
1493 }
1494 
1495 std::unique_ptr&lt;CharacterClass&gt; anycharCreate()
1496 {
<span class="line-modified">1497     auto characterClass = makeUnique&lt;CharacterClass&gt;();</span>
1498     characterClass-&gt;m_ranges.append(CharacterRange(0x00, 0x7f));
1499     characterClass-&gt;m_rangesUnicode.append(CharacterRange(0x0080, 0x10ffff));
<span class="line-modified">1500     characterClass-&gt;m_characterWidths = CharacterClassWidths::HasBothBMPAndNonBMP;</span>
1501     characterClass-&gt;m_anyCharacter = true;
1502     return characterClass;
1503 }
1504 
1505 } } // namespace JSC::Yarr
</pre>
</td>
</tr>
</table>
<center><a href="YarrParser.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="YarrPattern.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>