<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WebCore/svg/SVGDocumentExtensions.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2006 Apple Inc. All rights reserved.
  3  * Copyright (C) 2006, 2008 Nikolas Zimmermann &lt;zimmermann@kde.org&gt;
  4  *
  5  * This library is free software; you can redistribute it and/or
  6  * modify it under the terms of the GNU Library General Public
  7  * License as published by the Free Software Foundation; either
  8  * version 2 of the License, or (at your option) any later version.
  9  *
 10  * This library is distributed in the hope that it will be useful,
 11  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 12  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 13  * Library General Public License for more details.
 14  *
 15  * You should have received a copy of the GNU Library General Public License
 16  * along with this library; see the file COPYING.LIB.  If not, write to
 17  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 18  * Boston, MA 02110-1301, USA.
 19  */
 20 
 21 #pragma once
 22 
 23 #include &lt;wtf/Forward.h&gt;
 24 #include &lt;wtf/HashMap.h&gt;
 25 #include &lt;wtf/HashSet.h&gt;
 26 #include &lt;wtf/text/AtomicStringHash.h&gt;
 27 
 28 namespace WebCore {
 29 
 30 class Document;
 31 class Element;
 32 class RenderSVGResourceContainer;
 33 class SVGElement;
 34 class SVGFontFaceElement;
 35 class SVGResourcesCache;
 36 class SVGSMILElement;
 37 class SVGSVGElement;
 38 
 39 class SVGDocumentExtensions {
 40     WTF_MAKE_NONCOPYABLE(SVGDocumentExtensions); WTF_MAKE_FAST_ALLOCATED;
 41 public:
 42     typedef HashSet&lt;Element*&gt; PendingElements;
 43     explicit SVGDocumentExtensions(Document&amp;);
 44     ~SVGDocumentExtensions();
 45 
 46     void addTimeContainer(SVGSVGElement&amp;);
 47     void removeTimeContainer(SVGSVGElement&amp;);
 48 
 49     void addResource(const AtomicString&amp; id, RenderSVGResourceContainer&amp;);
 50     void removeResource(const AtomicString&amp; id);
 51     RenderSVGResourceContainer* resourceById(const AtomicString&amp; id) const;
 52 
 53     void startAnimations();
 54     void pauseAnimations();
 55     void unpauseAnimations();
 56     void dispatchSVGLoadEventToOutermostSVGElements();
 57     bool areAnimationsPaused() const { return m_areAnimationsPaused; }
 58 
 59     void reportWarning(const String&amp;);
 60     void reportError(const String&amp;);
 61 
 62     SVGResourcesCache&amp; resourcesCache() { return *m_resourcesCache; }
 63 
 64     HashSet&lt;SVGElement*&gt;* setOfElementsReferencingTarget(SVGElement&amp; referencedElement) const;
 65     void addElementReferencingTarget(SVGElement&amp; referencingElement, SVGElement&amp; referencedElement);
 66     void removeAllTargetReferencesForElement(SVGElement&amp;);
 67     void rebuildAllElementReferencesForTarget(SVGElement&amp;);
 68     void removeAllElementReferencesForTarget(SVGElement&amp;);
 69 
 70     void clearTargetDependencies(SVGElement&amp;);
 71     void rebuildElements();
 72 
 73 #if ENABLE(SVG_FONTS)
 74     const HashSet&lt;SVGFontFaceElement*&gt;&amp; svgFontFaceElements() const { return m_svgFontFaceElements; }
 75     void registerSVGFontFaceElement(SVGFontFaceElement&amp;);
 76     void unregisterSVGFontFaceElement(SVGFontFaceElement&amp;);
 77 #endif
 78 
 79 private:
 80     Document&amp; m_document;
 81     HashSet&lt;SVGSVGElement*&gt; m_timeContainers; // For SVG 1.2 support this will need to be made more general.
 82 #if ENABLE(SVG_FONTS)
 83     HashSet&lt;SVGFontFaceElement*&gt; m_svgFontFaceElements;
 84 #endif
 85     HashMap&lt;AtomicString, RenderSVGResourceContainer*&gt; m_resources;
 86     HashMap&lt;AtomicString, std::unique_ptr&lt;PendingElements&gt;&gt; m_pendingResources; // Resources that are pending.
 87     HashMap&lt;AtomicString, std::unique_ptr&lt;PendingElements&gt;&gt; m_pendingResourcesForRemoval; // Resources that are pending and scheduled for removal.
 88     HashMap&lt;SVGElement*, std::unique_ptr&lt;HashSet&lt;SVGElement*&gt;&gt;&gt; m_elementDependencies;
 89     std::unique_ptr&lt;SVGResourcesCache&gt; m_resourcesCache;
 90 
 91     Vector&lt;SVGElement*&gt; m_rebuildElements;
 92     bool m_areAnimationsPaused;
 93 
 94 public:
 95     // This HashMap contains a list of pending resources. Pending resources, are such
 96     // which are referenced by any object in the SVG document, but do NOT exist yet.
 97     // For instance, dynamically build gradients / patterns / clippers...
 98     void addPendingResource(const AtomicString&amp; id, Element&amp;);
 99     bool isIdOfPendingResource(const AtomicString&amp; id) const;
100     bool isPendingResource(Element&amp;, const AtomicString&amp; id) const;
101     void clearHasPendingResourcesIfPossible(Element&amp;);
102     void removeElementFromPendingResources(Element&amp;);
103     std::unique_ptr&lt;PendingElements&gt; removePendingResource(const AtomicString&amp; id);
104 
105     // The following two functions are used for scheduling a pending resource to be removed.
106     void markPendingResourcesForRemoval(const AtomicString&amp;);
107     RefPtr&lt;Element&gt; removeElementFromPendingResourcesForRemovalMap(const AtomicString&amp;);
108 
109 private:
110     bool isElementWithPendingResources(Element&amp;) const;
111     std::unique_ptr&lt;PendingElements&gt; removePendingResourceForRemoval(const AtomicString&amp;);
112 };
113 
114 } // namespace WebCore
    </pre>
  </body>
</html>