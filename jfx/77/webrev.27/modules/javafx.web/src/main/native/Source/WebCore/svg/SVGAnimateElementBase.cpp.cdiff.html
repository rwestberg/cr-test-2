<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/svg/SVGAnimateElementBase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SVGAnimateElement.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SVGAnimateElementBase.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/svg/SVGAnimateElementBase.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,9 ***</span>
  /*
   * Copyright (C) 2004, 2005 Nikolas Zimmermann &lt;zimmermann@kde.org&gt;
   * Copyright (C) 2004, 2005, 2006 Rob Buis &lt;buis@kde.org&gt;
<span class="line-modified">!  * Copyright (C) 2008 Apple Inc. All rights reserved.</span>
   * Copyright (C) Research In Motion Limited 2011. All rights reserved.
   * Copyright (C) 2014 Adobe Systems Incorporated. All rights reserved.
   *
   * This library is free software; you can redistribute it and/or
   * modify it under the terms of the GNU Library General Public
<span class="line-new-header">--- 1,9 ---</span>
  /*
   * Copyright (C) 2004, 2005 Nikolas Zimmermann &lt;zimmermann@kde.org&gt;
   * Copyright (C) 2004, 2005, 2006 Rob Buis &lt;buis@kde.org&gt;
<span class="line-modified">!  * Copyright (C) 2008-2019 Apple Inc. All rights reserved.</span>
   * Copyright (C) Research In Motion Limited 2011. All rights reserved.
   * Copyright (C) 2014 Adobe Systems Incorporated. All rights reserved.
   *
   * This library is free software; you can redistribute it and/or
   * modify it under the terms of the GNU Library General Public
</pre>
<hr />
<pre>
<span class="line-old-header">*** 22,443 ***</span>
   */
  
  #include &quot;config.h&quot;
  #include &quot;SVGAnimateElementBase.h&quot;
  
<span class="line-removed">- #include &quot;CSSPropertyNames.h&quot;</span>
<span class="line-removed">- #include &quot;CSSPropertyParser.h&quot;</span>
  #include &quot;QualifiedName.h&quot;
<span class="line-modified">! #include &quot;RenderObject.h&quot;</span>
<span class="line-removed">- #include &quot;SVGAnimatorFactory.h&quot;</span>
  #include &quot;SVGElement.h&quot;
  #include &quot;SVGNames.h&quot;
<span class="line-removed">- #include &quot;StyleProperties.h&quot;</span>
  #include &lt;wtf/IsoMallocInlines.h&gt;
  
  namespace WebCore {
  
  WTF_MAKE_ISO_ALLOCATED_IMPL(SVGAnimateElementBase);
  
  SVGAnimateElementBase::SVGAnimateElementBase(const QualifiedName&amp; tagName, Document&amp; document)
      : SVGAnimationElement(tagName, document)
<span class="line-removed">-     , m_animatedPropertyType(AnimatedString)</span>
  {
<span class="line-modified">!     ASSERT(hasTagName(SVGNames::animateTag) || hasTagName(SVGNames::setTag) || hasTagName(SVGNames::animateColorTag) || hasTagName(SVGNames::animateTransformTag));</span>
  }
  
<span class="line-modified">! SVGAnimateElementBase::~SVGAnimateElementBase() = default;</span>
<span class="line-removed">- </span>
<span class="line-removed">- bool SVGAnimateElementBase::hasValidAttributeType()</span>
  {
<span class="line-modified">!     if (!this-&gt;targetElement())</span>
<span class="line-modified">!         return false;</span>
  
<span class="line-modified">!     return m_animatedPropertyType != AnimatedUnknown &amp;&amp; !hasInvalidCSSAttributeType();</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! AnimatedPropertyType SVGAnimateElementBase::determineAnimatedPropertyType(SVGElement&amp; targetElement) const</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     auto propertyTypes = targetElement.animatedPropertyTypesForAttribute(attributeName());</span>
<span class="line-removed">-     if (propertyTypes.isEmpty())</span>
<span class="line-removed">-         return AnimatedUnknown;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     ASSERT(propertyTypes.size() &lt;= 2);</span>
<span class="line-removed">-     AnimatedPropertyType type = propertyTypes[0];</span>
<span class="line-removed">-     if (hasTagName(SVGNames::animateColorTag) &amp;&amp; type != AnimatedColor)</span>
<span class="line-removed">-         return AnimatedUnknown;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // Animations of transform lists are not allowed for &lt;animate&gt; or &lt;set&gt;</span>
<span class="line-removed">-     // http://www.w3.org/TR/SVG/animate.html#AnimationAttributesAndProperties</span>
<span class="line-removed">-     if (type == AnimatedTransformList &amp;&amp; !hasTagName(SVGNames::animateTransformTag))</span>
<span class="line-removed">-         return AnimatedUnknown;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // Fortunately there&#39;s just one special case needed here: SVGMarkerElements orientAttr, which</span>
<span class="line-removed">-     // corresponds to SVGAnimatedAngle orientAngle and SVGAnimatedEnumeration orientType. We have to</span>
<span class="line-removed">-     // figure out whose value to change here.</span>
<span class="line-removed">-     if (targetElement.hasTagName(SVGNames::markerTag) &amp;&amp; type == AnimatedAngle) {</span>
<span class="line-removed">-         ASSERT(propertyTypes.size() == 2);</span>
<span class="line-removed">-         ASSERT(propertyTypes[0] == AnimatedAngle);</span>
<span class="line-removed">-         ASSERT(propertyTypes[1] == AnimatedEnumeration);</span>
<span class="line-removed">-     } else if (propertyTypes.size() == 2)</span>
<span class="line-removed">-         ASSERT(propertyTypes[0] == propertyTypes[1]);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     return type;</span>
  }
  
<span class="line-modified">! void SVGAnimateElementBase::calculateAnimatedValue(float percentage, unsigned repeatCount, SVGSMILElement* resultElement)</span>
  {
<span class="line-modified">!     ASSERT(resultElement);</span>
<span class="line-modified">!     auto targetElement = makeRefPtr(this-&gt;targetElement());</span>
<span class="line-removed">-     if (!targetElement)</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     const QualifiedName&amp; attributeName = this-&gt;attributeName();</span>
<span class="line-removed">-     ShouldApplyAnimation shouldApply = shouldApplyAnimation(targetElement.get(), attributeName);</span>
  
<span class="line-modified">!     if (shouldApply == DontApplyAnimation)</span>
<span class="line-modified">!         return;</span>
  
<span class="line-modified">!     ASSERT(m_animatedPropertyType == determineAnimatedPropertyType(*targetElement));</span>
<span class="line-modified">! </span>
<span class="line-modified">!     ASSERT(percentage &gt;= 0 &amp;&amp; percentage &lt;= 1);</span>
<span class="line-modified">!     ASSERT(m_animatedPropertyType != AnimatedTransformList || hasTagName(SVGNames::animateTransformTag));</span>
<span class="line-removed">-     ASSERT(m_animatedPropertyType != AnimatedUnknown);</span>
<span class="line-removed">-     ASSERT(m_animator);</span>
<span class="line-removed">-     ASSERT(m_animator-&gt;type() == m_animatedPropertyType);</span>
<span class="line-removed">-     ASSERT(m_fromType);</span>
<span class="line-removed">-     ASSERT(m_fromType-&gt;type() == m_animatedPropertyType);</span>
<span class="line-removed">-     ASSERT(m_toType);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (shouldApply == ApplyXMLAnimation || shouldApply == ApplyXMLandCSSAnimation) {</span>
<span class="line-removed">-         // SVG DOM animVal animation code-path.</span>
<span class="line-removed">-         if (m_animator-&gt;findAnimatedPropertiesForAttributeName(*targetElement, attributeName).isEmpty())</span>
<span class="line-removed">-             return;</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     SVGAnimateElementBase&amp; resultAnimationElement = downcast&lt;SVGAnimateElementBase&gt;(*resultElement);</span>
<span class="line-modified">!     ASSERT(resultAnimationElement.m_animatedType);</span>
<span class="line-removed">-     ASSERT(resultAnimationElement.m_animatedPropertyType == m_animatedPropertyType);</span>
  
<span class="line-modified">!     if (hasTagName(SVGNames::setTag))</span>
<span class="line-modified">!         percentage = 1;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (calcMode() == CalcMode::Discrete)</span>
<span class="line-removed">-         percentage = percentage &lt; 0.5 ? 0 : 1;</span>
  
<span class="line-modified">!     // Target element might have changed.</span>
<span class="line-modified">!     m_animator-&gt;setContextElement(targetElement.get());</span>
  
<span class="line-modified">!     // Be sure to detach list wrappers before we modfiy their underlying value. If we&#39;d do</span>
<span class="line-modified">!     // if after calculateAnimatedValue() ran the cached pointers in the list propery tear</span>
<span class="line-modified">!     // offs would point nowhere, and we couldn&#39;t create copies of those values anymore,</span>
<span class="line-modified">!     // while detaching. This is covered by assertions, moving this down would fire them.</span>
<span class="line-modified">!     if (!m_animatedProperties.isEmpty())</span>
<span class="line-removed">-         m_animator-&gt;animValWillChange(m_animatedProperties);</span>
  
<span class="line-modified">!     // Values-animation accumulates using the last values entry corresponding to the end of duration time.</span>
<span class="line-modified">!     SVGAnimatedType* toAtEndOfDurationType = m_toAtEndOfDurationType ? m_toAtEndOfDurationType.get() : m_toType.get();</span>
<span class="line-modified">!     m_animator-&gt;calculateAnimatedValue(percentage, repeatCount, m_fromType.get(), m_toType.get(), toAtEndOfDurationType, resultAnimationElement.m_animatedType.get());</span>
  }
  
<span class="line-modified">! bool SVGAnimateElementBase::calculateToAtEndOfDurationValue(const String&amp; toAtEndOfDurationString)</span>
  {
<span class="line-modified">!     if (toAtEndOfDurationString.isEmpty())</span>
<span class="line-modified">!         return false;</span>
<span class="line-modified">!     m_toAtEndOfDurationType = ensureAnimator()-&gt;constructFromString(toAtEndOfDurationString);</span>
<span class="line-removed">-     return true;</span>
  }
  
  bool SVGAnimateElementBase::calculateFromAndToValues(const String&amp; fromString, const String&amp; toString)
  {
<span class="line-modified">!     if (!this-&gt;targetElement())</span>
          return false;
  
<span class="line-modified">!     determinePropertyValueTypes(fromString, toString);</span>
<span class="line-modified">!     ensureAnimator()-&gt;calculateFromAndToValues(m_fromType, m_toType, fromString, toString);</span>
<span class="line-modified">!     ASSERT(m_animatedPropertyType == m_animator-&gt;type());</span>
<span class="line-modified">!     return true;</span>
  }
  
  bool SVGAnimateElementBase::calculateFromAndByValues(const String&amp; fromString, const String&amp; byString)
  {
      if (!this-&gt;targetElement())
          return false;
  
<span class="line-modified">!     if (animationMode() == ByAnimation &amp;&amp; !isAdditive())</span>
          return false;
  
<span class="line-modified">!     // from-by animation may only be used with attributes that support addition (e.g. most numeric attributes).</span>
<span class="line-removed">-     if (animationMode() == FromByAnimation &amp;&amp; !animatedPropertyTypeSupportsAddition())</span>
          return false;
  
<span class="line-modified">!     ASSERT(!hasTagName(SVGNames::setTag));</span>
<span class="line-modified">! </span>
<span class="line-modified">!     determinePropertyValueTypes(fromString, byString);</span>
<span class="line-removed">-     ensureAnimator()-&gt;calculateFromAndByValues(m_fromType, m_toType, fromString, byString);</span>
<span class="line-removed">-     ASSERT(m_animatedPropertyType == m_animator-&gt;type());</span>
<span class="line-removed">-     return true;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- #ifndef NDEBUG</span>
<span class="line-removed">- static inline bool propertyTypesAreConsistent(AnimatedPropertyType expectedPropertyType, const SVGElementAnimatedPropertyList&amp; animatedTypes)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     for (auto&amp; type : animatedTypes) {</span>
<span class="line-removed">-         for (auto&amp; property : type.properties) {</span>
<span class="line-removed">-             if (expectedPropertyType != property-&gt;animatedPropertyType()) {</span>
<span class="line-removed">-                 // This is the only allowed inconsistency. SVGAnimatedAngleAnimator handles both SVGAnimatedAngle &amp; SVGAnimatedEnumeration for markers orient attribute.</span>
<span class="line-removed">-                 if (expectedPropertyType == AnimatedAngle &amp;&amp; property-&gt;animatedPropertyType() == AnimatedEnumeration)</span>
<span class="line-removed">-                     return true;</span>
<span class="line-removed">-                 return false;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
      }
<span class="line-modified">! </span>
<span class="line-removed">-     return true;</span>
  }
<span class="line-removed">- #endif</span>
  
<span class="line-modified">! void SVGAnimateElementBase::resetAnimatedType()</span>
  {
<span class="line-modified">!     SVGAnimatedTypeAnimator* animator = ensureAnimator();</span>
<span class="line-modified">!     ASSERT(m_animatedPropertyType == animator-&gt;type());</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto targetElement = makeRefPtr(this-&gt;targetElement());</span>
<span class="line-removed">-     if (!targetElement)</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     const QualifiedName&amp; attributeName = this-&gt;attributeName();</span>
<span class="line-removed">-     ShouldApplyAnimation shouldApply = shouldApplyAnimation(targetElement.get(), attributeName);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (shouldApply == DontApplyAnimation)</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (shouldApply == ApplyXMLAnimation || shouldApply == ApplyXMLandCSSAnimation) {</span>
<span class="line-removed">-         // SVG DOM animVal animation code-path.</span>
<span class="line-removed">-         m_animatedProperties = animator-&gt;findAnimatedPropertiesForAttributeName(*targetElement, attributeName);</span>
<span class="line-removed">-         if (m_animatedProperties.isEmpty())</span>
<span class="line-removed">-             return;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         ASSERT(propertyTypesAreConsistent(m_animatedPropertyType, m_animatedProperties));</span>
<span class="line-removed">-         if (!m_animatedType)</span>
<span class="line-removed">-             m_animatedType = animator-&gt;startAnimValAnimation(m_animatedProperties);</span>
<span class="line-removed">-         else {</span>
<span class="line-removed">-             animator-&gt;resetAnimValToBaseVal(m_animatedProperties, *m_animatedType);</span>
<span class="line-removed">-             animator-&gt;animValDidChange(m_animatedProperties);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     // CSS properties animation code-path.</span>
<span class="line-modified">!     ASSERT(m_animatedProperties.isEmpty());</span>
<span class="line-removed">-     String baseValue;</span>
  
<span class="line-modified">!     if (shouldApply == ApplyCSSAnimation) {</span>
<span class="line-modified">!         ASSERT(SVGAnimationElement::isTargetAttributeCSSProperty(targetElement.get(), attributeName));</span>
<span class="line-modified">!         computeCSSPropertyValue(targetElement.get(), cssPropertyID(attributeName.localName()), baseValue);</span>
      }
<span class="line-modified">! </span>
<span class="line-removed">-     if (!m_animatedType)</span>
<span class="line-removed">-         m_animatedType = animator-&gt;constructFromString(baseValue);</span>
<span class="line-removed">-     else</span>
<span class="line-removed">-         m_animatedType-&gt;setValueAsString(attributeName, baseValue);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- static inline void applyCSSPropertyToTarget(SVGElement&amp; targetElement, CSSPropertyID id, const String&amp; value)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ASSERT(!targetElement.m_deletionHasBegun);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (!targetElement.ensureAnimatedSMILStyleProperties().setProperty(id, value, false))</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     targetElement.invalidateStyle();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- static inline void removeCSSPropertyFromTarget(SVGElement&amp; targetElement, CSSPropertyID id)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ASSERT(!targetElement.m_deletionHasBegun);</span>
<span class="line-removed">-     targetElement.ensureAnimatedSMILStyleProperties().removeProperty(id);</span>
<span class="line-removed">-     targetElement.invalidateStyle();</span>
  }
  
<span class="line-modified">! static inline void applyCSSPropertyToTargetAndInstances(SVGElement&amp; targetElement, const QualifiedName&amp; attributeName, const String&amp; valueAsString)</span>
  {
<span class="line-modified">!     // FIXME: Do we really need to check both isConnected and !parentNode?</span>
<span class="line-removed">-     if (attributeName == anyQName() || !targetElement.isConnected() || !targetElement.parentNode())</span>
          return;
  
<span class="line-modified">!     CSSPropertyID id = cssPropertyID(attributeName.localName());</span>
<span class="line-modified">! </span>
<span class="line-removed">-     SVGElement::InstanceUpdateBlocker blocker(targetElement);</span>
<span class="line-removed">-     applyCSSPropertyToTarget(targetElement, id, valueAsString);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // If the target element has instances, update them as well, w/o requiring the &lt;use&gt; tree to be rebuilt.</span>
<span class="line-removed">-     for (auto* instance : targetElement.instances())</span>
<span class="line-removed">-         applyCSSPropertyToTarget(*instance, id, valueAsString);</span>
  }
  
<span class="line-modified">! static inline void removeCSSPropertyFromTargetAndInstances(SVGElement&amp; targetElement, const QualifiedName&amp; attributeName)</span>
  {
<span class="line-modified">!     // FIXME: Do we really need to check both isConnected and !parentNode?</span>
<span class="line-removed">-     if (attributeName == anyQName() || !targetElement.isConnected() || !targetElement.parentNode())</span>
          return;
  
<span class="line-modified">!     CSSPropertyID id = cssPropertyID(attributeName.localName());</span>
<span class="line-modified">! </span>
<span class="line-modified">!     SVGElement::InstanceUpdateBlocker blocker(targetElement);</span>
<span class="line-removed">-     removeCSSPropertyFromTarget(targetElement, id);</span>
  
<span class="line-modified">!     // If the target element has instances, update them as well, w/o requiring the &lt;use&gt; tree to be rebuilt.</span>
<span class="line-modified">!     for (auto* instance : targetElement.instances())</span>
<span class="line-removed">-         removeCSSPropertyFromTarget(*instance, id);</span>
<span class="line-removed">- }</span>
  
<span class="line-modified">! static inline void notifyTargetAboutAnimValChange(SVGElement&amp; targetElement, const QualifiedName&amp; attributeName)</span>
<span class="line-modified">! {</span>
<span class="line-removed">-     ASSERT(!targetElement.m_deletionHasBegun);</span>
<span class="line-removed">-     targetElement.svgAttributeChanged(attributeName);</span>
  }
  
<span class="line-modified">! static inline void notifyTargetAndInstancesAboutAnimValChange(SVGElement&amp; targetElement, const QualifiedName&amp; attributeName)</span>
  {
<span class="line-modified">!     if (attributeName == anyQName() || !targetElement.isConnected() || !targetElement.parentNode())</span>
          return;
  
<span class="line-modified">!     SVGElement::InstanceUpdateBlocker blocker(targetElement);</span>
<span class="line-modified">!     notifyTargetAboutAnimValChange(targetElement, attributeName);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // If the target element has instances, update them as well, w/o requiring the &lt;use&gt; tree to be rebuilt.</span>
<span class="line-removed">-     for (auto* instance : targetElement.instances())</span>
<span class="line-removed">-         notifyTargetAboutAnimValChange(*instance, attributeName);</span>
  }
  
  void SVGAnimateElementBase::clearAnimatedType(SVGElement* targetElement)
  {
<span class="line-modified">!     if (!m_animatedType)</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // If the SVGAnimatedType is a list type, e.g. SVGLengthListValues, the wrappers of the</span>
<span class="line-removed">-     // animated properties have to be detached from the items in the list before it&#39;s deleted.</span>
<span class="line-removed">-     if (!m_animatedProperties.isEmpty())</span>
<span class="line-removed">-         m_animator-&gt;animValWillChange(m_animatedProperties);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (!targetElement) {</span>
<span class="line-removed">-         m_animatedType = nullptr;</span>
          return;
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     if (m_animatedProperties.isEmpty()) {</span>
<span class="line-modified">!         // CSS properties animation code-path.</span>
<span class="line-removed">-         removeCSSPropertyFromTargetAndInstances(*targetElement, attributeName());</span>
<span class="line-removed">-         m_animatedType = nullptr;</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     ShouldApplyAnimation shouldApply = shouldApplyAnimation(targetElement, attributeName());</span>
<span class="line-removed">-     if (shouldApply == ApplyXMLandCSSAnimation)</span>
<span class="line-removed">-         removeCSSPropertyFromTargetAndInstances(*targetElement, attributeName());</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // SVG DOM animVal animation code-path.</span>
<span class="line-removed">-     if (m_animator) {</span>
<span class="line-removed">-         m_animator-&gt;stopAnimValAnimation(m_animatedProperties);</span>
<span class="line-removed">-         notifyTargetAndInstancesAboutAnimValChange(*targetElement, attributeName());</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     m_animatedProperties.clear();</span>
<span class="line-removed">-     m_animatedType = nullptr;</span>
  }
  
<span class="line-modified">! void SVGAnimateElementBase::applyResultsToTarget()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ASSERT(m_animatedPropertyType != AnimatedTransformList || hasTagName(SVGNames::animateTransformTag));</span>
<span class="line-removed">-     ASSERT(m_animatedPropertyType != AnimatedUnknown);</span>
<span class="line-removed">-     ASSERT(m_animator);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // Early exit if our animated type got destroyed by a previous endedActiveInterval().</span>
<span class="line-removed">-     if (!m_animatedType)</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto targetElement = makeRefPtr(this-&gt;targetElement());</span>
<span class="line-removed">-     const QualifiedName&amp; attributeName = this-&gt;attributeName();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     ASSERT(targetElement);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (m_animatedProperties.isEmpty()) {</span>
<span class="line-removed">-         // CSS properties animation code-path.</span>
<span class="line-removed">-         // Convert the result of the animation to a String and apply it as CSS property on the target &amp; all instances.</span>
<span class="line-removed">-         applyCSSPropertyToTargetAndInstances(*targetElement, attributeName, m_animatedType-&gt;valueAsString());</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // We do update the style and the animation property independent of each other.</span>
<span class="line-removed">-     ShouldApplyAnimation shouldApply = shouldApplyAnimation(targetElement.get(), attributeName);</span>
<span class="line-removed">-     if (shouldApply == ApplyXMLandCSSAnimation)</span>
<span class="line-removed">-         applyCSSPropertyToTargetAndInstances(*targetElement, attributeName, m_animatedType-&gt;valueAsString());</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // SVG DOM animVal animation code-path.</span>
<span class="line-removed">-     // At this point the SVG DOM values are already changed, unlike for CSS.</span>
<span class="line-removed">-     // We only have to trigger update notifications here.</span>
<span class="line-removed">-     m_animator-&gt;animValDidChange(m_animatedProperties);</span>
<span class="line-removed">-     notifyTargetAndInstancesAboutAnimValChange(*targetElement, attributeName);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- bool SVGAnimateElementBase::animatedPropertyTypeSupportsAddition() const</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     // Spec: http://www.w3.org/TR/SVG/animate.html#AnimationAttributesAndProperties.</span>
<span class="line-removed">-     switch (m_animatedPropertyType) {</span>
<span class="line-removed">-     case AnimatedBoolean:</span>
<span class="line-removed">-     case AnimatedEnumeration:</span>
<span class="line-removed">-     case AnimatedPreserveAspectRatio:</span>
<span class="line-removed">-     case AnimatedString:</span>
<span class="line-removed">-     case AnimatedUnknown:</span>
<span class="line-removed">-         return false;</span>
<span class="line-removed">-     case AnimatedAngle:</span>
<span class="line-removed">-     case AnimatedColor:</span>
<span class="line-removed">-     case AnimatedInteger:</span>
<span class="line-removed">-     case AnimatedIntegerOptionalInteger:</span>
<span class="line-removed">-     case AnimatedLength:</span>
<span class="line-removed">-     case AnimatedLengthList:</span>
<span class="line-removed">-     case AnimatedNumber:</span>
<span class="line-removed">-     case AnimatedNumberList:</span>
<span class="line-removed">-     case AnimatedNumberOptionalNumber:</span>
<span class="line-removed">-     case AnimatedPath:</span>
<span class="line-removed">-     case AnimatedPoints:</span>
<span class="line-removed">-     case AnimatedRect:</span>
<span class="line-removed">-     case AnimatedTransformList:</span>
<span class="line-removed">-         return true;</span>
<span class="line-removed">-     default:</span>
<span class="line-removed">-         RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-removed">-         return true;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- bool SVGAnimateElementBase::isAdditive() const</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     if (animationMode() == ByAnimation || animationMode() == FromByAnimation) {</span>
<span class="line-removed">-         if (!animatedPropertyTypeSupportsAddition())</span>
<span class="line-removed">-             return false;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     return SVGAnimationElement::isAdditive();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- float SVGAnimateElementBase::calculateDistance(const String&amp; fromString, const String&amp; toString)</span>
  {
      // FIXME: A return value of float is not enough to support paced animations on lists.
<span class="line-modified">!     if (!this-&gt;targetElement())</span>
<span class="line-modified">!         return -1;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     return ensureAnimator()-&gt;calculateDistance(fromString, toString);</span>
<span class="line-removed">- }</span>
  
<span class="line-modified">! void SVGAnimateElementBase::setTargetElement(SVGElement* target)</span>
<span class="line-modified">! {</span>
<span class="line-removed">-     SVGAnimationElement::setTargetElement(target);</span>
<span class="line-removed">-     resetAnimatedPropertyType();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void SVGAnimateElementBase::setAttributeName(const QualifiedName&amp; attributeName)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     SVGSMILElement::setAttributeName(attributeName);</span>
<span class="line-removed">-     checkInvalidCSSAttributeType(targetElement());</span>
<span class="line-removed">-     resetAnimatedPropertyType();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void SVGAnimateElementBase::resetAnimatedPropertyType()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     SVGAnimationElement::resetAnimatedPropertyType();</span>
<span class="line-removed">-     ASSERT(!m_animatedType);</span>
<span class="line-removed">-     m_fromType = nullptr;</span>
<span class="line-removed">-     m_toType = nullptr;</span>
<span class="line-removed">-     m_toAtEndOfDurationType = nullptr;</span>
<span class="line-removed">-     m_animator = nullptr;</span>
<span class="line-removed">-     m_animatedPropertyType = targetElement() ? determineAnimatedPropertyType(*targetElement()) : AnimatedString;</span>
<span class="line-removed">- }</span>
  
<span class="line-modified">! SVGAnimatedTypeAnimator* SVGAnimateElementBase::ensureAnimator()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     if (!m_animator)</span>
<span class="line-removed">-         m_animator = SVGAnimatorFactory::create(this, targetElement(), m_animatedPropertyType);</span>
<span class="line-removed">-     ASSERT(m_animatedPropertyType == m_animator-&gt;type());</span>
<span class="line-removed">-     return m_animator.get();</span>
  }
  
  } // namespace WebCore
<span class="line-new-header">--- 22,179 ---</span>
   */
  
  #include &quot;config.h&quot;
  #include &quot;SVGAnimateElementBase.h&quot;
  
  #include &quot;QualifiedName.h&quot;
<span class="line-modified">! #include &quot;SVGAttributeAnimator.h&quot;</span>
  #include &quot;SVGElement.h&quot;
  #include &quot;SVGNames.h&quot;
  #include &lt;wtf/IsoMallocInlines.h&gt;
  
  namespace WebCore {
  
  WTF_MAKE_ISO_ALLOCATED_IMPL(SVGAnimateElementBase);
  
  SVGAnimateElementBase::SVGAnimateElementBase(const QualifiedName&amp; tagName, Document&amp; document)
      : SVGAnimationElement(tagName, document)
  {
<span class="line-modified">!     ASSERT(hasTagName(SVGNames::animateTag)</span>
<span class="line-added">+         || hasTagName(SVGNames::setTag)</span>
<span class="line-added">+         || hasTagName(SVGNames::animateColorTag)</span>
<span class="line-added">+         || hasTagName(SVGNames::animateTransformTag));</span>
  }
  
<span class="line-modified">! SVGAttributeAnimator* SVGAnimateElementBase::animator() const</span>
  {
<span class="line-modified">!     ASSERT(targetElement());</span>
<span class="line-modified">!     ASSERT(!hasInvalidCSSAttributeType());</span>
  
<span class="line-modified">!     if (!m_animator)</span>
<span class="line-modified">!         m_animator = targetElement()-&gt;createAnimator(attributeName(), animationMode(), calcMode(), isAccumulated(), isAdditive());</span>
  
<span class="line-modified">!     return m_animator.get();</span>
  }
  
<span class="line-modified">! bool SVGAnimateElementBase::hasValidAttributeType() const</span>
  {
<span class="line-modified">!     if (!targetElement() || hasInvalidCSSAttributeType())</span>
<span class="line-modified">!         return false;</span>
  
<span class="line-modified">!     return targetElement()-&gt;isAnimatedAttribute(attributeName());</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! bool SVGAnimateElementBase::hasInvalidCSSAttributeType() const</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     if (!targetElement())</span>
<span class="line-modified">!         return false;</span>
  
<span class="line-modified">!     if (!m_hasInvalidCSSAttributeType)</span>
<span class="line-modified">!         m_hasInvalidCSSAttributeType = hasValidAttributeName() &amp;&amp; attributeType() == AttributeType::CSS &amp;&amp; !isTargetAttributeCSSProperty(targetElement(), attributeName());</span>
  
<span class="line-modified">!     return m_hasInvalidCSSAttributeType.value();</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! bool SVGAnimateElementBase::isDiscreteAnimator() const</span>
<span class="line-modified">! {</span>
<span class="line-added">+     return hasValidAttributeType() &amp;&amp; animatorIfExists() &amp;&amp; animatorIfExists()-&gt;isDiscrete();</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">! void SVGAnimateElementBase::setTargetElement(SVGElement* target)</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     SVGAnimationElement::setTargetElement(target);</span>
<span class="line-modified">!     resetAnimation();</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! void SVGAnimateElementBase::setAttributeName(const QualifiedName&amp; attributeName)</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     SVGSMILElement::setAttributeName(attributeName);</span>
<span class="line-added">+     resetAnimation();</span>
  }
  
<span class="line-modified">! void SVGAnimateElementBase::resetAnimation()</span>
  {
<span class="line-modified">!     SVGAnimationElement::resetAnimation();</span>
<span class="line-modified">!     m_animator = nullptr;</span>
<span class="line-modified">!     m_hasInvalidCSSAttributeType = { };</span>
  }
  
  bool SVGAnimateElementBase::calculateFromAndToValues(const String&amp; fromString, const String&amp; toString)
  {
<span class="line-modified">!     if (!targetElement())</span>
          return false;
  
<span class="line-modified">!     if (auto* animator = this-&gt;animator()) {</span>
<span class="line-modified">!         animator-&gt;setFromAndToValues(targetElement(), animateRangeString(fromString), animateRangeString(toString));</span>
<span class="line-modified">!         return true;</span>
<span class="line-modified">!     }</span>
<span class="line-added">+     return false;</span>
  }
  
  bool SVGAnimateElementBase::calculateFromAndByValues(const String&amp; fromString, const String&amp; byString)
  {
      if (!this-&gt;targetElement())
          return false;
  
<span class="line-modified">!     if (animationMode() == AnimationMode::By &amp;&amp; (!isAdditive() || isDiscreteAnimator()))</span>
          return false;
  
<span class="line-modified">!     if (animationMode() == AnimationMode::FromBy &amp;&amp; isDiscreteAnimator())</span>
          return false;
  
<span class="line-modified">!     if (auto* animator = this-&gt;animator()) {</span>
<span class="line-modified">!         animator-&gt;setFromAndByValues(targetElement(), animateRangeString(fromString), animateRangeString(byString));</span>
<span class="line-modified">!         return true;</span>
      }
<span class="line-modified">!     return false;</span>
  }
  
<span class="line-modified">! bool SVGAnimateElementBase::calculateToAtEndOfDurationValue(const String&amp; toAtEndOfDurationString)</span>
  {
<span class="line-modified">!     if (!targetElement() || toAtEndOfDurationString.isEmpty())</span>
<span class="line-modified">!         return false;</span>
  
<span class="line-modified">!     if (isDiscreteAnimator())</span>
<span class="line-modified">!         return true;</span>
  
<span class="line-modified">!     if (auto* animator = this-&gt;animator()) {</span>
<span class="line-modified">!         animator-&gt;setToAtEndOfDurationValue(animateRangeString(toAtEndOfDurationString));</span>
<span class="line-modified">!         return true;</span>
      }
<span class="line-modified">!     return false;</span>
  }
  
<span class="line-modified">! void SVGAnimateElementBase::resetAnimatedType()</span>
  {
<span class="line-modified">!     if (!targetElement())</span>
          return;
  
<span class="line-modified">!     if (auto protectedAnimator = makeRefPtr(this-&gt;animator()))</span>
<span class="line-modified">!         protectedAnimator-&gt;start(targetElement());</span>
  }
  
<span class="line-modified">! void SVGAnimateElementBase::calculateAnimatedValue(float progress, unsigned repeatCount, SVGSMILElement*)</span>
  {
<span class="line-modified">!     if (!targetElement())</span>
          return;
  
<span class="line-modified">!     ASSERT(progress &gt;= 0 &amp;&amp; progress &lt;= 1);</span>
<span class="line-modified">!     if (hasTagName(SVGNames::setTag))</span>
<span class="line-modified">!         progress = 1;</span>
  
<span class="line-modified">!     if (calcMode() == CalcMode::Discrete)</span>
<span class="line-modified">!         progress = progress &lt; 0.5 ? 0 : 1;</span>
  
<span class="line-modified">!     if (auto protectedAnimator = makeRefPtr(this-&gt;animator()))</span>
<span class="line-modified">!         protectedAnimator-&gt;animate(targetElement(), progress, repeatCount);</span>
  }
  
<span class="line-modified">! void SVGAnimateElementBase::applyResultsToTarget()</span>
  {
<span class="line-modified">!     if (!targetElement())</span>
          return;
  
<span class="line-modified">!     if (auto* animator = this-&gt;animator())</span>
<span class="line-modified">!         animator-&gt;apply(targetElement());</span>
  }
  
  void SVGAnimateElementBase::clearAnimatedType(SVGElement* targetElement)
  {
<span class="line-modified">!     if (!targetElement)</span>
          return;
  
<span class="line-modified">!     if (auto* animator = this-&gt;animatorIfExists())</span>
<span class="line-modified">!         animator-&gt;stop(targetElement);</span>
  }
  
<span class="line-modified">! Optional&lt;float&gt; SVGAnimateElementBase::calculateDistance(const String&amp; fromString, const String&amp; toString)</span>
  {
      // FIXME: A return value of float is not enough to support paced animations on lists.
<span class="line-modified">!     if (!targetElement())</span>
<span class="line-modified">!         return { };</span>
  
<span class="line-modified">!     if (auto* animator = this-&gt;animator())</span>
<span class="line-modified">!         return animator-&gt;calculateDistance(targetElement(), fromString, toString);</span>
  
<span class="line-modified">!     return { };</span>
  }
  
  } // namespace WebCore
</pre>
<center><a href="SVGAnimateElement.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SVGAnimateElementBase.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>