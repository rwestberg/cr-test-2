<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/css/parser/CSSParserImpl.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CSSParserFastPaths.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="CSSParserImpl.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/css/parser/CSSParserImpl.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 60 
 61 CSSParserImpl::CSSParserImpl(const CSSParserContext&amp; context, StyleSheetContents* styleSheet)
 62     : m_context(context)
 63     , m_styleSheet(styleSheet)
 64 {
 65 
 66 }
 67 
 68 CSSParserImpl::CSSParserImpl(CSSDeferredParser&amp; deferredParser)
 69     : m_context(deferredParser.context())
 70     , m_styleSheet(deferredParser.styleSheet())
 71     , m_deferredParser(&amp;deferredParser)
 72 {
 73 }
 74 
 75 CSSParserImpl::CSSParserImpl(const CSSParserContext&amp; context, const String&amp; string, StyleSheetContents* styleSheet, CSSParserObserverWrapper* wrapper, CSSParser::RuleParsing ruleParsing)
 76     : m_context(context)
 77     , m_styleSheet(styleSheet)
 78     , m_observerWrapper(wrapper)
 79 {
<span class="line-modified"> 80     m_tokenizer = wrapper ? std::make_unique&lt;CSSTokenizer&gt;(string, *wrapper) : std::make_unique&lt;CSSTokenizer&gt;(string);</span>
 81     if (context.deferredCSSParserEnabled &amp;&amp; !wrapper &amp;&amp; styleSheet &amp;&amp; ruleParsing == CSSParser::RuleParsing::Deferred)
 82         m_deferredParser = CSSDeferredParser::create(context, string, *styleSheet);
 83 }
 84 
 85 CSSParser::ParseResult CSSParserImpl::parseValue(MutableStyleProperties* declaration, CSSPropertyID propertyID, const String&amp; string, bool important, const CSSParserContext&amp; context)
 86 {
 87     CSSParserImpl parser(context, string);
 88     StyleRule::Type ruleType = StyleRule::Style;
 89 #if ENABLE(CSS_DEVICE_ADAPTATION)
 90     if (declaration-&gt;cssParserMode() == CSSViewportRuleMode)
 91         ruleType = StyleRule::Viewport;
 92 #endif
 93     parser.consumeDeclarationValue(parser.tokenizer()-&gt;tokenRange(), propertyID, important, ruleType);
 94     if (parser.m_parsedProperties.isEmpty())
 95         return CSSParser::ParseResult::Error;
 96     return declaration-&gt;addParsedProperties(parser.m_parsedProperties) ? CSSParser::ParseResult::Changed : CSSParser::ParseResult::Unchanged;
 97 }
 98 
<span class="line-modified"> 99 CSSParser::ParseResult CSSParserImpl::parseCustomPropertyValue(MutableStyleProperties* declaration, const AtomicString&amp; propertyName, const String&amp; string, bool important, const CSSParserContext&amp; context)</span>
100 {
101     CSSParserImpl parser(context, string);
102     parser.consumeCustomPropertyValue(parser.tokenizer()-&gt;tokenRange(), propertyName, important);
103     if (parser.m_parsedProperties.isEmpty())
104         return CSSParser::ParseResult::Error;
105     return declaration-&gt;addParsedProperties(parser.m_parsedProperties) ? CSSParser::ParseResult::Changed : CSSParser::ParseResult::Unchanged;
106 }
107 
<span class="line-modified">108 static inline void filterProperties(bool important, const ParsedPropertyVector&amp; input, ParsedPropertyVector&amp; output, size_t&amp; unusedEntries, std::bitset&lt;numCSSProperties&gt;&amp; seenProperties, HashSet&lt;AtomicString&gt;&amp; seenCustomProperties)</span>
109 {
110     // Add properties in reverse order so that highest priority definitions are reached first. Duplicate definitions can then be ignored when found.
111     for (size_t i = input.size(); i--; ) {
112         const CSSProperty&amp; property = input[i];
113         if (property.isImportant() != important)
114             continue;
115         const unsigned propertyIDIndex = property.id() - firstCSSProperty;
116 
117         if (property.id() == CSSPropertyCustom) {
118             auto&amp; name = downcast&lt;CSSCustomPropertyValue&gt;(*property.value()).name();
119             if (!seenCustomProperties.add(name).isNewEntry)
120                 continue;
121             output[--unusedEntries] = property;
122             continue;
123         }
124 
125         // FIXME-NEWPARSER: We won&#39;t support @apply yet.
126         /*else if (property.id() == CSSPropertyApplyAtRule) {
127          // FIXME: Do we need to do anything here?
128          } */
129 
130         if (seenProperties.test(propertyIDIndex))
131             continue;
132         seenProperties.set(propertyIDIndex);
133 
134         output[--unusedEntries] = property;
135     }
136 }
137 
138 Ref&lt;DeferredStyleProperties&gt; CSSParserImpl::createDeferredStyleProperties(const CSSParserTokenRange&amp; propertyRange)
139 {
140     ASSERT(m_deferredParser);
141     return DeferredStyleProperties::create(propertyRange, *m_deferredParser);
142 }
143 
144 static Ref&lt;ImmutableStyleProperties&gt; createStyleProperties(ParsedPropertyVector&amp; parsedProperties, CSSParserMode mode)
145 {
146     std::bitset&lt;numCSSProperties&gt; seenProperties;
147     size_t unusedEntries = parsedProperties.size();
148     ParsedPropertyVector results(unusedEntries);
<span class="line-modified">149     HashSet&lt;AtomicString&gt; seenCustomProperties;</span>
150 
151     filterProperties(true, parsedProperties, results, unusedEntries, seenProperties, seenCustomProperties);
152     filterProperties(false, parsedProperties, results, unusedEntries, seenProperties, seenCustomProperties);
153 
154     Ref&lt;ImmutableStyleProperties&gt; result = ImmutableStyleProperties::create(results.data() + unusedEntries, results.size() - unusedEntries, mode);
155     parsedProperties.clear();
156     return result;
157 }
158 
159 Ref&lt;ImmutableStyleProperties&gt; CSSParserImpl::parseInlineStyleDeclaration(const String&amp; string, const Element* element)
160 {
161     CSSParserContext context(element-&gt;document());
162     context.mode = strictToCSSParserMode(element-&gt;isHTMLElement() &amp;&amp; !element-&gt;document().inQuirksMode());
163 
164     CSSParserImpl parser(context, string);
165     parser.consumeDeclarationList(parser.tokenizer()-&gt;tokenRange(), StyleRule::Style);
166     return createStyleProperties(parser.m_parsedProperties, context.mode);
167 }
168 
169 Ref&lt;ImmutableStyleProperties&gt; CSSParserImpl::parseDeferredDeclaration(CSSParserTokenRange tokenRange, const CSSParserContext&amp; context, StyleSheetContents* styleSheet)
</pre>
<hr />
<pre>
196     parser.consumeRuleList(tokenRange, KeyframesRuleList, [&amp;keyframeRule](const RefPtr&lt;StyleRuleBase&gt;&amp; keyframe) {
197         keyframeRule.parserAppendKeyframe(downcast&lt;const StyleRuleKeyframe&gt;(keyframe.get()));
198     });
199 }
200 
201 bool CSSParserImpl::parseDeclarationList(MutableStyleProperties* declaration, const String&amp; string, const CSSParserContext&amp; context)
202 {
203     CSSParserImpl parser(context, string);
204     StyleRule::Type ruleType = StyleRule::Style;
205 #if ENABLE(CSS_DEVICE_ADAPTATION)
206     if (declaration-&gt;cssParserMode() == CSSViewportRuleMode)
207         ruleType = StyleRule::Viewport;
208 #endif
209     parser.consumeDeclarationList(parser.tokenizer()-&gt;tokenRange(), ruleType);
210     if (parser.m_parsedProperties.isEmpty())
211         return false;
212 
213     std::bitset&lt;numCSSProperties&gt; seenProperties;
214     size_t unusedEntries = parser.m_parsedProperties.size();
215     ParsedPropertyVector results(unusedEntries);
<span class="line-modified">216     HashSet&lt;AtomicString&gt; seenCustomProperties;</span>
217     filterProperties(true, parser.m_parsedProperties, results, unusedEntries, seenProperties, seenCustomProperties);
218     filterProperties(false, parser.m_parsedProperties, results, unusedEntries, seenProperties, seenCustomProperties);
219     if (unusedEntries)
220         results.remove(0, unusedEntries);
221     return declaration-&gt;addParsedProperties(results);
222 }
223 
224 RefPtr&lt;StyleRuleBase&gt; CSSParserImpl::parseRule(const String&amp; string, const CSSParserContext&amp; context, StyleSheetContents* styleSheet, AllowedRulesType allowedRules)
225 {
226     CSSParserImpl parser(context, string, styleSheet);
227     CSSParserTokenRange range = parser.tokenizer()-&gt;tokenRange();
228     range.consumeWhitespace();
229     if (range.atEnd())
230         return nullptr; // Parse error, empty rule
231     RefPtr&lt;StyleRuleBase&gt; rule;
232     if (range.peek().type() == AtKeywordToken)
233         rule = parser.consumeAtRule(range, allowedRules);
234     else
235         rule = parser.consumeQualifiedRule(range, allowedRules);
236     if (!rule)
</pre>
<hr />
<pre>
247     bool firstRuleValid = parser.consumeRuleList(parser.tokenizer()-&gt;tokenRange(), TopLevelRuleList, [&amp;styleSheet](RefPtr&lt;StyleRuleBase&gt; rule) {
248         if (rule-&gt;isCharsetRule())
249             return;
250         styleSheet-&gt;parserAppendRule(rule.releaseNonNull());
251     });
252     styleSheet-&gt;setHasSyntacticallyValidCSSHeader(firstRuleValid);
253     parser.adoptTokenizerEscapedStrings();
254 }
255 
256 void CSSParserImpl::adoptTokenizerEscapedStrings()
257 {
258     if (!m_deferredParser || !m_tokenizer)
259         return;
260     m_deferredParser-&gt;adoptTokenizerEscapedStrings(m_tokenizer-&gt;escapedStringsForAdoption());
261 }
262 
263 CSSSelectorList CSSParserImpl::parsePageSelector(CSSParserTokenRange range, StyleSheetContents* styleSheet)
264 {
265     // We only support a small subset of the css-page spec.
266     range.consumeWhitespace();
<span class="line-modified">267     AtomicString typeSelector;</span>
268     if (range.peek().type() == IdentToken)
<span class="line-modified">269         typeSelector = range.consume().value().toAtomicString();</span>
270 
<span class="line-modified">271     AtomicString pseudo;</span>
272     if (range.peek().type() == ColonToken) {
273         range.consume();
274         if (range.peek().type() != IdentToken)
275             return CSSSelectorList();
<span class="line-modified">276         pseudo = range.consume().value().toAtomicString();</span>
277     }
278 
279     range.consumeWhitespace();
280     if (!range.atEnd())
281         return CSSSelectorList(); // Parse error; extra tokens in @page selector
282 
283     std::unique_ptr&lt;CSSParserSelector&gt; selector;
284     if (!typeSelector.isNull() &amp;&amp; pseudo.isNull())
<span class="line-modified">285         selector = std::make_unique&lt;CSSParserSelector&gt;(QualifiedName(nullAtom(), typeSelector, styleSheet-&gt;defaultNamespace()));</span>
286     else {
<span class="line-modified">287         selector = std::make_unique&lt;CSSParserSelector&gt;();</span>
288         if (!pseudo.isNull()) {
289             selector = std::unique_ptr&lt;CSSParserSelector&gt;(CSSParserSelector::parsePagePseudoSelector(pseudo));
290             if (!selector || selector-&gt;match() != CSSSelector::PagePseudoClass)
291                 return CSSSelectorList();
292         }
293         if (!typeSelector.isNull())
294             selector-&gt;prependTagSelector(QualifiedName(nullAtom(), typeSelector, styleSheet-&gt;defaultNamespace()));
295     }
296 
297     selector-&gt;setForPage();
298     return CSSSelectorList { Vector&lt;std::unique_ptr&lt;CSSParserSelector&gt;&gt;::from(WTFMove(selector)) };
299 }
300 
301 std::unique_ptr&lt;Vector&lt;double&gt;&gt; CSSParserImpl::parseKeyframeKeyList(const String&amp; keyList)
302 {
303     return consumeKeyframeKeyList(CSSTokenizer(keyList).tokenRange());
304 }
305 
306 bool CSSParserImpl::supportsDeclaration(CSSParserTokenRange&amp; range)
307 {
</pre>
<hr />
<pre>
460     const CSSParserToken* preludeStart = &amp;range.peek();
461     while (!range.atEnd() &amp;&amp; range.peek().type() != LeftBraceToken)
462         range.consumeComponentValue();
463 
464     if (range.atEnd())
465         return nullptr; // Parse error, EOF instead of qualified rule block
466 
467     CSSParserTokenRange prelude = range.makeSubRange(preludeStart, &amp;range.peek());
468     CSSParserTokenRange block = range.consumeBlockCheckingForEditability(m_styleSheet.get());
469 
470     if (allowedRules &lt;= RegularRules)
471         return consumeStyleRule(prelude, block);
472     if (allowedRules == KeyframeRules)
473         return consumeKeyframeStyleRule(prelude, block);
474 
475     ASSERT_NOT_REACHED();
476     return nullptr;
477 }
478 
479 // This may still consume tokens if it fails
<span class="line-modified">480 static AtomicString consumeStringOrURI(CSSParserTokenRange&amp; range)</span>
481 {
482     const CSSParserToken&amp; token = range.peek();
483 
484     if (token.type() == StringToken || token.type() == UrlToken)
<span class="line-modified">485         return range.consumeIncludingWhitespace().value().toAtomicString();</span>
486 
487     if (token.type() != FunctionToken || !equalIgnoringASCIICase(token.value(), &quot;url&quot;))
<span class="line-modified">488         return AtomicString();</span>
489 
490     CSSParserTokenRange contents = range.consumeBlock();
491     const CSSParserToken&amp; uri = contents.consumeIncludingWhitespace();
492     if (uri.type() == BadStringToken || !contents.atEnd())
<span class="line-modified">493         return AtomicString();</span>
<span class="line-modified">494     return uri.value().toAtomicString();</span>
495 }
496 
497 RefPtr&lt;StyleRuleCharset&gt; CSSParserImpl::consumeCharsetRule(CSSParserTokenRange prelude)
498 {
499     const CSSParserToken&amp; string = prelude.consumeIncludingWhitespace();
500     if (string.type() != StringToken || !prelude.atEnd())
501         return nullptr; // Parse error, expected a single string
502     return StyleRuleCharset::create();
503 }
504 
505 RefPtr&lt;StyleRuleImport&gt; CSSParserImpl::consumeImportRule(CSSParserTokenRange prelude)
506 {
<span class="line-modified">507     AtomicString uri(consumeStringOrURI(prelude));</span>
508     if (uri.isNull())
509         return nullptr; // Parse error, expected string or URI
510 
511     if (m_observerWrapper) {
512         unsigned endOffset = m_observerWrapper-&gt;endOffset(prelude);
513         m_observerWrapper-&gt;observer().startRuleHeader(StyleRule::Import, m_observerWrapper-&gt;startOffset(prelude));
514         m_observerWrapper-&gt;observer().endRuleHeader(endOffset);
515         m_observerWrapper-&gt;observer().startRuleBody(endOffset);
516         m_observerWrapper-&gt;observer().endRuleBody(endOffset);
517     }
518 
519     return StyleRuleImport::create(uri, MediaQueryParser::parseMediaQuerySet(prelude, MediaQueryParserContext(m_context)).releaseNonNull());
520 }
521 
522 RefPtr&lt;StyleRuleNamespace&gt; CSSParserImpl::consumeNamespaceRule(CSSParserTokenRange prelude)
523 {
<span class="line-modified">524     AtomicString namespacePrefix;</span>
525     if (prelude.peek().type() == IdentToken)
<span class="line-modified">526         namespacePrefix = prelude.consumeIncludingWhitespace().value().toAtomicString();</span>
527 
<span class="line-modified">528     AtomicString uri(consumeStringOrURI(prelude));</span>
529     if (uri.isNull() || !prelude.atEnd())
530         return nullptr; // Parse error, expected string or URI
531 
532     return StyleRuleNamespace::create(namespacePrefix, uri);
533 }
534 
535 RefPtr&lt;StyleRuleMedia&gt; CSSParserImpl::consumeMediaRule(CSSParserTokenRange prelude, CSSParserTokenRange block)
536 {
537     if (m_deferredParser)
<span class="line-modified">538         return StyleRuleMedia::create(MediaQueryParser::parseMediaQuerySet(prelude, MediaQueryParserContext(m_context)).releaseNonNull(),  std::make_unique&lt;DeferredStyleGroupRuleList&gt;(block, *m_deferredParser));</span>
539 
540     Vector&lt;RefPtr&lt;StyleRuleBase&gt;&gt; rules;
541 
542     if (m_observerWrapper) {
543         m_observerWrapper-&gt;observer().startRuleHeader(StyleRule::Media, m_observerWrapper-&gt;startOffset(prelude));
544         m_observerWrapper-&gt;observer().endRuleHeader(m_observerWrapper-&gt;endOffset(prelude));
545         m_observerWrapper-&gt;observer().startRuleBody(m_observerWrapper-&gt;previousTokenStartOffset(block));
546     }
547 
548     consumeRuleList(block, RegularRuleList, [&amp;rules](RefPtr&lt;StyleRuleBase&gt; rule) {
549         rules.append(rule);
550     });
551     rules.shrinkToFit();
552 
553     if (m_observerWrapper)
554         m_observerWrapper-&gt;observer().endRuleBody(m_observerWrapper-&gt;endOffset(block));
555 
556     return StyleRuleMedia::create(MediaQueryParser::parseMediaQuerySet(prelude, MediaQueryParserContext(m_context)).releaseNonNull(), rules);
557 }
558 
559 RefPtr&lt;StyleRuleSupports&gt; CSSParserImpl::consumeSupportsRule(CSSParserTokenRange prelude, CSSParserTokenRange block)
560 {
561     CSSSupportsParser::SupportsResult supported = CSSSupportsParser::supportsCondition(prelude, *this, CSSSupportsParser::ForAtRule);
562     if (supported == CSSSupportsParser::Invalid)
563         return nullptr; // Parse error, invalid @supports condition
564 
565     if (m_deferredParser)
<span class="line-modified">566         return StyleRuleSupports::create(prelude.serialize().stripWhiteSpace(), supported, std::make_unique&lt;DeferredStyleGroupRuleList&gt;(block, *m_deferredParser));</span>
567 
568     if (m_observerWrapper) {
569         m_observerWrapper-&gt;observer().startRuleHeader(StyleRule::Supports, m_observerWrapper-&gt;startOffset(prelude));
570         m_observerWrapper-&gt;observer().endRuleHeader(m_observerWrapper-&gt;endOffset(prelude));
571         m_observerWrapper-&gt;observer().startRuleBody(m_observerWrapper-&gt;previousTokenStartOffset(block));
572     }
573 
574     Vector&lt;RefPtr&lt;StyleRuleBase&gt;&gt; rules;
575     consumeRuleList(block, RegularRuleList, [&amp;rules](RefPtr&lt;StyleRuleBase&gt; rule) {
576         rules.append(rule);
577     });
578     rules.shrinkToFit();
579 
580     if (m_observerWrapper)
581         m_observerWrapper-&gt;observer().endRuleBody(m_observerWrapper-&gt;endOffset(block));
582 
583     return StyleRuleSupports::create(prelude.serialize().stripWhiteSpace(), supported, rules);
584 }
585 
586 #if ENABLE(CSS_DEVICE_ADAPTATION)
</pre>
<hr />
<pre>
618     consumeDeclarationList(block, StyleRule::FontFace);
619     return StyleRuleFontFace::create(createStyleProperties(m_parsedProperties, m_context.mode));
620 }
621 
622 RefPtr&lt;StyleRuleKeyframes&gt; CSSParserImpl::consumeKeyframesRule(bool webkitPrefixed, CSSParserTokenRange prelude, CSSParserTokenRange block)
623 {
624     CSSParserTokenRange rangeCopy = prelude; // For inspector callbacks
625     const CSSParserToken&amp; nameToken = prelude.consumeIncludingWhitespace();
626     if (!prelude.atEnd())
627         return nullptr; // Parse error; expected single non-whitespace token in @keyframes header
628 
629     String name;
630     if (nameToken.type() == IdentToken) {
631         name = nameToken.value().toString();
632     } else if (nameToken.type() == StringToken &amp;&amp; webkitPrefixed)
633         name = nameToken.value().toString();
634     else
635         return nullptr; // Parse error; expected ident token in @keyframes header
636 
637     if (m_deferredParser)
<span class="line-modified">638         return StyleRuleKeyframes::create(name, std::make_unique&lt;DeferredStyleGroupRuleList&gt;(block, *m_deferredParser));</span>
639 
640     if (m_observerWrapper) {
641         m_observerWrapper-&gt;observer().startRuleHeader(StyleRule::Keyframes, m_observerWrapper-&gt;startOffset(rangeCopy));
642         m_observerWrapper-&gt;observer().endRuleHeader(m_observerWrapper-&gt;endOffset(prelude));
643         m_observerWrapper-&gt;observer().startRuleBody(m_observerWrapper-&gt;previousTokenStartOffset(block));
644         m_observerWrapper-&gt;observer().endRuleBody(m_observerWrapper-&gt;endOffset(block));
645     }
646 
647     RefPtr&lt;StyleRuleKeyframes&gt; keyframeRule = StyleRuleKeyframes::create(name);
648     consumeRuleList(block, KeyframesRuleList, [keyframeRule](const RefPtr&lt;StyleRuleBase&gt;&amp; keyframe) {
649         keyframeRule-&gt;parserAppendKeyframe(downcast&lt;const StyleRuleKeyframe&gt;(keyframe.get()));
650     });
651 
652     // FIXME-NEWPARSER: Find out why this is done. Behavior difference when prefixed?
653     // keyframeRule-&gt;setVendorPrefixed(webkitPrefixed);
654     return keyframeRule;
655 }
656 
657 RefPtr&lt;StyleRulePage&gt; CSSParserImpl::consumePageRule(CSSParserTokenRange prelude, CSSParserTokenRange block)
658 {
</pre>
<hr />
<pre>
805     if (range.consume().type() != ColonToken)
806         return; // Parse error
807 
808     bool important = false;
809     const CSSParserToken* declarationValueEnd = range.end();
810     const CSSParserToken* last = range.end() - 1;
811     while (last-&gt;type() == WhitespaceToken)
812         --last;
813     if (last-&gt;type() == IdentToken &amp;&amp; equalIgnoringASCIICase(last-&gt;value(), &quot;important&quot;)) {
814         --last;
815         while (last-&gt;type() == WhitespaceToken)
816             --last;
817         if (last-&gt;type() == DelimiterToken &amp;&amp; last-&gt;delimiter() == &#39;!&#39;) {
818             important = true;
819             declarationValueEnd = last;
820         }
821     }
822 
823     size_t propertiesCount = m_parsedProperties.size();
824     if (propertyID == CSSPropertyInvalid &amp;&amp; CSSVariableParser::isValidVariableName(token)) {
<span class="line-modified">825         AtomicString variableName = token.value().toAtomicString();</span>
826         consumeCustomPropertyValue(range.makeSubRange(&amp;range.peek(), declarationValueEnd), variableName, important);
827     }
828 
829     if (important &amp;&amp; (ruleType == StyleRule::FontFace || ruleType == StyleRule::Keyframe))
830         return;
831 
832     if (propertyID != CSSPropertyInvalid)
833         consumeDeclarationValue(range.makeSubRange(&amp;range.peek(), declarationValueEnd), propertyID, important, ruleType);
834 
835     if (m_observerWrapper &amp;&amp; (ruleType == StyleRule::Style || ruleType == StyleRule::Keyframe)) {
836         m_observerWrapper-&gt;observer().observeProperty(
837             m_observerWrapper-&gt;startOffset(rangeCopy), m_observerWrapper-&gt;endOffset(rangeCopy),
838             important, m_parsedProperties.size() != propertiesCount);
839     }
840 }
841 
<span class="line-modified">842 void CSSParserImpl::consumeCustomPropertyValue(CSSParserTokenRange range, const AtomicString&amp; variableName, bool important)</span>
843 {
844     if (RefPtr&lt;CSSCustomPropertyValue&gt; value = CSSVariableParser::parseDeclarationValue(variableName, range, m_context))
845         m_parsedProperties.append(CSSProperty(CSSPropertyCustom, WTFMove(value), important));
846 }
847 
848 void CSSParserImpl::consumeDeclarationValue(CSSParserTokenRange range, CSSPropertyID propertyID, bool important, StyleRule::Type ruleType)
849 {
850     CSSPropertyParser::parseValue(propertyID, important, range, m_context, m_parsedProperties, ruleType);
851 }
852 
853 std::unique_ptr&lt;Vector&lt;double&gt;&gt; CSSParserImpl::consumeKeyframeKeyList(CSSParserTokenRange range)
854 {
855     std::unique_ptr&lt;Vector&lt;double&gt;&gt; result = std::unique_ptr&lt;Vector&lt;double&gt;&gt;(new Vector&lt;double&gt;);
856     while (true) {
857         range.consumeWhitespace();
858         const CSSParserToken&amp; token = range.consumeIncludingWhitespace();
859         if (token.type() == PercentageToken &amp;&amp; token.numericValue() &gt;= 0 &amp;&amp; token.numericValue() &lt;= 100)
860             result-&gt;append(token.numericValue() / 100);
861         else if (token.type() == IdentToken &amp;&amp; equalIgnoringASCIICase(token.value(), &quot;from&quot;))
862             result-&gt;append(0);
</pre>
</td>
<td>
<hr />
<pre>
 60 
 61 CSSParserImpl::CSSParserImpl(const CSSParserContext&amp; context, StyleSheetContents* styleSheet)
 62     : m_context(context)
 63     , m_styleSheet(styleSheet)
 64 {
 65 
 66 }
 67 
 68 CSSParserImpl::CSSParserImpl(CSSDeferredParser&amp; deferredParser)
 69     : m_context(deferredParser.context())
 70     , m_styleSheet(deferredParser.styleSheet())
 71     , m_deferredParser(&amp;deferredParser)
 72 {
 73 }
 74 
 75 CSSParserImpl::CSSParserImpl(const CSSParserContext&amp; context, const String&amp; string, StyleSheetContents* styleSheet, CSSParserObserverWrapper* wrapper, CSSParser::RuleParsing ruleParsing)
 76     : m_context(context)
 77     , m_styleSheet(styleSheet)
 78     , m_observerWrapper(wrapper)
 79 {
<span class="line-modified"> 80     m_tokenizer = wrapper ? makeUnique&lt;CSSTokenizer&gt;(string, *wrapper) : makeUnique&lt;CSSTokenizer&gt;(string);</span>
 81     if (context.deferredCSSParserEnabled &amp;&amp; !wrapper &amp;&amp; styleSheet &amp;&amp; ruleParsing == CSSParser::RuleParsing::Deferred)
 82         m_deferredParser = CSSDeferredParser::create(context, string, *styleSheet);
 83 }
 84 
 85 CSSParser::ParseResult CSSParserImpl::parseValue(MutableStyleProperties* declaration, CSSPropertyID propertyID, const String&amp; string, bool important, const CSSParserContext&amp; context)
 86 {
 87     CSSParserImpl parser(context, string);
 88     StyleRule::Type ruleType = StyleRule::Style;
 89 #if ENABLE(CSS_DEVICE_ADAPTATION)
 90     if (declaration-&gt;cssParserMode() == CSSViewportRuleMode)
 91         ruleType = StyleRule::Viewport;
 92 #endif
 93     parser.consumeDeclarationValue(parser.tokenizer()-&gt;tokenRange(), propertyID, important, ruleType);
 94     if (parser.m_parsedProperties.isEmpty())
 95         return CSSParser::ParseResult::Error;
 96     return declaration-&gt;addParsedProperties(parser.m_parsedProperties) ? CSSParser::ParseResult::Changed : CSSParser::ParseResult::Unchanged;
 97 }
 98 
<span class="line-modified"> 99 CSSParser::ParseResult CSSParserImpl::parseCustomPropertyValue(MutableStyleProperties* declaration, const AtomString&amp; propertyName, const String&amp; string, bool important, const CSSParserContext&amp; context)</span>
100 {
101     CSSParserImpl parser(context, string);
102     parser.consumeCustomPropertyValue(parser.tokenizer()-&gt;tokenRange(), propertyName, important);
103     if (parser.m_parsedProperties.isEmpty())
104         return CSSParser::ParseResult::Error;
105     return declaration-&gt;addParsedProperties(parser.m_parsedProperties) ? CSSParser::ParseResult::Changed : CSSParser::ParseResult::Unchanged;
106 }
107 
<span class="line-modified">108 static inline void filterProperties(bool important, const ParsedPropertyVector&amp; input, ParsedPropertyVector&amp; output, size_t&amp; unusedEntries, std::bitset&lt;numCSSProperties&gt;&amp; seenProperties, HashSet&lt;AtomString&gt;&amp; seenCustomProperties)</span>
109 {
110     // Add properties in reverse order so that highest priority definitions are reached first. Duplicate definitions can then be ignored when found.
111     for (size_t i = input.size(); i--; ) {
112         const CSSProperty&amp; property = input[i];
113         if (property.isImportant() != important)
114             continue;
115         const unsigned propertyIDIndex = property.id() - firstCSSProperty;
116 
117         if (property.id() == CSSPropertyCustom) {
118             auto&amp; name = downcast&lt;CSSCustomPropertyValue&gt;(*property.value()).name();
119             if (!seenCustomProperties.add(name).isNewEntry)
120                 continue;
121             output[--unusedEntries] = property;
122             continue;
123         }
124 
125         // FIXME-NEWPARSER: We won&#39;t support @apply yet.
126         /*else if (property.id() == CSSPropertyApplyAtRule) {
127          // FIXME: Do we need to do anything here?
128          } */
129 
130         if (seenProperties.test(propertyIDIndex))
131             continue;
132         seenProperties.set(propertyIDIndex);
133 
134         output[--unusedEntries] = property;
135     }
136 }
137 
138 Ref&lt;DeferredStyleProperties&gt; CSSParserImpl::createDeferredStyleProperties(const CSSParserTokenRange&amp; propertyRange)
139 {
140     ASSERT(m_deferredParser);
141     return DeferredStyleProperties::create(propertyRange, *m_deferredParser);
142 }
143 
144 static Ref&lt;ImmutableStyleProperties&gt; createStyleProperties(ParsedPropertyVector&amp; parsedProperties, CSSParserMode mode)
145 {
146     std::bitset&lt;numCSSProperties&gt; seenProperties;
147     size_t unusedEntries = parsedProperties.size();
148     ParsedPropertyVector results(unusedEntries);
<span class="line-modified">149     HashSet&lt;AtomString&gt; seenCustomProperties;</span>
150 
151     filterProperties(true, parsedProperties, results, unusedEntries, seenProperties, seenCustomProperties);
152     filterProperties(false, parsedProperties, results, unusedEntries, seenProperties, seenCustomProperties);
153 
154     Ref&lt;ImmutableStyleProperties&gt; result = ImmutableStyleProperties::create(results.data() + unusedEntries, results.size() - unusedEntries, mode);
155     parsedProperties.clear();
156     return result;
157 }
158 
159 Ref&lt;ImmutableStyleProperties&gt; CSSParserImpl::parseInlineStyleDeclaration(const String&amp; string, const Element* element)
160 {
161     CSSParserContext context(element-&gt;document());
162     context.mode = strictToCSSParserMode(element-&gt;isHTMLElement() &amp;&amp; !element-&gt;document().inQuirksMode());
163 
164     CSSParserImpl parser(context, string);
165     parser.consumeDeclarationList(parser.tokenizer()-&gt;tokenRange(), StyleRule::Style);
166     return createStyleProperties(parser.m_parsedProperties, context.mode);
167 }
168 
169 Ref&lt;ImmutableStyleProperties&gt; CSSParserImpl::parseDeferredDeclaration(CSSParserTokenRange tokenRange, const CSSParserContext&amp; context, StyleSheetContents* styleSheet)
</pre>
<hr />
<pre>
196     parser.consumeRuleList(tokenRange, KeyframesRuleList, [&amp;keyframeRule](const RefPtr&lt;StyleRuleBase&gt;&amp; keyframe) {
197         keyframeRule.parserAppendKeyframe(downcast&lt;const StyleRuleKeyframe&gt;(keyframe.get()));
198     });
199 }
200 
201 bool CSSParserImpl::parseDeclarationList(MutableStyleProperties* declaration, const String&amp; string, const CSSParserContext&amp; context)
202 {
203     CSSParserImpl parser(context, string);
204     StyleRule::Type ruleType = StyleRule::Style;
205 #if ENABLE(CSS_DEVICE_ADAPTATION)
206     if (declaration-&gt;cssParserMode() == CSSViewportRuleMode)
207         ruleType = StyleRule::Viewport;
208 #endif
209     parser.consumeDeclarationList(parser.tokenizer()-&gt;tokenRange(), ruleType);
210     if (parser.m_parsedProperties.isEmpty())
211         return false;
212 
213     std::bitset&lt;numCSSProperties&gt; seenProperties;
214     size_t unusedEntries = parser.m_parsedProperties.size();
215     ParsedPropertyVector results(unusedEntries);
<span class="line-modified">216     HashSet&lt;AtomString&gt; seenCustomProperties;</span>
217     filterProperties(true, parser.m_parsedProperties, results, unusedEntries, seenProperties, seenCustomProperties);
218     filterProperties(false, parser.m_parsedProperties, results, unusedEntries, seenProperties, seenCustomProperties);
219     if (unusedEntries)
220         results.remove(0, unusedEntries);
221     return declaration-&gt;addParsedProperties(results);
222 }
223 
224 RefPtr&lt;StyleRuleBase&gt; CSSParserImpl::parseRule(const String&amp; string, const CSSParserContext&amp; context, StyleSheetContents* styleSheet, AllowedRulesType allowedRules)
225 {
226     CSSParserImpl parser(context, string, styleSheet);
227     CSSParserTokenRange range = parser.tokenizer()-&gt;tokenRange();
228     range.consumeWhitespace();
229     if (range.atEnd())
230         return nullptr; // Parse error, empty rule
231     RefPtr&lt;StyleRuleBase&gt; rule;
232     if (range.peek().type() == AtKeywordToken)
233         rule = parser.consumeAtRule(range, allowedRules);
234     else
235         rule = parser.consumeQualifiedRule(range, allowedRules);
236     if (!rule)
</pre>
<hr />
<pre>
247     bool firstRuleValid = parser.consumeRuleList(parser.tokenizer()-&gt;tokenRange(), TopLevelRuleList, [&amp;styleSheet](RefPtr&lt;StyleRuleBase&gt; rule) {
248         if (rule-&gt;isCharsetRule())
249             return;
250         styleSheet-&gt;parserAppendRule(rule.releaseNonNull());
251     });
252     styleSheet-&gt;setHasSyntacticallyValidCSSHeader(firstRuleValid);
253     parser.adoptTokenizerEscapedStrings();
254 }
255 
256 void CSSParserImpl::adoptTokenizerEscapedStrings()
257 {
258     if (!m_deferredParser || !m_tokenizer)
259         return;
260     m_deferredParser-&gt;adoptTokenizerEscapedStrings(m_tokenizer-&gt;escapedStringsForAdoption());
261 }
262 
263 CSSSelectorList CSSParserImpl::parsePageSelector(CSSParserTokenRange range, StyleSheetContents* styleSheet)
264 {
265     // We only support a small subset of the css-page spec.
266     range.consumeWhitespace();
<span class="line-modified">267     AtomString typeSelector;</span>
268     if (range.peek().type() == IdentToken)
<span class="line-modified">269         typeSelector = range.consume().value().toAtomString();</span>
270 
<span class="line-modified">271     StringView pseudo;</span>
272     if (range.peek().type() == ColonToken) {
273         range.consume();
274         if (range.peek().type() != IdentToken)
275             return CSSSelectorList();
<span class="line-modified">276         pseudo = range.consume().value();</span>
277     }
278 
279     range.consumeWhitespace();
280     if (!range.atEnd())
281         return CSSSelectorList(); // Parse error; extra tokens in @page selector
282 
283     std::unique_ptr&lt;CSSParserSelector&gt; selector;
284     if (!typeSelector.isNull() &amp;&amp; pseudo.isNull())
<span class="line-modified">285         selector = makeUnique&lt;CSSParserSelector&gt;(QualifiedName(nullAtom(), typeSelector, styleSheet-&gt;defaultNamespace()));</span>
286     else {
<span class="line-modified">287         selector = makeUnique&lt;CSSParserSelector&gt;();</span>
288         if (!pseudo.isNull()) {
289             selector = std::unique_ptr&lt;CSSParserSelector&gt;(CSSParserSelector::parsePagePseudoSelector(pseudo));
290             if (!selector || selector-&gt;match() != CSSSelector::PagePseudoClass)
291                 return CSSSelectorList();
292         }
293         if (!typeSelector.isNull())
294             selector-&gt;prependTagSelector(QualifiedName(nullAtom(), typeSelector, styleSheet-&gt;defaultNamespace()));
295     }
296 
297     selector-&gt;setForPage();
298     return CSSSelectorList { Vector&lt;std::unique_ptr&lt;CSSParserSelector&gt;&gt;::from(WTFMove(selector)) };
299 }
300 
301 std::unique_ptr&lt;Vector&lt;double&gt;&gt; CSSParserImpl::parseKeyframeKeyList(const String&amp; keyList)
302 {
303     return consumeKeyframeKeyList(CSSTokenizer(keyList).tokenRange());
304 }
305 
306 bool CSSParserImpl::supportsDeclaration(CSSParserTokenRange&amp; range)
307 {
</pre>
<hr />
<pre>
460     const CSSParserToken* preludeStart = &amp;range.peek();
461     while (!range.atEnd() &amp;&amp; range.peek().type() != LeftBraceToken)
462         range.consumeComponentValue();
463 
464     if (range.atEnd())
465         return nullptr; // Parse error, EOF instead of qualified rule block
466 
467     CSSParserTokenRange prelude = range.makeSubRange(preludeStart, &amp;range.peek());
468     CSSParserTokenRange block = range.consumeBlockCheckingForEditability(m_styleSheet.get());
469 
470     if (allowedRules &lt;= RegularRules)
471         return consumeStyleRule(prelude, block);
472     if (allowedRules == KeyframeRules)
473         return consumeKeyframeStyleRule(prelude, block);
474 
475     ASSERT_NOT_REACHED();
476     return nullptr;
477 }
478 
479 // This may still consume tokens if it fails
<span class="line-modified">480 static AtomString consumeStringOrURI(CSSParserTokenRange&amp; range)</span>
481 {
482     const CSSParserToken&amp; token = range.peek();
483 
484     if (token.type() == StringToken || token.type() == UrlToken)
<span class="line-modified">485         return range.consumeIncludingWhitespace().value().toAtomString();</span>
486 
487     if (token.type() != FunctionToken || !equalIgnoringASCIICase(token.value(), &quot;url&quot;))
<span class="line-modified">488         return AtomString();</span>
489 
490     CSSParserTokenRange contents = range.consumeBlock();
491     const CSSParserToken&amp; uri = contents.consumeIncludingWhitespace();
492     if (uri.type() == BadStringToken || !contents.atEnd())
<span class="line-modified">493         return AtomString();</span>
<span class="line-modified">494     return uri.value().toAtomString();</span>
495 }
496 
497 RefPtr&lt;StyleRuleCharset&gt; CSSParserImpl::consumeCharsetRule(CSSParserTokenRange prelude)
498 {
499     const CSSParserToken&amp; string = prelude.consumeIncludingWhitespace();
500     if (string.type() != StringToken || !prelude.atEnd())
501         return nullptr; // Parse error, expected a single string
502     return StyleRuleCharset::create();
503 }
504 
505 RefPtr&lt;StyleRuleImport&gt; CSSParserImpl::consumeImportRule(CSSParserTokenRange prelude)
506 {
<span class="line-modified">507     AtomString uri(consumeStringOrURI(prelude));</span>
508     if (uri.isNull())
509         return nullptr; // Parse error, expected string or URI
510 
511     if (m_observerWrapper) {
512         unsigned endOffset = m_observerWrapper-&gt;endOffset(prelude);
513         m_observerWrapper-&gt;observer().startRuleHeader(StyleRule::Import, m_observerWrapper-&gt;startOffset(prelude));
514         m_observerWrapper-&gt;observer().endRuleHeader(endOffset);
515         m_observerWrapper-&gt;observer().startRuleBody(endOffset);
516         m_observerWrapper-&gt;observer().endRuleBody(endOffset);
517     }
518 
519     return StyleRuleImport::create(uri, MediaQueryParser::parseMediaQuerySet(prelude, MediaQueryParserContext(m_context)).releaseNonNull());
520 }
521 
522 RefPtr&lt;StyleRuleNamespace&gt; CSSParserImpl::consumeNamespaceRule(CSSParserTokenRange prelude)
523 {
<span class="line-modified">524     AtomString namespacePrefix;</span>
525     if (prelude.peek().type() == IdentToken)
<span class="line-modified">526         namespacePrefix = prelude.consumeIncludingWhitespace().value().toAtomString();</span>
527 
<span class="line-modified">528     AtomString uri(consumeStringOrURI(prelude));</span>
529     if (uri.isNull() || !prelude.atEnd())
530         return nullptr; // Parse error, expected string or URI
531 
532     return StyleRuleNamespace::create(namespacePrefix, uri);
533 }
534 
535 RefPtr&lt;StyleRuleMedia&gt; CSSParserImpl::consumeMediaRule(CSSParserTokenRange prelude, CSSParserTokenRange block)
536 {
537     if (m_deferredParser)
<span class="line-modified">538         return StyleRuleMedia::create(MediaQueryParser::parseMediaQuerySet(prelude, MediaQueryParserContext(m_context)).releaseNonNull(),  makeUnique&lt;DeferredStyleGroupRuleList&gt;(block, *m_deferredParser));</span>
539 
540     Vector&lt;RefPtr&lt;StyleRuleBase&gt;&gt; rules;
541 
542     if (m_observerWrapper) {
543         m_observerWrapper-&gt;observer().startRuleHeader(StyleRule::Media, m_observerWrapper-&gt;startOffset(prelude));
544         m_observerWrapper-&gt;observer().endRuleHeader(m_observerWrapper-&gt;endOffset(prelude));
545         m_observerWrapper-&gt;observer().startRuleBody(m_observerWrapper-&gt;previousTokenStartOffset(block));
546     }
547 
548     consumeRuleList(block, RegularRuleList, [&amp;rules](RefPtr&lt;StyleRuleBase&gt; rule) {
549         rules.append(rule);
550     });
551     rules.shrinkToFit();
552 
553     if (m_observerWrapper)
554         m_observerWrapper-&gt;observer().endRuleBody(m_observerWrapper-&gt;endOffset(block));
555 
556     return StyleRuleMedia::create(MediaQueryParser::parseMediaQuerySet(prelude, MediaQueryParserContext(m_context)).releaseNonNull(), rules);
557 }
558 
559 RefPtr&lt;StyleRuleSupports&gt; CSSParserImpl::consumeSupportsRule(CSSParserTokenRange prelude, CSSParserTokenRange block)
560 {
561     CSSSupportsParser::SupportsResult supported = CSSSupportsParser::supportsCondition(prelude, *this, CSSSupportsParser::ForAtRule);
562     if (supported == CSSSupportsParser::Invalid)
563         return nullptr; // Parse error, invalid @supports condition
564 
565     if (m_deferredParser)
<span class="line-modified">566         return StyleRuleSupports::create(prelude.serialize().stripWhiteSpace(), supported, makeUnique&lt;DeferredStyleGroupRuleList&gt;(block, *m_deferredParser));</span>
567 
568     if (m_observerWrapper) {
569         m_observerWrapper-&gt;observer().startRuleHeader(StyleRule::Supports, m_observerWrapper-&gt;startOffset(prelude));
570         m_observerWrapper-&gt;observer().endRuleHeader(m_observerWrapper-&gt;endOffset(prelude));
571         m_observerWrapper-&gt;observer().startRuleBody(m_observerWrapper-&gt;previousTokenStartOffset(block));
572     }
573 
574     Vector&lt;RefPtr&lt;StyleRuleBase&gt;&gt; rules;
575     consumeRuleList(block, RegularRuleList, [&amp;rules](RefPtr&lt;StyleRuleBase&gt; rule) {
576         rules.append(rule);
577     });
578     rules.shrinkToFit();
579 
580     if (m_observerWrapper)
581         m_observerWrapper-&gt;observer().endRuleBody(m_observerWrapper-&gt;endOffset(block));
582 
583     return StyleRuleSupports::create(prelude.serialize().stripWhiteSpace(), supported, rules);
584 }
585 
586 #if ENABLE(CSS_DEVICE_ADAPTATION)
</pre>
<hr />
<pre>
618     consumeDeclarationList(block, StyleRule::FontFace);
619     return StyleRuleFontFace::create(createStyleProperties(m_parsedProperties, m_context.mode));
620 }
621 
622 RefPtr&lt;StyleRuleKeyframes&gt; CSSParserImpl::consumeKeyframesRule(bool webkitPrefixed, CSSParserTokenRange prelude, CSSParserTokenRange block)
623 {
624     CSSParserTokenRange rangeCopy = prelude; // For inspector callbacks
625     const CSSParserToken&amp; nameToken = prelude.consumeIncludingWhitespace();
626     if (!prelude.atEnd())
627         return nullptr; // Parse error; expected single non-whitespace token in @keyframes header
628 
629     String name;
630     if (nameToken.type() == IdentToken) {
631         name = nameToken.value().toString();
632     } else if (nameToken.type() == StringToken &amp;&amp; webkitPrefixed)
633         name = nameToken.value().toString();
634     else
635         return nullptr; // Parse error; expected ident token in @keyframes header
636 
637     if (m_deferredParser)
<span class="line-modified">638         return StyleRuleKeyframes::create(name, makeUnique&lt;DeferredStyleGroupRuleList&gt;(block, *m_deferredParser));</span>
639 
640     if (m_observerWrapper) {
641         m_observerWrapper-&gt;observer().startRuleHeader(StyleRule::Keyframes, m_observerWrapper-&gt;startOffset(rangeCopy));
642         m_observerWrapper-&gt;observer().endRuleHeader(m_observerWrapper-&gt;endOffset(prelude));
643         m_observerWrapper-&gt;observer().startRuleBody(m_observerWrapper-&gt;previousTokenStartOffset(block));
644         m_observerWrapper-&gt;observer().endRuleBody(m_observerWrapper-&gt;endOffset(block));
645     }
646 
647     RefPtr&lt;StyleRuleKeyframes&gt; keyframeRule = StyleRuleKeyframes::create(name);
648     consumeRuleList(block, KeyframesRuleList, [keyframeRule](const RefPtr&lt;StyleRuleBase&gt;&amp; keyframe) {
649         keyframeRule-&gt;parserAppendKeyframe(downcast&lt;const StyleRuleKeyframe&gt;(keyframe.get()));
650     });
651 
652     // FIXME-NEWPARSER: Find out why this is done. Behavior difference when prefixed?
653     // keyframeRule-&gt;setVendorPrefixed(webkitPrefixed);
654     return keyframeRule;
655 }
656 
657 RefPtr&lt;StyleRulePage&gt; CSSParserImpl::consumePageRule(CSSParserTokenRange prelude, CSSParserTokenRange block)
658 {
</pre>
<hr />
<pre>
805     if (range.consume().type() != ColonToken)
806         return; // Parse error
807 
808     bool important = false;
809     const CSSParserToken* declarationValueEnd = range.end();
810     const CSSParserToken* last = range.end() - 1;
811     while (last-&gt;type() == WhitespaceToken)
812         --last;
813     if (last-&gt;type() == IdentToken &amp;&amp; equalIgnoringASCIICase(last-&gt;value(), &quot;important&quot;)) {
814         --last;
815         while (last-&gt;type() == WhitespaceToken)
816             --last;
817         if (last-&gt;type() == DelimiterToken &amp;&amp; last-&gt;delimiter() == &#39;!&#39;) {
818             important = true;
819             declarationValueEnd = last;
820         }
821     }
822 
823     size_t propertiesCount = m_parsedProperties.size();
824     if (propertyID == CSSPropertyInvalid &amp;&amp; CSSVariableParser::isValidVariableName(token)) {
<span class="line-modified">825         AtomString variableName = token.value().toAtomString();</span>
826         consumeCustomPropertyValue(range.makeSubRange(&amp;range.peek(), declarationValueEnd), variableName, important);
827     }
828 
829     if (important &amp;&amp; (ruleType == StyleRule::FontFace || ruleType == StyleRule::Keyframe))
830         return;
831 
832     if (propertyID != CSSPropertyInvalid)
833         consumeDeclarationValue(range.makeSubRange(&amp;range.peek(), declarationValueEnd), propertyID, important, ruleType);
834 
835     if (m_observerWrapper &amp;&amp; (ruleType == StyleRule::Style || ruleType == StyleRule::Keyframe)) {
836         m_observerWrapper-&gt;observer().observeProperty(
837             m_observerWrapper-&gt;startOffset(rangeCopy), m_observerWrapper-&gt;endOffset(rangeCopy),
838             important, m_parsedProperties.size() != propertiesCount);
839     }
840 }
841 
<span class="line-modified">842 void CSSParserImpl::consumeCustomPropertyValue(CSSParserTokenRange range, const AtomString&amp; variableName, bool important)</span>
843 {
844     if (RefPtr&lt;CSSCustomPropertyValue&gt; value = CSSVariableParser::parseDeclarationValue(variableName, range, m_context))
845         m_parsedProperties.append(CSSProperty(CSSPropertyCustom, WTFMove(value), important));
846 }
847 
848 void CSSParserImpl::consumeDeclarationValue(CSSParserTokenRange range, CSSPropertyID propertyID, bool important, StyleRule::Type ruleType)
849 {
850     CSSPropertyParser::parseValue(propertyID, important, range, m_context, m_parsedProperties, ruleType);
851 }
852 
853 std::unique_ptr&lt;Vector&lt;double&gt;&gt; CSSParserImpl::consumeKeyframeKeyList(CSSParserTokenRange range)
854 {
855     std::unique_ptr&lt;Vector&lt;double&gt;&gt; result = std::unique_ptr&lt;Vector&lt;double&gt;&gt;(new Vector&lt;double&gt;);
856     while (true) {
857         range.consumeWhitespace();
858         const CSSParserToken&amp; token = range.consumeIncludingWhitespace();
859         if (token.type() == PercentageToken &amp;&amp; token.numericValue() &gt;= 0 &amp;&amp; token.numericValue() &lt;= 100)
860             result-&gt;append(token.numericValue() / 100);
861         else if (token.type() == IdentToken &amp;&amp; equalIgnoringASCIICase(token.value(), &quot;from&quot;))
862             result-&gt;append(0);
</pre>
</td>
</tr>
</table>
<center><a href="CSSParserFastPaths.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="CSSParserImpl.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>