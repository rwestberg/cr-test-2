<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/server/IDBServer.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="IDBBackingStore.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="IDBServer.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/server/IDBServer.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;IDBServer.h&quot;
 28 
 29 #if ENABLE(INDEXED_DATABASE)
 30 
 31 #include &quot;IDBRequestData.h&quot;
 32 #include &quot;IDBResultData.h&quot;
 33 #include &quot;Logging.h&quot;
 34 #include &quot;MemoryIDBBackingStore.h&quot;


 35 #include &quot;SQLiteFileSystem.h&quot;
 36 #include &quot;SQLiteIDBBackingStore.h&quot;

 37 #include &quot;SecurityOrigin.h&quot;

 38 #include &lt;wtf/CrossThreadCopier.h&gt;
 39 #include &lt;wtf/Locker.h&gt;
 40 #include &lt;wtf/MainThread.h&gt;
 41 
 42 namespace WebCore {
 43 namespace IDBServer {
 44 
<span class="line-modified"> 45 Ref&lt;IDBServer&gt; IDBServer::create(IDBBackingStoreTemporaryFileHandler&amp; fileHandler)</span>
 46 {
<span class="line-modified"> 47     return adoptRef(*new IDBServer(fileHandler));</span>
 48 }
 49 
<span class="line-modified"> 50 Ref&lt;IDBServer&gt; IDBServer::create(const String&amp; databaseDirectoryPath, IDBBackingStoreTemporaryFileHandler&amp; fileHandler)</span>
 51 {
<span class="line-modified"> 52     return adoptRef(*new IDBServer(databaseDirectoryPath, fileHandler));</span>
 53 }
 54 
<span class="line-modified"> 55 IDBServer::IDBServer(IDBBackingStoreTemporaryFileHandler&amp; fileHandler)</span>
<span class="line-modified"> 56     : CrossThreadTaskHandler(&quot;IndexedDatabase Server&quot;)</span>

 57     , m_backingStoreTemporaryFileHandler(fileHandler)

 58 {
 59 }
 60 
<span class="line-modified"> 61 IDBServer::IDBServer(const String&amp; databaseDirectoryPath, IDBBackingStoreTemporaryFileHandler&amp; fileHandler)</span>
<span class="line-modified"> 62     : CrossThreadTaskHandler(&quot;IndexedDatabase Server&quot;)</span>

 63     , m_databaseDirectoryPath(databaseDirectoryPath)
 64     , m_backingStoreTemporaryFileHandler(fileHandler)

 65 {
 66     LOG(IndexedDB, &quot;IDBServer created at path %s&quot;, databaseDirectoryPath.utf8().data());

 67 }
 68 
 69 void IDBServer::registerConnection(IDBConnectionToClient&amp; connection)
 70 {
 71     ASSERT(!m_connectionMap.contains(connection.identifier()));
 72     m_connectionMap.set(connection.identifier(), &amp;connection);
 73 }
 74 
 75 void IDBServer::unregisterConnection(IDBConnectionToClient&amp; connection)
 76 {
 77     ASSERT(m_connectionMap.contains(connection.identifier()));
 78     ASSERT(m_connectionMap.get(connection.identifier()) == &amp;connection);
 79 
 80     connection.connectionToClientClosed();
 81 
 82     m_connectionMap.remove(connection.identifier());
 83 }
 84 
 85 void IDBServer::registerTransaction(UniqueIDBDatabaseTransaction&amp; transaction)
 86 {
</pre>
<hr />
<pre>
 97 }
 98 
 99 void IDBServer::registerDatabaseConnection(UniqueIDBDatabaseConnection&amp; connection)
100 {
101     ASSERT(!m_databaseConnections.contains(connection.identifier()));
102     m_databaseConnections.set(connection.identifier(), &amp;connection);
103 }
104 
105 void IDBServer::unregisterDatabaseConnection(UniqueIDBDatabaseConnection&amp; connection)
106 {
107     ASSERT(m_databaseConnections.contains(connection.identifier()));
108     m_databaseConnections.remove(connection.identifier());
109 }
110 
111 UniqueIDBDatabase&amp; IDBServer::getOrCreateUniqueIDBDatabase(const IDBDatabaseIdentifier&amp; identifier)
112 {
113     ASSERT(isMainThread());
114 
115     auto uniqueIDBDatabase = m_uniqueIDBDatabaseMap.add(identifier, nullptr);
116     if (uniqueIDBDatabase.isNewEntry)
<span class="line-modified">117         uniqueIDBDatabase.iterator-&gt;value = std::make_unique&lt;UniqueIDBDatabase&gt;(*this, identifier);</span>
118 
119     return *uniqueIDBDatabase.iterator-&gt;value;
120 }
121 
122 std::unique_ptr&lt;IDBBackingStore&gt; IDBServer::createBackingStore(const IDBDatabaseIdentifier&amp; identifier)
123 {
124     ASSERT(!isMainThread());
125 
<span class="line-modified">126     if (m_databaseDirectoryPath.isEmpty())</span>
<span class="line-modified">127         return MemoryIDBBackingStore::create(identifier);</span>

128 
<span class="line-modified">129     return std::make_unique&lt;SQLiteIDBBackingStore&gt;(identifier, m_databaseDirectoryPath, m_backingStoreTemporaryFileHandler, m_perOriginQuota);</span>
130 }
131 
132 void IDBServer::openDatabase(const IDBRequestData&amp; requestData)
133 {
134     LOG(IndexedDB, &quot;IDBServer::openDatabase&quot;);
135 
136     auto&amp; uniqueIDBDatabase = getOrCreateUniqueIDBDatabase(requestData.databaseIdentifier());
137 
138     auto connection = m_connectionMap.get(requestData.requestIdentifier().connectionIdentifier());
139     if (!connection) {
140         // If the connection back to the client is gone, there&#39;s no way to open the database as
141         // well as no way to message back failure.
142         return;
143     }
144 
145     uniqueIDBDatabase.openDatabaseConnection(*connection, requestData);
146 }
147 
148 void IDBServer::deleteDatabase(const IDBRequestData&amp; requestData)
149 {
</pre>
<hr />
<pre>
440         return;
441 
442     uniqueIDBDatabase-&gt;openDBRequestCancelled(requestData.requestIdentifier());
443 }
444 
445 void IDBServer::confirmDidCloseFromServer(uint64_t databaseConnectionIdentifier)
446 {
447     LOG(IndexedDB, &quot;IDBServer::confirmDidCloseFromServer&quot;);
448 
449     if (auto databaseConnection = m_databaseConnections.get(databaseConnectionIdentifier))
450         databaseConnection-&gt;confirmDidCloseFromServer();
451 }
452 
453 void IDBServer::getAllDatabaseNames(uint64_t serverConnectionIdentifier, const SecurityOriginData&amp; mainFrameOrigin, const SecurityOriginData&amp; openingOrigin, uint64_t callbackID)
454 {
455     postDatabaseTask(createCrossThreadTask(*this, &amp;IDBServer::performGetAllDatabaseNames, serverConnectionIdentifier, mainFrameOrigin, openingOrigin, callbackID));
456 }
457 
458 void IDBServer::performGetAllDatabaseNames(uint64_t serverConnectionIdentifier, const SecurityOriginData&amp; mainFrameOrigin, const SecurityOriginData&amp; openingOrigin, uint64_t callbackID)
459 {
<span class="line-modified">460     String directory = IDBDatabaseIdentifier::databaseDirectoryRelativeToRoot(mainFrameOrigin, openingOrigin, m_databaseDirectoryPath);</span>
<span class="line-modified">461 </span>
<span class="line-modified">462     Vector&lt;String&gt; entries = FileSystem::listDirectory(directory, &quot;*&quot;_s);</span>
463     Vector&lt;String&gt; databases;
<span class="line-modified">464     databases.reserveInitialCapacity(entries.size());</span>
<span class="line-modified">465     for (auto&amp; entry : entries) {</span>
<span class="line-modified">466         String encodedName = FileSystem::lastComponentOfPathIgnoringTrailingSlash(entry);</span>
<span class="line-modified">467         databases.uncheckedAppend(SQLiteIDBBackingStore::databaseNameFromEncodedFilename(encodedName));</span>







468     }
469 
470     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;IDBServer::didGetAllDatabaseNames, serverConnectionIdentifier, callbackID, databases));
471 }
472 
473 void IDBServer::didGetAllDatabaseNames(uint64_t serverConnectionIdentifier, uint64_t callbackID, const Vector&lt;String&gt;&amp; databaseNames)
474 {
475     auto connection = m_connectionMap.get(serverConnectionIdentifier);
476     if (!connection)
477         return;
478 
479     connection-&gt;didGetAllDatabaseNames(callbackID, databaseNames);
480 }
481 
482 void IDBServer::postDatabaseTask(CrossThreadTask&amp;&amp; task)
483 {
484     postTask(WTFMove(task));
485 }
486 
487 void IDBServer::postDatabaseTaskReply(CrossThreadTask&amp;&amp; task)
</pre>
<hr />
<pre>
524     auto addResult = m_deleteDatabaseCompletionHandlers.add(callbackID, WTFMove(completionHandler));
525     ASSERT_UNUSED(addResult, addResult.isNewEntry);
526 
527     HashSet&lt;UniqueIDBDatabase*&gt; openDatabases;
528     for (auto&amp; database : m_uniqueIDBDatabaseMap.values()) {
529         const auto&amp; identifier = database-&gt;identifier();
530         for (auto&amp; origin : origins) {
531             if (identifier.isRelatedToOrigin(origin)) {
532                 openDatabases.add(database.get());
533                 break;
534             }
535         }
536     }
537 
538     for (auto&amp; database : openDatabases)
539         database-&gt;immediateCloseForUserDelete();
540 
541     postDatabaseTask(createCrossThreadTask(*this, &amp;IDBServer::performCloseAndDeleteDatabasesForOrigins, origins, callbackID));
542 }
543 
<span class="line-modified">544 static void removeAllDatabasesForOriginPath(const String&amp; originPath, WallTime modifiedSince)</span>
545 {
546     LOG(IndexedDB, &quot;removeAllDatabasesForOriginPath with originPath %s&quot;, originPath.utf8().data());
547     Vector&lt;String&gt; databasePaths = FileSystem::listDirectory(originPath, &quot;*&quot;);
548 
549     for (auto&amp; databasePath : databasePaths) {
<span class="line-removed">550         if (FileSystem::fileIsDirectory(databasePath, FileSystem::ShouldFollowSymbolicLinks::No))</span>
<span class="line-removed">551             removeAllDatabasesForOriginPath(databasePath, modifiedSince);</span>
<span class="line-removed">552 </span>
553         String databaseFile = FileSystem::pathByAppendingComponent(databasePath, &quot;IndexedDB.sqlite3&quot;);
554         if (modifiedSince &gt; -WallTime::infinity() &amp;&amp; FileSystem::fileExists(databaseFile)) {
555             auto modificationTime = FileSystem::getFileModificationTime(databaseFile);
556             if (!modificationTime)
557                 continue;
558 
559             if (modificationTime.value() &lt; modifiedSince)
560                 continue;
561         }
562 
563         // Deleting this database means we need to delete all files that represent it.
564         // This includes:
565         //     - The directory itself, which is named after the database.
566         //     - IndexedDB.sqlite3 and related SQLite files.
567         //     - Blob files that we stored in the directory.
568         //
569         // To be conservative, we should *not* try to delete files that are unexpected;
570         // We should only delete files we think we put there.
571         //
572         // IndexedDB blob files are named &quot;N.blob&quot; where N is a decimal integer,
</pre>
<hr />
<pre>
592                     validFilename = false;
593                     break;
594                 }
595             }
596 
597             if (validFilename)
598                 FileSystem::deleteFile(blobPath);
599         }
600 
601         // Now delete IndexedDB.sqlite3 and related SQLite files.
602         SQLiteFileSystem::deleteDatabaseFile(databaseFile);
603 
604         // And finally, if we can, delete the empty directory.
605         FileSystem::deleteEmptyDirectory(databasePath);
606     }
607 
608     // If no databases remain for this origin, we can delete the origin directory as well.
609     FileSystem::deleteEmptyDirectory(originPath);
610 }
611 
<span class="line-modified">612 void IDBServer::performCloseAndDeleteDatabasesModifiedSince(WallTime modifiedSince, uint64_t callbackID)</span>
613 {
<span class="line-modified">614     if (!m_databaseDirectoryPath.isEmpty()) {</span>
<span class="line-modified">615         Vector&lt;String&gt; originPaths = FileSystem::listDirectory(m_databaseDirectoryPath, &quot;*&quot;);</span>
<span class="line-modified">616         for (auto&amp; originPath : originPaths)</span>

















617             removeAllDatabasesForOriginPath(originPath, modifiedSince);
618     }








619 
620     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;IDBServer::didPerformCloseAndDeleteDatabases, callbackID));
621 }
622 
<span class="line-modified">623 void IDBServer::performCloseAndDeleteDatabasesForOrigins(const Vector&lt;SecurityOriginData&gt;&amp; origins, uint64_t callbackID)</span>
624 {
<span class="line-modified">625     if (!m_databaseDirectoryPath.isEmpty()) {</span>
<span class="line-modified">626         for (const auto&amp; origin : origins) {</span>
<span class="line-modified">627             String originPath = FileSystem::pathByAppendingComponent(m_databaseDirectoryPath, origin.databaseIdentifier());</span>
<span class="line-modified">628             removeAllDatabasesForOriginPath(originPath, -WallTime::infinity());</span>
629 
<span class="line-modified">630             for (const auto&amp; topOriginPath : FileSystem::listDirectory(m_databaseDirectoryPath, &quot;*&quot;)) {</span>
<span class="line-modified">631                 originPath = FileSystem::pathByAppendingComponent(topOriginPath, origin.databaseIdentifier());</span>
<span class="line-modified">632                 removeAllDatabasesForOriginPath(originPath, -WallTime::infinity());</span>
<span class="line-removed">633             }</span>
634         }
635     }








636 
637     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;IDBServer::didPerformCloseAndDeleteDatabases, callbackID));
638 }
639 
640 void IDBServer::didPerformCloseAndDeleteDatabases(uint64_t callbackID)
641 {



642     auto callback = m_deleteDatabaseCompletionHandlers.take(callbackID);
643     ASSERT(callback);
644     callback();
645 }
646 
<span class="line-modified">647 void IDBServer::setPerOriginQuota(uint64_t quota)</span>




648 {
<span class="line-modified">649     m_perOriginQuota = quota;</span>




























































































































































650 
651     for (auto&amp; database : m_uniqueIDBDatabaseMap.values())
<span class="line-modified">652         database-&gt;setQuota(quota);</span>








653 }
654 
655 } // namespace IDBServer
656 } // namespace WebCore
657 
658 #endif // ENABLE(INDEXED_DATABASE)
</pre>
</td>
<td>
<hr />
<pre>
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;IDBServer.h&quot;
 28 
 29 #if ENABLE(INDEXED_DATABASE)
 30 
 31 #include &quot;IDBRequestData.h&quot;
 32 #include &quot;IDBResultData.h&quot;
 33 #include &quot;Logging.h&quot;
 34 #include &quot;MemoryIDBBackingStore.h&quot;
<span class="line-added"> 35 #include &quot;SQLiteDatabase.h&quot;</span>
<span class="line-added"> 36 #include &quot;SQLiteDatabaseTracker.h&quot;</span>
 37 #include &quot;SQLiteFileSystem.h&quot;
 38 #include &quot;SQLiteIDBBackingStore.h&quot;
<span class="line-added"> 39 #include &quot;SQLiteStatement.h&quot;</span>
 40 #include &quot;SecurityOrigin.h&quot;
<span class="line-added"> 41 #include &quot;StorageQuotaManager.h&quot;</span>
 42 #include &lt;wtf/CrossThreadCopier.h&gt;
 43 #include &lt;wtf/Locker.h&gt;
 44 #include &lt;wtf/MainThread.h&gt;
 45 
 46 namespace WebCore {
 47 namespace IDBServer {
 48 
<span class="line-modified"> 49 Ref&lt;IDBServer&gt; IDBServer::create(PAL::SessionID sessionID, IDBBackingStoreTemporaryFileHandler&amp; fileHandler, QuotaManagerGetter&amp;&amp; quotaManagerGetter)</span>
 50 {
<span class="line-modified"> 51     return adoptRef(*new IDBServer(sessionID, fileHandler, WTFMove(quotaManagerGetter)));</span>
 52 }
 53 
<span class="line-modified"> 54 Ref&lt;IDBServer&gt; IDBServer::create(PAL::SessionID sessionID, const String&amp; databaseDirectoryPath, IDBBackingStoreTemporaryFileHandler&amp; fileHandler, QuotaManagerGetter&amp;&amp; quotaManagerGetter)</span>
 55 {
<span class="line-modified"> 56     return adoptRef(*new IDBServer(sessionID, databaseDirectoryPath, fileHandler, WTFMove(quotaManagerGetter)));</span>
 57 }
 58 
<span class="line-modified"> 59 IDBServer::IDBServer(PAL::SessionID sessionID, IDBBackingStoreTemporaryFileHandler&amp; fileHandler, QuotaManagerGetter&amp;&amp; quotaManagerGetter)</span>
<span class="line-modified"> 60     : CrossThreadTaskHandler(&quot;IndexedDatabase Server&quot;, AutodrainedPoolForRunLoop::Use)</span>
<span class="line-added"> 61     , m_sessionID(sessionID)</span>
 62     , m_backingStoreTemporaryFileHandler(fileHandler)
<span class="line-added"> 63     , m_quotaManagerGetter(WTFMove(quotaManagerGetter))</span>
 64 {
 65 }
 66 
<span class="line-modified"> 67 IDBServer::IDBServer(PAL::SessionID sessionID, const String&amp; databaseDirectoryPath, IDBBackingStoreTemporaryFileHandler&amp; fileHandler, QuotaManagerGetter&amp;&amp; quotaManagerGetter)</span>
<span class="line-modified"> 68     : CrossThreadTaskHandler(&quot;IndexedDatabase Server&quot;, AutodrainedPoolForRunLoop::Use)</span>
<span class="line-added"> 69     , m_sessionID(sessionID)</span>
 70     , m_databaseDirectoryPath(databaseDirectoryPath)
 71     , m_backingStoreTemporaryFileHandler(fileHandler)
<span class="line-added"> 72     , m_quotaManagerGetter(WTFMove(quotaManagerGetter))</span>
 73 {
 74     LOG(IndexedDB, &quot;IDBServer created at path %s&quot;, databaseDirectoryPath.utf8().data());
<span class="line-added"> 75     postDatabaseTask(createCrossThreadTask(*this, &amp;IDBServer::upgradeFilesIfNecessary));</span>
 76 }
 77 
 78 void IDBServer::registerConnection(IDBConnectionToClient&amp; connection)
 79 {
 80     ASSERT(!m_connectionMap.contains(connection.identifier()));
 81     m_connectionMap.set(connection.identifier(), &amp;connection);
 82 }
 83 
 84 void IDBServer::unregisterConnection(IDBConnectionToClient&amp; connection)
 85 {
 86     ASSERT(m_connectionMap.contains(connection.identifier()));
 87     ASSERT(m_connectionMap.get(connection.identifier()) == &amp;connection);
 88 
 89     connection.connectionToClientClosed();
 90 
 91     m_connectionMap.remove(connection.identifier());
 92 }
 93 
 94 void IDBServer::registerTransaction(UniqueIDBDatabaseTransaction&amp; transaction)
 95 {
</pre>
<hr />
<pre>
106 }
107 
108 void IDBServer::registerDatabaseConnection(UniqueIDBDatabaseConnection&amp; connection)
109 {
110     ASSERT(!m_databaseConnections.contains(connection.identifier()));
111     m_databaseConnections.set(connection.identifier(), &amp;connection);
112 }
113 
114 void IDBServer::unregisterDatabaseConnection(UniqueIDBDatabaseConnection&amp; connection)
115 {
116     ASSERT(m_databaseConnections.contains(connection.identifier()));
117     m_databaseConnections.remove(connection.identifier());
118 }
119 
120 UniqueIDBDatabase&amp; IDBServer::getOrCreateUniqueIDBDatabase(const IDBDatabaseIdentifier&amp; identifier)
121 {
122     ASSERT(isMainThread());
123 
124     auto uniqueIDBDatabase = m_uniqueIDBDatabaseMap.add(identifier, nullptr);
125     if (uniqueIDBDatabase.isNewEntry)
<span class="line-modified">126         uniqueIDBDatabase.iterator-&gt;value = makeUnique&lt;UniqueIDBDatabase&gt;(*this, identifier);</span>
127 
128     return *uniqueIDBDatabase.iterator-&gt;value;
129 }
130 
131 std::unique_ptr&lt;IDBBackingStore&gt; IDBServer::createBackingStore(const IDBDatabaseIdentifier&amp; identifier)
132 {
133     ASSERT(!isMainThread());
134 
<span class="line-modified">135     auto databaseDirectoryPath = this-&gt;databaseDirectoryPathIsolatedCopy();</span>
<span class="line-modified">136     if (databaseDirectoryPath.isEmpty())</span>
<span class="line-added">137         return MemoryIDBBackingStore::create(m_sessionID, identifier);</span>
138 
<span class="line-modified">139     return makeUnique&lt;SQLiteIDBBackingStore&gt;(m_sessionID, identifier, databaseDirectoryPath, m_backingStoreTemporaryFileHandler);</span>
140 }
141 
142 void IDBServer::openDatabase(const IDBRequestData&amp; requestData)
143 {
144     LOG(IndexedDB, &quot;IDBServer::openDatabase&quot;);
145 
146     auto&amp; uniqueIDBDatabase = getOrCreateUniqueIDBDatabase(requestData.databaseIdentifier());
147 
148     auto connection = m_connectionMap.get(requestData.requestIdentifier().connectionIdentifier());
149     if (!connection) {
150         // If the connection back to the client is gone, there&#39;s no way to open the database as
151         // well as no way to message back failure.
152         return;
153     }
154 
155     uniqueIDBDatabase.openDatabaseConnection(*connection, requestData);
156 }
157 
158 void IDBServer::deleteDatabase(const IDBRequestData&amp; requestData)
159 {
</pre>
<hr />
<pre>
450         return;
451 
452     uniqueIDBDatabase-&gt;openDBRequestCancelled(requestData.requestIdentifier());
453 }
454 
455 void IDBServer::confirmDidCloseFromServer(uint64_t databaseConnectionIdentifier)
456 {
457     LOG(IndexedDB, &quot;IDBServer::confirmDidCloseFromServer&quot;);
458 
459     if (auto databaseConnection = m_databaseConnections.get(databaseConnectionIdentifier))
460         databaseConnection-&gt;confirmDidCloseFromServer();
461 }
462 
463 void IDBServer::getAllDatabaseNames(uint64_t serverConnectionIdentifier, const SecurityOriginData&amp; mainFrameOrigin, const SecurityOriginData&amp; openingOrigin, uint64_t callbackID)
464 {
465     postDatabaseTask(createCrossThreadTask(*this, &amp;IDBServer::performGetAllDatabaseNames, serverConnectionIdentifier, mainFrameOrigin, openingOrigin, callbackID));
466 }
467 
468 void IDBServer::performGetAllDatabaseNames(uint64_t serverConnectionIdentifier, const SecurityOriginData&amp; mainFrameOrigin, const SecurityOriginData&amp; openingOrigin, uint64_t callbackID)
469 {
<span class="line-modified">470     auto databaseDirectoryPath = this-&gt;databaseDirectoryPathIsolatedCopy();</span>
<span class="line-modified">471     String oldDirectory = IDBDatabaseIdentifier::databaseDirectoryRelativeToRoot(mainFrameOrigin, openingOrigin, databaseDirectoryPath, &quot;v0&quot;);</span>
<span class="line-modified">472     Vector&lt;String&gt; files = FileSystem::listDirectory(oldDirectory, &quot;*&quot;_s);</span>
473     Vector&lt;String&gt; databases;
<span class="line-modified">474     for (auto&amp; file : files) {</span>
<span class="line-modified">475         String encodedName = FileSystem::lastComponentOfPathIgnoringTrailingSlash(file);</span>
<span class="line-modified">476         databases.append(SQLiteIDBBackingStore::databaseNameFromEncodedFilename(encodedName));</span>
<span class="line-modified">477     }</span>
<span class="line-added">478 </span>
<span class="line-added">479     String directory = IDBDatabaseIdentifier::databaseDirectoryRelativeToRoot(mainFrameOrigin, openingOrigin, databaseDirectoryPath, &quot;v1&quot;);</span>
<span class="line-added">480     files = FileSystem::listDirectory(directory, &quot;*&quot;_s);</span>
<span class="line-added">481     for (auto&amp; file : files) {</span>
<span class="line-added">482         auto databaseName = SQLiteIDBBackingStore::databaseNameFromFile(SQLiteIDBBackingStore::fullDatabasePathForDirectory(file));</span>
<span class="line-added">483         if (!databaseName.isEmpty())</span>
<span class="line-added">484             databases.append(databaseName);</span>
485     }
486 
487     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;IDBServer::didGetAllDatabaseNames, serverConnectionIdentifier, callbackID, databases));
488 }
489 
490 void IDBServer::didGetAllDatabaseNames(uint64_t serverConnectionIdentifier, uint64_t callbackID, const Vector&lt;String&gt;&amp; databaseNames)
491 {
492     auto connection = m_connectionMap.get(serverConnectionIdentifier);
493     if (!connection)
494         return;
495 
496     connection-&gt;didGetAllDatabaseNames(callbackID, databaseNames);
497 }
498 
499 void IDBServer::postDatabaseTask(CrossThreadTask&amp;&amp; task)
500 {
501     postTask(WTFMove(task));
502 }
503 
504 void IDBServer::postDatabaseTaskReply(CrossThreadTask&amp;&amp; task)
</pre>
<hr />
<pre>
541     auto addResult = m_deleteDatabaseCompletionHandlers.add(callbackID, WTFMove(completionHandler));
542     ASSERT_UNUSED(addResult, addResult.isNewEntry);
543 
544     HashSet&lt;UniqueIDBDatabase*&gt; openDatabases;
545     for (auto&amp; database : m_uniqueIDBDatabaseMap.values()) {
546         const auto&amp; identifier = database-&gt;identifier();
547         for (auto&amp; origin : origins) {
548             if (identifier.isRelatedToOrigin(origin)) {
549                 openDatabases.add(database.get());
550                 break;
551             }
552         }
553     }
554 
555     for (auto&amp; database : openDatabases)
556         database-&gt;immediateCloseForUserDelete();
557 
558     postDatabaseTask(createCrossThreadTask(*this, &amp;IDBServer::performCloseAndDeleteDatabasesForOrigins, origins, callbackID));
559 }
560 
<span class="line-modified">561 static void removeAllDatabasesForFullOriginPath(const String&amp; originPath, WallTime modifiedSince)</span>
562 {
563     LOG(IndexedDB, &quot;removeAllDatabasesForOriginPath with originPath %s&quot;, originPath.utf8().data());
564     Vector&lt;String&gt; databasePaths = FileSystem::listDirectory(originPath, &quot;*&quot;);
565 
566     for (auto&amp; databasePath : databasePaths) {



567         String databaseFile = FileSystem::pathByAppendingComponent(databasePath, &quot;IndexedDB.sqlite3&quot;);
568         if (modifiedSince &gt; -WallTime::infinity() &amp;&amp; FileSystem::fileExists(databaseFile)) {
569             auto modificationTime = FileSystem::getFileModificationTime(databaseFile);
570             if (!modificationTime)
571                 continue;
572 
573             if (modificationTime.value() &lt; modifiedSince)
574                 continue;
575         }
576 
577         // Deleting this database means we need to delete all files that represent it.
578         // This includes:
579         //     - The directory itself, which is named after the database.
580         //     - IndexedDB.sqlite3 and related SQLite files.
581         //     - Blob files that we stored in the directory.
582         //
583         // To be conservative, we should *not* try to delete files that are unexpected;
584         // We should only delete files we think we put there.
585         //
586         // IndexedDB blob files are named &quot;N.blob&quot; where N is a decimal integer,
</pre>
<hr />
<pre>
606                     validFilename = false;
607                     break;
608                 }
609             }
610 
611             if (validFilename)
612                 FileSystem::deleteFile(blobPath);
613         }
614 
615         // Now delete IndexedDB.sqlite3 and related SQLite files.
616         SQLiteFileSystem::deleteDatabaseFile(databaseFile);
617 
618         // And finally, if we can, delete the empty directory.
619         FileSystem::deleteEmptyDirectory(databasePath);
620     }
621 
622     // If no databases remain for this origin, we can delete the origin directory as well.
623     FileSystem::deleteEmptyDirectory(originPath);
624 }
625 
<span class="line-modified">626 static void removeAllDatabasesForOriginPath(const String&amp; originPath, WallTime modifiedSince)</span>
627 {
<span class="line-modified">628     String databaseIdentifier = FileSystem::lastComponentOfPathIgnoringTrailingSlash(originPath);</span>
<span class="line-modified">629     if (!SecurityOriginData::fromDatabaseIdentifier(databaseIdentifier))</span>
<span class="line-modified">630         return;</span>
<span class="line-added">631 </span>
<span class="line-added">632     auto directories = FileSystem::listDirectory(originPath, &quot;*&quot;_s);</span>
<span class="line-added">633     for (auto&amp; directory : directories) {</span>
<span class="line-added">634         String databaseIdentifier = FileSystem::lastComponentOfPathIgnoringTrailingSlash(directory);</span>
<span class="line-added">635         if (auto securityOrigin = SecurityOriginData::fromDatabaseIdentifier(databaseIdentifier))</span>
<span class="line-added">636             removeAllDatabasesForFullOriginPath(directory, modifiedSince);</span>
<span class="line-added">637     }</span>
<span class="line-added">638 </span>
<span class="line-added">639     removeAllDatabasesForFullOriginPath(originPath, modifiedSince);</span>
<span class="line-added">640 }</span>
<span class="line-added">641 </span>
<span class="line-added">642 void IDBServer::removeDatabasesModifiedSinceForVersion(WallTime modifiedSince, const String&amp; version)</span>
<span class="line-added">643 {</span>
<span class="line-added">644     String versionPath = FileSystem::pathByAppendingComponent(databaseDirectoryPathIsolatedCopy(), version);</span>
<span class="line-added">645     for (auto&amp; originPath : FileSystem::listDirectory(versionPath, &quot;*&quot;)) {</span>
<span class="line-added">646         String databaseIdentifier = FileSystem::lastComponentOfPathIgnoringTrailingSlash(originPath);</span>
<span class="line-added">647         if (auto securityOrigin = SecurityOriginData::fromDatabaseIdentifier(databaseIdentifier))</span>
648             removeAllDatabasesForOriginPath(originPath, modifiedSince);
649     }
<span class="line-added">650 }</span>
<span class="line-added">651 </span>
<span class="line-added">652 void IDBServer::performCloseAndDeleteDatabasesModifiedSince(WallTime modifiedSince, uint64_t callbackID)</span>
<span class="line-added">653 {</span>
<span class="line-added">654     if (!databaseDirectoryPathIsolatedCopy().isEmpty()) {</span>
<span class="line-added">655         removeDatabasesModifiedSinceForVersion(modifiedSince, &quot;v0&quot;);</span>
<span class="line-added">656         removeDatabasesModifiedSinceForVersion(modifiedSince, &quot;v1&quot;);</span>
<span class="line-added">657     }</span>
658 
659     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;IDBServer::didPerformCloseAndDeleteDatabases, callbackID));
660 }
661 
<span class="line-modified">662 void IDBServer::removeDatabasesWithOriginsForVersion(const Vector&lt;SecurityOriginData&gt; &amp;origins, const String&amp; version)</span>
663 {
<span class="line-modified">664     String versionPath = FileSystem::pathByAppendingComponent(databaseDirectoryPathIsolatedCopy(), version);</span>
<span class="line-modified">665     for (const auto&amp; origin : origins) {</span>
<span class="line-modified">666         String originPath = FileSystem::pathByAppendingComponent(versionPath, origin.databaseIdentifier());</span>
<span class="line-modified">667         removeAllDatabasesForOriginPath(originPath, -WallTime::infinity());</span>
668 
<span class="line-modified">669         for (auto&amp; topOriginPath : FileSystem::listDirectory(versionPath, &quot;*&quot;)) {</span>
<span class="line-modified">670             originPath = FileSystem::pathByAppendingComponent(topOriginPath, origin.databaseIdentifier());</span>
<span class="line-modified">671             removeAllDatabasesForOriginPath(originPath, -WallTime::infinity());</span>

672         }
673     }
<span class="line-added">674 }</span>
<span class="line-added">675 </span>
<span class="line-added">676 void IDBServer::performCloseAndDeleteDatabasesForOrigins(const Vector&lt;SecurityOriginData&gt;&amp; origins, uint64_t callbackID)</span>
<span class="line-added">677 {</span>
<span class="line-added">678     if (!databaseDirectoryPathIsolatedCopy().isEmpty()) {</span>
<span class="line-added">679         removeDatabasesWithOriginsForVersion(origins, &quot;v0&quot;);</span>
<span class="line-added">680         removeDatabasesWithOriginsForVersion(origins, &quot;v1&quot;);</span>
<span class="line-added">681     }</span>
682 
683     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;IDBServer::didPerformCloseAndDeleteDatabases, callbackID));
684 }
685 
686 void IDBServer::didPerformCloseAndDeleteDatabases(uint64_t callbackID)
687 {
<span class="line-added">688     for (auto&amp; user : m_quotaUsers.values())</span>
<span class="line-added">689         user-&gt;resetSpaceUsed();</span>
<span class="line-added">690 </span>
691     auto callback = m_deleteDatabaseCompletionHandlers.take(callbackID);
692     ASSERT(callback);
693     callback();
694 }
695 
<span class="line-modified">696 IDBServer::QuotaUser::QuotaUser(IDBServer&amp; server, StorageQuotaManager* manager, ClientOrigin&amp;&amp; origin)</span>
<span class="line-added">697     : m_server(server)</span>
<span class="line-added">698     , m_manager(makeWeakPtr(manager))</span>
<span class="line-added">699     , m_origin(WTFMove(origin))</span>
<span class="line-added">700     , m_isInitialized(m_server.m_sessionID.isEphemeral())</span>
701 {
<span class="line-modified">702     if (manager)</span>
<span class="line-added">703         manager-&gt;addUser(*this);</span>
<span class="line-added">704 }</span>
<span class="line-added">705 </span>
<span class="line-added">706 IDBServer::QuotaUser::~QuotaUser()</span>
<span class="line-added">707 {</span>
<span class="line-added">708     if (m_manager)</span>
<span class="line-added">709         m_manager-&gt;removeUser(*this);</span>
<span class="line-added">710 }</span>
<span class="line-added">711 </span>
<span class="line-added">712 void IDBServer::QuotaUser::resetSpaceUsed()</span>
<span class="line-added">713 {</span>
<span class="line-added">714     m_spaceUsed = 0;</span>
<span class="line-added">715     m_estimatedSpaceIncrease = 0;</span>
<span class="line-added">716 </span>
<span class="line-added">717     if (!m_manager)</span>
<span class="line-added">718         return;</span>
<span class="line-added">719 </span>
<span class="line-added">720     if (m_server.m_sessionID.isEphemeral())</span>
<span class="line-added">721         return;</span>
<span class="line-added">722 </span>
<span class="line-added">723     if (!m_isInitialized)</span>
<span class="line-added">724         return;</span>
<span class="line-added">725 </span>
<span class="line-added">726     ASSERT(!m_initializationCallback);</span>
<span class="line-added">727 </span>
<span class="line-added">728     m_isInitialized = false;</span>
<span class="line-added">729 </span>
<span class="line-added">730     // Do add/remove to trigger call to whenInitialized.</span>
<span class="line-added">731     m_manager-&gt;removeUser(*this);</span>
<span class="line-added">732     m_manager-&gt;addUser(*this);</span>
<span class="line-added">733 }</span>
<span class="line-added">734 </span>
<span class="line-added">735 void IDBServer::QuotaUser::increaseSpaceUsed(uint64_t size)</span>
<span class="line-added">736 {</span>
<span class="line-added">737     if (!m_isInitialized)</span>
<span class="line-added">738         return;</span>
<span class="line-added">739     ASSERT(m_spaceUsed + size &gt; m_spaceUsed);</span>
<span class="line-added">740     m_spaceUsed += size;</span>
<span class="line-added">741 }</span>
<span class="line-added">742 void IDBServer::QuotaUser::decreaseSpaceUsed(uint64_t size)</span>
<span class="line-added">743 {</span>
<span class="line-added">744     if (!m_isInitialized)</span>
<span class="line-added">745         return;</span>
<span class="line-added">746     ASSERT(m_spaceUsed &gt;= size);</span>
<span class="line-added">747     m_spaceUsed -= size;</span>
<span class="line-added">748 }</span>
<span class="line-added">749 </span>
<span class="line-added">750 void IDBServer::QuotaUser::whenInitialized(CompletionHandler&lt;void()&gt;&amp;&amp; callback)</span>
<span class="line-added">751 {</span>
<span class="line-added">752     if (m_isInitialized) {</span>
<span class="line-added">753         callback();</span>
<span class="line-added">754         return;</span>
<span class="line-added">755     }</span>
<span class="line-added">756     m_initializationCallback = WTFMove(callback);</span>
<span class="line-added">757     m_server.startComputingSpaceUsedForOrigin(m_origin);</span>
<span class="line-added">758 }</span>
<span class="line-added">759 </span>
<span class="line-added">760 void IDBServer::QuotaUser::initializeSpaceUsed(uint64_t spaceUsed)</span>
<span class="line-added">761 {</span>
<span class="line-added">762     ASSERT(m_isInitialized || !m_estimatedSpaceIncrease);</span>
<span class="line-added">763     m_spaceUsed = spaceUsed;</span>
<span class="line-added">764     m_isInitialized = true;</span>
<span class="line-added">765 </span>
<span class="line-added">766     if (auto callback = WTFMove(m_initializationCallback))</span>
<span class="line-added">767         callback();</span>
<span class="line-added">768 }</span>
<span class="line-added">769 </span>
<span class="line-added">770 IDBServer::QuotaUser&amp; IDBServer::ensureQuotaUser(const ClientOrigin&amp; origin)</span>
<span class="line-added">771 {</span>
<span class="line-added">772     return *m_quotaUsers.ensure(origin, [this, &amp;origin] {</span>
<span class="line-added">773         return makeUnique&lt;QuotaUser&gt;(*this, m_quotaManagerGetter(m_sessionID, origin), ClientOrigin { origin });</span>
<span class="line-added">774     }).iterator-&gt;value;</span>
<span class="line-added">775 }</span>
<span class="line-added">776 </span>
<span class="line-added">777 void IDBServer::startComputingSpaceUsedForOrigin(const ClientOrigin&amp; origin)</span>
<span class="line-added">778 {</span>
<span class="line-added">779     ASSERT(!m_sessionID.isEphemeral());</span>
<span class="line-added">780     postDatabaseTask(createCrossThreadTask(*this, &amp;IDBServer::computeSpaceUsedForOrigin, origin));</span>
<span class="line-added">781 }</span>
<span class="line-added">782 </span>
<span class="line-added">783 void IDBServer::computeSpaceUsedForOrigin(const ClientOrigin&amp; origin)</span>
<span class="line-added">784 {</span>
<span class="line-added">785     ASSERT(!isMainThread());</span>
<span class="line-added">786 </span>
<span class="line-added">787     auto databaseDirectoryPath = this-&gt;databaseDirectoryPathIsolatedCopy();</span>
<span class="line-added">788     auto oldVersionOriginDirectory = IDBDatabaseIdentifier::databaseDirectoryRelativeToRoot(origin.topOrigin, origin.clientOrigin, databaseDirectoryPath, &quot;v0&quot;);</span>
<span class="line-added">789     auto newVersionOriginDirectory = IDBDatabaseIdentifier::databaseDirectoryRelativeToRoot(origin.topOrigin, origin.clientOrigin, databaseDirectoryPath, &quot;v1&quot;);</span>
<span class="line-added">790     auto size = SQLiteIDBBackingStore::databasesSizeForDirectory(oldVersionOriginDirectory) + SQLiteIDBBackingStore::databasesSizeForDirectory(newVersionOriginDirectory);</span>
<span class="line-added">791 </span>
<span class="line-added">792     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;IDBServer::finishComputingSpaceUsedForOrigin, origin, size));</span>
<span class="line-added">793 }</span>
<span class="line-added">794 </span>
<span class="line-added">795 void IDBServer::finishComputingSpaceUsedForOrigin(const ClientOrigin&amp; origin, uint64_t spaceUsed)</span>
<span class="line-added">796 {</span>
<span class="line-added">797     ensureQuotaUser(origin).initializeSpaceUsed(spaceUsed);</span>
<span class="line-added">798 }</span>
<span class="line-added">799 </span>
<span class="line-added">800 void IDBServer::requestSpace(const ClientOrigin&amp; origin, uint64_t taskSize, CompletionHandler&lt;void(StorageQuotaManager::Decision)&gt;&amp;&amp; callback)</span>
<span class="line-added">801 {</span>
<span class="line-added">802     auto* quotaManager = ensureQuotaUser(origin).manager();</span>
<span class="line-added">803     if (!quotaManager) {</span>
<span class="line-added">804         callback(StorageQuotaManager::Decision::Deny);</span>
<span class="line-added">805         return;</span>
<span class="line-added">806     }</span>
<span class="line-added">807 </span>
<span class="line-added">808     quotaManager-&gt;requestSpace(taskSize, WTFMove(callback));</span>
<span class="line-added">809 }</span>
<span class="line-added">810 </span>
<span class="line-added">811 void IDBServer::resetSpaceUsed(const ClientOrigin&amp; origin)</span>
<span class="line-added">812 {</span>
<span class="line-added">813     if (auto* user = m_quotaUsers.get(origin))</span>
<span class="line-added">814         user-&gt;resetSpaceUsed();</span>
<span class="line-added">815 }</span>
<span class="line-added">816 </span>
<span class="line-added">817 void IDBServer::increaseSpaceUsed(const ClientOrigin&amp; origin, uint64_t size)</span>
<span class="line-added">818 {</span>
<span class="line-added">819     ensureQuotaUser(origin).increaseSpaceUsed(size);</span>
<span class="line-added">820 }</span>
<span class="line-added">821 </span>
<span class="line-added">822 void IDBServer::decreaseSpaceUsed(const ClientOrigin&amp; origin, uint64_t size)</span>
<span class="line-added">823 {</span>
<span class="line-added">824     ensureQuotaUser(origin).decreaseSpaceUsed(size);</span>
<span class="line-added">825 }</span>
<span class="line-added">826 </span>
<span class="line-added">827 void IDBServer::increasePotentialSpaceUsed(const ClientOrigin&amp; origin, uint64_t taskSize)</span>
<span class="line-added">828 {</span>
<span class="line-added">829     ensureQuotaUser(origin).increasePotentialSpaceUsed(taskSize);</span>
<span class="line-added">830 }</span>
<span class="line-added">831 </span>
<span class="line-added">832 void IDBServer::decreasePotentialSpaceUsed(const ClientOrigin&amp; origin, uint64_t spaceUsed)</span>
<span class="line-added">833 {</span>
<span class="line-added">834     ensureQuotaUser(origin).decreasePotentialSpaceUsed(spaceUsed);</span>
<span class="line-added">835 }</span>
<span class="line-added">836 </span>
<span class="line-added">837 void IDBServer::upgradeFilesIfNecessary()</span>
<span class="line-added">838 {</span>
<span class="line-added">839     auto databaseDirectoryPath = this-&gt;databaseDirectoryPathIsolatedCopy();</span>
<span class="line-added">840     if (databaseDirectoryPath.isEmpty() || !FileSystem::fileExists(databaseDirectoryPath))</span>
<span class="line-added">841         return;</span>
<span class="line-added">842 </span>
<span class="line-added">843     String newVersionDirectory = FileSystem::pathByAppendingComponent(databaseDirectoryPath, &quot;v1&quot;);</span>
<span class="line-added">844     if (!FileSystem::fileExists(newVersionDirectory))</span>
<span class="line-added">845         FileSystem::makeAllDirectories(newVersionDirectory);</span>
<span class="line-added">846 }</span>
<span class="line-added">847 </span>
<span class="line-added">848 void IDBServer::tryStop(ShouldForceStop shouldForceStop)</span>
<span class="line-added">849 {</span>
<span class="line-added">850     // Only stop non-ephemeral IDBServers that can hold locked database files.</span>
<span class="line-added">851     if (m_sessionID.isEphemeral())</span>
<span class="line-added">852         return;</span>
<span class="line-added">853 </span>
<span class="line-added">854     suspendAndWait();</span>
<span class="line-added">855     if (shouldForceStop == ShouldForceStop::No &amp;&amp; SQLiteDatabaseTracker::hasTransactionInProgress()) {</span>
<span class="line-added">856         CrossThreadTaskHandler::resume();</span>
<span class="line-added">857         return;</span>
<span class="line-added">858     }</span>
859 
860     for (auto&amp; database : m_uniqueIDBDatabaseMap.values())
<span class="line-modified">861         database-&gt;finishActiveTransactions();</span>
<span class="line-added">862 }</span>
<span class="line-added">863 </span>
<span class="line-added">864 void IDBServer::resume()</span>
<span class="line-added">865 {</span>
<span class="line-added">866     if (m_sessionID.isEphemeral())</span>
<span class="line-added">867         return;</span>
<span class="line-added">868 </span>
<span class="line-added">869     CrossThreadTaskHandler::resume();</span>
870 }
871 
872 } // namespace IDBServer
873 } // namespace WebCore
874 
875 #endif // ENABLE(INDEXED_DATABASE)
</pre>
</td>
</tr>
</table>
<center><a href="IDBBackingStore.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="IDBServer.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>