<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/css/parser/CSSSelectorParser.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CSSPropertyParserHelpers.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="CSSSelectorParser.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/css/parser/CSSSelectorParser.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 78     Vector&lt;std::unique_ptr&lt;CSSParserSelector&gt;&gt; selectorList;
 79     std::unique_ptr&lt;CSSParserSelector&gt; selector = consumeCompoundSelector(range);
 80     range.consumeWhitespace();
 81     if (!selector)
 82         return CSSSelectorList();
 83     selectorList.append(WTFMove(selector));
 84     while (!range.atEnd() &amp;&amp; range.peek().type() == CommaToken) {
 85         range.consumeIncludingWhitespace();
 86         selector = consumeCompoundSelector(range);
 87         range.consumeWhitespace();
 88         if (!selector)
 89             return CSSSelectorList();
 90         selectorList.append(WTFMove(selector));
 91     }
 92 
 93     if (m_failedParsing)
 94         return { };
 95     return CSSSelectorList { WTFMove(selectorList) };
 96 }
 97 
<span class="line-modified"> 98 static bool consumeLangArgumentList(std::unique_ptr&lt;Vector&lt;AtomicString&gt;&gt;&amp; argumentList, CSSParserTokenRange&amp; range)</span>
 99 {
100     const CSSParserToken&amp; ident = range.consumeIncludingWhitespace();
101     if (ident.type() != IdentToken &amp;&amp; ident.type() != StringToken)
102         return false;
103     StringView string = ident.value();
104     if (string.startsWith(&quot;--&quot;))
105         return false;
<span class="line-modified">106     argumentList-&gt;append(string.toAtomicString());</span>
107     while (!range.atEnd() &amp;&amp; range.peek().type() == CommaToken) {
108         range.consumeIncludingWhitespace();
109         const CSSParserToken&amp; ident = range.consumeIncludingWhitespace();
110         if (ident.type() != IdentToken &amp;&amp; ident.type() != StringToken)
111             return false;
112         StringView string = ident.value();
113         if (string.startsWith(&quot;--&quot;))
114             return false;
<span class="line-modified">115         argumentList-&gt;append(string.toAtomicString());</span>
116     }
117     return range.atEnd();
118 }
119 
120 namespace {
121 
122 enum CompoundSelectorFlags {
123     HasPseudoElementForRightmostCompound = 1 &lt;&lt; 0,
124     HasContentPseudoElement = 1 &lt;&lt; 1
125 };
126 
127 unsigned extractCompoundFlags(const CSSParserSelector&amp; simpleSelector, CSSParserMode parserMode)
128 {
129     if (simpleSelector.match() != CSSSelector::PseudoElement)
130         return 0;
131 
132     // FIXME: https://bugs.webkit.org/show_bug.cgi?id=161747
133     // The UASheetMode check is a work-around to allow this selector in mediaControls(New).css:
134     // input[type=&quot;range&quot; i]::-webkit-media-slider-container &gt; div {
135     if (parserMode == UASheetMode &amp;&amp; simpleSelector.pseudoElementType() == CSSSelector::PseudoElementWebKitCustom)
</pre>
<hr />
<pre>
243     // FIXME-NEWPARSER: This doesn&#39;t exist for us.
244     // if (compoundPseudoElement == CSSSelector::PseudoElementContent)
245     //    return simpleSelector.match() != CSSSelector::PseudoElement;
246     if (simpleSelector.match() != CSSSelector::PseudoClass)
247         return false;
248     CSSSelector::PseudoClassType pseudo = simpleSelector.pseudoClassType();
249     if (pseudo == CSSSelector::PseudoClassNot) {
250         ASSERT(simpleSelector.selectorList());
251         ASSERT(simpleSelector.selectorList()-&gt;first());
252         pseudo = simpleSelector.selectorList()-&gt;first()-&gt;pseudoClassType();
253     }
254     return isPseudoClassValidAfterPseudoElement(pseudo, compoundPseudoElement);
255 }
256 
257 } // namespace
258 
259 std::unique_ptr&lt;CSSParserSelector&gt; CSSSelectorParser::consumeCompoundSelector(CSSParserTokenRange&amp; range)
260 {
261     std::unique_ptr&lt;CSSParserSelector&gt; compoundSelector;
262 
<span class="line-modified">263     AtomicString namespacePrefix;</span>
<span class="line-modified">264     AtomicString elementName;</span>
265     CSSSelector::PseudoElementType compoundPseudoElement = CSSSelector::PseudoElementUnknown;
266     if (!consumeName(range, elementName, namespacePrefix)) {
267         compoundSelector = consumeSimpleSelector(range);
268         if (!compoundSelector)
269             return nullptr;
270         if (compoundSelector-&gt;match() == CSSSelector::PseudoElement)
271             compoundPseudoElement = compoundSelector-&gt;pseudoElementType();
272     }
273 
274     while (std::unique_ptr&lt;CSSParserSelector&gt; simpleSelector = consumeSimpleSelector(range)) {
275         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=161747
276         // The UASheetMode check is a work-around to allow this selector in mediaControls(New).css:
277         // video::-webkit-media-text-track-region-container.scrolling
278         if (m_context.mode != UASheetMode &amp;&amp; !isSimpleSelectorValidAfterPseudoElement(*simpleSelector.get(), compoundPseudoElement)) {
279             m_failedParsing = true;
280             return nullptr;
281         }
282         if (simpleSelector-&gt;match() == CSSSelector::PseudoElement)
283             compoundPseudoElement = simpleSelector-&gt;pseudoElementType();
284 
285         if (compoundSelector)
286             compoundSelector = addSimpleSelectorToCompound(WTFMove(compoundSelector), WTFMove(simpleSelector));
287         else
288             compoundSelector = WTFMove(simpleSelector);
289     }
290 
291     if (!compoundSelector) {
<span class="line-modified">292         AtomicString namespaceURI = determineNamespace(namespacePrefix);</span>
293         if (namespaceURI.isNull()) {
294             m_failedParsing = true;
295             return nullptr;
296         }
297         if (namespaceURI == defaultNamespace())
298             namespacePrefix = nullAtom();
299 
300         CSSParserSelector* rawSelector = new CSSParserSelector(QualifiedName(namespacePrefix, elementName, namespaceURI));
301         std::unique_ptr&lt;CSSParserSelector&gt; selector = std::unique_ptr&lt;CSSParserSelector&gt;(rawSelector);
302         return selector;
303     }
304     prependTypeSelectorIfNeeded(namespacePrefix, elementName, compoundSelector.get());
305     return splitCompoundAtImplicitShadowCrossingCombinator(WTFMove(compoundSelector), m_context);
306 }
307 
308 std::unique_ptr&lt;CSSParserSelector&gt; CSSSelectorParser::consumeSimpleSelector(CSSParserTokenRange&amp; range)
309 {
310     const CSSParserToken&amp; token = range.peek();
311     std::unique_ptr&lt;CSSParserSelector&gt; selector;
312     if (token.type() == HashToken)
313         selector = consumeId(range);
314     else if (token.type() == DelimiterToken &amp;&amp; token.delimiter() == &#39;.&#39;)
315         selector = consumeClass(range);
316     else if (token.type() == LeftBracketToken)
317         selector = consumeAttribute(range);
318     else if (token.type() == ColonToken)
319         selector = consumePseudo(range);
320     else
321         return nullptr;
322     if (!selector)
323         m_failedParsing = true;
324     return selector;
325 }
326 
<span class="line-modified">327 bool CSSSelectorParser::consumeName(CSSParserTokenRange&amp; range, AtomicString&amp; name, AtomicString&amp; namespacePrefix)</span>
328 {
329     name = nullAtom();
330     namespacePrefix = nullAtom();
331 
332     const CSSParserToken&amp; firstToken = range.peek();
333     if (firstToken.type() == IdentToken) {
<span class="line-modified">334         name = firstToken.value().toAtomicString();</span>
335         range.consume();
336     } else if (firstToken.type() == DelimiterToken &amp;&amp; firstToken.delimiter() == &#39;*&#39;) {
337         name = starAtom();
338         range.consume();
339     } else if (firstToken.type() == DelimiterToken &amp;&amp; firstToken.delimiter() == &#39;|&#39;) {
340         // This is an empty namespace, which&#39;ll get assigned this value below
341         name = emptyAtom();
342     } else
343         return false;
344 
345     if (range.peek().type() != DelimiterToken || range.peek().delimiter() != &#39;|&#39;)
346         return true;
347     range.consume();
348 
349     namespacePrefix = name;
350     const CSSParserToken&amp; nameToken = range.consume();
351     if (nameToken.type() == IdentToken) {
<span class="line-modified">352         name = nameToken.value().toAtomicString();</span>
353     } else if (nameToken.type() == DelimiterToken &amp;&amp; nameToken.delimiter() == &#39;*&#39;)
354         name = starAtom();
355     else {
356         name = nullAtom();
357         namespacePrefix = nullAtom();
358         return false;
359     }
360 
361     return true;
362 }
363 
364 std::unique_ptr&lt;CSSParserSelector&gt; CSSSelectorParser::consumeId(CSSParserTokenRange&amp; range)
365 {
366     ASSERT(range.peek().type() == HashToken);
367     if (range.peek().getHashTokenType() != HashTokenId)
368         return nullptr;
369     std::unique_ptr&lt;CSSParserSelector&gt; selector = std::unique_ptr&lt;CSSParserSelector&gt;(new CSSParserSelector());
370     selector-&gt;setMatch(CSSSelector::Id);
371 
372     // FIXME-NEWPARSER: Avoid having to do this, but the old parser does and we need
373     // to be compatible for now.
374     CSSParserToken token = range.consume();
<span class="line-modified">375     selector-&gt;setValue(token.value().toAtomicString(), m_context.mode == HTMLQuirksMode);</span>
376     return selector;
377 }
378 
379 std::unique_ptr&lt;CSSParserSelector&gt; CSSSelectorParser::consumeClass(CSSParserTokenRange&amp; range)
380 {
381     ASSERT(range.peek().type() == DelimiterToken);
382     ASSERT(range.peek().delimiter() == &#39;.&#39;);
383     range.consume();
384     if (range.peek().type() != IdentToken)
385         return nullptr;
386     std::unique_ptr&lt;CSSParserSelector&gt; selector = std::unique_ptr&lt;CSSParserSelector&gt;(new CSSParserSelector());
387     selector-&gt;setMatch(CSSSelector::Class);
388 
389     // FIXME-NEWPARSER: Avoid having to do this, but the old parser does and we need
390     // to be compatible for now.
391     CSSParserToken token = range.consume();
<span class="line-modified">392     selector-&gt;setValue(token.value().toAtomicString(), m_context.mode == HTMLQuirksMode);</span>
393 
394     return selector;
395 }
396 
397 std::unique_ptr&lt;CSSParserSelector&gt; CSSSelectorParser::consumeAttribute(CSSParserTokenRange&amp; range)
398 {
399     ASSERT(range.peek().type() == LeftBracketToken);
400     CSSParserTokenRange block = range.consumeBlock();
<span class="line-removed">401     if (block.end() == range.end())</span>
<span class="line-removed">402         return nullptr; // No ] was found. Be strict about this.</span>
<span class="line-removed">403 </span>
404     block.consumeWhitespace();
405 
<span class="line-modified">406     AtomicString namespacePrefix;</span>
<span class="line-modified">407     AtomicString attributeName;</span>
408     if (!consumeName(block, attributeName, namespacePrefix))
409         return nullptr;
410     block.consumeWhitespace();
411 
<span class="line-modified">412     AtomicString namespaceURI = determineNamespace(namespacePrefix);</span>
413     if (namespaceURI.isNull())
414         return nullptr;
415 
416     QualifiedName qualifiedName = namespacePrefix.isNull()
417         ? QualifiedName(nullAtom(), attributeName, nullAtom())
418         : QualifiedName(namespacePrefix, attributeName, namespaceURI);
419 
420     std::unique_ptr&lt;CSSParserSelector&gt; selector = std::unique_ptr&lt;CSSParserSelector&gt;(new CSSParserSelector());
421 
422     if (block.atEnd()) {
423         selector-&gt;setAttribute(qualifiedName, m_context.isHTMLDocument, CSSSelector::CaseSensitive);
424         selector-&gt;setMatch(CSSSelector::Set);
425         return selector;
426     }
427 
428     selector-&gt;setMatch(consumeAttributeMatch(block));
429 
430     const CSSParserToken&amp; attributeValue = block.consumeIncludingWhitespace();
431     if (attributeValue.type() != IdentToken &amp;&amp; attributeValue.type() != StringToken)
432         return nullptr;
<span class="line-modified">433     selector-&gt;setValue(attributeValue.value().toAtomicString());</span>
434 
435     selector-&gt;setAttribute(qualifiedName, m_context.isHTMLDocument, consumeAttributeFlags(block));
436 
437     if (!block.atEnd())
438         return nullptr;
439     return selector;
440 }
441 
442 static bool isOnlyPseudoClassFunction(CSSSelector::PseudoClassType pseudoClassType)
443 {
444     switch (pseudoClassType) {
445     case CSSSelector::PseudoClassNot:
446     case CSSSelector::PseudoClassMatches:
447     case CSSSelector::PseudoClassNthChild:
448     case CSSSelector::PseudoClassNthLastChild:
449     case CSSSelector::PseudoClassNthOfType:
450     case CSSSelector::PseudoClassNthLastOfType:
451     case CSSSelector::PseudoClassLang:
452     case CSSSelector::PseudoClassAny:
453 #if ENABLE(CSS_SELECTORS_LEVEL4)
</pre>
<hr />
<pre>
473     return false;
474 }
475 
476 std::unique_ptr&lt;CSSParserSelector&gt; CSSSelectorParser::consumePseudo(CSSParserTokenRange&amp; range)
477 {
478     ASSERT(range.peek().type() == ColonToken);
479     range.consume();
480 
481     int colons = 1;
482     if (range.peek().type() == ColonToken) {
483         range.consume();
484         colons++;
485     }
486 
487     const CSSParserToken&amp; token = range.peek();
488     if (token.type() != IdentToken &amp;&amp; token.type() != FunctionToken)
489         return nullptr;
490 
491     std::unique_ptr&lt;CSSParserSelector&gt; selector;
492 
<span class="line-removed">493     auto lowercasedValue = token.value().convertToASCIILowercase();</span>
<span class="line-removed">494     auto value = StringView { lowercasedValue };</span>
<span class="line-removed">495 </span>
496     if (colons == 1) {
<span class="line-modified">497         selector = std::unique_ptr&lt;CSSParserSelector&gt;(CSSParserSelector::parsePseudoClassSelectorFromStringView(value));</span>
498 #if ENABLE(ATTACHMENT_ELEMENT)
499         if (!m_context.attachmentEnabled &amp;&amp; selector &amp;&amp; selector-&gt;match() == CSSSelector::PseudoClass &amp;&amp; selector-&gt;pseudoClassType() == CSSSelector::PseudoClassHasAttachment)
500             return nullptr;
501 #endif
502     } else {
<span class="line-modified">503         selector = std::unique_ptr&lt;CSSParserSelector&gt;(CSSParserSelector::parsePseudoElementSelectorFromStringView(value));</span>
504 #if ENABLE(VIDEO_TRACK)
505         // Treat the ident version of cue as PseudoElementWebkitCustom.
506         if (token.type() == IdentToken &amp;&amp; selector &amp;&amp; selector-&gt;match() == CSSSelector::PseudoElement &amp;&amp; selector-&gt;pseudoElementType() == CSSSelector::PseudoElementCue)
507             selector-&gt;setPseudoElementType(CSSSelector::PseudoElementWebKitCustom);
508 #endif
509     }
510 
511     if (!selector || (selector-&gt;match() == CSSSelector::PseudoElement &amp;&amp; m_disallowPseudoElements))
512         return nullptr;
513 
514     if (token.type() == IdentToken) {
515         range.consume();
516         if ((selector-&gt;match() == CSSSelector::PseudoElement &amp;&amp; (selector-&gt;pseudoElementType() == CSSSelector::PseudoElementUnknown || isOnlyPseudoElementFunction(selector-&gt;pseudoElementType())))
517             || (selector-&gt;match() == CSSSelector::PseudoClass &amp;&amp; (selector-&gt;pseudoClassType() == CSSSelector::PseudoClassUnknown || isOnlyPseudoClassFunction(selector-&gt;pseudoClassType()))))
518             return nullptr;
519         return selector;
520     }
521 
522     CSSParserTokenRange block = range.consumeBlock();
<span class="line-removed">523     if (block.end() == range.end())</span>
<span class="line-removed">524         return nullptr; // No ) was found. Be strict about this.</span>
525     block.consumeWhitespace();
526     if (token.type() != FunctionToken)
527         return nullptr;
528 
529     const auto&amp; argumentStart = block.peek();
530 
531     if (selector-&gt;match() == CSSSelector::PseudoClass) {
532         switch (selector-&gt;pseudoClassType()) {
533         case CSSSelector::PseudoClassNot: {
534             DisallowPseudoElementsScope scope(this);
535             std::unique_ptr&lt;CSSSelectorList&gt; selectorList = std::unique_ptr&lt;CSSSelectorList&gt;(new CSSSelectorList());
536             *selectorList = consumeComplexSelectorList(block);
537             if (!selectorList-&gt;first() || !block.atEnd())
538                 return nullptr;
539             selector-&gt;setSelectorList(WTFMove(selectorList));
540             return selector;
541         }
542         case CSSSelector::PseudoClassNthChild:
543         case CSSSelector::PseudoClassNthLastChild:
544         case CSSSelector::PseudoClassNthOfType:
</pre>
<hr />
<pre>
555                 if (block.peek().type() != IdentToken)
556                     return nullptr;
557                 const CSSParserToken&amp; ident = block.consume();
558                 if (!equalIgnoringASCIICase(ident.value(), &quot;of&quot;))
559                     return nullptr;
560                 if (block.peek().type() != WhitespaceToken)
561                     return nullptr;
562                 DisallowPseudoElementsScope scope(this);
563                 block.consumeWhitespace();
564                 std::unique_ptr&lt;CSSSelectorList&gt; selectorList = std::unique_ptr&lt;CSSSelectorList&gt;(new CSSSelectorList());
565                 *selectorList = consumeComplexSelectorList(block);
566                 if (!selectorList-&gt;first() || !block.atEnd())
567                     return nullptr;
568                 selector-&gt;setSelectorList(WTFMove(selectorList));
569             }
570             selector-&gt;setNth(ab.first, ab.second);
571             return selector;
572         }
573         case CSSSelector::PseudoClassLang: {
574             // FIXME: CSS Selectors Level 4 allows :lang(*-foo)
<span class="line-modified">575             auto argumentList = std::make_unique&lt;Vector&lt;AtomicString&gt;&gt;();</span>
576             if (!consumeLangArgumentList(argumentList, block))
577                 return nullptr;
578             selector-&gt;setLangArgumentList(WTFMove(argumentList));
579             return selector;
580         }
581         case CSSSelector::PseudoClassMatches: {
582             std::unique_ptr&lt;CSSSelectorList&gt; selectorList = std::unique_ptr&lt;CSSSelectorList&gt;(new CSSSelectorList());
583             *selectorList = consumeComplexSelectorList(block);
584             if (!selectorList-&gt;first() || !block.atEnd())
585                 return nullptr;
586             selector-&gt;setSelectorList(WTFMove(selectorList));
587             return selector;
588         }
589         case CSSSelector::PseudoClassAny:
590         case CSSSelector::PseudoClassHost: {
591             std::unique_ptr&lt;CSSSelectorList&gt; selectorList = std::unique_ptr&lt;CSSSelectorList&gt;(new CSSSelectorList());
592             *selectorList = consumeCompoundSelectorList(block);
593             if (!selectorList-&gt;first() || !block.atEnd())
594                 return nullptr;
595             selector-&gt;setSelectorList(WTFMove(selectorList));
596             return selector;
597         }
598 #if ENABLE(CSS_SELECTORS_LEVEL4)
599         case CSSSelector::PseudoClassDir:
600         case CSSSelector::PseudoClassRole: {
601             const CSSParserToken&amp; ident = block.consumeIncludingWhitespace();
602             if (ident.type() != IdentToken || !block.atEnd())
603                 return nullptr;
<span class="line-modified">604             selector-&gt;setArgument(ident.value().toAtomicString());</span>
605             return selector;
606         }
607 #endif
608         default:
609             break;
610         }
611 
612     }
613 
614     if (selector-&gt;match() == CSSSelector::PseudoElement) {
615         switch (selector-&gt;pseudoElementType()) {
616 #if ENABLE(VIDEO_TRACK)
617         case CSSSelector::PseudoElementCue: {
618             DisallowPseudoElementsScope scope(this);
619             std::unique_ptr&lt;CSSSelectorList&gt; selectorList = std::unique_ptr&lt;CSSSelectorList&gt;(new CSSSelectorList());
620             *selectorList = consumeCompoundSelectorList(block);
621             if (!selectorList-&gt;isValid() || !block.atEnd())
622                 return nullptr;
623             selector-&gt;setSelectorList(WTFMove(selectorList));
624             return selector;
</pre>
<hr />
<pre>
763         else
764             return false;
765     }
766 
767     if (sign == NoSign &amp;&amp; range.peek().type() != NumberToken) {
768         result.second = 0;
769         return true;
770     }
771 
772     const CSSParserToken&amp; b = range.consume();
773     if (b.type() != NumberToken || b.numericValueType() != IntegerValueType)
774         return false;
775     if ((b.numericSign() == NoSign) == (sign == NoSign))
776         return false;
777     result.second = b.numericValue();
778     if (sign == MinusSign)
779         result.second = -result.second;
780     return true;
781 }
782 
<span class="line-modified">783 const AtomicString&amp; CSSSelectorParser::defaultNamespace() const</span>
784 {
785     if (!m_styleSheet)
786         return starAtom();
787     return m_styleSheet-&gt;defaultNamespace();
788 }
789 
<span class="line-modified">790 const AtomicString&amp; CSSSelectorParser::determineNamespace(const AtomicString&amp; prefix)</span>
791 {
792     if (prefix.isNull())
793         return defaultNamespace();
794     if (prefix.isEmpty())
795         return emptyAtom(); // No namespace. If an element/attribute has a namespace, we won&#39;t match it.
796     if (prefix == starAtom())
797         return starAtom(); // We&#39;ll match any namespace.
798     if (!m_styleSheet)
799         return nullAtom(); // Cannot resolve prefix to namespace without a stylesheet, syntax error.
800     return m_styleSheet-&gt;namespaceURIFromPrefix(prefix);
801 }
802 
<span class="line-modified">803 void CSSSelectorParser::prependTypeSelectorIfNeeded(const AtomicString&amp; namespacePrefix, const AtomicString&amp; elementName, CSSParserSelector* compoundSelector)</span>
804 {
805     bool isShadowDOM = compoundSelector-&gt;needsImplicitShadowCombinatorForMatching();
806 
807     if (elementName.isNull() &amp;&amp; defaultNamespace() == starAtom() &amp;&amp; !isShadowDOM)
808         return;
809 
<span class="line-modified">810     AtomicString determinedElementName = elementName.isNull() ? starAtom() : elementName;</span>
<span class="line-modified">811     AtomicString namespaceURI = determineNamespace(namespacePrefix);</span>
812     if (namespaceURI.isNull()) {
813         m_failedParsing = true;
814         return;
815     }
<span class="line-modified">816     AtomicString determinedPrefix = namespacePrefix;</span>
817     if (namespaceURI == defaultNamespace())
818         determinedPrefix = nullAtom();
819     QualifiedName tag = QualifiedName(determinedPrefix, determinedElementName, namespaceURI);
820 
821     // *:host never matches, so we can&#39;t discard the *,
822     // otherwise we can&#39;t tell the difference between *:host and just :host.
823     //
824     // Also, selectors where we use a ShadowPseudo combinator between the
825     // element and the pseudo element for matching (custom pseudo elements,
826     // ::cue), we need a universal selector to set the combinator
827     // (relation) on in the cases where there are no simple selectors preceding
828     // the pseudo element.
829     bool explicitForHost = compoundSelector-&gt;isHostPseudoSelector() &amp;&amp; !elementName.isNull();
830     if (tag != anyQName() || explicitForHost || isShadowDOM)
831         compoundSelector-&gt;prependTagSelector(tag, determinedPrefix == nullAtom() &amp;&amp; determinedElementName == starAtom() &amp;&amp; !explicitForHost);
832 }
833 
834 std::unique_ptr&lt;CSSParserSelector&gt; CSSSelectorParser::addSimpleSelectorToCompound(std::unique_ptr&lt;CSSParserSelector&gt; compoundSelector, std::unique_ptr&lt;CSSParserSelector&gt; simpleSelector)
835 {
836     compoundSelector-&gt;appendTagHistory(CSSSelector::Subselector, WTFMove(simpleSelector));
</pre>
</td>
<td>
<hr />
<pre>
 78     Vector&lt;std::unique_ptr&lt;CSSParserSelector&gt;&gt; selectorList;
 79     std::unique_ptr&lt;CSSParserSelector&gt; selector = consumeCompoundSelector(range);
 80     range.consumeWhitespace();
 81     if (!selector)
 82         return CSSSelectorList();
 83     selectorList.append(WTFMove(selector));
 84     while (!range.atEnd() &amp;&amp; range.peek().type() == CommaToken) {
 85         range.consumeIncludingWhitespace();
 86         selector = consumeCompoundSelector(range);
 87         range.consumeWhitespace();
 88         if (!selector)
 89             return CSSSelectorList();
 90         selectorList.append(WTFMove(selector));
 91     }
 92 
 93     if (m_failedParsing)
 94         return { };
 95     return CSSSelectorList { WTFMove(selectorList) };
 96 }
 97 
<span class="line-modified"> 98 static bool consumeLangArgumentList(std::unique_ptr&lt;Vector&lt;AtomString&gt;&gt;&amp; argumentList, CSSParserTokenRange&amp; range)</span>
 99 {
100     const CSSParserToken&amp; ident = range.consumeIncludingWhitespace();
101     if (ident.type() != IdentToken &amp;&amp; ident.type() != StringToken)
102         return false;
103     StringView string = ident.value();
104     if (string.startsWith(&quot;--&quot;))
105         return false;
<span class="line-modified">106     argumentList-&gt;append(string.toAtomString());</span>
107     while (!range.atEnd() &amp;&amp; range.peek().type() == CommaToken) {
108         range.consumeIncludingWhitespace();
109         const CSSParserToken&amp; ident = range.consumeIncludingWhitespace();
110         if (ident.type() != IdentToken &amp;&amp; ident.type() != StringToken)
111             return false;
112         StringView string = ident.value();
113         if (string.startsWith(&quot;--&quot;))
114             return false;
<span class="line-modified">115         argumentList-&gt;append(string.toAtomString());</span>
116     }
117     return range.atEnd();
118 }
119 
120 namespace {
121 
122 enum CompoundSelectorFlags {
123     HasPseudoElementForRightmostCompound = 1 &lt;&lt; 0,
124     HasContentPseudoElement = 1 &lt;&lt; 1
125 };
126 
127 unsigned extractCompoundFlags(const CSSParserSelector&amp; simpleSelector, CSSParserMode parserMode)
128 {
129     if (simpleSelector.match() != CSSSelector::PseudoElement)
130         return 0;
131 
132     // FIXME: https://bugs.webkit.org/show_bug.cgi?id=161747
133     // The UASheetMode check is a work-around to allow this selector in mediaControls(New).css:
134     // input[type=&quot;range&quot; i]::-webkit-media-slider-container &gt; div {
135     if (parserMode == UASheetMode &amp;&amp; simpleSelector.pseudoElementType() == CSSSelector::PseudoElementWebKitCustom)
</pre>
<hr />
<pre>
243     // FIXME-NEWPARSER: This doesn&#39;t exist for us.
244     // if (compoundPseudoElement == CSSSelector::PseudoElementContent)
245     //    return simpleSelector.match() != CSSSelector::PseudoElement;
246     if (simpleSelector.match() != CSSSelector::PseudoClass)
247         return false;
248     CSSSelector::PseudoClassType pseudo = simpleSelector.pseudoClassType();
249     if (pseudo == CSSSelector::PseudoClassNot) {
250         ASSERT(simpleSelector.selectorList());
251         ASSERT(simpleSelector.selectorList()-&gt;first());
252         pseudo = simpleSelector.selectorList()-&gt;first()-&gt;pseudoClassType();
253     }
254     return isPseudoClassValidAfterPseudoElement(pseudo, compoundPseudoElement);
255 }
256 
257 } // namespace
258 
259 std::unique_ptr&lt;CSSParserSelector&gt; CSSSelectorParser::consumeCompoundSelector(CSSParserTokenRange&amp; range)
260 {
261     std::unique_ptr&lt;CSSParserSelector&gt; compoundSelector;
262 
<span class="line-modified">263     AtomString namespacePrefix;</span>
<span class="line-modified">264     AtomString elementName;</span>
265     CSSSelector::PseudoElementType compoundPseudoElement = CSSSelector::PseudoElementUnknown;
266     if (!consumeName(range, elementName, namespacePrefix)) {
267         compoundSelector = consumeSimpleSelector(range);
268         if (!compoundSelector)
269             return nullptr;
270         if (compoundSelector-&gt;match() == CSSSelector::PseudoElement)
271             compoundPseudoElement = compoundSelector-&gt;pseudoElementType();
272     }
273 
274     while (std::unique_ptr&lt;CSSParserSelector&gt; simpleSelector = consumeSimpleSelector(range)) {
275         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=161747
276         // The UASheetMode check is a work-around to allow this selector in mediaControls(New).css:
277         // video::-webkit-media-text-track-region-container.scrolling
278         if (m_context.mode != UASheetMode &amp;&amp; !isSimpleSelectorValidAfterPseudoElement(*simpleSelector.get(), compoundPseudoElement)) {
279             m_failedParsing = true;
280             return nullptr;
281         }
282         if (simpleSelector-&gt;match() == CSSSelector::PseudoElement)
283             compoundPseudoElement = simpleSelector-&gt;pseudoElementType();
284 
285         if (compoundSelector)
286             compoundSelector = addSimpleSelectorToCompound(WTFMove(compoundSelector), WTFMove(simpleSelector));
287         else
288             compoundSelector = WTFMove(simpleSelector);
289     }
290 
291     if (!compoundSelector) {
<span class="line-modified">292         AtomString namespaceURI = determineNamespace(namespacePrefix);</span>
293         if (namespaceURI.isNull()) {
294             m_failedParsing = true;
295             return nullptr;
296         }
297         if (namespaceURI == defaultNamespace())
298             namespacePrefix = nullAtom();
299 
300         CSSParserSelector* rawSelector = new CSSParserSelector(QualifiedName(namespacePrefix, elementName, namespaceURI));
301         std::unique_ptr&lt;CSSParserSelector&gt; selector = std::unique_ptr&lt;CSSParserSelector&gt;(rawSelector);
302         return selector;
303     }
304     prependTypeSelectorIfNeeded(namespacePrefix, elementName, compoundSelector.get());
305     return splitCompoundAtImplicitShadowCrossingCombinator(WTFMove(compoundSelector), m_context);
306 }
307 
308 std::unique_ptr&lt;CSSParserSelector&gt; CSSSelectorParser::consumeSimpleSelector(CSSParserTokenRange&amp; range)
309 {
310     const CSSParserToken&amp; token = range.peek();
311     std::unique_ptr&lt;CSSParserSelector&gt; selector;
312     if (token.type() == HashToken)
313         selector = consumeId(range);
314     else if (token.type() == DelimiterToken &amp;&amp; token.delimiter() == &#39;.&#39;)
315         selector = consumeClass(range);
316     else if (token.type() == LeftBracketToken)
317         selector = consumeAttribute(range);
318     else if (token.type() == ColonToken)
319         selector = consumePseudo(range);
320     else
321         return nullptr;
322     if (!selector)
323         m_failedParsing = true;
324     return selector;
325 }
326 
<span class="line-modified">327 bool CSSSelectorParser::consumeName(CSSParserTokenRange&amp; range, AtomString&amp; name, AtomString&amp; namespacePrefix)</span>
328 {
329     name = nullAtom();
330     namespacePrefix = nullAtom();
331 
332     const CSSParserToken&amp; firstToken = range.peek();
333     if (firstToken.type() == IdentToken) {
<span class="line-modified">334         name = firstToken.value().toAtomString();</span>
335         range.consume();
336     } else if (firstToken.type() == DelimiterToken &amp;&amp; firstToken.delimiter() == &#39;*&#39;) {
337         name = starAtom();
338         range.consume();
339     } else if (firstToken.type() == DelimiterToken &amp;&amp; firstToken.delimiter() == &#39;|&#39;) {
340         // This is an empty namespace, which&#39;ll get assigned this value below
341         name = emptyAtom();
342     } else
343         return false;
344 
345     if (range.peek().type() != DelimiterToken || range.peek().delimiter() != &#39;|&#39;)
346         return true;
347     range.consume();
348 
349     namespacePrefix = name;
350     const CSSParserToken&amp; nameToken = range.consume();
351     if (nameToken.type() == IdentToken) {
<span class="line-modified">352         name = nameToken.value().toAtomString();</span>
353     } else if (nameToken.type() == DelimiterToken &amp;&amp; nameToken.delimiter() == &#39;*&#39;)
354         name = starAtom();
355     else {
356         name = nullAtom();
357         namespacePrefix = nullAtom();
358         return false;
359     }
360 
361     return true;
362 }
363 
364 std::unique_ptr&lt;CSSParserSelector&gt; CSSSelectorParser::consumeId(CSSParserTokenRange&amp; range)
365 {
366     ASSERT(range.peek().type() == HashToken);
367     if (range.peek().getHashTokenType() != HashTokenId)
368         return nullptr;
369     std::unique_ptr&lt;CSSParserSelector&gt; selector = std::unique_ptr&lt;CSSParserSelector&gt;(new CSSParserSelector());
370     selector-&gt;setMatch(CSSSelector::Id);
371 
372     // FIXME-NEWPARSER: Avoid having to do this, but the old parser does and we need
373     // to be compatible for now.
374     CSSParserToken token = range.consume();
<span class="line-modified">375     selector-&gt;setValue(token.value().toAtomString(), m_context.mode == HTMLQuirksMode);</span>
376     return selector;
377 }
378 
379 std::unique_ptr&lt;CSSParserSelector&gt; CSSSelectorParser::consumeClass(CSSParserTokenRange&amp; range)
380 {
381     ASSERT(range.peek().type() == DelimiterToken);
382     ASSERT(range.peek().delimiter() == &#39;.&#39;);
383     range.consume();
384     if (range.peek().type() != IdentToken)
385         return nullptr;
386     std::unique_ptr&lt;CSSParserSelector&gt; selector = std::unique_ptr&lt;CSSParserSelector&gt;(new CSSParserSelector());
387     selector-&gt;setMatch(CSSSelector::Class);
388 
389     // FIXME-NEWPARSER: Avoid having to do this, but the old parser does and we need
390     // to be compatible for now.
391     CSSParserToken token = range.consume();
<span class="line-modified">392     selector-&gt;setValue(token.value().toAtomString(), m_context.mode == HTMLQuirksMode);</span>
393 
394     return selector;
395 }
396 
397 std::unique_ptr&lt;CSSParserSelector&gt; CSSSelectorParser::consumeAttribute(CSSParserTokenRange&amp; range)
398 {
399     ASSERT(range.peek().type() == LeftBracketToken);
400     CSSParserTokenRange block = range.consumeBlock();



401     block.consumeWhitespace();
402 
<span class="line-modified">403     AtomString namespacePrefix;</span>
<span class="line-modified">404     AtomString attributeName;</span>
405     if (!consumeName(block, attributeName, namespacePrefix))
406         return nullptr;
407     block.consumeWhitespace();
408 
<span class="line-modified">409     AtomString namespaceURI = determineNamespace(namespacePrefix);</span>
410     if (namespaceURI.isNull())
411         return nullptr;
412 
413     QualifiedName qualifiedName = namespacePrefix.isNull()
414         ? QualifiedName(nullAtom(), attributeName, nullAtom())
415         : QualifiedName(namespacePrefix, attributeName, namespaceURI);
416 
417     std::unique_ptr&lt;CSSParserSelector&gt; selector = std::unique_ptr&lt;CSSParserSelector&gt;(new CSSParserSelector());
418 
419     if (block.atEnd()) {
420         selector-&gt;setAttribute(qualifiedName, m_context.isHTMLDocument, CSSSelector::CaseSensitive);
421         selector-&gt;setMatch(CSSSelector::Set);
422         return selector;
423     }
424 
425     selector-&gt;setMatch(consumeAttributeMatch(block));
426 
427     const CSSParserToken&amp; attributeValue = block.consumeIncludingWhitespace();
428     if (attributeValue.type() != IdentToken &amp;&amp; attributeValue.type() != StringToken)
429         return nullptr;
<span class="line-modified">430     selector-&gt;setValue(attributeValue.value().toAtomString());</span>
431 
432     selector-&gt;setAttribute(qualifiedName, m_context.isHTMLDocument, consumeAttributeFlags(block));
433 
434     if (!block.atEnd())
435         return nullptr;
436     return selector;
437 }
438 
439 static bool isOnlyPseudoClassFunction(CSSSelector::PseudoClassType pseudoClassType)
440 {
441     switch (pseudoClassType) {
442     case CSSSelector::PseudoClassNot:
443     case CSSSelector::PseudoClassMatches:
444     case CSSSelector::PseudoClassNthChild:
445     case CSSSelector::PseudoClassNthLastChild:
446     case CSSSelector::PseudoClassNthOfType:
447     case CSSSelector::PseudoClassNthLastOfType:
448     case CSSSelector::PseudoClassLang:
449     case CSSSelector::PseudoClassAny:
450 #if ENABLE(CSS_SELECTORS_LEVEL4)
</pre>
<hr />
<pre>
470     return false;
471 }
472 
473 std::unique_ptr&lt;CSSParserSelector&gt; CSSSelectorParser::consumePseudo(CSSParserTokenRange&amp; range)
474 {
475     ASSERT(range.peek().type() == ColonToken);
476     range.consume();
477 
478     int colons = 1;
479     if (range.peek().type() == ColonToken) {
480         range.consume();
481         colons++;
482     }
483 
484     const CSSParserToken&amp; token = range.peek();
485     if (token.type() != IdentToken &amp;&amp; token.type() != FunctionToken)
486         return nullptr;
487 
488     std::unique_ptr&lt;CSSParserSelector&gt; selector;
489 



490     if (colons == 1) {
<span class="line-modified">491         selector = CSSParserSelector::parsePseudoClassSelector(token.value());</span>
492 #if ENABLE(ATTACHMENT_ELEMENT)
493         if (!m_context.attachmentEnabled &amp;&amp; selector &amp;&amp; selector-&gt;match() == CSSSelector::PseudoClass &amp;&amp; selector-&gt;pseudoClassType() == CSSSelector::PseudoClassHasAttachment)
494             return nullptr;
495 #endif
496     } else {
<span class="line-modified">497         selector = CSSParserSelector::parsePseudoElementSelector(token.value());</span>
498 #if ENABLE(VIDEO_TRACK)
499         // Treat the ident version of cue as PseudoElementWebkitCustom.
500         if (token.type() == IdentToken &amp;&amp; selector &amp;&amp; selector-&gt;match() == CSSSelector::PseudoElement &amp;&amp; selector-&gt;pseudoElementType() == CSSSelector::PseudoElementCue)
501             selector-&gt;setPseudoElementType(CSSSelector::PseudoElementWebKitCustom);
502 #endif
503     }
504 
505     if (!selector || (selector-&gt;match() == CSSSelector::PseudoElement &amp;&amp; m_disallowPseudoElements))
506         return nullptr;
507 
508     if (token.type() == IdentToken) {
509         range.consume();
510         if ((selector-&gt;match() == CSSSelector::PseudoElement &amp;&amp; (selector-&gt;pseudoElementType() == CSSSelector::PseudoElementUnknown || isOnlyPseudoElementFunction(selector-&gt;pseudoElementType())))
511             || (selector-&gt;match() == CSSSelector::PseudoClass &amp;&amp; (selector-&gt;pseudoClassType() == CSSSelector::PseudoClassUnknown || isOnlyPseudoClassFunction(selector-&gt;pseudoClassType()))))
512             return nullptr;
513         return selector;
514     }
515 
516     CSSParserTokenRange block = range.consumeBlock();


517     block.consumeWhitespace();
518     if (token.type() != FunctionToken)
519         return nullptr;
520 
521     const auto&amp; argumentStart = block.peek();
522 
523     if (selector-&gt;match() == CSSSelector::PseudoClass) {
524         switch (selector-&gt;pseudoClassType()) {
525         case CSSSelector::PseudoClassNot: {
526             DisallowPseudoElementsScope scope(this);
527             std::unique_ptr&lt;CSSSelectorList&gt; selectorList = std::unique_ptr&lt;CSSSelectorList&gt;(new CSSSelectorList());
528             *selectorList = consumeComplexSelectorList(block);
529             if (!selectorList-&gt;first() || !block.atEnd())
530                 return nullptr;
531             selector-&gt;setSelectorList(WTFMove(selectorList));
532             return selector;
533         }
534         case CSSSelector::PseudoClassNthChild:
535         case CSSSelector::PseudoClassNthLastChild:
536         case CSSSelector::PseudoClassNthOfType:
</pre>
<hr />
<pre>
547                 if (block.peek().type() != IdentToken)
548                     return nullptr;
549                 const CSSParserToken&amp; ident = block.consume();
550                 if (!equalIgnoringASCIICase(ident.value(), &quot;of&quot;))
551                     return nullptr;
552                 if (block.peek().type() != WhitespaceToken)
553                     return nullptr;
554                 DisallowPseudoElementsScope scope(this);
555                 block.consumeWhitespace();
556                 std::unique_ptr&lt;CSSSelectorList&gt; selectorList = std::unique_ptr&lt;CSSSelectorList&gt;(new CSSSelectorList());
557                 *selectorList = consumeComplexSelectorList(block);
558                 if (!selectorList-&gt;first() || !block.atEnd())
559                     return nullptr;
560                 selector-&gt;setSelectorList(WTFMove(selectorList));
561             }
562             selector-&gt;setNth(ab.first, ab.second);
563             return selector;
564         }
565         case CSSSelector::PseudoClassLang: {
566             // FIXME: CSS Selectors Level 4 allows :lang(*-foo)
<span class="line-modified">567             auto argumentList = makeUnique&lt;Vector&lt;AtomString&gt;&gt;();</span>
568             if (!consumeLangArgumentList(argumentList, block))
569                 return nullptr;
570             selector-&gt;setLangArgumentList(WTFMove(argumentList));
571             return selector;
572         }
573         case CSSSelector::PseudoClassMatches: {
574             std::unique_ptr&lt;CSSSelectorList&gt; selectorList = std::unique_ptr&lt;CSSSelectorList&gt;(new CSSSelectorList());
575             *selectorList = consumeComplexSelectorList(block);
576             if (!selectorList-&gt;first() || !block.atEnd())
577                 return nullptr;
578             selector-&gt;setSelectorList(WTFMove(selectorList));
579             return selector;
580         }
581         case CSSSelector::PseudoClassAny:
582         case CSSSelector::PseudoClassHost: {
583             std::unique_ptr&lt;CSSSelectorList&gt; selectorList = std::unique_ptr&lt;CSSSelectorList&gt;(new CSSSelectorList());
584             *selectorList = consumeCompoundSelectorList(block);
585             if (!selectorList-&gt;first() || !block.atEnd())
586                 return nullptr;
587             selector-&gt;setSelectorList(WTFMove(selectorList));
588             return selector;
589         }
590 #if ENABLE(CSS_SELECTORS_LEVEL4)
591         case CSSSelector::PseudoClassDir:
592         case CSSSelector::PseudoClassRole: {
593             const CSSParserToken&amp; ident = block.consumeIncludingWhitespace();
594             if (ident.type() != IdentToken || !block.atEnd())
595                 return nullptr;
<span class="line-modified">596             selector-&gt;setArgument(ident.value().toAtomString());</span>
597             return selector;
598         }
599 #endif
600         default:
601             break;
602         }
603 
604     }
605 
606     if (selector-&gt;match() == CSSSelector::PseudoElement) {
607         switch (selector-&gt;pseudoElementType()) {
608 #if ENABLE(VIDEO_TRACK)
609         case CSSSelector::PseudoElementCue: {
610             DisallowPseudoElementsScope scope(this);
611             std::unique_ptr&lt;CSSSelectorList&gt; selectorList = std::unique_ptr&lt;CSSSelectorList&gt;(new CSSSelectorList());
612             *selectorList = consumeCompoundSelectorList(block);
613             if (!selectorList-&gt;isValid() || !block.atEnd())
614                 return nullptr;
615             selector-&gt;setSelectorList(WTFMove(selectorList));
616             return selector;
</pre>
<hr />
<pre>
755         else
756             return false;
757     }
758 
759     if (sign == NoSign &amp;&amp; range.peek().type() != NumberToken) {
760         result.second = 0;
761         return true;
762     }
763 
764     const CSSParserToken&amp; b = range.consume();
765     if (b.type() != NumberToken || b.numericValueType() != IntegerValueType)
766         return false;
767     if ((b.numericSign() == NoSign) == (sign == NoSign))
768         return false;
769     result.second = b.numericValue();
770     if (sign == MinusSign)
771         result.second = -result.second;
772     return true;
773 }
774 
<span class="line-modified">775 const AtomString&amp; CSSSelectorParser::defaultNamespace() const</span>
776 {
777     if (!m_styleSheet)
778         return starAtom();
779     return m_styleSheet-&gt;defaultNamespace();
780 }
781 
<span class="line-modified">782 const AtomString&amp; CSSSelectorParser::determineNamespace(const AtomString&amp; prefix)</span>
783 {
784     if (prefix.isNull())
785         return defaultNamespace();
786     if (prefix.isEmpty())
787         return emptyAtom(); // No namespace. If an element/attribute has a namespace, we won&#39;t match it.
788     if (prefix == starAtom())
789         return starAtom(); // We&#39;ll match any namespace.
790     if (!m_styleSheet)
791         return nullAtom(); // Cannot resolve prefix to namespace without a stylesheet, syntax error.
792     return m_styleSheet-&gt;namespaceURIFromPrefix(prefix);
793 }
794 
<span class="line-modified">795 void CSSSelectorParser::prependTypeSelectorIfNeeded(const AtomString&amp; namespacePrefix, const AtomString&amp; elementName, CSSParserSelector* compoundSelector)</span>
796 {
797     bool isShadowDOM = compoundSelector-&gt;needsImplicitShadowCombinatorForMatching();
798 
799     if (elementName.isNull() &amp;&amp; defaultNamespace() == starAtom() &amp;&amp; !isShadowDOM)
800         return;
801 
<span class="line-modified">802     AtomString determinedElementName = elementName.isNull() ? starAtom() : elementName;</span>
<span class="line-modified">803     AtomString namespaceURI = determineNamespace(namespacePrefix);</span>
804     if (namespaceURI.isNull()) {
805         m_failedParsing = true;
806         return;
807     }
<span class="line-modified">808     AtomString determinedPrefix = namespacePrefix;</span>
809     if (namespaceURI == defaultNamespace())
810         determinedPrefix = nullAtom();
811     QualifiedName tag = QualifiedName(determinedPrefix, determinedElementName, namespaceURI);
812 
813     // *:host never matches, so we can&#39;t discard the *,
814     // otherwise we can&#39;t tell the difference between *:host and just :host.
815     //
816     // Also, selectors where we use a ShadowPseudo combinator between the
817     // element and the pseudo element for matching (custom pseudo elements,
818     // ::cue), we need a universal selector to set the combinator
819     // (relation) on in the cases where there are no simple selectors preceding
820     // the pseudo element.
821     bool explicitForHost = compoundSelector-&gt;isHostPseudoSelector() &amp;&amp; !elementName.isNull();
822     if (tag != anyQName() || explicitForHost || isShadowDOM)
823         compoundSelector-&gt;prependTagSelector(tag, determinedPrefix == nullAtom() &amp;&amp; determinedElementName == starAtom() &amp;&amp; !explicitForHost);
824 }
825 
826 std::unique_ptr&lt;CSSParserSelector&gt; CSSSelectorParser::addSimpleSelectorToCompound(std::unique_ptr&lt;CSSParserSelector&gt; compoundSelector, std::unique_ptr&lt;CSSParserSelector&gt; simpleSelector)
827 {
828     compoundSelector-&gt;appendTagHistory(CSSSelector::Subselector, WTFMove(simpleSelector));
</pre>
</td>
</tr>
</table>
<center><a href="CSSPropertyParserHelpers.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="CSSSelectorParser.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>