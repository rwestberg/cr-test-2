<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/dom/Node.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
   3  *           (C) 1999 Antti Koivisto (koivisto@kde.org)
   4  *           (C) 2001 Dirk Mueller (mueller@kde.org)
   5  * Copyright (C) 2004-2017 Apple Inc. All rights reserved.
   6  * Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies)
   7  * Copyright (C) 2009 Torch Mobile Inc. All rights reserved. (http://www.torchmobile.com/)
   8  *
   9  * This library is free software; you can redistribute it and/or
  10  * modify it under the terms of the GNU Library General Public
  11  * License as published by the Free Software Foundation; either
  12  * version 2 of the License, or (at your option) any later version.
  13  *
  14  * This library is distributed in the hope that it will be useful,
  15  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  16  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  17  * Library General Public License for more details.
  18  *
  19  * You should have received a copy of the GNU Library General Public License
  20  * along with this library; see the file COPYING.LIB.  If not, write to
  21  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  22  * Boston, MA 02110-1301, USA.
  23  */
  24 
  25 #include &quot;config.h&quot;
  26 #include &quot;Node.h&quot;
  27 
  28 #include &quot;AXObjectCache.h&quot;
  29 #include &quot;Attr.h&quot;
  30 #include &quot;BeforeLoadEvent.h&quot;
  31 #include &quot;ChildListMutationScope.h&quot;
  32 #include &quot;CommonVM.h&quot;
  33 #include &quot;ComposedTreeAncestorIterator.h&quot;
  34 #include &quot;ContainerNodeAlgorithms.h&quot;
<a name="1" id="anc1"></a>


  35 #include &quot;ContextMenuController.h&quot;
  36 #include &quot;DOMWindow.h&quot;
  37 #include &quot;DataTransfer.h&quot;
  38 #include &quot;DocumentType.h&quot;
  39 #include &quot;ElementIterator.h&quot;
  40 #include &quot;ElementRareData.h&quot;
  41 #include &quot;ElementTraversal.h&quot;
  42 #include &quot;EventDispatcher.h&quot;
  43 #include &quot;EventHandler.h&quot;
  44 #include &quot;FrameView.h&quot;
<a name="2" id="anc2"></a>
  45 #include &quot;HTMLBodyElement.h&quot;
  46 #include &quot;HTMLCollection.h&quot;
  47 #include &quot;HTMLElement.h&quot;
  48 #include &quot;HTMLImageElement.h&quot;
  49 #include &quot;HTMLSlotElement.h&quot;
  50 #include &quot;HTMLStyleElement.h&quot;
  51 #include &quot;InputEvent.h&quot;
  52 #include &quot;InspectorController.h&quot;
  53 #include &quot;KeyboardEvent.h&quot;
  54 #include &quot;Logging.h&quot;
  55 #include &quot;MutationEvent.h&quot;
  56 #include &quot;NodeRenderStyle.h&quot;
  57 #include &quot;ProcessingInstruction.h&quot;
  58 #include &quot;ProgressEvent.h&quot;
  59 #include &quot;Range.h&quot;
  60 #include &quot;RenderBlock.h&quot;
  61 #include &quot;RenderBox.h&quot;
  62 #include &quot;RenderTextControl.h&quot;
  63 #include &quot;RenderView.h&quot;
<a name="3" id="anc3"></a>
  64 #include &quot;ScopedEventQueue.h&quot;
  65 #include &quot;ScriptDisallowedScope.h&quot;
  66 #include &quot;StorageEvent.h&quot;
  67 #include &quot;StyleResolver.h&quot;
  68 #include &quot;StyleSheetContents.h&quot;
  69 #include &quot;TemplateContentDocumentFragment.h&quot;
  70 #include &quot;TextEvent.h&quot;
  71 #include &quot;TouchEvent.h&quot;
  72 #include &quot;WheelEvent.h&quot;
  73 #include &quot;XMLNSNames.h&quot;
  74 #include &quot;XMLNames.h&quot;
  75 #include &lt;wtf/IsoMallocInlines.h&gt;
  76 #include &lt;wtf/RefCountedLeakCounter.h&gt;
  77 #include &lt;wtf/SHA1.h&gt;
  78 #include &lt;wtf/Variant.h&gt;
  79 #include &lt;wtf/text/CString.h&gt;
  80 #include &lt;wtf/text/StringBuilder.h&gt;
  81 
  82 namespace WebCore {
  83 
  84 WTF_MAKE_ISO_ALLOCATED_IMPL(Node);
  85 
  86 using namespace HTMLNames;
  87 
  88 #if DUMP_NODE_STATISTICS
  89 static HashSet&lt;Node*&gt;&amp; liveNodeSet()
  90 {
  91     static NeverDestroyed&lt;HashSet&lt;Node*&gt;&gt; liveNodes;
  92     return liveNodes;
  93 }
  94 
  95 static const char* stringForRareDataUseType(NodeRareData::UseType useType)
  96 {
  97     switch (useType) {
  98     case NodeRareData::UseType::ConnectedFrameCount:
  99         return &quot;ConnectedFrameCount&quot;;
 100     case NodeRareData::UseType::NodeList:
 101         return &quot;NodeList&quot;;
 102     case NodeRareData::UseType::MutationObserver:
 103         return &quot;MutationObserver&quot;;
 104     case NodeRareData::UseType::TabIndex:
 105         return &quot;TabIndex&quot;;
<a name="4" id="anc4"></a><span class="line-removed"> 106     case NodeRareData::UseType::StyleFlags:</span>
<span class="line-removed"> 107         return &quot;StyleFlags&quot;;</span>
 108     case NodeRareData::UseType::MinimumSize:
 109         return &quot;MinimumSize&quot;;
 110     case NodeRareData::UseType::ScrollingPosition:
 111         return &quot;ScrollingPosition&quot;;
 112     case NodeRareData::UseType::ComputedStyle:
 113         return &quot;ComputedStyle&quot;;
 114     case NodeRareData::UseType::Dataset:
 115         return &quot;Dataset&quot;;
 116     case NodeRareData::UseType::ClassList:
 117         return &quot;ClassList&quot;;
 118     case NodeRareData::UseType::ShadowRoot:
 119         return &quot;ShadowRoot&quot;;
 120     case NodeRareData::UseType::CustomElementQueue:
 121         return &quot;CustomElementQueue&quot;;
 122     case NodeRareData::UseType::AttributeMap:
 123         return &quot;AttributeMap&quot;;
 124     case NodeRareData::UseType::InteractionObserver:
 125         return &quot;InteractionObserver&quot;;
 126     case NodeRareData::UseType::PseudoElements:
 127         return &quot;PseudoElements&quot;;
 128     }
 129     return nullptr;
 130 }
 131 
 132 #endif
 133 
 134 void Node::dumpStatistics()
 135 {
 136 #if DUMP_NODE_STATISTICS
 137     size_t nodesWithRareData = 0;
 138 
 139     size_t elementNodes = 0;
 140     size_t attrNodes = 0;
 141     size_t textNodes = 0;
 142     size_t cdataNodes = 0;
 143     size_t commentNodes = 0;
 144     size_t piNodes = 0;
 145     size_t documentNodes = 0;
 146     size_t docTypeNodes = 0;
 147     size_t fragmentNodes = 0;
 148     size_t shadowRootNodes = 0;
 149 
 150     HashMap&lt;String, size_t&gt; perTagCount;
 151 
 152     size_t attributes = 0;
 153     size_t attributesWithAttr = 0;
 154     size_t elementsWithAttributeStorage = 0;
 155     size_t elementsWithRareData = 0;
 156     size_t elementsWithNamedNodeMap = 0;
 157 
 158     HashMap&lt;uint16_t, size_t&gt; rareDataSingleUseTypeCounts;
 159     size_t mixedRareDataUseCount = 0;
 160 
 161     for (auto* node : liveNodeSet()) {
 162         if (node-&gt;hasRareData()) {
 163             ++nodesWithRareData;
 164             if (is&lt;Element&gt;(*node)) {
 165                 ++elementsWithRareData;
 166                 if (downcast&lt;Element&gt;(*node).hasNamedNodeMap())
 167                     ++elementsWithNamedNodeMap;
 168             }
 169             auto* rareData = node-&gt;rareData();
 170             auto useTypes = is&lt;Element&gt;(node) ? static_cast&lt;ElementRareData*&gt;(rareData)-&gt;useTypes() : rareData-&gt;useTypes();
 171             unsigned useTypeCount = 0;
 172             for (auto type : useTypes) {
 173                 UNUSED_PARAM(type);
 174                 useTypeCount++;
 175             }
 176             if (useTypeCount == 1) {
 177                 auto result = rareDataSingleUseTypeCounts.add(static_cast&lt;uint16_t&gt;(*useTypes.begin()), 0);
 178                 result.iterator-&gt;value++;
 179             } else
 180                 mixedRareDataUseCount++;
 181         }
 182 
 183         switch (node-&gt;nodeType()) {
 184             case ELEMENT_NODE: {
 185                 ++elementNodes;
 186 
 187                 // Tag stats
 188                 Element&amp; element = downcast&lt;Element&gt;(*node);
 189                 HashMap&lt;String, size_t&gt;::AddResult result = perTagCount.add(element.tagName(), 1);
 190                 if (!result.isNewEntry)
 191                     result.iterator-&gt;value++;
 192 
 193                 if (const ElementData* elementData = element.elementData()) {
 194                     unsigned length = elementData-&gt;length();
 195                     attributes += length;
 196                     ++elementsWithAttributeStorage;
 197                     for (unsigned i = 0; i &lt; length; ++i) {
 198                         const Attribute&amp; attr = elementData-&gt;attributeAt(i);
 199                         if (element.attrIfExists(attr.name()))
 200                             ++attributesWithAttr;
 201                     }
 202                 }
 203                 break;
 204             }
 205             case ATTRIBUTE_NODE: {
 206                 ++attrNodes;
 207                 break;
 208             }
 209             case TEXT_NODE: {
 210                 ++textNodes;
 211                 break;
 212             }
 213             case CDATA_SECTION_NODE: {
 214                 ++cdataNodes;
 215                 break;
 216             }
 217             case PROCESSING_INSTRUCTION_NODE: {
 218                 ++piNodes;
 219                 break;
 220             }
 221             case COMMENT_NODE: {
 222                 ++commentNodes;
 223                 break;
 224             }
 225             case DOCUMENT_NODE: {
 226                 ++documentNodes;
 227                 break;
 228             }
 229             case DOCUMENT_TYPE_NODE: {
 230                 ++docTypeNodes;
 231                 break;
 232             }
 233             case DOCUMENT_FRAGMENT_NODE: {
 234                 if (node-&gt;isShadowRoot())
 235                     ++shadowRootNodes;
 236                 else
 237                     ++fragmentNodes;
 238                 break;
 239             }
 240         }
 241     }
 242 
 243     printf(&quot;Number of Nodes: %d\n\n&quot;, liveNodeSet().size());
 244     printf(&quot;Number of Nodes with RareData: %zu\n&quot;, nodesWithRareData);
 245     printf(&quot;  Mixed use: %zu\n&quot;, mixedRareDataUseCount);
 246     for (auto it : rareDataSingleUseTypeCounts)
 247         printf(&quot;  %s: %zu\n&quot;, stringForRareDataUseType(static_cast&lt;NodeRareData::UseType&gt;(it.key)), it.value);
 248     printf(&quot;\n&quot;);
 249 
 250 
 251     printf(&quot;NodeType distribution:\n&quot;);
 252     printf(&quot;  Number of Element nodes: %zu\n&quot;, elementNodes);
 253     printf(&quot;  Number of Attribute nodes: %zu\n&quot;, attrNodes);
 254     printf(&quot;  Number of Text nodes: %zu\n&quot;, textNodes);
 255     printf(&quot;  Number of CDATASection nodes: %zu\n&quot;, cdataNodes);
 256     printf(&quot;  Number of Comment nodes: %zu\n&quot;, commentNodes);
 257     printf(&quot;  Number of ProcessingInstruction nodes: %zu\n&quot;, piNodes);
 258     printf(&quot;  Number of Document nodes: %zu\n&quot;, documentNodes);
 259     printf(&quot;  Number of DocumentType nodes: %zu\n&quot;, docTypeNodes);
 260     printf(&quot;  Number of DocumentFragment nodes: %zu\n&quot;, fragmentNodes);
 261     printf(&quot;  Number of ShadowRoot nodes: %zu\n&quot;, shadowRootNodes);
 262 
 263     printf(&quot;Element tag name distibution:\n&quot;);
 264     for (auto&amp; stringSizePair : perTagCount)
 265         printf(&quot;  Number of &lt;%s&gt; tags: %zu\n&quot;, stringSizePair.key.utf8().data(), stringSizePair.value);
 266 
 267     printf(&quot;Attributes:\n&quot;);
 268     printf(&quot;  Number of Attributes (non-Node and Node): %zu [%zu]\n&quot;, attributes, sizeof(Attribute));
 269     printf(&quot;  Number of Attributes with an Attr: %zu\n&quot;, attributesWithAttr);
 270     printf(&quot;  Number of Elements with attribute storage: %zu [%zu]\n&quot;, elementsWithAttributeStorage, sizeof(ElementData));
 271     printf(&quot;  Number of Elements with RareData: %zu\n&quot;, elementsWithRareData);
 272     printf(&quot;  Number of Elements with NamedNodeMap: %zu [%zu]\n&quot;, elementsWithNamedNodeMap, sizeof(NamedNodeMap));
 273 #endif
 274 }
 275 
 276 DEFINE_DEBUG_ONLY_GLOBAL(WTF::RefCountedLeakCounter, nodeCounter, (&quot;WebCoreNode&quot;));
 277 
 278 #ifndef NDEBUG
 279 static bool shouldIgnoreLeaks = false;
 280 
 281 static HashSet&lt;Node*&gt;&amp; ignoreSet()
 282 {
 283     static NeverDestroyed&lt;HashSet&lt;Node*&gt;&gt; ignore;
 284 
 285     return ignore;
 286 }
 287 
 288 #endif
 289 
 290 void Node::startIgnoringLeaks()
 291 {
 292 #ifndef NDEBUG
 293     shouldIgnoreLeaks = true;
 294 #endif
 295 }
 296 
 297 void Node::stopIgnoringLeaks()
 298 {
 299 #ifndef NDEBUG
 300     shouldIgnoreLeaks = false;
 301 #endif
 302 }
 303 
 304 void Node::trackForDebugging()
 305 {
 306 #ifndef NDEBUG
 307     if (shouldIgnoreLeaks)
 308         ignoreSet().add(this);
 309     else
 310         nodeCounter.increment();
 311 #endif
 312 
 313 #if DUMP_NODE_STATISTICS
 314     liveNodeSet().add(this);
 315 #endif
 316 }
 317 
 318 Node::Node(Document&amp; document, ConstructionType type)
<a name="5" id="anc5"></a><span class="line-modified"> 319     : m_refCount(1)</span>
<span class="line-removed"> 320     , m_nodeFlags(type)</span>
 321     , m_treeScope(&amp;document)
 322 {
 323     ASSERT(isMainThread());
 324 
 325     document.incrementReferencingNodeCount();
 326 
 327 #if !defined(NDEBUG) || (defined(DUMP_NODE_STATISTICS) &amp;&amp; DUMP_NODE_STATISTICS)
 328     trackForDebugging();
 329 #endif
 330 }
 331 
 332 Node::~Node()
 333 {
 334     ASSERT(isMainThread());
<a name="6" id="anc6"></a><span class="line-modified"> 335     // We set m_refCount to 1 before calling delete to avoid double destruction through use of Ref&lt;T&gt;/RefPtr&lt;T&gt;.</span>
<span class="line-removed"> 336     // This is a security mitigation in case of programmer errorm (caught by a debug assertion).</span>
<span class="line-removed"> 337     ASSERT(m_refCount == 1);</span>
 338     ASSERT(m_deletionHasBegun);
 339     ASSERT(!m_adoptionIsRequired);
 340 
 341 #ifndef NDEBUG
 342     if (!ignoreSet().remove(this))
 343         nodeCounter.decrement();
 344 #endif
 345 
 346 #if DUMP_NODE_STATISTICS
 347     liveNodeSet().remove(this);
 348 #endif
 349 
 350     RELEASE_ASSERT(!renderer());
 351     ASSERT(!parentNode());
 352     ASSERT(!m_previous);
 353     ASSERT(!m_next);
 354 
 355     if (hasRareData())
 356         clearRareData();
 357 
 358     if (!isContainerNode())
 359         willBeDeletedFrom(document());
 360 
 361     if (hasEventTargetData())
 362         clearEventTargetData();
 363 
 364     document().decrementReferencingNodeCount();
 365 
 366 #if ENABLE(TOUCH_EVENTS) &amp;&amp; PLATFORM(IOS_FAMILY) &amp;&amp; (!ASSERT_DISABLED || ENABLE(SECURITY_ASSERTIONS))
 367     for (auto* document : Document::allDocuments()) {
 368         ASSERT_WITH_SECURITY_IMPLICATION(!document-&gt;touchEventListenersContain(*this));
 369         ASSERT_WITH_SECURITY_IMPLICATION(!document-&gt;touchEventHandlersContain(*this));
 370         ASSERT_WITH_SECURITY_IMPLICATION(!document-&gt;touchEventTargetsContain(*this));
 371     }
 372 #endif
 373 }
 374 
 375 void Node::willBeDeletedFrom(Document&amp; document)
 376 {
 377     if (hasEventTargetData()) {
 378         document.didRemoveWheelEventHandler(*this, EventHandlerRemoval::All);
 379 #if ENABLE(TOUCH_EVENTS)
 380 #if PLATFORM(IOS_FAMILY)
 381         document.removeTouchEventListener(*this, EventHandlerRemoval::All);
 382 #endif
 383         document.didRemoveTouchEventHandler(*this, EventHandlerRemoval::All);
 384 #endif
 385     }
 386 
 387 #if ENABLE(TOUCH_EVENTS) &amp;&amp; PLATFORM(IOS_FAMILY)
 388     document.removeTouchEventHandler(*this, EventHandlerRemoval::All);
 389 #endif
 390 
 391     if (auto* cache = document.existingAXObjectCache())
 392         cache-&gt;remove(*this);
 393 }
 394 
 395 void Node::materializeRareData()
 396 {
<a name="7" id="anc7"></a><span class="line-removed"> 397     NodeRareData* data;</span>
 398     if (is&lt;Element&gt;(*this))
<a name="8" id="anc8"></a><span class="line-modified"> 399         data = std::make_unique&lt;ElementRareData&gt;(downcast&lt;RenderElement&gt;(m_data.m_renderer)).release();</span>
 400     else
<a name="9" id="anc9"></a><span class="line-modified"> 401         data = std::make_unique&lt;NodeRareData&gt;(m_data.m_renderer).release();</span>
<span class="line-modified"> 402     ASSERT(data);</span>
 403 
<a name="10" id="anc10"></a><span class="line-modified"> 404     m_data.m_rareData = data;</span>
<span class="line-modified"> 405     setFlag(HasRareDataFlag);</span>




 406 }
 407 
 408 void Node::clearRareData()
 409 {
 410     ASSERT(hasRareData());
 411     ASSERT(!transientMutationObserverRegistry() || transientMutationObserverRegistry()-&gt;isEmpty());
 412 
<a name="11" id="anc11"></a><span class="line-modified"> 413     RenderObject* renderer = m_data.m_rareData-&gt;renderer();</span>
<span class="line-removed"> 414     if (isElementNode())</span>
<span class="line-removed"> 415         delete static_cast&lt;ElementRareData*&gt;(m_data.m_rareData);</span>
<span class="line-removed"> 416     else</span>
<span class="line-removed"> 417         delete static_cast&lt;NodeRareData*&gt;(m_data.m_rareData);</span>
<span class="line-removed"> 418     m_data.m_renderer = renderer;</span>
<span class="line-removed"> 419     clearFlag(HasRareDataFlag);</span>
 420 }
 421 
 422 bool Node::isNode() const
 423 {
 424     return true;
 425 }
 426 
 427 String Node::nodeValue() const
 428 {
 429     return String();
 430 }
 431 
 432 ExceptionOr&lt;void&gt; Node::setNodeValue(const String&amp;)
 433 {
 434     // By default, setting nodeValue has no effect.
 435     return { };
 436 }
 437 
 438 RefPtr&lt;NodeList&gt; Node::childNodes()
 439 {
 440     if (is&lt;ContainerNode&gt;(*this))
 441         return ensureRareData().ensureNodeLists().ensureChildNodeList(downcast&lt;ContainerNode&gt;(*this));
 442     return ensureRareData().ensureNodeLists().ensureEmptyChildNodeList(*this);
 443 }
 444 
 445 Node *Node::lastDescendant() const
 446 {
 447     Node *n = const_cast&lt;Node *&gt;(this);
 448     while (n &amp;&amp; n-&gt;lastChild())
 449         n = n-&gt;lastChild();
 450     return n;
 451 }
 452 
 453 Node* Node::firstDescendant() const
 454 {
 455     Node *n = const_cast&lt;Node *&gt;(this);
 456     while (n &amp;&amp; n-&gt;firstChild())
 457         n = n-&gt;firstChild();
 458     return n;
 459 }
 460 
 461 Element* Node::previousElementSibling() const
 462 {
 463     return ElementTraversal::previousSibling(*this);
 464 }
 465 
 466 Element* Node::nextElementSibling() const
 467 {
 468     return ElementTraversal::nextSibling(*this);
 469 }
 470 
 471 ExceptionOr&lt;void&gt; Node::insertBefore(Node&amp; newChild, Node* refChild)
 472 {
 473     if (!is&lt;ContainerNode&gt;(*this))
 474         return Exception { HierarchyRequestError };
 475     return downcast&lt;ContainerNode&gt;(*this).insertBefore(newChild, refChild);
 476 }
 477 
 478 ExceptionOr&lt;void&gt; Node::replaceChild(Node&amp; newChild, Node&amp; oldChild)
 479 {
 480     if (!is&lt;ContainerNode&gt;(*this))
 481         return Exception { HierarchyRequestError };
 482     return downcast&lt;ContainerNode&gt;(*this).replaceChild(newChild, oldChild);
 483 }
 484 
 485 ExceptionOr&lt;void&gt; Node::removeChild(Node&amp; oldChild)
 486 {
 487     if (!is&lt;ContainerNode&gt;(*this))
 488         return Exception { NotFoundError };
 489     return downcast&lt;ContainerNode&gt;(*this).removeChild(oldChild);
 490 }
 491 
 492 ExceptionOr&lt;void&gt; Node::appendChild(Node&amp; newChild)
 493 {
 494     if (!is&lt;ContainerNode&gt;(*this))
 495         return Exception { HierarchyRequestError };
 496     return downcast&lt;ContainerNode&gt;(*this).appendChild(newChild);
 497 }
 498 
 499 static HashSet&lt;RefPtr&lt;Node&gt;&gt; nodeSetPreTransformedFromNodeOrStringVector(const Vector&lt;NodeOrString&gt;&amp; vector)
 500 {
 501     HashSet&lt;RefPtr&lt;Node&gt;&gt; nodeSet;
 502     for (const auto&amp; variant : vector) {
 503         WTF::switchOn(variant,
 504             [&amp;] (const RefPtr&lt;Node&gt;&amp; node) { nodeSet.add(const_cast&lt;Node*&gt;(node.get())); },
 505             [] (const String&amp;) { }
 506         );
 507     }
 508     return nodeSet;
 509 }
 510 
 511 static RefPtr&lt;Node&gt; firstPrecedingSiblingNotInNodeSet(Node&amp; context, const HashSet&lt;RefPtr&lt;Node&gt;&gt;&amp; nodeSet)
 512 {
 513     for (auto* sibling = context.previousSibling(); sibling; sibling = sibling-&gt;previousSibling()) {
 514         if (!nodeSet.contains(sibling))
 515             return sibling;
 516     }
 517     return nullptr;
 518 }
 519 
 520 static RefPtr&lt;Node&gt; firstFollowingSiblingNotInNodeSet(Node&amp; context, const HashSet&lt;RefPtr&lt;Node&gt;&gt;&amp; nodeSet)
 521 {
 522     for (auto* sibling = context.nextSibling(); sibling; sibling = sibling-&gt;nextSibling()) {
 523         if (!nodeSet.contains(sibling))
 524             return sibling;
 525     }
 526     return nullptr;
 527 }
 528 
 529 ExceptionOr&lt;RefPtr&lt;Node&gt;&gt; Node::convertNodesOrStringsIntoNode(Vector&lt;NodeOrString&gt;&amp;&amp; nodeOrStringVector)
 530 {
 531     if (nodeOrStringVector.isEmpty())
 532         return nullptr;
 533 
 534     Vector&lt;Ref&lt;Node&gt;&gt; nodes;
 535     nodes.reserveInitialCapacity(nodeOrStringVector.size());
 536     for (auto&amp; variant : nodeOrStringVector) {
 537         WTF::switchOn(variant,
 538             [&amp;](RefPtr&lt;Node&gt;&amp; node) { nodes.uncheckedAppend(*node.get()); },
 539             [&amp;](String&amp; string) { nodes.uncheckedAppend(Text::create(document(), string)); }
 540         );
 541     }
 542 
 543     if (nodes.size() == 1)
 544         return RefPtr&lt;Node&gt; { WTFMove(nodes.first()) };
 545 
 546     auto nodeToReturn = DocumentFragment::create(document());
 547     for (auto&amp; node : nodes) {
 548         auto appendResult = nodeToReturn-&gt;appendChild(node);
 549         if (appendResult.hasException())
 550             return appendResult.releaseException();
 551     }
 552     return RefPtr&lt;Node&gt; { WTFMove(nodeToReturn) };
 553 }
 554 
 555 ExceptionOr&lt;void&gt; Node::before(Vector&lt;NodeOrString&gt;&amp;&amp; nodeOrStringVector)
 556 {
 557     RefPtr&lt;ContainerNode&gt; parent = parentNode();
 558     if (!parent)
 559         return { };
 560 
 561     auto nodeSet = nodeSetPreTransformedFromNodeOrStringVector(nodeOrStringVector);
 562     auto viablePreviousSibling = firstPrecedingSiblingNotInNodeSet(*this, nodeSet);
 563 
 564     auto result = convertNodesOrStringsIntoNode(WTFMove(nodeOrStringVector));
 565     if (result.hasException())
 566         return result.releaseException();
 567     auto node = result.releaseReturnValue();
 568     if (!node)
 569         return { };
 570 
 571     if (viablePreviousSibling)
 572         viablePreviousSibling = viablePreviousSibling-&gt;nextSibling();
 573     else
 574         viablePreviousSibling = parent-&gt;firstChild();
 575 
 576     return parent-&gt;insertBefore(*node, viablePreviousSibling.get());
 577 }
 578 
 579 ExceptionOr&lt;void&gt; Node::after(Vector&lt;NodeOrString&gt;&amp;&amp; nodeOrStringVector)
 580 {
 581     RefPtr&lt;ContainerNode&gt; parent = parentNode();
 582     if (!parent)
 583         return { };
 584 
 585     auto nodeSet = nodeSetPreTransformedFromNodeOrStringVector(nodeOrStringVector);
 586     auto viableNextSibling = firstFollowingSiblingNotInNodeSet(*this, nodeSet);
 587 
 588     auto result = convertNodesOrStringsIntoNode(WTFMove(nodeOrStringVector));
 589     if (result.hasException())
 590         return result.releaseException();
 591     auto node = result.releaseReturnValue();
 592     if (!node)
 593         return { };
 594 
 595     return parent-&gt;insertBefore(*node, viableNextSibling.get());
 596 }
 597 
 598 ExceptionOr&lt;void&gt; Node::replaceWith(Vector&lt;NodeOrString&gt;&amp;&amp; nodeOrStringVector)
 599 {
 600     RefPtr&lt;ContainerNode&gt; parent = parentNode();
 601     if (!parent)
 602         return { };
 603 
 604     auto nodeSet = nodeSetPreTransformedFromNodeOrStringVector(nodeOrStringVector);
 605     auto viableNextSibling = firstFollowingSiblingNotInNodeSet(*this, nodeSet);
 606 
 607     auto result = convertNodesOrStringsIntoNode(WTFMove(nodeOrStringVector));
 608     if (result.hasException())
 609         return result.releaseException();
 610 
 611     if (parentNode() == parent) {
 612         if (auto node = result.releaseReturnValue())
 613             return parent-&gt;replaceChild(*node, *this);
 614         return parent-&gt;removeChild(*this);
 615     }
 616 
 617     if (auto node = result.releaseReturnValue())
 618         return parent-&gt;insertBefore(*node, viableNextSibling.get());
 619     return { };
 620 }
 621 
 622 ExceptionOr&lt;void&gt; Node::remove()
 623 {
 624     auto* parent = parentNode();
 625     if (!parent)
 626         return { };
 627     return parent-&gt;removeChild(*this);
 628 }
 629 
 630 void Node::normalize()
 631 {
 632     // Go through the subtree beneath us, normalizing all nodes. This means that
 633     // any two adjacent text nodes are merged and any empty text nodes are removed.
 634 
 635     RefPtr&lt;Node&gt; node = this;
 636     while (Node* firstChild = node-&gt;firstChild())
 637         node = firstChild;
 638     while (node) {
 639         NodeType type = node-&gt;nodeType();
 640         if (type == ELEMENT_NODE)
 641             downcast&lt;Element&gt;(*node).normalizeAttributes();
 642 
 643         if (node == this)
 644             break;
 645 
 646         if (type != TEXT_NODE) {
 647             node = NodeTraversal::nextPostOrder(*node);
 648             continue;
 649         }
 650 
 651         RefPtr&lt;Text&gt; text = downcast&lt;Text&gt;(node.get());
 652 
 653         // Remove empty text nodes.
 654         if (!text-&gt;length()) {
 655             // Care must be taken to get the next node before removing the current node.
 656             node = NodeTraversal::nextPostOrder(*node);
 657             text-&gt;remove();
 658             continue;
 659         }
 660 
 661         // Merge text nodes.
 662         while (Node* nextSibling = node-&gt;nextSibling()) {
 663             if (nextSibling-&gt;nodeType() != TEXT_NODE)
 664                 break;
 665             Ref&lt;Text&gt; nextText = downcast&lt;Text&gt;(*nextSibling);
 666 
 667             // Remove empty text nodes.
 668             if (!nextText-&gt;length()) {
 669                 nextText-&gt;remove();
 670                 continue;
 671             }
 672 
 673             // Both non-empty text nodes. Merge them.
 674             unsigned offset = text-&gt;length();
 675             text-&gt;appendData(nextText-&gt;data());
 676             document().textNodesMerged(nextText, offset);
 677             nextText-&gt;remove();
 678         }
 679 
 680         node = NodeTraversal::nextPostOrder(*node);
 681     }
 682 }
 683 
 684 ExceptionOr&lt;Ref&lt;Node&gt;&gt; Node::cloneNodeForBindings(bool deep)
 685 {
 686     if (UNLIKELY(isShadowRoot()))
 687         return Exception { NotSupportedError };
 688     return cloneNode(deep);
 689 }
 690 
<a name="12" id="anc12"></a><span class="line-modified"> 691 const AtomicString&amp; Node::prefix() const</span>
 692 {
 693     // For nodes other than elements and attributes, the prefix is always null
 694     return nullAtom();
 695 }
 696 
<a name="13" id="anc13"></a><span class="line-modified"> 697 ExceptionOr&lt;void&gt; Node::setPrefix(const AtomicString&amp;)</span>
 698 {
 699     // The spec says that for nodes other than elements and attributes, prefix is always null.
 700     // It does not say what to do when the user tries to set the prefix on another type of
 701     // node, however Mozilla throws a NamespaceError exception.
 702     return Exception { NamespaceError };
 703 }
 704 
<a name="14" id="anc14"></a><span class="line-modified"> 705 const AtomicString&amp; Node::localName() const</span>
 706 {
 707     return nullAtom();
 708 }
 709 
<a name="15" id="anc15"></a><span class="line-modified"> 710 const AtomicString&amp; Node::namespaceURI() const</span>
 711 {
 712     return nullAtom();
 713 }
 714 
 715 bool Node::isContentEditable()
 716 {
 717     return computeEditability(UserSelectAllDoesNotAffectEditability, ShouldUpdateStyle::Update) != Editability::ReadOnly;
 718 }
 719 
 720 bool Node::isContentRichlyEditable()
 721 {
 722     return computeEditability(UserSelectAllIsAlwaysNonEditable, ShouldUpdateStyle::Update) == Editability::CanEditRichly;
 723 }
 724 
 725 void Node::inspect()
 726 {
 727     if (document().page())
 728         document().page()-&gt;inspectorController().inspect(this);
 729 }
 730 
 731 static Node::Editability computeEditabilityFromComputedStyle(const Node&amp; startNode, Node::UserSelectAllTreatment treatment)
 732 {
 733     // Ideally we&#39;d call ASSERT(!needsStyleRecalc()) here, but
 734     // ContainerNode::setFocus() calls invalidateStyleForSubtree(), so the assertion
 735     // would fire in the middle of Document::setFocusedElement().
 736 
 737     for (const Node* node = &amp;startNode; node; node = node-&gt;parentNode()) {
 738         auto* style = node-&gt;isDocumentNode() ? node-&gt;renderStyle() : const_cast&lt;Node*&gt;(node)-&gt;computedStyle();
 739         if (!style)
 740             continue;
 741         if (style-&gt;display() == DisplayType::None)
 742             continue;
 743 #if ENABLE(USERSELECT_ALL)
 744         // Elements with user-select: all style are considered atomic
 745         // therefore non editable.
 746         if (treatment == Node::UserSelectAllIsAlwaysNonEditable &amp;&amp; style-&gt;userSelect() == UserSelect::All)
 747             return Node::Editability::ReadOnly;
 748 #else
 749         UNUSED_PARAM(treatment);
 750 #endif
 751         switch (style-&gt;userModify()) {
 752         case UserModify::ReadOnly:
 753             return Node::Editability::ReadOnly;
 754         case UserModify::ReadWrite:
 755             return Node::Editability::CanEditRichly;
 756         case UserModify::ReadWritePlaintextOnly:
 757             return Node::Editability::CanEditPlainText;
 758         }
 759         ASSERT_NOT_REACHED();
 760         return Node::Editability::ReadOnly;
 761     }
 762     return Node::Editability::ReadOnly;
 763 }
 764 
 765 Node::Editability Node::computeEditability(UserSelectAllTreatment treatment, ShouldUpdateStyle shouldUpdateStyle) const
 766 {
 767     if (!document().hasLivingRenderTree() || isPseudoElement())
 768         return Editability::ReadOnly;
 769 
 770     if (isInShadowTree())
 771         return HTMLElement::editabilityFromContentEditableAttr(*this);
 772 
 773     if (document().frame() &amp;&amp; document().frame()-&gt;page() &amp;&amp; document().frame()-&gt;page()-&gt;isEditable())
 774         return Editability::CanEditRichly;
 775 
 776     if (shouldUpdateStyle == ShouldUpdateStyle::Update &amp;&amp; document().needsStyleRecalc()) {
 777         if (!document().usesStyleBasedEditability())
 778             return HTMLElement::editabilityFromContentEditableAttr(*this);
 779         document().updateStyleIfNeeded();
 780     }
 781     return computeEditabilityFromComputedStyle(*this, treatment);
 782 }
 783 
 784 RenderBox* Node::renderBox() const
 785 {
 786     RenderObject* renderer = this-&gt;renderer();
 787     return is&lt;RenderBox&gt;(renderer) ? downcast&lt;RenderBox&gt;(renderer) : nullptr;
 788 }
 789 
 790 RenderBoxModelObject* Node::renderBoxModelObject() const
 791 {
 792     RenderObject* renderer = this-&gt;renderer();
 793     return is&lt;RenderBoxModelObject&gt;(renderer) ? downcast&lt;RenderBoxModelObject&gt;(renderer) : nullptr;
 794 }
 795 
 796 LayoutRect Node::renderRect(bool* isReplaced)
 797 {
 798     RenderObject* hitRenderer = this-&gt;renderer();
<a name="16" id="anc16"></a><span class="line-modified"> 799     ASSERT(hitRenderer);</span>




 800     RenderObject* renderer = hitRenderer;
 801     while (renderer &amp;&amp; !renderer-&gt;isBody() &amp;&amp; !renderer-&gt;isDocumentElementRenderer()) {
 802         if (renderer-&gt;isRenderBlock() || renderer-&gt;isInlineBlockOrInlineTable() || renderer-&gt;isReplaced()) {
 803             *isReplaced = renderer-&gt;isReplaced();
 804             return renderer-&gt;absoluteBoundingBoxRect();
 805         }
 806         renderer = renderer-&gt;parent();
 807     }
 808     return LayoutRect();
 809 }
 810 
 811 void Node::refEventTarget()
 812 {
 813     ref();
 814 }
 815 
 816 void Node::derefEventTarget()
 817 {
 818     deref();
 819 }
 820 
 821 void Node::adjustStyleValidity(Style::Validity validity, Style::InvalidationMode mode)
 822 {
 823     if (validity &gt; styleValidity()) {
 824         m_nodeFlags &amp;= ~StyleValidityMask;
 825         m_nodeFlags |= static_cast&lt;unsigned&gt;(validity) &lt;&lt; StyleValidityShift;
 826     }
 827     if (mode == Style::InvalidationMode::RecompositeLayer)
 828         setFlag(StyleResolutionShouldRecompositeLayerFlag);
 829 }
 830 
 831 inline void Node::updateAncestorsForStyleRecalc()
 832 {
 833     auto composedAncestors = composedTreeAncestors(*this);
 834     auto it = composedAncestors.begin();
 835     auto end = composedAncestors.end();
 836     if (it != end) {
 837         it-&gt;setDirectChildNeedsStyleRecalc();
 838 
 839         for (; it != end; ++it) {
 840             // Iterator skips over shadow roots.
 841             if (auto* shadowRoot = it-&gt;shadowRoot())
 842                 shadowRoot-&gt;setChildNeedsStyleRecalc();
 843             if (it-&gt;childNeedsStyleRecalc())
 844                 break;
 845             it-&gt;setChildNeedsStyleRecalc();
 846         }
 847     }
 848 
 849     auto* documentElement = document().documentElement();
 850     if (!documentElement)
 851         return;
 852     if (!documentElement-&gt;childNeedsStyleRecalc() &amp;&amp; !documentElement-&gt;needsStyleRecalc())
 853         return;
 854     document().setChildNeedsStyleRecalc();
 855     document().scheduleStyleRecalc();
 856 }
 857 
 858 void Node::invalidateStyle(Style::Validity validity, Style::InvalidationMode mode)
 859 {
 860     ASSERT(validity != Style::Validity::Valid);
 861     if (!inRenderedDocument())
 862         return;
 863 
 864     // FIXME: This should eventually be an ASSERT.
 865     if (document().inRenderTreeUpdate())
 866         return;
 867 
 868     // FIXME: Why the second condition?
 869     bool markAncestors = styleValidity() == Style::Validity::Valid || validity == Style::Validity::SubtreeAndRenderersInvalid;
 870 
 871     adjustStyleValidity(validity, mode);
 872 
 873     if (markAncestors)
 874         updateAncestorsForStyleRecalc();
 875 }
 876 
 877 unsigned Node::computeNodeIndex() const
 878 {
 879     unsigned count = 0;
 880     for (Node* sibling = previousSibling(); sibling; sibling = sibling-&gt;previousSibling())
 881         ++count;
 882     return count;
 883 }
 884 
 885 template&lt;unsigned type&gt;
 886 bool shouldInvalidateNodeListCachesForAttr(const unsigned nodeListCounts[], const QualifiedName&amp; attrName)
 887 {
 888     if (nodeListCounts[type] &amp;&amp; shouldInvalidateTypeOnAttributeChange(static_cast&lt;NodeListInvalidationType&gt;(type), attrName))
 889         return true;
 890     return shouldInvalidateNodeListCachesForAttr&lt;type + 1&gt;(nodeListCounts, attrName);
 891 }
 892 
 893 template&lt;&gt;
 894 bool shouldInvalidateNodeListCachesForAttr&lt;numNodeListInvalidationTypes&gt;(const unsigned[], const QualifiedName&amp;)
 895 {
 896     return false;
 897 }
 898 
 899 inline bool Document::shouldInvalidateNodeListAndCollectionCaches() const
 900 {
 901     for (int type = 0; type &lt; numNodeListInvalidationTypes; ++type) {
 902         if (m_nodeListAndCollectionCounts[type])
 903             return true;
 904     }
 905     return false;
 906 }
 907 
 908 inline bool Document::shouldInvalidateNodeListAndCollectionCachesForAttribute(const QualifiedName&amp; attrName) const
 909 {
 910     return shouldInvalidateNodeListCachesForAttr&lt;DoNotInvalidateOnAttributeChanges + 1&gt;(m_nodeListAndCollectionCounts, attrName);
 911 }
 912 
 913 template &lt;typename InvalidationFunction&gt;
 914 void Document::invalidateNodeListAndCollectionCaches(InvalidationFunction invalidate)
 915 {
 916     for (auto* list : copyToVectorSpecialization&lt;Vector&lt;LiveNodeList*, 8&gt;&gt;(m_listsInvalidatedAtDocument))
 917         invalidate(*list);
 918 
 919     for (auto* collection : copyToVectorSpecialization&lt;Vector&lt;HTMLCollection*, 8&gt;&gt;(m_collectionsInvalidatedAtDocument))
 920         invalidate(*collection);
 921 }
 922 
 923 void Node::invalidateNodeListAndCollectionCachesInAncestors()
 924 {
 925     if (hasRareData()) {
 926         if (auto* lists = rareData()-&gt;nodeLists())
 927             lists-&gt;clearChildNodeListCache();
 928     }
 929 
 930     if (!document().shouldInvalidateNodeListAndCollectionCaches())
 931         return;
 932 
 933     document().invalidateNodeListAndCollectionCaches([](auto&amp; list) {
 934         list.invalidateCache();
 935     });
 936 
 937     for (auto* node = this; node; node = node-&gt;parentNode()) {
 938         if (!node-&gt;hasRareData())
 939             continue;
 940 
 941         if (auto* lists = node-&gt;rareData()-&gt;nodeLists())
 942             lists-&gt;invalidateCaches();
 943     }
 944 }
 945 
 946 void Node::invalidateNodeListAndCollectionCachesInAncestorsForAttribute(const QualifiedName&amp; attrName)
 947 {
 948     ASSERT(is&lt;Element&gt;(*this));
 949 
 950     if (!document().shouldInvalidateNodeListAndCollectionCachesForAttribute(attrName))
 951         return;
 952 
 953     document().invalidateNodeListAndCollectionCaches([&amp;attrName](auto&amp; list) {
 954         list.invalidateCacheForAttribute(attrName);
 955     });
 956 
 957     for (auto* node = this; node; node = node-&gt;parentNode()) {
 958         if (!node-&gt;hasRareData())
 959             continue;
 960 
 961         if (auto* lists = node-&gt;rareData()-&gt;nodeLists())
 962             lists-&gt;invalidateCachesForAttribute(attrName);
 963     }
 964 }
 965 
 966 NodeListsNodeData* Node::nodeLists()
 967 {
 968     return hasRareData() ? rareData()-&gt;nodeLists() : nullptr;
 969 }
 970 
 971 void Node::clearNodeLists()
 972 {
 973     rareData()-&gt;clearNodeLists();
 974 }
 975 
<a name="17" id="anc17"></a><span class="line-modified"> 976 ExceptionOr&lt;void&gt; Node::checkSetPrefix(const AtomicString&amp; prefix)</span>
 977 {
 978     // Perform error checking as required by spec for setting Node.prefix. Used by
 979     // Element::setPrefix() and Attr::setPrefix()
 980 
 981     if (!prefix.isEmpty() &amp;&amp; !Document::isValidName(prefix))
 982         return Exception { InvalidCharacterError };
 983 
 984     // FIXME: Raise NamespaceError if prefix is malformed per the Namespaces in XML specification.
 985 
 986     auto&amp; namespaceURI = this-&gt;namespaceURI();
 987     if (namespaceURI.isEmpty() &amp;&amp; !prefix.isEmpty())
 988         return Exception { NamespaceError };
 989     if (prefix == xmlAtom() &amp;&amp; namespaceURI != XMLNames::xmlNamespaceURI)
 990         return Exception { NamespaceError };
 991 
 992     // Attribute-specific checks are in Attr::setPrefix().
 993 
 994     return { };
 995 }
 996 
 997 bool Node::isDescendantOf(const Node&amp; other) const
 998 {
 999     // Return true if other is an ancestor of this, otherwise false
1000     if (!other.hasChildNodes() || isConnected() != other.isConnected())
1001         return false;
1002     if (other.isDocumentNode())
1003         return &amp;document() == &amp;other &amp;&amp; !isDocumentNode() &amp;&amp; isConnected();
1004     for (const auto* ancestor = parentNode(); ancestor; ancestor = ancestor-&gt;parentNode()) {
1005         if (ancestor == &amp;other)
1006             return true;
1007     }
1008     return false;
1009 }
1010 
1011 bool Node::isDescendantOrShadowDescendantOf(const Node* other) const
1012 {
1013     // FIXME: This element&#39;s shadow tree&#39;s host could be inside another shadow tree.
1014     // This function doesn&#39;t handle that case correctly. Maybe share code with
1015     // the containsIncludingShadowDOM function?
1016     return other &amp;&amp; (isDescendantOf(*other) || other-&gt;contains(shadowHost()));
1017 }
1018 
1019 bool Node::contains(const Node* node) const
1020 {
1021     return this == node || (node &amp;&amp; node-&gt;isDescendantOf(*this));
1022 }
1023 
1024 bool Node::containsIncludingShadowDOM(const Node* node) const
1025 {
1026     for (; node; node = node-&gt;parentOrShadowHostNode()) {
1027         if (node == this)
1028             return true;
1029     }
1030     return false;
1031 }
1032 
1033 Node* Node::pseudoAwarePreviousSibling() const
1034 {
1035     Element* parentOrHost = is&lt;PseudoElement&gt;(*this) ? downcast&lt;PseudoElement&gt;(*this).hostElement() : parentElement();
1036     if (parentOrHost &amp;&amp; !previousSibling()) {
1037         if (isAfterPseudoElement() &amp;&amp; parentOrHost-&gt;lastChild())
1038             return parentOrHost-&gt;lastChild();
1039         if (!isBeforePseudoElement())
1040             return parentOrHost-&gt;beforePseudoElement();
1041     }
1042     return previousSibling();
1043 }
1044 
1045 Node* Node::pseudoAwareNextSibling() const
1046 {
1047     Element* parentOrHost = is&lt;PseudoElement&gt;(*this) ? downcast&lt;PseudoElement&gt;(*this).hostElement() : parentElement();
1048     if (parentOrHost &amp;&amp; !nextSibling()) {
1049         if (isBeforePseudoElement() &amp;&amp; parentOrHost-&gt;firstChild())
1050             return parentOrHost-&gt;firstChild();
1051         if (!isAfterPseudoElement())
1052             return parentOrHost-&gt;afterPseudoElement();
1053     }
1054     return nextSibling();
1055 }
1056 
1057 Node* Node::pseudoAwareFirstChild() const
1058 {
1059     if (is&lt;Element&gt;(*this)) {
1060         const Element&amp; currentElement = downcast&lt;Element&gt;(*this);
1061         Node* first = currentElement.beforePseudoElement();
1062         if (first)
1063             return first;
1064         first = currentElement.firstChild();
1065         if (!first)
1066             first = currentElement.afterPseudoElement();
1067         return first;
1068     }
1069     return firstChild();
1070 }
1071 
1072 Node* Node::pseudoAwareLastChild() const
1073 {
1074     if (is&lt;Element&gt;(*this)) {
1075         const Element&amp; currentElement = downcast&lt;Element&gt;(*this);
1076         Node* last = currentElement.afterPseudoElement();
1077         if (last)
1078             return last;
1079         last = currentElement.lastChild();
1080         if (!last)
1081             last = currentElement.beforePseudoElement();
1082         return last;
1083     }
1084     return lastChild();
1085 }
1086 
1087 const RenderStyle* Node::computedStyle(PseudoId pseudoElementSpecifier)
1088 {
1089     auto* composedParent = composedTreeAncestors(*this).first();
1090     if (!composedParent)
1091         return nullptr;
1092     return composedParent-&gt;computedStyle(pseudoElementSpecifier);
1093 }
1094 
1095 int Node::maxCharacterOffset() const
1096 {
1097     ASSERT_NOT_REACHED();
1098     return 0;
1099 }
1100 
1101 // FIXME: Shouldn&#39;t these functions be in the editing code?  Code that asks questions about HTML in the core DOM class
1102 // is obviously misplaced.
1103 bool Node::canStartSelection() const
1104 {
1105     if (hasEditableStyle())
1106         return true;
1107 
1108     if (renderer()) {
1109         const RenderStyle&amp; style = renderer()-&gt;style();
1110         // We allow selections to begin within an element that has -webkit-user-select: none set,
1111         // but if the element is draggable then dragging should take priority over selection.
1112         if (style.userDrag() == UserDrag::Element &amp;&amp; style.userSelect() == UserSelect::None)
1113             return false;
1114     }
1115     return parentOrShadowHostNode() ? parentOrShadowHostNode()-&gt;canStartSelection() : true;
1116 }
1117 
1118 Element* Node::shadowHost() const
1119 {
1120     if (ShadowRoot* root = containingShadowRoot())
1121         return root-&gt;host();
1122     return nullptr;
1123 }
1124 
1125 ShadowRoot* Node::containingShadowRoot() const
1126 {
1127     ContainerNode&amp; root = treeScope().rootNode();
1128     return is&lt;ShadowRoot&gt;(root) ? downcast&lt;ShadowRoot&gt;(&amp;root) : nullptr;
1129 }
1130 
1131 #if !ASSERT_DISABLED
1132 // https://dom.spec.whatwg.org/#concept-closed-shadow-hidden
1133 static bool isClosedShadowHiddenUsingSpecDefinition(const Node&amp; A, const Node&amp; B)
1134 {
1135     return A.isInShadowTree()
1136         &amp;&amp; !A.rootNode().containsIncludingShadowDOM(&amp;B)
1137         &amp;&amp; (A.containingShadowRoot()-&gt;mode() != ShadowRootMode::Open || isClosedShadowHiddenUsingSpecDefinition(*A.shadowHost(), B));
1138 }
1139 #endif
1140 
1141 // http://w3c.github.io/webcomponents/spec/shadow/#dfn-unclosed-node
1142 bool Node::isClosedShadowHidden(const Node&amp; otherNode) const
1143 {
1144     // Use Vector instead of HashSet since we expect the number of ancestor tree scopes to be small.
1145     Vector&lt;TreeScope*, 8&gt; ancestorScopesOfThisNode;
1146 
1147     for (auto* scope = &amp;treeScope(); scope; scope = scope-&gt;parentTreeScope())
1148         ancestorScopesOfThisNode.append(scope);
1149 
1150     for (auto* treeScopeThatCanAccessOtherNode = &amp;otherNode.treeScope(); treeScopeThatCanAccessOtherNode; treeScopeThatCanAccessOtherNode = treeScopeThatCanAccessOtherNode-&gt;parentTreeScope()) {
1151         for (auto* scope : ancestorScopesOfThisNode) {
1152             if (scope == treeScopeThatCanAccessOtherNode) {
1153                 ASSERT(!isClosedShadowHiddenUsingSpecDefinition(otherNode, *this));
1154                 return false; // treeScopeThatCanAccessOtherNode is a shadow-including inclusive ancestor of this node.
1155             }
1156         }
1157         auto&amp; root = treeScopeThatCanAccessOtherNode-&gt;rootNode();
1158         if (is&lt;ShadowRoot&gt;(root) &amp;&amp; downcast&lt;ShadowRoot&gt;(root).mode() != ShadowRootMode::Open)
1159             break;
1160     }
1161 
1162     ASSERT(isClosedShadowHiddenUsingSpecDefinition(otherNode, *this));
1163     return true;
1164 }
1165 
1166 static inline ShadowRoot* parentShadowRoot(const Node&amp; node)
1167 {
1168     if (auto* parent = node.parentElement())
1169         return parent-&gt;shadowRoot();
1170     return nullptr;
1171 }
1172 
1173 HTMLSlotElement* Node::assignedSlot() const
1174 {
1175     if (auto* shadowRoot = parentShadowRoot(*this))
1176         return shadowRoot-&gt;findAssignedSlot(*this);
1177     return nullptr;
1178 }
1179 
1180 HTMLSlotElement* Node::assignedSlotForBindings() const
1181 {
1182     auto* shadowRoot = parentShadowRoot(*this);
1183     if (shadowRoot &amp;&amp; shadowRoot-&gt;mode() == ShadowRootMode::Open)
1184         return shadowRoot-&gt;findAssignedSlot(*this);
1185     return nullptr;
1186 }
1187 
1188 ContainerNode* Node::parentInComposedTree() const
1189 {
1190     ASSERT(isMainThreadOrGCThread());
1191     if (auto* slot = assignedSlot())
1192         return slot;
1193     if (is&lt;ShadowRoot&gt;(*this))
1194         return downcast&lt;ShadowRoot&gt;(*this).host();
1195     return parentNode();
1196 }
1197 
1198 Element* Node::parentElementInComposedTree() const
1199 {
1200     if (auto* slot = assignedSlot())
1201         return slot;
1202     if (is&lt;PseudoElement&gt;(*this))
1203         return downcast&lt;PseudoElement&gt;(*this).hostElement();
1204     if (auto* parent = parentNode()) {
1205         if (is&lt;ShadowRoot&gt;(*parent))
1206             return downcast&lt;ShadowRoot&gt;(*parent).host();
1207         if (is&lt;Element&gt;(*parent))
1208             return downcast&lt;Element&gt;(parent);
1209     }
1210     return nullptr;
1211 }
1212 
1213 bool Node::isInUserAgentShadowTree() const
1214 {
1215     auto* shadowRoot = containingShadowRoot();
1216     return shadowRoot &amp;&amp; shadowRoot-&gt;mode() == ShadowRootMode::UserAgent;
1217 }
1218 
1219 Node* Node::nonBoundaryShadowTreeRootNode()
1220 {
1221     ASSERT(!isShadowRoot());
1222     Node* root = this;
1223     while (root) {
1224         if (root-&gt;isShadowRoot())
1225             return root;
1226         Node* parent = root-&gt;parentNodeGuaranteedHostFree();
1227         if (parent &amp;&amp; parent-&gt;isShadowRoot())
1228             return root;
1229         root = parent;
1230     }
1231     return 0;
1232 }
1233 
1234 ContainerNode* Node::nonShadowBoundaryParentNode() const
1235 {
1236     ContainerNode* parent = parentNode();
1237     return parent &amp;&amp; !parent-&gt;isShadowRoot() ? parent : nullptr;
1238 }
1239 
1240 Element* Node::parentOrShadowHostElement() const
1241 {
1242     ContainerNode* parent = parentOrShadowHostNode();
1243     if (!parent)
1244         return nullptr;
1245 
1246     if (is&lt;ShadowRoot&gt;(*parent))
1247         return downcast&lt;ShadowRoot&gt;(*parent).host();
1248 
1249     if (!is&lt;Element&gt;(*parent))
1250         return nullptr;
1251 
1252     return downcast&lt;Element&gt;(parent);
1253 }
1254 
1255 Node&amp; Node::traverseToRootNode() const
1256 {
1257     Node* node = const_cast&lt;Node*&gt;(this);
1258     Node* highest = node;
1259     for (; node; node = node-&gt;parentNode())
1260         highest = node;
1261     return *highest;
1262 }
1263 
1264 // https://dom.spec.whatwg.org/#concept-shadow-including-root
1265 Node&amp; Node::shadowIncludingRoot() const
1266 {
1267     auto&amp; root = rootNode();
1268     if (!is&lt;ShadowRoot&gt;(root))
1269         return root;
1270     auto* host = downcast&lt;ShadowRoot&gt;(root).host();
1271     return host ? host-&gt;shadowIncludingRoot() : root;
1272 }
1273 
1274 Node&amp; Node::getRootNode(const GetRootNodeOptions&amp; options) const
1275 {
1276     return options.composed ? shadowIncludingRoot() : rootNode();
1277 }
1278 
1279 Node::InsertedIntoAncestorResult Node::insertedIntoAncestor(InsertionType insertionType, ContainerNode&amp; parentOfInsertedTree)
1280 {
1281     if (insertionType.connectedToDocument)
1282         setFlag(IsConnectedFlag);
1283     if (parentOfInsertedTree.isInShadowTree())
1284         setFlag(IsInShadowTreeFlag);
1285 
1286     invalidateStyle(Style::Validity::SubtreeAndRenderersInvalid);
1287 
1288     return InsertedIntoAncestorResult::Done;
1289 }
1290 
1291 void Node::removedFromAncestor(RemovalType removalType, ContainerNode&amp;)
1292 {
1293     if (removalType.disconnectedFromDocument)
1294         clearFlag(IsConnectedFlag);
1295     if (isInShadowTree() &amp;&amp; !treeScope().rootNode().isShadowRoot())
1296         clearFlag(IsInShadowTreeFlag);
1297 }
1298 
1299 bool Node::isRootEditableElement() const
1300 {
1301     return hasEditableStyle() &amp;&amp; isElementNode() &amp;&amp; (!parentNode() || !parentNode()-&gt;hasEditableStyle()
1302         || !parentNode()-&gt;isElementNode() || hasTagName(bodyTag));
1303 }
1304 
1305 Element* Node::rootEditableElement() const
1306 {
1307     Element* result = nullptr;
1308     for (Node* node = const_cast&lt;Node*&gt;(this); node &amp;&amp; node-&gt;hasEditableStyle(); node = node-&gt;parentNode()) {
1309         if (is&lt;Element&gt;(*node))
1310             result = downcast&lt;Element&gt;(node);
1311         if (is&lt;HTMLBodyElement&gt;(*node))
1312             break;
1313     }
1314     return result;
1315 }
1316 
1317 // FIXME: End of obviously misplaced HTML editing functions.  Try to move these out of Node.
1318 
1319 Document* Node::ownerDocument() const
1320 {
1321     Document* document = &amp;this-&gt;document();
1322     return document == this ? nullptr : document;
1323 }
1324 
1325 const URL&amp; Node::baseURI() const
1326 {
1327     auto&amp; url = document().baseURL();
1328     return url.isNull() ? WTF::blankURL() : url;
1329 }
1330 
1331 bool Node::isEqualNode(Node* other) const
1332 {
1333     if (!other)
1334         return false;
1335 
1336     NodeType nodeType = this-&gt;nodeType();
1337     if (nodeType != other-&gt;nodeType())
1338         return false;
1339 
1340     switch (nodeType) {
1341     case Node::DOCUMENT_TYPE_NODE: {
1342         auto&amp; thisDocType = downcast&lt;DocumentType&gt;(*this);
1343         auto&amp; otherDocType = downcast&lt;DocumentType&gt;(*other);
1344         if (thisDocType.name() != otherDocType.name())
1345             return false;
1346         if (thisDocType.publicId() != otherDocType.publicId())
1347             return false;
1348         if (thisDocType.systemId() != otherDocType.systemId())
1349             return false;
1350         break;
1351         }
1352     case Node::ELEMENT_NODE: {
1353         auto&amp; thisElement = downcast&lt;Element&gt;(*this);
1354         auto&amp; otherElement = downcast&lt;Element&gt;(*other);
1355         if (thisElement.tagQName() != otherElement.tagQName())
1356             return false;
1357         if (!thisElement.hasEquivalentAttributes(otherElement))
1358             return false;
1359         break;
1360         }
1361     case Node::PROCESSING_INSTRUCTION_NODE: {
1362         auto&amp; thisProcessingInstruction = downcast&lt;ProcessingInstruction&gt;(*this);
1363         auto&amp; otherProcessingInstruction = downcast&lt;ProcessingInstruction&gt;(*other);
1364         if (thisProcessingInstruction.target() != otherProcessingInstruction.target())
1365             return false;
1366         if (thisProcessingInstruction.data() != otherProcessingInstruction.data())
1367             return false;
1368         break;
1369         }
1370     case Node::CDATA_SECTION_NODE:
1371     case Node::TEXT_NODE:
1372     case Node::COMMENT_NODE: {
1373         auto&amp; thisCharacterData = downcast&lt;CharacterData&gt;(*this);
1374         auto&amp; otherCharacterData = downcast&lt;CharacterData&gt;(*other);
1375         if (thisCharacterData.data() != otherCharacterData.data())
1376             return false;
1377         break;
1378         }
1379     case Node::ATTRIBUTE_NODE: {
1380         auto&amp; thisAttribute = downcast&lt;Attr&gt;(*this);
1381         auto&amp; otherAttribute = downcast&lt;Attr&gt;(*other);
1382         if (thisAttribute.qualifiedName() != otherAttribute.qualifiedName())
1383             return false;
1384         if (thisAttribute.value() != otherAttribute.value())
1385             return false;
1386         break;
1387         }
1388     case Node::DOCUMENT_NODE:
1389     case Node::DOCUMENT_FRAGMENT_NODE:
1390         break;
1391     }
1392 
1393     Node* child = firstChild();
1394     Node* otherChild = other-&gt;firstChild();
1395 
1396     while (child) {
1397         if (!child-&gt;isEqualNode(otherChild))
1398             return false;
1399 
1400         child = child-&gt;nextSibling();
1401         otherChild = otherChild-&gt;nextSibling();
1402     }
1403 
1404     if (otherChild)
1405         return false;
1406 
1407     return true;
1408 }
1409 
1410 // https://dom.spec.whatwg.org/#locate-a-namespace
<a name="18" id="anc18"></a><span class="line-modified">1411 static const AtomicString&amp; locateDefaultNamespace(const Node&amp; node, const AtomicString&amp; prefix)</span>
1412 {
1413     switch (node.nodeType()) {
1414     case Node::ELEMENT_NODE: {
1415         auto&amp; element = downcast&lt;Element&gt;(node);
1416         auto&amp; namespaceURI = element.namespaceURI();
1417         if (!namespaceURI.isNull() &amp;&amp; element.prefix() == prefix)
1418             return namespaceURI;
1419 
1420         if (element.hasAttributes()) {
1421             for (auto&amp; attribute : element.attributesIterator()) {
1422                 if (attribute.namespaceURI() != XMLNSNames::xmlnsNamespaceURI)
1423                     continue;
1424 
1425                 if ((prefix.isNull() &amp;&amp; attribute.prefix().isNull() &amp;&amp; attribute.localName() == xmlnsAtom()) || (attribute.prefix() == xmlnsAtom() &amp;&amp; attribute.localName() == prefix)) {
1426                     auto&amp; result = attribute.value();
1427                     return result.isEmpty() ? nullAtom() : result;
1428                 }
1429             }
1430         }
1431         auto* parent = node.parentElement();
1432         return parent ? locateDefaultNamespace(*parent, prefix) : nullAtom();
1433     }
1434     case Node::DOCUMENT_NODE:
1435         if (auto* documentElement = downcast&lt;Document&gt;(node).documentElement())
1436             return locateDefaultNamespace(*documentElement, prefix);
1437         return nullAtom();
1438     case Node::DOCUMENT_TYPE_NODE:
1439     case Node::DOCUMENT_FRAGMENT_NODE:
1440         return nullAtom();
1441     case Node::ATTRIBUTE_NODE:
1442         if (auto* ownerElement = downcast&lt;Attr&gt;(node).ownerElement())
1443             return locateDefaultNamespace(*ownerElement, prefix);
1444         return nullAtom();
1445     default:
1446         if (auto* parent = node.parentElement())
1447             return locateDefaultNamespace(*parent, prefix);
1448         return nullAtom();
1449     }
1450 }
1451 
1452 // https://dom.spec.whatwg.org/#dom-node-isdefaultnamespace
<a name="19" id="anc19"></a><span class="line-modified">1453 bool Node::isDefaultNamespace(const AtomicString&amp; potentiallyEmptyNamespace) const</span>
1454 {
<a name="20" id="anc20"></a><span class="line-modified">1455     const AtomicString&amp; namespaceURI = potentiallyEmptyNamespace.isEmpty() ? nullAtom() : potentiallyEmptyNamespace;</span>
1456     return locateDefaultNamespace(*this, nullAtom()) == namespaceURI;
1457 }
1458 
1459 // https://dom.spec.whatwg.org/#dom-node-lookupnamespaceuri
<a name="21" id="anc21"></a><span class="line-modified">1460 const AtomicString&amp; Node::lookupNamespaceURI(const AtomicString&amp; potentiallyEmptyPrefix) const</span>
1461 {
<a name="22" id="anc22"></a><span class="line-modified">1462     const AtomicString&amp; prefix = potentiallyEmptyPrefix.isEmpty() ? nullAtom() : potentiallyEmptyPrefix;</span>
1463     return locateDefaultNamespace(*this, prefix);
1464 }
1465 
1466 // https://dom.spec.whatwg.org/#locate-a-namespace-prefix
<a name="23" id="anc23"></a><span class="line-modified">1467 static const AtomicString&amp; locateNamespacePrefix(const Element&amp; element, const AtomicString&amp; namespaceURI)</span>
1468 {
1469     if (element.namespaceURI() == namespaceURI)
1470         return element.prefix();
1471 
1472     if (element.hasAttributes()) {
1473         for (auto&amp; attribute : element.attributesIterator()) {
1474             if (attribute.prefix() == xmlnsAtom() &amp;&amp; attribute.value() == namespaceURI)
1475                 return attribute.localName();
1476         }
1477     }
1478     auto* parent = element.parentElement();
1479     return parent ? locateNamespacePrefix(*parent, namespaceURI) : nullAtom();
1480 }
1481 
1482 // https://dom.spec.whatwg.org/#dom-node-lookupprefix
<a name="24" id="anc24"></a><span class="line-modified">1483 const AtomicString&amp; Node::lookupPrefix(const AtomicString&amp; namespaceURI) const</span>
1484 {
1485     if (namespaceURI.isEmpty())
1486         return nullAtom();
1487 
1488     switch (nodeType()) {
1489     case ELEMENT_NODE:
1490         return locateNamespacePrefix(downcast&lt;Element&gt;(*this), namespaceURI);
1491     case DOCUMENT_NODE:
1492         if (auto* documentElement = downcast&lt;Document&gt;(*this).documentElement())
1493             return locateNamespacePrefix(*documentElement, namespaceURI);
1494         return nullAtom();
1495     case DOCUMENT_FRAGMENT_NODE:
1496     case DOCUMENT_TYPE_NODE:
1497         return nullAtom();
1498     case ATTRIBUTE_NODE:
1499         if (auto* ownerElement = downcast&lt;Attr&gt;(*this).ownerElement())
1500             return locateNamespacePrefix(*ownerElement, namespaceURI);
1501         return nullAtom();
1502     default:
1503         if (auto* parent = parentElement())
1504             return locateNamespacePrefix(*parent, namespaceURI);
1505         return nullAtom();
1506     }
1507 }
1508 
1509 static void appendTextContent(const Node* node, bool convertBRsToNewlines, bool&amp; isNullString, StringBuilder&amp; content)
1510 {
1511     switch (node-&gt;nodeType()) {
1512     case Node::TEXT_NODE:
1513     case Node::CDATA_SECTION_NODE:
1514     case Node::COMMENT_NODE:
1515         isNullString = false;
1516         content.append(downcast&lt;CharacterData&gt;(*node).data());
1517         break;
1518 
1519     case Node::PROCESSING_INSTRUCTION_NODE:
1520         isNullString = false;
1521         content.append(downcast&lt;ProcessingInstruction&gt;(*node).data());
1522         break;
1523 
1524     case Node::ATTRIBUTE_NODE:
1525         isNullString = false;
1526         content.append(downcast&lt;Attr&gt;(*node).value());
1527         break;
1528 
1529     case Node::ELEMENT_NODE:
1530         if (node-&gt;hasTagName(brTag) &amp;&amp; convertBRsToNewlines) {
1531             isNullString = false;
1532             content.append(&#39;\n&#39;);
1533             break;
1534         }
1535         FALLTHROUGH;
1536     case Node::DOCUMENT_FRAGMENT_NODE:
1537         isNullString = false;
1538         for (Node* child = node-&gt;firstChild(); child; child = child-&gt;nextSibling()) {
1539             if (child-&gt;nodeType() == Node::COMMENT_NODE || child-&gt;nodeType() == Node::PROCESSING_INSTRUCTION_NODE)
1540                 continue;
1541             appendTextContent(child, convertBRsToNewlines, isNullString, content);
1542         }
1543         break;
1544 
1545     case Node::DOCUMENT_NODE:
1546     case Node::DOCUMENT_TYPE_NODE:
1547         break;
1548     }
1549 }
1550 
1551 String Node::textContent(bool convertBRsToNewlines) const
1552 {
1553     StringBuilder content;
1554     bool isNullString = true;
1555     appendTextContent(this, convertBRsToNewlines, isNullString, content);
1556     return isNullString ? String() : content.toString();
1557 }
1558 
1559 ExceptionOr&lt;void&gt; Node::setTextContent(const String&amp; text)
1560 {
1561     switch (nodeType()) {
1562     case ATTRIBUTE_NODE:
1563     case TEXT_NODE:
1564     case CDATA_SECTION_NODE:
1565     case COMMENT_NODE:
1566     case PROCESSING_INSTRUCTION_NODE:
1567         return setNodeValue(text);
1568     case ELEMENT_NODE:
1569     case DOCUMENT_FRAGMENT_NODE: {
1570         auto&amp; container = downcast&lt;ContainerNode&gt;(*this);
1571         if (text.isEmpty())
1572             container.replaceAllChildren(nullptr);
1573         else
1574             container.replaceAllChildren(document().createTextNode(text));
1575         return { };
1576     }
1577     case DOCUMENT_NODE:
1578     case DOCUMENT_TYPE_NODE:
1579         // Do nothing.
1580         return { };
1581     }
1582     ASSERT_NOT_REACHED();
1583     return { };
1584 }
1585 
1586 static SHA1::Digest hashPointer(void* pointer)
1587 {
1588     SHA1 sha1;
1589     sha1.addBytes(reinterpret_cast&lt;const uint8_t*&gt;(&amp;pointer), sizeof(pointer));
1590     SHA1::Digest digest;
1591     sha1.computeHash(digest);
1592     return digest;
1593 }
1594 
1595 static inline unsigned short compareDetachedElementsPosition(Node&amp; firstNode, Node&amp; secondNode)
1596 {
1597     // If the 2 nodes are not in the same tree, return the result of adding DOCUMENT_POSITION_DISCONNECTED,
1598     // DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC, and either DOCUMENT_POSITION_PRECEDING or
1599     // DOCUMENT_POSITION_FOLLOWING, with the constraint that this is to be consistent. Whether to return
1600     // DOCUMENT_POSITION_PRECEDING or DOCUMENT_POSITION_FOLLOWING is implemented by comparing cryptographic
1601     // hashes of Node pointers.
1602     // See step 3 in https://dom.spec.whatwg.org/#dom-node-comparedocumentposition
1603     SHA1::Digest firstHash = hashPointer(&amp;firstNode);
1604     SHA1::Digest secondHash = hashPointer(&amp;secondNode);
1605 
1606     unsigned short direction = memcmp(firstHash.data(), secondHash.data(), SHA1::hashSize) &gt; 0 ? Node::DOCUMENT_POSITION_PRECEDING : Node::DOCUMENT_POSITION_FOLLOWING;
1607 
1608     return Node::DOCUMENT_POSITION_DISCONNECTED | Node::DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC | direction;
1609 }
1610 
1611 unsigned short Node::compareDocumentPosition(Node&amp; otherNode)
1612 {
1613     if (&amp;otherNode == this)
1614         return DOCUMENT_POSITION_EQUIVALENT;
1615 
1616     Attr* attr1 = is&lt;Attr&gt;(*this) ? downcast&lt;Attr&gt;(this) : nullptr;
1617     Attr* attr2 = is&lt;Attr&gt;(otherNode) ? &amp;downcast&lt;Attr&gt;(otherNode) : nullptr;
1618 
1619     Node* start1 = attr1 ? attr1-&gt;ownerElement() : this;
1620     Node* start2 = attr2 ? attr2-&gt;ownerElement() : &amp;otherNode;
1621 
1622     // If either of start1 or start2 is null, then we are disconnected, since one of the nodes is
1623     // an orphaned attribute node.
1624     if (!start1 || !start2)
1625         return compareDetachedElementsPosition(*this, otherNode);
1626 
1627     Vector&lt;Node*, 16&gt; chain1;
1628     Vector&lt;Node*, 16&gt; chain2;
1629     if (attr1)
1630         chain1.append(attr1);
1631     if (attr2)
1632         chain2.append(attr2);
1633 
1634     if (attr1 &amp;&amp; attr2 &amp;&amp; start1 == start2 &amp;&amp; start1) {
1635         // We are comparing two attributes on the same node. Crawl our attribute map and see which one we hit first.
1636         Element* owner1 = attr1-&gt;ownerElement();
1637         owner1-&gt;synchronizeAllAttributes();
1638         for (const Attribute&amp; attribute : owner1-&gt;attributesIterator()) {
1639             // If neither of the two determining nodes is a child node and nodeType is the same for both determining nodes, then an
1640             // implementation-dependent order between the determining nodes is returned. This order is stable as long as no nodes of
1641             // the same nodeType are inserted into or removed from the direct container. This would be the case, for example,
1642             // when comparing two attributes of the same element, and inserting or removing additional attributes might change
1643             // the order between existing attributes.
1644             if (attr1-&gt;qualifiedName() == attribute.name())
1645                 return DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC | DOCUMENT_POSITION_FOLLOWING;
1646             if (attr2-&gt;qualifiedName() == attribute.name())
1647                 return DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC | DOCUMENT_POSITION_PRECEDING;
1648         }
1649 
1650         ASSERT_NOT_REACHED();
1651         return DOCUMENT_POSITION_DISCONNECTED;
1652     }
1653 
1654     // If one node is in the document and the other is not, we must be disconnected.
1655     // If the nodes have different owning documents, they must be disconnected.  Note that we avoid
1656     // comparing Attr nodes here, since they return false from isConnected() all the time (which seems like a bug).
1657     if (start1-&gt;isConnected() != start2-&gt;isConnected() || &amp;start1-&gt;treeScope() != &amp;start2-&gt;treeScope())
1658         return compareDetachedElementsPosition(*this, otherNode);
1659 
1660     // We need to find a common ancestor container, and then compare the indices of the two immediate children.
1661     Node* current;
1662     for (current = start1; current; current = current-&gt;parentNode())
1663         chain1.append(current);
1664     for (current = start2; current; current = current-&gt;parentNode())
1665         chain2.append(current);
1666 
1667     unsigned index1 = chain1.size();
1668     unsigned index2 = chain2.size();
1669 
1670     // If the two elements don&#39;t have a common root, they&#39;re not in the same tree.
1671     if (chain1[index1 - 1] != chain2[index2 - 1])
1672         return compareDetachedElementsPosition(*this, otherNode);
1673 
1674     // Walk the two chains backwards and look for the first difference.
1675     for (unsigned i = std::min(index1, index2); i; --i) {
1676         Node* child1 = chain1[--index1];
1677         Node* child2 = chain2[--index2];
1678         if (child1 != child2) {
1679             // If one of the children is an attribute, it wins.
1680             if (child1-&gt;nodeType() == ATTRIBUTE_NODE)
1681                 return DOCUMENT_POSITION_FOLLOWING;
1682             if (child2-&gt;nodeType() == ATTRIBUTE_NODE)
1683                 return DOCUMENT_POSITION_PRECEDING;
1684 
1685             if (!child2-&gt;nextSibling())
1686                 return DOCUMENT_POSITION_FOLLOWING;
1687             if (!child1-&gt;nextSibling())
1688                 return DOCUMENT_POSITION_PRECEDING;
1689 
1690             // Otherwise we need to see which node occurs first.  Crawl backwards from child2 looking for child1.
1691             for (Node* child = child2-&gt;previousSibling(); child; child = child-&gt;previousSibling()) {
1692                 if (child == child1)
1693                     return DOCUMENT_POSITION_FOLLOWING;
1694             }
1695             return DOCUMENT_POSITION_PRECEDING;
1696         }
1697     }
1698 
1699     // There was no difference between the two parent chains, i.e., one was a subset of the other.  The shorter
1700     // chain is the ancestor.
1701     return index1 &lt; index2 ?
1702                DOCUMENT_POSITION_FOLLOWING | DOCUMENT_POSITION_CONTAINED_BY :
1703                DOCUMENT_POSITION_PRECEDING | DOCUMENT_POSITION_CONTAINS;
1704 }
1705 
1706 FloatPoint Node::convertToPage(const FloatPoint&amp; p) const
1707 {
1708     // If there is a renderer, just ask it to do the conversion
1709     if (renderer())
1710         return renderer()-&gt;localToAbsolute(p, UseTransforms);
1711 
1712     // Otherwise go up the tree looking for a renderer
1713     if (auto* parent = parentElement())
1714         return parent-&gt;convertToPage(p);
1715 
1716     // No parent - no conversion needed
1717     return p;
1718 }
1719 
1720 FloatPoint Node::convertFromPage(const FloatPoint&amp; p) const
1721 {
1722     // If there is a renderer, just ask it to do the conversion
1723     if (renderer())
1724         return renderer()-&gt;absoluteToLocal(p, UseTransforms);
1725 
1726     // Otherwise go up the tree looking for a renderer
1727     if (auto* parent = parentElement())
1728         return parent-&gt;convertFromPage(p);
1729 
1730     // No parent - no conversion needed
1731     return p;
1732 }
1733 
1734 #if ENABLE(TREE_DEBUGGING)
1735 
1736 static void appendAttributeDesc(const Node* node, StringBuilder&amp; stringBuilder, const QualifiedName&amp; name, const char* attrDesc)
1737 {
1738     if (!is&lt;Element&gt;(*node))
1739         return;
1740 
<a name="25" id="anc25"></a><span class="line-modified">1741     const AtomicString&amp; attr = downcast&lt;Element&gt;(*node).getAttribute(name);</span>
1742     if (attr.isEmpty())
1743         return;
1744 
1745     stringBuilder.append(attrDesc);
1746     stringBuilder.append(attr);
1747 }
1748 
1749 void Node::showNode(const char* prefix) const
1750 {
1751     if (!prefix)
1752         prefix = &quot;&quot;;
1753     if (isTextNode()) {
1754         String value = nodeValue();
1755         value.replaceWithLiteral(&#39;\\&#39;, &quot;\\\\&quot;);
1756         value.replaceWithLiteral(&#39;\n&#39;, &quot;\\n&quot;);
1757         fprintf(stderr, &quot;%s%s\t%p \&quot;%s\&quot;\n&quot;, prefix, nodeName().utf8().data(), this, value.utf8().data());
1758     } else {
1759         StringBuilder attrs;
1760         appendAttributeDesc(this, attrs, classAttr, &quot; CLASS=&quot;);
1761         appendAttributeDesc(this, attrs, styleAttr, &quot; STYLE=&quot;);
1762         fprintf(stderr, &quot;%s%s\t%p (renderer %p) %s%s%s\n&quot;, prefix, nodeName().utf8().data(), this, renderer(), attrs.toString().utf8().data(), needsStyleRecalc() ? &quot; (needs style recalc)&quot; : &quot;&quot;, childNeedsStyleRecalc() ? &quot; (child needs style recalc)&quot; : &quot;&quot;);
1763     }
1764 }
1765 
1766 void Node::showTreeForThis() const
1767 {
1768     showTreeAndMark(this, &quot;*&quot;);
1769 }
1770 
1771 void Node::showNodePathForThis() const
1772 {
1773     Vector&lt;const Node*, 16&gt; chain;
1774     const Node* node = this;
1775     while (node-&gt;parentOrShadowHostNode()) {
1776         chain.append(node);
1777         node = node-&gt;parentOrShadowHostNode();
1778     }
1779     for (unsigned index = chain.size(); index &gt; 0; --index) {
1780         const Node* node = chain[index - 1];
1781         if (is&lt;ShadowRoot&gt;(*node)) {
1782             int count = 0;
1783             for (const ShadowRoot* shadowRoot = downcast&lt;ShadowRoot&gt;(node); shadowRoot &amp;&amp; shadowRoot != node; shadowRoot = shadowRoot-&gt;shadowRoot())
1784                 ++count;
1785             fprintf(stderr, &quot;/#shadow-root[%d]&quot;, count);
1786             continue;
1787         }
1788 
1789         switch (node-&gt;nodeType()) {
1790         case ELEMENT_NODE: {
1791             fprintf(stderr, &quot;/%s&quot;, node-&gt;nodeName().utf8().data());
1792 
1793             const Element&amp; element = downcast&lt;Element&gt;(*node);
<a name="26" id="anc26"></a><span class="line-modified">1794             const AtomicString&amp; idattr = element.getIdAttribute();</span>
1795             bool hasIdAttr = !idattr.isNull() &amp;&amp; !idattr.isEmpty();
1796             if (node-&gt;previousSibling() || node-&gt;nextSibling()) {
1797                 int count = 0;
1798                 for (Node* previous = node-&gt;previousSibling(); previous; previous = previous-&gt;previousSibling())
1799                     if (previous-&gt;nodeName() == node-&gt;nodeName())
1800                         ++count;
1801                 if (hasIdAttr)
1802                     fprintf(stderr, &quot;[@id=\&quot;%s\&quot; and position()=%d]&quot;, idattr.string().utf8().data(), count);
1803                 else
1804                     fprintf(stderr, &quot;[%d]&quot;, count);
1805             } else if (hasIdAttr)
1806                 fprintf(stderr, &quot;[@id=\&quot;%s\&quot;]&quot;, idattr.string().utf8().data());
1807             break;
1808         }
1809         case TEXT_NODE:
1810             fprintf(stderr, &quot;/text()&quot;);
1811             break;
1812         case ATTRIBUTE_NODE:
1813             fprintf(stderr, &quot;/@%s&quot;, node-&gt;nodeName().utf8().data());
1814             break;
1815         default:
1816             break;
1817         }
1818     }
1819     fprintf(stderr, &quot;\n&quot;);
1820 }
1821 
1822 static void traverseTreeAndMark(const String&amp; baseIndent, const Node* rootNode, const Node* markedNode1, const char* markedLabel1, const Node* markedNode2, const char* markedLabel2)
1823 {
1824     for (const Node* node = rootNode; node; node = NodeTraversal::next(*node)) {
1825         if (node == markedNode1)
1826             fprintf(stderr, &quot;%s&quot;, markedLabel1);
1827         if (node == markedNode2)
1828             fprintf(stderr, &quot;%s&quot;, markedLabel2);
1829 
1830         StringBuilder indent;
1831         indent.append(baseIndent);
1832         for (const Node* tmpNode = node; tmpNode &amp;&amp; tmpNode != rootNode; tmpNode = tmpNode-&gt;parentOrShadowHostNode())
1833             indent.append(&#39;\t&#39;);
1834         fprintf(stderr, &quot;%s&quot;, indent.toString().utf8().data());
1835         node-&gt;showNode();
1836         indent.append(&#39;\t&#39;);
1837         if (!node-&gt;isShadowRoot()) {
1838             if (ShadowRoot* shadowRoot = node-&gt;shadowRoot())
1839                 traverseTreeAndMark(indent.toString(), shadowRoot, markedNode1, markedLabel1, markedNode2, markedLabel2);
1840         }
1841     }
1842 }
1843 
1844 void Node::showTreeAndMark(const Node* markedNode1, const char* markedLabel1, const Node* markedNode2, const char* markedLabel2) const
1845 {
1846     const Node* rootNode;
1847     const Node* node = this;
1848     while (node-&gt;parentOrShadowHostNode() &amp;&amp; !node-&gt;hasTagName(bodyTag))
1849         node = node-&gt;parentOrShadowHostNode();
1850     rootNode = node;
1851 
1852     String startingIndent;
1853     traverseTreeAndMark(startingIndent, rootNode, markedNode1, markedLabel1, markedNode2, markedLabel2);
1854 }
1855 
1856 void Node::formatForDebugger(char* buffer, unsigned length) const
1857 {
1858     String result;
1859     String s;
1860 
1861     s = nodeName();
1862     if (s.isEmpty())
1863         result = &quot;&lt;none&gt;&quot;;
1864     else
1865         result = s;
1866 
1867     strncpy(buffer, result.utf8().data(), length - 1);
1868 }
1869 
1870 static ContainerNode* parentOrShadowHostOrFrameOwner(const Node* node)
1871 {
1872     ContainerNode* parent = node-&gt;parentOrShadowHostNode();
1873     if (!parent &amp;&amp; node-&gt;document().frame())
1874         parent = node-&gt;document().frame()-&gt;ownerElement();
1875     return parent;
1876 }
1877 
1878 static void showSubTreeAcrossFrame(const Node* node, const Node* markedNode, const String&amp; indent)
1879 {
1880     if (node == markedNode)
1881         fputs(&quot;*&quot;, stderr);
1882     fputs(indent.utf8().data(), stderr);
1883     node-&gt;showNode();
1884     if (!node-&gt;isShadowRoot()) {
1885         if (node-&gt;isFrameOwnerElement())
1886             showSubTreeAcrossFrame(static_cast&lt;const HTMLFrameOwnerElement*&gt;(node)-&gt;contentDocument(), markedNode, indent + &quot;\t&quot;);
1887         if (ShadowRoot* shadowRoot = node-&gt;shadowRoot())
1888             showSubTreeAcrossFrame(shadowRoot, markedNode, indent + &quot;\t&quot;);
1889     }
1890     for (Node* child = node-&gt;firstChild(); child; child = child-&gt;nextSibling())
1891         showSubTreeAcrossFrame(child, markedNode, indent + &quot;\t&quot;);
1892 }
1893 
1894 void Node::showTreeForThisAcrossFrame() const
1895 {
1896     Node* rootNode = const_cast&lt;Node*&gt;(this);
1897     while (parentOrShadowHostOrFrameOwner(rootNode))
1898         rootNode = parentOrShadowHostOrFrameOwner(rootNode);
1899     showSubTreeAcrossFrame(rootNode, this, &quot;&quot;);
1900 }
1901 
1902 #endif // ENABLE(TREE_DEBUGGING)
1903 
1904 // --------
1905 
1906 void NodeListsNodeData::invalidateCaches()
1907 {
1908     for (auto&amp; atomicName : m_atomicNameCaches)
1909         atomicName.value-&gt;invalidateCache();
1910 
1911     for (auto&amp; collection : m_cachedCollections)
1912         collection.value-&gt;invalidateCache();
1913 
1914     for (auto&amp; tagCollection : m_tagCollectionNSCache)
1915         tagCollection.value-&gt;invalidateCache();
1916 }
1917 
1918 void NodeListsNodeData::invalidateCachesForAttribute(const QualifiedName&amp; attrName)
1919 {
1920     for (auto&amp; atomicName : m_atomicNameCaches)
1921         atomicName.value-&gt;invalidateCacheForAttribute(attrName);
1922 
1923     for (auto&amp; collection : m_cachedCollections)
1924         collection.value-&gt;invalidateCacheForAttribute(attrName);
1925 }
1926 
1927 void Node::getSubresourceURLs(ListHashSet&lt;URL&gt;&amp; urls) const
1928 {
1929     addSubresourceAttributeURLs(urls);
1930 }
1931 
1932 Element* Node::enclosingLinkEventParentOrSelf()
1933 {
1934     for (Node* node = this; node; node = node-&gt;parentInComposedTree()) {
1935         // For imagemaps, the enclosing link element is the associated area element not the image itself.
1936         // So we don&#39;t let images be the enclosing link element, even though isLink sometimes returns
1937         // true for them.
1938         if (node-&gt;isLink() &amp;&amp; !is&lt;HTMLImageElement&gt;(*node))
1939             return downcast&lt;Element&gt;(node);
1940     }
1941 
1942     return nullptr;
1943 }
1944 
1945 EventTargetInterface Node::eventTargetInterface() const
1946 {
1947     return NodeEventTargetInterfaceType;
1948 }
1949 
1950 template &lt;typename MoveNodeFunction, typename MoveShadowRootFunction&gt;
1951 static void traverseSubtreeToUpdateTreeScope(Node&amp; root, MoveNodeFunction moveNode, MoveShadowRootFunction moveShadowRoot)
1952 {
1953     for (Node* node = &amp;root; node; node = NodeTraversal::next(*node, &amp;root)) {
1954         moveNode(*node);
1955 
1956         if (!is&lt;Element&gt;(*node))
1957             continue;
1958         Element&amp; element = downcast&lt;Element&gt;(*node);
1959 
1960         if (element.hasSyntheticAttrChildNodes()) {
1961             for (auto&amp; attr : element.attrNodeList())
1962                 moveNode(*attr);
1963         }
1964 
1965         if (auto* shadow = element.shadowRoot())
1966             moveShadowRoot(*shadow);
1967     }
1968 }
1969 
1970 inline void Node::moveShadowTreeToNewDocument(ShadowRoot&amp; shadowRoot, Document&amp; oldDocument, Document&amp; newDocument)
1971 {
1972     traverseSubtreeToUpdateTreeScope(shadowRoot, [&amp;oldDocument, &amp;newDocument](Node&amp; node) {
1973         node.moveNodeToNewDocument(oldDocument, newDocument);
1974     }, [&amp;oldDocument, &amp;newDocument](ShadowRoot&amp; innerShadowRoot) {
1975         RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(&amp;innerShadowRoot.document() == &amp;oldDocument);
1976         innerShadowRoot.moveShadowRootToNewDocument(newDocument);
1977         moveShadowTreeToNewDocument(innerShadowRoot, oldDocument, newDocument);
1978     });
1979 }
1980 
1981 void Node::moveTreeToNewScope(Node&amp; root, TreeScope&amp; oldScope, TreeScope&amp; newScope)
1982 {
1983     ASSERT(&amp;oldScope != &amp;newScope);
1984 
1985     Document&amp; oldDocument = oldScope.documentScope();
1986     Document&amp; newDocument = newScope.documentScope();
1987     if (&amp;oldDocument != &amp;newDocument) {
1988         oldDocument.incrementReferencingNodeCount();
1989         traverseSubtreeToUpdateTreeScope(root, [&amp;](Node&amp; node) {
1990             ASSERT(!node.isTreeScope());
1991             RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(&amp;node.treeScope() == &amp;oldScope);
1992             node.setTreeScope(newScope);
1993             node.moveNodeToNewDocument(oldDocument, newDocument);
1994         }, [&amp;](ShadowRoot&amp; shadowRoot) {
1995             ASSERT_WITH_SECURITY_IMPLICATION(&amp;shadowRoot.document() == &amp;oldDocument);
1996             shadowRoot.moveShadowRootToNewParentScope(newScope, newDocument);
1997             moveShadowTreeToNewDocument(shadowRoot, oldDocument, newDocument);
1998         });
1999         RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(&amp;oldScope.documentScope() == &amp;oldDocument &amp;&amp; &amp;newScope.documentScope() == &amp;newDocument);
2000         oldDocument.decrementReferencingNodeCount();
2001     } else {
2002         traverseSubtreeToUpdateTreeScope(root, [&amp;](Node&amp; node) {
2003             ASSERT(!node.isTreeScope());
2004             RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(&amp;node.treeScope() == &amp;oldScope);
2005             node.setTreeScope(newScope);
2006             if (UNLIKELY(!node.hasRareData()))
2007                 return;
2008             if (auto* nodeLists = node.rareData()-&gt;nodeLists())
2009                 nodeLists-&gt;adoptTreeScope();
2010         }, [&amp;newScope](ShadowRoot&amp; shadowRoot) {
2011             shadowRoot.setParentTreeScope(newScope);
2012         });
2013     }
2014 }
2015 
2016 void Node::moveNodeToNewDocument(Document&amp; oldDocument, Document&amp; newDocument)
2017 {
2018     newDocument.incrementReferencingNodeCount();
2019     oldDocument.decrementReferencingNodeCount();
2020 
2021     if (hasRareData()) {
2022         if (auto* nodeLists = rareData()-&gt;nodeLists())
2023             nodeLists-&gt;adoptDocument(oldDocument, newDocument);
2024         if (auto* registry = mutationObserverRegistry()) {
2025             for (auto&amp; registration : *registry)
2026                 newDocument.addMutationObserverTypes(registration-&gt;mutationTypes());
2027         }
2028         if (auto* transientRegistry = transientMutationObserverRegistry()) {
2029             for (auto&amp; registration : *transientRegistry)
2030                 newDocument.addMutationObserverTypes(registration-&gt;mutationTypes());
2031         }
2032     } else {
2033         ASSERT(!mutationObserverRegistry());
2034         ASSERT(!transientMutationObserverRegistry());
2035     }
2036 
2037     oldDocument.moveNodeIteratorsToNewDocument(*this, newDocument);
2038 
2039     if (AXObjectCache::accessibilityEnabled()) {
2040         if (auto* cache = oldDocument.existingAXObjectCache())
2041             cache-&gt;remove(*this);
2042     }
2043 
2044     if (auto* eventTargetData = this-&gt;eventTargetData()) {
2045         if (!eventTargetData-&gt;eventListenerMap.isEmpty()) {
2046             for (auto&amp; type : eventTargetData-&gt;eventListenerMap.eventTypes())
2047                 newDocument.addListenerTypeIfNeeded(type);
2048         }
2049 
2050         unsigned numWheelEventHandlers = eventListeners(eventNames().mousewheelEvent).size() + eventListeners(eventNames().wheelEvent).size();
2051         for (unsigned i = 0; i &lt; numWheelEventHandlers; ++i) {
2052             oldDocument.didRemoveWheelEventHandler(*this);
2053             newDocument.didAddWheelEventHandler(*this);
2054         }
2055 
2056         unsigned numTouchEventListeners = 0;
<a name="27" id="anc27"></a><span class="line-modified">2057         for (auto&amp; name : eventNames().touchAndPointerEventNames())</span>
<span class="line-modified">2058             numTouchEventListeners += eventListeners(name).size();</span>









2059 
2060         for (unsigned i = 0; i &lt; numTouchEventListeners; ++i) {
2061             oldDocument.didRemoveTouchEventHandler(*this);
2062             newDocument.didAddTouchEventHandler(*this);
2063 #if ENABLE(TOUCH_EVENTS) &amp;&amp; PLATFORM(IOS_FAMILY)
2064             oldDocument.removeTouchEventListener(*this);
2065             newDocument.addTouchEventListener(*this);
2066 #endif
2067         }
2068 
2069 #if ENABLE(TOUCH_EVENTS) &amp;&amp; ENABLE(IOS_GESTURE_EVENTS)
2070         unsigned numGestureEventListeners = 0;
2071         for (auto&amp; name : eventNames().gestureEventNames())
2072             numGestureEventListeners += eventListeners(name).size();
2073 
2074         for (unsigned i = 0; i &lt; numGestureEventListeners; ++i) {
2075             oldDocument.removeTouchEventHandler(*this);
2076             newDocument.addTouchEventHandler(*this);
2077         }
2078 #endif
2079     }
2080 
2081 #if !ASSERT_DISABLED || ENABLE(SECURITY_ASSERTIONS)
2082 #if ENABLE(TOUCH_EVENTS) &amp;&amp; PLATFORM(IOS_FAMILY)
2083     ASSERT_WITH_SECURITY_IMPLICATION(!oldDocument.touchEventListenersContain(*this));
2084     ASSERT_WITH_SECURITY_IMPLICATION(!oldDocument.touchEventHandlersContain(*this));
2085 #endif
2086 #if ENABLE(TOUCH_EVENTS) &amp;&amp; ENABLE(IOS_GESTURE_EVENTS)
2087     ASSERT_WITH_SECURITY_IMPLICATION(!oldDocument.touchEventTargetsContain(*this));
2088 #endif
2089 #endif
2090 
2091     if (is&lt;Element&gt;(*this))
2092         downcast&lt;Element&gt;(*this).didMoveToNewDocument(oldDocument, newDocument);
2093 }
2094 
<a name="28" id="anc28"></a><span class="line-modified">2095 static inline bool tryAddEventListener(Node* targetNode, const AtomicString&amp; eventType, Ref&lt;EventListener&gt;&amp;&amp; listener, const EventTarget::AddEventListenerOptions&amp; options)</span>
2096 {
2097     if (!targetNode-&gt;EventTarget::addEventListener(eventType, listener.copyRef(), options))
2098         return false;
2099 
2100     targetNode-&gt;document().addListenerTypeIfNeeded(eventType);
2101     if (eventNames().isWheelEventType(eventType))
2102         targetNode-&gt;document().didAddWheelEventHandler(*targetNode);
<a name="29" id="anc29"></a><span class="line-modified">2103     else if (eventNames().isTouchEventType(eventType))</span>
2104         targetNode-&gt;document().didAddTouchEventHandler(*targetNode);
2105 
2106 #if PLATFORM(IOS_FAMILY)
2107     if (targetNode == &amp;targetNode-&gt;document() &amp;&amp; eventType == eventNames().scrollEvent)
2108         targetNode-&gt;document().domWindow()-&gt;incrementScrollEventListenersCount();
2109 
<a name="30" id="anc30"></a><span class="line-removed">2110     // FIXME: Would it be sufficient to special-case this code for &lt;body&gt; and &lt;frameset&gt;?</span>
<span class="line-removed">2111     //</span>
<span class="line-removed">2112     // This code was added to address &lt;rdar://problem/5846492&gt; Onorientationchange event not working for document.body.</span>
<span class="line-removed">2113     // Forward this call to addEventListener() to the window since these are window-only events.</span>
<span class="line-removed">2114     if (eventType == eventNames().orientationchangeEvent || eventType == eventNames().resizeEvent)</span>
<span class="line-removed">2115         targetNode-&gt;document().domWindow()-&gt;addEventListener(eventType, WTFMove(listener), options);</span>
<span class="line-removed">2116 </span>
2117 #if ENABLE(TOUCH_EVENTS)
<a name="31" id="anc31"></a><span class="line-modified">2118     if (eventNames().isTouchEventType(eventType))</span>
2119         targetNode-&gt;document().addTouchEventListener(*targetNode);
2120 #endif
2121 #endif // PLATFORM(IOS_FAMILY)
2122 
2123 #if ENABLE(IOS_GESTURE_EVENTS) &amp;&amp; ENABLE(TOUCH_EVENTS)
2124     if (eventNames().isGestureEventType(eventType))
2125         targetNode-&gt;document().addTouchEventHandler(*targetNode);
2126 #endif
2127 
2128     return true;
2129 }
2130 
<a name="32" id="anc32"></a><span class="line-modified">2131 bool Node::addEventListener(const AtomicString&amp; eventType, Ref&lt;EventListener&gt;&amp;&amp; listener, const AddEventListenerOptions&amp; options)</span>
2132 {
2133     return tryAddEventListener(this, eventType, WTFMove(listener), options);
2134 }
2135 
<a name="33" id="anc33"></a><span class="line-modified">2136 static inline bool tryRemoveEventListener(Node* targetNode, const AtomicString&amp; eventType, EventListener&amp; listener, const EventTarget::ListenerOptions&amp; options)</span>
2137 {
2138     if (!targetNode-&gt;EventTarget::removeEventListener(eventType, listener, options))
2139         return false;
2140 
2141     // FIXME: Notify Document that the listener has vanished. We need to keep track of a number of
2142     // listeners for each type, not just a bool - see https://bugs.webkit.org/show_bug.cgi?id=33861
2143     if (eventNames().isWheelEventType(eventType))
2144         targetNode-&gt;document().didRemoveWheelEventHandler(*targetNode);
<a name="34" id="anc34"></a><span class="line-modified">2145     else if (eventNames().isTouchEventType(eventType))</span>
2146         targetNode-&gt;document().didRemoveTouchEventHandler(*targetNode);
2147 
2148 #if PLATFORM(IOS_FAMILY)
2149     if (targetNode == &amp;targetNode-&gt;document() &amp;&amp; eventType == eventNames().scrollEvent)
2150         targetNode-&gt;document().domWindow()-&gt;decrementScrollEventListenersCount();
2151 
<a name="35" id="anc35"></a><span class="line-removed">2152     // FIXME: Would it be sufficient to special-case this code for &lt;body&gt; and &lt;frameset&gt;? See &lt;rdar://problem/15647823&gt;.</span>
<span class="line-removed">2153     // This code was added to address &lt;rdar://problem/5846492&gt; Onorientationchange event not working for document.body.</span>
<span class="line-removed">2154     // Forward this call to removeEventListener() to the window since these are window-only events.</span>
<span class="line-removed">2155     if (eventType == eventNames().orientationchangeEvent || eventType == eventNames().resizeEvent)</span>
<span class="line-removed">2156         targetNode-&gt;document().domWindow()-&gt;removeEventListener(eventType, listener, options);</span>
<span class="line-removed">2157 </span>
2158 #if ENABLE(TOUCH_EVENTS)
<a name="36" id="anc36"></a><span class="line-modified">2159     if (eventNames().isTouchEventType(eventType))</span>
2160         targetNode-&gt;document().removeTouchEventListener(*targetNode);
2161 #endif
2162 #endif // PLATFORM(IOS_FAMILY)
2163 
2164 #if ENABLE(IOS_GESTURE_EVENTS) &amp;&amp; ENABLE(TOUCH_EVENTS)
2165     if (eventNames().isGestureEventType(eventType))
2166         targetNode-&gt;document().removeTouchEventHandler(*targetNode);
2167 #endif
2168 
2169     return true;
2170 }
2171 
<a name="37" id="anc37"></a><span class="line-modified">2172 bool Node::removeEventListener(const AtomicString&amp; eventType, EventListener&amp; listener, const ListenerOptions&amp; options)</span>
2173 {
2174     return tryRemoveEventListener(this, eventType, listener, options);
2175 }
2176 
2177 typedef HashMap&lt;Node*, std::unique_ptr&lt;EventTargetData&gt;&gt; EventTargetDataMap;
2178 
2179 static EventTargetDataMap&amp; eventTargetDataMap()
2180 {
2181     static NeverDestroyed&lt;EventTargetDataMap&gt; map;
2182 
2183     return map;
2184 }
2185 
2186 static Lock s_eventTargetDataMapLock;
2187 
2188 EventTargetData* Node::eventTargetData()
2189 {
2190     return hasEventTargetData() ? eventTargetDataMap().get(this) : nullptr;
2191 }
2192 
2193 EventTargetData* Node::eventTargetDataConcurrently()
2194 {
2195     // Not holding the lock when the world is stopped accelerates parallel constraint solving, which
2196     // calls this function from many threads. Parallel constraint solving can happen with the world
2197     // running or stopped, but if we do it with a running world, then we&#39;re usually mixing constraint
2198     // solving with other work. Therefore, the most likely time for contention on this lock is when the
2199     // world is stopped. We don&#39;t have to hold the lock when the world is stopped, because a stopped world
2200     // means that we will never mutate the event target data map.
2201     JSC::VM* vm = commonVMOrNull();
2202     auto locker = holdLockIf(s_eventTargetDataMapLock, vm &amp;&amp; vm-&gt;heap.worldIsRunning());
2203     return hasEventTargetData() ? eventTargetDataMap().get(this) : nullptr;
2204 }
2205 
2206 EventTargetData&amp; Node::ensureEventTargetData()
2207 {
2208     if (hasEventTargetData())
2209         return *eventTargetDataMap().get(this);
2210 
2211     JSC::VM* vm = commonVMOrNull();
2212     RELEASE_ASSERT(!vm || vm-&gt;heap.worldIsRunning());
2213 
2214     auto locker = holdLock(s_eventTargetDataMapLock);
2215     setHasEventTargetData(true);
<a name="38" id="anc38"></a><span class="line-modified">2216     return *eventTargetDataMap().add(this, std::make_unique&lt;EventTargetData&gt;()).iterator-&gt;value;</span>
2217 }
2218 
2219 void Node::clearEventTargetData()
2220 {
2221     JSC::VM* vm = commonVMOrNull();
2222     RELEASE_ASSERT(!vm || vm-&gt;heap.worldIsRunning());
2223     auto locker = holdLock(s_eventTargetDataMapLock);
2224     eventTargetDataMap().remove(this);
2225 }
2226 
2227 Vector&lt;std::unique_ptr&lt;MutationObserverRegistration&gt;&gt;* Node::mutationObserverRegistry()
2228 {
2229     if (!hasRareData())
2230         return nullptr;
2231     auto* data = rareData()-&gt;mutationObserverData();
2232     if (!data)
2233         return nullptr;
2234     return &amp;data-&gt;registry;
2235 }
2236 
2237 HashSet&lt;MutationObserverRegistration*&gt;* Node::transientMutationObserverRegistry()
2238 {
2239     if (!hasRareData())
2240         return nullptr;
2241     auto* data = rareData()-&gt;mutationObserverData();
2242     if (!data)
2243         return nullptr;
2244     return &amp;data-&gt;transientRegistry;
2245 }
2246 
2247 template&lt;typename Registry&gt; static inline void collectMatchingObserversForMutation(HashMap&lt;Ref&lt;MutationObserver&gt;, MutationRecordDeliveryOptions&gt;&amp; observers, Registry* registry, Node&amp; target, MutationObserver::MutationType type, const QualifiedName* attributeName)
2248 {
2249     if (!registry)
2250         return;
2251 
2252     for (auto&amp; registration : *registry) {
2253         if (registration-&gt;shouldReceiveMutationFrom(target, type, attributeName)) {
2254             auto deliveryOptions = registration-&gt;deliveryOptions();
2255             auto result = observers.add(registration-&gt;observer(), deliveryOptions);
2256             if (!result.isNewEntry)
2257                 result.iterator-&gt;value |= deliveryOptions;
2258         }
2259     }
2260 }
2261 
2262 HashMap&lt;Ref&lt;MutationObserver&gt;, MutationRecordDeliveryOptions&gt; Node::registeredMutationObservers(MutationObserver::MutationType type, const QualifiedName* attributeName)
2263 {
2264     HashMap&lt;Ref&lt;MutationObserver&gt;, MutationRecordDeliveryOptions&gt; result;
2265     ASSERT((type == MutationObserver::Attributes &amp;&amp; attributeName) || !attributeName);
2266     collectMatchingObserversForMutation(result, mutationObserverRegistry(), *this, type, attributeName);
2267     collectMatchingObserversForMutation(result, transientMutationObserverRegistry(), *this, type, attributeName);
2268     for (Node* node = parentNode(); node; node = node-&gt;parentNode()) {
2269         collectMatchingObserversForMutation(result, node-&gt;mutationObserverRegistry(), *this, type, attributeName);
2270         collectMatchingObserversForMutation(result, node-&gt;transientMutationObserverRegistry(), *this, type, attributeName);
2271     }
2272     return result;
2273 }
2274 
<a name="39" id="anc39"></a><span class="line-modified">2275 void Node::registerMutationObserver(MutationObserver&amp; observer, MutationObserverOptions options, const HashSet&lt;AtomicString&gt;&amp; attributeFilter)</span>
2276 {
2277     MutationObserverRegistration* registration = nullptr;
2278     auto&amp; registry = ensureRareData().ensureMutationObserverData().registry;
2279 
2280     for (auto&amp; candidateRegistration : registry) {
2281         if (&amp;candidateRegistration-&gt;observer() == &amp;observer) {
2282             registration = candidateRegistration.get();
2283             registration-&gt;resetObservation(options, attributeFilter);
2284         }
2285     }
2286 
2287     if (!registration) {
<a name="40" id="anc40"></a><span class="line-modified">2288         registry.append(std::make_unique&lt;MutationObserverRegistration&gt;(observer, *this, options, attributeFilter));</span>
2289         registration = registry.last().get();
2290     }
2291 
2292     document().addMutationObserverTypes(registration-&gt;mutationTypes());
2293 }
2294 
2295 void Node::unregisterMutationObserver(MutationObserverRegistration&amp; registration)
2296 {
2297     auto* registry = mutationObserverRegistry();
2298     ASSERT(registry);
2299     if (!registry)
2300         return;
2301 
2302     registry-&gt;removeFirstMatching([&amp;registration] (auto&amp; current) {
2303         return current.get() == &amp;registration;
2304     });
2305 }
2306 
2307 void Node::registerTransientMutationObserver(MutationObserverRegistration&amp; registration)
2308 {
2309     ensureRareData().ensureMutationObserverData().transientRegistry.add(&amp;registration);
2310 }
2311 
2312 void Node::unregisterTransientMutationObserver(MutationObserverRegistration&amp; registration)
2313 {
2314     auto* transientRegistry = transientMutationObserverRegistry();
2315     ASSERT(transientRegistry);
2316     if (!transientRegistry)
2317         return;
2318 
2319     ASSERT(transientRegistry-&gt;contains(&amp;registration));
2320     transientRegistry-&gt;remove(&amp;registration);
2321 }
2322 
2323 void Node::notifyMutationObserversNodeWillDetach()
2324 {
2325     if (!document().hasMutationObservers())
2326         return;
2327 
2328     for (Node* node = parentNode(); node; node = node-&gt;parentNode()) {
2329         if (auto* registry = node-&gt;mutationObserverRegistry()) {
2330             for (auto&amp; registration : *registry)
2331                 registration-&gt;observedSubtreeNodeWillDetach(*this);
2332         }
2333         if (auto* transientRegistry = node-&gt;transientMutationObserverRegistry()) {
2334             for (auto* registration : *transientRegistry)
2335                 registration-&gt;observedSubtreeNodeWillDetach(*this);
2336         }
2337     }
2338 }
2339 
2340 void Node::handleLocalEvents(Event&amp; event, EventInvokePhase phase)
2341 {
2342     if (!hasEventTargetData())
2343         return;
2344 
2345     // FIXME: Should we deliver wheel events to disabled form controls or not?
2346     if (is&lt;Element&gt;(*this) &amp;&amp; downcast&lt;Element&gt;(*this).isDisabledFormControl() &amp;&amp; event.isMouseEvent() &amp;&amp; !event.isWheelEvent())
2347         return;
2348 
2349     fireEventListeners(event, phase);
2350 }
2351 
2352 void Node::dispatchScopedEvent(Event&amp; event)
2353 {
2354     EventDispatcher::dispatchScopedEvent(*this, event);
2355 }
2356 
2357 void Node::dispatchEvent(Event&amp; event)
2358 {
2359     EventDispatcher::dispatchEvent(*this, event);
2360 }
2361 
2362 void Node::dispatchSubtreeModifiedEvent()
2363 {
2364     if (isInShadowTree())
2365         return;
2366 
2367     ASSERT_WITH_SECURITY_IMPLICATION(ScriptDisallowedScope::InMainThread::isEventDispatchAllowedInSubtree(*this));
2368 
2369     if (!document().hasListenerType(Document::DOMSUBTREEMODIFIED_LISTENER))
2370         return;
<a name="41" id="anc41"></a><span class="line-modified">2371     const AtomicString&amp; subtreeModifiedEventName = eventNames().DOMSubtreeModifiedEvent;</span>
2372     if (!parentNode() &amp;&amp; !hasEventListeners(subtreeModifiedEventName))
2373         return;
2374 
2375     dispatchScopedEvent(MutationEvent::create(subtreeModifiedEventName, Event::CanBubble::Yes));
2376 }
2377 
2378 void Node::dispatchDOMActivateEvent(Event&amp; underlyingClickEvent)
2379 {
2380     ASSERT_WITH_SECURITY_IMPLICATION(ScriptDisallowedScope::InMainThread::isScriptAllowed());
2381     int detail = is&lt;UIEvent&gt;(underlyingClickEvent) ? downcast&lt;UIEvent&gt;(underlyingClickEvent).detail() : 0;
2382     auto event = UIEvent::create(eventNames().DOMActivateEvent, Event::CanBubble::Yes, Event::IsCancelable::Yes, Event::IsComposed::Yes, document().windowProxy(), detail);
2383     event-&gt;setUnderlyingEvent(&amp;underlyingClickEvent);
2384     dispatchScopedEvent(event);
2385     if (event-&gt;defaultHandled())
2386         underlyingClickEvent.setDefaultHandled();
2387 }
2388 
2389 bool Node::dispatchBeforeLoadEvent(const String&amp; sourceURL)
2390 {
2391     if (!document().hasListenerType(Document::BEFORELOAD_LISTENER))
2392         return true;
2393 
2394     Ref&lt;Node&gt; protectedThis(*this);
2395     auto event = BeforeLoadEvent::create(sourceURL);
2396     dispatchEvent(event);
2397     return !event-&gt;defaultPrevented();
2398 }
2399 
2400 void Node::dispatchInputEvent()
2401 {
2402     dispatchScopedEvent(Event::create(eventNames().inputEvent, Event::CanBubble::Yes, Event::IsCancelable::No, Event::IsComposed::Yes));
2403 }
2404 
2405 void Node::defaultEventHandler(Event&amp; event)
2406 {
2407     if (event.target() != this)
2408         return;
<a name="42" id="anc42"></a><span class="line-modified">2409     const AtomicString&amp; eventType = event.type();</span>
2410     if (eventType == eventNames().keydownEvent || eventType == eventNames().keypressEvent) {
2411         if (is&lt;KeyboardEvent&gt;(event)) {
2412             if (Frame* frame = document().frame())
2413                 frame-&gt;eventHandler().defaultKeyboardEventHandler(downcast&lt;KeyboardEvent&gt;(event));
2414         }
2415     } else if (eventType == eventNames().clickEvent) {
2416         dispatchDOMActivateEvent(event);
2417 #if ENABLE(CONTEXT_MENUS)
2418     } else if (eventType == eventNames().contextmenuEvent) {
2419         if (Frame* frame = document().frame())
2420             if (Page* page = frame-&gt;page())
2421                 page-&gt;contextMenuController().handleContextMenuEvent(event);
2422 #endif
2423     } else if (eventType == eventNames().textInputEvent) {
2424         if (is&lt;TextEvent&gt;(event)) {
2425             if (Frame* frame = document().frame())
2426                 frame-&gt;eventHandler().defaultTextInputEventHandler(downcast&lt;TextEvent&gt;(event));
2427         }
2428 #if ENABLE(PAN_SCROLLING)
2429     } else if (eventType == eventNames().mousedownEvent &amp;&amp; is&lt;MouseEvent&gt;(event)) {
2430         if (downcast&lt;MouseEvent&gt;(event).button() == MiddleButton) {
2431             if (enclosingLinkEventParentOrSelf())
2432                 return;
2433 
<a name="43" id="anc43"></a><span class="line-removed">2434             // Avoid that canBeScrolledAndHasScrollableArea changes render tree</span>
<span class="line-removed">2435             // structure.</span>
<span class="line-removed">2436             // FIXME: We should avoid synchronous layout if possible. We can</span>
<span class="line-removed">2437             // remove this synchronous layout if we avoid synchronous layout in</span>
<span class="line-removed">2438             // RenderTextControlSingleLine::scrollHeight</span>
<span class="line-removed">2439             document().updateLayoutIgnorePendingStylesheets();</span>
2440             RenderObject* renderer = this-&gt;renderer();
2441             while (renderer &amp;&amp; (!is&lt;RenderBox&gt;(*renderer) || !downcast&lt;RenderBox&gt;(*renderer).canBeScrolledAndHasScrollableArea()))
2442                 renderer = renderer-&gt;parent();
2443 
2444             if (renderer) {
2445                 if (Frame* frame = document().frame())
2446                     frame-&gt;eventHandler().startPanScrolling(downcast&lt;RenderBox&gt;(*renderer));
2447             }
2448         }
2449 #endif
2450     } else if (eventNames().isWheelEventType(eventType) &amp;&amp; is&lt;WheelEvent&gt;(event)) {
2451         // If we don&#39;t have a renderer, send the wheel event to the first node we find with a renderer.
2452         // This is needed for &lt;option&gt; and &lt;optgroup&gt; elements so that &lt;select&gt;s get a wheel scroll.
2453         Node* startNode = this;
2454         while (startNode &amp;&amp; !startNode-&gt;renderer())
2455             startNode = startNode-&gt;parentOrShadowHostNode();
2456 
2457         if (startNode &amp;&amp; startNode-&gt;renderer())
2458             if (Frame* frame = document().frame())
2459                 frame-&gt;eventHandler().defaultWheelEventHandler(startNode, downcast&lt;WheelEvent&gt;(event));
2460 #if ENABLE(TOUCH_EVENTS) &amp;&amp; PLATFORM(IOS_FAMILY)
<a name="44" id="anc44"></a><span class="line-modified">2461     } else if (is&lt;TouchEvent&gt;(event) &amp;&amp; eventNames().isTouchEventType(eventType)) {</span>









2462         RenderObject* renderer = this-&gt;renderer();
2463         while (renderer &amp;&amp; (!is&lt;RenderBox&gt;(*renderer) || !downcast&lt;RenderBox&gt;(*renderer).canBeScrolledAndHasScrollableArea()))
2464             renderer = renderer-&gt;parent();
2465 
2466         if (renderer &amp;&amp; renderer-&gt;node()) {
2467             if (Frame* frame = document().frame())
2468                 frame-&gt;eventHandler().defaultTouchEventHandler(*renderer-&gt;node(), downcast&lt;TouchEvent&gt;(event));
2469         }
2470 #endif
2471     }
2472 }
2473 
2474 bool Node::willRespondToMouseMoveEvents()
2475 {
2476     // FIXME: Why is the iOS code path different from the non-iOS code path?
2477 #if !PLATFORM(IOS_FAMILY)
2478     if (!is&lt;Element&gt;(*this))
2479         return false;
2480     if (downcast&lt;Element&gt;(*this).isDisabledFormControl())
2481         return false;
2482 #endif
2483     return hasEventListeners(eventNames().mousemoveEvent) || hasEventListeners(eventNames().mouseoverEvent) || hasEventListeners(eventNames().mouseoutEvent);
2484 }
2485 
2486 bool Node::willRespondToMouseClickEvents()
2487 {
2488     // FIXME: Why is the iOS code path different from the non-iOS code path?
2489 #if PLATFORM(IOS_FAMILY)
2490     return isContentEditable() || hasEventListeners(eventNames().mouseupEvent) || hasEventListeners(eventNames().mousedownEvent) || hasEventListeners(eventNames().clickEvent);
2491 #else
2492     if (!is&lt;Element&gt;(*this))
2493         return false;
2494     if (downcast&lt;Element&gt;(*this).isDisabledFormControl())
2495         return false;
2496     return computeEditability(UserSelectAllIsAlwaysNonEditable, ShouldUpdateStyle::Update) != Editability::ReadOnly
2497         || hasEventListeners(eventNames().mouseupEvent) || hasEventListeners(eventNames().mousedownEvent) || hasEventListeners(eventNames().clickEvent) || hasEventListeners(eventNames().DOMActivateEvent);
2498 #endif
2499 }
2500 
2501 bool Node::willRespondToMouseWheelEvents()
2502 {
2503     return hasEventListeners(eventNames().mousewheelEvent);
2504 }
2505 
2506 // It&#39;s important not to inline removedLastRef, because we don&#39;t want to inline the code to
2507 // delete a Node at each deref call site.
2508 void Node::removedLastRef()
2509 {
<a name="45" id="anc45"></a>

2510     // An explicit check for Document here is better than a virtual function since it is
2511     // faster for non-Document nodes, and because the call to removedLastRef that is inlined
2512     // at all deref call sites is smaller if it&#39;s a non-virtual function.
2513     if (is&lt;Document&gt;(*this)) {
2514         downcast&lt;Document&gt;(*this).removedLastRef();
2515         return;
2516     }
2517 
<a name="46" id="anc46"></a>





2518 #ifndef NDEBUG
2519     m_deletionHasBegun = true;
2520 #endif
<a name="47" id="anc47"></a><span class="line-removed">2521     m_refCount = 1; // Avoid double destruction through use of RefPtr&lt;T&gt;. (This is a security mitigation in case of programmer error. It will ASSERT in debug builds.)</span>
2522     delete this;
2523 }
2524 
2525 void Node::textRects(Vector&lt;IntRect&gt;&amp; rects) const
2526 {
2527     auto range = Range::create(document());
2528     range-&gt;selectNodeContents(const_cast&lt;Node&amp;&gt;(*this));
2529     range-&gt;absoluteTextRects(rects);
2530 }
2531 
2532 unsigned Node::connectedSubframeCount() const
2533 {
2534     return hasRareData() ? rareData()-&gt;connectedSubframeCount() : 0;
2535 }
2536 
2537 void Node::incrementConnectedSubframeCount(unsigned amount)
2538 {
2539     ASSERT(isContainerNode());
2540     ensureRareData().incrementConnectedSubframeCount(amount);
2541 }
2542 
2543 void Node::decrementConnectedSubframeCount(unsigned amount)
2544 {
<a name="48" id="anc48"></a>


2545     rareData()-&gt;decrementConnectedSubframeCount(amount);
2546 }
2547 
2548 void Node::updateAncestorConnectedSubframeCountForRemoval() const
2549 {
2550     unsigned count = connectedSubframeCount();
2551 
2552     if (!count)
2553         return;
2554 
2555     for (Node* node = parentOrShadowHostNode(); node; node = node-&gt;parentOrShadowHostNode())
2556         node-&gt;decrementConnectedSubframeCount(count);
2557 }
2558 
2559 void Node::updateAncestorConnectedSubframeCountForInsertion() const
2560 {
2561     unsigned count = connectedSubframeCount();
2562 
2563     if (!count)
2564         return;
2565 
2566     for (Node* node = parentOrShadowHostNode(); node; node = node-&gt;parentOrShadowHostNode())
2567         node-&gt;incrementConnectedSubframeCount(count);
2568 }
2569 
2570 bool Node::inRenderedDocument() const
2571 {
2572     return isConnected() &amp;&amp; document().hasLivingRenderTree();
2573 }
2574 
2575 void* Node::opaqueRootSlow() const
2576 {
2577     const Node* node = this;
2578     for (;;) {
2579         const Node* nextNode = node-&gt;parentOrShadowHostNode();
2580         if (!nextNode)
2581             break;
2582         node = nextNode;
2583     }
2584     return const_cast&lt;void*&gt;(static_cast&lt;const void*&gt;(node));
2585 }
2586 
2587 } // namespace WebCore
2588 
2589 #if ENABLE(TREE_DEBUGGING)
2590 
2591 void showTree(const WebCore::Node* node)
2592 {
2593     if (node)
2594         node-&gt;showTreeForThis();
2595 }
2596 
2597 void showNodePath(const WebCore::Node* node)
2598 {
2599     if (node)
2600         node-&gt;showNodePathForThis();
2601 }
2602 
2603 #endif // ENABLE(TREE_DEBUGGING)
<a name="49" id="anc49"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="49" type="hidden" />
</body>
</html>