<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/dom/Element.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
  3  *           (C) 1999 Antti Koivisto (koivisto@kde.org)
  4  *           (C) 2001 Peter Kelly (pmk@post.com)
  5  *           (C) 2001 Dirk Mueller (mueller@kde.org)
  6  * Copyright (C) 2003-2017 Apple Inc. All rights reserved.
  7  *
  8  * This library is free software; you can redistribute it and/or
  9  * modify it under the terms of the GNU Library General Public
 10  * License as published by the Free Software Foundation; either
 11  * version 2 of the License, or (at your option) any later version.
 12  *
 13  * This library is distributed in the hope that it will be useful,
 14  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 15  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 16  * Library General Public License for more details.
 17  *
 18  * You should have received a copy of the GNU Library General Public License
 19  * along with this library; see the file COPYING.LIB.  If not, write to
 20  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 21  * Boston, MA 02110-1301, USA.
 22  *
 23  */
 24 
 25 #pragma once
 26 
 27 #include &quot;AXTextStateChangeIntent.h&quot;
 28 #include &quot;Document.h&quot;
 29 #include &quot;ElementData.h&quot;
 30 #include &quot;HTMLNames.h&quot;
 31 #include &quot;KeyframeAnimationOptions.h&quot;
 32 #include &quot;ScrollToOptions.h&quot;
 33 #include &quot;ScrollTypes.h&quot;
 34 #include &quot;ShadowRootMode.h&quot;
 35 #include &quot;SimulatedClickOptions.h&quot;
 36 #include &quot;StyleChange.h&quot;
 37 
 38 namespace WebCore {
 39 
 40 class CustomElementReactionQueue;
 41 class DatasetDOMStringMap;
 42 class DOMRect;
 43 class DOMRectList;
 44 class DOMTokenList;
 45 class ElementRareData;
 46 class Frame;
 47 class HTMLDocument;
 48 class IntSize;
 49 class JSCustomElementInterface;
 50 class KeyboardEvent;
 51 class Locale;
 52 class PlatformKeyboardEvent;
 53 class PlatformMouseEvent;
 54 class PlatformWheelEvent;
 55 class PseudoElement;
 56 class RenderTreePosition;
 57 class StylePropertyMap;
 58 class WebAnimation;
 59 struct ElementStyle;
 60 struct ScrollIntoViewOptions;
 61 
 62 #if ENABLE(INTERSECTION_OBSERVER)
 63 struct IntersectionObserverData;
 64 #endif
 65 
<a name="1" id="anc1"></a>



 66 enum SpellcheckAttributeState {
 67     SpellcheckAttributeTrue,
 68     SpellcheckAttributeFalse,
 69     SpellcheckAttributeDefault
 70 };
 71 
<a name="2" id="anc2"></a><span class="line-removed"> 72 #if ENABLE(POINTER_EVENTS)</span>
<span class="line-removed"> 73 enum class TouchAction : uint8_t;</span>
<span class="line-removed"> 74 #endif</span>
<span class="line-removed"> 75 </span>
 76 class Element : public ContainerNode {
 77     WTF_MAKE_ISO_ALLOCATED(Element);
 78 public:
 79     static Ref&lt;Element&gt; create(const QualifiedName&amp;, Document&amp;);
 80     virtual ~Element();
 81 
 82     WEBCORE_EXPORT bool hasAttribute(const QualifiedName&amp;) const;
<a name="3" id="anc3"></a><span class="line-modified"> 83     WEBCORE_EXPORT const AtomicString&amp; getAttribute(const QualifiedName&amp;) const;</span>
 84     template&lt;typename... QualifiedNames&gt;
<a name="4" id="anc4"></a><span class="line-modified"> 85     const AtomicString&amp; getAttribute(const QualifiedName&amp;, const QualifiedNames&amp;...) const;</span>
<span class="line-modified"> 86     WEBCORE_EXPORT void setAttribute(const QualifiedName&amp;, const AtomicString&amp; value);</span>
<span class="line-modified"> 87     WEBCORE_EXPORT void setAttributeWithoutSynchronization(const QualifiedName&amp;, const AtomicString&amp; value);</span>
<span class="line-modified"> 88     void setSynchronizedLazyAttribute(const QualifiedName&amp;, const AtomicString&amp; value);</span>
 89     bool removeAttribute(const QualifiedName&amp;);
 90     Vector&lt;String&gt; getAttributeNames() const;
 91 
 92     // Typed getters and setters for language bindings.
 93     WEBCORE_EXPORT int getIntegralAttribute(const QualifiedName&amp; attributeName) const;
 94     WEBCORE_EXPORT void setIntegralAttribute(const QualifiedName&amp; attributeName, int value);
 95     WEBCORE_EXPORT unsigned getUnsignedIntegralAttribute(const QualifiedName&amp; attributeName) const;
 96     WEBCORE_EXPORT void setUnsignedIntegralAttribute(const QualifiedName&amp; attributeName, unsigned value);
 97 
 98     // Call this to get the value of an attribute that is known not to be the style
 99     // attribute or one of the SVG animatable attributes.
100     bool hasAttributeWithoutSynchronization(const QualifiedName&amp;) const;
<a name="5" id="anc5"></a><span class="line-modified">101     const AtomicString&amp; attributeWithoutSynchronization(const QualifiedName&amp;) const;</span>
102 #ifndef NDEBUG
103     WEBCORE_EXPORT bool fastAttributeLookupAllowed(const QualifiedName&amp;) const;
104 #endif
105 
106 #if DUMP_NODE_STATISTICS
107     bool hasNamedNodeMap() const;
108 #endif
109     WEBCORE_EXPORT bool hasAttributes() const;
110     // This variant will not update the potentially invalid attributes. To be used when not interested
111     // in style attribute or one of the SVG animation attributes.
112     bool hasAttributesWithoutUpdate() const;
113 
<a name="6" id="anc6"></a><span class="line-modified">114     WEBCORE_EXPORT bool hasAttribute(const AtomicString&amp; qualifiedName) const;</span>
<span class="line-modified">115     WEBCORE_EXPORT bool hasAttributeNS(const AtomicString&amp; namespaceURI, const AtomicString&amp; localName) const;</span>
116 
<a name="7" id="anc7"></a><span class="line-modified">117     WEBCORE_EXPORT const AtomicString&amp; getAttribute(const AtomicString&amp; qualifiedName) const;</span>
<span class="line-modified">118     WEBCORE_EXPORT const AtomicString&amp; getAttributeNS(const AtomicString&amp; namespaceURI, const AtomicString&amp; localName) const;</span>
119 
<a name="8" id="anc8"></a><span class="line-modified">120     WEBCORE_EXPORT ExceptionOr&lt;void&gt; setAttribute(const AtomicString&amp; qualifiedName, const AtomicString&amp; value);</span>
<span class="line-modified">121     static ExceptionOr&lt;QualifiedName&gt; parseAttributeName(const AtomicString&amp; namespaceURI, const AtomicString&amp; qualifiedName);</span>
<span class="line-modified">122     WEBCORE_EXPORT ExceptionOr&lt;void&gt; setAttributeNS(const AtomicString&amp; namespaceURI, const AtomicString&amp; qualifiedName, const AtomicString&amp; value);</span>
123 
<a name="9" id="anc9"></a><span class="line-modified">124     ExceptionOr&lt;bool&gt; toggleAttribute(const AtomicString&amp; qualifiedName, Optional&lt;bool&gt; force);</span>
125 
<a name="10" id="anc10"></a><span class="line-modified">126     const AtomicString&amp; getIdAttribute() const;</span>
<span class="line-modified">127     void setIdAttribute(const AtomicString&amp;);</span>
128 
<a name="11" id="anc11"></a><span class="line-modified">129     const AtomicString&amp; getNameAttribute() const;</span>
130 
131     // Call this to get the value of the id attribute for style resolution purposes.
132     // The value will already be lowercased if the document is in compatibility mode,
133     // so this function is not suitable for non-style uses.
<a name="12" id="anc12"></a><span class="line-modified">134     const AtomicString&amp; idForStyleResolution() const;</span>
135 
136     // Internal methods that assume the existence of attribute storage, one should use hasAttributes()
137     // before calling them.
138     AttributeIteratorAccessor attributesIterator() const { return elementData()-&gt;attributesIterator(); }
139     unsigned attributeCount() const;
140     const Attribute&amp; attributeAt(unsigned index) const;
141     const Attribute* findAttributeByName(const QualifiedName&amp;) const;
142     unsigned findAttributeIndexByName(const QualifiedName&amp; name) const { return elementData()-&gt;findAttributeIndexByName(name); }
<a name="13" id="anc13"></a><span class="line-modified">143     unsigned findAttributeIndexByName(const AtomicString&amp; name, bool shouldIgnoreAttributeCase) const { return elementData()-&gt;findAttributeIndexByName(name, shouldIgnoreAttributeCase); }</span>
144 
145     WEBCORE_EXPORT void scrollIntoView(Optional&lt;Variant&lt;bool, ScrollIntoViewOptions&gt;&gt;&amp;&amp; arg);
146     WEBCORE_EXPORT void scrollIntoView(bool alignToTop = true);
147     WEBCORE_EXPORT void scrollIntoViewIfNeeded(bool centerIfNeeded = true);
148     WEBCORE_EXPORT void scrollIntoViewIfNotVisible(bool centerIfNotVisible = true);
149 
150     void scrollBy(const ScrollToOptions&amp;);
151     void scrollBy(double x, double y);
152     virtual void scrollTo(const ScrollToOptions&amp;, ScrollClamping = ScrollClamping::Clamped);
153     void scrollTo(double x, double y);
154 
155     WEBCORE_EXPORT void scrollByLines(int lines);
156     WEBCORE_EXPORT void scrollByPages(int pages);
157 
158     WEBCORE_EXPORT double offsetLeftForBindings();
159     WEBCORE_EXPORT double offsetLeft();
160     WEBCORE_EXPORT double offsetTopForBindings();
161     WEBCORE_EXPORT double offsetTop();
162     WEBCORE_EXPORT double offsetWidth();
163     WEBCORE_EXPORT double offsetHeight();
164 
165     bool mayCauseRepaintInsideViewport(const IntRect* visibleRect = nullptr) const;
166 
167     // FIXME: Replace uses of offsetParent in the platform with calls
168     // to the render layer and merge bindingsOffsetParent and offsetParent.
169     WEBCORE_EXPORT Element* offsetParentForBindings();
170 
171     const Element* rootElement() const;
172 
173     Element* offsetParent();
174     WEBCORE_EXPORT double clientLeft();
175     WEBCORE_EXPORT double clientTop();
176     WEBCORE_EXPORT double clientWidth();
177     WEBCORE_EXPORT double clientHeight();
178 
179     virtual int scrollLeft();
180     virtual int scrollTop();
181     virtual void setScrollLeft(int);
182     virtual void setScrollTop(int);
183     virtual int scrollWidth();
184     virtual int scrollHeight();
185 
186     WEBCORE_EXPORT IntRect boundsInRootViewSpace();
187 
<a name="14" id="anc14"></a>

188     WEBCORE_EXPORT FloatRect boundingClientRect();
189 
190     WEBCORE_EXPORT Ref&lt;DOMRectList&gt; getClientRects();
191     Ref&lt;DOMRect&gt; getBoundingClientRect();
192 
193     // Returns the absolute bounding box translated into client coordinates.
194     WEBCORE_EXPORT IntRect clientRect() const;
195     // Returns the absolute bounding box translated into screen coordinates.
196     WEBCORE_EXPORT IntRect screenRect() const;
197 
<a name="15" id="anc15"></a><span class="line-modified">198     WEBCORE_EXPORT bool removeAttribute(const AtomicString&amp; qualifiedName);</span>
<span class="line-modified">199     WEBCORE_EXPORT bool removeAttributeNS(const AtomicString&amp; namespaceURI, const AtomicString&amp; localName);</span>
200 
201     Ref&lt;Attr&gt; detachAttribute(unsigned index);
202 
<a name="16" id="anc16"></a><span class="line-modified">203     WEBCORE_EXPORT RefPtr&lt;Attr&gt; getAttributeNode(const AtomicString&amp; qualifiedName);</span>
<span class="line-modified">204     WEBCORE_EXPORT RefPtr&lt;Attr&gt; getAttributeNodeNS(const AtomicString&amp; namespaceURI, const AtomicString&amp; localName);</span>
205     WEBCORE_EXPORT ExceptionOr&lt;RefPtr&lt;Attr&gt;&gt; setAttributeNode(Attr&amp;);
206     WEBCORE_EXPORT ExceptionOr&lt;RefPtr&lt;Attr&gt;&gt; setAttributeNodeNS(Attr&amp;);
207     WEBCORE_EXPORT ExceptionOr&lt;Ref&lt;Attr&gt;&gt; removeAttributeNode(Attr&amp;);
208 
209     RefPtr&lt;Attr&gt; attrIfExists(const QualifiedName&amp;);
<a name="17" id="anc17"></a><span class="line-modified">210     RefPtr&lt;Attr&gt; attrIfExists(const AtomicString&amp; localName, bool shouldIgnoreAttributeCase);</span>
211     Ref&lt;Attr&gt; ensureAttr(const QualifiedName&amp;);
212 
213     const Vector&lt;RefPtr&lt;Attr&gt;&gt;&amp; attrNodeList();
214 
215     const QualifiedName&amp; tagQName() const { return m_tagName; }
216 #if ENABLE(JIT)
217     static ptrdiff_t tagQNameMemoryOffset() { return OBJECT_OFFSETOF(Element, m_tagName); }
218 #endif // ENABLE(JIT)
219     String tagName() const { return nodeName(); }
220     bool hasTagName(const QualifiedName&amp; tagName) const { return m_tagName.matches(tagName); }
221     bool hasTagName(const HTMLQualifiedName&amp; tagName) const { return ContainerNode::hasTagName(tagName); }
222     bool hasTagName(const MathMLQualifiedName&amp; tagName) const { return ContainerNode::hasTagName(tagName); }
223     bool hasTagName(const SVGQualifiedName&amp; tagName) const { return ContainerNode::hasTagName(tagName); }
224 
225     // A fast function for checking the local name against another atomic string.
<a name="18" id="anc18"></a><span class="line-modified">226     bool hasLocalName(const AtomicString&amp; other) const { return m_tagName.localName() == other; }</span>
227 
<a name="19" id="anc19"></a><span class="line-modified">228     const AtomicString&amp; localName() const final { return m_tagName.localName(); }</span>
<span class="line-modified">229     const AtomicString&amp; prefix() const final { return m_tagName.prefix(); }</span>
<span class="line-modified">230     const AtomicString&amp; namespaceURI() const final { return m_tagName.namespaceURI(); }</span>
231 
<a name="20" id="anc20"></a><span class="line-modified">232     ExceptionOr&lt;void&gt; setPrefix(const AtomicString&amp;) final;</span>
233 
234     String nodeName() const override;
235 
236     Ref&lt;Element&gt; cloneElementWithChildren(Document&amp;);
237     Ref&lt;Element&gt; cloneElementWithoutChildren(Document&amp;);
238 
239     void normalizeAttributes();
240     String nodeNamePreservingCase() const;
241 
242     WEBCORE_EXPORT void setBooleanAttribute(const QualifiedName&amp; name, bool);
243 
244     // For exposing to DOM only.
245     WEBCORE_EXPORT NamedNodeMap&amp; attributes() const;
246 
247     enum AttributeModificationReason {
248         ModifiedDirectly,
249         ModifiedByCloning
250     };
251 
252     // This method is called whenever an attribute is added, changed or removed.
<a name="21" id="anc21"></a><span class="line-modified">253     virtual void attributeChanged(const QualifiedName&amp;, const AtomicString&amp; oldValue, const AtomicString&amp; newValue, AttributeModificationReason = ModifiedDirectly);</span>
<span class="line-modified">254     virtual void parseAttribute(const QualifiedName&amp;, const AtomicString&amp;) { }</span>
255 
256     // Only called by the parser immediately after element construction.
257     void parserSetAttributes(const Vector&lt;Attribute&gt;&amp;);
258 
259     bool isEventHandlerAttribute(const Attribute&amp;) const;
260     bool isJavaScriptURLAttribute(const Attribute&amp;) const;
261 
262     // Remove attributes that might introduce scripting from the vector leaving the element unchanged.
263     void stripScriptingAttributes(Vector&lt;Attribute&gt;&amp;) const;
264 
265     const ElementData* elementData() const { return m_elementData.get(); }
266     static ptrdiff_t elementDataMemoryOffset() { return OBJECT_OFFSETOF(Element, m_elementData); }
267     UniqueElementData&amp; ensureUniqueElementData();
268 
269     void synchronizeAllAttributes() const;
270 
271     // Clones attributes only.
272     void cloneAttributesFromElement(const Element&amp;);
273 
274     // Clones all attribute-derived data, including subclass specifics (through copyNonAttributeProperties.)
275     void cloneDataFromElement(const Element&amp;);
276 
277     virtual void didMoveToNewDocument(Document&amp; oldDocument, Document&amp; newDocument);
278 
279     bool hasEquivalentAttributes(const Element&amp; other) const;
280 
281     virtual void copyNonAttributePropertiesFromElement(const Element&amp;) { }
282 
283     virtual RenderPtr&lt;RenderElement&gt; createElementRenderer(RenderStyle&amp;&amp;, const RenderTreePosition&amp;);
284     virtual bool rendererIsNeeded(const RenderStyle&amp;);
285 
286     WEBCORE_EXPORT ShadowRoot* shadowRoot() const;
287     ShadowRoot* shadowRootForBindings(JSC::ExecState&amp;) const;
288 
289     struct ShadowRootInit {
290         ShadowRootMode mode;
291     };
292     ExceptionOr&lt;ShadowRoot&amp;&gt; attachShadow(const ShadowRootInit&amp;);
293 
294     RefPtr&lt;ShadowRoot&gt; userAgentShadowRoot() const;
295     WEBCORE_EXPORT ShadowRoot&amp; ensureUserAgentShadowRoot();
296 
297     void setIsDefinedCustomElement(JSCustomElementInterface&amp;);
298     void setIsFailedCustomElement(JSCustomElementInterface&amp;);
299     void setIsCustomElementUpgradeCandidate();
300     void enqueueToUpgrade(JSCustomElementInterface&amp;);
301     CustomElementReactionQueue* reactionQueue() const;
302 
303     // FIXME: this should not be virtual, do not override this.
<a name="22" id="anc22"></a><span class="line-modified">304     virtual const AtomicString&amp; shadowPseudoId() const;</span>
305 
306     bool isInActiveChain() const { return isUserActionElement() &amp;&amp; isUserActionElementInActiveChain(); }
307     bool active() const { return isUserActionElement() &amp;&amp; isUserActionElementActive(); }
308     bool hovered() const { return isUserActionElement() &amp;&amp; isUserActionElementHovered(); }
309     bool focused() const { return isUserActionElement() &amp;&amp; isUserActionElementFocused(); }
310     bool hasFocusWithin() const { return getFlag(HasFocusWithin); };
311 
312     virtual void setActive(bool flag = true, bool pause = false);
313     virtual void setHovered(bool flag = true);
314     virtual void setFocus(bool flag);
315     void setHasFocusWithin(bool flag);
316 
<a name="23" id="anc23"></a><span class="line-modified">317     bool tabIndexSetExplicitly() const;</span>

318     virtual bool supportsFocus() const;
319     virtual bool isFocusable() const;
320     virtual bool isKeyboardFocusable(KeyboardEvent*) const;
321     virtual bool isMouseFocusable() const;
322 
323     virtual bool shouldUseInputMethod();
324 
<a name="24" id="anc24"></a><span class="line-modified">325     virtual int tabIndex() const;</span>
<span class="line-modified">326     WEBCORE_EXPORT void setTabIndex(int);</span>
327     virtual RefPtr&lt;Element&gt; focusDelegate();
328 
329     ExceptionOr&lt;void&gt; insertAdjacentHTML(const String&amp; where, const String&amp; html, NodeVector* addedNodes);
330 
331     WEBCORE_EXPORT ExceptionOr&lt;Element*&gt; insertAdjacentElement(const String&amp; where, Element&amp; newChild);
332     WEBCORE_EXPORT ExceptionOr&lt;void&gt; insertAdjacentHTML(const String&amp; where, const String&amp; html);
333     WEBCORE_EXPORT ExceptionOr&lt;void&gt; insertAdjacentText(const String&amp; where, const String&amp; text);
334 
335     const RenderStyle* computedStyle(PseudoId = PseudoId::None) override;
336 
337     bool needsStyleInvalidation() const;
338 
339     // Methods for indicating the style is affected by dynamic updates (e.g., children changing, our position changing in our sibling list, etc.)
<a name="25" id="anc25"></a><span class="line-modified">340     bool styleAffectedByActive() const { return hasRareData() &amp;&amp; rareDataStyleAffectedByActive(); }</span>
<span class="line-modified">341     bool styleAffectedByEmpty() const { return hasRareData() &amp;&amp; rareDataStyleAffectedByEmpty(); }</span>
<span class="line-modified">342     bool styleAffectedByFocusWithin() const { return hasRareData() &amp;&amp; rareDataStyleAffectedByFocusWithin(); }</span>
343     bool descendantsAffectedByPreviousSibling() const { return getFlag(DescendantsAffectedByPreviousSiblingFlag); }
344     bool childrenAffectedByHover() const { return getFlag(ChildrenAffectedByHoverRulesFlag); }
<a name="26" id="anc26"></a><span class="line-modified">345     bool childrenAffectedByDrag() const { return hasRareData() &amp;&amp; rareDataChildrenAffectedByDrag(); }</span>
346     bool childrenAffectedByFirstChildRules() const { return getFlag(ChildrenAffectedByFirstChildRulesFlag); }
347     bool childrenAffectedByLastChildRules() const { return getFlag(ChildrenAffectedByLastChildRulesFlag); }
<a name="27" id="anc27"></a><span class="line-modified">348     bool childrenAffectedByForwardPositionalRules() const { return hasRareData() &amp;&amp; rareDataChildrenAffectedByForwardPositionalRules(); }</span>
<span class="line-modified">349     bool descendantsAffectedByForwardPositionalRules() const { return hasRareData() &amp;&amp; rareDataDescendantsAffectedByForwardPositionalRules(); }</span>
<span class="line-modified">350     bool childrenAffectedByBackwardPositionalRules() const { return hasRareData() &amp;&amp; rareDataChildrenAffectedByBackwardPositionalRules(); }</span>
<span class="line-modified">351     bool descendantsAffectedByBackwardPositionalRules() const { return hasRareData() &amp;&amp; rareDataDescendantsAffectedByBackwardPositionalRules(); }</span>
<span class="line-modified">352     bool childrenAffectedByPropertyBasedBackwardPositionalRules() const { return hasRareData() &amp;&amp; rareDataChildrenAffectedByPropertyBasedBackwardPositionalRules(); }</span>
353     bool affectsNextSiblingElementStyle() const { return getFlag(AffectsNextSiblingElementStyle); }
354     unsigned childIndex() const { return hasRareData() ? rareDataChildIndex() : 0; }
355 
356     bool hasFlagsSetDuringStylingOfChildren() const;
357 
<a name="28" id="anc28"></a><span class="line-modified">358     void setStyleAffectedByEmpty();</span>
<span class="line-modified">359     void setStyleAffectedByFocusWithin();</span>
<span class="line-modified">360     void setDescendantsAffectedByPreviousSibling() const { return setFlag(DescendantsAffectedByPreviousSiblingFlag); }</span>
361     void setChildrenAffectedByHover() { setFlag(ChildrenAffectedByHoverRulesFlag); }
<a name="29" id="anc29"></a><span class="line-modified">362     void setStyleAffectedByActive();</span>
<span class="line-modified">363     void setChildrenAffectedByDrag();</span>
364     void setChildrenAffectedByFirstChildRules() { setFlag(ChildrenAffectedByFirstChildRulesFlag); }
365     void setChildrenAffectedByLastChildRules() { setFlag(ChildrenAffectedByLastChildRulesFlag); }
<a name="30" id="anc30"></a><span class="line-modified">366     void setChildrenAffectedByForwardPositionalRules();</span>
<span class="line-modified">367     void setDescendantsAffectedByForwardPositionalRules();</span>
<span class="line-modified">368     void setChildrenAffectedByBackwardPositionalRules();</span>
<span class="line-modified">369     void setDescendantsAffectedByBackwardPositionalRules();</span>
<span class="line-modified">370     void setChildrenAffectedByPropertyBasedBackwardPositionalRules();</span>
371     void setAffectsNextSiblingElementStyle() { setFlag(AffectsNextSiblingElementStyle); }
372     void setStyleIsAffectedByPreviousSibling() { setFlag(StyleIsAffectedByPreviousSibling); }
373     void setChildIndex(unsigned);
374 
<a name="31" id="anc31"></a><span class="line-modified">375     WEBCORE_EXPORT AtomicString computeInheritedLanguage() const;</span>
376     Locale&amp; locale() const;
377 
378     virtual void accessKeyAction(bool /*sendToAnyEvent*/) { }
379 
380     virtual bool isURLAttribute(const Attribute&amp;) const { return false; }
381     virtual bool attributeContainsURL(const Attribute&amp; attribute) const { return isURLAttribute(attribute); }
382     virtual String completeURLsInAttributeValue(const URL&amp; base, const Attribute&amp;) const;
383     virtual bool isHTMLContentAttribute(const Attribute&amp;) const { return false; }
384 
385     WEBCORE_EXPORT URL getURLAttribute(const QualifiedName&amp;) const;
386     URL getNonEmptyURLAttribute(const QualifiedName&amp;) const;
387 
<a name="32" id="anc32"></a><span class="line-modified">388     virtual const AtomicString&amp; imageSourceURL() const;</span>
389     virtual String target() const { return String(); }
390 
391     static AXTextStateChangeIntent defaultFocusTextStateChangeIntent() { return AXTextStateChangeIntent(AXTextStateChangeTypeSelectionMove, AXTextSelection { AXTextSelectionDirectionDiscontiguous, AXTextSelectionGranularityUnknown, true }); }
392     virtual void focus(bool restorePreviousSelection = true, FocusDirection = FocusDirectionNone);
393     virtual RefPtr&lt;Element&gt; focusAppearanceUpdateTarget();
394     virtual void updateFocusAppearance(SelectionRestorationMode, SelectionRevealMode = SelectionRevealMode::Reveal);
395     virtual void blur();
396 
397     WEBCORE_EXPORT String innerHTML() const;
398     WEBCORE_EXPORT String outerHTML() const;
399     WEBCORE_EXPORT ExceptionOr&lt;void&gt; setInnerHTML(const String&amp;);
400     WEBCORE_EXPORT ExceptionOr&lt;void&gt; setOuterHTML(const String&amp;);
401     WEBCORE_EXPORT String innerText();
402     WEBCORE_EXPORT String outerText();
403 
404     virtual String title() const;
405 
<a name="33" id="anc33"></a><span class="line-modified">406     const AtomicString&amp; pseudo() const;</span>
<span class="line-modified">407     WEBCORE_EXPORT void setPseudo(const AtomicString&amp;);</span>
408 
409     LayoutSize minimumSizeForResizing() const;
410     void setMinimumSizeForResizing(const LayoutSize&amp;);
411 
412     // Use Document::registerForDocumentActivationCallbacks() to subscribe to these
413     virtual void prepareForDocumentSuspension() { }
414     virtual void resumeFromDocumentSuspension() { }
415 
416     // Use Document::registerForMediaVolumeCallbacks() to subscribe to this
417     virtual void mediaVolumeDidChange() { }
418 
419     // Use Document::registerForPrivateBrowsingStateChangedCallbacks() to subscribe to this.
<a name="34" id="anc34"></a><span class="line-modified">420     virtual void privateBrowsingStateDidChange() { }</span>
421 
422     virtual void willBecomeFullscreenElement();
423     virtual void ancestorWillEnterFullscreen() { }
424     virtual void didBecomeFullscreenElement() { }
425     virtual void willStopBeingFullscreenElement() { }
426 
427 #if ENABLE(VIDEO_TRACK)
428     virtual void captionPreferencesChanged() { }
429 #endif
430 
431     bool isFinishedParsingChildren() const { return isParsingChildrenFinished(); }
432     void finishParsingChildren() override;
433     void beginParsingChildren() final;
434 
435     WEBCORE_EXPORT PseudoElement* beforePseudoElement() const;
436     WEBCORE_EXPORT PseudoElement* afterPseudoElement() const;
437     bool childNeedsShadowWalker() const;
438     void didShadowTreeAwareChildrenChange();
439 
440     virtual bool matchesValidPseudoClass() const;
441     virtual bool matchesInvalidPseudoClass() const;
442     virtual bool matchesReadWritePseudoClass() const;
443     virtual bool matchesIndeterminatePseudoClass() const;
444     virtual bool matchesDefaultPseudoClass() const;
445     WEBCORE_EXPORT ExceptionOr&lt;bool&gt; matches(const String&amp; selectors);
446     WEBCORE_EXPORT ExceptionOr&lt;Element*&gt; closest(const String&amp; selectors);
447     virtual bool shouldAppearIndeterminate() const;
448 
449     WEBCORE_EXPORT DOMTokenList&amp; classList();
450 
451     DatasetDOMStringMap&amp; dataset();
452 
453 #if ENABLE(VIDEO)
454     virtual bool isMediaElement() const { return false; }
455 #endif
456 
457     virtual bool isFormControlElement() const { return false; }
458     virtual bool isSpinButtonElement() const { return false; }
459     virtual bool isTextFormControlElement() const { return false; }
460     virtual bool isTextField() const { return false; }
461     virtual bool isOptionalFormControl() const { return false; }
462     virtual bool isRequiredFormControl() const { return false; }
463     virtual bool isInRange() const { return false; }
464     virtual bool isOutOfRange() const { return false; }
<a name="35" id="anc35"></a><span class="line-removed">465     virtual bool isFrameElementBase() const { return false; }</span>
466     virtual bool isUploadButton() const { return false; }
467     virtual bool isSliderContainerElement() const { return false; }
468 
469     bool canContainRangeEndPoint() const override;
470 
471     // Used for disabled form elements; if true, prevents mouse events from being dispatched
472     // to event listeners, and prevents DOMActivate events from being sent at all.
473     virtual bool isDisabledFormControl() const { return false; }
474 
475     virtual bool childShouldCreateRenderer(const Node&amp;) const;
476 
477     bool hasPendingResources() const;
478     void setHasPendingResources();
479     void clearHasPendingResources();
480     virtual void buildPendingResource() { };
481 
482     bool hasCSSAnimation() const;
483     void setHasCSSAnimation();
484     void clearHasCSSAnimation();
485 
486 #if ENABLE(FULLSCREEN_API)
487     WEBCORE_EXPORT bool containsFullScreenElement() const;
488     void setContainsFullScreenElement(bool);
489     void setContainsFullScreenElementOnAncestorsCrossingFrameBoundaries(bool);
490     WEBCORE_EXPORT virtual void webkitRequestFullscreen();
491 #endif
492 
493 #if ENABLE(POINTER_EVENTS)
494     ExceptionOr&lt;void&gt; setPointerCapture(int32_t);
495     ExceptionOr&lt;void&gt; releasePointerCapture(int32_t);
496     bool hasPointerCapture(int32_t);
497 #endif
498 
499 #if ENABLE(POINTER_LOCK)
500     WEBCORE_EXPORT void requestPointerLock();
501 #endif
502 
503     bool isSpellCheckingEnabled() const;
504 
505     bool hasID() const;
506     bool hasClass() const;
507     bool hasName() const;
508     const SpaceSplitString&amp; classNames() const;
509 
510     IntPoint savedLayerScrollPosition() const;
511     void setSavedLayerScrollPosition(const IntPoint&amp;);
512 
<a name="36" id="anc36"></a><span class="line-modified">513     bool dispatchMouseEvent(const PlatformMouseEvent&amp;, const AtomicString&amp; eventType, int clickCount = 0, Element* relatedTarget = nullptr);</span>
514     bool dispatchWheelEvent(const PlatformWheelEvent&amp;);
515     bool dispatchKeyEvent(const PlatformKeyboardEvent&amp;);
516     void dispatchSimulatedClick(Event* underlyingEvent, SimulatedClickMouseEventOptions = SendNoEvents, SimulatedClickVisualOptions = ShowPressedLook);
<a name="37" id="anc37"></a><span class="line-modified">517     void dispatchFocusInEvent(const AtomicString&amp; eventType, RefPtr&lt;Element&gt;&amp;&amp; oldFocusedElement);</span>
<span class="line-modified">518     void dispatchFocusOutEvent(const AtomicString&amp; eventType, RefPtr&lt;Element&gt;&amp;&amp; newFocusedElement);</span>
519     virtual void dispatchFocusEvent(RefPtr&lt;Element&gt;&amp;&amp; oldFocusedElement, FocusDirection);
520     virtual void dispatchBlurEvent(RefPtr&lt;Element&gt;&amp;&amp; newFocusedElement);
521     void dispatchWebKitImageReadyEventForTesting();
522 
523     WEBCORE_EXPORT bool dispatchMouseForceWillBegin();
524 
525     virtual void willRecalcStyle(Style::Change);
526     virtual void didRecalcStyle(Style::Change);
527     virtual void willResetComputedStyle();
528     virtual void willAttachRenderers();
529     virtual void didAttachRenderers();
530     virtual void willDetachRenderers();
531     virtual void didDetachRenderers();
532     virtual Optional&lt;ElementStyle&gt; resolveCustomStyle(const RenderStyle&amp; parentStyle, const RenderStyle* shadowHostStyle);
533 
534     LayoutRect absoluteEventHandlerBounds(bool&amp; includesFixedPositionElements) override;
535 
536     const RenderStyle* existingComputedStyle() const;
<a name="38" id="anc38"></a><span class="line-modified">537     const RenderStyle* renderOrDisplayContentsStyle() const;</span>
538 
539     void setBeforePseudoElement(Ref&lt;PseudoElement&gt;&amp;&amp;);
540     void setAfterPseudoElement(Ref&lt;PseudoElement&gt;&amp;&amp;);
541     void clearBeforePseudoElement();
542     void clearAfterPseudoElement();
543     void resetComputedStyle();
544     void resetStyleRelations();
545     void clearHoverAndActiveStatusBeforeDetachingRenderer();
546 
547     WEBCORE_EXPORT URL absoluteLinkURL() const;
548 
549 #if ENABLE(TOUCH_EVENTS)
550     bool allowsDoubleTapGesture() const override;
551 #endif
552 
553     StyleResolver&amp; styleResolver();
554     ElementStyle resolveStyle(const RenderStyle* parentStyle);
555 
556     // Invalidates the style of a single element. Style is resolved lazily.
557     // Descendant elements are resolved as needed, for example if an inherited property changes.
558     // This should be called whenever an element changes in a manner that can affect its style.
559     void invalidateStyle();
560 
561     // As above but also call RenderElement::setStyle with StyleDifference::RecompositeLayer flag for
562     // the element even when the style doesn&#39;t change. This is mostly needed by the animation code.
563     WEBCORE_EXPORT void invalidateStyleAndLayerComposition();
564 
565     // Invalidate the element and all its descendants. This is used when there is some sort of change
566     // in the tree that may affect the style of any of the descendants and we don&#39;t know how to optimize
567     // the case to limit the scope. This is expensive and should be avoided.
568     void invalidateStyleForSubtree();
569 
570     // Invalidates renderers for the element and all its descendants causing them to be torn down
571     // and rebuild during style resolution. Style is also recomputed. This is used in code dealing with
572     // custom (not style based) renderers. This is expensive and should be avoided.
573     // Elements newly added to the tree are also in this state.
574     void invalidateStyleAndRenderersForSubtree();
575 
576     void invalidateStyleInternal();
577     void invalidateStyleForSubtreeInternal();
578 
579     bool hasDisplayContents() const;
580     void storeDisplayContentsStyle(std::unique_ptr&lt;RenderStyle&gt;);
581 
582     using ContainerNode::setAttributeEventListener;
<a name="39" id="anc39"></a><span class="line-modified">583     void setAttributeEventListener(const AtomicString&amp; eventType, const QualifiedName&amp; attributeName, const AtomicString&amp; value);</span>
584 
585 #if ENABLE(INTERSECTION_OBSERVER)
586     IntersectionObserverData&amp; ensureIntersectionObserverData();
587     IntersectionObserverData* intersectionObserverData();
588 #endif
589 
<a name="40" id="anc40"></a>




590     Element* findAnchorElementForLink(String&amp; outAnchorName);
591 
592     ExceptionOr&lt;Ref&lt;WebAnimation&gt;&gt; animate(JSC::ExecState&amp;, JSC::Strong&lt;JSC::JSObject&gt;&amp;&amp;, Optional&lt;Variant&lt;double, KeyframeAnimationOptions&gt;&gt;&amp;&amp;);
593     Vector&lt;RefPtr&lt;WebAnimation&gt;&gt; getAnimations();
594 
<a name="41" id="anc41"></a><span class="line-modified">595 #if ENABLE(POINTER_EVENTS)</span>
<span class="line-removed">596     OptionSet&lt;TouchAction&gt; computedTouchActions() const;</span>
<span class="line-removed">597 #if ENABLE(ACCELERATED_OVERFLOW_SCROLLING)</span>
<span class="line-removed">598     ScrollingNodeID nearestScrollingNodeIDUsingTouchOverflowScrolling() const;</span>
<span class="line-removed">599 #endif</span>
<span class="line-removed">600 #endif</span>
601 
602 protected:
603     Element(const QualifiedName&amp;, Document&amp;, ConstructionType);
604 
605     InsertedIntoAncestorResult insertedIntoAncestor(InsertionType, ContainerNode&amp;) override;
606     void removedFromAncestor(RemovalType, ContainerNode&amp;) override;
607     void childrenChanged(const ChildChange&amp;) override;
608     void removeAllEventListeners() final;
609     virtual void parserDidSetAttributes();
610 
611     void clearTabIndexExplicitlyIfNeeded();
612     void setTabIndexExplicitly(int);
613 
614     // classAttributeChanged() exists to share code between
615     // parseAttribute (called via setAttribute()) and
616     // svgAttributeChanged (called when element.className.baseValue is set)
<a name="42" id="anc42"></a><span class="line-modified">617     void classAttributeChanged(const AtomicString&amp; newClassString);</span>
618 
619     void addShadowRoot(Ref&lt;ShadowRoot&gt;&amp;&amp;);
620 
621     static ExceptionOr&lt;void&gt; mergeWithNextTextNode(Text&amp;);
622 
623 #if ENABLE(CSS_TYPED_OM)
624     StylePropertyMap* attributeStyleMap();
625     void setAttributeStyleMap(Ref&lt;StylePropertyMap&gt;&amp;&amp;);
626 #endif
627 
628 private:
629     Frame* documentFrameWithNonNullView() const;
630 
631     bool isTextNode() const;
632 
633     bool isUserActionElementInActiveChain() const;
634     bool isUserActionElementActive() const;
635     bool isUserActionElementFocused() const;
636     bool isUserActionElementHovered() const;
637 
638     virtual void didAddUserAgentShadowRoot(ShadowRoot&amp;) { }
639 
<a name="43" id="anc43"></a><span class="line-modified">640     void didAddAttribute(const QualifiedName&amp;, const AtomicString&amp;);</span>
<span class="line-modified">641     void willModifyAttribute(const QualifiedName&amp;, const AtomicString&amp; oldValue, const AtomicString&amp; newValue);</span>
<span class="line-modified">642     void didModifyAttribute(const QualifiedName&amp;, const AtomicString&amp; oldValue, const AtomicString&amp; newValue);</span>
<span class="line-modified">643     void didRemoveAttribute(const QualifiedName&amp;, const AtomicString&amp; oldValue);</span>
644 
645     void synchronizeAttribute(const QualifiedName&amp;) const;
<a name="44" id="anc44"></a><span class="line-modified">646     void synchronizeAttribute(const AtomicString&amp; localName) const;</span>
647 
<a name="45" id="anc45"></a><span class="line-modified">648     void updateName(const AtomicString&amp; oldName, const AtomicString&amp; newName);</span>
<span class="line-modified">649     void updateNameForTreeScope(TreeScope&amp;, const AtomicString&amp; oldName, const AtomicString&amp; newName);</span>
<span class="line-modified">650     void updateNameForDocument(HTMLDocument&amp;, const AtomicString&amp; oldName, const AtomicString&amp; newName);</span>
651 
652     enum class NotifyObservers { No, Yes };
<a name="46" id="anc46"></a><span class="line-modified">653     void updateId(const AtomicString&amp; oldId, const AtomicString&amp; newId, NotifyObservers = NotifyObservers::Yes);</span>
<span class="line-modified">654     void updateIdForTreeScope(TreeScope&amp;, const AtomicString&amp; oldId, const AtomicString&amp; newId, NotifyObservers = NotifyObservers::Yes);</span>
655 
656     enum HTMLDocumentNamedItemMapsUpdatingCondition { AlwaysUpdateHTMLDocumentNamedItemMaps, UpdateHTMLDocumentNamedItemMapsOnlyIfDiffersFromNameAttribute };
<a name="47" id="anc47"></a><span class="line-modified">657     void updateIdForDocument(HTMLDocument&amp;, const AtomicString&amp; oldId, const AtomicString&amp; newId, HTMLDocumentNamedItemMapsUpdatingCondition);</span>
<span class="line-modified">658     void updateLabel(TreeScope&amp;, const AtomicString&amp; oldForAttributeValue, const AtomicString&amp; newForAttributeValue);</span>
659 
660     ExceptionOr&lt;Node*&gt; insertAdjacent(const String&amp; where, Ref&lt;Node&gt;&amp;&amp; newChild);
661 
662     void scrollByUnits(int units, ScrollGranularity);
663 
664     NodeType nodeType() const final;
665     bool childTypeAllowed(NodeType) const final;
666 
667     enum SynchronizationOfLazyAttribute { NotInSynchronizationOfLazyAttribute, InSynchronizationOfLazyAttribute };
<a name="48" id="anc48"></a><span class="line-modified">668     void setAttributeInternal(unsigned index, const QualifiedName&amp;, const AtomicString&amp; value, SynchronizationOfLazyAttribute);</span>
<span class="line-modified">669     void addAttributeInternal(const QualifiedName&amp;, const AtomicString&amp; value, SynchronizationOfLazyAttribute);</span>
670     void removeAttributeInternal(unsigned index, SynchronizationOfLazyAttribute);
671 
672     LayoutRect absoluteEventBounds(bool&amp; boundsIncludeAllDescendantElements, bool&amp; includesFixedPositionElements);
673     LayoutRect absoluteEventBoundsOfElementAndDescendants(bool&amp; includesFixedPositionElements);
674 
675 #if ENABLE(TREE_DEBUGGING)
676     void formatForDebugger(char* buffer, unsigned length) const override;
677 #endif
678 
679 #if ENABLE(INTERSECTION_OBSERVER)
680     void disconnectFromIntersectionObservers();
681 #endif
682 
<a name="49" id="anc49"></a>



683     // The cloneNode function is private so that non-virtual cloneElementWith/WithoutChildren are used instead.
684     Ref&lt;Node&gt; cloneNodeInternal(Document&amp;, CloningOperation) override;
685     virtual Ref&lt;Element&gt; cloneElementWithoutAttributesAndChildren(Document&amp;);
686 
687     void removeShadowRoot();
688 
689     const RenderStyle&amp; resolveComputedStyle();
690     const RenderStyle&amp; resolvePseudoElementStyle(PseudoId);
691 
<a name="50" id="anc50"></a><span class="line-removed">692     bool rareDataStyleAffectedByEmpty() const;</span>
<span class="line-removed">693     bool rareDataStyleAffectedByFocusWithin() const;</span>
<span class="line-removed">694     bool rareDataChildrenAffectedByHover() const;</span>
<span class="line-removed">695     bool rareDataStyleAffectedByActive() const;</span>
<span class="line-removed">696     bool rareDataChildrenAffectedByDrag() const;</span>
<span class="line-removed">697     bool rareDataChildrenAffectedByLastChildRules() const;</span>
<span class="line-removed">698     bool rareDataChildrenAffectedByForwardPositionalRules() const;</span>
<span class="line-removed">699     bool rareDataDescendantsAffectedByForwardPositionalRules() const;</span>
<span class="line-removed">700     bool rareDataChildrenAffectedByBackwardPositionalRules() const;</span>
<span class="line-removed">701     bool rareDataDescendantsAffectedByBackwardPositionalRules() const;</span>
<span class="line-removed">702     bool rareDataChildrenAffectedByPropertyBasedBackwardPositionalRules() const;</span>
703     unsigned rareDataChildIndex() const;
704 
705     SpellcheckAttributeState spellcheckAttributeState() const;
706 
707     void createUniqueElementData();
708 
709     ElementRareData* elementRareData() const;
710     ElementRareData&amp; ensureElementRareData();
711 
<a name="51" id="anc51"></a>

712     void detachAllAttrNodesFromElement();
<a name="52" id="anc52"></a><span class="line-modified">713     void detachAttrNodeFromElementWithValue(Attr*, const AtomicString&amp; value);</span>
714 
715     // Anyone thinking of using this should call document instead of ownerDocument.
716     void ownerDocument() const = delete;
717 
718     void attachAttributeNodeIfNeeded(Attr&amp;);
719 
720     QualifiedName m_tagName;
721     RefPtr&lt;ElementData&gt; m_elementData;
722 };
723 
724 inline bool Node::hasAttributes() const
725 {
726     return is&lt;Element&gt;(*this) &amp;&amp; downcast&lt;Element&gt;(*this).hasAttributes();
727 }
728 
729 inline NamedNodeMap* Node::attributes() const
730 {
731     return is&lt;Element&gt;(*this) ? &amp;downcast&lt;Element&gt;(*this).attributes() : nullptr;
732 }
733 
734 inline Element* Node::parentElement() const
735 {
736     ContainerNode* parent = parentNode();
737     return is&lt;Element&gt;(parent) ? downcast&lt;Element&gt;(parent) : nullptr;
738 }
739 
740 inline const Element* Element::rootElement() const
741 {
742     if (isConnected())
743         return document().documentElement();
744 
745     const Element* highest = this;
746     while (highest-&gt;parentElement())
747         highest = highest-&gt;parentElement();
748     return highest;
749 }
750 
751 inline bool Element::hasAttributeWithoutSynchronization(const QualifiedName&amp; name) const
752 {
753     ASSERT(fastAttributeLookupAllowed(name));
754     return elementData() &amp;&amp; findAttributeByName(name);
755 }
756 
<a name="53" id="anc53"></a><span class="line-modified">757 inline const AtomicString&amp; Element::attributeWithoutSynchronization(const QualifiedName&amp; name) const</span>
758 {
759     if (elementData()) {
760         if (const Attribute* attribute = findAttributeByName(name))
761             return attribute-&gt;value();
762     }
763     return nullAtom();
764 }
765 
766 inline bool Element::hasAttributesWithoutUpdate() const
767 {
768     return elementData() &amp;&amp; !elementData()-&gt;isEmpty();
769 }
770 
<a name="54" id="anc54"></a><span class="line-modified">771 inline const AtomicString&amp; Element::idForStyleResolution() const</span>
772 {
773     return hasID() ? elementData()-&gt;idForStyleResolution() : nullAtom();
774 }
775 
<a name="55" id="anc55"></a><span class="line-modified">776 inline const AtomicString&amp; Element::getIdAttribute() const</span>
777 {
778     if (hasID())
779         return elementData()-&gt;findAttributeByName(HTMLNames::idAttr)-&gt;value();
780     return nullAtom();
781 }
782 
<a name="56" id="anc56"></a><span class="line-modified">783 inline const AtomicString&amp; Element::getNameAttribute() const</span>
784 {
785     if (hasName())
786         return elementData()-&gt;findAttributeByName(HTMLNames::nameAttr)-&gt;value();
787     return nullAtom();
788 }
789 
<a name="57" id="anc57"></a><span class="line-modified">790 inline void Element::setIdAttribute(const AtomicString&amp; value)</span>
791 {
792     setAttributeWithoutSynchronization(HTMLNames::idAttr, value);
793 }
794 
795 inline const SpaceSplitString&amp; Element::classNames() const
796 {
797     ASSERT(hasClass());
798     ASSERT(elementData());
799     return elementData()-&gt;classNames();
800 }
801 
802 inline unsigned Element::attributeCount() const
803 {
804     ASSERT(elementData());
805     return elementData()-&gt;length();
806 }
807 
808 inline const Attribute&amp; Element::attributeAt(unsigned index) const
809 {
810     ASSERT(elementData());
811     return elementData()-&gt;attributeAt(index);
812 }
813 
814 inline const Attribute* Element::findAttributeByName(const QualifiedName&amp; name) const
815 {
816     ASSERT(elementData());
817     return elementData()-&gt;findAttributeByName(name);
818 }
819 
820 inline bool Element::hasID() const
821 {
822     return elementData() &amp;&amp; elementData()-&gt;hasID();
823 }
824 
825 inline bool Element::hasClass() const
826 {
827     return elementData() &amp;&amp; elementData()-&gt;hasClass();
828 }
829 
830 inline bool Element::hasName() const
831 {
832     return elementData() &amp;&amp; elementData()-&gt;hasName();
833 }
834 
835 inline UniqueElementData&amp; Element::ensureUniqueElementData()
836 {
837     if (!elementData() || !elementData()-&gt;isUnique())
838         createUniqueElementData();
839     return static_cast&lt;UniqueElementData&amp;&gt;(*m_elementData);
840 }
841 
842 inline bool shouldIgnoreAttributeCase(const Element&amp; element)
843 {
844     return element.isHTMLElement() &amp;&amp; element.document().isHTMLDocument();
845 }
846 
847 inline void Element::setHasFocusWithin(bool flag)
848 {
849     if (hasFocusWithin() == flag)
850         return;
851     setFlag(flag, HasFocusWithin);
852     if (styleAffectedByFocusWithin())
853         invalidateStyleForSubtree();
854 }
855 
856 template&lt;typename... QualifiedNames&gt;
<a name="58" id="anc58"></a><span class="line-modified">857 inline const AtomicString&amp; Element::getAttribute(const QualifiedName&amp; name, const QualifiedNames&amp;... names) const</span>
858 {
<a name="59" id="anc59"></a><span class="line-modified">859     const AtomicString&amp; value = getAttribute(name);</span>
860     if (!value.isNull())
861         return value;
862     return getAttribute(names...);
863 }
864 
865 } // namespace WebCore
866 
867 SPECIALIZE_TYPE_TRAITS_BEGIN(WebCore::Element)
868     static bool isType(const WebCore::Node&amp; node) { return node.isElementNode(); }
869     static bool isType(const WebCore::EventTarget&amp; target) { return is&lt;WebCore::Node&gt;(target) &amp;&amp; isType(downcast&lt;WebCore::Node&gt;(target)); }
870 SPECIALIZE_TYPE_TRAITS_END()
<a name="60" id="anc60"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="60" type="hidden" />
</body>
</html>