<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/inspector/agents/InspectorDebuggerAgent.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2010-2017 Apple Inc. All rights reserved.
   3  * Copyright (C) 2010, 2011 Google Inc. All rights reserved.
   4  *
   5  * Redistribution and use in source and binary forms, with or without
   6  * modification, are permitted provided that the following conditions
   7  * are met:
   8  *
   9  * 1.  Redistributions of source code must retain the above copyright
  10  *     notice, this list of conditions and the following disclaimer.
  11  * 2.  Redistributions in binary form must reproduce the above copyright
  12  *     notice, this list of conditions and the following disclaimer in the
  13  *     documentation and/or other materials provided with the distribution.
  14  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
  15  *     its contributors may be used to endorse or promote products derived
  16  *     from this software without specific prior written permission.
  17  *
  18  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
  19  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  20  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  21  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  22  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  23  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  24  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  25  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  26  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  27  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  28  */
  29 
  30 #include &quot;config.h&quot;
  31 #include &quot;InspectorDebuggerAgent.h&quot;
  32 
  33 #include &quot;AsyncStackTrace.h&quot;
  34 #include &quot;ContentSearchUtilities.h&quot;
  35 #include &quot;InjectedScript.h&quot;
  36 #include &quot;InjectedScriptManager.h&quot;
  37 #include &quot;InspectorFrontendRouter.h&quot;
  38 #include &quot;JSCInlines.h&quot;
  39 #include &quot;RegularExpression.h&quot;
  40 #include &quot;ScriptCallStack.h&quot;
  41 #include &quot;ScriptCallStackFactory.h&quot;
  42 #include &quot;ScriptDebugServer.h&quot;
  43 #include &quot;ScriptObject.h&quot;
  44 #include &lt;wtf/JSONValues.h&gt;
  45 #include &lt;wtf/NeverDestroyed.h&gt;
  46 #include &lt;wtf/Stopwatch.h&gt;
  47 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
  48 #include &lt;wtf/text/WTFString.h&gt;
  49 
  50 namespace Inspector {
  51 
  52 const char* InspectorDebuggerAgent::backtraceObjectGroup = &quot;backtrace&quot;;
  53 
  54 // Objects created and retained by evaluating breakpoint actions are put into object groups
  55 // according to the breakpoint action identifier assigned by the frontend. A breakpoint may
  56 // have several object groups, and objects from several backend breakpoint action instances may
  57 // create objects in the same group.
  58 static String objectGroupForBreakpointAction(const ScriptBreakpointAction&amp; action)
  59 {
  60     return makeString(&quot;breakpoint-action-&quot;, action.identifier);
  61 }
  62 
  63 InspectorDebuggerAgent::InspectorDebuggerAgent(AgentContext&amp; context)
  64     : InspectorAgentBase(&quot;Debugger&quot;_s)
  65     , m_frontendDispatcher(makeUnique&lt;DebuggerFrontendDispatcher&gt;(context.frontendRouter))
  66     , m_backendDispatcher(DebuggerBackendDispatcher::create(context.backendDispatcher, this))
  67     , m_scriptDebugServer(context.environment.scriptDebugServer())
  68     , m_injectedScriptManager(context.injectedScriptManager)
  69 {
  70     // FIXME: make breakReason optional so that there was no need to init it with &quot;other&quot;.
  71     clearBreakDetails();
  72 }
  73 
  74 InspectorDebuggerAgent::~InspectorDebuggerAgent() = default;
  75 
  76 void InspectorDebuggerAgent::didCreateFrontendAndBackend(FrontendRouter*, BackendDispatcher*)
  77 {
  78 }
  79 
  80 void InspectorDebuggerAgent::willDestroyFrontendAndBackend(DisconnectReason reason)
  81 {
  82     disable(reason == DisconnectReason::InspectedTargetDestroyed);
  83 }
  84 
  85 void InspectorDebuggerAgent::enable()
  86 {
  87     if (m_enabled)
  88         return;
  89 
  90     m_enabled = true;
  91 
  92     m_scriptDebugServer.addListener(this);
  93 
  94     for (auto* listener : copyToVector(m_listeners))
  95         listener-&gt;debuggerWasEnabled();
  96 }
  97 
  98 void InspectorDebuggerAgent::disable(bool isBeingDestroyed)
  99 {
 100     if (!m_enabled)
 101         return;
 102 
 103     for (auto* listener : copyToVector(m_listeners))
 104         listener-&gt;debuggerWasDisabled();
 105 
 106     m_scriptDebugServer.removeListener(this, isBeingDestroyed);
 107 
 108     clearInspectorBreakpointState();
 109 
 110     if (!isBeingDestroyed)
 111         m_scriptDebugServer.deactivateBreakpoints();
 112 
 113     ASSERT(m_javaScriptBreakpoints.isEmpty());
 114 
 115     clearAsyncStackTraceData();
 116 
 117     m_pauseOnAssertionFailures = false;
 118     m_pauseOnMicrotasks = false;
 119 
 120     m_enabled = false;
 121 }
 122 
 123 void InspectorDebuggerAgent::enable(ErrorString&amp;)
 124 {
 125     enable();
 126 }
 127 
 128 void InspectorDebuggerAgent::disable(ErrorString&amp;)
 129 {
 130     disable(false);
 131 }
 132 
 133 bool InspectorDebuggerAgent::breakpointsActive() const
 134 {
 135     return m_scriptDebugServer.breakpointsActive();
 136 }
 137 
 138 void InspectorDebuggerAgent::setAsyncStackTraceDepth(ErrorString&amp; errorString, int depth)
 139 {
 140     if (m_asyncStackTraceDepth == depth)
 141         return;
 142 
 143     if (depth &lt; 0) {
 144         errorString = &quot;Unexpected negative depth&quot;_s;
 145         return;
 146     }
 147 
 148     m_asyncStackTraceDepth = depth;
 149 
 150     if (!m_asyncStackTraceDepth)
 151         clearAsyncStackTraceData();
 152 }
 153 
 154 void InspectorDebuggerAgent::setBreakpointsActive(ErrorString&amp;, bool active)
 155 {
 156     if (active)
 157         m_scriptDebugServer.activateBreakpoints();
 158     else
 159         m_scriptDebugServer.deactivateBreakpoints();
 160 }
 161 
 162 bool InspectorDebuggerAgent::isPaused() const
 163 {
 164     return m_scriptDebugServer.isPaused();
 165 }
 166 
 167 void InspectorDebuggerAgent::setSuppressAllPauses(bool suppress)
 168 {
 169     m_scriptDebugServer.setSuppressAllPauses(suppress);
 170 }
 171 
 172 static RefPtr&lt;JSON::Object&gt; buildAssertPauseReason(const String&amp; message)
 173 {
 174     auto reason = Protocol::Debugger::AssertPauseReason::create().release();
 175     if (!message.isNull())
 176         reason-&gt;setMessage(message);
 177     return reason-&gt;openAccessors();
 178 }
 179 
 180 static RefPtr&lt;JSON::Object&gt; buildCSPViolationPauseReason(const String&amp; directiveText)
 181 {
 182     auto reason = Protocol::Debugger::CSPViolationPauseReason::create()
 183         .setDirective(directiveText)
 184         .release();
 185     return reason-&gt;openAccessors();
 186 }
 187 
 188 RefPtr&lt;JSON::Object&gt; InspectorDebuggerAgent::buildBreakpointPauseReason(JSC::BreakpointID debuggerBreakpointIdentifier)
 189 {
 190     ASSERT(debuggerBreakpointIdentifier != JSC::noBreakpointID);
 191     auto it = m_debuggerBreakpointIdentifierToInspectorBreakpointIdentifier.find(debuggerBreakpointIdentifier);
 192     if (it == m_debuggerBreakpointIdentifierToInspectorBreakpointIdentifier.end())
 193         return nullptr;
 194 
 195     auto reason = Protocol::Debugger::BreakpointPauseReason::create()
 196         .setBreakpointId(it-&gt;value)
 197         .release();
 198     return reason-&gt;openAccessors();
 199 }
 200 
 201 RefPtr&lt;JSON::Object&gt; InspectorDebuggerAgent::buildExceptionPauseReason(JSC::JSValue exception, const InjectedScript&amp; injectedScript)
 202 {
 203     ASSERT(exception);
 204     if (!exception)
 205         return nullptr;
 206 
 207     ASSERT(!injectedScript.hasNoValue());
 208     if (injectedScript.hasNoValue())
 209         return nullptr;
 210 
 211     return injectedScript.wrapObject(exception, InspectorDebuggerAgent::backtraceObjectGroup)-&gt;openAccessors();
 212 }
 213 
 214 void InspectorDebuggerAgent::handleConsoleAssert(const String&amp; message)
 215 {
 216     if (!m_scriptDebugServer.breakpointsActive())
 217         return;
 218 
 219     if (m_pauseOnAssertionFailures)
 220         breakProgram(DebuggerFrontendDispatcher::Reason::Assert, buildAssertPauseReason(message));
 221 }
 222 
 223 InspectorDebuggerAgent::AsyncCallIdentifier InspectorDebuggerAgent::asyncCallIdentifier(AsyncCallType asyncCallType, int callbackId)
 224 {
 225     return std::make_pair(static_cast&lt;unsigned&gt;(asyncCallType), callbackId);
 226 }
 227 
 228 void InspectorDebuggerAgent::didScheduleAsyncCall(JSC::ExecState* exec, AsyncCallType asyncCallType, int callbackId, bool singleShot)
 229 {
 230     if (!m_asyncStackTraceDepth)
 231         return;
 232 
 233     if (!m_scriptDebugServer.breakpointsActive())
 234         return;
 235 
 236     Ref&lt;ScriptCallStack&gt; callStack = createScriptCallStack(exec, m_asyncStackTraceDepth);
 237     ASSERT(callStack-&gt;size());
 238     if (!callStack-&gt;size())
 239         return;
 240 
 241     RefPtr&lt;AsyncStackTrace&gt; parentStackTrace;
 242     if (m_currentAsyncCallIdentifier) {
 243         auto it = m_pendingAsyncCalls.find(m_currentAsyncCallIdentifier.value());
 244         ASSERT(it != m_pendingAsyncCalls.end());
 245         parentStackTrace = it-&gt;value;
 246     }
 247 
 248     auto identifier = asyncCallIdentifier(asyncCallType, callbackId);
 249     auto asyncStackTrace = AsyncStackTrace::create(WTFMove(callStack), singleShot, WTFMove(parentStackTrace));
 250 
 251     m_pendingAsyncCalls.set(identifier, WTFMove(asyncStackTrace));
 252 }
 253 
 254 void InspectorDebuggerAgent::didCancelAsyncCall(AsyncCallType asyncCallType, int callbackId)
 255 {
 256     if (!m_asyncStackTraceDepth)
 257         return;
 258 
 259     auto identifier = asyncCallIdentifier(asyncCallType, callbackId);
 260     auto it = m_pendingAsyncCalls.find(identifier);
 261     if (it == m_pendingAsyncCalls.end())
 262         return;
 263 
 264     auto&amp; asyncStackTrace = it-&gt;value;
 265     asyncStackTrace-&gt;didCancelAsyncCall();
 266 
 267     if (m_currentAsyncCallIdentifier &amp;&amp; m_currentAsyncCallIdentifier.value() == identifier)
 268         return;
 269 
 270     m_pendingAsyncCalls.remove(identifier);
 271 }
 272 
 273 void InspectorDebuggerAgent::willDispatchAsyncCall(AsyncCallType asyncCallType, int callbackId)
 274 {
 275     if (!m_asyncStackTraceDepth)
 276         return;
 277 
 278     if (m_currentAsyncCallIdentifier)
 279         return;
 280 
 281     // A call can be scheduled before the Inspector is opened, or while async stack
 282     // traces are disabled. If no call data exists, do nothing.
 283     auto identifier = asyncCallIdentifier(asyncCallType, callbackId);
 284     auto it = m_pendingAsyncCalls.find(identifier);
 285     if (it == m_pendingAsyncCalls.end())
 286         return;
 287 
 288     auto&amp; asyncStackTrace = it-&gt;value;
 289     asyncStackTrace-&gt;willDispatchAsyncCall(m_asyncStackTraceDepth);
 290 
 291     m_currentAsyncCallIdentifier = identifier;
 292 }
 293 
 294 void InspectorDebuggerAgent::didDispatchAsyncCall()
 295 {
 296     if (!m_asyncStackTraceDepth)
 297         return;
 298 
 299     if (!m_currentAsyncCallIdentifier)
 300         return;
 301 
 302     auto identifier = m_currentAsyncCallIdentifier.value();
 303     auto it = m_pendingAsyncCalls.find(identifier);
 304     ASSERT(it != m_pendingAsyncCalls.end());
 305 
 306     auto&amp; asyncStackTrace = it-&gt;value;
 307     asyncStackTrace-&gt;didDispatchAsyncCall();
 308 
 309     m_currentAsyncCallIdentifier = WTF::nullopt;
 310 
 311     if (!asyncStackTrace-&gt;isPending())
 312         m_pendingAsyncCalls.remove(identifier);
 313 }
 314 
 315 static Ref&lt;JSON::Object&gt; buildObjectForBreakpointCookie(const String&amp; url, int lineNumber, int columnNumber, const String&amp; condition, RefPtr&lt;JSON::Array&gt;&amp; actions, bool isRegex, bool autoContinue, unsigned ignoreCount)
 316 {
 317     Ref&lt;JSON::Object&gt; breakpointObject = JSON::Object::create();
 318     breakpointObject-&gt;setString(&quot;url&quot;_s, url);
 319     breakpointObject-&gt;setInteger(&quot;lineNumber&quot;_s, lineNumber);
 320     breakpointObject-&gt;setInteger(&quot;columnNumber&quot;_s, columnNumber);
 321     breakpointObject-&gt;setString(&quot;condition&quot;_s, condition);
 322     breakpointObject-&gt;setBoolean(&quot;isRegex&quot;_s, isRegex);
 323     breakpointObject-&gt;setBoolean(&quot;autoContinue&quot;_s, autoContinue);
 324     breakpointObject-&gt;setInteger(&quot;ignoreCount&quot;_s, ignoreCount);
 325 
 326     if (actions)
 327         breakpointObject-&gt;setArray(&quot;actions&quot;_s, actions);
 328 
 329     return breakpointObject;
 330 }
 331 
 332 static bool matches(const String&amp; url, const String&amp; pattern, bool isRegex)
 333 {
 334     if (isRegex) {
 335         JSC::Yarr::RegularExpression regex(pattern);
 336         return regex.match(url) != -1;
 337     }
 338     return url == pattern;
 339 }
 340 
 341 static bool breakpointActionTypeForString(const String&amp; typeString, ScriptBreakpointActionType* output)
 342 {
 343     if (typeString == Protocol::InspectorHelpers::getEnumConstantValue(Protocol::Debugger::BreakpointAction::Type::Log)) {
 344         *output = ScriptBreakpointActionTypeLog;
 345         return true;
 346     }
 347     if (typeString == Protocol::InspectorHelpers::getEnumConstantValue(Protocol::Debugger::BreakpointAction::Type::Evaluate)) {
 348         *output = ScriptBreakpointActionTypeEvaluate;
 349         return true;
 350     }
 351     if (typeString == Protocol::InspectorHelpers::getEnumConstantValue(Protocol::Debugger::BreakpointAction::Type::Sound)) {
 352         *output = ScriptBreakpointActionTypeSound;
 353         return true;
 354     }
 355     if (typeString == Protocol::InspectorHelpers::getEnumConstantValue(Protocol::Debugger::BreakpointAction::Type::Probe)) {
 356         *output = ScriptBreakpointActionTypeProbe;
 357         return true;
 358     }
 359 
 360     return false;
 361 }
 362 
 363 bool InspectorDebuggerAgent::breakpointActionsFromProtocol(ErrorString&amp; errorString, RefPtr&lt;JSON::Array&gt;&amp; actions, BreakpointActions* result)
 364 {
 365     if (!actions)
 366         return true;
 367 
 368     unsigned actionsLength = actions-&gt;length();
 369     if (!actionsLength)
 370         return true;
 371 
 372     result-&gt;reserveCapacity(actionsLength);
 373     for (unsigned i = 0; i &lt; actionsLength; ++i) {
 374         RefPtr&lt;JSON::Value&gt; value = actions-&gt;get(i);
 375         RefPtr&lt;JSON::Object&gt; object;
 376         if (!value-&gt;asObject(object)) {
 377             errorString = &quot;Unexpected non-object item in given actions&quot;_s;
 378             return false;
 379         }
 380 
 381         String typeString;
 382         if (!object-&gt;getString(&quot;type&quot;_s, typeString)) {
 383             errorString = &quot;Missing type for item in given actions&quot;_s;
 384             return false;
 385         }
 386 
 387         ScriptBreakpointActionType type;
 388         if (!breakpointActionTypeForString(typeString, &amp;type)) {
 389             errorString = &quot;Non-string type for item in given actions&quot;_s;
 390             return false;
 391         }
 392 
 393         // Specifying an identifier is optional. They are used to correlate probe samples
 394         // in the frontend across multiple backend probe actions and segregate object groups.
 395         int identifier = 0;
 396         object-&gt;getInteger(&quot;id&quot;_s, identifier);
 397 
 398         String data;
 399         object-&gt;getString(&quot;data&quot;_s, data);
 400 
 401         result-&gt;append(ScriptBreakpointAction(type, identifier, data));
 402     }
 403 
 404     return true;
 405 }
 406 
 407 static RefPtr&lt;Protocol::Debugger::Location&gt; buildDebuggerLocation(const JSC::Breakpoint&amp; breakpoint)
 408 {
 409     ASSERT(breakpoint.resolved);
 410 
 411     auto location = Protocol::Debugger::Location::create()
 412         .setScriptId(String::number(breakpoint.sourceID))
 413         .setLineNumber(breakpoint.line)
 414         .release();
 415     location-&gt;setColumnNumber(breakpoint.column);
 416 
 417     return location;
 418 }
 419 
 420 static bool parseLocation(ErrorString&amp; errorString, const JSON::Object&amp; location, JSC::SourceID&amp; sourceID, unsigned&amp; lineNumber, unsigned&amp; columnNumber)
 421 {
 422     if (!location.getInteger(&quot;lineNumber&quot;_s, lineNumber)) {
 423         errorString = &quot;Unexpected non-integer lineNumber in given location&quot;_s;
 424         sourceID = JSC::noSourceID;
 425         return false;
 426     }
 427 
 428     String scriptIDStr;
 429     if (!location.getString(&quot;scriptId&quot;_s, scriptIDStr)) {
 430         sourceID = JSC::noSourceID;
 431         errorString = &quot;Unexepcted non-string scriptId in given location&quot;_s;
 432         return false;
 433     }
 434 
 435     sourceID = scriptIDStr.toIntPtr();
 436     columnNumber = 0;
 437     location.getInteger(&quot;columnNumber&quot;_s, columnNumber);
 438     return true;
 439 }
 440 
 441 void InspectorDebuggerAgent::setBreakpointByUrl(ErrorString&amp; errorString, int lineNumber, const String* optionalURL, const String* optionalURLRegex, const int* optionalColumnNumber, const JSON::Object* options, Protocol::Debugger::BreakpointId* outBreakpointIdentifier, RefPtr&lt;JSON::ArrayOf&lt;Protocol::Debugger::Location&gt;&gt;&amp; locations)
 442 {
 443     locations = JSON::ArrayOf&lt;Protocol::Debugger::Location&gt;::create();
 444     if (!optionalURL == !optionalURLRegex) {
 445         errorString = &quot;Either url or urlRegex must be specified&quot;_s;
 446         return;
 447     }
 448 
 449     String url = optionalURL ? *optionalURL : *optionalURLRegex;
 450     int columnNumber = optionalColumnNumber ? *optionalColumnNumber : 0;
 451     bool isRegex = optionalURLRegex;
 452 
 453     String breakpointIdentifier = makeString(isRegex ? &quot;/&quot; : &quot;&quot;, url, isRegex ? &quot;/:&quot; : &quot;:&quot;, lineNumber, &#39;:&#39;, columnNumber);
 454     if (m_javaScriptBreakpoints.contains(breakpointIdentifier)) {
 455         errorString = &quot;Breakpoint for given location already exists.&quot;_s;
 456         return;
 457     }
 458 
 459     String condition = emptyString();
 460     bool autoContinue = false;
 461     unsigned ignoreCount = 0;
 462     RefPtr&lt;JSON::Array&gt; actions;
 463     if (options) {
 464         options-&gt;getString(&quot;condition&quot;_s, condition);
 465         options-&gt;getBoolean(&quot;autoContinue&quot;_s, autoContinue);
 466         options-&gt;getArray(&quot;actions&quot;_s, actions);
 467         options-&gt;getInteger(&quot;ignoreCount&quot;_s, ignoreCount);
 468     }
 469 
 470     BreakpointActions breakpointActions;
 471     if (!breakpointActionsFromProtocol(errorString, actions, &amp;breakpointActions))
 472         return;
 473 
 474     m_javaScriptBreakpoints.set(breakpointIdentifier, buildObjectForBreakpointCookie(url, lineNumber, columnNumber, condition, actions, isRegex, autoContinue, ignoreCount));
 475 
 476     for (auto&amp; entry : m_scripts) {
 477         Script&amp; script = entry.value;
 478         String scriptURLForBreakpoints = !script.sourceURL.isEmpty() ? script.sourceURL : script.url;
 479         if (!matches(scriptURLForBreakpoints, url, isRegex))
 480             continue;
 481 
 482         JSC::SourceID sourceID = entry.key;
 483         JSC::Breakpoint breakpoint(sourceID, lineNumber, columnNumber, condition, autoContinue, ignoreCount);
 484         resolveBreakpoint(script, breakpoint);
 485         if (!breakpoint.resolved)
 486             continue;
 487 
 488         bool existing;
 489         setBreakpoint(breakpoint, existing);
 490         if (existing)
 491             continue;
 492 
 493         ScriptBreakpoint scriptBreakpoint(breakpoint.line, breakpoint.column, condition, breakpointActions, autoContinue, ignoreCount);
 494         didSetBreakpoint(breakpoint, breakpointIdentifier, scriptBreakpoint);
 495 
 496         locations-&gt;addItem(buildDebuggerLocation(breakpoint));
 497     }
 498 
 499     *outBreakpointIdentifier = breakpointIdentifier;
 500 }
 501 
 502 void InspectorDebuggerAgent::setBreakpoint(ErrorString&amp; errorString, const JSON::Object&amp; location, const JSON::Object* options, Protocol::Debugger::BreakpointId* outBreakpointIdentifier, RefPtr&lt;Protocol::Debugger::Location&gt;&amp; actualLocation)
 503 {
 504     JSC::SourceID sourceID;
 505     unsigned lineNumber;
 506     unsigned columnNumber;
 507     if (!parseLocation(errorString, location, sourceID, lineNumber, columnNumber))
 508         return;
 509 
 510     String condition = emptyString();
 511     bool autoContinue = false;
 512     unsigned ignoreCount = 0;
 513     RefPtr&lt;JSON::Array&gt; actions;
 514     if (options) {
 515         options-&gt;getString(&quot;condition&quot;_s, condition);
 516         options-&gt;getBoolean(&quot;autoContinue&quot;_s, autoContinue);
 517         options-&gt;getArray(&quot;actions&quot;_s, actions);
 518         options-&gt;getInteger(&quot;ignoreCount&quot;_s, ignoreCount);
 519     }
 520 
 521     BreakpointActions breakpointActions;
 522     if (!breakpointActionsFromProtocol(errorString, actions, &amp;breakpointActions))
 523         return;
 524 
 525     auto scriptIterator = m_scripts.find(sourceID);
 526     if (scriptIterator == m_scripts.end()) {
 527         errorString = &quot;Missing script for scriptId in given location&quot;_s;
 528         return;
 529     }
 530 
 531     Script&amp; script = scriptIterator-&gt;value;
 532     JSC::Breakpoint breakpoint(sourceID, lineNumber, columnNumber, condition, autoContinue, ignoreCount);
 533     resolveBreakpoint(script, breakpoint);
 534     if (!breakpoint.resolved) {
 535         errorString = &quot;Could not resolve breakpoint&quot;_s;
 536         return;
 537     }
 538 
 539     bool existing;
 540     setBreakpoint(breakpoint, existing);
 541     if (existing) {
 542         errorString = &quot;Breakpoint for given location already exists&quot;_s;
 543         return;
 544     }
 545 
 546     String breakpointIdentifier = makeString(sourceID, &#39;:&#39;, breakpoint.line, &#39;:&#39;, breakpoint.column);
 547     ScriptBreakpoint scriptBreakpoint(breakpoint.line, breakpoint.column, condition, breakpointActions, autoContinue, ignoreCount);
 548     didSetBreakpoint(breakpoint, breakpointIdentifier, scriptBreakpoint);
 549 
 550     actualLocation = buildDebuggerLocation(breakpoint);
 551     *outBreakpointIdentifier = breakpointIdentifier;
 552 }
 553 
 554 void InspectorDebuggerAgent::didSetBreakpoint(const JSC::Breakpoint&amp; breakpoint, const String&amp; breakpointIdentifier, const ScriptBreakpoint&amp; scriptBreakpoint)
 555 {
 556     JSC::BreakpointID id = breakpoint.id;
 557     m_scriptDebugServer.setBreakpointActions(id, scriptBreakpoint);
 558 
 559     auto debugServerBreakpointIDsIterator = m_breakpointIdentifierToDebugServerBreakpointIDs.find(breakpointIdentifier);
 560     if (debugServerBreakpointIDsIterator == m_breakpointIdentifierToDebugServerBreakpointIDs.end())
 561         debugServerBreakpointIDsIterator = m_breakpointIdentifierToDebugServerBreakpointIDs.set(breakpointIdentifier, Vector&lt;JSC::BreakpointID&gt;()).iterator;
 562     debugServerBreakpointIDsIterator-&gt;value.append(id);
 563 
 564     m_debuggerBreakpointIdentifierToInspectorBreakpointIdentifier.set(id, breakpointIdentifier);
 565 }
 566 
 567 void InspectorDebuggerAgent::resolveBreakpoint(const Script&amp; script, JSC::Breakpoint&amp; breakpoint)
 568 {
 569     if (breakpoint.line &lt; static_cast&lt;unsigned&gt;(script.startLine) || static_cast&lt;unsigned&gt;(script.endLine) &lt; breakpoint.line)
 570         return;
 571 
 572     m_scriptDebugServer.resolveBreakpoint(breakpoint, script.sourceProvider.get());
 573 }
 574 
 575 void InspectorDebuggerAgent::setBreakpoint(JSC::Breakpoint&amp; breakpoint, bool&amp; existing)
 576 {
 577     JSC::JSLockHolder locker(m_scriptDebugServer.vm());
 578     m_scriptDebugServer.setBreakpoint(breakpoint, existing);
 579 }
 580 
 581 void InspectorDebuggerAgent::removeBreakpoint(ErrorString&amp;, const String&amp; breakpointIdentifier)
 582 {
 583     m_javaScriptBreakpoints.remove(breakpointIdentifier);
 584 
 585     for (JSC::BreakpointID breakpointID : m_breakpointIdentifierToDebugServerBreakpointIDs.take(breakpointIdentifier)) {
 586         m_debuggerBreakpointIdentifierToInspectorBreakpointIdentifier.remove(breakpointID);
 587 
 588         const BreakpointActions&amp; breakpointActions = m_scriptDebugServer.getActionsForBreakpoint(breakpointID);
 589         for (auto&amp; action : breakpointActions)
 590             m_injectedScriptManager.releaseObjectGroup(objectGroupForBreakpointAction(action));
 591 
 592         JSC::JSLockHolder locker(m_scriptDebugServer.vm());
 593         m_scriptDebugServer.removeBreakpointActions(breakpointID);
 594         m_scriptDebugServer.removeBreakpoint(breakpointID);
 595     }
 596 }
 597 
 598 void InspectorDebuggerAgent::continueUntilNextRunLoop(ErrorString&amp; errorString)
 599 {
 600     if (!assertPaused(errorString))
 601         return;
 602 
 603     resume(errorString);
 604 
 605     m_enablePauseWhenIdle = true;
 606 
 607     registerIdleHandler();
 608 }
 609 
 610 void InspectorDebuggerAgent::continueToLocation(ErrorString&amp; errorString, const JSON::Object&amp; location)
 611 {
 612     if (!assertPaused(errorString))
 613         return;
 614 
 615     if (m_continueToLocationBreakpointID != JSC::noBreakpointID) {
 616         m_scriptDebugServer.removeBreakpoint(m_continueToLocationBreakpointID);
 617         m_continueToLocationBreakpointID = JSC::noBreakpointID;
 618     }
 619 
 620     JSC::SourceID sourceID;
 621     unsigned lineNumber;
 622     unsigned columnNumber;
 623     if (!parseLocation(errorString, location, sourceID, lineNumber, columnNumber))
 624         return;
 625 
 626     auto scriptIterator = m_scripts.find(sourceID);
 627     if (scriptIterator == m_scripts.end()) {
 628         m_scriptDebugServer.continueProgram();
 629         m_frontendDispatcher-&gt;resumed();
 630         errorString = &quot;Missing script for scriptId in given location&quot;_s;
 631         return;
 632     }
 633 
 634     String condition;
 635     bool autoContinue = false;
 636     unsigned ignoreCount = 0;
 637     JSC::Breakpoint breakpoint(sourceID, lineNumber, columnNumber, condition, autoContinue, ignoreCount);
 638     Script&amp; script = scriptIterator-&gt;value;
 639     resolveBreakpoint(script, breakpoint);
 640     if (!breakpoint.resolved) {
 641         m_scriptDebugServer.continueProgram();
 642         m_frontendDispatcher-&gt;resumed();
 643         errorString = &quot;Could not resolve breakpoint&quot;_s;
 644         return;
 645     }
 646 
 647     bool existing;
 648     setBreakpoint(breakpoint, existing);
 649     if (existing) {
 650         // There is an existing breakpoint at this location. Instead of
 651         // acting like a series of steps, just resume and we will either
 652         // hit this new breakpoint or not.
 653         m_scriptDebugServer.continueProgram();
 654         m_frontendDispatcher-&gt;resumed();
 655         return;
 656     }
 657 
 658     m_continueToLocationBreakpointID = breakpoint.id;
 659 
 660     // Treat this as a series of steps until reaching the new breakpoint.
 661     // So don&#39;t issue a resumed event unless we exit the VM without pausing.
 662     willStepAndMayBecomeIdle();
 663     m_scriptDebugServer.continueProgram();
 664 }
 665 
 666 void InspectorDebuggerAgent::searchInContent(ErrorString&amp; errorString, const String&amp; scriptIDStr, const String&amp; query, const bool* optionalCaseSensitive, const bool* optionalIsRegex, RefPtr&lt;JSON::ArrayOf&lt;Protocol::GenericTypes::SearchMatch&gt;&gt;&amp; results)
 667 {
 668     JSC::SourceID sourceID = scriptIDStr.toIntPtr();
 669     auto it = m_scripts.find(sourceID);
 670     if (it == m_scripts.end()) {
 671         errorString = &quot;Missing script for given scriptId&quot;;
 672         return;
 673     }
 674 
 675     bool isRegex = optionalIsRegex ? *optionalIsRegex : false;
 676     bool caseSensitive = optionalCaseSensitive ? *optionalCaseSensitive : false;
 677     results = ContentSearchUtilities::searchInTextByLines(it-&gt;value.source, query, caseSensitive, isRegex);
 678 }
 679 
 680 void InspectorDebuggerAgent::getScriptSource(ErrorString&amp; errorString, const String&amp; scriptIDStr, String* scriptSource)
 681 {
 682     JSC::SourceID sourceID = scriptIDStr.toIntPtr();
 683     auto it = m_scripts.find(sourceID);
 684     if (it != m_scripts.end())
 685         *scriptSource = it-&gt;value.source;
 686     else
 687         errorString = &quot;Missing script for given scriptId&quot;;
 688 }
 689 
 690 void InspectorDebuggerAgent::getFunctionDetails(ErrorString&amp; errorString, const String&amp; functionId, RefPtr&lt;Protocol::Debugger::FunctionDetails&gt;&amp; details)
 691 {
 692     InjectedScript injectedScript = m_injectedScriptManager.injectedScriptForObjectId(functionId);
 693     if (injectedScript.hasNoValue()) {
 694         errorString = &quot;Missing injected script for given functionId&quot;_s;
 695         return;
 696     }
 697 
 698     injectedScript.getFunctionDetails(errorString, functionId, details);
 699 }
 700 
 701 void InspectorDebuggerAgent::schedulePauseOnNextStatement(DebuggerFrontendDispatcher::Reason breakReason, RefPtr&lt;JSON::Object&gt;&amp;&amp; data)
 702 {
 703     if (m_javaScriptPauseScheduled)
 704         return;
 705 
 706     m_javaScriptPauseScheduled = true;
 707 
 708     m_breakReason = breakReason;
 709     m_breakData = WTFMove(data);
 710 
 711     JSC::JSLockHolder locker(m_scriptDebugServer.vm());
 712     m_scriptDebugServer.setPauseOnNextStatement(true);
 713 }
 714 
 715 void InspectorDebuggerAgent::cancelPauseOnNextStatement()
 716 {
 717     if (!m_javaScriptPauseScheduled)
 718         return;
 719 
 720     m_javaScriptPauseScheduled = false;
 721 
 722     clearBreakDetails();
 723     m_scriptDebugServer.setPauseOnNextStatement(false);
 724     m_enablePauseWhenIdle = false;
 725 }
 726 
 727 void InspectorDebuggerAgent::pause(ErrorString&amp;)
 728 {
 729     schedulePauseOnNextStatement(DebuggerFrontendDispatcher::Reason::PauseOnNextStatement, nullptr);
 730 }
 731 
 732 void InspectorDebuggerAgent::resume(ErrorString&amp; errorString)
 733 {
 734     if (!m_pausedScriptState &amp;&amp; !m_javaScriptPauseScheduled) {
 735         errorString = &quot;Must be paused or waiting to pause&quot;_s;
 736         return;
 737     }
 738 
 739     cancelPauseOnNextStatement();
 740     m_scriptDebugServer.continueProgram();
 741     m_conditionToDispatchResumed = ShouldDispatchResumed::WhenContinued;
 742 }
 743 
 744 void InspectorDebuggerAgent::stepOver(ErrorString&amp; errorString)
 745 {
 746     if (!assertPaused(errorString))
 747         return;
 748 
 749     willStepAndMayBecomeIdle();
 750     m_scriptDebugServer.stepOverStatement();
 751 }
 752 
 753 void InspectorDebuggerAgent::stepInto(ErrorString&amp; errorString)
 754 {
 755     if (!assertPaused(errorString))
 756         return;
 757 
 758     willStepAndMayBecomeIdle();
 759     m_scriptDebugServer.stepIntoStatement();
 760 }
 761 
 762 void InspectorDebuggerAgent::stepOut(ErrorString&amp; errorString)
 763 {
 764     if (!assertPaused(errorString))
 765         return;
 766 
 767     willStepAndMayBecomeIdle();
 768     m_scriptDebugServer.stepOutOfFunction();
 769 }
 770 
 771 void InspectorDebuggerAgent::registerIdleHandler()
 772 {
 773     if (!m_registeredIdleCallback) {
 774         m_registeredIdleCallback = true;
 775         JSC::VM&amp; vm = m_scriptDebugServer.vm();
 776         vm.whenIdle([this]() {
 777             didBecomeIdle();
 778         });
 779     }
 780 }
 781 
 782 void InspectorDebuggerAgent::willStepAndMayBecomeIdle()
 783 {
 784     // When stepping the backend must eventually trigger a &quot;paused&quot; or &quot;resumed&quot; event.
 785     // If the step causes us to exit the VM, then we should issue &quot;resumed&quot;.
 786     m_conditionToDispatchResumed = ShouldDispatchResumed::WhenIdle;
 787 
 788     registerIdleHandler();
 789 }
 790 
 791 void InspectorDebuggerAgent::didBecomeIdle()
 792 {
 793     m_registeredIdleCallback = false;
 794 
 795     if (m_conditionToDispatchResumed == ShouldDispatchResumed::WhenIdle) {
 796         cancelPauseOnNextStatement();
 797         m_scriptDebugServer.continueProgram();
 798         m_frontendDispatcher-&gt;resumed();
 799     }
 800 
 801     m_conditionToDispatchResumed = ShouldDispatchResumed::No;
 802 
 803     if (m_enablePauseWhenIdle) {
 804         ErrorString ignored;
 805         pause(ignored);
 806     }
 807 }
 808 
 809 void InspectorDebuggerAgent::setPauseOnExceptions(ErrorString&amp; errorString, const String&amp; stringPauseState)
 810 {
 811     JSC::Debugger::PauseOnExceptionsState pauseState;
 812     if (stringPauseState == &quot;none&quot;)
 813         pauseState = JSC::Debugger::DontPauseOnExceptions;
 814     else if (stringPauseState == &quot;all&quot;)
 815         pauseState = JSC::Debugger::PauseOnAllExceptions;
 816     else if (stringPauseState == &quot;uncaught&quot;)
 817         pauseState = JSC::Debugger::PauseOnUncaughtExceptions;
 818     else {
 819         errorString = makeString(&quot;Unknown state: &quot;_s, stringPauseState);
 820         return;
 821     }
 822 
 823     m_scriptDebugServer.setPauseOnExceptionsState(static_cast&lt;JSC::Debugger::PauseOnExceptionsState&gt;(pauseState));
 824     if (m_scriptDebugServer.pauseOnExceptionsState() != pauseState)
 825         errorString = &quot;Internal error. Could not change pause on exceptions state&quot;_s;
 826 }
 827 
 828 void InspectorDebuggerAgent::setPauseOnAssertions(ErrorString&amp;, bool enabled)
 829 {
 830     m_pauseOnAssertionFailures = enabled;
 831 }
 832 
 833 void InspectorDebuggerAgent::setPauseOnMicrotasks(ErrorString&amp;, bool enabled)
 834 {
 835     m_pauseOnMicrotasks = enabled;
 836 }
 837 
 838 void InspectorDebuggerAgent::evaluateOnCallFrame(ErrorString&amp; errorString, const String&amp; callFrameId, const String&amp; expression, const String* objectGroup, const bool* includeCommandLineAPI, const bool* doNotPauseOnExceptionsAndMuteConsole, const bool* returnByValue, const bool* generatePreview, const bool* saveResult, const bool* /* emulateUserGesture */, RefPtr&lt;Protocol::Runtime::RemoteObject&gt;&amp; result, Optional&lt;bool&gt;&amp; wasThrown, Optional&lt;int&gt;&amp; savedResultIndex)
 839 {
 840     if (!assertPaused(errorString))
 841         return;
 842 
 843     InjectedScript injectedScript = m_injectedScriptManager.injectedScriptForObjectId(callFrameId);
 844     if (injectedScript.hasNoValue()) {
 845         errorString = &quot;Missing injected script for given callFrameId&quot;_s;
 846         return;
 847     }
 848 
 849     auto pauseState = m_scriptDebugServer.pauseOnExceptionsState();
 850     bool pauseAndMute = doNotPauseOnExceptionsAndMuteConsole &amp;&amp; *doNotPauseOnExceptionsAndMuteConsole;
 851     if (pauseAndMute) {
 852         if (pauseState != JSC::Debugger::DontPauseOnExceptions)
 853             m_scriptDebugServer.setPauseOnExceptionsState(JSC::Debugger::DontPauseOnExceptions);
 854         muteConsole();
 855     }
 856 
 857     injectedScript.evaluateOnCallFrame(errorString, m_currentCallStack.get(), callFrameId, expression,
 858         objectGroup ? *objectGroup : emptyString(), includeCommandLineAPI &amp;&amp; *includeCommandLineAPI, returnByValue &amp;&amp; *returnByValue, generatePreview &amp;&amp; *generatePreview, saveResult &amp;&amp; *saveResult,
 859         result, wasThrown, savedResultIndex);
 860 
 861     if (pauseAndMute) {
 862         unmuteConsole();
 863         m_scriptDebugServer.setPauseOnExceptionsState(pauseState);
 864     }
 865 }
 866 
 867 void InspectorDebuggerAgent::scriptExecutionBlockedByCSP(const String&amp; directiveText)
 868 {
 869     if (m_scriptDebugServer.pauseOnExceptionsState() != JSC::Debugger::DontPauseOnExceptions)
 870         breakProgram(DebuggerFrontendDispatcher::Reason::CSPViolation, buildCSPViolationPauseReason(directiveText));
 871 }
 872 
 873 Ref&lt;JSON::ArrayOf&lt;Protocol::Debugger::CallFrame&gt;&gt; InspectorDebuggerAgent::currentCallFrames(const InjectedScript&amp; injectedScript)
 874 {
 875     ASSERT(!injectedScript.hasNoValue());
 876     if (injectedScript.hasNoValue())
 877         return JSON::ArrayOf&lt;Protocol::Debugger::CallFrame&gt;::create();
 878 
 879     return injectedScript.wrapCallFrames(m_currentCallStack.get());
 880 }
 881 
 882 String InspectorDebuggerAgent::sourceMapURLForScript(const Script&amp; script)
 883 {
 884     return script.sourceMappingURL;
 885 }
 886 
 887 void InspectorDebuggerAgent::setPauseForInternalScripts(ErrorString&amp;, bool shouldPause)
 888 {
 889     if (shouldPause == m_pauseForInternalScripts)
 890         return;
 891 
 892     m_pauseForInternalScripts = shouldPause;
 893 
 894     if (m_pauseForInternalScripts)
 895         m_scriptDebugServer.clearBlacklist();
 896 }
 897 
 898 static bool isWebKitInjectedScript(const String&amp; sourceURL)
 899 {
 900     return sourceURL.startsWith(&quot;__InjectedScript_&quot;) &amp;&amp; sourceURL.endsWith(&quot;.js&quot;);
 901 }
 902 
 903 void InspectorDebuggerAgent::didParseSource(JSC::SourceID sourceID, const Script&amp; script)
 904 {
 905     String scriptIDStr = String::number(sourceID);
 906     bool hasSourceURL = !script.sourceURL.isEmpty();
 907     String sourceURL = script.sourceURL;
 908     String sourceMappingURL = sourceMapURLForScript(script);
 909 
 910     const bool isModule = script.sourceProvider-&gt;sourceType() == JSC::SourceProviderSourceType::Module;
 911     const bool* isContentScript = script.isContentScript ? &amp;script.isContentScript : nullptr;
 912     String* sourceURLParam = hasSourceURL ? &amp;sourceURL : nullptr;
 913     String* sourceMapURLParam = sourceMappingURL.isEmpty() ? nullptr : &amp;sourceMappingURL;
 914 
 915     m_frontendDispatcher-&gt;scriptParsed(scriptIDStr, script.url, script.startLine, script.startColumn, script.endLine, script.endColumn, isContentScript, sourceURLParam, sourceMapURLParam, isModule ? &amp;isModule : nullptr);
 916 
 917     m_scripts.set(sourceID, script);
 918 
 919     if (hasSourceURL &amp;&amp; isWebKitInjectedScript(sourceURL) &amp;&amp; !m_pauseForInternalScripts)
 920         m_scriptDebugServer.addToBlacklist(sourceID);
 921 
 922     String scriptURLForBreakpoints = hasSourceURL ? script.sourceURL : script.url;
 923     if (scriptURLForBreakpoints.isEmpty())
 924         return;
 925 
 926     for (auto&amp; entry : m_javaScriptBreakpoints) {
 927         RefPtr&lt;JSON::Object&gt; breakpointObject = entry.value;
 928 
 929         bool isRegex;
 930         String url;
 931         breakpointObject-&gt;getBoolean(&quot;isRegex&quot;_s, isRegex);
 932         breakpointObject-&gt;getString(&quot;url&quot;_s, url);
 933         if (!matches(scriptURLForBreakpoints, url, isRegex))
 934             continue;
 935 
 936         ScriptBreakpoint scriptBreakpoint;
 937         breakpointObject-&gt;getInteger(&quot;lineNumber&quot;_s, scriptBreakpoint.lineNumber);
 938         breakpointObject-&gt;getInteger(&quot;columnNumber&quot;_s, scriptBreakpoint.columnNumber);
 939         breakpointObject-&gt;getString(&quot;condition&quot;_s, scriptBreakpoint.condition);
 940         breakpointObject-&gt;getBoolean(&quot;autoContinue&quot;_s, scriptBreakpoint.autoContinue);
 941         breakpointObject-&gt;getInteger(&quot;ignoreCount&quot;_s, scriptBreakpoint.ignoreCount);
 942         ErrorString errorString;
 943         RefPtr&lt;JSON::Array&gt; actions;
 944         breakpointObject-&gt;getArray(&quot;actions&quot;_s, actions);
 945         if (!breakpointActionsFromProtocol(errorString, actions, &amp;scriptBreakpoint.actions)) {
 946             ASSERT_NOT_REACHED();
 947             continue;
 948         }
 949 
 950         JSC::Breakpoint breakpoint(sourceID, scriptBreakpoint.lineNumber, scriptBreakpoint.columnNumber, scriptBreakpoint.condition, scriptBreakpoint.autoContinue, scriptBreakpoint.ignoreCount);
 951         resolveBreakpoint(script, breakpoint);
 952         if (!breakpoint.resolved)
 953             continue;
 954 
 955         bool existing;
 956         setBreakpoint(breakpoint, existing);
 957         if (existing)
 958             continue;
 959 
 960         String breakpointIdentifier = entry.key;
 961         didSetBreakpoint(breakpoint, breakpointIdentifier, scriptBreakpoint);
 962 
 963         m_frontendDispatcher-&gt;breakpointResolved(breakpointIdentifier, buildDebuggerLocation(breakpoint));
 964     }
 965 }
 966 
 967 void InspectorDebuggerAgent::failedToParseSource(const String&amp; url, const String&amp; data, int firstLine, int errorLine, const String&amp; errorMessage)
 968 {
 969     m_frontendDispatcher-&gt;scriptFailedToParse(url, data, firstLine, errorLine, errorMessage);
 970 }
 971 
 972 void InspectorDebuggerAgent::willRunMicrotask()
 973 {
 974     if (!m_scriptDebugServer.breakpointsActive())
 975         return;
 976 
 977     if (m_pauseOnMicrotasks)
 978         schedulePauseOnNextStatement(DebuggerFrontendDispatcher::Reason::Microtask, nullptr);
 979 }
 980 
 981 void InspectorDebuggerAgent::didRunMicrotask()
 982 {
 983     if (!m_scriptDebugServer.breakpointsActive())
 984         return;
 985 
 986     if (m_pauseOnMicrotasks)
 987         cancelPauseOnNextStatement();
 988 }
 989 
 990 void InspectorDebuggerAgent::didPause(JSC::ExecState&amp; scriptState, JSC::JSValue callFrames, JSC::JSValue exceptionOrCaughtValue)
 991 {
 992     ASSERT(!m_pausedScriptState);
 993     m_pausedScriptState = &amp;scriptState;
 994     m_currentCallStack = { scriptState.vm(), callFrames };
 995 
 996     InjectedScript injectedScript = m_injectedScriptManager.injectedScriptFor(&amp;scriptState);
 997 
 998     // If a high level pause pause reason is not already set, try to infer a reason from the debugger.
 999     if (m_breakReason == DebuggerFrontendDispatcher::Reason::Other) {
1000         switch (m_scriptDebugServer.reasonForPause()) {
1001         case JSC::Debugger::PausedForBreakpoint: {
1002             JSC::BreakpointID debuggerBreakpointId = m_scriptDebugServer.pausingBreakpointID();
1003             if (debuggerBreakpointId != m_continueToLocationBreakpointID) {
1004                 m_breakReason = DebuggerFrontendDispatcher::Reason::Breakpoint;
1005                 m_breakData = buildBreakpointPauseReason(debuggerBreakpointId);
1006             }
1007             break;
1008         }
1009         case JSC::Debugger::PausedForDebuggerStatement:
1010             m_breakReason = DebuggerFrontendDispatcher::Reason::DebuggerStatement;
1011             m_breakData = nullptr;
1012             break;
1013         case JSC::Debugger::PausedForException:
1014             m_breakReason = DebuggerFrontendDispatcher::Reason::Exception;
1015             m_breakData = buildExceptionPauseReason(exceptionOrCaughtValue, injectedScript);
1016             break;
1017         case JSC::Debugger::PausedAtStatement:
1018         case JSC::Debugger::PausedAtExpression:
1019         case JSC::Debugger::PausedBeforeReturn:
1020         case JSC::Debugger::PausedAtEndOfProgram:
1021             // Pause was just stepping. Nothing to report.
1022             break;
1023         case JSC::Debugger::NotPaused:
1024             ASSERT_NOT_REACHED();
1025             break;
1026         }
1027     }
1028 
1029     // Set $exception to the exception or caught value.
1030     if (exceptionOrCaughtValue &amp;&amp; !injectedScript.hasNoValue()) {
1031         injectedScript.setExceptionValue(exceptionOrCaughtValue);
1032         m_hasExceptionValue = true;
1033     }
1034 
1035     m_conditionToDispatchResumed = ShouldDispatchResumed::No;
1036     m_enablePauseWhenIdle = false;
1037 
1038     RefPtr&lt;Protocol::Console::StackTrace&gt; asyncStackTrace;
1039     if (m_currentAsyncCallIdentifier) {
1040         auto it = m_pendingAsyncCalls.find(m_currentAsyncCallIdentifier.value());
1041         if (it != m_pendingAsyncCalls.end())
1042             asyncStackTrace = it-&gt;value-&gt;buildInspectorObject();
1043     }
1044 
1045     m_frontendDispatcher-&gt;paused(currentCallFrames(injectedScript), m_breakReason, m_breakData, asyncStackTrace);
1046 
1047     m_javaScriptPauseScheduled = false;
1048 
1049     if (m_continueToLocationBreakpointID != JSC::noBreakpointID) {
1050         m_scriptDebugServer.removeBreakpoint(m_continueToLocationBreakpointID);
1051         m_continueToLocationBreakpointID = JSC::noBreakpointID;
1052     }
1053 
1054     RefPtr&lt;Stopwatch&gt; stopwatch = m_injectedScriptManager.inspectorEnvironment().executionStopwatch();
1055     if (stopwatch &amp;&amp; stopwatch-&gt;isActive()) {
1056         stopwatch-&gt;stop();
1057         m_didPauseStopwatch = true;
1058     }
1059 }
1060 
1061 void InspectorDebuggerAgent::breakpointActionSound(int breakpointActionIdentifier)
1062 {
1063     m_frontendDispatcher-&gt;playBreakpointActionSound(breakpointActionIdentifier);
1064 }
1065 
1066 void InspectorDebuggerAgent::breakpointActionProbe(JSC::ExecState&amp; scriptState, const ScriptBreakpointAction&amp; action, unsigned batchId, unsigned sampleId, JSC::JSValue sample)
1067 {
1068     InjectedScript injectedScript = m_injectedScriptManager.injectedScriptFor(&amp;scriptState);
1069     auto payload = injectedScript.wrapObject(sample, objectGroupForBreakpointAction(action), true);
1070     auto result = Protocol::Debugger::ProbeSample::create()
1071         .setProbeId(action.identifier)
1072         .setBatchId(batchId)
1073         .setSampleId(sampleId)
1074         .setTimestamp(m_injectedScriptManager.inspectorEnvironment().executionStopwatch()-&gt;elapsedTime().seconds())
1075         .setPayload(WTFMove(payload))
1076         .release();
1077     m_frontendDispatcher-&gt;didSampleProbe(WTFMove(result));
1078 }
1079 
1080 void InspectorDebuggerAgent::didContinue()
1081 {
1082     if (m_didPauseStopwatch) {
1083         m_didPauseStopwatch = false;
1084         m_injectedScriptManager.inspectorEnvironment().executionStopwatch()-&gt;start();
1085     }
1086 
1087     m_pausedScriptState = nullptr;
1088     m_currentCallStack = { };
1089     m_injectedScriptManager.releaseObjectGroup(InspectorDebuggerAgent::backtraceObjectGroup);
1090     clearBreakDetails();
1091     clearExceptionValue();
1092 
1093     if (m_conditionToDispatchResumed == ShouldDispatchResumed::WhenContinued)
1094         m_frontendDispatcher-&gt;resumed();
1095 }
1096 
1097 void InspectorDebuggerAgent::breakProgram(DebuggerFrontendDispatcher::Reason breakReason, RefPtr&lt;JSON::Object&gt;&amp;&amp; data)
1098 {
1099     m_breakReason = breakReason;
1100     m_breakData = WTFMove(data);
1101     m_scriptDebugServer.breakProgram();
1102 }
1103 
1104 void InspectorDebuggerAgent::clearInspectorBreakpointState()
1105 {
1106     ErrorString ignored;
1107     for (const String&amp; identifier : copyToVector(m_breakpointIdentifierToDebugServerBreakpointIDs.keys()))
1108         removeBreakpoint(ignored, identifier);
1109 
1110     m_javaScriptBreakpoints.clear();
1111 
1112     clearDebuggerBreakpointState();
1113 }
1114 
1115 void InspectorDebuggerAgent::clearDebuggerBreakpointState()
1116 {
1117     {
1118         JSC::JSLockHolder holder(m_scriptDebugServer.vm());
1119         m_scriptDebugServer.clearBreakpointActions();
1120         m_scriptDebugServer.clearBreakpoints();
1121         m_scriptDebugServer.clearBlacklist();
1122     }
1123 
1124     m_pausedScriptState = nullptr;
1125     m_currentCallStack = { };
1126     m_scripts.clear();
1127     m_breakpointIdentifierToDebugServerBreakpointIDs.clear();
1128     m_debuggerBreakpointIdentifierToInspectorBreakpointIdentifier.clear();
1129     m_continueToLocationBreakpointID = JSC::noBreakpointID;
1130     clearBreakDetails();
1131     m_javaScriptPauseScheduled = false;
1132     m_hasExceptionValue = false;
1133 
1134     if (isPaused()) {
1135         m_scriptDebugServer.continueProgram();
1136         m_frontendDispatcher-&gt;resumed();
1137     }
1138 }
1139 
1140 void InspectorDebuggerAgent::didClearGlobalObject()
1141 {
1142     // Clear breakpoints from the debugger, but keep the inspector&#39;s model of which
1143     // pages have what breakpoints, as the mapping is only sent to DebuggerAgent once.
1144     clearDebuggerBreakpointState();
1145 
1146     clearAsyncStackTraceData();
1147 
1148     m_frontendDispatcher-&gt;globalObjectCleared();
1149 }
1150 
1151 bool InspectorDebuggerAgent::assertPaused(ErrorString&amp; errorString)
1152 {
1153     if (!m_pausedScriptState) {
1154         errorString = &quot;Must be paused&quot;_s;
1155         return false;
1156     }
1157 
1158     return true;
1159 }
1160 
1161 void InspectorDebuggerAgent::clearBreakDetails()
1162 {
1163     m_breakReason = DebuggerFrontendDispatcher::Reason::Other;
1164     m_breakData = nullptr;
1165 }
1166 
1167 void InspectorDebuggerAgent::clearExceptionValue()
1168 {
1169     if (m_hasExceptionValue) {
1170         m_injectedScriptManager.clearExceptionValue();
1171         m_hasExceptionValue = false;
1172     }
1173 }
1174 
1175 void InspectorDebuggerAgent::clearAsyncStackTraceData()
1176 {
1177     m_pendingAsyncCalls.clear();
1178     m_currentAsyncCallIdentifier = WTF::nullopt;
1179 
1180     didClearAsyncStackTraceData();
1181 }
1182 
1183 } // namespace Inspector
    </pre>
  </body>
</html>