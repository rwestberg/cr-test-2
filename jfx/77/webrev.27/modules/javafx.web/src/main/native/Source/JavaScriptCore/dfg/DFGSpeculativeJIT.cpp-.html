<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGSpeculativeJIT.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
    1 /*
    2  * Copyright (C) 2011-2019 Apple Inc. All rights reserved.
    3  *
    4  * Redistribution and use in source and binary forms, with or without
    5  * modification, are permitted provided that the following conditions
    6  * are met:
    7  * 1. Redistributions of source code must retain the above copyright
    8  *    notice, this list of conditions and the following disclaimer.
    9  * 2. Redistributions in binary form must reproduce the above copyright
   10  *    notice, this list of conditions and the following disclaimer in the
   11  *    documentation and/or other materials provided with the distribution.
   12  *
   13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
   14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
   16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
   17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
   18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
   19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
   21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   24  */
   25 
   26 #include &quot;config.h&quot;
   27 #include &quot;DFGSpeculativeJIT.h&quot;
   28 
   29 #if ENABLE(DFG_JIT)
   30 
   31 #include &quot;BinarySwitch.h&quot;
   32 #include &quot;DFGAbstractInterpreterInlines.h&quot;
   33 #include &quot;DFGArrayifySlowPathGenerator.h&quot;
   34 #include &quot;DFGCallArrayAllocatorSlowPathGenerator.h&quot;
   35 #include &quot;DFGCallCreateDirectArgumentsSlowPathGenerator.h&quot;
   36 #include &quot;DFGCapabilities.h&quot;
   37 #include &quot;DFGMayExit.h&quot;
   38 #include &quot;DFGOSRExitFuzz.h&quot;
   39 #include &quot;DFGSaneStringGetByValSlowPathGenerator.h&quot;
   40 #include &quot;DFGSlowPathGenerator.h&quot;
   41 #include &quot;DFGSnippetParams.h&quot;
   42 #include &quot;DirectArguments.h&quot;
   43 #include &quot;JITAddGenerator.h&quot;
   44 #include &quot;JITBitAndGenerator.h&quot;
   45 #include &quot;JITBitOrGenerator.h&quot;
   46 #include &quot;JITBitXorGenerator.h&quot;
   47 #include &quot;JITDivGenerator.h&quot;
   48 #include &quot;JITLeftShiftGenerator.h&quot;
   49 #include &quot;JITMulGenerator.h&quot;
   50 #include &quot;JITRightShiftGenerator.h&quot;
   51 #include &quot;JITSubGenerator.h&quot;
   52 #include &quot;JSAsyncFunction.h&quot;
   53 #include &quot;JSAsyncGeneratorFunction.h&quot;
   54 #include &quot;JSCInlines.h&quot;
   55 #include &quot;JSFixedArray.h&quot;
   56 #include &quot;JSGeneratorFunction.h&quot;
   57 #include &quot;JSImmutableButterfly.h&quot;
   58 #include &quot;JSLexicalEnvironment.h&quot;
   59 #include &quot;JSPropertyNameEnumerator.h&quot;
   60 #include &quot;LinkBuffer.h&quot;
   61 #include &quot;RegExpObject.h&quot;
   62 #include &quot;ScopedArguments.h&quot;
   63 #include &quot;ScratchRegisterAllocator.h&quot;
   64 #include &quot;SuperSampler.h&quot;
   65 #include &quot;TypeProfilerLog.h&quot;
   66 #include &quot;WeakMapImpl.h&quot;
   67 #include &lt;wtf/BitVector.h&gt;
   68 #include &lt;wtf/Box.h&gt;
   69 #include &lt;wtf/MathExtras.h&gt;
   70 
   71 namespace JSC { namespace DFG {
   72 
   73 SpeculativeJIT::SpeculativeJIT(JITCompiler&amp; jit)
   74     : m_compileOkay(true)
   75     , m_jit(jit)
   76     , m_graph(m_jit.graph())
   77     , m_currentNode(0)
   78     , m_lastGeneratedNode(LastNodeType)
   79     , m_indexInBlock(0)
   80     , m_generationInfo(m_jit.graph().frameRegisterCount())
   81     , m_state(m_jit.graph())
   82     , m_interpreter(m_jit.graph(), m_state)
   83     , m_stream(&amp;jit.jitCode()-&gt;variableEventStream)
   84     , m_minifiedGraph(&amp;jit.jitCode()-&gt;minifiedDFG)
   85 {
   86 }
   87 
   88 SpeculativeJIT::~SpeculativeJIT()
   89 {
   90 }
   91 
   92 void SpeculativeJIT::emitAllocateRawObject(GPRReg resultGPR, RegisteredStructure structure, GPRReg storageGPR, unsigned numElements, unsigned vectorLength)
   93 {
   94     ASSERT(!isCopyOnWrite(structure-&gt;indexingMode()));
   95     IndexingType indexingType = structure-&gt;indexingType();
   96     bool hasIndexingHeader = hasIndexedProperties(indexingType);
   97 
   98     unsigned inlineCapacity = structure-&gt;inlineCapacity();
   99     unsigned outOfLineCapacity = structure-&gt;outOfLineCapacity();
  100 
  101     GPRTemporary scratch(this);
  102     GPRTemporary scratch2(this);
  103     GPRReg scratchGPR = scratch.gpr();
  104     GPRReg scratch2GPR = scratch2.gpr();
  105 
  106     ASSERT(vectorLength &gt;= numElements);
  107     vectorLength = Butterfly::optimalContiguousVectorLength(structure.get(), vectorLength);
  108 
  109     JITCompiler::JumpList slowCases;
  110 
  111     size_t size = 0;
  112     if (hasIndexingHeader)
  113         size += vectorLength * sizeof(JSValue) + sizeof(IndexingHeader);
  114     size += outOfLineCapacity * sizeof(JSValue);
  115 
  116     m_jit.move(TrustedImmPtr(nullptr), storageGPR);
  117 
  118     if (size) {
  119         if (Allocator allocator = m_jit.vm()-&gt;jsValueGigacageAuxiliarySpace.allocatorForNonVirtual(size, AllocatorForMode::AllocatorIfExists)) {
  120             m_jit.emitAllocate(storageGPR, JITAllocator::constant(allocator), scratchGPR, scratch2GPR, slowCases);
  121 
  122             m_jit.addPtr(
  123                 TrustedImm32(outOfLineCapacity * sizeof(JSValue) + sizeof(IndexingHeader)),
  124                 storageGPR);
  125 
  126             if (hasIndexingHeader)
  127                 m_jit.store32(TrustedImm32(vectorLength), MacroAssembler::Address(storageGPR, Butterfly::offsetOfVectorLength()));
  128         } else
  129             slowCases.append(m_jit.jump());
  130     }
  131 
  132     size_t allocationSize = JSFinalObject::allocationSize(inlineCapacity);
  133     Allocator allocator = allocatorForNonVirtualConcurrently&lt;JSFinalObject&gt;(*m_jit.vm(), allocationSize, AllocatorForMode::AllocatorIfExists);
  134     if (allocator) {
  135         emitAllocateJSObject(resultGPR, JITAllocator::constant(allocator), scratchGPR, TrustedImmPtr(structure), storageGPR, scratch2GPR, slowCases);
  136         m_jit.emitInitializeInlineStorage(resultGPR, structure-&gt;inlineCapacity());
  137     } else
  138         slowCases.append(m_jit.jump());
  139 
  140     // I want a slow path that also loads out the storage pointer, and that&#39;s
  141     // what this custom CallArrayAllocatorSlowPathGenerator gives me. It&#39;s a lot
  142     // of work for a very small piece of functionality. :-/
  143     addSlowPathGenerator(std::make_unique&lt;CallArrayAllocatorSlowPathGenerator&gt;(
  144         slowCases, this, operationNewRawObject, resultGPR, storageGPR,
  145         structure, vectorLength));
  146 
  147     if (numElements &lt; vectorLength) {
  148 #if USE(JSVALUE64)
  149         if (hasDouble(structure-&gt;indexingType()))
  150             m_jit.move(TrustedImm64(bitwise_cast&lt;int64_t&gt;(PNaN)), scratchGPR);
  151         else
  152             m_jit.move(TrustedImm64(JSValue::encode(JSValue())), scratchGPR);
  153         for (unsigned i = numElements; i &lt; vectorLength; ++i)
  154             m_jit.store64(scratchGPR, MacroAssembler::Address(storageGPR, sizeof(double) * i));
  155 #else
  156         EncodedValueDescriptor value;
  157         if (hasDouble(structure-&gt;indexingType()))
  158             value.asInt64 = JSValue::encode(JSValue(JSValue::EncodeAsDouble, PNaN));
  159         else
  160             value.asInt64 = JSValue::encode(JSValue());
  161         for (unsigned i = numElements; i &lt; vectorLength; ++i) {
  162             m_jit.store32(TrustedImm32(value.asBits.tag), MacroAssembler::Address(storageGPR, sizeof(double) * i + OBJECT_OFFSETOF(JSValue, u.asBits.tag)));
  163             m_jit.store32(TrustedImm32(value.asBits.payload), MacroAssembler::Address(storageGPR, sizeof(double) * i + OBJECT_OFFSETOF(JSValue, u.asBits.payload)));
  164         }
  165 #endif
  166     }
  167 
  168     if (hasIndexingHeader)
  169         m_jit.store32(TrustedImm32(numElements), MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()));
  170 
  171     m_jit.emitInitializeOutOfLineStorage(storageGPR, structure-&gt;outOfLineCapacity());
  172 
  173     m_jit.mutatorFence(*m_jit.vm());
  174 }
  175 
  176 void SpeculativeJIT::emitGetLength(InlineCallFrame* inlineCallFrame, GPRReg lengthGPR, bool includeThis)
  177 {
  178     if (inlineCallFrame &amp;&amp; !inlineCallFrame-&gt;isVarargs())
  179         m_jit.move(TrustedImm32(inlineCallFrame-&gt;argumentCountIncludingThis - !includeThis), lengthGPR);
  180     else {
  181         VirtualRegister argumentCountRegister = m_jit.argumentCount(inlineCallFrame);
  182         m_jit.load32(JITCompiler::payloadFor(argumentCountRegister), lengthGPR);
  183         if (!includeThis)
  184             m_jit.sub32(TrustedImm32(1), lengthGPR);
  185     }
  186 }
  187 
  188 void SpeculativeJIT::emitGetLength(CodeOrigin origin, GPRReg lengthGPR, bool includeThis)
  189 {
  190     emitGetLength(origin.inlineCallFrame, lengthGPR, includeThis);
  191 }
  192 
  193 void SpeculativeJIT::emitGetCallee(CodeOrigin origin, GPRReg calleeGPR)
  194 {
  195     if (origin.inlineCallFrame) {
  196         if (origin.inlineCallFrame-&gt;isClosureCall) {
  197             m_jit.loadPtr(
  198                 JITCompiler::addressFor(origin.inlineCallFrame-&gt;calleeRecovery.virtualRegister()),
  199                 calleeGPR);
  200         } else {
  201             m_jit.move(
  202                 TrustedImmPtr::weakPointer(m_jit.graph(), origin.inlineCallFrame-&gt;calleeRecovery.constant().asCell()),
  203                 calleeGPR);
  204         }
  205     } else
  206         m_jit.loadPtr(JITCompiler::addressFor(CallFrameSlot::callee), calleeGPR);
  207 }
  208 
  209 void SpeculativeJIT::emitGetArgumentStart(CodeOrigin origin, GPRReg startGPR)
  210 {
  211     m_jit.addPtr(
  212         TrustedImm32(
  213             JITCompiler::argumentsStart(origin).offset() * static_cast&lt;int&gt;(sizeof(Register))),
  214         GPRInfo::callFrameRegister, startGPR);
  215 }
  216 
  217 MacroAssembler::Jump SpeculativeJIT::emitOSRExitFuzzCheck()
  218 {
  219     if (!Options::useOSRExitFuzz()
  220         || !canUseOSRExitFuzzing(m_jit.graph().baselineCodeBlockFor(m_origin.semantic))
  221         || !doOSRExitFuzzing())
  222         return MacroAssembler::Jump();
  223 
  224     MacroAssembler::Jump result;
  225 
  226     m_jit.pushToSave(GPRInfo::regT0);
  227     m_jit.load32(&amp;g_numberOfOSRExitFuzzChecks, GPRInfo::regT0);
  228     m_jit.add32(TrustedImm32(1), GPRInfo::regT0);
  229     m_jit.store32(GPRInfo::regT0, &amp;g_numberOfOSRExitFuzzChecks);
  230     unsigned atOrAfter = Options::fireOSRExitFuzzAtOrAfter();
  231     unsigned at = Options::fireOSRExitFuzzAt();
  232     if (at || atOrAfter) {
  233         unsigned threshold;
  234         MacroAssembler::RelationalCondition condition;
  235         if (atOrAfter) {
  236             threshold = atOrAfter;
  237             condition = MacroAssembler::Below;
  238         } else {
  239             threshold = at;
  240             condition = MacroAssembler::NotEqual;
  241         }
  242         MacroAssembler::Jump ok = m_jit.branch32(
  243             condition, GPRInfo::regT0, MacroAssembler::TrustedImm32(threshold));
  244         m_jit.popToRestore(GPRInfo::regT0);
  245         result = m_jit.jump();
  246         ok.link(&amp;m_jit);
  247     }
  248     m_jit.popToRestore(GPRInfo::regT0);
  249 
  250     return result;
  251 }
  252 
  253 void SpeculativeJIT::speculationCheck(ExitKind kind, JSValueSource jsValueSource, Node* node, MacroAssembler::Jump jumpToFail)
  254 {
  255     if (!m_compileOkay)
  256         return;
  257     JITCompiler::Jump fuzzJump = emitOSRExitFuzzCheck();
  258     if (fuzzJump.isSet()) {
  259         JITCompiler::JumpList jumpsToFail;
  260         jumpsToFail.append(fuzzJump);
  261         jumpsToFail.append(jumpToFail);
  262         m_jit.appendExitInfo(jumpsToFail);
  263     } else
  264         m_jit.appendExitInfo(jumpToFail);
  265     m_jit.jitCode()-&gt;appendOSRExit(OSRExit(kind, jsValueSource, m_jit.graph().methodOfGettingAValueProfileFor(m_currentNode, node), this, m_stream-&gt;size()));
  266 }
  267 
  268 void SpeculativeJIT::speculationCheck(ExitKind kind, JSValueSource jsValueSource, Node* node, const MacroAssembler::JumpList&amp; jumpsToFail)
  269 {
  270     if (!m_compileOkay)
  271         return;
  272     JITCompiler::Jump fuzzJump = emitOSRExitFuzzCheck();
  273     if (fuzzJump.isSet()) {
  274         JITCompiler::JumpList myJumpsToFail;
  275         myJumpsToFail.append(jumpsToFail);
  276         myJumpsToFail.append(fuzzJump);
  277         m_jit.appendExitInfo(myJumpsToFail);
  278     } else
  279         m_jit.appendExitInfo(jumpsToFail);
  280     m_jit.jitCode()-&gt;appendOSRExit(OSRExit(kind, jsValueSource, m_jit.graph().methodOfGettingAValueProfileFor(m_currentNode, node), this, m_stream-&gt;size()));
  281 }
  282 
  283 OSRExitJumpPlaceholder SpeculativeJIT::speculationCheck(ExitKind kind, JSValueSource jsValueSource, Node* node)
  284 {
  285     if (!m_compileOkay)
  286         return OSRExitJumpPlaceholder();
  287     unsigned index = m_jit.jitCode()-&gt;osrExit.size();
  288     m_jit.appendExitInfo();
  289     m_jit.jitCode()-&gt;appendOSRExit(OSRExit(kind, jsValueSource, m_jit.graph().methodOfGettingAValueProfileFor(m_currentNode, node), this, m_stream-&gt;size()));
  290     return OSRExitJumpPlaceholder(index);
  291 }
  292 
  293 OSRExitJumpPlaceholder SpeculativeJIT::speculationCheck(ExitKind kind, JSValueSource jsValueSource, Edge nodeUse)
  294 {
  295     return speculationCheck(kind, jsValueSource, nodeUse.node());
  296 }
  297 
  298 void SpeculativeJIT::speculationCheck(ExitKind kind, JSValueSource jsValueSource, Edge nodeUse, MacroAssembler::Jump jumpToFail)
  299 {
  300     speculationCheck(kind, jsValueSource, nodeUse.node(), jumpToFail);
  301 }
  302 
  303 void SpeculativeJIT::speculationCheck(ExitKind kind, JSValueSource jsValueSource, Edge nodeUse, const MacroAssembler::JumpList&amp; jumpsToFail)
  304 {
  305     speculationCheck(kind, jsValueSource, nodeUse.node(), jumpsToFail);
  306 }
  307 
  308 void SpeculativeJIT::speculationCheck(ExitKind kind, JSValueSource jsValueSource, Node* node, MacroAssembler::Jump jumpToFail, const SpeculationRecovery&amp; recovery)
  309 {
  310     if (!m_compileOkay)
  311         return;
  312     unsigned recoveryIndex = m_jit.jitCode()-&gt;appendSpeculationRecovery(recovery);
  313     m_jit.appendExitInfo(jumpToFail);
  314     m_jit.jitCode()-&gt;appendOSRExit(OSRExit(kind, jsValueSource, m_jit.graph().methodOfGettingAValueProfileFor(m_currentNode, node), this, m_stream-&gt;size(), recoveryIndex));
  315 }
  316 
  317 void SpeculativeJIT::speculationCheck(ExitKind kind, JSValueSource jsValueSource, Edge nodeUse, MacroAssembler::Jump jumpToFail, const SpeculationRecovery&amp; recovery)
  318 {
  319     speculationCheck(kind, jsValueSource, nodeUse.node(), jumpToFail, recovery);
  320 }
  321 
  322 void SpeculativeJIT::emitInvalidationPoint(Node* node)
  323 {
  324     if (!m_compileOkay)
  325         return;
  326     OSRExitCompilationInfo&amp; info = m_jit.appendExitInfo(JITCompiler::JumpList());
  327     m_jit.jitCode()-&gt;appendOSRExit(OSRExit(
  328         UncountableInvalidation, JSValueSource(), MethodOfGettingAValueProfile(),
  329         this, m_stream-&gt;size()));
  330     info.m_replacementSource = m_jit.watchpointLabel();
  331     ASSERT(info.m_replacementSource.isSet());
  332     noResult(node);
  333 }
  334 
  335 void SpeculativeJIT::unreachable(Node* node)
  336 {
  337     m_compileOkay = false;
  338     m_jit.abortWithReason(DFGUnreachableNode, node-&gt;op());
  339 }
  340 
  341 void SpeculativeJIT::terminateSpeculativeExecution(ExitKind kind, JSValueRegs jsValueRegs, Node* node)
  342 {
  343     if (!m_compileOkay)
  344         return;
  345     speculationCheck(kind, jsValueRegs, node, m_jit.jump());
  346     m_compileOkay = false;
  347     if (verboseCompilationEnabled())
  348         dataLog(&quot;Bailing compilation.\n&quot;);
  349 }
  350 
  351 void SpeculativeJIT::terminateSpeculativeExecution(ExitKind kind, JSValueRegs jsValueRegs, Edge nodeUse)
  352 {
  353     terminateSpeculativeExecution(kind, jsValueRegs, nodeUse.node());
  354 }
  355 
  356 void SpeculativeJIT::typeCheck(JSValueSource source, Edge edge, SpeculatedType typesPassedThrough, MacroAssembler::Jump jumpToFail, ExitKind exitKind)
  357 {
  358     ASSERT(needsTypeCheck(edge, typesPassedThrough));
  359     m_interpreter.filter(edge, typesPassedThrough);
  360     speculationCheck(exitKind, source, edge.node(), jumpToFail);
  361 }
  362 
  363 RegisterSet SpeculativeJIT::usedRegisters()
  364 {
  365     RegisterSet result;
  366 
  367     for (unsigned i = GPRInfo::numberOfRegisters; i--;) {
  368         GPRReg gpr = GPRInfo::toRegister(i);
  369         if (m_gprs.isInUse(gpr))
  370             result.set(gpr);
  371     }
  372     for (unsigned i = FPRInfo::numberOfRegisters; i--;) {
  373         FPRReg fpr = FPRInfo::toRegister(i);
  374         if (m_fprs.isInUse(fpr))
  375             result.set(fpr);
  376     }
  377 
  378     // FIXME: This is overly conservative. We could subtract out those callee-saves that we
  379     // actually saved.
  380     // https://bugs.webkit.org/show_bug.cgi?id=185686
  381     result.merge(RegisterSet::stubUnavailableRegisters());
  382 
  383     return result;
  384 }
  385 
  386 void SpeculativeJIT::addSlowPathGenerator(std::unique_ptr&lt;SlowPathGenerator&gt; slowPathGenerator)
  387 {
  388     m_slowPathGenerators.append(WTFMove(slowPathGenerator));
  389 }
  390 
  391 void SpeculativeJIT::addSlowPathGeneratorLambda(Function&lt;void()&gt;&amp;&amp; lambda)
  392 {
  393     m_slowPathLambdas.append(SlowPathLambda{ WTFMove(lambda), m_currentNode, static_cast&lt;unsigned&gt;(m_stream-&gt;size()) });
  394 }
  395 
  396 void SpeculativeJIT::runSlowPathGenerators(PCToCodeOriginMapBuilder&amp; pcToCodeOriginMapBuilder)
  397 {
  398     for (auto&amp; slowPathGenerator : m_slowPathGenerators) {
  399         pcToCodeOriginMapBuilder.appendItem(m_jit.labelIgnoringWatchpoints(), slowPathGenerator-&gt;origin().semantic);
  400         slowPathGenerator-&gt;generate(this);
  401     }
  402     for (auto&amp; slowPathLambda : m_slowPathLambdas) {
  403         Node* currentNode = slowPathLambda.currentNode;
  404         m_currentNode = currentNode;
  405         m_outOfLineStreamIndex = slowPathLambda.streamIndex;
  406         pcToCodeOriginMapBuilder.appendItem(m_jit.labelIgnoringWatchpoints(), currentNode-&gt;origin.semantic);
  407         slowPathLambda.generator();
  408         m_outOfLineStreamIndex = WTF::nullopt;
  409     }
  410 }
  411 
  412 void SpeculativeJIT::clearGenerationInfo()
  413 {
  414     for (unsigned i = 0; i &lt; m_generationInfo.size(); ++i)
  415         m_generationInfo[i] = GenerationInfo();
  416     m_gprs = RegisterBank&lt;GPRInfo&gt;();
  417     m_fprs = RegisterBank&lt;FPRInfo&gt;();
  418 }
  419 
  420 SilentRegisterSavePlan SpeculativeJIT::silentSavePlanForGPR(VirtualRegister spillMe, GPRReg source)
  421 {
  422     GenerationInfo&amp; info = generationInfoFromVirtualRegister(spillMe);
  423     Node* node = info.node();
  424     DataFormat registerFormat = info.registerFormat();
  425     ASSERT(registerFormat != DataFormatNone);
  426     ASSERT(registerFormat != DataFormatDouble);
  427 
  428     SilentSpillAction spillAction;
  429     SilentFillAction fillAction;
  430 
  431     if (!info.needsSpill())
  432         spillAction = DoNothingForSpill;
  433     else {
  434 #if USE(JSVALUE64)
  435         ASSERT(info.gpr() == source);
  436         if (registerFormat == DataFormatInt32)
  437             spillAction = Store32Payload;
  438         else if (registerFormat == DataFormatCell || registerFormat == DataFormatStorage)
  439             spillAction = StorePtr;
  440         else if (registerFormat == DataFormatInt52 || registerFormat == DataFormatStrictInt52)
  441             spillAction = Store64;
  442         else {
  443             ASSERT(registerFormat &amp; DataFormatJS);
  444             spillAction = Store64;
  445         }
  446 #elif USE(JSVALUE32_64)
  447         if (registerFormat &amp; DataFormatJS) {
  448             ASSERT(info.tagGPR() == source || info.payloadGPR() == source);
  449             spillAction = source == info.tagGPR() ? Store32Tag : Store32Payload;
  450         } else {
  451             ASSERT(info.gpr() == source);
  452             spillAction = Store32Payload;
  453         }
  454 #endif
  455     }
  456 
  457     if (registerFormat == DataFormatInt32) {
  458         ASSERT(info.gpr() == source);
  459         ASSERT(isJSInt32(info.registerFormat()));
  460         if (node-&gt;hasConstant()) {
  461             ASSERT(node-&gt;isInt32Constant());
  462             fillAction = SetInt32Constant;
  463         } else
  464             fillAction = Load32Payload;
  465     } else if (registerFormat == DataFormatBoolean) {
  466 #if USE(JSVALUE64)
  467         RELEASE_ASSERT_NOT_REACHED();
  468 #if COMPILER_QUIRK(CONSIDERS_UNREACHABLE_CODE)
  469         fillAction = DoNothingForFill;
  470 #endif
  471 #elif USE(JSVALUE32_64)
  472         ASSERT(info.gpr() == source);
  473         if (node-&gt;hasConstant()) {
  474             ASSERT(node-&gt;isBooleanConstant());
  475             fillAction = SetBooleanConstant;
  476         } else
  477             fillAction = Load32Payload;
  478 #endif
  479     } else if (registerFormat == DataFormatCell) {
  480         ASSERT(info.gpr() == source);
  481         if (node-&gt;hasConstant()) {
  482             DFG_ASSERT(m_jit.graph(), m_currentNode, node-&gt;isCellConstant());
  483             node-&gt;asCell(); // To get the assertion.
  484             fillAction = SetCellConstant;
  485         } else {
  486 #if USE(JSVALUE64)
  487             fillAction = LoadPtr;
  488 #else
  489             fillAction = Load32Payload;
  490 #endif
  491         }
  492     } else if (registerFormat == DataFormatStorage) {
  493         ASSERT(info.gpr() == source);
  494         fillAction = LoadPtr;
  495     } else if (registerFormat == DataFormatInt52) {
  496         if (node-&gt;hasConstant())
  497             fillAction = SetInt52Constant;
  498         else if (info.spillFormat() == DataFormatInt52)
  499             fillAction = Load64;
  500         else if (info.spillFormat() == DataFormatStrictInt52)
  501             fillAction = Load64ShiftInt52Left;
  502         else if (info.spillFormat() == DataFormatNone)
  503             fillAction = Load64;
  504         else {
  505             RELEASE_ASSERT_NOT_REACHED();
  506 #if COMPILER_QUIRK(CONSIDERS_UNREACHABLE_CODE)
  507             fillAction = Load64; // Make GCC happy.
  508 #endif
  509         }
  510     } else if (registerFormat == DataFormatStrictInt52) {
  511         if (node-&gt;hasConstant())
  512             fillAction = SetStrictInt52Constant;
  513         else if (info.spillFormat() == DataFormatInt52)
  514             fillAction = Load64ShiftInt52Right;
  515         else if (info.spillFormat() == DataFormatStrictInt52)
  516             fillAction = Load64;
  517         else if (info.spillFormat() == DataFormatNone)
  518             fillAction = Load64;
  519         else {
  520             RELEASE_ASSERT_NOT_REACHED();
  521 #if COMPILER_QUIRK(CONSIDERS_UNREACHABLE_CODE)
  522             fillAction = Load64; // Make GCC happy.
  523 #endif
  524         }
  525     } else {
  526         ASSERT(registerFormat &amp; DataFormatJS);
  527 #if USE(JSVALUE64)
  528         ASSERT(info.gpr() == source);
  529         if (node-&gt;hasConstant()) {
  530             if (node-&gt;isCellConstant())
  531                 fillAction = SetTrustedJSConstant;
  532             else
  533                 fillAction = SetJSConstant;
  534         } else if (info.spillFormat() == DataFormatInt32) {
  535             ASSERT(registerFormat == DataFormatJSInt32);
  536             fillAction = Load32PayloadBoxInt;
  537         } else
  538             fillAction = Load64;
  539 #else
  540         ASSERT(info.tagGPR() == source || info.payloadGPR() == source);
  541         if (node-&gt;hasConstant())
  542             fillAction = info.tagGPR() == source ? SetJSConstantTag : SetJSConstantPayload;
  543         else if (info.payloadGPR() == source)
  544             fillAction = Load32Payload;
  545         else { // Fill the Tag
  546             switch (info.spillFormat()) {
  547             case DataFormatInt32:
  548                 ASSERT(registerFormat == DataFormatJSInt32);
  549                 fillAction = SetInt32Tag;
  550                 break;
  551             case DataFormatCell:
  552                 ASSERT(registerFormat == DataFormatJSCell);
  553                 fillAction = SetCellTag;
  554                 break;
  555             case DataFormatBoolean:
  556                 ASSERT(registerFormat == DataFormatJSBoolean);
  557                 fillAction = SetBooleanTag;
  558                 break;
  559             default:
  560                 fillAction = Load32Tag;
  561                 break;
  562             }
  563         }
  564 #endif
  565     }
  566 
  567     return SilentRegisterSavePlan(spillAction, fillAction, node, source);
  568 }
  569 
  570 SilentRegisterSavePlan SpeculativeJIT::silentSavePlanForFPR(VirtualRegister spillMe, FPRReg source)
  571 {
  572     GenerationInfo&amp; info = generationInfoFromVirtualRegister(spillMe);
  573     Node* node = info.node();
  574     ASSERT(info.registerFormat() == DataFormatDouble);
  575 
  576     SilentSpillAction spillAction;
  577     SilentFillAction fillAction;
  578 
  579     if (!info.needsSpill())
  580         spillAction = DoNothingForSpill;
  581     else {
  582         ASSERT(!node-&gt;hasConstant());
  583         ASSERT(info.spillFormat() == DataFormatNone);
  584         ASSERT(info.fpr() == source);
  585         spillAction = StoreDouble;
  586     }
  587 
  588 #if USE(JSVALUE64)
  589     if (node-&gt;hasConstant()) {
  590         node-&gt;asNumber(); // To get the assertion.
  591         fillAction = SetDoubleConstant;
  592     } else {
  593         ASSERT(info.spillFormat() == DataFormatNone || info.spillFormat() == DataFormatDouble);
  594         fillAction = LoadDouble;
  595     }
  596 #elif USE(JSVALUE32_64)
  597     ASSERT(info.registerFormat() == DataFormatDouble);
  598     if (node-&gt;hasConstant()) {
  599         node-&gt;asNumber(); // To get the assertion.
  600         fillAction = SetDoubleConstant;
  601     } else
  602         fillAction = LoadDouble;
  603 #endif
  604 
  605     return SilentRegisterSavePlan(spillAction, fillAction, node, source);
  606 }
  607 
  608 void SpeculativeJIT::silentSpill(const SilentRegisterSavePlan&amp; plan)
  609 {
  610     switch (plan.spillAction()) {
  611     case DoNothingForSpill:
  612         break;
  613     case Store32Tag:
  614         m_jit.store32(plan.gpr(), JITCompiler::tagFor(plan.node()-&gt;virtualRegister()));
  615         break;
  616     case Store32Payload:
  617         m_jit.store32(plan.gpr(), JITCompiler::payloadFor(plan.node()-&gt;virtualRegister()));
  618         break;
  619     case StorePtr:
  620         m_jit.storePtr(plan.gpr(), JITCompiler::addressFor(plan.node()-&gt;virtualRegister()));
  621         break;
  622 #if USE(JSVALUE64)
  623     case Store64:
  624         m_jit.store64(plan.gpr(), JITCompiler::addressFor(plan.node()-&gt;virtualRegister()));
  625         break;
  626 #endif
  627     case StoreDouble:
  628         m_jit.storeDouble(plan.fpr(), JITCompiler::addressFor(plan.node()-&gt;virtualRegister()));
  629         break;
  630     default:
  631         RELEASE_ASSERT_NOT_REACHED();
  632     }
  633 }
  634 
  635 void SpeculativeJIT::silentFill(const SilentRegisterSavePlan&amp; plan)
  636 {
  637     switch (plan.fillAction()) {
  638     case DoNothingForFill:
  639         break;
  640     case SetInt32Constant:
  641         m_jit.move(Imm32(plan.node()-&gt;asInt32()), plan.gpr());
  642         break;
  643 #if USE(JSVALUE64)
  644     case SetInt52Constant:
  645         m_jit.move(Imm64(plan.node()-&gt;asAnyInt() &lt;&lt; JSValue::int52ShiftAmount), plan.gpr());
  646         break;
  647     case SetStrictInt52Constant:
  648         m_jit.move(Imm64(plan.node()-&gt;asAnyInt()), plan.gpr());
  649         break;
  650 #endif // USE(JSVALUE64)
  651     case SetBooleanConstant:
  652         m_jit.move(TrustedImm32(plan.node()-&gt;asBoolean()), plan.gpr());
  653         break;
  654     case SetCellConstant:
  655         ASSERT(plan.node()-&gt;constant()-&gt;value().isCell());
  656         m_jit.move(TrustedImmPtr(plan.node()-&gt;constant()), plan.gpr());
  657         break;
  658 #if USE(JSVALUE64)
  659     case SetTrustedJSConstant:
  660         m_jit.move(valueOfJSConstantAsImm64(plan.node()).asTrustedImm64(), plan.gpr());
  661         break;
  662     case SetJSConstant:
  663         m_jit.move(valueOfJSConstantAsImm64(plan.node()), plan.gpr());
  664         break;
  665     case SetDoubleConstant:
  666         m_jit.moveDouble(Imm64(reinterpretDoubleToInt64(plan.node()-&gt;asNumber())), plan.fpr());
  667         break;
  668     case Load32PayloadBoxInt:
  669         m_jit.load32(JITCompiler::payloadFor(plan.node()-&gt;virtualRegister()), plan.gpr());
  670         m_jit.or64(GPRInfo::tagTypeNumberRegister, plan.gpr());
  671         break;
  672     case Load32PayloadConvertToInt52:
  673         m_jit.load32(JITCompiler::payloadFor(plan.node()-&gt;virtualRegister()), plan.gpr());
  674         m_jit.signExtend32ToPtr(plan.gpr(), plan.gpr());
  675         m_jit.lshift64(TrustedImm32(JSValue::int52ShiftAmount), plan.gpr());
  676         break;
  677     case Load32PayloadSignExtend:
  678         m_jit.load32(JITCompiler::payloadFor(plan.node()-&gt;virtualRegister()), plan.gpr());
  679         m_jit.signExtend32ToPtr(plan.gpr(), plan.gpr());
  680         break;
  681 #else
  682     case SetJSConstantTag:
  683         m_jit.move(Imm32(plan.node()-&gt;asJSValue().tag()), plan.gpr());
  684         break;
  685     case SetJSConstantPayload:
  686         m_jit.move(Imm32(plan.node()-&gt;asJSValue().payload()), plan.gpr());
  687         break;
  688     case SetInt32Tag:
  689         m_jit.move(TrustedImm32(JSValue::Int32Tag), plan.gpr());
  690         break;
  691     case SetCellTag:
  692         m_jit.move(TrustedImm32(JSValue::CellTag), plan.gpr());
  693         break;
  694     case SetBooleanTag:
  695         m_jit.move(TrustedImm32(JSValue::BooleanTag), plan.gpr());
  696         break;
  697     case SetDoubleConstant:
  698         m_jit.loadDouble(TrustedImmPtr(m_jit.addressOfDoubleConstant(plan.node())), plan.fpr());
  699         break;
  700 #endif
  701     case Load32Tag:
  702         m_jit.load32(JITCompiler::tagFor(plan.node()-&gt;virtualRegister()), plan.gpr());
  703         break;
  704     case Load32Payload:
  705         m_jit.load32(JITCompiler::payloadFor(plan.node()-&gt;virtualRegister()), plan.gpr());
  706         break;
  707     case LoadPtr:
  708         m_jit.loadPtr(JITCompiler::addressFor(plan.node()-&gt;virtualRegister()), plan.gpr());
  709         break;
  710 #if USE(JSVALUE64)
  711     case Load64:
  712         m_jit.load64(JITCompiler::addressFor(plan.node()-&gt;virtualRegister()), plan.gpr());
  713         break;
  714     case Load64ShiftInt52Right:
  715         m_jit.load64(JITCompiler::addressFor(plan.node()-&gt;virtualRegister()), plan.gpr());
  716         m_jit.rshift64(TrustedImm32(JSValue::int52ShiftAmount), plan.gpr());
  717         break;
  718     case Load64ShiftInt52Left:
  719         m_jit.load64(JITCompiler::addressFor(plan.node()-&gt;virtualRegister()), plan.gpr());
  720         m_jit.lshift64(TrustedImm32(JSValue::int52ShiftAmount), plan.gpr());
  721         break;
  722 #endif
  723     case LoadDouble:
  724         m_jit.loadDouble(JITCompiler::addressFor(plan.node()-&gt;virtualRegister()), plan.fpr());
  725         break;
  726     default:
  727         RELEASE_ASSERT_NOT_REACHED();
  728     }
  729 }
  730 
  731 JITCompiler::JumpList SpeculativeJIT::jumpSlowForUnwantedArrayMode(GPRReg tempGPR, ArrayMode arrayMode)
  732 {
  733     JITCompiler::JumpList result;
  734 
  735     IndexingType indexingModeMask = IsArray | IndexingShapeMask;
  736     if (arrayMode.action() == Array::Write)
  737         indexingModeMask |= CopyOnWrite;
  738 
  739     switch (arrayMode.type()) {
  740     case Array::Int32:
  741     case Array::Double:
  742     case Array::Contiguous:
  743     case Array::Undecided:
  744     case Array::ArrayStorage: {
  745         IndexingType shape = arrayMode.shapeMask();
  746         switch (arrayMode.arrayClass()) {
  747         case Array::OriginalArray:
  748         case Array::OriginalCopyOnWriteArray:
  749             RELEASE_ASSERT_NOT_REACHED();
  750             return result;
  751 
  752         case Array::Array:
  753             m_jit.and32(TrustedImm32(indexingModeMask), tempGPR);
  754             result.append(m_jit.branch32(
  755                 MacroAssembler::NotEqual, tempGPR, TrustedImm32(IsArray | shape)));
  756             return result;
  757 
  758         case Array::NonArray:
  759         case Array::OriginalNonArray:
  760             m_jit.and32(TrustedImm32(indexingModeMask), tempGPR);
  761             result.append(m_jit.branch32(
  762                 MacroAssembler::NotEqual, tempGPR, TrustedImm32(shape)));
  763             return result;
  764 
  765         case Array::PossiblyArray:
  766             m_jit.and32(TrustedImm32(indexingModeMask &amp; ~IsArray), tempGPR);
  767             result.append(m_jit.branch32(MacroAssembler::NotEqual, tempGPR, TrustedImm32(shape)));
  768             return result;
  769         }
  770 
  771         RELEASE_ASSERT_NOT_REACHED();
  772         return result;
  773     }
  774 
  775     case Array::SlowPutArrayStorage: {
  776         ASSERT(!arrayMode.isJSArrayWithOriginalStructure());
  777 
  778         switch (arrayMode.arrayClass()) {
  779         case Array::OriginalArray:
  780         case Array::OriginalCopyOnWriteArray:
  781             RELEASE_ASSERT_NOT_REACHED();
  782             return result;
  783 
  784         case Array::Array:
  785             result.append(
  786                 m_jit.branchTest32(
  787                     MacroAssembler::Zero, tempGPR, MacroAssembler::TrustedImm32(IsArray)));
  788             break;
  789 
  790         case Array::NonArray:
  791         case Array::OriginalNonArray:
  792             result.append(
  793                 m_jit.branchTest32(
  794                     MacroAssembler::NonZero, tempGPR, MacroAssembler::TrustedImm32(IsArray)));
  795             break;
  796 
  797         case Array::PossiblyArray:
  798             break;
  799         }
  800 
  801         m_jit.and32(TrustedImm32(IndexingShapeMask), tempGPR);
  802         m_jit.sub32(TrustedImm32(ArrayStorageShape), tempGPR);
  803         result.append(
  804             m_jit.branch32(
  805                 MacroAssembler::Above, tempGPR,
  806                 TrustedImm32(SlowPutArrayStorageShape - ArrayStorageShape)));
  807         return result;
  808     }
  809     default:
  810         CRASH();
  811         break;
  812     }
  813 
  814     return result;
  815 }
  816 
  817 void SpeculativeJIT::checkArray(Node* node)
  818 {
  819     ASSERT(node-&gt;arrayMode().isSpecific());
  820     ASSERT(!node-&gt;arrayMode().doesConversion());
  821 
  822     SpeculateCellOperand base(this, node-&gt;child1());
  823     GPRReg baseReg = base.gpr();
  824 
  825     if (node-&gt;arrayMode().alreadyChecked(m_jit.graph(), node, m_state.forNode(node-&gt;child1()))) {
  826         noResult(m_currentNode);
  827         return;
  828     }
  829 
  830     switch (node-&gt;arrayMode().type()) {
  831     case Array::AnyTypedArray:
  832     case Array::String:
  833         RELEASE_ASSERT_NOT_REACHED(); // Should have been a Phantom(String:)
  834         return;
  835     case Array::Int32:
  836     case Array::Double:
  837     case Array::Contiguous:
  838     case Array::Undecided:
  839     case Array::ArrayStorage:
  840     case Array::SlowPutArrayStorage: {
  841         GPRTemporary temp(this);
  842         GPRReg tempGPR = temp.gpr();
  843         m_jit.load8(MacroAssembler::Address(baseReg, JSCell::indexingTypeAndMiscOffset()), tempGPR);
  844         speculationCheck(
  845             BadIndexingType, JSValueSource::unboxedCell(baseReg), 0,
  846             jumpSlowForUnwantedArrayMode(tempGPR, node-&gt;arrayMode()));
  847 
  848         noResult(m_currentNode);
  849         return;
  850     }
  851     case Array::DirectArguments:
  852         speculateCellTypeWithoutTypeFiltering(node-&gt;child1(), baseReg, DirectArgumentsType);
  853         noResult(m_currentNode);
  854         return;
  855     case Array::ScopedArguments:
  856         speculateCellTypeWithoutTypeFiltering(node-&gt;child1(), baseReg, ScopedArgumentsType);
  857         noResult(m_currentNode);
  858         return;
  859     default:
  860         speculateCellTypeWithoutTypeFiltering(
  861             node-&gt;child1(), baseReg,
  862             typeForTypedArrayType(node-&gt;arrayMode().typedArrayType()));
  863         noResult(m_currentNode);
  864         return;
  865     }
  866 }
  867 
  868 void SpeculativeJIT::arrayify(Node* node, GPRReg baseReg, GPRReg propertyReg)
  869 {
  870     ASSERT(node-&gt;arrayMode().doesConversion());
  871 
  872     GPRTemporary temp(this);
  873     GPRTemporary structure;
  874     GPRReg tempGPR = temp.gpr();
  875     GPRReg structureGPR = InvalidGPRReg;
  876 
  877     if (node-&gt;op() != ArrayifyToStructure) {
  878         GPRTemporary realStructure(this);
  879         structure.adopt(realStructure);
  880         structureGPR = structure.gpr();
  881     }
  882 
  883     // We can skip all that comes next if we already have array storage.
  884     MacroAssembler::JumpList slowPath;
  885 
  886     if (node-&gt;op() == ArrayifyToStructure) {
  887         ASSERT(!isCopyOnWrite(node-&gt;structure()-&gt;indexingMode()));
  888         ASSERT((node-&gt;structure()-&gt;indexingType() &amp; IndexingShapeMask) == node-&gt;arrayMode().shapeMask());
  889         slowPath.append(m_jit.branchWeakStructure(
  890             JITCompiler::NotEqual,
  891             JITCompiler::Address(baseReg, JSCell::structureIDOffset()),
  892             node-&gt;structure()));
  893     } else {
  894         m_jit.load8(
  895             MacroAssembler::Address(baseReg, JSCell::indexingTypeAndMiscOffset()), tempGPR);
  896 
  897         slowPath.append(jumpSlowForUnwantedArrayMode(tempGPR, node-&gt;arrayMode()));
  898     }
  899 
  900     addSlowPathGenerator(std::make_unique&lt;ArrayifySlowPathGenerator&gt;(
  901         slowPath, this, node, baseReg, propertyReg, tempGPR, structureGPR));
  902 
  903     noResult(m_currentNode);
  904 }
  905 
  906 void SpeculativeJIT::arrayify(Node* node)
  907 {
  908     ASSERT(node-&gt;arrayMode().isSpecific());
  909 
  910     SpeculateCellOperand base(this, node-&gt;child1());
  911 
  912     if (!node-&gt;child2()) {
  913         arrayify(node, base.gpr(), InvalidGPRReg);
  914         return;
  915     }
  916 
  917     SpeculateInt32Operand property(this, node-&gt;child2());
  918 
  919     arrayify(node, base.gpr(), property.gpr());
  920 }
  921 
  922 GPRReg SpeculativeJIT::fillStorage(Edge edge)
  923 {
  924     VirtualRegister virtualRegister = edge-&gt;virtualRegister();
  925     GenerationInfo&amp; info = generationInfoFromVirtualRegister(virtualRegister);
  926 
  927     switch (info.registerFormat()) {
  928     case DataFormatNone: {
  929         if (info.spillFormat() == DataFormatStorage) {
  930             GPRReg gpr = allocate();
  931             m_gprs.retain(gpr, virtualRegister, SpillOrderSpilled);
  932             m_jit.loadPtr(JITCompiler::addressFor(virtualRegister), gpr);
  933             info.fillStorage(*m_stream, gpr);
  934             return gpr;
  935         }
  936 
  937         // Must be a cell; fill it as a cell and then return the pointer.
  938         return fillSpeculateCell(edge);
  939     }
  940 
  941     case DataFormatStorage: {
  942         GPRReg gpr = info.gpr();
  943         m_gprs.lock(gpr);
  944         return gpr;
  945     }
  946 
  947     default:
  948         return fillSpeculateCell(edge);
  949     }
  950 }
  951 
  952 void SpeculativeJIT::useChildren(Node* node)
  953 {
  954     if (node-&gt;flags() &amp; NodeHasVarArgs) {
  955         for (unsigned childIdx = node-&gt;firstChild(); childIdx &lt; node-&gt;firstChild() + node-&gt;numChildren(); childIdx++) {
  956             if (!!m_jit.graph().m_varArgChildren[childIdx])
  957                 use(m_jit.graph().m_varArgChildren[childIdx]);
  958         }
  959     } else {
  960         Edge child1 = node-&gt;child1();
  961         if (!child1) {
  962             ASSERT(!node-&gt;child2() &amp;&amp; !node-&gt;child3());
  963             return;
  964         }
  965         use(child1);
  966 
  967         Edge child2 = node-&gt;child2();
  968         if (!child2) {
  969             ASSERT(!node-&gt;child3());
  970             return;
  971         }
  972         use(child2);
  973 
  974         Edge child3 = node-&gt;child3();
  975         if (!child3)
  976             return;
  977         use(child3);
  978     }
  979 }
  980 
  981 void SpeculativeJIT::compileGetById(Node* node, AccessType accessType)
  982 {
  983     ASSERT(accessType == AccessType::Get || accessType == AccessType::GetDirect || accessType == AccessType::TryGet);
  984 
  985     switch (node-&gt;child1().useKind()) {
  986     case CellUse: {
  987         SpeculateCellOperand base(this, node-&gt;child1());
  988         JSValueRegsTemporary result(this, Reuse, base);
  989 
  990         JSValueRegs baseRegs = JSValueRegs::payloadOnly(base.gpr());
  991         JSValueRegs resultRegs = result.regs();
  992 
  993         base.use();
  994 
  995         cachedGetById(node-&gt;origin.semantic, baseRegs, resultRegs, node-&gt;identifierNumber(), JITCompiler::Jump(), NeedToSpill, accessType);
  996 
  997         jsValueResult(resultRegs, node, DataFormatJS, UseChildrenCalledExplicitly);
  998         break;
  999     }
 1000 
 1001     case UntypedUse: {
 1002         JSValueOperand base(this, node-&gt;child1());
 1003         JSValueRegsTemporary result(this, Reuse, base);
 1004 
 1005         JSValueRegs baseRegs = base.jsValueRegs();
 1006         JSValueRegs resultRegs = result.regs();
 1007 
 1008         base.use();
 1009 
 1010         JITCompiler::Jump notCell = m_jit.branchIfNotCell(baseRegs);
 1011 
 1012         cachedGetById(node-&gt;origin.semantic, baseRegs, resultRegs, node-&gt;identifierNumber(), notCell, NeedToSpill, accessType);
 1013 
 1014         jsValueResult(resultRegs, node, DataFormatJS, UseChildrenCalledExplicitly);
 1015         break;
 1016     }
 1017 
 1018     default:
 1019         DFG_CRASH(m_jit.graph(), node, &quot;Bad use kind&quot;);
 1020         break;
 1021     }
 1022 }
 1023 
 1024 void SpeculativeJIT::compileGetByIdFlush(Node* node, AccessType accessType)
 1025 {
 1026     switch (node-&gt;child1().useKind()) {
 1027     case CellUse: {
 1028         SpeculateCellOperand base(this, node-&gt;child1());
 1029         JSValueRegs baseRegs = JSValueRegs::payloadOnly(base.gpr());
 1030 
 1031         JSValueRegsFlushedCallResult result(this);
 1032         JSValueRegs resultRegs = result.regs();
 1033 
 1034         base.use();
 1035 
 1036         flushRegisters();
 1037 
 1038         cachedGetById(node-&gt;origin.semantic, baseRegs, resultRegs, node-&gt;identifierNumber(), JITCompiler::Jump(), DontSpill, accessType);
 1039 
 1040         jsValueResult(resultRegs, node, DataFormatJS, UseChildrenCalledExplicitly);
 1041         break;
 1042     }
 1043 
 1044     case UntypedUse: {
 1045         JSValueOperand base(this, node-&gt;child1());
 1046         JSValueRegs baseRegs = base.jsValueRegs();
 1047 
 1048         JSValueRegsFlushedCallResult result(this);
 1049         JSValueRegs resultRegs = result.regs();
 1050 
 1051         base.use();
 1052 
 1053         flushRegisters();
 1054 
 1055         JITCompiler::Jump notCell = m_jit.branchIfNotCell(baseRegs);
 1056 
 1057         cachedGetById(node-&gt;origin.semantic, baseRegs, resultRegs, node-&gt;identifierNumber(), notCell, DontSpill, accessType);
 1058 
 1059         jsValueResult(resultRegs, node, DataFormatJS, UseChildrenCalledExplicitly);
 1060         break;
 1061     }
 1062 
 1063     default:
 1064         DFG_CRASH(m_jit.graph(), node, &quot;Bad use kind&quot;);
 1065         break;
 1066     }
 1067 }
 1068 
 1069 void SpeculativeJIT::compileInById(Node* node)
 1070 {
 1071     SpeculateCellOperand base(this, node-&gt;child1());
 1072     JSValueRegsTemporary result(this, Reuse, base, PayloadWord);
 1073 
 1074     GPRReg baseGPR = base.gpr();
 1075     JSValueRegs resultRegs = result.regs();
 1076 
 1077     base.use();
 1078 
 1079     CodeOrigin codeOrigin = node-&gt;origin.semantic;
 1080     CallSiteIndex callSite = m_jit.recordCallSiteAndGenerateExceptionHandlingOSRExitIfNeeded(codeOrigin, m_stream-&gt;size());
 1081     RegisterSet usedRegisters = this-&gt;usedRegisters();
 1082     JITInByIdGenerator gen(
 1083         m_jit.codeBlock(), codeOrigin, callSite, usedRegisters, identifierUID(node-&gt;identifierNumber()),
 1084         JSValueRegs::payloadOnly(baseGPR), resultRegs);
 1085     gen.generateFastPath(m_jit);
 1086 
 1087     auto slowPath = slowPathCall(
 1088         gen.slowPathJump(), this, operationInByIdOptimize,
 1089         NeedToSpill, ExceptionCheckRequirement::CheckNeeded,
 1090         resultRegs, gen.stubInfo(), CCallHelpers::CellValue(baseGPR), identifierUID(node-&gt;identifierNumber()));
 1091 
 1092     m_jit.addInById(gen, slowPath.get());
 1093     addSlowPathGenerator(WTFMove(slowPath));
 1094 
 1095     blessedBooleanResult(resultRegs.payloadGPR(), node, UseChildrenCalledExplicitly);
 1096 }
 1097 
 1098 void SpeculativeJIT::compileInByVal(Node* node)
 1099 {
 1100     SpeculateCellOperand base(this, node-&gt;child1());
 1101     JSValueOperand key(this, node-&gt;child2());
 1102 
 1103     GPRReg baseGPR = base.gpr();
 1104     JSValueRegs regs = key.jsValueRegs();
 1105 
 1106     base.use();
 1107     key.use();
 1108 
 1109     flushRegisters();
 1110     JSValueRegsFlushedCallResult result(this);
 1111     JSValueRegs resultRegs = result.regs();
 1112     callOperation(operationInByVal, resultRegs, baseGPR, regs);
 1113     m_jit.exceptionCheck();
 1114     blessedBooleanResult(resultRegs.payloadGPR(), node, UseChildrenCalledExplicitly);
 1115 }
 1116 
 1117 void SpeculativeJIT::compileDeleteById(Node* node)
 1118 {
 1119     JSValueOperand value(this, node-&gt;child1());
 1120     GPRFlushedCallResult result(this);
 1121 
 1122     JSValueRegs valueRegs = value.jsValueRegs();
 1123     GPRReg resultGPR = result.gpr();
 1124 
 1125     value.use();
 1126 
 1127     flushRegisters();
 1128     callOperation(operationDeleteById, resultGPR, valueRegs, identifierUID(node-&gt;identifierNumber()));
 1129     m_jit.exceptionCheck();
 1130 
 1131     unblessedBooleanResult(resultGPR, node, UseChildrenCalledExplicitly);
 1132 }
 1133 
 1134 void SpeculativeJIT::compileDeleteByVal(Node* node)
 1135 {
 1136     JSValueOperand base(this, node-&gt;child1());
 1137     JSValueOperand key(this, node-&gt;child2());
 1138     GPRFlushedCallResult result(this);
 1139 
 1140     JSValueRegs baseRegs = base.jsValueRegs();
 1141     JSValueRegs keyRegs = key.jsValueRegs();
 1142     GPRReg resultGPR = result.gpr();
 1143 
 1144     base.use();
 1145     key.use();
 1146 
 1147     flushRegisters();
 1148     callOperation(operationDeleteByVal, resultGPR, baseRegs, keyRegs);
 1149     m_jit.exceptionCheck();
 1150 
 1151     unblessedBooleanResult(resultGPR, node, UseChildrenCalledExplicitly);
 1152 }
 1153 
 1154 void SpeculativeJIT::compilePushWithScope(Node* node)
 1155 {
 1156     SpeculateCellOperand currentScope(this, node-&gt;child1());
 1157     GPRReg currentScopeGPR = currentScope.gpr();
 1158 
 1159     GPRFlushedCallResult result(this);
 1160     GPRReg resultGPR = result.gpr();
 1161 
 1162     auto objectEdge = node-&gt;child2();
 1163     if (objectEdge.useKind() == ObjectUse) {
 1164         SpeculateCellOperand object(this, objectEdge);
 1165         GPRReg objectGPR = object.gpr();
 1166         speculateObject(objectEdge, objectGPR);
 1167 
 1168         flushRegisters();
 1169         callOperation(operationPushWithScopeObject, resultGPR, currentScopeGPR, objectGPR);
 1170         // No exception check here as we did not have to call toObject().
 1171     } else {
 1172         ASSERT(objectEdge.useKind() == UntypedUse);
 1173         JSValueOperand object(this, objectEdge);
 1174         JSValueRegs objectRegs = object.jsValueRegs();
 1175 
 1176         flushRegisters();
 1177         callOperation(operationPushWithScope, resultGPR, currentScopeGPR, objectRegs);
 1178         m_jit.exceptionCheck();
 1179     }
 1180 
 1181     cellResult(resultGPR, node);
 1182 }
 1183 
 1184 bool SpeculativeJIT::nonSpeculativeStrictEq(Node* node, bool invert)
 1185 {
 1186     unsigned branchIndexInBlock = detectPeepHoleBranch();
 1187     if (branchIndexInBlock != UINT_MAX) {
 1188         Node* branchNode = m_block-&gt;at(branchIndexInBlock);
 1189 
 1190         ASSERT(node-&gt;adjustedRefCount() == 1);
 1191 
 1192         nonSpeculativePeepholeStrictEq(node, branchNode, invert);
 1193 
 1194         m_indexInBlock = branchIndexInBlock;
 1195         m_currentNode = branchNode;
 1196 
 1197         return true;
 1198     }
 1199 
 1200     nonSpeculativeNonPeepholeStrictEq(node, invert);
 1201 
 1202     return false;
 1203 }
 1204 
 1205 static const char* dataFormatString(DataFormat format)
 1206 {
 1207     // These values correspond to the DataFormat enum.
 1208     const char* strings[] = {
 1209         &quot;[  ]&quot;,
 1210         &quot;[ i]&quot;,
 1211         &quot;[ d]&quot;,
 1212         &quot;[ c]&quot;,
 1213         &quot;Err!&quot;,
 1214         &quot;Err!&quot;,
 1215         &quot;Err!&quot;,
 1216         &quot;Err!&quot;,
 1217         &quot;[J ]&quot;,
 1218         &quot;[Ji]&quot;,
 1219         &quot;[Jd]&quot;,
 1220         &quot;[Jc]&quot;,
 1221         &quot;Err!&quot;,
 1222         &quot;Err!&quot;,
 1223         &quot;Err!&quot;,
 1224         &quot;Err!&quot;,
 1225     };
 1226     return strings[format];
 1227 }
 1228 
 1229 void SpeculativeJIT::dump(const char* label)
 1230 {
 1231     if (label)
 1232         dataLogF(&quot;&lt;%s&gt;\n&quot;, label);
 1233 
 1234     dataLogF(&quot;  gprs:\n&quot;);
 1235     m_gprs.dump();
 1236     dataLogF(&quot;  fprs:\n&quot;);
 1237     m_fprs.dump();
 1238     dataLogF(&quot;  VirtualRegisters:\n&quot;);
 1239     for (unsigned i = 0; i &lt; m_generationInfo.size(); ++i) {
 1240         GenerationInfo&amp; info = m_generationInfo[i];
 1241         if (info.alive())
 1242             dataLogF(&quot;    % 3d:%s%s&quot;, i, dataFormatString(info.registerFormat()), dataFormatString(info.spillFormat()));
 1243         else
 1244             dataLogF(&quot;    % 3d:[__][__]&quot;, i);
 1245         if (info.registerFormat() == DataFormatDouble)
 1246             dataLogF(&quot;:fpr%d\n&quot;, info.fpr());
 1247         else if (info.registerFormat() != DataFormatNone
 1248 #if USE(JSVALUE32_64)
 1249             &amp;&amp; !(info.registerFormat() &amp; DataFormatJS)
 1250 #endif
 1251             ) {
 1252             ASSERT(info.gpr() != InvalidGPRReg);
 1253             dataLogF(&quot;:%s\n&quot;, GPRInfo::debugName(info.gpr()));
 1254         } else
 1255             dataLogF(&quot;\n&quot;);
 1256     }
 1257     if (label)
 1258         dataLogF(&quot;&lt;/%s&gt;\n&quot;, label);
 1259 }
 1260 
 1261 GPRTemporary::GPRTemporary()
 1262     : m_jit(0)
 1263     , m_gpr(InvalidGPRReg)
 1264 {
 1265 }
 1266 
 1267 GPRTemporary::GPRTemporary(SpeculativeJIT* jit)
 1268     : m_jit(jit)
 1269     , m_gpr(InvalidGPRReg)
 1270 {
 1271     m_gpr = m_jit-&gt;allocate();
 1272 }
 1273 
 1274 GPRTemporary::GPRTemporary(SpeculativeJIT* jit, GPRReg specific)
 1275     : m_jit(jit)
 1276     , m_gpr(InvalidGPRReg)
 1277 {
 1278     m_gpr = m_jit-&gt;allocate(specific);
 1279 }
 1280 
 1281 #if USE(JSVALUE32_64)
 1282 GPRTemporary::GPRTemporary(
 1283     SpeculativeJIT* jit, ReuseTag, JSValueOperand&amp; op1, WhichValueWord which)
 1284     : m_jit(jit)
 1285     , m_gpr(InvalidGPRReg)
 1286 {
 1287     if (!op1.isDouble() &amp;&amp; m_jit-&gt;canReuse(op1.node()))
 1288         m_gpr = m_jit-&gt;reuse(op1.gpr(which));
 1289     else
 1290         m_gpr = m_jit-&gt;allocate();
 1291 }
 1292 #else // USE(JSVALUE32_64)
 1293 GPRTemporary::GPRTemporary(SpeculativeJIT* jit, ReuseTag, JSValueOperand&amp; op1, WhichValueWord)
 1294     : GPRTemporary(jit, Reuse, op1)
 1295 {
 1296 }
 1297 #endif
 1298 
 1299 JSValueRegsTemporary::JSValueRegsTemporary() { }
 1300 
 1301 JSValueRegsTemporary::JSValueRegsTemporary(SpeculativeJIT* jit)
 1302 #if USE(JSVALUE64)
 1303     : m_gpr(jit)
 1304 #else
 1305     : m_payloadGPR(jit)
 1306     , m_tagGPR(jit)
 1307 #endif
 1308 {
 1309 }
 1310 
 1311 #if USE(JSVALUE64)
 1312 template&lt;typename T&gt;
 1313 JSValueRegsTemporary::JSValueRegsTemporary(SpeculativeJIT* jit, ReuseTag, T&amp; operand, WhichValueWord)
 1314     : m_gpr(jit, Reuse, operand)
 1315 {
 1316 }
 1317 #else
 1318 template&lt;typename T&gt;
 1319 JSValueRegsTemporary::JSValueRegsTemporary(SpeculativeJIT* jit, ReuseTag, T&amp; operand, WhichValueWord resultWord)
 1320 {
 1321     if (resultWord == PayloadWord) {
 1322         m_payloadGPR = GPRTemporary(jit, Reuse, operand);
 1323         m_tagGPR = GPRTemporary(jit);
 1324     } else {
 1325         m_payloadGPR = GPRTemporary(jit);
 1326         m_tagGPR = GPRTemporary(jit, Reuse, operand);
 1327     }
 1328 }
 1329 #endif
 1330 
 1331 #if USE(JSVALUE64)
 1332 JSValueRegsTemporary::JSValueRegsTemporary(SpeculativeJIT* jit, ReuseTag, JSValueOperand&amp; operand)
 1333 {
 1334     m_gpr = GPRTemporary(jit, Reuse, operand);
 1335 }
 1336 #else
 1337 JSValueRegsTemporary::JSValueRegsTemporary(SpeculativeJIT* jit, ReuseTag, JSValueOperand&amp; operand)
 1338 {
 1339     if (jit-&gt;canReuse(operand.node())) {
 1340         m_payloadGPR = GPRTemporary(jit, Reuse, operand, PayloadWord);
 1341         m_tagGPR = GPRTemporary(jit, Reuse, operand, TagWord);
 1342     } else {
 1343         m_payloadGPR = GPRTemporary(jit);
 1344         m_tagGPR = GPRTemporary(jit);
 1345     }
 1346 }
 1347 #endif
 1348 
 1349 JSValueRegsTemporary::~JSValueRegsTemporary() { }
 1350 
 1351 JSValueRegs JSValueRegsTemporary::regs()
 1352 {
 1353 #if USE(JSVALUE64)
 1354     return JSValueRegs(m_gpr.gpr());
 1355 #else
 1356     return JSValueRegs(m_tagGPR.gpr(), m_payloadGPR.gpr());
 1357 #endif
 1358 }
 1359 
 1360 void GPRTemporary::adopt(GPRTemporary&amp; other)
 1361 {
 1362     ASSERT(!m_jit);
 1363     ASSERT(m_gpr == InvalidGPRReg);
 1364     ASSERT(other.m_jit);
 1365     ASSERT(other.m_gpr != InvalidGPRReg);
 1366     m_jit = other.m_jit;
 1367     m_gpr = other.m_gpr;
 1368     other.m_jit = 0;
 1369     other.m_gpr = InvalidGPRReg;
 1370 }
 1371 
 1372 FPRTemporary::FPRTemporary(FPRTemporary&amp;&amp; other)
 1373 {
 1374     ASSERT(other.m_jit);
 1375     ASSERT(other.m_fpr != InvalidFPRReg);
 1376     m_jit = other.m_jit;
 1377     m_fpr = other.m_fpr;
 1378 
 1379     other.m_jit = nullptr;
 1380 }
 1381 
 1382 FPRTemporary::FPRTemporary(SpeculativeJIT* jit)
 1383     : m_jit(jit)
 1384     , m_fpr(InvalidFPRReg)
 1385 {
 1386     m_fpr = m_jit-&gt;fprAllocate();
 1387 }
 1388 
 1389 FPRTemporary::FPRTemporary(SpeculativeJIT* jit, SpeculateDoubleOperand&amp; op1)
 1390     : m_jit(jit)
 1391     , m_fpr(InvalidFPRReg)
 1392 {
 1393     if (m_jit-&gt;canReuse(op1.node()))
 1394         m_fpr = m_jit-&gt;reuse(op1.fpr());
 1395     else
 1396         m_fpr = m_jit-&gt;fprAllocate();
 1397 }
 1398 
 1399 FPRTemporary::FPRTemporary(SpeculativeJIT* jit, SpeculateDoubleOperand&amp; op1, SpeculateDoubleOperand&amp; op2)
 1400     : m_jit(jit)
 1401     , m_fpr(InvalidFPRReg)
 1402 {
 1403     if (m_jit-&gt;canReuse(op1.node()))
 1404         m_fpr = m_jit-&gt;reuse(op1.fpr());
 1405     else if (m_jit-&gt;canReuse(op2.node()))
 1406         m_fpr = m_jit-&gt;reuse(op2.fpr());
 1407     else if (m_jit-&gt;canReuse(op1.node(), op2.node()) &amp;&amp; op1.fpr() == op2.fpr())
 1408         m_fpr = m_jit-&gt;reuse(op1.fpr());
 1409     else
 1410         m_fpr = m_jit-&gt;fprAllocate();
 1411 }
 1412 
 1413 #if USE(JSVALUE32_64)
 1414 FPRTemporary::FPRTemporary(SpeculativeJIT* jit, JSValueOperand&amp; op1)
 1415     : m_jit(jit)
 1416     , m_fpr(InvalidFPRReg)
 1417 {
 1418     if (op1.isDouble() &amp;&amp; m_jit-&gt;canReuse(op1.node()))
 1419         m_fpr = m_jit-&gt;reuse(op1.fpr());
 1420     else
 1421         m_fpr = m_jit-&gt;fprAllocate();
 1422 }
 1423 #endif
 1424 
 1425 void SpeculativeJIT::compilePeepHoleDoubleBranch(Node* node, Node* branchNode, JITCompiler::DoubleCondition condition)
 1426 {
 1427     BasicBlock* taken = branchNode-&gt;branchData()-&gt;taken.block;
 1428     BasicBlock* notTaken = branchNode-&gt;branchData()-&gt;notTaken.block;
 1429 
 1430     if (taken == nextBlock()) {
 1431         condition = MacroAssembler::invert(condition);
 1432         std::swap(taken, notTaken);
 1433     }
 1434 
 1435     SpeculateDoubleOperand op1(this, node-&gt;child1());
 1436     SpeculateDoubleOperand op2(this, node-&gt;child2());
 1437 
 1438     branchDouble(condition, op1.fpr(), op2.fpr(), taken);
 1439     jump(notTaken);
 1440 }
 1441 
 1442 void SpeculativeJIT::compilePeepHoleObjectEquality(Node* node, Node* branchNode)
 1443 {
 1444     BasicBlock* taken = branchNode-&gt;branchData()-&gt;taken.block;
 1445     BasicBlock* notTaken = branchNode-&gt;branchData()-&gt;notTaken.block;
 1446 
 1447     MacroAssembler::RelationalCondition condition = MacroAssembler::Equal;
 1448 
 1449     if (taken == nextBlock()) {
 1450         condition = MacroAssembler::NotEqual;
 1451         BasicBlock* tmp = taken;
 1452         taken = notTaken;
 1453         notTaken = tmp;
 1454     }
 1455 
 1456     SpeculateCellOperand op1(this, node-&gt;child1());
 1457     SpeculateCellOperand op2(this, node-&gt;child2());
 1458 
 1459     GPRReg op1GPR = op1.gpr();
 1460     GPRReg op2GPR = op2.gpr();
 1461 
 1462     if (masqueradesAsUndefinedWatchpointIsStillValid()) {
 1463         if (m_state.forNode(node-&gt;child1()).m_type &amp; ~SpecObject) {
 1464             speculationCheck(
 1465                 BadType, JSValueSource::unboxedCell(op1GPR), node-&gt;child1(), m_jit.branchIfNotObject(op1GPR));
 1466         }
 1467         if (m_state.forNode(node-&gt;child2()).m_type &amp; ~SpecObject) {
 1468             speculationCheck(
 1469                 BadType, JSValueSource::unboxedCell(op2GPR), node-&gt;child2(), m_jit.branchIfNotObject(op2GPR));
 1470         }
 1471     } else {
 1472         if (m_state.forNode(node-&gt;child1()).m_type &amp; ~SpecObject) {
 1473             speculationCheck(
 1474                 BadType, JSValueSource::unboxedCell(op1GPR), node-&gt;child1(),
 1475                 m_jit.branchIfNotObject(op1GPR));
 1476         }
 1477         speculationCheck(BadType, JSValueSource::unboxedCell(op1GPR), node-&gt;child1(),
 1478             m_jit.branchTest8(
 1479                 MacroAssembler::NonZero,
 1480                 MacroAssembler::Address(op1GPR, JSCell::typeInfoFlagsOffset()),
 1481                 MacroAssembler::TrustedImm32(MasqueradesAsUndefined)));
 1482 
 1483         if (m_state.forNode(node-&gt;child2()).m_type &amp; ~SpecObject) {
 1484             speculationCheck(
 1485                 BadType, JSValueSource::unboxedCell(op2GPR), node-&gt;child2(),
 1486                 m_jit.branchIfNotObject(op2GPR));
 1487         }
 1488         speculationCheck(BadType, JSValueSource::unboxedCell(op2GPR), node-&gt;child2(),
 1489             m_jit.branchTest8(
 1490                 MacroAssembler::NonZero,
 1491                 MacroAssembler::Address(op2GPR, JSCell::typeInfoFlagsOffset()),
 1492                 MacroAssembler::TrustedImm32(MasqueradesAsUndefined)));
 1493     }
 1494 
 1495     branchPtr(condition, op1GPR, op2GPR, taken);
 1496     jump(notTaken);
 1497 }
 1498 
 1499 void SpeculativeJIT::compilePeepHoleBooleanBranch(Node* node, Node* branchNode, JITCompiler::RelationalCondition condition)
 1500 {
 1501     BasicBlock* taken = branchNode-&gt;branchData()-&gt;taken.block;
 1502     BasicBlock* notTaken = branchNode-&gt;branchData()-&gt;notTaken.block;
 1503 
 1504     // The branch instruction will branch to the taken block.
 1505     // If taken is next, switch taken with notTaken &amp; invert the branch condition so we can fall through.
 1506     if (taken == nextBlock()) {
 1507         condition = JITCompiler::invert(condition);
 1508         BasicBlock* tmp = taken;
 1509         taken = notTaken;
 1510         notTaken = tmp;
 1511     }
 1512 
 1513     if (node-&gt;child1()-&gt;isInt32Constant()) {
 1514         int32_t imm = node-&gt;child1()-&gt;asInt32();
 1515         SpeculateBooleanOperand op2(this, node-&gt;child2());
 1516         branch32(condition, JITCompiler::Imm32(imm), op2.gpr(), taken);
 1517     } else if (node-&gt;child2()-&gt;isInt32Constant()) {
 1518         SpeculateBooleanOperand op1(this, node-&gt;child1());
 1519         int32_t imm = node-&gt;child2()-&gt;asInt32();
 1520         branch32(condition, op1.gpr(), JITCompiler::Imm32(imm), taken);
 1521     } else {
 1522         SpeculateBooleanOperand op1(this, node-&gt;child1());
 1523         SpeculateBooleanOperand op2(this, node-&gt;child2());
 1524         branch32(condition, op1.gpr(), op2.gpr(), taken);
 1525     }
 1526 
 1527     jump(notTaken);
 1528 }
 1529 
 1530 void SpeculativeJIT::compileStringSlice(Node* node)
 1531 {
 1532     SpeculateCellOperand string(this, node-&gt;child1());
 1533 
 1534     GPRReg stringGPR = string.gpr();
 1535 
 1536     speculateString(node-&gt;child1(), stringGPR);
 1537 
 1538     SpeculateInt32Operand start(this, node-&gt;child2());
 1539     GPRReg startGPR = start.gpr();
 1540 
 1541     Optional&lt;SpeculateInt32Operand&gt; end;
 1542     Optional&lt;GPRReg&gt; endGPR;
 1543     if (node-&gt;child3()) {
 1544         end.emplace(this, node-&gt;child3());
 1545         endGPR.emplace(end-&gt;gpr());
 1546     }
 1547 
 1548     GPRTemporary temp(this);
 1549     GPRReg tempGPR = temp.gpr();
 1550 
 1551     m_jit.loadPtr(CCallHelpers::Address(stringGPR, JSString::offsetOfValue()), tempGPR);
 1552     auto isRope = m_jit.branchIfRopeStringImpl(tempGPR);
 1553 
 1554     GPRTemporary temp2(this);
 1555     GPRTemporary startIndex(this);
 1556 
 1557     GPRReg temp2GPR = temp2.gpr();
 1558     GPRReg startIndexGPR = startIndex.gpr();
 1559     {
 1560         m_jit.load32(MacroAssembler::Address(tempGPR, StringImpl::lengthMemoryOffset()), temp2GPR);
 1561 
 1562         emitPopulateSliceIndex(node-&gt;child2(), startGPR, temp2GPR, startIndexGPR);
 1563 
 1564         if (node-&gt;child3())
 1565             emitPopulateSliceIndex(node-&gt;child3(), endGPR.value(), temp2GPR, tempGPR);
 1566         else
 1567             m_jit.move(temp2GPR, tempGPR);
 1568     }
 1569 
 1570     CCallHelpers::JumpList doneCases;
 1571     CCallHelpers::JumpList slowCases;
 1572 
 1573     auto nonEmptyCase = m_jit.branch32(MacroAssembler::Below, startIndexGPR, tempGPR);
 1574     m_jit.move(TrustedImmPtr::weakPointer(m_jit.graph(), jsEmptyString(&amp;vm())), tempGPR);
 1575     doneCases.append(m_jit.jump());
 1576 
 1577     nonEmptyCase.link(&amp;m_jit);
 1578     m_jit.sub32(startIndexGPR, tempGPR); // the size of the sliced string.
 1579     slowCases.append(m_jit.branch32(MacroAssembler::NotEqual, tempGPR, TrustedImm32(1)));
 1580 
 1581     // Refill StringImpl* here.
 1582     m_jit.loadPtr(MacroAssembler::Address(stringGPR, JSString::offsetOfValue()), temp2GPR);
 1583     m_jit.loadPtr(MacroAssembler::Address(temp2GPR, StringImpl::dataOffset()), tempGPR);
 1584 
 1585     // Load the character into scratchReg
 1586     m_jit.zeroExtend32ToPtr(startIndexGPR, startIndexGPR);
 1587     auto is16Bit = m_jit.branchTest32(MacroAssembler::Zero, MacroAssembler::Address(temp2GPR, StringImpl::flagsOffset()), TrustedImm32(StringImpl::flagIs8Bit()));
 1588 
 1589     m_jit.load8(MacroAssembler::BaseIndex(tempGPR, startIndexGPR, MacroAssembler::TimesOne, 0), tempGPR);
 1590     auto cont8Bit = m_jit.jump();
 1591 
 1592     is16Bit.link(&amp;m_jit);
 1593     m_jit.load16(MacroAssembler::BaseIndex(tempGPR, startIndexGPR, MacroAssembler::TimesTwo, 0), tempGPR);
 1594 
 1595     auto bigCharacter = m_jit.branch32(MacroAssembler::Above, tempGPR, TrustedImm32(maxSingleCharacterString));
 1596 
 1597     // 8 bit string values don&#39;t need the isASCII check.
 1598     cont8Bit.link(&amp;m_jit);
 1599 
 1600     m_jit.lshift32(MacroAssembler::TrustedImm32(sizeof(void*) == 4 ? 2 : 3), tempGPR);
 1601     m_jit.addPtr(TrustedImmPtr(m_jit.vm()-&gt;smallStrings.singleCharacterStrings()), tempGPR);
 1602     m_jit.loadPtr(tempGPR, tempGPR);
 1603 
 1604     addSlowPathGenerator(slowPathCall(bigCharacter, this, operationSingleCharacterString, tempGPR, tempGPR));
 1605 
 1606     addSlowPathGenerator(slowPathCall(slowCases, this, operationStringSubstr, tempGPR, stringGPR, startIndexGPR, tempGPR));
 1607 
 1608     if (endGPR)
 1609         addSlowPathGenerator(slowPathCall(isRope, this, operationStringSlice, tempGPR, stringGPR, startGPR, *endGPR));
 1610     else
 1611         addSlowPathGenerator(slowPathCall(isRope, this, operationStringSlice, tempGPR, stringGPR, startGPR, TrustedImm32(std::numeric_limits&lt;int32_t&gt;::max())));
 1612 
 1613     doneCases.link(&amp;m_jit);
 1614     cellResult(tempGPR, node);
 1615 }
 1616 
 1617 void SpeculativeJIT::compileToLowerCase(Node* node)
 1618 {
 1619     ASSERT(node-&gt;op() == ToLowerCase);
 1620     SpeculateCellOperand string(this, node-&gt;child1());
 1621     GPRTemporary temp(this);
 1622     GPRTemporary index(this);
 1623     GPRTemporary charReg(this);
 1624     GPRTemporary length(this);
 1625 
 1626     GPRReg stringGPR = string.gpr();
 1627     GPRReg tempGPR = temp.gpr();
 1628     GPRReg indexGPR = index.gpr();
 1629     GPRReg charGPR = charReg.gpr();
 1630     GPRReg lengthGPR = length.gpr();
 1631 
 1632     speculateString(node-&gt;child1(), stringGPR);
 1633 
 1634     CCallHelpers::JumpList slowPath;
 1635 
 1636     m_jit.move(TrustedImmPtr(nullptr), indexGPR);
 1637 
 1638     m_jit.loadPtr(MacroAssembler::Address(stringGPR, JSString::offsetOfValue()), tempGPR);
 1639     slowPath.append(m_jit.branchIfRopeStringImpl(tempGPR));
 1640     slowPath.append(m_jit.branchTest32(
 1641         MacroAssembler::Zero, MacroAssembler::Address(tempGPR, StringImpl::flagsOffset()),
 1642         MacroAssembler::TrustedImm32(StringImpl::flagIs8Bit())));
 1643     m_jit.load32(MacroAssembler::Address(tempGPR, StringImpl::lengthMemoryOffset()), lengthGPR);
 1644     m_jit.loadPtr(MacroAssembler::Address(tempGPR, StringImpl::dataOffset()), tempGPR);
 1645 
 1646     auto loopStart = m_jit.label();
 1647     auto loopDone = m_jit.branch32(CCallHelpers::AboveOrEqual, indexGPR, lengthGPR);
 1648     m_jit.load8(MacroAssembler::BaseIndex(tempGPR, indexGPR, MacroAssembler::TimesOne), charGPR);
 1649     slowPath.append(m_jit.branchTest32(CCallHelpers::NonZero, charGPR, TrustedImm32(~0x7F)));
 1650     m_jit.sub32(TrustedImm32(&#39;A&#39;), charGPR);
 1651     slowPath.append(m_jit.branch32(CCallHelpers::BelowOrEqual, charGPR, TrustedImm32(&#39;Z&#39; - &#39;A&#39;)));
 1652 
 1653     m_jit.add32(TrustedImm32(1), indexGPR);
 1654     m_jit.jump().linkTo(loopStart, &amp;m_jit);
 1655 
 1656     slowPath.link(&amp;m_jit);
 1657     silentSpillAllRegisters(lengthGPR);
 1658     callOperation(operationToLowerCase, lengthGPR, stringGPR, indexGPR);
 1659     silentFillAllRegisters();
 1660     m_jit.exceptionCheck();
 1661     auto done = m_jit.jump();
 1662 
 1663     loopDone.link(&amp;m_jit);
 1664     m_jit.move(stringGPR, lengthGPR);
 1665 
 1666     done.link(&amp;m_jit);
 1667     cellResult(lengthGPR, node);
 1668 }
 1669 
 1670 void SpeculativeJIT::compilePeepHoleInt32Branch(Node* node, Node* branchNode, JITCompiler::RelationalCondition condition)
 1671 {
 1672     BasicBlock* taken = branchNode-&gt;branchData()-&gt;taken.block;
 1673     BasicBlock* notTaken = branchNode-&gt;branchData()-&gt;notTaken.block;
 1674 
 1675     // The branch instruction will branch to the taken block.
 1676     // If taken is next, switch taken with notTaken &amp; invert the branch condition so we can fall through.
 1677     if (taken == nextBlock()) {
 1678         condition = JITCompiler::invert(condition);
 1679         BasicBlock* tmp = taken;
 1680         taken = notTaken;
 1681         notTaken = tmp;
 1682     }
 1683 
 1684     if (node-&gt;child1()-&gt;isInt32Constant()) {
 1685         int32_t imm = node-&gt;child1()-&gt;asInt32();
 1686         SpeculateInt32Operand op2(this, node-&gt;child2());
 1687         branch32(condition, JITCompiler::Imm32(imm), op2.gpr(), taken);
 1688     } else if (node-&gt;child2()-&gt;isInt32Constant()) {
 1689         SpeculateInt32Operand op1(this, node-&gt;child1());
 1690         int32_t imm = node-&gt;child2()-&gt;asInt32();
 1691         branch32(condition, op1.gpr(), JITCompiler::Imm32(imm), taken);
 1692     } else {
 1693         SpeculateInt32Operand op1(this, node-&gt;child1());
 1694         SpeculateInt32Operand op2(this, node-&gt;child2());
 1695         branch32(condition, op1.gpr(), op2.gpr(), taken);
 1696     }
 1697 
 1698     jump(notTaken);
 1699 }
 1700 
 1701 // Returns true if the compare is fused with a subsequent branch.
 1702 bool SpeculativeJIT::compilePeepHoleBranch(Node* node, MacroAssembler::RelationalCondition condition, MacroAssembler::DoubleCondition doubleCondition, S_JITOperation_EJJ operation)
 1703 {
 1704     // Fused compare &amp; branch.
 1705     unsigned branchIndexInBlock = detectPeepHoleBranch();
 1706     if (branchIndexInBlock != UINT_MAX) {
 1707         Node* branchNode = m_block-&gt;at(branchIndexInBlock);
 1708 
 1709         // detectPeepHoleBranch currently only permits the branch to be the very next node,
 1710         // so can be no intervening nodes to also reference the compare.
 1711         ASSERT(node-&gt;adjustedRefCount() == 1);
 1712 
 1713         if (node-&gt;isBinaryUseKind(Int32Use))
 1714             compilePeepHoleInt32Branch(node, branchNode, condition);
 1715 #if USE(JSVALUE64)
 1716         else if (node-&gt;isBinaryUseKind(Int52RepUse))
 1717             compilePeepHoleInt52Branch(node, branchNode, condition);
 1718 #endif // USE(JSVALUE64)
 1719         else if (node-&gt;isBinaryUseKind(StringUse) || node-&gt;isBinaryUseKind(StringIdentUse)) {
 1720             // Use non-peephole comparison, for now.
 1721             return false;
 1722         } else if (node-&gt;isBinaryUseKind(DoubleRepUse))
 1723             compilePeepHoleDoubleBranch(node, branchNode, doubleCondition);
 1724         else if (node-&gt;op() == CompareEq) {
 1725             if (node-&gt;isBinaryUseKind(BooleanUse))
 1726                 compilePeepHoleBooleanBranch(node, branchNode, condition);
 1727             else if (node-&gt;isBinaryUseKind(SymbolUse))
 1728                 compilePeepHoleSymbolEquality(node, branchNode);
 1729             else if (node-&gt;isBinaryUseKind(ObjectUse))
 1730                 compilePeepHoleObjectEquality(node, branchNode);
 1731             else if (node-&gt;isBinaryUseKind(ObjectUse, ObjectOrOtherUse))
 1732                 compilePeepHoleObjectToObjectOrOtherEquality(node-&gt;child1(), node-&gt;child2(), branchNode);
 1733             else if (node-&gt;isBinaryUseKind(ObjectOrOtherUse, ObjectUse))
 1734                 compilePeepHoleObjectToObjectOrOtherEquality(node-&gt;child2(), node-&gt;child1(), branchNode);
 1735             else if (!needsTypeCheck(node-&gt;child1(), SpecOther))
 1736                 nonSpeculativePeepholeBranchNullOrUndefined(node-&gt;child2(), branchNode);
 1737             else if (!needsTypeCheck(node-&gt;child2(), SpecOther))
 1738                 nonSpeculativePeepholeBranchNullOrUndefined(node-&gt;child1(), branchNode);
 1739             else {
 1740                 nonSpeculativePeepholeBranch(node, branchNode, condition, operation);
 1741                 return true;
 1742             }
 1743         } else {
 1744             nonSpeculativePeepholeBranch(node, branchNode, condition, operation);
 1745             return true;
 1746         }
 1747 
 1748         use(node-&gt;child1());
 1749         use(node-&gt;child2());
 1750         m_indexInBlock = branchIndexInBlock;
 1751         m_currentNode = branchNode;
 1752         return true;
 1753     }
 1754     return false;
 1755 }
 1756 
 1757 void SpeculativeJIT::noticeOSRBirth(Node* node)
 1758 {
 1759     if (!node-&gt;hasVirtualRegister())
 1760         return;
 1761 
 1762     VirtualRegister virtualRegister = node-&gt;virtualRegister();
 1763     GenerationInfo&amp; info = generationInfoFromVirtualRegister(virtualRegister);
 1764 
 1765     info.noticeOSRBirth(*m_stream, node, virtualRegister);
 1766 }
 1767 
 1768 void SpeculativeJIT::compileMovHint(Node* node)
 1769 {
 1770     ASSERT(node-&gt;containsMovHint() &amp;&amp; node-&gt;op() != ZombieHint);
 1771 
 1772     Node* child = node-&gt;child1().node();
 1773     noticeOSRBirth(child);
 1774 
 1775     m_stream-&gt;appendAndLog(VariableEvent::movHint(MinifiedID(child), node-&gt;unlinkedLocal()));
 1776 }
 1777 
 1778 void SpeculativeJIT::bail(AbortReason reason)
 1779 {
 1780     if (verboseCompilationEnabled())
 1781         dataLog(&quot;Bailing compilation.\n&quot;);
 1782     m_compileOkay = true;
 1783     m_jit.abortWithReason(reason, m_lastGeneratedNode);
 1784     clearGenerationInfo();
 1785 }
 1786 
 1787 void SpeculativeJIT::compileCurrentBlock()
 1788 {
 1789     ASSERT(m_compileOkay);
 1790 
 1791     if (!m_block)
 1792         return;
 1793 
 1794     ASSERT(m_block-&gt;isReachable);
 1795 
 1796     m_jit.blockHeads()[m_block-&gt;index] = m_jit.label();
 1797 
 1798     if (!m_block-&gt;intersectionOfCFAHasVisited) {
 1799         // Don&#39;t generate code for basic blocks that are unreachable according to CFA.
 1800         // But to be sure that nobody has generated a jump to this block, drop in a
 1801         // breakpoint here.
 1802         m_jit.abortWithReason(DFGUnreachableBasicBlock);
 1803         return;
 1804     }
 1805 
 1806     if (m_block-&gt;isCatchEntrypoint) {
 1807         m_jit.addPtr(CCallHelpers::TrustedImm32(-(m_jit.graph().frameRegisterCount() * sizeof(Register))), GPRInfo::callFrameRegister,  CCallHelpers::stackPointerRegister);
 1808         if (Options::zeroStackFrame())
 1809             m_jit.clearStackFrame(GPRInfo::callFrameRegister, CCallHelpers::stackPointerRegister, GPRInfo::regT0, m_jit.graph().frameRegisterCount() * sizeof(Register));
 1810         m_jit.emitSaveCalleeSaves();
 1811         m_jit.emitMaterializeTagCheckRegisters();
 1812         m_jit.emitPutToCallFrameHeader(m_jit.codeBlock(), CallFrameSlot::codeBlock);
 1813     }
 1814 
 1815     m_stream-&gt;appendAndLog(VariableEvent::reset());
 1816 
 1817     m_jit.jitAssertHasValidCallFrame();
 1818     m_jit.jitAssertTagsInPlace();
 1819     m_jit.jitAssertArgumentCountSane();
 1820 
 1821     m_state.reset();
 1822     m_state.beginBasicBlock(m_block);
 1823 
 1824     for (size_t i = m_block-&gt;variablesAtHead.size(); i--;) {
 1825         int operand = m_block-&gt;variablesAtHead.operandForIndex(i);
 1826         Node* node = m_block-&gt;variablesAtHead[i];
 1827         if (!node)
 1828             continue; // No need to record dead SetLocal&#39;s.
 1829 
 1830         VariableAccessData* variable = node-&gt;variableAccessData();
 1831         DataFormat format;
 1832         if (!node-&gt;refCount())
 1833             continue; // No need to record dead SetLocal&#39;s.
 1834         format = dataFormatFor(variable-&gt;flushFormat());
 1835         m_stream-&gt;appendAndLog(
 1836             VariableEvent::setLocal(
 1837                 VirtualRegister(operand),
 1838                 variable-&gt;machineLocal(),
 1839                 format));
 1840     }
 1841 
 1842     m_origin = NodeOrigin();
 1843 
 1844     for (m_indexInBlock = 0; m_indexInBlock &lt; m_block-&gt;size(); ++m_indexInBlock) {
 1845         m_currentNode = m_block-&gt;at(m_indexInBlock);
 1846 
 1847         // We may have hit a contradiction that the CFA was aware of but that the JIT
 1848         // didn&#39;t cause directly.
 1849         if (!m_state.isValid()) {
 1850             bail(DFGBailedAtTopOfBlock);
 1851             return;
 1852         }
 1853 
 1854         m_interpreter.startExecuting();
 1855         m_interpreter.executeKnownEdgeTypes(m_currentNode);
 1856         m_jit.setForNode(m_currentNode);
 1857         m_origin = m_currentNode-&gt;origin;
 1858         m_lastGeneratedNode = m_currentNode-&gt;op();
 1859 
 1860         ASSERT(m_currentNode-&gt;shouldGenerate());
 1861 
 1862         if (verboseCompilationEnabled()) {
 1863             dataLogF(
 1864                 &quot;SpeculativeJIT generating Node @%d (bc#%u) at JIT offset 0x%x&quot;,
 1865                 (int)m_currentNode-&gt;index(),
 1866                 m_currentNode-&gt;origin.semantic.bytecodeIndex, m_jit.debugOffset());
 1867             dataLog(&quot;\n&quot;);
 1868         }
 1869 
 1870         if (Options::validateDFGExceptionHandling() &amp;&amp; (mayExit(m_jit.graph(), m_currentNode) != DoesNotExit || m_currentNode-&gt;isTerminal()))
 1871             m_jit.jitReleaseAssertNoException(*m_jit.vm());
 1872 
 1873         m_jit.pcToCodeOriginMapBuilder().appendItem(m_jit.labelIgnoringWatchpoints(), m_origin.semantic);
 1874 
 1875         compile(m_currentNode);
 1876 
 1877         if (belongsInMinifiedGraph(m_currentNode-&gt;op()))
 1878             m_minifiedGraph-&gt;append(MinifiedNode::fromNode(m_currentNode));
 1879 
 1880 #if ENABLE(DFG_REGISTER_ALLOCATION_VALIDATION)
 1881         m_jit.clearRegisterAllocationOffsets();
 1882 #endif
 1883 
 1884         if (!m_compileOkay) {
 1885             bail(DFGBailedAtEndOfNode);
 1886             return;
 1887         }
 1888 
 1889         // Make sure that the abstract state is rematerialized for the next node.
 1890         m_interpreter.executeEffects(m_indexInBlock);
 1891     }
 1892 
 1893     // Perform the most basic verification that children have been used correctly.
 1894     if (!ASSERT_DISABLED) {
 1895         for (auto&amp; info : m_generationInfo)
 1896             RELEASE_ASSERT(!info.alive());
 1897     }
 1898 }
 1899 
 1900 // If we are making type predictions about our arguments then
 1901 // we need to check that they are correct on function entry.
 1902 void SpeculativeJIT::checkArgumentTypes()
 1903 {
 1904     ASSERT(!m_currentNode);
 1905     m_origin = NodeOrigin(CodeOrigin(0), CodeOrigin(0), true);
 1906 
 1907     auto&amp; arguments = m_jit.graph().m_rootToArguments.find(m_jit.graph().block(0))-&gt;value;
 1908     for (int i = 0; i &lt; m_jit.codeBlock()-&gt;numParameters(); ++i) {
 1909         Node* node = arguments[i];
 1910         if (!node) {
 1911             // The argument is dead. We don&#39;t do any checks for such arguments.
 1912             continue;
 1913         }
 1914 
 1915         ASSERT(node-&gt;op() == SetArgument);
 1916         ASSERT(node-&gt;shouldGenerate());
 1917 
 1918         VariableAccessData* variableAccessData = node-&gt;variableAccessData();
 1919         FlushFormat format = variableAccessData-&gt;flushFormat();
 1920 
 1921         if (format == FlushedJSValue)
 1922             continue;
 1923 
 1924         VirtualRegister virtualRegister = variableAccessData-&gt;local();
 1925 
 1926         JSValueSource valueSource = JSValueSource(JITCompiler::addressFor(virtualRegister));
 1927 
 1928 #if USE(JSVALUE64)
 1929         switch (format) {
 1930         case FlushedInt32: {
 1931             speculationCheck(BadType, valueSource, node, m_jit.branch64(MacroAssembler::Below, JITCompiler::addressFor(virtualRegister), GPRInfo::tagTypeNumberRegister));
 1932             break;
 1933         }
 1934         case FlushedBoolean: {
 1935             GPRTemporary temp(this);
 1936             m_jit.load64(JITCompiler::addressFor(virtualRegister), temp.gpr());
 1937             m_jit.xor64(TrustedImm32(static_cast&lt;int32_t&gt;(ValueFalse)), temp.gpr());
 1938             speculationCheck(BadType, valueSource, node, m_jit.branchTest64(MacroAssembler::NonZero, temp.gpr(), TrustedImm32(static_cast&lt;int32_t&gt;(~1))));
 1939             break;
 1940         }
 1941         case FlushedCell: {
 1942             speculationCheck(BadType, valueSource, node, m_jit.branchTest64(MacroAssembler::NonZero, JITCompiler::addressFor(virtualRegister), GPRInfo::tagMaskRegister));
 1943             break;
 1944         }
 1945         default:
 1946             RELEASE_ASSERT_NOT_REACHED();
 1947             break;
 1948         }
 1949 #else
 1950         switch (format) {
 1951         case FlushedInt32: {
 1952             speculationCheck(BadType, valueSource, node, m_jit.branch32(MacroAssembler::NotEqual, JITCompiler::tagFor(virtualRegister), TrustedImm32(JSValue::Int32Tag)));
 1953             break;
 1954         }
 1955         case FlushedBoolean: {
 1956             speculationCheck(BadType, valueSource, node, m_jit.branch32(MacroAssembler::NotEqual, JITCompiler::tagFor(virtualRegister), TrustedImm32(JSValue::BooleanTag)));
 1957             break;
 1958         }
 1959         case FlushedCell: {
 1960             speculationCheck(BadType, valueSource, node, m_jit.branch32(MacroAssembler::NotEqual, JITCompiler::tagFor(virtualRegister), TrustedImm32(JSValue::CellTag)));
 1961             break;
 1962         }
 1963         default:
 1964             RELEASE_ASSERT_NOT_REACHED();
 1965             break;
 1966         }
 1967 #endif
 1968     }
 1969 
 1970     m_origin = NodeOrigin();
 1971 }
 1972 
 1973 bool SpeculativeJIT::compile()
 1974 {
 1975     checkArgumentTypes();
 1976 
 1977     ASSERT(!m_currentNode);
 1978     for (BlockIndex blockIndex = 0; blockIndex &lt; m_jit.graph().numBlocks(); ++blockIndex) {
 1979         m_jit.setForBlockIndex(blockIndex);
 1980         m_block = m_jit.graph().block(blockIndex);
 1981         compileCurrentBlock();
 1982     }
 1983     linkBranches();
 1984     return true;
 1985 }
 1986 
 1987 void SpeculativeJIT::createOSREntries()
 1988 {
 1989     for (BlockIndex blockIndex = 0; blockIndex &lt; m_jit.graph().numBlocks(); ++blockIndex) {
 1990         BasicBlock* block = m_jit.graph().block(blockIndex);
 1991         if (!block)
 1992             continue;
 1993         if (block-&gt;isOSRTarget || block-&gt;isCatchEntrypoint) {
 1994             // Currently we don&#39;t have OSR entry trampolines. We could add them
 1995             // here if need be.
 1996             m_osrEntryHeads.append(m_jit.blockHeads()[blockIndex]);
 1997         }
 1998     }
 1999 }
 2000 
 2001 void SpeculativeJIT::linkOSREntries(LinkBuffer&amp; linkBuffer)
 2002 {
 2003     unsigned osrEntryIndex = 0;
 2004     for (BlockIndex blockIndex = 0; blockIndex &lt; m_jit.graph().numBlocks(); ++blockIndex) {
 2005         BasicBlock* block = m_jit.graph().block(blockIndex);
 2006         if (!block)
 2007             continue;
 2008         if (!block-&gt;isOSRTarget &amp;&amp; !block-&gt;isCatchEntrypoint)
 2009             continue;
 2010         if (block-&gt;isCatchEntrypoint) {
 2011             auto&amp; argumentsVector = m_jit.graph().m_rootToArguments.find(block)-&gt;value;
 2012             Vector&lt;FlushFormat&gt; argumentFormats;
 2013             argumentFormats.reserveInitialCapacity(argumentsVector.size());
 2014             for (Node* setArgument : argumentsVector) {
 2015                 if (setArgument) {
 2016                     FlushFormat flushFormat = setArgument-&gt;variableAccessData()-&gt;flushFormat();
 2017                     ASSERT(flushFormat == FlushedInt32 || flushFormat == FlushedCell || flushFormat == FlushedBoolean || flushFormat == FlushedJSValue);
 2018                     argumentFormats.uncheckedAppend(flushFormat);
 2019                 } else
 2020                     argumentFormats.uncheckedAppend(DeadFlush);
 2021             }
 2022             m_jit.noticeCatchEntrypoint(*block, m_osrEntryHeads[osrEntryIndex++], linkBuffer, WTFMove(argumentFormats));
 2023         } else {
 2024             ASSERT(block-&gt;isOSRTarget);
 2025             m_jit.noticeOSREntry(*block, m_osrEntryHeads[osrEntryIndex++], linkBuffer);
 2026         }
 2027     }
 2028 
 2029     m_jit.jitCode()-&gt;finalizeOSREntrypoints();
 2030     m_jit.jitCode()-&gt;common.finalizeCatchEntrypoints();
 2031 
 2032     ASSERT(osrEntryIndex == m_osrEntryHeads.size());
 2033 
 2034     if (verboseCompilationEnabled()) {
 2035         DumpContext dumpContext;
 2036         dataLog(&quot;OSR Entries:\n&quot;);
 2037         for (OSREntryData&amp; entryData : m_jit.jitCode()-&gt;osrEntry)
 2038             dataLog(&quot;    &quot;, inContext(entryData, &amp;dumpContext), &quot;\n&quot;);
 2039         if (!dumpContext.isEmpty())
 2040             dumpContext.dump(WTF::dataFile());
 2041     }
 2042 }
 2043 
 2044 void SpeculativeJIT::compileCheckTraps(Node* node)
 2045 {
 2046     ASSERT(Options::usePollingTraps());
 2047     GPRTemporary unused(this);
 2048     GPRReg unusedGPR = unused.gpr();
 2049 
 2050     JITCompiler::Jump needTrapHandling = m_jit.branchTest8(JITCompiler::NonZero,
 2051         JITCompiler::AbsoluteAddress(m_jit.vm()-&gt;needTrapHandlingAddress()));
 2052 
 2053     addSlowPathGenerator(slowPathCall(needTrapHandling, this, operationHandleTraps, unusedGPR));
 2054     noResult(node);
 2055 }
 2056 
 2057 void SpeculativeJIT::compileDoublePutByVal(Node* node, SpeculateCellOperand&amp; base, SpeculateStrictInt32Operand&amp; property)
 2058 {
 2059     Edge child3 = m_jit.graph().varArgChild(node, 2);
 2060     Edge child4 = m_jit.graph().varArgChild(node, 3);
 2061 
 2062     ArrayMode arrayMode = node-&gt;arrayMode();
 2063 
 2064     GPRReg baseReg = base.gpr();
 2065     GPRReg propertyReg = property.gpr();
 2066 
 2067     SpeculateDoubleOperand value(this, child3);
 2068 
 2069     FPRReg valueReg = value.fpr();
 2070 
 2071     DFG_TYPE_CHECK(
 2072         JSValueRegs(), child3, SpecFullRealNumber,
 2073         m_jit.branchIfNaN(valueReg));
 2074 
 2075     if (!m_compileOkay)
 2076         return;
 2077 
 2078     StorageOperand storage(this, child4);
 2079     GPRReg storageReg = storage.gpr();
 2080 
 2081     if (node-&gt;op() == PutByValAlias) {
 2082         // Store the value to the array.
 2083         GPRReg propertyReg = property.gpr();
 2084         FPRReg valueReg = value.fpr();
 2085         m_jit.storeDouble(valueReg, MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight));
 2086 
 2087         noResult(m_currentNode);
 2088         return;
 2089     }
 2090 
 2091     GPRTemporary temporary;
 2092     GPRReg temporaryReg = temporaryRegisterForPutByVal(temporary, node);
 2093 
 2094     MacroAssembler::Jump slowCase;
 2095 
 2096     if (arrayMode.isInBounds()) {
 2097         speculationCheck(
 2098             OutOfBounds, JSValueRegs(), 0,
 2099             m_jit.branch32(MacroAssembler::AboveOrEqual, propertyReg, MacroAssembler::Address(storageReg, Butterfly::offsetOfPublicLength())));
 2100     } else {
 2101         MacroAssembler::Jump inBounds = m_jit.branch32(MacroAssembler::Below, propertyReg, MacroAssembler::Address(storageReg, Butterfly::offsetOfPublicLength()));
 2102 
 2103         slowCase = m_jit.branch32(MacroAssembler::AboveOrEqual, propertyReg, MacroAssembler::Address(storageReg, Butterfly::offsetOfVectorLength()));
 2104 
 2105         if (!arrayMode.isOutOfBounds())
 2106             speculationCheck(OutOfBounds, JSValueRegs(), 0, slowCase);
 2107 
 2108         m_jit.add32(TrustedImm32(1), propertyReg, temporaryReg);
 2109         m_jit.store32(temporaryReg, MacroAssembler::Address(storageReg, Butterfly::offsetOfPublicLength()));
 2110 
 2111         inBounds.link(&amp;m_jit);
 2112     }
 2113 
 2114     m_jit.storeDouble(valueReg, MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight));
 2115 
 2116     base.use();
 2117     property.use();
 2118     value.use();
 2119     storage.use();
 2120 
 2121     if (arrayMode.isOutOfBounds()) {
 2122         addSlowPathGenerator(
 2123             slowPathCall(
 2124                 slowCase, this,
 2125                 m_jit.codeBlock()-&gt;isStrictMode()
 2126                     ? (node-&gt;op() == PutByValDirect ? operationPutDoubleByValDirectBeyondArrayBoundsStrict : operationPutDoubleByValBeyondArrayBoundsStrict)
 2127                     : (node-&gt;op() == PutByValDirect ? operationPutDoubleByValDirectBeyondArrayBoundsNonStrict : operationPutDoubleByValBeyondArrayBoundsNonStrict),
 2128                 NoResult, baseReg, propertyReg, valueReg));
 2129     }
 2130 
 2131     noResult(m_currentNode, UseChildrenCalledExplicitly);
 2132 }
 2133 
 2134 void SpeculativeJIT::compileGetCharCodeAt(Node* node)
 2135 {
 2136     SpeculateCellOperand string(this, node-&gt;child1());
 2137     SpeculateStrictInt32Operand index(this, node-&gt;child2());
 2138     StorageOperand storage(this, node-&gt;child3());
 2139 
 2140     GPRReg stringReg = string.gpr();
 2141     GPRReg indexReg = index.gpr();
 2142     GPRReg storageReg = storage.gpr();
 2143 
 2144     ASSERT(speculationChecked(m_state.forNode(node-&gt;child1()).m_type, SpecString));
 2145 
 2146     GPRTemporary scratch(this);
 2147     GPRReg scratchReg = scratch.gpr();
 2148 
 2149     m_jit.loadPtr(MacroAssembler::Address(stringReg, JSString::offsetOfValue()), scratchReg);
 2150 
 2151     // unsigned comparison so we can filter out negative indices and indices that are too large
 2152     speculationCheck(Uncountable, JSValueRegs(), 0, m_jit.branch32(MacroAssembler::AboveOrEqual, indexReg, CCallHelpers::Address(scratchReg, StringImpl::lengthMemoryOffset())));
 2153 
 2154     // Load the character into scratchReg
 2155     JITCompiler::Jump is16Bit = m_jit.branchTest32(MacroAssembler::Zero, MacroAssembler::Address(scratchReg, StringImpl::flagsOffset()), TrustedImm32(StringImpl::flagIs8Bit()));
 2156 
 2157     m_jit.load8(MacroAssembler::BaseIndex(storageReg, indexReg, MacroAssembler::TimesOne, 0), scratchReg);
 2158     JITCompiler::Jump cont8Bit = m_jit.jump();
 2159 
 2160     is16Bit.link(&amp;m_jit);
 2161 
 2162     m_jit.load16(MacroAssembler::BaseIndex(storageReg, indexReg, MacroAssembler::TimesTwo, 0), scratchReg);
 2163 
 2164     cont8Bit.link(&amp;m_jit);
 2165 
 2166     int32Result(scratchReg, m_currentNode);
 2167 }
 2168 
 2169 void SpeculativeJIT::compileGetByValOnString(Node* node)
 2170 {
 2171     SpeculateCellOperand base(this, m_graph.child(node, 0));
 2172     SpeculateStrictInt32Operand property(this, m_graph.child(node, 1));
 2173     StorageOperand storage(this, m_graph.child(node, 2));
 2174     GPRReg baseReg = base.gpr();
 2175     GPRReg propertyReg = property.gpr();
 2176     GPRReg storageReg = storage.gpr();
 2177 
 2178     GPRTemporary scratch(this);
 2179     GPRReg scratchReg = scratch.gpr();
 2180 #if USE(JSVALUE32_64)
 2181     GPRTemporary resultTag;
 2182     GPRReg resultTagReg = InvalidGPRReg;
 2183     if (node-&gt;arrayMode().isOutOfBounds()) {
 2184         GPRTemporary realResultTag(this);
 2185         resultTag.adopt(realResultTag);
 2186         resultTagReg = resultTag.gpr();
 2187     }
 2188 #endif
 2189 
 2190     ASSERT(ArrayMode(Array::String, Array::Read).alreadyChecked(m_jit.graph(), node, m_state.forNode(m_graph.child(node, 0))));
 2191 
 2192     // unsigned comparison so we can filter out negative indices and indices that are too large
 2193     m_jit.loadPtr(MacroAssembler::Address(baseReg, JSString::offsetOfValue()), scratchReg);
 2194     JITCompiler::Jump outOfBounds = m_jit.branch32(
 2195         MacroAssembler::AboveOrEqual, propertyReg,
 2196         MacroAssembler::Address(scratchReg, StringImpl::lengthMemoryOffset()));
 2197     if (node-&gt;arrayMode().isInBounds())
 2198         speculationCheck(OutOfBounds, JSValueRegs(), 0, outOfBounds);
 2199 
 2200     // Load the character into scratchReg
 2201     JITCompiler::Jump is16Bit = m_jit.branchTest32(MacroAssembler::Zero, MacroAssembler::Address(scratchReg, StringImpl::flagsOffset()), TrustedImm32(StringImpl::flagIs8Bit()));
 2202 
 2203     m_jit.load8(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesOne, 0), scratchReg);
 2204     JITCompiler::Jump cont8Bit = m_jit.jump();
 2205 
 2206     is16Bit.link(&amp;m_jit);
 2207 
 2208     m_jit.load16(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesTwo, 0), scratchReg);
 2209 
 2210     JITCompiler::Jump bigCharacter =
 2211         m_jit.branch32(MacroAssembler::Above, scratchReg, TrustedImm32(maxSingleCharacterString));
 2212 
 2213     // 8 bit string values don&#39;t need the isASCII check.
 2214     cont8Bit.link(&amp;m_jit);
 2215 
 2216     m_jit.lshift32(MacroAssembler::TrustedImm32(sizeof(void*) == 4 ? 2 : 3), scratchReg);
 2217     m_jit.addPtr(TrustedImmPtr(m_jit.vm()-&gt;smallStrings.singleCharacterStrings()), scratchReg);
 2218     m_jit.loadPtr(scratchReg, scratchReg);
 2219 
 2220     addSlowPathGenerator(
 2221         slowPathCall(
 2222             bigCharacter, this, operationSingleCharacterString, scratchReg, scratchReg));
 2223 
 2224     if (node-&gt;arrayMode().isOutOfBounds()) {
 2225 #if USE(JSVALUE32_64)
 2226         m_jit.move(TrustedImm32(JSValue::CellTag), resultTagReg);
 2227 #endif
 2228 
 2229         JSGlobalObject* globalObject = m_jit.globalObjectFor(node-&gt;origin.semantic);
 2230         bool prototypeChainIsSane = false;
 2231         if (globalObject-&gt;stringPrototypeChainIsSane()) {
 2232             // FIXME: This could be captured using a Speculation mode that means &quot;out-of-bounds
 2233             // loads return a trivial value&quot;. Something like SaneChainOutOfBounds. This should
 2234             // speculate that we don&#39;t take negative out-of-bounds, or better yet, it should rely
 2235             // on a stringPrototypeChainIsSane() guaranteeing that the prototypes have no negative
 2236             // indexed properties either.
 2237             // https://bugs.webkit.org/show_bug.cgi?id=144668
 2238             m_jit.graph().registerAndWatchStructureTransition(globalObject-&gt;stringPrototype()-&gt;structure(*m_jit.vm()));
 2239             m_jit.graph().registerAndWatchStructureTransition(globalObject-&gt;objectPrototype()-&gt;structure(*m_jit.vm()));
 2240             prototypeChainIsSane = globalObject-&gt;stringPrototypeChainIsSane();
 2241         }
 2242         if (prototypeChainIsSane) {
 2243 #if USE(JSVALUE64)
 2244             addSlowPathGenerator(std::make_unique&lt;SaneStringGetByValSlowPathGenerator&gt;(
 2245                 outOfBounds, this, JSValueRegs(scratchReg), baseReg, propertyReg));
 2246 #else
 2247             addSlowPathGenerator(std::make_unique&lt;SaneStringGetByValSlowPathGenerator&gt;(
 2248                 outOfBounds, this, JSValueRegs(resultTagReg, scratchReg),
 2249                 baseReg, propertyReg));
 2250 #endif
 2251         } else {
 2252 #if USE(JSVALUE64)
 2253             addSlowPathGenerator(
 2254                 slowPathCall(
 2255                     outOfBounds, this, operationGetByValStringInt,
 2256                     scratchReg, baseReg, propertyReg));
 2257 #else
 2258             addSlowPathGenerator(
 2259                 slowPathCall(
 2260                     outOfBounds, this, operationGetByValStringInt,
 2261                     JSValueRegs(resultTagReg, scratchReg), baseReg, propertyReg));
 2262 #endif
 2263         }
 2264 
 2265 #if USE(JSVALUE64)
 2266         jsValueResult(scratchReg, m_currentNode);
 2267 #else
 2268         jsValueResult(resultTagReg, scratchReg, m_currentNode);
 2269 #endif
 2270     } else
 2271         cellResult(scratchReg, m_currentNode);
 2272 }
 2273 
 2274 void SpeculativeJIT::compileFromCharCode(Node* node)
 2275 {
 2276     Edge&amp; child = node-&gt;child1();
 2277     if (child.useKind() == UntypedUse) {
 2278         JSValueOperand opr(this, child);
 2279         JSValueRegs oprRegs = opr.jsValueRegs();
 2280 
 2281         flushRegisters();
 2282         JSValueRegsFlushedCallResult result(this);
 2283         JSValueRegs resultRegs = result.regs();
 2284         callOperation(operationStringFromCharCodeUntyped, resultRegs, oprRegs);
 2285         m_jit.exceptionCheck();
 2286 
 2287         jsValueResult(resultRegs, node);
 2288         return;
 2289     }
 2290 
 2291     SpeculateStrictInt32Operand property(this, child);
 2292     GPRReg propertyReg = property.gpr();
 2293     GPRTemporary smallStrings(this);
 2294     GPRTemporary scratch(this);
 2295     GPRReg scratchReg = scratch.gpr();
 2296     GPRReg smallStringsReg = smallStrings.gpr();
 2297 
 2298     JITCompiler::JumpList slowCases;
 2299     slowCases.append(m_jit.branch32(MacroAssembler::AboveOrEqual, propertyReg, TrustedImm32(maxSingleCharacterString)));
 2300     m_jit.move(TrustedImmPtr(m_jit.vm()-&gt;smallStrings.singleCharacterStrings()), smallStringsReg);
 2301     m_jit.loadPtr(MacroAssembler::BaseIndex(smallStringsReg, propertyReg, MacroAssembler::ScalePtr, 0), scratchReg);
 2302 
 2303     slowCases.append(m_jit.branchTest32(MacroAssembler::Zero, scratchReg));
 2304     addSlowPathGenerator(slowPathCall(slowCases, this, operationStringFromCharCode, scratchReg, propertyReg));
 2305     cellResult(scratchReg, m_currentNode);
 2306 }
 2307 
 2308 GeneratedOperandType SpeculativeJIT::checkGeneratedTypeForToInt32(Node* node)
 2309 {
 2310     VirtualRegister virtualRegister = node-&gt;virtualRegister();
 2311     GenerationInfo&amp; info = generationInfoFromVirtualRegister(virtualRegister);
 2312 
 2313     switch (info.registerFormat()) {
 2314     case DataFormatStorage:
 2315         RELEASE_ASSERT_NOT_REACHED();
 2316 
 2317     case DataFormatBoolean:
 2318     case DataFormatCell:
 2319         terminateSpeculativeExecution(Uncountable, JSValueRegs(), 0);
 2320         return GeneratedOperandTypeUnknown;
 2321 
 2322     case DataFormatNone:
 2323     case DataFormatJSCell:
 2324     case DataFormatJS:
 2325     case DataFormatJSBoolean:
 2326     case DataFormatJSDouble:
 2327         return GeneratedOperandJSValue;
 2328 
 2329     case DataFormatJSInt32:
 2330     case DataFormatInt32:
 2331         return GeneratedOperandInteger;
 2332 
 2333     default:
 2334         RELEASE_ASSERT_NOT_REACHED();
 2335         return GeneratedOperandTypeUnknown;
 2336     }
 2337 }
 2338 
 2339 void SpeculativeJIT::compileValueToInt32(Node* node)
 2340 {
 2341     switch (node-&gt;child1().useKind()) {
 2342 #if USE(JSVALUE64)
 2343     case Int52RepUse: {
 2344         SpeculateStrictInt52Operand op1(this, node-&gt;child1());
 2345         GPRTemporary result(this, Reuse, op1);
 2346         GPRReg op1GPR = op1.gpr();
 2347         GPRReg resultGPR = result.gpr();
 2348         m_jit.zeroExtend32ToPtr(op1GPR, resultGPR);
 2349         int32Result(resultGPR, node, DataFormatInt32);
 2350         return;
 2351     }
 2352 #endif // USE(JSVALUE64)
 2353 
 2354     case DoubleRepUse: {
 2355         GPRTemporary result(this);
 2356         SpeculateDoubleOperand op1(this, node-&gt;child1());
 2357         FPRReg fpr = op1.fpr();
 2358         GPRReg gpr = result.gpr();
 2359 #if CPU(ARM64)
 2360         if (MacroAssemblerARM64::supportsDoubleToInt32ConversionUsingJavaScriptSemantics())
 2361             m_jit.convertDoubleToInt32UsingJavaScriptSemantics(fpr, gpr);
 2362         else
 2363 #endif
 2364         {
 2365             JITCompiler::Jump notTruncatedToInteger = m_jit.branchTruncateDoubleToInt32(fpr, gpr, JITCompiler::BranchIfTruncateFailed);
 2366             addSlowPathGenerator(slowPathCall(notTruncatedToInteger, this,
 2367                 hasSensibleDoubleToInt() ? operationToInt32SensibleSlow : operationToInt32, NeedToSpill, ExceptionCheckRequirement::CheckNotNeeded, gpr, fpr));
 2368         }
 2369         int32Result(gpr, node);
 2370         return;
 2371     }
 2372 
 2373     case NumberUse:
 2374     case NotCellUse: {
 2375         switch (checkGeneratedTypeForToInt32(node-&gt;child1().node())) {
 2376         case GeneratedOperandInteger: {
 2377             SpeculateInt32Operand op1(this, node-&gt;child1(), ManualOperandSpeculation);
 2378             GPRTemporary result(this, Reuse, op1);
 2379             m_jit.move(op1.gpr(), result.gpr());
 2380             int32Result(result.gpr(), node, op1.format());
 2381             return;
 2382         }
 2383         case GeneratedOperandJSValue: {
 2384             GPRTemporary result(this);
 2385 #if USE(JSVALUE64)
 2386             JSValueOperand op1(this, node-&gt;child1(), ManualOperandSpeculation);
 2387 
 2388             GPRReg gpr = op1.gpr();
 2389             GPRReg resultGpr = result.gpr();
 2390             FPRTemporary tempFpr(this);
 2391             FPRReg fpr = tempFpr.fpr();
 2392 
 2393             JITCompiler::Jump isInteger = m_jit.branchIfInt32(gpr);
 2394             JITCompiler::JumpList converted;
 2395 
 2396             if (node-&gt;child1().useKind() == NumberUse) {
 2397                 DFG_TYPE_CHECK(
 2398                     JSValueRegs(gpr), node-&gt;child1(), SpecBytecodeNumber,
 2399                     m_jit.branchIfNotNumber(gpr));
 2400             } else {
 2401                 JITCompiler::Jump isNumber = m_jit.branchIfNumber(gpr);
 2402 
 2403                 DFG_TYPE_CHECK(
 2404                     JSValueRegs(gpr), node-&gt;child1(), ~SpecCellCheck, m_jit.branchIfCell(JSValueRegs(gpr)));
 2405 
 2406                 // It&#39;s not a cell: so true turns into 1 and all else turns into 0.
 2407                 m_jit.compare64(JITCompiler::Equal, gpr, TrustedImm32(ValueTrue), resultGpr);
 2408                 converted.append(m_jit.jump());
 2409 
 2410                 isNumber.link(&amp;m_jit);
 2411             }
 2412 
 2413             // First, if we get here we have a double encoded as a JSValue
 2414             unboxDouble(gpr, resultGpr, fpr);
 2415 #if CPU(ARM64)
 2416             if (MacroAssemblerARM64::supportsDoubleToInt32ConversionUsingJavaScriptSemantics())
 2417                 m_jit.convertDoubleToInt32UsingJavaScriptSemantics(fpr, resultGpr);
 2418             else
 2419 #endif
 2420             {
 2421                 silentSpillAllRegisters(resultGpr);
 2422                 callOperation(operationToInt32, resultGpr, fpr);
 2423                 silentFillAllRegisters();
 2424             }
 2425 
 2426             converted.append(m_jit.jump());
 2427 
 2428             isInteger.link(&amp;m_jit);
 2429             m_jit.zeroExtend32ToPtr(gpr, resultGpr);
 2430 
 2431             converted.link(&amp;m_jit);
 2432 #else
 2433             Node* childNode = node-&gt;child1().node();
 2434             VirtualRegister virtualRegister = childNode-&gt;virtualRegister();
 2435             GenerationInfo&amp; info = generationInfoFromVirtualRegister(virtualRegister);
 2436 
 2437             JSValueOperand op1(this, node-&gt;child1(), ManualOperandSpeculation);
 2438 
 2439             GPRReg payloadGPR = op1.payloadGPR();
 2440             GPRReg resultGpr = result.gpr();
 2441 
 2442             JITCompiler::JumpList converted;
 2443 
 2444             if (info.registerFormat() == DataFormatJSInt32)
 2445                 m_jit.move(payloadGPR, resultGpr);
 2446             else {
 2447                 GPRReg tagGPR = op1.tagGPR();
 2448                 FPRTemporary tempFpr(this);
 2449                 FPRReg fpr = tempFpr.fpr();
 2450                 FPRTemporary scratch(this);
 2451 
 2452                 JITCompiler::Jump isInteger = m_jit.branchIfInt32(tagGPR);
 2453 
 2454                 if (node-&gt;child1().useKind() == NumberUse) {
 2455                     DFG_TYPE_CHECK(
 2456                         op1.jsValueRegs(), node-&gt;child1(), SpecBytecodeNumber,
 2457                         m_jit.branch32(
 2458                             MacroAssembler::AboveOrEqual, tagGPR,
 2459                             TrustedImm32(JSValue::LowestTag)));
 2460                 } else {
 2461                     JITCompiler::Jump isNumber = m_jit.branch32(MacroAssembler::Below, tagGPR, TrustedImm32(JSValue::LowestTag));
 2462 
 2463                     DFG_TYPE_CHECK(
 2464                         op1.jsValueRegs(), node-&gt;child1(), ~SpecCell,
 2465                         m_jit.branchIfCell(op1.jsValueRegs()));
 2466 
 2467                     // It&#39;s not a cell: so true turns into 1 and all else turns into 0.
 2468                     JITCompiler::Jump isBoolean = m_jit.branchIfBoolean(tagGPR, InvalidGPRReg);
 2469                     m_jit.move(TrustedImm32(0), resultGpr);
 2470                     converted.append(m_jit.jump());
 2471 
 2472                     isBoolean.link(&amp;m_jit);
 2473                     m_jit.move(payloadGPR, resultGpr);
 2474                     converted.append(m_jit.jump());
 2475 
 2476                     isNumber.link(&amp;m_jit);
 2477                 }
 2478 
 2479                 unboxDouble(tagGPR, payloadGPR, fpr, scratch.fpr());
 2480 
 2481                 silentSpillAllRegisters(resultGpr);
 2482                 callOperation(operationToInt32, resultGpr, fpr);
 2483                 silentFillAllRegisters();
 2484 
 2485                 converted.append(m_jit.jump());
 2486 
 2487                 isInteger.link(&amp;m_jit);
 2488                 m_jit.move(payloadGPR, resultGpr);
 2489 
 2490                 converted.link(&amp;m_jit);
 2491             }
 2492 #endif
 2493             int32Result(resultGpr, node);
 2494             return;
 2495         }
 2496         case GeneratedOperandTypeUnknown:
 2497             RELEASE_ASSERT(!m_compileOkay);
 2498             return;
 2499         }
 2500         RELEASE_ASSERT_NOT_REACHED();
 2501         return;
 2502     }
 2503 
 2504     default:
 2505         ASSERT(!m_compileOkay);
 2506         return;
 2507     }
 2508 }
 2509 
 2510 void SpeculativeJIT::compileUInt32ToNumber(Node* node)
 2511 {
 2512     if (doesOverflow(node-&gt;arithMode())) {
 2513         if (enableInt52()) {
 2514             SpeculateInt32Operand op1(this, node-&gt;child1());
 2515             GPRTemporary result(this, Reuse, op1);
 2516             m_jit.zeroExtend32ToPtr(op1.gpr(), result.gpr());
 2517             strictInt52Result(result.gpr(), node);
 2518             return;
 2519         }
 2520         SpeculateInt32Operand op1(this, node-&gt;child1());
 2521         FPRTemporary result(this);
 2522 
 2523         GPRReg inputGPR = op1.gpr();
 2524         FPRReg outputFPR = result.fpr();
 2525 
 2526         m_jit.convertInt32ToDouble(inputGPR, outputFPR);
 2527 
 2528         JITCompiler::Jump positive = m_jit.branch32(MacroAssembler::GreaterThanOrEqual, inputGPR, TrustedImm32(0));
 2529         m_jit.addDouble(JITCompiler::AbsoluteAddress(&amp;AssemblyHelpers::twoToThe32), outputFPR);
 2530         positive.link(&amp;m_jit);
 2531 
 2532         doubleResult(outputFPR, node);
 2533         return;
 2534     }
 2535 
 2536     RELEASE_ASSERT(node-&gt;arithMode() == Arith::CheckOverflow);
 2537 
 2538     SpeculateInt32Operand op1(this, node-&gt;child1());
 2539     GPRTemporary result(this);
 2540 
 2541     m_jit.move(op1.gpr(), result.gpr());
 2542 
 2543     speculationCheck(Overflow, JSValueRegs(), 0, m_jit.branch32(MacroAssembler::LessThan, result.gpr(), TrustedImm32(0)));
 2544 
 2545     int32Result(result.gpr(), node, op1.format());
 2546 }
 2547 
 2548 void SpeculativeJIT::compileDoubleAsInt32(Node* node)
 2549 {
 2550     SpeculateDoubleOperand op1(this, node-&gt;child1());
 2551     FPRTemporary scratch(this);
 2552     GPRTemporary result(this);
 2553 
 2554     FPRReg valueFPR = op1.fpr();
 2555     FPRReg scratchFPR = scratch.fpr();
 2556     GPRReg resultGPR = result.gpr();
 2557 
 2558     JITCompiler::JumpList failureCases;
 2559     RELEASE_ASSERT(shouldCheckOverflow(node-&gt;arithMode()));
 2560     m_jit.branchConvertDoubleToInt32(
 2561         valueFPR, resultGPR, failureCases, scratchFPR,
 2562         shouldCheckNegativeZero(node-&gt;arithMode()));
 2563     speculationCheck(Overflow, JSValueRegs(), 0, failureCases);
 2564 
 2565     int32Result(resultGPR, node);
 2566 }
 2567 
 2568 void SpeculativeJIT::compileDoubleRep(Node* node)
 2569 {
 2570     switch (node-&gt;child1().useKind()) {
 2571     case RealNumberUse: {
 2572         JSValueOperand op1(this, node-&gt;child1(), ManualOperandSpeculation);
 2573         FPRTemporary result(this);
 2574 
 2575         JSValueRegs op1Regs = op1.jsValueRegs();
 2576         FPRReg resultFPR = result.fpr();
 2577 
 2578 #if USE(JSVALUE64)
 2579         GPRTemporary temp(this);
 2580         GPRReg tempGPR = temp.gpr();
 2581         m_jit.unboxDoubleWithoutAssertions(op1Regs.gpr(), tempGPR, resultFPR);
 2582 #else
 2583         FPRTemporary temp(this);
 2584         FPRReg tempFPR = temp.fpr();
 2585         unboxDouble(op1Regs.tagGPR(), op1Regs.payloadGPR(), resultFPR, tempFPR);
 2586 #endif
 2587 
 2588         JITCompiler::Jump done = m_jit.branchIfNotNaN(resultFPR);
 2589 
 2590         DFG_TYPE_CHECK(
 2591             op1Regs, node-&gt;child1(), SpecBytecodeRealNumber, m_jit.branchIfNotInt32(op1Regs));
 2592         m_jit.convertInt32ToDouble(op1Regs.payloadGPR(), resultFPR);
 2593 
 2594         done.link(&amp;m_jit);
 2595 
 2596         doubleResult(resultFPR, node);
 2597         return;
 2598     }
 2599 
 2600     case NotCellUse:
 2601     case NumberUse: {
 2602         SpeculatedType possibleTypes = m_state.forNode(node-&gt;child1()).m_type;
 2603         if (isInt32Speculation(possibleTypes)) {
 2604             SpeculateInt32Operand op1(this, node-&gt;child1(), ManualOperandSpeculation);
 2605             FPRTemporary result(this);
 2606             m_jit.convertInt32ToDouble(op1.gpr(), result.fpr());
 2607             doubleResult(result.fpr(), node);
 2608             return;
 2609         }
 2610 
 2611         JSValueOperand op1(this, node-&gt;child1(), ManualOperandSpeculation);
 2612         FPRTemporary result(this);
 2613 
 2614 #if USE(JSVALUE64)
 2615         GPRTemporary temp(this);
 2616 
 2617         GPRReg op1GPR = op1.gpr();
 2618         GPRReg tempGPR = temp.gpr();
 2619         FPRReg resultFPR = result.fpr();
 2620         JITCompiler::JumpList done;
 2621 
 2622         JITCompiler::Jump isInteger = m_jit.branchIfInt32(op1GPR);
 2623 
 2624         if (node-&gt;child1().useKind() == NotCellUse) {
 2625             JITCompiler::Jump isNumber = m_jit.branchIfNumber(op1GPR);
 2626             JITCompiler::Jump isUndefined = m_jit.branchIfUndefined(op1GPR);
 2627 
 2628             static const double zero = 0;
 2629             m_jit.loadDouble(TrustedImmPtr(&amp;zero), resultFPR);
 2630 
 2631             JITCompiler::Jump isNull = m_jit.branchIfNull(op1GPR);
 2632             done.append(isNull);
 2633 
 2634             DFG_TYPE_CHECK(JSValueRegs(op1GPR), node-&gt;child1(), ~SpecCellCheck,
 2635                 m_jit.branchTest64(JITCompiler::Zero, op1GPR, TrustedImm32(static_cast&lt;int32_t&gt;(TagBitBool))));
 2636 
 2637             JITCompiler::Jump isFalse = m_jit.branch64(JITCompiler::Equal, op1GPR, TrustedImm64(ValueFalse));
 2638             static const double one = 1;
 2639             m_jit.loadDouble(TrustedImmPtr(&amp;one), resultFPR);
 2640             done.append(m_jit.jump());
 2641             done.append(isFalse);
 2642 
 2643             isUndefined.link(&amp;m_jit);
 2644             static const double NaN = PNaN;
 2645             m_jit.loadDouble(TrustedImmPtr(&amp;NaN), resultFPR);
 2646             done.append(m_jit.jump());
 2647 
 2648             isNumber.link(&amp;m_jit);
 2649         } else if (needsTypeCheck(node-&gt;child1(), SpecBytecodeNumber)) {
 2650             typeCheck(
 2651                 JSValueRegs(op1GPR), node-&gt;child1(), SpecBytecodeNumber,
 2652                 m_jit.branchIfNotNumber(op1GPR));
 2653         }
 2654 
 2655         unboxDouble(op1GPR, tempGPR, resultFPR);
 2656         done.append(m_jit.jump());
 2657 
 2658         isInteger.link(&amp;m_jit);
 2659         m_jit.convertInt32ToDouble(op1GPR, resultFPR);
 2660         done.link(&amp;m_jit);
 2661 #else // USE(JSVALUE64) -&gt; this is the 32_64 case
 2662         FPRTemporary temp(this);
 2663 
 2664         GPRReg op1TagGPR = op1.tagGPR();
 2665         GPRReg op1PayloadGPR = op1.payloadGPR();
 2666         FPRReg tempFPR = temp.fpr();
 2667         FPRReg resultFPR = result.fpr();
 2668         JITCompiler::JumpList done;
 2669 
 2670         JITCompiler::Jump isInteger = m_jit.branchIfInt32(op1TagGPR);
 2671 
 2672         if (node-&gt;child1().useKind() == NotCellUse) {
 2673             JITCompiler::Jump isNumber = m_jit.branch32(JITCompiler::Below, op1TagGPR, JITCompiler::TrustedImm32(JSValue::LowestTag + 1));
 2674             JITCompiler::Jump isUndefined = m_jit.branchIfUndefined(op1TagGPR);
 2675 
 2676             static const double zero = 0;
 2677             m_jit.loadDouble(TrustedImmPtr(&amp;zero), resultFPR);
 2678 
 2679             JITCompiler::Jump isNull = m_jit.branchIfNull(op1TagGPR);
 2680             done.append(isNull);
 2681 
 2682             DFG_TYPE_CHECK(JSValueRegs(op1TagGPR, op1PayloadGPR), node-&gt;child1(), ~SpecCell, m_jit.branchIfNotBoolean(op1TagGPR, InvalidGPRReg));
 2683 
 2684             JITCompiler::Jump isFalse = m_jit.branchTest32(JITCompiler::Zero, op1PayloadGPR, TrustedImm32(1));
 2685             static const double one = 1;
 2686             m_jit.loadDouble(TrustedImmPtr(&amp;one), resultFPR);
 2687             done.append(m_jit.jump());
 2688             done.append(isFalse);
 2689 
 2690             isUndefined.link(&amp;m_jit);
 2691             static const double NaN = PNaN;
 2692             m_jit.loadDouble(TrustedImmPtr(&amp;NaN), resultFPR);
 2693             done.append(m_jit.jump());
 2694 
 2695             isNumber.link(&amp;m_jit);
 2696         } else if (needsTypeCheck(node-&gt;child1(), SpecBytecodeNumber)) {
 2697             // This check fails with Int32Tag, but it is OK since Int32 case is already excluded.
 2698             typeCheck(
 2699                 JSValueRegs(op1TagGPR, op1PayloadGPR), node-&gt;child1(), SpecBytecodeNumber,
 2700                 m_jit.branch32(MacroAssembler::AboveOrEqual, op1TagGPR, TrustedImm32(JSValue::LowestTag)));
 2701         }
 2702 
 2703         unboxDouble(op1TagGPR, op1PayloadGPR, resultFPR, tempFPR);
 2704         done.append(m_jit.jump());
 2705 
 2706         isInteger.link(&amp;m_jit);
 2707         m_jit.convertInt32ToDouble(op1PayloadGPR, resultFPR);
 2708         done.link(&amp;m_jit);
 2709 #endif // USE(JSVALUE64)
 2710 
 2711         doubleResult(resultFPR, node);
 2712         return;
 2713     }
 2714 
 2715 #if USE(JSVALUE64)
 2716     case Int52RepUse: {
 2717         SpeculateStrictInt52Operand value(this, node-&gt;child1());
 2718         FPRTemporary result(this);
 2719 
 2720         GPRReg valueGPR = value.gpr();
 2721         FPRReg resultFPR = result.fpr();
 2722 
 2723         m_jit.convertInt64ToDouble(valueGPR, resultFPR);
 2724 
 2725         doubleResult(resultFPR, node);
 2726         return;
 2727     }
 2728 #endif // USE(JSVALUE64)
 2729 
 2730     default:
 2731         RELEASE_ASSERT_NOT_REACHED();
 2732         return;
 2733     }
 2734 }
 2735 
 2736 void SpeculativeJIT::compileValueRep(Node* node)
 2737 {
 2738     switch (node-&gt;child1().useKind()) {
 2739     case DoubleRepUse: {
 2740         SpeculateDoubleOperand value(this, node-&gt;child1());
 2741         JSValueRegsTemporary result(this);
 2742 
 2743         FPRReg valueFPR = value.fpr();
 2744         JSValueRegs resultRegs = result.regs();
 2745 
 2746         // It&#39;s very tempting to in-place filter the value to indicate that it&#39;s not impure NaN
 2747         // anymore. Unfortunately, this would be unsound. If it&#39;s a GetLocal or if the value was
 2748         // subject to a prior SetLocal, filtering the value would imply that the corresponding
 2749         // local was purified.
 2750         if (needsTypeCheck(node-&gt;child1(), ~SpecDoubleImpureNaN))
 2751             m_jit.purifyNaN(valueFPR);
 2752 
 2753         boxDouble(valueFPR, resultRegs);
 2754 
 2755         jsValueResult(resultRegs, node);
 2756         return;
 2757     }
 2758 
 2759 #if USE(JSVALUE64)
 2760     case Int52RepUse: {
 2761         SpeculateStrictInt52Operand value(this, node-&gt;child1());
 2762         GPRTemporary result(this);
 2763 
 2764         GPRReg valueGPR = value.gpr();
 2765         GPRReg resultGPR = result.gpr();
 2766 
 2767         boxInt52(valueGPR, resultGPR, DataFormatStrictInt52);
 2768 
 2769         jsValueResult(resultGPR, node);
 2770         return;
 2771     }
 2772 #endif // USE(JSVALUE64)
 2773 
 2774     default:
 2775         RELEASE_ASSERT_NOT_REACHED();
 2776         return;
 2777     }
 2778 }
 2779 
 2780 static double clampDoubleToByte(double d)
 2781 {
 2782     d += 0.5;
 2783     if (!(d &gt; 0))
 2784         d = 0;
 2785     else if (d &gt; 255)
 2786         d = 255;
 2787     return d;
 2788 }
 2789 
 2790 static void compileClampIntegerToByte(JITCompiler&amp; jit, GPRReg result)
 2791 {
 2792     MacroAssembler::Jump inBounds = jit.branch32(MacroAssembler::BelowOrEqual, result, JITCompiler::TrustedImm32(0xff));
 2793     MacroAssembler::Jump tooBig = jit.branch32(MacroAssembler::GreaterThan, result, JITCompiler::TrustedImm32(0xff));
 2794     jit.xorPtr(result, result);
 2795     MacroAssembler::Jump clamped = jit.jump();
 2796     tooBig.link(&amp;jit);
 2797     jit.move(JITCompiler::TrustedImm32(255), result);
 2798     clamped.link(&amp;jit);
 2799     inBounds.link(&amp;jit);
 2800 }
 2801 
 2802 static void compileClampDoubleToByte(JITCompiler&amp; jit, GPRReg result, FPRReg source, FPRReg scratch)
 2803 {
 2804     // Unordered compare so we pick up NaN
 2805     static const double zero = 0;
 2806     static const double byteMax = 255;
 2807     static const double half = 0.5;
 2808     jit.loadDouble(JITCompiler::TrustedImmPtr(&amp;zero), scratch);
 2809     MacroAssembler::Jump tooSmall = jit.branchDouble(MacroAssembler::DoubleLessThanOrEqualOrUnordered, source, scratch);
 2810     jit.loadDouble(JITCompiler::TrustedImmPtr(&amp;byteMax), scratch);
 2811     MacroAssembler::Jump tooBig = jit.branchDouble(MacroAssembler::DoubleGreaterThan, source, scratch);
 2812 
 2813     jit.loadDouble(JITCompiler::TrustedImmPtr(&amp;half), scratch);
 2814     // FIXME: This should probably just use a floating point round!
 2815     // https://bugs.webkit.org/show_bug.cgi?id=72054
 2816     jit.addDouble(source, scratch);
 2817     jit.truncateDoubleToInt32(scratch, result);
 2818     MacroAssembler::Jump truncatedInt = jit.jump();
 2819 
 2820     tooSmall.link(&amp;jit);
 2821     jit.xorPtr(result, result);
 2822     MacroAssembler::Jump zeroed = jit.jump();
 2823 
 2824     tooBig.link(&amp;jit);
 2825     jit.move(JITCompiler::TrustedImm32(255), result);
 2826 
 2827     truncatedInt.link(&amp;jit);
 2828     zeroed.link(&amp;jit);
 2829 
 2830 }
 2831 
 2832 JITCompiler::Jump SpeculativeJIT::jumpForTypedArrayOutOfBounds(Node* node, GPRReg baseGPR, GPRReg indexGPR)
 2833 {
 2834     if (node-&gt;op() == PutByValAlias)
 2835         return JITCompiler::Jump();
 2836     JSArrayBufferView* view = m_jit.graph().tryGetFoldableView(
 2837         m_state.forNode(m_jit.graph().child(node, 0)).m_value, node-&gt;arrayMode());
 2838     if (view) {
 2839         uint32_t length = view-&gt;length();
 2840         Node* indexNode = m_jit.graph().child(node, 1).node();
 2841         if (indexNode-&gt;isInt32Constant() &amp;&amp; indexNode-&gt;asUInt32() &lt; length)
 2842             return JITCompiler::Jump();
 2843         return m_jit.branch32(
 2844             MacroAssembler::AboveOrEqual, indexGPR, MacroAssembler::Imm32(length));
 2845     }
 2846     return m_jit.branch32(
 2847         MacroAssembler::AboveOrEqual, indexGPR,
 2848         MacroAssembler::Address(baseGPR, JSArrayBufferView::offsetOfLength()));
 2849 }
 2850 
 2851 void SpeculativeJIT::emitTypedArrayBoundsCheck(Node* node, GPRReg baseGPR, GPRReg indexGPR)
 2852 {
 2853     JITCompiler::Jump jump = jumpForTypedArrayOutOfBounds(node, baseGPR, indexGPR);
 2854     if (!jump.isSet())
 2855         return;
 2856     speculationCheck(OutOfBounds, JSValueRegs(), 0, jump);
 2857 }
 2858 
 2859 JITCompiler::Jump SpeculativeJIT::jumpForTypedArrayIsNeuteredIfOutOfBounds(Node* node, GPRReg base, JITCompiler::Jump outOfBounds)
 2860 {
 2861     JITCompiler::Jump done;
 2862     if (outOfBounds.isSet()) {
 2863         done = m_jit.jump();
 2864         if (node-&gt;arrayMode().isInBounds())
 2865             speculationCheck(OutOfBounds, JSValueSource(), 0, outOfBounds);
 2866         else {
 2867             outOfBounds.link(&amp;m_jit);
 2868 
 2869             JITCompiler::Jump notWasteful = m_jit.branch32(
 2870                 MacroAssembler::NotEqual,
 2871                 MacroAssembler::Address(base, JSArrayBufferView::offsetOfMode()),
 2872                 TrustedImm32(WastefulTypedArray));
 2873 
 2874             JITCompiler::Jump hasNullVector = m_jit.branchTestPtr(
 2875                 MacroAssembler::Zero,
 2876                 MacroAssembler::Address(base, JSArrayBufferView::offsetOfVector()));
 2877             speculationCheck(Uncountable, JSValueSource(), node, hasNullVector);
 2878             notWasteful.link(&amp;m_jit);
 2879         }
 2880     }
 2881     return done;
 2882 }
 2883 
 2884 void SpeculativeJIT::loadFromIntTypedArray(GPRReg storageReg, GPRReg propertyReg, GPRReg resultReg, TypedArrayType type)
 2885 {
 2886     switch (elementSize(type)) {
 2887     case 1:
 2888         if (isSigned(type))
 2889             m_jit.load8SignedExtendTo32(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesOne), resultReg);
 2890         else
 2891             m_jit.load8(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesOne), resultReg);
 2892         break;
 2893     case 2:
 2894         if (isSigned(type))
 2895             m_jit.load16SignedExtendTo32(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesTwo), resultReg);
 2896         else
 2897             m_jit.load16(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesTwo), resultReg);
 2898         break;
 2899     case 4:
 2900         m_jit.load32(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesFour), resultReg);
 2901         break;
 2902     default:
 2903         CRASH();
 2904     }
 2905 }
 2906 
 2907 void SpeculativeJIT::setIntTypedArrayLoadResult(Node* node, GPRReg resultReg, TypedArrayType type, bool canSpeculate)
 2908 {
 2909     if (elementSize(type) &lt; 4 || isSigned(type)) {
 2910         int32Result(resultReg, node);
 2911         return;
 2912     }
 2913 
 2914     ASSERT(elementSize(type) == 4 &amp;&amp; !isSigned(type));
 2915     if (node-&gt;shouldSpeculateInt32() &amp;&amp; canSpeculate) {
 2916         speculationCheck(Overflow, JSValueRegs(), 0, m_jit.branch32(MacroAssembler::LessThan, resultReg, TrustedImm32(0)));
 2917         int32Result(resultReg, node);
 2918         return;
 2919     }
 2920 
 2921 #if USE(JSVALUE64)
 2922     if (node-&gt;shouldSpeculateAnyInt()) {
 2923         m_jit.zeroExtend32ToPtr(resultReg, resultReg);
 2924         strictInt52Result(resultReg, node);
 2925         return;
 2926     }
 2927 #endif
 2928 
 2929     FPRTemporary fresult(this);
 2930     m_jit.convertInt32ToDouble(resultReg, fresult.fpr());
 2931     JITCompiler::Jump positive = m_jit.branch32(MacroAssembler::GreaterThanOrEqual, resultReg, TrustedImm32(0));
 2932     m_jit.addDouble(JITCompiler::AbsoluteAddress(&amp;AssemblyHelpers::twoToThe32), fresult.fpr());
 2933     positive.link(&amp;m_jit);
 2934     doubleResult(fresult.fpr(), node);
 2935 }
 2936 
 2937 void SpeculativeJIT::compileGetByValOnIntTypedArray(Node* node, TypedArrayType type)
 2938 {
 2939     ASSERT(isInt(type));
 2940 
 2941     SpeculateCellOperand base(this, m_graph.varArgChild(node, 0));
 2942     SpeculateStrictInt32Operand property(this, m_graph.varArgChild(node, 1));
 2943     StorageOperand storage(this, m_graph.varArgChild(node, 2));
 2944 
 2945     GPRReg baseReg = base.gpr();
 2946     GPRReg propertyReg = property.gpr();
 2947     GPRReg storageReg = storage.gpr();
 2948 
 2949     GPRTemporary result(this);
 2950     GPRReg resultReg = result.gpr();
 2951 
 2952     ASSERT(node-&gt;arrayMode().alreadyChecked(m_jit.graph(), node, m_state.forNode(m_graph.varArgChild(node, 0))));
 2953 
 2954     emitTypedArrayBoundsCheck(node, baseReg, propertyReg);
 2955     loadFromIntTypedArray(storageReg, propertyReg, resultReg, type);
 2956     bool canSpeculate = true;
 2957     setIntTypedArrayLoadResult(node, resultReg, type, canSpeculate);
 2958 }
 2959 
 2960 bool SpeculativeJIT::getIntTypedArrayStoreOperand(
 2961     GPRTemporary&amp; value,
 2962     GPRReg property,
 2963 #if USE(JSVALUE32_64)
 2964     GPRTemporary&amp; propertyTag,
 2965     GPRTemporary&amp; valueTag,
 2966 #endif
 2967     Edge valueUse, JITCompiler::JumpList&amp; slowPathCases, bool isClamped)
 2968 {
 2969     bool isAppropriateConstant = false;
 2970     if (valueUse-&gt;isConstant()) {
 2971         JSValue jsValue = valueUse-&gt;asJSValue();
 2972         SpeculatedType expectedType = typeFilterFor(valueUse.useKind());
 2973         SpeculatedType actualType = speculationFromValue(jsValue);
 2974         isAppropriateConstant = (expectedType | actualType) == expectedType;
 2975     }
 2976 
 2977     if (isAppropriateConstant) {
 2978         JSValue jsValue = valueUse-&gt;asJSValue();
 2979         if (!jsValue.isNumber()) {
 2980             terminateSpeculativeExecution(Uncountable, JSValueRegs(), 0);
 2981             return false;
 2982         }
 2983         double d = jsValue.asNumber();
 2984         if (isClamped)
 2985             d = clampDoubleToByte(d);
 2986         GPRTemporary scratch(this);
 2987         GPRReg scratchReg = scratch.gpr();
 2988         m_jit.move(Imm32(toInt32(d)), scratchReg);
 2989         value.adopt(scratch);
 2990     } else {
 2991         switch (valueUse.useKind()) {
 2992         case Int32Use: {
 2993             SpeculateInt32Operand valueOp(this, valueUse);
 2994             GPRTemporary scratch(this);
 2995             GPRReg scratchReg = scratch.gpr();
 2996             m_jit.move(valueOp.gpr(), scratchReg);
 2997             if (isClamped)
 2998                 compileClampIntegerToByte(m_jit, scratchReg);
 2999             value.adopt(scratch);
 3000             break;
 3001         }
 3002 
 3003 #if USE(JSVALUE64)
 3004         case Int52RepUse: {
 3005             SpeculateStrictInt52Operand valueOp(this, valueUse);
 3006             GPRTemporary scratch(this);
 3007             GPRReg scratchReg = scratch.gpr();
 3008             m_jit.move(valueOp.gpr(), scratchReg);
 3009             if (isClamped) {
 3010                 MacroAssembler::Jump inBounds = m_jit.branch64(
 3011                     MacroAssembler::BelowOrEqual, scratchReg, JITCompiler::TrustedImm64(0xff));
 3012                 MacroAssembler::Jump tooBig = m_jit.branch64(
 3013                     MacroAssembler::GreaterThan, scratchReg, JITCompiler::TrustedImm64(0xff));
 3014                 m_jit.move(TrustedImm32(0), scratchReg);
 3015                 MacroAssembler::Jump clamped = m_jit.jump();
 3016                 tooBig.link(&amp;m_jit);
 3017                 m_jit.move(JITCompiler::TrustedImm32(255), scratchReg);
 3018                 clamped.link(&amp;m_jit);
 3019                 inBounds.link(&amp;m_jit);
 3020             }
 3021             value.adopt(scratch);
 3022             break;
 3023         }
 3024 #endif // USE(JSVALUE64)
 3025 
 3026         case DoubleRepUse: {
 3027             RELEASE_ASSERT(!isAtomicsIntrinsic(m_currentNode-&gt;op()));
 3028             if (isClamped) {
 3029                 SpeculateDoubleOperand valueOp(this, valueUse);
 3030                 GPRTemporary result(this);
 3031                 FPRTemporary floatScratch(this);
 3032                 FPRReg fpr = valueOp.fpr();
 3033                 GPRReg gpr = result.gpr();
 3034                 compileClampDoubleToByte(m_jit, gpr, fpr, floatScratch.fpr());
 3035                 value.adopt(result);
 3036             } else {
 3037 #if USE(JSVALUE32_64)
 3038                 GPRTemporary realPropertyTag(this);
 3039                 propertyTag.adopt(realPropertyTag);
 3040                 GPRReg propertyTagGPR = propertyTag.gpr();
 3041 
 3042                 GPRTemporary realValueTag(this);
 3043                 valueTag.adopt(realValueTag);
 3044                 GPRReg valueTagGPR = valueTag.gpr();
 3045 #endif
 3046                 SpeculateDoubleOperand valueOp(this, valueUse);
 3047                 GPRTemporary result(this);
 3048                 FPRReg fpr = valueOp.fpr();
 3049                 GPRReg gpr = result.gpr();
 3050                 MacroAssembler::Jump notNaN = m_jit.branchIfNotNaN(fpr);
 3051                 m_jit.xorPtr(gpr, gpr);
 3052                 MacroAssembler::JumpList fixed(m_jit.jump());
 3053                 notNaN.link(&amp;m_jit);
 3054 
 3055                 fixed.append(m_jit.branchTruncateDoubleToInt32(
 3056                     fpr, gpr, MacroAssembler::BranchIfTruncateSuccessful));
 3057 
 3058 #if USE(JSVALUE64)
 3059                 m_jit.or64(GPRInfo::tagTypeNumberRegister, property);
 3060                 boxDouble(fpr, gpr);
 3061 #else
 3062                 UNUSED_PARAM(property);
 3063                 m_jit.move(TrustedImm32(JSValue::Int32Tag), propertyTagGPR);
 3064                 boxDouble(fpr, valueTagGPR, gpr);
 3065 #endif
 3066                 slowPathCases.append(m_jit.jump());
 3067 
 3068                 fixed.link(&amp;m_jit);
 3069                 value.adopt(result);
 3070             }
 3071             break;
 3072         }
 3073 
 3074         default:
 3075             RELEASE_ASSERT_NOT_REACHED();
 3076             break;
 3077         }
 3078     }
 3079     return true;
 3080 }
 3081 
 3082 void SpeculativeJIT::compilePutByValForIntTypedArray(GPRReg base, GPRReg property, Node* node, TypedArrayType type)
 3083 {
 3084     ASSERT(isInt(type));
 3085 
 3086     StorageOperand storage(this, m_jit.graph().varArgChild(node, 3));
 3087     GPRReg storageReg = storage.gpr();
 3088 
 3089     Edge valueUse = m_jit.graph().varArgChild(node, 2);
 3090 
 3091     GPRTemporary value;
 3092 #if USE(JSVALUE32_64)
 3093     GPRTemporary propertyTag;
 3094     GPRTemporary valueTag;
 3095 #endif
 3096 
 3097     JITCompiler::JumpList slowPathCases;
 3098 
 3099     bool result = getIntTypedArrayStoreOperand(
 3100         value, property,
 3101 #if USE(JSVALUE32_64)
 3102         propertyTag, valueTag,
 3103 #endif
 3104         valueUse, slowPathCases, isClamped(type));
 3105     if (!result) {
 3106         noResult(node);
 3107         return;
 3108     }
 3109 
 3110     GPRReg valueGPR = value.gpr();
 3111 #if USE(JSVALUE32_64)
 3112     GPRReg propertyTagGPR = propertyTag.gpr();
 3113     GPRReg valueTagGPR = valueTag.gpr();
 3114 #endif
 3115 
 3116     ASSERT_UNUSED(valueGPR, valueGPR != property);
 3117     ASSERT(valueGPR != base);
 3118     ASSERT(valueGPR != storageReg);
 3119     JITCompiler::Jump outOfBounds = jumpForTypedArrayOutOfBounds(node, base, property);
 3120 
 3121     switch (elementSize(type)) {
 3122     case 1:
 3123         m_jit.store8(value.gpr(), MacroAssembler::BaseIndex(storageReg, property, MacroAssembler::TimesOne));
 3124         break;
 3125     case 2:
 3126         m_jit.store16(value.gpr(), MacroAssembler::BaseIndex(storageReg, property, MacroAssembler::TimesTwo));
 3127         break;
 3128     case 4:
 3129         m_jit.store32(value.gpr(), MacroAssembler::BaseIndex(storageReg, property, MacroAssembler::TimesFour));
 3130         break;
 3131     default:
 3132         CRASH();
 3133     }
 3134 
 3135     JITCompiler::Jump done = jumpForTypedArrayIsNeuteredIfOutOfBounds(node, base, outOfBounds);
 3136     if (done.isSet())
 3137         done.link(&amp;m_jit);
 3138 
 3139     if (!slowPathCases.empty()) {
 3140 #if USE(JSVALUE64)
 3141         if (node-&gt;op() == PutByValDirect) {
 3142             addSlowPathGenerator(slowPathCall(
 3143                 slowPathCases, this,
 3144                 m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValDirectStrict : operationPutByValDirectNonStrict,
 3145                 NoResult, base, property, valueGPR));
 3146         } else {
 3147             addSlowPathGenerator(slowPathCall(
 3148                 slowPathCases, this,
 3149                 m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValStrict : operationPutByValNonStrict,
 3150                 NoResult, base, property, valueGPR));
 3151         }
 3152 #else // not USE(JSVALUE64)
 3153         if (node-&gt;op() == PutByValDirect) {
 3154             addSlowPathGenerator(slowPathCall(
 3155                 slowPathCases, this,
 3156                 m_jit.codeBlock()-&gt;isStrictMode() ? operationPutByValDirectCellStrict : operationPutByValDirectCellNonStrict,
 3157                 NoResult, base, JSValueRegs(propertyTagGPR, property), JSValueRegs(valueTagGPR, valueGPR)));
 3158         } else {
 3159             addSlowPathGenerator(slowPathCall(
 3160                 slowPathCases, this,
 3161                 m_jit.codeBlock()-&gt;isStrictMode() ? operationPutByValCellStrict : operationPutByValCellNonStrict,
 3162                 NoResult, base, JSValueRegs(propertyTagGPR, property), JSValueRegs(valueTagGPR, valueGPR)));
 3163         }
 3164 #endif
 3165     }
 3166 
 3167     noResult(node);
 3168 }
 3169 
 3170 void SpeculativeJIT::compileGetByValOnFloatTypedArray(Node* node, TypedArrayType type)
 3171 {
 3172     ASSERT(isFloat(type));
 3173 
 3174     SpeculateCellOperand base(this, m_graph.varArgChild(node, 0));
 3175     SpeculateStrictInt32Operand property(this, m_graph.varArgChild(node, 1));
 3176     StorageOperand storage(this, m_graph.varArgChild(node, 2));
 3177 
 3178     GPRReg baseReg = base.gpr();
 3179     GPRReg propertyReg = property.gpr();
 3180     GPRReg storageReg = storage.gpr();
 3181 
 3182     ASSERT(node-&gt;arrayMode().alreadyChecked(m_jit.graph(), node, m_state.forNode(m_graph.varArgChild(node, 0))));
 3183 
 3184     FPRTemporary result(this);
 3185     FPRReg resultReg = result.fpr();
 3186     emitTypedArrayBoundsCheck(node, baseReg, propertyReg);
 3187     switch (elementSize(type)) {
 3188     case 4:
 3189         m_jit.loadFloat(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesFour), resultReg);
 3190         m_jit.convertFloatToDouble(resultReg, resultReg);
 3191         break;
 3192     case 8: {
 3193         m_jit.loadDouble(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight), resultReg);
 3194         break;
 3195     }
 3196     default:
 3197         RELEASE_ASSERT_NOT_REACHED();
 3198     }
 3199 
 3200     doubleResult(resultReg, node);
 3201 }
 3202 
 3203 void SpeculativeJIT::compilePutByValForFloatTypedArray(GPRReg base, GPRReg property, Node* node, TypedArrayType type)
 3204 {
 3205     ASSERT(isFloat(type));
 3206 
 3207     StorageOperand storage(this, m_jit.graph().varArgChild(node, 3));
 3208     GPRReg storageReg = storage.gpr();
 3209 
 3210     Edge baseUse = m_jit.graph().varArgChild(node, 0);
 3211     Edge valueUse = m_jit.graph().varArgChild(node, 2);
 3212 
 3213     SpeculateDoubleOperand valueOp(this, valueUse);
 3214     FPRTemporary scratch(this);
 3215     FPRReg valueFPR = valueOp.fpr();
 3216     FPRReg scratchFPR = scratch.fpr();
 3217 
 3218     ASSERT_UNUSED(baseUse, node-&gt;arrayMode().alreadyChecked(m_jit.graph(), node, m_state.forNode(baseUse)));
 3219 
 3220     MacroAssembler::Jump outOfBounds = jumpForTypedArrayOutOfBounds(node, base, property);
 3221 
 3222     switch (elementSize(type)) {
 3223     case 4: {
 3224         m_jit.moveDouble(valueFPR, scratchFPR);
 3225         m_jit.convertDoubleToFloat(valueFPR, scratchFPR);
 3226         m_jit.storeFloat(scratchFPR, MacroAssembler::BaseIndex(storageReg, property, MacroAssembler::TimesFour));
 3227         break;
 3228     }
 3229     case 8:
 3230         m_jit.storeDouble(valueFPR, MacroAssembler::BaseIndex(storageReg, property, MacroAssembler::TimesEight));
 3231         break;
 3232     default:
 3233         RELEASE_ASSERT_NOT_REACHED();
 3234     }
 3235 
 3236     JITCompiler::Jump done = jumpForTypedArrayIsNeuteredIfOutOfBounds(node, base, outOfBounds);
 3237     if (done.isSet())
 3238         done.link(&amp;m_jit);
 3239     noResult(node);
 3240 }
 3241 
 3242 void SpeculativeJIT::compileGetByValForObjectWithString(Node* node)
 3243 {
 3244     SpeculateCellOperand arg1(this, m_graph.varArgChild(node, 0));
 3245     SpeculateCellOperand arg2(this, m_graph.varArgChild(node, 1));
 3246 
 3247     GPRReg arg1GPR = arg1.gpr();
 3248     GPRReg arg2GPR = arg2.gpr();
 3249 
 3250     speculateObject(m_graph.varArgChild(node, 0), arg1GPR);
 3251     speculateString(m_graph.varArgChild(node, 1), arg2GPR);
 3252 
 3253     flushRegisters();
 3254     JSValueRegsFlushedCallResult result(this);
 3255     JSValueRegs resultRegs = result.regs();
 3256     callOperation(operationGetByValObjectString, resultRegs, arg1GPR, arg2GPR);
 3257     m_jit.exceptionCheck();
 3258 
 3259     jsValueResult(resultRegs, node);
 3260 }
 3261 
 3262 void SpeculativeJIT::compileGetByValForObjectWithSymbol(Node* node)
 3263 {
 3264     SpeculateCellOperand arg1(this, m_graph.varArgChild(node, 0));
 3265     SpeculateCellOperand arg2(this, m_graph.varArgChild(node, 1));
 3266 
 3267     GPRReg arg1GPR = arg1.gpr();
 3268     GPRReg arg2GPR = arg2.gpr();
 3269 
 3270     speculateObject(m_graph.varArgChild(node, 0), arg1GPR);
 3271     speculateSymbol(m_graph.varArgChild(node, 1), arg2GPR);
 3272 
 3273     flushRegisters();
 3274     JSValueRegsFlushedCallResult result(this);
 3275     JSValueRegs resultRegs = result.regs();
 3276     callOperation(operationGetByValObjectSymbol, resultRegs, arg1GPR, arg2GPR);
 3277     m_jit.exceptionCheck();
 3278 
 3279     jsValueResult(resultRegs, node);
 3280 }
 3281 
 3282 void SpeculativeJIT::compilePutByValForCellWithString(Node* node, Edge&amp; child1, Edge&amp; child2, Edge&amp; child3)
 3283 {
 3284     SpeculateCellOperand arg1(this, child1);
 3285     SpeculateCellOperand arg2(this, child2);
 3286     JSValueOperand arg3(this, child3);
 3287 
 3288     GPRReg arg1GPR = arg1.gpr();
 3289     GPRReg arg2GPR = arg2.gpr();
 3290     JSValueRegs arg3Regs = arg3.jsValueRegs();
 3291 
 3292     speculateString(child2, arg2GPR);
 3293 
 3294     flushRegisters();
 3295     callOperation(m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValCellStringStrict : operationPutByValCellStringNonStrict, arg1GPR, arg2GPR, arg3Regs);
 3296     m_jit.exceptionCheck();
 3297 
 3298     noResult(node);
 3299 }
 3300 
 3301 void SpeculativeJIT::compilePutByValForCellWithSymbol(Node* node, Edge&amp; child1, Edge&amp; child2, Edge&amp; child3)
 3302 {
 3303     SpeculateCellOperand arg1(this, child1);
 3304     SpeculateCellOperand arg2(this, child2);
 3305     JSValueOperand arg3(this, child3);
 3306 
 3307     GPRReg arg1GPR = arg1.gpr();
 3308     GPRReg arg2GPR = arg2.gpr();
 3309     JSValueRegs arg3Regs = arg3.jsValueRegs();
 3310 
 3311     speculateSymbol(child2, arg2GPR);
 3312 
 3313     flushRegisters();
 3314     callOperation(m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValCellSymbolStrict : operationPutByValCellSymbolNonStrict, arg1GPR, arg2GPR, arg3Regs);
 3315     m_jit.exceptionCheck();
 3316 
 3317     noResult(node);
 3318 }
 3319 
 3320 void SpeculativeJIT::compileGetByValWithThis(Node* node)
 3321 {
 3322     JSValueOperand base(this, node-&gt;child1());
 3323     JSValueRegs baseRegs = base.jsValueRegs();
 3324     JSValueOperand thisValue(this, node-&gt;child2());
 3325     JSValueRegs thisValueRegs = thisValue.jsValueRegs();
 3326     JSValueOperand subscript(this, node-&gt;child3());
 3327     JSValueRegs subscriptRegs = subscript.jsValueRegs();
 3328 
 3329     flushRegisters();
 3330     JSValueRegsFlushedCallResult result(this);
 3331     JSValueRegs resultRegs = result.regs();
 3332     callOperation(operationGetByValWithThis, resultRegs, baseRegs, thisValueRegs, subscriptRegs);
 3333     m_jit.exceptionCheck();
 3334 
 3335     jsValueResult(resultRegs, node);
 3336 }
 3337 
 3338 void SpeculativeJIT::compileCheckTypeInfoFlags(Node* node)
 3339 {
 3340     SpeculateCellOperand base(this, node-&gt;child1());
 3341 
 3342     GPRReg baseGPR = base.gpr();
 3343 
 3344     // FIXME: This only works for checking if a single bit is set. If we want to check more
 3345     // than one bit at once, we&#39;ll need to fix this:
 3346     // https://bugs.webkit.org/show_bug.cgi?id=185705
 3347     speculationCheck(BadTypeInfoFlags, JSValueRegs(), 0, m_jit.branchTest8(MacroAssembler::Zero, MacroAssembler::Address(baseGPR, JSCell::typeInfoFlagsOffset()), MacroAssembler::TrustedImm32(node-&gt;typeInfoOperand())));
 3348 
 3349     noResult(node);
 3350 }
 3351 
 3352 void SpeculativeJIT::compileParseInt(Node* node)
 3353 {
 3354     RELEASE_ASSERT(node-&gt;child1().useKind() == UntypedUse || node-&gt;child1().useKind() == StringUse);
 3355     if (node-&gt;child2()) {
 3356         SpeculateInt32Operand radix(this, node-&gt;child2());
 3357         GPRReg radixGPR = radix.gpr();
 3358         if (node-&gt;child1().useKind() == UntypedUse) {
 3359             JSValueOperand value(this, node-&gt;child1());
 3360             JSValueRegs valueRegs = value.jsValueRegs();
 3361 
 3362             flushRegisters();
 3363             JSValueRegsFlushedCallResult result(this);
 3364             JSValueRegs resultRegs = result.regs();
 3365             callOperation(operationParseIntGeneric, resultRegs, valueRegs, radixGPR);
 3366             m_jit.exceptionCheck();
 3367             jsValueResult(resultRegs, node);
 3368             return;
 3369         }
 3370 
 3371         SpeculateCellOperand value(this, node-&gt;child1());
 3372         GPRReg valueGPR = value.gpr();
 3373         speculateString(node-&gt;child1(), valueGPR);
 3374 
 3375         flushRegisters();
 3376         JSValueRegsFlushedCallResult result(this);
 3377         JSValueRegs resultRegs = result.regs();
 3378         callOperation(operationParseIntString, resultRegs, valueGPR, radixGPR);
 3379         m_jit.exceptionCheck();
 3380         jsValueResult(resultRegs, node);
 3381         return;
 3382     }
 3383 
 3384     if (node-&gt;child1().useKind() == UntypedUse) {
 3385         JSValueOperand value(this, node-&gt;child1());
 3386         JSValueRegs valueRegs = value.jsValueRegs();
 3387 
 3388         flushRegisters();
 3389         JSValueRegsFlushedCallResult result(this);
 3390         JSValueRegs resultRegs = result.regs();
 3391         callOperation(operationParseIntNoRadixGeneric, resultRegs, valueRegs);
 3392         m_jit.exceptionCheck();
 3393         jsValueResult(resultRegs, node);
 3394         return;
 3395     }
 3396 
 3397     SpeculateCellOperand value(this, node-&gt;child1());
 3398     GPRReg valueGPR = value.gpr();
 3399     speculateString(node-&gt;child1(), valueGPR);
 3400 
 3401     flushRegisters();
 3402     JSValueRegsFlushedCallResult result(this);
 3403     JSValueRegs resultRegs = result.regs();
 3404     callOperation(operationParseIntStringNoRadix, resultRegs, valueGPR);
 3405     m_jit.exceptionCheck();
 3406     jsValueResult(resultRegs, node);
 3407 }
 3408 
 3409 void SpeculativeJIT::compileOverridesHasInstance(Node* node)
 3410 {
 3411     Node* hasInstanceValueNode = node-&gt;child2().node();
 3412     JSFunction* defaultHasInstanceFunction = jsCast&lt;JSFunction*&gt;(node-&gt;cellOperand()-&gt;value());
 3413 
 3414     MacroAssembler::JumpList notDefault;
 3415     SpeculateCellOperand base(this, node-&gt;child1());
 3416     JSValueOperand hasInstanceValue(this, node-&gt;child2());
 3417     GPRTemporary result(this);
 3418 
 3419     GPRReg baseGPR = base.gpr();
 3420     GPRReg resultGPR = result.gpr();
 3421 
 3422     // It would be great if constant folding handled automatically the case where we knew the hasInstance function
 3423     // was a constant. Unfortunately, the folding rule for OverridesHasInstance is in the strength reduction phase
 3424     // since it relies on OSR information. https://bugs.webkit.org/show_bug.cgi?id=154832
 3425     if (!hasInstanceValueNode-&gt;isCellConstant() || defaultHasInstanceFunction != hasInstanceValueNode-&gt;asCell()) {
 3426         JSValueRegs hasInstanceValueRegs = hasInstanceValue.jsValueRegs();
 3427 #if USE(JSVALUE64)
 3428         notDefault.append(m_jit.branchPtr(MacroAssembler::NotEqual, hasInstanceValueRegs.gpr(), TrustedImmPtr(node-&gt;cellOperand())));
 3429 #else
 3430         notDefault.append(m_jit.branchIfNotCell(hasInstanceValueRegs));
 3431         notDefault.append(m_jit.branchPtr(MacroAssembler::NotEqual, hasInstanceValueRegs.payloadGPR(), TrustedImmPtr(node-&gt;cellOperand())));
 3432 #endif
 3433     }
 3434 
 3435     // Check that base &#39;ImplementsDefaultHasInstance&#39;.
 3436     m_jit.test8(MacroAssembler::Zero, MacroAssembler::Address(baseGPR, JSCell::typeInfoFlagsOffset()), MacroAssembler::TrustedImm32(ImplementsDefaultHasInstance), resultGPR);
 3437     MacroAssembler::Jump done = m_jit.jump();
 3438 
 3439     if (!notDefault.empty()) {
 3440         notDefault.link(&amp;m_jit);
 3441         m_jit.move(TrustedImm32(1), resultGPR);
 3442     }
 3443 
 3444     done.link(&amp;m_jit);
 3445     unblessedBooleanResult(resultGPR, node);
 3446 }
 3447 
 3448 void SpeculativeJIT::compileInstanceOfForCells(Node* node, JSValueRegs valueRegs, JSValueRegs prototypeRegs, GPRReg resultGPR, GPRReg scratchGPR, GPRReg scratch2GPR, JITCompiler::Jump slowCase)
 3449 {
 3450     CallSiteIndex callSiteIndex = m_jit.addCallSite(node-&gt;origin.semantic);
 3451 
 3452     JITInstanceOfGenerator gen(
 3453         m_jit.codeBlock(), node-&gt;origin.semantic, callSiteIndex, usedRegisters(), resultGPR,
 3454         valueRegs.payloadGPR(), prototypeRegs.payloadGPR(), scratchGPR, scratch2GPR,
 3455         m_state.forNode(node-&gt;child2()).isType(SpecObject | ~SpecCell));
 3456     gen.generateFastPath(m_jit);
 3457 
 3458     JITCompiler::JumpList slowCases;
 3459     slowCases.append(slowCase);
 3460 
 3461     std::unique_ptr&lt;SlowPathGenerator&gt; slowPath = slowPathCall(
 3462         slowCases, this, operationInstanceOfOptimize, resultGPR, gen.stubInfo(), valueRegs,
 3463         prototypeRegs);
 3464 
 3465     m_jit.addInstanceOf(gen, slowPath.get());
 3466     addSlowPathGenerator(WTFMove(slowPath));
 3467 }
 3468 
 3469 void SpeculativeJIT::compileInstanceOf(Node* node)
 3470 {
 3471 #if USE(JSVALUE64)
 3472     if (node-&gt;child1().useKind() == CellUse
 3473         &amp;&amp; node-&gt;child2().useKind() == CellUse) {
 3474         SpeculateCellOperand value(this, node-&gt;child1());
 3475         SpeculateCellOperand prototype(this, node-&gt;child2());
 3476 
 3477         GPRTemporary result(this);
 3478         GPRTemporary scratch(this);
 3479         GPRTemporary scratch2(this);
 3480 
 3481         GPRReg valueGPR = value.gpr();
 3482         GPRReg prototypeGPR = prototype.gpr();
 3483         GPRReg resultGPR = result.gpr();
 3484         GPRReg scratchGPR = scratch.gpr();
 3485         GPRReg scratch2GPR = scratch2.gpr();
 3486 
 3487         compileInstanceOfForCells(node, JSValueRegs(valueGPR), JSValueRegs(prototypeGPR), resultGPR, scratchGPR, scratch2GPR);
 3488 
 3489         blessedBooleanResult(resultGPR, node);
 3490         return;
 3491     }
 3492 #endif
 3493 
 3494     DFG_ASSERT(m_jit.graph(), node, node-&gt;child1().useKind() == UntypedUse);
 3495     DFG_ASSERT(m_jit.graph(), node, node-&gt;child2().useKind() == UntypedUse);
 3496 
 3497     JSValueOperand value(this, node-&gt;child1());
 3498     JSValueOperand prototype(this, node-&gt;child2());
 3499 
 3500     GPRTemporary result(this);
 3501     GPRTemporary scratch(this);
 3502 
 3503     JSValueRegs valueRegs = value.jsValueRegs();
 3504     JSValueRegs prototypeRegs = prototype.jsValueRegs();
 3505 
 3506     GPRReg resultGPR = result.gpr();
 3507     GPRReg scratchGPR = scratch.gpr();
 3508 
 3509     JITCompiler::Jump isCell = m_jit.branchIfCell(valueRegs);
 3510     moveFalseTo(resultGPR);
 3511 
 3512     JITCompiler::Jump done = m_jit.jump();
 3513 
 3514     isCell.link(&amp;m_jit);
 3515 
 3516     JITCompiler::Jump slowCase = m_jit.branchIfNotCell(prototypeRegs);
 3517 
 3518     compileInstanceOfForCells(node, valueRegs, prototypeRegs, resultGPR, scratchGPR, InvalidGPRReg, slowCase);
 3519 
 3520     done.link(&amp;m_jit);
 3521     blessedBooleanResult(resultGPR, node);
 3522     return;
 3523 }
 3524 
 3525 void SpeculativeJIT::compileBitwiseNot(Node* node)
 3526 {
 3527     Edge&amp; child1 = node-&gt;child1();
 3528 
 3529     if (child1.useKind() == UntypedUse) {
 3530         JSValueOperand operand(this, child1);
 3531         JSValueRegs operandRegs = operand.jsValueRegs();
 3532 
 3533         flushRegisters();
 3534         JSValueRegsFlushedCallResult result(this);
 3535         JSValueRegs resultRegs = result.regs();
 3536         callOperation(operationValueBitNot, resultRegs, operandRegs);
 3537         m_jit.exceptionCheck();
 3538 
 3539         jsValueResult(resultRegs, node);
 3540         return;
 3541     }
 3542 
 3543     SpeculateInt32Operand operand(this, child1);
 3544     GPRTemporary result(this);
 3545     GPRReg resultGPR = result.gpr();
 3546 
 3547     m_jit.move(operand.gpr(), resultGPR);
 3548 
 3549     m_jit.not32(resultGPR);
 3550 
 3551     int32Result(resultGPR, node);
 3552 }
 3553 
 3554 template&lt;typename SnippetGenerator, J_JITOperation_EJJ snippetSlowPathFunction&gt;
 3555 void SpeculativeJIT::emitUntypedBitOp(Node* node)
 3556 {
 3557     Edge&amp; leftChild = node-&gt;child1();
 3558     Edge&amp; rightChild = node-&gt;child2();
 3559 
 3560     if (isKnownNotNumber(leftChild.node()) || isKnownNotNumber(rightChild.node())) {
 3561         JSValueOperand left(this, leftChild);
 3562         JSValueOperand right(this, rightChild);
 3563         JSValueRegs leftRegs = left.jsValueRegs();
 3564         JSValueRegs rightRegs = right.jsValueRegs();
 3565 
 3566         flushRegisters();
 3567         JSValueRegsFlushedCallResult result(this);
 3568         JSValueRegs resultRegs = result.regs();
 3569         callOperation(snippetSlowPathFunction, resultRegs, leftRegs, rightRegs);
 3570         m_jit.exceptionCheck();
 3571 
 3572         jsValueResult(resultRegs, node);
 3573         return;
 3574     }
 3575 
 3576     Optional&lt;JSValueOperand&gt; left;
 3577     Optional&lt;JSValueOperand&gt; right;
 3578 
 3579     JSValueRegs leftRegs;
 3580     JSValueRegs rightRegs;
 3581 
 3582 #if USE(JSVALUE64)
 3583     GPRTemporary result(this);
 3584     JSValueRegs resultRegs = JSValueRegs(result.gpr());
 3585     GPRTemporary scratch(this);
 3586     GPRReg scratchGPR = scratch.gpr();
 3587 #else
 3588     GPRTemporary resultTag(this);
 3589     GPRTemporary resultPayload(this);
 3590     JSValueRegs resultRegs = JSValueRegs(resultPayload.gpr(), resultTag.gpr());
 3591     GPRReg scratchGPR = resultTag.gpr();
 3592 #endif
 3593 
 3594     SnippetOperand leftOperand;
 3595     SnippetOperand rightOperand;
 3596 
 3597     // The snippet generator does not support both operands being constant. If the left
 3598     // operand is already const, we&#39;ll ignore the right operand&#39;s constness.
 3599     if (leftChild-&gt;isInt32Constant())
 3600         leftOperand.setConstInt32(leftChild-&gt;asInt32());
 3601     else if (rightChild-&gt;isInt32Constant())
 3602         rightOperand.setConstInt32(rightChild-&gt;asInt32());
 3603 
 3604     RELEASE_ASSERT(!leftOperand.isConst() || !rightOperand.isConst());
 3605 
 3606     if (!leftOperand.isConst()) {
 3607         left.emplace(this, leftChild);
 3608         leftRegs = left-&gt;jsValueRegs();
 3609     }
 3610     if (!rightOperand.isConst()) {
 3611         right.emplace(this, rightChild);
 3612         rightRegs = right-&gt;jsValueRegs();
 3613     }
 3614 
 3615     SnippetGenerator gen(leftOperand, rightOperand, resultRegs, leftRegs, rightRegs, scratchGPR);
 3616     gen.generateFastPath(m_jit);
 3617 
 3618     ASSERT(gen.didEmitFastPath());
 3619     gen.endJumpList().append(m_jit.jump());
 3620 
 3621     gen.slowPathJumpList().link(&amp;m_jit);
 3622     silentSpillAllRegisters(resultRegs);
 3623 
 3624     if (leftOperand.isConst()) {
 3625         leftRegs = resultRegs;
 3626         m_jit.moveValue(leftChild-&gt;asJSValue(), leftRegs);
 3627     } else if (rightOperand.isConst()) {
 3628         rightRegs = resultRegs;
 3629         m_jit.moveValue(rightChild-&gt;asJSValue(), rightRegs);
 3630     }
 3631 
 3632     callOperation(snippetSlowPathFunction, resultRegs, leftRegs, rightRegs);
 3633 
 3634     silentFillAllRegisters();
 3635     m_jit.exceptionCheck();
 3636 
 3637     gen.endJumpList().link(&amp;m_jit);
 3638     jsValueResult(resultRegs, node);
 3639 }
 3640 
 3641 void SpeculativeJIT::compileValueBitwiseOp(Node* node)
 3642 {
 3643     NodeType op = node-&gt;op();
 3644     Edge&amp; leftChild = node-&gt;child1();
 3645     Edge&amp; rightChild = node-&gt;child2();
 3646 
 3647     if (leftChild.useKind() == UntypedUse || rightChild.useKind() == UntypedUse) {
 3648         switch (op) {
 3649         case ValueBitAnd:
 3650             emitUntypedBitOp&lt;JITBitAndGenerator, operationValueBitAnd&gt;(node);
 3651             return;
 3652         case ValueBitXor:
 3653             emitUntypedBitOp&lt;JITBitXorGenerator, operationValueBitXor&gt;(node);
 3654             return;
 3655         case ValueBitOr:
 3656             emitUntypedBitOp&lt;JITBitOrGenerator, operationValueBitOr&gt;(node);
 3657             return;
 3658         default:
 3659             RELEASE_ASSERT_NOT_REACHED();
 3660         }
 3661     }
 3662 
 3663     ASSERT(leftChild.useKind() == BigIntUse &amp;&amp; rightChild.useKind() == BigIntUse);
 3664 
 3665     SpeculateCellOperand left(this, node-&gt;child1());
 3666     SpeculateCellOperand right(this, node-&gt;child2());
 3667     GPRReg leftGPR = left.gpr();
 3668     GPRReg rightGPR = right.gpr();
 3669 
 3670     speculateBigInt(leftChild, leftGPR);
 3671     speculateBigInt(rightChild, rightGPR);
 3672 
 3673     flushRegisters();
 3674     GPRFlushedCallResult result(this);
 3675     GPRReg resultGPR = result.gpr();
 3676 
 3677     switch (op) {
 3678     case ValueBitAnd:
 3679         callOperation(operationBitAndBigInt, resultGPR, leftGPR, rightGPR);
 3680         break;
 3681     case ValueBitXor:
 3682         callOperation(operationBitXorBigInt, resultGPR, leftGPR, rightGPR);
 3683         break;
 3684     case ValueBitOr:
 3685         callOperation(operationBitOrBigInt, resultGPR, leftGPR, rightGPR);
 3686         break;
 3687     default:
 3688         RELEASE_ASSERT_NOT_REACHED();
 3689     }
 3690 
 3691     m_jit.exceptionCheck();
 3692     cellResult(resultGPR, node);
 3693 }
 3694 
 3695 void SpeculativeJIT::compileBitwiseOp(Node* node)
 3696 {
 3697     NodeType op = node-&gt;op();
 3698     Edge&amp; leftChild = node-&gt;child1();
 3699     Edge&amp; rightChild = node-&gt;child2();
 3700 
 3701     if (leftChild-&gt;isInt32Constant()) {
 3702         SpeculateInt32Operand op2(this, rightChild);
 3703         GPRTemporary result(this, Reuse, op2);
 3704 
 3705         bitOp(op, leftChild-&gt;asInt32(), op2.gpr(), result.gpr());
 3706 
 3707         int32Result(result.gpr(), node);
 3708         return;
 3709     }
 3710 
 3711     if (rightChild-&gt;isInt32Constant()) {
 3712         SpeculateInt32Operand op1(this, leftChild);
 3713         GPRTemporary result(this, Reuse, op1);
 3714 
 3715         bitOp(op, rightChild-&gt;asInt32(), op1.gpr(), result.gpr());
 3716 
 3717         int32Result(result.gpr(), node);
 3718         return;
 3719     }
 3720 
 3721     SpeculateInt32Operand op1(this, leftChild);
 3722     SpeculateInt32Operand op2(this, rightChild);
 3723     GPRTemporary result(this, Reuse, op1, op2);
 3724 
 3725     GPRReg reg1 = op1.gpr();
 3726     GPRReg reg2 = op2.gpr();
 3727     bitOp(op, reg1, reg2, result.gpr());
 3728 
 3729     int32Result(result.gpr(), node);
 3730 }
 3731 
 3732 void SpeculativeJIT::emitUntypedRightShiftBitOp(Node* node)
 3733 {
 3734     J_JITOperation_EJJ snippetSlowPathFunction = node-&gt;op() == BitRShift
 3735         ? operationValueBitRShift : operationValueBitURShift;
 3736     JITRightShiftGenerator::ShiftType shiftType = node-&gt;op() == BitRShift
 3737         ? JITRightShiftGenerator::SignedShift : JITRightShiftGenerator::UnsignedShift;
 3738 
 3739     Edge&amp; leftChild = node-&gt;child1();
 3740     Edge&amp; rightChild = node-&gt;child2();
 3741 
 3742     if (isKnownNotNumber(leftChild.node()) || isKnownNotNumber(rightChild.node())) {
 3743         JSValueOperand left(this, leftChild);
 3744         JSValueOperand right(this, rightChild);
 3745         JSValueRegs leftRegs = left.jsValueRegs();
 3746         JSValueRegs rightRegs = right.jsValueRegs();
 3747 
 3748         flushRegisters();
 3749         JSValueRegsFlushedCallResult result(this);
 3750         JSValueRegs resultRegs = result.regs();
 3751         callOperation(snippetSlowPathFunction, resultRegs, leftRegs, rightRegs);
 3752         m_jit.exceptionCheck();
 3753 
 3754         jsValueResult(resultRegs, node);
 3755         return;
 3756     }
 3757 
 3758     Optional&lt;JSValueOperand&gt; left;
 3759     Optional&lt;JSValueOperand&gt; right;
 3760 
 3761     JSValueRegs leftRegs;
 3762     JSValueRegs rightRegs;
 3763 
 3764     FPRTemporary leftNumber(this);
 3765     FPRReg leftFPR = leftNumber.fpr();
 3766 
 3767 #if USE(JSVALUE64)
 3768     GPRTemporary result(this);
 3769     JSValueRegs resultRegs = JSValueRegs(result.gpr());
 3770     GPRTemporary scratch(this);
 3771     GPRReg scratchGPR = scratch.gpr();
 3772     FPRReg scratchFPR = InvalidFPRReg;
 3773 #else
 3774     GPRTemporary resultTag(this);
 3775     GPRTemporary resultPayload(this);
 3776     JSValueRegs resultRegs = JSValueRegs(resultPayload.gpr(), resultTag.gpr());
 3777     GPRReg scratchGPR = resultTag.gpr();
 3778     FPRTemporary fprScratch(this);
 3779     FPRReg scratchFPR = fprScratch.fpr();
 3780 #endif
 3781 
 3782     SnippetOperand leftOperand;
 3783     SnippetOperand rightOperand;
 3784 
 3785     // The snippet generator does not support both operands being constant. If the left
 3786     // operand is already const, we&#39;ll ignore the right operand&#39;s constness.
 3787     if (leftChild-&gt;isInt32Constant())
 3788         leftOperand.setConstInt32(leftChild-&gt;asInt32());
 3789     else if (rightChild-&gt;isInt32Constant())
 3790         rightOperand.setConstInt32(rightChild-&gt;asInt32());
 3791 
 3792     RELEASE_ASSERT(!leftOperand.isConst() || !rightOperand.isConst());
 3793 
 3794     if (!leftOperand.isConst()) {
 3795         left.emplace(this, leftChild);
 3796         leftRegs = left-&gt;jsValueRegs();
 3797     }
 3798     if (!rightOperand.isConst()) {
 3799         right.emplace(this, rightChild);
 3800         rightRegs = right-&gt;jsValueRegs();
 3801     }
 3802 
 3803     JITRightShiftGenerator gen(leftOperand, rightOperand, resultRegs, leftRegs, rightRegs,
 3804         leftFPR, scratchGPR, scratchFPR, shiftType);
 3805     gen.generateFastPath(m_jit);
 3806 
 3807     ASSERT(gen.didEmitFastPath());
 3808     gen.endJumpList().append(m_jit.jump());
 3809 
 3810     gen.slowPathJumpList().link(&amp;m_jit);
 3811     silentSpillAllRegisters(resultRegs);
 3812 
 3813     if (leftOperand.isConst()) {
 3814         leftRegs = resultRegs;
 3815         m_jit.moveValue(leftChild-&gt;asJSValue(), leftRegs);
 3816     } else if (rightOperand.isConst()) {
 3817         rightRegs = resultRegs;
 3818         m_jit.moveValue(rightChild-&gt;asJSValue(), rightRegs);
 3819     }
 3820 
 3821     callOperation(snippetSlowPathFunction, resultRegs, leftRegs, rightRegs);
 3822 
 3823     silentFillAllRegisters();
 3824     m_jit.exceptionCheck();
 3825 
 3826     gen.endJumpList().link(&amp;m_jit);
 3827     jsValueResult(resultRegs, node);
 3828     return;
 3829 }
 3830 
 3831 void SpeculativeJIT::compileShiftOp(Node* node)
 3832 {
 3833     NodeType op = node-&gt;op();
 3834     Edge&amp; leftChild = node-&gt;child1();
 3835     Edge&amp; rightChild = node-&gt;child2();
 3836 
 3837     if (leftChild.useKind() == UntypedUse || rightChild.useKind() == UntypedUse) {
 3838         switch (op) {
 3839         case BitLShift:
 3840             emitUntypedBitOp&lt;JITLeftShiftGenerator, operationValueBitLShift&gt;(node);
 3841             return;
 3842         case BitRShift:
 3843         case BitURShift:
 3844             emitUntypedRightShiftBitOp(node);
 3845             return;
 3846         default:
 3847             RELEASE_ASSERT_NOT_REACHED();
 3848         }
 3849     }
 3850 
 3851     if (rightChild-&gt;isInt32Constant()) {
 3852         SpeculateInt32Operand op1(this, leftChild);
 3853         GPRTemporary result(this, Reuse, op1);
 3854 
 3855         shiftOp(op, op1.gpr(), rightChild-&gt;asInt32() &amp; 0x1f, result.gpr());
 3856 
 3857         int32Result(result.gpr(), node);
 3858     } else {
 3859         // Do not allow shift amount to be used as the result, MacroAssembler does not permit this.
 3860         SpeculateInt32Operand op1(this, leftChild);
 3861         SpeculateInt32Operand op2(this, rightChild);
 3862         GPRTemporary result(this, Reuse, op1);
 3863 
 3864         GPRReg reg1 = op1.gpr();
 3865         GPRReg reg2 = op2.gpr();
 3866         shiftOp(op, reg1, reg2, result.gpr());
 3867 
 3868         int32Result(result.gpr(), node);
 3869     }
 3870 }
 3871 
 3872 void SpeculativeJIT::compileValueAdd(Node* node)
 3873 {
 3874     Edge&amp; leftChild = node-&gt;child1();
 3875     Edge&amp; rightChild = node-&gt;child2();
 3876 
 3877     if (node-&gt;isBinaryUseKind(BigIntUse)) {
 3878         SpeculateCellOperand left(this, node-&gt;child1());
 3879         SpeculateCellOperand right(this, node-&gt;child2());
 3880         GPRReg leftGPR = left.gpr();
 3881         GPRReg rightGPR = right.gpr();
 3882 
 3883         speculateBigInt(leftChild, leftGPR);
 3884         speculateBigInt(rightChild, rightGPR);
 3885 
 3886         flushRegisters();
 3887         GPRFlushedCallResult result(this);
 3888         GPRReg resultGPR = result.gpr();
 3889         callOperation(operationAddBigInt, resultGPR, leftGPR, rightGPR);
 3890         m_jit.exceptionCheck();
 3891 
 3892         cellResult(resultGPR, node);
 3893         return;
 3894     }
 3895 
 3896     if (isKnownNotNumber(leftChild.node()) || isKnownNotNumber(rightChild.node())) {
 3897         JSValueOperand left(this, leftChild);
 3898         JSValueOperand right(this, rightChild);
 3899         JSValueRegs leftRegs = left.jsValueRegs();
 3900         JSValueRegs rightRegs = right.jsValueRegs();
 3901 
 3902         flushRegisters();
 3903         JSValueRegsFlushedCallResult result(this);
 3904         JSValueRegs resultRegs = result.regs();
 3905         callOperation(operationValueAddNotNumber, resultRegs, leftRegs, rightRegs);
 3906         m_jit.exceptionCheck();
 3907 
 3908         jsValueResult(resultRegs, node);
 3909         return;
 3910     }
 3911 
 3912 #if USE(JSVALUE64)
 3913     bool needsScratchGPRReg = true;
 3914     bool needsScratchFPRReg = false;
 3915 #else
 3916     bool needsScratchGPRReg = true;
 3917     bool needsScratchFPRReg = true;
 3918 #endif
 3919 
 3920     CodeBlock* baselineCodeBlock = m_jit.graph().baselineCodeBlockFor(node-&gt;origin.semantic);
 3921     ArithProfile* arithProfile = baselineCodeBlock-&gt;arithProfileForBytecodeOffset(node-&gt;origin.semantic.bytecodeIndex);
 3922     const Instruction* instruction = baselineCodeBlock-&gt;instructions().at(node-&gt;origin.semantic.bytecodeIndex).ptr();
 3923     JITAddIC* addIC = m_jit.codeBlock()-&gt;addJITAddIC(arithProfile, instruction);
 3924     auto repatchingFunction = operationValueAddOptimize;
 3925     auto nonRepatchingFunction = operationValueAdd;
 3926 
 3927     compileMathIC(node, addIC, needsScratchGPRReg, needsScratchFPRReg, repatchingFunction, nonRepatchingFunction);
 3928 }
 3929 
 3930 void SpeculativeJIT::compileValueSub(Node* node)
 3931 {
 3932     Edge&amp; leftChild = node-&gt;child1();
 3933     Edge&amp; rightChild = node-&gt;child2();
 3934 
 3935     if (node-&gt;binaryUseKind() == UntypedUse) {
 3936 #if USE(JSVALUE64)
 3937         bool needsScratchGPRReg = true;
 3938         bool needsScratchFPRReg = false;
 3939 #else
 3940         bool needsScratchGPRReg = true;
 3941         bool needsScratchFPRReg = true;
 3942 #endif
 3943 
 3944         CodeBlock* baselineCodeBlock = m_jit.graph().baselineCodeBlockFor(node-&gt;origin.semantic);
 3945         ArithProfile* arithProfile = baselineCodeBlock-&gt;arithProfileForBytecodeOffset(node-&gt;origin.semantic.bytecodeIndex);
 3946         const Instruction* instruction = baselineCodeBlock-&gt;instructions().at(node-&gt;origin.semantic.bytecodeIndex).ptr();
 3947         JITSubIC* subIC = m_jit.codeBlock()-&gt;addJITSubIC(arithProfile, instruction);
 3948         auto repatchingFunction = operationValueSubOptimize;
 3949         auto nonRepatchingFunction = operationValueSub;
 3950 
 3951         compileMathIC(node, subIC, needsScratchGPRReg, needsScratchFPRReg, repatchingFunction, nonRepatchingFunction);
 3952         return;
 3953     }
 3954 
 3955     ASSERT(leftChild.useKind() == BigIntUse &amp;&amp; rightChild.useKind() == BigIntUse);
 3956 
 3957     SpeculateCellOperand left(this, node-&gt;child1());
 3958     SpeculateCellOperand right(this, node-&gt;child2());
 3959     GPRReg leftGPR = left.gpr();
 3960     GPRReg rightGPR = right.gpr();
 3961 
 3962     speculateBigInt(leftChild, leftGPR);
 3963     speculateBigInt(rightChild, rightGPR);
 3964 
 3965     flushRegisters();
 3966     GPRFlushedCallResult result(this);
 3967     GPRReg resultGPR = result.gpr();
 3968 
 3969     callOperation(operationSubBigInt, resultGPR, leftGPR, rightGPR);
 3970 
 3971     m_jit.exceptionCheck();
 3972     cellResult(resultGPR, node);
 3973 }
 3974 
 3975 template &lt;typename Generator, typename RepatchingFunction, typename NonRepatchingFunction&gt;
 3976 void SpeculativeJIT::compileMathIC(Node* node, JITBinaryMathIC&lt;Generator&gt;* mathIC, bool needsScratchGPRReg, bool needsScratchFPRReg, RepatchingFunction repatchingFunction, NonRepatchingFunction nonRepatchingFunction)
 3977 {
 3978     Edge&amp; leftChild = node-&gt;child1();
 3979     Edge&amp; rightChild = node-&gt;child2();
 3980 
 3981     Optional&lt;JSValueOperand&gt; left;
 3982     Optional&lt;JSValueOperand&gt; right;
 3983 
 3984     JSValueRegs leftRegs;
 3985     JSValueRegs rightRegs;
 3986 
 3987     FPRTemporary leftNumber(this);
 3988     FPRTemporary rightNumber(this);
 3989     FPRReg leftFPR = leftNumber.fpr();
 3990     FPRReg rightFPR = rightNumber.fpr();
 3991 
 3992     GPRReg scratchGPR = InvalidGPRReg;
 3993     FPRReg scratchFPR = InvalidFPRReg;
 3994 
 3995     Optional&lt;FPRTemporary&gt; fprScratch;
 3996     if (needsScratchFPRReg) {
 3997         fprScratch.emplace(this);
 3998         scratchFPR = fprScratch-&gt;fpr();
 3999     }
 4000 
 4001 #if USE(JSVALUE64)
 4002     Optional&lt;GPRTemporary&gt; gprScratch;
 4003     if (needsScratchGPRReg) {
 4004         gprScratch.emplace(this);
 4005         scratchGPR = gprScratch-&gt;gpr();
 4006     }
 4007     GPRTemporary result(this);
 4008     JSValueRegs resultRegs = JSValueRegs(result.gpr());
 4009 #else
 4010     GPRTemporary resultTag(this);
 4011     GPRTemporary resultPayload(this);
 4012     JSValueRegs resultRegs = JSValueRegs(resultPayload.gpr(), resultTag.gpr());
 4013     if (needsScratchGPRReg)
 4014         scratchGPR = resultRegs.tagGPR();
 4015 #endif
 4016 
 4017     SnippetOperand leftOperand(m_state.forNode(leftChild).resultType());
 4018     SnippetOperand rightOperand(m_state.forNode(rightChild).resultType());
 4019 
 4020     // The snippet generator does not support both operands being constant. If the left
 4021     // operand is already const, we&#39;ll ignore the right operand&#39;s constness.
 4022     if (leftChild-&gt;isInt32Constant())
 4023         leftOperand.setConstInt32(leftChild-&gt;asInt32());
 4024     else if (rightChild-&gt;isInt32Constant())
 4025         rightOperand.setConstInt32(rightChild-&gt;asInt32());
 4026 
 4027     ASSERT(!leftOperand.isConst() || !rightOperand.isConst());
 4028     ASSERT(!(Generator::isLeftOperandValidConstant(leftOperand) &amp;&amp; Generator::isRightOperandValidConstant(rightOperand)));
 4029 
 4030     if (!Generator::isLeftOperandValidConstant(leftOperand)) {
 4031         left.emplace(this, leftChild);
 4032         leftRegs = left-&gt;jsValueRegs();
 4033     }
 4034     if (!Generator::isRightOperandValidConstant(rightOperand)) {
 4035         right.emplace(this, rightChild);
 4036         rightRegs = right-&gt;jsValueRegs();
 4037     }
 4038 
 4039 #if ENABLE(MATH_IC_STATS)
 4040     auto inlineStart = m_jit.label();
 4041 #endif
 4042 
 4043     Box&lt;MathICGenerationState&gt; addICGenerationState = Box&lt;MathICGenerationState&gt;::create();
 4044     mathIC-&gt;m_generator = Generator(leftOperand, rightOperand, resultRegs, leftRegs, rightRegs, leftFPR, rightFPR, scratchGPR, scratchFPR);
 4045 
 4046     bool shouldEmitProfiling = false;
 4047     bool generatedInline = mathIC-&gt;generateInline(m_jit, *addICGenerationState, shouldEmitProfiling);
 4048     if (generatedInline) {
 4049         ASSERT(!addICGenerationState-&gt;slowPathJumps.empty());
 4050 
 4051         Vector&lt;SilentRegisterSavePlan&gt; savePlans;
 4052         silentSpillAllRegistersImpl(false, savePlans, resultRegs);
 4053 
 4054         auto done = m_jit.label();
 4055 
 4056         addSlowPathGeneratorLambda([=, savePlans = WTFMove(savePlans)] () {
 4057             addICGenerationState-&gt;slowPathJumps.link(&amp;m_jit);
 4058             addICGenerationState-&gt;slowPathStart = m_jit.label();
 4059 #if ENABLE(MATH_IC_STATS)
 4060             auto slowPathStart = m_jit.label();
 4061 #endif
 4062 
 4063             silentSpill(savePlans);
 4064 
 4065             auto innerLeftRegs = leftRegs;
 4066             auto innerRightRegs = rightRegs;
 4067             if (Generator::isLeftOperandValidConstant(leftOperand)) {
 4068                 innerLeftRegs = resultRegs;
 4069                 m_jit.moveValue(leftChild-&gt;asJSValue(), innerLeftRegs);
 4070             } else if (Generator::isRightOperandValidConstant(rightOperand)) {
 4071                 innerRightRegs = resultRegs;
 4072                 m_jit.moveValue(rightChild-&gt;asJSValue(), innerRightRegs);
 4073             }
 4074 
 4075             if (addICGenerationState-&gt;shouldSlowPathRepatch)
 4076                 addICGenerationState-&gt;slowPathCall = callOperation(bitwise_cast&lt;J_JITOperation_EJJMic&gt;(repatchingFunction), resultRegs, innerLeftRegs, innerRightRegs, TrustedImmPtr(mathIC));
 4077             else
 4078                 addICGenerationState-&gt;slowPathCall = callOperation(nonRepatchingFunction, resultRegs, innerLeftRegs, innerRightRegs);
 4079 
 4080             silentFill(savePlans);
 4081             m_jit.exceptionCheck();
 4082             m_jit.jump().linkTo(done, &amp;m_jit);
 4083 
 4084             m_jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
 4085                 mathIC-&gt;finalizeInlineCode(*addICGenerationState, linkBuffer);
 4086             });
 4087 
 4088 #if ENABLE(MATH_IC_STATS)
 4089             auto slowPathEnd = m_jit.label();
 4090             m_jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
 4091                 size_t size = static_cast&lt;char*&gt;(linkBuffer.locationOf(slowPathEnd).executableAddress()) - static_cast&lt;char*&gt;(linkBuffer.locationOf(slowPathStart).executableAddress());
 4092                 mathIC-&gt;m_generatedCodeSize += size;
 4093             });
 4094 #endif
 4095 
 4096         });
 4097     } else {
 4098         if (Generator::isLeftOperandValidConstant(leftOperand)) {
 4099             left.emplace(this, leftChild);
 4100             leftRegs = left-&gt;jsValueRegs();
 4101         } else if (Generator::isRightOperandValidConstant(rightOperand)) {
 4102             right.emplace(this, rightChild);
 4103             rightRegs = right-&gt;jsValueRegs();
 4104         }
 4105 
 4106         flushRegisters();
 4107         callOperation(nonRepatchingFunction, resultRegs, leftRegs, rightRegs);
 4108         m_jit.exceptionCheck();
 4109     }
 4110 
 4111 #if ENABLE(MATH_IC_STATS)
 4112     auto inlineEnd = m_jit.label();
 4113     m_jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
 4114         size_t size = static_cast&lt;char*&gt;(linkBuffer.locationOf(inlineEnd).executableAddress()) - static_cast&lt;char*&gt;(linkBuffer.locationOf(inlineStart).executableAddress());
 4115         mathIC-&gt;m_generatedCodeSize += size;
 4116     });
 4117 #endif
 4118 
 4119     jsValueResult(resultRegs, node);
 4120     return;
 4121 }
 4122 
 4123 void SpeculativeJIT::compileInstanceOfCustom(Node* node)
 4124 {
 4125     // We could do something smarter here but this case is currently super rare and unless
 4126     // Symbol.hasInstance becomes popular will likely remain that way.
 4127 
 4128     JSValueOperand value(this, node-&gt;child1());
 4129     SpeculateCellOperand constructor(this, node-&gt;child2());
 4130     JSValueOperand hasInstanceValue(this, node-&gt;child3());
 4131     GPRTemporary result(this);
 4132 
 4133     JSValueRegs valueRegs = value.jsValueRegs();
 4134     GPRReg constructorGPR = constructor.gpr();
 4135     JSValueRegs hasInstanceRegs = hasInstanceValue.jsValueRegs();
 4136     GPRReg resultGPR = result.gpr();
 4137 
 4138     MacroAssembler::Jump slowCase = m_jit.jump();
 4139 
 4140     addSlowPathGenerator(slowPathCall(slowCase, this, operationInstanceOfCustom, resultGPR, valueRegs, constructorGPR, hasInstanceRegs));
 4141 
 4142     unblessedBooleanResult(resultGPR, node);
 4143 }
 4144 
 4145 void SpeculativeJIT::compileIsCellWithType(Node* node)
 4146 {
 4147     switch (node-&gt;child1().useKind()) {
 4148     case UntypedUse: {
 4149         JSValueOperand value(this, node-&gt;child1());
 4150         GPRTemporary result(this, Reuse, value, PayloadWord);
 4151 
 4152         JSValueRegs valueRegs = value.jsValueRegs();
 4153         GPRReg resultGPR = result.gpr();
 4154 
 4155         JITCompiler::Jump isNotCell = m_jit.branchIfNotCell(valueRegs);
 4156 
 4157         m_jit.compare8(JITCompiler::Equal,
 4158             JITCompiler::Address(valueRegs.payloadGPR(), JSCell::typeInfoTypeOffset()),
 4159             TrustedImm32(node-&gt;queriedType()),
 4160             resultGPR);
 4161         blessBoolean(resultGPR);
 4162         JITCompiler::Jump done = m_jit.jump();
 4163 
 4164         isNotCell.link(&amp;m_jit);
 4165         moveFalseTo(resultGPR);
 4166 
 4167         done.link(&amp;m_jit);
 4168         blessedBooleanResult(resultGPR, node);
 4169         return;
 4170     }
 4171 
 4172     case CellUse: {
 4173         SpeculateCellOperand cell(this, node-&gt;child1());
 4174         GPRTemporary result(this, Reuse, cell);
 4175 
 4176         GPRReg cellGPR = cell.gpr();
 4177         GPRReg resultGPR = result.gpr();
 4178 
 4179         m_jit.compare8(JITCompiler::Equal,
 4180             JITCompiler::Address(cellGPR, JSCell::typeInfoTypeOffset()),
 4181             TrustedImm32(node-&gt;queriedType()),
 4182             resultGPR);
 4183         blessBoolean(resultGPR);
 4184         blessedBooleanResult(resultGPR, node);
 4185         return;
 4186     }
 4187 
 4188     default:
 4189         RELEASE_ASSERT_NOT_REACHED();
 4190         break;
 4191     }
 4192 }
 4193 
 4194 void SpeculativeJIT::compileIsTypedArrayView(Node* node)
 4195 {
 4196     JSValueOperand value(this, node-&gt;child1());
 4197     GPRTemporary result(this, Reuse, value, PayloadWord);
 4198 
 4199     JSValueRegs valueRegs = value.jsValueRegs();
 4200     GPRReg resultGPR = result.gpr();
 4201 
 4202     JITCompiler::Jump isNotCell = m_jit.branchIfNotCell(valueRegs);
 4203 
 4204     m_jit.load8(JITCompiler::Address(valueRegs.payloadGPR(), JSCell::typeInfoTypeOffset()), resultGPR);
 4205     m_jit.sub32(TrustedImm32(FirstTypedArrayType), resultGPR);
 4206     m_jit.compare32(JITCompiler::Below,
 4207         resultGPR,
 4208         TrustedImm32(NumberOfTypedArrayTypesExcludingDataView),
 4209         resultGPR);
 4210     blessBoolean(resultGPR);
 4211     JITCompiler::Jump done = m_jit.jump();
 4212 
 4213     isNotCell.link(&amp;m_jit);
 4214     moveFalseTo(resultGPR);
 4215 
 4216     done.link(&amp;m_jit);
 4217     blessedBooleanResult(resultGPR, node);
 4218 }
 4219 
 4220 void SpeculativeJIT::compileToObjectOrCallObjectConstructor(Node* node)
 4221 {
 4222     RELEASE_ASSERT(node-&gt;child1().useKind() == UntypedUse);
 4223 
 4224     JSValueOperand value(this, node-&gt;child1());
 4225     GPRTemporary result(this, Reuse, value, PayloadWord);
 4226 
 4227     JSValueRegs valueRegs = value.jsValueRegs();
 4228     GPRReg resultGPR = result.gpr();
 4229 
 4230     MacroAssembler::JumpList slowCases;
 4231     slowCases.append(m_jit.branchIfNotCell(valueRegs));
 4232     slowCases.append(m_jit.branchIfNotObject(valueRegs.payloadGPR()));
 4233     m_jit.move(valueRegs.payloadGPR(), resultGPR);
 4234 
 4235     if (node-&gt;op() == ToObject)
 4236         addSlowPathGenerator(slowPathCall(slowCases, this, operationToObject, resultGPR, m_jit.graph().globalObjectFor(node-&gt;origin.semantic), valueRegs, identifierUID(node-&gt;identifierNumber())));
 4237     else
 4238         addSlowPathGenerator(slowPathCall(slowCases, this, operationCallObjectConstructor, resultGPR, TrustedImmPtr(node-&gt;cellOperand()), valueRegs));
 4239 
 4240     cellResult(resultGPR, node);
 4241 }
 4242 
 4243 void SpeculativeJIT::compileArithAdd(Node* node)
 4244 {
 4245     switch (node-&gt;binaryUseKind()) {
 4246     case Int32Use: {
 4247         ASSERT(!shouldCheckNegativeZero(node-&gt;arithMode()));
 4248 
 4249         if (node-&gt;child2()-&gt;isInt32Constant()) {
 4250             SpeculateInt32Operand op1(this, node-&gt;child1());
 4251             GPRTemporary result(this, Reuse, op1);
 4252 
 4253             GPRReg gpr1 = op1.gpr();
 4254             int32_t imm2 = node-&gt;child2()-&gt;asInt32();
 4255             GPRReg gprResult = result.gpr();
 4256 
 4257             if (!shouldCheckOverflow(node-&gt;arithMode())) {
 4258                 m_jit.add32(Imm32(imm2), gpr1, gprResult);
 4259                 int32Result(gprResult, node);
 4260                 return;
 4261             }
 4262 
 4263             MacroAssembler::Jump check = m_jit.branchAdd32(MacroAssembler::Overflow, gpr1, Imm32(imm2), gprResult);
 4264             if (gpr1 == gprResult) {
 4265                 speculationCheck(Overflow, JSValueRegs(), 0, check,
 4266                     SpeculationRecovery(SpeculativeAddImmediate, gpr1, imm2));
 4267             } else
 4268                 speculationCheck(Overflow, JSValueRegs(), 0, check);
 4269 
 4270             int32Result(gprResult, node);
 4271             return;
 4272         }
 4273 
 4274         SpeculateInt32Operand op1(this, node-&gt;child1());
 4275         SpeculateInt32Operand op2(this, node-&gt;child2());
 4276         GPRTemporary result(this, Reuse, op1, op2);
 4277 
 4278         GPRReg gpr1 = op1.gpr();
 4279         GPRReg gpr2 = op2.gpr();
 4280         GPRReg gprResult = result.gpr();
 4281 
 4282         if (!shouldCheckOverflow(node-&gt;arithMode()))
 4283             m_jit.add32(gpr1, gpr2, gprResult);
 4284         else {
 4285             MacroAssembler::Jump check = m_jit.branchAdd32(MacroAssembler::Overflow, gpr1, gpr2, gprResult);
 4286 
 4287             if (gpr1 == gprResult)
 4288                 speculationCheck(Overflow, JSValueRegs(), 0, check, SpeculationRecovery(SpeculativeAdd, gprResult, gpr2));
 4289             else if (gpr2 == gprResult)
 4290                 speculationCheck(Overflow, JSValueRegs(), 0, check, SpeculationRecovery(SpeculativeAdd, gprResult, gpr1));
 4291             else
 4292                 speculationCheck(Overflow, JSValueRegs(), 0, check);
 4293         }
 4294 
 4295         int32Result(gprResult, node);
 4296         return;
 4297     }
 4298 
 4299 #if USE(JSVALUE64)
 4300     case Int52RepUse: {
 4301         ASSERT(shouldCheckOverflow(node-&gt;arithMode()));
 4302         ASSERT(!shouldCheckNegativeZero(node-&gt;arithMode()));
 4303 
 4304         // Will we need an overflow check? If we can prove that neither input can be
 4305         // Int52 then the overflow check will not be necessary.
 4306         if (!m_state.forNode(node-&gt;child1()).couldBeType(SpecInt52Only)
 4307             &amp;&amp; !m_state.forNode(node-&gt;child2()).couldBeType(SpecInt52Only)) {
 4308             SpeculateWhicheverInt52Operand op1(this, node-&gt;child1());
 4309             SpeculateWhicheverInt52Operand op2(this, node-&gt;child2(), op1);
 4310             GPRTemporary result(this, Reuse, op1);
 4311             m_jit.add64(op1.gpr(), op2.gpr(), result.gpr());
 4312             int52Result(result.gpr(), node, op1.format());
 4313             return;
 4314         }
 4315 
 4316         SpeculateInt52Operand op1(this, node-&gt;child1());
 4317         SpeculateInt52Operand op2(this, node-&gt;child2());
 4318         GPRTemporary result(this);
 4319         m_jit.move(op1.gpr(), result.gpr());
 4320         speculationCheck(
 4321             Int52Overflow, JSValueRegs(), 0,
 4322             m_jit.branchAdd64(MacroAssembler::Overflow, op2.gpr(), result.gpr()));
 4323         int52Result(result.gpr(), node);
 4324         return;
 4325     }
 4326 #endif // USE(JSVALUE64)
 4327 
 4328     case DoubleRepUse: {
 4329         SpeculateDoubleOperand op1(this, node-&gt;child1());
 4330         SpeculateDoubleOperand op2(this, node-&gt;child2());
 4331         FPRTemporary result(this, op1, op2);
 4332 
 4333         FPRReg reg1 = op1.fpr();
 4334         FPRReg reg2 = op2.fpr();
 4335         m_jit.addDouble(reg1, reg2, result.fpr());
 4336 
 4337         doubleResult(result.fpr(), node);
 4338         return;
 4339     }
 4340 
 4341     default:
 4342         RELEASE_ASSERT_NOT_REACHED();
 4343         break;
 4344     }
 4345 }
 4346 
 4347 void SpeculativeJIT::compileArithAbs(Node* node)
 4348 {
 4349     switch (node-&gt;child1().useKind()) {
 4350     case Int32Use: {
 4351         SpeculateStrictInt32Operand op1(this, node-&gt;child1());
 4352         GPRTemporary result(this, Reuse, op1);
 4353         GPRTemporary scratch(this);
 4354 
 4355         m_jit.move(op1.gpr(), result.gpr());
 4356         m_jit.rshift32(result.gpr(), MacroAssembler::TrustedImm32(31), scratch.gpr());
 4357         m_jit.add32(scratch.gpr(), result.gpr());
 4358         m_jit.xor32(scratch.gpr(), result.gpr());
 4359         if (shouldCheckOverflow(node-&gt;arithMode()))
 4360             speculationCheck(Overflow, JSValueRegs(), 0, m_jit.branchTest32(MacroAssembler::Signed, result.gpr()));
 4361         int32Result(result.gpr(), node);
 4362         break;
 4363     }
 4364 
 4365     case DoubleRepUse: {
 4366         SpeculateDoubleOperand op1(this, node-&gt;child1());
 4367         FPRTemporary result(this);
 4368 
 4369         m_jit.absDouble(op1.fpr(), result.fpr());
 4370         doubleResult(result.fpr(), node);
 4371         break;
 4372     }
 4373 
 4374     default: {
 4375         DFG_ASSERT(m_jit.graph(), node, node-&gt;child1().useKind() == UntypedUse, node-&gt;child1().useKind());
 4376         JSValueOperand op1(this, node-&gt;child1());
 4377         JSValueRegs op1Regs = op1.jsValueRegs();
 4378         flushRegisters();
 4379         FPRResult result(this);
 4380         callOperation(operationArithAbs, result.fpr(), op1Regs);
 4381         m_jit.exceptionCheck();
 4382         doubleResult(result.fpr(), node);
 4383         break;
 4384     }
 4385     }
 4386 }
 4387 
 4388 void SpeculativeJIT::compileArithClz32(Node* node)
 4389 {
 4390     if (node-&gt;child1().useKind() == Int32Use || node-&gt;child1().useKind() == KnownInt32Use) {
 4391         SpeculateInt32Operand value(this, node-&gt;child1());
 4392         GPRTemporary result(this, Reuse, value);
 4393         GPRReg valueReg = value.gpr();
 4394         GPRReg resultReg = result.gpr();
 4395         m_jit.countLeadingZeros32(valueReg, resultReg);
 4396         int32Result(resultReg, node);
 4397         return;
 4398     }
 4399     JSValueOperand op1(this, node-&gt;child1());
 4400     JSValueRegs op1Regs = op1.jsValueRegs();
 4401     GPRTemporary result(this);
 4402     GPRReg resultReg = result.gpr();
 4403     flushRegisters();
 4404     callOperation(operationArithClz32, resultReg, op1Regs);
 4405     m_jit.exceptionCheck();
 4406     int32Result(resultReg, node);
 4407 }
 4408 
 4409 void SpeculativeJIT::compileArithDoubleUnaryOp(Node* node, double (*doubleFunction)(double), double (*operation)(ExecState*, EncodedJSValue))
 4410 {
 4411     if (node-&gt;child1().useKind() == DoubleRepUse) {
 4412         SpeculateDoubleOperand op1(this, node-&gt;child1());
 4413         FPRReg op1FPR = op1.fpr();
 4414 
 4415         flushRegisters();
 4416 
 4417         FPRResult result(this);
 4418         callOperation(doubleFunction, result.fpr(), op1FPR);
 4419 
 4420         doubleResult(result.fpr(), node);
 4421         return;
 4422     }
 4423 
 4424     JSValueOperand op1(this, node-&gt;child1());
 4425     JSValueRegs op1Regs = op1.jsValueRegs();
 4426     flushRegisters();
 4427     FPRResult result(this);
 4428     callOperation(operation, result.fpr(), op1Regs);
 4429     m_jit.exceptionCheck();
 4430     doubleResult(result.fpr(), node);
 4431 }
 4432 
 4433 void SpeculativeJIT::compileArithSub(Node* node)
 4434 {
 4435     switch (node-&gt;binaryUseKind()) {
 4436     case Int32Use: {
 4437         ASSERT(!shouldCheckNegativeZero(node-&gt;arithMode()));
 4438 
 4439         if (node-&gt;child2()-&gt;isInt32Constant()) {
 4440             SpeculateInt32Operand op1(this, node-&gt;child1());
 4441             int32_t imm2 = node-&gt;child2()-&gt;asInt32();
 4442             GPRTemporary result(this);
 4443 
 4444             if (!shouldCheckOverflow(node-&gt;arithMode())) {
 4445                 m_jit.move(op1.gpr(), result.gpr());
 4446                 m_jit.sub32(Imm32(imm2), result.gpr());
 4447             } else {
 4448                 GPRTemporary scratch(this);
 4449                 speculationCheck(Overflow, JSValueRegs(), 0, m_jit.branchSub32(MacroAssembler::Overflow, op1.gpr(), Imm32(imm2), result.gpr(), scratch.gpr()));
 4450             }
 4451 
 4452             int32Result(result.gpr(), node);
 4453             return;
 4454         }
 4455 
 4456         if (node-&gt;child1()-&gt;isInt32Constant()) {
 4457             int32_t imm1 = node-&gt;child1()-&gt;asInt32();
 4458             SpeculateInt32Operand op2(this, node-&gt;child2());
 4459             GPRTemporary result(this);
 4460 
 4461             m_jit.move(Imm32(imm1), result.gpr());
 4462             if (!shouldCheckOverflow(node-&gt;arithMode()))
 4463                 m_jit.sub32(op2.gpr(), result.gpr());
 4464             else
 4465                 speculationCheck(Overflow, JSValueRegs(), 0, m_jit.branchSub32(MacroAssembler::Overflow, op2.gpr(), result.gpr()));
 4466 
 4467             int32Result(result.gpr(), node);
 4468             return;
 4469         }
 4470 
 4471         SpeculateInt32Operand op1(this, node-&gt;child1());
 4472         SpeculateInt32Operand op2(this, node-&gt;child2());
 4473         GPRTemporary result(this);
 4474 
 4475         if (!shouldCheckOverflow(node-&gt;arithMode())) {
 4476             m_jit.move(op1.gpr(), result.gpr());
 4477             m_jit.sub32(op2.gpr(), result.gpr());
 4478         } else
 4479             speculationCheck(Overflow, JSValueRegs(), 0, m_jit.branchSub32(MacroAssembler::Overflow, op1.gpr(), op2.gpr(), result.gpr()));
 4480 
 4481         int32Result(result.gpr(), node);
 4482         return;
 4483     }
 4484 
 4485 #if USE(JSVALUE64)
 4486     case Int52RepUse: {
 4487         ASSERT(shouldCheckOverflow(node-&gt;arithMode()));
 4488         ASSERT(!shouldCheckNegativeZero(node-&gt;arithMode()));
 4489 
 4490         // Will we need an overflow check? If we can prove that neither input can be
 4491         // Int52 then the overflow check will not be necessary.
 4492         if (!m_state.forNode(node-&gt;child1()).couldBeType(SpecInt52Only)
 4493             &amp;&amp; !m_state.forNode(node-&gt;child2()).couldBeType(SpecInt52Only)) {
 4494             SpeculateWhicheverInt52Operand op1(this, node-&gt;child1());
 4495             SpeculateWhicheverInt52Operand op2(this, node-&gt;child2(), op1);
 4496             GPRTemporary result(this, Reuse, op1);
 4497             m_jit.move(op1.gpr(), result.gpr());
 4498             m_jit.sub64(op2.gpr(), result.gpr());
 4499             int52Result(result.gpr(), node, op1.format());
 4500             return;
 4501         }
 4502 
 4503         SpeculateInt52Operand op1(this, node-&gt;child1());
 4504         SpeculateInt52Operand op2(this, node-&gt;child2());
 4505         GPRTemporary result(this);
 4506         m_jit.move(op1.gpr(), result.gpr());
 4507         speculationCheck(
 4508             Int52Overflow, JSValueRegs(), 0,
 4509             m_jit.branchSub64(MacroAssembler::Overflow, op2.gpr(), result.gpr()));
 4510         int52Result(result.gpr(), node);
 4511         return;
 4512     }
 4513 #endif // USE(JSVALUE64)
 4514 
 4515     case DoubleRepUse: {
 4516         SpeculateDoubleOperand op1(this, node-&gt;child1());
 4517         SpeculateDoubleOperand op2(this, node-&gt;child2());
 4518         FPRTemporary result(this, op1);
 4519 
 4520         FPRReg reg1 = op1.fpr();
 4521         FPRReg reg2 = op2.fpr();
 4522         m_jit.subDouble(reg1, reg2, result.fpr());
 4523 
 4524         doubleResult(result.fpr(), node);
 4525         return;
 4526     }
 4527 
 4528     default:
 4529         RELEASE_ASSERT_NOT_REACHED();
 4530         return;
 4531     }
 4532 }
 4533 
 4534 void SpeculativeJIT::compileValueNegate(Node* node)
 4535 {
 4536     CodeBlock* baselineCodeBlock = m_jit.graph().baselineCodeBlockFor(node-&gt;origin.semantic);
 4537     ArithProfile* arithProfile = baselineCodeBlock-&gt;arithProfileForBytecodeOffset(node-&gt;origin.semantic.bytecodeIndex);
 4538     const Instruction* instruction = baselineCodeBlock-&gt;instructions().at(node-&gt;origin.semantic.bytecodeIndex).ptr();
 4539     JITNegIC* negIC = m_jit.codeBlock()-&gt;addJITNegIC(arithProfile, instruction);
 4540     auto repatchingFunction = operationArithNegateOptimize;
 4541     auto nonRepatchingFunction = operationArithNegate;
 4542     bool needsScratchGPRReg = true;
 4543     compileMathIC(node, negIC, needsScratchGPRReg, repatchingFunction, nonRepatchingFunction);
 4544 }
 4545 
 4546 void SpeculativeJIT::compileArithNegate(Node* node)
 4547 {
 4548     switch (node-&gt;child1().useKind()) {
 4549     case Int32Use: {
 4550         SpeculateInt32Operand op1(this, node-&gt;child1());
 4551         GPRTemporary result(this);
 4552 
 4553         m_jit.move(op1.gpr(), result.gpr());
 4554 
 4555         // Note: there is no notion of being not used as a number, but someone
 4556         // caring about negative zero.
 4557 
 4558         if (!shouldCheckOverflow(node-&gt;arithMode()))
 4559             m_jit.neg32(result.gpr());
 4560         else if (!shouldCheckNegativeZero(node-&gt;arithMode()))
 4561             speculationCheck(Overflow, JSValueRegs(), 0, m_jit.branchNeg32(MacroAssembler::Overflow, result.gpr()));
 4562         else {
 4563             speculationCheck(Overflow, JSValueRegs(), 0, m_jit.branchTest32(MacroAssembler::Zero, result.gpr(), TrustedImm32(0x7fffffff)));
 4564             m_jit.neg32(result.gpr());
 4565         }
 4566 
 4567         int32Result(result.gpr(), node);
 4568         return;
 4569     }
 4570 
 4571 #if USE(JSVALUE64)
 4572     case Int52RepUse: {
 4573         ASSERT(shouldCheckOverflow(node-&gt;arithMode()));
 4574 
 4575         if (!m_state.forNode(node-&gt;child1()).couldBeType(SpecInt52Only)) {
 4576             SpeculateWhicheverInt52Operand op1(this, node-&gt;child1());
 4577             GPRTemporary result(this);
 4578             GPRReg op1GPR = op1.gpr();
 4579             GPRReg resultGPR = result.gpr();
 4580             m_jit.move(op1GPR, resultGPR);
 4581             m_jit.neg64(resultGPR);
 4582             if (shouldCheckNegativeZero(node-&gt;arithMode())) {
 4583                 speculationCheck(
 4584                     NegativeZero, JSValueRegs(), 0,
 4585                     m_jit.branchTest64(MacroAssembler::Zero, resultGPR));
 4586             }
 4587             int52Result(resultGPR, node, op1.format());
 4588             return;
 4589         }
 4590 
 4591         SpeculateInt52Operand op1(this, node-&gt;child1());
 4592         GPRTemporary result(this);
 4593         GPRReg op1GPR = op1.gpr();
 4594         GPRReg resultGPR = result.gpr();
 4595         m_jit.move(op1GPR, resultGPR);
 4596         speculationCheck(
 4597             Int52Overflow, JSValueRegs(), 0,
 4598             m_jit.branchNeg64(MacroAssembler::Overflow, resultGPR));
 4599         if (shouldCheckNegativeZero(node-&gt;arithMode())) {
 4600             speculationCheck(
 4601                 NegativeZero, JSValueRegs(), 0,
 4602                 m_jit.branchTest64(MacroAssembler::Zero, resultGPR));
 4603         }
 4604         int52Result(resultGPR, node);
 4605         return;
 4606     }
 4607 #endif // USE(JSVALUE64)
 4608 
 4609     case DoubleRepUse: {
 4610         SpeculateDoubleOperand op1(this, node-&gt;child1());
 4611         FPRTemporary result(this);
 4612 
 4613         m_jit.negateDouble(op1.fpr(), result.fpr());
 4614 
 4615         doubleResult(result.fpr(), node);
 4616         return;
 4617     }
 4618 
 4619     default: {
 4620         RELEASE_ASSERT_NOT_REACHED();
 4621     }
 4622     }
 4623 }
 4624 
 4625 template &lt;typename Generator, typename RepatchingFunction, typename NonRepatchingFunction&gt;
 4626 void SpeculativeJIT::compileMathIC(Node* node, JITUnaryMathIC&lt;Generator&gt;* mathIC, bool needsScratchGPRReg, RepatchingFunction repatchingFunction, NonRepatchingFunction nonRepatchingFunction)
 4627 {
 4628     GPRReg scratchGPR = InvalidGPRReg;
 4629     Optional&lt;GPRTemporary&gt; gprScratch;
 4630     if (needsScratchGPRReg) {
 4631         gprScratch.emplace(this);
 4632         scratchGPR = gprScratch-&gt;gpr();
 4633     }
 4634     JSValueOperand childOperand(this, node-&gt;child1());
 4635     JSValueRegs childRegs = childOperand.jsValueRegs();
 4636 #if USE(JSVALUE64)
 4637     GPRTemporary result(this, Reuse, childOperand);
 4638     JSValueRegs resultRegs(result.gpr());
 4639 #else
 4640     GPRTemporary resultTag(this);
 4641     GPRTemporary resultPayload(this);
 4642     JSValueRegs resultRegs(resultPayload.gpr(), resultTag.gpr());
 4643 #endif
 4644 
 4645 #if ENABLE(MATH_IC_STATS)
 4646     auto inlineStart = m_jit.label();
 4647 #endif
 4648 
 4649     Box&lt;MathICGenerationState&gt; icGenerationState = Box&lt;MathICGenerationState&gt;::create();
 4650     mathIC-&gt;m_generator = Generator(resultRegs, childRegs, scratchGPR);
 4651 
 4652     bool shouldEmitProfiling = false;
 4653     bool generatedInline = mathIC-&gt;generateInline(m_jit, *icGenerationState, shouldEmitProfiling);
 4654     if (generatedInline) {
 4655         ASSERT(!icGenerationState-&gt;slowPathJumps.empty());
 4656 
 4657         Vector&lt;SilentRegisterSavePlan&gt; savePlans;
 4658         silentSpillAllRegistersImpl(false, savePlans, resultRegs);
 4659 
 4660         auto done = m_jit.label();
 4661 
 4662         addSlowPathGeneratorLambda([=, savePlans = WTFMove(savePlans)] () {
 4663             icGenerationState-&gt;slowPathJumps.link(&amp;m_jit);
 4664             icGenerationState-&gt;slowPathStart = m_jit.label();
 4665 #if ENABLE(MATH_IC_STATS)
 4666             auto slowPathStart = m_jit.label();
 4667 #endif
 4668 
 4669             silentSpill(savePlans);
 4670 
 4671             if (icGenerationState-&gt;shouldSlowPathRepatch)
 4672                 icGenerationState-&gt;slowPathCall = callOperation(bitwise_cast&lt;J_JITOperation_EJMic&gt;(repatchingFunction), resultRegs, childRegs, TrustedImmPtr(mathIC));
 4673             else
 4674                 icGenerationState-&gt;slowPathCall = callOperation(nonRepatchingFunction, resultRegs, childRegs);
 4675 
 4676             silentFill(savePlans);
 4677             m_jit.exceptionCheck();
 4678             m_jit.jump().linkTo(done, &amp;m_jit);
 4679 
 4680             m_jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
 4681                 mathIC-&gt;finalizeInlineCode(*icGenerationState, linkBuffer);
 4682             });
 4683 
 4684 #if ENABLE(MATH_IC_STATS)
 4685             auto slowPathEnd = m_jit.label();
 4686             m_jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
 4687                 size_t size = static_cast&lt;char*&gt;(linkBuffer.locationOf(slowPathEnd).executableAddress()) - static_cast&lt;char*&gt;(linkBuffer.locationOf(slowPathStart).executableAddress());
 4688                 mathIC-&gt;m_generatedCodeSize += size;
 4689             });
 4690 #endif
 4691 
 4692         });
 4693     } else {
 4694         flushRegisters();
 4695         callOperation(nonRepatchingFunction, resultRegs, childRegs);
 4696         m_jit.exceptionCheck();
 4697     }
 4698 
 4699 #if ENABLE(MATH_IC_STATS)
 4700     auto inlineEnd = m_jit.label();
 4701     m_jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
 4702         size_t size = static_cast&lt;char*&gt;(linkBuffer.locationOf(inlineEnd).executableAddress()) - static_cast&lt;char*&gt;(linkBuffer.locationOf(inlineStart).executableAddress());
 4703         mathIC-&gt;m_generatedCodeSize += size;
 4704     });
 4705 #endif
 4706 
 4707     jsValueResult(resultRegs, node);
 4708     return;
 4709 }
 4710 
 4711 void SpeculativeJIT::compileValueMul(Node* node)
 4712 {
 4713     Edge&amp; leftChild = node-&gt;child1();
 4714     Edge&amp; rightChild = node-&gt;child2();
 4715 
 4716     if (leftChild.useKind() == BigIntUse &amp;&amp; rightChild.useKind() == BigIntUse) {
 4717         SpeculateCellOperand left(this, leftChild);
 4718         SpeculateCellOperand right(this, rightChild);
 4719         GPRReg leftGPR = left.gpr();
 4720         GPRReg rightGPR = right.gpr();
 4721 
 4722         speculateBigInt(leftChild, leftGPR);
 4723         speculateBigInt(rightChild, rightGPR);
 4724 
 4725         flushRegisters();
 4726         GPRFlushedCallResult result(this);
 4727         GPRReg resultGPR = result.gpr();
 4728 
 4729         callOperation(operationMulBigInt, resultGPR, leftGPR, rightGPR);
 4730 
 4731         m_jit.exceptionCheck();
 4732         cellResult(resultGPR, node);
 4733         return;
 4734     }
 4735 
 4736     if (isKnownNotNumber(leftChild.node()) || isKnownNotNumber(rightChild.node())) {
 4737         JSValueOperand left(this, leftChild);
 4738         JSValueOperand right(this, rightChild);
 4739         JSValueRegs leftRegs = left.jsValueRegs();
 4740         JSValueRegs rightRegs = right.jsValueRegs();
 4741 
 4742         flushRegisters();
 4743         JSValueRegsFlushedCallResult result(this);
 4744         JSValueRegs resultRegs = result.regs();
 4745         callOperation(operationValueMul, resultRegs, leftRegs, rightRegs);
 4746         m_jit.exceptionCheck();
 4747 
 4748         jsValueResult(resultRegs, node);
 4749         return;
 4750     }
 4751 
 4752     bool needsScratchGPRReg = true;
 4753 #if USE(JSVALUE64)
 4754     bool needsScratchFPRReg = false;
 4755 #else
 4756     bool needsScratchFPRReg = true;
 4757 #endif
 4758 
 4759     CodeBlock* baselineCodeBlock = m_jit.graph().baselineCodeBlockFor(node-&gt;origin.semantic);
 4760     ArithProfile* arithProfile = baselineCodeBlock-&gt;arithProfileForBytecodeOffset(node-&gt;origin.semantic.bytecodeIndex);
 4761     const Instruction* instruction = baselineCodeBlock-&gt;instructions().at(node-&gt;origin.semantic.bytecodeIndex).ptr();
 4762     JITMulIC* mulIC = m_jit.codeBlock()-&gt;addJITMulIC(arithProfile, instruction);
 4763     auto repatchingFunction = operationValueMulOptimize;
 4764     auto nonRepatchingFunction = operationValueMul;
 4765 
 4766     compileMathIC(node, mulIC, needsScratchGPRReg, needsScratchFPRReg, repatchingFunction, nonRepatchingFunction);
 4767 }
 4768 
 4769 void SpeculativeJIT::compileArithMul(Node* node)
 4770 {
 4771     switch (node-&gt;binaryUseKind()) {
 4772     case Int32Use: {
 4773         if (node-&gt;child2()-&gt;isInt32Constant()) {
 4774             SpeculateInt32Operand op1(this, node-&gt;child1());
 4775             GPRTemporary result(this);
 4776 
 4777             int32_t imm = node-&gt;child2()-&gt;asInt32();
 4778             GPRReg op1GPR = op1.gpr();
 4779             GPRReg resultGPR = result.gpr();
 4780 
 4781             if (!shouldCheckOverflow(node-&gt;arithMode()))
 4782                 m_jit.mul32(Imm32(imm), op1GPR, resultGPR);
 4783             else {
 4784                 speculationCheck(Overflow, JSValueRegs(), 0,
 4785                     m_jit.branchMul32(MacroAssembler::Overflow, op1GPR, Imm32(imm), resultGPR));
 4786             }
 4787 
 4788             // The only way to create negative zero with a constant is:
 4789             // -negative-op1 * 0.
 4790             // -zero-op1 * negative constant.
 4791             if (shouldCheckNegativeZero(node-&gt;arithMode())) {
 4792                 if (!imm)
 4793                     speculationCheck(NegativeZero, JSValueRegs(), 0, m_jit.branchTest32(MacroAssembler::Signed, op1GPR));
 4794                 else if (imm &lt; 0) {
 4795                     if (shouldCheckOverflow(node-&gt;arithMode()))
 4796                         speculationCheck(NegativeZero, JSValueRegs(), 0, m_jit.branchTest32(MacroAssembler::Zero, resultGPR));
 4797                     else
 4798                         speculationCheck(NegativeZero, JSValueRegs(), 0, m_jit.branchTest32(MacroAssembler::Zero, op1GPR));
 4799                 }
 4800             }
 4801 
 4802             int32Result(resultGPR, node);
 4803             return;
 4804         }
 4805         SpeculateInt32Operand op1(this, node-&gt;child1());
 4806         SpeculateInt32Operand op2(this, node-&gt;child2());
 4807         GPRTemporary result(this);
 4808 
 4809         GPRReg reg1 = op1.gpr();
 4810         GPRReg reg2 = op2.gpr();
 4811 
 4812         // We can perform truncated multiplications if we get to this point, because if the
 4813         // fixup phase could not prove that it would be safe, it would have turned us into
 4814         // a double multiplication.
 4815         if (!shouldCheckOverflow(node-&gt;arithMode()))
 4816             m_jit.mul32(reg1, reg2, result.gpr());
 4817         else {
 4818             speculationCheck(
 4819                 Overflow, JSValueRegs(), 0,
 4820                 m_jit.branchMul32(MacroAssembler::Overflow, reg1, reg2, result.gpr()));
 4821         }
 4822 
 4823         // Check for negative zero, if the users of this node care about such things.
 4824         if (shouldCheckNegativeZero(node-&gt;arithMode())) {
 4825             MacroAssembler::Jump resultNonZero = m_jit.branchTest32(MacroAssembler::NonZero, result.gpr());
 4826             speculationCheck(NegativeZero, JSValueRegs(), 0, m_jit.branchTest32(MacroAssembler::Signed, reg1));
 4827             speculationCheck(NegativeZero, JSValueRegs(), 0, m_jit.branchTest32(MacroAssembler::Signed, reg2));
 4828             resultNonZero.link(&amp;m_jit);
 4829         }
 4830 
 4831         int32Result(result.gpr(), node);
 4832         return;
 4833     }
 4834 
 4835 #if USE(JSVALUE64)
 4836     case Int52RepUse: {
 4837         ASSERT(shouldCheckOverflow(node-&gt;arithMode()));
 4838 
 4839         // This is super clever. We want to do an int52 multiplication and check the
 4840         // int52 overflow bit. There is no direct hardware support for this, but we do
 4841         // have the ability to do an int64 multiplication and check the int64 overflow
 4842         // bit. We leverage that. Consider that a, b are int52 numbers inside int64
 4843         // registers, with the high 12 bits being sign-extended. We can do:
 4844         //
 4845         //     (a * (b &lt;&lt; 12))
 4846         //
 4847         // This will give us a left-shifted int52 (value is in high 52 bits, low 16
 4848         // bits are zero) plus the int52 overflow bit. I.e. whether this 64-bit
 4849         // multiplication overflows is identical to whether the &#39;a * b&#39; 52-bit
 4850         // multiplication overflows.
 4851         //
 4852         // In our nomenclature, this is:
 4853         //
 4854         //     strictInt52(a) * int52(b) =&gt; int52
 4855         //
 4856         // That is &quot;strictInt52&quot; means unshifted and &quot;int52&quot; means left-shifted by 16
 4857         // bits.
 4858         //
 4859         // We don&#39;t care which of op1 or op2 serves as the left-shifted operand, so
 4860         // we just do whatever is more convenient for op1 and have op2 do the
 4861         // opposite. This ensures that we do at most one shift.
 4862 
 4863         SpeculateWhicheverInt52Operand op1(this, node-&gt;child1());
 4864         SpeculateWhicheverInt52Operand op2(this, node-&gt;child2(), OppositeShift, op1);
 4865         GPRTemporary result(this);
 4866 
 4867         GPRReg op1GPR = op1.gpr();
 4868         GPRReg op2GPR = op2.gpr();
 4869         GPRReg resultGPR = result.gpr();
 4870 
 4871         m_jit.move(op1GPR, resultGPR);
 4872         speculationCheck(
 4873             Int52Overflow, JSValueRegs(), 0,
 4874             m_jit.branchMul64(MacroAssembler::Overflow, op2GPR, resultGPR));
 4875 
 4876         if (shouldCheckNegativeZero(node-&gt;arithMode())) {
 4877             MacroAssembler::Jump resultNonZero = m_jit.branchTest64(
 4878                 MacroAssembler::NonZero, resultGPR);
 4879             speculationCheck(
 4880                 NegativeZero, JSValueRegs(), 0,
 4881                 m_jit.branch64(MacroAssembler::LessThan, op1GPR, TrustedImm32(0)));
 4882             speculationCheck(
 4883                 NegativeZero, JSValueRegs(), 0,
 4884                 m_jit.branch64(MacroAssembler::LessThan, op2GPR, TrustedImm32(0)));
 4885             resultNonZero.link(&amp;m_jit);
 4886         }
 4887 
 4888         int52Result(resultGPR, node);
 4889         return;
 4890     }
 4891 #endif // USE(JSVALUE64)
 4892 
 4893     case DoubleRepUse: {
 4894         SpeculateDoubleOperand op1(this, node-&gt;child1());
 4895         SpeculateDoubleOperand op2(this, node-&gt;child2());
 4896         FPRTemporary result(this, op1, op2);
 4897 
 4898         FPRReg reg1 = op1.fpr();
 4899         FPRReg reg2 = op2.fpr();
 4900 
 4901         m_jit.mulDouble(reg1, reg2, result.fpr());
 4902 
 4903         doubleResult(result.fpr(), node);
 4904         return;
 4905     }
 4906 
 4907     default:
 4908         RELEASE_ASSERT_NOT_REACHED();
 4909         return;
 4910     }
 4911 }
 4912 
 4913 void SpeculativeJIT::compileValueDiv(Node* node)
 4914 {
 4915     Edge&amp; leftChild = node-&gt;child1();
 4916     Edge&amp; rightChild = node-&gt;child2();
 4917 
 4918     if (leftChild.useKind() == BigIntUse &amp;&amp; rightChild.useKind() == BigIntUse) {
 4919         SpeculateCellOperand left(this, leftChild);
 4920         SpeculateCellOperand right(this, rightChild);
 4921         GPRReg leftGPR = left.gpr();
 4922         GPRReg rightGPR = right.gpr();
 4923 
 4924         speculateBigInt(leftChild, leftGPR);
 4925         speculateBigInt(rightChild, rightGPR);
 4926 
 4927         flushRegisters();
 4928         GPRFlushedCallResult result(this);
 4929         GPRReg resultGPR = result.gpr();
 4930 
 4931         callOperation(operationDivBigInt, resultGPR, leftGPR, rightGPR);
 4932 
 4933         m_jit.exceptionCheck();
 4934         cellResult(resultGPR, node);
 4935         return;
 4936     }
 4937 
 4938     if (isKnownNotNumber(leftChild.node()) || isKnownNotNumber(rightChild.node())) {
 4939         JSValueOperand left(this, leftChild);
 4940         JSValueOperand right(this, rightChild);
 4941         JSValueRegs leftRegs = left.jsValueRegs();
 4942         JSValueRegs rightRegs = right.jsValueRegs();
 4943 
 4944         flushRegisters();
 4945         JSValueRegsFlushedCallResult result(this);
 4946         JSValueRegs resultRegs = result.regs();
 4947         callOperation(operationValueDiv, resultRegs, leftRegs, rightRegs);
 4948         m_jit.exceptionCheck();
 4949 
 4950         jsValueResult(resultRegs, node);
 4951         return;
 4952     }
 4953 
 4954     Optional&lt;JSValueOperand&gt; left;
 4955     Optional&lt;JSValueOperand&gt; right;
 4956 
 4957     JSValueRegs leftRegs;
 4958     JSValueRegs rightRegs;
 4959 
 4960     FPRTemporary leftNumber(this);
 4961     FPRTemporary rightNumber(this);
 4962     FPRReg leftFPR = leftNumber.fpr();
 4963     FPRReg rightFPR = rightNumber.fpr();
 4964     FPRTemporary fprScratch(this);
 4965     FPRReg scratchFPR = fprScratch.fpr();
 4966 
 4967 #if USE(JSVALUE64)
 4968     GPRTemporary result(this);
 4969     JSValueRegs resultRegs = JSValueRegs(result.gpr());
 4970     GPRTemporary scratch(this);
 4971     GPRReg scratchGPR = scratch.gpr();
 4972 #else
 4973     GPRTemporary resultTag(this);
 4974     GPRTemporary resultPayload(this);
 4975     JSValueRegs resultRegs = JSValueRegs(resultPayload.gpr(), resultTag.gpr());
 4976     GPRReg scratchGPR = resultTag.gpr();
 4977 #endif
 4978 
 4979     SnippetOperand leftOperand(m_state.forNode(leftChild).resultType());
 4980     SnippetOperand rightOperand(m_state.forNode(rightChild).resultType());
 4981 
 4982     if (leftChild-&gt;isInt32Constant())
 4983         leftOperand.setConstInt32(leftChild-&gt;asInt32());
 4984 #if USE(JSVALUE64)
 4985     else if (leftChild-&gt;isDoubleConstant())
 4986         leftOperand.setConstDouble(leftChild-&gt;asNumber());
 4987 #endif
 4988 
 4989     if (leftOperand.isConst()) {
 4990         // The snippet generator only supports 1 argument as a constant.
 4991         // Ignore the rightChild&#39;s const-ness.
 4992     } else if (rightChild-&gt;isInt32Constant())
 4993         rightOperand.setConstInt32(rightChild-&gt;asInt32());
 4994 #if USE(JSVALUE64)
 4995     else if (rightChild-&gt;isDoubleConstant())
 4996         rightOperand.setConstDouble(rightChild-&gt;asNumber());
 4997 #endif
 4998 
 4999     RELEASE_ASSERT(!leftOperand.isConst() || !rightOperand.isConst());
 5000 
 5001     if (!leftOperand.isConst()) {
 5002         left.emplace(this, leftChild);
 5003         leftRegs = left-&gt;jsValueRegs();
 5004     }
 5005     if (!rightOperand.isConst()) {
 5006         right.emplace(this, rightChild);
 5007         rightRegs = right-&gt;jsValueRegs();
 5008     }
 5009 
 5010     JITDivGenerator gen(leftOperand, rightOperand, resultRegs, leftRegs, rightRegs,
 5011         leftFPR, rightFPR, scratchGPR, scratchFPR);
 5012     gen.generateFastPath(m_jit);
 5013 
 5014     ASSERT(gen.didEmitFastPath());
 5015     gen.endJumpList().append(m_jit.jump());
 5016 
 5017     gen.slowPathJumpList().link(&amp;m_jit);
 5018     silentSpillAllRegisters(resultRegs);
 5019 
 5020     if (leftOperand.isConst()) {
 5021         leftRegs = resultRegs;
 5022         m_jit.moveValue(leftChild-&gt;asJSValue(), leftRegs);
 5023     }
 5024     if (rightOperand.isConst()) {
 5025         rightRegs = resultRegs;
 5026         m_jit.moveValue(rightChild-&gt;asJSValue(), rightRegs);
 5027     }
 5028 
 5029     callOperation(operationValueDiv, resultRegs, leftRegs, rightRegs);
 5030 
 5031     silentFillAllRegisters();
 5032     m_jit.exceptionCheck();
 5033 
 5034     gen.endJumpList().link(&amp;m_jit);
 5035     jsValueResult(resultRegs, node);
 5036 }
 5037 
 5038 void SpeculativeJIT::compileArithDiv(Node* node)
 5039 {
 5040     switch (node-&gt;binaryUseKind()) {
 5041     case Int32Use: {
 5042 #if CPU(X86) || CPU(X86_64)
 5043         SpeculateInt32Operand op1(this, node-&gt;child1());
 5044         SpeculateInt32Operand op2(this, node-&gt;child2());
 5045         GPRTemporary eax(this, X86Registers::eax);
 5046         GPRTemporary edx(this, X86Registers::edx);
 5047         GPRReg op1GPR = op1.gpr();
 5048         GPRReg op2GPR = op2.gpr();
 5049 
 5050         GPRReg op2TempGPR;
 5051         GPRReg temp;
 5052         if (op2GPR == X86Registers::eax || op2GPR == X86Registers::edx) {
 5053             op2TempGPR = allocate();
 5054             temp = op2TempGPR;
 5055         } else {
 5056             op2TempGPR = InvalidGPRReg;
 5057             if (op1GPR == X86Registers::eax)
 5058                 temp = X86Registers::edx;
 5059             else
 5060                 temp = X86Registers::eax;
 5061         }
 5062 
 5063         ASSERT(temp != op1GPR);
 5064         ASSERT(temp != op2GPR);
 5065 
 5066         m_jit.add32(JITCompiler::TrustedImm32(1), op2GPR, temp);
 5067 
 5068         JITCompiler::Jump safeDenominator = m_jit.branch32(JITCompiler::Above, temp, JITCompiler::TrustedImm32(1));
 5069 
 5070         JITCompiler::JumpList done;
 5071         if (shouldCheckOverflow(node-&gt;arithMode())) {
 5072             speculationCheck(Overflow, JSValueRegs(), 0, m_jit.branchTest32(JITCompiler::Zero, op2GPR));
 5073             speculationCheck(Overflow, JSValueRegs(), 0, m_jit.branch32(JITCompiler::Equal, op1GPR, TrustedImm32(-2147483647-1)));
 5074         } else {
 5075             // This is the case where we convert the result to an int after we&#39;re done, and we
 5076             // already know that the denominator is either -1 or 0. So, if the denominator is
 5077             // zero, then the result should be zero. If the denominator is not zero (i.e. it&#39;s
 5078             // -1) and the numerator is -2^31 then the result should be -2^31. Otherwise we
 5079             // are happy to fall through to a normal division, since we&#39;re just dividing
 5080             // something by negative 1.
 5081 
 5082             JITCompiler::Jump notZero = m_jit.branchTest32(JITCompiler::NonZero, op2GPR);
 5083             m_jit.move(TrustedImm32(0), eax.gpr());
 5084             done.append(m_jit.jump());
 5085 
 5086             notZero.link(&amp;m_jit);
 5087             JITCompiler::Jump notNeg2ToThe31 =
 5088                 m_jit.branch32(JITCompiler::NotEqual, op1GPR, TrustedImm32(-2147483647-1));
 5089             m_jit.zeroExtend32ToPtr(op1GPR, eax.gpr());
 5090             done.append(m_jit.jump());
 5091 
 5092             notNeg2ToThe31.link(&amp;m_jit);
 5093         }
 5094 
 5095         safeDenominator.link(&amp;m_jit);
 5096 
 5097         // If the user cares about negative zero, then speculate that we&#39;re not about
 5098         // to produce negative zero.
 5099         if (shouldCheckNegativeZero(node-&gt;arithMode())) {
 5100             MacroAssembler::Jump numeratorNonZero = m_jit.branchTest32(MacroAssembler::NonZero, op1GPR);
 5101             speculationCheck(NegativeZero, JSValueRegs(), 0, m_jit.branch32(MacroAssembler::LessThan, op2GPR, TrustedImm32(0)));
 5102             numeratorNonZero.link(&amp;m_jit);
 5103         }
 5104 
 5105         if (op2TempGPR != InvalidGPRReg) {
 5106             m_jit.move(op2GPR, op2TempGPR);
 5107             op2GPR = op2TempGPR;
 5108         }
 5109 
 5110         m_jit.move(op1GPR, eax.gpr());
 5111         m_jit.x86ConvertToDoubleWord32();
 5112         m_jit.x86Div32(op2GPR);
 5113 
 5114         if (op2TempGPR != InvalidGPRReg)
 5115             unlock(op2TempGPR);
 5116 
 5117         // Check that there was no remainder. If there had been, then we&#39;d be obligated to
 5118         // produce a double result instead.
 5119         if (shouldCheckOverflow(node-&gt;arithMode()))
 5120             speculationCheck(Overflow, JSValueRegs(), 0, m_jit.branchTest32(JITCompiler::NonZero, edx.gpr()));
 5121 
 5122         done.link(&amp;m_jit);
 5123         int32Result(eax.gpr(), node);
 5124 #elif HAVE(ARM_IDIV_INSTRUCTIONS) || CPU(ARM64)
 5125         SpeculateInt32Operand op1(this, node-&gt;child1());
 5126         SpeculateInt32Operand op2(this, node-&gt;child2());
 5127         GPRReg op1GPR = op1.gpr();
 5128         GPRReg op2GPR = op2.gpr();
 5129         GPRTemporary quotient(this);
 5130         GPRTemporary multiplyAnswer(this);
 5131 
 5132         // If the user cares about negative zero, then speculate that we&#39;re not about
 5133         // to produce negative zero.
 5134         if (shouldCheckNegativeZero(node-&gt;arithMode())) {
 5135             MacroAssembler::Jump numeratorNonZero = m_jit.branchTest32(MacroAssembler::NonZero, op1GPR);
 5136             speculationCheck(NegativeZero, JSValueRegs(), 0, m_jit.branch32(MacroAssembler::LessThan, op2GPR, TrustedImm32(0)));
 5137             numeratorNonZero.link(&amp;m_jit);
 5138         }
 5139 
 5140         if (shouldCheckOverflow(node-&gt;arithMode()))
 5141             speculationCheck(Overflow, JSValueRegs(), nullptr, m_jit.branchTest32(MacroAssembler::Zero, op2GPR));
 5142 
 5143         m_jit.assembler().sdiv&lt;32&gt;(quotient.gpr(), op1GPR, op2GPR);
 5144 
 5145         // Check that there was no remainder. If there had been, then we&#39;d be obligated to
 5146         // produce a double result instead.
 5147         if (shouldCheckOverflow(node-&gt;arithMode())) {
 5148             speculationCheck(Overflow, JSValueRegs(), 0, m_jit.branchMul32(JITCompiler::Overflow, quotient.gpr(), op2GPR, multiplyAnswer.gpr()));
 5149             speculationCheck(Overflow, JSValueRegs(), 0, m_jit.branch32(JITCompiler::NotEqual, multiplyAnswer.gpr(), op1GPR));
 5150         }
 5151 
 5152         int32Result(quotient.gpr(), node);
 5153 #else
 5154         RELEASE_ASSERT_NOT_REACHED();
 5155 #endif
 5156         break;
 5157     }
 5158 
 5159     case DoubleRepUse: {
 5160         SpeculateDoubleOperand op1(this, node-&gt;child1());
 5161         SpeculateDoubleOperand op2(this, node-&gt;child2());
 5162         FPRTemporary result(this, op1);
 5163 
 5164         FPRReg reg1 = op1.fpr();
 5165         FPRReg reg2 = op2.fpr();
 5166         m_jit.divDouble(reg1, reg2, result.fpr());
 5167 
 5168         doubleResult(result.fpr(), node);
 5169         break;
 5170     }
 5171 
 5172     default:
 5173         RELEASE_ASSERT_NOT_REACHED();
 5174         break;
 5175     }
 5176 }
 5177 
 5178 void SpeculativeJIT::compileArithFRound(Node* node)
 5179 {
 5180     if (node-&gt;child1().useKind() == DoubleRepUse) {
 5181         SpeculateDoubleOperand op1(this, node-&gt;child1());
 5182         FPRTemporary result(this, op1);
 5183         m_jit.convertDoubleToFloat(op1.fpr(), result.fpr());
 5184         m_jit.convertFloatToDouble(result.fpr(), result.fpr());
 5185         doubleResult(result.fpr(), node);
 5186         return;
 5187     }
 5188 
 5189     JSValueOperand op1(this, node-&gt;child1());
 5190     JSValueRegs op1Regs = op1.jsValueRegs();
 5191     flushRegisters();
 5192     FPRResult result(this);
 5193     callOperation(operationArithFRound, result.fpr(), op1Regs);
 5194     m_jit.exceptionCheck();
 5195     doubleResult(result.fpr(), node);
 5196 }
 5197 
 5198 void SpeculativeJIT::compileArithMod(Node* node)
 5199 {
 5200     switch (node-&gt;binaryUseKind()) {
 5201     case Int32Use: {
 5202         // In the fast path, the dividend value could be the final result
 5203         // (in case of |dividend| &lt; |divisor|), so we speculate it as strict int32.
 5204         SpeculateStrictInt32Operand op1(this, node-&gt;child1());
 5205 
 5206         if (node-&gt;child2()-&gt;isInt32Constant()) {
 5207             int32_t divisor = node-&gt;child2()-&gt;asInt32();
 5208             if (divisor &gt; 1 &amp;&amp; hasOneBitSet(divisor)) {
 5209                 unsigned logarithm = WTF::fastLog2(static_cast&lt;uint32_t&gt;(divisor));
 5210                 GPRReg dividendGPR = op1.gpr();
 5211                 GPRTemporary result(this);
 5212                 GPRReg resultGPR = result.gpr();
 5213 
 5214                 // This is what LLVM generates. It&#39;s pretty crazy. Here&#39;s my
 5215                 // attempt at understanding it.
 5216 
 5217                 // First, compute either divisor - 1, or 0, depending on whether
 5218                 // the dividend is negative:
 5219                 //
 5220                 // If dividend &lt; 0:  resultGPR = divisor - 1
 5221                 // If dividend &gt;= 0: resultGPR = 0
 5222                 m_jit.move(dividendGPR, resultGPR);
 5223                 m_jit.rshift32(TrustedImm32(31), resultGPR);
 5224                 m_jit.urshift32(TrustedImm32(32 - logarithm), resultGPR);
 5225 
 5226                 // Add in the dividend, so that:
 5227                 //
 5228                 // If dividend &lt; 0:  resultGPR = dividend + divisor - 1
 5229                 // If dividend &gt;= 0: resultGPR = dividend
 5230                 m_jit.add32(dividendGPR, resultGPR);
 5231 
 5232                 // Mask so as to only get the *high* bits. This rounds down
 5233                 // (towards negative infinity) resultGPR to the nearest multiple
 5234                 // of divisor, so that:
 5235                 //
 5236                 // If dividend &lt; 0:  resultGPR = floor((dividend + divisor - 1) / divisor)
 5237                 // If dividend &gt;= 0: resultGPR = floor(dividend / divisor)
 5238                 //
 5239                 // Note that this can be simplified to:
 5240                 //
 5241                 // If dividend &lt; 0:  resultGPR = ceil(dividend / divisor)
 5242                 // If dividend &gt;= 0: resultGPR = floor(dividend / divisor)
 5243                 //
 5244                 // Note that if the dividend is negative, resultGPR will also be negative.
 5245                 // Regardless of the sign of dividend, resultGPR will be rounded towards
 5246                 // zero, because of how things are conditionalized.
 5247                 m_jit.and32(TrustedImm32(-divisor), resultGPR);
 5248 
 5249                 // Subtract resultGPR from dividendGPR, which yields the remainder:
 5250                 //
 5251                 // resultGPR = dividendGPR - resultGPR
 5252                 m_jit.neg32(resultGPR);
 5253                 m_jit.add32(dividendGPR, resultGPR);
 5254 
 5255                 if (shouldCheckNegativeZero(node-&gt;arithMode())) {
 5256                     // Check that we&#39;re not about to create negative zero.
 5257                     JITCompiler::Jump numeratorPositive = m_jit.branch32(JITCompiler::GreaterThanOrEqual, dividendGPR, TrustedImm32(0));
 5258                     speculationCheck(NegativeZero, JSValueRegs(), 0, m_jit.branchTest32(JITCompiler::Zero, resultGPR));
 5259                     numeratorPositive.link(&amp;m_jit);
 5260                 }
 5261 
 5262                 int32Result(resultGPR, node);
 5263                 return;
 5264             }
 5265         }
 5266 
 5267 #if CPU(X86) || CPU(X86_64)
 5268         if (node-&gt;child2()-&gt;isInt32Constant()) {
 5269             int32_t divisor = node-&gt;child2()-&gt;asInt32();
 5270             if (divisor &amp;&amp; divisor != -1) {
 5271                 GPRReg op1Gpr = op1.gpr();
 5272 
 5273                 GPRTemporary eax(this, X86Registers::eax);
 5274                 GPRTemporary edx(this, X86Registers::edx);
 5275                 GPRTemporary scratch(this);
 5276                 GPRReg scratchGPR = scratch.gpr();
 5277 
 5278                 GPRReg op1SaveGPR;
 5279                 if (op1Gpr == X86Registers::eax || op1Gpr == X86Registers::edx) {
 5280                     op1SaveGPR = allocate();
 5281                     ASSERT(op1Gpr != op1SaveGPR);
 5282                     m_jit.move(op1Gpr, op1SaveGPR);
 5283                 } else
 5284                     op1SaveGPR = op1Gpr;
 5285                 ASSERT(op1SaveGPR != X86Registers::eax);
 5286                 ASSERT(op1SaveGPR != X86Registers::edx);
 5287 
 5288                 m_jit.move(op1Gpr, eax.gpr());
 5289                 m_jit.move(TrustedImm32(divisor), scratchGPR);
 5290                 m_jit.x86ConvertToDoubleWord32();
 5291                 m_jit.x86Div32(scratchGPR);
 5292                 if (shouldCheckNegativeZero(node-&gt;arithMode())) {
 5293                     JITCompiler::Jump numeratorPositive = m_jit.branch32(JITCompiler::GreaterThanOrEqual, op1SaveGPR, TrustedImm32(0));
 5294                     speculationCheck(Overflow, JSValueRegs(), 0, m_jit.branchTest32(JITCompiler::Zero, edx.gpr()));
 5295                     numeratorPositive.link(&amp;m_jit);
 5296                 }
 5297 
 5298                 if (op1SaveGPR != op1Gpr)
 5299                     unlock(op1SaveGPR);
 5300 
 5301                 int32Result(edx.gpr(), node);
 5302                 return;
 5303             }
 5304         }
 5305 #endif
 5306 
 5307         SpeculateInt32Operand op2(this, node-&gt;child2());
 5308 #if CPU(X86) || CPU(X86_64)
 5309         GPRTemporary eax(this, X86Registers::eax);
 5310         GPRTemporary edx(this, X86Registers::edx);
 5311         GPRReg op1GPR = op1.gpr();
 5312         GPRReg op2GPR = op2.gpr();
 5313 
 5314         GPRReg op2TempGPR;
 5315         GPRReg temp;
 5316         GPRReg op1SaveGPR;
 5317 
 5318         if (op2GPR == X86Registers::eax || op2GPR == X86Registers::edx) {
 5319             op2TempGPR = allocate();
 5320             temp = op2TempGPR;
 5321         } else {
 5322             op2TempGPR = InvalidGPRReg;
 5323             if (op1GPR == X86Registers::eax)
 5324                 temp = X86Registers::edx;
 5325             else
 5326                 temp = X86Registers::eax;
 5327         }
 5328 
 5329         if (op1GPR == X86Registers::eax || op1GPR == X86Registers::edx) {
 5330             op1SaveGPR = allocate();
 5331             ASSERT(op1GPR != op1SaveGPR);
 5332             m_jit.move(op1GPR, op1SaveGPR);
 5333         } else
 5334             op1SaveGPR = op1GPR;
 5335 
 5336         ASSERT(temp != op1GPR);
 5337         ASSERT(temp != op2GPR);
 5338         ASSERT(op1SaveGPR != X86Registers::eax);
 5339         ASSERT(op1SaveGPR != X86Registers::edx);
 5340 
 5341         m_jit.add32(JITCompiler::TrustedImm32(1), op2GPR, temp);
 5342 
 5343         JITCompiler::Jump safeDenominator = m_jit.branch32(JITCompiler::Above, temp, JITCompiler::TrustedImm32(1));
 5344 
 5345         JITCompiler::JumpList done;
 5346 
 5347         // FIXME: -2^31 / -1 will actually yield negative zero, so we could have a
 5348         // separate case for that. But it probably doesn&#39;t matter so much.
 5349         if (shouldCheckOverflow(node-&gt;arithMode())) {
 5350             speculationCheck(Overflow, JSValueRegs(), 0, m_jit.branchTest32(JITCompiler::Zero, op2GPR));
 5351             speculationCheck(Overflow, JSValueRegs(), 0, m_jit.branch32(JITCompiler::Equal, op1GPR, TrustedImm32(-2147483647-1)));
 5352         } else {
 5353             // This is the case where we convert the result to an int after we&#39;re done, and we
 5354             // already know that the denominator is either -1 or 0. So, if the denominator is
 5355             // zero, then the result should be zero. If the denominator is not zero (i.e. it&#39;s
 5356             // -1) and the numerator is -2^31 then the result should be 0. Otherwise we are
 5357             // happy to fall through to a normal division, since we&#39;re just dividing something
 5358             // by negative 1.
 5359 
 5360             JITCompiler::Jump notZero = m_jit.branchTest32(JITCompiler::NonZero, op2GPR);
 5361             m_jit.move(TrustedImm32(0), edx.gpr());
 5362             done.append(m_jit.jump());
 5363 
 5364             notZero.link(&amp;m_jit);
 5365             JITCompiler::Jump notNeg2ToThe31 =
 5366                 m_jit.branch32(JITCompiler::NotEqual, op1GPR, TrustedImm32(-2147483647-1));
 5367             m_jit.move(TrustedImm32(0), edx.gpr());
 5368             done.append(m_jit.jump());
 5369 
 5370             notNeg2ToThe31.link(&amp;m_jit);
 5371         }
 5372 
 5373         safeDenominator.link(&amp;m_jit);
 5374 
 5375         if (op2TempGPR != InvalidGPRReg) {
 5376             m_jit.move(op2GPR, op2TempGPR);
 5377             op2GPR = op2TempGPR;
 5378         }
 5379 
 5380         m_jit.move(op1GPR, eax.gpr());
 5381         m_jit.x86ConvertToDoubleWord32();
 5382         m_jit.x86Div32(op2GPR);
 5383 
 5384         if (op2TempGPR != InvalidGPRReg)
 5385             unlock(op2TempGPR);
 5386 
 5387         // Check that we&#39;re not about to create negative zero.
 5388         if (shouldCheckNegativeZero(node-&gt;arithMode())) {
 5389             JITCompiler::Jump numeratorPositive = m_jit.branch32(JITCompiler::GreaterThanOrEqual, op1SaveGPR, TrustedImm32(0));
 5390             speculationCheck(Overflow, JSValueRegs(), 0, m_jit.branchTest32(JITCompiler::Zero, edx.gpr()));
 5391             numeratorPositive.link(&amp;m_jit);
 5392         }
 5393 
 5394         if (op1SaveGPR != op1GPR)
 5395             unlock(op1SaveGPR);
 5396 
 5397         done.link(&amp;m_jit);
 5398         int32Result(edx.gpr(), node);
 5399 
 5400 #elif HAVE(ARM_IDIV_INSTRUCTIONS) || CPU(ARM64)
 5401         GPRTemporary temp(this);
 5402         GPRTemporary quotientThenRemainder(this);
 5403         GPRTemporary multiplyAnswer(this);
 5404         GPRReg dividendGPR = op1.gpr();
 5405         GPRReg divisorGPR = op2.gpr();
 5406         GPRReg quotientThenRemainderGPR = quotientThenRemainder.gpr();
 5407         GPRReg multiplyAnswerGPR = multiplyAnswer.gpr();
 5408 
 5409         JITCompiler::JumpList done;
 5410 
 5411         if (shouldCheckOverflow(node-&gt;arithMode()))
 5412             speculationCheck(Overflow, JSValueRegs(), 0, m_jit.branchTest32(JITCompiler::Zero, divisorGPR));
 5413         else {
 5414             JITCompiler::Jump denominatorNotZero = m_jit.branchTest32(JITCompiler::NonZero, divisorGPR);
 5415             // We know that the low 32-bit of divisorGPR is 0, but we don&#39;t know if the high bits are.
 5416             // So, use TrustedImm32(0) on ARM instead because done expects the result to be in DataFormatInt32.
 5417             // Using an immediate 0 doesn&#39;t cost anything extra on ARM.
 5418             m_jit.move(TrustedImm32(0), quotientThenRemainderGPR);
 5419             done.append(m_jit.jump());
 5420             denominatorNotZero.link(&amp;m_jit);
 5421         }
 5422 
 5423         m_jit.assembler().sdiv&lt;32&gt;(quotientThenRemainderGPR, dividendGPR, divisorGPR);
 5424         // FIXME: It seems like there are cases where we don&#39;t need this? What if we have
 5425         // arithMode() == Arith::Unchecked?
 5426         // https://bugs.webkit.org/show_bug.cgi?id=126444
 5427         speculationCheck(Overflow, JSValueRegs(), 0, m_jit.branchMul32(JITCompiler::Overflow, quotientThenRemainderGPR, divisorGPR, multiplyAnswerGPR));
 5428 #if HAVE(ARM_IDIV_INSTRUCTIONS)
 5429         m_jit.assembler().sub(quotientThenRemainderGPR, dividendGPR, multiplyAnswerGPR);
 5430 #else
 5431         m_jit.assembler().sub&lt;32&gt;(quotientThenRemainderGPR, dividendGPR, multiplyAnswerGPR);
 5432 #endif
 5433 
 5434         // If the user cares about negative zero, then speculate that we&#39;re not about
 5435         // to produce negative zero.
 5436         if (shouldCheckNegativeZero(node-&gt;arithMode())) {
 5437             // Check that we&#39;re not about to create negative zero.
 5438             JITCompiler::Jump numeratorPositive = m_jit.branch32(JITCompiler::GreaterThanOrEqual, dividendGPR, TrustedImm32(0));
 5439             speculationCheck(Overflow, JSValueRegs(), 0, m_jit.branchTest32(JITCompiler::Zero, quotientThenRemainderGPR));
 5440             numeratorPositive.link(&amp;m_jit);
 5441         }
 5442 
 5443         done.link(&amp;m_jit);
 5444 
 5445         int32Result(quotientThenRemainderGPR, node);
 5446 #else // not architecture that can do integer division
 5447         RELEASE_ASSERT_NOT_REACHED();
 5448 #endif
 5449         return;
 5450     }
 5451 
 5452     case DoubleRepUse: {
 5453         SpeculateDoubleOperand op1(this, node-&gt;child1());
 5454         SpeculateDoubleOperand op2(this, node-&gt;child2());
 5455 
 5456         FPRReg op1FPR = op1.fpr();
 5457         FPRReg op2FPR = op2.fpr();
 5458 
 5459         flushRegisters();
 5460 
 5461         FPRResult result(this);
 5462 
 5463         using OperationType = D_JITOperation_DD;
 5464         callOperation&lt;OperationType&gt;(jsMod, result.fpr(), op1FPR, op2FPR);
 5465 
 5466         doubleResult(result.fpr(), node);
 5467         return;
 5468     }
 5469 
 5470     default:
 5471         RELEASE_ASSERT_NOT_REACHED();
 5472         return;
 5473     }
 5474 }
 5475 
 5476 void SpeculativeJIT::compileArithRounding(Node* node)
 5477 {
 5478     if (node-&gt;child1().useKind() == DoubleRepUse) {
 5479         SpeculateDoubleOperand value(this, node-&gt;child1());
 5480         FPRReg valueFPR = value.fpr();
 5481 
 5482         auto setResult = [&amp;] (FPRReg resultFPR) {
 5483             if (producesInteger(node-&gt;arithRoundingMode())) {
 5484                 GPRTemporary roundedResultAsInt32(this);
 5485                 FPRTemporary scratch(this);
 5486                 FPRReg scratchFPR = scratch.fpr();
 5487                 GPRReg resultGPR = roundedResultAsInt32.gpr();
 5488                 JITCompiler::JumpList failureCases;
 5489                 m_jit.branchConvertDoubleToInt32(resultFPR, resultGPR, failureCases, scratchFPR, shouldCheckNegativeZero(node-&gt;arithRoundingMode()));
 5490                 speculationCheck(Overflow, JSValueRegs(), node, failureCases);
 5491 
 5492                 int32Result(resultGPR, node);
 5493             } else
 5494                 doubleResult(resultFPR, node);
 5495         };
 5496 
 5497         if (m_jit.supportsFloatingPointRounding()) {
 5498             switch (node-&gt;op()) {
 5499             case ArithRound: {
 5500                 FPRTemporary result(this);
 5501                 FPRReg resultFPR = result.fpr();
 5502                 if (producesInteger(node-&gt;arithRoundingMode()) &amp;&amp; !shouldCheckNegativeZero(node-&gt;arithRoundingMode())) {
 5503                     static const double halfConstant = 0.5;
 5504                     m_jit.loadDouble(TrustedImmPtr(&amp;halfConstant), resultFPR);
 5505                     m_jit.addDouble(valueFPR, resultFPR);
 5506                     m_jit.floorDouble(resultFPR, resultFPR);
 5507                 } else {
 5508                     m_jit.ceilDouble(valueFPR, resultFPR);
 5509                     FPRTemporary realPart(this);
 5510                     FPRReg realPartFPR = realPart.fpr();
 5511                     m_jit.subDouble(resultFPR, valueFPR, realPartFPR);
 5512 
 5513                     FPRTemporary scratch(this);
 5514                     FPRReg scratchFPR = scratch.fpr();
 5515                     static const double halfConstant = 0.5;
 5516                     m_jit.loadDouble(TrustedImmPtr(&amp;halfConstant), scratchFPR);
 5517 
 5518                     JITCompiler::Jump shouldUseCeiled = m_jit.branchDouble(JITCompiler::DoubleLessThanOrEqual, realPartFPR, scratchFPR);
 5519                     static const double oneConstant = -1.0;
 5520                     m_jit.loadDouble(TrustedImmPtr(&amp;oneConstant), scratchFPR);
 5521                     m_jit.addDouble(scratchFPR, resultFPR);
 5522                     shouldUseCeiled.link(&amp;m_jit);
 5523                 }
 5524                 setResult(resultFPR);
 5525                 return;
 5526             }
 5527 
 5528             case ArithFloor: {
 5529                 FPRTemporary rounded(this);
 5530                 FPRReg resultFPR = rounded.fpr();
 5531                 m_jit.floorDouble(valueFPR, resultFPR);
 5532                 setResult(resultFPR);
 5533                 return;
 5534             }
 5535 
 5536             case ArithCeil: {
 5537                 FPRTemporary rounded(this);
 5538                 FPRReg resultFPR = rounded.fpr();
 5539                 m_jit.ceilDouble(valueFPR, resultFPR);
 5540                 setResult(resultFPR);
 5541                 return;
 5542             }
 5543 
 5544             case ArithTrunc: {
 5545                 FPRTemporary rounded(this);
 5546                 FPRReg resultFPR = rounded.fpr();
 5547                 m_jit.roundTowardZeroDouble(valueFPR, resultFPR);
 5548                 setResult(resultFPR);
 5549                 return;
 5550             }
 5551 
 5552             default:
 5553                 RELEASE_ASSERT_NOT_REACHED();
 5554             }
 5555         } else {
 5556             flushRegisters();
 5557             FPRResult roundedResultAsDouble(this);
 5558             FPRReg resultFPR = roundedResultAsDouble.fpr();
 5559             using OperationType = D_JITOperation_D;
 5560             if (node-&gt;op() == ArithRound)
 5561                 callOperation&lt;OperationType&gt;(jsRound, resultFPR, valueFPR);
 5562             else if (node-&gt;op() == ArithFloor)
 5563                 callOperation&lt;OperationType&gt;(floor, resultFPR, valueFPR);
 5564             else if (node-&gt;op() == ArithCeil)
 5565                 callOperation&lt;OperationType&gt;(ceil, resultFPR, valueFPR);
 5566             else {
 5567                 ASSERT(node-&gt;op() == ArithTrunc);
 5568                 callOperation&lt;OperationType&gt;(trunc, resultFPR, valueFPR);
 5569             }
 5570             setResult(resultFPR);
 5571         }
 5572         return;
 5573     }
 5574 
 5575     DFG_ASSERT(m_jit.graph(), node, node-&gt;child1().useKind() == UntypedUse, node-&gt;child1().useKind());
 5576 
 5577     JSValueOperand argument(this, node-&gt;child1());
 5578     JSValueRegs argumentRegs = argument.jsValueRegs();
 5579 
 5580     flushRegisters();
 5581     JSValueRegsFlushedCallResult result(this);
 5582     JSValueRegs resultRegs = result.regs();
 5583     J_JITOperation_EJ operation = nullptr;
 5584     if (node-&gt;op() == ArithRound)
 5585         operation = operationArithRound;
 5586     else if (node-&gt;op() == ArithFloor)
 5587         operation = operationArithFloor;
 5588     else if (node-&gt;op() == ArithCeil)
 5589         operation = operationArithCeil;
 5590     else {
 5591         ASSERT(node-&gt;op() == ArithTrunc);
 5592         operation = operationArithTrunc;
 5593     }
 5594     callOperation(operation, resultRegs, argumentRegs);
 5595     m_jit.exceptionCheck();
 5596     jsValueResult(resultRegs, node);
 5597 }
 5598 
 5599 void SpeculativeJIT::compileArithUnary(Node* node)
 5600 {
 5601     compileArithDoubleUnaryOp(node, arithUnaryFunction(node-&gt;arithUnaryType()), arithUnaryOperation(node-&gt;arithUnaryType()));
 5602 }
 5603 
 5604 void SpeculativeJIT::compileArithSqrt(Node* node)
 5605 {
 5606     if (node-&gt;child1().useKind() == DoubleRepUse) {
 5607         SpeculateDoubleOperand op1(this, node-&gt;child1());
 5608         FPRReg op1FPR = op1.fpr();
 5609 
 5610         if (!MacroAssembler::supportsFloatingPointSqrt() || !Options::useArchitectureSpecificOptimizations()) {
 5611             flushRegisters();
 5612             FPRResult result(this);
 5613             callOperation&lt;D_JITOperation_D&gt;(sqrt, result.fpr(), op1FPR);
 5614             doubleResult(result.fpr(), node);
 5615         } else {
 5616             FPRTemporary result(this, op1);
 5617             m_jit.sqrtDouble(op1.fpr(), result.fpr());
 5618             doubleResult(result.fpr(), node);
 5619         }
 5620         return;
 5621     }
 5622 
 5623     JSValueOperand op1(this, node-&gt;child1());
 5624     JSValueRegs op1Regs = op1.jsValueRegs();
 5625     flushRegisters();
 5626     FPRResult result(this);
 5627     callOperation(operationArithSqrt, result.fpr(), op1Regs);
 5628     m_jit.exceptionCheck();
 5629     doubleResult(result.fpr(), node);
 5630 }
 5631 
 5632 void SpeculativeJIT::compileArithMinMax(Node* node)
 5633 {
 5634     switch (node-&gt;binaryUseKind()) {
 5635     case Int32Use: {
 5636         SpeculateStrictInt32Operand op1(this, node-&gt;child1());
 5637         SpeculateStrictInt32Operand op2(this, node-&gt;child2());
 5638         GPRTemporary result(this, Reuse, op1);
 5639 
 5640         GPRReg op1GPR = op1.gpr();
 5641         GPRReg op2GPR = op2.gpr();
 5642         GPRReg resultGPR = result.gpr();
 5643 
 5644         MacroAssembler::Jump op1Less = m_jit.branch32(node-&gt;op() == ArithMin ? MacroAssembler::LessThan : MacroAssembler::GreaterThan, op1GPR, op2GPR);
 5645         m_jit.move(op2GPR, resultGPR);
 5646         if (op1GPR != resultGPR) {
 5647             MacroAssembler::Jump done = m_jit.jump();
 5648             op1Less.link(&amp;m_jit);
 5649             m_jit.move(op1GPR, resultGPR);
 5650             done.link(&amp;m_jit);
 5651         } else
 5652             op1Less.link(&amp;m_jit);
 5653 
 5654         int32Result(resultGPR, node);
 5655         break;
 5656     }
 5657 
 5658     case DoubleRepUse: {
 5659         SpeculateDoubleOperand op1(this, node-&gt;child1());
 5660         SpeculateDoubleOperand op2(this, node-&gt;child2());
 5661         FPRTemporary result(this, op1);
 5662 
 5663         FPRReg op1FPR = op1.fpr();
 5664         FPRReg op2FPR = op2.fpr();
 5665         FPRReg resultFPR = result.fpr();
 5666 
 5667         MacroAssembler::JumpList done;
 5668 
 5669         MacroAssembler::Jump op1Less = m_jit.branchDouble(node-&gt;op() == ArithMin ? MacroAssembler::DoubleLessThan : MacroAssembler::DoubleGreaterThan, op1FPR, op2FPR);
 5670 
 5671         // op2 is eather the lesser one or one of then is NaN
 5672         MacroAssembler::Jump op2Less = m_jit.branchDouble(node-&gt;op() == ArithMin ? MacroAssembler::DoubleGreaterThanOrEqual : MacroAssembler::DoubleLessThanOrEqual, op1FPR, op2FPR);
 5673 
 5674         // Unordered case. We don&#39;t know which of op1, op2 is NaN. Manufacture NaN by adding
 5675         // op1 + op2 and putting it into result.
 5676         m_jit.addDouble(op1FPR, op2FPR, resultFPR);
 5677         done.append(m_jit.jump());
 5678 
 5679         op2Less.link(&amp;m_jit);
 5680         m_jit.moveDouble(op2FPR, resultFPR);
 5681 
 5682         if (op1FPR != resultFPR) {
 5683             done.append(m_jit.jump());
 5684 
 5685             op1Less.link(&amp;m_jit);
 5686             m_jit.moveDouble(op1FPR, resultFPR);
 5687         } else
 5688             op1Less.link(&amp;m_jit);
 5689 
 5690         done.link(&amp;m_jit);
 5691 
 5692         doubleResult(resultFPR, node);
 5693         break;
 5694     }
 5695 
 5696     default:
 5697         DFG_CRASH(m_jit.graph(), node, &quot;Bad use kind&quot;);
 5698         break;
 5699     }
 5700 }
 5701 
 5702 // For small positive integers , it is worth doing a tiny inline loop to exponentiate the base.
 5703 // Every register is clobbered by this helper.
 5704 static MacroAssembler::Jump compileArithPowIntegerFastPath(JITCompiler&amp; assembler, FPRReg xOperand, GPRReg yOperand, FPRReg result)
 5705 {
 5706     MacroAssembler::JumpList skipFastPath;
 5707     skipFastPath.append(assembler.branch32(MacroAssembler::Above, yOperand, MacroAssembler::TrustedImm32(maxExponentForIntegerMathPow)));
 5708 
 5709     static const double oneConstant = 1.0;
 5710     assembler.loadDouble(MacroAssembler::TrustedImmPtr(&amp;oneConstant), result);
 5711 
 5712     MacroAssembler::Label startLoop(assembler.label());
 5713     MacroAssembler::Jump exponentIsEven = assembler.branchTest32(MacroAssembler::Zero, yOperand, MacroAssembler::TrustedImm32(1));
 5714     assembler.mulDouble(xOperand, result);
 5715     exponentIsEven.link(&amp;assembler);
 5716     assembler.mulDouble(xOperand, xOperand);
 5717     assembler.rshift32(MacroAssembler::TrustedImm32(1), yOperand);
 5718     assembler.branchTest32(MacroAssembler::NonZero, yOperand).linkTo(startLoop, &amp;assembler);
 5719 
 5720     MacroAssembler::Jump skipSlowPath = assembler.jump();
 5721     skipFastPath.link(&amp;assembler);
 5722 
 5723     return skipSlowPath;
 5724 }
 5725 
 5726 void SpeculativeJIT::compileArithPow(Node* node)
 5727 {
 5728     if (node-&gt;child2().useKind() == Int32Use) {
 5729         SpeculateDoubleOperand xOperand(this, node-&gt;child1());
 5730         SpeculateInt32Operand yOperand(this, node-&gt;child2());
 5731         FPRReg xOperandfpr = xOperand.fpr();
 5732         GPRReg yOperandGpr = yOperand.gpr();
 5733         FPRTemporary yOperandfpr(this);
 5734 
 5735         flushRegisters();
 5736 
 5737         FPRResult result(this);
 5738         FPRReg resultFpr = result.fpr();
 5739 
 5740         FPRTemporary xOperandCopy(this);
 5741         FPRReg xOperandCopyFpr = xOperandCopy.fpr();
 5742         m_jit.moveDouble(xOperandfpr, xOperandCopyFpr);
 5743 
 5744         GPRTemporary counter(this);
 5745         GPRReg counterGpr = counter.gpr();
 5746         m_jit.move(yOperandGpr, counterGpr);
 5747 
 5748         MacroAssembler::Jump skipFallback = compileArithPowIntegerFastPath(m_jit, xOperandCopyFpr, counterGpr, resultFpr);
 5749         m_jit.convertInt32ToDouble(yOperandGpr, yOperandfpr.fpr());
 5750         callOperation(operationMathPow, resultFpr, xOperandfpr, yOperandfpr.fpr());
 5751 
 5752         skipFallback.link(&amp;m_jit);
 5753         doubleResult(resultFpr, node);
 5754         return;
 5755     }
 5756 
 5757     if (node-&gt;child2()-&gt;isDoubleConstant()) {
 5758         double exponent = node-&gt;child2()-&gt;asNumber();
 5759         static const double infinityConstant = std::numeric_limits&lt;double&gt;::infinity();
 5760         static const double minusInfinityConstant = -std::numeric_limits&lt;double&gt;::infinity();
 5761         if (exponent == 0.5) {
 5762             SpeculateDoubleOperand xOperand(this, node-&gt;child1());
 5763             FPRTemporary result(this);
 5764             FPRReg xOperandFpr = xOperand.fpr();
 5765             FPRReg resultFpr = result.fpr();
 5766 
 5767             m_jit.moveZeroToDouble(resultFpr);
 5768             MacroAssembler::Jump xIsZeroOrNegativeZero = m_jit.branchDouble(MacroAssembler::DoubleEqual, xOperandFpr, resultFpr);
 5769 
 5770             m_jit.loadDouble(TrustedImmPtr(&amp;minusInfinityConstant), resultFpr);
 5771             MacroAssembler::Jump xIsMinusInfinity = m_jit.branchDouble(MacroAssembler::DoubleEqual, xOperandFpr, resultFpr);
 5772             m_jit.sqrtDouble(xOperandFpr, resultFpr);
 5773             MacroAssembler::Jump doneWithSqrt = m_jit.jump();
 5774 
 5775             xIsMinusInfinity.link(&amp;m_jit);
 5776             if (isX86())
 5777                 m_jit.loadDouble(TrustedImmPtr(&amp;infinityConstant), resultFpr);
 5778             else
 5779                 m_jit.absDouble(resultFpr, resultFpr);
 5780 
 5781             xIsZeroOrNegativeZero.link(&amp;m_jit);
 5782             doneWithSqrt.link(&amp;m_jit);
 5783             doubleResult(resultFpr, node);
 5784             return;
 5785         }
 5786         if (exponent == -0.5) {
 5787             SpeculateDoubleOperand xOperand(this, node-&gt;child1());
 5788             FPRTemporary scratch(this);
 5789             FPRTemporary result(this);
 5790             FPRReg xOperandFpr = xOperand.fpr();
 5791             FPRReg scratchFPR = scratch.fpr();
 5792             FPRReg resultFpr = result.fpr();
 5793 
 5794             m_jit.moveZeroToDouble(resultFpr);
 5795             MacroAssembler::Jump xIsZeroOrNegativeZero = m_jit.branchDouble(MacroAssembler::DoubleEqual, xOperandFpr, resultFpr);
 5796 
 5797             m_jit.loadDouble(TrustedImmPtr(&amp;minusInfinityConstant), resultFpr);
 5798             MacroAssembler::Jump xIsMinusInfinity = m_jit.branchDouble(MacroAssembler::DoubleEqual, xOperandFpr, resultFpr);
 5799 
 5800             static const double oneConstant = 1.;
 5801             m_jit.loadDouble(TrustedImmPtr(&amp;oneConstant), resultFpr);
 5802             m_jit.sqrtDouble(xOperandFpr, scratchFPR);
 5803             m_jit.divDouble(resultFpr, scratchFPR, resultFpr);
 5804             MacroAssembler::Jump doneWithSqrt = m_jit.jump();
 5805 
 5806             xIsZeroOrNegativeZero.link(&amp;m_jit);
 5807             m_jit.loadDouble(TrustedImmPtr(&amp;infinityConstant), resultFpr);
 5808             MacroAssembler::Jump doneWithBaseZero = m_jit.jump();
 5809 
 5810             xIsMinusInfinity.link(&amp;m_jit);
 5811             m_jit.moveZeroToDouble(resultFpr);
 5812 
 5813             doneWithBaseZero.link(&amp;m_jit);
 5814             doneWithSqrt.link(&amp;m_jit);
 5815             doubleResult(resultFpr, node);
 5816             return;
 5817         }
 5818     }
 5819 
 5820     SpeculateDoubleOperand xOperand(this, node-&gt;child1());
 5821     SpeculateDoubleOperand yOperand(this, node-&gt;child2());
 5822     FPRReg xOperandfpr = xOperand.fpr();
 5823     FPRReg yOperandfpr = yOperand.fpr();
 5824 
 5825     flushRegisters();
 5826 
 5827     FPRResult result(this);
 5828     FPRReg resultFpr = result.fpr();
 5829 
 5830     FPRTemporary xOperandCopy(this);
 5831     FPRReg xOperandCopyFpr = xOperandCopy.fpr();
 5832 
 5833     FPRTemporary scratch(this);
 5834     FPRReg scratchFpr = scratch.fpr();
 5835 
 5836     GPRTemporary yOperandInteger(this);
 5837     GPRReg yOperandIntegerGpr = yOperandInteger.gpr();
 5838     MacroAssembler::JumpList failedExponentConversionToInteger;
 5839     m_jit.branchConvertDoubleToInt32(yOperandfpr, yOperandIntegerGpr, failedExponentConversionToInteger, scratchFpr, false);
 5840 
 5841     m_jit.moveDouble(xOperandfpr, xOperandCopyFpr);
 5842     MacroAssembler::Jump skipFallback = compileArithPowIntegerFastPath(m_jit, xOperandCopyFpr, yOperandInteger.gpr(), resultFpr);
 5843     failedExponentConversionToInteger.link(&amp;m_jit);
 5844 
 5845     callOperation(operationMathPow, resultFpr, xOperandfpr, yOperandfpr);
 5846     skipFallback.link(&amp;m_jit);
 5847     doubleResult(resultFpr, node);
 5848 }
 5849 
 5850 // Returns true if the compare is fused with a subsequent branch.
 5851 bool SpeculativeJIT::compare(Node* node, MacroAssembler::RelationalCondition condition, MacroAssembler::DoubleCondition doubleCondition, S_JITOperation_EJJ operation)
 5852 {
 5853     if (compilePeepHoleBranch(node, condition, doubleCondition, operation))
 5854         return true;
 5855 
 5856     if (node-&gt;isBinaryUseKind(Int32Use)) {
 5857         compileInt32Compare(node, condition);
 5858         return false;
 5859     }
 5860 
 5861 #if USE(JSVALUE64)
 5862     if (node-&gt;isBinaryUseKind(Int52RepUse)) {
 5863         compileInt52Compare(node, condition);
 5864         return false;
 5865     }
 5866 #endif // USE(JSVALUE64)
 5867 
 5868     if (node-&gt;isBinaryUseKind(DoubleRepUse)) {
 5869         compileDoubleCompare(node, doubleCondition);
 5870         return false;
 5871     }
 5872 
 5873     if (node-&gt;isBinaryUseKind(StringUse)) {
 5874         if (node-&gt;op() == CompareEq)
 5875             compileStringEquality(node);
 5876         else
 5877             compileStringCompare(node, condition);
 5878         return false;
 5879     }
 5880 
 5881     if (node-&gt;isBinaryUseKind(StringIdentUse)) {
 5882         if (node-&gt;op() == CompareEq)
 5883             compileStringIdentEquality(node);
 5884         else
 5885             compileStringIdentCompare(node, condition);
 5886         return false;
 5887     }
 5888 
 5889     if (node-&gt;op() == CompareEq) {
 5890         if (node-&gt;isBinaryUseKind(BooleanUse)) {
 5891             compileBooleanCompare(node, condition);
 5892             return false;
 5893         }
 5894 
 5895         if (node-&gt;isBinaryUseKind(SymbolUse)) {
 5896             compileSymbolEquality(node);
 5897             return false;
 5898         }
 5899 
 5900         if (node-&gt;isBinaryUseKind(ObjectUse)) {
 5901             compileObjectEquality(node);
 5902             return false;
 5903         }
 5904 
 5905         if (node-&gt;isBinaryUseKind(ObjectUse, ObjectOrOtherUse)) {
 5906             compileObjectToObjectOrOtherEquality(node-&gt;child1(), node-&gt;child2());
 5907             return false;
 5908         }
 5909 
 5910         if (node-&gt;isBinaryUseKind(ObjectOrOtherUse, ObjectUse)) {
 5911             compileObjectToObjectOrOtherEquality(node-&gt;child2(), node-&gt;child1());
 5912             return false;
 5913         }
 5914 
 5915         if (!needsTypeCheck(node-&gt;child1(), SpecOther)) {
 5916             nonSpeculativeNonPeepholeCompareNullOrUndefined(node-&gt;child2());
 5917             return false;
 5918         }
 5919 
 5920         if (!needsTypeCheck(node-&gt;child2(), SpecOther)) {
 5921             nonSpeculativeNonPeepholeCompareNullOrUndefined(node-&gt;child1());
 5922             return false;
 5923         }
 5924     }
 5925 
 5926     nonSpeculativeNonPeepholeCompare(node, condition, operation);
 5927     return false;
 5928 }
 5929 
 5930 void SpeculativeJIT::compileCompareUnsigned(Node* node, MacroAssembler::RelationalCondition condition)
 5931 {
 5932     compileInt32Compare(node, condition);
 5933 }
 5934 
 5935 bool SpeculativeJIT::compileStrictEq(Node* node)
 5936 {
 5937     if (node-&gt;isBinaryUseKind(BooleanUse)) {
 5938         unsigned branchIndexInBlock = detectPeepHoleBranch();
 5939         if (branchIndexInBlock != UINT_MAX) {
 5940             Node* branchNode = m_block-&gt;at(branchIndexInBlock);
 5941             compilePeepHoleBooleanBranch(node, branchNode, MacroAssembler::Equal);
 5942             use(node-&gt;child1());
 5943             use(node-&gt;child2());
 5944             m_indexInBlock = branchIndexInBlock;
 5945             m_currentNode = branchNode;
 5946             return true;
 5947         }
 5948         compileBooleanCompare(node, MacroAssembler::Equal);
 5949         return false;
 5950     }
 5951 
 5952     if (node-&gt;isBinaryUseKind(Int32Use)) {
 5953         unsigned branchIndexInBlock = detectPeepHoleBranch();
 5954         if (branchIndexInBlock != UINT_MAX) {
 5955             Node* branchNode = m_block-&gt;at(branchIndexInBlock);
 5956             compilePeepHoleInt32Branch(node, branchNode, MacroAssembler::Equal);
 5957             use(node-&gt;child1());
 5958             use(node-&gt;child2());
 5959             m_indexInBlock = branchIndexInBlock;
 5960             m_currentNode = branchNode;
 5961             return true;
 5962         }
 5963         compileInt32Compare(node, MacroAssembler::Equal);
 5964         return false;
 5965     }
 5966 
 5967 #if USE(JSVALUE64)
 5968     if (node-&gt;isBinaryUseKind(Int52RepUse)) {
 5969         unsigned branchIndexInBlock = detectPeepHoleBranch();
 5970         if (branchIndexInBlock != UINT_MAX) {
 5971             Node* branchNode = m_block-&gt;at(branchIndexInBlock);
 5972             compilePeepHoleInt52Branch(node, branchNode, MacroAssembler::Equal);
 5973             use(node-&gt;child1());
 5974             use(node-&gt;child2());
 5975             m_indexInBlock = branchIndexInBlock;
 5976             m_currentNode = branchNode;
 5977             return true;
 5978         }
 5979         compileInt52Compare(node, MacroAssembler::Equal);
 5980         return false;
 5981     }
 5982 #endif // USE(JSVALUE64)
 5983 
 5984     if (node-&gt;isBinaryUseKind(DoubleRepUse)) {
 5985         unsigned branchIndexInBlock = detectPeepHoleBranch();
 5986         if (branchIndexInBlock != UINT_MAX) {
 5987             Node* branchNode = m_block-&gt;at(branchIndexInBlock);
 5988             compilePeepHoleDoubleBranch(node, branchNode, MacroAssembler::DoubleEqual);
 5989             use(node-&gt;child1());
 5990             use(node-&gt;child2());
 5991             m_indexInBlock = branchIndexInBlock;
 5992             m_currentNode = branchNode;
 5993             return true;
 5994         }
 5995         compileDoubleCompare(node, MacroAssembler::DoubleEqual);
 5996         return false;
 5997     }
 5998 
 5999     if (node-&gt;isBinaryUseKind(SymbolUse)) {
 6000         unsigned branchIndexInBlock = detectPeepHoleBranch();
 6001         if (branchIndexInBlock != UINT_MAX) {
 6002             Node* branchNode = m_block-&gt;at(branchIndexInBlock);
 6003             compilePeepHoleSymbolEquality(node, branchNode);
 6004             use(node-&gt;child1());
 6005             use(node-&gt;child2());
 6006             m_indexInBlock = branchIndexInBlock;
 6007             m_currentNode = branchNode;
 6008             return true;
 6009         }
 6010         compileSymbolEquality(node);
 6011         return false;
 6012     }
 6013 
 6014     if (node-&gt;isBinaryUseKind(BigIntUse)) {
 6015         compileBigIntEquality(node);
 6016         return false;
 6017     }
 6018 
 6019     if (node-&gt;isBinaryUseKind(SymbolUse, UntypedUse)) {
 6020         compileSymbolUntypedEquality(node, node-&gt;child1(), node-&gt;child2());
 6021         return false;
 6022     }
 6023 
 6024     if (node-&gt;isBinaryUseKind(UntypedUse, SymbolUse)) {
 6025         compileSymbolUntypedEquality(node, node-&gt;child2(), node-&gt;child1());
 6026         return false;
 6027     }
 6028 
 6029     if (node-&gt;isBinaryUseKind(StringUse)) {
 6030         compileStringEquality(node);
 6031         return false;
 6032     }
 6033 
 6034     if (node-&gt;isBinaryUseKind(StringIdentUse)) {
 6035         compileStringIdentEquality(node);
 6036         return false;
 6037     }
 6038 
 6039     if (node-&gt;isBinaryUseKind(ObjectUse, UntypedUse)) {
 6040         unsigned branchIndexInBlock = detectPeepHoleBranch();
 6041         if (branchIndexInBlock != UINT_MAX) {
 6042             Node* branchNode = m_block-&gt;at(branchIndexInBlock);
 6043             compilePeepHoleObjectStrictEquality(node-&gt;child1(), node-&gt;child2(), branchNode);
 6044             use(node-&gt;child1());
 6045             use(node-&gt;child2());
 6046             m_indexInBlock = branchIndexInBlock;
 6047             m_currentNode = branchNode;
 6048             return true;
 6049         }
 6050         compileObjectStrictEquality(node-&gt;child1(), node-&gt;child2());
 6051         return false;
 6052     }
 6053 
 6054     if (node-&gt;isBinaryUseKind(UntypedUse, ObjectUse)) {
 6055         unsigned branchIndexInBlock = detectPeepHoleBranch();
 6056         if (branchIndexInBlock != UINT_MAX) {
 6057             Node* branchNode = m_block-&gt;at(branchIndexInBlock);
 6058             compilePeepHoleObjectStrictEquality(node-&gt;child2(), node-&gt;child1(), branchNode);
 6059             use(node-&gt;child1());
 6060             use(node-&gt;child2());
 6061             m_indexInBlock = branchIndexInBlock;
 6062             m_currentNode = branchNode;
 6063             return true;
 6064         }
 6065         compileObjectStrictEquality(node-&gt;child2(), node-&gt;child1());
 6066         return false;
 6067     }
 6068 
 6069     if (node-&gt;isBinaryUseKind(ObjectUse)) {
 6070         unsigned branchIndexInBlock = detectPeepHoleBranch();
 6071         if (branchIndexInBlock != UINT_MAX) {
 6072             Node* branchNode = m_block-&gt;at(branchIndexInBlock);
 6073             compilePeepHoleObjectEquality(node, branchNode);
 6074             use(node-&gt;child1());
 6075             use(node-&gt;child2());
 6076             m_indexInBlock = branchIndexInBlock;
 6077             m_currentNode = branchNode;
 6078             return true;
 6079         }
 6080         compileObjectEquality(node);
 6081         return false;
 6082     }
 6083 
 6084     if (node-&gt;isBinaryUseKind(MiscUse, UntypedUse)
 6085         || node-&gt;isBinaryUseKind(UntypedUse, MiscUse)) {
 6086         compileMiscStrictEq(node);
 6087         return false;
 6088     }
 6089 
 6090     if (node-&gt;isBinaryUseKind(StringIdentUse, NotStringVarUse)) {
 6091         compileStringIdentToNotStringVarEquality(node, node-&gt;child1(), node-&gt;child2());
 6092         return false;
 6093     }
 6094 
 6095     if (node-&gt;isBinaryUseKind(NotStringVarUse, StringIdentUse)) {
 6096         compileStringIdentToNotStringVarEquality(node, node-&gt;child2(), node-&gt;child1());
 6097         return false;
 6098     }
 6099 
 6100     if (node-&gt;isBinaryUseKind(StringUse, UntypedUse)) {
 6101         compileStringToUntypedEquality(node, node-&gt;child1(), node-&gt;child2());
 6102         return false;
 6103     }
 6104 
 6105     if (node-&gt;isBinaryUseKind(UntypedUse, StringUse)) {
 6106         compileStringToUntypedEquality(node, node-&gt;child2(), node-&gt;child1());
 6107         return false;
 6108     }
 6109 
 6110     RELEASE_ASSERT(node-&gt;isBinaryUseKind(UntypedUse));
 6111     return nonSpeculativeStrictEq(node);
 6112 }
 6113 
 6114 void SpeculativeJIT::compileBooleanCompare(Node* node, MacroAssembler::RelationalCondition condition)
 6115 {
 6116     SpeculateBooleanOperand op1(this, node-&gt;child1());
 6117     SpeculateBooleanOperand op2(this, node-&gt;child2());
 6118     GPRTemporary result(this);
 6119 
 6120     m_jit.compare32(condition, op1.gpr(), op2.gpr(), result.gpr());
 6121 
 6122     unblessedBooleanResult(result.gpr(), node);
 6123 }
 6124 
 6125 void SpeculativeJIT::compileInt32Compare(Node* node, MacroAssembler::RelationalCondition condition)
 6126 {
 6127     if (node-&gt;child1()-&gt;isInt32Constant()) {
 6128         SpeculateInt32Operand op2(this, node-&gt;child2());
 6129         GPRTemporary result(this, Reuse, op2);
 6130         int32_t imm = node-&gt;child1()-&gt;asInt32();
 6131         m_jit.compare32(condition, JITCompiler::Imm32(imm), op2.gpr(), result.gpr());
 6132 
 6133         unblessedBooleanResult(result.gpr(), node);
 6134     } else if (node-&gt;child2()-&gt;isInt32Constant()) {
 6135         SpeculateInt32Operand op1(this, node-&gt;child1());
 6136         GPRTemporary result(this, Reuse, op1);
 6137         int32_t imm = node-&gt;child2()-&gt;asInt32();
 6138         m_jit.compare32(condition, op1.gpr(), JITCompiler::Imm32(imm), result.gpr());
 6139 
 6140         unblessedBooleanResult(result.gpr(), node);
 6141     } else {
 6142         SpeculateInt32Operand op1(this, node-&gt;child1());
 6143         SpeculateInt32Operand op2(this, node-&gt;child2());
 6144         GPRTemporary result(this, Reuse, op1, op2);
 6145         m_jit.compare32(condition, op1.gpr(), op2.gpr(), result.gpr());
 6146 
 6147         unblessedBooleanResult(result.gpr(), node);
 6148     }
 6149 }
 6150 
 6151 void SpeculativeJIT::compileDoubleCompare(Node* node, MacroAssembler::DoubleCondition condition)
 6152 {
 6153     SpeculateDoubleOperand op1(this, node-&gt;child1());
 6154     SpeculateDoubleOperand op2(this, node-&gt;child2());
 6155     GPRTemporary result(this);
 6156 
 6157     FPRReg op1FPR = op1.fpr();
 6158     FPRReg op2FPR = op2.fpr();
 6159     GPRReg resultGPR = result.gpr();
 6160 
 6161     m_jit.compareDouble(condition, op1FPR, op2FPR, resultGPR);
 6162 
 6163     unblessedBooleanResult(resultGPR, node);
 6164 }
 6165 
 6166 void SpeculativeJIT::compileObjectEquality(Node* node)
 6167 {
 6168     SpeculateCellOperand op1(this, node-&gt;child1());
 6169     SpeculateCellOperand op2(this, node-&gt;child2());
 6170     GPRTemporary result(this, Reuse, op1);
 6171 
 6172     GPRReg op1GPR = op1.gpr();
 6173     GPRReg op2GPR = op2.gpr();
 6174     GPRReg resultGPR = result.gpr();
 6175 
 6176     if (masqueradesAsUndefinedWatchpointIsStillValid()) {
 6177         DFG_TYPE_CHECK(
 6178             JSValueSource::unboxedCell(op1GPR), node-&gt;child1(), SpecObject, m_jit.branchIfNotObject(op1GPR));
 6179         DFG_TYPE_CHECK(
 6180             JSValueSource::unboxedCell(op2GPR), node-&gt;child2(), SpecObject, m_jit.branchIfNotObject(op2GPR));
 6181     } else {
 6182         DFG_TYPE_CHECK(
 6183             JSValueSource::unboxedCell(op1GPR), node-&gt;child1(), SpecObject, m_jit.branchIfNotObject(op1GPR));
 6184         speculationCheck(BadType, JSValueSource::unboxedCell(op1GPR), node-&gt;child1(),
 6185             m_jit.branchTest8(
 6186                 MacroAssembler::NonZero,
 6187                 MacroAssembler::Address(op1GPR, JSCell::typeInfoFlagsOffset()),
 6188                 MacroAssembler::TrustedImm32(MasqueradesAsUndefined)));
 6189 
 6190         DFG_TYPE_CHECK(
 6191             JSValueSource::unboxedCell(op2GPR), node-&gt;child2(), SpecObject, m_jit.branchIfNotObject(op2GPR));
 6192         speculationCheck(BadType, JSValueSource::unboxedCell(op2GPR), node-&gt;child2(),
 6193             m_jit.branchTest8(
 6194                 MacroAssembler::NonZero,
 6195                 MacroAssembler::Address(op2GPR, JSCell::typeInfoFlagsOffset()),
 6196                 MacroAssembler::TrustedImm32(MasqueradesAsUndefined)));
 6197     }
 6198 
 6199     m_jit.comparePtr(MacroAssembler::Equal, op1GPR, op2GPR, resultGPR);
 6200     unblessedBooleanResult(resultGPR, node);
 6201 }
 6202 
 6203 void SpeculativeJIT::compileSymbolEquality(Node* node)
 6204 {
 6205     SpeculateCellOperand left(this, node-&gt;child1());
 6206     SpeculateCellOperand right(this, node-&gt;child2());
 6207     GPRTemporary result(this, Reuse, left, right);
 6208 
 6209     GPRReg leftGPR = left.gpr();
 6210     GPRReg rightGPR = right.gpr();
 6211     GPRReg resultGPR = result.gpr();
 6212 
 6213     speculateSymbol(node-&gt;child1(), leftGPR);
 6214     speculateSymbol(node-&gt;child2(), rightGPR);
 6215 
 6216     m_jit.comparePtr(JITCompiler::Equal, leftGPR, rightGPR, resultGPR);
 6217     unblessedBooleanResult(resultGPR, node);
 6218 }
 6219 
 6220 void SpeculativeJIT::compilePeepHoleSymbolEquality(Node* node, Node* branchNode)
 6221 {
 6222     SpeculateCellOperand left(this, node-&gt;child1());
 6223     SpeculateCellOperand right(this, node-&gt;child2());
 6224 
 6225     GPRReg leftGPR = left.gpr();
 6226     GPRReg rightGPR = right.gpr();
 6227 
 6228     speculateSymbol(node-&gt;child1(), leftGPR);
 6229     speculateSymbol(node-&gt;child2(), rightGPR);
 6230 
 6231     BasicBlock* taken = branchNode-&gt;branchData()-&gt;taken.block;
 6232     BasicBlock* notTaken = branchNode-&gt;branchData()-&gt;notTaken.block;
 6233 
 6234     if (taken == nextBlock()) {
 6235         branchPtr(JITCompiler::NotEqual, leftGPR, rightGPR, notTaken);
 6236         jump(taken);
 6237     } else {
 6238         branchPtr(JITCompiler::Equal, leftGPR, rightGPR, taken);
 6239         jump(notTaken);
 6240     }
 6241 }
 6242 
 6243 void SpeculativeJIT::compileStringEquality(
 6244     Node* node, GPRReg leftGPR, GPRReg rightGPR, GPRReg lengthGPR, GPRReg leftTempGPR,
 6245     GPRReg rightTempGPR, GPRReg leftTemp2GPR, GPRReg rightTemp2GPR,
 6246     const JITCompiler::JumpList&amp; fastTrue, const JITCompiler::JumpList&amp; fastFalse)
 6247 {
 6248     JITCompiler::JumpList trueCase;
 6249     JITCompiler::JumpList falseCase;
 6250     JITCompiler::JumpList slowCase;
 6251 
 6252     trueCase.append(fastTrue);
 6253     falseCase.append(fastFalse);
 6254 
 6255     m_jit.loadPtr(MacroAssembler::Address(leftGPR, JSString::offsetOfValue()), leftTempGPR);
 6256     m_jit.loadPtr(MacroAssembler::Address(rightGPR, JSString::offsetOfValue()), rightTempGPR);
 6257 
 6258     slowCase.append(m_jit.branchIfRopeStringImpl(leftTempGPR));
 6259     slowCase.append(m_jit.branchIfRopeStringImpl(rightTempGPR));
 6260 
 6261     m_jit.load32(MacroAssembler::Address(leftTempGPR, StringImpl::lengthMemoryOffset()), lengthGPR);
 6262 
 6263     falseCase.append(m_jit.branch32(
 6264         MacroAssembler::NotEqual,
 6265         MacroAssembler::Address(rightTempGPR, StringImpl::lengthMemoryOffset()),
 6266         lengthGPR));
 6267 
 6268     trueCase.append(m_jit.branchTest32(MacroAssembler::Zero, lengthGPR));
 6269 
 6270     slowCase.append(m_jit.branchTest32(
 6271         MacroAssembler::Zero,
 6272         MacroAssembler::Address(leftTempGPR, StringImpl::flagsOffset()),
 6273         TrustedImm32(StringImpl::flagIs8Bit())));
 6274     slowCase.append(m_jit.branchTest32(
 6275         MacroAssembler::Zero,
 6276         MacroAssembler::Address(rightTempGPR, StringImpl::flagsOffset()),
 6277         TrustedImm32(StringImpl::flagIs8Bit())));
 6278 
 6279     m_jit.loadPtr(MacroAssembler::Address(leftTempGPR, StringImpl::dataOffset()), leftTempGPR);
 6280     m_jit.loadPtr(MacroAssembler::Address(rightTempGPR, StringImpl::dataOffset()), rightTempGPR);
 6281 
 6282     MacroAssembler::Label loop = m_jit.label();
 6283 
 6284     m_jit.sub32(TrustedImm32(1), lengthGPR);
 6285 
 6286     // This isn&#39;t going to generate the best code on x86. But that&#39;s OK, it&#39;s still better
 6287     // than not inlining.
 6288     m_jit.load8(MacroAssembler::BaseIndex(leftTempGPR, lengthGPR, MacroAssembler::TimesOne), leftTemp2GPR);
 6289     m_jit.load8(MacroAssembler::BaseIndex(rightTempGPR, lengthGPR, MacroAssembler::TimesOne), rightTemp2GPR);
 6290     falseCase.append(m_jit.branch32(MacroAssembler::NotEqual, leftTemp2GPR, rightTemp2GPR));
 6291 
 6292     m_jit.branchTest32(MacroAssembler::NonZero, lengthGPR).linkTo(loop, &amp;m_jit);
 6293 
 6294     trueCase.link(&amp;m_jit);
 6295     moveTrueTo(leftTempGPR);
 6296 
 6297     JITCompiler::Jump done = m_jit.jump();
 6298 
 6299     falseCase.link(&amp;m_jit);
 6300     moveFalseTo(leftTempGPR);
 6301 
 6302     done.link(&amp;m_jit);
 6303     addSlowPathGenerator(
 6304         slowPathCall(
 6305             slowCase, this, operationCompareStringEq, leftTempGPR, leftGPR, rightGPR));
 6306 
 6307     blessedBooleanResult(leftTempGPR, node);
 6308 }
 6309 
 6310 void SpeculativeJIT::compileStringEquality(Node* node)
 6311 {
 6312     SpeculateCellOperand left(this, node-&gt;child1());
 6313     SpeculateCellOperand right(this, node-&gt;child2());
 6314     GPRTemporary length(this);
 6315     GPRTemporary leftTemp(this);
 6316     GPRTemporary rightTemp(this);
 6317     GPRTemporary leftTemp2(this, Reuse, left);
 6318     GPRTemporary rightTemp2(this, Reuse, right);
 6319 
 6320     GPRReg leftGPR = left.gpr();
 6321     GPRReg rightGPR = right.gpr();
 6322     GPRReg lengthGPR = length.gpr();
 6323     GPRReg leftTempGPR = leftTemp.gpr();
 6324     GPRReg rightTempGPR = rightTemp.gpr();
 6325     GPRReg leftTemp2GPR = leftTemp2.gpr();
 6326     GPRReg rightTemp2GPR = rightTemp2.gpr();
 6327 
 6328     speculateString(node-&gt;child1(), leftGPR);
 6329 
 6330     // It&#39;s safe to branch around the type check below, since proving that the values are
 6331     // equal does indeed prove that the right value is a string.
 6332     JITCompiler::Jump fastTrue = m_jit.branchPtr(MacroAssembler::Equal, leftGPR, rightGPR);
 6333 
 6334     speculateString(node-&gt;child2(), rightGPR);
 6335 
 6336     compileStringEquality(
 6337         node, leftGPR, rightGPR, lengthGPR, leftTempGPR, rightTempGPR, leftTemp2GPR,
 6338         rightTemp2GPR, fastTrue, JITCompiler::Jump());
 6339 }
 6340 
 6341 void SpeculativeJIT::compileStringToUntypedEquality(Node* node, Edge stringEdge, Edge untypedEdge)
 6342 {
 6343     SpeculateCellOperand left(this, stringEdge);
 6344     JSValueOperand right(this, untypedEdge, ManualOperandSpeculation);
 6345     GPRTemporary length(this);
 6346     GPRTemporary leftTemp(this);
 6347     GPRTemporary rightTemp(this);
 6348     GPRTemporary leftTemp2(this, Reuse, left);
 6349     GPRTemporary rightTemp2(this);
 6350 
 6351     GPRReg leftGPR = left.gpr();
 6352     JSValueRegs rightRegs = right.jsValueRegs();
 6353     GPRReg lengthGPR = length.gpr();
 6354     GPRReg leftTempGPR = leftTemp.gpr();
 6355     GPRReg rightTempGPR = rightTemp.gpr();
 6356     GPRReg leftTemp2GPR = leftTemp2.gpr();
 6357     GPRReg rightTemp2GPR = rightTemp2.gpr();
 6358 
 6359     speculateString(stringEdge, leftGPR);
 6360 
 6361     JITCompiler::JumpList fastTrue;
 6362     JITCompiler::JumpList fastFalse;
 6363 
 6364     fastFalse.append(m_jit.branchIfNotCell(rightRegs));
 6365 
 6366     // It&#39;s safe to branch around the type check below, since proving that the values are
 6367     // equal does indeed prove that the right value is a string.
 6368     fastTrue.append(m_jit.branchPtr(
 6369         MacroAssembler::Equal, leftGPR, rightRegs.payloadGPR()));
 6370 
 6371     fastFalse.append(m_jit.branchIfNotString(rightRegs.payloadGPR()));
 6372 
 6373     compileStringEquality(
 6374         node, leftGPR, rightRegs.payloadGPR(), lengthGPR, leftTempGPR, rightTempGPR, leftTemp2GPR,
 6375         rightTemp2GPR, fastTrue, fastFalse);
 6376 }
 6377 
 6378 void SpeculativeJIT::compileStringIdentEquality(Node* node)
 6379 {
 6380     SpeculateCellOperand left(this, node-&gt;child1());
 6381     SpeculateCellOperand right(this, node-&gt;child2());
 6382     GPRTemporary leftTemp(this);
 6383     GPRTemporary rightTemp(this);
 6384 
 6385     GPRReg leftGPR = left.gpr();
 6386     GPRReg rightGPR = right.gpr();
 6387     GPRReg leftTempGPR = leftTemp.gpr();
 6388     GPRReg rightTempGPR = rightTemp.gpr();
 6389 
 6390     speculateString(node-&gt;child1(), leftGPR);
 6391     speculateString(node-&gt;child2(), rightGPR);
 6392 
 6393     speculateStringIdentAndLoadStorage(node-&gt;child1(), leftGPR, leftTempGPR);
 6394     speculateStringIdentAndLoadStorage(node-&gt;child2(), rightGPR, rightTempGPR);
 6395 
 6396     m_jit.comparePtr(MacroAssembler::Equal, leftTempGPR, rightTempGPR, leftTempGPR);
 6397 
 6398     unblessedBooleanResult(leftTempGPR, node);
 6399 }
 6400 
 6401 void SpeculativeJIT::compileStringIdentToNotStringVarEquality(
 6402     Node* node, Edge stringEdge, Edge notStringVarEdge)
 6403 {
 6404     SpeculateCellOperand left(this, stringEdge);
 6405     JSValueOperand right(this, notStringVarEdge, ManualOperandSpeculation);
 6406     GPRTemporary leftTemp(this);
 6407     GPRTemporary rightTemp(this);
 6408     GPRReg leftTempGPR = leftTemp.gpr();
 6409     GPRReg rightTempGPR = rightTemp.gpr();
 6410     GPRReg leftGPR = left.gpr();
 6411     JSValueRegs rightRegs = right.jsValueRegs();
 6412 
 6413     speculateString(stringEdge, leftGPR);
 6414     speculateStringIdentAndLoadStorage(stringEdge, leftGPR, leftTempGPR);
 6415 
 6416     moveFalseTo(rightTempGPR);
 6417     JITCompiler::JumpList notString;
 6418     notString.append(m_jit.branchIfNotCell(rightRegs));
 6419     notString.append(m_jit.branchIfNotString(rightRegs.payloadGPR()));
 6420 
 6421     speculateStringIdentAndLoadStorage(notStringVarEdge, rightRegs.payloadGPR(), rightTempGPR);
 6422 
 6423     m_jit.comparePtr(MacroAssembler::Equal, leftTempGPR, rightTempGPR, rightTempGPR);
 6424     notString.link(&amp;m_jit);
 6425 
 6426     unblessedBooleanResult(rightTempGPR, node);
 6427 }
 6428 
 6429 void SpeculativeJIT::compileStringCompare(Node* node, MacroAssembler::RelationalCondition condition)
 6430 {
 6431     SpeculateCellOperand left(this, node-&gt;child1());
 6432     SpeculateCellOperand right(this, node-&gt;child2());
 6433     GPRReg leftGPR = left.gpr();
 6434     GPRReg rightGPR = right.gpr();
 6435 
 6436     speculateString(node-&gt;child1(), leftGPR);
 6437     speculateString(node-&gt;child2(), rightGPR);
 6438 
 6439     C_JITOperation_B_EJssJss compareFunction = nullptr;
 6440     if (condition == MacroAssembler::LessThan)
 6441         compareFunction = operationCompareStringLess;
 6442     else if (condition == MacroAssembler::LessThanOrEqual)
 6443         compareFunction = operationCompareStringLessEq;
 6444     else if (condition == MacroAssembler::GreaterThan)
 6445         compareFunction = operationCompareStringGreater;
 6446     else if (condition == MacroAssembler::GreaterThanOrEqual)
 6447         compareFunction = operationCompareStringGreaterEq;
 6448     else
 6449         RELEASE_ASSERT_NOT_REACHED();
 6450 
 6451     GPRFlushedCallResult result(this);
 6452     GPRReg resultGPR = result.gpr();
 6453 
 6454     flushRegisters();
 6455     callOperation(compareFunction, resultGPR, leftGPR, rightGPR);
 6456     m_jit.exceptionCheck();
 6457 
 6458     unblessedBooleanResult(resultGPR, node);
 6459 }
 6460 
 6461 void SpeculativeJIT::compileStringIdentCompare(Node* node, MacroAssembler::RelationalCondition condition)
 6462 {
 6463     SpeculateCellOperand left(this, node-&gt;child1());
 6464     SpeculateCellOperand right(this, node-&gt;child2());
 6465     GPRFlushedCallResult result(this);
 6466     GPRTemporary leftTemp(this);
 6467     GPRTemporary rightTemp(this);
 6468 
 6469     GPRReg leftGPR = left.gpr();
 6470     GPRReg rightGPR = right.gpr();
 6471     GPRReg resultGPR = result.gpr();
 6472     GPRReg leftTempGPR = leftTemp.gpr();
 6473     GPRReg rightTempGPR = rightTemp.gpr();
 6474 
 6475     speculateString(node-&gt;child1(), leftGPR);
 6476     speculateString(node-&gt;child2(), rightGPR);
 6477 
 6478     C_JITOperation_TT compareFunction = nullptr;
 6479     if (condition == MacroAssembler::LessThan)
 6480         compareFunction = operationCompareStringImplLess;
 6481     else if (condition == MacroAssembler::LessThanOrEqual)
 6482         compareFunction = operationCompareStringImplLessEq;
 6483     else if (condition == MacroAssembler::GreaterThan)
 6484         compareFunction = operationCompareStringImplGreater;
 6485     else if (condition == MacroAssembler::GreaterThanOrEqual)
 6486         compareFunction = operationCompareStringImplGreaterEq;
 6487     else
 6488         RELEASE_ASSERT_NOT_REACHED();
 6489 
 6490     speculateStringIdentAndLoadStorage(node-&gt;child1(), leftGPR, leftTempGPR);
 6491     speculateStringIdentAndLoadStorage(node-&gt;child2(), rightGPR, rightTempGPR);
 6492 
 6493     flushRegisters();
 6494     callOperation(compareFunction, resultGPR, leftTempGPR, rightTempGPR);
 6495 
 6496     unblessedBooleanResult(resultGPR, node);
 6497 }
 6498 
 6499 void SpeculativeJIT::compileSameValue(Node* node)
 6500 {
 6501     if (node-&gt;isBinaryUseKind(DoubleRepUse)) {
 6502         SpeculateDoubleOperand arg1(this, node-&gt;child1());
 6503         SpeculateDoubleOperand arg2(this, node-&gt;child2());
 6504         GPRTemporary result(this);
 6505         GPRTemporary temp(this);
 6506         GPRTemporary temp2(this);
 6507 
 6508         FPRReg arg1FPR = arg1.fpr();
 6509         FPRReg arg2FPR = arg2.fpr();
 6510         GPRReg resultGPR = result.gpr();
 6511         GPRReg tempGPR = temp.gpr();
 6512         GPRReg temp2GPR = temp2.gpr();
 6513 
 6514 #if USE(JSVALUE64)
 6515         m_jit.moveDoubleTo64(arg1FPR, tempGPR);
 6516         m_jit.moveDoubleTo64(arg2FPR, temp2GPR);
 6517         auto trueCase = m_jit.branch64(CCallHelpers::Equal, tempGPR, temp2GPR);
 6518 #else
 6519         GPRTemporary temp3(this);
 6520         GPRReg temp3GPR = temp3.gpr();
 6521 
 6522         m_jit.moveDoubleToInts(arg1FPR, tempGPR, temp2GPR);
 6523         m_jit.moveDoubleToInts(arg2FPR, temp3GPR, resultGPR);
 6524         auto notEqual = m_jit.branch32(CCallHelpers::NotEqual, tempGPR, temp3GPR);
 6525         auto trueCase = m_jit.branch32(CCallHelpers::Equal, temp2GPR, resultGPR);
 6526         notEqual.link(&amp;m_jit);
 6527 #endif
 6528 
 6529         m_jit.compareDouble(CCallHelpers::DoubleNotEqualOrUnordered, arg1FPR, arg1FPR, tempGPR);
 6530         m_jit.compareDouble(CCallHelpers::DoubleNotEqualOrUnordered, arg2FPR, arg2FPR, temp2GPR);
 6531         m_jit.and32(tempGPR, temp2GPR, resultGPR);
 6532         auto done = m_jit.jump();
 6533 
 6534         trueCase.link(&amp;m_jit);
 6535         m_jit.move(CCallHelpers::TrustedImm32(1), resultGPR);
 6536         done.link(&amp;m_jit);
 6537 
 6538         unblessedBooleanResult(resultGPR, node);
 6539         return;
 6540     }
 6541 
 6542     ASSERT(node-&gt;isBinaryUseKind(UntypedUse));
 6543 
 6544     JSValueOperand arg1(this, node-&gt;child1());
 6545     JSValueOperand arg2(this, node-&gt;child2());
 6546     JSValueRegs arg1Regs = arg1.jsValueRegs();
 6547     JSValueRegs arg2Regs = arg2.jsValueRegs();
 6548 
 6549     arg1.use();
 6550     arg2.use();
 6551 
 6552     flushRegisters();
 6553 
 6554     GPRFlushedCallResult result(this);
 6555     GPRReg resultGPR = result.gpr();
 6556     callOperation(operationSameValue, resultGPR, arg1Regs, arg2Regs);
 6557     m_jit.exceptionCheck();
 6558 
 6559     unblessedBooleanResult(resultGPR, node, UseChildrenCalledExplicitly);
 6560 }
 6561 
 6562 void SpeculativeJIT::compileStringZeroLength(Node* node)
 6563 {
 6564     SpeculateCellOperand str(this, node-&gt;child1());
 6565     GPRReg strGPR = str.gpr();
 6566 
 6567     // Make sure that this is a string.
 6568     speculateString(node-&gt;child1(), strGPR);
 6569 
 6570     GPRTemporary eq(this);
 6571     GPRReg eqGPR = eq.gpr();
 6572 
 6573     m_jit.move(TrustedImmPtr::weakPointer(m_jit.graph(), jsEmptyString(m_jit.vm())), eqGPR);
 6574     m_jit.comparePtr(CCallHelpers::Equal, strGPR, eqGPR, eqGPR);
 6575     unblessedBooleanResult(eqGPR, node);
 6576 }
 6577 
 6578 void SpeculativeJIT::compileLogicalNotStringOrOther(Node* node)
 6579 {
 6580     JSValueOperand value(this, node-&gt;child1(), ManualOperandSpeculation);
 6581     GPRTemporary temp(this);
 6582     JSValueRegs valueRegs = value.jsValueRegs();
 6583     GPRReg tempGPR = temp.gpr();
 6584 
 6585     JITCompiler::Jump notCell = m_jit.branchIfNotCell(valueRegs);
 6586     GPRReg cellGPR = valueRegs.payloadGPR();
 6587     DFG_TYPE_CHECK(
 6588         valueRegs, node-&gt;child1(), (~SpecCellCheck) | SpecString, m_jit.branchIfNotString(cellGPR));
 6589 
 6590     m_jit.move(TrustedImmPtr::weakPointer(m_jit.graph(), jsEmptyString(m_jit.vm())), tempGPR);
 6591     m_jit.comparePtr(CCallHelpers::Equal, cellGPR, tempGPR, tempGPR);
 6592     auto done = m_jit.jump();
 6593 
 6594     notCell.link(&amp;m_jit);
 6595     DFG_TYPE_CHECK(
 6596         valueRegs, node-&gt;child1(), SpecCellCheck | SpecOther, m_jit.branchIfNotOther(valueRegs, tempGPR));
 6597     m_jit.move(TrustedImm32(1), tempGPR);
 6598 
 6599     done.link(&amp;m_jit);
 6600     unblessedBooleanResult(tempGPR, node);
 6601 
 6602 }
 6603 
 6604 void SpeculativeJIT::emitStringBranch(Edge nodeUse, BasicBlock* taken, BasicBlock* notTaken)
 6605 {
 6606     SpeculateCellOperand str(this, nodeUse);
 6607 
 6608     GPRReg strGPR = str.gpr();
 6609 
 6610     speculateString(nodeUse, strGPR);
 6611 
 6612     branchPtr(CCallHelpers::Equal, strGPR, TrustedImmPtr::weakPointer(m_jit.graph(), jsEmptyString(m_jit.vm())), notTaken);
 6613     jump(taken);
 6614 
 6615     noResult(m_currentNode);
 6616 }
 6617 
 6618 void SpeculativeJIT::emitStringOrOtherBranch(Edge nodeUse, BasicBlock* taken, BasicBlock* notTaken)
 6619 {
 6620     JSValueOperand value(this, nodeUse, ManualOperandSpeculation);
 6621     GPRTemporary temp(this);
 6622     JSValueRegs valueRegs = value.jsValueRegs();
 6623     GPRReg tempGPR = temp.gpr();
 6624 
 6625     JITCompiler::Jump notCell = m_jit.branchIfNotCell(valueRegs);
 6626     GPRReg cellGPR = valueRegs.payloadGPR();
 6627     DFG_TYPE_CHECK(valueRegs, nodeUse, (~SpecCellCheck) | SpecString, m_jit.branchIfNotString(cellGPR));
 6628 
 6629     branchPtr(CCallHelpers::Equal, cellGPR, TrustedImmPtr::weakPointer(m_jit.graph(), jsEmptyString(m_jit.vm())), notTaken);
 6630     jump(taken, ForceJump);
 6631 
 6632     notCell.link(&amp;m_jit);
 6633     DFG_TYPE_CHECK(
 6634         valueRegs, nodeUse, SpecCellCheck | SpecOther, m_jit.branchIfNotOther(valueRegs, tempGPR));
 6635     jump(notTaken);
 6636     noResult(m_currentNode);
 6637 }
 6638 
 6639 void SpeculativeJIT::compileConstantStoragePointer(Node* node)
 6640 {
 6641     GPRTemporary storage(this);
 6642     GPRReg storageGPR = storage.gpr();
 6643     m_jit.move(TrustedImmPtr(node-&gt;storagePointer()), storageGPR);
 6644     storageResult(storageGPR, node);
 6645 }
 6646 
 6647 void SpeculativeJIT::cageTypedArrayStorage(GPRReg storageReg)
 6648 {
 6649 #if GIGACAGE_ENABLED
 6650     if (!Gigacage::shouldBeEnabled())
 6651         return;
 6652 
 6653     if (Gigacage::canPrimitiveGigacageBeDisabled()) {
 6654         if (m_jit.vm()-&gt;primitiveGigacageEnabled().isStillValid())
 6655             m_jit.graph().watchpoints().addLazily(m_jit.vm()-&gt;primitiveGigacageEnabled());
 6656         else
 6657             return;
 6658     }
 6659 
 6660     m_jit.cage(Gigacage::Primitive, storageReg);
 6661 #else
 6662     UNUSED_PARAM(storageReg);
 6663 #endif
 6664 }
 6665 
 6666 void SpeculativeJIT::compileGetIndexedPropertyStorage(Node* node)
 6667 {
 6668     SpeculateCellOperand base(this, node-&gt;child1());
 6669     GPRReg baseReg = base.gpr();
 6670 
 6671     GPRTemporary storage(this);
 6672     GPRReg storageReg = storage.gpr();
 6673 
 6674     switch (node-&gt;arrayMode().type()) {
 6675     case Array::String:
 6676         m_jit.loadPtr(MacroAssembler::Address(baseReg, JSString::offsetOfValue()), storageReg);
 6677 
 6678         addSlowPathGenerator(
 6679             slowPathCall(
 6680                 m_jit.branchIfRopeStringImpl(storageReg),
 6681                 this, operationResolveRope, storageReg, baseReg));
 6682 
 6683         m_jit.loadPtr(MacroAssembler::Address(storageReg, StringImpl::dataOffset()), storageReg);
 6684         break;
 6685 
 6686     default:
 6687         auto typedArrayType = node-&gt;arrayMode().typedArrayType();
 6688         ASSERT_UNUSED(typedArrayType, isTypedView(typedArrayType));
 6689 
 6690         m_jit.loadPtr(JITCompiler::Address(baseReg, JSArrayBufferView::offsetOfVector()), storageReg);
 6691         cageTypedArrayStorage(storageReg);
 6692         break;
 6693     }
 6694 
 6695     storageResult(storageReg, node);
 6696 }
 6697 
 6698 void SpeculativeJIT::compileGetTypedArrayByteOffset(Node* node)
 6699 {
 6700     SpeculateCellOperand base(this, node-&gt;child1());
 6701     GPRTemporary vector(this);
 6702     GPRTemporary data(this);
 6703 
 6704     GPRReg baseGPR = base.gpr();
 6705     GPRReg vectorGPR = vector.gpr();
 6706     GPRReg dataGPR = data.gpr();
 6707     ASSERT(baseGPR != vectorGPR);
 6708     ASSERT(baseGPR != dataGPR);
 6709     ASSERT(vectorGPR != dataGPR);
 6710 
 6711     GPRReg arrayBufferGPR = dataGPR;
 6712 
 6713     JITCompiler::Jump emptyByteOffset = m_jit.branch32(
 6714         MacroAssembler::NotEqual,
 6715         MacroAssembler::Address(baseGPR, JSArrayBufferView::offsetOfMode()),
 6716         TrustedImm32(WastefulTypedArray));
 6717 
 6718     m_jit.loadPtr(MacroAssembler::Address(baseGPR, JSArrayBufferView::offsetOfVector()), vectorGPR);
 6719     JITCompiler::Jump nullVector = m_jit.branchTestPtr(JITCompiler::Zero, vectorGPR);
 6720 
 6721     m_jit.loadPtr(MacroAssembler::Address(baseGPR, JSObject::butterflyOffset()), dataGPR);
 6722     m_jit.cage(Gigacage::JSValue, dataGPR);
 6723 
 6724     cageTypedArrayStorage(vectorGPR);
 6725 
 6726     m_jit.loadPtr(MacroAssembler::Address(dataGPR, Butterfly::offsetOfArrayBuffer()), arrayBufferGPR);
 6727     // FIXME: This needs caging.
 6728     // https://bugs.webkit.org/show_bug.cgi?id=175515
 6729     m_jit.loadPtr(MacroAssembler::Address(arrayBufferGPR, ArrayBuffer::offsetOfData()), dataGPR);
 6730     m_jit.subPtr(dataGPR, vectorGPR);
 6731 
 6732     JITCompiler::Jump done = m_jit.jump();
 6733 
 6734     emptyByteOffset.link(&amp;m_jit);
 6735     m_jit.move(TrustedImmPtr(nullptr), vectorGPR);
 6736 
 6737     done.link(&amp;m_jit);
 6738     nullVector.link(&amp;m_jit);
 6739 
 6740     int32Result(vectorGPR, node);
 6741 }
 6742 
 6743 void SpeculativeJIT::compileGetByValOnDirectArguments(Node* node)
 6744 {
 6745     SpeculateCellOperand base(this, m_graph.varArgChild(node, 0));
 6746     SpeculateStrictInt32Operand property(this, m_graph.varArgChild(node, 1));
 6747     JSValueRegsTemporary result(this);
 6748     GPRTemporary scratch(this);
 6749 
 6750     GPRReg baseReg = base.gpr();
 6751     GPRReg propertyReg = property.gpr();
 6752     JSValueRegs resultRegs = result.regs();
 6753     GPRReg scratchReg = scratch.gpr();
 6754 
 6755     if (!m_compileOkay)
 6756         return;
 6757 
 6758     ASSERT(ArrayMode(Array::DirectArguments, Array::Read).alreadyChecked(m_jit.graph(), node, m_state.forNode(m_graph.varArgChild(node, 0))));
 6759 
 6760     speculationCheck(
 6761         ExoticObjectMode, JSValueSource(), 0,
 6762         m_jit.branchTestPtr(
 6763             MacroAssembler::NonZero,
 6764             MacroAssembler::Address(baseReg, DirectArguments::offsetOfMappedArguments())));
 6765 
 6766     m_jit.load32(CCallHelpers::Address(baseReg, DirectArguments::offsetOfLength()), scratchReg);
 6767     auto isOutOfBounds = m_jit.branch32(CCallHelpers::AboveOrEqual, propertyReg, scratchReg);
 6768     if (node-&gt;arrayMode().isInBounds())
 6769         speculationCheck(OutOfBounds, JSValueSource(), 0, isOutOfBounds);
 6770 
 6771     m_jit.loadValue(
 6772         MacroAssembler::BaseIndex(
 6773             baseReg, propertyReg, MacroAssembler::TimesEight, DirectArguments::storageOffset()),
 6774         resultRegs);
 6775 
 6776     if (!node-&gt;arrayMode().isInBounds()) {
 6777         addSlowPathGenerator(
 6778             slowPathCall(
 6779                 isOutOfBounds, this, operationGetByValObjectInt,
 6780                 extractResult(resultRegs), baseReg, propertyReg));
 6781     }
 6782 
 6783     jsValueResult(resultRegs, node);
 6784 }
 6785 
 6786 void SpeculativeJIT::compileGetByValOnScopedArguments(Node* node)
 6787 {
 6788     SpeculateCellOperand base(this, m_graph.varArgChild(node, 0));
 6789     SpeculateStrictInt32Operand property(this, m_graph.varArgChild(node, 1));
 6790     JSValueRegsTemporary result(this);
 6791     GPRTemporary scratch(this);
 6792     GPRTemporary scratch2(this);
 6793     GPRTemporary indexMask(this);
 6794 
 6795     GPRReg baseReg = base.gpr();
 6796     GPRReg propertyReg = property.gpr();
 6797     JSValueRegs resultRegs = result.regs();
 6798     GPRReg scratchReg = scratch.gpr();
 6799     GPRReg scratch2Reg = scratch2.gpr();
 6800     GPRReg indexMaskReg = indexMask.gpr();
 6801 
 6802     if (!m_compileOkay)
 6803         return;
 6804 
 6805     ASSERT(ArrayMode(Array::ScopedArguments, Array::Read).alreadyChecked(m_jit.graph(), node, m_state.forNode(m_graph.varArgChild(node, 0))));
 6806 
 6807     m_jit.loadPtr(
 6808         MacroAssembler::Address(baseReg, ScopedArguments::offsetOfStorage()), resultRegs.payloadGPR());
 6809     m_jit.load32(
 6810         MacroAssembler::Address(resultRegs.payloadGPR(), ScopedArguments::offsetOfTotalLengthInStorage()),
 6811         scratchReg);
 6812 
 6813     speculationCheck(
 6814         ExoticObjectMode, JSValueSource(), nullptr,
 6815         m_jit.branch32(MacroAssembler::AboveOrEqual, propertyReg, scratchReg));
 6816 
 6817     m_jit.emitPreparePreciseIndexMask32(propertyReg, scratchReg, indexMaskReg);
 6818 
 6819     m_jit.loadPtr(MacroAssembler::Address(baseReg, ScopedArguments::offsetOfTable()), scratchReg);
 6820     m_jit.load32(
 6821         MacroAssembler::Address(scratchReg, ScopedArgumentsTable::offsetOfLength()), scratch2Reg);
 6822 
 6823     MacroAssembler::Jump overflowArgument = m_jit.branch32(
 6824         MacroAssembler::AboveOrEqual, propertyReg, scratch2Reg);
 6825 
 6826     m_jit.loadPtr(MacroAssembler::Address(baseReg, ScopedArguments::offsetOfScope()), scratch2Reg);
 6827 
 6828     m_jit.loadPtr(
 6829         MacroAssembler::Address(scratchReg, ScopedArgumentsTable::offsetOfArguments()),
 6830         scratchReg);
 6831     m_jit.load32(
 6832         MacroAssembler::BaseIndex(scratchReg, propertyReg, MacroAssembler::TimesFour),
 6833         scratchReg);
 6834 
 6835     speculationCheck(
 6836         ExoticObjectMode, JSValueSource(), nullptr,
 6837         m_jit.branch32(
 6838             MacroAssembler::Equal, scratchReg, TrustedImm32(ScopeOffset::invalidOffset)));
 6839 
 6840     m_jit.loadValue(
 6841         MacroAssembler::BaseIndex(
 6842             scratch2Reg, propertyReg, MacroAssembler::TimesEight,
 6843             JSLexicalEnvironment::offsetOfVariables()),
 6844         resultRegs);
 6845 
 6846     MacroAssembler::Jump done = m_jit.jump();
 6847     overflowArgument.link(&amp;m_jit);
 6848 
 6849     m_jit.sub32(propertyReg, scratch2Reg);
 6850     m_jit.neg32(scratch2Reg);
 6851 
 6852     m_jit.loadValue(
 6853         MacroAssembler::BaseIndex(
 6854             resultRegs.payloadGPR(), scratch2Reg, MacroAssembler::TimesEight),
 6855         resultRegs);
 6856     speculationCheck(ExoticObjectMode, JSValueSource(), nullptr, m_jit.branchIfEmpty(resultRegs));
 6857 
 6858     done.link(&amp;m_jit);
 6859 
 6860     m_jit.andPtr(indexMaskReg, resultRegs.payloadGPR());
 6861 
 6862     jsValueResult(resultRegs, node);
 6863 }
 6864 
 6865 void SpeculativeJIT::compileGetScope(Node* node)
 6866 {
 6867     SpeculateCellOperand function(this, node-&gt;child1());
 6868     GPRTemporary result(this, Reuse, function);
 6869     m_jit.loadPtr(JITCompiler::Address(function.gpr(), JSFunction::offsetOfScopeChain()), result.gpr());
 6870     cellResult(result.gpr(), node);
 6871 }
 6872 
 6873 void SpeculativeJIT::compileSkipScope(Node* node)
 6874 {
 6875     SpeculateCellOperand scope(this, node-&gt;child1());
 6876     GPRTemporary result(this, Reuse, scope);
 6877     m_jit.loadPtr(JITCompiler::Address(scope.gpr(), JSScope::offsetOfNext()), result.gpr());
 6878     cellResult(result.gpr(), node);
 6879 }
 6880 
 6881 void SpeculativeJIT::compileGetGlobalObject(Node* node)
 6882 {
 6883     SpeculateCellOperand object(this, node-&gt;child1());
 6884     GPRTemporary result(this);
 6885     GPRTemporary scratch(this);
 6886     m_jit.emitLoadStructure(*m_jit.vm(), object.gpr(), result.gpr(), scratch.gpr());
 6887     m_jit.loadPtr(JITCompiler::Address(result.gpr(), Structure::globalObjectOffset()), result.gpr());
 6888     cellResult(result.gpr(), node);
 6889 }
 6890 
 6891 void SpeculativeJIT::compileGetGlobalThis(Node* node)
 6892 {
 6893     GPRTemporary result(this);
 6894     GPRReg resultGPR = result.gpr();
 6895     auto* globalObject = m_jit.graph().globalObjectFor(node-&gt;origin.semantic);
 6896     m_jit.loadPtr(globalObject-&gt;addressOfGlobalThis(), resultGPR);
 6897     cellResult(resultGPR, node);
 6898 }
 6899 
 6900 void SpeculativeJIT::compileGetArrayLength(Node* node)
 6901 {
 6902     switch (node-&gt;arrayMode().type()) {
 6903     case Array::Undecided:
 6904     case Array::Int32:
 6905     case Array::Double:
 6906     case Array::Contiguous: {
 6907         StorageOperand storage(this, node-&gt;child2());
 6908         GPRTemporary result(this, Reuse, storage);
 6909         GPRReg storageReg = storage.gpr();
 6910         GPRReg resultReg = result.gpr();
 6911         m_jit.load32(MacroAssembler::Address(storageReg, Butterfly::offsetOfPublicLength()), resultReg);
 6912 
 6913         int32Result(resultReg, node);
 6914         break;
 6915     }
 6916     case Array::ArrayStorage:
 6917     case Array::SlowPutArrayStorage: {
 6918         StorageOperand storage(this, node-&gt;child2());
 6919         GPRTemporary result(this, Reuse, storage);
 6920         GPRReg storageReg = storage.gpr();
 6921         GPRReg resultReg = result.gpr();
 6922         m_jit.load32(MacroAssembler::Address(storageReg, Butterfly::offsetOfPublicLength()), resultReg);
 6923 
 6924         speculationCheck(Uncountable, JSValueRegs(), 0, m_jit.branch32(MacroAssembler::LessThan, resultReg, MacroAssembler::TrustedImm32(0)));
 6925 
 6926         int32Result(resultReg, node);
 6927         break;
 6928     }
 6929     case Array::String: {
 6930         SpeculateCellOperand base(this, node-&gt;child1());
 6931         GPRTemporary result(this, Reuse, base);
 6932         GPRTemporary temp(this);
 6933         GPRReg baseGPR = base.gpr();
 6934         GPRReg resultGPR = result.gpr();
 6935         GPRReg tempGPR = temp.gpr();
 6936 
 6937         m_jit.loadPtr(MacroAssembler::Address(baseGPR, JSString::offsetOfValue()), tempGPR);
 6938         auto isRope = m_jit.branchIfRopeStringImpl(tempGPR);
 6939         m_jit.load32(MacroAssembler::Address(tempGPR, StringImpl::lengthMemoryOffset()), resultGPR);
 6940         auto done = m_jit.jump();
 6941 
 6942         isRope.link(&amp;m_jit);
 6943         m_jit.load32(CCallHelpers::Address(baseGPR, JSRopeString::offsetOfLength()), resultGPR);
 6944 
 6945         done.link(&amp;m_jit);
 6946         int32Result(resultGPR, node);
 6947         break;
 6948     }
 6949     case Array::DirectArguments: {
 6950         SpeculateCellOperand base(this, node-&gt;child1());
 6951         GPRTemporary result(this, Reuse, base);
 6952 
 6953         GPRReg baseReg = base.gpr();
 6954         GPRReg resultReg = result.gpr();
 6955 
 6956         if (!m_compileOkay)
 6957             return;
 6958 
 6959         ASSERT(ArrayMode(Array::DirectArguments, Array::Read).alreadyChecked(m_jit.graph(), node, m_state.forNode(node-&gt;child1())));
 6960 
 6961         speculationCheck(
 6962             ExoticObjectMode, JSValueSource(), 0,
 6963             m_jit.branchTestPtr(
 6964                 MacroAssembler::NonZero,
 6965                 MacroAssembler::Address(baseReg, DirectArguments::offsetOfMappedArguments())));
 6966 
 6967         m_jit.load32(
 6968             MacroAssembler::Address(baseReg, DirectArguments::offsetOfLength()), resultReg);
 6969 
 6970         int32Result(resultReg, node);
 6971         break;
 6972     }
 6973     case Array::ScopedArguments: {
 6974         SpeculateCellOperand base(this, node-&gt;child1());
 6975         GPRTemporary result(this);
 6976 
 6977         GPRReg baseReg = base.gpr();
 6978         GPRReg resultReg = result.gpr();
 6979 
 6980         if (!m_compileOkay)
 6981             return;
 6982 
 6983         ASSERT(ArrayMode(Array::ScopedArguments, Array::Read).alreadyChecked(m_jit.graph(), node, m_state.forNode(node-&gt;child1())));
 6984 
 6985         m_jit.loadPtr(
 6986             MacroAssembler::Address(baseReg, ScopedArguments::offsetOfStorage()), resultReg);
 6987 
 6988         speculationCheck(
 6989             ExoticObjectMode, JSValueSource(), 0,
 6990             m_jit.branchTest8(
 6991                 MacroAssembler::NonZero,
 6992                 MacroAssembler::Address(resultReg, ScopedArguments::offsetOfOverrodeThingsInStorage())));
 6993 
 6994         m_jit.load32(
 6995             MacroAssembler::Address(resultReg, ScopedArguments::offsetOfTotalLengthInStorage()), resultReg);
 6996 
 6997         int32Result(resultReg, node);
 6998         break;
 6999     }
 7000     default: {
 7001         ASSERT(node-&gt;arrayMode().isSomeTypedArrayView());
 7002         SpeculateCellOperand base(this, node-&gt;child1());
 7003         GPRTemporary result(this, Reuse, base);
 7004         GPRReg baseGPR = base.gpr();
 7005         GPRReg resultGPR = result.gpr();
 7006         m_jit.load32(MacroAssembler::Address(baseGPR, JSArrayBufferView::offsetOfLength()), resultGPR);
 7007         int32Result(resultGPR, node);
 7008         break;
 7009     } }
 7010 }
 7011 
 7012 void SpeculativeJIT::compileCheckStringIdent(Node* node)
 7013 {
 7014     SpeculateCellOperand string(this, node-&gt;child1());
 7015     GPRTemporary storage(this);
 7016 
 7017     GPRReg stringGPR = string.gpr();
 7018     GPRReg storageGPR = storage.gpr();
 7019 
 7020     speculateString(node-&gt;child1(), stringGPR);
 7021     speculateStringIdentAndLoadStorage(node-&gt;child1(), stringGPR, storageGPR);
 7022 
 7023     UniquedStringImpl* uid = node-&gt;uidOperand();
 7024     speculationCheck(
 7025         BadIdent, JSValueSource(), nullptr,
 7026         m_jit.branchPtr(JITCompiler::NotEqual, storageGPR, TrustedImmPtr(uid)));
 7027     noResult(node);
 7028 }
 7029 
 7030 template &lt;typename ClassType&gt;
 7031 void SpeculativeJIT::compileNewFunctionCommon(GPRReg resultGPR, RegisteredStructure structure, GPRReg scratch1GPR, GPRReg scratch2GPR, GPRReg scopeGPR, MacroAssembler::JumpList&amp; slowPath, size_t size, FunctionExecutable* executable)
 7032 {
 7033     auto butterfly = TrustedImmPtr(nullptr);
 7034     emitAllocateJSObjectWithKnownSize&lt;ClassType&gt;(resultGPR, TrustedImmPtr(structure), butterfly, scratch1GPR, scratch2GPR, slowPath, size);
 7035 
 7036     m_jit.storePtr(scopeGPR, JITCompiler::Address(resultGPR, JSFunction::offsetOfScopeChain()));
 7037     m_jit.storePtr(TrustedImmPtr::weakPointer(m_jit.graph(), executable), JITCompiler::Address(resultGPR, JSFunction::offsetOfExecutable()));
 7038     m_jit.storePtr(TrustedImmPtr(nullptr), JITCompiler::Address(resultGPR, JSFunction::offsetOfRareData()));
 7039 
 7040     m_jit.mutatorFence(*m_jit.vm());
 7041 }
 7042 
 7043 void SpeculativeJIT::compileNewFunction(Node* node)
 7044 {
 7045     NodeType nodeType = node-&gt;op();
 7046     ASSERT(nodeType == NewFunction || nodeType == NewGeneratorFunction || nodeType == NewAsyncFunction || nodeType == NewAsyncGeneratorFunction);
 7047 
 7048     SpeculateCellOperand scope(this, node-&gt;child1());
 7049     GPRReg scopeGPR = scope.gpr();
 7050 
 7051     FunctionExecutable* executable = node-&gt;castOperand&lt;FunctionExecutable*&gt;();
 7052 
 7053     if (executable-&gt;singletonFunction()-&gt;isStillValid()) {
 7054         GPRFlushedCallResult result(this);
 7055         GPRReg resultGPR = result.gpr();
 7056 
 7057         flushRegisters();
 7058 
 7059         if (nodeType == NewGeneratorFunction)
 7060             callOperation(operationNewGeneratorFunction, resultGPR, scopeGPR, executable);
 7061         else if (nodeType == NewAsyncFunction)
 7062             callOperation(operationNewAsyncFunction, resultGPR, scopeGPR, executable);
 7063         else if (nodeType == NewAsyncGeneratorFunction)
 7064             callOperation(operationNewAsyncGeneratorFunction, resultGPR, scopeGPR, executable);
 7065         else
 7066             callOperation(operationNewFunction, resultGPR, scopeGPR, executable);
 7067         m_jit.exceptionCheck();
 7068         cellResult(resultGPR, node);
 7069         return;
 7070     }
 7071 
 7072     RegisteredStructure structure = m_jit.graph().registerStructure(
 7073         [&amp;] () {
 7074             JSGlobalObject* globalObject = m_jit.graph().globalObjectFor(node-&gt;origin.semantic);
 7075             switch (nodeType) {
 7076             case NewGeneratorFunction:
 7077                 return globalObject-&gt;generatorFunctionStructure();
 7078             case NewAsyncFunction:
 7079                 return globalObject-&gt;asyncFunctionStructure();
 7080             case NewAsyncGeneratorFunction:
 7081                 return globalObject-&gt;asyncGeneratorFunctionStructure();
 7082             case NewFunction:
 7083                 return JSFunction::selectStructureForNewFuncExp(globalObject, node-&gt;castOperand&lt;FunctionExecutable*&gt;());
 7084             default:
 7085                 RELEASE_ASSERT_NOT_REACHED();
 7086             }
 7087         }());
 7088 
 7089     GPRTemporary result(this);
 7090     GPRTemporary scratch1(this);
 7091     GPRTemporary scratch2(this);
 7092 
 7093     GPRReg resultGPR = result.gpr();
 7094     GPRReg scratch1GPR = scratch1.gpr();
 7095     GPRReg scratch2GPR = scratch2.gpr();
 7096 
 7097     JITCompiler::JumpList slowPath;
 7098 
 7099     if (nodeType == NewFunction) {
 7100         compileNewFunctionCommon&lt;JSFunction&gt;(resultGPR, structure, scratch1GPR, scratch2GPR, scopeGPR, slowPath, JSFunction::allocationSize(0), executable);
 7101 
 7102         addSlowPathGenerator(slowPathCall(slowPath, this, operationNewFunctionWithInvalidatedReallocationWatchpoint, resultGPR, scopeGPR, executable));
 7103     }
 7104 
 7105     if (nodeType == NewGeneratorFunction) {
 7106         compileNewFunctionCommon&lt;JSGeneratorFunction&gt;(resultGPR, structure, scratch1GPR, scratch2GPR, scopeGPR, slowPath, JSGeneratorFunction::allocationSize(0), executable);
 7107 
 7108         addSlowPathGenerator(slowPathCall(slowPath, this, operationNewGeneratorFunctionWithInvalidatedReallocationWatchpoint, resultGPR, scopeGPR, executable));
 7109     }
 7110 
 7111     if (nodeType == NewAsyncFunction) {
 7112         compileNewFunctionCommon&lt;JSAsyncFunction&gt;(resultGPR, structure, scratch1GPR, scratch2GPR, scopeGPR, slowPath, JSAsyncFunction::allocationSize(0), executable);
 7113 
 7114         addSlowPathGenerator(slowPathCall(slowPath, this, operationNewAsyncFunctionWithInvalidatedReallocationWatchpoint, resultGPR, scopeGPR, executable));
 7115     }
 7116 
 7117     if (nodeType == NewAsyncGeneratorFunction) {
 7118         compileNewFunctionCommon&lt;JSAsyncGeneratorFunction&gt;(resultGPR, structure, scratch1GPR, scratch2GPR, scopeGPR, slowPath, JSAsyncGeneratorFunction::allocationSize(0), executable);
 7119 
 7120         addSlowPathGenerator(slowPathCall(slowPath, this, operationNewAsyncGeneratorFunctionWithInvalidatedReallocationWatchpoint, resultGPR, scopeGPR, executable));
 7121     }
 7122 
 7123     cellResult(resultGPR, node);
 7124 }
 7125 
 7126 void SpeculativeJIT::compileSetFunctionName(Node* node)
 7127 {
 7128     SpeculateCellOperand func(this, node-&gt;child1());
 7129     GPRReg funcGPR = func.gpr();
 7130     JSValueOperand nameValue(this, node-&gt;child2());
 7131     JSValueRegs nameValueRegs = nameValue.jsValueRegs();
 7132 
 7133     flushRegisters();
 7134     callOperation(operationSetFunctionName, funcGPR, nameValueRegs);
 7135     m_jit.exceptionCheck();
 7136 
 7137     noResult(node);
 7138 }
 7139 
 7140 void SpeculativeJIT::compileLoadVarargs(Node* node)
 7141 {
 7142     LoadVarargsData* data = node-&gt;loadVarargsData();
 7143 
 7144     JSValueRegs argumentsRegs;
 7145     {
 7146         JSValueOperand arguments(this, node-&gt;child1());
 7147         argumentsRegs = arguments.jsValueRegs();
 7148         flushRegisters();
 7149     }
 7150 
 7151     callOperation(operationSizeOfVarargs, GPRInfo::returnValueGPR, argumentsRegs, data-&gt;offset);
 7152     m_jit.exceptionCheck();
 7153 
 7154     lock(GPRInfo::returnValueGPR);
 7155     {
 7156         JSValueOperand arguments(this, node-&gt;child1());
 7157         argumentsRegs = arguments.jsValueRegs();
 7158         flushRegisters();
 7159     }
 7160     unlock(GPRInfo::returnValueGPR);
 7161 
 7162     // FIXME: There is a chance that we will call an effectful length property twice. This is safe
 7163     // from the standpoint of the VM&#39;s integrity, but it&#39;s subtly wrong from a spec compliance
 7164     // standpoint. The best solution would be one where we can exit *into* the op_call_varargs right
 7165     // past the sizing.
 7166     // https://bugs.webkit.org/show_bug.cgi?id=141448
 7167 
 7168     GPRReg argCountIncludingThisGPR =
 7169         JITCompiler::selectScratchGPR(GPRInfo::returnValueGPR, argumentsRegs);
 7170 
 7171     m_jit.add32(TrustedImm32(1), GPRInfo::returnValueGPR, argCountIncludingThisGPR);
 7172 
 7173     speculationCheck(
 7174         VarargsOverflow, JSValueSource(), Edge(), m_jit.branch32(
 7175             MacroAssembler::Above,
 7176             GPRInfo::returnValueGPR,
 7177             argCountIncludingThisGPR));
 7178 
 7179     speculationCheck(
 7180         VarargsOverflow, JSValueSource(), Edge(), m_jit.branch32(
 7181             MacroAssembler::Above,
 7182             argCountIncludingThisGPR,
 7183             TrustedImm32(data-&gt;limit)));
 7184 
 7185     m_jit.store32(argCountIncludingThisGPR, JITCompiler::payloadFor(data-&gt;machineCount));
 7186 
 7187     callOperation(operationLoadVarargs, data-&gt;machineStart.offset(), argumentsRegs, data-&gt;offset, GPRInfo::returnValueGPR, data-&gt;mandatoryMinimum);
 7188     m_jit.exceptionCheck();
 7189 
 7190     noResult(node);
 7191 }
 7192 
 7193 void SpeculativeJIT::compileForwardVarargs(Node* node)
 7194 {
 7195     LoadVarargsData* data = node-&gt;loadVarargsData();
 7196     InlineCallFrame* inlineCallFrame;
 7197     if (node-&gt;child1())
 7198         inlineCallFrame = node-&gt;child1()-&gt;origin.semantic.inlineCallFrame;
 7199     else
 7200         inlineCallFrame = node-&gt;origin.semantic.inlineCallFrame;
 7201 
 7202     GPRTemporary length(this);
 7203     JSValueRegsTemporary temp(this);
 7204     GPRReg lengthGPR = length.gpr();
 7205     JSValueRegs tempRegs = temp.regs();
 7206 
 7207     emitGetLength(inlineCallFrame, lengthGPR, /* includeThis = */ true);
 7208     if (data-&gt;offset)
 7209         m_jit.sub32(TrustedImm32(data-&gt;offset), lengthGPR);
 7210 
 7211     speculationCheck(
 7212         VarargsOverflow, JSValueSource(), Edge(), m_jit.branch32(
 7213             MacroAssembler::Above,
 7214             lengthGPR, TrustedImm32(data-&gt;limit)));
 7215 
 7216     m_jit.store32(lengthGPR, JITCompiler::payloadFor(data-&gt;machineCount));
 7217 
 7218     VirtualRegister sourceStart = JITCompiler::argumentsStart(inlineCallFrame) + data-&gt;offset;
 7219     VirtualRegister targetStart = data-&gt;machineStart;
 7220 
 7221     m_jit.sub32(TrustedImm32(1), lengthGPR);
 7222 
 7223     // First have a loop that fills in the undefined slots in case of an arity check failure.
 7224     m_jit.move(TrustedImm32(data-&gt;mandatoryMinimum), tempRegs.payloadGPR());
 7225     JITCompiler::Jump done = m_jit.branch32(JITCompiler::BelowOrEqual, tempRegs.payloadGPR(), lengthGPR);
 7226 
 7227     JITCompiler::Label loop = m_jit.label();
 7228     m_jit.sub32(TrustedImm32(1), tempRegs.payloadGPR());
 7229     m_jit.storeTrustedValue(
 7230         jsUndefined(),
 7231         JITCompiler::BaseIndex(
 7232             GPRInfo::callFrameRegister, tempRegs.payloadGPR(), JITCompiler::TimesEight,
 7233             targetStart.offset() * sizeof(EncodedJSValue)));
 7234     m_jit.branch32(JITCompiler::Above, tempRegs.payloadGPR(), lengthGPR).linkTo(loop, &amp;m_jit);
 7235     done.link(&amp;m_jit);
 7236 
 7237     // And then fill in the actual argument values.
 7238     done = m_jit.branchTest32(JITCompiler::Zero, lengthGPR);
 7239 
 7240     loop = m_jit.label();
 7241     m_jit.sub32(TrustedImm32(1), lengthGPR);
 7242     m_jit.loadValue(
 7243         JITCompiler::BaseIndex(
 7244             GPRInfo::callFrameRegister, lengthGPR, JITCompiler::TimesEight,
 7245             sourceStart.offset() * sizeof(EncodedJSValue)),
 7246         tempRegs);
 7247     m_jit.storeValue(
 7248         tempRegs,
 7249         JITCompiler::BaseIndex(
 7250             GPRInfo::callFrameRegister, lengthGPR, JITCompiler::TimesEight,
 7251             targetStart.offset() * sizeof(EncodedJSValue)));
 7252     m_jit.branchTest32(JITCompiler::NonZero, lengthGPR).linkTo(loop, &amp;m_jit);
 7253 
 7254     done.link(&amp;m_jit);
 7255 
 7256     noResult(node);
 7257 }
 7258 
 7259 void SpeculativeJIT::compileCreateActivation(Node* node)
 7260 {
 7261     SymbolTable* table = node-&gt;castOperand&lt;SymbolTable*&gt;();
 7262     RegisteredStructure structure = m_jit.graph().registerStructure(m_jit.graph().globalObjectFor(
 7263         node-&gt;origin.semantic)-&gt;activationStructure());
 7264 
 7265     SpeculateCellOperand scope(this, node-&gt;child1());
 7266     GPRReg scopeGPR = scope.gpr();
 7267     JSValue initializationValue = node-&gt;initializationValueForActivation();
 7268     ASSERT(initializationValue == jsUndefined() || initializationValue == jsTDZValue());
 7269 
 7270     if (table-&gt;singletonScope()-&gt;isStillValid()) {
 7271         GPRFlushedCallResult result(this);
 7272         GPRReg resultGPR = result.gpr();
 7273 
 7274 #if USE(JSVALUE32_64)
 7275         JSValueRegsTemporary initialization(this);
 7276         JSValueRegs initializationRegs = initialization.regs();
 7277         m_jit.moveTrustedValue(initializationValue, initializationRegs);
 7278 #endif
 7279 
 7280         flushRegisters();
 7281 
 7282 #if USE(JSVALUE64)
 7283         callOperation(operationCreateActivationDirect,
 7284             resultGPR, structure, scopeGPR, table, TrustedImm64(JSValue::encode(initializationValue)));
 7285 #else
 7286         callOperation(operationCreateActivationDirect,
 7287             resultGPR, structure, scopeGPR, table, initializationRegs);
 7288 #endif
 7289         m_jit.exceptionCheck();
 7290         cellResult(resultGPR, node);
 7291         return;
 7292     }
 7293 
 7294     GPRTemporary result(this);
 7295     GPRTemporary scratch1(this);
 7296     GPRTemporary scratch2(this);
 7297     GPRReg resultGPR = result.gpr();
 7298     GPRReg scratch1GPR = scratch1.gpr();
 7299     GPRReg scratch2GPR = scratch2.gpr();
 7300 
 7301 #if USE(JSVALUE32_64)
 7302     JSValueRegsTemporary initialization(this);
 7303     JSValueRegs initializationRegs = initialization.regs();
 7304     m_jit.moveTrustedValue(initializationValue, initializationRegs);
 7305 #endif
 7306 
 7307     JITCompiler::JumpList slowPath;
 7308     auto butterfly = TrustedImmPtr(nullptr);
 7309     emitAllocateJSObjectWithKnownSize&lt;JSLexicalEnvironment&gt;(
 7310         resultGPR, TrustedImmPtr(structure), butterfly, scratch1GPR, scratch2GPR,
 7311         slowPath, JSLexicalEnvironment::allocationSize(table));
 7312 
 7313     // Don&#39;t need a memory barriers since we just fast-created the activation, so the
 7314     // activation must be young.
 7315     m_jit.storePtr(scopeGPR, JITCompiler::Address(resultGPR, JSScope::offsetOfNext()));
 7316     m_jit.storePtr(
 7317         TrustedImmPtr(node-&gt;cellOperand()),
 7318         JITCompiler::Address(resultGPR, JSLexicalEnvironment::offsetOfSymbolTable()));
 7319 
 7320     // Must initialize all members to undefined or the TDZ empty value.
 7321     for (unsigned i = 0; i &lt; table-&gt;scopeSize(); ++i) {
 7322         m_jit.storeTrustedValue(
 7323             initializationValue,
 7324             JITCompiler::Address(
 7325                 resultGPR, JSLexicalEnvironment::offsetOfVariable(ScopeOffset(i))));
 7326     }
 7327 
 7328     m_jit.mutatorFence(*m_jit.vm());
 7329 
 7330 #if USE(JSVALUE64)
 7331     addSlowPathGenerator(
 7332         slowPathCall(
 7333             slowPath, this, operationCreateActivationDirect, resultGPR, structure, scopeGPR, table, TrustedImm64(JSValue::encode(initializationValue))));
 7334 #else
 7335     addSlowPathGenerator(
 7336         slowPathCall(
 7337             slowPath, this, operationCreateActivationDirect, resultGPR, structure, scopeGPR, table, initializationRegs));
 7338 #endif
 7339 
 7340     cellResult(resultGPR, node);
 7341 }
 7342 
 7343 void SpeculativeJIT::compileCreateDirectArguments(Node* node)
 7344 {
 7345     // FIXME: A more effective way of dealing with the argument count and callee is to have
 7346     // them be explicit arguments to this node.
 7347     // https://bugs.webkit.org/show_bug.cgi?id=142207
 7348 
 7349     GPRTemporary result(this);
 7350     GPRTemporary scratch1(this);
 7351     GPRTemporary scratch2(this);
 7352     GPRTemporary length;
 7353     GPRReg resultGPR = result.gpr();
 7354     GPRReg scratch1GPR = scratch1.gpr();
 7355     GPRReg scratch2GPR = scratch2.gpr();
 7356     GPRReg lengthGPR = InvalidGPRReg;
 7357     JSValueRegs valueRegs = JSValueRegs::withTwoAvailableRegs(scratch1GPR, scratch2GPR);
 7358 
 7359     unsigned minCapacity = m_jit.graph().baselineCodeBlockFor(node-&gt;origin.semantic)-&gt;numParameters() - 1;
 7360 
 7361     unsigned knownLength;
 7362     bool lengthIsKnown; // if false, lengthGPR will have the length.
 7363     if (node-&gt;origin.semantic.inlineCallFrame
 7364         &amp;&amp; !node-&gt;origin.semantic.inlineCallFrame-&gt;isVarargs()) {
 7365         knownLength = node-&gt;origin.semantic.inlineCallFrame-&gt;argumentCountIncludingThis - 1;
 7366         lengthIsKnown = true;
 7367     } else {
 7368         knownLength = UINT_MAX;
 7369         lengthIsKnown = false;
 7370 
 7371         GPRTemporary realLength(this);
 7372         length.adopt(realLength);
 7373         lengthGPR = length.gpr();
 7374 
 7375         VirtualRegister argumentCountRegister = m_jit.argumentCount(node-&gt;origin.semantic);
 7376         m_jit.load32(JITCompiler::payloadFor(argumentCountRegister), lengthGPR);
 7377         m_jit.sub32(TrustedImm32(1), lengthGPR);
 7378     }
 7379 
 7380     RegisteredStructure structure =
 7381         m_jit.graph().registerStructure(m_jit.graph().globalObjectFor(node-&gt;origin.semantic)-&gt;directArgumentsStructure());
 7382 
 7383     // Use a different strategy for allocating the object depending on whether we know its
 7384     // size statically.
 7385     JITCompiler::JumpList slowPath;
 7386     if (lengthIsKnown) {
 7387         auto butterfly = TrustedImmPtr(nullptr);
 7388         emitAllocateJSObjectWithKnownSize&lt;DirectArguments&gt;(
 7389             resultGPR, TrustedImmPtr(structure), butterfly, scratch1GPR, scratch2GPR,
 7390             slowPath, DirectArguments::allocationSize(std::max(knownLength, minCapacity)));
 7391 
 7392         m_jit.store32(
 7393             TrustedImm32(knownLength),
 7394             JITCompiler::Address(resultGPR, DirectArguments::offsetOfLength()));
 7395     } else {
 7396         JITCompiler::Jump tooFewArguments;
 7397         if (minCapacity) {
 7398             tooFewArguments =
 7399                 m_jit.branch32(JITCompiler::Below, lengthGPR, TrustedImm32(minCapacity));
 7400         }
 7401         m_jit.lshift32(lengthGPR, TrustedImm32(3), scratch1GPR);
 7402         m_jit.add32(TrustedImm32(DirectArguments::storageOffset()), scratch1GPR);
 7403         if (minCapacity) {
 7404             JITCompiler::Jump done = m_jit.jump();
 7405             tooFewArguments.link(&amp;m_jit);
 7406             m_jit.move(TrustedImm32(DirectArguments::allocationSize(minCapacity)), scratch1GPR);
 7407             done.link(&amp;m_jit);
 7408         }
 7409 
 7410         emitAllocateVariableSizedJSObject&lt;DirectArguments&gt;(
 7411             resultGPR, TrustedImmPtr(structure), scratch1GPR, scratch1GPR, scratch2GPR,
 7412             slowPath);
 7413 
 7414         m_jit.store32(
 7415             lengthGPR, JITCompiler::Address(resultGPR, DirectArguments::offsetOfLength()));
 7416     }
 7417 
 7418     m_jit.store32(
 7419         TrustedImm32(minCapacity),
 7420         JITCompiler::Address(resultGPR, DirectArguments::offsetOfMinCapacity()));
 7421 
 7422     m_jit.storePtr(
 7423         TrustedImmPtr(nullptr), JITCompiler::Address(resultGPR, DirectArguments::offsetOfMappedArguments()));
 7424 
 7425     m_jit.storePtr(
 7426         TrustedImmPtr(nullptr), JITCompiler::Address(resultGPR, DirectArguments::offsetOfModifiedArgumentsDescriptor()));
 7427 
 7428     if (lengthIsKnown) {
 7429         addSlowPathGenerator(
 7430             slowPathCall(
 7431                 slowPath, this, operationCreateDirectArguments, resultGPR, structure,
 7432                 knownLength, minCapacity));
 7433     } else {
 7434         auto generator = std::make_unique&lt;CallCreateDirectArgumentsSlowPathGenerator&gt;(
 7435             slowPath, this, resultGPR, structure, lengthGPR, minCapacity);
 7436         addSlowPathGenerator(WTFMove(generator));
 7437     }
 7438 
 7439     if (node-&gt;origin.semantic.inlineCallFrame) {
 7440         if (node-&gt;origin.semantic.inlineCallFrame-&gt;isClosureCall) {
 7441             m_jit.loadPtr(
 7442                 JITCompiler::addressFor(
 7443                     node-&gt;origin.semantic.inlineCallFrame-&gt;calleeRecovery.virtualRegister()),
 7444                 scratch1GPR);
 7445         } else {
 7446             m_jit.move(
 7447                 TrustedImmPtr::weakPointer(
 7448                     m_jit.graph(), node-&gt;origin.semantic.inlineCallFrame-&gt;calleeRecovery.constant().asCell()),
 7449                 scratch1GPR);
 7450         }
 7451     } else
 7452         m_jit.loadPtr(JITCompiler::addressFor(CallFrameSlot::callee), scratch1GPR);
 7453 
 7454     // Don&#39;t need a memory barriers since we just fast-created the activation, so the
 7455     // activation must be young.
 7456     m_jit.storePtr(
 7457         scratch1GPR, JITCompiler::Address(resultGPR, DirectArguments::offsetOfCallee()));
 7458 
 7459     VirtualRegister start = m_jit.argumentsStart(node-&gt;origin.semantic);
 7460     if (lengthIsKnown) {
 7461         for (unsigned i = 0; i &lt; std::max(knownLength, minCapacity); ++i) {
 7462             m_jit.loadValue(JITCompiler::addressFor(start + i), valueRegs);
 7463             m_jit.storeValue(
 7464                 valueRegs, JITCompiler::Address(resultGPR, DirectArguments::offsetOfSlot(i)));
 7465         }
 7466     } else {
 7467         JITCompiler::Jump done;
 7468         if (minCapacity) {
 7469             JITCompiler::Jump startLoop = m_jit.branch32(
 7470                 JITCompiler::AboveOrEqual, lengthGPR, TrustedImm32(minCapacity));
 7471             m_jit.move(TrustedImm32(minCapacity), lengthGPR);
 7472             startLoop.link(&amp;m_jit);
 7473         } else
 7474             done = m_jit.branchTest32(MacroAssembler::Zero, lengthGPR);
 7475         JITCompiler::Label loop = m_jit.label();
 7476         m_jit.sub32(TrustedImm32(1), lengthGPR);
 7477         m_jit.loadValue(
 7478             JITCompiler::BaseIndex(
 7479                 GPRInfo::callFrameRegister, lengthGPR, JITCompiler::TimesEight,
 7480                 start.offset() * static_cast&lt;int&gt;(sizeof(Register))),
 7481             valueRegs);
 7482         m_jit.storeValue(
 7483             valueRegs,
 7484             JITCompiler::BaseIndex(
 7485                 resultGPR, lengthGPR, JITCompiler::TimesEight,
 7486                 DirectArguments::storageOffset()));
 7487         m_jit.branchTest32(MacroAssembler::NonZero, lengthGPR).linkTo(loop, &amp;m_jit);
 7488         if (done.isSet())
 7489             done.link(&amp;m_jit);
 7490     }
 7491 
 7492     m_jit.mutatorFence(*m_jit.vm());
 7493 
 7494     cellResult(resultGPR, node);
 7495 }
 7496 
 7497 void SpeculativeJIT::compileGetFromArguments(Node* node)
 7498 {
 7499     SpeculateCellOperand arguments(this, node-&gt;child1());
 7500     JSValueRegsTemporary result(this);
 7501 
 7502     GPRReg argumentsGPR = arguments.gpr();
 7503     JSValueRegs resultRegs = result.regs();
 7504 
 7505     m_jit.loadValue(JITCompiler::Address(argumentsGPR, DirectArguments::offsetOfSlot(node-&gt;capturedArgumentsOffset().offset())), resultRegs);
 7506     jsValueResult(resultRegs, node);
 7507 }
 7508 
 7509 void SpeculativeJIT::compilePutToArguments(Node* node)
 7510 {
 7511     SpeculateCellOperand arguments(this, node-&gt;child1());
 7512     JSValueOperand value(this, node-&gt;child2());
 7513 
 7514     GPRReg argumentsGPR = arguments.gpr();
 7515     JSValueRegs valueRegs = value.jsValueRegs();
 7516 
 7517     m_jit.storeValue(valueRegs, JITCompiler::Address(argumentsGPR, DirectArguments::offsetOfSlot(node-&gt;capturedArgumentsOffset().offset())));
 7518     noResult(node);
 7519 }
 7520 
 7521 void SpeculativeJIT::compileGetArgument(Node* node)
 7522 {
 7523     GPRTemporary argumentCount(this);
 7524     JSValueRegsTemporary result(this);
 7525     GPRReg argumentCountGPR = argumentCount.gpr();
 7526     JSValueRegs resultRegs = result.regs();
 7527     m_jit.load32(CCallHelpers::payloadFor(m_jit.argumentCount(node-&gt;origin.semantic)), argumentCountGPR);
 7528     auto argumentOutOfBounds = m_jit.branch32(CCallHelpers::LessThanOrEqual, argumentCountGPR, CCallHelpers::TrustedImm32(node-&gt;argumentIndex()));
 7529     m_jit.loadValue(CCallHelpers::addressFor(CCallHelpers::argumentsStart(node-&gt;origin.semantic) + node-&gt;argumentIndex() - 1), resultRegs);
 7530     auto done = m_jit.jump();
 7531 
 7532     argumentOutOfBounds.link(&amp;m_jit);
 7533     m_jit.moveValue(jsUndefined(), resultRegs);
 7534 
 7535     done.link(&amp;m_jit);
 7536     jsValueResult(resultRegs, node);
 7537 }
 7538 
 7539 void SpeculativeJIT::compileCreateScopedArguments(Node* node)
 7540 {
 7541     SpeculateCellOperand scope(this, node-&gt;child1());
 7542     GPRReg scopeGPR = scope.gpr();
 7543 
 7544     GPRFlushedCallResult result(this);
 7545     GPRReg resultGPR = result.gpr();
 7546     flushRegisters();
 7547 
 7548     // We set up the arguments ourselves, because we have the whole register file and we can
 7549     // set them up directly into the argument registers. This also means that we don&#39;t have to
 7550     // invent a four-argument-register shuffle.
 7551 
 7552     // Arguments: 0:exec, 1:structure, 2:start, 3:length, 4:callee, 5:scope
 7553 
 7554     // Do the scopeGPR first, since it might alias an argument register.
 7555     m_jit.setupArgument(5, [&amp;] (GPRReg destGPR) { m_jit.move(scopeGPR, destGPR); });
 7556 
 7557     // These other things could be done in any order.
 7558     m_jit.setupArgument(4, [&amp;] (GPRReg destGPR) { emitGetCallee(node-&gt;origin.semantic, destGPR); });
 7559     m_jit.setupArgument(3, [&amp;] (GPRReg destGPR) { emitGetLength(node-&gt;origin.semantic, destGPR); });
 7560     m_jit.setupArgument(2, [&amp;] (GPRReg destGPR) { emitGetArgumentStart(node-&gt;origin.semantic, destGPR); });
 7561     m_jit.setupArgument(
 7562         1, [&amp;] (GPRReg destGPR) {
 7563             m_jit.move(
 7564                 TrustedImmPtr::weakPointer(m_jit.graph(), m_jit.globalObjectFor(node-&gt;origin.semantic)-&gt;scopedArgumentsStructure()),
 7565                 destGPR);
 7566         });
 7567     m_jit.setupArgument(0, [&amp;] (GPRReg destGPR) { m_jit.move(GPRInfo::callFrameRegister, destGPR); });
 7568 
 7569     appendCallSetResult(operationCreateScopedArguments, resultGPR);
 7570     m_jit.exceptionCheck();
 7571 
 7572     cellResult(resultGPR, node);
 7573 }
 7574 
 7575 void SpeculativeJIT::compileCreateClonedArguments(Node* node)
 7576 {
 7577     GPRFlushedCallResult result(this);
 7578     GPRReg resultGPR = result.gpr();
 7579     flushRegisters();
 7580 
 7581     // We set up the arguments ourselves, because we have the whole register file and we can
 7582     // set them up directly into the argument registers.
 7583 
 7584     // Arguments: 0:exec, 1:structure, 2:start, 3:length, 4:callee
 7585     m_jit.setupArgument(4, [&amp;] (GPRReg destGPR) { emitGetCallee(node-&gt;origin.semantic, destGPR); });
 7586     m_jit.setupArgument(3, [&amp;] (GPRReg destGPR) { emitGetLength(node-&gt;origin.semantic, destGPR); });
 7587     m_jit.setupArgument(2, [&amp;] (GPRReg destGPR) { emitGetArgumentStart(node-&gt;origin.semantic, destGPR); });
 7588     m_jit.setupArgument(
 7589         1, [&amp;] (GPRReg destGPR) {
 7590             m_jit.move(
 7591                 TrustedImmPtr::weakPointer(
 7592                     m_jit.graph(), m_jit.globalObjectFor(node-&gt;origin.semantic)-&gt;clonedArgumentsStructure()),
 7593                 destGPR);
 7594         });
 7595     m_jit.setupArgument(0, [&amp;] (GPRReg destGPR) { m_jit.move(GPRInfo::callFrameRegister, destGPR); });
 7596 
 7597     appendCallSetResult(operationCreateClonedArguments, resultGPR);
 7598     m_jit.exceptionCheck();
 7599 
 7600     cellResult(resultGPR, node);
 7601 }
 7602 
 7603 void SpeculativeJIT::compileCreateRest(Node* node)
 7604 {
 7605     ASSERT(node-&gt;op() == CreateRest);
 7606 
 7607 #if !CPU(X86)
 7608     if (m_jit.graph().isWatchingHavingABadTimeWatchpoint(node)) {
 7609         SpeculateStrictInt32Operand arrayLength(this, node-&gt;child1());
 7610         GPRTemporary arrayResult(this);
 7611 
 7612         GPRReg arrayLengthGPR = arrayLength.gpr();
 7613         GPRReg arrayResultGPR = arrayResult.gpr();
 7614 
 7615         // We can tell compileAllocateNewArrayWithSize() that it does not need to check
 7616         // for large arrays and use ArrayStorage structure because arrayLength here will
 7617         // always be bounded by stack size. Realistically, we won&#39;t be able to push enough
 7618         // arguments to have arrayLength exceed MIN_ARRAY_STORAGE_CONSTRUCTION_LENGTH.
 7619         bool shouldAllowForArrayStorageStructureForLargeArrays = false;
 7620         ASSERT(m_jit.graph().globalObjectFor(node-&gt;origin.semantic)-&gt;restParameterStructure()-&gt;indexingMode() == ArrayWithContiguous || m_jit.graph().globalObjectFor(node-&gt;origin.semantic)-&gt;isHavingABadTime());
 7621         compileAllocateNewArrayWithSize(m_jit.graph().globalObjectFor(node-&gt;origin.semantic), arrayResultGPR, arrayLengthGPR, ArrayWithContiguous, shouldAllowForArrayStorageStructureForLargeArrays);
 7622 
 7623         GPRTemporary argumentsStart(this);
 7624         GPRReg argumentsStartGPR = argumentsStart.gpr();
 7625 
 7626         emitGetArgumentStart(node-&gt;origin.semantic, argumentsStartGPR);
 7627 
 7628         GPRTemporary butterfly(this);
 7629         GPRTemporary currentLength(this);
 7630         JSValueRegsTemporary value(this);
 7631 
 7632         JSValueRegs valueRegs = value.regs();
 7633         GPRReg currentLengthGPR = currentLength.gpr();
 7634         GPRReg butterflyGPR = butterfly.gpr();
 7635 
 7636         m_jit.loadPtr(MacroAssembler::Address(arrayResultGPR, JSObject::butterflyOffset()), butterflyGPR);
 7637 
 7638         CCallHelpers::Jump skipLoop = m_jit.branch32(MacroAssembler::Equal, arrayLengthGPR, TrustedImm32(0));
 7639         m_jit.zeroExtend32ToPtr(arrayLengthGPR, currentLengthGPR);
 7640         m_jit.addPtr(Imm32(sizeof(Register) * node-&gt;numberOfArgumentsToSkip()), argumentsStartGPR);
 7641 
 7642         auto loop = m_jit.label();
 7643         m_jit.sub32(TrustedImm32(1), currentLengthGPR);
 7644         m_jit.loadValue(JITCompiler::BaseIndex(argumentsStartGPR, currentLengthGPR, MacroAssembler::TimesEight), valueRegs);
 7645         m_jit.storeValue(valueRegs, MacroAssembler::BaseIndex(butterflyGPR, currentLengthGPR, MacroAssembler::TimesEight));
 7646         m_jit.branch32(MacroAssembler::NotEqual, currentLengthGPR, TrustedImm32(0)).linkTo(loop, &amp;m_jit);
 7647 
 7648         skipLoop.link(&amp;m_jit);
 7649         cellResult(arrayResultGPR, node);
 7650         return;
 7651     }
 7652 #endif // !CPU(X86)
 7653 
 7654     SpeculateStrictInt32Operand arrayLength(this, node-&gt;child1());
 7655     GPRTemporary argumentsStart(this);
 7656     GPRTemporary numberOfArgumentsToSkip(this);
 7657 
 7658     GPRReg arrayLengthGPR = arrayLength.gpr();
 7659     GPRReg argumentsStartGPR = argumentsStart.gpr();
 7660 
 7661     emitGetArgumentStart(node-&gt;origin.semantic, argumentsStartGPR);
 7662 
 7663     flushRegisters();
 7664 
 7665     GPRFlushedCallResult result(this);
 7666     GPRReg resultGPR = result.gpr();
 7667     callOperation(operationCreateRest, resultGPR, argumentsStartGPR, Imm32(node-&gt;numberOfArgumentsToSkip()), arrayLengthGPR);
 7668     m_jit.exceptionCheck();
 7669 
 7670     cellResult(resultGPR, node);
 7671 }
 7672 
 7673 void SpeculativeJIT::compileSpread(Node* node)
 7674 {
 7675     ASSERT(node-&gt;op() == Spread);
 7676 
 7677     SpeculateCellOperand operand(this, node-&gt;child1());
 7678     GPRReg argument = operand.gpr();
 7679 
 7680     if (node-&gt;child1().useKind() == ArrayUse)
 7681         speculateArray(node-&gt;child1(), argument);
 7682 
 7683     if (m_jit.graph().canDoFastSpread(node, m_state.forNode(node-&gt;child1()))) {
 7684 #if USE(JSVALUE64)
 7685         GPRTemporary result(this);
 7686         GPRTemporary scratch1(this);
 7687         GPRTemporary scratch2(this);
 7688         GPRTemporary length(this);
 7689         FPRTemporary doubleRegister(this);
 7690 
 7691         GPRReg resultGPR = result.gpr();
 7692         GPRReg scratch1GPR = scratch1.gpr();
 7693         GPRReg scratch2GPR = scratch2.gpr();
 7694         GPRReg lengthGPR = length.gpr();
 7695         FPRReg doubleFPR = doubleRegister.fpr();
 7696 
 7697         MacroAssembler::JumpList slowPath;
 7698 
 7699         m_jit.load8(MacroAssembler::Address(argument, JSCell::indexingTypeAndMiscOffset()), scratch1GPR);
 7700         m_jit.and32(TrustedImm32(IndexingShapeMask), scratch1GPR);
 7701         m_jit.sub32(TrustedImm32(Int32Shape), scratch1GPR);
 7702 
 7703         slowPath.append(m_jit.branch32(MacroAssembler::Above, scratch1GPR, TrustedImm32(ContiguousShape - Int32Shape)));
 7704 
 7705         m_jit.loadPtr(MacroAssembler::Address(argument, JSObject::butterflyOffset()), lengthGPR);
 7706         m_jit.load32(MacroAssembler::Address(lengthGPR, Butterfly::offsetOfPublicLength()), lengthGPR);
 7707         static_assert(sizeof(JSValue) == 8 &amp;&amp; 1 &lt;&lt; 3 == 8, &quot;This is strongly assumed in the code below.&quot;);
 7708         m_jit.move(lengthGPR, scratch1GPR);
 7709         m_jit.lshift32(TrustedImm32(3), scratch1GPR);
 7710         m_jit.add32(TrustedImm32(JSFixedArray::offsetOfData()), scratch1GPR);
 7711 
 7712         m_jit.emitAllocateVariableSizedCell&lt;JSFixedArray&gt;(*m_jit.vm(), resultGPR, TrustedImmPtr(m_jit.graph().registerStructure(m_jit.graph().m_vm.fixedArrayStructure.get())), scratch1GPR, scratch1GPR, scratch2GPR, slowPath);
 7713         m_jit.store32(lengthGPR, MacroAssembler::Address(resultGPR, JSFixedArray::offsetOfSize()));
 7714 
 7715         m_jit.loadPtr(MacroAssembler::Address(argument, JSObject::butterflyOffset()), scratch1GPR);
 7716 
 7717         MacroAssembler::JumpList done;
 7718 
 7719         m_jit.load8(MacroAssembler::Address(argument, JSCell::indexingTypeAndMiscOffset()), scratch2GPR);
 7720         m_jit.and32(TrustedImm32(IndexingShapeMask), scratch2GPR);
 7721         auto isDoubleArray = m_jit.branch32(MacroAssembler::Equal, scratch2GPR, TrustedImm32(DoubleShape));
 7722 
 7723         {
 7724             done.append(m_jit.branchTest32(MacroAssembler::Zero, lengthGPR));
 7725             auto loopStart = m_jit.label();
 7726             m_jit.sub32(TrustedImm32(1), lengthGPR);
 7727             m_jit.load64(MacroAssembler::BaseIndex(scratch1GPR, lengthGPR, MacroAssembler::TimesEight), scratch2GPR);
 7728             auto notEmpty = m_jit.branchIfNotEmpty(scratch2GPR);
 7729             m_jit.move(TrustedImm64(JSValue::encode(jsUndefined())), scratch2GPR);
 7730             notEmpty.link(&amp;m_jit);
 7731             m_jit.store64(scratch2GPR, MacroAssembler::BaseIndex(resultGPR, lengthGPR, MacroAssembler::TimesEight, JSFixedArray::offsetOfData()));
 7732             m_jit.branchTest32(MacroAssembler::NonZero, lengthGPR).linkTo(loopStart, &amp;m_jit);
 7733             done.append(m_jit.jump());
 7734         }
 7735 
 7736         isDoubleArray.link(&amp;m_jit);
 7737         {
 7738             done.append(m_jit.branchTest32(MacroAssembler::Zero, lengthGPR));
 7739             auto loopStart = m_jit.label();
 7740             m_jit.sub32(TrustedImm32(1), lengthGPR);
 7741             m_jit.loadDouble(MacroAssembler::BaseIndex(scratch1GPR, lengthGPR, MacroAssembler::TimesEight), doubleFPR);
 7742             auto notEmpty = m_jit.branchIfNotNaN(doubleFPR);
 7743             m_jit.move(TrustedImm64(JSValue::encode(jsUndefined())), scratch2GPR);
 7744             auto doStore = m_jit.jump();
 7745             notEmpty.link(&amp;m_jit);
 7746             m_jit.boxDouble(doubleFPR, scratch2GPR);
 7747             doStore.link(&amp;m_jit);
 7748             m_jit.store64(scratch2GPR, MacroAssembler::BaseIndex(resultGPR, lengthGPR, MacroAssembler::TimesEight, JSFixedArray::offsetOfData()));
 7749             m_jit.branchTest32(MacroAssembler::NonZero, lengthGPR).linkTo(loopStart, &amp;m_jit);
 7750             done.append(m_jit.jump());
 7751         }
 7752 
 7753         m_jit.mutatorFence(*m_jit.vm());
 7754 
 7755         slowPath.link(&amp;m_jit);
 7756         addSlowPathGenerator(slowPathCall(m_jit.jump(), this, operationSpreadFastArray, resultGPR, argument));
 7757 
 7758         done.link(&amp;m_jit);
 7759         cellResult(resultGPR, node);
 7760 #else
 7761         flushRegisters();
 7762 
 7763         GPRFlushedCallResult result(this);
 7764         GPRReg resultGPR = result.gpr();
 7765         callOperation(operationSpreadFastArray, resultGPR, argument);
 7766         m_jit.exceptionCheck();
 7767         cellResult(resultGPR, node);
 7768 #endif // USE(JSVALUE64)
 7769     } else {
 7770         flushRegisters();
 7771 
 7772         GPRFlushedCallResult result(this);
 7773         GPRReg resultGPR = result.gpr();
 7774         callOperation(operationSpreadGeneric, resultGPR, argument);
 7775         m_jit.exceptionCheck();
 7776         cellResult(resultGPR, node);
 7777     }
 7778 }
 7779 
 7780 void SpeculativeJIT::compileNewArray(Node* node)
 7781 {
 7782     JSGlobalObject* globalObject = m_jit.graph().globalObjectFor(node-&gt;origin.semantic);
 7783     if (!globalObject-&gt;isHavingABadTime() &amp;&amp; !hasAnyArrayStorage(node-&gt;indexingType())) {
 7784         RegisteredStructure structure = m_jit.graph().registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(node-&gt;indexingType()));
 7785         DFG_ASSERT(m_jit.graph(), node, structure-&gt;indexingType() == node-&gt;indexingType(), structure-&gt;indexingType(), node-&gt;indexingType());
 7786         ASSERT(
 7787             hasUndecided(structure-&gt;indexingType())
 7788             || hasInt32(structure-&gt;indexingType())
 7789             || hasDouble(structure-&gt;indexingType())
 7790             || hasContiguous(structure-&gt;indexingType()));
 7791 
 7792         unsigned numElements = node-&gt;numChildren();
 7793         unsigned vectorLengthHint = node-&gt;vectorLengthHint();
 7794         ASSERT(vectorLengthHint &gt;= numElements);
 7795 
 7796         GPRTemporary result(this);
 7797         GPRTemporary storage(this);
 7798 
 7799         GPRReg resultGPR = result.gpr();
 7800         GPRReg storageGPR = storage.gpr();
 7801 
 7802         emitAllocateRawObject(resultGPR, structure, storageGPR, numElements, vectorLengthHint);
 7803 
 7804         // At this point, one way or another, resultGPR and storageGPR have pointers to
 7805         // the JSArray and the Butterfly, respectively.
 7806 
 7807         ASSERT(!hasUndecided(structure-&gt;indexingType()) || !node-&gt;numChildren());
 7808 
 7809         for (unsigned operandIdx = 0; operandIdx &lt; node-&gt;numChildren(); ++operandIdx) {
 7810             Edge use = m_jit.graph().m_varArgChildren[node-&gt;firstChild() + operandIdx];
 7811             switch (node-&gt;indexingType()) {
 7812             case ALL_BLANK_INDEXING_TYPES:
 7813             case ALL_UNDECIDED_INDEXING_TYPES:
 7814                 CRASH();
 7815                 break;
 7816             case ALL_DOUBLE_INDEXING_TYPES: {
 7817                 SpeculateDoubleOperand operand(this, use);
 7818                 FPRReg opFPR = operand.fpr();
 7819                 DFG_TYPE_CHECK(
 7820                     JSValueRegs(), use, SpecDoubleReal,
 7821                     m_jit.branchIfNaN(opFPR));
 7822                 m_jit.storeDouble(opFPR, MacroAssembler::Address(storageGPR, sizeof(double) * operandIdx));
 7823                 break;
 7824             }
 7825             case ALL_INT32_INDEXING_TYPES:
 7826             case ALL_CONTIGUOUS_INDEXING_TYPES: {
 7827                 JSValueOperand operand(this, use, ManualOperandSpeculation);
 7828                 JSValueRegs operandRegs = operand.jsValueRegs();
 7829                 if (hasInt32(node-&gt;indexingType())) {
 7830                     DFG_TYPE_CHECK(
 7831                         operandRegs, use, SpecInt32Only,
 7832                         m_jit.branchIfNotInt32(operandRegs));
 7833                 }
 7834                 m_jit.storeValue(operandRegs, MacroAssembler::Address(storageGPR, sizeof(JSValue) * operandIdx));
 7835                 break;
 7836             }
 7837             default:
 7838                 CRASH();
 7839                 break;
 7840             }
 7841         }
 7842 
 7843         // Yuck, we should *really* have a way of also returning the storageGPR. But
 7844         // that&#39;s the least of what&#39;s wrong with this code. We really shouldn&#39;t be
 7845         // allocating the array after having computed - and probably spilled to the
 7846         // stack - all of the things that will go into the array. The solution to that
 7847         // bigger problem will also likely fix the redundancy in reloading the storage
 7848         // pointer that we currently have.
 7849 
 7850         cellResult(resultGPR, node);
 7851         return;
 7852     }
 7853 
 7854     if (!node-&gt;numChildren()) {
 7855         flushRegisters();
 7856         GPRFlushedCallResult result(this);
 7857         callOperation(operationNewEmptyArray, result.gpr(), m_jit.graph().registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(node-&gt;indexingType())));
 7858         m_jit.exceptionCheck();
 7859         cellResult(result.gpr(), node);
 7860         return;
 7861     }
 7862 
 7863     size_t scratchSize = sizeof(EncodedJSValue) * node-&gt;numChildren();
 7864     ScratchBuffer* scratchBuffer = m_jit.vm()-&gt;scratchBufferForSize(scratchSize);
 7865     EncodedJSValue* buffer = scratchBuffer ? static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer()) : nullptr;
 7866 
 7867     for (unsigned operandIdx = 0; operandIdx &lt; node-&gt;numChildren(); ++operandIdx) {
 7868         // Need to perform the speculations that this node promises to perform. If we&#39;re
 7869         // emitting code here and the indexing type is not array storage then there is
 7870         // probably something hilarious going on and we&#39;re already failing at all the
 7871         // things, but at least we&#39;re going to be sound.
 7872         Edge use = m_jit.graph().m_varArgChildren[node-&gt;firstChild() + operandIdx];
 7873         switch (node-&gt;indexingType()) {
 7874         case ALL_BLANK_INDEXING_TYPES:
 7875         case ALL_UNDECIDED_INDEXING_TYPES:
 7876             CRASH();
 7877             break;
 7878         case ALL_DOUBLE_INDEXING_TYPES: {
 7879             SpeculateDoubleOperand operand(this, use);
 7880             FPRReg opFPR = operand.fpr();
 7881             DFG_TYPE_CHECK(
 7882                 JSValueRegs(), use, SpecDoubleReal,
 7883                 m_jit.branchIfNaN(opFPR));
 7884 #if USE(JSVALUE64)
 7885             JSValueRegsTemporary scratch(this);
 7886             JSValueRegs scratchRegs = scratch.regs();
 7887             m_jit.boxDouble(opFPR, scratchRegs);
 7888             m_jit.storeValue(scratchRegs, buffer + operandIdx);
 7889 #else
 7890             m_jit.storeDouble(opFPR, TrustedImmPtr(buffer + operandIdx));
 7891 #endif
 7892             operand.use();
 7893             break;
 7894         }
 7895         case ALL_INT32_INDEXING_TYPES:
 7896         case ALL_CONTIGUOUS_INDEXING_TYPES:
 7897         case ALL_ARRAY_STORAGE_INDEXING_TYPES: {
 7898             JSValueOperand operand(this, use, ManualOperandSpeculation);
 7899             JSValueRegs operandRegs = operand.jsValueRegs();
 7900             if (hasInt32(node-&gt;indexingType())) {
 7901                 DFG_TYPE_CHECK(
 7902                     operandRegs, use, SpecInt32Only,
 7903                     m_jit.branchIfNotInt32(operandRegs));
 7904             }
 7905             m_jit.storeValue(operandRegs, buffer + operandIdx);
 7906             operand.use();
 7907             break;
 7908         }
 7909         default:
 7910             CRASH();
 7911             break;
 7912         }
 7913     }
 7914 
 7915     flushRegisters();
 7916 
 7917     if (scratchSize) {
 7918         GPRTemporary scratch(this);
 7919 
 7920         // Tell GC mark phase how much of the scratch buffer is active during call.
 7921         m_jit.move(TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), scratch.gpr());
 7922         m_jit.storePtr(TrustedImmPtr(scratchSize), scratch.gpr());
 7923     }
 7924 
 7925     GPRFlushedCallResult result(this);
 7926 
 7927     callOperation(
 7928         operationNewArray, result.gpr(), m_jit.graph().registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(node-&gt;indexingType())),
 7929         static_cast&lt;void*&gt;(buffer), size_t(node-&gt;numChildren()));
 7930     m_jit.exceptionCheck();
 7931 
 7932     if (scratchSize) {
 7933         GPRTemporary scratch(this);
 7934 
 7935         m_jit.move(TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), scratch.gpr());
 7936         m_jit.storePtr(TrustedImmPtr(nullptr), scratch.gpr());
 7937     }
 7938 
 7939     cellResult(result.gpr(), node, UseChildrenCalledExplicitly);
 7940 }
 7941 
 7942 void SpeculativeJIT::compileNewArrayWithSpread(Node* node)
 7943 {
 7944     ASSERT(node-&gt;op() == NewArrayWithSpread);
 7945 
 7946 #if USE(JSVALUE64)
 7947     if (m_jit.graph().isWatchingHavingABadTimeWatchpoint(node)) {
 7948         GPRTemporary result(this);
 7949         GPRReg resultGPR = result.gpr();
 7950 
 7951         BitVector* bitVector = node-&gt;bitVector();
 7952         {
 7953             unsigned startLength = 0;
 7954             for (unsigned i = 0; i &lt; node-&gt;numChildren(); ++i) {
 7955                 if (!bitVector-&gt;get(i))
 7956                     ++startLength;
 7957             }
 7958 
 7959             GPRTemporary length(this);
 7960             GPRReg lengthGPR = length.gpr();
 7961             m_jit.move(TrustedImm32(startLength), lengthGPR);
 7962 
 7963             for (unsigned i = 0; i &lt; node-&gt;numChildren(); ++i) {
 7964                 if (bitVector-&gt;get(i)) {
 7965                     Edge use = m_jit.graph().varArgChild(node, i);
 7966                     SpeculateCellOperand fixedArray(this, use);
 7967                     GPRReg fixedArrayGPR = fixedArray.gpr();
 7968                     speculationCheck(Overflow, JSValueRegs(), nullptr, m_jit.branchAdd32(MacroAssembler::Overflow, MacroAssembler::Address(fixedArrayGPR, JSFixedArray::offsetOfSize()), lengthGPR));
 7969                 }
 7970             }
 7971 
 7972             speculationCheck(Overflow, JSValueRegs(), nullptr, m_jit.branch32(MacroAssembler::AboveOrEqual, lengthGPR, TrustedImm32(MIN_ARRAY_STORAGE_CONSTRUCTION_LENGTH)));
 7973 
 7974             // We can tell compileAllocateNewArrayWithSize() that it does not need to
 7975             // check for large arrays and use ArrayStorage structure because we already
 7976             // ensured above that the spread array length will definitely fit in a
 7977             // non-ArrayStorage shaped array.
 7978             bool shouldAllowForArrayStorageStructureForLargeArrays = false;
 7979             ASSERT(m_jit.graph().globalObjectFor(node-&gt;origin.semantic)-&gt;restParameterStructure()-&gt;indexingType() == ArrayWithContiguous || m_jit.graph().globalObjectFor(node-&gt;origin.semantic)-&gt;isHavingABadTime());
 7980             compileAllocateNewArrayWithSize(m_jit.graph().globalObjectFor(node-&gt;origin.semantic), resultGPR, lengthGPR, ArrayWithContiguous, shouldAllowForArrayStorageStructureForLargeArrays);
 7981         }
 7982 
 7983         GPRTemporary index(this);
 7984         GPRReg indexGPR = index.gpr();
 7985 
 7986         GPRTemporary storage(this);
 7987         GPRReg storageGPR = storage.gpr();
 7988 
 7989         m_jit.move(TrustedImm32(0), indexGPR);
 7990         m_jit.loadPtr(MacroAssembler::Address(resultGPR, JSObject::butterflyOffset()), storageGPR);
 7991 
 7992         for (unsigned i = 0; i &lt; node-&gt;numChildren(); ++i) {
 7993             Edge use = m_jit.graph().varArgChild(node, i);
 7994             if (bitVector-&gt;get(i)) {
 7995                 SpeculateCellOperand fixedArray(this, use);
 7996                 GPRReg fixedArrayGPR = fixedArray.gpr();
 7997 
 7998                 GPRTemporary fixedIndex(this);
 7999                 GPRReg fixedIndexGPR = fixedIndex.gpr();
 8000 
 8001                 GPRTemporary item(this);
 8002                 GPRReg itemGPR = item.gpr();
 8003 
 8004                 GPRTemporary fixedLength(this);
 8005                 GPRReg fixedLengthGPR = fixedLength.gpr();
 8006 
 8007                 m_jit.load32(MacroAssembler::Address(fixedArrayGPR, JSFixedArray::offsetOfSize()), fixedLengthGPR);
 8008                 m_jit.move(TrustedImm32(0), fixedIndexGPR);
 8009                 auto done = m_jit.branchPtr(MacroAssembler::AboveOrEqual, fixedIndexGPR, fixedLengthGPR);
 8010                 auto loopStart = m_jit.label();
 8011                 m_jit.load64(
 8012                     MacroAssembler::BaseIndex(fixedArrayGPR, fixedIndexGPR, MacroAssembler::TimesEight, JSFixedArray::offsetOfData()),
 8013                     itemGPR);
 8014 
 8015                 m_jit.store64(itemGPR, MacroAssembler::BaseIndex(storageGPR, indexGPR, MacroAssembler::TimesEight));
 8016                 m_jit.addPtr(TrustedImm32(1), fixedIndexGPR);
 8017                 m_jit.addPtr(TrustedImm32(1), indexGPR);
 8018                 m_jit.branchPtr(MacroAssembler::Below, fixedIndexGPR, fixedLengthGPR).linkTo(loopStart, &amp;m_jit);
 8019 
 8020                 done.link(&amp;m_jit);
 8021             } else {
 8022                 JSValueOperand item(this, use);
 8023                 GPRReg itemGPR = item.gpr();
 8024                 m_jit.store64(itemGPR, MacroAssembler::BaseIndex(storageGPR, indexGPR, MacroAssembler::TimesEight));
 8025                 m_jit.addPtr(TrustedImm32(1), indexGPR);
 8026             }
 8027         }
 8028 
 8029         cellResult(resultGPR, node);
 8030         return;
 8031     }
 8032 #endif // USE(JSVALUE64)
 8033 
 8034     ASSERT(node-&gt;numChildren());
 8035     size_t scratchSize = sizeof(EncodedJSValue) * node-&gt;numChildren();
 8036     ScratchBuffer* scratchBuffer = m_jit.vm()-&gt;scratchBufferForSize(scratchSize);
 8037     EncodedJSValue* buffer = static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer());
 8038 
 8039     BitVector* bitVector = node-&gt;bitVector();
 8040     for (unsigned i = 0; i &lt; node-&gt;numChildren(); ++i) {
 8041         Edge use = m_jit.graph().m_varArgChildren[node-&gt;firstChild() + i];
 8042         if (bitVector-&gt;get(i)) {
 8043             SpeculateCellOperand fixedArray(this, use);
 8044             GPRReg arrayGPR = fixedArray.gpr();
 8045 #if USE(JSVALUE64)
 8046             m_jit.store64(arrayGPR, &amp;buffer[i]);
 8047 #else
 8048             char* pointer = static_cast&lt;char*&gt;(static_cast&lt;void*&gt;(&amp;buffer[i]));
 8049             m_jit.store32(arrayGPR, pointer + PayloadOffset);
 8050             m_jit.store32(TrustedImm32(JSValue::CellTag), pointer + TagOffset);
 8051 #endif
 8052         } else {
 8053             JSValueOperand input(this, use);
 8054             JSValueRegs inputRegs = input.jsValueRegs();
 8055             m_jit.storeValue(inputRegs, &amp;buffer[i]);
 8056         }
 8057     }
 8058 
 8059     {
 8060         GPRTemporary scratch(this);
 8061         m_jit.move(TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), scratch.gpr());
 8062         m_jit.storePtr(TrustedImmPtr(scratchSize), MacroAssembler::Address(scratch.gpr()));
 8063     }
 8064 
 8065     flushRegisters();
 8066 
 8067     GPRFlushedCallResult result(this);
 8068     GPRReg resultGPR = result.gpr();
 8069 
 8070     callOperation(operationNewArrayWithSpreadSlow, resultGPR, buffer, node-&gt;numChildren());
 8071     m_jit.exceptionCheck();
 8072     {
 8073         GPRTemporary scratch(this);
 8074         m_jit.move(TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), scratch.gpr());
 8075         m_jit.storePtr(TrustedImmPtr(nullptr), MacroAssembler::Address(scratch.gpr()));
 8076     }
 8077 
 8078     cellResult(resultGPR, node);
 8079 }
 8080 
 8081 void SpeculativeJIT::compileGetRestLength(Node* node)
 8082 {
 8083     ASSERT(node-&gt;op() == GetRestLength);
 8084 
 8085     GPRTemporary result(this);
 8086     GPRReg resultGPR = result.gpr();
 8087 
 8088     emitGetLength(node-&gt;origin.semantic, resultGPR);
 8089     CCallHelpers::Jump hasNonZeroLength = m_jit.branch32(MacroAssembler::Above, resultGPR, Imm32(node-&gt;numberOfArgumentsToSkip()));
 8090     m_jit.move(TrustedImm32(0), resultGPR);
 8091     CCallHelpers::Jump done = m_jit.jump();
 8092     hasNonZeroLength.link(&amp;m_jit);
 8093     if (node-&gt;numberOfArgumentsToSkip())
 8094         m_jit.sub32(TrustedImm32(node-&gt;numberOfArgumentsToSkip()), resultGPR);
 8095     done.link(&amp;m_jit);
 8096     int32Result(resultGPR, node);
 8097 }
 8098 
 8099 void SpeculativeJIT::emitPopulateSliceIndex(Edge&amp; target, Optional&lt;GPRReg&gt; indexGPR, GPRReg lengthGPR, GPRReg resultGPR)
 8100 {
 8101     if (target-&gt;isInt32Constant()) {
 8102         int32_t value = target-&gt;asInt32();
 8103         if (value == 0) {
 8104             m_jit.move(TrustedImm32(0), resultGPR);
 8105             return;
 8106         }
 8107 
 8108         MacroAssembler::JumpList done;
 8109         if (value &gt; 0) {
 8110             m_jit.move(TrustedImm32(value), resultGPR);
 8111             done.append(m_jit.branch32(MacroAssembler::BelowOrEqual, resultGPR, lengthGPR));
 8112             m_jit.move(lengthGPR, resultGPR);
 8113         } else {
 8114             ASSERT(value != 0);
 8115             m_jit.move(lengthGPR, resultGPR);
 8116             done.append(m_jit.branchAdd32(MacroAssembler::PositiveOrZero, TrustedImm32(value), resultGPR));
 8117             m_jit.move(TrustedImm32(0), resultGPR);
 8118         }
 8119         done.link(&amp;m_jit);
 8120         return;
 8121     }
 8122 
 8123     Optional&lt;SpeculateInt32Operand&gt; index;
 8124     if (!indexGPR) {
 8125         index.emplace(this, target);
 8126         indexGPR = index-&gt;gpr();
 8127     }
 8128     MacroAssembler::JumpList done;
 8129 
 8130     auto isPositive = m_jit.branch32(MacroAssembler::GreaterThanOrEqual, indexGPR.value(), TrustedImm32(0));
 8131     m_jit.move(lengthGPR, resultGPR);
 8132     done.append(m_jit.branchAdd32(MacroAssembler::PositiveOrZero, indexGPR.value(), resultGPR));
 8133     m_jit.move(TrustedImm32(0), resultGPR);
 8134     done.append(m_jit.jump());
 8135 
 8136     isPositive.link(&amp;m_jit);
 8137     m_jit.move(indexGPR.value(), resultGPR);
 8138     done.append(m_jit.branch32(MacroAssembler::BelowOrEqual, resultGPR, lengthGPR));
 8139     m_jit.move(lengthGPR, resultGPR);
 8140 
 8141     done.link(&amp;m_jit);
 8142 }
 8143 
 8144 void SpeculativeJIT::compileArraySlice(Node* node)
 8145 {
 8146     ASSERT(node-&gt;op() == ArraySlice);
 8147 
 8148     JSGlobalObject* globalObject = m_jit.graph().globalObjectFor(node-&gt;origin.semantic);
 8149 
 8150     GPRTemporary temp(this);
 8151     StorageOperand storage(this, m_jit.graph().varArgChild(node, node-&gt;numChildren() - 1));
 8152     GPRTemporary result(this);
 8153 
 8154     GPRReg storageGPR = storage.gpr();
 8155     GPRReg resultGPR = result.gpr();
 8156     GPRReg tempGPR = temp.gpr();
 8157 
 8158     if (node-&gt;numChildren() == 2)
 8159         m_jit.load32(MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()), tempGPR);
 8160     else {
 8161         ASSERT(node-&gt;numChildren() == 3 || node-&gt;numChildren() == 4);
 8162         GPRTemporary tempLength(this);
 8163         GPRReg lengthGPR = tempLength.gpr();
 8164         m_jit.load32(MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()), lengthGPR);
 8165 
 8166         if (node-&gt;numChildren() == 4)
 8167             emitPopulateSliceIndex(m_jit.graph().varArgChild(node, 2), WTF::nullopt, lengthGPR, tempGPR);
 8168         else
 8169             m_jit.move(lengthGPR, tempGPR);
 8170 
 8171         if (m_jit.graph().varArgChild(node, 1)-&gt;isInt32Constant() &amp;&amp; m_jit.graph().varArgChild(node, 1)-&gt;asInt32() == 0) {
 8172             // Do nothing for array.slice(0, end) or array.slice(0) cases.
 8173             // `tempGPR` already points to the size of a newly created array.
 8174         } else {
 8175             GPRTemporary tempStartIndex(this);
 8176             GPRReg startGPR = tempStartIndex.gpr();
 8177             emitPopulateSliceIndex(m_jit.graph().varArgChild(node, 1), WTF::nullopt, lengthGPR, startGPR);
 8178 
 8179             auto tooBig = m_jit.branch32(MacroAssembler::Above, startGPR, tempGPR);
 8180             m_jit.sub32(startGPR, tempGPR); // the size of the array we&#39;ll make.
 8181             auto done = m_jit.jump();
 8182 
 8183             tooBig.link(&amp;m_jit);
 8184             m_jit.move(TrustedImm32(0), tempGPR);
 8185             done.link(&amp;m_jit);
 8186         }
 8187     }
 8188 
 8189     GPRTemporary temp3(this);
 8190     GPRReg tempValue = temp3.gpr();
 8191 
 8192     {
 8193         // We need to keep the source array alive at least until after we&#39;re done
 8194         // with anything that can GC (e.g. allocating the result array below).
 8195         SpeculateCellOperand cell(this, m_jit.graph().varArgChild(node, 0));
 8196 
 8197         m_jit.load8(MacroAssembler::Address(cell.gpr(), JSCell::indexingTypeAndMiscOffset()), tempValue);
 8198         // We can ignore the writability of the cell since we won&#39;t write to the source.
 8199         m_jit.and32(TrustedImm32(AllWritableArrayTypesAndHistory), tempValue);
 8200 
 8201         JSValueRegsTemporary emptyValue(this);
 8202         JSValueRegs emptyValueRegs = emptyValue.regs();
 8203 
 8204         GPRTemporary storage(this);
 8205         GPRReg storageResultGPR = storage.gpr();
 8206 
 8207         GPRReg sizeGPR = tempGPR;
 8208 
 8209         CCallHelpers::JumpList done;
 8210 
 8211         auto emitMoveEmptyValue = [&amp;] (JSValue v) {
 8212             m_jit.moveValue(v, emptyValueRegs);
 8213         };
 8214 
 8215         auto isContiguous = m_jit.branch32(MacroAssembler::Equal, tempValue, TrustedImm32(ArrayWithContiguous));
 8216         auto isInt32 = m_jit.branch32(MacroAssembler::Equal, tempValue, TrustedImm32(ArrayWithInt32));
 8217         // When we emit an ArraySlice, we dominate the use of the array by a CheckStructure
 8218         // to ensure the incoming array is one to be one of the original array structures
 8219         // with one of the following indexing shapes: Int32, Contiguous, Double. Therefore,
 8220         // we&#39;re a double array here.
 8221         m_jit.move(TrustedImmPtr(m_jit.graph().registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithDouble))), tempValue);
 8222         emitMoveEmptyValue(jsNaN());
 8223         done.append(m_jit.jump());
 8224 
 8225         isContiguous.link(&amp;m_jit);
 8226         m_jit.move(TrustedImmPtr(m_jit.graph().registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithContiguous))), tempValue);
 8227         emitMoveEmptyValue(JSValue());
 8228         done.append(m_jit.jump());
 8229 
 8230         isInt32.link(&amp;m_jit);
 8231         m_jit.move(TrustedImmPtr(m_jit.graph().registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithInt32))), tempValue);
 8232         emitMoveEmptyValue(JSValue());
 8233 
 8234         done.link(&amp;m_jit);
 8235 
 8236         MacroAssembler::JumpList slowCases;
 8237         m_jit.move(TrustedImmPtr(nullptr), storageResultGPR);
 8238         // Enable the fast case on 64-bit platforms, where a sufficient amount of GP registers should be available.
 8239         // Other platforms could support the same approach with custom code, but that is not currently worth the extra code maintenance.
 8240         if (is64Bit()) {
 8241             GPRTemporary scratch(this);
 8242             GPRTemporary scratch2(this);
 8243             GPRReg scratchGPR = scratch.gpr();
 8244             GPRReg scratch2GPR = scratch2.gpr();
 8245 
 8246             emitAllocateButterfly(storageResultGPR, sizeGPR, scratchGPR, scratch2GPR, resultGPR, slowCases);
 8247             emitInitializeButterfly(storageResultGPR, sizeGPR, emptyValueRegs, scratchGPR);
 8248             emitAllocateJSObject&lt;JSArray&gt;(resultGPR, tempValue, storageResultGPR, scratchGPR, scratch2GPR, slowCases);
 8249             m_jit.mutatorFence(*m_jit.vm());
 8250         } else {
 8251             slowCases.append(m_jit.jump());
 8252         }
 8253 
 8254         addSlowPathGenerator(std::make_unique&lt;CallArrayAllocatorWithVariableStructureVariableSizeSlowPathGenerator&gt;(
 8255             slowCases, this, operationNewArrayWithSize, resultGPR, tempValue, sizeGPR, storageResultGPR));
 8256     }
 8257 
 8258     GPRTemporary temp4(this);
 8259     GPRReg loadIndex = temp4.gpr();
 8260 
 8261     if (node-&gt;numChildren() == 2) {
 8262         m_jit.load32(MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()), tempGPR);
 8263         m_jit.move(TrustedImm32(0), loadIndex);
 8264     } else {
 8265         m_jit.load32(MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()), tempValue);
 8266         if (node-&gt;numChildren() == 4)
 8267             emitPopulateSliceIndex(m_jit.graph().varArgChild(node, 2), WTF::nullopt, tempValue, tempGPR);
 8268         else
 8269             m_jit.move(tempValue, tempGPR);
 8270         emitPopulateSliceIndex(m_jit.graph().varArgChild(node, 1), WTF::nullopt, tempValue, loadIndex);
 8271     }
 8272 
 8273     GPRTemporary temp5(this);
 8274     GPRReg storeIndex = temp5.gpr();
 8275     m_jit.move(TrustedImmPtr(nullptr), storeIndex);
 8276 
 8277     GPRTemporary temp2(this);
 8278     GPRReg resultButterfly = temp2.gpr();
 8279 
 8280     m_jit.loadPtr(MacroAssembler::Address(resultGPR, JSObject::butterflyOffset()), resultButterfly);
 8281     m_jit.zeroExtend32ToPtr(tempGPR, tempGPR);
 8282     m_jit.zeroExtend32ToPtr(loadIndex, loadIndex);
 8283     auto done = m_jit.branchPtr(MacroAssembler::AboveOrEqual, loadIndex, tempGPR);
 8284 
 8285     auto loop = m_jit.label();
 8286 #if USE(JSVALUE64)
 8287     m_jit.load64(
 8288         MacroAssembler::BaseIndex(storageGPR, loadIndex, MacroAssembler::TimesEight), tempValue);
 8289     m_jit.store64(
 8290         tempValue, MacroAssembler::BaseIndex(resultButterfly, storeIndex, MacroAssembler::TimesEight));
 8291 #else
 8292     m_jit.load32(
 8293         MacroAssembler::BaseIndex(storageGPR, loadIndex, MacroAssembler::TimesEight, PayloadOffset), tempValue);
 8294     m_jit.store32(
 8295         tempValue, MacroAssembler::BaseIndex(resultButterfly, storeIndex, MacroAssembler::TimesEight, PayloadOffset));
 8296     m_jit.load32(
 8297         MacroAssembler::BaseIndex(storageGPR, loadIndex, MacroAssembler::TimesEight, TagOffset), tempValue);
 8298     m_jit.store32(
 8299         tempValue, MacroAssembler::BaseIndex(resultButterfly, storeIndex, MacroAssembler::TimesEight, TagOffset));
 8300 #endif // USE(JSVALUE64)
 8301     m_jit.addPtr(TrustedImm32(1), loadIndex);
 8302     m_jit.addPtr(TrustedImm32(1), storeIndex);
 8303     m_jit.branchPtr(MacroAssembler::Below, loadIndex, tempGPR).linkTo(loop, &amp;m_jit);
 8304 
 8305     done.link(&amp;m_jit);
 8306     cellResult(resultGPR, node);
 8307 }
 8308 
 8309 void SpeculativeJIT::compileArrayIndexOf(Node* node)
 8310 {
 8311     ASSERT(node-&gt;op() == ArrayIndexOf);
 8312 
 8313     StorageOperand storage(this, m_jit.graph().varArgChild(node, node-&gt;numChildren() == 3 ? 2 : 3));
 8314     GPRTemporary index(this);
 8315     GPRTemporary tempLength(this);
 8316 
 8317     GPRReg storageGPR = storage.gpr();
 8318     GPRReg indexGPR = index.gpr();
 8319     GPRReg lengthGPR = tempLength.gpr();
 8320 
 8321     m_jit.load32(MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()), lengthGPR);
 8322 
 8323     if (node-&gt;numChildren() == 4)
 8324         emitPopulateSliceIndex(m_jit.graph().varArgChild(node, 2), WTF::nullopt, lengthGPR, indexGPR);
 8325     else
 8326         m_jit.move(TrustedImm32(0), indexGPR);
 8327 
 8328     Edge&amp; searchElementEdge = m_jit.graph().varArgChild(node, 1);
 8329     switch (searchElementEdge.useKind()) {
 8330     case Int32Use:
 8331     case ObjectUse:
 8332     case SymbolUse:
 8333     case OtherUse: {
 8334         auto emitLoop = [&amp;] (auto emitCompare) {
 8335 #if ENABLE(DFG_REGISTER_ALLOCATION_VALIDATION)
 8336             m_jit.clearRegisterAllocationOffsets();
 8337 #endif
 8338 
 8339             m_jit.zeroExtend32ToPtr(lengthGPR, lengthGPR);
 8340             m_jit.zeroExtend32ToPtr(indexGPR, indexGPR);
 8341 
 8342             auto loop = m_jit.label();
 8343             auto notFound = m_jit.branch32(CCallHelpers::Equal, indexGPR, lengthGPR);
 8344 
 8345             auto found = emitCompare();
 8346 
 8347             m_jit.add32(TrustedImm32(1), indexGPR);
 8348             m_jit.jump().linkTo(loop, &amp;m_jit);
 8349 
 8350             notFound.link(&amp;m_jit);
 8351             m_jit.move(TrustedImm32(-1), indexGPR);
 8352             found.link(&amp;m_jit);
 8353             int32Result(indexGPR, node);
 8354         };
 8355 
 8356         if (searchElementEdge.useKind() == Int32Use) {
 8357             ASSERT(node-&gt;arrayMode().type() == Array::Int32);
 8358 #if USE(JSVALUE64)
 8359             JSValueOperand searchElement(this, searchElementEdge, ManualOperandSpeculation);
 8360             JSValueRegs searchElementRegs = searchElement.jsValueRegs();
 8361             speculateInt32(searchElementEdge, searchElementRegs);
 8362             GPRReg searchElementGPR = searchElementRegs.payloadGPR();
 8363 #else
 8364             SpeculateInt32Operand searchElement(this, searchElementEdge);
 8365             GPRReg searchElementGPR = searchElement.gpr();
 8366 
 8367             GPRTemporary temp(this);
 8368             GPRReg tempGPR = temp.gpr();
 8369 #endif
 8370             emitLoop([&amp;] () {
 8371 #if USE(JSVALUE64)
 8372                 auto found = m_jit.branch64(CCallHelpers::Equal, MacroAssembler::BaseIndex(storageGPR, indexGPR, MacroAssembler::TimesEight), searchElementGPR);
 8373 #else
 8374                 auto skip = m_jit.branch32(CCallHelpers::NotEqual, MacroAssembler::BaseIndex(storageGPR, indexGPR, MacroAssembler::TimesEight, TagOffset), TrustedImm32(JSValue::Int32Tag));
 8375                 m_jit.load32(MacroAssembler::BaseIndex(storageGPR, indexGPR, MacroAssembler::TimesEight, PayloadOffset), tempGPR);
 8376                 auto found = m_jit.branch32(CCallHelpers::Equal, tempGPR, searchElementGPR);
 8377                 skip.link(&amp;m_jit);
 8378 #endif
 8379                 return found;
 8380             });
 8381             return;
 8382         }
 8383 
 8384         if (searchElementEdge.useKind() == OtherUse) {
 8385             ASSERT(node-&gt;arrayMode().type() == Array::Contiguous);
 8386             JSValueOperand searchElement(this, searchElementEdge, ManualOperandSpeculation);
 8387             GPRTemporary temp(this);
 8388 
 8389             JSValueRegs searchElementRegs = searchElement.jsValueRegs();
 8390             GPRReg tempGPR = temp.gpr();
 8391             speculateOther(searchElementEdge, searchElementRegs, tempGPR);
 8392 
 8393             emitLoop([&amp;] () {
 8394 #if USE(JSVALUE64)
 8395                 auto found = m_jit.branch64(CCallHelpers::Equal, MacroAssembler::BaseIndex(storageGPR, indexGPR, MacroAssembler::TimesEight), searchElementRegs.payloadGPR());
 8396 #else
 8397                 m_jit.load32(MacroAssembler::BaseIndex(storageGPR, indexGPR, MacroAssembler::TimesEight, TagOffset), tempGPR);
 8398                 auto found = m_jit.branch32(CCallHelpers::Equal, tempGPR, searchElementRegs.tagGPR());
 8399 #endif
 8400                 return found;
 8401             });
 8402             return;
 8403         }
 8404 
 8405         ASSERT(node-&gt;arrayMode().type() == Array::Contiguous);
 8406         SpeculateCellOperand searchElement(this, searchElementEdge);
 8407         GPRReg searchElementGPR = searchElement.gpr();
 8408 
 8409         if (searchElementEdge.useKind() == ObjectUse)
 8410             speculateObject(searchElementEdge, searchElementGPR);
 8411         else {
 8412             ASSERT(searchElementEdge.useKind() == SymbolUse);
 8413             speculateSymbol(searchElementEdge, searchElementGPR);
 8414         }
 8415 
 8416 #if USE(JSVALUE32_64)
 8417         GPRTemporary temp(this);
 8418         GPRReg tempGPR = temp.gpr();
 8419 #endif
 8420 
 8421         emitLoop([&amp;] () {
 8422 #if USE(JSVALUE64)
 8423             auto found = m_jit.branch64(CCallHelpers::Equal, MacroAssembler::BaseIndex(storageGPR, indexGPR, MacroAssembler::TimesEight), searchElementGPR);
 8424 #else
 8425             auto skip = m_jit.branch32(CCallHelpers::NotEqual, MacroAssembler::BaseIndex(storageGPR, indexGPR, MacroAssembler::TimesEight, TagOffset), TrustedImm32(JSValue::CellTag));
 8426             m_jit.load32(MacroAssembler::BaseIndex(storageGPR, indexGPR, MacroAssembler::TimesEight, PayloadOffset), tempGPR);
 8427             auto found = m_jit.branch32(CCallHelpers::Equal, tempGPR, searchElementGPR);
 8428             skip.link(&amp;m_jit);
 8429 #endif
 8430             return found;
 8431         });
 8432         return;
 8433     }
 8434 
 8435     case DoubleRepUse: {
 8436         ASSERT(node-&gt;arrayMode().type() == Array::Double);
 8437         SpeculateDoubleOperand searchElement(this, searchElementEdge);
 8438         FPRTemporary tempDouble(this);
 8439 
 8440         FPRReg searchElementFPR = searchElement.fpr();
 8441         FPRReg tempFPR = tempDouble.fpr();
 8442 
 8443 #if ENABLE(DFG_REGISTER_ALLOCATION_VALIDATION)
 8444         m_jit.clearRegisterAllocationOffsets();
 8445 #endif
 8446 
 8447         m_jit.zeroExtend32ToPtr(lengthGPR, lengthGPR);
 8448         m_jit.zeroExtend32ToPtr(indexGPR, indexGPR);
 8449 
 8450         auto loop = m_jit.label();
 8451         auto notFound = m_jit.branch32(CCallHelpers::Equal, indexGPR, lengthGPR);
 8452         m_jit.loadDouble(MacroAssembler::BaseIndex(storageGPR, indexGPR, MacroAssembler::TimesEight), tempFPR);
 8453         auto found = m_jit.branchDouble(CCallHelpers::DoubleEqual, tempFPR, searchElementFPR);
 8454         m_jit.add32(TrustedImm32(1), indexGPR);
 8455         m_jit.jump().linkTo(loop, &amp;m_jit);
 8456 
 8457         notFound.link(&amp;m_jit);
 8458         m_jit.move(TrustedImm32(-1), indexGPR);
 8459         found.link(&amp;m_jit);
 8460         int32Result(indexGPR, node);
 8461         return;
 8462     }
 8463 
 8464     case StringUse: {
 8465         ASSERT(node-&gt;arrayMode().type() == Array::Contiguous);
 8466         SpeculateCellOperand searchElement(this, searchElementEdge);
 8467 
 8468         GPRReg searchElementGPR = searchElement.gpr();
 8469 
 8470         speculateString(searchElementEdge, searchElementGPR);
 8471 
 8472         flushRegisters();
 8473 
 8474         callOperation(operationArrayIndexOfString, lengthGPR, storageGPR, searchElementGPR, indexGPR);
 8475         m_jit.exceptionCheck();
 8476 
 8477         int32Result(lengthGPR, node);
 8478         return;
 8479     }
 8480 
 8481     case UntypedUse: {
 8482         JSValueOperand searchElement(this, searchElementEdge);
 8483 
 8484         JSValueRegs searchElementRegs = searchElement.jsValueRegs();
 8485 
 8486         flushRegisters();
 8487         switch (node-&gt;arrayMode().type()) {
 8488         case Array::Double:
 8489             callOperation(operationArrayIndexOfValueDouble, lengthGPR, storageGPR, searchElementRegs, indexGPR);
 8490             break;
 8491         case Array::Int32:
 8492         case Array::Contiguous:
 8493             callOperation(operationArrayIndexOfValueInt32OrContiguous, lengthGPR, storageGPR, searchElementRegs, indexGPR);
 8494             break;
 8495         default:
 8496             RELEASE_ASSERT_NOT_REACHED();
 8497             break;
 8498         }
 8499         m_jit.exceptionCheck();
 8500 
 8501         int32Result(lengthGPR, node);
 8502         return;
 8503     }
 8504 
 8505     default:
 8506         RELEASE_ASSERT_NOT_REACHED();
 8507         return;
 8508     }
 8509 }
 8510 
 8511 void SpeculativeJIT::compileArrayPush(Node* node)
 8512 {
 8513     ASSERT(node-&gt;arrayMode().isJSArray());
 8514 
 8515     Edge&amp; storageEdge = m_jit.graph().varArgChild(node, 0);
 8516     Edge&amp; arrayEdge = m_jit.graph().varArgChild(node, 1);
 8517 
 8518     SpeculateCellOperand base(this, arrayEdge);
 8519     GPRTemporary storageLength(this);
 8520 
 8521     GPRReg baseGPR = base.gpr();
 8522     GPRReg storageLengthGPR = storageLength.gpr();
 8523 
 8524     StorageOperand storage(this, storageEdge);
 8525     GPRReg storageGPR = storage.gpr();
 8526     unsigned elementOffset = 2;
 8527     unsigned elementCount = node-&gt;numChildren() - elementOffset;
 8528 
 8529 #if USE(JSVALUE32_64)
 8530     GPRTemporary tag(this);
 8531     GPRReg tagGPR = tag.gpr();
 8532     JSValueRegs resultRegs { tagGPR, storageLengthGPR };
 8533 #else
 8534     JSValueRegs resultRegs { storageLengthGPR };
 8535 #endif
 8536 
 8537     auto getStorageBufferAddress = [&amp;] (GPRReg storageGPR, GPRReg indexGPR, int32_t offset, GPRReg bufferGPR) {
 8538         static_assert(sizeof(JSValue) == 8 &amp;&amp; 1 &lt;&lt; 3 == 8, &quot;This is strongly assumed in the code below.&quot;);
 8539         m_jit.getEffectiveAddress(MacroAssembler::BaseIndex(storageGPR, indexGPR, MacroAssembler::TimesEight, offset), bufferGPR);
 8540     };
 8541 
 8542     switch (node-&gt;arrayMode().type()) {
 8543     case Array::Int32:
 8544     case Array::Contiguous: {
 8545         if (elementCount == 1) {
 8546             Edge&amp; element = m_jit.graph().varArgChild(node, elementOffset);
 8547             JSValueOperand value(this, element, ManualOperandSpeculation);
 8548             JSValueRegs valueRegs = value.jsValueRegs();
 8549 
 8550             if (node-&gt;arrayMode().type() == Array::Int32)
 8551                 DFG_ASSERT(m_jit.graph(), node, !needsTypeCheck(element, SpecInt32Only));
 8552 
 8553             m_jit.load32(MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()), storageLengthGPR);
 8554             MacroAssembler::Jump slowPath = m_jit.branch32(MacroAssembler::AboveOrEqual, storageLengthGPR, MacroAssembler::Address(storageGPR, Butterfly::offsetOfVectorLength()));
 8555             m_jit.storeValue(valueRegs, MacroAssembler::BaseIndex(storageGPR, storageLengthGPR, MacroAssembler::TimesEight));
 8556             m_jit.add32(TrustedImm32(1), storageLengthGPR);
 8557             m_jit.store32(storageLengthGPR, MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()));
 8558             m_jit.boxInt32(storageLengthGPR, resultRegs);
 8559 
 8560             addSlowPathGenerator(
 8561                 slowPathCall(slowPath, this, operationArrayPush, resultRegs, valueRegs, baseGPR));
 8562 
 8563             jsValueResult(resultRegs, node);
 8564             return;
 8565         }
 8566 
 8567         GPRTemporary buffer(this);
 8568         GPRReg bufferGPR = buffer.gpr();
 8569 
 8570         m_jit.load32(MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()), storageLengthGPR);
 8571         m_jit.move(storageLengthGPR, bufferGPR);
 8572         m_jit.add32(TrustedImm32(elementCount), bufferGPR);
 8573         MacroAssembler::Jump slowPath = m_jit.branch32(MacroAssembler::Above, bufferGPR, MacroAssembler::Address(storageGPR, Butterfly::offsetOfVectorLength()));
 8574 
 8575         m_jit.store32(bufferGPR, MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()));
 8576         getStorageBufferAddress(storageGPR, storageLengthGPR, 0, bufferGPR);
 8577         m_jit.add32(TrustedImm32(elementCount), storageLengthGPR);
 8578         m_jit.boxInt32(storageLengthGPR, resultRegs);
 8579         auto storageDone = m_jit.jump();
 8580 
 8581         slowPath.link(&amp;m_jit);
 8582 
 8583         size_t scratchSize = sizeof(EncodedJSValue) * elementCount;
 8584         ScratchBuffer* scratchBuffer = m_jit.vm()-&gt;scratchBufferForSize(scratchSize);
 8585         m_jit.move(TrustedImmPtr(static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer())), bufferGPR);
 8586         m_jit.move(TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), storageLengthGPR);
 8587         m_jit.storePtr(TrustedImmPtr(scratchSize), MacroAssembler::Address(storageLengthGPR));
 8588 
 8589         storageDone.link(&amp;m_jit);
 8590         for (unsigned elementIndex = 0; elementIndex &lt; elementCount; ++elementIndex) {
 8591             Edge&amp; element = m_jit.graph().varArgChild(node, elementIndex + elementOffset);
 8592             JSValueOperand value(this, element, ManualOperandSpeculation);
 8593             JSValueRegs valueRegs = value.jsValueRegs();
 8594 
 8595             if (node-&gt;arrayMode().type() == Array::Int32)
 8596                 DFG_ASSERT(m_jit.graph(), node, !needsTypeCheck(element, SpecInt32Only));
 8597 
 8598             m_jit.storeValue(valueRegs, MacroAssembler::Address(bufferGPR, sizeof(EncodedJSValue) * elementIndex));
 8599             value.use();
 8600         }
 8601 
 8602         MacroAssembler::Jump fastPath = m_jit.branchPtr(MacroAssembler::NotEqual, bufferGPR, TrustedImmPtr(static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer())));
 8603 
 8604         addSlowPathGenerator(slowPathCall(m_jit.jump(), this, operationArrayPushMultiple, resultRegs, baseGPR, bufferGPR, TrustedImm32(elementCount)));
 8605 
 8606         m_jit.move(TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), bufferGPR);
 8607         m_jit.storePtr(TrustedImmPtr(nullptr), MacroAssembler::Address(bufferGPR));
 8608 
 8609         base.use();
 8610         storage.use();
 8611 
 8612         fastPath.link(&amp;m_jit);
 8613         jsValueResult(resultRegs, node, DataFormatJS, UseChildrenCalledExplicitly);
 8614         return;
 8615     }
 8616 
 8617     case Array::Double: {
 8618         if (elementCount == 1) {
 8619             Edge&amp; element = m_jit.graph().varArgChild(node, elementOffset);
 8620             SpeculateDoubleOperand value(this, element);
 8621             FPRReg valueFPR = value.fpr();
 8622 
 8623             DFG_ASSERT(m_jit.graph(), node, !needsTypeCheck(element, SpecDoubleReal));
 8624 
 8625             m_jit.load32(MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()), storageLengthGPR);
 8626             MacroAssembler::Jump slowPath = m_jit.branch32(MacroAssembler::AboveOrEqual, storageLengthGPR, MacroAssembler::Address(storageGPR, Butterfly::offsetOfVectorLength()));
 8627             m_jit.storeDouble(valueFPR, MacroAssembler::BaseIndex(storageGPR, storageLengthGPR, MacroAssembler::TimesEight));
 8628             m_jit.add32(TrustedImm32(1), storageLengthGPR);
 8629             m_jit.store32(storageLengthGPR, MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()));
 8630             m_jit.boxInt32(storageLengthGPR, resultRegs);
 8631 
 8632             addSlowPathGenerator(
 8633                 slowPathCall(slowPath, this, operationArrayPushDouble, resultRegs, valueFPR, baseGPR));
 8634 
 8635             jsValueResult(resultRegs, node);
 8636             return;
 8637         }
 8638 
 8639         GPRTemporary buffer(this);
 8640         GPRReg bufferGPR = buffer.gpr();
 8641 
 8642         m_jit.load32(MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()), storageLengthGPR);
 8643         m_jit.move(storageLengthGPR, bufferGPR);
 8644         m_jit.add32(TrustedImm32(elementCount), bufferGPR);
 8645         MacroAssembler::Jump slowPath = m_jit.branch32(MacroAssembler::Above, bufferGPR, MacroAssembler::Address(storageGPR, Butterfly::offsetOfVectorLength()));
 8646 
 8647         m_jit.store32(bufferGPR, MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()));
 8648         getStorageBufferAddress(storageGPR, storageLengthGPR, 0, bufferGPR);
 8649         m_jit.add32(TrustedImm32(elementCount), storageLengthGPR);
 8650         m_jit.boxInt32(storageLengthGPR, resultRegs);
 8651         auto storageDone = m_jit.jump();
 8652 
 8653         slowPath.link(&amp;m_jit);
 8654 
 8655         size_t scratchSize = sizeof(double) * elementCount;
 8656         ScratchBuffer* scratchBuffer = m_jit.vm()-&gt;scratchBufferForSize(scratchSize);
 8657         m_jit.move(TrustedImmPtr(static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer())), bufferGPR);
 8658         m_jit.move(TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), storageLengthGPR);
 8659         m_jit.storePtr(TrustedImmPtr(scratchSize), MacroAssembler::Address(storageLengthGPR));
 8660 
 8661         storageDone.link(&amp;m_jit);
 8662         for (unsigned elementIndex = 0; elementIndex &lt; elementCount; ++elementIndex) {
 8663             Edge&amp; element = m_jit.graph().varArgChild(node, elementIndex + elementOffset);
 8664             SpeculateDoubleOperand value(this, element);
 8665             FPRReg valueFPR = value.fpr();
 8666 
 8667             DFG_ASSERT(m_jit.graph(), node, !needsTypeCheck(element, SpecDoubleReal));
 8668 
 8669             m_jit.storeDouble(valueFPR, MacroAssembler::Address(bufferGPR, sizeof(double) * elementIndex));
 8670             value.use();
 8671         }
 8672 
 8673         MacroAssembler::Jump fastPath = m_jit.branchPtr(MacroAssembler::NotEqual, bufferGPR, TrustedImmPtr(static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer())));
 8674 
 8675         addSlowPathGenerator(slowPathCall(m_jit.jump(), this, operationArrayPushDoubleMultiple, resultRegs, baseGPR, bufferGPR, TrustedImm32(elementCount)));
 8676 
 8677         m_jit.move(TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), bufferGPR);
 8678         m_jit.storePtr(TrustedImmPtr(nullptr), MacroAssembler::Address(bufferGPR));
 8679 
 8680         base.use();
 8681         storage.use();
 8682 
 8683         fastPath.link(&amp;m_jit);
 8684         jsValueResult(resultRegs, node, DataFormatJS, UseChildrenCalledExplicitly);
 8685         return;
 8686     }
 8687 
 8688     case Array::ArrayStorage: {
 8689         // This ensures that the result of ArrayPush is Int32 in AI.
 8690         int32_t largestPositiveInt32Length = 0x7fffffff - elementCount;
 8691         if (elementCount == 1) {
 8692             Edge&amp; element = m_jit.graph().varArgChild(node, elementOffset);
 8693             JSValueOperand value(this, element);
 8694             JSValueRegs valueRegs = value.jsValueRegs();
 8695 
 8696             m_jit.load32(MacroAssembler::Address(storageGPR, ArrayStorage::lengthOffset()), storageLengthGPR);
 8697 
 8698             // Refuse to handle bizarre lengths.
 8699             speculationCheck(Uncountable, JSValueRegs(), 0, m_jit.branch32(MacroAssembler::Above, storageLengthGPR, TrustedImm32(largestPositiveInt32Length)));
 8700 
 8701             MacroAssembler::Jump slowPath = m_jit.branch32(MacroAssembler::AboveOrEqual, storageLengthGPR, MacroAssembler::Address(storageGPR, ArrayStorage::vectorLengthOffset()));
 8702 
 8703             m_jit.storeValue(valueRegs, MacroAssembler::BaseIndex(storageGPR, storageLengthGPR, MacroAssembler::TimesEight, ArrayStorage::vectorOffset()));
 8704 
 8705             m_jit.add32(TrustedImm32(1), storageLengthGPR);
 8706             m_jit.store32(storageLengthGPR, MacroAssembler::Address(storageGPR, ArrayStorage::lengthOffset()));
 8707             m_jit.add32(TrustedImm32(1), MacroAssembler::Address(storageGPR, OBJECT_OFFSETOF(ArrayStorage, m_numValuesInVector)));
 8708             m_jit.boxInt32(storageLengthGPR, resultRegs);
 8709 
 8710             addSlowPathGenerator(
 8711                 slowPathCall(slowPath, this, operationArrayPush, resultRegs, valueRegs, baseGPR));
 8712 
 8713             jsValueResult(resultRegs, node);
 8714             return;
 8715         }
 8716 
 8717         GPRTemporary buffer(this);
 8718         GPRReg bufferGPR = buffer.gpr();
 8719 
 8720         m_jit.load32(MacroAssembler::Address(storageGPR, ArrayStorage::lengthOffset()), storageLengthGPR);
 8721 
 8722         // Refuse to handle bizarre lengths.
 8723         speculationCheck(Uncountable, JSValueRegs(), 0, m_jit.branch32(MacroAssembler::Above, storageLengthGPR, TrustedImm32(largestPositiveInt32Length)));
 8724 
 8725         m_jit.move(storageLengthGPR, bufferGPR);
 8726         m_jit.add32(TrustedImm32(elementCount), bufferGPR);
 8727         MacroAssembler::Jump slowPath = m_jit.branch32(MacroAssembler::Above, bufferGPR, MacroAssembler::Address(storageGPR, ArrayStorage::vectorLengthOffset()));
 8728 
 8729         m_jit.store32(bufferGPR, MacroAssembler::Address(storageGPR, ArrayStorage::lengthOffset()));
 8730         getStorageBufferAddress(storageGPR, storageLengthGPR, ArrayStorage::vectorOffset(), bufferGPR);
 8731         m_jit.add32(TrustedImm32(elementCount), MacroAssembler::Address(storageGPR, OBJECT_OFFSETOF(ArrayStorage, m_numValuesInVector)));
 8732         m_jit.add32(TrustedImm32(elementCount), storageLengthGPR);
 8733         m_jit.boxInt32(storageLengthGPR, resultRegs);
 8734         auto storageDone = m_jit.jump();
 8735 
 8736         slowPath.link(&amp;m_jit);
 8737 
 8738         size_t scratchSize = sizeof(EncodedJSValue) * elementCount;
 8739         ScratchBuffer* scratchBuffer = m_jit.vm()-&gt;scratchBufferForSize(scratchSize);
 8740         m_jit.move(TrustedImmPtr(static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer())), bufferGPR);
 8741         m_jit.move(TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), storageLengthGPR);
 8742         m_jit.storePtr(TrustedImmPtr(scratchSize), MacroAssembler::Address(storageLengthGPR));
 8743 
 8744         storageDone.link(&amp;m_jit);
 8745         for (unsigned elementIndex = 0; elementIndex &lt; elementCount; ++elementIndex) {
 8746             Edge&amp; element = m_jit.graph().varArgChild(node, elementIndex + elementOffset);
 8747             JSValueOperand value(this, element);
 8748             JSValueRegs valueRegs = value.jsValueRegs();
 8749 
 8750             m_jit.storeValue(valueRegs, MacroAssembler::Address(bufferGPR, sizeof(EncodedJSValue) * elementIndex));
 8751             value.use();
 8752         }
 8753 
 8754         MacroAssembler::Jump fastPath = m_jit.branchPtr(MacroAssembler::NotEqual, bufferGPR, TrustedImmPtr(static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer())));
 8755 
 8756         addSlowPathGenerator(
 8757             slowPathCall(m_jit.jump(), this, operationArrayPushMultiple, resultRegs, baseGPR, bufferGPR, TrustedImm32(elementCount)));
 8758 
 8759         m_jit.move(TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), bufferGPR);
 8760         m_jit.storePtr(TrustedImmPtr(nullptr), MacroAssembler::Address(bufferGPR));
 8761 
 8762         base.use();
 8763         storage.use();
 8764 
 8765         fastPath.link(&amp;m_jit);
 8766         jsValueResult(resultRegs, node, DataFormatJS, UseChildrenCalledExplicitly);
 8767         return;
 8768     }
 8769 
 8770     default:
 8771         RELEASE_ASSERT_NOT_REACHED();
 8772     }
 8773 }
 8774 
 8775 void SpeculativeJIT::compileNotifyWrite(Node* node)
 8776 {
 8777     WatchpointSet* set = node-&gt;watchpointSet();
 8778 
 8779     JITCompiler::Jump slowCase = m_jit.branch8(
 8780         JITCompiler::NotEqual,
 8781         JITCompiler::AbsoluteAddress(set-&gt;addressOfState()),
 8782         TrustedImm32(IsInvalidated));
 8783 
 8784     addSlowPathGenerator(
 8785         slowPathCall(slowCase, this, operationNotifyWrite, NeedToSpill, ExceptionCheckRequirement::CheckNotNeeded, NoResult, set));
 8786 
 8787     noResult(node);
 8788 }
 8789 
 8790 void SpeculativeJIT::compileIsObject(Node* node)
 8791 {
 8792     JSValueOperand value(this, node-&gt;child1());
 8793     GPRTemporary result(this, Reuse, value, TagWord);
 8794 
 8795     JSValueRegs valueRegs = value.jsValueRegs();
 8796     GPRReg resultGPR = result.gpr();
 8797 
 8798     JITCompiler::Jump isNotCell = m_jit.branchIfNotCell(valueRegs);
 8799 
 8800     m_jit.compare8(JITCompiler::AboveOrEqual,
 8801         JITCompiler::Address(valueRegs.payloadGPR(), JSCell::typeInfoTypeOffset()),
 8802         TrustedImm32(ObjectType),
 8803         resultGPR);
 8804     JITCompiler::Jump done = m_jit.jump();
 8805 
 8806     isNotCell.link(&amp;m_jit);
 8807     m_jit.move(TrustedImm32(0), resultGPR);
 8808 
 8809     done.link(&amp;m_jit);
 8810     unblessedBooleanResult(resultGPR, node);
 8811 }
 8812 
 8813 void SpeculativeJIT::compileIsObjectOrNull(Node* node)
 8814 {
 8815     JSGlobalObject* globalObject = m_jit.graph().globalObjectFor(node-&gt;origin.semantic);
 8816 
 8817     JSValueOperand value(this, node-&gt;child1());
 8818     JSValueRegs valueRegs = value.jsValueRegs();
 8819 
 8820     GPRTemporary result(this);
 8821     GPRReg resultGPR = result.gpr();
 8822 
 8823     JITCompiler::Jump isCell = m_jit.branchIfCell(valueRegs);
 8824 
 8825     JITCompiler::Jump isNull = m_jit.branchIfEqual(valueRegs, jsNull());
 8826     JITCompiler::Jump isNonNullNonCell = m_jit.jump();
 8827 
 8828     isCell.link(&amp;m_jit);
 8829     JITCompiler::Jump isFunction = m_jit.branchIfFunction(valueRegs.payloadGPR());
 8830     JITCompiler::Jump notObject = m_jit.branchIfNotObject(valueRegs.payloadGPR());
 8831 
 8832     JITCompiler::Jump slowPath = m_jit.branchTest8(
 8833         JITCompiler::NonZero,
 8834         JITCompiler::Address(valueRegs.payloadGPR(), JSCell::typeInfoFlagsOffset()),
 8835         TrustedImm32(MasqueradesAsUndefined | OverridesGetCallData));
 8836 
 8837     isNull.link(&amp;m_jit);
 8838     m_jit.move(TrustedImm32(1), resultGPR);
 8839     JITCompiler::Jump done = m_jit.jump();
 8840 
 8841     isNonNullNonCell.link(&amp;m_jit);
 8842     isFunction.link(&amp;m_jit);
 8843     notObject.link(&amp;m_jit);
 8844     m_jit.move(TrustedImm32(0), resultGPR);
 8845 
 8846     addSlowPathGenerator(
 8847         slowPathCall(
 8848             slowPath, this, operationObjectIsObject, resultGPR, globalObject,
 8849             valueRegs.payloadGPR()));
 8850 
 8851     done.link(&amp;m_jit);
 8852 
 8853     unblessedBooleanResult(resultGPR, node);
 8854 }
 8855 
 8856 void SpeculativeJIT::compileIsFunction(Node* node)
 8857 {
 8858     JSGlobalObject* globalObject = m_jit.graph().globalObjectFor(node-&gt;origin.semantic);
 8859 
 8860     JSValueOperand value(this, node-&gt;child1());
 8861     JSValueRegs valueRegs = value.jsValueRegs();
 8862 
 8863     GPRTemporary result(this);
 8864     GPRReg resultGPR = result.gpr();
 8865 
 8866     JITCompiler::Jump notCell = m_jit.branchIfNotCell(valueRegs);
 8867     JITCompiler::Jump isFunction = m_jit.branchIfFunction(valueRegs.payloadGPR());
 8868     JITCompiler::Jump notObject = m_jit.branchIfNotObject(valueRegs.payloadGPR());
 8869 
 8870     JITCompiler::Jump slowPath = m_jit.branchTest8(
 8871         JITCompiler::NonZero,
 8872         JITCompiler::Address(valueRegs.payloadGPR(), JSCell::typeInfoFlagsOffset()),
 8873         TrustedImm32(MasqueradesAsUndefined | OverridesGetCallData));
 8874 
 8875     notCell.link(&amp;m_jit);
 8876     notObject.link(&amp;m_jit);
 8877     m_jit.move(TrustedImm32(0), resultGPR);
 8878     JITCompiler::Jump done = m_jit.jump();
 8879 
 8880     isFunction.link(&amp;m_jit);
 8881     m_jit.move(TrustedImm32(1), resultGPR);
 8882 
 8883     addSlowPathGenerator(
 8884         slowPathCall(
 8885             slowPath, this, operationObjectIsFunction, resultGPR, globalObject,
 8886             valueRegs.payloadGPR()));
 8887 
 8888     done.link(&amp;m_jit);
 8889 
 8890     unblessedBooleanResult(resultGPR, node);
 8891 }
 8892 
 8893 void SpeculativeJIT::compileTypeOf(Node* node)
 8894 {
 8895     JSGlobalObject* globalObject = m_jit.graph().globalObjectFor(node-&gt;origin.semantic);
 8896 
 8897     JSValueOperand value(this, node-&gt;child1());
 8898     JSValueRegs valueRegs = value.jsValueRegs();
 8899 
 8900     GPRTemporary result(this);
 8901     GPRReg resultGPR = result.gpr();
 8902 
 8903     JITCompiler::JumpList done;
 8904     JITCompiler::Jump slowPath;
 8905     m_jit.emitTypeOf(
 8906         valueRegs, resultGPR,
 8907         [&amp;] (TypeofType type, bool fallsThrough) {
 8908             m_jit.move(TrustedImmPtr::weakPointer(m_jit.graph(), m_jit.vm()-&gt;smallStrings.typeString(type)), resultGPR);
 8909             if (!fallsThrough)
 8910                 done.append(m_jit.jump());
 8911         },
 8912         [&amp;] (JITCompiler::Jump theSlowPath) {
 8913             slowPath = theSlowPath;
 8914         });
 8915     done.link(&amp;m_jit);
 8916 
 8917     addSlowPathGenerator(
 8918         slowPathCall(
 8919             slowPath, this, operationTypeOfObject, resultGPR, globalObject,
 8920             valueRegs.payloadGPR()));
 8921 
 8922     cellResult(resultGPR, node);
 8923 }
 8924 
 8925 void SpeculativeJIT::emitStructureCheck(Node* node, GPRReg cellGPR, GPRReg tempGPR)
 8926 {
 8927     ASSERT(node-&gt;structureSet().size());
 8928 
 8929     if (node-&gt;structureSet().size() == 1) {
 8930         speculationCheck(
 8931             BadCache, JSValueSource::unboxedCell(cellGPR), 0,
 8932             m_jit.branchWeakStructure(
 8933                 JITCompiler::NotEqual,
 8934                 JITCompiler::Address(cellGPR, JSCell::structureIDOffset()),
 8935                 node-&gt;structureSet()[0]));
 8936     } else {
 8937         std::unique_ptr&lt;GPRTemporary&gt; structure;
 8938         GPRReg structureGPR;
 8939 
 8940         if (tempGPR == InvalidGPRReg) {
 8941             structure = std::make_unique&lt;GPRTemporary&gt;(this);
 8942             structureGPR = structure-&gt;gpr();
 8943         } else
 8944             structureGPR = tempGPR;
 8945 
 8946         m_jit.load32(JITCompiler::Address(cellGPR, JSCell::structureIDOffset()), structureGPR);
 8947 
 8948         JITCompiler::JumpList done;
 8949 
 8950         for (size_t i = 0; i &lt; node-&gt;structureSet().size() - 1; ++i) {
 8951             done.append(
 8952                 m_jit.branchWeakStructure(JITCompiler::Equal, structureGPR, node-&gt;structureSet()[i]));
 8953         }
 8954 
 8955         speculationCheck(
 8956             BadCache, JSValueSource::unboxedCell(cellGPR), 0,
 8957             m_jit.branchWeakStructure(
 8958                 JITCompiler::NotEqual, structureGPR, node-&gt;structureSet().last()));
 8959 
 8960         done.link(&amp;m_jit);
 8961     }
 8962 }
 8963 
 8964 void SpeculativeJIT::compileCheckCell(Node* node)
 8965 {
 8966     SpeculateCellOperand cell(this, node-&gt;child1());
 8967     speculationCheck(BadCell, JSValueSource::unboxedCell(cell.gpr()), node-&gt;child1(), m_jit.branchWeakPtr(JITCompiler::NotEqual, cell.gpr(), node-&gt;cellOperand()-&gt;cell()));
 8968     noResult(node);
 8969 }
 8970 
 8971 void SpeculativeJIT::compileCheckNotEmpty(Node* node)
 8972 {
 8973     JSValueOperand operand(this, node-&gt;child1());
 8974     JSValueRegs regs = operand.jsValueRegs();
 8975     speculationCheck(TDZFailure, JSValueSource(), nullptr, m_jit.branchIfEmpty(regs));
 8976     noResult(node);
 8977 }
 8978 
 8979 void SpeculativeJIT::compileCheckStructure(Node* node)
 8980 {
 8981     switch (node-&gt;child1().useKind()) {
 8982     case CellUse:
 8983     case KnownCellUse: {
 8984         SpeculateCellOperand cell(this, node-&gt;child1());
 8985         emitStructureCheck(node, cell.gpr(), InvalidGPRReg);
 8986         noResult(node);
 8987         return;
 8988     }
 8989 
 8990     case CellOrOtherUse: {
 8991         JSValueOperand value(this, node-&gt;child1(), ManualOperandSpeculation);
 8992         GPRTemporary temp(this);
 8993 
 8994         JSValueRegs valueRegs = value.jsValueRegs();
 8995         GPRReg tempGPR = temp.gpr();
 8996 
 8997         JITCompiler::Jump cell = m_jit.branchIfCell(valueRegs);
 8998         DFG_TYPE_CHECK(
 8999             valueRegs, node-&gt;child1(), SpecCell | SpecOther,
 9000             m_jit.branchIfNotOther(valueRegs, tempGPR));
 9001         JITCompiler::Jump done = m_jit.jump();
 9002         cell.link(&amp;m_jit);
 9003         emitStructureCheck(node, valueRegs.payloadGPR(), tempGPR);
 9004         done.link(&amp;m_jit);
 9005         noResult(node);
 9006         return;
 9007     }
 9008 
 9009     default:
 9010         DFG_CRASH(m_jit.graph(), node, &quot;Bad use kind&quot;);
 9011         return;
 9012     }
 9013 }
 9014 
 9015 void SpeculativeJIT::compileAllocatePropertyStorage(Node* node)
 9016 {
 9017     ASSERT(!node-&gt;transition()-&gt;previous-&gt;outOfLineCapacity());
 9018     ASSERT(initialOutOfLineCapacity == node-&gt;transition()-&gt;next-&gt;outOfLineCapacity());
 9019 
 9020     size_t size = initialOutOfLineCapacity * sizeof(JSValue);
 9021 
 9022     Allocator allocator = m_jit.vm()-&gt;jsValueGigacageAuxiliarySpace.allocatorForNonVirtual(size, AllocatorForMode::AllocatorIfExists);
 9023 
 9024     if (!allocator || node-&gt;transition()-&gt;previous-&gt;couldHaveIndexingHeader()) {
 9025         SpeculateCellOperand base(this, node-&gt;child1());
 9026 
 9027         GPRReg baseGPR = base.gpr();
 9028 
 9029         flushRegisters();
 9030 
 9031         GPRFlushedCallResult result(this);
 9032         callOperation(operationAllocateComplexPropertyStorageWithInitialCapacity, result.gpr(), baseGPR);
 9033         m_jit.exceptionCheck();
 9034 
 9035         storageResult(result.gpr(), node);
 9036         return;
 9037     }
 9038 
 9039     GPRTemporary scratch1(this);
 9040     GPRTemporary scratch2(this);
 9041     GPRTemporary scratch3(this);
 9042 
 9043     GPRReg scratchGPR1 = scratch1.gpr();
 9044     GPRReg scratchGPR2 = scratch2.gpr();
 9045     GPRReg scratchGPR3 = scratch3.gpr();
 9046 
 9047     JITCompiler::JumpList slowPath;
 9048     m_jit.emitAllocate(scratchGPR1, JITAllocator::constant(allocator), scratchGPR2, scratchGPR3, slowPath);
 9049     m_jit.addPtr(JITCompiler::TrustedImm32(size + sizeof(IndexingHeader)), scratchGPR1);
 9050 
 9051     addSlowPathGenerator(
 9052         slowPathCall(slowPath, this, operationAllocateSimplePropertyStorageWithInitialCapacity, scratchGPR1));
 9053 
 9054     for (ptrdiff_t offset = 0; offset &lt; static_cast&lt;ptrdiff_t&gt;(size); offset += sizeof(void*))
 9055         m_jit.storePtr(TrustedImmPtr(nullptr), JITCompiler::Address(scratchGPR1, -(offset + sizeof(JSValue) + sizeof(void*))));
 9056 
 9057     storageResult(scratchGPR1, node);
 9058 }
 9059 
 9060 void SpeculativeJIT::compileReallocatePropertyStorage(Node* node)
 9061 {
 9062     size_t oldSize = node-&gt;transition()-&gt;previous-&gt;outOfLineCapacity() * sizeof(JSValue);
 9063     size_t newSize = oldSize * outOfLineGrowthFactor;
 9064     ASSERT(newSize == node-&gt;transition()-&gt;next-&gt;outOfLineCapacity() * sizeof(JSValue));
 9065 
 9066     Allocator allocator = m_jit.vm()-&gt;jsValueGigacageAuxiliarySpace.allocatorForNonVirtual(newSize, AllocatorForMode::AllocatorIfExists);
 9067 
 9068     if (!allocator || node-&gt;transition()-&gt;previous-&gt;couldHaveIndexingHeader()) {
 9069         SpeculateCellOperand base(this, node-&gt;child1());
 9070 
 9071         GPRReg baseGPR = base.gpr();
 9072 
 9073         flushRegisters();
 9074 
 9075         GPRFlushedCallResult result(this);
 9076         callOperation(operationAllocateComplexPropertyStorage, result.gpr(), baseGPR, newSize / sizeof(JSValue));
 9077         m_jit.exceptionCheck();
 9078 
 9079         storageResult(result.gpr(), node);
 9080         return;
 9081     }
 9082 
 9083     StorageOperand oldStorage(this, node-&gt;child2());
 9084     GPRTemporary scratch1(this);
 9085     GPRTemporary scratch2(this);
 9086     GPRTemporary scratch3(this);
 9087 
 9088     GPRReg oldStorageGPR = oldStorage.gpr();
 9089     GPRReg scratchGPR1 = scratch1.gpr();
 9090     GPRReg scratchGPR2 = scratch2.gpr();
 9091     GPRReg scratchGPR3 = scratch3.gpr();
 9092 
 9093     JITCompiler::JumpList slowPath;
 9094     m_jit.emitAllocate(scratchGPR1, JITAllocator::constant(allocator), scratchGPR2, scratchGPR3, slowPath);
 9095 
 9096     m_jit.addPtr(JITCompiler::TrustedImm32(newSize + sizeof(IndexingHeader)), scratchGPR1);
 9097 
 9098     addSlowPathGenerator(
 9099         slowPathCall(slowPath, this, operationAllocateSimplePropertyStorage, scratchGPR1, newSize / sizeof(JSValue)));
 9100 
 9101     for (ptrdiff_t offset = oldSize; offset &lt; static_cast&lt;ptrdiff_t&gt;(newSize); offset += sizeof(void*))
 9102         m_jit.storePtr(TrustedImmPtr(nullptr), JITCompiler::Address(scratchGPR1, -(offset + sizeof(JSValue) + sizeof(void*))));
 9103 
 9104     // We have scratchGPR1 = new storage, scratchGPR2 = scratch
 9105     for (ptrdiff_t offset = 0; offset &lt; static_cast&lt;ptrdiff_t&gt;(oldSize); offset += sizeof(void*)) {
 9106         m_jit.loadPtr(JITCompiler::Address(oldStorageGPR, -(offset + sizeof(JSValue) + sizeof(void*))), scratchGPR2);
 9107         m_jit.storePtr(scratchGPR2, JITCompiler::Address(scratchGPR1, -(offset + sizeof(JSValue) + sizeof(void*))));
 9108     }
 9109 
 9110     storageResult(scratchGPR1, node);
 9111 }
 9112 
 9113 void SpeculativeJIT::compileNukeStructureAndSetButterfly(Node* node)
 9114 {
 9115     SpeculateCellOperand base(this, node-&gt;child1());
 9116     StorageOperand storage(this, node-&gt;child2());
 9117 
 9118     GPRReg baseGPR = base.gpr();
 9119     GPRReg storageGPR = storage.gpr();
 9120 
 9121     m_jit.nukeStructureAndStoreButterfly(*m_jit.vm(), storageGPR, baseGPR);
 9122 
 9123     noResult(node);
 9124 }
 9125 
 9126 void SpeculativeJIT::compileGetButterfly(Node* node)
 9127 {
 9128     SpeculateCellOperand base(this, node-&gt;child1());
 9129     GPRTemporary result(this, Reuse, base);
 9130 
 9131     GPRReg baseGPR = base.gpr();
 9132     GPRReg resultGPR = result.gpr();
 9133 
 9134     m_jit.loadPtr(JITCompiler::Address(baseGPR, JSObject::butterflyOffset()), resultGPR);
 9135 
 9136     storageResult(resultGPR, node);
 9137 }
 9138 
 9139 static void allocateTemporaryRegistersForSnippet(SpeculativeJIT* jit, Vector&lt;GPRTemporary&gt;&amp; gpHolders, Vector&lt;FPRTemporary&gt;&amp; fpHolders, Vector&lt;GPRReg&gt;&amp; gpScratch, Vector&lt;FPRReg&gt;&amp; fpScratch, Snippet&amp; snippet)
 9140 {
 9141     for (unsigned i = 0; i &lt; snippet.numGPScratchRegisters; ++i) {
 9142         GPRTemporary temporary(jit);
 9143         gpScratch.append(temporary.gpr());
 9144         gpHolders.append(WTFMove(temporary));
 9145     }
 9146 
 9147     for (unsigned i = 0; i &lt; snippet.numFPScratchRegisters; ++i) {
 9148         FPRTemporary temporary(jit);
 9149         fpScratch.append(temporary.fpr());
 9150         fpHolders.append(WTFMove(temporary));
 9151     }
 9152 }
 9153 
 9154 void SpeculativeJIT::compileCallDOM(Node* node)
 9155 {
 9156     const DOMJIT::Signature* signature = node-&gt;signature();
 9157 
 9158     // FIXME: We should have a way to call functions with the vector of registers.
 9159     // https://bugs.webkit.org/show_bug.cgi?id=163099
 9160     Vector&lt;Variant&lt;SpeculateCellOperand, SpeculateInt32Operand, SpeculateBooleanOperand&gt;, JSC_DOMJIT_SIGNATURE_MAX_ARGUMENTS_INCLUDING_THIS&gt; operands;
 9161     Vector&lt;GPRReg, JSC_DOMJIT_SIGNATURE_MAX_ARGUMENTS_INCLUDING_THIS&gt; regs;
 9162 
 9163     auto appendCell = [&amp;](Edge&amp; edge) {
 9164         SpeculateCellOperand operand(this, edge);
 9165         regs.append(operand.gpr());
 9166         operands.append(WTFMove(operand));
 9167     };
 9168 
 9169     auto appendString = [&amp;](Edge&amp; edge) {
 9170         SpeculateCellOperand operand(this, edge);
 9171         GPRReg gpr = operand.gpr();
 9172         regs.append(gpr);
 9173         speculateString(edge, gpr);
 9174         operands.append(WTFMove(operand));
 9175     };
 9176 
 9177     auto appendInt32 = [&amp;](Edge&amp; edge) {
 9178         SpeculateInt32Operand operand(this, edge);
 9179         regs.append(operand.gpr());
 9180         operands.append(WTFMove(operand));
 9181     };
 9182 
 9183     auto appendBoolean = [&amp;](Edge&amp; edge) {
 9184         SpeculateBooleanOperand operand(this, edge);
 9185         regs.append(operand.gpr());
 9186         operands.append(WTFMove(operand));
 9187     };
 9188 
 9189     unsigned index = 0;
 9190     m_jit.graph().doToChildren(node, [&amp;](Edge edge) {
 9191         if (!index)
 9192             appendCell(edge);
 9193         else {
 9194             switch (signature-&gt;arguments[index - 1]) {
 9195             case SpecString:
 9196                 appendString(edge);
 9197                 break;
 9198             case SpecInt32Only:
 9199                 appendInt32(edge);
 9200                 break;
 9201             case SpecBoolean:
 9202                 appendBoolean(edge);
 9203                 break;
 9204             default:
 9205                 RELEASE_ASSERT_NOT_REACHED();
 9206                 break;
 9207             }
 9208         }
 9209         ++index;
 9210     });
 9211 
 9212     JSValueRegsTemporary result(this);
 9213     JSValueRegs resultRegs = result.regs();
 9214 
 9215     flushRegisters();
 9216     assertIsTaggedWith(reinterpret_cast&lt;void*&gt;(signature-&gt;unsafeFunction), CFunctionPtrTag);
 9217     unsigned argumentCountIncludingThis = signature-&gt;argumentCount + 1;
 9218     switch (argumentCountIncludingThis) {
 9219     case 1:
 9220         callOperation(reinterpret_cast&lt;J_JITOperation_EP&gt;(signature-&gt;unsafeFunction), extractResult(resultRegs), regs[0]);
 9221         break;
 9222     case 2:
 9223         callOperation(reinterpret_cast&lt;J_JITOperation_EPP&gt;(signature-&gt;unsafeFunction), extractResult(resultRegs), regs[0], regs[1]);
 9224         break;
 9225     case 3:
 9226         callOperation(reinterpret_cast&lt;J_JITOperation_EPPP&gt;(signature-&gt;unsafeFunction), extractResult(resultRegs), regs[0], regs[1], regs[2]);
 9227         break;
 9228     default:
 9229         RELEASE_ASSERT_NOT_REACHED();
 9230         break;
 9231     }
 9232 
 9233     m_jit.exceptionCheck();
 9234     jsValueResult(resultRegs, node);
 9235 }
 9236 
 9237 void SpeculativeJIT::compileCallDOMGetter(Node* node)
 9238 {
 9239     DOMJIT::CallDOMGetterSnippet* snippet = node-&gt;callDOMGetterData()-&gt;snippet;
 9240     if (!snippet) {
 9241         FunctionPtr&lt;OperationPtrTag&gt; getter = node-&gt;callDOMGetterData()-&gt;customAccessorGetter;
 9242         SpeculateCellOperand base(this, node-&gt;child1());
 9243         JSValueRegsTemporary result(this);
 9244 
 9245         JSValueRegs resultRegs = result.regs();
 9246         GPRReg baseGPR = base.gpr();
 9247 
 9248         flushRegisters();
 9249         m_jit.setupArguments&lt;J_JITOperation_EJI&gt;(CCallHelpers::CellValue(baseGPR), identifierUID(node-&gt;callDOMGetterData()-&gt;identifierNumber));
 9250         m_jit.storePtr(GPRInfo::callFrameRegister, &amp;m_jit.vm()-&gt;topCallFrame);
 9251         m_jit.emitStoreCodeOrigin(m_currentNode-&gt;origin.semantic);
 9252         m_jit.appendCall(getter.retagged&lt;CFunctionPtrTag&gt;());
 9253         m_jit.setupResults(resultRegs);
 9254 
 9255         m_jit.exceptionCheck();
 9256         jsValueResult(resultRegs, node);
 9257         return;
 9258     }
 9259 
 9260     Vector&lt;GPRReg&gt; gpScratch;
 9261     Vector&lt;FPRReg&gt; fpScratch;
 9262     Vector&lt;SnippetParams::Value&gt; regs;
 9263 
 9264     JSValueRegsTemporary result(this);
 9265     regs.append(result.regs());
 9266 
 9267     Edge&amp; baseEdge = node-&gt;child1();
 9268     SpeculateCellOperand base(this, baseEdge);
 9269     regs.append(SnippetParams::Value(base.gpr(), m_state.forNode(baseEdge).value()));
 9270 
 9271     Optional&lt;SpeculateCellOperand&gt; globalObject;
 9272     if (snippet-&gt;requireGlobalObject) {
 9273         Edge&amp; globalObjectEdge = node-&gt;child2();
 9274         globalObject.emplace(this, globalObjectEdge);
 9275         regs.append(SnippetParams::Value(globalObject-&gt;gpr(), m_state.forNode(globalObjectEdge).value()));
 9276     }
 9277 
 9278     Vector&lt;GPRTemporary&gt; gpTempraries;
 9279     Vector&lt;FPRTemporary&gt; fpTempraries;
 9280     allocateTemporaryRegistersForSnippet(this, gpTempraries, fpTempraries, gpScratch, fpScratch, *snippet);
 9281     SnippetParams params(this, WTFMove(regs), WTFMove(gpScratch), WTFMove(fpScratch));
 9282     snippet-&gt;generator()-&gt;run(m_jit, params);
 9283     jsValueResult(result.regs(), node);
 9284 }
 9285 
 9286 void SpeculativeJIT::compileCheckSubClass(Node* node)
 9287 {
 9288     const ClassInfo* classInfo = node-&gt;classInfo();
 9289     if (!classInfo-&gt;checkSubClassSnippet) {
 9290         SpeculateCellOperand base(this, node-&gt;child1());
 9291         GPRTemporary other(this);
 9292         GPRTemporary specified(this);
 9293 
 9294         GPRReg baseGPR = base.gpr();
 9295         GPRReg otherGPR = other.gpr();
 9296         GPRReg specifiedGPR = specified.gpr();
 9297 
 9298         m_jit.emitLoadStructure(*m_jit.vm(), baseGPR, otherGPR, specifiedGPR);
 9299         m_jit.loadPtr(CCallHelpers::Address(otherGPR, Structure::classInfoOffset()), otherGPR);
 9300         m_jit.move(CCallHelpers::TrustedImmPtr(node-&gt;classInfo()), specifiedGPR);
 9301 
 9302         CCallHelpers::Label loop = m_jit.label();
 9303         auto done = m_jit.branchPtr(CCallHelpers::Equal, otherGPR, specifiedGPR);
 9304         m_jit.loadPtr(CCallHelpers::Address(otherGPR, ClassInfo::offsetOfParentClass()), otherGPR);
 9305         m_jit.branchTestPtr(CCallHelpers::NonZero, otherGPR).linkTo(loop, &amp;m_jit);
 9306         speculationCheck(BadType, JSValueSource::unboxedCell(baseGPR), node-&gt;child1(), m_jit.jump());
 9307         done.link(&amp;m_jit);
 9308         noResult(node);
 9309         return;
 9310     }
 9311 
 9312     Ref&lt;Snippet&gt; snippet = classInfo-&gt;checkSubClassSnippet();
 9313 
 9314     Vector&lt;GPRReg&gt; gpScratch;
 9315     Vector&lt;FPRReg&gt; fpScratch;
 9316     Vector&lt;SnippetParams::Value&gt; regs;
 9317 
 9318     SpeculateCellOperand base(this, node-&gt;child1());
 9319     GPRReg baseGPR = base.gpr();
 9320     regs.append(SnippetParams::Value(baseGPR, m_state.forNode(node-&gt;child1()).value()));
 9321 
 9322     Vector&lt;GPRTemporary&gt; gpTempraries;
 9323     Vector&lt;FPRTemporary&gt; fpTempraries;
 9324     allocateTemporaryRegistersForSnippet(this, gpTempraries, fpTempraries, gpScratch, fpScratch, snippet.get());
 9325 
 9326     SnippetParams params(this, WTFMove(regs), WTFMove(gpScratch), WTFMove(fpScratch));
 9327     CCallHelpers::JumpList failureCases = snippet-&gt;generator()-&gt;run(m_jit, params);
 9328     speculationCheck(BadType, JSValueSource::unboxedCell(baseGPR), node-&gt;child1(), failureCases);
 9329     noResult(node);
 9330 }
 9331 
 9332 GPRReg SpeculativeJIT::temporaryRegisterForPutByVal(GPRTemporary&amp; temporary, ArrayMode arrayMode)
 9333 {
 9334     if (!putByValWillNeedExtraRegister(arrayMode))
 9335         return InvalidGPRReg;
 9336 
 9337     GPRTemporary realTemporary(this);
 9338     temporary.adopt(realTemporary);
 9339     return temporary.gpr();
 9340 }
 9341 
 9342 void SpeculativeJIT::compileToStringOrCallStringConstructorOrStringValueOf(Node* node)
 9343 {
 9344     ASSERT(node-&gt;op() != StringValueOf || node-&gt;child1().useKind() == UntypedUse);
 9345     switch (node-&gt;child1().useKind()) {
 9346     case NotCellUse: {
 9347         JSValueOperand op1(this, node-&gt;child1(), ManualOperandSpeculation);
 9348         JSValueRegs op1Regs = op1.jsValueRegs();
 9349 
 9350         GPRFlushedCallResult result(this);
 9351         GPRReg resultGPR = result.gpr();
 9352 
 9353         speculateNotCell(node-&gt;child1(), op1Regs);
 9354 
 9355         flushRegisters();
 9356 
 9357         if (node-&gt;op() == ToString)
 9358             callOperation(operationToString, resultGPR, op1Regs);
 9359         else {
 9360             ASSERT(node-&gt;op() == CallStringConstructor);
 9361             callOperation(operationCallStringConstructor, resultGPR, op1Regs);
 9362         }
 9363         m_jit.exceptionCheck();
 9364         cellResult(resultGPR, node);
 9365         return;
 9366     }
 9367 
 9368     case UntypedUse: {
 9369         JSValueOperand op1(this, node-&gt;child1());
 9370         JSValueRegs op1Regs = op1.jsValueRegs();
 9371         GPRReg op1PayloadGPR = op1Regs.payloadGPR();
 9372 
 9373         GPRFlushedCallResult result(this);
 9374         GPRReg resultGPR = result.gpr();
 9375 
 9376         flushRegisters();
 9377 
 9378         JITCompiler::Jump done;
 9379         if (node-&gt;child1()-&gt;prediction() &amp; SpecString) {
 9380             JITCompiler::Jump slowPath1 = m_jit.branchIfNotCell(op1.jsValueRegs());
 9381             JITCompiler::Jump slowPath2 = m_jit.branchIfNotString(op1PayloadGPR);
 9382             m_jit.move(op1PayloadGPR, resultGPR);
 9383             done = m_jit.jump();
 9384             slowPath1.link(&amp;m_jit);
 9385             slowPath2.link(&amp;m_jit);
 9386         }
 9387         if (node-&gt;op() == ToString)
 9388             callOperation(operationToString, resultGPR, op1Regs);
 9389         else if (node-&gt;op() == StringValueOf)
 9390             callOperation(operationStringValueOf, resultGPR, op1Regs);
 9391         else {
 9392             ASSERT(node-&gt;op() == CallStringConstructor);
 9393             callOperation(operationCallStringConstructor, resultGPR, op1Regs);
 9394         }
 9395         m_jit.exceptionCheck();
 9396         if (done.isSet())
 9397             done.link(&amp;m_jit);
 9398         cellResult(resultGPR, node);
 9399         return;
 9400     }
 9401 
 9402     case Int32Use:
 9403     case Int52RepUse:
 9404     case DoubleRepUse:
 9405         compileNumberToStringWithValidRadixConstant(node, 10);
 9406         return;
 9407 
 9408     default:
 9409         break;
 9410     }
 9411 
 9412     SpeculateCellOperand op1(this, node-&gt;child1());
 9413     GPRReg op1GPR = op1.gpr();
 9414 
 9415     switch (node-&gt;child1().useKind()) {
 9416     case StringObjectUse: {
 9417         GPRTemporary result(this);
 9418         GPRReg resultGPR = result.gpr();
 9419 
 9420         speculateStringObject(node-&gt;child1(), op1GPR);
 9421 
 9422         m_jit.loadPtr(JITCompiler::Address(op1GPR, JSWrapperObject::internalValueCellOffset()), resultGPR);
 9423         cellResult(resultGPR, node);
 9424         break;
 9425     }
 9426 
 9427     case StringOrStringObjectUse: {
 9428         GPRTemporary result(this);
 9429         GPRReg resultGPR = result.gpr();
 9430 
 9431         m_jit.load8(JITCompiler::Address(op1GPR, JSCell::typeInfoTypeOffset()), resultGPR);
 9432         JITCompiler::Jump isString = m_jit.branch32(JITCompiler::Equal, resultGPR, TrustedImm32(StringType));
 9433 
 9434         speculationCheck(BadType, JSValueSource::unboxedCell(op1GPR), node-&gt;child1().node(), m_jit.branch32(JITCompiler::NotEqual, resultGPR, TrustedImm32(StringObjectType)));
 9435         m_jit.loadPtr(JITCompiler::Address(op1GPR, JSWrapperObject::internalValueCellOffset()), resultGPR);
 9436         JITCompiler::Jump done = m_jit.jump();
 9437 
 9438         isString.link(&amp;m_jit);
 9439         m_jit.move(op1GPR, resultGPR);
 9440         done.link(&amp;m_jit);
 9441 
 9442         m_interpreter.filter(node-&gt;child1(), SpecString | SpecStringObject);
 9443 
 9444         cellResult(resultGPR, node);
 9445         break;
 9446     }
 9447 
 9448     case CellUse: {
 9449         GPRFlushedCallResult result(this);
 9450         GPRReg resultGPR = result.gpr();
 9451 
 9452         // We flush registers instead of silent spill/fill because in this mode we
 9453         // believe that most likely the input is not a string, and we need to take
 9454         // slow path.
 9455         flushRegisters();
 9456         JITCompiler::Jump done;
 9457         if (node-&gt;child1()-&gt;prediction() &amp; SpecString) {
 9458             JITCompiler::Jump needCall = m_jit.branchIfNotString(op1GPR);
 9459             m_jit.move(op1GPR, resultGPR);
 9460             done = m_jit.jump();
 9461             needCall.link(&amp;m_jit);
 9462         }
 9463         if (node-&gt;op() == ToString)
 9464             callOperation(operationToStringOnCell, resultGPR, op1GPR);
 9465         else {
 9466             ASSERT(node-&gt;op() == CallStringConstructor);
 9467             callOperation(operationCallStringConstructorOnCell, resultGPR, op1GPR);
 9468         }
 9469         m_jit.exceptionCheck();
 9470         if (done.isSet())
 9471             done.link(&amp;m_jit);
 9472         cellResult(resultGPR, node);
 9473         break;
 9474     }
 9475 
 9476     default:
 9477         RELEASE_ASSERT_NOT_REACHED();
 9478     }
 9479 }
 9480 
 9481 void SpeculativeJIT::compileNumberToStringWithValidRadixConstant(Node* node)
 9482 {
 9483     compileNumberToStringWithValidRadixConstant(node, node-&gt;validRadixConstant());
 9484 }
 9485 
 9486 void SpeculativeJIT::compileNumberToStringWithValidRadixConstant(Node* node, int32_t radix)
 9487 {
 9488     auto callToString = [&amp;] (auto operation, GPRReg resultGPR, auto valueReg) {
 9489         flushRegisters();
 9490         callOperation(operation, resultGPR, valueReg, TrustedImm32(radix));
 9491         m_jit.exceptionCheck();
 9492         cellResult(resultGPR, node);
 9493     };
 9494 
 9495     switch (node-&gt;child1().useKind()) {
 9496     case Int32Use: {
 9497         SpeculateStrictInt32Operand value(this, node-&gt;child1());
 9498         GPRFlushedCallResult result(this);
 9499         callToString(operationInt32ToStringWithValidRadix, result.gpr(), value.gpr());
 9500         break;
 9501     }
 9502 
 9503 #if USE(JSVALUE64)
 9504     case Int52RepUse: {
 9505         SpeculateStrictInt52Operand value(this, node-&gt;child1());
 9506         GPRFlushedCallResult result(this);
 9507         callToString(operationInt52ToStringWithValidRadix, result.gpr(), value.gpr());
 9508         break;
 9509     }
 9510 #endif
 9511 
 9512     case DoubleRepUse: {
 9513         SpeculateDoubleOperand value(this, node-&gt;child1());
 9514         GPRFlushedCallResult result(this);
 9515         callToString(operationDoubleToStringWithValidRadix, result.gpr(), value.fpr());
 9516         break;
 9517     }
 9518 
 9519     default:
 9520         RELEASE_ASSERT_NOT_REACHED();
 9521     }
 9522 }
 9523 
 9524 void SpeculativeJIT::compileNumberToStringWithRadix(Node* node)
 9525 {
 9526     bool validRadixIsGuaranteed = false;
 9527     if (node-&gt;child2()-&gt;isInt32Constant()) {
 9528         int32_t radix = node-&gt;child2()-&gt;asInt32();
 9529         if (radix &gt;= 2 &amp;&amp; radix &lt;= 36)
 9530             validRadixIsGuaranteed = true;
 9531     }
 9532 
 9533     auto callToString = [&amp;] (auto operation, GPRReg resultGPR, auto valueReg, GPRReg radixGPR) {
 9534         flushRegisters();
 9535         callOperation(operation, resultGPR, valueReg, radixGPR);
 9536         m_jit.exceptionCheck();
 9537         cellResult(resultGPR, node);
 9538     };
 9539 
 9540     switch (node-&gt;child1().useKind()) {
 9541     case Int32Use: {
 9542         SpeculateStrictInt32Operand value(this, node-&gt;child1());
 9543         SpeculateStrictInt32Operand radix(this, node-&gt;child2());
 9544         GPRFlushedCallResult result(this);
 9545         callToString(validRadixIsGuaranteed ? operationInt32ToStringWithValidRadix : operationInt32ToString, result.gpr(), value.gpr(), radix.gpr());
 9546         break;
 9547     }
 9548 
 9549 #if USE(JSVALUE64)
 9550     case Int52RepUse: {
 9551         SpeculateStrictInt52Operand value(this, node-&gt;child1());
 9552         SpeculateStrictInt32Operand radix(this, node-&gt;child2());
 9553         GPRFlushedCallResult result(this);
 9554         callToString(validRadixIsGuaranteed ? operationInt52ToStringWithValidRadix : operationInt52ToString, result.gpr(), value.gpr(), radix.gpr());
 9555         break;
 9556     }
 9557 #endif
 9558 
 9559     case DoubleRepUse: {
 9560         SpeculateDoubleOperand value(this, node-&gt;child1());
 9561         SpeculateStrictInt32Operand radix(this, node-&gt;child2());
 9562         GPRFlushedCallResult result(this);
 9563         callToString(validRadixIsGuaranteed ? operationDoubleToStringWithValidRadix : operationDoubleToString, result.gpr(), value.fpr(), radix.gpr());
 9564         break;
 9565     }
 9566 
 9567     default:
 9568         RELEASE_ASSERT_NOT_REACHED();
 9569     }
 9570 }
 9571 
 9572 void SpeculativeJIT::compileNewStringObject(Node* node)
 9573 {
 9574     SpeculateCellOperand operand(this, node-&gt;child1());
 9575 
 9576     GPRTemporary result(this);
 9577     GPRTemporary scratch1(this);
 9578     GPRTemporary scratch2(this);
 9579 
 9580     GPRReg operandGPR = operand.gpr();
 9581     GPRReg resultGPR = result.gpr();
 9582     GPRReg scratch1GPR = scratch1.gpr();
 9583     GPRReg scratch2GPR = scratch2.gpr();
 9584 
 9585     JITCompiler::JumpList slowPath;
 9586 
 9587     auto butterfly = TrustedImmPtr(nullptr);
 9588     emitAllocateJSObject&lt;StringObject&gt;(
 9589         resultGPR, TrustedImmPtr(node-&gt;structure()), butterfly, scratch1GPR, scratch2GPR,
 9590         slowPath);
 9591 
 9592     m_jit.storePtr(
 9593         TrustedImmPtr(StringObject::info()),
 9594         JITCompiler::Address(resultGPR, JSDestructibleObject::classInfoOffset()));
 9595 #if USE(JSVALUE64)
 9596     m_jit.store64(
 9597         operandGPR, JITCompiler::Address(resultGPR, JSWrapperObject::internalValueOffset()));
 9598 #else
 9599     m_jit.store32(
 9600         TrustedImm32(JSValue::CellTag),
 9601         JITCompiler::Address(resultGPR, JSWrapperObject::internalValueOffset() + OBJECT_OFFSETOF(JSValue, u.asBits.tag)));
 9602     m_jit.store32(
 9603         operandGPR,
 9604         JITCompiler::Address(resultGPR, JSWrapperObject::internalValueOffset() + OBJECT_OFFSETOF(JSValue, u.asBits.payload)));
 9605 #endif
 9606 
 9607     m_jit.mutatorFence(*m_jit.vm());
 9608 
 9609     addSlowPathGenerator(slowPathCall(
 9610         slowPath, this, operationNewStringObject, resultGPR, operandGPR, node-&gt;structure()));
 9611 
 9612     cellResult(resultGPR, node);
 9613 }
 9614 
 9615 void SpeculativeJIT::compileNewSymbol(Node* node)
 9616 {
 9617     if (!node-&gt;child1()) {
 9618         flushRegisters();
 9619         GPRFlushedCallResult result(this);
 9620         GPRReg resultGPR = result.gpr();
 9621         callOperation(operationNewSymbol, resultGPR);
 9622         m_jit.exceptionCheck();
 9623         cellResult(resultGPR, node);
 9624         return;
 9625     }
 9626 
 9627 
 9628     ASSERT(node-&gt;child1().useKind() == KnownStringUse);
 9629     SpeculateCellOperand operand(this, node-&gt;child1());
 9630 
 9631     GPRReg stringGPR = operand.gpr();
 9632 
 9633     flushRegisters();
 9634     GPRFlushedCallResult result(this);
 9635     GPRReg resultGPR = result.gpr();
 9636     callOperation(operationNewSymbolWithDescription, resultGPR, stringGPR);
 9637     m_jit.exceptionCheck();
 9638     cellResult(resultGPR, node);
 9639 }
 9640 
 9641 void SpeculativeJIT::compileNewTypedArrayWithSize(Node* node)
 9642 {
 9643     JSGlobalObject* globalObject = m_jit.graph().globalObjectFor(node-&gt;origin.semantic);
 9644     auto typedArrayType = node-&gt;typedArrayType();
 9645     RegisteredStructure structure = m_jit.graph().registerStructure(globalObject-&gt;typedArrayStructureConcurrently(typedArrayType));
 9646     RELEASE_ASSERT(structure.get());
 9647 
 9648     SpeculateInt32Operand size(this, node-&gt;child1());
 9649     GPRReg sizeGPR = size.gpr();
 9650 
 9651     GPRTemporary result(this);
 9652     GPRTemporary storage(this);
 9653     GPRTemporary scratch(this);
 9654     GPRTemporary scratch2(this);
 9655     GPRReg resultGPR = result.gpr();
 9656     GPRReg storageGPR = storage.gpr();
 9657     GPRReg scratchGPR = scratch.gpr();
 9658     GPRReg scratchGPR2 = scratch2.gpr();
 9659 
 9660     JITCompiler::JumpList slowCases;
 9661 
 9662     m_jit.move(TrustedImmPtr(nullptr), storageGPR);
 9663 
 9664     slowCases.append(m_jit.branch32(
 9665         MacroAssembler::Above, sizeGPR, TrustedImm32(JSArrayBufferView::fastSizeLimit)));
 9666 
 9667     m_jit.move(sizeGPR, scratchGPR);
 9668     m_jit.lshift32(TrustedImm32(logElementSize(typedArrayType)), scratchGPR);
 9669     if (elementSize(typedArrayType) &lt; 8) {
 9670         m_jit.add32(TrustedImm32(7), scratchGPR);
 9671         m_jit.and32(TrustedImm32(~7), scratchGPR);
 9672     }
 9673     m_jit.emitAllocateVariableSized(
 9674         storageGPR, m_jit.vm()-&gt;primitiveGigacageAuxiliarySpace, scratchGPR, scratchGPR,
 9675         scratchGPR2, slowCases);
 9676 
 9677     MacroAssembler::Jump done = m_jit.branchTest32(MacroAssembler::Zero, sizeGPR);
 9678     m_jit.move(sizeGPR, scratchGPR);
 9679     if (elementSize(typedArrayType) != 4) {
 9680         if (elementSize(typedArrayType) &gt; 4)
 9681             m_jit.lshift32(TrustedImm32(logElementSize(typedArrayType) - 2), scratchGPR);
 9682         else {
 9683             if (elementSize(typedArrayType) &gt; 1)
 9684                 m_jit.lshift32(TrustedImm32(logElementSize(typedArrayType)), scratchGPR);
 9685             m_jit.add32(TrustedImm32(3), scratchGPR);
 9686             m_jit.urshift32(TrustedImm32(2), scratchGPR);
 9687         }
 9688     }
 9689     MacroAssembler::Label loop = m_jit.label();
 9690     m_jit.sub32(TrustedImm32(1), scratchGPR);
 9691     m_jit.store32(
 9692         TrustedImm32(0),
 9693         MacroAssembler::BaseIndex(storageGPR, scratchGPR, MacroAssembler::TimesFour));
 9694     m_jit.branchTest32(MacroAssembler::NonZero, scratchGPR).linkTo(loop, &amp;m_jit);
 9695     done.link(&amp;m_jit);
 9696 
 9697     auto butterfly = TrustedImmPtr(nullptr);
 9698     emitAllocateJSObject&lt;JSArrayBufferView&gt;(
 9699         resultGPR, TrustedImmPtr(structure), butterfly, scratchGPR, scratchGPR2,
 9700         slowCases);
 9701 
 9702     m_jit.storePtr(
 9703         storageGPR,
 9704         MacroAssembler::Address(resultGPR, JSArrayBufferView::offsetOfVector()));
 9705     m_jit.store32(
 9706         sizeGPR,
 9707         MacroAssembler::Address(resultGPR, JSArrayBufferView::offsetOfLength()));
 9708     m_jit.store32(
 9709         TrustedImm32(FastTypedArray),
 9710         MacroAssembler::Address(resultGPR, JSArrayBufferView::offsetOfMode()));
 9711 
 9712     m_jit.mutatorFence(*m_jit.vm());
 9713 
 9714     addSlowPathGenerator(slowPathCall(
 9715         slowCases, this, operationNewTypedArrayWithSizeForType(typedArrayType),
 9716         resultGPR, structure, sizeGPR, storageGPR));
 9717 
 9718     cellResult(resultGPR, node);
 9719 }
 9720 
 9721 void SpeculativeJIT::compileNewRegexp(Node* node)
 9722 {
 9723     RegExp* regexp = node-&gt;castOperand&lt;RegExp*&gt;();
 9724     ASSERT(regexp-&gt;isValid());
 9725 
 9726     GPRTemporary result(this);
 9727     GPRTemporary scratch1(this);
 9728     GPRTemporary scratch2(this);
 9729     JSValueOperand lastIndex(this, node-&gt;child1());
 9730 
 9731     GPRReg resultGPR = result.gpr();
 9732     GPRReg scratch1GPR = scratch1.gpr();
 9733     GPRReg scratch2GPR = scratch2.gpr();
 9734     JSValueRegs lastIndexRegs = lastIndex.jsValueRegs();
 9735 
 9736     JITCompiler::JumpList slowPath;
 9737 
 9738     auto structure = m_jit.graph().registerStructure(m_jit.graph().globalObjectFor(node-&gt;origin.semantic)-&gt;regExpStructure());
 9739     auto butterfly = TrustedImmPtr(nullptr);
 9740     emitAllocateJSObject&lt;RegExpObject&gt;(resultGPR, TrustedImmPtr(structure), butterfly, scratch1GPR, scratch2GPR, slowPath);
 9741 
 9742     m_jit.storePtr(
 9743         TrustedImmPtr(node-&gt;cellOperand()),
 9744         CCallHelpers::Address(resultGPR, RegExpObject::offsetOfRegExp()));
 9745     m_jit.storeValue(lastIndexRegs, CCallHelpers::Address(resultGPR, RegExpObject::offsetOfLastIndex()));
 9746     m_jit.store8(TrustedImm32(true), CCallHelpers::Address(resultGPR, RegExpObject::offsetOfLastIndexIsWritable()));
 9747     m_jit.mutatorFence(*m_jit.vm());
 9748 
 9749     addSlowPathGenerator(slowPathCall(slowPath, this, operationNewRegexpWithLastIndex, resultGPR, regexp, lastIndexRegs));
 9750 
 9751     cellResult(resultGPR, node);
 9752 }
 9753 
 9754 void SpeculativeJIT::speculateCellTypeWithoutTypeFiltering(
 9755     Edge edge, GPRReg cellGPR, JSType jsType)
 9756 {
 9757     speculationCheck(
 9758         BadType, JSValueSource::unboxedCell(cellGPR), edge,
 9759         m_jit.branchIfNotType(cellGPR, jsType));
 9760 }
 9761 
 9762 void SpeculativeJIT::speculateCellType(
 9763     Edge edge, GPRReg cellGPR, SpeculatedType specType, JSType jsType)
 9764 {
 9765     DFG_TYPE_CHECK(
 9766         JSValueSource::unboxedCell(cellGPR), edge, specType,
 9767         m_jit.branchIfNotType(cellGPR, jsType));
 9768 }
 9769 
 9770 void SpeculativeJIT::speculateInt32(Edge edge)
 9771 {
 9772     if (!needsTypeCheck(edge, SpecInt32Only))
 9773         return;
 9774 
 9775     (SpeculateInt32Operand(this, edge)).gpr();
 9776 }
 9777 
 9778 void SpeculativeJIT::speculateNumber(Edge edge)
 9779 {
 9780     if (!needsTypeCheck(edge, SpecBytecodeNumber))
 9781         return;
 9782 
 9783     JSValueOperand value(this, edge, ManualOperandSpeculation);
 9784 #if USE(JSVALUE64)
 9785     GPRReg gpr = value.gpr();
 9786     typeCheck(
 9787         JSValueRegs(gpr), edge, SpecBytecodeNumber,
 9788         m_jit.branchIfNotNumber(gpr));
 9789 #else
 9790     IGNORE_WARNINGS_BEGIN(&quot;enum-compare&quot;)
 9791     static_assert(JSValue::Int32Tag &gt;= JSValue::LowestTag, &quot;Int32Tag is included in &gt;= JSValue::LowestTag range.&quot;);
 9792     IGNORE_WARNINGS_END
 9793     GPRReg tagGPR = value.tagGPR();
 9794     DFG_TYPE_CHECK(
 9795         value.jsValueRegs(), edge, ~SpecInt32Only,
 9796         m_jit.branchIfInt32(tagGPR));
 9797     DFG_TYPE_CHECK(
 9798         value.jsValueRegs(), edge, SpecBytecodeNumber,
 9799         m_jit.branch32(MacroAssembler::AboveOrEqual, tagGPR, TrustedImm32(JSValue::LowestTag)));
 9800 #endif
 9801 }
 9802 
 9803 void SpeculativeJIT::speculateRealNumber(Edge edge)
 9804 {
 9805     if (!needsTypeCheck(edge, SpecBytecodeRealNumber))
 9806         return;
 9807 
 9808     JSValueOperand op1(this, edge, ManualOperandSpeculation);
 9809     FPRTemporary result(this);
 9810 
 9811     JSValueRegs op1Regs = op1.jsValueRegs();
 9812     FPRReg resultFPR = result.fpr();
 9813 
 9814 #if USE(JSVALUE64)
 9815     GPRTemporary temp(this);
 9816     GPRReg tempGPR = temp.gpr();
 9817     m_jit.unboxDoubleWithoutAssertions(op1Regs.gpr(), tempGPR, resultFPR);
 9818 #else
 9819     FPRTemporary temp(this);
 9820     FPRReg tempFPR = temp.fpr();
 9821     unboxDouble(op1Regs.tagGPR(), op1Regs.payloadGPR(), resultFPR, tempFPR);
 9822 #endif
 9823 
 9824     JITCompiler::Jump done = m_jit.branchIfNotNaN(resultFPR);
 9825 
 9826     typeCheck(op1Regs, edge, SpecBytecodeRealNumber, m_jit.branchIfNotInt32(op1Regs));
 9827 
 9828     done.link(&amp;m_jit);
 9829 }
 9830 
 9831 void SpeculativeJIT::speculateDoubleRepReal(Edge edge)
 9832 {
 9833     if (!needsTypeCheck(edge, SpecDoubleReal))
 9834         return;
 9835 
 9836     SpeculateDoubleOperand operand(this, edge);
 9837     FPRReg fpr = operand.fpr();
 9838     typeCheck(
 9839         JSValueRegs(), edge, SpecDoubleReal,
 9840         m_jit.branchIfNaN(fpr));
 9841 }
 9842 
 9843 void SpeculativeJIT::speculateBoolean(Edge edge)
 9844 {
 9845     if (!needsTypeCheck(edge, SpecBoolean))
 9846         return;
 9847 
 9848     (SpeculateBooleanOperand(this, edge)).gpr();
 9849 }
 9850 
 9851 void SpeculativeJIT::speculateCell(Edge edge)
 9852 {
 9853     if (!needsTypeCheck(edge, SpecCellCheck))
 9854         return;
 9855 
 9856     (SpeculateCellOperand(this, edge)).gpr();
 9857 }
 9858 
 9859 void SpeculativeJIT::speculateCellOrOther(Edge edge)
 9860 {
 9861     if (!needsTypeCheck(edge, SpecCellCheck | SpecOther))
 9862         return;
 9863 
 9864     JSValueOperand operand(this, edge, ManualOperandSpeculation);
 9865     GPRTemporary temp(this);
 9866     GPRReg tempGPR = temp.gpr();
 9867 
 9868     MacroAssembler::Jump ok = m_jit.branchIfCell(operand.jsValueRegs());
 9869     DFG_TYPE_CHECK(
 9870         operand.jsValueRegs(), edge, SpecCellCheck | SpecOther,
 9871         m_jit.branchIfNotOther(operand.jsValueRegs(), tempGPR));
 9872     ok.link(&amp;m_jit);
 9873 }
 9874 
 9875 void SpeculativeJIT::speculateObject(Edge edge, GPRReg cell)
 9876 {
 9877     DFG_TYPE_CHECK(JSValueSource::unboxedCell(cell), edge, SpecObject, m_jit.branchIfNotObject(cell));
 9878 }
 9879 
 9880 void SpeculativeJIT::speculateObject(Edge edge)
 9881 {
 9882     if (!needsTypeCheck(edge, SpecObject))
 9883         return;
 9884 
 9885     SpeculateCellOperand operand(this, edge);
 9886     speculateObject(edge, operand.gpr());
 9887 }
 9888 
 9889 void SpeculativeJIT::speculateFunction(Edge edge, GPRReg cell)
 9890 {
 9891     speculateCellType(edge, cell, SpecFunction, JSFunctionType);
 9892 }
 9893 
 9894 void SpeculativeJIT::speculateFunction(Edge edge)
 9895 {
 9896     if (!needsTypeCheck(edge, SpecFunction))
 9897         return;
 9898 
 9899     SpeculateCellOperand operand(this, edge);
 9900     speculateFunction(edge, operand.gpr());
 9901 }
 9902 
 9903 void SpeculativeJIT::speculateFinalObject(Edge edge, GPRReg cell)
 9904 {
 9905     speculateCellType(edge, cell, SpecFinalObject, FinalObjectType);
 9906 }
 9907 
 9908 void SpeculativeJIT::speculateFinalObject(Edge edge)
 9909 {
 9910     if (!needsTypeCheck(edge, SpecFinalObject))
 9911         return;
 9912 
 9913     SpeculateCellOperand operand(this, edge);
 9914     speculateFinalObject(edge, operand.gpr());
 9915 }
 9916 
 9917 void SpeculativeJIT::speculateRegExpObject(Edge edge, GPRReg cell)
 9918 {
 9919     speculateCellType(edge, cell, SpecRegExpObject, RegExpObjectType);
 9920 }
 9921 
 9922 void SpeculativeJIT::speculateRegExpObject(Edge edge)
 9923 {
 9924     if (!needsTypeCheck(edge, SpecRegExpObject))
 9925         return;
 9926 
 9927     SpeculateCellOperand operand(this, edge);
 9928     speculateRegExpObject(edge, operand.gpr());
 9929 }
 9930 
 9931 void SpeculativeJIT::speculateArray(Edge edge, GPRReg cell)
 9932 {
 9933     speculateCellType(edge, cell, SpecArray, ArrayType);
 9934 }
 9935 
 9936 void SpeculativeJIT::speculateArray(Edge edge)
 9937 {
 9938     if (!needsTypeCheck(edge, SpecArray))
 9939         return;
 9940 
 9941     SpeculateCellOperand operand(this, edge);
 9942     speculateArray(edge, operand.gpr());
 9943 }
 9944 
 9945 void SpeculativeJIT::speculateProxyObject(Edge edge, GPRReg cell)
 9946 {
 9947     speculateCellType(edge, cell, SpecProxyObject, ProxyObjectType);
 9948 }
 9949 
 9950 void SpeculativeJIT::speculateProxyObject(Edge edge)
 9951 {
 9952     if (!needsTypeCheck(edge, SpecProxyObject))
 9953         return;
 9954 
 9955     SpeculateCellOperand operand(this, edge);
 9956     speculateProxyObject(edge, operand.gpr());
 9957 }
 9958 
 9959 void SpeculativeJIT::speculateDerivedArray(Edge edge, GPRReg cell)
 9960 {
 9961     speculateCellType(edge, cell, SpecDerivedArray, DerivedArrayType);
 9962 }
 9963 
 9964 void SpeculativeJIT::speculateDerivedArray(Edge edge)
 9965 {
 9966     if (!needsTypeCheck(edge, SpecDerivedArray))
 9967         return;
 9968 
 9969     SpeculateCellOperand operand(this, edge);
 9970     speculateDerivedArray(edge, operand.gpr());
 9971 }
 9972 
 9973 void SpeculativeJIT::speculateMapObject(Edge edge, GPRReg cell)
 9974 {
 9975     speculateCellType(edge, cell, SpecMapObject, JSMapType);
 9976 }
 9977 
 9978 void SpeculativeJIT::speculateMapObject(Edge edge)
 9979 {
 9980     if (!needsTypeCheck(edge, SpecMapObject))
 9981         return;
 9982 
 9983     SpeculateCellOperand operand(this, edge);
 9984     speculateMapObject(edge, operand.gpr());
 9985 }
 9986 
 9987 void SpeculativeJIT::speculateSetObject(Edge edge, GPRReg cell)
 9988 {
 9989     speculateCellType(edge, cell, SpecSetObject, JSSetType);
 9990 }
 9991 
 9992 void SpeculativeJIT::speculateSetObject(Edge edge)
 9993 {
 9994     if (!needsTypeCheck(edge, SpecSetObject))
 9995         return;
 9996 
 9997     SpeculateCellOperand operand(this, edge);
 9998     speculateSetObject(edge, operand.gpr());
 9999 }
10000 
10001 void SpeculativeJIT::speculateWeakMapObject(Edge edge, GPRReg cell)
10002 {
10003     speculateCellType(edge, cell, SpecWeakMapObject, JSWeakMapType);
10004 }
10005 
10006 void SpeculativeJIT::speculateWeakMapObject(Edge edge)
10007 {
10008     if (!needsTypeCheck(edge, SpecWeakMapObject))
10009         return;
10010 
10011     SpeculateCellOperand operand(this, edge);
10012     speculateWeakMapObject(edge, operand.gpr());
10013 }
10014 
10015 void SpeculativeJIT::speculateWeakSetObject(Edge edge, GPRReg cell)
10016 {
10017     speculateCellType(edge, cell, SpecWeakSetObject, JSWeakSetType);
10018 }
10019 
10020 void SpeculativeJIT::speculateWeakSetObject(Edge edge)
10021 {
10022     if (!needsTypeCheck(edge, SpecWeakSetObject))
10023         return;
10024 
10025     SpeculateCellOperand operand(this, edge);
10026     speculateWeakSetObject(edge, operand.gpr());
10027 }
10028 
10029 void SpeculativeJIT::speculateDataViewObject(Edge edge, GPRReg cell)
10030 {
10031     speculateCellType(edge, cell, SpecDataViewObject, DataViewType);
10032 }
10033 
10034 void SpeculativeJIT::speculateDataViewObject(Edge edge)
10035 {
10036     if (!needsTypeCheck(edge, SpecDataViewObject))
10037         return;
10038 
10039     SpeculateCellOperand operand(this, edge);
10040     speculateDataViewObject(edge, operand.gpr());
10041 }
10042 
10043 void SpeculativeJIT::speculateObjectOrOther(Edge edge)
10044 {
10045     if (!needsTypeCheck(edge, SpecObject | SpecOther))
10046         return;
10047 
10048     JSValueOperand operand(this, edge, ManualOperandSpeculation);
10049     GPRTemporary temp(this);
10050     GPRReg tempGPR = temp.gpr();
10051     MacroAssembler::Jump notCell = m_jit.branchIfNotCell(operand.jsValueRegs());
10052     GPRReg gpr = operand.jsValueRegs().payloadGPR();
10053     DFG_TYPE_CHECK(
10054         operand.jsValueRegs(), edge, (~SpecCellCheck) | SpecObject, m_jit.branchIfNotObject(gpr));
10055     MacroAssembler::Jump done = m_jit.jump();
10056     notCell.link(&amp;m_jit);
10057     DFG_TYPE_CHECK(
10058         operand.jsValueRegs(), edge, SpecCellCheck | SpecOther,
10059         m_jit.branchIfNotOther(operand.jsValueRegs(), tempGPR));
10060     done.link(&amp;m_jit);
10061 }
10062 
10063 void SpeculativeJIT::speculateString(Edge edge, GPRReg cell)
10064 {
10065     DFG_TYPE_CHECK(
10066         JSValueSource::unboxedCell(cell), edge, SpecString | ~SpecCellCheck, m_jit.branchIfNotString(cell));
10067 }
10068 
10069 void SpeculativeJIT::speculateStringOrOther(Edge edge, JSValueRegs regs, GPRReg scratch)
10070 {
10071     JITCompiler::Jump notCell = m_jit.branchIfNotCell(regs);
10072     GPRReg cell = regs.payloadGPR();
10073     DFG_TYPE_CHECK(regs, edge, (~SpecCellCheck) | SpecString, m_jit.branchIfNotString(cell));
10074     JITCompiler::Jump done = m_jit.jump();
10075     notCell.link(&amp;m_jit);
10076     DFG_TYPE_CHECK(regs, edge, SpecCellCheck | SpecOther, m_jit.branchIfNotOther(regs, scratch));
10077     done.link(&amp;m_jit);
10078 }
10079 
10080 void SpeculativeJIT::speculateStringOrOther(Edge edge)
10081 {
10082     if (!needsTypeCheck(edge, SpecString | SpecOther))
10083         return;
10084 
10085     JSValueOperand operand(this, edge, ManualOperandSpeculation);
10086     GPRTemporary temp(this);
10087     JSValueRegs regs = operand.jsValueRegs();
10088     GPRReg tempGPR = temp.gpr();
10089     speculateStringOrOther(edge, regs, tempGPR);
10090 }
10091 
10092 void SpeculativeJIT::speculateStringIdentAndLoadStorage(Edge edge, GPRReg string, GPRReg storage)
10093 {
10094     m_jit.loadPtr(MacroAssembler::Address(string, JSString::offsetOfValue()), storage);
10095 
10096     if (!needsTypeCheck(edge, SpecStringIdent | ~SpecString))
10097         return;
10098 
10099     speculationCheck(
10100         BadType, JSValueSource::unboxedCell(string), edge,
10101         m_jit.branchIfRopeStringImpl(storage));
10102     speculationCheck(
10103         BadType, JSValueSource::unboxedCell(string), edge, m_jit.branchTest32(
10104             MacroAssembler::Zero,
10105             MacroAssembler::Address(storage, StringImpl::flagsOffset()),
10106             MacroAssembler::TrustedImm32(StringImpl::flagIsAtomic())));
10107 
10108     m_interpreter.filter(edge, SpecStringIdent | ~SpecString);
10109 }
10110 
10111 void SpeculativeJIT::speculateStringIdent(Edge edge, GPRReg string)
10112 {
10113     if (!needsTypeCheck(edge, SpecStringIdent))
10114         return;
10115 
10116     GPRTemporary temp(this);
10117     speculateStringIdentAndLoadStorage(edge, string, temp.gpr());
10118 }
10119 
10120 void SpeculativeJIT::speculateStringIdent(Edge edge)
10121 {
10122     if (!needsTypeCheck(edge, SpecStringIdent))
10123         return;
10124 
10125     SpeculateCellOperand operand(this, edge);
10126     GPRReg gpr = operand.gpr();
10127     speculateString(edge, gpr);
10128     speculateStringIdent(edge, gpr);
10129 }
10130 
10131 void SpeculativeJIT::speculateString(Edge edge)
10132 {
10133     if (!needsTypeCheck(edge, SpecString))
10134         return;
10135 
10136     SpeculateCellOperand operand(this, edge);
10137     speculateString(edge, operand.gpr());
10138 }
10139 
10140 void SpeculativeJIT::speculateStringObject(Edge edge, GPRReg cellGPR)
10141 {
10142     DFG_TYPE_CHECK(JSValueSource::unboxedCell(cellGPR), edge, ~SpecCellCheck | SpecStringObject, m_jit.branchIfNotType(cellGPR, StringObjectType));
10143 }
10144 
10145 void SpeculativeJIT::speculateStringObject(Edge edge)
10146 {
10147     if (!needsTypeCheck(edge, SpecStringObject))
10148         return;
10149 
10150     SpeculateCellOperand operand(this, edge);
10151     GPRReg gpr = operand.gpr();
10152     speculateStringObject(edge, gpr);
10153 }
10154 
10155 void SpeculativeJIT::speculateStringOrStringObject(Edge edge)
10156 {
10157     if (!needsTypeCheck(edge, SpecString | SpecStringObject))
10158         return;
10159 
10160     SpeculateCellOperand operand(this, edge);
10161     GPRReg gpr = operand.gpr();
10162     if (!needsTypeCheck(edge, SpecString | SpecStringObject))
10163         return;
10164 
10165     GPRTemporary typeTemp(this);
10166     GPRReg typeGPR = typeTemp.gpr();
10167 
10168     m_jit.load8(JITCompiler::Address(gpr, JSCell::typeInfoTypeOffset()), typeGPR);
10169 
10170     JITCompiler::Jump isString = m_jit.branch32(JITCompiler::Equal, typeGPR, TrustedImm32(StringType));
10171     speculationCheck(BadType, JSValueSource::unboxedCell(gpr), edge.node(), m_jit.branch32(JITCompiler::NotEqual, typeGPR, TrustedImm32(StringObjectType)));
10172     isString.link(&amp;m_jit);
10173 
10174     m_interpreter.filter(edge, SpecString | SpecStringObject);
10175 }
10176 
10177 void SpeculativeJIT::speculateNotStringVar(Edge edge)
10178 {
10179     JSValueOperand operand(this, edge, ManualOperandSpeculation);
10180     GPRTemporary temp(this);
10181     GPRReg tempGPR = temp.gpr();
10182 
10183     JITCompiler::Jump notCell = m_jit.branchIfNotCell(operand.jsValueRegs());
10184     GPRReg cell = operand.jsValueRegs().payloadGPR();
10185 
10186     JITCompiler::Jump notString = m_jit.branchIfNotString(cell);
10187 
10188     speculateStringIdentAndLoadStorage(edge, cell, tempGPR);
10189 
10190     notString.link(&amp;m_jit);
10191     notCell.link(&amp;m_jit);
10192 }
10193 
10194 void SpeculativeJIT::speculateNotSymbol(Edge edge)
10195 {
10196     if (!needsTypeCheck(edge, ~SpecSymbol))
10197         return;
10198 
10199     JSValueOperand operand(this, edge, ManualOperandSpeculation);
10200     auto valueRegs = operand.jsValueRegs();
10201     GPRReg value = valueRegs.payloadGPR();
10202     JITCompiler::Jump notCell;
10203 
10204     bool needsCellCheck = needsTypeCheck(edge, SpecCell);
10205     if (needsCellCheck)
10206         notCell = m_jit.branchIfNotCell(valueRegs);
10207 
10208     speculationCheck(BadType, JSValueSource::unboxedCell(value), edge.node(), m_jit.branchIfSymbol(value));
10209 
10210     if (needsCellCheck)
10211         notCell.link(&amp;m_jit);
10212 
10213     m_interpreter.filter(edge, ~SpecSymbol);
10214 }
10215 
10216 void SpeculativeJIT::speculateSymbol(Edge edge, GPRReg cell)
10217 {
10218     DFG_TYPE_CHECK(JSValueSource::unboxedCell(cell), edge, ~SpecCellCheck | SpecSymbol, m_jit.branchIfNotSymbol(cell));
10219 }
10220 
10221 void SpeculativeJIT::speculateSymbol(Edge edge)
10222 {
10223     if (!needsTypeCheck(edge, SpecSymbol))
10224         return;
10225 
10226     SpeculateCellOperand operand(this, edge);
10227     speculateSymbol(edge, operand.gpr());
10228 }
10229 
10230 void SpeculativeJIT::speculateBigInt(Edge edge, GPRReg cell)
10231 {
10232     DFG_TYPE_CHECK(JSValueSource::unboxedCell(cell), edge, ~SpecCellCheck | SpecBigInt, m_jit.branchIfNotBigInt(cell));
10233 }
10234 
10235 void SpeculativeJIT::speculateBigInt(Edge edge)
10236 {
10237     if (!needsTypeCheck(edge, SpecBigInt))
10238         return;
10239 
10240     SpeculateCellOperand operand(this, edge);
10241     speculateBigInt(edge, operand.gpr());
10242 }
10243 
10244 void SpeculativeJIT::speculateNotCell(Edge edge, JSValueRegs regs)
10245 {
10246     DFG_TYPE_CHECK(regs, edge, ~SpecCellCheck, m_jit.branchIfCell(regs));
10247 }
10248 
10249 void SpeculativeJIT::speculateNotCell(Edge edge)
10250 {
10251     if (!needsTypeCheck(edge, ~SpecCellCheck))
10252         return;
10253 
10254     JSValueOperand operand(this, edge, ManualOperandSpeculation);
10255     speculateNotCell(edge, operand.jsValueRegs());
10256 }
10257 
10258 void SpeculativeJIT::speculateOther(Edge edge, JSValueRegs regs, GPRReg tempGPR)
10259 {
10260     DFG_TYPE_CHECK(regs, edge, SpecOther, m_jit.branchIfNotOther(regs, tempGPR));
10261 }
10262 
10263 void SpeculativeJIT::speculateOther(Edge edge, JSValueRegs regs)
10264 {
10265     if (!needsTypeCheck(edge, SpecOther))
10266         return;
10267 
10268     GPRTemporary temp(this);
10269     GPRReg tempGPR = temp.gpr();
10270     speculateOther(edge, regs, tempGPR);
10271 }
10272 
10273 void SpeculativeJIT::speculateOther(Edge edge)
10274 {
10275     if (!needsTypeCheck(edge, SpecOther))
10276         return;
10277 
10278     JSValueOperand operand(this, edge, ManualOperandSpeculation);
10279     speculateOther(edge, operand.jsValueRegs());
10280 }
10281 
10282 void SpeculativeJIT::speculateMisc(Edge edge, JSValueRegs regs)
10283 {
10284 #if USE(JSVALUE64)
10285     DFG_TYPE_CHECK(
10286         regs, edge, SpecMisc,
10287         m_jit.branch64(MacroAssembler::Above, regs.gpr(), MacroAssembler::TrustedImm64(TagBitTypeOther | TagBitBool | TagBitUndefined)));
10288 #else
10289     IGNORE_WARNINGS_BEGIN(&quot;enum-compare&quot;)
10290     static_assert(JSValue::Int32Tag &gt;= JSValue::UndefinedTag, &quot;Int32Tag is included in &gt;= JSValue::UndefinedTag range.&quot;);
10291     IGNORE_WARNINGS_END
10292     DFG_TYPE_CHECK(
10293         regs, edge, ~SpecInt32Only,
10294         m_jit.branchIfInt32(regs.tagGPR()));
10295     DFG_TYPE_CHECK(
10296         regs, edge, SpecMisc,
10297         m_jit.branch32(MacroAssembler::Below, regs.tagGPR(), MacroAssembler::TrustedImm32(JSValue::UndefinedTag)));
10298 #endif
10299 }
10300 
10301 void SpeculativeJIT::speculateMisc(Edge edge)
10302 {
10303     if (!needsTypeCheck(edge, SpecMisc))
10304         return;
10305 
10306     JSValueOperand operand(this, edge, ManualOperandSpeculation);
10307     speculateMisc(edge, operand.jsValueRegs());
10308 }
10309 
10310 void SpeculativeJIT::speculate(Node*, Edge edge)
10311 {
10312     switch (edge.useKind()) {
10313     case UntypedUse:
10314         break;
10315     case DoubleRepUse:
10316     case Int52RepUse:
10317     case KnownInt32Use:
10318     case KnownCellUse:
10319     case KnownStringUse:
10320     case KnownPrimitiveUse:
10321     case KnownOtherUse:
10322     case KnownBooleanUse:
10323         ASSERT(!m_interpreter.needsTypeCheck(edge));
10324         break;
10325     case Int32Use:
10326         speculateInt32(edge);
10327         break;
10328     case NumberUse:
10329         speculateNumber(edge);
10330         break;
10331     case RealNumberUse:
10332         speculateRealNumber(edge);
10333         break;
10334     case DoubleRepRealUse:
10335         speculateDoubleRepReal(edge);
10336         break;
10337 #if USE(JSVALUE64)
10338     case AnyIntUse:
10339         speculateAnyInt(edge);
10340         break;
10341     case DoubleRepAnyIntUse:
10342         speculateDoubleRepAnyInt(edge);
10343         break;
10344 #endif
10345     case BooleanUse:
10346         speculateBoolean(edge);
10347         break;
10348     case CellUse:
10349         speculateCell(edge);
10350         break;
10351     case CellOrOtherUse:
10352         speculateCellOrOther(edge);
10353         break;
10354     case ObjectUse:
10355         speculateObject(edge);
10356         break;
10357     case FunctionUse:
10358         speculateFunction(edge);
10359         break;
10360     case ArrayUse:
10361         speculateArray(edge);
10362         break;
10363     case FinalObjectUse:
10364         speculateFinalObject(edge);
10365         break;
10366     case RegExpObjectUse:
10367         speculateRegExpObject(edge);
10368         break;
10369     case ProxyObjectUse:
10370         speculateProxyObject(edge);
10371         break;
10372     case DerivedArrayUse:
10373         speculateDerivedArray(edge);
10374         break;
10375     case MapObjectUse:
10376         speculateMapObject(edge);
10377         break;
10378     case SetObjectUse:
10379         speculateSetObject(edge);
10380         break;
10381     case WeakMapObjectUse:
10382         speculateWeakMapObject(edge);
10383         break;
10384     case WeakSetObjectUse:
10385         speculateWeakSetObject(edge);
10386         break;
10387     case DataViewObjectUse:
10388         speculateDataViewObject(edge);
10389         break;
10390     case ObjectOrOtherUse:
10391         speculateObjectOrOther(edge);
10392         break;
10393     case StringIdentUse:
10394         speculateStringIdent(edge);
10395         break;
10396     case StringUse:
10397         speculateString(edge);
10398         break;
10399     case StringOrOtherUse:
10400         speculateStringOrOther(edge);
10401         break;
10402     case SymbolUse:
10403         speculateSymbol(edge);
10404         break;
10405     case BigIntUse:
10406         speculateBigInt(edge);
10407         break;
10408     case StringObjectUse:
10409         speculateStringObject(edge);
10410         break;
10411     case StringOrStringObjectUse:
10412         speculateStringOrStringObject(edge);
10413         break;
10414     case NotStringVarUse:
10415         speculateNotStringVar(edge);
10416         break;
10417     case NotSymbolUse:
10418         speculateNotSymbol(edge);
10419         break;
10420     case NotCellUse:
10421         speculateNotCell(edge);
10422         break;
10423     case OtherUse:
10424         speculateOther(edge);
10425         break;
10426     case MiscUse:
10427         speculateMisc(edge);
10428         break;
10429     default:
10430         RELEASE_ASSERT_NOT_REACHED();
10431         break;
10432     }
10433 }
10434 
10435 void SpeculativeJIT::emitSwitchIntJump(
10436     SwitchData* data, GPRReg value, GPRReg scratch)
10437 {
10438     SimpleJumpTable&amp; table = m_jit.codeBlock()-&gt;switchJumpTable(data-&gt;switchTableIndex);
10439     table.ensureCTITable();
10440     m_jit.sub32(Imm32(table.min), value);
10441     addBranch(
10442         m_jit.branch32(JITCompiler::AboveOrEqual, value, Imm32(table.ctiOffsets.size())),
10443         data-&gt;fallThrough.block);
10444     m_jit.move(TrustedImmPtr(table.ctiOffsets.begin()), scratch);
10445     m_jit.loadPtr(JITCompiler::BaseIndex(scratch, value, JITCompiler::timesPtr()), scratch);
10446 
10447     m_jit.jump(scratch, JSSwitchPtrTag);
10448     data-&gt;didUseJumpTable = true;
10449 }
10450 
10451 void SpeculativeJIT::emitSwitchImm(Node* node, SwitchData* data)
10452 {
10453     switch (node-&gt;child1().useKind()) {
10454     case Int32Use: {
10455         SpeculateInt32Operand value(this, node-&gt;child1());
10456         GPRTemporary temp(this);
10457         emitSwitchIntJump(data, value.gpr(), temp.gpr());
10458         noResult(node);
10459         break;
10460     }
10461 
10462     case UntypedUse: {
10463         JSValueOperand value(this, node-&gt;child1());
10464         GPRTemporary temp(this);
10465         JSValueRegs valueRegs = value.jsValueRegs();
10466         GPRReg scratch = temp.gpr();
10467 
10468         value.use();
10469 
10470         auto notInt32 = m_jit.branchIfNotInt32(valueRegs);
10471         emitSwitchIntJump(data, valueRegs.payloadGPR(), scratch);
10472         notInt32.link(&amp;m_jit);
10473         addBranch(m_jit.branchIfNotNumber(valueRegs, scratch), data-&gt;fallThrough.block);
10474         silentSpillAllRegisters(scratch);
10475         callOperation(operationFindSwitchImmTargetForDouble, scratch, valueRegs, data-&gt;switchTableIndex);
10476         silentFillAllRegisters();
10477 
10478         m_jit.jump(scratch, JSSwitchPtrTag);
10479         noResult(node, UseChildrenCalledExplicitly);
10480         break;
10481     }
10482 
10483     default:
10484         RELEASE_ASSERT_NOT_REACHED();
10485         break;
10486     }
10487 }
10488 
10489 void SpeculativeJIT::emitSwitchCharStringJump(
10490     SwitchData* data, GPRReg value, GPRReg scratch)
10491 {
10492     m_jit.loadPtr(MacroAssembler::Address(value, JSString::offsetOfValue()), scratch);
10493     auto isRope = m_jit.branchIfRopeStringImpl(scratch);
10494 
10495     addBranch(
10496         m_jit.branch32(
10497             MacroAssembler::NotEqual,
10498             MacroAssembler::Address(scratch, StringImpl::lengthMemoryOffset()),
10499             TrustedImm32(1)),
10500         data-&gt;fallThrough.block);
10501 
10502     addSlowPathGenerator(slowPathCall(isRope, this, operationResolveRope, scratch, value));
10503 
10504     m_jit.loadPtr(MacroAssembler::Address(scratch, StringImpl::dataOffset()), value);
10505 
10506     JITCompiler::Jump is8Bit = m_jit.branchTest32(
10507         MacroAssembler::NonZero,
10508         MacroAssembler::Address(scratch, StringImpl::flagsOffset()),
10509         TrustedImm32(StringImpl::flagIs8Bit()));
10510 
10511     m_jit.load16(MacroAssembler::Address(value), scratch);
10512 
10513     JITCompiler::Jump ready = m_jit.jump();
10514 
10515     is8Bit.link(&amp;m_jit);
10516     m_jit.load8(MacroAssembler::Address(value), scratch);
10517 
10518     ready.link(&amp;m_jit);
10519     emitSwitchIntJump(data, scratch, value);
10520 }
10521 
10522 void SpeculativeJIT::emitSwitchChar(Node* node, SwitchData* data)
10523 {
10524     switch (node-&gt;child1().useKind()) {
10525     case StringUse: {
10526         SpeculateCellOperand op1(this, node-&gt;child1());
10527         GPRTemporary temp(this);
10528 
10529         GPRReg op1GPR = op1.gpr();
10530         GPRReg tempGPR = temp.gpr();
10531 
10532         op1.use();
10533 
10534         speculateString(node-&gt;child1(), op1GPR);
10535         emitSwitchCharStringJump(data, op1GPR, tempGPR);
10536         noResult(node, UseChildrenCalledExplicitly);
10537         break;
10538     }
10539 
10540     case UntypedUse: {
10541         JSValueOperand op1(this, node-&gt;child1());
10542         GPRTemporary temp(this);
10543 
10544         JSValueRegs op1Regs = op1.jsValueRegs();
10545         GPRReg tempGPR = temp.gpr();
10546 
10547         op1.use();
10548 
10549         addBranch(m_jit.branchIfNotCell(op1Regs), data-&gt;fallThrough.block);
10550 
10551         addBranch(m_jit.branchIfNotString(op1Regs.payloadGPR()), data-&gt;fallThrough.block);
10552 
10553         emitSwitchCharStringJump(data, op1Regs.payloadGPR(), tempGPR);
10554         noResult(node, UseChildrenCalledExplicitly);
10555         break;
10556     }
10557 
10558     default:
10559         RELEASE_ASSERT_NOT_REACHED();
10560         break;
10561     }
10562 }
10563 
10564 namespace {
10565 
10566 struct CharacterCase {
10567     bool operator&lt;(const CharacterCase&amp; other) const
10568     {
10569         return character &lt; other.character;
10570     }
10571 
10572     LChar character;
10573     unsigned begin;
10574     unsigned end;
10575 };
10576 
10577 } // anonymous namespace
10578 
10579 void SpeculativeJIT::emitBinarySwitchStringRecurse(
10580     SwitchData* data, const Vector&lt;SpeculativeJIT::StringSwitchCase&gt;&amp; cases,
10581     unsigned numChecked, unsigned begin, unsigned end, GPRReg buffer, GPRReg length,
10582     GPRReg temp, unsigned alreadyCheckedLength, bool checkedExactLength)
10583 {
10584     static const bool verbose = false;
10585 
10586     if (verbose) {
10587         dataLog(&quot;We&#39;re down to the following cases, alreadyCheckedLength = &quot;, alreadyCheckedLength, &quot;:\n&quot;);
10588         for (unsigned i = begin; i &lt; end; ++i) {
10589             dataLog(&quot;    &quot;, cases[i].string, &quot;\n&quot;);
10590         }
10591     }
10592 
10593     if (begin == end) {
10594         jump(data-&gt;fallThrough.block, ForceJump);
10595         return;
10596     }
10597 
10598     unsigned minLength = cases[begin].string-&gt;length();
10599     unsigned commonChars = minLength;
10600     bool allLengthsEqual = true;
10601     for (unsigned i = begin + 1; i &lt; end; ++i) {
10602         unsigned myCommonChars = numChecked;
10603         for (unsigned j = numChecked;
10604             j &lt; std::min(cases[begin].string-&gt;length(), cases[i].string-&gt;length());
10605             ++j) {
10606             if (cases[begin].string-&gt;at(j) != cases[i].string-&gt;at(j)) {
10607                 if (verbose)
10608                     dataLog(&quot;string(&quot;, cases[i].string, &quot;)[&quot;, j, &quot;] != string(&quot;, cases[begin].string, &quot;)[&quot;, j, &quot;]\n&quot;);
10609                 break;
10610             }
10611             myCommonChars++;
10612         }
10613         commonChars = std::min(commonChars, myCommonChars);
10614         if (minLength != cases[i].string-&gt;length())
10615             allLengthsEqual = false;
10616         minLength = std::min(minLength, cases[i].string-&gt;length());
10617     }
10618 
10619     if (checkedExactLength) {
10620         RELEASE_ASSERT(alreadyCheckedLength == minLength);
10621         RELEASE_ASSERT(allLengthsEqual);
10622     }
10623 
10624     RELEASE_ASSERT(minLength &gt;= commonChars);
10625 
10626     if (verbose)
10627         dataLog(&quot;length = &quot;, minLength, &quot;, commonChars = &quot;, commonChars, &quot;, allLengthsEqual = &quot;, allLengthsEqual, &quot;\n&quot;);
10628 
10629     if (!allLengthsEqual &amp;&amp; alreadyCheckedLength &lt; minLength)
10630         branch32(MacroAssembler::Below, length, Imm32(minLength), data-&gt;fallThrough.block);
10631     if (allLengthsEqual &amp;&amp; (alreadyCheckedLength &lt; minLength || !checkedExactLength))
10632         branch32(MacroAssembler::NotEqual, length, Imm32(minLength), data-&gt;fallThrough.block);
10633 
10634     for (unsigned i = numChecked; i &lt; commonChars; ++i) {
10635         branch8(
10636             MacroAssembler::NotEqual, MacroAssembler::Address(buffer, i),
10637             TrustedImm32(cases[begin].string-&gt;at(i)), data-&gt;fallThrough.block);
10638     }
10639 
10640     if (minLength == commonChars) {
10641         // This is the case where one of the cases is a prefix of all of the other cases.
10642         // We&#39;ve already checked that the input string is a prefix of all of the cases,
10643         // so we just check length to jump to that case.
10644 
10645         if (!ASSERT_DISABLED) {
10646             ASSERT(cases[begin].string-&gt;length() == commonChars);
10647             for (unsigned i = begin + 1; i &lt; end; ++i)
10648                 ASSERT(cases[i].string-&gt;length() &gt; commonChars);
10649         }
10650 
10651         if (allLengthsEqual) {
10652             RELEASE_ASSERT(end == begin + 1);
10653             jump(cases[begin].target, ForceJump);
10654             return;
10655         }
10656 
10657         branch32(MacroAssembler::Equal, length, Imm32(commonChars), cases[begin].target);
10658 
10659         // We&#39;ve checked if the length is &gt;= minLength, and then we checked if the
10660         // length is == commonChars. We get to this point if it is &gt;= minLength but not
10661         // == commonChars. Hence we know that it now must be &gt; minLength, i.e., that
10662         // it&#39;s &gt;= minLength + 1.
10663         emitBinarySwitchStringRecurse(
10664             data, cases, commonChars, begin + 1, end, buffer, length, temp, minLength + 1, false);
10665         return;
10666     }
10667 
10668     // At this point we know that the string is longer than commonChars, and we&#39;ve only
10669     // verified commonChars. Use a binary switch on the next unchecked character, i.e.
10670     // string[commonChars].
10671 
10672     RELEASE_ASSERT(end &gt;= begin + 2);
10673 
10674     m_jit.load8(MacroAssembler::Address(buffer, commonChars), temp);
10675 
10676     Vector&lt;CharacterCase&gt; characterCases;
10677     CharacterCase currentCase;
10678     currentCase.character = cases[begin].string-&gt;at(commonChars);
10679     currentCase.begin = begin;
10680     currentCase.end = begin + 1;
10681     for (unsigned i = begin + 1; i &lt; end; ++i) {
10682         if (cases[i].string-&gt;at(commonChars) != currentCase.character) {
10683             if (verbose)
10684                 dataLog(&quot;string(&quot;, cases[i].string, &quot;)[&quot;, commonChars, &quot;] != string(&quot;, cases[begin].string, &quot;)[&quot;, commonChars, &quot;]\n&quot;);
10685             currentCase.end = i;
10686             characterCases.append(currentCase);
10687             currentCase.character = cases[i].string-&gt;at(commonChars);
10688             currentCase.begin = i;
10689             currentCase.end = i + 1;
10690         } else
10691             currentCase.end = i + 1;
10692     }
10693     characterCases.append(currentCase);
10694 
10695     Vector&lt;int64_t&gt; characterCaseValues;
10696     for (unsigned i = 0; i &lt; characterCases.size(); ++i)
10697         characterCaseValues.append(characterCases[i].character);
10698 
10699     BinarySwitch binarySwitch(temp, characterCaseValues, BinarySwitch::Int32);
10700     while (binarySwitch.advance(m_jit)) {
10701         const CharacterCase&amp; myCase = characterCases[binarySwitch.caseIndex()];
10702         emitBinarySwitchStringRecurse(
10703             data, cases, commonChars + 1, myCase.begin, myCase.end, buffer, length,
10704             temp, minLength, allLengthsEqual);
10705     }
10706 
10707     addBranch(binarySwitch.fallThrough(), data-&gt;fallThrough.block);
10708 }
10709 
10710 void SpeculativeJIT::emitSwitchStringOnString(SwitchData* data, GPRReg string)
10711 {
10712     data-&gt;didUseJumpTable = true;
10713 
10714     bool canDoBinarySwitch = true;
10715     unsigned totalLength = 0;
10716 
10717     for (unsigned i = data-&gt;cases.size(); i--;) {
10718         StringImpl* string = data-&gt;cases[i].value.stringImpl();
10719         if (!string-&gt;is8Bit()) {
10720             canDoBinarySwitch = false;
10721             break;
10722         }
10723         if (string-&gt;length() &gt; Options::maximumBinaryStringSwitchCaseLength()) {
10724             canDoBinarySwitch = false;
10725             break;
10726         }
10727         totalLength += string-&gt;length();
10728     }
10729 
10730     if (!canDoBinarySwitch || totalLength &gt; Options::maximumBinaryStringSwitchTotalLength()) {
10731         flushRegisters();
10732         callOperation(
10733             operationSwitchString, string, static_cast&lt;size_t&gt;(data-&gt;switchTableIndex), string);
10734         m_jit.exceptionCheck();
10735         m_jit.jump(string, JSSwitchPtrTag);
10736         return;
10737     }
10738 
10739     GPRTemporary length(this);
10740     GPRTemporary temp(this);
10741 
10742     GPRReg lengthGPR = length.gpr();
10743     GPRReg tempGPR = temp.gpr();
10744 
10745     MacroAssembler::JumpList slowCases;
10746     m_jit.loadPtr(MacroAssembler::Address(string, JSString::offsetOfValue()), tempGPR);
10747     slowCases.append(m_jit.branchIfRopeStringImpl(tempGPR));
10748     m_jit.load32(MacroAssembler::Address(tempGPR, StringImpl::lengthMemoryOffset()), lengthGPR);
10749 
10750     slowCases.append(m_jit.branchTest32(
10751         MacroAssembler::Zero,
10752         MacroAssembler::Address(tempGPR, StringImpl::flagsOffset()),
10753         TrustedImm32(StringImpl::flagIs8Bit())));
10754 
10755     m_jit.loadPtr(MacroAssembler::Address(tempGPR, StringImpl::dataOffset()), string);
10756 
10757     Vector&lt;StringSwitchCase&gt; cases;
10758     for (unsigned i = 0; i &lt; data-&gt;cases.size(); ++i) {
10759         cases.append(
10760             StringSwitchCase(data-&gt;cases[i].value.stringImpl(), data-&gt;cases[i].target.block));
10761     }
10762 
10763     std::sort(cases.begin(), cases.end());
10764 
10765     emitBinarySwitchStringRecurse(
10766         data, cases, 0, 0, cases.size(), string, lengthGPR, tempGPR, 0, false);
10767 
10768     slowCases.link(&amp;m_jit);
10769     silentSpillAllRegisters(string);
10770     callOperation(operationSwitchString, string, static_cast&lt;size_t&gt;(data-&gt;switchTableIndex), string);
10771     silentFillAllRegisters();
10772     m_jit.exceptionCheck();
10773     m_jit.jump(string, JSSwitchPtrTag);
10774 }
10775 
10776 void SpeculativeJIT::emitSwitchString(Node* node, SwitchData* data)
10777 {
10778     switch (node-&gt;child1().useKind()) {
10779     case StringIdentUse: {
10780         SpeculateCellOperand op1(this, node-&gt;child1());
10781         GPRTemporary temp(this);
10782 
10783         GPRReg op1GPR = op1.gpr();
10784         GPRReg tempGPR = temp.gpr();
10785 
10786         speculateString(node-&gt;child1(), op1GPR);
10787         speculateStringIdentAndLoadStorage(node-&gt;child1(), op1GPR, tempGPR);
10788 
10789         Vector&lt;int64_t&gt; identifierCaseValues;
10790         for (unsigned i = 0; i &lt; data-&gt;cases.size(); ++i) {
10791             identifierCaseValues.append(
10792                 static_cast&lt;int64_t&gt;(bitwise_cast&lt;intptr_t&gt;(data-&gt;cases[i].value.stringImpl())));
10793         }
10794 
10795         BinarySwitch binarySwitch(tempGPR, identifierCaseValues, BinarySwitch::IntPtr);
10796         while (binarySwitch.advance(m_jit))
10797             jump(data-&gt;cases[binarySwitch.caseIndex()].target.block, ForceJump);
10798         addBranch(binarySwitch.fallThrough(), data-&gt;fallThrough.block);
10799 
10800         noResult(node);
10801         break;
10802     }
10803 
10804     case StringUse: {
10805         SpeculateCellOperand op1(this, node-&gt;child1());
10806 
10807         GPRReg op1GPR = op1.gpr();
10808 
10809         op1.use();
10810 
10811         speculateString(node-&gt;child1(), op1GPR);
10812         emitSwitchStringOnString(data, op1GPR);
10813         noResult(node, UseChildrenCalledExplicitly);
10814         break;
10815     }
10816 
10817     case UntypedUse: {
10818         JSValueOperand op1(this, node-&gt;child1());
10819 
10820         JSValueRegs op1Regs = op1.jsValueRegs();
10821 
10822         op1.use();
10823 
10824         addBranch(m_jit.branchIfNotCell(op1Regs), data-&gt;fallThrough.block);
10825 
10826         addBranch(m_jit.branchIfNotString(op1Regs.payloadGPR()), data-&gt;fallThrough.block);
10827 
10828         emitSwitchStringOnString(data, op1Regs.payloadGPR());
10829         noResult(node, UseChildrenCalledExplicitly);
10830         break;
10831     }
10832 
10833     default:
10834         RELEASE_ASSERT_NOT_REACHED();
10835         break;
10836     }
10837 }
10838 
10839 void SpeculativeJIT::emitSwitch(Node* node)
10840 {
10841     SwitchData* data = node-&gt;switchData();
10842     switch (data-&gt;kind) {
10843     case SwitchImm: {
10844         emitSwitchImm(node, data);
10845         return;
10846     }
10847     case SwitchChar: {
10848         emitSwitchChar(node, data);
10849         return;
10850     }
10851     case SwitchString: {
10852         emitSwitchString(node, data);
10853         return;
10854     }
10855     case SwitchCell: {
10856         DFG_CRASH(m_jit.graph(), node, &quot;Bad switch kind&quot;);
10857         return;
10858     } }
10859     RELEASE_ASSERT_NOT_REACHED();
10860 }
10861 
10862 void SpeculativeJIT::addBranch(const MacroAssembler::JumpList&amp; jump, BasicBlock* destination)
10863 {
10864     for (unsigned i = jump.jumps().size(); i--;)
10865         addBranch(jump.jumps()[i], destination);
10866 }
10867 
10868 void SpeculativeJIT::linkBranches()
10869 {
10870     for (auto&amp; branch : m_branches)
10871         branch.jump.linkTo(m_jit.blockHeads()[branch.destination-&gt;index], &amp;m_jit);
10872 }
10873 
10874 void SpeculativeJIT::compileStoreBarrier(Node* node)
10875 {
10876     ASSERT(node-&gt;op() == StoreBarrier || node-&gt;op() == FencedStoreBarrier);
10877 
10878     bool isFenced = node-&gt;op() == FencedStoreBarrier;
10879 
10880     SpeculateCellOperand base(this, node-&gt;child1());
10881     GPRTemporary scratch1(this);
10882 
10883     GPRReg baseGPR = base.gpr();
10884     GPRReg scratch1GPR = scratch1.gpr();
10885 
10886     JITCompiler::JumpList ok;
10887 
10888     if (isFenced) {
10889         ok.append(m_jit.barrierBranch(*m_jit.vm(), baseGPR, scratch1GPR));
10890 
10891         JITCompiler::Jump noFence = m_jit.jumpIfMutatorFenceNotNeeded(*m_jit.vm());
10892         m_jit.memoryFence();
10893         ok.append(m_jit.barrierBranchWithoutFence(baseGPR));
10894         noFence.link(&amp;m_jit);
10895     } else
10896         ok.append(m_jit.barrierBranchWithoutFence(baseGPR));
10897 
10898     silentSpillAllRegisters(InvalidGPRReg);
10899     callOperation(operationWriteBarrierSlowPath, baseGPR);
10900     silentFillAllRegisters();
10901 
10902     ok.link(&amp;m_jit);
10903 
10904     noResult(node);
10905 }
10906 
10907 void SpeculativeJIT::compilePutAccessorById(Node* node)
10908 {
10909     SpeculateCellOperand base(this, node-&gt;child1());
10910     SpeculateCellOperand accessor(this, node-&gt;child2());
10911 
10912     GPRReg baseGPR = base.gpr();
10913     GPRReg accessorGPR = accessor.gpr();
10914 
10915     flushRegisters();
10916     callOperation(node-&gt;op() == PutGetterById ? operationPutGetterById : operationPutSetterById, NoResult, baseGPR, identifierUID(node-&gt;identifierNumber()), node-&gt;accessorAttributes(), accessorGPR);
10917     m_jit.exceptionCheck();
10918 
10919     noResult(node);
10920 }
10921 
10922 void SpeculativeJIT::compilePutGetterSetterById(Node* node)
10923 {
10924     SpeculateCellOperand base(this, node-&gt;child1());
10925     JSValueOperand getter(this, node-&gt;child2());
10926     JSValueOperand setter(this, node-&gt;child3());
10927 
10928 #if USE(JSVALUE64)
10929     GPRReg baseGPR = base.gpr();
10930     GPRReg getterGPR = getter.gpr();
10931     GPRReg setterGPR = setter.gpr();
10932 
10933     flushRegisters();
10934     callOperation(operationPutGetterSetter, NoResult, baseGPR, identifierUID(node-&gt;identifierNumber()), node-&gt;accessorAttributes(), getterGPR, setterGPR);
10935 #else
10936     // These JSValues may be JSUndefined OR JSFunction*.
10937     // At that time,
10938     // 1. If the JSValue is JSUndefined, its payload becomes nullptr.
10939     // 2. If the JSValue is JSFunction*, its payload becomes JSFunction*.
10940     // So extract payload and pass it to operationPutGetterSetter. This hack is used as the same way in baseline JIT.
10941     GPRReg baseGPR = base.gpr();
10942     JSValueRegs getterRegs = getter.jsValueRegs();
10943     JSValueRegs setterRegs = setter.jsValueRegs();
10944 
10945     flushRegisters();
10946     callOperation(operationPutGetterSetter, NoResult, baseGPR, identifierUID(node-&gt;identifierNumber()), node-&gt;accessorAttributes(), getterRegs.payloadGPR(), setterRegs.payloadGPR());
10947 #endif
10948     m_jit.exceptionCheck();
10949 
10950     noResult(node);
10951 }
10952 
10953 void SpeculativeJIT::compileResolveScope(Node* node)
10954 {
10955     SpeculateCellOperand scope(this, node-&gt;child1());
10956     GPRReg scopeGPR = scope.gpr();
10957     GPRFlushedCallResult result(this);
10958     GPRReg resultGPR = result.gpr();
10959     flushRegisters();
10960     callOperation(operationResolveScope, resultGPR, scopeGPR, identifierUID(node-&gt;identifierNumber()));
10961     m_jit.exceptionCheck();
10962     cellResult(resultGPR, node);
10963 }
10964 
10965 void SpeculativeJIT::compileResolveScopeForHoistingFuncDeclInEval(Node* node)
10966 {
10967     SpeculateCellOperand scope(this, node-&gt;child1());
10968     GPRReg scopeGPR = scope.gpr();
10969     flushRegisters();
10970     JSValueRegsFlushedCallResult result(this);
10971     JSValueRegs resultRegs = result.regs();
10972     callOperation(operationResolveScopeForHoistingFuncDeclInEval, resultRegs, scopeGPR, identifierUID(node-&gt;identifierNumber()));
10973     m_jit.exceptionCheck();
10974     jsValueResult(resultRegs, node);
10975 }
10976 
10977 void SpeculativeJIT::compileGetGlobalVariable(Node* node)
10978 {
10979     JSValueRegsTemporary result(this);
10980     JSValueRegs resultRegs = result.regs();
10981     m_jit.loadValue(node-&gt;variablePointer(), resultRegs);
10982     jsValueResult(resultRegs, node);
10983 }
10984 
10985 void SpeculativeJIT::compilePutGlobalVariable(Node* node)
10986 {
10987     JSValueOperand value(this, node-&gt;child2());
10988     JSValueRegs valueRegs = value.jsValueRegs();
10989     m_jit.storeValue(valueRegs, node-&gt;variablePointer());
10990     noResult(node);
10991 }
10992 
10993 void SpeculativeJIT::compileGetDynamicVar(Node* node)
10994 {
10995     SpeculateCellOperand scope(this, node-&gt;child1());
10996     GPRReg scopeGPR = scope.gpr();
10997     flushRegisters();
10998     JSValueRegsFlushedCallResult result(this);
10999     JSValueRegs resultRegs = result.regs();
11000     callOperation(operationGetDynamicVar, resultRegs, scopeGPR, identifierUID(node-&gt;identifierNumber()), node-&gt;getPutInfo());
11001     m_jit.exceptionCheck();
11002     jsValueResult(resultRegs, node);
11003 }
11004 
11005 void SpeculativeJIT::compilePutDynamicVar(Node* node)
11006 {
11007     SpeculateCellOperand scope(this, node-&gt;child1());
11008     JSValueOperand value(this, node-&gt;child2());
11009 
11010     GPRReg scopeGPR = scope.gpr();
11011     JSValueRegs valueRegs = value.jsValueRegs();
11012 
11013     flushRegisters();
11014     callOperation(operationPutDynamicVar, NoResult, scopeGPR, valueRegs, identifierUID(node-&gt;identifierNumber()), node-&gt;getPutInfo());
11015     m_jit.exceptionCheck();
11016     noResult(node);
11017 }
11018 
11019 void SpeculativeJIT::compileGetClosureVar(Node* node)
11020 {
11021     SpeculateCellOperand base(this, node-&gt;child1());
11022     JSValueRegsTemporary result(this);
11023 
11024     GPRReg baseGPR = base.gpr();
11025     JSValueRegs resultRegs = result.regs();
11026 
11027     m_jit.loadValue(JITCompiler::Address(baseGPR, JSLexicalEnvironment::offsetOfVariable(node-&gt;scopeOffset())), resultRegs);
11028     jsValueResult(resultRegs, node);
11029 }
11030 
11031 void SpeculativeJIT::compilePutClosureVar(Node* node)
11032 {
11033     SpeculateCellOperand base(this, node-&gt;child1());
11034     JSValueOperand value(this, node-&gt;child2());
11035 
11036     GPRReg baseGPR = base.gpr();
11037     JSValueRegs valueRegs = value.jsValueRegs();
11038 
11039     m_jit.storeValue(valueRegs, JITCompiler::Address(baseGPR, JSLexicalEnvironment::offsetOfVariable(node-&gt;scopeOffset())));
11040     noResult(node);
11041 }
11042 
11043 void SpeculativeJIT::compilePutAccessorByVal(Node* node)
11044 {
11045     SpeculateCellOperand base(this, node-&gt;child1());
11046     JSValueOperand subscript(this, node-&gt;child2());
11047     SpeculateCellOperand accessor(this, node-&gt;child3());
11048 
11049     auto operation = node-&gt;op() == PutGetterByVal ? operationPutGetterByVal : operationPutSetterByVal;
11050 
11051     GPRReg baseGPR = base.gpr();
11052     JSValueRegs subscriptRegs = subscript.jsValueRegs();
11053     GPRReg accessorGPR = accessor.gpr();
11054 
11055     flushRegisters();
11056     callOperation(operation, NoResult, baseGPR, subscriptRegs, node-&gt;accessorAttributes(), accessorGPR);
11057     m_jit.exceptionCheck();
11058 
11059     noResult(node);
11060 }
11061 
11062 void SpeculativeJIT::compileGetRegExpObjectLastIndex(Node* node)
11063 {
11064     SpeculateCellOperand regExp(this, node-&gt;child1());
11065     JSValueRegsTemporary result(this);
11066     GPRReg regExpGPR = regExp.gpr();
11067     JSValueRegs resultRegs = result.regs();
11068     speculateRegExpObject(node-&gt;child1(), regExpGPR);
11069     m_jit.loadValue(JITCompiler::Address(regExpGPR, RegExpObject::offsetOfLastIndex()), resultRegs);
11070     jsValueResult(resultRegs, node);
11071 }
11072 
11073 void SpeculativeJIT::compileSetRegExpObjectLastIndex(Node* node)
11074 {
11075     SpeculateCellOperand regExp(this, node-&gt;child1());
11076     JSValueOperand value(this, node-&gt;child2());
11077     GPRReg regExpGPR = regExp.gpr();
11078     JSValueRegs valueRegs = value.jsValueRegs();
11079 
11080     if (!node-&gt;ignoreLastIndexIsWritable()) {
11081         speculateRegExpObject(node-&gt;child1(), regExpGPR);
11082         speculationCheck(
11083             ExoticObjectMode, JSValueRegs(), nullptr,
11084             m_jit.branchTest8(
11085                 JITCompiler::Zero,
11086                 JITCompiler::Address(regExpGPR, RegExpObject::offsetOfLastIndexIsWritable())));
11087     }
11088 
11089     m_jit.storeValue(valueRegs, JITCompiler::Address(regExpGPR, RegExpObject::offsetOfLastIndex()));
11090     noResult(node);
11091 }
11092 
11093 void SpeculativeJIT::compileRegExpExec(Node* node)
11094 {
11095     bool sample = false;
11096     if (sample)
11097         m_jit.incrementSuperSamplerCount();
11098 
11099     SpeculateCellOperand globalObject(this, node-&gt;child1());
11100     GPRReg globalObjectGPR = globalObject.gpr();
11101 
11102     if (node-&gt;child2().useKind() == RegExpObjectUse) {
11103         if (node-&gt;child3().useKind() == StringUse) {
11104             SpeculateCellOperand base(this, node-&gt;child2());
11105             SpeculateCellOperand argument(this, node-&gt;child3());
11106             GPRReg baseGPR = base.gpr();
11107             GPRReg argumentGPR = argument.gpr();
11108             speculateRegExpObject(node-&gt;child2(), baseGPR);
11109             speculateString(node-&gt;child3(), argumentGPR);
11110 
11111             flushRegisters();
11112             JSValueRegsFlushedCallResult result(this);
11113             JSValueRegs resultRegs = result.regs();
11114             callOperation(operationRegExpExecString, resultRegs, globalObjectGPR, baseGPR, argumentGPR);
11115             m_jit.exceptionCheck();
11116 
11117             jsValueResult(resultRegs, node);
11118 
11119             if (sample)
11120                 m_jit.decrementSuperSamplerCount();
11121             return;
11122         }
11123 
11124         SpeculateCellOperand base(this, node-&gt;child2());
11125         JSValueOperand argument(this, node-&gt;child3());
11126         GPRReg baseGPR = base.gpr();
11127         JSValueRegs argumentRegs = argument.jsValueRegs();
11128         speculateRegExpObject(node-&gt;child2(), baseGPR);
11129 
11130         flushRegisters();
11131         JSValueRegsFlushedCallResult result(this);
11132         JSValueRegs resultRegs = result.regs();
11133         callOperation(operationRegExpExec, resultRegs, globalObjectGPR, baseGPR, argumentRegs);
11134         m_jit.exceptionCheck();
11135 
11136         jsValueResult(resultRegs, node);
11137 
11138         if (sample)
11139             m_jit.decrementSuperSamplerCount();
11140         return;
11141     }
11142 
11143     JSValueOperand base(this, node-&gt;child2());
11144     JSValueOperand argument(this, node-&gt;child3());
11145     JSValueRegs baseRegs = base.jsValueRegs();
11146     JSValueRegs argumentRegs = argument.jsValueRegs();
11147 
11148     flushRegisters();
11149     JSValueRegsFlushedCallResult result(this);
11150     JSValueRegs resultRegs = result.regs();
11151     callOperation(operationRegExpExecGeneric, resultRegs, globalObjectGPR, baseRegs, argumentRegs);
11152     m_jit.exceptionCheck();
11153 
11154     jsValueResult(resultRegs, node);
11155 
11156     if (sample)
11157         m_jit.decrementSuperSamplerCount();
11158 }
11159 
11160 void SpeculativeJIT::compileRegExpTest(Node* node)
11161 {
11162     SpeculateCellOperand globalObject(this, node-&gt;child1());
11163     GPRReg globalObjectGPR = globalObject.gpr();
11164 
11165     if (node-&gt;child2().useKind() == RegExpObjectUse) {
11166         if (node-&gt;child3().useKind() == StringUse) {
11167             SpeculateCellOperand base(this, node-&gt;child2());
11168             SpeculateCellOperand argument(this, node-&gt;child3());
11169             GPRReg baseGPR = base.gpr();
11170             GPRReg argumentGPR = argument.gpr();
11171             speculateRegExpObject(node-&gt;child2(), baseGPR);
11172             speculateString(node-&gt;child3(), argumentGPR);
11173 
11174             flushRegisters();
11175             GPRFlushedCallResult result(this);
11176             callOperation(operationRegExpTestString, result.gpr(), globalObjectGPR, baseGPR, argumentGPR);
11177             m_jit.exceptionCheck();
11178 
11179             unblessedBooleanResult(result.gpr(), node);
11180             return;
11181         }
11182 
11183         SpeculateCellOperand base(this, node-&gt;child2());
11184         JSValueOperand argument(this, node-&gt;child3());
11185         GPRReg baseGPR = base.gpr();
11186         JSValueRegs argumentRegs = argument.jsValueRegs();
11187         speculateRegExpObject(node-&gt;child2(), baseGPR);
11188 
11189         flushRegisters();
11190         GPRFlushedCallResult result(this);
11191         callOperation(operationRegExpTest, result.gpr(), globalObjectGPR, baseGPR, argumentRegs);
11192         m_jit.exceptionCheck();
11193 
11194         unblessedBooleanResult(result.gpr(), node);
11195         return;
11196     }
11197 
11198     JSValueOperand base(this, node-&gt;child2());
11199     JSValueOperand argument(this, node-&gt;child3());
11200     JSValueRegs baseRegs = base.jsValueRegs();
11201     JSValueRegs argumentRegs = argument.jsValueRegs();
11202 
11203     flushRegisters();
11204     GPRFlushedCallResult result(this);
11205     callOperation(operationRegExpTestGeneric, result.gpr(), globalObjectGPR, baseRegs, argumentRegs);
11206     m_jit.exceptionCheck();
11207 
11208     unblessedBooleanResult(result.gpr(), node);
11209 }
11210 
11211 void SpeculativeJIT::compileStringReplace(Node* node)
11212 {
11213     ASSERT(node-&gt;op() == StringReplace || node-&gt;op() == StringReplaceRegExp);
11214     bool sample = false;
11215     if (sample)
11216         m_jit.incrementSuperSamplerCount();
11217 
11218     if (node-&gt;child1().useKind() == StringUse
11219         &amp;&amp; node-&gt;child2().useKind() == RegExpObjectUse
11220         &amp;&amp; node-&gt;child3().useKind() == StringUse) {
11221         if (JSString* replace = node-&gt;child3()-&gt;dynamicCastConstant&lt;JSString*&gt;(*m_jit.vm())) {
11222             if (!replace-&gt;length()) {
11223                 SpeculateCellOperand string(this, node-&gt;child1());
11224                 SpeculateCellOperand regExp(this, node-&gt;child2());
11225                 GPRReg stringGPR = string.gpr();
11226                 GPRReg regExpGPR = regExp.gpr();
11227                 speculateString(node-&gt;child1(), stringGPR);
11228                 speculateRegExpObject(node-&gt;child2(), regExpGPR);
11229 
11230                 flushRegisters();
11231                 GPRFlushedCallResult result(this);
11232                 callOperation(operationStringProtoFuncReplaceRegExpEmptyStr, result.gpr(), stringGPR, regExpGPR);
11233                 m_jit.exceptionCheck();
11234                 cellResult(result.gpr(), node);
11235                 if (sample)
11236                     m_jit.decrementSuperSamplerCount();
11237                 return;
11238             }
11239         }
11240 
11241         SpeculateCellOperand string(this, node-&gt;child1());
11242         SpeculateCellOperand regExp(this, node-&gt;child2());
11243         SpeculateCellOperand replace(this, node-&gt;child3());
11244         GPRReg stringGPR = string.gpr();
11245         GPRReg regExpGPR = regExp.gpr();
11246         GPRReg replaceGPR = replace.gpr();
11247         speculateString(node-&gt;child1(), stringGPR);
11248         speculateRegExpObject(node-&gt;child2(), regExpGPR);
11249         speculateString(node-&gt;child3(), replaceGPR);
11250 
11251         flushRegisters();
11252         GPRFlushedCallResult result(this);
11253         callOperation(operationStringProtoFuncReplaceRegExpString, result.gpr(), stringGPR, regExpGPR, replaceGPR);
11254         m_jit.exceptionCheck();
11255         cellResult(result.gpr(), node);
11256         if (sample)
11257             m_jit.decrementSuperSamplerCount();
11258         return;
11259     }
11260 
11261     // If we fixed up the edge of child2, we inserted a Check(@child2, String).
11262     OperandSpeculationMode child2SpeculationMode = AutomaticOperandSpeculation;
11263     if (node-&gt;child2().useKind() == StringUse)
11264         child2SpeculationMode = ManualOperandSpeculation;
11265 
11266     JSValueOperand string(this, node-&gt;child1());
11267     JSValueOperand search(this, node-&gt;child2(), child2SpeculationMode);
11268     JSValueOperand replace(this, node-&gt;child3());
11269     JSValueRegs stringRegs = string.jsValueRegs();
11270     JSValueRegs searchRegs = search.jsValueRegs();
11271     JSValueRegs replaceRegs = replace.jsValueRegs();
11272 
11273     flushRegisters();
11274     GPRFlushedCallResult result(this);
11275     callOperation(operationStringProtoFuncReplaceGeneric, result.gpr(), stringRegs, searchRegs, replaceRegs);
11276     m_jit.exceptionCheck();
11277     cellResult(result.gpr(), node);
11278     if (sample)
11279         m_jit.decrementSuperSamplerCount();
11280 }
11281 
11282 void SpeculativeJIT::compileRegExpExecNonGlobalOrSticky(Node* node)
11283 {
11284     SpeculateCellOperand globalObject(this, node-&gt;child1());
11285     SpeculateCellOperand argument(this, node-&gt;child2());
11286     GPRReg globalObjectGPR = globalObject.gpr();
11287     GPRReg argumentGPR = argument.gpr();
11288 
11289     speculateString(node-&gt;child2(), argumentGPR);
11290 
11291     flushRegisters();
11292     JSValueRegsFlushedCallResult result(this);
11293     JSValueRegs resultRegs = result.regs();
11294     callOperation(
11295         operationRegExpExecNonGlobalOrSticky, resultRegs,
11296         globalObjectGPR, TrustedImmPtr(node-&gt;cellOperand()), argumentGPR);
11297     m_jit.exceptionCheck();
11298 
11299     jsValueResult(resultRegs, node);
11300 }
11301 
11302 void SpeculativeJIT::compileRegExpMatchFastGlobal(Node* node)
11303 {
11304     SpeculateCellOperand globalObject(this, node-&gt;child1());
11305     SpeculateCellOperand argument(this, node-&gt;child2());
11306     GPRReg globalObjectGPR = globalObject.gpr();
11307     GPRReg argumentGPR = argument.gpr();
11308 
11309     speculateString(node-&gt;child2(), argumentGPR);
11310 
11311     flushRegisters();
11312     JSValueRegsFlushedCallResult result(this);
11313     JSValueRegs resultRegs = result.regs();
11314     callOperation(
11315         operationRegExpMatchFastGlobalString, resultRegs,
11316         globalObjectGPR, TrustedImmPtr(node-&gt;cellOperand()), argumentGPR);
11317     m_jit.exceptionCheck();
11318 
11319     jsValueResult(resultRegs, node);
11320 }
11321 
11322 void SpeculativeJIT::compileRegExpMatchFast(Node* node)
11323 {
11324     SpeculateCellOperand globalObject(this, node-&gt;child1());
11325     SpeculateCellOperand base(this, node-&gt;child2());
11326     SpeculateCellOperand argument(this, node-&gt;child3());
11327     GPRReg globalObjectGPR = globalObject.gpr();
11328     GPRReg baseGPR = base.gpr();
11329     GPRReg argumentGPR = argument.gpr();
11330     speculateRegExpObject(node-&gt;child2(), baseGPR);
11331     speculateString(node-&gt;child3(), argumentGPR);
11332 
11333     flushRegisters();
11334     JSValueRegsFlushedCallResult result(this);
11335     JSValueRegs resultRegs = result.regs();
11336     callOperation(
11337         operationRegExpMatchFastString, resultRegs,
11338         globalObjectGPR, baseGPR, argumentGPR);
11339     m_jit.exceptionCheck();
11340 
11341     jsValueResult(resultRegs, node);
11342 }
11343 
11344 void SpeculativeJIT::compileLazyJSConstant(Node* node)
11345 {
11346     JSValueRegsTemporary result(this);
11347     JSValueRegs resultRegs = result.regs();
11348     node-&gt;lazyJSValue().emit(m_jit, resultRegs);
11349     jsValueResult(resultRegs, node);
11350 }
11351 
11352 void SpeculativeJIT::compileMaterializeNewObject(Node* node)
11353 {
11354     RegisteredStructure structure = node-&gt;structureSet().at(0);
11355     ASSERT(m_jit.graph().varArgChild(node, 0)-&gt;dynamicCastConstant&lt;Structure*&gt;(*m_jit.vm()) == structure.get());
11356 
11357     ObjectMaterializationData&amp; data = node-&gt;objectMaterializationData();
11358 
11359     IndexingType indexingType = structure-&gt;indexingType();
11360     bool hasIndexingHeader = hasIndexedProperties(indexingType);
11361     int32_t publicLength = 0;
11362     int32_t vectorLength = 0;
11363 
11364     if (hasIndexingHeader) {
11365         for (unsigned i = data.m_properties.size(); i--;) {
11366             Edge edge = m_jit.graph().varArgChild(node, 1 + i);
11367             switch (data.m_properties[i].kind()) {
11368             case PublicLengthPLoc:
11369                 publicLength = edge-&gt;asInt32();
11370                 break;
11371             case VectorLengthPLoc:
11372                 vectorLength = edge-&gt;asInt32();
11373                 break;
11374             default:
11375                 break;
11376             }
11377         }
11378     }
11379 
11380     GPRTemporary result(this);
11381     GPRTemporary storage(this);
11382     GPRReg resultGPR = result.gpr();
11383     GPRReg storageGPR = storage.gpr();
11384 
11385     emitAllocateRawObject(resultGPR, structure, storageGPR, 0, vectorLength);
11386 
11387     m_jit.store32(
11388         JITCompiler::TrustedImm32(publicLength),
11389         JITCompiler::Address(storageGPR, Butterfly::offsetOfPublicLength()));
11390 
11391     for (unsigned i = data.m_properties.size(); i--;) {
11392         Edge edge = m_jit.graph().varArgChild(node, 1 + i);
11393         PromotedLocationDescriptor descriptor = data.m_properties[i];
11394         switch (descriptor.kind()) {
11395         case IndexedPropertyPLoc: {
11396             JSValueOperand value(this, edge);
11397             m_jit.storeValue(
11398                 value.jsValueRegs(),
11399                 JITCompiler::Address(storageGPR, sizeof(EncodedJSValue) * descriptor.info()));
11400             break;
11401         }
11402 
11403         case NamedPropertyPLoc: {
11404             StringImpl* uid = m_jit.graph().identifiers()[descriptor.info()];
11405             for (PropertyMapEntry entry : structure-&gt;getPropertiesConcurrently()) {
11406                 if (uid != entry.key)
11407                     continue;
11408 
11409                 JSValueOperand value(this, edge);
11410                 GPRReg baseGPR = isInlineOffset(entry.offset) ? resultGPR : storageGPR;
11411                 m_jit.storeValue(
11412                     value.jsValueRegs(),
11413                     JITCompiler::Address(baseGPR, offsetRelativeToBase(entry.offset)));
11414             }
11415             break;
11416         }
11417 
11418         default:
11419             break;
11420         }
11421     }
11422 
11423     cellResult(resultGPR, node);
11424 }
11425 
11426 void SpeculativeJIT::compileRecordRegExpCachedResult(Node* node)
11427 {
11428     Edge globalObjectEdge = m_jit.graph().varArgChild(node, 0);
11429     Edge regExpEdge = m_jit.graph().varArgChild(node, 1);
11430     Edge stringEdge = m_jit.graph().varArgChild(node, 2);
11431     Edge startEdge = m_jit.graph().varArgChild(node, 3);
11432     Edge endEdge = m_jit.graph().varArgChild(node, 4);
11433 
11434     SpeculateCellOperand globalObject(this, globalObjectEdge);
11435     SpeculateCellOperand regExp(this, regExpEdge);
11436     SpeculateCellOperand string(this, stringEdge);
11437     SpeculateInt32Operand start(this, startEdge);
11438     SpeculateInt32Operand end(this, endEdge);
11439 
11440     GPRReg globalObjectGPR = globalObject.gpr();
11441     GPRReg regExpGPR = regExp.gpr();
11442     GPRReg stringGPR = string.gpr();
11443     GPRReg startGPR = start.gpr();
11444     GPRReg endGPR = end.gpr();
11445 
11446     ptrdiff_t offset = JSGlobalObject::regExpGlobalDataOffset() + RegExpGlobalData::offsetOfCachedResult();
11447 
11448     m_jit.storePtr(
11449         regExpGPR,
11450         JITCompiler::Address(globalObjectGPR, offset + RegExpCachedResult::offsetOfLastRegExp()));
11451     m_jit.storePtr(
11452         stringGPR,
11453         JITCompiler::Address(globalObjectGPR, offset + RegExpCachedResult::offsetOfLastInput()));
11454     m_jit.store32(
11455         startGPR,
11456         JITCompiler::Address(
11457             globalObjectGPR,
11458             offset + RegExpCachedResult::offsetOfResult() + OBJECT_OFFSETOF(MatchResult, start)));
11459     m_jit.store32(
11460         endGPR,
11461         JITCompiler::Address(
11462             globalObjectGPR,
11463             offset + RegExpCachedResult::offsetOfResult() + OBJECT_OFFSETOF(MatchResult, end)));
11464     m_jit.store8(
11465         TrustedImm32(0),
11466         JITCompiler::Address(globalObjectGPR, offset + RegExpCachedResult::offsetOfReified()));
11467 
11468     noResult(node);
11469 }
11470 
11471 void SpeculativeJIT::compileDefineDataProperty(Node* node)
11472 {
11473 #if USE(JSVALUE64)
11474     static_assert(GPRInfo::numberOfRegisters &gt;= 5, &quot;We are assuming we have enough registers to make this call without incrementally setting up the arguments.&quot;);
11475 #else
11476     static_assert(GPRInfo::numberOfRegisters &gt;= 6, &quot;We are assuming we have enough registers to make this call without incrementally setting up the arguments.&quot;);
11477 #endif
11478 
11479     SpeculateCellOperand base(this, m_jit.graph().varArgChild(node, 0));
11480     GPRReg baseGPR = base.gpr();
11481 
11482     JSValueOperand value(this, m_jit.graph().varArgChild(node, 2));
11483     JSValueRegs valueRegs = value.jsValueRegs();
11484 
11485     SpeculateInt32Operand attributes(this, m_jit.graph().varArgChild(node, 3));
11486     GPRReg attributesGPR = attributes.gpr();
11487 
11488     Edge&amp; propertyEdge = m_jit.graph().varArgChild(node, 1);
11489     switch (propertyEdge.useKind()) {
11490     case StringUse: {
11491         SpeculateCellOperand property(this, propertyEdge);
11492         GPRReg propertyGPR = property.gpr();
11493         speculateString(propertyEdge, propertyGPR);
11494 
11495         useChildren(node);
11496 
11497         flushRegisters();
11498         callOperation(operationDefineDataPropertyString, NoResult, baseGPR, propertyGPR, valueRegs, attributesGPR);
11499         m_jit.exceptionCheck();
11500         break;
11501     }
11502     case StringIdentUse: {
11503         SpeculateCellOperand property(this, propertyEdge);
11504         GPRTemporary ident(this);
11505 
11506         GPRReg propertyGPR = property.gpr();
11507         GPRReg identGPR = ident.gpr();
11508 
11509         speculateString(propertyEdge, propertyGPR);
11510         speculateStringIdentAndLoadStorage(propertyEdge, propertyGPR, identGPR);
11511 
11512         useChildren(node);
11513 
11514         flushRegisters();
11515         callOperation(operationDefineDataPropertyStringIdent, NoResult, baseGPR, identGPR, valueRegs, attributesGPR);
11516         m_jit.exceptionCheck();
11517         break;
11518     }
11519     case SymbolUse: {
11520         SpeculateCellOperand property(this, propertyEdge);
11521         GPRReg propertyGPR = property.gpr();
11522         speculateSymbol(propertyEdge, propertyGPR);
11523 
11524         useChildren(node);
11525 
11526         flushRegisters();
11527         callOperation(operationDefineDataPropertySymbol, NoResult, baseGPR, propertyGPR, valueRegs, attributesGPR);
11528         m_jit.exceptionCheck();
11529         break;
11530     }
11531     case UntypedUse: {
11532         JSValueOperand property(this, propertyEdge);
11533         JSValueRegs propertyRegs = property.jsValueRegs();
11534 
11535         useChildren(node);
11536 
11537         flushRegisters();
11538         callOperation(operationDefineDataProperty, NoResult, baseGPR, propertyRegs, valueRegs, attributesGPR);
11539         m_jit.exceptionCheck();
11540         break;
11541     }
11542     default:
11543         RELEASE_ASSERT_NOT_REACHED();
11544     }
11545 
11546     noResult(node, UseChildrenCalledExplicitly);
11547 }
11548 
11549 void SpeculativeJIT::compileDefineAccessorProperty(Node* node)
11550 {
11551 #if USE(JSVALUE64)
11552     static_assert(GPRInfo::numberOfRegisters &gt;= 5, &quot;We are assuming we have enough registers to make this call without incrementally setting up the arguments.&quot;);
11553 #else
11554     static_assert(GPRInfo::numberOfRegisters &gt;= 6, &quot;We are assuming we have enough registers to make this call without incrementally setting up the arguments.&quot;);
11555 #endif
11556 
11557     SpeculateCellOperand base(this, m_jit.graph().varArgChild(node, 0));
11558     GPRReg baseGPR = base.gpr();
11559 
11560     SpeculateCellOperand getter(this, m_jit.graph().varArgChild(node, 2));
11561     GPRReg getterGPR = getter.gpr();
11562 
11563     SpeculateCellOperand setter(this, m_jit.graph().varArgChild(node, 3));
11564     GPRReg setterGPR = setter.gpr();
11565 
11566     SpeculateInt32Operand attributes(this, m_jit.graph().varArgChild(node, 4));
11567     GPRReg attributesGPR = attributes.gpr();
11568 
11569     Edge&amp; propertyEdge = m_jit.graph().varArgChild(node, 1);
11570     switch (propertyEdge.useKind()) {
11571     case StringUse: {
11572         SpeculateCellOperand property(this, propertyEdge);
11573         GPRReg propertyGPR = property.gpr();
11574         speculateString(propertyEdge, propertyGPR);
11575 
11576         useChildren(node);
11577 
11578         flushRegisters();
11579         callOperation(operationDefineAccessorPropertyString, NoResult, baseGPR, propertyGPR, getterGPR, setterGPR, attributesGPR);
11580         m_jit.exceptionCheck();
11581         break;
11582     }
11583     case StringIdentUse: {
11584         SpeculateCellOperand property(this, propertyEdge);
11585         GPRTemporary ident(this);
11586 
11587         GPRReg propertyGPR = property.gpr();
11588         GPRReg identGPR = ident.gpr();
11589 
11590         speculateString(propertyEdge, propertyGPR);
11591         speculateStringIdentAndLoadStorage(propertyEdge, propertyGPR, identGPR);
11592 
11593         useChildren(node);
11594 
11595         flushRegisters();
11596         callOperation(operationDefineAccessorPropertyStringIdent, NoResult, baseGPR, identGPR, getterGPR, setterGPR, attributesGPR);
11597         m_jit.exceptionCheck();
11598         break;
11599     }
11600     case SymbolUse: {
11601         SpeculateCellOperand property(this, propertyEdge);
11602         GPRReg propertyGPR = property.gpr();
11603         speculateSymbol(propertyEdge, propertyGPR);
11604 
11605         useChildren(node);
11606 
11607         flushRegisters();
11608         callOperation(operationDefineAccessorPropertySymbol, NoResult, baseGPR, propertyGPR, getterGPR, setterGPR, attributesGPR);
11609         m_jit.exceptionCheck();
11610         break;
11611     }
11612     case UntypedUse: {
11613         JSValueOperand property(this, propertyEdge);
11614         JSValueRegs propertyRegs = property.jsValueRegs();
11615 
11616         useChildren(node);
11617 
11618         flushRegisters();
11619         callOperation(operationDefineAccessorProperty, NoResult, baseGPR, propertyRegs, getterGPR, setterGPR, attributesGPR);
11620         m_jit.exceptionCheck();
11621         break;
11622     }
11623     default:
11624         RELEASE_ASSERT_NOT_REACHED();
11625     }
11626 
11627     noResult(node, UseChildrenCalledExplicitly);
11628 }
11629 
11630 void SpeculativeJIT::emitAllocateButterfly(GPRReg storageResultGPR, GPRReg sizeGPR, GPRReg scratch1, GPRReg scratch2, GPRReg scratch3, MacroAssembler::JumpList&amp; slowCases)
11631 {
11632     RELEASE_ASSERT(RegisterSet(storageResultGPR, sizeGPR, scratch1, scratch2, scratch3).numberOfSetGPRs() == 5);
11633     ASSERT((1 &lt;&lt; 3) == sizeof(JSValue));
11634     m_jit.zeroExtend32ToPtr(sizeGPR, scratch1);
11635     m_jit.lshift32(TrustedImm32(3), scratch1);
11636     m_jit.add32(TrustedImm32(sizeof(IndexingHeader)), scratch1, scratch2);
11637 #if !ASSERT_DISABLED
11638     MacroAssembler::Jump didNotOverflow = m_jit.branch32(MacroAssembler::AboveOrEqual, scratch2, sizeGPR);
11639     m_jit.abortWithReason(UncheckedOverflow);
11640     didNotOverflow.link(&amp;m_jit);
11641 #endif
11642     m_jit.emitAllocateVariableSized(
11643         storageResultGPR, m_jit.vm()-&gt;jsValueGigacageAuxiliarySpace, scratch2, scratch1, scratch3, slowCases);
11644     m_jit.addPtr(TrustedImm32(sizeof(IndexingHeader)), storageResultGPR);
11645 
11646     m_jit.store32(sizeGPR, MacroAssembler::Address(storageResultGPR, Butterfly::offsetOfPublicLength()));
11647     m_jit.store32(sizeGPR, MacroAssembler::Address(storageResultGPR, Butterfly::offsetOfVectorLength()));
11648 }
11649 
11650 void SpeculativeJIT::compileNormalizeMapKey(Node* node)
11651 {
11652     ASSERT(node-&gt;child1().useKind() == UntypedUse);
11653     JSValueOperand key(this, node-&gt;child1());
11654     JSValueRegsTemporary result(this, Reuse, key);
11655     GPRTemporary scratch(this);
11656     FPRTemporary doubleValue(this);
11657     FPRTemporary temp(this);
11658 
11659     JSValueRegs keyRegs = key.jsValueRegs();
11660     JSValueRegs resultRegs = result.regs();
11661     GPRReg scratchGPR = scratch.gpr();
11662     FPRReg doubleValueFPR = doubleValue.fpr();
11663     FPRReg tempFPR = temp.fpr();
11664 
11665     CCallHelpers::JumpList passThroughCases;
11666 
11667     passThroughCases.append(m_jit.branchIfNotNumber(keyRegs, scratchGPR));
11668     passThroughCases.append(m_jit.branchIfInt32(keyRegs));
11669 
11670 #if USE(JSVALUE64)
11671     m_jit.unboxDoubleWithoutAssertions(keyRegs.gpr(), scratchGPR, doubleValueFPR);
11672 #else
11673     unboxDouble(keyRegs.tagGPR(), keyRegs.payloadGPR(), doubleValueFPR, tempFPR);
11674 #endif
11675     passThroughCases.append(m_jit.branchIfNaN(doubleValueFPR));
11676 
11677     m_jit.truncateDoubleToInt32(doubleValueFPR, scratchGPR);
11678     m_jit.convertInt32ToDouble(scratchGPR, tempFPR);
11679     passThroughCases.append(m_jit.branchDouble(JITCompiler::DoubleNotEqual, doubleValueFPR, tempFPR));
11680 
11681     m_jit.boxInt32(scratchGPR, resultRegs);
11682     auto done = m_jit.jump();
11683 
11684     passThroughCases.link(&amp;m_jit);
11685     m_jit.moveValueRegs(keyRegs, resultRegs);
11686 
11687     done.link(&amp;m_jit);
11688     jsValueResult(resultRegs, node);
11689 }
11690 
11691 void SpeculativeJIT::compileGetMapBucketHead(Node* node)
11692 {
11693     SpeculateCellOperand map(this, node-&gt;child1());
11694     GPRTemporary bucket(this);
11695 
11696     GPRReg mapGPR = map.gpr();
11697     GPRReg bucketGPR = bucket.gpr();
11698 
11699     if (node-&gt;child1().useKind() == MapObjectUse)
11700         speculateMapObject(node-&gt;child1(), mapGPR);
11701     else if (node-&gt;child1().useKind() == SetObjectUse)
11702         speculateSetObject(node-&gt;child1(), mapGPR);
11703     else
11704         RELEASE_ASSERT_NOT_REACHED();
11705 
11706     ASSERT(HashMapImpl&lt;HashMapBucket&lt;HashMapBucketDataKey&gt;&gt;::offsetOfHead() == HashMapImpl&lt;HashMapBucket&lt;HashMapBucketDataKeyValue&gt;&gt;::offsetOfHead());
11707     m_jit.loadPtr(MacroAssembler::Address(mapGPR, HashMapImpl&lt;HashMapBucket&lt;HashMapBucketDataKey&gt;&gt;::offsetOfHead()), bucketGPR);
11708     cellResult(bucketGPR, node);
11709 }
11710 
11711 void SpeculativeJIT::compileGetMapBucketNext(Node* node)
11712 {
11713     SpeculateCellOperand bucket(this, node-&gt;child1());
11714     GPRTemporary result(this);
11715 
11716     GPRReg bucketGPR = bucket.gpr();
11717     GPRReg resultGPR = result.gpr();
11718 
11719     ASSERT(HashMapBucket&lt;HashMapBucketDataKey&gt;::offsetOfNext() == HashMapBucket&lt;HashMapBucketDataKeyValue&gt;::offsetOfNext());
11720     ASSERT(HashMapBucket&lt;HashMapBucketDataKey&gt;::offsetOfKey() == HashMapBucket&lt;HashMapBucketDataKeyValue&gt;::offsetOfKey());
11721     m_jit.loadPtr(MacroAssembler::Address(bucketGPR, HashMapBucket&lt;HashMapBucketDataKeyValue&gt;::offsetOfNext()), resultGPR);
11722 
11723     MacroAssembler::Label loop = m_jit.label();
11724     auto notBucket = m_jit.branchTestPtr(MacroAssembler::Zero, resultGPR);
11725 #if USE(JSVALUE32_64)
11726     auto done = m_jit.branch32(MacroAssembler::NotEqual, MacroAssembler::Address(resultGPR, HashMapBucket&lt;HashMapBucketDataKeyValue&gt;::offsetOfKey() + TagOffset), TrustedImm32(JSValue::EmptyValueTag));
11727 #else
11728     auto done = m_jit.branchTest64(MacroAssembler::NonZero, MacroAssembler::Address(resultGPR, HashMapBucket&lt;HashMapBucketDataKeyValue&gt;::offsetOfKey()));
11729 #endif
11730     m_jit.loadPtr(MacroAssembler::Address(resultGPR, HashMapBucket&lt;HashMapBucketDataKeyValue&gt;::offsetOfNext()), resultGPR);
11731     m_jit.jump().linkTo(loop, &amp;m_jit);
11732 
11733     notBucket.link(&amp;m_jit);
11734     JSCell* sentinel = nullptr;
11735     if (node-&gt;bucketOwnerType() == BucketOwnerType::Map)
11736         sentinel = m_jit.vm()-&gt;sentinelMapBucket();
11737     else {
11738         ASSERT(node-&gt;bucketOwnerType() == BucketOwnerType::Set);
11739         sentinel = m_jit.vm()-&gt;sentinelSetBucket();
11740     }
11741     m_jit.move(TrustedImmPtr::weakPointer(m_jit.graph(), sentinel), resultGPR);
11742     done.link(&amp;m_jit);
11743 
11744     cellResult(resultGPR, node);
11745 }
11746 
11747 void SpeculativeJIT::compileLoadKeyFromMapBucket(Node* node)
11748 {
11749     SpeculateCellOperand bucket(this, node-&gt;child1());
11750     JSValueRegsTemporary result(this);
11751 
11752     GPRReg bucketGPR = bucket.gpr();
11753     JSValueRegs resultRegs = result.regs();
11754 
11755     m_jit.loadValue(MacroAssembler::Address(bucketGPR, HashMapBucket&lt;HashMapBucketDataKeyValue&gt;::offsetOfKey()), resultRegs);
11756     jsValueResult(resultRegs, node);
11757 }
11758 
11759 void SpeculativeJIT::compileLoadValueFromMapBucket(Node* node)
11760 {
11761     SpeculateCellOperand bucket(this, node-&gt;child1());
11762     JSValueRegsTemporary result(this);
11763 
11764     GPRReg bucketGPR = bucket.gpr();
11765     JSValueRegs resultRegs = result.regs();
11766 
11767     m_jit.loadValue(MacroAssembler::Address(bucketGPR, HashMapBucket&lt;HashMapBucketDataKeyValue&gt;::offsetOfValue()), resultRegs);
11768     jsValueResult(resultRegs, node);
11769 }
11770 
11771 void SpeculativeJIT::compileExtractValueFromWeakMapGet(Node* node)
11772 {
11773     JSValueOperand value(this, node-&gt;child1());
11774     JSValueRegsTemporary result(this, Reuse, value);
11775 
11776     JSValueRegs valueRegs = value.jsValueRegs();
11777     JSValueRegs resultRegs = result.regs();
11778 
11779 #if USE(JSVALUE64)
11780     m_jit.moveValueRegs(valueRegs, resultRegs);
11781     auto done = m_jit.branchTestPtr(CCallHelpers::NonZero, resultRegs.payloadGPR());
11782     m_jit.moveValue(jsUndefined(), resultRegs);
11783     done.link(&amp;m_jit);
11784 #else
11785     auto isEmpty = m_jit.branchIfEmpty(valueRegs.tagGPR());
11786     m_jit.moveValueRegs(valueRegs, resultRegs);
11787     auto done = m_jit.jump();
11788 
11789     isEmpty.link(&amp;m_jit);
11790     m_jit.moveValue(jsUndefined(), resultRegs);
11791 
11792     done.link(&amp;m_jit);
11793 #endif
11794 
11795     jsValueResult(resultRegs, node, DataFormatJS);
11796 }
11797 
11798 void SpeculativeJIT::compileThrow(Node* node)
11799 {
11800     JSValueOperand value(this, node-&gt;child1());
11801     JSValueRegs valueRegs = value.jsValueRegs();
11802     flushRegisters();
11803     callOperation(operationThrowDFG, valueRegs);
11804     m_jit.exceptionCheck();
11805     m_jit.breakpoint();
11806     noResult(node);
11807 }
11808 
11809 void SpeculativeJIT::compileThrowStaticError(Node* node)
11810 {
11811     SpeculateCellOperand message(this, node-&gt;child1());
11812     GPRReg messageGPR = message.gpr();
11813     speculateString(node-&gt;child1(), messageGPR);
11814     flushRegisters();
11815     callOperation(operationThrowStaticError, messageGPR, node-&gt;errorType());
11816     m_jit.exceptionCheck();
11817     m_jit.breakpoint();
11818     noResult(node);
11819 }
11820 
11821 void SpeculativeJIT::compileGetEnumerableLength(Node* node)
11822 {
11823     SpeculateCellOperand enumerator(this, node-&gt;child1());
11824     GPRFlushedCallResult result(this);
11825     GPRReg resultGPR = result.gpr();
11826 
11827     m_jit.load32(MacroAssembler::Address(enumerator.gpr(), JSPropertyNameEnumerator::indexedLengthOffset()), resultGPR);
11828     int32Result(resultGPR, node);
11829 }
11830 
11831 void SpeculativeJIT::compileHasGenericProperty(Node* node)
11832 {
11833     JSValueOperand base(this, node-&gt;child1());
11834     SpeculateCellOperand property(this, node-&gt;child2());
11835 
11836     JSValueRegs baseRegs = base.jsValueRegs();
11837     GPRReg propertyGPR = property.gpr();
11838 
11839     flushRegisters();
11840     JSValueRegsFlushedCallResult result(this);
11841     JSValueRegs resultRegs = result.regs();
11842     callOperation(operationHasGenericProperty, resultRegs, baseRegs, propertyGPR);
11843     m_jit.exceptionCheck();
11844     blessedBooleanResult(resultRegs.payloadGPR(), node);
11845 }
11846 
11847 void SpeculativeJIT::compileToIndexString(Node* node)
11848 {
11849     SpeculateInt32Operand index(this, node-&gt;child1());
11850     GPRReg indexGPR = index.gpr();
11851 
11852     flushRegisters();
11853     GPRFlushedCallResult result(this);
11854     GPRReg resultGPR = result.gpr();
11855     callOperation(operationToIndexString, resultGPR, indexGPR);
11856     m_jit.exceptionCheck();
11857     cellResult(resultGPR, node);
11858 }
11859 
11860 void SpeculativeJIT::compilePutByIdFlush(Node* node)
11861 {
11862     SpeculateCellOperand base(this, node-&gt;child1());
11863     JSValueOperand value(this, node-&gt;child2());
11864     GPRTemporary scratch(this);
11865 
11866     GPRReg baseGPR = base.gpr();
11867     JSValueRegs valueRegs = value.jsValueRegs();
11868     GPRReg scratchGPR = scratch.gpr();
11869     flushRegisters();
11870 
11871     cachedPutById(node-&gt;origin.semantic, baseGPR, valueRegs, scratchGPR, node-&gt;identifierNumber(), NotDirect, MacroAssembler::Jump(), DontSpill);
11872 
11873     noResult(node);
11874 }
11875 
11876 void SpeculativeJIT::compilePutById(Node* node)
11877 {
11878     SpeculateCellOperand base(this, node-&gt;child1());
11879     JSValueOperand value(this, node-&gt;child2());
11880     GPRTemporary scratch(this);
11881 
11882     GPRReg baseGPR = base.gpr();
11883     JSValueRegs valueRegs = value.jsValueRegs();
11884     GPRReg scratchGPR = scratch.gpr();
11885 
11886     cachedPutById(node-&gt;origin.semantic, baseGPR, valueRegs, scratchGPR, node-&gt;identifierNumber(), NotDirect);
11887 
11888     noResult(node);
11889 }
11890 
11891 void SpeculativeJIT::compilePutByIdDirect(Node* node)
11892 {
11893     SpeculateCellOperand base(this, node-&gt;child1());
11894     JSValueOperand value(this, node-&gt;child2());
11895     GPRTemporary scratch(this);
11896 
11897     GPRReg baseGPR = base.gpr();
11898     JSValueRegs valueRegs = value.jsValueRegs();
11899     GPRReg scratchGPR = scratch.gpr();
11900 
11901     cachedPutById(node-&gt;origin.semantic, baseGPR, valueRegs, scratchGPR, node-&gt;identifierNumber(), Direct);
11902 
11903     noResult(node);
11904 }
11905 
11906 void SpeculativeJIT::compilePutByIdWithThis(Node* node)
11907 {
11908     JSValueOperand base(this, node-&gt;child1());
11909     JSValueRegs baseRegs = base.jsValueRegs();
11910     JSValueOperand thisValue(this, node-&gt;child2());
11911     JSValueRegs thisRegs = thisValue.jsValueRegs();
11912     JSValueOperand value(this, node-&gt;child3());
11913     JSValueRegs valueRegs = value.jsValueRegs();
11914 
11915     flushRegisters();
11916     callOperation(m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByIdWithThisStrict : operationPutByIdWithThis,
11917         NoResult, baseRegs, thisRegs, valueRegs, identifierUID(node-&gt;identifierNumber()));
11918     m_jit.exceptionCheck();
11919 
11920     noResult(node);
11921 }
11922 
11923 void SpeculativeJIT::compileGetByOffset(Node* node)
11924 {
11925     StorageOperand storage(this, node-&gt;child1());
11926     JSValueRegsTemporary result(this, Reuse, storage);
11927 
11928     GPRReg storageGPR = storage.gpr();
11929     JSValueRegs resultRegs = result.regs();
11930 
11931     StorageAccessData&amp; storageAccessData = node-&gt;storageAccessData();
11932 
11933     m_jit.loadValue(JITCompiler::Address(storageGPR, offsetRelativeToBase(storageAccessData.offset)), resultRegs);
11934 
11935     jsValueResult(resultRegs, node);
11936 }
11937 
11938 void SpeculativeJIT::compilePutByOffset(Node* node)
11939 {
11940     StorageOperand storage(this, node-&gt;child1());
11941     JSValueOperand value(this, node-&gt;child3());
11942 
11943     GPRReg storageGPR = storage.gpr();
11944     JSValueRegs valueRegs = value.jsValueRegs();
11945 
11946     speculate(node, node-&gt;child2());
11947 
11948     StorageAccessData&amp; storageAccessData = node-&gt;storageAccessData();
11949 
11950     m_jit.storeValue(valueRegs, JITCompiler::Address(storageGPR, offsetRelativeToBase(storageAccessData.offset)));
11951 
11952     noResult(node);
11953 }
11954 
11955 void SpeculativeJIT::compileMatchStructure(Node* node)
11956 {
11957     SpeculateCellOperand base(this, node-&gt;child1());
11958     GPRTemporary temp(this);
11959     GPRReg baseGPR = base.gpr();
11960     GPRReg tempGPR = temp.gpr();
11961 
11962     m_jit.load32(JITCompiler::Address(baseGPR, JSCell::structureIDOffset()), tempGPR);
11963 
11964     auto&amp; variants = node-&gt;matchStructureData().variants;
11965     Vector&lt;int64_t&gt; cases;
11966     for (MatchStructureVariant&amp; variant : variants)
11967         cases.append(bitwise_cast&lt;int32_t&gt;(variant.structure-&gt;id()));
11968 
11969     BinarySwitch binarySwitch(tempGPR, cases, BinarySwitch::Int32);
11970     JITCompiler::JumpList done;
11971     while (binarySwitch.advance(m_jit)) {
11972         m_jit.boxBooleanPayload(variants[binarySwitch.caseIndex()].result, tempGPR);
11973         done.append(m_jit.jump());
11974     }
11975     speculationCheck(BadCache, JSValueRegs(), node, binarySwitch.fallThrough());
11976 
11977     done.link(&amp;m_jit);
11978 
11979     blessedBooleanResult(tempGPR, node);
11980 }
11981 
11982 void SpeculativeJIT::compileHasStructureProperty(Node* node)
11983 {
11984     JSValueOperand base(this, node-&gt;child1());
11985     SpeculateCellOperand property(this, node-&gt;child2());
11986     SpeculateCellOperand enumerator(this, node-&gt;child3());
11987     JSValueRegsTemporary result(this);
11988 
11989     JSValueRegs baseRegs = base.jsValueRegs();
11990     GPRReg propertyGPR = property.gpr();
11991     JSValueRegs resultRegs = result.regs();
11992 
11993     CCallHelpers::JumpList wrongStructure;
11994 
11995     wrongStructure.append(m_jit.branchIfNotCell(baseRegs));
11996 
11997     m_jit.load32(MacroAssembler::Address(baseRegs.payloadGPR(), JSCell::structureIDOffset()), resultRegs.payloadGPR());
11998     wrongStructure.append(m_jit.branch32(MacroAssembler::NotEqual,
11999         resultRegs.payloadGPR(),
12000         MacroAssembler::Address(enumerator.gpr(), JSPropertyNameEnumerator::cachedStructureIDOffset())));
12001 
12002     moveTrueTo(resultRegs.payloadGPR());
12003     MacroAssembler::Jump done = m_jit.jump();
12004 
12005     done.link(&amp;m_jit);
12006 
12007     addSlowPathGenerator(slowPathCall(wrongStructure, this, operationHasGenericProperty, resultRegs, baseRegs, propertyGPR));
12008     blessedBooleanResult(resultRegs.payloadGPR(), node);
12009 }
12010 
12011 void SpeculativeJIT::compileGetPropertyEnumerator(Node* node)
12012 {
12013     if (node-&gt;child1().useKind() == CellUse) {
12014         SpeculateCellOperand base(this, node-&gt;child1());
12015         GPRReg baseGPR = base.gpr();
12016 
12017         flushRegisters();
12018         GPRFlushedCallResult result(this);
12019         GPRReg resultGPR = result.gpr();
12020         callOperation(operationGetPropertyEnumeratorCell, resultGPR, baseGPR);
12021         m_jit.exceptionCheck();
12022         cellResult(resultGPR, node);
12023         return;
12024     }
12025 
12026     JSValueOperand base(this, node-&gt;child1());
12027     JSValueRegs baseRegs = base.jsValueRegs();
12028 
12029     flushRegisters();
12030     GPRFlushedCallResult result(this);
12031     GPRReg resultGPR = result.gpr();
12032     callOperation(operationGetPropertyEnumerator, resultGPR, baseRegs);
12033     m_jit.exceptionCheck();
12034     cellResult(resultGPR, node);
12035 }
12036 
12037 void SpeculativeJIT::compileGetEnumeratorPname(Node* node)
12038 {
12039     ASSERT(node-&gt;op() == GetEnumeratorStructurePname || node-&gt;op() == GetEnumeratorGenericPname);
12040     SpeculateCellOperand enumerator(this, node-&gt;child1());
12041     SpeculateStrictInt32Operand index(this, node-&gt;child2());
12042     GPRTemporary scratch(this);
12043     JSValueRegsTemporary result(this);
12044 
12045     GPRReg enumeratorGPR = enumerator.gpr();
12046     GPRReg indexGPR = index.gpr();
12047     GPRReg scratchGPR = scratch.gpr();
12048     JSValueRegs resultRegs = result.regs();
12049 
12050     MacroAssembler::Jump inBounds = m_jit.branch32(MacroAssembler::Below, indexGPR,
12051         MacroAssembler::Address(enumeratorGPR, (node-&gt;op() == GetEnumeratorStructurePname)
12052             ? JSPropertyNameEnumerator::endStructurePropertyIndexOffset()
12053             : JSPropertyNameEnumerator::endGenericPropertyIndexOffset()));
12054 
12055     m_jit.moveValue(jsNull(), resultRegs);
12056 
12057     MacroAssembler::Jump done = m_jit.jump();
12058     inBounds.link(&amp;m_jit);
12059 
12060     m_jit.loadPtr(MacroAssembler::Address(enumeratorGPR, JSPropertyNameEnumerator::cachedPropertyNamesVectorOffset()), scratchGPR);
12061     m_jit.loadPtr(MacroAssembler::BaseIndex(scratchGPR, indexGPR, MacroAssembler::ScalePtr), resultRegs.payloadGPR());
12062 #if USE(JSVALUE32_64)
12063     m_jit.move(MacroAssembler::TrustedImm32(JSValue::CellTag), resultRegs.tagGPR());
12064 #endif
12065 
12066     done.link(&amp;m_jit);
12067     jsValueResult(resultRegs, node);
12068 }
12069 
12070 void SpeculativeJIT::compileGetExecutable(Node* node)
12071 {
12072     SpeculateCellOperand function(this, node-&gt;child1());
12073     GPRTemporary result(this, Reuse, function);
12074     GPRReg functionGPR = function.gpr();
12075     GPRReg resultGPR = result.gpr();
12076     speculateCellType(node-&gt;child1(), functionGPR, SpecFunction, JSFunctionType);
12077     m_jit.loadPtr(JITCompiler::Address(functionGPR, JSFunction::offsetOfExecutable()), resultGPR);
12078     cellResult(resultGPR, node);
12079 }
12080 
12081 void SpeculativeJIT::compileGetGetter(Node* node)
12082 {
12083     SpeculateCellOperand op1(this, node-&gt;child1());
12084     GPRTemporary result(this, Reuse, op1);
12085 
12086     GPRReg op1GPR = op1.gpr();
12087     GPRReg resultGPR = result.gpr();
12088 
12089     m_jit.loadPtr(JITCompiler::Address(op1GPR, GetterSetter::offsetOfGetter()), resultGPR);
12090 
12091     cellResult(resultGPR, node);
12092 }
12093 
12094 void SpeculativeJIT::compileGetSetter(Node* node)
12095 {
12096     SpeculateCellOperand op1(this, node-&gt;child1());
12097     GPRTemporary result(this, Reuse, op1);
12098 
12099     GPRReg op1GPR = op1.gpr();
12100     GPRReg resultGPR = result.gpr();
12101 
12102     m_jit.loadPtr(JITCompiler::Address(op1GPR, GetterSetter::offsetOfSetter()), resultGPR);
12103 
12104     cellResult(resultGPR, node);
12105 }
12106 
12107 void SpeculativeJIT::compileGetCallee(Node* node)
12108 {
12109     GPRTemporary result(this);
12110     m_jit.loadPtr(JITCompiler::payloadFor(CallFrameSlot::callee), result.gpr());
12111     cellResult(result.gpr(), node);
12112 }
12113 
12114 void SpeculativeJIT::compileSetCallee(Node* node)
12115 {
12116     SpeculateCellOperand callee(this, node-&gt;child1());
12117     m_jit.storeCell(callee.gpr(), JITCompiler::payloadFor(CallFrameSlot::callee));
12118     noResult(node);
12119 }
12120 
12121 void SpeculativeJIT::compileGetArgumentCountIncludingThis(Node* node)
12122 {
12123     GPRTemporary result(this);
12124     VirtualRegister argumentCountRegister;
12125     if (InlineCallFrame* inlineCallFrame = node-&gt;argumentsInlineCallFrame())
12126         argumentCountRegister = inlineCallFrame-&gt;argumentCountRegister;
12127     else
12128         argumentCountRegister = VirtualRegister(CallFrameSlot::argumentCount);
12129     m_jit.load32(JITCompiler::payloadFor(argumentCountRegister), result.gpr());
12130     int32Result(result.gpr(), node);
12131 }
12132 
12133 void SpeculativeJIT::compileSetArgumentCountIncludingThis(Node* node)
12134 {
12135     m_jit.store32(TrustedImm32(node-&gt;argumentCountIncludingThis()), JITCompiler::payloadFor(CallFrameSlot::argumentCount));
12136     noResult(node);
12137 }
12138 
12139 void SpeculativeJIT::compileStrCat(Node* node)
12140 {
12141     JSValueOperand op1(this, node-&gt;child1(), ManualOperandSpeculation);
12142     JSValueOperand op2(this, node-&gt;child2(), ManualOperandSpeculation);
12143     JSValueOperand op3(this, node-&gt;child3(), ManualOperandSpeculation);
12144 
12145     JSValueRegs op1Regs = op1.jsValueRegs();
12146     JSValueRegs op2Regs = op2.jsValueRegs();
12147     JSValueRegs op3Regs;
12148 
12149     if (node-&gt;child3())
12150         op3Regs = op3.jsValueRegs();
12151 
12152     flushRegisters();
12153 
12154     GPRFlushedCallResult result(this);
12155     if (node-&gt;child3())
12156         callOperation(operationStrCat3, result.gpr(), op1Regs, op2Regs, op3Regs);
12157     else
12158         callOperation(operationStrCat2, result.gpr(), op1Regs, op2Regs);
12159     m_jit.exceptionCheck();
12160 
12161     cellResult(result.gpr(), node);
12162 }
12163 
12164 void SpeculativeJIT::compileNewArrayBuffer(Node* node)
12165 {
12166     JSGlobalObject* globalObject = m_jit.graph().globalObjectFor(node-&gt;origin.semantic);
12167     auto* array = node-&gt;castOperand&lt;JSImmutableButterfly*&gt;();
12168 
12169     IndexingType indexingMode = node-&gt;indexingMode();
12170     RegisteredStructure structure = m_jit.graph().registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(indexingMode));
12171 
12172     if (!globalObject-&gt;isHavingABadTime() &amp;&amp; !hasAnyArrayStorage(indexingMode)) {
12173         GPRTemporary result(this);
12174         GPRTemporary scratch1(this);
12175         GPRTemporary scratch2(this);
12176 
12177         GPRReg resultGPR = result.gpr();
12178         GPRReg scratch1GPR = scratch1.gpr();
12179         GPRReg scratch2GPR = scratch2.gpr();
12180 
12181         MacroAssembler::JumpList slowCases;
12182 
12183         emitAllocateJSObject&lt;JSArray&gt;(resultGPR, TrustedImmPtr(structure), TrustedImmPtr(array-&gt;toButterfly()), scratch1GPR, scratch2GPR, slowCases);
12184 
12185         addSlowPathGenerator(slowPathCall(slowCases, this, operationNewArrayBuffer, result.gpr(), structure, array));
12186 
12187         DFG_ASSERT(m_jit.graph(), node, indexingMode &amp; IsArray, indexingMode);
12188         cellResult(resultGPR, node);
12189         return;
12190     }
12191 
12192     flushRegisters();
12193     GPRFlushedCallResult result(this);
12194 
12195     callOperation(operationNewArrayBuffer, result.gpr(), structure, TrustedImmPtr(node-&gt;cellOperand()));
12196     m_jit.exceptionCheck();
12197 
12198     cellResult(result.gpr(), node);
12199 }
12200 
12201 void SpeculativeJIT::compileNewArrayWithSize(Node* node)
12202 {
12203     JSGlobalObject* globalObject = m_jit.graph().globalObjectFor(node-&gt;origin.semantic);
12204     if (!globalObject-&gt;isHavingABadTime() &amp;&amp; !hasAnyArrayStorage(node-&gt;indexingType())) {
12205         SpeculateStrictInt32Operand size(this, node-&gt;child1());
12206         GPRTemporary result(this);
12207 
12208         GPRReg sizeGPR = size.gpr();
12209         GPRReg resultGPR = result.gpr();
12210 
12211         compileAllocateNewArrayWithSize(globalObject, resultGPR, sizeGPR, node-&gt;indexingType());
12212         cellResult(resultGPR, node);
12213         return;
12214     }
12215 
12216     SpeculateStrictInt32Operand size(this, node-&gt;child1());
12217     GPRReg sizeGPR = size.gpr();
12218     flushRegisters();
12219     GPRFlushedCallResult result(this);
12220     GPRReg resultGPR = result.gpr();
12221     GPRReg structureGPR = AssemblyHelpers::selectScratchGPR(sizeGPR);
12222     MacroAssembler::Jump bigLength = m_jit.branch32(MacroAssembler::AboveOrEqual, sizeGPR, TrustedImm32(MIN_ARRAY_STORAGE_CONSTRUCTION_LENGTH));
12223     m_jit.move(TrustedImmPtr(m_jit.graph().registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(node-&gt;indexingType()))), structureGPR);
12224     MacroAssembler::Jump done = m_jit.jump();
12225     bigLength.link(&amp;m_jit);
12226     m_jit.move(TrustedImmPtr(m_jit.graph().registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithArrayStorage))), structureGPR);
12227     done.link(&amp;m_jit);
12228     callOperation(operationNewArrayWithSize, resultGPR, structureGPR, sizeGPR, nullptr);
12229     m_jit.exceptionCheck();
12230     cellResult(resultGPR, node);
12231 }
12232 
12233 void SpeculativeJIT::compileNewTypedArray(Node* node)
12234 {
12235     switch (node-&gt;child1().useKind()) {
12236     case Int32Use:
12237         compileNewTypedArrayWithSize(node);
12238         break;
12239     case UntypedUse: {
12240         JSValueOperand argument(this, node-&gt;child1());
12241         JSValueRegs argumentRegs = argument.jsValueRegs();
12242 
12243         flushRegisters();
12244 
12245         GPRFlushedCallResult result(this);
12246         GPRReg resultGPR = result.gpr();
12247 
12248         JSGlobalObject* globalObject = m_jit.graph().globalObjectFor(node-&gt;origin.semantic);
12249         callOperation(
12250             operationNewTypedArrayWithOneArgumentForType(node-&gt;typedArrayType()),
12251             resultGPR, m_jit.graph().registerStructure(globalObject-&gt;typedArrayStructureConcurrently(node-&gt;typedArrayType())), argumentRegs);
12252         m_jit.exceptionCheck();
12253 
12254         cellResult(resultGPR, node);
12255         break;
12256     }
12257     default:
12258         RELEASE_ASSERT_NOT_REACHED();
12259         break;
12260     }
12261 }
12262 
12263 void SpeculativeJIT::compileToThis(Node* node)
12264 {
12265     ASSERT(node-&gt;child1().useKind() == UntypedUse);
12266     JSValueOperand thisValue(this, node-&gt;child1());
12267     JSValueRegsTemporary temp(this);
12268 
12269     JSValueRegs thisValueRegs = thisValue.jsValueRegs();
12270     JSValueRegs tempRegs = temp.regs();
12271 
12272     MacroAssembler::JumpList slowCases;
12273     slowCases.append(m_jit.branchIfNotCell(thisValueRegs));
12274     slowCases.append(
12275         m_jit.branchTest8(
12276             MacroAssembler::NonZero,
12277             MacroAssembler::Address(thisValueRegs.payloadGPR(), JSCell::typeInfoFlagsOffset()),
12278             MacroAssembler::TrustedImm32(OverridesToThis)));
12279     m_jit.moveValueRegs(thisValueRegs, tempRegs);
12280 
12281     J_JITOperation_EJ function;
12282     if (m_jit.graph().executableFor(node-&gt;origin.semantic)-&gt;isStrictMode())
12283         function = operationToThisStrict;
12284     else
12285         function = operationToThis;
12286     addSlowPathGenerator(slowPathCall(slowCases, this, function, tempRegs, thisValueRegs));
12287 
12288     jsValueResult(tempRegs, node);
12289 }
12290 
12291 void SpeculativeJIT::compileObjectKeys(Node* node)
12292 {
12293     switch (node-&gt;child1().useKind()) {
12294     case ObjectUse: {
12295         if (m_graph.isWatchingHavingABadTimeWatchpoint(node)) {
12296             SpeculateCellOperand object(this, node-&gt;child1());
12297             GPRTemporary structure(this);
12298             GPRTemporary scratch(this);
12299             GPRTemporary scratch2(this);
12300             GPRTemporary scratch3(this);
12301             GPRTemporary result(this);
12302 
12303             GPRReg objectGPR = object.gpr();
12304             GPRReg structureGPR = structure.gpr();
12305             GPRReg scratchGPR = scratch.gpr();
12306             GPRReg scratch2GPR = scratch2.gpr();
12307             GPRReg scratch3GPR = scratch3.gpr();
12308             GPRReg resultGPR = result.gpr();
12309 
12310             speculateObject(node-&gt;child1(), objectGPR);
12311 
12312             CCallHelpers::JumpList slowCases;
12313             m_jit.emitLoadStructure(*m_jit.vm(), objectGPR, structureGPR, scratchGPR);
12314             m_jit.loadPtr(CCallHelpers::Address(structureGPR, Structure::previousOrRareDataOffset()), scratchGPR);
12315 
12316             slowCases.append(m_jit.branchTestPtr(CCallHelpers::Zero, scratchGPR));
12317             slowCases.append(m_jit.branch32(CCallHelpers::Equal, CCallHelpers::Address(scratchGPR, JSCell::structureIDOffset()), TrustedImm32(bitwise_cast&lt;int32_t&gt;(m_jit.vm()-&gt;structureStructure-&gt;structureID()))));
12318 
12319             m_jit.loadPtr(CCallHelpers::Address(scratchGPR, StructureRareData::offsetOfCachedOwnKeys()), scratchGPR);
12320 
12321             ASSERT(bitwise_cast&lt;uintptr_t&gt;(StructureRareData::cachedOwnKeysSentinel()) == 1);
12322             slowCases.append(m_jit.branchPtr(CCallHelpers::BelowOrEqual, scratchGPR, TrustedImmPtr(bitwise_cast&lt;void*&gt;(StructureRareData::cachedOwnKeysSentinel()))));
12323 
12324             MacroAssembler::JumpList slowButArrayBufferCases;
12325 
12326             JSGlobalObject* globalObject = m_jit.graph().globalObjectFor(node-&gt;origin.semantic);
12327             RegisteredStructure arrayStructure = m_jit.graph().registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(CopyOnWriteArrayWithContiguous));
12328 
12329             m_jit.move(scratchGPR, scratch3GPR);
12330             m_jit.addPtr(TrustedImmPtr(JSImmutableButterfly::offsetOfData()), scratchGPR);
12331 
12332             emitAllocateJSObject&lt;JSArray&gt;(resultGPR, TrustedImmPtr(arrayStructure), scratchGPR, structureGPR, scratch2GPR, slowButArrayBufferCases);
12333 
12334             addSlowPathGenerator(slowPathCall(slowButArrayBufferCases, this, operationNewArrayBuffer, resultGPR, arrayStructure, scratch3GPR));
12335 
12336             addSlowPathGenerator(slowPathCall(slowCases, this, operationObjectKeysObject, resultGPR, objectGPR));
12337 
12338             cellResult(resultGPR, node);
12339             break;
12340         }
12341 
12342         SpeculateCellOperand object(this, node-&gt;child1());
12343 
12344         GPRReg objectGPR = object.gpr();
12345 
12346         speculateObject(node-&gt;child1(), objectGPR);
12347 
12348         flushRegisters();
12349         GPRFlushedCallResult result(this);
12350         GPRReg resultGPR = result.gpr();
12351         callOperation(operationObjectKeysObject, resultGPR, objectGPR);
12352         m_jit.exceptionCheck();
12353 
12354         cellResult(resultGPR, node);
12355         break;
12356     }
12357 
12358     case UntypedUse: {
12359         JSValueOperand object(this, node-&gt;child1());
12360 
12361         JSValueRegs objectRegs = object.jsValueRegs();
12362 
12363         flushRegisters();
12364         GPRFlushedCallResult result(this);
12365         GPRReg resultGPR = result.gpr();
12366         callOperation(operationObjectKeys, resultGPR, objectRegs);
12367         m_jit.exceptionCheck();
12368 
12369         cellResult(resultGPR, node);
12370         break;
12371     }
12372 
12373     default:
12374         RELEASE_ASSERT_NOT_REACHED();
12375         break;
12376     }
12377 }
12378 
12379 void SpeculativeJIT::compileObjectCreate(Node* node)
12380 {
12381     switch (node-&gt;child1().useKind()) {
12382     case ObjectUse: {
12383         SpeculateCellOperand prototype(this, node-&gt;child1());
12384 
12385         GPRReg prototypeGPR = prototype.gpr();
12386 
12387         speculateObject(node-&gt;child1(), prototypeGPR);
12388 
12389         flushRegisters();
12390         GPRFlushedCallResult result(this);
12391         GPRReg resultGPR = result.gpr();
12392         callOperation(operationObjectCreateObject, resultGPR, prototypeGPR);
12393         m_jit.exceptionCheck();
12394 
12395         cellResult(resultGPR, node);
12396         break;
12397     }
12398 
12399     case UntypedUse: {
12400         JSValueOperand prototype(this, node-&gt;child1());
12401 
12402         JSValueRegs prototypeRegs = prototype.jsValueRegs();
12403 
12404         flushRegisters();
12405         GPRFlushedCallResult result(this);
12406         GPRReg resultGPR = result.gpr();
12407         callOperation(operationObjectCreate, resultGPR, prototypeRegs);
12408         m_jit.exceptionCheck();
12409 
12410         cellResult(resultGPR, node);
12411         break;
12412     }
12413 
12414     default:
12415         RELEASE_ASSERT_NOT_REACHED();
12416         break;
12417     }
12418 }
12419 
12420 void SpeculativeJIT::compileCreateThis(Node* node)
12421 {
12422     // Note that there is not so much profit to speculate here. The only things we
12423     // speculate on are (1) that it&#39;s a cell, since that eliminates cell checks
12424     // later if the proto is reused, and (2) if we have a FinalObject prediction
12425     // then we speculate because we want to get recompiled if it isn&#39;t (since
12426     // otherwise we&#39;d start taking slow path a lot).
12427 
12428     SpeculateCellOperand callee(this, node-&gt;child1());
12429     GPRTemporary result(this);
12430     GPRTemporary allocator(this);
12431     GPRTemporary structure(this);
12432     GPRTemporary scratch(this);
12433 
12434     GPRReg calleeGPR = callee.gpr();
12435     GPRReg resultGPR = result.gpr();
12436     GPRReg allocatorGPR = allocator.gpr();
12437     GPRReg structureGPR = structure.gpr();
12438     GPRReg scratchGPR = scratch.gpr();
12439     // Rare data is only used to access the allocator &amp; structure
12440     // We can avoid using an additional GPR this way
12441     GPRReg rareDataGPR = structureGPR;
12442     GPRReg inlineCapacityGPR = rareDataGPR;
12443 
12444     MacroAssembler::JumpList slowPath;
12445 
12446     slowPath.append(m_jit.branchIfNotFunction(calleeGPR));
12447     m_jit.loadPtr(JITCompiler::Address(calleeGPR, JSFunction::offsetOfRareData()), rareDataGPR);
12448     slowPath.append(m_jit.branchTestPtr(MacroAssembler::Zero, rareDataGPR));
12449     m_jit.loadPtr(JITCompiler::Address(rareDataGPR, FunctionRareData::offsetOfObjectAllocationProfile() + ObjectAllocationProfile::offsetOfAllocator()), allocatorGPR);
12450     m_jit.loadPtr(JITCompiler::Address(rareDataGPR, FunctionRareData::offsetOfObjectAllocationProfile() + ObjectAllocationProfile::offsetOfStructure()), structureGPR);
12451 
12452     auto butterfly = TrustedImmPtr(nullptr);
12453     emitAllocateJSObject(resultGPR, JITAllocator::variable(), allocatorGPR, structureGPR, butterfly, scratchGPR, slowPath);
12454 
12455     m_jit.loadPtr(JITCompiler::Address(calleeGPR, JSFunction::offsetOfRareData()), rareDataGPR);
12456     m_jit.load32(JITCompiler::Address(rareDataGPR, FunctionRareData::offsetOfObjectAllocationProfile() + ObjectAllocationProfile::offsetOfInlineCapacity()), inlineCapacityGPR);
12457     m_jit.emitInitializeInlineStorage(resultGPR, inlineCapacityGPR);
12458     m_jit.mutatorFence(*m_jit.vm());
12459 
12460     addSlowPathGenerator(slowPathCall(slowPath, this, operationCreateThis, resultGPR, calleeGPR, node-&gt;inlineCapacity()));
12461 
12462     cellResult(resultGPR, node);
12463 }
12464 
12465 void SpeculativeJIT::compileNewObject(Node* node)
12466 {
12467     GPRTemporary result(this);
12468     GPRTemporary allocator(this);
12469     GPRTemporary scratch(this);
12470 
12471     GPRReg resultGPR = result.gpr();
12472     GPRReg allocatorGPR = allocator.gpr();
12473     GPRReg scratchGPR = scratch.gpr();
12474 
12475     MacroAssembler::JumpList slowPath;
12476 
12477     RegisteredStructure structure = node-&gt;structure();
12478     size_t allocationSize = JSFinalObject::allocationSize(structure-&gt;inlineCapacity());
12479     Allocator allocatorValue = allocatorForNonVirtualConcurrently&lt;JSFinalObject&gt;(*m_jit.vm(), allocationSize, AllocatorForMode::AllocatorIfExists);
12480     if (!allocatorValue)
12481         slowPath.append(m_jit.jump());
12482     else {
12483         auto butterfly = TrustedImmPtr(nullptr);
12484         emitAllocateJSObject(resultGPR, JITAllocator::constant(allocatorValue), allocatorGPR, TrustedImmPtr(structure), butterfly, scratchGPR, slowPath);
12485         m_jit.emitInitializeInlineStorage(resultGPR, structure-&gt;inlineCapacity());
12486         m_jit.mutatorFence(*m_jit.vm());
12487     }
12488 
12489     addSlowPathGenerator(slowPathCall(slowPath, this, operationNewObject, resultGPR, structure));
12490 
12491     cellResult(resultGPR, node);
12492 }
12493 
12494 void SpeculativeJIT::compileToPrimitive(Node* node)
12495 {
12496     DFG_ASSERT(m_jit.graph(), node, node-&gt;child1().useKind() == UntypedUse, node-&gt;child1().useKind());
12497     JSValueOperand argument(this, node-&gt;child1());
12498     JSValueRegsTemporary result(this, Reuse, argument);
12499 
12500     JSValueRegs argumentRegs = argument.jsValueRegs();
12501     JSValueRegs resultRegs = result.regs();
12502 
12503     argument.use();
12504 
12505     MacroAssembler::Jump alreadyPrimitive = m_jit.branchIfNotCell(argumentRegs);
12506     MacroAssembler::Jump notPrimitive = m_jit.branchIfObject(argumentRegs.payloadGPR());
12507 
12508     alreadyPrimitive.link(&amp;m_jit);
12509     m_jit.moveValueRegs(argumentRegs, resultRegs);
12510 
12511     addSlowPathGenerator(slowPathCall(notPrimitive, this, operationToPrimitive, resultRegs, argumentRegs));
12512 
12513     jsValueResult(resultRegs, node, DataFormatJS, UseChildrenCalledExplicitly);
12514 }
12515 
12516 void SpeculativeJIT::compileLogShadowChickenPrologue(Node* node)
12517 {
12518     flushRegisters();
12519     prepareForExternalCall();
12520     m_jit.emitStoreCodeOrigin(node-&gt;origin.semantic);
12521 
12522     GPRTemporary scratch1(this, GPRInfo::nonArgGPR0); // This must be a non-argument GPR.
12523     GPRReg scratch1Reg = scratch1.gpr();
12524     GPRTemporary scratch2(this);
12525     GPRReg scratch2Reg = scratch2.gpr();
12526     GPRTemporary shadowPacket(this);
12527     GPRReg shadowPacketReg = shadowPacket.gpr();
12528 
12529     m_jit.ensureShadowChickenPacket(*m_jit.vm(), shadowPacketReg, scratch1Reg, scratch2Reg);
12530 
12531     SpeculateCellOperand scope(this, node-&gt;child1());
12532     GPRReg scopeReg = scope.gpr();
12533 
12534     m_jit.logShadowChickenProloguePacket(shadowPacketReg, scratch1Reg, scopeReg);
12535     noResult(node);
12536 }
12537 
12538 void SpeculativeJIT::compileLogShadowChickenTail(Node* node)
12539 {
12540     flushRegisters();
12541     prepareForExternalCall();
12542     CallSiteIndex callSiteIndex = m_jit.emitStoreCodeOrigin(node-&gt;origin.semantic);
12543 
12544     GPRTemporary scratch1(this, GPRInfo::nonArgGPR0); // This must be a non-argument GPR.
12545     GPRReg scratch1Reg = scratch1.gpr();
12546     GPRTemporary scratch2(this);
12547     GPRReg scratch2Reg = scratch2.gpr();
12548     GPRTemporary shadowPacket(this);
12549     GPRReg shadowPacketReg = shadowPacket.gpr();
12550 
12551     m_jit.ensureShadowChickenPacket(*m_jit.vm(), shadowPacketReg, scratch1Reg, scratch2Reg);
12552 
12553     JSValueOperand thisValue(this, node-&gt;child1());
12554     JSValueRegs thisRegs = thisValue.jsValueRegs();
12555     SpeculateCellOperand scope(this, node-&gt;child2());
12556     GPRReg scopeReg = scope.gpr();
12557 
12558     m_jit.logShadowChickenTailPacket(shadowPacketReg, thisRegs, scopeReg, m_jit.codeBlock(), callSiteIndex);
12559     noResult(node);
12560 }
12561 
12562 void SpeculativeJIT::compileSetAdd(Node* node)
12563 {
12564     SpeculateCellOperand set(this, node-&gt;child1());
12565     JSValueOperand key(this, node-&gt;child2());
12566     SpeculateInt32Operand hash(this, node-&gt;child3());
12567 
12568     GPRReg setGPR = set.gpr();
12569     JSValueRegs keyRegs = key.jsValueRegs();
12570     GPRReg hashGPR = hash.gpr();
12571 
12572     speculateSetObject(node-&gt;child1(), setGPR);
12573 
12574     flushRegisters();
12575     GPRFlushedCallResult result(this);
12576     GPRReg resultGPR = result.gpr();
12577     callOperation(operationSetAdd, resultGPR, setGPR, keyRegs, hashGPR);
12578     m_jit.exceptionCheck();
12579     cellResult(resultGPR, node);
12580 }
12581 
12582 void SpeculativeJIT::compileMapSet(Node* node)
12583 {
12584     SpeculateCellOperand map(this, m_jit.graph().varArgChild(node, 0));
12585     JSValueOperand key(this, m_jit.graph().varArgChild(node, 1));
12586     JSValueOperand value(this, m_jit.graph().varArgChild(node, 2));
12587     SpeculateInt32Operand hash(this, m_jit.graph().varArgChild(node, 3));
12588 
12589     GPRReg mapGPR = map.gpr();
12590     JSValueRegs keyRegs = key.jsValueRegs();
12591     JSValueRegs valueRegs = value.jsValueRegs();
12592     GPRReg hashGPR = hash.gpr();
12593 
12594     speculateMapObject(m_jit.graph().varArgChild(node, 0), mapGPR);
12595 
12596     flushRegisters();
12597     GPRFlushedCallResult result(this);
12598     GPRReg resultGPR = result.gpr();
12599     callOperation(operationMapSet, resultGPR, mapGPR, keyRegs, valueRegs, hashGPR);
12600     m_jit.exceptionCheck();
12601     cellResult(resultGPR, node);
12602 }
12603 
12604 void SpeculativeJIT::compileWeakMapGet(Node* node)
12605 {
12606     GPRTemporary mask(this);
12607     GPRTemporary buffer(this);
12608     JSValueRegsTemporary result(this);
12609 
12610     GPRReg maskGPR = mask.gpr();
12611     GPRReg bufferGPR = buffer.gpr();
12612     JSValueRegs resultRegs = result.regs();
12613 
12614     GPRTemporary index;
12615     GPRReg indexGPR { InvalidGPRReg };
12616     {
12617         SpeculateInt32Operand hash(this, node-&gt;child3());
12618         GPRReg hashGPR = hash.gpr();
12619         index = GPRTemporary(this, Reuse, hash);
12620         indexGPR = index.gpr();
12621         m_jit.move(hashGPR, indexGPR);
12622     }
12623 
12624     {
12625         SpeculateCellOperand weakMap(this, node-&gt;child1());
12626         GPRReg weakMapGPR = weakMap.gpr();
12627         if (node-&gt;child1().useKind() == WeakMapObjectUse)
12628             speculateWeakMapObject(node-&gt;child1(), weakMapGPR);
12629         else
12630             speculateWeakSetObject(node-&gt;child1(), weakMapGPR);
12631 
12632         ASSERT(WeakMapImpl&lt;WeakMapBucket&lt;WeakMapBucketDataKey&gt;&gt;::offsetOfCapacity() == WeakMapImpl&lt;WeakMapBucket&lt;WeakMapBucketDataKeyValue&gt;&gt;::offsetOfCapacity());
12633         ASSERT(WeakMapImpl&lt;WeakMapBucket&lt;WeakMapBucketDataKey&gt;&gt;::offsetOfBuffer() == WeakMapImpl&lt;WeakMapBucket&lt;WeakMapBucketDataKeyValue&gt;&gt;::offsetOfBuffer());
12634         m_jit.load32(MacroAssembler::Address(weakMapGPR, WeakMapImpl&lt;WeakMapBucket&lt;WeakMapBucketDataKey&gt;&gt;::offsetOfCapacity()), maskGPR);
12635         m_jit.loadPtr(MacroAssembler::Address(weakMapGPR, WeakMapImpl&lt;WeakMapBucket&lt;WeakMapBucketDataKey&gt;&gt;::offsetOfBuffer()), bufferGPR);
12636     }
12637 
12638     SpeculateCellOperand key(this, node-&gt;child2());
12639     GPRReg keyGPR = key.gpr();
12640     speculateObject(node-&gt;child2(), keyGPR);
12641 
12642 #if USE(JSVALUE32_64)
12643     GPRReg bucketGPR = resultRegs.tagGPR();
12644 #else
12645     GPRTemporary bucket(this);
12646     GPRReg bucketGPR = bucket.gpr();
12647 #endif
12648 
12649     m_jit.sub32(TrustedImm32(1), maskGPR);
12650 
12651     MacroAssembler::Label loop = m_jit.label();
12652     m_jit.and32(maskGPR, indexGPR);
12653     if (node-&gt;child1().useKind() == WeakSetObjectUse) {
12654         static_assert(sizeof(WeakMapBucket&lt;WeakMapBucketDataKey&gt;) == sizeof(void*), &quot;&quot;);
12655         m_jit.zeroExtend32ToPtr(indexGPR, bucketGPR);
12656         m_jit.lshiftPtr(MacroAssembler::Imm32(sizeof(void*) == 4 ? 2 : 3), bucketGPR);
12657         m_jit.addPtr(bufferGPR, bucketGPR);
12658     } else {
12659         ASSERT(node-&gt;child1().useKind() == WeakMapObjectUse);
12660         static_assert(sizeof(WeakMapBucket&lt;WeakMapBucketDataKeyValue&gt;) == 16, &quot;&quot;);
12661         m_jit.zeroExtend32ToPtr(indexGPR, bucketGPR);
12662         m_jit.lshiftPtr(MacroAssembler::Imm32(4), bucketGPR);
12663         m_jit.addPtr(bufferGPR, bucketGPR);
12664     }
12665 
12666     m_jit.loadPtr(MacroAssembler::Address(bucketGPR, WeakMapBucket&lt;WeakMapBucketDataKeyValue&gt;::offsetOfKey()), resultRegs.payloadGPR());
12667 
12668     // They&#39;re definitely the same value, we found the bucket we were looking for!
12669     // The deleted key comparison is also done with this.
12670     auto found = m_jit.branchPtr(MacroAssembler::Equal, resultRegs.payloadGPR(), keyGPR);
12671 
12672     auto notPresentInTable = m_jit.branchTestPtr(MacroAssembler::Zero, resultRegs.payloadGPR());
12673 
12674     m_jit.add32(TrustedImm32(1), indexGPR);
12675     m_jit.jump().linkTo(loop, &amp;m_jit);
12676 
12677 #if USE(JSVALUE32_64)
12678     notPresentInTable.link(&amp;m_jit);
12679     m_jit.moveValue(JSValue(), resultRegs);
12680     auto notPresentInTableDone = m_jit.jump();
12681 
12682     found.link(&amp;m_jit);
12683     if (node-&gt;child1().useKind() == WeakSetObjectUse)
12684         m_jit.move(TrustedImm32(JSValue::CellTag), resultRegs.tagGPR());
12685     else
12686         m_jit.loadValue(MacroAssembler::Address(bucketGPR, WeakMapBucket&lt;WeakMapBucketDataKeyValue&gt;::offsetOfValue()), resultRegs);
12687 
12688     notPresentInTableDone.link(&amp;m_jit);
12689 #else
12690     notPresentInTable.link(&amp;m_jit);
12691     found.link(&amp;m_jit);
12692 
12693     // In 64bit environment, Empty bucket has JSEmpty value. Empty key is JSEmpty.
12694     // If empty bucket is found, we can use the same path used for the case of finding a bucket.
12695     if (node-&gt;child1().useKind() == WeakMapObjectUse)
12696         m_jit.loadValue(MacroAssembler::Address(bucketGPR, WeakMapBucket&lt;WeakMapBucketDataKeyValue&gt;::offsetOfValue()), resultRegs);
12697 #endif
12698 
12699     jsValueResult(resultRegs, node);
12700 }
12701 
12702 void SpeculativeJIT::compileWeakSetAdd(Node* node)
12703 {
12704     SpeculateCellOperand set(this, node-&gt;child1());
12705     SpeculateCellOperand key(this, node-&gt;child2());
12706     SpeculateInt32Operand hash(this, node-&gt;child3());
12707 
12708     GPRReg setGPR = set.gpr();
12709     GPRReg keyGPR = key.gpr();
12710     GPRReg hashGPR = hash.gpr();
12711 
12712     speculateWeakSetObject(node-&gt;child1(), setGPR);
12713     speculateObject(node-&gt;child2(), keyGPR);
12714 
12715     flushRegisters();
12716     callOperation(operationWeakSetAdd, setGPR, keyGPR, hashGPR);
12717     m_jit.exceptionCheck();
12718     noResult(node);
12719 }
12720 
12721 void SpeculativeJIT::compileWeakMapSet(Node* node)
12722 {
12723     SpeculateCellOperand map(this, m_jit.graph().varArgChild(node, 0));
12724     SpeculateCellOperand key(this, m_jit.graph().varArgChild(node, 1));
12725     JSValueOperand value(this, m_jit.graph().varArgChild(node, 2));
12726     SpeculateInt32Operand hash(this, m_jit.graph().varArgChild(node, 3));
12727 
12728     GPRReg mapGPR = map.gpr();
12729     GPRReg keyGPR = key.gpr();
12730     JSValueRegs valueRegs = value.jsValueRegs();
12731     GPRReg hashGPR = hash.gpr();
12732 
12733     speculateWeakMapObject(m_jit.graph().varArgChild(node, 0), mapGPR);
12734     speculateObject(m_jit.graph().varArgChild(node, 1), keyGPR);
12735 
12736     flushRegisters();
12737     callOperation(operationWeakMapSet, mapGPR, keyGPR, valueRegs, hashGPR);
12738     m_jit.exceptionCheck();
12739     noResult(node);
12740 }
12741 
12742 void SpeculativeJIT::compileGetPrototypeOf(Node* node)
12743 {
12744     switch (node-&gt;child1().useKind()) {
12745     case ArrayUse:
12746     case FunctionUse:
12747     case FinalObjectUse: {
12748         SpeculateCellOperand object(this, node-&gt;child1());
12749         GPRTemporary temp(this);
12750         GPRTemporary temp2(this);
12751 
12752         GPRReg objectGPR = object.gpr();
12753         GPRReg tempGPR = temp.gpr();
12754         GPRReg temp2GPR = temp2.gpr();
12755 
12756         switch (node-&gt;child1().useKind()) {
12757         case ArrayUse:
12758             speculateArray(node-&gt;child1(), objectGPR);
12759             break;
12760         case FunctionUse:
12761             speculateFunction(node-&gt;child1(), objectGPR);
12762             break;
12763         case FinalObjectUse:
12764             speculateFinalObject(node-&gt;child1(), objectGPR);
12765             break;
12766         default:
12767             RELEASE_ASSERT_NOT_REACHED();
12768             break;
12769         }
12770 
12771         m_jit.emitLoadStructure(*m_jit.vm(), objectGPR, tempGPR, temp2GPR);
12772 
12773         AbstractValue&amp; value = m_state.forNode(node-&gt;child1());
12774         if ((value.m_type &amp;&amp; !(value.m_type &amp; ~SpecObject)) &amp;&amp; value.m_structure.isFinite()) {
12775             bool hasPolyProto = false;
12776             bool hasMonoProto = false;
12777             value.m_structure.forEach([&amp;] (RegisteredStructure structure) {
12778                 if (structure-&gt;hasPolyProto())
12779                     hasPolyProto = true;
12780                 else
12781                     hasMonoProto = true;
12782             });
12783 
12784             if (hasMonoProto &amp;&amp; !hasPolyProto) {
12785 #if USE(JSVALUE64)
12786                 m_jit.load64(MacroAssembler::Address(tempGPR, Structure::prototypeOffset()), tempGPR);
12787                 jsValueResult(tempGPR, node);
12788 #else
12789                 m_jit.load32(MacroAssembler::Address(tempGPR, Structure::prototypeOffset() + TagOffset), temp2GPR);
12790                 m_jit.load32(MacroAssembler::Address(tempGPR, Structure::prototypeOffset() + PayloadOffset), tempGPR);
12791                 jsValueResult(temp2GPR, tempGPR, node);
12792 #endif
12793                 return;
12794             }
12795 
12796             if (hasPolyProto &amp;&amp; !hasMonoProto) {
12797 #if USE(JSVALUE64)
12798                 m_jit.load64(JITCompiler::Address(objectGPR, offsetRelativeToBase(knownPolyProtoOffset)), tempGPR);
12799                 jsValueResult(tempGPR, node);
12800 #else
12801                 m_jit.load32(JITCompiler::Address(objectGPR, offsetRelativeToBase(knownPolyProtoOffset) + TagOffset), temp2GPR);
12802                 m_jit.load32(JITCompiler::Address(objectGPR, offsetRelativeToBase(knownPolyProtoOffset) + PayloadOffset), tempGPR);
12803                 jsValueResult(temp2GPR, tempGPR, node);
12804 #endif
12805                 return;
12806             }
12807         }
12808 
12809 #if USE(JSVALUE64)
12810         m_jit.load64(MacroAssembler::Address(tempGPR, Structure::prototypeOffset()), tempGPR);
12811         auto hasMonoProto = m_jit.branchIfNotEmpty(tempGPR);
12812         m_jit.load64(JITCompiler::Address(objectGPR, offsetRelativeToBase(knownPolyProtoOffset)), tempGPR);
12813         hasMonoProto.link(&amp;m_jit);
12814         jsValueResult(tempGPR, node);
12815 #else
12816         m_jit.load32(MacroAssembler::Address(tempGPR, Structure::prototypeOffset() + TagOffset), temp2GPR);
12817         m_jit.load32(MacroAssembler::Address(tempGPR, Structure::prototypeOffset() + PayloadOffset), tempGPR);
12818         auto hasMonoProto = m_jit.branchIfNotEmpty(temp2GPR);
12819         m_jit.load32(JITCompiler::Address(objectGPR, offsetRelativeToBase(knownPolyProtoOffset) + TagOffset), temp2GPR);
12820         m_jit.load32(JITCompiler::Address(objectGPR, offsetRelativeToBase(knownPolyProtoOffset) + PayloadOffset), tempGPR);
12821         hasMonoProto.link(&amp;m_jit);
12822         jsValueResult(temp2GPR, tempGPR, node);
12823 #endif
12824         return;
12825     }
12826     case ObjectUse: {
12827         SpeculateCellOperand value(this, node-&gt;child1());
12828         JSValueRegsTemporary result(this);
12829 
12830         GPRReg valueGPR = value.gpr();
12831         JSValueRegs resultRegs = result.regs();
12832 
12833         speculateObject(node-&gt;child1(), valueGPR);
12834 
12835         flushRegisters();
12836         callOperation(operationGetPrototypeOfObject, resultRegs, valueGPR);
12837         m_jit.exceptionCheck();
12838         jsValueResult(resultRegs, node);
12839         return;
12840     }
12841     default: {
12842         JSValueOperand value(this, node-&gt;child1());
12843         JSValueRegsTemporary result(this);
12844 
12845         JSValueRegs valueRegs = value.jsValueRegs();
12846         JSValueRegs resultRegs = result.regs();
12847 
12848         flushRegisters();
12849         callOperation(operationGetPrototypeOf, resultRegs, valueRegs);
12850         m_jit.exceptionCheck();
12851         jsValueResult(resultRegs, node);
12852         return;
12853     }
12854     }
12855 }
12856 
12857 void SpeculativeJIT::compileIdentity(Node* node)
12858 {
12859     speculate(node, node-&gt;child1());
12860     switch (node-&gt;child1().useKind()) {
12861 #if USE(JSVALUE64)
12862     case DoubleRepAnyIntUse:
12863 #endif
12864     case DoubleRepUse:
12865     case DoubleRepRealUse: {
12866         SpeculateDoubleOperand op(this, node-&gt;child1());
12867         FPRTemporary scratch(this, op);
12868         m_jit.moveDouble(op.fpr(), scratch.fpr());
12869         doubleResult(scratch.fpr(), node);
12870         break;
12871     }
12872 #if USE(JSVALUE64)
12873     case Int52RepUse: {
12874         SpeculateInt52Operand op(this, node-&gt;child1());
12875         GPRTemporary result(this, Reuse, op);
12876         m_jit.move(op.gpr(), result.gpr());
12877         int52Result(result.gpr(), node);
12878         break;
12879     }
12880 #endif
12881     default: {
12882         JSValueOperand op(this, node-&gt;child1(), ManualOperandSpeculation);
12883         JSValueRegsTemporary result(this, Reuse, op);
12884         JSValueRegs opRegs = op.jsValueRegs();
12885         JSValueRegs resultRegs = result.regs();
12886         m_jit.moveValueRegs(opRegs, resultRegs);
12887         jsValueResult(resultRegs, node);
12888         break;
12889     }
12890     }
12891 }
12892 
12893 void SpeculativeJIT::compileMiscStrictEq(Node* node)
12894 {
12895     JSValueOperand op1(this, node-&gt;child1(), ManualOperandSpeculation);
12896     JSValueOperand op2(this, node-&gt;child2(), ManualOperandSpeculation);
12897     GPRTemporary result(this);
12898 
12899     if (node-&gt;child1().useKind() == MiscUse)
12900         speculateMisc(node-&gt;child1(), op1.jsValueRegs());
12901     if (node-&gt;child2().useKind() == MiscUse)
12902         speculateMisc(node-&gt;child2(), op2.jsValueRegs());
12903 
12904 #if USE(JSVALUE64)
12905     m_jit.compare64(JITCompiler::Equal, op1.gpr(), op2.gpr(), result.gpr());
12906 #else
12907     m_jit.move(TrustedImm32(0), result.gpr());
12908     JITCompiler::Jump notEqual = m_jit.branch32(JITCompiler::NotEqual, op1.tagGPR(), op2.tagGPR());
12909     m_jit.compare32(JITCompiler::Equal, op1.payloadGPR(), op2.payloadGPR(), result.gpr());
12910     notEqual.link(&amp;m_jit);
12911 #endif
12912     unblessedBooleanResult(result.gpr(), node);
12913 }
12914 
12915 void SpeculativeJIT::emitInitializeButterfly(GPRReg storageGPR, GPRReg sizeGPR, JSValueRegs emptyValueRegs, GPRReg scratchGPR)
12916 {
12917     m_jit.zeroExtend32ToPtr(sizeGPR, scratchGPR);
12918     MacroAssembler::Jump done = m_jit.branchTest32(MacroAssembler::Zero, scratchGPR);
12919     MacroAssembler::Label loop = m_jit.label();
12920     m_jit.sub32(TrustedImm32(1), scratchGPR);
12921     m_jit.storeValue(emptyValueRegs, MacroAssembler::BaseIndex(storageGPR, scratchGPR, MacroAssembler::TimesEight));
12922     m_jit.branchTest32(MacroAssembler::NonZero, scratchGPR).linkTo(loop, &amp;m_jit);
12923     done.link(&amp;m_jit);
12924 }
12925 
12926 void SpeculativeJIT::compileAllocateNewArrayWithSize(JSGlobalObject* globalObject, GPRReg resultGPR, GPRReg sizeGPR, IndexingType indexingType, bool shouldConvertLargeSizeToArrayStorage)
12927 {
12928     GPRTemporary storage(this);
12929     GPRTemporary scratch(this);
12930     GPRTemporary scratch2(this);
12931 
12932     GPRReg storageGPR = storage.gpr();
12933     GPRReg scratchGPR = scratch.gpr();
12934     GPRReg scratch2GPR = scratch2.gpr();
12935 
12936     m_jit.move(TrustedImmPtr(nullptr), storageGPR);
12937 
12938     MacroAssembler::JumpList slowCases;
12939     if (shouldConvertLargeSizeToArrayStorage)
12940         slowCases.append(m_jit.branch32(MacroAssembler::AboveOrEqual, sizeGPR, TrustedImm32(MIN_ARRAY_STORAGE_CONSTRUCTION_LENGTH)));
12941 #if !ASSERT_DISABLED
12942     else {
12943         MacroAssembler::Jump lengthIsWithinLimits;
12944         lengthIsWithinLimits = m_jit.branch32(MacroAssembler::Below, sizeGPR, TrustedImm32(MIN_ARRAY_STORAGE_CONSTRUCTION_LENGTH));
12945         m_jit.abortWithReason(UncheckedOverflow);
12946         lengthIsWithinLimits.link(&amp;m_jit);
12947     }
12948 #endif
12949 
12950     // We can use resultGPR as a scratch right now.
12951     emitAllocateButterfly(storageGPR, sizeGPR, scratchGPR, scratch2GPR, resultGPR, slowCases);
12952 
12953 #if USE(JSVALUE64)
12954     JSValueRegs emptyValueRegs(scratchGPR);
12955     if (hasDouble(indexingType))
12956         m_jit.move(TrustedImm64(bitwise_cast&lt;int64_t&gt;(PNaN)), emptyValueRegs.gpr());
12957     else
12958         m_jit.move(TrustedImm64(JSValue::encode(JSValue())), emptyValueRegs.gpr());
12959 #else
12960     JSValueRegs emptyValueRegs(scratchGPR, scratch2GPR);
12961     if (hasDouble(indexingType))
12962         m_jit.moveValue(JSValue(JSValue::EncodeAsDouble, PNaN), emptyValueRegs);
12963     else
12964         m_jit.moveValue(JSValue(), emptyValueRegs);
12965 #endif
12966     emitInitializeButterfly(storageGPR, sizeGPR, emptyValueRegs, resultGPR);
12967 
12968     RegisteredStructure structure = m_jit.graph().registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(indexingType));
12969 
12970     emitAllocateJSObject&lt;JSArray&gt;(resultGPR, TrustedImmPtr(structure), storageGPR, scratchGPR, scratch2GPR, slowCases);
12971 
12972     m_jit.mutatorFence(*m_jit.vm());
12973 
12974     addSlowPathGenerator(std::make_unique&lt;CallArrayAllocatorWithVariableSizeSlowPathGenerator&gt;(
12975         slowCases, this, operationNewArrayWithSize, resultGPR,
12976         structure,
12977         shouldConvertLargeSizeToArrayStorage ? m_jit.graph().registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithArrayStorage)) : structure,
12978         sizeGPR, storageGPR));
12979 }
12980 
12981 void SpeculativeJIT::compileHasIndexedProperty(Node* node)
12982 {
12983     SpeculateCellOperand base(this, m_graph.varArgChild(node, 0));
12984     SpeculateStrictInt32Operand index(this, m_graph.varArgChild(node, 1));
12985     GPRTemporary result(this);
12986 
12987     GPRReg baseGPR = base.gpr();
12988     GPRReg indexGPR = index.gpr();
12989     GPRReg resultGPR = result.gpr();
12990 
12991     MacroAssembler::JumpList slowCases;
12992     ArrayMode mode = node-&gt;arrayMode();
12993     switch (mode.type()) {
12994     case Array::Int32:
12995     case Array::Contiguous: {
12996         ASSERT(!!m_graph.varArgChild(node, 2));
12997         StorageOperand storage(this, m_graph.varArgChild(node, 2));
12998         GPRTemporary scratch(this);
12999 
13000         GPRReg storageGPR = storage.gpr();
13001         GPRReg scratchGPR = scratch.gpr();
13002 
13003         MacroAssembler::Jump outOfBounds = m_jit.branch32(MacroAssembler::AboveOrEqual, indexGPR, MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()));
13004         if (mode.isInBounds())
13005             speculationCheck(OutOfBounds, JSValueRegs(), nullptr, outOfBounds);
13006         else
13007             slowCases.append(outOfBounds);
13008 
13009 #if USE(JSVALUE64)
13010         m_jit.load64(MacroAssembler::BaseIndex(storageGPR, indexGPR, MacroAssembler::TimesEight), scratchGPR);
13011         slowCases.append(m_jit.branchIfEmpty(scratchGPR));
13012 #else
13013         m_jit.load32(MacroAssembler::BaseIndex(storageGPR, indexGPR, MacroAssembler::TimesEight, OBJECT_OFFSETOF(JSValue, u.asBits.tag)), scratchGPR);
13014         slowCases.append(m_jit.branchIfEmpty(scratchGPR));
13015 #endif
13016         m_jit.move(TrustedImm32(1), resultGPR);
13017         break;
13018     }
13019     case Array::Double: {
13020         ASSERT(!!m_graph.varArgChild(node, 2));
13021         StorageOperand storage(this, m_graph.varArgChild(node, 2));
13022         FPRTemporary scratch(this);
13023         FPRReg scratchFPR = scratch.fpr();
13024         GPRReg storageGPR = storage.gpr();
13025 
13026         MacroAssembler::Jump outOfBounds = m_jit.branch32(MacroAssembler::AboveOrEqual, indexGPR, MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()));
13027         if (mode.isInBounds())
13028             speculationCheck(OutOfBounds, JSValueRegs(), nullptr, outOfBounds);
13029         else
13030             slowCases.append(outOfBounds);
13031 
13032         m_jit.loadDouble(MacroAssembler::BaseIndex(storageGPR, indexGPR, MacroAssembler::TimesEight), scratchFPR);
13033         slowCases.append(m_jit.branchIfNaN(scratchFPR));
13034         m_jit.move(TrustedImm32(1), resultGPR);
13035         break;
13036     }
13037     case Array::ArrayStorage: {
13038         ASSERT(!!m_graph.varArgChild(node, 2));
13039         StorageOperand storage(this, m_graph.varArgChild(node, 2));
13040         GPRTemporary scratch(this);
13041 
13042         GPRReg storageGPR = storage.gpr();
13043         GPRReg scratchGPR = scratch.gpr();
13044 
13045         MacroAssembler::Jump outOfBounds = m_jit.branch32(MacroAssembler::AboveOrEqual, indexGPR, MacroAssembler::Address(storageGPR, ArrayStorage::vectorLengthOffset()));
13046         if (mode.isInBounds())
13047             speculationCheck(OutOfBounds, JSValueRegs(), nullptr, outOfBounds);
13048         else
13049             slowCases.append(outOfBounds);
13050 
13051 #if USE(JSVALUE64)
13052         m_jit.load64(MacroAssembler::BaseIndex(storageGPR, indexGPR, MacroAssembler::TimesEight, ArrayStorage::vectorOffset()), scratchGPR);
13053         slowCases.append(m_jit.branchIfEmpty(scratchGPR));
13054 #else
13055         m_jit.load32(MacroAssembler::BaseIndex(storageGPR, indexGPR, MacroAssembler::TimesEight, ArrayStorage::vectorOffset() + OBJECT_OFFSETOF(JSValue, u.asBits.tag)), scratchGPR);
13056         slowCases.append(m_jit.branchIfEmpty(scratchGPR));
13057 #endif
13058         m_jit.move(TrustedImm32(1), resultGPR);
13059         break;
13060     }
13061     default: {
13062         slowCases.append(m_jit.jump());
13063         break;
13064     }
13065     }
13066 
13067     addSlowPathGenerator(slowPathCall(slowCases, this, operationHasIndexedPropertyByInt, resultGPR, baseGPR, indexGPR, static_cast&lt;int32_t&gt;(node-&gt;internalMethodType())));
13068 
13069     unblessedBooleanResult(resultGPR, node);
13070 }
13071 
13072 void SpeculativeJIT::compileGetDirectPname(Node* node)
13073 {
13074     Edge&amp; baseEdge = m_jit.graph().varArgChild(node, 0);
13075     Edge&amp; propertyEdge = m_jit.graph().varArgChild(node, 1);
13076 
13077     SpeculateCellOperand base(this, baseEdge);
13078     SpeculateCellOperand property(this, propertyEdge);
13079     GPRReg baseGPR = base.gpr();
13080     GPRReg propertyGPR = property.gpr();
13081 
13082 #if CPU(X86)
13083     // Not enough registers on X86 for this code, so always use the slow path.
13084     flushRegisters();
13085     JSValueRegsFlushedCallResult result(this);
13086     JSValueRegs resultRegs = result.regs();
13087     callOperation(operationGetByValCell, resultRegs, baseGPR, CCallHelpers::CellValue(propertyGPR));
13088     m_jit.exceptionCheck();
13089     jsValueResult(resultRegs, node);
13090 #else
13091     Edge&amp; indexEdge = m_jit.graph().varArgChild(node, 2);
13092     Edge&amp; enumeratorEdge = m_jit.graph().varArgChild(node, 3);
13093     SpeculateStrictInt32Operand index(this, indexEdge);
13094     SpeculateCellOperand enumerator(this, enumeratorEdge);
13095     GPRTemporary scratch(this);
13096     JSValueRegsTemporary result(this);
13097 
13098     GPRReg indexGPR = index.gpr();
13099     GPRReg enumeratorGPR = enumerator.gpr();
13100     GPRReg scratchGPR = scratch.gpr();
13101     JSValueRegs resultRegs = result.regs();
13102 
13103     MacroAssembler::JumpList slowPath;
13104 
13105     // Check the structure
13106     m_jit.load32(MacroAssembler::Address(baseGPR, JSCell::structureIDOffset()), scratchGPR);
13107     slowPath.append(
13108         m_jit.branch32(
13109             MacroAssembler::NotEqual,
13110             scratchGPR,
13111             MacroAssembler::Address(
13112                 enumeratorGPR, JSPropertyNameEnumerator::cachedStructureIDOffset())));
13113 
13114     // Compute the offset
13115     // If index is less than the enumerator&#39;s cached inline storage, then it&#39;s an inline access
13116     MacroAssembler::Jump outOfLineAccess = m_jit.branch32(MacroAssembler::AboveOrEqual,
13117         indexGPR, MacroAssembler::Address(enumeratorGPR, JSPropertyNameEnumerator::cachedInlineCapacityOffset()));
13118 
13119     m_jit.loadValue(MacroAssembler::BaseIndex(baseGPR, indexGPR, MacroAssembler::TimesEight, JSObject::offsetOfInlineStorage()), resultRegs);
13120 
13121     MacroAssembler::Jump done = m_jit.jump();
13122 
13123     // Otherwise it&#39;s out of line
13124     outOfLineAccess.link(&amp;m_jit);
13125     m_jit.loadPtr(MacroAssembler::Address(baseGPR, JSObject::butterflyOffset()), resultRegs.payloadGPR());
13126     m_jit.move(indexGPR, scratchGPR);
13127     m_jit.sub32(MacroAssembler::Address(enumeratorGPR, JSPropertyNameEnumerator::cachedInlineCapacityOffset()), scratchGPR);
13128     m_jit.neg32(scratchGPR);
13129     m_jit.signExtend32ToPtr(scratchGPR, scratchGPR);
13130     int32_t offsetOfFirstProperty = static_cast&lt;int32_t&gt;(offsetInButterfly(firstOutOfLineOffset)) * sizeof(EncodedJSValue);
13131     m_jit.loadValue(MacroAssembler::BaseIndex(resultRegs.payloadGPR(), scratchGPR, MacroAssembler::TimesEight, offsetOfFirstProperty), resultRegs);
13132 
13133     done.link(&amp;m_jit);
13134 
13135     addSlowPathGenerator(slowPathCall(slowPath, this, operationGetByValCell, resultRegs, baseGPR, CCallHelpers::CellValue(propertyGPR)));
13136 
13137     jsValueResult(resultRegs, node);
13138 #endif
13139 }
13140 
13141 void SpeculativeJIT::compileExtractCatchLocal(Node* node)
13142 {
13143     JSValueRegsTemporary result(this);
13144     JSValueRegs resultRegs = result.regs();
13145 
13146     JSValue* ptr = &amp;reinterpret_cast&lt;JSValue*&gt;(m_jit.jitCode()-&gt;common.catchOSREntryBuffer-&gt;dataBuffer())[node-&gt;catchOSREntryIndex()];
13147     m_jit.loadValue(ptr, resultRegs);
13148     jsValueResult(resultRegs, node);
13149 }
13150 
13151 void SpeculativeJIT::compileClearCatchLocals(Node* node)
13152 {
13153     ScratchBuffer* scratchBuffer = m_jit.jitCode()-&gt;common.catchOSREntryBuffer;
13154     ASSERT(scratchBuffer);
13155     GPRTemporary scratch(this);
13156     GPRReg scratchGPR = scratch.gpr();
13157     m_jit.move(TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), scratchGPR);
13158     m_jit.storePtr(TrustedImmPtr(nullptr), scratchGPR);
13159     noResult(node);
13160 }
13161 
13162 void SpeculativeJIT::compileProfileType(Node* node)
13163 {
13164     JSValueOperand value(this, node-&gt;child1());
13165     GPRTemporary scratch1(this);
13166     GPRTemporary scratch2(this);
13167     GPRTemporary scratch3(this);
13168 
13169     JSValueRegs valueRegs = value.jsValueRegs();
13170     GPRReg scratch1GPR = scratch1.gpr();
13171     GPRReg scratch2GPR = scratch2.gpr();
13172     GPRReg scratch3GPR = scratch3.gpr();
13173 
13174     MacroAssembler::JumpList jumpToEnd;
13175 
13176     jumpToEnd.append(m_jit.branchIfEmpty(valueRegs));
13177 
13178     TypeLocation* cachedTypeLocation = node-&gt;typeLocation();
13179     // Compile in a predictive type check, if possible, to see if we can skip writing to the log.
13180     // These typechecks are inlined to match those of the 64-bit JSValue type checks.
13181     if (cachedTypeLocation-&gt;m_lastSeenType == TypeUndefined)
13182         jumpToEnd.append(m_jit.branchIfUndefined(valueRegs));
13183     else if (cachedTypeLocation-&gt;m_lastSeenType == TypeNull)
13184         jumpToEnd.append(m_jit.branchIfNull(valueRegs));
13185     else if (cachedTypeLocation-&gt;m_lastSeenType == TypeBoolean)
13186         jumpToEnd.append(m_jit.branchIfBoolean(valueRegs, scratch1GPR));
13187     else if (cachedTypeLocation-&gt;m_lastSeenType == TypeAnyInt)
13188         jumpToEnd.append(m_jit.branchIfInt32(valueRegs));
13189     else if (cachedTypeLocation-&gt;m_lastSeenType == TypeNumber)
13190         jumpToEnd.append(m_jit.branchIfNumber(valueRegs, scratch1GPR));
13191     else if (cachedTypeLocation-&gt;m_lastSeenType == TypeString) {
13192         MacroAssembler::Jump isNotCell = m_jit.branchIfNotCell(valueRegs);
13193         jumpToEnd.append(m_jit.branchIfString(valueRegs.payloadGPR()));
13194         isNotCell.link(&amp;m_jit);
13195     }
13196 
13197     // Load the TypeProfilerLog into Scratch2.
13198     TypeProfilerLog* cachedTypeProfilerLog = m_jit.vm()-&gt;typeProfilerLog();
13199     m_jit.move(TrustedImmPtr(cachedTypeProfilerLog), scratch2GPR);
13200 
13201     // Load the next LogEntry into Scratch1.
13202     m_jit.loadPtr(MacroAssembler::Address(scratch2GPR, TypeProfilerLog::currentLogEntryOffset()), scratch1GPR);
13203 
13204     // Store the JSValue onto the log entry.
13205     m_jit.storeValue(valueRegs, MacroAssembler::Address(scratch1GPR, TypeProfilerLog::LogEntry::valueOffset()));
13206 
13207     // Store the structureID of the cell if valueRegs is a cell, otherwise, store 0 on the log entry.
13208     MacroAssembler::Jump isNotCell = m_jit.branchIfNotCell(valueRegs);
13209     m_jit.load32(MacroAssembler::Address(valueRegs.payloadGPR(), JSCell::structureIDOffset()), scratch3GPR);
13210     m_jit.store32(scratch3GPR, MacroAssembler::Address(scratch1GPR, TypeProfilerLog::LogEntry::structureIDOffset()));
13211     MacroAssembler::Jump skipIsCell = m_jit.jump();
13212     isNotCell.link(&amp;m_jit);
13213     m_jit.store32(TrustedImm32(0), MacroAssembler::Address(scratch1GPR, TypeProfilerLog::LogEntry::structureIDOffset()));
13214     skipIsCell.link(&amp;m_jit);
13215 
13216     // Store the typeLocation on the log entry.
13217     m_jit.move(TrustedImmPtr(cachedTypeLocation), scratch3GPR);
13218     m_jit.storePtr(scratch3GPR, MacroAssembler::Address(scratch1GPR, TypeProfilerLog::LogEntry::locationOffset()));
13219 
13220     // Increment the current log entry.
13221     m_jit.addPtr(TrustedImm32(sizeof(TypeProfilerLog::LogEntry)), scratch1GPR);
13222     m_jit.storePtr(scratch1GPR, MacroAssembler::Address(scratch2GPR, TypeProfilerLog::currentLogEntryOffset()));
13223     MacroAssembler::Jump clearLog = m_jit.branchPtr(MacroAssembler::Equal, scratch1GPR, TrustedImmPtr(cachedTypeProfilerLog-&gt;logEndPtr()));
13224     addSlowPathGenerator(
13225         slowPathCall(clearLog, this, operationProcessTypeProfilerLogDFG, NoResult));
13226 
13227     jumpToEnd.link(&amp;m_jit);
13228 
13229     noResult(node);
13230 }
13231 
13232 void SpeculativeJIT::cachedPutById(CodeOrigin codeOrigin, GPRReg baseGPR, JSValueRegs valueRegs, GPRReg scratchGPR, unsigned identifierNumber, PutKind putKind, JITCompiler::Jump slowPathTarget, SpillRegistersMode spillMode)
13233 {
13234     RegisterSet usedRegisters = this-&gt;usedRegisters();
13235     if (spillMode == DontSpill) {
13236         // We&#39;ve already flushed registers to the stack, we don&#39;t need to spill these.
13237         usedRegisters.set(baseGPR, false);
13238         usedRegisters.set(valueRegs, false);
13239     }
13240     CallSiteIndex callSite = m_jit.recordCallSiteAndGenerateExceptionHandlingOSRExitIfNeeded(codeOrigin, m_stream-&gt;size());
13241     JITPutByIdGenerator gen(
13242         m_jit.codeBlock(), codeOrigin, callSite, usedRegisters,
13243         JSValueRegs::payloadOnly(baseGPR), valueRegs,
13244         scratchGPR, m_jit.ecmaModeFor(codeOrigin), putKind);
13245 
13246     gen.generateFastPath(m_jit);
13247 
13248     JITCompiler::JumpList slowCases;
13249     if (slowPathTarget.isSet())
13250         slowCases.append(slowPathTarget);
13251     slowCases.append(gen.slowPathJump());
13252 
13253     auto slowPath = slowPathCall(
13254         slowCases, this, gen.slowPathFunction(), NoResult, gen.stubInfo(), valueRegs,
13255         CCallHelpers::CellValue(baseGPR), identifierUID(identifierNumber));
13256 
13257     m_jit.addPutById(gen, slowPath.get());
13258     addSlowPathGenerator(WTFMove(slowPath));
13259 }
13260 
13261 void SpeculativeJIT::nonSpeculativeNonPeepholeCompare(Node* node, MacroAssembler::RelationalCondition cond, S_JITOperation_EJJ helperFunction)
13262 {
13263     ASSERT(node-&gt;isBinaryUseKind(UntypedUse));
13264     JSValueOperand arg1(this, node-&gt;child1());
13265     JSValueOperand arg2(this, node-&gt;child2());
13266 
13267     JSValueRegs arg1Regs = arg1.jsValueRegs();
13268     JSValueRegs arg2Regs = arg2.jsValueRegs();
13269 
13270     JITCompiler::JumpList slowPath;
13271 
13272     if (isKnownNotInteger(node-&gt;child1().node()) || isKnownNotInteger(node-&gt;child2().node())) {
13273         GPRFlushedCallResult result(this);
13274         GPRReg resultGPR = result.gpr();
13275 
13276         arg1.use();
13277         arg2.use();
13278 
13279         flushRegisters();
13280         callOperation(helperFunction, resultGPR, arg1Regs, arg2Regs);
13281         m_jit.exceptionCheck();
13282 
13283         unblessedBooleanResult(resultGPR, node, UseChildrenCalledExplicitly);
13284         return;
13285     }
13286 
13287     GPRTemporary result(this, Reuse, arg1, TagWord);
13288     GPRReg resultGPR = result.gpr();
13289 
13290     arg1.use();
13291     arg2.use();
13292 
13293     if (!isKnownInteger(node-&gt;child1().node()))
13294         slowPath.append(m_jit.branchIfNotInt32(arg1Regs));
13295     if (!isKnownInteger(node-&gt;child2().node()))
13296         slowPath.append(m_jit.branchIfNotInt32(arg2Regs));
13297 
13298     m_jit.compare32(cond, arg1Regs.payloadGPR(), arg2Regs.payloadGPR(), resultGPR);
13299 
13300     if (!isKnownInteger(node-&gt;child1().node()) || !isKnownInteger(node-&gt;child2().node()))
13301         addSlowPathGenerator(slowPathCall(slowPath, this, helperFunction, resultGPR, arg1Regs, arg2Regs));
13302 
13303     unblessedBooleanResult(resultGPR, node, UseChildrenCalledExplicitly);
13304 }
13305 
13306 void SpeculativeJIT::nonSpeculativePeepholeBranch(Node* node, Node* branchNode, MacroAssembler::RelationalCondition cond, S_JITOperation_EJJ helperFunction)
13307 {
13308     BasicBlock* taken = branchNode-&gt;branchData()-&gt;taken.block;
13309     BasicBlock* notTaken = branchNode-&gt;branchData()-&gt;notTaken.block;
13310 
13311     JITCompiler::ResultCondition callResultCondition = JITCompiler::NonZero;
13312 
13313     // The branch instruction will branch to the taken block.
13314     // If taken is next, switch taken with notTaken &amp; invert the branch condition so we can fall through.
13315     if (taken == nextBlock()) {
13316         cond = JITCompiler::invert(cond);
13317         callResultCondition = JITCompiler::Zero;
13318         BasicBlock* tmp = taken;
13319         taken = notTaken;
13320         notTaken = tmp;
13321     }
13322 
13323     JSValueOperand arg1(this, node-&gt;child1());
13324     JSValueOperand arg2(this, node-&gt;child2());
13325     JSValueRegs arg1Regs = arg1.jsValueRegs();
13326     JSValueRegs arg2Regs = arg2.jsValueRegs();
13327 
13328     JITCompiler::JumpList slowPath;
13329 
13330     if (isKnownNotInteger(node-&gt;child1().node()) || isKnownNotInteger(node-&gt;child2().node())) {
13331         GPRFlushedCallResult result(this);
13332         GPRReg resultGPR = result.gpr();
13333 
13334         arg1.use();
13335         arg2.use();
13336 
13337         flushRegisters();
13338         callOperation(helperFunction, resultGPR, arg1Regs, arg2Regs);
13339         m_jit.exceptionCheck();
13340 
13341         branchTest32(callResultCondition, resultGPR, taken);
13342     } else {
13343         GPRTemporary result(this, Reuse, arg2, TagWord);
13344         GPRReg resultGPR = result.gpr();
13345 
13346         arg1.use();
13347         arg2.use();
13348 
13349         if (!isKnownInteger(node-&gt;child1().node()))
13350             slowPath.append(m_jit.branchIfNotInt32(arg1Regs));
13351         if (!isKnownInteger(node-&gt;child2().node()))
13352             slowPath.append(m_jit.branchIfNotInt32(arg2Regs));
13353 
13354         branch32(cond, arg1Regs.payloadGPR(), arg2Regs.payloadGPR(), taken);
13355 
13356         if (!isKnownInteger(node-&gt;child1().node()) || !isKnownInteger(node-&gt;child2().node())) {
13357             jump(notTaken, ForceJump);
13358 
13359             slowPath.link(&amp;m_jit);
13360 
13361             silentSpillAllRegisters(resultGPR);
13362             callOperation(helperFunction, resultGPR, arg1Regs, arg2Regs);
13363             silentFillAllRegisters();
13364             m_jit.exceptionCheck();
13365 
13366             branchTest32(callResultCondition, resultGPR, taken);
13367         }
13368     }
13369 
13370     jump(notTaken);
13371 
13372     m_indexInBlock = m_block-&gt;size() - 1;
13373     m_currentNode = branchNode;
13374 }
13375 
13376 void SpeculativeJIT::compileBigIntEquality(Node* node)
13377 {
13378     // FIXME: [ESNext][BigInt] Create specialized version of strict equals for BigIntUse
13379     // https://bugs.webkit.org/show_bug.cgi?id=182895
13380     SpeculateCellOperand left(this, node-&gt;child1());
13381     SpeculateCellOperand right(this, node-&gt;child2());
13382     GPRTemporary result(this, Reuse, left);
13383     GPRReg leftGPR = left.gpr();
13384     GPRReg rightGPR = right.gpr();
13385     GPRReg resultGPR = result.gpr();
13386 
13387     left.use();
13388     right.use();
13389 
13390     speculateBigInt(node-&gt;child1(), leftGPR);
13391     speculateBigInt(node-&gt;child2(), rightGPR);
13392 
13393     JITCompiler::Jump notEqualCase = m_jit.branchPtr(JITCompiler::NotEqual, leftGPR, rightGPR);
13394 
13395     m_jit.move(JITCompiler::TrustedImm32(1), resultGPR);
13396 
13397     JITCompiler::Jump done = m_jit.jump();
13398 
13399     notEqualCase.link(&amp;m_jit);
13400 
13401     silentSpillAllRegisters(resultGPR);
13402     callOperation(operationCompareStrictEqCell, resultGPR, leftGPR, rightGPR);
13403     silentFillAllRegisters();
13404 
13405     done.link(&amp;m_jit);
13406 
13407     unblessedBooleanResult(resultGPR, node, UseChildrenCalledExplicitly);
13408 }
13409 
13410 void SpeculativeJIT::compileMakeRope(Node* node)
13411 {
13412     ASSERT(node-&gt;child1().useKind() == KnownStringUse);
13413     ASSERT(node-&gt;child2().useKind() == KnownStringUse);
13414     ASSERT(!node-&gt;child3() || node-&gt;child3().useKind() == KnownStringUse);
13415 
13416     SpeculateCellOperand op1(this, node-&gt;child1());
13417     SpeculateCellOperand op2(this, node-&gt;child2());
13418     SpeculateCellOperand op3(this, node-&gt;child3());
13419     GPRReg opGPRs[3];
13420     unsigned numOpGPRs;
13421     opGPRs[0] = op1.gpr();
13422     opGPRs[1] = op2.gpr();
13423     if (node-&gt;child3()) {
13424         opGPRs[2] = op3.gpr();
13425         numOpGPRs = 3;
13426     } else {
13427         opGPRs[2] = InvalidGPRReg;
13428         numOpGPRs = 2;
13429     }
13430 
13431 #if CPU(ADDRESS64)
13432     Edge edges[3] = {
13433         node-&gt;child1(),
13434         node-&gt;child2(),
13435         node-&gt;child3()
13436     };
13437 
13438     GPRTemporary result(this);
13439     GPRTemporary allocator(this);
13440     GPRTemporary scratch(this);
13441     GPRTemporary scratch2(this);
13442     GPRReg resultGPR = result.gpr();
13443     GPRReg allocatorGPR = allocator.gpr();
13444     GPRReg scratchGPR = scratch.gpr();
13445     GPRReg scratch2GPR = scratch2.gpr();
13446 
13447     CCallHelpers::JumpList slowPath;
13448     Allocator allocatorValue = allocatorForNonVirtualConcurrently&lt;JSRopeString&gt;(*m_jit.vm(), sizeof(JSRopeString), AllocatorForMode::AllocatorIfExists);
13449     emitAllocateJSCell(resultGPR, JITAllocator::constant(allocatorValue), allocatorGPR, TrustedImmPtr(m_jit.graph().registerStructure(m_jit.vm()-&gt;stringStructure.get())), scratchGPR, slowPath);
13450 
13451     m_jit.orPtr(TrustedImm32(JSString::isRopeInPointer), opGPRs[0], allocatorGPR);
13452     m_jit.storePtr(allocatorGPR, CCallHelpers::Address(resultGPR, JSRopeString::offsetOfFiber0()));
13453 
13454     m_jit.move(opGPRs[1], scratchGPR);
13455     m_jit.store32(scratchGPR, CCallHelpers::Address(resultGPR, JSRopeString::offsetOfFiber1Lower()));
13456     m_jit.rshiftPtr(TrustedImm32(32), scratchGPR);
13457     m_jit.store16(scratchGPR, CCallHelpers::Address(resultGPR, JSRopeString::offsetOfFiber1Upper()));
13458 
13459     if (numOpGPRs == 3) {
13460         m_jit.move(opGPRs[2], scratchGPR);
13461         m_jit.store32(scratchGPR, CCallHelpers::Address(resultGPR, JSRopeString::offsetOfFiber2Lower()));
13462         m_jit.rshiftPtr(TrustedImm32(32), scratchGPR);
13463         m_jit.store16(scratchGPR, CCallHelpers::Address(resultGPR, JSRopeString::offsetOfFiber2Upper()));
13464     } else {
13465         m_jit.storeZero32(CCallHelpers::Address(resultGPR, JSRopeString::offsetOfFiber2Lower()));
13466         m_jit.storeZero16(CCallHelpers::Address(resultGPR, JSRopeString::offsetOfFiber2Upper()));
13467     }
13468 
13469     {
13470         if (JSString* string = edges[0]-&gt;dynamicCastConstant&lt;JSString*&gt;(*m_jit.vm())) {
13471             m_jit.move(TrustedImm32(string-&gt;is8Bit() ? StringImpl::flagIs8Bit() : 0), scratchGPR);
13472             m_jit.move(TrustedImm32(string-&gt;length()), allocatorGPR);
13473         } else {
13474             bool canBeRope = !m_state.forNode(edges[0]).isType(SpecStringIdent);
13475             m_jit.loadPtr(CCallHelpers::Address(opGPRs[0], JSString::offsetOfValue()), scratch2GPR);
13476             CCallHelpers::Jump isRope;
13477             if (canBeRope)
13478                 isRope = m_jit.branchIfRopeStringImpl(scratch2GPR);
13479 
13480             m_jit.load32(CCallHelpers::Address(scratch2GPR, StringImpl::flagsOffset()), scratchGPR);
13481             m_jit.load32(CCallHelpers::Address(scratch2GPR, StringImpl::lengthMemoryOffset()), allocatorGPR);
13482 
13483             if (canBeRope) {
13484                 auto done = m_jit.jump();
13485 
13486                 isRope.link(&amp;m_jit);
13487                 m_jit.load16(CCallHelpers::Address(opGPRs[0], JSRopeString::offsetOfFlags()), scratchGPR);
13488                 m_jit.load32(CCallHelpers::Address(opGPRs[0], JSRopeString::offsetOfLength()), allocatorGPR);
13489                 done.link(&amp;m_jit);
13490             }
13491         }
13492 
13493         if (!ASSERT_DISABLED) {
13494             CCallHelpers::Jump ok = m_jit.branch32(
13495                 CCallHelpers::GreaterThanOrEqual, allocatorGPR, TrustedImm32(0));
13496             m_jit.abortWithReason(DFGNegativeStringLength);
13497             ok.link(&amp;m_jit);
13498         }
13499     }
13500 
13501     for (unsigned i = 1; i &lt; numOpGPRs; ++i) {
13502         if (JSString* string = edges[i]-&gt;dynamicCastConstant&lt;JSString*&gt;(*m_jit.vm())) {
13503             m_jit.and32(TrustedImm32(string-&gt;is8Bit() ? StringImpl::flagIs8Bit() : 0), scratchGPR);
13504             speculationCheck(
13505                 Uncountable, JSValueSource(), nullptr,
13506                 m_jit.branchAdd32(
13507                     CCallHelpers::Overflow,
13508                     TrustedImm32(string-&gt;length()), allocatorGPR));
13509         } else {
13510             bool canBeRope = !m_state.forNode(edges[i]).isType(SpecStringIdent);
13511             m_jit.loadPtr(CCallHelpers::Address(opGPRs[i], JSString::offsetOfValue()), scratch2GPR);
13512             CCallHelpers::Jump isRope;
13513             if (canBeRope)
13514                 isRope = m_jit.branchIfRopeStringImpl(scratch2GPR);
13515 
13516             m_jit.and16(CCallHelpers::Address(scratch2GPR, StringImpl::flagsOffset()), scratchGPR);
13517             speculationCheck(
13518                 Uncountable, JSValueSource(), nullptr,
13519                 m_jit.branchAdd32(
13520                     CCallHelpers::Overflow,
13521                     CCallHelpers::Address(scratch2GPR, StringImpl::lengthMemoryOffset()), allocatorGPR));
13522             if (canBeRope) {
13523                 auto done = m_jit.jump();
13524 
13525                 isRope.link(&amp;m_jit);
13526                 m_jit.and16(CCallHelpers::Address(opGPRs[i], JSRopeString::offsetOfFlags()), scratchGPR);
13527                 m_jit.load32(CCallHelpers::Address(opGPRs[i], JSRopeString::offsetOfLength()), scratch2GPR);
13528                 speculationCheck(
13529                     Uncountable, JSValueSource(), nullptr,
13530                     m_jit.branchAdd32(
13531                         CCallHelpers::Overflow, scratch2GPR, allocatorGPR));
13532                 done.link(&amp;m_jit);
13533             }
13534         }
13535     }
13536     m_jit.store16(scratchGPR, CCallHelpers::Address(resultGPR, JSRopeString::offsetOfFlags()));
13537     if (!ASSERT_DISABLED) {
13538         CCallHelpers::Jump ok = m_jit.branch32(
13539             CCallHelpers::GreaterThanOrEqual, allocatorGPR, TrustedImm32(0));
13540         m_jit.abortWithReason(DFGNegativeStringLength);
13541         ok.link(&amp;m_jit);
13542     }
13543     m_jit.store32(allocatorGPR, CCallHelpers::Address(resultGPR, JSRopeString::offsetOfLength()));
13544     auto isNonEmptyString = m_jit.branchTest32(CCallHelpers::NonZero, allocatorGPR);
13545 
13546     m_jit.move(TrustedImmPtr::weakPointer(m_jit.graph(), jsEmptyString(&amp;m_jit.graph().m_vm)), resultGPR);
13547 
13548     isNonEmptyString.link(&amp;m_jit);
13549     m_jit.mutatorFence(*m_jit.vm());
13550 
13551     switch (numOpGPRs) {
13552     case 2:
13553         addSlowPathGenerator(slowPathCall(
13554             slowPath, this, operationMakeRope2, resultGPR, opGPRs[0], opGPRs[1]));
13555         break;
13556     case 3:
13557         addSlowPathGenerator(slowPathCall(
13558             slowPath, this, operationMakeRope3, resultGPR, opGPRs[0], opGPRs[1], opGPRs[2]));
13559         break;
13560     default:
13561         RELEASE_ASSERT_NOT_REACHED();
13562         break;
13563     }
13564 
13565     cellResult(resultGPR, node);
13566 #else
13567     flushRegisters();
13568     GPRFlushedCallResult result(this);
13569     GPRReg resultGPR = result.gpr();
13570     switch (numOpGPRs) {
13571     case 2:
13572         callOperation(operationMakeRope2, resultGPR, opGPRs[0], opGPRs[1]);
13573         m_jit.exceptionCheck();
13574         break;
13575     case 3:
13576         callOperation(operationMakeRope3, resultGPR, opGPRs[0], opGPRs[1], opGPRs[2]);
13577         m_jit.exceptionCheck();
13578         break;
13579     default:
13580         RELEASE_ASSERT_NOT_REACHED();
13581         break;
13582     }
13583 
13584     cellResult(resultGPR, node);
13585 #endif
13586 }
13587 
13588 } } // namespace JSC::DFG
13589 
13590 #endif
    </pre>
  </body>
</html>