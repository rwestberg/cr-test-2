<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/loader/FrameLoader.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FrameLoadRequest.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="FrameLoader.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/loader/FrameLoader.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  28  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  29  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  30  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  31  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  32  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  33  */
  34 
  35 #include &quot;config.h&quot;
  36 #include &quot;FrameLoader.h&quot;
  37 
  38 #include &quot;AXObjectCache.h&quot;
  39 #include &quot;ApplicationCacheHost.h&quot;
  40 #include &quot;BackForwardController.h&quot;
  41 #include &quot;BeforeUnloadEvent.h&quot;
  42 #include &quot;CachedPage.h&quot;
  43 #include &quot;CachedResourceLoader.h&quot;
  44 #include &quot;Chrome.h&quot;
  45 #include &quot;ChromeClient.h&quot;
  46 #include &quot;CommonVM.h&quot;
  47 #include &quot;ContentFilter.h&quot;

  48 #include &quot;ContentSecurityPolicy.h&quot;

  49 #include &quot;DOMWindow.h&quot;
  50 #include &quot;DatabaseManager.h&quot;
  51 #include &quot;DiagnosticLoggingClient.h&quot;
  52 #include &quot;DiagnosticLoggingKeys.h&quot;
  53 #include &quot;Document.h&quot;
  54 #include &quot;DocumentLoader.h&quot;
  55 #include &quot;Editor.h&quot;
  56 #include &quot;EditorClient.h&quot;
  57 #include &quot;Element.h&quot;
  58 #include &quot;Event.h&quot;
  59 #include &quot;EventHandler.h&quot;
  60 #include &quot;EventNames.h&quot;
  61 #include &quot;FloatRect.h&quot;
  62 #include &quot;FormState.h&quot;
  63 #include &quot;FormSubmission.h&quot;
  64 #include &quot;Frame.h&quot;
  65 #include &quot;FrameLoadRequest.h&quot;
  66 #include &quot;FrameLoaderClient.h&quot;
  67 #include &quot;FrameNetworkingContext.h&quot;
  68 #include &quot;FrameTree.h&quot;
</pre>
<hr />
<pre>
  99 #include &quot;PolicyChecker.h&quot;
 100 #include &quot;ProgressTracker.h&quot;
 101 #include &quot;ResourceHandle.h&quot;
 102 #include &quot;ResourceLoadInfo.h&quot;
 103 #include &quot;ResourceLoadObserver.h&quot;
 104 #include &quot;ResourceRequest.h&quot;
 105 #include &quot;SVGDocument.h&quot;
 106 #include &quot;SVGLocatable.h&quot;
 107 #include &quot;SVGNames.h&quot;
 108 #include &quot;SVGViewElement.h&quot;
 109 #include &quot;SVGViewSpec.h&quot;
 110 #include &quot;ScriptController.h&quot;
 111 #include &quot;ScriptSourceCode.h&quot;
 112 #include &quot;ScrollAnimator.h&quot;
 113 #include &quot;SecurityOrigin.h&quot;
 114 #include &quot;SecurityPolicy.h&quot;
 115 #include &quot;SegmentedString.h&quot;
 116 #include &quot;SerializedScriptValue.h&quot;
 117 #include &quot;Settings.h&quot;
 118 #include &quot;ShouldTreatAsContinuingLoad.h&quot;

 119 #include &quot;SubframeLoader.h&quot;
 120 #include &quot;SubresourceLoader.h&quot;
 121 #include &quot;TextResourceDecoder.h&quot;
 122 #include &quot;UserContentController.h&quot;
 123 #include &quot;UserGestureIndicator.h&quot;
 124 #include &quot;WindowFeatures.h&quot;
 125 #include &quot;XMLDocumentParser.h&quot;
 126 #include &lt;dom/ScriptDisallowedScope.h&gt;
 127 #include &lt;wtf/CompletionHandler.h&gt;
 128 #include &lt;wtf/URL.h&gt;
 129 #include &lt;wtf/Ref.h&gt;
 130 #include &lt;wtf/SetForScope.h&gt;
 131 #include &lt;wtf/StdLibExtras.h&gt;
 132 #include &lt;wtf/SystemTracing.h&gt;
 133 #include &lt;wtf/text/CString.h&gt;
 134 #include &lt;wtf/text/WTFString.h&gt;
 135 
 136 #if ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)
 137 #include &quot;Archive.h&quot;
 138 #endif
 139 
 140 #if ENABLE(DATA_DETECTION)
 141 #include &quot;DataDetection.h&quot;
 142 #endif
 143 
 144 #if PLATFORM(IOS_FAMILY)
 145 #include &quot;DocumentType.h&quot;
 146 #include &quot;ResourceLoader.h&quot;
 147 #include &quot;RuntimeApplicationChecks.h&quot;
<span class="line-removed"> 148 #include &quot;WKContentObservation.h&quot;</span>
 149 #endif
 150 
 151 #define RELEASE_LOG_IF_ALLOWED(fmt, ...) RELEASE_LOG_IF(isAlwaysOnLoggingAllowed(), Network, &quot;%p - FrameLoader::&quot; fmt, this, ##__VA_ARGS__)
 152 
 153 namespace WebCore {
 154 
 155 using namespace HTMLNames;
 156 using namespace SVGNames;
 157 
 158 static const char defaultAcceptHeader[] = &quot;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&quot;;
 159 
 160 bool isBackForwardLoadType(FrameLoadType type)
 161 {
 162     switch (type) {
 163     case FrameLoadType::Standard:
 164     case FrameLoadType::Reload:
 165     case FrameLoadType::ReloadFromOrigin:
 166     case FrameLoadType::ReloadExpiredOnly:
 167     case FrameLoadType::Same:
 168     case FrameLoadType::RedirectWithLockedBackForwardList:
</pre>
<hr />
<pre>
 251 
 252     void progressCompleted()
 253     {
 254         ASSERT(m_inProgress);
 255         ASSERT(m_frame.page());
 256         m_inProgress = false;
 257         m_frame.page()-&gt;progress().progressCompleted(m_frame);
 258 
 259         if (auto pageID = m_frame.loader().client().pageID())
 260             platformStrategies()-&gt;loaderStrategy()-&gt;pageLoadCompleted(pageID.value());
 261     }
 262 
 263 private:
 264     Frame&amp; m_frame;
 265     bool m_inProgress;
 266 };
 267 
 268 FrameLoader::FrameLoader(Frame&amp; frame, FrameLoaderClient&amp; client)
 269     : m_frame(frame)
 270     , m_client(client)
<span class="line-modified"> 271     , m_policyChecker(std::make_unique&lt;PolicyChecker&gt;(frame))</span>
<span class="line-modified"> 272     , m_history(std::make_unique&lt;HistoryController&gt;(frame))</span>
 273     , m_notifier(frame)
<span class="line-modified"> 274     , m_subframeLoader(std::make_unique&lt;SubframeLoader&gt;(frame))</span>
 275     , m_mixedContentChecker(frame)
 276     , m_state(FrameStateProvisional)
 277     , m_loadType(FrameLoadType::Standard)
 278     , m_quickRedirectComing(false)
 279     , m_sentRedirectNotification(false)
 280     , m_inStopAllLoaders(false)
 281     , m_isExecutingJavaScriptFormAction(false)
 282     , m_didCallImplicitClose(true)
 283     , m_wasUnloadEventEmitted(false)
 284     , m_isComplete(false)
 285     , m_needsClear(false)
 286     , m_checkTimer(*this, &amp;FrameLoader::checkTimerFired)
 287     , m_shouldCallCheckCompleted(false)
 288     , m_shouldCallCheckLoadComplete(false)
 289     , m_opener(nullptr)
 290     , m_loadingFromCachedPage(false)
 291     , m_currentNavigationHasShownBeforeUnloadConfirmPanel(false)
 292     , m_loadsSynchronously(false)
 293     , m_forcedSandboxFlags(SandboxNone)
 294 {
</pre>
<hr />
<pre>
 302         frame-&gt;loader().m_opener = nullptr;
 303 
 304     m_client.frameLoaderDestroyed();
 305 
 306     if (m_networkingContext)
 307         m_networkingContext-&gt;invalidate();
 308 }
 309 
 310 void FrameLoader::init()
 311 {
 312     // This somewhat odd set of steps gives the frame an initial empty document.
 313     setPolicyDocumentLoader(m_client.createDocumentLoader(ResourceRequest(URL({ }, emptyString())), SubstituteData()).ptr());
 314     setProvisionalDocumentLoader(m_policyDocumentLoader.get());
 315     m_provisionalDocumentLoader-&gt;startLoadingMainResource();
 316 
 317     Ref&lt;Frame&gt; protect(m_frame);
 318     m_frame.document()-&gt;cancelParsing();
 319     m_stateMachine.advanceTo(FrameLoaderStateMachine::DisplayingInitialEmptyDocument);
 320 
 321     m_networkingContext = m_client.createNetworkingContext();
<span class="line-modified"> 322     m_progressTracker = std::make_unique&lt;FrameProgressTracker&gt;(m_frame);</span>
 323 }
 324 
 325 void FrameLoader::initForSynthesizedDocument(const URL&amp;)
 326 {
 327     // FIXME: We need to initialize the document URL to the specified URL. Currently the URL is empty and hence
 328     // FrameLoader::checkCompleted() will overwrite the URL of the document to be activeDocumentLoader()-&gt;documentURL().
 329 
 330     auto loader = m_client.createDocumentLoader(ResourceRequest(URL({ }, emptyString())), SubstituteData());
 331     loader-&gt;attachToFrame(m_frame);
 332     loader-&gt;setResponse(ResourceResponse(URL(), &quot;text/html&quot;_s, 0, String()));
 333     loader-&gt;setCommitted(true);
 334     setDocumentLoader(loader.ptr());
 335 
 336     m_stateMachine.advanceTo(FrameLoaderStateMachine::DisplayingInitialEmptyDocument);
 337     m_stateMachine.advanceTo(FrameLoaderStateMachine::DisplayingInitialEmptyDocumentPostCommit);
 338     m_stateMachine.advanceTo(FrameLoaderStateMachine::CommittedFirstRealLoad);
 339     m_client.transitionToCommittedForNewPage();
 340 
 341     m_didCallImplicitClose = true;
 342     m_isComplete = true;
 343     m_state = FrameStateComplete;
 344     m_needsClear = true;
 345 
 346     m_networkingContext = m_client.createNetworkingContext();
<span class="line-modified"> 347     m_progressTracker = std::make_unique&lt;FrameProgressTracker&gt;(m_frame);</span>
 348 }
 349 
 350 void FrameLoader::setDefersLoading(bool defers)
 351 {
 352     if (m_documentLoader)
 353         m_documentLoader-&gt;setDefersLoading(defers);
 354     if (m_provisionalDocumentLoader)
 355         m_provisionalDocumentLoader-&gt;setDefersLoading(defers);
 356     if (m_policyDocumentLoader)
 357         m_policyDocumentLoader-&gt;setDefersLoading(defers);
 358     history().setDefersLoading(defers);
 359 
 360     if (!defers) {
 361         m_frame.navigationScheduler().startTimer();
 362         startCheckCompleteTimer();
 363     }
 364 }
 365 
 366 void FrameLoader::checkContentPolicy(const ResourceResponse&amp; response, PolicyCheckIdentifier identifier, ContentPolicyDecisionFunction&amp;&amp; function)
 367 {
 368     if (!activeDocumentLoader()) {
 369         // Load was cancelled
 370         function(PolicyAction::Ignore, identifier);
 371         return;
 372     }
 373 
 374     // FIXME: Validate the policy check identifier.
<span class="line-modified"> 375     client().dispatchDecidePolicyForResponse(response, activeDocumentLoader()-&gt;request(), identifier, WTFMove(function));</span>
 376 }
 377 
 378 void FrameLoader::changeLocation(FrameLoadRequest&amp;&amp; request)
 379 {
 380     urlSelected(WTFMove(request), nullptr);
 381 }
 382 
<span class="line-modified"> 383 void FrameLoader::urlSelected(const URL&amp; url, const String&amp; passedTarget, Event* triggeringEvent, LockHistory lockHistory, LockBackForwardList lockBackForwardList, ShouldSendReferrer shouldSendReferrer, ShouldOpenExternalURLsPolicy shouldOpenExternalURLsPolicy, Optional&lt;NewFrameOpenerPolicy&gt; openerPolicy, const AtomicString&amp; downloadAttribute, const SystemPreviewInfo&amp; systemPreviewInfo, Optional&lt;AdClickAttribution&gt;&amp;&amp; adClickAttribution)</span>
 384 {
 385     auto* frame = lexicalFrameFromCommonVM();
 386     auto initiatedByMainFrame = frame &amp;&amp; frame-&gt;isMainFrame() ? InitiatedByMainFrame::Yes : InitiatedByMainFrame::Unknown;
 387 
 388     NewFrameOpenerPolicy newFrameOpenerPolicy = openerPolicy.valueOr(shouldSendReferrer == NeverSendReferrer ? NewFrameOpenerPolicy::Suppress : NewFrameOpenerPolicy::Allow);
 389     urlSelected(FrameLoadRequest(*m_frame.document(), m_frame.document()-&gt;securityOrigin(), { url }, passedTarget, lockHistory, lockBackForwardList, shouldSendReferrer, AllowNavigationToInvalidURL::Yes, newFrameOpenerPolicy, shouldOpenExternalURLsPolicy, initiatedByMainFrame, DoNotReplaceDocumentIfJavaScriptURL, downloadAttribute, systemPreviewInfo), triggeringEvent, WTFMove(adClickAttribution));
 390 }
 391 
 392 void FrameLoader::urlSelected(FrameLoadRequest&amp;&amp; frameRequest, Event* triggeringEvent, Optional&lt;AdClickAttribution&gt;&amp;&amp; adClickAttribution)
 393 {
 394     RELEASE_LOG_IF_ALLOWED(&quot;urlSelected: frame load started (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());
 395 
 396     Ref&lt;Frame&gt; protect(m_frame);
 397 
 398     if (m_frame.script().executeIfJavaScriptURL(frameRequest.resourceRequest().url(), frameRequest.shouldReplaceDocumentIfJavaScriptURL()))
 399         return;
 400 
 401     if (frameRequest.frameName().isEmpty())
 402         frameRequest.setFrameName(m_frame.document()-&gt;baseTarget());
 403 
</pre>
<hr />
<pre>
 455         return;
 456 
 457     // FIXME: We&#39;d like to remove this altogether and fix the multiple form submission issue another way.
 458 
 459     // We do not want to submit more than one form from the same page, nor do we want to submit a single
 460     // form more than once. This flag prevents these from happening; not sure how other browsers prevent this.
 461     // The flag is reset in each time we start dispatching a new mouse or key down event, and
 462     // also in setView since this part may get reused for a page from the back/forward cache.
 463     // The form multi-submit logic here is only needed when we are submitting a form that affects this frame.
 464 
 465     // FIXME: Frame targeting is only one of the ways the submission could end up doing something other
 466     // than replacing this frame&#39;s content, so this check is flawed. On the other hand, the check is hardly
 467     // needed any more now that we reset m_submittedFormURL on each mouse or key down event.
 468 
 469     if (m_frame.tree().isDescendantOf(targetFrame)) {
 470         if (m_submittedFormURL == submission-&gt;requestURL())
 471             return;
 472         m_submittedFormURL = submission-&gt;requestURL();
 473     }
 474 
<span class="line-removed"> 475     submission-&gt;data().generateFiles(m_frame.document());</span>
 476     submission-&gt;setReferrer(outgoingReferrer());
 477     submission-&gt;setOrigin(outgoingOrigin());
 478 
 479     targetFrame-&gt;navigationScheduler().scheduleFormSubmission(WTFMove(submission));
 480 }
 481 
 482 void FrameLoader::stopLoading(UnloadEventPolicy unloadEventPolicy)
 483 {
 484     if (m_frame.document() &amp;&amp; m_frame.document()-&gt;parser())
 485         m_frame.document()-&gt;parser()-&gt;stopParsing();
 486 
 487     if (unloadEventPolicy != UnloadEventPolicyNone)
 488         dispatchUnloadEvents(unloadEventPolicy);
 489 
 490     m_isComplete = true; // to avoid calling completed() in finishedParsing()
 491     m_didCallImplicitClose = true; // don&#39;t want that one either
 492 
 493     if (m_frame.document() &amp;&amp; m_frame.document()-&gt;parsing()) {
 494         finishedParsing();
 495         m_frame.document()-&gt;setParsing(false);
 496     }
 497 
 498     if (auto* document = m_frame.document()) {
<span class="line-removed"> 499         // FIXME: HTML5 doesn&#39;t tell us to set the state to complete when aborting, but we do anyway to match legacy behavior.</span>
<span class="line-removed"> 500         // http://www.w3.org/Bugs/Public/show_bug.cgi?id=10537</span>
<span class="line-removed"> 501         document-&gt;setReadyState(Document::Complete);</span>
<span class="line-removed"> 502 </span>
 503         // FIXME: Should the DatabaseManager watch for something like ActiveDOMObject::stop() rather than being special-cased here?
 504         DatabaseManager::singleton().stopDatabases(*document, nullptr);
 505     }
 506 
 507     policyChecker().stopCheck();
 508 
 509     // FIXME: This will cancel redirection timer, which really needs to be restarted when restoring the frame from b/f cache.
 510     m_frame.navigationScheduler().cancel();
 511 }
 512 
 513 void FrameLoader::stop()
 514 {
 515     // http://bugs.webkit.org/show_bug.cgi?id=10854
 516     // The frame&#39;s last ref may be removed and it will be deleted by checkCompleted().
 517     Ref&lt;Frame&gt; protect(m_frame);
 518 
 519     if (DocumentParser* parser = m_frame.document()-&gt;parser()) {
 520         parser-&gt;stopParsing();
 521         parser-&gt;finish();
 522     }
</pre>
<hr />
<pre>
 576     if (!m_stateMachine.creatingInitialEmptyDocument()) {
 577         DOMWindow* window = m_frame.document()-&gt;domWindow();
 578         window-&gt;setStatus(String());
 579         window-&gt;setDefaultStatus(String());
 580     }
 581 
 582     started();
 583 
 584     return true;
 585 }
 586 
 587 void FrameLoader::didExplicitOpen()
 588 {
 589     m_isComplete = false;
 590     m_didCallImplicitClose = false;
 591 
 592     // Calling document.open counts as committing the first real document load.
 593     if (!m_stateMachine.committedFirstRealDocumentLoad())
 594         m_stateMachine.advanceTo(FrameLoaderStateMachine::DisplayingInitialEmptyDocumentPostCommit);
 595 


 596     // Prevent window.open(url) -- eg window.open(&quot;about:blank&quot;) -- from blowing away results
 597     // from a subsequent window.document.open / window.document.write call.
 598     // Canceling redirection here works for all cases because document.open
 599     // implicitly precedes document.write.
 600     m_frame.navigationScheduler().cancel();
 601 }
 602 
 603 
 604 void FrameLoader::cancelAndClear()
 605 {
 606     m_frame.navigationScheduler().cancel();
 607 
 608     if (!m_isComplete)
 609         closeURL();
 610 
 611     clear(m_frame.document(), false);
 612     m_frame.script().updatePlatformScriptObjects();
 613 }
 614 
 615 static inline bool shouldClearWindowName(const Frame&amp; frame, const Document&amp; newDocument)
 616 {
 617     if (!frame.isMainFrame())
 618         return false;
 619 
 620     if (frame.loader().opener())
 621         return false;
 622 
 623     return !newDocument.securityOrigin().isSameOriginAs(frame.document()-&gt;securityOrigin());
 624 }
 625 
<span class="line-modified"> 626 void FrameLoader::clear(Document* newDocument, bool clearWindowProperties, bool clearScriptObjects, bool clearFrameView)</span>
 627 {
 628     m_frame.editor().clear();
 629 
<span class="line-modified"> 630     if (!m_needsClear)</span>
<span class="line-removed"> 631         return;</span>
 632     m_needsClear = false;
 633 
<span class="line-modified"> 634     if (m_frame.document()-&gt;pageCacheState() != Document::InPageCache) {</span>
 635         m_frame.document()-&gt;cancelParsing();
 636         m_frame.document()-&gt;stopActiveDOMObjects();
 637         bool hadLivingRenderTree = m_frame.document()-&gt;hasLivingRenderTree();
 638         m_frame.document()-&gt;prepareForDestruction();
 639         if (hadLivingRenderTree)
 640             m_frame.document()-&gt;adjustFocusedNodeOnNodeRemoval(*m_frame.document());
 641     }
 642 






 643     // Do this after detaching the document so that the unload event works.
 644     if (clearWindowProperties) {
 645         InspectorInstrumentation::frameWindowDiscarded(m_frame, m_frame.document()-&gt;domWindow());
 646         m_frame.document()-&gt;domWindow()-&gt;resetUnlessSuspendedForDocumentSuspension();
 647         m_frame.windowProxy().clearJSWindowProxiesNotMatchingDOMWindow(newDocument-&gt;domWindow(), m_frame.document()-&gt;pageCacheState() == Document::AboutToEnterPageCache);
 648 
 649         if (shouldClearWindowName(m_frame, *newDocument))
 650             m_frame.tree().setName(nullAtom());
 651     }
 652 
 653     m_frame.selection().prepareForDestruction();
 654     m_frame.eventHandler().clear();
 655 
 656     if (clearFrameView &amp;&amp; m_frame.view())
 657         m_frame.view()-&gt;clear();
 658 
 659     // Do not drop the document before the ScriptController and view are cleared
 660     // as some destructors might still try to access the document.
 661     m_frame.setDocument(nullptr);
 662 
</pre>
<hr />
<pre>
 958 {
 959     RELEASE_LOG_IF_ALLOWED(&quot;loadURLIntoChildFrame: frame load started (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());
 960 
 961     ASSERT(childFrame);
 962 
 963 #if ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)
 964     if (auto activeLoader = activeDocumentLoader()) {
 965         if (auto subframeArchive = activeLoader-&gt;popArchiveForSubframe(childFrame-&gt;tree().uniqueName(), url)) {
 966             childFrame-&gt;loader().loadArchive(RefPtr&lt;Archive&gt; { subframeArchive }.releaseNonNull());
 967             return;
 968         }
 969     }
 970 #endif
 971 
 972     // If we&#39;re moving in the back/forward list, we might want to replace the content
 973     // of this child frame with whatever was there at that point.
 974     auto* parentItem = history().currentItem();
 975     if (parentItem &amp;&amp; parentItem-&gt;children().size() &amp;&amp; isBackForwardLoadType(loadType()) &amp;&amp; !m_frame.document()-&gt;loadEventFinished()) {
 976         if (auto* childItem = parentItem-&gt;childItemWithTarget(childFrame-&gt;tree().uniqueName())) {
 977             childFrame-&gt;loader().m_requestedHistoryItem = childItem;
<span class="line-modified"> 978             childFrame-&gt;loader().loadDifferentDocumentItem(*childItem, loadType(), MayAttemptCacheOnlyLoadForFormSubmissionItem, ShouldTreatAsContinuingLoad::No);</span>
 979             return;
 980         }
 981     }
 982 
 983     auto* lexicalFrame = lexicalFrameFromCommonVM();
 984     auto initiatedByMainFrame = lexicalFrame &amp;&amp; lexicalFrame-&gt;isMainFrame() ? InitiatedByMainFrame::Yes : InitiatedByMainFrame::Unknown;
 985 
 986     FrameLoadRequest frameLoadRequest { *m_frame.document(), m_frame.document()-&gt;securityOrigin(), { url }, &quot;_self&quot;_s, LockHistory::No, LockBackForwardList::Yes, ShouldSendReferrer::MaybeSendReferrer, AllowNavigationToInvalidURL::Yes, NewFrameOpenerPolicy::Suppress, ShouldOpenExternalURLsPolicy::ShouldNotAllow, initiatedByMainFrame };
 987     childFrame-&gt;loader().loadURL(WTFMove(frameLoadRequest), referer, FrameLoadType::RedirectWithLockedBackForwardList, nullptr, { }, WTF::nullopt, [] { });
 988 }
 989 
 990 #if ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)
 991 
 992 void FrameLoader::loadArchive(Ref&lt;Archive&gt;&amp;&amp; archive)
 993 {
 994     RELEASE_LOG_IF_ALLOWED(&quot;loadArchive: frame load started (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());
 995 
 996     ArchiveResource* mainResource = archive-&gt;mainResource();
 997     ASSERT(mainResource);
 998     if (!mainResource)
</pre>
<hr />
<pre>
1091 }
1092 
1093 void FrameLoader::resetMultipleFormSubmissionProtection()
1094 {
1095     m_submittedFormURL = URL();
1096 }
1097 
1098 void FrameLoader::updateFirstPartyForCookies()
1099 {
1100     if (m_frame.tree().parent())
1101         setFirstPartyForCookies(m_frame.tree().parent()-&gt;document()-&gt;firstPartyForCookies());
1102     else
1103         setFirstPartyForCookies(m_frame.document()-&gt;url());
1104 }
1105 
1106 void FrameLoader::setFirstPartyForCookies(const URL&amp; url)
1107 {
1108     for (Frame* frame = &amp;m_frame; frame; frame = frame-&gt;tree().traverseNext(&amp;m_frame))
1109         frame-&gt;document()-&gt;setFirstPartyForCookies(url);
1110 
<span class="line-modified">1111     String registrableDomain = ResourceRequest::partitionName(url.host().toString());</span>
1112     for (Frame* frame = &amp;m_frame; frame; frame = frame-&gt;tree().traverseNext(&amp;m_frame)) {
<span class="line-modified">1113         if (SecurityPolicy::shouldInheritSecurityOriginFromOwner(frame-&gt;document()-&gt;url()) || registrableDomainsAreEqual(frame-&gt;document()-&gt;url(), registrableDomain))</span>
1114             frame-&gt;document()-&gt;setSiteForCookies(url);
1115     }
1116 }
1117 
1118 // This does the same kind of work that didOpenURL does, except it relies on the fact
1119 // that a higher level already checked that the URLs match and the scrolling is the right thing to do.
1120 void FrameLoader::loadInSameDocument(const URL&amp; url, SerializedScriptValue* stateObject, bool isNewNavigation)
1121 {
1122     RELEASE_LOG_IF_ALLOWED(&quot;loadInSameDocument: frame load started (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());
1123 
1124     // If we have a state object, we cannot also be a new navigation.
1125     ASSERT(!stateObject || (stateObject &amp;&amp; !isNewNavigation));
1126 
1127     // Update the data source&#39;s request with the new URL to fake the URL change
1128     URL oldURL = m_frame.document()-&gt;url();
1129     m_frame.document()-&gt;setURL(url);
1130     setOutgoingReferrer(url);
1131     documentLoader()-&gt;replaceRequestURLForSameDocumentNavigation(url);
1132     if (isNewNavigation &amp;&amp; !shouldTreatURLAsSameAsCurrent(url) &amp;&amp; !stateObject) {
1133         // NB: must happen after replaceRequestURLForSameDocumentNavigation(), since we add
</pre>
<hr />
<pre>
1304     return propagatedPolicy;
1305 }
1306 
1307 static ShouldOpenExternalURLsPolicy shouldOpenExternalURLsPolicyToApply(Frame&amp; currentFrame, const FrameLoadRequest&amp; frameLoadRequest)
1308 {
1309     return shouldOpenExternalURLsPolicyToApply(currentFrame, frameLoadRequest.initiatedByMainFrame(), frameLoadRequest.shouldOpenExternalURLsPolicy());
1310 }
1311 
1312 static void applyShouldOpenExternalURLsPolicyToNewDocumentLoader(Frame&amp; frame, DocumentLoader&amp; documentLoader, InitiatedByMainFrame initiatedByMainFrame, ShouldOpenExternalURLsPolicy propagatedPolicy)
1313 {
1314     documentLoader.setShouldOpenExternalURLsPolicy(shouldOpenExternalURLsPolicyToApply(frame, initiatedByMainFrame, propagatedPolicy));
1315 }
1316 
1317 static void applyShouldOpenExternalURLsPolicyToNewDocumentLoader(Frame&amp; frame, DocumentLoader&amp; documentLoader, const FrameLoadRequest&amp; frameLoadRequest)
1318 {
1319     documentLoader.setShouldOpenExternalURLsPolicy(shouldOpenExternalURLsPolicyToApply(frame, frameLoadRequest));
1320 }
1321 
1322 bool FrameLoader::isNavigationAllowed() const
1323 {
<span class="line-modified">1324     return m_pageDismissalEventBeingDispatched == PageDismissalType::None &amp;&amp; NavigationDisabler::isNavigationAllowed(m_frame);</span>
1325 }
1326 
1327 bool FrameLoader::isStopLoadingAllowed() const
1328 {
1329     return m_pageDismissalEventBeingDispatched == PageDismissalType::None;
1330 }
1331 
1332 void FrameLoader::loadURL(FrameLoadRequest&amp;&amp; frameLoadRequest, const String&amp; referrer, FrameLoadType newLoadType, Event* event, RefPtr&lt;FormState&gt;&amp;&amp; formState, Optional&lt;AdClickAttribution&gt;&amp;&amp; adClickAttribution, CompletionHandler&lt;void()&gt;&amp;&amp; completionHandler)
1333 {
1334     RELEASE_LOG_IF_ALLOWED(&quot;loadURL: frame load started (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());
1335 
1336     CompletionHandlerCallingScope completionHandlerCaller(WTFMove(completionHandler));
1337     if (m_inStopAllLoaders || m_inClearProvisionalLoadForPolicyCheck)
1338         return;
1339 
1340     Ref&lt;Frame&gt; protect(m_frame);
1341 
1342     // Anchor target is ignored when the download attribute is set since it will download the hyperlink rather than follow it.
1343     String effectiveFrameName = frameLoadRequest.downloadAttribute().isNull() ? frameLoadRequest.frameName() : String();
1344     AllowNavigationToInvalidURL allowNavigationToInvalidURL = frameLoadRequest.allowNavigationToInvalidURL();
</pre>
<hr />
<pre>
1399     if (shouldPerformFragmentNavigation(isFormSubmission, httpMethod, newLoadType, newURL)) {
1400         oldDocumentLoader-&gt;setTriggeringAction(WTFMove(action));
1401         oldDocumentLoader-&gt;setLastCheckedRequest(ResourceRequest());
1402         policyChecker().stopCheck();
1403         policyChecker().setLoadType(newLoadType);
1404         RELEASE_ASSERT(!isBackForwardLoadType(newLoadType) || history().provisionalItem());
1405         policyChecker().checkNavigationPolicy(WTFMove(request), ResourceResponse { } /* redirectResponse */, oldDocumentLoader.get(), WTFMove(formState), [this, protectedFrame = makeRef(m_frame)] (const ResourceRequest&amp; request, WeakPtr&lt;FormState&gt;&amp;&amp;, NavigationPolicyDecision navigationPolicyDecision) {
1406             continueFragmentScrollAfterNavigationPolicy(request, navigationPolicyDecision == NavigationPolicyDecision::ContinueLoad);
1407         }, PolicyDecisionMode::Synchronous);
1408         return;
1409     }
1410 
1411     // Must grab this now, since this load may stop the previous load and clear this flag.
1412     bool isRedirect = m_quickRedirectComing;
1413 #if USE(SYSTEM_PREVIEW)
1414     bool isSystemPreview = frameLoadRequest.isSystemPreview();
1415     request.setSystemPreview(isSystemPreview);
1416     if (isSystemPreview)
1417         request.setSystemPreviewRect(frameLoadRequest.systemPreviewRect());
1418 #endif
<span class="line-modified">1419     loadWithNavigationAction(request, WTFMove(action), lockHistory, newLoadType, WTFMove(formState), allowNavigationToInvalidURL, [this, isRedirect, sameURL, newLoadType, protectedFrame = makeRef(m_frame), completionHandler = completionHandlerCaller.release()] () mutable {</span>
1420         if (isRedirect) {
1421             m_quickRedirectComing = false;
1422             if (m_provisionalDocumentLoader)
1423                 m_provisionalDocumentLoader-&gt;setIsClientRedirect(true);
1424             else if (m_policyDocumentLoader)
1425                 m_policyDocumentLoader-&gt;setIsClientRedirect(true);
1426         } else if (sameURL &amp;&amp; !isReload(newLoadType)) {
1427             // Example of this case are sites that reload the same URL with a different cookie
1428             // driving the generated content, or a master frame with links that drive a target
1429             // frame, where the user has clicked on the same link repeatedly.
1430             m_loadType = FrameLoadType::Same;
1431         }
1432         completionHandler();
1433     });
1434 }
1435 
1436 SubstituteData FrameLoader::defaultSubstituteDataForURL(const URL&amp; url)
1437 {
1438     if (!shouldTreatURLAsSrcdocDocument(url))
1439         return SubstituteData();
</pre>
<hr />
<pre>
1475     if (!request.hasSubstituteData())
1476         request.setSubstituteData(defaultSubstituteDataForURL(request.resourceRequest().url()));
1477 
1478     Ref&lt;DocumentLoader&gt; loader = m_client.createDocumentLoader(request.resourceRequest(), request.substituteData());
1479     loader-&gt;setAllowsWebArchiveForMainFrame(request.isRequestFromClientOrUserInput());
1480     addSameSiteInfoToRequestIfNeeded(loader-&gt;request());
1481     applyShouldOpenExternalURLsPolicyToNewDocumentLoader(m_frame, loader, request);
1482 
1483     if (request.shouldTreatAsContinuingLoad()) {
1484         loader-&gt;setClientRedirectSourceForHistory(request.clientRedirectSourceForHistory());
1485         if (request.lockBackForwardList() == LockBackForwardList::Yes) {
1486             loader-&gt;setIsClientRedirect(true);
1487             m_loadType = FrameLoadType::RedirectWithLockedBackForwardList;
1488         }
1489     }
1490 
1491     SetForScope&lt;LoadContinuingState&gt; continuingLoadGuard(m_currentLoadContinuingState, request.shouldTreatAsContinuingLoad() ? LoadContinuingState::ContinuingWithRequest : LoadContinuingState::NotContinuing);
1492     load(loader.get());
1493 }
1494 
<span class="line-modified">1495 void FrameLoader::loadWithNavigationAction(const ResourceRequest&amp; request, NavigationAction&amp;&amp; action, LockHistory lockHistory, FrameLoadType type, RefPtr&lt;FormState&gt;&amp;&amp; formState, AllowNavigationToInvalidURL allowNavigationToInvalidURL, CompletionHandler&lt;void()&gt;&amp;&amp; completionHandler)</span>
1496 {
1497     RELEASE_LOG_IF_ALLOWED(&quot;loadWithNavigationAction: frame load started (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());
1498 
1499     Ref&lt;DocumentLoader&gt; loader = m_client.createDocumentLoader(request, defaultSubstituteDataForURL(request.url()));

1500     applyShouldOpenExternalURLsPolicyToNewDocumentLoader(m_frame, loader, action.initiatedByMainFrame(), action.shouldOpenExternalURLsPolicy());
1501 
1502     if (lockHistory == LockHistory::Yes &amp;&amp; m_documentLoader)
1503         loader-&gt;setClientRedirectSourceForHistory(m_documentLoader-&gt;didCreateGlobalHistoryEntry() ? m_documentLoader-&gt;urlForHistory().string() : m_documentLoader-&gt;clientRedirectSourceForHistory());
1504 
1505     loader-&gt;setTriggeringAction(WTFMove(action));
1506     if (m_documentLoader)
1507         loader-&gt;setOverrideEncoding(m_documentLoader-&gt;overrideEncoding());
1508 
1509     loadWithDocumentLoader(loader.ptr(), type, WTFMove(formState), allowNavigationToInvalidURL, ShouldTreatAsContinuingLoad::No, WTFMove(completionHandler));
1510 }
1511 
1512 void FrameLoader::load(DocumentLoader&amp; newDocumentLoader)
1513 {
1514     RELEASE_LOG_IF_ALLOWED(&quot;load (DocumentLoader): frame load started (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());
1515 
1516     ResourceRequest&amp; r = newDocumentLoader.request();
1517     addExtraFieldsToMainResourceRequest(r);
1518     FrameLoadType type;
1519 
</pre>
<hr />
<pre>
1786 
1787     addSameSiteInfoToRequestIfNeeded(request);
1788 
1789     // If we&#39;re about to re-post, set up action so the application can warn the user.
1790     if (request.httpMethod() == &quot;POST&quot;)
1791         loader-&gt;setTriggeringAction({ *m_frame.document(), request, InitiatedByMainFrame::Unknown, NavigationType::FormResubmitted });
1792 
1793     loader-&gt;setOverrideEncoding(m_documentLoader-&gt;overrideEncoding());
1794 
1795     auto frameLoadTypeForReloadOptions = [] (auto options) {
1796         if (options &amp; ReloadOption::FromOrigin)
1797             return FrameLoadType::ReloadFromOrigin;
1798         if (options &amp; ReloadOption::ExpiredOnly)
1799             return FrameLoadType::ReloadExpiredOnly;
1800         return FrameLoadType::Reload;
1801     };
1802 
1803     loadWithDocumentLoader(loader.ptr(), frameLoadTypeForReloadOptions(options), { }, AllowNavigationToInvalidURL::Yes, ShouldTreatAsContinuingLoad::No);
1804 }
1805 
<span class="line-modified">1806 void FrameLoader::stopAllLoaders(ClearProvisionalItemPolicy clearProvisionalItemPolicy)</span>
1807 {
1808     if (m_frame.document() &amp;&amp; m_frame.document()-&gt;pageCacheState() == Document::InPageCache)
1809         return;
1810 
<span class="line-modified">1811     if (!isStopLoadingAllowed())</span>
1812         return;
1813 
1814     // If this method is called from within this method, infinite recursion can occur (3442218). Avoid this.
1815     if (m_inStopAllLoaders)
1816         return;
1817 
1818     // This method might dispatch events.
1819     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(ScriptDisallowedScope::InMainThread::isScriptAllowed());
1820 
1821     // Calling stopLoading() on the provisional document loader can blow away
1822     // the frame from underneath.
1823     Ref&lt;Frame&gt; protect(m_frame);
1824 
1825     m_inStopAllLoaders = true;
1826 
1827     policyChecker().stopCheck();
1828 
1829     // If no new load is in progress, we should clear the provisional item from history
1830     // before we call stopLoading.
1831     if (clearProvisionalItemPolicy == ShouldClearProvisionalItem)
</pre>
<hr />
<pre>
2276         DOMWindow* window = m_frame.document()-&gt;domWindow();
2277         window-&gt;setStatus(String());
2278         window-&gt;setDefaultStatus(String());
2279     }
2280 }
2281 
2282 void FrameLoader::open(CachedFrameBase&amp; cachedFrame)
2283 {
2284     m_isComplete = false;
2285 
2286     // Don&#39;t re-emit the load event.
2287     m_didCallImplicitClose = true;
2288 
2289     URL url = cachedFrame.url();
2290 
2291     // FIXME: I suspect this block of code doesn&#39;t do anything.
2292     if (url.protocolIsInHTTPFamily() &amp;&amp; !url.host().isEmpty() &amp;&amp; url.path().isEmpty())
2293         url.setPath(&quot;/&quot;);
2294 
2295     started();
<span class="line-modified">2296     Document* document = cachedFrame.document();</span>
<span class="line-removed">2297     ASSERT(document);</span>
2298     ASSERT(document-&gt;domWindow());
2299 
<span class="line-modified">2300     clear(document, true, true, cachedFrame.isMainFrame());</span>
2301 

2302     document-&gt;setPageCacheState(Document::NotInPageCache);
2303 
2304     m_needsClear = true;
2305     m_isComplete = false;
2306     m_didCallImplicitClose = false;
<span class="line-modified">2307     m_outgoingReferrer = url.string();</span>
2308 
2309     FrameView* view = cachedFrame.view();
2310 
2311     // When navigating to a CachedFrame its FrameView should never be null.  If it is we&#39;ll crash in creative ways downstream.
2312     ASSERT(view);
2313     view-&gt;setWasScrolledByUser(false);
2314 
2315     Optional&lt;IntRect&gt; previousViewFrameRect = m_frame.view() ?  m_frame.view()-&gt;frameRect() : Optional&lt;IntRect&gt;(WTF::nullopt);
2316     m_frame.setView(view);
2317 
2318     // Use the previous ScrollView&#39;s frame rect.
2319     if (previousViewFrameRect)
2320         view-&gt;setFrameRect(previousViewFrameRect.value());
2321 
<span class="line-modified">2322     {</span>
<span class="line-modified">2323         // Setting the document builds the render tree and runs post style resolution callbacks that can do anything,</span>
<span class="line-modified">2324         // including loading a child frame before its been re-attached to the frame tree as part of this restore.</span>
<span class="line-modified">2325         // For example, the HTML object element may load its content into a frame in a post style resolution callback.</span>
<span class="line-modified">2326         NavigationDisabler disableNavigation { &amp;m_frame };</span>
<span class="line-modified">2327         m_frame.setDocument(document);</span>
<span class="line-modified">2328     }</span>


2329 
2330     document-&gt;domWindow()-&gt;resumeFromPageCache();
2331 
2332     updateFirstPartyForCookies();
2333 
2334     cachedFrame.restore();
2335 }
2336 
2337 bool FrameLoader::isHostedByObjectElement() const
2338 {
2339     HTMLFrameOwnerElement* owner = m_frame.ownerElement();
2340     return owner &amp;&amp; owner-&gt;hasTagName(objectTag);
2341 }
2342 
2343 bool FrameLoader::isReplacing() const
2344 {
2345     return m_loadType == FrameLoadType::Replace;
2346 }
2347 
2348 void FrameLoader::setReplacing()
</pre>
<hr />
<pre>
2406         return CachePolicyHistoryBuffer;
2407     case FrameLoadType::ReloadFromOrigin:
2408         ASSERT_NOT_REACHED(); // Already handled above.
2409         return CachePolicyReload;
2410     case FrameLoadType::RedirectWithLockedBackForwardList:
2411     case FrameLoadType::Replace:
2412     case FrameLoadType::Same:
2413     case FrameLoadType::Standard:
2414         return CachePolicyVerify;
2415     case FrameLoadType::ReloadExpiredOnly:
2416         // We know about expiration for HTTP and data. Do a normal reload otherwise.
2417         if (!url.protocolIsInHTTPFamily() &amp;&amp; !url.protocolIsData())
2418             return CachePolicyReload;
2419         return CachePolicyVerify;
2420     }
2421 
2422     RELEASE_ASSERT_NOT_REACHED();
2423     return CachePolicyVerify;
2424 }
2425 





























2426 void FrameLoader::checkLoadCompleteForThisFrame()
2427 {
2428     ASSERT(m_client.hasWebView());
2429 
2430     // FIXME: Should this check be done in checkLoadComplete instead of here?
2431     // FIXME: Why does this one check need to be repeated here, and not the many others from checkCompleted?
2432     if (m_frame.document()-&gt;isDelayingLoadEvent())
2433         return;
2434 
2435     switch (m_state) {
2436         case FrameStateProvisional: {
2437             // FIXME: Prohibiting any provisional load failures from being sent to clients
2438             // while handling provisional load failures is too heavy. For example, the current
2439             // load will fail to cancel another ongoing load. That might prevent clients&#39; page
2440             // load state being handled properly.
2441             if (!m_provisionalLoadErrorBeingHandledURL.isEmpty())
2442                 return;
2443 
2444             RefPtr&lt;DocumentLoader&gt; pdl = m_provisionalDocumentLoader;
2445             if (!pdl)
2446                 return;
2447 
2448             // If we&#39;ve received any errors we may be stuck in the provisional state and actually complete.
2449             const ResourceError&amp; error = pdl-&gt;mainDocumentError();
2450             if (error.isNull())
2451                 return;
2452 
2453             // Check all children first.
2454             RefPtr&lt;HistoryItem&gt; item;
2455             if (Page* page = m_frame.page())
2456                 if (isBackForwardLoadType(loadType()))
2457                     // Reset the back forward list to the last committed history item at the top level.
2458                     item = page-&gt;mainFrame().loader().history().currentItem();
2459 
2460             // Only reset if we aren&#39;t already going to a new provisional item.
2461             bool shouldReset = !history().provisionalItem();
2462             if (!pdl-&gt;isLoadingInAPISense() || pdl-&gt;isStopping()) {
2463                 RELEASE_LOG_IF_ALLOWED(&quot;checkLoadCompleteForThisFrame: Failed provisional load (frame = %p, main = %d, isTimeout = %d, isCancellation = %d, errorCode = %d)&quot;, &amp;m_frame, m_frame.isMainFrame(), error.isTimeout(), error.isCancellation(), error.errorCode());
<span class="line-removed">2464                 m_provisionalLoadErrorBeingHandledURL = m_provisionalDocumentLoader-&gt;url();</span>
<span class="line-removed">2465                 m_client.dispatchDidFailProvisionalLoad(error);</span>
<span class="line-removed">2466 #if ENABLE(CONTENT_FILTERING)</span>
<span class="line-removed">2467                 if (auto contentFilter = pdl-&gt;contentFilter())</span>
<span class="line-removed">2468                     contentFilter-&gt;handleProvisionalLoadFailure(error);</span>
<span class="line-removed">2469 #endif</span>
<span class="line-removed">2470                 m_provisionalLoadErrorBeingHandledURL = { };</span>
2471 

2472                 ASSERT(!pdl-&gt;isLoading());
2473 
2474                 // If we&#39;re in the middle of loading multipart data, we need to restore the document loader.
2475                 if (isReplacing() &amp;&amp; !m_documentLoader.get())
2476                     setDocumentLoader(m_provisionalDocumentLoader.get());
2477 
2478                 // Finish resetting the load state, but only if another load hasn&#39;t been started by the
2479                 // delegate callback.
2480                 if (pdl == m_provisionalDocumentLoader)
2481                     clearProvisionalLoad();
2482                 else if (activeDocumentLoader()) {
2483                     URL unreachableURL = activeDocumentLoader()-&gt;unreachableURL();
2484                     if (!unreachableURL.isEmpty() &amp;&amp; unreachableURL == pdl-&gt;request().url())
2485                         shouldReset = false;
2486                 }
2487             }
2488             if (shouldReset &amp;&amp; item)
2489                 if (Page* page = m_frame.page()) {
2490                     page-&gt;backForward().setCurrentItem(*item);
2491                 }
</pre>
<hr />
<pre>
2626     // Note: Can be called multiple times.
2627 
2628     m_client.frameLoadCompleted();
2629 
2630     history().updateForFrameLoadCompleted();
2631 
2632     // After a canceled provisional load, firstLayoutDone is false.
2633     // Reset it to true if we&#39;re displaying a page.
2634     if (m_documentLoader &amp;&amp; m_stateMachine.committedFirstRealDocumentLoad() &amp;&amp; !m_stateMachine.isDisplayingInitialEmptyDocument() &amp;&amp; !m_stateMachine.firstLayoutDone())
2635         m_stateMachine.advanceTo(FrameLoaderStateMachine::FirstLayoutDone);
2636 }
2637 
2638 void FrameLoader::detachChildren()
2639 {
2640     // detachChildren() will fire the unload event in each subframe and the
2641     // HTML specification states that the parent document&#39;s ignore-opens-during-unload counter while
2642     // this event is being fired in its subframes:
2643     // https://html.spec.whatwg.org/multipage/browsers.html#unload-a-document
2644     IgnoreOpensDuringUnloadCountIncrementer ignoreOpensDuringUnloadCountIncrementer(m_frame.document());
2645 







2646     // Any subframe inserted by unload event handlers executed in the loop below will not get unloaded
2647     // because we create a copy of the subframes list before looping. Therefore, it would be unsafe to
2648     // allow loading of subframes at this point.
2649     SubframeLoadingDisabler subframeLoadingDisabler(m_frame.document());
2650 
2651     Vector&lt;Ref&lt;Frame&gt;, 16&gt; childrenToDetach;
2652     childrenToDetach.reserveInitialCapacity(m_frame.tree().childCount());
2653     for (Frame* child = m_frame.tree().lastChild(); child; child = child-&gt;tree().previousSibling())
2654         childrenToDetach.uncheckedAppend(*child);
2655     for (auto&amp; child : childrenToDetach)
2656         child-&gt;loader().detachFromParent();
2657 }
2658 
2659 void FrameLoader::closeAndRemoveChild(Frame&amp; child)
2660 {
2661     child.tree().detachFromParent();
2662 
2663     child.setView(nullptr);
2664     if (child.ownerElement() &amp;&amp; child.page())
2665         child.page()-&gt;decrementSubframeCount();
</pre>
<hr />
<pre>
2768     if (m_frame.document()-&gt;pageCacheState() != Document::InPageCache) {
2769         stopAllLoadersAndCheckCompleteness();
2770         m_frame.document()-&gt;stopActiveDOMObjects();
2771     }
2772 
2773     detachFromParent();
2774 }
2775 
2776 void FrameLoader::detachFromParent()
2777 {
2778     // Calling stopAllLoaders() can cause the frame to be deallocated, including the frame loader.
2779     Ref&lt;Frame&gt; protect(m_frame);
2780 
2781     closeURL();
2782     history().saveScrollPositionAndViewStateToItem(history().currentItem());
2783     detachChildren();
2784     if (m_frame.document()-&gt;pageCacheState() != Document::InPageCache) {
2785         // stopAllLoaders() needs to be called after detachChildren() if the document is not in the page cache,
2786         // because detachedChildren() will trigger the unload event handlers of any child frames, and those event
2787         // handlers might start a new subresource load in this frame.
<span class="line-modified">2788         stopAllLoaders();</span>
2789     }
2790 
2791     InspectorInstrumentation::frameDetachedFromParent(m_frame);
2792 
2793     detachViewsAndDocumentLoader();
2794 
2795     m_progressTracker = nullptr;
2796 
2797     if (Frame* parent = m_frame.tree().parent()) {
2798         parent-&gt;loader().closeAndRemoveChild(m_frame);
2799         parent-&gt;loader().scheduleCheckCompleted();
2800         parent-&gt;loader().scheduleCheckLoadComplete();
2801     } else {
2802         m_frame.setView(nullptr);
2803         m_frame.willDetachPage();
2804         m_frame.detachFromPage();
2805     }
2806 }
2807 
2808 void FrameLoader::detachViewsAndDocumentLoader()
</pre>
<hr />
<pre>
2954     }
2955 
2956     request.setHTTPOrigin(origin);
2957 }
2958 
2959 // Implements the &quot;&#39;Same-site&#39; and &#39;cross-site&#39; Requests&quot; algorithm from &lt;https://tools.ietf.org/html/draft-ietf-httpbis-cookie-same-site-00#section-2.1&gt;.
2960 // The algorithm is ammended to treat URLs that inherit their security origin from their owner (e.g. about:blank)
2961 // as same-site. This matches the behavior of Chrome and Firefox.
2962 void FrameLoader::addSameSiteInfoToRequestIfNeeded(ResourceRequest&amp; request, const Document* initiator)
2963 {
2964     if (!request.isSameSiteUnspecified())
2965         return;
2966     if (!initiator) {
2967         request.setIsSameSite(true);
2968         return;
2969     }
2970     if (SecurityPolicy::shouldInheritSecurityOriginFromOwner(request.url())) {
2971         request.setIsSameSite(true);
2972         return;
2973     }
<span class="line-modified">2974     request.setIsSameSite(registrableDomainsAreEqual(initiator-&gt;siteForCookies(), request.url()));</span>
2975 }
2976 
2977 void FrameLoader::addHTTPUpgradeInsecureRequestsIfNeeded(ResourceRequest&amp; request)
2978 {
2979     if (request.url().protocolIs(&quot;https&quot;)) {
2980         // FIXME: Identify HSTS cases and avoid adding the header. &lt;https://bugs.webkit.org/show_bug.cgi?id=157885&gt;
2981         return;
2982     }
2983 
2984     request.setHTTPHeaderField(HTTPHeaderName::UpgradeInsecureRequests, &quot;1&quot;_s);
2985 }
2986 
2987 void FrameLoader::loadPostRequest(FrameLoadRequest&amp;&amp; request, const String&amp; referrer, FrameLoadType loadType, Event* event, RefPtr&lt;FormState&gt;&amp;&amp; formState, CompletionHandler&lt;void()&gt;&amp;&amp; completionHandler)
2988 {
2989     RELEASE_LOG_IF_ALLOWED(&quot;loadPostRequest: frame load started (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());
2990 
2991     String frameName = request.frameName();
2992     LockHistory lockHistory = request.lockHistory();
2993     AllowNavigationToInvalidURL allowNavigationToInvalidURL = request.allowNavigationToInvalidURL();
2994     NewFrameOpenerPolicy openerPolicy = request.newFrameOpenerPolicy();
</pre>
<hr />
<pre>
2999     String origin = inRequest.httpOrigin();
3000 
3001     ResourceRequest workingResourceRequest(url);
3002 
3003     if (!referrer.isEmpty())
3004         workingResourceRequest.setHTTPReferrer(referrer);
3005     workingResourceRequest.setHTTPOrigin(origin);
3006     workingResourceRequest.setHTTPMethod(&quot;POST&quot;);
3007     workingResourceRequest.setHTTPBody(inRequest.httpBody());
3008     workingResourceRequest.setHTTPContentType(contentType);
3009     addExtraFieldsToRequest(workingResourceRequest, loadType, true);
3010 
3011     if (Document* document = m_frame.document())
3012         document-&gt;contentSecurityPolicy()-&gt;upgradeInsecureRequestIfNeeded(workingResourceRequest, ContentSecurityPolicy::InsecureRequestType::Load);
3013 
3014     NavigationAction action { request.requester(), workingResourceRequest, request.initiatedByMainFrame(), loadType, true, event, request.shouldOpenExternalURLsPolicy(), request.downloadAttribute() };
3015 
3016     if (!frameName.isEmpty()) {
3017         // The search for a target frame is done earlier in the case of form submission.
3018         if (auto* targetFrame = formState ? nullptr : findFrameForNavigation(frameName)) {
<span class="line-modified">3019             targetFrame-&gt;loader().loadWithNavigationAction(workingResourceRequest, WTFMove(action), lockHistory, loadType, WTFMove(formState), allowNavigationToInvalidURL, WTFMove(completionHandler));</span>
3020             return;
3021         }
3022 
3023         policyChecker().checkNewWindowPolicy(WTFMove(action), WTFMove(workingResourceRequest), WTFMove(formState), frameName, [this, allowNavigationToInvalidURL, openerPolicy, completionHandler = WTFMove(completionHandler)] (const ResourceRequest&amp; request, WeakPtr&lt;FormState&gt;&amp;&amp; formState, const String&amp; frameName, const NavigationAction&amp; action, ShouldContinue shouldContinue) mutable {
3024             continueLoadAfterNewWindowPolicy(request, formState.get(), frameName, action, shouldContinue, allowNavigationToInvalidURL, openerPolicy);
3025             completionHandler();
3026         });
3027         return;
3028     }
3029 
3030     // must grab this now, since this load may stop the previous load and clear this flag
3031     bool isRedirect = m_quickRedirectComing;
<span class="line-modified">3032     loadWithNavigationAction(workingResourceRequest, WTFMove(action), lockHistory, loadType, WTFMove(formState), allowNavigationToInvalidURL, [this, isRedirect, protectedFrame = makeRef(m_frame), completionHandler = WTFMove(completionHandler)] () mutable {</span>
3033         if (isRedirect) {
3034             m_quickRedirectComing = false;
3035             if (m_provisionalDocumentLoader)
3036                 m_provisionalDocumentLoader-&gt;setIsClientRedirect(true);
3037             else if (m_policyDocumentLoader)
3038                 m_policyDocumentLoader-&gt;setIsClientRedirect(true);
3039         }
3040         completionHandler();
3041     });
3042 }
3043 
3044 unsigned long FrameLoader::loadResourceSynchronously(const ResourceRequest&amp; request, ClientCredentialPolicy clientCredentialPolicy, const FetchOptions&amp; options, const HTTPHeaderMap&amp; originalRequestHeaders, ResourceError&amp; error, ResourceResponse&amp; response, RefPtr&lt;SharedBuffer&gt;&amp; data)
3045 {
3046     ASSERT(m_frame.document());
3047     String referrer = SecurityPolicy::generateReferrerHeader(m_frame.document()-&gt;referrerPolicy(), request.url(), outgoingReferrer());
3048 
3049     ResourceRequest initialRequest = request;
3050     initialRequest.setTimeoutInterval(10);
3051 
3052     if (!referrer.isEmpty())
3053         initialRequest.setHTTPReferrer(referrer);
3054     addHTTPOriginIfNeeded(initialRequest, outgoingOrigin());
3055 
3056     initialRequest.setFirstPartyForCookies(m_frame.mainFrame().loader().documentLoader()-&gt;request().url());
3057 
3058     addExtraFieldsToSubresourceRequest(initialRequest);
3059 
3060     unsigned long identifier = 0;
3061     ResourceRequest newRequest(initialRequest);
3062     requestFromDelegate(newRequest, identifier, error);
3063 
3064 #if ENABLE(CONTENT_EXTENSIONS)
3065     if (error.isNull()) {
3066         if (auto* page = m_frame.page()) {
3067             if (m_documentLoader) {
<span class="line-modified">3068                 auto blockedStatus = page-&gt;userContentProvider().processContentExtensionRulesForLoad(newRequest.url(), ResourceType::Raw, *m_documentLoader);</span>
<span class="line-modified">3069                 applyBlockedStatusToRequest(blockedStatus, page, newRequest);</span>
<span class="line-modified">3070                 if (blockedStatus.blockedLoad) {</span>

3071                     newRequest = { };
3072                     error = ResourceError(errorDomainWebKitInternal, 0, initialRequest.url(), emptyString());
3073                     response = { };
3074                     data = nullptr;
3075                 }
3076             }
3077         }
3078     }
3079 #endif
3080 
3081     m_frame.document()-&gt;contentSecurityPolicy()-&gt;upgradeInsecureRequestIfNeeded(newRequest, ContentSecurityPolicy::InsecureRequestType::Load);
3082 
3083     if (error.isNull()) {
3084         ASSERT(!newRequest.isNull());
3085 
3086         if (!documentLoader()-&gt;applicationCacheHost().maybeLoadSynchronously(newRequest, error, response, data)) {
3087             Vector&lt;char&gt; buffer;
3088             platformStrategies()-&gt;loaderStrategy()-&gt;loadResourceSynchronously(*this, identifier, newRequest, clientCredentialPolicy, options, originalRequestHeaders, error, response, buffer);
3089             data = SharedBuffer::create(WTFMove(buffer));
3090             documentLoader()-&gt;applicationCacheHost().maybeLoadFallbackSynchronously(newRequest, error, response, data);
</pre>
<hr />
<pre>
3220             if (!targetFrames[i]-&gt;loader().dispatchBeforeUnloadEvent(page-&gt;chrome(), this))
3221                 break;
3222         }
3223 
3224         if (i == targetFrames.size())
3225             shouldClose = true;
3226     }
3227 
3228     if (!shouldClose)
3229         m_submittedFormURL = URL();
3230 
3231     m_currentNavigationHasShownBeforeUnloadConfirmPanel = false;
3232     return shouldClose;
3233 }
3234 
3235 void FrameLoader::dispatchUnloadEvents(UnloadEventPolicy unloadEventPolicy)
3236 {
3237     if (!m_frame.document())
3238         return;
3239 



3240     // We store the frame&#39;s page in a local variable because the frame might get detached inside dispatchEvent.
3241     ForbidPromptsScope forbidPrompts(m_frame.page());
3242     IgnoreOpensDuringUnloadCountIncrementer ignoreOpensDuringUnloadCountIncrementer(m_frame.document());
3243 
3244     if (m_didCallImplicitClose &amp;&amp; !m_wasUnloadEventEmitted) {
3245         auto* currentFocusedElement = m_frame.document()-&gt;focusedElement();
3246         if (is&lt;HTMLInputElement&gt;(currentFocusedElement))
3247             downcast&lt;HTMLInputElement&gt;(*currentFocusedElement).endEditing();
3248         if (m_pageDismissalEventBeingDispatched == PageDismissalType::None) {
3249             if (unloadEventPolicy == UnloadEventPolicyUnloadAndPageHide) {
3250                 m_pageDismissalEventBeingDispatched = PageDismissalType::PageHide;
3251                 m_frame.document()-&gt;domWindow()-&gt;dispatchEvent(PageTransitionEvent::create(eventNames().pagehideEvent, m_frame.document()-&gt;pageCacheState() == Document::AboutToEnterPageCache), m_frame.document());
3252             }
3253 
3254             // FIXME: update Page Visibility state here.
3255             // https://bugs.webkit.org/show_bug.cgi?id=116770
3256 
3257             if (m_frame.document()-&gt;pageCacheState() == Document::NotInPageCache) {
3258                 Ref&lt;Event&gt; unloadEvent(Event::create(eventNames().unloadEvent, Event::CanBubble::No, Event::IsCancelable::No));
3259                 // The DocumentLoader (and thus its LoadTiming) might get destroyed
</pre>
<hr />
<pre>
3298     bool userDidInteractWithPage = document.topDocument().userDidInteractWithPage();
3299     // Web pages can request we ask for confirmation before navigating by:
3300     // - Cancelling the BeforeUnloadEvent (modern way)
3301     // - Setting the returnValue attribute on the BeforeUnloadEvent to a non-empty string.
3302     // - Returning a non-empty string from the event handler, which is then set as returnValue
3303     //   attribute on the BeforeUnloadEvent.
3304     return userDidInteractWithPage &amp;&amp; (event.defaultPrevented() || !event.returnValue().isEmpty());
3305 }
3306 
3307 bool FrameLoader::dispatchBeforeUnloadEvent(Chrome&amp; chrome, FrameLoader* frameLoaderBeingNavigated)
3308 {
3309     DOMWindow* domWindow = m_frame.document()-&gt;domWindow();
3310     if (!domWindow)
3311         return true;
3312 
3313     RefPtr&lt;Document&gt; document = m_frame.document();
3314     if (!document-&gt;bodyOrFrameset())
3315         return true;
3316 
3317     Ref&lt;BeforeUnloadEvent&gt; beforeUnloadEvent = BeforeUnloadEvent::create();
<span class="line-removed">3318     m_pageDismissalEventBeingDispatched = PageDismissalType::BeforeUnload;</span>
3319 
3320     {

3321         ForbidPromptsScope forbidPrompts(m_frame.page());
3322         domWindow-&gt;dispatchEvent(beforeUnloadEvent, domWindow-&gt;document());
3323     }
3324 
<span class="line-removed">3325     m_pageDismissalEventBeingDispatched = PageDismissalType::None;</span>
<span class="line-removed">3326 </span>
3327     if (!beforeUnloadEvent-&gt;defaultPrevented())
3328         document-&gt;defaultEventHandler(beforeUnloadEvent.get());
3329 
3330     if (!shouldAskForNavigationConfirmation(*document, beforeUnloadEvent))
3331         return true;
3332 
3333     // If the navigating FrameLoader has already shown a beforeunload confirmation panel for the current navigation attempt,
3334     // this frame is not allowed to cause another one to be shown.
3335     if (frameLoaderBeingNavigated-&gt;m_currentNavigationHasShownBeforeUnloadConfirmPanel) {
3336         document-&gt;addConsoleMessage(MessageSource::JS, MessageLevel::Error, &quot;Blocked attempt to show multiple beforeunload confirmation dialogs for the same navigation.&quot;_s);
3337         return true;
3338     }
3339 
3340     // We should only display the beforeunload dialog for an iframe if its SecurityOrigin matches all
3341     // ancestor frame SecurityOrigins up through the navigating FrameLoader.
3342     if (frameLoaderBeingNavigated != this) {
3343         Frame* parentFrame = m_frame.tree().parent();
3344         while (parentFrame) {
3345             Document* parentDocument = parentFrame-&gt;document();
3346             if (!parentDocument)
</pre>
<hr />
<pre>
3423 
3424     FrameLoadType type = policyChecker().loadType();
3425     // A new navigation is in progress, so don&#39;t clear the history&#39;s provisional item.
3426     stopAllLoaders(ShouldNotClearProvisionalItem);
3427 
3428     // &lt;rdar://problem/6250856&gt; - In certain circumstances on pages with multiple frames, stopAllLoaders()
3429     // might detach the current FrameLoader, in which case we should bail on this newly defunct load.
3430     if (!m_frame.page()) {
3431         RELEASE_LOG_IF_ALLOWED(&quot;continueLoadAfterNavigationPolicy: can&#39;t continue loading frame because it became defunct (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());
3432         return;
3433     }
3434 
3435     setProvisionalDocumentLoader(m_policyDocumentLoader.get());
3436     m_loadType = type;
3437     setState(FrameStateProvisional);
3438 
3439     setPolicyDocumentLoader(nullptr);
3440 
3441     if (isBackForwardLoadType(type)) {
3442         auto&amp; diagnosticLoggingClient = m_frame.page()-&gt;diagnosticLoggingClient();
<span class="line-modified">3443         if (history().provisionalItem()-&gt;isInPageCache()) {</span>
3444             diagnosticLoggingClient.logDiagnosticMessageWithResult(DiagnosticLoggingKeys::pageCacheKey(), DiagnosticLoggingKeys::retrievalKey(), DiagnosticLoggingResultPass, ShouldSample::Yes);
3445             loadProvisionalItemFromCachedPage();
3446             RELEASE_LOG_IF_ALLOWED(&quot;continueLoadAfterNavigationPolicy: can&#39;t continue loading frame because it will be loaded from cache (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());
3447             return;
3448         }
3449         diagnosticLoggingClient.logDiagnosticMessageWithResult(DiagnosticLoggingKeys::pageCacheKey(), DiagnosticLoggingKeys::retrievalKey(), DiagnosticLoggingResultFail, ShouldSample::Yes);
3450     }
3451 
3452     CompletionHandler&lt;void()&gt; completionHandler = [this, protectedFrame = makeRef(m_frame)] () mutable {
3453         if (!m_provisionalDocumentLoader) {
3454             RELEASE_LOG_IF_ALLOWED(&quot;continueLoadAfterNavigationPolicy completionHandler: Frame load canceled #1 (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());
3455             return;
3456         }
3457 
3458         prepareForLoadStart();
3459 
3460         // The load might be cancelled inside of prepareForLoadStart(), nulling out the m_provisionalDocumentLoader,
3461         // so we need to null check it again.
3462         if (!m_provisionalDocumentLoader) {
3463             RELEASE_LOG_IF_ALLOWED(&quot;prepareForLoadStart completionHandler: Frame load canceled #2 (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());
</pre>
<hr />
<pre>
3632 
3633 bool FrameLoader::shouldTreatURLAsSameAsCurrent(const URL&amp; url) const
3634 {
3635     if (!history().currentItem())
3636         return false;
3637     return url == history().currentItem()-&gt;url() || url == history().currentItem()-&gt;originalURL();
3638 }
3639 
3640 bool FrameLoader::shouldTreatURLAsSrcdocDocument(const URL&amp; url) const
3641 {
3642     if (!equalLettersIgnoringASCIICase(url.string(), &quot;about:srcdoc&quot;))
3643         return false;
3644     HTMLFrameOwnerElement* ownerElement = m_frame.ownerElement();
3645     if (!ownerElement)
3646         return false;
3647     if (!ownerElement-&gt;hasTagName(iframeTag))
3648         return false;
3649     return ownerElement-&gt;hasAttributeWithoutSynchronization(srcdocAttr);
3650 }
3651 
<span class="line-modified">3652 Frame* FrameLoader::findFrameForNavigation(const AtomicString&amp; name, Document* activeDocument)</span>
3653 {
3654     // FIXME: Eventually all callers should supply the actual activeDocument so we can call canNavigate with the right document.
3655     if (!activeDocument)
3656         activeDocument = m_frame.document();
3657 
3658     auto* frame = m_frame.tree().find(name, activeDocument-&gt;frame() ? *activeDocument-&gt;frame() : m_frame);
3659 
3660     if (!activeDocument-&gt;canNavigate(frame))
3661         return nullptr;
3662 
3663     return frame;
3664 }
3665 
3666 void FrameLoader::loadSameDocumentItem(HistoryItem&amp; item)
3667 {
3668     ASSERT(item.documentSequenceNumber() == history().currentItem()-&gt;documentSequenceNumber());
3669 
3670     Ref&lt;Frame&gt; protect(m_frame);
3671 
3672     // Save user view state to the current history item here since we don&#39;t do a normal load.
3673     // FIXME: Does form state need to be saved here too?
3674     history().saveScrollPositionAndViewStateToItem(history().currentItem());
3675     if (FrameView* view = m_frame.view())
3676         view-&gt;setWasScrolledByUser(false);
3677 
3678     history().setCurrentItem(item);
3679 
3680     // loadInSameDocument() actually changes the URL and notifies load delegates of a &quot;fake&quot; load
3681     loadInSameDocument(item.url(), item.stateObject(), false);
3682 
3683     // Restore user view state from the current history item here since we don&#39;t do a normal load.
3684     history().restoreScrollPositionAndViewState();
3685 }
3686 
3687 // FIXME: This function should really be split into a couple pieces, some of
3688 // which should be methods of HistoryController and some of which should be
3689 // methods of FrameLoader.
<span class="line-modified">3690 void FrameLoader::loadDifferentDocumentItem(HistoryItem&amp; item, FrameLoadType loadType, FormSubmissionCacheLoadPolicy cacheLoadPolicy, ShouldTreatAsContinuingLoad shouldTreatAsContinuingLoad)</span>
3691 {
3692     RELEASE_LOG_IF_ALLOWED(&quot;loadDifferentDocumentItem: frame load started (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());
3693 
3694     Ref&lt;Frame&gt; protectedFrame(m_frame);
3695 
3696     // History items should not be reported to the parent.
3697     m_shouldReportResourceTimingToParentFrame = false;
3698 
3699     // Remember this item so we can traverse any child items as child frames load
3700     history().setProvisionalItem(&amp;item);
3701 
3702     auto initiatedByMainFrame = InitiatedByMainFrame::Unknown;
3703 
3704     SetForScope&lt;LoadContinuingState&gt; continuingLoadGuard(m_currentLoadContinuingState, shouldTreatAsContinuingLoad == ShouldTreatAsContinuingLoad::Yes ? LoadContinuingState::ContinuingWithHistoryItem : LoadContinuingState::NotContinuing);
3705 
3706     if (CachedPage* cachedPage = PageCache::singleton().get(item, m_frame.page())) {
3707         auto documentLoader = cachedPage-&gt;documentLoader();
3708         m_client.updateCachedDocumentLoader(*documentLoader);
3709 
3710         auto action = NavigationAction { *m_frame.document(), documentLoader-&gt;request(), initiatedByMainFrame, loadType, false };
3711         action.setTargetBackForwardItem(item);

3712         documentLoader-&gt;setTriggeringAction(WTFMove(action));
3713 
3714         documentLoader-&gt;setLastCheckedRequest(ResourceRequest());
3715         loadWithDocumentLoader(documentLoader, loadType, { }, AllowNavigationToInvalidURL::Yes, shouldTreatAsContinuingLoad);
3716         return;
3717     }
3718 
3719     URL itemURL = item.url();
3720     URL itemOriginalURL = item.originalURL();
3721     URL currentURL;
3722     if (documentLoader())
3723         currentURL = documentLoader()-&gt;url();
3724     RefPtr&lt;FormData&gt; formData = item.formData();
3725 
3726     ResourceRequest request(itemURL);
3727 
3728     if (!item.referrer().isNull())
3729         request.setHTTPReferrer(item.referrer());
3730 
3731     ShouldOpenExternalURLsPolicy shouldOpenExternalURLsPolicy = shouldOpenExternalURLsPolicyToApply(m_frame, initiatedByMainFrame, item.shouldOpenExternalURLsPolicy());
3732     bool isFormSubmission = false;
3733     Event* event = nullptr;
3734 
3735     // If this was a repost that failed the page cache, we might try to repost the form.
3736     NavigationAction action;
3737     if (formData) {
<span class="line-removed">3738         formData-&gt;generateFiles(m_frame.document());</span>
<span class="line-removed">3739 </span>
3740         request.setHTTPMethod(&quot;POST&quot;);
3741         request.setHTTPBody(WTFMove(formData));
3742         request.setHTTPContentType(item.formContentType());
3743         auto securityOrigin = SecurityOrigin::createFromString(item.referrer());
3744         addHTTPOriginIfNeeded(request, securityOrigin-&gt;toString());
3745         addHTTPUpgradeInsecureRequestsIfNeeded(request);
3746 
3747         // Make sure to add extra fields to the request after the Origin header is added for the FormData case.
3748         // See https://bugs.webkit.org/show_bug.cgi?id=22194 for more discussion.
3749         addExtraFieldsToRequest(request, loadType, true);
3750 
3751         // FIXME: Slight hack to test if the NSURL cache contains the page we&#39;re going to.
3752         // We want to know this before talking to the policy delegate, since it affects whether
3753         // we show the DoYouReallyWantToRepost nag.
3754         //
3755         // This trick has a small bug (3123893) where we might find a cache hit, but then
3756         // have the item vanish when we try to use it in the ensuing nav.  This should be
3757         // extremely rare, but in that case the user will get an error on the navigation.
3758 
3759         if (cacheLoadPolicy == MayAttemptCacheOnlyLoadForFormSubmissionItem) {
</pre>
<hr />
<pre>
3782                 request.setCachePolicy(ResourceRequestCachePolicy::ReturnCacheDataElseLoad);
3783             item.setWasRestoredFromSession(false);
3784             break;
3785         }
3786         case FrameLoadType::Standard:
3787         case FrameLoadType::RedirectWithLockedBackForwardList:
3788             break;
3789         case FrameLoadType::Same:
3790         case FrameLoadType::Replace:
3791             ASSERT_NOT_REACHED();
3792         }
3793 
3794         addExtraFieldsToRequest(request, loadType, true);
3795 
3796         ResourceRequest requestForOriginalURL(request);
3797         requestForOriginalURL.setURL(itemOriginalURL);
3798         action = { *m_frame.document(), requestForOriginalURL, initiatedByMainFrame, loadType, isFormSubmission, event, shouldOpenExternalURLsPolicy };
3799     }
3800 
3801     action.setTargetBackForwardItem(item);

3802 
3803     loadWithNavigationAction(request, WTFMove(action), LockHistory::No, loadType, { }, AllowNavigationToInvalidURL::Yes);
3804 }
3805 
3806 // Loads content into this frame, as specified by history item
<span class="line-modified">3807 void FrameLoader::loadItem(HistoryItem&amp; item, FrameLoadType loadType, ShouldTreatAsContinuingLoad shouldTreatAsContinuingLoad)</span>
3808 {
3809     m_requestedHistoryItem = &amp;item;
3810     HistoryItem* currentItem = history().currentItem();
3811     bool sameDocumentNavigation = currentItem &amp;&amp; item.shouldDoSameDocumentNavigationTo(*currentItem);
3812 
3813     if (sameDocumentNavigation)
3814         loadSameDocumentItem(item);
3815     else
<span class="line-modified">3816         loadDifferentDocumentItem(item, loadType, MayAttemptCacheOnlyLoadForFormSubmissionItem, shouldTreatAsContinuingLoad);</span>
3817 }
3818 
3819 void FrameLoader::retryAfterFailedCacheOnlyMainResourceLoad()
3820 {
3821     ASSERT(m_state == FrameStateProvisional);
3822     ASSERT(!m_loadingFromCachedPage);
3823     ASSERT(history().provisionalItem());
3824     ASSERT(history().provisionalItem()-&gt;formData());
3825     ASSERT(history().provisionalItem() == m_requestedHistoryItem.get());
3826 
3827     FrameLoadType loadType = m_loadType;
<span class="line-modified">3828     HistoryItem&amp; item = *history().provisionalItem();</span>
3829 
3830     stopAllLoaders(ShouldNotClearProvisionalItem);
<span class="line-modified">3831     loadDifferentDocumentItem(item, loadType, MayNotAttemptCacheOnlyLoadForFormSubmissionItem, ShouldTreatAsContinuingLoad::No);</span>





3832 }
3833 
3834 ResourceError FrameLoader::cancelledError(const ResourceRequest&amp; request) const
3835 {
3836     ResourceError error = m_client.cancelledError(request);
3837     error.setType(ResourceError::Type::Cancellation);
3838     return error;
3839 }
3840 
3841 ResourceError FrameLoader::blockedByContentBlockerError(const ResourceRequest&amp; request) const
3842 {
3843     return m_client.blockedByContentBlockerError(request);
3844 }
3845 
3846 ResourceError FrameLoader::blockedError(const ResourceRequest&amp; request) const
3847 {
3848     ResourceError error = m_client.blockedError(request);
3849     error.setType(ResourceError::Type::Cancellation);
3850     return error;
3851 }
</pre>
</td>
<td>
<hr />
<pre>
  28  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  29  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  30  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  31  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  32  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  33  */
  34 
  35 #include &quot;config.h&quot;
  36 #include &quot;FrameLoader.h&quot;
  37 
  38 #include &quot;AXObjectCache.h&quot;
  39 #include &quot;ApplicationCacheHost.h&quot;
  40 #include &quot;BackForwardController.h&quot;
  41 #include &quot;BeforeUnloadEvent.h&quot;
  42 #include &quot;CachedPage.h&quot;
  43 #include &quot;CachedResourceLoader.h&quot;
  44 #include &quot;Chrome.h&quot;
  45 #include &quot;ChromeClient.h&quot;
  46 #include &quot;CommonVM.h&quot;
  47 #include &quot;ContentFilter.h&quot;
<span class="line-added">  48 #include &quot;ContentRuleListResults.h&quot;</span>
  49 #include &quot;ContentSecurityPolicy.h&quot;
<span class="line-added">  50 #include &quot;CustomHeaderFields.h&quot;</span>
  51 #include &quot;DOMWindow.h&quot;
  52 #include &quot;DatabaseManager.h&quot;
  53 #include &quot;DiagnosticLoggingClient.h&quot;
  54 #include &quot;DiagnosticLoggingKeys.h&quot;
  55 #include &quot;Document.h&quot;
  56 #include &quot;DocumentLoader.h&quot;
  57 #include &quot;Editor.h&quot;
  58 #include &quot;EditorClient.h&quot;
  59 #include &quot;Element.h&quot;
  60 #include &quot;Event.h&quot;
  61 #include &quot;EventHandler.h&quot;
  62 #include &quot;EventNames.h&quot;
  63 #include &quot;FloatRect.h&quot;
  64 #include &quot;FormState.h&quot;
  65 #include &quot;FormSubmission.h&quot;
  66 #include &quot;Frame.h&quot;
  67 #include &quot;FrameLoadRequest.h&quot;
  68 #include &quot;FrameLoaderClient.h&quot;
  69 #include &quot;FrameNetworkingContext.h&quot;
  70 #include &quot;FrameTree.h&quot;
</pre>
<hr />
<pre>
 101 #include &quot;PolicyChecker.h&quot;
 102 #include &quot;ProgressTracker.h&quot;
 103 #include &quot;ResourceHandle.h&quot;
 104 #include &quot;ResourceLoadInfo.h&quot;
 105 #include &quot;ResourceLoadObserver.h&quot;
 106 #include &quot;ResourceRequest.h&quot;
 107 #include &quot;SVGDocument.h&quot;
 108 #include &quot;SVGLocatable.h&quot;
 109 #include &quot;SVGNames.h&quot;
 110 #include &quot;SVGViewElement.h&quot;
 111 #include &quot;SVGViewSpec.h&quot;
 112 #include &quot;ScriptController.h&quot;
 113 #include &quot;ScriptSourceCode.h&quot;
 114 #include &quot;ScrollAnimator.h&quot;
 115 #include &quot;SecurityOrigin.h&quot;
 116 #include &quot;SecurityPolicy.h&quot;
 117 #include &quot;SegmentedString.h&quot;
 118 #include &quot;SerializedScriptValue.h&quot;
 119 #include &quot;Settings.h&quot;
 120 #include &quot;ShouldTreatAsContinuingLoad.h&quot;
<span class="line-added"> 121 #include &quot;StyleTreeResolver.h&quot;</span>
 122 #include &quot;SubframeLoader.h&quot;
 123 #include &quot;SubresourceLoader.h&quot;
 124 #include &quot;TextResourceDecoder.h&quot;
 125 #include &quot;UserContentController.h&quot;
 126 #include &quot;UserGestureIndicator.h&quot;
 127 #include &quot;WindowFeatures.h&quot;
 128 #include &quot;XMLDocumentParser.h&quot;
 129 #include &lt;dom/ScriptDisallowedScope.h&gt;
 130 #include &lt;wtf/CompletionHandler.h&gt;
 131 #include &lt;wtf/URL.h&gt;
 132 #include &lt;wtf/Ref.h&gt;
 133 #include &lt;wtf/SetForScope.h&gt;
 134 #include &lt;wtf/StdLibExtras.h&gt;
 135 #include &lt;wtf/SystemTracing.h&gt;
 136 #include &lt;wtf/text/CString.h&gt;
 137 #include &lt;wtf/text/WTFString.h&gt;
 138 
 139 #if ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)
 140 #include &quot;Archive.h&quot;
 141 #endif
 142 
 143 #if ENABLE(DATA_DETECTION)
 144 #include &quot;DataDetection.h&quot;
 145 #endif
 146 
 147 #if PLATFORM(IOS_FAMILY)
 148 #include &quot;DocumentType.h&quot;
 149 #include &quot;ResourceLoader.h&quot;
 150 #include &quot;RuntimeApplicationChecks.h&quot;

 151 #endif
 152 
 153 #define RELEASE_LOG_IF_ALLOWED(fmt, ...) RELEASE_LOG_IF(isAlwaysOnLoggingAllowed(), Network, &quot;%p - FrameLoader::&quot; fmt, this, ##__VA_ARGS__)
 154 
 155 namespace WebCore {
 156 
 157 using namespace HTMLNames;
 158 using namespace SVGNames;
 159 
 160 static const char defaultAcceptHeader[] = &quot;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&quot;;
 161 
 162 bool isBackForwardLoadType(FrameLoadType type)
 163 {
 164     switch (type) {
 165     case FrameLoadType::Standard:
 166     case FrameLoadType::Reload:
 167     case FrameLoadType::ReloadFromOrigin:
 168     case FrameLoadType::ReloadExpiredOnly:
 169     case FrameLoadType::Same:
 170     case FrameLoadType::RedirectWithLockedBackForwardList:
</pre>
<hr />
<pre>
 253 
 254     void progressCompleted()
 255     {
 256         ASSERT(m_inProgress);
 257         ASSERT(m_frame.page());
 258         m_inProgress = false;
 259         m_frame.page()-&gt;progress().progressCompleted(m_frame);
 260 
 261         if (auto pageID = m_frame.loader().client().pageID())
 262             platformStrategies()-&gt;loaderStrategy()-&gt;pageLoadCompleted(pageID.value());
 263     }
 264 
 265 private:
 266     Frame&amp; m_frame;
 267     bool m_inProgress;
 268 };
 269 
 270 FrameLoader::FrameLoader(Frame&amp; frame, FrameLoaderClient&amp; client)
 271     : m_frame(frame)
 272     , m_client(client)
<span class="line-modified"> 273     , m_policyChecker(makeUnique&lt;PolicyChecker&gt;(frame))</span>
<span class="line-modified"> 274     , m_history(makeUnique&lt;HistoryController&gt;(frame))</span>
 275     , m_notifier(frame)
<span class="line-modified"> 276     , m_subframeLoader(makeUnique&lt;SubframeLoader&gt;(frame))</span>
 277     , m_mixedContentChecker(frame)
 278     , m_state(FrameStateProvisional)
 279     , m_loadType(FrameLoadType::Standard)
 280     , m_quickRedirectComing(false)
 281     , m_sentRedirectNotification(false)
 282     , m_inStopAllLoaders(false)
 283     , m_isExecutingJavaScriptFormAction(false)
 284     , m_didCallImplicitClose(true)
 285     , m_wasUnloadEventEmitted(false)
 286     , m_isComplete(false)
 287     , m_needsClear(false)
 288     , m_checkTimer(*this, &amp;FrameLoader::checkTimerFired)
 289     , m_shouldCallCheckCompleted(false)
 290     , m_shouldCallCheckLoadComplete(false)
 291     , m_opener(nullptr)
 292     , m_loadingFromCachedPage(false)
 293     , m_currentNavigationHasShownBeforeUnloadConfirmPanel(false)
 294     , m_loadsSynchronously(false)
 295     , m_forcedSandboxFlags(SandboxNone)
 296 {
</pre>
<hr />
<pre>
 304         frame-&gt;loader().m_opener = nullptr;
 305 
 306     m_client.frameLoaderDestroyed();
 307 
 308     if (m_networkingContext)
 309         m_networkingContext-&gt;invalidate();
 310 }
 311 
 312 void FrameLoader::init()
 313 {
 314     // This somewhat odd set of steps gives the frame an initial empty document.
 315     setPolicyDocumentLoader(m_client.createDocumentLoader(ResourceRequest(URL({ }, emptyString())), SubstituteData()).ptr());
 316     setProvisionalDocumentLoader(m_policyDocumentLoader.get());
 317     m_provisionalDocumentLoader-&gt;startLoadingMainResource();
 318 
 319     Ref&lt;Frame&gt; protect(m_frame);
 320     m_frame.document()-&gt;cancelParsing();
 321     m_stateMachine.advanceTo(FrameLoaderStateMachine::DisplayingInitialEmptyDocument);
 322 
 323     m_networkingContext = m_client.createNetworkingContext();
<span class="line-modified"> 324     m_progressTracker = makeUnique&lt;FrameProgressTracker&gt;(m_frame);</span>
 325 }
 326 
 327 void FrameLoader::initForSynthesizedDocument(const URL&amp;)
 328 {
 329     // FIXME: We need to initialize the document URL to the specified URL. Currently the URL is empty and hence
 330     // FrameLoader::checkCompleted() will overwrite the URL of the document to be activeDocumentLoader()-&gt;documentURL().
 331 
 332     auto loader = m_client.createDocumentLoader(ResourceRequest(URL({ }, emptyString())), SubstituteData());
 333     loader-&gt;attachToFrame(m_frame);
 334     loader-&gt;setResponse(ResourceResponse(URL(), &quot;text/html&quot;_s, 0, String()));
 335     loader-&gt;setCommitted(true);
 336     setDocumentLoader(loader.ptr());
 337 
 338     m_stateMachine.advanceTo(FrameLoaderStateMachine::DisplayingInitialEmptyDocument);
 339     m_stateMachine.advanceTo(FrameLoaderStateMachine::DisplayingInitialEmptyDocumentPostCommit);
 340     m_stateMachine.advanceTo(FrameLoaderStateMachine::CommittedFirstRealLoad);
 341     m_client.transitionToCommittedForNewPage();
 342 
 343     m_didCallImplicitClose = true;
 344     m_isComplete = true;
 345     m_state = FrameStateComplete;
 346     m_needsClear = true;
 347 
 348     m_networkingContext = m_client.createNetworkingContext();
<span class="line-modified"> 349     m_progressTracker = makeUnique&lt;FrameProgressTracker&gt;(m_frame);</span>
 350 }
 351 
 352 void FrameLoader::setDefersLoading(bool defers)
 353 {
 354     if (m_documentLoader)
 355         m_documentLoader-&gt;setDefersLoading(defers);
 356     if (m_provisionalDocumentLoader)
 357         m_provisionalDocumentLoader-&gt;setDefersLoading(defers);
 358     if (m_policyDocumentLoader)
 359         m_policyDocumentLoader-&gt;setDefersLoading(defers);
 360     history().setDefersLoading(defers);
 361 
 362     if (!defers) {
 363         m_frame.navigationScheduler().startTimer();
 364         startCheckCompleteTimer();
 365     }
 366 }
 367 
 368 void FrameLoader::checkContentPolicy(const ResourceResponse&amp; response, PolicyCheckIdentifier identifier, ContentPolicyDecisionFunction&amp;&amp; function)
 369 {
 370     if (!activeDocumentLoader()) {
 371         // Load was cancelled
 372         function(PolicyAction::Ignore, identifier);
 373         return;
 374     }
 375 
 376     // FIXME: Validate the policy check identifier.
<span class="line-modified"> 377     client().dispatchDecidePolicyForResponse(response, activeDocumentLoader()-&gt;request(), identifier, activeDocumentLoader()-&gt;downloadAttribute(), WTFMove(function));</span>
 378 }
 379 
 380 void FrameLoader::changeLocation(FrameLoadRequest&amp;&amp; request)
 381 {
 382     urlSelected(WTFMove(request), nullptr);
 383 }
 384 
<span class="line-modified"> 385 void FrameLoader::urlSelected(const URL&amp; url, const String&amp; passedTarget, Event* triggeringEvent, LockHistory lockHistory, LockBackForwardList lockBackForwardList, ShouldSendReferrer shouldSendReferrer, ShouldOpenExternalURLsPolicy shouldOpenExternalURLsPolicy, Optional&lt;NewFrameOpenerPolicy&gt; openerPolicy, const AtomString&amp; downloadAttribute, const SystemPreviewInfo&amp; systemPreviewInfo, Optional&lt;AdClickAttribution&gt;&amp;&amp; adClickAttribution)</span>
 386 {
 387     auto* frame = lexicalFrameFromCommonVM();
 388     auto initiatedByMainFrame = frame &amp;&amp; frame-&gt;isMainFrame() ? InitiatedByMainFrame::Yes : InitiatedByMainFrame::Unknown;
 389 
 390     NewFrameOpenerPolicy newFrameOpenerPolicy = openerPolicy.valueOr(shouldSendReferrer == NeverSendReferrer ? NewFrameOpenerPolicy::Suppress : NewFrameOpenerPolicy::Allow);
 391     urlSelected(FrameLoadRequest(*m_frame.document(), m_frame.document()-&gt;securityOrigin(), { url }, passedTarget, lockHistory, lockBackForwardList, shouldSendReferrer, AllowNavigationToInvalidURL::Yes, newFrameOpenerPolicy, shouldOpenExternalURLsPolicy, initiatedByMainFrame, DoNotReplaceDocumentIfJavaScriptURL, downloadAttribute, systemPreviewInfo), triggeringEvent, WTFMove(adClickAttribution));
 392 }
 393 
 394 void FrameLoader::urlSelected(FrameLoadRequest&amp;&amp; frameRequest, Event* triggeringEvent, Optional&lt;AdClickAttribution&gt;&amp;&amp; adClickAttribution)
 395 {
 396     RELEASE_LOG_IF_ALLOWED(&quot;urlSelected: frame load started (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());
 397 
 398     Ref&lt;Frame&gt; protect(m_frame);
 399 
 400     if (m_frame.script().executeIfJavaScriptURL(frameRequest.resourceRequest().url(), frameRequest.shouldReplaceDocumentIfJavaScriptURL()))
 401         return;
 402 
 403     if (frameRequest.frameName().isEmpty())
 404         frameRequest.setFrameName(m_frame.document()-&gt;baseTarget());
 405 
</pre>
<hr />
<pre>
 457         return;
 458 
 459     // FIXME: We&#39;d like to remove this altogether and fix the multiple form submission issue another way.
 460 
 461     // We do not want to submit more than one form from the same page, nor do we want to submit a single
 462     // form more than once. This flag prevents these from happening; not sure how other browsers prevent this.
 463     // The flag is reset in each time we start dispatching a new mouse or key down event, and
 464     // also in setView since this part may get reused for a page from the back/forward cache.
 465     // The form multi-submit logic here is only needed when we are submitting a form that affects this frame.
 466 
 467     // FIXME: Frame targeting is only one of the ways the submission could end up doing something other
 468     // than replacing this frame&#39;s content, so this check is flawed. On the other hand, the check is hardly
 469     // needed any more now that we reset m_submittedFormURL on each mouse or key down event.
 470 
 471     if (m_frame.tree().isDescendantOf(targetFrame)) {
 472         if (m_submittedFormURL == submission-&gt;requestURL())
 473             return;
 474         m_submittedFormURL = submission-&gt;requestURL();
 475     }
 476 

 477     submission-&gt;setReferrer(outgoingReferrer());
 478     submission-&gt;setOrigin(outgoingOrigin());
 479 
 480     targetFrame-&gt;navigationScheduler().scheduleFormSubmission(WTFMove(submission));
 481 }
 482 
 483 void FrameLoader::stopLoading(UnloadEventPolicy unloadEventPolicy)
 484 {
 485     if (m_frame.document() &amp;&amp; m_frame.document()-&gt;parser())
 486         m_frame.document()-&gt;parser()-&gt;stopParsing();
 487 
 488     if (unloadEventPolicy != UnloadEventPolicyNone)
 489         dispatchUnloadEvents(unloadEventPolicy);
 490 
 491     m_isComplete = true; // to avoid calling completed() in finishedParsing()
 492     m_didCallImplicitClose = true; // don&#39;t want that one either
 493 
 494     if (m_frame.document() &amp;&amp; m_frame.document()-&gt;parsing()) {
 495         finishedParsing();
 496         m_frame.document()-&gt;setParsing(false);
 497     }
 498 
 499     if (auto* document = m_frame.document()) {




 500         // FIXME: Should the DatabaseManager watch for something like ActiveDOMObject::stop() rather than being special-cased here?
 501         DatabaseManager::singleton().stopDatabases(*document, nullptr);
 502     }
 503 
 504     policyChecker().stopCheck();
 505 
 506     // FIXME: This will cancel redirection timer, which really needs to be restarted when restoring the frame from b/f cache.
 507     m_frame.navigationScheduler().cancel();
 508 }
 509 
 510 void FrameLoader::stop()
 511 {
 512     // http://bugs.webkit.org/show_bug.cgi?id=10854
 513     // The frame&#39;s last ref may be removed and it will be deleted by checkCompleted().
 514     Ref&lt;Frame&gt; protect(m_frame);
 515 
 516     if (DocumentParser* parser = m_frame.document()-&gt;parser()) {
 517         parser-&gt;stopParsing();
 518         parser-&gt;finish();
 519     }
</pre>
<hr />
<pre>
 573     if (!m_stateMachine.creatingInitialEmptyDocument()) {
 574         DOMWindow* window = m_frame.document()-&gt;domWindow();
 575         window-&gt;setStatus(String());
 576         window-&gt;setDefaultStatus(String());
 577     }
 578 
 579     started();
 580 
 581     return true;
 582 }
 583 
 584 void FrameLoader::didExplicitOpen()
 585 {
 586     m_isComplete = false;
 587     m_didCallImplicitClose = false;
 588 
 589     // Calling document.open counts as committing the first real document load.
 590     if (!m_stateMachine.committedFirstRealDocumentLoad())
 591         m_stateMachine.advanceTo(FrameLoaderStateMachine::DisplayingInitialEmptyDocumentPostCommit);
 592 
<span class="line-added"> 593     m_client.dispatchDidExplicitOpen(m_frame.document() ? m_frame.document()-&gt;url() : URL());</span>
<span class="line-added"> 594 </span>
 595     // Prevent window.open(url) -- eg window.open(&quot;about:blank&quot;) -- from blowing away results
 596     // from a subsequent window.document.open / window.document.write call.
 597     // Canceling redirection here works for all cases because document.open
 598     // implicitly precedes document.write.
 599     m_frame.navigationScheduler().cancel();
 600 }
 601 
 602 
 603 void FrameLoader::cancelAndClear()
 604 {
 605     m_frame.navigationScheduler().cancel();
 606 
 607     if (!m_isComplete)
 608         closeURL();
 609 
 610     clear(m_frame.document(), false);
 611     m_frame.script().updatePlatformScriptObjects();
 612 }
 613 
 614 static inline bool shouldClearWindowName(const Frame&amp; frame, const Document&amp; newDocument)
 615 {
 616     if (!frame.isMainFrame())
 617         return false;
 618 
 619     if (frame.loader().opener())
 620         return false;
 621 
 622     return !newDocument.securityOrigin().isSameOriginAs(frame.document()-&gt;securityOrigin());
 623 }
 624 
<span class="line-modified"> 625 void FrameLoader::clear(Document* newDocument, bool clearWindowProperties, bool clearScriptObjects, bool clearFrameView, WTF::Function&lt;void()&gt;&amp;&amp; handleDOMWindowCreation)</span>
 626 {
 627     m_frame.editor().clear();
 628 
<span class="line-modified"> 629     bool neededClear = m_needsClear;</span>

 630     m_needsClear = false;
 631 
<span class="line-modified"> 632     if (neededClear &amp;&amp; m_frame.document()-&gt;pageCacheState() != Document::InPageCache) {</span>
 633         m_frame.document()-&gt;cancelParsing();
 634         m_frame.document()-&gt;stopActiveDOMObjects();
 635         bool hadLivingRenderTree = m_frame.document()-&gt;hasLivingRenderTree();
 636         m_frame.document()-&gt;prepareForDestruction();
 637         if (hadLivingRenderTree)
 638             m_frame.document()-&gt;adjustFocusedNodeOnNodeRemoval(*m_frame.document());
 639     }
 640 
<span class="line-added"> 641     if (handleDOMWindowCreation)</span>
<span class="line-added"> 642         handleDOMWindowCreation();</span>
<span class="line-added"> 643 </span>
<span class="line-added"> 644     if (!neededClear)</span>
<span class="line-added"> 645         return;</span>
<span class="line-added"> 646 </span>
 647     // Do this after detaching the document so that the unload event works.
 648     if (clearWindowProperties) {
 649         InspectorInstrumentation::frameWindowDiscarded(m_frame, m_frame.document()-&gt;domWindow());
 650         m_frame.document()-&gt;domWindow()-&gt;resetUnlessSuspendedForDocumentSuspension();
 651         m_frame.windowProxy().clearJSWindowProxiesNotMatchingDOMWindow(newDocument-&gt;domWindow(), m_frame.document()-&gt;pageCacheState() == Document::AboutToEnterPageCache);
 652 
 653         if (shouldClearWindowName(m_frame, *newDocument))
 654             m_frame.tree().setName(nullAtom());
 655     }
 656 
 657     m_frame.selection().prepareForDestruction();
 658     m_frame.eventHandler().clear();
 659 
 660     if (clearFrameView &amp;&amp; m_frame.view())
 661         m_frame.view()-&gt;clear();
 662 
 663     // Do not drop the document before the ScriptController and view are cleared
 664     // as some destructors might still try to access the document.
 665     m_frame.setDocument(nullptr);
 666 
</pre>
<hr />
<pre>
 962 {
 963     RELEASE_LOG_IF_ALLOWED(&quot;loadURLIntoChildFrame: frame load started (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());
 964 
 965     ASSERT(childFrame);
 966 
 967 #if ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)
 968     if (auto activeLoader = activeDocumentLoader()) {
 969         if (auto subframeArchive = activeLoader-&gt;popArchiveForSubframe(childFrame-&gt;tree().uniqueName(), url)) {
 970             childFrame-&gt;loader().loadArchive(RefPtr&lt;Archive&gt; { subframeArchive }.releaseNonNull());
 971             return;
 972         }
 973     }
 974 #endif
 975 
 976     // If we&#39;re moving in the back/forward list, we might want to replace the content
 977     // of this child frame with whatever was there at that point.
 978     auto* parentItem = history().currentItem();
 979     if (parentItem &amp;&amp; parentItem-&gt;children().size() &amp;&amp; isBackForwardLoadType(loadType()) &amp;&amp; !m_frame.document()-&gt;loadEventFinished()) {
 980         if (auto* childItem = parentItem-&gt;childItemWithTarget(childFrame-&gt;tree().uniqueName())) {
 981             childFrame-&gt;loader().m_requestedHistoryItem = childItem;
<span class="line-modified"> 982             childFrame-&gt;loader().loadDifferentDocumentItem(*childItem, nullptr, loadType(), MayAttemptCacheOnlyLoadForFormSubmissionItem, ShouldTreatAsContinuingLoad::No);</span>
 983             return;
 984         }
 985     }
 986 
 987     auto* lexicalFrame = lexicalFrameFromCommonVM();
 988     auto initiatedByMainFrame = lexicalFrame &amp;&amp; lexicalFrame-&gt;isMainFrame() ? InitiatedByMainFrame::Yes : InitiatedByMainFrame::Unknown;
 989 
 990     FrameLoadRequest frameLoadRequest { *m_frame.document(), m_frame.document()-&gt;securityOrigin(), { url }, &quot;_self&quot;_s, LockHistory::No, LockBackForwardList::Yes, ShouldSendReferrer::MaybeSendReferrer, AllowNavigationToInvalidURL::Yes, NewFrameOpenerPolicy::Suppress, ShouldOpenExternalURLsPolicy::ShouldNotAllow, initiatedByMainFrame };
 991     childFrame-&gt;loader().loadURL(WTFMove(frameLoadRequest), referer, FrameLoadType::RedirectWithLockedBackForwardList, nullptr, { }, WTF::nullopt, [] { });
 992 }
 993 
 994 #if ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)
 995 
 996 void FrameLoader::loadArchive(Ref&lt;Archive&gt;&amp;&amp; archive)
 997 {
 998     RELEASE_LOG_IF_ALLOWED(&quot;loadArchive: frame load started (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());
 999 
1000     ArchiveResource* mainResource = archive-&gt;mainResource();
1001     ASSERT(mainResource);
1002     if (!mainResource)
</pre>
<hr />
<pre>
1095 }
1096 
1097 void FrameLoader::resetMultipleFormSubmissionProtection()
1098 {
1099     m_submittedFormURL = URL();
1100 }
1101 
1102 void FrameLoader::updateFirstPartyForCookies()
1103 {
1104     if (m_frame.tree().parent())
1105         setFirstPartyForCookies(m_frame.tree().parent()-&gt;document()-&gt;firstPartyForCookies());
1106     else
1107         setFirstPartyForCookies(m_frame.document()-&gt;url());
1108 }
1109 
1110 void FrameLoader::setFirstPartyForCookies(const URL&amp; url)
1111 {
1112     for (Frame* frame = &amp;m_frame; frame; frame = frame-&gt;tree().traverseNext(&amp;m_frame))
1113         frame-&gt;document()-&gt;setFirstPartyForCookies(url);
1114 
<span class="line-modified">1115     RegistrableDomain registrableDomain(url);</span>
1116     for (Frame* frame = &amp;m_frame; frame; frame = frame-&gt;tree().traverseNext(&amp;m_frame)) {
<span class="line-modified">1117         if (SecurityPolicy::shouldInheritSecurityOriginFromOwner(frame-&gt;document()-&gt;url()) || registrableDomain.matches(frame-&gt;document()-&gt;url()))</span>
1118             frame-&gt;document()-&gt;setSiteForCookies(url);
1119     }
1120 }
1121 
1122 // This does the same kind of work that didOpenURL does, except it relies on the fact
1123 // that a higher level already checked that the URLs match and the scrolling is the right thing to do.
1124 void FrameLoader::loadInSameDocument(const URL&amp; url, SerializedScriptValue* stateObject, bool isNewNavigation)
1125 {
1126     RELEASE_LOG_IF_ALLOWED(&quot;loadInSameDocument: frame load started (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());
1127 
1128     // If we have a state object, we cannot also be a new navigation.
1129     ASSERT(!stateObject || (stateObject &amp;&amp; !isNewNavigation));
1130 
1131     // Update the data source&#39;s request with the new URL to fake the URL change
1132     URL oldURL = m_frame.document()-&gt;url();
1133     m_frame.document()-&gt;setURL(url);
1134     setOutgoingReferrer(url);
1135     documentLoader()-&gt;replaceRequestURLForSameDocumentNavigation(url);
1136     if (isNewNavigation &amp;&amp; !shouldTreatURLAsSameAsCurrent(url) &amp;&amp; !stateObject) {
1137         // NB: must happen after replaceRequestURLForSameDocumentNavigation(), since we add
</pre>
<hr />
<pre>
1308     return propagatedPolicy;
1309 }
1310 
1311 static ShouldOpenExternalURLsPolicy shouldOpenExternalURLsPolicyToApply(Frame&amp; currentFrame, const FrameLoadRequest&amp; frameLoadRequest)
1312 {
1313     return shouldOpenExternalURLsPolicyToApply(currentFrame, frameLoadRequest.initiatedByMainFrame(), frameLoadRequest.shouldOpenExternalURLsPolicy());
1314 }
1315 
1316 static void applyShouldOpenExternalURLsPolicyToNewDocumentLoader(Frame&amp; frame, DocumentLoader&amp; documentLoader, InitiatedByMainFrame initiatedByMainFrame, ShouldOpenExternalURLsPolicy propagatedPolicy)
1317 {
1318     documentLoader.setShouldOpenExternalURLsPolicy(shouldOpenExternalURLsPolicyToApply(frame, initiatedByMainFrame, propagatedPolicy));
1319 }
1320 
1321 static void applyShouldOpenExternalURLsPolicyToNewDocumentLoader(Frame&amp; frame, DocumentLoader&amp; documentLoader, const FrameLoadRequest&amp; frameLoadRequest)
1322 {
1323     documentLoader.setShouldOpenExternalURLsPolicy(shouldOpenExternalURLsPolicyToApply(frame, frameLoadRequest));
1324 }
1325 
1326 bool FrameLoader::isNavigationAllowed() const
1327 {
<span class="line-modified">1328     return m_pageDismissalEventBeingDispatched == PageDismissalType::None &amp;&amp; !m_frame.script().willReplaceWithResultOfExecutingJavascriptURL() &amp;&amp; NavigationDisabler::isNavigationAllowed(m_frame);</span>
1329 }
1330 
1331 bool FrameLoader::isStopLoadingAllowed() const
1332 {
1333     return m_pageDismissalEventBeingDispatched == PageDismissalType::None;
1334 }
1335 
1336 void FrameLoader::loadURL(FrameLoadRequest&amp;&amp; frameLoadRequest, const String&amp; referrer, FrameLoadType newLoadType, Event* event, RefPtr&lt;FormState&gt;&amp;&amp; formState, Optional&lt;AdClickAttribution&gt;&amp;&amp; adClickAttribution, CompletionHandler&lt;void()&gt;&amp;&amp; completionHandler)
1337 {
1338     RELEASE_LOG_IF_ALLOWED(&quot;loadURL: frame load started (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());
1339 
1340     CompletionHandlerCallingScope completionHandlerCaller(WTFMove(completionHandler));
1341     if (m_inStopAllLoaders || m_inClearProvisionalLoadForPolicyCheck)
1342         return;
1343 
1344     Ref&lt;Frame&gt; protect(m_frame);
1345 
1346     // Anchor target is ignored when the download attribute is set since it will download the hyperlink rather than follow it.
1347     String effectiveFrameName = frameLoadRequest.downloadAttribute().isNull() ? frameLoadRequest.frameName() : String();
1348     AllowNavigationToInvalidURL allowNavigationToInvalidURL = frameLoadRequest.allowNavigationToInvalidURL();
</pre>
<hr />
<pre>
1403     if (shouldPerformFragmentNavigation(isFormSubmission, httpMethod, newLoadType, newURL)) {
1404         oldDocumentLoader-&gt;setTriggeringAction(WTFMove(action));
1405         oldDocumentLoader-&gt;setLastCheckedRequest(ResourceRequest());
1406         policyChecker().stopCheck();
1407         policyChecker().setLoadType(newLoadType);
1408         RELEASE_ASSERT(!isBackForwardLoadType(newLoadType) || history().provisionalItem());
1409         policyChecker().checkNavigationPolicy(WTFMove(request), ResourceResponse { } /* redirectResponse */, oldDocumentLoader.get(), WTFMove(formState), [this, protectedFrame = makeRef(m_frame)] (const ResourceRequest&amp; request, WeakPtr&lt;FormState&gt;&amp;&amp;, NavigationPolicyDecision navigationPolicyDecision) {
1410             continueFragmentScrollAfterNavigationPolicy(request, navigationPolicyDecision == NavigationPolicyDecision::ContinueLoad);
1411         }, PolicyDecisionMode::Synchronous);
1412         return;
1413     }
1414 
1415     // Must grab this now, since this load may stop the previous load and clear this flag.
1416     bool isRedirect = m_quickRedirectComing;
1417 #if USE(SYSTEM_PREVIEW)
1418     bool isSystemPreview = frameLoadRequest.isSystemPreview();
1419     request.setSystemPreview(isSystemPreview);
1420     if (isSystemPreview)
1421         request.setSystemPreviewRect(frameLoadRequest.systemPreviewRect());
1422 #endif
<span class="line-modified">1423     loadWithNavigationAction(request, WTFMove(action), lockHistory, newLoadType, WTFMove(formState), allowNavigationToInvalidURL, frameLoadRequest.downloadAttribute(), [this, isRedirect, sameURL, newLoadType, protectedFrame = makeRef(m_frame), completionHandler = completionHandlerCaller.release()] () mutable {</span>
1424         if (isRedirect) {
1425             m_quickRedirectComing = false;
1426             if (m_provisionalDocumentLoader)
1427                 m_provisionalDocumentLoader-&gt;setIsClientRedirect(true);
1428             else if (m_policyDocumentLoader)
1429                 m_policyDocumentLoader-&gt;setIsClientRedirect(true);
1430         } else if (sameURL &amp;&amp; !isReload(newLoadType)) {
1431             // Example of this case are sites that reload the same URL with a different cookie
1432             // driving the generated content, or a master frame with links that drive a target
1433             // frame, where the user has clicked on the same link repeatedly.
1434             m_loadType = FrameLoadType::Same;
1435         }
1436         completionHandler();
1437     });
1438 }
1439 
1440 SubstituteData FrameLoader::defaultSubstituteDataForURL(const URL&amp; url)
1441 {
1442     if (!shouldTreatURLAsSrcdocDocument(url))
1443         return SubstituteData();
</pre>
<hr />
<pre>
1479     if (!request.hasSubstituteData())
1480         request.setSubstituteData(defaultSubstituteDataForURL(request.resourceRequest().url()));
1481 
1482     Ref&lt;DocumentLoader&gt; loader = m_client.createDocumentLoader(request.resourceRequest(), request.substituteData());
1483     loader-&gt;setAllowsWebArchiveForMainFrame(request.isRequestFromClientOrUserInput());
1484     addSameSiteInfoToRequestIfNeeded(loader-&gt;request());
1485     applyShouldOpenExternalURLsPolicyToNewDocumentLoader(m_frame, loader, request);
1486 
1487     if (request.shouldTreatAsContinuingLoad()) {
1488         loader-&gt;setClientRedirectSourceForHistory(request.clientRedirectSourceForHistory());
1489         if (request.lockBackForwardList() == LockBackForwardList::Yes) {
1490             loader-&gt;setIsClientRedirect(true);
1491             m_loadType = FrameLoadType::RedirectWithLockedBackForwardList;
1492         }
1493     }
1494 
1495     SetForScope&lt;LoadContinuingState&gt; continuingLoadGuard(m_currentLoadContinuingState, request.shouldTreatAsContinuingLoad() ? LoadContinuingState::ContinuingWithRequest : LoadContinuingState::NotContinuing);
1496     load(loader.get());
1497 }
1498 
<span class="line-modified">1499 void FrameLoader::loadWithNavigationAction(const ResourceRequest&amp; request, NavigationAction&amp;&amp; action, LockHistory lockHistory, FrameLoadType type, RefPtr&lt;FormState&gt;&amp;&amp; formState, AllowNavigationToInvalidURL allowNavigationToInvalidURL, const String&amp; downloadAttribute, CompletionHandler&lt;void()&gt;&amp;&amp; completionHandler)</span>
1500 {
1501     RELEASE_LOG_IF_ALLOWED(&quot;loadWithNavigationAction: frame load started (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());
1502 
1503     Ref&lt;DocumentLoader&gt; loader = m_client.createDocumentLoader(request, defaultSubstituteDataForURL(request.url()));
<span class="line-added">1504     loader-&gt;setDownloadAttribute(downloadAttribute);</span>
1505     applyShouldOpenExternalURLsPolicyToNewDocumentLoader(m_frame, loader, action.initiatedByMainFrame(), action.shouldOpenExternalURLsPolicy());
1506 
1507     if (lockHistory == LockHistory::Yes &amp;&amp; m_documentLoader)
1508         loader-&gt;setClientRedirectSourceForHistory(m_documentLoader-&gt;didCreateGlobalHistoryEntry() ? m_documentLoader-&gt;urlForHistory().string() : m_documentLoader-&gt;clientRedirectSourceForHistory());
1509 
1510     loader-&gt;setTriggeringAction(WTFMove(action));
1511     if (m_documentLoader)
1512         loader-&gt;setOverrideEncoding(m_documentLoader-&gt;overrideEncoding());
1513 
1514     loadWithDocumentLoader(loader.ptr(), type, WTFMove(formState), allowNavigationToInvalidURL, ShouldTreatAsContinuingLoad::No, WTFMove(completionHandler));
1515 }
1516 
1517 void FrameLoader::load(DocumentLoader&amp; newDocumentLoader)
1518 {
1519     RELEASE_LOG_IF_ALLOWED(&quot;load (DocumentLoader): frame load started (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());
1520 
1521     ResourceRequest&amp; r = newDocumentLoader.request();
1522     addExtraFieldsToMainResourceRequest(r);
1523     FrameLoadType type;
1524 
</pre>
<hr />
<pre>
1791 
1792     addSameSiteInfoToRequestIfNeeded(request);
1793 
1794     // If we&#39;re about to re-post, set up action so the application can warn the user.
1795     if (request.httpMethod() == &quot;POST&quot;)
1796         loader-&gt;setTriggeringAction({ *m_frame.document(), request, InitiatedByMainFrame::Unknown, NavigationType::FormResubmitted });
1797 
1798     loader-&gt;setOverrideEncoding(m_documentLoader-&gt;overrideEncoding());
1799 
1800     auto frameLoadTypeForReloadOptions = [] (auto options) {
1801         if (options &amp; ReloadOption::FromOrigin)
1802             return FrameLoadType::ReloadFromOrigin;
1803         if (options &amp; ReloadOption::ExpiredOnly)
1804             return FrameLoadType::ReloadExpiredOnly;
1805         return FrameLoadType::Reload;
1806     };
1807 
1808     loadWithDocumentLoader(loader.ptr(), frameLoadTypeForReloadOptions(options), { }, AllowNavigationToInvalidURL::Yes, ShouldTreatAsContinuingLoad::No);
1809 }
1810 
<span class="line-modified">1811 void FrameLoader::stopAllLoaders(ClearProvisionalItemPolicy clearProvisionalItemPolicy, StopLoadingPolicy stopLoadingPolicy)</span>
1812 {
1813     if (m_frame.document() &amp;&amp; m_frame.document()-&gt;pageCacheState() == Document::InPageCache)
1814         return;
1815 
<span class="line-modified">1816     if (stopLoadingPolicy == StopLoadingPolicy::PreventDuringUnloadEvents &amp;&amp; !isStopLoadingAllowed())</span>
1817         return;
1818 
1819     // If this method is called from within this method, infinite recursion can occur (3442218). Avoid this.
1820     if (m_inStopAllLoaders)
1821         return;
1822 
1823     // This method might dispatch events.
1824     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(ScriptDisallowedScope::InMainThread::isScriptAllowed());
1825 
1826     // Calling stopLoading() on the provisional document loader can blow away
1827     // the frame from underneath.
1828     Ref&lt;Frame&gt; protect(m_frame);
1829 
1830     m_inStopAllLoaders = true;
1831 
1832     policyChecker().stopCheck();
1833 
1834     // If no new load is in progress, we should clear the provisional item from history
1835     // before we call stopLoading.
1836     if (clearProvisionalItemPolicy == ShouldClearProvisionalItem)
</pre>
<hr />
<pre>
2281         DOMWindow* window = m_frame.document()-&gt;domWindow();
2282         window-&gt;setStatus(String());
2283         window-&gt;setDefaultStatus(String());
2284     }
2285 }
2286 
2287 void FrameLoader::open(CachedFrameBase&amp; cachedFrame)
2288 {
2289     m_isComplete = false;
2290 
2291     // Don&#39;t re-emit the load event.
2292     m_didCallImplicitClose = true;
2293 
2294     URL url = cachedFrame.url();
2295 
2296     // FIXME: I suspect this block of code doesn&#39;t do anything.
2297     if (url.protocolIsInHTTPFamily() &amp;&amp; !url.host().isEmpty() &amp;&amp; url.path().isEmpty())
2298         url.setPath(&quot;/&quot;);
2299 
2300     started();
<span class="line-modified">2301     auto document = makeRef(*cachedFrame.document());</span>

2302     ASSERT(document-&gt;domWindow());
2303 
<span class="line-modified">2304     clear(document.ptr(), true, true, cachedFrame.isMainFrame());</span>
2305 
<span class="line-added">2306     document-&gt;attachToCachedFrame(cachedFrame);</span>
2307     document-&gt;setPageCacheState(Document::NotInPageCache);
2308 
2309     m_needsClear = true;
2310     m_isComplete = false;
2311     m_didCallImplicitClose = false;
<span class="line-modified">2312     setOutgoingReferrer(url);</span>
2313 
2314     FrameView* view = cachedFrame.view();
2315 
2316     // When navigating to a CachedFrame its FrameView should never be null.  If it is we&#39;ll crash in creative ways downstream.
2317     ASSERT(view);
2318     view-&gt;setWasScrolledByUser(false);
2319 
2320     Optional&lt;IntRect&gt; previousViewFrameRect = m_frame.view() ?  m_frame.view()-&gt;frameRect() : Optional&lt;IntRect&gt;(WTF::nullopt);
2321     m_frame.setView(view);
2322 
2323     // Use the previous ScrollView&#39;s frame rect.
2324     if (previousViewFrameRect)
2325         view-&gt;setFrameRect(previousViewFrameRect.value());
2326 
<span class="line-modified">2327 </span>
<span class="line-modified">2328     // Setting the document builds the render tree and runs post style resolution callbacks that can do anything,</span>
<span class="line-modified">2329     // including loading a child frame before its been re-attached to the frame tree as part of this restore.</span>
<span class="line-modified">2330     // For example, the HTML object element may load its content into a frame in a post style resolution callback.</span>
<span class="line-modified">2331     Style::PostResolutionCallbackDisabler disabler(document.get());</span>
<span class="line-modified">2332     WidgetHierarchyUpdatesSuspensionScope suspendWidgetHierarchyUpdates;</span>
<span class="line-modified">2333     NavigationDisabler disableNavigation { &amp;m_frame };</span>
<span class="line-added">2334 </span>
<span class="line-added">2335     m_frame.setDocument(document.copyRef());</span>
2336 
2337     document-&gt;domWindow()-&gt;resumeFromPageCache();
2338 
2339     updateFirstPartyForCookies();
2340 
2341     cachedFrame.restore();
2342 }
2343 
2344 bool FrameLoader::isHostedByObjectElement() const
2345 {
2346     HTMLFrameOwnerElement* owner = m_frame.ownerElement();
2347     return owner &amp;&amp; owner-&gt;hasTagName(objectTag);
2348 }
2349 
2350 bool FrameLoader::isReplacing() const
2351 {
2352     return m_loadType == FrameLoadType::Replace;
2353 }
2354 
2355 void FrameLoader::setReplacing()
</pre>
<hr />
<pre>
2413         return CachePolicyHistoryBuffer;
2414     case FrameLoadType::ReloadFromOrigin:
2415         ASSERT_NOT_REACHED(); // Already handled above.
2416         return CachePolicyReload;
2417     case FrameLoadType::RedirectWithLockedBackForwardList:
2418     case FrameLoadType::Replace:
2419     case FrameLoadType::Same:
2420     case FrameLoadType::Standard:
2421         return CachePolicyVerify;
2422     case FrameLoadType::ReloadExpiredOnly:
2423         // We know about expiration for HTTP and data. Do a normal reload otherwise.
2424         if (!url.protocolIsInHTTPFamily() &amp;&amp; !url.protocolIsData())
2425             return CachePolicyReload;
2426         return CachePolicyVerify;
2427     }
2428 
2429     RELEASE_ASSERT_NOT_REACHED();
2430     return CachePolicyVerify;
2431 }
2432 
<span class="line-added">2433 void FrameLoader::dispatchDidFailProvisionalLoad(DocumentLoader&amp; provisionalDocumentLoader, const ResourceError&amp; error)</span>
<span class="line-added">2434 {</span>
<span class="line-added">2435     m_provisionalLoadErrorBeingHandledURL = provisionalDocumentLoader.url();</span>
<span class="line-added">2436 </span>
<span class="line-added">2437 #if ENABLE(CONTENT_FILTERING)</span>
<span class="line-added">2438     auto contentFilter = provisionalDocumentLoader.contentFilter();</span>
<span class="line-added">2439     auto contentFilterWillContinueLoading = false;</span>
<span class="line-added">2440 #endif</span>
<span class="line-added">2441 </span>
<span class="line-added">2442     auto willContinueLoading = WillContinueLoading::No;</span>
<span class="line-added">2443     if (history().provisionalItem())</span>
<span class="line-added">2444         willContinueLoading = WillContinueLoading::Yes;</span>
<span class="line-added">2445 #if ENABLE(CONTENT_FILTERING)</span>
<span class="line-added">2446     if (contentFilter &amp;&amp; contentFilter-&gt;willHandleProvisionalLoadFailure(error)) {</span>
<span class="line-added">2447         willContinueLoading = WillContinueLoading::Yes;</span>
<span class="line-added">2448         contentFilterWillContinueLoading = true;</span>
<span class="line-added">2449     }</span>
<span class="line-added">2450 #endif</span>
<span class="line-added">2451 </span>
<span class="line-added">2452     m_client.dispatchDidFailProvisionalLoad(error, willContinueLoading);</span>
<span class="line-added">2453 </span>
<span class="line-added">2454 #if ENABLE(CONTENT_FILTERING)</span>
<span class="line-added">2455     if (contentFilterWillContinueLoading)</span>
<span class="line-added">2456         contentFilter-&gt;handleProvisionalLoadFailure(error);</span>
<span class="line-added">2457 #endif</span>
<span class="line-added">2458 </span>
<span class="line-added">2459     m_provisionalLoadErrorBeingHandledURL = { };</span>
<span class="line-added">2460 }</span>
<span class="line-added">2461 </span>
2462 void FrameLoader::checkLoadCompleteForThisFrame()
2463 {
2464     ASSERT(m_client.hasWebView());
2465 
2466     // FIXME: Should this check be done in checkLoadComplete instead of here?
2467     // FIXME: Why does this one check need to be repeated here, and not the many others from checkCompleted?
2468     if (m_frame.document()-&gt;isDelayingLoadEvent())
2469         return;
2470 
2471     switch (m_state) {
2472         case FrameStateProvisional: {
2473             // FIXME: Prohibiting any provisional load failures from being sent to clients
2474             // while handling provisional load failures is too heavy. For example, the current
2475             // load will fail to cancel another ongoing load. That might prevent clients&#39; page
2476             // load state being handled properly.
2477             if (!m_provisionalLoadErrorBeingHandledURL.isEmpty())
2478                 return;
2479 
2480             RefPtr&lt;DocumentLoader&gt; pdl = m_provisionalDocumentLoader;
2481             if (!pdl)
2482                 return;
2483 
2484             // If we&#39;ve received any errors we may be stuck in the provisional state and actually complete.
2485             const ResourceError&amp; error = pdl-&gt;mainDocumentError();
2486             if (error.isNull())
2487                 return;
2488 
2489             // Check all children first.
2490             RefPtr&lt;HistoryItem&gt; item;
2491             if (Page* page = m_frame.page())
2492                 if (isBackForwardLoadType(loadType()))
2493                     // Reset the back forward list to the last committed history item at the top level.
2494                     item = page-&gt;mainFrame().loader().history().currentItem();
2495 
2496             // Only reset if we aren&#39;t already going to a new provisional item.
2497             bool shouldReset = !history().provisionalItem();
2498             if (!pdl-&gt;isLoadingInAPISense() || pdl-&gt;isStopping()) {
2499                 RELEASE_LOG_IF_ALLOWED(&quot;checkLoadCompleteForThisFrame: Failed provisional load (frame = %p, main = %d, isTimeout = %d, isCancellation = %d, errorCode = %d)&quot;, &amp;m_frame, m_frame.isMainFrame(), error.isTimeout(), error.isCancellation(), error.errorCode());







2500 
<span class="line-added">2501                 dispatchDidFailProvisionalLoad(*pdl, error);</span>
2502                 ASSERT(!pdl-&gt;isLoading());
2503 
2504                 // If we&#39;re in the middle of loading multipart data, we need to restore the document loader.
2505                 if (isReplacing() &amp;&amp; !m_documentLoader.get())
2506                     setDocumentLoader(m_provisionalDocumentLoader.get());
2507 
2508                 // Finish resetting the load state, but only if another load hasn&#39;t been started by the
2509                 // delegate callback.
2510                 if (pdl == m_provisionalDocumentLoader)
2511                     clearProvisionalLoad();
2512                 else if (activeDocumentLoader()) {
2513                     URL unreachableURL = activeDocumentLoader()-&gt;unreachableURL();
2514                     if (!unreachableURL.isEmpty() &amp;&amp; unreachableURL == pdl-&gt;request().url())
2515                         shouldReset = false;
2516                 }
2517             }
2518             if (shouldReset &amp;&amp; item)
2519                 if (Page* page = m_frame.page()) {
2520                     page-&gt;backForward().setCurrentItem(*item);
2521                 }
</pre>
<hr />
<pre>
2656     // Note: Can be called multiple times.
2657 
2658     m_client.frameLoadCompleted();
2659 
2660     history().updateForFrameLoadCompleted();
2661 
2662     // After a canceled provisional load, firstLayoutDone is false.
2663     // Reset it to true if we&#39;re displaying a page.
2664     if (m_documentLoader &amp;&amp; m_stateMachine.committedFirstRealDocumentLoad() &amp;&amp; !m_stateMachine.isDisplayingInitialEmptyDocument() &amp;&amp; !m_stateMachine.firstLayoutDone())
2665         m_stateMachine.advanceTo(FrameLoaderStateMachine::FirstLayoutDone);
2666 }
2667 
2668 void FrameLoader::detachChildren()
2669 {
2670     // detachChildren() will fire the unload event in each subframe and the
2671     // HTML specification states that the parent document&#39;s ignore-opens-during-unload counter while
2672     // this event is being fired in its subframes:
2673     // https://html.spec.whatwg.org/multipage/browsers.html#unload-a-document
2674     IgnoreOpensDuringUnloadCountIncrementer ignoreOpensDuringUnloadCountIncrementer(m_frame.document());
2675 
<span class="line-added">2676     // detachChildren() will fire the unload event in each subframe and the</span>
<span class="line-added">2677     // HTML specification states that navigations should be prevented during the prompt to unload algorithm:</span>
<span class="line-added">2678     // https://html.spec.whatwg.org/multipage/browsing-the-web.html#navigate</span>
<span class="line-added">2679     std::unique_ptr&lt;NavigationDisabler&gt; navigationDisabler;</span>
<span class="line-added">2680     if (m_frame.isMainFrame())</span>
<span class="line-added">2681         navigationDisabler = makeUnique&lt;NavigationDisabler&gt;(&amp;m_frame);</span>
<span class="line-added">2682 </span>
2683     // Any subframe inserted by unload event handlers executed in the loop below will not get unloaded
2684     // because we create a copy of the subframes list before looping. Therefore, it would be unsafe to
2685     // allow loading of subframes at this point.
2686     SubframeLoadingDisabler subframeLoadingDisabler(m_frame.document());
2687 
2688     Vector&lt;Ref&lt;Frame&gt;, 16&gt; childrenToDetach;
2689     childrenToDetach.reserveInitialCapacity(m_frame.tree().childCount());
2690     for (Frame* child = m_frame.tree().lastChild(); child; child = child-&gt;tree().previousSibling())
2691         childrenToDetach.uncheckedAppend(*child);
2692     for (auto&amp; child : childrenToDetach)
2693         child-&gt;loader().detachFromParent();
2694 }
2695 
2696 void FrameLoader::closeAndRemoveChild(Frame&amp; child)
2697 {
2698     child.tree().detachFromParent();
2699 
2700     child.setView(nullptr);
2701     if (child.ownerElement() &amp;&amp; child.page())
2702         child.page()-&gt;decrementSubframeCount();
</pre>
<hr />
<pre>
2805     if (m_frame.document()-&gt;pageCacheState() != Document::InPageCache) {
2806         stopAllLoadersAndCheckCompleteness();
2807         m_frame.document()-&gt;stopActiveDOMObjects();
2808     }
2809 
2810     detachFromParent();
2811 }
2812 
2813 void FrameLoader::detachFromParent()
2814 {
2815     // Calling stopAllLoaders() can cause the frame to be deallocated, including the frame loader.
2816     Ref&lt;Frame&gt; protect(m_frame);
2817 
2818     closeURL();
2819     history().saveScrollPositionAndViewStateToItem(history().currentItem());
2820     detachChildren();
2821     if (m_frame.document()-&gt;pageCacheState() != Document::InPageCache) {
2822         // stopAllLoaders() needs to be called after detachChildren() if the document is not in the page cache,
2823         // because detachedChildren() will trigger the unload event handlers of any child frames, and those event
2824         // handlers might start a new subresource load in this frame.
<span class="line-modified">2825         stopAllLoaders(ShouldClearProvisionalItem, StopLoadingPolicy::AlwaysStopLoading);</span>
2826     }
2827 
2828     InspectorInstrumentation::frameDetachedFromParent(m_frame);
2829 
2830     detachViewsAndDocumentLoader();
2831 
2832     m_progressTracker = nullptr;
2833 
2834     if (Frame* parent = m_frame.tree().parent()) {
2835         parent-&gt;loader().closeAndRemoveChild(m_frame);
2836         parent-&gt;loader().scheduleCheckCompleted();
2837         parent-&gt;loader().scheduleCheckLoadComplete();
2838     } else {
2839         m_frame.setView(nullptr);
2840         m_frame.willDetachPage();
2841         m_frame.detachFromPage();
2842     }
2843 }
2844 
2845 void FrameLoader::detachViewsAndDocumentLoader()
</pre>
<hr />
<pre>
2991     }
2992 
2993     request.setHTTPOrigin(origin);
2994 }
2995 
2996 // Implements the &quot;&#39;Same-site&#39; and &#39;cross-site&#39; Requests&quot; algorithm from &lt;https://tools.ietf.org/html/draft-ietf-httpbis-cookie-same-site-00#section-2.1&gt;.
2997 // The algorithm is ammended to treat URLs that inherit their security origin from their owner (e.g. about:blank)
2998 // as same-site. This matches the behavior of Chrome and Firefox.
2999 void FrameLoader::addSameSiteInfoToRequestIfNeeded(ResourceRequest&amp; request, const Document* initiator)
3000 {
3001     if (!request.isSameSiteUnspecified())
3002         return;
3003     if (!initiator) {
3004         request.setIsSameSite(true);
3005         return;
3006     }
3007     if (SecurityPolicy::shouldInheritSecurityOriginFromOwner(request.url())) {
3008         request.setIsSameSite(true);
3009         return;
3010     }
<span class="line-modified">3011     request.setIsSameSite(areRegistrableDomainsEqual(initiator-&gt;siteForCookies(), request.url()));</span>
3012 }
3013 
3014 void FrameLoader::addHTTPUpgradeInsecureRequestsIfNeeded(ResourceRequest&amp; request)
3015 {
3016     if (request.url().protocolIs(&quot;https&quot;)) {
3017         // FIXME: Identify HSTS cases and avoid adding the header. &lt;https://bugs.webkit.org/show_bug.cgi?id=157885&gt;
3018         return;
3019     }
3020 
3021     request.setHTTPHeaderField(HTTPHeaderName::UpgradeInsecureRequests, &quot;1&quot;_s);
3022 }
3023 
3024 void FrameLoader::loadPostRequest(FrameLoadRequest&amp;&amp; request, const String&amp; referrer, FrameLoadType loadType, Event* event, RefPtr&lt;FormState&gt;&amp;&amp; formState, CompletionHandler&lt;void()&gt;&amp;&amp; completionHandler)
3025 {
3026     RELEASE_LOG_IF_ALLOWED(&quot;loadPostRequest: frame load started (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());
3027 
3028     String frameName = request.frameName();
3029     LockHistory lockHistory = request.lockHistory();
3030     AllowNavigationToInvalidURL allowNavigationToInvalidURL = request.allowNavigationToInvalidURL();
3031     NewFrameOpenerPolicy openerPolicy = request.newFrameOpenerPolicy();
</pre>
<hr />
<pre>
3036     String origin = inRequest.httpOrigin();
3037 
3038     ResourceRequest workingResourceRequest(url);
3039 
3040     if (!referrer.isEmpty())
3041         workingResourceRequest.setHTTPReferrer(referrer);
3042     workingResourceRequest.setHTTPOrigin(origin);
3043     workingResourceRequest.setHTTPMethod(&quot;POST&quot;);
3044     workingResourceRequest.setHTTPBody(inRequest.httpBody());
3045     workingResourceRequest.setHTTPContentType(contentType);
3046     addExtraFieldsToRequest(workingResourceRequest, loadType, true);
3047 
3048     if (Document* document = m_frame.document())
3049         document-&gt;contentSecurityPolicy()-&gt;upgradeInsecureRequestIfNeeded(workingResourceRequest, ContentSecurityPolicy::InsecureRequestType::Load);
3050 
3051     NavigationAction action { request.requester(), workingResourceRequest, request.initiatedByMainFrame(), loadType, true, event, request.shouldOpenExternalURLsPolicy(), request.downloadAttribute() };
3052 
3053     if (!frameName.isEmpty()) {
3054         // The search for a target frame is done earlier in the case of form submission.
3055         if (auto* targetFrame = formState ? nullptr : findFrameForNavigation(frameName)) {
<span class="line-modified">3056             targetFrame-&gt;loader().loadWithNavigationAction(workingResourceRequest, WTFMove(action), lockHistory, loadType, WTFMove(formState), allowNavigationToInvalidURL, { }, WTFMove(completionHandler));</span>
3057             return;
3058         }
3059 
3060         policyChecker().checkNewWindowPolicy(WTFMove(action), WTFMove(workingResourceRequest), WTFMove(formState), frameName, [this, allowNavigationToInvalidURL, openerPolicy, completionHandler = WTFMove(completionHandler)] (const ResourceRequest&amp; request, WeakPtr&lt;FormState&gt;&amp;&amp; formState, const String&amp; frameName, const NavigationAction&amp; action, ShouldContinue shouldContinue) mutable {
3061             continueLoadAfterNewWindowPolicy(request, formState.get(), frameName, action, shouldContinue, allowNavigationToInvalidURL, openerPolicy);
3062             completionHandler();
3063         });
3064         return;
3065     }
3066 
3067     // must grab this now, since this load may stop the previous load and clear this flag
3068     bool isRedirect = m_quickRedirectComing;
<span class="line-modified">3069     loadWithNavigationAction(workingResourceRequest, WTFMove(action), lockHistory, loadType, WTFMove(formState), allowNavigationToInvalidURL, { }, [this, isRedirect, protectedFrame = makeRef(m_frame), completionHandler = WTFMove(completionHandler)] () mutable {</span>
3070         if (isRedirect) {
3071             m_quickRedirectComing = false;
3072             if (m_provisionalDocumentLoader)
3073                 m_provisionalDocumentLoader-&gt;setIsClientRedirect(true);
3074             else if (m_policyDocumentLoader)
3075                 m_policyDocumentLoader-&gt;setIsClientRedirect(true);
3076         }
3077         completionHandler();
3078     });
3079 }
3080 
3081 unsigned long FrameLoader::loadResourceSynchronously(const ResourceRequest&amp; request, ClientCredentialPolicy clientCredentialPolicy, const FetchOptions&amp; options, const HTTPHeaderMap&amp; originalRequestHeaders, ResourceError&amp; error, ResourceResponse&amp; response, RefPtr&lt;SharedBuffer&gt;&amp; data)
3082 {
3083     ASSERT(m_frame.document());
3084     String referrer = SecurityPolicy::generateReferrerHeader(m_frame.document()-&gt;referrerPolicy(), request.url(), outgoingReferrer());
3085 
3086     ResourceRequest initialRequest = request;
3087     initialRequest.setTimeoutInterval(10);
3088 
3089     if (!referrer.isEmpty())
3090         initialRequest.setHTTPReferrer(referrer);
3091     addHTTPOriginIfNeeded(initialRequest, outgoingOrigin());
3092 
3093     initialRequest.setFirstPartyForCookies(m_frame.mainFrame().loader().documentLoader()-&gt;request().url());
3094 
3095     addExtraFieldsToSubresourceRequest(initialRequest);
3096 
3097     unsigned long identifier = 0;
3098     ResourceRequest newRequest(initialRequest);
3099     requestFromDelegate(newRequest, identifier, error);
3100 
3101 #if ENABLE(CONTENT_EXTENSIONS)
3102     if (error.isNull()) {
3103         if (auto* page = m_frame.page()) {
3104             if (m_documentLoader) {
<span class="line-modified">3105                 auto results = page-&gt;userContentProvider().processContentRuleListsForLoad(newRequest.url(), ContentExtensions::ResourceType::Raw, *m_documentLoader);</span>
<span class="line-modified">3106                 bool blockedLoad = results.summary.blockedLoad;</span>
<span class="line-modified">3107                 ContentExtensions::applyResultsToRequest(WTFMove(results), page, newRequest);</span>
<span class="line-added">3108                 if (blockedLoad) {</span>
3109                     newRequest = { };
3110                     error = ResourceError(errorDomainWebKitInternal, 0, initialRequest.url(), emptyString());
3111                     response = { };
3112                     data = nullptr;
3113                 }
3114             }
3115         }
3116     }
3117 #endif
3118 
3119     m_frame.document()-&gt;contentSecurityPolicy()-&gt;upgradeInsecureRequestIfNeeded(newRequest, ContentSecurityPolicy::InsecureRequestType::Load);
3120 
3121     if (error.isNull()) {
3122         ASSERT(!newRequest.isNull());
3123 
3124         if (!documentLoader()-&gt;applicationCacheHost().maybeLoadSynchronously(newRequest, error, response, data)) {
3125             Vector&lt;char&gt; buffer;
3126             platformStrategies()-&gt;loaderStrategy()-&gt;loadResourceSynchronously(*this, identifier, newRequest, clientCredentialPolicy, options, originalRequestHeaders, error, response, buffer);
3127             data = SharedBuffer::create(WTFMove(buffer));
3128             documentLoader()-&gt;applicationCacheHost().maybeLoadFallbackSynchronously(newRequest, error, response, data);
</pre>
<hr />
<pre>
3258             if (!targetFrames[i]-&gt;loader().dispatchBeforeUnloadEvent(page-&gt;chrome(), this))
3259                 break;
3260         }
3261 
3262         if (i == targetFrames.size())
3263             shouldClose = true;
3264     }
3265 
3266     if (!shouldClose)
3267         m_submittedFormURL = URL();
3268 
3269     m_currentNavigationHasShownBeforeUnloadConfirmPanel = false;
3270     return shouldClose;
3271 }
3272 
3273 void FrameLoader::dispatchUnloadEvents(UnloadEventPolicy unloadEventPolicy)
3274 {
3275     if (!m_frame.document())
3276         return;
3277 
<span class="line-added">3278     if (m_pageDismissalEventBeingDispatched != PageDismissalType::None)</span>
<span class="line-added">3279         return;</span>
<span class="line-added">3280 </span>
3281     // We store the frame&#39;s page in a local variable because the frame might get detached inside dispatchEvent.
3282     ForbidPromptsScope forbidPrompts(m_frame.page());
3283     IgnoreOpensDuringUnloadCountIncrementer ignoreOpensDuringUnloadCountIncrementer(m_frame.document());
3284 
3285     if (m_didCallImplicitClose &amp;&amp; !m_wasUnloadEventEmitted) {
3286         auto* currentFocusedElement = m_frame.document()-&gt;focusedElement();
3287         if (is&lt;HTMLInputElement&gt;(currentFocusedElement))
3288             downcast&lt;HTMLInputElement&gt;(*currentFocusedElement).endEditing();
3289         if (m_pageDismissalEventBeingDispatched == PageDismissalType::None) {
3290             if (unloadEventPolicy == UnloadEventPolicyUnloadAndPageHide) {
3291                 m_pageDismissalEventBeingDispatched = PageDismissalType::PageHide;
3292                 m_frame.document()-&gt;domWindow()-&gt;dispatchEvent(PageTransitionEvent::create(eventNames().pagehideEvent, m_frame.document()-&gt;pageCacheState() == Document::AboutToEnterPageCache), m_frame.document());
3293             }
3294 
3295             // FIXME: update Page Visibility state here.
3296             // https://bugs.webkit.org/show_bug.cgi?id=116770
3297 
3298             if (m_frame.document()-&gt;pageCacheState() == Document::NotInPageCache) {
3299                 Ref&lt;Event&gt; unloadEvent(Event::create(eventNames().unloadEvent, Event::CanBubble::No, Event::IsCancelable::No));
3300                 // The DocumentLoader (and thus its LoadTiming) might get destroyed
</pre>
<hr />
<pre>
3339     bool userDidInteractWithPage = document.topDocument().userDidInteractWithPage();
3340     // Web pages can request we ask for confirmation before navigating by:
3341     // - Cancelling the BeforeUnloadEvent (modern way)
3342     // - Setting the returnValue attribute on the BeforeUnloadEvent to a non-empty string.
3343     // - Returning a non-empty string from the event handler, which is then set as returnValue
3344     //   attribute on the BeforeUnloadEvent.
3345     return userDidInteractWithPage &amp;&amp; (event.defaultPrevented() || !event.returnValue().isEmpty());
3346 }
3347 
3348 bool FrameLoader::dispatchBeforeUnloadEvent(Chrome&amp; chrome, FrameLoader* frameLoaderBeingNavigated)
3349 {
3350     DOMWindow* domWindow = m_frame.document()-&gt;domWindow();
3351     if (!domWindow)
3352         return true;
3353 
3354     RefPtr&lt;Document&gt; document = m_frame.document();
3355     if (!document-&gt;bodyOrFrameset())
3356         return true;
3357 
3358     Ref&lt;BeforeUnloadEvent&gt; beforeUnloadEvent = BeforeUnloadEvent::create();

3359 
3360     {
<span class="line-added">3361         SetForScope&lt;PageDismissalType&gt; change(m_pageDismissalEventBeingDispatched, PageDismissalType::BeforeUnload);</span>
3362         ForbidPromptsScope forbidPrompts(m_frame.page());
3363         domWindow-&gt;dispatchEvent(beforeUnloadEvent, domWindow-&gt;document());
3364     }
3365 


3366     if (!beforeUnloadEvent-&gt;defaultPrevented())
3367         document-&gt;defaultEventHandler(beforeUnloadEvent.get());
3368 
3369     if (!shouldAskForNavigationConfirmation(*document, beforeUnloadEvent))
3370         return true;
3371 
3372     // If the navigating FrameLoader has already shown a beforeunload confirmation panel for the current navigation attempt,
3373     // this frame is not allowed to cause another one to be shown.
3374     if (frameLoaderBeingNavigated-&gt;m_currentNavigationHasShownBeforeUnloadConfirmPanel) {
3375         document-&gt;addConsoleMessage(MessageSource::JS, MessageLevel::Error, &quot;Blocked attempt to show multiple beforeunload confirmation dialogs for the same navigation.&quot;_s);
3376         return true;
3377     }
3378 
3379     // We should only display the beforeunload dialog for an iframe if its SecurityOrigin matches all
3380     // ancestor frame SecurityOrigins up through the navigating FrameLoader.
3381     if (frameLoaderBeingNavigated != this) {
3382         Frame* parentFrame = m_frame.tree().parent();
3383         while (parentFrame) {
3384             Document* parentDocument = parentFrame-&gt;document();
3385             if (!parentDocument)
</pre>
<hr />
<pre>
3462 
3463     FrameLoadType type = policyChecker().loadType();
3464     // A new navigation is in progress, so don&#39;t clear the history&#39;s provisional item.
3465     stopAllLoaders(ShouldNotClearProvisionalItem);
3466 
3467     // &lt;rdar://problem/6250856&gt; - In certain circumstances on pages with multiple frames, stopAllLoaders()
3468     // might detach the current FrameLoader, in which case we should bail on this newly defunct load.
3469     if (!m_frame.page()) {
3470         RELEASE_LOG_IF_ALLOWED(&quot;continueLoadAfterNavigationPolicy: can&#39;t continue loading frame because it became defunct (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());
3471         return;
3472     }
3473 
3474     setProvisionalDocumentLoader(m_policyDocumentLoader.get());
3475     m_loadType = type;
3476     setState(FrameStateProvisional);
3477 
3478     setPolicyDocumentLoader(nullptr);
3479 
3480     if (isBackForwardLoadType(type)) {
3481         auto&amp; diagnosticLoggingClient = m_frame.page()-&gt;diagnosticLoggingClient();
<span class="line-modified">3482         if (history().provisionalItem() &amp;&amp; history().provisionalItem()-&gt;isInPageCache()) {</span>
3483             diagnosticLoggingClient.logDiagnosticMessageWithResult(DiagnosticLoggingKeys::pageCacheKey(), DiagnosticLoggingKeys::retrievalKey(), DiagnosticLoggingResultPass, ShouldSample::Yes);
3484             loadProvisionalItemFromCachedPage();
3485             RELEASE_LOG_IF_ALLOWED(&quot;continueLoadAfterNavigationPolicy: can&#39;t continue loading frame because it will be loaded from cache (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());
3486             return;
3487         }
3488         diagnosticLoggingClient.logDiagnosticMessageWithResult(DiagnosticLoggingKeys::pageCacheKey(), DiagnosticLoggingKeys::retrievalKey(), DiagnosticLoggingResultFail, ShouldSample::Yes);
3489     }
3490 
3491     CompletionHandler&lt;void()&gt; completionHandler = [this, protectedFrame = makeRef(m_frame)] () mutable {
3492         if (!m_provisionalDocumentLoader) {
3493             RELEASE_LOG_IF_ALLOWED(&quot;continueLoadAfterNavigationPolicy completionHandler: Frame load canceled #1 (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());
3494             return;
3495         }
3496 
3497         prepareForLoadStart();
3498 
3499         // The load might be cancelled inside of prepareForLoadStart(), nulling out the m_provisionalDocumentLoader,
3500         // so we need to null check it again.
3501         if (!m_provisionalDocumentLoader) {
3502             RELEASE_LOG_IF_ALLOWED(&quot;prepareForLoadStart completionHandler: Frame load canceled #2 (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());
</pre>
<hr />
<pre>
3671 
3672 bool FrameLoader::shouldTreatURLAsSameAsCurrent(const URL&amp; url) const
3673 {
3674     if (!history().currentItem())
3675         return false;
3676     return url == history().currentItem()-&gt;url() || url == history().currentItem()-&gt;originalURL();
3677 }
3678 
3679 bool FrameLoader::shouldTreatURLAsSrcdocDocument(const URL&amp; url) const
3680 {
3681     if (!equalLettersIgnoringASCIICase(url.string(), &quot;about:srcdoc&quot;))
3682         return false;
3683     HTMLFrameOwnerElement* ownerElement = m_frame.ownerElement();
3684     if (!ownerElement)
3685         return false;
3686     if (!ownerElement-&gt;hasTagName(iframeTag))
3687         return false;
3688     return ownerElement-&gt;hasAttributeWithoutSynchronization(srcdocAttr);
3689 }
3690 
<span class="line-modified">3691 Frame* FrameLoader::findFrameForNavigation(const AtomString&amp; name, Document* activeDocument)</span>
3692 {
3693     // FIXME: Eventually all callers should supply the actual activeDocument so we can call canNavigate with the right document.
3694     if (!activeDocument)
3695         activeDocument = m_frame.document();
3696 
3697     auto* frame = m_frame.tree().find(name, activeDocument-&gt;frame() ? *activeDocument-&gt;frame() : m_frame);
3698 
3699     if (!activeDocument-&gt;canNavigate(frame))
3700         return nullptr;
3701 
3702     return frame;
3703 }
3704 
3705 void FrameLoader::loadSameDocumentItem(HistoryItem&amp; item)
3706 {
3707     ASSERT(item.documentSequenceNumber() == history().currentItem()-&gt;documentSequenceNumber());
3708 
3709     Ref&lt;Frame&gt; protect(m_frame);
3710 
3711     // Save user view state to the current history item here since we don&#39;t do a normal load.
3712     // FIXME: Does form state need to be saved here too?
3713     history().saveScrollPositionAndViewStateToItem(history().currentItem());
3714     if (FrameView* view = m_frame.view())
3715         view-&gt;setWasScrolledByUser(false);
3716 
3717     history().setCurrentItem(item);
3718 
3719     // loadInSameDocument() actually changes the URL and notifies load delegates of a &quot;fake&quot; load
3720     loadInSameDocument(item.url(), item.stateObject(), false);
3721 
3722     // Restore user view state from the current history item here since we don&#39;t do a normal load.
3723     history().restoreScrollPositionAndViewState();
3724 }
3725 
3726 // FIXME: This function should really be split into a couple pieces, some of
3727 // which should be methods of HistoryController and some of which should be
3728 // methods of FrameLoader.
<span class="line-modified">3729 void FrameLoader::loadDifferentDocumentItem(HistoryItem&amp; item, HistoryItem* fromItem, FrameLoadType loadType, FormSubmissionCacheLoadPolicy cacheLoadPolicy, ShouldTreatAsContinuingLoad shouldTreatAsContinuingLoad)</span>
3730 {
3731     RELEASE_LOG_IF_ALLOWED(&quot;loadDifferentDocumentItem: frame load started (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());
3732 
3733     Ref&lt;Frame&gt; protectedFrame(m_frame);
3734 
3735     // History items should not be reported to the parent.
3736     m_shouldReportResourceTimingToParentFrame = false;
3737 
3738     // Remember this item so we can traverse any child items as child frames load
3739     history().setProvisionalItem(&amp;item);
3740 
3741     auto initiatedByMainFrame = InitiatedByMainFrame::Unknown;
3742 
3743     SetForScope&lt;LoadContinuingState&gt; continuingLoadGuard(m_currentLoadContinuingState, shouldTreatAsContinuingLoad == ShouldTreatAsContinuingLoad::Yes ? LoadContinuingState::ContinuingWithHistoryItem : LoadContinuingState::NotContinuing);
3744 
3745     if (CachedPage* cachedPage = PageCache::singleton().get(item, m_frame.page())) {
3746         auto documentLoader = cachedPage-&gt;documentLoader();
3747         m_client.updateCachedDocumentLoader(*documentLoader);
3748 
3749         auto action = NavigationAction { *m_frame.document(), documentLoader-&gt;request(), initiatedByMainFrame, loadType, false };
3750         action.setTargetBackForwardItem(item);
<span class="line-added">3751         action.setSourceBackForwardItem(fromItem);</span>
3752         documentLoader-&gt;setTriggeringAction(WTFMove(action));
3753 
3754         documentLoader-&gt;setLastCheckedRequest(ResourceRequest());
3755         loadWithDocumentLoader(documentLoader, loadType, { }, AllowNavigationToInvalidURL::Yes, shouldTreatAsContinuingLoad);
3756         return;
3757     }
3758 
3759     URL itemURL = item.url();
3760     URL itemOriginalURL = item.originalURL();
3761     URL currentURL;
3762     if (documentLoader())
3763         currentURL = documentLoader()-&gt;url();
3764     RefPtr&lt;FormData&gt; formData = item.formData();
3765 
3766     ResourceRequest request(itemURL);
3767 
3768     if (!item.referrer().isNull())
3769         request.setHTTPReferrer(item.referrer());
3770 
3771     ShouldOpenExternalURLsPolicy shouldOpenExternalURLsPolicy = shouldOpenExternalURLsPolicyToApply(m_frame, initiatedByMainFrame, item.shouldOpenExternalURLsPolicy());
3772     bool isFormSubmission = false;
3773     Event* event = nullptr;
3774 
3775     // If this was a repost that failed the page cache, we might try to repost the form.
3776     NavigationAction action;
3777     if (formData) {


3778         request.setHTTPMethod(&quot;POST&quot;);
3779         request.setHTTPBody(WTFMove(formData));
3780         request.setHTTPContentType(item.formContentType());
3781         auto securityOrigin = SecurityOrigin::createFromString(item.referrer());
3782         addHTTPOriginIfNeeded(request, securityOrigin-&gt;toString());
3783         addHTTPUpgradeInsecureRequestsIfNeeded(request);
3784 
3785         // Make sure to add extra fields to the request after the Origin header is added for the FormData case.
3786         // See https://bugs.webkit.org/show_bug.cgi?id=22194 for more discussion.
3787         addExtraFieldsToRequest(request, loadType, true);
3788 
3789         // FIXME: Slight hack to test if the NSURL cache contains the page we&#39;re going to.
3790         // We want to know this before talking to the policy delegate, since it affects whether
3791         // we show the DoYouReallyWantToRepost nag.
3792         //
3793         // This trick has a small bug (3123893) where we might find a cache hit, but then
3794         // have the item vanish when we try to use it in the ensuing nav.  This should be
3795         // extremely rare, but in that case the user will get an error on the navigation.
3796 
3797         if (cacheLoadPolicy == MayAttemptCacheOnlyLoadForFormSubmissionItem) {
</pre>
<hr />
<pre>
3820                 request.setCachePolicy(ResourceRequestCachePolicy::ReturnCacheDataElseLoad);
3821             item.setWasRestoredFromSession(false);
3822             break;
3823         }
3824         case FrameLoadType::Standard:
3825         case FrameLoadType::RedirectWithLockedBackForwardList:
3826             break;
3827         case FrameLoadType::Same:
3828         case FrameLoadType::Replace:
3829             ASSERT_NOT_REACHED();
3830         }
3831 
3832         addExtraFieldsToRequest(request, loadType, true);
3833 
3834         ResourceRequest requestForOriginalURL(request);
3835         requestForOriginalURL.setURL(itemOriginalURL);
3836         action = { *m_frame.document(), requestForOriginalURL, initiatedByMainFrame, loadType, isFormSubmission, event, shouldOpenExternalURLsPolicy };
3837     }
3838 
3839     action.setTargetBackForwardItem(item);
<span class="line-added">3840     action.setSourceBackForwardItem(fromItem);</span>
3841 
3842     loadWithNavigationAction(request, WTFMove(action), LockHistory::No, loadType, { }, AllowNavigationToInvalidURL::Yes);
3843 }
3844 
3845 // Loads content into this frame, as specified by history item
<span class="line-modified">3846 void FrameLoader::loadItem(HistoryItem&amp; item, HistoryItem* fromItem, FrameLoadType loadType, ShouldTreatAsContinuingLoad shouldTreatAsContinuingLoad)</span>
3847 {
3848     m_requestedHistoryItem = &amp;item;
3849     HistoryItem* currentItem = history().currentItem();
3850     bool sameDocumentNavigation = currentItem &amp;&amp; item.shouldDoSameDocumentNavigationTo(*currentItem);
3851 
3852     if (sameDocumentNavigation)
3853         loadSameDocumentItem(item);
3854     else
<span class="line-modified">3855         loadDifferentDocumentItem(item, fromItem, loadType, MayAttemptCacheOnlyLoadForFormSubmissionItem, shouldTreatAsContinuingLoad);</span>
3856 }
3857 
3858 void FrameLoader::retryAfterFailedCacheOnlyMainResourceLoad()
3859 {
3860     ASSERT(m_state == FrameStateProvisional);
3861     ASSERT(!m_loadingFromCachedPage);
3862     ASSERT(history().provisionalItem());
3863     ASSERT(history().provisionalItem()-&gt;formData());
3864     ASSERT(history().provisionalItem() == m_requestedHistoryItem.get());
3865 
3866     FrameLoadType loadType = m_loadType;
<span class="line-modified">3867     HistoryItem* item = history().provisionalItem();</span>
3868 
3869     stopAllLoaders(ShouldNotClearProvisionalItem);
<span class="line-modified">3870     if (item)</span>
<span class="line-added">3871         loadDifferentDocumentItem(*item, history().currentItem(), loadType, MayNotAttemptCacheOnlyLoadForFormSubmissionItem, ShouldTreatAsContinuingLoad::No);</span>
<span class="line-added">3872     else {</span>
<span class="line-added">3873         ASSERT_NOT_REACHED();</span>
<span class="line-added">3874         RELEASE_LOG_ERROR(ResourceLoading, &quot;Retrying load after failed cache-only main resource load failed because there is no provisional history item.&quot;);</span>
<span class="line-added">3875     }</span>
3876 }
3877 
3878 ResourceError FrameLoader::cancelledError(const ResourceRequest&amp; request) const
3879 {
3880     ResourceError error = m_client.cancelledError(request);
3881     error.setType(ResourceError::Type::Cancellation);
3882     return error;
3883 }
3884 
3885 ResourceError FrameLoader::blockedByContentBlockerError(const ResourceRequest&amp; request) const
3886 {
3887     return m_client.blockedByContentBlockerError(request);
3888 }
3889 
3890 ResourceError FrameLoader::blockedError(const ResourceRequest&amp; request) const
3891 {
3892     ResourceError error = m_client.blockedError(request);
3893     error.setType(ResourceError::Type::Cancellation);
3894     return error;
3895 }
</pre>
</td>
</tr>
</table>
<center><a href="FrameLoadRequest.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="FrameLoader.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>