<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/accessibility/atk/WebKitAccessible.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2008 Nuanti Ltd.
   3  * Copyright (C) 2009 Jan Alonzo
   4  * Copyright (C) 2009, 2010, 2011, 2012, 2019 Igalia S.L.
   5  * Copyright (C) 2013 Samsung Electronics
   6  *
   7  * Portions from Mozilla a11y, copyright as follows:
   8  *
   9  * The Original Code is mozilla.org code.
  10  *
  11  * The Initial Developer of the Original Code is
  12  * Sun Microsystems, Inc.
  13  * Portions created by the Initial Developer are Copyright (C) 2002
  14  * the Initial Developer. All Rights Reserved.
  15  *
  16  * This library is free software; you can redistribute it and/or
  17  * modify it under the terms of the GNU Library General Public
  18  * License as published by the Free Software Foundation; either
  19  * version 2 of the License, or (at your option) any later version.
  20  *
  21  * This library is distributed in the hope that it will be useful,
  22  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  23  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  24  * Library General Public License for more details.
  25  *
  26  * You should have received a copy of the GNU Library General Public License
  27  * along with this library; see the file COPYING.LIB.  If not, write to
  28  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  29  * Boston, MA 02110-1301, USA.
  30  */
  31 
  32 #include &quot;config.h&quot;
  33 #include &quot;WebKitAccessible.h&quot;
  34 
<a name="1" id="anc1"></a><span class="line-modified">  35 #if ENABLE(ACCESSIBILITY)</span>
  36 
  37 #include &quot;AXObjectCache.h&quot;
  38 #include &quot;AccessibilityList.h&quot;
  39 #include &quot;AccessibilityListBoxOption.h&quot;
  40 #include &quot;AccessibilityTable.h&quot;
  41 #include &quot;AccessibilityTableCell.h&quot;
  42 #include &quot;AccessibilityTableRow.h&quot;
  43 #include &quot;Document.h&quot;
  44 #include &quot;Editing.h&quot;
  45 #include &quot;Frame.h&quot;
  46 #include &quot;FrameView.h&quot;
  47 #include &quot;HTMLNames.h&quot;
  48 #include &quot;HTMLTableElement.h&quot;
  49 #include &quot;HostWindow.h&quot;
  50 #include &quot;RenderAncestorIterator.h&quot;
  51 #include &quot;RenderBlock.h&quot;
  52 #include &quot;RenderObject.h&quot;
  53 #include &quot;SVGElement.h&quot;
  54 #include &quot;Settings.h&quot;
  55 #include &quot;TextIterator.h&quot;
  56 #include &quot;VisibleUnits.h&quot;
  57 #include &quot;WebKitAccessibleHyperlink.h&quot;
  58 #include &quot;WebKitAccessibleInterfaceAction.h&quot;
  59 #include &quot;WebKitAccessibleInterfaceComponent.h&quot;
  60 #include &quot;WebKitAccessibleInterfaceDocument.h&quot;
  61 #include &quot;WebKitAccessibleInterfaceEditableText.h&quot;
  62 #include &quot;WebKitAccessibleInterfaceHyperlinkImpl.h&quot;
  63 #include &quot;WebKitAccessibleInterfaceHypertext.h&quot;
  64 #include &quot;WebKitAccessibleInterfaceImage.h&quot;
  65 #include &quot;WebKitAccessibleInterfaceSelection.h&quot;
  66 #include &quot;WebKitAccessibleInterfaceTable.h&quot;
  67 #include &quot;WebKitAccessibleInterfaceTableCell.h&quot;
  68 #include &quot;WebKitAccessibleInterfaceText.h&quot;
  69 #include &quot;WebKitAccessibleInterfaceValue.h&quot;
  70 #include &quot;WebKitAccessibleUtil.h&quot;
  71 #include &lt;glib/gprintf.h&gt;
  72 #include &lt;wtf/glib/WTFGType.h&gt;
  73 #include &lt;wtf/text/CString.h&gt;
  74 
  75 using namespace WebCore;
  76 
  77 struct _WebKitAccessiblePrivate {
  78     AccessibilityObject* object;
  79 
  80     // Cached data for AtkObject.
  81     CString accessibleName;
  82     CString accessibleDescription;
  83 
  84     // Cached data for AtkAction.
  85     CString actionName;
  86     CString actionKeyBinding;
  87 
  88     // Cached data for AtkDocument.
  89     CString documentLocale;
  90     CString documentType;
  91     CString documentEncoding;
  92     CString documentURI;
  93 
  94     // Cached data for AtkImage.
  95     CString imageDescription;
  96 };
  97 
  98 WEBKIT_DEFINE_TYPE(WebKitAccessible, webkit_accessible, ATK_TYPE_OBJECT)
  99 
 100 static AccessibilityObject* fallbackObject()
 101 {
 102     static AccessibilityObject* object = &amp;AccessibilityListBoxOption::create().leakRef();
 103     return object;
 104 }
 105 
 106 static const gchar* webkitAccessibleGetName(AtkObject* object)
 107 {
 108     auto* accessible = WEBKIT_ACCESSIBLE(object);
 109     returnValIfWebKitAccessibleIsInvalid(accessible, nullptr);
 110 
 111     Vector&lt;AccessibilityText&gt; textOrder;
 112     accessible-&gt;priv-&gt;object-&gt;accessibilityText(textOrder);
 113 
 114     for (const auto&amp; text : textOrder) {
 115         // FIXME: This check is here because AccessibilityNodeObject::titleElementText()
 116         // appends an empty String for the LabelByElementText source when there is a
 117         // titleUIElement(). Removing this check makes some fieldsets lose their name.
 118         if (text.text.isEmpty())
 119             continue;
 120 
 121         // WebCore Accessibility should provide us with the text alternative computation
 122         // in the order defined by that spec. So take the first thing that our platform
 123         // does not expose via the AtkObject description.
 124         if (text.textSource != AccessibilityTextSource::Help &amp;&amp; text.textSource != AccessibilityTextSource::Summary)
 125             return webkitAccessibleCacheAndReturnAtkProperty(accessible, AtkCachedAccessibleName, text.text.utf8());
 126     }
 127 
 128     return webkitAccessibleCacheAndReturnAtkProperty(accessible, AtkCachedAccessibleName, &quot;&quot;);
 129 }
 130 
 131 static const gchar* webkitAccessibleGetDescription(AtkObject* object)
 132 {
 133     auto* accessible = WEBKIT_ACCESSIBLE(object);
 134     returnValIfWebKitAccessibleIsInvalid(accessible, nullptr);
 135 
 136     Vector&lt;AccessibilityText&gt; textOrder;
 137     accessible-&gt;priv-&gt;object-&gt;accessibilityText(textOrder);
 138 
 139     bool nameTextAvailable = false;
 140     for (const auto&amp; text : textOrder) {
 141         // WebCore Accessibility should provide us with the text alternative computation
 142         // in the order defined by that spec. So take the first thing that our platform
 143         // does not expose via the AtkObject name.
 144         if (text.textSource == AccessibilityTextSource::Help || text.textSource == AccessibilityTextSource::Summary)
 145             return webkitAccessibleCacheAndReturnAtkProperty(accessible, AtkCachedAccessibleDescription, text.text.utf8());
 146 
 147         // If there is no other text alternative, the title tag contents will have been
 148         // used for the AtkObject name. We don&#39;t want to duplicate it here.
 149         if (text.textSource == AccessibilityTextSource::TitleTag &amp;&amp; nameTextAvailable)
 150             return webkitAccessibleCacheAndReturnAtkProperty(accessible, AtkCachedAccessibleDescription, text.text.utf8());
 151 
 152         nameTextAvailable = true;
 153     }
 154 
 155     return webkitAccessibleCacheAndReturnAtkProperty(accessible, AtkCachedAccessibleDescription, &quot;&quot;);
 156 }
 157 
 158 static void removeAtkRelationByType(AtkRelationSet* relationSet, AtkRelationType relationType)
 159 {
 160     int count = atk_relation_set_get_n_relations(relationSet);
 161     for (int i = 0; i &lt; count; i++) {
 162         AtkRelation* relation = atk_relation_set_get_relation(relationSet, i);
 163         if (atk_relation_get_relation_type(relation) == relationType) {
 164             atk_relation_set_remove(relationSet, relation);
 165             break;
 166         }
 167     }
 168 }
 169 
 170 static void setAtkRelationSetFromCoreObject(AccessibilityObject* coreObject, AtkRelationSet* relationSet)
 171 {
 172     // Elements with aria-labelledby should have the labelled-by relation as per the ARIA AAM spec.
 173     // Controls with a label element and fieldsets with a legend element should also use this relation
 174     // as per the HTML AAM spec. The reciprocal label-for relation should also be used.
 175     removeAtkRelationByType(relationSet, ATK_RELATION_LABELLED_BY);
 176     removeAtkRelationByType(relationSet, ATK_RELATION_LABEL_FOR);
 177     if (coreObject-&gt;isControl()) {
 178         if (AccessibilityObject* label = coreObject-&gt;correspondingLabelForControlElement())
 179             atk_relation_set_add_relation_by_type(relationSet, ATK_RELATION_LABELLED_BY, ATK_OBJECT(label-&gt;wrapper()));
 180     } else if (coreObject-&gt;isFieldset()) {
 181         if (AccessibilityObject* label = coreObject-&gt;titleUIElement())
 182             atk_relation_set_add_relation_by_type(relationSet, ATK_RELATION_LABELLED_BY, ATK_OBJECT(label-&gt;wrapper()));
 183     } else if (coreObject-&gt;roleValue() == AccessibilityRole::Legend) {
 184         if (RenderBlock* renderFieldset = ancestorsOfType&lt;RenderBlock&gt;(*coreObject-&gt;renderer()).first()) {
 185             if (renderFieldset-&gt;isFieldset()) {
 186                 AccessibilityObject* fieldset = coreObject-&gt;axObjectCache()-&gt;getOrCreate(renderFieldset);
 187                 atk_relation_set_add_relation_by_type(relationSet, ATK_RELATION_LABEL_FOR, ATK_OBJECT(fieldset-&gt;wrapper()));
 188             }
 189         }
 190     } else if (AccessibilityObject* control = coreObject-&gt;correspondingControlForLabelElement())
 191         atk_relation_set_add_relation_by_type(relationSet, ATK_RELATION_LABEL_FOR, ATK_OBJECT(control-&gt;wrapper()));
 192     else {
 193         AccessibilityObject::AccessibilityChildrenVector ariaLabelledByElements;
 194         coreObject-&gt;ariaLabelledByElements(ariaLabelledByElements);
 195         for (const auto&amp; accessibilityObject : ariaLabelledByElements)
 196             atk_relation_set_add_relation_by_type(relationSet, ATK_RELATION_LABELLED_BY, ATK_OBJECT(accessibilityObject-&gt;wrapper()));
 197     }
 198 
 199     // Elements referenced by aria-labelledby should have the label-for relation as per the ARIA AAM spec.
 200     AccessibilityObject::AccessibilityChildrenVector labels;
 201     coreObject-&gt;ariaLabelledByReferencingElements(labels);
 202     for (const auto&amp; accessibilityObject : labels)
 203         atk_relation_set_add_relation_by_type(relationSet, ATK_RELATION_LABEL_FOR, ATK_OBJECT(accessibilityObject-&gt;wrapper()));
 204 
 205     // Elements with aria-flowto should have the flows-to relation as per the ARIA AAM spec.
 206     removeAtkRelationByType(relationSet, ATK_RELATION_FLOWS_TO);
 207     AccessibilityObject::AccessibilityChildrenVector ariaFlowToElements;
 208     coreObject-&gt;ariaFlowToElements(ariaFlowToElements);
 209     for (const auto&amp; accessibilityObject : ariaFlowToElements)
 210         atk_relation_set_add_relation_by_type(relationSet, ATK_RELATION_FLOWS_TO, ATK_OBJECT(accessibilityObject-&gt;wrapper()));
 211 
 212     // Elements referenced by aria-flowto should have the flows-from relation as per the ARIA AAM spec.
 213     removeAtkRelationByType(relationSet, ATK_RELATION_FLOWS_FROM);
 214     AccessibilityObject::AccessibilityChildrenVector flowFrom;
 215     coreObject-&gt;ariaFlowToReferencingElements(flowFrom);
 216     for (const auto&amp; accessibilityObject : flowFrom)
 217         atk_relation_set_add_relation_by_type(relationSet, ATK_RELATION_FLOWS_FROM, ATK_OBJECT(accessibilityObject-&gt;wrapper()));
 218 
 219     // Elements with aria-describedby should have the described-by relation as per the ARIA AAM spec.
 220     removeAtkRelationByType(relationSet, ATK_RELATION_DESCRIBED_BY);
 221     AccessibilityObject::AccessibilityChildrenVector ariaDescribedByElements;
 222     coreObject-&gt;ariaDescribedByElements(ariaDescribedByElements);
 223     for (const auto&amp; accessibilityObject : ariaDescribedByElements)
 224         atk_relation_set_add_relation_by_type(relationSet, ATK_RELATION_DESCRIBED_BY, ATK_OBJECT(accessibilityObject-&gt;wrapper()));
 225 
 226     // Elements referenced by aria-describedby should have the description-for relation as per the ARIA AAM spec.
 227     removeAtkRelationByType(relationSet, ATK_RELATION_DESCRIPTION_FOR);
 228     AccessibilityObject::AccessibilityChildrenVector describers;
 229     coreObject-&gt;ariaDescribedByReferencingElements(describers);
 230     for (const auto&amp; accessibilityObject : describers)
 231         atk_relation_set_add_relation_by_type(relationSet, ATK_RELATION_DESCRIPTION_FOR, ATK_OBJECT(accessibilityObject-&gt;wrapper()));
 232 
 233     // Elements with aria-controls should have the controller-for relation as per the ARIA AAM spec.
 234     removeAtkRelationByType(relationSet, ATK_RELATION_CONTROLLER_FOR);
 235     AccessibilityObject::AccessibilityChildrenVector ariaControls;
 236     coreObject-&gt;ariaControlsElements(ariaControls);
 237     for (const auto&amp; accessibilityObject : ariaControls)
 238         atk_relation_set_add_relation_by_type(relationSet, ATK_RELATION_CONTROLLER_FOR, ATK_OBJECT(accessibilityObject-&gt;wrapper()));
 239 
 240     // Elements referenced by aria-controls should have the controlled-by relation as per the ARIA AAM spec.
 241     removeAtkRelationByType(relationSet, ATK_RELATION_CONTROLLED_BY);
 242     AccessibilityObject::AccessibilityChildrenVector controllers;
 243     coreObject-&gt;ariaControlsReferencingElements(controllers);
 244     for (const auto&amp; accessibilityObject : controllers)
 245         atk_relation_set_add_relation_by_type(relationSet, ATK_RELATION_CONTROLLED_BY, ATK_OBJECT(accessibilityObject-&gt;wrapper()));
 246 
 247     // Elements with aria-owns should have the node-parent-of relation as per the ARIA AAM spec.
 248     removeAtkRelationByType(relationSet, ATK_RELATION_NODE_PARENT_OF);
 249     AccessibilityObject::AccessibilityChildrenVector ariaOwns;
 250     coreObject-&gt;ariaOwnsElements(ariaOwns);
 251     for (const auto&amp; accessibilityObject : ariaOwns)
 252         atk_relation_set_add_relation_by_type(relationSet, ATK_RELATION_NODE_PARENT_OF, ATK_OBJECT(accessibilityObject-&gt;wrapper()));
 253 
 254     // Elements referenced by aria-owns should have the node-child-of relation as per the ARIA AAM spec.
 255     removeAtkRelationByType(relationSet, ATK_RELATION_NODE_CHILD_OF);
 256     AccessibilityObject::AccessibilityChildrenVector owners;
 257     coreObject-&gt;ariaOwnsReferencingElements(owners);
 258     for (const auto&amp; accessibilityObject : owners)
 259         atk_relation_set_add_relation_by_type(relationSet, ATK_RELATION_NODE_CHILD_OF, ATK_OBJECT(accessibilityObject-&gt;wrapper()));
 260 
 261 #if ATK_CHECK_VERSION(2, 25, 2)
 262     // Elements with aria-details should have the details relation as per the ARIA AAM spec.
 263     removeAtkRelationByType(relationSet, ATK_RELATION_DETAILS);
 264     AccessibilityObject::AccessibilityChildrenVector ariaDetails;
 265     coreObject-&gt;ariaDetailsElements(ariaDetails);
 266     for (const auto&amp; accessibilityObject : ariaDetails)
 267         atk_relation_set_add_relation_by_type(relationSet, ATK_RELATION_DETAILS, ATK_OBJECT(accessibilityObject-&gt;wrapper()));
 268 
 269     // Elements referenced by aria-details should have the details-for relation as per the ARIA AAM spec.
 270     removeAtkRelationByType(relationSet, ATK_RELATION_DETAILS_FOR);
 271     AccessibilityObject::AccessibilityChildrenVector details;
 272     coreObject-&gt;ariaDetailsReferencingElements(details);
 273     for (const auto&amp; accessibilityObject : details)
 274         atk_relation_set_add_relation_by_type(relationSet, ATK_RELATION_DETAILS_FOR, ATK_OBJECT(accessibilityObject-&gt;wrapper()));
 275 
 276     // Elements with aria-errormessage should have the error-message relation as per the ARIA AAM spec.
 277     removeAtkRelationByType(relationSet, ATK_RELATION_ERROR_MESSAGE);
 278     AccessibilityObject::AccessibilityChildrenVector ariaErrorMessage;
 279     coreObject-&gt;ariaErrorMessageElements(ariaErrorMessage);
 280     for (const auto&amp; accessibilityObject : ariaErrorMessage)
 281         atk_relation_set_add_relation_by_type(relationSet, ATK_RELATION_ERROR_MESSAGE, ATK_OBJECT(accessibilityObject-&gt;wrapper()));
 282 
 283     // Elements referenced by aria-errormessage should have the error-for relation as per the ARIA AAM spec.
 284     removeAtkRelationByType(relationSet, ATK_RELATION_ERROR_FOR);
 285     AccessibilityObject::AccessibilityChildrenVector errors;
 286     coreObject-&gt;ariaErrorMessageReferencingElements(errors);
 287     for (const auto&amp; accessibilityObject : errors)
 288         atk_relation_set_add_relation_by_type(relationSet, ATK_RELATION_ERROR_FOR, ATK_OBJECT(accessibilityObject-&gt;wrapper()));
 289 #endif
 290 }
 291 
 292 static bool isRootObject(AccessibilityObject* coreObject)
 293 {
 294     // The root accessible object in WebCore is always an object with
 295     // the ScrolledArea role with one child with the WebArea role.
 296     if (!coreObject || !coreObject-&gt;isScrollView())
 297         return false;
 298 
 299     AccessibilityObject* firstChild = coreObject-&gt;firstChild();
 300     return firstChild &amp;&amp; firstChild-&gt;isWebArea();
 301 }
 302 
 303 static AtkObject* webkitAccessibleGetParent(AtkObject* object)
 304 {
 305     auto* accessible = WEBKIT_ACCESSIBLE(object);
 306     returnValIfWebKitAccessibleIsInvalid(accessible, nullptr);
 307 
 308     // Check first if the parent has been already set.
 309     AtkObject* accessibleParent = ATK_OBJECT_CLASS(webkit_accessible_parent_class)-&gt;get_parent(object);
 310     if (accessibleParent)
 311         return accessibleParent;
 312 
 313     // Parent not set yet, so try to find it in the hierarchy.
 314     auto* coreObject = accessible-&gt;priv-&gt;object;
 315     auto* coreParent = coreObject-&gt;parentObjectUnignored();
 316     if (!coreParent &amp;&amp; isRootObject(coreObject)) {
 317         // The top level object claims to not have a parent. This makes it
 318         // impossible for assistive technologies to ascend the accessible
 319         // hierarchy all the way to the application. (Bug 30489)
 320         if (!coreObject-&gt;document())
 321             return nullptr;
 322     }
 323 
 324     return coreParent ? ATK_OBJECT(coreParent-&gt;wrapper()) : nullptr;
 325 }
 326 
 327 static gint webkitAccessibleGetNChildren(AtkObject* object)
 328 {
 329     auto* accessible = WEBKIT_ACCESSIBLE(object);
 330     returnValIfWebKitAccessibleIsInvalid(accessible, 0);
 331 
 332     return accessible-&gt;priv-&gt;object-&gt;children().size();
 333 }
 334 
 335 static AtkObject* webkitAccessibleRefChild(AtkObject* object, gint index)
 336 {
 337     auto* accessible = WEBKIT_ACCESSIBLE(object);
 338     returnValIfWebKitAccessibleIsInvalid(accessible, nullptr);
 339 
 340     if (index &lt; 0)
 341         return nullptr;
 342 
 343     const auto&amp; children = accessible-&gt;priv-&gt;object-&gt;children();
 344     if (static_cast&lt;size_t&gt;(index) &gt;= children.size())
 345         return nullptr;
 346 
 347     auto&amp; coreChild = children[index];
 348     if (!coreChild)
 349         return nullptr;
 350 
 351     auto* child = coreChild-&gt;wrapper();
 352     if (!child)
 353         return nullptr;
 354 
 355     atk_object_set_parent(ATK_OBJECT(child), object);
 356     return ATK_OBJECT(g_object_ref(child));
 357 }
 358 
 359 static gint webkitAccessibleGetIndexInParent(AtkObject* object)
 360 {
 361     auto* accessible = WEBKIT_ACCESSIBLE(object);
 362     returnValIfWebKitAccessibleIsInvalid(accessible, -1);
 363 
 364     auto* coreObject = accessible-&gt;priv-&gt;object;
 365     auto* parent = coreObject-&gt;parentObjectUnignored();
 366     if (!parent &amp;&amp; isRootObject(coreObject)) {
 367         if (!coreObject-&gt;document())
 368             return -1;
 369 
 370         auto* atkParent = parent ? ATK_OBJECT(parent-&gt;wrapper()) : nullptr;
 371         if (!atkParent)
 372             return -1;
 373 
 374         unsigned count = atk_object_get_n_accessible_children(atkParent);
 375         for (unsigned i = 0; i &lt; count; ++i) {
 376             GRefPtr&lt;AtkObject&gt; child = adoptGRef(atk_object_ref_accessible_child(atkParent, i));
 377             if (child.get() == object)
 378                 return i;
 379         }
 380     }
 381 
 382     if (!parent)
 383         return -1;
 384 
 385     size_t index = parent-&gt;children().find(coreObject);
 386     return (index == WTF::notFound) ? -1 : index;
 387 }
 388 
 389 static AtkAttributeSet* webkitAccessibleGetAttributes(AtkObject* object)
 390 {
 391     auto* accessible = WEBKIT_ACCESSIBLE(object);
 392     returnValIfWebKitAccessibleIsInvalid(accessible, nullptr);
 393 
 394     AtkAttributeSet* attributeSet = nullptr;
 395 #if PLATFORM(GTK)
 396     attributeSet = addToAtkAttributeSet(attributeSet, &quot;toolkit&quot;, &quot;WebKitGtk&quot;);
<a name="2" id="anc2"></a><span class="line-added"> 397 #elif PLATFORM(WPE)</span>
<span class="line-added"> 398     attributeSet = addToAtkAttributeSet(attributeSet, &quot;toolkit&quot;, &quot;WPEWebKit&quot;);</span>
 399 #endif
 400 
 401     auto* coreObject = accessible-&gt;priv-&gt;object;
 402 
 403     // Hack needed for WebKit2 tests because obtaining an element by its ID
 404     // cannot be done from the UIProcess. Assistive technologies have no need
 405     // for this information.
 406     Element* element = coreObject-&gt;element() ? coreObject-&gt;element() : coreObject-&gt;actionElement();
 407     if (element) {
 408         String tagName = element-&gt;tagName();
 409         if (!tagName.isEmpty())
 410             attributeSet = addToAtkAttributeSet(attributeSet, &quot;tag&quot;, tagName.convertToASCIILowercase().utf8().data());
 411         String id = element-&gt;getIdAttribute().string();
 412         if (!id.isEmpty())
 413             attributeSet = addToAtkAttributeSet(attributeSet, &quot;html-id&quot;, id.utf8().data());
 414     }
 415 
 416     int level = coreObject-&gt;isHeading() ? coreObject-&gt;headingLevel() : coreObject-&gt;hierarchicalLevel();
 417     if (level) {
 418         String value = String::number(level);
 419         attributeSet = addToAtkAttributeSet(attributeSet, &quot;level&quot;, value.utf8().data());
 420     }
 421 
 422     if (coreObject-&gt;roleValue() == AccessibilityRole::MathElement) {
 423         if (coreObject-&gt;isMathMultiscriptObject(AccessibilityMathMultiscriptObjectType::PreSuperscript) || coreObject-&gt;isMathMultiscriptObject(AccessibilityMathMultiscriptObjectType::PreSubscript))
 424             attributeSet = addToAtkAttributeSet(attributeSet, &quot;multiscript-type&quot;, &quot;pre&quot;);
 425         else if (coreObject-&gt;isMathMultiscriptObject(AccessibilityMathMultiscriptObjectType::PostSuperscript) || coreObject-&gt;isMathMultiscriptObject(AccessibilityMathMultiscriptObjectType::PostSubscript))
 426             attributeSet = addToAtkAttributeSet(attributeSet, &quot;multiscript-type&quot;, &quot;post&quot;);
 427     }
 428 
 429     if (is&lt;AccessibilityTable&gt;(*coreObject) &amp;&amp; downcast&lt;AccessibilityTable&gt;(*coreObject).isExposableThroughAccessibility()) {
 430         auto&amp; table = downcast&lt;AccessibilityTable&gt;(*coreObject);
 431         int rowCount = table.axRowCount();
 432         if (rowCount)
 433             attributeSet = addToAtkAttributeSet(attributeSet, &quot;rowcount&quot;, String::number(rowCount).utf8().data());
 434 
 435         int columnCount = table.axColumnCount();
 436         if (columnCount)
 437             attributeSet = addToAtkAttributeSet(attributeSet, &quot;colcount&quot;, String::number(columnCount).utf8().data());
 438     } else if (is&lt;AccessibilityTableRow&gt;(*coreObject)) {
 439         auto&amp; row = downcast&lt;AccessibilityTableRow&gt;(*coreObject);
 440         int rowIndex = row.axRowIndex();
 441         if (rowIndex != -1)
 442             attributeSet = addToAtkAttributeSet(attributeSet, &quot;rowindex&quot;, String::number(rowIndex).utf8().data());
 443     } else if (is&lt;AccessibilityTableCell&gt;(*coreObject)) {
 444         auto&amp; cell = downcast&lt;AccessibilityTableCell&gt;(*coreObject);
 445         int rowIndex = cell.axRowIndex();
 446         if (rowIndex != -1)
 447             attributeSet = addToAtkAttributeSet(attributeSet, &quot;rowindex&quot;, String::number(rowIndex).utf8().data());
 448 
 449         int columnIndex = cell.axColumnIndex();
 450         if (columnIndex != -1)
 451             attributeSet = addToAtkAttributeSet(attributeSet, &quot;colindex&quot;, String::number(columnIndex).utf8().data());
 452 
 453         int rowSpan = cell.axRowSpan();
 454         if (rowSpan != -1)
 455             attributeSet = addToAtkAttributeSet(attributeSet, &quot;rowspan&quot;, String::number(rowSpan).utf8().data());
 456 
 457         int columnSpan = cell.axColumnSpan();
 458         if (columnSpan != -1)
 459             attributeSet = addToAtkAttributeSet(attributeSet, &quot;colspan&quot;, String::number(columnSpan).utf8().data());
 460     }
 461 
 462     String placeholder = coreObject-&gt;placeholderValue();
 463     if (!placeholder.isEmpty())
 464         attributeSet = addToAtkAttributeSet(attributeSet, &quot;placeholder-text&quot;, placeholder.utf8().data());
 465 
 466     if (coreObject-&gt;supportsAutoComplete())
 467         attributeSet = addToAtkAttributeSet(attributeSet, &quot;autocomplete&quot;, coreObject-&gt;autoCompleteValue().utf8().data());
 468 
 469     if (coreObject-&gt;supportsHasPopup())
<a name="3" id="anc3"></a><span class="line-modified"> 470         attributeSet = addToAtkAttributeSet(attributeSet, &quot;haspopup&quot;, coreObject-&gt;popupValue().utf8().data());</span>
 471 
 472     if (coreObject-&gt;supportsCurrent())
 473         attributeSet = addToAtkAttributeSet(attributeSet, &quot;current&quot;, coreObject-&gt;currentValue().utf8().data());
 474 
 475     // The Core AAM states that an explicitly-set value should be exposed, including &quot;none&quot;.
 476     if (coreObject-&gt;hasAttribute(HTMLNames::aria_sortAttr)) {
 477         switch (coreObject-&gt;sortDirection()) {
 478         case AccessibilitySortDirection::Invalid:
 479             break;
 480         case AccessibilitySortDirection::Ascending:
 481             attributeSet = addToAtkAttributeSet(attributeSet, &quot;sort&quot;, &quot;ascending&quot;);
 482             break;
 483         case AccessibilitySortDirection::Descending:
 484             attributeSet = addToAtkAttributeSet(attributeSet, &quot;sort&quot;, &quot;descending&quot;);
 485             break;
 486         case AccessibilitySortDirection::Other:
 487             attributeSet = addToAtkAttributeSet(attributeSet, &quot;sort&quot;, &quot;other&quot;);
 488             break;
 489         case AccessibilitySortDirection::None:
 490             attributeSet = addToAtkAttributeSet(attributeSet, &quot;sort&quot;, &quot;none&quot;);
 491         }
 492     }
 493 
 494     if (coreObject-&gt;supportsPosInSet())
 495         attributeSet = addToAtkAttributeSet(attributeSet, &quot;posinset&quot;, String::number(coreObject-&gt;posInSet()).utf8().data());
 496 
 497     if (coreObject-&gt;supportsSetSize())
 498         attributeSet = addToAtkAttributeSet(attributeSet, &quot;setsize&quot;, String::number(coreObject-&gt;setSize()).utf8().data());
 499 
 500     String isReadOnly = coreObject-&gt;readOnlyValue();
 501     if (!isReadOnly.isEmpty())
 502         attributeSet = addToAtkAttributeSet(attributeSet, &quot;readonly&quot;, isReadOnly.utf8().data());
 503 
 504     String valueDescription = coreObject-&gt;valueDescription();
 505     if (!valueDescription.isEmpty())
 506         attributeSet = addToAtkAttributeSet(attributeSet, &quot;valuetext&quot;, valueDescription.utf8().data());
 507 
 508     // According to the W3C Core Accessibility API Mappings 1.1, section 5.4.1 General Rules:
 509     // &quot;User agents must expose the WAI-ARIA role string if the API supports a mechanism to do so.&quot;
 510     // In the case of ATK, the mechanism to do so is an object attribute pair (xml-roles:&quot;string&quot;).
 511     // We cannot use the computedRoleString for this purpose because it is not limited to elements
 512     // with ARIA roles, and it might not contain the actual ARIA role value (e.g. DPub ARIA).
 513     String roleString = coreObject-&gt;getAttribute(HTMLNames::roleAttr);
 514     if (!roleString.isEmpty())
 515         attributeSet = addToAtkAttributeSet(attributeSet, &quot;xml-roles&quot;, roleString.utf8().data());
 516 
 517     String computedRoleString = coreObject-&gt;computedRoleString();
 518     if (!computedRoleString.isEmpty()) {
 519         attributeSet = addToAtkAttributeSet(attributeSet, &quot;computed-role&quot;, computedRoleString.utf8().data());
 520 
 521         // The HTML AAM maps several elements to ARIA landmark roles. In order for the type of landmark
 522         // to be obtainable in the same fashion as an ARIA landmark, fall back on the computedRoleString.
<a name="4" id="anc4"></a><span class="line-modified"> 523         // We also want to do this for the style-format-group element types so that the type of format</span>
<span class="line-added"> 524         // group it is doesn&#39;t get lost to a generic platform role.</span>
<span class="line-added"> 525         if (coreObject-&gt;ariaRoleAttribute() == AccessibilityRole::Unknown</span>
<span class="line-added"> 526             &amp;&amp; (coreObject-&gt;isLandmark() || coreObject-&gt;isStyleFormatGroup()))</span>
 527             attributeSet = addToAtkAttributeSet(attributeSet, &quot;xml-roles&quot;, computedRoleString.utf8().data());
 528     }
 529 
 530     String roleDescription = coreObject-&gt;roleDescription();
 531     if (!roleDescription.isEmpty())
 532         attributeSet = addToAtkAttributeSet(attributeSet, &quot;roledescription&quot;, roleDescription.utf8().data());
 533 
 534     // We need to expose the live region attributes even if the live region is currently disabled/off.
 535     if (auto liveContainer = coreObject-&gt;liveRegionAncestor(false)) {
 536         String liveStatus = liveContainer-&gt;liveRegionStatus();
 537         String relevant = liveContainer-&gt;liveRegionRelevant();
<a name="5" id="anc5"></a><span class="line-modified"> 538         bool isAtom = liveContainer-&gt;liveRegionAtomic();</span>
 539         String liveRole = roleString.isEmpty() ? computedRoleString : roleString;
 540 
 541         // According to the Core AAM, we need to expose the above properties with &quot;container-&quot; prefixed
 542         // object attributes regardless of whether the container is this object, or an ancestor of it.
 543         attributeSet = addToAtkAttributeSet(attributeSet, &quot;container-live&quot;, liveStatus.utf8().data());
 544         attributeSet = addToAtkAttributeSet(attributeSet, &quot;container-relevant&quot;, relevant.utf8().data());
<a name="6" id="anc6"></a><span class="line-modified"> 545         if (isAtom)</span>
 546             attributeSet = addToAtkAttributeSet(attributeSet, &quot;container-atomic&quot;, &quot;true&quot;);
 547         if (!liveRole.isEmpty())
 548             attributeSet = addToAtkAttributeSet(attributeSet, &quot;container-live-role&quot;, liveRole.utf8().data());
 549 
 550         // According to the Core AAM, if this object is the live region (rather than its descendant),
 551         // we must expose the above properties on the object without a &quot;container-&quot; prefix.
 552         if (liveContainer == coreObject) {
 553             attributeSet = addToAtkAttributeSet(attributeSet, &quot;live&quot;, liveStatus.utf8().data());
 554             attributeSet = addToAtkAttributeSet(attributeSet, &quot;relevant&quot;, relevant.utf8().data());
<a name="7" id="anc7"></a><span class="line-modified"> 555             if (isAtom)</span>
 556                 attributeSet = addToAtkAttributeSet(attributeSet, &quot;atomic&quot;, &quot;true&quot;);
<a name="8" id="anc8"></a><span class="line-modified"> 557         } else if (!isAtom &amp;&amp; coreObject-&gt;liveRegionAtomic())</span>
 558             attributeSet = addToAtkAttributeSet(attributeSet, &quot;atomic&quot;, &quot;true&quot;);
 559     }
 560 
 561     // The Core AAM states the author-provided value should be exposed as-is.
 562     String dropEffect = coreObject-&gt;getAttribute(HTMLNames::aria_dropeffectAttr);
 563     if (!dropEffect.isEmpty())
 564         attributeSet = addToAtkAttributeSet(attributeSet, &quot;dropeffect&quot;, dropEffect.utf8().data());
 565 
 566     if (coreObject-&gt;isARIAGrabbed())
 567         attributeSet = addToAtkAttributeSet(attributeSet, &quot;grabbed&quot;, &quot;true&quot;);
 568     else if (coreObject-&gt;supportsARIADragging())
 569         attributeSet = addToAtkAttributeSet(attributeSet, &quot;grabbed&quot;, &quot;false&quot;);
 570 
 571     // The Core AAM states the author-provided value should be exposed as-is.
<a name="9" id="anc9"></a><span class="line-modified"> 572     const AtomString&amp; keyShortcuts = coreObject-&gt;keyShortcutsValue();</span>
 573     if (!keyShortcuts.isEmpty())
 574         attributeSet = addToAtkAttributeSet(attributeSet, &quot;keyshortcuts&quot;, keyShortcuts.string().utf8().data());
 575 
 576     return attributeSet;
 577 }
 578 
 579 static AtkRole atkRole(AccessibilityObject* coreObject)
 580 {
 581     switch (coreObject-&gt;roleValue()) {
 582     case AccessibilityRole::ApplicationAlert:
 583         return ATK_ROLE_ALERT;
 584     case AccessibilityRole::ApplicationAlertDialog:
 585     case AccessibilityRole::ApplicationDialog:
 586         return ATK_ROLE_DIALOG;
 587     case AccessibilityRole::ApplicationStatus:
 588         return ATK_ROLE_STATUSBAR;
 589     case AccessibilityRole::Unknown:
 590         return ATK_ROLE_UNKNOWN;
 591     case AccessibilityRole::Audio:
<a name="10" id="anc10"></a>
 592         return ATK_ROLE_AUDIO;
<a name="11" id="anc11"></a>
 593     case AccessibilityRole::Video:
<a name="12" id="anc12"></a>
 594         return ATK_ROLE_VIDEO;
<a name="13" id="anc13"></a>

 595     case AccessibilityRole::Button:
 596         return ATK_ROLE_PUSH_BUTTON;
 597     case AccessibilityRole::Switch:
 598     case AccessibilityRole::ToggleButton:
 599         return ATK_ROLE_TOGGLE_BUTTON;
 600     case AccessibilityRole::RadioButton:
 601         return ATK_ROLE_RADIO_BUTTON;
 602     case AccessibilityRole::CheckBox:
 603         return ATK_ROLE_CHECK_BOX;
 604     case AccessibilityRole::Slider:
 605         return ATK_ROLE_SLIDER;
 606     case AccessibilityRole::TabGroup:
 607     case AccessibilityRole::TabList:
 608         return ATK_ROLE_PAGE_TAB_LIST;
 609     case AccessibilityRole::TextField:
 610     case AccessibilityRole::TextArea:
 611     case AccessibilityRole::SearchField:
 612         return ATK_ROLE_ENTRY;
 613     case AccessibilityRole::StaticText:
<a name="14" id="anc14"></a>
 614         return ATK_ROLE_STATIC;
<a name="15" id="anc15"></a>


 615     case AccessibilityRole::Outline:
 616     case AccessibilityRole::Tree:
 617         return ATK_ROLE_TREE;
 618     case AccessibilityRole::TreeItem:
 619         return ATK_ROLE_TREE_ITEM;
 620     case AccessibilityRole::MenuBar:
 621         return ATK_ROLE_MENU_BAR;
 622     case AccessibilityRole::MenuListPopup:
 623     case AccessibilityRole::Menu:
 624         return ATK_ROLE_MENU;
 625     case AccessibilityRole::MenuListOption:
 626     case AccessibilityRole::MenuItem:
 627     case AccessibilityRole::MenuButton:
 628         return ATK_ROLE_MENU_ITEM;
 629     case AccessibilityRole::MenuItemCheckbox:
 630         return ATK_ROLE_CHECK_MENU_ITEM;
 631     case AccessibilityRole::MenuItemRadio:
 632         return ATK_ROLE_RADIO_MENU_ITEM;
 633     case AccessibilityRole::Column:
 634         // return ATK_ROLE_TABLE_COLUMN_HEADER; // Is this right?
 635         return ATK_ROLE_UNKNOWN; // Matches Mozilla
 636     case AccessibilityRole::Row:
 637         return ATK_ROLE_TABLE_ROW;
 638     case AccessibilityRole::Toolbar:
 639         return ATK_ROLE_TOOL_BAR;
<a name="16" id="anc16"></a><span class="line-added"> 640     case AccessibilityRole::Meter:</span>
<span class="line-added"> 641         return ATK_ROLE_LEVEL_BAR;</span>
 642     case AccessibilityRole::BusyIndicator:
<a name="17" id="anc17"></a>
 643     case AccessibilityRole::ProgressIndicator:
<a name="18" id="anc18"></a><span class="line-modified"> 644         return ATK_ROLE_PROGRESS_BAR;</span>
 645     case AccessibilityRole::Window:
 646         return ATK_ROLE_WINDOW;
 647     case AccessibilityRole::PopUpButton:
 648         return coreObject-&gt;hasPopup() ? ATK_ROLE_PUSH_BUTTON : ATK_ROLE_COMBO_BOX;
 649     case AccessibilityRole::ComboBox:
 650         return ATK_ROLE_COMBO_BOX;
 651     case AccessibilityRole::SplitGroup:
 652         return ATK_ROLE_SPLIT_PANE;
 653     case AccessibilityRole::Splitter:
 654         return ATK_ROLE_SEPARATOR;
<a name="19" id="anc19"></a>
 655 #if PLATFORM(GTK)
<a name="20" id="anc20"></a><span class="line-added"> 656     case AccessibilityRole::ColorWell:</span>
 657         // ATK_ROLE_COLOR_CHOOSER is defined as a dialog (i.e. it&#39;s what appears when you push the button).
 658         return ATK_ROLE_PUSH_BUTTON;
 659 #endif
 660     case AccessibilityRole::List:
 661         return ATK_ROLE_LIST;
 662     case AccessibilityRole::ScrollBar:
 663         return ATK_ROLE_SCROLL_BAR;
 664     case AccessibilityRole::ScrollArea:
 665     case AccessibilityRole::TabPanel:
 666         return ATK_ROLE_SCROLL_PANE;
 667     case AccessibilityRole::Grid:
 668     case AccessibilityRole::Table:
 669         return ATK_ROLE_TABLE;
 670     case AccessibilityRole::TreeGrid:
 671         return ATK_ROLE_TREE_TABLE;
 672     case AccessibilityRole::Application:
 673         return ATK_ROLE_APPLICATION;
 674     case AccessibilityRole::ApplicationGroup:
 675     case AccessibilityRole::Feed:
 676     case AccessibilityRole::Figure:
 677     case AccessibilityRole::GraphicsObject:
 678     case AccessibilityRole::Group:
 679     case AccessibilityRole::RadioGroup:
 680     case AccessibilityRole::SVGRoot:
 681         return ATK_ROLE_PANEL;
 682     case AccessibilityRole::RowHeader:
 683         return ATK_ROLE_ROW_HEADER;
 684     case AccessibilityRole::ColumnHeader:
 685         return ATK_ROLE_COLUMN_HEADER;
 686     case AccessibilityRole::Caption:
 687         return ATK_ROLE_CAPTION;
 688     case AccessibilityRole::Cell:
 689     case AccessibilityRole::GridCell:
 690         return coreObject-&gt;inheritsPresentationalRole() ? ATK_ROLE_SECTION : ATK_ROLE_TABLE_CELL;
 691     case AccessibilityRole::Link:
 692     case AccessibilityRole::WebCoreLink:
 693     case AccessibilityRole::ImageMapLink:
 694         return ATK_ROLE_LINK;
 695     case AccessibilityRole::ImageMap:
 696         return ATK_ROLE_IMAGE_MAP;
 697     case AccessibilityRole::GraphicsSymbol:
 698     case AccessibilityRole::Image:
 699         return ATK_ROLE_IMAGE;
 700     case AccessibilityRole::ListMarker:
 701         return ATK_ROLE_TEXT;
 702     case AccessibilityRole::DocumentArticle:
<a name="21" id="anc21"></a>
 703         return ATK_ROLE_ARTICLE;
<a name="22" id="anc22"></a>
 704     case AccessibilityRole::Document:
 705     case AccessibilityRole::GraphicsDocument:
 706         return ATK_ROLE_DOCUMENT_FRAME;
 707     case AccessibilityRole::DocumentNote:
 708         return ATK_ROLE_COMMENT;
 709     case AccessibilityRole::Heading:
 710         return ATK_ROLE_HEADING;
 711     case AccessibilityRole::ListBox:
 712         // https://rawgit.com/w3c/aria/master/core-aam/core-aam.html#role-map-listbox
 713         return coreObject-&gt;isDescendantOfRole(AccessibilityRole::ComboBox) ? ATK_ROLE_MENU : ATK_ROLE_LIST_BOX;
 714     case AccessibilityRole::ListItem:
 715         return coreObject-&gt;inheritsPresentationalRole() ? ATK_ROLE_SECTION : ATK_ROLE_LIST_ITEM;
 716     case AccessibilityRole::ListBoxOption:
 717         return coreObject-&gt;isDescendantOfRole(AccessibilityRole::ComboBox) ? ATK_ROLE_MENU_ITEM : ATK_ROLE_LIST_ITEM;
 718     case AccessibilityRole::Paragraph:
 719         return ATK_ROLE_PARAGRAPH;
 720     case AccessibilityRole::Label:
 721     case AccessibilityRole::Legend:
 722         return ATK_ROLE_LABEL;
 723     case AccessibilityRole::Blockquote:
<a name="23" id="anc23"></a>
 724         return ATK_ROLE_BLOCK_QUOTE;
<a name="24" id="anc24"></a>

 725 #if ATK_CHECK_VERSION(2, 25, 2)
<a name="25" id="anc25"></a><span class="line-added"> 726     case AccessibilityRole::Footnote:</span>
 727         return ATK_ROLE_FOOTNOTE;
 728 #endif
 729     case AccessibilityRole::ApplicationTextGroup:
 730     case AccessibilityRole::Div:
 731     case AccessibilityRole::Pre:
 732     case AccessibilityRole::SVGText:
 733     case AccessibilityRole::TextGroup:
 734         return ATK_ROLE_SECTION;
 735     case AccessibilityRole::Footer:
 736         return ATK_ROLE_FOOTER;
 737     case AccessibilityRole::Form:
<a name="26" id="anc26"></a>
 738         if (coreObject-&gt;ariaRoleAttribute() != AccessibilityRole::Unknown)
 739             return ATK_ROLE_LANDMARK;
<a name="27" id="anc27"></a>
 740         return ATK_ROLE_FORM;
 741     case AccessibilityRole::Canvas:
 742         return ATK_ROLE_CANVAS;
 743     case AccessibilityRole::HorizontalRule:
 744         return ATK_ROLE_SEPARATOR;
 745     case AccessibilityRole::SpinButton:
 746         return ATK_ROLE_SPIN_BUTTON;
 747     case AccessibilityRole::Tab:
 748         return ATK_ROLE_PAGE_TAB;
 749     case AccessibilityRole::UserInterfaceTooltip:
 750         return ATK_ROLE_TOOL_TIP;
 751     case AccessibilityRole::WebArea:
 752         return ATK_ROLE_DOCUMENT_WEB;
 753     case AccessibilityRole::WebApplication:
 754         return ATK_ROLE_EMBEDDED;
<a name="28" id="anc28"></a>
 755     case AccessibilityRole::ApplicationLog:
 756         return ATK_ROLE_LOG;
 757     case AccessibilityRole::ApplicationMarquee:
 758         return ATK_ROLE_MARQUEE;
 759     case AccessibilityRole::ApplicationTimer:
 760         return ATK_ROLE_TIMER;
 761     case AccessibilityRole::Definition:
 762         return ATK_ROLE_DEFINITION;
 763     case AccessibilityRole::DocumentMath:
 764         return ATK_ROLE_MATH;
 765     case AccessibilityRole::MathElement:
 766         if (coreObject-&gt;isMathRow())
 767             return ATK_ROLE_PANEL;
 768         if (coreObject-&gt;isMathTable())
 769             return ATK_ROLE_TABLE;
 770         if (coreObject-&gt;isMathTableRow())
 771             return ATK_ROLE_TABLE_ROW;
 772         if (coreObject-&gt;isMathTableCell())
 773             return ATK_ROLE_TABLE_CELL;
 774         if (coreObject-&gt;isMathSubscriptSuperscript() || coreObject-&gt;isMathMultiscript())
 775             return ATK_ROLE_SECTION;
<a name="29" id="anc29"></a>
 776         if (coreObject-&gt;isMathFraction())
 777             return ATK_ROLE_MATH_FRACTION;
 778         if (coreObject-&gt;isMathSquareRoot() || coreObject-&gt;isMathRoot())
 779             return ATK_ROLE_MATH_ROOT;
 780         if (coreObject-&gt;isMathScriptObject(AccessibilityMathScriptObjectType::Subscript)
 781             || coreObject-&gt;isMathMultiscriptObject(AccessibilityMathMultiscriptObjectType::PreSubscript) || coreObject-&gt;isMathMultiscriptObject(AccessibilityMathMultiscriptObjectType::PostSubscript))
 782             return ATK_ROLE_SUBSCRIPT;
 783         if (coreObject-&gt;isMathScriptObject(AccessibilityMathScriptObjectType::Superscript)
 784             || coreObject-&gt;isMathMultiscriptObject(AccessibilityMathMultiscriptObjectType::PreSuperscript) || coreObject-&gt;isMathMultiscriptObject(AccessibilityMathMultiscriptObjectType::PostSuperscript))
 785             return ATK_ROLE_SUPERSCRIPT;
<a name="30" id="anc30"></a>

 786         if (coreObject-&gt;isMathToken())
 787             return ATK_ROLE_STATIC;
<a name="31" id="anc31"></a>
 788         return ATK_ROLE_UNKNOWN;
 789     case AccessibilityRole::LandmarkBanner:
 790     case AccessibilityRole::LandmarkComplementary:
 791     case AccessibilityRole::LandmarkContentInfo:
 792     case AccessibilityRole::LandmarkDocRegion:
 793     case AccessibilityRole::LandmarkMain:
 794     case AccessibilityRole::LandmarkNavigation:
 795     case AccessibilityRole::LandmarkRegion:
 796     case AccessibilityRole::LandmarkSearch:
 797         return ATK_ROLE_LANDMARK;
<a name="32" id="anc32"></a>

 798     case AccessibilityRole::DescriptionList:
 799         return ATK_ROLE_DESCRIPTION_LIST;
 800     case AccessibilityRole::Term:
 801     case AccessibilityRole::DescriptionListTerm:
 802         return ATK_ROLE_DESCRIPTION_TERM;
 803     case AccessibilityRole::DescriptionListDetail:
 804         return ATK_ROLE_DESCRIPTION_VALUE;
<a name="33" id="anc33"></a><span class="line-added"> 805     case AccessibilityRole::Deletion:</span>
<span class="line-added"> 806 #if ATK_CHECK_VERSION(2, 33, 3)</span>
<span class="line-added"> 807         return ATK_ROLE_CONTENT_DELETION;</span>
<span class="line-added"> 808 #else</span>
<span class="line-added"> 809         return ATK_ROLE_STATIC;</span>
 810 #endif
<a name="34" id="anc34"></a><span class="line-modified"> 811     case AccessibilityRole::Insertion:</span>
<span class="line-modified"> 812 #if ATK_CHECK_VERSION(2, 33, 3)</span>
<span class="line-modified"> 813         return ATK_ROLE_CONTENT_INSERTION;</span>
<span class="line-modified"> 814 #else</span>




 815         return ATK_ROLE_STATIC;
<a name="35" id="anc35"></a><span class="line-added"> 816 #endif</span>
<span class="line-added"> 817     case AccessibilityRole::Subscript:</span>
<span class="line-added"> 818         return ATK_ROLE_SUBSCRIPT;</span>
<span class="line-added"> 819     case AccessibilityRole::Superscript:</span>
<span class="line-added"> 820         return ATK_ROLE_SUPERSCRIPT;</span>
<span class="line-added"> 821     case AccessibilityRole::Inline:</span>
 822     case AccessibilityRole::SVGTextPath:
 823     case AccessibilityRole::SVGTSpan:
 824     case AccessibilityRole::Time:
 825         return ATK_ROLE_STATIC;
<a name="36" id="anc36"></a>
 826     default:
 827         return ATK_ROLE_UNKNOWN;
 828     }
 829 }
 830 
 831 static AtkRole webkitAccessibleGetRole(AtkObject* object)
 832 {
 833     // ATK_ROLE_UNKNOWN should only be applied in cases where there is a valid
 834     // WebCore accessible object for which the platform role mapping is unknown.
 835     auto* accessible = WEBKIT_ACCESSIBLE(object);
 836     returnValIfWebKitAccessibleIsInvalid(accessible, ATK_ROLE_INVALID);
 837 
 838     // Note: Why doesn&#39;t WebCore have a password field for this
 839     if (accessible-&gt;priv-&gt;object-&gt;isPasswordField())
 840         return ATK_ROLE_PASSWORD_TEXT;
 841 
 842     return atkRole(accessible-&gt;priv-&gt;object);
 843 }
 844 
 845 static bool isTextWithCaret(AccessibilityObject* coreObject)
 846 {
 847     if (!coreObject || !coreObject-&gt;isAccessibilityRenderObject())
 848         return false;
 849 
 850     Document* document = coreObject-&gt;document();
 851     if (!document)
 852         return false;
 853 
 854     Frame* frame = document-&gt;frame();
 855     if (!frame)
 856         return false;
 857 
 858     if (!frame-&gt;settings().caretBrowsingEnabled())
 859         return false;
 860 
 861     // Check text objects and paragraphs only.
 862     auto* axObject = coreObject-&gt;wrapper();
 863     AtkRole role = axObject ? atk_object_get_role(ATK_OBJECT(axObject)) : ATK_ROLE_INVALID;
 864     if (role != ATK_ROLE_TEXT &amp;&amp; role != ATK_ROLE_PARAGRAPH)
 865         return false;
 866 
 867     // Finally, check whether the caret is set in the current object.
 868     VisibleSelection selection = coreObject-&gt;selection();
 869     if (!selection.isCaret())
 870         return false;
 871 
 872     return selectionBelongsToObject(coreObject, selection);
 873 }
 874 
 875 static void setAtkStateSetFromCoreObject(AccessibilityObject* coreObject, AtkStateSet* stateSet)
 876 {
 877     AccessibilityObject* parent = coreObject-&gt;parentObject();
 878     bool isListBoxOption = parent &amp;&amp; parent-&gt;isListBox();
 879 
 880     // Please keep the state list in alphabetical order
 881     if ((isListBoxOption &amp;&amp; coreObject-&gt;isSelectedOptionActive())
 882         || coreObject-&gt;currentState() != AccessibilityCurrentState::False)
 883         atk_state_set_add_state(stateSet, ATK_STATE_ACTIVE);
 884 
 885     if (coreObject-&gt;isBusy())
 886         atk_state_set_add_state(stateSet, ATK_STATE_BUSY);
 887 
<a name="37" id="anc37"></a>
 888     if (coreObject-&gt;supportsChecked() &amp;&amp; coreObject-&gt;canSetValueAttribute())
 889         atk_state_set_add_state(stateSet, ATK_STATE_CHECKABLE);
<a name="38" id="anc38"></a>
 890 
 891     if (coreObject-&gt;isChecked())
 892         atk_state_set_add_state(stateSet, ATK_STATE_CHECKED);
 893 
 894     if ((coreObject-&gt;isTextControl() || coreObject-&gt;isNonNativeTextControl()) &amp;&amp; coreObject-&gt;canSetValueAttribute())
 895         atk_state_set_add_state(stateSet, ATK_STATE_EDITABLE);
 896 
 897     // FIXME: Put both ENABLED and SENSITIVE together here for now
 898     if (coreObject-&gt;isEnabled()) {
 899         atk_state_set_add_state(stateSet, ATK_STATE_ENABLED);
 900         atk_state_set_add_state(stateSet, ATK_STATE_SENSITIVE);
 901     }
 902 
 903     if (coreObject-&gt;canSetExpandedAttribute())
 904         atk_state_set_add_state(stateSet, ATK_STATE_EXPANDABLE);
 905 
 906     if (coreObject-&gt;isExpanded())
 907         atk_state_set_add_state(stateSet, ATK_STATE_EXPANDED);
 908 
 909     if (coreObject-&gt;canSetFocusAttribute())
 910         atk_state_set_add_state(stateSet, ATK_STATE_FOCUSABLE);
 911 
 912     // According to the Core AAM, if the element which is focused has a valid aria-activedescendant,
 913     // we should not expose the focused state on the element which is actually focused, but instead
 914     // on its active descendant.
 915     if ((coreObject-&gt;isFocused() &amp;&amp; !coreObject-&gt;activeDescendant()) || isTextWithCaret(coreObject))
 916         atk_state_set_add_state(stateSet, ATK_STATE_FOCUSED);
 917     else if (coreObject-&gt;isActiveDescendantOfFocusedContainer()) {
 918         atk_state_set_add_state(stateSet, ATK_STATE_FOCUSABLE);
 919         atk_state_set_add_state(stateSet, ATK_STATE_FOCUSED);
 920     }
 921 
 922     if (coreObject-&gt;orientation() == AccessibilityOrientation::Horizontal)
 923         atk_state_set_add_state(stateSet, ATK_STATE_HORIZONTAL);
 924     else if (coreObject-&gt;orientation() == AccessibilityOrientation::Vertical)
 925         atk_state_set_add_state(stateSet, ATK_STATE_VERTICAL);
 926 
 927     if (coreObject-&gt;hasPopup())
 928         atk_state_set_add_state(stateSet, ATK_STATE_HAS_POPUP);
 929 
 930     if (coreObject-&gt;isIndeterminate())
 931         atk_state_set_add_state(stateSet, ATK_STATE_INDETERMINATE);
 932     else if (coreObject-&gt;isCheckboxOrRadio() || coreObject-&gt;isMenuItem() || coreObject-&gt;isToggleButton()) {
 933         if (coreObject-&gt;checkboxOrRadioValue() == AccessibilityButtonState::Mixed)
 934             atk_state_set_add_state(stateSet, ATK_STATE_INDETERMINATE);
 935     }
 936 
 937     if (coreObject-&gt;isModalNode())
 938         atk_state_set_add_state(stateSet, ATK_STATE_MODAL);
 939 
 940     if (coreObject-&gt;invalidStatus() != &quot;false&quot;)
 941         atk_state_set_add_state(stateSet, ATK_STATE_INVALID_ENTRY);
 942 
 943     if (coreObject-&gt;isMultiSelectable())
 944         atk_state_set_add_state(stateSet, ATK_STATE_MULTISELECTABLE);
 945 
 946     // TODO: ATK_STATE_OPAQUE
 947 
 948     if (coreObject-&gt;isPressed())
 949         atk_state_set_add_state(stateSet, ATK_STATE_PRESSED);
 950 
<a name="39" id="anc39"></a>
 951     if (!coreObject-&gt;canSetValueAttribute() &amp;&amp; (coreObject-&gt;supportsReadOnly()))
 952         atk_state_set_add_state(stateSet, ATK_STATE_READ_ONLY);
<a name="40" id="anc40"></a>
 953 
 954     if (coreObject-&gt;isRequired())
 955         atk_state_set_add_state(stateSet, ATK_STATE_REQUIRED);
 956 
 957     // TODO: ATK_STATE_SELECTABLE_TEXT
 958 
 959     if (coreObject-&gt;canSetSelectedAttribute()) {
 960         atk_state_set_add_state(stateSet, ATK_STATE_SELECTABLE);
 961         // Items in focusable lists have both STATE_SELECT{ABLE,ED}
 962         // and STATE_FOCUS{ABLE,ED}. We&#39;ll fake the latter based on
 963         // the former.
 964         if (isListBoxOption)
 965             atk_state_set_add_state(stateSet, ATK_STATE_FOCUSABLE);
 966     }
 967 
 968     if (coreObject-&gt;isSelected()) {
 969         atk_state_set_add_state(stateSet, ATK_STATE_SELECTED);
 970         // Items in focusable lists have both STATE_SELECT{ABLE,ED}
 971         // and STATE_FOCUS{ABLE,ED}. We&#39;ll fake the latter based on the
 972         // former.
 973         if (isListBoxOption)
 974             atk_state_set_add_state(stateSet, ATK_STATE_FOCUSED);
 975     }
 976 
 977     // FIXME: Group both SHOWING and VISIBLE here for now
 978     // Not sure how to handle this in WebKit, see bug
 979     // http://bugzilla.gnome.org/show_bug.cgi?id=509650 for other
 980     // issues with SHOWING vs VISIBLE.
 981     if (!coreObject-&gt;isOffScreen()) {
 982         atk_state_set_add_state(stateSet, ATK_STATE_SHOWING);
 983         atk_state_set_add_state(stateSet, ATK_STATE_VISIBLE);
 984     }
 985 
 986     // Mutually exclusive, so we group these two
 987     if (coreObject-&gt;roleValue() == AccessibilityRole::TextArea || coreObject-&gt;ariaIsMultiline())
 988         atk_state_set_add_state(stateSet, ATK_STATE_MULTI_LINE);
 989     else if (coreObject-&gt;roleValue() == AccessibilityRole::TextField || coreObject-&gt;roleValue() == AccessibilityRole::SearchField)
 990         atk_state_set_add_state(stateSet, ATK_STATE_SINGLE_LINE);
 991 
 992     // TODO: ATK_STATE_SENSITIVE
 993 
 994     if (coreObject-&gt;supportsAutoComplete() &amp;&amp; coreObject-&gt;autoCompleteValue() != &quot;none&quot;)
 995         atk_state_set_add_state(stateSet, ATK_STATE_SUPPORTS_AUTOCOMPLETION);
 996 
 997     if (coreObject-&gt;isVisited())
 998         atk_state_set_add_state(stateSet, ATK_STATE_VISITED);
 999 }
1000 
1001 static AtkStateSet* webkitAccessibleRefStateSet(AtkObject* object)
1002 {
1003     auto* accessible = WEBKIT_ACCESSIBLE(object);
1004     AtkStateSet* stateSet = ATK_OBJECT_CLASS(webkit_accessible_parent_class)-&gt;ref_state_set(object);
1005 
1006     // Make sure the layout is updated to really know whether the object
1007     // is defunct or not, so we can return the proper state.
1008     accessible-&gt;priv-&gt;object-&gt;updateBackingStore();
1009 
1010     if (accessible-&gt;priv-&gt;object == fallbackObject()) {
1011         atk_state_set_add_state(stateSet, ATK_STATE_DEFUNCT);
1012         return stateSet;
1013     }
1014 
1015     // Text objects must be focusable.
1016     AtkRole role = atk_object_get_role(object);
1017     if (role == ATK_ROLE_TEXT || role == ATK_ROLE_PARAGRAPH)
1018         atk_state_set_add_state(stateSet, ATK_STATE_FOCUSABLE);
1019 
1020     setAtkStateSetFromCoreObject(accessible-&gt;priv-&gt;object, stateSet);
1021     return stateSet;
1022 }
1023 
1024 static AtkRelationSet* webkitAccessibleRefRelationSet(AtkObject* object)
1025 {
1026     auto* accessible = WEBKIT_ACCESSIBLE(object);
1027     returnValIfWebKitAccessibleIsInvalid(accessible, nullptr);
1028 
1029     AtkRelationSet* relationSet = ATK_OBJECT_CLASS(webkit_accessible_parent_class)-&gt;ref_relation_set(object);
1030     setAtkRelationSetFromCoreObject(accessible-&gt;priv-&gt;object, relationSet);
1031     return relationSet;
1032 }
1033 
1034 static void webkitAccessibleInit(AtkObject* object, gpointer data)
1035 {
1036     if (ATK_OBJECT_CLASS(webkit_accessible_parent_class)-&gt;initialize)
1037         ATK_OBJECT_CLASS(webkit_accessible_parent_class)-&gt;initialize(object, data);
1038 
1039     WebKitAccessible* accessible = WEBKIT_ACCESSIBLE(object);
1040     accessible-&gt;priv-&gt;object = reinterpret_cast&lt;AccessibilityObject*&gt;(data);
1041 }
1042 
1043 static const gchar* webkitAccessibleGetObjectLocale(AtkObject* object)
1044 {
1045     auto* accessible = WEBKIT_ACCESSIBLE(object);
1046     returnValIfWebKitAccessibleIsInvalid(accessible, nullptr);
1047 
1048     if (ATK_IS_DOCUMENT(object)) {
1049         // TODO: Should we fall back on lang xml:lang when the following comes up empty?
1050         String language = accessible-&gt;priv-&gt;object-&gt;language();
1051         if (!language.isEmpty())
1052             return webkitAccessibleCacheAndReturnAtkProperty(accessible, AtkCachedDocumentLocale, language.utf8());
1053 
1054     } else if (ATK_IS_TEXT(object)) {
1055         const gchar* locale = nullptr;
1056 
1057         AtkAttributeSet* textAttributes = atk_text_get_default_attributes(ATK_TEXT(object));
1058         for (auto* attributes = textAttributes; attributes; attributes = attributes-&gt;next) {
1059             auto* atkAttribute = static_cast&lt;AtkAttribute*&gt;(attributes-&gt;data);
1060             if (!strcmp(atkAttribute-&gt;name, atk_text_attribute_get_name(ATK_TEXT_ATTR_LANGUAGE))) {
1061                 locale = webkitAccessibleCacheAndReturnAtkProperty(accessible, AtkCachedDocumentLocale, atkAttribute-&gt;value);
1062                 break;
1063             }
1064         }
1065         atk_attribute_set_free(textAttributes);
1066 
1067         return locale;
1068     }
1069 
1070     return nullptr;
1071 }
1072 
1073 static void webkit_accessible_class_init(WebKitAccessibleClass* klass)
1074 {
1075     auto* atkObjectClass = ATK_OBJECT_CLASS(klass);
1076     atkObjectClass-&gt;initialize = webkitAccessibleInit;
1077     atkObjectClass-&gt;get_name = webkitAccessibleGetName;
1078     atkObjectClass-&gt;get_description = webkitAccessibleGetDescription;
1079     atkObjectClass-&gt;get_parent = webkitAccessibleGetParent;
1080     atkObjectClass-&gt;get_n_children = webkitAccessibleGetNChildren;
1081     atkObjectClass-&gt;ref_child = webkitAccessibleRefChild;
1082     atkObjectClass-&gt;get_role = webkitAccessibleGetRole;
1083     atkObjectClass-&gt;ref_state_set = webkitAccessibleRefStateSet;
1084     atkObjectClass-&gt;get_index_in_parent = webkitAccessibleGetIndexInParent;
1085     atkObjectClass-&gt;get_attributes = webkitAccessibleGetAttributes;
1086     atkObjectClass-&gt;ref_relation_set = webkitAccessibleRefRelationSet;
1087     atkObjectClass-&gt;get_object_locale = webkitAccessibleGetObjectLocale;
1088 }
1089 
1090 static const GInterfaceInfo atkInterfacesInitFunctions[] = {
1091     {reinterpret_cast&lt;GInterfaceInitFunc&gt;(reinterpret_cast&lt;GCallback&gt;(webkitAccessibleActionInterfaceInit)), nullptr, nullptr},
1092     {reinterpret_cast&lt;GInterfaceInitFunc&gt;(reinterpret_cast&lt;GCallback&gt;(webkitAccessibleSelectionInterfaceInit)), nullptr, nullptr},
1093     {reinterpret_cast&lt;GInterfaceInitFunc&gt;(reinterpret_cast&lt;GCallback&gt;(webkitAccessibleEditableTextInterfaceInit)), nullptr, nullptr},
1094     {reinterpret_cast&lt;GInterfaceInitFunc&gt;(reinterpret_cast&lt;GCallback&gt;(webkitAccessibleTextInterfaceInit)), nullptr, nullptr},
1095     {reinterpret_cast&lt;GInterfaceInitFunc&gt;(reinterpret_cast&lt;GCallback&gt;(webkitAccessibleComponentInterfaceInit)), nullptr, nullptr},
1096     {reinterpret_cast&lt;GInterfaceInitFunc&gt;(reinterpret_cast&lt;GCallback&gt;(webkitAccessibleImageInterfaceInit)), nullptr, nullptr},
1097     {reinterpret_cast&lt;GInterfaceInitFunc&gt;(reinterpret_cast&lt;GCallback&gt;(webkitAccessibleTableInterfaceInit)), nullptr, nullptr},
<a name="41" id="anc41"></a>
1098     {reinterpret_cast&lt;GInterfaceInitFunc&gt;(reinterpret_cast&lt;GCallback&gt;(webkitAccessibleTableCellInterfaceInit)), nullptr, nullptr},
<a name="42" id="anc42"></a>
1099     {reinterpret_cast&lt;GInterfaceInitFunc&gt;(reinterpret_cast&lt;GCallback&gt;(webkitAccessibleHypertextInterfaceInit)), nullptr, nullptr},
1100     {reinterpret_cast&lt;GInterfaceInitFunc&gt;(reinterpret_cast&lt;GCallback&gt;(webkitAccessibleHyperlinkImplInterfaceInit)), nullptr, nullptr},
1101     {reinterpret_cast&lt;GInterfaceInitFunc&gt;(reinterpret_cast&lt;GCallback&gt;(webkitAccessibleDocumentInterfaceInit)), nullptr, nullptr},
1102     {reinterpret_cast&lt;GInterfaceInitFunc&gt;(reinterpret_cast&lt;GCallback&gt;(webkitAccessibleValueInterfaceInit)), nullptr, nullptr}
1103 };
1104 
1105 enum WAIType {
1106     WAIAction,
1107     WAISelection,
1108     WAIEditableText,
1109     WAIText,
1110     WAIComponent,
1111     WAIImage,
1112     WAITable,
<a name="43" id="anc43"></a>
1113     WAITableCell,
<a name="44" id="anc44"></a>
1114     WAIHypertext,
1115     WAIHyperlink,
1116     WAIDocument,
1117     WAIValue,
1118 };
1119 
1120 static GType atkInterfaceTypeFromWAIType(WAIType type)
1121 {
1122     switch (type) {
1123     case WAIAction:
1124         return ATK_TYPE_ACTION;
1125     case WAISelection:
1126         return ATK_TYPE_SELECTION;
1127     case WAIEditableText:
1128         return ATK_TYPE_EDITABLE_TEXT;
1129     case WAIText:
1130         return ATK_TYPE_TEXT;
1131     case WAIComponent:
1132         return ATK_TYPE_COMPONENT;
1133     case WAIImage:
1134         return ATK_TYPE_IMAGE;
1135     case WAITable:
1136         return ATK_TYPE_TABLE;
<a name="45" id="anc45"></a>
1137     case WAITableCell:
1138         return ATK_TYPE_TABLE_CELL;
<a name="46" id="anc46"></a>
1139     case WAIHypertext:
1140         return ATK_TYPE_HYPERTEXT;
1141     case WAIHyperlink:
1142         return ATK_TYPE_HYPERLINK_IMPL;
1143     case WAIDocument:
1144         return ATK_TYPE_DOCUMENT;
1145     case WAIValue:
1146         return ATK_TYPE_VALUE;
1147     }
1148 
1149     return G_TYPE_INVALID;
1150 }
1151 
1152 static bool roleIsTextType(AccessibilityRole role)
1153 {
1154     return role == AccessibilityRole::Paragraph
1155         || role == AccessibilityRole::Heading
1156         || role == AccessibilityRole::Div
1157         || role == AccessibilityRole::Cell
1158         || role == AccessibilityRole::Link
1159         || role == AccessibilityRole::WebCoreLink
1160         || role == AccessibilityRole::ListItem
1161         || role == AccessibilityRole::Pre
1162         || role == AccessibilityRole::GridCell
1163         || role == AccessibilityRole::TextGroup
1164         || role == AccessibilityRole::ApplicationTextGroup
1165         || role == AccessibilityRole::ApplicationGroup;
1166 }
1167 
1168 static guint16 interfaceMaskFromObject(AccessibilityObject* coreObject)
1169 {
1170     guint16 interfaceMask = 0;
1171 
1172     // Component interface is always supported
1173     interfaceMask |= 1 &lt;&lt; WAIComponent;
1174 
1175     AccessibilityRole role = coreObject-&gt;roleValue();
1176 
1177     // Action
1178     // As the implementation of the AtkAction interface is a very
1179     // basic one (just relays in executing the default action for each
1180     // object, and only supports having one action per object), it is
1181     // better just to implement this interface for every instance of
1182     // the WebKitAccessible class and let WebCore decide what to do.
1183     interfaceMask |= 1 &lt;&lt; WAIAction;
1184 
1185     // Selection
1186     if (coreObject-&gt;canHaveSelectedChildren() || coreObject-&gt;isMenuList())
1187         interfaceMask |= 1 &lt;&lt; WAISelection;
1188 
1189     // Get renderer if available.
1190     RenderObject* renderer = nullptr;
1191     if (coreObject-&gt;isAccessibilityRenderObject())
1192         renderer = coreObject-&gt;renderer();
1193 
1194     // Hyperlink (links and embedded objects).
1195     if (coreObject-&gt;isLink() || (renderer &amp;&amp; renderer-&gt;isReplaced()))
1196         interfaceMask |= 1 &lt;&lt; WAIHyperlink;
1197 
1198     // Text, Editable Text &amp; Hypertext
1199     if (role == AccessibilityRole::StaticText || coreObject-&gt;isMenuListOption())
1200         interfaceMask |= 1 &lt;&lt; WAIText;
1201     else if (coreObject-&gt;isTextControl() || coreObject-&gt;isNonNativeTextControl()) {
1202         interfaceMask |= 1 &lt;&lt; WAIText;
1203         if (coreObject-&gt;canSetValueAttribute())
1204             interfaceMask |= 1 &lt;&lt; WAIEditableText;
1205     } else if (!coreObject-&gt;isWebArea()) {
1206         if (role != AccessibilityRole::Table) {
1207             interfaceMask |= 1 &lt;&lt; WAIHypertext;
1208             if ((renderer &amp;&amp; renderer-&gt;childrenInline()) || roleIsTextType(role) || coreObject-&gt;isMathToken())
1209                 interfaceMask |= 1 &lt;&lt; WAIText;
1210         }
1211 
1212         // Add the TEXT interface for list items whose
1213         // first accessible child has a text renderer
1214         if (role == AccessibilityRole::ListItem) {
1215             const auto&amp; children = coreObject-&gt;children();
1216             if (!children.isEmpty())
1217                 interfaceMask |= interfaceMaskFromObject(children[0].get());
1218         }
1219     }
1220 
1221     // Image
1222     if (coreObject-&gt;isImage())
1223         interfaceMask |= 1 &lt;&lt; WAIImage;
1224 
1225     // Table
1226     if (coreObject-&gt;isTable())
1227         interfaceMask |= 1 &lt;&lt; WAITable;
1228 
<a name="47" id="anc47"></a>
1229     if (role == AccessibilityRole::Cell || role == AccessibilityRole::GridCell || role == AccessibilityRole::ColumnHeader || role == AccessibilityRole::RowHeader)
1230         interfaceMask |= 1 &lt;&lt; WAITableCell;
<a name="48" id="anc48"></a>
1231 
1232     // Document
1233     if (role == AccessibilityRole::WebArea)
1234         interfaceMask |= 1 &lt;&lt; WAIDocument;
1235 
1236     // Value
1237     if (coreObject-&gt;supportsRangeValue())
1238         interfaceMask |= 1 &lt;&lt; WAIValue;
1239 
1240 #if ENABLE(INPUT_TYPE_COLOR)
1241     // Color type.
1242     if (role == AccessibilityRole::ColorWell)
1243         interfaceMask |= 1 &lt;&lt; WAIText;
1244 #endif
1245 
1246     return interfaceMask;
1247 }
1248 
1249 static const char* uniqueAccessibilityTypeName(guint16 interfaceMask)
1250 {
1251 #define WAI_TYPE_NAME_LEN (30) // Enough for prefix + 5 hex characters (max).
1252     static char name[WAI_TYPE_NAME_LEN + 1];
1253 
1254     g_sprintf(name, &quot;WAIType%x&quot;, interfaceMask);
1255     name[WAI_TYPE_NAME_LEN] = &#39;\0&#39;;
1256 
1257     return name;
1258 }
1259 
1260 static GType accessibilityTypeFromObject(AccessibilityObject* coreObject)
1261 {
1262     static const GTypeInfo typeInfo = {
1263         sizeof(WebKitAccessibleClass),
1264         nullptr, // GBaseInitFunc
1265         nullptr, // GBaseFinalizeFunc
1266         nullptr, // GClassInitFunc
1267         nullptr, // GClassFinalizeFunc
1268         nullptr, // class data
1269         sizeof(WebKitAccessible), // instance size
1270         0, // nb preallocs
1271         nullptr, // GInstanceInitFunc
1272         nullptr // value table
1273     };
1274 
1275     guint16 interfaceMask = interfaceMaskFromObject(coreObject);
1276     const char* atkTypeName = uniqueAccessibilityTypeName(interfaceMask);
1277     if (GType type = g_type_from_name(atkTypeName))
1278         return type;
1279 
1280     GType type = g_type_register_static(WEBKIT_TYPE_ACCESSIBLE, atkTypeName, &amp;typeInfo, static_cast&lt;GTypeFlags&gt;(0));
1281     for (unsigned i = 0; i &lt; G_N_ELEMENTS(atkInterfacesInitFunctions); ++i) {
1282         if (interfaceMask &amp; (1 &lt;&lt; i)) {
1283             g_type_add_interface_static(type,
1284                 atkInterfaceTypeFromWAIType(static_cast&lt;WAIType&gt;(i)),
1285                 &amp;atkInterfacesInitFunctions[i]);
1286         }
1287     }
1288 
1289     return type;
1290 }
1291 
1292 WebKitAccessible* webkitAccessibleNew(AccessibilityObject* coreObject)
1293 {
1294     auto* object = ATK_OBJECT(g_object_new(accessibilityTypeFromObject(coreObject), nullptr));
1295     atk_object_initialize(object, coreObject);
1296     return WEBKIT_ACCESSIBLE(object);
1297 }
1298 
1299 AccessibilityObject&amp; webkitAccessibleGetAccessibilityObject(WebKitAccessible* accessible)
1300 {
1301     ASSERT(WEBKIT_IS_ACCESSIBLE(accessible));
1302     return *accessible-&gt;priv-&gt;object;
1303 }
1304 
1305 void webkitAccessibleDetach(WebKitAccessible* accessible)
1306 {
1307     ASSERT(WEBKIT_IS_ACCESSIBLE(accessible));
1308     ASSERT(accessible-&gt;priv-&gt;object != fallbackObject());
1309 
1310     if (accessible-&gt;priv-&gt;object-&gt;roleValue() == AccessibilityRole::WebArea)
1311         atk_object_notify_state_change(ATK_OBJECT(accessible), ATK_STATE_DEFUNCT, TRUE);
1312 
1313     // We replace the WebCore AccessibilityObject with a fallback object that
1314     // provides default implementations to avoid repetitive null-checking after
1315     // detachment.
1316     accessible-&gt;priv-&gt;object = fallbackObject();
1317 }
1318 
1319 bool webkitAccessibleIsDetached(WebKitAccessible* accessible)
1320 {
1321     ASSERT(WEBKIT_IS_ACCESSIBLE(accessible));
1322     return accessible-&gt;priv-&gt;object == fallbackObject();
1323 }
1324 
1325 const char* webkitAccessibleCacheAndReturnAtkProperty(WebKitAccessible* accessible, AtkCachedProperty property, CString&amp;&amp; value)
1326 {
1327     ASSERT(WEBKIT_IS_ACCESSIBLE(accessible));
1328 
1329     WebKitAccessiblePrivate* priv = accessible-&gt;priv;
1330     CString* propertyPtr = nullptr;
1331 
1332     switch (property) {
1333     case AtkCachedAccessibleName:
1334         propertyPtr = &amp;priv-&gt;accessibleName;
1335         break;
1336     case AtkCachedAccessibleDescription:
1337         propertyPtr = &amp;priv-&gt;accessibleDescription;
1338         break;
1339     case AtkCachedActionName:
1340         propertyPtr = &amp;priv-&gt;actionName;
1341         break;
1342     case AtkCachedActionKeyBinding:
1343         propertyPtr = &amp;priv-&gt;actionKeyBinding;
1344         break;
1345     case AtkCachedDocumentLocale:
1346         propertyPtr = &amp;priv-&gt;documentLocale;
1347         break;
1348     case AtkCachedDocumentType:
1349         propertyPtr = &amp;priv-&gt;documentType;
1350         break;
1351     case AtkCachedDocumentEncoding:
1352         propertyPtr = &amp;priv-&gt;documentEncoding;
1353         break;
1354     case AtkCachedDocumentURI:
1355         propertyPtr = &amp;priv-&gt;documentURI;
1356         break;
1357     case AtkCachedImageDescription:
1358         propertyPtr = &amp;priv-&gt;imageDescription;
1359         break;
1360     default:
1361         ASSERT_NOT_REACHED();
1362     }
1363 
1364     // Don&#39;t invalidate old memory if not stricly needed, since other
1365     // callers might be still holding on to it.
1366     if (*propertyPtr != value)
1367         *propertyPtr = WTFMove(value);
1368 
1369     return (*propertyPtr).data();
1370 }
1371 
<a name="49" id="anc49"></a><span class="line-modified">1372 #endif // ENABLE(ACCESSIBILITY)</span>
<a name="50" id="anc50"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="50" type="hidden" />
</body>
</html>