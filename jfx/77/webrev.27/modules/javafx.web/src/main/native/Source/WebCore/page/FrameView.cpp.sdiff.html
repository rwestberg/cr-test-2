<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/page/FrameView.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FrameTree.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="FrameView.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/page/FrameView.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  17  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  18  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  19  * Library General Public License for more details.
  20  *
  21  * You should have received a copy of the GNU Library General Public License
  22  * along with this library; see the file COPYING.LIB.  If not, write to
  23  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  24  * Boston, MA 02110-1301, USA.
  25  */
  26 
  27 #include &quot;config.h&quot;
  28 #include &quot;FrameView.h&quot;
  29 
  30 #include &quot;AXObjectCache.h&quot;
  31 #include &quot;BackForwardController.h&quot;
  32 #include &quot;CSSAnimationController.h&quot;
  33 #include &quot;CachedImage.h&quot;
  34 #include &quot;CachedResourceLoader.h&quot;
  35 #include &quot;Chrome.h&quot;
  36 #include &quot;ChromeClient.h&quot;

  37 #include &quot;DOMWindow.h&quot;
  38 #include &quot;DebugPageOverlays.h&quot;
  39 #include &quot;DeprecatedGlobalSettings.h&quot;
  40 #include &quot;DocumentLoader.h&quot;
  41 #include &quot;DocumentMarkerController.h&quot;
  42 #include &quot;EventHandler.h&quot;
  43 #include &quot;EventNames.h&quot;
  44 #include &quot;FloatRect.h&quot;
  45 #include &quot;FocusController.h&quot;
  46 #include &quot;Frame.h&quot;
  47 #include &quot;FrameLoader.h&quot;
  48 #include &quot;FrameLoaderClient.h&quot;
  49 #include &quot;FrameSelection.h&quot;
  50 #include &quot;FrameTree.h&quot;
  51 #include &quot;GraphicsContext.h&quot;
  52 #include &quot;HTMLBodyElement.h&quot;
  53 #include &quot;HTMLEmbedElement.h&quot;
  54 #include &quot;HTMLFrameElement.h&quot;
  55 #include &quot;HTMLFrameSetElement.h&quot;
  56 #include &quot;HTMLHtmlElement.h&quot;
</pre>
<hr />
<pre>
  68 #include &quot;OverflowEvent.h&quot;
  69 #include &quot;Page.h&quot;
  70 #include &quot;PageCache.h&quot;
  71 #include &quot;PageOverlayController.h&quot;
  72 #include &quot;ProgressTracker.h&quot;
  73 #include &quot;RenderEmbeddedObject.h&quot;
  74 #include &quot;RenderFullScreen.h&quot;
  75 #include &quot;RenderIFrame.h&quot;
  76 #include &quot;RenderInline.h&quot;
  77 #include &quot;RenderLayer.h&quot;
  78 #include &quot;RenderLayerBacking.h&quot;
  79 #include &quot;RenderLayerCompositor.h&quot;
  80 #include &quot;RenderSVGRoot.h&quot;
  81 #include &quot;RenderScrollbar.h&quot;
  82 #include &quot;RenderScrollbarPart.h&quot;
  83 #include &quot;RenderStyle.h&quot;
  84 #include &quot;RenderText.h&quot;
  85 #include &quot;RenderTheme.h&quot;
  86 #include &quot;RenderView.h&quot;
  87 #include &quot;RenderWidget.h&quot;

  88 #include &quot;RuntimeEnabledFeatures.h&quot;
  89 #include &quot;SVGDocument.h&quot;
  90 #include &quot;SVGSVGElement.h&quot;
  91 #include &quot;ScriptRunner.h&quot;
  92 #include &quot;ScriptedAnimationController.h&quot;
  93 #include &quot;ScrollAnimator.h&quot;
  94 #include &quot;ScrollingCoordinator.h&quot;
  95 #include &quot;Settings.h&quot;
  96 #include &quot;StyleResolver.h&quot;
  97 #include &quot;StyleScope.h&quot;
  98 #include &quot;TextResourceDecoder.h&quot;
  99 #include &quot;TiledBacking.h&quot;

 100 #include &quot;VisualViewport.h&quot;
 101 #include &quot;WheelEventTestTrigger.h&quot;
 102 #include &lt;wtf/text/TextStream.h&gt;
 103 
 104 #include &lt;wtf/IsoMallocInlines.h&gt;
 105 #include &lt;wtf/MemoryPressureHandler.h&gt;
 106 #include &lt;wtf/Ref.h&gt;
 107 #include &lt;wtf/SetForScope.h&gt;
 108 #include &lt;wtf/SystemTracing.h&gt;
 109 
 110 #if USE(COORDINATED_GRAPHICS)
 111 #include &quot;TiledBackingStore.h&quot;
 112 #endif
 113 
 114 #if ENABLE(CSS_SCROLL_SNAP)
 115 #include &quot;AxisScrollSnapOffsets.h&quot;
 116 #endif
 117 
 118 #if PLATFORM(IOS_FAMILY)
 119 #include &quot;DocumentLoader.h&quot;
</pre>
<hr />
<pre>
 125 #endif
 126 
 127 #define RELEASE_LOG_IF_ALLOWED(fmt, ...) RELEASE_LOG_IF(frame().page() &amp;&amp; frame().page()-&gt;isAlwaysOnLoggingAllowed(), Layout, &quot;%p - FrameView::&quot; fmt, this, ##__VA_ARGS__)
 128 
 129 namespace WebCore {
 130 
 131 using namespace HTMLNames;
 132 
 133 WTF_MAKE_ISO_ALLOCATED_IMPL(FrameView);
 134 
 135 MonotonicTime FrameView::sCurrentPaintTimeStamp { };
 136 
 137 // The maximum number of updateEmbeddedObjects iterations that should be done before returning.
 138 static const unsigned maxUpdateEmbeddedObjectsIterations = 2;
 139 
 140 static constexpr unsigned defaultSignificantRenderedTextCharacterThreshold = 3000;
 141 static constexpr float defaultSignificantRenderedTextMeanLength = 50;
 142 static constexpr unsigned mainArticleSignificantRenderedTextCharacterThreshold = 1500;
 143 static constexpr float mainArticleSignificantRenderedTextMeanLength = 25;
 144 
<span class="line-removed"> 145 static OptionSet&lt;RenderLayer::UpdateLayerPositionsFlag&gt; updateLayerPositionFlags(RenderLayer* layer, bool isRelayoutingSubtree, bool didFullRepaint)</span>
<span class="line-removed"> 146 {</span>
<span class="line-removed"> 147     auto flags = RenderLayer::updateLayerPositionsDefaultFlags();</span>
<span class="line-removed"> 148     if (didFullRepaint) {</span>
<span class="line-removed"> 149         flags.remove(RenderLayer::CheckForRepaint);</span>
<span class="line-removed"> 150         flags.add(RenderLayer::NeedsFullRepaintInBacking);</span>
<span class="line-removed"> 151     }</span>
<span class="line-removed"> 152     if (isRelayoutingSubtree &amp;&amp; layer-&gt;enclosingPaginationLayer(RenderLayer::IncludeCompositedPaginatedLayers))</span>
<span class="line-removed"> 153         flags.add(RenderLayer::UpdatePagination);</span>
<span class="line-removed"> 154     return flags;</span>
<span class="line-removed"> 155 }</span>
<span class="line-removed"> 156 </span>
 157 Pagination::Mode paginationModeForRenderStyle(const RenderStyle&amp; style)
 158 {
 159     Overflow overflow = style.overflowY();
 160     if (overflow != Overflow::PagedX &amp;&amp; overflow != Overflow::PagedY)
 161         return Pagination::Unpaginated;
 162 
 163     bool isHorizontalWritingMode = style.isHorizontalWritingMode();
 164     TextDirection textDirection = style.direction();
 165     WritingMode writingMode = style.writingMode();
 166 
 167     // paged-x always corresponds to LeftToRightPaginated or RightToLeftPaginated. If the WritingMode
 168     // is horizontal, then we use TextDirection to choose between those options. If the WritingMode
 169     // is vertical, then the direction of the verticality dictates the choice.
 170     if (overflow == Overflow::PagedX) {
 171         if ((isHorizontalWritingMode &amp;&amp; textDirection == TextDirection::LTR) || writingMode == LeftToRightWritingMode)
 172             return Pagination::LeftToRightPaginated;
 173         return Pagination::RightToLeftPaginated;
 174     }
 175 
 176     // paged-y always corresponds to TopToBottomPaginated or BottomToTopPaginated. If the WritingMode
</pre>
<hr />
<pre>
 296     else
 297         setScrollbarModes(ScrollbarAlwaysOff, ScrollbarAlwaysOff);
 298     setScrollbarsSuppressed(false);
 299 }
 300 
 301 void FrameView::resetScrollbarsAndClearContentsSize()
 302 {
 303     resetScrollbars();
 304 
 305     LOG(Layout, &quot;FrameView %p resetScrollbarsAndClearContentsSize&quot;, this);
 306 
 307     setScrollbarsSuppressed(true);
 308     setContentsSize(IntSize());
 309     setScrollbarsSuppressed(false);
 310 }
 311 
 312 void FrameView::init()
 313 {
 314     reset();
 315 
<span class="line-removed"> 316     m_margins = LayoutSize(-1, -1); // undefined</span>
 317     m_size = LayoutSize();
 318 
<span class="line-modified"> 319     // Propagate the marginwidth/height and scrolling modes to the view.</span>
<span class="line-modified"> 320     Element* ownerElement = frame().ownerElement();</span>
<span class="line-modified"> 321     if (is&lt;HTMLFrameElementBase&gt;(ownerElement)) {</span>
<span class="line-modified"> 322         HTMLFrameElementBase&amp; frameElement = downcast&lt;HTMLFrameElementBase&gt;(*ownerElement);</span>
<span class="line-removed"> 323         if (frameElement.scrollingMode() == ScrollbarAlwaysOff)</span>
<span class="line-removed"> 324             setCanHaveScrollbars(false);</span>
<span class="line-removed"> 325         LayoutUnit marginWidth = frameElement.marginWidth();</span>
<span class="line-removed"> 326         LayoutUnit marginHeight = frameElement.marginHeight();</span>
<span class="line-removed"> 327         if (marginWidth != -1)</span>
<span class="line-removed"> 328             setMarginWidth(marginWidth);</span>
<span class="line-removed"> 329         if (marginHeight != -1)</span>
<span class="line-removed"> 330             setMarginHeight(marginHeight);</span>
<span class="line-removed"> 331     }</span>
 332 
 333     Page* page = frame().page();
 334     if (page &amp;&amp; page-&gt;chrome().client().shouldPaintEntireContents())
 335         setPaintsEntireContents(true);
 336 }
 337 
 338 void FrameView::prepareForDetach()
 339 {
 340     detachCustomScrollbars();
 341     // When the view is no longer associated with a frame, it needs to be removed from the ax object cache
 342     // right now, otherwise it won&#39;t be able to reach the topDocument()&#39;s axObject cache later.
 343     removeFromAXObjectCache();
 344 
 345     if (frame().page()) {
 346         if (ScrollingCoordinator* scrollingCoordinator = frame().page()-&gt;scrollingCoordinator())
 347             scrollingCoordinator-&gt;willDestroyScrollableArea(*this);
 348     }
 349 }
 350 
 351 void FrameView::detachCustomScrollbars()
</pre>
<hr />
<pre>
 441         if (auto* page = frame().page())
 442             page-&gt;chrome().invalidateContentsAndRootView(rect);
 443         return;
 444     }
 445 
 446     auto* renderer = frame().ownerRenderer();
 447     if (!renderer)
 448         return;
 449 
 450     IntRect repaintRect = rect;
 451     repaintRect.moveBy(roundedIntPoint(renderer-&gt;contentBoxLocation()));
 452     renderer-&gt;repaintRectangle(repaintRect);
 453 }
 454 
 455 void FrameView::setFrameRect(const IntRect&amp; newRect)
 456 {
 457     Ref&lt;FrameView&gt; protectedThis(*this);
 458     IntRect oldRect = frameRect();
 459     if (newRect == oldRect)
 460         return;

 461     // Every scroll that happens as the result of frame size change is programmatic.
<span class="line-modified"> 462     SetForScope&lt;bool&gt; changeInProgrammaticScroll(m_inProgrammaticScroll, true);</span>


 463     ScrollView::setFrameRect(newRect);
 464 
 465     updateScrollableAreaSet();
 466 
 467     if (RenderView* renderView = this-&gt;renderView()) {
 468         if (renderView-&gt;usesCompositing())
 469             renderView-&gt;compositor().frameViewDidChangeSize();
 470     }
 471 
 472     if (frame().isMainFrame() &amp;&amp; frame().page())
 473         frame().page()-&gt;pageOverlayController().didChangeViewSize();
 474 
 475     viewportContentsChanged();

 476 }
 477 
 478 bool FrameView::scheduleAnimation()
 479 {
 480     auto* page = frame().page();
 481     if (!page)
 482         return false;
 483     page-&gt;chrome().scheduleAnimation();
 484     return true;
 485 }
 486 
<span class="line-removed"> 487 void FrameView::setMarginWidth(LayoutUnit w)</span>
<span class="line-removed"> 488 {</span>
<span class="line-removed"> 489     // make it update the rendering area when set</span>
<span class="line-removed"> 490     m_margins.setWidth(w);</span>
<span class="line-removed"> 491 }</span>
<span class="line-removed"> 492 </span>
<span class="line-removed"> 493 void FrameView::setMarginHeight(LayoutUnit h)</span>
<span class="line-removed"> 494 {</span>
<span class="line-removed"> 495     // make it update the rendering area when set</span>
<span class="line-removed"> 496     m_margins.setHeight(h);</span>
<span class="line-removed"> 497 }</span>
<span class="line-removed"> 498 </span>
 499 FrameFlattening FrameView::effectiveFrameFlattening() const
 500 {
 501 #if PLATFORM(IOS_FAMILY)
 502     // On iOS when async frame scrolling is enabled, it does not make sense to use full frame flattening.
 503     // In that case, we just consider that frame flattening is disabled. This allows people to test
 504     // frame scrolling on iOS by enabling &quot;Async Frame Scrolling&quot; via the Safari menu.
 505     if (frame().settings().asyncFrameScrollingEnabled() &amp;&amp; frame().settings().frameFlattening() == FrameFlattening::FullyEnabled)
 506         return FrameFlattening::Disabled;
 507 #endif
 508     return frame().settings().frameFlattening();
 509 }
 510 
 511 bool FrameView::frameFlatteningEnabled() const
 512 {
 513     return effectiveFrameFlattening() != FrameFlattening::Disabled;
 514 }
 515 
 516 bool FrameView::isFrameFlatteningValidForThisFrame() const
 517 {
 518     if (!frameFlatteningEnabled())
</pre>
<hr />
<pre>
1072         return platformTopContentInset();
1073 
1074     if (!frame().isMainFrame())
1075         return 0;
1076 
1077     Page* page = frame().page();
1078     return page ? page-&gt;topContentInset() : 0;
1079 }
1080 
1081 void FrameView::topContentInsetDidChange(float newTopContentInset)
1082 {
1083     RenderView* renderView = this-&gt;renderView();
1084     if (!renderView)
1085         return;
1086 
1087     if (platformWidget())
1088         platformSetTopContentInset(newTopContentInset);
1089 
1090     layoutContext().layout();
1091     // Every scroll that happens as the result of content inset change is programmatic.
<span class="line-modified">1092     SetForScope&lt;bool&gt; changeInProgrammaticScroll(m_inProgrammaticScroll, true);</span>


1093     updateScrollbars(scrollPosition());
1094     if (renderView-&gt;usesCompositing())
1095         renderView-&gt;compositor().frameViewDidChangeSize();
1096 
1097     if (TiledBacking* tiledBacking = this-&gt;tiledBacking())
1098         tiledBacking-&gt;setTopContentInset(newTopContentInset);


1099 }
1100 
1101 void FrameView::topContentDirectionDidChange()
1102 {
1103     m_needsDeferredScrollbarsUpdate = true;
1104 }
1105 
1106 void FrameView::handleDeferredScrollbarsUpdateAfterDirectionChange()
1107 {
1108     if (!m_needsDeferredScrollbarsUpdate)
1109         return;
1110 
1111     m_needsDeferredScrollbarsUpdate = false;
1112 
1113     updateScrollbars(scrollPosition());
1114     positionScrollbarLayers();
1115 }
1116 
1117 // Sometimes (for plug-ins) we need to eagerly go into compositing mode.
1118 void FrameView::enterCompositingMode()
</pre>
<hr />
<pre>
1120     if (RenderView* renderView = this-&gt;renderView()) {
1121         renderView-&gt;compositor().enableCompositingMode();
1122         if (!needsLayout())
1123             renderView-&gt;compositor().scheduleCompositingLayerUpdate();
1124     }
1125 }
1126 
1127 bool FrameView::isEnclosedInCompositingLayer() const
1128 {
1129     auto frameOwnerRenderer = frame().ownerRenderer();
1130     if (frameOwnerRenderer &amp;&amp; frameOwnerRenderer-&gt;containerForRepaint())
1131         return true;
1132 
1133     if (FrameView* parentView = parentFrameView())
1134         return parentView-&gt;isEnclosedInCompositingLayer();
1135     return false;
1136 }
1137 
1138 bool FrameView::flushCompositingStateIncludingSubframes()
1139 {
<span class="line-removed">1140 #if PLATFORM(COCOA)</span>
<span class="line-removed">1141     InspectorInstrumentation::willComposite(frame());</span>
<span class="line-removed">1142 #endif</span>
<span class="line-removed">1143 </span>
1144     bool allFramesFlushed = flushCompositingStateForThisFrame(frame());
1145 
1146     for (Frame* child = frame().tree().firstRenderedChild(); child; child = child-&gt;tree().traverseNextRendered(m_frame.ptr())) {
1147         if (!child-&gt;view())
1148             continue;
1149         bool flushed = child-&gt;view()-&gt;flushCompositingStateForThisFrame(frame());
1150         allFramesFlushed &amp;= flushed;
1151     }
1152     return allFramesFlushed;
1153 }
1154 
1155 bool FrameView::isSoftwareRenderable() const
1156 {
1157     RenderView* renderView = this-&gt;renderView();
1158     return !renderView || !renderView-&gt;compositor().has3DContent();
1159 }
1160 
1161 void FrameView::setIsInWindow(bool isInWindow)
1162 {
1163     if (RenderView* renderView = this-&gt;renderView())
</pre>
<hr />
<pre>
1243         m_firstLayoutCallbackPending = true;
1244     }
1245     adjustScrollbarsForLayout(firstLayout);
1246 
1247     auto oldSize = m_size;
1248     LayoutSize newSize = layoutSize();
1249     if (oldSize != newSize) {
1250         m_size = newSize;
1251         LOG(Layout, &quot;  layout size changed from %.3fx%.3f to %.3fx%.3f&quot;, oldSize.width().toFloat(), oldSize.height().toFloat(),     newSize.width().toFloat(), newSize.height().toFloat());
1252         layoutContext().setNeedsFullRepaint();
1253         if (!firstLayout)
1254             markRootOrBodyRendererDirty();
1255     }
1256     forceLayoutParentViewIfNeeded();
1257 }
1258 
1259 void FrameView::didLayout(WeakPtr&lt;RenderElement&gt; layoutRoot)
1260 {
1261     renderView()-&gt;releaseProtectedRenderWidgets();
1262     auto* layoutRootEnclosingLayer = layoutRoot-&gt;enclosingLayer();
<span class="line-modified">1263     layoutRootEnclosingLayer-&gt;updateLayerPositionsAfterLayout(renderView()-&gt;layer(), updateLayerPositionFlags(layoutRootEnclosingLayer, !is&lt;RenderView&gt;(*layoutRoot), layoutContext().needsFullRepaint()));</span>
1264 
1265     updateCompositingLayersAfterLayout();
1266 
1267 #if PLATFORM(COCOA) || PLATFORM(WIN) || PLATFORM(GTK)
1268     if (auto* cache = frame().document()-&gt;existingAXObjectCache())
1269         cache-&gt;postNotification(layoutRoot.get(), AXObjectCache::AXLayoutComplete);
1270 #endif
1271 
<span class="line-modified">1272     frame().document()-&gt;invalidateRenderingDependentRegions(Document::AnnotationsAction::Update);</span>
1273 
1274     updateCanBlitOnScrollRecursively();
1275 
1276     handleDeferredScrollUpdateAfterContentSizeChange();
1277 
1278     handleDeferredScrollbarsUpdateAfterDirectionChange();
1279 
1280     if (frame().document()-&gt;hasListenerType(Document::OVERFLOWCHANGED_LISTENER))
1281         updateOverflowStatus(layoutWidth() &lt; contentsWidth(), layoutHeight() &lt; contentsHeight());
1282 
1283     frame().document()-&gt;markers().invalidateRectsForAllMarkers();
1284 }
1285 
1286 bool FrameView::shouldDeferScrollUpdateAfterContentSizeChange()
1287 {
1288     return (layoutContext().layoutPhase() &lt; FrameViewLayoutContext::LayoutPhase::InPostLayout) &amp;&amp; (layoutContext().layoutPhase() != FrameViewLayoutContext::LayoutPhase::OutsideLayout);
1289 }
1290 
1291 RenderBox* FrameView::embeddedContentBox() const
1292 {
1293     RenderView* renderView = this-&gt;renderView();
1294     if (!renderView)
1295         return nullptr;
1296 
1297     RenderObject* firstChild = renderView-&gt;firstChild();
1298 
1299     // Curently only embedded SVG documents participate in the size-negotiation logic.
1300     if (is&lt;RenderSVGRoot&gt;(firstChild))
1301         return downcast&lt;RenderSVGRoot&gt;(firstChild);
1302 
1303     return nullptr;
1304 }
1305 
1306 void FrameView::addEmbeddedObjectToUpdate(RenderEmbeddedObject&amp; embeddedObject)
1307 {
1308     if (!m_embeddedObjectsToUpdate)
<span class="line-modified">1309         m_embeddedObjectsToUpdate = std::make_unique&lt;ListHashSet&lt;RenderEmbeddedObject*&gt;&gt;();</span>
1310 
1311     HTMLFrameOwnerElement&amp; element = embeddedObject.frameOwnerElement();
1312     if (is&lt;HTMLObjectElement&gt;(element) || is&lt;HTMLEmbedElement&gt;(element)) {
1313         // Tell the DOM element that it needs a widget update.
1314         HTMLPlugInImageElement&amp; pluginElement = downcast&lt;HTMLPlugInImageElement&gt;(element);
1315         if (!pluginElement.needsCheckForSizeChange())
1316             pluginElement.setNeedsWidgetUpdate(true);
1317     }
1318 
1319     m_embeddedObjectsToUpdate-&gt;add(&amp;embeddedObject);
1320 }
1321 
1322 void FrameView::removeEmbeddedObjectToUpdate(RenderEmbeddedObject&amp; embeddedObject)
1323 {
1324     if (!m_embeddedObjectsToUpdate)
1325         return;
1326 
1327     m_embeddedObjectsToUpdate-&gt;remove(&amp;embeddedObject);
1328 }
1329 
</pre>
<hr />
<pre>
1425         return;
1426     StringBuilder builder;
1427     if (frame().isMainFrame())
1428         builder.appendLiteral(&quot;Main&quot;);
1429     builder.appendLiteral(&quot;FrameView: &quot;);
1430     builder.append(message);
1431     document-&gt;addConsoleMessage(MessageSource::Other, MessageLevel::Debug, builder.toString());
1432 }
1433 
1434 void FrameView::setCannotBlitToWindow()
1435 {
1436     m_cannotBlitToWindow = true;
1437     updateCanBlitOnScrollRecursively();
1438 }
1439 
1440 void FrameView::addSlowRepaintObject(RenderElement&amp; renderer)
1441 {
1442     bool hadSlowRepaintObjects = hasSlowRepaintObjects();
1443 
1444     if (!m_slowRepaintObjects)
<span class="line-modified">1445         m_slowRepaintObjects = std::make_unique&lt;HashSet&lt;const RenderElement*&gt;&gt;();</span>
1446 
1447     m_slowRepaintObjects-&gt;add(&amp;renderer);
1448     if (hadSlowRepaintObjects)
1449         return;
1450 
1451     updateCanBlitOnScrollRecursively();
1452 
1453     if (auto* page = frame().page()) {
1454         if (auto* scrollingCoordinator = page-&gt;scrollingCoordinator())
1455             scrollingCoordinator-&gt;frameViewHasSlowRepaintObjectsDidChange(*this);
1456     }
1457 }
1458 
1459 void FrameView::removeSlowRepaintObject(RenderElement&amp; renderer)
1460 {
1461     if (!m_slowRepaintObjects)
1462         return;
1463 
1464     m_slowRepaintObjects-&gt;remove(&amp;renderer);
1465     if (!m_slowRepaintObjects-&gt;isEmpty())
1466         return;
1467 
1468     m_slowRepaintObjects = nullptr;
1469     updateCanBlitOnScrollRecursively();
1470 
1471     if (auto* page = frame().page()) {
1472         if (auto* scrollingCoordinator = page-&gt;scrollingCoordinator())
1473             scrollingCoordinator-&gt;frameViewHasSlowRepaintObjectsDidChange(*this);
1474     }
1475 }
1476 
1477 void FrameView::addViewportConstrainedObject(RenderLayerModelObject* object)
1478 {
1479     if (!m_viewportConstrainedObjects)
<span class="line-modified">1480         m_viewportConstrainedObjects = std::make_unique&lt;ViewportConstrainedObjectSet&gt;();</span>
1481 
1482     if (!m_viewportConstrainedObjects-&gt;contains(object)) {
1483         m_viewportConstrainedObjects-&gt;add(object);
1484         if (platformWidget())
1485             updateCanBlitOnScrollRecursively();
1486 
1487         if (Page* page = frame().page()) {
1488             if (ScrollingCoordinator* scrollingCoordinator = page-&gt;scrollingCoordinator())
1489                 scrollingCoordinator-&gt;frameViewFixedObjectsDidChange(*this);
1490         }
1491     }
1492 }
1493 
1494 void FrameView::removeViewportConstrainedObject(RenderLayerModelObject* object)
1495 {
1496     if (m_viewportConstrainedObjects &amp;&amp; m_viewportConstrainedObjects-&gt;remove(object)) {
1497         if (Page* page = frame().page()) {
1498             if (ScrollingCoordinator* scrollingCoordinator = page-&gt;scrollingCoordinator())
1499                 scrollingCoordinator-&gt;frameViewFixedObjectsDidChange(*this);
1500         }
1501 
1502         // FIXME: In addFixedObject() we only call this if there&#39;s a platform widget,
1503         // why isn&#39;t the same check being made here?
1504         updateCanBlitOnScrollRecursively();
1505     }
1506 }
1507 
1508 LayoutSize FrameView::expandedLayoutViewportSize(const LayoutSize&amp; baseLayoutViewportSize, const LayoutSize&amp; documentSize, double heightExpansionFactor)
1509 {
1510     if (!heightExpansionFactor)
1511         return baseLayoutViewportSize;
1512 
1513     auto documentHeight = documentSize.height();
1514     auto layoutViewportHeight = baseLayoutViewportSize.height();
1515     if (layoutViewportHeight &gt; documentHeight)
1516         return baseLayoutViewportSize;
1517 
<span class="line-modified">1518     return { baseLayoutViewportSize.width(), std::min&lt;LayoutUnit&gt;(documentHeight, (1 + heightExpansionFactor) * layoutViewportHeight) };</span>
1519 }
1520 
1521 LayoutRect FrameView::computeUpdatedLayoutViewportRect(const LayoutRect&amp; layoutViewport, const LayoutRect&amp; documentRect, const LayoutSize&amp; unobscuredContentSize, const LayoutRect&amp; unobscuredContentRect, const LayoutSize&amp; baseLayoutViewportSize, const LayoutPoint&amp; stableLayoutViewportOriginMin, const LayoutPoint&amp; stableLayoutViewportOriginMax, LayoutViewportConstraint constraint)
1522 {
1523     LayoutRect layoutViewportRect = layoutViewport;
1524 
1525     // The layout viewport is never smaller than baseLayoutViewportSize, and never be smaller than the unobscuredContentRect.
1526     LayoutSize constrainedSize = baseLayoutViewportSize;
1527     layoutViewportRect.setSize(constrainedSize.expandedTo(unobscuredContentSize));
1528 
1529     LayoutPoint layoutViewportOrigin = computeLayoutViewportOrigin(unobscuredContentRect, stableLayoutViewportOriginMin, stableLayoutViewportOriginMax, layoutViewportRect, StickToViewportBounds);
1530 
1531     // FIXME: Is this equivalent to calling computeLayoutViewportOrigin() with StickToDocumentBounds?
1532     if (constraint == LayoutViewportConstraint::ConstrainedToDocumentRect) {
1533         // The max stable layout viewport origin really depends on the size of the layout viewport itself, so we need to adjust the location of the layout viewport one final time to make sure it does not end up out of bounds of the document.
1534         // Without this adjustment (and with using the non-constrained unobscuredContentRect&#39;s size as the size of the layout viewport) the layout viewport can be pushed past the bounds of the document during rubber-banding, and cannot be pushed
1535         // back in until the user scrolls back in the other direction.
1536         layoutViewportOrigin.setX(clampTo&lt;float&gt;(layoutViewportOrigin.x().toFloat(), 0, documentRect.width() - layoutViewportRect.width()));
1537         layoutViewportOrigin.setY(clampTo&lt;float&gt;(layoutViewportOrigin.y().toFloat(), 0, documentRect.height() - layoutViewportRect.height()));
1538     }
</pre>
<hr />
<pre>
1647 }
1648 
1649 void FrameView::updateLayoutViewport()
1650 {
1651     if (!frame().settings().visualViewportEnabled())
1652         return;
1653 
1654     // Don&#39;t update the layout viewport if we&#39;re in the middle of adjusting scrollbars. We&#39;ll get another call
1655     // as a post-layout task.
1656     if (layoutContext().layoutPhase() == FrameViewLayoutContext::LayoutPhase::InViewSizeAdjust)
1657         return;
1658 
1659     LayoutRect layoutViewport = layoutViewportRect();
1660 
1661     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;\nFrameView &quot; &lt;&lt; this &lt;&lt; &quot; updateLayoutViewport() totalContentSize &quot; &lt;&lt; totalContentsSize() &lt;&lt; &quot; unscaledDocumentRect &quot; &lt;&lt; (renderView() ? renderView()-&gt;unscaledDocumentRect() : IntRect()) &lt;&lt; &quot; header height &quot; &lt;&lt; headerHeight() &lt;&lt; &quot; footer height &quot; &lt;&lt; footerHeight() &lt;&lt; &quot; fixed behavior &quot; &lt;&lt; scrollBehaviorForFixedElements());
1662     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;layoutViewport: &quot; &lt;&lt; layoutViewport);
1663     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;visualViewport: &quot; &lt;&lt; visualViewportRect() &lt;&lt; &quot; (is override &quot; &lt;&lt; (bool)m_visualViewportOverrideRect &lt;&lt; &quot;)&quot;);
1664     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;stable origins: min: &quot; &lt;&lt; minStableLayoutViewportOrigin() &lt;&lt; &quot; max: &quot;&lt;&lt; maxStableLayoutViewportOrigin());
1665 
1666     if (m_layoutViewportOverrideRect) {
<span class="line-modified">1667         if (m_inProgrammaticScroll) {</span>
1668             LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;computing new override layout viewport because of programmatic scrolling&quot;);
1669             LayoutPoint newOrigin = computeLayoutViewportOrigin(visualViewportRect(), minStableLayoutViewportOrigin(), maxStableLayoutViewportOrigin(), layoutViewport, StickToDocumentBounds);
1670             setLayoutViewportOverrideRect(LayoutRect(newOrigin, m_layoutViewportOverrideRect.value().size()));
1671         }
<span class="line-modified">1672         if (frame().settings().visualViewportAPIEnabled()) {</span>
<span class="line-removed">1673             if (auto* window = frame().window())</span>
<span class="line-removed">1674                 window-&gt;visualViewport().update();</span>
<span class="line-removed">1675         }</span>
1676         return;
1677     }
1678 
1679     LayoutPoint newLayoutViewportOrigin = computeLayoutViewportOrigin(visualViewportRect(), minStableLayoutViewportOrigin(), maxStableLayoutViewportOrigin(), layoutViewport, scrollBehaviorForFixedElements());
1680     if (newLayoutViewportOrigin != m_layoutViewportOrigin) {
1681         setBaseLayoutViewportOrigin(newLayoutViewportOrigin);
1682         LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;layoutViewport changed to &quot; &lt;&lt; layoutViewportRect());
1683     }
<span class="line-modified">1684     if (frame().settings().visualViewportAPIEnabled()) {</span>
<span class="line-removed">1685         if (auto* window = frame().window())</span>
<span class="line-removed">1686             window-&gt;visualViewport().update();</span>
<span class="line-removed">1687     }</span>
1688 }
1689 
1690 LayoutPoint FrameView::minStableLayoutViewportOrigin() const
1691 {
1692     return unscaledMinimumScrollPosition();
1693 }
1694 
1695 LayoutPoint FrameView::maxStableLayoutViewportOrigin() const
1696 {
1697     LayoutPoint maxPosition = unscaledMaximumScrollPosition();
1698     maxPosition = (maxPosition - LayoutSize(0, headerHeight() + footerHeight())).expandedTo({ });
1699     return maxPosition;
1700 }
1701 
1702 IntPoint FrameView::unscaledScrollOrigin() const
1703 {
1704     if (RenderView* renderView = this-&gt;renderView())
1705         return -renderView-&gt;unscaledDocumentRect().location(); // Akin to code in adjustViewSize().
1706 
1707     return { };
</pre>
<hr />
<pre>
1945 
1946 void FrameView::viewportContentsChanged()
1947 {
1948     if (!frame().view()) {
1949         // The frame is being destroyed.
1950         return;
1951     }
1952 
1953     if (auto* page = frame().page())
1954         page-&gt;updateValidationBubbleStateIfNeeded();
1955 
1956     // When the viewport contents changes (scroll, resize, style recalc, layout, ...),
1957     // check if we should resume animated images or unthrottle DOM timers.
1958     applyRecursivelyWithVisibleRect([] (FrameView&amp; frameView, const IntRect&amp; visibleRect) {
1959         frameView.resumeVisibleImageAnimations(visibleRect);
1960         frameView.updateScriptedAnimationsAndTimersThrottlingState(visibleRect);
1961 
1962         if (auto* renderView = frameView.frame().contentRenderer())
1963             renderView-&gt;updateVisibleViewportRect(visibleRect);
1964     });
<span class="line-removed">1965 </span>
<span class="line-removed">1966 #if ENABLE(INTERSECTION_OBSERVER)</span>
<span class="line-removed">1967     if (auto* document = frame().document()) {</span>
<span class="line-removed">1968         if (auto* page = frame().page()) {</span>
<span class="line-removed">1969             if (document-&gt;numberOfIntersectionObservers())</span>
<span class="line-removed">1970                 page-&gt;addDocumentNeedingIntersectionObservationUpdate(*document);</span>
<span class="line-removed">1971             if (!frame().isMainFrame()) {</span>
<span class="line-removed">1972                 if (auto* mainDocument = frame().mainFrame().document()) {</span>
<span class="line-removed">1973                     if (mainDocument-&gt;numberOfIntersectionObservers())</span>
<span class="line-removed">1974                         page-&gt;addDocumentNeedingIntersectionObservationUpdate(*mainDocument);</span>
<span class="line-removed">1975                 }</span>
<span class="line-removed">1976             }</span>
<span class="line-removed">1977         }</span>
<span class="line-removed">1978     }</span>
<span class="line-removed">1979 #endif</span>
1980 }
1981 
<span class="line-modified">1982 IntRect FrameView::unobscuredContentRectExpandedByContentInsets() const</span>
1983 {
<span class="line-modified">1984     FloatRect unobscuredContentRect = this-&gt;unobscuredContentRect();</span>





1985     if (auto* page = frame().page())
<span class="line-modified">1986         unobscuredContentRect.expand(page-&gt;contentInsets());</span>
<span class="line-modified">1987     return IntRect(unobscuredContentRect);</span>

1988 }
1989 
1990 bool FrameView::fixedElementsLayoutRelativeToFrame() const
1991 {
1992     return frame().settings().fixedElementsLayoutRelativeToFrame();
1993 }
1994 
1995 IntPoint FrameView::lastKnownMousePosition() const
1996 {
1997     return frame().eventHandler().lastKnownMousePosition();
1998 }
1999 
2000 bool FrameView::isHandlingWheelEvent() const
2001 {
2002     return frame().eventHandler().isHandlingWheelEvent();
2003 }
2004 
2005 bool FrameView::shouldSetCursor() const
2006 {
2007     Page* page = frame().page();
2008     return page &amp;&amp; page-&gt;isVisible() &amp;&amp; page-&gt;focusController().isActive();
2009 }
2010 
2011 #if ENABLE(DARK_MODE_CSS)
<span class="line-modified">2012 RenderObject* FrameView::rendererForSupportedColorSchemes() const</span>
2013 {
2014     auto* document = frame().document();
2015     auto* documentElement = document ? document-&gt;documentElement() : nullptr;
2016     auto* documentElementRenderer = documentElement ? documentElement-&gt;renderer() : nullptr;
<span class="line-modified">2017     if (documentElementRenderer &amp;&amp; documentElementRenderer-&gt;style().hasExplicitlySetSupportedColorSchemes())</span>
2018         return documentElementRenderer;
2019     auto* bodyElement = document ? document-&gt;bodyOrFrameset() : nullptr;
2020     return bodyElement ? bodyElement-&gt;renderer() : nullptr;
2021 }
2022 #endif
2023 
2024 bool FrameView::useDarkAppearance() const
2025 {
2026 #if ENABLE(DARK_MODE_CSS)
<span class="line-modified">2027     if (auto* renderer = rendererForSupportedColorSchemes())</span>
2028         return renderer-&gt;useDarkAppearance();
2029 #endif
2030     if (auto* document = frame().document())
2031         return document-&gt;useDarkAppearance(nullptr);
2032     return false;
2033 }
2034 
2035 OptionSet&lt;StyleColor::Options&gt; FrameView::styleColorOptions() const
2036 {
2037 #if ENABLE(DARK_MODE_CSS)
<span class="line-modified">2038     if (auto* renderer = rendererForSupportedColorSchemes())</span>
2039         return renderer-&gt;styleColorOptions();
2040 #endif
2041     if (auto* document = frame().document())
2042         return document-&gt;styleColorOptions(nullptr);
2043     return { };
2044 }
2045 
2046 bool FrameView::scrollContentsFastPath(const IntSize&amp; scrollDelta, const IntRect&amp; rectToScroll, const IntRect&amp; clipRect)
2047 {
2048     if (!m_viewportConstrainedObjects || m_viewportConstrainedObjects-&gt;isEmpty()) {
2049         frame().page()-&gt;chrome().scroll(scrollDelta, rectToScroll, clipRect);
2050         return true;
2051     }
2052 
2053     bool isCompositedContentLayer = usesCompositedScrolling();
2054 
2055     // Get the rects of the fixed objects visible in the rectToScroll
2056     Region regionToUpdate;
2057     for (auto&amp; renderer : *m_viewportConstrainedObjects) {
2058         if (!renderer-&gt;style().hasViewportConstrainedPosition())
</pre>
<hr />
<pre>
2251     else
2252         scrollToAnchor();
2253 }
2254 
2255 void FrameView::scrollElementToRect(const Element&amp; element, const IntRect&amp; rect)
2256 {
2257     frame().document()-&gt;updateLayoutIgnorePendingStylesheets();
2258 
2259     LayoutRect bounds;
2260     if (RenderElement* renderer = element.renderer())
2261         bounds = renderer-&gt;absoluteAnchorRect();
2262     int centeringOffsetX = (rect.width() - bounds.width()) / 2;
2263     int centeringOffsetY = (rect.height() - bounds.height()) / 2;
2264     setScrollPosition(IntPoint(bounds.x() - centeringOffsetX - rect.x(), bounds.y() - centeringOffsetY - rect.y()));
2265 }
2266 
2267 void FrameView::setScrollPosition(const ScrollPosition&amp; scrollPosition)
2268 {
2269     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;FrameView::setScrollPosition &quot; &lt;&lt; scrollPosition &lt;&lt; &quot; , clearing anchor&quot;);
2270 
<span class="line-modified">2271     SetForScope&lt;bool&gt; changeInProgrammaticScroll(m_inProgrammaticScroll, true);</span>


2272     m_maintainScrollPositionAnchor = nullptr;
2273     m_shouldScrollToFocusedElement = false;
2274     m_delayedScrollToFocusedElementTimer.stop();
2275     Page* page = frame().page();
2276     if (page &amp;&amp; page-&gt;expectsWheelEventTriggers())
2277         scrollAnimator().setWheelEventTestTrigger(page-&gt;testTrigger());
2278     ScrollView::setScrollPosition(scrollPosition);


2279 }
2280 
2281 void FrameView::resetScrollAnchor()
2282 {
2283     ASSERT(frame().document());
2284     auto&amp; document = *frame().document();
2285 
2286     // If CSS target was set previously, we want to set it to 0, recalc
2287     // and possibly repaint because :target pseudo class may have been
2288     // set (see bug 11321).
2289     document.setCSSTarget(nullptr);
2290 
2291     if (is&lt;SVGDocument&gt;(document)) {
2292         if (auto rootElement = SVGDocument::rootElement(document)) {
2293             // We need to update the layout before resetScrollAnchor(), otherwise we
2294             // could really mess things up if resetting the anchor comes at a bad moment.
2295             document.updateStyleIfNeeded();
2296             rootElement-&gt;resetScrollAnchor();
2297         }
2298     }
</pre>
<hr />
<pre>
2532 
2533 bool FrameView::shouldUpdateCompositingLayersAfterScrolling() const
2534 {
2535 #if ENABLE(ASYNC_SCROLLING)
2536     // If the scrolling thread is updating the fixed elements, then the FrameView should not update them as well.
2537 
2538     Page* page = frame().page();
2539     if (!page)
2540         return true;
2541 
2542     if (&amp;page-&gt;mainFrame() != m_frame.ptr())
2543         return true;
2544 
2545     ScrollingCoordinator* scrollingCoordinator = page-&gt;scrollingCoordinator();
2546     if (!scrollingCoordinator)
2547         return true;
2548 
2549     if (scrollingCoordinator-&gt;shouldUpdateScrollLayerPositionSynchronously(*this))
2550         return true;
2551 
<span class="line-modified">2552     if (inProgrammaticScroll())</span>
2553         return true;
2554 
2555     return false;
2556 #endif
2557     return true;
2558 }
2559 
2560 void FrameView::updateCompositingLayersAfterScrolling()
2561 {
2562     ASSERT(layoutContext().layoutPhase() &gt;= FrameViewLayoutContext::LayoutPhase::InPostLayout || layoutContext().layoutPhase() == FrameViewLayoutContext::LayoutPhase::OutsideLayout);
2563 
2564     if (!shouldUpdateCompositingLayersAfterScrolling())
2565         return;
2566 
2567     if (!layoutContext().isLayoutNested() &amp;&amp; hasViewportConstrainedObjects()) {
2568         if (RenderView* renderView = this-&gt;renderView())
2569             renderView-&gt;compositor().updateCompositingLayers(CompositingUpdateType::OnScroll);
2570     }
2571 }
2572 
</pre>
<hr />
<pre>
2751 
2752     TiledBacking::Scrollability scrollability = TiledBacking::NotScrollable;
2753     if (horizontallyScrollable)
2754         scrollability = TiledBacking::HorizontallyScrollable;
2755 
2756     if (verticallyScrollable)
2757         scrollability |= TiledBacking::VerticallyScrollable;
2758 
2759     return scrollability;
2760 }
2761 
2762 void FrameView::updateTiledBackingAdaptiveSizing()
2763 {
2764     auto* tiledBacking = this-&gt;tiledBacking();
2765     if (!tiledBacking)
2766         return;
2767 
2768     tiledBacking-&gt;setScrollability(computeScrollability());
2769 }
2770 
<span class="line-modified">2771 #if PLATFORM(IOS_FAMILY)</span>
<span class="line-modified">2772 </span>
<span class="line-removed">2773 void FrameView::didUpdateViewportOverrideRects()</span>
2774 {
2775     if (!frame().settings().visualViewportAPIEnabled())
2776         return;
2777 
2778     if (auto* window = frame().window())
2779         window-&gt;visualViewport().update();





2780 }
2781 


2782 void FrameView::unobscuredContentSizeChanged()
2783 {
2784     updateTiledBackingAdaptiveSizing();
2785 }
2786 
2787 #endif
2788 
2789 static LayerFlushThrottleState::Flags determineLayerFlushThrottleState(Page&amp; page)
2790 {
2791     // We only throttle when constantly receiving new data during the inital page load.
2792     if (!page.progress().isMainLoadProgressing())
2793         return 0;
2794     // Scrolling during page loading disables throttling.
2795     if (page.mainFrame().view()-&gt;wasScrolledByUser())
2796         return 0;
2797     // Disable for image documents so large GIF animations don&#39;t get throttled during loading.
2798     auto* document = page.mainFrame().document();
2799     if (!document || is&lt;ImageDocument&gt;(*document))
2800         return 0;
2801     return LayerFlushThrottleState::Enabled;
</pre>
<hr />
<pre>
2908 
2909 void FrameView::hide()
2910 {
2911     ScrollView::hide();
2912     adjustTiledBackingCoverage();
2913 }
2914 
2915 bool FrameView::needsLayout() const
2916 {
2917     return layoutContext().needsLayout();
2918 }
2919 
2920 void FrameView::setNeedsLayoutAfterViewConfigurationChange()
2921 {
2922     layoutContext().setNeedsLayoutAfterViewConfigurationChange();
2923 }
2924 
2925 void FrameView::setNeedsCompositingConfigurationUpdate()
2926 {
2927     RenderView* renderView = this-&gt;renderView();
<span class="line-modified">2928     if (renderView-&gt;usesCompositing()) {</span>
2929         if (auto* rootLayer = renderView-&gt;layer())
2930             rootLayer-&gt;setNeedsCompositingConfigurationUpdate();
2931         renderView-&gt;compositor().scheduleCompositingLayerUpdate();
2932     }
2933 }
2934 
2935 void FrameView::setNeedsCompositingGeometryUpdate()
2936 {
2937     RenderView* renderView = this-&gt;renderView();
2938     if (renderView-&gt;usesCompositing()) {
2939         if (auto* rootLayer = renderView-&gt;layer())
2940             rootLayer-&gt;setNeedsCompositingGeometryUpdate();
2941         renderView-&gt;compositor().scheduleCompositingLayerUpdate();
2942     }
2943 }
2944 
2945 void FrameView::scheduleSelectionUpdate()
2946 {
2947     if (needsLayout())
2948         return;
</pre>
<hr />
<pre>
2969     // and must not update compositing layers.
2970     if (!isViewForDocumentInFrame())
2971         return;
2972 
2973     setNeedsLayoutAfterViewConfigurationChange();
2974     setNeedsCompositingConfigurationUpdate();
2975 }
2976 
2977 bool FrameView::hasOpaqueBackground() const
2978 {
2979     return !m_isTransparent &amp;&amp; m_baseBackgroundColor.isOpaque();
2980 }
2981 
2982 Color FrameView::baseBackgroundColor() const
2983 {
2984     return m_baseBackgroundColor;
2985 }
2986 
2987 void FrameView::setBaseBackgroundColor(const Color&amp; backgroundColor)
2988 {
<span class="line-modified">2989     m_baseBackgroundColor = backgroundColor.isValid() ? backgroundColor : Color::white;</span>




2990 
2991     if (!isViewForDocumentInFrame())
2992         return;
2993 
2994     recalculateScrollbarOverlayStyle();
2995     setNeedsLayoutAfterViewConfigurationChange();
2996     setNeedsCompositingConfigurationUpdate();
2997 }
2998 
2999 void FrameView::updateBackgroundRecursively(const Optional&lt;Color&gt;&amp; backgroundColor)
3000 {
<span class="line-modified">3001 #if ENABLE(DARK_MODE_CSS) &amp;&amp; PLATFORM(MAC)</span>
3002     Color baseBackgroundColor = backgroundColor.valueOr(RenderTheme::singleton().systemColor(CSSValueAppleSystemControlBackground, styleColorOptions()));
3003 #else
3004     Color baseBackgroundColor = backgroundColor.valueOr(Color::white);
3005 #endif
3006 
3007     for (auto* frame = m_frame.ptr(); frame; frame = frame-&gt;tree().traverseNext(m_frame.ptr())) {
3008         if (FrameView* view = frame-&gt;view()) {
3009             view-&gt;setTransparent(!baseBackgroundColor.isVisible());
3010             view-&gt;setBaseBackgroundColor(baseBackgroundColor);
3011             if (view-&gt;needsLayout())
3012                 view-&gt;layoutContext().scheduleLayout();
3013         }
3014     }
3015 }
3016 
3017 bool FrameView::hasExtendedBackgroundRectForPainting() const
3018 {
3019     TiledBacking* tiledBacking = this-&gt;tiledBacking();
3020     if (!tiledBacking)
3021         return false;
</pre>
<hr />
<pre>
3423     ScrollView::willEndLiveResize();
3424     adjustTiledBackingCoverage();
3425 }
3426 
3427 void FrameView::autoSizeIfEnabled()
3428 {
3429     if (!m_shouldAutoSize)
3430         return;
3431 
3432     if (m_inAutoSize)
3433         return;
3434 
3435     auto* document = frame().document();
3436     if (!document)
3437         return;
3438 
3439     auto* renderView = document-&gt;renderView();
3440     if (!renderView)
3441         return;
3442 




3443     LOG(Layout, &quot;FrameView %p autoSizeIfEnabled&quot;, this);
3444     SetForScope&lt;bool&gt; changeInAutoSize(m_inAutoSize, true);
3445     if (layoutContext().subtreeLayoutRoot())
3446         layoutContext().convertSubtreeLayoutToFullLayout();
<span class="line-removed">3447     // Start from the minimum size and allow it to grow.</span>
<span class="line-removed">3448     resize(m_minAutoSize.width(), m_minAutoSize.height());</span>
<span class="line-removed">3449     IntSize size = frameRect().size();</span>
<span class="line-removed">3450     // Do the resizing twice. The first time is basically a rough calculation using the preferred width</span>
<span class="line-removed">3451     // which may result in a height change during the second iteration.</span>
<span class="line-removed">3452     for (int i = 0; i &lt; 2; i++) {</span>
<span class="line-removed">3453         // Update various sizes including contentsSize, scrollHeight, etc.</span>
<span class="line-removed">3454         document-&gt;updateLayoutIgnorePendingStylesheets();</span>
<span class="line-removed">3455         int width = renderView-&gt;minPreferredLogicalWidth();</span>
<span class="line-removed">3456         int height = renderView-&gt;documentRect().height();</span>
<span class="line-removed">3457         IntSize newSize(width, height);</span>
<span class="line-removed">3458 </span>
<span class="line-removed">3459         // Check to see if a scrollbar is needed for a given dimension and</span>
<span class="line-removed">3460         // if so, increase the other dimension to account for the scrollbar.</span>
<span class="line-removed">3461         // Since the dimensions are only for the view rectangle, once a</span>
<span class="line-removed">3462         // dimension exceeds the maximum, there is no need to increase it further.</span>
<span class="line-removed">3463         if (newSize.width() &gt; m_maxAutoSize.width()) {</span>
<span class="line-removed">3464             RefPtr&lt;Scrollbar&gt; localHorizontalScrollbar = horizontalScrollbar();</span>
<span class="line-removed">3465             if (!localHorizontalScrollbar)</span>
<span class="line-removed">3466                 localHorizontalScrollbar = createScrollbar(HorizontalScrollbar);</span>
<span class="line-removed">3467             newSize.expand(0, localHorizontalScrollbar-&gt;occupiedHeight());</span>
<span class="line-removed">3468 </span>
<span class="line-removed">3469             // Don&#39;t bother checking for a vertical scrollbar because the width is at</span>
<span class="line-removed">3470             // already greater the maximum.</span>
<span class="line-removed">3471         } else if (newSize.height() &gt; m_maxAutoSize.height()) {</span>
<span class="line-removed">3472             RefPtr&lt;Scrollbar&gt; localVerticalScrollbar = verticalScrollbar();</span>
<span class="line-removed">3473             if (!localVerticalScrollbar)</span>
<span class="line-removed">3474                 localVerticalScrollbar = createScrollbar(VerticalScrollbar);</span>
<span class="line-removed">3475             newSize.expand(localVerticalScrollbar-&gt;occupiedWidth(), 0);</span>
<span class="line-removed">3476 </span>
<span class="line-removed">3477             // Don&#39;t bother checking for a horizontal scrollbar because the height is</span>
<span class="line-removed">3478             // already greater the maximum.</span>
<span class="line-removed">3479         }</span>
<span class="line-removed">3480 </span>
<span class="line-removed">3481         // Ensure the size is at least the min bounds.</span>
<span class="line-removed">3482         newSize = newSize.expandedTo(m_minAutoSize);</span>
<span class="line-removed">3483 </span>
<span class="line-removed">3484         // Bound the dimensions by the max bounds and determine what scrollbars to show.</span>
<span class="line-removed">3485         ScrollbarMode horizonalScrollbarMode = ScrollbarAlwaysOff;</span>
<span class="line-removed">3486         if (newSize.width() &gt; m_maxAutoSize.width()) {</span>
<span class="line-removed">3487             newSize.setWidth(m_maxAutoSize.width());</span>
<span class="line-removed">3488             horizonalScrollbarMode = ScrollbarAlwaysOn;</span>
<span class="line-removed">3489         }</span>
<span class="line-removed">3490         ScrollbarMode verticalScrollbarMode = ScrollbarAlwaysOff;</span>
<span class="line-removed">3491         if (newSize.height() &gt; m_maxAutoSize.height()) {</span>
<span class="line-removed">3492             newSize.setHeight(m_maxAutoSize.height());</span>
<span class="line-removed">3493             verticalScrollbarMode = ScrollbarAlwaysOn;</span>
<span class="line-removed">3494         }</span>
3495 
<span class="line-modified">3496         if (newSize == size)</span>
<span class="line-modified">3497             continue;</span>



3498 
<span class="line-modified">3499         // While loading only allow the size to increase (to avoid twitching during intermediate smaller states)</span>
<span class="line-modified">3500         // unless autoresize has just been turned on or the maximum size is smaller than the current size.</span>
<span class="line-modified">3501         if (m_didRunAutosize &amp;&amp; size.height() &lt;= m_maxAutoSize.height() &amp;&amp; size.width() &lt;= m_maxAutoSize.width()</span>
<span class="line-modified">3502             &amp;&amp; !frame().loader().isComplete() &amp;&amp; (newSize.height() &lt; size.height() || newSize.width() &lt; size.width()))</span>
<span class="line-removed">3503             break;</span>
3504 
<span class="line-removed">3505         // The first time around, resize to the minimum height again; otherwise,</span>
<span class="line-removed">3506         // on pages (e.g. quirks mode) where the body/document resize to the view size,</span>
<span class="line-removed">3507         // we&#39;ll end up not shrinking back down after resizing to the computed preferred width.</span>
<span class="line-removed">3508         resize(newSize.width(), i ? newSize.height() : m_minAutoSize.height());</span>
<span class="line-removed">3509         // Force the scrollbar state to avoid the scrollbar code adding them and causing them to be needed. For example,</span>
<span class="line-removed">3510         // a vertical scrollbar may cause text to wrap and thus increase the height (which is the only reason the scollbar is needed).</span>
<span class="line-removed">3511         setVerticalScrollbarLock(false);</span>
<span class="line-removed">3512         setHorizontalScrollbarLock(false);</span>
<span class="line-removed">3513         setScrollbarModes(horizonalScrollbarMode, verticalScrollbarMode, true, true);</span>
<span class="line-removed">3514     }</span>
3515     Ref&lt;FrameView&gt; protectedThis(*this);
<span class="line-removed">3516     // All the resizing above may have invalidated style (for example if viewport units are being used).</span>
3517     document-&gt;updateStyleIfNeeded();
<span class="line-modified">3518     // FIXME: Use the final layout&#39;s result as the content size (webkit.org/b/173561).</span>



3519     m_autoSizeContentSize = contentsSize();
<span class="line-removed">3520     if (m_autoSizeFixedMinimumHeight) {</span>
<span class="line-removed">3521         auto contentsSize = this-&gt;contentsSize();</span>
<span class="line-removed">3522         resize(contentsSize.width(), std::max(m_autoSizeFixedMinimumHeight, contentsSize.height()));</span>
<span class="line-removed">3523         document-&gt;updateLayoutIgnorePendingStylesheets();</span>
<span class="line-removed">3524     }</span>
<span class="line-removed">3525     m_didRunAutosize = true;</span>
3526 
<span class="line-modified">3527     LOG_WITH_STREAM(Layout, stream &lt;&lt; &quot;FrameView &quot; &lt;&lt; this &lt;&lt; &quot; autoSizeIfEnabled() changed size from &quot; &lt;&lt; size &lt;&lt; &quot; to &quot; &lt;&lt; frameRect().size());</span>






3528 }
3529 
3530 void FrameView::setAutoSizeFixedMinimumHeight(int fixedMinimumHeight)
3531 {
3532     if (m_autoSizeFixedMinimumHeight == fixedMinimumHeight)
3533         return;
3534 
3535     m_autoSizeFixedMinimumHeight = fixedMinimumHeight;
3536 
3537     setNeedsLayoutAfterViewConfigurationChange();
3538 }
3539 
3540 RenderElement* FrameView::viewportRenderer() const
3541 {
3542     if (m_viewportRendererType == ViewportRendererType::None)
3543         return nullptr;
3544 
3545     auto* document = frame().document();
3546     if (!document)
3547         return nullptr;
</pre>
<hr />
<pre>
4078 
4079     GraphicsContext context(paintInvalidationReasons);
4080     if (platformWidget()) {
4081         // FIXME: consult paintsEntireContents().
4082         paintContents(context, visibleContentRect(LegacyIOSDocumentVisibleRect));
4083     } else
4084         paint(context, frameRect());
4085 }
4086 
4087 bool FrameView::wasScrolledByUser() const
4088 {
4089     return m_wasScrolledByUser;
4090 }
4091 
4092 void FrameView::setWasScrolledByUser(bool wasScrolledByUser)
4093 {
4094     LOG(Scrolling, &quot;FrameView::setWasScrolledByUser at %d&quot;, wasScrolledByUser);
4095 
4096     m_shouldScrollToFocusedElement = false;
4097     m_delayedScrollToFocusedElementTimer.stop();
<span class="line-modified">4098     if (m_inProgrammaticScroll)</span>
4099         return;
4100     m_maintainScrollPositionAnchor = nullptr;
4101     if (m_wasScrolledByUser == wasScrolledByUser)
4102         return;
4103     m_wasScrolledByUser = wasScrolledByUser;
4104     if (frame().isMainFrame())
4105         updateLayerFlushThrottling();
4106     adjustTiledBackingCoverage();
4107 }
4108 
4109 void FrameView::willPaintContents(GraphicsContext&amp; context, const IntRect&amp;, PaintingState&amp; paintingState)
4110 {
4111     Document* document = frame().document();
4112 
4113     if (!context.paintingDisabled())
4114         InspectorInstrumentation::willPaint(*renderView());
4115 
4116     paintingState.isTopLevelPainter = !sCurrentPaintTimeStamp;
4117 
4118     if (paintingState.isTopLevelPainter)
</pre>
<hr />
<pre>
4137     }
4138 
4139     paintingState.isFlatteningPaintOfRootFrame = (m_paintBehavior &amp; PaintBehavior::FlattenCompositingLayers) &amp;&amp; !frame().ownerElement();
4140     if (paintingState.isFlatteningPaintOfRootFrame)
4141         notifyWidgetsInAllFrames(WillPaintFlattened);
4142 
4143     ASSERT(!m_isPainting);
4144     m_isPainting = true;
4145 }
4146 
4147 void FrameView::didPaintContents(GraphicsContext&amp; context, const IntRect&amp; dirtyRect, PaintingState&amp; paintingState)
4148 {
4149     m_isPainting = false;
4150 
4151     if (paintingState.isFlatteningPaintOfRootFrame)
4152         notifyWidgetsInAllFrames(DidPaintFlattened);
4153 
4154     m_paintBehavior = paintingState.paintBehavior;
4155     m_lastPaintTime = MonotonicTime::now();
4156 
<span class="line-removed">4157     // Regions may have changed as a result of the visibility/z-index of element changing.</span>
<span class="line-removed">4158     frame().document()-&gt;updateZOrderDependentRegions();</span>
<span class="line-removed">4159 </span>
4160     if (paintingState.isTopLevelPainter)
4161         sCurrentPaintTimeStamp = MonotonicTime();
4162 
4163     if (!context.paintingDisabled()) {
4164         InspectorInstrumentation::didPaint(*renderView(), dirtyRect);
4165         // FIXME: should probably not fire milestones for snapshot painting. https://bugs.webkit.org/show_bug.cgi?id=117623
4166         firePaintRelatedMilestonesIfNeeded();
4167     }
4168 }
4169 
4170 void FrameView::paintContents(GraphicsContext&amp; context, const IntRect&amp; dirtyRect, SecurityOriginPaintPolicy securityOriginPaintPolicy)
4171 {
4172 #ifndef NDEBUG
4173     bool fillWithWarningColor;
4174     if (frame().document()-&gt;printing())
4175         fillWithWarningColor = false; // Printing, don&#39;t fill with red (can&#39;t remember why).
4176     else if (frame().ownerElement())
4177         fillWithWarningColor = false; // Subframe, don&#39;t fill with red.
4178     else if (isTransparent())
4179         fillWithWarningColor = false; // Transparent, don&#39;t fill with red.
</pre>
<hr />
<pre>
4500         }
4501         return false;
4502     };
4503 
4504     // Finished parsing the main document and we still don&#39;t yet have enough content. Check if we might be getting some more.
4505     if (finishedParsingMainDocument)
4506         return !isMoreContentExpected();
4507 
4508     return false;
4509 }
4510 
4511 bool FrameView::isViewForDocumentInFrame() const
4512 {
4513     RenderView* renderView = this-&gt;renderView();
4514     if (!renderView)
4515         return false;
4516 
4517     return &amp;renderView-&gt;frameView() == this;
4518 }
4519 
<span class="line-modified">4520 void FrameView::enableAutoSizeMode(bool enable, const IntSize&amp; minSize, const IntSize&amp; maxSize)</span>
4521 {
<span class="line-modified">4522     ASSERT(!enable || !minSize.isEmpty());</span>
<span class="line-modified">4523     ASSERT(minSize.width() &lt;= maxSize.width());</span>
<span class="line-removed">4524     ASSERT(minSize.height() &lt;= maxSize.height());</span>
<span class="line-removed">4525 </span>
<span class="line-removed">4526     if (m_shouldAutoSize == enable &amp;&amp; m_minAutoSize == minSize &amp;&amp; m_maxAutoSize == maxSize)</span>
4527         return;
4528 
4529     m_shouldAutoSize = enable;
<span class="line-modified">4530     m_minAutoSize = minSize;</span>
<span class="line-modified">4531     m_maxAutoSize = maxSize;</span>
4532     m_didRunAutosize = false;
4533 
4534     setNeedsLayoutAfterViewConfigurationChange();
4535     layoutContext().scheduleLayout();
4536     if (m_shouldAutoSize) {
<span class="line-modified">4537         overrideViewportSizeForCSSViewportUnits({ minSize.width(), m_overrideViewportSize ? m_overrideViewportSize-&gt;height : WTF::nullopt });</span>
4538         return;
4539     }
4540 
4541     clearViewportSizeOverrideForCSSViewportUnits();
4542     // Since autosize mode forces the scrollbar mode, change them to being auto.
4543     setVerticalScrollbarLock(false);
4544     setHorizontalScrollbarLock(false);
4545     setScrollbarModes(ScrollbarAuto, ScrollbarAuto);
4546 }
4547 
4548 void FrameView::forceLayout(bool allowSubtreeLayout)
4549 {
4550     if (!allowSubtreeLayout &amp;&amp; layoutContext().subtreeLayoutRoot())
4551         layoutContext().convertSubtreeLayoutToFullLayout();
4552     layoutContext().layout();
4553 }
4554 
4555 void FrameView::forceLayoutForPagination(const FloatSize&amp; pageSize, const FloatSize&amp; originalPageSize, float maximumShrinkFactor, AdjustViewSizeOrNot shouldAdjustViewSize)
4556 {
4557     if (!renderView())
</pre>
<hr />
<pre>
4581     if (docLogicalWidth &gt; pageLogicalWidth) {
4582         int expectedPageWidth = std::min&lt;float&gt;(documentRect.width(), pageSize.width() * maximumShrinkFactor);
4583         int expectedPageHeight = std::min&lt;float&gt;(documentRect.height(), pageSize.height() * maximumShrinkFactor);
4584         FloatSize maxPageSize = frame().resizePageRectsKeepingRatio(FloatSize(originalPageSize.width(), originalPageSize.height()), FloatSize(expectedPageWidth, expectedPageHeight));
4585         pageLogicalWidth = horizontalWritingMode ? maxPageSize.width() : maxPageSize.height();
4586         pageLogicalHeight = horizontalWritingMode ? maxPageSize.height() : maxPageSize.width();
4587 
4588         renderView.setPageLogicalSize({ floor(pageLogicalWidth), floor(pageLogicalHeight) });
4589         renderView.setNeedsLayoutAndPrefWidthsRecalc();
4590         forceLayout();
4591         if (hasOneRef())
4592             return;
4593 
4594         const LayoutRect&amp; updatedDocumentRect = renderView.documentRect();
4595         LayoutUnit docLogicalHeight = horizontalWritingMode ? updatedDocumentRect.height() : updatedDocumentRect.width();
4596         LayoutUnit docLogicalTop = horizontalWritingMode ? updatedDocumentRect.y() : updatedDocumentRect.x();
4597         LayoutUnit docLogicalRight = horizontalWritingMode ? updatedDocumentRect.maxX() : updatedDocumentRect.maxY();
4598         LayoutUnit clippedLogicalLeft;
4599         if (!renderView.style().isLeftToRightDirection())
4600             clippedLogicalLeft = docLogicalRight - pageLogicalWidth;
<span class="line-modified">4601         LayoutRect overflow(clippedLogicalLeft, docLogicalTop, pageLogicalWidth, docLogicalHeight);</span>
4602 
4603         if (!horizontalWritingMode)
4604             overflow = overflow.transposedRect();
4605         renderView.clearLayoutOverflow();
4606         renderView.addLayoutOverflow(overflow); // This is how we clip in case we overflow again.
4607     }
4608 
4609     if (shouldAdjustViewSize)
4610         adjustViewSize();
4611 }
4612 
4613 void FrameView::adjustPageHeightDeprecated(float *newBottom, float oldTop, float oldBottom, float /*bottomLimit*/)
4614 {
4615     RenderView* renderView = this-&gt;renderView();
4616     if (!renderView) {
4617         *newBottom = oldBottom;
4618         return;
4619 
4620     }
4621     // Use a context with painting disabled.
</pre>
<hr />
<pre>
4824 }
4825 
4826 FloatPoint FrameView::documentToClientPoint(FloatPoint p) const
4827 {
4828     p.move(documentToClientOffset());
4829     return p;
4830 }
4831 
4832 FloatRect FrameView::clientToDocumentRect(FloatRect rect) const
4833 {
4834     rect.move(-documentToClientOffset());
4835     return rect;
4836 }
4837 
4838 FloatPoint FrameView::clientToDocumentPoint(FloatPoint point) const
4839 {
4840     point.move(-documentToClientOffset());
4841     return point;
4842 }
4843 








4844 FloatPoint FrameView::layoutViewportToAbsolutePoint(FloatPoint p) const
4845 {
4846     ASSERT(frame().settings().visualViewportEnabled());
4847     p.moveBy(layoutViewportRect().location());
4848     return p.scaled(frame().frameScaleFactor());
4849 }
4850 
















4851 FloatRect FrameView::clientToLayoutViewportRect(FloatRect rect) const
4852 {
4853     ASSERT(frame().settings().visualViewportEnabled());
4854     rect.scale(frame().pageZoomFactor());
4855     return rect;
4856 }
4857 
4858 FloatPoint FrameView::clientToLayoutViewportPoint(FloatPoint p) const
4859 {
4860     ASSERT(frame().settings().visualViewportEnabled());
4861     return p.scaled(frame().pageZoomFactor());
4862 }
4863 
4864 void FrameView::setTracksRepaints(bool trackRepaints)
4865 {
4866     if (trackRepaints == m_isTrackingRepaints)
4867         return;
4868 
4869     // Force layout to flush out any pending repaints.
4870     if (trackRepaints) {
</pre>
<hr />
<pre>
4892 {
4893     Frame&amp; frame = this-&gt;frame();
4894     Ref&lt;Frame&gt; protector(frame);
4895 
4896     if (auto* document = frame.document())
4897         document-&gt;updateLayout();
4898 
4899     TextStream ts;
4900     if (!m_trackedRepaintRects.isEmpty()) {
4901         ts &lt;&lt; &quot;(repaint rects\n&quot;;
4902         for (auto&amp; rect : m_trackedRepaintRects)
4903             ts &lt;&lt; &quot;  (rect &quot; &lt;&lt; LayoutUnit(rect.x()) &lt;&lt; &quot; &quot; &lt;&lt; LayoutUnit(rect.y()) &lt;&lt; &quot; &quot; &lt;&lt; LayoutUnit(rect.width()) &lt;&lt; &quot; &quot; &lt;&lt; LayoutUnit(rect.height()) &lt;&lt; &quot;)\n&quot;;
4904         ts &lt;&lt; &quot;)\n&quot;;
4905     }
4906     return ts.release();
4907 }
4908 
4909 bool FrameView::addScrollableArea(ScrollableArea* scrollableArea)
4910 {
4911     if (!m_scrollableAreas)
<span class="line-modified">4912         m_scrollableAreas = std::make_unique&lt;ScrollableAreaSet&gt;();</span>
4913 
4914     if (m_scrollableAreas-&gt;add(scrollableArea).isNewEntry) {
4915         scrollableAreaSetChanged();
4916         return true;
4917     }
4918 
4919     return false;
4920 }
4921 
4922 bool FrameView::removeScrollableArea(ScrollableArea* scrollableArea)
4923 {
4924     if (m_scrollableAreas &amp;&amp; m_scrollableAreas-&gt;remove(scrollableArea)) {
4925         scrollableAreaSetChanged();
4926         return true;
4927     }
4928     return false;
4929 }
4930 
4931 bool FrameView::containsScrollableArea(ScrollableArea* scrollableArea) const
4932 {
</pre>
<hr />
<pre>
5062     IntRect newRect;
5063     Page* page = frame().page();
5064     if (!page || !page-&gt;chrome().client().fetchCustomFixedPositionLayoutRect(newRect))
5065         return false;
5066 
5067     if (newRect != m_customFixedPositionLayoutRect) {
5068         m_customFixedPositionLayoutRect = newRect;
5069         setViewportConstrainedObjectsNeedLayout();
5070         return true;
5071     }
5072     return false;
5073 }
5074 
5075 void FrameView::setCustomSizeForResizeEvent(IntSize customSize)
5076 {
5077     m_useCustomSizeForResizeEvent = true;
5078     m_customSizeForResizeEvent = customSize;
5079     sendResizeEventIfNeeded();
5080 }
5081 
<span class="line-modified">5082 void FrameView::setScrollVelocity(double horizontalVelocity, double verticalVelocity, double scaleChangeRate, MonotonicTime timestamp)</span>
5083 {
5084     if (TiledBacking* tiledBacking = this-&gt;tiledBacking())
<span class="line-modified">5085         tiledBacking-&gt;setVelocity(VelocityData(horizontalVelocity, verticalVelocity, scaleChangeRate, timestamp));</span>
5086 }
5087 #endif // PLATFORM(IOS_FAMILY)
5088 
5089 void FrameView::setScrollingPerformanceLoggingEnabled(bool flag)
5090 {
5091     if (TiledBacking* tiledBacking = this-&gt;tiledBacking())
5092         tiledBacking-&gt;setScrollingPerformanceLoggingEnabled(flag);
5093 }
5094 
5095 void FrameView::didAddScrollbar(Scrollbar* scrollbar, ScrollbarOrientation orientation)
5096 {
5097     ScrollableArea::didAddScrollbar(scrollbar, orientation);
5098     Page* page = frame().page();
5099     if (page &amp;&amp; page-&gt;expectsWheelEventTriggers())
5100         scrollAnimator().setWheelEventTestTrigger(page-&gt;testTrigger());
5101     if (AXObjectCache* cache = axObjectCache())
5102         cache-&gt;handleScrollbarUpdate(this);
5103 }
5104 
5105 void FrameView::willRemoveScrollbar(Scrollbar* scrollbar, ScrollbarOrientation orientation)
</pre>
<hr />
<pre>
5205     updateScrollbars(scrollPosition());
5206 }
5207 
5208 ScrollBehaviorForFixedElements FrameView::scrollBehaviorForFixedElements() const
5209 {
5210     return frame().settings().backgroundShouldExtendBeyondPage() ? StickToViewportBounds : StickToDocumentBounds;
5211 }
5212 
5213 RenderView* FrameView::renderView() const
5214 {
5215     return frame().contentRenderer();
5216 }
5217 
5218 int FrameView::mapFromLayoutToCSSUnits(LayoutUnit value) const
5219 {
5220     return value / (frame().pageZoomFactor() * frame().frameScaleFactor());
5221 }
5222 
5223 LayoutUnit FrameView::mapFromCSSToLayoutUnits(int value) const
5224 {
<span class="line-modified">5225     return value * frame().pageZoomFactor() * frame().frameScaleFactor();</span>
5226 }
5227 
5228 void FrameView::didAddWidgetToRenderTree(Widget&amp; widget)
5229 {
5230     ASSERT(!m_widgetsInRenderTree.contains(&amp;widget));
5231     m_widgetsInRenderTree.add(&amp;widget);
5232 }
5233 
5234 void FrameView::willRemoveWidgetFromRenderTree(Widget&amp; widget)
5235 {
5236     ASSERT(m_widgetsInRenderTree.contains(&amp;widget));
5237     m_widgetsInRenderTree.remove(&amp;widget);
5238 }
5239 
5240 static Vector&lt;RefPtr&lt;Widget&gt;&gt; collectAndProtectWidgets(const HashSet&lt;Widget*&gt;&amp; set)
5241 {
5242     return copyToVectorOf&lt;RefPtr&lt;Widget&gt;&gt;(set);
5243 }
5244 
5245 void FrameView::updateWidgetPositions()
</pre>
</td>
<td>
<hr />
<pre>
  17  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  18  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  19  * Library General Public License for more details.
  20  *
  21  * You should have received a copy of the GNU Library General Public License
  22  * along with this library; see the file COPYING.LIB.  If not, write to
  23  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  24  * Boston, MA 02110-1301, USA.
  25  */
  26 
  27 #include &quot;config.h&quot;
  28 #include &quot;FrameView.h&quot;
  29 
  30 #include &quot;AXObjectCache.h&quot;
  31 #include &quot;BackForwardController.h&quot;
  32 #include &quot;CSSAnimationController.h&quot;
  33 #include &quot;CachedImage.h&quot;
  34 #include &quot;CachedResourceLoader.h&quot;
  35 #include &quot;Chrome.h&quot;
  36 #include &quot;ChromeClient.h&quot;
<span class="line-added">  37 #include &quot;CustomHeaderFields.h&quot;</span>
  38 #include &quot;DOMWindow.h&quot;
  39 #include &quot;DebugPageOverlays.h&quot;
  40 #include &quot;DeprecatedGlobalSettings.h&quot;
  41 #include &quot;DocumentLoader.h&quot;
  42 #include &quot;DocumentMarkerController.h&quot;
  43 #include &quot;EventHandler.h&quot;
  44 #include &quot;EventNames.h&quot;
  45 #include &quot;FloatRect.h&quot;
  46 #include &quot;FocusController.h&quot;
  47 #include &quot;Frame.h&quot;
  48 #include &quot;FrameLoader.h&quot;
  49 #include &quot;FrameLoaderClient.h&quot;
  50 #include &quot;FrameSelection.h&quot;
  51 #include &quot;FrameTree.h&quot;
  52 #include &quot;GraphicsContext.h&quot;
  53 #include &quot;HTMLBodyElement.h&quot;
  54 #include &quot;HTMLEmbedElement.h&quot;
  55 #include &quot;HTMLFrameElement.h&quot;
  56 #include &quot;HTMLFrameSetElement.h&quot;
  57 #include &quot;HTMLHtmlElement.h&quot;
</pre>
<hr />
<pre>
  69 #include &quot;OverflowEvent.h&quot;
  70 #include &quot;Page.h&quot;
  71 #include &quot;PageCache.h&quot;
  72 #include &quot;PageOverlayController.h&quot;
  73 #include &quot;ProgressTracker.h&quot;
  74 #include &quot;RenderEmbeddedObject.h&quot;
  75 #include &quot;RenderFullScreen.h&quot;
  76 #include &quot;RenderIFrame.h&quot;
  77 #include &quot;RenderInline.h&quot;
  78 #include &quot;RenderLayer.h&quot;
  79 #include &quot;RenderLayerBacking.h&quot;
  80 #include &quot;RenderLayerCompositor.h&quot;
  81 #include &quot;RenderSVGRoot.h&quot;
  82 #include &quot;RenderScrollbar.h&quot;
  83 #include &quot;RenderScrollbarPart.h&quot;
  84 #include &quot;RenderStyle.h&quot;
  85 #include &quot;RenderText.h&quot;
  86 #include &quot;RenderTheme.h&quot;
  87 #include &quot;RenderView.h&quot;
  88 #include &quot;RenderWidget.h&quot;
<span class="line-added">  89 #include &quot;ResizeObserver.h&quot;</span>
  90 #include &quot;RuntimeEnabledFeatures.h&quot;
  91 #include &quot;SVGDocument.h&quot;
  92 #include &quot;SVGSVGElement.h&quot;
  93 #include &quot;ScriptRunner.h&quot;
  94 #include &quot;ScriptedAnimationController.h&quot;
  95 #include &quot;ScrollAnimator.h&quot;
  96 #include &quot;ScrollingCoordinator.h&quot;
  97 #include &quot;Settings.h&quot;
  98 #include &quot;StyleResolver.h&quot;
  99 #include &quot;StyleScope.h&quot;
 100 #include &quot;TextResourceDecoder.h&quot;
 101 #include &quot;TiledBacking.h&quot;
<span class="line-added"> 102 #include &quot;VelocityData.h&quot;</span>
 103 #include &quot;VisualViewport.h&quot;
 104 #include &quot;WheelEventTestTrigger.h&quot;
 105 #include &lt;wtf/text/TextStream.h&gt;
 106 
 107 #include &lt;wtf/IsoMallocInlines.h&gt;
 108 #include &lt;wtf/MemoryPressureHandler.h&gt;
 109 #include &lt;wtf/Ref.h&gt;
 110 #include &lt;wtf/SetForScope.h&gt;
 111 #include &lt;wtf/SystemTracing.h&gt;
 112 
 113 #if USE(COORDINATED_GRAPHICS)
 114 #include &quot;TiledBackingStore.h&quot;
 115 #endif
 116 
 117 #if ENABLE(CSS_SCROLL_SNAP)
 118 #include &quot;AxisScrollSnapOffsets.h&quot;
 119 #endif
 120 
 121 #if PLATFORM(IOS_FAMILY)
 122 #include &quot;DocumentLoader.h&quot;
</pre>
<hr />
<pre>
 128 #endif
 129 
 130 #define RELEASE_LOG_IF_ALLOWED(fmt, ...) RELEASE_LOG_IF(frame().page() &amp;&amp; frame().page()-&gt;isAlwaysOnLoggingAllowed(), Layout, &quot;%p - FrameView::&quot; fmt, this, ##__VA_ARGS__)
 131 
 132 namespace WebCore {
 133 
 134 using namespace HTMLNames;
 135 
 136 WTF_MAKE_ISO_ALLOCATED_IMPL(FrameView);
 137 
 138 MonotonicTime FrameView::sCurrentPaintTimeStamp { };
 139 
 140 // The maximum number of updateEmbeddedObjects iterations that should be done before returning.
 141 static const unsigned maxUpdateEmbeddedObjectsIterations = 2;
 142 
 143 static constexpr unsigned defaultSignificantRenderedTextCharacterThreshold = 3000;
 144 static constexpr float defaultSignificantRenderedTextMeanLength = 50;
 145 static constexpr unsigned mainArticleSignificantRenderedTextCharacterThreshold = 1500;
 146 static constexpr float mainArticleSignificantRenderedTextMeanLength = 25;
 147 












 148 Pagination::Mode paginationModeForRenderStyle(const RenderStyle&amp; style)
 149 {
 150     Overflow overflow = style.overflowY();
 151     if (overflow != Overflow::PagedX &amp;&amp; overflow != Overflow::PagedY)
 152         return Pagination::Unpaginated;
 153 
 154     bool isHorizontalWritingMode = style.isHorizontalWritingMode();
 155     TextDirection textDirection = style.direction();
 156     WritingMode writingMode = style.writingMode();
 157 
 158     // paged-x always corresponds to LeftToRightPaginated or RightToLeftPaginated. If the WritingMode
 159     // is horizontal, then we use TextDirection to choose between those options. If the WritingMode
 160     // is vertical, then the direction of the verticality dictates the choice.
 161     if (overflow == Overflow::PagedX) {
 162         if ((isHorizontalWritingMode &amp;&amp; textDirection == TextDirection::LTR) || writingMode == LeftToRightWritingMode)
 163             return Pagination::LeftToRightPaginated;
 164         return Pagination::RightToLeftPaginated;
 165     }
 166 
 167     // paged-y always corresponds to TopToBottomPaginated or BottomToTopPaginated. If the WritingMode
</pre>
<hr />
<pre>
 287     else
 288         setScrollbarModes(ScrollbarAlwaysOff, ScrollbarAlwaysOff);
 289     setScrollbarsSuppressed(false);
 290 }
 291 
 292 void FrameView::resetScrollbarsAndClearContentsSize()
 293 {
 294     resetScrollbars();
 295 
 296     LOG(Layout, &quot;FrameView %p resetScrollbarsAndClearContentsSize&quot;, this);
 297 
 298     setScrollbarsSuppressed(true);
 299     setContentsSize(IntSize());
 300     setScrollbarsSuppressed(false);
 301 }
 302 
 303 void FrameView::init()
 304 {
 305     reset();
 306 

 307     m_size = LayoutSize();
 308 
<span class="line-modified"> 309     // Propagate the scrolling mode to the view.</span>
<span class="line-modified"> 310     auto* ownerElement = frame().ownerElement();</span>
<span class="line-modified"> 311     if (is&lt;HTMLFrameElementBase&gt;(ownerElement) &amp;&amp; downcast&lt;HTMLFrameElementBase&gt;(*ownerElement).scrollingMode() == ScrollbarAlwaysOff)</span>
<span class="line-modified"> 312         setCanHaveScrollbars(false);</span>









 313 
 314     Page* page = frame().page();
 315     if (page &amp;&amp; page-&gt;chrome().client().shouldPaintEntireContents())
 316         setPaintsEntireContents(true);
 317 }
 318 
 319 void FrameView::prepareForDetach()
 320 {
 321     detachCustomScrollbars();
 322     // When the view is no longer associated with a frame, it needs to be removed from the ax object cache
 323     // right now, otherwise it won&#39;t be able to reach the topDocument()&#39;s axObject cache later.
 324     removeFromAXObjectCache();
 325 
 326     if (frame().page()) {
 327         if (ScrollingCoordinator* scrollingCoordinator = frame().page()-&gt;scrollingCoordinator())
 328             scrollingCoordinator-&gt;willDestroyScrollableArea(*this);
 329     }
 330 }
 331 
 332 void FrameView::detachCustomScrollbars()
</pre>
<hr />
<pre>
 422         if (auto* page = frame().page())
 423             page-&gt;chrome().invalidateContentsAndRootView(rect);
 424         return;
 425     }
 426 
 427     auto* renderer = frame().ownerRenderer();
 428     if (!renderer)
 429         return;
 430 
 431     IntRect repaintRect = rect;
 432     repaintRect.moveBy(roundedIntPoint(renderer-&gt;contentBoxLocation()));
 433     renderer-&gt;repaintRectangle(repaintRect);
 434 }
 435 
 436 void FrameView::setFrameRect(const IntRect&amp; newRect)
 437 {
 438     Ref&lt;FrameView&gt; protectedThis(*this);
 439     IntRect oldRect = frameRect();
 440     if (newRect == oldRect)
 441         return;
<span class="line-added"> 442 </span>
 443     // Every scroll that happens as the result of frame size change is programmatic.
<span class="line-modified"> 444     auto oldScrollType = currentScrollType();</span>
<span class="line-added"> 445     setCurrentScrollType(ScrollType::Programmatic);</span>
<span class="line-added"> 446 </span>
 447     ScrollView::setFrameRect(newRect);
 448 
 449     updateScrollableAreaSet();
 450 
 451     if (RenderView* renderView = this-&gt;renderView()) {
 452         if (renderView-&gt;usesCompositing())
 453             renderView-&gt;compositor().frameViewDidChangeSize();
 454     }
 455 
 456     if (frame().isMainFrame() &amp;&amp; frame().page())
 457         frame().page()-&gt;pageOverlayController().didChangeViewSize();
 458 
 459     viewportContentsChanged();
<span class="line-added"> 460     setCurrentScrollType(oldScrollType);</span>
 461 }
 462 
 463 bool FrameView::scheduleAnimation()
 464 {
 465     auto* page = frame().page();
 466     if (!page)
 467         return false;
 468     page-&gt;chrome().scheduleAnimation();
 469     return true;
 470 }
 471 












 472 FrameFlattening FrameView::effectiveFrameFlattening() const
 473 {
 474 #if PLATFORM(IOS_FAMILY)
 475     // On iOS when async frame scrolling is enabled, it does not make sense to use full frame flattening.
 476     // In that case, we just consider that frame flattening is disabled. This allows people to test
 477     // frame scrolling on iOS by enabling &quot;Async Frame Scrolling&quot; via the Safari menu.
 478     if (frame().settings().asyncFrameScrollingEnabled() &amp;&amp; frame().settings().frameFlattening() == FrameFlattening::FullyEnabled)
 479         return FrameFlattening::Disabled;
 480 #endif
 481     return frame().settings().frameFlattening();
 482 }
 483 
 484 bool FrameView::frameFlatteningEnabled() const
 485 {
 486     return effectiveFrameFlattening() != FrameFlattening::Disabled;
 487 }
 488 
 489 bool FrameView::isFrameFlatteningValidForThisFrame() const
 490 {
 491     if (!frameFlatteningEnabled())
</pre>
<hr />
<pre>
1045         return platformTopContentInset();
1046 
1047     if (!frame().isMainFrame())
1048         return 0;
1049 
1050     Page* page = frame().page();
1051     return page ? page-&gt;topContentInset() : 0;
1052 }
1053 
1054 void FrameView::topContentInsetDidChange(float newTopContentInset)
1055 {
1056     RenderView* renderView = this-&gt;renderView();
1057     if (!renderView)
1058         return;
1059 
1060     if (platformWidget())
1061         platformSetTopContentInset(newTopContentInset);
1062 
1063     layoutContext().layout();
1064     // Every scroll that happens as the result of content inset change is programmatic.
<span class="line-modified">1065     auto oldScrollType = currentScrollType();</span>
<span class="line-added">1066     setCurrentScrollType(ScrollType::Programmatic);</span>
<span class="line-added">1067 </span>
1068     updateScrollbars(scrollPosition());
1069     if (renderView-&gt;usesCompositing())
1070         renderView-&gt;compositor().frameViewDidChangeSize();
1071 
1072     if (TiledBacking* tiledBacking = this-&gt;tiledBacking())
1073         tiledBacking-&gt;setTopContentInset(newTopContentInset);
<span class="line-added">1074 </span>
<span class="line-added">1075     setCurrentScrollType(oldScrollType);</span>
1076 }
1077 
1078 void FrameView::topContentDirectionDidChange()
1079 {
1080     m_needsDeferredScrollbarsUpdate = true;
1081 }
1082 
1083 void FrameView::handleDeferredScrollbarsUpdateAfterDirectionChange()
1084 {
1085     if (!m_needsDeferredScrollbarsUpdate)
1086         return;
1087 
1088     m_needsDeferredScrollbarsUpdate = false;
1089 
1090     updateScrollbars(scrollPosition());
1091     positionScrollbarLayers();
1092 }
1093 
1094 // Sometimes (for plug-ins) we need to eagerly go into compositing mode.
1095 void FrameView::enterCompositingMode()
</pre>
<hr />
<pre>
1097     if (RenderView* renderView = this-&gt;renderView()) {
1098         renderView-&gt;compositor().enableCompositingMode();
1099         if (!needsLayout())
1100             renderView-&gt;compositor().scheduleCompositingLayerUpdate();
1101     }
1102 }
1103 
1104 bool FrameView::isEnclosedInCompositingLayer() const
1105 {
1106     auto frameOwnerRenderer = frame().ownerRenderer();
1107     if (frameOwnerRenderer &amp;&amp; frameOwnerRenderer-&gt;containerForRepaint())
1108         return true;
1109 
1110     if (FrameView* parentView = parentFrameView())
1111         return parentView-&gt;isEnclosedInCompositingLayer();
1112     return false;
1113 }
1114 
1115 bool FrameView::flushCompositingStateIncludingSubframes()
1116 {




1117     bool allFramesFlushed = flushCompositingStateForThisFrame(frame());
1118 
1119     for (Frame* child = frame().tree().firstRenderedChild(); child; child = child-&gt;tree().traverseNextRendered(m_frame.ptr())) {
1120         if (!child-&gt;view())
1121             continue;
1122         bool flushed = child-&gt;view()-&gt;flushCompositingStateForThisFrame(frame());
1123         allFramesFlushed &amp;= flushed;
1124     }
1125     return allFramesFlushed;
1126 }
1127 
1128 bool FrameView::isSoftwareRenderable() const
1129 {
1130     RenderView* renderView = this-&gt;renderView();
1131     return !renderView || !renderView-&gt;compositor().has3DContent();
1132 }
1133 
1134 void FrameView::setIsInWindow(bool isInWindow)
1135 {
1136     if (RenderView* renderView = this-&gt;renderView())
</pre>
<hr />
<pre>
1216         m_firstLayoutCallbackPending = true;
1217     }
1218     adjustScrollbarsForLayout(firstLayout);
1219 
1220     auto oldSize = m_size;
1221     LayoutSize newSize = layoutSize();
1222     if (oldSize != newSize) {
1223         m_size = newSize;
1224         LOG(Layout, &quot;  layout size changed from %.3fx%.3f to %.3fx%.3f&quot;, oldSize.width().toFloat(), oldSize.height().toFloat(),     newSize.width().toFloat(), newSize.height().toFloat());
1225         layoutContext().setNeedsFullRepaint();
1226         if (!firstLayout)
1227             markRootOrBodyRendererDirty();
1228     }
1229     forceLayoutParentViewIfNeeded();
1230 }
1231 
1232 void FrameView::didLayout(WeakPtr&lt;RenderElement&gt; layoutRoot)
1233 {
1234     renderView()-&gt;releaseProtectedRenderWidgets();
1235     auto* layoutRootEnclosingLayer = layoutRoot-&gt;enclosingLayer();
<span class="line-modified">1236     layoutRootEnclosingLayer-&gt;updateLayerPositionsAfterLayout(!is&lt;RenderView&gt;(*layoutRoot), layoutContext().needsFullRepaint());</span>
1237 
1238     updateCompositingLayersAfterLayout();
1239 
1240 #if PLATFORM(COCOA) || PLATFORM(WIN) || PLATFORM(GTK)
1241     if (auto* cache = frame().document()-&gt;existingAXObjectCache())
1242         cache-&gt;postNotification(layoutRoot.get(), AXObjectCache::AXLayoutComplete);
1243 #endif
1244 
<span class="line-modified">1245     frame().document()-&gt;invalidateRenderingDependentRegions();</span>
1246 
1247     updateCanBlitOnScrollRecursively();
1248 
1249     handleDeferredScrollUpdateAfterContentSizeChange();
1250 
1251     handleDeferredScrollbarsUpdateAfterDirectionChange();
1252 
1253     if (frame().document()-&gt;hasListenerType(Document::OVERFLOWCHANGED_LISTENER))
1254         updateOverflowStatus(layoutWidth() &lt; contentsWidth(), layoutHeight() &lt; contentsHeight());
1255 
1256     frame().document()-&gt;markers().invalidateRectsForAllMarkers();
1257 }
1258 
1259 bool FrameView::shouldDeferScrollUpdateAfterContentSizeChange()
1260 {
1261     return (layoutContext().layoutPhase() &lt; FrameViewLayoutContext::LayoutPhase::InPostLayout) &amp;&amp; (layoutContext().layoutPhase() != FrameViewLayoutContext::LayoutPhase::OutsideLayout);
1262 }
1263 
1264 RenderBox* FrameView::embeddedContentBox() const
1265 {
1266     RenderView* renderView = this-&gt;renderView();
1267     if (!renderView)
1268         return nullptr;
1269 
1270     RenderObject* firstChild = renderView-&gt;firstChild();
1271 
1272     // Curently only embedded SVG documents participate in the size-negotiation logic.
1273     if (is&lt;RenderSVGRoot&gt;(firstChild))
1274         return downcast&lt;RenderSVGRoot&gt;(firstChild);
1275 
1276     return nullptr;
1277 }
1278 
1279 void FrameView::addEmbeddedObjectToUpdate(RenderEmbeddedObject&amp; embeddedObject)
1280 {
1281     if (!m_embeddedObjectsToUpdate)
<span class="line-modified">1282         m_embeddedObjectsToUpdate = makeUnique&lt;ListHashSet&lt;RenderEmbeddedObject*&gt;&gt;();</span>
1283 
1284     HTMLFrameOwnerElement&amp; element = embeddedObject.frameOwnerElement();
1285     if (is&lt;HTMLObjectElement&gt;(element) || is&lt;HTMLEmbedElement&gt;(element)) {
1286         // Tell the DOM element that it needs a widget update.
1287         HTMLPlugInImageElement&amp; pluginElement = downcast&lt;HTMLPlugInImageElement&gt;(element);
1288         if (!pluginElement.needsCheckForSizeChange())
1289             pluginElement.setNeedsWidgetUpdate(true);
1290     }
1291 
1292     m_embeddedObjectsToUpdate-&gt;add(&amp;embeddedObject);
1293 }
1294 
1295 void FrameView::removeEmbeddedObjectToUpdate(RenderEmbeddedObject&amp; embeddedObject)
1296 {
1297     if (!m_embeddedObjectsToUpdate)
1298         return;
1299 
1300     m_embeddedObjectsToUpdate-&gt;remove(&amp;embeddedObject);
1301 }
1302 
</pre>
<hr />
<pre>
1398         return;
1399     StringBuilder builder;
1400     if (frame().isMainFrame())
1401         builder.appendLiteral(&quot;Main&quot;);
1402     builder.appendLiteral(&quot;FrameView: &quot;);
1403     builder.append(message);
1404     document-&gt;addConsoleMessage(MessageSource::Other, MessageLevel::Debug, builder.toString());
1405 }
1406 
1407 void FrameView::setCannotBlitToWindow()
1408 {
1409     m_cannotBlitToWindow = true;
1410     updateCanBlitOnScrollRecursively();
1411 }
1412 
1413 void FrameView::addSlowRepaintObject(RenderElement&amp; renderer)
1414 {
1415     bool hadSlowRepaintObjects = hasSlowRepaintObjects();
1416 
1417     if (!m_slowRepaintObjects)
<span class="line-modified">1418         m_slowRepaintObjects = makeUnique&lt;HashSet&lt;const RenderElement*&gt;&gt;();</span>
1419 
1420     m_slowRepaintObjects-&gt;add(&amp;renderer);
1421     if (hadSlowRepaintObjects)
1422         return;
1423 
1424     updateCanBlitOnScrollRecursively();
1425 
1426     if (auto* page = frame().page()) {
1427         if (auto* scrollingCoordinator = page-&gt;scrollingCoordinator())
1428             scrollingCoordinator-&gt;frameViewHasSlowRepaintObjectsDidChange(*this);
1429     }
1430 }
1431 
1432 void FrameView::removeSlowRepaintObject(RenderElement&amp; renderer)
1433 {
1434     if (!m_slowRepaintObjects)
1435         return;
1436 
1437     m_slowRepaintObjects-&gt;remove(&amp;renderer);
1438     if (!m_slowRepaintObjects-&gt;isEmpty())
1439         return;
1440 
1441     m_slowRepaintObjects = nullptr;
1442     updateCanBlitOnScrollRecursively();
1443 
1444     if (auto* page = frame().page()) {
1445         if (auto* scrollingCoordinator = page-&gt;scrollingCoordinator())
1446             scrollingCoordinator-&gt;frameViewHasSlowRepaintObjectsDidChange(*this);
1447     }
1448 }
1449 
1450 void FrameView::addViewportConstrainedObject(RenderLayerModelObject* object)
1451 {
1452     if (!m_viewportConstrainedObjects)
<span class="line-modified">1453         m_viewportConstrainedObjects = makeUnique&lt;ViewportConstrainedObjectSet&gt;();</span>
1454 
1455     if (!m_viewportConstrainedObjects-&gt;contains(object)) {
1456         m_viewportConstrainedObjects-&gt;add(object);
1457         if (platformWidget())
1458             updateCanBlitOnScrollRecursively();
1459 
1460         if (Page* page = frame().page()) {
1461             if (ScrollingCoordinator* scrollingCoordinator = page-&gt;scrollingCoordinator())
1462                 scrollingCoordinator-&gt;frameViewFixedObjectsDidChange(*this);
1463         }
1464     }
1465 }
1466 
1467 void FrameView::removeViewportConstrainedObject(RenderLayerModelObject* object)
1468 {
1469     if (m_viewportConstrainedObjects &amp;&amp; m_viewportConstrainedObjects-&gt;remove(object)) {
1470         if (Page* page = frame().page()) {
1471             if (ScrollingCoordinator* scrollingCoordinator = page-&gt;scrollingCoordinator())
1472                 scrollingCoordinator-&gt;frameViewFixedObjectsDidChange(*this);
1473         }
1474 
1475         // FIXME: In addFixedObject() we only call this if there&#39;s a platform widget,
1476         // why isn&#39;t the same check being made here?
1477         updateCanBlitOnScrollRecursively();
1478     }
1479 }
1480 
1481 LayoutSize FrameView::expandedLayoutViewportSize(const LayoutSize&amp; baseLayoutViewportSize, const LayoutSize&amp; documentSize, double heightExpansionFactor)
1482 {
1483     if (!heightExpansionFactor)
1484         return baseLayoutViewportSize;
1485 
1486     auto documentHeight = documentSize.height();
1487     auto layoutViewportHeight = baseLayoutViewportSize.height();
1488     if (layoutViewportHeight &gt; documentHeight)
1489         return baseLayoutViewportSize;
1490 
<span class="line-modified">1491     return { baseLayoutViewportSize.width(), std::min(documentHeight, LayoutUnit((1 + heightExpansionFactor) * layoutViewportHeight)) };</span>
1492 }
1493 
1494 LayoutRect FrameView::computeUpdatedLayoutViewportRect(const LayoutRect&amp; layoutViewport, const LayoutRect&amp; documentRect, const LayoutSize&amp; unobscuredContentSize, const LayoutRect&amp; unobscuredContentRect, const LayoutSize&amp; baseLayoutViewportSize, const LayoutPoint&amp; stableLayoutViewportOriginMin, const LayoutPoint&amp; stableLayoutViewportOriginMax, LayoutViewportConstraint constraint)
1495 {
1496     LayoutRect layoutViewportRect = layoutViewport;
1497 
1498     // The layout viewport is never smaller than baseLayoutViewportSize, and never be smaller than the unobscuredContentRect.
1499     LayoutSize constrainedSize = baseLayoutViewportSize;
1500     layoutViewportRect.setSize(constrainedSize.expandedTo(unobscuredContentSize));
1501 
1502     LayoutPoint layoutViewportOrigin = computeLayoutViewportOrigin(unobscuredContentRect, stableLayoutViewportOriginMin, stableLayoutViewportOriginMax, layoutViewportRect, StickToViewportBounds);
1503 
1504     // FIXME: Is this equivalent to calling computeLayoutViewportOrigin() with StickToDocumentBounds?
1505     if (constraint == LayoutViewportConstraint::ConstrainedToDocumentRect) {
1506         // The max stable layout viewport origin really depends on the size of the layout viewport itself, so we need to adjust the location of the layout viewport one final time to make sure it does not end up out of bounds of the document.
1507         // Without this adjustment (and with using the non-constrained unobscuredContentRect&#39;s size as the size of the layout viewport) the layout viewport can be pushed past the bounds of the document during rubber-banding, and cannot be pushed
1508         // back in until the user scrolls back in the other direction.
1509         layoutViewportOrigin.setX(clampTo&lt;float&gt;(layoutViewportOrigin.x().toFloat(), 0, documentRect.width() - layoutViewportRect.width()));
1510         layoutViewportOrigin.setY(clampTo&lt;float&gt;(layoutViewportOrigin.y().toFloat(), 0, documentRect.height() - layoutViewportRect.height()));
1511     }
</pre>
<hr />
<pre>
1620 }
1621 
1622 void FrameView::updateLayoutViewport()
1623 {
1624     if (!frame().settings().visualViewportEnabled())
1625         return;
1626 
1627     // Don&#39;t update the layout viewport if we&#39;re in the middle of adjusting scrollbars. We&#39;ll get another call
1628     // as a post-layout task.
1629     if (layoutContext().layoutPhase() == FrameViewLayoutContext::LayoutPhase::InViewSizeAdjust)
1630         return;
1631 
1632     LayoutRect layoutViewport = layoutViewportRect();
1633 
1634     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;\nFrameView &quot; &lt;&lt; this &lt;&lt; &quot; updateLayoutViewport() totalContentSize &quot; &lt;&lt; totalContentsSize() &lt;&lt; &quot; unscaledDocumentRect &quot; &lt;&lt; (renderView() ? renderView()-&gt;unscaledDocumentRect() : IntRect()) &lt;&lt; &quot; header height &quot; &lt;&lt; headerHeight() &lt;&lt; &quot; footer height &quot; &lt;&lt; footerHeight() &lt;&lt; &quot; fixed behavior &quot; &lt;&lt; scrollBehaviorForFixedElements());
1635     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;layoutViewport: &quot; &lt;&lt; layoutViewport);
1636     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;visualViewport: &quot; &lt;&lt; visualViewportRect() &lt;&lt; &quot; (is override &quot; &lt;&lt; (bool)m_visualViewportOverrideRect &lt;&lt; &quot;)&quot;);
1637     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;stable origins: min: &quot; &lt;&lt; minStableLayoutViewportOrigin() &lt;&lt; &quot; max: &quot;&lt;&lt; maxStableLayoutViewportOrigin());
1638 
1639     if (m_layoutViewportOverrideRect) {
<span class="line-modified">1640         if (currentScrollType() == ScrollType::Programmatic) {</span>
1641             LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;computing new override layout viewport because of programmatic scrolling&quot;);
1642             LayoutPoint newOrigin = computeLayoutViewportOrigin(visualViewportRect(), minStableLayoutViewportOrigin(), maxStableLayoutViewportOrigin(), layoutViewport, StickToDocumentBounds);
1643             setLayoutViewportOverrideRect(LayoutRect(newOrigin, m_layoutViewportOverrideRect.value().size()));
1644         }
<span class="line-modified">1645         layoutOrVisualViewportChanged();</span>



1646         return;
1647     }
1648 
1649     LayoutPoint newLayoutViewportOrigin = computeLayoutViewportOrigin(visualViewportRect(), minStableLayoutViewportOrigin(), maxStableLayoutViewportOrigin(), layoutViewport, scrollBehaviorForFixedElements());
1650     if (newLayoutViewportOrigin != m_layoutViewportOrigin) {
1651         setBaseLayoutViewportOrigin(newLayoutViewportOrigin);
1652         LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;layoutViewport changed to &quot; &lt;&lt; layoutViewportRect());
1653     }
<span class="line-modified">1654     layoutOrVisualViewportChanged();</span>



1655 }
1656 
1657 LayoutPoint FrameView::minStableLayoutViewportOrigin() const
1658 {
1659     return unscaledMinimumScrollPosition();
1660 }
1661 
1662 LayoutPoint FrameView::maxStableLayoutViewportOrigin() const
1663 {
1664     LayoutPoint maxPosition = unscaledMaximumScrollPosition();
1665     maxPosition = (maxPosition - LayoutSize(0, headerHeight() + footerHeight())).expandedTo({ });
1666     return maxPosition;
1667 }
1668 
1669 IntPoint FrameView::unscaledScrollOrigin() const
1670 {
1671     if (RenderView* renderView = this-&gt;renderView())
1672         return -renderView-&gt;unscaledDocumentRect().location(); // Akin to code in adjustViewSize().
1673 
1674     return { };
</pre>
<hr />
<pre>
1912 
1913 void FrameView::viewportContentsChanged()
1914 {
1915     if (!frame().view()) {
1916         // The frame is being destroyed.
1917         return;
1918     }
1919 
1920     if (auto* page = frame().page())
1921         page-&gt;updateValidationBubbleStateIfNeeded();
1922 
1923     // When the viewport contents changes (scroll, resize, style recalc, layout, ...),
1924     // check if we should resume animated images or unthrottle DOM timers.
1925     applyRecursivelyWithVisibleRect([] (FrameView&amp; frameView, const IntRect&amp; visibleRect) {
1926         frameView.resumeVisibleImageAnimations(visibleRect);
1927         frameView.updateScriptedAnimationsAndTimersThrottlingState(visibleRect);
1928 
1929         if (auto* renderView = frameView.frame().contentRenderer())
1930             renderView-&gt;updateVisibleViewportRect(visibleRect);
1931     });















1932 }
1933 
<span class="line-modified">1934 IntRect FrameView::viewRectExpandedByContentInsets() const</span>
1935 {
<span class="line-modified">1936     FloatRect viewRect;</span>
<span class="line-added">1937     if (delegatesScrolling() &amp;&amp; platformWidget())</span>
<span class="line-added">1938         viewRect = unobscuredContentRect();</span>
<span class="line-added">1939     else</span>
<span class="line-added">1940         viewRect = visualViewportRect();</span>
<span class="line-added">1941 </span>
1942     if (auto* page = frame().page())
<span class="line-modified">1943         viewRect.expand(page-&gt;contentInsets());</span>
<span class="line-modified">1944 </span>
<span class="line-added">1945     return IntRect(viewRect);</span>
1946 }
1947 
1948 bool FrameView::fixedElementsLayoutRelativeToFrame() const
1949 {
1950     return frame().settings().fixedElementsLayoutRelativeToFrame();
1951 }
1952 
1953 IntPoint FrameView::lastKnownMousePosition() const
1954 {
1955     return frame().eventHandler().lastKnownMousePosition();
1956 }
1957 
1958 bool FrameView::isHandlingWheelEvent() const
1959 {
1960     return frame().eventHandler().isHandlingWheelEvent();
1961 }
1962 
1963 bool FrameView::shouldSetCursor() const
1964 {
1965     Page* page = frame().page();
1966     return page &amp;&amp; page-&gt;isVisible() &amp;&amp; page-&gt;focusController().isActive();
1967 }
1968 
1969 #if ENABLE(DARK_MODE_CSS)
<span class="line-modified">1970 RenderObject* FrameView::rendererForColorScheme() const</span>
1971 {
1972     auto* document = frame().document();
1973     auto* documentElement = document ? document-&gt;documentElement() : nullptr;
1974     auto* documentElementRenderer = documentElement ? documentElement-&gt;renderer() : nullptr;
<span class="line-modified">1975     if (documentElementRenderer &amp;&amp; documentElementRenderer-&gt;style().hasExplicitlySetColorScheme())</span>
1976         return documentElementRenderer;
1977     auto* bodyElement = document ? document-&gt;bodyOrFrameset() : nullptr;
1978     return bodyElement ? bodyElement-&gt;renderer() : nullptr;
1979 }
1980 #endif
1981 
1982 bool FrameView::useDarkAppearance() const
1983 {
1984 #if ENABLE(DARK_MODE_CSS)
<span class="line-modified">1985     if (auto* renderer = rendererForColorScheme())</span>
1986         return renderer-&gt;useDarkAppearance();
1987 #endif
1988     if (auto* document = frame().document())
1989         return document-&gt;useDarkAppearance(nullptr);
1990     return false;
1991 }
1992 
1993 OptionSet&lt;StyleColor::Options&gt; FrameView::styleColorOptions() const
1994 {
1995 #if ENABLE(DARK_MODE_CSS)
<span class="line-modified">1996     if (auto* renderer = rendererForColorScheme())</span>
1997         return renderer-&gt;styleColorOptions();
1998 #endif
1999     if (auto* document = frame().document())
2000         return document-&gt;styleColorOptions(nullptr);
2001     return { };
2002 }
2003 
2004 bool FrameView::scrollContentsFastPath(const IntSize&amp; scrollDelta, const IntRect&amp; rectToScroll, const IntRect&amp; clipRect)
2005 {
2006     if (!m_viewportConstrainedObjects || m_viewportConstrainedObjects-&gt;isEmpty()) {
2007         frame().page()-&gt;chrome().scroll(scrollDelta, rectToScroll, clipRect);
2008         return true;
2009     }
2010 
2011     bool isCompositedContentLayer = usesCompositedScrolling();
2012 
2013     // Get the rects of the fixed objects visible in the rectToScroll
2014     Region regionToUpdate;
2015     for (auto&amp; renderer : *m_viewportConstrainedObjects) {
2016         if (!renderer-&gt;style().hasViewportConstrainedPosition())
</pre>
<hr />
<pre>
2209     else
2210         scrollToAnchor();
2211 }
2212 
2213 void FrameView::scrollElementToRect(const Element&amp; element, const IntRect&amp; rect)
2214 {
2215     frame().document()-&gt;updateLayoutIgnorePendingStylesheets();
2216 
2217     LayoutRect bounds;
2218     if (RenderElement* renderer = element.renderer())
2219         bounds = renderer-&gt;absoluteAnchorRect();
2220     int centeringOffsetX = (rect.width() - bounds.width()) / 2;
2221     int centeringOffsetY = (rect.height() - bounds.height()) / 2;
2222     setScrollPosition(IntPoint(bounds.x() - centeringOffsetX - rect.x(), bounds.y() - centeringOffsetY - rect.y()));
2223 }
2224 
2225 void FrameView::setScrollPosition(const ScrollPosition&amp; scrollPosition)
2226 {
2227     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;FrameView::setScrollPosition &quot; &lt;&lt; scrollPosition &lt;&lt; &quot; , clearing anchor&quot;);
2228 
<span class="line-modified">2229     auto oldScrollType = currentScrollType();</span>
<span class="line-added">2230     setCurrentScrollType(ScrollType::Programmatic);</span>
<span class="line-added">2231 </span>
2232     m_maintainScrollPositionAnchor = nullptr;
2233     m_shouldScrollToFocusedElement = false;
2234     m_delayedScrollToFocusedElementTimer.stop();
2235     Page* page = frame().page();
2236     if (page &amp;&amp; page-&gt;expectsWheelEventTriggers())
2237         scrollAnimator().setWheelEventTestTrigger(page-&gt;testTrigger());
2238     ScrollView::setScrollPosition(scrollPosition);
<span class="line-added">2239 </span>
<span class="line-added">2240     setCurrentScrollType(oldScrollType);</span>
2241 }
2242 
2243 void FrameView::resetScrollAnchor()
2244 {
2245     ASSERT(frame().document());
2246     auto&amp; document = *frame().document();
2247 
2248     // If CSS target was set previously, we want to set it to 0, recalc
2249     // and possibly repaint because :target pseudo class may have been
2250     // set (see bug 11321).
2251     document.setCSSTarget(nullptr);
2252 
2253     if (is&lt;SVGDocument&gt;(document)) {
2254         if (auto rootElement = SVGDocument::rootElement(document)) {
2255             // We need to update the layout before resetScrollAnchor(), otherwise we
2256             // could really mess things up if resetting the anchor comes at a bad moment.
2257             document.updateStyleIfNeeded();
2258             rootElement-&gt;resetScrollAnchor();
2259         }
2260     }
</pre>
<hr />
<pre>
2494 
2495 bool FrameView::shouldUpdateCompositingLayersAfterScrolling() const
2496 {
2497 #if ENABLE(ASYNC_SCROLLING)
2498     // If the scrolling thread is updating the fixed elements, then the FrameView should not update them as well.
2499 
2500     Page* page = frame().page();
2501     if (!page)
2502         return true;
2503 
2504     if (&amp;page-&gt;mainFrame() != m_frame.ptr())
2505         return true;
2506 
2507     ScrollingCoordinator* scrollingCoordinator = page-&gt;scrollingCoordinator();
2508     if (!scrollingCoordinator)
2509         return true;
2510 
2511     if (scrollingCoordinator-&gt;shouldUpdateScrollLayerPositionSynchronously(*this))
2512         return true;
2513 
<span class="line-modified">2514     if (currentScrollType() == ScrollType::Programmatic)</span>
2515         return true;
2516 
2517     return false;
2518 #endif
2519     return true;
2520 }
2521 
2522 void FrameView::updateCompositingLayersAfterScrolling()
2523 {
2524     ASSERT(layoutContext().layoutPhase() &gt;= FrameViewLayoutContext::LayoutPhase::InPostLayout || layoutContext().layoutPhase() == FrameViewLayoutContext::LayoutPhase::OutsideLayout);
2525 
2526     if (!shouldUpdateCompositingLayersAfterScrolling())
2527         return;
2528 
2529     if (!layoutContext().isLayoutNested() &amp;&amp; hasViewportConstrainedObjects()) {
2530         if (RenderView* renderView = this-&gt;renderView())
2531             renderView-&gt;compositor().updateCompositingLayers(CompositingUpdateType::OnScroll);
2532     }
2533 }
2534 
</pre>
<hr />
<pre>
2713 
2714     TiledBacking::Scrollability scrollability = TiledBacking::NotScrollable;
2715     if (horizontallyScrollable)
2716         scrollability = TiledBacking::HorizontallyScrollable;
2717 
2718     if (verticallyScrollable)
2719         scrollability |= TiledBacking::VerticallyScrollable;
2720 
2721     return scrollability;
2722 }
2723 
2724 void FrameView::updateTiledBackingAdaptiveSizing()
2725 {
2726     auto* tiledBacking = this-&gt;tiledBacking();
2727     if (!tiledBacking)
2728         return;
2729 
2730     tiledBacking-&gt;setScrollability(computeScrollability());
2731 }
2732 
<span class="line-modified">2733 // FIXME: This shouldn&#39;t be called from outside; FrameView should call it when the relevant viewports change.</span>
<span class="line-modified">2734 void FrameView::layoutOrVisualViewportChanged()</span>

2735 {
2736     if (!frame().settings().visualViewportAPIEnabled())
2737         return;
2738 
2739     if (auto* window = frame().window())
2740         window-&gt;visualViewport().update();
<span class="line-added">2741 </span>
<span class="line-added">2742     if (auto* page = frame().page()) {</span>
<span class="line-added">2743         if (auto* scrollingCoordinator = page-&gt;scrollingCoordinator())</span>
<span class="line-added">2744             scrollingCoordinator-&gt;frameViewVisualViewportChanged(*this);</span>
<span class="line-added">2745     }</span>
2746 }
2747 
<span class="line-added">2748 #if PLATFORM(IOS_FAMILY)</span>
<span class="line-added">2749 </span>
2750 void FrameView::unobscuredContentSizeChanged()
2751 {
2752     updateTiledBackingAdaptiveSizing();
2753 }
2754 
2755 #endif
2756 
2757 static LayerFlushThrottleState::Flags determineLayerFlushThrottleState(Page&amp; page)
2758 {
2759     // We only throttle when constantly receiving new data during the inital page load.
2760     if (!page.progress().isMainLoadProgressing())
2761         return 0;
2762     // Scrolling during page loading disables throttling.
2763     if (page.mainFrame().view()-&gt;wasScrolledByUser())
2764         return 0;
2765     // Disable for image documents so large GIF animations don&#39;t get throttled during loading.
2766     auto* document = page.mainFrame().document();
2767     if (!document || is&lt;ImageDocument&gt;(*document))
2768         return 0;
2769     return LayerFlushThrottleState::Enabled;
</pre>
<hr />
<pre>
2876 
2877 void FrameView::hide()
2878 {
2879     ScrollView::hide();
2880     adjustTiledBackingCoverage();
2881 }
2882 
2883 bool FrameView::needsLayout() const
2884 {
2885     return layoutContext().needsLayout();
2886 }
2887 
2888 void FrameView::setNeedsLayoutAfterViewConfigurationChange()
2889 {
2890     layoutContext().setNeedsLayoutAfterViewConfigurationChange();
2891 }
2892 
2893 void FrameView::setNeedsCompositingConfigurationUpdate()
2894 {
2895     RenderView* renderView = this-&gt;renderView();
<span class="line-modified">2896     if (renderView &amp;&amp; renderView-&gt;usesCompositing()) {</span>
2897         if (auto* rootLayer = renderView-&gt;layer())
2898             rootLayer-&gt;setNeedsCompositingConfigurationUpdate();
2899         renderView-&gt;compositor().scheduleCompositingLayerUpdate();
2900     }
2901 }
2902 
2903 void FrameView::setNeedsCompositingGeometryUpdate()
2904 {
2905     RenderView* renderView = this-&gt;renderView();
2906     if (renderView-&gt;usesCompositing()) {
2907         if (auto* rootLayer = renderView-&gt;layer())
2908             rootLayer-&gt;setNeedsCompositingGeometryUpdate();
2909         renderView-&gt;compositor().scheduleCompositingLayerUpdate();
2910     }
2911 }
2912 
2913 void FrameView::scheduleSelectionUpdate()
2914 {
2915     if (needsLayout())
2916         return;
</pre>
<hr />
<pre>
2937     // and must not update compositing layers.
2938     if (!isViewForDocumentInFrame())
2939         return;
2940 
2941     setNeedsLayoutAfterViewConfigurationChange();
2942     setNeedsCompositingConfigurationUpdate();
2943 }
2944 
2945 bool FrameView::hasOpaqueBackground() const
2946 {
2947     return !m_isTransparent &amp;&amp; m_baseBackgroundColor.isOpaque();
2948 }
2949 
2950 Color FrameView::baseBackgroundColor() const
2951 {
2952     return m_baseBackgroundColor;
2953 }
2954 
2955 void FrameView::setBaseBackgroundColor(const Color&amp; backgroundColor)
2956 {
<span class="line-modified">2957     Color newBaseBackgroundColor = backgroundColor.isValid() ? backgroundColor : Color::white;</span>
<span class="line-added">2958     if (m_baseBackgroundColor == newBaseBackgroundColor)</span>
<span class="line-added">2959         return;</span>
<span class="line-added">2960 </span>
<span class="line-added">2961     m_baseBackgroundColor = newBaseBackgroundColor;</span>
2962 
2963     if (!isViewForDocumentInFrame())
2964         return;
2965 
2966     recalculateScrollbarOverlayStyle();
2967     setNeedsLayoutAfterViewConfigurationChange();
2968     setNeedsCompositingConfigurationUpdate();
2969 }
2970 
2971 void FrameView::updateBackgroundRecursively(const Optional&lt;Color&gt;&amp; backgroundColor)
2972 {
<span class="line-modified">2973 #if HAVE(OS_DARK_MODE_SUPPORT)</span>
2974     Color baseBackgroundColor = backgroundColor.valueOr(RenderTheme::singleton().systemColor(CSSValueAppleSystemControlBackground, styleColorOptions()));
2975 #else
2976     Color baseBackgroundColor = backgroundColor.valueOr(Color::white);
2977 #endif
2978 
2979     for (auto* frame = m_frame.ptr(); frame; frame = frame-&gt;tree().traverseNext(m_frame.ptr())) {
2980         if (FrameView* view = frame-&gt;view()) {
2981             view-&gt;setTransparent(!baseBackgroundColor.isVisible());
2982             view-&gt;setBaseBackgroundColor(baseBackgroundColor);
2983             if (view-&gt;needsLayout())
2984                 view-&gt;layoutContext().scheduleLayout();
2985         }
2986     }
2987 }
2988 
2989 bool FrameView::hasExtendedBackgroundRectForPainting() const
2990 {
2991     TiledBacking* tiledBacking = this-&gt;tiledBacking();
2992     if (!tiledBacking)
2993         return false;
</pre>
<hr />
<pre>
3395     ScrollView::willEndLiveResize();
3396     adjustTiledBackingCoverage();
3397 }
3398 
3399 void FrameView::autoSizeIfEnabled()
3400 {
3401     if (!m_shouldAutoSize)
3402         return;
3403 
3404     if (m_inAutoSize)
3405         return;
3406 
3407     auto* document = frame().document();
3408     if (!document)
3409         return;
3410 
3411     auto* renderView = document-&gt;renderView();
3412     if (!renderView)
3413         return;
3414 
<span class="line-added">3415     auto* firstChild = renderView-&gt;firstChild();</span>
<span class="line-added">3416     if (!firstChild)</span>
<span class="line-added">3417         return;</span>
<span class="line-added">3418 </span>
3419     LOG(Layout, &quot;FrameView %p autoSizeIfEnabled&quot;, this);
3420     SetForScope&lt;bool&gt; changeInAutoSize(m_inAutoSize, true);
3421     if (layoutContext().subtreeLayoutRoot())
3422         layoutContext().convertSubtreeLayoutToFullLayout();
















































3423 
<span class="line-modified">3424     ScrollbarMode horizonalScrollbarMode = ScrollbarAlwaysOff;</span>
<span class="line-modified">3425     ScrollbarMode verticalScrollbarMode = ScrollbarAlwaysOff;</span>
<span class="line-added">3426     setVerticalScrollbarLock(false);</span>
<span class="line-added">3427     setHorizontalScrollbarLock(false);</span>
<span class="line-added">3428     setScrollbarModes(horizonalScrollbarMode, verticalScrollbarMode, true, true);</span>
3429 
<span class="line-modified">3430     ASSERT(is&lt;RenderElement&gt;(*firstChild));</span>
<span class="line-modified">3431     auto&amp; documentRenderer = downcast&lt;RenderElement&gt;(*firstChild);</span>
<span class="line-modified">3432     documentRenderer.mutableStyle().setMaxWidth(Length(m_autoSizeConstraint.width(), Fixed));</span>
<span class="line-modified">3433     resize(m_autoSizeConstraint.width(), m_autoSizeConstraint.height());</span>

3434 










3435     Ref&lt;FrameView&gt; protectedThis(*this);

3436     document-&gt;updateStyleIfNeeded();
<span class="line-modified">3437     document-&gt;updateLayoutIgnorePendingStylesheets();</span>
<span class="line-added">3438     // While the final content size could slightly be different after the next resize/layout (see below), we intentionally save and report</span>
<span class="line-added">3439     // the current value to avoid unstable layout (e.g. content &quot;height: 100%&quot;).</span>
<span class="line-added">3440     // See also webkit.org/b/173561</span>
3441     m_autoSizeContentSize = contentsSize();






3442 
<span class="line-modified">3443     auto finalWidth = std::max(m_autoSizeConstraint.width(), m_autoSizeContentSize.width());</span>
<span class="line-added">3444     auto finalHeight = m_autoSizeFixedMinimumHeight ? std::max(m_autoSizeFixedMinimumHeight, m_autoSizeContentSize.height()) : m_autoSizeContentSize.height();</span>
<span class="line-added">3445     resize(finalWidth, finalHeight);</span>
<span class="line-added">3446     document-&gt;updateLayoutIgnorePendingStylesheets();</span>
<span class="line-added">3447     if (auto* page = frame().page())</span>
<span class="line-added">3448         page-&gt;chrome().client().intrinsicContentsSizeChanged(m_autoSizeContentSize);</span>
<span class="line-added">3449     m_didRunAutosize = true;</span>
3450 }
3451 
3452 void FrameView::setAutoSizeFixedMinimumHeight(int fixedMinimumHeight)
3453 {
3454     if (m_autoSizeFixedMinimumHeight == fixedMinimumHeight)
3455         return;
3456 
3457     m_autoSizeFixedMinimumHeight = fixedMinimumHeight;
3458 
3459     setNeedsLayoutAfterViewConfigurationChange();
3460 }
3461 
3462 RenderElement* FrameView::viewportRenderer() const
3463 {
3464     if (m_viewportRendererType == ViewportRendererType::None)
3465         return nullptr;
3466 
3467     auto* document = frame().document();
3468     if (!document)
3469         return nullptr;
</pre>
<hr />
<pre>
4000 
4001     GraphicsContext context(paintInvalidationReasons);
4002     if (platformWidget()) {
4003         // FIXME: consult paintsEntireContents().
4004         paintContents(context, visibleContentRect(LegacyIOSDocumentVisibleRect));
4005     } else
4006         paint(context, frameRect());
4007 }
4008 
4009 bool FrameView::wasScrolledByUser() const
4010 {
4011     return m_wasScrolledByUser;
4012 }
4013 
4014 void FrameView::setWasScrolledByUser(bool wasScrolledByUser)
4015 {
4016     LOG(Scrolling, &quot;FrameView::setWasScrolledByUser at %d&quot;, wasScrolledByUser);
4017 
4018     m_shouldScrollToFocusedElement = false;
4019     m_delayedScrollToFocusedElementTimer.stop();
<span class="line-modified">4020     if (currentScrollType() == ScrollType::Programmatic)</span>
4021         return;
4022     m_maintainScrollPositionAnchor = nullptr;
4023     if (m_wasScrolledByUser == wasScrolledByUser)
4024         return;
4025     m_wasScrolledByUser = wasScrolledByUser;
4026     if (frame().isMainFrame())
4027         updateLayerFlushThrottling();
4028     adjustTiledBackingCoverage();
4029 }
4030 
4031 void FrameView::willPaintContents(GraphicsContext&amp; context, const IntRect&amp;, PaintingState&amp; paintingState)
4032 {
4033     Document* document = frame().document();
4034 
4035     if (!context.paintingDisabled())
4036         InspectorInstrumentation::willPaint(*renderView());
4037 
4038     paintingState.isTopLevelPainter = !sCurrentPaintTimeStamp;
4039 
4040     if (paintingState.isTopLevelPainter)
</pre>
<hr />
<pre>
4059     }
4060 
4061     paintingState.isFlatteningPaintOfRootFrame = (m_paintBehavior &amp; PaintBehavior::FlattenCompositingLayers) &amp;&amp; !frame().ownerElement();
4062     if (paintingState.isFlatteningPaintOfRootFrame)
4063         notifyWidgetsInAllFrames(WillPaintFlattened);
4064 
4065     ASSERT(!m_isPainting);
4066     m_isPainting = true;
4067 }
4068 
4069 void FrameView::didPaintContents(GraphicsContext&amp; context, const IntRect&amp; dirtyRect, PaintingState&amp; paintingState)
4070 {
4071     m_isPainting = false;
4072 
4073     if (paintingState.isFlatteningPaintOfRootFrame)
4074         notifyWidgetsInAllFrames(DidPaintFlattened);
4075 
4076     m_paintBehavior = paintingState.paintBehavior;
4077     m_lastPaintTime = MonotonicTime::now();
4078 



4079     if (paintingState.isTopLevelPainter)
4080         sCurrentPaintTimeStamp = MonotonicTime();
4081 
4082     if (!context.paintingDisabled()) {
4083         InspectorInstrumentation::didPaint(*renderView(), dirtyRect);
4084         // FIXME: should probably not fire milestones for snapshot painting. https://bugs.webkit.org/show_bug.cgi?id=117623
4085         firePaintRelatedMilestonesIfNeeded();
4086     }
4087 }
4088 
4089 void FrameView::paintContents(GraphicsContext&amp; context, const IntRect&amp; dirtyRect, SecurityOriginPaintPolicy securityOriginPaintPolicy)
4090 {
4091 #ifndef NDEBUG
4092     bool fillWithWarningColor;
4093     if (frame().document()-&gt;printing())
4094         fillWithWarningColor = false; // Printing, don&#39;t fill with red (can&#39;t remember why).
4095     else if (frame().ownerElement())
4096         fillWithWarningColor = false; // Subframe, don&#39;t fill with red.
4097     else if (isTransparent())
4098         fillWithWarningColor = false; // Transparent, don&#39;t fill with red.
</pre>
<hr />
<pre>
4419         }
4420         return false;
4421     };
4422 
4423     // Finished parsing the main document and we still don&#39;t yet have enough content. Check if we might be getting some more.
4424     if (finishedParsingMainDocument)
4425         return !isMoreContentExpected();
4426 
4427     return false;
4428 }
4429 
4430 bool FrameView::isViewForDocumentInFrame() const
4431 {
4432     RenderView* renderView = this-&gt;renderView();
4433     if (!renderView)
4434         return false;
4435 
4436     return &amp;renderView-&gt;frameView() == this;
4437 }
4438 
<span class="line-modified">4439 void FrameView::enableAutoSizeMode(bool enable, const IntSize&amp; viewSize)</span>
4440 {
<span class="line-modified">4441     ASSERT(!enable || !viewSize.isEmpty());</span>
<span class="line-modified">4442     if (m_shouldAutoSize == enable &amp;&amp; m_autoSizeConstraint == viewSize)</span>



4443         return;
4444 
4445     m_shouldAutoSize = enable;
<span class="line-modified">4446     m_autoSizeConstraint = viewSize;</span>
<span class="line-modified">4447     m_autoSizeContentSize = contentsSize();</span>
4448     m_didRunAutosize = false;
4449 
4450     setNeedsLayoutAfterViewConfigurationChange();
4451     layoutContext().scheduleLayout();
4452     if (m_shouldAutoSize) {
<span class="line-modified">4453         overrideViewportSizeForCSSViewportUnits({ m_autoSizeConstraint.width(), m_overrideViewportSize ? m_overrideViewportSize-&gt;height : WTF::nullopt });</span>
4454         return;
4455     }
4456 
4457     clearViewportSizeOverrideForCSSViewportUnits();
4458     // Since autosize mode forces the scrollbar mode, change them to being auto.
4459     setVerticalScrollbarLock(false);
4460     setHorizontalScrollbarLock(false);
4461     setScrollbarModes(ScrollbarAuto, ScrollbarAuto);
4462 }
4463 
4464 void FrameView::forceLayout(bool allowSubtreeLayout)
4465 {
4466     if (!allowSubtreeLayout &amp;&amp; layoutContext().subtreeLayoutRoot())
4467         layoutContext().convertSubtreeLayoutToFullLayout();
4468     layoutContext().layout();
4469 }
4470 
4471 void FrameView::forceLayoutForPagination(const FloatSize&amp; pageSize, const FloatSize&amp; originalPageSize, float maximumShrinkFactor, AdjustViewSizeOrNot shouldAdjustViewSize)
4472 {
4473     if (!renderView())
</pre>
<hr />
<pre>
4497     if (docLogicalWidth &gt; pageLogicalWidth) {
4498         int expectedPageWidth = std::min&lt;float&gt;(documentRect.width(), pageSize.width() * maximumShrinkFactor);
4499         int expectedPageHeight = std::min&lt;float&gt;(documentRect.height(), pageSize.height() * maximumShrinkFactor);
4500         FloatSize maxPageSize = frame().resizePageRectsKeepingRatio(FloatSize(originalPageSize.width(), originalPageSize.height()), FloatSize(expectedPageWidth, expectedPageHeight));
4501         pageLogicalWidth = horizontalWritingMode ? maxPageSize.width() : maxPageSize.height();
4502         pageLogicalHeight = horizontalWritingMode ? maxPageSize.height() : maxPageSize.width();
4503 
4504         renderView.setPageLogicalSize({ floor(pageLogicalWidth), floor(pageLogicalHeight) });
4505         renderView.setNeedsLayoutAndPrefWidthsRecalc();
4506         forceLayout();
4507         if (hasOneRef())
4508             return;
4509 
4510         const LayoutRect&amp; updatedDocumentRect = renderView.documentRect();
4511         LayoutUnit docLogicalHeight = horizontalWritingMode ? updatedDocumentRect.height() : updatedDocumentRect.width();
4512         LayoutUnit docLogicalTop = horizontalWritingMode ? updatedDocumentRect.y() : updatedDocumentRect.x();
4513         LayoutUnit docLogicalRight = horizontalWritingMode ? updatedDocumentRect.maxX() : updatedDocumentRect.maxY();
4514         LayoutUnit clippedLogicalLeft;
4515         if (!renderView.style().isLeftToRightDirection())
4516             clippedLogicalLeft = docLogicalRight - pageLogicalWidth;
<span class="line-modified">4517         LayoutRect overflow { clippedLogicalLeft, docLogicalTop, LayoutUnit(pageLogicalWidth), docLogicalHeight };</span>
4518 
4519         if (!horizontalWritingMode)
4520             overflow = overflow.transposedRect();
4521         renderView.clearLayoutOverflow();
4522         renderView.addLayoutOverflow(overflow); // This is how we clip in case we overflow again.
4523     }
4524 
4525     if (shouldAdjustViewSize)
4526         adjustViewSize();
4527 }
4528 
4529 void FrameView::adjustPageHeightDeprecated(float *newBottom, float oldTop, float oldBottom, float /*bottomLimit*/)
4530 {
4531     RenderView* renderView = this-&gt;renderView();
4532     if (!renderView) {
4533         *newBottom = oldBottom;
4534         return;
4535 
4536     }
4537     // Use a context with painting disabled.
</pre>
<hr />
<pre>
4740 }
4741 
4742 FloatPoint FrameView::documentToClientPoint(FloatPoint p) const
4743 {
4744     p.move(documentToClientOffset());
4745     return p;
4746 }
4747 
4748 FloatRect FrameView::clientToDocumentRect(FloatRect rect) const
4749 {
4750     rect.move(-documentToClientOffset());
4751     return rect;
4752 }
4753 
4754 FloatPoint FrameView::clientToDocumentPoint(FloatPoint point) const
4755 {
4756     point.move(-documentToClientOffset());
4757     return point;
4758 }
4759 
<span class="line-added">4760 FloatPoint FrameView::absoluteToLayoutViewportPoint(FloatPoint p) const</span>
<span class="line-added">4761 {</span>
<span class="line-added">4762     ASSERT(frame().settings().visualViewportEnabled());</span>
<span class="line-added">4763     p.scale(1 / frame().frameScaleFactor());</span>
<span class="line-added">4764     p.moveBy(-layoutViewportRect().location());</span>
<span class="line-added">4765     return p;</span>
<span class="line-added">4766 }</span>
<span class="line-added">4767 </span>
4768 FloatPoint FrameView::layoutViewportToAbsolutePoint(FloatPoint p) const
4769 {
4770     ASSERT(frame().settings().visualViewportEnabled());
4771     p.moveBy(layoutViewportRect().location());
4772     return p.scaled(frame().frameScaleFactor());
4773 }
4774 
<span class="line-added">4775 FloatRect FrameView::layoutViewportToAbsoluteRect(FloatRect rect) const</span>
<span class="line-added">4776 {</span>
<span class="line-added">4777     ASSERT(frame().settings().visualViewportEnabled());</span>
<span class="line-added">4778     rect.moveBy(layoutViewportRect().location());</span>
<span class="line-added">4779     rect.scale(frame().frameScaleFactor());</span>
<span class="line-added">4780     return rect;</span>
<span class="line-added">4781 }</span>
<span class="line-added">4782 </span>
<span class="line-added">4783 FloatRect FrameView::absoluteToLayoutViewportRect(FloatRect rect) const</span>
<span class="line-added">4784 {</span>
<span class="line-added">4785     ASSERT(frame().settings().visualViewportEnabled());</span>
<span class="line-added">4786     rect.scale(1 / frame().frameScaleFactor());</span>
<span class="line-added">4787     rect.moveBy(-layoutViewportRect().location());</span>
<span class="line-added">4788     return rect;</span>
<span class="line-added">4789 }</span>
<span class="line-added">4790 </span>
4791 FloatRect FrameView::clientToLayoutViewportRect(FloatRect rect) const
4792 {
4793     ASSERT(frame().settings().visualViewportEnabled());
4794     rect.scale(frame().pageZoomFactor());
4795     return rect;
4796 }
4797 
4798 FloatPoint FrameView::clientToLayoutViewportPoint(FloatPoint p) const
4799 {
4800     ASSERT(frame().settings().visualViewportEnabled());
4801     return p.scaled(frame().pageZoomFactor());
4802 }
4803 
4804 void FrameView::setTracksRepaints(bool trackRepaints)
4805 {
4806     if (trackRepaints == m_isTrackingRepaints)
4807         return;
4808 
4809     // Force layout to flush out any pending repaints.
4810     if (trackRepaints) {
</pre>
<hr />
<pre>
4832 {
4833     Frame&amp; frame = this-&gt;frame();
4834     Ref&lt;Frame&gt; protector(frame);
4835 
4836     if (auto* document = frame.document())
4837         document-&gt;updateLayout();
4838 
4839     TextStream ts;
4840     if (!m_trackedRepaintRects.isEmpty()) {
4841         ts &lt;&lt; &quot;(repaint rects\n&quot;;
4842         for (auto&amp; rect : m_trackedRepaintRects)
4843             ts &lt;&lt; &quot;  (rect &quot; &lt;&lt; LayoutUnit(rect.x()) &lt;&lt; &quot; &quot; &lt;&lt; LayoutUnit(rect.y()) &lt;&lt; &quot; &quot; &lt;&lt; LayoutUnit(rect.width()) &lt;&lt; &quot; &quot; &lt;&lt; LayoutUnit(rect.height()) &lt;&lt; &quot;)\n&quot;;
4844         ts &lt;&lt; &quot;)\n&quot;;
4845     }
4846     return ts.release();
4847 }
4848 
4849 bool FrameView::addScrollableArea(ScrollableArea* scrollableArea)
4850 {
4851     if (!m_scrollableAreas)
<span class="line-modified">4852         m_scrollableAreas = makeUnique&lt;ScrollableAreaSet&gt;();</span>
4853 
4854     if (m_scrollableAreas-&gt;add(scrollableArea).isNewEntry) {
4855         scrollableAreaSetChanged();
4856         return true;
4857     }
4858 
4859     return false;
4860 }
4861 
4862 bool FrameView::removeScrollableArea(ScrollableArea* scrollableArea)
4863 {
4864     if (m_scrollableAreas &amp;&amp; m_scrollableAreas-&gt;remove(scrollableArea)) {
4865         scrollableAreaSetChanged();
4866         return true;
4867     }
4868     return false;
4869 }
4870 
4871 bool FrameView::containsScrollableArea(ScrollableArea* scrollableArea) const
4872 {
</pre>
<hr />
<pre>
5002     IntRect newRect;
5003     Page* page = frame().page();
5004     if (!page || !page-&gt;chrome().client().fetchCustomFixedPositionLayoutRect(newRect))
5005         return false;
5006 
5007     if (newRect != m_customFixedPositionLayoutRect) {
5008         m_customFixedPositionLayoutRect = newRect;
5009         setViewportConstrainedObjectsNeedLayout();
5010         return true;
5011     }
5012     return false;
5013 }
5014 
5015 void FrameView::setCustomSizeForResizeEvent(IntSize customSize)
5016 {
5017     m_useCustomSizeForResizeEvent = true;
5018     m_customSizeForResizeEvent = customSize;
5019     sendResizeEventIfNeeded();
5020 }
5021 
<span class="line-modified">5022 void FrameView::setScrollVelocity(const VelocityData&amp; velocityData)</span>
5023 {
5024     if (TiledBacking* tiledBacking = this-&gt;tiledBacking())
<span class="line-modified">5025         tiledBacking-&gt;setVelocity(velocityData);</span>
5026 }
5027 #endif // PLATFORM(IOS_FAMILY)
5028 
5029 void FrameView::setScrollingPerformanceLoggingEnabled(bool flag)
5030 {
5031     if (TiledBacking* tiledBacking = this-&gt;tiledBacking())
5032         tiledBacking-&gt;setScrollingPerformanceLoggingEnabled(flag);
5033 }
5034 
5035 void FrameView::didAddScrollbar(Scrollbar* scrollbar, ScrollbarOrientation orientation)
5036 {
5037     ScrollableArea::didAddScrollbar(scrollbar, orientation);
5038     Page* page = frame().page();
5039     if (page &amp;&amp; page-&gt;expectsWheelEventTriggers())
5040         scrollAnimator().setWheelEventTestTrigger(page-&gt;testTrigger());
5041     if (AXObjectCache* cache = axObjectCache())
5042         cache-&gt;handleScrollbarUpdate(this);
5043 }
5044 
5045 void FrameView::willRemoveScrollbar(Scrollbar* scrollbar, ScrollbarOrientation orientation)
</pre>
<hr />
<pre>
5145     updateScrollbars(scrollPosition());
5146 }
5147 
5148 ScrollBehaviorForFixedElements FrameView::scrollBehaviorForFixedElements() const
5149 {
5150     return frame().settings().backgroundShouldExtendBeyondPage() ? StickToViewportBounds : StickToDocumentBounds;
5151 }
5152 
5153 RenderView* FrameView::renderView() const
5154 {
5155     return frame().contentRenderer();
5156 }
5157 
5158 int FrameView::mapFromLayoutToCSSUnits(LayoutUnit value) const
5159 {
5160     return value / (frame().pageZoomFactor() * frame().frameScaleFactor());
5161 }
5162 
5163 LayoutUnit FrameView::mapFromCSSToLayoutUnits(int value) const
5164 {
<span class="line-modified">5165     return LayoutUnit(value * frame().pageZoomFactor() * frame().frameScaleFactor());</span>
5166 }
5167 
5168 void FrameView::didAddWidgetToRenderTree(Widget&amp; widget)
5169 {
5170     ASSERT(!m_widgetsInRenderTree.contains(&amp;widget));
5171     m_widgetsInRenderTree.add(&amp;widget);
5172 }
5173 
5174 void FrameView::willRemoveWidgetFromRenderTree(Widget&amp; widget)
5175 {
5176     ASSERT(m_widgetsInRenderTree.contains(&amp;widget));
5177     m_widgetsInRenderTree.remove(&amp;widget);
5178 }
5179 
5180 static Vector&lt;RefPtr&lt;Widget&gt;&gt; collectAndProtectWidgets(const HashSet&lt;Widget*&gt;&amp; set)
5181 {
5182     return copyToVectorOf&lt;RefPtr&lt;Widget&gt;&gt;(set);
5183 }
5184 
5185 void FrameView::updateWidgetPositions()
</pre>
</td>
</tr>
</table>
<center><a href="FrameTree.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="FrameView.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>