<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/jsc.cpp</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="jit/ThunkGenerators.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="llint/LLIntData.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/jsc.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
   2  *  Copyright (C) 1999-2000 Harri Porten (porten@kde.org)
<span class="line-modified">   3  *  Copyright (C) 2004-2018 Apple Inc. All rights reserved.</span>
   4  *  Copyright (C) 2006 Bjoern Graf (bjoern.graf@gmail.com)
   5  *
   6  *  This library is free software; you can redistribute it and/or
   7  *  modify it under the terms of the GNU Library General Public
   8  *  License as published by the Free Software Foundation; either
   9  *  version 2 of the License, or (at your option) any later version.
  10  *
  11  *  This library is distributed in the hope that it will be useful,
  12  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  13  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  14  *  Library General Public License for more details.
  15  *
  16  *  You should have received a copy of the GNU Library General Public License
  17  *  along with this library; see the file COPYING.LIB.  If not, write to
  18  *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  19  *  Boston, MA 02110-1301, USA.
  20  *
  21  */
  22 
  23 #include &quot;config.h&quot;
  24 
  25 #include &quot;ArrayBuffer.h&quot;
  26 #include &quot;ArrayPrototype.h&quot;
  27 #include &quot;BuiltinNames.h&quot;
  28 #include &quot;ButterflyInlines.h&quot;

  29 #include &quot;CatchScope.h&quot;
  30 #include &quot;CodeBlock.h&quot;
  31 #include &quot;CodeCache.h&quot;
  32 #include &quot;Completion.h&quot;
  33 #include &quot;ConfigFile.h&quot;
  34 #include &quot;Disassembler.h&quot;
  35 #include &quot;Exception.h&quot;
  36 #include &quot;ExceptionHelpers.h&quot;
  37 #include &quot;HeapProfiler.h&quot;
  38 #include &quot;HeapSnapshotBuilder.h&quot;
  39 #include &quot;InitializeThreading.h&quot;
  40 #include &quot;Interpreter.h&quot;
  41 #include &quot;JIT.h&quot;
  42 #include &quot;JSArray.h&quot;
  43 #include &quot;JSArrayBuffer.h&quot;
  44 #include &quot;JSBigInt.h&quot;
  45 #include &quot;JSCInlines.h&quot;
  46 #include &quot;JSFunction.h&quot;
  47 #include &quot;JSInternalPromise.h&quot;
  48 #include &quot;JSInternalPromiseDeferred.h&quot;
</pre>
<hr />
<pre>
  52 #include &quot;JSONObject.h&quot;
  53 #include &quot;JSSourceCode.h&quot;
  54 #include &quot;JSString.h&quot;
  55 #include &quot;JSTypedArrays.h&quot;
  56 #include &quot;JSWebAssemblyInstance.h&quot;
  57 #include &quot;JSWebAssemblyMemory.h&quot;
  58 #include &quot;LLIntThunks.h&quot;
  59 #include &quot;ObjectConstructor.h&quot;
  60 #include &quot;ParserError.h&quot;
  61 #include &quot;ProfilerDatabase.h&quot;
  62 #include &quot;PromiseDeferredTimer.h&quot;
  63 #include &quot;ProtoCallFrame.h&quot;
  64 #include &quot;ReleaseHeapAccessScope.h&quot;
  65 #include &quot;SamplingProfiler.h&quot;
  66 #include &quot;StackVisitor.h&quot;
  67 #include &quot;StructureInlines.h&quot;
  68 #include &quot;StructureRareDataInlines.h&quot;
  69 #include &quot;SuperSampler.h&quot;
  70 #include &quot;TestRunnerUtils.h&quot;
  71 #include &quot;TypedArrayInlines.h&quot;

  72 #include &quot;WasmContext.h&quot;
  73 #include &quot;WasmFaultSignalHandler.h&quot;
  74 #include &quot;WasmMemory.h&quot;
  75 #include &lt;locale.h&gt;
  76 #include &lt;math.h&gt;
  77 #include &lt;stdio.h&gt;
  78 #include &lt;stdlib.h&gt;
  79 #include &lt;string.h&gt;
  80 #include &lt;sys/stat.h&gt;
  81 #include &lt;sys/types.h&gt;
  82 #include &lt;thread&gt;
  83 #include &lt;type_traits&gt;
  84 #include &lt;wtf/Box.h&gt;
  85 #include &lt;wtf/CommaPrinter.h&gt;

  86 #include &lt;wtf/MainThread.h&gt;
  87 #include &lt;wtf/MemoryPressureHandler.h&gt;
  88 #include &lt;wtf/MonotonicTime.h&gt;
  89 #include &lt;wtf/NeverDestroyed.h&gt;
  90 #include &lt;wtf/Scope.h&gt;
  91 #include &lt;wtf/StringPrintStream.h&gt;
  92 #include &lt;wtf/URL.h&gt;
  93 #include &lt;wtf/WallTime.h&gt;
  94 #include &lt;wtf/text/StringBuilder.h&gt;
  95 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
  96 
  97 #if OS(WINDOWS)
  98 #include &lt;direct.h&gt;
  99 #include &lt;fcntl.h&gt;
 100 #include &lt;io.h&gt;
<span class="line-removed"> 101 #include &lt;wtf/text/win/WCharStringExtras.h&gt;</span>
 102 #else
 103 #include &lt;unistd.h&gt;
 104 #endif
 105 
 106 #if PLATFORM(COCOA)
 107 #include &lt;crt_externs.h&gt;
 108 #endif
 109 
 110 #if HAVE(READLINE)
 111 // readline/history.h has a Function typedef which conflicts with the WTF::Function template from WTF/Forward.h
 112 // We #define it to something else to avoid this conflict.
 113 #define Function ReadlineFunction
 114 #include &lt;readline/history.h&gt;
 115 #include &lt;readline/readline.h&gt;
 116 #undef Function
 117 #endif
 118 
 119 #if HAVE(SYS_TIME_H)
 120 #include &lt;sys/time.h&gt;
 121 #endif
 122 
 123 #if HAVE(SIGNAL_H)
 124 #include &lt;signal.h&gt;
 125 #endif
 126 
 127 #if COMPILER(MSVC)
 128 #include &lt;crtdbg.h&gt;
 129 #include &lt;mmsystem.h&gt;
 130 #include &lt;windows.h&gt;
 131 #endif
 132 
 133 #if PLATFORM(IOS_FAMILY) &amp;&amp; CPU(ARM_THUMB2)
 134 #include &lt;fenv.h&gt;
 135 #include &lt;arm/arch.h&gt;
 136 #endif
 137 
<span class="line-modified"> 138 #if __has_include(&lt;WebKitAdditions/MemoryFootprint.h&gt;)</span>
<span class="line-modified"> 139 #include &lt;WebKitAdditions/MemoryFootprint.h&gt;</span>






 140 #else
 141 struct MemoryFootprint {
 142     uint64_t current;
 143     uint64_t peak;
 144 
 145     static MemoryFootprint now()
 146     {
 147         return { 0L, 0L };
 148     }
 149 
 150     static void resetPeak()
 151     {
 152     }
 153 };
 154 #endif
 155 
 156 #if !defined(PATH_MAX)
 157 #define PATH_MAX 4096
 158 #endif
 159 
</pre>
<hr />
<pre>
 176         }
 177     }
 178 #endif // ENABLE(DFG_JIT)
 179     exit(status);
 180 }
 181 
 182 class Masquerader : public JSNonFinalObject {
 183 public:
 184     Masquerader(VM&amp; vm, Structure* structure)
 185         : Base(vm, structure)
 186     {
 187     }
 188 
 189     typedef JSNonFinalObject Base;
 190     static const unsigned StructureFlags = Base::StructureFlags | JSC::MasqueradesAsUndefined;
 191 
 192     static Masquerader* create(VM&amp; vm, JSGlobalObject* globalObject)
 193     {
 194         globalObject-&gt;masqueradesAsUndefinedWatchpoint()-&gt;fireAll(vm, &quot;Masquerading object allocated&quot;);
 195         Structure* structure = createStructure(vm, globalObject, jsNull());
<span class="line-modified"> 196         Masquerader* result = new (NotNull, allocateCell&lt;Masquerader&gt;(vm.heap, sizeof(Masquerader))) Masquerader(vm, structure);</span>
 197         result-&gt;finishCreation(vm);
 198         return result;
 199     }
 200 
 201     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 202     {
 203         return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
 204     }
 205 
 206     DECLARE_INFO;
 207 };
 208 
 209 const ClassInfo Masquerader::s_info = { &quot;Masquerader&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(Masquerader) };
 210 static unsigned asyncTestPasses { 0 };
 211 static unsigned asyncTestExpectedPasses { 0 };
 212 
 213 }
 214 
 215 template&lt;typename Vector&gt;
 216 static bool fillBufferWithContentsOfFile(const String&amp; fileName, Vector&amp; buffer);
</pre>
<hr />
<pre>
 311 static EncodedJSValue JSC_HOST_CALL functionNoFTL(ExecState*);
 312 static EncodedJSValue JSC_HOST_CALL functionNoOSRExitFuzzing(ExecState*);
 313 static EncodedJSValue JSC_HOST_CALL functionOptimizeNextInvocation(ExecState*);
 314 static EncodedJSValue JSC_HOST_CALL functionNumberOfDFGCompiles(ExecState*);
 315 static EncodedJSValue JSC_HOST_CALL functionJSCOptions(ExecState*);
 316 static EncodedJSValue JSC_HOST_CALL functionReoptimizationRetryCount(ExecState*);
 317 static EncodedJSValue JSC_HOST_CALL functionTransferArrayBuffer(ExecState*);
 318 static EncodedJSValue JSC_HOST_CALL functionFailNextNewCodeBlock(ExecState*);
 319 static NO_RETURN_WITH_VALUE EncodedJSValue JSC_HOST_CALL functionQuit(ExecState*);
 320 static EncodedJSValue JSC_HOST_CALL functionFalse(ExecState*);
 321 static EncodedJSValue JSC_HOST_CALL functionUndefined1(ExecState*);
 322 static EncodedJSValue JSC_HOST_CALL functionUndefined2(ExecState*);
 323 static EncodedJSValue JSC_HOST_CALL functionIsInt32(ExecState*);
 324 static EncodedJSValue JSC_HOST_CALL functionIsPureNaN(ExecState*);
 325 static EncodedJSValue JSC_HOST_CALL functionEffectful42(ExecState*);
 326 static EncodedJSValue JSC_HOST_CALL functionIdentity(ExecState*);
 327 static EncodedJSValue JSC_HOST_CALL functionMakeMasquerader(ExecState*);
 328 static EncodedJSValue JSC_HOST_CALL functionHasCustomProperties(ExecState*);
 329 static EncodedJSValue JSC_HOST_CALL functionDumpTypesForAllVariables(ExecState*);
 330 static EncodedJSValue JSC_HOST_CALL functionDrainMicrotasks(ExecState*);

 331 static EncodedJSValue JSC_HOST_CALL functionIs32BitPlatform(ExecState*);
 332 static EncodedJSValue JSC_HOST_CALL functionCheckModuleSyntax(ExecState*);
 333 static EncodedJSValue JSC_HOST_CALL functionPlatformSupportsSamplingProfiler(ExecState*);
 334 static EncodedJSValue JSC_HOST_CALL functionGenerateHeapSnapshot(ExecState*);
 335 static EncodedJSValue JSC_HOST_CALL functionGenerateHeapSnapshotForGCDebugging(ExecState*);
 336 static EncodedJSValue JSC_HOST_CALL functionResetSuperSamplerState(ExecState*);
 337 static EncodedJSValue JSC_HOST_CALL functionEnsureArrayStorage(ExecState*);
 338 #if ENABLE(SAMPLING_PROFILER)
 339 static EncodedJSValue JSC_HOST_CALL functionStartSamplingProfiler(ExecState*);
 340 static EncodedJSValue JSC_HOST_CALL functionSamplingProfilerStackTraces(ExecState*);
 341 #endif
 342 
 343 static EncodedJSValue JSC_HOST_CALL functionMaxArguments(ExecState*);
 344 static EncodedJSValue JSC_HOST_CALL functionAsyncTestStart(ExecState*);
 345 static EncodedJSValue JSC_HOST_CALL functionAsyncTestPassed(ExecState*);
 346 
 347 #if ENABLE(WEBASSEMBLY)
 348 static EncodedJSValue JSC_HOST_CALL functionWebAssemblyMemoryMode(ExecState*);
 349 #endif
 350 
</pre>
<hr />
<pre>
 358 static EncodedJSValue JSC_HOST_CALL functionIsRope(ExecState*);
 359 static EncodedJSValue JSC_HOST_CALL functionCallerSourceOrigin(ExecState*);
 360 static EncodedJSValue JSC_HOST_CALL functionDollarCreateRealm(ExecState*);
 361 static EncodedJSValue JSC_HOST_CALL functionDollarDetachArrayBuffer(ExecState*);
 362 static EncodedJSValue JSC_HOST_CALL functionDollarEvalScript(ExecState*);
 363 static EncodedJSValue JSC_HOST_CALL functionDollarAgentStart(ExecState*);
 364 static EncodedJSValue JSC_HOST_CALL functionDollarAgentReceiveBroadcast(ExecState*);
 365 static EncodedJSValue JSC_HOST_CALL functionDollarAgentReport(ExecState*);
 366 static EncodedJSValue JSC_HOST_CALL functionDollarAgentSleep(ExecState*);
 367 static EncodedJSValue JSC_HOST_CALL functionDollarAgentBroadcast(ExecState*);
 368 static EncodedJSValue JSC_HOST_CALL functionDollarAgentGetReport(ExecState*);
 369 static EncodedJSValue JSC_HOST_CALL functionDollarAgentLeaving(ExecState*);
 370 static EncodedJSValue JSC_HOST_CALL functionDollarAgentMonotonicNow(ExecState*);
 371 static EncodedJSValue JSC_HOST_CALL functionWaitForReport(ExecState*);
 372 static EncodedJSValue JSC_HOST_CALL functionHeapCapacity(ExecState*);
 373 static EncodedJSValue JSC_HOST_CALL functionFlashHeapAccess(ExecState*);
 374 static EncodedJSValue JSC_HOST_CALL functionDisableRichSourceInfo(ExecState*);
 375 static EncodedJSValue JSC_HOST_CALL functionMallocInALoop(ExecState*);
 376 static EncodedJSValue JSC_HOST_CALL functionTotalCompileTime(ExecState*);
 377 


 378 struct Script {
 379     enum class StrictMode {
 380         Strict,
 381         Sloppy
 382     };
 383 
 384     enum class ScriptType {
 385         Script,
 386         Module
 387     };
 388 
 389     enum class CodeSource {
 390         File,
 391         CommandLine
 392     };
 393 
 394     StrictMode strictMode;
 395     CodeSource codeSource;
 396     ScriptType scriptType;
 397     char* argument;
 398 
 399     Script(StrictMode strictMode, CodeSource codeSource, ScriptType scriptType, char *argument)
 400         : strictMode(strictMode)
 401         , codeSource(codeSource)
 402         , scriptType(scriptType)
 403         , argument(argument)
 404     {
 405         if (strictMode == StrictMode::Strict)
 406             ASSERT(codeSource == CodeSource::File);
 407     }
 408 };
 409 
 410 class CommandLine {
 411 public:
 412     CommandLine(int argc, char** argv)
 413     {
 414         parseArguments(argc, argv);
 415     }
 416 




 417     bool m_interactive { false };
 418     bool m_dump { false };
 419     bool m_module { false };
 420     bool m_exitCode { false };
<span class="line-modified"> 421     Vector&lt;Script&gt; m_scripts;</span>
<span class="line-removed"> 422     Vector&lt;String&gt; m_arguments;</span>
 423     bool m_profile { false };
<span class="line-removed"> 424     String m_profilerOutput;</span>
<span class="line-removed"> 425     String m_uncaughtExceptionName;</span>
 426     bool m_treatWatchdogExceptionAsSuccess { false };
 427     bool m_alwaysDumpUncaughtException { false };
 428     bool m_dumpMemoryFootprint { false };
 429     bool m_dumpSamplingProfilerData { false };
 430     bool m_enableRemoteDebugging { false };
 431 
 432     void parseArguments(int, char**);
 433 };
 434 
 435 static const char interactivePrompt[] = &quot;&gt;&gt;&gt; &quot;;
 436 
 437 class StopWatch {
 438 public:
 439     void start();
 440     void stop();
 441     long getElapsedMS(); // call stop() first
 442 
 443 private:
 444     MonotonicTime m_startTime;
 445     MonotonicTime m_stopTime;
</pre>
<hr />
<pre>
 522         addFunction(vm, &quot;sleepSeconds&quot;, functionSleepSeconds, 1);
 523         addFunction(vm, &quot;jscStack&quot;, functionJSCStack, 1);
 524         addFunction(vm, &quot;readline&quot;, functionReadline, 0);
 525         addFunction(vm, &quot;preciseTime&quot;, functionPreciseTime, 0);
 526         addFunction(vm, &quot;neverInlineFunction&quot;, functionNeverInlineFunction, 1);
 527         addFunction(vm, &quot;noInline&quot;, functionNeverInlineFunction, 1);
 528         addFunction(vm, &quot;noDFG&quot;, functionNoDFG, 1);
 529         addFunction(vm, &quot;noFTL&quot;, functionNoFTL, 1);
 530         addFunction(vm, &quot;noOSRExitFuzzing&quot;, functionNoOSRExitFuzzing, 1);
 531         addFunction(vm, &quot;numberOfDFGCompiles&quot;, functionNumberOfDFGCompiles, 1);
 532         addFunction(vm, &quot;jscOptions&quot;, functionJSCOptions, 0);
 533         addFunction(vm, &quot;optimizeNextInvocation&quot;, functionOptimizeNextInvocation, 1);
 534         addFunction(vm, &quot;reoptimizationRetryCount&quot;, functionReoptimizationRetryCount, 1);
 535         addFunction(vm, &quot;transferArrayBuffer&quot;, functionTransferArrayBuffer, 1);
 536         addFunction(vm, &quot;failNextNewCodeBlock&quot;, functionFailNextNewCodeBlock, 1);
 537 #if ENABLE(SAMPLING_FLAGS)
 538         addFunction(vm, &quot;setSamplingFlags&quot;, functionSetSamplingFlags, 1);
 539         addFunction(vm, &quot;clearSamplingFlags&quot;, functionClearSamplingFlags, 1);
 540 #endif
 541 
<span class="line-modified"> 542         putDirectNativeFunction(vm, this, Identifier::fromString(&amp;vm, &quot;OSRExit&quot;), 0, functionUndefined1, OSRExitIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified"> 543         putDirectNativeFunction(vm, this, Identifier::fromString(&amp;vm, &quot;isFinalTier&quot;), 0, functionFalse, IsFinalTierIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified"> 544         putDirectNativeFunction(vm, this, Identifier::fromString(&amp;vm, &quot;predictInt32&quot;), 0, functionUndefined2, SetInt32HeapPredictionIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified"> 545         putDirectNativeFunction(vm, this, Identifier::fromString(&amp;vm, &quot;isInt32&quot;), 0, functionIsInt32, CheckInt32Intrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified"> 546         putDirectNativeFunction(vm, this, Identifier::fromString(&amp;vm, &quot;isPureNaN&quot;), 0, functionIsPureNaN, CheckInt32Intrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified"> 547         putDirectNativeFunction(vm, this, Identifier::fromString(&amp;vm, &quot;fiatInt52&quot;), 0, functionIdentity, FiatInt52Intrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
 548 
 549         addFunction(vm, &quot;effectful42&quot;, functionEffectful42, 0);
 550         addFunction(vm, &quot;makeMasquerader&quot;, functionMakeMasquerader, 0);
 551         addFunction(vm, &quot;hasCustomProperties&quot;, functionHasCustomProperties, 0);
 552 
 553         addFunction(vm, &quot;createGlobalObject&quot;, functionCreateGlobalObject, 0);
 554 
 555         addFunction(vm, &quot;dumpTypesForAllVariables&quot;, functionDumpTypesForAllVariables , 0);
 556 
 557         addFunction(vm, &quot;drainMicrotasks&quot;, functionDrainMicrotasks, 0);

 558 
 559         addFunction(vm, &quot;getRandomSeed&quot;, functionGetRandomSeed, 0);
 560         addFunction(vm, &quot;setRandomSeed&quot;, functionSetRandomSeed, 1);
 561         addFunction(vm, &quot;isRope&quot;, functionIsRope, 1);
 562         addFunction(vm, &quot;callerSourceOrigin&quot;, functionCallerSourceOrigin, 0);
 563 
 564         addFunction(vm, &quot;is32BitPlatform&quot;, functionIs32BitPlatform, 0);
 565 
 566         addFunction(vm, &quot;checkModuleSyntax&quot;, functionCheckModuleSyntax, 1);
 567 
 568         addFunction(vm, &quot;platformSupportsSamplingProfiler&quot;, functionPlatformSupportsSamplingProfiler, 0);
 569         addFunction(vm, &quot;generateHeapSnapshot&quot;, functionGenerateHeapSnapshot, 0);
 570         addFunction(vm, &quot;generateHeapSnapshotForGCDebugging&quot;, functionGenerateHeapSnapshotForGCDebugging, 0);
 571         addFunction(vm, &quot;resetSuperSamplerState&quot;, functionResetSuperSamplerState, 0);
 572         addFunction(vm, &quot;ensureArrayStorage&quot;, functionEnsureArrayStorage, 0);
 573 #if ENABLE(SAMPLING_PROFILER)
 574         addFunction(vm, &quot;startSamplingProfiler&quot;, functionStartSamplingProfiler, 0);
 575         addFunction(vm, &quot;samplingProfilerStackTraces&quot;, functionSamplingProfilerStackTraces, 0);
 576 #endif
 577 
 578         addFunction(vm, &quot;maxArguments&quot;, functionMaxArguments, 0);
 579 
 580         addFunction(vm, &quot;asyncTestStart&quot;, functionAsyncTestStart, 1);
 581         addFunction(vm, &quot;asyncTestPassed&quot;, functionAsyncTestPassed, 1);
 582 
 583 #if ENABLE(WEBASSEMBLY)
 584         addFunction(vm, &quot;WebAssemblyMemoryMode&quot;, functionWebAssemblyMemoryMode, 1);
 585 #endif
 586 
 587         if (!arguments.isEmpty()) {
 588             JSArray* array = constructEmptyArray(globalExec(), 0);
 589             for (size_t i = 0; i &lt; arguments.size(); ++i)
<span class="line-modified"> 590                 array-&gt;putDirectIndex(globalExec(), i, jsString(globalExec(), arguments[i]));</span>
<span class="line-modified"> 591             putDirect(vm, Identifier::fromString(globalExec(), &quot;arguments&quot;), array);</span>
 592         }
 593 
<span class="line-modified"> 594         putDirect(vm, Identifier::fromString(globalExec(), &quot;console&quot;), jsUndefined());</span>
 595 
 596         Structure* plainObjectStructure = JSFinalObject::createStructure(vm, this, objectPrototype(), 0);
 597 
 598         JSObject* dollar = JSFinalObject::create(vm, plainObjectStructure);
<span class="line-modified"> 599         putDirect(vm, Identifier::fromString(globalExec(), &quot;$&quot;), dollar);</span>
<span class="line-modified"> 600         putDirect(vm, Identifier::fromString(globalExec(), &quot;$262&quot;), dollar);</span>
 601 
 602         addFunction(vm, dollar, &quot;createRealm&quot;, functionDollarCreateRealm, 0);
 603         addFunction(vm, dollar, &quot;detachArrayBuffer&quot;, functionDollarDetachArrayBuffer, 1);
 604         addFunction(vm, dollar, &quot;evalScript&quot;, functionDollarEvalScript, 1);
 605 
<span class="line-modified"> 606         dollar-&gt;putDirect(vm, Identifier::fromString(globalExec(), &quot;global&quot;), this);</span>
 607 
 608         JSObject* agent = JSFinalObject::create(vm, plainObjectStructure);
<span class="line-modified"> 609         dollar-&gt;putDirect(vm, Identifier::fromString(globalExec(), &quot;agent&quot;), agent);</span>
 610 
 611         // The test262 INTERPRETING.md document says that some of these functions are just in the main
 612         // thread and some are in the other threads. We just put them in all threads.
 613         addFunction(vm, agent, &quot;start&quot;, functionDollarAgentStart, 1);
 614         addFunction(vm, agent, &quot;receiveBroadcast&quot;, functionDollarAgentReceiveBroadcast, 1);
 615         addFunction(vm, agent, &quot;report&quot;, functionDollarAgentReport, 1);
 616         addFunction(vm, agent, &quot;sleep&quot;, functionDollarAgentSleep, 1);
 617         addFunction(vm, agent, &quot;broadcast&quot;, functionDollarAgentBroadcast, 1);
 618         addFunction(vm, agent, &quot;getReport&quot;, functionDollarAgentGetReport, 0);
 619         addFunction(vm, agent, &quot;leaving&quot;, functionDollarAgentLeaving, 0);
 620         addFunction(vm, agent, &quot;monotonicNow&quot;, functionDollarAgentMonotonicNow, 0);
 621 
 622         addFunction(vm, &quot;waitForReport&quot;, functionWaitForReport, 0);
 623 
 624         addFunction(vm, &quot;heapCapacity&quot;, functionHeapCapacity, 0);
 625         addFunction(vm, &quot;flashHeapAccess&quot;, functionFlashHeapAccess, 0);
 626 
 627         addFunction(vm, &quot;disableRichSourceInfo&quot;, functionDisableRichSourceInfo, 0);
 628         addFunction(vm, &quot;mallocInALoop&quot;, functionMallocInALoop, 0);
 629         addFunction(vm, &quot;totalCompileTime&quot;, functionTotalCompileTime, 0);


 630     }
 631 
 632     void addFunction(VM&amp; vm, JSObject* object, const char* name, NativeFunction function, unsigned arguments)
 633     {
<span class="line-modified"> 634         Identifier identifier = Identifier::fromString(&amp;vm, name);</span>
 635         object-&gt;putDirect(vm, identifier, JSFunction::create(vm, this, arguments, identifier.string(), function));
 636     }
 637 
 638     void addFunction(VM&amp; vm, const char* name, NativeFunction function, unsigned arguments)
 639     {
 640         addFunction(vm, this, name, function, arguments);
 641     }
 642 
 643     static JSInternalPromise* moduleLoaderImportModule(JSGlobalObject*, ExecState*, JSModuleLoader*, JSString*, JSValue, const SourceOrigin&amp;);
 644     static Identifier moduleLoaderResolve(JSGlobalObject*, ExecState*, JSModuleLoader*, JSValue, JSValue, JSValue);
 645     static JSInternalPromise* moduleLoaderFetch(JSGlobalObject*, ExecState*, JSModuleLoader*, JSValue, JSValue, JSValue);
 646     static JSObject* moduleLoaderCreateImportMetaProperties(JSGlobalObject*, ExecState*, JSModuleLoader*, JSValue, JSModuleRecord*, JSValue);
 647 };
 648 
 649 static bool supportsRichSourceInfo = true;
 650 static bool shellSupportsRichSourceInfo(const JSGlobalObject*)
 651 {
 652     return supportsRichSourceInfo;
 653 }
 654 
</pre>
<hr />
<pre>
 731 static Optional&lt;DirectoryName&gt; currentWorkingDirectory()
 732 {
 733 #if OS(WINDOWS)
 734     // https://msdn.microsoft.com/en-us/library/windows/desktop/aa364934.aspx
 735     // https://msdn.microsoft.com/en-us/library/windows/desktop/aa365247.aspx#maxpath
 736     // The _MAX_PATH in Windows is 260. If the path of the current working directory is longer than that, _getcwd truncates the result.
 737     // And other I/O functions taking a path name also truncate it. To avoid this situation,
 738     //
 739     // (1). When opening the file in Windows for modules, we always use the abosolute path and add &quot;\\?\&quot; prefix to the path name.
 740     // (2). When retrieving the current working directory, use GetCurrentDirectory instead of _getcwd.
 741     //
 742     // In the path utility functions inside the JSC shell, we does not handle the UNC and UNCW including the network host name.
 743     DWORD bufferLength = ::GetCurrentDirectoryW(0, nullptr);
 744     if (!bufferLength)
 745         return WTF::nullopt;
 746     // In Windows, wchar_t is the UTF-16LE.
 747     // https://msdn.microsoft.com/en-us/library/dd374081.aspx
 748     // https://msdn.microsoft.com/en-us/library/windows/desktop/ff381407.aspx
 749     Vector&lt;wchar_t&gt; buffer(bufferLength);
 750     DWORD lengthNotIncludingNull = ::GetCurrentDirectoryW(bufferLength, buffer.data());
<span class="line-modified"> 751     String directoryString = wcharToString(buffer.data(), lengthNotIncludingNull);</span>
 752     // We don&#39;t support network path like \\host\share\&lt;path name&gt;.
 753     if (directoryString.startsWith(&quot;\\\\&quot;))
 754         return WTF::nullopt;
 755 #else
 756     Vector&lt;char&gt; buffer(PATH_MAX);
 757     if (!getcwd(buffer.data(), PATH_MAX))
 758         return WTF::nullopt;
 759     String directoryString = String::fromUTF8(buffer.data());
 760 #endif
 761     if (directoryString.isEmpty())
 762         return WTF::nullopt;
 763 
 764     if (directoryString[directoryString.length() - 1] == pathSeparator())
 765         return extractDirectoryName(directoryString);
 766     // Append the seperator to represents the file name. extractDirectoryName only accepts the absolute file name.
 767     return extractDirectoryName(makeString(directoryString, pathSeparator()));
 768 }
 769 
 770 static String resolvePath(const DirectoryName&amp; directoryName, const ModuleName&amp; moduleName)
 771 {
</pre>
<hr />
<pre>
 812     auto catchScope = DECLARE_CATCH_SCOPE(vm);
 813     auto reject = [&amp;] (JSValue rejectionReason) {
 814         catchScope.clearException();
 815         auto result = deferred-&gt;reject(exec, rejectionReason);
 816         catchScope.clearException();
 817         return result;
 818     };
 819 
 820     if (sourceOrigin.isNull())
 821         return reject(createError(exec, &quot;Could not resolve the module specifier.&quot;_s));
 822 
 823     const auto&amp; referrer = sourceOrigin.string();
 824     const auto&amp; moduleName = moduleNameValue-&gt;value(exec);
 825     if (UNLIKELY(catchScope.exception()))
 826         return reject(catchScope.exception());
 827 
 828     auto directoryName = extractDirectoryName(referrer.impl());
 829     if (!directoryName)
 830         return reject(createError(exec, makeString(&quot;Could not resolve the referrer name &#39;&quot;, String(referrer.impl()), &quot;&#39;.&quot;)));
 831 
<span class="line-modified"> 832     auto result = JSC::importModule(exec, Identifier::fromString(&amp;vm, resolvePath(directoryName.value(), ModuleName(moduleName))), parameters, jsUndefined());</span>
 833     if (UNLIKELY(catchScope.exception()))
 834         return reject(catchScope.exception());
 835     return result;
 836 }
 837 
 838 Identifier GlobalObject::moduleLoaderResolve(JSGlobalObject* globalObject, ExecState* exec, JSModuleLoader*, JSValue keyValue, JSValue referrerValue, JSValue)
 839 {
 840     VM&amp; vm = globalObject-&gt;vm();
 841     auto scope = DECLARE_THROW_SCOPE(vm);
 842 
 843     scope.releaseAssertNoException();
 844     const Identifier key = keyValue.toPropertyKey(exec);
 845     RETURN_IF_EXCEPTION(scope, { });
 846 
 847     if (key.isSymbol())
 848         return key;
 849 
 850     if (referrerValue.isUndefined()) {
 851         auto directoryName = currentWorkingDirectory();
 852         if (!directoryName) {
 853             throwException(exec, scope, createError(exec, &quot;Could not resolve the current working directory.&quot;_s));
 854             return { };
 855         }
<span class="line-modified"> 856         return Identifier::fromString(&amp;vm, resolvePath(directoryName.value(), ModuleName(key.impl())));</span>
 857     }
 858 
 859     const Identifier referrer = referrerValue.toPropertyKey(exec);
 860     RETURN_IF_EXCEPTION(scope, { });
 861 
 862     if (referrer.isSymbol()) {
 863         auto directoryName = currentWorkingDirectory();
 864         if (!directoryName) {
 865             throwException(exec, scope, createError(exec, &quot;Could not resolve the current working directory.&quot;_s));
 866             return { };
 867         }
<span class="line-modified"> 868         return Identifier::fromString(&amp;vm, resolvePath(directoryName.value(), ModuleName(key.impl())));</span>
 869     }
 870 
 871     // If the referrer exists, we assume that the referrer is the correct absolute path.
 872     auto directoryName = extractDirectoryName(referrer.impl());
 873     if (!directoryName) {
 874         throwException(exec, scope, createError(exec, makeString(&quot;Could not resolve the referrer name &#39;&quot;, String(referrer.impl()), &quot;&#39;.&quot;)));
 875         return { };
 876     }
<span class="line-modified"> 877     return Identifier::fromString(&amp;vm, resolvePath(directoryName.value(), ModuleName(key.impl())));</span>
 878 }
 879 
 880 template&lt;typename Vector&gt;
 881 static void convertShebangToJSComment(Vector&amp; buffer)
 882 {
 883     if (buffer.size() &gt;= 2) {
 884         if (buffer[0] == &#39;#&#39; &amp;&amp; buffer[1] == &#39;!&#39;)
 885             buffer[0] = buffer[1] = &#39;/&#39;;
 886     }
 887 }
 888 
 889 static RefPtr&lt;Uint8Array&gt; fillBufferWithContentsOfFile(FILE* file)
 890 {
 891     if (fseek(file, 0, SEEK_END) == -1)
 892         return nullptr;
 893     long bufferCapacity = ftell(file);
 894     if (bufferCapacity == -1)
 895         return nullptr;
 896     if (fseek(file, 0, SEEK_SET) == -1)
 897         return nullptr;
</pre>
<hr />
<pre>
 949     return result;
 950 }
 951 
 952 static bool fetchScriptFromLocalFileSystem(const String&amp; fileName, Vector&lt;char&gt;&amp; buffer)
 953 {
 954     if (!fillBufferWithContentsOfFile(fileName, buffer))
 955         return false;
 956     convertShebangToJSComment(buffer);
 957     return true;
 958 }
 959 
 960 class ShellSourceProvider : public StringSourceProvider {
 961 public:
 962     static Ref&lt;ShellSourceProvider&gt; create(const String&amp; source, const SourceOrigin&amp; sourceOrigin, URL&amp;&amp; url, const TextPosition&amp; startPosition, SourceProviderSourceType sourceType)
 963     {
 964         return adoptRef(*new ShellSourceProvider(source, sourceOrigin, WTFMove(url), startPosition, sourceType));
 965     }
 966 
 967     ~ShellSourceProvider()
 968     {
<span class="line-modified"> 969 #if OS(DARWIN)</span>
<span class="line-removed"> 970         if (m_cachedBytecode.size())</span>
<span class="line-removed"> 971             munmap(const_cast&lt;void*&gt;(m_cachedBytecode.data()), m_cachedBytecode.size());</span>
<span class="line-removed"> 972 #endif</span>
 973     }
 974 
<span class="line-modified"> 975     const CachedBytecode* cachedBytecode() const override</span>
 976     {
<span class="line-modified"> 977         return &amp;m_cachedBytecode;</span>












 978     }
 979 
 980     void cacheBytecode(const BytecodeCacheGenerator&amp; generator) const override
 981     {
<span class="line-modified"> 982 #if OS(DARWIN)</span>

















 983         String filename = cachePath();
<span class="line-modified"> 984         if (filename.isNull())</span>

 985             return;
<span class="line-modified"> 986         int fd = open(filename.utf8().data(), O_CREAT | O_WRONLY | O_TRUNC | O_EXLOCK | O_NONBLOCK, 0666);</span>
<span class="line-modified"> 987         if (fd == -1)</span>





 988             return;
<span class="line-modified"> 989         CachedBytecode cachedBytecode = generator();</span>
<span class="line-modified"> 990         write(fd, cachedBytecode.data(), cachedBytecode.size());</span>
<span class="line-modified"> 991         close(fd);</span>
<span class="line-modified"> 992 #endif</span>












 993     }
 994 
 995 private:
 996     String cachePath() const
 997     {
<span class="line-modified"> 998         const char* cachePath = Options::diskCachePath();</span>
<span class="line-removed"> 999         if (!cachePath)</span>
1000             return static_cast&lt;const char*&gt;(nullptr);
<span class="line-modified">1001         String filename = sourceOrigin().string();</span>
<span class="line-modified">1002         filename.replace(&#39;/&#39;, &#39;_&#39;);</span>
<span class="line-modified">1003         return makeString(cachePath, &#39;/&#39;, source().toString().hash(), &#39;-&#39;, filename, &quot;.bytecode-cache&quot;);</span>
1004     }
1005 
<span class="line-modified">1006     void loadBytecode()</span>
1007     {
<span class="line-modified">1008 #if OS(DARWIN)</span>


1009         String filename = cachePath();
1010         if (filename.isNull())
1011             return;
1012 
<span class="line-modified">1013         int fd = open(filename.utf8().data(), O_RDONLY | O_SHLOCK | O_NONBLOCK);</span>
<span class="line-modified">1014         if (fd == -1)</span>
1015             return;
1016 
1017         auto closeFD = makeScopeExit([&amp;] {
<span class="line-modified">1018             close(fd);</span>
1019         });
1020 
<span class="line-modified">1021         struct stat sb;</span>
<span class="line-modified">1022         int res = fstat(fd, &amp;sb);</span>
<span class="line-removed">1023         size_t size = static_cast&lt;size_t&gt;(sb.st_size);</span>
<span class="line-removed">1024         if (res || !size)</span>
<span class="line-removed">1025             return;</span>
1026 
<span class="line-modified">1027         void* buffer = mmap(nullptr, size, PROT_READ, MAP_PRIVATE, fd, 0);</span>
<span class="line-removed">1028         if (buffer == MAP_FAILED)</span>
1029             return;
<span class="line-modified">1030         m_cachedBytecode = CachedBytecode { buffer, size };</span>
<span class="line-modified">1031 #endif</span>
1032     }
1033 
1034     ShellSourceProvider(const String&amp; source, const SourceOrigin&amp; sourceOrigin, URL&amp;&amp; url, const TextPosition&amp; startPosition, SourceProviderSourceType sourceType)
1035         : StringSourceProvider(source, sourceOrigin, WTFMove(url), startPosition, sourceType)
1036     {
<span class="line-removed">1037         loadBytecode();</span>
1038     }
1039 
<span class="line-modified">1040     CachedBytecode m_cachedBytecode;</span>






1041 };
1042 
1043 static inline SourceCode jscSource(const String&amp; source, const SourceOrigin&amp; sourceOrigin, URL&amp;&amp; url = URL(), const TextPosition&amp; startPosition = TextPosition(), SourceProviderSourceType sourceType = SourceProviderSourceType::Program)
1044 {
1045     return SourceCode(ShellSourceProvider::create(source, sourceOrigin, WTFMove(url), startPosition, sourceType), startPosition.m_line.oneBasedInt(), startPosition.m_column.oneBasedInt());
1046 }
1047 
1048 template&lt;typename Vector&gt;
1049 static inline SourceCode jscSource(const Vector&amp; utf8, const SourceOrigin&amp; sourceOrigin, const String&amp; filename)
1050 {
1051     // FIXME: This should use an absolute file URL https://bugs.webkit.org/show_bug.cgi?id=193077
1052     String str = stringFromUTF(utf8);
1053     return jscSource(str, sourceOrigin, URL({ }, filename));
1054 }
1055 
1056 template&lt;typename Vector&gt;
1057 static bool fetchModuleFromLocalFileSystem(const String&amp; fileName, Vector&amp; buffer)
1058 {
1059     // We assume that fileName is always an absolute path.
1060 #if OS(WINDOWS)
1061     // https://msdn.microsoft.com/en-us/library/windows/desktop/aa365247.aspx#maxpath
1062     // Use long UNC to pass the long path name to the Windows APIs.
<span class="line-modified">1063     String longUNCPathName = WTF::makeString(&quot;\\\\?\\&quot;, fileName);</span>
<span class="line-removed">1064     auto pathName = stringToNullTerminatedWChar(longUNCPathName);</span>
1065     struct _stat status { };
1066     if (_wstat(pathName.data(), &amp;status))
1067         return false;
1068     if ((status.st_mode &amp; S_IFMT) != S_IFREG)
1069         return false;
1070 
1071     FILE* f = _wfopen(pathName.data(), L&quot;rb&quot;);
1072 #else
1073     auto pathName = fileName.utf8();
1074     struct stat status { };
1075     if (stat(pathName.data(), &amp;status))
1076         return false;
1077     if ((status.st_mode &amp; S_IFMT) != S_IFREG)
1078         return false;
1079 
1080     FILE* f = fopen(pathName.data(), &quot;r&quot;);
1081 #endif
1082     if (!f) {
1083         fprintf(stderr, &quot;Could not open file: %s\n&quot;, fileName.utf8().data());
1084         return false;
</pre>
<hr />
<pre>
1131             return result;
1132         }
1133     }
1134 #endif
1135 
1136     auto sourceCode = JSSourceCode::create(vm, jscSource(stringFromUTF(buffer), SourceOrigin { moduleKey }, WTFMove(moduleURL), TextPosition(), SourceProviderSourceType::Module));
1137     catchScope.releaseAssertNoException();
1138     auto result = deferred-&gt;resolve(exec, sourceCode);
1139     catchScope.clearException();
1140     return result;
1141 }
1142 
1143 JSObject* GlobalObject::moduleLoaderCreateImportMetaProperties(JSGlobalObject* globalObject, ExecState* exec, JSModuleLoader*, JSValue key, JSModuleRecord*, JSValue)
1144 {
1145     VM&amp; vm = exec-&gt;vm();
1146     auto scope = DECLARE_THROW_SCOPE(vm);
1147 
1148     JSObject* metaProperties = constructEmptyObject(exec, globalObject-&gt;nullPrototypeObjectStructure());
1149     RETURN_IF_EXCEPTION(scope, nullptr);
1150 
<span class="line-modified">1151     metaProperties-&gt;putDirect(vm, Identifier::fromString(&amp;vm, &quot;filename&quot;), key);</span>
1152     RETURN_IF_EXCEPTION(scope, nullptr);
1153 
1154     return metaProperties;
1155 }
1156 
1157 static CString cStringFromViewWithString(ExecState* exec, ThrowScope&amp; scope, StringViewWithUnderlyingString&amp; viewWithString)
1158 {
1159     Expected&lt;CString, UTF8ConversionError&gt; expectedString = viewWithString.view.tryGetUtf8();
1160     if (expectedString)
1161         return expectedString.value();
1162     switch (expectedString.error()) {
1163     case UTF8ConversionError::OutOfMemory:
1164         throwOutOfMemoryError(exec, scope);
1165         break;
1166     case UTF8ConversionError::IllegalSource:
1167         scope.throwException(exec, createError(exec, &quot;Illegal source encountered during UTF8 conversion&quot;));
1168         break;
1169     case UTF8ConversionError::SourceExhausted:
1170         scope.throwException(exec, createError(exec, &quot;Source exhausted during UTF8 conversion&quot;));
1171         break;
</pre>
<hr />
<pre>
1207     return JSValue::encode(jsUndefined());
1208 }
1209 
1210 EncodedJSValue JSC_HOST_CALL functionPrintStdOut(ExecState* exec) { return printInternal(exec, stdout); }
1211 EncodedJSValue JSC_HOST_CALL functionPrintStdErr(ExecState* exec) { return printInternal(exec, stderr); }
1212 
1213 EncodedJSValue JSC_HOST_CALL functionDebug(ExecState* exec)
1214 {
1215     VM&amp; vm = exec-&gt;vm();
1216     auto scope = DECLARE_THROW_SCOPE(vm);
1217     auto viewWithString = exec-&gt;argument(0).toString(exec)-&gt;viewWithUnderlyingString(exec);
1218     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1219     auto string = cStringFromViewWithString(exec, scope, viewWithString);
1220     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1221     fprintf(stderr, &quot;--&gt; %s\n&quot;, string.data());
1222     return JSValue::encode(jsUndefined());
1223 }
1224 
1225 EncodedJSValue JSC_HOST_CALL functionDescribe(ExecState* exec)
1226 {

1227     if (exec-&gt;argumentCount() &lt; 1)
1228         return JSValue::encode(jsUndefined());
<span class="line-modified">1229     return JSValue::encode(jsString(exec, toString(exec-&gt;argument(0))));</span>
1230 }
1231 
1232 EncodedJSValue JSC_HOST_CALL functionDescribeArray(ExecState* exec)
1233 {
1234     if (exec-&gt;argumentCount() &lt; 1)
1235         return JSValue::encode(jsUndefined());
1236     VM&amp; vm = exec-&gt;vm();
1237     JSObject* object = jsDynamicCast&lt;JSObject*&gt;(vm, exec-&gt;argument(0));
1238     if (!object)
<span class="line-modified">1239         return JSValue::encode(jsNontrivialString(exec, &quot;&lt;not object&gt;&quot;_s));</span>
<span class="line-modified">1240     return JSValue::encode(jsNontrivialString(exec, toString(&quot;&lt;Butterfly: &quot;, RawPointer(object-&gt;butterfly()), &quot;; public length: &quot;, object-&gt;getArrayLength(), &quot;; vector length: &quot;, object-&gt;getVectorLength(), &quot;&gt;&quot;)));</span>
1241 }
1242 
1243 EncodedJSValue JSC_HOST_CALL functionSleepSeconds(ExecState* exec)
1244 {
1245     VM&amp; vm = exec-&gt;vm();
1246     auto scope = DECLARE_THROW_SCOPE(vm);
1247 
1248     if (exec-&gt;argumentCount() &gt;= 1) {
1249         Seconds seconds = Seconds(exec-&gt;argument(0).toNumber(exec));
1250         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1251         sleep(seconds);
1252     }
1253 
1254     return JSValue::encode(jsUndefined());
1255 }
1256 
1257 class FunctionJSCStackFunctor {
1258 public:
1259     FunctionJSCStackFunctor(StringBuilder&amp; trace)
1260         : m_trace(trace)
</pre>
<hr />
<pre>
1319     VM&amp; vm = exec-&gt;vm();
1320     JSLockHolder lock(vm);
1321     return JSValue::encode(jsNumber(vm.heap.size()));
1322 }
1323 
1324 class JSCMemoryFootprint : public JSDestructibleObject {
1325     using Base = JSDestructibleObject;
1326 public:
1327     JSCMemoryFootprint(VM&amp; vm, Structure* structure)
1328         : Base(vm, structure)
1329     { }
1330 
1331     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
1332     {
1333         return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
1334     }
1335 
1336     static JSCMemoryFootprint* create(VM&amp; vm, JSGlobalObject* globalObject)
1337     {
1338         Structure* structure = createStructure(vm, globalObject, jsNull());
<span class="line-modified">1339         JSCMemoryFootprint* footprint = new (NotNull, allocateCell&lt;JSCMemoryFootprint&gt;(vm.heap, sizeof(JSCMemoryFootprint))) JSCMemoryFootprint(vm, structure);</span>
1340         footprint-&gt;finishCreation(vm);
1341         return footprint;
1342     }
1343 
1344     void finishCreation(VM&amp; vm)
1345     {
1346         Base::finishCreation(vm);
1347 
1348         auto addProperty = [&amp;] (VM&amp; vm, const char* name, JSValue value) {
1349             JSCMemoryFootprint::addProperty(vm, name, value);
1350         };
1351 
1352         MemoryFootprint footprint = MemoryFootprint::now();
1353 
1354         addProperty(vm, &quot;current&quot;, jsNumber(footprint.current));
1355         addProperty(vm, &quot;peak&quot;, jsNumber(footprint.peak));
1356     }
1357 
1358     DECLARE_INFO;
1359 
1360 private:
1361     void addProperty(VM&amp; vm, const char* name, JSValue value)
1362     {
<span class="line-modified">1363         Identifier identifier = Identifier::fromString(&amp;vm, name);</span>
1364         putDirect(vm, identifier, value);
1365     }
1366 };
1367 
1368 const ClassInfo JSCMemoryFootprint::s_info = { &quot;MemoryFootprint&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSCMemoryFootprint) };
1369 
1370 EncodedJSValue JSC_HOST_CALL functionCreateMemoryFootprint(ExecState* exec)
1371 {
1372     VM&amp; vm = exec-&gt;vm();
1373     JSLockHolder lock(vm);
1374     return JSValue::encode(JSCMemoryFootprint::create(vm, exec-&gt;lexicalGlobalObject()));
1375 }
1376 
1377 EncodedJSValue JSC_HOST_CALL functionResetMemoryPeak(ExecState*)
1378 {
1379     MemoryFootprint::resetPeak();
1380     return JSValue::encode(jsUndefined());
1381 }
1382 
1383 // This function is not generally very helpful in 64-bit code as the tag and payload
</pre>
<hr />
<pre>
1403 
1404 EncodedJSValue JSC_HOST_CALL functionRun(ExecState* exec)
1405 {
1406     VM&amp; vm = exec-&gt;vm();
1407     auto scope = DECLARE_THROW_SCOPE(vm);
1408 
1409     String fileName = exec-&gt;argument(0).toWTFString(exec);
1410     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1411     Vector&lt;char&gt; script;
1412     if (!fetchScriptFromLocalFileSystem(fileName, script))
1413         return JSValue::encode(throwException(exec, scope, createError(exec, &quot;Could not open file.&quot;_s)));
1414 
1415     GlobalObject* globalObject = GlobalObject::create(vm, GlobalObject::createStructure(vm, jsNull()), Vector&lt;String&gt;());
1416 
1417     JSArray* array = constructEmptyArray(globalObject-&gt;globalExec(), 0);
1418     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1419     for (unsigned i = 1; i &lt; exec-&gt;argumentCount(); ++i) {
1420         array-&gt;putDirectIndex(globalObject-&gt;globalExec(), i - 1, exec-&gt;uncheckedArgument(i));
1421         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1422     }
<span class="line-modified">1423     globalObject-&gt;putDirect(</span>
<span class="line-removed">1424         vm, Identifier::fromString(globalObject-&gt;globalExec(), &quot;arguments&quot;), array);</span>
1425 
1426     NakedPtr&lt;Exception&gt; exception;
1427     StopWatch stopWatch;
1428     stopWatch.start();
1429     evaluate(globalObject-&gt;globalExec(), jscSource(script, SourceOrigin { absolutePath(fileName) }, fileName), JSValue(), exception);
1430     stopWatch.stop();
1431 
1432     if (exception) {
1433         throwException(globalObject-&gt;globalExec(), scope, exception);
1434         return JSValue::encode(jsUndefined());
1435     }
1436 
1437     return JSValue::encode(jsNumber(stopWatch.getElapsedMS()));
1438 }
1439 
1440 EncodedJSValue JSC_HOST_CALL functionRunString(ExecState* exec)
1441 {
1442     VM&amp; vm = exec-&gt;vm();
1443     auto scope = DECLARE_THROW_SCOPE(vm);
1444 
1445     String source = exec-&gt;argument(0).toWTFString(exec);
1446     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1447 
1448     GlobalObject* globalObject = GlobalObject::create(vm, GlobalObject::createStructure(vm, jsNull()), Vector&lt;String&gt;());
1449 
1450     JSArray* array = constructEmptyArray(globalObject-&gt;globalExec(), 0);
1451     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1452     for (unsigned i = 1; i &lt; exec-&gt;argumentCount(); ++i) {
1453         array-&gt;putDirectIndex(globalObject-&gt;globalExec(), i - 1, exec-&gt;uncheckedArgument(i));
1454         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1455     }
<span class="line-modified">1456     globalObject-&gt;putDirect(</span>
<span class="line-removed">1457         vm, Identifier::fromString(globalObject-&gt;globalExec(), &quot;arguments&quot;), array);</span>
1458 
1459     NakedPtr&lt;Exception&gt; exception;
<span class="line-modified">1460     evaluate(globalObject-&gt;globalExec(), makeSource(source, exec-&gt;callerSourceOrigin()), JSValue(), exception);</span>
1461 
1462     if (exception) {
1463         scope.throwException(globalObject-&gt;globalExec(), exception);
1464         return JSValue::encode(jsUndefined());
1465     }
1466 
1467     return JSValue::encode(globalObject);
1468 }
1469 
1470 EncodedJSValue JSC_HOST_CALL functionLoad(ExecState* exec)
1471 {
1472     VM&amp; vm = exec-&gt;vm();
1473     auto scope = DECLARE_THROW_SCOPE(vm);
1474 
1475     String fileName = exec-&gt;argument(0).toWTFString(exec);
1476     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1477     Vector&lt;char&gt; script;
1478     if (!fetchScriptFromLocalFileSystem(fileName, script))
1479         return JSValue::encode(throwException(exec, scope, createError(exec, &quot;Could not open file.&quot;_s)));
1480 
1481     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();
1482 
1483     NakedPtr&lt;Exception&gt; evaluationException;
1484     JSValue result = evaluate(globalObject-&gt;globalExec(), jscSource(script, SourceOrigin { absolutePath(fileName) }, fileName), JSValue(), evaluationException);
1485     if (evaluationException)
1486         throwException(exec, scope, evaluationException);
1487     return JSValue::encode(result);
1488 }
1489 
1490 EncodedJSValue JSC_HOST_CALL functionLoadString(ExecState* exec)
1491 {
1492     VM&amp; vm = exec-&gt;vm();
1493     auto scope = DECLARE_THROW_SCOPE(vm);
1494 
1495     String sourceCode = exec-&gt;argument(0).toWTFString(exec);
1496     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1497     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();
1498 
1499     NakedPtr&lt;Exception&gt; evaluationException;
<span class="line-modified">1500     JSValue result = evaluate(globalObject-&gt;globalExec(), makeSource(sourceCode, exec-&gt;callerSourceOrigin()), JSValue(), evaluationException);</span>
1501     if (evaluationException)
1502         throwException(exec, scope, evaluationException);
1503     return JSValue::encode(result);
1504 }
1505 
1506 EncodedJSValue JSC_HOST_CALL functionReadFile(ExecState* exec)
1507 {
1508     VM&amp; vm = exec-&gt;vm();
1509     auto scope = DECLARE_THROW_SCOPE(vm);
1510 
1511     String fileName = exec-&gt;argument(0).toWTFString(exec);
1512     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1513 
1514     bool isBinary = false;
1515     if (exec-&gt;argumentCount() &gt; 1) {
1516         String type = exec-&gt;argument(1).toWTFString(exec);
1517         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1518         if (type != &quot;binary&quot;)
1519             return throwVMError(exec, scope, &quot;Expected &#39;binary&#39; as second argument.&quot;);
1520         isBinary = true;
1521     }
1522 
1523     RefPtr&lt;Uint8Array&gt; content = fillBufferWithContentsOfFile(fileName);
1524     if (!content)
1525         return throwVMError(exec, scope, &quot;Could not open file.&quot;);
1526 
1527     if (!isBinary)
<span class="line-modified">1528         return JSValue::encode(jsString(exec, String::fromUTF8WithLatin1Fallback(content-&gt;data(), content-&gt;length())));</span>
1529 
1530     Structure* structure = exec-&gt;lexicalGlobalObject()-&gt;typedArrayStructure(TypeUint8);
1531     JSObject* result = JSUint8Array::create(vm, structure, WTFMove(content));
1532     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1533 
1534     return JSValue::encode(result);
1535 }
1536 
1537 EncodedJSValue JSC_HOST_CALL functionCheckSyntax(ExecState* exec)
1538 {
1539     VM&amp; vm = exec-&gt;vm();
1540     auto scope = DECLARE_THROW_SCOPE(vm);
1541 
1542     String fileName = exec-&gt;argument(0).toWTFString(exec);
1543     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1544     Vector&lt;char&gt; script;
1545     if (!fetchScriptFromLocalFileSystem(fileName, script))
1546         return JSValue::encode(throwException(exec, scope, createError(exec, &quot;Could not open file.&quot;_s)));
1547 
1548     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();
</pre>
<hr />
<pre>
1594     unsigned seed = exec-&gt;argument(0).toUInt32(exec);
1595     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1596     exec-&gt;lexicalGlobalObject()-&gt;weakRandom().setSeed(seed);
1597     return JSValue::encode(jsUndefined());
1598 }
1599 
1600 EncodedJSValue JSC_HOST_CALL functionIsRope(ExecState* exec)
1601 {
1602     JSValue argument = exec-&gt;argument(0);
1603     if (!argument.isString())
1604         return JSValue::encode(jsBoolean(false));
1605     const StringImpl* impl = asString(argument)-&gt;tryGetValueImpl();
1606     return JSValue::encode(jsBoolean(!impl));
1607 }
1608 
1609 EncodedJSValue JSC_HOST_CALL functionCallerSourceOrigin(ExecState* state)
1610 {
1611     SourceOrigin sourceOrigin = state-&gt;callerSourceOrigin();
1612     if (sourceOrigin.isNull())
1613         return JSValue::encode(jsNull());
<span class="line-modified">1614     return JSValue::encode(jsString(state, sourceOrigin.string()));</span>
1615 }
1616 
1617 EncodedJSValue JSC_HOST_CALL functionReadline(ExecState* exec)
1618 {
1619     Vector&lt;char, 256&gt; line;
1620     int c;
1621     while ((c = getchar()) != EOF) {
1622         // FIXME: Should we also break on \r?
1623         if (c == &#39;\n&#39;)
1624             break;
1625         line.append(c);
1626     }
1627     line.append(&#39;\0&#39;);
<span class="line-modified">1628     return JSValue::encode(jsString(exec, line.data()));</span>
1629 }
1630 
1631 EncodedJSValue JSC_HOST_CALL functionPreciseTime(ExecState*)
1632 {
1633     return JSValue::encode(jsNumber(WallTime::now().secondsSinceEpoch().value()));
1634 }
1635 
1636 EncodedJSValue JSC_HOST_CALL functionNeverInlineFunction(ExecState* exec)
1637 {
1638     return JSValue::encode(setNeverInline(exec));
1639 }
1640 
1641 EncodedJSValue JSC_HOST_CALL functionNoDFG(ExecState* exec)
1642 {
1643     return JSValue::encode(setNeverOptimize(exec));
1644 }
1645 
1646 EncodedJSValue JSC_HOST_CALL functionNoFTL(ExecState* exec)
1647 {
1648     if (exec-&gt;argumentCount()) {
</pre>
<hr />
<pre>
1766         m_condition.wait(m_lock);
1767     return m_reports.takeFirst();
1768 }
1769 
1770 Workers&amp; Workers::singleton()
1771 {
1772     static Workers* result;
1773     static std::once_flag flag;
1774     std::call_once(
1775         flag,
1776         [] {
1777             result = new Workers();
1778         });
1779     return *result;
1780 }
1781 
1782 EncodedJSValue JSC_HOST_CALL functionDollarCreateRealm(ExecState* exec)
1783 {
1784     VM&amp; vm = exec-&gt;vm();
1785     GlobalObject* result = GlobalObject::create(vm, GlobalObject::createStructure(vm, jsNull()), Vector&lt;String&gt;());
<span class="line-modified">1786     return JSValue::encode(result-&gt;getDirect(vm, Identifier::fromString(exec, &quot;$&quot;)));</span>
1787 }
1788 
1789 EncodedJSValue JSC_HOST_CALL functionDollarDetachArrayBuffer(ExecState* exec)
1790 {
1791     return functionTransferArrayBuffer(exec);
1792 }
1793 
1794 EncodedJSValue JSC_HOST_CALL functionDollarEvalScript(ExecState* exec)
1795 {
1796     VM&amp; vm = exec-&gt;vm();
1797     auto scope = DECLARE_THROW_SCOPE(vm);
1798 
1799     String sourceCode = exec-&gt;argument(0).toWTFString(exec);
1800     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1801 
1802     GlobalObject* globalObject = jsDynamicCast&lt;GlobalObject*&gt;(vm,
<span class="line-modified">1803         exec-&gt;thisValue().get(exec, Identifier::fromString(exec, &quot;global&quot;)));</span>
1804     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1805     if (!globalObject)
1806         return JSValue::encode(throwException(exec, scope, createError(exec, &quot;Expected global to point to a global object&quot;_s)));
1807 
1808     NakedPtr&lt;Exception&gt; evaluationException;
1809     JSValue result = evaluate(globalObject-&gt;globalExec(), jscSource(sourceCode, exec-&gt;callerSourceOrigin()), JSValue(), evaluationException);
1810     if (evaluationException)
1811         throwException(exec, scope, evaluationException);
1812     return JSValue::encode(result);
1813 }
1814 
1815 EncodedJSValue JSC_HOST_CALL functionDollarAgentStart(ExecState* exec)
1816 {
1817     VM&amp; vm = exec-&gt;vm();
1818     auto scope = DECLARE_THROW_SCOPE(vm);
1819 
1820     String sourceCode = exec-&gt;argument(0).toWTFString(exec).isolatedCopy();
1821     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1822 
1823     Lock didStartLock;
1824     Condition didStartCondition;
1825     bool didStart = false;
1826 
1827     Thread::create(
1828         &quot;JSC Agent&quot;,
1829         [sourceCode, &amp;didStartLock, &amp;didStartCondition, &amp;didStart] () {
1830             CommandLine commandLine(0, nullptr);
1831             commandLine.m_interactive = false;
1832             runJSC(
1833                 commandLine, true,
1834                 [&amp;] (VM&amp;, GlobalObject* globalObject, bool&amp; success) {
1835                     // Notify the thread that started us that we have registered a worker.
1836                     {
1837                         auto locker = holdLock(didStartLock);
1838                         didStart = true;
1839                         didStartCondition.notifyOne();
1840                     }
1841 
1842                     NakedPtr&lt;Exception&gt; evaluationException;
1843                     JSValue result;
<span class="line-modified">1844                     result = evaluate(globalObject-&gt;globalExec(), makeSource(sourceCode, SourceOrigin(&quot;worker&quot;_s)), JSValue(), evaluationException);</span>
1845                     if (evaluationException)
1846                         result = evaluationException-&gt;value();
1847                     checkException(globalObject-&gt;globalExec(), globalObject, true, evaluationException, result, commandLine, success);
1848                     if (!success)
1849                         exit(1);
1850                 });
1851         })-&gt;detach();
1852 
1853     {
1854         auto locker = holdLock(didStartLock);
1855         while (!didStart)
1856             didStartCondition.wait(didStartLock);
1857     }
1858 
1859     return JSValue::encode(jsUndefined());
1860 }
1861 
1862 EncodedJSValue JSC_HOST_CALL functionDollarAgentReceiveBroadcast(ExecState* exec)
1863 {
1864     VM&amp; vm = exec-&gt;vm();
</pre>
<hr />
<pre>
1929     Workers::singleton().broadcast(
1930         [&amp;] (const AbstractLocker&amp; locker, Worker&amp; worker) {
1931             ArrayBuffer* nativeBuffer = jsBuffer-&gt;impl();
1932             ArrayBufferContents contents;
1933             nativeBuffer-&gt;transferTo(vm, contents); // &quot;transferTo&quot; means &quot;share&quot; if the buffer is shared.
1934             RefPtr&lt;Message&gt; message = adoptRef(new Message(WTFMove(contents), index));
1935             worker.enqueue(locker, message);
1936         });
1937 
1938     return JSValue::encode(jsUndefined());
1939 }
1940 
1941 EncodedJSValue JSC_HOST_CALL functionDollarAgentGetReport(ExecState* exec)
1942 {
1943     VM&amp; vm = exec-&gt;vm();
1944 
1945     String string = Workers::singleton().tryGetReport();
1946     if (!string)
1947         return JSValue::encode(jsNull());
1948 
<span class="line-modified">1949     return JSValue::encode(jsString(&amp;vm, string));</span>
1950 }
1951 
1952 EncodedJSValue JSC_HOST_CALL functionDollarAgentLeaving(ExecState*)
1953 {
1954     return JSValue::encode(jsUndefined());
1955 }
1956 
1957 EncodedJSValue JSC_HOST_CALL functionDollarAgentMonotonicNow(ExecState*)
1958 {
1959     return JSValue::encode(jsNumber(MonotonicTime::now().secondsSinceEpoch().milliseconds()));
1960 }
1961 
1962 EncodedJSValue JSC_HOST_CALL functionWaitForReport(ExecState* exec)
1963 {
1964     VM&amp; vm = exec-&gt;vm();
1965 
1966     String string;
1967     {
1968         ReleaseHeapAccessScope releaseAccess(vm.heap);
1969         string = Workers::singleton().getReport();
1970     }
1971     if (!string)
1972         return JSValue::encode(jsNull());
1973 
<span class="line-modified">1974     return JSValue::encode(jsString(&amp;vm, string));</span>
1975 }
1976 
1977 EncodedJSValue JSC_HOST_CALL functionHeapCapacity(ExecState* exec)
1978 {
1979     VM&amp; vm = exec-&gt;vm();
1980     return JSValue::encode(jsNumber(vm.heap.capacity()));
1981 }
1982 
1983 EncodedJSValue JSC_HOST_CALL functionFlashHeapAccess(ExecState* exec)
1984 {
1985     VM&amp; vm = exec-&gt;vm();
1986     auto scope = DECLARE_THROW_SCOPE(vm);
1987 
1988     double sleepTimeMs = 0;
1989     if (exec-&gt;argumentCount() &gt;= 1) {
1990         sleepTimeMs = exec-&gt;argument(0).toNumber(exec);
1991         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1992     }
1993 
1994     vm.heap.releaseAccess();
</pre>
<hr />
<pre>
2020     return JSValue::encode(jsNumber(JIT::totalCompileTime().milliseconds()));
2021 #else
2022     return JSValue::encode(jsNumber(0));
2023 #endif
2024 }
2025 
2026 template&lt;typename ValueType&gt;
2027 typename std::enable_if&lt;!std::is_fundamental&lt;ValueType&gt;::value&gt;::type addOption(VM&amp;, JSObject*, const Identifier&amp;, ValueType) { }
2028 
2029 template&lt;typename ValueType&gt;
2030 typename std::enable_if&lt;std::is_fundamental&lt;ValueType&gt;::value&gt;::type addOption(VM&amp; vm, JSObject* optionsObject, const Identifier&amp; identifier, ValueType value)
2031 {
2032     optionsObject-&gt;putDirect(vm, identifier, JSValue(value));
2033 }
2034 
2035 EncodedJSValue JSC_HOST_CALL functionJSCOptions(ExecState* exec)
2036 {
2037     VM&amp; vm = exec-&gt;vm();
2038     JSObject* optionsObject = constructEmptyObject(exec);
2039 #define FOR_EACH_OPTION(type_, name_, defaultValue_, availability_, description_) \
<span class="line-modified">2040     addOption(vm, optionsObject, Identifier::fromString(exec, #name_), Options::name_());</span>
2041     JSC_OPTIONS(FOR_EACH_OPTION)
2042 #undef FOR_EACH_OPTION
2043     return JSValue::encode(optionsObject);
2044 }
2045 
2046 EncodedJSValue JSC_HOST_CALL functionReoptimizationRetryCount(ExecState* exec)
2047 {
2048     if (exec-&gt;argumentCount() &lt; 1)
2049         return JSValue::encode(jsUndefined());
2050 
2051     CodeBlock* block = getSomeBaselineCodeBlockForFunction(exec-&gt;argument(0));
2052     if (!block)
2053         return JSValue::encode(jsNumber(0));
2054 
2055     return JSValue::encode(jsNumber(block-&gt;reoptimizationRetryCounter()));
2056 }
2057 
2058 EncodedJSValue JSC_HOST_CALL functionTransferArrayBuffer(ExecState* exec)
2059 {
2060     VM&amp; vm = exec-&gt;vm();
</pre>
<hr />
<pre>
2139     JSValue value = exec-&gt;argument(0);
2140     if (value.isObject())
2141         return JSValue::encode(jsBoolean(asObject(value)-&gt;hasCustomProperties(exec-&gt;vm())));
2142     return JSValue::encode(jsBoolean(false));
2143 }
2144 
2145 EncodedJSValue JSC_HOST_CALL functionDumpTypesForAllVariables(ExecState* exec)
2146 {
2147     VM&amp; vm = exec-&gt;vm();
2148     vm.dumpTypeProfilerData();
2149     return JSValue::encode(jsUndefined());
2150 }
2151 
2152 EncodedJSValue JSC_HOST_CALL functionDrainMicrotasks(ExecState* exec)
2153 {
2154     VM&amp; vm = exec-&gt;vm();
2155     vm.drainMicrotasks();
2156     return JSValue::encode(jsUndefined());
2157 }
2158 







2159 EncodedJSValue JSC_HOST_CALL functionIs32BitPlatform(ExecState*)
2160 {
2161 #if USE(JSVALUE64)
2162     return JSValue::encode(JSValue(JSC::JSValue::JSFalse));
2163 #else
2164     return JSValue::encode(JSValue(JSC::JSValue::JSTrue));
2165 #endif
2166 }
2167 
2168 EncodedJSValue JSC_HOST_CALL functionCreateGlobalObject(ExecState* exec)
2169 {
2170     VM&amp; vm = exec-&gt;vm();
2171     return JSValue::encode(GlobalObject::create(vm, GlobalObject::createStructure(vm, jsNull()), Vector&lt;String&gt;()));
2172 }
2173 
2174 EncodedJSValue JSC_HOST_CALL functionCheckModuleSyntax(ExecState* exec)
2175 {
2176     VM&amp; vm = exec-&gt;vm();
2177     auto scope = DECLARE_THROW_SCOPE(vm);
2178 
2179     String source = exec-&gt;argument(0).toWTFString(exec);
2180     RETURN_IF_EXCEPTION(scope, encodedJSValue());
2181 
2182     StopWatch stopWatch;
2183     stopWatch.start();
2184 
2185     ParserError error;
<span class="line-modified">2186     bool validSyntax = checkModuleSyntax(exec, makeSource(source, { }, URL(), TextPosition(), SourceProviderSourceType::Module), error);</span>
2187     RETURN_IF_EXCEPTION(scope, encodedJSValue());
2188     stopWatch.stop();
2189 
2190     if (!validSyntax)
<span class="line-modified">2191         throwException(exec, scope, jsNontrivialString(exec, toString(&quot;SyntaxError: &quot;, error.message(), &quot;:&quot;, error.line())));</span>
2192     return JSValue::encode(jsNumber(stopWatch.getElapsedMS()));
2193 }
2194 
2195 EncodedJSValue JSC_HOST_CALL functionPlatformSupportsSamplingProfiler(ExecState*)
2196 {
2197 #if ENABLE(SAMPLING_PROFILER)
2198     return JSValue::encode(JSValue(JSC::JSValue::JSTrue));
2199 #else
2200     return JSValue::encode(JSValue(JSC::JSValue::JSFalse));
2201 #endif
2202 }
2203 
2204 EncodedJSValue JSC_HOST_CALL functionGenerateHeapSnapshot(ExecState* exec)
2205 {
2206     VM&amp; vm = exec-&gt;vm();
2207     JSLockHolder lock(vm);
2208     auto scope = DECLARE_THROW_SCOPE(vm);
2209 
2210     HeapSnapshotBuilder snapshotBuilder(vm.ensureHeapProfiler());
2211     snapshotBuilder.buildSnapshot();
</pre>
<hr />
<pre>
2214     EncodedJSValue result = JSValue::encode(JSONParse(exec, jsonString));
2215     scope.releaseAssertNoException();
2216     return result;
2217 }
2218 
2219 EncodedJSValue JSC_HOST_CALL functionGenerateHeapSnapshotForGCDebugging(ExecState* exec)
2220 {
2221     VM&amp; vm = exec-&gt;vm();
2222     JSLockHolder lock(vm);
2223     auto scope = DECLARE_THROW_SCOPE(vm);
2224     String jsonString;
2225     {
2226         DeferGCForAWhile deferGC(vm.heap); // Prevent concurrent GC from interfering with the full GC that the snapshot does.
2227 
2228         HeapSnapshotBuilder snapshotBuilder(vm.ensureHeapProfiler(), HeapSnapshotBuilder::SnapshotType::GCDebuggingSnapshot);
2229         snapshotBuilder.buildSnapshot();
2230 
2231         jsonString = snapshotBuilder.json();
2232     }
2233     scope.releaseAssertNoException();
<span class="line-modified">2234     return JSValue::encode(jsString(&amp;vm, jsonString));</span>
2235 }
2236 
2237 EncodedJSValue JSC_HOST_CALL functionResetSuperSamplerState(ExecState*)
2238 {
2239     resetSuperSamplerState();
2240     return JSValue::encode(jsUndefined());
2241 }
2242 
2243 EncodedJSValue JSC_HOST_CALL functionEnsureArrayStorage(ExecState* exec)
2244 {
2245     VM&amp; vm = exec-&gt;vm();
2246     for (unsigned i = 0; i &lt; exec-&gt;argumentCount(); ++i) {
2247         if (JSObject* object = jsDynamicCast&lt;JSObject*&gt;(vm, exec-&gt;argument(i)))
2248             object-&gt;ensureArrayStorage(vm);
2249     }
2250     return JSValue::encode(jsUndefined());
2251 }
2252 
2253 #if ENABLE(SAMPLING_PROFILER)
2254 EncodedJSValue JSC_HOST_CALL functionStartSamplingProfiler(ExecState* exec)
</pre>
<hr />
<pre>
2270 
2271     String jsonString = vm.samplingProfiler()-&gt;stackTracesAsJSON();
2272     EncodedJSValue result = JSValue::encode(JSONParse(exec, jsonString));
2273     scope.releaseAssertNoException();
2274     return result;
2275 }
2276 #endif // ENABLE(SAMPLING_PROFILER)
2277 
2278 EncodedJSValue JSC_HOST_CALL functionMaxArguments(ExecState*)
2279 {
2280     return JSValue::encode(jsNumber(JSC::maxArguments));
2281 }
2282 
2283 EncodedJSValue JSC_HOST_CALL functionAsyncTestStart(ExecState* exec)
2284 {
2285     VM&amp; vm = exec-&gt;vm();
2286     auto scope = DECLARE_THROW_SCOPE(vm);
2287 
2288     JSValue numberOfAsyncPasses = exec-&gt;argument(0);
2289     if (!numberOfAsyncPasses.isUInt32())
<span class="line-modified">2290         return throwVMError(exec, scope, &quot;Expected first argument to a uint32&quot;_s);</span>
2291 
2292     asyncTestExpectedPasses += numberOfAsyncPasses.asUInt32();
2293     return encodedJSUndefined();
2294 }
2295 
2296 EncodedJSValue JSC_HOST_CALL functionAsyncTestPassed(ExecState*)
2297 {
2298     asyncTestPasses++;
2299     return encodedJSUndefined();
2300 }
2301 
2302 #if ENABLE(WEBASSEMBLY)
2303 
2304 static EncodedJSValue JSC_HOST_CALL functionWebAssemblyMemoryMode(ExecState* exec)
2305 {
2306     VM&amp; vm = exec-&gt;vm();
2307     auto scope = DECLARE_THROW_SCOPE(vm);
2308 
<span class="line-modified">2309     if (!Options::useWebAssembly())</span>
2310         return throwVMTypeError(exec, scope, &quot;WebAssemblyMemoryMode should only be called if the useWebAssembly option is set&quot;_s);
2311 
2312     if (JSObject* object = exec-&gt;argument(0).getObject()) {
2313         if (auto* memory = jsDynamicCast&lt;JSWebAssemblyMemory*&gt;(vm, object))
<span class="line-modified">2314             return JSValue::encode(jsString(&amp;vm, makeString(memory-&gt;memory().mode())));</span>
2315         if (auto* instance = jsDynamicCast&lt;JSWebAssemblyInstance*&gt;(vm, object))
<span class="line-modified">2316             return JSValue::encode(jsString(&amp;vm, makeString(instance-&gt;memoryMode())));</span>
2317     }
2318 
2319     return throwVMTypeError(exec, scope, &quot;WebAssemblyMemoryMode expects either a WebAssembly.Memory or WebAssembly.Instance&quot;_s);
2320 }
2321 
2322 #endif // ENABLE(WEBASSEMBLY)
2323 













2324 // Use SEH for Release builds only to get rid of the crash report dialog
2325 // (luckily the same tests fail in Release and Debug builds so far). Need to
2326 // be in a separate main function because the jscmain function requires object
2327 // unwinding.
2328 
2329 #if COMPILER(MSVC) &amp;&amp; !defined(_DEBUG)
2330 #define TRY       __try {
2331 #define EXCEPT(x) } __except (EXCEPTION_EXECUTE_HANDLER) { x; }
2332 #else
2333 #define TRY
2334 #define EXCEPT(x)
2335 #endif
2336 
2337 int jscmain(int argc, char** argv);
2338 
2339 static double s_desiredTimeout;
2340 static double s_timeoutMultiplier = 1.0;
2341 
2342 static void startTimeoutThreadIfNeeded()
2343 {
</pre>
<hr />
<pre>
2414 
2415 static void dumpException(GlobalObject* globalObject, JSValue exception)
2416 {
2417     VM&amp; vm = globalObject-&gt;vm();
2418     auto scope = DECLARE_CATCH_SCOPE(vm);
2419 
2420 #define CHECK_EXCEPTION() do { \
2421         if (scope.exception()) { \
2422             scope.clearException(); \
2423             return; \
2424         } \
2425     } while (false)
2426 
2427     auto exceptionString = exception.toWTFString(globalObject-&gt;globalExec());
2428     Expected&lt;CString, UTF8ConversionError&gt; expectedCString = exceptionString.tryGetUtf8();
2429     if (expectedCString)
2430         printf(&quot;Exception: %s\n&quot;, expectedCString.value().data());
2431     else
2432         printf(&quot;Exception: &lt;out of memory while extracting exception string&gt;\n&quot;);
2433 
<span class="line-modified">2434     Identifier nameID = Identifier::fromString(globalObject-&gt;globalExec(), &quot;name&quot;);</span>
2435     CHECK_EXCEPTION();
<span class="line-modified">2436     Identifier fileNameID = Identifier::fromString(globalObject-&gt;globalExec(), &quot;sourceURL&quot;);</span>
2437     CHECK_EXCEPTION();
<span class="line-modified">2438     Identifier lineNumberID = Identifier::fromString(globalObject-&gt;globalExec(), &quot;line&quot;);</span>
2439     CHECK_EXCEPTION();
<span class="line-modified">2440     Identifier stackID = Identifier::fromString(globalObject-&gt;globalExec(), &quot;stack&quot;);</span>
2441     CHECK_EXCEPTION();
2442 
2443     JSValue nameValue = exception.get(globalObject-&gt;globalExec(), nameID);
2444     CHECK_EXCEPTION();
2445     JSValue fileNameValue = exception.get(globalObject-&gt;globalExec(), fileNameID);
2446     CHECK_EXCEPTION();
2447     JSValue lineNumberValue = exception.get(globalObject-&gt;globalExec(), lineNumberID);
2448     CHECK_EXCEPTION();
2449     JSValue stackValue = exception.get(globalObject-&gt;globalExec(), stackID);
2450     CHECK_EXCEPTION();
2451 
2452     if (nameValue.toWTFString(globalObject-&gt;globalExec()) == &quot;SyntaxError&quot;
2453         &amp;&amp; (!fileNameValue.isUndefinedOrNull() || !lineNumberValue.isUndefinedOrNull())) {
2454         printf(
2455             &quot;at %s:%s\n&quot;,
2456             fileNameValue.toWTFString(globalObject-&gt;globalExec()).utf8().data(),
2457             lineNumberValue.toWTFString(globalObject-&gt;globalExec()).utf8().data());
2458     }
2459 
2460     if (!stackValue.isUndefinedOrNull()) {
2461         auto stackString = stackValue.toWTFString(globalObject-&gt;globalExec());
2462         if (stackString.length())
2463             printf(&quot;%s\n&quot;, stackString.utf8().data());
2464     }
2465 
2466 #undef CHECK_EXCEPTION
2467 }
2468 
2469 static bool checkUncaughtException(VM&amp; vm, GlobalObject* globalObject, JSValue exception, CommandLine&amp; options)
2470 {
2471     const String&amp; expectedExceptionName = options.m_uncaughtExceptionName;
2472     auto scope = DECLARE_CATCH_SCOPE(vm);
2473     scope.clearException();
2474     if (!exception) {
2475         printf(&quot;Expected uncaught exception with name &#39;%s&#39; but none was thrown\n&quot;, expectedExceptionName.utf8().data());
2476         return false;
2477     }
2478 
2479     ExecState* exec = globalObject-&gt;globalExec();
<span class="line-modified">2480     JSValue exceptionClass = globalObject-&gt;get(exec, Identifier::fromString(exec, expectedExceptionName));</span>
2481     if (!exceptionClass.isObject() || scope.exception()) {
2482         printf(&quot;Expected uncaught exception with name &#39;%s&#39; but given exception class is not defined\n&quot;, expectedExceptionName.utf8().data());
2483         return false;
2484     }
2485 
2486     bool isInstanceOfExpectedException = jsCast&lt;JSObject*&gt;(exceptionClass)-&gt;hasInstance(exec, exception);
2487     if (scope.exception()) {
2488         printf(&quot;Expected uncaught exception with name &#39;%s&#39; but given exception class fails performing hasInstance\n&quot;, expectedExceptionName.utf8().data());
2489         return false;
2490     }
2491     if (isInstanceOfExpectedException) {
2492         if (options.m_alwaysDumpUncaughtException)
2493             dumpException(globalObject, exception);
2494         return true;
2495     }
2496 
2497     printf(&quot;Expected uncaught exception with name &#39;%s&#39; but exception value is not instance of this exception class\n&quot;, expectedExceptionName.utf8().data());
2498     dumpException(globalObject, exception);
2499     return false;
2500 }
</pre>
<hr />
<pre>
2605     auto scope = DECLARE_CATCH_SCOPE(vm);
2606 
2607     Optional&lt;DirectoryName&gt; directoryName = currentWorkingDirectory();
2608     if (!directoryName)
2609         return;
2610     SourceOrigin sourceOrigin(resolvePath(directoryName.value(), ModuleName(&quot;interpreter&quot;)));
2611 
2612     bool shouldQuit = false;
2613     while (!shouldQuit) {
2614 #if HAVE(READLINE) &amp;&amp; !RUNNING_FROM_XCODE
2615         ParserError error;
2616         String source;
2617         do {
2618             error = ParserError();
2619             char* line = readline(source.isEmpty() ? interactivePrompt : &quot;... &quot;);
2620             shouldQuit = !line;
2621             if (!line)
2622                 break;
2623             source = source + String::fromUTF8(line);
2624             source = source + &#39;\n&#39;;
<span class="line-modified">2625             checkSyntax(vm, makeSource(source, sourceOrigin), error);</span>
2626             if (!line[0]) {
2627                 free(line);
2628                 break;
2629             }
2630             add_history(line);
2631             free(line);
2632         } while (error.syntaxErrorType() == ParserError::SyntaxErrorRecoverable);
2633 
2634         if (error.isValid()) {
2635             printf(&quot;%s:%d\n&quot;, error.message().utf8().data(), error.line());
2636             continue;
2637         }
2638 
2639 
2640         NakedPtr&lt;Exception&gt; evaluationException;
<span class="line-modified">2641         JSValue returnValue = evaluate(globalObject-&gt;globalExec(), makeSource(source, sourceOrigin), JSValue(), evaluationException);</span>
2642 #else
2643         printf(&quot;%s&quot;, interactivePrompt);
2644         Vector&lt;char, 256&gt; line;
2645         int c;
2646         while ((c = getchar()) != EOF) {
2647             // FIXME: Should we also break on \r?
2648             if (c == &#39;\n&#39;)
2649                 break;
2650             line.append(c);
2651         }
2652         if (line.isEmpty())
2653             break;
2654 
2655         NakedPtr&lt;Exception&gt; evaluationException;
2656         JSValue returnValue = evaluate(globalObject-&gt;globalExec(), jscSource(line, sourceOrigin, sourceOrigin.string()), JSValue(), evaluationException);
2657 #endif
2658         if (evaluationException)
2659             printf(&quot;Exception: %s\n&quot;, evaluationException-&gt;value().toWTFString(globalObject-&gt;globalExec()).utf8().data());
2660         else
2661             printf(&quot;%s\n&quot;, returnValue.toWTFString(globalObject-&gt;globalExec()).utf8().data());
</pre>
<hr />
<pre>
2675     fprintf(stderr, &quot;  -h|--help  Prints this help message\n&quot;);
2676     fprintf(stderr, &quot;  -i         Enables interactive mode (default if no files are specified)\n&quot;);
2677     fprintf(stderr, &quot;  -m         Execute as a module\n&quot;);
2678 #if HAVE(SIGNAL_H)
2679     fprintf(stderr, &quot;  -s         Installs signal handlers that exit on a crash (Unix platforms only)\n&quot;);
2680 #endif
2681     fprintf(stderr, &quot;  -p &lt;file&gt;  Outputs profiling data to a file\n&quot;);
2682     fprintf(stderr, &quot;  -x         Output exit code before terminating\n&quot;);
2683     fprintf(stderr, &quot;\n&quot;);
2684     fprintf(stderr, &quot;  --sample                   Collects and outputs sampling profiler data\n&quot;);
2685     fprintf(stderr, &quot;  --test262-async            Check that some script calls the print function with the string &#39;Test262:AsyncTestComplete&#39;\n&quot;);
2686     fprintf(stderr, &quot;  --strict-file=&lt;file&gt;       Parse the given file as if it were in strict mode (this option may be passed more than once)\n&quot;);
2687     fprintf(stderr, &quot;  --module-file=&lt;file&gt;       Parse and evaluate the given file as module (this option may be passed more than once)\n&quot;);
2688     fprintf(stderr, &quot;  --exception=&lt;name&gt;         Check the last script exits with an uncaught exception with the specified name\n&quot;);
2689     fprintf(stderr, &quot;  --watchdog-exception-ok    Uncaught watchdog exceptions exit with success\n&quot;);
2690     fprintf(stderr, &quot;  --dumpException            Dump uncaught exception text\n&quot;);
2691     fprintf(stderr, &quot;  --footprint                Dump memory footprint after done executing\n&quot;);
2692     fprintf(stderr, &quot;  --options                  Dumps all JSC VM options and exits\n&quot;);
2693     fprintf(stderr, &quot;  --dumpOptions              Dumps all non-default JSC VM options before continuing\n&quot;);
2694     fprintf(stderr, &quot;  --&lt;jsc VM option&gt;=&lt;value&gt;  Sets the specified JSC VM option\n&quot;);

2695     fprintf(stderr, &quot;\n&quot;);
2696     fprintf(stderr, &quot;Files with a .mjs extension will always be evaluated as modules.\n&quot;);
2697     fprintf(stderr, &quot;\n&quot;);
2698 
2699     jscExit(help ? EXIT_SUCCESS : EXIT_FAILURE);
2700 }
2701 
2702 static bool isMJSFile(char *filename)
2703 {
2704     filename = strrchr(filename, &#39;.&#39;);
2705 
2706     if (filename)
2707         return !strcmp(filename, &quot;.mjs&quot;);
2708 
2709     return false;
2710 }
2711 
2712 void CommandLine::parseArguments(int argc, char** argv)
2713 {
2714     Options::initialize();
</pre>
<hr />
<pre>
2783             break;
2784         }
2785         if (!strcmp(arg, &quot;-h&quot;) || !strcmp(arg, &quot;--help&quot;))
2786             printUsageStatement(true);
2787 
2788         if (!strcmp(arg, &quot;--options&quot;)) {
2789             dumpOptionsLevel = JSC::Options::DumpLevel::Verbose;
2790             needToExit = true;
2791             continue;
2792         }
2793         if (!strcmp(arg, &quot;--dumpOptions&quot;)) {
2794             dumpOptionsLevel = JSC::Options::DumpLevel::Overridden;
2795             continue;
2796         }
2797         if (!strcmp(arg, &quot;--sample&quot;)) {
2798             JSC::Options::useSamplingProfiler() = true;
2799             JSC::Options::collectSamplingProfilerDataForJSCShell() = true;
2800             m_dumpSamplingProfilerData = true;
2801             continue;
2802         }




2803 
2804         static const char* timeoutMultiplierOptStr = &quot;--timeoutMultiplier=&quot;;
2805         static const unsigned timeoutMultiplierOptStrLength = strlen(timeoutMultiplierOptStr);
2806         if (!strncmp(arg, timeoutMultiplierOptStr, timeoutMultiplierOptStrLength)) {
2807             const char* valueStr = &amp;arg[timeoutMultiplierOptStrLength];
2808             if (sscanf(valueStr, &quot;%lf&quot;, &amp;s_timeoutMultiplier) != 1)
2809                 dataLog(&quot;WARNING: --timeoutMultiplier=&quot;, valueStr, &quot; is invalid. Expects a numeric ratio.\n&quot;);
2810             continue;
2811         }
2812 
2813         if (!strcmp(arg, &quot;--test262-async&quot;)) {
2814             asyncTestExpectedPasses++;
2815             continue;
2816         }
2817 
2818         if (!strcmp(arg, &quot;--remote-debug&quot;)) {
2819             m_enableRemoteDebugging = true;
2820             continue;
2821         }
2822 
</pre>
<hr />
<pre>
2884         JSC::Options::dumpAllOptions(stderr, dumpOptionsLevel, optionsTitle);
2885     }
2886     JSC::Options::ensureOptionsAreCoherent();
2887     if (needToExit)
2888         jscExit(EXIT_SUCCESS);
2889 }
2890 
2891 template&lt;typename Func&gt;
2892 int runJSC(const CommandLine&amp; options, bool isWorker, const Func&amp; func)
2893 {
2894     Worker worker(Workers::singleton());
2895 
2896     VM&amp; vm = VM::create(LargeHeap).leakRef();
2897     int result;
2898     bool success = true;
2899     GlobalObject* globalObject = nullptr;
2900     {
2901         JSLockHolder locker(vm);
2902 
2903         if (options.m_profile &amp;&amp; !vm.m_perBytecodeProfiler)
<span class="line-modified">2904             vm.m_perBytecodeProfiler = std::make_unique&lt;Profiler::Database&gt;(vm);</span>
2905 
2906         globalObject = GlobalObject::create(vm, GlobalObject::createStructure(vm, jsNull()), options.m_arguments);
2907         globalObject-&gt;setRemoteDebuggingEnabled(options.m_enableRemoteDebugging);
2908         func(vm, globalObject, success);
2909         vm.drainMicrotasks();
2910     }
2911     vm.promiseDeferredTimer-&gt;runRunLoop();
2912     {
2913         JSLockHolder locker(vm);
2914         if (options.m_interactive &amp;&amp; success)
2915             runInteractive(globalObject);
2916     }
2917 
2918     result = success &amp;&amp; (asyncTestExpectedPasses == asyncTestPasses) ? 0 : 3;
2919 
2920     if (options.m_exitCode) {
2921         printf(&quot;jsc exiting %d&quot;, result);
2922         if (asyncTestExpectedPasses != asyncTestPasses)
2923             printf(&quot; because expected: %d async test passes but got: %d async test passes&quot;, asyncTestExpectedPasses, asyncTestPasses);
2924         printf(&quot;\n&quot;);
</pre>
<hr />
<pre>
2956 #endif
2957 
2958     if (Options::gcAtEnd()) {
2959         // We need to hold the API lock to do a GC.
2960         JSLockHolder locker(&amp;vm);
2961         vm.heap.collectNow(Sync, CollectionScope::Full);
2962     }
2963 
2964     if (options.m_dumpSamplingProfilerData) {
2965 #if ENABLE(SAMPLING_PROFILER)
2966         JSLockHolder locker(&amp;vm);
2967         vm.samplingProfiler()-&gt;reportTopFunctions();
2968         vm.samplingProfiler()-&gt;reportTopBytecodes();
2969 #else
2970         dataLog(&quot;Sampling profiler is not enabled on this platform\n&quot;);
2971 #endif
2972     }
2973 
2974     vm.codeCache()-&gt;write(vm);
2975 
<span class="line-modified">2976     if (isWorker) {</span>
2977         JSLockHolder locker(vm);
2978         // This is needed because we don&#39;t want the worker&#39;s main
2979         // thread to die before its compilation threads finish.
2980         vm.deref();
2981     }
2982 
2983     return result;
2984 }
2985 
2986 int jscmain(int argc, char** argv)
2987 {
2988     // Need to override and enable restricted options before we start parsing options below.
2989     Options::enableRestrictedOptions(true);
2990 


2991     // Note that the options parsing can affect VM creation, and thus
2992     // comes first.
2993     CommandLine options(argc, argv);
2994 
2995     processConfigFile(Options::configFile(), &quot;jsc&quot;);
2996 
2997     // Initialize JSC before getting VM.
<span class="line-removed">2998     WTF::initializeMainThread();</span>
2999     JSC::initializeThreading();
3000     startTimeoutThreadIfNeeded();
3001 #if ENABLE(WEBASSEMBLY)
3002     JSC::Wasm::enableFastMemory();
3003 #endif
3004     Gigacage::disableDisablingPrimitiveGigacageIfShouldBeEnabled();
3005 
3006 #if PLATFORM(COCOA)
3007     auto&amp; memoryPressureHandler = MemoryPressureHandler::singleton();
3008     {
3009         dispatch_queue_t queue = dispatch_queue_create(&quot;jsc shell memory pressure handler&quot;, DISPATCH_QUEUE_SERIAL);
3010         memoryPressureHandler.setDispatchQueue(queue);
3011         dispatch_release(queue);
3012     }
3013     Box&lt;Critical&gt; memoryPressureCriticalState = Box&lt;Critical&gt;::create(Critical::No);
3014     Box&lt;Synchronous&gt; memoryPressureSynchronousState = Box&lt;Synchronous&gt;::create(Synchronous::No);
3015     memoryPressureHandler.setLowMemoryHandler([=] (Critical critical, Synchronous synchronous) {
3016         // We set these racily with respect to reading them from the JS execution thread.
3017         *memoryPressureCriticalState = critical;
3018         *memoryPressureSynchronousState = synchronous;
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
   2  *  Copyright (C) 1999-2000 Harri Porten (porten@kde.org)
<span class="line-modified">   3  *  Copyright (C) 2004-2019 Apple Inc. All rights reserved.</span>
   4  *  Copyright (C) 2006 Bjoern Graf (bjoern.graf@gmail.com)
   5  *
   6  *  This library is free software; you can redistribute it and/or
   7  *  modify it under the terms of the GNU Library General Public
   8  *  License as published by the Free Software Foundation; either
   9  *  version 2 of the License, or (at your option) any later version.
  10  *
  11  *  This library is distributed in the hope that it will be useful,
  12  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  13  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  14  *  Library General Public License for more details.
  15  *
  16  *  You should have received a copy of the GNU Library General Public License
  17  *  along with this library; see the file COPYING.LIB.  If not, write to
  18  *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  19  *  Boston, MA 02110-1301, USA.
  20  *
  21  */
  22 
  23 #include &quot;config.h&quot;
  24 
  25 #include &quot;ArrayBuffer.h&quot;
  26 #include &quot;ArrayPrototype.h&quot;
  27 #include &quot;BuiltinNames.h&quot;
  28 #include &quot;ButterflyInlines.h&quot;
<span class="line-added">  29 #include &quot;BytecodeCacheError.h&quot;</span>
  30 #include &quot;CatchScope.h&quot;
  31 #include &quot;CodeBlock.h&quot;
  32 #include &quot;CodeCache.h&quot;
  33 #include &quot;Completion.h&quot;
  34 #include &quot;ConfigFile.h&quot;
  35 #include &quot;Disassembler.h&quot;
  36 #include &quot;Exception.h&quot;
  37 #include &quot;ExceptionHelpers.h&quot;
  38 #include &quot;HeapProfiler.h&quot;
  39 #include &quot;HeapSnapshotBuilder.h&quot;
  40 #include &quot;InitializeThreading.h&quot;
  41 #include &quot;Interpreter.h&quot;
  42 #include &quot;JIT.h&quot;
  43 #include &quot;JSArray.h&quot;
  44 #include &quot;JSArrayBuffer.h&quot;
  45 #include &quot;JSBigInt.h&quot;
  46 #include &quot;JSCInlines.h&quot;
  47 #include &quot;JSFunction.h&quot;
  48 #include &quot;JSInternalPromise.h&quot;
  49 #include &quot;JSInternalPromiseDeferred.h&quot;
</pre>
<hr />
<pre>
  53 #include &quot;JSONObject.h&quot;
  54 #include &quot;JSSourceCode.h&quot;
  55 #include &quot;JSString.h&quot;
  56 #include &quot;JSTypedArrays.h&quot;
  57 #include &quot;JSWebAssemblyInstance.h&quot;
  58 #include &quot;JSWebAssemblyMemory.h&quot;
  59 #include &quot;LLIntThunks.h&quot;
  60 #include &quot;ObjectConstructor.h&quot;
  61 #include &quot;ParserError.h&quot;
  62 #include &quot;ProfilerDatabase.h&quot;
  63 #include &quot;PromiseDeferredTimer.h&quot;
  64 #include &quot;ProtoCallFrame.h&quot;
  65 #include &quot;ReleaseHeapAccessScope.h&quot;
  66 #include &quot;SamplingProfiler.h&quot;
  67 #include &quot;StackVisitor.h&quot;
  68 #include &quot;StructureInlines.h&quot;
  69 #include &quot;StructureRareDataInlines.h&quot;
  70 #include &quot;SuperSampler.h&quot;
  71 #include &quot;TestRunnerUtils.h&quot;
  72 #include &quot;TypedArrayInlines.h&quot;
<span class="line-added">  73 #include &quot;WasmCapabilities.h&quot;</span>
  74 #include &quot;WasmContext.h&quot;
  75 #include &quot;WasmFaultSignalHandler.h&quot;
  76 #include &quot;WasmMemory.h&quot;
  77 #include &lt;locale.h&gt;
  78 #include &lt;math.h&gt;
  79 #include &lt;stdio.h&gt;
  80 #include &lt;stdlib.h&gt;
  81 #include &lt;string.h&gt;
  82 #include &lt;sys/stat.h&gt;
  83 #include &lt;sys/types.h&gt;
  84 #include &lt;thread&gt;
  85 #include &lt;type_traits&gt;
  86 #include &lt;wtf/Box.h&gt;
  87 #include &lt;wtf/CommaPrinter.h&gt;
<span class="line-added">  88 #include &lt;wtf/FileSystem.h&gt;</span>
  89 #include &lt;wtf/MainThread.h&gt;
  90 #include &lt;wtf/MemoryPressureHandler.h&gt;
  91 #include &lt;wtf/MonotonicTime.h&gt;
  92 #include &lt;wtf/NeverDestroyed.h&gt;
  93 #include &lt;wtf/Scope.h&gt;
  94 #include &lt;wtf/StringPrintStream.h&gt;
  95 #include &lt;wtf/URL.h&gt;
  96 #include &lt;wtf/WallTime.h&gt;
  97 #include &lt;wtf/text/StringBuilder.h&gt;
  98 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
  99 
 100 #if OS(WINDOWS)
 101 #include &lt;direct.h&gt;
 102 #include &lt;fcntl.h&gt;
 103 #include &lt;io.h&gt;

 104 #else
 105 #include &lt;unistd.h&gt;
 106 #endif
 107 
 108 #if PLATFORM(COCOA)
 109 #include &lt;crt_externs.h&gt;
 110 #endif
 111 
 112 #if HAVE(READLINE)
 113 // readline/history.h has a Function typedef which conflicts with the WTF::Function template from WTF/Forward.h
 114 // We #define it to something else to avoid this conflict.
 115 #define Function ReadlineFunction
 116 #include &lt;readline/history.h&gt;
 117 #include &lt;readline/readline.h&gt;
 118 #undef Function
 119 #endif
 120 
 121 #if HAVE(SYS_TIME_H)
 122 #include &lt;sys/time.h&gt;
 123 #endif
 124 
 125 #if HAVE(SIGNAL_H)
 126 #include &lt;signal.h&gt;
 127 #endif
 128 
 129 #if COMPILER(MSVC)
 130 #include &lt;crtdbg.h&gt;
 131 #include &lt;mmsystem.h&gt;
 132 #include &lt;windows.h&gt;
 133 #endif
 134 
 135 #if PLATFORM(IOS_FAMILY) &amp;&amp; CPU(ARM_THUMB2)
 136 #include &lt;fenv.h&gt;
 137 #include &lt;arm/arch.h&gt;
 138 #endif
 139 
<span class="line-modified"> 140 #if OS(DARWIN)</span>
<span class="line-modified"> 141 #include &lt;wtf/spi/darwin/ProcessMemoryFootprint.h&gt;</span>
<span class="line-added"> 142 struct MemoryFootprint : ProcessMemoryFootprint {</span>
<span class="line-added"> 143     MemoryFootprint(const ProcessMemoryFootprint&amp; src)</span>
<span class="line-added"> 144         : ProcessMemoryFootprint(src)</span>
<span class="line-added"> 145     {</span>
<span class="line-added"> 146     }</span>
<span class="line-added"> 147 };</span>
 148 #else
 149 struct MemoryFootprint {
 150     uint64_t current;
 151     uint64_t peak;
 152 
 153     static MemoryFootprint now()
 154     {
 155         return { 0L, 0L };
 156     }
 157 
 158     static void resetPeak()
 159     {
 160     }
 161 };
 162 #endif
 163 
 164 #if !defined(PATH_MAX)
 165 #define PATH_MAX 4096
 166 #endif
 167 
</pre>
<hr />
<pre>
 184         }
 185     }
 186 #endif // ENABLE(DFG_JIT)
 187     exit(status);
 188 }
 189 
 190 class Masquerader : public JSNonFinalObject {
 191 public:
 192     Masquerader(VM&amp; vm, Structure* structure)
 193         : Base(vm, structure)
 194     {
 195     }
 196 
 197     typedef JSNonFinalObject Base;
 198     static const unsigned StructureFlags = Base::StructureFlags | JSC::MasqueradesAsUndefined;
 199 
 200     static Masquerader* create(VM&amp; vm, JSGlobalObject* globalObject)
 201     {
 202         globalObject-&gt;masqueradesAsUndefinedWatchpoint()-&gt;fireAll(vm, &quot;Masquerading object allocated&quot;);
 203         Structure* structure = createStructure(vm, globalObject, jsNull());
<span class="line-modified"> 204         Masquerader* result = new (NotNull, allocateCell&lt;Masquerader&gt;(vm.heap)) Masquerader(vm, structure);</span>
 205         result-&gt;finishCreation(vm);
 206         return result;
 207     }
 208 
 209     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 210     {
 211         return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
 212     }
 213 
 214     DECLARE_INFO;
 215 };
 216 
 217 const ClassInfo Masquerader::s_info = { &quot;Masquerader&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(Masquerader) };
 218 static unsigned asyncTestPasses { 0 };
 219 static unsigned asyncTestExpectedPasses { 0 };
 220 
 221 }
 222 
 223 template&lt;typename Vector&gt;
 224 static bool fillBufferWithContentsOfFile(const String&amp; fileName, Vector&amp; buffer);
</pre>
<hr />
<pre>
 319 static EncodedJSValue JSC_HOST_CALL functionNoFTL(ExecState*);
 320 static EncodedJSValue JSC_HOST_CALL functionNoOSRExitFuzzing(ExecState*);
 321 static EncodedJSValue JSC_HOST_CALL functionOptimizeNextInvocation(ExecState*);
 322 static EncodedJSValue JSC_HOST_CALL functionNumberOfDFGCompiles(ExecState*);
 323 static EncodedJSValue JSC_HOST_CALL functionJSCOptions(ExecState*);
 324 static EncodedJSValue JSC_HOST_CALL functionReoptimizationRetryCount(ExecState*);
 325 static EncodedJSValue JSC_HOST_CALL functionTransferArrayBuffer(ExecState*);
 326 static EncodedJSValue JSC_HOST_CALL functionFailNextNewCodeBlock(ExecState*);
 327 static NO_RETURN_WITH_VALUE EncodedJSValue JSC_HOST_CALL functionQuit(ExecState*);
 328 static EncodedJSValue JSC_HOST_CALL functionFalse(ExecState*);
 329 static EncodedJSValue JSC_HOST_CALL functionUndefined1(ExecState*);
 330 static EncodedJSValue JSC_HOST_CALL functionUndefined2(ExecState*);
 331 static EncodedJSValue JSC_HOST_CALL functionIsInt32(ExecState*);
 332 static EncodedJSValue JSC_HOST_CALL functionIsPureNaN(ExecState*);
 333 static EncodedJSValue JSC_HOST_CALL functionEffectful42(ExecState*);
 334 static EncodedJSValue JSC_HOST_CALL functionIdentity(ExecState*);
 335 static EncodedJSValue JSC_HOST_CALL functionMakeMasquerader(ExecState*);
 336 static EncodedJSValue JSC_HOST_CALL functionHasCustomProperties(ExecState*);
 337 static EncodedJSValue JSC_HOST_CALL functionDumpTypesForAllVariables(ExecState*);
 338 static EncodedJSValue JSC_HOST_CALL functionDrainMicrotasks(ExecState*);
<span class="line-added"> 339 static EncodedJSValue JSC_HOST_CALL functionReleaseWeakRefs(ExecState*);</span>
 340 static EncodedJSValue JSC_HOST_CALL functionIs32BitPlatform(ExecState*);
 341 static EncodedJSValue JSC_HOST_CALL functionCheckModuleSyntax(ExecState*);
 342 static EncodedJSValue JSC_HOST_CALL functionPlatformSupportsSamplingProfiler(ExecState*);
 343 static EncodedJSValue JSC_HOST_CALL functionGenerateHeapSnapshot(ExecState*);
 344 static EncodedJSValue JSC_HOST_CALL functionGenerateHeapSnapshotForGCDebugging(ExecState*);
 345 static EncodedJSValue JSC_HOST_CALL functionResetSuperSamplerState(ExecState*);
 346 static EncodedJSValue JSC_HOST_CALL functionEnsureArrayStorage(ExecState*);
 347 #if ENABLE(SAMPLING_PROFILER)
 348 static EncodedJSValue JSC_HOST_CALL functionStartSamplingProfiler(ExecState*);
 349 static EncodedJSValue JSC_HOST_CALL functionSamplingProfilerStackTraces(ExecState*);
 350 #endif
 351 
 352 static EncodedJSValue JSC_HOST_CALL functionMaxArguments(ExecState*);
 353 static EncodedJSValue JSC_HOST_CALL functionAsyncTestStart(ExecState*);
 354 static EncodedJSValue JSC_HOST_CALL functionAsyncTestPassed(ExecState*);
 355 
 356 #if ENABLE(WEBASSEMBLY)
 357 static EncodedJSValue JSC_HOST_CALL functionWebAssemblyMemoryMode(ExecState*);
 358 #endif
 359 
</pre>
<hr />
<pre>
 367 static EncodedJSValue JSC_HOST_CALL functionIsRope(ExecState*);
 368 static EncodedJSValue JSC_HOST_CALL functionCallerSourceOrigin(ExecState*);
 369 static EncodedJSValue JSC_HOST_CALL functionDollarCreateRealm(ExecState*);
 370 static EncodedJSValue JSC_HOST_CALL functionDollarDetachArrayBuffer(ExecState*);
 371 static EncodedJSValue JSC_HOST_CALL functionDollarEvalScript(ExecState*);
 372 static EncodedJSValue JSC_HOST_CALL functionDollarAgentStart(ExecState*);
 373 static EncodedJSValue JSC_HOST_CALL functionDollarAgentReceiveBroadcast(ExecState*);
 374 static EncodedJSValue JSC_HOST_CALL functionDollarAgentReport(ExecState*);
 375 static EncodedJSValue JSC_HOST_CALL functionDollarAgentSleep(ExecState*);
 376 static EncodedJSValue JSC_HOST_CALL functionDollarAgentBroadcast(ExecState*);
 377 static EncodedJSValue JSC_HOST_CALL functionDollarAgentGetReport(ExecState*);
 378 static EncodedJSValue JSC_HOST_CALL functionDollarAgentLeaving(ExecState*);
 379 static EncodedJSValue JSC_HOST_CALL functionDollarAgentMonotonicNow(ExecState*);
 380 static EncodedJSValue JSC_HOST_CALL functionWaitForReport(ExecState*);
 381 static EncodedJSValue JSC_HOST_CALL functionHeapCapacity(ExecState*);
 382 static EncodedJSValue JSC_HOST_CALL functionFlashHeapAccess(ExecState*);
 383 static EncodedJSValue JSC_HOST_CALL functionDisableRichSourceInfo(ExecState*);
 384 static EncodedJSValue JSC_HOST_CALL functionMallocInALoop(ExecState*);
 385 static EncodedJSValue JSC_HOST_CALL functionTotalCompileTime(ExecState*);
 386 
<span class="line-added"> 387 static EncodedJSValue JSC_HOST_CALL functionSetUnhandledRejectionCallback(ExecState*);</span>
<span class="line-added"> 388 </span>
 389 struct Script {
 390     enum class StrictMode {
 391         Strict,
 392         Sloppy
 393     };
 394 
 395     enum class ScriptType {
 396         Script,
 397         Module
 398     };
 399 
 400     enum class CodeSource {
 401         File,
 402         CommandLine
 403     };
 404 
 405     StrictMode strictMode;
 406     CodeSource codeSource;
 407     ScriptType scriptType;
 408     char* argument;
 409 
 410     Script(StrictMode strictMode, CodeSource codeSource, ScriptType scriptType, char *argument)
 411         : strictMode(strictMode)
 412         , codeSource(codeSource)
 413         , scriptType(scriptType)
 414         , argument(argument)
 415     {
 416         if (strictMode == StrictMode::Strict)
 417             ASSERT(codeSource == CodeSource::File);
 418     }
 419 };
 420 
 421 class CommandLine {
 422 public:
 423     CommandLine(int argc, char** argv)
 424     {
 425         parseArguments(argc, argv);
 426     }
 427 
<span class="line-added"> 428     Vector&lt;Script&gt; m_scripts;</span>
<span class="line-added"> 429     Vector&lt;String&gt; m_arguments;</span>
<span class="line-added"> 430     String m_profilerOutput;</span>
<span class="line-added"> 431     String m_uncaughtExceptionName;</span>
 432     bool m_interactive { false };
 433     bool m_dump { false };
 434     bool m_module { false };
 435     bool m_exitCode { false };
<span class="line-modified"> 436     bool m_destroyVM { false };</span>

 437     bool m_profile { false };


 438     bool m_treatWatchdogExceptionAsSuccess { false };
 439     bool m_alwaysDumpUncaughtException { false };
 440     bool m_dumpMemoryFootprint { false };
 441     bool m_dumpSamplingProfilerData { false };
 442     bool m_enableRemoteDebugging { false };
 443 
 444     void parseArguments(int, char**);
 445 };
 446 
 447 static const char interactivePrompt[] = &quot;&gt;&gt;&gt; &quot;;
 448 
 449 class StopWatch {
 450 public:
 451     void start();
 452     void stop();
 453     long getElapsedMS(); // call stop() first
 454 
 455 private:
 456     MonotonicTime m_startTime;
 457     MonotonicTime m_stopTime;
</pre>
<hr />
<pre>
 534         addFunction(vm, &quot;sleepSeconds&quot;, functionSleepSeconds, 1);
 535         addFunction(vm, &quot;jscStack&quot;, functionJSCStack, 1);
 536         addFunction(vm, &quot;readline&quot;, functionReadline, 0);
 537         addFunction(vm, &quot;preciseTime&quot;, functionPreciseTime, 0);
 538         addFunction(vm, &quot;neverInlineFunction&quot;, functionNeverInlineFunction, 1);
 539         addFunction(vm, &quot;noInline&quot;, functionNeverInlineFunction, 1);
 540         addFunction(vm, &quot;noDFG&quot;, functionNoDFG, 1);
 541         addFunction(vm, &quot;noFTL&quot;, functionNoFTL, 1);
 542         addFunction(vm, &quot;noOSRExitFuzzing&quot;, functionNoOSRExitFuzzing, 1);
 543         addFunction(vm, &quot;numberOfDFGCompiles&quot;, functionNumberOfDFGCompiles, 1);
 544         addFunction(vm, &quot;jscOptions&quot;, functionJSCOptions, 0);
 545         addFunction(vm, &quot;optimizeNextInvocation&quot;, functionOptimizeNextInvocation, 1);
 546         addFunction(vm, &quot;reoptimizationRetryCount&quot;, functionReoptimizationRetryCount, 1);
 547         addFunction(vm, &quot;transferArrayBuffer&quot;, functionTransferArrayBuffer, 1);
 548         addFunction(vm, &quot;failNextNewCodeBlock&quot;, functionFailNextNewCodeBlock, 1);
 549 #if ENABLE(SAMPLING_FLAGS)
 550         addFunction(vm, &quot;setSamplingFlags&quot;, functionSetSamplingFlags, 1);
 551         addFunction(vm, &quot;clearSamplingFlags&quot;, functionClearSamplingFlags, 1);
 552 #endif
 553 
<span class="line-modified"> 554         putDirectNativeFunction(vm, this, Identifier::fromString(vm, &quot;OSRExit&quot;), 0, functionUndefined1, OSRExitIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified"> 555         putDirectNativeFunction(vm, this, Identifier::fromString(vm, &quot;isFinalTier&quot;), 0, functionFalse, IsFinalTierIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified"> 556         putDirectNativeFunction(vm, this, Identifier::fromString(vm, &quot;predictInt32&quot;), 0, functionUndefined2, SetInt32HeapPredictionIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified"> 557         putDirectNativeFunction(vm, this, Identifier::fromString(vm, &quot;isInt32&quot;), 0, functionIsInt32, CheckInt32Intrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified"> 558         putDirectNativeFunction(vm, this, Identifier::fromString(vm, &quot;isPureNaN&quot;), 0, functionIsPureNaN, CheckInt32Intrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified"> 559         putDirectNativeFunction(vm, this, Identifier::fromString(vm, &quot;fiatInt52&quot;), 0, functionIdentity, FiatInt52Intrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
 560 
 561         addFunction(vm, &quot;effectful42&quot;, functionEffectful42, 0);
 562         addFunction(vm, &quot;makeMasquerader&quot;, functionMakeMasquerader, 0);
 563         addFunction(vm, &quot;hasCustomProperties&quot;, functionHasCustomProperties, 0);
 564 
 565         addFunction(vm, &quot;createGlobalObject&quot;, functionCreateGlobalObject, 0);
 566 
 567         addFunction(vm, &quot;dumpTypesForAllVariables&quot;, functionDumpTypesForAllVariables , 0);
 568 
 569         addFunction(vm, &quot;drainMicrotasks&quot;, functionDrainMicrotasks, 0);
<span class="line-added"> 570         addFunction(vm, &quot;releaseWeakRefs&quot;, functionReleaseWeakRefs, 0);</span>
 571 
 572         addFunction(vm, &quot;getRandomSeed&quot;, functionGetRandomSeed, 0);
 573         addFunction(vm, &quot;setRandomSeed&quot;, functionSetRandomSeed, 1);
 574         addFunction(vm, &quot;isRope&quot;, functionIsRope, 1);
 575         addFunction(vm, &quot;callerSourceOrigin&quot;, functionCallerSourceOrigin, 0);
 576 
 577         addFunction(vm, &quot;is32BitPlatform&quot;, functionIs32BitPlatform, 0);
 578 
 579         addFunction(vm, &quot;checkModuleSyntax&quot;, functionCheckModuleSyntax, 1);
 580 
 581         addFunction(vm, &quot;platformSupportsSamplingProfiler&quot;, functionPlatformSupportsSamplingProfiler, 0);
 582         addFunction(vm, &quot;generateHeapSnapshot&quot;, functionGenerateHeapSnapshot, 0);
 583         addFunction(vm, &quot;generateHeapSnapshotForGCDebugging&quot;, functionGenerateHeapSnapshotForGCDebugging, 0);
 584         addFunction(vm, &quot;resetSuperSamplerState&quot;, functionResetSuperSamplerState, 0);
 585         addFunction(vm, &quot;ensureArrayStorage&quot;, functionEnsureArrayStorage, 0);
 586 #if ENABLE(SAMPLING_PROFILER)
 587         addFunction(vm, &quot;startSamplingProfiler&quot;, functionStartSamplingProfiler, 0);
 588         addFunction(vm, &quot;samplingProfilerStackTraces&quot;, functionSamplingProfilerStackTraces, 0);
 589 #endif
 590 
 591         addFunction(vm, &quot;maxArguments&quot;, functionMaxArguments, 0);
 592 
 593         addFunction(vm, &quot;asyncTestStart&quot;, functionAsyncTestStart, 1);
 594         addFunction(vm, &quot;asyncTestPassed&quot;, functionAsyncTestPassed, 1);
 595 
 596 #if ENABLE(WEBASSEMBLY)
 597         addFunction(vm, &quot;WebAssemblyMemoryMode&quot;, functionWebAssemblyMemoryMode, 1);
 598 #endif
 599 
 600         if (!arguments.isEmpty()) {
 601             JSArray* array = constructEmptyArray(globalExec(), 0);
 602             for (size_t i = 0; i &lt; arguments.size(); ++i)
<span class="line-modified"> 603                 array-&gt;putDirectIndex(globalExec(), i, jsString(vm, arguments[i]));</span>
<span class="line-modified"> 604             putDirect(vm, Identifier::fromString(vm, &quot;arguments&quot;), array);</span>
 605         }
 606 
<span class="line-modified"> 607         putDirect(vm, Identifier::fromString(vm, &quot;console&quot;), jsUndefined());</span>
 608 
 609         Structure* plainObjectStructure = JSFinalObject::createStructure(vm, this, objectPrototype(), 0);
 610 
 611         JSObject* dollar = JSFinalObject::create(vm, plainObjectStructure);
<span class="line-modified"> 612         putDirect(vm, Identifier::fromString(vm, &quot;$&quot;), dollar);</span>
<span class="line-modified"> 613         putDirect(vm, Identifier::fromString(vm, &quot;$262&quot;), dollar);</span>
 614 
 615         addFunction(vm, dollar, &quot;createRealm&quot;, functionDollarCreateRealm, 0);
 616         addFunction(vm, dollar, &quot;detachArrayBuffer&quot;, functionDollarDetachArrayBuffer, 1);
 617         addFunction(vm, dollar, &quot;evalScript&quot;, functionDollarEvalScript, 1);
 618 
<span class="line-modified"> 619         dollar-&gt;putDirect(vm, Identifier::fromString(vm, &quot;global&quot;), this);</span>
 620 
 621         JSObject* agent = JSFinalObject::create(vm, plainObjectStructure);
<span class="line-modified"> 622         dollar-&gt;putDirect(vm, Identifier::fromString(vm, &quot;agent&quot;), agent);</span>
 623 
 624         // The test262 INTERPRETING.md document says that some of these functions are just in the main
 625         // thread and some are in the other threads. We just put them in all threads.
 626         addFunction(vm, agent, &quot;start&quot;, functionDollarAgentStart, 1);
 627         addFunction(vm, agent, &quot;receiveBroadcast&quot;, functionDollarAgentReceiveBroadcast, 1);
 628         addFunction(vm, agent, &quot;report&quot;, functionDollarAgentReport, 1);
 629         addFunction(vm, agent, &quot;sleep&quot;, functionDollarAgentSleep, 1);
 630         addFunction(vm, agent, &quot;broadcast&quot;, functionDollarAgentBroadcast, 1);
 631         addFunction(vm, agent, &quot;getReport&quot;, functionDollarAgentGetReport, 0);
 632         addFunction(vm, agent, &quot;leaving&quot;, functionDollarAgentLeaving, 0);
 633         addFunction(vm, agent, &quot;monotonicNow&quot;, functionDollarAgentMonotonicNow, 0);
 634 
 635         addFunction(vm, &quot;waitForReport&quot;, functionWaitForReport, 0);
 636 
 637         addFunction(vm, &quot;heapCapacity&quot;, functionHeapCapacity, 0);
 638         addFunction(vm, &quot;flashHeapAccess&quot;, functionFlashHeapAccess, 0);
 639 
 640         addFunction(vm, &quot;disableRichSourceInfo&quot;, functionDisableRichSourceInfo, 0);
 641         addFunction(vm, &quot;mallocInALoop&quot;, functionMallocInALoop, 0);
 642         addFunction(vm, &quot;totalCompileTime&quot;, functionTotalCompileTime, 0);
<span class="line-added"> 643 </span>
<span class="line-added"> 644         addFunction(vm, &quot;setUnhandledRejectionCallback&quot;, functionSetUnhandledRejectionCallback, 1);</span>
 645     }
 646 
 647     void addFunction(VM&amp; vm, JSObject* object, const char* name, NativeFunction function, unsigned arguments)
 648     {
<span class="line-modified"> 649         Identifier identifier = Identifier::fromString(vm, name);</span>
 650         object-&gt;putDirect(vm, identifier, JSFunction::create(vm, this, arguments, identifier.string(), function));
 651     }
 652 
 653     void addFunction(VM&amp; vm, const char* name, NativeFunction function, unsigned arguments)
 654     {
 655         addFunction(vm, this, name, function, arguments);
 656     }
 657 
 658     static JSInternalPromise* moduleLoaderImportModule(JSGlobalObject*, ExecState*, JSModuleLoader*, JSString*, JSValue, const SourceOrigin&amp;);
 659     static Identifier moduleLoaderResolve(JSGlobalObject*, ExecState*, JSModuleLoader*, JSValue, JSValue, JSValue);
 660     static JSInternalPromise* moduleLoaderFetch(JSGlobalObject*, ExecState*, JSModuleLoader*, JSValue, JSValue, JSValue);
 661     static JSObject* moduleLoaderCreateImportMetaProperties(JSGlobalObject*, ExecState*, JSModuleLoader*, JSValue, JSModuleRecord*, JSValue);
 662 };
 663 
 664 static bool supportsRichSourceInfo = true;
 665 static bool shellSupportsRichSourceInfo(const JSGlobalObject*)
 666 {
 667     return supportsRichSourceInfo;
 668 }
 669 
</pre>
<hr />
<pre>
 746 static Optional&lt;DirectoryName&gt; currentWorkingDirectory()
 747 {
 748 #if OS(WINDOWS)
 749     // https://msdn.microsoft.com/en-us/library/windows/desktop/aa364934.aspx
 750     // https://msdn.microsoft.com/en-us/library/windows/desktop/aa365247.aspx#maxpath
 751     // The _MAX_PATH in Windows is 260. If the path of the current working directory is longer than that, _getcwd truncates the result.
 752     // And other I/O functions taking a path name also truncate it. To avoid this situation,
 753     //
 754     // (1). When opening the file in Windows for modules, we always use the abosolute path and add &quot;\\?\&quot; prefix to the path name.
 755     // (2). When retrieving the current working directory, use GetCurrentDirectory instead of _getcwd.
 756     //
 757     // In the path utility functions inside the JSC shell, we does not handle the UNC and UNCW including the network host name.
 758     DWORD bufferLength = ::GetCurrentDirectoryW(0, nullptr);
 759     if (!bufferLength)
 760         return WTF::nullopt;
 761     // In Windows, wchar_t is the UTF-16LE.
 762     // https://msdn.microsoft.com/en-us/library/dd374081.aspx
 763     // https://msdn.microsoft.com/en-us/library/windows/desktop/ff381407.aspx
 764     Vector&lt;wchar_t&gt; buffer(bufferLength);
 765     DWORD lengthNotIncludingNull = ::GetCurrentDirectoryW(bufferLength, buffer.data());
<span class="line-modified"> 766     String directoryString(buffer.data(), lengthNotIncludingNull);</span>
 767     // We don&#39;t support network path like \\host\share\&lt;path name&gt;.
 768     if (directoryString.startsWith(&quot;\\\\&quot;))
 769         return WTF::nullopt;
 770 #else
 771     Vector&lt;char&gt; buffer(PATH_MAX);
 772     if (!getcwd(buffer.data(), PATH_MAX))
 773         return WTF::nullopt;
 774     String directoryString = String::fromUTF8(buffer.data());
 775 #endif
 776     if (directoryString.isEmpty())
 777         return WTF::nullopt;
 778 
 779     if (directoryString[directoryString.length() - 1] == pathSeparator())
 780         return extractDirectoryName(directoryString);
 781     // Append the seperator to represents the file name. extractDirectoryName only accepts the absolute file name.
 782     return extractDirectoryName(makeString(directoryString, pathSeparator()));
 783 }
 784 
 785 static String resolvePath(const DirectoryName&amp; directoryName, const ModuleName&amp; moduleName)
 786 {
</pre>
<hr />
<pre>
 827     auto catchScope = DECLARE_CATCH_SCOPE(vm);
 828     auto reject = [&amp;] (JSValue rejectionReason) {
 829         catchScope.clearException();
 830         auto result = deferred-&gt;reject(exec, rejectionReason);
 831         catchScope.clearException();
 832         return result;
 833     };
 834 
 835     if (sourceOrigin.isNull())
 836         return reject(createError(exec, &quot;Could not resolve the module specifier.&quot;_s));
 837 
 838     const auto&amp; referrer = sourceOrigin.string();
 839     const auto&amp; moduleName = moduleNameValue-&gt;value(exec);
 840     if (UNLIKELY(catchScope.exception()))
 841         return reject(catchScope.exception());
 842 
 843     auto directoryName = extractDirectoryName(referrer.impl());
 844     if (!directoryName)
 845         return reject(createError(exec, makeString(&quot;Could not resolve the referrer name &#39;&quot;, String(referrer.impl()), &quot;&#39;.&quot;)));
 846 
<span class="line-modified"> 847     auto result = JSC::importModule(exec, Identifier::fromString(vm, resolvePath(directoryName.value(), ModuleName(moduleName))), parameters, jsUndefined());</span>
 848     if (UNLIKELY(catchScope.exception()))
 849         return reject(catchScope.exception());
 850     return result;
 851 }
 852 
 853 Identifier GlobalObject::moduleLoaderResolve(JSGlobalObject* globalObject, ExecState* exec, JSModuleLoader*, JSValue keyValue, JSValue referrerValue, JSValue)
 854 {
 855     VM&amp; vm = globalObject-&gt;vm();
 856     auto scope = DECLARE_THROW_SCOPE(vm);
 857 
 858     scope.releaseAssertNoException();
 859     const Identifier key = keyValue.toPropertyKey(exec);
 860     RETURN_IF_EXCEPTION(scope, { });
 861 
 862     if (key.isSymbol())
 863         return key;
 864 
 865     if (referrerValue.isUndefined()) {
 866         auto directoryName = currentWorkingDirectory();
 867         if (!directoryName) {
 868             throwException(exec, scope, createError(exec, &quot;Could not resolve the current working directory.&quot;_s));
 869             return { };
 870         }
<span class="line-modified"> 871         return Identifier::fromString(vm, resolvePath(directoryName.value(), ModuleName(key.impl())));</span>
 872     }
 873 
 874     const Identifier referrer = referrerValue.toPropertyKey(exec);
 875     RETURN_IF_EXCEPTION(scope, { });
 876 
 877     if (referrer.isSymbol()) {
 878         auto directoryName = currentWorkingDirectory();
 879         if (!directoryName) {
 880             throwException(exec, scope, createError(exec, &quot;Could not resolve the current working directory.&quot;_s));
 881             return { };
 882         }
<span class="line-modified"> 883         return Identifier::fromString(vm, resolvePath(directoryName.value(), ModuleName(key.impl())));</span>
 884     }
 885 
 886     // If the referrer exists, we assume that the referrer is the correct absolute path.
 887     auto directoryName = extractDirectoryName(referrer.impl());
 888     if (!directoryName) {
 889         throwException(exec, scope, createError(exec, makeString(&quot;Could not resolve the referrer name &#39;&quot;, String(referrer.impl()), &quot;&#39;.&quot;)));
 890         return { };
 891     }
<span class="line-modified"> 892     return Identifier::fromString(vm, resolvePath(directoryName.value(), ModuleName(key.impl())));</span>
 893 }
 894 
 895 template&lt;typename Vector&gt;
 896 static void convertShebangToJSComment(Vector&amp; buffer)
 897 {
 898     if (buffer.size() &gt;= 2) {
 899         if (buffer[0] == &#39;#&#39; &amp;&amp; buffer[1] == &#39;!&#39;)
 900             buffer[0] = buffer[1] = &#39;/&#39;;
 901     }
 902 }
 903 
 904 static RefPtr&lt;Uint8Array&gt; fillBufferWithContentsOfFile(FILE* file)
 905 {
 906     if (fseek(file, 0, SEEK_END) == -1)
 907         return nullptr;
 908     long bufferCapacity = ftell(file);
 909     if (bufferCapacity == -1)
 910         return nullptr;
 911     if (fseek(file, 0, SEEK_SET) == -1)
 912         return nullptr;
</pre>
<hr />
<pre>
 964     return result;
 965 }
 966 
 967 static bool fetchScriptFromLocalFileSystem(const String&amp; fileName, Vector&lt;char&gt;&amp; buffer)
 968 {
 969     if (!fillBufferWithContentsOfFile(fileName, buffer))
 970         return false;
 971     convertShebangToJSComment(buffer);
 972     return true;
 973 }
 974 
 975 class ShellSourceProvider : public StringSourceProvider {
 976 public:
 977     static Ref&lt;ShellSourceProvider&gt; create(const String&amp; source, const SourceOrigin&amp; sourceOrigin, URL&amp;&amp; url, const TextPosition&amp; startPosition, SourceProviderSourceType sourceType)
 978     {
 979         return adoptRef(*new ShellSourceProvider(source, sourceOrigin, WTFMove(url), startPosition, sourceType));
 980     }
 981 
 982     ~ShellSourceProvider()
 983     {
<span class="line-modified"> 984         commitCachedBytecode();</span>



 985     }
 986 
<span class="line-modified"> 987     RefPtr&lt;CachedBytecode&gt; cachedBytecode() const override</span>
 988     {
<span class="line-modified"> 989         if (!m_cachedBytecode)</span>
<span class="line-added"> 990             loadBytecode();</span>
<span class="line-added"> 991         return m_cachedBytecode.copyRef();</span>
<span class="line-added"> 992     }</span>
<span class="line-added"> 993 </span>
<span class="line-added"> 994     void updateCache(const UnlinkedFunctionExecutable* executable, const SourceCode&amp;, CodeSpecializationKind kind, const UnlinkedFunctionCodeBlock* codeBlock) const override</span>
<span class="line-added"> 995     {</span>
<span class="line-added"> 996         if (!cacheEnabled() || !m_cachedBytecode)</span>
<span class="line-added"> 997             return;</span>
<span class="line-added"> 998         BytecodeCacheError error;</span>
<span class="line-added"> 999         RefPtr&lt;CachedBytecode&gt; cachedBytecode = encodeFunctionCodeBlock(executable-&gt;vm(), codeBlock, error);</span>
<span class="line-added">1000         if (cachedBytecode &amp;&amp; !error.isValid())</span>
<span class="line-added">1001             m_cachedBytecode-&gt;addFunctionUpdate(executable, kind, *cachedBytecode);</span>
1002     }
1003 
1004     void cacheBytecode(const BytecodeCacheGenerator&amp; generator) const override
1005     {
<span class="line-modified">1006         if (!cacheEnabled())</span>
<span class="line-added">1007             return;</span>
<span class="line-added">1008         if (!m_cachedBytecode)</span>
<span class="line-added">1009             m_cachedBytecode = CachedBytecode::create();</span>
<span class="line-added">1010         auto update = generator();</span>
<span class="line-added">1011         if (update)</span>
<span class="line-added">1012             m_cachedBytecode-&gt;addGlobalUpdate(*update);</span>
<span class="line-added">1013     }</span>
<span class="line-added">1014 </span>
<span class="line-added">1015     void commitCachedBytecode() const override</span>
<span class="line-added">1016     {</span>
<span class="line-added">1017         if (!cacheEnabled() || !m_cachedBytecode || !m_cachedBytecode-&gt;hasUpdates())</span>
<span class="line-added">1018             return;</span>
<span class="line-added">1019 </span>
<span class="line-added">1020         auto clearBytecode = makeScopeExit([&amp;] {</span>
<span class="line-added">1021             m_cachedBytecode = nullptr;</span>
<span class="line-added">1022         });</span>
<span class="line-added">1023 </span>
1024         String filename = cachePath();
<span class="line-modified">1025         auto fd = FileSystem::openAndLockFile(filename, FileSystem::FileOpenMode::Write, {FileSystem::FileLockMode::Exclusive, FileSystem::FileLockMode::Nonblocking});</span>
<span class="line-added">1026         if (!FileSystem::isHandleValid(fd))</span>
1027             return;
<span class="line-modified">1028 </span>
<span class="line-modified">1029         auto closeFD = makeScopeExit([&amp;] {</span>
<span class="line-added">1030             FileSystem::unlockAndCloseFile(fd);</span>
<span class="line-added">1031         });</span>
<span class="line-added">1032 </span>
<span class="line-added">1033         long long fileSize;</span>
<span class="line-added">1034         if (!FileSystem::getFileSize(fd, fileSize))</span>
1035             return;
<span class="line-modified">1036 </span>
<span class="line-modified">1037         size_t cacheFileSize;</span>
<span class="line-modified">1038         if (!WTF::convertSafely(fileSize, cacheFileSize) || cacheFileSize != m_cachedBytecode-&gt;size()) {</span>
<span class="line-modified">1039             // The bytecode cache has already been updated</span>
<span class="line-added">1040             return;</span>
<span class="line-added">1041         }</span>
<span class="line-added">1042 </span>
<span class="line-added">1043         if (!FileSystem::truncateFile(fd, m_cachedBytecode-&gt;sizeForUpdate()))</span>
<span class="line-added">1044             return;</span>
<span class="line-added">1045 </span>
<span class="line-added">1046         m_cachedBytecode-&gt;commitUpdates([&amp;] (off_t offset, const void* data, size_t size) {</span>
<span class="line-added">1047             long long result = FileSystem::seekFile(fd, offset, FileSystem::FileSeekOrigin::Beginning);</span>
<span class="line-added">1048             ASSERT_UNUSED(result, result != -1);</span>
<span class="line-added">1049             size_t bytesWritten = static_cast&lt;size_t&gt;(FileSystem::writeToFile(fd, static_cast&lt;const char*&gt;(data), size));</span>
<span class="line-added">1050             ASSERT_UNUSED(bytesWritten, bytesWritten == size);</span>
<span class="line-added">1051         });</span>
1052     }
1053 
1054 private:
1055     String cachePath() const
1056     {
<span class="line-modified">1057         if (!cacheEnabled())</span>

1058             return static_cast&lt;const char*&gt;(nullptr);
<span class="line-modified">1059         const char* cachePath = Options::diskCachePath();</span>
<span class="line-modified">1060         String filename = FileSystem::encodeForFileName(FileSystem::lastComponentOfPathIgnoringTrailingSlash(sourceOrigin().string()));</span>
<span class="line-modified">1061         return FileSystem::pathByAppendingComponent(cachePath, makeString(source().toString().hash(), &#39;-&#39;, filename, &quot;.bytecode-cache&quot;));</span>
1062     }
1063 
<span class="line-modified">1064     void loadBytecode() const</span>
1065     {
<span class="line-modified">1066         if (!cacheEnabled())</span>
<span class="line-added">1067             return;</span>
<span class="line-added">1068 </span>
1069         String filename = cachePath();
1070         if (filename.isNull())
1071             return;
1072 
<span class="line-modified">1073         auto fd = FileSystem::openAndLockFile(filename, FileSystem::FileOpenMode::Read, {FileSystem::FileLockMode::Shared, FileSystem::FileLockMode::Nonblocking});</span>
<span class="line-modified">1074         if (!FileSystem::isHandleValid(fd))</span>
1075             return;
1076 
1077         auto closeFD = makeScopeExit([&amp;] {
<span class="line-modified">1078             FileSystem::unlockAndCloseFile(fd);</span>
1079         });
1080 
<span class="line-modified">1081         bool success;</span>
<span class="line-modified">1082         FileSystem::MappedFileData mappedFileData(fd, FileSystem::MappedFileMode::Private, success);</span>



1083 
<span class="line-modified">1084         if (!success)</span>

1085             return;
<span class="line-modified">1086 </span>
<span class="line-modified">1087         m_cachedBytecode = CachedBytecode::create(WTFMove(mappedFileData));</span>
1088     }
1089 
1090     ShellSourceProvider(const String&amp; source, const SourceOrigin&amp; sourceOrigin, URL&amp;&amp; url, const TextPosition&amp; startPosition, SourceProviderSourceType sourceType)
1091         : StringSourceProvider(source, sourceOrigin, WTFMove(url), startPosition, sourceType)
1092     {

1093     }
1094 
<span class="line-modified">1095     static bool cacheEnabled()</span>
<span class="line-added">1096     {</span>
<span class="line-added">1097         static bool enabled = !!Options::diskCachePath();</span>
<span class="line-added">1098         return enabled;</span>
<span class="line-added">1099     }</span>
<span class="line-added">1100 </span>
<span class="line-added">1101     mutable RefPtr&lt;CachedBytecode&gt; m_cachedBytecode;</span>
1102 };
1103 
1104 static inline SourceCode jscSource(const String&amp; source, const SourceOrigin&amp; sourceOrigin, URL&amp;&amp; url = URL(), const TextPosition&amp; startPosition = TextPosition(), SourceProviderSourceType sourceType = SourceProviderSourceType::Program)
1105 {
1106     return SourceCode(ShellSourceProvider::create(source, sourceOrigin, WTFMove(url), startPosition, sourceType), startPosition.m_line.oneBasedInt(), startPosition.m_column.oneBasedInt());
1107 }
1108 
1109 template&lt;typename Vector&gt;
1110 static inline SourceCode jscSource(const Vector&amp; utf8, const SourceOrigin&amp; sourceOrigin, const String&amp; filename)
1111 {
1112     // FIXME: This should use an absolute file URL https://bugs.webkit.org/show_bug.cgi?id=193077
1113     String str = stringFromUTF(utf8);
1114     return jscSource(str, sourceOrigin, URL({ }, filename));
1115 }
1116 
1117 template&lt;typename Vector&gt;
1118 static bool fetchModuleFromLocalFileSystem(const String&amp; fileName, Vector&amp; buffer)
1119 {
1120     // We assume that fileName is always an absolute path.
1121 #if OS(WINDOWS)
1122     // https://msdn.microsoft.com/en-us/library/windows/desktop/aa365247.aspx#maxpath
1123     // Use long UNC to pass the long path name to the Windows APIs.
<span class="line-modified">1124     auto pathName = makeString(&quot;\\\\?\\&quot;, fileName).wideCharacters();</span>

1125     struct _stat status { };
1126     if (_wstat(pathName.data(), &amp;status))
1127         return false;
1128     if ((status.st_mode &amp; S_IFMT) != S_IFREG)
1129         return false;
1130 
1131     FILE* f = _wfopen(pathName.data(), L&quot;rb&quot;);
1132 #else
1133     auto pathName = fileName.utf8();
1134     struct stat status { };
1135     if (stat(pathName.data(), &amp;status))
1136         return false;
1137     if ((status.st_mode &amp; S_IFMT) != S_IFREG)
1138         return false;
1139 
1140     FILE* f = fopen(pathName.data(), &quot;r&quot;);
1141 #endif
1142     if (!f) {
1143         fprintf(stderr, &quot;Could not open file: %s\n&quot;, fileName.utf8().data());
1144         return false;
</pre>
<hr />
<pre>
1191             return result;
1192         }
1193     }
1194 #endif
1195 
1196     auto sourceCode = JSSourceCode::create(vm, jscSource(stringFromUTF(buffer), SourceOrigin { moduleKey }, WTFMove(moduleURL), TextPosition(), SourceProviderSourceType::Module));
1197     catchScope.releaseAssertNoException();
1198     auto result = deferred-&gt;resolve(exec, sourceCode);
1199     catchScope.clearException();
1200     return result;
1201 }
1202 
1203 JSObject* GlobalObject::moduleLoaderCreateImportMetaProperties(JSGlobalObject* globalObject, ExecState* exec, JSModuleLoader*, JSValue key, JSModuleRecord*, JSValue)
1204 {
1205     VM&amp; vm = exec-&gt;vm();
1206     auto scope = DECLARE_THROW_SCOPE(vm);
1207 
1208     JSObject* metaProperties = constructEmptyObject(exec, globalObject-&gt;nullPrototypeObjectStructure());
1209     RETURN_IF_EXCEPTION(scope, nullptr);
1210 
<span class="line-modified">1211     metaProperties-&gt;putDirect(vm, Identifier::fromString(vm, &quot;filename&quot;), key);</span>
1212     RETURN_IF_EXCEPTION(scope, nullptr);
1213 
1214     return metaProperties;
1215 }
1216 
1217 static CString cStringFromViewWithString(ExecState* exec, ThrowScope&amp; scope, StringViewWithUnderlyingString&amp; viewWithString)
1218 {
1219     Expected&lt;CString, UTF8ConversionError&gt; expectedString = viewWithString.view.tryGetUtf8();
1220     if (expectedString)
1221         return expectedString.value();
1222     switch (expectedString.error()) {
1223     case UTF8ConversionError::OutOfMemory:
1224         throwOutOfMemoryError(exec, scope);
1225         break;
1226     case UTF8ConversionError::IllegalSource:
1227         scope.throwException(exec, createError(exec, &quot;Illegal source encountered during UTF8 conversion&quot;));
1228         break;
1229     case UTF8ConversionError::SourceExhausted:
1230         scope.throwException(exec, createError(exec, &quot;Source exhausted during UTF8 conversion&quot;));
1231         break;
</pre>
<hr />
<pre>
1267     return JSValue::encode(jsUndefined());
1268 }
1269 
1270 EncodedJSValue JSC_HOST_CALL functionPrintStdOut(ExecState* exec) { return printInternal(exec, stdout); }
1271 EncodedJSValue JSC_HOST_CALL functionPrintStdErr(ExecState* exec) { return printInternal(exec, stderr); }
1272 
1273 EncodedJSValue JSC_HOST_CALL functionDebug(ExecState* exec)
1274 {
1275     VM&amp; vm = exec-&gt;vm();
1276     auto scope = DECLARE_THROW_SCOPE(vm);
1277     auto viewWithString = exec-&gt;argument(0).toString(exec)-&gt;viewWithUnderlyingString(exec);
1278     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1279     auto string = cStringFromViewWithString(exec, scope, viewWithString);
1280     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1281     fprintf(stderr, &quot;--&gt; %s\n&quot;, string.data());
1282     return JSValue::encode(jsUndefined());
1283 }
1284 
1285 EncodedJSValue JSC_HOST_CALL functionDescribe(ExecState* exec)
1286 {
<span class="line-added">1287     VM&amp; vm = exec-&gt;vm();</span>
1288     if (exec-&gt;argumentCount() &lt; 1)
1289         return JSValue::encode(jsUndefined());
<span class="line-modified">1290     return JSValue::encode(jsString(vm, toString(exec-&gt;argument(0))));</span>
1291 }
1292 
1293 EncodedJSValue JSC_HOST_CALL functionDescribeArray(ExecState* exec)
1294 {
1295     if (exec-&gt;argumentCount() &lt; 1)
1296         return JSValue::encode(jsUndefined());
1297     VM&amp; vm = exec-&gt;vm();
1298     JSObject* object = jsDynamicCast&lt;JSObject*&gt;(vm, exec-&gt;argument(0));
1299     if (!object)
<span class="line-modified">1300         return JSValue::encode(jsNontrivialString(vm, &quot;&lt;not object&gt;&quot;_s));</span>
<span class="line-modified">1301     return JSValue::encode(jsNontrivialString(vm, toString(&quot;&lt;Butterfly: &quot;, RawPointer(object-&gt;butterfly()), &quot;; public length: &quot;, object-&gt;getArrayLength(), &quot;; vector length: &quot;, object-&gt;getVectorLength(), &quot;&gt;&quot;)));</span>
1302 }
1303 
1304 EncodedJSValue JSC_HOST_CALL functionSleepSeconds(ExecState* exec)
1305 {
1306     VM&amp; vm = exec-&gt;vm();
1307     auto scope = DECLARE_THROW_SCOPE(vm);
1308 
1309     if (exec-&gt;argumentCount() &gt;= 1) {
1310         Seconds seconds = Seconds(exec-&gt;argument(0).toNumber(exec));
1311         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1312         sleep(seconds);
1313     }
1314 
1315     return JSValue::encode(jsUndefined());
1316 }
1317 
1318 class FunctionJSCStackFunctor {
1319 public:
1320     FunctionJSCStackFunctor(StringBuilder&amp; trace)
1321         : m_trace(trace)
</pre>
<hr />
<pre>
1380     VM&amp; vm = exec-&gt;vm();
1381     JSLockHolder lock(vm);
1382     return JSValue::encode(jsNumber(vm.heap.size()));
1383 }
1384 
1385 class JSCMemoryFootprint : public JSDestructibleObject {
1386     using Base = JSDestructibleObject;
1387 public:
1388     JSCMemoryFootprint(VM&amp; vm, Structure* structure)
1389         : Base(vm, structure)
1390     { }
1391 
1392     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
1393     {
1394         return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
1395     }
1396 
1397     static JSCMemoryFootprint* create(VM&amp; vm, JSGlobalObject* globalObject)
1398     {
1399         Structure* structure = createStructure(vm, globalObject, jsNull());
<span class="line-modified">1400         JSCMemoryFootprint* footprint = new (NotNull, allocateCell&lt;JSCMemoryFootprint&gt;(vm.heap)) JSCMemoryFootprint(vm, structure);</span>
1401         footprint-&gt;finishCreation(vm);
1402         return footprint;
1403     }
1404 
1405     void finishCreation(VM&amp; vm)
1406     {
1407         Base::finishCreation(vm);
1408 
1409         auto addProperty = [&amp;] (VM&amp; vm, const char* name, JSValue value) {
1410             JSCMemoryFootprint::addProperty(vm, name, value);
1411         };
1412 
1413         MemoryFootprint footprint = MemoryFootprint::now();
1414 
1415         addProperty(vm, &quot;current&quot;, jsNumber(footprint.current));
1416         addProperty(vm, &quot;peak&quot;, jsNumber(footprint.peak));
1417     }
1418 
1419     DECLARE_INFO;
1420 
1421 private:
1422     void addProperty(VM&amp; vm, const char* name, JSValue value)
1423     {
<span class="line-modified">1424         Identifier identifier = Identifier::fromString(vm, name);</span>
1425         putDirect(vm, identifier, value);
1426     }
1427 };
1428 
1429 const ClassInfo JSCMemoryFootprint::s_info = { &quot;MemoryFootprint&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSCMemoryFootprint) };
1430 
1431 EncodedJSValue JSC_HOST_CALL functionCreateMemoryFootprint(ExecState* exec)
1432 {
1433     VM&amp; vm = exec-&gt;vm();
1434     JSLockHolder lock(vm);
1435     return JSValue::encode(JSCMemoryFootprint::create(vm, exec-&gt;lexicalGlobalObject()));
1436 }
1437 
1438 EncodedJSValue JSC_HOST_CALL functionResetMemoryPeak(ExecState*)
1439 {
1440     MemoryFootprint::resetPeak();
1441     return JSValue::encode(jsUndefined());
1442 }
1443 
1444 // This function is not generally very helpful in 64-bit code as the tag and payload
</pre>
<hr />
<pre>
1464 
1465 EncodedJSValue JSC_HOST_CALL functionRun(ExecState* exec)
1466 {
1467     VM&amp; vm = exec-&gt;vm();
1468     auto scope = DECLARE_THROW_SCOPE(vm);
1469 
1470     String fileName = exec-&gt;argument(0).toWTFString(exec);
1471     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1472     Vector&lt;char&gt; script;
1473     if (!fetchScriptFromLocalFileSystem(fileName, script))
1474         return JSValue::encode(throwException(exec, scope, createError(exec, &quot;Could not open file.&quot;_s)));
1475 
1476     GlobalObject* globalObject = GlobalObject::create(vm, GlobalObject::createStructure(vm, jsNull()), Vector&lt;String&gt;());
1477 
1478     JSArray* array = constructEmptyArray(globalObject-&gt;globalExec(), 0);
1479     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1480     for (unsigned i = 1; i &lt; exec-&gt;argumentCount(); ++i) {
1481         array-&gt;putDirectIndex(globalObject-&gt;globalExec(), i - 1, exec-&gt;uncheckedArgument(i));
1482         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1483     }
<span class="line-modified">1484     globalObject-&gt;putDirect(vm, Identifier::fromString(vm, &quot;arguments&quot;), array);</span>

1485 
1486     NakedPtr&lt;Exception&gt; exception;
1487     StopWatch stopWatch;
1488     stopWatch.start();
1489     evaluate(globalObject-&gt;globalExec(), jscSource(script, SourceOrigin { absolutePath(fileName) }, fileName), JSValue(), exception);
1490     stopWatch.stop();
1491 
1492     if (exception) {
1493         throwException(globalObject-&gt;globalExec(), scope, exception);
1494         return JSValue::encode(jsUndefined());
1495     }
1496 
1497     return JSValue::encode(jsNumber(stopWatch.getElapsedMS()));
1498 }
1499 
1500 EncodedJSValue JSC_HOST_CALL functionRunString(ExecState* exec)
1501 {
1502     VM&amp; vm = exec-&gt;vm();
1503     auto scope = DECLARE_THROW_SCOPE(vm);
1504 
1505     String source = exec-&gt;argument(0).toWTFString(exec);
1506     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1507 
1508     GlobalObject* globalObject = GlobalObject::create(vm, GlobalObject::createStructure(vm, jsNull()), Vector&lt;String&gt;());
1509 
1510     JSArray* array = constructEmptyArray(globalObject-&gt;globalExec(), 0);
1511     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1512     for (unsigned i = 1; i &lt; exec-&gt;argumentCount(); ++i) {
1513         array-&gt;putDirectIndex(globalObject-&gt;globalExec(), i - 1, exec-&gt;uncheckedArgument(i));
1514         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1515     }
<span class="line-modified">1516     globalObject-&gt;putDirect(vm, Identifier::fromString(vm, &quot;arguments&quot;), array);</span>

1517 
1518     NakedPtr&lt;Exception&gt; exception;
<span class="line-modified">1519     evaluate(globalObject-&gt;globalExec(), jscSource(source, exec-&gt;callerSourceOrigin()), JSValue(), exception);</span>
1520 
1521     if (exception) {
1522         scope.throwException(globalObject-&gt;globalExec(), exception);
1523         return JSValue::encode(jsUndefined());
1524     }
1525 
1526     return JSValue::encode(globalObject);
1527 }
1528 
1529 EncodedJSValue JSC_HOST_CALL functionLoad(ExecState* exec)
1530 {
1531     VM&amp; vm = exec-&gt;vm();
1532     auto scope = DECLARE_THROW_SCOPE(vm);
1533 
1534     String fileName = exec-&gt;argument(0).toWTFString(exec);
1535     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1536     Vector&lt;char&gt; script;
1537     if (!fetchScriptFromLocalFileSystem(fileName, script))
1538         return JSValue::encode(throwException(exec, scope, createError(exec, &quot;Could not open file.&quot;_s)));
1539 
1540     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();
1541 
1542     NakedPtr&lt;Exception&gt; evaluationException;
1543     JSValue result = evaluate(globalObject-&gt;globalExec(), jscSource(script, SourceOrigin { absolutePath(fileName) }, fileName), JSValue(), evaluationException);
1544     if (evaluationException)
1545         throwException(exec, scope, evaluationException);
1546     return JSValue::encode(result);
1547 }
1548 
1549 EncodedJSValue JSC_HOST_CALL functionLoadString(ExecState* exec)
1550 {
1551     VM&amp; vm = exec-&gt;vm();
1552     auto scope = DECLARE_THROW_SCOPE(vm);
1553 
1554     String sourceCode = exec-&gt;argument(0).toWTFString(exec);
1555     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1556     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();
1557 
1558     NakedPtr&lt;Exception&gt; evaluationException;
<span class="line-modified">1559     JSValue result = evaluate(globalObject-&gt;globalExec(), jscSource(sourceCode, exec-&gt;callerSourceOrigin()), JSValue(), evaluationException);</span>
1560     if (evaluationException)
1561         throwException(exec, scope, evaluationException);
1562     return JSValue::encode(result);
1563 }
1564 
1565 EncodedJSValue JSC_HOST_CALL functionReadFile(ExecState* exec)
1566 {
1567     VM&amp; vm = exec-&gt;vm();
1568     auto scope = DECLARE_THROW_SCOPE(vm);
1569 
1570     String fileName = exec-&gt;argument(0).toWTFString(exec);
1571     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1572 
1573     bool isBinary = false;
1574     if (exec-&gt;argumentCount() &gt; 1) {
1575         String type = exec-&gt;argument(1).toWTFString(exec);
1576         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1577         if (type != &quot;binary&quot;)
1578             return throwVMError(exec, scope, &quot;Expected &#39;binary&#39; as second argument.&quot;);
1579         isBinary = true;
1580     }
1581 
1582     RefPtr&lt;Uint8Array&gt; content = fillBufferWithContentsOfFile(fileName);
1583     if (!content)
1584         return throwVMError(exec, scope, &quot;Could not open file.&quot;);
1585 
1586     if (!isBinary)
<span class="line-modified">1587         return JSValue::encode(jsString(vm, String::fromUTF8WithLatin1Fallback(content-&gt;data(), content-&gt;length())));</span>
1588 
1589     Structure* structure = exec-&gt;lexicalGlobalObject()-&gt;typedArrayStructure(TypeUint8);
1590     JSObject* result = JSUint8Array::create(vm, structure, WTFMove(content));
1591     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1592 
1593     return JSValue::encode(result);
1594 }
1595 
1596 EncodedJSValue JSC_HOST_CALL functionCheckSyntax(ExecState* exec)
1597 {
1598     VM&amp; vm = exec-&gt;vm();
1599     auto scope = DECLARE_THROW_SCOPE(vm);
1600 
1601     String fileName = exec-&gt;argument(0).toWTFString(exec);
1602     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1603     Vector&lt;char&gt; script;
1604     if (!fetchScriptFromLocalFileSystem(fileName, script))
1605         return JSValue::encode(throwException(exec, scope, createError(exec, &quot;Could not open file.&quot;_s)));
1606 
1607     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();
</pre>
<hr />
<pre>
1653     unsigned seed = exec-&gt;argument(0).toUInt32(exec);
1654     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1655     exec-&gt;lexicalGlobalObject()-&gt;weakRandom().setSeed(seed);
1656     return JSValue::encode(jsUndefined());
1657 }
1658 
1659 EncodedJSValue JSC_HOST_CALL functionIsRope(ExecState* exec)
1660 {
1661     JSValue argument = exec-&gt;argument(0);
1662     if (!argument.isString())
1663         return JSValue::encode(jsBoolean(false));
1664     const StringImpl* impl = asString(argument)-&gt;tryGetValueImpl();
1665     return JSValue::encode(jsBoolean(!impl));
1666 }
1667 
1668 EncodedJSValue JSC_HOST_CALL functionCallerSourceOrigin(ExecState* state)
1669 {
1670     SourceOrigin sourceOrigin = state-&gt;callerSourceOrigin();
1671     if (sourceOrigin.isNull())
1672         return JSValue::encode(jsNull());
<span class="line-modified">1673     return JSValue::encode(jsString(state-&gt;vm(), sourceOrigin.string()));</span>
1674 }
1675 
1676 EncodedJSValue JSC_HOST_CALL functionReadline(ExecState* exec)
1677 {
1678     Vector&lt;char, 256&gt; line;
1679     int c;
1680     while ((c = getchar()) != EOF) {
1681         // FIXME: Should we also break on \r?
1682         if (c == &#39;\n&#39;)
1683             break;
1684         line.append(c);
1685     }
1686     line.append(&#39;\0&#39;);
<span class="line-modified">1687     return JSValue::encode(jsString(exec-&gt;vm(), line.data()));</span>
1688 }
1689 
1690 EncodedJSValue JSC_HOST_CALL functionPreciseTime(ExecState*)
1691 {
1692     return JSValue::encode(jsNumber(WallTime::now().secondsSinceEpoch().value()));
1693 }
1694 
1695 EncodedJSValue JSC_HOST_CALL functionNeverInlineFunction(ExecState* exec)
1696 {
1697     return JSValue::encode(setNeverInline(exec));
1698 }
1699 
1700 EncodedJSValue JSC_HOST_CALL functionNoDFG(ExecState* exec)
1701 {
1702     return JSValue::encode(setNeverOptimize(exec));
1703 }
1704 
1705 EncodedJSValue JSC_HOST_CALL functionNoFTL(ExecState* exec)
1706 {
1707     if (exec-&gt;argumentCount()) {
</pre>
<hr />
<pre>
1825         m_condition.wait(m_lock);
1826     return m_reports.takeFirst();
1827 }
1828 
1829 Workers&amp; Workers::singleton()
1830 {
1831     static Workers* result;
1832     static std::once_flag flag;
1833     std::call_once(
1834         flag,
1835         [] {
1836             result = new Workers();
1837         });
1838     return *result;
1839 }
1840 
1841 EncodedJSValue JSC_HOST_CALL functionDollarCreateRealm(ExecState* exec)
1842 {
1843     VM&amp; vm = exec-&gt;vm();
1844     GlobalObject* result = GlobalObject::create(vm, GlobalObject::createStructure(vm, jsNull()), Vector&lt;String&gt;());
<span class="line-modified">1845     return JSValue::encode(result-&gt;getDirect(vm, Identifier::fromString(vm, &quot;$&quot;)));</span>
1846 }
1847 
1848 EncodedJSValue JSC_HOST_CALL functionDollarDetachArrayBuffer(ExecState* exec)
1849 {
1850     return functionTransferArrayBuffer(exec);
1851 }
1852 
1853 EncodedJSValue JSC_HOST_CALL functionDollarEvalScript(ExecState* exec)
1854 {
1855     VM&amp; vm = exec-&gt;vm();
1856     auto scope = DECLARE_THROW_SCOPE(vm);
1857 
1858     String sourceCode = exec-&gt;argument(0).toWTFString(exec);
1859     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1860 
1861     GlobalObject* globalObject = jsDynamicCast&lt;GlobalObject*&gt;(vm,
<span class="line-modified">1862         exec-&gt;thisValue().get(exec, Identifier::fromString(vm, &quot;global&quot;)));</span>
1863     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1864     if (!globalObject)
1865         return JSValue::encode(throwException(exec, scope, createError(exec, &quot;Expected global to point to a global object&quot;_s)));
1866 
1867     NakedPtr&lt;Exception&gt; evaluationException;
1868     JSValue result = evaluate(globalObject-&gt;globalExec(), jscSource(sourceCode, exec-&gt;callerSourceOrigin()), JSValue(), evaluationException);
1869     if (evaluationException)
1870         throwException(exec, scope, evaluationException);
1871     return JSValue::encode(result);
1872 }
1873 
1874 EncodedJSValue JSC_HOST_CALL functionDollarAgentStart(ExecState* exec)
1875 {
1876     VM&amp; vm = exec-&gt;vm();
1877     auto scope = DECLARE_THROW_SCOPE(vm);
1878 
1879     String sourceCode = exec-&gt;argument(0).toWTFString(exec).isolatedCopy();
1880     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1881 
1882     Lock didStartLock;
1883     Condition didStartCondition;
1884     bool didStart = false;
1885 
1886     Thread::create(
1887         &quot;JSC Agent&quot;,
1888         [sourceCode, &amp;didStartLock, &amp;didStartCondition, &amp;didStart] () {
1889             CommandLine commandLine(0, nullptr);
1890             commandLine.m_interactive = false;
1891             runJSC(
1892                 commandLine, true,
1893                 [&amp;] (VM&amp;, GlobalObject* globalObject, bool&amp; success) {
1894                     // Notify the thread that started us that we have registered a worker.
1895                     {
1896                         auto locker = holdLock(didStartLock);
1897                         didStart = true;
1898                         didStartCondition.notifyOne();
1899                     }
1900 
1901                     NakedPtr&lt;Exception&gt; evaluationException;
1902                     JSValue result;
<span class="line-modified">1903                     result = evaluate(globalObject-&gt;globalExec(), jscSource(sourceCode, SourceOrigin(&quot;worker&quot;_s)), JSValue(), evaluationException);</span>
1904                     if (evaluationException)
1905                         result = evaluationException-&gt;value();
1906                     checkException(globalObject-&gt;globalExec(), globalObject, true, evaluationException, result, commandLine, success);
1907                     if (!success)
1908                         exit(1);
1909                 });
1910         })-&gt;detach();
1911 
1912     {
1913         auto locker = holdLock(didStartLock);
1914         while (!didStart)
1915             didStartCondition.wait(didStartLock);
1916     }
1917 
1918     return JSValue::encode(jsUndefined());
1919 }
1920 
1921 EncodedJSValue JSC_HOST_CALL functionDollarAgentReceiveBroadcast(ExecState* exec)
1922 {
1923     VM&amp; vm = exec-&gt;vm();
</pre>
<hr />
<pre>
1988     Workers::singleton().broadcast(
1989         [&amp;] (const AbstractLocker&amp; locker, Worker&amp; worker) {
1990             ArrayBuffer* nativeBuffer = jsBuffer-&gt;impl();
1991             ArrayBufferContents contents;
1992             nativeBuffer-&gt;transferTo(vm, contents); // &quot;transferTo&quot; means &quot;share&quot; if the buffer is shared.
1993             RefPtr&lt;Message&gt; message = adoptRef(new Message(WTFMove(contents), index));
1994             worker.enqueue(locker, message);
1995         });
1996 
1997     return JSValue::encode(jsUndefined());
1998 }
1999 
2000 EncodedJSValue JSC_HOST_CALL functionDollarAgentGetReport(ExecState* exec)
2001 {
2002     VM&amp; vm = exec-&gt;vm();
2003 
2004     String string = Workers::singleton().tryGetReport();
2005     if (!string)
2006         return JSValue::encode(jsNull());
2007 
<span class="line-modified">2008     return JSValue::encode(jsString(vm, string));</span>
2009 }
2010 
2011 EncodedJSValue JSC_HOST_CALL functionDollarAgentLeaving(ExecState*)
2012 {
2013     return JSValue::encode(jsUndefined());
2014 }
2015 
2016 EncodedJSValue JSC_HOST_CALL functionDollarAgentMonotonicNow(ExecState*)
2017 {
2018     return JSValue::encode(jsNumber(MonotonicTime::now().secondsSinceEpoch().milliseconds()));
2019 }
2020 
2021 EncodedJSValue JSC_HOST_CALL functionWaitForReport(ExecState* exec)
2022 {
2023     VM&amp; vm = exec-&gt;vm();
2024 
2025     String string;
2026     {
2027         ReleaseHeapAccessScope releaseAccess(vm.heap);
2028         string = Workers::singleton().getReport();
2029     }
2030     if (!string)
2031         return JSValue::encode(jsNull());
2032 
<span class="line-modified">2033     return JSValue::encode(jsString(vm, string));</span>
2034 }
2035 
2036 EncodedJSValue JSC_HOST_CALL functionHeapCapacity(ExecState* exec)
2037 {
2038     VM&amp; vm = exec-&gt;vm();
2039     return JSValue::encode(jsNumber(vm.heap.capacity()));
2040 }
2041 
2042 EncodedJSValue JSC_HOST_CALL functionFlashHeapAccess(ExecState* exec)
2043 {
2044     VM&amp; vm = exec-&gt;vm();
2045     auto scope = DECLARE_THROW_SCOPE(vm);
2046 
2047     double sleepTimeMs = 0;
2048     if (exec-&gt;argumentCount() &gt;= 1) {
2049         sleepTimeMs = exec-&gt;argument(0).toNumber(exec);
2050         RETURN_IF_EXCEPTION(scope, encodedJSValue());
2051     }
2052 
2053     vm.heap.releaseAccess();
</pre>
<hr />
<pre>
2079     return JSValue::encode(jsNumber(JIT::totalCompileTime().milliseconds()));
2080 #else
2081     return JSValue::encode(jsNumber(0));
2082 #endif
2083 }
2084 
2085 template&lt;typename ValueType&gt;
2086 typename std::enable_if&lt;!std::is_fundamental&lt;ValueType&gt;::value&gt;::type addOption(VM&amp;, JSObject*, const Identifier&amp;, ValueType) { }
2087 
2088 template&lt;typename ValueType&gt;
2089 typename std::enable_if&lt;std::is_fundamental&lt;ValueType&gt;::value&gt;::type addOption(VM&amp; vm, JSObject* optionsObject, const Identifier&amp; identifier, ValueType value)
2090 {
2091     optionsObject-&gt;putDirect(vm, identifier, JSValue(value));
2092 }
2093 
2094 EncodedJSValue JSC_HOST_CALL functionJSCOptions(ExecState* exec)
2095 {
2096     VM&amp; vm = exec-&gt;vm();
2097     JSObject* optionsObject = constructEmptyObject(exec);
2098 #define FOR_EACH_OPTION(type_, name_, defaultValue_, availability_, description_) \
<span class="line-modified">2099     addOption(vm, optionsObject, Identifier::fromString(vm, #name_), Options::name_());</span>
2100     JSC_OPTIONS(FOR_EACH_OPTION)
2101 #undef FOR_EACH_OPTION
2102     return JSValue::encode(optionsObject);
2103 }
2104 
2105 EncodedJSValue JSC_HOST_CALL functionReoptimizationRetryCount(ExecState* exec)
2106 {
2107     if (exec-&gt;argumentCount() &lt; 1)
2108         return JSValue::encode(jsUndefined());
2109 
2110     CodeBlock* block = getSomeBaselineCodeBlockForFunction(exec-&gt;argument(0));
2111     if (!block)
2112         return JSValue::encode(jsNumber(0));
2113 
2114     return JSValue::encode(jsNumber(block-&gt;reoptimizationRetryCounter()));
2115 }
2116 
2117 EncodedJSValue JSC_HOST_CALL functionTransferArrayBuffer(ExecState* exec)
2118 {
2119     VM&amp; vm = exec-&gt;vm();
</pre>
<hr />
<pre>
2198     JSValue value = exec-&gt;argument(0);
2199     if (value.isObject())
2200         return JSValue::encode(jsBoolean(asObject(value)-&gt;hasCustomProperties(exec-&gt;vm())));
2201     return JSValue::encode(jsBoolean(false));
2202 }
2203 
2204 EncodedJSValue JSC_HOST_CALL functionDumpTypesForAllVariables(ExecState* exec)
2205 {
2206     VM&amp; vm = exec-&gt;vm();
2207     vm.dumpTypeProfilerData();
2208     return JSValue::encode(jsUndefined());
2209 }
2210 
2211 EncodedJSValue JSC_HOST_CALL functionDrainMicrotasks(ExecState* exec)
2212 {
2213     VM&amp; vm = exec-&gt;vm();
2214     vm.drainMicrotasks();
2215     return JSValue::encode(jsUndefined());
2216 }
2217 
<span class="line-added">2218 EncodedJSValue JSC_HOST_CALL functionReleaseWeakRefs(ExecState* exec)</span>
<span class="line-added">2219 {</span>
<span class="line-added">2220     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-added">2221     vm.finalizeSynchronousJSExecution();</span>
<span class="line-added">2222     return JSValue::encode(jsUndefined());</span>
<span class="line-added">2223 }</span>
<span class="line-added">2224 </span>
2225 EncodedJSValue JSC_HOST_CALL functionIs32BitPlatform(ExecState*)
2226 {
2227 #if USE(JSVALUE64)
2228     return JSValue::encode(JSValue(JSC::JSValue::JSFalse));
2229 #else
2230     return JSValue::encode(JSValue(JSC::JSValue::JSTrue));
2231 #endif
2232 }
2233 
2234 EncodedJSValue JSC_HOST_CALL functionCreateGlobalObject(ExecState* exec)
2235 {
2236     VM&amp; vm = exec-&gt;vm();
2237     return JSValue::encode(GlobalObject::create(vm, GlobalObject::createStructure(vm, jsNull()), Vector&lt;String&gt;()));
2238 }
2239 
2240 EncodedJSValue JSC_HOST_CALL functionCheckModuleSyntax(ExecState* exec)
2241 {
2242     VM&amp; vm = exec-&gt;vm();
2243     auto scope = DECLARE_THROW_SCOPE(vm);
2244 
2245     String source = exec-&gt;argument(0).toWTFString(exec);
2246     RETURN_IF_EXCEPTION(scope, encodedJSValue());
2247 
2248     StopWatch stopWatch;
2249     stopWatch.start();
2250 
2251     ParserError error;
<span class="line-modified">2252     bool validSyntax = checkModuleSyntax(exec, jscSource(source, { }, URL(), TextPosition(), SourceProviderSourceType::Module), error);</span>
2253     RETURN_IF_EXCEPTION(scope, encodedJSValue());
2254     stopWatch.stop();
2255 
2256     if (!validSyntax)
<span class="line-modified">2257         throwException(exec, scope, jsNontrivialString(vm, toString(&quot;SyntaxError: &quot;, error.message(), &quot;:&quot;, error.line())));</span>
2258     return JSValue::encode(jsNumber(stopWatch.getElapsedMS()));
2259 }
2260 
2261 EncodedJSValue JSC_HOST_CALL functionPlatformSupportsSamplingProfiler(ExecState*)
2262 {
2263 #if ENABLE(SAMPLING_PROFILER)
2264     return JSValue::encode(JSValue(JSC::JSValue::JSTrue));
2265 #else
2266     return JSValue::encode(JSValue(JSC::JSValue::JSFalse));
2267 #endif
2268 }
2269 
2270 EncodedJSValue JSC_HOST_CALL functionGenerateHeapSnapshot(ExecState* exec)
2271 {
2272     VM&amp; vm = exec-&gt;vm();
2273     JSLockHolder lock(vm);
2274     auto scope = DECLARE_THROW_SCOPE(vm);
2275 
2276     HeapSnapshotBuilder snapshotBuilder(vm.ensureHeapProfiler());
2277     snapshotBuilder.buildSnapshot();
</pre>
<hr />
<pre>
2280     EncodedJSValue result = JSValue::encode(JSONParse(exec, jsonString));
2281     scope.releaseAssertNoException();
2282     return result;
2283 }
2284 
2285 EncodedJSValue JSC_HOST_CALL functionGenerateHeapSnapshotForGCDebugging(ExecState* exec)
2286 {
2287     VM&amp; vm = exec-&gt;vm();
2288     JSLockHolder lock(vm);
2289     auto scope = DECLARE_THROW_SCOPE(vm);
2290     String jsonString;
2291     {
2292         DeferGCForAWhile deferGC(vm.heap); // Prevent concurrent GC from interfering with the full GC that the snapshot does.
2293 
2294         HeapSnapshotBuilder snapshotBuilder(vm.ensureHeapProfiler(), HeapSnapshotBuilder::SnapshotType::GCDebuggingSnapshot);
2295         snapshotBuilder.buildSnapshot();
2296 
2297         jsonString = snapshotBuilder.json();
2298     }
2299     scope.releaseAssertNoException();
<span class="line-modified">2300     return JSValue::encode(jsString(vm, jsonString));</span>
2301 }
2302 
2303 EncodedJSValue JSC_HOST_CALL functionResetSuperSamplerState(ExecState*)
2304 {
2305     resetSuperSamplerState();
2306     return JSValue::encode(jsUndefined());
2307 }
2308 
2309 EncodedJSValue JSC_HOST_CALL functionEnsureArrayStorage(ExecState* exec)
2310 {
2311     VM&amp; vm = exec-&gt;vm();
2312     for (unsigned i = 0; i &lt; exec-&gt;argumentCount(); ++i) {
2313         if (JSObject* object = jsDynamicCast&lt;JSObject*&gt;(vm, exec-&gt;argument(i)))
2314             object-&gt;ensureArrayStorage(vm);
2315     }
2316     return JSValue::encode(jsUndefined());
2317 }
2318 
2319 #if ENABLE(SAMPLING_PROFILER)
2320 EncodedJSValue JSC_HOST_CALL functionStartSamplingProfiler(ExecState* exec)
</pre>
<hr />
<pre>
2336 
2337     String jsonString = vm.samplingProfiler()-&gt;stackTracesAsJSON();
2338     EncodedJSValue result = JSValue::encode(JSONParse(exec, jsonString));
2339     scope.releaseAssertNoException();
2340     return result;
2341 }
2342 #endif // ENABLE(SAMPLING_PROFILER)
2343 
2344 EncodedJSValue JSC_HOST_CALL functionMaxArguments(ExecState*)
2345 {
2346     return JSValue::encode(jsNumber(JSC::maxArguments));
2347 }
2348 
2349 EncodedJSValue JSC_HOST_CALL functionAsyncTestStart(ExecState* exec)
2350 {
2351     VM&amp; vm = exec-&gt;vm();
2352     auto scope = DECLARE_THROW_SCOPE(vm);
2353 
2354     JSValue numberOfAsyncPasses = exec-&gt;argument(0);
2355     if (!numberOfAsyncPasses.isUInt32())
<span class="line-modified">2356         return throwVMError(exec, scope, &quot;Expected first argument to be a uint32&quot;_s);</span>
2357 
2358     asyncTestExpectedPasses += numberOfAsyncPasses.asUInt32();
2359     return encodedJSUndefined();
2360 }
2361 
2362 EncodedJSValue JSC_HOST_CALL functionAsyncTestPassed(ExecState*)
2363 {
2364     asyncTestPasses++;
2365     return encodedJSUndefined();
2366 }
2367 
2368 #if ENABLE(WEBASSEMBLY)
2369 
2370 static EncodedJSValue JSC_HOST_CALL functionWebAssemblyMemoryMode(ExecState* exec)
2371 {
2372     VM&amp; vm = exec-&gt;vm();
2373     auto scope = DECLARE_THROW_SCOPE(vm);
2374 
<span class="line-modified">2375     if (!Wasm::isSupported())</span>
2376         return throwVMTypeError(exec, scope, &quot;WebAssemblyMemoryMode should only be called if the useWebAssembly option is set&quot;_s);
2377 
2378     if (JSObject* object = exec-&gt;argument(0).getObject()) {
2379         if (auto* memory = jsDynamicCast&lt;JSWebAssemblyMemory*&gt;(vm, object))
<span class="line-modified">2380             return JSValue::encode(jsString(vm, makeString(memory-&gt;memory().mode())));</span>
2381         if (auto* instance = jsDynamicCast&lt;JSWebAssemblyInstance*&gt;(vm, object))
<span class="line-modified">2382             return JSValue::encode(jsString(vm, makeString(instance-&gt;memoryMode())));</span>
2383     }
2384 
2385     return throwVMTypeError(exec, scope, &quot;WebAssemblyMemoryMode expects either a WebAssembly.Memory or WebAssembly.Instance&quot;_s);
2386 }
2387 
2388 #endif // ENABLE(WEBASSEMBLY)
2389 
<span class="line-added">2390 EncodedJSValue JSC_HOST_CALL functionSetUnhandledRejectionCallback(ExecState* exec)</span>
<span class="line-added">2391 {</span>
<span class="line-added">2392     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-added">2393     JSObject* object = exec-&gt;argument(0).getObject();</span>
<span class="line-added">2394     auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-added">2395 </span>
<span class="line-added">2396     if (!object || !object-&gt;isFunction(vm))</span>
<span class="line-added">2397         return throwVMTypeError(exec, scope);</span>
<span class="line-added">2398 </span>
<span class="line-added">2399     exec-&gt;lexicalGlobalObject()-&gt;setUnhandledRejectionCallback(vm, object);</span>
<span class="line-added">2400     return JSValue::encode(jsUndefined());</span>
<span class="line-added">2401 }</span>
<span class="line-added">2402 </span>
2403 // Use SEH for Release builds only to get rid of the crash report dialog
2404 // (luckily the same tests fail in Release and Debug builds so far). Need to
2405 // be in a separate main function because the jscmain function requires object
2406 // unwinding.
2407 
2408 #if COMPILER(MSVC) &amp;&amp; !defined(_DEBUG)
2409 #define TRY       __try {
2410 #define EXCEPT(x) } __except (EXCEPTION_EXECUTE_HANDLER) { x; }
2411 #else
2412 #define TRY
2413 #define EXCEPT(x)
2414 #endif
2415 
2416 int jscmain(int argc, char** argv);
2417 
2418 static double s_desiredTimeout;
2419 static double s_timeoutMultiplier = 1.0;
2420 
2421 static void startTimeoutThreadIfNeeded()
2422 {
</pre>
<hr />
<pre>
2493 
2494 static void dumpException(GlobalObject* globalObject, JSValue exception)
2495 {
2496     VM&amp; vm = globalObject-&gt;vm();
2497     auto scope = DECLARE_CATCH_SCOPE(vm);
2498 
2499 #define CHECK_EXCEPTION() do { \
2500         if (scope.exception()) { \
2501             scope.clearException(); \
2502             return; \
2503         } \
2504     } while (false)
2505 
2506     auto exceptionString = exception.toWTFString(globalObject-&gt;globalExec());
2507     Expected&lt;CString, UTF8ConversionError&gt; expectedCString = exceptionString.tryGetUtf8();
2508     if (expectedCString)
2509         printf(&quot;Exception: %s\n&quot;, expectedCString.value().data());
2510     else
2511         printf(&quot;Exception: &lt;out of memory while extracting exception string&gt;\n&quot;);
2512 
<span class="line-modified">2513     Identifier nameID = Identifier::fromString(vm, &quot;name&quot;);</span>
2514     CHECK_EXCEPTION();
<span class="line-modified">2515     Identifier fileNameID = Identifier::fromString(vm, &quot;sourceURL&quot;);</span>
2516     CHECK_EXCEPTION();
<span class="line-modified">2517     Identifier lineNumberID = Identifier::fromString(vm, &quot;line&quot;);</span>
2518     CHECK_EXCEPTION();
<span class="line-modified">2519     Identifier stackID = Identifier::fromString(vm, &quot;stack&quot;);</span>
2520     CHECK_EXCEPTION();
2521 
2522     JSValue nameValue = exception.get(globalObject-&gt;globalExec(), nameID);
2523     CHECK_EXCEPTION();
2524     JSValue fileNameValue = exception.get(globalObject-&gt;globalExec(), fileNameID);
2525     CHECK_EXCEPTION();
2526     JSValue lineNumberValue = exception.get(globalObject-&gt;globalExec(), lineNumberID);
2527     CHECK_EXCEPTION();
2528     JSValue stackValue = exception.get(globalObject-&gt;globalExec(), stackID);
2529     CHECK_EXCEPTION();
2530 
2531     if (nameValue.toWTFString(globalObject-&gt;globalExec()) == &quot;SyntaxError&quot;
2532         &amp;&amp; (!fileNameValue.isUndefinedOrNull() || !lineNumberValue.isUndefinedOrNull())) {
2533         printf(
2534             &quot;at %s:%s\n&quot;,
2535             fileNameValue.toWTFString(globalObject-&gt;globalExec()).utf8().data(),
2536             lineNumberValue.toWTFString(globalObject-&gt;globalExec()).utf8().data());
2537     }
2538 
2539     if (!stackValue.isUndefinedOrNull()) {
2540         auto stackString = stackValue.toWTFString(globalObject-&gt;globalExec());
2541         if (stackString.length())
2542             printf(&quot;%s\n&quot;, stackString.utf8().data());
2543     }
2544 
2545 #undef CHECK_EXCEPTION
2546 }
2547 
2548 static bool checkUncaughtException(VM&amp; vm, GlobalObject* globalObject, JSValue exception, CommandLine&amp; options)
2549 {
2550     const String&amp; expectedExceptionName = options.m_uncaughtExceptionName;
2551     auto scope = DECLARE_CATCH_SCOPE(vm);
2552     scope.clearException();
2553     if (!exception) {
2554         printf(&quot;Expected uncaught exception with name &#39;%s&#39; but none was thrown\n&quot;, expectedExceptionName.utf8().data());
2555         return false;
2556     }
2557 
2558     ExecState* exec = globalObject-&gt;globalExec();
<span class="line-modified">2559     JSValue exceptionClass = globalObject-&gt;get(exec, Identifier::fromString(vm, expectedExceptionName));</span>
2560     if (!exceptionClass.isObject() || scope.exception()) {
2561         printf(&quot;Expected uncaught exception with name &#39;%s&#39; but given exception class is not defined\n&quot;, expectedExceptionName.utf8().data());
2562         return false;
2563     }
2564 
2565     bool isInstanceOfExpectedException = jsCast&lt;JSObject*&gt;(exceptionClass)-&gt;hasInstance(exec, exception);
2566     if (scope.exception()) {
2567         printf(&quot;Expected uncaught exception with name &#39;%s&#39; but given exception class fails performing hasInstance\n&quot;, expectedExceptionName.utf8().data());
2568         return false;
2569     }
2570     if (isInstanceOfExpectedException) {
2571         if (options.m_alwaysDumpUncaughtException)
2572             dumpException(globalObject, exception);
2573         return true;
2574     }
2575 
2576     printf(&quot;Expected uncaught exception with name &#39;%s&#39; but exception value is not instance of this exception class\n&quot;, expectedExceptionName.utf8().data());
2577     dumpException(globalObject, exception);
2578     return false;
2579 }
</pre>
<hr />
<pre>
2684     auto scope = DECLARE_CATCH_SCOPE(vm);
2685 
2686     Optional&lt;DirectoryName&gt; directoryName = currentWorkingDirectory();
2687     if (!directoryName)
2688         return;
2689     SourceOrigin sourceOrigin(resolvePath(directoryName.value(), ModuleName(&quot;interpreter&quot;)));
2690 
2691     bool shouldQuit = false;
2692     while (!shouldQuit) {
2693 #if HAVE(READLINE) &amp;&amp; !RUNNING_FROM_XCODE
2694         ParserError error;
2695         String source;
2696         do {
2697             error = ParserError();
2698             char* line = readline(source.isEmpty() ? interactivePrompt : &quot;... &quot;);
2699             shouldQuit = !line;
2700             if (!line)
2701                 break;
2702             source = source + String::fromUTF8(line);
2703             source = source + &#39;\n&#39;;
<span class="line-modified">2704             checkSyntax(vm, jscSource(source, sourceOrigin), error);</span>
2705             if (!line[0]) {
2706                 free(line);
2707                 break;
2708             }
2709             add_history(line);
2710             free(line);
2711         } while (error.syntaxErrorType() == ParserError::SyntaxErrorRecoverable);
2712 
2713         if (error.isValid()) {
2714             printf(&quot;%s:%d\n&quot;, error.message().utf8().data(), error.line());
2715             continue;
2716         }
2717 
2718 
2719         NakedPtr&lt;Exception&gt; evaluationException;
<span class="line-modified">2720         JSValue returnValue = evaluate(globalObject-&gt;globalExec(), jscSource(source, sourceOrigin), JSValue(), evaluationException);</span>
2721 #else
2722         printf(&quot;%s&quot;, interactivePrompt);
2723         Vector&lt;char, 256&gt; line;
2724         int c;
2725         while ((c = getchar()) != EOF) {
2726             // FIXME: Should we also break on \r?
2727             if (c == &#39;\n&#39;)
2728                 break;
2729             line.append(c);
2730         }
2731         if (line.isEmpty())
2732             break;
2733 
2734         NakedPtr&lt;Exception&gt; evaluationException;
2735         JSValue returnValue = evaluate(globalObject-&gt;globalExec(), jscSource(line, sourceOrigin, sourceOrigin.string()), JSValue(), evaluationException);
2736 #endif
2737         if (evaluationException)
2738             printf(&quot;Exception: %s\n&quot;, evaluationException-&gt;value().toWTFString(globalObject-&gt;globalExec()).utf8().data());
2739         else
2740             printf(&quot;%s\n&quot;, returnValue.toWTFString(globalObject-&gt;globalExec()).utf8().data());
</pre>
<hr />
<pre>
2754     fprintf(stderr, &quot;  -h|--help  Prints this help message\n&quot;);
2755     fprintf(stderr, &quot;  -i         Enables interactive mode (default if no files are specified)\n&quot;);
2756     fprintf(stderr, &quot;  -m         Execute as a module\n&quot;);
2757 #if HAVE(SIGNAL_H)
2758     fprintf(stderr, &quot;  -s         Installs signal handlers that exit on a crash (Unix platforms only)\n&quot;);
2759 #endif
2760     fprintf(stderr, &quot;  -p &lt;file&gt;  Outputs profiling data to a file\n&quot;);
2761     fprintf(stderr, &quot;  -x         Output exit code before terminating\n&quot;);
2762     fprintf(stderr, &quot;\n&quot;);
2763     fprintf(stderr, &quot;  --sample                   Collects and outputs sampling profiler data\n&quot;);
2764     fprintf(stderr, &quot;  --test262-async            Check that some script calls the print function with the string &#39;Test262:AsyncTestComplete&#39;\n&quot;);
2765     fprintf(stderr, &quot;  --strict-file=&lt;file&gt;       Parse the given file as if it were in strict mode (this option may be passed more than once)\n&quot;);
2766     fprintf(stderr, &quot;  --module-file=&lt;file&gt;       Parse and evaluate the given file as module (this option may be passed more than once)\n&quot;);
2767     fprintf(stderr, &quot;  --exception=&lt;name&gt;         Check the last script exits with an uncaught exception with the specified name\n&quot;);
2768     fprintf(stderr, &quot;  --watchdog-exception-ok    Uncaught watchdog exceptions exit with success\n&quot;);
2769     fprintf(stderr, &quot;  --dumpException            Dump uncaught exception text\n&quot;);
2770     fprintf(stderr, &quot;  --footprint                Dump memory footprint after done executing\n&quot;);
2771     fprintf(stderr, &quot;  --options                  Dumps all JSC VM options and exits\n&quot;);
2772     fprintf(stderr, &quot;  --dumpOptions              Dumps all non-default JSC VM options before continuing\n&quot;);
2773     fprintf(stderr, &quot;  --&lt;jsc VM option&gt;=&lt;value&gt;  Sets the specified JSC VM option\n&quot;);
<span class="line-added">2774     fprintf(stderr, &quot;  --destroy-vm               Destroy VM before exiting\n&quot;);</span>
2775     fprintf(stderr, &quot;\n&quot;);
2776     fprintf(stderr, &quot;Files with a .mjs extension will always be evaluated as modules.\n&quot;);
2777     fprintf(stderr, &quot;\n&quot;);
2778 
2779     jscExit(help ? EXIT_SUCCESS : EXIT_FAILURE);
2780 }
2781 
2782 static bool isMJSFile(char *filename)
2783 {
2784     filename = strrchr(filename, &#39;.&#39;);
2785 
2786     if (filename)
2787         return !strcmp(filename, &quot;.mjs&quot;);
2788 
2789     return false;
2790 }
2791 
2792 void CommandLine::parseArguments(int argc, char** argv)
2793 {
2794     Options::initialize();
</pre>
<hr />
<pre>
2863             break;
2864         }
2865         if (!strcmp(arg, &quot;-h&quot;) || !strcmp(arg, &quot;--help&quot;))
2866             printUsageStatement(true);
2867 
2868         if (!strcmp(arg, &quot;--options&quot;)) {
2869             dumpOptionsLevel = JSC::Options::DumpLevel::Verbose;
2870             needToExit = true;
2871             continue;
2872         }
2873         if (!strcmp(arg, &quot;--dumpOptions&quot;)) {
2874             dumpOptionsLevel = JSC::Options::DumpLevel::Overridden;
2875             continue;
2876         }
2877         if (!strcmp(arg, &quot;--sample&quot;)) {
2878             JSC::Options::useSamplingProfiler() = true;
2879             JSC::Options::collectSamplingProfilerDataForJSCShell() = true;
2880             m_dumpSamplingProfilerData = true;
2881             continue;
2882         }
<span class="line-added">2883         if (!strcmp(arg, &quot;--destroy-vm&quot;)) {</span>
<span class="line-added">2884             m_destroyVM = true;</span>
<span class="line-added">2885             continue;</span>
<span class="line-added">2886         }</span>
2887 
2888         static const char* timeoutMultiplierOptStr = &quot;--timeoutMultiplier=&quot;;
2889         static const unsigned timeoutMultiplierOptStrLength = strlen(timeoutMultiplierOptStr);
2890         if (!strncmp(arg, timeoutMultiplierOptStr, timeoutMultiplierOptStrLength)) {
2891             const char* valueStr = &amp;arg[timeoutMultiplierOptStrLength];
2892             if (sscanf(valueStr, &quot;%lf&quot;, &amp;s_timeoutMultiplier) != 1)
2893                 dataLog(&quot;WARNING: --timeoutMultiplier=&quot;, valueStr, &quot; is invalid. Expects a numeric ratio.\n&quot;);
2894             continue;
2895         }
2896 
2897         if (!strcmp(arg, &quot;--test262-async&quot;)) {
2898             asyncTestExpectedPasses++;
2899             continue;
2900         }
2901 
2902         if (!strcmp(arg, &quot;--remote-debug&quot;)) {
2903             m_enableRemoteDebugging = true;
2904             continue;
2905         }
2906 
</pre>
<hr />
<pre>
2968         JSC::Options::dumpAllOptions(stderr, dumpOptionsLevel, optionsTitle);
2969     }
2970     JSC::Options::ensureOptionsAreCoherent();
2971     if (needToExit)
2972         jscExit(EXIT_SUCCESS);
2973 }
2974 
2975 template&lt;typename Func&gt;
2976 int runJSC(const CommandLine&amp; options, bool isWorker, const Func&amp; func)
2977 {
2978     Worker worker(Workers::singleton());
2979 
2980     VM&amp; vm = VM::create(LargeHeap).leakRef();
2981     int result;
2982     bool success = true;
2983     GlobalObject* globalObject = nullptr;
2984     {
2985         JSLockHolder locker(vm);
2986 
2987         if (options.m_profile &amp;&amp; !vm.m_perBytecodeProfiler)
<span class="line-modified">2988             vm.m_perBytecodeProfiler = makeUnique&lt;Profiler::Database&gt;(vm);</span>
2989 
2990         globalObject = GlobalObject::create(vm, GlobalObject::createStructure(vm, jsNull()), options.m_arguments);
2991         globalObject-&gt;setRemoteDebuggingEnabled(options.m_enableRemoteDebugging);
2992         func(vm, globalObject, success);
2993         vm.drainMicrotasks();
2994     }
2995     vm.promiseDeferredTimer-&gt;runRunLoop();
2996     {
2997         JSLockHolder locker(vm);
2998         if (options.m_interactive &amp;&amp; success)
2999             runInteractive(globalObject);
3000     }
3001 
3002     result = success &amp;&amp; (asyncTestExpectedPasses == asyncTestPasses) ? 0 : 3;
3003 
3004     if (options.m_exitCode) {
3005         printf(&quot;jsc exiting %d&quot;, result);
3006         if (asyncTestExpectedPasses != asyncTestPasses)
3007             printf(&quot; because expected: %d async test passes but got: %d async test passes&quot;, asyncTestExpectedPasses, asyncTestPasses);
3008         printf(&quot;\n&quot;);
</pre>
<hr />
<pre>
3040 #endif
3041 
3042     if (Options::gcAtEnd()) {
3043         // We need to hold the API lock to do a GC.
3044         JSLockHolder locker(&amp;vm);
3045         vm.heap.collectNow(Sync, CollectionScope::Full);
3046     }
3047 
3048     if (options.m_dumpSamplingProfilerData) {
3049 #if ENABLE(SAMPLING_PROFILER)
3050         JSLockHolder locker(&amp;vm);
3051         vm.samplingProfiler()-&gt;reportTopFunctions();
3052         vm.samplingProfiler()-&gt;reportTopBytecodes();
3053 #else
3054         dataLog(&quot;Sampling profiler is not enabled on this platform\n&quot;);
3055 #endif
3056     }
3057 
3058     vm.codeCache()-&gt;write(vm);
3059 
<span class="line-modified">3060     if (options.m_destroyVM || isWorker) {</span>
3061         JSLockHolder locker(vm);
3062         // This is needed because we don&#39;t want the worker&#39;s main
3063         // thread to die before its compilation threads finish.
3064         vm.deref();
3065     }
3066 
3067     return result;
3068 }
3069 
3070 int jscmain(int argc, char** argv)
3071 {
3072     // Need to override and enable restricted options before we start parsing options below.
3073     Options::enableRestrictedOptions(true);
3074 
<span class="line-added">3075     WTF::initializeMainThread();</span>
<span class="line-added">3076 </span>
3077     // Note that the options parsing can affect VM creation, and thus
3078     // comes first.
3079     CommandLine options(argc, argv);
3080 
3081     processConfigFile(Options::configFile(), &quot;jsc&quot;);
3082 
3083     // Initialize JSC before getting VM.

3084     JSC::initializeThreading();
3085     startTimeoutThreadIfNeeded();
3086 #if ENABLE(WEBASSEMBLY)
3087     JSC::Wasm::enableFastMemory();
3088 #endif
3089     Gigacage::disableDisablingPrimitiveGigacageIfShouldBeEnabled();
3090 
3091 #if PLATFORM(COCOA)
3092     auto&amp; memoryPressureHandler = MemoryPressureHandler::singleton();
3093     {
3094         dispatch_queue_t queue = dispatch_queue_create(&quot;jsc shell memory pressure handler&quot;, DISPATCH_QUEUE_SERIAL);
3095         memoryPressureHandler.setDispatchQueue(queue);
3096         dispatch_release(queue);
3097     }
3098     Box&lt;Critical&gt; memoryPressureCriticalState = Box&lt;Critical&gt;::create(Critical::No);
3099     Box&lt;Synchronous&gt; memoryPressureSynchronousState = Box&lt;Synchronous&gt;::create(Synchronous::No);
3100     memoryPressureHandler.setLowMemoryHandler([=] (Critical critical, Synchronous synchronous) {
3101         // We set these racily with respect to reading them from the JS execution thread.
3102         *memoryPressureCriticalState = critical;
3103         *memoryPressureSynchronousState = synchronous;
</pre>
</td>
</tr>
</table>
<center><a href="jit/ThunkGenerators.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="llint/LLIntData.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>