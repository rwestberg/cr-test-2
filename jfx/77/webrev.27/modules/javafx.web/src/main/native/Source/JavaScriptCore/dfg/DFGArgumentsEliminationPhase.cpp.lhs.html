<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGArgumentsEliminationPhase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (C) 2015-2018 Apple Inc. All rights reserved.</span>
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;DFGArgumentsEliminationPhase.h&quot;
  28 
  29 #if ENABLE(DFG_JIT)
  30 
  31 #include &quot;ArrayPrototype.h&quot;
  32 #include &quot;BytecodeLivenessAnalysisInlines.h&quot;
  33 #include &quot;ClonedArguments.h&quot;
  34 #include &quot;DFGArgumentsUtilities.h&quot;
  35 #include &quot;DFGBasicBlockInlines.h&quot;
  36 #include &quot;DFGBlockMapInlines.h&quot;
  37 #include &quot;DFGClobberize.h&quot;
  38 #include &quot;DFGCombinedLiveness.h&quot;
  39 #include &quot;DFGForAllKills.h&quot;
  40 #include &quot;DFGGraph.h&quot;
  41 #include &quot;DFGInsertionSet.h&quot;
  42 #include &quot;DFGLivenessAnalysisPhase.h&quot;
  43 #include &quot;DFGOSRAvailabilityAnalysisPhase.h&quot;
  44 #include &quot;DFGPhase.h&quot;
  45 #include &quot;JSCInlines.h&quot;
  46 #include &lt;wtf/HashSet.h&gt;
  47 #include &lt;wtf/ListDump.h&gt;
  48 #include &lt;wtf/RecursableLambda.h&gt;
  49 
  50 namespace JSC { namespace DFG {
  51 
  52 namespace {
  53 
  54 namespace DFGArgumentsEliminationPhaseInternal {
  55 static const bool verbose = false;
  56 }
  57 
  58 class ArgumentsEliminationPhase : public Phase {
  59 public:
  60     ArgumentsEliminationPhase(Graph&amp; graph)
  61         : Phase(graph, &quot;arguments elimination&quot;)
  62     {
  63     }
  64 
  65     bool run()
  66     {
  67         // For now this phase only works on SSA. This could be changed; we could have a block-local
  68         // version over LoadStore.
  69         DFG_ASSERT(m_graph, nullptr, m_graph.m_form == SSA);
  70 
  71         if (DFGArgumentsEliminationPhaseInternal::verbose) {
  72             dataLog(&quot;Graph before arguments elimination:\n&quot;);
  73             m_graph.dump();
  74         }
  75 
  76         identifyCandidates();
  77         if (m_candidates.isEmpty())
  78             return false;
  79 
  80         eliminateCandidatesThatEscape();
  81         if (m_candidates.isEmpty())
  82             return false;
  83 
  84         eliminateCandidatesThatInterfere();
  85         if (m_candidates.isEmpty())
  86             return false;
  87 
  88         transform();
  89 
  90         return true;
  91     }
  92 
  93 private:
  94     // Just finds nodes that we know how to work with.
  95     void identifyCandidates()
  96     {
  97         for (BasicBlock* block : m_graph.blocksInPreOrder()) {
  98             for (Node* node : *block) {
  99                 switch (node-&gt;op()) {
 100                 case CreateDirectArguments:
 101                 case CreateClonedArguments:
 102                     m_candidates.add(node);
 103                     break;
 104 
 105                 case CreateRest:
 106                     if (m_graph.isWatchingHavingABadTimeWatchpoint(node)) {
 107                         // If we&#39;re watching the HavingABadTime watchpoint it means that we will be invalidated
 108                         // when it fires (it may or may not have actually fired yet). We don&#39;t try to eliminate
 109                         // this allocation when we&#39;re not watching the watchpoint because it could entail calling
 110                         // indexed accessors (and probably more crazy things) on out of bound accesses to the
 111                         // rest parameter. It&#39;s also much easier to reason about this way.
 112                         m_candidates.add(node);
 113                     }
 114                     break;
 115 
 116                 case Spread:
 117                     if (m_graph.isWatchingHavingABadTimeWatchpoint(node)) {
 118                         // We check ArrayUse here because ArrayUse indicates that the iterator
 119                         // protocol for Arrays is non-observable by user code (e.g, it hasn&#39;t
 120                         // been changed).
 121                         if (node-&gt;child1().useKind() == ArrayUse) {
 122                             if ((node-&gt;child1()-&gt;op() == CreateRest || node-&gt;child1()-&gt;op() == NewArrayBuffer) &amp;&amp; m_candidates.contains(node-&gt;child1().node()))
 123                                 m_candidates.add(node);
 124                         }
 125                     }
 126                     break;
 127 
 128                 case NewArrayWithSpread: {
 129                     if (m_graph.isWatchingHavingABadTimeWatchpoint(node)) {
 130                         BitVector* bitVector = node-&gt;bitVector();
 131                         // We only allow for Spreads to be of CreateRest or NewArrayBuffer nodes for now.
 132                         bool isOK = true;
 133                         for (unsigned i = 0; i &lt; node-&gt;numChildren(); i++) {
 134                             if (bitVector-&gt;get(i)) {
 135                                 Node* child = m_graph.varArgChild(node, i).node();
 136                                 isOK = child-&gt;op() == Spread &amp;&amp; (child-&gt;child1()-&gt;op() == CreateRest || child-&gt;child1()-&gt;op() == NewArrayBuffer) &amp;&amp; m_candidates.contains(child);
 137                                 if (!isOK)
 138                                     break;
 139                             }
 140                         }
 141 
 142                         if (!isOK)
 143                             break;
 144 
 145                         m_candidates.add(node);
 146                     }
 147                     break;
 148                 }
 149 
 150                 case NewArrayBuffer: {
 151                     if (m_graph.isWatchingHavingABadTimeWatchpoint(node) &amp;&amp; !hasAnyArrayStorage(node-&gt;indexingMode()))
 152                         m_candidates.add(node);
 153                     break;
 154                 }
 155 
 156                 case CreateScopedArguments:
 157                     // FIXME: We could handle this if it wasn&#39;t for the fact that scoped arguments are
 158                     // always stored into the activation.
 159                     // https://bugs.webkit.org/show_bug.cgi?id=143072 and
 160                     // https://bugs.webkit.org/show_bug.cgi?id=143073
 161                     break;
 162 
 163                 default:
 164                     break;
 165                 }
 166                 if (node-&gt;isPseudoTerminal())
 167                     break;
 168             }
 169         }
 170 
 171         if (DFGArgumentsEliminationPhaseInternal::verbose)
 172             dataLog(&quot;Candidates: &quot;, listDump(m_candidates), &quot;\n&quot;);
 173     }
 174 
 175     bool isStillValidCandidate(Node* candidate)
 176     {
 177         switch (candidate-&gt;op()) {
 178         case Spread:
 179             return m_candidates.contains(candidate-&gt;child1().node());
 180 
 181         case NewArrayWithSpread: {
 182             BitVector* bitVector = candidate-&gt;bitVector();
 183             for (unsigned i = 0; i &lt; candidate-&gt;numChildren(); i++) {
 184                 if (bitVector-&gt;get(i)) {
 185                     if (!m_candidates.contains(m_graph.varArgChild(candidate, i).node()))
 186                         return false;
 187                 }
 188             }
 189             return true;
 190         }
 191 
 192         default:
 193             return true;
 194         }
 195 
 196         RELEASE_ASSERT_NOT_REACHED();
 197         return false;
 198     }
 199 
 200     void removeInvalidCandidates()
 201     {
 202         bool changed;
 203         do {
 204             changed = false;
 205             Vector&lt;Node*, 1&gt; toRemove;
 206 
 207             for (Node* candidate : m_candidates) {
 208                 if (!isStillValidCandidate(candidate))
 209                     toRemove.append(candidate);
 210             }
 211 
 212             if (toRemove.size()) {
 213                 changed = true;
 214                 for (Node* node : toRemove)
 215                     m_candidates.remove(node);
 216             }
 217 
 218         } while (changed);
 219     }
 220 
 221     void transitivelyRemoveCandidate(Node* node, Node* source = nullptr)
 222     {
 223         bool removed = m_candidates.remove(node);
 224         if (removed &amp;&amp; DFGArgumentsEliminationPhaseInternal::verbose &amp;&amp; source)
 225             dataLog(&quot;eliminating candidate: &quot;, node, &quot; because it escapes from: &quot;, source, &quot;\n&quot;);
 226 
 227         if (removed)
 228             removeInvalidCandidates();
 229     }
 230 
 231     // Look for escaping sites, and remove from the candidates set if we see an escape.
 232     void eliminateCandidatesThatEscape()
 233     {
 234         auto escape = [&amp;] (Edge edge, Node* source) {
 235             if (!edge)
 236                 return;
 237             transitivelyRemoveCandidate(edge.node(), source);
 238         };
 239 
 240         auto escapeBasedOnArrayMode = [&amp;] (ArrayMode mode, Edge edge, Node* source) {
 241             switch (mode.type()) {
 242             case Array::DirectArguments: {
 243                 if (edge-&gt;op() != CreateDirectArguments) {
 244                     escape(edge, source);
 245                     break;
 246                 }
 247 
 248                 // Everything is fine if we&#39;re doing an in-bounds access.
 249                 if (mode.isInBounds())
 250                     break;
 251 
 252                 // If we&#39;re out-of-bounds then we proceed only if the prototype chain
 253                 // for the allocation is sane (i.e. doesn&#39;t have indexed properties).
 254                 JSGlobalObject* globalObject = m_graph.globalObjectFor(edge-&gt;origin.semantic);
 255                 Structure* objectPrototypeStructure = globalObject-&gt;objectPrototype()-&gt;structure(m_graph.m_vm);
 256                 if (objectPrototypeStructure-&gt;transitionWatchpointSetIsStillValid()
 257                     &amp;&amp; globalObject-&gt;objectPrototypeIsSane()) {
 258                     m_graph.registerAndWatchStructureTransition(objectPrototypeStructure);
 259                     break;
 260                 }
 261                 escape(edge, source);
 262                 break;
 263             }
 264 
 265             case Array::Contiguous: {
 266                 if (edge-&gt;op() != CreateClonedArguments &amp;&amp; edge-&gt;op() != CreateRest) {
 267                     escape(edge, source);
 268                     break;
 269                 }
 270 
 271                 // Everything is fine if we&#39;re doing an in-bounds access.
 272                 if (mode.isInBounds())
 273                     break;
 274 
 275                 // If we&#39;re out-of-bounds then we proceed only if the prototype chain
 276                 // for the allocation is sane (i.e. doesn&#39;t have indexed properties).
 277                 JSGlobalObject* globalObject = m_graph.globalObjectFor(edge-&gt;origin.semantic);
 278                 Structure* objectPrototypeStructure = globalObject-&gt;objectPrototype()-&gt;structure(m_graph.m_vm);
 279                 if (edge-&gt;op() == CreateRest) {
 280                     Structure* arrayPrototypeStructure = globalObject-&gt;arrayPrototype()-&gt;structure(m_graph.m_vm);
 281                     if (arrayPrototypeStructure-&gt;transitionWatchpointSetIsStillValid()
 282                         &amp;&amp; objectPrototypeStructure-&gt;transitionWatchpointSetIsStillValid()
 283                         &amp;&amp; globalObject-&gt;arrayPrototypeChainIsSane()) {
 284                         m_graph.registerAndWatchStructureTransition(arrayPrototypeStructure);
 285                         m_graph.registerAndWatchStructureTransition(objectPrototypeStructure);
 286                         break;
 287                     }
 288                 } else {
 289                     if (objectPrototypeStructure-&gt;transitionWatchpointSetIsStillValid()
 290                         &amp;&amp; globalObject-&gt;objectPrototypeIsSane()) {
 291                         m_graph.registerAndWatchStructureTransition(objectPrototypeStructure);
 292                         break;
 293                     }
 294                 }
 295                 escape(edge, source);
 296                 break;
 297             }
 298 
 299             case Array::ForceExit:
 300                 break;
 301 
 302             default:
 303                 escape(edge, source);
 304                 break;
 305             }
 306         };
 307 
 308         removeInvalidCandidates();
 309 
 310         for (BasicBlock* block : m_graph.blocksInNaturalOrder()) {
 311             for (Node* node : *block) {
 312                 switch (node-&gt;op()) {
 313                 case GetFromArguments:
 314                     break;
 315 
 316                 case GetByVal:
 317                     escapeBasedOnArrayMode(node-&gt;arrayMode(), m_graph.varArgChild(node, 0), node);
 318                     escape(m_graph.varArgChild(node, 1), node);
 319                     escape(m_graph.varArgChild(node, 2), node);
 320                     break;
 321 
 322                 case GetArrayLength:
 323                     escape(node-&gt;child2(), node);
 324                     // Computing the length of a NewArrayWithSpread can require some additions.
 325                     // These additions can overflow if the array is sufficiently enormous, and in that case we will need to exit.
 326                     if ((node-&gt;child1()-&gt;op() == NewArrayWithSpread) &amp;&amp; !node-&gt;origin.exitOK)
 327                         escape(node-&gt;child1(), node);
 328                     break;
 329 
 330                 case NewArrayWithSpread: {
 331                     BitVector* bitVector = node-&gt;bitVector();
 332                     bool isWatchingHavingABadTimeWatchpoint = m_graph.isWatchingHavingABadTimeWatchpoint(node);
 333                     for (unsigned i = 0; i &lt; node-&gt;numChildren(); i++) {
 334                         Edge child = m_graph.varArgChild(node, i);
 335                         bool dontEscape;
 336                         if (bitVector-&gt;get(i)) {
 337                             dontEscape = child-&gt;op() == Spread
 338                                 &amp;&amp; child-&gt;child1().useKind() == ArrayUse
 339                                 &amp;&amp; (child-&gt;child1()-&gt;op() == CreateRest || child-&gt;child1()-&gt;op() == NewArrayBuffer)
 340                                 &amp;&amp; isWatchingHavingABadTimeWatchpoint;
 341                         } else
 342                             dontEscape = false;
 343 
 344                         if (!dontEscape)
 345                             escape(child, node);
 346                     }
 347 
 348                     break;
 349                 }
 350 
 351                 case Spread: {
 352                     bool isOK = node-&gt;child1().useKind() == ArrayUse &amp;&amp; (node-&gt;child1()-&gt;op() == CreateRest || node-&gt;child1()-&gt;op() == NewArrayBuffer);
 353                     if (!isOK)
 354                         escape(node-&gt;child1(), node);
 355                     break;
 356                 }
 357 
 358                 case NewArrayBuffer:
 359                     break;
 360 
 361                 case LoadVarargs:
 362                     if (node-&gt;loadVarargsData()-&gt;offset &amp;&amp; (node-&gt;child1()-&gt;op() == NewArrayWithSpread || node-&gt;child1()-&gt;op() == Spread || node-&gt;child1()-&gt;op() == NewArrayBuffer))
 363                         escape(node-&gt;child1(), node);
 364                     break;
 365 
 366                 case CallVarargs:
 367                 case ConstructVarargs:
 368                 case TailCallVarargs:
 369                 case TailCallVarargsInlinedCaller:
 370                     escape(node-&gt;child1(), node);
 371                     escape(node-&gt;child2(), node);
 372                     if (node-&gt;callVarargsData()-&gt;firstVarArgOffset &amp;&amp; (node-&gt;child3()-&gt;op() == NewArrayWithSpread || node-&gt;child3()-&gt;op() == Spread || node-&gt;child1()-&gt;op() == NewArrayBuffer))
 373                         escape(node-&gt;child3(), node);
 374                     break;
 375 
 376                 case Check:
 377                 case CheckVarargs:
 378                     m_graph.doToChildren(
 379                         node,
 380                         [&amp;] (Edge edge) {
 381                             if (edge.willNotHaveCheck())
 382                                 return;
 383 
 384                             if (alreadyChecked(edge.useKind(), SpecObject))
 385                                 return;
 386 
 387                             escape(edge, node);
 388                         });
 389                     break;
 390 
 391                 case MovHint:
 392                 case PutHint:
 393                     break;
 394 
 395                 case GetButterfly:
 396                     // This barely works. The danger is that the GetButterfly is used by something that
 397                     // does something escaping to a candidate. Fortunately, the only butterfly-using ops
 398                     // that we exempt here also use the candidate directly. If there ever was a
 399                     // butterfly-using op that we wanted to exempt, then we&#39;d have to look at the
 400                     // butterfly&#39;s child and check if it&#39;s a candidate.
 401                     break;
 402 
 403                 case FilterGetByIdStatus:
 404                 case FilterPutByIdStatus:
 405                 case FilterCallLinkStatus:
 406                 case FilterInByIdStatus:
 407                     break;
 408 
 409                 case CheckArray:
 410                     escapeBasedOnArrayMode(node-&gt;arrayMode(), node-&gt;child1(), node);
 411                     break;
 412 
 413                 case CheckStructureOrEmpty:
 414                 case CheckStructure: {
 415                     Node* target = node-&gt;child1().node();
 416                     if (!m_candidates.contains(target))
 417                         break;
 418 
 419                     Structure* structure = nullptr;
 420                     JSGlobalObject* globalObject = m_graph.globalObjectFor(target-&gt;origin.semantic);
 421                     switch (target-&gt;op()) {
 422                     case CreateDirectArguments:
 423                         structure = globalObject-&gt;directArgumentsStructure();
 424                         break;
 425                     case CreateClonedArguments:
 426                         structure = globalObject-&gt;clonedArgumentsStructure();
 427                         break;
 428                     case CreateRest:
 429                         ASSERT(m_graph.isWatchingHavingABadTimeWatchpoint(target));
 430                         structure = globalObject-&gt;restParameterStructure();
 431                         break;
 432                     case NewArrayWithSpread:
 433                         ASSERT(m_graph.isWatchingHavingABadTimeWatchpoint(target));
 434                         structure = globalObject-&gt;originalArrayStructureForIndexingType(ArrayWithContiguous);
 435                         break;
 436                     case NewArrayBuffer: {
 437                         ASSERT(m_graph.isWatchingHavingABadTimeWatchpoint(target));
 438                         IndexingType indexingMode = target-&gt;indexingMode();
 439                         ASSERT(!hasAnyArrayStorage(indexingMode));
 440                         structure = globalObject-&gt;originalArrayStructureForIndexingType(indexingMode);
 441                         break;
 442                     }
 443                     default:
 444                         RELEASE_ASSERT_NOT_REACHED();
 445                     }
 446                     ASSERT(structure);
 447 
 448                     if (!node-&gt;structureSet().contains(m_graph.registerStructure(structure)))
 449                         escape(node-&gt;child1(), node);
 450                     break;
 451                 }
 452 
 453                 // FIXME: We should be able to handle GetById/GetByOffset on callee.
 454                 // https://bugs.webkit.org/show_bug.cgi?id=143075
 455 
 456                 case GetByOffset:
 457                     if (node-&gt;child2()-&gt;op() == CreateClonedArguments &amp;&amp; node-&gt;storageAccessData().offset == clonedArgumentsLengthPropertyOffset)
 458                         break;
 459                     FALLTHROUGH;
 460                 default:
 461                     m_graph.doToChildren(node, [&amp;] (Edge edge) { return escape(edge, node); });
 462                     break;
 463                 }
 464                 if (node-&gt;isPseudoTerminal())
 465                     break;
 466             }
 467         }
 468 
 469         if (DFGArgumentsEliminationPhaseInternal::verbose)
 470             dataLog(&quot;After escape analysis: &quot;, listDump(m_candidates), &quot;\n&quot;);
 471     }
 472 
 473     // Anywhere that a candidate is live (in bytecode or in DFG), check if there is a chance of
 474     // interference between the stack area that the arguments object copies from and the arguments
 475     // object&#39;s payload. Conservatively this means that the stack region doesn&#39;t get stored to.
 476     void eliminateCandidatesThatInterfere()
 477     {
 478         performLivenessAnalysis(m_graph);
 479         performOSRAvailabilityAnalysis(m_graph);
 480         m_graph.initializeNodeOwners();
 481         CombinedLiveness combinedLiveness(m_graph);
 482 
 483         BlockMap&lt;Operands&lt;bool&gt;&gt; clobberedByBlock(m_graph);
 484         for (BasicBlock* block : m_graph.blocksInNaturalOrder()) {
 485             Operands&lt;bool&gt;&amp; clobberedByThisBlock = clobberedByBlock[block];
 486             clobberedByThisBlock = Operands&lt;bool&gt;(OperandsLike, m_graph.block(0)-&gt;variablesAtHead);
 487             for (Node* node : *block) {
 488                 clobberize(
 489                     m_graph, node, NoOpClobberize(),
 490                     [&amp;] (AbstractHeap heap) {
 491                         if (heap.kind() != Stack) {
 492                             ASSERT(!heap.overlaps(Stack));
 493                             return;
 494                         }
 495                         ASSERT(!heap.payload().isTop());
 496                         VirtualRegister reg(heap.payload().value32());
 497                         // The register may not point to an argument or local, for example if we are looking at SetArgumentCountIncludingThis.
 498                         if (!reg.isHeader())
 499                             clobberedByThisBlock.operand(reg) = true;
 500                     },
 501                     NoOpClobberize());
 502             }
 503         }
 504 
<a name="2" id="anc2"></a>


























 505         for (BasicBlock* block : m_graph.blocksInNaturalOrder()) {
 506             // Stop if we&#39;ve already removed all candidates.
 507             if (m_candidates.isEmpty())
 508                 return;
 509 
 510             // Ignore blocks that don&#39;t write to the stack.
 511             bool writesToStack = false;
 512             for (unsigned i = clobberedByBlock[block].size(); i--;) {
 513                 if (clobberedByBlock[block][i]) {
 514                     writesToStack = true;
 515                     break;
 516                 }
 517             }
 518             if (!writesToStack)
 519                 continue;
 520 
 521             forAllKillsInBlock(
 522                 m_graph, combinedLiveness, block,
 523                 [&amp;] (unsigned nodeIndex, Node* candidate) {
 524                     if (!m_candidates.contains(candidate))
 525                         return;
 526 
<a name="3" id="anc3"></a><span class="line-modified"> 527                     // Check if this block has any clobbers that affect this candidate. This is a fairly</span>
<span class="line-modified"> 528                     // fast check.</span>
<span class="line-modified"> 529                     bool isClobberedByBlock = false;</span>
<span class="line-modified"> 530                     Operands&lt;bool&gt;&amp; clobberedByThisBlock = clobberedByBlock[block];</span>

 531 
<a name="4" id="anc4"></a><span class="line-modified"> 532                     if (InlineCallFrame* inlineCallFrame = candidate-&gt;origin.semantic.inlineCallFrame) {</span>
<span class="line-modified"> 533                         if (inlineCallFrame-&gt;isVarargs()) {</span>
<span class="line-modified"> 534                             isClobberedByBlock |= clobberedByThisBlock.operand(</span>
<span class="line-modified"> 535                                 inlineCallFrame-&gt;stackOffset + CallFrameSlot::argumentCount);</span>
<span class="line-modified"> 536                         }</span>
 537 
<a name="5" id="anc5"></a><span class="line-modified"> 538                         if (!isClobberedByBlock || inlineCallFrame-&gt;isClosureCall) {</span>
<span class="line-modified"> 539                             isClobberedByBlock |= clobberedByThisBlock.operand(</span>
<span class="line-modified"> 540                                 inlineCallFrame-&gt;stackOffset + CallFrameSlot::callee);</span>
<span class="line-modified"> 541                         }</span>
 542 
<a name="6" id="anc6"></a><span class="line-modified"> 543                         if (!isClobberedByBlock) {</span>
<span class="line-modified"> 544                             for (unsigned i = 0; i &lt; inlineCallFrame-&gt;argumentCountIncludingThis - 1; ++i) {</span>
<span class="line-modified"> 545                                 VirtualRegister reg =</span>
<span class="line-modified"> 546                                     VirtualRegister(inlineCallFrame-&gt;stackOffset) +</span>
<span class="line-modified"> 547                                     CallFrame::argumentOffset(i);</span>
<span class="line-modified"> 548                                 if (clobberedByThisBlock.operand(reg)) {</span>










 549                                     isClobberedByBlock = true;
 550                                     break;
 551                                 }
 552                             }
 553                         }
<a name="7" id="anc7"></a><span class="line-removed"> 554                     } else {</span>
<span class="line-removed"> 555                         // We don&#39;t include the ArgumentCount or Callee in this case because we can be</span>
<span class="line-removed"> 556                         // damn sure that this won&#39;t be clobbered.</span>
<span class="line-removed"> 557                         for (unsigned i = 1; i &lt; static_cast&lt;unsigned&gt;(codeBlock()-&gt;numParameters()); ++i) {</span>
<span class="line-removed"> 558                             if (clobberedByThisBlock.argument(i)) {</span>
<span class="line-removed"> 559                                 isClobberedByBlock = true;</span>
<span class="line-removed"> 560                                 break;</span>
<span class="line-removed"> 561                             }</span>
<span class="line-removed"> 562                         }</span>
<span class="line-removed"> 563                     }</span>
 564 
<a name="8" id="anc8"></a><span class="line-modified"> 565                     if (!isClobberedByBlock)</span>
<span class="line-modified"> 566                         return;</span>
 567 
<a name="9" id="anc9"></a><span class="line-modified"> 568                     // Check if we can immediately eliminate this candidate. If the block has a clobber</span>
<span class="line-modified"> 569                     // for this arguments allocation, and we&#39;d have to examine every node in the block,</span>
<span class="line-modified"> 570                     // then we can just eliminate the candidate.</span>
<span class="line-modified"> 571                     if (nodeIndex == block-&gt;size() &amp;&amp; candidate-&gt;owner != block) {</span>
<span class="line-modified"> 572                         if (DFGArgumentsEliminationPhaseInternal::verbose)</span>
<span class="line-modified"> 573                             dataLog(&quot;eliminating candidate: &quot;, candidate, &quot; because it is clobbered by: &quot;, block-&gt;at(nodeIndex), &quot;\n&quot;);</span>
<span class="line-modified"> 574                         transitivelyRemoveCandidate(candidate);</span>
<span class="line-modified"> 575                         return;</span>
<span class="line-modified"> 576                     }</span>
 577 
<a name="10" id="anc10"></a><span class="line-modified"> 578                     // This loop considers all nodes up to the nodeIndex, excluding the nodeIndex.</span>
<span class="line-modified"> 579                     while (nodeIndex--) {</span>
<span class="line-modified"> 580                         Node* node = block-&gt;at(nodeIndex);</span>
<span class="line-modified"> 581                         if (node == candidate)</span>
<span class="line-modified"> 582                             break;</span>













 583 
<a name="11" id="anc11"></a><span class="line-modified"> 584                         bool found = false;</span>
<span class="line-modified"> 585                         clobberize(</span>
<span class="line-modified"> 586                             m_graph, node, NoOpClobberize(),</span>
<span class="line-modified"> 587                             [&amp;] (AbstractHeap heap) {</span>
<span class="line-modified"> 588                                 if (heap.kind() == Stack &amp;&amp; !heap.payload().isTop()) {</span>
<span class="line-modified"> 589                                     if (argumentsInvolveStackSlot(candidate, VirtualRegister(heap.payload().value32())))</span>




 590                                         found = true;
<a name="12" id="anc12"></a><span class="line-modified"> 591                                     return;</span>
<span class="line-modified"> 592                                 }</span>
<span class="line-removed"> 593                                 if (heap.overlaps(Stack))</span>
<span class="line-removed"> 594                                     found = true;</span>
<span class="line-removed"> 595                             },</span>
<span class="line-removed"> 596                             NoOpClobberize());</span>
 597 
<a name="13" id="anc13"></a><span class="line-modified"> 598                         if (found) {</span>
<span class="line-modified"> 599                             if (DFGArgumentsEliminationPhaseInternal::verbose)</span>
<span class="line-modified"> 600                                 dataLog(&quot;eliminating candidate: &quot;, candidate, &quot; because it is clobbered by &quot;, block-&gt;at(nodeIndex), &quot;\n&quot;);</span>
<span class="line-modified"> 601                             transitivelyRemoveCandidate(candidate);</span>
<span class="line-modified"> 602                             return;</span>

 603                         }
 604                     }
 605                 });
 606         }
 607 
 608         // Q: How do we handle OSR exit with a live PhantomArguments at a point where the inline call
 609         // frame is dead?  A: Naively we could say that PhantomArguments must escape the stack slots. But
 610         // that would break PutStack sinking, which in turn would break object allocation sinking, in
 611         // cases where we have a varargs call to an otherwise pure method. So, we need something smarter.
 612         // For the outermost arguments, we just have a PhantomArguments that magically knows that it
 613         // should load the arguments from the call frame. For the inline arguments, we have the heap map
 614         // in the availabiltiy map track each possible inline argument as a promoted heap location. If the
 615         // PutStacks for those arguments aren&#39;t sunk, those heap locations will map to very trivial
 616         // availabilities (they will be flush availabilities). But if sinking happens then those
 617         // availabilities may become whatever. OSR exit should be able to handle this quite naturally,
 618         // since those availabilities speak of the stack before the optimizing compiler stack frame is
 619         // torn down.
 620 
 621         if (DFGArgumentsEliminationPhaseInternal::verbose)
 622             dataLog(&quot;After interference analysis: &quot;, listDump(m_candidates), &quot;\n&quot;);
 623     }
 624 
 625     void transform()
 626     {
 627         bool modifiedCFG = false;
 628 
 629         InsertionSet insertionSet(m_graph);
 630 
 631         for (BasicBlock* block : m_graph.blocksInPreOrder()) {
 632             Node* pseudoTerminal = nullptr;
 633             for (unsigned nodeIndex = 0; nodeIndex &lt; block-&gt;size(); ++nodeIndex) {
 634                 Node* node = block-&gt;at(nodeIndex);
 635 
 636                 auto getArrayLength = [&amp;] (Node* candidate) -&gt; Node* {
 637                     return emitCodeToGetArgumentsArrayLength(
 638                         insertionSet, candidate, nodeIndex, node-&gt;origin);
 639                 };
 640 
 641                 auto isEliminatedAllocation = [&amp;] (Node* candidate) -&gt; bool {
 642                     if (!m_candidates.contains(candidate))
 643                         return false;
 644                     // We traverse in such a way that we are guaranteed to see a def before a use.
 645                     // Therefore, we should have already transformed the allocation before the use
 646                     // of an allocation.
 647                     ASSERT(candidate-&gt;op() == PhantomCreateRest || candidate-&gt;op() == PhantomDirectArguments || candidate-&gt;op() == PhantomClonedArguments
 648                         || candidate-&gt;op() == PhantomSpread || candidate-&gt;op() == PhantomNewArrayWithSpread || candidate-&gt;op() == PhantomNewArrayBuffer);
 649                     return true;
 650                 };
 651 
 652                 switch (node-&gt;op()) {
 653                 case CreateDirectArguments:
 654                     if (!m_candidates.contains(node))
 655                         break;
 656 
 657                     node-&gt;setOpAndDefaultFlags(PhantomDirectArguments);
 658                     break;
 659 
 660                 case CreateRest:
 661                     if (!m_candidates.contains(node))
 662                         break;
 663 
<a name="14" id="anc14"></a>





 664                     node-&gt;setOpAndDefaultFlags(PhantomCreateRest);
 665                     // We don&#39;t need this parameter for OSR exit, we can find out all the information
 666                     // we need via the static parameter count and the dynamic argument count.
 667                     node-&gt;child1() = Edge();
 668                     break;
 669 
 670                 case CreateClonedArguments:
 671                     if (!m_candidates.contains(node))
 672                         break;
 673 
 674                     node-&gt;setOpAndDefaultFlags(PhantomClonedArguments);
 675                     break;
 676 
 677                 case Spread:
 678                     if (!m_candidates.contains(node))
 679                         break;
 680 
 681                     node-&gt;setOpAndDefaultFlags(PhantomSpread);
 682                     break;
 683 
 684                 case NewArrayWithSpread:
 685                     if (!m_candidates.contains(node))
 686                         break;
 687 
 688                     node-&gt;setOpAndDefaultFlags(PhantomNewArrayWithSpread);
 689                     break;
 690 
 691                 case NewArrayBuffer:
 692                     if (!m_candidates.contains(node))
 693                         break;
 694 
 695                     node-&gt;setOpAndDefaultFlags(PhantomNewArrayBuffer);
 696                     node-&gt;child1() = Edge(insertionSet.insertConstant(nodeIndex, node-&gt;origin, node-&gt;cellOperand()));
 697                     break;
 698 
 699                 case GetFromArguments: {
 700                     Node* candidate = node-&gt;child1().node();
 701                     if (!isEliminatedAllocation(candidate))
 702                         break;
 703 
 704                     DFG_ASSERT(
 705                         m_graph, node, node-&gt;child1()-&gt;op() == PhantomDirectArguments, node-&gt;child1()-&gt;op());
 706                     VirtualRegister reg =
 707                         virtualRegisterForArgument(node-&gt;capturedArgumentsOffset().offset() + 1) +
 708                         node-&gt;origin.semantic.stackOffset();
 709                     StackAccessData* data = m_graph.m_stackAccessData.add(reg, FlushedJSValue);
 710                     node-&gt;convertToGetStack(data);
 711                     break;
 712                 }
 713 
 714                 case GetByOffset: {
 715                     Node* candidate = node-&gt;child2().node();
 716                     if (!isEliminatedAllocation(candidate))
 717                         break;
 718 
 719                     ASSERT(candidate-&gt;op() == PhantomClonedArguments);
 720                     ASSERT(node-&gt;storageAccessData().offset == clonedArgumentsLengthPropertyOffset);
 721 
 722                     // Meh, this is kind of hackish - we use an Identity so that we can reuse the
 723                     // getArrayLength() helper.
 724                     node-&gt;convertToIdentityOn(getArrayLength(candidate));
 725                     break;
 726                 }
 727 
 728                 case GetArrayLength: {
 729                     Node* candidate = node-&gt;child1().node();
 730                     if (!isEliminatedAllocation(candidate))
 731                         break;
 732 
 733                     node-&gt;convertToIdentityOn(getArrayLength(candidate));
 734                     break;
 735                 }
 736 
 737                 case GetByVal: {
 738                     // FIXME: For ClonedArguments, we would have already done a separate bounds check.
 739                     // This code will cause us to have two bounds checks - the original one that we
 740                     // already factored out in SSALoweringPhase, and the new one we insert here, which is
 741                     // often implicitly part of GetMyArgumentByVal. B3 will probably eliminate the
 742                     // second bounds check, but still - that&#39;s just silly.
 743                     // https://bugs.webkit.org/show_bug.cgi?id=143076
 744 
 745                     Node* candidate = m_graph.varArgChild(node, 0).node();
 746                     if (!isEliminatedAllocation(candidate))
 747                         break;
 748 
 749                     unsigned numberOfArgumentsToSkip = 0;
 750                     if (candidate-&gt;op() == PhantomCreateRest)
 751                         numberOfArgumentsToSkip = candidate-&gt;numberOfArgumentsToSkip();
 752 
 753                     Node* result = nullptr;
 754                     if (m_graph.varArgChild(node, 1)-&gt;isInt32Constant()) {
 755                         unsigned index = m_graph.varArgChild(node, 1)-&gt;asUInt32();
<a name="15" id="anc15"></a><span class="line-modified"> 756                         InlineCallFrame* inlineCallFrame = candidate-&gt;origin.semantic.inlineCallFrame;</span>
 757                         index += numberOfArgumentsToSkip;
 758 
 759                         bool safeToGetStack = index &gt;= numberOfArgumentsToSkip;
 760                         if (inlineCallFrame)
 761                             safeToGetStack &amp;= index &lt; inlineCallFrame-&gt;argumentCountIncludingThis - 1;
 762                         else {
 763                             safeToGetStack &amp;=
 764                                 index &lt; static_cast&lt;unsigned&gt;(codeBlock()-&gt;numParameters()) - 1;
 765                         }
 766                         if (safeToGetStack) {
 767                             StackAccessData* data;
 768                             VirtualRegister arg = virtualRegisterForArgument(index + 1);
 769                             if (inlineCallFrame)
 770                                 arg += inlineCallFrame-&gt;stackOffset;
 771                             data = m_graph.m_stackAccessData.add(arg, FlushedJSValue);
 772 
 773                             Node* check = nullptr;
 774                             if (!inlineCallFrame || inlineCallFrame-&gt;isVarargs()) {
 775                                 check = insertionSet.insertNode(
 776                                     nodeIndex, SpecNone, CheckInBounds, node-&gt;origin,
 777                                     m_graph.varArgChild(node, 1), Edge(getArrayLength(candidate), Int32Use));
 778                             }
 779 
 780                             result = insertionSet.insertNode(
 781                                 nodeIndex, node-&gt;prediction(), GetStack, node-&gt;origin, OpInfo(data), Edge(check, UntypedUse));
 782                         }
 783                     }
 784 
 785                     if (!result) {
 786                         NodeType op;
 787                         if (node-&gt;arrayMode().isInBounds())
 788                             op = GetMyArgumentByVal;
 789                         else
 790                             op = GetMyArgumentByValOutOfBounds;
 791                         result = insertionSet.insertNode(
 792                             nodeIndex, node-&gt;prediction(), op, node-&gt;origin, OpInfo(numberOfArgumentsToSkip),
 793                             m_graph.varArgChild(node, 0), m_graph.varArgChild(node, 1));
 794                     }
 795 
 796                     // Need to do this because we may have a data format conversion here.
 797                     node-&gt;convertToIdentityOn(result);
 798                     break;
 799                 }
 800 
 801                 case LoadVarargs: {
 802                     Node* candidate = node-&gt;child1().node();
 803                     if (!isEliminatedAllocation(candidate))
 804                         break;
 805 
 806                     // LoadVarargs can exit, so it better be exitOK.
 807                     DFG_ASSERT(m_graph, node, node-&gt;origin.exitOK);
 808                     bool canExit = true;
 809                     LoadVarargsData* varargsData = node-&gt;loadVarargsData();
 810 
 811                     auto storeArgumentCountIncludingThis = [&amp;] (unsigned argumentCountIncludingThis) {
 812                         Node* argumentCountIncludingThisNode = insertionSet.insertConstant(
 813                             nodeIndex, node-&gt;origin.withExitOK(canExit),
 814                             jsNumber(argumentCountIncludingThis));
<a name="16" id="anc16"></a>


 815                         insertionSet.insertNode(
 816                             nodeIndex, SpecNone, MovHint, node-&gt;origin.takeValidExit(canExit),
 817                             OpInfo(varargsData-&gt;count.offset()), Edge(argumentCountIncludingThisNode));
 818                         insertionSet.insertNode(
 819                             nodeIndex, SpecNone, PutStack, node-&gt;origin.withExitOK(canExit),
 820                             OpInfo(m_graph.m_stackAccessData.add(varargsData-&gt;count, FlushedInt32)),
 821                             Edge(argumentCountIncludingThisNode, KnownInt32Use));
 822                     };
 823 
 824                     auto storeValue = [&amp;] (Node* value, unsigned storeIndex) {
 825                         VirtualRegister reg = varargsData-&gt;start + storeIndex;
 826                         StackAccessData* data =
 827                             m_graph.m_stackAccessData.add(reg, FlushedJSValue);
 828 
<a name="17" id="anc17"></a>

 829                         insertionSet.insertNode(
 830                             nodeIndex, SpecNone, MovHint, node-&gt;origin.takeValidExit(canExit),
 831                             OpInfo(reg.offset()), Edge(value));
 832                         insertionSet.insertNode(
 833                             nodeIndex, SpecNone, PutStack, node-&gt;origin.withExitOK(canExit),
 834                             OpInfo(data), Edge(value));
 835                     };
 836 
 837                     if (candidate-&gt;op() == PhantomNewArrayWithSpread || candidate-&gt;op() == PhantomNewArrayBuffer || candidate-&gt;op() == PhantomSpread) {
 838                         auto canConvertToStaticLoadStores = recursableLambda([&amp;] (auto self, Node* candidate) -&gt; bool {
 839                             if (candidate-&gt;op() == PhantomSpread)
 840                                 return self(candidate-&gt;child1().node());
 841 
 842                             if (candidate-&gt;op() == PhantomNewArrayWithSpread) {
 843                                 BitVector* bitVector = candidate-&gt;bitVector();
 844                                 for (unsigned i = 0; i &lt; candidate-&gt;numChildren(); i++) {
 845                                     if (bitVector-&gt;get(i)) {
 846                                         if (!self(m_graph.varArgChild(candidate, i).node()))
 847                                             return false;
 848                                     }
 849                                 }
 850                                 return true;
 851                             }
 852 
 853                             // PhantomNewArrayBuffer only contains constants. It can always convert LoadVarargs to static load stores.
 854                             if (candidate-&gt;op() == PhantomNewArrayBuffer)
 855                                 return true;
 856 
 857                             ASSERT(candidate-&gt;op() == PhantomCreateRest);
<a name="18" id="anc18"></a><span class="line-modified"> 858                             InlineCallFrame* inlineCallFrame = candidate-&gt;origin.semantic.inlineCallFrame;</span>
 859                             return inlineCallFrame &amp;&amp; !inlineCallFrame-&gt;isVarargs();
 860                         });
 861 
 862                         if (canConvertToStaticLoadStores(candidate)) {
 863                             auto countNumberOfArguments = recursableLambda([&amp;](auto self, Node* candidate) -&gt; unsigned {
 864                                 if (candidate-&gt;op() == PhantomSpread)
 865                                     return self(candidate-&gt;child1().node());
 866 
 867                                 if (candidate-&gt;op() == PhantomNewArrayWithSpread) {
 868                                     BitVector* bitVector = candidate-&gt;bitVector();
 869                                     unsigned result = 0;
 870                                     for (unsigned i = 0; i &lt; candidate-&gt;numChildren(); i++) {
 871                                         if (bitVector-&gt;get(i))
 872                                             result += self(m_graph.varArgChild(candidate, i).node());
 873                                         else
 874                                             ++result;
 875                                     }
 876                                     return result;
 877                                 }
 878 
 879                                 if (candidate-&gt;op() == PhantomNewArrayBuffer)
 880                                     return candidate-&gt;castOperand&lt;JSImmutableButterfly*&gt;()-&gt;length();
 881 
 882                                 ASSERT(candidate-&gt;op() == PhantomCreateRest);
 883                                 unsigned numberOfArgumentsToSkip = candidate-&gt;numberOfArgumentsToSkip();
<a name="19" id="anc19"></a><span class="line-modified"> 884                                 InlineCallFrame* inlineCallFrame = candidate-&gt;origin.semantic.inlineCallFrame;</span>
 885                                 unsigned frameArgumentCount = inlineCallFrame-&gt;argumentCountIncludingThis - 1;
 886                                 if (frameArgumentCount &gt;= numberOfArgumentsToSkip)
 887                                     return frameArgumentCount - numberOfArgumentsToSkip;
 888                                 return 0;
 889                             });
 890 
 891                             unsigned argumentCountIncludingThis = 1 + countNumberOfArguments(candidate); // |this|
 892                             if (argumentCountIncludingThis &lt;= varargsData-&gt;limit) {
 893                                 storeArgumentCountIncludingThis(argumentCountIncludingThis);
 894 
 895                                 DFG_ASSERT(m_graph, node, varargsData-&gt;limit - 1 &gt;= varargsData-&gt;mandatoryMinimum, varargsData-&gt;limit, varargsData-&gt;mandatoryMinimum);
 896                                 // Define our limit to exclude &quot;this&quot;, since that&#39;s a bit easier to reason about.
 897                                 unsigned limit = varargsData-&gt;limit - 1;
 898 
 899                                 auto forwardNode = recursableLambda([&amp;](auto self, Node* candidate, unsigned storeIndex) -&gt; unsigned {
 900                                     if (candidate-&gt;op() == PhantomSpread)
 901                                         return self(candidate-&gt;child1().node(), storeIndex);
 902 
 903                                     if (candidate-&gt;op() == PhantomNewArrayWithSpread) {
 904                                         BitVector* bitVector = candidate-&gt;bitVector();
 905                                         for (unsigned i = 0; i &lt; candidate-&gt;numChildren(); i++) {
 906                                             if (bitVector-&gt;get(i))
 907                                                 storeIndex = self(m_graph.varArgChild(candidate, i).node(), storeIndex);
 908                                             else {
 909                                                 Node* value = m_graph.varArgChild(candidate, i).node();
 910                                                 storeValue(value, storeIndex++);
 911                                             }
 912                                         }
 913                                         return storeIndex;
 914                                     }
 915 
 916                                     if (candidate-&gt;op() == PhantomNewArrayBuffer) {
 917                                         auto* array = candidate-&gt;castOperand&lt;JSImmutableButterfly*&gt;();
 918                                         for (unsigned index = 0; index &lt; array-&gt;length(); ++index) {
 919                                             JSValue constant;
 920                                             if (candidate-&gt;indexingType() == ArrayWithDouble)
 921                                                 constant = jsDoubleNumber(array-&gt;get(index).asNumber());
 922                                             else
 923                                                 constant = array-&gt;get(index);
 924                                             Node* value = insertionSet.insertConstant(nodeIndex, node-&gt;origin.withExitOK(canExit), constant);
 925                                             storeValue(value, storeIndex++);
 926                                         }
 927                                         return storeIndex;
 928                                     }
 929 
 930                                     ASSERT(candidate-&gt;op() == PhantomCreateRest);
 931                                     unsigned numberOfArgumentsToSkip = candidate-&gt;numberOfArgumentsToSkip();
<a name="20" id="anc20"></a><span class="line-modified"> 932                                     InlineCallFrame* inlineCallFrame = candidate-&gt;origin.semantic.inlineCallFrame;</span>
 933                                     unsigned frameArgumentCount = inlineCallFrame-&gt;argumentCountIncludingThis - 1;
 934                                     for (unsigned loadIndex = numberOfArgumentsToSkip; loadIndex &lt; frameArgumentCount; ++loadIndex) {
 935                                         VirtualRegister reg = virtualRegisterForArgument(loadIndex + 1) + inlineCallFrame-&gt;stackOffset;
 936                                         StackAccessData* data = m_graph.m_stackAccessData.add(reg, FlushedJSValue);
 937                                         Node* value = insertionSet.insertNode(
 938                                             nodeIndex, SpecNone, GetStack, node-&gt;origin.withExitOK(canExit),
 939                                             OpInfo(data));
 940                                         storeValue(value, storeIndex++);
 941                                     }
 942                                     return storeIndex;
 943                                 });
 944 
 945                                 unsigned storeIndex = forwardNode(candidate, 0);
 946                                 RELEASE_ASSERT(storeIndex &lt;= limit);
 947                                 Node* undefined = nullptr;
 948                                 for (; storeIndex &lt; limit; ++storeIndex) {
 949                                     if (!undefined) {
 950                                         undefined = insertionSet.insertConstant(
 951                                             nodeIndex, node-&gt;origin.withExitOK(canExit), jsUndefined());
 952                                     }
 953                                     storeValue(undefined, storeIndex);
 954                                 }
 955 
 956                                 node-&gt;remove(m_graph);
 957                                 node-&gt;origin.exitOK = canExit;
 958                                 break;
 959                             }
 960                         }
 961                     } else {
 962                         unsigned numberOfArgumentsToSkip = 0;
 963                         if (candidate-&gt;op() == PhantomCreateRest)
 964                             numberOfArgumentsToSkip = candidate-&gt;numberOfArgumentsToSkip();
 965                         varargsData-&gt;offset += numberOfArgumentsToSkip;
 966 
<a name="21" id="anc21"></a><span class="line-modified"> 967                         InlineCallFrame* inlineCallFrame = candidate-&gt;origin.semantic.inlineCallFrame;</span>
 968 
 969                         if (inlineCallFrame
 970                             &amp;&amp; !inlineCallFrame-&gt;isVarargs()) {
 971 
 972                             unsigned argumentCountIncludingThis = inlineCallFrame-&gt;argumentCountIncludingThis;
 973                             if (argumentCountIncludingThis &gt; varargsData-&gt;offset)
 974                                 argumentCountIncludingThis -= varargsData-&gt;offset;
 975                             else
 976                                 argumentCountIncludingThis = 1;
 977                             RELEASE_ASSERT(argumentCountIncludingThis &gt;= 1);
 978 
 979                             if (argumentCountIncludingThis &lt;= varargsData-&gt;limit) {
 980 
 981                                 storeArgumentCountIncludingThis(argumentCountIncludingThis);
 982 
 983                                 DFG_ASSERT(m_graph, node, varargsData-&gt;limit - 1 &gt;= varargsData-&gt;mandatoryMinimum, varargsData-&gt;limit, varargsData-&gt;mandatoryMinimum);
 984                                 // Define our limit to exclude &quot;this&quot;, since that&#39;s a bit easier to reason about.
 985                                 unsigned limit = varargsData-&gt;limit - 1;
 986                                 Node* undefined = nullptr;
 987                                 for (unsigned storeIndex = 0; storeIndex &lt; limit; ++storeIndex) {
 988                                     // First determine if we have an element we can load, and load it if
 989                                     // possible.
 990 
 991                                     Node* value = nullptr;
 992                                     unsigned loadIndex = storeIndex + varargsData-&gt;offset;
 993 
 994                                     if (loadIndex + 1 &lt; inlineCallFrame-&gt;argumentCountIncludingThis) {
 995                                         VirtualRegister reg = virtualRegisterForArgument(loadIndex + 1) + inlineCallFrame-&gt;stackOffset;
 996                                         StackAccessData* data = m_graph.m_stackAccessData.add(
 997                                             reg, FlushedJSValue);
 998 
 999                                         value = insertionSet.insertNode(
1000                                             nodeIndex, SpecNone, GetStack, node-&gt;origin.withExitOK(canExit),
1001                                             OpInfo(data));
1002                                     } else {
1003                                         // FIXME: We shouldn&#39;t have to store anything if
1004                                         // storeIndex &gt;= varargsData-&gt;mandatoryMinimum, but we will still
1005                                         // have GetStacks in that range. So if we don&#39;t do the stores, we&#39;ll
1006                                         // have degenerate IR: we&#39;ll have GetStacks of something that didn&#39;t
1007                                         // have PutStacks.
1008                                         // https://bugs.webkit.org/show_bug.cgi?id=147434
1009 
1010                                         if (!undefined) {
1011                                             undefined = insertionSet.insertConstant(
1012                                                 nodeIndex, node-&gt;origin.withExitOK(canExit), jsUndefined());
1013                                         }
1014                                         value = undefined;
1015                                     }
1016 
1017                                     // Now that we have a value, store it.
1018                                     storeValue(value, storeIndex);
1019                                 }
1020 
1021                                 node-&gt;remove(m_graph);
1022                                 node-&gt;origin.exitOK = canExit;
1023                                 break;
1024                             }
1025                         }
1026                     }
1027 
1028                     node-&gt;setOpAndDefaultFlags(ForwardVarargs);
1029                     break;
1030                 }
1031 
1032                 case CallVarargs:
1033                 case ConstructVarargs:
1034                 case TailCallVarargs:
1035                 case TailCallVarargsInlinedCaller: {
1036                     Node* candidate = node-&gt;child3().node();
1037                     if (!isEliminatedAllocation(candidate))
1038                         break;
1039 
1040                     auto convertToStaticArgumentCountCall = [&amp;] (const Vector&lt;Node*&gt;&amp; arguments) {
1041                         unsigned firstChild = m_graph.m_varArgChildren.size();
1042                         m_graph.m_varArgChildren.append(node-&gt;child1());
1043                         m_graph.m_varArgChildren.append(node-&gt;child2());
1044                         for (Node* argument : arguments)
1045                             m_graph.m_varArgChildren.append(Edge(argument));
1046                         switch (node-&gt;op()) {
1047                         case CallVarargs:
1048                             node-&gt;setOpAndDefaultFlags(Call);
1049                             break;
1050                         case ConstructVarargs:
1051                             node-&gt;setOpAndDefaultFlags(Construct);
1052                             break;
1053                         case TailCallVarargs:
1054                             node-&gt;setOpAndDefaultFlags(TailCall);
1055                             break;
1056                         case TailCallVarargsInlinedCaller:
1057                             node-&gt;setOpAndDefaultFlags(TailCallInlinedCaller);
1058                             break;
1059                         default:
1060                             RELEASE_ASSERT_NOT_REACHED();
1061                         }
1062                         node-&gt;children = AdjacencyList(
1063                             AdjacencyList::Variable,
1064                             firstChild, m_graph.m_varArgChildren.size() - firstChild);
1065                     };
1066 
1067                     auto convertToForwardsCall = [&amp;] () {
1068                         switch (node-&gt;op()) {
1069                         case CallVarargs:
1070                             node-&gt;setOpAndDefaultFlags(CallForwardVarargs);
1071                             break;
1072                         case ConstructVarargs:
1073                             node-&gt;setOpAndDefaultFlags(ConstructForwardVarargs);
1074                             break;
1075                         case TailCallVarargs:
1076                             node-&gt;setOpAndDefaultFlags(TailCallForwardVarargs);
1077                             break;
1078                         case TailCallVarargsInlinedCaller:
1079                             node-&gt;setOpAndDefaultFlags(TailCallForwardVarargsInlinedCaller);
1080                             break;
1081                         default:
1082                             RELEASE_ASSERT_NOT_REACHED();
1083                         }
1084                     };
1085 
1086                     if (candidate-&gt;op() == PhantomNewArrayWithSpread || candidate-&gt;op() == PhantomNewArrayBuffer || candidate-&gt;op() == PhantomSpread) {
1087                         auto canTransformToStaticArgumentCountCall = recursableLambda([&amp;](auto self, Node* candidate) -&gt; bool {
1088                             if (candidate-&gt;op() == PhantomSpread)
1089                                 return self(candidate-&gt;child1().node());
1090 
1091                             if (candidate-&gt;op() == PhantomNewArrayWithSpread) {
1092                                 BitVector* bitVector = candidate-&gt;bitVector();
1093                                 for (unsigned i = 0; i &lt; candidate-&gt;numChildren(); i++) {
1094                                     if (bitVector-&gt;get(i)) {
1095                                         Node* spread = m_graph.varArgChild(candidate, i).node();
1096                                         if (!self(spread))
1097                                             return false;
1098                                     }
1099                                 }
1100                                 return true;
1101                             }
1102 
1103                             // PhantomNewArrayBuffer only contains constants. It can always convert LoadVarargs to static load stores.
1104                             if (candidate-&gt;op() == PhantomNewArrayBuffer)
1105                                 return true;
1106 
1107                             ASSERT(candidate-&gt;op() == PhantomCreateRest);
<a name="22" id="anc22"></a><span class="line-modified">1108                             InlineCallFrame* inlineCallFrame = candidate-&gt;origin.semantic.inlineCallFrame;</span>
1109                             return inlineCallFrame &amp;&amp; !inlineCallFrame-&gt;isVarargs();
1110                         });
1111 
1112                         if (canTransformToStaticArgumentCountCall(candidate)) {
1113                             Vector&lt;Node*&gt; arguments;
1114                             auto appendNode = recursableLambda([&amp;](auto self, Node* candidate) -&gt; void {
1115                                 if (candidate-&gt;op() == PhantomSpread) {
1116                                     self(candidate-&gt;child1().node());
1117                                     return;
1118                                 }
1119 
1120                                 if (candidate-&gt;op() == PhantomNewArrayWithSpread) {
1121                                     BitVector* bitVector = candidate-&gt;bitVector();
1122                                     for (unsigned i = 0; i &lt; candidate-&gt;numChildren(); i++) {
1123                                         Node* child = m_graph.varArgChild(candidate, i).node();
1124                                         if (bitVector-&gt;get(i))
1125                                             self(child);
1126                                         else
1127                                             arguments.append(child);
1128                                     }
1129                                     return;
1130                                 }
1131 
1132                                 if (candidate-&gt;op() == PhantomNewArrayBuffer) {
1133                                     bool canExit = true;
1134                                     auto* array = candidate-&gt;castOperand&lt;JSImmutableButterfly*&gt;();
1135                                     for (unsigned index = 0; index &lt; array-&gt;length(); ++index) {
1136                                         JSValue constant;
1137                                         if (candidate-&gt;indexingType() == ArrayWithDouble)
1138                                             constant = jsDoubleNumber(array-&gt;get(index).asNumber());
1139                                         else
1140                                             constant = array-&gt;get(index);
1141                                         arguments.append(insertionSet.insertConstant(nodeIndex, node-&gt;origin.withExitOK(canExit), constant));
1142                                     }
1143                                     return;
1144                                 }
1145 
1146                                 ASSERT(candidate-&gt;op() == PhantomCreateRest);
<a name="23" id="anc23"></a><span class="line-modified">1147                                 InlineCallFrame* inlineCallFrame = candidate-&gt;origin.semantic.inlineCallFrame;</span>
1148                                 unsigned numberOfArgumentsToSkip = candidate-&gt;numberOfArgumentsToSkip();
1149                                 for (unsigned i = 1 + numberOfArgumentsToSkip; i &lt; inlineCallFrame-&gt;argumentCountIncludingThis; ++i) {
1150                                     StackAccessData* data = m_graph.m_stackAccessData.add(
1151                                         virtualRegisterForArgument(i) + inlineCallFrame-&gt;stackOffset,
1152                                         FlushedJSValue);
1153 
1154                                     Node* value = insertionSet.insertNode(
1155                                         nodeIndex, SpecNone, GetStack, node-&gt;origin, OpInfo(data));
1156 
1157                                     arguments.append(value);
1158                                 }
1159                             });
1160 
1161                             appendNode(candidate);
1162                             convertToStaticArgumentCountCall(arguments);
1163                         } else
1164                             convertToForwardsCall();
1165                     } else {
1166                         unsigned numberOfArgumentsToSkip = 0;
1167                         if (candidate-&gt;op() == PhantomCreateRest)
1168                             numberOfArgumentsToSkip = candidate-&gt;numberOfArgumentsToSkip();
1169                         CallVarargsData* varargsData = node-&gt;callVarargsData();
1170                         varargsData-&gt;firstVarArgOffset += numberOfArgumentsToSkip;
1171 
<a name="24" id="anc24"></a><span class="line-modified">1172                         InlineCallFrame* inlineCallFrame = candidate-&gt;origin.semantic.inlineCallFrame;</span>
1173                         if (inlineCallFrame &amp;&amp; !inlineCallFrame-&gt;isVarargs()) {
1174                             Vector&lt;Node*&gt; arguments;
1175                             for (unsigned i = 1 + varargsData-&gt;firstVarArgOffset; i &lt; inlineCallFrame-&gt;argumentCountIncludingThis; ++i) {
1176                                 StackAccessData* data = m_graph.m_stackAccessData.add(
1177                                     virtualRegisterForArgument(i) + inlineCallFrame-&gt;stackOffset,
1178                                     FlushedJSValue);
1179 
1180                                 Node* value = insertionSet.insertNode(
1181                                     nodeIndex, SpecNone, GetStack, node-&gt;origin, OpInfo(data));
1182 
1183                                 arguments.append(value);
1184                             }
1185 
1186                             convertToStaticArgumentCountCall(arguments);
1187                         } else
1188                             convertToForwardsCall();
1189                     }
1190 
1191                     break;
1192                 }
1193 
1194                 case CheckArray:
1195                 case GetButterfly:
1196                 case FilterGetByIdStatus:
1197                 case FilterPutByIdStatus:
1198                 case FilterCallLinkStatus:
1199                 case FilterInByIdStatus: {
1200                     if (!isEliminatedAllocation(node-&gt;child1().node()))
1201                         break;
1202                     node-&gt;remove(m_graph);
1203                     break;
1204                 }
1205 
1206                 case CheckStructureOrEmpty:
1207                 case CheckStructure:
1208                     if (!isEliminatedAllocation(node-&gt;child1().node()))
1209                         break;
1210                     node-&gt;child1() = Edge(); // Remove the cell check since we&#39;ve proven it&#39;s not needed and FTL lowering might botch this.
1211                     node-&gt;remove(m_graph);
1212                     break;
1213 
1214                 default:
1215                     break;
1216                 }
1217 
1218                 if (node-&gt;isPseudoTerminal()) {
1219                     pseudoTerminal = node;
1220                     break;
1221                 }
1222             }
1223 
1224             insertionSet.execute(block);
1225 
1226             if (pseudoTerminal) {
1227                 for (unsigned i = 0; i &lt; block-&gt;size(); ++i) {
1228                     Node* node = block-&gt;at(i);
1229                     if (node != pseudoTerminal)
1230                         continue;
1231                     block-&gt;resize(i + 1);
1232                     block-&gt;append(m_graph.addNode(SpecNone, Unreachable, node-&gt;origin));
1233                     modifiedCFG = true;
1234                     break;
1235                 }
1236             }
1237         }
1238 
1239         if (modifiedCFG) {
1240             m_graph.invalidateCFG();
1241             m_graph.resetReachability();
1242             m_graph.killUnreachableBlocks();
1243         }
1244     }
1245 
1246     HashSet&lt;Node*&gt; m_candidates;
1247 };
1248 
1249 } // anonymous namespace
1250 
1251 bool performArgumentsElimination(Graph&amp; graph)
1252 {
1253     return runPhase&lt;ArgumentsEliminationPhase&gt;(graph);
1254 }
1255 
1256 } } // namespace JSC::DFG
1257 
1258 #endif // ENABLE(DFG_JIT)
1259 
<a name="25" id="anc25"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="25" type="hidden" />
</body>
</html>