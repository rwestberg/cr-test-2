<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/inspector/InspectorCanvas.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="InspectorAuditDOMObject.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="InspectorCanvas.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/inspector/InspectorCanvas.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 40 #include &quot;HTMLVideoElement.h&quot;
 41 #include &quot;Image.h&quot;
 42 #include &quot;ImageBitmap.h&quot;
 43 #include &quot;ImageBitmapRenderingContext.h&quot;
 44 #include &quot;ImageBuffer.h&quot;
 45 #include &quot;ImageData.h&quot;
 46 #include &quot;InspectorDOMAgent.h&quot;
 47 #include &quot;JSCanvasDirection.h&quot;
 48 #include &quot;JSCanvasFillRule.h&quot;
 49 #include &quot;JSCanvasLineCap.h&quot;
 50 #include &quot;JSCanvasLineJoin.h&quot;
 51 #include &quot;JSCanvasTextAlign.h&quot;
 52 #include &quot;JSCanvasTextBaseline.h&quot;
 53 #include &quot;JSExecState.h&quot;
 54 #include &quot;JSImageSmoothingQuality.h&quot;
 55 #include &quot;Path2D.h&quot;
 56 #include &quot;Pattern.h&quot;
 57 #include &quot;RecordingSwizzleTypes.h&quot;
 58 #include &quot;SVGPathUtilities.h&quot;
 59 #include &quot;StringAdaptors.h&quot;



 60 #if ENABLE(WEBGL)
 61 #include &quot;WebGLRenderingContext.h&quot;
 62 #endif
 63 #if ENABLE(WEBGL2)
 64 #include &quot;WebGL2RenderingContext.h&quot;
 65 #endif
<span class="line-modified"> 66 #if ENABLE(WEBMETAL)</span>
<span class="line-modified"> 67 #include &quot;WebMetalRenderingContext.h&quot;</span>
 68 #endif
 69 #include &lt;JavaScriptCore/IdentifiersFactory.h&gt;
 70 #include &lt;JavaScriptCore/ScriptCallStackFactory.h&gt;

 71 
 72 namespace WebCore {
 73 
 74 using namespace Inspector;
 75 
 76 Ref&lt;InspectorCanvas&gt; InspectorCanvas::create(CanvasRenderingContext&amp; context)
 77 {
 78     return adoptRef(*new InspectorCanvas(context));
 79 }
 80 
 81 InspectorCanvas::InspectorCanvas(CanvasRenderingContext&amp; context)
 82     : m_identifier(&quot;canvas:&quot; + IdentifiersFactory::createIdentifier())
 83     , m_context(context)
 84 {
 85 }
 86 
 87 HTMLCanvasElement* InspectorCanvas::canvasElement()
 88 {
<span class="line-modified"> 89     auto* canvasBase = &amp;m_context.canvasBase();</span>
<span class="line-modified"> 90     if (is&lt;HTMLCanvasElement&gt;(canvasBase))</span>
<span class="line-removed"> 91         return downcast&lt;HTMLCanvasElement&gt;(canvasBase);</span>
 92     return nullptr;
 93 }
 94 












 95 void InspectorCanvas::resetRecordingData()
 96 {
 97     m_initialState = nullptr;
 98     m_frames = nullptr;
 99     m_currentActions = nullptr;
<span class="line-removed">100     m_actionNeedingSnapshot = nullptr;</span>
101     m_serializedDuplicateData = nullptr;
102     m_indexedDuplicateData.clear();
103     m_recordingName = { };
104     m_bufferLimit = 100 * 1024 * 1024;
105     m_bufferUsed = 0;
106     m_frameCount = WTF::nullopt;
107     m_framesCaptured = 0;

108 
109     m_context.setCallTracingActive(false);
110 }
111 
112 bool InspectorCanvas::hasRecordingData() const
113 {
114     return m_bufferUsed &gt; 0;
115 }
116 
117 bool InspectorCanvas::currentFrameHasData() const
118 {
119     return !!m_frames;
120 }
121 
122 static bool shouldSnapshotBitmapRendererAction(const String&amp; name)
123 {
124     return name == &quot;transferFromImageBitmap&quot;;
125 }
126 

127 static bool shouldSnapshotWebGLAction(const String&amp; name)
128 {
129     return name == &quot;clear&quot;
130         || name == &quot;drawArrays&quot;
131         || name == &quot;drawElements&quot;;
132 }

133 
<span class="line-modified">134 void InspectorCanvas::recordAction(const String&amp; name, Vector&lt;RecordCanvasActionVariant&gt;&amp;&amp; parameters)</span>











135 {
136     if (!m_initialState) {



137         m_initialState = buildInitialState();
138         m_bufferUsed += m_initialState-&gt;memoryCost();
139     }
140 
141     if (!m_frames)
142         m_frames = JSON::ArrayOf&lt;Inspector::Protocol::Recording::Frame&gt;::create();
143 
144     if (!m_currentActions) {
145         m_currentActions = JSON::ArrayOf&lt;JSON::Value&gt;::create();
146 
147         auto frame = Inspector::Protocol::Recording::Frame::create()
148             .setActions(m_currentActions)
149             .release();
150 
151         m_frames-&gt;addItem(WTFMove(frame));
152         ++m_framesCaptured;
153 
154         m_currentFrameStartTime = MonotonicTime::now();
155     }
156 
157     appendActionSnapshotIfNeeded();
158 
<span class="line-modified">159     auto action = buildAction(name, WTFMove(parameters));</span>
<span class="line-modified">160     m_bufferUsed += action-&gt;memoryCost();</span>
<span class="line-modified">161     m_currentActions-&gt;addItem(action.ptr());</span>
162 
163     if (is&lt;ImageBitmapRenderingContext&gt;(m_context) &amp;&amp; shouldSnapshotBitmapRendererAction(name))
<span class="line-modified">164         m_actionNeedingSnapshot = WTFMove(action);</span>
165 #if ENABLE(WEBGL)
166     else if (is&lt;WebGLRenderingContext&gt;(m_context) &amp;&amp; shouldSnapshotWebGLAction(name))
<span class="line-modified">167         m_actionNeedingSnapshot = WTFMove(action);</span>




168 #endif
169 }
170 
<span class="line-modified">171 RefPtr&lt;Inspector::Protocol::Recording::InitialState&gt;&amp;&amp; InspectorCanvas::releaseInitialState()</span>
<span class="line-removed">172 {</span>
<span class="line-removed">173     return WTFMove(m_initialState);</span>
<span class="line-removed">174 }</span>
<span class="line-removed">175 </span>
<span class="line-removed">176 RefPtr&lt;JSON::ArrayOf&lt;Inspector::Protocol::Recording::Frame&gt;&gt;&amp;&amp; InspectorCanvas::releaseFrames()</span>
177 {
178     appendActionSnapshotIfNeeded();
179 
<span class="line-removed">180     return WTFMove(m_frames);</span>
<span class="line-removed">181 }</span>
<span class="line-removed">182 </span>
<span class="line-removed">183 RefPtr&lt;JSON::ArrayOf&lt;JSON::Value&gt;&gt;&amp;&amp; InspectorCanvas::releaseData()</span>
<span class="line-removed">184 {</span>
<span class="line-removed">185     m_indexedDuplicateData.clear();</span>
<span class="line-removed">186     return WTFMove(m_serializedDuplicateData);</span>
<span class="line-removed">187 }</span>
<span class="line-removed">188 </span>
<span class="line-removed">189 void InspectorCanvas::finalizeFrame()</span>
<span class="line-removed">190 {</span>
191     if (m_frames &amp;&amp; m_frames-&gt;length() &amp;&amp; !std::isnan(m_currentFrameStartTime)) {
192         auto currentFrame = static_cast&lt;Inspector::Protocol::Recording::Frame*&gt;(m_frames-&gt;get(m_frames-&gt;length() - 1).get());
193         currentFrame-&gt;setDuration((MonotonicTime::now() - m_currentFrameStartTime).milliseconds());
194 
195         m_currentFrameStartTime = MonotonicTime::nan();
196     }
197 
198     m_currentActions = nullptr;
199 }
200 
201 void InspectorCanvas::markCurrentFrameIncomplete()
202 {
203     if (!m_currentActions || !m_frames || !m_frames-&gt;length())
204         return;
205 
206     static_cast&lt;Inspector::Protocol::Recording::Frame*&gt;(m_frames-&gt;get(m_frames-&gt;length() - 1).get())-&gt;setIncomplete(true);
207 }
208 
209 void InspectorCanvas::setBufferLimit(long memoryLimit)
210 {
</pre>
<hr />
<pre>
227 bool InspectorCanvas::overFrameCount() const
228 {
229     return m_frameCount &amp;&amp; m_framesCaptured &gt;= m_frameCount.value();
230 }
231 
232 Ref&lt;Inspector::Protocol::Canvas::Canvas&gt; InspectorCanvas::buildObjectForCanvas(bool captureBacktrace)
233 {
234     Inspector::Protocol::Canvas::ContextType contextType;
235     if (is&lt;CanvasRenderingContext2D&gt;(m_context))
236         contextType = Inspector::Protocol::Canvas::ContextType::Canvas2D;
237     else if (is&lt;ImageBitmapRenderingContext&gt;(m_context))
238         contextType = Inspector::Protocol::Canvas::ContextType::BitmapRenderer;
239 #if ENABLE(WEBGL)
240     else if (is&lt;WebGLRenderingContext&gt;(m_context))
241         contextType = Inspector::Protocol::Canvas::ContextType::WebGL;
242 #endif
243 #if ENABLE(WEBGL2)
244     else if (is&lt;WebGL2RenderingContext&gt;(m_context))
245         contextType = Inspector::Protocol::Canvas::ContextType::WebGL2;
246 #endif
<span class="line-modified">247 #if ENABLE(WEBMETAL)</span>
<span class="line-modified">248     else if (is&lt;WebMetalRenderingContext&gt;(m_context))</span>
<span class="line-modified">249         contextType = Inspector::Protocol::Canvas::ContextType::WebMetal;</span>
250 #endif
251     else {
252         ASSERT_NOT_REACHED();
253         contextType = Inspector::Protocol::Canvas::ContextType::Canvas2D;
254     }
255 
256     auto canvas = Inspector::Protocol::Canvas::Canvas::create()
257         .setCanvasId(m_identifier)
258         .setContextType(contextType)
259         .release();
260 
261     if (auto* node = canvasElement()) {
262         String cssCanvasName = node-&gt;document().nameForCSSCanvasElement(*node);
263         if (!cssCanvasName.isEmpty())
264             canvas-&gt;setCssCanvasName(cssCanvasName);
265 
266         // FIXME: &lt;https://webkit.org/b/178282&gt; Web Inspector: send a DOM node with each Canvas payload and eliminate Canvas.requestNode
267     }
268 
269     if (is&lt;ImageBitmapRenderingContext&gt;(m_context)) {
</pre>
<hr />
<pre>
287             canvas-&gt;setContextAttributes(WTFMove(contextAttributes));
288         }
289     }
290 #endif
291 
292     // FIXME: &lt;https://webkit.org/b/180833&gt; Web Inspector: support OffscreenCanvas for Canvas related operations
293 
294     if (auto* node = canvasElement()) {
295         if (size_t memoryCost = node-&gt;memoryCost())
296             canvas-&gt;setMemoryCost(memoryCost);
297     }
298 
299     if (captureBacktrace) {
300         auto stackTrace = Inspector::createScriptCallStack(JSExecState::currentState(), Inspector::ScriptCallStack::maxCallStackSizeToCapture);
301         canvas-&gt;setBacktrace(stackTrace-&gt;buildInspectorArray());
302     }
303 
304     return canvas;
305 }
306 
<span class="line-modified">307 void InspectorCanvas::appendActionSnapshotIfNeeded()</span>
308 {
<span class="line-modified">309     if (!m_actionNeedingSnapshot)</span>
<span class="line-modified">310         return;</span>





























311 
<span class="line-modified">312     m_actionNeedingSnapshot-&gt;addItem(indexForData(getCanvasContentAsDataURL()));</span>
<span class="line-modified">313     m_actionNeedingSnapshot = nullptr;</span>

314 }
315 
<span class="line-modified">316 String InspectorCanvas::getCanvasContentAsDataURL()</span>
317 {
<span class="line-modified">318     // FIXME: &lt;https://webkit.org/b/180833&gt; Web Inspector: support OffscreenCanvas for Canvas related operations</span>








319 

320     auto* node = canvasElement();
<span class="line-modified">321     if (!node)</span>
<span class="line-modified">322         return String();</span>


323 
324 #if ENABLE(WEBGL)
325     if (is&lt;WebGLRenderingContextBase&gt;(m_context))
326         downcast&lt;WebGLRenderingContextBase&gt;(m_context).setPreventBufferClearForInspector(true);
327 #endif
328 
329     ExceptionOr&lt;UncachedString&gt; result = node-&gt;toDataURL(&quot;image/png&quot;_s);
330 
331 #if ENABLE(WEBGL)
332     if (is&lt;WebGLRenderingContextBase&gt;(m_context))
333         downcast&lt;WebGLRenderingContextBase&gt;(m_context).setPreventBufferClearForInspector(false);
334 #endif
335 
<span class="line-modified">336     if (result.hasException())</span>
<span class="line-modified">337         return String();</span>


338 
339     return result.releaseReturnValue().string;
340 }
341 


















342 int InspectorCanvas::indexForData(DuplicateDataVariant data)
343 {
344     size_t index = m_indexedDuplicateData.findMatching([&amp;] (auto item) {
345         if (data == item)
346             return true;
347 
348         auto traceA = WTF::get_if&lt;RefPtr&lt;ScriptCallStack&gt;&gt;(data);
349         auto traceB = WTF::get_if&lt;RefPtr&lt;ScriptCallStack&gt;&gt;(item);
350         if (traceA &amp;&amp; *traceA &amp;&amp; traceB &amp;&amp; *traceB)
351             return (*traceA)-&gt;isEqual((*traceB).get());
352 
353         return false;
354     });
355     if (index != notFound) {
<span class="line-modified">356         ASSERT(index &lt; std::numeric_limits&lt;int&gt;::max());</span>
357         return static_cast&lt;int&gt;(index);
358     }
359 
360     if (!m_serializedDuplicateData)
361         m_serializedDuplicateData = JSON::ArrayOf&lt;JSON::Value&gt;::create();
362 
363     RefPtr&lt;JSON::Value&gt; item;
364     WTF::switchOn(data,
365         [&amp;] (const RefPtr&lt;HTMLImageElement&gt;&amp; imageElement) {
366             String dataURL = &quot;data:,&quot;_s;
367 
368             if (CachedImage* cachedImage = imageElement-&gt;cachedImage()) {
369                 Image* image = cachedImage-&gt;image();
370                 if (image &amp;&amp; image != &amp;Image::nullImage()) {
371                     std::unique_ptr&lt;ImageBuffer&gt; imageBuffer = ImageBuffer::create(image-&gt;size(), RenderingMode::Unaccelerated);
372                     imageBuffer-&gt;context().drawImage(*image, FloatPoint(0, 0));
373                     dataURL = imageBuffer-&gt;toDataURL(&quot;image/png&quot;);
374                 }
375             }
376 
</pre>
<hr />
<pre>
395             String dataURL = &quot;data:,&quot;_s;
396 
397             ExceptionOr&lt;UncachedString&gt; result = canvasElement-&gt;toDataURL(&quot;image/png&quot;_s);
398             if (!result.hasException())
399                 dataURL = result.releaseReturnValue().string;
400 
401             index = indexForData(dataURL);
402         },
403         [&amp;] (const RefPtr&lt;CanvasGradient&gt;&amp; canvasGradient) { item = buildArrayForCanvasGradient(*canvasGradient); },
404         [&amp;] (const RefPtr&lt;CanvasPattern&gt;&amp; canvasPattern) { item = buildArrayForCanvasPattern(*canvasPattern); },
405         [&amp;] (const RefPtr&lt;ImageData&gt;&amp; imageData) { item = buildArrayForImageData(*imageData); },
406         [&amp;] (RefPtr&lt;ImageBitmap&gt;&amp; imageBitmap) {
407             index = indexForData(imageBitmap-&gt;buffer()-&gt;toDataURL(&quot;image/png&quot;));
408         },
409         [&amp;] (const RefPtr&lt;ScriptCallStack&gt;&amp; scriptCallStack) {
410             auto array = JSON::ArrayOf&lt;double&gt;::create();
411             for (size_t i = 0; i &lt; scriptCallStack-&gt;size(); ++i)
412                 array-&gt;addItem(indexForData(scriptCallStack-&gt;at(i)));
413             item = WTFMove(array);
414         },
















415         [&amp;] (const ScriptCallFrame&amp; scriptCallFrame) {
416             auto array = JSON::ArrayOf&lt;double&gt;::create();
417             array-&gt;addItem(indexForData(scriptCallFrame.functionName()));
418             array-&gt;addItem(indexForData(scriptCallFrame.sourceURL()));
419             array-&gt;addItem(static_cast&lt;int&gt;(scriptCallFrame.lineNumber()));
420             array-&gt;addItem(static_cast&lt;int&gt;(scriptCallFrame.columnNumber()));
421             item = WTFMove(array);
422         },
423         [&amp;] (const String&amp; value) { item = JSON::Value::create(value); }
424     );
425 
426     if (item) {
427         m_bufferUsed += item-&gt;memoryCost();
428         m_serializedDuplicateData-&gt;addItem(WTFMove(item));
429 
430         m_indexedDuplicateData.append(data);
431         index = m_indexedDuplicateData.size() - 1;
432     }
433 
<span class="line-modified">434     ASSERT(index &lt; std::numeric_limits&lt;int&gt;::max());</span>
435     return static_cast&lt;int&gt;(index);
436 }
437 
438 String InspectorCanvas::stringIndexForKey(const String&amp; key)
439 {
440     return String::number(indexForData(key));
441 }
442 
443 static Ref&lt;JSON::ArrayOf&lt;double&gt;&gt; buildArrayForAffineTransform(const AffineTransform&amp; affineTransform)
444 {
445     auto array = JSON::ArrayOf&lt;double&gt;::create();
446     array-&gt;addItem(affineTransform.a());
447     array-&gt;addItem(affineTransform.b());
448     array-&gt;addItem(affineTransform.c());
449     array-&gt;addItem(affineTransform.d());
450     array-&gt;addItem(affineTransform.e());
451     array-&gt;addItem(affineTransform.f());
452     return array;
453 }
454 
</pre>
<hr />
<pre>
537             webGLContextAttributesPayload-&gt;setBoolean(&quot;alpha&quot;_s, webGLContextAttributes-&gt;alpha);
538             webGLContextAttributesPayload-&gt;setBoolean(&quot;depth&quot;_s, webGLContextAttributes-&gt;depth);
539             webGLContextAttributesPayload-&gt;setBoolean(&quot;stencil&quot;_s, webGLContextAttributes-&gt;stencil);
540             webGLContextAttributesPayload-&gt;setBoolean(&quot;antialias&quot;_s, webGLContextAttributes-&gt;antialias);
541             webGLContextAttributesPayload-&gt;setBoolean(&quot;premultipliedAlpha&quot;_s, webGLContextAttributes-&gt;premultipliedAlpha);
542             webGLContextAttributesPayload-&gt;setBoolean(&quot;preserveDrawingBuffer&quot;_s, webGLContextAttributes-&gt;preserveDrawingBuffer);
543             webGLContextAttributesPayload-&gt;setBoolean(&quot;failIfMajorPerformanceCaveat&quot;_s, webGLContextAttributes-&gt;failIfMajorPerformanceCaveat);
544             parametersPayload-&gt;addItem(WTFMove(webGLContextAttributesPayload));
545         }
546     }
547 #endif
548 
549     initialStatePayload-&gt;setAttributes(WTFMove(attributesPayload));
550 
551     if (statesPayload-&gt;length())
552         initialStatePayload-&gt;setStates(WTFMove(statesPayload));
553 
554     if (parametersPayload-&gt;length())
555         initialStatePayload-&gt;setParameters(WTFMove(parametersPayload));
556 
<span class="line-modified">557     initialStatePayload-&gt;setContent(getCanvasContentAsDataURL());</span>

558 
559     return initialStatePayload;
560 }
561 
<span class="line-modified">562 Ref&lt;JSON::ArrayOf&lt;JSON::Value&gt;&gt; InspectorCanvas::buildAction(const String&amp; name, Vector&lt;RecordCanvasActionVariant&gt;&amp;&amp; parameters)</span>
563 {
564     auto action = JSON::ArrayOf&lt;JSON::Value&gt;::create();
565     action-&gt;addItem(indexForData(name));
566 
567     auto parametersData = JSON::ArrayOf&lt;JSON::Value&gt;::create();
568     auto swizzleTypes = JSON::ArrayOf&lt;int&gt;::create();
569 
570     auto addParameter = [&amp;parametersData, &amp;swizzleTypes] (auto value, RecordingSwizzleTypes swizzleType) {
571         parametersData-&gt;addItem(value);
572         swizzleTypes-&gt;addItem(static_cast&lt;int&gt;(swizzleType));
573     };
574 
<span class="line-modified">575     for (auto&amp; item : parameters) {</span>
<span class="line-modified">576         WTF::switchOn(item,</span>


577             [&amp;] (CanvasDirection value) { addParameter(indexForData(convertEnumerationToString(value)), RecordingSwizzleTypes::String); },
578             [&amp;] (CanvasFillRule value) { addParameter(indexForData(convertEnumerationToString(value)), RecordingSwizzleTypes::String); },
579             [&amp;] (CanvasLineCap value) { addParameter(indexForData(convertEnumerationToString(value)), RecordingSwizzleTypes::String); },
580             [&amp;] (CanvasLineJoin value) { addParameter(indexForData(convertEnumerationToString(value)), RecordingSwizzleTypes::String); },
581             [&amp;] (CanvasTextAlign value) { addParameter(indexForData(convertEnumerationToString(value)), RecordingSwizzleTypes::String); },
582             [&amp;] (CanvasTextBaseline value) { addParameter(indexForData(convertEnumerationToString(value)), RecordingSwizzleTypes::String); },

583             [&amp;] (const DOMMatrix2DInit&amp; value) {
584                 auto array = JSON::ArrayOf&lt;double&gt;::create();
585                 array-&gt;addItem(value.a.valueOr(1));
586                 array-&gt;addItem(value.b.valueOr(0));
587                 array-&gt;addItem(value.c.valueOr(0));
588                 array-&gt;addItem(value.d.valueOr(1));
589                 array-&gt;addItem(value.e.valueOr(0));
590                 array-&gt;addItem(value.f.valueOr(0));
591                 addParameter(array.ptr(), RecordingSwizzleTypes::DOMMatrix);
592             },
<span class="line-modified">593             [&amp;] (const Element*) {</span>
<span class="line-modified">594                 // Elements are not serializable, so add a string as a placeholder since the actual</span>
<span class="line-modified">595                 // element cannot be reconstructed in the frontend.</span>
<span class="line-modified">596                 addParameter(indexForData(&quot;Element&quot;), RecordingSwizzleTypes::None);</span>


597             },
<span class="line-modified">598             [&amp;] (HTMLImageElement* value) { addParameter(indexForData(value), RecordingSwizzleTypes::Image); },</span>
<span class="line-modified">599             [&amp;] (ImageBitmap* value) { addParameter(indexForData(value), RecordingSwizzleTypes::ImageBitmap); },</span>
<span class="line-modified">600             [&amp;] (ImageData* value) { addParameter(indexForData(value), RecordingSwizzleTypes::ImageData); },</span>
<span class="line-modified">601             [&amp;] (ImageSmoothingQuality value) { addParameter(indexForData(convertEnumerationToString(value)), RecordingSwizzleTypes::String); },</span>
<span class="line-modified">602             [&amp;] (const Path2D* value) { addParameter(indexForData(buildStringFromPath(value-&gt;path())), RecordingSwizzleTypes::Path2D); },</span>







603 #if ENABLE(WEBGL)
604             // FIXME: &lt;https://webkit.org/b/176009&gt; Web Inspector: send data for WebGL objects during a recording instead of a placeholder string
<span class="line-modified">605             [&amp;] (const WebGLBuffer*) { addParameter(0, RecordingSwizzleTypes::WebGLBuffer); },</span>
<span class="line-modified">606             [&amp;] (const WebGLFramebuffer*) { addParameter(0, RecordingSwizzleTypes::WebGLFramebuffer); },</span>
<span class="line-modified">607             [&amp;] (const WebGLProgram*) { addParameter(0, RecordingSwizzleTypes::WebGLProgram); },</span>
<span class="line-modified">608             [&amp;] (const WebGLRenderbuffer*) { addParameter(0, RecordingSwizzleTypes::WebGLRenderbuffer); },</span>
<span class="line-modified">609             [&amp;] (const WebGLShader*) { addParameter(0, RecordingSwizzleTypes::WebGLShader); },</span>
<span class="line-modified">610             [&amp;] (const WebGLTexture*) { addParameter(0, RecordingSwizzleTypes::WebGLTexture); },</span>
<span class="line-modified">611             [&amp;] (const WebGLUniformLocation*) { addParameter(0, RecordingSwizzleTypes::WebGLUniformLocation); },</span>









































612 #endif
<span class="line-modified">613             [&amp;] (const RefPtr&lt;ArrayBuffer&gt;&amp;) { addParameter(0, RecordingSwizzleTypes::TypedArray); },</span>
<span class="line-modified">614             [&amp;] (const RefPtr&lt;ArrayBufferView&gt;&amp;) { addParameter(0, RecordingSwizzleTypes::TypedArray); },</span>
<span class="line-modified">615             [&amp;] (const RefPtr&lt;CanvasGradient&gt;&amp; value) { addParameter(indexForData(value), RecordingSwizzleTypes::CanvasGradient); },</span>
<span class="line-modified">616             [&amp;] (const RefPtr&lt;CanvasPattern&gt;&amp; value) { addParameter(indexForData(value), RecordingSwizzleTypes::CanvasPattern); },</span>
<span class="line-modified">617             [&amp;] (const RefPtr&lt;Float32Array&gt;&amp;) { addParameter(0, RecordingSwizzleTypes::TypedArray); },</span>
<span class="line-modified">618             [&amp;] (const RefPtr&lt;HTMLCanvasElement&gt;&amp; value) { addParameter(indexForData(value), RecordingSwizzleTypes::Image); },</span>
<span class="line-modified">619             [&amp;] (const RefPtr&lt;HTMLImageElement&gt;&amp; value) { addParameter(indexForData(value), RecordingSwizzleTypes::Image); },</span>





















620 #if ENABLE(VIDEO)
<span class="line-modified">621             [&amp;] (const RefPtr&lt;HTMLVideoElement&gt;&amp; value) { addParameter(indexForData(value), RecordingSwizzleTypes::Image); },</span>



622 #endif
623 #if ENABLE(CSS_TYPED_OM)
<span class="line-modified">624             // FIXME implement: &lt;https://bugs.webkit.org/show_bug.cgi?id=192609&gt;.</span>
<span class="line-modified">625             [&amp;] (const RefPtr&lt;TypedOMCSSImageValue&gt;&amp;) { },</span>








































626 #endif
<span class="line-modified">627             [&amp;] (const RefPtr&lt;ImageBitmap&gt;&amp; value) { addParameter(indexForData(value), RecordingSwizzleTypes::ImageBitmap); },</span>
<span class="line-modified">628             [&amp;] (const RefPtr&lt;ImageData&gt;&amp; value) { addParameter(indexForData(value), RecordingSwizzleTypes::ImageData); },</span>
<span class="line-modified">629             [&amp;] (const RefPtr&lt;Int32Array&gt;&amp;) { addParameter(0, RecordingSwizzleTypes::TypedArray); },</span>



630             [&amp;] (const Vector&lt;float&gt;&amp; value) { addParameter(buildArrayForVector(value).ptr(), RecordingSwizzleTypes::Array); },
<span class="line-modified">631             [&amp;] (const Vector&lt;int&gt;&amp; value) { addParameter(buildArrayForVector(value).ptr(), RecordingSwizzleTypes::Array); },</span>



















632             [&amp;] (const String&amp; value) { addParameter(indexForData(value), RecordingSwizzleTypes::String); },
633             [&amp;] (double value) { addParameter(value, RecordingSwizzleTypes::Number); },
634             [&amp;] (float value) { addParameter(value, RecordingSwizzleTypes::Number); },





635             [&amp;] (int64_t value) { addParameter(static_cast&lt;double&gt;(value), RecordingSwizzleTypes::Number); },
636             [&amp;] (uint32_t value) { addParameter(static_cast&lt;double&gt;(value), RecordingSwizzleTypes::Number); },
637             [&amp;] (int32_t value) { addParameter(value, RecordingSwizzleTypes::Number); },
638             [&amp;] (uint8_t value) { addParameter(static_cast&lt;int&gt;(value), RecordingSwizzleTypes::Number); },
639             [&amp;] (bool value) { addParameter(value, RecordingSwizzleTypes::Boolean); }
640         );
<span class="line-modified">641     }</span>


642 
643     action-&gt;addItem(WTFMove(parametersData));
644     action-&gt;addItem(WTFMove(swizzleTypes));
645 
646     auto trace = Inspector::createScriptCallStack(JSExecState::currentState(), Inspector::ScriptCallStack::maxCallStackSizeToCapture);
647     action-&gt;addItem(indexForData(trace.ptr()));
648 
649     return action;
650 }
651 
652 Ref&lt;JSON::ArrayOf&lt;JSON::Value&gt;&gt; InspectorCanvas::buildArrayForCanvasGradient(const CanvasGradient&amp; canvasGradient)
653 {
654     const auto&amp; gradient = canvasGradient.gradient();
655 
656     String type = gradient.type() == Gradient::Type::Radial ? &quot;radial-gradient&quot;_s : gradient.type() == Gradient::Type::Linear ? &quot;linear-gradient&quot;_s : &quot;conic-gradient&quot;_s;
657 
658     auto parameters = JSON::ArrayOf&lt;float&gt;::create();
659     WTF::switchOn(gradient.data(),
660         [&amp;parameters] (const Gradient::LinearData&amp; data) {
661             parameters-&gt;addItem(data.point0.x());
</pre>
</td>
<td>
<hr />
<pre>
 40 #include &quot;HTMLVideoElement.h&quot;
 41 #include &quot;Image.h&quot;
 42 #include &quot;ImageBitmap.h&quot;
 43 #include &quot;ImageBitmapRenderingContext.h&quot;
 44 #include &quot;ImageBuffer.h&quot;
 45 #include &quot;ImageData.h&quot;
 46 #include &quot;InspectorDOMAgent.h&quot;
 47 #include &quot;JSCanvasDirection.h&quot;
 48 #include &quot;JSCanvasFillRule.h&quot;
 49 #include &quot;JSCanvasLineCap.h&quot;
 50 #include &quot;JSCanvasLineJoin.h&quot;
 51 #include &quot;JSCanvasTextAlign.h&quot;
 52 #include &quot;JSCanvasTextBaseline.h&quot;
 53 #include &quot;JSExecState.h&quot;
 54 #include &quot;JSImageSmoothingQuality.h&quot;
 55 #include &quot;Path2D.h&quot;
 56 #include &quot;Pattern.h&quot;
 57 #include &quot;RecordingSwizzleTypes.h&quot;
 58 #include &quot;SVGPathUtilities.h&quot;
 59 #include &quot;StringAdaptors.h&quot;
<span class="line-added"> 60 #if ENABLE(CSS_TYPED_OM)</span>
<span class="line-added"> 61 #include &quot;TypedOMCSSImageValue.h&quot;</span>
<span class="line-added"> 62 #endif</span>
 63 #if ENABLE(WEBGL)
 64 #include &quot;WebGLRenderingContext.h&quot;
 65 #endif
 66 #if ENABLE(WEBGL2)
 67 #include &quot;WebGL2RenderingContext.h&quot;
 68 #endif
<span class="line-modified"> 69 #if ENABLE(WEBGPU)</span>
<span class="line-modified"> 70 #include &quot;GPUCanvasContext.h&quot;</span>
 71 #endif
 72 #include &lt;JavaScriptCore/IdentifiersFactory.h&gt;
 73 #include &lt;JavaScriptCore/ScriptCallStackFactory.h&gt;
<span class="line-added"> 74 #include &lt;wtf/Function.h&gt;</span>
 75 
 76 namespace WebCore {
 77 
 78 using namespace Inspector;
 79 
 80 Ref&lt;InspectorCanvas&gt; InspectorCanvas::create(CanvasRenderingContext&amp; context)
 81 {
 82     return adoptRef(*new InspectorCanvas(context));
 83 }
 84 
 85 InspectorCanvas::InspectorCanvas(CanvasRenderingContext&amp; context)
 86     : m_identifier(&quot;canvas:&quot; + IdentifiersFactory::createIdentifier())
 87     , m_context(context)
 88 {
 89 }
 90 
 91 HTMLCanvasElement* InspectorCanvas::canvasElement()
 92 {
<span class="line-modified"> 93     if (is&lt;HTMLCanvasElement&gt;(m_context.canvasBase()))</span>
<span class="line-modified"> 94         return &amp;downcast&lt;HTMLCanvasElement&gt;(m_context.canvasBase());</span>

 95     return nullptr;
 96 }
 97 
<span class="line-added"> 98 void InspectorCanvas::canvasChanged()</span>
<span class="line-added"> 99 {</span>
<span class="line-added">100     if (!m_context.callTracingActive())</span>
<span class="line-added">101         return;</span>
<span class="line-added">102 </span>
<span class="line-added">103     // Since 2D contexts are able to be fully reproduced in the frontend, we don&#39;t need snapshots.</span>
<span class="line-added">104     if (is&lt;CanvasRenderingContext2D&gt;(m_context))</span>
<span class="line-added">105         return;</span>
<span class="line-added">106 </span>
<span class="line-added">107     m_contentChanged = true;</span>
<span class="line-added">108 }</span>
<span class="line-added">109 </span>
110 void InspectorCanvas::resetRecordingData()
111 {
112     m_initialState = nullptr;
113     m_frames = nullptr;
114     m_currentActions = nullptr;

115     m_serializedDuplicateData = nullptr;
116     m_indexedDuplicateData.clear();
117     m_recordingName = { };
118     m_bufferLimit = 100 * 1024 * 1024;
119     m_bufferUsed = 0;
120     m_frameCount = WTF::nullopt;
121     m_framesCaptured = 0;
<span class="line-added">122     m_contentChanged = false;</span>
123 
124     m_context.setCallTracingActive(false);
125 }
126 
127 bool InspectorCanvas::hasRecordingData() const
128 {
129     return m_bufferUsed &gt; 0;
130 }
131 
132 bool InspectorCanvas::currentFrameHasData() const
133 {
134     return !!m_frames;
135 }
136 
137 static bool shouldSnapshotBitmapRendererAction(const String&amp; name)
138 {
139     return name == &quot;transferFromImageBitmap&quot;;
140 }
141 
<span class="line-added">142 #if ENABLE(WEBGL)</span>
143 static bool shouldSnapshotWebGLAction(const String&amp; name)
144 {
145     return name == &quot;clear&quot;
146         || name == &quot;drawArrays&quot;
147         || name == &quot;drawElements&quot;;
148 }
<span class="line-added">149 #endif</span>
150 
<span class="line-modified">151 #if ENABLE(WEBGL2)</span>
<span class="line-added">152 static bool shouldSnapshotWebGL2Action(const String&amp; name)</span>
<span class="line-added">153 {</span>
<span class="line-added">154     return name == &quot;clear&quot;</span>
<span class="line-added">155         || name == &quot;drawArrays&quot;</span>
<span class="line-added">156         || name == &quot;drawArraysInstanced&quot;</span>
<span class="line-added">157         || name == &quot;drawElements&quot;</span>
<span class="line-added">158         || name == &quot;drawElementsInstanced&quot;;</span>
<span class="line-added">159 }</span>
<span class="line-added">160 #endif</span>
<span class="line-added">161 </span>
<span class="line-added">162 void InspectorCanvas::recordAction(const String&amp; name, std::initializer_list&lt;RecordCanvasActionVariant&gt;&amp;&amp; parameters)</span>
163 {
164     if (!m_initialState) {
<span class="line-added">165         // We should only construct the initial state for the first action of the recording.</span>
<span class="line-added">166         ASSERT(!m_frames &amp;&amp; !m_currentActions);</span>
<span class="line-added">167 </span>
168         m_initialState = buildInitialState();
169         m_bufferUsed += m_initialState-&gt;memoryCost();
170     }
171 
172     if (!m_frames)
173         m_frames = JSON::ArrayOf&lt;Inspector::Protocol::Recording::Frame&gt;::create();
174 
175     if (!m_currentActions) {
176         m_currentActions = JSON::ArrayOf&lt;JSON::Value&gt;::create();
177 
178         auto frame = Inspector::Protocol::Recording::Frame::create()
179             .setActions(m_currentActions)
180             .release();
181 
182         m_frames-&gt;addItem(WTFMove(frame));
183         ++m_framesCaptured;
184 
185         m_currentFrameStartTime = MonotonicTime::now();
186     }
187 
188     appendActionSnapshotIfNeeded();
189 
<span class="line-modified">190     m_lastRecordedAction = buildAction(name, WTFMove(parameters));</span>
<span class="line-modified">191     m_bufferUsed += m_lastRecordedAction-&gt;memoryCost();</span>
<span class="line-modified">192     m_currentActions-&gt;addItem(m_lastRecordedAction.get());</span>
193 
194     if (is&lt;ImageBitmapRenderingContext&gt;(m_context) &amp;&amp; shouldSnapshotBitmapRendererAction(name))
<span class="line-modified">195         m_contentChanged = true;</span>
196 #if ENABLE(WEBGL)
197     else if (is&lt;WebGLRenderingContext&gt;(m_context) &amp;&amp; shouldSnapshotWebGLAction(name))
<span class="line-modified">198         m_contentChanged = true;</span>
<span class="line-added">199 #endif</span>
<span class="line-added">200 #if ENABLE(WEBGL2)</span>
<span class="line-added">201     else if (is&lt;WebGL2RenderingContext&gt;(m_context) &amp;&amp; shouldSnapshotWebGL2Action(name))</span>
<span class="line-added">202         m_contentChanged = true;</span>
203 #endif
204 }
205 
<span class="line-modified">206 void InspectorCanvas::finalizeFrame()</span>





207 {
208     appendActionSnapshotIfNeeded();
209 











210     if (m_frames &amp;&amp; m_frames-&gt;length() &amp;&amp; !std::isnan(m_currentFrameStartTime)) {
211         auto currentFrame = static_cast&lt;Inspector::Protocol::Recording::Frame*&gt;(m_frames-&gt;get(m_frames-&gt;length() - 1).get());
212         currentFrame-&gt;setDuration((MonotonicTime::now() - m_currentFrameStartTime).milliseconds());
213 
214         m_currentFrameStartTime = MonotonicTime::nan();
215     }
216 
217     m_currentActions = nullptr;
218 }
219 
220 void InspectorCanvas::markCurrentFrameIncomplete()
221 {
222     if (!m_currentActions || !m_frames || !m_frames-&gt;length())
223         return;
224 
225     static_cast&lt;Inspector::Protocol::Recording::Frame*&gt;(m_frames-&gt;get(m_frames-&gt;length() - 1).get())-&gt;setIncomplete(true);
226 }
227 
228 void InspectorCanvas::setBufferLimit(long memoryLimit)
229 {
</pre>
<hr />
<pre>
246 bool InspectorCanvas::overFrameCount() const
247 {
248     return m_frameCount &amp;&amp; m_framesCaptured &gt;= m_frameCount.value();
249 }
250 
251 Ref&lt;Inspector::Protocol::Canvas::Canvas&gt; InspectorCanvas::buildObjectForCanvas(bool captureBacktrace)
252 {
253     Inspector::Protocol::Canvas::ContextType contextType;
254     if (is&lt;CanvasRenderingContext2D&gt;(m_context))
255         contextType = Inspector::Protocol::Canvas::ContextType::Canvas2D;
256     else if (is&lt;ImageBitmapRenderingContext&gt;(m_context))
257         contextType = Inspector::Protocol::Canvas::ContextType::BitmapRenderer;
258 #if ENABLE(WEBGL)
259     else if (is&lt;WebGLRenderingContext&gt;(m_context))
260         contextType = Inspector::Protocol::Canvas::ContextType::WebGL;
261 #endif
262 #if ENABLE(WEBGL2)
263     else if (is&lt;WebGL2RenderingContext&gt;(m_context))
264         contextType = Inspector::Protocol::Canvas::ContextType::WebGL2;
265 #endif
<span class="line-modified">266 #if ENABLE(WEBGPU)</span>
<span class="line-modified">267     else if (is&lt;GPUCanvasContext&gt;(m_context))</span>
<span class="line-modified">268         contextType = Inspector::Protocol::Canvas::ContextType::WebGPU;</span>
269 #endif
270     else {
271         ASSERT_NOT_REACHED();
272         contextType = Inspector::Protocol::Canvas::ContextType::Canvas2D;
273     }
274 
275     auto canvas = Inspector::Protocol::Canvas::Canvas::create()
276         .setCanvasId(m_identifier)
277         .setContextType(contextType)
278         .release();
279 
280     if (auto* node = canvasElement()) {
281         String cssCanvasName = node-&gt;document().nameForCSSCanvasElement(*node);
282         if (!cssCanvasName.isEmpty())
283             canvas-&gt;setCssCanvasName(cssCanvasName);
284 
285         // FIXME: &lt;https://webkit.org/b/178282&gt; Web Inspector: send a DOM node with each Canvas payload and eliminate Canvas.requestNode
286     }
287 
288     if (is&lt;ImageBitmapRenderingContext&gt;(m_context)) {
</pre>
<hr />
<pre>
306             canvas-&gt;setContextAttributes(WTFMove(contextAttributes));
307         }
308     }
309 #endif
310 
311     // FIXME: &lt;https://webkit.org/b/180833&gt; Web Inspector: support OffscreenCanvas for Canvas related operations
312 
313     if (auto* node = canvasElement()) {
314         if (size_t memoryCost = node-&gt;memoryCost())
315             canvas-&gt;setMemoryCost(memoryCost);
316     }
317 
318     if (captureBacktrace) {
319         auto stackTrace = Inspector::createScriptCallStack(JSExecState::currentState(), Inspector::ScriptCallStack::maxCallStackSizeToCapture);
320         canvas-&gt;setBacktrace(stackTrace-&gt;buildInspectorArray());
321     }
322 
323     return canvas;
324 }
325 
<span class="line-modified">326 Ref&lt;Inspector::Protocol::Recording::Recording&gt; InspectorCanvas::releaseObjectForRecording()</span>
327 {
<span class="line-modified">328     ASSERT(!m_currentActions);</span>
<span class="line-modified">329     ASSERT(!m_lastRecordedAction);</span>
<span class="line-added">330     ASSERT(!m_frames);</span>
<span class="line-added">331 </span>
<span class="line-added">332     Inspector::Protocol::Recording::Type type;</span>
<span class="line-added">333     if (is&lt;CanvasRenderingContext2D&gt;(m_context))</span>
<span class="line-added">334         type = Inspector::Protocol::Recording::Type::Canvas2D;</span>
<span class="line-added">335     else if (is&lt;ImageBitmapRenderingContext&gt;(m_context))</span>
<span class="line-added">336         type = Inspector::Protocol::Recording::Type::CanvasBitmapRenderer;</span>
<span class="line-added">337 #if ENABLE(WEBGL)</span>
<span class="line-added">338     else if (is&lt;WebGLRenderingContext&gt;(m_context))</span>
<span class="line-added">339         type = Inspector::Protocol::Recording::Type::CanvasWebGL;</span>
<span class="line-added">340 #endif</span>
<span class="line-added">341 #if ENABLE(WEBGL2)</span>
<span class="line-added">342     else if (is&lt;WebGL2RenderingContext&gt;(m_context))</span>
<span class="line-added">343         type = Inspector::Protocol::Recording::Type::CanvasWebGL2;</span>
<span class="line-added">344 #endif</span>
<span class="line-added">345     else {</span>
<span class="line-added">346         ASSERT_NOT_REACHED();</span>
<span class="line-added">347         type = Inspector::Protocol::Recording::Type::Canvas2D;</span>
<span class="line-added">348     }</span>
<span class="line-added">349 </span>
<span class="line-added">350     auto recording = Inspector::Protocol::Recording::Recording::create()</span>
<span class="line-added">351         .setVersion(Inspector::Protocol::Recording::VERSION)</span>
<span class="line-added">352         .setType(type)</span>
<span class="line-added">353         .setInitialState(m_initialState.releaseNonNull())</span>
<span class="line-added">354         .setData(m_serializedDuplicateData.releaseNonNull())</span>
<span class="line-added">355         .release();</span>
<span class="line-added">356 </span>
<span class="line-added">357     if (!m_recordingName.isEmpty())</span>
<span class="line-added">358         recording-&gt;setName(m_recordingName);</span>
359 
<span class="line-modified">360     resetRecordingData();</span>
<span class="line-modified">361 </span>
<span class="line-added">362     return recording;</span>
363 }
364 
<span class="line-modified">365 String InspectorCanvas::getCanvasContentAsDataURL(ErrorString&amp; errorString)</span>
366 {
<span class="line-modified">367     // FIXME: &lt;https://webkit.org/b/173621&gt; Web Inspector: Support getting the content of WebMetal context;</span>
<span class="line-added">368     if (!is&lt;CanvasRenderingContext2D&gt;(m_context)</span>
<span class="line-added">369 #if ENABLE(WEBGL)</span>
<span class="line-added">370         &amp;&amp; !is&lt;WebGLRenderingContextBase&gt;(m_context)</span>
<span class="line-added">371 #endif</span>
<span class="line-added">372         &amp;&amp; !is&lt;ImageBitmapRenderingContext&gt;(m_context)) {</span>
<span class="line-added">373         errorString = &quot;Unsupported canvas context type&quot;_s;</span>
<span class="line-added">374         return emptyString();</span>
<span class="line-added">375     }</span>
376 
<span class="line-added">377     // FIXME: &lt;https://webkit.org/b/180833&gt; Web Inspector: support OffscreenCanvas for Canvas related operations</span>
378     auto* node = canvasElement();
<span class="line-modified">379     if (!node) {</span>
<span class="line-modified">380         errorString = &quot;Context isn&#39;t related to an HTMLCanvasElement&quot;_s;</span>
<span class="line-added">381         return emptyString();</span>
<span class="line-added">382     }</span>
383 
384 #if ENABLE(WEBGL)
385     if (is&lt;WebGLRenderingContextBase&gt;(m_context))
386         downcast&lt;WebGLRenderingContextBase&gt;(m_context).setPreventBufferClearForInspector(true);
387 #endif
388 
389     ExceptionOr&lt;UncachedString&gt; result = node-&gt;toDataURL(&quot;image/png&quot;_s);
390 
391 #if ENABLE(WEBGL)
392     if (is&lt;WebGLRenderingContextBase&gt;(m_context))
393         downcast&lt;WebGLRenderingContextBase&gt;(m_context).setPreventBufferClearForInspector(false);
394 #endif
395 
<span class="line-modified">396     if (result.hasException()) {</span>
<span class="line-modified">397         errorString = result.releaseException().releaseMessage();</span>
<span class="line-added">398         return emptyString();</span>
<span class="line-added">399     }</span>
400 
401     return result.releaseReturnValue().string;
402 }
403 
<span class="line-added">404 void InspectorCanvas::appendActionSnapshotIfNeeded()</span>
<span class="line-added">405 {</span>
<span class="line-added">406     if (!m_lastRecordedAction)</span>
<span class="line-added">407         return;</span>
<span class="line-added">408 </span>
<span class="line-added">409     if (m_contentChanged) {</span>
<span class="line-added">410         m_bufferUsed -= m_lastRecordedAction-&gt;memoryCost();</span>
<span class="line-added">411 </span>
<span class="line-added">412         ErrorString ignored;</span>
<span class="line-added">413         m_lastRecordedAction-&gt;addItem(indexForData(getCanvasContentAsDataURL(ignored)));</span>
<span class="line-added">414 </span>
<span class="line-added">415         m_bufferUsed += m_lastRecordedAction-&gt;memoryCost();</span>
<span class="line-added">416     }</span>
<span class="line-added">417 </span>
<span class="line-added">418     m_lastRecordedAction = nullptr;</span>
<span class="line-added">419     m_contentChanged = false;</span>
<span class="line-added">420 }</span>
<span class="line-added">421 </span>
422 int InspectorCanvas::indexForData(DuplicateDataVariant data)
423 {
424     size_t index = m_indexedDuplicateData.findMatching([&amp;] (auto item) {
425         if (data == item)
426             return true;
427 
428         auto traceA = WTF::get_if&lt;RefPtr&lt;ScriptCallStack&gt;&gt;(data);
429         auto traceB = WTF::get_if&lt;RefPtr&lt;ScriptCallStack&gt;&gt;(item);
430         if (traceA &amp;&amp; *traceA &amp;&amp; traceB &amp;&amp; *traceB)
431             return (*traceA)-&gt;isEqual((*traceB).get());
432 
433         return false;
434     });
435     if (index != notFound) {
<span class="line-modified">436         ASSERT(index &lt; static_cast&lt;size_t&gt;(std::numeric_limits&lt;int&gt;::max()));</span>
437         return static_cast&lt;int&gt;(index);
438     }
439 
440     if (!m_serializedDuplicateData)
441         m_serializedDuplicateData = JSON::ArrayOf&lt;JSON::Value&gt;::create();
442 
443     RefPtr&lt;JSON::Value&gt; item;
444     WTF::switchOn(data,
445         [&amp;] (const RefPtr&lt;HTMLImageElement&gt;&amp; imageElement) {
446             String dataURL = &quot;data:,&quot;_s;
447 
448             if (CachedImage* cachedImage = imageElement-&gt;cachedImage()) {
449                 Image* image = cachedImage-&gt;image();
450                 if (image &amp;&amp; image != &amp;Image::nullImage()) {
451                     std::unique_ptr&lt;ImageBuffer&gt; imageBuffer = ImageBuffer::create(image-&gt;size(), RenderingMode::Unaccelerated);
452                     imageBuffer-&gt;context().drawImage(*image, FloatPoint(0, 0));
453                     dataURL = imageBuffer-&gt;toDataURL(&quot;image/png&quot;);
454                 }
455             }
456 
</pre>
<hr />
<pre>
475             String dataURL = &quot;data:,&quot;_s;
476 
477             ExceptionOr&lt;UncachedString&gt; result = canvasElement-&gt;toDataURL(&quot;image/png&quot;_s);
478             if (!result.hasException())
479                 dataURL = result.releaseReturnValue().string;
480 
481             index = indexForData(dataURL);
482         },
483         [&amp;] (const RefPtr&lt;CanvasGradient&gt;&amp; canvasGradient) { item = buildArrayForCanvasGradient(*canvasGradient); },
484         [&amp;] (const RefPtr&lt;CanvasPattern&gt;&amp; canvasPattern) { item = buildArrayForCanvasPattern(*canvasPattern); },
485         [&amp;] (const RefPtr&lt;ImageData&gt;&amp; imageData) { item = buildArrayForImageData(*imageData); },
486         [&amp;] (RefPtr&lt;ImageBitmap&gt;&amp; imageBitmap) {
487             index = indexForData(imageBitmap-&gt;buffer()-&gt;toDataURL(&quot;image/png&quot;));
488         },
489         [&amp;] (const RefPtr&lt;ScriptCallStack&gt;&amp; scriptCallStack) {
490             auto array = JSON::ArrayOf&lt;double&gt;::create();
491             for (size_t i = 0; i &lt; scriptCallStack-&gt;size(); ++i)
492                 array-&gt;addItem(indexForData(scriptCallStack-&gt;at(i)));
493             item = WTFMove(array);
494         },
<span class="line-added">495 #if ENABLE(CSS_TYPED_OM)</span>
<span class="line-added">496         [&amp;] (const RefPtr&lt;TypedOMCSSImageValue&gt;&amp; cssImageValue) {</span>
<span class="line-added">497             String dataURL = &quot;data:,&quot;_s;</span>
<span class="line-added">498 </span>
<span class="line-added">499             if (auto* cachedImage = cssImageValue-&gt;image()) {</span>
<span class="line-added">500                 auto* image = cachedImage-&gt;image();</span>
<span class="line-added">501                 if (image &amp;&amp; image != &amp;Image::nullImage()) {</span>
<span class="line-added">502                     auto imageBuffer = ImageBuffer::create(image-&gt;size(), RenderingMode::Unaccelerated);</span>
<span class="line-added">503                     imageBuffer-&gt;context().drawImage(*image, FloatPoint(0, 0));</span>
<span class="line-added">504                     dataURL = imageBuffer-&gt;toDataURL(&quot;image/png&quot;);</span>
<span class="line-added">505                 }</span>
<span class="line-added">506             }</span>
<span class="line-added">507 </span>
<span class="line-added">508             index = indexForData(dataURL);</span>
<span class="line-added">509         },</span>
<span class="line-added">510 #endif</span>
511         [&amp;] (const ScriptCallFrame&amp; scriptCallFrame) {
512             auto array = JSON::ArrayOf&lt;double&gt;::create();
513             array-&gt;addItem(indexForData(scriptCallFrame.functionName()));
514             array-&gt;addItem(indexForData(scriptCallFrame.sourceURL()));
515             array-&gt;addItem(static_cast&lt;int&gt;(scriptCallFrame.lineNumber()));
516             array-&gt;addItem(static_cast&lt;int&gt;(scriptCallFrame.columnNumber()));
517             item = WTFMove(array);
518         },
519         [&amp;] (const String&amp; value) { item = JSON::Value::create(value); }
520     );
521 
522     if (item) {
523         m_bufferUsed += item-&gt;memoryCost();
524         m_serializedDuplicateData-&gt;addItem(WTFMove(item));
525 
526         m_indexedDuplicateData.append(data);
527         index = m_indexedDuplicateData.size() - 1;
528     }
529 
<span class="line-modified">530     ASSERT(index &lt; static_cast&lt;size_t&gt;(std::numeric_limits&lt;int&gt;::max()));</span>
531     return static_cast&lt;int&gt;(index);
532 }
533 
534 String InspectorCanvas::stringIndexForKey(const String&amp; key)
535 {
536     return String::number(indexForData(key));
537 }
538 
539 static Ref&lt;JSON::ArrayOf&lt;double&gt;&gt; buildArrayForAffineTransform(const AffineTransform&amp; affineTransform)
540 {
541     auto array = JSON::ArrayOf&lt;double&gt;::create();
542     array-&gt;addItem(affineTransform.a());
543     array-&gt;addItem(affineTransform.b());
544     array-&gt;addItem(affineTransform.c());
545     array-&gt;addItem(affineTransform.d());
546     array-&gt;addItem(affineTransform.e());
547     array-&gt;addItem(affineTransform.f());
548     return array;
549 }
550 
</pre>
<hr />
<pre>
633             webGLContextAttributesPayload-&gt;setBoolean(&quot;alpha&quot;_s, webGLContextAttributes-&gt;alpha);
634             webGLContextAttributesPayload-&gt;setBoolean(&quot;depth&quot;_s, webGLContextAttributes-&gt;depth);
635             webGLContextAttributesPayload-&gt;setBoolean(&quot;stencil&quot;_s, webGLContextAttributes-&gt;stencil);
636             webGLContextAttributesPayload-&gt;setBoolean(&quot;antialias&quot;_s, webGLContextAttributes-&gt;antialias);
637             webGLContextAttributesPayload-&gt;setBoolean(&quot;premultipliedAlpha&quot;_s, webGLContextAttributes-&gt;premultipliedAlpha);
638             webGLContextAttributesPayload-&gt;setBoolean(&quot;preserveDrawingBuffer&quot;_s, webGLContextAttributes-&gt;preserveDrawingBuffer);
639             webGLContextAttributesPayload-&gt;setBoolean(&quot;failIfMajorPerformanceCaveat&quot;_s, webGLContextAttributes-&gt;failIfMajorPerformanceCaveat);
640             parametersPayload-&gt;addItem(WTFMove(webGLContextAttributesPayload));
641         }
642     }
643 #endif
644 
645     initialStatePayload-&gt;setAttributes(WTFMove(attributesPayload));
646 
647     if (statesPayload-&gt;length())
648         initialStatePayload-&gt;setStates(WTFMove(statesPayload));
649 
650     if (parametersPayload-&gt;length())
651         initialStatePayload-&gt;setParameters(WTFMove(parametersPayload));
652 
<span class="line-modified">653     ErrorString ignored;</span>
<span class="line-added">654     initialStatePayload-&gt;setContent(getCanvasContentAsDataURL(ignored));</span>
655 
656     return initialStatePayload;
657 }
658 
<span class="line-modified">659 Ref&lt;JSON::ArrayOf&lt;JSON::Value&gt;&gt; InspectorCanvas::buildAction(const String&amp; name, std::initializer_list&lt;RecordCanvasActionVariant&gt;&amp;&amp; parameters)</span>
660 {
661     auto action = JSON::ArrayOf&lt;JSON::Value&gt;::create();
662     action-&gt;addItem(indexForData(name));
663 
664     auto parametersData = JSON::ArrayOf&lt;JSON::Value&gt;::create();
665     auto swizzleTypes = JSON::ArrayOf&lt;int&gt;::create();
666 
667     auto addParameter = [&amp;parametersData, &amp;swizzleTypes] (auto value, RecordingSwizzleTypes swizzleType) {
668         parametersData-&gt;addItem(value);
669         swizzleTypes-&gt;addItem(static_cast&lt;int&gt;(swizzleType));
670     };
671 
<span class="line-modified">672     // Declared before it&#39;s initialized so it can be used recursively.</span>
<span class="line-modified">673     Function&lt;void(const RecordCanvasActionVariant&amp;)&gt; parseParameter;</span>
<span class="line-added">674     parseParameter = [&amp;] (const auto&amp; parameter) {</span>
<span class="line-added">675         WTF::switchOn(parameter,</span>
676             [&amp;] (CanvasDirection value) { addParameter(indexForData(convertEnumerationToString(value)), RecordingSwizzleTypes::String); },
677             [&amp;] (CanvasFillRule value) { addParameter(indexForData(convertEnumerationToString(value)), RecordingSwizzleTypes::String); },
678             [&amp;] (CanvasLineCap value) { addParameter(indexForData(convertEnumerationToString(value)), RecordingSwizzleTypes::String); },
679             [&amp;] (CanvasLineJoin value) { addParameter(indexForData(convertEnumerationToString(value)), RecordingSwizzleTypes::String); },
680             [&amp;] (CanvasTextAlign value) { addParameter(indexForData(convertEnumerationToString(value)), RecordingSwizzleTypes::String); },
681             [&amp;] (CanvasTextBaseline value) { addParameter(indexForData(convertEnumerationToString(value)), RecordingSwizzleTypes::String); },
<span class="line-added">682             [&amp;] (ImageSmoothingQuality value) { addParameter(indexForData(convertEnumerationToString(value)), RecordingSwizzleTypes::String); },</span>
683             [&amp;] (const DOMMatrix2DInit&amp; value) {
684                 auto array = JSON::ArrayOf&lt;double&gt;::create();
685                 array-&gt;addItem(value.a.valueOr(1));
686                 array-&gt;addItem(value.b.valueOr(0));
687                 array-&gt;addItem(value.c.valueOr(0));
688                 array-&gt;addItem(value.d.valueOr(1));
689                 array-&gt;addItem(value.e.valueOr(0));
690                 array-&gt;addItem(value.f.valueOr(0));
691                 addParameter(array.ptr(), RecordingSwizzleTypes::DOMMatrix);
692             },
<span class="line-modified">693             [&amp;] (const Element* value) {</span>
<span class="line-modified">694                 if (value) {</span>
<span class="line-modified">695                     // Elements are not serializable, so add a string as a placeholder since the actual</span>
<span class="line-modified">696                     // element cannot be reconstructed in the frontend.</span>
<span class="line-added">697                     addParameter(indexForData(&quot;Element&quot;), RecordingSwizzleTypes::None);</span>
<span class="line-added">698                 }</span>
699             },
<span class="line-modified">700             [&amp;] (HTMLImageElement* value) {</span>
<span class="line-modified">701                 if (value)</span>
<span class="line-modified">702                     addParameter(indexForData(value), RecordingSwizzleTypes::Image); },</span>
<span class="line-modified">703             [&amp;] (ImageBitmap* value) {</span>
<span class="line-modified">704                 if (value)</span>
<span class="line-added">705                     addParameter(indexForData(value), RecordingSwizzleTypes::ImageBitmap); },</span>
<span class="line-added">706             [&amp;] (ImageData* value) {</span>
<span class="line-added">707                 if (value)</span>
<span class="line-added">708                     addParameter(indexForData(value), RecordingSwizzleTypes::ImageData); },</span>
<span class="line-added">709             [&amp;] (const Path2D* value) {</span>
<span class="line-added">710                 if (value)</span>
<span class="line-added">711                     addParameter(indexForData(buildStringFromPath(value-&gt;path())), RecordingSwizzleTypes::Path2D); },</span>
712 #if ENABLE(WEBGL)
713             // FIXME: &lt;https://webkit.org/b/176009&gt; Web Inspector: send data for WebGL objects during a recording instead of a placeholder string
<span class="line-modified">714             [&amp;] (const WebGLBuffer* value) {</span>
<span class="line-modified">715                 if (value)</span>
<span class="line-modified">716                     addParameter(0, RecordingSwizzleTypes::WebGLBuffer);</span>
<span class="line-modified">717             },</span>
<span class="line-modified">718             [&amp;] (const WebGLFramebuffer* value) {</span>
<span class="line-modified">719                 if (value)</span>
<span class="line-modified">720                     addParameter(0, RecordingSwizzleTypes::WebGLFramebuffer);</span>
<span class="line-added">721             },</span>
<span class="line-added">722             [&amp;] (const WebGLProgram* value) {</span>
<span class="line-added">723                 if (value)</span>
<span class="line-added">724                     addParameter(0, RecordingSwizzleTypes::WebGLProgram);</span>
<span class="line-added">725             },</span>
<span class="line-added">726             [&amp;] (const WebGLQuery* value) {</span>
<span class="line-added">727                 if (value)</span>
<span class="line-added">728                     addParameter(0, RecordingSwizzleTypes::WebGLQuery);</span>
<span class="line-added">729             },</span>
<span class="line-added">730             [&amp;] (const WebGLRenderbuffer* value) {</span>
<span class="line-added">731                 if (value)</span>
<span class="line-added">732                     addParameter(0, RecordingSwizzleTypes::WebGLRenderbuffer);</span>
<span class="line-added">733             },</span>
<span class="line-added">734             [&amp;] (const WebGLSampler* value) {</span>
<span class="line-added">735                 if (value)</span>
<span class="line-added">736                     addParameter(0, RecordingSwizzleTypes::WebGLSampler);</span>
<span class="line-added">737             },</span>
<span class="line-added">738             [&amp;] (const WebGLShader* value) {</span>
<span class="line-added">739                 if (value)</span>
<span class="line-added">740                     addParameter(0, RecordingSwizzleTypes::WebGLShader);</span>
<span class="line-added">741             },</span>
<span class="line-added">742             [&amp;] (const WebGLSync* value) {</span>
<span class="line-added">743                 if (value)</span>
<span class="line-added">744                     addParameter(0, RecordingSwizzleTypes::WebGLSync);</span>
<span class="line-added">745             },</span>
<span class="line-added">746             [&amp;] (const WebGLTexture* value) {</span>
<span class="line-added">747                 if (value)</span>
<span class="line-added">748                     addParameter(0, RecordingSwizzleTypes::WebGLTexture);</span>
<span class="line-added">749             },</span>
<span class="line-added">750             [&amp;] (const WebGLTransformFeedback* value) {</span>
<span class="line-added">751                 if (value)</span>
<span class="line-added">752                     addParameter(0, RecordingSwizzleTypes::WebGLTransformFeedback);</span>
<span class="line-added">753             },</span>
<span class="line-added">754             [&amp;] (const WebGLUniformLocation* value) {</span>
<span class="line-added">755                 if (value)</span>
<span class="line-added">756                     addParameter(0, RecordingSwizzleTypes::WebGLUniformLocation);</span>
<span class="line-added">757             },</span>
<span class="line-added">758             [&amp;] (const WebGLVertexArrayObject* value) {</span>
<span class="line-added">759                 if (value)</span>
<span class="line-added">760                     addParameter(0, RecordingSwizzleTypes::WebGLVertexArrayObject);</span>
<span class="line-added">761             },</span>
762 #endif
<span class="line-modified">763             [&amp;] (const RefPtr&lt;ArrayBuffer&gt;&amp; value) {</span>
<span class="line-modified">764                 if (value)</span>
<span class="line-modified">765                     addParameter(0, RecordingSwizzleTypes::TypedArray);</span>
<span class="line-modified">766             },</span>
<span class="line-modified">767             [&amp;] (const RefPtr&lt;ArrayBufferView&gt;&amp; value) {</span>
<span class="line-modified">768                 if (value)</span>
<span class="line-modified">769                     addParameter(0, RecordingSwizzleTypes::TypedArray);</span>
<span class="line-added">770             },</span>
<span class="line-added">771             [&amp;] (const RefPtr&lt;CanvasGradient&gt;&amp; value) {</span>
<span class="line-added">772                 if (value)</span>
<span class="line-added">773                     addParameter(indexForData(value), RecordingSwizzleTypes::CanvasGradient);</span>
<span class="line-added">774             },</span>
<span class="line-added">775             [&amp;] (const RefPtr&lt;CanvasPattern&gt;&amp; value) {</span>
<span class="line-added">776                 if (value)</span>
<span class="line-added">777                     addParameter(indexForData(value), RecordingSwizzleTypes::CanvasPattern);</span>
<span class="line-added">778             },</span>
<span class="line-added">779             [&amp;] (const RefPtr&lt;Float32Array&gt;&amp; value) {</span>
<span class="line-added">780                 if (value)</span>
<span class="line-added">781                     addParameter(0, RecordingSwizzleTypes::TypedArray);</span>
<span class="line-added">782             },</span>
<span class="line-added">783             [&amp;] (const RefPtr&lt;HTMLCanvasElement&gt;&amp; value) {</span>
<span class="line-added">784                 if (value)</span>
<span class="line-added">785                     addParameter(indexForData(value), RecordingSwizzleTypes::Image);</span>
<span class="line-added">786             },</span>
<span class="line-added">787             [&amp;] (const RefPtr&lt;HTMLImageElement&gt;&amp; value) {</span>
<span class="line-added">788                 if (value)</span>
<span class="line-added">789                     addParameter(indexForData(value), RecordingSwizzleTypes::Image);</span>
<span class="line-added">790             },</span>
791 #if ENABLE(VIDEO)
<span class="line-modified">792             [&amp;] (const RefPtr&lt;HTMLVideoElement&gt;&amp; value) {</span>
<span class="line-added">793                 if (value)</span>
<span class="line-added">794                     addParameter(indexForData(value), RecordingSwizzleTypes::Image);</span>
<span class="line-added">795             },</span>
796 #endif
797 #if ENABLE(CSS_TYPED_OM)
<span class="line-modified">798             [&amp;] (const RefPtr&lt;TypedOMCSSImageValue&gt;&amp; value) {</span>
<span class="line-modified">799                 if (value)</span>
<span class="line-added">800                     addParameter(indexForData(value), RecordingSwizzleTypes::Image);</span>
<span class="line-added">801             },</span>
<span class="line-added">802 #endif</span>
<span class="line-added">803             [&amp;] (const RefPtr&lt;ImageBitmap&gt;&amp; value) {</span>
<span class="line-added">804                 if (value)</span>
<span class="line-added">805                     addParameter(indexForData(value), RecordingSwizzleTypes::ImageBitmap);</span>
<span class="line-added">806             },</span>
<span class="line-added">807             [&amp;] (const RefPtr&lt;ImageData&gt;&amp; value) {</span>
<span class="line-added">808                 if (value)</span>
<span class="line-added">809                     addParameter(indexForData(value), RecordingSwizzleTypes::ImageData);</span>
<span class="line-added">810             },</span>
<span class="line-added">811             [&amp;] (const RefPtr&lt;Int32Array&gt;&amp; value) {</span>
<span class="line-added">812                 if (value)</span>
<span class="line-added">813                     addParameter(0, RecordingSwizzleTypes::TypedArray);</span>
<span class="line-added">814             },</span>
<span class="line-added">815             [&amp;] (const RefPtr&lt;Uint32Array&gt;&amp; value) {</span>
<span class="line-added">816                 if (value)</span>
<span class="line-added">817                     addParameter(0, RecordingSwizzleTypes::TypedArray);</span>
<span class="line-added">818             },</span>
<span class="line-added">819             [&amp;] (const CanvasImageSource&amp; value) {</span>
<span class="line-added">820                 WTF::visit(parseParameter, value);</span>
<span class="line-added">821             },</span>
<span class="line-added">822             [&amp;] (const CanvasRenderingContext2DBase::Style&amp; value) {</span>
<span class="line-added">823                 WTF::visit(parseParameter, value);</span>
<span class="line-added">824             },</span>
<span class="line-added">825 #if ENABLE(WEBGL)</span>
<span class="line-added">826             [&amp;] (const WebGLRenderingContextBase::BufferDataSource&amp; value) {</span>
<span class="line-added">827                 WTF::visit(parseParameter, value);</span>
<span class="line-added">828             },</span>
<span class="line-added">829             [&amp;] (const Optional&lt;WebGLRenderingContextBase::BufferDataSource&gt;&amp; value) {</span>
<span class="line-added">830                 if (value)</span>
<span class="line-added">831                     parseParameter(value.value());</span>
<span class="line-added">832             },</span>
<span class="line-added">833             [&amp;] (const WebGLRenderingContextBase::TexImageSource&amp; value) {</span>
<span class="line-added">834                 WTF::visit(parseParameter, value);</span>
<span class="line-added">835             },</span>
<span class="line-added">836             [&amp;] (const Optional&lt;WebGLRenderingContextBase::TexImageSource&gt;&amp; value) {</span>
<span class="line-added">837                 if (value)</span>
<span class="line-added">838                     parseParameter(value.value());</span>
<span class="line-added">839             },</span>
840 #endif
<span class="line-modified">841             [&amp;] (const Vector&lt;String&gt;&amp; value) {</span>
<span class="line-modified">842                 auto deduplicated = value.map([&amp;] (const String&amp; item) {</span>
<span class="line-modified">843                     return indexForData(item);</span>
<span class="line-added">844                 });</span>
<span class="line-added">845                 addParameter(buildArrayForVector(deduplicated).ptr(), RecordingSwizzleTypes::String);</span>
<span class="line-added">846             },</span>
847             [&amp;] (const Vector&lt;float&gt;&amp; value) { addParameter(buildArrayForVector(value).ptr(), RecordingSwizzleTypes::Array); },
<span class="line-modified">848             [&amp;] (const Vector&lt;uint32_t&gt;&amp; value) {</span>
<span class="line-added">849                 auto mapped = value.map([&amp;] (uint32_t item) {</span>
<span class="line-added">850                     return static_cast&lt;double&gt;(item);</span>
<span class="line-added">851                 });</span>
<span class="line-added">852                 addParameter(buildArrayForVector(mapped).ptr(), RecordingSwizzleTypes::Array);</span>
<span class="line-added">853             },</span>
<span class="line-added">854             [&amp;] (const Vector&lt;int32_t&gt;&amp; value) { addParameter(buildArrayForVector(value).ptr(), RecordingSwizzleTypes::Array); },</span>
<span class="line-added">855 #if ENABLE(WEBGL)</span>
<span class="line-added">856             [&amp;] (const WebGLRenderingContextBase::Float32List::VariantType&amp; value) {</span>
<span class="line-added">857                 WTF::visit(parseParameter, value);</span>
<span class="line-added">858             },</span>
<span class="line-added">859             [&amp;] (const WebGLRenderingContextBase::Int32List::VariantType&amp; value) {</span>
<span class="line-added">860                 WTF::visit(parseParameter, value);</span>
<span class="line-added">861             },</span>
<span class="line-added">862 #endif</span>
<span class="line-added">863 #if ENABLE(WEBGL2)</span>
<span class="line-added">864             [&amp;] (const WebGL2RenderingContext::Uint32List::VariantType&amp; value) {</span>
<span class="line-added">865                 WTF::visit(parseParameter, value);</span>
<span class="line-added">866             },</span>
<span class="line-added">867 #endif</span>
868             [&amp;] (const String&amp; value) { addParameter(indexForData(value), RecordingSwizzleTypes::String); },
869             [&amp;] (double value) { addParameter(value, RecordingSwizzleTypes::Number); },
870             [&amp;] (float value) { addParameter(value, RecordingSwizzleTypes::Number); },
<span class="line-added">871             [&amp;] (const Optional&lt;float&gt;&amp; value) {</span>
<span class="line-added">872                 if (value)</span>
<span class="line-added">873                     parseParameter(value.value());</span>
<span class="line-added">874             },</span>
<span class="line-added">875             [&amp;] (uint64_t value) { addParameter(static_cast&lt;double&gt;(value), RecordingSwizzleTypes::Number); },</span>
876             [&amp;] (int64_t value) { addParameter(static_cast&lt;double&gt;(value), RecordingSwizzleTypes::Number); },
877             [&amp;] (uint32_t value) { addParameter(static_cast&lt;double&gt;(value), RecordingSwizzleTypes::Number); },
878             [&amp;] (int32_t value) { addParameter(value, RecordingSwizzleTypes::Number); },
879             [&amp;] (uint8_t value) { addParameter(static_cast&lt;int&gt;(value), RecordingSwizzleTypes::Number); },
880             [&amp;] (bool value) { addParameter(value, RecordingSwizzleTypes::Boolean); }
881         );
<span class="line-modified">882     };</span>
<span class="line-added">883     for (auto&amp; parameter : parameters)</span>
<span class="line-added">884         parseParameter(parameter);</span>
885 
886     action-&gt;addItem(WTFMove(parametersData));
887     action-&gt;addItem(WTFMove(swizzleTypes));
888 
889     auto trace = Inspector::createScriptCallStack(JSExecState::currentState(), Inspector::ScriptCallStack::maxCallStackSizeToCapture);
890     action-&gt;addItem(indexForData(trace.ptr()));
891 
892     return action;
893 }
894 
895 Ref&lt;JSON::ArrayOf&lt;JSON::Value&gt;&gt; InspectorCanvas::buildArrayForCanvasGradient(const CanvasGradient&amp; canvasGradient)
896 {
897     const auto&amp; gradient = canvasGradient.gradient();
898 
899     String type = gradient.type() == Gradient::Type::Radial ? &quot;radial-gradient&quot;_s : gradient.type() == Gradient::Type::Linear ? &quot;linear-gradient&quot;_s : &quot;conic-gradient&quot;_s;
900 
901     auto parameters = JSON::ArrayOf&lt;float&gt;::create();
902     WTF::switchOn(gradient.data(),
903         [&amp;parameters] (const Gradient::LinearData&amp; data) {
904             parameters-&gt;addItem(data.point0.x());
</pre>
</td>
</tr>
</table>
<center><a href="InspectorAuditDOMObject.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="InspectorCanvas.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>