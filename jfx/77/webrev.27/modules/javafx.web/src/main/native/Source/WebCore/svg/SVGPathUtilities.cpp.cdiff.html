<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/svg/SVGPathUtilities.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SVGPathStringBuilder.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SVGPathUtilities.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/svg/SVGPathUtilities.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 58,43 ***</span>
      if (!path.isNull() &amp;&amp; !path.isEmpty()) {
          path.apply([&amp;builder] (const PathElement&amp; element) {
              switch (element.type) {
              case PathElementMoveToPoint:
                  builder.append(&#39;M&#39;);
<span class="line-modified">!                 builder.appendECMAScriptNumber(element.points[0].x());</span>
                  builder.append(&#39; &#39;);
<span class="line-modified">!                 builder.appendECMAScriptNumber(element.points[0].y());</span>
                  break;
              case PathElementAddLineToPoint:
                  builder.append(&#39;L&#39;);
<span class="line-modified">!                 builder.appendECMAScriptNumber(element.points[0].x());</span>
                  builder.append(&#39; &#39;);
<span class="line-modified">!                 builder.appendECMAScriptNumber(element.points[0].y());</span>
                  break;
              case PathElementAddQuadCurveToPoint:
                  builder.append(&#39;Q&#39;);
<span class="line-modified">!                 builder.appendECMAScriptNumber(element.points[0].x());</span>
                  builder.append(&#39; &#39;);
<span class="line-modified">!                 builder.appendECMAScriptNumber(element.points[0].y());</span>
                  builder.append(&#39;,&#39;);
<span class="line-modified">!                 builder.appendECMAScriptNumber(element.points[1].x());</span>
                  builder.append(&#39; &#39;);
<span class="line-modified">!                 builder.appendECMAScriptNumber(element.points[1].y());</span>
                  break;
              case PathElementAddCurveToPoint:
                  builder.append(&#39;C&#39;);
<span class="line-modified">!                 builder.appendECMAScriptNumber(element.points[0].x());</span>
                  builder.append(&#39; &#39;);
<span class="line-modified">!                 builder.appendECMAScriptNumber(element.points[0].y());</span>
                  builder.append(&#39;,&#39;);
<span class="line-modified">!                 builder.appendECMAScriptNumber(element.points[1].x());</span>
                  builder.append(&#39; &#39;);
<span class="line-modified">!                 builder.appendECMAScriptNumber(element.points[1].y());</span>
                  builder.append(&#39;,&#39;);
<span class="line-modified">!                 builder.appendECMAScriptNumber(element.points[2].x());</span>
                  builder.append(&#39; &#39;);
<span class="line-modified">!                 builder.appendECMAScriptNumber(element.points[2].y());</span>
                  break;
              case PathElementCloseSubpath:
                  builder.append(&#39;Z&#39;);
                  break;
              }
<span class="line-new-header">--- 58,43 ---</span>
      if (!path.isNull() &amp;&amp; !path.isEmpty()) {
          path.apply([&amp;builder] (const PathElement&amp; element) {
              switch (element.type) {
              case PathElementMoveToPoint:
                  builder.append(&#39;M&#39;);
<span class="line-modified">!                 builder.appendNumber(element.points[0].x());</span>
                  builder.append(&#39; &#39;);
<span class="line-modified">!                 builder.appendNumber(element.points[0].y());</span>
                  break;
              case PathElementAddLineToPoint:
                  builder.append(&#39;L&#39;);
<span class="line-modified">!                 builder.appendNumber(element.points[0].x());</span>
                  builder.append(&#39; &#39;);
<span class="line-modified">!                 builder.appendNumber(element.points[0].y());</span>
                  break;
              case PathElementAddQuadCurveToPoint:
                  builder.append(&#39;Q&#39;);
<span class="line-modified">!                 builder.appendNumber(element.points[0].x());</span>
                  builder.append(&#39; &#39;);
<span class="line-modified">!                 builder.appendNumber(element.points[0].y());</span>
                  builder.append(&#39;,&#39;);
<span class="line-modified">!                 builder.appendNumber(element.points[1].x());</span>
                  builder.append(&#39; &#39;);
<span class="line-modified">!                 builder.appendNumber(element.points[1].y());</span>
                  break;
              case PathElementAddCurveToPoint:
                  builder.append(&#39;C&#39;);
<span class="line-modified">!                 builder.appendNumber(element.points[0].x());</span>
                  builder.append(&#39; &#39;);
<span class="line-modified">!                 builder.appendNumber(element.points[0].y());</span>
                  builder.append(&#39;,&#39;);
<span class="line-modified">!                 builder.appendNumber(element.points[1].x());</span>
                  builder.append(&#39; &#39;);
<span class="line-modified">!                 builder.appendNumber(element.points[1].y());</span>
                  builder.append(&#39;,&#39;);
<span class="line-modified">!                 builder.appendNumber(element.points[2].x());</span>
                  builder.append(&#39; &#39;);
<span class="line-modified">!                 builder.appendNumber(element.points[2].y());</span>
                  break;
              case PathElementCloseSubpath:
                  builder.append(&#39;Z&#39;);
                  break;
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 102,36 ***</span>
      }
  
      return builder.toString();
  }
  
<span class="line-modified">! bool buildSVGPathByteStreamFromSVGPathSegListValues(const SVGPathSegListValues&amp; list, SVGPathByteStream&amp; result, PathParsingMode parsingMode)</span>
  {
<span class="line-modified">!     result.clear();</span>
      if (list.isEmpty())
          return true;
  
      SVGPathSegListSource source(list);
<span class="line-modified">!     return SVGPathParser::parseToByteStream(source, result, parsingMode);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- bool appendSVGPathByteStreamFromSVGPathSeg(RefPtr&lt;SVGPathSeg&gt;&amp;&amp; pathSeg, SVGPathByteStream&amp; result, PathParsingMode parsingMode)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     // FIXME: https://bugs.webkit.org/show_bug.cgi?id=15412 - Implement normalized path segment lists!</span>
<span class="line-removed">-     ASSERT(parsingMode == UnalteredParsing);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     SVGPathSegListValues appendedItemList(PathSegUnalteredRole);</span>
<span class="line-removed">-     appendedItemList.append(WTFMove(pathSeg));</span>
<span class="line-removed">- </span>
<span class="line-removed">-     SVGPathByteStream appendedByteStream;</span>
<span class="line-removed">-     SVGPathSegListSource source(appendedItemList);</span>
<span class="line-removed">-     bool ok = SVGPathParser::parseToByteStream(source, result, parsingMode, false);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (ok)</span>
<span class="line-removed">-         result.append(appendedByteStream);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     return ok;</span>
  }
  
  Path buildPathFromByteStream(const SVGPathByteStream&amp; stream)
  {
      if (stream.isEmpty())
<span class="line-new-header">--- 102,18 ---</span>
      }
  
      return builder.toString();
  }
  
<span class="line-modified">! bool buildSVGPathByteStreamFromSVGPathSegList(const SVGPathSegList&amp; list, SVGPathByteStream&amp; stream, PathParsingMode parsingMode, bool checkForInitialMoveTo)</span>
  {
<span class="line-modified">!     stream.clear();</span>
      if (list.isEmpty())
          return true;
  
      SVGPathSegListSource source(list);
<span class="line-modified">!     return SVGPathParser::parseToByteStream(source, stream, parsingMode, checkForInitialMoveTo);</span>
  }
  
  Path buildPathFromByteStream(const SVGPathByteStream&amp; stream)
  {
      if (stream.isEmpty())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 142,37 ***</span>
      SVGPathByteStreamSource source(stream);
      SVGPathParser::parse(source, builder);
      return path;
  }
  
<span class="line-modified">! bool buildSVGPathSegListValuesFromByteStream(const SVGPathByteStream&amp; stream, SVGPathElement&amp; element, SVGPathSegListValues&amp; result, PathParsingMode parsingMode)</span>
  {
      if (stream.isEmpty())
          return true;
  
<span class="line-modified">!     SVGPathSegListBuilder builder(element, result, parsingMode == NormalizedParsing ? PathSegNormalizedRole : PathSegUnalteredRole);</span>
      SVGPathByteStreamSource source(stream);
<span class="line-modified">!     return SVGPathParser::parse(source, builder, parsingMode);</span>
  }
  
<span class="line-modified">! bool buildStringFromByteStream(const SVGPathByteStream&amp; stream, String&amp; result, PathParsingMode parsingMode)</span>
  {
      if (stream.isEmpty())
          return true;
  
      SVGPathByteStreamSource source(stream);
<span class="line-modified">!     return SVGPathParser::parseToString(source, result, parsingMode);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- bool buildStringFromSVGPathSegListValues(const SVGPathSegListValues&amp; list, String&amp; result, PathParsingMode parsingMode)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     result = String();</span>
<span class="line-removed">-     if (list.isEmpty())</span>
<span class="line-removed">-         return true;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     SVGPathSegListSource source(list);</span>
<span class="line-removed">-     return SVGPathParser::parseToString(source, result, parsingMode);</span>
  }
  
  bool buildSVGPathByteStreamFromString(const String&amp; d, SVGPathByteStream&amp; result, PathParsingMode parsingMode)
  {
      result.clear();
<span class="line-new-header">--- 124,27 ---</span>
      SVGPathByteStreamSource source(stream);
      SVGPathParser::parse(source, builder);
      return path;
  }
  
<span class="line-modified">! bool buildSVGPathSegListFromByteStream(const SVGPathByteStream&amp; stream, SVGPathSegList&amp; list, PathParsingMode mode)</span>
  {
      if (stream.isEmpty())
          return true;
  
<span class="line-modified">!     SVGPathSegListBuilder builder(list);</span>
      SVGPathByteStreamSource source(stream);
<span class="line-modified">!     return SVGPathParser::parse(source, builder, mode);</span>
  }
  
<span class="line-modified">! bool buildStringFromByteStream(const SVGPathByteStream&amp; stream, String&amp; result, PathParsingMode parsingMode, bool checkForInitialMoveTo)</span>
  {
      if (stream.isEmpty())
          return true;
  
      SVGPathByteStreamSource source(stream);
<span class="line-modified">!     return SVGPathParser::parseToString(source, result, parsingMode, checkForInitialMoveTo);</span>
  }
  
  bool buildSVGPathByteStreamFromString(const String&amp; d, SVGPathByteStream&amp; result, PathParsingMode parsingMode)
  {
      result.clear();
</pre>
<center><a href="SVGPathStringBuilder.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SVGPathUtilities.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>