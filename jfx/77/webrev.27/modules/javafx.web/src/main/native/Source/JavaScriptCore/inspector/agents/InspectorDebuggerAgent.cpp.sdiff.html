<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/inspector/agents/InspectorDebuggerAgent.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="InspectorConsoleAgent.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="InspectorDebuggerAgent.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/inspector/agents/InspectorDebuggerAgent.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  45 #include &lt;wtf/NeverDestroyed.h&gt;
  46 #include &lt;wtf/Stopwatch.h&gt;
  47 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
  48 #include &lt;wtf/text/WTFString.h&gt;
  49 
  50 namespace Inspector {
  51 
  52 const char* InspectorDebuggerAgent::backtraceObjectGroup = &quot;backtrace&quot;;
  53 
  54 // Objects created and retained by evaluating breakpoint actions are put into object groups
  55 // according to the breakpoint action identifier assigned by the frontend. A breakpoint may
  56 // have several object groups, and objects from several backend breakpoint action instances may
  57 // create objects in the same group.
  58 static String objectGroupForBreakpointAction(const ScriptBreakpointAction&amp; action)
  59 {
  60     return makeString(&quot;breakpoint-action-&quot;, action.identifier);
  61 }
  62 
  63 InspectorDebuggerAgent::InspectorDebuggerAgent(AgentContext&amp; context)
  64     : InspectorAgentBase(&quot;Debugger&quot;_s)
<span class="line-modified">  65     , m_injectedScriptManager(context.injectedScriptManager)</span>
<span class="line-removed">  66     , m_frontendDispatcher(std::make_unique&lt;DebuggerFrontendDispatcher&gt;(context.frontendRouter))</span>
  67     , m_backendDispatcher(DebuggerBackendDispatcher::create(context.backendDispatcher, this))
  68     , m_scriptDebugServer(context.environment.scriptDebugServer())
<span class="line-modified">  69     , m_continueToLocationBreakpointID(JSC::noBreakpointID)</span>
  70 {
  71     // FIXME: make breakReason optional so that there was no need to init it with &quot;other&quot;.
  72     clearBreakDetails();
  73 }
  74 
<span class="line-modified">  75 InspectorDebuggerAgent::~InspectorDebuggerAgent()</span>
<span class="line-removed">  76 {</span>
<span class="line-removed">  77 }</span>
  78 
  79 void InspectorDebuggerAgent::didCreateFrontendAndBackend(FrontendRouter*, BackendDispatcher*)
  80 {
  81 }
  82 
  83 void InspectorDebuggerAgent::willDestroyFrontendAndBackend(DisconnectReason reason)
  84 {
<span class="line-modified">  85     bool skipRecompile = reason == DisconnectReason::InspectedTargetDestroyed;</span>
<span class="line-removed">  86     disable(skipRecompile);</span>
  87 }
  88 
  89 void InspectorDebuggerAgent::enable()
  90 {
  91     if (m_enabled)
  92         return;
  93 
<span class="line-modified">  94     m_scriptDebugServer.addListener(this);</span>
  95 
<span class="line-modified">  96     if (m_listener)</span>
<span class="line-removed">  97         m_listener-&gt;debuggerWasEnabled();</span>
  98 
<span class="line-modified">  99     m_enabled = true;</span>

 100 }
 101 
 102 void InspectorDebuggerAgent::disable(bool isBeingDestroyed)
 103 {
 104     if (!m_enabled)
 105         return;
 106 



 107     m_scriptDebugServer.removeListener(this, isBeingDestroyed);

 108     clearInspectorBreakpointState();
 109 
 110     if (!isBeingDestroyed)
 111         m_scriptDebugServer.deactivateBreakpoints();
 112 
 113     ASSERT(m_javaScriptBreakpoints.isEmpty());
 114 
<span class="line-removed"> 115     if (m_listener)</span>
<span class="line-removed"> 116         m_listener-&gt;debuggerWasDisabled();</span>
<span class="line-removed"> 117 </span>
 118     clearAsyncStackTraceData();
 119 
 120     m_pauseOnAssertionFailures = false;

 121 
 122     m_enabled = false;
 123 }
 124 
 125 void InspectorDebuggerAgent::enable(ErrorString&amp;)
 126 {
 127     enable();
 128 }
 129 
 130 void InspectorDebuggerAgent::disable(ErrorString&amp;)
 131 {
 132     disable(false);
 133 }
 134 
 135 bool InspectorDebuggerAgent::breakpointsActive() const
 136 {
 137     return m_scriptDebugServer.breakpointsActive();
 138 }
 139 
 140 void InspectorDebuggerAgent::setAsyncStackTraceDepth(ErrorString&amp; errorString, int depth)
 141 {
 142     if (m_asyncStackTraceDepth == depth)
 143         return;
 144 
 145     if (depth &lt; 0) {
<span class="line-modified"> 146         errorString = &quot;depth must be a positive number.&quot;_s;</span>
 147         return;
 148     }
 149 
 150     m_asyncStackTraceDepth = depth;
 151 
 152     if (!m_asyncStackTraceDepth)
 153         clearAsyncStackTraceData();
 154 }
 155 
 156 void InspectorDebuggerAgent::setBreakpointsActive(ErrorString&amp;, bool active)
 157 {
 158     if (active)
 159         m_scriptDebugServer.activateBreakpoints();
 160     else
 161         m_scriptDebugServer.deactivateBreakpoints();
 162 }
 163 
 164 bool InspectorDebuggerAgent::isPaused() const
 165 {
 166     return m_scriptDebugServer.isPaused();
</pre>
<hr />
<pre>
 359         return true;
 360     }
 361 
 362     return false;
 363 }
 364 
 365 bool InspectorDebuggerAgent::breakpointActionsFromProtocol(ErrorString&amp; errorString, RefPtr&lt;JSON::Array&gt;&amp; actions, BreakpointActions* result)
 366 {
 367     if (!actions)
 368         return true;
 369 
 370     unsigned actionsLength = actions-&gt;length();
 371     if (!actionsLength)
 372         return true;
 373 
 374     result-&gt;reserveCapacity(actionsLength);
 375     for (unsigned i = 0; i &lt; actionsLength; ++i) {
 376         RefPtr&lt;JSON::Value&gt; value = actions-&gt;get(i);
 377         RefPtr&lt;JSON::Object&gt; object;
 378         if (!value-&gt;asObject(object)) {
<span class="line-modified"> 379             errorString = &quot;BreakpointAction of incorrect type, expected object&quot;_s;</span>
 380             return false;
 381         }
 382 
 383         String typeString;
 384         if (!object-&gt;getString(&quot;type&quot;_s, typeString)) {
<span class="line-modified"> 385             errorString = &quot;BreakpointAction had type missing&quot;_s;</span>
 386             return false;
 387         }
 388 
 389         ScriptBreakpointActionType type;
 390         if (!breakpointActionTypeForString(typeString, &amp;type)) {
<span class="line-modified"> 391             errorString = &quot;BreakpointAction had unknown type&quot;_s;</span>
 392             return false;
 393         }
 394 
 395         // Specifying an identifier is optional. They are used to correlate probe samples
 396         // in the frontend across multiple backend probe actions and segregate object groups.
 397         int identifier = 0;
 398         object-&gt;getInteger(&quot;id&quot;_s, identifier);
 399 
 400         String data;
 401         object-&gt;getString(&quot;data&quot;_s, data);
 402 
 403         result-&gt;append(ScriptBreakpointAction(type, identifier, data));
 404     }
 405 
 406     return true;
 407 }
 408 
 409 static RefPtr&lt;Protocol::Debugger::Location&gt; buildDebuggerLocation(const JSC::Breakpoint&amp; breakpoint)
 410 {
 411     ASSERT(breakpoint.resolved);
 412 
 413     auto location = Protocol::Debugger::Location::create()
 414         .setScriptId(String::number(breakpoint.sourceID))
 415         .setLineNumber(breakpoint.line)
 416         .release();
 417     location-&gt;setColumnNumber(breakpoint.column);
 418 
<span class="line-modified"> 419     return WTFMove(location);</span>
 420 }
 421 
 422 static bool parseLocation(ErrorString&amp; errorString, const JSON::Object&amp; location, JSC::SourceID&amp; sourceID, unsigned&amp; lineNumber, unsigned&amp; columnNumber)
 423 {






 424     String scriptIDStr;
<span class="line-modified"> 425     if (!location.getString(&quot;scriptId&quot;_s, scriptIDStr) || !location.getInteger(&quot;lineNumber&quot;_s, lineNumber)) {</span>
 426         sourceID = JSC::noSourceID;
<span class="line-modified"> 427         errorString = &quot;scriptId and lineNumber are required.&quot;_s;</span>
 428         return false;
 429     }
 430 
 431     sourceID = scriptIDStr.toIntPtr();
 432     columnNumber = 0;
 433     location.getInteger(&quot;columnNumber&quot;_s, columnNumber);
 434     return true;
 435 }
 436 
 437 void InspectorDebuggerAgent::setBreakpointByUrl(ErrorString&amp; errorString, int lineNumber, const String* optionalURL, const String* optionalURLRegex, const int* optionalColumnNumber, const JSON::Object* options, Protocol::Debugger::BreakpointId* outBreakpointIdentifier, RefPtr&lt;JSON::ArrayOf&lt;Protocol::Debugger::Location&gt;&gt;&amp; locations)
 438 {
 439     locations = JSON::ArrayOf&lt;Protocol::Debugger::Location&gt;::create();
 440     if (!optionalURL == !optionalURLRegex) {
<span class="line-modified"> 441         errorString = &quot;Either url or urlRegex must be specified.&quot;_s;</span>
 442         return;
 443     }
 444 
 445     String url = optionalURL ? *optionalURL : *optionalURLRegex;
 446     int columnNumber = optionalColumnNumber ? *optionalColumnNumber : 0;
 447     bool isRegex = optionalURLRegex;
 448 
 449     String breakpointIdentifier = makeString(isRegex ? &quot;/&quot; : &quot;&quot;, url, isRegex ? &quot;/:&quot; : &quot;:&quot;, lineNumber, &#39;:&#39;, columnNumber);
 450     if (m_javaScriptBreakpoints.contains(breakpointIdentifier)) {
<span class="line-modified"> 451         errorString = &quot;Breakpoint at specified location already exists.&quot;_s;</span>
 452         return;
 453     }
 454 
 455     String condition = emptyString();
 456     bool autoContinue = false;
 457     unsigned ignoreCount = 0;
 458     RefPtr&lt;JSON::Array&gt; actions;
 459     if (options) {
 460         options-&gt;getString(&quot;condition&quot;_s, condition);
 461         options-&gt;getBoolean(&quot;autoContinue&quot;_s, autoContinue);
 462         options-&gt;getArray(&quot;actions&quot;_s, actions);
 463         options-&gt;getInteger(&quot;ignoreCount&quot;_s, ignoreCount);
 464     }
 465 
 466     BreakpointActions breakpointActions;
 467     if (!breakpointActionsFromProtocol(errorString, actions, &amp;breakpointActions))
 468         return;
 469 
 470     m_javaScriptBreakpoints.set(breakpointIdentifier, buildObjectForBreakpointCookie(url, lineNumber, columnNumber, condition, actions, isRegex, autoContinue, ignoreCount));
 471 
</pre>
<hr />
<pre>
 503     if (!parseLocation(errorString, location, sourceID, lineNumber, columnNumber))
 504         return;
 505 
 506     String condition = emptyString();
 507     bool autoContinue = false;
 508     unsigned ignoreCount = 0;
 509     RefPtr&lt;JSON::Array&gt; actions;
 510     if (options) {
 511         options-&gt;getString(&quot;condition&quot;_s, condition);
 512         options-&gt;getBoolean(&quot;autoContinue&quot;_s, autoContinue);
 513         options-&gt;getArray(&quot;actions&quot;_s, actions);
 514         options-&gt;getInteger(&quot;ignoreCount&quot;_s, ignoreCount);
 515     }
 516 
 517     BreakpointActions breakpointActions;
 518     if (!breakpointActionsFromProtocol(errorString, actions, &amp;breakpointActions))
 519         return;
 520 
 521     auto scriptIterator = m_scripts.find(sourceID);
 522     if (scriptIterator == m_scripts.end()) {
<span class="line-modified"> 523         errorString = makeString(&quot;No script for id: &quot;_s, sourceID);</span>
 524         return;
 525     }
 526 
 527     Script&amp; script = scriptIterator-&gt;value;
 528     JSC::Breakpoint breakpoint(sourceID, lineNumber, columnNumber, condition, autoContinue, ignoreCount);
 529     resolveBreakpoint(script, breakpoint);
 530     if (!breakpoint.resolved) {
 531         errorString = &quot;Could not resolve breakpoint&quot;_s;
 532         return;
 533     }
 534 
 535     bool existing;
 536     setBreakpoint(breakpoint, existing);
 537     if (existing) {
<span class="line-modified"> 538         errorString = &quot;Breakpoint at specified location already exists&quot;_s;</span>
 539         return;
 540     }
 541 
 542     String breakpointIdentifier = makeString(sourceID, &#39;:&#39;, breakpoint.line, &#39;:&#39;, breakpoint.column);
 543     ScriptBreakpoint scriptBreakpoint(breakpoint.line, breakpoint.column, condition, breakpointActions, autoContinue, ignoreCount);
 544     didSetBreakpoint(breakpoint, breakpointIdentifier, scriptBreakpoint);
 545 
 546     actualLocation = buildDebuggerLocation(breakpoint);
 547     *outBreakpointIdentifier = breakpointIdentifier;
 548 }
 549 
 550 void InspectorDebuggerAgent::didSetBreakpoint(const JSC::Breakpoint&amp; breakpoint, const String&amp; breakpointIdentifier, const ScriptBreakpoint&amp; scriptBreakpoint)
 551 {
 552     JSC::BreakpointID id = breakpoint.id;
 553     m_scriptDebugServer.setBreakpointActions(id, scriptBreakpoint);
 554 
 555     auto debugServerBreakpointIDsIterator = m_breakpointIdentifierToDebugServerBreakpointIDs.find(breakpointIdentifier);
 556     if (debugServerBreakpointIDsIterator == m_breakpointIdentifierToDebugServerBreakpointIDs.end())
 557         debugServerBreakpointIDsIterator = m_breakpointIdentifierToDebugServerBreakpointIDs.set(breakpointIdentifier, Vector&lt;JSC::BreakpointID&gt;()).iterator;
 558     debugServerBreakpointIDsIterator-&gt;value.append(id);
</pre>
<hr />
<pre>
 606 void InspectorDebuggerAgent::continueToLocation(ErrorString&amp; errorString, const JSON::Object&amp; location)
 607 {
 608     if (!assertPaused(errorString))
 609         return;
 610 
 611     if (m_continueToLocationBreakpointID != JSC::noBreakpointID) {
 612         m_scriptDebugServer.removeBreakpoint(m_continueToLocationBreakpointID);
 613         m_continueToLocationBreakpointID = JSC::noBreakpointID;
 614     }
 615 
 616     JSC::SourceID sourceID;
 617     unsigned lineNumber;
 618     unsigned columnNumber;
 619     if (!parseLocation(errorString, location, sourceID, lineNumber, columnNumber))
 620         return;
 621 
 622     auto scriptIterator = m_scripts.find(sourceID);
 623     if (scriptIterator == m_scripts.end()) {
 624         m_scriptDebugServer.continueProgram();
 625         m_frontendDispatcher-&gt;resumed();
<span class="line-modified"> 626         errorString = makeString(&quot;No script for id: &quot;_s, sourceID);</span>
 627         return;
 628     }
 629 
 630     String condition;
 631     bool autoContinue = false;
 632     unsigned ignoreCount = 0;
 633     JSC::Breakpoint breakpoint(sourceID, lineNumber, columnNumber, condition, autoContinue, ignoreCount);
 634     Script&amp; script = scriptIterator-&gt;value;
 635     resolveBreakpoint(script, breakpoint);
 636     if (!breakpoint.resolved) {
 637         m_scriptDebugServer.continueProgram();
 638         m_frontendDispatcher-&gt;resumed();
 639         errorString = &quot;Could not resolve breakpoint&quot;_s;
 640         return;
 641     }
 642 
 643     bool existing;
 644     setBreakpoint(breakpoint, existing);
 645     if (existing) {
 646         // There is an existing breakpoint at this location. Instead of
 647         // acting like a series of steps, just resume and we will either
 648         // hit this new breakpoint or not.
 649         m_scriptDebugServer.continueProgram();
 650         m_frontendDispatcher-&gt;resumed();
 651         return;
 652     }
 653 
 654     m_continueToLocationBreakpointID = breakpoint.id;
 655 
 656     // Treat this as a series of steps until reaching the new breakpoint.
 657     // So don&#39;t issue a resumed event unless we exit the VM without pausing.
 658     willStepAndMayBecomeIdle();
 659     m_scriptDebugServer.continueProgram();
 660 }
 661 
<span class="line-modified"> 662 void InspectorDebuggerAgent::searchInContent(ErrorString&amp; error, const String&amp; scriptIDStr, const String&amp; query, const bool* optionalCaseSensitive, const bool* optionalIsRegex, RefPtr&lt;JSON::ArrayOf&lt;Protocol::GenericTypes::SearchMatch&gt;&gt;&amp; results)</span>
 663 {
 664     JSC::SourceID sourceID = scriptIDStr.toIntPtr();
 665     auto it = m_scripts.find(sourceID);
 666     if (it == m_scripts.end()) {
<span class="line-modified"> 667         error = makeString(&quot;No script for id: &quot;_s, scriptIDStr);</span>
 668         return;
 669     }
 670 
 671     bool isRegex = optionalIsRegex ? *optionalIsRegex : false;
 672     bool caseSensitive = optionalCaseSensitive ? *optionalCaseSensitive : false;
 673     results = ContentSearchUtilities::searchInTextByLines(it-&gt;value.source, query, caseSensitive, isRegex);
 674 }
 675 
<span class="line-modified"> 676 void InspectorDebuggerAgent::getScriptSource(ErrorString&amp; error, const String&amp; scriptIDStr, String* scriptSource)</span>
 677 {
 678     JSC::SourceID sourceID = scriptIDStr.toIntPtr();
<span class="line-modified"> 679     ScriptsMap::iterator it = m_scripts.find(sourceID);</span>
 680     if (it != m_scripts.end())
 681         *scriptSource = it-&gt;value.source;
 682     else
<span class="line-modified"> 683         error = makeString(&quot;No script for id: &quot;_s, scriptIDStr);</span>
 684 }
 685 
 686 void InspectorDebuggerAgent::getFunctionDetails(ErrorString&amp; errorString, const String&amp; functionId, RefPtr&lt;Protocol::Debugger::FunctionDetails&gt;&amp; details)
 687 {
 688     InjectedScript injectedScript = m_injectedScriptManager.injectedScriptForObjectId(functionId);
 689     if (injectedScript.hasNoValue()) {
<span class="line-modified"> 690         errorString = &quot;Function object id is obsolete&quot;_s;</span>
 691         return;
 692     }
 693 
 694     injectedScript.getFunctionDetails(errorString, functionId, details);
 695 }
 696 
 697 void InspectorDebuggerAgent::schedulePauseOnNextStatement(DebuggerFrontendDispatcher::Reason breakReason, RefPtr&lt;JSON::Object&gt;&amp;&amp; data)
 698 {
 699     if (m_javaScriptPauseScheduled)
 700         return;
 701 
 702     m_javaScriptPauseScheduled = true;
 703 
 704     m_breakReason = breakReason;
<span class="line-modified"> 705     m_breakAuxData = WTFMove(data);</span>
 706 
 707     JSC::JSLockHolder locker(m_scriptDebugServer.vm());
 708     m_scriptDebugServer.setPauseOnNextStatement(true);
 709 }
 710 
 711 void InspectorDebuggerAgent::cancelPauseOnNextStatement()
 712 {
 713     if (!m_javaScriptPauseScheduled)
 714         return;
 715 
 716     m_javaScriptPauseScheduled = false;
 717 
 718     clearBreakDetails();
 719     m_scriptDebugServer.setPauseOnNextStatement(false);
 720     m_enablePauseWhenIdle = false;
 721 }
 722 
 723 void InspectorDebuggerAgent::pause(ErrorString&amp;)
 724 {
 725     schedulePauseOnNextStatement(DebuggerFrontendDispatcher::Reason::PauseOnNextStatement, nullptr);
 726 }
 727 
 728 void InspectorDebuggerAgent::resume(ErrorString&amp; errorString)
 729 {
 730     if (!m_pausedScriptState &amp;&amp; !m_javaScriptPauseScheduled) {
<span class="line-modified"> 731         errorString = &quot;Was not paused or waiting to pause&quot;_s;</span>
 732         return;
 733     }
 734 
 735     cancelPauseOnNextStatement();
 736     m_scriptDebugServer.continueProgram();
 737     m_conditionToDispatchResumed = ShouldDispatchResumed::WhenContinued;
 738 }
 739 
 740 void InspectorDebuggerAgent::stepOver(ErrorString&amp; errorString)
 741 {
 742     if (!assertPaused(errorString))
 743         return;
 744 
 745     willStepAndMayBecomeIdle();
 746     m_scriptDebugServer.stepOverStatement();
 747 }
 748 
 749 void InspectorDebuggerAgent::stepInto(ErrorString&amp; errorString)
 750 {
 751     if (!assertPaused(errorString))
</pre>
<hr />
<pre>
 795     }
 796 
 797     m_conditionToDispatchResumed = ShouldDispatchResumed::No;
 798 
 799     if (m_enablePauseWhenIdle) {
 800         ErrorString ignored;
 801         pause(ignored);
 802     }
 803 }
 804 
 805 void InspectorDebuggerAgent::setPauseOnExceptions(ErrorString&amp; errorString, const String&amp; stringPauseState)
 806 {
 807     JSC::Debugger::PauseOnExceptionsState pauseState;
 808     if (stringPauseState == &quot;none&quot;)
 809         pauseState = JSC::Debugger::DontPauseOnExceptions;
 810     else if (stringPauseState == &quot;all&quot;)
 811         pauseState = JSC::Debugger::PauseOnAllExceptions;
 812     else if (stringPauseState == &quot;uncaught&quot;)
 813         pauseState = JSC::Debugger::PauseOnUncaughtExceptions;
 814     else {
<span class="line-modified"> 815         errorString = makeString(&quot;Unknown pause on exceptions mode: &quot;_s, stringPauseState);</span>
 816         return;
 817     }
 818 
 819     m_scriptDebugServer.setPauseOnExceptionsState(static_cast&lt;JSC::Debugger::PauseOnExceptionsState&gt;(pauseState));
 820     if (m_scriptDebugServer.pauseOnExceptionsState() != pauseState)
 821         errorString = &quot;Internal error. Could not change pause on exceptions state&quot;_s;
 822 }
 823 
 824 void InspectorDebuggerAgent::setPauseOnAssertions(ErrorString&amp;, bool enabled)
 825 {
 826     m_pauseOnAssertionFailures = enabled;
 827 }
 828 
<span class="line-modified"> 829 void InspectorDebuggerAgent::evaluateOnCallFrame(ErrorString&amp; errorString, const String&amp; callFrameId, const String&amp; expression, const String* objectGroup, const bool* includeCommandLineAPI, const bool* doNotPauseOnExceptionsAndMuteConsole, const bool* returnByValue, const bool* generatePreview, const bool* saveResult, RefPtr&lt;Protocol::Runtime::RemoteObject&gt;&amp; result, Optional&lt;bool&gt;&amp; wasThrown, Optional&lt;int&gt;&amp; savedResultIndex)</span>





 830 {
<span class="line-modified"> 831     if (!m_currentCallStack) {</span>
<span class="line-removed"> 832         errorString = &quot;Not paused&quot;_s;</span>
 833         return;
<span class="line-removed"> 834     }</span>
 835 
 836     InjectedScript injectedScript = m_injectedScriptManager.injectedScriptForObjectId(callFrameId);
 837     if (injectedScript.hasNoValue()) {
<span class="line-modified"> 838         errorString = &quot;Could not find InjectedScript for callFrameId&quot;_s;</span>
 839         return;
 840     }
 841 
 842     auto pauseState = m_scriptDebugServer.pauseOnExceptionsState();
 843     bool pauseAndMute = doNotPauseOnExceptionsAndMuteConsole &amp;&amp; *doNotPauseOnExceptionsAndMuteConsole;
 844     if (pauseAndMute) {
 845         if (pauseState != JSC::Debugger::DontPauseOnExceptions)
 846             m_scriptDebugServer.setPauseOnExceptionsState(JSC::Debugger::DontPauseOnExceptions);
 847         muteConsole();
 848     }
 849 
 850     injectedScript.evaluateOnCallFrame(errorString, m_currentCallStack.get(), callFrameId, expression,
 851         objectGroup ? *objectGroup : emptyString(), includeCommandLineAPI &amp;&amp; *includeCommandLineAPI, returnByValue &amp;&amp; *returnByValue, generatePreview &amp;&amp; *generatePreview, saveResult &amp;&amp; *saveResult,
 852         result, wasThrown, savedResultIndex);
 853 
 854     if (pauseAndMute) {
 855         unmuteConsole();
 856         m_scriptDebugServer.setPauseOnExceptionsState(pauseState);
 857     }
 858 }
 859 
<span class="line-removed"> 860 void InspectorDebuggerAgent::setOverlayMessage(ErrorString&amp;, const String*)</span>
<span class="line-removed"> 861 {</span>
<span class="line-removed"> 862 }</span>
<span class="line-removed"> 863 </span>
 864 void InspectorDebuggerAgent::scriptExecutionBlockedByCSP(const String&amp; directiveText)
 865 {
 866     if (m_scriptDebugServer.pauseOnExceptionsState() != JSC::Debugger::DontPauseOnExceptions)
 867         breakProgram(DebuggerFrontendDispatcher::Reason::CSPViolation, buildCSPViolationPauseReason(directiveText));
 868 }
 869 
 870 Ref&lt;JSON::ArrayOf&lt;Protocol::Debugger::CallFrame&gt;&gt; InspectorDebuggerAgent::currentCallFrames(const InjectedScript&amp; injectedScript)
 871 {
 872     ASSERT(!injectedScript.hasNoValue());
 873     if (injectedScript.hasNoValue())
 874         return JSON::ArrayOf&lt;Protocol::Debugger::CallFrame&gt;::create();
 875 
 876     return injectedScript.wrapCallFrames(m_currentCallStack.get());
 877 }
 878 
 879 String InspectorDebuggerAgent::sourceMapURLForScript(const Script&amp; script)
 880 {
 881     return script.sourceMappingURL;
 882 }
 883 
</pre>
<hr />
<pre>
 949         if (!breakpoint.resolved)
 950             continue;
 951 
 952         bool existing;
 953         setBreakpoint(breakpoint, existing);
 954         if (existing)
 955             continue;
 956 
 957         String breakpointIdentifier = entry.key;
 958         didSetBreakpoint(breakpoint, breakpointIdentifier, scriptBreakpoint);
 959 
 960         m_frontendDispatcher-&gt;breakpointResolved(breakpointIdentifier, buildDebuggerLocation(breakpoint));
 961     }
 962 }
 963 
 964 void InspectorDebuggerAgent::failedToParseSource(const String&amp; url, const String&amp; data, int firstLine, int errorLine, const String&amp; errorMessage)
 965 {
 966     m_frontendDispatcher-&gt;scriptFailedToParse(url, data, firstLine, errorLine, errorMessage);
 967 }
 968 


















 969 void InspectorDebuggerAgent::didPause(JSC::ExecState&amp; scriptState, JSC::JSValue callFrames, JSC::JSValue exceptionOrCaughtValue)
 970 {
 971     ASSERT(!m_pausedScriptState);
 972     m_pausedScriptState = &amp;scriptState;
 973     m_currentCallStack = { scriptState.vm(), callFrames };
 974 
 975     InjectedScript injectedScript = m_injectedScriptManager.injectedScriptFor(&amp;scriptState);
 976 
 977     // If a high level pause pause reason is not already set, try to infer a reason from the debugger.
 978     if (m_breakReason == DebuggerFrontendDispatcher::Reason::Other) {
 979         switch (m_scriptDebugServer.reasonForPause()) {
 980         case JSC::Debugger::PausedForBreakpoint: {
 981             JSC::BreakpointID debuggerBreakpointId = m_scriptDebugServer.pausingBreakpointID();
 982             if (debuggerBreakpointId != m_continueToLocationBreakpointID) {
 983                 m_breakReason = DebuggerFrontendDispatcher::Reason::Breakpoint;
<span class="line-modified"> 984                 m_breakAuxData = buildBreakpointPauseReason(debuggerBreakpointId);</span>
 985             }
 986             break;
 987         }
 988         case JSC::Debugger::PausedForDebuggerStatement:
 989             m_breakReason = DebuggerFrontendDispatcher::Reason::DebuggerStatement;
<span class="line-modified"> 990             m_breakAuxData = nullptr;</span>
 991             break;
 992         case JSC::Debugger::PausedForException:
 993             m_breakReason = DebuggerFrontendDispatcher::Reason::Exception;
<span class="line-modified"> 994             m_breakAuxData = buildExceptionPauseReason(exceptionOrCaughtValue, injectedScript);</span>
 995             break;
 996         case JSC::Debugger::PausedAtStatement:
 997         case JSC::Debugger::PausedAtExpression:
 998         case JSC::Debugger::PausedBeforeReturn:
 999         case JSC::Debugger::PausedAtEndOfProgram:
1000             // Pause was just stepping. Nothing to report.
1001             break;
1002         case JSC::Debugger::NotPaused:
1003             ASSERT_NOT_REACHED();
1004             break;
1005         }
1006     }
1007 
1008     // Set $exception to the exception or caught value.
1009     if (exceptionOrCaughtValue &amp;&amp; !injectedScript.hasNoValue()) {
1010         injectedScript.setExceptionValue(exceptionOrCaughtValue);
1011         m_hasExceptionValue = true;
1012     }
1013 
1014     m_conditionToDispatchResumed = ShouldDispatchResumed::No;
1015     m_enablePauseWhenIdle = false;
1016 
1017     RefPtr&lt;Protocol::Console::StackTrace&gt; asyncStackTrace;
1018     if (m_currentAsyncCallIdentifier) {
1019         auto it = m_pendingAsyncCalls.find(m_currentAsyncCallIdentifier.value());
1020         if (it != m_pendingAsyncCalls.end())
1021             asyncStackTrace = it-&gt;value-&gt;buildInspectorObject();
1022     }
1023 
<span class="line-modified">1024     m_frontendDispatcher-&gt;paused(currentCallFrames(injectedScript), m_breakReason, m_breakAuxData, asyncStackTrace);</span>
1025 
1026     m_javaScriptPauseScheduled = false;
1027 
1028     if (m_continueToLocationBreakpointID != JSC::noBreakpointID) {
1029         m_scriptDebugServer.removeBreakpoint(m_continueToLocationBreakpointID);
1030         m_continueToLocationBreakpointID = JSC::noBreakpointID;
1031     }
1032 
1033     RefPtr&lt;Stopwatch&gt; stopwatch = m_injectedScriptManager.inspectorEnvironment().executionStopwatch();
1034     if (stopwatch &amp;&amp; stopwatch-&gt;isActive()) {
1035         stopwatch-&gt;stop();
1036         m_didPauseStopwatch = true;
1037     }
1038 }
1039 
1040 void InspectorDebuggerAgent::breakpointActionSound(int breakpointActionIdentifier)
1041 {
1042     m_frontendDispatcher-&gt;playBreakpointActionSound(breakpointActionIdentifier);
1043 }
1044 
</pre>
<hr />
<pre>
1059 void InspectorDebuggerAgent::didContinue()
1060 {
1061     if (m_didPauseStopwatch) {
1062         m_didPauseStopwatch = false;
1063         m_injectedScriptManager.inspectorEnvironment().executionStopwatch()-&gt;start();
1064     }
1065 
1066     m_pausedScriptState = nullptr;
1067     m_currentCallStack = { };
1068     m_injectedScriptManager.releaseObjectGroup(InspectorDebuggerAgent::backtraceObjectGroup);
1069     clearBreakDetails();
1070     clearExceptionValue();
1071 
1072     if (m_conditionToDispatchResumed == ShouldDispatchResumed::WhenContinued)
1073         m_frontendDispatcher-&gt;resumed();
1074 }
1075 
1076 void InspectorDebuggerAgent::breakProgram(DebuggerFrontendDispatcher::Reason breakReason, RefPtr&lt;JSON::Object&gt;&amp;&amp; data)
1077 {
1078     m_breakReason = breakReason;
<span class="line-modified">1079     m_breakAuxData = WTFMove(data);</span>
1080     m_scriptDebugServer.breakProgram();
1081 }
1082 
1083 void InspectorDebuggerAgent::clearInspectorBreakpointState()
1084 {
<span class="line-modified">1085     ErrorString dummyError;</span>
1086     for (const String&amp; identifier : copyToVector(m_breakpointIdentifierToDebugServerBreakpointIDs.keys()))
<span class="line-modified">1087         removeBreakpoint(dummyError, identifier);</span>
1088 
1089     m_javaScriptBreakpoints.clear();
1090 
1091     clearDebuggerBreakpointState();
1092 }
1093 
1094 void InspectorDebuggerAgent::clearDebuggerBreakpointState()
1095 {
1096     {
1097         JSC::JSLockHolder holder(m_scriptDebugServer.vm());
1098         m_scriptDebugServer.clearBreakpointActions();
1099         m_scriptDebugServer.clearBreakpoints();
1100         m_scriptDebugServer.clearBlacklist();
1101     }
1102 
1103     m_pausedScriptState = nullptr;
1104     m_currentCallStack = { };
1105     m_scripts.clear();
1106     m_breakpointIdentifierToDebugServerBreakpointIDs.clear();
1107     m_debuggerBreakpointIdentifierToInspectorBreakpointIdentifier.clear();
</pre>
<hr />
<pre>
1113     if (isPaused()) {
1114         m_scriptDebugServer.continueProgram();
1115         m_frontendDispatcher-&gt;resumed();
1116     }
1117 }
1118 
1119 void InspectorDebuggerAgent::didClearGlobalObject()
1120 {
1121     // Clear breakpoints from the debugger, but keep the inspector&#39;s model of which
1122     // pages have what breakpoints, as the mapping is only sent to DebuggerAgent once.
1123     clearDebuggerBreakpointState();
1124 
1125     clearAsyncStackTraceData();
1126 
1127     m_frontendDispatcher-&gt;globalObjectCleared();
1128 }
1129 
1130 bool InspectorDebuggerAgent::assertPaused(ErrorString&amp; errorString)
1131 {
1132     if (!m_pausedScriptState) {
<span class="line-modified">1133         errorString = &quot;Can only perform operation while paused.&quot;_s;</span>
1134         return false;
1135     }
1136 
1137     return true;
1138 }
1139 
1140 void InspectorDebuggerAgent::clearBreakDetails()
1141 {
1142     m_breakReason = DebuggerFrontendDispatcher::Reason::Other;
<span class="line-modified">1143     m_breakAuxData = nullptr;</span>
1144 }
1145 
1146 void InspectorDebuggerAgent::clearExceptionValue()
1147 {
1148     if (m_hasExceptionValue) {
1149         m_injectedScriptManager.clearExceptionValue();
1150         m_hasExceptionValue = false;
1151     }
1152 }
1153 
1154 void InspectorDebuggerAgent::clearAsyncStackTraceData()
1155 {
1156     m_pendingAsyncCalls.clear();
1157     m_currentAsyncCallIdentifier = WTF::nullopt;
1158 
1159     didClearAsyncStackTraceData();
1160 }
1161 
1162 } // namespace Inspector
</pre>
</td>
<td>
<hr />
<pre>
  45 #include &lt;wtf/NeverDestroyed.h&gt;
  46 #include &lt;wtf/Stopwatch.h&gt;
  47 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
  48 #include &lt;wtf/text/WTFString.h&gt;
  49 
  50 namespace Inspector {
  51 
  52 const char* InspectorDebuggerAgent::backtraceObjectGroup = &quot;backtrace&quot;;
  53 
  54 // Objects created and retained by evaluating breakpoint actions are put into object groups
  55 // according to the breakpoint action identifier assigned by the frontend. A breakpoint may
  56 // have several object groups, and objects from several backend breakpoint action instances may
  57 // create objects in the same group.
  58 static String objectGroupForBreakpointAction(const ScriptBreakpointAction&amp; action)
  59 {
  60     return makeString(&quot;breakpoint-action-&quot;, action.identifier);
  61 }
  62 
  63 InspectorDebuggerAgent::InspectorDebuggerAgent(AgentContext&amp; context)
  64     : InspectorAgentBase(&quot;Debugger&quot;_s)
<span class="line-modified">  65     , m_frontendDispatcher(makeUnique&lt;DebuggerFrontendDispatcher&gt;(context.frontendRouter))</span>

  66     , m_backendDispatcher(DebuggerBackendDispatcher::create(context.backendDispatcher, this))
  67     , m_scriptDebugServer(context.environment.scriptDebugServer())
<span class="line-modified">  68     , m_injectedScriptManager(context.injectedScriptManager)</span>
  69 {
  70     // FIXME: make breakReason optional so that there was no need to init it with &quot;other&quot;.
  71     clearBreakDetails();
  72 }
  73 
<span class="line-modified">  74 InspectorDebuggerAgent::~InspectorDebuggerAgent() = default;</span>


  75 
  76 void InspectorDebuggerAgent::didCreateFrontendAndBackend(FrontendRouter*, BackendDispatcher*)
  77 {
  78 }
  79 
  80 void InspectorDebuggerAgent::willDestroyFrontendAndBackend(DisconnectReason reason)
  81 {
<span class="line-modified">  82     disable(reason == DisconnectReason::InspectedTargetDestroyed);</span>

  83 }
  84 
  85 void InspectorDebuggerAgent::enable()
  86 {
  87     if (m_enabled)
  88         return;
  89 
<span class="line-modified">  90     m_enabled = true;</span>
  91 
<span class="line-modified">  92     m_scriptDebugServer.addListener(this);</span>

  93 
<span class="line-modified">  94     for (auto* listener : copyToVector(m_listeners))</span>
<span class="line-added">  95         listener-&gt;debuggerWasEnabled();</span>
  96 }
  97 
  98 void InspectorDebuggerAgent::disable(bool isBeingDestroyed)
  99 {
 100     if (!m_enabled)
 101         return;
 102 
<span class="line-added"> 103     for (auto* listener : copyToVector(m_listeners))</span>
<span class="line-added"> 104         listener-&gt;debuggerWasDisabled();</span>
<span class="line-added"> 105 </span>
 106     m_scriptDebugServer.removeListener(this, isBeingDestroyed);
<span class="line-added"> 107 </span>
 108     clearInspectorBreakpointState();
 109 
 110     if (!isBeingDestroyed)
 111         m_scriptDebugServer.deactivateBreakpoints();
 112 
 113     ASSERT(m_javaScriptBreakpoints.isEmpty());
 114 



 115     clearAsyncStackTraceData();
 116 
 117     m_pauseOnAssertionFailures = false;
<span class="line-added"> 118     m_pauseOnMicrotasks = false;</span>
 119 
 120     m_enabled = false;
 121 }
 122 
 123 void InspectorDebuggerAgent::enable(ErrorString&amp;)
 124 {
 125     enable();
 126 }
 127 
 128 void InspectorDebuggerAgent::disable(ErrorString&amp;)
 129 {
 130     disable(false);
 131 }
 132 
 133 bool InspectorDebuggerAgent::breakpointsActive() const
 134 {
 135     return m_scriptDebugServer.breakpointsActive();
 136 }
 137 
 138 void InspectorDebuggerAgent::setAsyncStackTraceDepth(ErrorString&amp; errorString, int depth)
 139 {
 140     if (m_asyncStackTraceDepth == depth)
 141         return;
 142 
 143     if (depth &lt; 0) {
<span class="line-modified"> 144         errorString = &quot;Unexpected negative depth&quot;_s;</span>
 145         return;
 146     }
 147 
 148     m_asyncStackTraceDepth = depth;
 149 
 150     if (!m_asyncStackTraceDepth)
 151         clearAsyncStackTraceData();
 152 }
 153 
 154 void InspectorDebuggerAgent::setBreakpointsActive(ErrorString&amp;, bool active)
 155 {
 156     if (active)
 157         m_scriptDebugServer.activateBreakpoints();
 158     else
 159         m_scriptDebugServer.deactivateBreakpoints();
 160 }
 161 
 162 bool InspectorDebuggerAgent::isPaused() const
 163 {
 164     return m_scriptDebugServer.isPaused();
</pre>
<hr />
<pre>
 357         return true;
 358     }
 359 
 360     return false;
 361 }
 362 
 363 bool InspectorDebuggerAgent::breakpointActionsFromProtocol(ErrorString&amp; errorString, RefPtr&lt;JSON::Array&gt;&amp; actions, BreakpointActions* result)
 364 {
 365     if (!actions)
 366         return true;
 367 
 368     unsigned actionsLength = actions-&gt;length();
 369     if (!actionsLength)
 370         return true;
 371 
 372     result-&gt;reserveCapacity(actionsLength);
 373     for (unsigned i = 0; i &lt; actionsLength; ++i) {
 374         RefPtr&lt;JSON::Value&gt; value = actions-&gt;get(i);
 375         RefPtr&lt;JSON::Object&gt; object;
 376         if (!value-&gt;asObject(object)) {
<span class="line-modified"> 377             errorString = &quot;Unexpected non-object item in given actions&quot;_s;</span>
 378             return false;
 379         }
 380 
 381         String typeString;
 382         if (!object-&gt;getString(&quot;type&quot;_s, typeString)) {
<span class="line-modified"> 383             errorString = &quot;Missing type for item in given actions&quot;_s;</span>
 384             return false;
 385         }
 386 
 387         ScriptBreakpointActionType type;
 388         if (!breakpointActionTypeForString(typeString, &amp;type)) {
<span class="line-modified"> 389             errorString = &quot;Non-string type for item in given actions&quot;_s;</span>
 390             return false;
 391         }
 392 
 393         // Specifying an identifier is optional. They are used to correlate probe samples
 394         // in the frontend across multiple backend probe actions and segregate object groups.
 395         int identifier = 0;
 396         object-&gt;getInteger(&quot;id&quot;_s, identifier);
 397 
 398         String data;
 399         object-&gt;getString(&quot;data&quot;_s, data);
 400 
 401         result-&gt;append(ScriptBreakpointAction(type, identifier, data));
 402     }
 403 
 404     return true;
 405 }
 406 
 407 static RefPtr&lt;Protocol::Debugger::Location&gt; buildDebuggerLocation(const JSC::Breakpoint&amp; breakpoint)
 408 {
 409     ASSERT(breakpoint.resolved);
 410 
 411     auto location = Protocol::Debugger::Location::create()
 412         .setScriptId(String::number(breakpoint.sourceID))
 413         .setLineNumber(breakpoint.line)
 414         .release();
 415     location-&gt;setColumnNumber(breakpoint.column);
 416 
<span class="line-modified"> 417     return location;</span>
 418 }
 419 
 420 static bool parseLocation(ErrorString&amp; errorString, const JSON::Object&amp; location, JSC::SourceID&amp; sourceID, unsigned&amp; lineNumber, unsigned&amp; columnNumber)
 421 {
<span class="line-added"> 422     if (!location.getInteger(&quot;lineNumber&quot;_s, lineNumber)) {</span>
<span class="line-added"> 423         errorString = &quot;Unexpected non-integer lineNumber in given location&quot;_s;</span>
<span class="line-added"> 424         sourceID = JSC::noSourceID;</span>
<span class="line-added"> 425         return false;</span>
<span class="line-added"> 426     }</span>
<span class="line-added"> 427 </span>
 428     String scriptIDStr;
<span class="line-modified"> 429     if (!location.getString(&quot;scriptId&quot;_s, scriptIDStr)) {</span>
 430         sourceID = JSC::noSourceID;
<span class="line-modified"> 431         errorString = &quot;Unexepcted non-string scriptId in given location&quot;_s;</span>
 432         return false;
 433     }
 434 
 435     sourceID = scriptIDStr.toIntPtr();
 436     columnNumber = 0;
 437     location.getInteger(&quot;columnNumber&quot;_s, columnNumber);
 438     return true;
 439 }
 440 
 441 void InspectorDebuggerAgent::setBreakpointByUrl(ErrorString&amp; errorString, int lineNumber, const String* optionalURL, const String* optionalURLRegex, const int* optionalColumnNumber, const JSON::Object* options, Protocol::Debugger::BreakpointId* outBreakpointIdentifier, RefPtr&lt;JSON::ArrayOf&lt;Protocol::Debugger::Location&gt;&gt;&amp; locations)
 442 {
 443     locations = JSON::ArrayOf&lt;Protocol::Debugger::Location&gt;::create();
 444     if (!optionalURL == !optionalURLRegex) {
<span class="line-modified"> 445         errorString = &quot;Either url or urlRegex must be specified&quot;_s;</span>
 446         return;
 447     }
 448 
 449     String url = optionalURL ? *optionalURL : *optionalURLRegex;
 450     int columnNumber = optionalColumnNumber ? *optionalColumnNumber : 0;
 451     bool isRegex = optionalURLRegex;
 452 
 453     String breakpointIdentifier = makeString(isRegex ? &quot;/&quot; : &quot;&quot;, url, isRegex ? &quot;/:&quot; : &quot;:&quot;, lineNumber, &#39;:&#39;, columnNumber);
 454     if (m_javaScriptBreakpoints.contains(breakpointIdentifier)) {
<span class="line-modified"> 455         errorString = &quot;Breakpoint for given location already exists.&quot;_s;</span>
 456         return;
 457     }
 458 
 459     String condition = emptyString();
 460     bool autoContinue = false;
 461     unsigned ignoreCount = 0;
 462     RefPtr&lt;JSON::Array&gt; actions;
 463     if (options) {
 464         options-&gt;getString(&quot;condition&quot;_s, condition);
 465         options-&gt;getBoolean(&quot;autoContinue&quot;_s, autoContinue);
 466         options-&gt;getArray(&quot;actions&quot;_s, actions);
 467         options-&gt;getInteger(&quot;ignoreCount&quot;_s, ignoreCount);
 468     }
 469 
 470     BreakpointActions breakpointActions;
 471     if (!breakpointActionsFromProtocol(errorString, actions, &amp;breakpointActions))
 472         return;
 473 
 474     m_javaScriptBreakpoints.set(breakpointIdentifier, buildObjectForBreakpointCookie(url, lineNumber, columnNumber, condition, actions, isRegex, autoContinue, ignoreCount));
 475 
</pre>
<hr />
<pre>
 507     if (!parseLocation(errorString, location, sourceID, lineNumber, columnNumber))
 508         return;
 509 
 510     String condition = emptyString();
 511     bool autoContinue = false;
 512     unsigned ignoreCount = 0;
 513     RefPtr&lt;JSON::Array&gt; actions;
 514     if (options) {
 515         options-&gt;getString(&quot;condition&quot;_s, condition);
 516         options-&gt;getBoolean(&quot;autoContinue&quot;_s, autoContinue);
 517         options-&gt;getArray(&quot;actions&quot;_s, actions);
 518         options-&gt;getInteger(&quot;ignoreCount&quot;_s, ignoreCount);
 519     }
 520 
 521     BreakpointActions breakpointActions;
 522     if (!breakpointActionsFromProtocol(errorString, actions, &amp;breakpointActions))
 523         return;
 524 
 525     auto scriptIterator = m_scripts.find(sourceID);
 526     if (scriptIterator == m_scripts.end()) {
<span class="line-modified"> 527         errorString = &quot;Missing script for scriptId in given location&quot;_s;</span>
 528         return;
 529     }
 530 
 531     Script&amp; script = scriptIterator-&gt;value;
 532     JSC::Breakpoint breakpoint(sourceID, lineNumber, columnNumber, condition, autoContinue, ignoreCount);
 533     resolveBreakpoint(script, breakpoint);
 534     if (!breakpoint.resolved) {
 535         errorString = &quot;Could not resolve breakpoint&quot;_s;
 536         return;
 537     }
 538 
 539     bool existing;
 540     setBreakpoint(breakpoint, existing);
 541     if (existing) {
<span class="line-modified"> 542         errorString = &quot;Breakpoint for given location already exists&quot;_s;</span>
 543         return;
 544     }
 545 
 546     String breakpointIdentifier = makeString(sourceID, &#39;:&#39;, breakpoint.line, &#39;:&#39;, breakpoint.column);
 547     ScriptBreakpoint scriptBreakpoint(breakpoint.line, breakpoint.column, condition, breakpointActions, autoContinue, ignoreCount);
 548     didSetBreakpoint(breakpoint, breakpointIdentifier, scriptBreakpoint);
 549 
 550     actualLocation = buildDebuggerLocation(breakpoint);
 551     *outBreakpointIdentifier = breakpointIdentifier;
 552 }
 553 
 554 void InspectorDebuggerAgent::didSetBreakpoint(const JSC::Breakpoint&amp; breakpoint, const String&amp; breakpointIdentifier, const ScriptBreakpoint&amp; scriptBreakpoint)
 555 {
 556     JSC::BreakpointID id = breakpoint.id;
 557     m_scriptDebugServer.setBreakpointActions(id, scriptBreakpoint);
 558 
 559     auto debugServerBreakpointIDsIterator = m_breakpointIdentifierToDebugServerBreakpointIDs.find(breakpointIdentifier);
 560     if (debugServerBreakpointIDsIterator == m_breakpointIdentifierToDebugServerBreakpointIDs.end())
 561         debugServerBreakpointIDsIterator = m_breakpointIdentifierToDebugServerBreakpointIDs.set(breakpointIdentifier, Vector&lt;JSC::BreakpointID&gt;()).iterator;
 562     debugServerBreakpointIDsIterator-&gt;value.append(id);
</pre>
<hr />
<pre>
 610 void InspectorDebuggerAgent::continueToLocation(ErrorString&amp; errorString, const JSON::Object&amp; location)
 611 {
 612     if (!assertPaused(errorString))
 613         return;
 614 
 615     if (m_continueToLocationBreakpointID != JSC::noBreakpointID) {
 616         m_scriptDebugServer.removeBreakpoint(m_continueToLocationBreakpointID);
 617         m_continueToLocationBreakpointID = JSC::noBreakpointID;
 618     }
 619 
 620     JSC::SourceID sourceID;
 621     unsigned lineNumber;
 622     unsigned columnNumber;
 623     if (!parseLocation(errorString, location, sourceID, lineNumber, columnNumber))
 624         return;
 625 
 626     auto scriptIterator = m_scripts.find(sourceID);
 627     if (scriptIterator == m_scripts.end()) {
 628         m_scriptDebugServer.continueProgram();
 629         m_frontendDispatcher-&gt;resumed();
<span class="line-modified"> 630         errorString = &quot;Missing script for scriptId in given location&quot;_s;</span>
 631         return;
 632     }
 633 
 634     String condition;
 635     bool autoContinue = false;
 636     unsigned ignoreCount = 0;
 637     JSC::Breakpoint breakpoint(sourceID, lineNumber, columnNumber, condition, autoContinue, ignoreCount);
 638     Script&amp; script = scriptIterator-&gt;value;
 639     resolveBreakpoint(script, breakpoint);
 640     if (!breakpoint.resolved) {
 641         m_scriptDebugServer.continueProgram();
 642         m_frontendDispatcher-&gt;resumed();
 643         errorString = &quot;Could not resolve breakpoint&quot;_s;
 644         return;
 645     }
 646 
 647     bool existing;
 648     setBreakpoint(breakpoint, existing);
 649     if (existing) {
 650         // There is an existing breakpoint at this location. Instead of
 651         // acting like a series of steps, just resume and we will either
 652         // hit this new breakpoint or not.
 653         m_scriptDebugServer.continueProgram();
 654         m_frontendDispatcher-&gt;resumed();
 655         return;
 656     }
 657 
 658     m_continueToLocationBreakpointID = breakpoint.id;
 659 
 660     // Treat this as a series of steps until reaching the new breakpoint.
 661     // So don&#39;t issue a resumed event unless we exit the VM without pausing.
 662     willStepAndMayBecomeIdle();
 663     m_scriptDebugServer.continueProgram();
 664 }
 665 
<span class="line-modified"> 666 void InspectorDebuggerAgent::searchInContent(ErrorString&amp; errorString, const String&amp; scriptIDStr, const String&amp; query, const bool* optionalCaseSensitive, const bool* optionalIsRegex, RefPtr&lt;JSON::ArrayOf&lt;Protocol::GenericTypes::SearchMatch&gt;&gt;&amp; results)</span>
 667 {
 668     JSC::SourceID sourceID = scriptIDStr.toIntPtr();
 669     auto it = m_scripts.find(sourceID);
 670     if (it == m_scripts.end()) {
<span class="line-modified"> 671         errorString = &quot;Missing script for given scriptId&quot;;</span>
 672         return;
 673     }
 674 
 675     bool isRegex = optionalIsRegex ? *optionalIsRegex : false;
 676     bool caseSensitive = optionalCaseSensitive ? *optionalCaseSensitive : false;
 677     results = ContentSearchUtilities::searchInTextByLines(it-&gt;value.source, query, caseSensitive, isRegex);
 678 }
 679 
<span class="line-modified"> 680 void InspectorDebuggerAgent::getScriptSource(ErrorString&amp; errorString, const String&amp; scriptIDStr, String* scriptSource)</span>
 681 {
 682     JSC::SourceID sourceID = scriptIDStr.toIntPtr();
<span class="line-modified"> 683     auto it = m_scripts.find(sourceID);</span>
 684     if (it != m_scripts.end())
 685         *scriptSource = it-&gt;value.source;
 686     else
<span class="line-modified"> 687         errorString = &quot;Missing script for given scriptId&quot;;</span>
 688 }
 689 
 690 void InspectorDebuggerAgent::getFunctionDetails(ErrorString&amp; errorString, const String&amp; functionId, RefPtr&lt;Protocol::Debugger::FunctionDetails&gt;&amp; details)
 691 {
 692     InjectedScript injectedScript = m_injectedScriptManager.injectedScriptForObjectId(functionId);
 693     if (injectedScript.hasNoValue()) {
<span class="line-modified"> 694         errorString = &quot;Missing injected script for given functionId&quot;_s;</span>
 695         return;
 696     }
 697 
 698     injectedScript.getFunctionDetails(errorString, functionId, details);
 699 }
 700 
 701 void InspectorDebuggerAgent::schedulePauseOnNextStatement(DebuggerFrontendDispatcher::Reason breakReason, RefPtr&lt;JSON::Object&gt;&amp;&amp; data)
 702 {
 703     if (m_javaScriptPauseScheduled)
 704         return;
 705 
 706     m_javaScriptPauseScheduled = true;
 707 
 708     m_breakReason = breakReason;
<span class="line-modified"> 709     m_breakData = WTFMove(data);</span>
 710 
 711     JSC::JSLockHolder locker(m_scriptDebugServer.vm());
 712     m_scriptDebugServer.setPauseOnNextStatement(true);
 713 }
 714 
 715 void InspectorDebuggerAgent::cancelPauseOnNextStatement()
 716 {
 717     if (!m_javaScriptPauseScheduled)
 718         return;
 719 
 720     m_javaScriptPauseScheduled = false;
 721 
 722     clearBreakDetails();
 723     m_scriptDebugServer.setPauseOnNextStatement(false);
 724     m_enablePauseWhenIdle = false;
 725 }
 726 
 727 void InspectorDebuggerAgent::pause(ErrorString&amp;)
 728 {
 729     schedulePauseOnNextStatement(DebuggerFrontendDispatcher::Reason::PauseOnNextStatement, nullptr);
 730 }
 731 
 732 void InspectorDebuggerAgent::resume(ErrorString&amp; errorString)
 733 {
 734     if (!m_pausedScriptState &amp;&amp; !m_javaScriptPauseScheduled) {
<span class="line-modified"> 735         errorString = &quot;Must be paused or waiting to pause&quot;_s;</span>
 736         return;
 737     }
 738 
 739     cancelPauseOnNextStatement();
 740     m_scriptDebugServer.continueProgram();
 741     m_conditionToDispatchResumed = ShouldDispatchResumed::WhenContinued;
 742 }
 743 
 744 void InspectorDebuggerAgent::stepOver(ErrorString&amp; errorString)
 745 {
 746     if (!assertPaused(errorString))
 747         return;
 748 
 749     willStepAndMayBecomeIdle();
 750     m_scriptDebugServer.stepOverStatement();
 751 }
 752 
 753 void InspectorDebuggerAgent::stepInto(ErrorString&amp; errorString)
 754 {
 755     if (!assertPaused(errorString))
</pre>
<hr />
<pre>
 799     }
 800 
 801     m_conditionToDispatchResumed = ShouldDispatchResumed::No;
 802 
 803     if (m_enablePauseWhenIdle) {
 804         ErrorString ignored;
 805         pause(ignored);
 806     }
 807 }
 808 
 809 void InspectorDebuggerAgent::setPauseOnExceptions(ErrorString&amp; errorString, const String&amp; stringPauseState)
 810 {
 811     JSC::Debugger::PauseOnExceptionsState pauseState;
 812     if (stringPauseState == &quot;none&quot;)
 813         pauseState = JSC::Debugger::DontPauseOnExceptions;
 814     else if (stringPauseState == &quot;all&quot;)
 815         pauseState = JSC::Debugger::PauseOnAllExceptions;
 816     else if (stringPauseState == &quot;uncaught&quot;)
 817         pauseState = JSC::Debugger::PauseOnUncaughtExceptions;
 818     else {
<span class="line-modified"> 819         errorString = makeString(&quot;Unknown state: &quot;_s, stringPauseState);</span>
 820         return;
 821     }
 822 
 823     m_scriptDebugServer.setPauseOnExceptionsState(static_cast&lt;JSC::Debugger::PauseOnExceptionsState&gt;(pauseState));
 824     if (m_scriptDebugServer.pauseOnExceptionsState() != pauseState)
 825         errorString = &quot;Internal error. Could not change pause on exceptions state&quot;_s;
 826 }
 827 
 828 void InspectorDebuggerAgent::setPauseOnAssertions(ErrorString&amp;, bool enabled)
 829 {
 830     m_pauseOnAssertionFailures = enabled;
 831 }
 832 
<span class="line-modified"> 833 void InspectorDebuggerAgent::setPauseOnMicrotasks(ErrorString&amp;, bool enabled)</span>
<span class="line-added"> 834 {</span>
<span class="line-added"> 835     m_pauseOnMicrotasks = enabled;</span>
<span class="line-added"> 836 }</span>
<span class="line-added"> 837 </span>
<span class="line-added"> 838 void InspectorDebuggerAgent::evaluateOnCallFrame(ErrorString&amp; errorString, const String&amp; callFrameId, const String&amp; expression, const String* objectGroup, const bool* includeCommandLineAPI, const bool* doNotPauseOnExceptionsAndMuteConsole, const bool* returnByValue, const bool* generatePreview, const bool* saveResult, const bool* /* emulateUserGesture */, RefPtr&lt;Protocol::Runtime::RemoteObject&gt;&amp; result, Optional&lt;bool&gt;&amp; wasThrown, Optional&lt;int&gt;&amp; savedResultIndex)</span>
 839 {
<span class="line-modified"> 840     if (!assertPaused(errorString))</span>

 841         return;

 842 
 843     InjectedScript injectedScript = m_injectedScriptManager.injectedScriptForObjectId(callFrameId);
 844     if (injectedScript.hasNoValue()) {
<span class="line-modified"> 845         errorString = &quot;Missing injected script for given callFrameId&quot;_s;</span>
 846         return;
 847     }
 848 
 849     auto pauseState = m_scriptDebugServer.pauseOnExceptionsState();
 850     bool pauseAndMute = doNotPauseOnExceptionsAndMuteConsole &amp;&amp; *doNotPauseOnExceptionsAndMuteConsole;
 851     if (pauseAndMute) {
 852         if (pauseState != JSC::Debugger::DontPauseOnExceptions)
 853             m_scriptDebugServer.setPauseOnExceptionsState(JSC::Debugger::DontPauseOnExceptions);
 854         muteConsole();
 855     }
 856 
 857     injectedScript.evaluateOnCallFrame(errorString, m_currentCallStack.get(), callFrameId, expression,
 858         objectGroup ? *objectGroup : emptyString(), includeCommandLineAPI &amp;&amp; *includeCommandLineAPI, returnByValue &amp;&amp; *returnByValue, generatePreview &amp;&amp; *generatePreview, saveResult &amp;&amp; *saveResult,
 859         result, wasThrown, savedResultIndex);
 860 
 861     if (pauseAndMute) {
 862         unmuteConsole();
 863         m_scriptDebugServer.setPauseOnExceptionsState(pauseState);
 864     }
 865 }
 866 




 867 void InspectorDebuggerAgent::scriptExecutionBlockedByCSP(const String&amp; directiveText)
 868 {
 869     if (m_scriptDebugServer.pauseOnExceptionsState() != JSC::Debugger::DontPauseOnExceptions)
 870         breakProgram(DebuggerFrontendDispatcher::Reason::CSPViolation, buildCSPViolationPauseReason(directiveText));
 871 }
 872 
 873 Ref&lt;JSON::ArrayOf&lt;Protocol::Debugger::CallFrame&gt;&gt; InspectorDebuggerAgent::currentCallFrames(const InjectedScript&amp; injectedScript)
 874 {
 875     ASSERT(!injectedScript.hasNoValue());
 876     if (injectedScript.hasNoValue())
 877         return JSON::ArrayOf&lt;Protocol::Debugger::CallFrame&gt;::create();
 878 
 879     return injectedScript.wrapCallFrames(m_currentCallStack.get());
 880 }
 881 
 882 String InspectorDebuggerAgent::sourceMapURLForScript(const Script&amp; script)
 883 {
 884     return script.sourceMappingURL;
 885 }
 886 
</pre>
<hr />
<pre>
 952         if (!breakpoint.resolved)
 953             continue;
 954 
 955         bool existing;
 956         setBreakpoint(breakpoint, existing);
 957         if (existing)
 958             continue;
 959 
 960         String breakpointIdentifier = entry.key;
 961         didSetBreakpoint(breakpoint, breakpointIdentifier, scriptBreakpoint);
 962 
 963         m_frontendDispatcher-&gt;breakpointResolved(breakpointIdentifier, buildDebuggerLocation(breakpoint));
 964     }
 965 }
 966 
 967 void InspectorDebuggerAgent::failedToParseSource(const String&amp; url, const String&amp; data, int firstLine, int errorLine, const String&amp; errorMessage)
 968 {
 969     m_frontendDispatcher-&gt;scriptFailedToParse(url, data, firstLine, errorLine, errorMessage);
 970 }
 971 
<span class="line-added"> 972 void InspectorDebuggerAgent::willRunMicrotask()</span>
<span class="line-added"> 973 {</span>
<span class="line-added"> 974     if (!m_scriptDebugServer.breakpointsActive())</span>
<span class="line-added"> 975         return;</span>
<span class="line-added"> 976 </span>
<span class="line-added"> 977     if (m_pauseOnMicrotasks)</span>
<span class="line-added"> 978         schedulePauseOnNextStatement(DebuggerFrontendDispatcher::Reason::Microtask, nullptr);</span>
<span class="line-added"> 979 }</span>
<span class="line-added"> 980 </span>
<span class="line-added"> 981 void InspectorDebuggerAgent::didRunMicrotask()</span>
<span class="line-added"> 982 {</span>
<span class="line-added"> 983     if (!m_scriptDebugServer.breakpointsActive())</span>
<span class="line-added"> 984         return;</span>
<span class="line-added"> 985 </span>
<span class="line-added"> 986     if (m_pauseOnMicrotasks)</span>
<span class="line-added"> 987         cancelPauseOnNextStatement();</span>
<span class="line-added"> 988 }</span>
<span class="line-added"> 989 </span>
 990 void InspectorDebuggerAgent::didPause(JSC::ExecState&amp; scriptState, JSC::JSValue callFrames, JSC::JSValue exceptionOrCaughtValue)
 991 {
 992     ASSERT(!m_pausedScriptState);
 993     m_pausedScriptState = &amp;scriptState;
 994     m_currentCallStack = { scriptState.vm(), callFrames };
 995 
 996     InjectedScript injectedScript = m_injectedScriptManager.injectedScriptFor(&amp;scriptState);
 997 
 998     // If a high level pause pause reason is not already set, try to infer a reason from the debugger.
 999     if (m_breakReason == DebuggerFrontendDispatcher::Reason::Other) {
1000         switch (m_scriptDebugServer.reasonForPause()) {
1001         case JSC::Debugger::PausedForBreakpoint: {
1002             JSC::BreakpointID debuggerBreakpointId = m_scriptDebugServer.pausingBreakpointID();
1003             if (debuggerBreakpointId != m_continueToLocationBreakpointID) {
1004                 m_breakReason = DebuggerFrontendDispatcher::Reason::Breakpoint;
<span class="line-modified">1005                 m_breakData = buildBreakpointPauseReason(debuggerBreakpointId);</span>
1006             }
1007             break;
1008         }
1009         case JSC::Debugger::PausedForDebuggerStatement:
1010             m_breakReason = DebuggerFrontendDispatcher::Reason::DebuggerStatement;
<span class="line-modified">1011             m_breakData = nullptr;</span>
1012             break;
1013         case JSC::Debugger::PausedForException:
1014             m_breakReason = DebuggerFrontendDispatcher::Reason::Exception;
<span class="line-modified">1015             m_breakData = buildExceptionPauseReason(exceptionOrCaughtValue, injectedScript);</span>
1016             break;
1017         case JSC::Debugger::PausedAtStatement:
1018         case JSC::Debugger::PausedAtExpression:
1019         case JSC::Debugger::PausedBeforeReturn:
1020         case JSC::Debugger::PausedAtEndOfProgram:
1021             // Pause was just stepping. Nothing to report.
1022             break;
1023         case JSC::Debugger::NotPaused:
1024             ASSERT_NOT_REACHED();
1025             break;
1026         }
1027     }
1028 
1029     // Set $exception to the exception or caught value.
1030     if (exceptionOrCaughtValue &amp;&amp; !injectedScript.hasNoValue()) {
1031         injectedScript.setExceptionValue(exceptionOrCaughtValue);
1032         m_hasExceptionValue = true;
1033     }
1034 
1035     m_conditionToDispatchResumed = ShouldDispatchResumed::No;
1036     m_enablePauseWhenIdle = false;
1037 
1038     RefPtr&lt;Protocol::Console::StackTrace&gt; asyncStackTrace;
1039     if (m_currentAsyncCallIdentifier) {
1040         auto it = m_pendingAsyncCalls.find(m_currentAsyncCallIdentifier.value());
1041         if (it != m_pendingAsyncCalls.end())
1042             asyncStackTrace = it-&gt;value-&gt;buildInspectorObject();
1043     }
1044 
<span class="line-modified">1045     m_frontendDispatcher-&gt;paused(currentCallFrames(injectedScript), m_breakReason, m_breakData, asyncStackTrace);</span>
1046 
1047     m_javaScriptPauseScheduled = false;
1048 
1049     if (m_continueToLocationBreakpointID != JSC::noBreakpointID) {
1050         m_scriptDebugServer.removeBreakpoint(m_continueToLocationBreakpointID);
1051         m_continueToLocationBreakpointID = JSC::noBreakpointID;
1052     }
1053 
1054     RefPtr&lt;Stopwatch&gt; stopwatch = m_injectedScriptManager.inspectorEnvironment().executionStopwatch();
1055     if (stopwatch &amp;&amp; stopwatch-&gt;isActive()) {
1056         stopwatch-&gt;stop();
1057         m_didPauseStopwatch = true;
1058     }
1059 }
1060 
1061 void InspectorDebuggerAgent::breakpointActionSound(int breakpointActionIdentifier)
1062 {
1063     m_frontendDispatcher-&gt;playBreakpointActionSound(breakpointActionIdentifier);
1064 }
1065 
</pre>
<hr />
<pre>
1080 void InspectorDebuggerAgent::didContinue()
1081 {
1082     if (m_didPauseStopwatch) {
1083         m_didPauseStopwatch = false;
1084         m_injectedScriptManager.inspectorEnvironment().executionStopwatch()-&gt;start();
1085     }
1086 
1087     m_pausedScriptState = nullptr;
1088     m_currentCallStack = { };
1089     m_injectedScriptManager.releaseObjectGroup(InspectorDebuggerAgent::backtraceObjectGroup);
1090     clearBreakDetails();
1091     clearExceptionValue();
1092 
1093     if (m_conditionToDispatchResumed == ShouldDispatchResumed::WhenContinued)
1094         m_frontendDispatcher-&gt;resumed();
1095 }
1096 
1097 void InspectorDebuggerAgent::breakProgram(DebuggerFrontendDispatcher::Reason breakReason, RefPtr&lt;JSON::Object&gt;&amp;&amp; data)
1098 {
1099     m_breakReason = breakReason;
<span class="line-modified">1100     m_breakData = WTFMove(data);</span>
1101     m_scriptDebugServer.breakProgram();
1102 }
1103 
1104 void InspectorDebuggerAgent::clearInspectorBreakpointState()
1105 {
<span class="line-modified">1106     ErrorString ignored;</span>
1107     for (const String&amp; identifier : copyToVector(m_breakpointIdentifierToDebugServerBreakpointIDs.keys()))
<span class="line-modified">1108         removeBreakpoint(ignored, identifier);</span>
1109 
1110     m_javaScriptBreakpoints.clear();
1111 
1112     clearDebuggerBreakpointState();
1113 }
1114 
1115 void InspectorDebuggerAgent::clearDebuggerBreakpointState()
1116 {
1117     {
1118         JSC::JSLockHolder holder(m_scriptDebugServer.vm());
1119         m_scriptDebugServer.clearBreakpointActions();
1120         m_scriptDebugServer.clearBreakpoints();
1121         m_scriptDebugServer.clearBlacklist();
1122     }
1123 
1124     m_pausedScriptState = nullptr;
1125     m_currentCallStack = { };
1126     m_scripts.clear();
1127     m_breakpointIdentifierToDebugServerBreakpointIDs.clear();
1128     m_debuggerBreakpointIdentifierToInspectorBreakpointIdentifier.clear();
</pre>
<hr />
<pre>
1134     if (isPaused()) {
1135         m_scriptDebugServer.continueProgram();
1136         m_frontendDispatcher-&gt;resumed();
1137     }
1138 }
1139 
1140 void InspectorDebuggerAgent::didClearGlobalObject()
1141 {
1142     // Clear breakpoints from the debugger, but keep the inspector&#39;s model of which
1143     // pages have what breakpoints, as the mapping is only sent to DebuggerAgent once.
1144     clearDebuggerBreakpointState();
1145 
1146     clearAsyncStackTraceData();
1147 
1148     m_frontendDispatcher-&gt;globalObjectCleared();
1149 }
1150 
1151 bool InspectorDebuggerAgent::assertPaused(ErrorString&amp; errorString)
1152 {
1153     if (!m_pausedScriptState) {
<span class="line-modified">1154         errorString = &quot;Must be paused&quot;_s;</span>
1155         return false;
1156     }
1157 
1158     return true;
1159 }
1160 
1161 void InspectorDebuggerAgent::clearBreakDetails()
1162 {
1163     m_breakReason = DebuggerFrontendDispatcher::Reason::Other;
<span class="line-modified">1164     m_breakData = nullptr;</span>
1165 }
1166 
1167 void InspectorDebuggerAgent::clearExceptionValue()
1168 {
1169     if (m_hasExceptionValue) {
1170         m_injectedScriptManager.clearExceptionValue();
1171         m_hasExceptionValue = false;
1172     }
1173 }
1174 
1175 void InspectorDebuggerAgent::clearAsyncStackTraceData()
1176 {
1177     m_pendingAsyncCalls.clear();
1178     m_currentAsyncCallIdentifier = WTF::nullopt;
1179 
1180     didClearAsyncStackTraceData();
1181 }
1182 
1183 } // namespace Inspector
</pre>
</td>
</tr>
</table>
<center><a href="InspectorConsoleAgent.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="InspectorDebuggerAgent.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>