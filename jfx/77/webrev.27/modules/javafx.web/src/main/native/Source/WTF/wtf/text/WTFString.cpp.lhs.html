<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WTF/wtf/text/WTFString.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * (C) 1999 Lars Knoll (knoll@kde.org)
<a name="1" id="anc1"></a><span class="line-modified">   3  * Copyright (C) 2004-2017 Apple Inc. All rights reserved.</span>
   4  * Copyright (C) 2007-2009 Torch Mobile, Inc.
   5  *
   6  * This library is free software; you can redistribute it and/or
   7  * modify it under the terms of the GNU Library General Public
   8  * License as published by the Free Software Foundation; either
   9  * version 2 of the License, or (at your option) any later version.
  10  *
  11  * This library is distributed in the hope that it will be useful,
  12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  14  * Library General Public License for more details.
  15  *
  16  * You should have received a copy of the GNU Library General Public License
  17  * along with this library; see the file COPYING.LIB.  If not, write to
  18  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  19  * Boston, MA 02110-1301, USA.
  20  */
  21 
  22 #include &quot;config.h&quot;
  23 #include &lt;wtf/text/WTFString.h&gt;
  24 
  25 #include &lt;stdarg.h&gt;
  26 #include &lt;wtf/ASCIICType.h&gt;
  27 #include &lt;wtf/DataLog.h&gt;
  28 #include &lt;wtf/HexNumber.h&gt;
  29 #include &lt;wtf/MathExtras.h&gt;
  30 #include &lt;wtf/NeverDestroyed.h&gt;
  31 #include &lt;wtf/Vector.h&gt;
  32 #include &lt;wtf/dtoa.h&gt;
  33 #include &lt;wtf/text/CString.h&gt;
  34 #include &lt;wtf/text/IntegerToStringConversion.h&gt;
  35 #include &lt;wtf/text/StringToIntegerConversion.h&gt;
  36 #include &lt;wtf/unicode/CharacterNames.h&gt;
  37 #include &lt;wtf/unicode/UTF8Conversion.h&gt;
  38 
  39 namespace WTF {
  40 
  41 using namespace Unicode;
  42 
  43 // Construct a string with UTF-16 data.
  44 String::String(const UChar* characters, unsigned length)
  45 {
  46     if (characters)
  47         m_impl = StringImpl::create(characters, length);
  48 }
  49 
  50 // Construct a string with UTF-16 data, from a null-terminated source.
  51 String::String(const UChar* nullTerminatedString)
  52 {
  53     if (nullTerminatedString)
  54         m_impl = StringImpl::create(nullTerminatedString, lengthOfNullTerminatedString(nullTerminatedString));
  55 }
  56 
  57 // Construct a string with latin1 data.
  58 String::String(const LChar* characters, unsigned length)
  59 {
  60     if (characters)
  61         m_impl = StringImpl::create(characters, length);
  62 }
  63 
  64 String::String(const char* characters, unsigned length)
  65 {
  66     if (characters)
  67         m_impl = StringImpl::create(reinterpret_cast&lt;const LChar*&gt;(characters), length);
  68 }
  69 
  70 // Construct a string with Latin-1 data, from a null-terminated source.
  71 String::String(const LChar* nullTerminatedString)
  72 {
  73     if (nullTerminatedString)
  74         m_impl = StringImpl::create(nullTerminatedString);
  75 }
  76 
  77 String::String(const char* nullTerminatedString)
  78 {
  79     if (nullTerminatedString)
  80         m_impl = StringImpl::create(reinterpret_cast&lt;const LChar*&gt;(nullTerminatedString));
  81 }
  82 
  83 String::String(ASCIILiteral characters)
  84     : m_impl(StringImpl::createFromLiteral(characters))
  85 {
  86 }
  87 
  88 void String::append(const String&amp; otherString)
  89 {
  90     // FIXME: This is extremely inefficient. So much so that we might want to take this out of String&#39;s API.
  91 
  92     if (!m_impl) {
  93         m_impl = otherString.m_impl;
  94         return;
  95     }
  96 
  97     if (otherString.isEmpty())
  98         return;
  99 
 100     auto length = m_impl-&gt;length();
 101     auto otherLength = otherString.m_impl-&gt;length();
 102     if (otherLength &gt; MaxLength - length)
 103         CRASH();
 104 
 105     if (m_impl-&gt;is8Bit() &amp;&amp; otherString.m_impl-&gt;is8Bit()) {
 106         LChar* data;
 107         auto newImpl = StringImpl::createUninitialized(length + otherLength, data);
 108         StringImpl::copyCharacters(data, m_impl-&gt;characters8(), length);
 109         StringImpl::copyCharacters(data + length, otherString.m_impl-&gt;characters8(), otherLength);
 110         m_impl = WTFMove(newImpl);
 111         return;
 112     }
 113     UChar* data;
 114     auto newImpl = StringImpl::createUninitialized(length + otherLength, data);
 115     StringView(*m_impl).getCharactersWithUpconvert(data);
 116     StringView(*otherString.m_impl).getCharactersWithUpconvert(data + length);
 117     m_impl = WTFMove(newImpl);
 118 }
 119 
 120 void String::append(LChar character)
 121 {
 122     // FIXME: This is extremely inefficient. So much so that we might want to take this out of String&#39;s API.
 123 
 124     if (!m_impl) {
 125         m_impl = StringImpl::create(&amp;character, 1);
 126         return;
 127     }
 128     if (!is8Bit()) {
 129         append(static_cast&lt;UChar&gt;(character));
 130         return;
 131     }
 132     if (m_impl-&gt;length() &gt;= MaxLength)
 133         CRASH();
 134     LChar* data;
 135     auto newImpl = StringImpl::createUninitialized(m_impl-&gt;length() + 1, data);
 136     StringImpl::copyCharacters(data, m_impl-&gt;characters8(), m_impl-&gt;length());
 137     data[m_impl-&gt;length()] = character;
 138     m_impl = WTFMove(newImpl);
 139 }
 140 
 141 void String::append(UChar character)
 142 {
 143     // FIXME: This is extremely inefficient. So much so that we might want to take this out of String&#39;s API.
 144 
 145     if (!m_impl) {
 146         m_impl = StringImpl::create(&amp;character, 1);
 147         return;
 148     }
 149     if (isLatin1(character) &amp;&amp; is8Bit()) {
 150         append(static_cast&lt;LChar&gt;(character));
 151         return;
 152     }
 153     if (m_impl-&gt;length() &gt;= MaxLength)
 154         CRASH();
 155     UChar* data;
 156     auto newImpl = StringImpl::createUninitialized(m_impl-&gt;length() + 1, data);
 157     StringView(*m_impl).getCharactersWithUpconvert(data);
 158     data[m_impl-&gt;length()] = character;
 159     m_impl = WTFMove(newImpl);
 160 }
 161 
 162 int codePointCompare(const String&amp; a, const String&amp; b)
 163 {
 164     return codePointCompare(a.impl(), b.impl());
 165 }
 166 
 167 void String::insert(const String&amp; string, unsigned position)
 168 {
 169     // FIXME: This is extremely inefficient. So much so that we might want to take this out of String&#39;s API.
 170 
 171     unsigned lengthToInsert = string.length();
 172 
 173     if (!lengthToInsert) {
 174         if (string.isNull())
 175             return;
 176         if (isNull())
 177             m_impl = string.impl();
 178         return;
 179     }
 180 
 181     if (position &gt;= length()) {
 182         append(string);
 183         return;
 184     }
 185 
 186     if (lengthToInsert &gt; MaxLength - length())
 187         CRASH();
 188 
 189     if (is8Bit() &amp;&amp; string.is8Bit()) {
 190         LChar* data;
 191         auto newString = StringImpl::createUninitialized(length() + lengthToInsert, data);
 192         StringView(*m_impl).substring(0, position).getCharactersWithUpconvert(data);
 193         StringView(string).getCharactersWithUpconvert(data + position);
 194         StringView(*m_impl).substring(position).getCharactersWithUpconvert(data + position + lengthToInsert);
 195         m_impl = WTFMove(newString);
 196     } else {
 197         UChar* data;
 198         auto newString = StringImpl::createUninitialized(length() + lengthToInsert, data);
 199         StringView(*m_impl).substring(0, position).getCharactersWithUpconvert(data);
 200         StringView(string).getCharactersWithUpconvert(data + position);
 201         StringView(*m_impl).substring(position).getCharactersWithUpconvert(data + position + lengthToInsert);
 202         m_impl = WTFMove(newString);
 203     }
 204 }
 205 
 206 void String::append(const LChar* charactersToAppend, unsigned lengthToAppend)
 207 {
 208     // FIXME: This is extremely inefficient. So much so that we might want to take this out of String&#39;s API.
 209 
 210     if (!m_impl) {
 211         if (!charactersToAppend)
 212             return;
 213         m_impl = StringImpl::create(charactersToAppend, lengthToAppend);
 214         return;
 215     }
 216 
 217     if (!lengthToAppend)
 218         return;
 219 
 220     ASSERT(charactersToAppend);
 221 
 222     unsigned strLength = m_impl-&gt;length();
 223 
 224     if (m_impl-&gt;is8Bit()) {
 225         if (lengthToAppend &gt; MaxLength - strLength)
 226             CRASH();
 227         LChar* data;
 228         auto newImpl = StringImpl::createUninitialized(strLength + lengthToAppend, data);
 229         StringImpl::copyCharacters(data, m_impl-&gt;characters8(), strLength);
 230         StringImpl::copyCharacters(data + strLength, charactersToAppend, lengthToAppend);
 231         m_impl = WTFMove(newImpl);
 232         return;
 233     }
 234 
 235     if (lengthToAppend &gt; MaxLength - strLength)
 236         CRASH();
 237     UChar* data;
 238     auto newImpl = StringImpl::createUninitialized(length() + lengthToAppend, data);
 239     StringImpl::copyCharacters(data, m_impl-&gt;characters16(), strLength);
 240     StringImpl::copyCharacters(data + strLength, charactersToAppend, lengthToAppend);
 241     m_impl = WTFMove(newImpl);
 242 }
 243 
 244 void String::append(const UChar* charactersToAppend, unsigned lengthToAppend)
 245 {
 246     // FIXME: This is extremely inefficient. So much so that we might want to take this out of String&#39;s API.
 247 
 248     if (!m_impl) {
 249         if (!charactersToAppend)
 250             return;
 251         m_impl = StringImpl::create(charactersToAppend, lengthToAppend);
 252         return;
 253     }
 254 
 255     if (!lengthToAppend)
 256         return;
 257 
 258     unsigned strLength = m_impl-&gt;length();
 259 
 260     ASSERT(charactersToAppend);
 261     if (lengthToAppend &gt; MaxLength - strLength)
 262         CRASH();
 263     UChar* data;
 264     auto newImpl = StringImpl::createUninitialized(strLength + lengthToAppend, data);
 265     if (m_impl-&gt;is8Bit())
 266         StringImpl::copyCharacters(data, characters8(), strLength);
 267     else
 268         StringImpl::copyCharacters(data, characters16(), strLength);
 269     StringImpl::copyCharacters(data + strLength, charactersToAppend, lengthToAppend);
 270     m_impl = WTFMove(newImpl);
 271 }
 272 
 273 
 274 UChar32 String::characterStartingAt(unsigned i) const
 275 {
 276     if (!m_impl || i &gt;= m_impl-&gt;length())
 277         return 0;
 278     return m_impl-&gt;characterStartingAt(i);
 279 }
 280 
 281 void String::truncate(unsigned position)
 282 {
 283     if (m_impl)
 284         m_impl = m_impl-&gt;substring(0, position);
 285 }
 286 
 287 template&lt;typename CharacterType&gt; inline void String::removeInternal(const CharacterType* characters, unsigned position, unsigned lengthToRemove)
 288 {
 289     CharacterType* data;
 290     auto newImpl = StringImpl::createUninitialized(length() - lengthToRemove, data);
 291     StringImpl::copyCharacters(data, characters, position);
 292     StringImpl::copyCharacters(data + position, characters + position + lengthToRemove, length() - lengthToRemove - position);
 293     m_impl = WTFMove(newImpl);
 294 }
 295 
 296 void String::remove(unsigned position, unsigned lengthToRemove)
 297 {
 298     if (!lengthToRemove)
 299         return;
 300     auto length = this-&gt;length();
 301     if (position &gt;= length)
 302         return;
 303     lengthToRemove = std::min(lengthToRemove, length - position);
 304     if (is8Bit())
 305         removeInternal(characters8(), position, lengthToRemove);
 306     else
 307         removeInternal(characters16(), position, lengthToRemove);
 308 }
 309 
 310 String String::substring(unsigned position, unsigned length) const
 311 {
 312     // FIXME: Should this function, and the many others like it, be inlined?
 313     return m_impl ? m_impl-&gt;substring(position, length) : String { };
 314 }
 315 
 316 String String::substringSharingImpl(unsigned offset, unsigned length) const
 317 {
 318     // FIXME: We used to check against a limit of Heap::minExtraCost / sizeof(UChar).
 319 
 320     unsigned stringLength = this-&gt;length();
 321     offset = std::min(offset, stringLength);
 322     length = std::min(length, stringLength - offset);
 323 
 324     if (!offset &amp;&amp; length == stringLength)
 325         return *this;
 326     return StringImpl::createSubstringSharingImpl(*m_impl, offset, length);
 327 }
 328 
 329 String String::convertToASCIILowercase() const
 330 {
 331     // FIXME: Should this function, and the many others like it, be inlined?
 332     return m_impl ? m_impl-&gt;convertToASCIILowercase() : String { };
 333 }
 334 
 335 String String::convertToASCIIUppercase() const
 336 {
 337     // FIXME: Should this function, and the many others like it, be inlined?
 338     return m_impl ? m_impl-&gt;convertToASCIIUppercase() : String { };
 339 }
 340 
 341 String String::convertToLowercaseWithoutLocale() const
 342 {
 343     // FIXME: Should this function, and the many others like it, be inlined?
 344     return m_impl ? m_impl-&gt;convertToLowercaseWithoutLocale() : String { };
 345 }
 346 
 347 String String::convertToLowercaseWithoutLocaleStartingAtFailingIndex8Bit(unsigned failingIndex) const
 348 {
 349     // FIXME: Should this function, and the many others like it, be inlined?
 350     return m_impl ? m_impl-&gt;convertToLowercaseWithoutLocaleStartingAtFailingIndex8Bit(failingIndex) : String { };
 351 }
 352 
 353 String String::convertToUppercaseWithoutLocale() const
 354 {
 355     // FIXME: Should this function, and the many others like it, be inlined?
 356     return m_impl ? m_impl-&gt;convertToUppercaseWithoutLocale() : String { };
 357 }
 358 
<a name="2" id="anc2"></a><span class="line-modified"> 359 String String::convertToLowercaseWithLocale(const AtomicString&amp; localeIdentifier) const</span>
 360 {
 361     // FIXME: Should this function, and the many others like it, be inlined?
 362     return m_impl ? m_impl-&gt;convertToLowercaseWithLocale(localeIdentifier) : String { };
 363 }
 364 
<a name="3" id="anc3"></a><span class="line-modified"> 365 String String::convertToUppercaseWithLocale(const AtomicString&amp; localeIdentifier) const</span>
 366 {
 367     // FIXME: Should this function, and the many others like it, be inlined?
 368     return m_impl ? m_impl-&gt;convertToUppercaseWithLocale(localeIdentifier) : String { };
 369 }
 370 
 371 String String::stripWhiteSpace() const
 372 {
 373     // FIXME: Should this function, and the many others like it, be inlined?
 374     // FIXME: This function needs a new name. For one thing, &quot;whitespace&quot; is a single
 375     // word so the &quot;s&quot; should be lowercase. For another, it&#39;s not clear from this name
 376     // that the function uses the Unicode definition of whitespace. Most WebKit callers
 377     // don&#39;t want that and eventually we should consider deleting this.
 378     return m_impl ? m_impl-&gt;stripWhiteSpace() : String { };
 379 }
 380 
 381 String String::stripLeadingAndTrailingCharacters(CodeUnitMatchFunction predicate) const
 382 {
 383     // FIXME: Should this function, and the many others like it, be inlined?
 384     return m_impl ? m_impl-&gt;stripLeadingAndTrailingCharacters(predicate) : String { };
 385 }
 386 
 387 String String::simplifyWhiteSpace() const
 388 {
 389     // FIXME: Should this function, and the many others like it, be inlined?
 390     // FIXME: This function needs a new name. For one thing, &quot;whitespace&quot; is a single
 391     // word so the &quot;s&quot; should be lowercase. For another, it&#39;s not clear from this name
 392     // that the function uses the Unicode definition of whitespace. Most WebKit callers
 393     // don&#39;t want that and eventually we should consider deleting this.
 394     return m_impl ? m_impl-&gt;simplifyWhiteSpace() : String { };
 395 }
 396 
 397 String String::simplifyWhiteSpace(CodeUnitMatchFunction isWhiteSpace) const
 398 {
 399     // FIXME: Should this function, and the many others like it, be inlined?
 400     return m_impl ? m_impl-&gt;simplifyWhiteSpace(isWhiteSpace) : String { };
 401 }
 402 
 403 String String::removeCharacters(CodeUnitMatchFunction findMatch) const
 404 {
 405     // FIXME: Should this function, and the many others like it, be inlined?
 406     return m_impl ? m_impl-&gt;removeCharacters(findMatch) : String { };
 407 }
 408 
 409 String String::foldCase() const
 410 {
 411     // FIXME: Should this function, and the many others like it, be inlined?
 412     return m_impl ? m_impl-&gt;foldCase() : String { };
 413 }
 414 
 415 bool String::percentage(int&amp; result) const
 416 {
 417     if (!m_impl || !m_impl-&gt;length())
 418         return false;
 419 
 420     if ((*m_impl)[m_impl-&gt;length() - 1] != &#39;%&#39;)
 421        return false;
 422 
 423     if (m_impl-&gt;is8Bit())
 424         result = charactersToIntStrict(m_impl-&gt;characters8(), m_impl-&gt;length() - 1);
 425     else
 426         result = charactersToIntStrict(m_impl-&gt;characters16(), m_impl-&gt;length() - 1);
 427     return true;
 428 }
 429 
 430 Vector&lt;UChar&gt; String::charactersWithNullTermination() const
 431 {
 432     Vector&lt;UChar&gt; result;
 433 
 434     if (m_impl) {
 435         result.reserveInitialCapacity(length() + 1);
 436 
 437         if (is8Bit()) {
 438             const LChar* characters8 = m_impl-&gt;characters8();
 439             for (size_t i = 0; i &lt; length(); ++i)
 440                 result.uncheckedAppend(characters8[i]);
 441         } else {
 442             const UChar* characters16 = m_impl-&gt;characters16();
 443             result.append(characters16, m_impl-&gt;length());
 444         }
 445 
 446         result.append(0);
 447     }
 448 
 449     return result;
 450 }
 451 
 452 String String::number(int number)
 453 {
 454     return numberToStringSigned&lt;String&gt;(number);
 455 }
 456 
<a name="4" id="anc4"></a><span class="line-modified"> 457 String String::number(unsigned int number)</span>
 458 {
 459     return numberToStringUnsigned&lt;String&gt;(number);
 460 }
 461 
 462 String String::number(long number)
 463 {
 464     return numberToStringSigned&lt;String&gt;(number);
 465 }
 466 
 467 String String::number(unsigned long number)
 468 {
 469     return numberToStringUnsigned&lt;String&gt;(number);
 470 }
 471 
 472 String String::number(long long number)
 473 {
 474     return numberToStringSigned&lt;String&gt;(number);
 475 }
 476 
 477 String String::number(unsigned long long number)
 478 {
 479     return numberToStringUnsigned&lt;String&gt;(number);
 480 }
 481 
<a name="5" id="anc5"></a><span class="line-modified"> 482 String String::number(double number, unsigned precision, TrailingZerosTruncatingPolicy trailingZerosTruncatingPolicy)</span>
 483 {
 484     NumberToStringBuffer buffer;
<a name="6" id="anc6"></a><span class="line-modified"> 485     return String(numberToFixedPrecisionString(number, precision, buffer, trailingZerosTruncatingPolicy == TruncateTrailingZeros));</span>
 486 }
 487 
<a name="7" id="anc7"></a><span class="line-modified"> 488 String String::numberToStringECMAScript(double number)</span>
 489 {
 490     NumberToStringBuffer buffer;
<a name="8" id="anc8"></a><span class="line-modified"> 491     return String(numberToString(number, buffer));</span>












 492 }
 493 
 494 String String::numberToStringFixedWidth(double number, unsigned decimalPlaces)
 495 {
 496     NumberToStringBuffer buffer;
<a name="9" id="anc9"></a><span class="line-modified"> 497     return String(numberToFixedWidthString(number, decimalPlaces, buffer));</span>
 498 }
 499 
 500 int String::toIntStrict(bool* ok, int base) const
 501 {
 502     if (!m_impl) {
 503         if (ok)
 504             *ok = false;
 505         return 0;
 506     }
 507     return m_impl-&gt;toIntStrict(ok, base);
 508 }
 509 
 510 unsigned String::toUIntStrict(bool* ok, int base) const
 511 {
 512     if (!m_impl) {
 513         if (ok)
 514             *ok = false;
 515         return 0;
 516     }
 517     return m_impl-&gt;toUIntStrict(ok, base);
 518 }
 519 
 520 int64_t String::toInt64Strict(bool* ok, int base) const
 521 {
 522     if (!m_impl) {
 523         if (ok)
 524             *ok = false;
 525         return 0;
 526     }
 527     return m_impl-&gt;toInt64Strict(ok, base);
 528 }
 529 
 530 uint64_t String::toUInt64Strict(bool* ok, int base) const
 531 {
 532     if (!m_impl) {
 533         if (ok)
 534             *ok = false;
 535         return 0;
 536     }
 537     return m_impl-&gt;toUInt64Strict(ok, base);
 538 }
 539 
 540 intptr_t String::toIntPtrStrict(bool* ok, int base) const
 541 {
 542     if (!m_impl) {
 543         if (ok)
 544             *ok = false;
 545         return 0;
 546     }
 547     return m_impl-&gt;toIntPtrStrict(ok, base);
 548 }
 549 
 550 int String::toInt(bool* ok) const
 551 {
 552     if (!m_impl) {
 553         if (ok)
 554             *ok = false;
 555         return 0;
 556     }
 557     return m_impl-&gt;toInt(ok);
 558 }
 559 
 560 unsigned String::toUInt(bool* ok) const
 561 {
 562     if (!m_impl) {
 563         if (ok)
 564             *ok = false;
 565         return 0;
 566     }
 567     return m_impl-&gt;toUInt(ok);
 568 }
 569 
 570 int64_t String::toInt64(bool* ok) const
 571 {
 572     if (!m_impl) {
 573         if (ok)
 574             *ok = false;
 575         return 0;
 576     }
 577     return m_impl-&gt;toInt64(ok);
 578 }
 579 
 580 uint64_t String::toUInt64(bool* ok) const
 581 {
 582     if (!m_impl) {
 583         if (ok)
 584             *ok = false;
 585         return 0;
 586     }
 587     return m_impl-&gt;toUInt64(ok);
 588 }
 589 
 590 intptr_t String::toIntPtr(bool* ok) const
 591 {
 592     if (!m_impl) {
 593         if (ok)
 594             *ok = false;
 595         return 0;
 596     }
 597     return m_impl-&gt;toIntPtr(ok);
 598 }
 599 
 600 double String::toDouble(bool* ok) const
 601 {
 602     if (!m_impl) {
 603         if (ok)
 604             *ok = false;
 605         return 0.0;
 606     }
 607     return m_impl-&gt;toDouble(ok);
 608 }
 609 
 610 float String::toFloat(bool* ok) const
 611 {
 612     if (!m_impl) {
 613         if (ok)
 614             *ok = false;
 615         return 0.0f;
 616     }
 617     return m_impl-&gt;toFloat(ok);
 618 }
 619 
 620 String String::isolatedCopy() const &amp;
 621 {
 622     // FIXME: Should this function, and the many others like it, be inlined?
 623     return m_impl ? m_impl-&gt;isolatedCopy() : String { };
 624 }
 625 
 626 String String::isolatedCopy() &amp;&amp;
 627 {
 628     if (isSafeToSendToAnotherThread()) {
 629         // Since we know that our string is a temporary that will be destroyed
 630         // we can just steal the m_impl from it, thus avoiding a copy.
 631         return { WTFMove(*this) };
 632     }
 633 
 634     return m_impl ? m_impl-&gt;isolatedCopy() : String { };
 635 }
 636 
 637 bool String::isSafeToSendToAnotherThread() const
 638 {
<a name="10" id="anc10"></a><span class="line-modified"> 639     // AtomicStrings are not safe to send between threads as ~StringImpl()</span>
<span class="line-modified"> 640     // will try to remove them from the wrong AtomicStringTable.</span>
<span class="line-modified"> 641     return isEmpty() || (m_impl-&gt;hasOneRef() &amp;&amp; !m_impl-&gt;isAtomic());</span>
 642 }
 643 
 644 template&lt;bool allowEmptyEntries&gt;
 645 inline Vector&lt;String&gt; String::splitInternal(const String&amp; separator) const
 646 {
 647     Vector&lt;String&gt; result;
 648 
 649     unsigned startPos = 0;
 650     size_t endPos;
 651     while ((endPos = find(separator, startPos)) != notFound) {
 652         if (allowEmptyEntries || startPos != endPos)
 653             result.append(substring(startPos, endPos - startPos));
 654         startPos = endPos + separator.length();
 655     }
 656     if (allowEmptyEntries || startPos != length())
 657         result.append(substring(startPos));
 658 
 659     return result;
 660 }
 661 
 662 template&lt;bool allowEmptyEntries&gt;
 663 inline void String::splitInternal(UChar separator, const SplitFunctor&amp; functor) const
 664 {
 665     StringView view(*this);
 666 
 667     unsigned startPos = 0;
 668     size_t endPos;
 669     while ((endPos = find(separator, startPos)) != notFound) {
 670         if (allowEmptyEntries || startPos != endPos)
 671             functor(view.substring(startPos, endPos - startPos));
 672         startPos = endPos + 1;
 673     }
 674     if (allowEmptyEntries || startPos != length())
 675         functor(view.substring(startPos));
 676 }
 677 
 678 template&lt;bool allowEmptyEntries&gt;
 679 inline Vector&lt;String&gt; String::splitInternal(UChar separator) const
 680 {
 681     Vector&lt;String&gt; result;
 682     splitInternal&lt;allowEmptyEntries&gt;(separator, [&amp;result](StringView item) {
 683         result.append(item.toString());
 684     });
 685 
 686     return result;
 687 }
 688 
 689 void String::split(UChar separator, const SplitFunctor&amp; functor) const
 690 {
 691     splitInternal&lt;false&gt;(separator, functor);
 692 }
 693 
 694 Vector&lt;String&gt; String::split(UChar separator) const
 695 {
 696     return splitInternal&lt;false&gt;(separator);
 697 }
 698 
 699 Vector&lt;String&gt; String::split(const String&amp; separator) const
 700 {
 701     return splitInternal&lt;false&gt;(separator);
 702 }
 703 
 704 void String::splitAllowingEmptyEntries(UChar separator, const SplitFunctor&amp; functor) const
 705 {
 706     splitInternal&lt;true&gt;(separator, functor);
 707 }
 708 
 709 Vector&lt;String&gt; String::splitAllowingEmptyEntries(UChar separator) const
 710 {
 711     return splitInternal&lt;true&gt;(separator);
 712 }
 713 
 714 Vector&lt;String&gt; String::splitAllowingEmptyEntries(const String&amp; separator) const
 715 {
 716     return splitInternal&lt;true&gt;(separator);
 717 }
 718 
 719 CString String::ascii() const
 720 {
 721     // Printable ASCII characters 32..127 and the null character are
 722     // preserved, characters outside of this range are converted to &#39;?&#39;.
 723 
 724     unsigned length = this-&gt;length();
 725     if (!length) {
 726         char* characterBuffer;
 727         return CString::newUninitialized(length, characterBuffer);
 728     }
 729 
 730     if (this-&gt;is8Bit()) {
 731         const LChar* characters = this-&gt;characters8();
 732 
 733         char* characterBuffer;
 734         CString result = CString::newUninitialized(length, characterBuffer);
 735 
 736         for (unsigned i = 0; i &lt; length; ++i) {
 737             LChar ch = characters[i];
 738             characterBuffer[i] = ch &amp;&amp; (ch &lt; 0x20 || ch &gt; 0x7f) ? &#39;?&#39; : ch;
 739         }
 740 
 741         return result;
 742     }
 743 
 744     const UChar* characters = this-&gt;characters16();
 745 
 746     char* characterBuffer;
 747     CString result = CString::newUninitialized(length, characterBuffer);
 748 
 749     for (unsigned i = 0; i &lt; length; ++i) {
 750         UChar ch = characters[i];
 751         characterBuffer[i] = ch &amp;&amp; (ch &lt; 0x20 || ch &gt; 0x7f) ? &#39;?&#39; : ch;
 752     }
 753 
 754     return result;
 755 }
 756 
 757 CString String::latin1() const
 758 {
 759     // Basic Latin1 (ISO) encoding - Unicode characters 0..255 are
 760     // preserved, characters outside of this range are converted to &#39;?&#39;.
 761 
 762     unsigned length = this-&gt;length();
 763 
 764     if (!length)
 765         return CString(&quot;&quot;, 0);
 766 
 767     if (is8Bit())
 768         return CString(reinterpret_cast&lt;const char*&gt;(this-&gt;characters8()), length);
 769 
 770     const UChar* characters = this-&gt;characters16();
 771 
 772     char* characterBuffer;
 773     CString result = CString::newUninitialized(length, characterBuffer);
 774 
 775     for (unsigned i = 0; i &lt; length; ++i) {
 776         UChar ch = characters[i];
 777         characterBuffer[i] = !isLatin1(ch) ? &#39;?&#39; : ch;
 778     }
 779 
 780     return result;
 781 }
 782 
 783 Expected&lt;CString, UTF8ConversionError&gt; String::tryGetUtf8(ConversionMode mode) const
 784 {
 785     return m_impl ? m_impl-&gt;tryGetUtf8(mode) : CString { &quot;&quot;, 0 };
 786 }
 787 
 788 Expected&lt;CString, UTF8ConversionError&gt; String::tryGetUtf8() const
 789 {
 790     return tryGetUtf8(LenientConversion);
 791 }
 792 
 793 CString String::utf8(ConversionMode mode) const
 794 {
 795     Expected&lt;CString, UTF8ConversionError&gt; expectedString = tryGetUtf8(mode);
 796     RELEASE_ASSERT(expectedString);
 797     return expectedString.value();
 798 }
 799 
 800 CString String::utf8() const
 801 {
 802     return utf8(LenientConversion);
 803 }
 804 
 805 String String::make8BitFrom16BitSource(const UChar* source, size_t length)
 806 {
 807     if (!length)
 808         return String();
 809 
 810     LChar* destination;
 811     String result = String::createUninitialized(length, destination);
 812 
 813     copyLCharsFromUCharSource(destination, source, length);
 814 
 815     return result;
 816 }
 817 
 818 String String::make16BitFrom8BitSource(const LChar* source, size_t length)
 819 {
 820     if (!length)
 821         return String();
 822 
 823     UChar* destination;
 824     String result = String::createUninitialized(length, destination);
 825 
 826     StringImpl::copyCharacters(destination, source, length);
 827 
 828     return result;
 829 }
 830 
 831 String String::fromUTF8(const LChar* stringStart, size_t length)
 832 {
 833     if (length &gt; MaxLength)
 834         CRASH();
 835 
 836     if (!stringStart)
 837         return String();
 838 
 839     if (!length)
 840         return emptyString();
 841 
 842     if (charactersAreAllASCII(stringStart, length))
 843         return StringImpl::create(stringStart, length);
 844 
 845     Vector&lt;UChar, 1024&gt; buffer(length);
 846     UChar* bufferStart = buffer.data();
 847 
 848     UChar* bufferCurrent = bufferStart;
 849     const char* stringCurrent = reinterpret_cast&lt;const char*&gt;(stringStart);
<a name="11" id="anc11"></a><span class="line-modified"> 850     if (convertUTF8ToUTF16(&amp;stringCurrent, reinterpret_cast&lt;const char *&gt;(stringStart + length), &amp;bufferCurrent, bufferCurrent + buffer.size()) != conversionOK)</span>
 851         return String();
 852 
 853     unsigned utf16Length = bufferCurrent - bufferStart;
 854     ASSERT_WITH_SECURITY_IMPLICATION(utf16Length &lt; length);
 855     return StringImpl::create(bufferStart, utf16Length);
 856 }
 857 
 858 String String::fromUTF8(const LChar* string)
 859 {
 860     if (!string)
 861         return String();
 862     return fromUTF8(string, strlen(reinterpret_cast&lt;const char*&gt;(string)));
 863 }
 864 
 865 String String::fromUTF8(const CString&amp; s)
 866 {
 867     return fromUTF8(s.data());
 868 }
 869 
 870 String String::fromUTF8WithLatin1Fallback(const LChar* string, size_t size)
 871 {
 872     String utf8 = fromUTF8(string, size);
 873     if (!utf8)
 874         return String(string, size);
 875     return utf8;
 876 }
 877 
 878 // String Operations
 879 template&lt;typename CharacterType&gt;
 880 static unsigned lengthOfCharactersAsInteger(const CharacterType* data, size_t length)
 881 {
 882     size_t i = 0;
 883 
 884     // Allow leading spaces.
 885     for (; i != length; ++i) {
 886         if (!isSpaceOrNewline(data[i]))
 887             break;
 888     }
 889 
 890     // Allow sign.
 891     if (i != length &amp;&amp; (data[i] == &#39;+&#39; || data[i] == &#39;-&#39;))
 892         ++i;
 893 
 894     // Allow digits.
 895     for (; i != length; ++i) {
 896         if (!isASCIIDigit(data[i]))
 897             break;
 898     }
 899 
 900     return i;
 901 }
 902 
 903 int charactersToIntStrict(const LChar* data, size_t length, bool* ok, int base)
 904 {
 905     return toIntegralType&lt;int, LChar&gt;(data, length, ok, base);
 906 }
 907 
 908 int charactersToIntStrict(const UChar* data, size_t length, bool* ok, int base)
 909 {
 910     return toIntegralType&lt;int, UChar&gt;(data, length, ok, base);
 911 }
 912 
 913 unsigned charactersToUIntStrict(const LChar* data, size_t length, bool* ok, int base)
 914 {
 915     return toIntegralType&lt;unsigned, LChar&gt;(data, length, ok, base);
 916 }
 917 
 918 unsigned charactersToUIntStrict(const UChar* data, size_t length, bool* ok, int base)
 919 {
 920     return toIntegralType&lt;unsigned, UChar&gt;(data, length, ok, base);
 921 }
 922 
 923 int64_t charactersToInt64Strict(const LChar* data, size_t length, bool* ok, int base)
 924 {
 925     return toIntegralType&lt;int64_t, LChar&gt;(data, length, ok, base);
 926 }
 927 
 928 int64_t charactersToInt64Strict(const UChar* data, size_t length, bool* ok, int base)
 929 {
 930     return toIntegralType&lt;int64_t, UChar&gt;(data, length, ok, base);
 931 }
 932 
 933 uint64_t charactersToUInt64Strict(const LChar* data, size_t length, bool* ok, int base)
 934 {
 935     return toIntegralType&lt;uint64_t, LChar&gt;(data, length, ok, base);
 936 }
 937 
 938 uint64_t charactersToUInt64Strict(const UChar* data, size_t length, bool* ok, int base)
 939 {
 940     return toIntegralType&lt;uint64_t, UChar&gt;(data, length, ok, base);
 941 }
 942 
 943 intptr_t charactersToIntPtrStrict(const LChar* data, size_t length, bool* ok, int base)
 944 {
 945     return toIntegralType&lt;intptr_t, LChar&gt;(data, length, ok, base);
 946 }
 947 
 948 intptr_t charactersToIntPtrStrict(const UChar* data, size_t length, bool* ok, int base)
 949 {
 950     return toIntegralType&lt;intptr_t, UChar&gt;(data, length, ok, base);
 951 }
 952 
 953 int charactersToInt(const LChar* data, size_t length, bool* ok)
 954 {
 955     return toIntegralType&lt;int, LChar&gt;(data, lengthOfCharactersAsInteger&lt;LChar&gt;(data, length), ok, 10);
 956 }
 957 
 958 int charactersToInt(const UChar* data, size_t length, bool* ok)
 959 {
 960     return toIntegralType&lt;int, UChar&gt;(data, lengthOfCharactersAsInteger(data, length), ok, 10);
 961 }
 962 
 963 unsigned charactersToUInt(const LChar* data, size_t length, bool* ok)
 964 {
 965     return toIntegralType&lt;unsigned, LChar&gt;(data, lengthOfCharactersAsInteger&lt;LChar&gt;(data, length), ok, 10);
 966 }
 967 
 968 unsigned charactersToUInt(const UChar* data, size_t length, bool* ok)
 969 {
 970     return toIntegralType&lt;unsigned, UChar&gt;(data, lengthOfCharactersAsInteger&lt;UChar&gt;(data, length), ok, 10);
 971 }
 972 
 973 int64_t charactersToInt64(const LChar* data, size_t length, bool* ok)
 974 {
 975     return toIntegralType&lt;int64_t, LChar&gt;(data, lengthOfCharactersAsInteger&lt;LChar&gt;(data, length), ok, 10);
 976 }
 977 
 978 int64_t charactersToInt64(const UChar* data, size_t length, bool* ok)
 979 {
 980     return toIntegralType&lt;int64_t, UChar&gt;(data, lengthOfCharactersAsInteger&lt;UChar&gt;(data, length), ok, 10);
 981 }
 982 
 983 uint64_t charactersToUInt64(const LChar* data, size_t length, bool* ok)
 984 {
 985     return toIntegralType&lt;uint64_t, LChar&gt;(data, lengthOfCharactersAsInteger&lt;LChar&gt;(data, length), ok, 10);
 986 }
 987 
 988 uint64_t charactersToUInt64(const UChar* data, size_t length, bool* ok)
 989 {
 990     return toIntegralType&lt;uint64_t, UChar&gt;(data, lengthOfCharactersAsInteger&lt;UChar&gt;(data, length), ok, 10);
 991 }
 992 
 993 intptr_t charactersToIntPtr(const LChar* data, size_t length, bool* ok)
 994 {
 995     return toIntegralType&lt;intptr_t, LChar&gt;(data, lengthOfCharactersAsInteger&lt;LChar&gt;(data, length), ok, 10);
 996 }
 997 
 998 intptr_t charactersToIntPtr(const UChar* data, size_t length, bool* ok)
 999 {
1000     return toIntegralType&lt;intptr_t, UChar&gt;(data, lengthOfCharactersAsInteger&lt;UChar&gt;(data, length), ok, 10);
1001 }
1002 
1003 enum TrailingJunkPolicy { DisallowTrailingJunk, AllowTrailingJunk };
1004 
1005 template&lt;typename CharacterType, TrailingJunkPolicy policy&gt;
1006 static inline double toDoubleType(const CharacterType* data, size_t length, bool* ok, size_t&amp; parsedLength)
1007 {
1008     size_t leadingSpacesLength = 0;
1009     while (leadingSpacesLength &lt; length &amp;&amp; isASCIISpace(data[leadingSpacesLength]))
1010         ++leadingSpacesLength;
1011 
1012     double number = parseDouble(data + leadingSpacesLength, length - leadingSpacesLength, parsedLength);
1013     if (!parsedLength) {
1014         if (ok)
1015             *ok = false;
1016         return 0.0;
1017     }
1018 
1019     parsedLength += leadingSpacesLength;
1020     if (ok)
1021         *ok = policy == AllowTrailingJunk || parsedLength == length;
1022     return number;
1023 }
1024 
1025 double charactersToDouble(const LChar* data, size_t length, bool* ok)
1026 {
1027     size_t parsedLength;
1028     return toDoubleType&lt;LChar, DisallowTrailingJunk&gt;(data, length, ok, parsedLength);
1029 }
1030 
1031 double charactersToDouble(const UChar* data, size_t length, bool* ok)
1032 {
1033     size_t parsedLength;
1034     return toDoubleType&lt;UChar, DisallowTrailingJunk&gt;(data, length, ok, parsedLength);
1035 }
1036 
1037 float charactersToFloat(const LChar* data, size_t length, bool* ok)
1038 {
1039     // FIXME: This will return ok even when the string fits into a double but not a float.
1040     size_t parsedLength;
1041     return static_cast&lt;float&gt;(toDoubleType&lt;LChar, DisallowTrailingJunk&gt;(data, length, ok, parsedLength));
1042 }
1043 
1044 float charactersToFloat(const UChar* data, size_t length, bool* ok)
1045 {
1046     // FIXME: This will return ok even when the string fits into a double but not a float.
1047     size_t parsedLength;
1048     return static_cast&lt;float&gt;(toDoubleType&lt;UChar, DisallowTrailingJunk&gt;(data, length, ok, parsedLength));
1049 }
1050 
1051 float charactersToFloat(const LChar* data, size_t length, size_t&amp; parsedLength)
1052 {
1053     // FIXME: This will return ok even when the string fits into a double but not a float.
1054     return static_cast&lt;float&gt;(toDoubleType&lt;LChar, AllowTrailingJunk&gt;(data, length, 0, parsedLength));
1055 }
1056 
1057 float charactersToFloat(const UChar* data, size_t length, size_t&amp; parsedLength)
1058 {
1059     // FIXME: This will return ok even when the string fits into a double but not a float.
1060     return static_cast&lt;float&gt;(toDoubleType&lt;UChar, AllowTrailingJunk&gt;(data, length, 0, parsedLength));
1061 }
1062 
1063 const String&amp; emptyString()
1064 {
1065     static NeverDestroyed&lt;String&gt; emptyString(StringImpl::empty());
1066     return emptyString;
1067 }
1068 
1069 const String&amp; nullString()
1070 {
1071     static NeverDestroyed&lt;String&gt; nullString;
1072     return nullString;
1073 }
1074 
1075 } // namespace WTF
1076 
1077 #ifndef NDEBUG
1078 
1079 // For use in the debugger.
1080 String* string(const char*);
1081 Vector&lt;char&gt; asciiDebug(StringImpl* impl);
1082 Vector&lt;char&gt; asciiDebug(String&amp; string);
1083 
1084 void String::show() const
1085 {
1086     dataLogF(&quot;%s\n&quot;, asciiDebug(impl()).data());
1087 }
1088 
1089 String* string(const char* s)
1090 {
1091     // Intentionally leaks memory!
1092     return new String(s);
1093 }
1094 
1095 Vector&lt;char&gt; asciiDebug(StringImpl* impl)
1096 {
1097     if (!impl)
1098         return asciiDebug(String(&quot;[null]&quot;_s).impl());
1099 
1100     Vector&lt;char&gt; buffer;
1101     for (unsigned i = 0; i &lt; impl-&gt;length(); ++i) {
1102         UChar ch = (*impl)[i];
1103         if (isASCIIPrintable(ch)) {
1104             if (ch == &#39;\\&#39;)
1105                 buffer.append(ch);
1106             buffer.append(ch);
1107         } else {
1108             buffer.append(&#39;\\&#39;);
1109             buffer.append(&#39;u&#39;);
1110             appendUnsignedAsHexFixedSize(ch, buffer, 4);
1111         }
1112     }
1113     buffer.append(&#39;\0&#39;);
1114     return buffer;
1115 }
1116 
1117 Vector&lt;char&gt; asciiDebug(String&amp; string)
1118 {
1119     return asciiDebug(string.impl());
1120 }
1121 
1122 #endif
<a name="12" id="anc12"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="12" type="hidden" />
</body>
</html>