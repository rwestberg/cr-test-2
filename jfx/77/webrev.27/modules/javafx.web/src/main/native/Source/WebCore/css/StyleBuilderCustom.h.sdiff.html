<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/css/StyleBuilderCustom.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="StyleBuilderConverter.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="StyleColor.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/css/StyleBuilderCustom.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  20  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  21  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  22  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  23  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  24  * THE POSSIBILITY OF SUCH DAMAGE.
  25  */
  26 
  27 #pragma once
  28 
  29 #include &quot;CSSAspectRatioValue.h&quot;
  30 #include &quot;CSSCursorImageValue.h&quot;
  31 #include &quot;CSSFontFamily.h&quot;
  32 #include &quot;CSSFontValue.h&quot;
  33 #include &quot;CSSGradientValue.h&quot;
  34 #include &quot;CSSGridTemplateAreasValue.h&quot;
  35 #include &quot;CSSRegisteredCustomProperty.h&quot;
  36 #include &quot;CSSShadowValue.h&quot;
  37 #include &quot;Counter.h&quot;
  38 #include &quot;CounterContent.h&quot;
  39 #include &quot;CursorList.h&quot;
<span class="line-removed">  40 #include &quot;DashboardRegion.h&quot;</span>
  41 #include &quot;ElementAncestorIterator.h&quot;
  42 #include &quot;FontVariantBuilder.h&quot;
  43 #include &quot;Frame.h&quot;
  44 #include &quot;HTMLElement.h&quot;
  45 #include &quot;Rect.h&quot;
  46 #include &quot;SVGElement.h&quot;
  47 #include &quot;SVGRenderStyle.h&quot;
  48 #include &quot;StyleBuilderConverter.h&quot;
  49 #include &quot;StyleCachedImage.h&quot;
  50 #include &quot;StyleFontSizeFunctions.h&quot;
  51 #include &quot;StyleGeneratedImage.h&quot;
  52 #include &quot;StyleResolver.h&quot;
  53 #include &quot;WillChangeData.h&quot;
  54 
  55 namespace WebCore {
  56 
  57 #define DECLARE_PROPERTY_CUSTOM_HANDLERS(property) \
  58     static void applyInherit##property(StyleResolver&amp;); \
  59     static void applyInitial##property(StyleResolver&amp;); \
  60     static void applyValue##property(StyleResolver&amp;, CSSValue&amp;)
</pre>
<hr />
<pre>
 112     // Custom handling of initial + inherit value setting only.
 113     static void applyInitialWebkitMaskImage(StyleResolver&amp;) { }
 114     static void applyInheritWebkitMaskImage(StyleResolver&amp;) { }
 115     static void applyInitialFontFeatureSettings(StyleResolver&amp;) { }
 116     static void applyInheritFontFeatureSettings(StyleResolver&amp;) { }
 117 #if ENABLE(VARIATION_FONTS)
 118     static void applyInitialFontVariationSettings(StyleResolver&amp;) { }
 119     static void applyInheritFontVariationSettings(StyleResolver&amp;) { }
 120 #endif
 121 
 122     // Custom handling of inherit + value setting only.
 123     static void applyInheritDisplay(StyleResolver&amp;);
 124     static void applyValueDisplay(StyleResolver&amp;, CSSValue&amp;);
 125 
 126     // Custom handling of value setting only.
 127     static void applyValueBaselineShift(StyleResolver&amp;, CSSValue&amp;);
 128     static void applyValueDirection(StyleResolver&amp;, CSSValue&amp;);
 129     static void applyValueVerticalAlign(StyleResolver&amp;, CSSValue&amp;);
 130     static void applyInitialTextAlign(StyleResolver&amp;);
 131     static void applyValueTextAlign(StyleResolver&amp;, CSSValue&amp;);
<span class="line-removed"> 132 #if ENABLE(DASHBOARD_SUPPORT)</span>
<span class="line-removed"> 133     static void applyValueWebkitDashboardRegion(StyleResolver&amp;, CSSValue&amp;);</span>
<span class="line-removed"> 134 #endif</span>
 135     static void applyValueWebkitLocale(StyleResolver&amp;, CSSValue&amp;);
 136     static void applyValueWebkitTextOrientation(StyleResolver&amp;, CSSValue&amp;);
 137 #if ENABLE(TEXT_AUTOSIZING)
 138     static void applyValueWebkitTextSizeAdjust(StyleResolver&amp;, CSSValue&amp;);
 139 #endif
 140     static void applyValueWebkitTextZoom(StyleResolver&amp;, CSSValue&amp;);
 141     static void applyValueWritingMode(StyleResolver&amp;, CSSValue&amp;);
 142     static void applyValueAlt(StyleResolver&amp;, CSSValue&amp;);
 143     static void applyValueWillChange(StyleResolver&amp;, CSSValue&amp;);
 144 
 145 #if ENABLE(DARK_MODE_CSS)
<span class="line-modified"> 146     static void applyValueSupportedColorSchemes(StyleResolver&amp;, CSSValue&amp;);</span>
 147 #endif
 148 
 149     static void applyValueStrokeWidth(StyleResolver&amp;, CSSValue&amp;);
 150     static void applyValueStrokeColor(StyleResolver&amp;, CSSValue&amp;);
 151 
<span class="line-modified"> 152     static void applyInitialCustomProperty(StyleResolver&amp;, const CSSRegisteredCustomProperty*, const AtomicString&amp; name);</span>
<span class="line-modified"> 153     static void applyInheritCustomProperty(StyleResolver&amp;, const CSSRegisteredCustomProperty*, const AtomicString&amp; name);</span>
 154     static void applyValueCustomProperty(StyleResolver&amp;, const CSSRegisteredCustomProperty*, CSSCustomPropertyValue&amp;);
 155 
 156 private:
 157     static void resetEffectiveZoom(StyleResolver&amp;);
 158 
 159     static Length mmLength(double mm);
 160     static Length inchLength(double inch);
 161     static bool getPageSizeFromName(CSSPrimitiveValue* pageSizeName, CSSPrimitiveValue* pageOrientation, Length&amp; width, Length&amp; height);
 162 
 163     template &lt;CSSPropertyID id&gt;
 164     static void applyTextOrBoxShadowValue(StyleResolver&amp;, CSSValue&amp;);
 165     static bool isValidDisplayValue(StyleResolver&amp;, DisplayType);
 166 
 167     enum CounterBehavior {Increment = 0, Reset};
 168     template &lt;CounterBehavior counterBehavior&gt;
 169     static void applyInheritCounter(StyleResolver&amp;);
 170     template &lt;CounterBehavior counterBehavior&gt;
 171     static void applyValueCounter(StyleResolver&amp;, CSSValue&amp;);
 172 
 173     static float largerFontSize(float size);
</pre>
<hr />
<pre>
 311             break;
 312         case CSSValuePortrait:
 313             // Nothing to do.
 314             break;
 315         default:
 316             return false;
 317         }
 318     }
 319     return true;
 320 }
 321 
 322 inline void StyleBuilderCustom::applyValueVerticalAlign(StyleResolver&amp; styleResolver, CSSValue&amp; value)
 323 {
 324     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
 325     if (primitiveValue.valueID())
 326         styleResolver.style()-&gt;setVerticalAlign(primitiveValue);
 327     else
 328         styleResolver.style()-&gt;setVerticalAlignLength(primitiveValue.convertToLength&lt;FixedIntegerConversion | PercentConversion | CalculatedConversion&gt;(styleResolver.state().cssToLengthConversionData()));
 329 }
 330 
<span class="line-removed"> 331 #if ENABLE(DASHBOARD_SUPPORT)</span>
<span class="line-removed"> 332 </span>
<span class="line-removed"> 333 static Length convertToIntLength(const CSSPrimitiveValue* primitiveValue, const CSSToLengthConversionData&amp; conversionData)</span>
<span class="line-removed"> 334 {</span>
<span class="line-removed"> 335     return primitiveValue ? primitiveValue-&gt;convertToLength&lt;FixedIntegerConversion | PercentConversion | CalculatedConversion&gt;(conversionData) : Length(Undefined);</span>
<span class="line-removed"> 336 }</span>
<span class="line-removed"> 337 </span>
<span class="line-removed"> 338 inline void StyleBuilderCustom::applyValueWebkitDashboardRegion(StyleResolver&amp; styleResolver, CSSValue&amp; value)</span>
<span class="line-removed"> 339 {</span>
<span class="line-removed"> 340     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);</span>
<span class="line-removed"> 341     if (primitiveValue.valueID() == CSSValueNone) {</span>
<span class="line-removed"> 342         styleResolver.style()-&gt;setDashboardRegions(RenderStyle::noneDashboardRegions());</span>
<span class="line-removed"> 343         return;</span>
<span class="line-removed"> 344     }</span>
<span class="line-removed"> 345 </span>
<span class="line-removed"> 346     auto* region = primitiveValue.dashboardRegionValue();</span>
<span class="line-removed"> 347     if (!region)</span>
<span class="line-removed"> 348         return;</span>
<span class="line-removed"> 349 </span>
<span class="line-removed"> 350     auto* first = region;</span>
<span class="line-removed"> 351     while (region) {</span>
<span class="line-removed"> 352         Length top = convertToIntLength(region-&gt;top(), styleResolver.state().cssToLengthConversionData().copyWithAdjustedZoom(1.0f));</span>
<span class="line-removed"> 353         Length right = convertToIntLength(region-&gt;right(), styleResolver.state().cssToLengthConversionData().copyWithAdjustedZoom(1.0f));</span>
<span class="line-removed"> 354         Length bottom = convertToIntLength(region-&gt;bottom(), styleResolver.state().cssToLengthConversionData().copyWithAdjustedZoom(1.0f));</span>
<span class="line-removed"> 355         Length left = convertToIntLength(region-&gt;left(), styleResolver.state().cssToLengthConversionData().copyWithAdjustedZoom(1.0f));</span>
<span class="line-removed"> 356 </span>
<span class="line-removed"> 357         if (top.isUndefined())</span>
<span class="line-removed"> 358             top = Length();</span>
<span class="line-removed"> 359         if (right.isUndefined())</span>
<span class="line-removed"> 360             right = Length();</span>
<span class="line-removed"> 361         if (bottom.isUndefined())</span>
<span class="line-removed"> 362             bottom = Length();</span>
<span class="line-removed"> 363         if (left.isUndefined())</span>
<span class="line-removed"> 364             left = Length();</span>
<span class="line-removed"> 365 </span>
<span class="line-removed"> 366         if (region-&gt;m_isCircle)</span>
<span class="line-removed"> 367             styleResolver.style()-&gt;setDashboardRegion(StyleDashboardRegion::Circle, region-&gt;m_label, WTFMove(top), WTFMove(right), WTFMove(bottom), WTFMove(left), region != first);</span>
<span class="line-removed"> 368         else if (region-&gt;m_isRectangle)</span>
<span class="line-removed"> 369             styleResolver.style()-&gt;setDashboardRegion(StyleDashboardRegion::Rectangle, region-&gt;m_label, WTFMove(top), WTFMove(right), WTFMove(bottom), WTFMove(left), region != first);</span>
<span class="line-removed"> 370 </span>
<span class="line-removed"> 371         region = region-&gt;m_next.get();</span>
<span class="line-removed"> 372     }</span>
<span class="line-removed"> 373 </span>
<span class="line-removed"> 374     styleResolver.document().setHasAnnotatedRegions(true);</span>
<span class="line-removed"> 375 }</span>
<span class="line-removed"> 376 </span>
<span class="line-removed"> 377 #endif // ENABLE(DASHBOARD_SUPPORT)</span>
<span class="line-removed"> 378 </span>
 379 #if ENABLE(CSS_IMAGE_RESOLUTION)
 380 
 381 inline void StyleBuilderCustom::applyInheritImageResolution(StyleResolver&amp; styleResolver)
 382 {
 383     styleResolver.style()-&gt;setImageResolutionSource(styleResolver.parentStyle()-&gt;imageResolutionSource());
 384     styleResolver.style()-&gt;setImageResolutionSnap(styleResolver.parentStyle()-&gt;imageResolutionSnap());
 385     styleResolver.style()-&gt;setImageResolution(styleResolver.parentStyle()-&gt;imageResolution());
 386 }
 387 
 388 inline void StyleBuilderCustom::applyInitialImageResolution(StyleResolver&amp; styleResolver)
 389 {
 390     styleResolver.style()-&gt;setImageResolutionSource(RenderStyle::initialImageResolutionSource());
 391     styleResolver.style()-&gt;setImageResolutionSnap(RenderStyle::initialImageResolutionSnap());
 392     styleResolver.style()-&gt;setImageResolution(RenderStyle::initialImageResolution());
 393 }
 394 
 395 inline void StyleBuilderCustom::applyValueImageResolution(StyleResolver&amp; styleResolver, CSSValue&amp; value)
 396 {
 397     ImageResolutionSource source = RenderStyle::initialImageResolutionSource();
 398     ImageResolutionSnap snap = RenderStyle::initialImageResolutionSnap();
</pre>
<hr />
<pre>
 652 
 653 inline void StyleBuilderCustom::applyInheritLineHeight(StyleResolver&amp; styleResolver)
 654 {
 655     styleResolver.style()-&gt;setLineHeight(Length { styleResolver.parentStyle()-&gt;lineHeight() });
 656     styleResolver.style()-&gt;setSpecifiedLineHeight(Length { styleResolver.parentStyle()-&gt;specifiedLineHeight() });
 657 }
 658 
 659 inline void StyleBuilderCustom::applyInitialLineHeight(StyleResolver&amp; styleResolver)
 660 {
 661     styleResolver.style()-&gt;setLineHeight(RenderStyle::initialLineHeight());
 662     styleResolver.style()-&gt;setSpecifiedLineHeight(RenderStyle::initialSpecifiedLineHeight());
 663 }
 664 
 665 static inline float computeBaseSpecifiedFontSize(const Document&amp; document, const RenderStyle&amp; style, bool percentageAutosizingEnabled)
 666 {
 667     float result = style.specifiedFontSize();
 668     auto* frame = document.frame();
 669     if (frame &amp;&amp; style.textZoom() != TextZoom::Reset)
 670         result *= frame-&gt;textZoomFactor();
 671     result *= style.effectiveZoom();
<span class="line-modified"> 672     if (percentageAutosizingEnabled)</span>
 673         result *= style.textSizeAdjust().multiplier();
 674     return result;
 675 }
 676 
 677 static inline float computeLineHeightMultiplierDueToFontSize(const Document&amp; document, const RenderStyle&amp; style, const CSSPrimitiveValue&amp; value)
 678 {
 679     bool percentageAutosizingEnabled = document.settings().textAutosizingEnabled() &amp;&amp; style.textSizeAdjust().isPercentage();
 680 
 681     if (value.isLength()) {
 682         auto minimumFontSize = document.settings().minimumFontSize();
 683         if (minimumFontSize &gt; 0) {
 684             auto specifiedFontSize = computeBaseSpecifiedFontSize(document, style, percentageAutosizingEnabled);
 685             // Small font sizes cause a preposterously large (near infinity) line-height. Add a fuzz-factor of 1px which opts out of
 686             // boosted line-height.
 687             if (specifiedFontSize &lt; minimumFontSize &amp;&amp; specifiedFontSize &gt;= 1) {
 688                 // FIXME: There are two settings which are relevant here: minimum font size, and minimum logical font size (as
 689                 // well as things like the zoom property, text zoom on the page, and text autosizing). The minimum logical font
 690                 // size is nonzero by default, and already incorporated into the computed font size, so if we just use the ratio
 691                 // of the computed : specified font size, it will be &gt; 1 in the cases where the minimum logical font size kicks
 692                 // in. In general, this is the right thing to do, however, this kind of blanket change is too risky to perform
 693                 // right now. https://bugs.webkit.org/show_bug.cgi?id=174570 tracks turning this on. For now, we can just pretend
 694                 // that the minimum font size is the only thing affecting the computed font size.
 695 
 696                 // This calculation matches the line-height computed size calculation in
 697                 // TextAutoSizing::Value::adjustTextNodeSizes().
 698                 auto scaleChange = minimumFontSize / specifiedFontSize;
 699                 return scaleChange;
 700             }
 701         }
 702     }
 703 
<span class="line-modified"> 704     if (percentageAutosizingEnabled)</span>
 705         return style.textSizeAdjust().multiplier();
 706     return 1;
 707 }
 708 
 709 inline void StyleBuilderCustom::applyValueLineHeight(StyleResolver&amp; styleResolver, CSSValue&amp; value)
 710 {
 711     Optional&lt;Length&gt; lineHeight = StyleBuilderConverter::convertLineHeight(styleResolver, value, 1);
 712     if (!lineHeight)
 713         return;
 714 
 715     Length computedLineHeight;
 716     if (lineHeight.value().isNegative())
 717         computedLineHeight = lineHeight.value();
 718     else {
 719         auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
 720         auto multiplier = computeLineHeightMultiplierDueToFontSize(styleResolver.document(), *styleResolver.style(), primitiveValue);
 721         if (multiplier == 1)
 722             computedLineHeight = lineHeight.value();
 723         else
 724             computedLineHeight = StyleBuilderConverter::convertLineHeight(styleResolver, value, multiplier).value();
</pre>
<hr />
<pre>
 815     else if (primitiveValue.valueID() == CSSValueNone)
 816         styleResolver.style()-&gt;setTextSizeAdjust(TextSizeAdjustment(NoTextSizeAdjustment));
 817     else
 818         styleResolver.style()-&gt;setTextSizeAdjust(TextSizeAdjustment(primitiveValue.floatValue()));
 819 
 820     styleResolver.state().setFontDirty(true);
 821 }
 822 #endif
 823 
 824 inline void StyleBuilderCustom::applyValueWebkitTextZoom(StyleResolver&amp; styleResolver, CSSValue&amp; value)
 825 {
 826     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
 827     if (primitiveValue.valueID() == CSSValueNormal)
 828         styleResolver.style()-&gt;setTextZoom(TextZoom::Normal);
 829     else if (primitiveValue.valueID() == CSSValueReset)
 830         styleResolver.style()-&gt;setTextZoom(TextZoom::Reset);
 831     styleResolver.state().setFontDirty(true);
 832 }
 833 
 834 #if ENABLE(DARK_MODE_CSS)
<span class="line-modified"> 835 inline void StyleBuilderCustom::applyValueSupportedColorSchemes(StyleResolver&amp; styleResolver, CSSValue&amp; value)</span>
 836 {
<span class="line-modified"> 837     styleResolver.style()-&gt;setSupportedColorSchemes(StyleBuilderConverter::convertSupportedColorSchemes(styleResolver, value));</span>
<span class="line-modified"> 838     styleResolver.style()-&gt;setHasExplicitlySetSupportedColorSchemes(true);</span>
 839 }
 840 #endif
 841 
 842 template&lt;CSSPropertyID property&gt;
 843 inline void StyleBuilderCustom::applyTextOrBoxShadowValue(StyleResolver&amp; styleResolver, CSSValue&amp; value)
 844 {
 845     if (is&lt;CSSPrimitiveValue&gt;(value)) {
 846         ASSERT(downcast&lt;CSSPrimitiveValue&gt;(value).valueID() == CSSValueNone);
 847         if (property == CSSPropertyTextShadow)
 848             styleResolver.style()-&gt;setTextShadow(nullptr);
 849         else
 850             styleResolver.style()-&gt;setBoxShadow(nullptr);
 851         return;
 852     }
 853 
 854     bool isFirstEntry = true;
 855     for (auto&amp; item : downcast&lt;CSSValueList&gt;(value)) {
 856         auto&amp; shadowValue = downcast&lt;CSSShadowValue&gt;(item.get());
 857         auto conversionData = styleResolver.state().cssToLengthConversionData();
 858         int x = shadowValue.x-&gt;computeLength&lt;int&gt;(conversionData);
 859         int y = shadowValue.y-&gt;computeLength&lt;int&gt;(conversionData);
 860         int blur = shadowValue.blur ? shadowValue.blur-&gt;computeLength&lt;int&gt;(conversionData) : 0;
 861         int spread = shadowValue.spread ? shadowValue.spread-&gt;computeLength&lt;int&gt;(conversionData) : 0;
 862         ShadowStyle shadowStyle = shadowValue.style &amp;&amp; shadowValue.style-&gt;valueID() == CSSValueInset ? Inset : Normal;
 863         Color color;
 864         if (shadowValue.color)
 865             color = styleResolver.colorFromPrimitiveValue(*shadowValue.color);
 866         else
 867             color = styleResolver.style()-&gt;color();
<span class="line-modified"> 868         auto shadowData = std::make_unique&lt;ShadowData&gt;(IntPoint(x, y), blur, spread, shadowStyle, property == CSSPropertyWebkitBoxShadow, color.isValid() ? color : Color::transparent);</span>
 869         if (property == CSSPropertyTextShadow)
 870             styleResolver.style()-&gt;setTextShadow(WTFMove(shadowData), !isFirstEntry); // add to the list if this is not the first entry
 871         else
 872             styleResolver.style()-&gt;setBoxShadow(WTFMove(shadowData), !isFirstEntry); // add to the list if this is not the first entry
 873         isFirstEntry = false;
 874     }
 875 }
 876 
 877 inline void StyleBuilderCustom::applyInitialTextShadow(StyleResolver&amp; styleResolver)
 878 {
 879     styleResolver.style()-&gt;setTextShadow(nullptr);
 880 }
 881 
 882 inline void StyleBuilderCustom::applyInheritTextShadow(StyleResolver&amp; styleResolver)
 883 {
<span class="line-modified"> 884     styleResolver.style()-&gt;setTextShadow(styleResolver.parentStyle()-&gt;textShadow() ? std::make_unique&lt;ShadowData&gt;(*styleResolver.parentStyle()-&gt;textShadow()) : nullptr);</span>
 885 }
 886 
 887 inline void StyleBuilderCustom::applyValueTextShadow(StyleResolver&amp; styleResolver, CSSValue&amp; value)
 888 {
 889     applyTextOrBoxShadowValue&lt;CSSPropertyTextShadow&gt;(styleResolver, value);
 890 }
 891 
 892 inline void StyleBuilderCustom::applyInitialBoxShadow(StyleResolver&amp; styleResolver)
 893 {
 894     styleResolver.style()-&gt;setBoxShadow(nullptr);
 895 }
 896 
 897 inline void StyleBuilderCustom::applyInheritBoxShadow(StyleResolver&amp; styleResolver)
 898 {
<span class="line-modified"> 899     styleResolver.style()-&gt;setBoxShadow(styleResolver.parentStyle()-&gt;boxShadow() ? std::make_unique&lt;ShadowData&gt;(*styleResolver.parentStyle()-&gt;boxShadow()) : nullptr);</span>
 900 }
 901 
 902 inline void StyleBuilderCustom::applyValueBoxShadow(StyleResolver&amp; styleResolver, CSSValue&amp; value)
 903 {
 904     applyTextOrBoxShadowValue&lt;CSSPropertyBoxShadow&gt;(styleResolver, value);
 905 }
 906 
 907 inline void StyleBuilderCustom::applyInitialWebkitBoxShadow(StyleResolver&amp; styleResolver)
 908 {
 909     applyInitialBoxShadow(styleResolver);
 910 }
 911 
 912 inline void StyleBuilderCustom::applyInheritWebkitBoxShadow(StyleResolver&amp; styleResolver)
 913 {
 914     applyInheritBoxShadow(styleResolver);
 915 }
 916 
 917 inline void StyleBuilderCustom::applyValueWebkitBoxShadow(StyleResolver&amp; styleResolver, CSSValue&amp; value)
 918 {
 919     applyTextOrBoxShadowValue&lt;CSSPropertyWebkitBoxShadow&gt;(styleResolver, value);
</pre>
<hr />
<pre>
 936 }
 937 
 938 inline void StyleBuilderCustom::applyInheritFontFamily(StyleResolver&amp; styleResolver)
 939 {
 940     auto fontDescription = styleResolver.style()-&gt;fontDescription();
 941     auto parentFontDescription = styleResolver.parentStyle()-&gt;fontDescription();
 942 
 943     fontDescription.setFamilies(parentFontDescription.families());
 944     fontDescription.setIsSpecifiedFont(parentFontDescription.isSpecifiedFont());
 945     styleResolver.setFontDescription(WTFMove(fontDescription));
 946 }
 947 
 948 inline void StyleBuilderCustom::applyValueFontFamily(StyleResolver&amp; styleResolver, CSSValue&amp; value)
 949 {
 950     auto&amp; valueList = downcast&lt;CSSValueList&gt;(value);
 951 
 952     auto fontDescription = styleResolver.style()-&gt;fontDescription();
 953     // Before mapping in a new font-family property, we should reset the generic family.
 954     bool oldFamilyUsedFixedDefaultSize = fontDescription.useFixedDefaultSize();
 955 
<span class="line-modified"> 956     Vector&lt;AtomicString&gt; families;</span>
 957     families.reserveInitialCapacity(valueList.length());
 958 
 959     for (auto&amp; item : valueList) {
 960         auto&amp; contentValue = downcast&lt;CSSPrimitiveValue&gt;(item.get());
<span class="line-modified"> 961         AtomicString family;</span>
 962         bool isGenericFamily = false;
 963         if (contentValue.isFontFamily()) {
 964             const CSSFontFamily&amp; fontFamily = contentValue.fontFamily();
 965             family = fontFamily.familyName;
 966             // If the family name was resolved by the CSS parser from a system font ID, then it is generic.
 967             isGenericFamily = fontFamily.fromSystemFontID;
 968         } else {
 969             switch (contentValue.valueID()) {
 970             case CSSValueWebkitBody:
 971                 family = styleResolver.settings().standardFontFamily();
 972                 break;
 973             case CSSValueSerif:
 974                 family = serifFamily;
 975                 isGenericFamily = true;
 976                 break;
 977             case CSSValueSansSerif:
 978                 family = sansSerifFamily;
 979                 isGenericFamily = true;
 980                 break;
 981             case CSSValueCursive:
</pre>
<hr />
<pre>
1170 inline void StyleBuilderCustom::applyValueCounter(StyleResolver&amp; styleResolver, CSSValue&amp; value)
1171 {
1172     bool setCounterIncrementToNone = counterBehavior == Increment &amp;&amp; is&lt;CSSPrimitiveValue&gt;(value) &amp;&amp; downcast&lt;CSSPrimitiveValue&gt;(value).valueID() == CSSValueNone;
1173 
1174     if (!is&lt;CSSValueList&gt;(value) &amp;&amp; !setCounterIncrementToNone)
1175         return;
1176 
1177     CounterDirectiveMap&amp; map = styleResolver.style()-&gt;accessCounterDirectives();
1178     for (auto&amp; keyValue : map) {
1179         if (counterBehavior == Reset)
1180             keyValue.value.resetValue = WTF::nullopt;
1181         else
1182             keyValue.value.incrementValue = WTF::nullopt;
1183     }
1184 
1185     if (setCounterIncrementToNone)
1186         return;
1187 
1188     for (auto&amp; item : downcast&lt;CSSValueList&gt;(value)) {
1189         Pair* pair = downcast&lt;CSSPrimitiveValue&gt;(item.get()).pairValue();
<span class="line-modified">1190         AtomicString identifier = pair-&gt;first()-&gt;stringValue();</span>
1191         int value = pair-&gt;second()-&gt;intValue();
1192         auto&amp; directives = map.add(identifier, CounterDirectives { }).iterator-&gt;value;
1193         if (counterBehavior == Reset)
1194             directives.resetValue = value;
1195         else
1196             directives.incrementValue = saturatedAddition(directives.incrementValue.valueOr(0), value);
1197     }
1198 }
1199 
1200 inline void StyleBuilderCustom::applyInitialCounterIncrement(StyleResolver&amp;) { }
1201 
1202 inline void StyleBuilderCustom::applyInheritCounterIncrement(StyleResolver&amp; styleResolver)
1203 {
1204     applyInheritCounter&lt;Increment&gt;(styleResolver);
1205 }
1206 
1207 inline void StyleBuilderCustom::applyValueCounterIncrement(StyleResolver&amp; styleResolver, CSSValue&amp; value)
1208 {
1209     applyValueCounter&lt;Increment&gt;(styleResolver, value);
1210 }
</pre>
<hr />
<pre>
1383         if (is&lt;CSSImageValue&gt;(item)) {
1384             styleResolver.style()-&gt;setContent(StyleCachedImage::create(item), didSet);
1385             didSet = true;
1386             continue;
1387         }
1388 
1389         if (!is&lt;CSSPrimitiveValue&gt;(item))
1390             continue;
1391 
1392         auto&amp; contentValue = downcast&lt;CSSPrimitiveValue&gt;(item.get());
1393         if (contentValue.isString()) {
1394             styleResolver.style()-&gt;setContent(contentValue.stringValue().impl(), didSet);
1395             didSet = true;
1396         } else if (contentValue.isAttr()) {
1397             // FIXME: Can a namespace be specified for an attr(foo)?
1398             if (styleResolver.style()-&gt;styleType() == PseudoId::None)
1399                 styleResolver.style()-&gt;setHasAttrContent();
1400             else
1401                 const_cast&lt;RenderStyle*&gt;(styleResolver.parentStyle())-&gt;setHasAttrContent();
1402             QualifiedName attr(nullAtom(), contentValue.stringValue().impl(), nullAtom());
<span class="line-modified">1403             const AtomicString&amp; value = styleResolver.element()-&gt;getAttribute(attr);</span>
1404             styleResolver.style()-&gt;setContent(value.isNull() ? emptyAtom() : value.impl(), didSet);
1405             didSet = true;
1406             // Register the fact that the attribute value affects the style.
1407             styleResolver.ruleSets().mutableFeatures().registerContentAttribute(attr.localName());
1408         } else if (contentValue.isCounter()) {
1409             auto* counterValue = contentValue.counterValue();
1410             ListStyleType listStyleType = ListStyleType::None;
1411             CSSValueID listStyleIdent = counterValue-&gt;listStyleIdent();
1412             if (listStyleIdent != CSSValueNone)
1413                 listStyleType = static_cast&lt;ListStyleType&gt;(listStyleIdent - CSSValueDisc);
<span class="line-modified">1414             auto counter = std::make_unique&lt;CounterContent&gt;(counterValue-&gt;identifier(), listStyleType, counterValue-&gt;separator());</span>
1415             styleResolver.style()-&gt;setContent(WTFMove(counter), didSet);
1416             didSet = true;
1417         } else {
1418             switch (contentValue.valueID()) {
1419             case CSSValueOpenQuote:
1420                 styleResolver.style()-&gt;setContent(QuoteType::OpenQuote, didSet);
1421                 didSet = true;
1422                 break;
1423             case CSSValueCloseQuote:
1424                 styleResolver.style()-&gt;setContent(QuoteType::CloseQuote, didSet);
1425                 didSet = true;
1426                 break;
1427             case CSSValueNoOpenQuote:
1428                 styleResolver.style()-&gt;setContent(QuoteType::NoOpenQuote, didSet);
1429                 didSet = true;
1430                 break;
1431             case CSSValueNoCloseQuote:
1432                 styleResolver.style()-&gt;setContent(QuoteType::NoCloseQuote, didSet);
1433                 didSet = true;
1434                 break;
</pre>
<hr />
<pre>
1780     const NamedGridAreaMap&amp; namedGridAreas = styleResolver.style()-&gt;namedGridArea();
1781     if (!namedGridAreas.isEmpty())
1782         StyleBuilderConverter::createImplicitNamedGridLinesFromGridArea(namedGridAreas, tracksData.m_namedGridLines, ForRows);
1783 
1784     SET_TRACKS_DATA(tracksData, styleResolver.style(), Row);
1785 }
1786 
1787 void StyleBuilderCustom::applyValueAlt(StyleResolver&amp; styleResolver, CSSValue&amp; value)
1788 {
1789     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
1790     if (primitiveValue.isString())
1791         styleResolver.style()-&gt;setContentAltText(primitiveValue.stringValue());
1792     else if (primitiveValue.isAttr()) {
1793         // FIXME: Can a namespace be specified for an attr(foo)?
1794         if (styleResolver.style()-&gt;styleType() == PseudoId::None)
1795             styleResolver.style()-&gt;setUnique();
1796         else
1797             const_cast&lt;RenderStyle*&gt;(styleResolver.parentStyle())-&gt;setUnique();
1798 
1799         QualifiedName attr(nullAtom(), primitiveValue.stringValue(), nullAtom());
<span class="line-modified">1800         const AtomicString&amp; value = styleResolver.element()-&gt;getAttribute(attr);</span>
1801         styleResolver.style()-&gt;setContentAltText(value.isNull() ? emptyAtom() : value);
1802 
1803         // Register the fact that the attribute value affects the style.
1804         styleResolver.ruleSets().mutableFeatures().registerContentAttribute(attr.localName());
1805     } else
1806         styleResolver.style()-&gt;setContentAltText(emptyAtom());
1807 }
1808 
1809 inline void StyleBuilderCustom::applyValueWillChange(StyleResolver&amp; styleResolver, CSSValue&amp; value)
1810 {
1811     if (is&lt;CSSPrimitiveValue&gt;(value)) {
1812         ASSERT(downcast&lt;CSSPrimitiveValue&gt;(value).valueID() == CSSValueAuto);
1813         styleResolver.style()-&gt;setWillChange(nullptr);
1814         return;
1815     }
1816 
1817     auto willChange = WillChangeData::create();
1818     for (auto&amp; item : downcast&lt;CSSValueList&gt;(value)) {
1819         if (!is&lt;CSSPrimitiveValue&gt;(item))
1820             continue;
</pre>
<hr />
<pre>
1834     }
1835     styleResolver.style()-&gt;setWillChange(WTFMove(willChange));
1836 }
1837 
1838 inline void StyleBuilderCustom::applyValueStrokeWidth(StyleResolver&amp; styleResolver, CSSValue&amp; value)
1839 {
1840     styleResolver.style()-&gt;setStrokeWidth(StyleBuilderConverter::convertLength(styleResolver, value));
1841     styleResolver.style()-&gt;setHasExplicitlySetStrokeWidth(true);
1842 }
1843 
1844 inline void StyleBuilderCustom::applyValueStrokeColor(StyleResolver&amp; styleResolver, CSSValue&amp; value)
1845 {
1846     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
1847     if (styleResolver.applyPropertyToRegularStyle())
1848         styleResolver.style()-&gt;setStrokeColor(styleResolver.colorFromPrimitiveValue(primitiveValue, /* forVisitedLink */ false));
1849     if (styleResolver.applyPropertyToVisitedLinkStyle())
1850         styleResolver.style()-&gt;setVisitedLinkStrokeColor(styleResolver.colorFromPrimitiveValue(primitiveValue, /* forVisitedLink */ true));
1851     styleResolver.style()-&gt;setHasExplicitlySetStrokeColor(true);
1852 }
1853 
<span class="line-modified">1854 inline void StyleBuilderCustom::applyInitialCustomProperty(StyleResolver&amp; styleResolver, const CSSRegisteredCustomProperty* registered, const AtomicString&amp; name)</span>
1855 {
1856     if (registered &amp;&amp; registered-&gt;initialValue()) {
1857         auto initialValue = registered-&gt;initialValueCopy();
1858         applyValueCustomProperty(styleResolver, registered, *initialValue);
1859         return;
1860     }
1861 
1862     auto invalid = CSSCustomPropertyValue::createUnresolved(name, CSSValueInvalid);
1863     applyValueCustomProperty(styleResolver, registered, invalid.get());
1864 }
1865 
<span class="line-modified">1866 inline void StyleBuilderCustom::applyInheritCustomProperty(StyleResolver&amp; styleResolver, const CSSRegisteredCustomProperty* registered, const AtomicString&amp; name)</span>
1867 {
1868     auto* parentValue = styleResolver.parentStyle() ? styleResolver.parentStyle()-&gt;inheritedCustomProperties().get(name) : nullptr;
1869     if (parentValue &amp;&amp; !(registered &amp;&amp; !registered-&gt;inherits))
1870         applyValueCustomProperty(styleResolver, registered, *parentValue);
1871     else
1872         applyInitialCustomProperty(styleResolver, registered, name);
1873 }
1874 
1875 inline void StyleBuilderCustom::applyValueCustomProperty(StyleResolver&amp; styleResolver, const CSSRegisteredCustomProperty* registered, CSSCustomPropertyValue&amp; value)
1876 {
1877     ASSERT(value.isResolved());
1878     const auto&amp; name = value.name();
1879 
1880     if (!registered || registered-&gt;inherits)
1881         styleResolver.style()-&gt;setInheritedCustomPropertyValue(name, makeRef(value));
1882     else
1883         styleResolver.style()-&gt;setNonInheritedCustomPropertyValue(name, makeRef(value));
1884 }
1885 
1886 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
  20  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  21  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  22  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  23  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  24  * THE POSSIBILITY OF SUCH DAMAGE.
  25  */
  26 
  27 #pragma once
  28 
  29 #include &quot;CSSAspectRatioValue.h&quot;
  30 #include &quot;CSSCursorImageValue.h&quot;
  31 #include &quot;CSSFontFamily.h&quot;
  32 #include &quot;CSSFontValue.h&quot;
  33 #include &quot;CSSGradientValue.h&quot;
  34 #include &quot;CSSGridTemplateAreasValue.h&quot;
  35 #include &quot;CSSRegisteredCustomProperty.h&quot;
  36 #include &quot;CSSShadowValue.h&quot;
  37 #include &quot;Counter.h&quot;
  38 #include &quot;CounterContent.h&quot;
  39 #include &quot;CursorList.h&quot;

  40 #include &quot;ElementAncestorIterator.h&quot;
  41 #include &quot;FontVariantBuilder.h&quot;
  42 #include &quot;Frame.h&quot;
  43 #include &quot;HTMLElement.h&quot;
  44 #include &quot;Rect.h&quot;
  45 #include &quot;SVGElement.h&quot;
  46 #include &quot;SVGRenderStyle.h&quot;
  47 #include &quot;StyleBuilderConverter.h&quot;
  48 #include &quot;StyleCachedImage.h&quot;
  49 #include &quot;StyleFontSizeFunctions.h&quot;
  50 #include &quot;StyleGeneratedImage.h&quot;
  51 #include &quot;StyleResolver.h&quot;
  52 #include &quot;WillChangeData.h&quot;
  53 
  54 namespace WebCore {
  55 
  56 #define DECLARE_PROPERTY_CUSTOM_HANDLERS(property) \
  57     static void applyInherit##property(StyleResolver&amp;); \
  58     static void applyInitial##property(StyleResolver&amp;); \
  59     static void applyValue##property(StyleResolver&amp;, CSSValue&amp;)
</pre>
<hr />
<pre>
 111     // Custom handling of initial + inherit value setting only.
 112     static void applyInitialWebkitMaskImage(StyleResolver&amp;) { }
 113     static void applyInheritWebkitMaskImage(StyleResolver&amp;) { }
 114     static void applyInitialFontFeatureSettings(StyleResolver&amp;) { }
 115     static void applyInheritFontFeatureSettings(StyleResolver&amp;) { }
 116 #if ENABLE(VARIATION_FONTS)
 117     static void applyInitialFontVariationSettings(StyleResolver&amp;) { }
 118     static void applyInheritFontVariationSettings(StyleResolver&amp;) { }
 119 #endif
 120 
 121     // Custom handling of inherit + value setting only.
 122     static void applyInheritDisplay(StyleResolver&amp;);
 123     static void applyValueDisplay(StyleResolver&amp;, CSSValue&amp;);
 124 
 125     // Custom handling of value setting only.
 126     static void applyValueBaselineShift(StyleResolver&amp;, CSSValue&amp;);
 127     static void applyValueDirection(StyleResolver&amp;, CSSValue&amp;);
 128     static void applyValueVerticalAlign(StyleResolver&amp;, CSSValue&amp;);
 129     static void applyInitialTextAlign(StyleResolver&amp;);
 130     static void applyValueTextAlign(StyleResolver&amp;, CSSValue&amp;);



 131     static void applyValueWebkitLocale(StyleResolver&amp;, CSSValue&amp;);
 132     static void applyValueWebkitTextOrientation(StyleResolver&amp;, CSSValue&amp;);
 133 #if ENABLE(TEXT_AUTOSIZING)
 134     static void applyValueWebkitTextSizeAdjust(StyleResolver&amp;, CSSValue&amp;);
 135 #endif
 136     static void applyValueWebkitTextZoom(StyleResolver&amp;, CSSValue&amp;);
 137     static void applyValueWritingMode(StyleResolver&amp;, CSSValue&amp;);
 138     static void applyValueAlt(StyleResolver&amp;, CSSValue&amp;);
 139     static void applyValueWillChange(StyleResolver&amp;, CSSValue&amp;);
 140 
 141 #if ENABLE(DARK_MODE_CSS)
<span class="line-modified"> 142     static void applyValueColorScheme(StyleResolver&amp;, CSSValue&amp;);</span>
 143 #endif
 144 
 145     static void applyValueStrokeWidth(StyleResolver&amp;, CSSValue&amp;);
 146     static void applyValueStrokeColor(StyleResolver&amp;, CSSValue&amp;);
 147 
<span class="line-modified"> 148     static void applyInitialCustomProperty(StyleResolver&amp;, const CSSRegisteredCustomProperty*, const AtomString&amp; name);</span>
<span class="line-modified"> 149     static void applyInheritCustomProperty(StyleResolver&amp;, const CSSRegisteredCustomProperty*, const AtomString&amp; name);</span>
 150     static void applyValueCustomProperty(StyleResolver&amp;, const CSSRegisteredCustomProperty*, CSSCustomPropertyValue&amp;);
 151 
 152 private:
 153     static void resetEffectiveZoom(StyleResolver&amp;);
 154 
 155     static Length mmLength(double mm);
 156     static Length inchLength(double inch);
 157     static bool getPageSizeFromName(CSSPrimitiveValue* pageSizeName, CSSPrimitiveValue* pageOrientation, Length&amp; width, Length&amp; height);
 158 
 159     template &lt;CSSPropertyID id&gt;
 160     static void applyTextOrBoxShadowValue(StyleResolver&amp;, CSSValue&amp;);
 161     static bool isValidDisplayValue(StyleResolver&amp;, DisplayType);
 162 
 163     enum CounterBehavior {Increment = 0, Reset};
 164     template &lt;CounterBehavior counterBehavior&gt;
 165     static void applyInheritCounter(StyleResolver&amp;);
 166     template &lt;CounterBehavior counterBehavior&gt;
 167     static void applyValueCounter(StyleResolver&amp;, CSSValue&amp;);
 168 
 169     static float largerFontSize(float size);
</pre>
<hr />
<pre>
 307             break;
 308         case CSSValuePortrait:
 309             // Nothing to do.
 310             break;
 311         default:
 312             return false;
 313         }
 314     }
 315     return true;
 316 }
 317 
 318 inline void StyleBuilderCustom::applyValueVerticalAlign(StyleResolver&amp; styleResolver, CSSValue&amp; value)
 319 {
 320     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
 321     if (primitiveValue.valueID())
 322         styleResolver.style()-&gt;setVerticalAlign(primitiveValue);
 323     else
 324         styleResolver.style()-&gt;setVerticalAlignLength(primitiveValue.convertToLength&lt;FixedIntegerConversion | PercentConversion | CalculatedConversion&gt;(styleResolver.state().cssToLengthConversionData()));
 325 }
 326 
















































 327 #if ENABLE(CSS_IMAGE_RESOLUTION)
 328 
 329 inline void StyleBuilderCustom::applyInheritImageResolution(StyleResolver&amp; styleResolver)
 330 {
 331     styleResolver.style()-&gt;setImageResolutionSource(styleResolver.parentStyle()-&gt;imageResolutionSource());
 332     styleResolver.style()-&gt;setImageResolutionSnap(styleResolver.parentStyle()-&gt;imageResolutionSnap());
 333     styleResolver.style()-&gt;setImageResolution(styleResolver.parentStyle()-&gt;imageResolution());
 334 }
 335 
 336 inline void StyleBuilderCustom::applyInitialImageResolution(StyleResolver&amp; styleResolver)
 337 {
 338     styleResolver.style()-&gt;setImageResolutionSource(RenderStyle::initialImageResolutionSource());
 339     styleResolver.style()-&gt;setImageResolutionSnap(RenderStyle::initialImageResolutionSnap());
 340     styleResolver.style()-&gt;setImageResolution(RenderStyle::initialImageResolution());
 341 }
 342 
 343 inline void StyleBuilderCustom::applyValueImageResolution(StyleResolver&amp; styleResolver, CSSValue&amp; value)
 344 {
 345     ImageResolutionSource source = RenderStyle::initialImageResolutionSource();
 346     ImageResolutionSnap snap = RenderStyle::initialImageResolutionSnap();
</pre>
<hr />
<pre>
 600 
 601 inline void StyleBuilderCustom::applyInheritLineHeight(StyleResolver&amp; styleResolver)
 602 {
 603     styleResolver.style()-&gt;setLineHeight(Length { styleResolver.parentStyle()-&gt;lineHeight() });
 604     styleResolver.style()-&gt;setSpecifiedLineHeight(Length { styleResolver.parentStyle()-&gt;specifiedLineHeight() });
 605 }
 606 
 607 inline void StyleBuilderCustom::applyInitialLineHeight(StyleResolver&amp; styleResolver)
 608 {
 609     styleResolver.style()-&gt;setLineHeight(RenderStyle::initialLineHeight());
 610     styleResolver.style()-&gt;setSpecifiedLineHeight(RenderStyle::initialSpecifiedLineHeight());
 611 }
 612 
 613 static inline float computeBaseSpecifiedFontSize(const Document&amp; document, const RenderStyle&amp; style, bool percentageAutosizingEnabled)
 614 {
 615     float result = style.specifiedFontSize();
 616     auto* frame = document.frame();
 617     if (frame &amp;&amp; style.textZoom() != TextZoom::Reset)
 618         result *= frame-&gt;textZoomFactor();
 619     result *= style.effectiveZoom();
<span class="line-modified"> 620     if (percentageAutosizingEnabled &amp;&amp; !document.settings().textAutosizingUsesIdempotentMode())</span>
 621         result *= style.textSizeAdjust().multiplier();
 622     return result;
 623 }
 624 
 625 static inline float computeLineHeightMultiplierDueToFontSize(const Document&amp; document, const RenderStyle&amp; style, const CSSPrimitiveValue&amp; value)
 626 {
 627     bool percentageAutosizingEnabled = document.settings().textAutosizingEnabled() &amp;&amp; style.textSizeAdjust().isPercentage();
 628 
 629     if (value.isLength()) {
 630         auto minimumFontSize = document.settings().minimumFontSize();
 631         if (minimumFontSize &gt; 0) {
 632             auto specifiedFontSize = computeBaseSpecifiedFontSize(document, style, percentageAutosizingEnabled);
 633             // Small font sizes cause a preposterously large (near infinity) line-height. Add a fuzz-factor of 1px which opts out of
 634             // boosted line-height.
 635             if (specifiedFontSize &lt; minimumFontSize &amp;&amp; specifiedFontSize &gt;= 1) {
 636                 // FIXME: There are two settings which are relevant here: minimum font size, and minimum logical font size (as
 637                 // well as things like the zoom property, text zoom on the page, and text autosizing). The minimum logical font
 638                 // size is nonzero by default, and already incorporated into the computed font size, so if we just use the ratio
 639                 // of the computed : specified font size, it will be &gt; 1 in the cases where the minimum logical font size kicks
 640                 // in. In general, this is the right thing to do, however, this kind of blanket change is too risky to perform
 641                 // right now. https://bugs.webkit.org/show_bug.cgi?id=174570 tracks turning this on. For now, we can just pretend
 642                 // that the minimum font size is the only thing affecting the computed font size.
 643 
 644                 // This calculation matches the line-height computed size calculation in
 645                 // TextAutoSizing::Value::adjustTextNodeSizes().
 646                 auto scaleChange = minimumFontSize / specifiedFontSize;
 647                 return scaleChange;
 648             }
 649         }
 650     }
 651 
<span class="line-modified"> 652     if (percentageAutosizingEnabled &amp;&amp; !document.settings().textAutosizingUsesIdempotentMode())</span>
 653         return style.textSizeAdjust().multiplier();
 654     return 1;
 655 }
 656 
 657 inline void StyleBuilderCustom::applyValueLineHeight(StyleResolver&amp; styleResolver, CSSValue&amp; value)
 658 {
 659     Optional&lt;Length&gt; lineHeight = StyleBuilderConverter::convertLineHeight(styleResolver, value, 1);
 660     if (!lineHeight)
 661         return;
 662 
 663     Length computedLineHeight;
 664     if (lineHeight.value().isNegative())
 665         computedLineHeight = lineHeight.value();
 666     else {
 667         auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
 668         auto multiplier = computeLineHeightMultiplierDueToFontSize(styleResolver.document(), *styleResolver.style(), primitiveValue);
 669         if (multiplier == 1)
 670             computedLineHeight = lineHeight.value();
 671         else
 672             computedLineHeight = StyleBuilderConverter::convertLineHeight(styleResolver, value, multiplier).value();
</pre>
<hr />
<pre>
 763     else if (primitiveValue.valueID() == CSSValueNone)
 764         styleResolver.style()-&gt;setTextSizeAdjust(TextSizeAdjustment(NoTextSizeAdjustment));
 765     else
 766         styleResolver.style()-&gt;setTextSizeAdjust(TextSizeAdjustment(primitiveValue.floatValue()));
 767 
 768     styleResolver.state().setFontDirty(true);
 769 }
 770 #endif
 771 
 772 inline void StyleBuilderCustom::applyValueWebkitTextZoom(StyleResolver&amp; styleResolver, CSSValue&amp; value)
 773 {
 774     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
 775     if (primitiveValue.valueID() == CSSValueNormal)
 776         styleResolver.style()-&gt;setTextZoom(TextZoom::Normal);
 777     else if (primitiveValue.valueID() == CSSValueReset)
 778         styleResolver.style()-&gt;setTextZoom(TextZoom::Reset);
 779     styleResolver.state().setFontDirty(true);
 780 }
 781 
 782 #if ENABLE(DARK_MODE_CSS)
<span class="line-modified"> 783 inline void StyleBuilderCustom::applyValueColorScheme(StyleResolver&amp; styleResolver, CSSValue&amp; value)</span>
 784 {
<span class="line-modified"> 785     styleResolver.style()-&gt;setColorScheme(StyleBuilderConverter::convertColorScheme(styleResolver, value));</span>
<span class="line-modified"> 786     styleResolver.style()-&gt;setHasExplicitlySetColorScheme(true);</span>
 787 }
 788 #endif
 789 
 790 template&lt;CSSPropertyID property&gt;
 791 inline void StyleBuilderCustom::applyTextOrBoxShadowValue(StyleResolver&amp; styleResolver, CSSValue&amp; value)
 792 {
 793     if (is&lt;CSSPrimitiveValue&gt;(value)) {
 794         ASSERT(downcast&lt;CSSPrimitiveValue&gt;(value).valueID() == CSSValueNone);
 795         if (property == CSSPropertyTextShadow)
 796             styleResolver.style()-&gt;setTextShadow(nullptr);
 797         else
 798             styleResolver.style()-&gt;setBoxShadow(nullptr);
 799         return;
 800     }
 801 
 802     bool isFirstEntry = true;
 803     for (auto&amp; item : downcast&lt;CSSValueList&gt;(value)) {
 804         auto&amp; shadowValue = downcast&lt;CSSShadowValue&gt;(item.get());
 805         auto conversionData = styleResolver.state().cssToLengthConversionData();
 806         int x = shadowValue.x-&gt;computeLength&lt;int&gt;(conversionData);
 807         int y = shadowValue.y-&gt;computeLength&lt;int&gt;(conversionData);
 808         int blur = shadowValue.blur ? shadowValue.blur-&gt;computeLength&lt;int&gt;(conversionData) : 0;
 809         int spread = shadowValue.spread ? shadowValue.spread-&gt;computeLength&lt;int&gt;(conversionData) : 0;
 810         ShadowStyle shadowStyle = shadowValue.style &amp;&amp; shadowValue.style-&gt;valueID() == CSSValueInset ? Inset : Normal;
 811         Color color;
 812         if (shadowValue.color)
 813             color = styleResolver.colorFromPrimitiveValue(*shadowValue.color);
 814         else
 815             color = styleResolver.style()-&gt;color();
<span class="line-modified"> 816         auto shadowData = makeUnique&lt;ShadowData&gt;(IntPoint(x, y), blur, spread, shadowStyle, property == CSSPropertyWebkitBoxShadow, color.isValid() ? color : Color::transparent);</span>
 817         if (property == CSSPropertyTextShadow)
 818             styleResolver.style()-&gt;setTextShadow(WTFMove(shadowData), !isFirstEntry); // add to the list if this is not the first entry
 819         else
 820             styleResolver.style()-&gt;setBoxShadow(WTFMove(shadowData), !isFirstEntry); // add to the list if this is not the first entry
 821         isFirstEntry = false;
 822     }
 823 }
 824 
 825 inline void StyleBuilderCustom::applyInitialTextShadow(StyleResolver&amp; styleResolver)
 826 {
 827     styleResolver.style()-&gt;setTextShadow(nullptr);
 828 }
 829 
 830 inline void StyleBuilderCustom::applyInheritTextShadow(StyleResolver&amp; styleResolver)
 831 {
<span class="line-modified"> 832     styleResolver.style()-&gt;setTextShadow(styleResolver.parentStyle()-&gt;textShadow() ? makeUnique&lt;ShadowData&gt;(*styleResolver.parentStyle()-&gt;textShadow()) : nullptr);</span>
 833 }
 834 
 835 inline void StyleBuilderCustom::applyValueTextShadow(StyleResolver&amp; styleResolver, CSSValue&amp; value)
 836 {
 837     applyTextOrBoxShadowValue&lt;CSSPropertyTextShadow&gt;(styleResolver, value);
 838 }
 839 
 840 inline void StyleBuilderCustom::applyInitialBoxShadow(StyleResolver&amp; styleResolver)
 841 {
 842     styleResolver.style()-&gt;setBoxShadow(nullptr);
 843 }
 844 
 845 inline void StyleBuilderCustom::applyInheritBoxShadow(StyleResolver&amp; styleResolver)
 846 {
<span class="line-modified"> 847     styleResolver.style()-&gt;setBoxShadow(styleResolver.parentStyle()-&gt;boxShadow() ? makeUnique&lt;ShadowData&gt;(*styleResolver.parentStyle()-&gt;boxShadow()) : nullptr);</span>
 848 }
 849 
 850 inline void StyleBuilderCustom::applyValueBoxShadow(StyleResolver&amp; styleResolver, CSSValue&amp; value)
 851 {
 852     applyTextOrBoxShadowValue&lt;CSSPropertyBoxShadow&gt;(styleResolver, value);
 853 }
 854 
 855 inline void StyleBuilderCustom::applyInitialWebkitBoxShadow(StyleResolver&amp; styleResolver)
 856 {
 857     applyInitialBoxShadow(styleResolver);
 858 }
 859 
 860 inline void StyleBuilderCustom::applyInheritWebkitBoxShadow(StyleResolver&amp; styleResolver)
 861 {
 862     applyInheritBoxShadow(styleResolver);
 863 }
 864 
 865 inline void StyleBuilderCustom::applyValueWebkitBoxShadow(StyleResolver&amp; styleResolver, CSSValue&amp; value)
 866 {
 867     applyTextOrBoxShadowValue&lt;CSSPropertyWebkitBoxShadow&gt;(styleResolver, value);
</pre>
<hr />
<pre>
 884 }
 885 
 886 inline void StyleBuilderCustom::applyInheritFontFamily(StyleResolver&amp; styleResolver)
 887 {
 888     auto fontDescription = styleResolver.style()-&gt;fontDescription();
 889     auto parentFontDescription = styleResolver.parentStyle()-&gt;fontDescription();
 890 
 891     fontDescription.setFamilies(parentFontDescription.families());
 892     fontDescription.setIsSpecifiedFont(parentFontDescription.isSpecifiedFont());
 893     styleResolver.setFontDescription(WTFMove(fontDescription));
 894 }
 895 
 896 inline void StyleBuilderCustom::applyValueFontFamily(StyleResolver&amp; styleResolver, CSSValue&amp; value)
 897 {
 898     auto&amp; valueList = downcast&lt;CSSValueList&gt;(value);
 899 
 900     auto fontDescription = styleResolver.style()-&gt;fontDescription();
 901     // Before mapping in a new font-family property, we should reset the generic family.
 902     bool oldFamilyUsedFixedDefaultSize = fontDescription.useFixedDefaultSize();
 903 
<span class="line-modified"> 904     Vector&lt;AtomString&gt; families;</span>
 905     families.reserveInitialCapacity(valueList.length());
 906 
 907     for (auto&amp; item : valueList) {
 908         auto&amp; contentValue = downcast&lt;CSSPrimitiveValue&gt;(item.get());
<span class="line-modified"> 909         AtomString family;</span>
 910         bool isGenericFamily = false;
 911         if (contentValue.isFontFamily()) {
 912             const CSSFontFamily&amp; fontFamily = contentValue.fontFamily();
 913             family = fontFamily.familyName;
 914             // If the family name was resolved by the CSS parser from a system font ID, then it is generic.
 915             isGenericFamily = fontFamily.fromSystemFontID;
 916         } else {
 917             switch (contentValue.valueID()) {
 918             case CSSValueWebkitBody:
 919                 family = styleResolver.settings().standardFontFamily();
 920                 break;
 921             case CSSValueSerif:
 922                 family = serifFamily;
 923                 isGenericFamily = true;
 924                 break;
 925             case CSSValueSansSerif:
 926                 family = sansSerifFamily;
 927                 isGenericFamily = true;
 928                 break;
 929             case CSSValueCursive:
</pre>
<hr />
<pre>
1118 inline void StyleBuilderCustom::applyValueCounter(StyleResolver&amp; styleResolver, CSSValue&amp; value)
1119 {
1120     bool setCounterIncrementToNone = counterBehavior == Increment &amp;&amp; is&lt;CSSPrimitiveValue&gt;(value) &amp;&amp; downcast&lt;CSSPrimitiveValue&gt;(value).valueID() == CSSValueNone;
1121 
1122     if (!is&lt;CSSValueList&gt;(value) &amp;&amp; !setCounterIncrementToNone)
1123         return;
1124 
1125     CounterDirectiveMap&amp; map = styleResolver.style()-&gt;accessCounterDirectives();
1126     for (auto&amp; keyValue : map) {
1127         if (counterBehavior == Reset)
1128             keyValue.value.resetValue = WTF::nullopt;
1129         else
1130             keyValue.value.incrementValue = WTF::nullopt;
1131     }
1132 
1133     if (setCounterIncrementToNone)
1134         return;
1135 
1136     for (auto&amp; item : downcast&lt;CSSValueList&gt;(value)) {
1137         Pair* pair = downcast&lt;CSSPrimitiveValue&gt;(item.get()).pairValue();
<span class="line-modified">1138         AtomString identifier = pair-&gt;first()-&gt;stringValue();</span>
1139         int value = pair-&gt;second()-&gt;intValue();
1140         auto&amp; directives = map.add(identifier, CounterDirectives { }).iterator-&gt;value;
1141         if (counterBehavior == Reset)
1142             directives.resetValue = value;
1143         else
1144             directives.incrementValue = saturatedAddition(directives.incrementValue.valueOr(0), value);
1145     }
1146 }
1147 
1148 inline void StyleBuilderCustom::applyInitialCounterIncrement(StyleResolver&amp;) { }
1149 
1150 inline void StyleBuilderCustom::applyInheritCounterIncrement(StyleResolver&amp; styleResolver)
1151 {
1152     applyInheritCounter&lt;Increment&gt;(styleResolver);
1153 }
1154 
1155 inline void StyleBuilderCustom::applyValueCounterIncrement(StyleResolver&amp; styleResolver, CSSValue&amp; value)
1156 {
1157     applyValueCounter&lt;Increment&gt;(styleResolver, value);
1158 }
</pre>
<hr />
<pre>
1331         if (is&lt;CSSImageValue&gt;(item)) {
1332             styleResolver.style()-&gt;setContent(StyleCachedImage::create(item), didSet);
1333             didSet = true;
1334             continue;
1335         }
1336 
1337         if (!is&lt;CSSPrimitiveValue&gt;(item))
1338             continue;
1339 
1340         auto&amp; contentValue = downcast&lt;CSSPrimitiveValue&gt;(item.get());
1341         if (contentValue.isString()) {
1342             styleResolver.style()-&gt;setContent(contentValue.stringValue().impl(), didSet);
1343             didSet = true;
1344         } else if (contentValue.isAttr()) {
1345             // FIXME: Can a namespace be specified for an attr(foo)?
1346             if (styleResolver.style()-&gt;styleType() == PseudoId::None)
1347                 styleResolver.style()-&gt;setHasAttrContent();
1348             else
1349                 const_cast&lt;RenderStyle*&gt;(styleResolver.parentStyle())-&gt;setHasAttrContent();
1350             QualifiedName attr(nullAtom(), contentValue.stringValue().impl(), nullAtom());
<span class="line-modified">1351             const AtomString&amp; value = styleResolver.element()-&gt;getAttribute(attr);</span>
1352             styleResolver.style()-&gt;setContent(value.isNull() ? emptyAtom() : value.impl(), didSet);
1353             didSet = true;
1354             // Register the fact that the attribute value affects the style.
1355             styleResolver.ruleSets().mutableFeatures().registerContentAttribute(attr.localName());
1356         } else if (contentValue.isCounter()) {
1357             auto* counterValue = contentValue.counterValue();
1358             ListStyleType listStyleType = ListStyleType::None;
1359             CSSValueID listStyleIdent = counterValue-&gt;listStyleIdent();
1360             if (listStyleIdent != CSSValueNone)
1361                 listStyleType = static_cast&lt;ListStyleType&gt;(listStyleIdent - CSSValueDisc);
<span class="line-modified">1362             auto counter = makeUnique&lt;CounterContent&gt;(counterValue-&gt;identifier(), listStyleType, counterValue-&gt;separator());</span>
1363             styleResolver.style()-&gt;setContent(WTFMove(counter), didSet);
1364             didSet = true;
1365         } else {
1366             switch (contentValue.valueID()) {
1367             case CSSValueOpenQuote:
1368                 styleResolver.style()-&gt;setContent(QuoteType::OpenQuote, didSet);
1369                 didSet = true;
1370                 break;
1371             case CSSValueCloseQuote:
1372                 styleResolver.style()-&gt;setContent(QuoteType::CloseQuote, didSet);
1373                 didSet = true;
1374                 break;
1375             case CSSValueNoOpenQuote:
1376                 styleResolver.style()-&gt;setContent(QuoteType::NoOpenQuote, didSet);
1377                 didSet = true;
1378                 break;
1379             case CSSValueNoCloseQuote:
1380                 styleResolver.style()-&gt;setContent(QuoteType::NoCloseQuote, didSet);
1381                 didSet = true;
1382                 break;
</pre>
<hr />
<pre>
1728     const NamedGridAreaMap&amp; namedGridAreas = styleResolver.style()-&gt;namedGridArea();
1729     if (!namedGridAreas.isEmpty())
1730         StyleBuilderConverter::createImplicitNamedGridLinesFromGridArea(namedGridAreas, tracksData.m_namedGridLines, ForRows);
1731 
1732     SET_TRACKS_DATA(tracksData, styleResolver.style(), Row);
1733 }
1734 
1735 void StyleBuilderCustom::applyValueAlt(StyleResolver&amp; styleResolver, CSSValue&amp; value)
1736 {
1737     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
1738     if (primitiveValue.isString())
1739         styleResolver.style()-&gt;setContentAltText(primitiveValue.stringValue());
1740     else if (primitiveValue.isAttr()) {
1741         // FIXME: Can a namespace be specified for an attr(foo)?
1742         if (styleResolver.style()-&gt;styleType() == PseudoId::None)
1743             styleResolver.style()-&gt;setUnique();
1744         else
1745             const_cast&lt;RenderStyle*&gt;(styleResolver.parentStyle())-&gt;setUnique();
1746 
1747         QualifiedName attr(nullAtom(), primitiveValue.stringValue(), nullAtom());
<span class="line-modified">1748         const AtomString&amp; value = styleResolver.element()-&gt;getAttribute(attr);</span>
1749         styleResolver.style()-&gt;setContentAltText(value.isNull() ? emptyAtom() : value);
1750 
1751         // Register the fact that the attribute value affects the style.
1752         styleResolver.ruleSets().mutableFeatures().registerContentAttribute(attr.localName());
1753     } else
1754         styleResolver.style()-&gt;setContentAltText(emptyAtom());
1755 }
1756 
1757 inline void StyleBuilderCustom::applyValueWillChange(StyleResolver&amp; styleResolver, CSSValue&amp; value)
1758 {
1759     if (is&lt;CSSPrimitiveValue&gt;(value)) {
1760         ASSERT(downcast&lt;CSSPrimitiveValue&gt;(value).valueID() == CSSValueAuto);
1761         styleResolver.style()-&gt;setWillChange(nullptr);
1762         return;
1763     }
1764 
1765     auto willChange = WillChangeData::create();
1766     for (auto&amp; item : downcast&lt;CSSValueList&gt;(value)) {
1767         if (!is&lt;CSSPrimitiveValue&gt;(item))
1768             continue;
</pre>
<hr />
<pre>
1782     }
1783     styleResolver.style()-&gt;setWillChange(WTFMove(willChange));
1784 }
1785 
1786 inline void StyleBuilderCustom::applyValueStrokeWidth(StyleResolver&amp; styleResolver, CSSValue&amp; value)
1787 {
1788     styleResolver.style()-&gt;setStrokeWidth(StyleBuilderConverter::convertLength(styleResolver, value));
1789     styleResolver.style()-&gt;setHasExplicitlySetStrokeWidth(true);
1790 }
1791 
1792 inline void StyleBuilderCustom::applyValueStrokeColor(StyleResolver&amp; styleResolver, CSSValue&amp; value)
1793 {
1794     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
1795     if (styleResolver.applyPropertyToRegularStyle())
1796         styleResolver.style()-&gt;setStrokeColor(styleResolver.colorFromPrimitiveValue(primitiveValue, /* forVisitedLink */ false));
1797     if (styleResolver.applyPropertyToVisitedLinkStyle())
1798         styleResolver.style()-&gt;setVisitedLinkStrokeColor(styleResolver.colorFromPrimitiveValue(primitiveValue, /* forVisitedLink */ true));
1799     styleResolver.style()-&gt;setHasExplicitlySetStrokeColor(true);
1800 }
1801 
<span class="line-modified">1802 inline void StyleBuilderCustom::applyInitialCustomProperty(StyleResolver&amp; styleResolver, const CSSRegisteredCustomProperty* registered, const AtomString&amp; name)</span>
1803 {
1804     if (registered &amp;&amp; registered-&gt;initialValue()) {
1805         auto initialValue = registered-&gt;initialValueCopy();
1806         applyValueCustomProperty(styleResolver, registered, *initialValue);
1807         return;
1808     }
1809 
1810     auto invalid = CSSCustomPropertyValue::createUnresolved(name, CSSValueInvalid);
1811     applyValueCustomProperty(styleResolver, registered, invalid.get());
1812 }
1813 
<span class="line-modified">1814 inline void StyleBuilderCustom::applyInheritCustomProperty(StyleResolver&amp; styleResolver, const CSSRegisteredCustomProperty* registered, const AtomString&amp; name)</span>
1815 {
1816     auto* parentValue = styleResolver.parentStyle() ? styleResolver.parentStyle()-&gt;inheritedCustomProperties().get(name) : nullptr;
1817     if (parentValue &amp;&amp; !(registered &amp;&amp; !registered-&gt;inherits))
1818         applyValueCustomProperty(styleResolver, registered, *parentValue);
1819     else
1820         applyInitialCustomProperty(styleResolver, registered, name);
1821 }
1822 
1823 inline void StyleBuilderCustom::applyValueCustomProperty(StyleResolver&amp; styleResolver, const CSSRegisteredCustomProperty* registered, CSSCustomPropertyValue&amp; value)
1824 {
1825     ASSERT(value.isResolved());
1826     const auto&amp; name = value.name();
1827 
1828     if (!registered || registered-&gt;inherits)
1829         styleResolver.style()-&gt;setInheritedCustomPropertyValue(name, makeRef(value));
1830     else
1831         styleResolver.style()-&gt;setNonInheritedCustomPropertyValue(name, makeRef(value));
1832 }
1833 
1834 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="StyleBuilderConverter.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="StyleColor.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>