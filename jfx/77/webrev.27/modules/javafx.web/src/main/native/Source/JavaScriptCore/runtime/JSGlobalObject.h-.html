<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSGlobalObject.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  *  Copyright (C) 2007 Eric Seidel &lt;eric@webkit.org&gt;
   3  *  Copyright (C) 2007-2019 Apple Inc. All rights reserved.
   4  *
   5  *  This library is free software; you can redistribute it and/or
   6  *  modify it under the terms of the GNU Library General Public
   7  *  License as published by the Free Software Foundation; either
   8  *  version 2 of the License, or (at your option) any later version.
   9  *
  10  *  This library is distributed in the hope that it will be useful,
  11  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  12  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  13  *  Library General Public License for more details.
  14  *
  15  *  You should have received a copy of the GNU Library General Public License
  16  *  along with this library; see the file COPYING.LIB.  If not, write to
  17  *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  18  *  Boston, MA 02110-1301, USA.
  19  *
  20  */
  21 
  22 #pragma once
  23 
  24 #include &quot;ArrayAllocationProfile.h&quot;
  25 #include &quot;ArrayBufferSharingMode.h&quot;
  26 #include &quot;BigIntPrototype.h&quot;
  27 #include &quot;BooleanPrototype.h&quot;
  28 #include &quot;ErrorType.h&quot;
  29 #include &quot;ExceptionHelpers.h&quot;
  30 #include &quot;InternalFunction.h&quot;
  31 #include &quot;JSArray.h&quot;
  32 #include &quot;JSArrayBufferPrototype.h&quot;
  33 #include &quot;JSClassRef.h&quot;
  34 #include &quot;JSGlobalLexicalEnvironment.h&quot;
  35 #include &quot;JSPromiseDeferred.h&quot;
  36 #include &quot;JSSegmentedVariableObject.h&quot;
  37 #include &quot;JSWeakObjectMapRefInternal.h&quot;
  38 #include &quot;LazyProperty.h&quot;
  39 #include &quot;LazyClassStructure.h&quot;
  40 #include &quot;NumberPrototype.h&quot;
  41 #include &quot;RegExpGlobalData.h&quot;
  42 #include &quot;RuntimeFlags.h&quot;
  43 #include &quot;SpecialPointer.h&quot;
  44 #include &quot;StringPrototype.h&quot;
  45 #include &quot;SymbolPrototype.h&quot;
  46 #include &quot;VM.h&quot;
  47 #include &quot;Watchpoint.h&quot;
  48 #include &lt;JavaScriptCore/JSBase.h&gt;
  49 #include &lt;array&gt;
  50 #include &lt;wtf/HashSet.h&gt;
  51 #include &lt;wtf/RetainPtr.h&gt;
  52 
  53 struct OpaqueJSClass;
  54 struct OpaqueJSClassContextData;
  55 OBJC_CLASS JSWrapperMap;
  56 
  57 namespace Inspector {
  58 class JSGlobalObjectInspectorController;
  59 }
  60 
  61 namespace JSC {
  62 class ArrayConstructor;
  63 class ArrayPrototype;
  64 class AsyncIteratorPrototype;
  65 class AsyncFunctionPrototype;
  66 class AsyncGeneratorPrototype;
  67 class AsyncGeneratorFunctionPrototype;
  68 class BooleanPrototype;
  69 class ConsoleClient;
  70 class Debugger;
  71 class ErrorConstructor;
  72 class ErrorPrototype;
  73 class EvalCodeBlock;
  74 class EvalExecutable;
  75 class FunctionConstructor;
  76 class FunctionPrototype;
  77 class GeneratorPrototype;
  78 class GeneratorFunctionPrototype;
  79 class GetterSetter;
  80 class GlobalCodeBlock;
  81 class IndirectEvalExecutable;
  82 class InputCursor;
  83 class IntlObject;
  84 class IntlCollator;
  85 class JSArrayBuffer;
  86 class JSArrayBufferPrototype;
  87 class JSCallee;
  88 class JSGlobalObjectDebuggable;
  89 class JSInternalPromise;
  90 class JSModuleLoader;
  91 class JSModuleRecord;
  92 class JSPromise;
  93 class JSPromiseConstructor;
  94 class JSPromisePrototype;
  95 class JSSharedArrayBuffer;
  96 class JSSharedArrayBufferPrototype;
  97 class JSTypedArrayViewConstructor;
  98 class JSTypedArrayViewPrototype;
  99 class DirectEvalExecutable;
 100 class LLIntOffsetsExtractor;
 101 class MapPrototype;
 102 class Microtask;
 103 class ModuleLoader;
 104 class ModuleProgramExecutable;
 105 class NativeErrorConstructorBase;
 106 class NullGetterFunction;
 107 class NullSetterFunction;
 108 class ObjectConstructor;
 109 class ProgramCodeBlock;
 110 class ProgramExecutable;
 111 class RegExpConstructor;
 112 class RegExpPrototype;
 113 class SetPrototype;
 114 class SourceCode;
 115 class SourceOrigin;
 116 class UnlinkedModuleProgramCodeBlock;
 117 class VariableEnvironment;
 118 struct ActivationStackNode;
 119 struct HashTable;
 120 
 121 #ifdef JSC_GLIB_API_ENABLED
 122 class WrapperMap;
 123 #endif
 124 
 125 template&lt;typename Watchpoint&gt; class ObjectPropertyChangeAdaptiveWatchpoint;
 126 
 127 #define DEFINE_STANDARD_BUILTIN(macro, upperName, lowerName) macro(upperName, lowerName, lowerName, JS ## upperName, upperName, object)
 128 
 129 #define FOR_EACH_SIMPLE_BUILTIN_TYPE_WITH_CONSTRUCTOR(macro) \
 130     macro(String, string, stringObject, StringObject, String, object) \
 131     macro(Error, error, error, ErrorInstance, Error, object) \
 132     macro(Map, map, map, JSMap, Map, object) \
 133     macro(Set, set, set, JSSet, Set, object) \
 134     macro(JSPromise, promise, promise, JSPromise, Promise, object)
 135 
 136 #define FOR_BIG_INT_BUILTIN_TYPE_WITH_CONSTRUCTOR(macro) \
 137     macro(BigInt, bigInt, bigIntObject, BigIntObject, BigInt, object)
 138 
 139 #define FOR_EACH_BUILTIN_DERIVED_ITERATOR_TYPE(macro) \
 140     macro(StringIterator, stringIterator, stringIterator, JSStringIterator, StringIterator, iterator) \
 141 
 142 #define FOR_EACH_SIMPLE_BUILTIN_TYPE(macro) \
 143     FOR_EACH_SIMPLE_BUILTIN_TYPE_WITH_CONSTRUCTOR(macro) \
 144     macro(JSInternalPromise, internalPromise, internalPromise, JSInternalPromise, InternalPromise, object) \
 145 
 146 #define FOR_EACH_LAZY_BUILTIN_TYPE(macro) \
 147     macro(Boolean, boolean, booleanObject, BooleanObject, Boolean, object) \
 148     macro(Date, date, date, DateInstance, Date, object) \
 149     macro(Number, number, numberObject, NumberObject, Number, object) \
 150     macro(Symbol, symbol, symbolObject, SymbolObject, Symbol, object) \
 151     DEFINE_STANDARD_BUILTIN(macro, WeakMap, weakMap) \
 152     DEFINE_STANDARD_BUILTIN(macro, WeakSet, weakSet) \
 153 
 154 #if ENABLE(WEBASSEMBLY)
 155 #define FOR_EACH_WEBASSEMBLY_CONSTRUCTOR_TYPE(macro) \
 156     macro(WebAssemblyCompileError, webAssemblyCompileError, WebAssemblyCompileError, WebAssemblyCompileError, CompileError, error) \
 157     macro(WebAssemblyInstance,     webAssemblyInstance,     WebAssemblyInstance,     WebAssemblyInstance,     Instance,     object) \
 158     macro(WebAssemblyLinkError,    webAssemblyLinkError,    WebAssemblyLinkError,    WebAssemblyLinkError,    LinkError,    error) \
 159     macro(WebAssemblyMemory,       webAssemblyMemory,       WebAssemblyMemory,       WebAssemblyMemory,       Memory,       object) \
 160     macro(WebAssemblyModule,       webAssemblyModule,       WebAssemblyModule,       WebAssemblyModule,       Module,       object) \
 161     macro(WebAssemblyRuntimeError, webAssemblyRuntimeError, WebAssemblyRuntimeError, WebAssemblyRuntimeError, RuntimeError, error) \
 162     macro(WebAssemblyTable,        webAssemblyTable,        WebAssemblyTable,        WebAssemblyTable,        Table,        object)
 163 #else
 164 #define FOR_EACH_WEBASSEMBLY_CONSTRUCTOR_TYPE(macro)
 165 #endif // ENABLE(WEBASSEMBLY)
 166 
 167 #define DECLARE_SIMPLE_BUILTIN_TYPE(capitalName, lowerName, properName, instanceType, jsName, prototypeBase) \
 168     class JS ## capitalName; \
 169     class capitalName ## Prototype; \
 170     class capitalName ## Constructor;
 171 
 172 class IteratorPrototype;
 173 FOR_EACH_SIMPLE_BUILTIN_TYPE(DECLARE_SIMPLE_BUILTIN_TYPE)
 174 FOR_BIG_INT_BUILTIN_TYPE_WITH_CONSTRUCTOR(DECLARE_SIMPLE_BUILTIN_TYPE)
 175 FOR_EACH_LAZY_BUILTIN_TYPE(DECLARE_SIMPLE_BUILTIN_TYPE)
 176 FOR_EACH_BUILTIN_DERIVED_ITERATOR_TYPE(DECLARE_SIMPLE_BUILTIN_TYPE)
 177 FOR_EACH_WEBASSEMBLY_CONSTRUCTOR_TYPE(DECLARE_SIMPLE_BUILTIN_TYPE)
 178 
 179 #undef DECLARE_SIMPLE_BUILTIN_TYPE
 180 
 181 enum class JSPromiseRejectionOperation : unsigned {
 182     Reject, // When a promise is rejected without any handlers.
 183     Handle, // When a handler is added to a rejected promise for the first time.
 184 };
 185 
 186 struct GlobalObjectMethodTable {
 187     typedef bool (*SupportsRichSourceInfoFunctionPtr)(const JSGlobalObject*);
 188     SupportsRichSourceInfoFunctionPtr supportsRichSourceInfo;
 189 
 190     typedef bool (*ShouldInterruptScriptFunctionPtr)(const JSGlobalObject*);
 191     ShouldInterruptScriptFunctionPtr shouldInterruptScript;
 192 
 193     typedef RuntimeFlags (*JavaScriptRuntimeFlagsFunctionPtr)(const JSGlobalObject*);
 194     JavaScriptRuntimeFlagsFunctionPtr javaScriptRuntimeFlags;
 195 
 196     typedef void (*QueueTaskToEventLoopFunctionPtr)(JSGlobalObject&amp;, Ref&lt;Microtask&gt;&amp;&amp;);
 197     QueueTaskToEventLoopFunctionPtr queueTaskToEventLoop;
 198 
 199     typedef bool (*ShouldInterruptScriptBeforeTimeoutPtr)(const JSGlobalObject*);
 200     ShouldInterruptScriptBeforeTimeoutPtr shouldInterruptScriptBeforeTimeout;
 201 
 202     typedef JSInternalPromise* (*ModuleLoaderImportModulePtr)(JSGlobalObject*, ExecState*, JSModuleLoader*, JSString*, JSValue, const SourceOrigin&amp;);
 203     ModuleLoaderImportModulePtr moduleLoaderImportModule;
 204 
 205     typedef Identifier (*ModuleLoaderResolvePtr)(JSGlobalObject*, ExecState*, JSModuleLoader*, JSValue, JSValue, JSValue);
 206     ModuleLoaderResolvePtr moduleLoaderResolve;
 207 
 208     typedef JSInternalPromise* (*ModuleLoaderFetchPtr)(JSGlobalObject*, ExecState*, JSModuleLoader*, JSValue, JSValue, JSValue);
 209     ModuleLoaderFetchPtr moduleLoaderFetch;
 210 
 211     typedef JSObject* (*ModuleLoaderCreateImportMetaPropertiesPtr)(JSGlobalObject*, ExecState*, JSModuleLoader*, JSValue, JSModuleRecord*, JSValue);
 212     ModuleLoaderCreateImportMetaPropertiesPtr moduleLoaderCreateImportMetaProperties;
 213 
 214     typedef JSValue (*ModuleLoaderEvaluatePtr)(JSGlobalObject*, ExecState*, JSModuleLoader*, JSValue, JSValue, JSValue);
 215     ModuleLoaderEvaluatePtr moduleLoaderEvaluate;
 216 
 217     typedef void (*PromiseRejectionTrackerPtr)(JSGlobalObject*, ExecState*, JSPromise*, JSPromiseRejectionOperation);
 218     PromiseRejectionTrackerPtr promiseRejectionTracker;
 219 
 220     typedef String (*DefaultLanguageFunctionPtr)();
 221     DefaultLanguageFunctionPtr defaultLanguage;
 222 
 223     typedef void (*CompileStreamingPtr)(JSGlobalObject*, ExecState*, JSPromiseDeferred*, JSValue);
 224     CompileStreamingPtr compileStreaming;
 225 
 226     typedef void (*InstantiateStreamingPtr)(JSGlobalObject*, ExecState*, JSPromiseDeferred*, JSValue, JSObject*);
 227     InstantiateStreamingPtr instantiateStreaming;
 228 };
 229 
 230 class JSGlobalObject : public JSSegmentedVariableObject {
 231 private:
 232     typedef HashSet&lt;RefPtr&lt;OpaqueJSWeakObjectMap&gt;&gt; WeakMapSet;
 233     typedef HashMap&lt;OpaqueJSClass*, std::unique_ptr&lt;OpaqueJSClassContextData&gt;&gt; OpaqueJSClassDataMap;
 234 
 235     struct JSGlobalObjectRareData {
 236         WTF_MAKE_FAST_ALLOCATED;
 237     public:
 238         JSGlobalObjectRareData()
 239             : profileGroup(0)
 240         {
 241         }
 242 
 243         WeakMapSet weakMaps;
 244         unsigned profileGroup;
 245 
 246         OpaqueJSClassDataMap opaqueJSClassData;
 247     };
 248 
 249 // Our hashtable code-generator tries to access these properties, so we make them public.
 250 // However, we&#39;d like it better if they could be protected.
 251 public:
 252     template&lt;typename T&gt; using Initializer = typename LazyProperty&lt;JSGlobalObject, T&gt;::Initializer;
 253 
 254     Register m_globalCallFrame[CallFrame::headerSizeInRegisters];
 255 
 256     WriteBarrier&lt;JSObject&gt; m_globalThis;
 257 
 258     WriteBarrier&lt;JSGlobalLexicalEnvironment&gt; m_globalLexicalEnvironment;
 259     WriteBarrier&lt;JSScope&gt; m_globalScopeExtension;
 260     WriteBarrier&lt;JSCallee&gt; m_globalCallee;
 261     WriteBarrier&lt;JSCallee&gt; m_stackOverflowFrameCallee;
 262 
 263     WriteBarrier&lt;ErrorConstructor&gt; m_errorConstructor;
 264     LazyClassStructure m_evalErrorStructure;
 265     LazyClassStructure m_rangeErrorStructure;
 266     LazyClassStructure m_referenceErrorStructure;
 267     LazyClassStructure m_syntaxErrorStructure;
 268     LazyClassStructure m_typeErrorStructure;
 269     LazyClassStructure m_URIErrorStructure;
 270 
 271     WriteBarrier&lt;ObjectConstructor&gt; m_objectConstructor;
 272     WriteBarrier&lt;ArrayConstructor&gt; m_arrayConstructor;
 273     WriteBarrier&lt;JSPromiseConstructor&gt; m_promiseConstructor;
 274     WriteBarrier&lt;JSInternalPromiseConstructor&gt; m_internalPromiseConstructor;
 275 
 276 #if ENABLE(INTL)
 277     WriteBarrier&lt;IntlObject&gt; m_intlObject;
 278     WriteBarrier&lt;IntlCollator&gt; m_defaultCollator;
 279     LazyProperty&lt;JSGlobalObject, Structure&gt; m_collatorStructure;
 280     LazyProperty&lt;JSGlobalObject, Structure&gt; m_numberFormatStructure;
 281     LazyProperty&lt;JSGlobalObject, Structure&gt; m_dateTimeFormatStructure;
 282     LazyProperty&lt;JSGlobalObject, Structure&gt; m_pluralRulesStructure;
 283 #endif
 284     WriteBarrier&lt;NullGetterFunction&gt; m_nullGetterFunction;
 285     WriteBarrier&lt;NullSetterFunction&gt; m_nullSetterFunction;
 286 
 287     WriteBarrier&lt;JSFunction&gt; m_parseIntFunction;
 288     WriteBarrier&lt;JSFunction&gt; m_parseFloatFunction;
 289 
 290     WriteBarrier&lt;JSFunction&gt; m_evalFunction;
 291     WriteBarrier&lt;JSFunction&gt; m_callFunction;
 292     WriteBarrier&lt;JSFunction&gt; m_applyFunction;
 293     WriteBarrier&lt;JSFunction&gt; m_throwTypeErrorFunction;
 294     LazyProperty&lt;JSGlobalObject, JSFunction&gt; m_arrayProtoToStringFunction;
 295     LazyProperty&lt;JSGlobalObject, JSFunction&gt; m_arrayProtoValuesFunction;
 296     LazyProperty&lt;JSGlobalObject, JSFunction&gt; m_initializePromiseFunction;
 297     LazyProperty&lt;JSGlobalObject, JSFunction&gt; m_iteratorProtocolFunction;
 298     LazyProperty&lt;JSGlobalObject, JSFunction&gt; m_promiseResolveFunction;
 299     WriteBarrier&lt;JSFunction&gt; m_objectProtoValueOfFunction;
 300     WriteBarrier&lt;JSFunction&gt; m_numberProtoToStringFunction;
 301     WriteBarrier&lt;JSFunction&gt; m_newPromiseCapabilityFunction;
 302     WriteBarrier&lt;JSFunction&gt; m_functionProtoHasInstanceSymbolFunction;
 303     LazyProperty&lt;JSGlobalObject, GetterSetter&gt; m_throwTypeErrorGetterSetter;
 304     WriteBarrier&lt;JSObject&gt; m_regExpProtoExec;
 305     WriteBarrier&lt;JSObject&gt; m_regExpProtoSymbolReplace;
 306     WriteBarrier&lt;JSObject&gt; m_regExpProtoGlobalGetter;
 307     WriteBarrier&lt;JSObject&gt; m_regExpProtoUnicodeGetter;
 308     WriteBarrier&lt;GetterSetter&gt; m_throwTypeErrorArgumentsCalleeAndCallerGetterSetter;
 309 
 310     LazyProperty&lt;JSGlobalObject, JSModuleLoader&gt; m_moduleLoader;
 311 
 312     WriteBarrier&lt;ObjectPrototype&gt; m_objectPrototype;
 313     WriteBarrier&lt;FunctionPrototype&gt; m_functionPrototype;
 314     WriteBarrier&lt;ArrayPrototype&gt; m_arrayPrototype;
 315     WriteBarrier&lt;RegExpPrototype&gt; m_regExpPrototype;
 316     WriteBarrier&lt;IteratorPrototype&gt; m_iteratorPrototype;
 317     WriteBarrier&lt;AsyncIteratorPrototype&gt; m_asyncIteratorPrototype;
 318     WriteBarrier&lt;GeneratorFunctionPrototype&gt; m_generatorFunctionPrototype;
 319     WriteBarrier&lt;GeneratorPrototype&gt; m_generatorPrototype;
 320     WriteBarrier&lt;AsyncGeneratorPrototype&gt; m_asyncGeneratorPrototype;
 321 
 322     LazyProperty&lt;JSGlobalObject, Structure&gt; m_debuggerScopeStructure;
 323     LazyProperty&lt;JSGlobalObject, Structure&gt; m_withScopeStructure;
 324     WriteBarrier&lt;Structure&gt; m_strictEvalActivationStructure;
 325     WriteBarrier&lt;Structure&gt; m_lexicalEnvironmentStructure;
 326     LazyProperty&lt;JSGlobalObject, Structure&gt; m_moduleEnvironmentStructure;
 327     WriteBarrier&lt;Structure&gt; m_directArgumentsStructure;
 328     WriteBarrier&lt;Structure&gt; m_scopedArgumentsStructure;
 329     WriteBarrier&lt;Structure&gt; m_clonedArgumentsStructure;
 330 
 331     WriteBarrier&lt;Structure&gt; m_objectStructureForObjectConstructor;
 332 
 333     // Lists the actual structures used for having these particular indexing shapes.
 334     WriteBarrier&lt;Structure&gt; m_originalArrayStructureForIndexingShape[NumberOfArrayIndexingModes];
 335     // Lists the structures we should use during allocation for these particular indexing shapes.
 336     // These structures will differ from the originals list above when we are having a bad time.
 337     WriteBarrier&lt;Structure&gt; m_arrayStructureForIndexingShapeDuringAllocation[NumberOfArrayIndexingModes];
 338 
 339     LazyProperty&lt;JSGlobalObject, Structure&gt; m_callbackConstructorStructure;
 340     LazyProperty&lt;JSGlobalObject, Structure&gt; m_callbackFunctionStructure;
 341     LazyProperty&lt;JSGlobalObject, Structure&gt; m_callbackObjectStructure;
 342 #if JSC_OBJC_API_ENABLED
 343     LazyProperty&lt;JSGlobalObject, Structure&gt; m_objcCallbackFunctionStructure;
 344     LazyProperty&lt;JSGlobalObject, Structure&gt; m_objcWrapperObjectStructure;
 345 #endif
 346 #ifdef JSC_GLIB_API_ENABLED
 347     LazyProperty&lt;JSGlobalObject, Structure&gt; m_glibCallbackFunctionStructure;
 348     LazyProperty&lt;JSGlobalObject, Structure&gt; m_glibWrapperObjectStructure;
 349 #endif
 350     WriteBarrier&lt;Structure&gt; m_nullPrototypeObjectStructure;
 351     WriteBarrier&lt;Structure&gt; m_calleeStructure;
 352 
 353     WriteBarrier&lt;Structure&gt; m_hostFunctionStructure;
 354 
 355     struct FunctionStructures {
 356         WriteBarrier&lt;Structure&gt; arrowFunctionStructure;
 357         WriteBarrier&lt;Structure&gt; sloppyFunctionStructure;
 358         WriteBarrier&lt;Structure&gt; strictFunctionStructure;
 359     };
 360     FunctionStructures m_builtinFunctions;
 361     FunctionStructures m_ordinaryFunctions;
 362 
 363     LazyProperty&lt;JSGlobalObject, Structure&gt; m_boundFunctionStructure;
 364     LazyProperty&lt;JSGlobalObject, Structure&gt; m_customGetterSetterFunctionStructure;
 365     WriteBarrier&lt;Structure&gt; m_getterSetterStructure;
 366     LazyProperty&lt;JSGlobalObject, Structure&gt; m_nativeStdFunctionStructure;
 367     PropertyOffset m_functionNameOffset;
 368     WriteBarrier&lt;Structure&gt; m_regExpStructure;
 369     WriteBarrier&lt;AsyncFunctionPrototype&gt; m_asyncFunctionPrototype;
 370     WriteBarrier&lt;AsyncGeneratorFunctionPrototype&gt; m_asyncGeneratorFunctionPrototype;
 371     WriteBarrier&lt;Structure&gt; m_asyncFunctionStructure;
 372     WriteBarrier&lt;Structure&gt; m_asyncGeneratorFunctionStructure;
 373     WriteBarrier&lt;Structure&gt; m_generatorFunctionStructure;
 374     WriteBarrier&lt;Structure&gt; m_iteratorResultObjectStructure;
 375     WriteBarrier&lt;Structure&gt; m_regExpMatchesArrayStructure;
 376     WriteBarrier&lt;Structure&gt; m_regExpMatchesArrayWithGroupsStructure;
 377     WriteBarrier&lt;Structure&gt; m_moduleRecordStructure;
 378     WriteBarrier&lt;Structure&gt; m_moduleNamespaceObjectStructure;
 379     WriteBarrier&lt;Structure&gt; m_proxyObjectStructure;
 380     WriteBarrier&lt;Structure&gt; m_callableProxyObjectStructure;
 381     WriteBarrier&lt;Structure&gt; m_proxyRevokeStructure;
 382     WriteBarrier&lt;JSArrayBufferPrototype&gt; m_arrayBufferPrototype;
 383     WriteBarrier&lt;Structure&gt; m_arrayBufferStructure;
 384 #if ENABLE(SHARED_ARRAY_BUFFER)
 385     WriteBarrier&lt;JSArrayBufferPrototype&gt; m_sharedArrayBufferPrototype;
 386     WriteBarrier&lt;Structure&gt; m_sharedArrayBufferStructure;
 387 #endif
 388 
 389 #define DEFINE_STORAGE_FOR_SIMPLE_TYPE(capitalName, lowerName, properName, instanceType, jsName, prototypeBase) \
 390     WriteBarrier&lt;capitalName ## Prototype&gt; m_ ## lowerName ## Prototype; \
 391     WriteBarrier&lt;Structure&gt; m_ ## properName ## Structure;
 392 
 393     FOR_EACH_SIMPLE_BUILTIN_TYPE(DEFINE_STORAGE_FOR_SIMPLE_TYPE)
 394     FOR_BIG_INT_BUILTIN_TYPE_WITH_CONSTRUCTOR(DEFINE_STORAGE_FOR_SIMPLE_TYPE)
 395     FOR_EACH_BUILTIN_DERIVED_ITERATOR_TYPE(DEFINE_STORAGE_FOR_SIMPLE_TYPE)
 396 
 397 #if ENABLE(WEBASSEMBLY)
 398     WriteBarrier&lt;Structure&gt; m_webAssemblyStructure;
 399     WriteBarrier&lt;Structure&gt; m_webAssemblyModuleRecordStructure;
 400     WriteBarrier&lt;Structure&gt; m_webAssemblyFunctionStructure;
 401     WriteBarrier&lt;Structure&gt; m_webAssemblyWrapperFunctionStructure;
 402     WriteBarrier&lt;Structure&gt; m_webAssemblyToJSCalleeStructure;
 403     FOR_EACH_WEBASSEMBLY_CONSTRUCTOR_TYPE(DEFINE_STORAGE_FOR_SIMPLE_TYPE)
 404 #endif // ENABLE(WEBASSEMBLY)
 405 
 406 #undef DEFINE_STORAGE_FOR_SIMPLE_TYPE
 407 
 408 #define DEFINE_STORAGE_FOR_LAZY_TYPE(capitalName, lowerName, properName, instanceType, jsName, prototypeBase) \
 409     LazyClassStructure m_ ## properName ## Structure;
 410     FOR_EACH_LAZY_BUILTIN_TYPE(DEFINE_STORAGE_FOR_LAZY_TYPE)
 411 #undef DEFINE_STORAGE_FOR_LAZY_TYPE
 412 
 413     WriteBarrier&lt;GetterSetter&gt; m_speciesGetterSetter;
 414 
 415     LazyProperty&lt;JSGlobalObject, JSTypedArrayViewPrototype&gt; m_typedArrayProto;
 416     LazyProperty&lt;JSGlobalObject, JSTypedArrayViewConstructor&gt; m_typedArraySuperConstructor;
 417 
 418 #define DECLARE_TYPED_ARRAY_TYPE_STRUCTURE(name) LazyClassStructure m_typedArray ## name;
 419     FOR_EACH_TYPED_ARRAY_TYPE(DECLARE_TYPED_ARRAY_TYPE_STRUCTURE)
 420 #undef DECLARE_TYPED_ARRAY_TYPE_STRUCTURE
 421 
 422     JSCell* m_specialPointers[Special::TableSize]; // Special pointers used by the LLInt and JIT.
 423     JSCell* m_linkTimeConstants[LinkTimeConstantCount];
 424 
 425     String m_name;
 426 
 427     Debugger* m_debugger;
 428 
 429     VM&amp; m_vm;
 430 
 431 #if ENABLE(REMOTE_INSPECTOR)
 432     std::unique_ptr&lt;Inspector::JSGlobalObjectInspectorController&gt; m_inspectorController;
 433     std::unique_ptr&lt;JSGlobalObjectDebuggable&gt; m_inspectorDebuggable;
 434 #endif
 435 
 436 #if ENABLE(INTL)
 437     HashSet&lt;String&gt; m_intlCollatorAvailableLocales;
 438     HashSet&lt;String&gt; m_intlDateTimeFormatAvailableLocales;
 439     HashSet&lt;String&gt; m_intlNumberFormatAvailableLocales;
 440     HashSet&lt;String&gt; m_intlPluralRulesAvailableLocales;
 441 #endif // ENABLE(INTL)
 442 
 443     RefPtr&lt;WatchpointSet&gt; m_masqueradesAsUndefinedWatchpoint;
 444     RefPtr&lt;WatchpointSet&gt; m_havingABadTimeWatchpoint;
 445     RefPtr&lt;WatchpointSet&gt; m_varInjectionWatchpoint;
 446 
 447     std::unique_ptr&lt;JSGlobalObjectRareData&gt; m_rareData;
 448 
 449     WeakRandom m_weakRandom;
 450     RegExpGlobalData m_regExpGlobalData;
 451 
 452     JSCallee* stackOverflowFrameCallee() const { return m_stackOverflowFrameCallee.get(); }
 453 
 454     InlineWatchpointSet&amp; arrayIteratorProtocolWatchpoint() { return m_arrayIteratorProtocolWatchpoint; }
 455     InlineWatchpointSet&amp; mapIteratorProtocolWatchpoint() { return m_mapIteratorProtocolWatchpoint; }
 456     InlineWatchpointSet&amp; setIteratorProtocolWatchpoint() { return m_setIteratorProtocolWatchpoint; }
 457     InlineWatchpointSet&amp; stringIteratorProtocolWatchpoint() { return m_stringIteratorProtocolWatchpoint; }
 458     InlineWatchpointSet&amp; mapSetWatchpoint() { return m_mapSetWatchpoint; }
 459     InlineWatchpointSet&amp; setAddWatchpoint() { return m_setAddWatchpoint; }
 460     InlineWatchpointSet&amp; arraySpeciesWatchpoint() { return m_arraySpeciesWatchpoint; }
 461     InlineWatchpointSet&amp; numberToStringWatchpoint()
 462     {
 463         RELEASE_ASSERT(VM::canUseJIT());
 464         return m_numberToStringWatchpoint;
 465     }
 466     // If this hasn&#39;t been invalidated, it means the array iterator protocol
 467     // is not observable to user code yet.
 468     InlineWatchpointSet m_arrayIteratorProtocolWatchpoint;
 469     InlineWatchpointSet m_mapIteratorProtocolWatchpoint;
 470     InlineWatchpointSet m_setIteratorProtocolWatchpoint;
 471     InlineWatchpointSet m_stringIteratorProtocolWatchpoint;
 472     InlineWatchpointSet m_mapSetWatchpoint;
 473     InlineWatchpointSet m_setAddWatchpoint;
 474     InlineWatchpointSet m_arraySpeciesWatchpoint;
 475     InlineWatchpointSet m_numberToStringWatchpoint;
 476     std::unique_ptr&lt;ObjectPropertyChangeAdaptiveWatchpoint&lt;InlineWatchpointSet&gt;&gt; m_arrayPrototypeSymbolIteratorWatchpoint;
 477     std::unique_ptr&lt;ObjectPropertyChangeAdaptiveWatchpoint&lt;InlineWatchpointSet&gt;&gt; m_arrayIteratorPrototypeNext;
 478     std::unique_ptr&lt;ObjectPropertyChangeAdaptiveWatchpoint&lt;InlineWatchpointSet&gt;&gt; m_mapPrototypeSymbolIteratorWatchpoint;
 479     std::unique_ptr&lt;ObjectPropertyChangeAdaptiveWatchpoint&lt;InlineWatchpointSet&gt;&gt; m_mapIteratorPrototypeNextWatchpoint;
 480     std::unique_ptr&lt;ObjectPropertyChangeAdaptiveWatchpoint&lt;InlineWatchpointSet&gt;&gt; m_setPrototypeSymbolIteratorWatchpoint;
 481     std::unique_ptr&lt;ObjectPropertyChangeAdaptiveWatchpoint&lt;InlineWatchpointSet&gt;&gt; m_setIteratorPrototypeNextWatchpoint;
 482     std::unique_ptr&lt;ObjectPropertyChangeAdaptiveWatchpoint&lt;InlineWatchpointSet&gt;&gt; m_stringPrototypeSymbolIteratorWatchpoint;
 483     std::unique_ptr&lt;ObjectPropertyChangeAdaptiveWatchpoint&lt;InlineWatchpointSet&gt;&gt; m_stringIteratorPrototypeNextWatchpoint;
 484     std::unique_ptr&lt;ObjectPropertyChangeAdaptiveWatchpoint&lt;InlineWatchpointSet&gt;&gt; m_mapPrototypeSetWatchpoint;
 485     std::unique_ptr&lt;ObjectPropertyChangeAdaptiveWatchpoint&lt;InlineWatchpointSet&gt;&gt; m_setPrototypeAddWatchpoint;
 486     std::unique_ptr&lt;ObjectPropertyChangeAdaptiveWatchpoint&lt;InlineWatchpointSet&gt;&gt; m_numberPrototypeToStringWatchpoint;
 487 
 488     bool isArrayPrototypeIteratorProtocolFastAndNonObservable();
 489     bool isMapPrototypeIteratorProtocolFastAndNonObservable();
 490     bool isSetPrototypeIteratorProtocolFastAndNonObservable();
 491     bool isStringPrototypeIteratorProtocolFastAndNonObservable();
 492     bool isMapPrototypeSetFastAndNonObservable();
 493     bool isSetPrototypeAddFastAndNonObservable();
 494 
 495 #if ENABLE(DFG_JIT)
 496     using ReferencedGlobalPropertyWatchpointSets = HashMap&lt;RefPtr&lt;UniquedStringImpl&gt;, Ref&lt;WatchpointSet&gt;, IdentifierRepHash&gt;;
 497     ReferencedGlobalPropertyWatchpointSets m_referencedGlobalPropertyWatchpointSets;
 498     ConcurrentJSLock m_referencedGlobalPropertyWatchpointSetsLock;
 499 #endif
 500 
 501     bool m_evalEnabled { true };
 502     bool m_webAssemblyEnabled { true };
 503     unsigned m_globalLexicalBindingEpoch { 1 };
 504     String m_evalDisabledErrorMessage;
 505     String m_webAssemblyDisabledErrorMessage;
 506     RuntimeFlags m_runtimeFlags;
 507     ConsoleClient* m_consoleClient { nullptr };
 508     Optional&lt;unsigned&gt; m_stackTraceLimit;
 509 
 510 #if !ASSERT_DISABLED
 511     const ExecState* m_callFrameAtDebuggerEntry { nullptr };
 512 #endif
 513 
 514     static JS_EXPORT_PRIVATE const GlobalObjectMethodTable s_globalObjectMethodTable;
 515     const GlobalObjectMethodTable* m_globalObjectMethodTable;
 516 
 517     void createRareDataIfNeeded()
 518     {
 519         if (m_rareData)
 520             return;
 521         m_rareData = std::make_unique&lt;JSGlobalObjectRareData&gt;();
 522     }
 523 
 524 public:
 525     typedef JSSegmentedVariableObject Base;
 526     static const unsigned StructureFlags = Base::StructureFlags | HasStaticPropertyTable | OverridesGetOwnPropertySlot | OverridesGetPropertyNames | IsImmutablePrototypeExoticObject;
 527 
 528     JS_EXPORT_PRIVATE static JSGlobalObject* create(VM&amp;, Structure*);
 529 
 530     DECLARE_EXPORT_INFO;
 531 
 532     bool hasDebugger() const;
 533     bool hasInteractiveDebugger() const;
 534     const RuntimeFlags&amp; runtimeFlags() const { return m_runtimeFlags; }
 535 
 536 #if ENABLE(DFG_JIT)
 537     WatchpointSet* getReferencedPropertyWatchpointSet(UniquedStringImpl*);
 538     WatchpointSet&amp; ensureReferencedPropertyWatchpointSet(UniquedStringImpl*);
 539 #endif
 540 
 541     Optional&lt;unsigned&gt; stackTraceLimit() const { return m_stackTraceLimit; }
 542     void setStackTraceLimit(Optional&lt;unsigned&gt; value) { m_stackTraceLimit = value; }
 543 
 544 protected:
 545     JS_EXPORT_PRIVATE explicit JSGlobalObject(VM&amp;, Structure*, const GlobalObjectMethodTable* = nullptr);
 546 
 547     JS_EXPORT_PRIVATE void finishCreation(VM&amp;);
 548 
 549     JS_EXPORT_PRIVATE void finishCreation(VM&amp;, JSObject*);
 550 
 551     void addGlobalVar(const Identifier&amp;);
 552 
 553 public:
 554     JS_EXPORT_PRIVATE ~JSGlobalObject();
 555     JS_EXPORT_PRIVATE static void destroy(JSCell*);
 556 
 557     JS_EXPORT_PRIVATE static void visitChildren(JSCell*, SlotVisitor&amp;);
 558 
 559     JS_EXPORT_PRIVATE static bool getOwnPropertySlot(JSObject*, ExecState*, PropertyName, PropertySlot&amp;);
 560     JS_EXPORT_PRIVATE static bool put(JSCell*, ExecState*, PropertyName, JSValue, PutPropertySlot&amp;);
 561 
 562     JS_EXPORT_PRIVATE static void defineGetter(JSObject*, ExecState*, PropertyName, JSObject* getterFunc, unsigned attributes);
 563     JS_EXPORT_PRIVATE static void defineSetter(JSObject*, ExecState*, PropertyName, JSObject* setterFunc, unsigned attributes);
 564     JS_EXPORT_PRIVATE static bool defineOwnProperty(JSObject*, ExecState*, PropertyName, const PropertyDescriptor&amp;, bool shouldThrow);
 565 
 566     void addVar(ExecState* exec, const Identifier&amp; propertyName)
 567     {
 568         if (!hasOwnProperty(exec, propertyName))
 569             addGlobalVar(propertyName);
 570     }
 571     void addFunction(ExecState*, const Identifier&amp;);
 572 
 573     JSScope* globalScope() { return m_globalLexicalEnvironment.get(); }
 574     JSGlobalLexicalEnvironment* globalLexicalEnvironment() { return m_globalLexicalEnvironment.get(); }
 575 
 576     JSScope* globalScopeExtension() { return m_globalScopeExtension.get(); }
 577     void setGlobalScopeExtension(JSScope*);
 578     void clearGlobalScopeExtension();
 579 
 580     // The following accessors return pristine values, even if a script
 581     // replaces the global object&#39;s associated property.
 582 
 583     GetterSetter* speciesGetterSetter() const { return m_speciesGetterSetter.get(); }
 584 
 585     ArrayConstructor* arrayConstructor() const { return m_arrayConstructor.get(); }
 586     ObjectConstructor* objectConstructor() const { return m_objectConstructor.get(); }
 587     JSPromiseConstructor* promiseConstructor() const { return m_promiseConstructor.get(); }
 588     JSInternalPromiseConstructor* internalPromiseConstructor() const { return m_internalPromiseConstructor.get(); }
 589 
 590 #if ENABLE(INTL)
 591     IntlCollator* defaultCollator(ExecState*);
 592 #endif
 593 
 594     NullGetterFunction* nullGetterFunction() const { return m_nullGetterFunction.get(); }
 595     NullSetterFunction* nullSetterFunction() const { return m_nullSetterFunction.get(); }
 596 
 597     JSFunction* parseIntFunction() const { return m_parseIntFunction.get(); }
 598     JSFunction* parseFloatFunction() const { return m_parseFloatFunction.get(); }
 599 
 600     JSFunction* evalFunction() const { return m_evalFunction.get(); }
 601     JSFunction* callFunction() const { return m_callFunction.get(); }
 602     JSFunction* applyFunction() const { return m_applyFunction.get(); }
 603     JSFunction* throwTypeErrorFunction() const { return m_throwTypeErrorFunction.get(); }
 604     JSFunction* arrayProtoToStringFunction() const { return m_arrayProtoToStringFunction.get(this); }
 605     JSFunction* arrayProtoValuesFunction() const { return m_arrayProtoValuesFunction.get(this); }
 606     JSFunction* initializePromiseFunction() const { return m_initializePromiseFunction.get(this); }
 607     JSFunction* iteratorProtocolFunction() const { return m_iteratorProtocolFunction.get(this); }
 608     JSFunction* promiseResolveFunction() const { return m_promiseResolveFunction.get(this); }
 609     JSFunction* objectProtoValueOfFunction() const { return m_objectProtoValueOfFunction.get(); }
 610     JSFunction* numberProtoToStringFunction() const { return m_numberProtoToStringFunction.get(); }
 611     JSFunction* newPromiseCapabilityFunction() const { return m_newPromiseCapabilityFunction.get(); }
 612     JSFunction* functionProtoHasInstanceSymbolFunction() const { return m_functionProtoHasInstanceSymbolFunction.get(); }
 613     JSObject* regExpProtoExecFunction() const { return m_regExpProtoExec.get(); }
 614     JSObject* regExpProtoSymbolReplaceFunction() const { return m_regExpProtoSymbolReplace.get(); }
 615     JSObject* regExpProtoGlobalGetter() const { return m_regExpProtoGlobalGetter.get(); }
 616     JSObject* regExpProtoUnicodeGetter() const { return m_regExpProtoUnicodeGetter.get(); }
 617     GetterSetter* throwTypeErrorArgumentsCalleeAndCallerGetterSetter()
 618     {
 619         return m_throwTypeErrorArgumentsCalleeAndCallerGetterSetter.get();
 620     }
 621 
 622     JSModuleLoader* moduleLoader() const { return m_moduleLoader.get(this); }
 623 
 624     ObjectPrototype* objectPrototype() const { return m_objectPrototype.get(); }
 625     FunctionPrototype* functionPrototype() const { return m_functionPrototype.get(); }
 626     ArrayPrototype* arrayPrototype() const { return m_arrayPrototype.get(); }
 627     JSObject* booleanPrototype() const { return m_booleanObjectStructure.prototypeInitializedOnMainThread(this); }
 628     StringPrototype* stringPrototype() const { return m_stringPrototype.get(); }
 629     JSObject* numberPrototype() const { return m_numberObjectStructure.prototypeInitializedOnMainThread(this); }
 630     BigIntPrototype* bigIntPrototype() const { return m_bigIntPrototype.get(); }
 631     JSObject* datePrototype() const { return m_dateStructure.prototype(this); }
 632     JSObject* symbolPrototype() const { return m_symbolObjectStructure.prototypeInitializedOnMainThread(this); }
 633     RegExpPrototype* regExpPrototype() const { return m_regExpPrototype.get(); }
 634     ErrorPrototype* errorPrototype() const { return m_errorPrototype.get(); }
 635     IteratorPrototype* iteratorPrototype() const { return m_iteratorPrototype.get(); }
 636     AsyncIteratorPrototype* asyncIteratorPrototype() const { return m_asyncIteratorPrototype.get(); }
 637     GeneratorFunctionPrototype* generatorFunctionPrototype() const { return m_generatorFunctionPrototype.get(); }
 638     GeneratorPrototype* generatorPrototype() const { return m_generatorPrototype.get(); }
 639     AsyncFunctionPrototype* asyncFunctionPrototype() const { return m_asyncFunctionPrototype.get(); }
 640     MapPrototype* mapPrototype() const { return m_mapPrototype.get(); }
 641     // Workaround for the name conflict between JSCell::setPrototype.
 642     SetPrototype* jsSetPrototype() const { return m_setPrototype.get(); }
 643     JSPromisePrototype* promisePrototype() const { return m_promisePrototype.get(); }
 644     AsyncGeneratorPrototype* asyncGeneratorPrototype() const { return m_asyncGeneratorPrototype.get(); }
 645     AsyncGeneratorFunctionPrototype* asyncGeneratorFunctionPrototype() const { return m_asyncGeneratorFunctionPrototype.get(); }
 646 
 647     Structure* debuggerScopeStructure() const { return m_debuggerScopeStructure.get(this); }
 648     Structure* withScopeStructure() const { return m_withScopeStructure.get(this); }
 649     Structure* strictEvalActivationStructure() const { return m_strictEvalActivationStructure.get(); }
 650     Structure* activationStructure() const { return m_lexicalEnvironmentStructure.get(); }
 651     Structure* moduleEnvironmentStructure() const { return m_moduleEnvironmentStructure.get(this); }
 652     Structure* directArgumentsStructure() const { return m_directArgumentsStructure.get(); }
 653     Structure* scopedArgumentsStructure() const { return m_scopedArgumentsStructure.get(); }
 654     Structure* clonedArgumentsStructure() const { return m_clonedArgumentsStructure.get(); }
 655     Structure* objectStructureForObjectConstructor() const { return m_objectStructureForObjectConstructor.get(); }
 656     Structure* originalArrayStructureForIndexingType(IndexingType indexingType) const
 657     {
 658         ASSERT(indexingType &amp; IsArray);
 659         return m_originalArrayStructureForIndexingShape[arrayIndexFromIndexingType(indexingType)].get();
 660     }
 661     Structure* arrayStructureForIndexingTypeDuringAllocation(IndexingType indexingType) const
 662     {
 663         ASSERT(indexingType &amp; IsArray);
 664         return m_arrayStructureForIndexingShapeDuringAllocation[arrayIndexFromIndexingType(indexingType)].get();
 665     }
 666     Structure* arrayStructureForIndexingTypeDuringAllocation(ExecState* exec, IndexingType indexingType, JSValue newTarget) const
 667     {
 668         return InternalFunction::createSubclassStructure(exec, newTarget, arrayStructureForIndexingTypeDuringAllocation(indexingType));
 669     }
 670     Structure* arrayStructureForProfileDuringAllocation(ExecState* exec, ArrayAllocationProfile* profile, JSValue newTarget) const
 671     {
 672         return arrayStructureForIndexingTypeDuringAllocation(exec, ArrayAllocationProfile::selectIndexingTypeFor(profile), newTarget);
 673     }
 674 
 675     bool isOriginalArrayStructure(Structure* structure)
 676     {
 677         return originalArrayStructureForIndexingType(structure-&gt;indexingMode() | IsArray) == structure;
 678     }
 679 
 680     Structure* booleanObjectStructure() const { return m_booleanObjectStructure.get(this); }
 681     Structure* callbackConstructorStructure() const { return m_callbackConstructorStructure.get(this); }
 682     Structure* callbackFunctionStructure() const { return m_callbackFunctionStructure.get(this); }
 683     Structure* callbackObjectStructure() const { return m_callbackObjectStructure.get(this); }
 684 #if JSC_OBJC_API_ENABLED
 685     Structure* objcCallbackFunctionStructure() const { return m_objcCallbackFunctionStructure.get(this); }
 686     Structure* objcWrapperObjectStructure() const { return m_objcWrapperObjectStructure.get(this); }
 687 #endif
 688 #ifdef JSC_GLIB_API_ENABLED
 689     Structure* glibCallbackFunctionStructure() const { return m_glibCallbackFunctionStructure.get(this); }
 690     Structure* glibWrapperObjectStructure() const { return m_glibWrapperObjectStructure.get(this); }
 691 #endif
 692     Structure* dateStructure() const { return m_dateStructure.get(this); }
 693     Structure* symbolObjectStructure() const { return m_symbolObjectStructure.get(this); }
 694     Structure* nullPrototypeObjectStructure() const { return m_nullPrototypeObjectStructure.get(); }
 695     Structure* errorStructure() const { return m_errorStructure.get(); }
 696     Structure* errorStructure(ErrorType errorType) const
 697     {
 698         switch (errorType) {
 699         case ErrorType::Error:
 700             return errorStructure();
 701         case ErrorType::EvalError:
 702             return m_evalErrorStructure.get(this);
 703         case ErrorType::RangeError:
 704             return m_rangeErrorStructure.get(this);
 705         case ErrorType::ReferenceError:
 706             return m_referenceErrorStructure.get(this);
 707         case ErrorType::SyntaxError:
 708             return m_syntaxErrorStructure.get(this);
 709         case ErrorType::TypeError:
 710             return m_typeErrorStructure.get(this);
 711         case ErrorType::URIError:
 712             return m_URIErrorStructure.get(this);
 713         }
 714         ASSERT_NOT_REACHED();
 715         return nullptr;
 716     }
 717     Structure* calleeStructure() const { return m_calleeStructure.get(); }
 718     Structure* hostFunctionStructure() const { return m_hostFunctionStructure.get(); }
 719 
 720     Structure* arrowFunctionStructure(bool isBuiltin) const
 721     {
 722         if (isBuiltin)
 723             return m_builtinFunctions.arrowFunctionStructure.get();
 724         return m_ordinaryFunctions.arrowFunctionStructure.get();
 725     }
 726     Structure* sloppyFunctionStructure(bool isBuiltin) const
 727     {
 728         if (isBuiltin)
 729             return m_builtinFunctions.sloppyFunctionStructure.get();
 730         return m_ordinaryFunctions.sloppyFunctionStructure.get();
 731     }
 732     Structure* strictFunctionStructure(bool isBuiltin) const
 733     {
 734         if (isBuiltin)
 735             return m_builtinFunctions.strictFunctionStructure.get();
 736         return m_ordinaryFunctions.strictFunctionStructure.get();
 737     }
 738 
 739     Structure* boundFunctionStructure() const { return m_boundFunctionStructure.get(this); }
 740     Structure* customGetterSetterFunctionStructure() const { return m_customGetterSetterFunctionStructure.get(this); }
 741     Structure* getterSetterStructure() const { return m_getterSetterStructure.get(); }
 742     Structure* nativeStdFunctionStructure() const { return m_nativeStdFunctionStructure.get(this); }
 743     PropertyOffset functionNameOffset() const { return m_functionNameOffset; }
 744     Structure* numberObjectStructure() const { return m_numberObjectStructure.get(this); }
 745     Structure* mapStructure() const { return m_mapStructure.get(); }
 746     Structure* regExpStructure() const { return m_regExpStructure.get(); }
 747     Structure* generatorFunctionStructure() const { return m_generatorFunctionStructure.get(); }
 748     Structure* asyncFunctionStructure() const { return m_asyncFunctionStructure.get(); }
 749     Structure* asyncGeneratorFunctionStructure() const { return m_asyncGeneratorFunctionStructure.get(); }
 750     Structure* stringObjectStructure() const { return m_stringObjectStructure.get(); }
 751     Structure* bigIntObjectStructure() const { return m_bigIntObjectStructure.get(); }
 752     Structure* iteratorResultObjectStructure() const { return m_iteratorResultObjectStructure.get(); }
 753     Structure* regExpMatchesArrayStructure() const { return m_regExpMatchesArrayStructure.get(); }
 754     Structure* regExpMatchesArrayWithGroupsStructure() const { return m_regExpMatchesArrayWithGroupsStructure.get(); }
 755     Structure* moduleRecordStructure() const { return m_moduleRecordStructure.get(); }
 756     Structure* moduleNamespaceObjectStructure() const { return m_moduleNamespaceObjectStructure.get(); }
 757     Structure* proxyObjectStructure() const { return m_proxyObjectStructure.get(); }
 758     Structure* callableProxyObjectStructure() const { return m_callableProxyObjectStructure.get(); }
 759     Structure* proxyRevokeStructure() const { return m_proxyRevokeStructure.get(); }
 760     Structure* restParameterStructure() const { return arrayStructureForIndexingTypeDuringAllocation(ArrayWithContiguous); }
 761     Structure* originalRestParameterStructure() const { return originalArrayStructureForIndexingType(ArrayWithContiguous); }
 762 #if ENABLE(WEBASSEMBLY)
 763     Structure* webAssemblyModuleRecordStructure() const { return m_webAssemblyModuleRecordStructure.get(); }
 764     Structure* webAssemblyFunctionStructure() const { return m_webAssemblyFunctionStructure.get(); }
 765     Structure* webAssemblyWrapperFunctionStructure() const { return m_webAssemblyWrapperFunctionStructure.get(); }
 766     Structure* webAssemblyToJSCalleeStructure() const { return m_webAssemblyToJSCalleeStructure.get(); }
 767 #endif // ENABLE(WEBASSEMBLY)
 768 #if ENABLE(INTL)
 769     Structure* collatorStructure() { return m_collatorStructure.get(this); }
 770     Structure* numberFormatStructure() { return m_numberFormatStructure.get(this); }
 771     Structure* dateTimeFormatStructure() { return m_dateTimeFormatStructure.get(this); }
 772     Structure* pluralRulesStructure() { return m_pluralRulesStructure.get(this); }
 773 #endif // ENABLE(INTL)
 774 
 775     JS_EXPORT_PRIVATE void setRemoteDebuggingEnabled(bool);
 776     JS_EXPORT_PRIVATE bool remoteDebuggingEnabled() const;
 777 
 778     RegExpGlobalData&amp; regExpGlobalData() { return m_regExpGlobalData; }
 779     static ptrdiff_t regExpGlobalDataOffset() { return OBJECT_OFFSETOF(JSGlobalObject, m_regExpGlobalData); }
 780 
 781 #if ENABLE(REMOTE_INSPECTOR)
 782     Inspector::JSGlobalObjectInspectorController&amp; inspectorController() const { return *m_inspectorController.get(); }
 783     JSGlobalObjectDebuggable&amp; inspectorDebuggable() { return *m_inspectorDebuggable.get(); }
 784 #endif
 785 
 786 #if ENABLE(INTL)
 787     const HashSet&lt;String&gt;&amp; intlCollatorAvailableLocales();
 788     const HashSet&lt;String&gt;&amp; intlDateTimeFormatAvailableLocales();
 789     const HashSet&lt;String&gt;&amp; intlNumberFormatAvailableLocales();
 790     const HashSet&lt;String&gt;&amp; intlPluralRulesAvailableLocales();
 791 #endif // ENABLE(INTL)
 792 
 793     void bumpGlobalLexicalBindingEpoch(VM&amp;);
 794     unsigned globalLexicalBindingEpoch() const { return m_globalLexicalBindingEpoch; }
 795     static ptrdiff_t globalLexicalBindingEpochOffset() { return OBJECT_OFFSETOF(JSGlobalObject, m_globalLexicalBindingEpoch); }
 796     unsigned* addressOfGlobalLexicalBindingEpoch() { return &amp;m_globalLexicalBindingEpoch; }
 797 
 798     void setConsoleClient(ConsoleClient* consoleClient) { m_consoleClient = consoleClient; }
 799     ConsoleClient* consoleClient() const { return m_consoleClient; }
 800 
 801     void setName(const String&amp;);
 802     const String&amp; name() const { return m_name; }
 803 
 804     JSArrayBufferPrototype* arrayBufferPrototype(ArrayBufferSharingMode sharingMode) const
 805     {
 806         switch (sharingMode) {
 807         case ArrayBufferSharingMode::Default:
 808             return m_arrayBufferPrototype.get();
 809 #if ENABLE(SHARED_ARRAY_BUFFER)
 810         case ArrayBufferSharingMode::Shared:
 811             return m_sharedArrayBufferPrototype.get();
 812 #else
 813         default:
 814             return m_arrayBufferPrototype.get();
 815 #endif
 816         }
 817     }
 818     Structure* arrayBufferStructure(ArrayBufferSharingMode sharingMode) const
 819     {
 820         switch (sharingMode) {
 821         case ArrayBufferSharingMode::Default:
 822             return m_arrayBufferStructure.get();
 823 #if ENABLE(SHARED_ARRAY_BUFFER)
 824         case ArrayBufferSharingMode::Shared:
 825             return m_sharedArrayBufferStructure.get();
 826 #else
 827         default:
 828             return m_arrayBufferStructure.get();
 829 #endif
 830         }
 831         RELEASE_ASSERT_NOT_REACHED();
 832         return nullptr;
 833     }
 834 
 835 #define DEFINE_ACCESSORS_FOR_SIMPLE_TYPE(capitalName, lowerName, properName, instanceType, jsName, prototypeBase) \
 836     Structure* properName ## Structure() { return m_ ## properName ## Structure.get(); }
 837 
 838     FOR_EACH_SIMPLE_BUILTIN_TYPE(DEFINE_ACCESSORS_FOR_SIMPLE_TYPE)
 839     FOR_BIG_INT_BUILTIN_TYPE_WITH_CONSTRUCTOR(DEFINE_ACCESSORS_FOR_SIMPLE_TYPE)
 840     FOR_EACH_WEBASSEMBLY_CONSTRUCTOR_TYPE(DEFINE_ACCESSORS_FOR_SIMPLE_TYPE)
 841     FOR_EACH_BUILTIN_DERIVED_ITERATOR_TYPE(DEFINE_ACCESSORS_FOR_SIMPLE_TYPE)
 842 
 843 #undef DEFINE_ACCESSORS_FOR_SIMPLE_TYPE
 844 
 845 #define DEFINE_ACCESSORS_FOR_LAZY_TYPE(capitalName, lowerName, properName, instanceType, jsName, prototypeBase) \
 846     Structure* properName ## Structure() { return m_ ## properName ## Structure.get(this); }
 847 
 848     FOR_EACH_LAZY_BUILTIN_TYPE(DEFINE_ACCESSORS_FOR_LAZY_TYPE)
 849 
 850 #undef DEFINE_ACCESSORS_FOR_LAZY_TYPE
 851 
 852     LazyClassStructure&amp; lazyTypedArrayStructure(TypedArrayType type)
 853     {
 854         switch (type) {
 855         case NotTypedArray:
 856             RELEASE_ASSERT_NOT_REACHED();
 857             return m_typedArrayInt8;
 858 #define TYPED_ARRAY_TYPE_CASE(name) case Type ## name: return m_typedArray ## name;
 859             FOR_EACH_TYPED_ARRAY_TYPE(TYPED_ARRAY_TYPE_CASE)
 860 #undef TYPED_ARRAY_TYPE_CASE
 861         }
 862         RELEASE_ASSERT_NOT_REACHED();
 863         return m_typedArrayInt8;
 864     }
 865     const LazyClassStructure&amp; lazyTypedArrayStructure(TypedArrayType type) const
 866     {
 867         return const_cast&lt;const LazyClassStructure&amp;&gt;(const_cast&lt;JSGlobalObject*&gt;(this)-&gt;lazyTypedArrayStructure(type));
 868     }
 869 
 870     Structure* typedArrayStructure(TypedArrayType type) const
 871     {
 872         return lazyTypedArrayStructure(type).get(this);
 873     }
 874     Structure* typedArrayStructureConcurrently(TypedArrayType type) const
 875     {
 876         return lazyTypedArrayStructure(type).getConcurrently();
 877     }
 878     bool isOriginalTypedArrayStructure(Structure* structure)
 879     {
 880         TypedArrayType type = structure-&gt;classInfo()-&gt;typedArrayStorageType;
 881         if (type == NotTypedArray)
 882             return false;
 883         return typedArrayStructureConcurrently(type) == structure;
 884     }
 885 
 886     JSObject* typedArrayConstructor(TypedArrayType type) const
 887     {
 888         return lazyTypedArrayStructure(type).constructor(this);
 889     }
 890 
 891     JSCell* actualPointerFor(Special::Pointer pointer)
 892     {
 893         ASSERT(pointer &lt; Special::TableSize);
 894         return m_specialPointers[pointer];
 895     }
 896     JSCell* jsCellForLinkTimeConstant(LinkTimeConstant type)
 897     {
 898         unsigned index = static_cast&lt;unsigned&gt;(type);
 899         ASSERT(index &lt; LinkTimeConstantCount);
 900         return m_linkTimeConstants[index];
 901     }
 902 
 903     WatchpointSet* masqueradesAsUndefinedWatchpoint() { return m_masqueradesAsUndefinedWatchpoint.get(); }
 904     WatchpointSet* havingABadTimeWatchpoint() { return m_havingABadTimeWatchpoint.get(); }
 905     WatchpointSet* varInjectionWatchpoint() { return m_varInjectionWatchpoint.get(); }
 906 
 907     bool isHavingABadTime() const
 908     {
 909         return m_havingABadTimeWatchpoint-&gt;hasBeenInvalidated();
 910     }
 911 
 912     void haveABadTime(VM&amp;);
 913 
 914     bool objectPrototypeIsSane();
 915     bool arrayPrototypeChainIsSane();
 916     bool stringPrototypeChainIsSane();
 917 
 918     void setProfileGroup(unsigned value) { createRareDataIfNeeded(); m_rareData-&gt;profileGroup = value; }
 919     unsigned profileGroup() const
 920     {
 921         if (!m_rareData)
 922             return 0;
 923         return m_rareData-&gt;profileGroup;
 924     }
 925 
 926     Debugger* debugger() const { return m_debugger; }
 927     void setDebugger(Debugger*);
 928 
 929     const GlobalObjectMethodTable* globalObjectMethodTable() const { return m_globalObjectMethodTable; }
 930 
 931     static bool supportsRichSourceInfo(const JSGlobalObject*) { return true; }
 932 
 933     JS_EXPORT_PRIVATE ExecState* globalExec();
 934 
 935     static bool shouldInterruptScript(const JSGlobalObject*) { return true; }
 936     static bool shouldInterruptScriptBeforeTimeout(const JSGlobalObject*) { return false; }
 937     static RuntimeFlags javaScriptRuntimeFlags(const JSGlobalObject*) { return RuntimeFlags(); }
 938 
 939     JS_EXPORT_PRIVATE void queueMicrotask(Ref&lt;Microtask&gt;&amp;&amp;);
 940 
 941     bool evalEnabled() const { return m_evalEnabled; }
 942     bool webAssemblyEnabled() const { return m_webAssemblyEnabled; }
 943     const String&amp; evalDisabledErrorMessage() const { return m_evalDisabledErrorMessage; }
 944     const String&amp; webAssemblyDisabledErrorMessage() const { return m_webAssemblyDisabledErrorMessage; }
 945     void setEvalEnabled(bool enabled, const String&amp; errorMessage = String())
 946     {
 947         m_evalEnabled = enabled;
 948         m_evalDisabledErrorMessage = errorMessage;
 949     }
 950     void setWebAssemblyEnabled(bool enabled, const String&amp; errorMessage = String())
 951     {
 952         m_webAssemblyEnabled = enabled;
 953         m_webAssemblyDisabledErrorMessage = errorMessage;
 954     }
 955 
 956 #if !ASSERT_DISABLED
 957     const ExecState* callFrameAtDebuggerEntry() const { return m_callFrameAtDebuggerEntry; }
 958     void setCallFrameAtDebuggerEntry(const ExecState* callFrame) { m_callFrameAtDebuggerEntry = callFrame; }
 959 #endif
 960 
 961     void resetPrototype(VM&amp;, JSValue prototype);
 962 
 963     VM&amp; vm() const { return m_vm; }
 964     JSObject* globalThis() const;
 965     WriteBarrier&lt;JSObject&gt;* addressOfGlobalThis() { return &amp;m_globalThis; }
 966 
 967     static Structure* createStructure(VM&amp; vm, JSValue prototype)
 968     {
 969         Structure* result = Structure::create(vm, 0, prototype, TypeInfo(GlobalObjectType, StructureFlags), info());
 970         result-&gt;setTransitionWatchpointIsLikelyToBeFired(true);
 971         return result;
 972     }
 973 
 974     void registerWeakMap(OpaqueJSWeakObjectMap* map)
 975     {
 976         createRareDataIfNeeded();
 977         m_rareData-&gt;weakMaps.add(map);
 978     }
 979 
 980     void unregisterWeakMap(OpaqueJSWeakObjectMap* map)
 981     {
 982         if (m_rareData)
 983             m_rareData-&gt;weakMaps.remove(map);
 984     }
 985 
 986     OpaqueJSClassDataMap&amp; opaqueJSClassData()
 987     {
 988         createRareDataIfNeeded();
 989         return m_rareData-&gt;opaqueJSClassData;
 990     }
 991 
 992     static ptrdiff_t weakRandomOffset() { return OBJECT_OFFSETOF(JSGlobalObject, m_weakRandom); }
 993     double weakRandomNumber() { return m_weakRandom.get(); }
 994     unsigned weakRandomInteger() { return m_weakRandom.getUint32(); }
 995     WeakRandom&amp; weakRandom() { return m_weakRandom; }
 996 
 997     bool needsSiteSpecificQuirks() const { return m_needsSiteSpecificQuirks; }
 998     JS_EXPORT_PRIVATE void exposeDollarVM(VM&amp;);
 999 
1000 #if JSC_OBJC_API_ENABLED
1001     JSWrapperMap* wrapperMap() const { return m_wrapperMap.get(); }
1002     void setWrapperMap(JSWrapperMap* map) { m_wrapperMap = map; }
1003 #endif
1004 #ifdef JSC_GLIB_API_ENABLED
1005     WrapperMap* wrapperMap() const { return m_wrapperMap.get(); }
1006     void setWrapperMap(std::unique_ptr&lt;WrapperMap&gt;&amp;&amp;);
1007 #endif
1008 
1009 protected:
1010     struct GlobalPropertyInfo {
1011         GlobalPropertyInfo(const Identifier&amp; i, JSValue v, unsigned a)
1012             : identifier(i)
1013             , value(v)
1014             , attributes(a)
1015         {
1016         }
1017 
1018         const Identifier identifier;
1019         JSValue value;
1020         unsigned attributes;
1021     };
1022     JS_EXPORT_PRIVATE void addStaticGlobals(GlobalPropertyInfo*, int count);
1023 
1024     void setNeedsSiteSpecificQuirks(bool needQuirks) { m_needsSiteSpecificQuirks = needQuirks; }
1025 
1026 private:
1027     friend class LLIntOffsetsExtractor;
1028 
1029     void fireWatchpointAndMakeAllArrayStructuresSlowPut(VM&amp;);
1030     void setGlobalThis(VM&amp;, JSObject* globalThis);
1031 
1032     template&lt;ErrorType errorType&gt;
1033     void initializeErrorConstructor(LazyClassStructure::Initializer&amp;);
1034 
1035     JS_EXPORT_PRIVATE void init(VM&amp;);
1036 
1037     JS_EXPORT_PRIVATE static void clearRareData(JSCell*);
1038 
1039     bool m_needsSiteSpecificQuirks { false };
1040 #if JSC_OBJC_API_ENABLED
1041     RetainPtr&lt;JSWrapperMap&gt; m_wrapperMap;
1042 #endif
1043 #ifdef JSC_GLIB_API_ENABLED
1044     std::unique_ptr&lt;WrapperMap&gt; m_wrapperMap;
1045 #endif
1046 };
1047 
1048 inline JSArray* constructEmptyArray(ExecState* exec, ArrayAllocationProfile* profile, JSGlobalObject* globalObject, unsigned initialLength = 0, JSValue newTarget = JSValue())
1049 {
1050     VM&amp; vm = globalObject-&gt;vm();
1051     auto scope = DECLARE_THROW_SCOPE(vm);
1052     Structure* structure;
1053     if (initialLength &gt;= MIN_ARRAY_STORAGE_CONSTRUCTION_LENGTH)
1054         structure = globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(exec, ArrayWithArrayStorage, newTarget);
1055     else
1056         structure = globalObject-&gt;arrayStructureForProfileDuringAllocation(exec, profile, newTarget);
1057     RETURN_IF_EXCEPTION(scope, nullptr);
1058 
1059     JSArray* result = JSArray::tryCreate(vm, structure, initialLength);
1060     if (UNLIKELY(!result)) {
1061         throwOutOfMemoryError(exec, scope);
1062         return nullptr;
1063     }
1064     return ArrayAllocationProfile::updateLastAllocationFor(profile, result);
1065 }
1066 
1067 inline JSArray* constructEmptyArray(ExecState* exec, ArrayAllocationProfile* profile, unsigned initialLength = 0, JSValue newTarget = JSValue())
1068 {
1069     return constructEmptyArray(exec, profile, exec-&gt;lexicalGlobalObject(), initialLength, newTarget);
1070 }
1071 
1072 inline JSArray* constructArray(ExecState* exec, ArrayAllocationProfile* profile, JSGlobalObject* globalObject, const ArgList&amp; values, JSValue newTarget = JSValue())
1073 {
1074     VM&amp; vm = globalObject-&gt;vm();
1075     auto scope = DECLARE_THROW_SCOPE(vm);
1076     Structure* structure = globalObject-&gt;arrayStructureForProfileDuringAllocation(exec, profile, newTarget);
1077     RETURN_IF_EXCEPTION(scope, nullptr);
1078     return ArrayAllocationProfile::updateLastAllocationFor(profile, constructArray(exec, structure, values));
1079 }
1080 
1081 inline JSArray* constructArray(ExecState* exec, ArrayAllocationProfile* profile, const ArgList&amp; values, JSValue newTarget = JSValue())
1082 {
1083     return constructArray(exec, profile, exec-&gt;lexicalGlobalObject(), values, newTarget);
1084 }
1085 
1086 inline JSArray* constructArray(ExecState* exec, ArrayAllocationProfile* profile, JSGlobalObject* globalObject, const JSValue* values, unsigned length, JSValue newTarget = JSValue())
1087 {
1088     VM&amp; vm = globalObject-&gt;vm();
1089     auto scope = DECLARE_THROW_SCOPE(vm);
1090     Structure* structure = globalObject-&gt;arrayStructureForProfileDuringAllocation(exec, profile, newTarget);
1091     RETURN_IF_EXCEPTION(scope, nullptr);
1092     return ArrayAllocationProfile::updateLastAllocationFor(profile, constructArray(exec, structure, values, length));
1093 }
1094 
1095 inline JSArray* constructArray(ExecState* exec, ArrayAllocationProfile* profile, const JSValue* values, unsigned length, JSValue newTarget = JSValue())
1096 {
1097     return constructArray(exec, profile, exec-&gt;lexicalGlobalObject(), values, length, newTarget);
1098 }
1099 
1100 inline JSArray* constructArrayNegativeIndexed(ExecState* exec, ArrayAllocationProfile* profile, JSGlobalObject* globalObject, const JSValue* values, unsigned length, JSValue newTarget = JSValue())
1101 {
1102     VM&amp; vm = globalObject-&gt;vm();
1103     auto scope = DECLARE_THROW_SCOPE(vm);
1104     Structure* structure = globalObject-&gt;arrayStructureForProfileDuringAllocation(exec, profile, newTarget);
1105     RETURN_IF_EXCEPTION(scope, nullptr);
1106     return ArrayAllocationProfile::updateLastAllocationFor(profile, constructArrayNegativeIndexed(exec, structure, values, length));
1107 }
1108 
1109 inline JSArray* constructArrayNegativeIndexed(ExecState* exec, ArrayAllocationProfile* profile, const JSValue* values, unsigned length, JSValue newTarget = JSValue())
1110 {
1111     return constructArrayNegativeIndexed(exec, profile, exec-&gt;lexicalGlobalObject(), values, length, newTarget);
1112 }
1113 
1114 inline JSObject* ExecState::globalThisValue() const
1115 {
1116     return lexicalGlobalObject()-&gt;globalThis();
1117 }
1118 
1119 inline JSObject* JSScope::globalThis()
1120 {
1121     return globalObject()-&gt;globalThis();
1122 }
1123 
1124 inline JSObject* JSGlobalObject::globalThis() const
1125 {
1126     return m_globalThis.get();
1127 }
1128 
1129 } // namespace JSC
    </pre>
  </body>
</html>