<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/svg/SVGElement.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SVGDocumentExtensions.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SVGElement.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/svg/SVGElement.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
   2  * Copyright (C) 2004, 2005, 2006, 2007, 2008 Nikolas Zimmermann &lt;zimmermann@kde.org&gt;
   3  * Copyright (C) 2004, 2005, 2006, 2008 Rob Buis &lt;buis@kde.org&gt;
<span class="line-modified">   4  * Copyright (C) 2008-2018 Apple Inc. All rights reserved.</span>
   5  * Copyright (C) 2008 Alp Toker &lt;alp@atoker.com&gt;
   6  * Copyright (C) 2009 Cameron McCormack &lt;cam@mcc.id.au&gt;
   7  * Copyright (C) 2013 Samsung Electronics. All rights reserved.
   8  * Copyright (C) 2014 Adobe Systems Incorporated. All rights reserved.
   9  *
  10  * This library is free software; you can redistribute it and/or
  11  * modify it under the terms of the GNU Library General Public
  12  * License as published by the Free Software Foundation; either
  13  * version 2 of the License, or (at your option) any later version.
  14  *
  15  * This library is distributed in the hope that it will be useful,
  16  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  17  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  18  * Library General Public License for more details.
  19  *
  20  * You should have received a copy of the GNU Library General Public License
  21  * along with this library; see the file COPYING.LIB.  If not, write to
  22  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  23  * Boston, MA 02110-1301, USA.
  24  */
</pre>
<hr />
<pre>
  27 #include &quot;SVGElement.h&quot;
  28 
  29 #include &quot;CSSPropertyParser.h&quot;
  30 #include &quot;DeprecatedCSSOMValue.h&quot;
  31 #include &quot;Document.h&quot;
  32 #include &quot;ElementIterator.h&quot;
  33 #include &quot;Event.h&quot;
  34 #include &quot;EventNames.h&quot;
  35 #include &quot;HTMLElement.h&quot;
  36 #include &quot;HTMLNames.h&quot;
  37 #include &quot;HTMLParserIdioms.h&quot;
  38 #include &quot;RenderObject.h&quot;
  39 #include &quot;RenderSVGResource.h&quot;
  40 #include &quot;RenderSVGResourceFilter.h&quot;
  41 #include &quot;RenderSVGResourceMasker.h&quot;
  42 #include &quot;SVGDocumentExtensions.h&quot;
  43 #include &quot;SVGElementRareData.h&quot;
  44 #include &quot;SVGGraphicsElement.h&quot;
  45 #include &quot;SVGImageElement.h&quot;
  46 #include &quot;SVGNames.h&quot;

  47 #include &quot;SVGRenderStyle.h&quot;
  48 #include &quot;SVGRenderSupport.h&quot;
  49 #include &quot;SVGSVGElement.h&quot;
  50 #include &quot;SVGTitleElement.h&quot;
  51 #include &quot;SVGUseElement.h&quot;
  52 #include &quot;ShadowRoot.h&quot;
  53 #include &quot;XMLNames.h&quot;
  54 #include &lt;wtf/Assertions.h&gt;
  55 #include &lt;wtf/HashMap.h&gt;
  56 #include &lt;wtf/IsoMallocInlines.h&gt;
  57 #include &lt;wtf/NeverDestroyed.h&gt;
  58 #include &lt;wtf/StdLibExtras.h&gt;
  59 #include &lt;wtf/text/WTFString.h&gt;
  60 
  61 
  62 namespace WebCore {
  63 
  64 WTF_MAKE_ISO_ALLOCATED_IMPL(SVGElement);
  65 
<span class="line-modified">  66 static NEVER_INLINE HashMap&lt;AtomicStringImpl*, CSSPropertyID&gt; createAttributeNameToCSSPropertyIDMap()</span>
  67 {
  68     using namespace HTMLNames;
  69     using namespace SVGNames;
  70 
  71     // This list should include all base CSS and SVG CSS properties which are exposed as SVG XML attributes.
  72     static const QualifiedName* const attributeNames[] = {
  73         &amp;alignment_baselineAttr.get(),
  74         &amp;baseline_shiftAttr.get(),
  75         &amp;buffered_renderingAttr.get(),
  76         &amp;clipAttr.get(),
  77         &amp;clip_pathAttr.get(),
  78         &amp;clip_ruleAttr.get(),
  79         &amp;SVGNames::colorAttr.get(),
  80         &amp;color_interpolationAttr.get(),
  81         &amp;color_interpolation_filtersAttr.get(),
  82         &amp;color_profileAttr.get(),
  83         &amp;color_renderingAttr.get(),
  84         &amp;cursorAttr.get(),
  85         &amp;cxAttr.get(),
  86         &amp;cyAttr.get(),
</pre>
<hr />
<pre>
 126         &amp;stroke_dasharrayAttr.get(),
 127         &amp;stroke_dashoffsetAttr.get(),
 128         &amp;stroke_linecapAttr.get(),
 129         &amp;stroke_linejoinAttr.get(),
 130         &amp;stroke_miterlimitAttr.get(),
 131         &amp;stroke_opacityAttr.get(),
 132         &amp;stroke_widthAttr.get(),
 133         &amp;text_anchorAttr.get(),
 134         &amp;text_decorationAttr.get(),
 135         &amp;text_renderingAttr.get(),
 136         &amp;unicode_bidiAttr.get(),
 137         &amp;vector_effectAttr.get(),
 138         &amp;visibilityAttr.get(),
 139         &amp;SVGNames::widthAttr.get(),
 140         &amp;word_spacingAttr.get(),
 141         &amp;writing_modeAttr.get(),
 142         &amp;xAttr.get(),
 143         &amp;yAttr.get(),
 144     };
 145 
<span class="line-modified"> 146     HashMap&lt;AtomicStringImpl*, CSSPropertyID&gt; map;</span>
 147 
 148     for (auto&amp; name : attributeNames) {
<span class="line-modified"> 149         const AtomicString&amp; localName = name-&gt;localName();</span>
 150         map.add(localName.impl(), cssPropertyID(localName));
 151     }
 152 
 153     // FIXME: When CSS supports &quot;transform-origin&quot; this special case can be removed,
 154     // and we can add transform_originAttr to the table above instead.
 155     map.add(transform_originAttr-&gt;localName().impl(), CSSPropertyTransformOrigin);
 156 
 157     return map;
 158 }
 159 
<span class="line-removed"> 160 static NEVER_INLINE HashMap&lt;QualifiedName::QualifiedNameImpl*, AnimatedPropertyType&gt; createAttributeNameToAnimatedPropertyTypeMap()</span>
<span class="line-removed"> 161 {</span>
<span class="line-removed"> 162     using namespace HTMLNames;</span>
<span class="line-removed"> 163     using namespace SVGNames;</span>
<span class="line-removed"> 164 </span>
<span class="line-removed"> 165     struct TableEntry {</span>
<span class="line-removed"> 166         const QualifiedName&amp; attributeName;</span>
<span class="line-removed"> 167         AnimatedPropertyType type;</span>
<span class="line-removed"> 168     };</span>
<span class="line-removed"> 169 </span>
<span class="line-removed"> 170     static const TableEntry table[] = {</span>
<span class="line-removed"> 171         { alignment_baselineAttr, AnimatedString },</span>
<span class="line-removed"> 172         { baseline_shiftAttr, AnimatedString },</span>
<span class="line-removed"> 173         { buffered_renderingAttr, AnimatedString },</span>
<span class="line-removed"> 174         { clipAttr, AnimatedRect },</span>
<span class="line-removed"> 175         { clip_pathAttr, AnimatedString },</span>
<span class="line-removed"> 176         { clip_ruleAttr, AnimatedString },</span>
<span class="line-removed"> 177         { SVGNames::colorAttr, AnimatedColor },</span>
<span class="line-removed"> 178         { color_interpolationAttr, AnimatedString },</span>
<span class="line-removed"> 179         { color_interpolation_filtersAttr, AnimatedString },</span>
<span class="line-removed"> 180         { color_profileAttr, AnimatedString },</span>
<span class="line-removed"> 181         { color_renderingAttr, AnimatedString },</span>
<span class="line-removed"> 182         { cursorAttr, AnimatedString },</span>
<span class="line-removed"> 183         { displayAttr, AnimatedString },</span>
<span class="line-removed"> 184         { dominant_baselineAttr, AnimatedString },</span>
<span class="line-removed"> 185         { fillAttr, AnimatedColor },</span>
<span class="line-removed"> 186         { fill_opacityAttr, AnimatedNumber },</span>
<span class="line-removed"> 187         { fill_ruleAttr, AnimatedString },</span>
<span class="line-removed"> 188         { filterAttr, AnimatedString },</span>
<span class="line-removed"> 189         { flood_colorAttr, AnimatedColor },</span>
<span class="line-removed"> 190         { flood_opacityAttr, AnimatedNumber },</span>
<span class="line-removed"> 191         { font_familyAttr, AnimatedString },</span>
<span class="line-removed"> 192         { font_sizeAttr, AnimatedLength },</span>
<span class="line-removed"> 193         { font_stretchAttr, AnimatedString },</span>
<span class="line-removed"> 194         { font_styleAttr, AnimatedString },</span>
<span class="line-removed"> 195         { font_variantAttr, AnimatedString },</span>
<span class="line-removed"> 196         { font_weightAttr, AnimatedString },</span>
<span class="line-removed"> 197         { image_renderingAttr, AnimatedString },</span>
<span class="line-removed"> 198         { kerningAttr, AnimatedLength },</span>
<span class="line-removed"> 199         { letter_spacingAttr, AnimatedLength },</span>
<span class="line-removed"> 200         { lighting_colorAttr, AnimatedColor },</span>
<span class="line-removed"> 201         { marker_endAttr, AnimatedString },</span>
<span class="line-removed"> 202         { marker_midAttr, AnimatedString },</span>
<span class="line-removed"> 203         { marker_startAttr, AnimatedString },</span>
<span class="line-removed"> 204         { maskAttr, AnimatedString },</span>
<span class="line-removed"> 205         { mask_typeAttr, AnimatedString },</span>
<span class="line-removed"> 206         { opacityAttr, AnimatedNumber },</span>
<span class="line-removed"> 207         { overflowAttr, AnimatedString },</span>
<span class="line-removed"> 208         { paint_orderAttr, AnimatedString },</span>
<span class="line-removed"> 209         { pointer_eventsAttr, AnimatedString },</span>
<span class="line-removed"> 210         { shape_renderingAttr, AnimatedString },</span>
<span class="line-removed"> 211         { stop_colorAttr, AnimatedColor },</span>
<span class="line-removed"> 212         { stop_opacityAttr, AnimatedNumber },</span>
<span class="line-removed"> 213         { strokeAttr, AnimatedColor },</span>
<span class="line-removed"> 214         { stroke_dasharrayAttr, AnimatedLengthList },</span>
<span class="line-removed"> 215         { stroke_dashoffsetAttr, AnimatedLength },</span>
<span class="line-removed"> 216         { stroke_linecapAttr, AnimatedString },</span>
<span class="line-removed"> 217         { stroke_linejoinAttr, AnimatedString },</span>
<span class="line-removed"> 218         { stroke_miterlimitAttr, AnimatedNumber },</span>
<span class="line-removed"> 219         { stroke_opacityAttr, AnimatedNumber },</span>
<span class="line-removed"> 220         { stroke_widthAttr, AnimatedLength },</span>
<span class="line-removed"> 221         { text_anchorAttr, AnimatedString },</span>
<span class="line-removed"> 222         { text_decorationAttr, AnimatedString },</span>
<span class="line-removed"> 223         { text_renderingAttr, AnimatedString },</span>
<span class="line-removed"> 224         { vector_effectAttr, AnimatedString },</span>
<span class="line-removed"> 225         { visibilityAttr, AnimatedString },</span>
<span class="line-removed"> 226         { word_spacingAttr, AnimatedLength },</span>
<span class="line-removed"> 227     };</span>
<span class="line-removed"> 228 </span>
<span class="line-removed"> 229     HashMap&lt;QualifiedName::QualifiedNameImpl*, AnimatedPropertyType&gt; map;</span>
<span class="line-removed"> 230     for (auto&amp; entry : table)</span>
<span class="line-removed"> 231         map.add(entry.attributeName.impl(), entry.type);</span>
<span class="line-removed"> 232     return map;</span>
<span class="line-removed"> 233 }</span>
<span class="line-removed"> 234 </span>
<span class="line-removed"> 235 static const HashMap&lt;QualifiedName::QualifiedNameImpl*, AnimatedPropertyType&gt;&amp; attributeNameToAnimatedPropertyTypeMap()</span>
<span class="line-removed"> 236 {</span>
<span class="line-removed"> 237     static const auto map = makeNeverDestroyed(createAttributeNameToAnimatedPropertyTypeMap());</span>
<span class="line-removed"> 238     return map;</span>
<span class="line-removed"> 239 }</span>
<span class="line-removed"> 240 </span>
<span class="line-removed"> 241 static NEVER_INLINE HashMap&lt;QualifiedName::QualifiedNameImpl*, AnimatedPropertyType&gt; createCSSPropertyWithSVGDOMNameToAnimatedPropertyTypeMap()</span>
<span class="line-removed"> 242 {</span>
<span class="line-removed"> 243     using namespace HTMLNames;</span>
<span class="line-removed"> 244     using namespace SVGNames;</span>
<span class="line-removed"> 245 </span>
<span class="line-removed"> 246     struct TableEntry {</span>
<span class="line-removed"> 247         const QualifiedName&amp; attributeName;</span>
<span class="line-removed"> 248         AnimatedPropertyType type;</span>
<span class="line-removed"> 249     };</span>
<span class="line-removed"> 250 </span>
<span class="line-removed"> 251     static const TableEntry table[] = {</span>
<span class="line-removed"> 252         { cxAttr, AnimatedLength },</span>
<span class="line-removed"> 253         { cyAttr, AnimatedLength },</span>
<span class="line-removed"> 254         { rAttr, AnimatedLength },</span>
<span class="line-removed"> 255         { rxAttr, AnimatedLength },</span>
<span class="line-removed"> 256         { ryAttr, AnimatedLength },</span>
<span class="line-removed"> 257         { SVGNames::heightAttr, AnimatedLength },</span>
<span class="line-removed"> 258         { SVGNames::widthAttr, AnimatedLength },</span>
<span class="line-removed"> 259         { xAttr, AnimatedLength },</span>
<span class="line-removed"> 260         { yAttr, AnimatedLength },</span>
<span class="line-removed"> 261     };</span>
<span class="line-removed"> 262 </span>
<span class="line-removed"> 263     HashMap&lt;QualifiedName::QualifiedNameImpl*, AnimatedPropertyType&gt; map;</span>
<span class="line-removed"> 264     for (auto&amp; entry : table)</span>
<span class="line-removed"> 265         map.add(entry.attributeName.impl(), entry.type);</span>
<span class="line-removed"> 266     return map;</span>
<span class="line-removed"> 267 }</span>
<span class="line-removed"> 268 </span>
<span class="line-removed"> 269 static inline const HashMap&lt;QualifiedName::QualifiedNameImpl*, AnimatedPropertyType&gt;&amp; cssPropertyWithSVGDOMNameToAnimatedPropertyTypeMap()</span>
<span class="line-removed"> 270 {</span>
<span class="line-removed"> 271     static const auto map = makeNeverDestroyed(createCSSPropertyWithSVGDOMNameToAnimatedPropertyTypeMap());</span>
<span class="line-removed"> 272     return map;</span>
<span class="line-removed"> 273 }</span>
<span class="line-removed"> 274 </span>
 275 SVGElement::SVGElement(const QualifiedName&amp; tagName, Document&amp; document)
 276     : StyledElement(tagName, document, CreateSVGElement)
 277     , SVGLangSpace(this)

 278 {
<span class="line-modified"> 279     registerAttributes();</span>



 280 }
 281 
 282 SVGElement::~SVGElement()
 283 {
 284     if (m_svgRareData) {
 285         for (SVGElement* instance : m_svgRareData-&gt;instances())
 286             instance-&gt;m_svgRareData-&gt;setCorrespondingElement(nullptr);
 287         if (auto correspondingElement = makeRefPtr(m_svgRareData-&gt;correspondingElement()))
 288             correspondingElement-&gt;m_svgRareData-&gt;instances().remove(this);
 289 
 290         m_svgRareData = nullptr;
 291     }
 292     document().accessSVGExtensions().rebuildAllElementReferencesForTarget(*this);
 293     document().accessSVGExtensions().removeAllElementReferencesForTarget(*this);
 294 }
 295 
<span class="line-removed"> 296 int SVGElement::tabIndex() const</span>
<span class="line-removed"> 297 {</span>
<span class="line-removed"> 298     if (supportsFocus())</span>
<span class="line-removed"> 299         return Element::tabIndex();</span>
<span class="line-removed"> 300     return -1;</span>
<span class="line-removed"> 301 }</span>
<span class="line-removed"> 302 </span>
 303 void SVGElement::willRecalcStyle(Style::Change change)
 304 {
 305     if (!m_svgRareData || styleResolutionShouldRecompositeLayer())
 306         return;
 307     // If the style changes because of a regular property change (not induced by SMIL animations themselves)
 308     // reset the &quot;computed style without SMIL style properties&quot;, so the base value change gets reflected.
 309     if (change &gt; Style::NoChange || needsStyleRecalc())
 310         m_svgRareData-&gt;setNeedsOverrideComputedStyleUpdate();
 311 }
 312 
 313 SVGElementRareData&amp; SVGElement::ensureSVGRareData()
 314 {
 315     if (!m_svgRareData)
<span class="line-modified"> 316         m_svgRareData = std::make_unique&lt;SVGElementRareData&gt;();</span>
 317     return *m_svgRareData;
 318 }
 319 
 320 bool SVGElement::isOutermostSVGSVGElement() const
 321 {
 322     if (!is&lt;SVGSVGElement&gt;(*this))
 323         return false;
 324 
 325     // If we&#39;re living in a shadow tree, we&#39;re a &lt;svg&gt; element that got created as replacement
 326     // for a &lt;symbol&gt; element or a cloned &lt;svg&gt; element in the referenced tree. In that case
 327     // we&#39;re always an inner &lt;svg&gt; element.
 328     if (isInShadowTree() &amp;&amp; parentOrShadowHostElement() &amp;&amp; parentOrShadowHostElement()-&gt;isSVGElement())
 329         return false;
 330 
 331     // Element may not be in the document, pretend we&#39;re outermost for viewport(), getCTM(), etc.
 332     if (!parentNode())
 333         return true;
 334 
 335     // We act like an outermost SVG element, if we&#39;re a direct child of a &lt;foreignObject&gt; element.
 336     if (parentNode()-&gt;hasTagName(SVGNames::foreignObjectTag))
 337         return true;
 338 
 339     // This is true whenever this is the outermost SVG, even if there are HTML elements outside it
 340     return !parentNode()-&gt;isSVGElement();
 341 }
 342 
<span class="line-modified"> 343 void SVGElement::reportAttributeParsingError(SVGParsingError error, const QualifiedName&amp; name, const AtomicString&amp; value)</span>
 344 {
 345     if (error == NoError)
 346         return;
 347 
 348     String errorString = &quot;&lt;&quot; + tagName() + &quot;&gt; attribute &quot; + name.toString() + &quot;=\&quot;&quot; + value + &quot;\&quot;&quot;;
 349     SVGDocumentExtensions&amp; extensions = document().accessSVGExtensions();
 350 
 351     if (error == NegativeValueForbiddenError) {
 352         extensions.reportError(&quot;Invalid negative value for &quot; + errorString);
 353         return;
 354     }
 355 
 356     if (error == ParsingAttributeFailedError) {
 357         extensions.reportError(&quot;Invalid value for &quot; + errorString);
 358         return;
 359     }
 360 
 361     ASSERT_NOT_REACHED();
 362 }
 363 
</pre>
<hr />
<pre>
 434     if (root-&gt;mode() != ShadowRootMode::UserAgent)
 435         return nullptr;
 436     auto* host = root-&gt;host();
 437     if (!is&lt;SVGUseElement&gt;(host))
 438         return nullptr;
 439     return &amp;downcast&lt;SVGUseElement&gt;(*host);
 440 }
 441 
 442 void SVGElement::setCorrespondingElement(SVGElement* correspondingElement)
 443 {
 444     if (m_svgRareData) {
 445         if (auto oldCorrespondingElement = makeRefPtr(m_svgRareData-&gt;correspondingElement()))
 446             oldCorrespondingElement-&gt;m_svgRareData-&gt;instances().remove(this);
 447     }
 448     if (m_svgRareData || correspondingElement)
 449         ensureSVGRareData().setCorrespondingElement(correspondingElement);
 450     if (correspondingElement)
 451         correspondingElement-&gt;ensureSVGRareData().instances().add(this);
 452 }
 453 
<span class="line-modified"> 454 void SVGElement::registerAttributes()</span>
<span class="line-removed"> 455 {</span>
<span class="line-removed"> 456     auto&amp; registry = attributeRegistry();</span>
<span class="line-removed"> 457     if (!registry.isEmpty())</span>
<span class="line-removed"> 458         return;</span>
<span class="line-removed"> 459     registry.registerAttribute&lt;HTMLNames::classAttr, &amp;SVGElement::m_className&gt;();</span>
<span class="line-removed"> 460 }</span>
<span class="line-removed"> 461 </span>
<span class="line-removed"> 462 void SVGElement::parseAttribute(const QualifiedName&amp; name, const AtomicString&amp; value)</span>
 463 {
 464     if (name == HTMLNames::classAttr) {
<span class="line-modified"> 465         m_className.setValue(value);</span>
 466         return;
 467     }
 468 
 469     if (name == HTMLNames::tabindexAttr) {
 470         if (value.isEmpty())
 471             clearTabIndexExplicitlyIfNeeded();
 472         else if (auto optionalTabIndex = parseHTMLInteger(value))
 473             setTabIndexExplicitly(optionalTabIndex.value());
 474         return;
 475     }
 476 
 477     auto&amp; eventName = HTMLElement::eventNameForEventHandlerAttribute(name);
 478     if (!eventName.isNull()) {
 479         setAttributeEventListener(eventName, name, value);
 480         return;
 481     }
 482 
 483     SVGLangSpace::parseAttribute(name, value);
 484 }
 485 
<span class="line-removed"> 486 Vector&lt;AnimatedPropertyType&gt; SVGElement::animatedPropertyTypesForAttribute(const QualifiedName&amp; attributeName)</span>
<span class="line-removed"> 487 {</span>
<span class="line-removed"> 488     auto types = animatedTypes(attributeName);</span>
<span class="line-removed"> 489     if (!types.isEmpty())</span>
<span class="line-removed"> 490         return types;</span>
<span class="line-removed"> 491 </span>
<span class="line-removed"> 492     {</span>
<span class="line-removed"> 493         auto&amp; map = attributeNameToAnimatedPropertyTypeMap();</span>
<span class="line-removed"> 494         auto it = map.find(attributeName.impl());</span>
<span class="line-removed"> 495         if (it != map.end()) {</span>
<span class="line-removed"> 496             types.append(it-&gt;value);</span>
<span class="line-removed"> 497             return types;</span>
<span class="line-removed"> 498         }</span>
<span class="line-removed"> 499     }</span>
<span class="line-removed"> 500 </span>
<span class="line-removed"> 501     {</span>
<span class="line-removed"> 502         auto&amp; map = cssPropertyWithSVGDOMNameToAnimatedPropertyTypeMap();</span>
<span class="line-removed"> 503         auto it = map.find(attributeName.impl());</span>
<span class="line-removed"> 504         if (it != map.end()) {</span>
<span class="line-removed"> 505             types.append(it-&gt;value);</span>
<span class="line-removed"> 506             return types;</span>
<span class="line-removed"> 507         }</span>
<span class="line-removed"> 508     }</span>
<span class="line-removed"> 509 </span>
<span class="line-removed"> 510     return types;</span>
<span class="line-removed"> 511 }</span>
<span class="line-removed"> 512 </span>
 513 bool SVGElement::haveLoadedRequiredResources()
 514 {
 515     for (auto&amp; child : childrenOfType&lt;SVGElement&gt;(*this)) {
 516         if (!child.haveLoadedRequiredResources())
 517             return false;
 518     }
 519     return true;
 520 }
 521 
<span class="line-modified"> 522 bool SVGElement::addEventListener(const AtomicString&amp; eventType, Ref&lt;EventListener&gt;&amp;&amp; listener, const AddEventListenerOptions&amp; options)</span>
 523 {
 524     // Add event listener to regular DOM element
 525     if (!Node::addEventListener(eventType, listener.copyRef(), options))
 526         return false;
 527 
 528     if (containingShadowRoot())
 529         return true;
 530 
 531     // Add event listener to all shadow tree DOM element instances
 532     ASSERT(!instanceUpdatesBlocked());
 533     for (auto* instance : instances()) {
 534         ASSERT(instance-&gt;correspondingElement() == this);
 535         bool result = instance-&gt;Node::addEventListener(eventType, listener.copyRef(), options);
 536         ASSERT_UNUSED(result, result);
 537     }
 538 
 539     return true;
 540 }
 541 
<span class="line-modified"> 542 bool SVGElement::removeEventListener(const AtomicString&amp; eventType, EventListener&amp; listener, const ListenerOptions&amp; options)</span>
 543 {
 544     if (containingShadowRoot())
 545         return Node::removeEventListener(eventType, listener, options);
 546 
 547     // EventTarget::removeEventListener creates a Ref around the given EventListener
 548     // object when creating a temporary RegisteredEventListener object used to look up the
 549     // event listener in a cache. If we want to be able to call removeEventListener() multiple
 550     // times on different nodes, we have to delay its immediate destruction, which would happen
 551     // after the first call below.
 552     Ref&lt;EventListener&gt; protector(listener);
 553 
 554     // Remove event listener from regular DOM element
 555     if (!Node::removeEventListener(eventType, listener, options))
 556         return false;
 557 
 558     // Remove event listener from all shadow tree DOM element instances
 559     ASSERT(!instanceUpdatesBlocked());
 560     for (auto&amp; instance : instances()) {
 561         ASSERT(instance-&gt;correspondingElement() == this);
 562 
</pre>
<hr />
<pre>
 661         return false;
 662     auto&amp; svgChild = downcast&lt;SVGElement&gt;(child);
 663 
 664     static const QualifiedName* const invalidTextContent[] {
 665 #if ENABLE(SVG_FONTS)
 666         &amp;SVGNames::altGlyphTag.get(),
 667 #endif
 668         &amp;SVGNames::textPathTag.get(),
 669         &amp;SVGNames::trefTag.get(),
 670         &amp;SVGNames::tspanTag.get(),
 671     };
 672     auto&amp; name = svgChild.localName();
 673     for (auto* tag : invalidTextContent) {
 674         if (name == tag-&gt;localName())
 675             return false;
 676     }
 677 
 678     return svgChild.isValid();
 679 }
 680 
<span class="line-modified"> 681 void SVGElement::attributeChanged(const QualifiedName&amp; name, const AtomicString&amp; oldValue, const AtomicString&amp; newValue, AttributeModificationReason)</span>
 682 {
 683     StyledElement::attributeChanged(name, oldValue, newValue);
 684 
 685     if (name == HTMLNames::idAttr)
 686         document().accessSVGExtensions().rebuildAllElementReferencesForTarget(*this);
 687 
 688     // Changes to the style attribute are processed lazily (see Element::getAttribute() and related methods),
 689     // so we don&#39;t want changes to the style attribute to result in extra work here except invalidateInstances().
 690     if (name == HTMLNames::styleAttr)
 691         invalidateInstances();
 692     else
 693         svgAttributeChanged(name);
 694 }
 695 
<span class="line-modified"> 696 void SVGElement::synchronizeAllAnimatedSVGAttribute(SVGElement* svgElement)</span>
 697 {
<span class="line-modified"> 698     ASSERT(svgElement-&gt;elementData());</span>
<span class="line-modified"> 699     ASSERT(svgElement-&gt;elementData()-&gt;animatedSVGAttributesAreDirty());</span>


 700 
<span class="line-modified"> 701     svgElement-&gt;synchronizeAttributes();</span>
<span class="line-modified"> 702     svgElement-&gt;elementData()-&gt;setAnimatedSVGAttributesAreDirty(false);</span>





 703 }
 704 
<span class="line-modified"> 705 void SVGElement::synchronizeAnimatedSVGAttribute(const QualifiedName&amp; name) const</span>
 706 {
<span class="line-modified"> 707     if (!elementData() || !elementData()-&gt;animatedSVGAttributesAreDirty())</span>
<span class="line-modified"> 708         return;</span>











 709 
<span class="line-modified"> 710     SVGElement* nonConstThis = const_cast&lt;SVGElement*&gt;(this);</span>
<span class="line-modified"> 711     if (name == anyQName())</span>
<span class="line-modified"> 712         synchronizeAllAnimatedSVGAttribute(nonConstThis);</span>






 713     else
<span class="line-modified"> 714         nonConstThis-&gt;synchronizeAttribute(name);</span>






































 715 }
 716 
 717 Optional&lt;ElementStyle&gt; SVGElement::resolveCustomStyle(const RenderStyle&amp; parentStyle, const RenderStyle*)
 718 {
 719     // If the element is in a &lt;use&gt; tree we get the style from the definition tree.
 720     if (auto styleElement = makeRefPtr(this-&gt;correspondingElement())) {
 721         Optional&lt;ElementStyle&gt; style = styleElement-&gt;resolveStyle(&amp;parentStyle);
 722         StyleResolver::adjustSVGElementStyle(*this, *style-&gt;renderStyle);
 723         return style;
 724     }
 725 
 726     return resolveStyle(&amp;parentStyle);
 727 }
 728 
 729 MutableStyleProperties* SVGElement::animatedSMILStyleProperties() const
 730 {
 731     if (m_svgRareData)
 732         return m_svgRareData-&gt;animatedSMILStyleProperties();
 733     return 0;
 734 }
</pre>
<hr />
<pre>
 741 void SVGElement::setUseOverrideComputedStyle(bool value)
 742 {
 743     if (m_svgRareData)
 744         m_svgRareData-&gt;setUseOverrideComputedStyle(value);
 745 }
 746 
 747 const RenderStyle* SVGElement::computedStyle(PseudoId pseudoElementSpecifier)
 748 {
 749     if (!m_svgRareData || !m_svgRareData-&gt;useOverrideComputedStyle())
 750         return Element::computedStyle(pseudoElementSpecifier);
 751 
 752     const RenderStyle* parentStyle = nullptr;
 753     if (auto parent = makeRefPtr(parentOrShadowHostElement())) {
 754         if (auto renderer = parent-&gt;renderer())
 755             parentStyle = &amp;renderer-&gt;style();
 756     }
 757 
 758     return m_svgRareData-&gt;overrideComputedStyle(*this, parentStyle);
 759 }
 760 
<span class="line-modified"> 761 QualifiedName SVGElement::animatableAttributeForName(const AtomicString&amp; localName)</span>
 762 {
 763     static const auto animatableAttributes = makeNeverDestroyed([] {
 764         static const QualifiedName* const names[] = {
 765             &amp;HTMLNames::classAttr.get(),
 766             &amp;SVGNames::amplitudeAttr.get(),
 767             &amp;SVGNames::azimuthAttr.get(),
 768             &amp;SVGNames::baseFrequencyAttr.get(),
 769             &amp;SVGNames::biasAttr.get(),
 770             &amp;SVGNames::clipPathUnitsAttr.get(),
 771             &amp;SVGNames::cxAttr.get(),
 772             &amp;SVGNames::cyAttr.get(),
 773             &amp;SVGNames::diffuseConstantAttr.get(),
 774             &amp;SVGNames::divisorAttr.get(),
 775             &amp;SVGNames::dxAttr.get(),
 776             &amp;SVGNames::dyAttr.get(),
 777             &amp;SVGNames::edgeModeAttr.get(),
 778             &amp;SVGNames::elevationAttr.get(),
 779             &amp;SVGNames::exponentAttr.get(),
 780             &amp;SVGNames::externalResourcesRequiredAttr.get(),
 781             &amp;SVGNames::filterUnitsAttr.get(),
</pre>
<hr />
<pre>
 839             &amp;SVGNames::tableValuesAttr.get(),
 840             &amp;SVGNames::targetAttr.get(),
 841             &amp;SVGNames::targetXAttr.get(),
 842             &amp;SVGNames::targetYAttr.get(),
 843             &amp;SVGNames::transformAttr.get(),
 844             &amp;SVGNames::typeAttr.get(),
 845             &amp;SVGNames::valuesAttr.get(),
 846             &amp;SVGNames::viewBoxAttr.get(),
 847             &amp;SVGNames::widthAttr.get(),
 848             &amp;SVGNames::x1Attr.get(),
 849             &amp;SVGNames::x2Attr.get(),
 850             &amp;SVGNames::xAttr.get(),
 851             &amp;SVGNames::xChannelSelectorAttr.get(),
 852             &amp;SVGNames::y1Attr.get(),
 853             &amp;SVGNames::y2Attr.get(),
 854             &amp;SVGNames::yAttr.get(),
 855             &amp;SVGNames::yChannelSelectorAttr.get(),
 856             &amp;SVGNames::zAttr.get(),
 857             &amp;SVGNames::hrefAttr.get(),
 858         };
<span class="line-modified"> 859         HashMap&lt;AtomicString, QualifiedName&gt; map;</span>
 860         for (auto&amp; name : names) {
 861             auto addResult = map.add(name-&gt;localName(), *name);
 862             ASSERT_UNUSED(addResult, addResult.isNewEntry);
 863         }
 864         return map;
 865     }());
 866     return animatableAttributes.get().get(localName);
 867 }
 868 
 869 #ifndef NDEBUG
 870 
 871 bool SVGElement::isAnimatableAttribute(const QualifiedName&amp; name) const
 872 {
 873     if (animatableAttributeForName(name.localName()) == name)
 874         return !filterOutAnimatableAttribute(name);
 875     return false;
 876 }
 877 
 878 bool SVGElement::filterOutAnimatableAttribute(const QualifiedName&amp;) const
 879 {
</pre>
<hr />
<pre>
 898     // http://www.w3.org/TR/SVG/extend.html#PrivateData
 899     // Prevent anything other than SVG renderers from appearing in our render tree
 900     // Spec: SVG allows inclusion of elements from foreign namespaces anywhere
 901     // with the SVG content. In general, the SVG user agent will include the unknown
 902     // elements in the DOM but will otherwise ignore unknown elements.
 903     if (!parentOrShadowHostElement() || parentOrShadowHostElement()-&gt;isSVGElement())
 904         return StyledElement::rendererIsNeeded(style);
 905 
 906     return false;
 907 }
 908 
 909 CSSPropertyID SVGElement::cssPropertyIdForSVGAttributeName(const QualifiedName&amp; attrName)
 910 {
 911     if (!attrName.namespaceURI().isNull())
 912         return CSSPropertyInvalid;
 913 
 914     static const auto properties = makeNeverDestroyed(createAttributeNameToCSSPropertyIDMap());
 915     return properties.get().get(attrName.localName().impl());
 916 }
 917 
<span class="line-removed"> 918 bool SVGElement::isAnimatableCSSProperty(const QualifiedName&amp; attributeName)</span>
<span class="line-removed"> 919 {</span>
<span class="line-removed"> 920     return attributeNameToAnimatedPropertyTypeMap().contains(attributeName.impl())</span>
<span class="line-removed"> 921         || cssPropertyWithSVGDOMNameToAnimatedPropertyTypeMap().contains(attributeName.impl());</span>
<span class="line-removed"> 922 }</span>
<span class="line-removed"> 923 </span>
<span class="line-removed"> 924 bool SVGElement::isPresentationAttributeWithSVGDOM(const QualifiedName&amp; attributeName)</span>
<span class="line-removed"> 925 {</span>
<span class="line-removed"> 926     return !animatedTypes(attributeName).isEmpty();</span>
<span class="line-removed"> 927 }</span>
<span class="line-removed"> 928 </span>
 929 bool SVGElement::isPresentationAttribute(const QualifiedName&amp; name) const
 930 {
 931     if (cssPropertyIdForSVGAttributeName(name) &gt; 0)
 932         return true;
 933     return StyledElement::isPresentationAttribute(name);
 934 }
 935 
<span class="line-modified"> 936 void SVGElement::collectStyleForPresentationAttribute(const QualifiedName&amp; name, const AtomicString&amp; value, MutableStyleProperties&amp; style)</span>
 937 {
 938     CSSPropertyID propertyID = cssPropertyIdForSVGAttributeName(name);
 939     if (propertyID &gt; 0)
 940         addPropertyToPresentationAttributeStyle(style, propertyID, value);
 941 }
 942 
 943 void SVGElement::svgAttributeChanged(const QualifiedName&amp; attrName)
 944 {
 945     CSSPropertyID propId = cssPropertyIdForSVGAttributeName(attrName);
 946     if (propId &gt; 0) {
 947         invalidateInstances();
 948         return;
 949     }
 950 
 951     if (attrName == HTMLNames::classAttr) {
 952         classAttributeChanged(className());
 953         invalidateInstances();
 954         return;
 955     }
 956 
</pre>
<hr />
<pre>
1067         }
1068 
1069         m_elementsWithRelativeLengths.remove(element);
1070     }
1071 
1072     if (!element-&gt;isSVGGraphicsElement())
1073         return;
1074 
1075     // Find first styled parent node, and notify it that we&#39;ve changed our relative length state.
1076     auto node = makeRefPtr(parentNode());
1077     while (node) {
1078         if (!node-&gt;isSVGElement())
1079             break;
1080 
1081         // Register us in the parent element map.
1082         downcast&lt;SVGElement&gt;(*node).updateRelativeLengthsInformation(hasRelativeLengths, this);
1083         break;
1084     }
1085 }
1086 
<span class="line-removed">1087 bool SVGElement::hasFocusEventListeners() const</span>
<span class="line-removed">1088 {</span>
<span class="line-removed">1089     Element* eventTarget = const_cast&lt;SVGElement*&gt;(this);</span>
<span class="line-removed">1090     return eventTarget-&gt;hasEventListeners(eventNames().focusinEvent)</span>
<span class="line-removed">1091         || eventTarget-&gt;hasEventListeners(eventNames().focusoutEvent)</span>
<span class="line-removed">1092         || eventTarget-&gt;hasEventListeners(eventNames().focusEvent)</span>
<span class="line-removed">1093         || eventTarget-&gt;hasEventListeners(eventNames().blurEvent);</span>
<span class="line-removed">1094 }</span>
<span class="line-removed">1095 </span>
<span class="line-removed">1096 bool SVGElement::isMouseFocusable() const</span>
<span class="line-removed">1097 {</span>
<span class="line-removed">1098     if (!isFocusable())</span>
<span class="line-removed">1099         return false;</span>
<span class="line-removed">1100     Element* eventTarget = const_cast&lt;SVGElement*&gt;(this);</span>
<span class="line-removed">1101     return hasFocusEventListeners()</span>
<span class="line-removed">1102         || eventTarget-&gt;hasEventListeners(eventNames().keydownEvent)</span>
<span class="line-removed">1103         || eventTarget-&gt;hasEventListeners(eventNames().keyupEvent)</span>
<span class="line-removed">1104         || eventTarget-&gt;hasEventListeners(eventNames().keypressEvent);</span>
<span class="line-removed">1105 }</span>
<span class="line-removed">1106 </span>
1107 void SVGElement::accessKeyAction(bool sendMouseEvents)
1108 {
1109     dispatchSimulatedClick(0, sendMouseEvents ? SendMouseUpDownEvents : SendNoEvents);
1110 }
1111 
1112 void SVGElement::invalidateInstances()
1113 {
1114     if (instanceUpdatesBlocked())
1115         return;
1116 
1117     auto&amp; instances = this-&gt;instances();
1118     while (!instances.isEmpty()) {
1119         auto instance = makeRefPtr(*instances.begin());
1120         if (auto useElement = instance-&gt;correspondingUseElement())
1121             useElement-&gt;invalidateShadowTree();
1122         instance-&gt;setCorrespondingElement(nullptr);
1123     } while (!instances.isEmpty());
1124 }
1125 
1126 }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
   2  * Copyright (C) 2004, 2005, 2006, 2007, 2008 Nikolas Zimmermann &lt;zimmermann@kde.org&gt;
   3  * Copyright (C) 2004, 2005, 2006, 2008 Rob Buis &lt;buis@kde.org&gt;
<span class="line-modified">   4  * Copyright (C) 2008-2019 Apple Inc. All rights reserved.</span>
   5  * Copyright (C) 2008 Alp Toker &lt;alp@atoker.com&gt;
   6  * Copyright (C) 2009 Cameron McCormack &lt;cam@mcc.id.au&gt;
   7  * Copyright (C) 2013 Samsung Electronics. All rights reserved.
   8  * Copyright (C) 2014 Adobe Systems Incorporated. All rights reserved.
   9  *
  10  * This library is free software; you can redistribute it and/or
  11  * modify it under the terms of the GNU Library General Public
  12  * License as published by the Free Software Foundation; either
  13  * version 2 of the License, or (at your option) any later version.
  14  *
  15  * This library is distributed in the hope that it will be useful,
  16  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  17  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  18  * Library General Public License for more details.
  19  *
  20  * You should have received a copy of the GNU Library General Public License
  21  * along with this library; see the file COPYING.LIB.  If not, write to
  22  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  23  * Boston, MA 02110-1301, USA.
  24  */
</pre>
<hr />
<pre>
  27 #include &quot;SVGElement.h&quot;
  28 
  29 #include &quot;CSSPropertyParser.h&quot;
  30 #include &quot;DeprecatedCSSOMValue.h&quot;
  31 #include &quot;Document.h&quot;
  32 #include &quot;ElementIterator.h&quot;
  33 #include &quot;Event.h&quot;
  34 #include &quot;EventNames.h&quot;
  35 #include &quot;HTMLElement.h&quot;
  36 #include &quot;HTMLNames.h&quot;
  37 #include &quot;HTMLParserIdioms.h&quot;
  38 #include &quot;RenderObject.h&quot;
  39 #include &quot;RenderSVGResource.h&quot;
  40 #include &quot;RenderSVGResourceFilter.h&quot;
  41 #include &quot;RenderSVGResourceMasker.h&quot;
  42 #include &quot;SVGDocumentExtensions.h&quot;
  43 #include &quot;SVGElementRareData.h&quot;
  44 #include &quot;SVGGraphicsElement.h&quot;
  45 #include &quot;SVGImageElement.h&quot;
  46 #include &quot;SVGNames.h&quot;
<span class="line-added">  47 #include &quot;SVGPropertyAnimatorFactory.h&quot;</span>
  48 #include &quot;SVGRenderStyle.h&quot;
  49 #include &quot;SVGRenderSupport.h&quot;
  50 #include &quot;SVGSVGElement.h&quot;
  51 #include &quot;SVGTitleElement.h&quot;
  52 #include &quot;SVGUseElement.h&quot;
  53 #include &quot;ShadowRoot.h&quot;
  54 #include &quot;XMLNames.h&quot;
  55 #include &lt;wtf/Assertions.h&gt;
  56 #include &lt;wtf/HashMap.h&gt;
  57 #include &lt;wtf/IsoMallocInlines.h&gt;
  58 #include &lt;wtf/NeverDestroyed.h&gt;
  59 #include &lt;wtf/StdLibExtras.h&gt;
  60 #include &lt;wtf/text/WTFString.h&gt;
  61 
  62 
  63 namespace WebCore {
  64 
  65 WTF_MAKE_ISO_ALLOCATED_IMPL(SVGElement);
  66 
<span class="line-modified">  67 static NEVER_INLINE HashMap&lt;AtomStringImpl*, CSSPropertyID&gt; createAttributeNameToCSSPropertyIDMap()</span>
  68 {
  69     using namespace HTMLNames;
  70     using namespace SVGNames;
  71 
  72     // This list should include all base CSS and SVG CSS properties which are exposed as SVG XML attributes.
  73     static const QualifiedName* const attributeNames[] = {
  74         &amp;alignment_baselineAttr.get(),
  75         &amp;baseline_shiftAttr.get(),
  76         &amp;buffered_renderingAttr.get(),
  77         &amp;clipAttr.get(),
  78         &amp;clip_pathAttr.get(),
  79         &amp;clip_ruleAttr.get(),
  80         &amp;SVGNames::colorAttr.get(),
  81         &amp;color_interpolationAttr.get(),
  82         &amp;color_interpolation_filtersAttr.get(),
  83         &amp;color_profileAttr.get(),
  84         &amp;color_renderingAttr.get(),
  85         &amp;cursorAttr.get(),
  86         &amp;cxAttr.get(),
  87         &amp;cyAttr.get(),
</pre>
<hr />
<pre>
 127         &amp;stroke_dasharrayAttr.get(),
 128         &amp;stroke_dashoffsetAttr.get(),
 129         &amp;stroke_linecapAttr.get(),
 130         &amp;stroke_linejoinAttr.get(),
 131         &amp;stroke_miterlimitAttr.get(),
 132         &amp;stroke_opacityAttr.get(),
 133         &amp;stroke_widthAttr.get(),
 134         &amp;text_anchorAttr.get(),
 135         &amp;text_decorationAttr.get(),
 136         &amp;text_renderingAttr.get(),
 137         &amp;unicode_bidiAttr.get(),
 138         &amp;vector_effectAttr.get(),
 139         &amp;visibilityAttr.get(),
 140         &amp;SVGNames::widthAttr.get(),
 141         &amp;word_spacingAttr.get(),
 142         &amp;writing_modeAttr.get(),
 143         &amp;xAttr.get(),
 144         &amp;yAttr.get(),
 145     };
 146 
<span class="line-modified"> 147     HashMap&lt;AtomStringImpl*, CSSPropertyID&gt; map;</span>
 148 
 149     for (auto&amp; name : attributeNames) {
<span class="line-modified"> 150         const AtomString&amp; localName = name-&gt;localName();</span>
 151         map.add(localName.impl(), cssPropertyID(localName));
 152     }
 153 
 154     // FIXME: When CSS supports &quot;transform-origin&quot; this special case can be removed,
 155     // and we can add transform_originAttr to the table above instead.
 156     map.add(transform_originAttr-&gt;localName().impl(), CSSPropertyTransformOrigin);
 157 
 158     return map;
 159 }
 160 



















































































































 161 SVGElement::SVGElement(const QualifiedName&amp; tagName, Document&amp; document)
 162     : StyledElement(tagName, document, CreateSVGElement)
 163     , SVGLangSpace(this)
<span class="line-added"> 164     , m_propertyAnimatorFactory(makeUnique&lt;SVGPropertyAnimatorFactory&gt;())</span>
 165 {
<span class="line-modified"> 166     static std::once_flag onceFlag;</span>
<span class="line-added"> 167     std::call_once(onceFlag, [] {</span>
<span class="line-added"> 168         PropertyRegistry::registerProperty&lt;HTMLNames::classAttr, &amp;SVGElement::m_className&gt;();</span>
<span class="line-added"> 169     });</span>
 170 }
 171 
 172 SVGElement::~SVGElement()
 173 {
 174     if (m_svgRareData) {
 175         for (SVGElement* instance : m_svgRareData-&gt;instances())
 176             instance-&gt;m_svgRareData-&gt;setCorrespondingElement(nullptr);
 177         if (auto correspondingElement = makeRefPtr(m_svgRareData-&gt;correspondingElement()))
 178             correspondingElement-&gt;m_svgRareData-&gt;instances().remove(this);
 179 
 180         m_svgRareData = nullptr;
 181     }
 182     document().accessSVGExtensions().rebuildAllElementReferencesForTarget(*this);
 183     document().accessSVGExtensions().removeAllElementReferencesForTarget(*this);
 184 }
 185 







 186 void SVGElement::willRecalcStyle(Style::Change change)
 187 {
 188     if (!m_svgRareData || styleResolutionShouldRecompositeLayer())
 189         return;
 190     // If the style changes because of a regular property change (not induced by SMIL animations themselves)
 191     // reset the &quot;computed style without SMIL style properties&quot;, so the base value change gets reflected.
 192     if (change &gt; Style::NoChange || needsStyleRecalc())
 193         m_svgRareData-&gt;setNeedsOverrideComputedStyleUpdate();
 194 }
 195 
 196 SVGElementRareData&amp; SVGElement::ensureSVGRareData()
 197 {
 198     if (!m_svgRareData)
<span class="line-modified"> 199         m_svgRareData = makeUnique&lt;SVGElementRareData&gt;();</span>
 200     return *m_svgRareData;
 201 }
 202 
 203 bool SVGElement::isOutermostSVGSVGElement() const
 204 {
 205     if (!is&lt;SVGSVGElement&gt;(*this))
 206         return false;
 207 
 208     // If we&#39;re living in a shadow tree, we&#39;re a &lt;svg&gt; element that got created as replacement
 209     // for a &lt;symbol&gt; element or a cloned &lt;svg&gt; element in the referenced tree. In that case
 210     // we&#39;re always an inner &lt;svg&gt; element.
 211     if (isInShadowTree() &amp;&amp; parentOrShadowHostElement() &amp;&amp; parentOrShadowHostElement()-&gt;isSVGElement())
 212         return false;
 213 
 214     // Element may not be in the document, pretend we&#39;re outermost for viewport(), getCTM(), etc.
 215     if (!parentNode())
 216         return true;
 217 
 218     // We act like an outermost SVG element, if we&#39;re a direct child of a &lt;foreignObject&gt; element.
 219     if (parentNode()-&gt;hasTagName(SVGNames::foreignObjectTag))
 220         return true;
 221 
 222     // This is true whenever this is the outermost SVG, even if there are HTML elements outside it
 223     return !parentNode()-&gt;isSVGElement();
 224 }
 225 
<span class="line-modified"> 226 void SVGElement::reportAttributeParsingError(SVGParsingError error, const QualifiedName&amp; name, const AtomString&amp; value)</span>
 227 {
 228     if (error == NoError)
 229         return;
 230 
 231     String errorString = &quot;&lt;&quot; + tagName() + &quot;&gt; attribute &quot; + name.toString() + &quot;=\&quot;&quot; + value + &quot;\&quot;&quot;;
 232     SVGDocumentExtensions&amp; extensions = document().accessSVGExtensions();
 233 
 234     if (error == NegativeValueForbiddenError) {
 235         extensions.reportError(&quot;Invalid negative value for &quot; + errorString);
 236         return;
 237     }
 238 
 239     if (error == ParsingAttributeFailedError) {
 240         extensions.reportError(&quot;Invalid value for &quot; + errorString);
 241         return;
 242     }
 243 
 244     ASSERT_NOT_REACHED();
 245 }
 246 
</pre>
<hr />
<pre>
 317     if (root-&gt;mode() != ShadowRootMode::UserAgent)
 318         return nullptr;
 319     auto* host = root-&gt;host();
 320     if (!is&lt;SVGUseElement&gt;(host))
 321         return nullptr;
 322     return &amp;downcast&lt;SVGUseElement&gt;(*host);
 323 }
 324 
 325 void SVGElement::setCorrespondingElement(SVGElement* correspondingElement)
 326 {
 327     if (m_svgRareData) {
 328         if (auto oldCorrespondingElement = makeRefPtr(m_svgRareData-&gt;correspondingElement()))
 329             oldCorrespondingElement-&gt;m_svgRareData-&gt;instances().remove(this);
 330     }
 331     if (m_svgRareData || correspondingElement)
 332         ensureSVGRareData().setCorrespondingElement(correspondingElement);
 333     if (correspondingElement)
 334         correspondingElement-&gt;ensureSVGRareData().instances().add(this);
 335 }
 336 
<span class="line-modified"> 337 void SVGElement::parseAttribute(const QualifiedName&amp; name, const AtomString&amp; value)</span>








 338 {
 339     if (name == HTMLNames::classAttr) {
<span class="line-modified"> 340         m_className-&gt;setBaseValInternal(value);</span>
 341         return;
 342     }
 343 
 344     if (name == HTMLNames::tabindexAttr) {
 345         if (value.isEmpty())
 346             clearTabIndexExplicitlyIfNeeded();
 347         else if (auto optionalTabIndex = parseHTMLInteger(value))
 348             setTabIndexExplicitly(optionalTabIndex.value());
 349         return;
 350     }
 351 
 352     auto&amp; eventName = HTMLElement::eventNameForEventHandlerAttribute(name);
 353     if (!eventName.isNull()) {
 354         setAttributeEventListener(eventName, name, value);
 355         return;
 356     }
 357 
 358     SVGLangSpace::parseAttribute(name, value);
 359 }
 360 



























 361 bool SVGElement::haveLoadedRequiredResources()
 362 {
 363     for (auto&amp; child : childrenOfType&lt;SVGElement&gt;(*this)) {
 364         if (!child.haveLoadedRequiredResources())
 365             return false;
 366     }
 367     return true;
 368 }
 369 
<span class="line-modified"> 370 bool SVGElement::addEventListener(const AtomString&amp; eventType, Ref&lt;EventListener&gt;&amp;&amp; listener, const AddEventListenerOptions&amp; options)</span>
 371 {
 372     // Add event listener to regular DOM element
 373     if (!Node::addEventListener(eventType, listener.copyRef(), options))
 374         return false;
 375 
 376     if (containingShadowRoot())
 377         return true;
 378 
 379     // Add event listener to all shadow tree DOM element instances
 380     ASSERT(!instanceUpdatesBlocked());
 381     for (auto* instance : instances()) {
 382         ASSERT(instance-&gt;correspondingElement() == this);
 383         bool result = instance-&gt;Node::addEventListener(eventType, listener.copyRef(), options);
 384         ASSERT_UNUSED(result, result);
 385     }
 386 
 387     return true;
 388 }
 389 
<span class="line-modified"> 390 bool SVGElement::removeEventListener(const AtomString&amp; eventType, EventListener&amp; listener, const ListenerOptions&amp; options)</span>
 391 {
 392     if (containingShadowRoot())
 393         return Node::removeEventListener(eventType, listener, options);
 394 
 395     // EventTarget::removeEventListener creates a Ref around the given EventListener
 396     // object when creating a temporary RegisteredEventListener object used to look up the
 397     // event listener in a cache. If we want to be able to call removeEventListener() multiple
 398     // times on different nodes, we have to delay its immediate destruction, which would happen
 399     // after the first call below.
 400     Ref&lt;EventListener&gt; protector(listener);
 401 
 402     // Remove event listener from regular DOM element
 403     if (!Node::removeEventListener(eventType, listener, options))
 404         return false;
 405 
 406     // Remove event listener from all shadow tree DOM element instances
 407     ASSERT(!instanceUpdatesBlocked());
 408     for (auto&amp; instance : instances()) {
 409         ASSERT(instance-&gt;correspondingElement() == this);
 410 
</pre>
<hr />
<pre>
 509         return false;
 510     auto&amp; svgChild = downcast&lt;SVGElement&gt;(child);
 511 
 512     static const QualifiedName* const invalidTextContent[] {
 513 #if ENABLE(SVG_FONTS)
 514         &amp;SVGNames::altGlyphTag.get(),
 515 #endif
 516         &amp;SVGNames::textPathTag.get(),
 517         &amp;SVGNames::trefTag.get(),
 518         &amp;SVGNames::tspanTag.get(),
 519     };
 520     auto&amp; name = svgChild.localName();
 521     for (auto* tag : invalidTextContent) {
 522         if (name == tag-&gt;localName())
 523             return false;
 524     }
 525 
 526     return svgChild.isValid();
 527 }
 528 
<span class="line-modified"> 529 void SVGElement::attributeChanged(const QualifiedName&amp; name, const AtomString&amp; oldValue, const AtomString&amp; newValue, AttributeModificationReason)</span>
 530 {
 531     StyledElement::attributeChanged(name, oldValue, newValue);
 532 
 533     if (name == HTMLNames::idAttr)
 534         document().accessSVGExtensions().rebuildAllElementReferencesForTarget(*this);
 535 
 536     // Changes to the style attribute are processed lazily (see Element::getAttribute() and related methods),
 537     // so we don&#39;t want changes to the style attribute to result in extra work here except invalidateInstances().
 538     if (name == HTMLNames::styleAttr)
 539         invalidateInstances();
 540     else
 541         svgAttributeChanged(name);
 542 }
 543 
<span class="line-modified"> 544 void SVGElement::synchronizeAttribute(const QualifiedName&amp; name)</span>
 545 {
<span class="line-modified"> 546     // If the value of the property has changed, serialize the new value to the attribute.</span>
<span class="line-modified"> 547     if (auto value = propertyRegistry().synchronize(name))</span>
<span class="line-added"> 548         setSynchronizedLazyAttribute(name, *value);</span>
<span class="line-added"> 549 }</span>
 550 
<span class="line-modified"> 551 void SVGElement::synchronizeAllAttributes()</span>
<span class="line-modified"> 552 {</span>
<span class="line-added"> 553     // SVGPropertyRegistry::synchronizeAllAttributes() returns the new values of</span>
<span class="line-added"> 554     // the properties which have changed but not committed yet.</span>
<span class="line-added"> 555     auto map = propertyRegistry().synchronizeAllAttributes();</span>
<span class="line-added"> 556     for (const auto&amp; entry : map)</span>
<span class="line-added"> 557         setSynchronizedLazyAttribute(entry.key, entry.value);</span>
 558 }
 559 
<span class="line-modified"> 560 void SVGElement::synchronizeAllAnimatedSVGAttribute(SVGElement&amp; svgElement)</span>
 561 {
<span class="line-modified"> 562     svgElement.synchronizeAllAttributes();</span>
<span class="line-modified"> 563 }</span>
<span class="line-added"> 564 </span>
<span class="line-added"> 565 void SVGElement::commitPropertyChange(SVGProperty* property)</span>
<span class="line-added"> 566 {</span>
<span class="line-added"> 567     // We want to dirty the top-level property when a descendant changes. For example</span>
<span class="line-added"> 568     // a change in an SVGLength item in SVGLengthList should set the dirty flag on</span>
<span class="line-added"> 569     // SVGLengthList and not the SVGLength.</span>
<span class="line-added"> 570     property-&gt;setDirty();</span>
<span class="line-added"> 571 </span>
<span class="line-added"> 572     invalidateSVGAttributes();</span>
<span class="line-added"> 573     svgAttributeChanged(propertyRegistry().propertyAttributeName(*property));</span>
<span class="line-added"> 574 }</span>
 575 
<span class="line-modified"> 576 void SVGElement::commitPropertyChange(SVGAnimatedProperty&amp; animatedProperty)</span>
<span class="line-modified"> 577 {</span>
<span class="line-modified"> 578     QualifiedName attributeName = propertyRegistry().animatedPropertyAttributeName(animatedProperty);</span>
<span class="line-added"> 579     ASSERT(attributeName != nullQName());</span>
<span class="line-added"> 580 </span>
<span class="line-added"> 581     // A change in a style property, e.g SVGRectElement::x should be serialized to</span>
<span class="line-added"> 582     // the attribute immediately. Otherwise it is okay to be lazy in this regard.</span>
<span class="line-added"> 583     if (!propertyRegistry().isAnimatedStylePropertyAttribute(attributeName))</span>
<span class="line-added"> 584         animatedProperty.setDirty();</span>
 585     else
<span class="line-modified"> 586         setSynchronizedLazyAttribute(attributeName, animatedProperty.baseValAsString());</span>
<span class="line-added"> 587 </span>
<span class="line-added"> 588     invalidateSVGAttributes();</span>
<span class="line-added"> 589     svgAttributeChanged(attributeName);</span>
<span class="line-added"> 590 }</span>
<span class="line-added"> 591 </span>
<span class="line-added"> 592 bool SVGElement::isAnimatedPropertyAttribute(const QualifiedName&amp; attributeName) const</span>
<span class="line-added"> 593 {</span>
<span class="line-added"> 594     return propertyRegistry().isAnimatedPropertyAttribute(attributeName);</span>
<span class="line-added"> 595 }</span>
<span class="line-added"> 596 </span>
<span class="line-added"> 597 bool SVGElement::isAnimatedAttribute(const QualifiedName&amp; attributeName) const</span>
<span class="line-added"> 598 {</span>
<span class="line-added"> 599     return SVGPropertyAnimatorFactory::isKnownAttribute(attributeName) || isAnimatedPropertyAttribute(attributeName);</span>
<span class="line-added"> 600 }</span>
<span class="line-added"> 601 </span>
<span class="line-added"> 602 bool SVGElement::isAnimatedStyleAttribute(const QualifiedName&amp; attributeName) const</span>
<span class="line-added"> 603 {</span>
<span class="line-added"> 604     return SVGPropertyAnimatorFactory::isKnownAttribute(attributeName) || propertyRegistry().isAnimatedStylePropertyAttribute(attributeName);</span>
<span class="line-added"> 605 }</span>
<span class="line-added"> 606 </span>
<span class="line-added"> 607 RefPtr&lt;SVGAttributeAnimator&gt; SVGElement::createAnimator(const QualifiedName&amp; attributeName, AnimationMode animationMode, CalcMode calcMode, bool isAccumulated, bool isAdditive)</span>
<span class="line-added"> 608 {</span>
<span class="line-added"> 609     // Property animator, e.g. &quot;fill&quot; or &quot;fill-opacity&quot;.</span>
<span class="line-added"> 610     if (auto animator = propertyAnimatorFactory().createAnimator(attributeName, animationMode, calcMode, isAccumulated, isAdditive))</span>
<span class="line-added"> 611         return animator;</span>
<span class="line-added"> 612 </span>
<span class="line-added"> 613     // Animated property animator.</span>
<span class="line-added"> 614     auto animator = propertyRegistry().createAnimator(attributeName, animationMode, calcMode, isAccumulated, isAdditive);</span>
<span class="line-added"> 615     if (!animator)</span>
<span class="line-added"> 616         return animator;</span>
<span class="line-added"> 617     for (auto* instance : instances())</span>
<span class="line-added"> 618         instance-&gt;propertyRegistry().appendAnimatedInstance(attributeName, *animator);</span>
<span class="line-added"> 619     return animator;</span>
<span class="line-added"> 620 }</span>
<span class="line-added"> 621 </span>
<span class="line-added"> 622 void SVGElement::animatorWillBeDeleted(const QualifiedName&amp; attributeName)</span>
<span class="line-added"> 623 {</span>
<span class="line-added"> 624     propertyAnimatorFactory().animatorWillBeDeleted(attributeName);</span>
 625 }
 626 
 627 Optional&lt;ElementStyle&gt; SVGElement::resolveCustomStyle(const RenderStyle&amp; parentStyle, const RenderStyle*)
 628 {
 629     // If the element is in a &lt;use&gt; tree we get the style from the definition tree.
 630     if (auto styleElement = makeRefPtr(this-&gt;correspondingElement())) {
 631         Optional&lt;ElementStyle&gt; style = styleElement-&gt;resolveStyle(&amp;parentStyle);
 632         StyleResolver::adjustSVGElementStyle(*this, *style-&gt;renderStyle);
 633         return style;
 634     }
 635 
 636     return resolveStyle(&amp;parentStyle);
 637 }
 638 
 639 MutableStyleProperties* SVGElement::animatedSMILStyleProperties() const
 640 {
 641     if (m_svgRareData)
 642         return m_svgRareData-&gt;animatedSMILStyleProperties();
 643     return 0;
 644 }
</pre>
<hr />
<pre>
 651 void SVGElement::setUseOverrideComputedStyle(bool value)
 652 {
 653     if (m_svgRareData)
 654         m_svgRareData-&gt;setUseOverrideComputedStyle(value);
 655 }
 656 
 657 const RenderStyle* SVGElement::computedStyle(PseudoId pseudoElementSpecifier)
 658 {
 659     if (!m_svgRareData || !m_svgRareData-&gt;useOverrideComputedStyle())
 660         return Element::computedStyle(pseudoElementSpecifier);
 661 
 662     const RenderStyle* parentStyle = nullptr;
 663     if (auto parent = makeRefPtr(parentOrShadowHostElement())) {
 664         if (auto renderer = parent-&gt;renderer())
 665             parentStyle = &amp;renderer-&gt;style();
 666     }
 667 
 668     return m_svgRareData-&gt;overrideComputedStyle(*this, parentStyle);
 669 }
 670 
<span class="line-modified"> 671 QualifiedName SVGElement::animatableAttributeForName(const AtomString&amp; localName)</span>
 672 {
 673     static const auto animatableAttributes = makeNeverDestroyed([] {
 674         static const QualifiedName* const names[] = {
 675             &amp;HTMLNames::classAttr.get(),
 676             &amp;SVGNames::amplitudeAttr.get(),
 677             &amp;SVGNames::azimuthAttr.get(),
 678             &amp;SVGNames::baseFrequencyAttr.get(),
 679             &amp;SVGNames::biasAttr.get(),
 680             &amp;SVGNames::clipPathUnitsAttr.get(),
 681             &amp;SVGNames::cxAttr.get(),
 682             &amp;SVGNames::cyAttr.get(),
 683             &amp;SVGNames::diffuseConstantAttr.get(),
 684             &amp;SVGNames::divisorAttr.get(),
 685             &amp;SVGNames::dxAttr.get(),
 686             &amp;SVGNames::dyAttr.get(),
 687             &amp;SVGNames::edgeModeAttr.get(),
 688             &amp;SVGNames::elevationAttr.get(),
 689             &amp;SVGNames::exponentAttr.get(),
 690             &amp;SVGNames::externalResourcesRequiredAttr.get(),
 691             &amp;SVGNames::filterUnitsAttr.get(),
</pre>
<hr />
<pre>
 749             &amp;SVGNames::tableValuesAttr.get(),
 750             &amp;SVGNames::targetAttr.get(),
 751             &amp;SVGNames::targetXAttr.get(),
 752             &amp;SVGNames::targetYAttr.get(),
 753             &amp;SVGNames::transformAttr.get(),
 754             &amp;SVGNames::typeAttr.get(),
 755             &amp;SVGNames::valuesAttr.get(),
 756             &amp;SVGNames::viewBoxAttr.get(),
 757             &amp;SVGNames::widthAttr.get(),
 758             &amp;SVGNames::x1Attr.get(),
 759             &amp;SVGNames::x2Attr.get(),
 760             &amp;SVGNames::xAttr.get(),
 761             &amp;SVGNames::xChannelSelectorAttr.get(),
 762             &amp;SVGNames::y1Attr.get(),
 763             &amp;SVGNames::y2Attr.get(),
 764             &amp;SVGNames::yAttr.get(),
 765             &amp;SVGNames::yChannelSelectorAttr.get(),
 766             &amp;SVGNames::zAttr.get(),
 767             &amp;SVGNames::hrefAttr.get(),
 768         };
<span class="line-modified"> 769         HashMap&lt;AtomString, QualifiedName&gt; map;</span>
 770         for (auto&amp; name : names) {
 771             auto addResult = map.add(name-&gt;localName(), *name);
 772             ASSERT_UNUSED(addResult, addResult.isNewEntry);
 773         }
 774         return map;
 775     }());
 776     return animatableAttributes.get().get(localName);
 777 }
 778 
 779 #ifndef NDEBUG
 780 
 781 bool SVGElement::isAnimatableAttribute(const QualifiedName&amp; name) const
 782 {
 783     if (animatableAttributeForName(name.localName()) == name)
 784         return !filterOutAnimatableAttribute(name);
 785     return false;
 786 }
 787 
 788 bool SVGElement::filterOutAnimatableAttribute(const QualifiedName&amp;) const
 789 {
</pre>
<hr />
<pre>
 808     // http://www.w3.org/TR/SVG/extend.html#PrivateData
 809     // Prevent anything other than SVG renderers from appearing in our render tree
 810     // Spec: SVG allows inclusion of elements from foreign namespaces anywhere
 811     // with the SVG content. In general, the SVG user agent will include the unknown
 812     // elements in the DOM but will otherwise ignore unknown elements.
 813     if (!parentOrShadowHostElement() || parentOrShadowHostElement()-&gt;isSVGElement())
 814         return StyledElement::rendererIsNeeded(style);
 815 
 816     return false;
 817 }
 818 
 819 CSSPropertyID SVGElement::cssPropertyIdForSVGAttributeName(const QualifiedName&amp; attrName)
 820 {
 821     if (!attrName.namespaceURI().isNull())
 822         return CSSPropertyInvalid;
 823 
 824     static const auto properties = makeNeverDestroyed(createAttributeNameToCSSPropertyIDMap());
 825     return properties.get().get(attrName.localName().impl());
 826 }
 827 











 828 bool SVGElement::isPresentationAttribute(const QualifiedName&amp; name) const
 829 {
 830     if (cssPropertyIdForSVGAttributeName(name) &gt; 0)
 831         return true;
 832     return StyledElement::isPresentationAttribute(name);
 833 }
 834 
<span class="line-modified"> 835 void SVGElement::collectStyleForPresentationAttribute(const QualifiedName&amp; name, const AtomString&amp; value, MutableStyleProperties&amp; style)</span>
 836 {
 837     CSSPropertyID propertyID = cssPropertyIdForSVGAttributeName(name);
 838     if (propertyID &gt; 0)
 839         addPropertyToPresentationAttributeStyle(style, propertyID, value);
 840 }
 841 
 842 void SVGElement::svgAttributeChanged(const QualifiedName&amp; attrName)
 843 {
 844     CSSPropertyID propId = cssPropertyIdForSVGAttributeName(attrName);
 845     if (propId &gt; 0) {
 846         invalidateInstances();
 847         return;
 848     }
 849 
 850     if (attrName == HTMLNames::classAttr) {
 851         classAttributeChanged(className());
 852         invalidateInstances();
 853         return;
 854     }
 855 
</pre>
<hr />
<pre>
 966         }
 967 
 968         m_elementsWithRelativeLengths.remove(element);
 969     }
 970 
 971     if (!element-&gt;isSVGGraphicsElement())
 972         return;
 973 
 974     // Find first styled parent node, and notify it that we&#39;ve changed our relative length state.
 975     auto node = makeRefPtr(parentNode());
 976     while (node) {
 977         if (!node-&gt;isSVGElement())
 978             break;
 979 
 980         // Register us in the parent element map.
 981         downcast&lt;SVGElement&gt;(*node).updateRelativeLengthsInformation(hasRelativeLengths, this);
 982         break;
 983     }
 984 }
 985 




















 986 void SVGElement::accessKeyAction(bool sendMouseEvents)
 987 {
 988     dispatchSimulatedClick(0, sendMouseEvents ? SendMouseUpDownEvents : SendNoEvents);
 989 }
 990 
 991 void SVGElement::invalidateInstances()
 992 {
 993     if (instanceUpdatesBlocked())
 994         return;
 995 
 996     auto&amp; instances = this-&gt;instances();
 997     while (!instances.isEmpty()) {
 998         auto instance = makeRefPtr(*instances.begin());
 999         if (auto useElement = instance-&gt;correspondingUseElement())
1000             useElement-&gt;invalidateShadowTree();
1001         instance-&gt;setCorrespondingElement(nullptr);
1002     } while (!instances.isEmpty());
1003 }
1004 
1005 }
</pre>
</td>
</tr>
</table>
<center><a href="SVGDocumentExtensions.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SVGElement.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>