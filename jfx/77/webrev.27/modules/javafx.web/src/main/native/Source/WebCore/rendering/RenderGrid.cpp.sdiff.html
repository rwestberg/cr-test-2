<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderGrid.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderGeometryMap.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderIFrame.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderGrid.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 171     // We cannot perform a simplified layout if we need to position the items and we have some
 172     // positioned items to be laid out.
 173     if (m_grid.needsItemsPlacement() &amp;&amp; posChildNeedsLayout())
 174         return false;
 175 
 176     return RenderBlock::canPerformSimplifiedLayout();
 177 }
 178 
 179 void RenderGrid::layoutBlock(bool relayoutChildren, LayoutUnit)
 180 {
 181     ASSERT(needsLayout());
 182 
 183     if (!relayoutChildren &amp;&amp; simplifiedLayout())
 184         return;
 185 
 186     LayoutRepainter repainter(*this, checkForRepaintDuringLayout());
 187     {
 188         LayoutStateMaintainer statePusher(*this, locationOffset(), hasTransform() || hasReflection() || style().isFlippedBlocksWritingMode());
 189 
 190         preparePaginationBeforeBlockLayout(relayoutChildren);

 191 
 192         LayoutSize previousSize = size();
 193         // FIXME: We should use RenderBlock::hasDefiniteLogicalHeight() but it does not work for positioned stuff.
 194         // FIXME: Consider caching the hasDefiniteLogicalHeight value throughout the layout.
 195         bool hasDefiniteLogicalHeight = hasOverrideContentLogicalHeight() || computeContentLogicalHeight(MainOrPreferredSize, style().logicalHeight(), WTF::nullopt);
 196 
 197         m_hasAnyOrthogonalItem = false;
 198         for (auto* child = firstChildBox(); child; child = child-&gt;nextSiblingBox()) {
 199             if (child-&gt;isOutOfFlowPositioned())
 200                 continue;
 201             // Grid&#39;s layout logic controls the grid item&#39;s override height, hence we need to
 202             // clear any override height set previously, so it doesn&#39;t interfere in current layout
 203             // execution. Grid never uses the override width, that&#39;s why we don&#39;t need to clear  it.
 204             child-&gt;clearOverrideContentLogicalHeight();
 205 
 206             // We may need to repeat the track sizing in case of any grid item was orthogonal.
 207             if (GridLayoutFunctions::isOrthogonalChild(*this, *child))
 208                 m_hasAnyOrthogonalItem = true;
 209 
 210             // We keep a cache of items with baseline as alignment values so
</pre>
<hr />
<pre>
 262 
 263         // 2.5- Compute Content Distribution offsets for rows tracks
 264         computeContentPositionAndDistributionOffset(ForRows, m_trackSizingAlgorithm.freeSpace(ForRows).value(), nonCollapsedTracks(ForRows));
 265 
 266         // 3- If the min-content contribution of any grid items have changed based on the row
 267         // sizes calculated in step 2, steps 1 and 2 are repeated with the new min-content
 268         // contribution (once only).
 269         repeatTracksSizingIfNeeded(availableSpaceForColumns, contentLogicalHeight());
 270 
 271         // Grid container should have the minimum height of a line if it&#39;s editable. That does not affect track sizing though.
 272         if (hasLineIfEmpty()) {
 273             LayoutUnit minHeightForEmptyLine = borderAndPaddingLogicalHeight()
 274                 + lineHeight(true, isHorizontalWritingMode() ? HorizontalLine : VerticalLine, PositionOfInteriorLineBoxes)
 275                 + scrollbarLogicalHeight();
 276             setLogicalHeight(std::max(logicalHeight(), minHeightForEmptyLine));
 277         }
 278 
 279         layoutGridItems();
 280         m_trackSizingAlgorithm.reset();
 281 


 282         if (size() != previousSize)
 283             relayoutChildren = true;
 284 
 285         m_outOfFlowItemColumn.clear();
 286         m_outOfFlowItemRow.clear();
 287 
 288         layoutPositionedObjects(relayoutChildren || isDocumentElementRenderer());
 289 
 290         computeOverflow(oldClientAfterEdge);
 291     }
 292 
 293     updateLayerTransform();
 294 
 295     // Update our scroll information if we&#39;re overflow:auto/scroll/hidden now that we know if
 296     // we overflow or not.
 297     updateScrollInfoAfterLayout();
 298 
 299     repainter.repaintAfterLayout();
 300 
 301     clearNeedsLayout();
</pre>
<hr />
<pre>
 436     LayoutUnit totalGuttersSize = guttersSize(grid, direction, 0, numberOfTracks, WTF::nullopt);
 437 
 438     if (minIntrinsicSize)
 439         *minIntrinsicSize = algorithm.minContentSize() + totalGuttersSize;
 440     if (maxIntrinsicSize)
 441         *maxIntrinsicSize = algorithm.maxContentSize() + totalGuttersSize;
 442 
 443     ASSERT(algorithm.tracksAreWiderThanMinTrackBreadth());
 444 }
 445 
 446 unsigned RenderGrid::computeAutoRepeatTracksCount(GridTrackSizingDirection direction, Optional&lt;LayoutUnit&gt; availableSize) const
 447 {
 448     ASSERT(!availableSize || availableSize.value() != -1);
 449     bool isRowAxis = direction == ForColumns;
 450     const auto&amp; autoRepeatTracks = isRowAxis ? style().gridAutoRepeatColumns() : style().gridAutoRepeatRows();
 451     unsigned autoRepeatTrackListLength = autoRepeatTracks.size();
 452 
 453     if (!autoRepeatTrackListLength)
 454         return 0;
 455 
<span class="line-removed"> 456     if (!isRowAxis &amp;&amp; !availableSize) {</span>
<span class="line-removed"> 457         const Length&amp; maxLength = style().logicalMaxHeight();</span>
<span class="line-removed"> 458         if (!maxLength.isUndefined()) {</span>
<span class="line-removed"> 459             availableSize = computeContentLogicalHeight(MaxSize, maxLength, WTF::nullopt);</span>
<span class="line-removed"> 460             if (availableSize)</span>
<span class="line-removed"> 461                 availableSize = constrainContentBoxLogicalHeightByMinMax(availableSize.value(), WTF::nullopt);</span>
<span class="line-removed"> 462         }</span>
<span class="line-removed"> 463     }</span>
<span class="line-removed"> 464 </span>
 465     bool needsToFulfillMinimumSize = false;
 466     if (!availableSize) {










 467         const Length&amp; minSize = isRowAxis ? style().logicalMinWidth() : style().logicalMinHeight();
<span class="line-modified"> 468         if (!minSize.isSpecified())</span>
 469             return autoRepeatTrackListLength;
 470 
<span class="line-modified"> 471         LayoutUnit containingBlockAvailableSize = isRowAxis ? containingBlockLogicalWidthForContent() : containingBlockLogicalHeightForContent(ExcludeMarginBorderPadding);</span>
<span class="line-modified"> 472         availableSize = valueForLength(minSize, containingBlockAvailableSize);</span>
<span class="line-modified"> 473         needsToFulfillMinimumSize = true;</span>








 474     }
 475 
 476     LayoutUnit autoRepeatTracksSize;
 477     for (auto&amp; autoTrackSize : autoRepeatTracks) {
 478         ASSERT(autoTrackSize.minTrackBreadth().isLength());
 479         ASSERT(!autoTrackSize.minTrackBreadth().isFlex());
 480         bool hasDefiniteMaxTrackSizingFunction = autoTrackSize.maxTrackBreadth().isLength() &amp;&amp; !autoTrackSize.maxTrackBreadth().isContentSized();
 481         auto trackLength = hasDefiniteMaxTrackSizingFunction ? autoTrackSize.maxTrackBreadth().length() : autoTrackSize.minTrackBreadth().length();
 482         autoRepeatTracksSize += valueForLength(trackLength, availableSize.value());
 483     }
 484     // For the purpose of finding the number of auto-repeated tracks, the UA must floor the track size to a UA-specified
 485     // value to avoid division by zero. It is suggested that this floor be 1px.
 486     autoRepeatTracksSize = std::max&lt;LayoutUnit&gt;(1_lu, autoRepeatTracksSize);
 487 
 488     // There will be always at least 1 auto-repeat track, so take it already into account when computing the total track size.
 489     LayoutUnit tracksSize = autoRepeatTracksSize;
 490     auto&amp; trackSizes = isRowAxis ? style().gridColumns() : style().gridRows();
 491 
 492     for (const auto&amp; track : trackSizes) {
 493         bool hasDefiniteMaxTrackBreadth = track.maxTrackBreadth().isLength() &amp;&amp; !track.maxTrackBreadth().isContentSized();
</pre>
<hr />
<pre>
 515     if (needsToFulfillMinimumSize &amp;&amp; freeSpace)
 516         ++repetitions;
 517 
 518     return repetitions * autoRepeatTrackListLength;
 519 }
 520 
 521 
 522 std::unique_ptr&lt;OrderedTrackIndexSet&gt; RenderGrid::computeEmptyTracksForAutoRepeat(Grid&amp; grid, GridTrackSizingDirection direction) const
 523 {
 524     bool isRowAxis = direction == ForColumns;
 525     if ((isRowAxis &amp;&amp; style().gridAutoRepeatColumnsType() != AutoRepeatType::Fit)
 526         || (!isRowAxis &amp;&amp; style().gridAutoRepeatRowsType() != AutoRepeatType::Fit))
 527         return nullptr;
 528 
 529     std::unique_ptr&lt;OrderedTrackIndexSet&gt; emptyTrackIndexes;
 530     unsigned insertionPoint = isRowAxis ? style().gridAutoRepeatColumnsInsertionPoint() : style().gridAutoRepeatRowsInsertionPoint();
 531     unsigned firstAutoRepeatTrack = insertionPoint + std::abs(grid.smallestTrackStart(direction));
 532     unsigned lastAutoRepeatTrack = firstAutoRepeatTrack + grid.autoRepeatTracks(direction);
 533 
 534     if (!grid.hasGridItems()) {
<span class="line-modified"> 535         emptyTrackIndexes = std::make_unique&lt;OrderedTrackIndexSet&gt;();</span>
 536         for (unsigned trackIndex = firstAutoRepeatTrack; trackIndex &lt; lastAutoRepeatTrack; ++trackIndex)
 537             emptyTrackIndexes-&gt;add(trackIndex);
 538     } else {
 539         for (unsigned trackIndex = firstAutoRepeatTrack; trackIndex &lt; lastAutoRepeatTrack; ++trackIndex) {
 540             GridIterator iterator(grid, direction, trackIndex);
 541             if (!iterator.nextGridItem()) {
 542                 if (!emptyTrackIndexes)
<span class="line-modified"> 543                     emptyTrackIndexes = std::make_unique&lt;OrderedTrackIndexSet&gt;();</span>
 544                 emptyTrackIndexes-&gt;add(trackIndex);
 545             }
 546         }
 547     }
 548     return emptyTrackIndexes;
 549 }
 550 
 551 unsigned RenderGrid::clampAutoRepeatTracks(GridTrackSizingDirection direction, unsigned autoRepeatTracks) const
 552 {
 553     if (!autoRepeatTracks)
 554         return 0;
 555 
 556     unsigned insertionPoint = direction == ForColumns ? style().gridAutoRepeatColumnsInsertionPoint() : style().gridAutoRepeatRowsInsertionPoint();
 557     unsigned maxTracks = static_cast&lt;unsigned&gt;(GridPosition::max());
 558 
 559     if (!insertionPoint)
 560         return std::min(autoRepeatTracks, maxTracks);
 561 
 562     if (insertionPoint &gt;= maxTracks)
 563         return 0;
</pre>
<hr />
<pre>
 703             maximumColumnIndex = std::max&lt;int&gt;(maximumColumnIndex, columnPositions.untranslatedEndLine());
 704         } else {
 705             // Grow the grid for items with a definite column span, getting the largest such span.
 706             unsigned spanSize = GridPositionsResolver::spanSizeForAutoPlacedItem(*child, ForColumns);
 707             maximumColumnIndex = std::max(maximumColumnIndex, spanSize);
 708         }
 709 
 710         grid.setGridItemArea(*child, { rowPositions, columnPositions });
 711     }
 712 
 713     grid.setSmallestTracksStart(smallestRowStart, smallestColumnStart);
 714     grid.ensureGridSize(maximumRowIndex + std::abs(smallestRowStart), maximumColumnIndex + std::abs(smallestColumnStart));
 715 }
 716 
 717 std::unique_ptr&lt;GridArea&gt; RenderGrid::createEmptyGridAreaAtSpecifiedPositionsOutsideGrid(Grid&amp; grid, const RenderBox&amp; gridItem, GridTrackSizingDirection specifiedDirection, const GridSpan&amp; specifiedPositions) const
 718 {
 719     GridTrackSizingDirection crossDirection = specifiedDirection == ForColumns ? ForRows : ForColumns;
 720     const unsigned endOfCrossDirection = grid.numTracks(crossDirection);
 721     unsigned crossDirectionSpanSize = GridPositionsResolver::spanSizeForAutoPlacedItem(gridItem, crossDirection);
 722     GridSpan crossDirectionPositions = GridSpan::translatedDefiniteGridSpan(endOfCrossDirection, endOfCrossDirection + crossDirectionSpanSize);
<span class="line-modified"> 723     return std::make_unique&lt;GridArea&gt;(specifiedDirection == ForColumns ? crossDirectionPositions : specifiedPositions, specifiedDirection == ForColumns ? specifiedPositions : crossDirectionPositions);</span>
 724 }
 725 
 726 void RenderGrid::placeSpecifiedMajorAxisItemsOnGrid(Grid&amp; grid, const Vector&lt;RenderBox*&gt;&amp; autoGridItems) const
 727 {
 728     bool isForColumns = autoPlacementMajorAxisDirection() == ForColumns;
 729     bool isGridAutoFlowDense = style().isGridAutoFlowAlgorithmDense();
 730 
 731     // Mapping between the major axis tracks (rows or columns) and the last auto-placed item&#39;s position inserted on
 732     // that track. This is needed to implement &quot;sparse&quot; packing for items locked to a given track.
 733     // See http://dev.w3.org/csswg/css-grid/#auto-placement-algorithm
 734     HashMap&lt;unsigned, unsigned, DefaultHash&lt;unsigned&gt;::Hash, WTF::UnsignedWithZeroKeyHashTraits&lt;unsigned&gt;&gt; minorAxisCursors;
 735 
 736     for (auto&amp; autoGridItem : autoGridItems) {
 737         GridSpan majorAxisPositions = grid.gridItemSpan(*autoGridItem, autoPlacementMajorAxisDirection());
 738         ASSERT(majorAxisPositions.isTranslatedDefinite());
 739         ASSERT(grid.gridItemSpan(*autoGridItem, autoPlacementMinorAxisDirection()).isIndefinite());
 740         unsigned minorAxisSpanSize = GridPositionsResolver::spanSizeForAutoPlacedItem(*autoGridItem, autoPlacementMinorAxisDirection());
 741         unsigned majorAxisInitialPosition = majorAxisPositions.startLine();
 742 
 743         GridIterator iterator(grid, autoPlacementMajorAxisDirection(), majorAxisPositions.startLine(), isGridAutoFlowDense ? 0 : minorAxisCursors.get(majorAxisInitialPosition));
</pre>
<hr />
<pre>
1182 
1183     const RenderStyle&amp; parentStyle = style();
1184     Length marginBefore = child.style().marginBeforeUsing(&amp;parentStyle);
1185     Length marginAfter = child.style().marginAfterUsing(&amp;parentStyle);
1186     if (marginBefore.isAuto() &amp;&amp; marginAfter.isAuto()) {
1187         child.setMarginBefore(availableAlignmentSpace / 2, &amp;parentStyle);
1188         child.setMarginAfter(availableAlignmentSpace / 2, &amp;parentStyle);
1189     } else if (marginBefore.isAuto()) {
1190         child.setMarginBefore(availableAlignmentSpace, &amp;parentStyle);
1191     } else if (marginAfter.isAuto()) {
1192         child.setMarginAfter(availableAlignmentSpace, &amp;parentStyle);
1193     }
1194 }
1195 
1196 // FIXME: This logic could be refactored somehow and defined in RenderBox.
1197 static int synthesizedBaselineFromBorderBox(const RenderBox&amp; box, LineDirectionMode direction)
1198 {
1199     return (direction == HorizontalLine ? box.size().height() : box.size().width()).toInt();
1200 }
1201 
<span class="line-removed">1202 static int synthesizedBaselineFromMarginBox(const RenderBox&amp; box, LineDirectionMode direction)</span>
<span class="line-removed">1203 {</span>
<span class="line-removed">1204     return (direction == HorizontalLine ? box.size().height() + box.verticalMarginExtent() : box.size().width() + box.horizontalMarginExtent()).toInt();</span>
<span class="line-removed">1205 }</span>
<span class="line-removed">1206 </span>
1207 bool RenderGrid::isBaselineAlignmentForChild(const RenderBox&amp; child) const
1208 {
1209     return isBaselineAlignmentForChild(child, GridRowAxis) || isBaselineAlignmentForChild(child, GridColumnAxis);
1210 }
1211 
1212 bool RenderGrid::isBaselineAlignmentForChild(const RenderBox&amp; child, GridAxis baselineAxis) const
1213 {
1214     if (child.isOutOfFlowPositioned())
1215         return false;
1216     ItemPosition align = selfAlignmentForChild(baselineAxis, child).position();
1217     bool hasAutoMargins = baselineAxis == GridColumnAxis ? hasAutoMarginsInColumnAxis(child) : hasAutoMarginsInRowAxis(child);
1218     return isBaselinePosition(align) &amp;&amp; !hasAutoMargins;
1219 }
1220 
1221 // FIXME: This logic is shared by RenderFlexibleBox, so it might be refactored somehow.
1222 int RenderGrid::baselinePosition(FontBaseline, bool, LineDirectionMode direction, LinePositionMode mode) const
1223 {
1224 #if !ASSERT_DISABLED
1225     ASSERT(mode == PositionOnContainingLine);
1226 #else
1227     UNUSED_PARAM(mode);
1228 #endif
<span class="line-modified">1229     return firstLineBaseline().valueOr(synthesizedBaselineFromMarginBox(*this, direction));</span>




1230 }
1231 
1232 Optional&lt;int&gt; RenderGrid::firstLineBaseline() const
1233 {
1234     if (isWritingModeRoot() || !m_grid.hasGridItems())
1235         return WTF::nullopt;
1236 
1237     const RenderBox* baselineChild = nullptr;
1238     // Finding the first grid item in grid order.
1239     unsigned numColumns = m_grid.numTracks(ForColumns);
1240     for (size_t column = 0; column &lt; numColumns; column++) {
1241         for (auto&amp; child : m_grid.cell(0, column)) {
1242             ASSERT(child.get());
1243             // If an item participates in baseline alignment, we select such item.
1244             if (isBaselineAlignmentForChild(*child)) {
1245                 // FIXME: self-baseline and content-baseline alignment not implemented yet.
1246                 baselineChild = child.get();
1247                 break;
1248             }
1249             if (!baselineChild)
1250                 baselineChild = child.get();
1251         }
1252     }
1253 
1254     if (!baselineChild)
1255         return WTF::nullopt;
1256 
1257     auto baseline = GridLayoutFunctions::isOrthogonalChild(*this, *baselineChild) ? WTF::nullopt : baselineChild-&gt;firstLineBaseline();
1258     // We take border-box&#39;s bottom if no valid baseline.
1259     if (!baseline) {
1260         // FIXME: We should pass |direction| into firstLineBaseline and stop bailing out if we&#39;re a writing
1261         // mode root. This would also fix some cases where the grid is orthogonal to its container.
1262         LineDirectionMode direction = isHorizontalWritingMode() ? HorizontalLine : VerticalLine;
<span class="line-modified">1263         return synthesizedBaselineFromBorderBox(*baselineChild, direction) + baselineChild-&gt;logicalTop().toInt();</span>
1264     }
1265     return baseline.value() + baselineChild-&gt;logicalTop().toInt();
1266 }
1267 
<span class="line-modified">1268 Optional&lt;int&gt; RenderGrid::inlineBlockBaseline(LineDirectionMode direction) const</span>
1269 {
<span class="line-modified">1270     if (Optional&lt;int&gt; baseline = firstLineBaseline())</span>
<span class="line-removed">1271         return baseline;</span>
<span class="line-removed">1272 </span>
<span class="line-removed">1273     int marginAscent = direction == HorizontalLine ? marginBottom() : marginRight();</span>
<span class="line-removed">1274     return synthesizedBaselineFromBorderBox(*this, direction) + marginAscent;</span>
1275 }
1276 
1277 LayoutUnit RenderGrid::columnAxisBaselineOffsetForChild(const RenderBox&amp; child) const
1278 {
1279     return m_trackSizingAlgorithm.baselineOffsetForChild(child, GridColumnAxis);
1280 }
1281 
1282 LayoutUnit RenderGrid::rowAxisBaselineOffsetForChild(const RenderBox&amp; child) const
1283 {
1284     return m_trackSizingAlgorithm.baselineOffsetForChild(child, GridRowAxis);
1285 }
1286 
1287 GridAxisPosition RenderGrid::columnAxisPositionForChild(const RenderBox&amp; child) const
1288 {
1289     bool hasSameWritingMode = child.style().writingMode() == style().writingMode();
1290     bool childIsLTR = child.style().isLeftToRightDirection();
1291     if (child.isOutOfFlowPositioned() &amp;&amp; !hasStaticPositionForChild(child, ForRows))
1292         return GridAxisStart;
1293 
1294     switch (alignSelfForChild(child).position()) {
</pre>
</td>
<td>
<hr />
<pre>
 171     // We cannot perform a simplified layout if we need to position the items and we have some
 172     // positioned items to be laid out.
 173     if (m_grid.needsItemsPlacement() &amp;&amp; posChildNeedsLayout())
 174         return false;
 175 
 176     return RenderBlock::canPerformSimplifiedLayout();
 177 }
 178 
 179 void RenderGrid::layoutBlock(bool relayoutChildren, LayoutUnit)
 180 {
 181     ASSERT(needsLayout());
 182 
 183     if (!relayoutChildren &amp;&amp; simplifiedLayout())
 184         return;
 185 
 186     LayoutRepainter repainter(*this, checkForRepaintDuringLayout());
 187     {
 188         LayoutStateMaintainer statePusher(*this, locationOffset(), hasTransform() || hasReflection() || style().isFlippedBlocksWritingMode());
 189 
 190         preparePaginationBeforeBlockLayout(relayoutChildren);
<span class="line-added"> 191         beginUpdateScrollInfoAfterLayoutTransaction();</span>
 192 
 193         LayoutSize previousSize = size();
 194         // FIXME: We should use RenderBlock::hasDefiniteLogicalHeight() but it does not work for positioned stuff.
 195         // FIXME: Consider caching the hasDefiniteLogicalHeight value throughout the layout.
 196         bool hasDefiniteLogicalHeight = hasOverrideContentLogicalHeight() || computeContentLogicalHeight(MainOrPreferredSize, style().logicalHeight(), WTF::nullopt);
 197 
 198         m_hasAnyOrthogonalItem = false;
 199         for (auto* child = firstChildBox(); child; child = child-&gt;nextSiblingBox()) {
 200             if (child-&gt;isOutOfFlowPositioned())
 201                 continue;
 202             // Grid&#39;s layout logic controls the grid item&#39;s override height, hence we need to
 203             // clear any override height set previously, so it doesn&#39;t interfere in current layout
 204             // execution. Grid never uses the override width, that&#39;s why we don&#39;t need to clear  it.
 205             child-&gt;clearOverrideContentLogicalHeight();
 206 
 207             // We may need to repeat the track sizing in case of any grid item was orthogonal.
 208             if (GridLayoutFunctions::isOrthogonalChild(*this, *child))
 209                 m_hasAnyOrthogonalItem = true;
 210 
 211             // We keep a cache of items with baseline as alignment values so
</pre>
<hr />
<pre>
 263 
 264         // 2.5- Compute Content Distribution offsets for rows tracks
 265         computeContentPositionAndDistributionOffset(ForRows, m_trackSizingAlgorithm.freeSpace(ForRows).value(), nonCollapsedTracks(ForRows));
 266 
 267         // 3- If the min-content contribution of any grid items have changed based on the row
 268         // sizes calculated in step 2, steps 1 and 2 are repeated with the new min-content
 269         // contribution (once only).
 270         repeatTracksSizingIfNeeded(availableSpaceForColumns, contentLogicalHeight());
 271 
 272         // Grid container should have the minimum height of a line if it&#39;s editable. That does not affect track sizing though.
 273         if (hasLineIfEmpty()) {
 274             LayoutUnit minHeightForEmptyLine = borderAndPaddingLogicalHeight()
 275                 + lineHeight(true, isHorizontalWritingMode() ? HorizontalLine : VerticalLine, PositionOfInteriorLineBoxes)
 276                 + scrollbarLogicalHeight();
 277             setLogicalHeight(std::max(logicalHeight(), minHeightForEmptyLine));
 278         }
 279 
 280         layoutGridItems();
 281         m_trackSizingAlgorithm.reset();
 282 
<span class="line-added"> 283         endAndCommitUpdateScrollInfoAfterLayoutTransaction();</span>
<span class="line-added"> 284 </span>
 285         if (size() != previousSize)
 286             relayoutChildren = true;
 287 
 288         m_outOfFlowItemColumn.clear();
 289         m_outOfFlowItemRow.clear();
 290 
 291         layoutPositionedObjects(relayoutChildren || isDocumentElementRenderer());
 292 
 293         computeOverflow(oldClientAfterEdge);
 294     }
 295 
 296     updateLayerTransform();
 297 
 298     // Update our scroll information if we&#39;re overflow:auto/scroll/hidden now that we know if
 299     // we overflow or not.
 300     updateScrollInfoAfterLayout();
 301 
 302     repainter.repaintAfterLayout();
 303 
 304     clearNeedsLayout();
</pre>
<hr />
<pre>
 439     LayoutUnit totalGuttersSize = guttersSize(grid, direction, 0, numberOfTracks, WTF::nullopt);
 440 
 441     if (minIntrinsicSize)
 442         *minIntrinsicSize = algorithm.minContentSize() + totalGuttersSize;
 443     if (maxIntrinsicSize)
 444         *maxIntrinsicSize = algorithm.maxContentSize() + totalGuttersSize;
 445 
 446     ASSERT(algorithm.tracksAreWiderThanMinTrackBreadth());
 447 }
 448 
 449 unsigned RenderGrid::computeAutoRepeatTracksCount(GridTrackSizingDirection direction, Optional&lt;LayoutUnit&gt; availableSize) const
 450 {
 451     ASSERT(!availableSize || availableSize.value() != -1);
 452     bool isRowAxis = direction == ForColumns;
 453     const auto&amp; autoRepeatTracks = isRowAxis ? style().gridAutoRepeatColumns() : style().gridAutoRepeatRows();
 454     unsigned autoRepeatTrackListLength = autoRepeatTracks.size();
 455 
 456     if (!autoRepeatTrackListLength)
 457         return 0;
 458 









 459     bool needsToFulfillMinimumSize = false;
 460     if (!availableSize) {
<span class="line-added"> 461         const Length&amp; maxSize = isRowAxis ? style().logicalMaxWidth() : style().logicalMaxHeight();</span>
<span class="line-added"> 462         Optional&lt;LayoutUnit&gt; containingBlockAvailableSize;</span>
<span class="line-added"> 463         Optional&lt;LayoutUnit&gt; availableMaxSize;</span>
<span class="line-added"> 464         if (maxSize.isSpecified()) {</span>
<span class="line-added"> 465             if (maxSize.isPercentOrCalculated())</span>
<span class="line-added"> 466                 containingBlockAvailableSize = isRowAxis ? containingBlockLogicalWidthForContent() : containingBlockLogicalHeightForContent(ExcludeMarginBorderPadding);</span>
<span class="line-added"> 467             LayoutUnit maxSizeValue = valueForLength(maxSize, containingBlockAvailableSize.valueOr(LayoutUnit()));</span>
<span class="line-added"> 468             availableMaxSize = isRowAxis ? adjustContentBoxLogicalWidthForBoxSizing(maxSizeValue) : adjustContentBoxLogicalHeightForBoxSizing(maxSizeValue);</span>
<span class="line-added"> 469         }</span>
<span class="line-added"> 470 </span>
 471         const Length&amp; minSize = isRowAxis ? style().logicalMinWidth() : style().logicalMinHeight();
<span class="line-modified"> 472         if (!availableMaxSize &amp;&amp; !minSize.isSpecified())</span>
 473             return autoRepeatTrackListLength;
 474 
<span class="line-modified"> 475         Optional&lt;LayoutUnit&gt; availableMinSize;</span>
<span class="line-modified"> 476         if (minSize.isSpecified()) {</span>
<span class="line-modified"> 477             if (!containingBlockAvailableSize &amp;&amp; minSize.isPercentOrCalculated())</span>
<span class="line-added"> 478                 containingBlockAvailableSize = isRowAxis ? containingBlockLogicalWidthForContent() : containingBlockLogicalHeightForContent(ExcludeMarginBorderPadding);</span>
<span class="line-added"> 479             LayoutUnit minSizeValue = valueForLength(minSize, containingBlockAvailableSize.valueOr(LayoutUnit()));</span>
<span class="line-added"> 480             availableMinSize = isRowAxis ? adjustContentBoxLogicalWidthForBoxSizing(minSizeValue) : adjustContentBoxLogicalHeightForBoxSizing(minSizeValue);</span>
<span class="line-added"> 481             if (!maxSize.isSpecified())</span>
<span class="line-added"> 482                 needsToFulfillMinimumSize = true;</span>
<span class="line-added"> 483         }</span>
<span class="line-added"> 484 </span>
<span class="line-added"> 485         availableSize = std::max(availableMinSize.valueOr(LayoutUnit()), availableMaxSize.valueOr(LayoutUnit()));</span>
 486     }
 487 
 488     LayoutUnit autoRepeatTracksSize;
 489     for (auto&amp; autoTrackSize : autoRepeatTracks) {
 490         ASSERT(autoTrackSize.minTrackBreadth().isLength());
 491         ASSERT(!autoTrackSize.minTrackBreadth().isFlex());
 492         bool hasDefiniteMaxTrackSizingFunction = autoTrackSize.maxTrackBreadth().isLength() &amp;&amp; !autoTrackSize.maxTrackBreadth().isContentSized();
 493         auto trackLength = hasDefiniteMaxTrackSizingFunction ? autoTrackSize.maxTrackBreadth().length() : autoTrackSize.minTrackBreadth().length();
 494         autoRepeatTracksSize += valueForLength(trackLength, availableSize.value());
 495     }
 496     // For the purpose of finding the number of auto-repeated tracks, the UA must floor the track size to a UA-specified
 497     // value to avoid division by zero. It is suggested that this floor be 1px.
 498     autoRepeatTracksSize = std::max&lt;LayoutUnit&gt;(1_lu, autoRepeatTracksSize);
 499 
 500     // There will be always at least 1 auto-repeat track, so take it already into account when computing the total track size.
 501     LayoutUnit tracksSize = autoRepeatTracksSize;
 502     auto&amp; trackSizes = isRowAxis ? style().gridColumns() : style().gridRows();
 503 
 504     for (const auto&amp; track : trackSizes) {
 505         bool hasDefiniteMaxTrackBreadth = track.maxTrackBreadth().isLength() &amp;&amp; !track.maxTrackBreadth().isContentSized();
</pre>
<hr />
<pre>
 527     if (needsToFulfillMinimumSize &amp;&amp; freeSpace)
 528         ++repetitions;
 529 
 530     return repetitions * autoRepeatTrackListLength;
 531 }
 532 
 533 
 534 std::unique_ptr&lt;OrderedTrackIndexSet&gt; RenderGrid::computeEmptyTracksForAutoRepeat(Grid&amp; grid, GridTrackSizingDirection direction) const
 535 {
 536     bool isRowAxis = direction == ForColumns;
 537     if ((isRowAxis &amp;&amp; style().gridAutoRepeatColumnsType() != AutoRepeatType::Fit)
 538         || (!isRowAxis &amp;&amp; style().gridAutoRepeatRowsType() != AutoRepeatType::Fit))
 539         return nullptr;
 540 
 541     std::unique_ptr&lt;OrderedTrackIndexSet&gt; emptyTrackIndexes;
 542     unsigned insertionPoint = isRowAxis ? style().gridAutoRepeatColumnsInsertionPoint() : style().gridAutoRepeatRowsInsertionPoint();
 543     unsigned firstAutoRepeatTrack = insertionPoint + std::abs(grid.smallestTrackStart(direction));
 544     unsigned lastAutoRepeatTrack = firstAutoRepeatTrack + grid.autoRepeatTracks(direction);
 545 
 546     if (!grid.hasGridItems()) {
<span class="line-modified"> 547         emptyTrackIndexes = makeUnique&lt;OrderedTrackIndexSet&gt;();</span>
 548         for (unsigned trackIndex = firstAutoRepeatTrack; trackIndex &lt; lastAutoRepeatTrack; ++trackIndex)
 549             emptyTrackIndexes-&gt;add(trackIndex);
 550     } else {
 551         for (unsigned trackIndex = firstAutoRepeatTrack; trackIndex &lt; lastAutoRepeatTrack; ++trackIndex) {
 552             GridIterator iterator(grid, direction, trackIndex);
 553             if (!iterator.nextGridItem()) {
 554                 if (!emptyTrackIndexes)
<span class="line-modified"> 555                     emptyTrackIndexes = makeUnique&lt;OrderedTrackIndexSet&gt;();</span>
 556                 emptyTrackIndexes-&gt;add(trackIndex);
 557             }
 558         }
 559     }
 560     return emptyTrackIndexes;
 561 }
 562 
 563 unsigned RenderGrid::clampAutoRepeatTracks(GridTrackSizingDirection direction, unsigned autoRepeatTracks) const
 564 {
 565     if (!autoRepeatTracks)
 566         return 0;
 567 
 568     unsigned insertionPoint = direction == ForColumns ? style().gridAutoRepeatColumnsInsertionPoint() : style().gridAutoRepeatRowsInsertionPoint();
 569     unsigned maxTracks = static_cast&lt;unsigned&gt;(GridPosition::max());
 570 
 571     if (!insertionPoint)
 572         return std::min(autoRepeatTracks, maxTracks);
 573 
 574     if (insertionPoint &gt;= maxTracks)
 575         return 0;
</pre>
<hr />
<pre>
 715             maximumColumnIndex = std::max&lt;int&gt;(maximumColumnIndex, columnPositions.untranslatedEndLine());
 716         } else {
 717             // Grow the grid for items with a definite column span, getting the largest such span.
 718             unsigned spanSize = GridPositionsResolver::spanSizeForAutoPlacedItem(*child, ForColumns);
 719             maximumColumnIndex = std::max(maximumColumnIndex, spanSize);
 720         }
 721 
 722         grid.setGridItemArea(*child, { rowPositions, columnPositions });
 723     }
 724 
 725     grid.setSmallestTracksStart(smallestRowStart, smallestColumnStart);
 726     grid.ensureGridSize(maximumRowIndex + std::abs(smallestRowStart), maximumColumnIndex + std::abs(smallestColumnStart));
 727 }
 728 
 729 std::unique_ptr&lt;GridArea&gt; RenderGrid::createEmptyGridAreaAtSpecifiedPositionsOutsideGrid(Grid&amp; grid, const RenderBox&amp; gridItem, GridTrackSizingDirection specifiedDirection, const GridSpan&amp; specifiedPositions) const
 730 {
 731     GridTrackSizingDirection crossDirection = specifiedDirection == ForColumns ? ForRows : ForColumns;
 732     const unsigned endOfCrossDirection = grid.numTracks(crossDirection);
 733     unsigned crossDirectionSpanSize = GridPositionsResolver::spanSizeForAutoPlacedItem(gridItem, crossDirection);
 734     GridSpan crossDirectionPositions = GridSpan::translatedDefiniteGridSpan(endOfCrossDirection, endOfCrossDirection + crossDirectionSpanSize);
<span class="line-modified"> 735     return makeUnique&lt;GridArea&gt;(specifiedDirection == ForColumns ? crossDirectionPositions : specifiedPositions, specifiedDirection == ForColumns ? specifiedPositions : crossDirectionPositions);</span>
 736 }
 737 
 738 void RenderGrid::placeSpecifiedMajorAxisItemsOnGrid(Grid&amp; grid, const Vector&lt;RenderBox*&gt;&amp; autoGridItems) const
 739 {
 740     bool isForColumns = autoPlacementMajorAxisDirection() == ForColumns;
 741     bool isGridAutoFlowDense = style().isGridAutoFlowAlgorithmDense();
 742 
 743     // Mapping between the major axis tracks (rows or columns) and the last auto-placed item&#39;s position inserted on
 744     // that track. This is needed to implement &quot;sparse&quot; packing for items locked to a given track.
 745     // See http://dev.w3.org/csswg/css-grid/#auto-placement-algorithm
 746     HashMap&lt;unsigned, unsigned, DefaultHash&lt;unsigned&gt;::Hash, WTF::UnsignedWithZeroKeyHashTraits&lt;unsigned&gt;&gt; minorAxisCursors;
 747 
 748     for (auto&amp; autoGridItem : autoGridItems) {
 749         GridSpan majorAxisPositions = grid.gridItemSpan(*autoGridItem, autoPlacementMajorAxisDirection());
 750         ASSERT(majorAxisPositions.isTranslatedDefinite());
 751         ASSERT(grid.gridItemSpan(*autoGridItem, autoPlacementMinorAxisDirection()).isIndefinite());
 752         unsigned minorAxisSpanSize = GridPositionsResolver::spanSizeForAutoPlacedItem(*autoGridItem, autoPlacementMinorAxisDirection());
 753         unsigned majorAxisInitialPosition = majorAxisPositions.startLine();
 754 
 755         GridIterator iterator(grid, autoPlacementMajorAxisDirection(), majorAxisPositions.startLine(), isGridAutoFlowDense ? 0 : minorAxisCursors.get(majorAxisInitialPosition));
</pre>
<hr />
<pre>
1194 
1195     const RenderStyle&amp; parentStyle = style();
1196     Length marginBefore = child.style().marginBeforeUsing(&amp;parentStyle);
1197     Length marginAfter = child.style().marginAfterUsing(&amp;parentStyle);
1198     if (marginBefore.isAuto() &amp;&amp; marginAfter.isAuto()) {
1199         child.setMarginBefore(availableAlignmentSpace / 2, &amp;parentStyle);
1200         child.setMarginAfter(availableAlignmentSpace / 2, &amp;parentStyle);
1201     } else if (marginBefore.isAuto()) {
1202         child.setMarginBefore(availableAlignmentSpace, &amp;parentStyle);
1203     } else if (marginAfter.isAuto()) {
1204         child.setMarginAfter(availableAlignmentSpace, &amp;parentStyle);
1205     }
1206 }
1207 
1208 // FIXME: This logic could be refactored somehow and defined in RenderBox.
1209 static int synthesizedBaselineFromBorderBox(const RenderBox&amp; box, LineDirectionMode direction)
1210 {
1211     return (direction == HorizontalLine ? box.size().height() : box.size().width()).toInt();
1212 }
1213 





1214 bool RenderGrid::isBaselineAlignmentForChild(const RenderBox&amp; child) const
1215 {
1216     return isBaselineAlignmentForChild(child, GridRowAxis) || isBaselineAlignmentForChild(child, GridColumnAxis);
1217 }
1218 
1219 bool RenderGrid::isBaselineAlignmentForChild(const RenderBox&amp; child, GridAxis baselineAxis) const
1220 {
1221     if (child.isOutOfFlowPositioned())
1222         return false;
1223     ItemPosition align = selfAlignmentForChild(baselineAxis, child).position();
1224     bool hasAutoMargins = baselineAxis == GridColumnAxis ? hasAutoMarginsInColumnAxis(child) : hasAutoMarginsInRowAxis(child);
1225     return isBaselinePosition(align) &amp;&amp; !hasAutoMargins;
1226 }
1227 
1228 // FIXME: This logic is shared by RenderFlexibleBox, so it might be refactored somehow.
1229 int RenderGrid::baselinePosition(FontBaseline, bool, LineDirectionMode direction, LinePositionMode mode) const
1230 {
1231 #if !ASSERT_DISABLED
1232     ASSERT(mode == PositionOnContainingLine);
1233 #else
1234     UNUSED_PARAM(mode);
1235 #endif
<span class="line-modified">1236     auto baseline = firstLineBaseline();</span>
<span class="line-added">1237     if (!baseline)</span>
<span class="line-added">1238         return synthesizedBaselineFromBorderBox(*this, direction) + marginLogicalHeight();</span>
<span class="line-added">1239 </span>
<span class="line-added">1240     return baseline.value() + (direction == HorizontalLine ? marginTop() : marginRight()).toInt();</span>
1241 }
1242 
1243 Optional&lt;int&gt; RenderGrid::firstLineBaseline() const
1244 {
1245     if (isWritingModeRoot() || !m_grid.hasGridItems())
1246         return WTF::nullopt;
1247 
1248     const RenderBox* baselineChild = nullptr;
1249     // Finding the first grid item in grid order.
1250     unsigned numColumns = m_grid.numTracks(ForColumns);
1251     for (size_t column = 0; column &lt; numColumns; column++) {
1252         for (auto&amp; child : m_grid.cell(0, column)) {
1253             ASSERT(child.get());
1254             // If an item participates in baseline alignment, we select such item.
1255             if (isBaselineAlignmentForChild(*child)) {
1256                 // FIXME: self-baseline and content-baseline alignment not implemented yet.
1257                 baselineChild = child.get();
1258                 break;
1259             }
1260             if (!baselineChild)
1261                 baselineChild = child.get();
1262         }
1263     }
1264 
1265     if (!baselineChild)
1266         return WTF::nullopt;
1267 
1268     auto baseline = GridLayoutFunctions::isOrthogonalChild(*this, *baselineChild) ? WTF::nullopt : baselineChild-&gt;firstLineBaseline();
1269     // We take border-box&#39;s bottom if no valid baseline.
1270     if (!baseline) {
1271         // FIXME: We should pass |direction| into firstLineBaseline and stop bailing out if we&#39;re a writing
1272         // mode root. This would also fix some cases where the grid is orthogonal to its container.
1273         LineDirectionMode direction = isHorizontalWritingMode() ? HorizontalLine : VerticalLine;
<span class="line-modified">1274         return synthesizedBaselineFromBorderBox(*baselineChild, direction) + logicalTopForChild(*baselineChild).toInt();</span>
1275     }
1276     return baseline.value() + baselineChild-&gt;logicalTop().toInt();
1277 }
1278 
<span class="line-modified">1279 Optional&lt;int&gt; RenderGrid::inlineBlockBaseline(LineDirectionMode) const</span>
1280 {
<span class="line-modified">1281     return firstLineBaseline();</span>




1282 }
1283 
1284 LayoutUnit RenderGrid::columnAxisBaselineOffsetForChild(const RenderBox&amp; child) const
1285 {
1286     return m_trackSizingAlgorithm.baselineOffsetForChild(child, GridColumnAxis);
1287 }
1288 
1289 LayoutUnit RenderGrid::rowAxisBaselineOffsetForChild(const RenderBox&amp; child) const
1290 {
1291     return m_trackSizingAlgorithm.baselineOffsetForChild(child, GridRowAxis);
1292 }
1293 
1294 GridAxisPosition RenderGrid::columnAxisPositionForChild(const RenderBox&amp; child) const
1295 {
1296     bool hasSameWritingMode = child.style().writingMode() == style().writingMode();
1297     bool childIsLTR = child.style().isLeftToRightDirection();
1298     if (child.isOutOfFlowPositioned() &amp;&amp; !hasStaticPositionForChild(child, ForRows))
1299         return GridAxisStart;
1300 
1301     switch (alignSelfForChild(child).position()) {
</pre>
</td>
</tr>
</table>
<center><a href="RenderGeometryMap.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderIFrame.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>