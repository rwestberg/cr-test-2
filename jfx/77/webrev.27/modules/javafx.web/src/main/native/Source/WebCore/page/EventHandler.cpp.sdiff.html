<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/page/EventHandler.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="EditorClient.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="EventHandler.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/page/EventHandler.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  34 #include &quot;Chrome.h&quot;
  35 #include &quot;ChromeClient.h&quot;
  36 #include &quot;ComposedTreeAncestorIterator.h&quot;
  37 #include &quot;CursorList.h&quot;
  38 #include &quot;DocumentMarkerController.h&quot;
  39 #include &quot;DragController.h&quot;
  40 #include &quot;DragState.h&quot;
  41 #include &quot;Editing.h&quot;
  42 #include &quot;Editor.h&quot;
  43 #include &quot;EditorClient.h&quot;
  44 #include &quot;EventNames.h&quot;
  45 #include &quot;FileList.h&quot;
  46 #include &quot;FloatPoint.h&quot;
  47 #include &quot;FloatRect.h&quot;
  48 #include &quot;FocusController.h&quot;
  49 #include &quot;Frame.h&quot;
  50 #include &quot;FrameLoader.h&quot;
  51 #include &quot;FrameSelection.h&quot;
  52 #include &quot;FrameTree.h&quot;
  53 #include &quot;FrameView.h&quot;

  54 #include &quot;HTMLDocument.h&quot;
  55 #include &quot;HTMLFrameElement.h&quot;
  56 #include &quot;HTMLFrameSetElement.h&quot;
  57 #include &quot;HTMLHtmlElement.h&quot;
  58 #include &quot;HTMLIFrameElement.h&quot;
  59 #include &quot;HTMLInputElement.h&quot;
  60 #include &quot;HTMLNames.h&quot;
  61 #include &quot;HitTestRequest.h&quot;
  62 #include &quot;HitTestResult.h&quot;
  63 #include &quot;Image.h&quot;
  64 #include &quot;InspectorInstrumentation.h&quot;
  65 #include &quot;KeyboardEvent.h&quot;
  66 #include &quot;Logging.h&quot;
  67 #include &quot;MouseEvent.h&quot;
  68 #include &quot;MouseEventWithHitTestResults.h&quot;
  69 #include &quot;NotImplemented.h&quot;
  70 #include &quot;Page.h&quot;
  71 #include &quot;PageOverlayController.h&quot;
  72 #include &quot;Pasteboard.h&quot;
  73 #include &quot;PlatformEvent.h&quot;
</pre>
<hr />
<pre>
 109 #include &quot;PlatformTouchEventIOS.h&quot;
 110 #endif
 111 
 112 #if ENABLE(TOUCH_EVENTS)
 113 #include &quot;TouchEvent.h&quot;
 114 #include &quot;TouchList.h&quot;
 115 #endif
 116 
 117 #if ENABLE(TOUCH_EVENTS) &amp;&amp; !ENABLE(IOS_TOUCH_EVENTS)
 118 #include &quot;PlatformTouchEvent.h&quot;
 119 #endif
 120 
 121 #if ENABLE(MAC_GESTURE_EVENTS)
 122 #include &quot;PlatformGestureEventMac.h&quot;
 123 #endif
 124 
 125 #if ENABLE(POINTER_LOCK)
 126 #include &quot;PointerLockController.h&quot;
 127 #endif
 128 








 129 namespace WebCore {
 130 
 131 using namespace HTMLNames;
 132 
 133 #if ENABLE(DRAG_SUPPORT)
 134 // The link drag hysteresis is much larger than the others because there
 135 // needs to be enough space to cancel the link press without starting a link drag,
 136 // and because dragging links is rare.
 137 const int LinkDragHysteresis = 40;
 138 const int ImageDragHysteresis = 5;
 139 const int TextDragHysteresis = 3;
 140 const int ColorDragHystersis = 3;
 141 const int GeneralDragHysteresis = 3;
 142 #if PLATFORM(MAC)
 143 const Seconds EventHandler::TextDragDelay { 150_ms };
 144 #else
 145 const Seconds EventHandler::TextDragDelay { 0_s };
 146 #endif
 147 #endif // ENABLE(DRAG_SUPPORT)
 148 
</pre>
<hr />
<pre>
 359 }
 360 
 361 #if ENABLE(DRAG_SUPPORT)
 362 inline bool EventHandler::eventLoopHandleMouseDragged(const MouseEventWithHitTestResults&amp;)
 363 {
 364     return false;
 365 }
 366 #endif
 367 
 368 #endif
 369 
 370 EventHandler::EventHandler(Frame&amp; frame)
 371     : m_frame(frame)
 372     , m_hoverTimer(*this, &amp;EventHandler::hoverTimerFired)
 373 #if ENABLE(CURSOR_SUPPORT)
 374     , m_cursorUpdateTimer(*this, &amp;EventHandler::cursorUpdateTimerFired)
 375 #endif
 376 #if PLATFORM(MAC)
 377     , m_pendingMomentumWheelEventsTimer(*this, &amp;EventHandler::clearLatchedState)
 378 #endif
<span class="line-modified"> 379     , m_autoscrollController(std::make_unique&lt;AutoscrollController&gt;())</span>
 380 #if !ENABLE(IOS_TOUCH_EVENTS)
 381     , m_fakeMouseMoveEventTimer(*this, &amp;EventHandler::fakeMouseMoveEventTimerFired)
 382 #endif
 383 #if ENABLE(CURSOR_VISIBILITY)
 384     , m_autoHideCursorTimer(*this, &amp;EventHandler::autoHideCursorTimerFired)
 385 #endif
 386 {
 387 }
 388 
 389 EventHandler::~EventHandler()
 390 {
 391 #if !ENABLE(IOS_TOUCH_EVENTS)
 392     ASSERT(!m_fakeMouseMoveEventTimer.isActive());
 393 #endif
 394 #if ENABLE(CURSOR_VISIBILITY)
 395     ASSERT(!m_autoHideCursorTimer.isActive());
 396 #endif
 397 }
 398 
 399 #if ENABLE(DRAG_SUPPORT)
</pre>
<hr />
<pre>
 672     bool extendSelection = event.event().shiftKey() &amp;&amp; !event.isOverLink();
 673 
 674     // Don&#39;t restart the selection when the mouse is pressed on an
 675     // existing selection so we can allow for text dragging.
 676     if (FrameView* view = m_frame.view()) {
 677         LayoutPoint vPoint = view-&gt;windowToContents(event.event().position());
 678         if (!extendSelection &amp;&amp; m_frame.selection().contains(vPoint)) {
 679             m_mouseDownWasSingleClickInSelection = true;
 680             return false;
 681         }
 682     }
 683 
 684     VisiblePosition visiblePos(targetNode-&gt;renderer()-&gt;positionForPoint(event.localPoint(), nullptr));
 685     if (visiblePos.isNull())
 686         visiblePos = VisiblePosition(firstPositionInOrBeforeNode(targetNode), DOWNSTREAM);
 687     Position pos = visiblePos.deepEquivalent();
 688 
 689     VisibleSelection newSelection = m_frame.selection().selection();
 690     TextGranularity granularity = CharacterGranularity;
 691 
<span class="line-modified"> 692 #if PLATFORM(IOS_FAMILY)</span>
<span class="line-removed"> 693     // The text selection assistant will handle selection in the case where we are already editing the node</span>
<span class="line-removed"> 694     if (newSelection.rootEditableElement() == targetNode-&gt;rootEditableElement())</span>
 695         return true;
<span class="line-removed"> 696 #endif</span>
 697 
 698     if (extendSelection &amp;&amp; newSelection.isCaretOrRange()) {
 699         VisibleSelection selectionInUserSelectAll = expandSelectionToRespectSelectOnMouseDown(*targetNode, VisibleSelection(pos));
 700         if (selectionInUserSelectAll.isRange()) {
 701             if (comparePositions(selectionInUserSelectAll.start(), newSelection.start()) &lt; 0)
 702                 pos = selectionInUserSelectAll.start();
 703             else if (comparePositions(newSelection.end(), selectionInUserSelectAll.end()) &lt; 0)
 704                 pos = selectionInUserSelectAll.end();
 705         }
 706 
 707         if (!m_frame.editor().behavior().shouldConsiderSelectionAsDirectional() &amp;&amp; pos.isNotNull()) {
 708             // See &lt;rdar://problem/3668157&gt; REGRESSION (Mail): shift-click deselects when selection
 709             // was created right-to-left
 710             Position start = newSelection.start();
 711             Position end = newSelection.end();
 712             int distanceToStart = textDistance(start, pos);
 713             int distanceToEnd = textDistance(pos, end);
 714             if (distanceToStart &lt;= distanceToEnd)
 715                 newSelection = VisibleSelection(end, pos);
 716             else
</pre>
<hr />
<pre>
 758     m_frame.document()-&gt;updateLayoutIgnorePendingStylesheets();
 759 
 760     if (ScrollView* scrollView = m_frame.view()) {
 761         if (scrollView-&gt;isPointInScrollbarCorner(event.event().position()))
 762             return false;
 763     }
 764 
 765     bool singleClick = event.event().clickCount() &lt;= 1;
 766 
 767     // If we got the event back, that must mean it wasn&#39;t prevented,
 768     // so it&#39;s allowed to start a drag or selection if it wasn&#39;t in a scrollbar.
 769     m_mouseDownMayStartSelect = canMouseDownStartSelect(event.targetNode()) &amp;&amp; !event.scrollbar();
 770 
 771 #if ENABLE(DRAG_SUPPORT)
 772     // Careful that the drag starting logic stays in sync with eventMayStartDrag()
 773     // FIXME: eventMayStartDrag() does not check for shift key press, link or image event targets.
 774     // Bug: https://bugs.webkit.org/show_bug.cgi?id=155390
 775 
 776     // Single mouse down on links or images can always trigger drag-n-drop.
 777     bool isMouseDownOnLinkOrImage = event.isOverLink() || event.hitTestResult().image();
<span class="line-modified"> 778     m_mouseDownMayStartDrag = singleClick &amp;&amp; (!event.event().shiftKey() || isMouseDownOnLinkOrImage);</span>
 779 #endif
 780 
 781     m_mouseDownWasSingleClickInSelection = false;
 782 
 783     m_mouseDown = event.event();
 784 
 785     if (m_immediateActionStage != ImmediateActionStage::PerformedHitTest)
 786         m_immediateActionStage = ImmediateActionStage::None;
 787 
 788     if (event.isOverWidget() &amp;&amp; passWidgetMouseDownEventToWidget(event))
 789         return true;
 790 
 791     if (is&lt;SVGDocument&gt;(*m_frame.document()) &amp;&amp; downcast&lt;SVGDocument&gt;(*m_frame.document()).zoomAndPanEnabled()) {
 792         if (event.event().shiftKey() &amp;&amp; singleClick) {
 793             m_svgPan = true;
 794             downcast&lt;SVGDocument&gt;(*m_frame.document()).startPan(m_frame.view()-&gt;windowToContents(event.event().position()));
 795             return true;
 796         }
 797     }
 798 
</pre>
<hr />
<pre>
 829 {
 830     FloatPoint selectionEndPoint = localPoint;
 831     Element* editableElement = selection.rootEditableElement();
 832 
 833     if (!targetNode || !targetNode-&gt;renderer())
 834         return VisiblePosition();
 835 
 836     if (editableElement &amp;&amp; !editableElement-&gt;contains(targetNode)) {
 837         if (!editableElement-&gt;renderer())
 838             return VisiblePosition();
 839 
 840         FloatPoint absolutePoint = targetNode-&gt;renderer()-&gt;localToAbsolute(FloatPoint(selectionEndPoint));
 841         selectionEndPoint = editableElement-&gt;renderer()-&gt;absoluteToLocal(absolutePoint);
 842         targetNode = editableElement;
 843     }
 844 
 845     return targetNode-&gt;renderer()-&gt;positionForPoint(LayoutPoint(selectionEndPoint), nullptr);
 846 }
 847 
 848 #if ENABLE(DRAG_SUPPORT)















 849 bool EventHandler::handleMouseDraggedEvent(const MouseEventWithHitTestResults&amp; event, CheckDragHysteresis checkDragHysteresis)
 850 {
 851     if (!m_mousePressed)
 852         return false;
 853 
 854     Ref&lt;Frame&gt; protectedFrame(m_frame);
 855 
 856     if (handleDrag(event, checkDragHysteresis))
 857         return true;
 858 
 859     Node* targetNode = event.targetNode();
 860     if (event.event().button() != LeftButton || !targetNode)
 861         return false;
 862 
 863     RenderObject* renderer = targetNode-&gt;renderer();
 864     if (!renderer) {
 865         Element* parent = targetNode-&gt;parentOrShadowHostElement();
 866         if (!parent)
 867             return false;
 868 
</pre>
<hr />
<pre>
 908     if (!view)
 909         return false;
 910 
 911     Page* page = m_frame.page();
 912     if (!page)
 913         return false;
 914 
 915     Ref&lt;Frame&gt; protectedFrame(m_frame);
 916 
 917     updateDragSourceActionsAllowed();
 918     HitTestRequest request(HitTestRequest::ReadOnly | HitTestRequest::DisallowUserAgentShadowContent);
 919     HitTestResult result(view-&gt;windowToContents(event.position()));
 920     document-&gt;hitTest(request, result);
 921     DragState state;
 922     Element* targetElement = result.targetElement();
 923     return targetElement &amp;&amp; page-&gt;dragController().draggableElement(&amp;m_frame, targetElement, result.roundedPointInInnerNodeFrame(), state);
 924 }
 925 
 926 void EventHandler::updateSelectionForMouseDrag()
 927 {



 928     FrameView* view = m_frame.view();
 929     if (!view)
 930         return;
 931     auto* document = m_frame.document();
 932     if (!document)
 933         return;
 934 
 935     HitTestRequest request(HitTestRequest::ReadOnly | HitTestRequest::Active | HitTestRequest::Move | HitTestRequest::DisallowUserAgentShadowContent);
 936     HitTestResult result(view-&gt;windowToContents(m_lastKnownMousePosition));
 937     document-&gt;hitTest(request, result);
 938     updateSelectionForMouseDrag(result);
 939 }
 940 
 941 void EventHandler::updateSelectionForMouseDrag(const HitTestResult&amp; hitTestResult)
 942 {



 943     if (!m_mouseDownMayStartSelect)
 944         return;
 945 
 946     Node* target = hitTestResult.targetNode();
 947     if (!target)
 948         return;
 949 
 950     VisiblePosition targetPosition = selectionExtentRespectingEditingBoundary(m_frame.selection().selection(), hitTestResult.localPoint(), target);
 951 
 952     // Don&#39;t modify the selection if we&#39;re not on a node.
 953     if (targetPosition.isNull())
 954         return;
 955 
 956     // Restart the selection if this is the first mouse move. This work is usually
 957     // done in handleMousePressEvent, but not if the mouse press was on an existing selection.
 958     VisibleSelection newSelection = m_frame.selection().selection();
 959 
 960     // Special case to limit selection to the containing block for SVG text.
 961     // FIXME: Isn&#39;t there a better non-SVG-specific way to do this?
 962     if (Node* selectionBaseNode = newSelection.base().deprecatedNode()) {
</pre>
<hr />
<pre>
1163         FrameView* frameView = m_frame.view();
1164         FrameView* mainView = mainFrame.view();
1165         if (frameView &amp;&amp; mainView) {
1166             IntPoint mainFramePoint = mainView-&gt;rootViewToContents(frameView-&gt;contentsToRootView(roundedIntPoint(point)));
1167             return mainFrame.eventHandler().hitTestResultAtPoint(mainFramePoint, hitType, padding);
1168         }
1169     }
1170 
1171     unsigned nonNegativePaddingWidth = std::max&lt;LayoutUnit&gt;(0, padding.width()).toUnsigned();
1172     unsigned nonNegativePaddingHeight = std::max&lt;LayoutUnit&gt;(0, padding.height()).toUnsigned();
1173 
1174     // We should always start hit testing a clean tree.
1175     if (auto* frameView = m_frame.view())
1176         frameView-&gt;updateLayoutAndStyleIfNeededRecursive();
1177 
1178     HitTestResult result(point, nonNegativePaddingHeight, nonNegativePaddingWidth, nonNegativePaddingHeight, nonNegativePaddingWidth);
1179     auto* document = m_frame.document();
1180     if (!document)
1181         return result;
1182 
<span class="line-modified">1183     // hitTestResultAtPoint is specifically used to hitTest into all frames, thus it always allows child frame content.</span>
<span class="line-removed">1184     HitTestRequest request(hitType | HitTestRequest::AllowChildFrameContent);</span>
1185     document-&gt;hitTest(request, result);
1186     if (!request.readOnly())
1187         m_frame.document()-&gt;updateHoverActiveState(request, result.targetElement());
1188 
1189     if (request.disallowsUserAgentShadowContent())
1190         result.setToNonUserAgentShadowAncestor();
1191 
1192     return result;
1193 }
1194 
1195 void EventHandler::stopAutoscrollTimer(bool rendererIsBeingDestroyed)
1196 {
1197     m_autoscrollController-&gt;stopAutoscrollTimer(rendererIsBeingDestroyed);
1198 }
1199 
1200 bool EventHandler::scrollOverflow(ScrollDirection direction, ScrollGranularity granularity, Node* startingNode)
1201 {
1202     Node* node = startingNode;
1203 
1204     if (!node)
</pre>
<hr />
<pre>
1961         hitType |= HitTestRequest::Active | HitTestRequest::ReadOnly;
1962 #endif
1963     HitTestRequest request(hitType);
1964     MouseEventWithHitTestResults mouseEvent = prepareMouseEvent(request, platformMouseEvent);
1965     if (hoveredNode)
1966         *hoveredNode = mouseEvent.hitTestResult();
1967 
1968     if (m_resizeLayer &amp;&amp; m_resizeLayer-&gt;inResizeMode())
1969         m_resizeLayer-&gt;resize(platformMouseEvent, m_offsetFromResizeCorner);
1970     else {
1971         Scrollbar* scrollbar = mouseEvent.scrollbar();
1972         updateLastScrollbarUnderMouse(scrollbar, m_mousePressed ? SetOrClearLastScrollbar::Clear : SetOrClearLastScrollbar::Set);
1973 
1974         // On iOS, our scrollbars are managed by UIKit.
1975 #if !PLATFORM(IOS_FAMILY)
1976         if (!m_mousePressed &amp;&amp; scrollbar)
1977             scrollbar-&gt;mouseMoved(platformMouseEvent); // Handle hover effects on platforms that support visual feedback on scrollbar hovering.
1978 #endif
1979         if (onlyUpdateScrollbars) {
1980             if (shouldSendMouseEventsToInactiveWindows())
<span class="line-modified">1981                 updateMouseEventTargetNode(mouseEvent.targetNode(), platformMouseEvent, true);</span>
1982 
1983             return true;
1984         }
1985     }
1986 
1987     bool swallowEvent = false;
1988     RefPtr&lt;Frame&gt; newSubframe = m_capturingMouseEventsElement.get() ? subframeForTargetNode(m_capturingMouseEventsElement.get()) : subframeForHitTestResult(mouseEvent);
1989 
1990     // We want mouseouts to happen first, from the inside out.  First send a move event to the last subframe so that it will fire mouseouts.
1991     if (m_lastMouseMoveEventSubframe &amp;&amp; m_lastMouseMoveEventSubframe-&gt;tree().isDescendantOf(&amp;m_frame) &amp;&amp; m_lastMouseMoveEventSubframe != newSubframe)
1992         passMouseMoveEventToSubframe(mouseEvent, m_lastMouseMoveEventSubframe.get());
1993 
1994     if (newSubframe) {
1995         // Update over/out state before passing the event to the subframe.
<span class="line-modified">1996         updateMouseEventTargetNode(mouseEvent.targetNode(), platformMouseEvent, true);</span>
1997 
1998         // Event dispatch in updateMouseEventTargetNode may have caused the subframe of the target
1999         // node to be detached from its FrameView, in which case the event should not be passed.
2000         if (newSubframe-&gt;view())
2001             swallowEvent |= passMouseMoveEventToSubframe(mouseEvent, newSubframe.get(), hoveredNode);
2002     }
2003 
2004     if (!newSubframe || mouseEvent.scrollbar()) {
2005 #if ENABLE(CURSOR_SUPPORT)
2006         if (auto* view = m_frame.view())
2007             updateCursor(*view, mouseEvent.hitTestResult(), platformMouseEvent.shiftKey());
2008 #endif
2009     }
2010 
2011     m_lastMouseMoveEventSubframe = newSubframe;
2012 
2013     if (swallowEvent)
2014         return true;
2015 
2016     swallowEvent = !dispatchMouseEvent(eventNames().mousemoveEvent, mouseEvent.targetNode(), false, 0, platformMouseEvent, true);
</pre>
<hr />
<pre>
2209 #if PLATFORM(GTK)
2210     if (platformMouseEvent.type() != PlatformEvent::MousePressed)
2211         return false;
2212 #else
2213     if (platformMouseEvent.type() != PlatformEvent::MouseReleased)
2214         return false;
2215 #endif
2216 
2217     if (!m_frame.page())
2218         return false;
2219     Frame&amp; focusFrame = m_frame.page()-&gt;focusController().focusedOrMainFrame();
2220     // Do not paste here if the focus was moved somewhere else.
2221     if (&amp;m_frame == &amp;focusFrame &amp;&amp; m_frame.editor().client()-&gt;supportsGlobalSelection())
2222         return m_frame.editor().command(&quot;PasteGlobalSelection&quot;_s).execute();
2223 
2224     return false;
2225 }
2226 
2227 #if ENABLE(DRAG_SUPPORT)
2228 
<span class="line-modified">2229 bool EventHandler::dispatchDragEvent(const AtomicString&amp; eventType, Element&amp; dragTarget, const PlatformMouseEvent&amp; event, DataTransfer&amp; dataTransfer)</span>
2230 {
2231     Ref&lt;Frame&gt; protectedFrame(m_frame);
2232     FrameView* view = m_frame.view();
2233 
2234     // FIXME: We might want to dispatch a dragleave even if the view is gone.
2235     if (!view)
2236         return false;
2237 
2238     view-&gt;disableLayerFlushThrottlingTemporarilyForInteraction();
2239     // FIXME: Use MouseEvent::create which takes PlatformMouseEvent.
2240     Ref&lt;MouseEvent&gt; me = MouseEvent::create(eventType, Event::CanBubble::Yes, Event::IsCancelable::Yes, Event::IsComposed::Yes,
2241         event.timestamp().approximateMonotonicTime(), &amp;m_frame.windowProxy(), 0,
2242         event.globalPosition(), event.position(),
2243 #if ENABLE(POINTER_LOCK)
2244         event.movementDelta(),
2245 #else
2246         { },
2247 #endif
2248         event.modifiers(), 0, 0, nullptr, event.force(), NoTap, &amp;dataTransfer);
2249 
</pre>
<hr />
<pre>
2304         bool matched = false;
2305         DragOperation dragOperation = DragOperationNone;
2306         for (unsigned i = 0, size = keywords.size(); i &lt; size; ++i) {
2307             DragOperation op = convertDropZoneOperationToDragOperation(keywords[i]);
2308             if (op != DragOperationNone) {
2309                 if (dragOperation == DragOperationNone)
2310                     dragOperation = op;
2311             } else
2312                 matched = matched || hasDropZoneType(dataTransfer, keywords[i].string());
2313             if (matched &amp;&amp; dragOperation != DragOperationNone)
2314                 break;
2315         }
2316         if (matched) {
2317             dataTransfer.setDropEffect(convertDragOperationToDropZoneOperation(dragOperation));
2318             return true;
2319         }
2320     }
2321     return false;
2322 }
2323 
<span class="line-modified">2324 EventHandler::DragTargetResponse EventHandler::dispatchDragEnterOrDragOverEvent(const AtomicString&amp; eventType, Element&amp; target, const PlatformMouseEvent&amp; event,</span>
2325     std::unique_ptr&lt;Pasteboard&gt;&amp;&amp; pasteboard, DragOperation sourceOperation, bool draggingFiles)
2326 {
2327     auto dataTransfer = DataTransfer::createForUpdatingDropTarget(target.document(), WTFMove(pasteboard), sourceOperation, draggingFiles);
2328     bool accept = dispatchDragEvent(eventType, target, event, dataTransfer.get());
2329     if (!accept)
2330         accept = findDropZone(target, dataTransfer);
2331     dataTransfer-&gt;makeInvalidForSecurity();
2332     if (accept &amp;&amp; !dataTransfer-&gt;dropEffectIsUninitialized())
2333         return { true, dataTransfer-&gt;destinationOperation() };
2334     return { accept, WTF::nullopt };
2335 }
2336 
2337 EventHandler::DragTargetResponse EventHandler::updateDragAndDrop(const PlatformMouseEvent&amp; event, const std::function&lt;std::unique_ptr&lt;Pasteboard&gt;()&gt;&amp; makePasteboard, DragOperation sourceOperation, bool draggingFiles)
2338 {
2339     Ref&lt;Frame&gt; protectedFrame(m_frame);
2340     if (!m_frame.view())
2341         return { };
2342 
2343     HitTestRequest request(HitTestRequest::ReadOnly | HitTestRequest::DisallowUserAgentShadowContent);
2344     MouseEventWithHitTestResults mouseEvent = prepareMouseEvent(request, event);
</pre>
<hr />
<pre>
2443 
2444 void EventHandler::clearDragState()
2445 {
2446     stopAutoscrollTimer();
2447     m_dragTarget = nullptr;
2448     m_capturingMouseEventsElement = nullptr;
2449     m_shouldOnlyFireDragOverEvent = false;
2450 #if PLATFORM(COCOA)
2451     m_sendingEventToSubview = false;
2452 #endif
2453 }
2454 
2455 #endif // ENABLE(DRAG_SUPPORT)
2456 
2457 void EventHandler::setCapturingMouseEventsElement(Element* element)
2458 {
2459     m_capturingMouseEventsElement = element;
2460     m_eventHandlerWillResetCapturingMouseEventsElement = false;
2461 }
2462 













2463 MouseEventWithHitTestResults EventHandler::prepareMouseEvent(const HitTestRequest&amp; request, const PlatformMouseEvent&amp; mouseEvent)
2464 {



2465     Ref&lt;Frame&gt; protectedFrame(m_frame);
2466     ASSERT(m_frame.document());
2467     return m_frame.document()-&gt;prepareMouseEvent(request, documentPointForWindowPoint(m_frame, mouseEvent.position()), mouseEvent);
2468 }
2469 
<span class="line-modified">2470 static bool hierarchyHasCapturingEventListeners(Element* element, const AtomicString&amp; eventName)</span>
2471 {
2472     for (ContainerNode* curr = element; curr; curr = curr-&gt;parentInComposedTree()) {
<span class="line-modified">2473         if (curr-&gt;hasCapturingEventListeners(eventName))</span>
2474             return true;
2475     }
2476     return false;
2477 }
2478 
<span class="line-modified">2479 void EventHandler::updateMouseEventTargetNode(Node* targetNode, const PlatformMouseEvent&amp; platformMouseEvent, bool fireMouseOverOut)</span>
2480 {
2481     Ref&lt;Frame&gt; protectedFrame(m_frame);
2482     Element* targetElement = nullptr;
2483 
2484     // If we&#39;re capturing, we always go right to that element.
2485     if (m_capturingMouseEventsElement)
2486         targetElement = m_capturingMouseEventsElement.get();
2487     else if (targetNode) {
2488         // If the target node is a non-element, dispatch on the parent. &lt;rdar://problem/4196646&gt;
2489         while (targetNode &amp;&amp; !is&lt;Element&gt;(*targetNode))
2490             targetNode = targetNode-&gt;parentInComposedTree();
2491         targetElement = downcast&lt;Element&gt;(targetNode);
2492     }
2493 
2494     m_elementUnderMouse = targetElement;
2495 
2496     // Fire mouseout/mouseover if the mouse has shifted to a different node.
<span class="line-modified">2497     if (fireMouseOverOut) {</span>
2498         auto scrollableAreaForLastNode = enclosingScrollableArea(m_lastElementUnderMouse.get());
2499         auto scrollableAreaForNodeUnderMouse = enclosingScrollableArea(m_elementUnderMouse.get());
2500         Page* page = m_frame.page();
2501 
2502         if (m_lastElementUnderMouse &amp;&amp; (!m_elementUnderMouse || &amp;m_elementUnderMouse-&gt;document() != m_frame.document())) {
2503             // The mouse has moved between frames.
2504             if (Frame* frame = m_lastElementUnderMouse-&gt;document().frame()) {
2505                 if (FrameView* frameView = frame-&gt;view())
2506                     frameView-&gt;mouseExitedContentArea();
2507             }
2508         } else if (page &amp;&amp; (scrollableAreaForLastNode &amp;&amp; (!scrollableAreaForNodeUnderMouse || scrollableAreaForNodeUnderMouse != scrollableAreaForLastNode))) {
2509             // The mouse has moved between layers.
2510             if (Frame* frame = m_lastElementUnderMouse-&gt;document().frame()) {
2511                 if (FrameView* frameView = frame-&gt;view()) {
2512                     if (frameView-&gt;containsScrollableArea(scrollableAreaForLastNode))
2513                         scrollableAreaForLastNode-&gt;mouseExitedContentArea();
2514                 }
2515             }
2516         }
2517 
</pre>
<hr />
<pre>
2523             }
2524         } else if (page &amp;&amp; (scrollableAreaForNodeUnderMouse &amp;&amp; (!scrollableAreaForLastNode || scrollableAreaForNodeUnderMouse != scrollableAreaForLastNode))) {
2525             // The mouse has moved between layers.
2526             if (Frame* frame = m_elementUnderMouse-&gt;document().frame()) {
2527                 if (FrameView* frameView = frame-&gt;view()) {
2528                     if (frameView-&gt;containsScrollableArea(scrollableAreaForNodeUnderMouse))
2529                         scrollableAreaForNodeUnderMouse-&gt;mouseEnteredContentArea();
2530                 }
2531             }
2532         }
2533 
2534         if (m_lastElementUnderMouse &amp;&amp; &amp;m_lastElementUnderMouse-&gt;document() != m_frame.document()) {
2535             m_lastElementUnderMouse = nullptr;
2536             m_lastScrollbarUnderMouse = nullptr;
2537         }
2538 
2539         if (m_lastElementUnderMouse != m_elementUnderMouse) {
2540             // mouseenter and mouseleave events are only dispatched if there is a capturing eventhandler on an ancestor
2541             // or a normal eventhandler on the element itself (they don&#39;t bubble).
2542             // This optimization is necessary since these events can cause O(n^2) capturing event-handler checks.
<span class="line-modified">2543             bool hasCapturingMouseEnterListener = hierarchyHasCapturingEventListeners(m_elementUnderMouse.get(), eventNames().mouseenterEvent);</span>
<span class="line-modified">2544             bool hasCapturingMouseLeaveListener = hierarchyHasCapturingEventListeners(m_lastElementUnderMouse.get(), eventNames().mouseleaveEvent);</span>
2545 
2546             Vector&lt;Ref&lt;Element&gt;, 32&gt; leftElementsChain;
2547             for (Element* element = m_lastElementUnderMouse.get(); element; element = element-&gt;parentElementInComposedTree())
2548                 leftElementsChain.append(*element);
2549             Vector&lt;Ref&lt;Element&gt;, 32&gt; enteredElementsChain;
2550             for (Element* element = m_elementUnderMouse.get(); element; element = element-&gt;parentElementInComposedTree())
2551                 enteredElementsChain.append(*element);
2552 
2553             if (!leftElementsChain.isEmpty() &amp;&amp; !enteredElementsChain.isEmpty() &amp;&amp; leftElementsChain.last().ptr() == enteredElementsChain.last().ptr()) {
2554                 size_t minHeight = std::min(leftElementsChain.size(), enteredElementsChain.size());
2555                 size_t i;
2556                 for (i = 0; i &lt; minHeight; ++i) {
2557                     if (leftElementsChain[leftElementsChain.size() - i - 1].ptr() != enteredElementsChain[enteredElementsChain.size() - i - 1].ptr())
2558                         break;
2559                 }
2560                 leftElementsChain.shrink(leftElementsChain.size() - i);
2561                 enteredElementsChain.shrink(enteredElementsChain.size() - i);
2562             }
2563 
2564             if (m_lastElementUnderMouse)
2565                 m_lastElementUnderMouse-&gt;dispatchMouseEvent(platformMouseEvent, eventNames().mouseoutEvent, 0, m_elementUnderMouse.get());
2566 
2567             for (auto&amp; chain : leftElementsChain) {
<span class="line-modified">2568                 if (hasCapturingMouseLeaveListener || chain-&gt;hasEventListeners(eventNames().mouseleaveEvent))</span>
2569                     chain-&gt;dispatchMouseEvent(platformMouseEvent, eventNames().mouseleaveEvent, 0, m_elementUnderMouse.get());
2570             }
2571 
2572             if (m_elementUnderMouse)
2573                 m_elementUnderMouse-&gt;dispatchMouseEvent(platformMouseEvent, eventNames().mouseoverEvent, 0, m_lastElementUnderMouse.get());
2574 
<span class="line-modified">2575             for (auto&amp; chain : enteredElementsChain) {</span>
<span class="line-modified">2576                 if (hasCapturingMouseEnterListener || chain-&gt;hasEventListeners(eventNames().mouseenterEvent))</span>
2577                     chain-&gt;dispatchMouseEvent(platformMouseEvent, eventNames().mouseenterEvent, 0, m_lastElementUnderMouse.get());
2578             }
2579         }
2580         m_lastElementUnderMouse = m_elementUnderMouse;
2581     }
2582 }
2583 
<span class="line-modified">2584 bool EventHandler::dispatchMouseEvent(const AtomicString&amp; eventType, Node* targetNode, bool /*cancelable*/, int clickCount, const PlatformMouseEvent&amp; platformMouseEvent, bool setUnder)</span>
2585 {
2586     Ref&lt;Frame&gt; protectedFrame(m_frame);
2587 
2588     if (auto* view = m_frame.view())
2589         view-&gt;disableLayerFlushThrottlingTemporarilyForInteraction();
2590 
<span class="line-modified">2591     updateMouseEventTargetNode(targetNode, platformMouseEvent, setUnder);</span>
2592 
2593     if (m_elementUnderMouse &amp;&amp; !m_elementUnderMouse-&gt;dispatchMouseEvent(platformMouseEvent, eventType, clickCount))
2594         return false;
2595 
2596     if (eventType != eventNames().mousedownEvent)
2597         return true;
2598 
2599     // If clicking on a frame scrollbar, do not make any change to which element is focused.
2600     auto* view = m_frame.view();
2601     if (view &amp;&amp; view-&gt;scrollbarAtPoint(platformMouseEvent.position()))
2602         return true;
2603 
2604     // The layout needs to be up to date to determine if an element is focusable.
2605     m_frame.document()-&gt;updateLayoutIgnorePendingStylesheets();
2606 
2607     // Remove focus from the currently focused element when a link or button is clicked.
2608     // This is expected by some sites that rely on change event handlers running
2609     // from form fields before the button click is processed, behavior that was inherited
2610     // from the user interface of Windows, where pushing a button moves focus to the button.
2611 
</pre>
<hr />
<pre>
2732 }
2733 
2734 static WeakPtr&lt;Widget&gt; widgetForElement(const Element&amp; element)
2735 {
2736     auto target = element.renderer();
2737     if (!is&lt;RenderWidget&gt;(target) || !downcast&lt;RenderWidget&gt;(*target).widget())
2738         return { };
2739 
2740     return makeWeakPtr(*downcast&lt;RenderWidget&gt;(*target).widget());
2741 }
2742 
2743 bool EventHandler::completeWidgetWheelEvent(const PlatformWheelEvent&amp; event, const WeakPtr&lt;Widget&gt;&amp; widget, const WeakPtr&lt;ScrollableArea&gt;&amp; scrollableArea, ContainerNode* scrollableContainer)
2744 {
2745     m_isHandlingWheelEvent = false;
2746 
2747     // We do another check on the widget because the event handler can run JS which results in the frame getting destroyed.
2748     if (!widget)
2749         return false;
2750 
2751     if (scrollableArea)
<span class="line-modified">2752         scrollableArea-&gt;setScrolledProgrammatically(false);</span>
2753 
2754     platformNotifyIfEndGesture(event, scrollableArea);
2755 
2756     if (!widget-&gt;platformWidget())
2757         return true;
2758 
2759     return platformCompletePlatformWidgetWheelEvent(event, *widget.get(), scrollableContainer);
2760 }
2761 
2762 bool EventHandler::handleWheelEvent(const PlatformWheelEvent&amp; event)
2763 {
2764     auto* document = m_frame.document();
2765     if (!document)
2766         return false;
2767 
2768     Ref&lt;Frame&gt; protectedFrame(m_frame);
2769     RefPtr&lt;FrameView&gt; protector(m_frame.view());
2770 
2771     FrameView* view = m_frame.view();
2772     if (!view)
</pre>
<hr />
<pre>
2795 #if PLATFORM(MAC)
2796     if (event.phase() == PlatformWheelEventPhaseNone &amp;&amp; event.momentumPhase() == PlatformWheelEventPhaseNone &amp;&amp; m_frame.page())
2797         m_frame.page()-&gt;resetLatchingState();
2798 #endif
2799 
2800     // FIXME: It should not be necessary to do this mutation here.
2801     // Instead, the handlers should know convert vertical scrolls appropriately.
2802     PlatformWheelEvent adjustedEvent = shouldSwapScrollDirection(result, event) ? event.copySwappingDirection() : event;
2803     platformRecordWheelEvent(adjustedEvent);
2804 
2805     if (element) {
2806         if (isOverWidget) {
2807             if (WeakPtr&lt;Widget&gt; widget = widgetForElement(*element)) {
2808                 if (widgetDidHandleWheelEvent(event, *widget.get()))
2809                     return completeWidgetWheelEvent(adjustedEvent, widget, scrollableArea, scrollableContainer.get());
2810             }
2811         }
2812 
2813         if (!element-&gt;dispatchWheelEvent(adjustedEvent)) {
2814             m_isHandlingWheelEvent = false;
<span class="line-modified">2815             if (scrollableArea &amp;&amp; scrollableArea-&gt;isScrolledProgrammatically()) {</span>
2816                 // Web developer is controlling scrolling, so don&#39;t attempt to latch.
2817                 clearLatchedState();
<span class="line-modified">2818                 scrollableArea-&gt;setScrolledProgrammatically(false);</span>
2819             }
2820 
2821             platformNotifyIfEndGesture(adjustedEvent, scrollableArea);
2822             return true;
2823         }
2824     }
2825 
2826     if (scrollableArea)
<span class="line-modified">2827         scrollableArea-&gt;setScrolledProgrammatically(false);</span>
2828 
2829     bool handledEvent = platformCompleteWheelEvent(adjustedEvent, scrollableContainer.get(), scrollableArea);
2830     platformNotifyIfEndGesture(adjustedEvent, scrollableArea);
2831     return handledEvent;
2832 }
2833 
2834 void EventHandler::clearLatchedState()
2835 {
2836     auto* page = m_frame.page();
2837     if (!page)
2838         return;
2839 
2840 #if PLATFORM(MAC)
2841     page-&gt;resetLatchingState();
2842 #endif
2843     if (auto filter = page-&gt;wheelEventDeltaFilter())
2844         filter-&gt;endFilteringDeltas();
2845 }
2846 
2847 void EventHandler::defaultWheelEventHandler(Node* startNode, WheelEvent&amp; wheelEvent)
</pre>
<hr />
<pre>
3117     if ((event.modifiers() - PlatformEvent::Modifier::ShiftKey) != accessKeyModifiers())
3118         return false;
3119     auto* element = m_frame.document()-&gt;elementForAccessKey(event.unmodifiedText());
3120     if (!element)
3121         return false;
3122     element-&gt;accessKeyAction(false);
3123     return true;
3124 }
3125 
3126 #if !PLATFORM(MAC)
3127 bool EventHandler::needsKeyboardEventDisambiguationQuirks() const
3128 {
3129     return false;
3130 }
3131 #endif
3132 
3133 #if ENABLE(FULLSCREEN_API)
3134 bool EventHandler::isKeyEventAllowedInFullScreen(const PlatformKeyboardEvent&amp; keyEvent) const
3135 {
3136     Document* document = m_frame.document();
<span class="line-modified">3137     if (document-&gt;webkitFullScreenKeyboardInputAllowed())</span>
3138         return true;
3139 
3140     if (keyEvent.type() == PlatformKeyboardEvent::Char) {
3141         if (keyEvent.text().length() != 1)
3142             return false;
3143         UChar character = keyEvent.text()[0];
3144         return character == &#39; &#39;;
3145     }
3146 
3147     int keyCode = keyEvent.windowsVirtualKeyCode();
3148     return (keyCode &gt;= VK_BACK &amp;&amp; keyCode &lt;= VK_CAPITAL)
3149         || (keyCode &gt;= VK_SPACE &amp;&amp; keyCode &lt;= VK_DELETE)
3150         || (keyCode &gt;= VK_OEM_1 &amp;&amp; keyCode &lt;= VK_OEM_PLUS)
3151         || (keyCode &gt;= VK_MULTIPLY &amp;&amp; keyCode &lt;= VK_OEM_8);
3152 }
3153 #endif
3154 
3155 bool EventHandler::keyEvent(const PlatformKeyboardEvent&amp; keyEvent)
3156 {
3157     Document* topDocument = m_frame.document() ? &amp;m_frame.document()-&gt;topDocument() : nullptr;
</pre>
<hr />
<pre>
3189 {
3190     Ref&lt;Frame&gt; protectedFrame(m_frame);
3191     RefPtr&lt;FrameView&gt; protector(m_frame.view());
3192 
3193     LOG(Editing, &quot;EventHandler %p keyEvent (text %s keyIdentifier %s)&quot;, this, initialKeyEvent.text().utf8().data(), initialKeyEvent.keyIdentifier().utf8().data());
3194 
3195 #if ENABLE(POINTER_LOCK)
3196     if (initialKeyEvent.type() == PlatformEvent::KeyDown &amp;&amp; initialKeyEvent.windowsVirtualKeyCode() == VK_ESCAPE &amp;&amp; m_frame.page()-&gt;pointerLockController().element()) {
3197         m_frame.page()-&gt;pointerLockController().requestPointerUnlockAndForceCursorVisible();
3198     }
3199 #endif
3200 
3201     if (initialKeyEvent.type() == PlatformEvent::KeyDown &amp;&amp; initialKeyEvent.windowsVirtualKeyCode() == VK_ESCAPE) {
3202         if (auto* page = m_frame.page()) {
3203             if (auto* validationMessageClient = page-&gt;validationMessageClient())
3204                 validationMessageClient-&gt;hideAnyValidationMessage();
3205         }
3206     }
3207 
3208 #if ENABLE(FULLSCREEN_API)
<span class="line-modified">3209     if (m_frame.document()-&gt;webkitIsFullScreen()) {</span>
3210         if (initialKeyEvent.type() == PlatformEvent::KeyDown &amp;&amp; initialKeyEvent.windowsVirtualKeyCode() == VK_ESCAPE) {
<span class="line-modified">3211             m_frame.document()-&gt;webkitCancelFullScreen();</span>
3212             return true;
3213         }
3214 
3215         if (!isKeyEventAllowedInFullScreen(initialKeyEvent))
3216             return false;
3217     }
3218 #endif
3219 
3220     if (initialKeyEvent.windowsVirtualKeyCode() == VK_CAPITAL)
3221         capsLockStateMayHaveChanged();
3222 
3223 #if ENABLE(PAN_SCROLLING)
3224     if (m_frame.mainFrame().eventHandler().panScrollInProgress()) {
3225         // If a key is pressed while the panScroll is in progress then we want to stop
3226         if (initialKeyEvent.type() == PlatformEvent::KeyDown || initialKeyEvent.type() == PlatformEvent::RawKeyDown)
3227             stopAutoscrollTimer();
3228 
3229         // If we were in panscroll mode, we swallow the key event
3230         return true;
3231     }
</pre>
<hr />
<pre>
3282 
3283     // Run input method in advance of DOM event handling.  This may result in the IM
3284     // modifying the page prior the keydown event, but this behaviour is necessary
3285     // in order to match IE:
3286     // 1. preventing default handling of keydown and keypress events has no effect on IM input;
3287     // 2. if an input method handles the event, its keyCode is set to 229 in keydown event.
3288     m_frame.editor().handleInputMethodKeydown(keydown.get());
3289 
3290     bool handledByInputMethod = keydown-&gt;defaultHandled();
3291 
3292     if (handledByInputMethod) {
3293         keyDownEvent.setWindowsVirtualKeyCode(CompositionEventKeyCode);
3294         keydown = KeyboardEvent::create(keyDownEvent, &amp;m_frame.windowProxy());
3295         keydown-&gt;setTarget(element);
3296         keydown-&gt;setIsDefaultEventHandlerIgnored();
3297     }
3298 
3299     if (accessibilityPreventsEventPropagation(keydown))
3300         keydown-&gt;stopPropagation();
3301 




3302     element-&gt;dispatchEvent(keydown);
3303     if (handledByInputMethod)
3304         return true;
3305 
3306     // If frame changed as a result of keydown dispatch, then return early to avoid sending a subsequent keypress message to the new frame.
3307     bool changedFocusedFrame = m_frame.page() &amp;&amp; &amp;m_frame != &amp;m_frame.page()-&gt;focusController().focusedOrMainFrame();
3308     bool keydownResult = keydown-&gt;defaultHandled() || keydown-&gt;defaultPrevented() || changedFocusedFrame;
3309     if (keydownResult &amp;&amp; !backwardCompatibilityMode)
3310         return keydownResult;
3311 
3312     // Focus may have changed during keydown handling, so refetch element.
3313     // But if we are dispatching a fake backward compatibility keypress, then we pretend that the keypress happened on the original element.
3314     if (!keydownResult) {
3315         element = eventTargetElementForDocument(m_frame.document());
3316         if (!element)
3317             return false;
3318     }
3319 
3320     PlatformKeyboardEvent keyPressEvent = initialKeyEvent;
3321     keyPressEvent.disambiguateKeyDownEvent(PlatformEvent::Char, backwardCompatibilityMode);
3322     if (keyPressEvent.text().isEmpty())
3323         return keydownResult;
3324     auto keypress = KeyboardEvent::create(keyPressEvent, &amp;m_frame.windowProxy());
3325     keypress-&gt;setTarget(element);
3326     if (keydownResult)
3327         keypress-&gt;preventDefault();
3328 #if PLATFORM(COCOA)
3329     keypress-&gt;keypressCommands() = keydown-&gt;keypressCommands();
3330 #endif
3331     element-&gt;dispatchEvent(keypress);
3332 
3333     return keydownResult || keypress-&gt;defaultPrevented() || keypress-&gt;defaultHandled();
3334 }
3335 
<span class="line-modified">3336 static FocusDirection focusDirectionForKey(const AtomicString&amp; keyIdentifier)</span>
3337 {
<span class="line-modified">3338     static NeverDestroyed&lt;AtomicString&gt; Down(&quot;Down&quot;, AtomicString::ConstructFromLiteral);</span>
<span class="line-modified">3339     static NeverDestroyed&lt;AtomicString&gt; Up(&quot;Up&quot;, AtomicString::ConstructFromLiteral);</span>
<span class="line-modified">3340     static NeverDestroyed&lt;AtomicString&gt; Left(&quot;Left&quot;, AtomicString::ConstructFromLiteral);</span>
<span class="line-modified">3341     static NeverDestroyed&lt;AtomicString&gt; Right(&quot;Right&quot;, AtomicString::ConstructFromLiteral);</span>
3342 
3343     FocusDirection retVal = FocusDirectionNone;
3344 
3345     if (keyIdentifier == Down)
3346         retVal = FocusDirectionDown;
3347     else if (keyIdentifier == Up)
3348         retVal = FocusDirectionUp;
3349     else if (keyIdentifier == Left)
3350         retVal = FocusDirectionLeft;
3351     else if (keyIdentifier == Right)
3352         retVal = FocusDirectionRight;
3353 
3354     return retVal;
3355 }
3356 
3357 static void setInitialKeyboardSelection(Frame&amp; frame, SelectionDirection direction)
3358 {
3359     Document* document = frame.document();
3360     if (!document)
3361         return;
</pre>
<hr />
<pre>
3598     invalidateDataTransfer();
3599 
3600     if (mayExtendDragSession == MayExtendDragSession::No) {
3601         if (auto* page = m_frame.page())
3602             removeDraggedContentDocumentMarkersFromAllFramesInPage(*page);
3603     }
3604 
3605     dragState().source = nullptr;
3606     // In case the drag was ended due to an escape key press we need to ensure
3607     // that consecutive mousemove events don&#39;t reinitiate the drag and drop.
3608     m_mouseDownMayStartDrag = false;
3609 }
3610 
3611 void EventHandler::updateDragStateAfterEditDragIfNeeded(Element&amp; rootEditableElement)
3612 {
3613     // If inserting the dragged contents removed the drag source, we still want to fire dragend at the root editable element.
3614     if (dragState().source &amp;&amp; !dragState().source-&gt;isConnected())
3615         dragState().source = &amp;rootEditableElement;
3616 }
3617 
<span class="line-modified">3618 void EventHandler::dispatchDragSrcEvent(const AtomicString&amp; eventType, const PlatformMouseEvent&amp; event)</span>
3619 {
3620     ASSERT(dragState().dataTransfer);
3621     dispatchDragEvent(eventType, *dragState().source, event, *dragState().dataTransfer);
3622 }
3623 
3624 bool EventHandler::dispatchDragStartEventOnSourceElement(DataTransfer&amp; dataTransfer)
3625 {
3626     return !dispatchDragEvent(eventNames().dragstartEvent, *dragState().source, m_mouseDown, dataTransfer) &amp;&amp; !m_frame.selection().selection().isInPasswordField();
3627 }
3628 
3629 static bool ExactlyOneBitSet(DragSourceAction n)
3630 {
3631     return n &amp;&amp; !(n &amp; (n - 1));
3632 }
3633 
3634 RefPtr&lt;Element&gt; EventHandler::draggedElement() const
3635 {
3636     return dragState().source;
3637 }
3638 
</pre>
<hr />
<pre>
3705         dragState().type = DragSourceActionSelection;
3706     }
3707 
3708     // We are starting a text/image/url drag, so the cursor should be an arrow
3709     if (FrameView* view = m_frame.view()) {
3710         // FIXME &lt;rdar://7577595&gt;: Custom cursors aren&#39;t supported during drag and drop (default to pointer).
3711         view-&gt;setCursor(pointerCursor());
3712     }
3713 
3714     if (checkDragHysteresis == ShouldCheckDragHysteresis &amp;&amp; !dragHysteresisExceeded(event.event().position()))
3715         return true;
3716 
3717     // Once we&#39;re past the hysteresis point, we don&#39;t want to treat this gesture as a click
3718     invalidateClick();
3719 
3720     DragOperation srcOp = DragOperationNone;
3721 
3722     // This does work only if we missed a dragEnd. Do it anyway, just to make sure the old dataTransfer gets numbed.
3723     invalidateDataTransfer();
3724 
<span class="line-modified">3725     dragState().dataTransfer = DataTransfer::createForDrag();</span>
3726     HasNonDefaultPasteboardData hasNonDefaultPasteboardData = HasNonDefaultPasteboardData::No;
3727 
3728     if (dragState().shouldDispatchEvents) {
3729         ASSERT(dragState().source);
3730         auto dragStartDataTransfer = DataTransfer::createForDragStartEvent(dragState().source-&gt;document());
3731         m_mouseDownMayStartDrag = dispatchDragStartEventOnSourceElement(dragStartDataTransfer);
3732         hasNonDefaultPasteboardData = dragStartDataTransfer-&gt;pasteboard().hasData() ? HasNonDefaultPasteboardData::Yes : HasNonDefaultPasteboardData::No;
3733         dragState().dataTransfer-&gt;moveDragState(WTFMove(dragStartDataTransfer));
3734 
3735         if (dragState().source &amp;&amp; dragState().type == DragSourceActionDHTML &amp;&amp; !dragState().dataTransfer-&gt;hasDragImage()) {
3736             dragState().source-&gt;document().updateStyleIfNeeded();
3737             if (auto* renderer = dragState().source-&gt;renderer()) {
3738                 auto absolutePosition = renderer-&gt;localToAbsolute();
3739                 auto delta = m_mouseDownPos - roundedIntPoint(absolutePosition);
3740                 dragState().dataTransfer-&gt;setDragImage(dragState().source.get(), delta.width(), delta.height());
3741             } else {
3742                 dispatchDragSrcEvent(eventNames().dragendEvent, event.event());
3743                 m_mouseDownMayStartDrag = false;
3744                 invalidateDataTransfer();
3745                 dragState().source = nullptr;
</pre>
<hr />
<pre>
3987 }
3988 
3989 // If scrollbar (under mouse) is different from last, send a mouse exited.
3990 void EventHandler::updateLastScrollbarUnderMouse(Scrollbar* scrollbar, SetOrClearLastScrollbar setOrClear)
3991 {
3992     if (m_lastScrollbarUnderMouse != scrollbar) {
3993         // Send mouse exited to the old scrollbar.
3994         if (m_lastScrollbarUnderMouse)
3995             m_lastScrollbarUnderMouse-&gt;mouseExited();
3996 
3997         // Send mouse entered if we&#39;re setting a new scrollbar.
3998         if (scrollbar &amp;&amp; setOrClear == SetOrClearLastScrollbar::Set) {
3999             scrollbar-&gt;mouseEntered();
4000             m_lastScrollbarUnderMouse = makeWeakPtr(*scrollbar);
4001         } else
4002             m_lastScrollbarUnderMouse = nullptr;
4003     }
4004 }
4005 
4006 #if ENABLE(TOUCH_EVENTS) &amp;&amp; !ENABLE(IOS_TOUCH_EVENTS)
<span class="line-modified">4007 static const AtomicString&amp; eventNameForTouchPointState(PlatformTouchPoint::State state)</span>
4008 {
4009     switch (state) {
4010     case PlatformTouchPoint::TouchReleased:
4011         return eventNames().touchendEvent;
4012     case PlatformTouchPoint::TouchCancelled:
4013         return eventNames().touchcancelEvent;
4014     case PlatformTouchPoint::TouchPressed:
4015         return eventNames().touchstartEvent;
4016     case PlatformTouchPoint::TouchMoved:
4017         return eventNames().touchmoveEvent;
4018     case PlatformTouchPoint::TouchStationary:
4019         // TouchStationary state is not converted to touch events, so fall through to assert.
4020     default:
4021         ASSERT_NOT_REACHED();
4022         return emptyAtom();
4023     }
4024 }
4025 
4026 static HitTestResult hitTestResultInFrame(Frame* frame, const LayoutPoint&amp; point, HitTestRequest::HitTestRequestType hitType)
4027 {
</pre>
<hr />
<pre>
4098         case PlatformTouchPoint::TouchCancelled:
4099             hitType |= HitTestRequest::Release;
4100             break;
4101         case PlatformTouchPoint::TouchStationary:
4102             hitType |= HitTestRequest::Active | HitTestRequest::ReadOnly;
4103             break;
4104         default:
4105             ASSERT_NOT_REACHED();
4106             break;
4107         }
4108 
4109         if (shouldGesturesTriggerActive())
4110             hitType |= HitTestRequest::ReadOnly;
4111 
4112         // Increment the platform touch id by 1 to avoid storing a key of 0 in the hashmap.
4113         unsigned touchPointTargetKey = point.id() + 1;
4114         RefPtr&lt;EventTarget&gt; touchTarget;
4115         if (pointState == PlatformTouchPoint::TouchPressed) {
4116             HitTestResult result;
4117             if (freshTouchEvents) {
<span class="line-modified">4118                 result = hitTestResultAtPoint(pagePoint, hitType);</span>
4119                 m_originatingTouchPointTargetKey = touchPointTargetKey;
4120             } else if (m_originatingTouchPointDocument.get() &amp;&amp; m_originatingTouchPointDocument-&gt;frame()) {
4121                 LayoutPoint pagePointInOriginatingDocument = documentPointForWindowPoint(*m_originatingTouchPointDocument-&gt;frame(), point.pos());
4122                 result = hitTestResultInFrame(m_originatingTouchPointDocument-&gt;frame(), pagePointInOriginatingDocument, hitType);
4123                 if (!result.innerNode())
4124                     continue;
4125             } else
4126                 continue;
4127 
4128             Element* element = result.targetElement();
4129             ASSERT(element);
4130 
4131             if (element &amp;&amp; InspectorInstrumentation::handleTouchEvent(m_frame, *element))
4132                 return true;
4133 
4134             Document&amp; doc = element-&gt;document();
4135             // Record the originating touch document even if it does not have a touch listener.
4136             if (freshTouchEvents) {
4137                 m_originatingTouchPointDocument = &amp;doc;
4138                 freshTouchEvents = false;
</pre>
<hr />
<pre>
4201             if (!changedTouches[pointState].m_touches)
4202                 changedTouches[pointState].m_touches = TouchList::create();
4203             changedTouches[pointState].m_touches-&gt;append(WTFMove(touch));
4204             changedTouches[pointState].m_targets.add(touchTarget);
4205         }
4206     }
4207     m_touchPressed = touches-&gt;length() &gt; 0;
4208     if (allTouchReleased)
4209         m_originatingTouchPointDocument = nullptr;
4210 
4211     // Now iterate the changedTouches list and m_targets within it, sending events to the targets as required.
4212     bool swallowedEvent = false;
4213     RefPtr&lt;TouchList&gt; emptyList = TouchList::create();
4214     for (unsigned state = 0; state != PlatformTouchPoint::TouchStateEnd; ++state) {
4215         if (!changedTouches[state].m_touches)
4216             continue;
4217 
4218         // When sending a touch cancel event, use empty touches and targetTouches lists.
4219         bool isTouchCancelEvent = (state == PlatformTouchPoint::TouchCancelled);
4220         RefPtr&lt;TouchList&gt;&amp; effectiveTouches(isTouchCancelEvent ? emptyList : touches);
<span class="line-modified">4221         const AtomicString&amp; stateName(eventNameForTouchPointState(static_cast&lt;PlatformTouchPoint::State&gt;(state)));</span>
4222 
4223         for (auto&amp; target : changedTouches[state].m_targets) {
4224             ASSERT(is&lt;Node&gt;(target));
4225 
4226             RefPtr&lt;TouchList&gt; targetTouches(isTouchCancelEvent ? emptyList : touchesByTarget.get(target.get()));
4227             ASSERT(targetTouches);
4228 
4229             Ref&lt;TouchEvent&gt; touchEvent = TouchEvent::create(effectiveTouches.get(), targetTouches.get(), changedTouches[state].m_touches.get(),
4230                 stateName, downcast&lt;Node&gt;(*target).document().windowProxy(), { }, event.modifiers());
4231             target-&gt;dispatchEvent(touchEvent);
4232             swallowedEvent = swallowedEvent || touchEvent-&gt;defaultPrevented() || touchEvent-&gt;defaultHandled();
4233         }
4234     }
4235 
4236     return swallowedEvent;
4237 }
4238 #endif // ENABLE(TOUCH_EVENTS) &amp;&amp; !ENABLE(IOS_TOUCH_EVENTS)
4239 
4240 #if ENABLE(TOUCH_EVENTS)
4241 bool EventHandler::dispatchSyntheticTouchEventIfEnabled(const PlatformMouseEvent&amp; platformMouseEvent)
</pre>
</td>
<td>
<hr />
<pre>
  34 #include &quot;Chrome.h&quot;
  35 #include &quot;ChromeClient.h&quot;
  36 #include &quot;ComposedTreeAncestorIterator.h&quot;
  37 #include &quot;CursorList.h&quot;
  38 #include &quot;DocumentMarkerController.h&quot;
  39 #include &quot;DragController.h&quot;
  40 #include &quot;DragState.h&quot;
  41 #include &quot;Editing.h&quot;
  42 #include &quot;Editor.h&quot;
  43 #include &quot;EditorClient.h&quot;
  44 #include &quot;EventNames.h&quot;
  45 #include &quot;FileList.h&quot;
  46 #include &quot;FloatPoint.h&quot;
  47 #include &quot;FloatRect.h&quot;
  48 #include &quot;FocusController.h&quot;
  49 #include &quot;Frame.h&quot;
  50 #include &quot;FrameLoader.h&quot;
  51 #include &quot;FrameSelection.h&quot;
  52 #include &quot;FrameTree.h&quot;
  53 #include &quot;FrameView.h&quot;
<span class="line-added">  54 #include &quot;FullscreenManager.h&quot;</span>
  55 #include &quot;HTMLDocument.h&quot;
  56 #include &quot;HTMLFrameElement.h&quot;
  57 #include &quot;HTMLFrameSetElement.h&quot;
  58 #include &quot;HTMLHtmlElement.h&quot;
  59 #include &quot;HTMLIFrameElement.h&quot;
  60 #include &quot;HTMLInputElement.h&quot;
  61 #include &quot;HTMLNames.h&quot;
  62 #include &quot;HitTestRequest.h&quot;
  63 #include &quot;HitTestResult.h&quot;
  64 #include &quot;Image.h&quot;
  65 #include &quot;InspectorInstrumentation.h&quot;
  66 #include &quot;KeyboardEvent.h&quot;
  67 #include &quot;Logging.h&quot;
  68 #include &quot;MouseEvent.h&quot;
  69 #include &quot;MouseEventWithHitTestResults.h&quot;
  70 #include &quot;NotImplemented.h&quot;
  71 #include &quot;Page.h&quot;
  72 #include &quot;PageOverlayController.h&quot;
  73 #include &quot;Pasteboard.h&quot;
  74 #include &quot;PlatformEvent.h&quot;
</pre>
<hr />
<pre>
 110 #include &quot;PlatformTouchEventIOS.h&quot;
 111 #endif
 112 
 113 #if ENABLE(TOUCH_EVENTS)
 114 #include &quot;TouchEvent.h&quot;
 115 #include &quot;TouchList.h&quot;
 116 #endif
 117 
 118 #if ENABLE(TOUCH_EVENTS) &amp;&amp; !ENABLE(IOS_TOUCH_EVENTS)
 119 #include &quot;PlatformTouchEvent.h&quot;
 120 #endif
 121 
 122 #if ENABLE(MAC_GESTURE_EVENTS)
 123 #include &quot;PlatformGestureEventMac.h&quot;
 124 #endif
 125 
 126 #if ENABLE(POINTER_LOCK)
 127 #include &quot;PointerLockController.h&quot;
 128 #endif
 129 
<span class="line-added"> 130 #if ENABLE(POINTER_EVENTS)</span>
<span class="line-added"> 131 #include &quot;RuntimeEnabledFeatures.h&quot;</span>
<span class="line-added"> 132 #endif</span>
<span class="line-added"> 133 </span>
<span class="line-added"> 134 #if PLATFORM(IOS_FAMILY)</span>
<span class="line-added"> 135 #include &quot;DOMTimerHoldingTank.h&quot;</span>
<span class="line-added"> 136 #endif</span>
<span class="line-added"> 137 </span>
 138 namespace WebCore {
 139 
 140 using namespace HTMLNames;
 141 
 142 #if ENABLE(DRAG_SUPPORT)
 143 // The link drag hysteresis is much larger than the others because there
 144 // needs to be enough space to cancel the link press without starting a link drag,
 145 // and because dragging links is rare.
 146 const int LinkDragHysteresis = 40;
 147 const int ImageDragHysteresis = 5;
 148 const int TextDragHysteresis = 3;
 149 const int ColorDragHystersis = 3;
 150 const int GeneralDragHysteresis = 3;
 151 #if PLATFORM(MAC)
 152 const Seconds EventHandler::TextDragDelay { 150_ms };
 153 #else
 154 const Seconds EventHandler::TextDragDelay { 0_s };
 155 #endif
 156 #endif // ENABLE(DRAG_SUPPORT)
 157 
</pre>
<hr />
<pre>
 368 }
 369 
 370 #if ENABLE(DRAG_SUPPORT)
 371 inline bool EventHandler::eventLoopHandleMouseDragged(const MouseEventWithHitTestResults&amp;)
 372 {
 373     return false;
 374 }
 375 #endif
 376 
 377 #endif
 378 
 379 EventHandler::EventHandler(Frame&amp; frame)
 380     : m_frame(frame)
 381     , m_hoverTimer(*this, &amp;EventHandler::hoverTimerFired)
 382 #if ENABLE(CURSOR_SUPPORT)
 383     , m_cursorUpdateTimer(*this, &amp;EventHandler::cursorUpdateTimerFired)
 384 #endif
 385 #if PLATFORM(MAC)
 386     , m_pendingMomentumWheelEventsTimer(*this, &amp;EventHandler::clearLatchedState)
 387 #endif
<span class="line-modified"> 388     , m_autoscrollController(makeUnique&lt;AutoscrollController&gt;())</span>
 389 #if !ENABLE(IOS_TOUCH_EVENTS)
 390     , m_fakeMouseMoveEventTimer(*this, &amp;EventHandler::fakeMouseMoveEventTimerFired)
 391 #endif
 392 #if ENABLE(CURSOR_VISIBILITY)
 393     , m_autoHideCursorTimer(*this, &amp;EventHandler::autoHideCursorTimerFired)
 394 #endif
 395 {
 396 }
 397 
 398 EventHandler::~EventHandler()
 399 {
 400 #if !ENABLE(IOS_TOUCH_EVENTS)
 401     ASSERT(!m_fakeMouseMoveEventTimer.isActive());
 402 #endif
 403 #if ENABLE(CURSOR_VISIBILITY)
 404     ASSERT(!m_autoHideCursorTimer.isActive());
 405 #endif
 406 }
 407 
 408 #if ENABLE(DRAG_SUPPORT)
</pre>
<hr />
<pre>
 681     bool extendSelection = event.event().shiftKey() &amp;&amp; !event.isOverLink();
 682 
 683     // Don&#39;t restart the selection when the mouse is pressed on an
 684     // existing selection so we can allow for text dragging.
 685     if (FrameView* view = m_frame.view()) {
 686         LayoutPoint vPoint = view-&gt;windowToContents(event.event().position());
 687         if (!extendSelection &amp;&amp; m_frame.selection().contains(vPoint)) {
 688             m_mouseDownWasSingleClickInSelection = true;
 689             return false;
 690         }
 691     }
 692 
 693     VisiblePosition visiblePos(targetNode-&gt;renderer()-&gt;positionForPoint(event.localPoint(), nullptr));
 694     if (visiblePos.isNull())
 695         visiblePos = VisiblePosition(firstPositionInOrBeforeNode(targetNode), DOWNSTREAM);
 696     Position pos = visiblePos.deepEquivalent();
 697 
 698     VisibleSelection newSelection = m_frame.selection().selection();
 699     TextGranularity granularity = CharacterGranularity;
 700 
<span class="line-modified"> 701     if (!m_frame.editor().client()-&gt;shouldAllowSingleClickToChangeSelection(*targetNode, newSelection))</span>


 702         return true;

 703 
 704     if (extendSelection &amp;&amp; newSelection.isCaretOrRange()) {
 705         VisibleSelection selectionInUserSelectAll = expandSelectionToRespectSelectOnMouseDown(*targetNode, VisibleSelection(pos));
 706         if (selectionInUserSelectAll.isRange()) {
 707             if (comparePositions(selectionInUserSelectAll.start(), newSelection.start()) &lt; 0)
 708                 pos = selectionInUserSelectAll.start();
 709             else if (comparePositions(newSelection.end(), selectionInUserSelectAll.end()) &lt; 0)
 710                 pos = selectionInUserSelectAll.end();
 711         }
 712 
 713         if (!m_frame.editor().behavior().shouldConsiderSelectionAsDirectional() &amp;&amp; pos.isNotNull()) {
 714             // See &lt;rdar://problem/3668157&gt; REGRESSION (Mail): shift-click deselects when selection
 715             // was created right-to-left
 716             Position start = newSelection.start();
 717             Position end = newSelection.end();
 718             int distanceToStart = textDistance(start, pos);
 719             int distanceToEnd = textDistance(pos, end);
 720             if (distanceToStart &lt;= distanceToEnd)
 721                 newSelection = VisibleSelection(end, pos);
 722             else
</pre>
<hr />
<pre>
 764     m_frame.document()-&gt;updateLayoutIgnorePendingStylesheets();
 765 
 766     if (ScrollView* scrollView = m_frame.view()) {
 767         if (scrollView-&gt;isPointInScrollbarCorner(event.event().position()))
 768             return false;
 769     }
 770 
 771     bool singleClick = event.event().clickCount() &lt;= 1;
 772 
 773     // If we got the event back, that must mean it wasn&#39;t prevented,
 774     // so it&#39;s allowed to start a drag or selection if it wasn&#39;t in a scrollbar.
 775     m_mouseDownMayStartSelect = canMouseDownStartSelect(event.targetNode()) &amp;&amp; !event.scrollbar();
 776 
 777 #if ENABLE(DRAG_SUPPORT)
 778     // Careful that the drag starting logic stays in sync with eventMayStartDrag()
 779     // FIXME: eventMayStartDrag() does not check for shift key press, link or image event targets.
 780     // Bug: https://bugs.webkit.org/show_bug.cgi?id=155390
 781 
 782     // Single mouse down on links or images can always trigger drag-n-drop.
 783     bool isMouseDownOnLinkOrImage = event.isOverLink() || event.hitTestResult().image();
<span class="line-modified"> 784     m_mouseDownMayStartDrag = singleClick &amp;&amp; (!event.event().shiftKey() || isMouseDownOnLinkOrImage) &amp;&amp; shouldAllowMouseDownToStartDrag();</span>
 785 #endif
 786 
 787     m_mouseDownWasSingleClickInSelection = false;
 788 
 789     m_mouseDown = event.event();
 790 
 791     if (m_immediateActionStage != ImmediateActionStage::PerformedHitTest)
 792         m_immediateActionStage = ImmediateActionStage::None;
 793 
 794     if (event.isOverWidget() &amp;&amp; passWidgetMouseDownEventToWidget(event))
 795         return true;
 796 
 797     if (is&lt;SVGDocument&gt;(*m_frame.document()) &amp;&amp; downcast&lt;SVGDocument&gt;(*m_frame.document()).zoomAndPanEnabled()) {
 798         if (event.event().shiftKey() &amp;&amp; singleClick) {
 799             m_svgPan = true;
 800             downcast&lt;SVGDocument&gt;(*m_frame.document()).startPan(m_frame.view()-&gt;windowToContents(event.event().position()));
 801             return true;
 802         }
 803     }
 804 
</pre>
<hr />
<pre>
 835 {
 836     FloatPoint selectionEndPoint = localPoint;
 837     Element* editableElement = selection.rootEditableElement();
 838 
 839     if (!targetNode || !targetNode-&gt;renderer())
 840         return VisiblePosition();
 841 
 842     if (editableElement &amp;&amp; !editableElement-&gt;contains(targetNode)) {
 843         if (!editableElement-&gt;renderer())
 844             return VisiblePosition();
 845 
 846         FloatPoint absolutePoint = targetNode-&gt;renderer()-&gt;localToAbsolute(FloatPoint(selectionEndPoint));
 847         selectionEndPoint = editableElement-&gt;renderer()-&gt;absoluteToLocal(absolutePoint);
 848         targetNode = editableElement;
 849     }
 850 
 851     return targetNode-&gt;renderer()-&gt;positionForPoint(LayoutPoint(selectionEndPoint), nullptr);
 852 }
 853 
 854 #if ENABLE(DRAG_SUPPORT)
<span class="line-added"> 855 </span>
<span class="line-added"> 856 #if !PLATFORM(IOS_FAMILY)</span>
<span class="line-added"> 857 </span>
<span class="line-added"> 858 bool EventHandler::supportsSelectionUpdatesOnMouseDrag() const</span>
<span class="line-added"> 859 {</span>
<span class="line-added"> 860     return true;</span>
<span class="line-added"> 861 }</span>
<span class="line-added"> 862 </span>
<span class="line-added"> 863 bool EventHandler::shouldAllowMouseDownToStartDrag() const</span>
<span class="line-added"> 864 {</span>
<span class="line-added"> 865     return true;</span>
<span class="line-added"> 866 }</span>
<span class="line-added"> 867 </span>
<span class="line-added"> 868 #endif</span>
<span class="line-added"> 869 </span>
 870 bool EventHandler::handleMouseDraggedEvent(const MouseEventWithHitTestResults&amp; event, CheckDragHysteresis checkDragHysteresis)
 871 {
 872     if (!m_mousePressed)
 873         return false;
 874 
 875     Ref&lt;Frame&gt; protectedFrame(m_frame);
 876 
 877     if (handleDrag(event, checkDragHysteresis))
 878         return true;
 879 
 880     Node* targetNode = event.targetNode();
 881     if (event.event().button() != LeftButton || !targetNode)
 882         return false;
 883 
 884     RenderObject* renderer = targetNode-&gt;renderer();
 885     if (!renderer) {
 886         Element* parent = targetNode-&gt;parentOrShadowHostElement();
 887         if (!parent)
 888             return false;
 889 
</pre>
<hr />
<pre>
 929     if (!view)
 930         return false;
 931 
 932     Page* page = m_frame.page();
 933     if (!page)
 934         return false;
 935 
 936     Ref&lt;Frame&gt; protectedFrame(m_frame);
 937 
 938     updateDragSourceActionsAllowed();
 939     HitTestRequest request(HitTestRequest::ReadOnly | HitTestRequest::DisallowUserAgentShadowContent);
 940     HitTestResult result(view-&gt;windowToContents(event.position()));
 941     document-&gt;hitTest(request, result);
 942     DragState state;
 943     Element* targetElement = result.targetElement();
 944     return targetElement &amp;&amp; page-&gt;dragController().draggableElement(&amp;m_frame, targetElement, result.roundedPointInInnerNodeFrame(), state);
 945 }
 946 
 947 void EventHandler::updateSelectionForMouseDrag()
 948 {
<span class="line-added"> 949     if (!supportsSelectionUpdatesOnMouseDrag())</span>
<span class="line-added"> 950         return;</span>
<span class="line-added"> 951 </span>
 952     FrameView* view = m_frame.view();
 953     if (!view)
 954         return;
 955     auto* document = m_frame.document();
 956     if (!document)
 957         return;
 958 
 959     HitTestRequest request(HitTestRequest::ReadOnly | HitTestRequest::Active | HitTestRequest::Move | HitTestRequest::DisallowUserAgentShadowContent);
 960     HitTestResult result(view-&gt;windowToContents(m_lastKnownMousePosition));
 961     document-&gt;hitTest(request, result);
 962     updateSelectionForMouseDrag(result);
 963 }
 964 
 965 void EventHandler::updateSelectionForMouseDrag(const HitTestResult&amp; hitTestResult)
 966 {
<span class="line-added"> 967     if (!supportsSelectionUpdatesOnMouseDrag())</span>
<span class="line-added"> 968         return;</span>
<span class="line-added"> 969 </span>
 970     if (!m_mouseDownMayStartSelect)
 971         return;
 972 
 973     Node* target = hitTestResult.targetNode();
 974     if (!target)
 975         return;
 976 
 977     VisiblePosition targetPosition = selectionExtentRespectingEditingBoundary(m_frame.selection().selection(), hitTestResult.localPoint(), target);
 978 
 979     // Don&#39;t modify the selection if we&#39;re not on a node.
 980     if (targetPosition.isNull())
 981         return;
 982 
 983     // Restart the selection if this is the first mouse move. This work is usually
 984     // done in handleMousePressEvent, but not if the mouse press was on an existing selection.
 985     VisibleSelection newSelection = m_frame.selection().selection();
 986 
 987     // Special case to limit selection to the containing block for SVG text.
 988     // FIXME: Isn&#39;t there a better non-SVG-specific way to do this?
 989     if (Node* selectionBaseNode = newSelection.base().deprecatedNode()) {
</pre>
<hr />
<pre>
1190         FrameView* frameView = m_frame.view();
1191         FrameView* mainView = mainFrame.view();
1192         if (frameView &amp;&amp; mainView) {
1193             IntPoint mainFramePoint = mainView-&gt;rootViewToContents(frameView-&gt;contentsToRootView(roundedIntPoint(point)));
1194             return mainFrame.eventHandler().hitTestResultAtPoint(mainFramePoint, hitType, padding);
1195         }
1196     }
1197 
1198     unsigned nonNegativePaddingWidth = std::max&lt;LayoutUnit&gt;(0, padding.width()).toUnsigned();
1199     unsigned nonNegativePaddingHeight = std::max&lt;LayoutUnit&gt;(0, padding.height()).toUnsigned();
1200 
1201     // We should always start hit testing a clean tree.
1202     if (auto* frameView = m_frame.view())
1203         frameView-&gt;updateLayoutAndStyleIfNeededRecursive();
1204 
1205     HitTestResult result(point, nonNegativePaddingHeight, nonNegativePaddingWidth, nonNegativePaddingHeight, nonNegativePaddingWidth);
1206     auto* document = m_frame.document();
1207     if (!document)
1208         return result;
1209 
<span class="line-modified">1210     HitTestRequest request(hitType);</span>

1211     document-&gt;hitTest(request, result);
1212     if (!request.readOnly())
1213         m_frame.document()-&gt;updateHoverActiveState(request, result.targetElement());
1214 
1215     if (request.disallowsUserAgentShadowContent())
1216         result.setToNonUserAgentShadowAncestor();
1217 
1218     return result;
1219 }
1220 
1221 void EventHandler::stopAutoscrollTimer(bool rendererIsBeingDestroyed)
1222 {
1223     m_autoscrollController-&gt;stopAutoscrollTimer(rendererIsBeingDestroyed);
1224 }
1225 
1226 bool EventHandler::scrollOverflow(ScrollDirection direction, ScrollGranularity granularity, Node* startingNode)
1227 {
1228     Node* node = startingNode;
1229 
1230     if (!node)
</pre>
<hr />
<pre>
1987         hitType |= HitTestRequest::Active | HitTestRequest::ReadOnly;
1988 #endif
1989     HitTestRequest request(hitType);
1990     MouseEventWithHitTestResults mouseEvent = prepareMouseEvent(request, platformMouseEvent);
1991     if (hoveredNode)
1992         *hoveredNode = mouseEvent.hitTestResult();
1993 
1994     if (m_resizeLayer &amp;&amp; m_resizeLayer-&gt;inResizeMode())
1995         m_resizeLayer-&gt;resize(platformMouseEvent, m_offsetFromResizeCorner);
1996     else {
1997         Scrollbar* scrollbar = mouseEvent.scrollbar();
1998         updateLastScrollbarUnderMouse(scrollbar, m_mousePressed ? SetOrClearLastScrollbar::Clear : SetOrClearLastScrollbar::Set);
1999 
2000         // On iOS, our scrollbars are managed by UIKit.
2001 #if !PLATFORM(IOS_FAMILY)
2002         if (!m_mousePressed &amp;&amp; scrollbar)
2003             scrollbar-&gt;mouseMoved(platformMouseEvent); // Handle hover effects on platforms that support visual feedback on scrollbar hovering.
2004 #endif
2005         if (onlyUpdateScrollbars) {
2006             if (shouldSendMouseEventsToInactiveWindows())
<span class="line-modified">2007                 updateMouseEventTargetNode(mouseEvent.targetNode(), platformMouseEvent, FireMouseOverOut::Yes);</span>
2008 
2009             return true;
2010         }
2011     }
2012 
2013     bool swallowEvent = false;
2014     RefPtr&lt;Frame&gt; newSubframe = m_capturingMouseEventsElement.get() ? subframeForTargetNode(m_capturingMouseEventsElement.get()) : subframeForHitTestResult(mouseEvent);
2015 
2016     // We want mouseouts to happen first, from the inside out.  First send a move event to the last subframe so that it will fire mouseouts.
2017     if (m_lastMouseMoveEventSubframe &amp;&amp; m_lastMouseMoveEventSubframe-&gt;tree().isDescendantOf(&amp;m_frame) &amp;&amp; m_lastMouseMoveEventSubframe != newSubframe)
2018         passMouseMoveEventToSubframe(mouseEvent, m_lastMouseMoveEventSubframe.get());
2019 
2020     if (newSubframe) {
2021         // Update over/out state before passing the event to the subframe.
<span class="line-modified">2022         updateMouseEventTargetNode(mouseEvent.targetNode(), platformMouseEvent, FireMouseOverOut::Yes);</span>
2023 
2024         // Event dispatch in updateMouseEventTargetNode may have caused the subframe of the target
2025         // node to be detached from its FrameView, in which case the event should not be passed.
2026         if (newSubframe-&gt;view())
2027             swallowEvent |= passMouseMoveEventToSubframe(mouseEvent, newSubframe.get(), hoveredNode);
2028     }
2029 
2030     if (!newSubframe || mouseEvent.scrollbar()) {
2031 #if ENABLE(CURSOR_SUPPORT)
2032         if (auto* view = m_frame.view())
2033             updateCursor(*view, mouseEvent.hitTestResult(), platformMouseEvent.shiftKey());
2034 #endif
2035     }
2036 
2037     m_lastMouseMoveEventSubframe = newSubframe;
2038 
2039     if (swallowEvent)
2040         return true;
2041 
2042     swallowEvent = !dispatchMouseEvent(eventNames().mousemoveEvent, mouseEvent.targetNode(), false, 0, platformMouseEvent, true);
</pre>
<hr />
<pre>
2235 #if PLATFORM(GTK)
2236     if (platformMouseEvent.type() != PlatformEvent::MousePressed)
2237         return false;
2238 #else
2239     if (platformMouseEvent.type() != PlatformEvent::MouseReleased)
2240         return false;
2241 #endif
2242 
2243     if (!m_frame.page())
2244         return false;
2245     Frame&amp; focusFrame = m_frame.page()-&gt;focusController().focusedOrMainFrame();
2246     // Do not paste here if the focus was moved somewhere else.
2247     if (&amp;m_frame == &amp;focusFrame &amp;&amp; m_frame.editor().client()-&gt;supportsGlobalSelection())
2248         return m_frame.editor().command(&quot;PasteGlobalSelection&quot;_s).execute();
2249 
2250     return false;
2251 }
2252 
2253 #if ENABLE(DRAG_SUPPORT)
2254 
<span class="line-modified">2255 bool EventHandler::dispatchDragEvent(const AtomString&amp; eventType, Element&amp; dragTarget, const PlatformMouseEvent&amp; event, DataTransfer&amp; dataTransfer)</span>
2256 {
2257     Ref&lt;Frame&gt; protectedFrame(m_frame);
2258     FrameView* view = m_frame.view();
2259 
2260     // FIXME: We might want to dispatch a dragleave even if the view is gone.
2261     if (!view)
2262         return false;
2263 
2264     view-&gt;disableLayerFlushThrottlingTemporarilyForInteraction();
2265     // FIXME: Use MouseEvent::create which takes PlatformMouseEvent.
2266     Ref&lt;MouseEvent&gt; me = MouseEvent::create(eventType, Event::CanBubble::Yes, Event::IsCancelable::Yes, Event::IsComposed::Yes,
2267         event.timestamp().approximateMonotonicTime(), &amp;m_frame.windowProxy(), 0,
2268         event.globalPosition(), event.position(),
2269 #if ENABLE(POINTER_LOCK)
2270         event.movementDelta(),
2271 #else
2272         { },
2273 #endif
2274         event.modifiers(), 0, 0, nullptr, event.force(), NoTap, &amp;dataTransfer);
2275 
</pre>
<hr />
<pre>
2330         bool matched = false;
2331         DragOperation dragOperation = DragOperationNone;
2332         for (unsigned i = 0, size = keywords.size(); i &lt; size; ++i) {
2333             DragOperation op = convertDropZoneOperationToDragOperation(keywords[i]);
2334             if (op != DragOperationNone) {
2335                 if (dragOperation == DragOperationNone)
2336                     dragOperation = op;
2337             } else
2338                 matched = matched || hasDropZoneType(dataTransfer, keywords[i].string());
2339             if (matched &amp;&amp; dragOperation != DragOperationNone)
2340                 break;
2341         }
2342         if (matched) {
2343             dataTransfer.setDropEffect(convertDragOperationToDropZoneOperation(dragOperation));
2344             return true;
2345         }
2346     }
2347     return false;
2348 }
2349 
<span class="line-modified">2350 EventHandler::DragTargetResponse EventHandler::dispatchDragEnterOrDragOverEvent(const AtomString&amp; eventType, Element&amp; target, const PlatformMouseEvent&amp; event,</span>
2351     std::unique_ptr&lt;Pasteboard&gt;&amp;&amp; pasteboard, DragOperation sourceOperation, bool draggingFiles)
2352 {
2353     auto dataTransfer = DataTransfer::createForUpdatingDropTarget(target.document(), WTFMove(pasteboard), sourceOperation, draggingFiles);
2354     bool accept = dispatchDragEvent(eventType, target, event, dataTransfer.get());
2355     if (!accept)
2356         accept = findDropZone(target, dataTransfer);
2357     dataTransfer-&gt;makeInvalidForSecurity();
2358     if (accept &amp;&amp; !dataTransfer-&gt;dropEffectIsUninitialized())
2359         return { true, dataTransfer-&gt;destinationOperation() };
2360     return { accept, WTF::nullopt };
2361 }
2362 
2363 EventHandler::DragTargetResponse EventHandler::updateDragAndDrop(const PlatformMouseEvent&amp; event, const std::function&lt;std::unique_ptr&lt;Pasteboard&gt;()&gt;&amp; makePasteboard, DragOperation sourceOperation, bool draggingFiles)
2364 {
2365     Ref&lt;Frame&gt; protectedFrame(m_frame);
2366     if (!m_frame.view())
2367         return { };
2368 
2369     HitTestRequest request(HitTestRequest::ReadOnly | HitTestRequest::DisallowUserAgentShadowContent);
2370     MouseEventWithHitTestResults mouseEvent = prepareMouseEvent(request, event);
</pre>
<hr />
<pre>
2469 
2470 void EventHandler::clearDragState()
2471 {
2472     stopAutoscrollTimer();
2473     m_dragTarget = nullptr;
2474     m_capturingMouseEventsElement = nullptr;
2475     m_shouldOnlyFireDragOverEvent = false;
2476 #if PLATFORM(COCOA)
2477     m_sendingEventToSubview = false;
2478 #endif
2479 }
2480 
2481 #endif // ENABLE(DRAG_SUPPORT)
2482 
2483 void EventHandler::setCapturingMouseEventsElement(Element* element)
2484 {
2485     m_capturingMouseEventsElement = element;
2486     m_eventHandlerWillResetCapturingMouseEventsElement = false;
2487 }
2488 
<span class="line-added">2489 #if ENABLE(POINTER_EVENTS)</span>
<span class="line-added">2490 void EventHandler::pointerCaptureElementDidChange(Element* element)</span>
<span class="line-added">2491 {</span>
<span class="line-added">2492     if (m_capturingMouseEventsElement == element)</span>
<span class="line-added">2493         return;</span>
<span class="line-added">2494 </span>
<span class="line-added">2495     setCapturingMouseEventsElement(element);</span>
<span class="line-added">2496 </span>
<span class="line-added">2497     // Now that we have a new capture element, we need to dispatch boundary mouse events.</span>
<span class="line-added">2498     updateMouseEventTargetNode(element, m_lastPlatformMouseEvent, FireMouseOverOut::Yes);</span>
<span class="line-added">2499 }</span>
<span class="line-added">2500 #endif</span>
<span class="line-added">2501 </span>
2502 MouseEventWithHitTestResults EventHandler::prepareMouseEvent(const HitTestRequest&amp; request, const PlatformMouseEvent&amp; mouseEvent)
2503 {
<span class="line-added">2504 #if ENABLE(POINTER_EVENTS)</span>
<span class="line-added">2505     m_lastPlatformMouseEvent = mouseEvent;</span>
<span class="line-added">2506 #endif</span>
2507     Ref&lt;Frame&gt; protectedFrame(m_frame);
2508     ASSERT(m_frame.document());
2509     return m_frame.document()-&gt;prepareMouseEvent(request, documentPointForWindowPoint(m_frame, mouseEvent.position()), mouseEvent);
2510 }
2511 
<span class="line-modified">2512 static bool hierarchyHasCapturingEventListeners(Element* element, const AtomString&amp; pointerEventName, const AtomString&amp; compatibilityMouseEventName)</span>
2513 {
2514     for (ContainerNode* curr = element; curr; curr = curr-&gt;parentInComposedTree()) {
<span class="line-modified">2515         if (curr-&gt;hasCapturingEventListeners(pointerEventName) || curr-&gt;hasCapturingEventListeners(compatibilityMouseEventName))</span>
2516             return true;
2517     }
2518     return false;
2519 }
2520 
<span class="line-modified">2521 void EventHandler::updateMouseEventTargetNode(Node* targetNode, const PlatformMouseEvent&amp; platformMouseEvent, FireMouseOverOut fireMouseOverOut)</span>
2522 {
2523     Ref&lt;Frame&gt; protectedFrame(m_frame);
2524     Element* targetElement = nullptr;
2525 
2526     // If we&#39;re capturing, we always go right to that element.
2527     if (m_capturingMouseEventsElement)
2528         targetElement = m_capturingMouseEventsElement.get();
2529     else if (targetNode) {
2530         // If the target node is a non-element, dispatch on the parent. &lt;rdar://problem/4196646&gt;
2531         while (targetNode &amp;&amp; !is&lt;Element&gt;(*targetNode))
2532             targetNode = targetNode-&gt;parentInComposedTree();
2533         targetElement = downcast&lt;Element&gt;(targetNode);
2534     }
2535 
2536     m_elementUnderMouse = targetElement;
2537 
2538     // Fire mouseout/mouseover if the mouse has shifted to a different node.
<span class="line-modified">2539     if (fireMouseOverOut == FireMouseOverOut::Yes) {</span>
2540         auto scrollableAreaForLastNode = enclosingScrollableArea(m_lastElementUnderMouse.get());
2541         auto scrollableAreaForNodeUnderMouse = enclosingScrollableArea(m_elementUnderMouse.get());
2542         Page* page = m_frame.page();
2543 
2544         if (m_lastElementUnderMouse &amp;&amp; (!m_elementUnderMouse || &amp;m_elementUnderMouse-&gt;document() != m_frame.document())) {
2545             // The mouse has moved between frames.
2546             if (Frame* frame = m_lastElementUnderMouse-&gt;document().frame()) {
2547                 if (FrameView* frameView = frame-&gt;view())
2548                     frameView-&gt;mouseExitedContentArea();
2549             }
2550         } else if (page &amp;&amp; (scrollableAreaForLastNode &amp;&amp; (!scrollableAreaForNodeUnderMouse || scrollableAreaForNodeUnderMouse != scrollableAreaForLastNode))) {
2551             // The mouse has moved between layers.
2552             if (Frame* frame = m_lastElementUnderMouse-&gt;document().frame()) {
2553                 if (FrameView* frameView = frame-&gt;view()) {
2554                     if (frameView-&gt;containsScrollableArea(scrollableAreaForLastNode))
2555                         scrollableAreaForLastNode-&gt;mouseExitedContentArea();
2556                 }
2557             }
2558         }
2559 
</pre>
<hr />
<pre>
2565             }
2566         } else if (page &amp;&amp; (scrollableAreaForNodeUnderMouse &amp;&amp; (!scrollableAreaForLastNode || scrollableAreaForNodeUnderMouse != scrollableAreaForLastNode))) {
2567             // The mouse has moved between layers.
2568             if (Frame* frame = m_elementUnderMouse-&gt;document().frame()) {
2569                 if (FrameView* frameView = frame-&gt;view()) {
2570                     if (frameView-&gt;containsScrollableArea(scrollableAreaForNodeUnderMouse))
2571                         scrollableAreaForNodeUnderMouse-&gt;mouseEnteredContentArea();
2572                 }
2573             }
2574         }
2575 
2576         if (m_lastElementUnderMouse &amp;&amp; &amp;m_lastElementUnderMouse-&gt;document() != m_frame.document()) {
2577             m_lastElementUnderMouse = nullptr;
2578             m_lastScrollbarUnderMouse = nullptr;
2579         }
2580 
2581         if (m_lastElementUnderMouse != m_elementUnderMouse) {
2582             // mouseenter and mouseleave events are only dispatched if there is a capturing eventhandler on an ancestor
2583             // or a normal eventhandler on the element itself (they don&#39;t bubble).
2584             // This optimization is necessary since these events can cause O(n^2) capturing event-handler checks.
<span class="line-modified">2585             bool hasCapturingMouseEnterListener = hierarchyHasCapturingEventListeners(m_elementUnderMouse.get(), eventNames().pointerenterEvent, eventNames().mouseenterEvent);</span>
<span class="line-modified">2586             bool hasCapturingMouseLeaveListener = hierarchyHasCapturingEventListeners(m_lastElementUnderMouse.get(), eventNames().pointerleaveEvent, eventNames().mouseleaveEvent);</span>
2587 
2588             Vector&lt;Ref&lt;Element&gt;, 32&gt; leftElementsChain;
2589             for (Element* element = m_lastElementUnderMouse.get(); element; element = element-&gt;parentElementInComposedTree())
2590                 leftElementsChain.append(*element);
2591             Vector&lt;Ref&lt;Element&gt;, 32&gt; enteredElementsChain;
2592             for (Element* element = m_elementUnderMouse.get(); element; element = element-&gt;parentElementInComposedTree())
2593                 enteredElementsChain.append(*element);
2594 
2595             if (!leftElementsChain.isEmpty() &amp;&amp; !enteredElementsChain.isEmpty() &amp;&amp; leftElementsChain.last().ptr() == enteredElementsChain.last().ptr()) {
2596                 size_t minHeight = std::min(leftElementsChain.size(), enteredElementsChain.size());
2597                 size_t i;
2598                 for (i = 0; i &lt; minHeight; ++i) {
2599                     if (leftElementsChain[leftElementsChain.size() - i - 1].ptr() != enteredElementsChain[enteredElementsChain.size() - i - 1].ptr())
2600                         break;
2601                 }
2602                 leftElementsChain.shrink(leftElementsChain.size() - i);
2603                 enteredElementsChain.shrink(enteredElementsChain.size() - i);
2604             }
2605 
2606             if (m_lastElementUnderMouse)
2607                 m_lastElementUnderMouse-&gt;dispatchMouseEvent(platformMouseEvent, eventNames().mouseoutEvent, 0, m_elementUnderMouse.get());
2608 
2609             for (auto&amp; chain : leftElementsChain) {
<span class="line-modified">2610                 if (hasCapturingMouseLeaveListener || chain-&gt;hasEventListeners(eventNames().pointerleaveEvent) || chain-&gt;hasEventListeners(eventNames().mouseleaveEvent))</span>
2611                     chain-&gt;dispatchMouseEvent(platformMouseEvent, eventNames().mouseleaveEvent, 0, m_elementUnderMouse.get());
2612             }
2613 
2614             if (m_elementUnderMouse)
2615                 m_elementUnderMouse-&gt;dispatchMouseEvent(platformMouseEvent, eventNames().mouseoverEvent, 0, m_lastElementUnderMouse.get());
2616 
<span class="line-modified">2617             for (auto&amp; chain : WTF::makeReversedRange(enteredElementsChain)) {</span>
<span class="line-modified">2618                 if (hasCapturingMouseEnterListener || chain-&gt;hasEventListeners(eventNames().pointerenterEvent) || chain-&gt;hasEventListeners(eventNames().mouseenterEvent))</span>
2619                     chain-&gt;dispatchMouseEvent(platformMouseEvent, eventNames().mouseenterEvent, 0, m_lastElementUnderMouse.get());
2620             }
2621         }
2622         m_lastElementUnderMouse = m_elementUnderMouse;
2623     }
2624 }
2625 
<span class="line-modified">2626 bool EventHandler::dispatchMouseEvent(const AtomString&amp; eventType, Node* targetNode, bool /*cancelable*/, int clickCount, const PlatformMouseEvent&amp; platformMouseEvent, bool setUnder)</span>
2627 {
2628     Ref&lt;Frame&gt; protectedFrame(m_frame);
2629 
2630     if (auto* view = m_frame.view())
2631         view-&gt;disableLayerFlushThrottlingTemporarilyForInteraction();
2632 
<span class="line-modified">2633     updateMouseEventTargetNode(targetNode, platformMouseEvent, setUnder ? FireMouseOverOut::Yes : FireMouseOverOut::No);</span>
2634 
2635     if (m_elementUnderMouse &amp;&amp; !m_elementUnderMouse-&gt;dispatchMouseEvent(platformMouseEvent, eventType, clickCount))
2636         return false;
2637 
2638     if (eventType != eventNames().mousedownEvent)
2639         return true;
2640 
2641     // If clicking on a frame scrollbar, do not make any change to which element is focused.
2642     auto* view = m_frame.view();
2643     if (view &amp;&amp; view-&gt;scrollbarAtPoint(platformMouseEvent.position()))
2644         return true;
2645 
2646     // The layout needs to be up to date to determine if an element is focusable.
2647     m_frame.document()-&gt;updateLayoutIgnorePendingStylesheets();
2648 
2649     // Remove focus from the currently focused element when a link or button is clicked.
2650     // This is expected by some sites that rely on change event handlers running
2651     // from form fields before the button click is processed, behavior that was inherited
2652     // from the user interface of Windows, where pushing a button moves focus to the button.
2653 
</pre>
<hr />
<pre>
2774 }
2775 
2776 static WeakPtr&lt;Widget&gt; widgetForElement(const Element&amp; element)
2777 {
2778     auto target = element.renderer();
2779     if (!is&lt;RenderWidget&gt;(target) || !downcast&lt;RenderWidget&gt;(*target).widget())
2780         return { };
2781 
2782     return makeWeakPtr(*downcast&lt;RenderWidget&gt;(*target).widget());
2783 }
2784 
2785 bool EventHandler::completeWidgetWheelEvent(const PlatformWheelEvent&amp; event, const WeakPtr&lt;Widget&gt;&amp; widget, const WeakPtr&lt;ScrollableArea&gt;&amp; scrollableArea, ContainerNode* scrollableContainer)
2786 {
2787     m_isHandlingWheelEvent = false;
2788 
2789     // We do another check on the widget because the event handler can run JS which results in the frame getting destroyed.
2790     if (!widget)
2791         return false;
2792 
2793     if (scrollableArea)
<span class="line-modified">2794         scrollableArea-&gt;setScrollShouldClearLatchedState(false);</span>
2795 
2796     platformNotifyIfEndGesture(event, scrollableArea);
2797 
2798     if (!widget-&gt;platformWidget())
2799         return true;
2800 
2801     return platformCompletePlatformWidgetWheelEvent(event, *widget.get(), scrollableContainer);
2802 }
2803 
2804 bool EventHandler::handleWheelEvent(const PlatformWheelEvent&amp; event)
2805 {
2806     auto* document = m_frame.document();
2807     if (!document)
2808         return false;
2809 
2810     Ref&lt;Frame&gt; protectedFrame(m_frame);
2811     RefPtr&lt;FrameView&gt; protector(m_frame.view());
2812 
2813     FrameView* view = m_frame.view();
2814     if (!view)
</pre>
<hr />
<pre>
2837 #if PLATFORM(MAC)
2838     if (event.phase() == PlatformWheelEventPhaseNone &amp;&amp; event.momentumPhase() == PlatformWheelEventPhaseNone &amp;&amp; m_frame.page())
2839         m_frame.page()-&gt;resetLatchingState();
2840 #endif
2841 
2842     // FIXME: It should not be necessary to do this mutation here.
2843     // Instead, the handlers should know convert vertical scrolls appropriately.
2844     PlatformWheelEvent adjustedEvent = shouldSwapScrollDirection(result, event) ? event.copySwappingDirection() : event;
2845     platformRecordWheelEvent(adjustedEvent);
2846 
2847     if (element) {
2848         if (isOverWidget) {
2849             if (WeakPtr&lt;Widget&gt; widget = widgetForElement(*element)) {
2850                 if (widgetDidHandleWheelEvent(event, *widget.get()))
2851                     return completeWidgetWheelEvent(adjustedEvent, widget, scrollableArea, scrollableContainer.get());
2852             }
2853         }
2854 
2855         if (!element-&gt;dispatchWheelEvent(adjustedEvent)) {
2856             m_isHandlingWheelEvent = false;
<span class="line-modified">2857             if (scrollableArea &amp;&amp; scrollableArea-&gt;scrollShouldClearLatchedState()) {</span>
2858                 // Web developer is controlling scrolling, so don&#39;t attempt to latch.
2859                 clearLatchedState();
<span class="line-modified">2860                 scrollableArea-&gt;setScrollShouldClearLatchedState(false);</span>
2861             }
2862 
2863             platformNotifyIfEndGesture(adjustedEvent, scrollableArea);
2864             return true;
2865         }
2866     }
2867 
2868     if (scrollableArea)
<span class="line-modified">2869         scrollableArea-&gt;setScrollShouldClearLatchedState(false);</span>
2870 
2871     bool handledEvent = platformCompleteWheelEvent(adjustedEvent, scrollableContainer.get(), scrollableArea);
2872     platformNotifyIfEndGesture(adjustedEvent, scrollableArea);
2873     return handledEvent;
2874 }
2875 
2876 void EventHandler::clearLatchedState()
2877 {
2878     auto* page = m_frame.page();
2879     if (!page)
2880         return;
2881 
2882 #if PLATFORM(MAC)
2883     page-&gt;resetLatchingState();
2884 #endif
2885     if (auto filter = page-&gt;wheelEventDeltaFilter())
2886         filter-&gt;endFilteringDeltas();
2887 }
2888 
2889 void EventHandler::defaultWheelEventHandler(Node* startNode, WheelEvent&amp; wheelEvent)
</pre>
<hr />
<pre>
3159     if ((event.modifiers() - PlatformEvent::Modifier::ShiftKey) != accessKeyModifiers())
3160         return false;
3161     auto* element = m_frame.document()-&gt;elementForAccessKey(event.unmodifiedText());
3162     if (!element)
3163         return false;
3164     element-&gt;accessKeyAction(false);
3165     return true;
3166 }
3167 
3168 #if !PLATFORM(MAC)
3169 bool EventHandler::needsKeyboardEventDisambiguationQuirks() const
3170 {
3171     return false;
3172 }
3173 #endif
3174 
3175 #if ENABLE(FULLSCREEN_API)
3176 bool EventHandler::isKeyEventAllowedInFullScreen(const PlatformKeyboardEvent&amp; keyEvent) const
3177 {
3178     Document* document = m_frame.document();
<span class="line-modified">3179     if (document-&gt;fullscreenManager().isFullscreenKeyboardInputAllowed())</span>
3180         return true;
3181 
3182     if (keyEvent.type() == PlatformKeyboardEvent::Char) {
3183         if (keyEvent.text().length() != 1)
3184             return false;
3185         UChar character = keyEvent.text()[0];
3186         return character == &#39; &#39;;
3187     }
3188 
3189     int keyCode = keyEvent.windowsVirtualKeyCode();
3190     return (keyCode &gt;= VK_BACK &amp;&amp; keyCode &lt;= VK_CAPITAL)
3191         || (keyCode &gt;= VK_SPACE &amp;&amp; keyCode &lt;= VK_DELETE)
3192         || (keyCode &gt;= VK_OEM_1 &amp;&amp; keyCode &lt;= VK_OEM_PLUS)
3193         || (keyCode &gt;= VK_MULTIPLY &amp;&amp; keyCode &lt;= VK_OEM_8);
3194 }
3195 #endif
3196 
3197 bool EventHandler::keyEvent(const PlatformKeyboardEvent&amp; keyEvent)
3198 {
3199     Document* topDocument = m_frame.document() ? &amp;m_frame.document()-&gt;topDocument() : nullptr;
</pre>
<hr />
<pre>
3231 {
3232     Ref&lt;Frame&gt; protectedFrame(m_frame);
3233     RefPtr&lt;FrameView&gt; protector(m_frame.view());
3234 
3235     LOG(Editing, &quot;EventHandler %p keyEvent (text %s keyIdentifier %s)&quot;, this, initialKeyEvent.text().utf8().data(), initialKeyEvent.keyIdentifier().utf8().data());
3236 
3237 #if ENABLE(POINTER_LOCK)
3238     if (initialKeyEvent.type() == PlatformEvent::KeyDown &amp;&amp; initialKeyEvent.windowsVirtualKeyCode() == VK_ESCAPE &amp;&amp; m_frame.page()-&gt;pointerLockController().element()) {
3239         m_frame.page()-&gt;pointerLockController().requestPointerUnlockAndForceCursorVisible();
3240     }
3241 #endif
3242 
3243     if (initialKeyEvent.type() == PlatformEvent::KeyDown &amp;&amp; initialKeyEvent.windowsVirtualKeyCode() == VK_ESCAPE) {
3244         if (auto* page = m_frame.page()) {
3245             if (auto* validationMessageClient = page-&gt;validationMessageClient())
3246                 validationMessageClient-&gt;hideAnyValidationMessage();
3247         }
3248     }
3249 
3250 #if ENABLE(FULLSCREEN_API)
<span class="line-modified">3251     if (m_frame.document()-&gt;fullscreenManager().isFullscreen()) {</span>
3252         if (initialKeyEvent.type() == PlatformEvent::KeyDown &amp;&amp; initialKeyEvent.windowsVirtualKeyCode() == VK_ESCAPE) {
<span class="line-modified">3253             m_frame.document()-&gt;fullscreenManager().cancelFullscreen();</span>
3254             return true;
3255         }
3256 
3257         if (!isKeyEventAllowedInFullScreen(initialKeyEvent))
3258             return false;
3259     }
3260 #endif
3261 
3262     if (initialKeyEvent.windowsVirtualKeyCode() == VK_CAPITAL)
3263         capsLockStateMayHaveChanged();
3264 
3265 #if ENABLE(PAN_SCROLLING)
3266     if (m_frame.mainFrame().eventHandler().panScrollInProgress()) {
3267         // If a key is pressed while the panScroll is in progress then we want to stop
3268         if (initialKeyEvent.type() == PlatformEvent::KeyDown || initialKeyEvent.type() == PlatformEvent::RawKeyDown)
3269             stopAutoscrollTimer();
3270 
3271         // If we were in panscroll mode, we swallow the key event
3272         return true;
3273     }
</pre>
<hr />
<pre>
3324 
3325     // Run input method in advance of DOM event handling.  This may result in the IM
3326     // modifying the page prior the keydown event, but this behaviour is necessary
3327     // in order to match IE:
3328     // 1. preventing default handling of keydown and keypress events has no effect on IM input;
3329     // 2. if an input method handles the event, its keyCode is set to 229 in keydown event.
3330     m_frame.editor().handleInputMethodKeydown(keydown.get());
3331 
3332     bool handledByInputMethod = keydown-&gt;defaultHandled();
3333 
3334     if (handledByInputMethod) {
3335         keyDownEvent.setWindowsVirtualKeyCode(CompositionEventKeyCode);
3336         keydown = KeyboardEvent::create(keyDownEvent, &amp;m_frame.windowProxy());
3337         keydown-&gt;setTarget(element);
3338         keydown-&gt;setIsDefaultEventHandlerIgnored();
3339     }
3340 
3341     if (accessibilityPreventsEventPropagation(keydown))
3342         keydown-&gt;stopPropagation();
3343 
<span class="line-added">3344 #if PLATFORM(IOS_FAMILY)</span>
<span class="line-added">3345     DeferDOMTimersForScope deferralScope { m_frame.document()-&gt;quirks().needsDeferKeyDownAndKeyPressTimersUntilNextEditingCommand() };</span>
<span class="line-added">3346 #endif</span>
<span class="line-added">3347 </span>
3348     element-&gt;dispatchEvent(keydown);
3349     if (handledByInputMethod)
3350         return true;
3351 
3352     // If frame changed as a result of keydown dispatch, then return early to avoid sending a subsequent keypress message to the new frame.
3353     bool changedFocusedFrame = m_frame.page() &amp;&amp; &amp;m_frame != &amp;m_frame.page()-&gt;focusController().focusedOrMainFrame();
3354     bool keydownResult = keydown-&gt;defaultHandled() || keydown-&gt;defaultPrevented() || changedFocusedFrame;
3355     if (keydownResult &amp;&amp; !backwardCompatibilityMode)
3356         return keydownResult;
3357 
3358     // Focus may have changed during keydown handling, so refetch element.
3359     // But if we are dispatching a fake backward compatibility keypress, then we pretend that the keypress happened on the original element.
3360     if (!keydownResult) {
3361         element = eventTargetElementForDocument(m_frame.document());
3362         if (!element)
3363             return false;
3364     }
3365 
3366     PlatformKeyboardEvent keyPressEvent = initialKeyEvent;
3367     keyPressEvent.disambiguateKeyDownEvent(PlatformEvent::Char, backwardCompatibilityMode);
3368     if (keyPressEvent.text().isEmpty())
3369         return keydownResult;
3370     auto keypress = KeyboardEvent::create(keyPressEvent, &amp;m_frame.windowProxy());
3371     keypress-&gt;setTarget(element);
3372     if (keydownResult)
3373         keypress-&gt;preventDefault();
3374 #if PLATFORM(COCOA)
3375     keypress-&gt;keypressCommands() = keydown-&gt;keypressCommands();
3376 #endif
3377     element-&gt;dispatchEvent(keypress);
3378 
3379     return keydownResult || keypress-&gt;defaultPrevented() || keypress-&gt;defaultHandled();
3380 }
3381 
<span class="line-modified">3382 static FocusDirection focusDirectionForKey(const AtomString&amp; keyIdentifier)</span>
3383 {
<span class="line-modified">3384     static NeverDestroyed&lt;AtomString&gt; Down(&quot;Down&quot;, AtomString::ConstructFromLiteral);</span>
<span class="line-modified">3385     static NeverDestroyed&lt;AtomString&gt; Up(&quot;Up&quot;, AtomString::ConstructFromLiteral);</span>
<span class="line-modified">3386     static NeverDestroyed&lt;AtomString&gt; Left(&quot;Left&quot;, AtomString::ConstructFromLiteral);</span>
<span class="line-modified">3387     static NeverDestroyed&lt;AtomString&gt; Right(&quot;Right&quot;, AtomString::ConstructFromLiteral);</span>
3388 
3389     FocusDirection retVal = FocusDirectionNone;
3390 
3391     if (keyIdentifier == Down)
3392         retVal = FocusDirectionDown;
3393     else if (keyIdentifier == Up)
3394         retVal = FocusDirectionUp;
3395     else if (keyIdentifier == Left)
3396         retVal = FocusDirectionLeft;
3397     else if (keyIdentifier == Right)
3398         retVal = FocusDirectionRight;
3399 
3400     return retVal;
3401 }
3402 
3403 static void setInitialKeyboardSelection(Frame&amp; frame, SelectionDirection direction)
3404 {
3405     Document* document = frame.document();
3406     if (!document)
3407         return;
</pre>
<hr />
<pre>
3644     invalidateDataTransfer();
3645 
3646     if (mayExtendDragSession == MayExtendDragSession::No) {
3647         if (auto* page = m_frame.page())
3648             removeDraggedContentDocumentMarkersFromAllFramesInPage(*page);
3649     }
3650 
3651     dragState().source = nullptr;
3652     // In case the drag was ended due to an escape key press we need to ensure
3653     // that consecutive mousemove events don&#39;t reinitiate the drag and drop.
3654     m_mouseDownMayStartDrag = false;
3655 }
3656 
3657 void EventHandler::updateDragStateAfterEditDragIfNeeded(Element&amp; rootEditableElement)
3658 {
3659     // If inserting the dragged contents removed the drag source, we still want to fire dragend at the root editable element.
3660     if (dragState().source &amp;&amp; !dragState().source-&gt;isConnected())
3661         dragState().source = &amp;rootEditableElement;
3662 }
3663 
<span class="line-modified">3664 void EventHandler::dispatchDragSrcEvent(const AtomString&amp; eventType, const PlatformMouseEvent&amp; event)</span>
3665 {
3666     ASSERT(dragState().dataTransfer);
3667     dispatchDragEvent(eventType, *dragState().source, event, *dragState().dataTransfer);
3668 }
3669 
3670 bool EventHandler::dispatchDragStartEventOnSourceElement(DataTransfer&amp; dataTransfer)
3671 {
3672     return !dispatchDragEvent(eventNames().dragstartEvent, *dragState().source, m_mouseDown, dataTransfer) &amp;&amp; !m_frame.selection().selection().isInPasswordField();
3673 }
3674 
3675 static bool ExactlyOneBitSet(DragSourceAction n)
3676 {
3677     return n &amp;&amp; !(n &amp; (n - 1));
3678 }
3679 
3680 RefPtr&lt;Element&gt; EventHandler::draggedElement() const
3681 {
3682     return dragState().source;
3683 }
3684 
</pre>
<hr />
<pre>
3751         dragState().type = DragSourceActionSelection;
3752     }
3753 
3754     // We are starting a text/image/url drag, so the cursor should be an arrow
3755     if (FrameView* view = m_frame.view()) {
3756         // FIXME &lt;rdar://7577595&gt;: Custom cursors aren&#39;t supported during drag and drop (default to pointer).
3757         view-&gt;setCursor(pointerCursor());
3758     }
3759 
3760     if (checkDragHysteresis == ShouldCheckDragHysteresis &amp;&amp; !dragHysteresisExceeded(event.event().position()))
3761         return true;
3762 
3763     // Once we&#39;re past the hysteresis point, we don&#39;t want to treat this gesture as a click
3764     invalidateClick();
3765 
3766     DragOperation srcOp = DragOperationNone;
3767 
3768     // This does work only if we missed a dragEnd. Do it anyway, just to make sure the old dataTransfer gets numbed.
3769     invalidateDataTransfer();
3770 
<span class="line-modified">3771     dragState().dataTransfer = DataTransfer::createForDrag(*m_frame.document());</span>
3772     HasNonDefaultPasteboardData hasNonDefaultPasteboardData = HasNonDefaultPasteboardData::No;
3773 
3774     if (dragState().shouldDispatchEvents) {
3775         ASSERT(dragState().source);
3776         auto dragStartDataTransfer = DataTransfer::createForDragStartEvent(dragState().source-&gt;document());
3777         m_mouseDownMayStartDrag = dispatchDragStartEventOnSourceElement(dragStartDataTransfer);
3778         hasNonDefaultPasteboardData = dragStartDataTransfer-&gt;pasteboard().hasData() ? HasNonDefaultPasteboardData::Yes : HasNonDefaultPasteboardData::No;
3779         dragState().dataTransfer-&gt;moveDragState(WTFMove(dragStartDataTransfer));
3780 
3781         if (dragState().source &amp;&amp; dragState().type == DragSourceActionDHTML &amp;&amp; !dragState().dataTransfer-&gt;hasDragImage()) {
3782             dragState().source-&gt;document().updateStyleIfNeeded();
3783             if (auto* renderer = dragState().source-&gt;renderer()) {
3784                 auto absolutePosition = renderer-&gt;localToAbsolute();
3785                 auto delta = m_mouseDownPos - roundedIntPoint(absolutePosition);
3786                 dragState().dataTransfer-&gt;setDragImage(dragState().source.get(), delta.width(), delta.height());
3787             } else {
3788                 dispatchDragSrcEvent(eventNames().dragendEvent, event.event());
3789                 m_mouseDownMayStartDrag = false;
3790                 invalidateDataTransfer();
3791                 dragState().source = nullptr;
</pre>
<hr />
<pre>
4033 }
4034 
4035 // If scrollbar (under mouse) is different from last, send a mouse exited.
4036 void EventHandler::updateLastScrollbarUnderMouse(Scrollbar* scrollbar, SetOrClearLastScrollbar setOrClear)
4037 {
4038     if (m_lastScrollbarUnderMouse != scrollbar) {
4039         // Send mouse exited to the old scrollbar.
4040         if (m_lastScrollbarUnderMouse)
4041             m_lastScrollbarUnderMouse-&gt;mouseExited();
4042 
4043         // Send mouse entered if we&#39;re setting a new scrollbar.
4044         if (scrollbar &amp;&amp; setOrClear == SetOrClearLastScrollbar::Set) {
4045             scrollbar-&gt;mouseEntered();
4046             m_lastScrollbarUnderMouse = makeWeakPtr(*scrollbar);
4047         } else
4048             m_lastScrollbarUnderMouse = nullptr;
4049     }
4050 }
4051 
4052 #if ENABLE(TOUCH_EVENTS) &amp;&amp; !ENABLE(IOS_TOUCH_EVENTS)
<span class="line-modified">4053 static const AtomString&amp; eventNameForTouchPointState(PlatformTouchPoint::State state)</span>
4054 {
4055     switch (state) {
4056     case PlatformTouchPoint::TouchReleased:
4057         return eventNames().touchendEvent;
4058     case PlatformTouchPoint::TouchCancelled:
4059         return eventNames().touchcancelEvent;
4060     case PlatformTouchPoint::TouchPressed:
4061         return eventNames().touchstartEvent;
4062     case PlatformTouchPoint::TouchMoved:
4063         return eventNames().touchmoveEvent;
4064     case PlatformTouchPoint::TouchStationary:
4065         // TouchStationary state is not converted to touch events, so fall through to assert.
4066     default:
4067         ASSERT_NOT_REACHED();
4068         return emptyAtom();
4069     }
4070 }
4071 
4072 static HitTestResult hitTestResultInFrame(Frame* frame, const LayoutPoint&amp; point, HitTestRequest::HitTestRequestType hitType)
4073 {
</pre>
<hr />
<pre>
4144         case PlatformTouchPoint::TouchCancelled:
4145             hitType |= HitTestRequest::Release;
4146             break;
4147         case PlatformTouchPoint::TouchStationary:
4148             hitType |= HitTestRequest::Active | HitTestRequest::ReadOnly;
4149             break;
4150         default:
4151             ASSERT_NOT_REACHED();
4152             break;
4153         }
4154 
4155         if (shouldGesturesTriggerActive())
4156             hitType |= HitTestRequest::ReadOnly;
4157 
4158         // Increment the platform touch id by 1 to avoid storing a key of 0 in the hashmap.
4159         unsigned touchPointTargetKey = point.id() + 1;
4160         RefPtr&lt;EventTarget&gt; touchTarget;
4161         if (pointState == PlatformTouchPoint::TouchPressed) {
4162             HitTestResult result;
4163             if (freshTouchEvents) {
<span class="line-modified">4164                 result = hitTestResultAtPoint(pagePoint, hitType | HitTestRequest::AllowChildFrameContent);</span>
4165                 m_originatingTouchPointTargetKey = touchPointTargetKey;
4166             } else if (m_originatingTouchPointDocument.get() &amp;&amp; m_originatingTouchPointDocument-&gt;frame()) {
4167                 LayoutPoint pagePointInOriginatingDocument = documentPointForWindowPoint(*m_originatingTouchPointDocument-&gt;frame(), point.pos());
4168                 result = hitTestResultInFrame(m_originatingTouchPointDocument-&gt;frame(), pagePointInOriginatingDocument, hitType);
4169                 if (!result.innerNode())
4170                     continue;
4171             } else
4172                 continue;
4173 
4174             Element* element = result.targetElement();
4175             ASSERT(element);
4176 
4177             if (element &amp;&amp; InspectorInstrumentation::handleTouchEvent(m_frame, *element))
4178                 return true;
4179 
4180             Document&amp; doc = element-&gt;document();
4181             // Record the originating touch document even if it does not have a touch listener.
4182             if (freshTouchEvents) {
4183                 m_originatingTouchPointDocument = &amp;doc;
4184                 freshTouchEvents = false;
</pre>
<hr />
<pre>
4247             if (!changedTouches[pointState].m_touches)
4248                 changedTouches[pointState].m_touches = TouchList::create();
4249             changedTouches[pointState].m_touches-&gt;append(WTFMove(touch));
4250             changedTouches[pointState].m_targets.add(touchTarget);
4251         }
4252     }
4253     m_touchPressed = touches-&gt;length() &gt; 0;
4254     if (allTouchReleased)
4255         m_originatingTouchPointDocument = nullptr;
4256 
4257     // Now iterate the changedTouches list and m_targets within it, sending events to the targets as required.
4258     bool swallowedEvent = false;
4259     RefPtr&lt;TouchList&gt; emptyList = TouchList::create();
4260     for (unsigned state = 0; state != PlatformTouchPoint::TouchStateEnd; ++state) {
4261         if (!changedTouches[state].m_touches)
4262             continue;
4263 
4264         // When sending a touch cancel event, use empty touches and targetTouches lists.
4265         bool isTouchCancelEvent = (state == PlatformTouchPoint::TouchCancelled);
4266         RefPtr&lt;TouchList&gt;&amp; effectiveTouches(isTouchCancelEvent ? emptyList : touches);
<span class="line-modified">4267         const AtomString&amp; stateName(eventNameForTouchPointState(static_cast&lt;PlatformTouchPoint::State&gt;(state)));</span>
4268 
4269         for (auto&amp; target : changedTouches[state].m_targets) {
4270             ASSERT(is&lt;Node&gt;(target));
4271 
4272             RefPtr&lt;TouchList&gt; targetTouches(isTouchCancelEvent ? emptyList : touchesByTarget.get(target.get()));
4273             ASSERT(targetTouches);
4274 
4275             Ref&lt;TouchEvent&gt; touchEvent = TouchEvent::create(effectiveTouches.get(), targetTouches.get(), changedTouches[state].m_touches.get(),
4276                 stateName, downcast&lt;Node&gt;(*target).document().windowProxy(), { }, event.modifiers());
4277             target-&gt;dispatchEvent(touchEvent);
4278             swallowedEvent = swallowedEvent || touchEvent-&gt;defaultPrevented() || touchEvent-&gt;defaultHandled();
4279         }
4280     }
4281 
4282     return swallowedEvent;
4283 }
4284 #endif // ENABLE(TOUCH_EVENTS) &amp;&amp; !ENABLE(IOS_TOUCH_EVENTS)
4285 
4286 #if ENABLE(TOUCH_EVENTS)
4287 bool EventHandler::dispatchSyntheticTouchEventIfEnabled(const PlatformMouseEvent&amp; platformMouseEvent)
</pre>
</td>
</tr>
</table>
<center><a href="EditorClient.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="EventHandler.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>