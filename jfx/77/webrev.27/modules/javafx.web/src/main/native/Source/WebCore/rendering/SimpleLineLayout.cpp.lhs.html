<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/rendering/SimpleLineLayout.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2013 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;SimpleLineLayout.h&quot;
 28 
 29 #include &quot;DocumentMarkerController.h&quot;
 30 #include &quot;FontCache.h&quot;
 31 #include &quot;Frame.h&quot;
 32 #include &quot;GraphicsContext.h&quot;
 33 #include &quot;HTMLTextFormControlElement.h&quot;
 34 #include &quot;HitTestLocation.h&quot;
 35 #include &quot;HitTestRequest.h&quot;
 36 #include &quot;HitTestResult.h&quot;
 37 #include &quot;Hyphenation.h&quot;
 38 #include &quot;InlineTextBox.h&quot;
 39 #include &quot;LineWidth.h&quot;
 40 #include &quot;Logging.h&quot;
 41 #include &quot;PaintInfo.h&quot;
 42 #include &quot;RenderBlockFlow.h&quot;
 43 #include &quot;RenderChildIterator.h&quot;
 44 #include &quot;RenderFragmentedFlow.h&quot;
 45 #include &quot;RenderLineBreak.h&quot;
 46 #include &quot;RenderMultiColumnFlow.h&quot;
 47 #include &quot;RenderStyle.h&quot;
 48 #include &quot;RenderText.h&quot;
 49 #include &quot;RenderTextControl.h&quot;
 50 #include &quot;RenderView.h&quot;
 51 #include &quot;Settings.h&quot;
 52 #include &quot;SimpleLineLayoutFlowContents.h&quot;
 53 #include &quot;SimpleLineLayoutFunctions.h&quot;
 54 #include &quot;SimpleLineLayoutResolver.h&quot;
 55 #include &quot;SimpleLineLayoutTextFragmentIterator.h&quot;
 56 #include &quot;Text.h&quot;
 57 #include &quot;TextPaintStyle.h&quot;
 58 #include &lt;pal/Logging.h&gt;
 59 
 60 namespace WebCore {
 61 namespace SimpleLineLayout {
 62 
 63 #ifndef NDEBUG
 64 #define SET_REASON_AND_RETURN_IF_NEEDED(reason, reasons, includeReasons) { \
 65         reasons |= reason; \
 66         if (includeReasons == IncludeReasons::First) \
 67             return reasons; \
 68     }
 69 #else
 70 #define SET_REASON_AND_RETURN_IF_NEEDED(reason, reasons, includeReasons) { \
 71         ASSERT_UNUSED(includeReasons, includeReasons == IncludeReasons::First); \
 72         reasons |= reason; \
 73         return reasons; \
 74     }
 75 #endif
 76 
 77 
 78 template &lt;typename CharacterType&gt; AvoidanceReasonFlags canUseForCharacter(CharacterType, bool textIsJustified, IncludeReasons);
 79 
 80 template&lt;&gt; AvoidanceReasonFlags canUseForCharacter(UChar character, bool textIsJustified, IncludeReasons includeReasons)
 81 {
 82     AvoidanceReasonFlags reasons = { };
 83     if (textIsJustified) {
 84         // Include characters up to Latin Extended-B and some punctuation range when text is justified.
 85         bool isLatinIncludingExtendedB = character &lt;= 0x01FF;
 86         bool isPunctuationRange = character &gt;= 0x2010 &amp;&amp; character &lt;= 0x2027;
 87         if (!(isLatinIncludingExtendedB || isPunctuationRange))
 88             SET_REASON_AND_RETURN_IF_NEEDED(FlowHasJustifiedNonLatinText, reasons, includeReasons);
 89     }
 90 
 91     if (U16_IS_SURROGATE(character))
 92         SET_REASON_AND_RETURN_IF_NEEDED(FlowTextHasSurrogatePair, reasons, includeReasons);
 93 
 94     UCharDirection direction = u_charDirection(character);
 95     if (direction == U_RIGHT_TO_LEFT || direction == U_RIGHT_TO_LEFT_ARABIC
 96         || direction == U_RIGHT_TO_LEFT_EMBEDDING || direction == U_RIGHT_TO_LEFT_OVERRIDE
 97         || direction == U_LEFT_TO_RIGHT_EMBEDDING || direction == U_LEFT_TO_RIGHT_OVERRIDE
 98         || direction == U_POP_DIRECTIONAL_FORMAT || direction == U_BOUNDARY_NEUTRAL)
 99         SET_REASON_AND_RETURN_IF_NEEDED(FlowTextHasDirectionCharacter, reasons, includeReasons);
100 
101     return reasons;
102 }
103 
104 template&lt;&gt; AvoidanceReasonFlags canUseForCharacter(LChar, bool, IncludeReasons)
105 {
106     return { };
107 }
108 
109 template &lt;typename CharacterType&gt;
110 static AvoidanceReasonFlags canUseForText(const CharacterType* text, unsigned length, const FontCascade&amp; fontCascade, Optional&lt;float&gt; lineHeightConstraint,
111     bool textIsJustified, IncludeReasons includeReasons)
112 {
113     AvoidanceReasonFlags reasons = { };
114     auto&amp; primaryFont = fontCascade.primaryFont();
115     auto&amp; fontMetrics = primaryFont.fontMetrics();
116     auto availableSpaceForGlyphAscent = fontMetrics.ascent();
117     auto availableSpaceForGlyphDescent = fontMetrics.descent();
118     if (lineHeightConstraint) {
119         auto lineHeightPadding = *lineHeightConstraint - fontMetrics.height();
120         availableSpaceForGlyphAscent += lineHeightPadding / 2;
121         availableSpaceForGlyphDescent += lineHeightPadding / 2;
122     }
123 
124     for (unsigned i = 0; i &lt; length; ++i) {
125         auto character = text[i];
126         if (FontCascade::treatAsSpace(character))
127             continue;
128 
129         if (character == softHyphen)
130             SET_REASON_AND_RETURN_IF_NEEDED(FlowTextHasSoftHyphen, reasons, includeReasons);
131 
132         auto characterReasons = canUseForCharacter(character, textIsJustified, includeReasons);
133         if (characterReasons != NoReason)
134             SET_REASON_AND_RETURN_IF_NEEDED(characterReasons, reasons, includeReasons);
135 
136         auto glyphData = fontCascade.glyphDataForCharacter(character, false);
137         if (!glyphData.isValid() || glyphData.font != &amp;primaryFont)
138             SET_REASON_AND_RETURN_IF_NEEDED(FlowPrimaryFontIsInsufficient, reasons, includeReasons);
139 
140         if (lineHeightConstraint) {
141             auto bounds = primaryFont.boundsForGlyph(glyphData.glyph);
142             if (ceilf(-bounds.y()) &gt; availableSpaceForGlyphAscent || ceilf(bounds.maxY()) &gt; availableSpaceForGlyphDescent)
143                 SET_REASON_AND_RETURN_IF_NEEDED(FlowFontHasOverflowGlyph, reasons, includeReasons);
144         }
145     }
146     return reasons;
147 }
148 
149 static AvoidanceReasonFlags canUseForText(StringView text, const FontCascade&amp; fontCascade, Optional&lt;float&gt; lineHeightConstraint, bool textIsJustified, IncludeReasons includeReasons)
150 {
151     if (text.is8Bit())
152         return canUseForText(text.characters8(), text.length(), fontCascade, lineHeightConstraint, textIsJustified, includeReasons);
153     return canUseForText(text.characters16(), text.length(), fontCascade, lineHeightConstraint, textIsJustified, includeReasons);
154 }
155 
156 static AvoidanceReasonFlags canUseForFontAndText(const RenderBlockFlow&amp; flow, IncludeReasons includeReasons)
157 {
158     AvoidanceReasonFlags reasons = { };
159     // We assume that all lines have metrics based purely on the primary font.
160     const auto&amp; style = flow.style();
161     auto&amp; fontCascade = style.fontCascade();
162     if (fontCascade.primaryFont().isInterstitial())
163         SET_REASON_AND_RETURN_IF_NEEDED(FlowIsMissingPrimaryFont, reasons, includeReasons);
164     Optional&lt;float&gt; lineHeightConstraint;
165     if (style.lineBoxContain() &amp; LineBoxContainGlyphs)
166         lineHeightConstraint = lineHeightFromFlow(flow).toFloat();
167     bool flowIsJustified = style.textAlign() == TextAlignMode::Justify;
168     for (const auto&amp; textRenderer : childrenOfType&lt;RenderText&gt;(flow)) {
169         // FIXME: Do not return until after checking all children.
170         if (textRenderer.text().isEmpty())
171             SET_REASON_AND_RETURN_IF_NEEDED(FlowTextIsEmpty, reasons, includeReasons);
172         if (textRenderer.isCombineText())
173             SET_REASON_AND_RETURN_IF_NEEDED(FlowTextIsCombineText, reasons, includeReasons);
174         if (textRenderer.isCounter())
175             SET_REASON_AND_RETURN_IF_NEEDED(FlowTextIsRenderCounter, reasons, includeReasons);
176         if (textRenderer.isQuote())
177             SET_REASON_AND_RETURN_IF_NEEDED(FlowTextIsRenderQuote, reasons, includeReasons);
178         if (textRenderer.isTextFragment())
179             SET_REASON_AND_RETURN_IF_NEEDED(FlowTextIsTextFragment, reasons, includeReasons);
180         if (textRenderer.isSVGInlineText())
181             SET_REASON_AND_RETURN_IF_NEEDED(FlowTextIsSVGInlineText, reasons, includeReasons);
182         if (!textRenderer.canUseSimpleFontCodePath()) {
183             // No need to check the code path at this point. We already know it can&#39;t be simple.
184             SET_REASON_AND_RETURN_IF_NEEDED(FlowHasComplexFontCodePath, reasons, includeReasons);
185         } else {
186             TextRun run(String(textRenderer.text()));
187             run.setCharacterScanForCodePath(false);
188             if (style.fontCascade().codePath(run) != FontCascade::Simple)
189                 SET_REASON_AND_RETURN_IF_NEEDED(FlowHasComplexFontCodePath, reasons, includeReasons);
190         }
191 
192         auto textReasons = canUseForText(textRenderer.stringView(), fontCascade, lineHeightConstraint, flowIsJustified, includeReasons);
193         if (textReasons != NoReason)
194             SET_REASON_AND_RETURN_IF_NEEDED(textReasons, reasons, includeReasons);
195     }
196     return reasons;
197 }
198 
199 static AvoidanceReasonFlags canUseForStyle(const RenderStyle&amp; style, IncludeReasons includeReasons)
200 {
201     AvoidanceReasonFlags reasons = { };
202     if (style.textOverflow() == TextOverflow::Ellipsis)
203         SET_REASON_AND_RETURN_IF_NEEDED(FlowHasTextOverflow, reasons, includeReasons);
204     if (style.textUnderlinePosition() != TextUnderlinePosition::Auto || !style.textUnderlineOffset().isAuto() || !style.textDecorationThickness().isAuto())
205         SET_REASON_AND_RETURN_IF_NEEDED(FlowHasUnsupportedUnderlineDecoration, reasons, includeReasons);
206     // Non-visible overflow should be pretty easy to support.
207     if (style.overflowX() != Overflow::Visible || style.overflowY() != Overflow::Visible)
208         SET_REASON_AND_RETURN_IF_NEEDED(FlowHasOverflowNotVisible, reasons, includeReasons);
209     if (!style.isLeftToRightDirection())
210         SET_REASON_AND_RETURN_IF_NEEDED(FlowIsNotLTR, reasons, includeReasons);
211     if (!(style.lineBoxContain() &amp; LineBoxContainBlock))
212         SET_REASON_AND_RETURN_IF_NEEDED(FlowHasLineBoxContainProperty, reasons, includeReasons);
213     if (style.writingMode() != TopToBottomWritingMode)
214         SET_REASON_AND_RETURN_IF_NEEDED(FlowIsNotTopToBottom, reasons, includeReasons);
215     if (style.lineBreak() != LineBreak::Auto)
216         SET_REASON_AND_RETURN_IF_NEEDED(FlowHasLineBreak, reasons, includeReasons);
217     if (style.unicodeBidi() != UBNormal)
218         SET_REASON_AND_RETURN_IF_NEEDED(FlowHasNonNormalUnicodeBiDi, reasons, includeReasons);
219     if (style.rtlOrdering() != Order::Logical)
220         SET_REASON_AND_RETURN_IF_NEEDED(FlowHasRTLOrdering, reasons, includeReasons);
221     if (style.lineAlign() != LineAlign::None)
222         SET_REASON_AND_RETURN_IF_NEEDED(FlowHasLineAlignEdges, reasons, includeReasons);
223     if (style.lineSnap() != LineSnap::None)
224         SET_REASON_AND_RETURN_IF_NEEDED(FlowHasLineSnap, reasons, includeReasons);
225     if (style.textEmphasisFill() != TextEmphasisFill::Filled || style.textEmphasisMark() != TextEmphasisMark::None)
226         SET_REASON_AND_RETURN_IF_NEEDED(FlowHasTextEmphasisFillOrMark, reasons, includeReasons);
227     if (style.textShadow())
228         SET_REASON_AND_RETURN_IF_NEEDED(FlowHasTextShadow, reasons, includeReasons);
229     if (style.hasPseudoStyle(PseudoId::FirstLine))
230         SET_REASON_AND_RETURN_IF_NEEDED(FlowHasPseudoFirstLine, reasons, includeReasons);
231     if (style.hasPseudoStyle(PseudoId::FirstLetter))
232         SET_REASON_AND_RETURN_IF_NEEDED(FlowHasPseudoFirstLetter, reasons, includeReasons);
233     if (style.hasTextCombine())
234         SET_REASON_AND_RETURN_IF_NEEDED(FlowHasTextCombine, reasons, includeReasons);
235     if (style.backgroundClip() == FillBox::Text)
236         SET_REASON_AND_RETURN_IF_NEEDED(FlowHasTextFillBox, reasons, includeReasons);
237     if (style.borderFit() == BorderFit::Lines)
238         SET_REASON_AND_RETURN_IF_NEEDED(FlowHasBorderFitLines, reasons, includeReasons);
239     if (style.lineBreak() != LineBreak::Auto)
240         SET_REASON_AND_RETURN_IF_NEEDED(FlowHasNonAutoLineBreak, reasons, includeReasons);
241     if (style.nbspMode() != NBSPMode::Normal)
242         SET_REASON_AND_RETURN_IF_NEEDED(FlowHasWebKitNBSPMode, reasons, includeReasons);
243     if (style.hyphens() == Hyphens::Auto) {
244         auto textReasons = canUseForText(style.hyphenString(), style.fontCascade(), WTF::nullopt, false, includeReasons);
245         if (textReasons != NoReason)
246             SET_REASON_AND_RETURN_IF_NEEDED(textReasons, reasons, includeReasons);
247     }
248     return reasons;
249 }
250 
251 AvoidanceReasonFlags canUseForWithReason(const RenderBlockFlow&amp; flow, IncludeReasons includeReasons)
252 {
253 #ifndef NDEBUG
254     static std::once_flag onceFlag;
255     std::call_once(onceFlag, [] {
256         PAL::registerNotifyCallback(&quot;com.apple.WebKit.showSimpleLineLayoutCoverage&quot;, WTF::Function&lt;void()&gt; { printSimpleLineLayoutCoverage });
257         PAL::registerNotifyCallback(&quot;com.apple.WebKit.showSimpleLineLayoutReasons&quot;, WTF::Function&lt;void()&gt; { printSimpleLineLayoutBlockList });
258         PAL::registerNotifyCallback(&quot;com.apple.WebKit.toggleSimpleLineLayout&quot;, WTF::Function&lt;void()&gt; { toggleSimpleLineLayout });
259     });
260 #endif
261     AvoidanceReasonFlags reasons = { };
262     if (!flow.settings().simpleLineLayoutEnabled())
263         SET_REASON_AND_RETURN_IF_NEEDED(FeatureIsDisabled, reasons, includeReasons);
264     if (!flow.parent())
265         SET_REASON_AND_RETURN_IF_NEEDED(FlowHasNoParent, reasons, includeReasons);
266     if (!flow.firstChild())
267         SET_REASON_AND_RETURN_IF_NEEDED(FlowHasNoChild, reasons, includeReasons);
268     if (flow.fragmentedFlowState() != RenderObject::NotInsideFragmentedFlow) {
269         auto* fragmentedFlow = flow.enclosingFragmentedFlow();
270         if (!is&lt;RenderMultiColumnFlow&gt;(fragmentedFlow))
271             SET_REASON_AND_RETURN_IF_NEEDED(FlowIsInsideANonMultiColumnThread, reasons, includeReasons);
272         auto&amp; columnThread = downcast&lt;RenderMultiColumnFlow&gt;(*fragmentedFlow);
273         if (columnThread.parent() != &amp;flow.view())
274             SET_REASON_AND_RETURN_IF_NEEDED(MultiColumnFlowIsNotTopLevel, reasons, includeReasons);
275         if (columnThread.hasColumnSpanner())
276             SET_REASON_AND_RETURN_IF_NEEDED(MultiColumnFlowHasColumnSpanner, reasons, includeReasons);
277         auto&amp; style = flow.style();
278         if (style.verticalAlign() != VerticalAlign::Baseline)
279             SET_REASON_AND_RETURN_IF_NEEDED(MultiColumnFlowVerticalAlign, reasons, includeReasons);
280         if (style.isFloating())
281             SET_REASON_AND_RETURN_IF_NEEDED(MultiColumnFlowIsFloating, reasons, includeReasons);
282     }
283     if (!flow.isHorizontalWritingMode())
284         SET_REASON_AND_RETURN_IF_NEEDED(FlowHasHorizonalWritingMode, reasons, includeReasons);
285     if (flow.hasOutline())
286         SET_REASON_AND_RETURN_IF_NEEDED(FlowHasOutline, reasons, includeReasons);
287     if (flow.isRubyText() || flow.isRubyBase())
288         SET_REASON_AND_RETURN_IF_NEEDED(FlowIsRuby, reasons, includeReasons);
289     if (!flow.style().hangingPunctuation().isEmpty())
290         SET_REASON_AND_RETURN_IF_NEEDED(FlowHasHangingPunctuation, reasons, includeReasons);
291 
292     // Printing does pagination without a flow thread.
293     if (flow.document().paginated())
294         SET_REASON_AND_RETURN_IF_NEEDED(FlowIsPaginated, reasons, includeReasons);
295     if (flow.firstLineBlock())
296         SET_REASON_AND_RETURN_IF_NEEDED(FlowHasPseudoFirstLine, reasons, includeReasons);
297     if (flow.isAnonymousBlock() &amp;&amp; flow.parent()-&gt;style().textOverflow() == TextOverflow::Ellipsis)
298         SET_REASON_AND_RETURN_IF_NEEDED(FlowHasTextOverflow, reasons, includeReasons);
299     if (flow.parent()-&gt;isDeprecatedFlexibleBox())
300         SET_REASON_AND_RETURN_IF_NEEDED(FlowIsDepricatedFlexBox, reasons, includeReasons);
301     // FIXME: Placeholders do something strange.
302     if (is&lt;RenderTextControl&gt;(*flow.parent()) &amp;&amp; downcast&lt;RenderTextControl&gt;(*flow.parent()).textFormControlElement().placeholderElement())
303         SET_REASON_AND_RETURN_IF_NEEDED(FlowParentIsPlaceholderElement, reasons, includeReasons);
304     // FIXME: Implementation of wrap=hard looks into lineboxes.
305     if (flow.parent()-&gt;isTextArea() &amp;&amp; flow.parent()-&gt;element()-&gt;hasAttributeWithoutSynchronization(HTMLNames::wrapAttr))
306         SET_REASON_AND_RETURN_IF_NEEDED(FlowParentIsTextAreaWithWrapping, reasons, includeReasons);
307     // This currently covers &lt;blockflow&gt;#text&lt;/blockflow&gt;, &lt;blockflow&gt;#text&lt;br&gt;&lt;/blockflow&gt; and mutiple (sibling) RenderText cases.
308     // The &lt;blockflow&gt;&lt;inline&gt;#text&lt;/inline&gt;&lt;/blockflow&gt; case is also popular and should be relatively easy to cover.
309     for (const auto* child = flow.firstChild(); child;) {
310         if (child-&gt;selectionState() != RenderObject::SelectionNone)
311             SET_REASON_AND_RETURN_IF_NEEDED(FlowChildIsSelected, reasons, includeReasons);
312         if (is&lt;RenderText&gt;(*child)) {
313             const auto&amp; renderText = downcast&lt;RenderText&gt;(*child);
314             if (renderText.textNode() &amp;&amp; !renderText.document().markers().markersFor(*renderText.textNode()).isEmpty())
315                 SET_REASON_AND_RETURN_IF_NEEDED(FlowIncludesDocumentMarkers, reasons, includeReasons);
316             child = child-&gt;nextSibling();
317             continue;
318         }
319         if (is&lt;RenderLineBreak&gt;(child) &amp;&amp; !downcast&lt;RenderLineBreak&gt;(*child).isWBR() &amp;&amp; child-&gt;style().clear() == Clear::None) {
320             child = child-&gt;nextSibling();
321             continue;
322         }
323         SET_REASON_AND_RETURN_IF_NEEDED(FlowHasNonSupportedChild, reasons, includeReasons);
324         break;
325     }
326     auto styleReasons = canUseForStyle(flow.style(), includeReasons);
327     if (styleReasons != NoReason)
328         SET_REASON_AND_RETURN_IF_NEEDED(styleReasons, reasons, includeReasons);
329     // We can&#39;t use the code path if any lines would need to be shifted below floats. This is because we don&#39;t keep per-line y coordinates.
330     if (flow.containsFloats()) {
331         float minimumWidthNeeded = std::numeric_limits&lt;float&gt;::max();
332         for (const auto&amp; textRenderer : childrenOfType&lt;RenderText&gt;(flow)) {
333             minimumWidthNeeded = std::min(minimumWidthNeeded, textRenderer.minLogicalWidth());
334 
335             for (auto&amp; floatingObject : *flow.floatingObjectSet()) {
336                 ASSERT(floatingObject);
337                 // if a float has a shape, we cannot tell if content will need to be shifted until after we lay it out,
338                 // since the amount of space is not uniform for the height of the float.
339                 if (floatingObject-&gt;renderer().shapeOutsideInfo())
340                     SET_REASON_AND_RETURN_IF_NEEDED(FlowHasUnsupportedFloat, reasons, includeReasons);
341                 float availableWidth = flow.availableLogicalWidthForLine(floatingObject-&gt;y(), DoNotIndentText);
342                 if (availableWidth &lt; minimumWidthNeeded)
343                     SET_REASON_AND_RETURN_IF_NEEDED(FlowHasUnsupportedFloat, reasons, includeReasons);
344             }
345         }
346     }
347     auto fontAndTextReasons = canUseForFontAndText(flow, includeReasons);
348     if (fontAndTextReasons != NoReason)
349         SET_REASON_AND_RETURN_IF_NEEDED(fontAndTextReasons, reasons, includeReasons);
350     return reasons;
351 }
352 
353 bool canUseFor(const RenderBlockFlow&amp; flow)
354 {
355     return canUseForWithReason(flow, IncludeReasons::First) == NoReason;
356 }
357 
358 static float computeLineLeft(TextAlignMode textAlign, float availableWidth, float committedWidth, float logicalLeftOffset)
359 {
360     float remainingWidth = availableWidth - committedWidth;
361     float left = logicalLeftOffset;
362     switch (textAlign) {
363     case TextAlignMode::Left:
364     case TextAlignMode::WebKitLeft:
365     case TextAlignMode::Start:
366         return left;
367     case TextAlignMode::Right:
368     case TextAlignMode::WebKitRight:
369     case TextAlignMode::End:
370         return left + std::max&lt;float&gt;(remainingWidth, 0);
371     case TextAlignMode::Center:
372     case TextAlignMode::WebKitCenter:
373         return left + std::max&lt;float&gt;(remainingWidth / 2, 0);
374     case TextAlignMode::Justify:
375         ASSERT_NOT_REACHED();
376         break;
377     }
378     ASSERT_NOT_REACHED();
379     return 0;
380 }
381 
382 static void revertAllRunsOnCurrentLine(Layout::RunVector&amp; runs)
383 {
384     while (!runs.isEmpty() &amp;&amp; !runs.last().isEndOfLine)
385         runs.removeLast();
386 }
387 
388 static void revertRuns(Layout::RunVector&amp; runs, unsigned positionToRevertTo, float width)
389 {
390     while (runs.size()) {
391         auto&amp; lastRun = runs.last();
392         if (lastRun.end &lt;= positionToRevertTo)
393             break;
394         if (lastRun.start &gt;= positionToRevertTo) {
395             // Revert this run completely.
396             width -= (lastRun.logicalRight - lastRun.logicalLeft);
397             runs.removeLast();
398         } else {
399             lastRun.logicalRight -= width;
400             width = 0;
401             lastRun.end = positionToRevertTo;
402             // Partial removal.
403             break;
404         }
405     }
406 }
407 
408 class LineState {
409 public:
410     void setAvailableWidth(float width) { m_availableWidth = width; }
411     void setCollapedWhitespaceWidth(float width) { m_collapsedWhitespaceWidth = width; }
412     void setLogicalLeftOffset(float offset) { m_logicalLeftOffset = offset; }
413     void setOverflowedFragment(const TextFragmentIterator::TextFragment&amp; fragment) { m_overflowedFragment = fragment; }
414     void setNeedsAllFragments()
415     {
416         ASSERT(!m_fragments);
417         m_fragments.emplace();
418     }
419     void setHyphenationDisabled() { m_hyphenationDisabled = true; }
420     bool isHyphenationDisabled() const { return m_hyphenationDisabled; }
421 
422     float availableWidth() const { return m_availableWidth; }
423     float logicalLeftOffset() const { return m_logicalLeftOffset; }
424     const TextFragmentIterator::TextFragment&amp; overflowedFragment() const { return m_overflowedFragment; }
<a name="1" id="anc1"></a><span class="line-modified">425     bool hasTrailingWhitespace() const { return m_lastFragment.type() == TextFragmentIterator::TextFragment::Whitespace; }</span>

426     TextFragmentIterator::TextFragment lastFragment() const { return m_lastFragment; }
427     bool isWhitespaceOnly() const { return m_trailingWhitespaceWidth &amp;&amp; m_runsWidth == m_trailingWhitespaceWidth; }
428     bool fits(float extra) const { return m_availableWidth &gt;= m_runsWidth + extra; }
429     bool firstCharacterFits() const { return m_firstCharacterFits; }
430     float width() const { return m_runsWidth; }
431     std::pair&lt;unsigned, bool&gt; expansionOpportunityCount(unsigned from, unsigned to) const
432     {
433         ASSERT(m_fragments);
434         // linebreak runs are special.
435         if (from == to)
436             return std::make_pair(0, false);
437         unsigned expansionOpportunityCount = 0;
438         auto previousFragmentType = TextFragmentIterator::TextFragment::ContentEnd;
439         for (const auto&amp; fragment : *m_fragments) {
440             if (fragment.end() &lt;= from)
441                 continue;
442             auto currentFragmentType = fragment.type();
443             auto expansionOpportunity = this-&gt;expansionOpportunity(currentFragmentType, previousFragmentType);
444             if (expansionOpportunity)
445                 ++expansionOpportunityCount;
446             previousFragmentType = currentFragmentType;
447             if (fragment.end() &gt;= to)
448                 return std::make_pair(expansionOpportunityCount, expansionOpportunity);
449         }
450         ASSERT_NOT_REACHED();
451         return std::make_pair(expansionOpportunityCount, false);
452     }
453 
454     bool isEmpty() const
455     {
456         if (!m_lastFragment.isValid())
457             return true;
458         if (!m_lastCompleteFragment.isEmpty())
459             return false;
460         return m_lastFragment.overlapsToNextRenderer();
461     }
462 
463     static inline unsigned endPositionForCollapsedFragment(const TextFragmentIterator::TextFragment&amp; fragment)
464     {
465         return fragment.isCollapsed() ? fragment.start() + 1 : fragment.end();
466     }
467 
468     void appendFragmentAndCreateRunIfNeeded(const TextFragmentIterator::TextFragment&amp; fragment, Layout::RunVector&amp; runs)
469     {
470         // Adjust end position while collapsing.
471         unsigned endPosition = endPositionForCollapsedFragment(fragment);
472         // New line needs new run.
473         if (!m_runsWidth) {
474             ASSERT(!m_uncompletedWidth);
475             runs.append(Run(fragment.start(), endPosition, m_runsWidth, m_runsWidth + fragment.width(), false, fragment.hasHyphen()));
476         } else {
477             // Advance last completed fragment when the previous fragment is all set (including multiple parts across renderers)
478             if ((m_lastFragment.type() != fragment.type()) || !m_lastFragment.overlapsToNextRenderer()) {
479                 m_lastCompleteFragment = m_lastFragment;
480                 m_uncompletedWidth = fragment.width();
481             } else
482                 m_uncompletedWidth += fragment.width();
483             // Collapse neighbouring whitespace, if they are across multiple renderers and are not collapsed yet.
484             if (m_lastFragment.isCollapsible() &amp;&amp; fragment.isCollapsible()) {
485                 ASSERT(m_lastFragment.isLastInRenderer());
486                 if (!m_lastFragment.isCollapsed()) {
487                     // Line width needs to be adjusted so that now it takes collapsing into consideration.
488                     m_runsWidth -= (m_lastFragment.width() - m_collapsedWhitespaceWidth);
489                 }
490                 // This fragment is collapsed completely. No run is needed.
491                 return;
492             }
493             if (m_lastFragment.isLastInRenderer() || m_lastFragment.isCollapsed())
494                 runs.append(Run(fragment.start(), endPosition, m_runsWidth, m_runsWidth + fragment.width(), false, fragment.hasHyphen()));
495             else {
496                 Run&amp; lastRun = runs.last();
497                 lastRun.end = endPosition;
498                 lastRun.logicalRight += fragment.width();
499                 ASSERT(!lastRun.hasHyphen);
500                 lastRun.hasHyphen = fragment.hasHyphen();
501             }
502         }
503         m_runsWidth += fragment.width();
504         m_lastFragment = fragment;
505         if (m_fragments)
506             (*m_fragments).append(fragment);
507 
<a name="2" id="anc2"></a><span class="line-modified">508         if (fragment.type() == TextFragmentIterator::TextFragment::Whitespace)</span>
509             m_trailingWhitespaceWidth += fragment.width();
<a name="3" id="anc3"></a><span class="line-modified">510         else {</span>

511             m_trailingWhitespaceWidth = 0;
512             m_lastNonWhitespaceFragment = fragment;
513         }
514 
515         if (!m_firstCharacterFits)
516             m_firstCharacterFits = fragment.start() + 1 &gt; endPosition || m_runsWidth &lt;= m_availableWidth;
517     }
518 
519     TextFragmentIterator::TextFragment revertToLastCompleteFragment(Layout::RunVector&amp; runs)
520     {
521         if (!m_uncompletedWidth) {
522             ASSERT(m_lastFragment == m_lastCompleteFragment);
523             return m_lastFragment;
524         }
525         ASSERT(m_lastFragment.isValid());
526         m_runsWidth -= m_uncompletedWidth;
527         revertRuns(runs, endPositionForCollapsedFragment(m_lastCompleteFragment), m_uncompletedWidth);
528         m_uncompletedWidth = 0;
529         ASSERT(m_lastCompleteFragment.isValid());
530         return m_lastCompleteFragment;
531     }
532 
533     void removeTrailingWhitespace(Layout::RunVector&amp; runs)
534     {
535         if (m_lastFragment.type() != TextFragmentIterator::TextFragment::Whitespace)
536             return;
537         if (m_lastNonWhitespaceFragment) {
538             auto needsReverting = m_lastNonWhitespaceFragment-&gt;end() != m_lastFragment.end();
539             // Trailing whitespace fragment might actually have zero length.
540             ASSERT(needsReverting || !m_trailingWhitespaceWidth);
541             if (needsReverting) {
542                 revertRuns(runs, m_lastNonWhitespaceFragment-&gt;end(), m_trailingWhitespaceWidth);
543                 m_runsWidth -= m_trailingWhitespaceWidth;
544             }
545             m_trailingWhitespaceWidth = 0;
546             m_lastFragment = *m_lastNonWhitespaceFragment;
547             return;
548         }
549         // This line is all whitespace.
550         revertAllRunsOnCurrentLine(runs);
551         m_runsWidth = 0;
552         m_trailingWhitespaceWidth = 0;
553         // FIXME: Make m_lastFragment optional.
554         m_lastFragment = TextFragmentIterator::TextFragment();
555     }
556 
557 private:
558     bool expansionOpportunity(TextFragmentIterator::TextFragment::Type currentFragmentType, TextFragmentIterator::TextFragment::Type previousFragmentType) const
559     {
560         return (currentFragmentType == TextFragmentIterator::TextFragment::Whitespace
561             || (currentFragmentType == TextFragmentIterator::TextFragment::NonWhitespace &amp;&amp; previousFragmentType == TextFragmentIterator::TextFragment::NonWhitespace));
562     }
563 
564     float m_availableWidth { 0 };
565     float m_logicalLeftOffset { 0 };
566     float m_runsWidth { 0 };
567     TextFragmentIterator::TextFragment m_overflowedFragment;
568     TextFragmentIterator::TextFragment m_lastFragment;
569     Optional&lt;TextFragmentIterator::TextFragment&gt; m_lastNonWhitespaceFragment;
<a name="4" id="anc4"></a>
570     TextFragmentIterator::TextFragment m_lastCompleteFragment;
571     float m_uncompletedWidth { 0 };
572     float m_trailingWhitespaceWidth { 0 }; // Use this to remove trailing whitespace without re-mesuring the text.
573     float m_collapsedWhitespaceWidth { 0 };
574     // Having one character on the line does not necessarily mean it actually fits.
575     // First character of the first fragment might be forced on to the current line even if it does not fit.
576     bool m_firstCharacterFits { false };
577     bool m_hyphenationDisabled { false };
578     Optional&lt;Vector&lt;TextFragmentIterator::TextFragment, 30&gt;&gt; m_fragments;
579 };
580 
581 static bool preWrap(const TextFragmentIterator::Style&amp; style)
582 {
583     return style.wrapLines &amp;&amp; !style.collapseWhitespace;
584 }
585 
586 static void removeTrailingWhitespace(LineState&amp; lineState, Layout::RunVector&amp; runs, const TextFragmentIterator&amp; textFragmentIterator)
587 {
588     if (!lineState.hasTrailingWhitespace())
589         return;
590     // Remove collapsed whitespace, or non-collapsed pre-wrap whitespace, unless it&#39;s the only content on the line -so removing the whitesapce
591     // would produce an empty line.
592     const auto&amp; style = textFragmentIterator.style();
<a name="5" id="anc5"></a><span class="line-modified">593     bool collapseWhitespace = style.collapseWhitespace | preWrap(style);</span>
594     if (!collapseWhitespace)
595         return;
596     if (preWrap(style) &amp;&amp; lineState.isWhitespaceOnly())
597         return;
598     lineState.removeTrailingWhitespace(runs);
599 }
600 
601 static void updateLineConstrains(const RenderBlockFlow&amp; flow, LineState&amp; line, const LineState&amp; previousLine, unsigned&amp; numberOfPrecedingLinesWithHyphen, const TextFragmentIterator::Style&amp; style, bool isFirstLine)
602 {
603     bool shouldApplyTextIndent = !flow.isAnonymous() || flow.parent()-&gt;firstChild() == &amp;flow;
604     LayoutUnit height = flow.logicalHeight();
605     LayoutUnit logicalHeight = flow.minLineHeightForReplacedRenderer(false, 0);
606     line.setLogicalLeftOffset(flow.logicalLeftOffsetForLine(height, DoNotIndentText, logicalHeight) + (shouldApplyTextIndent &amp;&amp; isFirstLine ? flow.textIndentOffset() : 0_lu));
607     float logicalRightOffset = flow.logicalRightOffsetForLine(height, DoNotIndentText, logicalHeight);
608     line.setAvailableWidth(std::max&lt;float&gt;(0, logicalRightOffset - line.logicalLeftOffset()));
609     if (style.textAlign == TextAlignMode::Justify)
610         line.setNeedsAllFragments();
611     numberOfPrecedingLinesWithHyphen = (previousLine.isEmpty() || !previousLine.lastFragment().hasHyphen()) ? 0 : numberOfPrecedingLinesWithHyphen + 1;
612     if (style.hyphenLimitLines &amp;&amp; numberOfPrecedingLinesWithHyphen &gt;= *style.hyphenLimitLines)
613         line.setHyphenationDisabled();
614     line.setCollapedWhitespaceWidth(style.font.spaceWidth() + style.wordSpacing);
615 }
616 
617 struct SplitFragmentData {
618     unsigned position;
619     float width;
620 };
621 static Optional&lt;unsigned&gt; hyphenPositionForFragment(SplitFragmentData splitData, const TextFragmentIterator::TextFragment&amp; fragmentToSplit,
622     const LineState&amp; line, const TextFragmentIterator&amp; textFragmentIterator, float availableWidth)
623 {
624     auto&amp; style = textFragmentIterator.style();
625     if (!style.shouldHyphenate || line.isHyphenationDisabled())
626         return WTF::nullopt;
627 
628     // FIXME: This is a workaround for webkit.org/b/169613. See maxPrefixWidth computation in tryHyphenating().
629     // It does not work properly with non-collapsed leading tabs when font is enlarged.
630     auto adjustedAvailableWidth = availableWidth - style.hyphenStringWidth;
631     if (!line.isEmpty())
632         adjustedAvailableWidth += style.font.spaceWidth();
633     if (!enoughWidthForHyphenation(adjustedAvailableWidth, style.font.pixelSize()))
634         return WTF::nullopt;
635 
636     // We might be able to fit the hyphen at the split position.
637     auto splitPositionWithHyphen = splitData.position;
638     // Find a splitting position where hyphen surely fits.
639     unsigned start = fragmentToSplit.start();
640     auto leftSideWidth = splitData.width;
641     while (leftSideWidth + style.hyphenStringWidth &gt; availableWidth) {
642         if (--splitPositionWithHyphen &lt;= start)
643             return WTF::nullopt; // No space for hyphen.
644         leftSideWidth -= textFragmentIterator.textWidth(splitPositionWithHyphen, splitPositionWithHyphen + 1, 0);
645     }
646     ASSERT(splitPositionWithHyphen &gt; start);
647     return textFragmentIterator.lastHyphenPosition(fragmentToSplit, splitPositionWithHyphen + 1);
648 }
649 
650 static SplitFragmentData split(const TextFragmentIterator::TextFragment&amp; fragment, float availableWidth,
651     const TextFragmentIterator&amp; textFragmentIterator)
652 {
653     ASSERT(availableWidth &gt;= 0);
654     auto left = fragment.start();
655     // Pathological case of (extremely)long string and narrow lines.
656     // Adjust the range so that we can pick a reasonable midpoint.
657     auto averageCharacterWidth = fragment.width() / fragment.length();
658     auto right = std::min&lt;unsigned&gt;(left + (2 * availableWidth / averageCharacterWidth), fragment.end() - 1);
659     // Preserve the left width for the final split position so that we don&#39;t need to remeasure the left side again.
660     float leftSideWidth = 0;
661     while (left &lt; right) {
662         auto middle = (left + right) / 2;
663         auto width = textFragmentIterator.textWidth(fragment.start(), middle + 1, 0);
664         if (width &lt; availableWidth) {
665             left = middle + 1;
666             leftSideWidth = width;
667         } else if (width &gt; availableWidth)
668             right = middle;
669         else {
670             right = middle + 1;
671             leftSideWidth = width;
672             break;
673         }
674     }
675     return { right, leftSideWidth };
676 }
677 
678 static TextFragmentIterator::TextFragment splitFragmentToFitLine(TextFragmentIterator::TextFragment&amp; fragmentToSplit,
679     const LineState&amp; line, const TextFragmentIterator&amp; textFragmentIterator)
680 {
681     auto availableWidth = line.availableWidth() - line.width();
682     auto splitFragmentData = split(fragmentToSplit, availableWidth, textFragmentIterator);
683     Optional&lt;unsigned&gt; hyphenPosition = WTF::nullopt;
684     // Does first character fit this line?
685     if (splitFragmentData.position == fragmentToSplit.start()) {
686         // Keep at least one character on empty lines.
687         if (line.isEmpty())
688             splitFragmentData.width = textFragmentIterator.textWidth(fragmentToSplit.start(), ++splitFragmentData.position, 0);
689     } else {
690         hyphenPosition = hyphenPositionForFragment(splitFragmentData, fragmentToSplit, line, textFragmentIterator, availableWidth);
691         if (hyphenPosition) {
692             splitFragmentData.position = *hyphenPosition;
693             splitFragmentData.width = textFragmentIterator.textWidth(fragmentToSplit.start(), splitFragmentData.position, 0);
694         }
695     }
696     // If the right side surely does not fit the (next)line, we don&#39;t need the width to be kerning/ligature adjusted.
697     // Part of it gets re-measured as the left side during next split.
698     // This saves measuring long chunk of text repeatedly (see pathological case at ::split).
699     auto rightSideWidth = fragmentToSplit.width() - splitFragmentData.width;
700     if (rightSideWidth &lt; 2 * availableWidth)
701         rightSideWidth = textFragmentIterator.textWidth(splitFragmentData.position, fragmentToSplit.end(), 0);
702     return hyphenPosition ? fragmentToSplit.splitWithHyphen(splitFragmentData.position, textFragmentIterator.style().hyphenStringWidth,
703         splitFragmentData.width, rightSideWidth) : fragmentToSplit.split(splitFragmentData.position, splitFragmentData.width, rightSideWidth);
704 }
705 
706 enum PreWrapLineBreakRule { Preserve, Ignore };
707 
708 static TextFragmentIterator::TextFragment consumeLineBreakIfNeeded(const TextFragmentIterator::TextFragment&amp; fragment, TextFragmentIterator&amp; textFragmentIterator, LineState&amp; line, Layout::RunVector&amp; runs,
709     PreWrapLineBreakRule preWrapLineBreakRule = PreWrapLineBreakRule::Preserve)
710 {
711     if (!fragment.isLineBreak())
712         return fragment;
713 
714     bool isHardLinebreak = fragment.type() == TextFragmentIterator::TextFragment::HardLineBreak;
715     // &lt;br&gt; always produces a run. (required by testing output)
716     if (isHardLinebreak)
717         line.appendFragmentAndCreateRunIfNeeded(fragment, runs);
718 
719     auto&amp; style = textFragmentIterator.style();
720     if (style.preserveNewline &amp;&amp; preWrapLineBreakRule == PreWrapLineBreakRule::Preserve) {
721         if (!isHardLinebreak)
722             return fragment;
723     }
724     return textFragmentIterator.nextTextFragment();
725 }
726 
727 static TextFragmentIterator::TextFragment skipWhitespaceIfNeeded(const TextFragmentIterator::TextFragment&amp; fragment, TextFragmentIterator&amp; textFragmentIterator)
728 {
729     if (!textFragmentIterator.style().collapseWhitespace)
730         return fragment;
731 
732     TextFragmentIterator::TextFragment firstNonWhitespaceFragment = fragment;
733     while (firstNonWhitespaceFragment.type() == TextFragmentIterator::TextFragment::Whitespace)
734         firstNonWhitespaceFragment = textFragmentIterator.nextTextFragment();
735     return firstNonWhitespaceFragment;
736 }
737 
738 static TextFragmentIterator::TextFragment firstFragment(TextFragmentIterator&amp; textFragmentIterator, LineState&amp; currentLine, const LineState&amp; previousLine, Layout::RunVector&amp; runs)
739 {
740     // Handle overflow fragment from previous line.
741     auto overflowedFragment = previousLine.overflowedFragment();
742     if (overflowedFragment.isEmpty())
743         return skipWhitespaceIfNeeded(textFragmentIterator.nextTextFragment(), textFragmentIterator);
744 
745     if (overflowedFragment.type() != TextFragmentIterator::TextFragment::Whitespace)
746         return overflowedFragment;
747 
748     // Leading whitespace handling.
749     auto&amp; style = textFragmentIterator.style();
<a name="6" id="anc6"></a>





750     // Special overflow pre-wrap whitespace handling: skip the overflowed whitespace (even when style says not-collapsible)
751     // if we manage to fit at least one character on the previous line.
752     auto preWrapIsOn = preWrap(style);
753     if ((style.collapseWhitespace || preWrapIsOn) &amp;&amp; previousLine.firstCharacterFits()) {
754         // If skipping the whitespace puts us on a newline, skip the newline too as we already wrapped the line.
755         auto firstFragmentCandidate = consumeLineBreakIfNeeded(textFragmentIterator.nextTextFragment(), textFragmentIterator, currentLine, runs,
756             preWrapIsOn ? PreWrapLineBreakRule::Ignore : PreWrapLineBreakRule::Preserve);
757         return skipWhitespaceIfNeeded(firstFragmentCandidate, textFragmentIterator);
758     }
759     return skipWhitespaceIfNeeded(overflowedFragment, textFragmentIterator);
760 }
761 
762 static void forceFragmentToLine(LineState&amp; line, TextFragmentIterator&amp; textFragmentIterator, Layout::RunVector&amp; runs, const TextFragmentIterator::TextFragment&amp; fragment)
763 {
764     line.appendFragmentAndCreateRunIfNeeded(fragment, runs);
765     // Check if there are more fragments to add to the current line.
766     auto nextFragment = textFragmentIterator.nextTextFragment();
767     if (fragment.overlapsToNextRenderer()) {
768         while (true) {
769             if (nextFragment.type() != fragment.type())
770                 break;
771             line.appendFragmentAndCreateRunIfNeeded(nextFragment, runs);
772             // Does it overlap to the next segment?
773             if (!nextFragment.overlapsToNextRenderer())
774                 return;
775             nextFragment = textFragmentIterator.nextTextFragment();
776         }
777     }
778     // When the forced fragment is followed by either whitespace and/or line break, consume them too, otherwise we end up with an extra whitespace and/or line break.
779     nextFragment = skipWhitespaceIfNeeded(nextFragment, textFragmentIterator);
780     nextFragment = consumeLineBreakIfNeeded(nextFragment, textFragmentIterator, line, runs);
781     line.setOverflowedFragment(nextFragment);
782 }
783 
784 static bool createLineRuns(LineState&amp; line, const LineState&amp; previousLine, Layout::RunVector&amp; runs, TextFragmentIterator&amp; textFragmentIterator)
785 {
786     const auto&amp; style = textFragmentIterator.style();
787     bool lineCanBeWrapped = style.wrapLines || style.breakFirstWordOnOverflow || style.breakAnyWordOnOverflow;
788     auto fragment = firstFragment(textFragmentIterator, line, previousLine, runs);
789     while (fragment.type() != TextFragmentIterator::TextFragment::ContentEnd) {
790         // Hard and soft linebreaks.
791         if (fragment.isLineBreak()) {
792             // Add the new line fragment only if there&#39;s nothing on the line. (otherwise the extra new line character would show up at the end of the content.)
793             if (line.isEmpty() || fragment.type() == TextFragmentIterator::TextFragment::HardLineBreak) {
794                 if (style.textAlign == TextAlignMode::Right || style.textAlign == TextAlignMode::WebKitRight)
795                     line.removeTrailingWhitespace(runs);
796                 line.appendFragmentAndCreateRunIfNeeded(fragment, runs);
797             }
798             break;
799         }
800         if (lineCanBeWrapped &amp;&amp; !line.fits(fragment.width())) {
801             // Overflow wrapping behaviour:
802             // 1. Whitesapce collapse on: whitespace is skipped. Jump to next line.
803             // 2. Whitespace collapse off: whitespace is wrapped.
804             // 3. First, non-whitespace fragment is either wrapped or kept on the line. (depends on overflow-wrap)
805             // 5. Non-whitespace fragment when there&#39;s already another fragment on the line either gets wrapped (word-break: break-all)
806             // or gets pushed to the next line.
807             bool emptyLine = line.isEmpty();
808             // Whitespace fragment.
809             if (fragment.type() == TextFragmentIterator::TextFragment::Whitespace) {
810                 if (style.collapseWhitespace) {
811                     // Push collapased whitespace to the next line.
812                     line.setOverflowedFragment(fragment);
813                     break;
814                 }
<a name="7" id="anc7"></a>




815                 // Split the whitespace; left part stays on this line, right is pushed to next line.
816                 line.setOverflowedFragment(splitFragmentToFitLine(fragment, line, textFragmentIterator));
817                 line.appendFragmentAndCreateRunIfNeeded(fragment, runs);
818                 break;
819             }
820             // Non-whitespace fragment. (!style.wrapLines: bug138102(preserve existing behavior)
821             if (((emptyLine &amp;&amp; style.breakFirstWordOnOverflow) || style.breakAnyWordOnOverflow) || !style.wrapLines) {
822                 // Split the fragment; (modified)fragment stays on this line, overflowedFragment is pushed to next line.
823                 line.setOverflowedFragment(splitFragmentToFitLine(fragment, line, textFragmentIterator));
824                 line.appendFragmentAndCreateRunIfNeeded(fragment, runs);
825                 break;
826             }
827             ASSERT(fragment.type() == TextFragmentIterator::TextFragment::NonWhitespace);
828             // Find out if this non-whitespace fragment has a hyphen where we can break.
829             if (style.shouldHyphenate) {
830                 auto fragmentToSplit = fragment;
831                 // Split and check if we actually ended up with a hyphen.
832                 auto overflowFragment = splitFragmentToFitLine(fragmentToSplit, line, textFragmentIterator);
833                 if (fragmentToSplit.hasHyphen()) {
834                     line.setOverflowedFragment(overflowFragment);
835                     line.appendFragmentAndCreateRunIfNeeded(fragmentToSplit, runs);
836                     break;
837                 }
838                 // No hyphen, no split.
839             }
840             // Non-breakable non-whitespace first fragment. Add it to the current line. -it overflows though.
841             if (emptyLine) {
842                 forceFragmentToLine(line, textFragmentIterator, runs, fragment);
843                 break;
844             }
845             // Non-breakable non-whitespace fragment when there&#39;s already content on the line. Push it to the next line.
846             ASSERT(line.lastFragment().isValid());
847             if (line.lastFragment().overlapsToNextRenderer()) {
848                 // Check if this fragment is a continuation of a previous segment. In such cases, we need to remove them all.
849                 textFragmentIterator.revertToEndOfFragment(line.revertToLastCompleteFragment(runs));
850                 break;
851             }
852             line.setOverflowedFragment(fragment);
853             break;
854         }
855         line.appendFragmentAndCreateRunIfNeeded(fragment, runs);
856         // Find the next text fragment.
857         fragment = textFragmentIterator.nextTextFragment(line.width());
858     }
859     return (fragment.type() == TextFragmentIterator::TextFragment::ContentEnd &amp;&amp; line.overflowedFragment().isEmpty()) || line.overflowedFragment().type() == TextFragmentIterator::TextFragment::ContentEnd;
860 }
861 
862 static ExpansionBehavior expansionBehavior(bool isAfterExpansion, bool lastRunOnLine)
863 {
864     ExpansionBehavior expansionBehavior;
865     expansionBehavior = isAfterExpansion ? ForbidLeadingExpansion : AllowLeadingExpansion;
866     expansionBehavior |= lastRunOnLine ? ForbidTrailingExpansion : AllowTrailingExpansion;
867     return expansionBehavior;
868 }
869 
870 static void justifyRuns(const LineState&amp; line, Layout::RunVector&amp; runs, unsigned firstRunIndex)
871 {
872     ASSERT(runs.size());
873     auto widthToDistribute = line.availableWidth() - line.width();
874     if (widthToDistribute &lt;= 0)
875         return;
876 
877     auto lastRunIndex = runs.size() - 1;
878     ASSERT(firstRunIndex &lt;= lastRunIndex);
879     Vector&lt;std::pair&lt;unsigned, ExpansionBehavior&gt;&gt; expansionOpportunityList;
880     unsigned expansionOpportunityCountOnThisLine = 0;
881     auto isAfterExpansion = true;
882     for (auto i = firstRunIndex; i &lt;= lastRunIndex; ++i) {
883         const auto&amp; run = runs.at(i);
884         unsigned opportunityCountInRun = 0;
885         std::tie(opportunityCountInRun, isAfterExpansion) = line.expansionOpportunityCount(run.start, run.end);
886         expansionOpportunityList.append(std::make_pair(opportunityCountInRun, expansionBehavior(isAfterExpansion, i == lastRunIndex)));
887         expansionOpportunityCountOnThisLine += opportunityCountInRun;
888     }
889     if (!expansionOpportunityCountOnThisLine)
890         return;
891 
892     ASSERT(expansionOpportunityList.size() == lastRunIndex - firstRunIndex + 1);
893     auto expansion = widthToDistribute / expansionOpportunityCountOnThisLine;
894     float accumulatedExpansion = 0;
895     for (auto i = firstRunIndex; i &lt;= lastRunIndex; ++i) {
896         auto&amp; run = runs.at(i);
897         unsigned opportunityCountInRun;
898         std::tie(opportunityCountInRun, run.expansionBehavior) = expansionOpportunityList.at(i - firstRunIndex);
899         run.expansion = opportunityCountInRun * expansion;
900         run.logicalLeft += accumulatedExpansion;
901         run.logicalRight += (accumulatedExpansion + run.expansion);
902         accumulatedExpansion += run.expansion;
903     }
904 }
905 
906 static TextAlignMode textAlignForLine(const TextFragmentIterator::Style&amp; style, bool lastLine)
907 {
908     // Fallback to TextAlignMode::Left (START) alignment for non-collapsable content and for the last line before a forced break or the end of the block.
909     auto textAlign = style.textAlign;
910     if (textAlign == TextAlignMode::Justify &amp;&amp; (!style.collapseWhitespace || lastLine))
911         textAlign = TextAlignMode::Left;
912     return textAlign;
913 }
914 
915 static void closeLineEndingAndAdjustRuns(LineState&amp; line, Layout::RunVector&amp; runs, Optional&lt;unsigned&gt; lastRunIndexOfPreviousLine, unsigned&amp; lineCount,
916     const TextFragmentIterator&amp; textFragmentIterator, bool lastLineInFlow)
917 {
918     if (!runs.size() || (lastRunIndexOfPreviousLine &amp;&amp; runs.size() - 1 == lastRunIndexOfPreviousLine.value()))
919         return;
920     removeTrailingWhitespace(line, runs, textFragmentIterator);
921     if (!runs.size())
922         return;
923     // Adjust runs&#39; position by taking line&#39;s alignment into account.
924     const auto&amp; style = textFragmentIterator.style();
925     auto firstRunIndex = lastRunIndexOfPreviousLine ? lastRunIndexOfPreviousLine.value() + 1 : 0;
926     auto lineLogicalLeft = line.logicalLeftOffset();
927     auto textAlign = textAlignForLine(style, lastLineInFlow || (line.lastFragment().isValid() &amp;&amp; line.lastFragment().type() == TextFragmentIterator::TextFragment::HardLineBreak));
928     if (textAlign == TextAlignMode::Justify)
929         justifyRuns(line, runs, firstRunIndex);
930     else
931         lineLogicalLeft = computeLineLeft(textAlign, line.availableWidth(), line.width(), line.logicalLeftOffset());
932     for (auto i = firstRunIndex; i &lt; runs.size(); ++i) {
933         runs[i].logicalLeft += lineLogicalLeft;
934         runs[i].logicalRight += lineLogicalLeft;
935     }
936     runs.last().isEndOfLine = true;
937     ++lineCount;
938 }
939 
940 static void createTextRuns(Layout::RunVector&amp; runs, RenderBlockFlow&amp; flow, unsigned&amp; lineCount)
941 {
942     LayoutUnit borderAndPaddingBefore = flow.borderAndPaddingBefore();
943     LayoutUnit lineHeight = lineHeightFromFlow(flow);
944     LineState line;
945     unsigned numberOfPrecedingLinesWithHyphen = 0;
946     bool isEndOfContent = false;
947     TextFragmentIterator textFragmentIterator = TextFragmentIterator(flow);
948     Optional&lt;unsigned&gt; lastRunIndexOfPreviousLine;
949     do {
950         flow.setLogicalHeight(lineHeight * lineCount + borderAndPaddingBefore);
951         LineState previousLine = line;
952         line = LineState();
953         updateLineConstrains(flow, line, previousLine, numberOfPrecedingLinesWithHyphen, textFragmentIterator.style(), !lineCount);
954         isEndOfContent = createLineRuns(line, previousLine, runs, textFragmentIterator);
955         closeLineEndingAndAdjustRuns(line, runs, lastRunIndexOfPreviousLine, lineCount, textFragmentIterator, isEndOfContent);
956         if (runs.size())
957             lastRunIndexOfPreviousLine = runs.size() - 1;
958     } while (!isEndOfContent);
959 }
960 
961 std::unique_ptr&lt;Layout&gt; create(RenderBlockFlow&amp; flow)
962 {
963     unsigned lineCount = 0;
964     Layout::RunVector runs;
965     createTextRuns(runs, flow, lineCount);
966     return Layout::create(runs, lineCount, flow);
967 }
968 
969 std::unique_ptr&lt;Layout&gt; Layout::create(const RunVector&amp; runVector, unsigned lineCount, const RenderBlockFlow&amp; blockFlow)
970 {
971     void* slot = WTF::fastMalloc(sizeof(Layout) + sizeof(Run) * runVector.size());
972     return std::unique_ptr&lt;Layout&gt;(new (NotNull, slot) Layout(runVector, lineCount, blockFlow));
973 }
974 
975 Layout::Layout(const RunVector&amp; runVector, unsigned lineCount, const RenderBlockFlow&amp; blockFlow)
976     : m_lineCount(lineCount)
977     , m_runCount(runVector.size())
978     , m_blockFlowRenderer(blockFlow)
979 {
980     memcpy(m_runs, runVector.data(), m_runCount * sizeof(Run));
981 }
982 
983 const RunResolver&amp; Layout::runResolver() const
984 {
985     if (!m_runResolver)
<a name="8" id="anc8"></a><span class="line-modified">986         m_runResolver = std::make_unique&lt;RunResolver&gt;(m_blockFlowRenderer, *this);</span>
987     return *m_runResolver;
988 }
989 
990 Layout::~Layout()
991 {
992     simpleLineLayoutWillBeDeleted(*this);
993 }
994 
995 }
996 }
<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>