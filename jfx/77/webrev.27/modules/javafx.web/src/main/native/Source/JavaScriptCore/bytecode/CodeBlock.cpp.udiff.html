<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/CodeBlock.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CallVariant.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CodeBlock.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/CodeBlock.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -106,13 +106,10 @@</span>
  #if ENABLE(FTL_JIT)
  #include &quot;FTLJITCode.h&quot;
  #endif
  
  namespace JSC {
<span class="udiff-line-removed">- namespace CodeBlockInternal {</span>
<span class="udiff-line-removed">- static constexpr bool verbose = false;</span>
<span class="udiff-line-removed">- } // namespace CodeBlockInternal</span>
  
  const ClassInfo CodeBlock::s_info = {
      &quot;CodeBlock&quot;, nullptr, nullptr, nullptr,
      CREATE_METHOD_TABLE(CodeBlock)
  };
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -123,11 +120,11 @@</span>
      case GlobalCode:
          return &quot;&lt;global&gt;&quot;;
      case EvalCode:
          return &quot;&lt;eval&gt;&quot;;
      case FunctionCode:
<span class="udiff-line-modified-removed">-         return jsCast&lt;FunctionExecutable*&gt;(ownerExecutable())-&gt;inferredName().utf8();</span>
<span class="udiff-line-modified-added">+         return jsCast&lt;FunctionExecutable*&gt;(ownerExecutable())-&gt;ecmaName().utf8();</span>
      case ModuleCode:
          return &quot;&lt;module&gt;&quot;;
      default:
          CRASH();
          return CString(&quot;&quot;, 0);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -181,22 +178,22 @@</span>
      if (hasHash() || isSafeToComputeHash())
          return toCString(hash());
      return &quot;&lt;no-hash&gt;&quot;;
  }
  
<span class="udiff-line-modified-removed">- void CodeBlock::dumpAssumingJITType(PrintStream&amp; out, JITCode::JITType jitType) const</span>
<span class="udiff-line-modified-added">+ void CodeBlock::dumpAssumingJITType(PrintStream&amp; out, JITType jitType) const</span>
  {
      out.print(inferredName(), &quot;#&quot;, hashAsStringIfPossible());
      out.print(&quot;:[&quot;, RawPointer(this), &quot;-&gt;&quot;);
      if (!!m_alternative)
          out.print(RawPointer(alternative()), &quot;-&gt;&quot;);
      out.print(RawPointer(ownerExecutable()), &quot;, &quot;, jitType, codeType());
  
      if (codeType() == FunctionCode)
          out.print(specializationKind());
<span class="udiff-line-modified-removed">-     out.print(&quot;, &quot;, instructionCount());</span>
<span class="udiff-line-modified-removed">-     if (this-&gt;jitType() == JITCode::BaselineJIT &amp;&amp; m_shouldAlwaysBeInlined)</span>
<span class="udiff-line-modified-added">+     out.print(&quot;, &quot;, instructionsSize());</span>
<span class="udiff-line-modified-added">+     if (this-&gt;jitType() == JITType::BaselineJIT &amp;&amp; m_shouldAlwaysBeInlined)</span>
          out.print(&quot; (ShouldAlwaysBeInlined)&quot;);
      if (ownerExecutable()-&gt;neverInline())
          out.print(&quot; (NeverInline)&quot;);
      if (ownerExecutable()-&gt;neverOptimize())
          out.print(&quot; (NeverOptimize)&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -206,13 +203,13 @@</span>
          out.print(&quot; (DidTryToEnterInLoop)&quot;);
      if (ownerExecutable()-&gt;isStrictMode())
          out.print(&quot; (StrictMode)&quot;);
      if (m_didFailJITCompilation)
          out.print(&quot; (JITFail)&quot;);
<span class="udiff-line-modified-removed">-     if (this-&gt;jitType() == JITCode::BaselineJIT &amp;&amp; m_didFailFTLCompilation)</span>
<span class="udiff-line-modified-added">+     if (this-&gt;jitType() == JITType::BaselineJIT &amp;&amp; m_didFailFTLCompilation)</span>
          out.print(&quot; (FTLFail)&quot;);
<span class="udiff-line-modified-removed">-     if (this-&gt;jitType() == JITCode::BaselineJIT &amp;&amp; m_hasBeenCompiledWithFTL)</span>
<span class="udiff-line-modified-added">+     if (this-&gt;jitType() == JITType::BaselineJIT &amp;&amp; m_hasBeenCompiledWithFTL)</span>
          out.print(&quot; (HadFTLReplacement)&quot;);
      out.print(&quot;]&quot;);
  }
  
  void CodeBlock::dump(PrintStream&amp; out) const
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -230,11 +227,11 @@</span>
      ScriptExecutable* executable = ownerExecutable();
      if (executable-&gt;isFunctionExecutable()) {
          FunctionExecutable* functionExecutable = reinterpret_cast&lt;FunctionExecutable*&gt;(executable);
          StringView source = functionExecutable-&gt;source().provider()-&gt;getRange(
              functionExecutable-&gt;parametersStartOffset(),
<span class="udiff-line-modified-removed">-             functionExecutable-&gt;typeProfilingEndOffset(*vm()) + 1); // Type profiling end offset is the character before the &#39;}&#39;.</span>
<span class="udiff-line-modified-added">+             functionExecutable-&gt;typeProfilingEndOffset(vm()) + 1); // Type profiling end offset is the character before the &#39;}&#39;.</span>
  
          out.print(&quot;function &quot;, inferredName(), source);
          return;
      }
      out.print(executable-&gt;source().view());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -283,12 +280,12 @@</span>
      const Identifier&amp; m_ident;
  };
  
  } // anonymous namespace
  
<span class="udiff-line-modified-removed">- CodeBlock::CodeBlock(VM* vm, Structure* structure, CopyParsedBlockTag, CodeBlock&amp; other)</span>
<span class="udiff-line-modified-removed">-     : JSCell(*vm, structure)</span>
<span class="udiff-line-modified-added">+ CodeBlock::CodeBlock(VM&amp; vm, Structure* structure, CopyParsedBlockTag, CodeBlock&amp; other)</span>
<span class="udiff-line-modified-added">+     : JSCell(vm, structure)</span>
      , m_globalObject(other.m_globalObject)
      , m_shouldAlwaysBeInlined(true)
  #if ENABLE(JIT)
      , m_capabilityLevelState(DFG::CapabilityLevelNotSet)
  #endif
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -299,15 +296,15 @@</span>
      , m_numVars(other.m_numVars)
      , m_numberOfArgumentsToSkip(other.m_numberOfArgumentsToSkip)
      , m_hasDebuggerStatement(false)
      , m_steppingMode(SteppingModeDisabled)
      , m_numBreakpoints(0)
<span class="udiff-line-modified-removed">-     , m_instructionCount(other.m_instructionCount)</span>
<span class="udiff-line-modified-added">+     , m_bytecodeCost(other.m_bytecodeCost)</span>
      , m_scopeRegister(other.m_scopeRegister)
      , m_hash(other.m_hash)
<span class="udiff-line-modified-removed">-     , m_unlinkedCode(*other.vm(), this, other.m_unlinkedCode.get())</span>
<span class="udiff-line-modified-removed">-     , m_ownerExecutable(*other.vm(), this, other.m_ownerExecutable.get())</span>
<span class="udiff-line-modified-added">+     , m_unlinkedCode(other.vm(), this, other.m_unlinkedCode.get())</span>
<span class="udiff-line-modified-added">+     , m_ownerExecutable(other.vm(), this, other.m_ownerExecutable.get())</span>
      , m_vm(other.m_vm)
      , m_instructionsRawPointer(other.m_instructionsRawPointer)
      , m_constantRegisters(other.m_constantRegisters)
      , m_constantsSourceCodeRepresentation(other.m_constantsSourceCodeRepresentation)
      , m_functionDecls(other.m_functionDecls)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -322,11 +319,11 @@</span>
      ASSERT(m_scopeRegister.isLocal());
  
      ASSERT(source().provider());
      setNumParameters(other.numParameters());
  
<span class="udiff-line-modified-removed">-     vm-&gt;heap.codeBlockSet().add(this);</span>
<span class="udiff-line-modified-added">+     vm.heap.codeBlockSet().add(this);</span>
  }
  
  void CodeBlock::finishCreation(VM&amp; vm, CopyParsedBlockTag, CodeBlock&amp; other)
  {
      Base::finishCreation(vm);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -342,13 +339,13 @@</span>
          m_rareData-&gt;m_switchJumpTables = other.m_rareData-&gt;m_switchJumpTables;
          m_rareData-&gt;m_stringSwitchJumpTables = other.m_rareData-&gt;m_stringSwitchJumpTables;
      }
  }
  
<span class="udiff-line-modified-removed">- CodeBlock::CodeBlock(VM* vm, Structure* structure, ScriptExecutable* ownerExecutable, UnlinkedCodeBlock* unlinkedCodeBlock, JSScope* scope)</span>
<span class="udiff-line-modified-removed">-     : JSCell(*vm, structure)</span>
<span class="udiff-line-modified-removed">-     , m_globalObject(*vm, this, scope-&gt;globalObject(*vm))</span>
<span class="udiff-line-modified-added">+ CodeBlock::CodeBlock(VM&amp; vm, Structure* structure, ScriptExecutable* ownerExecutable, UnlinkedCodeBlock* unlinkedCodeBlock, JSScope* scope)</span>
<span class="udiff-line-modified-added">+     : JSCell(vm, structure)</span>
<span class="udiff-line-modified-added">+     , m_globalObject(vm, this, scope-&gt;globalObject(vm))</span>
      , m_shouldAlwaysBeInlined(true)
  #if ENABLE(JIT)
      , m_capabilityLevelState(DFG::CapabilityLevelNotSet)
  #endif
      , m_didFailJITCompilation(false)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -358,13 +355,13 @@</span>
      , m_numVars(unlinkedCodeBlock-&gt;numVars())
      , m_hasDebuggerStatement(false)
      , m_steppingMode(SteppingModeDisabled)
      , m_numBreakpoints(0)
      , m_scopeRegister(unlinkedCodeBlock-&gt;scopeRegister())
<span class="udiff-line-modified-removed">-     , m_unlinkedCode(*vm, this, unlinkedCodeBlock)</span>
<span class="udiff-line-modified-removed">-     , m_ownerExecutable(*vm, this, ownerExecutable)</span>
<span class="udiff-line-modified-removed">-     , m_vm(vm)</span>
<span class="udiff-line-modified-added">+     , m_unlinkedCode(vm, this, unlinkedCodeBlock)</span>
<span class="udiff-line-modified-added">+     , m_ownerExecutable(vm, this, ownerExecutable)</span>
<span class="udiff-line-modified-added">+     , m_vm(&amp;vm)</span>
      , m_instructionsRawPointer(unlinkedCodeBlock-&gt;instructions().rawPointer())
      , m_osrExitCounter(0)
      , m_optimizationDelayCounter(0)
      , m_reoptimizationRetryCounter(0)
      , m_metadata(unlinkedCodeBlock-&gt;metadata().link())
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -374,11 +371,11 @@</span>
      ASSERT(m_scopeRegister.isLocal());
  
      ASSERT(source().provider());
      setNumParameters(unlinkedCodeBlock-&gt;numParameters());
  
<span class="udiff-line-modified-removed">-     vm-&gt;heap.codeBlockSet().add(this);</span>
<span class="udiff-line-modified-added">+     vm.heap.codeBlockSet().add(this);</span>
  }
  
  // The main purpose of this function is to generate linked bytecode from unlinked bytecode. The process
  // of linking is taking an abstract representation of bytecode and tying it to a GlobalObject and scope
  // chain. For example, this process allows us to cache the depth of lexical environment reads that reach
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -393,14 +390,15 @@</span>
      Base::finishCreation(vm);
      finishCreationCommon(vm);
  
      auto throwScope = DECLARE_THROW_SCOPE(vm);
  
<span class="udiff-line-modified-removed">-     if (vm.typeProfiler() || vm.controlFlowProfiler())</span>
<span class="udiff-line-modified-added">+     if (m_unlinkedCode-&gt;wasCompiledWithTypeProfilerOpcodes() || m_unlinkedCode-&gt;wasCompiledWithControlFlowProfilerOpcodes())</span>
          vm.functionHasExecutedCache()-&gt;removeUnexecutedRange(ownerExecutable-&gt;sourceID(), ownerExecutable-&gt;typeProfilingStartOffset(vm), ownerExecutable-&gt;typeProfilingEndOffset(vm));
  
<span class="udiff-line-modified-removed">-     setConstantRegisters(unlinkedCodeBlock-&gt;constantRegisters(), unlinkedCodeBlock-&gt;constantsSourceCodeRepresentation());</span>
<span class="udiff-line-modified-added">+     ScriptExecutable* topLevelExecutable = ownerExecutable-&gt;topLevelExecutable();</span>
<span class="udiff-line-added">+     setConstantRegisters(unlinkedCodeBlock-&gt;constantRegisters(), unlinkedCodeBlock-&gt;constantsSourceCodeRepresentation(), topLevelExecutable);</span>
      RETURN_IF_EXCEPTION(throwScope, false);
  
      for (unsigned i = 0; i &lt; LinkTimeConstantCount; i++) {
          LinkTimeConstant type = static_cast&lt;LinkTimeConstant&gt;(i);
          if (unsigned registerIndex = unlinkedCodeBlock-&gt;registerIndexForLinkTimeConstant(type))
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -409,32 +407,32 @@</span>
  
      // We already have the cloned symbol table for the module environment since we need to instantiate
      // the module environments before linking the code block. We replace the stored symbol table with the already cloned one.
      if (UnlinkedModuleProgramCodeBlock* unlinkedModuleProgramCodeBlock = jsDynamicCast&lt;UnlinkedModuleProgramCodeBlock*&gt;(vm, unlinkedCodeBlock)) {
          SymbolTable* clonedSymbolTable = jsCast&lt;ModuleProgramExecutable*&gt;(ownerExecutable)-&gt;moduleEnvironmentSymbolTable();
<span class="udiff-line-modified-removed">-         if (vm.typeProfiler()) {</span>
<span class="udiff-line-modified-added">+         if (m_unlinkedCode-&gt;wasCompiledWithTypeProfilerOpcodes()) {</span>
              ConcurrentJSLocker locker(clonedSymbolTable-&gt;m_lock);
              clonedSymbolTable-&gt;prepareForTypeProfiling(locker);
          }
          replaceConstant(unlinkedModuleProgramCodeBlock-&gt;moduleEnvironmentSymbolTableConstantRegisterOffset(), clonedSymbolTable);
      }
  
<span class="udiff-line-modified-removed">-     bool shouldUpdateFunctionHasExecutedCache = vm.typeProfiler() || vm.controlFlowProfiler();</span>
<span class="udiff-line-modified-added">+     bool shouldUpdateFunctionHasExecutedCache = m_unlinkedCode-&gt;wasCompiledWithTypeProfilerOpcodes() || m_unlinkedCode-&gt;wasCompiledWithControlFlowProfilerOpcodes();</span>
      m_functionDecls = RefCountedArray&lt;WriteBarrier&lt;FunctionExecutable&gt;&gt;(unlinkedCodeBlock-&gt;numberOfFunctionDecls());
      for (size_t count = unlinkedCodeBlock-&gt;numberOfFunctionDecls(), i = 0; i &lt; count; ++i) {
          UnlinkedFunctionExecutable* unlinkedExecutable = unlinkedCodeBlock-&gt;functionDecl(i);
          if (shouldUpdateFunctionHasExecutedCache)
              vm.functionHasExecutedCache()-&gt;insertUnexecutedRange(ownerExecutable-&gt;sourceID(), unlinkedExecutable-&gt;typeProfilingStartOffset(), unlinkedExecutable-&gt;typeProfilingEndOffset());
<span class="udiff-line-modified-removed">-         m_functionDecls[i].set(vm, this, unlinkedExecutable-&gt;link(vm, ownerExecutable-&gt;source()));</span>
<span class="udiff-line-modified-added">+         m_functionDecls[i].set(vm, this, unlinkedExecutable-&gt;link(vm, topLevelExecutable, ownerExecutable-&gt;source()));</span>
      }
  
      m_functionExprs = RefCountedArray&lt;WriteBarrier&lt;FunctionExecutable&gt;&gt;(unlinkedCodeBlock-&gt;numberOfFunctionExprs());
      for (size_t count = unlinkedCodeBlock-&gt;numberOfFunctionExprs(), i = 0; i &lt; count; ++i) {
          UnlinkedFunctionExecutable* unlinkedExecutable = unlinkedCodeBlock-&gt;functionExpr(i);
          if (shouldUpdateFunctionHasExecutedCache)
              vm.functionHasExecutedCache()-&gt;insertUnexecutedRange(ownerExecutable-&gt;sourceID(), unlinkedExecutable-&gt;typeProfilingStartOffset(), unlinkedExecutable-&gt;typeProfilingEndOffset());
<span class="udiff-line-modified-removed">-         m_functionExprs[i].set(vm, this, unlinkedExecutable-&gt;link(vm, ownerExecutable-&gt;source()));</span>
<span class="udiff-line-modified-added">+         m_functionExprs[i].set(vm, this, unlinkedExecutable-&gt;link(vm, topLevelExecutable, ownerExecutable-&gt;source()));</span>
      }
  
      if (unlinkedCodeBlock-&gt;hasRareData()) {
          createRareDataIfNecessary();
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -445,13 +443,18 @@</span>
              m_rareData-&gt;m_exceptionHandlers.resizeToFit(count);
              for (size_t i = 0; i &lt; count; i++) {
                  const UnlinkedHandlerInfo&amp; unlinkedHandler = unlinkedCodeBlock-&gt;exceptionHandler(i);
                  HandlerInfo&amp; handler = m_rareData-&gt;m_exceptionHandlers[i];
  #if ENABLE(JIT)
<span class="udiff-line-modified-removed">-                 MacroAssemblerCodePtr&lt;BytecodePtrTag&gt; codePtr = instructions().at(unlinkedHandler.target)-&gt;isWide()</span>
<span class="udiff-line-modified-removed">-                     ? LLInt::getWideCodePtr&lt;BytecodePtrTag&gt;(op_catch)</span>
<span class="udiff-line-modified-removed">-                     : LLInt::getCodePtr&lt;BytecodePtrTag&gt;(op_catch);</span>
<span class="udiff-line-modified-added">+                 auto instruction = instructions().at(unlinkedHandler.target);</span>
<span class="udiff-line-modified-added">+                 MacroAssemblerCodePtr&lt;BytecodePtrTag&gt; codePtr;</span>
<span class="udiff-line-modified-added">+                 if (instruction-&gt;isWide32())</span>
<span class="udiff-line-added">+                     codePtr = LLInt::getWide32CodePtr&lt;BytecodePtrTag&gt;(op_catch);</span>
<span class="udiff-line-added">+                 else if (instruction-&gt;isWide16())</span>
<span class="udiff-line-added">+                     codePtr = LLInt::getWide16CodePtr&lt;BytecodePtrTag&gt;(op_catch);</span>
<span class="udiff-line-added">+                 else</span>
<span class="udiff-line-added">+                     codePtr = LLInt::getCodePtr&lt;BytecodePtrTag&gt;(op_catch);</span>
                  handler.initialize(unlinkedHandler, CodeLocationLabel&lt;ExceptionHandlerPtrTag&gt;(codePtr.retagged&lt;ExceptionHandlerPtrTag&gt;()));
  #else
                  handler.initialize(unlinkedHandler);
  #endif
              }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -482,31 +485,22 @@</span>
      }
  
      // Bookkeep the strongly referenced module environments.
      HashSet&lt;JSModuleEnvironment*&gt; stronglyReferencedModuleEnvironments;
  
<span class="udiff-line-modified-removed">-     auto link_profile = [&amp;](const auto&amp; instruction, auto /*bytecode*/, auto&amp; metadata) {</span>
<span class="udiff-line-modified-added">+     auto link_profile = [&amp;](const auto&amp; /*instruction*/, auto /*bytecode*/, auto&amp; /*metadata*/) {</span>
          m_numberOfNonArgumentValueProfiles++;
<span class="udiff-line-removed">-         metadata.m_profile.m_bytecodeOffset = instruction.offset();</span>
<span class="udiff-line-removed">-     };</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     auto link_arrayProfile = [&amp;](const auto&amp; instruction, auto /*bytecode*/, auto&amp; metadata) {</span>
<span class="udiff-line-removed">-         metadata.m_arrayProfile.m_bytecodeOffset = instruction.offset();</span>
      };
  
      auto link_objectAllocationProfile = [&amp;](const auto&amp; /*instruction*/, auto bytecode, auto&amp; metadata) {
          metadata.m_objectAllocationProfile.initializeProfile(vm, m_globalObject.get(), this, m_globalObject-&gt;objectPrototype(), bytecode.m_inlineCapacity);
      };
  
      auto link_arrayAllocationProfile = [&amp;](const auto&amp; /*instruction*/, auto bytecode, auto&amp; metadata) {
          metadata.m_arrayAllocationProfile.initializeIndexingMode(bytecode.m_recommendedIndexingType);
      };
  
<span class="udiff-line-removed">-     auto link_hitCountForLLIntCaching = [&amp;](const auto&amp; /*instruction*/, auto /*bytecode*/, auto&amp; metadata) {</span>
<span class="udiff-line-removed">-         metadata.m_hitCountForLLIntCaching = Options::prototypeHitCountForLLIntCaching();</span>
<span class="udiff-line-removed">-     };</span>
<span class="udiff-line-removed">- </span>
  #define LINK_FIELD(__field) \
      WTF_LAZY_JOIN(link_, __field)(instruction, bytecode, metadata);
  
  #define INITIALIZE_METADATA(__op) \
      auto bytecode = instruction-&gt;as&lt;__op&gt;(); \
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -525,19 +519,19 @@</span>
      }
  
      const InstructionStream&amp; instructionStream = instructions();
      for (const auto&amp; instruction : instructionStream) {
          OpcodeID opcodeID = instruction-&gt;opcodeID();
<span class="udiff-line-modified-removed">-         m_instructionCount += opcodeLengths[opcodeID];</span>
<span class="udiff-line-modified-added">+         m_bytecodeCost += opcodeLengths[opcodeID];</span>
          switch (opcodeID) {
<span class="udiff-line-modified-removed">-         LINK(OpHasIndexedProperty, arrayProfile)</span>
<span class="udiff-line-modified-added">+         LINK(OpHasIndexedProperty)</span>
  
<span class="udiff-line-modified-removed">-         LINK(OpCallVarargs, arrayProfile, profile)</span>
<span class="udiff-line-modified-removed">-         LINK(OpTailCallVarargs, arrayProfile, profile)</span>
<span class="udiff-line-modified-removed">-         LINK(OpTailCallForwardArguments, arrayProfile, profile)</span>
<span class="udiff-line-modified-removed">-         LINK(OpConstructVarargs, arrayProfile, profile)</span>
<span class="udiff-line-modified-removed">-         LINK(OpGetByVal, arrayProfile, profile)</span>
<span class="udiff-line-modified-added">+         LINK(OpCallVarargs, profile)</span>
<span class="udiff-line-modified-added">+         LINK(OpTailCallVarargs, profile)</span>
<span class="udiff-line-modified-added">+         LINK(OpTailCallForwardArguments, profile)</span>
<span class="udiff-line-modified-added">+         LINK(OpConstructVarargs, profile)</span>
<span class="udiff-line-modified-added">+         LINK(OpGetByVal, profile)</span>
  
          LINK(OpGetDirectPname, profile)
          LINK(OpGetByIdWithThis, profile)
          LINK(OpTryGetById, profile)
          LINK(OpGetByIdDirect, profile)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -549,21 +543,22 @@</span>
          LINK(OpToThis, profile)
          LINK(OpBitand, profile)
          LINK(OpBitor, profile)
          LINK(OpBitnot, profile)
          LINK(OpBitxor, profile)
<span class="udiff-line-added">+         LINK(OpLshift, profile)</span>
  
<span class="udiff-line-modified-removed">-         LINK(OpGetById, profile, hitCountForLLIntCaching)</span>
<span class="udiff-line-modified-added">+         LINK(OpGetById, profile)</span>
  
<span class="udiff-line-modified-removed">-         LINK(OpCall, profile, arrayProfile)</span>
<span class="udiff-line-modified-removed">-         LINK(OpTailCall, profile, arrayProfile)</span>
<span class="udiff-line-modified-removed">-         LINK(OpCallEval, profile, arrayProfile)</span>
<span class="udiff-line-modified-removed">-         LINK(OpConstruct, profile, arrayProfile)</span>
<span class="udiff-line-modified-added">+         LINK(OpCall, profile)</span>
<span class="udiff-line-modified-added">+         LINK(OpTailCall, profile)</span>
<span class="udiff-line-modified-added">+         LINK(OpCallEval, profile)</span>
<span class="udiff-line-modified-added">+         LINK(OpConstruct, profile)</span>
  
<span class="udiff-line-modified-removed">-         LINK(OpInByVal, arrayProfile)</span>
<span class="udiff-line-modified-removed">-         LINK(OpPutByVal, arrayProfile)</span>
<span class="udiff-line-modified-removed">-         LINK(OpPutByValDirect, arrayProfile)</span>
<span class="udiff-line-modified-added">+         LINK(OpInByVal)</span>
<span class="udiff-line-modified-added">+         LINK(OpPutByVal)</span>
<span class="udiff-line-modified-added">+         LINK(OpPutByValDirect)</span>
  
          LINK(OpNewArray)
          LINK(OpNewArrayWithSize)
          LINK(OpNewArrayBuffer, arrayAllocationProfile)
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -606,11 +601,11 @@</span>
              } else if (JSScope* constantScope = JSScope::constantScopeForCodeBlock(op.type, this)) {
                  metadata.m_constantScope.set(vm, this, constantScope);
                  if (op.type == GlobalProperty || op.type == GlobalPropertyWithVarInjectionChecks)
                      metadata.m_globalLexicalBindingEpoch = m_globalObject-&gt;globalLexicalBindingEpoch();
              } else
<span class="udiff-line-modified-removed">-                 metadata.m_globalObject = nullptr;</span>
<span class="udiff-line-modified-added">+                 metadata.m_globalObject.clear();</span>
              break;
          }
  
          case op_get_from_scope: {
              INITIALIZE_METADATA(OpGetFromScope)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -643,11 +638,11 @@</span>
              INITIALIZE_METADATA(OpPutToScope)
  
              if (bytecode.m_getPutInfo.resolveType() == LocalClosureVar) {
                  // Only do watching if the property we&#39;re putting to is not anonymous.
                  if (bytecode.m_var != UINT_MAX) {
<span class="udiff-line-modified-removed">-                     SymbolTable* symbolTable = jsCast&lt;SymbolTable*&gt;(getConstant(bytecode.m_symbolTableOrScopeDepth));</span>
<span class="udiff-line-modified-added">+                     SymbolTable* symbolTable = jsCast&lt;SymbolTable*&gt;(getConstant(bytecode.m_symbolTableOrScopeDepth.symbolTable().offset()));</span>
                      const Identifier&amp; ident = identifier(bytecode.m_var);
                      ConcurrentJSLocker locker(symbolTable-&gt;m_lock);
                      auto iter = symbolTable-&gt;find(locker, ident.impl());
                      ASSERT(iter != symbolTable-&gt;end(locker));
                      iter-&gt;value.prepareToWatch();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -657,11 +652,11 @@</span>
                  break;
              }
  
              const Identifier&amp; ident = identifier(bytecode.m_var);
              metadata.m_watchpointSet = nullptr;
<span class="udiff-line-modified-removed">-             ResolveOp op = JSScope::abstractResolve(m_globalObject-&gt;globalExec(), bytecode.m_symbolTableOrScopeDepth, scope, ident, Put, bytecode.m_getPutInfo.resolveType(), bytecode.m_getPutInfo.initializationMode());</span>
<span class="udiff-line-modified-added">+             ResolveOp op = JSScope::abstractResolve(m_globalObject-&gt;globalExec(), bytecode.m_symbolTableOrScopeDepth.scopeDepth(), scope, ident, Put, bytecode.m_getPutInfo.resolveType(), bytecode.m_getPutInfo.initializationMode());</span>
              RETURN_IF_EXCEPTION(throwScope, false);
  
              metadata.m_getPutInfo = GetPutInfo(bytecode.m_getPutInfo.resolveMode(), op.type, bytecode.m_getPutInfo.initializationMode());
              if (op.type == GlobalVar || op.type == GlobalVarWithVarInjectionChecks || op.type == GlobalLexicalVar || op.type == GlobalLexicalVarWithVarInjectionChecks)
                  metadata.m_watchpointSet = op.watchpointSet;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -673,11 +668,11 @@</span>
              metadata.m_operand = op.operand;
              break;
          }
  
          case op_profile_type: {
<span class="udiff-line-modified-removed">-             RELEASE_ASSERT(vm.typeProfiler());</span>
<span class="udiff-line-modified-added">+             RELEASE_ASSERT(m_unlinkedCode-&gt;wasCompiledWithTypeProfilerOpcodes());</span>
  
              INITIALIZE_METADATA(OpProfileType)
  
              size_t instructionOffset = instruction.offset() + instruction-&gt;size() - 1;
              unsigned divotStart, divotEnd;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -687,11 +682,11 @@</span>
              SymbolTable* symbolTable = nullptr;
  
              switch (bytecode.m_flag) {
              case ProfileTypeBytecodeClosureVar: {
                  const Identifier&amp; ident = identifier(bytecode.m_identifier);
<span class="udiff-line-modified-removed">-                 unsigned localScopeDepth = bytecode.m_symbolTableOrScopeDepth;</span>
<span class="udiff-line-modified-added">+                 unsigned localScopeDepth = bytecode.m_symbolTableOrScopeDepth.scopeDepth();</span>
                  // Even though type profiling may be profiling either a Get or a Put, we can always claim a Get because
                  // we&#39;re abstractly &quot;read&quot;ing from a JSScope.
                  ResolveOp op = JSScope::abstractResolve(m_globalObject-&gt;globalExec(), localScopeDepth, scope, ident, Get, bytecode.m_resolveType, InitializationMode::NotInitialization);
                  RETURN_IF_EXCEPTION(throwScope, false);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -711,11 +706,11 @@</span>
                      globalVariableID = TypeProfilerNoGlobalIDExists;
  
                  break;
              }
              case ProfileTypeBytecodeLocallyResolved: {
<span class="udiff-line-modified-removed">-                 int symbolTableIndex = bytecode.m_symbolTableOrScopeDepth;</span>
<span class="udiff-line-modified-added">+                 int symbolTableIndex = bytecode.m_symbolTableOrScopeDepth.symbolTable().offset();</span>
                  SymbolTable* symbolTable = jsCast&lt;SymbolTable*&gt;(getConstant(symbolTableIndex));
                  const Identifier&amp; ident = identifier(bytecode.m_identifier);
                  ConcurrentJSLocker locker(symbolTable-&gt;m_lock);
                  // If our parent scope was created while profiling was disabled, it will not have prepared for profiling yet.
                  globalVariableID = symbolTable-&gt;uniqueIDForVariable(locker, ident.impl(), vm);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -782,11 +777,11 @@</span>
  #undef CASE
  #undef INITIALIZE_METADATA
  #undef LINK_FIELD
  #undef LINK
  
<span class="udiff-line-modified-removed">-     if (vm.controlFlowProfiler())</span>
<span class="udiff-line-modified-added">+     if (m_unlinkedCode-&gt;wasCompiledWithControlFlowProfilerOpcodes())</span>
          insertBasicBlockBoundariesForControlFlowProfiler();
  
      // Set optimization thresholds only after instructions is initialized, since these
      // rely on the instruction count (and are in theory permitted to also inspect the
      // instruction stream to more accurate assess the cost of tier-up).
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -814,10 +809,30 @@</span>
  
  CodeBlock::~CodeBlock()
  {
      VM&amp; vm = *m_vm;
  
<span class="udiff-line-added">+ #if ENABLE(DFG_JIT)</span>
<span class="udiff-line-added">+     // The JITCode (and its corresponding DFG::CommonData) may outlive the CodeBlock by</span>
<span class="udiff-line-added">+     // a short amount of time after the CodeBlock is destructed. For example, the</span>
<span class="udiff-line-added">+     // Interpreter::execute methods will ref JITCode before invoking it. This can</span>
<span class="udiff-line-added">+     // result in the JITCode having a non-zero refCount when its owner CodeBlock is</span>
<span class="udiff-line-added">+     // destructed.</span>
<span class="udiff-line-added">+     //</span>
<span class="udiff-line-added">+     // Hence, we cannot rely on DFG::CommonData destruction to clear these now invalid</span>
<span class="udiff-line-added">+     // watchpoints in a timely manner. We&#39;ll ensure they are cleared here eagerly.</span>
<span class="udiff-line-added">+     //</span>
<span class="udiff-line-added">+     // We only need to do this for a DFG/FTL CodeBlock because only these will have a</span>
<span class="udiff-line-added">+     // DFG:CommonData. Hence, the LLInt and Baseline will not have any of these watchpoints.</span>
<span class="udiff-line-added">+     //</span>
<span class="udiff-line-added">+     // Note also that the LLIntPrototypeLoadAdaptiveStructureWatchpoint is also related</span>
<span class="udiff-line-added">+     // to the CodeBlock. However, its lifecycle is tied directly to the CodeBlock, and</span>
<span class="udiff-line-added">+     // will be automatically cleared when the CodeBlock destructs.</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (JITCode::isOptimizingJIT(jitType()))</span>
<span class="udiff-line-added">+         jitCode()-&gt;dfgCommon()-&gt;clearWatchpoints();</span>
<span class="udiff-line-added">+ #endif</span>
      vm.heap.codeBlockSet().remove(this);
  
      if (UNLIKELY(vm.m_perBytecodeProfiler))
          vm.m_perBytecodeProfiler-&gt;notifyDestruction(this);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -863,48 +878,47 @@</span>
          RETURN_IF_EXCEPTION(scope, void());
          JSSet* jsSet = JSSet::create(exec, vm, setStructure, set.size());
          RETURN_IF_EXCEPTION(scope, void());
  
          for (auto setEntry : set) {
<span class="udiff-line-modified-removed">-             JSString* jsString = jsOwnedString(&amp;vm, setEntry.get());</span>
<span class="udiff-line-modified-added">+             JSString* jsString = jsOwnedString(vm, setEntry.get());</span>
              jsSet-&gt;add(exec, jsString);
              RETURN_IF_EXCEPTION(scope, void());
          }
          m_constantRegisters[entry.second].set(vm, this, jsSet);
      }
  }
  
<span class="udiff-line-modified-removed">- void CodeBlock::setConstantRegisters(const Vector&lt;WriteBarrier&lt;Unknown&gt;&gt;&amp; constants, const Vector&lt;SourceCodeRepresentation&gt;&amp; constantsSourceCodeRepresentation)</span>
<span class="udiff-line-modified-added">+ void CodeBlock::setConstantRegisters(const Vector&lt;WriteBarrier&lt;Unknown&gt;&gt;&amp; constants, const Vector&lt;SourceCodeRepresentation&gt;&amp; constantsSourceCodeRepresentation, ScriptExecutable* topLevelExecutable)</span>
  {
      VM&amp; vm = *m_vm;
      auto scope = DECLARE_THROW_SCOPE(vm);
      JSGlobalObject* globalObject = m_globalObject.get();
      ExecState* exec = globalObject-&gt;globalExec();
  
      ASSERT(constants.size() == constantsSourceCodeRepresentation.size());
      size_t count = constants.size();
      m_constantRegisters.resizeToFit(count);
<span class="udiff-line-removed">-     bool hasTypeProfiler = !!vm.typeProfiler();</span>
      for (size_t i = 0; i &lt; count; i++) {
          JSValue constant = constants[i].get();
  
          if (!constant.isEmpty()) {
              if (constant.isCell()) {
                  JSCell* cell = constant.asCell();
                  if (SymbolTable* symbolTable = jsDynamicCast&lt;SymbolTable*&gt;(vm, cell)) {
<span class="udiff-line-modified-removed">-                     if (hasTypeProfiler) {</span>
<span class="udiff-line-modified-added">+                     if (m_unlinkedCode-&gt;wasCompiledWithTypeProfilerOpcodes()) {</span>
                          ConcurrentJSLocker locker(symbolTable-&gt;m_lock);
                          symbolTable-&gt;prepareForTypeProfiling(locker);
                      }
  
                      SymbolTable* clone = symbolTable-&gt;cloneScopePart(vm);
                      if (wasCompiledWithDebuggingOpcodes())
                          clone-&gt;setRareDataCodeBlock(this);
  
                      constant = clone;
                  } else if (auto* descriptor = jsDynamicCast&lt;JSTemplateObjectDescriptor*&gt;(vm, cell)) {
<span class="udiff-line-modified-removed">-                     auto* templateObject = descriptor-&gt;createTemplateObject(exec);</span>
<span class="udiff-line-modified-added">+                     auto* templateObject = topLevelExecutable-&gt;createTemplateObject(exec, descriptor);</span>
                      RETURN_IF_EXCEPTION(scope, void());
                      constant = templateObject;
                  }
              }
          }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -924,17 +938,17 @@</span>
  
  void CodeBlock::setNumParameters(int newValue)
  {
      m_numParameters = newValue;
  
<span class="udiff-line-modified-removed">-     m_argumentValueProfiles = RefCountedArray&lt;ValueProfile&gt;(vm()-&gt;canUseJIT() ? newValue : 0);</span>
<span class="udiff-line-modified-added">+     m_argumentValueProfiles = RefCountedArray&lt;ValueProfile&gt;(vm().canUseJIT() ? newValue : 0);</span>
  }
  
  CodeBlock* CodeBlock::specialOSREntryBlockOrNull()
  {
  #if ENABLE(FTL_JIT)
<span class="udiff-line-modified-removed">-     if (jitType() != JITCode::DFGJIT)</span>
<span class="udiff-line-modified-added">+     if (jitType() != JITType::DFGJIT)</span>
          return 0;
      DFG::JITCode* jitCode = m_jitCode-&gt;dfg();
      return jitCode-&gt;osrEntryBlock();
  #else // ENABLE(FTL_JIT)
      return 0;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -945,12 +959,13 @@</span>
  {
      CodeBlock* thisObject = jsCast&lt;CodeBlock*&gt;(cell);
      size_t extraMemoryAllocated = 0;
      if (thisObject-&gt;m_metadata)
          extraMemoryAllocated += thisObject-&gt;m_metadata-&gt;sizeInBytes();
<span class="udiff-line-modified-removed">-     if (thisObject-&gt;m_jitCode)</span>
<span class="udiff-line-modified-removed">-         extraMemoryAllocated += thisObject-&gt;m_jitCode-&gt;size();</span>
<span class="udiff-line-modified-added">+     RefPtr&lt;JITCode&gt; jitCode = thisObject-&gt;m_jitCode;</span>
<span class="udiff-line-modified-added">+     if (jitCode &amp;&amp; !jitCode-&gt;isShared())</span>
<span class="udiff-line-added">+         extraMemoryAllocated += jitCode-&gt;size();</span>
      return Base::estimatedSize(cell, vm) + extraMemoryAllocated;
  }
  
  void CodeBlock::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
  {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -968,11 +983,11 @@</span>
          visitor.appendUnbarriered(otherBlock);
  
      size_t extraMemory = 0;
      if (m_metadata)
          extraMemory += m_metadata-&gt;sizeInBytes();
<span class="udiff-line-modified-removed">-     if (m_jitCode)</span>
<span class="udiff-line-modified-added">+     if (m_jitCode &amp;&amp; !m_jitCode-&gt;isShared())</span>
          extraMemory += m_jitCode-&gt;size();
      visitor.reportExtraMemoryVisited(extraMemory);
  
      stronglyVisitStrongReferences(locker, visitor);
      stronglyVisitWeakReferences(locker, visitor);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -995,53 +1010,53 @@</span>
          return true;
  
      return false;
  }
  
<span class="udiff-line-modified-removed">- bool CodeBlock::shouldJettisonDueToWeakReference()</span>
<span class="udiff-line-modified-added">+ bool CodeBlock::shouldJettisonDueToWeakReference(VM&amp; vm)</span>
  {
      if (!JITCode::isOptimizingJIT(jitType()))
          return false;
<span class="udiff-line-modified-removed">-     return !Heap::isMarked(this);</span>
<span class="udiff-line-modified-added">+     return !vm.heap.isMarked(this);</span>
  }
  
<span class="udiff-line-modified-removed">- static Seconds timeToLive(JITCode::JITType jitType)</span>
<span class="udiff-line-modified-added">+ static Seconds timeToLive(JITType jitType)</span>
  {
      if (UNLIKELY(Options::useEagerCodeBlockJettisonTiming())) {
          switch (jitType) {
<span class="udiff-line-modified-removed">-         case JITCode::InterpreterThunk:</span>
<span class="udiff-line-modified-added">+         case JITType::InterpreterThunk:</span>
              return 10_ms;
<span class="udiff-line-modified-removed">-         case JITCode::BaselineJIT:</span>
<span class="udiff-line-modified-added">+         case JITType::BaselineJIT:</span>
              return 30_ms;
<span class="udiff-line-modified-removed">-         case JITCode::DFGJIT:</span>
<span class="udiff-line-modified-added">+         case JITType::DFGJIT:</span>
              return 40_ms;
<span class="udiff-line-modified-removed">-         case JITCode::FTLJIT:</span>
<span class="udiff-line-modified-added">+         case JITType::FTLJIT:</span>
              return 120_ms;
          default:
              return Seconds::infinity();
          }
      }
  
      switch (jitType) {
<span class="udiff-line-modified-removed">-     case JITCode::InterpreterThunk:</span>
<span class="udiff-line-modified-added">+     case JITType::InterpreterThunk:</span>
          return 5_s;
<span class="udiff-line-modified-removed">-     case JITCode::BaselineJIT:</span>
<span class="udiff-line-modified-added">+     case JITType::BaselineJIT:</span>
          // Effectively 10 additional seconds, since BaselineJIT and
          // InterpreterThunk share a CodeBlock.
          return 15_s;
<span class="udiff-line-modified-removed">-     case JITCode::DFGJIT:</span>
<span class="udiff-line-modified-added">+     case JITType::DFGJIT:</span>
          return 20_s;
<span class="udiff-line-modified-removed">-     case JITCode::FTLJIT:</span>
<span class="udiff-line-modified-added">+     case JITType::FTLJIT:</span>
          return 60_s;
      default:
          return Seconds::infinity();
      }
  }
  
  bool CodeBlock::shouldJettisonDueToOldAge(const ConcurrentJSLocker&amp;)
  {
<span class="udiff-line-modified-removed">-     if (Heap::isMarked(this))</span>
<span class="udiff-line-modified-added">+     if (m_vm-&gt;heap.isMarked(this))</span>
          return false;
  
      if (UNLIKELY(Options::forceCodeBlockToJettisonDueToOldAge()))
          return true;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1050,16 +1065,16 @@</span>
  
      return true;
  }
  
  #if ENABLE(DFG_JIT)
<span class="udiff-line-modified-removed">- static bool shouldMarkTransition(DFG::WeakReferenceTransition&amp; transition)</span>
<span class="udiff-line-modified-added">+ static bool shouldMarkTransition(VM&amp; vm, DFG::WeakReferenceTransition&amp; transition)</span>
  {
<span class="udiff-line-modified-removed">-     if (transition.m_codeOrigin &amp;&amp; !Heap::isMarked(transition.m_codeOrigin.get()))</span>
<span class="udiff-line-modified-added">+     if (transition.m_codeOrigin &amp;&amp; !vm.heap.isMarked(transition.m_codeOrigin.get()))</span>
          return false;
  
<span class="udiff-line-modified-removed">-     if (!Heap::isMarked(transition.m_from.get()))</span>
<span class="udiff-line-modified-added">+     if (!vm.heap.isMarked(transition.m_from.get()))</span>
          return false;
  
      return true;
  }
  #endif // ENABLE(DFG_JIT)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1068,11 +1083,11 @@</span>
  {
      UNUSED_PARAM(visitor);
  
      VM&amp; vm = *m_vm;
  
<span class="udiff-line-modified-removed">-     if (jitType() == JITCode::InterpreterThunk) {</span>
<span class="udiff-line-modified-added">+     if (jitType() == JITType::InterpreterThunk) {</span>
          const Vector&lt;InstructionStream::Offset&gt;&amp; propertyAccessInstructions = m_unlinkedCode-&gt;propertyAccessInstructions();
          const InstructionStream&amp; instructionStream = instructions();
          for (size_t i = 0; i &lt; propertyAccessInstructions.size(); ++i) {
              auto instruction = instructionStream.at(propertyAccessInstructions[i]);
              if (instruction-&gt;is&lt;OpPutById&gt;()) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1083,11 +1098,11 @@</span>
                      continue;
                  Structure* oldStructure =
                      vm.heap.structureIDTable().get(oldStructureID);
                  Structure* newStructure =
                      vm.heap.structureIDTable().get(newStructureID);
<span class="udiff-line-modified-removed">-                 if (Heap::isMarked(oldStructure))</span>
<span class="udiff-line-modified-added">+                 if (vm.heap.isMarked(oldStructure))</span>
                      visitor.appendUnbarriered(newStructure);
                  continue;
              }
          }
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1109,11 +1124,11 @@</span>
  
          for (auto&amp; weakReference : dfgCommon-&gt;weakStructureReferences)
              weakReference-&gt;markIfCheap(visitor);
  
          for (auto&amp; transition : dfgCommon-&gt;transitions) {
<span class="udiff-line-modified-removed">-             if (shouldMarkTransition(transition)) {</span>
<span class="udiff-line-modified-added">+             if (shouldMarkTransition(vm, transition)) {</span>
                  // If the following three things are live, then the target of the
                  // transition is also live:
                  //
                  // - This code block. We know it&#39;s live already because otherwise
                  //   we wouldn&#39;t be scanning ourselves.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1141,11 +1156,12 @@</span>
  void CodeBlock::determineLiveness(const ConcurrentJSLocker&amp;, SlotVisitor&amp; visitor)
  {
      UNUSED_PARAM(visitor);
  
  #if ENABLE(DFG_JIT)
<span class="udiff-line-modified-removed">-     if (Heap::isMarked(this))</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = *m_vm;</span>
<span class="udiff-line-added">+     if (vm.heap.isMarked(this))</span>
          return;
  
      // In rare and weird cases, this could be called on a baseline CodeBlock. One that I found was
      // that we might decide that the CodeBlock should be jettisoned due to old age, so the
      // isMarked check doesn&#39;t protect us.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1157,19 +1173,19 @@</span>
      // have proved liveness and so we scan our strong references. If at end of
      // GC we still have not proved liveness, then this code block is toast.
      bool allAreLiveSoFar = true;
      for (unsigned i = 0; i &lt; dfgCommon-&gt;weakReferences.size(); ++i) {
          JSCell* reference = dfgCommon-&gt;weakReferences[i].get();
<span class="udiff-line-modified-removed">-         ASSERT(!jsDynamicCast&lt;CodeBlock*&gt;(*reference-&gt;vm(), reference));</span>
<span class="udiff-line-modified-removed">-         if (!Heap::isMarked(reference)) {</span>
<span class="udiff-line-modified-added">+         ASSERT(!jsDynamicCast&lt;CodeBlock*&gt;(vm, reference));</span>
<span class="udiff-line-modified-added">+         if (!vm.heap.isMarked(reference)) {</span>
              allAreLiveSoFar = false;
              break;
          }
      }
      if (allAreLiveSoFar) {
          for (unsigned i = 0; i &lt; dfgCommon-&gt;weakStructureReferences.size(); ++i) {
<span class="udiff-line-modified-removed">-             if (!Heap::isMarked(dfgCommon-&gt;weakStructureReferences[i].get())) {</span>
<span class="udiff-line-modified-added">+             if (!vm.heap.isMarked(dfgCommon-&gt;weakStructureReferences[i].get())) {</span>
                  allAreLiveSoFar = false;
                  break;
              }
          }
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1188,17 +1204,17 @@</span>
  void CodeBlock::finalizeLLIntInlineCaches()
  {
      VM&amp; vm = *m_vm;
      const Vector&lt;InstructionStream::Offset&gt;&amp; propertyAccessInstructions = m_unlinkedCode-&gt;propertyAccessInstructions();
  
<span class="udiff-line-modified-removed">-     auto handleGetPutFromScope = [](auto&amp; metadata) {</span>
<span class="udiff-line-modified-added">+     auto handleGetPutFromScope = [&amp;] (auto&amp; metadata) {</span>
          GetPutInfo getPutInfo = metadata.m_getPutInfo;
          if (getPutInfo.resolveType() == GlobalVar || getPutInfo.resolveType() == GlobalVarWithVarInjectionChecks
              || getPutInfo.resolveType() == LocalClosureVar || getPutInfo.resolveType() == GlobalLexicalVar || getPutInfo.resolveType() == GlobalLexicalVarWithVarInjectionChecks)
              return;
          WriteBarrierBase&lt;Structure&gt;&amp; structure = metadata.m_structure;
<span class="udiff-line-modified-removed">-         if (!structure || Heap::isMarked(structure.get()))</span>
<span class="udiff-line-modified-added">+         if (!structure || vm.heap.isMarked(structure.get()))</span>
              return;
          if (Options::verboseOSR())
              dataLogF(&quot;Clearing scope access with structure %p.\n&quot;, structure.get());
          structure.clear();
      };
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1207,24 +1223,24 @@</span>
      for (size_t size = propertyAccessInstructions.size(), i = 0; i &lt; size; ++i) {
          const auto curInstruction = instructionStream.at(propertyAccessInstructions[i]);
          switch (curInstruction-&gt;opcodeID()) {
          case op_get_by_id: {
              auto&amp; metadata = curInstruction-&gt;as&lt;OpGetById&gt;().metadata(this);
<span class="udiff-line-modified-removed">-             if (metadata.m_mode != GetByIdMode::Default)</span>
<span class="udiff-line-modified-added">+             if (metadata.m_modeMetadata.mode != GetByIdMode::Default)</span>
                  break;
              StructureID oldStructureID = metadata.m_modeMetadata.defaultMode.structureID;
<span class="udiff-line-modified-removed">-             if (!oldStructureID || Heap::isMarked(vm.heap.structureIDTable().get(oldStructureID)))</span>
<span class="udiff-line-modified-added">+             if (!oldStructureID || vm.heap.isMarked(vm.heap.structureIDTable().get(oldStructureID)))</span>
                  break;
              if (Options::verboseOSR())
                  dataLogF(&quot;Clearing LLInt property access.\n&quot;);
              LLIntPrototypeLoadAdaptiveStructureWatchpoint::clearLLIntGetByIdCache(metadata);
              break;
          }
          case op_get_by_id_direct: {
              auto&amp; metadata = curInstruction-&gt;as&lt;OpGetByIdDirect&gt;().metadata(this);
              StructureID oldStructureID = metadata.m_structureID;
<span class="udiff-line-modified-removed">-             if (!oldStructureID || Heap::isMarked(vm.heap.structureIDTable().get(oldStructureID)))</span>
<span class="udiff-line-modified-added">+             if (!oldStructureID || vm.heap.isMarked(vm.heap.structureIDTable().get(oldStructureID)))</span>
                  break;
              if (Options::verboseOSR())
                  dataLogF(&quot;Clearing LLInt property access.\n&quot;);
              metadata.m_structureID = 0;
              metadata.m_offset = 0;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1233,13 +1249,13 @@</span>
          case op_put_by_id: {
              auto&amp; metadata = curInstruction-&gt;as&lt;OpPutById&gt;().metadata(this);
              StructureID oldStructureID = metadata.m_oldStructureID;
              StructureID newStructureID = metadata.m_newStructureID;
              StructureChain* chain = metadata.m_structureChain.get();
<span class="udiff-line-modified-removed">-             if ((!oldStructureID || Heap::isMarked(vm.heap.structureIDTable().get(oldStructureID)))</span>
<span class="udiff-line-modified-removed">-                 &amp;&amp; (!newStructureID || Heap::isMarked(vm.heap.structureIDTable().get(newStructureID)))</span>
<span class="udiff-line-modified-removed">-                 &amp;&amp; (!chain || Heap::isMarked(chain)))</span>
<span class="udiff-line-modified-added">+             if ((!oldStructureID || vm.heap.isMarked(vm.heap.structureIDTable().get(oldStructureID)))</span>
<span class="udiff-line-modified-added">+                 &amp;&amp; (!newStructureID || vm.heap.isMarked(vm.heap.structureIDTable().get(newStructureID)))</span>
<span class="udiff-line-modified-added">+                 &amp;&amp; (!chain || vm.heap.isMarked(chain)))</span>
                  break;
              if (Options::verboseOSR())
                  dataLogF(&quot;Clearing LLInt put transition.\n&quot;);
              metadata.m_oldStructureID = 0;
              metadata.m_offset = 0;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1251,25 +1267,27 @@</span>
          // We need to add optimizations for op_resolve_scope_for_hoisting_func_decl_in_eval to do link time scope resolution.
          case op_resolve_scope_for_hoisting_func_decl_in_eval:
              break;
          case op_to_this: {
              auto&amp; metadata = curInstruction-&gt;as&lt;OpToThis&gt;().metadata(this);
<span class="udiff-line-modified-removed">-             if (!metadata.m_cachedStructure || Heap::isMarked(metadata.m_cachedStructure.get()))</span>
<span class="udiff-line-modified-added">+             if (!metadata.m_cachedStructureID || vm.heap.isMarked(vm.heap.structureIDTable().get(metadata.m_cachedStructureID)))</span>
                  break;
<span class="udiff-line-modified-removed">-             if (Options::verboseOSR())</span>
<span class="udiff-line-modified-removed">-                 dataLogF(&quot;Clearing LLInt to_this with structure %p.\n&quot;, metadata.m_cachedStructure.get());</span>
<span class="udiff-line-modified-removed">-             metadata.m_cachedStructure.clear();</span>
<span class="udiff-line-modified-added">+             if (Options::verboseOSR()) {</span>
<span class="udiff-line-modified-added">+                 Structure* structure = vm.heap.structureIDTable().get(metadata.m_cachedStructureID);</span>
<span class="udiff-line-modified-added">+                 dataLogF(&quot;Clearing LLInt to_this with structure %p.\n&quot;, structure);</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             metadata.m_cachedStructureID = 0;</span>
              metadata.m_toThisStatus = merge(metadata.m_toThisStatus, ToThisClearedByGC);
              break;
          }
          case op_create_this: {
              auto&amp; metadata = curInstruction-&gt;as&lt;OpCreateThis&gt;().metadata(this);
              auto&amp; cacheWriteBarrier = metadata.m_cachedCallee;
              if (!cacheWriteBarrier || cacheWriteBarrier.unvalidatedGet() == JSCell::seenMultipleCalleeObjects())
                  break;
              JSCell* cachedFunction = cacheWriteBarrier.get();
<span class="udiff-line-modified-removed">-             if (Heap::isMarked(cachedFunction))</span>
<span class="udiff-line-modified-added">+             if (vm.heap.isMarked(cachedFunction))</span>
                  break;
              if (Options::verboseOSR())
                  dataLogF(&quot;Clearing LLInt create_this with cached callee %p.\n&quot;, cachedFunction);
              cacheWriteBarrier.clear();
              break;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1278,11 +1296,11 @@</span>
              // Right now this isn&#39;t strictly necessary. Any symbol tables that this will refer to
              // are for outer functions, and we refer to those functions strongly, and they refer
              // to the symbol table strongly. But it&#39;s nice to be on the safe side.
              auto&amp; metadata = curInstruction-&gt;as&lt;OpResolveScope&gt;().metadata(this);
              WriteBarrierBase&lt;SymbolTable&gt;&amp; symbolTable = metadata.m_symbolTable;
<span class="udiff-line-modified-removed">-             if (!symbolTable || Heap::isMarked(symbolTable.get()))</span>
<span class="udiff-line-modified-added">+             if (!symbolTable || vm.heap.isMarked(symbolTable.get()))</span>
                  break;
              if (Options::verboseOSR())
                  dataLogF(&quot;Clearing dead symbolTable %p.\n&quot;, symbolTable.get());
              symbolTable.clear();
              break;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1301,64 +1319,66 @@</span>
  
      // We can&#39;t just remove all the sets when we clear the caches since we might have created a watchpoint set
      // then cleared the cache without GCing in between.
      m_llintGetByIdWatchpointMap.removeIf([&amp;] (const StructureWatchpointMap::KeyValuePairType&amp; pair) -&gt; bool {
          auto clear = [&amp;] () {
<span class="udiff-line-modified-removed">-             const Instruction* instruction = std::get&lt;1&gt;(pair.key);</span>
<span class="udiff-line-modified-added">+             auto&amp; instruction = instructions().at(std::get&lt;1&gt;(pair.key));</span>
              OpcodeID opcode = instruction-&gt;opcodeID();
              if (opcode == op_get_by_id) {
                  if (Options::verboseOSR())
                      dataLogF(&quot;Clearing LLInt property access.\n&quot;);
                  LLIntPrototypeLoadAdaptiveStructureWatchpoint::clearLLIntGetByIdCache(instruction-&gt;as&lt;OpGetById&gt;().metadata(this));
              }
              return true;
          };
  
<span class="udiff-line-modified-removed">-         if (!Heap::isMarked(std::get&lt;0&gt;(pair.key)))</span>
<span class="udiff-line-modified-added">+         if (!vm.heap.isMarked(vm.heap.structureIDTable().get(std::get&lt;0&gt;(pair.key))))</span>
              return clear();
  
<span class="udiff-line-modified-removed">-         for (const LLIntPrototypeLoadAdaptiveStructureWatchpoint* watchpoint : pair.value) {</span>
<span class="udiff-line-modified-removed">-             if (!watchpoint-&gt;key().isStillLive())</span>
<span class="udiff-line-modified-added">+         for (const LLIntPrototypeLoadAdaptiveStructureWatchpoint&amp; watchpoint : pair.value) {</span>
<span class="udiff-line-modified-added">+             if (!watchpoint.key().isStillLive(vm))</span>
                  return clear();
          }
  
          return false;
      });
  
      forEachLLIntCallLinkInfo([&amp;](LLIntCallLinkInfo&amp; callLinkInfo) {
<span class="udiff-line-modified-removed">-         if (callLinkInfo.isLinked() &amp;&amp; !Heap::isMarked(callLinkInfo.callee.get())) {</span>
<span class="udiff-line-modified-added">+         if (callLinkInfo.isLinked() &amp;&amp; !vm.heap.isMarked(callLinkInfo.callee())) {</span>
              if (Options::verboseOSR())
                  dataLog(&quot;Clearing LLInt call from &quot;, *this, &quot;\n&quot;);
              callLinkInfo.unlink();
          }
<span class="udiff-line-modified-removed">-         if (!!callLinkInfo.lastSeenCallee &amp;&amp; !Heap::isMarked(callLinkInfo.lastSeenCallee.get()))</span>
<span class="udiff-line-modified-removed">-             callLinkInfo.lastSeenCallee.clear();</span>
<span class="udiff-line-modified-added">+         if (callLinkInfo.lastSeenCallee() &amp;&amp; !vm.heap.isMarked(callLinkInfo.lastSeenCallee()))</span>
<span class="udiff-line-modified-added">+             callLinkInfo.clearLastSeenCallee();</span>
      });
  }
  
  #if ENABLE(JIT)
  CodeBlock::JITData&amp; CodeBlock::ensureJITDataSlow(const ConcurrentJSLocker&amp;)
  {
      ASSERT(!m_jitData);
<span class="udiff-line-modified-removed">-     m_jitData = std::make_unique&lt;JITData&gt;();</span>
<span class="udiff-line-modified-added">+     m_jitData = makeUnique&lt;JITData&gt;();</span>
      return *m_jitData;
  }
  
  void CodeBlock::finalizeBaselineJITInlineCaches()
  {
      if (auto* jitData = m_jitData.get()) {
          for (CallLinkInfo* callLinkInfo : jitData-&gt;m_callLinkInfos)
<span class="udiff-line-modified-removed">-             callLinkInfo-&gt;visitWeak(*vm());</span>
<span class="udiff-line-modified-added">+             callLinkInfo-&gt;visitWeak(vm());</span>
  
          for (StructureStubInfo* stubInfo : jitData-&gt;m_stubInfos)
              stubInfo-&gt;visitWeakReferences(this);
      }
  }
  #endif
  
<span class="udiff-line-modified-removed">- void CodeBlock::finalizeUnconditionally(VM&amp;)</span>
<span class="udiff-line-modified-added">+ void CodeBlock::finalizeUnconditionally(VM&amp; vm)</span>
  {
<span class="udiff-line-added">+     UNUSED_PARAM(vm);</span>
<span class="udiff-line-added">+ </span>
      updateAllPredictions();
  
      if (JITCode::couldBeInterpreted(jitType()))
          finalizeLLIntInlineCaches();
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1368,14 +1388,49 @@</span>
  #endif
  
  #if ENABLE(DFG_JIT)
      if (JITCode::isOptimizingJIT(jitType())) {
          DFG::CommonData* dfgCommon = m_jitCode-&gt;dfgCommon();
<span class="udiff-line-modified-removed">-         dfgCommon-&gt;recordedStatuses.finalize();</span>
<span class="udiff-line-modified-added">+         dfgCommon-&gt;recordedStatuses.finalize(vm);</span>
      }
  #endif // ENABLE(DFG_JIT)
  
<span class="udiff-line-added">+     auto updateActivity = [&amp;] {</span>
<span class="udiff-line-added">+         if (!VM::useUnlinkedCodeBlockJettisoning())</span>
<span class="udiff-line-added">+             return;</span>
<span class="udiff-line-added">+         JITCode* jitCode = m_jitCode.get();</span>
<span class="udiff-line-added">+         double count = 0;</span>
<span class="udiff-line-added">+         bool alwaysActive = false;</span>
<span class="udiff-line-added">+         switch (JITCode::jitTypeFor(jitCode)) {</span>
<span class="udiff-line-added">+         case JITType::None:</span>
<span class="udiff-line-added">+         case JITType::HostCallThunk:</span>
<span class="udiff-line-added">+             return;</span>
<span class="udiff-line-added">+         case JITType::InterpreterThunk:</span>
<span class="udiff-line-added">+             count = m_llintExecuteCounter.count();</span>
<span class="udiff-line-added">+             break;</span>
<span class="udiff-line-added">+         case JITType::BaselineJIT:</span>
<span class="udiff-line-added">+             count = m_jitExecuteCounter.count();</span>
<span class="udiff-line-added">+             break;</span>
<span class="udiff-line-added">+         case JITType::DFGJIT:</span>
<span class="udiff-line-added">+ #if ENABLE(FTL_JIT)</span>
<span class="udiff-line-added">+             count = static_cast&lt;DFG::JITCode*&gt;(jitCode)-&gt;tierUpCounter.count();</span>
<span class="udiff-line-added">+ #else</span>
<span class="udiff-line-added">+             alwaysActive = true;</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+             break;</span>
<span class="udiff-line-added">+         case JITType::FTLJIT:</span>
<span class="udiff-line-added">+             alwaysActive = true;</span>
<span class="udiff-line-added">+             break;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         if (alwaysActive || m_previousCounter &lt; count) {</span>
<span class="udiff-line-added">+             // CodeBlock is active right now, so resetting UnlinkedCodeBlock&#39;s age.</span>
<span class="udiff-line-added">+             m_unlinkedCode-&gt;resetAge();</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         m_previousCounter = count;</span>
<span class="udiff-line-added">+     };</span>
<span class="udiff-line-added">+     updateActivity();</span>
<span class="udiff-line-added">+ </span>
      VM::SpaceAndSet::setFor(*subspace()).remove(this);
  }
  
  void CodeBlock::destroy(JSCell* cell)
  {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1424,32 +1479,32 @@</span>
  {
      ConcurrentJSLocker locker(m_lock);
      return ensureJITData(locker).m_stubInfos.add(accessType);
  }
  
<span class="udiff-line-modified-removed">- JITAddIC* CodeBlock::addJITAddIC(ArithProfile* arithProfile, const Instruction* instruction)</span>
<span class="udiff-line-modified-added">+ JITAddIC* CodeBlock::addJITAddIC(ArithProfile* arithProfile)</span>
  {
      ConcurrentJSLocker locker(m_lock);
<span class="udiff-line-modified-removed">-     return ensureJITData(locker).m_addICs.add(arithProfile, instruction);</span>
<span class="udiff-line-modified-added">+     return ensureJITData(locker).m_addICs.add(arithProfile);</span>
  }
  
<span class="udiff-line-modified-removed">- JITMulIC* CodeBlock::addJITMulIC(ArithProfile* arithProfile, const Instruction* instruction)</span>
<span class="udiff-line-modified-added">+ JITMulIC* CodeBlock::addJITMulIC(ArithProfile* arithProfile)</span>
  {
      ConcurrentJSLocker locker(m_lock);
<span class="udiff-line-modified-removed">-     return ensureJITData(locker).m_mulICs.add(arithProfile, instruction);</span>
<span class="udiff-line-modified-added">+     return ensureJITData(locker).m_mulICs.add(arithProfile);</span>
  }
  
<span class="udiff-line-modified-removed">- JITSubIC* CodeBlock::addJITSubIC(ArithProfile* arithProfile, const Instruction* instruction)</span>
<span class="udiff-line-modified-added">+ JITSubIC* CodeBlock::addJITSubIC(ArithProfile* arithProfile)</span>
  {
      ConcurrentJSLocker locker(m_lock);
<span class="udiff-line-modified-removed">-     return ensureJITData(locker).m_subICs.add(arithProfile, instruction);</span>
<span class="udiff-line-modified-added">+     return ensureJITData(locker).m_subICs.add(arithProfile);</span>
  }
  
<span class="udiff-line-modified-removed">- JITNegIC* CodeBlock::addJITNegIC(ArithProfile* arithProfile, const Instruction* instruction)</span>
<span class="udiff-line-modified-added">+ JITNegIC* CodeBlock::addJITNegIC(ArithProfile* arithProfile)</span>
  {
      ConcurrentJSLocker locker(m_lock);
<span class="udiff-line-modified-removed">-     return ensureJITData(locker).m_negICs.add(arithProfile, instruction);</span>
<span class="udiff-line-modified-added">+     return ensureJITData(locker).m_negICs.add(arithProfile);</span>
  }
  
  StructureStubInfo* CodeBlock::findStubInfo(CodeOrigin codeOrigin)
  {
      ConcurrentJSLocker locker(m_lock);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1513,11 +1568,11 @@</span>
  }
  
  void CodeBlock::setCalleeSaveRegisters(RegisterSet calleeSaveRegisters)
  {
      ConcurrentJSLocker locker(m_lock);
<span class="udiff-line-modified-removed">-     ensureJITData(locker).m_calleeSaveRegisters = std::make_unique&lt;RegisterAtOffsetList&gt;(calleeSaveRegisters);</span>
<span class="udiff-line-modified-added">+     ensureJITData(locker).m_calleeSaveRegisters = makeUnique&lt;RegisterAtOffsetList&gt;(calleeSaveRegisters);</span>
  }
  
  void CodeBlock::setCalleeSaveRegisters(std::unique_ptr&lt;RegisterAtOffsetList&gt; registerAtOffsetList)
  {
      ConcurrentJSLocker locker(m_lock);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1627,21 +1682,21 @@</span>
  #if ENABLE(JIT)
      CodeBlock* result = this;
      while (result-&gt;alternative())
          result = result-&gt;alternative();
      RELEASE_ASSERT(result);
<span class="udiff-line-modified-removed">-     RELEASE_ASSERT(JITCode::isBaselineCode(result-&gt;jitType()) || result-&gt;jitType() == JITCode::None);</span>
<span class="udiff-line-modified-added">+     RELEASE_ASSERT(JITCode::isBaselineCode(result-&gt;jitType()) || result-&gt;jitType() == JITType::None);</span>
      return result;
  #else
      return this;
  #endif
  }
  
  CodeBlock* CodeBlock::baselineVersion()
  {
  #if ENABLE(JIT)
<span class="udiff-line-modified-removed">-     JITCode::JITType selfJITType = jitType();</span>
<span class="udiff-line-modified-added">+     JITType selfJITType = jitType();</span>
      if (JITCode::isBaselineCode(selfJITType))
          return this;
      CodeBlock* result = replacement();
      if (!result) {
          if (JITCode::isOptimizingJIT(selfJITType)) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1651,11 +1706,11 @@</span>
              // codeBlock, it will keep its baselineAlternative() alive for us to fetch below.
              result = this;
          } else {
              // This can happen if we&#39;re creating the original CodeBlock for an executable.
              // Assume that we&#39;re the baseline CodeBlock.
<span class="udiff-line-modified-removed">-             RELEASE_ASSERT(selfJITType == JITCode::None);</span>
<span class="udiff-line-modified-added">+             RELEASE_ASSERT(selfJITType == JITType::None);</span>
              return this;
          }
      }
      result = result-&gt;baselineAlternative();
      ASSERT(result);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1664,11 +1719,11 @@</span>
      return this;
  #endif
  }
  
  #if ENABLE(JIT)
<span class="udiff-line-modified-removed">- bool CodeBlock::hasOptimizedReplacement(JITCode::JITType typeToReplace)</span>
<span class="udiff-line-modified-added">+ bool CodeBlock::hasOptimizedReplacement(JITType typeToReplace)</span>
  {
      CodeBlock* replacement = this-&gt;replacement();
      return replacement &amp;&amp; JITCode::isHigherTier(replacement-&gt;jitType(), typeToReplace);
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1753,11 +1808,11 @@</span>
      });
  
      for (int i = 0; i &lt; numParameters(); ++i)
          liveOperands.append(virtualRegisterForArgument(i));
  
<span class="udiff-line-modified-removed">-     auto profiles = std::make_unique&lt;ValueProfileAndOperandBuffer&gt;(liveOperands.size());</span>
<span class="udiff-line-modified-added">+     auto profiles = makeUnique&lt;ValueProfileAndOperandBuffer&gt;(liveOperands.size());</span>
      RELEASE_ASSERT(profiles-&gt;m_size == liveOperands.size());
      for (unsigned i = 0; i &lt; profiles-&gt;m_size; ++i)
          profiles-&gt;m_buffer.get()[i].m_operand = liveOperands[i].offset();
  
      createRareDataIfNecessary();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1879,13 +1934,13 @@</span>
          ConcurrentJSLocker locker(m_lock);
          jitData = m_jitData.get();
      }
      if (jitData) {
          while (jitData-&gt;m_incomingCalls.begin() != jitData-&gt;m_incomingCalls.end())
<span class="udiff-line-modified-removed">-             jitData-&gt;m_incomingCalls.begin()-&gt;unlink(*vm());</span>
<span class="udiff-line-modified-added">+             jitData-&gt;m_incomingCalls.begin()-&gt;unlink(vm());</span>
          while (jitData-&gt;m_incomingPolymorphicCalls.begin() != jitData-&gt;m_incomingPolymorphicCalls.end())
<span class="udiff-line-modified-removed">-             jitData-&gt;m_incomingPolymorphicCalls.begin()-&gt;unlink(*vm());</span>
<span class="udiff-line-modified-added">+             jitData-&gt;m_incomingPolymorphicCalls.begin()-&gt;unlink(vm());</span>
      }
  #endif // ENABLE(JIT)
  }
  
  void CodeBlock::linkIncomingCall(ExecState* callerFrame, LLIntCallLinkInfo* incoming)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1900,11 +1955,11 @@</span>
  }
  
  #if ENABLE(JIT)
  CodeBlock* CodeBlock::replacement()
  {
<span class="udiff-line-modified-removed">-     const ClassInfo* classInfo = this-&gt;classInfo(*vm());</span>
<span class="udiff-line-modified-added">+     const ClassInfo* classInfo = this-&gt;classInfo(vm());</span>
  
      if (classInfo == FunctionCodeBlock::info())
          return jsCast&lt;FunctionExecutable*&gt;(ownerExecutable())-&gt;codeBlockFor(isConstructor() ? CodeForConstruct : CodeForCall);
  
      if (classInfo == EvalCodeBlock::info())
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1920,11 +1975,11 @@</span>
      return nullptr;
  }
  
  DFG::CapabilityLevel CodeBlock::computeCapabilityLevel()
  {
<span class="udiff-line-modified-removed">-     const ClassInfo* classInfo = this-&gt;classInfo(*vm());</span>
<span class="udiff-line-modified-added">+     const ClassInfo* classInfo = this-&gt;classInfo(vm());</span>
  
      if (classInfo == FunctionCodeBlock::info()) {
          if (isConstructor())
              return DFG::functionForConstructCapabilityLevel(this);
          return DFG::functionForCallCapabilityLevel(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1950,11 +2005,14 @@</span>
  #if !ENABLE(DFG_JIT)
      UNUSED_PARAM(mode);
      UNUSED_PARAM(detail);
  #endif
  
<span class="udiff-line-modified-removed">-     CODEBLOCK_LOG_EVENT(this, &quot;jettison&quot;, (&quot;due to &quot;, reason, &quot;, counting = &quot;, mode == CountReoptimization, &quot;, detail = &quot;, pointerDump(detail)));</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = *m_vm;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     CodeBlock* codeBlock = this; // Placate GCC for use in CODEBLOCK_LOG_EVENT  (does not like this).</span>
<span class="udiff-line-added">+     CODEBLOCK_LOG_EVENT(codeBlock, &quot;jettison&quot;, (&quot;due to &quot;, reason, &quot;, counting = &quot;, mode == CountReoptimization, &quot;, detail = &quot;, pointerDump(detail)));</span>
  
      RELEASE_ASSERT(reason != Profiler::NotJettisoned);
  
  #if ENABLE(DFG_JIT)
      if (DFG::shouldDumpDisassembly()) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1973,25 +2031,24 @@</span>
              DFG::CommonData* dfgCommon = m_jitCode-&gt;dfgCommon();
              for (auto&amp; transition : dfgCommon-&gt;transitions) {
                  JSCell* origin = transition.m_codeOrigin.get();
                  JSCell* from = transition.m_from.get();
                  JSCell* to = transition.m_to.get();
<span class="udiff-line-modified-removed">-                 if ((!origin || Heap::isMarked(origin)) &amp;&amp; Heap::isMarked(from))</span>
<span class="udiff-line-modified-added">+                 if ((!origin || vm.heap.isMarked(origin)) &amp;&amp; vm.heap.isMarked(from))</span>
                      continue;
                  dataLog(&quot;    Transition under &quot;, RawPointer(origin), &quot;, &quot;, RawPointer(from), &quot; -&gt; &quot;, RawPointer(to), &quot;.\n&quot;);
              }
              for (unsigned i = 0; i &lt; dfgCommon-&gt;weakReferences.size(); ++i) {
                  JSCell* weak = dfgCommon-&gt;weakReferences[i].get();
<span class="udiff-line-modified-removed">-                 if (Heap::isMarked(weak))</span>
<span class="udiff-line-modified-added">+                 if (vm.heap.isMarked(weak))</span>
                      continue;
                  dataLog(&quot;    Weak reference &quot;, RawPointer(weak), &quot;.\n&quot;);
              }
          }
      }
  #endif // ENABLE(DFG_JIT)
  
<span class="udiff-line-removed">-     VM&amp; vm = *m_vm;</span>
      DeferGCForAWhile deferGC(*heap());
  
      // We want to accomplish two things here:
      // 1) Make sure that if this CodeBlock is on the stack right now, then if we return to it
      //    we should OSR exit at the top of the next bytecode instruction after the return.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2007,11 +2064,11 @@</span>
              compilation-&gt;setJettisonReason(reason, detail);
  
          // This accomplishes (1), and does its own book-keeping about whether it has already happened.
          if (!jitCode()-&gt;dfgCommon()-&gt;invalidate()) {
              // We&#39;ve already been invalidated.
<span class="udiff-line-modified-removed">-             RELEASE_ASSERT(this != replacement() || (vm.heap.isCurrentThreadBusy() &amp;&amp; !Heap::isMarked(ownerExecutable())));</span>
<span class="udiff-line-modified-added">+             RELEASE_ASSERT(this != replacement() || (vm.heap.isCurrentThreadBusy() &amp;&amp; !vm.heap.isMarked(ownerExecutable())));</span>
              return;
          }
      }
  
      if (DFG::shouldDumpDisassembly())
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2039,13 +2096,23 @@</span>
          tallyFrequentExitSites();
  #endif // ENABLE(DFG_JIT)
  
      // Jettison can happen during GC. We don&#39;t want to install code to a dead executable
      // because that would add a dead object to the remembered set.
<span class="udiff-line-modified-removed">-     if (vm.heap.isCurrentThreadBusy() &amp;&amp; !Heap::isMarked(ownerExecutable()))</span>
<span class="udiff-line-modified-added">+     if (vm.heap.isCurrentThreadBusy() &amp;&amp; !vm.heap.isMarked(ownerExecutable()))</span>
          return;
  
<span class="udiff-line-added">+ #if ENABLE(JIT)</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+         ConcurrentJSLocker locker(m_lock);</span>
<span class="udiff-line-added">+         if (JITData* jitData = m_jitData.get()) {</span>
<span class="udiff-line-added">+             for (CallLinkInfo* callLinkInfo : jitData-&gt;m_callLinkInfos)</span>
<span class="udiff-line-added">+                 callLinkInfo-&gt;setClearedByJettison();</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ </span>
      // This accomplishes (2).
      ownerExecutable()-&gt;installCode(vm, alternative(), codeType(), specializationKind());
  
  #if ENABLE(DFG_JIT)
      if (DFG::shouldDumpDisassembly())
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2053,13 +2120,14 @@</span>
  #endif // ENABLE(DFG_JIT)
  }
  
  JSGlobalObject* CodeBlock::globalObjectFor(CodeOrigin codeOrigin)
  {
<span class="udiff-line-modified-removed">-     if (!codeOrigin.inlineCallFrame)</span>
<span class="udiff-line-modified-added">+     auto* inlineCallFrame = codeOrigin.inlineCallFrame();</span>
<span class="udiff-line-added">+     if (!inlineCallFrame)</span>
          return globalObject();
<span class="udiff-line-modified-removed">-     return codeOrigin.inlineCallFrame-&gt;baselineCodeBlock-&gt;globalObject();</span>
<span class="udiff-line-modified-added">+     return inlineCallFrame-&gt;baselineCodeBlock-&gt;globalObject();</span>
  }
  
  class RecursionCheckFunctor {
  public:
      RecursionCheckFunctor(CallFrame* startCallFrame, CodeBlock* codeBlock, unsigned depthToCheck)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2132,11 +2200,11 @@</span>
          if (Options::verboseCallLink())
              dataLog(&quot;    Clearing SABI because caller is too large.\n&quot;);
          return;
      }
  
<span class="udiff-line-modified-removed">-     if (callerCodeBlock-&gt;jitType() == JITCode::InterpreterThunk) {</span>
<span class="udiff-line-modified-added">+     if (callerCodeBlock-&gt;jitType() == JITType::InterpreterThunk) {</span>
          // If the caller is still in the interpreter, then we can&#39;t expect inlining to
          // happen anytime soon. Assume it&#39;s profitable to optimize it separately. This
          // ensures that a function is SABI only if it is called no more frequently than
          // any of its callers.
          m_shouldAlwaysBeInlined = false;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2162,11 +2230,11 @@</span>
          return;
      }
  
      // Recursive calls won&#39;t be inlined.
      RecursionCheckFunctor functor(callerFrame, this, Options::maximumInliningDepth());
<span class="udiff-line-modified-removed">-     vm()-&gt;topCallFrame-&gt;iterate(functor);</span>
<span class="udiff-line-modified-added">+     vm().topCallFrame-&gt;iterate(functor);</span>
  
      if (functor.didRecurse()) {
          if (Options::verboseCallLink())
              dataLog(&quot;    Clearing SABI because recursion was detected.\n&quot;);
          m_shouldAlwaysBeInlined = false;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2320,21 +2388,21 @@</span>
      const double a = 0.061504;
      const double b = 1.02406;
      const double c = 0.0;
      const double d = 0.825914;
  
<span class="udiff-line-modified-removed">-     double instructionCount = this-&gt;instructionCount();</span>
<span class="udiff-line-modified-added">+     double bytecodeCost = this-&gt;bytecodeCost();</span>
  
<span class="udiff-line-modified-removed">-     ASSERT(instructionCount); // Make sure this is called only after we have an instruction stream; otherwise it&#39;ll just return the value of d, which makes no sense.</span>
<span class="udiff-line-modified-added">+     ASSERT(bytecodeCost); // Make sure this is called only after we have an instruction stream; otherwise it&#39;ll just return the value of d, which makes no sense.</span>
  
<span class="udiff-line-modified-removed">-     double result = d + a * sqrt(instructionCount + b) + c * instructionCount;</span>
<span class="udiff-line-modified-added">+     double result = d + a * sqrt(bytecodeCost + b) + c * bytecodeCost;</span>
  
      result *= codeTypeThresholdMultiplier();
  
      if (Options::verboseOSR()) {
          dataLog(
<span class="udiff-line-modified-removed">-             *this, &quot;: instruction count is &quot;, instructionCount,</span>
<span class="udiff-line-modified-added">+             *this, &quot;: bytecode cost is &quot;, bytecodeCost,</span>
              &quot;, scaling execution counter by &quot;, result, &quot; * &quot;, codeTypeThresholdMultiplier(),
              &quot;\n&quot;);
      }
      return result;
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2400,11 +2468,11 @@</span>
      // don&#39;t know where to look for the exit count. Figure out if those loops are severe enough
      // that we had tried to OSR enter. If so, then we should use the loop reoptimization trigger.
      // Otherwise, we should use the normal reoptimization trigger.
  
      bool didTryToEnterInLoop = false;
<span class="udiff-line-modified-removed">-     for (InlineCallFrame* inlineCallFrame = exit.m_codeOrigin.inlineCallFrame; inlineCallFrame; inlineCallFrame = inlineCallFrame-&gt;directCaller.inlineCallFrame) {</span>
<span class="udiff-line-modified-added">+     for (InlineCallFrame* inlineCallFrame = exit.m_codeOrigin.inlineCallFrame(); inlineCallFrame; inlineCallFrame = inlineCallFrame-&gt;directCaller.inlineCallFrame()) {</span>
          if (inlineCallFrame-&gt;baselineCodeBlock-&gt;ownerExecutable()-&gt;didTryToEnterInLoop()) {
              didTryToEnterInLoop = true;
              break;
          }
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2474,14 +2542,14 @@</span>
  }
  
  #if ENABLE(DFG_JIT)
  void CodeBlock::setOptimizationThresholdBasedOnCompilationResult(CompilationResult result)
  {
<span class="udiff-line-modified-removed">-     JITCode::JITType type = jitType();</span>
<span class="udiff-line-modified-removed">-     if (type != JITCode::BaselineJIT) {</span>
<span class="udiff-line-modified-added">+     JITType type = jitType();</span>
<span class="udiff-line-modified-added">+     if (type != JITType::BaselineJIT) {</span>
          dataLog(*this, &quot;: expected to have baseline code but have &quot;, type, &quot;\n&quot;);
<span class="udiff-line-modified-removed">-         CRASH_WITH_INFO(bitwise_cast&lt;uintptr_t&gt;(jitCode().get()), type);</span>
<span class="udiff-line-modified-added">+         CRASH_WITH_INFO(bitwise_cast&lt;uintptr_t&gt;(jitCode().get()), static_cast&lt;uint8_t&gt;(type));</span>
      }
  
      CodeBlock* replacement = this-&gt;replacement();
      bool hasReplacement = (replacement &amp;&amp; replacement != this);
      if ((result == CompilationSuccessful) != hasReplacement) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2560,21 +2628,28 @@</span>
  
  ArrayProfile* CodeBlock::getArrayProfile(const ConcurrentJSLocker&amp;, unsigned bytecodeOffset)
  {
      auto instruction = instructions().at(bytecodeOffset);
      switch (instruction-&gt;opcodeID()) {
<span class="udiff-line-modified-removed">- #define CASE(Op) \</span>
<span class="udiff-line-modified-added">+ #define CASE1(Op) \</span>
      case Op::opcodeID: \
          return &amp;instruction-&gt;as&lt;Op&gt;().metadata(this).m_arrayProfile;
  
<span class="udiff-line-modified-removed">-     FOR_EACH_OPCODE_WITH_ARRAY_PROFILE(CASE)</span>
<span class="udiff-line-modified-removed">- #undef CASE</span>
<span class="udiff-line-modified-added">+ #define CASE2(Op) \</span>
<span class="udiff-line-modified-added">+     case Op::opcodeID: \</span>
<span class="udiff-line-added">+         return &amp;instruction-&gt;as&lt;Op&gt;().metadata(this).m_callLinkInfo.m_arrayProfile;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     FOR_EACH_OPCODE_WITH_ARRAY_PROFILE(CASE1)</span>
<span class="udiff-line-added">+     FOR_EACH_OPCODE_WITH_LLINT_CALL_LINK_INFO(CASE2)</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #undef CASE1</span>
<span class="udiff-line-added">+ #undef CASE2</span>
  
      case OpGetById::opcodeID: {
          auto bytecode = instruction-&gt;as&lt;OpGetById&gt;();
          auto&amp; metadata = bytecode.metadata(this);
<span class="udiff-line-modified-removed">-         if (metadata.m_mode == GetByIdMode::ArrayLength)</span>
<span class="udiff-line-modified-added">+         if (metadata.m_modeMetadata.mode == GetByIdMode::ArrayLength)</span>
              return &amp;metadata.m_modeMetadata.arrayLengthMode.arrayProfile;
          break;
      }
      default:
          break;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2611,35 +2686,36 @@</span>
      ASSERT(JITCode::isOptimizingJIT(jitType()));
      return m_jitCode-&gt;dfgCommon()-&gt;dfgIdentifiers[index - unlinkedIdentifiers];
  }
  #endif // ENABLE(DFG_JIT)
  
<span class="udiff-line-modified-removed">- void CodeBlock::updateAllPredictionsAndCountLiveness(unsigned&amp; numberOfLiveNonArgumentValueProfiles, unsigned&amp; numberOfSamplesInProfiles)</span>
<span class="udiff-line-modified-added">+ void CodeBlock::updateAllValueProfilePredictionsAndCountLiveness(unsigned&amp; numberOfLiveNonArgumentValueProfiles, unsigned&amp; numberOfSamplesInProfiles)</span>
  {
      ConcurrentJSLocker locker(m_lock);
  
      numberOfLiveNonArgumentValueProfiles = 0;
      numberOfSamplesInProfiles = 0; // If this divided by ValueProfile::numberOfBuckets equals numberOfValueProfiles() then value profiles are full.
  
<span class="udiff-line-modified-removed">-     forEachValueProfile([&amp;](ValueProfile&amp; profile) {</span>
<span class="udiff-line-modified-added">+     forEachValueProfile([&amp;](ValueProfile&amp; profile, bool isArgument) {</span>
          unsigned numSamples = profile.totalNumberOfSamples();
<span class="udiff-line-added">+         static_assert(ValueProfile::numberOfBuckets == 1);</span>
          if (numSamples &gt; ValueProfile::numberOfBuckets)
              numSamples = ValueProfile::numberOfBuckets; // We don&#39;t want profiles that are extremely hot to be given more weight.
          numberOfSamplesInProfiles += numSamples;
<span class="udiff-line-modified-removed">-         if (profile.m_bytecodeOffset &lt; 0) {</span>
<span class="udiff-line-modified-added">+         if (isArgument) {</span>
              profile.computeUpdatedPrediction(locker);
              return;
          }
<span class="udiff-line-modified-removed">-         if (profile.numberOfSamples() || profile.m_prediction != SpecNone)</span>
<span class="udiff-line-modified-added">+         if (profile.numberOfSamples() || profile.isSampledBefore())</span>
              numberOfLiveNonArgumentValueProfiles++;
          profile.computeUpdatedPrediction(locker);
      });
  
      if (auto* rareData = m_rareData.get()) {
          for (auto&amp; profileBucket : rareData-&gt;m_catchProfiles) {
              profileBucket-&gt;forEach([&amp;] (ValueProfileAndOperand&amp; profile) {
<span class="udiff-line-modified-removed">-                 profile.m_profile.computeUpdatedPrediction(locker);</span>
<span class="udiff-line-modified-added">+                 profile.computeUpdatedPrediction(locker);</span>
              });
          }
      }
  
  #if ENABLE(DFG_JIT)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2648,11 +2724,11 @@</span>
  }
  
  void CodeBlock::updateAllValueProfilePredictions()
  {
      unsigned ignoredValue1, ignoredValue2;
<span class="udiff-line-modified-removed">-     updateAllPredictionsAndCountLiveness(ignoredValue1, ignoredValue2);</span>
<span class="udiff-line-modified-added">+     updateAllValueProfilePredictionsAndCountLiveness(ignoredValue1, ignoredValue2);</span>
  }
  
  void CodeBlock::updateAllArrayPredictions()
  {
      ConcurrentJSLocker locker(m_lock);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2682,11 +2758,11 @@</span>
  
      updateAllArrayPredictions();
  
      unsigned numberOfLiveNonArgumentValueProfiles;
      unsigned numberOfSamplesInProfiles;
<span class="udiff-line-modified-removed">-     updateAllPredictionsAndCountLiveness(numberOfLiveNonArgumentValueProfiles, numberOfSamplesInProfiles);</span>
<span class="udiff-line-modified-added">+     updateAllValueProfilePredictionsAndCountLiveness(numberOfLiveNonArgumentValueProfiles, numberOfSamplesInProfiles);</span>
  
      if (Options::verboseOSR()) {
          dataLogF(
              &quot;Profile hotness: %lf (%u / %u), %lf (%u / %u)\n&quot;,
              (double)numberOfLiveNonArgumentValueProfiles / numberOfNonArgumentValueProfiles(),
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2708,24 +2784,24 @@</span>
  
  #if ENABLE(DFG_JIT)
  void CodeBlock::tallyFrequentExitSites()
  {
      ASSERT(JITCode::isOptimizingJIT(jitType()));
<span class="udiff-line-modified-removed">-     ASSERT(alternative()-&gt;jitType() == JITCode::BaselineJIT);</span>
<span class="udiff-line-modified-added">+     ASSERT(alternative()-&gt;jitType() == JITType::BaselineJIT);</span>
  
      CodeBlock* profiledBlock = alternative();
  
      switch (jitType()) {
<span class="udiff-line-modified-removed">-     case JITCode::DFGJIT: {</span>
<span class="udiff-line-modified-added">+     case JITType::DFGJIT: {</span>
          DFG::JITCode* jitCode = m_jitCode-&gt;dfg();
          for (auto&amp; exit : jitCode-&gt;osrExit)
              exit.considerAddingAsFrequentExitSite(profiledBlock);
          break;
      }
  
  #if ENABLE(FTL_JIT)
<span class="udiff-line-modified-removed">-     case JITCode::FTLJIT: {</span>
<span class="udiff-line-modified-added">+     case JITType::FTLJIT: {</span>
          // There is no easy way to avoid duplicating this code since the FTL::JITCode::osrExit
          // vector contains a totally different type, that just so happens to behave like
          // DFG::JITCode::osrExit.
          FTL::JITCode* jitCode = m_jitCode-&gt;ftl();
          for (unsigned i = 0; i &lt; jitCode-&gt;osrExit.size(); ++i) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2785,16 +2861,15 @@</span>
  
  #if ENABLE(VERBOSE_VALUE_PROFILE)
  void CodeBlock::dumpValueProfiles()
  {
      dataLog(&quot;ValueProfile for &quot;, *this, &quot;:\n&quot;);
<span class="udiff-line-modified-removed">-     forEachValueProfile([](ValueProfile&amp; profile) {</span>
<span class="udiff-line-modified-removed">-         if (profile.m_bytecodeOffset &lt; 0) {</span>
<span class="udiff-line-modified-removed">-             ASSERT(profile.m_bytecodeOffset == -1);</span>
<span class="udiff-line-modified-removed">-             dataLogF(&quot;   arg = %u: &quot;, i);</span>
<span class="udiff-line-modified-removed">-         } else</span>
<span class="udiff-line-removed">-             dataLogF(&quot;   bc = %d: &quot;, profile.m_bytecodeOffset);</span>
<span class="udiff-line-modified-added">+     forEachValueProfile([](ValueProfile&amp; profile, bool isArgument) {</span>
<span class="udiff-line-modified-added">+         if (isArgument)</span>
<span class="udiff-line-modified-added">+             dataLogF(&quot;   arg: &quot;);</span>
<span class="udiff-line-modified-added">+         else</span>
<span class="udiff-line-modified-added">+             dataLogF(&quot;   bc: &quot;);</span>
          if (!profile.numberOfSamples() &amp;&amp; profile.m_prediction == SpecNone) {
              dataLogF(&quot;&lt;empty&gt;\n&quot;);
              continue;
          }
          profile.dump(WTF::dataFile());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2809,21 +2884,21 @@</span>
  #endif // ENABLE(VERBOSE_VALUE_PROFILE)
  
  unsigned CodeBlock::frameRegisterCount()
  {
      switch (jitType()) {
<span class="udiff-line-modified-removed">-     case JITCode::InterpreterThunk:</span>
<span class="udiff-line-modified-added">+     case JITType::InterpreterThunk:</span>
          return LLInt::frameRegisterCountFor(this);
  
  #if ENABLE(JIT)
<span class="udiff-line-modified-removed">-     case JITCode::BaselineJIT:</span>
<span class="udiff-line-modified-added">+     case JITType::BaselineJIT:</span>
          return JIT::frameRegisterCountFor(this);
  #endif // ENABLE(JIT)
  
  #if ENABLE(DFG_JIT)
<span class="udiff-line-modified-removed">-     case JITCode::DFGJIT:</span>
<span class="udiff-line-modified-removed">-     case JITCode::FTLJIT:</span>
<span class="udiff-line-modified-added">+     case JITType::DFGJIT:</span>
<span class="udiff-line-modified-added">+     case JITType::FTLJIT:</span>
          return jitCode()-&gt;dfgCommon()-&gt;frameRegisterCount;
  #endif // ENABLE(DFG_JIT)
  
      default:
          RELEASE_ASSERT_NOT_REACHED();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2855,11 +2930,11 @@</span>
      // Be paranoid: silently reject bogus multipiers. Silently doing the &quot;wrong&quot; thing
      // here is OK, since this whole method is just a heuristic.
      if (multiplier &lt; 0 || multiplier &gt; 1000)
          return 0;
  
<span class="udiff-line-modified-removed">-     double doubleResult = multiplier * instructionCount();</span>
<span class="udiff-line-modified-added">+     double doubleResult = multiplier * bytecodeCost();</span>
  
      // Be even more paranoid: silently reject values that won&#39;t fit into a size_t. If
      // the function is so huge that we can&#39;t even fit it into virtual memory then we
      // should probably have some other guards in place to prevent us from even getting
      // to this point.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2872,11 +2947,11 @@</span>
  String CodeBlock::nameForRegister(VirtualRegister virtualRegister)
  {
      for (auto&amp; constantRegister : m_constantRegisters) {
          if (constantRegister.get().isEmpty())
              continue;
<span class="udiff-line-modified-removed">-         if (SymbolTable* symbolTable = jsDynamicCast&lt;SymbolTable*&gt;(*vm(), constantRegister.get())) {</span>
<span class="udiff-line-modified-added">+         if (SymbolTable* symbolTable = jsDynamicCast&lt;SymbolTable*&gt;(vm(), constantRegister.get())) {</span>
              ConcurrentJSLocker locker(symbolTable-&gt;m_lock);
              auto end = symbolTable-&gt;end(locker);
              for (auto ptr = symbolTable-&gt;begin(locker); ptr != end; ++ptr) {
                  if (ptr-&gt;value.varOffset() == VarOffset(virtualRegister)) {
                      // FIXME: This won&#39;t work from the compilation thread.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3098,15 +3173,15 @@</span>
          // k: op_profile_control_flow (we want to skip over the j-&gt;k block and start fresh at offset k as the start of a new basic block k-&gt;m).
          // ...
          // m: op_profile_control_flow
          if (basicBlockEndOffset &lt; basicBlockStartOffset) {
              RELEASE_ASSERT(i + 1 &lt; offsetsLength); // We should never encounter dummy blocks at the end of a CodeBlock.
<span class="udiff-line-modified-removed">-             metadata.m_basicBlockLocation = vm()-&gt;controlFlowProfiler()-&gt;dummyBasicBlock();</span>
<span class="udiff-line-modified-added">+             metadata.m_basicBlockLocation = vm().controlFlowProfiler()-&gt;dummyBasicBlock();</span>
              continue;
          }
  
<span class="udiff-line-modified-removed">-         BasicBlockLocation* basicBlockLocation = vm()-&gt;controlFlowProfiler()-&gt;getBasicBlockLocation(ownerExecutable()-&gt;sourceID(), basicBlockStartOffset, basicBlockEndOffset);</span>
<span class="udiff-line-modified-added">+         BasicBlockLocation* basicBlockLocation = vm().controlFlowProfiler()-&gt;getBasicBlockLocation(ownerExecutable()-&gt;sourceID(), basicBlockStartOffset, basicBlockEndOffset);</span>
  
          // Find all functions that are enclosed within the range: [basicBlockStartOffset, basicBlockEndOffset]
          // and insert these functions&#39; start/end offsets as gaps in the current BasicBlockLocation.
          // This is necessary because in the original source text of a JavaScript program,
          // function literals form new basic blocks boundaries, but they aren&#39;t represented
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3160,23 +3235,23 @@</span>
  #endif // ENABLE(JIT)
  
  Optional&lt;unsigned&gt; CodeBlock::bytecodeOffsetFromCallSiteIndex(CallSiteIndex callSiteIndex)
  {
      Optional&lt;unsigned&gt; bytecodeOffset;
<span class="udiff-line-modified-removed">-     JITCode::JITType jitType = this-&gt;jitType();</span>
<span class="udiff-line-modified-removed">-     if (jitType == JITCode::InterpreterThunk || jitType == JITCode::BaselineJIT) {</span>
<span class="udiff-line-modified-added">+     JITType jitType = this-&gt;jitType();</span>
<span class="udiff-line-modified-added">+     if (jitType == JITType::InterpreterThunk || jitType == JITType::BaselineJIT) {</span>
  #if USE(JSVALUE64)
          bytecodeOffset = callSiteIndex.bits();
  #else
          Instruction* instruction = bitwise_cast&lt;Instruction*&gt;(callSiteIndex.bits());
          bytecodeOffset = this-&gt;bytecodeOffset(instruction);
  #endif
<span class="udiff-line-modified-removed">-     } else if (jitType == JITCode::DFGJIT || jitType == JITCode::FTLJIT) {</span>
<span class="udiff-line-modified-added">+     } else if (jitType == JITType::DFGJIT || jitType == JITType::FTLJIT) {</span>
  #if ENABLE(DFG_JIT)
          RELEASE_ASSERT(canGetCodeOrigin(callSiteIndex));
          CodeOrigin origin = codeOrigin(callSiteIndex);
<span class="udiff-line-modified-removed">-         bytecodeOffset = origin.bytecodeIndex;</span>
<span class="udiff-line-modified-added">+         bytecodeOffset = origin.bytecodeIndex();</span>
  #else
          RELEASE_ASSERT_NOT_REACHED();
  #endif
      }
  
</pre>
<center><a href="CallVariant.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CodeBlock.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>