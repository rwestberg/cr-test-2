<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/JavaScriptCore/b3/B3Value.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="B3Value.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="B3ValueInlines.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/b3/B3Value.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -36,11 +36,11 @@</span>
  #include &quot;B3Type.h&quot;
  #include &quot;B3ValueKey.h&quot;
  #include &quot;B3Width.h&quot;
  #include &lt;wtf/CommaPrinter.h&gt;
  #include &lt;wtf/FastMalloc.h&gt;
<span class="udiff-line-modified-removed">- #include &lt;wtf/Noncopyable.h&gt;</span>
<span class="udiff-line-modified-added">+ #include &lt;wtf/IteratorRange.h&gt;</span>
  #include &lt;wtf/StdLibExtras.h&gt;
  #include &lt;wtf/TriState.h&gt;
  
  namespace JSC { namespace B3 {
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -51,12 +51,10 @@</span>
  class Procedure;
  
  class JS_EXPORT_PRIVATE Value {
      WTF_MAKE_FAST_ALLOCATED;
  public:
<span class="udiff-line-removed">-     typedef Vector&lt;Value*, 3&gt; AdjacencyList;</span>
<span class="udiff-line-removed">- </span>
      static const char* const dumpPrefix;
  
      static bool accepts(Kind) { return true; }
  
      virtual ~Value();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -80,27 +78,68 @@</span>
      bool traps() const { return kind().traps(); }
  
      Origin origin() const { return m_origin; }
      void setOrigin(Origin origin) { m_origin = origin; }
  
<span class="udiff-line-removed">-     Value*&amp; child(unsigned index) { return m_children[index]; }</span>
<span class="udiff-line-removed">-     Value* child(unsigned index) const { return m_children[index]; }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     Value*&amp; lastChild() { return m_children.last(); }</span>
<span class="udiff-line-removed">-     Value* lastChild() const { return m_children.last(); }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     unsigned numChildren() const { return m_children.size(); }</span>
<span class="udiff-line-removed">- </span>
      Type type() const { return m_type; }
      void setType(Type type) { m_type = type; }
  
      // This is useful when lowering. Note that this is only valid for non-void values.
      Bank resultBank() const { return bankForType(type()); }
      Width resultWidth() const { return widthForType(type()); }
  
<span class="udiff-line-modified-removed">-     AdjacencyList&amp; children() { return m_children; }</span>
<span class="udiff-line-modified-removed">-     const AdjacencyList&amp; children() const { return m_children; }</span>
<span class="udiff-line-modified-added">+     unsigned numChildren() const</span>
<span class="udiff-line-modified-added">+     {</span>
<span class="udiff-line-added">+         if (m_numChildren == VarArgs)</span>
<span class="udiff-line-added">+             return childrenVector().size();</span>
<span class="udiff-line-added">+         return m_numChildren;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     Value*&amp; child(unsigned index)</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+         ASSERT(index &lt; numChildren());</span>
<span class="udiff-line-added">+         return m_numChildren == VarArgs ? childrenVector()[index] : childrenArray()[index];</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     Value* child(unsigned index) const</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+         ASSERT(index &lt; numChildren());</span>
<span class="udiff-line-added">+         return m_numChildren == VarArgs ? childrenVector()[index] : childrenArray()[index];</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     Value*&amp; lastChild()</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+         if (m_numChildren == VarArgs)</span>
<span class="udiff-line-added">+             return childrenVector().last();</span>
<span class="udiff-line-added">+         ASSERT(m_numChildren &gt;= 1);</span>
<span class="udiff-line-added">+         return childrenArray()[m_numChildren - 1];</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     Value* lastChild() const</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+         if (m_numChildren == VarArgs)</span>
<span class="udiff-line-added">+             return childrenVector().last();</span>
<span class="udiff-line-added">+         ASSERT(m_numChildren &gt;= 1);</span>
<span class="udiff-line-added">+         return childrenArray()[m_numChildren - 1];</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     WTF::IteratorRange&lt;Value**&gt; children()</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+         if (m_numChildren == VarArgs) {</span>
<span class="udiff-line-added">+             Vector&lt;Value*, 3&gt;&amp; vec = childrenVector();</span>
<span class="udiff-line-added">+             return WTF::makeIteratorRange(&amp;*vec.begin(), &amp;*vec.end());</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         Value** buffer = childrenArray();</span>
<span class="udiff-line-added">+         return {buffer, buffer + m_numChildren };</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     WTF::IteratorRange&lt;Value* const*&gt; children() const</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+         if (m_numChildren == VarArgs) {</span>
<span class="udiff-line-added">+             const Vector&lt;Value*, 3&gt;&amp; vec = childrenVector();</span>
<span class="udiff-line-added">+             return WTF::makeIteratorRange(&amp;*vec.begin(), &amp;*vec.end());</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         Value* const* buffer = childrenArray();</span>
<span class="udiff-line-added">+         return {buffer, buffer + m_numChildren };</span>
<span class="udiff-line-added">+     }</span>
  
      // If you want to replace all uses of this value with a different value, then replace this
      // value with Identity. Then do a pass of performSubstitution() on all of the values that use
      // this one. Usually we do all of this in one pass in pre-order, which ensures that the
      // X-&gt;replaceWithIdentity() calls happen before the performSubstitution() calls on X&#39;s users.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -293,44 +332,246 @@</span>
      // OffsetType isn&#39;t sufficient to determine offset validity! Each Value opcode further has an
      // isLegalOffset runtime method used to determine value legality at runtime. This is exposed to users
      // of B3 to force them to reason about the target&#39;s offset.
      typedef int32_t OffsetType;
      template&lt;typename Int&gt;
<span class="udiff-line-modified-removed">-     struct IsLegalOffset : std::conjunction&lt;</span>
<span class="udiff-line-modified-removed">-         typename std::enable_if&lt;std::is_integral&lt;Int&gt;::value&gt;::type,</span>
<span class="udiff-line-modified-removed">-         typename std::enable_if&lt;std::is_signed&lt;Int&gt;::value&gt;::type,</span>
<span class="udiff-line-modified-removed">-         typename std::enable_if&lt;sizeof(Int) &lt;= sizeof(OffsetType)&gt;::type</span>
<span class="udiff-line-modified-removed">-     &gt; { };</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-modified-added">+     struct IsLegalOffset {</span>
<span class="udiff-line-modified-added">+         static constexpr bool value = std::is_integral&lt;Int&gt;::value</span>
<span class="udiff-line-modified-added">+             &amp;&amp; std::is_signed&lt;Int&gt;::value</span>
<span class="udiff-line-modified-added">+             &amp;&amp; sizeof(Int) &lt;= sizeof(OffsetType);</span>
<span class="udiff-line-modified-added">+     };</span>
  
  protected:
<span class="udiff-line-modified-removed">-     virtual Value* cloneImpl() const;</span>
<span class="udiff-line-modified-added">+     Value* cloneImpl() const;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     void replaceWith(Kind, Type, BasicBlock*);</span>
<span class="udiff-line-added">+     void replaceWith(Kind, Type, BasicBlock*, Value*);</span>
  
      virtual void dumpChildren(CommaPrinter&amp;, PrintStream&amp;) const;
      virtual void dumpMeta(CommaPrinter&amp;, PrintStream&amp;) const;
  
<span class="udiff-line-added">+     // The specific value of VarArgs does not matter, but the value of the others is assumed to match their meaning.</span>
<span class="udiff-line-added">+     enum NumChildren : uint8_t { Zero = 0, One = 1, Two = 2, Three = 3, VarArgs = 4};</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     char* childrenAlloc() { return bitwise_cast&lt;char*&gt;(this) + adjacencyListOffset(); }</span>
<span class="udiff-line-added">+     const char* childrenAlloc() const { return bitwise_cast&lt;const char*&gt;(this) + adjacencyListOffset(); }</span>
<span class="udiff-line-added">+     Vector&lt;Value*, 3&gt;&amp; childrenVector()</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+         ASSERT(m_numChildren == VarArgs);</span>
<span class="udiff-line-added">+         return *bitwise_cast&lt;Vector&lt;Value*, 3&gt;*&gt;(childrenAlloc());</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     const Vector&lt;Value*, 3&gt;&amp; childrenVector() const</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+         ASSERT(m_numChildren == VarArgs);</span>
<span class="udiff-line-added">+         return *bitwise_cast&lt;Vector&lt;Value*, 3&gt; const*&gt;(childrenAlloc());</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     Value** childrenArray()</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+         ASSERT(m_numChildren != VarArgs);</span>
<span class="udiff-line-added">+         return bitwise_cast&lt;Value**&gt;(childrenAlloc());</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     Value* const* childrenArray() const</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+         ASSERT(m_numChildren != VarArgs);</span>
<span class="udiff-line-added">+         return bitwise_cast&lt;Value* const*&gt;(childrenAlloc());</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     template&lt;typename... Arguments&gt;</span>
<span class="udiff-line-added">+     static Opcode opcodeFromConstructor(Kind kind, Arguments...) { return kind.opcode(); }</span>
<span class="udiff-line-added">+     ALWAYS_INLINE static size_t adjacencyListSpace(Kind kind)</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+         switch (kind.opcode()) {</span>
<span class="udiff-line-added">+         case FramePointer:</span>
<span class="udiff-line-added">+         case Nop:</span>
<span class="udiff-line-added">+         case Phi:</span>
<span class="udiff-line-added">+         case Jump:</span>
<span class="udiff-line-added">+         case Oops:</span>
<span class="udiff-line-added">+         case EntrySwitch:</span>
<span class="udiff-line-added">+         case ArgumentReg:</span>
<span class="udiff-line-added">+         case Const32:</span>
<span class="udiff-line-added">+         case Const64:</span>
<span class="udiff-line-added">+         case ConstFloat:</span>
<span class="udiff-line-added">+         case ConstDouble:</span>
<span class="udiff-line-added">+         case Fence:</span>
<span class="udiff-line-added">+         case SlotBase:</span>
<span class="udiff-line-added">+         case Get:</span>
<span class="udiff-line-added">+             return 0;</span>
<span class="udiff-line-added">+         case Return:</span>
<span class="udiff-line-added">+         case Identity:</span>
<span class="udiff-line-added">+         case Opaque:</span>
<span class="udiff-line-added">+         case Neg:</span>
<span class="udiff-line-added">+         case Clz:</span>
<span class="udiff-line-added">+         case Abs:</span>
<span class="udiff-line-added">+         case Ceil:</span>
<span class="udiff-line-added">+         case Floor:</span>
<span class="udiff-line-added">+         case Sqrt:</span>
<span class="udiff-line-added">+         case SExt8:</span>
<span class="udiff-line-added">+         case SExt16:</span>
<span class="udiff-line-added">+         case Trunc:</span>
<span class="udiff-line-added">+         case SExt32:</span>
<span class="udiff-line-added">+         case ZExt32:</span>
<span class="udiff-line-added">+         case FloatToDouble:</span>
<span class="udiff-line-added">+         case IToD:</span>
<span class="udiff-line-added">+         case DoubleToFloat:</span>
<span class="udiff-line-added">+         case IToF:</span>
<span class="udiff-line-added">+         case BitwiseCast:</span>
<span class="udiff-line-added">+         case Branch:</span>
<span class="udiff-line-added">+         case Depend:</span>
<span class="udiff-line-added">+         case Load8Z:</span>
<span class="udiff-line-added">+         case Load8S:</span>
<span class="udiff-line-added">+         case Load16Z:</span>
<span class="udiff-line-added">+         case Load16S:</span>
<span class="udiff-line-added">+         case Load:</span>
<span class="udiff-line-added">+         case Switch:</span>
<span class="udiff-line-added">+         case Upsilon:</span>
<span class="udiff-line-added">+         case Extract:</span>
<span class="udiff-line-added">+         case Set:</span>
<span class="udiff-line-added">+         case WasmAddress:</span>
<span class="udiff-line-added">+         case WasmBoundsCheck:</span>
<span class="udiff-line-added">+             return sizeof(Value*);</span>
<span class="udiff-line-added">+         case Add:</span>
<span class="udiff-line-added">+         case Sub:</span>
<span class="udiff-line-added">+         case Mul:</span>
<span class="udiff-line-added">+         case Div:</span>
<span class="udiff-line-added">+         case UDiv:</span>
<span class="udiff-line-added">+         case Mod:</span>
<span class="udiff-line-added">+         case UMod:</span>
<span class="udiff-line-added">+         case BitAnd:</span>
<span class="udiff-line-added">+         case BitOr:</span>
<span class="udiff-line-added">+         case BitXor:</span>
<span class="udiff-line-added">+         case Shl:</span>
<span class="udiff-line-added">+         case SShr:</span>
<span class="udiff-line-added">+         case ZShr:</span>
<span class="udiff-line-added">+         case RotR:</span>
<span class="udiff-line-added">+         case RotL:</span>
<span class="udiff-line-added">+         case Equal:</span>
<span class="udiff-line-added">+         case NotEqual:</span>
<span class="udiff-line-added">+         case LessThan:</span>
<span class="udiff-line-added">+         case GreaterThan:</span>
<span class="udiff-line-added">+         case LessEqual:</span>
<span class="udiff-line-added">+         case GreaterEqual:</span>
<span class="udiff-line-added">+         case Above:</span>
<span class="udiff-line-added">+         case Below:</span>
<span class="udiff-line-added">+         case AboveEqual:</span>
<span class="udiff-line-added">+         case BelowEqual:</span>
<span class="udiff-line-added">+         case EqualOrUnordered:</span>
<span class="udiff-line-added">+         case AtomicXchgAdd:</span>
<span class="udiff-line-added">+         case AtomicXchgAnd:</span>
<span class="udiff-line-added">+         case AtomicXchgOr:</span>
<span class="udiff-line-added">+         case AtomicXchgSub:</span>
<span class="udiff-line-added">+         case AtomicXchgXor:</span>
<span class="udiff-line-added">+         case AtomicXchg:</span>
<span class="udiff-line-added">+         case Store8:</span>
<span class="udiff-line-added">+         case Store16:</span>
<span class="udiff-line-added">+         case Store:</span>
<span class="udiff-line-added">+             return 2 * sizeof(Value*);</span>
<span class="udiff-line-added">+         case Select:</span>
<span class="udiff-line-added">+         case AtomicWeakCAS:</span>
<span class="udiff-line-added">+         case AtomicStrongCAS:</span>
<span class="udiff-line-added">+             return 3 * sizeof(Value*);</span>
<span class="udiff-line-added">+         case CCall:</span>
<span class="udiff-line-added">+         case Check:</span>
<span class="udiff-line-added">+         case CheckAdd:</span>
<span class="udiff-line-added">+         case CheckSub:</span>
<span class="udiff-line-added">+         case CheckMul:</span>
<span class="udiff-line-added">+         case Patchpoint:</span>
<span class="udiff-line-added">+             return sizeof(Vector&lt;Value*, 3&gt;);</span>
<span class="udiff-line-added">+ #ifdef NDEBUG</span>
<span class="udiff-line-added">+         default:</span>
<span class="udiff-line-added">+             break;</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         RELEASE_ASSERT_NOT_REACHED();</span>
<span class="udiff-line-added">+         return 0;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
  private:
<span class="udiff-line-added">+     static char* allocateSpace(Opcode opcode, size_t size)</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+         size_t adjacencyListSpace = Value::adjacencyListSpace(opcode);</span>
<span class="udiff-line-added">+         // We must allocate enough space that replaceWithIdentity can work without buffer overflow.</span>
<span class="udiff-line-added">+         size_t allocIdentitySize = sizeof(Value) + sizeof(Value*);</span>
<span class="udiff-line-added">+         size_t allocSize = std::max(size + adjacencyListSpace, allocIdentitySize);</span>
<span class="udiff-line-added">+         return static_cast&lt;char*&gt;(WTF::fastMalloc(allocSize));</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ protected:</span>
<span class="udiff-line-added">+     template&lt;typename ValueType, typename... Arguments&gt;</span>
<span class="udiff-line-added">+     static ValueType* allocate(Arguments... arguments)</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+         char* alloc = allocateSpace(ValueType::opcodeFromConstructor(arguments...), sizeof(ValueType));</span>
<span class="udiff-line-added">+         return new (alloc) ValueType(arguments...);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     template&lt;typename ValueType&gt;</span>
<span class="udiff-line-added">+     static ValueType* allocate(const ValueType&amp; valueToClone)</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+         char* alloc = allocateSpace(valueToClone.opcode(), sizeof(ValueType));</span>
<span class="udiff-line-added">+         ValueType* result = new (alloc) ValueType(valueToClone);</span>
<span class="udiff-line-added">+         result-&gt;buildAdjacencyList(sizeof(ValueType), valueToClone);</span>
<span class="udiff-line-added">+         return result;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // Protected so it will only be called from allocate above, possibly through the subclasses&#39;copy constructors</span>
<span class="udiff-line-added">+     Value(const Value&amp;) = default;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     Value(Value&amp;&amp;) = delete;</span>
<span class="udiff-line-added">+     Value&amp; operator=(const Value&amp;) = delete;</span>
<span class="udiff-line-added">+     Value&amp; operator=(Value&amp;&amp;) = delete;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     size_t adjacencyListOffset() const;</span>
<span class="udiff-line-added">+ </span>
      friend class Procedure;
      friend class SparseCollection&lt;Value&gt;;
  
<span class="udiff-line-added">+ private:</span>
<span class="udiff-line-added">+     template&lt;typename... Arguments&gt;</span>
<span class="udiff-line-added">+     void buildAdjacencyList(NumChildren numChildren, Arguments... arguments)</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+         if (numChildren == VarArgs) {</span>
<span class="udiff-line-added">+             new (childrenAlloc()) Vector&lt;Value*, 3&gt; { arguments... };</span>
<span class="udiff-line-added">+             return;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         ASSERT(numChildren == sizeof...(arguments));</span>
<span class="udiff-line-added">+         new (childrenAlloc()) Value*[sizeof...(arguments)] { arguments... };</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     void buildAdjacencyList(size_t offset, const Value&amp; valueToClone)</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+         switch (valueToClone.m_numChildren) {</span>
<span class="udiff-line-added">+         case VarArgs:</span>
<span class="udiff-line-added">+             new (bitwise_cast&lt;char*&gt;(this) + offset) Vector&lt;Value*, 3&gt; (valueToClone.childrenVector());</span>
<span class="udiff-line-added">+             break;</span>
<span class="udiff-line-added">+         case Three:</span>
<span class="udiff-line-added">+             bitwise_cast&lt;Value**&gt;(bitwise_cast&lt;char*&gt;(this) + offset)[2] = valueToClone.childrenArray()[2];</span>
<span class="udiff-line-added">+             FALLTHROUGH;</span>
<span class="udiff-line-added">+         case Two:</span>
<span class="udiff-line-added">+             bitwise_cast&lt;Value**&gt;(bitwise_cast&lt;char*&gt;(this) + offset)[1] = valueToClone.childrenArray()[1];</span>
<span class="udiff-line-added">+             FALLTHROUGH;</span>
<span class="udiff-line-added">+         case One:</span>
<span class="udiff-line-added">+             bitwise_cast&lt;Value**&gt;(bitwise_cast&lt;char*&gt;(this) + offset)[0] = valueToClone.childrenArray()[0];</span>
<span class="udiff-line-added">+             break;</span>
<span class="udiff-line-added">+         case Zero:</span>
<span class="udiff-line-added">+             break;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      // Checks that this kind is valid for use with B3::Value.
<span class="udiff-line-modified-removed">-     ALWAYS_INLINE static void checkKind(Kind kind, unsigned numArgs)</span>
<span class="udiff-line-modified-added">+     ALWAYS_INLINE static NumChildren numChildrenForKind(Kind kind, unsigned numArgs)</span>
      {
          switch (kind.opcode()) {
          case FramePointer:
          case Nop:
          case Phi:
          case Jump:
          case Oops:
          case EntrySwitch:
              if (UNLIKELY(numArgs))
                  badKind(kind, numArgs);
<span class="udiff-line-modified-removed">-             break;</span>
<span class="udiff-line-modified-added">+             return Zero;</span>
          case Return:
              if (UNLIKELY(numArgs &gt; 1))
                  badKind(kind, numArgs);
<span class="udiff-line-modified-removed">-             break;</span>
<span class="udiff-line-modified-added">+             return numArgs ? One : Zero;</span>
          case Identity:
          case Opaque:
          case Neg:
          case Clz:
          case Abs:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -349,11 +590,11 @@</span>
          case BitwiseCast:
          case Branch:
          case Depend:
              if (UNLIKELY(numArgs != 1))
                  badKind(kind, numArgs);
<span class="udiff-line-modified-removed">-             break;</span>
<span class="udiff-line-modified-added">+             return One;</span>
          case Add:
          case Sub:
          case Mul:
          case Div:
          case UDiv:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -378,133 +619,109 @@</span>
          case AboveEqual:
          case BelowEqual:
          case EqualOrUnordered:
              if (UNLIKELY(numArgs != 2))
                  badKind(kind, numArgs);
<span class="udiff-line-modified-removed">-             break;</span>
<span class="udiff-line-modified-added">+             return Two;</span>
          case Select:
              if (UNLIKELY(numArgs != 3))
                  badKind(kind, numArgs);
<span class="udiff-line-modified-removed">-             break;</span>
<span class="udiff-line-modified-added">+             return Three;</span>
          default:
              badKind(kind, numArgs);
              break;
          }
<span class="udiff-line-added">+         return VarArgs;</span>
      }
  
  protected:
      enum CheckedOpcodeTag { CheckedOpcode };
  
<span class="udiff-line-removed">-     Value(const Value&amp;) = default;</span>
<span class="udiff-line-removed">-     Value&amp; operator=(const Value&amp;) = default;</span>
<span class="udiff-line-removed">- </span>
      // Instantiate values via Procedure.
      // This form requires specifying the type explicitly:
      template&lt;typename... Arguments&gt;
<span class="udiff-line-modified-removed">-     explicit Value(CheckedOpcodeTag, Kind kind, Type type, Origin origin, Value* firstChild, Arguments... arguments)</span>
<span class="udiff-line-modified-added">+     explicit Value(CheckedOpcodeTag, Kind kind, Type type, NumChildren numChildren, Origin origin, Value* firstChild, Arguments... arguments)</span>
          : m_kind(kind)
          , m_type(type)
<span class="udiff-line-added">+         , m_numChildren(numChildren)</span>
          , m_origin(origin)
<span class="udiff-line-removed">-         , m_children{ firstChild, arguments... }</span>
      {
<span class="udiff-line-added">+         buildAdjacencyList(numChildren, firstChild, arguments...);</span>
      }
      // This form is for specifying the type explicitly when the opcode has no children:
<span class="udiff-line-modified-removed">-     explicit Value(CheckedOpcodeTag, Kind kind, Type type, Origin origin)</span>
<span class="udiff-line-modified-added">+     explicit Value(CheckedOpcodeTag, Kind kind, Type type, NumChildren numChildren, Origin origin)</span>
          : m_kind(kind)
          , m_type(type)
<span class="udiff-line-added">+         , m_numChildren(numChildren)</span>
          , m_origin(origin)
      {
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-removed">-     // This form is for those opcodes that can infer their type from the opcode and first child:</span>
<span class="udiff-line-removed">-     template&lt;typename... Arguments&gt;</span>
<span class="udiff-line-removed">-     explicit Value(CheckedOpcodeTag, Kind kind, Origin origin, Value* firstChild)</span>
<span class="udiff-line-removed">-         : m_kind(kind)</span>
<span class="udiff-line-removed">-         , m_type(typeFor(kind, firstChild))</span>
<span class="udiff-line-removed">-         , m_origin(origin)</span>
<span class="udiff-line-removed">-         , m_children{ firstChild }</span>
<span class="udiff-line-removed">-     {</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     // This form is for those opcodes that can infer their type from the opcode and first and second child:</span>
<span class="udiff-line-removed">-     template&lt;typename... Arguments&gt;</span>
<span class="udiff-line-removed">-     explicit Value(CheckedOpcodeTag, Kind kind, Origin origin, Value* firstChild, Value* secondChild, Arguments... arguments)</span>
<span class="udiff-line-removed">-         : m_kind(kind)</span>
<span class="udiff-line-removed">-         , m_type(typeFor(kind, firstChild, secondChild))</span>
<span class="udiff-line-removed">-         , m_origin(origin)</span>
<span class="udiff-line-removed">-         , m_children{ firstChild, secondChild, arguments... }</span>
<span class="udiff-line-removed">-     {</span>
<span class="udiff-line-modified-added">+         buildAdjacencyList(numChildren);</span>
      }
      // This form is for those opcodes that can infer their type from the opcode alone, and that don&#39;t
      // take any arguments:
<span class="udiff-line-modified-removed">-     explicit Value(CheckedOpcodeTag, Kind kind, Origin origin)</span>
<span class="udiff-line-modified-added">+     explicit Value(CheckedOpcodeTag, Kind kind, NumChildren numChildren, Origin origin)</span>
          : m_kind(kind)
          , m_type(typeFor(kind, nullptr))
<span class="udiff-line-added">+         , m_numChildren(numChildren)</span>
          , m_origin(origin)
      {
<span class="udiff-line-added">+         buildAdjacencyList(numChildren);</span>
      }
<span class="udiff-line-modified-removed">-     // Use this form for varargs.</span>
<span class="udiff-line-modified-removed">-     explicit Value(CheckedOpcodeTag, Kind kind, Type type, Origin origin, const AdjacencyList&amp; children)</span>
<span class="udiff-line-modified-added">+     // This form is for those opcodes that can infer their type from the opcode and first child:</span>
<span class="udiff-line-modified-added">+     explicit Value(CheckedOpcodeTag, Kind kind, NumChildren numChildren, Origin origin, Value* firstChild)</span>
          : m_kind(kind)
<span class="udiff-line-modified-removed">-         , m_type(type)</span>
<span class="udiff-line-modified-added">+         , m_type(typeFor(kind, firstChild))</span>
<span class="udiff-line-added">+         , m_numChildren(numChildren)</span>
          , m_origin(origin)
<span class="udiff-line-removed">-         , m_children(children)</span>
      {
<span class="udiff-line-added">+         buildAdjacencyList(numChildren, firstChild);</span>
      }
<span class="udiff-line-modified-removed">-     explicit Value(CheckedOpcodeTag, Kind kind, Type type, Origin origin, AdjacencyList&amp;&amp; children)</span>
<span class="udiff-line-modified-added">+     // This form is for those opcodes that can infer their type from the opcode and first and second child:</span>
<span class="udiff-line-added">+     template&lt;typename... Arguments&gt;</span>
<span class="udiff-line-added">+     explicit Value(CheckedOpcodeTag, Kind kind, NumChildren numChildren, Origin origin, Value* firstChild, Value* secondChild, Arguments... arguments)</span>
          : m_kind(kind)
<span class="udiff-line-modified-removed">-         , m_type(type)</span>
<span class="udiff-line-modified-added">+         , m_type(typeFor(kind, firstChild, secondChild))</span>
<span class="udiff-line-added">+         , m_numChildren(numChildren)</span>
          , m_origin(origin)
<span class="udiff-line-removed">-         , m_children(WTFMove(children))</span>
      {
<span class="udiff-line-added">+         buildAdjacencyList(numChildren, firstChild, secondChild, arguments...);</span>
      }
  
      // This is the constructor you end up actually calling, if you&#39;re instantiating Value
      // directly.
<span class="udiff-line-modified-removed">-     template&lt;typename... Arguments&gt;</span>
<span class="udiff-line-modified-removed">-         explicit Value(Kind kind, Type type, Origin origin)</span>
<span class="udiff-line-removed">-         : Value(CheckedOpcode, kind, type, origin)</span>
<span class="udiff-line-removed">-     {</span>
<span class="udiff-line-removed">-         checkKind(kind, 0);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     template&lt;typename... Arguments&gt;</span>
<span class="udiff-line-removed">-         explicit Value(Kind kind, Type type, Origin origin, Value* firstChild, Arguments&amp;&amp;... arguments)</span>
<span class="udiff-line-removed">-         : Value(CheckedOpcode, kind, type, origin, firstChild, std::forward&lt;Arguments&gt;(arguments)...)</span>
<span class="udiff-line-removed">-     {</span>
<span class="udiff-line-removed">-         checkKind(kind, 1 + sizeof...(arguments));</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     template&lt;typename... Arguments&gt;</span>
<span class="udiff-line-removed">-         explicit Value(Kind kind, Type type, Origin origin, const AdjacencyList&amp; children)</span>
<span class="udiff-line-removed">-         : Value(CheckedOpcode, kind, type, origin, children)</span>
<span class="udiff-line-modified-added">+     explicit Value(Kind kind, Type type, Origin origin)</span>
<span class="udiff-line-modified-added">+         : Value(CheckedOpcode, kind, type, Zero, origin)</span>
      {
<span class="udiff-line-modified-removed">-         checkKind(kind, children.size());</span>
<span class="udiff-line-modified-added">+         RELEASE_ASSERT(numChildrenForKind(kind, 0) == Zero);</span>
      }
<span class="udiff-line-added">+     // We explicitly convert the extra arguments to Value* (they may be pointers to some subclasses of Value) to limit template explosion</span>
      template&lt;typename... Arguments&gt;
<span class="udiff-line-modified-removed">-         explicit Value(Kind kind, Type type, Origin origin, AdjacencyList&amp;&amp; children)</span>
<span class="udiff-line-modified-removed">-         : Value(CheckedOpcode, kind, type, origin, WTFMove(children))</span>
<span class="udiff-line-modified-added">+     explicit Value(Kind kind, Origin origin, Arguments... arguments)</span>
<span class="udiff-line-modified-added">+         : Value(CheckedOpcode, kind, numChildrenForKind(kind, sizeof...(arguments)), origin, static_cast&lt;Value*&gt;(arguments)...)</span>
      {
<span class="udiff-line-removed">-         checkKind(kind, m_children.size());</span>
      }
      template&lt;typename... Arguments&gt;
<span class="udiff-line-modified-removed">-         explicit Value(Kind kind, Origin origin, Arguments&amp;&amp;... arguments)</span>
<span class="udiff-line-modified-removed">-         : Value(CheckedOpcode, kind, origin, std::forward&lt;Arguments&gt;(arguments)...)</span>
<span class="udiff-line-modified-added">+     explicit Value(Kind kind, Type type, Origin origin, Value* firstChild, Arguments... arguments)</span>
<span class="udiff-line-modified-added">+         : Value(CheckedOpcode, kind, type, numChildrenForKind(kind, 1 + sizeof...(arguments)), origin, firstChild, static_cast&lt;Value*&gt;(arguments)...)</span>
      {
<span class="udiff-line-removed">-         checkKind(kind, sizeof...(arguments));</span>
      }
  
  private:
      friend class CheckValue; // CheckValue::convertToAdd() modifies m_kind.
  
      static Type typeFor(Kind, Value* firstChild, Value* secondChild = nullptr);
  
<span class="udiff-line-modified-removed">-     // This group of fields is arranged to fit in 64 bits.</span>
<span class="udiff-line-modified-added">+     // m_index to m_numChildren are arranged to fit in 64 bits.</span>
  protected:
      unsigned m_index { UINT_MAX };
  private:
      Kind m_kind;
      Type m_type;
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-added">+ protected:</span>
<span class="udiff-line-added">+     NumChildren m_numChildren;</span>
<span class="udiff-line-added">+ private:</span>
      Origin m_origin;
<span class="udiff-line-removed">-     AdjacencyList m_children;</span>
  
      NO_RETURN_DUE_TO_CRASH static void badKind(Kind, unsigned);
  
  public:
      BasicBlock* owner { nullptr }; // computed by Procedure::resetValueOwners().
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -516,17 +733,11 @@</span>
          : m_proc(proc)
          , m_value(value)
      {
      }
  
<span class="udiff-line-modified-removed">-     void dump(PrintStream&amp; out) const</span>
<span class="udiff-line-removed">-     {</span>
<span class="udiff-line-removed">-         if (m_value)</span>
<span class="udiff-line-removed">-             m_value-&gt;deepDump(m_proc, out);</span>
<span class="udiff-line-removed">-         else</span>
<span class="udiff-line-removed">-             out.print(&quot;&lt;null&gt;&quot;);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+     void dump(PrintStream&amp; out) const;</span>
  
  private:
      const Procedure* m_proc;
      const Value* m_value;
  };
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -538,8 +749,118 @@</span>
  inline DeepValueDump deepDump(const Value* value)
  {
      return DeepValueDump(nullptr, value);
  }
  
<span class="udiff-line-added">+ // The following macros are designed for subclasses of B3::Value to use.</span>
<span class="udiff-line-added">+ // They are never required for correctness, but can improve the performance of child/lastChild/numChildren/children methods,</span>
<span class="udiff-line-added">+ // for users that already know the specific subclass of Value they are manipulating.</span>
<span class="udiff-line-added">+ // The first set is to be used when you know something about the number of children of all values of a class, including its subclasses:</span>
<span class="udiff-line-added">+ // - B3_SPECIALIZE_VALUE_FOR_NO_CHILDREN: always 0 children (e.g. Const32Value)</span>
<span class="udiff-line-added">+ // - B3_SPECIALIZE_VALUE_FOR_FIXED_CHILDREN(n): always n children, with n in {1, 2, 3} (e.g. UpsilonValue, with n = 1)</span>
<span class="udiff-line-added">+ // - B3_SPECIALIZE_VALUE_FOR_NON_VARARGS_CHILDREN: different numbers of children, but never a variable number at runtime (e.g. MemoryValue, that can have between 1 and 3 children)</span>
<span class="udiff-line-added">+ // - B3_SPECIALIZE_VALUE_FOR_VARARGS_CHILDREN: always a varargs (e.g. CCallValue)</span>
<span class="udiff-line-added">+ // The second set is only to be used by classes that we know are not further subclassed by anyone adding fields,</span>
<span class="udiff-line-added">+ // as they hardcode the offset of the children array/vector (which is equal to the size of the object).</span>
<span class="udiff-line-added">+ // - B3_SPECIALIZE_VALUE_FOR_FINAL_SIZE_FIXED_CHILDREN</span>
<span class="udiff-line-added">+ // - B3_SPECIALIZE_VALUE_FOR_FINAL_SIZE_VARARGS_CHILDREN</span>
<span class="udiff-line-added">+ #define B3_SPECIALIZE_VALUE_FOR_NO_CHILDREN \</span>
<span class="udiff-line-added">+     unsigned numChildren() const { return 0; } \</span>
<span class="udiff-line-added">+     WTF::IteratorRange&lt;Value**&gt; children() { return {nullptr, nullptr}; } \</span>
<span class="udiff-line-added">+     WTF::IteratorRange&lt;Value* const*&gt; children() const { return { nullptr, nullptr}; }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #define B3_SPECIALIZE_VALUE_FOR_FIXED_CHILDREN(n) \</span>
<span class="udiff-line-added">+ public: \</span>
<span class="udiff-line-added">+     unsigned numChildren() const { return n; } \</span>
<span class="udiff-line-added">+     Value*&amp; child(unsigned index) \</span>
<span class="udiff-line-added">+     { \</span>
<span class="udiff-line-added">+         ASSERT(index &lt;= n); \</span>
<span class="udiff-line-added">+         return childrenArray()[index]; \</span>
<span class="udiff-line-added">+     } \</span>
<span class="udiff-line-added">+     Value* child(unsigned index) const \</span>
<span class="udiff-line-added">+     { \</span>
<span class="udiff-line-added">+         ASSERT(index &lt;= n); \</span>
<span class="udiff-line-added">+         return childrenArray()[index]; \</span>
<span class="udiff-line-added">+     } \</span>
<span class="udiff-line-added">+     Value*&amp; lastChild() \</span>
<span class="udiff-line-added">+     { \</span>
<span class="udiff-line-added">+         return childrenArray()[n - 1]; \</span>
<span class="udiff-line-added">+     } \</span>
<span class="udiff-line-added">+     Value* lastChild() const \</span>
<span class="udiff-line-added">+     { \</span>
<span class="udiff-line-added">+         return childrenArray()[n - 1]; \</span>
<span class="udiff-line-added">+     } \</span>
<span class="udiff-line-added">+     WTF::IteratorRange&lt;Value**&gt; children() \</span>
<span class="udiff-line-added">+     { \</span>
<span class="udiff-line-added">+         Value** buffer = childrenArray(); \</span>
<span class="udiff-line-added">+         return {buffer, buffer + n }; \</span>
<span class="udiff-line-added">+     } \</span>
<span class="udiff-line-added">+     WTF::IteratorRange&lt;Value* const*&gt; children() const \</span>
<span class="udiff-line-added">+     { \</span>
<span class="udiff-line-added">+         Value* const* buffer = childrenArray(); \</span>
<span class="udiff-line-added">+         return {buffer, buffer + n }; \</span>
<span class="udiff-line-added">+     } \</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #define B3_SPECIALIZE_VALUE_FOR_NON_VARARGS_CHILDREN \</span>
<span class="udiff-line-added">+ public: \</span>
<span class="udiff-line-added">+     unsigned numChildren() const { return m_numChildren; } \</span>
<span class="udiff-line-added">+     Value*&amp; child(unsigned index) { return childrenArray()[index]; } \</span>
<span class="udiff-line-added">+     Value* child(unsigned index) const { return childrenArray()[index]; } \</span>
<span class="udiff-line-added">+     Value*&amp; lastChild() { return childrenArray()[numChildren() - 1]; } \</span>
<span class="udiff-line-added">+     Value* lastChild() const { return childrenArray()[numChildren() - 1]; } \</span>
<span class="udiff-line-added">+     WTF::IteratorRange&lt;Value**&gt; children() \</span>
<span class="udiff-line-added">+     { \</span>
<span class="udiff-line-added">+         Value** buffer = childrenArray(); \</span>
<span class="udiff-line-added">+         return {buffer, buffer + numChildren() }; \</span>
<span class="udiff-line-added">+     } \</span>
<span class="udiff-line-added">+     WTF::IteratorRange&lt;Value* const*&gt; children() const \</span>
<span class="udiff-line-added">+     { \</span>
<span class="udiff-line-added">+         Value* const* buffer = childrenArray(); \</span>
<span class="udiff-line-added">+         return {buffer, buffer + numChildren() }; \</span>
<span class="udiff-line-added">+     } \</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #define B3_SPECIALIZE_VALUE_FOR_VARARGS_CHILDREN \</span>
<span class="udiff-line-added">+ public: \</span>
<span class="udiff-line-added">+     unsigned numChildren() const { return childrenVector().size(); } \</span>
<span class="udiff-line-added">+     Value*&amp; child(unsigned index) { return childrenVector()[index]; } \</span>
<span class="udiff-line-added">+     Value* child(unsigned index) const { return childrenVector()[index]; } \</span>
<span class="udiff-line-added">+     Value*&amp; lastChild() { return childrenVector().last(); } \</span>
<span class="udiff-line-added">+     Value* lastChild() const { return childrenVector().last(); } \</span>
<span class="udiff-line-added">+     WTF::IteratorRange&lt;Value**&gt; children() \</span>
<span class="udiff-line-added">+     { \</span>
<span class="udiff-line-added">+         Vector&lt;Value*, 3&gt;&amp; vec = childrenVector(); \</span>
<span class="udiff-line-added">+         return WTF::makeIteratorRange(&amp;*vec.begin(), &amp;*vec.end()); \</span>
<span class="udiff-line-added">+     } \</span>
<span class="udiff-line-added">+     WTF::IteratorRange&lt;Value* const*&gt; children() const \</span>
<span class="udiff-line-added">+     { \</span>
<span class="udiff-line-added">+         const Vector&lt;Value*, 3&gt;&amp; vec = childrenVector(); \</span>
<span class="udiff-line-added">+         return WTF::makeIteratorRange(&amp;*vec.begin(), &amp;*vec.end()); \</span>
<span class="udiff-line-added">+     } \</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // Only use this for classes with no subclass that add new fields (as it uses sizeof(*this))</span>
<span class="udiff-line-added">+ // Also there is no point in applying this to classes with no children, as they don&#39;t have a children array to access.</span>
<span class="udiff-line-added">+ #define B3_SPECIALIZE_VALUE_FOR_FINAL_SIZE_FIXED_CHILDREN \</span>
<span class="udiff-line-added">+ private: \</span>
<span class="udiff-line-added">+     Value** childrenArray() \</span>
<span class="udiff-line-added">+     { \</span>
<span class="udiff-line-added">+         return bitwise_cast&lt;Value**&gt;(bitwise_cast&lt;char*&gt;(this) + sizeof(*this)); \</span>
<span class="udiff-line-added">+     } \</span>
<span class="udiff-line-added">+     Value* const* childrenArray() const \</span>
<span class="udiff-line-added">+     { \</span>
<span class="udiff-line-added">+         return bitwise_cast&lt;Value* const*&gt;(bitwise_cast&lt;char const*&gt;(this) + sizeof(*this)); \</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // Only use this for classes with no subclass that add new fields (as it uses sizeof(*this))</span>
<span class="udiff-line-added">+ #define B3_SPECIALIZE_VALUE_FOR_FINAL_SIZE_VARARGS_CHILDREN \</span>
<span class="udiff-line-added">+ private: \</span>
<span class="udiff-line-added">+     Vector&lt;Value*, 3&gt;&amp; childrenVector() \</span>
<span class="udiff-line-added">+     { \</span>
<span class="udiff-line-added">+         return *bitwise_cast&lt;Vector&lt;Value*, 3&gt;*&gt;(bitwise_cast&lt;char*&gt;(this) + sizeof(*this)); \</span>
<span class="udiff-line-added">+     } \</span>
<span class="udiff-line-added">+     const Vector&lt;Value*, 3&gt;&amp; childrenVector() const \</span>
<span class="udiff-line-added">+     { \</span>
<span class="udiff-line-added">+         return *bitwise_cast&lt;Vector&lt;Value*, 3&gt; const*&gt;(bitwise_cast&lt;char const*&gt;(this) + sizeof(*this)); \</span>
<span class="udiff-line-added">+     } \</span>
<span class="udiff-line-added">+ </span>
  } } // namespace JSC::B3
  
  #endif // ENABLE(B3_JIT)
</pre>
<center><a href="B3Value.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="B3ValueInlines.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>