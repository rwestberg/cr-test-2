<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/WTF/wtf/dtoa/fixed-dtoa.cc</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="fast-dtoa.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="fixed-dtoa.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WTF/wtf/dtoa/fixed-dtoa.cc</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -32,195 +32,195 @@</span>
  #include &lt;wtf/dtoa/fixed-dtoa.h&gt;
  #include &lt;wtf/dtoa/ieee.h&gt;
  
  namespace WTF {
  namespace double_conversion {
<span class="udiff-line-modified-removed">-     </span>
<span class="udiff-line-modified-added">+ </span>
  // Represents a 128bit type. This class should be replaced by a native type on
  // platforms that support 128bit integers.
  class UInt128 {
<span class="udiff-line-modified-removed">-     public:</span>
<span class="udiff-line-modified-removed">-         UInt128() : high_bits_(0), low_bits_(0) { }</span>
<span class="udiff-line-modified-removed">-         UInt128(uint64_t high, uint64_t low) : high_bits_(high), low_bits_(low) { }</span>
<span class="udiff-line-modified-removed">-         </span>
<span class="udiff-line-modified-removed">-         void Multiply(uint32_t multiplicand) {</span>
<span class="udiff-line-modified-removed">-             uint64_t accumulator;</span>
<span class="udiff-line-modified-removed">-             </span>
<span class="udiff-line-modified-removed">-             accumulator = (low_bits_ &amp; kMask32) * multiplicand;</span>
<span class="udiff-line-modified-removed">-             uint32_t part = static_cast&lt;uint32_t&gt;(accumulator &amp; kMask32);</span>
<span class="udiff-line-modified-removed">-             accumulator &gt;&gt;= 32;</span>
<span class="udiff-line-modified-removed">-             accumulator = accumulator + (low_bits_ &gt;&gt; 32) * multiplicand;</span>
<span class="udiff-line-modified-removed">-             low_bits_ = (accumulator &lt;&lt; 32) + part;</span>
<span class="udiff-line-modified-removed">-             accumulator &gt;&gt;= 32;</span>
<span class="udiff-line-modified-removed">-             accumulator = accumulator + (high_bits_ &amp; kMask32) * multiplicand;</span>
<span class="udiff-line-modified-removed">-             part = static_cast&lt;uint32_t&gt;(accumulator &amp; kMask32);</span>
<span class="udiff-line-modified-removed">-             accumulator &gt;&gt;= 32;</span>
<span class="udiff-line-modified-removed">-             accumulator = accumulator + (high_bits_ &gt;&gt; 32) * multiplicand;</span>
<span class="udiff-line-modified-removed">-             high_bits_ = (accumulator &lt;&lt; 32) + part;</span>
<span class="udiff-line-modified-removed">-             ASSERT((accumulator &gt;&gt; 32) == 0);</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-removed">-         </span>
<span class="udiff-line-modified-removed">-         void Shift(int shift_amount) {</span>
<span class="udiff-line-modified-removed">-             ASSERT(-64 &lt;= shift_amount &amp;&amp; shift_amount &lt;= 64);</span>
<span class="udiff-line-modified-removed">-             if (shift_amount == 0) {</span>
<span class="udiff-line-modified-removed">-                 return;</span>
<span class="udiff-line-modified-removed">-             } else if (shift_amount == -64) {</span>
<span class="udiff-line-modified-removed">-                 high_bits_ = low_bits_;</span>
<span class="udiff-line-modified-removed">-                 low_bits_ = 0;</span>
<span class="udiff-line-modified-removed">-             } else if (shift_amount == 64) {</span>
<span class="udiff-line-modified-removed">-                 low_bits_ = high_bits_;</span>
<span class="udiff-line-modified-removed">-                 high_bits_ = 0;</span>
<span class="udiff-line-modified-removed">-             } else if (shift_amount &lt;= 0) {</span>
<span class="udiff-line-modified-removed">-                 high_bits_ &lt;&lt;= -shift_amount;</span>
<span class="udiff-line-modified-removed">-                 high_bits_ += low_bits_ &gt;&gt; (64 + shift_amount);</span>
<span class="udiff-line-modified-removed">-                 low_bits_ &lt;&lt;= -shift_amount;</span>
<span class="udiff-line-modified-removed">-             } else {</span>
<span class="udiff-line-modified-removed">-                 low_bits_ &gt;&gt;= shift_amount;</span>
<span class="udiff-line-modified-removed">-                 low_bits_ += high_bits_ &lt;&lt; (64 - shift_amount);</span>
<span class="udiff-line-modified-removed">-                 high_bits_ &gt;&gt;= shift_amount;</span>
<span class="udiff-line-modified-removed">-             }</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-removed">-         </span>
<span class="udiff-line-modified-removed">-         // Modifies *this to *this MOD (2^power).</span>
<span class="udiff-line-modified-removed">-         // Returns *this DIV (2^power).</span>
<span class="udiff-line-modified-removed">-         int DivModPowerOf2(int power) {</span>
<span class="udiff-line-modified-removed">-             if (power &gt;= 64) {</span>
<span class="udiff-line-modified-removed">-                 int result = static_cast&lt;int&gt;(high_bits_ &gt;&gt; (power - 64));</span>
<span class="udiff-line-modified-removed">-                 high_bits_ -= static_cast&lt;uint64_t&gt;(result) &lt;&lt; (power - 64);</span>
<span class="udiff-line-modified-removed">-                 return result;</span>
<span class="udiff-line-modified-removed">-             } else {</span>
<span class="udiff-line-modified-removed">-                 uint64_t part_low = low_bits_ &gt;&gt; power;</span>
<span class="udiff-line-modified-removed">-                 uint64_t part_high = high_bits_ &lt;&lt; (64 - power);</span>
<span class="udiff-line-modified-removed">-                 int result = static_cast&lt;int&gt;(part_low + part_high);</span>
<span class="udiff-line-modified-removed">-                 high_bits_ = 0;</span>
<span class="udiff-line-modified-removed">-                 low_bits_ -= part_low &lt;&lt; power;</span>
<span class="udiff-line-modified-removed">-                 return result;</span>
<span class="udiff-line-modified-removed">-             }</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-removed">-         </span>
<span class="udiff-line-modified-removed">-         bool IsZero() const {</span>
<span class="udiff-line-modified-removed">-             return high_bits_ == 0 &amp;&amp; low_bits_ == 0;</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-removed">-         </span>
<span class="udiff-line-modified-added">+  public:</span>
<span class="udiff-line-modified-added">+   UInt128() : high_bits_(0), low_bits_(0) { }</span>
<span class="udiff-line-modified-added">+   UInt128(uint64_t high, uint64_t low) : high_bits_(high), low_bits_(low) { }</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   void Multiply(uint32_t multiplicand) {</span>
<span class="udiff-line-modified-added">+     uint64_t accumulator;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+     accumulator = (low_bits_ &amp; kMask32) * multiplicand;</span>
<span class="udiff-line-modified-added">+     uint32_t part = static_cast&lt;uint32_t&gt;(accumulator &amp; kMask32);</span>
<span class="udiff-line-modified-added">+     accumulator &gt;&gt;= 32;</span>
<span class="udiff-line-modified-added">+     accumulator = accumulator + (low_bits_ &gt;&gt; 32) * multiplicand;</span>
<span class="udiff-line-modified-added">+     low_bits_ = (accumulator &lt;&lt; 32) + part;</span>
<span class="udiff-line-modified-added">+     accumulator &gt;&gt;= 32;</span>
<span class="udiff-line-modified-added">+     accumulator = accumulator + (high_bits_ &amp; kMask32) * multiplicand;</span>
<span class="udiff-line-modified-added">+     part = static_cast&lt;uint32_t&gt;(accumulator &amp; kMask32);</span>
<span class="udiff-line-modified-added">+     accumulator &gt;&gt;= 32;</span>
<span class="udiff-line-modified-added">+     accumulator = accumulator + (high_bits_ &gt;&gt; 32) * multiplicand;</span>
<span class="udiff-line-modified-added">+     high_bits_ = (accumulator &lt;&lt; 32) + part;</span>
<span class="udiff-line-modified-added">+     ASSERT((accumulator &gt;&gt; 32) == 0);</span>
<span class="udiff-line-modified-added">+   }</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   void Shift(int shift_amount) {</span>
<span class="udiff-line-modified-added">+     ASSERT(-64 &lt;= shift_amount &amp;&amp; shift_amount &lt;= 64);</span>
<span class="udiff-line-modified-added">+     if (shift_amount == 0) {</span>
<span class="udiff-line-modified-added">+       return;</span>
<span class="udiff-line-modified-added">+     } else if (shift_amount == -64) {</span>
<span class="udiff-line-modified-added">+       high_bits_ = low_bits_;</span>
<span class="udiff-line-modified-added">+       low_bits_ = 0;</span>
<span class="udiff-line-modified-added">+     } else if (shift_amount == 64) {</span>
<span class="udiff-line-modified-added">+       low_bits_ = high_bits_;</span>
<span class="udiff-line-modified-added">+       high_bits_ = 0;</span>
<span class="udiff-line-modified-added">+     } else if (shift_amount &lt;= 0) {</span>
<span class="udiff-line-modified-added">+       high_bits_ &lt;&lt;= -shift_amount;</span>
<span class="udiff-line-modified-added">+       high_bits_ += low_bits_ &gt;&gt; (64 + shift_amount);</span>
<span class="udiff-line-modified-added">+       low_bits_ &lt;&lt;= -shift_amount;</span>
<span class="udiff-line-modified-added">+     } else {</span>
<span class="udiff-line-modified-added">+       low_bits_ &gt;&gt;= shift_amount;</span>
<span class="udiff-line-modified-added">+       low_bits_ += high_bits_ &lt;&lt; (64 - shift_amount);</span>
<span class="udiff-line-modified-added">+       high_bits_ &gt;&gt;= shift_amount;</span>
<span class="udiff-line-modified-added">+     }</span>
<span class="udiff-line-modified-added">+   }</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   // Modifies *this to *this MOD (2^power).</span>
<span class="udiff-line-modified-added">+   // Returns *this DIV (2^power).</span>
<span class="udiff-line-modified-added">+   int DivModPowerOf2(int power) {</span>
<span class="udiff-line-modified-added">+     if (power &gt;= 64) {</span>
<span class="udiff-line-modified-added">+       int result = static_cast&lt;int&gt;(high_bits_ &gt;&gt; (power - 64));</span>
<span class="udiff-line-modified-added">+       high_bits_ -= static_cast&lt;uint64_t&gt;(result) &lt;&lt; (power - 64);</span>
<span class="udiff-line-modified-added">+       return result;</span>
<span class="udiff-line-modified-added">+     } else {</span>
<span class="udiff-line-modified-added">+       uint64_t part_low = low_bits_ &gt;&gt; power;</span>
<span class="udiff-line-modified-added">+       uint64_t part_high = high_bits_ &lt;&lt; (64 - power);</span>
<span class="udiff-line-modified-added">+       int result = static_cast&lt;int&gt;(part_low + part_high);</span>
<span class="udiff-line-modified-added">+       high_bits_ = 0;</span>
<span class="udiff-line-modified-added">+       low_bits_ -= part_low &lt;&lt; power;</span>
<span class="udiff-line-modified-added">+       return result;</span>
<span class="udiff-line-modified-added">+     }</span>
<span class="udiff-line-modified-added">+   }</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   bool IsZero() const {</span>
<span class="udiff-line-modified-added">+     return high_bits_ == 0 &amp;&amp; low_bits_ == 0;</span>
<span class="udiff-line-modified-added">+   }</span>
<span class="udiff-line-modified-added">+ </span>
    int BitAt(int position) const {
<span class="udiff-line-modified-removed">-             if (position &gt;= 64) {</span>
<span class="udiff-line-modified-removed">-                 return static_cast&lt;int&gt;(high_bits_ &gt;&gt; (position - 64)) &amp; 1;</span>
<span class="udiff-line-modified-removed">-             } else {</span>
<span class="udiff-line-modified-removed">-                 return static_cast&lt;int&gt;(low_bits_ &gt;&gt; position) &amp; 1;</span>
<span class="udiff-line-modified-removed">-             }</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-removed">-         </span>
<span class="udiff-line-modified-removed">-     private:</span>
<span class="udiff-line-modified-removed">-         static const uint64_t kMask32 = 0xFFFFFFFF;</span>
<span class="udiff-line-modified-removed">-         // Value == (high_bits_ &lt;&lt; 64) + low_bits_</span>
<span class="udiff-line-modified-removed">-         uint64_t high_bits_;</span>
<span class="udiff-line-modified-removed">-         uint64_t low_bits_;</span>
<span class="udiff-line-modified-added">+     if (position &gt;= 64) {</span>
<span class="udiff-line-modified-added">+       return static_cast&lt;int&gt;(high_bits_ &gt;&gt; (position - 64)) &amp; 1;</span>
<span class="udiff-line-modified-added">+     } else {</span>
<span class="udiff-line-modified-added">+       return static_cast&lt;int&gt;(low_bits_ &gt;&gt; position) &amp; 1;</span>
<span class="udiff-line-modified-added">+     }</span>
<span class="udiff-line-modified-added">+   }</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+  private:</span>
<span class="udiff-line-modified-added">+   static const uint64_t kMask32 = 0xFFFFFFFF;</span>
<span class="udiff-line-modified-added">+   // Value == (high_bits_ &lt;&lt; 64) + low_bits_</span>
<span class="udiff-line-modified-added">+   uint64_t high_bits_;</span>
<span class="udiff-line-modified-added">+   uint64_t low_bits_;</span>
  };
<span class="udiff-line-modified-removed">-     </span>
<span class="udiff-line-modified-removed">-     </span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+ </span>
  static const int kDoubleSignificandSize = 53;  // Includes the hidden bit.
<span class="udiff-line-modified-removed">-     </span>
<span class="udiff-line-modified-removed">-     </span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+ </span>
  static void FillDigits32FixedLength(uint32_t number, int requested_length,
<span class="udiff-line-modified-removed">-                                         BufferReference&lt;char&gt; buffer, int* length) {</span>
<span class="udiff-line-modified-removed">-         for (int i = requested_length - 1; i &gt;= 0; --i) {</span>
<span class="udiff-line-modified-removed">-             buffer[(*length) + i] = &#39;0&#39; + number % 10;</span>
<span class="udiff-line-modified-removed">-             number /= 10;</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-removed">-         *length += requested_length;</span>
<span class="udiff-line-modified-added">+                                     BufferReference&lt;char&gt; buffer, int* length) {</span>
<span class="udiff-line-modified-added">+   for (int i = requested_length - 1; i &gt;= 0; --i) {</span>
<span class="udiff-line-modified-added">+     buffer[(*length) + i] = &#39;0&#39; + number % 10;</span>
<span class="udiff-line-modified-added">+     number /= 10;</span>
<span class="udiff-line-modified-added">+   }</span>
<span class="udiff-line-modified-added">+   *length += requested_length;</span>
  }
<span class="udiff-line-modified-removed">-     </span>
<span class="udiff-line-modified-removed">-     </span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+ </span>
  static void FillDigits32(uint32_t number, BufferReference&lt;char&gt; buffer, int* length) {
<span class="udiff-line-modified-removed">-         int number_length = 0;</span>
<span class="udiff-line-modified-removed">-         // We fill the digits in reverse order and exchange them afterwards.</span>
<span class="udiff-line-modified-removed">-         while (number != 0) {</span>
<span class="udiff-line-modified-removed">-             int digit = number % 10;</span>
<span class="udiff-line-modified-removed">-             number /= 10;</span>
<span class="udiff-line-modified-added">+   int number_length = 0;</span>
<span class="udiff-line-modified-added">+   // We fill the digits in reverse order and exchange them afterwards.</span>
<span class="udiff-line-modified-added">+   while (number != 0) {</span>
<span class="udiff-line-modified-added">+     int digit = number % 10;</span>
<span class="udiff-line-modified-added">+     number /= 10;</span>
      buffer[(*length) + number_length] = static_cast&lt;char&gt;(&#39;0&#39; + digit);
<span class="udiff-line-modified-removed">-             number_length++;</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-removed">-         // Exchange the digits.</span>
<span class="udiff-line-modified-removed">-         int i = *length;</span>
<span class="udiff-line-modified-removed">-         int j = *length + number_length - 1;</span>
<span class="udiff-line-modified-removed">-         while (i &lt; j) {</span>
<span class="udiff-line-modified-removed">-             char tmp = buffer[i];</span>
<span class="udiff-line-modified-removed">-             buffer[i] = buffer[j];</span>
<span class="udiff-line-modified-removed">-             buffer[j] = tmp;</span>
<span class="udiff-line-modified-removed">-             i++;</span>
<span class="udiff-line-modified-removed">-             j--;</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-removed">-         *length += number_length;</span>
<span class="udiff-line-modified-added">+     number_length++;</span>
<span class="udiff-line-modified-added">+   }</span>
<span class="udiff-line-modified-added">+   // Exchange the digits.</span>
<span class="udiff-line-modified-added">+   int i = *length;</span>
<span class="udiff-line-modified-added">+   int j = *length + number_length - 1;</span>
<span class="udiff-line-modified-added">+   while (i &lt; j) {</span>
<span class="udiff-line-modified-added">+     char tmp = buffer[i];</span>
<span class="udiff-line-modified-added">+     buffer[i] = buffer[j];</span>
<span class="udiff-line-modified-added">+     buffer[j] = tmp;</span>
<span class="udiff-line-modified-added">+     i++;</span>
<span class="udiff-line-modified-added">+     j--;</span>
<span class="udiff-line-modified-added">+   }</span>
<span class="udiff-line-modified-added">+   *length += number_length;</span>
  }
<span class="udiff-line-modified-removed">-     </span>
<span class="udiff-line-modified-removed">-     </span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+ </span>
  static void FillDigits64FixedLength(uint64_t number,
<span class="udiff-line-modified-removed">-                                         BufferReference&lt;char&gt; buffer, int* length) {</span>
<span class="udiff-line-modified-removed">-         const uint32_t kTen7 = 10000000;</span>
<span class="udiff-line-modified-removed">-         // For efficiency cut the number into 3 uint32_t parts, and print those.</span>
<span class="udiff-line-modified-removed">-         uint32_t part2 = static_cast&lt;uint32_t&gt;(number % kTen7);</span>
<span class="udiff-line-modified-removed">-         number /= kTen7;</span>
<span class="udiff-line-modified-removed">-         uint32_t part1 = static_cast&lt;uint32_t&gt;(number % kTen7);</span>
<span class="udiff-line-modified-removed">-         uint32_t part0 = static_cast&lt;uint32_t&gt;(number / kTen7);</span>
<span class="udiff-line-modified-removed">-         </span>
<span class="udiff-line-modified-removed">-         FillDigits32FixedLength(part0, 3, buffer, length);</span>
<span class="udiff-line-modified-removed">-         FillDigits32FixedLength(part1, 7, buffer, length);</span>
<span class="udiff-line-modified-removed">-         FillDigits32FixedLength(part2, 7, buffer, length);</span>
<span class="udiff-line-modified-added">+                                     BufferReference&lt;char&gt; buffer, int* length) {</span>
<span class="udiff-line-modified-added">+   const uint32_t kTen7 = 10000000;</span>
<span class="udiff-line-modified-added">+   // For efficiency cut the number into 3 uint32_t parts, and print those.</span>
<span class="udiff-line-modified-added">+   uint32_t part2 = static_cast&lt;uint32_t&gt;(number % kTen7);</span>
<span class="udiff-line-modified-added">+   number /= kTen7;</span>
<span class="udiff-line-modified-added">+   uint32_t part1 = static_cast&lt;uint32_t&gt;(number % kTen7);</span>
<span class="udiff-line-modified-added">+   uint32_t part0 = static_cast&lt;uint32_t&gt;(number / kTen7);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   FillDigits32FixedLength(part0, 3, buffer, length);</span>
<span class="udiff-line-modified-added">+   FillDigits32FixedLength(part1, 7, buffer, length);</span>
<span class="udiff-line-modified-added">+   FillDigits32FixedLength(part2, 7, buffer, length);</span>
  }
<span class="udiff-line-modified-removed">-     </span>
<span class="udiff-line-modified-removed">-     </span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+ </span>
  static void FillDigits64(uint64_t number, BufferReference&lt;char&gt; buffer, int* length) {
<span class="udiff-line-modified-removed">-         const uint32_t kTen7 = 10000000;</span>
<span class="udiff-line-modified-removed">-         // For efficiency cut the number into 3 uint32_t parts, and print those.</span>
<span class="udiff-line-modified-removed">-         uint32_t part2 = static_cast&lt;uint32_t&gt;(number % kTen7);</span>
<span class="udiff-line-modified-removed">-         number /= kTen7;</span>
<span class="udiff-line-modified-removed">-         uint32_t part1 = static_cast&lt;uint32_t&gt;(number % kTen7);</span>
<span class="udiff-line-modified-removed">-         uint32_t part0 = static_cast&lt;uint32_t&gt;(number / kTen7);</span>
<span class="udiff-line-modified-removed">-         </span>
<span class="udiff-line-modified-removed">-         if (part0 != 0) {</span>
<span class="udiff-line-modified-removed">-             FillDigits32(part0, buffer, length);</span>
<span class="udiff-line-modified-removed">-             FillDigits32FixedLength(part1, 7, buffer, length);</span>
<span class="udiff-line-modified-removed">-             FillDigits32FixedLength(part2, 7, buffer, length);</span>
<span class="udiff-line-modified-removed">-         } else if (part1 != 0) {</span>
<span class="udiff-line-modified-removed">-             FillDigits32(part1, buffer, length);</span>
<span class="udiff-line-modified-removed">-             FillDigits32FixedLength(part2, 7, buffer, length);</span>
<span class="udiff-line-modified-removed">-         } else {</span>
<span class="udiff-line-modified-removed">-             FillDigits32(part2, buffer, length);</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-added">+   const uint32_t kTen7 = 10000000;</span>
<span class="udiff-line-modified-added">+   // For efficiency cut the number into 3 uint32_t parts, and print those.</span>
<span class="udiff-line-modified-added">+   uint32_t part2 = static_cast&lt;uint32_t&gt;(number % kTen7);</span>
<span class="udiff-line-modified-added">+   number /= kTen7;</span>
<span class="udiff-line-modified-added">+   uint32_t part1 = static_cast&lt;uint32_t&gt;(number % kTen7);</span>
<span class="udiff-line-modified-added">+   uint32_t part0 = static_cast&lt;uint32_t&gt;(number / kTen7);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   if (part0 != 0) {</span>
<span class="udiff-line-modified-added">+     FillDigits32(part0, buffer, length);</span>
<span class="udiff-line-modified-added">+     FillDigits32FixedLength(part1, 7, buffer, length);</span>
<span class="udiff-line-modified-added">+     FillDigits32FixedLength(part2, 7, buffer, length);</span>
<span class="udiff-line-modified-added">+   } else if (part1 != 0) {</span>
<span class="udiff-line-modified-added">+     FillDigits32(part1, buffer, length);</span>
<span class="udiff-line-modified-added">+     FillDigits32FixedLength(part2, 7, buffer, length);</span>
<span class="udiff-line-modified-added">+   } else {</span>
<span class="udiff-line-modified-added">+     FillDigits32(part2, buffer, length);</span>
<span class="udiff-line-modified-added">+   }</span>
  }
<span class="udiff-line-modified-removed">-     </span>
<span class="udiff-line-modified-removed">-     </span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+ </span>
  static void RoundUp(BufferReference&lt;char&gt; buffer, int* length, int* decimal_point) {
<span class="udiff-line-modified-removed">-         // An empty buffer represents 0.</span>
<span class="udiff-line-modified-removed">-         if (*length == 0) {</span>
<span class="udiff-line-modified-removed">-             buffer[0] = &#39;1&#39;;</span>
<span class="udiff-line-modified-removed">-             *decimal_point = 1;</span>
<span class="udiff-line-modified-removed">-             *length = 1;</span>
<span class="udiff-line-modified-removed">-             return;</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-removed">-         // Round the last digit until we either have a digit that was not &#39;9&#39; or until</span>
<span class="udiff-line-modified-removed">-         // we reached the first digit.</span>
<span class="udiff-line-modified-removed">-         buffer[(*length) - 1]++;</span>
<span class="udiff-line-modified-removed">-         for (int i = (*length) - 1; i &gt; 0; --i) {</span>
<span class="udiff-line-modified-removed">-             if (buffer[i] != &#39;0&#39; + 10) {</span>
<span class="udiff-line-modified-removed">-                 return;</span>
<span class="udiff-line-modified-removed">-             }</span>
<span class="udiff-line-modified-removed">-             buffer[i] = &#39;0&#39;;</span>
<span class="udiff-line-modified-removed">-             buffer[i - 1]++;</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-removed">-         // If the first digit is now &#39;0&#39; + 10, we would need to set it to &#39;0&#39; and add</span>
<span class="udiff-line-modified-removed">-         // a &#39;1&#39; in front. However we reach the first digit only if all following</span>
<span class="udiff-line-modified-removed">-         // digits had been &#39;9&#39; before rounding up. Now all trailing digits are &#39;0&#39; and</span>
<span class="udiff-line-modified-removed">-         // we simply switch the first digit to &#39;1&#39; and update the decimal-point</span>
<span class="udiff-line-modified-removed">-         // (indicating that the point is now one digit to the right).</span>
<span class="udiff-line-modified-removed">-         if (buffer[0] == &#39;0&#39; + 10) {</span>
<span class="udiff-line-modified-removed">-             buffer[0] = &#39;1&#39;;</span>
<span class="udiff-line-modified-removed">-             (*decimal_point)++;</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-added">+   // An empty buffer represents 0.</span>
<span class="udiff-line-modified-added">+   if (*length == 0) {</span>
<span class="udiff-line-modified-added">+     buffer[0] = &#39;1&#39;;</span>
<span class="udiff-line-modified-added">+     *decimal_point = 1;</span>
<span class="udiff-line-modified-added">+     *length = 1;</span>
<span class="udiff-line-modified-added">+     return;</span>
<span class="udiff-line-modified-added">+   }</span>
<span class="udiff-line-modified-added">+   // Round the last digit until we either have a digit that was not &#39;9&#39; or until</span>
<span class="udiff-line-modified-added">+   // we reached the first digit.</span>
<span class="udiff-line-modified-added">+   buffer[(*length) - 1]++;</span>
<span class="udiff-line-modified-added">+   for (int i = (*length) - 1; i &gt; 0; --i) {</span>
<span class="udiff-line-modified-added">+     if (buffer[i] != &#39;0&#39; + 10) {</span>
<span class="udiff-line-modified-added">+       return;</span>
<span class="udiff-line-modified-added">+     }</span>
<span class="udiff-line-modified-added">+     buffer[i] = &#39;0&#39;;</span>
<span class="udiff-line-modified-added">+     buffer[i - 1]++;</span>
<span class="udiff-line-modified-added">+   }</span>
<span class="udiff-line-modified-added">+   // If the first digit is now &#39;0&#39; + 10, we would need to set it to &#39;0&#39; and add</span>
<span class="udiff-line-modified-added">+   // a &#39;1&#39; in front. However we reach the first digit only if all following</span>
<span class="udiff-line-modified-added">+   // digits had been &#39;9&#39; before rounding up. Now all trailing digits are &#39;0&#39; and</span>
<span class="udiff-line-modified-added">+   // we simply switch the first digit to &#39;1&#39; and update the decimal-point</span>
<span class="udiff-line-modified-added">+   // (indicating that the point is now one digit to the right).</span>
<span class="udiff-line-modified-added">+   if (buffer[0] == &#39;0&#39; + 10) {</span>
<span class="udiff-line-modified-added">+     buffer[0] = &#39;1&#39;;</span>
<span class="udiff-line-modified-added">+     (*decimal_point)++;</span>
<span class="udiff-line-modified-added">+   }</span>
  }
<span class="udiff-line-modified-removed">-     </span>
<span class="udiff-line-modified-removed">-     </span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+ </span>
  // The given fractionals number represents a fixed-point number with binary
  // point at bit (-exponent).
  // Preconditions:
  //   -128 &lt;= exponent &lt;= 0.
  //   0 &lt;= fractionals * 2^exponent &lt; 1
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -229,181 +229,181 @@</span>
  // generated by this function might be updated, and the decimal-point variable
  // might be updated. If this function generates the digits 99 and the buffer
  // already contained &quot;199&quot; (thus yielding a buffer of &quot;19999&quot;) then a
  // rounding-up will change the contents of the buffer to &quot;20000&quot;.
  static void FillFractionals(uint64_t fractionals, int exponent,
<span class="udiff-line-modified-removed">-                                 int fractional_count, BufferReference&lt;char&gt; buffer,</span>
<span class="udiff-line-modified-removed">-                                 int* length, int* decimal_point) {</span>
<span class="udiff-line-modified-removed">-         ASSERT(-128 &lt;= exponent &amp;&amp; exponent &lt;= 0);</span>
<span class="udiff-line-modified-removed">-         // &#39;fractionals&#39; is a fixed-point number, with binary point at bit</span>
<span class="udiff-line-modified-removed">-         // (-exponent). Inside the function the non-converted remainder of fractionals</span>
<span class="udiff-line-modified-removed">-         // is a fixed-point number, with binary point at bit &#39;point&#39;.</span>
<span class="udiff-line-modified-removed">-         if (-exponent &lt;= 64) {</span>
<span class="udiff-line-modified-removed">-             // One 64 bit number is sufficient.</span>
<span class="udiff-line-modified-removed">-             ASSERT(fractionals &gt;&gt; 56 == 0);</span>
<span class="udiff-line-modified-removed">-             int point = -exponent;</span>
<span class="udiff-line-modified-removed">-             for (int i = 0; i &lt; fractional_count; ++i) {</span>
<span class="udiff-line-modified-removed">-                 if (fractionals == 0) break;</span>
<span class="udiff-line-modified-removed">-                 // Instead of multiplying by 10 we multiply by 5 and adjust the point</span>
<span class="udiff-line-modified-removed">-                 // location. This way the fractionals variable will not overflow.</span>
<span class="udiff-line-modified-removed">-                 // Invariant at the beginning of the loop: fractionals &lt; 2^point.</span>
<span class="udiff-line-modified-removed">-                 // Initially we have: point &lt;= 64 and fractionals &lt; 2^56</span>
<span class="udiff-line-modified-removed">-                 // After each iteration the point is decremented by one.</span>
<span class="udiff-line-modified-removed">-                 // Note that 5^3 = 125 &lt; 128 = 2^7.</span>
<span class="udiff-line-modified-removed">-                 // Therefore three iterations of this loop will not overflow fractionals</span>
<span class="udiff-line-modified-removed">-                 // (even without the subtraction at the end of the loop body). At this</span>
<span class="udiff-line-modified-removed">-                 // time point will satisfy point &lt;= 61 and therefore fractionals &lt; 2^point</span>
<span class="udiff-line-modified-removed">-                 // and any further multiplication of fractionals by 5 will not overflow.</span>
<span class="udiff-line-modified-removed">-                 fractionals *= 5;</span>
<span class="udiff-line-modified-removed">-                 point--;</span>
<span class="udiff-line-modified-removed">-                 int digit = static_cast&lt;int&gt;(fractionals &gt;&gt; point);</span>
<span class="udiff-line-modified-added">+                             int fractional_count, BufferReference&lt;char&gt; buffer,</span>
<span class="udiff-line-modified-added">+                             int* length, int* decimal_point) {</span>
<span class="udiff-line-modified-added">+   ASSERT(-128 &lt;= exponent &amp;&amp; exponent &lt;= 0);</span>
<span class="udiff-line-modified-added">+   // &#39;fractionals&#39; is a fixed-point number, with binary point at bit</span>
<span class="udiff-line-modified-added">+   // (-exponent). Inside the function the non-converted remainder of fractionals</span>
<span class="udiff-line-modified-added">+   // is a fixed-point number, with binary point at bit &#39;point&#39;.</span>
<span class="udiff-line-modified-added">+   if (-exponent &lt;= 64) {</span>
<span class="udiff-line-modified-added">+     // One 64 bit number is sufficient.</span>
<span class="udiff-line-modified-added">+     ASSERT(fractionals &gt;&gt; 56 == 0);</span>
<span class="udiff-line-modified-added">+     int point = -exponent;</span>
<span class="udiff-line-modified-added">+     for (int i = 0; i &lt; fractional_count; ++i) {</span>
<span class="udiff-line-modified-added">+       if (fractionals == 0) break;</span>
<span class="udiff-line-modified-added">+       // Instead of multiplying by 10 we multiply by 5 and adjust the point</span>
<span class="udiff-line-modified-added">+       // location. This way the fractionals variable will not overflow.</span>
<span class="udiff-line-modified-added">+       // Invariant at the beginning of the loop: fractionals &lt; 2^point.</span>
<span class="udiff-line-modified-added">+       // Initially we have: point &lt;= 64 and fractionals &lt; 2^56</span>
<span class="udiff-line-modified-added">+       // After each iteration the point is decremented by one.</span>
<span class="udiff-line-modified-added">+       // Note that 5^3 = 125 &lt; 128 = 2^7.</span>
<span class="udiff-line-modified-added">+       // Therefore three iterations of this loop will not overflow fractionals</span>
<span class="udiff-line-modified-added">+       // (even without the subtraction at the end of the loop body). At this</span>
<span class="udiff-line-modified-added">+       // time point will satisfy point &lt;= 61 and therefore fractionals &lt; 2^point</span>
<span class="udiff-line-modified-added">+       // and any further multiplication of fractionals by 5 will not overflow.</span>
<span class="udiff-line-modified-added">+       fractionals *= 5;</span>
<span class="udiff-line-modified-added">+       point--;</span>
<span class="udiff-line-modified-added">+       int digit = static_cast&lt;int&gt;(fractionals &gt;&gt; point);</span>
        ASSERT(digit &lt;= 9);
        buffer[*length] = static_cast&lt;char&gt;(&#39;0&#39; + digit);
<span class="udiff-line-modified-removed">-                 (*length)++;</span>
<span class="udiff-line-modified-removed">-                 fractionals -= static_cast&lt;uint64_t&gt;(digit) &lt;&lt; point;</span>
<span class="udiff-line-modified-removed">-             }</span>
<span class="udiff-line-modified-removed">-             // If the first bit after the point is set we have to round up.</span>
<span class="udiff-line-modified-added">+       (*length)++;</span>
<span class="udiff-line-modified-added">+       fractionals -= static_cast&lt;uint64_t&gt;(digit) &lt;&lt; point;</span>
<span class="udiff-line-modified-added">+     }</span>
<span class="udiff-line-modified-added">+     // If the first bit after the point is set we have to round up.</span>
      ASSERT(fractionals == 0 || point - 1 &gt;= 0);
      if ((fractionals != 0) &amp;&amp; ((fractionals &gt;&gt; (point - 1)) &amp; 1) == 1) {
<span class="udiff-line-modified-removed">-                 RoundUp(buffer, length, decimal_point);</span>
<span class="udiff-line-modified-removed">-             }</span>
<span class="udiff-line-modified-removed">-         } else {  // We need 128 bits.</span>
<span class="udiff-line-modified-removed">-             ASSERT(64 &lt; -exponent &amp;&amp; -exponent &lt;= 128);</span>
<span class="udiff-line-modified-removed">-             UInt128 fractionals128 = UInt128(fractionals, 0);</span>
<span class="udiff-line-modified-removed">-             fractionals128.Shift(-exponent - 64);</span>
<span class="udiff-line-modified-removed">-             int point = 128;</span>
<span class="udiff-line-modified-removed">-             for (int i = 0; i &lt; fractional_count; ++i) {</span>
<span class="udiff-line-modified-removed">-                 if (fractionals128.IsZero()) break;</span>
<span class="udiff-line-modified-removed">-                 // As before: instead of multiplying by 10 we multiply by 5 and adjust the</span>
<span class="udiff-line-modified-removed">-                 // point location.</span>
<span class="udiff-line-modified-removed">-                 // This multiplication will not overflow for the same reasons as before.</span>
<span class="udiff-line-modified-removed">-                 fractionals128.Multiply(5);</span>
<span class="udiff-line-modified-removed">-                 point--;</span>
<span class="udiff-line-modified-removed">-                 int digit = fractionals128.DivModPowerOf2(point);</span>
<span class="udiff-line-modified-added">+       RoundUp(buffer, length, decimal_point);</span>
<span class="udiff-line-modified-added">+     }</span>
<span class="udiff-line-modified-added">+   } else {  // We need 128 bits.</span>
<span class="udiff-line-modified-added">+     ASSERT(64 &lt; -exponent &amp;&amp; -exponent &lt;= 128);</span>
<span class="udiff-line-modified-added">+     UInt128 fractionals128 = UInt128(fractionals, 0);</span>
<span class="udiff-line-modified-added">+     fractionals128.Shift(-exponent - 64);</span>
<span class="udiff-line-modified-added">+     int point = 128;</span>
<span class="udiff-line-modified-added">+     for (int i = 0; i &lt; fractional_count; ++i) {</span>
<span class="udiff-line-modified-added">+       if (fractionals128.IsZero()) break;</span>
<span class="udiff-line-modified-added">+       // As before: instead of multiplying by 10 we multiply by 5 and adjust the</span>
<span class="udiff-line-modified-added">+       // point location.</span>
<span class="udiff-line-modified-added">+       // This multiplication will not overflow for the same reasons as before.</span>
<span class="udiff-line-modified-added">+       fractionals128.Multiply(5);</span>
<span class="udiff-line-modified-added">+       point--;</span>
<span class="udiff-line-modified-added">+       int digit = fractionals128.DivModPowerOf2(point);</span>
        ASSERT(digit &lt;= 9);
        buffer[*length] = static_cast&lt;char&gt;(&#39;0&#39; + digit);
<span class="udiff-line-modified-removed">-                 (*length)++;</span>
<span class="udiff-line-modified-removed">-             }</span>
<span class="udiff-line-modified-removed">-             if (fractionals128.BitAt(point - 1) == 1) {</span>
<span class="udiff-line-modified-removed">-                 RoundUp(buffer, length, decimal_point);</span>
<span class="udiff-line-modified-removed">-             }</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-added">+       (*length)++;</span>
<span class="udiff-line-modified-added">+     }</span>
<span class="udiff-line-modified-added">+     if (fractionals128.BitAt(point - 1) == 1) {</span>
<span class="udiff-line-modified-added">+       RoundUp(buffer, length, decimal_point);</span>
<span class="udiff-line-modified-added">+     }</span>
<span class="udiff-line-modified-added">+   }</span>
  }
<span class="udiff-line-modified-removed">-     </span>
<span class="udiff-line-modified-removed">-     </span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+ </span>
  // Removes leading and trailing zeros.
  // If leading zeros are removed then the decimal point position is adjusted.
  static void TrimZeros(BufferReference&lt;char&gt; buffer, int* length, int* decimal_point) {
<span class="udiff-line-modified-removed">-         while (*length &gt; 0 &amp;&amp; buffer[(*length) - 1] == &#39;0&#39;) {</span>
<span class="udiff-line-modified-removed">-             (*length)--;</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-removed">-         int first_non_zero = 0;</span>
<span class="udiff-line-modified-removed">-         while (first_non_zero &lt; *length &amp;&amp; buffer[first_non_zero] == &#39;0&#39;) {</span>
<span class="udiff-line-modified-removed">-             first_non_zero++;</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-removed">-         if (first_non_zero != 0) {</span>
<span class="udiff-line-modified-removed">-             for (int i = first_non_zero; i &lt; *length; ++i) {</span>
<span class="udiff-line-modified-removed">-                 buffer[i - first_non_zero] = buffer[i];</span>
<span class="udiff-line-modified-removed">-             }</span>
<span class="udiff-line-modified-removed">-             *length -= first_non_zero;</span>
<span class="udiff-line-modified-removed">-             *decimal_point -= first_non_zero;</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-added">+   while (*length &gt; 0 &amp;&amp; buffer[(*length) - 1] == &#39;0&#39;) {</span>
<span class="udiff-line-modified-added">+     (*length)--;</span>
<span class="udiff-line-modified-added">+   }</span>
<span class="udiff-line-modified-added">+   int first_non_zero = 0;</span>
<span class="udiff-line-modified-added">+   while (first_non_zero &lt; *length &amp;&amp; buffer[first_non_zero] == &#39;0&#39;) {</span>
<span class="udiff-line-modified-added">+     first_non_zero++;</span>
<span class="udiff-line-modified-added">+   }</span>
<span class="udiff-line-modified-added">+   if (first_non_zero != 0) {</span>
<span class="udiff-line-modified-added">+     for (int i = first_non_zero; i &lt; *length; ++i) {</span>
<span class="udiff-line-modified-added">+       buffer[i - first_non_zero] = buffer[i];</span>
<span class="udiff-line-modified-added">+     }</span>
<span class="udiff-line-modified-added">+     *length -= first_non_zero;</span>
<span class="udiff-line-modified-added">+     *decimal_point -= first_non_zero;</span>
<span class="udiff-line-modified-added">+   }</span>
  }
<span class="udiff-line-modified-removed">-     </span>
<span class="udiff-line-modified-removed">-     </span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+ </span>
  bool FastFixedDtoa(double v,
<span class="udiff-line-modified-removed">-                        int fractional_count,</span>
<span class="udiff-line-modified-removed">-                        BufferReference&lt;char&gt; buffer,</span>
<span class="udiff-line-modified-removed">-                        int* length,</span>
<span class="udiff-line-modified-removed">-                        int* decimal_point) {</span>
<span class="udiff-line-modified-removed">-         const uint32_t kMaxUInt32 = 0xFFFFFFFF;</span>
<span class="udiff-line-modified-removed">-         uint64_t significand = Double(v).Significand();</span>
<span class="udiff-line-modified-removed">-         int exponent = Double(v).Exponent();</span>
<span class="udiff-line-modified-removed">-         // v = significand * 2^exponent (with significand a 53bit integer).</span>
<span class="udiff-line-modified-removed">-         // If the exponent is larger than 20 (i.e. we may have a 73bit number) then we</span>
<span class="udiff-line-modified-removed">-         // don&#39;t know how to compute the representation. 2^73 ~= 9.5*10^21.</span>
<span class="udiff-line-modified-removed">-         // If necessary this limit could probably be increased, but we don&#39;t need</span>
<span class="udiff-line-modified-removed">-         // more.</span>
<span class="udiff-line-modified-removed">-         if (exponent &gt; 20) return false;</span>
<span class="udiff-line-modified-removed">-         if (fractional_count &gt; 20) return false;</span>
<span class="udiff-line-modified-removed">-         *length = 0;</span>
<span class="udiff-line-modified-removed">-         // At most kDoubleSignificandSize bits of the significand are non-zero.</span>
<span class="udiff-line-modified-removed">-         // Given a 64 bit integer we have 11 0s followed by 53 potentially non-zero</span>
<span class="udiff-line-modified-removed">-         // bits:  0..11*..0xxx..53*..xx</span>
<span class="udiff-line-modified-removed">-         if (exponent + kDoubleSignificandSize &gt; 64) {</span>
<span class="udiff-line-modified-removed">-             // The exponent must be &gt; 11.</span>
<span class="udiff-line-modified-removed">-             //</span>
<span class="udiff-line-modified-removed">-             // We know that v = significand * 2^exponent.</span>
<span class="udiff-line-modified-removed">-             // And the exponent &gt; 11.</span>
<span class="udiff-line-modified-removed">-             // We simplify the task by dividing v by 10^17.</span>
<span class="udiff-line-modified-removed">-             // The quotient delivers the first digits, and the remainder fits into a 64</span>
<span class="udiff-line-modified-removed">-             // bit number.</span>
<span class="udiff-line-modified-removed">-             // Dividing by 10^17 is equivalent to dividing by 5^17*2^17.</span>
<span class="udiff-line-modified-removed">-             const uint64_t kFive17 = UINT64_2PART_C(0xB1, A2BC2EC5);  // 5^17</span>
<span class="udiff-line-modified-removed">-             uint64_t divisor = kFive17;</span>
<span class="udiff-line-modified-removed">-             int divisor_power = 17;</span>
<span class="udiff-line-modified-removed">-             uint64_t dividend = significand;</span>
<span class="udiff-line-modified-removed">-             uint32_t quotient;</span>
<span class="udiff-line-modified-removed">-             uint64_t remainder;</span>
<span class="udiff-line-modified-removed">-             // Let v = f * 2^e with f == significand and e == exponent.</span>
<span class="udiff-line-modified-removed">-             // Then need q (quotient) and r (remainder) as follows:</span>
<span class="udiff-line-modified-removed">-             //   v            = q * 10^17       + r</span>
<span class="udiff-line-modified-removed">-             //   f * 2^e      = q * 10^17       + r</span>
<span class="udiff-line-modified-removed">-             //   f * 2^e      = q * 5^17 * 2^17 + r</span>
<span class="udiff-line-modified-removed">-             // If e &gt; 17 then</span>
<span class="udiff-line-modified-removed">-             //   f * 2^(e-17) = q * 5^17        + r/2^17</span>
<span class="udiff-line-modified-removed">-             // else</span>
<span class="udiff-line-modified-removed">-             //   f  = q * 5^17 * 2^(17-e) + r/2^e</span>
<span class="udiff-line-modified-removed">-             if (exponent &gt; divisor_power) {</span>
<span class="udiff-line-modified-removed">-                 // We only allow exponents of up to 20 and therefore (17 - e) &lt;= 3</span>
<span class="udiff-line-modified-removed">-                 dividend &lt;&lt;= exponent - divisor_power;</span>
<span class="udiff-line-modified-removed">-                 quotient = static_cast&lt;uint32_t&gt;(dividend / divisor);</span>
<span class="udiff-line-modified-removed">-                 remainder = (dividend % divisor) &lt;&lt; divisor_power;</span>
<span class="udiff-line-modified-removed">-             } else {</span>
<span class="udiff-line-modified-removed">-                 divisor &lt;&lt;= divisor_power - exponent;</span>
<span class="udiff-line-modified-removed">-                 quotient = static_cast&lt;uint32_t&gt;(dividend / divisor);</span>
<span class="udiff-line-modified-removed">-                 remainder = (dividend % divisor) &lt;&lt; exponent;</span>
<span class="udiff-line-modified-removed">-             }</span>
<span class="udiff-line-modified-removed">-             FillDigits32(quotient, buffer, length);</span>
<span class="udiff-line-modified-added">+                    int fractional_count,</span>
<span class="udiff-line-modified-added">+                    BufferReference&lt;char&gt; buffer,</span>
<span class="udiff-line-modified-added">+                    int* length,</span>
<span class="udiff-line-modified-added">+                    int* decimal_point) {</span>
<span class="udiff-line-modified-added">+   const uint32_t kMaxUInt32 = 0xFFFFFFFF;</span>
<span class="udiff-line-modified-added">+   uint64_t significand = Double(v).Significand();</span>
<span class="udiff-line-modified-added">+   int exponent = Double(v).Exponent();</span>
<span class="udiff-line-modified-added">+   // v = significand * 2^exponent (with significand a 53bit integer).</span>
<span class="udiff-line-modified-added">+   // If the exponent is larger than 20 (i.e. we may have a 73bit number) then we</span>
<span class="udiff-line-modified-added">+   // don&#39;t know how to compute the representation. 2^73 ~= 9.5*10^21.</span>
<span class="udiff-line-modified-added">+   // If necessary this limit could probably be increased, but we don&#39;t need</span>
<span class="udiff-line-modified-added">+   // more.</span>
<span class="udiff-line-modified-added">+   if (exponent &gt; 20) return false;</span>
<span class="udiff-line-modified-added">+   if (fractional_count &gt; 20) return false;</span>
<span class="udiff-line-modified-added">+   *length = 0;</span>
<span class="udiff-line-modified-added">+   // At most kDoubleSignificandSize bits of the significand are non-zero.</span>
<span class="udiff-line-modified-added">+   // Given a 64 bit integer we have 11 0s followed by 53 potentially non-zero</span>
<span class="udiff-line-modified-added">+   // bits:  0..11*..0xxx..53*..xx</span>
<span class="udiff-line-modified-added">+   if (exponent + kDoubleSignificandSize &gt; 64) {</span>
<span class="udiff-line-modified-added">+     // The exponent must be &gt; 11.</span>
<span class="udiff-line-modified-added">+     //</span>
<span class="udiff-line-modified-added">+     // We know that v = significand * 2^exponent.</span>
<span class="udiff-line-modified-added">+     // And the exponent &gt; 11.</span>
<span class="udiff-line-modified-added">+     // We simplify the task by dividing v by 10^17.</span>
<span class="udiff-line-modified-added">+     // The quotient delivers the first digits, and the remainder fits into a 64</span>
<span class="udiff-line-modified-added">+     // bit number.</span>
<span class="udiff-line-modified-added">+     // Dividing by 10^17 is equivalent to dividing by 5^17*2^17.</span>
<span class="udiff-line-modified-added">+     const uint64_t kFive17 = UINT64_2PART_C(0xB1, A2BC2EC5);  // 5^17</span>
<span class="udiff-line-modified-added">+     uint64_t divisor = kFive17;</span>
<span class="udiff-line-modified-added">+     int divisor_power = 17;</span>
<span class="udiff-line-modified-added">+     uint64_t dividend = significand;</span>
<span class="udiff-line-modified-added">+     uint32_t quotient;</span>
<span class="udiff-line-modified-added">+     uint64_t remainder;</span>
<span class="udiff-line-modified-added">+     // Let v = f * 2^e with f == significand and e == exponent.</span>
<span class="udiff-line-modified-added">+     // Then need q (quotient) and r (remainder) as follows:</span>
<span class="udiff-line-modified-added">+     //   v            = q * 10^17       + r</span>
<span class="udiff-line-modified-added">+     //   f * 2^e      = q * 10^17       + r</span>
<span class="udiff-line-modified-added">+     //   f * 2^e      = q * 5^17 * 2^17 + r</span>
<span class="udiff-line-modified-added">+     // If e &gt; 17 then</span>
<span class="udiff-line-modified-added">+     //   f * 2^(e-17) = q * 5^17        + r/2^17</span>
<span class="udiff-line-modified-added">+     // else</span>
<span class="udiff-line-modified-added">+     //   f  = q * 5^17 * 2^(17-e) + r/2^e</span>
<span class="udiff-line-modified-added">+     if (exponent &gt; divisor_power) {</span>
<span class="udiff-line-modified-added">+       // We only allow exponents of up to 20 and therefore (17 - e) &lt;= 3</span>
<span class="udiff-line-modified-added">+       dividend &lt;&lt;= exponent - divisor_power;</span>
<span class="udiff-line-modified-added">+       quotient = static_cast&lt;uint32_t&gt;(dividend / divisor);</span>
<span class="udiff-line-modified-added">+       remainder = (dividend % divisor) &lt;&lt; divisor_power;</span>
<span class="udiff-line-modified-added">+     } else {</span>
<span class="udiff-line-modified-added">+       divisor &lt;&lt;= divisor_power - exponent;</span>
<span class="udiff-line-modified-added">+       quotient = static_cast&lt;uint32_t&gt;(dividend / divisor);</span>
<span class="udiff-line-modified-added">+       remainder = (dividend % divisor) &lt;&lt; exponent;</span>
<span class="udiff-line-modified-added">+     }</span>
<span class="udiff-line-modified-added">+     FillDigits32(quotient, buffer, length);</span>
      FillDigits64FixedLength(remainder, buffer, length);
<span class="udiff-line-modified-removed">-             *decimal_point = *length;</span>
<span class="udiff-line-modified-removed">-         } else if (exponent &gt;= 0) {</span>
<span class="udiff-line-modified-removed">-             // 0 &lt;= exponent &lt;= 11</span>
<span class="udiff-line-modified-removed">-             significand &lt;&lt;= exponent;</span>
<span class="udiff-line-modified-removed">-             FillDigits64(significand, buffer, length);</span>
<span class="udiff-line-modified-removed">-             *decimal_point = *length;</span>
<span class="udiff-line-modified-removed">-         } else if (exponent &gt; -kDoubleSignificandSize) {</span>
<span class="udiff-line-modified-removed">-             // We have to cut the number.</span>
<span class="udiff-line-modified-removed">-             uint64_t integrals = significand &gt;&gt; -exponent;</span>
<span class="udiff-line-modified-removed">-             uint64_t fractionals = significand - (integrals &lt;&lt; -exponent);</span>
<span class="udiff-line-modified-removed">-             if (integrals &gt; kMaxUInt32) {</span>
<span class="udiff-line-modified-removed">-                 FillDigits64(integrals, buffer, length);</span>
<span class="udiff-line-modified-removed">-             } else {</span>
<span class="udiff-line-modified-removed">-                 FillDigits32(static_cast&lt;uint32_t&gt;(integrals), buffer, length);</span>
<span class="udiff-line-modified-removed">-             }</span>
<span class="udiff-line-modified-removed">-             *decimal_point = *length;</span>
<span class="udiff-line-modified-removed">-             FillFractionals(fractionals, exponent, fractional_count,</span>
<span class="udiff-line-modified-removed">-                             buffer, length, decimal_point);</span>
<span class="udiff-line-modified-removed">-         } else if (exponent &lt; -128) {</span>
<span class="udiff-line-modified-removed">-             // This configuration (with at most 20 digits) means that all digits must be</span>
<span class="udiff-line-modified-removed">-             // 0.</span>
<span class="udiff-line-modified-removed">-             ASSERT(fractional_count &lt;= 20);</span>
<span class="udiff-line-modified-removed">-             buffer[0] = &#39;\0&#39;;</span>
<span class="udiff-line-modified-removed">-             *length = 0;</span>
<span class="udiff-line-modified-removed">-             *decimal_point = -fractional_count;</span>
<span class="udiff-line-modified-removed">-         } else {</span>
<span class="udiff-line-modified-removed">-             *decimal_point = 0;</span>
<span class="udiff-line-modified-removed">-             FillFractionals(significand, exponent, fractional_count,</span>
<span class="udiff-line-modified-removed">-                             buffer, length, decimal_point);</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-removed">-         TrimZeros(buffer, length, decimal_point);</span>
<span class="udiff-line-modified-removed">-         buffer[*length] = &#39;\0&#39;;</span>
<span class="udiff-line-modified-removed">-         if ((*length) == 0) {</span>
<span class="udiff-line-modified-removed">-             // The string is empty and the decimal_point thus has no importance. Mimick</span>
<span class="udiff-line-modified-removed">-             // Gay&#39;s dtoa and and set it to -fractional_count.</span>
<span class="udiff-line-modified-removed">-             *decimal_point = -fractional_count;</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-removed">-         return true;</span>
<span class="udiff-line-modified-added">+     *decimal_point = *length;</span>
<span class="udiff-line-modified-added">+   } else if (exponent &gt;= 0) {</span>
<span class="udiff-line-modified-added">+     // 0 &lt;= exponent &lt;= 11</span>
<span class="udiff-line-modified-added">+     significand &lt;&lt;= exponent;</span>
<span class="udiff-line-modified-added">+     FillDigits64(significand, buffer, length);</span>
<span class="udiff-line-modified-added">+     *decimal_point = *length;</span>
<span class="udiff-line-modified-added">+   } else if (exponent &gt; -kDoubleSignificandSize) {</span>
<span class="udiff-line-modified-added">+     // We have to cut the number.</span>
<span class="udiff-line-modified-added">+     uint64_t integrals = significand &gt;&gt; -exponent;</span>
<span class="udiff-line-modified-added">+     uint64_t fractionals = significand - (integrals &lt;&lt; -exponent);</span>
<span class="udiff-line-modified-added">+     if (integrals &gt; kMaxUInt32) {</span>
<span class="udiff-line-modified-added">+       FillDigits64(integrals, buffer, length);</span>
<span class="udiff-line-modified-added">+     } else {</span>
<span class="udiff-line-modified-added">+       FillDigits32(static_cast&lt;uint32_t&gt;(integrals), buffer, length);</span>
<span class="udiff-line-modified-added">+     }</span>
<span class="udiff-line-modified-added">+     *decimal_point = *length;</span>
<span class="udiff-line-modified-added">+     FillFractionals(fractionals, exponent, fractional_count,</span>
<span class="udiff-line-modified-added">+                     buffer, length, decimal_point);</span>
<span class="udiff-line-modified-added">+   } else if (exponent &lt; -128) {</span>
<span class="udiff-line-modified-added">+     // This configuration (with at most 20 digits) means that all digits must be</span>
<span class="udiff-line-modified-added">+     // 0.</span>
<span class="udiff-line-modified-added">+     ASSERT(fractional_count &lt;= 20);</span>
<span class="udiff-line-modified-added">+     buffer[0] = &#39;\0&#39;;</span>
<span class="udiff-line-modified-added">+     *length = 0;</span>
<span class="udiff-line-modified-added">+     *decimal_point = -fractional_count;</span>
<span class="udiff-line-modified-added">+   } else {</span>
<span class="udiff-line-modified-added">+     *decimal_point = 0;</span>
<span class="udiff-line-modified-added">+     FillFractionals(significand, exponent, fractional_count,</span>
<span class="udiff-line-modified-added">+                     buffer, length, decimal_point);</span>
<span class="udiff-line-modified-added">+   }</span>
<span class="udiff-line-modified-added">+   TrimZeros(buffer, length, decimal_point);</span>
<span class="udiff-line-modified-added">+   buffer[*length] = &#39;\0&#39;;</span>
<span class="udiff-line-modified-added">+   if ((*length) == 0) {</span>
<span class="udiff-line-modified-added">+     // The string is empty and the decimal_point thus has no importance. Mimick</span>
<span class="udiff-line-modified-added">+     // Gay&#39;s dtoa and and set it to -fractional_count.</span>
<span class="udiff-line-modified-added">+     *decimal_point = -fractional_count;</span>
<span class="udiff-line-modified-added">+   }</span>
<span class="udiff-line-modified-added">+   return true;</span>
  }
<span class="udiff-line-modified-removed">-     </span>
<span class="udiff-line-modified-added">+ </span>
  }  // namespace double_conversion
<span class="udiff-line-modified-removed">- } // namespace WTF</span>
<span class="udiff-line-modified-added">+ }  // namespace WTF</span>
</pre>
<center><a href="fast-dtoa.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="fixed-dtoa.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>