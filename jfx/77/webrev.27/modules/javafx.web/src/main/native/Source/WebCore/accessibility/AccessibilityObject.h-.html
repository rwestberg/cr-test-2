<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WebCore/accessibility/AccessibilityObject.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2008, 2009, 2011 Apple Inc. All rights reserved.
   3  * Copyright (C) 2008 Nuanti Ltd.
   4  *
   5  * Redistribution and use in source and binary forms, with or without
   6  * modification, are permitted provided that the following conditions
   7  * are met:
   8  *
   9  * 1.  Redistributions of source code must retain the above copyright
  10  *     notice, this list of conditions and the following disclaimer.
  11  * 2.  Redistributions in binary form must reproduce the above copyright
  12  *     notice, this list of conditions and the following disclaimer in the
  13  *     documentation and/or other materials provided with the distribution.
  14  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
  15  *     its contributors may be used to endorse or promote products derived
  16  *     from this software without specific prior written permission.
  17  *
  18  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
  19  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  20  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  21  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  22  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  23  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  24  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  25  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  26  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  27  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  28  */
  29 
  30 #pragma once
  31 
  32 #include &quot;AccessibilityObjectInterface.h&quot;
  33 #include &quot;FloatQuad.h&quot;
  34 #include &quot;HTMLTextFormControlElement.h&quot;
  35 #include &quot;LayoutRect.h&quot;
  36 #include &quot;Path.h&quot;
  37 #include &quot;Range.h&quot;
  38 #include &quot;TextIteratorBehavior.h&quot;
  39 #include &quot;VisiblePosition.h&quot;
  40 #include &quot;VisibleSelection.h&quot;
  41 #include &lt;wtf/Forward.h&gt;
  42 #include &lt;wtf/Function.h&gt;
  43 #include &lt;wtf/RefPtr.h&gt;
  44 #include &lt;wtf/Vector.h&gt;
  45 
  46 #if PLATFORM(COCOA)
  47 #include &lt;wtf/RetainPtr.h&gt;
  48 #elif PLATFORM(WIN)
  49 #include &quot;AccessibilityObjectWrapperWin.h&quot;
  50 #include &quot;COMPtr.h&quot;
  51 #endif
  52 
  53 #if PLATFORM(GTK)
  54 #include &lt;wtf/glib/GRefPtr.h&gt;
  55 #endif
  56 
  57 #if PLATFORM(COCOA)
  58 
  59 typedef struct _NSRange NSRange;
  60 
  61 OBJC_CLASS NSArray;
  62 OBJC_CLASS NSAttributedString;
  63 OBJC_CLASS NSData;
  64 OBJC_CLASS NSMutableAttributedString;
  65 OBJC_CLASS NSString;
  66 OBJC_CLASS NSValue;
  67 OBJC_CLASS NSView;
  68 OBJC_CLASS WebAccessibilityObjectWrapper;
  69 
  70 typedef WebAccessibilityObjectWrapper AccessibilityObjectWrapper;
  71 
  72 #elif PLATFORM(GTK)
  73 typedef struct _WebKitAccessible WebKitAccessible;
  74 typedef struct _WebKitAccessible AccessibilityObjectWrapper;
  75 #elif PLATFORM(WPE)
  76 class AccessibilityObjectWrapper : public RefCounted&lt;AccessibilityObjectWrapper&gt; { };
  77 #else
  78 class AccessibilityObjectWrapper;
  79 #endif
  80 
  81 namespace WebCore {
  82 
  83 class AccessibilityObject;
  84 class AXObjectCache;
  85 class Element;
  86 class Frame;
  87 class FrameView;
  88 class IntPoint;
  89 class IntSize;
  90 class Node;
  91 class Page;
  92 class RenderObject;
  93 class ScrollableArea;
  94 class ScrollView;
  95 class Widget;
  96 
  97 enum class AccessibilityTextSource {
  98     Alternative,
  99     Children,
 100     Summary,
 101     Help,
 102     Visible,
 103     TitleTag,
 104     Placeholder,
 105     LabelByElement,
 106     Title,
 107     Subtitle,
 108     Action,
 109 };
 110 
 111 enum class AccessibilityEventType {
 112     ContextMenu,
 113     Click,
 114     Decrement,
 115     Dismiss,
 116     Focus,
 117     Increment,
 118     ScrollIntoView,
 119     Select,
 120 };
 121 
 122 struct AccessibilityText {
 123     String text;
 124     AccessibilityTextSource textSource;
 125     Vector&lt;RefPtr&lt;AccessibilityObject&gt;&gt; textElements;
 126 
 127     AccessibilityText(const String&amp; t, const AccessibilityTextSource&amp; s)
 128         : text(t)
 129         , textSource(s)
 130     { }
 131 
 132     AccessibilityText(const String&amp; t, const AccessibilityTextSource&amp; s, Vector&lt;RefPtr&lt;AccessibilityObject&gt;&gt; elements)
 133         : text(t)
 134         , textSource(s)
 135         , textElements(WTFMove(elements))
 136     { }
 137 
 138     AccessibilityText(const String&amp; t, const AccessibilityTextSource&amp; s, RefPtr&lt;AccessibilityObject&gt;&amp;&amp; element)
 139         : text(t)
 140         , textSource(s)
 141     {
 142         textElements.append(WTFMove(element));
 143     }
 144 };
 145 
 146 struct AccessibilityTextUnderElementMode {
 147     enum ChildrenInclusion {
 148         TextUnderElementModeSkipIgnoredChildren,
 149         TextUnderElementModeIncludeAllChildren,
 150         TextUnderElementModeIncludeNameFromContentsChildren, // This corresponds to ARIA concept: nameFrom
 151     };
 152 
 153     ChildrenInclusion childrenInclusion;
 154     bool includeFocusableContent;
 155     Node* ignoredChildNode;
 156 
 157     AccessibilityTextUnderElementMode(ChildrenInclusion c = TextUnderElementModeSkipIgnoredChildren, bool i = false, Node* ignored = nullptr)
 158         : childrenInclusion(c)
 159         , includeFocusableContent(i)
 160         , ignoredChildNode(ignored)
 161     { }
 162 };
 163 
 164 // Use this struct to store the isIgnored data that depends on the parents, so that in addChildren()
 165 // we avoid going up the parent chain for each element while traversing the tree with useful information already.
 166 struct AccessibilityIsIgnoredFromParentData {
 167     AccessibilityObject* parent { nullptr };
 168     bool isAXHidden { false };
 169     bool isPresentationalChildOfAriaRole { false };
 170     bool isDescendantOfBarrenParent { false };
 171 
 172     AccessibilityIsIgnoredFromParentData(AccessibilityObject* parent = nullptr)
 173         : parent(parent)
 174     { }
 175 
 176     bool isNull() const { return !parent; }
 177 };
 178 
 179 enum class AccessibilityOrientation {
 180     Vertical,
 181     Horizontal,
 182     Undefined,
 183 };
 184 
 185 enum class AccessibilityObjectInclusion {
 186     IncludeObject,
 187     IgnoreObject,
 188     DefaultBehavior,
 189 };
 190 
 191 enum class AccessibilityButtonState {
 192     Off = 0,
 193     On,
 194     Mixed,
 195 };
 196 
 197 enum class AccessibilitySortDirection {
 198     None,
 199     Ascending,
 200     Descending,
 201     Other,
 202     Invalid,
 203 };
 204 
 205 enum class AccessibilitySearchDirection {
 206     Next = 1,
 207     Previous,
 208 };
 209 
 210 enum class AccessibilitySearchKey {
 211     AnyType = 1,
 212     Article,
 213     BlockquoteSameLevel,
 214     Blockquote,
 215     BoldFont,
 216     Button,
 217     CheckBox,
 218     Control,
 219     DifferentType,
 220     FontChange,
 221     FontColorChange,
 222     Frame,
 223     Graphic,
 224     HeadingLevel1,
 225     HeadingLevel2,
 226     HeadingLevel3,
 227     HeadingLevel4,
 228     HeadingLevel5,
 229     HeadingLevel6,
 230     HeadingSameLevel,
 231     Heading,
 232     Highlighted,
 233     ItalicFont,
 234     Landmark,
 235     Link,
 236     List,
 237     LiveRegion,
 238     MisspelledWord,
 239     Outline,
 240     PlainText,
 241     RadioGroup,
 242     SameType,
 243     StaticText,
 244     StyleChange,
 245     TableSameLevel,
 246     Table,
 247     TextField,
 248     Underline,
 249     UnvisitedLink,
 250     VisitedLink,
 251 };
 252 
 253 enum class AccessibilityVisiblePositionForBounds {
 254     First,
 255     Last,
 256 };
 257 
 258 struct AccessibilitySearchCriteria {
 259     AccessibilityObject* startObject;
 260     AccessibilitySearchDirection searchDirection;
 261     Vector&lt;AccessibilitySearchKey&gt; searchKeys;
 262     String searchText;
 263     unsigned resultsLimit;
 264     bool visibleOnly;
 265     bool immediateDescendantsOnly;
 266 
 267     AccessibilitySearchCriteria(AccessibilityObject* startObject, AccessibilitySearchDirection searchDirection, String searchText, unsigned resultsLimit, bool visibleOnly, bool immediateDescendantsOnly)
 268         : startObject(startObject)
 269         , searchDirection(searchDirection)
 270         , searchText(searchText)
 271         , resultsLimit(resultsLimit)
 272         , visibleOnly(visibleOnly)
 273         , immediateDescendantsOnly(immediateDescendantsOnly)
 274     { }
 275 };
 276 
 277 enum class AccessibilityDetachmentType { CacheDestroyed, ElementDestroyed };
 278 
 279 struct VisiblePositionRange {
 280 
 281     VisiblePosition start;
 282     VisiblePosition end;
 283 
 284     VisiblePositionRange() {}
 285 
 286     VisiblePositionRange(const VisiblePosition&amp; s, const VisiblePosition&amp; e)
 287         : start(s)
 288         , end(e)
 289     { }
 290 
 291     VisiblePositionRange(const VisibleSelection&amp; selection)
 292         : start(selection.start())
 293         , end(selection.end())
 294     { }
 295 
 296     bool isNull() const { return start.isNull() || end.isNull(); }
 297 };
 298 
 299 struct PlainTextRange {
 300 
 301     unsigned start { 0 };
 302     unsigned length { 0 };
 303 
 304     PlainTextRange() = default;
 305 
 306     PlainTextRange(unsigned s, unsigned l)
 307         : start(s)
 308         , length(l)
 309     { }
 310 
 311     bool isNull() const { return !start &amp;&amp; !length; }
 312 };
 313 
 314 enum class AccessibilitySelectTextActivity {
 315     FindAndReplace,
 316     FindAndSelect,
 317     FindAndCapitalize,
 318     FindAndLowercase,
 319     FindAndUppercase
 320 };
 321 
 322 enum class AccessibilitySelectTextAmbiguityResolution {
 323     ClosestAfter,
 324     ClosestBefore,
 325     ClosestTo
 326 };
 327 
 328 struct AccessibilitySelectTextCriteria {
 329     AccessibilitySelectTextActivity activity;
 330     AccessibilitySelectTextAmbiguityResolution ambiguityResolution;
 331     String replacementString;
 332     Vector&lt;String&gt; searchStrings;
 333 
 334     AccessibilitySelectTextCriteria(AccessibilitySelectTextActivity activity, AccessibilitySelectTextAmbiguityResolution ambiguityResolution, const String&amp; replacementString)
 335         : activity(activity)
 336         , ambiguityResolution(ambiguityResolution)
 337         , replacementString(replacementString)
 338     { }
 339 };
 340 
 341 enum class AccessibilityMathScriptObjectType { Subscript, Superscript };
 342 enum class AccessibilityMathMultiscriptObjectType { PreSubscript, PreSuperscript, PostSubscript, PostSuperscript };
 343 
 344 enum class AccessibilityCurrentState { False, True, Page, Step, Location, Date, Time };
 345 
 346 bool nodeHasPresentationRole(Node*);
 347 
 348 class AccessibilityObject : public RefCounted&lt;AccessibilityObject&gt;, public AccessibilityObjectInterface {
 349 protected:
 350     AccessibilityObject() = default;
 351 
 352 public:
 353     virtual ~AccessibilityObject();
 354 
 355     // After constructing an AccessibilityObject, it must be given a
 356     // unique ID, then added to AXObjectCache, and finally init() must
 357     // be called last.
 358     void setAXObjectID(AXID axObjectID) { m_id = axObjectID; }
 359     virtual void init() { }
 360 
 361     // When the corresponding WebCore object that this AccessibilityObject
 362     // wraps is deleted, it must be detached.
 363     virtual void detach(AccessibilityDetachmentType, AXObjectCache* cache = nullptr);
 364     virtual bool isDetached() const;
 365 
 366     typedef Vector&lt;RefPtr&lt;AccessibilityObject&gt;&gt; AccessibilityChildrenVector;
 367 
 368     virtual bool isAccessibilityNodeObject() const { return false; }
 369     virtual bool isAccessibilityRenderObject() const { return false; }
 370     virtual bool isAccessibilityScrollbar() const { return false; }
 371     virtual bool isAccessibilityScrollView() const { return false; }
 372     virtual bool isAccessibilitySVGRoot() const { return false; }
 373     virtual bool isAccessibilitySVGElement() const { return false; }
 374 
 375     bool accessibilityObjectContainsText(String *) const;
 376 
 377     virtual bool isAttachmentElement() const { return false; }
 378     virtual bool isHeading() const { return false; }
 379     virtual bool isLink() const { return false; }
 380     virtual bool isImage() const { return false; }
 381     virtual bool isImageMap() const { return roleValue() == AccessibilityRole::ImageMap; }
 382     virtual bool isNativeImage() const { return false; }
 383     virtual bool isImageButton() const { return false; }
 384     virtual bool isPasswordField() const { return false; }
 385     bool isContainedByPasswordField() const;
 386     virtual AccessibilityObject* passwordFieldOrContainingPasswordField() { return nullptr; }
 387     virtual bool isNativeTextControl() const { return false; }
 388     virtual bool isSearchField() const { return false; }
 389     bool isWebArea() const { return roleValue() == AccessibilityRole::WebArea; }
 390     virtual bool isCheckbox() const { return roleValue() == AccessibilityRole::CheckBox; }
 391     virtual bool isRadioButton() const { return roleValue() == AccessibilityRole::RadioButton; }
 392     virtual bool isNativeListBox() const { return false; }
 393     bool isListBox() const { return roleValue() == AccessibilityRole::ListBox; }
 394     virtual bool isListBoxOption() const { return false; }
 395     virtual bool isAttachment() const { return false; }
 396     virtual bool isMediaTimeline() const { return false; }
 397     virtual bool isMenuRelated() const { return false; }
 398     virtual bool isMenu() const { return false; }
 399     virtual bool isMenuBar() const { return false; }
 400     virtual bool isMenuButton() const { return false; }
 401     virtual bool isMenuItem() const { return false; }
 402     virtual bool isFileUploadButton() const { return false; }
 403     virtual bool isInputImage() const { return false; }
 404     virtual bool isProgressIndicator() const { return false; }
 405     virtual bool isSlider() const { return false; }
 406     virtual bool isSliderThumb() const { return false; }
 407     virtual bool isInputSlider() const { return false; }
 408     virtual bool isControl() const { return false; }
 409     virtual bool isLabel() const { return false; }
 410     virtual bool isList() const { return false; }
 411     virtual bool isTable() const { return false; }
 412     virtual bool isDataTable() const { return false; }
 413     virtual bool isTableRow() const { return false; }
 414     virtual bool isTableColumn() const { return false; }
 415     virtual bool isTableCell() const { return false; }
 416     virtual bool isFieldset() const { return false; }
 417     virtual bool isGroup() const { return false; }
 418     virtual bool isARIATreeGridRow() const { return false; }
 419     virtual bool isImageMapLink() const { return false; }
 420     virtual bool isMenuList() const { return false; }
 421     virtual bool isMenuListPopup() const { return false; }
 422     virtual bool isMenuListOption() const { return false; }
 423     virtual bool isSpinButton() const { return roleValue() == AccessibilityRole::SpinButton; }
 424     virtual bool isNativeSpinButton() const { return false; }
 425     virtual bool isSpinButtonPart() const { return false; }
 426     virtual bool isMockObject() const { return false; }
 427     virtual bool isMediaControlLabel() const { return false; }
 428     virtual bool isMediaObject() const { return false; }
 429     bool isSwitch() const { return roleValue() == AccessibilityRole::Switch; }
 430     bool isToggleButton() const { return roleValue() == AccessibilityRole::ToggleButton; }
 431     bool isTextControl() const;
 432     bool isARIATextControl() const;
 433     bool isNonNativeTextControl() const;
 434     bool isTabList() const { return roleValue() == AccessibilityRole::TabList; }
 435     bool isTabItem() const { return roleValue() == AccessibilityRole::Tab; }
 436     bool isRadioGroup() const { return roleValue() == AccessibilityRole::RadioGroup; }
 437     bool isComboBox() const { return roleValue() == AccessibilityRole::ComboBox; }
 438     bool isTree() const { return roleValue() == AccessibilityRole::Tree; }
 439     bool isTreeGrid() const { return roleValue() == AccessibilityRole::TreeGrid; }
 440     bool isTreeItem() const { return roleValue() == AccessibilityRole::TreeItem; }
 441     bool isScrollbar() const { return roleValue() == AccessibilityRole::ScrollBar; }
 442     bool isButton() const;
 443     bool isListItem() const { return roleValue() == AccessibilityRole::ListItem; }
 444     bool isCheckboxOrRadio() const { return isCheckbox() || isRadioButton(); }
 445     bool isScrollView() const { return roleValue() == AccessibilityRole::ScrollArea; }
 446     bool isCanvas() const { return roleValue() == AccessibilityRole::Canvas; }
 447     bool isPopUpButton() const { return roleValue() == AccessibilityRole::PopUpButton; }
 448     bool isBlockquote() const;
 449     bool isLandmark() const;
 450     bool isColorWell() const { return roleValue() == AccessibilityRole::ColorWell; }
 451     bool isRangeControl() const;
 452     bool isMeter() const;
 453     bool isSplitter() const { return roleValue() == AccessibilityRole::Splitter; }
 454     bool isToolbar() const { return roleValue() == AccessibilityRole::Toolbar; }
 455     bool isStyleFormatGroup() const;
 456     bool isSubscriptStyleGroup() const;
 457     bool isSuperscriptStyleGroup() const;
 458     bool isFigureElement() const;
 459     bool isSummary() const { return roleValue() == AccessibilityRole::Summary; }
 460     bool isOutput() const;
 461 
 462     virtual bool isChecked() const { return false; }
 463     virtual bool isEnabled() const { return false; }
 464     virtual bool isSelected() const { return false; }
 465     virtual bool isFocused() const { return false; }
 466     virtual bool isHovered() const { return false; }
 467     virtual bool isIndeterminate() const { return false; }
 468     virtual bool isLoaded() const { return false; }
 469     virtual bool isMultiSelectable() const { return false; }
 470     virtual bool isOffScreen() const { return false; }
 471     virtual bool isPressed() const { return false; }
 472     virtual bool isUnvisited() const { return false; }
 473     virtual bool isVisited() const { return false; }
 474     virtual bool isRequired() const { return false; }
 475     virtual bool supportsRequiredAttribute() const { return false; }
 476     virtual bool isLinked() const { return false; }
 477     virtual bool isExpanded() const;
 478     virtual bool isVisible() const { return true; }
 479     virtual bool isCollapsed() const { return false; }
 480     virtual void setIsExpanded(bool) { }
 481 
 482     // In a multi-select list, many items can be selected but only one is active at a time.
 483     virtual bool isSelectedOptionActive() const { return false; }
 484 
 485     virtual bool hasBoldFont() const { return false; }
 486     virtual bool hasItalicFont() const { return false; }
 487     bool hasMisspelling() const;
 488     virtual bool hasPlainText() const { return false; }
 489     virtual bool hasSameFont(RenderObject*) const { return false; }
 490     virtual bool hasSameFontColor(RenderObject*) const { return false; }
 491     virtual bool hasSameStyle(RenderObject*) const { return false; }
 492     bool isStaticText() const { return roleValue() == AccessibilityRole::StaticText; }
 493     virtual bool hasUnderline() const { return false; }
 494     bool hasHighlighting() const;
 495 
 496     bool supportsDatetimeAttribute() const;
 497     const AtomicString&amp; datetimeAttributeValue() const;
 498 
 499     virtual bool canSetFocusAttribute() const { return false; }
 500     virtual bool canSetTextRangeAttributes() const { return false; }
 501     virtual bool canSetValueAttribute() const { return false; }
 502     virtual bool canSetNumericValue() const { return false; }
 503     virtual bool canSetSelectedAttribute() const { return false; }
 504     virtual bool canSetSelectedChildrenAttribute() const { return false; }
 505     virtual bool canSetExpandedAttribute() const { return false; }
 506 
 507     virtual Element* element() const;
 508     virtual Node* node() const { return nullptr; }
 509     virtual RenderObject* renderer() const { return nullptr; }
 510     virtual bool accessibilityIsIgnored() const;
 511     virtual AccessibilityObjectInclusion defaultObjectInclusion() const;
 512     bool accessibilityIsIgnoredByDefault() const;
 513 
 514     bool isShowingValidationMessage() const;
 515     String validationMessage() const;
 516 
 517     unsigned blockquoteLevel() const;
 518     virtual int headingLevel() const { return 0; }
 519     virtual int tableLevel() const { return 0; }
 520     virtual AccessibilityButtonState checkboxOrRadioValue() const;
 521     virtual String valueDescription() const { return String(); }
 522     virtual float valueForRange() const { return 0.0f; }
 523     virtual float maxValueForRange() const { return 0.0f; }
 524     virtual float minValueForRange() const { return 0.0f; }
 525     virtual float stepValueForRange() const { return 0.0f; }
 526     virtual AccessibilityObject* selectedRadioButton() { return nullptr; }
 527     virtual AccessibilityObject* selectedTabItem() { return nullptr; }
 528     AccessibilityObject* selectedListItem();
 529     virtual int layoutCount() const { return 0; }
 530     virtual double estimatedLoadingProgress() const { return 0; }
 531     static bool isARIAControl(AccessibilityRole);
 532     static bool isARIAInput(AccessibilityRole);
 533 
 534     virtual bool supportsARIAOwns() const { return false; }
 535     bool isActiveDescendantOfFocusedContainer() const;
 536     void ariaActiveDescendantReferencingElements(AccessibilityChildrenVector&amp;) const;
 537     void ariaControlsElements(AccessibilityChildrenVector&amp;) const;
 538     void ariaControlsReferencingElements(AccessibilityChildrenVector&amp;) const;
 539     void ariaDescribedByElements(AccessibilityChildrenVector&amp;) const;
 540     void ariaDescribedByReferencingElements(AccessibilityChildrenVector&amp;) const;
 541     void ariaDetailsElements(AccessibilityChildrenVector&amp;) const;
 542     void ariaDetailsReferencingElements(AccessibilityChildrenVector&amp;) const;
 543     void ariaErrorMessageElements(AccessibilityChildrenVector&amp;) const;
 544     void ariaErrorMessageReferencingElements(AccessibilityChildrenVector&amp;) const;
 545     void ariaFlowToElements(AccessibilityChildrenVector&amp;) const;
 546     void ariaFlowToReferencingElements(AccessibilityChildrenVector&amp;) const;
 547     void ariaLabelledByElements(AccessibilityChildrenVector&amp;) const;
 548     void ariaLabelledByReferencingElements(AccessibilityChildrenVector&amp;) const;
 549     void ariaOwnsElements(AccessibilityChildrenVector&amp;) const;
 550     void ariaOwnsReferencingElements(AccessibilityChildrenVector&amp;) const;
 551 
 552     virtual bool hasPopup() const { return false; }
 553     String hasPopupValue() const;
 554     bool supportsHasPopup() const;
 555     bool pressedIsPresent() const;
 556     bool ariaIsMultiline() const;
 557     String invalidStatus() const;
 558     bool supportsPressed() const;
 559     bool supportsExpanded() const;
 560     bool supportsChecked() const;
 561     AccessibilitySortDirection sortDirection() const;
 562     virtual bool canvasHasFallbackContent() const { return false; }
 563     bool supportsRangeValue() const;
 564     const AtomicString&amp; identifierAttribute() const;
 565     const AtomicString&amp; linkRelValue() const;
 566     void classList(Vector&lt;String&gt;&amp;) const;
 567     virtual String roleDescription() const;
 568     AccessibilityCurrentState currentState() const;
 569     String currentValue() const;
 570     bool supportsCurrent() const;
 571     const String keyShortcutsValue() const;
 572 
 573     // This function checks if the object should be ignored when there&#39;s a modal dialog displayed.
 574     bool ignoredFromModalPresence() const;
 575     bool isModalDescendant(Node*) const;
 576     bool isModalNode() const;
 577 
 578     bool supportsSetSize() const;
 579     bool supportsPosInSet() const;
 580     int setSize() const;
 581     int posInSet() const;
 582 
 583     // ARIA drag and drop
 584     virtual bool supportsARIADropping() const { return false; }
 585     virtual bool supportsARIADragging() const { return false; }
 586     virtual bool isARIAGrabbed() { return false; }
 587     virtual void setARIAGrabbed(bool) { }
 588     virtual Vector&lt;String&gt; determineARIADropEffects() { return { }; }
 589 
 590     // Called on the root AX object to return the deepest available element.
 591     virtual AccessibilityObject* accessibilityHitTest(const IntPoint&amp;) const { return nullptr; }
 592     // Called on the AX object after the render tree determines which is the right AccessibilityRenderObject.
 593     virtual AccessibilityObject* elementAccessibilityHitTest(const IntPoint&amp;) const;
 594 
 595     virtual AccessibilityObject* focusedUIElement() const;
 596 
 597     virtual AccessibilityObject* firstChild() const { return nullptr; }
 598     virtual AccessibilityObject* lastChild() const { return nullptr; }
 599     virtual AccessibilityObject* previousSibling() const { return nullptr; }
 600     virtual AccessibilityObject* nextSibling() const { return nullptr; }
 601     virtual AccessibilityObject* nextSiblingUnignored(int limit) const;
 602     virtual AccessibilityObject* previousSiblingUnignored(int limit) const;
 603     virtual AccessibilityObject* parentObject() const = 0;
 604     virtual AccessibilityObject* parentObjectUnignored() const;
 605     virtual AccessibilityObject* parentObjectIfExists() const { return nullptr; }
 606     static AccessibilityObject* firstAccessibleObjectFromNode(const Node*);
 607     void findMatchingObjects(AccessibilitySearchCriteria*, AccessibilityChildrenVector&amp;);
 608     virtual bool isDescendantOfBarrenParent() const { return false; }
 609 
 610     bool isDescendantOfRole(AccessibilityRole) const;
 611 
 612     // Text selection
 613     RefPtr&lt;Range&gt; rangeOfStringClosestToRangeInDirection(Range*, AccessibilitySearchDirection, Vector&lt;String&gt;&amp;) const;
 614     RefPtr&lt;Range&gt; selectionRange() const;
 615     String selectText(AccessibilitySelectTextCriteria*);
 616 
 617     virtual AccessibilityObject* observableObject() const { return nullptr; }
 618     virtual void linkedUIElements(AccessibilityChildrenVector&amp;) const { }
 619     virtual AccessibilityObject* titleUIElement() const { return nullptr; }
 620     virtual bool exposesTitleUIElement() const { return true; }
 621     virtual AccessibilityObject* correspondingLabelForControlElement() const { return nullptr; }
 622     virtual AccessibilityObject* correspondingControlForLabelElement() const { return nullptr; }
 623     virtual AccessibilityObject* scrollBar(AccessibilityOrientation) { return nullptr; }
 624 
 625     virtual AccessibilityRole ariaRoleAttribute() const { return AccessibilityRole::Unknown; }
 626     virtual bool isPresentationalChildOfAriaRole() const { return false; }
 627     virtual bool ariaRoleHasPresentationalChildren() const { return false; }
 628     virtual bool inheritsPresentationalRole() const { return false; }
 629 
 630     // Accessibility Text
 631     virtual void accessibilityText(Vector&lt;AccessibilityText&gt;&amp;) { };
 632     // A single method for getting a computed label for an AXObject. It condenses the nuances of accessibilityText. Used by Inspector.
 633     String computedLabel();
 634 
 635     // A programmatic way to set a name on an AccessibleObject.
 636     virtual void setAccessibleName(const AtomicString&amp;) { }
 637     virtual bool hasAttributesRequiredForInclusion() const;
 638 
 639     // Accessibility Text - (To be deprecated).
 640     virtual String accessibilityDescription() const { return String(); }
 641     virtual String title() const { return String(); }
 642     virtual String helpText() const { return String(); }
 643 
 644     // Methods for determining accessibility text.
 645     bool isARIAStaticText() const { return ariaRoleAttribute() == AccessibilityRole::StaticText; }
 646     virtual String stringValue() const { return String(); }
 647     virtual String textUnderElement(AccessibilityTextUnderElementMode = AccessibilityTextUnderElementMode()) const { return String(); }
 648     virtual String text() const { return String(); }
 649     virtual int textLength() const { return 0; }
 650     virtual String ariaLabeledByAttribute() const { return String(); }
 651     virtual String ariaDescribedByAttribute() const { return String(); }
 652     const String placeholderValue() const;
 653     bool accessibleNameDerivesFromContent() const;
 654 
 655     // Abbreviations
 656     virtual String expandedTextValue() const { return String(); }
 657     virtual bool supportsExpandedTextValue() const { return false; }
 658 
 659     void elementsFromAttribute(Vector&lt;Element*&gt;&amp;, const QualifiedName&amp;) const;
 660 
 661     // Only if isColorWell()
 662     virtual void colorValue(int&amp; r, int&amp; g, int&amp; b) const { r = 0; g = 0; b = 0; }
 663 
 664     virtual AccessibilityRole roleValue() const { return m_role; }
 665 
 666     virtual AXObjectCache* axObjectCache() const;
 667     AXID axObjectID() const { return m_id; }
 668 
 669     static AccessibilityObject* anchorElementForNode(Node*);
 670     static AccessibilityObject* headingElementForNode(Node*);
 671     virtual Element* anchorElement() const { return nullptr; }
 672     bool supportsPressAction() const;
 673     virtual Element* actionElement() const { return nullptr; }
 674     virtual LayoutRect boundingBoxRect() const { return LayoutRect(); }
 675     IntRect pixelSnappedBoundingBoxRect() const { return snappedIntRect(boundingBoxRect()); }
 676     virtual LayoutRect elementRect() const = 0;
 677     LayoutSize size() const { return elementRect().size(); }
 678     virtual IntPoint clickPoint();
 679     static IntRect boundingBoxForQuads(RenderObject*, const Vector&lt;FloatQuad&gt;&amp;);
 680     virtual Path elementPath() const { return Path(); }
 681     virtual bool supportsPath() const { return false; }
 682 
 683     TextIteratorBehavior textIteratorBehaviorForTextRange() const;
 684     virtual PlainTextRange selectedTextRange() const { return PlainTextRange(); }
 685     unsigned selectionStart() const { return selectedTextRange().start; }
 686     unsigned selectionEnd() const { return selectedTextRange().length; }
 687 
 688     virtual URL url() const { return URL(); }
 689     virtual VisibleSelection selection() const { return VisibleSelection(); }
 690     virtual String selectedText() const { return String(); }
 691     virtual const AtomicString&amp; accessKey() const { return nullAtom(); }
 692     const String&amp; actionVerb() const;
 693     virtual Widget* widget() const { return nullptr; }
 694     virtual Widget* widgetForAttachmentView() const { return nullptr; }
 695     Page* page() const;
 696     virtual Document* document() const;
 697     virtual FrameView* documentFrameView() const;
 698     Frame* frame() const;
 699     Frame* mainFrame() const;
 700     Document* topDocument() const;
 701     ScrollView* scrollViewAncestor() const;
 702     String language() const;
 703     // 1-based, to match the aria-level spec.
 704     virtual unsigned hierarchicalLevel() const { return 0; }
 705 
 706     virtual void setFocused(bool) { }
 707     virtual void setSelectedText(const String&amp;) { }
 708     virtual void setSelectedTextRange(const PlainTextRange&amp;) { }
 709     virtual void setValue(const String&amp;) { }
 710     virtual void setValue(float) { }
 711     virtual void setSelected(bool) { }
 712     virtual void setSelectedRows(AccessibilityChildrenVector&amp;) { }
 713 
 714     virtual void makeRangeVisible(const PlainTextRange&amp;) { }
 715     virtual bool press();
 716     bool performDefaultAction() { return press(); }
 717 
 718     virtual AccessibilityOrientation orientation() const;
 719     virtual void increment() { }
 720     virtual void decrement() { }
 721 
 722     virtual void childrenChanged() { }
 723     virtual void textChanged() { }
 724     virtual void updateAccessibilityRole() { }
 725     const AccessibilityChildrenVector&amp; children(bool updateChildrenIfNeeded = true);
 726     virtual void addChildren() { }
 727     virtual void addChild(AccessibilityObject*);
 728     virtual void insertChild(AccessibilityObject*, unsigned);
 729 
 730     virtual bool shouldIgnoreAttributeRole() const { return false; }
 731 
 732     virtual bool canHaveChildren() const { return true; }
 733     virtual bool hasChildren() const { return m_haveChildren; }
 734     virtual void updateChildrenIfNecessary();
 735     virtual void setNeedsToUpdateChildren() { }
 736     virtual void setNeedsToUpdateSubtree() { }
 737     virtual void clearChildren();
 738     virtual bool needsToUpdateChildren() const { return false; }
 739 #if PLATFORM(COCOA)
 740     virtual void detachFromParent();
 741 #else
 742     virtual void detachFromParent() { }
 743 #endif
 744     virtual bool isDetachedFromParent() { return false; }
 745 
 746     virtual bool canHaveSelectedChildren() const { return false; }
 747     virtual void selectedChildren(AccessibilityChildrenVector&amp;) { }
 748     virtual void visibleChildren(AccessibilityChildrenVector&amp;) { }
 749     virtual void tabChildren(AccessibilityChildrenVector&amp;) { }
 750     virtual bool shouldFocusActiveDescendant() const { return false; }
 751     virtual AccessibilityObject* activeDescendant() const { return nullptr; }
 752     virtual void handleActiveDescendantChanged() { }
 753     virtual void handleAriaExpandedChanged() { }
 754     bool isDescendantOfObject(const AccessibilityObject*) const;
 755     bool isAncestorOfObject(const AccessibilityObject*) const;
 756     AccessibilityObject* firstAnonymousBlockChild() const;
 757 
 758     static AccessibilityRole ariaRoleToWebCoreRole(const String&amp;);
 759     bool hasAttribute(const QualifiedName&amp;) const;
 760     const AtomicString&amp; getAttribute(const QualifiedName&amp;) const;
 761     bool hasTagName(const QualifiedName&amp;) const;
 762 
 763     bool shouldDispatchAccessibilityEvent() const;
 764     bool dispatchAccessibilityEvent(Event&amp;) const;
 765     bool dispatchAccessibilityEventWithType(AccessibilityEventType) const;
 766     bool dispatchAccessibleSetValueEvent(const String&amp;) const;
 767 
 768     virtual VisiblePositionRange visiblePositionRange() const { return VisiblePositionRange(); }
 769     virtual VisiblePositionRange visiblePositionRangeForLine(unsigned) const { return VisiblePositionRange(); }
 770 
 771     RefPtr&lt;Range&gt; elementRange() const;
 772     static bool replacedNodeNeedsCharacter(Node* replacedNode);
 773 
 774     VisiblePositionRange visiblePositionRangeForUnorderedPositions(const VisiblePosition&amp;, const VisiblePosition&amp;) const;
 775     VisiblePositionRange positionOfLeftWord(const VisiblePosition&amp;) const;
 776     VisiblePositionRange positionOfRightWord(const VisiblePosition&amp;) const;
 777     VisiblePositionRange leftLineVisiblePositionRange(const VisiblePosition&amp;) const;
 778     VisiblePositionRange rightLineVisiblePositionRange(const VisiblePosition&amp;) const;
 779     VisiblePositionRange sentenceForPosition(const VisiblePosition&amp;) const;
 780     VisiblePositionRange paragraphForPosition(const VisiblePosition&amp;) const;
 781     VisiblePositionRange styleRangeForPosition(const VisiblePosition&amp;) const;
 782     VisiblePositionRange visiblePositionRangeForRange(const PlainTextRange&amp;) const;
 783     VisiblePositionRange lineRangeForPosition(const VisiblePosition&amp;) const;
 784 
 785     RefPtr&lt;Range&gt; rangeForPlainTextRange(const PlainTextRange&amp;) const;
 786 
 787     static String stringForVisiblePositionRange(const VisiblePositionRange&amp;);
 788     String stringForRange(RefPtr&lt;Range&gt;) const;
 789     virtual IntRect boundsForVisiblePositionRange(const VisiblePositionRange&amp;) const { return IntRect(); }
 790     virtual IntRect boundsForRange(const RefPtr&lt;Range&gt;) const { return IntRect(); }
 791     int lengthForVisiblePositionRange(const VisiblePositionRange&amp;) const;
 792     virtual void setSelectedVisiblePositionRange(const VisiblePositionRange&amp;) const { }
 793 
 794     VisiblePosition visiblePositionForBounds(const IntRect&amp;, AccessibilityVisiblePositionForBounds) const;
 795     virtual VisiblePosition visiblePositionForPoint(const IntPoint&amp;) const { return VisiblePosition(); }
 796     VisiblePosition nextVisiblePosition(const VisiblePosition&amp; visiblePos) const { return visiblePos.next(); }
 797     VisiblePosition previousVisiblePosition(const VisiblePosition&amp; visiblePos) const { return visiblePos.previous(); }
 798     VisiblePosition nextWordEnd(const VisiblePosition&amp;) const;
 799     VisiblePosition previousWordStart(const VisiblePosition&amp;) const;
 800     VisiblePosition nextLineEndPosition(const VisiblePosition&amp;) const;
 801     VisiblePosition previousLineStartPosition(const VisiblePosition&amp;) const;
 802     VisiblePosition nextSentenceEndPosition(const VisiblePosition&amp;) const;
 803     VisiblePosition previousSentenceStartPosition(const VisiblePosition&amp;) const;
 804     VisiblePosition nextParagraphEndPosition(const VisiblePosition&amp;) const;
 805     VisiblePosition previousParagraphStartPosition(const VisiblePosition&amp;) const;
 806     virtual VisiblePosition visiblePositionForIndex(unsigned, bool /*lastIndexOK */) const { return VisiblePosition(); }
 807 
 808     virtual VisiblePosition visiblePositionForIndex(int) const { return VisiblePosition(); }
 809     virtual int indexForVisiblePosition(const VisiblePosition&amp;) const { return 0; }
 810 
 811     AccessibilityObject* accessibilityObjectForPosition(const VisiblePosition&amp;) const;
 812     int lineForPosition(const VisiblePosition&amp;) const;
 813     PlainTextRange plainTextRangeForVisiblePositionRange(const VisiblePositionRange&amp;) const;
 814     virtual int index(const VisiblePosition&amp;) const { return -1; }
 815 
 816     virtual void lineBreaks(Vector&lt;int&gt;&amp;) const { }
 817     virtual PlainTextRange doAXRangeForLine(unsigned) const { return PlainTextRange(); }
 818     PlainTextRange doAXRangeForPosition(const IntPoint&amp;) const;
 819     virtual PlainTextRange doAXRangeForIndex(unsigned) const { return PlainTextRange(); }
 820     PlainTextRange doAXStyleRangeForIndex(unsigned) const;
 821 
 822     virtual String doAXStringForRange(const PlainTextRange&amp;) const { return String(); }
 823     virtual IntRect doAXBoundsForRange(const PlainTextRange&amp;) const { return IntRect(); }
 824     virtual IntRect doAXBoundsForRangeUsingCharacterOffset(const PlainTextRange&amp;) const { return IntRect(); }
 825     static String listMarkerTextForNodeAndPosition(Node*, const VisiblePosition&amp;);
 826 
 827     unsigned doAXLineForIndex(unsigned);
 828 
 829     String computedRoleString() const;
 830 
 831     virtual String stringValueForMSAA() const { return String(); }
 832     virtual String stringRoleForMSAA() const { return String(); }
 833     virtual String nameForMSAA() const { return String(); }
 834     virtual String descriptionForMSAA() const { return String(); }
 835     virtual AccessibilityRole roleValueForMSAA() const { return roleValue(); }
 836 
 837     virtual String passwordFieldValue() const { return String(); }
 838     bool isValueAutofilled() const;
 839     bool isValueAutofillAvailable() const;
 840     AutoFillButtonType valueAutofillButtonType() const;
 841 
 842     // Used by an ARIA tree to get all its rows.
 843     void ariaTreeRows(AccessibilityChildrenVector&amp;);
 844     // Used by an ARIA tree item to get all of its direct rows that it can disclose.
 845     void ariaTreeItemDisclosedRows(AccessibilityChildrenVector&amp;);
 846     // Used by an ARIA tree item to get only its content, and not its child tree items and groups.
 847     void ariaTreeItemContent(AccessibilityChildrenVector&amp;);
 848 
 849     // ARIA live-region features.
 850     bool supportsLiveRegion(bool excludeIfOff = true) const;
 851     bool isInsideLiveRegion(bool excludeIfOff = true) const;
 852     AccessibilityObject* liveRegionAncestor(bool excludeIfOff = true) const;
 853     virtual const String liveRegionStatus() const { return String(); }
 854     virtual const String liveRegionRelevant() const { return nullAtom(); }
 855     virtual bool liveRegionAtomic() const { return false; }
 856     virtual bool isBusy() const { return false; }
 857     static const String defaultLiveRegionStatusForRole(AccessibilityRole);
 858     static bool liveRegionStatusIsEnabled(const AtomicString&amp;);
 859     static bool contentEditableAttributeIsEnabled(Element*);
 860     bool hasContentEditableAttributeSet() const;
 861 
 862     bool supportsReadOnly() const;
 863     virtual String readOnlyValue() const;
 864 
 865     bool supportsAutoComplete() const;
 866     String autoCompleteValue() const;
 867 
 868     bool supportsARIAAttributes() const;
 869 
 870     // CSS3 Speech properties.
 871     virtual OptionSet&lt;SpeakAs&gt; speakAsProperty() const { return OptionSet&lt;SpeakAs&gt; { }; }
 872 
 873     // Make this object visible by scrolling as many nested scrollable views as needed.
 874     virtual void scrollToMakeVisible() const;
 875     // Same, but if the whole object can&#39;t be made visible, try for this subrect, in local coordinates.
 876     virtual void scrollToMakeVisibleWithSubFocus(const IntRect&amp;) const;
 877     // Scroll this object to a given point in global coordinates of the top-level window.
 878     virtual void scrollToGlobalPoint(const IntPoint&amp;) const;
 879 
 880     enum class ScrollByPageDirection { Up, Down, Left, Right };
 881     bool scrollByPage(ScrollByPageDirection) const;
 882     IntPoint scrollPosition() const;
 883     IntSize scrollContentsSize() const;
 884     IntRect scrollVisibleContentRect() const;
 885 
 886     bool lastKnownIsIgnoredValue();
 887     void setLastKnownIsIgnoredValue(bool);
 888 
 889     // Fires a children changed notification on the parent if the isIgnored value changed.
 890     void notifyIfIgnoredValueChanged();
 891 
 892     // All math elements return true for isMathElement().
 893     virtual bool isMathElement() const { return false; }
 894     virtual bool isMathFraction() const { return false; }
 895     virtual bool isMathFenced() const { return false; }
 896     virtual bool isMathSubscriptSuperscript() const { return false; }
 897     virtual bool isMathRow() const { return false; }
 898     virtual bool isMathUnderOver() const { return false; }
 899     virtual bool isMathRoot() const { return false; }
 900     virtual bool isMathSquareRoot() const { return false; }
 901     virtual bool isMathText() const { return false; }
 902     virtual bool isMathNumber() const { return false; }
 903     virtual bool isMathOperator() const { return false; }
 904     virtual bool isMathFenceOperator() const { return false; }
 905     virtual bool isMathSeparatorOperator() const { return false; }
 906     virtual bool isMathIdentifier() const { return false; }
 907     virtual bool isMathTable() const { return false; }
 908     virtual bool isMathTableRow() const { return false; }
 909     virtual bool isMathTableCell() const { return false; }
 910     virtual bool isMathMultiscript() const { return false; }
 911     virtual bool isMathToken() const { return false; }
 912     virtual bool isMathScriptObject(AccessibilityMathScriptObjectType) const { return false; }
 913     virtual bool isMathMultiscriptObject(AccessibilityMathMultiscriptObjectType) const { return false; }
 914 
 915     // Root components.
 916     virtual AccessibilityObject* mathRadicandObject() { return nullptr; }
 917     virtual AccessibilityObject* mathRootIndexObject() { return nullptr; }
 918 
 919     // Under over components.
 920     virtual AccessibilityObject* mathUnderObject() { return nullptr; }
 921     virtual AccessibilityObject* mathOverObject() { return nullptr; }
 922 
 923     // Fraction components.
 924     virtual AccessibilityObject* mathNumeratorObject() { return nullptr; }
 925     virtual AccessibilityObject* mathDenominatorObject() { return nullptr; }
 926 
 927     // Subscript/superscript components.
 928     virtual AccessibilityObject* mathBaseObject() { return nullptr; }
 929     virtual AccessibilityObject* mathSubscriptObject() { return nullptr; }
 930     virtual AccessibilityObject* mathSuperscriptObject() { return nullptr; }
 931 
 932     // Fenced components.
 933     virtual String mathFencedOpenString() const { return String(); }
 934     virtual String mathFencedCloseString() const { return String(); }
 935     virtual int mathLineThickness() const { return 0; }
 936     virtual bool isAnonymousMathOperator() const { return false; }
 937 
 938     // Multiscripts components.
 939     typedef Vector&lt;std::pair&lt;AccessibilityObject*, AccessibilityObject*&gt;&gt; AccessibilityMathMultiscriptPairs;
 940     virtual void mathPrescripts(AccessibilityMathMultiscriptPairs&amp;) { }
 941     virtual void mathPostscripts(AccessibilityMathMultiscriptPairs&amp;) { }
 942 
 943     // Visibility.
 944     bool isAXHidden() const;
 945     bool isDOMHidden() const;
 946     bool isHidden() const { return isAXHidden() || isDOMHidden(); }
 947 
 948 #if HAVE(ACCESSIBILITY)
 949     AccessibilityObjectWrapper* wrapper() const { return m_wrapper.get(); }
 950     void setWrapper(AccessibilityObjectWrapper* wrapper) { m_wrapper = wrapper; }
 951 #endif
 952 
 953 #if PLATFORM(COCOA)
 954     void overrideAttachmentParent(AccessibilityObject* parent);
 955 #else
 956     void overrideAttachmentParent(AccessibilityObject*) { }
 957 #endif
 958 
 959 #if HAVE(ACCESSIBILITY)
 960     // a platform-specific method for determining if an attachment is ignored
 961     bool accessibilityIgnoreAttachment() const;
 962     // gives platforms the opportunity to indicate if and how an object should be included
 963     AccessibilityObjectInclusion accessibilityPlatformIncludesObject() const;
 964 #else
 965     bool accessibilityIgnoreAttachment() const { return true; }
 966     AccessibilityObjectInclusion accessibilityPlatformIncludesObject() const { return AccessibilityObjectInclusion::DefaultBehavior; }
 967 #endif
 968 
 969 #if PLATFORM(IOS_FAMILY)
 970     int accessibilityPasswordFieldLength();
 971     bool hasTouchEventListener() const;
 972     bool isInputTypePopupButton() const;
 973     bool hasAccessibleDismissEventListener() const;
 974 #endif
 975 
 976     // allows for an AccessibilityObject to update its render tree or perform
 977     // other operations update type operations
 978     void updateBackingStore();
 979 
 980 #if PLATFORM(COCOA)
 981     bool preventKeyboardDOMEventDispatch() const;
 982     void setPreventKeyboardDOMEventDispatch(bool);
 983 #endif
 984 
 985 #if PLATFORM(COCOA) &amp;&amp; !PLATFORM(IOS_FAMILY)
 986     bool caretBrowsingEnabled() const;
 987     void setCaretBrowsingEnabled(bool);
 988 #endif
 989 
 990     AccessibilityObject* focusableAncestor();
 991     AccessibilityObject* editableAncestor();
 992     AccessibilityObject* highestEditableAncestor();
 993 
 994     static const AccessibilityObject* matchedParent(const AccessibilityObject&amp;, bool includeSelf, const WTF::Function&lt;bool(const AccessibilityObject&amp;)&gt;&amp;);
 995 
 996     void clearIsIgnoredFromParentData() { m_isIgnoredFromParentData = AccessibilityIsIgnoredFromParentData(); }
 997     void setIsIgnoredFromParentDataForChild(AccessibilityObject*);
 998 
 999 protected:
1000     AXID m_id { 0 };
1001     AccessibilityChildrenVector m_children;
1002     mutable bool m_haveChildren { false };
1003     AccessibilityRole m_role { AccessibilityRole::Unknown };
1004     AccessibilityObjectInclusion m_lastKnownIsIgnoredValue { AccessibilityObjectInclusion::DefaultBehavior };
1005     AccessibilityIsIgnoredFromParentData m_isIgnoredFromParentData { };
1006     bool m_childrenDirty { false };
1007     bool m_subtreeDirty { false };
1008 #if ENABLE(ACCESSIBILITY_ISOLATED_TREE)
1009     bool m_isolatedTreeNodeInitialized { false };
1010 #endif
1011 
1012     void setIsIgnoredFromParentData(AccessibilityIsIgnoredFromParentData&amp; data) { m_isIgnoredFromParentData = data; }
1013 
1014     virtual bool computeAccessibilityIsIgnored() const { return true; }
1015 
1016     // If this object itself scrolls, return its ScrollableArea.
1017     virtual ScrollableArea* getScrollableAreaIfScrollable() const { return nullptr; }
1018     virtual void scrollTo(const IntPoint&amp;) const { }
1019     ScrollableArea* scrollableAreaAncestor() const;
1020     void scrollAreaAndAncestor(std::pair&lt;ScrollableArea*, AccessibilityObject*&gt;&amp;) const;
1021 
1022     static bool isAccessibilityObjectSearchMatchAtIndex(AccessibilityObject*, AccessibilitySearchCriteria*, size_t);
1023     static bool isAccessibilityObjectSearchMatch(AccessibilityObject*, AccessibilitySearchCriteria*);
1024     static bool isAccessibilityTextSearchMatch(AccessibilityObject*, AccessibilitySearchCriteria*);
1025     static bool objectMatchesSearchCriteriaWithResultLimit(AccessibilityObject*, AccessibilitySearchCriteria*, AccessibilityChildrenVector&amp;);
1026     virtual AccessibilityRole buttonRoleType() const;
1027     bool isOnscreen() const;
1028     bool dispatchTouchEvent();
1029 
1030     void ariaElementsFromAttribute(AccessibilityChildrenVector&amp;, const QualifiedName&amp;) const;
1031     void ariaElementsReferencedByAttribute(AccessibilityChildrenVector&amp;, const QualifiedName&amp;) const;
1032 
1033     AccessibilityObject* radioGroupAncestor() const;
1034 
1035 #if PLATFORM(GTK) &amp;&amp; HAVE(ACCESSIBILITY)
1036     bool allowsTextRanges() const;
1037     unsigned getLengthForTextRange() const;
1038 #else
1039     bool allowsTextRanges() const { return isTextControl(); }
1040     unsigned getLengthForTextRange() const { return text().length(); }
1041 #endif
1042 
1043 #if PLATFORM(COCOA)
1044     RetainPtr&lt;WebAccessibilityObjectWrapper&gt; m_wrapper;
1045 #elif PLATFORM(WIN)
1046     COMPtr&lt;AccessibilityObjectWrapper&gt; m_wrapper;
1047 #elif PLATFORM(GTK)
1048     GRefPtr&lt;WebKitAccessible&gt; m_wrapper;
1049 #elif PLATFORM(WPE)
1050     RefPtr&lt;AccessibilityObjectWrapper&gt; m_wrapper;
1051 #endif
1052 };
1053 
1054 #if !HAVE(ACCESSIBILITY)
1055 inline const AccessibilityObject::AccessibilityChildrenVector&amp; AccessibilityObject::children(bool) { return m_children; }
1056 inline const String&amp; AccessibilityObject::actionVerb() const { return emptyString(); }
1057 inline int AccessibilityObject::lineForPosition(const VisiblePosition&amp;) const { return -1; }
1058 inline void AccessibilityObject::updateBackingStore() { }
1059 #endif
1060 
1061 } // namespace WebCore
1062 
1063 #define SPECIALIZE_TYPE_TRAITS_ACCESSIBILITY(ToValueTypeName, predicate) \
1064 SPECIALIZE_TYPE_TRAITS_BEGIN(WebCore::ToValueTypeName) \
1065     static bool isType(const WebCore::AccessibilityObject&amp; object) { return object.predicate; } \
1066 SPECIALIZE_TYPE_TRAITS_END()
    </pre>
  </body>
</html>