<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/html/MediaElementSession.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="MediaDocument.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="MediaElementSession.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/html/MediaElementSession.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 
 28 #if ENABLE(VIDEO)
 29 
 30 #include &quot;MediaElementSession.h&quot;
 31 
 32 #include &quot;Document.h&quot;
 33 #include &quot;DocumentLoader.h&quot;
 34 #include &quot;Frame.h&quot;
 35 #include &quot;FrameView.h&quot;

 36 #include &quot;HTMLAudioElement.h&quot;
 37 #include &quot;HTMLMediaElement.h&quot;
 38 #include &quot;HTMLNames.h&quot;
 39 #include &quot;HTMLVideoElement.h&quot;
 40 #include &quot;HitTestResult.h&quot;
 41 #include &quot;Logging.h&quot;
 42 #include &quot;Page.h&quot;
 43 #include &quot;PlatformMediaSessionManager.h&quot;

 44 #include &quot;RenderMedia.h&quot;
 45 #include &quot;RenderView.h&quot;
 46 #include &quot;ScriptController.h&quot;
 47 #include &quot;Settings.h&quot;
 48 #include &quot;SourceBuffer.h&quot;
 49 #include &lt;wtf/text/StringBuilder.h&gt;
 50 
 51 #if PLATFORM(IOS_FAMILY)
 52 #include &quot;AudioSession.h&quot;
 53 #include &quot;RuntimeApplicationChecks.h&quot;
 54 #include &lt;wtf/spi/darwin/dyldSPI.h&gt;
 55 #endif
 56 
 57 namespace WebCore {
 58 
 59 static const Seconds clientDataBufferingTimerThrottleDelay { 100_ms };
 60 static const Seconds elementMainContentCheckInterval { 250_ms };
 61 
 62 static bool isElementRectMostlyInMainFrame(const HTMLMediaElement&amp;);
 63 static bool isElementLargeEnoughForMainContent(const HTMLMediaElement&amp;, MediaSessionMainContentPurpose);
</pre>
<hr />
<pre>
 67 static String restrictionNames(MediaElementSession::BehaviorRestrictions restriction)
 68 {
 69     StringBuilder restrictionBuilder;
 70 #define CASE(restrictionType) \
 71     if (restriction &amp; MediaElementSession::restrictionType) { \
 72         if (!restrictionBuilder.isEmpty()) \
 73             restrictionBuilder.appendLiteral(&quot;, &quot;); \
 74         restrictionBuilder.append(#restrictionType); \
 75     } \
 76 
 77     CASE(NoRestrictions)
 78     CASE(RequireUserGestureForLoad)
 79     CASE(RequireUserGestureForVideoRateChange)
 80     CASE(RequireUserGestureForAudioRateChange)
 81     CASE(RequireUserGestureForFullscreen)
 82     CASE(RequirePageConsentToLoadMedia)
 83     CASE(RequirePageConsentToResumeMedia)
 84     CASE(RequireUserGestureToShowPlaybackTargetPicker)
 85     CASE(WirelessVideoPlaybackDisabled)
 86     CASE(RequireUserGestureToAutoplayToExternalDevice)
<span class="line-removed"> 87     CASE(MetadataPreloadingNotPermitted)</span>
 88     CASE(AutoPreloadingNotPermitted)
 89     CASE(InvisibleAutoplayNotPermitted)
 90     CASE(OverrideUserGestureRequirementForMainContent)
 91     CASE(RequireUserGestureToControlControlsManager)
 92     CASE(RequirePlaybackToControlControlsManager)
 93     CASE(RequireUserGestureForVideoDueToLowPowerMode)
 94 
 95     return restrictionBuilder.toString();
 96 }
 97 #endif
 98 
 99 static bool pageExplicitlyAllowsElementToAutoplayInline(const HTMLMediaElement&amp; element)
100 {
101     Document&amp; document = element.document();
102     Page* page = document.page();
103     return document.isMediaDocument() &amp;&amp; !document.ownerElement() &amp;&amp; page &amp;&amp; page-&gt;allowsMediaDocumentInlinePlayback();
104 }
105 
106 MediaElementSession::MediaElementSession(HTMLMediaElement&amp; element)
107     : PlatformMediaSession(element)
108     , m_element(element)
109     , m_restrictions(NoRestrictions)
110 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
111     , m_targetAvailabilityChangedTimer(*this, &amp;MediaElementSession::targetAvailabilityChangedTimerFired)

112 #endif
113     , m_mainContentCheckTimer(*this, &amp;MediaElementSession::mainContentCheckTimerFired)
114     , m_clientDataBufferingTimer(*this, &amp;MediaElementSession::clientDataBufferingTimerFired)
115 #if !RELEASE_LOG_DISABLED
116     , m_logIdentifier(element.logIdentifier())
117 #endif
118 {
119 }
120 
121 void MediaElementSession::registerWithDocument(Document&amp; document)
122 {
123 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
124     document.addPlaybackTargetPickerClient(*this);
125 #else
126     UNUSED_PARAM(document);
127 #endif
128 }
129 
130 void MediaElementSession::unregisterWithDocument(Document&amp; document)
131 {
</pre>
<hr />
<pre>
198 
199     updateClientDataBuffering();
200 
201 #if PLATFORM(IOS_FAMILY)
202     PlatformMediaSessionManager::sharedManager().configureWireLessTargetMonitoring();
203 #endif
204 
205     if (state() != Playing || !m_element.elementIsHidden())
206         return;
207 
208     PlatformMediaSessionManager::SessionRestrictions restrictions = PlatformMediaSessionManager::sharedManager().restrictions(mediaType());
209     if ((restrictions &amp; PlatformMediaSessionManager::BackgroundTabPlaybackRestricted) == PlatformMediaSessionManager::BackgroundTabPlaybackRestricted)
210         pauseSession();
211 }
212 
213 void MediaElementSession::updateClientDataBuffering()
214 {
215     if (m_clientDataBufferingTimer.isActive())
216         m_clientDataBufferingTimer.stop();
217 
<span class="line-modified">218     m_element.setShouldBufferData(dataBufferingPermitted());</span>
219 }
220 
221 void MediaElementSession::addBehaviorRestriction(BehaviorRestrictions restrictions)
222 {
223     if (restrictions &amp; ~m_restrictions)
224         INFO_LOG(LOGIDENTIFIER, &quot;adding &quot;, restrictionNames(restrictions &amp; ~m_restrictions));
225 
226     m_restrictions |= restrictions;
227 
228     if (restrictions &amp; OverrideUserGestureRequirementForMainContent)
229         m_mainContentCheckTimer.startRepeating(elementMainContentCheckInterval);
230 }
231 
232 void MediaElementSession::removeBehaviorRestriction(BehaviorRestrictions restriction)
233 {
234     if (restriction &amp; RequireUserGestureToControlControlsManager) {
235         m_mostRecentUserInteractionTime = MonotonicTime::now();
236         if (auto page = m_element.document().page())
237             page-&gt;setAllowsPlaybackControlsForAutoplayingAudio(true);
238     }
239 
240     if (!(m_restrictions &amp; restriction))
241         return;
242 
<span class="line-modified">243     INFO_LOG(LOGIDENTIFIER, &quot;removing &quot;, restrictionNames(m_restrictions &amp; restriction));</span>
244     m_restrictions &amp;= ~restriction;
245 }
246 
<span class="line-removed">247 #if PLATFORM(MAC)</span>
<span class="line-removed">248 static bool needsArbitraryUserGestureAutoplayQuirk(const Document&amp; document)</span>
<span class="line-removed">249 {</span>
<span class="line-removed">250     if (!document.settings().needsSiteSpecificQuirks())</span>
<span class="line-removed">251         return false;</span>
<span class="line-removed">252 </span>
<span class="line-removed">253     auto loader = makeRefPtr(document.loader());</span>
<span class="line-removed">254     return loader &amp;&amp; loader-&gt;allowedAutoplayQuirks().contains(AutoplayQuirk::ArbitraryUserGestures);</span>
<span class="line-removed">255 }</span>
<span class="line-removed">256 #endif // PLATFORM(MAC)</span>
<span class="line-removed">257 </span>
<span class="line-removed">258 static bool needsPerDocumentAutoplayBehaviorQuirk(const Document&amp; document)</span>
<span class="line-removed">259 {</span>
<span class="line-removed">260     if (!document.settings().needsSiteSpecificQuirks())</span>
<span class="line-removed">261         return false;</span>
<span class="line-removed">262 </span>
<span class="line-removed">263     auto loader = makeRefPtr(document.loader());</span>
<span class="line-removed">264     return loader &amp;&amp; loader-&gt;allowedAutoplayQuirks().contains(AutoplayQuirk::PerDocumentAutoplayBehavior);</span>
<span class="line-removed">265 }</span>
<span class="line-removed">266 </span>
267 SuccessOr&lt;MediaPlaybackDenialReason&gt; MediaElementSession::playbackPermitted() const
268 {
269     if (m_element.isSuspended()) {
270         ALWAYS_LOG(LOGIDENTIFIER, &quot;Returning FALSE because element is suspended&quot;);
271         return MediaPlaybackDenialReason::InvalidState;
272     }
273 
274     auto&amp; document = m_element.document();
275     auto* page = document.page();
<span class="line-modified">276     if (!page || page-&gt;mediaPlaybackIsSuspended())</span>

277         return MediaPlaybackDenialReason::PageConsentRequired;

278 
279     if (document.isMediaDocument() &amp;&amp; !document.ownerElement())
280         return { };
281 
282     if (pageExplicitlyAllowsElementToAutoplayInline(m_element))
283         return { };
284 
285     if (requiresFullscreenForVideoPlayback() &amp;&amp; !fullscreenPermitted()) {
286         ALWAYS_LOG(LOGIDENTIFIER, &quot;Returning FALSE because of fullscreen restriction&quot;);
287         return MediaPlaybackDenialReason::FullscreenRequired;
288     }
289 
290     if (m_restrictions &amp; OverrideUserGestureRequirementForMainContent &amp;&amp; updateIsMainContent())
291         return { };
292 
293 #if ENABLE(MEDIA_STREAM)
294     if (m_element.hasMediaStreamSrcObject()) {
295         if (document.isCapturing())
296             return { };
297         if (document.mediaState() &amp; MediaProducer::IsPlayingAudio)
298             return { };
299     }
300 #endif
301 

302     const auto&amp; topDocument = document.topDocument();
<span class="line-modified">303     if (topDocument.mediaState() &amp; MediaProducer::HasUserInteractedWithMediaElement &amp;&amp; needsPerDocumentAutoplayBehaviorQuirk(topDocument))</span>
304         return { };
305 
<span class="line-modified">306 #if PLATFORM(MAC)</span>
<span class="line-removed">307     if (document.hasHadUserInteraction() &amp;&amp; needsArbitraryUserGestureAutoplayQuirk(document))</span>
308         return { };
<span class="line-removed">309 #endif</span>
310 
311     if (m_restrictions &amp; RequireUserGestureForVideoRateChange &amp;&amp; m_element.isVideo() &amp;&amp; !document.processingUserGestureForMedia()) {
312         ALWAYS_LOG(LOGIDENTIFIER, &quot;Returning FALSE because a user gesture is required for video rate change restriction&quot;);
313         return MediaPlaybackDenialReason::UserGestureRequired;
314     }
315 
316     if (m_restrictions &amp; RequireUserGestureForAudioRateChange &amp;&amp; (!m_element.isVideo() || m_element.hasAudio()) &amp;&amp; !m_element.muted() &amp;&amp; m_element.volume() &amp;&amp; !document.processingUserGestureForMedia()) {
317         ALWAYS_LOG(LOGIDENTIFIER, &quot;Returning FALSE because a user gesture is required for audio rate change restriction&quot;);
318         return MediaPlaybackDenialReason::UserGestureRequired;
319     }
320 
321     if (m_restrictions &amp; RequireUserGestureForVideoDueToLowPowerMode &amp;&amp; m_element.isVideo() &amp;&amp; !document.processingUserGestureForMedia()) {
322         ALWAYS_LOG(LOGIDENTIFIER, &quot;Returning FALSE because of video low power mode restriction&quot;);
323         return MediaPlaybackDenialReason::UserGestureRequired;
324     }
325 
326     return { };
327 }
328 
329 bool MediaElementSession::autoplayPermitted() const
</pre>
<hr />
<pre>
357     if (renderer-&gt;visibleInViewportState() != VisibleInViewportState::Yes) {
358         ALWAYS_LOG(LOGIDENTIFIER, &quot;Returning FALSE because element is not visible in the viewport&quot;);
359         return false;
360     }
361     return true;
362 }
363 
364 bool MediaElementSession::dataLoadingPermitted() const
365 {
366     if (m_restrictions &amp; OverrideUserGestureRequirementForMainContent &amp;&amp; updateIsMainContent())
367         return true;
368 
369     if (m_restrictions &amp; RequireUserGestureForLoad &amp;&amp; !m_element.document().processingUserGestureForMedia()) {
370         INFO_LOG(LOGIDENTIFIER, &quot;returning FALSE&quot;);
371         return false;
372     }
373 
374     return true;
375 }
376 
<span class="line-modified">377 bool MediaElementSession::dataBufferingPermitted() const</span>
378 {
379     if (isSuspended())
<span class="line-modified">380         return false;</span>



381 
382     if (state() == PlatformMediaSession::Playing)
<span class="line-modified">383         return true;</span>
384 
385     if (shouldOverrideBackgroundLoadingRestriction())
<span class="line-modified">386         return true;</span>
387 
388 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
389     if (m_shouldPlayToPlaybackTarget)
<span class="line-modified">390         return true;</span>
391 #endif
392 
393     if (m_elementIsHiddenUntilVisibleInViewport || m_elementIsHiddenBecauseItWasRemovedFromDOM || m_element.elementIsHidden())
<span class="line-modified">394         return false;</span>
395 
<span class="line-modified">396     return true;</span>
397 }
398 
399 bool MediaElementSession::fullscreenPermitted() const
400 {
401     if (m_restrictions &amp; RequireUserGestureForFullscreen &amp;&amp; !m_element.document().processingUserGestureForMedia()) {
402         INFO_LOG(LOGIDENTIFIER, &quot;returning FALSE&quot;);
403         return false;
404     }
405 
406     return true;
407 }
408 
409 bool MediaElementSession::pageAllowsDataLoading() const
410 {
411     Page* page = m_element.document().page();
412     if (m_restrictions &amp; RequirePageConsentToLoadMedia &amp;&amp; page &amp;&amp; !page-&gt;canStartMedia()) {
413         INFO_LOG(LOGIDENTIFIER, &quot;returning FALSE&quot;);
414         return false;
415     }
416 
</pre>
<hr />
<pre>
480         return false;
481     }
482 
483     if (!hasBehaviorRestriction(RequireUserGestureToControlControlsManager) || m_element.document().processingUserGestureForMedia()) {
484         INFO_LOG(LOGIDENTIFIER, &quot;returning TRUE: no user gesture required&quot;);
485         return true;
486     }
487 
488     if (purpose == PlaybackControlsPurpose::ControlsManager &amp;&amp; hasBehaviorRestriction(RequirePlaybackToControlControlsManager) &amp;&amp; !m_element.isPlaying()) {
489         INFO_LOG(LOGIDENTIFIER, &quot;returning FALSE: needs to be playing&quot;);
490         return false;
491     }
492 
493     if (!m_element.hasEverNotifiedAboutPlaying()) {
494         INFO_LOG(LOGIDENTIFIER, &quot;returning FALSE: hasn&#39;t fired playing notification&quot;);
495         return false;
496     }
497 
498 #if ENABLE(FULLSCREEN_API)
499     // Elements which are not descendents of the current fullscreen element cannot be main content.
<span class="line-modified">500     auto* fullscreenElement = m_element.document().webkitCurrentFullScreenElement();</span>
501     if (fullscreenElement &amp;&amp; !m_element.isDescendantOf(*fullscreenElement)) {
502         INFO_LOG(LOGIDENTIFIER, &quot;returning FALSE: outside of full screen&quot;);
503         return false;
504     }
505 #endif
506 
507     // Only allow the main content heuristic to forbid videos from showing up if our purpose is the controls manager.
508     if (purpose == PlaybackControlsPurpose::ControlsManager &amp;&amp; m_element.isVideo()) {
509         if (!m_element.renderer()) {
510             INFO_LOG(LOGIDENTIFIER, &quot;returning FALSE: no renderer&quot;);
511             return false;
512         }
513 
514         if (!m_element.hasVideo() &amp;&amp; !m_element.hasEverHadVideo()) {
515             INFO_LOG(LOGIDENTIFIER, &quot;returning FALSE: no video&quot;);
516             return false;
517         }
518 
519         if (isLargeEnoughForMainContent(MediaSessionMainContentPurpose::MediaControls)) {
520             INFO_LOG(LOGIDENTIFIER, &quot;returning TRUE: is main content&quot;);
</pre>
<hr />
<pre>
688 {
689     INFO_LOG(LOGIDENTIFIER, shouldPlay);
690     m_shouldPlayToPlaybackTarget = shouldPlay;
691     updateClientDataBuffering();
692     client().setShouldPlayToPlaybackTarget(shouldPlay);
693 }
694 
695 void MediaElementSession::mediaStateDidChange(MediaProducer::MediaStateFlags state)
696 {
697     m_element.document().playbackTargetPickerClientStateDidChange(*this, state);
698 }
699 #endif
700 
701 MediaPlayer::Preload MediaElementSession::effectivePreloadForElement() const
702 {
703     MediaPlayer::Preload preload = m_element.preloadValue();
704 
705     if (pageExplicitlyAllowsElementToAutoplayInline(m_element))
706         return preload;
707 
<span class="line-removed">708     if (m_restrictions &amp; MetadataPreloadingNotPermitted)</span>
<span class="line-removed">709         return MediaPlayer::None;</span>
<span class="line-removed">710 </span>
711     if (m_restrictions &amp; AutoPreloadingNotPermitted) {
712         if (preload &gt; MediaPlayer::MetaData)
713             return MediaPlayer::MetaData;
714     }
715 
716     return preload;
717 }
718 
719 bool MediaElementSession::requiresFullscreenForVideoPlayback() const
720 {
721     if (pageExplicitlyAllowsElementToAutoplayInline(m_element))
722         return false;
723 
724     if (is&lt;HTMLAudioElement&gt;(m_element))
725         return false;
726 
727     if (m_element.document().isMediaDocument()) {
728         ASSERT(is&lt;HTMLVideoElement&gt;(m_element));
729         const HTMLVideoElement&amp; videoElement = *downcast&lt;const HTMLVideoElement&gt;(&amp;m_element);
730         if (m_element.readyState() &lt; HTMLVideoElement::HAVE_METADATA || !videoElement.hasEverHadVideo())
</pre>
<hr />
<pre>
768 {
769     INFO_LOG(LOGIDENTIFIER);
770 
771 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
772     if (m_restrictions &amp; WirelessVideoPlaybackDisabled)
773         setWirelessVideoPlaybackDisabled(true);
774     if (m_playbackTarget)
775         client().setWirelessPlaybackTarget(*m_playbackTarget.copyRef());
776     if (m_shouldPlayToPlaybackTarget)
777         client().setShouldPlayToPlaybackTarget(true);
778 #endif
779 
780 }
781 
782 void MediaElementSession::resetPlaybackSessionState()
783 {
784     m_mostRecentUserInteractionTime = MonotonicTime();
785     addBehaviorRestriction(RequireUserGestureToControlControlsManager | RequirePlaybackToControlControlsManager);
786 }
787 

















788 bool MediaElementSession::allowsPictureInPicture() const
789 {
790     return m_element.document().settings().allowsPictureInPictureMediaPlayback();
791 }
792 
793 #if PLATFORM(IOS_FAMILY)
794 bool MediaElementSession::requiresPlaybackTargetRouteMonitoring() const
795 {
796     return m_hasPlaybackTargetAvailabilityListeners &amp;&amp; !m_element.elementIsHidden();
797 }
798 #endif
799 
800 #if ENABLE(MEDIA_SOURCE)
801 size_t MediaElementSession::maximumMediaSourceBufferSize(const SourceBuffer&amp; buffer) const
802 {
803     // A good quality 1080p video uses 8,000 kbps and stereo audio uses 384 kbps, so assume 95% for video and 5% for audio.
804     const float bufferBudgetPercentageForVideo = .95;
805     const float bufferBudgetPercentageForAudio = .05;
806 
807     size_t maximum = buffer.document().settings().maximumSourceBufferSize();
</pre>
<hr />
<pre>
960     m_isMainContent = isElementMainContentForPurposesOfAutoplay(m_element, true);
961 
962     if (m_isMainContent != wasMainContent)
963         m_element.updateShouldPlay();
964 
965     return m_isMainContent;
966 }
967 
968 bool MediaElementSession::allowsNowPlayingControlsVisibility() const
969 {
970     auto page = m_element.document().page();
971     return page &amp;&amp; !page-&gt;isVisibleAndActive();
972 }
973 
974 bool MediaElementSession::allowsPlaybackControlsForAutoplayingAudio() const
975 {
976     auto page = m_element.document().page();
977     return page &amp;&amp; page-&gt;allowsPlaybackControlsForAutoplayingAudio();
978 }
979 
















980 }
981 
982 #endif // ENABLE(VIDEO)
</pre>
</td>
<td>
<hr />
<pre>
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 
 28 #if ENABLE(VIDEO)
 29 
 30 #include &quot;MediaElementSession.h&quot;
 31 
 32 #include &quot;Document.h&quot;
 33 #include &quot;DocumentLoader.h&quot;
 34 #include &quot;Frame.h&quot;
 35 #include &quot;FrameView.h&quot;
<span class="line-added"> 36 #include &quot;FullscreenManager.h&quot;</span>
 37 #include &quot;HTMLAudioElement.h&quot;
 38 #include &quot;HTMLMediaElement.h&quot;
 39 #include &quot;HTMLNames.h&quot;
 40 #include &quot;HTMLVideoElement.h&quot;
 41 #include &quot;HitTestResult.h&quot;
 42 #include &quot;Logging.h&quot;
 43 #include &quot;Page.h&quot;
 44 #include &quot;PlatformMediaSessionManager.h&quot;
<span class="line-added"> 45 #include &quot;Quirks.h&quot;</span>
 46 #include &quot;RenderMedia.h&quot;
 47 #include &quot;RenderView.h&quot;
 48 #include &quot;ScriptController.h&quot;
 49 #include &quot;Settings.h&quot;
 50 #include &quot;SourceBuffer.h&quot;
 51 #include &lt;wtf/text/StringBuilder.h&gt;
 52 
 53 #if PLATFORM(IOS_FAMILY)
 54 #include &quot;AudioSession.h&quot;
 55 #include &quot;RuntimeApplicationChecks.h&quot;
 56 #include &lt;wtf/spi/darwin/dyldSPI.h&gt;
 57 #endif
 58 
 59 namespace WebCore {
 60 
 61 static const Seconds clientDataBufferingTimerThrottleDelay { 100_ms };
 62 static const Seconds elementMainContentCheckInterval { 250_ms };
 63 
 64 static bool isElementRectMostlyInMainFrame(const HTMLMediaElement&amp;);
 65 static bool isElementLargeEnoughForMainContent(const HTMLMediaElement&amp;, MediaSessionMainContentPurpose);
</pre>
<hr />
<pre>
 69 static String restrictionNames(MediaElementSession::BehaviorRestrictions restriction)
 70 {
 71     StringBuilder restrictionBuilder;
 72 #define CASE(restrictionType) \
 73     if (restriction &amp; MediaElementSession::restrictionType) { \
 74         if (!restrictionBuilder.isEmpty()) \
 75             restrictionBuilder.appendLiteral(&quot;, &quot;); \
 76         restrictionBuilder.append(#restrictionType); \
 77     } \
 78 
 79     CASE(NoRestrictions)
 80     CASE(RequireUserGestureForLoad)
 81     CASE(RequireUserGestureForVideoRateChange)
 82     CASE(RequireUserGestureForAudioRateChange)
 83     CASE(RequireUserGestureForFullscreen)
 84     CASE(RequirePageConsentToLoadMedia)
 85     CASE(RequirePageConsentToResumeMedia)
 86     CASE(RequireUserGestureToShowPlaybackTargetPicker)
 87     CASE(WirelessVideoPlaybackDisabled)
 88     CASE(RequireUserGestureToAutoplayToExternalDevice)

 89     CASE(AutoPreloadingNotPermitted)
 90     CASE(InvisibleAutoplayNotPermitted)
 91     CASE(OverrideUserGestureRequirementForMainContent)
 92     CASE(RequireUserGestureToControlControlsManager)
 93     CASE(RequirePlaybackToControlControlsManager)
 94     CASE(RequireUserGestureForVideoDueToLowPowerMode)
 95 
 96     return restrictionBuilder.toString();
 97 }
 98 #endif
 99 
100 static bool pageExplicitlyAllowsElementToAutoplayInline(const HTMLMediaElement&amp; element)
101 {
102     Document&amp; document = element.document();
103     Page* page = document.page();
104     return document.isMediaDocument() &amp;&amp; !document.ownerElement() &amp;&amp; page &amp;&amp; page-&gt;allowsMediaDocumentInlinePlayback();
105 }
106 
107 MediaElementSession::MediaElementSession(HTMLMediaElement&amp; element)
108     : PlatformMediaSession(element)
109     , m_element(element)
110     , m_restrictions(NoRestrictions)
111 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
112     , m_targetAvailabilityChangedTimer(*this, &amp;MediaElementSession::targetAvailabilityChangedTimerFired)
<span class="line-added">113     , m_hasPlaybackTargets(PlatformMediaSessionManager::sharedManager().hasWirelessTargetsAvailable())</span>
114 #endif
115     , m_mainContentCheckTimer(*this, &amp;MediaElementSession::mainContentCheckTimerFired)
116     , m_clientDataBufferingTimer(*this, &amp;MediaElementSession::clientDataBufferingTimerFired)
117 #if !RELEASE_LOG_DISABLED
118     , m_logIdentifier(element.logIdentifier())
119 #endif
120 {
121 }
122 
123 void MediaElementSession::registerWithDocument(Document&amp; document)
124 {
125 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
126     document.addPlaybackTargetPickerClient(*this);
127 #else
128     UNUSED_PARAM(document);
129 #endif
130 }
131 
132 void MediaElementSession::unregisterWithDocument(Document&amp; document)
133 {
</pre>
<hr />
<pre>
200 
201     updateClientDataBuffering();
202 
203 #if PLATFORM(IOS_FAMILY)
204     PlatformMediaSessionManager::sharedManager().configureWireLessTargetMonitoring();
205 #endif
206 
207     if (state() != Playing || !m_element.elementIsHidden())
208         return;
209 
210     PlatformMediaSessionManager::SessionRestrictions restrictions = PlatformMediaSessionManager::sharedManager().restrictions(mediaType());
211     if ((restrictions &amp; PlatformMediaSessionManager::BackgroundTabPlaybackRestricted) == PlatformMediaSessionManager::BackgroundTabPlaybackRestricted)
212         pauseSession();
213 }
214 
215 void MediaElementSession::updateClientDataBuffering()
216 {
217     if (m_clientDataBufferingTimer.isActive())
218         m_clientDataBufferingTimer.stop();
219 
<span class="line-modified">220     m_element.setBufferingPolicy(preferredBufferingPolicy());</span>
221 }
222 
223 void MediaElementSession::addBehaviorRestriction(BehaviorRestrictions restrictions)
224 {
225     if (restrictions &amp; ~m_restrictions)
226         INFO_LOG(LOGIDENTIFIER, &quot;adding &quot;, restrictionNames(restrictions &amp; ~m_restrictions));
227 
228     m_restrictions |= restrictions;
229 
230     if (restrictions &amp; OverrideUserGestureRequirementForMainContent)
231         m_mainContentCheckTimer.startRepeating(elementMainContentCheckInterval);
232 }
233 
234 void MediaElementSession::removeBehaviorRestriction(BehaviorRestrictions restriction)
235 {
236     if (restriction &amp; RequireUserGestureToControlControlsManager) {
237         m_mostRecentUserInteractionTime = MonotonicTime::now();
238         if (auto page = m_element.document().page())
239             page-&gt;setAllowsPlaybackControlsForAutoplayingAudio(true);
240     }
241 
242     if (!(m_restrictions &amp; restriction))
243         return;
244 
<span class="line-modified">245     INFO_LOG(LOGIDENTIFIER, &quot;removed &quot;, restrictionNames(m_restrictions &amp; restriction));</span>
246     m_restrictions &amp;= ~restriction;
247 }
248 




















249 SuccessOr&lt;MediaPlaybackDenialReason&gt; MediaElementSession::playbackPermitted() const
250 {
251     if (m_element.isSuspended()) {
252         ALWAYS_LOG(LOGIDENTIFIER, &quot;Returning FALSE because element is suspended&quot;);
253         return MediaPlaybackDenialReason::InvalidState;
254     }
255 
256     auto&amp; document = m_element.document();
257     auto* page = document.page();
<span class="line-modified">258     if (!page || page-&gt;mediaPlaybackIsSuspended()) {</span>
<span class="line-added">259         ALWAYS_LOG(LOGIDENTIFIER, &quot;Returning FALSE because media playback is suspended&quot;);</span>
260         return MediaPlaybackDenialReason::PageConsentRequired;
<span class="line-added">261     }</span>
262 
263     if (document.isMediaDocument() &amp;&amp; !document.ownerElement())
264         return { };
265 
266     if (pageExplicitlyAllowsElementToAutoplayInline(m_element))
267         return { };
268 
269     if (requiresFullscreenForVideoPlayback() &amp;&amp; !fullscreenPermitted()) {
270         ALWAYS_LOG(LOGIDENTIFIER, &quot;Returning FALSE because of fullscreen restriction&quot;);
271         return MediaPlaybackDenialReason::FullscreenRequired;
272     }
273 
274     if (m_restrictions &amp; OverrideUserGestureRequirementForMainContent &amp;&amp; updateIsMainContent())
275         return { };
276 
277 #if ENABLE(MEDIA_STREAM)
278     if (m_element.hasMediaStreamSrcObject()) {
279         if (document.isCapturing())
280             return { };
281         if (document.mediaState() &amp; MediaProducer::IsPlayingAudio)
282             return { };
283     }
284 #endif
285 
<span class="line-added">286     // FIXME: Why are we checking top-level document only for PerDocumentAutoplayBehavior?</span>
287     const auto&amp; topDocument = document.topDocument();
<span class="line-modified">288     if (topDocument.mediaState() &amp; MediaProducer::HasUserInteractedWithMediaElement &amp;&amp; topDocument.quirks().needsPerDocumentAutoplayBehavior())</span>
289         return { };
290 
<span class="line-modified">291     if (document.hasHadUserInteraction() &amp;&amp; document.quirks().shouldAutoplayForArbitraryUserGesture())</span>

292         return { };

293 
294     if (m_restrictions &amp; RequireUserGestureForVideoRateChange &amp;&amp; m_element.isVideo() &amp;&amp; !document.processingUserGestureForMedia()) {
295         ALWAYS_LOG(LOGIDENTIFIER, &quot;Returning FALSE because a user gesture is required for video rate change restriction&quot;);
296         return MediaPlaybackDenialReason::UserGestureRequired;
297     }
298 
299     if (m_restrictions &amp; RequireUserGestureForAudioRateChange &amp;&amp; (!m_element.isVideo() || m_element.hasAudio()) &amp;&amp; !m_element.muted() &amp;&amp; m_element.volume() &amp;&amp; !document.processingUserGestureForMedia()) {
300         ALWAYS_LOG(LOGIDENTIFIER, &quot;Returning FALSE because a user gesture is required for audio rate change restriction&quot;);
301         return MediaPlaybackDenialReason::UserGestureRequired;
302     }
303 
304     if (m_restrictions &amp; RequireUserGestureForVideoDueToLowPowerMode &amp;&amp; m_element.isVideo() &amp;&amp; !document.processingUserGestureForMedia()) {
305         ALWAYS_LOG(LOGIDENTIFIER, &quot;Returning FALSE because of video low power mode restriction&quot;);
306         return MediaPlaybackDenialReason::UserGestureRequired;
307     }
308 
309     return { };
310 }
311 
312 bool MediaElementSession::autoplayPermitted() const
</pre>
<hr />
<pre>
340     if (renderer-&gt;visibleInViewportState() != VisibleInViewportState::Yes) {
341         ALWAYS_LOG(LOGIDENTIFIER, &quot;Returning FALSE because element is not visible in the viewport&quot;);
342         return false;
343     }
344     return true;
345 }
346 
347 bool MediaElementSession::dataLoadingPermitted() const
348 {
349     if (m_restrictions &amp; OverrideUserGestureRequirementForMainContent &amp;&amp; updateIsMainContent())
350         return true;
351 
352     if (m_restrictions &amp; RequireUserGestureForLoad &amp;&amp; !m_element.document().processingUserGestureForMedia()) {
353         INFO_LOG(LOGIDENTIFIER, &quot;returning FALSE&quot;);
354         return false;
355     }
356 
357     return true;
358 }
359 
<span class="line-modified">360 MediaPlayer::BufferingPolicy MediaElementSession::preferredBufferingPolicy() const</span>
361 {
362     if (isSuspended())
<span class="line-modified">363         return MediaPlayer::BufferingPolicy::MakeResourcesPurgeable;</span>
<span class="line-added">364 </span>
<span class="line-added">365     if (bufferingSuspended())</span>
<span class="line-added">366         return MediaPlayer::BufferingPolicy::LimitReadAhead;</span>
367 
368     if (state() == PlatformMediaSession::Playing)
<span class="line-modified">369         return MediaPlayer::BufferingPolicy::Default;</span>
370 
371     if (shouldOverrideBackgroundLoadingRestriction())
<span class="line-modified">372         return MediaPlayer::BufferingPolicy::Default;</span>
373 
374 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
375     if (m_shouldPlayToPlaybackTarget)
<span class="line-modified">376         return MediaPlayer::BufferingPolicy::Default;</span>
377 #endif
378 
379     if (m_elementIsHiddenUntilVisibleInViewport || m_elementIsHiddenBecauseItWasRemovedFromDOM || m_element.elementIsHidden())
<span class="line-modified">380         return MediaPlayer::BufferingPolicy::MakeResourcesPurgeable;</span>
381 
<span class="line-modified">382     return MediaPlayer::BufferingPolicy::Default;</span>
383 }
384 
385 bool MediaElementSession::fullscreenPermitted() const
386 {
387     if (m_restrictions &amp; RequireUserGestureForFullscreen &amp;&amp; !m_element.document().processingUserGestureForMedia()) {
388         INFO_LOG(LOGIDENTIFIER, &quot;returning FALSE&quot;);
389         return false;
390     }
391 
392     return true;
393 }
394 
395 bool MediaElementSession::pageAllowsDataLoading() const
396 {
397     Page* page = m_element.document().page();
398     if (m_restrictions &amp; RequirePageConsentToLoadMedia &amp;&amp; page &amp;&amp; !page-&gt;canStartMedia()) {
399         INFO_LOG(LOGIDENTIFIER, &quot;returning FALSE&quot;);
400         return false;
401     }
402 
</pre>
<hr />
<pre>
466         return false;
467     }
468 
469     if (!hasBehaviorRestriction(RequireUserGestureToControlControlsManager) || m_element.document().processingUserGestureForMedia()) {
470         INFO_LOG(LOGIDENTIFIER, &quot;returning TRUE: no user gesture required&quot;);
471         return true;
472     }
473 
474     if (purpose == PlaybackControlsPurpose::ControlsManager &amp;&amp; hasBehaviorRestriction(RequirePlaybackToControlControlsManager) &amp;&amp; !m_element.isPlaying()) {
475         INFO_LOG(LOGIDENTIFIER, &quot;returning FALSE: needs to be playing&quot;);
476         return false;
477     }
478 
479     if (!m_element.hasEverNotifiedAboutPlaying()) {
480         INFO_LOG(LOGIDENTIFIER, &quot;returning FALSE: hasn&#39;t fired playing notification&quot;);
481         return false;
482     }
483 
484 #if ENABLE(FULLSCREEN_API)
485     // Elements which are not descendents of the current fullscreen element cannot be main content.
<span class="line-modified">486     auto* fullscreenElement = m_element.document().fullscreenManager().currentFullscreenElement();</span>
487     if (fullscreenElement &amp;&amp; !m_element.isDescendantOf(*fullscreenElement)) {
488         INFO_LOG(LOGIDENTIFIER, &quot;returning FALSE: outside of full screen&quot;);
489         return false;
490     }
491 #endif
492 
493     // Only allow the main content heuristic to forbid videos from showing up if our purpose is the controls manager.
494     if (purpose == PlaybackControlsPurpose::ControlsManager &amp;&amp; m_element.isVideo()) {
495         if (!m_element.renderer()) {
496             INFO_LOG(LOGIDENTIFIER, &quot;returning FALSE: no renderer&quot;);
497             return false;
498         }
499 
500         if (!m_element.hasVideo() &amp;&amp; !m_element.hasEverHadVideo()) {
501             INFO_LOG(LOGIDENTIFIER, &quot;returning FALSE: no video&quot;);
502             return false;
503         }
504 
505         if (isLargeEnoughForMainContent(MediaSessionMainContentPurpose::MediaControls)) {
506             INFO_LOG(LOGIDENTIFIER, &quot;returning TRUE: is main content&quot;);
</pre>
<hr />
<pre>
674 {
675     INFO_LOG(LOGIDENTIFIER, shouldPlay);
676     m_shouldPlayToPlaybackTarget = shouldPlay;
677     updateClientDataBuffering();
678     client().setShouldPlayToPlaybackTarget(shouldPlay);
679 }
680 
681 void MediaElementSession::mediaStateDidChange(MediaProducer::MediaStateFlags state)
682 {
683     m_element.document().playbackTargetPickerClientStateDidChange(*this, state);
684 }
685 #endif
686 
687 MediaPlayer::Preload MediaElementSession::effectivePreloadForElement() const
688 {
689     MediaPlayer::Preload preload = m_element.preloadValue();
690 
691     if (pageExplicitlyAllowsElementToAutoplayInline(m_element))
692         return preload;
693 



694     if (m_restrictions &amp; AutoPreloadingNotPermitted) {
695         if (preload &gt; MediaPlayer::MetaData)
696             return MediaPlayer::MetaData;
697     }
698 
699     return preload;
700 }
701 
702 bool MediaElementSession::requiresFullscreenForVideoPlayback() const
703 {
704     if (pageExplicitlyAllowsElementToAutoplayInline(m_element))
705         return false;
706 
707     if (is&lt;HTMLAudioElement&gt;(m_element))
708         return false;
709 
710     if (m_element.document().isMediaDocument()) {
711         ASSERT(is&lt;HTMLVideoElement&gt;(m_element));
712         const HTMLVideoElement&amp; videoElement = *downcast&lt;const HTMLVideoElement&gt;(&amp;m_element);
713         if (m_element.readyState() &lt; HTMLVideoElement::HAVE_METADATA || !videoElement.hasEverHadVideo())
</pre>
<hr />
<pre>
751 {
752     INFO_LOG(LOGIDENTIFIER);
753 
754 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
755     if (m_restrictions &amp; WirelessVideoPlaybackDisabled)
756         setWirelessVideoPlaybackDisabled(true);
757     if (m_playbackTarget)
758         client().setWirelessPlaybackTarget(*m_playbackTarget.copyRef());
759     if (m_shouldPlayToPlaybackTarget)
760         client().setShouldPlayToPlaybackTarget(true);
761 #endif
762 
763 }
764 
765 void MediaElementSession::resetPlaybackSessionState()
766 {
767     m_mostRecentUserInteractionTime = MonotonicTime();
768     addBehaviorRestriction(RequireUserGestureToControlControlsManager | RequirePlaybackToControlControlsManager);
769 }
770 
<span class="line-added">771 void MediaElementSession::suspendBuffering()</span>
<span class="line-added">772 {</span>
<span class="line-added">773     updateClientDataBuffering();</span>
<span class="line-added">774 }</span>
<span class="line-added">775 </span>
<span class="line-added">776 void MediaElementSession::resumeBuffering()</span>
<span class="line-added">777 {</span>
<span class="line-added">778     updateClientDataBuffering();</span>
<span class="line-added">779 }</span>
<span class="line-added">780 </span>
<span class="line-added">781 bool MediaElementSession::bufferingSuspended() const</span>
<span class="line-added">782 {</span>
<span class="line-added">783     if (auto* page = m_element.document().page())</span>
<span class="line-added">784         return page-&gt;mediaBufferingIsSuspended();</span>
<span class="line-added">785     return true;</span>
<span class="line-added">786 }</span>
<span class="line-added">787 </span>
788 bool MediaElementSession::allowsPictureInPicture() const
789 {
790     return m_element.document().settings().allowsPictureInPictureMediaPlayback();
791 }
792 
793 #if PLATFORM(IOS_FAMILY)
794 bool MediaElementSession::requiresPlaybackTargetRouteMonitoring() const
795 {
796     return m_hasPlaybackTargetAvailabilityListeners &amp;&amp; !m_element.elementIsHidden();
797 }
798 #endif
799 
800 #if ENABLE(MEDIA_SOURCE)
801 size_t MediaElementSession::maximumMediaSourceBufferSize(const SourceBuffer&amp; buffer) const
802 {
803     // A good quality 1080p video uses 8,000 kbps and stereo audio uses 384 kbps, so assume 95% for video and 5% for audio.
804     const float bufferBudgetPercentageForVideo = .95;
805     const float bufferBudgetPercentageForAudio = .05;
806 
807     size_t maximum = buffer.document().settings().maximumSourceBufferSize();
</pre>
<hr />
<pre>
960     m_isMainContent = isElementMainContentForPurposesOfAutoplay(m_element, true);
961 
962     if (m_isMainContent != wasMainContent)
963         m_element.updateShouldPlay();
964 
965     return m_isMainContent;
966 }
967 
968 bool MediaElementSession::allowsNowPlayingControlsVisibility() const
969 {
970     auto page = m_element.document().page();
971     return page &amp;&amp; !page-&gt;isVisibleAndActive();
972 }
973 
974 bool MediaElementSession::allowsPlaybackControlsForAutoplayingAudio() const
975 {
976     auto page = m_element.document().page();
977     return page &amp;&amp; page-&gt;allowsPlaybackControlsForAutoplayingAudio();
978 }
979 
<span class="line-added">980 String convertEnumerationToString(const MediaPlaybackDenialReason enumerationValue)</span>
<span class="line-added">981 {</span>
<span class="line-added">982     static const NeverDestroyed&lt;String&gt; values[] = {</span>
<span class="line-added">983         MAKE_STATIC_STRING_IMPL(&quot;UserGestureRequired&quot;),</span>
<span class="line-added">984         MAKE_STATIC_STRING_IMPL(&quot;FullscreenRequired&quot;),</span>
<span class="line-added">985         MAKE_STATIC_STRING_IMPL(&quot;PageConsentRequired&quot;),</span>
<span class="line-added">986         MAKE_STATIC_STRING_IMPL(&quot;InvalidState&quot;),</span>
<span class="line-added">987     };</span>
<span class="line-added">988     static_assert(static_cast&lt;size_t&gt;(MediaPlaybackDenialReason::UserGestureRequired) == 0, &quot;MediaPlaybackDenialReason::UserGestureRequired is not 0 as expected&quot;);</span>
<span class="line-added">989     static_assert(static_cast&lt;size_t&gt;(MediaPlaybackDenialReason::FullscreenRequired) == 1, &quot;MediaPlaybackDenialReason::FullscreenRequired is not 1 as expected&quot;);</span>
<span class="line-added">990     static_assert(static_cast&lt;size_t&gt;(MediaPlaybackDenialReason::PageConsentRequired) == 2, &quot;MediaPlaybackDenialReason::PageConsentRequired is not 2 as expected&quot;);</span>
<span class="line-added">991     static_assert(static_cast&lt;size_t&gt;(MediaPlaybackDenialReason::InvalidState) == 3, &quot;MediaPlaybackDenialReason::InvalidState is not 3 as expected&quot;);</span>
<span class="line-added">992     ASSERT(static_cast&lt;size_t&gt;(enumerationValue) &lt; WTF_ARRAY_LENGTH(values));</span>
<span class="line-added">993     return values[static_cast&lt;size_t&gt;(enumerationValue)];</span>
<span class="line-added">994 }</span>
<span class="line-added">995 </span>
996 }
997 
998 #endif // ENABLE(VIDEO)
</pre>
</td>
</tr>
</table>
<center><a href="MediaDocument.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="MediaElementSession.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>