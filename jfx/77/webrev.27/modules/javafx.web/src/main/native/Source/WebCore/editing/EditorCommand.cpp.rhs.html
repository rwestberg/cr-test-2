<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/editing/EditorCommand.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2006-2008, 2014, 2016 Apple Inc. All rights reserved.
   3  * Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies)
   4  * Copyright (C) 2009 Igalia S.L.
   5  *
   6  * Redistribution and use in source and binary forms, with or without
   7  * modification, are permitted provided that the following conditions
   8  * are met:
   9  * 1. Redistributions of source code must retain the above copyright
  10  *    notice, this list of conditions and the following disclaimer.
  11  * 2. Redistributions in binary form must reproduce the above copyright
  12  *    notice, this list of conditions and the following disclaimer in the
  13  *    documentation and/or other materials provided with the distribution.
  14  *
  15  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  16  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  17  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  18  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  19  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  20  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  21  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  22  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  23  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  24  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  25  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  26  */
  27 
  28 #include &quot;config.h&quot;
  29 #include &quot;Editor.h&quot;
  30 
  31 #include &quot;CSSComputedStyleDeclaration.h&quot;
  32 #include &quot;CSSValueList.h&quot;
  33 #include &quot;Chrome.h&quot;
  34 #include &quot;CreateLinkCommand.h&quot;
  35 #include &quot;DocumentFragment.h&quot;
  36 #include &quot;Editing.h&quot;
  37 #include &quot;EditorClient.h&quot;
  38 #include &quot;Event.h&quot;
  39 #include &quot;EventHandler.h&quot;
  40 #include &quot;FormatBlockCommand.h&quot;
  41 #include &quot;Frame.h&quot;
  42 #include &quot;FrameLoader.h&quot;
  43 #include &quot;FrameView.h&quot;
  44 #include &quot;HTMLFontElement.h&quot;
  45 #include &quot;HTMLHRElement.h&quot;
  46 #include &quot;HTMLImageElement.h&quot;
  47 #include &quot;HTMLNames.h&quot;
  48 #include &quot;IndentOutdentCommand.h&quot;
  49 #include &quot;InsertEditableImageCommand.h&quot;
  50 #include &quot;InsertListCommand.h&quot;
  51 #include &quot;InsertNestedListCommand.h&quot;
  52 #include &quot;Page.h&quot;
  53 #include &quot;Pasteboard.h&quot;
  54 #include &quot;RenderBox.h&quot;
  55 #include &quot;ReplaceSelectionCommand.h&quot;
  56 #include &quot;Scrollbar.h&quot;
  57 #include &quot;Settings.h&quot;
  58 #include &quot;StyleProperties.h&quot;
  59 #include &quot;TypingCommand.h&quot;
  60 #include &quot;UnlinkCommand.h&quot;
  61 #include &quot;UserGestureIndicator.h&quot;
  62 #include &quot;UserTypingGestureIndicator.h&quot;
  63 #include &quot;markup.h&quot;
  64 #include &lt;pal/system/Sound.h&gt;
  65 #include &lt;pal/text/KillRing.h&gt;
<a name="1" id="anc1"></a><span class="line-modified">  66 #include &lt;wtf/text/AtomString.h&gt;</span>
  67 
  68 namespace WebCore {
  69 
  70 using namespace HTMLNames;
  71 
  72 class EditorInternalCommand {
  73 public:
  74     bool (*execute)(Frame&amp;, Event*, EditorCommandSource, const String&amp;);
  75     bool (*isSupportedFromDOM)(Frame*);
  76     bool (*isEnabled)(Frame&amp;, Event*, EditorCommandSource);
  77     TriState (*state)(Frame&amp;, Event*);
  78     String (*value)(Frame&amp;, Event*);
  79     bool isTextInsertion;
  80     bool (*allowExecutionWhenDisabled)(Frame&amp;, EditorCommandSource);
  81 };
  82 
  83 typedef HashMap&lt;String, const EditorInternalCommand*, ASCIICaseInsensitiveHash&gt; CommandMap;
  84 
  85 static const bool notTextInsertion = false;
  86 static const bool isTextInsertion = true;
  87 
  88 // Related to Editor::selectionForCommand.
  89 // Certain operations continue to use the target control&#39;s selection even if the event handler
  90 // already moved the selection outside of the text control.
  91 static Frame* targetFrame(Frame&amp; frame, Event* event)
  92 {
  93     if (!event)
  94         return &amp;frame;
  95     if (!is&lt;Node&gt;(event-&gt;target()))
  96         return &amp;frame;
  97     return downcast&lt;Node&gt;(*event-&gt;target()).document().frame();
  98 }
  99 
 100 static bool applyCommandToFrame(Frame&amp; frame, EditorCommandSource source, EditAction action, Ref&lt;EditingStyle&gt;&amp;&amp; style)
 101 {
 102     // FIXME: We don&#39;t call shouldApplyStyle when the source is DOM; is there a good reason for that?
 103     switch (source) {
 104     case CommandFromMenuOrKeyBinding:
 105         // Use InvertColor for testing purposes. foreColor and backColor are never triggered with CommandFromMenuOrKeyBinding outside DRT/WTR.
 106         frame.editor().applyStyleToSelection(WTFMove(style), action, Editor::ColorFilterMode::InvertColor);
 107         return true;
 108     case CommandFromDOM:
 109     case CommandFromDOMWithUserInterface:
 110         frame.editor().applyStyle(WTFMove(style), EditAction::Unspecified, Editor::ColorFilterMode::UseOriginalColor);
 111         return true;
 112     }
 113     ASSERT_NOT_REACHED();
 114     return false;
 115 }
 116 
 117 static bool isStylePresent(Editor&amp; editor, CSSPropertyID propertyID, const char* onValue)
 118 {
 119     // Style is considered present when
 120     // Mac: present at the beginning of selection
 121     // Windows: present throughout the selection
 122     if (editor.behavior().shouldToggleStyleBasedOnStartOfSelection())
 123         return editor.selectionStartHasStyle(propertyID, onValue);
 124     return editor.selectionHasStyle(propertyID, onValue) == TrueTriState;
 125 }
 126 
 127 static bool executeApplyStyle(Frame&amp; frame, EditorCommandSource source, EditAction action, CSSPropertyID propertyID, const String&amp; propertyValue)
 128 {
 129     return applyCommandToFrame(frame, source, action, EditingStyle::create(propertyID, propertyValue));
 130 }
 131 
 132 static bool executeApplyStyle(Frame&amp; frame, EditorCommandSource source, EditAction action, CSSPropertyID propertyID, CSSValueID propertyValue)
 133 {
 134     return applyCommandToFrame(frame, source, action, EditingStyle::create(propertyID, propertyValue));
 135 }
 136 
 137 static bool executeToggleStyle(Frame&amp; frame, EditorCommandSource source, EditAction action, CSSPropertyID propertyID, const char* offValue, const char* onValue)
 138 {
 139     bool styleIsPresent = isStylePresent(frame.editor(), propertyID, onValue);
 140     return applyCommandToFrame(frame, source, action, EditingStyle::create(propertyID, styleIsPresent ? offValue : onValue));
 141 }
 142 
 143 static bool executeApplyParagraphStyle(Frame&amp; frame, EditorCommandSource source, EditAction action, CSSPropertyID propertyID, const String&amp; propertyValue)
 144 {
 145     auto style = MutableStyleProperties::create();
 146     style-&gt;setProperty(propertyID, propertyValue);
 147     // FIXME: We don&#39;t call shouldApplyStyle when the source is DOM; is there a good reason for that?
 148     switch (source) {
 149     case CommandFromMenuOrKeyBinding:
 150         frame.editor().applyParagraphStyleToSelection(style.ptr(), action);
 151         return true;
 152     case CommandFromDOM:
 153     case CommandFromDOMWithUserInterface:
 154         frame.editor().applyParagraphStyle(style.ptr());
 155         return true;
 156     }
 157     ASSERT_NOT_REACHED();
 158     return false;
 159 }
 160 
 161 static bool executeInsertFragment(Frame&amp; frame, Ref&lt;DocumentFragment&gt;&amp;&amp; fragment)
 162 {
 163     ASSERT(frame.document());
 164     ReplaceSelectionCommand::create(*frame.document(), WTFMove(fragment), ReplaceSelectionCommand::PreventNesting, EditAction::Insert)-&gt;apply();
 165     return true;
 166 }
 167 
 168 static bool executeInsertNode(Frame&amp; frame, Ref&lt;Node&gt;&amp;&amp; content)
 169 {
 170     auto fragment = DocumentFragment::create(*frame.document());
 171     if (fragment-&gt;appendChild(content).hasException())
 172         return false;
 173     return executeInsertFragment(frame, WTFMove(fragment));
 174 }
 175 
 176 static bool expandSelectionToGranularity(Frame&amp; frame, TextGranularity granularity)
 177 {
 178     VisibleSelection selection = frame.selection().selection();
 179     selection.expandUsingGranularity(granularity);
 180     RefPtr&lt;Range&gt; newRange = selection.toNormalizedRange();
 181     if (!newRange)
 182         return false;
 183     if (newRange-&gt;collapsed())
 184         return false;
 185     RefPtr&lt;Range&gt; oldRange = selection.toNormalizedRange();
 186     EAffinity affinity = selection.affinity();
 187     if (!frame.editor().client()-&gt;shouldChangeSelectedRange(oldRange.get(), newRange.get(), affinity, false))
 188         return false;
 189     frame.selection().setSelectedRange(newRange.get(), affinity, FrameSelection::ShouldCloseTyping::Yes);
 190     return true;
 191 }
 192 
 193 static TriState stateStyle(Frame&amp; frame, CSSPropertyID propertyID, const char* desiredValue)
 194 {
 195     if (frame.editor().behavior().shouldToggleStyleBasedOnStartOfSelection())
 196         return frame.editor().selectionStartHasStyle(propertyID, desiredValue) ? TrueTriState : FalseTriState;
 197     return frame.editor().selectionHasStyle(propertyID, desiredValue);
 198 }
 199 
 200 static String valueStyle(Frame&amp; frame, CSSPropertyID propertyID)
 201 {
 202     // FIXME: Rather than retrieving the style at the start of the current selection,
 203     // we should retrieve the style present throughout the selection for non-Mac platforms.
 204     return frame.editor().selectionStartCSSPropertyValue(propertyID);
 205 }
 206 
 207 static TriState stateTextWritingDirection(Frame&amp; frame, WritingDirection direction)
 208 {
 209     bool hasNestedOrMultipleEmbeddings;
 210     WritingDirection selectionDirection = EditingStyle::textDirectionForSelection(frame.selection().selection(),
 211         frame.selection().typingStyle(), hasNestedOrMultipleEmbeddings);
 212     // FXIME: We should be returning MixedTriState when selectionDirection == direction &amp;&amp; hasNestedOrMultipleEmbeddings
 213     return (selectionDirection == direction &amp;&amp; !hasNestedOrMultipleEmbeddings) ? TrueTriState : FalseTriState;
 214 }
 215 
 216 static unsigned verticalScrollDistance(Frame&amp; frame)
 217 {
 218     Element* focusedElement = frame.document()-&gt;focusedElement();
 219     if (!focusedElement)
 220         return 0;
 221     auto* renderer = focusedElement-&gt;renderer();
 222     if (!is&lt;RenderBox&gt;(renderer))
 223         return 0;
 224     const RenderStyle&amp; style = renderer-&gt;style();
 225     if (!(style.overflowY() == Overflow::Scroll || style.overflowY() == Overflow::Auto || focusedElement-&gt;hasEditableStyle()))
 226         return 0;
 227     int height = std::min&lt;int&gt;(downcast&lt;RenderBox&gt;(*renderer).clientHeight(), frame.view()-&gt;visibleHeight());
 228     return static_cast&lt;unsigned&gt;(Scrollbar::pageStep(height));
 229 }
 230 
 231 static RefPtr&lt;Range&gt; unionDOMRanges(Range&amp; a, Range&amp; b)
 232 {
 233     Range&amp; start = a.compareBoundaryPoints(Range::START_TO_START, b).releaseReturnValue() &lt;= 0 ? a : b;
 234     Range&amp; end = a.compareBoundaryPoints(Range::END_TO_END, b).releaseReturnValue() &lt;= 0 ? b : a;
 235     return Range::create(a.ownerDocument(), &amp;start.startContainer(), start.startOffset(), &amp;end.endContainer(), end.endOffset());
 236 }
 237 
 238 // Execute command functions
 239 
 240 static bool executeBackColor(Frame&amp; frame, Event*, EditorCommandSource source, const String&amp; value)
 241 {
 242     return executeApplyStyle(frame, source, EditAction::SetBackgroundColor, CSSPropertyBackgroundColor, value);
 243 }
 244 
 245 static bool executeCopy(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 246 {
 247     frame.editor().copy();
 248     return true;
 249 }
 250 
 251 static bool executeCreateLink(Frame&amp; frame, Event*, EditorCommandSource, const String&amp; value)
 252 {
 253     // FIXME: If userInterface is true, we should display a dialog box to let the user enter a URL.
 254     if (value.isEmpty())
 255         return false;
 256     ASSERT(frame.document());
 257     CreateLinkCommand::create(*frame.document(), value)-&gt;apply();
 258     return true;
 259 }
 260 
 261 static bool executeCut(Frame&amp; frame, Event*, EditorCommandSource source, const String&amp;)
 262 {
 263     if (source == CommandFromMenuOrKeyBinding) {
 264         UserTypingGestureIndicator typingGestureIndicator(frame);
 265         frame.editor().cut();
 266     } else
 267         frame.editor().cut();
 268     return true;
 269 }
 270 
 271 static bool executeClearText(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 272 {
 273     frame.editor().clearText();
 274     return true;
 275 }
 276 
 277 static bool executeDefaultParagraphSeparator(Frame&amp; frame, Event*, EditorCommandSource, const String&amp; value)
 278 {
 279     if (equalLettersIgnoringASCIICase(value, &quot;div&quot;))
 280         frame.editor().setDefaultParagraphSeparator(EditorParagraphSeparatorIsDiv);
 281     else if (equalLettersIgnoringASCIICase(value, &quot;p&quot;))
 282         frame.editor().setDefaultParagraphSeparator(EditorParagraphSeparatorIsP);
 283 
 284     return true;
 285 }
 286 
 287 static bool executeDelete(Frame&amp; frame, Event*, EditorCommandSource source, const String&amp;)
 288 {
 289     switch (source) {
 290     case CommandFromMenuOrKeyBinding: {
 291         // Doesn&#39;t modify the text if the current selection isn&#39;t a range.
 292         UserTypingGestureIndicator typingGestureIndicator(frame);
 293         frame.editor().performDelete();
 294         return true;
 295     }
 296     case CommandFromDOM:
 297     case CommandFromDOMWithUserInterface:
 298         // If the current selection is a caret, delete the preceding character. IE performs forwardDelete, but we currently side with Firefox.
 299         // Doesn&#39;t scroll to make the selection visible, or modify the kill ring (this time, siding with IE, not Firefox).
<a name="2" id="anc2"></a><span class="line-modified"> 300         TypingCommand::deleteKeyPressed(*frame.document(), frame.editor().shouldSmartDelete() ? TypingCommand::SmartDelete : 0);</span>
 301         return true;
 302     }
 303     ASSERT_NOT_REACHED();
 304     return false;
 305 }
 306 
 307 static bool executeDeleteBackward(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 308 {
 309     frame.editor().deleteWithDirection(DirectionBackward, CharacterGranularity, false, true);
 310     return true;
 311 }
 312 
 313 static bool executeDeleteBackwardByDecomposingPreviousCharacter(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 314 {
 315     LOG_ERROR(&quot;DeleteBackwardByDecomposingPreviousCharacter is not implemented, doing DeleteBackward instead&quot;);
 316     frame.editor().deleteWithDirection(DirectionBackward, CharacterGranularity, false, true);
 317     return true;
 318 }
 319 
 320 static bool executeDeleteForward(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 321 {
 322     frame.editor().deleteWithDirection(DirectionForward, CharacterGranularity, false, true);
 323     return true;
 324 }
 325 
 326 static bool executeDeleteToBeginningOfLine(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 327 {
 328     frame.editor().deleteWithDirection(DirectionBackward, LineBoundary, true, false);
 329     return true;
 330 }
 331 
 332 static bool executeDeleteToBeginningOfParagraph(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 333 {
 334     frame.editor().deleteWithDirection(DirectionBackward, ParagraphBoundary, true, false);
 335     return true;
 336 }
 337 
 338 static bool executeDeleteToEndOfLine(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 339 {
 340     // Despite its name, this command should delete the newline at the end of
 341     // a paragraph if you are at the end of a paragraph (like DeleteToEndOfParagraph).
 342     frame.editor().deleteWithDirection(DirectionForward, LineBoundary, true, false);
 343     return true;
 344 }
 345 
 346 static bool executeDeleteToEndOfParagraph(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 347 {
 348     // Despite its name, this command should delete the newline at the end of
 349     // a paragraph if you are at the end of a paragraph.
 350     frame.editor().deleteWithDirection(DirectionForward, ParagraphBoundary, true, false);
 351     return true;
 352 }
 353 
 354 static bool executeDeleteToMark(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 355 {
 356     RefPtr&lt;Range&gt; mark = frame.editor().mark().toNormalizedRange();
 357     FrameSelection&amp; selection = frame.selection();
 358     if (mark &amp;&amp; frame.editor().selectedRange()) {
 359         bool selected = selection.setSelectedRange(unionDOMRanges(*mark, *frame.editor().selectedRange()).get(), DOWNSTREAM, FrameSelection::ShouldCloseTyping::Yes);
 360         ASSERT(selected);
 361         if (!selected)
 362             return false;
 363     }
 364     frame.editor().performDelete();
 365     frame.editor().setMark(selection.selection());
 366     return true;
 367 }
 368 
 369 static bool executeDeleteWordBackward(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 370 {
 371     frame.editor().deleteWithDirection(DirectionBackward, WordGranularity, true, false);
 372     return true;
 373 }
 374 
 375 static bool executeDeleteWordForward(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 376 {
 377     frame.editor().deleteWithDirection(DirectionForward, WordGranularity, true, false);
 378     return true;
 379 }
 380 
 381 static bool executeFindString(Frame&amp; frame, Event*, EditorCommandSource, const String&amp; value)
 382 {
 383     return frame.editor().findString(value, { CaseInsensitive, WrapAround, DoNotTraverseFlatTree });
 384 }
 385 
 386 static bool executeFontName(Frame&amp; frame, Event*, EditorCommandSource source, const String&amp; value)
 387 {
 388     return executeApplyStyle(frame, source, EditAction::SetFont, CSSPropertyFontFamily, value);
 389 }
 390 
 391 static bool executeFontSize(Frame&amp; frame, Event*, EditorCommandSource source, const String&amp; value)
 392 {
 393     CSSValueID size;
 394     if (!HTMLFontElement::cssValueFromFontSizeNumber(value, size))
 395         return false;
 396     return executeApplyStyle(frame, source, EditAction::ChangeAttributes, CSSPropertyFontSize, size);
 397 }
 398 
 399 static bool executeFontSizeDelta(Frame&amp; frame, Event*, EditorCommandSource source, const String&amp; value)
 400 {
 401     return executeApplyStyle(frame, source, EditAction::ChangeAttributes, CSSPropertyWebkitFontSizeDelta, value);
 402 }
 403 
 404 static bool executeForeColor(Frame&amp; frame, Event*, EditorCommandSource source, const String&amp; value)
 405 {
 406     return executeApplyStyle(frame, source, EditAction::SetColor, CSSPropertyColor, value);
 407 }
 408 
 409 static bool executeFormatBlock(Frame&amp; frame, Event*, EditorCommandSource, const String&amp; value)
 410 {
 411     String tagName = value.convertToASCIILowercase();
 412     if (tagName[0] == &#39;&lt;&#39; &amp;&amp; tagName[tagName.length() - 1] == &#39;&gt;&#39;)
 413         tagName = tagName.substring(1, tagName.length() - 2);
 414 
 415     auto qualifiedTagName = Document::parseQualifiedName(xhtmlNamespaceURI, tagName);
 416     if (qualifiedTagName.hasException())
 417         return false;
 418 
 419     ASSERT(frame.document());
 420     auto command = FormatBlockCommand::create(*frame.document(), qualifiedTagName.releaseReturnValue());
 421     command-&gt;apply();
 422     return command-&gt;didApply();
 423 }
 424 
 425 static bool executeForwardDelete(Frame&amp; frame, Event*, EditorCommandSource source, const String&amp;)
 426 {
 427     switch (source) {
 428     case CommandFromMenuOrKeyBinding:
 429         frame.editor().deleteWithDirection(DirectionForward, CharacterGranularity, false, true);
 430         return true;
 431     case CommandFromDOM:
 432     case CommandFromDOMWithUserInterface:
 433         // Doesn&#39;t scroll to make the selection visible, or modify the kill ring.
 434         // ForwardDelete is not implemented in IE or Firefox, so this behavior is only needed for
 435         // backward compatibility with ourselves, and for consistency with Delete.
 436         TypingCommand::forwardDeleteKeyPressed(*frame.document());
 437         return true;
 438     }
 439     ASSERT_NOT_REACHED();
 440     return false;
 441 }
 442 
 443 static bool executeIgnoreSpelling(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 444 {
 445     frame.editor().ignoreSpelling();
 446     return true;
 447 }
 448 
 449 static bool executeIndent(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 450 {
 451     ASSERT(frame.document());
 452     IndentOutdentCommand::create(*frame.document(), IndentOutdentCommand::Indent)-&gt;apply();
 453     return true;
 454 }
 455 
 456 static bool executeInsertBacktab(Frame&amp; frame, Event* event, EditorCommandSource, const String&amp;)
 457 {
 458     return targetFrame(frame, event)-&gt;eventHandler().handleTextInputEvent(&quot;\t&quot;_s, event, TextEventInputBackTab);
 459 }
 460 
 461 static bool executeInsertHorizontalRule(Frame&amp; frame, Event*, EditorCommandSource, const String&amp; value)
 462 {
 463     Ref&lt;HTMLHRElement&gt; rule = HTMLHRElement::create(*frame.document());
 464     if (!value.isEmpty())
 465         rule-&gt;setIdAttribute(value);
 466     return executeInsertNode(frame, WTFMove(rule));
 467 }
 468 
 469 static bool executeInsertHTML(Frame&amp; frame, Event*, EditorCommandSource, const String&amp; value)
 470 {
 471     return executeInsertFragment(frame, createFragmentFromMarkup(*frame.document(), value, emptyString()));
 472 }
 473 
 474 static bool executeInsertImage(Frame&amp; frame, Event*, EditorCommandSource, const String&amp; value)
 475 {
 476     // FIXME: If userInterface is true, we should display a dialog box and let the user choose a local image.
 477     Ref&lt;HTMLImageElement&gt; image = HTMLImageElement::create(*frame.document());
 478     image-&gt;setSrc(value);
 479     return executeInsertNode(frame, WTFMove(image));
 480 }
 481 
 482 static bool executeInsertEditableImage(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 483 {
 484     ASSERT(frame.document());
 485     InsertEditableImageCommand::create(*frame.document())-&gt;apply();
 486     return true;
 487 }
 488 
 489 static bool executeInsertLineBreak(Frame&amp; frame, Event* event, EditorCommandSource source, const String&amp;)
 490 {
 491     switch (source) {
 492     case CommandFromMenuOrKeyBinding:
 493         return targetFrame(frame, event)-&gt;eventHandler().handleTextInputEvent(&quot;\n&quot;_s, event, TextEventInputLineBreak);
 494     case CommandFromDOM:
 495     case CommandFromDOMWithUserInterface:
 496         // Doesn&#39;t scroll to make the selection visible, or modify the kill ring.
 497         // InsertLineBreak is not implemented in IE or Firefox, so this behavior is only needed for
 498         // backward compatibility with ourselves, and for consistency with other commands.
 499         TypingCommand::insertLineBreak(*frame.document(), 0);
 500         return true;
 501     }
 502     ASSERT_NOT_REACHED();
 503     return false;
 504 }
 505 
 506 static bool executeInsertNewline(Frame&amp; frame, Event* event, EditorCommandSource, const String&amp;)
 507 {
 508     Frame* targetFrame = WebCore::targetFrame(frame, event);
 509     return targetFrame-&gt;eventHandler().handleTextInputEvent(&quot;\n&quot;_s, event, targetFrame-&gt;editor().canEditRichly() ? TextEventInputKeyboard : TextEventInputLineBreak);
 510 }
 511 
 512 static bool executeInsertNewlineInQuotedContent(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 513 {
 514     TypingCommand::insertParagraphSeparatorInQuotedContent(*frame.document());
 515     return true;
 516 }
 517 
 518 static bool executeInsertOrderedList(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 519 {
 520     ASSERT(frame.document());
 521     InsertListCommand::create(*frame.document(), InsertListCommand::Type::OrderedList)-&gt;apply();
 522     return true;
 523 }
 524 
 525 static bool executeInsertParagraph(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 526 {
 527     TypingCommand::insertParagraphSeparator(*frame.document(), 0);
 528     return true;
 529 }
 530 
 531 static bool executeInsertTab(Frame&amp; frame, Event* event, EditorCommandSource, const String&amp;)
 532 {
 533     return targetFrame(frame, event)-&gt;eventHandler().handleTextInputEvent(&quot;\t&quot;_s, event);
 534 }
 535 
 536 static bool executeInsertText(Frame&amp; frame, Event*, EditorCommandSource, const String&amp; value)
 537 {
 538     TypingCommand::insertText(*frame.document(), value, 0);
 539     return true;
 540 }
 541 
 542 static bool executeInsertUnorderedList(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 543 {
 544     ASSERT(frame.document());
 545     InsertListCommand::create(*frame.document(), InsertListCommand::Type::UnorderedList)-&gt;apply();
 546     return true;
 547 }
 548 
 549 static bool executeInsertNestedUnorderedList(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 550 {
 551     ASSERT(frame.document());
 552     InsertNestedListCommand::insertUnorderedList(*frame.document());
 553     return true;
 554 }
 555 
 556 static bool executeInsertNestedOrderedList(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 557 {
 558     ASSERT(frame.document());
 559     InsertNestedListCommand::insertOrderedList(*frame.document());
 560     return true;
 561 }
 562 
 563 static bool executeJustifyCenter(Frame&amp; frame, Event*, EditorCommandSource source, const String&amp;)
 564 {
 565     return executeApplyParagraphStyle(frame, source, EditAction::Center, CSSPropertyTextAlign, &quot;center&quot;_s);
 566 }
 567 
 568 static bool executeJustifyFull(Frame&amp; frame, Event*, EditorCommandSource source, const String&amp;)
 569 {
 570     return executeApplyParagraphStyle(frame, source, EditAction::Justify, CSSPropertyTextAlign, &quot;justify&quot;_s);
 571 }
 572 
 573 static bool executeJustifyLeft(Frame&amp; frame, Event*, EditorCommandSource source, const String&amp;)
 574 {
 575     return executeApplyParagraphStyle(frame, source, EditAction::AlignLeft, CSSPropertyTextAlign, &quot;left&quot;_s);
 576 }
 577 
 578 static bool executeJustifyRight(Frame&amp; frame, Event*, EditorCommandSource source, const String&amp;)
 579 {
 580     return executeApplyParagraphStyle(frame, source, EditAction::AlignRight, CSSPropertyTextAlign, &quot;right&quot;_s);
 581 }
 582 
 583 static bool executeMakeTextWritingDirectionLeftToRight(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 584 {
 585     auto style = MutableStyleProperties::create();
 586     style-&gt;setProperty(CSSPropertyUnicodeBidi, CSSValueEmbed);
 587     style-&gt;setProperty(CSSPropertyDirection, CSSValueLtr);
<a name="3" id="anc3"></a><span class="line-modified"> 588     frame.editor().applyStyle(style.ptr(), EditAction::SetInlineWritingDirection);</span>
 589     return true;
 590 }
 591 
 592 static bool executeMakeTextWritingDirectionNatural(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 593 {
 594     auto style = MutableStyleProperties::create();
 595     style-&gt;setProperty(CSSPropertyUnicodeBidi, CSSValueNormal);
<a name="4" id="anc4"></a><span class="line-modified"> 596     frame.editor().applyStyle(style.ptr(), EditAction::SetInlineWritingDirection);</span>
 597     return true;
 598 }
 599 
 600 static bool executeMakeTextWritingDirectionRightToLeft(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 601 {
 602     auto style = MutableStyleProperties::create();
 603     style-&gt;setProperty(CSSPropertyUnicodeBidi, CSSValueEmbed);
 604     style-&gt;setProperty(CSSPropertyDirection, CSSValueRtl);
<a name="5" id="anc5"></a><span class="line-modified"> 605     frame.editor().applyStyle(style.ptr(), EditAction::SetInlineWritingDirection);</span>
 606     return true;
 607 }
 608 
 609 static bool executeMoveBackward(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 610 {
 611     frame.selection().modify(FrameSelection::AlterationMove, DirectionBackward, CharacterGranularity, UserTriggered);
 612     return true;
 613 }
 614 
 615 static bool executeMoveBackwardAndModifySelection(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 616 {
 617     frame.selection().modify(FrameSelection::AlterationExtend, DirectionBackward, CharacterGranularity, UserTriggered);
 618     return true;
 619 }
 620 
 621 static bool executeMoveDown(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 622 {
 623     return frame.selection().modify(FrameSelection::AlterationMove, DirectionForward, LineGranularity, UserTriggered);
 624 }
 625 
 626 static bool executeMoveDownAndModifySelection(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 627 {
 628     frame.selection().modify(FrameSelection::AlterationExtend, DirectionForward, LineGranularity, UserTriggered);
 629     return true;
 630 }
 631 
 632 static bool executeMoveForward(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 633 {
 634     frame.selection().modify(FrameSelection::AlterationMove, DirectionForward, CharacterGranularity, UserTriggered);
 635     return true;
 636 }
 637 
 638 static bool executeMoveForwardAndModifySelection(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 639 {
 640     frame.selection().modify(FrameSelection::AlterationExtend, DirectionForward, CharacterGranularity, UserTriggered);
 641     return true;
 642 }
 643 
 644 static bool executeMoveLeft(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 645 {
 646     return frame.selection().modify(FrameSelection::AlterationMove, DirectionLeft, CharacterGranularity, UserTriggered);
 647 }
 648 
 649 static bool executeMoveLeftAndModifySelection(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 650 {
 651     frame.selection().modify(FrameSelection::AlterationExtend, DirectionLeft, CharacterGranularity, UserTriggered);
 652     return true;
 653 }
 654 
 655 static bool executeMovePageDown(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 656 {
 657     unsigned distance = verticalScrollDistance(frame);
 658     if (!distance)
 659         return false;
 660     return frame.selection().modify(FrameSelection::AlterationMove, distance, FrameSelection::DirectionDown,
 661         UserTriggered, FrameSelection::AlignCursorOnScrollAlways);
 662 }
 663 
 664 static bool executeMovePageDownAndModifySelection(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 665 {
 666     unsigned distance = verticalScrollDistance(frame);
 667     if (!distance)
 668         return false;
 669     return frame.selection().modify(FrameSelection::AlterationExtend, distance, FrameSelection::DirectionDown,
 670         UserTriggered, FrameSelection::AlignCursorOnScrollAlways);
 671 }
 672 
 673 static bool executeMovePageUp(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 674 {
 675     unsigned distance = verticalScrollDistance(frame);
 676     if (!distance)
 677         return false;
 678     return frame.selection().modify(FrameSelection::AlterationMove, distance, FrameSelection::DirectionUp,
 679         UserTriggered, FrameSelection::AlignCursorOnScrollAlways);
 680 }
 681 
 682 static bool executeMovePageUpAndModifySelection(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 683 {
 684     unsigned distance = verticalScrollDistance(frame);
 685     if (!distance)
 686         return false;
 687     return frame.selection().modify(FrameSelection::AlterationExtend, distance, FrameSelection::DirectionUp,
 688         UserTriggered, FrameSelection::AlignCursorOnScrollAlways);
 689 }
 690 
 691 static bool executeMoveRight(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 692 {
 693     return frame.selection().modify(FrameSelection::AlterationMove, DirectionRight, CharacterGranularity, UserTriggered);
 694 }
 695 
 696 static bool executeMoveRightAndModifySelection(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 697 {
 698     frame.selection().modify(FrameSelection::AlterationExtend, DirectionRight, CharacterGranularity, UserTriggered);
 699     return true;
 700 }
 701 
 702 static bool executeMoveToBeginningOfDocument(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 703 {
 704     frame.selection().modify(FrameSelection::AlterationMove, DirectionBackward, DocumentBoundary, UserTriggered);
 705     return true;
 706 }
 707 
 708 static bool executeMoveToBeginningOfDocumentAndModifySelection(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 709 {
 710     frame.selection().modify(FrameSelection::AlterationExtend, DirectionBackward, DocumentBoundary, UserTriggered);
 711     return true;
 712 }
 713 
 714 static bool executeMoveToBeginningOfLine(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 715 {
 716     frame.selection().modify(FrameSelection::AlterationMove, DirectionBackward, LineBoundary, UserTriggered);
 717     return true;
 718 }
 719 
 720 static bool executeMoveToBeginningOfLineAndModifySelection(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 721 {
 722     frame.selection().modify(FrameSelection::AlterationExtend, DirectionBackward, LineBoundary, UserTriggered);
 723     return true;
 724 }
 725 
 726 static bool executeMoveToBeginningOfParagraph(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 727 {
 728     frame.selection().modify(FrameSelection::AlterationMove, DirectionBackward, ParagraphBoundary, UserTriggered);
 729     return true;
 730 }
 731 
 732 static bool executeMoveToBeginningOfParagraphAndModifySelection(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 733 {
 734     frame.selection().modify(FrameSelection::AlterationExtend, DirectionBackward, ParagraphBoundary, UserTriggered);
 735     return true;
 736 }
 737 
 738 static bool executeMoveToBeginningOfSentence(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 739 {
 740     frame.selection().modify(FrameSelection::AlterationMove, DirectionBackward, SentenceBoundary, UserTriggered);
 741     return true;
 742 }
 743 
 744 static bool executeMoveToBeginningOfSentenceAndModifySelection(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 745 {
 746     frame.selection().modify(FrameSelection::AlterationExtend, DirectionBackward, SentenceBoundary, UserTriggered);
 747     return true;
 748 }
 749 
 750 static bool executeMoveToEndOfDocument(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 751 {
 752     frame.selection().modify(FrameSelection::AlterationMove, DirectionForward, DocumentBoundary, UserTriggered);
 753     return true;
 754 }
 755 
 756 static bool executeMoveToEndOfDocumentAndModifySelection(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 757 {
 758     frame.selection().modify(FrameSelection::AlterationExtend, DirectionForward, DocumentBoundary, UserTriggered);
 759     return true;
 760 }
 761 
 762 static bool executeMoveToEndOfSentence(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 763 {
 764     frame.selection().modify(FrameSelection::AlterationMove, DirectionForward, SentenceBoundary, UserTriggered);
 765     return true;
 766 }
 767 
 768 static bool executeMoveToEndOfSentenceAndModifySelection(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 769 {
 770     frame.selection().modify(FrameSelection::AlterationExtend, DirectionForward, SentenceBoundary, UserTriggered);
 771     return true;
 772 }
 773 
 774 static bool executeMoveToEndOfLine(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 775 {
 776     frame.selection().modify(FrameSelection::AlterationMove, DirectionForward, LineBoundary, UserTriggered);
 777     return true;
 778 }
 779 
 780 static bool executeMoveToEndOfLineAndModifySelection(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 781 {
 782     frame.selection().modify(FrameSelection::AlterationExtend, DirectionForward, LineBoundary, UserTriggered);
 783     return true;
 784 }
 785 
 786 static bool executeMoveToEndOfParagraph(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 787 {
 788     frame.selection().modify(FrameSelection::AlterationMove, DirectionForward, ParagraphBoundary, UserTriggered);
 789     return true;
 790 }
 791 
 792 static bool executeMoveToEndOfParagraphAndModifySelection(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 793 {
 794     frame.selection().modify(FrameSelection::AlterationExtend, DirectionForward, ParagraphBoundary, UserTriggered);
 795     return true;
 796 }
 797 
 798 static bool executeMoveParagraphBackwardAndModifySelection(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 799 {
 800     frame.selection().modify(FrameSelection::AlterationExtend, DirectionBackward, ParagraphGranularity, UserTriggered);
 801     return true;
 802 }
 803 
 804 static bool executeMoveParagraphForwardAndModifySelection(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 805 {
 806     frame.selection().modify(FrameSelection::AlterationExtend, DirectionForward, ParagraphGranularity, UserTriggered);
 807     return true;
 808 }
 809 
 810 static bool executeMoveUp(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 811 {
 812     return frame.selection().modify(FrameSelection::AlterationMove, DirectionBackward, LineGranularity, UserTriggered);
 813 }
 814 
 815 static bool executeMoveUpAndModifySelection(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 816 {
 817     frame.selection().modify(FrameSelection::AlterationExtend, DirectionBackward, LineGranularity, UserTriggered);
 818     return true;
 819 }
 820 
 821 static bool executeMoveWordBackward(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 822 {
 823     frame.selection().modify(FrameSelection::AlterationMove, DirectionBackward, WordGranularity, UserTriggered);
 824     return true;
 825 }
 826 
 827 static bool executeMoveWordBackwardAndModifySelection(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 828 {
 829     frame.selection().modify(FrameSelection::AlterationExtend, DirectionBackward, WordGranularity, UserTriggered);
 830     return true;
 831 }
 832 
 833 static bool executeMoveWordForward(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 834 {
 835     frame.selection().modify(FrameSelection::AlterationMove, DirectionForward, WordGranularity, UserTriggered);
 836     return true;
 837 }
 838 
 839 static bool executeMoveWordForwardAndModifySelection(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 840 {
 841     frame.selection().modify(FrameSelection::AlterationExtend, DirectionForward, WordGranularity, UserTriggered);
 842     return true;
 843 }
 844 
 845 static bool executeMoveWordLeft(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 846 {
 847     frame.selection().modify(FrameSelection::AlterationMove, DirectionLeft, WordGranularity, UserTriggered);
 848     return true;
 849 }
 850 
 851 static bool executeMoveWordLeftAndModifySelection(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 852 {
 853     frame.selection().modify(FrameSelection::AlterationExtend, DirectionLeft, WordGranularity, UserTriggered);
 854     return true;
 855 }
 856 
 857 static bool executeMoveWordRight(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 858 {
 859     frame.selection().modify(FrameSelection::AlterationMove, DirectionRight, WordGranularity, UserTriggered);
 860     return true;
 861 }
 862 
 863 static bool executeMoveWordRightAndModifySelection(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 864 {
 865     frame.selection().modify(FrameSelection::AlterationExtend, DirectionRight, WordGranularity, UserTriggered);
 866     return true;
 867 }
 868 
 869 static bool executeMoveToLeftEndOfLine(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 870 {
 871     frame.selection().modify(FrameSelection::AlterationMove, DirectionLeft, LineBoundary, UserTriggered);
 872     return true;
 873 }
 874 
 875 static bool executeMoveToLeftEndOfLineAndModifySelection(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 876 {
 877     frame.selection().modify(FrameSelection::AlterationExtend, DirectionLeft, LineBoundary, UserTriggered);
 878     return true;
 879 }
 880 
 881 static bool executeMoveToRightEndOfLine(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 882 {
 883     frame.selection().modify(FrameSelection::AlterationMove, DirectionRight, LineBoundary, UserTriggered);
 884     return true;
 885 }
 886 
 887 static bool executeMoveToRightEndOfLineAndModifySelection(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 888 {
 889     frame.selection().modify(FrameSelection::AlterationExtend, DirectionRight, LineBoundary, UserTriggered);
 890     return true;
 891 }
 892 
 893 static bool executeOutdent(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 894 {
 895     ASSERT(frame.document());
 896     IndentOutdentCommand::create(*frame.document(), IndentOutdentCommand::Outdent)-&gt;apply();
 897     return true;
 898 }
 899 
 900 static bool executeToggleOverwrite(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 901 {
 902     frame.editor().toggleOverwriteModeEnabled();
 903     return true;
 904 }
 905 
 906 static bool executePaste(Frame&amp; frame, Event*, EditorCommandSource source, const String&amp;)
 907 {
 908     if (source == CommandFromMenuOrKeyBinding) {
 909         UserTypingGestureIndicator typingGestureIndicator(frame);
 910         frame.editor().paste();
<a name="6" id="anc6"></a><span class="line-modified"> 911         return true;</span>
<span class="line-modified"> 912     }</span>
<span class="line-added"> 913 </span>
<span class="line-added"> 914     if (!frame.requestDOMPasteAccess())</span>
<span class="line-added"> 915         return false;</span>
<span class="line-added"> 916 </span>
<span class="line-added"> 917     frame.editor().paste();</span>
 918     return true;
 919 }
 920 
 921 #if PLATFORM(GTK)
 922 
 923 static bool executePasteGlobalSelection(Frame&amp; frame, Event*, EditorCommandSource source, const String&amp;)
 924 {
 925     // FIXME: This check should be in an enable function, not here.
 926     if (!frame.editor().client()-&gt;supportsGlobalSelection())
 927         return false;
 928 
 929     ASSERT_UNUSED(source, source == CommandFromMenuOrKeyBinding);
 930     UserTypingGestureIndicator typingGestureIndicator(frame);
 931     frame.editor().paste(*Pasteboard::createForGlobalSelection());
 932     return true;
 933 }
 934 
 935 #endif
 936 
 937 static bool executePasteAndMatchStyle(Frame&amp; frame, Event*, EditorCommandSource source, const String&amp;)
 938 {
 939     if (source == CommandFromMenuOrKeyBinding) {
 940         UserTypingGestureIndicator typingGestureIndicator(frame);
 941         frame.editor().pasteAsPlainText();
<a name="7" id="anc7"></a><span class="line-modified"> 942         return true;</span>
<span class="line-modified"> 943     }</span>
<span class="line-added"> 944 </span>
<span class="line-added"> 945     if (!frame.requestDOMPasteAccess())</span>
<span class="line-added"> 946         return false;</span>
<span class="line-added"> 947 </span>
<span class="line-added"> 948     frame.editor().pasteAsPlainText();</span>
 949     return true;
 950 }
 951 
 952 static bool executePasteAsPlainText(Frame&amp; frame, Event*, EditorCommandSource source, const String&amp;)
 953 {
 954     if (source == CommandFromMenuOrKeyBinding) {
 955         UserTypingGestureIndicator typingGestureIndicator(frame);
 956         frame.editor().pasteAsPlainText();
<a name="8" id="anc8"></a><span class="line-modified"> 957         return true;</span>
<span class="line-modified"> 958     }</span>
<span class="line-added"> 959 </span>
<span class="line-added"> 960     if (!frame.requestDOMPasteAccess())</span>
<span class="line-added"> 961         return false;</span>
<span class="line-added"> 962 </span>
<span class="line-added"> 963     frame.editor().pasteAsPlainText();</span>
 964     return true;
 965 }
 966 
 967 static bool executePasteAsQuotation(Frame&amp; frame, Event*, EditorCommandSource source, const String&amp;)
 968 {
 969     if (source == CommandFromMenuOrKeyBinding) {
 970         UserTypingGestureIndicator typingGestureIndicator(frame);
 971         frame.editor().pasteAsQuotation();
<a name="9" id="anc9"></a><span class="line-modified"> 972         return true;</span>
<span class="line-modified"> 973     }</span>
<span class="line-added"> 974 </span>
<span class="line-added"> 975     if (!frame.requestDOMPasteAccess())</span>
<span class="line-added"> 976         return false;</span>
<span class="line-added"> 977 </span>
<span class="line-added"> 978     frame.editor().pasteAsQuotation();</span>
 979     return true;
 980 }
 981 
 982 static bool executePrint(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 983 {
 984     Page* page = frame.page();
 985     if (!page)
 986         return false;
 987     return page-&gt;chrome().print(frame);
 988 }
 989 
 990 static bool executeRedo(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 991 {
 992     frame.editor().redo();
 993     return true;
 994 }
 995 
 996 static bool executeRemoveFormat(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 997 {
 998     frame.editor().removeFormattingAndStyle();
 999     return true;
1000 }
1001 
1002 static bool executeScrollPageBackward(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
1003 {
1004     return frame.eventHandler().logicalScrollRecursively(ScrollBlockDirectionBackward, ScrollByPage);
1005 }
1006 
1007 static bool executeScrollPageForward(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
1008 {
1009     return frame.eventHandler().logicalScrollRecursively(ScrollBlockDirectionForward, ScrollByPage);
1010 }
1011 
1012 static bool executeScrollLineUp(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
1013 {
1014     return frame.eventHandler().scrollRecursively(ScrollUp, ScrollByLine);
1015 }
1016 
1017 static bool executeScrollLineDown(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
1018 {
1019     return frame.eventHandler().scrollRecursively(ScrollDown, ScrollByLine);
1020 }
1021 
1022 static bool executeScrollToBeginningOfDocument(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
1023 {
1024     return frame.eventHandler().logicalScrollRecursively(ScrollBlockDirectionBackward, ScrollByDocument);
1025 }
1026 
1027 static bool executeScrollToEndOfDocument(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
1028 {
1029     return frame.eventHandler().logicalScrollRecursively(ScrollBlockDirectionForward, ScrollByDocument);
1030 }
1031 
1032 static bool executeSelectAll(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
1033 {
1034     frame.selection().selectAll();
1035     return true;
1036 }
1037 
1038 static bool executeSelectLine(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
1039 {
1040     return expandSelectionToGranularity(frame, LineGranularity);
1041 }
1042 
1043 static bool executeSelectParagraph(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
1044 {
1045     return expandSelectionToGranularity(frame, ParagraphGranularity);
1046 }
1047 
1048 static bool executeSelectSentence(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
1049 {
1050     return expandSelectionToGranularity(frame, SentenceGranularity);
1051 }
1052 
1053 static bool executeSelectToMark(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
1054 {
1055     RefPtr&lt;Range&gt; mark = frame.editor().mark().toNormalizedRange();
1056     RefPtr&lt;Range&gt; selection = frame.editor().selectedRange();
1057     if (!mark || !selection) {
1058         PAL::systemBeep();
1059         return false;
1060     }
1061     frame.selection().setSelectedRange(unionDOMRanges(*mark, *selection).get(), DOWNSTREAM, FrameSelection::ShouldCloseTyping::Yes);
1062     return true;
1063 }
1064 
1065 static bool executeSelectWord(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
1066 {
1067     return expandSelectionToGranularity(frame, WordGranularity);
1068 }
1069 
1070 static bool executeSetMark(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
1071 {
1072     frame.editor().setMark(frame.selection().selection());
1073     return true;
1074 }
1075 
1076 static TextDecorationChange textDecorationChangeForToggling(Editor&amp; editor, CSSPropertyID propertyID, const char* onValue)
1077 {
1078     return isStylePresent(editor, propertyID, onValue) ? TextDecorationChange::Remove : TextDecorationChange::Add;
1079 }
1080 
1081 static bool executeStrikethrough(Frame&amp; frame, Event*, EditorCommandSource source, const String&amp;)
1082 {
1083     Ref&lt;EditingStyle&gt; style = EditingStyle::create();
1084     style-&gt;setStrikeThroughChange(textDecorationChangeForToggling(frame.editor(), CSSPropertyWebkitTextDecorationsInEffect, &quot;line-through&quot;_s));
1085     // FIXME: Needs a new EditAction!
1086     return applyCommandToFrame(frame, source, EditAction::Underline, WTFMove(style));
1087 }
1088 
1089 static bool executeStyleWithCSS(Frame&amp; frame, Event*, EditorCommandSource, const String&amp; value)
1090 {
1091     frame.editor().setShouldStyleWithCSS(!equalLettersIgnoringASCIICase(value, &quot;false&quot;));
1092     return true;
1093 }
1094 
1095 static bool executeUseCSS(Frame&amp; frame, Event*, EditorCommandSource, const String&amp; value)
1096 {
1097     frame.editor().setShouldStyleWithCSS(equalLettersIgnoringASCIICase(value, &quot;false&quot;));
1098     return true;
1099 }
1100 
1101 static bool executeSubscript(Frame&amp; frame, Event*, EditorCommandSource source, const String&amp;)
1102 {
1103     return executeToggleStyle(frame, source, EditAction::Subscript, CSSPropertyVerticalAlign, &quot;baseline&quot;_s, &quot;sub&quot;_s);
1104 }
1105 
1106 static bool executeSuperscript(Frame&amp; frame, Event*, EditorCommandSource source, const String&amp;)
1107 {
1108     return executeToggleStyle(frame, source, EditAction::Superscript, CSSPropertyVerticalAlign, &quot;baseline&quot;_s, &quot;super&quot;_s);
1109 }
1110 
1111 static bool executeSwapWithMark(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
1112 {
1113     Ref&lt;Frame&gt; protector(frame);
1114     const VisibleSelection&amp; mark = frame.editor().mark();
1115     const VisibleSelection&amp; selection = frame.selection().selection();
1116     if (mark.isNone() || selection.isNone()) {
1117         PAL::systemBeep();
1118         return false;
1119     }
1120     frame.selection().setSelection(mark);
1121     frame.editor().setMark(selection);
1122     return true;
1123 }
1124 
1125 #if PLATFORM(COCOA)
1126 
1127 static bool executeTakeFindStringFromSelection(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
1128 {
1129     frame.editor().takeFindStringFromSelection();
1130     return true;
1131 }
1132 
1133 #endif // PLATFORM(COCOA)
1134 
1135 static bool executeToggleBold(Frame&amp; frame, Event*, EditorCommandSource source, const String&amp;)
1136 {
1137     return executeToggleStyle(frame, source, EditAction::Bold, CSSPropertyFontWeight, &quot;normal&quot;_s, &quot;bold&quot;_s);
1138 }
1139 
1140 static bool executeToggleItalic(Frame&amp; frame, Event*, EditorCommandSource source, const String&amp;)
1141 {
1142     return executeToggleStyle(frame, source, EditAction::Italics, CSSPropertyFontStyle, &quot;normal&quot;_s, &quot;italic&quot;_s);
1143 }
1144 
1145 static bool executeTranspose(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
1146 {
1147     frame.editor().transpose();
1148     return true;
1149 }
1150 
1151 static bool executeUnderline(Frame&amp; frame, Event*, EditorCommandSource source, const String&amp;)
1152 {
1153     Ref&lt;EditingStyle&gt; style = EditingStyle::create();
1154     TextDecorationChange change = textDecorationChangeForToggling(frame.editor(), CSSPropertyWebkitTextDecorationsInEffect, &quot;underline&quot;_s);
1155     style-&gt;setUnderlineChange(change);
1156     return applyCommandToFrame(frame, source, EditAction::Underline, WTFMove(style));
1157 }
1158 
1159 static bool executeUndo(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
1160 {
1161     frame.editor().undo();
1162     return true;
1163 }
1164 
1165 static bool executeUnlink(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
1166 {
1167     ASSERT(frame.document());
1168     UnlinkCommand::create(*frame.document())-&gt;apply();
1169     return true;
1170 }
1171 
1172 static bool executeUnscript(Frame&amp; frame, Event*, EditorCommandSource source, const String&amp;)
1173 {
1174     return executeApplyStyle(frame, source, EditAction::Unscript, CSSPropertyVerticalAlign, &quot;baseline&quot;_s);
1175 }
1176 
1177 static bool executeUnselect(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
1178 {
1179     frame.selection().clear();
1180     return true;
1181 }
1182 
1183 static bool executeYank(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
1184 {
1185     frame.editor().insertTextWithoutSendingTextEvent(frame.editor().killRing().yank(), false, 0);
1186     frame.editor().killRing().setToYankedState();
1187     return true;
1188 }
1189 
1190 static bool executeYankAndSelect(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
1191 {
1192     frame.editor().insertTextWithoutSendingTextEvent(frame.editor().killRing().yank(), true, 0);
1193     frame.editor().killRing().setToYankedState();
1194     return true;
1195 }
1196 
1197 // Supported functions
1198 
1199 static bool supported(Frame*)
1200 {
1201     return true;
1202 }
1203 
1204 static bool supportedFromMenuOrKeyBinding(Frame*)
1205 {
1206     return false;
1207 }
1208 
1209 static bool defaultValueForSupportedCopyCut(Frame&amp; frame)
1210 {
1211     auto&amp; settings = frame.settings();
1212     if (settings.javaScriptCanAccessClipboard())
1213         return true;
1214 
1215     switch (settings.clipboardAccessPolicy()) {
1216     case ClipboardAccessPolicy::Allow:
1217     case ClipboardAccessPolicy::RequiresUserGesture:
1218         return true;
1219     case ClipboardAccessPolicy::Deny:
1220         return false;
1221     }
1222 
1223     ASSERT_NOT_REACHED();
1224     return false;
1225 }
1226 
1227 static bool supportedCopyCut(Frame* frame)
1228 {
1229     if (!frame)
1230         return false;
1231 
1232     bool defaultValue = defaultValueForSupportedCopyCut(*frame);
1233 
1234     EditorClient* client = frame-&gt;editor().client();
1235     return client ? client-&gt;canCopyCut(frame, defaultValue) : defaultValue;
1236 }
1237 
1238 static bool supportedPaste(Frame* frame)
1239 {
1240     if (!frame)
1241         return false;
1242 
<a name="10" id="anc10"></a><span class="line-modified">1243     auto&amp; settings = frame-&gt;settings();</span>
<span class="line-added">1244     bool defaultValue = (settings.javaScriptCanAccessClipboard() &amp;&amp; settings.DOMPasteAllowed()) || settings.domPasteAccessRequestsEnabled();</span>
1245 
1246     EditorClient* client = frame-&gt;editor().client();
1247     return client ? client-&gt;canPaste(frame, defaultValue) : defaultValue;
1248 }
1249 
1250 // Enabled functions
1251 
1252 static bool enabled(Frame&amp;, Event*, EditorCommandSource)
1253 {
1254     return true;
1255 }
1256 
1257 static bool enabledVisibleSelection(Frame&amp; frame, Event* event, EditorCommandSource)
1258 {
1259     // The term &quot;visible&quot; here includes a caret in editable text or a range in any text.
1260     const VisibleSelection&amp; selection = frame.editor().selectionForCommand(event);
1261     return (selection.isCaret() &amp;&amp; selection.isContentEditable()) || selection.isRange();
1262 }
1263 
1264 static bool caretBrowsingEnabled(Frame&amp; frame)
1265 {
1266     return frame.settings().caretBrowsingEnabled();
1267 }
1268 
1269 static EditorCommandSource dummyEditorCommandSource = static_cast&lt;EditorCommandSource&gt;(0);
1270 
1271 static bool enabledVisibleSelectionOrCaretBrowsing(Frame&amp; frame, Event* event, EditorCommandSource)
1272 {
1273     // The EditorCommandSource parameter is unused in enabledVisibleSelection, so just pass a dummy variable
1274     return caretBrowsingEnabled(frame) || enabledVisibleSelection(frame, event, dummyEditorCommandSource);
1275 }
1276 
1277 static bool enabledVisibleSelectionAndMark(Frame&amp; frame, Event* event, EditorCommandSource)
1278 {
1279     const VisibleSelection&amp; selection = frame.editor().selectionForCommand(event);
1280     return ((selection.isCaret() &amp;&amp; selection.isContentEditable()) || selection.isRange())
1281         &amp;&amp; frame.editor().mark().isCaretOrRange();
1282 }
1283 
1284 static bool enableCaretInEditableText(Frame&amp; frame, Event* event, EditorCommandSource)
1285 {
1286     const VisibleSelection&amp; selection = frame.editor().selectionForCommand(event);
1287     return selection.isCaret() &amp;&amp; selection.isContentEditable();
1288 }
1289 
1290 static bool allowCopyCutFromDOM(Frame&amp; frame)
1291 {
1292     auto&amp; settings = frame.settings();
1293     if (settings.javaScriptCanAccessClipboard())
1294         return true;
1295 
1296     switch (settings.clipboardAccessPolicy()) {
1297     case ClipboardAccessPolicy::Allow:
1298         return true;
1299     case ClipboardAccessPolicy::Deny:
1300         return false;
1301     case ClipboardAccessPolicy::RequiresUserGesture:
1302         return UserGestureIndicator::processingUserGesture();
1303     }
1304 
1305     ASSERT_NOT_REACHED();
1306     return false;
1307 }
1308 
1309 static bool enabledCopy(Frame&amp; frame, Event*, EditorCommandSource source)
1310 {
1311     switch (source) {
1312     case CommandFromMenuOrKeyBinding:
1313         return frame.editor().canDHTMLCopy() || frame.editor().canCopy();
1314     case CommandFromDOM:
1315     case CommandFromDOMWithUserInterface:
1316         return allowCopyCutFromDOM(frame) &amp;&amp; (frame.editor().canDHTMLCopy() || frame.editor().canCopy());
1317     }
1318     ASSERT_NOT_REACHED();
1319     return false;
1320 }
1321 
1322 static bool enabledCut(Frame&amp; frame, Event*, EditorCommandSource source)
1323 {
1324     switch (source) {
1325     case CommandFromMenuOrKeyBinding:
1326         return frame.editor().canDHTMLCut() || frame.editor().canCut();
1327     case CommandFromDOM:
1328     case CommandFromDOMWithUserInterface:
1329         return allowCopyCutFromDOM(frame) &amp;&amp; (frame.editor().canDHTMLCut() || frame.editor().canCut());
1330     }
1331     ASSERT_NOT_REACHED();
1332     return false;
1333 }
1334 
1335 static bool enabledClearText(Frame&amp; frame, Event*, EditorCommandSource)
1336 {
1337     UNUSED_PARAM(frame);
1338     return false;
1339 }
1340 
1341 static bool enabledInEditableText(Frame&amp; frame, Event* event, EditorCommandSource)
1342 {
1343     return frame.editor().selectionForCommand(event).rootEditableElement();
1344 }
1345 
1346 static bool enabledDelete(Frame&amp; frame, Event* event, EditorCommandSource source)
1347 {
1348     switch (source) {
1349     case CommandFromMenuOrKeyBinding:
1350         return frame.editor().canDelete();
1351     case CommandFromDOM:
1352     case CommandFromDOMWithUserInterface:
1353         // &quot;Delete&quot; from DOM is like delete/backspace keypress, affects selected range if non-empty,
1354         // otherwise removes a character
1355         return enabledInEditableText(frame, event, source);
1356     }
1357     ASSERT_NOT_REACHED();
1358     return false;
1359 }
1360 
1361 static bool enabledInEditableTextOrCaretBrowsing(Frame&amp; frame, Event* event, EditorCommandSource)
1362 {
1363     // The EditorCommandSource parameter is unused in enabledInEditableText, so just pass a dummy variable
1364     return caretBrowsingEnabled(frame) || enabledInEditableText(frame, event, dummyEditorCommandSource);
1365 }
1366 
1367 static bool enabledInRichlyEditableText(Frame&amp; frame, Event*, EditorCommandSource)
1368 {
1369     const VisibleSelection&amp; selection = frame.selection().selection();
1370     return selection.isCaretOrRange() &amp;&amp; selection.isContentRichlyEditable() &amp;&amp; selection.rootEditableElement();
1371 }
1372 
1373 static bool enabledPaste(Frame&amp; frame, Event*, EditorCommandSource)
1374 {
1375     return frame.editor().canPaste();
1376 }
1377 
1378 static bool enabledRangeInEditableText(Frame&amp; frame, Event*, EditorCommandSource)
1379 {
1380     return frame.selection().isRange() &amp;&amp; frame.selection().selection().isContentEditable();
1381 }
1382 
1383 static bool enabledRangeInRichlyEditableText(Frame&amp; frame, Event*, EditorCommandSource)
1384 {
1385     return frame.selection().isRange() &amp;&amp; frame.selection().selection().isContentRichlyEditable();
1386 }
1387 
1388 static bool enabledRedo(Frame&amp; frame, Event*, EditorCommandSource)
1389 {
1390     return frame.editor().canRedo();
1391 }
1392 
1393 #if PLATFORM(COCOA)
1394 
1395 static bool enabledTakeFindStringFromSelection(Frame&amp; frame, Event*, EditorCommandSource)
1396 {
1397     return frame.editor().canCopyExcludingStandaloneImages();
1398 }
1399 
1400 #endif // PLATFORM(COCOA)
1401 
1402 static bool enabledUndo(Frame&amp; frame, Event*, EditorCommandSource)
1403 {
1404     return frame.editor().canUndo();
1405 }
1406 
1407 static bool enabledInRichlyEditableTextWithEditableImagesEnabled(Frame&amp; frame, Event* event, EditorCommandSource source)
1408 {
1409     if (!frame.settings().editableImagesEnabled())
1410         return false;
1411     return enabledInRichlyEditableText(frame, event, source);
1412 }
1413 
1414 // State functions
1415 
1416 static TriState stateNone(Frame&amp;, Event*)
1417 {
1418     return FalseTriState;
1419 }
1420 
1421 static TriState stateBold(Frame&amp; frame, Event*)
1422 {
1423     return stateStyle(frame, CSSPropertyFontWeight, &quot;bold&quot;_s);
1424 }
1425 
1426 static TriState stateItalic(Frame&amp; frame, Event*)
1427 {
1428     return stateStyle(frame, CSSPropertyFontStyle, &quot;italic&quot;_s);
1429 }
1430 
1431 static TriState stateOrderedList(Frame&amp; frame, Event*)
1432 {
1433     return frame.editor().selectionOrderedListState();
1434 }
1435 
1436 static TriState stateStrikethrough(Frame&amp; frame, Event*)
1437 {
1438     return stateStyle(frame, CSSPropertyWebkitTextDecorationsInEffect, &quot;line-through&quot;_s);
1439 }
1440 
1441 static TriState stateStyleWithCSS(Frame&amp; frame, Event*)
1442 {
1443     return frame.editor().shouldStyleWithCSS() ? TrueTriState : FalseTriState;
1444 }
1445 
1446 static TriState stateSubscript(Frame&amp; frame, Event*)
1447 {
1448     return stateStyle(frame, CSSPropertyVerticalAlign, &quot;sub&quot;_s);
1449 }
1450 
1451 static TriState stateSuperscript(Frame&amp; frame, Event*)
1452 {
1453     return stateStyle(frame, CSSPropertyVerticalAlign, &quot;super&quot;_s);
1454 }
1455 
1456 static TriState stateTextWritingDirectionLeftToRight(Frame&amp; frame, Event*)
1457 {
1458     return stateTextWritingDirection(frame, WritingDirection::LeftToRight);
1459 }
1460 
1461 static TriState stateTextWritingDirectionNatural(Frame&amp; frame, Event*)
1462 {
1463     return stateTextWritingDirection(frame, WritingDirection::Natural);
1464 }
1465 
1466 static TriState stateTextWritingDirectionRightToLeft(Frame&amp; frame, Event*)
1467 {
1468     return stateTextWritingDirection(frame, WritingDirection::RightToLeft);
1469 }
1470 
1471 static TriState stateUnderline(Frame&amp; frame, Event*)
1472 {
1473     return stateStyle(frame, CSSPropertyWebkitTextDecorationsInEffect, &quot;underline&quot;_s);
1474 }
1475 
1476 static TriState stateUnorderedList(Frame&amp; frame, Event*)
1477 {
1478     return frame.editor().selectionUnorderedListState();
1479 }
1480 
1481 static TriState stateJustifyCenter(Frame&amp; frame, Event*)
1482 {
1483     return stateStyle(frame, CSSPropertyTextAlign, &quot;center&quot;_s);
1484 }
1485 
1486 static TriState stateJustifyFull(Frame&amp; frame, Event*)
1487 {
1488     return stateStyle(frame, CSSPropertyTextAlign, &quot;justify&quot;_s);
1489 }
1490 
1491 static TriState stateJustifyLeft(Frame&amp; frame, Event*)
1492 {
1493     return stateStyle(frame, CSSPropertyTextAlign, &quot;left&quot;_s);
1494 }
1495 
1496 static TriState stateJustifyRight(Frame&amp; frame, Event*)
1497 {
1498     return stateStyle(frame, CSSPropertyTextAlign, &quot;right&quot;_s);
1499 }
1500 
1501 // Value functions
1502 
1503 static String valueNull(Frame&amp;, Event*)
1504 {
1505     return String();
1506 }
1507 
1508 static String valueBackColor(Frame&amp; frame, Event*)
1509 {
1510     return valueStyle(frame, CSSPropertyBackgroundColor);
1511 }
1512 
1513 static String valueDefaultParagraphSeparator(Frame&amp; frame, Event*)
1514 {
1515     switch (frame.editor().defaultParagraphSeparator()) {
1516     case EditorParagraphSeparatorIsDiv:
1517         return divTag-&gt;localName();
1518     case EditorParagraphSeparatorIsP:
1519         return pTag-&gt;localName();
1520     }
1521 
1522     ASSERT_NOT_REACHED();
1523     return String();
1524 }
1525 
1526 static String valueFontName(Frame&amp; frame, Event*)
1527 {
1528     return valueStyle(frame, CSSPropertyFontFamily);
1529 }
1530 
1531 static String valueFontSize(Frame&amp; frame, Event*)
1532 {
1533     return valueStyle(frame, CSSPropertyFontSize);
1534 }
1535 
1536 static String valueFontSizeDelta(Frame&amp; frame, Event*)
1537 {
1538     return valueStyle(frame, CSSPropertyWebkitFontSizeDelta);
1539 }
1540 
1541 static String valueForeColor(Frame&amp; frame, Event*)
1542 {
1543     return valueStyle(frame, CSSPropertyColor);
1544 }
1545 
1546 static String valueFormatBlock(Frame&amp; frame, Event*)
1547 {
1548     const VisibleSelection&amp; selection = frame.selection().selection();
1549     if (selection.isNoneOrOrphaned() || !selection.isContentEditable())
1550         return emptyString();
1551     Element* formatBlockElement = FormatBlockCommand::elementForFormatBlockCommand(selection.firstRange().get());
1552     if (!formatBlockElement)
1553         return emptyString();
1554     return formatBlockElement-&gt;localName();
1555 }
1556 
1557 // allowExecutionWhenDisabled functions
1558 
1559 static bool allowExecutionWhenDisabled(Frame&amp;, EditorCommandSource)
1560 {
1561     return true;
1562 }
1563 
1564 static bool doNotAllowExecutionWhenDisabled(Frame&amp;, EditorCommandSource)
1565 {
1566     return false;
1567 }
1568 
1569 static bool allowExecutionWhenDisabledCopyCut(Frame&amp;, EditorCommandSource source)
1570 {
1571     switch (source) {
1572     case CommandFromMenuOrKeyBinding:
1573         return true;
1574     case CommandFromDOM:
1575     case CommandFromDOMWithUserInterface:
1576         return false;
1577     }
1578 
1579     ASSERT_NOT_REACHED();
1580     return false;
1581 }
1582 
1583 static bool allowExecutionWhenDisabledPaste(Frame&amp; frame, EditorCommandSource)
1584 {
1585     if (frame.mainFrame().loader().shouldSuppressTextInputFromEditing())
1586         return false;
1587     return true;
1588 }
1589 
1590 // Map of functions
1591 
1592 struct CommandEntry {
1593     const char* name;
1594     EditorInternalCommand command;
1595 };
1596 
1597 static const CommandMap&amp; createCommandMap()
1598 {
1599     static const CommandEntry commands[] = {
1600         { &quot;AlignCenter&quot;, { executeJustifyCenter, supportedFromMenuOrKeyBinding, enabledInRichlyEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1601         { &quot;AlignJustified&quot;, { executeJustifyFull, supportedFromMenuOrKeyBinding, enabledInRichlyEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1602         { &quot;AlignLeft&quot;, { executeJustifyLeft, supportedFromMenuOrKeyBinding, enabledInRichlyEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1603         { &quot;AlignRight&quot;, { executeJustifyRight, supportedFromMenuOrKeyBinding, enabledInRichlyEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1604         { &quot;BackColor&quot;, { executeBackColor, supported, enabledInRichlyEditableText, stateNone, valueBackColor, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1605         { &quot;Bold&quot;, { executeToggleBold, supported, enabledInRichlyEditableText, stateBold, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1606         { &quot;ClearText&quot;, { executeClearText, supported, enabledClearText, stateNone, valueNull, notTextInsertion, allowExecutionWhenDisabled } },
1607         { &quot;Copy&quot;, { executeCopy, supportedCopyCut, enabledCopy, stateNone, valueNull, notTextInsertion, allowExecutionWhenDisabledCopyCut } },
1608         { &quot;CreateLink&quot;, { executeCreateLink, supported, enabledInRichlyEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1609         { &quot;Cut&quot;, { executeCut, supportedCopyCut, enabledCut, stateNone, valueNull, notTextInsertion, allowExecutionWhenDisabledCopyCut } },
1610         { &quot;DefaultParagraphSeparator&quot;, { executeDefaultParagraphSeparator, supported, enabled, stateNone, valueDefaultParagraphSeparator, notTextInsertion, doNotAllowExecutionWhenDisabled} },
1611         { &quot;Delete&quot;, { executeDelete, supported, enabledDelete, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1612         { &quot;DeleteBackward&quot;, { executeDeleteBackward, supportedFromMenuOrKeyBinding, enabledInEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1613         { &quot;DeleteBackwardByDecomposingPreviousCharacter&quot;, { executeDeleteBackwardByDecomposingPreviousCharacter, supportedFromMenuOrKeyBinding, enabledInEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1614         { &quot;DeleteForward&quot;, { executeDeleteForward, supportedFromMenuOrKeyBinding, enabledInEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1615         { &quot;DeleteToBeginningOfLine&quot;, { executeDeleteToBeginningOfLine, supportedFromMenuOrKeyBinding, enabledInEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1616         { &quot;DeleteToBeginningOfParagraph&quot;, { executeDeleteToBeginningOfParagraph, supportedFromMenuOrKeyBinding, enabledInEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1617         { &quot;DeleteToEndOfLine&quot;, { executeDeleteToEndOfLine, supportedFromMenuOrKeyBinding, enabledInEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1618         { &quot;DeleteToEndOfParagraph&quot;, { executeDeleteToEndOfParagraph, supportedFromMenuOrKeyBinding, enabledInEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1619         { &quot;DeleteToMark&quot;, { executeDeleteToMark, supportedFromMenuOrKeyBinding, enabledInEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1620         { &quot;DeleteWordBackward&quot;, { executeDeleteWordBackward, supportedFromMenuOrKeyBinding, enabledInEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1621         { &quot;DeleteWordForward&quot;, { executeDeleteWordForward, supportedFromMenuOrKeyBinding, enabledInEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1622         { &quot;FindString&quot;, { executeFindString, supported, enabled, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1623         { &quot;FontName&quot;, { executeFontName, supported, enabledInEditableText, stateNone, valueFontName, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1624         { &quot;FontSize&quot;, { executeFontSize, supported, enabledInEditableText, stateNone, valueFontSize, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1625         { &quot;FontSizeDelta&quot;, { executeFontSizeDelta, supported, enabledInEditableText, stateNone, valueFontSizeDelta, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1626         { &quot;ForeColor&quot;, { executeForeColor, supported, enabledInRichlyEditableText, stateNone, valueForeColor, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1627         { &quot;FormatBlock&quot;, { executeFormatBlock, supported, enabledInRichlyEditableText, stateNone, valueFormatBlock, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1628         { &quot;ForwardDelete&quot;, { executeForwardDelete, supported, enabledInEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1629         { &quot;HiliteColor&quot;, { executeBackColor, supported, enabledInRichlyEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1630         { &quot;IgnoreSpelling&quot;, { executeIgnoreSpelling, supportedFromMenuOrKeyBinding, enabledInEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1631         { &quot;Indent&quot;, { executeIndent, supported, enabledInRichlyEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1632         { &quot;InsertBacktab&quot;, { executeInsertBacktab, supportedFromMenuOrKeyBinding, enabledInEditableText, stateNone, valueNull, isTextInsertion, doNotAllowExecutionWhenDisabled } },
1633         { &quot;InsertEditableImage&quot;, { executeInsertEditableImage, supported, enabledInRichlyEditableTextWithEditableImagesEnabled, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1634         { &quot;InsertHTML&quot;, { executeInsertHTML, supported, enabledInEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1635         { &quot;InsertHorizontalRule&quot;, { executeInsertHorizontalRule, supported, enabledInRichlyEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1636         { &quot;InsertImage&quot;, { executeInsertImage, supported, enabledInRichlyEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1637         { &quot;InsertLineBreak&quot;, { executeInsertLineBreak, supported, enabledInEditableText, stateNone, valueNull, isTextInsertion, doNotAllowExecutionWhenDisabled } },
1638         { &quot;InsertNewline&quot;, { executeInsertNewline, supportedFromMenuOrKeyBinding, enabledInEditableText, stateNone, valueNull, isTextInsertion, doNotAllowExecutionWhenDisabled } },
1639         { &quot;InsertNewlineInQuotedContent&quot;, { executeInsertNewlineInQuotedContent, supported, enabledInRichlyEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1640         { &quot;InsertOrderedList&quot;, { executeInsertOrderedList, supported, enabledInRichlyEditableText, stateOrderedList, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1641         { &quot;InsertNestedOrderedList&quot;, { executeInsertNestedOrderedList, supported, enabledInRichlyEditableText, stateOrderedList, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1642         { &quot;InsertParagraph&quot;, { executeInsertParagraph, supported, enabledInEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1643         { &quot;InsertTab&quot;, { executeInsertTab, supportedFromMenuOrKeyBinding, enabledInEditableText, stateNone, valueNull, isTextInsertion, doNotAllowExecutionWhenDisabled } },
1644         { &quot;InsertText&quot;, { executeInsertText, supported, enabledInEditableText, stateNone, valueNull, isTextInsertion, doNotAllowExecutionWhenDisabled } },
1645         { &quot;InsertUnorderedList&quot;, { executeInsertUnorderedList, supported, enabledInRichlyEditableText, stateUnorderedList, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1646         { &quot;InsertNestedUnorderedList&quot;, { executeInsertNestedUnorderedList, supported, enabledInRichlyEditableText, stateUnorderedList, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1647         { &quot;Italic&quot;, { executeToggleItalic, supported, enabledInRichlyEditableText, stateItalic, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1648         { &quot;JustifyCenter&quot;, { executeJustifyCenter, supported, enabledInRichlyEditableText, stateJustifyCenter, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1649         { &quot;JustifyFull&quot;, { executeJustifyFull, supported, enabledInRichlyEditableText, stateJustifyFull, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1650         { &quot;JustifyLeft&quot;, { executeJustifyLeft, supported, enabledInRichlyEditableText, stateJustifyLeft, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1651         { &quot;JustifyNone&quot;, { executeJustifyLeft, supported, enabledInRichlyEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1652         { &quot;JustifyRight&quot;, { executeJustifyRight, supported, enabledInRichlyEditableText, stateJustifyRight, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1653         { &quot;MakeTextWritingDirectionLeftToRight&quot;, { executeMakeTextWritingDirectionLeftToRight, supportedFromMenuOrKeyBinding, enabledInRichlyEditableText, stateTextWritingDirectionLeftToRight, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1654         { &quot;MakeTextWritingDirectionNatural&quot;, { executeMakeTextWritingDirectionNatural, supportedFromMenuOrKeyBinding, enabledInRichlyEditableText, stateTextWritingDirectionNatural, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1655         { &quot;MakeTextWritingDirectionRightToLeft&quot;, { executeMakeTextWritingDirectionRightToLeft, supportedFromMenuOrKeyBinding, enabledInRichlyEditableText, stateTextWritingDirectionRightToLeft, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1656         { &quot;MoveBackward&quot;, { executeMoveBackward, supportedFromMenuOrKeyBinding, enabledInEditableTextOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1657         { &quot;MoveBackwardAndModifySelection&quot;, { executeMoveBackwardAndModifySelection, supportedFromMenuOrKeyBinding, enabledVisibleSelectionOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1658         { &quot;MoveDown&quot;, { executeMoveDown, supportedFromMenuOrKeyBinding, enabledInEditableTextOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1659         { &quot;MoveDownAndModifySelection&quot;, { executeMoveDownAndModifySelection, supportedFromMenuOrKeyBinding, enabledVisibleSelectionOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1660         { &quot;MoveForward&quot;, { executeMoveForward, supportedFromMenuOrKeyBinding, enabledInEditableTextOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1661         { &quot;MoveForwardAndModifySelection&quot;, { executeMoveForwardAndModifySelection, supportedFromMenuOrKeyBinding, enabledVisibleSelectionOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1662         { &quot;MoveLeft&quot;, { executeMoveLeft, supportedFromMenuOrKeyBinding, enabledInEditableTextOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1663         { &quot;MoveLeftAndModifySelection&quot;, { executeMoveLeftAndModifySelection, supportedFromMenuOrKeyBinding, enabledVisibleSelectionOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1664         { &quot;MovePageDown&quot;, { executeMovePageDown, supportedFromMenuOrKeyBinding, enabledInEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1665         { &quot;MovePageDownAndModifySelection&quot;, { executeMovePageDownAndModifySelection, supportedFromMenuOrKeyBinding, enabledVisibleSelection, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1666         { &quot;MovePageUp&quot;, { executeMovePageUp, supportedFromMenuOrKeyBinding, enabledInEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1667         { &quot;MovePageUpAndModifySelection&quot;, { executeMovePageUpAndModifySelection, supportedFromMenuOrKeyBinding, enabledVisibleSelection, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1668         { &quot;MoveParagraphBackwardAndModifySelection&quot;, { executeMoveParagraphBackwardAndModifySelection, supportedFromMenuOrKeyBinding, enabledVisibleSelectionOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1669         { &quot;MoveParagraphForwardAndModifySelection&quot;, { executeMoveParagraphForwardAndModifySelection, supportedFromMenuOrKeyBinding, enabledVisibleSelectionOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1670         { &quot;MoveRight&quot;, { executeMoveRight, supportedFromMenuOrKeyBinding, enabledInEditableTextOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1671         { &quot;MoveRightAndModifySelection&quot;, { executeMoveRightAndModifySelection, supportedFromMenuOrKeyBinding, enabledVisibleSelectionOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1672         { &quot;MoveToBeginningOfDocument&quot;, { executeMoveToBeginningOfDocument, supportedFromMenuOrKeyBinding, enabledInEditableTextOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1673         { &quot;MoveToBeginningOfDocumentAndModifySelection&quot;, { executeMoveToBeginningOfDocumentAndModifySelection, supportedFromMenuOrKeyBinding, enabledVisibleSelectionOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1674         { &quot;MoveToBeginningOfLine&quot;, { executeMoveToBeginningOfLine, supportedFromMenuOrKeyBinding, enabledInEditableTextOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1675         { &quot;MoveToBeginningOfLineAndModifySelection&quot;, { executeMoveToBeginningOfLineAndModifySelection, supportedFromMenuOrKeyBinding, enabledVisibleSelectionOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1676         { &quot;MoveToBeginningOfParagraph&quot;, { executeMoveToBeginningOfParagraph, supportedFromMenuOrKeyBinding, enabledInEditableTextOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1677         { &quot;MoveToBeginningOfParagraphAndModifySelection&quot;, { executeMoveToBeginningOfParagraphAndModifySelection, supportedFromMenuOrKeyBinding, enabledVisibleSelectionOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1678         { &quot;MoveToBeginningOfSentence&quot;, { executeMoveToBeginningOfSentence, supportedFromMenuOrKeyBinding, enabledInEditableTextOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1679         { &quot;MoveToBeginningOfSentenceAndModifySelection&quot;, { executeMoveToBeginningOfSentenceAndModifySelection, supportedFromMenuOrKeyBinding, enabledVisibleSelectionOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1680         { &quot;MoveToEndOfDocument&quot;, { executeMoveToEndOfDocument, supportedFromMenuOrKeyBinding, enabledInEditableTextOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1681         { &quot;MoveToEndOfDocumentAndModifySelection&quot;, { executeMoveToEndOfDocumentAndModifySelection, supportedFromMenuOrKeyBinding, enabledVisibleSelectionOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1682         { &quot;MoveToEndOfLine&quot;, { executeMoveToEndOfLine, supportedFromMenuOrKeyBinding, enabledInEditableTextOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1683         { &quot;MoveToEndOfLineAndModifySelection&quot;, { executeMoveToEndOfLineAndModifySelection, supportedFromMenuOrKeyBinding, enabledVisibleSelectionOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1684         { &quot;MoveToEndOfParagraph&quot;, { executeMoveToEndOfParagraph, supportedFromMenuOrKeyBinding, enabledInEditableTextOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1685         { &quot;MoveToEndOfParagraphAndModifySelection&quot;, { executeMoveToEndOfParagraphAndModifySelection, supportedFromMenuOrKeyBinding, enabledVisibleSelectionOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1686         { &quot;MoveToEndOfSentence&quot;, { executeMoveToEndOfSentence, supportedFromMenuOrKeyBinding, enabledInEditableTextOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1687         { &quot;MoveToEndOfSentenceAndModifySelection&quot;, { executeMoveToEndOfSentenceAndModifySelection, supportedFromMenuOrKeyBinding, enabledVisibleSelectionOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1688         { &quot;MoveToLeftEndOfLine&quot;, { executeMoveToLeftEndOfLine, supportedFromMenuOrKeyBinding, enabledInEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1689         { &quot;MoveToLeftEndOfLineAndModifySelection&quot;, { executeMoveToLeftEndOfLineAndModifySelection, supportedFromMenuOrKeyBinding, enabledInEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1690         { &quot;MoveToRightEndOfLine&quot;, { executeMoveToRightEndOfLine, supportedFromMenuOrKeyBinding, enabledInEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1691         { &quot;MoveToRightEndOfLineAndModifySelection&quot;, { executeMoveToRightEndOfLineAndModifySelection, supportedFromMenuOrKeyBinding, enabledInEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1692         { &quot;MoveUp&quot;, { executeMoveUp, supportedFromMenuOrKeyBinding, enabledInEditableTextOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1693         { &quot;MoveUpAndModifySelection&quot;, { executeMoveUpAndModifySelection, supportedFromMenuOrKeyBinding, enabledVisibleSelectionOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1694         { &quot;MoveWordBackward&quot;, { executeMoveWordBackward, supportedFromMenuOrKeyBinding, enabledInEditableTextOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1695         { &quot;MoveWordBackwardAndModifySelection&quot;, { executeMoveWordBackwardAndModifySelection, supportedFromMenuOrKeyBinding, enabledVisibleSelectionOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1696         { &quot;MoveWordForward&quot;, { executeMoveWordForward, supportedFromMenuOrKeyBinding, enabledInEditableTextOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1697         { &quot;MoveWordForwardAndModifySelection&quot;, { executeMoveWordForwardAndModifySelection, supportedFromMenuOrKeyBinding, enabledVisibleSelectionOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1698         { &quot;MoveWordLeft&quot;, { executeMoveWordLeft, supportedFromMenuOrKeyBinding, enabledInEditableTextOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1699         { &quot;MoveWordLeftAndModifySelection&quot;, { executeMoveWordLeftAndModifySelection, supportedFromMenuOrKeyBinding, enabledVisibleSelectionOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1700         { &quot;MoveWordRight&quot;, { executeMoveWordRight, supportedFromMenuOrKeyBinding, enabledInEditableTextOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1701         { &quot;MoveWordRightAndModifySelection&quot;, { executeMoveWordRightAndModifySelection, supportedFromMenuOrKeyBinding, enabledVisibleSelectionOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1702         { &quot;Outdent&quot;, { executeOutdent, supported, enabledInRichlyEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1703         { &quot;OverWrite&quot;, { executeToggleOverwrite, supportedFromMenuOrKeyBinding, enabledInRichlyEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1704         { &quot;Paste&quot;, { executePaste, supportedPaste, enabledPaste, stateNone, valueNull, notTextInsertion, allowExecutionWhenDisabledPaste } },
1705         { &quot;PasteAndMatchStyle&quot;, { executePasteAndMatchStyle, supportedPaste, enabledPaste, stateNone, valueNull, notTextInsertion, allowExecutionWhenDisabledPaste } },
1706         { &quot;PasteAsPlainText&quot;, { executePasteAsPlainText, supportedPaste, enabledPaste, stateNone, valueNull, notTextInsertion, allowExecutionWhenDisabledPaste } },
1707         { &quot;PasteAsQuotation&quot;, { executePasteAsQuotation, supportedPaste, enabledPaste, stateNone, valueNull, notTextInsertion, allowExecutionWhenDisabledPaste } },
1708         { &quot;Print&quot;, { executePrint, supported, enabled, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1709         { &quot;Redo&quot;, { executeRedo, supported, enabledRedo, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1710         { &quot;RemoveFormat&quot;, { executeRemoveFormat, supported, enabledRangeInEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1711         { &quot;ScrollPageBackward&quot;, { executeScrollPageBackward, supportedFromMenuOrKeyBinding, enabled, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1712         { &quot;ScrollPageForward&quot;, { executeScrollPageForward, supportedFromMenuOrKeyBinding, enabled, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1713         { &quot;ScrollLineUp&quot;, { executeScrollLineUp, supportedFromMenuOrKeyBinding, enabled, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1714         { &quot;ScrollLineDown&quot;, { executeScrollLineDown, supportedFromMenuOrKeyBinding, enabled, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1715         { &quot;ScrollToBeginningOfDocument&quot;, { executeScrollToBeginningOfDocument, supportedFromMenuOrKeyBinding, enabled, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1716         { &quot;ScrollToEndOfDocument&quot;, { executeScrollToEndOfDocument, supportedFromMenuOrKeyBinding, enabled, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1717         { &quot;SelectAll&quot;, { executeSelectAll, supported, enabled, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1718         { &quot;SelectLine&quot;, { executeSelectLine, supportedFromMenuOrKeyBinding, enabledVisibleSelection, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1719         { &quot;SelectParagraph&quot;, { executeSelectParagraph, supportedFromMenuOrKeyBinding, enabledVisibleSelection, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1720         { &quot;SelectSentence&quot;, { executeSelectSentence, supportedFromMenuOrKeyBinding, enabledVisibleSelection, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1721         { &quot;SelectToMark&quot;, { executeSelectToMark, supportedFromMenuOrKeyBinding, enabledVisibleSelectionAndMark, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1722         { &quot;SelectWord&quot;, { executeSelectWord, supportedFromMenuOrKeyBinding, enabledVisibleSelection, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1723         { &quot;SetMark&quot;, { executeSetMark, supportedFromMenuOrKeyBinding, enabledVisibleSelection, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1724         { &quot;Strikethrough&quot;, { executeStrikethrough, supported, enabledInRichlyEditableText, stateStrikethrough, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1725         { &quot;StyleWithCSS&quot;, { executeStyleWithCSS, supported, enabled, stateStyleWithCSS, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1726         { &quot;Subscript&quot;, { executeSubscript, supported, enabledInRichlyEditableText, stateSubscript, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1727         { &quot;Superscript&quot;, { executeSuperscript, supported, enabledInRichlyEditableText, stateSuperscript, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1728         { &quot;SwapWithMark&quot;, { executeSwapWithMark, supportedFromMenuOrKeyBinding, enabledVisibleSelectionAndMark, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1729         { &quot;ToggleBold&quot;, { executeToggleBold, supportedFromMenuOrKeyBinding, enabledInRichlyEditableText, stateBold, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1730         { &quot;ToggleItalic&quot;, { executeToggleItalic, supportedFromMenuOrKeyBinding, enabledInRichlyEditableText, stateItalic, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1731         { &quot;ToggleUnderline&quot;, { executeUnderline, supportedFromMenuOrKeyBinding, enabledInRichlyEditableText, stateUnderline, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1732         { &quot;Transpose&quot;, { executeTranspose, supported, enableCaretInEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1733         { &quot;Underline&quot;, { executeUnderline, supported, enabledInRichlyEditableText, stateUnderline, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1734         { &quot;Undo&quot;, { executeUndo, supported, enabledUndo, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1735         { &quot;Unlink&quot;, { executeUnlink, supported, enabledRangeInRichlyEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1736         { &quot;Unscript&quot;, { executeUnscript, supportedFromMenuOrKeyBinding, enabledInRichlyEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1737         { &quot;Unselect&quot;, { executeUnselect, supported, enabledVisibleSelection, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1738         { &quot;UseCSS&quot;, { executeUseCSS, supported, enabled, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1739         { &quot;Yank&quot;, { executeYank, supportedFromMenuOrKeyBinding, enabledInEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1740         { &quot;YankAndSelect&quot;, { executeYankAndSelect, supportedFromMenuOrKeyBinding, enabledInEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1741 
1742 #if PLATFORM(GTK)
1743         { &quot;PasteGlobalSelection&quot;, { executePasteGlobalSelection, supportedFromMenuOrKeyBinding, enabledPaste, stateNone, valueNull, notTextInsertion, allowExecutionWhenDisabled } },
1744 #endif
1745 
1746 #if PLATFORM(COCOA)
1747         { &quot;TakeFindStringFromSelection&quot;, { executeTakeFindStringFromSelection, supportedFromMenuOrKeyBinding, enabledTakeFindStringFromSelection, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1748 #endif
1749     };
1750 
1751     // These unsupported commands are listed here since they appear in the Microsoft
1752     // documentation used as the starting point for our DOM executeCommand support.
1753     //
1754     // 2D-Position (not supported)
1755     // AbsolutePosition (not supported)
1756     // BlockDirLTR (not supported)
1757     // BlockDirRTL (not supported)
1758     // BrowseMode (not supported)
1759     // ClearAuthenticationCache (not supported)
1760     // CreateBookmark (not supported)
1761     // DirLTR (not supported)
1762     // DirRTL (not supported)
1763     // EditMode (not supported)
1764     // InlineDirLTR (not supported)
1765     // InlineDirRTL (not supported)
1766     // InsertButton (not supported)
1767     // InsertFieldSet (not supported)
1768     // InsertIFrame (not supported)
1769     // InsertInputButton (not supported)
1770     // InsertInputCheckbox (not supported)
1771     // InsertInputFileUpload (not supported)
1772     // InsertInputHidden (not supported)
1773     // InsertInputImage (not supported)
1774     // InsertInputPassword (not supported)
1775     // InsertInputRadio (not supported)
1776     // InsertInputReset (not supported)
1777     // InsertInputSubmit (not supported)
1778     // InsertInputText (not supported)
1779     // InsertMarquee (not supported)
1780     // InsertSelectDropDown (not supported)
1781     // InsertSelectListBox (not supported)
1782     // InsertTextArea (not supported)
1783     // LiveResize (not supported)
1784     // MultipleSelection (not supported)
1785     // Open (not supported)
1786     // PlayImage (not supported)
1787     // Refresh (not supported)
1788     // RemoveParaFormat (not supported)
1789     // SaveAs (not supported)
1790     // SizeToControl (not supported)
1791     // SizeToControlHeight (not supported)
1792     // SizeToControlWidth (not supported)
1793     // Stop (not supported)
1794     // StopImage (not supported)
1795     // Unbookmark (not supported)
1796 
1797     CommandMap&amp; commandMap = *new CommandMap;
1798 
1799     for (auto&amp; command : commands) {
1800         ASSERT(!commandMap.get(command.name));
1801         commandMap.set(command.name, &amp;command.command);
1802     }
1803 
1804     return commandMap;
1805 }
1806 
1807 static const EditorInternalCommand* internalCommand(const String&amp; commandName)
1808 {
1809     static const CommandMap&amp; commandMap = createCommandMap();
1810     return commandName.isEmpty() ? 0 : commandMap.get(commandName);
1811 }
1812 
1813 Editor::Command Editor::command(const String&amp; commandName)
1814 {
1815     return Command(internalCommand(commandName), CommandFromMenuOrKeyBinding, m_frame);
1816 }
1817 
1818 Editor::Command Editor::command(const String&amp; commandName, EditorCommandSource source)
1819 {
1820     return Command(internalCommand(commandName), source, m_frame);
1821 }
1822 
1823 bool Editor::commandIsSupportedFromMenuOrKeyBinding(const String&amp; commandName)
1824 {
1825     return internalCommand(commandName);
1826 }
1827 
1828 Editor::Command::Command()
1829 {
1830 }
1831 
1832 Editor::Command::Command(const EditorInternalCommand* command, EditorCommandSource source, Frame&amp; frame)
1833     : m_command(command)
1834     , m_source(source)
1835     , m_frame(command ? &amp;frame : nullptr)
1836 {
1837     ASSERT(command || !m_frame);
1838 }
1839 
1840 bool Editor::Command::execute(const String&amp; parameter, Event* triggeringEvent) const
1841 {
1842     if (!isEnabled(triggeringEvent)) {
1843         // Let certain commands be executed when performed explicitly even if they are disabled.
1844         if (!allowExecutionWhenDisabled())
1845             return false;
1846     }
1847     auto document = m_frame-&gt;document();
1848     document-&gt;updateLayoutIgnorePendingStylesheets();
1849     if (m_frame-&gt;document() != document)
1850         return false;
1851 
1852     return m_command-&gt;execute(*m_frame, triggeringEvent, m_source, parameter);
1853 }
1854 
1855 bool Editor::Command::execute(Event* triggeringEvent) const
1856 {
1857     return execute(String(), triggeringEvent);
1858 }
1859 
1860 bool Editor::Command::isSupported() const
1861 {
1862     if (!m_command)
1863         return false;
1864     switch (m_source) {
1865     case CommandFromMenuOrKeyBinding:
1866         return true;
1867     case CommandFromDOM:
1868     case CommandFromDOMWithUserInterface:
1869         return m_command-&gt;isSupportedFromDOM(m_frame.get());
1870     }
1871     ASSERT_NOT_REACHED();
1872     return false;
1873 }
1874 
1875 bool Editor::Command::isEnabled(Event* triggeringEvent) const
1876 {
1877     if (!isSupported() || !m_frame)
1878         return false;
1879     return m_command-&gt;isEnabled(*m_frame, triggeringEvent, m_source);
1880 }
1881 
1882 TriState Editor::Command::state(Event* triggeringEvent) const
1883 {
1884     if (!isSupported() || !m_frame)
1885         return FalseTriState;
1886     return m_command-&gt;state(*m_frame, triggeringEvent);
1887 }
1888 
1889 String Editor::Command::value(Event* triggeringEvent) const
1890 {
1891     if (!isSupported() || !m_frame)
1892         return String();
1893     if (m_command-&gt;value == valueNull &amp;&amp; m_command-&gt;state != stateNone)
1894         return m_command-&gt;state(*m_frame, triggeringEvent) == TrueTriState ? &quot;true&quot;_s : &quot;false&quot;_s;
1895     return m_command-&gt;value(*m_frame, triggeringEvent);
1896 }
1897 
1898 bool Editor::Command::isTextInsertion() const
1899 {
1900     return m_command &amp;&amp; m_command-&gt;isTextInsertion;
1901 }
1902 
1903 bool Editor::Command::allowExecutionWhenDisabled() const
1904 {
1905     if (!isSupported() || !m_frame)
1906         return false;
1907     return m_command-&gt;allowExecutionWhenDisabled(*m_frame, m_source);
1908 }
1909 
1910 } // namespace WebCore
<a name="11" id="anc11"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="11" type="hidden" />
</body>
</html>