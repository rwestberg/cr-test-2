<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/WHLSLParser.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2019 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
  14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
  17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  23  * THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;WHLSLParser.h&quot;
  28 
  29 #if ENABLE(WEBGPU)
  30 
  31 #include &quot;WHLSLAddressSpace.h&quot;
  32 #include &quot;WHLSLEntryPointType.h&quot;
<a name="1" id="anc1"></a><span class="line-added">  33 #include &quot;WHLSLProgram.h&quot;</span>
  34 #include &lt;wtf/dtoa.h&gt;
  35 #include &lt;wtf/text/StringBuilder.h&gt;
  36 #include &lt;wtf/text/StringConcatenate.h&gt;
  37 
  38 namespace WebCore {
  39 
  40 namespace WHLSL {
  41 
<a name="2" id="anc2"></a><span class="line-modified">  42 #define PARSE(name, element, ...) \</span>
<span class="line-modified">  43     auto name = parse##element(__VA_ARGS__); \</span>
<span class="line-added">  44     if (!name) \</span>
<span class="line-added">  45         return makeUnexpected(name.error()); \</span>
<span class="line-added">  46 </span>
<span class="line-added">  47 #define CONSUME_TYPE(name, type) \</span>
<span class="line-added">  48     auto name = consumeType(Token::Type::type); \</span>
<span class="line-added">  49     if (!name) \</span>
<span class="line-added">  50         return makeUnexpected(name.error());</span>
<span class="line-added">  51 </span>
<span class="line-added">  52 #define PEEK(name) \</span>
<span class="line-added">  53     auto name = peek(); \</span>
<span class="line-added">  54     if (!name) \</span>
<span class="line-added">  55         return makeUnexpected(name.error());</span>
<span class="line-added">  56 </span>
<span class="line-added">  57 #define PEEK_FURTHER(name) \</span>
<span class="line-added">  58     auto name = peekFurther(); \</span>
<span class="line-added">  59     if (!name) \</span>
<span class="line-added">  60         return makeUnexpected(name.error());</span>
<span class="line-added">  61 </span>
<span class="line-added">  62 auto Parser::parse(Program&amp; program, StringView stringView, ParsingMode mode, AST::NameSpace nameSpace) -&gt; Expected&lt;void, Error&gt;</span>
  63 {
<a name="3" id="anc3"></a><span class="line-modified">  64     m_lexer = Lexer(stringView, nameSpace);</span>
  65     m_mode = mode;
  66 
  67     while (!m_lexer.isFullyConsumed()) {
<a name="4" id="anc4"></a><span class="line-modified">  68         auto token = m_lexer.peek();</span>
<span class="line-added">  69         switch (token.type) {</span>
<span class="line-added">  70         case Token::Type::Invalid:</span>
<span class="line-added">  71             return { };</span>
<span class="line-added">  72         case Token::Type::Semicolon:</span>
  73             m_lexer.consumeToken();
  74             continue;
<a name="5" id="anc5"></a><span class="line-added">  75         case Token::Type::Typedef: {</span>
<span class="line-added">  76             auto typeDefinition = parseTypeDefinition();</span>
<span class="line-added">  77             if (!typeDefinition)</span>
<span class="line-added">  78                 return makeUnexpected(typeDefinition.error());</span>
<span class="line-added">  79             auto appendResult = program.append(WTFMove(*typeDefinition));</span>
<span class="line-added">  80             if (!appendResult)</span>
<span class="line-added">  81                 return makeUnexpected(appendResult.error());</span>
<span class="line-added">  82             continue;</span>
  83         }
<a name="6" id="anc6"></a><span class="line-modified">  84         case Token::Type::Struct: {</span>
<span class="line-modified">  85             auto structureDefinition = parseStructureDefinition();</span>
<span class="line-modified">  86             if (!structureDefinition)</span>
<span class="line-modified">  87                 return makeUnexpected(structureDefinition.error());</span>
<span class="line-modified">  88             auto appendResult = program.append(WTFMove(*structureDefinition));</span>
<span class="line-modified">  89             if (!appendResult)</span>
<span class="line-modified">  90                 return makeUnexpected(appendResult.error());</span>
<span class="line-modified">  91             continue;</span>



  92         }
<a name="7" id="anc7"></a><span class="line-modified">  93         case Token::Type::Enum: {</span>
<span class="line-modified">  94             auto enumerationDefinition = parseEnumerationDefinition();</span>
<span class="line-modified">  95             if (!enumerationDefinition)</span>
<span class="line-modified">  96                 return makeUnexpected(enumerationDefinition.error());</span>
<span class="line-modified">  97             auto appendResult = program.append(WTFMove(*enumerationDefinition));</span>
<span class="line-modified">  98             if (!appendResult)</span>
<span class="line-modified">  99                 return makeUnexpected(appendResult.error());</span>
<span class="line-modified"> 100             continue;</span>



 101         }
<a name="8" id="anc8"></a><span class="line-modified"> 102         case Token::Type::Native: {</span>
<span class="line-modified"> 103             if (m_mode != ParsingMode::StandardLibrary)</span>
<span class="line-modified"> 104                 return fail(makeString(&quot;&#39;native&#39; can&#39;t exist outside of the standard library.&quot;));</span>
<span class="line-modified"> 105             auto furtherToken = peekFurther();</span>
<span class="line-modified"> 106             if (!furtherToken)</span>
<span class="line-modified"> 107                 return { };</span>
<span class="line-modified"> 108             if (furtherToken-&gt;type == Token::Type::Typedef) {</span>
<span class="line-modified"> 109                 auto nativeTypeDeclaration = parseNativeTypeDeclaration();</span>
<span class="line-modified"> 110                 if (!nativeTypeDeclaration)</span>
<span class="line-added"> 111                     return makeUnexpected(nativeTypeDeclaration.error());</span>
<span class="line-added"> 112                 auto appendResult = program.append(WTFMove(*nativeTypeDeclaration));</span>
<span class="line-added"> 113                 if (!appendResult)</span>
<span class="line-added"> 114                     return makeUnexpected(appendResult.error());</span>
 115                 continue;
 116             }
<a name="9" id="anc9"></a><span class="line-added"> 117             auto nativeFunctionDeclaration = parseNativeFunctionDeclaration();</span>
<span class="line-added"> 118             if (!nativeFunctionDeclaration)</span>
<span class="line-added"> 119                 return makeUnexpected(nativeFunctionDeclaration.error());</span>
<span class="line-added"> 120             auto appendResult = program.append(WTFMove(*nativeFunctionDeclaration));</span>
<span class="line-added"> 121             if (!appendResult)</span>
<span class="line-added"> 122                 return makeUnexpected(appendResult.error());</span>
<span class="line-added"> 123             continue;</span>
 124         }
<a name="10" id="anc10"></a><span class="line-modified"> 125         default: {</span>
<span class="line-modified"> 126             auto functionDefinition = parseFunctionDefinition();</span>
<span class="line-modified"> 127             if (!functionDefinition)</span>
<span class="line-modified"> 128                 return makeUnexpected(functionDefinition.error());</span>
<span class="line-modified"> 129             auto appendResult = program.append(WTFMove(*functionDefinition));</span>
<span class="line-modified"> 130             if (!appendResult)</span>
<span class="line-modified"> 131                 return makeUnexpected(appendResult.error());</span>
<span class="line-modified"> 132             continue;</span>





 133         }
<a name="11" id="anc11"></a>










 134         }
<a name="12" id="anc12"></a><span class="line-added"> 135     }</span>
 136 
<a name="13" id="anc13"></a><span class="line-modified"> 137     return { };</span>
<span class="line-modified"> 138 }</span>









 139 
<a name="14" id="anc14"></a><span class="line-modified"> 140 auto Parser::fail(const String&amp; message, TryToPeek tryToPeek) -&gt; Unexpected&lt;Error&gt;</span>
<span class="line-added"> 141 {</span>
<span class="line-added"> 142     if (tryToPeek == TryToPeek::Yes) {</span>
<span class="line-added"> 143         if (auto nextToken = peek())</span>
<span class="line-added"> 144             return makeUnexpected(Error(m_lexer.errorString(*nextToken, message)));</span>
 145     }
<a name="15" id="anc15"></a><span class="line-modified"> 146     return makeUnexpected(Error(makeString(&quot;Cannot lex: &quot;, message)));</span>
 147 }
 148 
<a name="16" id="anc16"></a><span class="line-modified"> 149 auto Parser::peek() -&gt; Expected&lt;Token, Error&gt;</span>
 150 {
<a name="17" id="anc17"></a><span class="line-modified"> 151     auto token = m_lexer.peek();</span>
<span class="line-modified"> 152     if (token.type != Token::Type::Invalid &amp;&amp; token.type != Token::Type::EndOfFile)</span>
<span class="line-modified"> 153         return { token };</span>
<span class="line-added"> 154     return fail(&quot;Cannot consume token&quot;_str, TryToPeek::No);</span>
 155 }
 156 
<a name="18" id="anc18"></a><span class="line-modified"> 157 auto Parser::peekFurther() -&gt; Expected&lt;Token, Error&gt;</span>
 158 {
<a name="19" id="anc19"></a><span class="line-modified"> 159     auto token = m_lexer.peekFurther();</span>
<span class="line-modified"> 160     if (token.type != Token::Type::Invalid &amp;&amp; token.type != Token::Type::EndOfFile)</span>
<span class="line-modified"> 161         return { token };</span>
<span class="line-added"> 162     return fail(&quot;Cannot consume two tokens&quot;_str, TryToPeek::No);</span>
<span class="line-added"> 163 }</span>
<span class="line-added"> 164 </span>
<span class="line-added"> 165 template &lt;Token::Type t, Token::Type... ts&gt;</span>
<span class="line-added"> 166 struct Types {</span>
<span class="line-added"> 167     static bool includes(Token::Type type)</span>
<span class="line-added"> 168     {</span>
<span class="line-added"> 169         return t == type || Types&lt;ts...&gt;::includes(type);</span>
<span class="line-added"> 170     }</span>
<span class="line-added"> 171 </span>
<span class="line-added"> 172     static void appendNameTo(StringBuilder&amp; builder)</span>
<span class="line-added"> 173     {</span>
<span class="line-added"> 174         builder.append(Token::typeName(t), &quot;, &quot;);</span>
<span class="line-added"> 175         Types&lt;ts...&gt;::appendNameTo(builder);</span>
<span class="line-added"> 176     }</span>
<span class="line-added"> 177 };</span>
<span class="line-added"> 178 template &lt;Token::Type t&gt;</span>
<span class="line-added"> 179 struct Types&lt;t&gt; {</span>
<span class="line-added"> 180     static bool includes(Token::Type type)</span>
<span class="line-added"> 181     {</span>
<span class="line-added"> 182         return t == type;</span>
<span class="line-added"> 183     }</span>
<span class="line-added"> 184 </span>
<span class="line-added"> 185     static void appendNameTo(StringBuilder&amp; builder)</span>
<span class="line-added"> 186     {</span>
<span class="line-added"> 187         builder.append(Token::typeName(t));</span>
 188     }
<a name="20" id="anc20"></a><span class="line-modified"> 189 };</span>
<span class="line-added"> 190 </span>
<span class="line-added"> 191 </span>
<span class="line-added"> 192 bool Parser::peekType(Token::Type type)</span>
<span class="line-added"> 193 {</span>
<span class="line-added"> 194     auto token = m_lexer.peek();</span>
<span class="line-added"> 195     return token.type == type;</span>
 196 }
 197 
<a name="21" id="anc21"></a><span class="line-modified"> 198 template &lt;Token::Type... types&gt;</span>
<span class="line-added"> 199 bool Parser::peekTypes()</span>
 200 {
<a name="22" id="anc22"></a><span class="line-modified"> 201     auto token = m_lexer.peek();</span>
<span class="line-modified"> 202     return Types&lt;types...&gt;::includes(token.type);</span>
<span class="line-modified"> 203 }</span>
<span class="line-modified"> 204 </span>
<span class="line-modified"> 205 Optional&lt;Token&gt; Parser::tryType(Token::Type type)</span>
<span class="line-added"> 206 {</span>
<span class="line-added"> 207     auto token = m_lexer.peek();</span>
<span class="line-added"> 208     if (token.type == type)</span>
<span class="line-added"> 209         return { m_lexer.consumeToken() };</span>
 210     return WTF::nullopt;
 211 }
 212 
<a name="23" id="anc23"></a><span class="line-modified"> 213 template &lt;Token::Type... types&gt;</span>
<span class="line-added"> 214 Optional&lt;Token&gt; Parser::tryTypes()</span>
 215 {
<a name="24" id="anc24"></a><span class="line-modified"> 216     auto token = m_lexer.peek();</span>
<span class="line-modified"> 217     if (Types&lt;types...&gt;::includes(token.type))</span>
<span class="line-modified"> 218         return { m_lexer.consumeToken() };</span>


 219     return WTF::nullopt;
 220 }
 221 
<a name="25" id="anc25"></a><span class="line-modified"> 222 auto Parser::consumeType(Token::Type type) -&gt; Expected&lt;Token, Error&gt;</span>
 223 {
<a name="26" id="anc26"></a><span class="line-modified"> 224     auto token = m_lexer.consumeToken();</span>
<span class="line-modified"> 225     if (token.type == type)</span>
<span class="line-modified"> 226         return { token };</span>
<span class="line-modified"> 227     return fail(makeString(&quot;Unexpected token (expected &quot;, Token::typeName(type), &quot; got &quot;, Token::typeName(token.type), &quot;)&quot;));</span>


 228 }
 229 
<a name="27" id="anc27"></a><span class="line-modified"> 230 template &lt;Token::Type... types&gt;</span>
<span class="line-added"> 231 auto Parser::consumeTypes() -&gt; Expected&lt;Token, Error&gt;</span>
 232 {
 233     auto buildExpectedString = [&amp;]() -&gt; String {
 234         StringBuilder builder;
 235         builder.append(&quot;[&quot;);
<a name="28" id="anc28"></a><span class="line-modified"> 236         Types&lt;types...&gt;::appendNameTo(builder);</span>




 237         builder.append(&quot;]&quot;);
 238         return builder.toString();
 239     };
 240 
<a name="29" id="anc29"></a><span class="line-modified"> 241     auto token = m_lexer.consumeToken();</span>
<span class="line-modified"> 242     if (Types&lt;types...&gt;::includes(token.type))</span>
<span class="line-modified"> 243         return { token };</span>
<span class="line-modified"> 244     return fail(makeString(&quot;Unexpected token (expected one of &quot;, buildExpectedString(), &quot; got &quot;, Token::typeName(token.type), &quot;)&quot;));</span>


 245 }
 246 
 247 static int digitValue(UChar character)
 248 {
 249     if (character &gt;= &#39;0&#39; &amp;&amp; character &lt;= &#39;9&#39;)
 250         return character - &#39;0&#39;;
 251     if (character &gt;= &#39;a&#39; &amp;&amp; character &lt;= &#39;f&#39;)
 252         return character - &#39;a&#39; + 10;
 253     return character - &#39;A&#39; + 10;
 254 }
 255 
<a name="30" id="anc30"></a><span class="line-modified"> 256 static Expected&lt;int, Error&gt; intLiteralToInt(StringView text)</span>
 257 {
 258     bool negate = false;
 259     if (text.startsWith(&quot;-&quot;_str)) {
 260         negate = true;
 261         text = text.substring(1);
 262     }
 263     int base = 10;
 264     if (text.startsWith(&quot;0x&quot;_str)) {
 265         text = text.substring(2);
 266         base = 16;
 267     }
 268 
 269     unsigned result = 0;
 270     for (auto codePoint : text.codePoints()) {
 271         unsigned digit = digitValue(codePoint);
 272         auto previous = result;
 273         result = result * base + digit;
 274         if (result &lt; previous)
<a name="31" id="anc31"></a><span class="line-modified"> 275             return makeUnexpected(Error(makeString(&quot;int literal &quot;, text, &quot; is out of bounds&quot;)));</span>
 276     }
 277     if (negate) {
<a name="32" id="anc32"></a><span class="line-modified"> 278         static_assert(sizeof(int64_t) &gt; sizeof(unsigned) &amp;&amp; sizeof(int64_t) &gt; sizeof(int), &quot;This code would be wrong otherwise&quot;);</span>
<span class="line-modified"> 279         int64_t intResult = -static_cast&lt;int64_t&gt;(result);</span>
<span class="line-modified"> 280         if (intResult &lt; static_cast&lt;int64_t&gt;(std::numeric_limits&lt;int&gt;::min()))</span>
<span class="line-modified"> 281             return makeUnexpected(Error(makeString(&quot;int literal &quot;, text, &quot; is out of bounds&quot;)));</span>
<span class="line-added"> 282         return { static_cast&lt;int&gt;(intResult) };</span>
 283     }
 284     if (result &gt; static_cast&lt;unsigned&gt;(std::numeric_limits&lt;int&gt;::max()))
<a name="33" id="anc33"></a><span class="line-modified"> 285         return makeUnexpected(Error(makeString(&quot;int literal &quot;, text, &quot; is out of bounds&quot;)));</span>
 286     return { static_cast&lt;int&gt;(result) };
 287 }
 288 
<a name="34" id="anc34"></a><span class="line-modified"> 289 static Expected&lt;unsigned, Error&gt; uintLiteralToUint(StringView text)</span>
 290 {
 291     unsigned base = 10;
 292     if (text.startsWith(&quot;0x&quot;_str)) {
 293         text = text.substring(2);
 294         base = 16;
 295     }
 296     ASSERT(text.endsWith(&quot;u&quot;));
 297     text = text.substring(0, text.length() - 1);
 298     unsigned result = 0;
 299     for (auto codePoint : text.codePoints()) {
 300         unsigned digit = digitValue(codePoint);
 301         auto previous = result;
 302         result = result * base + digit;
 303         if (result &lt; previous)
<a name="35" id="anc35"></a><span class="line-modified"> 304             return makeUnexpected(Error(makeString(&quot;uint literal &quot;, text, &quot; is out of bounds&quot;)));</span>
 305     }
 306     return { result };
 307 }
 308 
<a name="36" id="anc36"></a><span class="line-modified"> 309 static Expected&lt;float, Error&gt; floatLiteralToFloat(StringView text)</span>
 310 {
 311     size_t parsedLength;
 312     auto result = parseDouble(text, parsedLength);
 313     if (parsedLength != text.length())
<a name="37" id="anc37"></a><span class="line-modified"> 314         return makeUnexpected(Error(makeString(&quot;Cannot parse float &quot;, text)));</span>
 315     return static_cast&lt;float&gt;(result);
 316 }
 317 
 318 auto Parser::consumeIntegralLiteral() -&gt; Expected&lt;Variant&lt;int, unsigned&gt;, Error&gt;
 319 {
<a name="38" id="anc38"></a><span class="line-modified"> 320     auto integralLiteralToken = consumeTypes&lt;Token::Type::IntLiteral, Token::Type::UintLiteral&gt;();</span>
 321     if (!integralLiteralToken)
<a name="39" id="anc39"></a><span class="line-modified"> 322         return makeUnexpected(integralLiteralToken.error());</span>
 323 
 324     switch (integralLiteralToken-&gt;type) {
<a name="40" id="anc40"></a><span class="line-modified"> 325     case Token::Type::IntLiteral: {</span>
<span class="line-modified"> 326         auto result = intLiteralToInt(integralLiteralToken-&gt;stringView(m_lexer));</span>
 327         if (result)
 328             return {{ *result }};
<a name="41" id="anc41"></a><span class="line-modified"> 329         return makeUnexpected(result.error());</span>
 330     }
 331     default: {
<a name="42" id="anc42"></a><span class="line-modified"> 332         ASSERT(integralLiteralToken-&gt;type == Token::Type::UintLiteral);</span>
<span class="line-modified"> 333         auto result = uintLiteralToUint(integralLiteralToken-&gt;stringView(m_lexer));</span>
 334         if (result)
 335             return {{ *result }};
<a name="43" id="anc43"></a><span class="line-modified"> 336         return makeUnexpected(result.error());</span>
 337     }
 338     }
 339 }
 340 
 341 auto Parser::consumeNonNegativeIntegralLiteral() -&gt; Expected&lt;unsigned, Error&gt;
 342 {
 343     auto integralLiteral = consumeIntegralLiteral();
 344     if (!integralLiteral)
<a name="44" id="anc44"></a><span class="line-modified"> 345         return makeUnexpected(integralLiteral.error());</span>
 346     auto result = WTF::visit(WTF::makeVisitor([](int x) -&gt; Optional&lt;unsigned&gt; {
 347         if (x &lt; 0)
 348             return WTF::nullopt;
 349         return x;
 350     }, [](unsigned x) -&gt; Optional&lt;unsigned&gt; {
 351         return x;
 352     }), *integralLiteral);
 353     if (result)
 354         return *result;
 355     return fail(&quot;int literal is negative&quot;_str);
 356 }
 357 
<a name="45" id="anc45"></a><span class="line-modified"> 358 static Expected&lt;unsigned, Error&gt; recognizeSimpleUnsignedInteger(StringView stringView)</span>
 359 {
 360     unsigned result = 0;
 361     if (stringView.length() &lt; 1)
<a name="46" id="anc46"></a><span class="line-modified"> 362         return makeUnexpected(Error(makeString(&quot;Simple unsigned literal &quot;, stringView, &quot; is too short&quot;)));</span>
 363     for (auto codePoint : stringView.codePoints()) {
 364         if (codePoint &lt; &#39;0&#39; || codePoint &gt; &#39;9&#39;)
<a name="47" id="anc47"></a><span class="line-modified"> 365             return makeUnexpected(Error(makeString(&quot;Simple unsigned literal &quot;, stringView, &quot; isn&#39;t of the form [0-9]+&quot;)));</span>
 366         auto previous = result;
 367         result = result * 10 + (codePoint - &#39;0&#39;);
 368         if (result &lt; previous)
<a name="48" id="anc48"></a><span class="line-modified"> 369             return makeUnexpected(Error(makeString(&quot;Simple unsigned literal &quot;, stringView, &quot; is out of bounds&quot;)));</span>
 370     }
 371     return result;
 372 }
 373 
 374 auto Parser::parseConstantExpression() -&gt; Expected&lt;AST::ConstantExpression, Error&gt;
 375 {
<a name="49" id="anc49"></a><span class="line-modified"> 376     auto type = consumeTypes&lt;</span>
<span class="line-modified"> 377         Token::Type::IntLiteral,</span>
<span class="line-modified"> 378         Token::Type::UintLiteral,</span>
<span class="line-modified"> 379         Token::Type::FloatLiteral,</span>
<span class="line-modified"> 380         Token::Type::Null,</span>
<span class="line-modified"> 381         Token::Type::True,</span>
<span class="line-modified"> 382         Token::Type::False,</span>
<span class="line-modified"> 383         Token::Type::Identifier&gt;();</span>

 384     if (!type)
<a name="50" id="anc50"></a><span class="line-modified"> 385         return makeUnexpected(type.error());</span>
 386 
 387     switch (type-&gt;type) {
<a name="51" id="anc51"></a><span class="line-modified"> 388     case Token::Type::IntLiteral: {</span>
<span class="line-modified"> 389         auto value = intLiteralToInt(type-&gt;stringView(m_lexer));</span>
 390         if (!value)
<a name="52" id="anc52"></a><span class="line-modified"> 391             return makeUnexpected(value.error());</span>
<span class="line-modified"> 392         return {{ AST::IntegerLiteral({ *type }, *value) }};</span>
 393     }
<a name="53" id="anc53"></a><span class="line-modified"> 394     case Token::Type::UintLiteral: {</span>
<span class="line-modified"> 395         auto value = uintLiteralToUint(type-&gt;stringView(m_lexer));</span>
 396         if (!value)
<a name="54" id="anc54"></a><span class="line-modified"> 397             return makeUnexpected(value.error());</span>
<span class="line-modified"> 398         return {{ AST::UnsignedIntegerLiteral({ *type }, *value) }};</span>
 399     }
<a name="55" id="anc55"></a><span class="line-modified"> 400     case Token::Type::FloatLiteral: {</span>
<span class="line-modified"> 401         auto value = floatLiteralToFloat(type-&gt;stringView(m_lexer));</span>
 402         if (!value)
<a name="56" id="anc56"></a><span class="line-modified"> 403             return makeUnexpected(value.error());</span>
<span class="line-modified"> 404         return {{ AST::FloatLiteral({ *type }, *value) }};</span>
 405     }
<a name="57" id="anc57"></a><span class="line-modified"> 406     case Token::Type::Null:</span>
 407         return { AST::NullLiteral(WTFMove(*type)) };
<a name="58" id="anc58"></a><span class="line-modified"> 408     case Token::Type::True:</span>
 409         return { AST::BooleanLiteral(WTFMove(*type), true) };
<a name="59" id="anc59"></a><span class="line-modified"> 410     case Token::Type::False:</span>
 411         return { AST::BooleanLiteral(WTFMove(*type), false) };
 412     default: {
<a name="60" id="anc60"></a><span class="line-modified"> 413         ASSERT(type-&gt;type == Token::Type::Identifier);</span>
<span class="line-modified"> 414         CONSUME_TYPE(fullStop, FullStop);</span>
<span class="line-modified"> 415         CONSUME_TYPE(next, Identifier);</span>
<span class="line-modified"> 416         return { AST::EnumerationMemberLiteral({ *type, *next }, type-&gt;stringView(m_lexer).toString(), next-&gt;stringView(m_lexer).toString()) };</span>




 417     }
 418     }
 419 }
 420 
 421 auto Parser::parseTypeArgument() -&gt; Expected&lt;AST::TypeArgument, Error&gt;
 422 {
<a name="61" id="anc61"></a><span class="line-modified"> 423     PEEK(nextToken);</span>
<span class="line-modified"> 424     PEEK_FURTHER(furtherToken);</span>
<span class="line-modified"> 425     if (nextToken-&gt;type != Token::Type::Identifier || furtherToken-&gt;type == Token::Type::FullStop) {</span>
<span class="line-modified"> 426         PARSE(constantExpression, ConstantExpression);</span>
 427         return AST::TypeArgument(WTFMove(*constantExpression));
<a name="62" id="anc62"></a><span class="line-modified"> 428     }</span>
<span class="line-modified"> 429     CONSUME_TYPE(result, Identifier);</span>
<span class="line-modified"> 430     CodeLocation location(*result);</span>
<span class="line-modified"> 431     return AST::TypeArgument(AST::TypeReference::create(location, result-&gt;stringView(m_lexer).toString(), AST::TypeArguments()));</span>
 432 }
 433 
 434 auto Parser::parseTypeArguments() -&gt; Expected&lt;AST::TypeArguments, Error&gt;
 435 {
<a name="63" id="anc63"></a><span class="line-modified"> 436     AST::TypeArguments typeArguments;</span>
<span class="line-modified"> 437     auto lessThanSign = tryType(Token::Type::LessThanSign);</span>
<span class="line-modified"> 438     if (!lessThanSign)</span>















 439         return typeArguments;
<a name="64" id="anc64"></a>


 440 
<a name="65" id="anc65"></a><span class="line-modified"> 441     auto greaterThanSign = tryType(Token::Type::GreaterThanSign);</span>
<span class="line-modified"> 442     if (greaterThanSign)</span>
<span class="line-modified"> 443         return typeArguments;</span>
<span class="line-modified"> 444 </span>
<span class="line-modified"> 445     PARSE(typeArgument, TypeArgument);</span>
<span class="line-modified"> 446     typeArguments.append(WTFMove(*typeArgument));</span>
<span class="line-modified"> 447 </span>
<span class="line-modified"> 448     while (true) {</span>
<span class="line-modified"> 449         auto greaterThanSign = tryType(Token::Type::GreaterThanSign);</span>
<span class="line-modified"> 450         if (greaterThanSign)</span>
<span class="line-modified"> 451             break;</span>
<span class="line-added"> 452 </span>
<span class="line-added"> 453         CONSUME_TYPE(comma, Comma);</span>
<span class="line-added"> 454         PARSE(typeArgument, TypeArgument);</span>
<span class="line-added"> 455         typeArguments.append(WTFMove(*typeArgument));</span>
<span class="line-added"> 456     }</span>
 457 
<a name="66" id="anc66"></a><span class="line-modified"> 458     return typeArguments;</span>
 459 }
 460 
 461 auto Parser::parseTypeSuffixAbbreviated() -&gt; Expected&lt;TypeSuffixAbbreviated, Error&gt;
 462 {
<a name="67" id="anc67"></a><span class="line-modified"> 463     auto token = consumeTypes&lt;</span>
<span class="line-added"> 464         Token::Type::Star,</span>
<span class="line-added"> 465         Token::Type::SquareBracketPair,</span>
<span class="line-added"> 466         Token::Type::LeftSquareBracket&gt;();</span>
 467     if (!token)
<a name="68" id="anc68"></a><span class="line-modified"> 468         return makeUnexpected(token.error());</span>
<span class="line-modified"> 469     if (token-&gt;type == Token::Type::LeftSquareBracket) {</span>
 470         auto numElements = consumeNonNegativeIntegralLiteral();
 471         if (!numElements)
<a name="69" id="anc69"></a><span class="line-modified"> 472             return makeUnexpected(numElements.error());</span>
<span class="line-modified"> 473         CONSUME_TYPE(rightSquareBracket, RightSquareBracket);</span>
<span class="line-modified"> 474         return {{ { *token, *rightSquareBracket }, *token, *numElements }};</span>


 475     }
<a name="70" id="anc70"></a><span class="line-modified"> 476     return {{ { *token }, *token, WTF::nullopt }};</span>
 477 }
 478 
 479 auto Parser::parseTypeSuffixNonAbbreviated() -&gt; Expected&lt;TypeSuffixNonAbbreviated, Error&gt;
 480 {
<a name="71" id="anc71"></a><span class="line-modified"> 481     auto token = consumeTypes&lt;</span>
<span class="line-added"> 482         Token::Type::Star,</span>
<span class="line-added"> 483         Token::Type::SquareBracketPair,</span>
<span class="line-added"> 484         Token::Type::LeftSquareBracket&gt;();</span>
 485     if (!token)
<a name="72" id="anc72"></a><span class="line-modified"> 486         return makeUnexpected(token.error());</span>
<span class="line-modified"> 487     if (token-&gt;type == Token::Type::LeftSquareBracket) {</span>
 488         auto numElements = consumeNonNegativeIntegralLiteral();
 489         if (!numElements)
<a name="73" id="anc73"></a><span class="line-modified"> 490             return makeUnexpected(numElements.error());</span>
<span class="line-modified"> 491         CONSUME_TYPE(rightSquareBracket, RightSquareBracket);</span>
<span class="line-modified"> 492         return {{ { *token, *rightSquareBracket }, *token, WTF::nullopt, *numElements }};</span>
<span class="line-modified"> 493     }</span>
<span class="line-modified"> 494     auto addressSpaceToken = consumeTypes&lt;</span>
<span class="line-modified"> 495         Token::Type::Constant,</span>
<span class="line-modified"> 496         Token::Type::Device,</span>
<span class="line-added"> 497         Token::Type::Threadgroup,</span>
<span class="line-added"> 498         Token::Type::Thread&gt;();</span>
 499     if (!addressSpaceToken)
<a name="74" id="anc74"></a><span class="line-modified"> 500         return makeUnexpected(addressSpaceToken.error());</span>
 501     AST::AddressSpace addressSpace;
 502     switch (addressSpaceToken-&gt;type) {
<a name="75" id="anc75"></a><span class="line-modified"> 503     case Token::Type::Constant:</span>
 504         addressSpace = AST::AddressSpace::Constant;
 505         break;
<a name="76" id="anc76"></a><span class="line-modified"> 506     case Token::Type::Device:</span>
 507         addressSpace = AST::AddressSpace::Device;
 508         break;
<a name="77" id="anc77"></a><span class="line-modified"> 509     case Token::Type::Threadgroup:</span>
 510         addressSpace = AST::AddressSpace::Threadgroup;
 511         break;
 512     default:
<a name="78" id="anc78"></a><span class="line-modified"> 513         ASSERT(addressSpaceToken-&gt;type == Token::Type::Thread);</span>
 514         addressSpace = AST::AddressSpace::Thread;
 515         break;
 516     }
<a name="79" id="anc79"></a><span class="line-modified"> 517     return {{ { *token }, *token, { addressSpace }, WTF::nullopt }};</span>
 518 }
 519 
<a name="80" id="anc80"></a><span class="line-modified"> 520 auto Parser::parseType() -&gt; Expected&lt;Ref&lt;AST::UnnamedType&gt;, Error&gt;</span>
 521 {
<a name="81" id="anc81"></a><span class="line-modified"> 522     auto addressSpaceToken = tryTypes&lt;</span>
<span class="line-modified"> 523         Token::Type::Constant,</span>
<span class="line-modified"> 524         Token::Type::Device,</span>
<span class="line-modified"> 525         Token::Type::Threadgroup,</span>
<span class="line-modified"> 526         Token::Type::Thread&gt;();</span>
































 527 
<a name="82" id="anc82"></a><span class="line-modified"> 528     CONSUME_TYPE(name, Identifier);</span>
<span class="line-modified"> 529     PARSE(typeArguments, TypeArguments);</span>
<span class="line-modified"> 530 </span>
<span class="line-modified"> 531     if (addressSpaceToken) {</span>
<span class="line-modified"> 532         AST::AddressSpace addressSpace;</span>
<span class="line-modified"> 533         switch (addressSpaceToken-&gt;type) {</span>
<span class="line-modified"> 534         case Token::Type::Constant:</span>
<span class="line-modified"> 535             addressSpace = AST::AddressSpace::Constant;</span>



 536             break;
<a name="83" id="anc83"></a><span class="line-modified"> 537         case Token::Type::Device:</span>
<span class="line-modified"> 538             addressSpace = AST::AddressSpace::Device;</span>
<span class="line-added"> 539             break;</span>
<span class="line-added"> 540         case Token::Type::Threadgroup:</span>
<span class="line-added"> 541             addressSpace = AST::AddressSpace::Threadgroup;</span>
<span class="line-added"> 542             break;</span>
<span class="line-added"> 543         default:</span>
<span class="line-added"> 544             ASSERT(addressSpaceToken-&gt;type == Token::Type::Thread);</span>
<span class="line-added"> 545             addressSpace = AST::AddressSpace::Thread;</span>
<span class="line-added"> 546             break;</span>
<span class="line-added"> 547         }</span>
<span class="line-added"> 548         auto constructTypeFromSuffixAbbreviated = [&amp;](const TypeSuffixAbbreviated&amp; typeSuffixAbbreviated, Ref&lt;AST::UnnamedType&gt;&amp;&amp; previous) -&gt; Ref&lt;AST::UnnamedType&gt; {</span>
<span class="line-added"> 549             CodeLocation location(*addressSpaceToken, typeSuffixAbbreviated.location);</span>
<span class="line-added"> 550             switch (typeSuffixAbbreviated.token.type) {</span>
<span class="line-added"> 551             case Token::Type::Star:</span>
<span class="line-added"> 552                 return { AST::PointerType::create(location, addressSpace, WTFMove(previous)) };</span>
<span class="line-added"> 553             case Token::Type::SquareBracketPair:</span>
<span class="line-added"> 554                 return { AST::ArrayReferenceType::create(location, addressSpace, WTFMove(previous)) };</span>
<span class="line-added"> 555             default:</span>
<span class="line-added"> 556                 ASSERT(typeSuffixAbbreviated.token.type == Token::Type::LeftSquareBracket);</span>
<span class="line-added"> 557                 return { AST::ArrayType::create(location, WTFMove(previous), *typeSuffixAbbreviated.numElements) };</span>
<span class="line-added"> 558             }</span>
<span class="line-added"> 559         };</span>
<span class="line-added"> 560         PARSE(firstTypeSuffixAbbreviated, TypeSuffixAbbreviated);</span>
<span class="line-added"> 561         Ref&lt;AST::UnnamedType&gt; result = AST::TypeReference::create(WTFMove(*addressSpaceToken), name-&gt;stringView(m_lexer).toString(), WTFMove(*typeArguments));</span>
<span class="line-added"> 562         auto next = constructTypeFromSuffixAbbreviated(*firstTypeSuffixAbbreviated, WTFMove(result));</span>
 563         result = WTFMove(next);
<a name="84" id="anc84"></a><span class="line-added"> 564         while (true) {</span>
<span class="line-added"> 565             PEEK(nextToken);</span>
<span class="line-added"> 566             if (nextToken-&gt;type != Token::Type::Star</span>
<span class="line-added"> 567                 &amp;&amp; nextToken-&gt;type != Token::Type::SquareBracketPair</span>
<span class="line-added"> 568                 &amp;&amp; nextToken-&gt;type != Token::Type::LeftSquareBracket) {</span>
<span class="line-added"> 569                 break;</span>
<span class="line-added"> 570             }</span>
<span class="line-added"> 571             PARSE(typeSuffixAbbreviated, TypeSuffixAbbreviated);</span>
<span class="line-added"> 572             // FIXME: The nesting here might be in the wrong order.</span>
<span class="line-added"> 573             next = constructTypeFromSuffixAbbreviated(*typeSuffixAbbreviated, WTFMove(result));</span>
<span class="line-added"> 574             result = WTFMove(next);</span>
<span class="line-added"> 575         }</span>
<span class="line-added"> 576         return WTFMove(result);</span>
 577     }
 578 
<a name="85" id="anc85"></a><span class="line-modified"> 579     auto constructTypeFromSuffixNonAbbreviated = [&amp;](const TypeSuffixNonAbbreviated&amp; typeSuffixNonAbbreviated, Ref&lt;AST::UnnamedType&gt;&amp;&amp; previous) -&gt; Ref&lt;AST::UnnamedType&gt; {</span>
<span class="line-modified"> 580         CodeLocation location(*name, typeSuffixNonAbbreviated.location);</span>














 581         switch (typeSuffixNonAbbreviated.token.type) {
<a name="86" id="anc86"></a><span class="line-modified"> 582         case Token::Type::Star:</span>
<span class="line-modified"> 583             return { AST::PointerType::create(location, *typeSuffixNonAbbreviated.addressSpace, WTFMove(previous)) };</span>
<span class="line-modified"> 584         case Token::Type::SquareBracketPair:</span>
<span class="line-modified"> 585             return { AST::ArrayReferenceType::create(location, *typeSuffixNonAbbreviated.addressSpace, WTFMove(previous)) };</span>
 586         default:
<a name="87" id="anc87"></a><span class="line-modified"> 587             ASSERT(typeSuffixNonAbbreviated.token.type == Token::Type::LeftSquareBracket);</span>
<span class="line-modified"> 588             return { AST::ArrayType::create(location, WTFMove(previous), *typeSuffixNonAbbreviated.numElements) };</span>
 589         }
 590     };
<a name="88" id="anc88"></a><span class="line-modified"> 591     Ref&lt;AST::UnnamedType&gt; result = AST::TypeReference::create(*name, name-&gt;stringView(m_lexer).toString(), WTFMove(*typeArguments));</span>

 592     while (true) {
<a name="89" id="anc89"></a><span class="line-modified"> 593         PEEK(nextToken);</span>
<span class="line-modified"> 594         if (nextToken-&gt;type != Token::Type::Star</span>
<span class="line-modified"> 595             &amp;&amp; nextToken-&gt;type != Token::Type::SquareBracketPair</span>
<span class="line-modified"> 596             &amp;&amp; nextToken-&gt;type != Token::Type::LeftSquareBracket) {</span>
 597             break;
<a name="90" id="anc90"></a><span class="line-added"> 598         }</span>
<span class="line-added"> 599         PARSE(typeSuffixNonAbbreviated, TypeSuffixNonAbbreviated);</span>
 600         // FIXME: The nesting here might be in the wrong order.
 601         auto next = constructTypeFromSuffixNonAbbreviated(*typeSuffixNonAbbreviated, WTFMove(result));
 602         result = WTFMove(next);
 603     }
<a name="91" id="anc91"></a>
 604     return WTFMove(result);
 605 }
 606 
<a name="92" id="anc92"></a>
















 607 auto Parser::parseTypeDefinition() -&gt; Expected&lt;AST::TypeDefinition, Error&gt;
 608 {
<a name="93" id="anc93"></a><span class="line-modified"> 609     CONSUME_TYPE(origin, Typedef);</span>
<span class="line-modified"> 610     CONSUME_TYPE(name, Identifier);</span>
<span class="line-modified"> 611     CONSUME_TYPE(equals, EqualsSign);</span>
<span class="line-modified"> 612     PARSE(type, Type);</span>
<span class="line-modified"> 613     CONSUME_TYPE(semicolon, Semicolon);</span>
<span class="line-modified"> 614     return AST::TypeDefinition({ *origin, *semicolon }, name-&gt;stringView(m_lexer).toString(), WTFMove(*type));</span>










 615 }
 616 
 617 auto Parser::parseBuiltInSemantic() -&gt; Expected&lt;AST::BuiltInSemantic, Error&gt;
 618 {
<a name="94" id="anc94"></a><span class="line-modified"> 619     auto origin = consumeTypes&lt;</span>
<span class="line-modified"> 620         Token::Type::SVInstanceID,</span>
<span class="line-modified"> 621         Token::Type::SVVertexID,</span>
<span class="line-modified"> 622         Token::Type::PSize,</span>
<span class="line-modified"> 623         Token::Type::SVPosition,</span>
<span class="line-modified"> 624         Token::Type::SVIsFrontFace,</span>
<span class="line-modified"> 625         Token::Type::SVSampleIndex,</span>
<span class="line-modified"> 626         Token::Type::SVInnerCoverage,</span>
<span class="line-modified"> 627         Token::Type::SVTarget,</span>
<span class="line-modified"> 628         Token::Type::SVDepth,</span>
<span class="line-modified"> 629         Token::Type::SVCoverage,</span>
<span class="line-modified"> 630         Token::Type::SVDispatchThreadID,</span>
<span class="line-modified"> 631         Token::Type::SVGroupID,</span>
<span class="line-modified"> 632         Token::Type::SVGroupIndex,</span>
<span class="line-modified"> 633         Token::Type::SVGroupThreadID&gt;();</span>
 634     if (!origin)
<a name="95" id="anc95"></a><span class="line-modified"> 635         return makeUnexpected(origin.error());</span>
 636 
 637     switch (origin-&gt;type) {
<a name="96" id="anc96"></a><span class="line-modified"> 638     case Token::Type::SVInstanceID:</span>
<span class="line-modified"> 639         return AST::BuiltInSemantic({ *origin }, AST::BuiltInSemantic::Variable::SVInstanceID);</span>
<span class="line-modified"> 640     case Token::Type::SVVertexID:</span>
<span class="line-modified"> 641         return AST::BuiltInSemantic({ *origin }, AST::BuiltInSemantic::Variable::SVVertexID);</span>
<span class="line-modified"> 642     case Token::Type::PSize:</span>
<span class="line-modified"> 643         return AST::BuiltInSemantic({ *origin }, AST::BuiltInSemantic::Variable::PSize);</span>
<span class="line-modified"> 644     case Token::Type::SVPosition:</span>
<span class="line-modified"> 645         return AST::BuiltInSemantic({ *origin }, AST::BuiltInSemantic::Variable::SVPosition);</span>
<span class="line-modified"> 646     case Token::Type::SVIsFrontFace:</span>
<span class="line-modified"> 647         return AST::BuiltInSemantic({ *origin }, AST::BuiltInSemantic::Variable::SVIsFrontFace);</span>
<span class="line-modified"> 648     case Token::Type::SVSampleIndex:</span>
<span class="line-modified"> 649         return AST::BuiltInSemantic({ *origin }, AST::BuiltInSemantic::Variable::SVSampleIndex);</span>
<span class="line-modified"> 650     case Token::Type::SVInnerCoverage:</span>
<span class="line-modified"> 651         return AST::BuiltInSemantic({ *origin }, AST::BuiltInSemantic::Variable::SVInnerCoverage);</span>
<span class="line-modified"> 652     case Token::Type::SVTarget: {</span>
<span class="line-modified"> 653         auto target = consumeNonNegativeIntegralLiteral(); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195807 Make this work with strings like &quot;SV_Target0&quot;.</span>
 654         if (!target)
<a name="97" id="anc97"></a><span class="line-modified"> 655             return makeUnexpected(target.error());</span>
<span class="line-modified"> 656         return AST::BuiltInSemantic({ *origin }, AST::BuiltInSemantic::Variable::SVTarget, *target);</span>
<span class="line-modified"> 657     }</span>
<span class="line-modified"> 658     case Token::Type::SVDepth:</span>
<span class="line-modified"> 659         return AST::BuiltInSemantic({ *origin }, AST::BuiltInSemantic::Variable::SVDepth);</span>
<span class="line-modified"> 660     case Token::Type::SVCoverage:</span>
<span class="line-modified"> 661         return AST::BuiltInSemantic({ *origin }, AST::BuiltInSemantic::Variable::SVCoverage);</span>
<span class="line-modified"> 662     case Token::Type::SVDispatchThreadID:</span>
<span class="line-modified"> 663         return AST::BuiltInSemantic({ *origin }, AST::BuiltInSemantic::Variable::SVDispatchThreadID);</span>
<span class="line-modified"> 664     case Token::Type::SVGroupID:</span>
<span class="line-modified"> 665         return AST::BuiltInSemantic({ *origin }, AST::BuiltInSemantic::Variable::SVGroupID);</span>
<span class="line-modified"> 666     case Token::Type::SVGroupIndex:</span>
<span class="line-modified"> 667         return AST::BuiltInSemantic({ *origin }, AST::BuiltInSemantic::Variable::SVGroupIndex);</span>
 668     default:
<a name="98" id="anc98"></a><span class="line-modified"> 669         ASSERT(origin-&gt;type == Token::Type::SVGroupThreadID);</span>
<span class="line-modified"> 670         return AST::BuiltInSemantic({ *origin }, AST::BuiltInSemantic::Variable::SVGroupThreadID);</span>
 671     }
 672 }
 673 
 674 auto Parser::parseResourceSemantic() -&gt; Expected&lt;AST::ResourceSemantic, Error&gt;
 675 {
<a name="99" id="anc99"></a><span class="line-modified"> 676     CONSUME_TYPE(origin, Register);</span>
<span class="line-modified"> 677     CONSUME_TYPE(leftParenthesis, LeftParenthesis);</span>

 678 
<a name="100" id="anc100"></a><span class="line-modified"> 679     CONSUME_TYPE(info, Identifier);</span>
<span class="line-modified"> 680     auto infoStringView = info-&gt;stringView(m_lexer);</span>
<span class="line-modified"> 681     if (infoStringView.length() &lt; 2 || (infoStringView[0] != &#39;u&#39;</span>
<span class="line-modified"> 682         &amp;&amp; infoStringView[0] != &#39;t&#39;</span>
<span class="line-modified"> 683         &amp;&amp; infoStringView[0] != &#39;b&#39;</span>
<span class="line-modified"> 684         &amp;&amp; infoStringView[0] != &#39;s&#39;))</span>
<span class="line-modified"> 685         return makeUnexpected(Error(makeString(infoStringView.substring(0, 1), &quot; is not a known resource type (&#39;u&#39;, &#39;t&#39;, &#39;b&#39;, or &#39;s&#39;)&quot;)));</span>





 686 
 687     AST::ResourceSemantic::Mode mode;
<a name="101" id="anc101"></a><span class="line-modified"> 688     switch (infoStringView[0]) {</span>
 689     case &#39;u&#39;:
 690         mode = AST::ResourceSemantic::Mode::UnorderedAccessView;
 691         break;
 692     case &#39;t&#39;:
 693         mode = AST::ResourceSemantic::Mode::Texture;
 694         break;
 695     case &#39;b&#39;:
 696         mode = AST::ResourceSemantic::Mode::Buffer;
 697         break;
 698     case &#39;s&#39;:
 699         mode = AST::ResourceSemantic::Mode::Sampler;
 700         break;
 701     }
 702 
<a name="102" id="anc102"></a><span class="line-modified"> 703     auto index = recognizeSimpleUnsignedInteger(infoStringView.substring(1));</span>
 704     if (!index)
<a name="103" id="anc103"></a><span class="line-modified"> 705         return makeUnexpected(index.error());</span>
 706 
 707     unsigned space = 0;
<a name="104" id="anc104"></a><span class="line-modified"> 708     if (tryType(Token::Type::Comma)) {</span>
<span class="line-modified"> 709         CONSUME_TYPE(spaceToken, Identifier);</span>
<span class="line-modified"> 710         auto spaceTokenStringView = spaceToken-&gt;stringView(m_lexer);</span>
<span class="line-modified"> 711         StringView prefix { &quot;space&quot; };</span>
<span class="line-modified"> 712         if (!spaceTokenStringView.startsWith(prefix))</span>
<span class="line-modified"> 713             return makeUnexpected(Error(makeString(&quot;Second argument to resource semantic &quot;, spaceTokenStringView, &quot; needs be of the form &#39;space0&#39;&quot;)));</span>
<span class="line-modified"> 714         if (spaceTokenStringView.length() &lt;= prefix.length())</span>
<span class="line-modified"> 715             return makeUnexpected(Error(makeString(&quot;Second argument to resource semantic &quot;, spaceTokenStringView, &quot; needs be of the form &#39;space0&#39;&quot;)));</span>
<span class="line-modified"> 716         auto spaceValue = recognizeSimpleUnsignedInteger(spaceTokenStringView.substring(prefix.length()));</span>

 717         if (!spaceValue)
<a name="105" id="anc105"></a><span class="line-modified"> 718             return makeUnexpected(spaceValue.error());</span>
 719         space = *spaceValue;
 720     }
 721 
<a name="106" id="anc106"></a><span class="line-modified"> 722     CONSUME_TYPE(rightParenthesis, RightParenthesis);</span>


 723 
<a name="107" id="anc107"></a><span class="line-modified"> 724     return AST::ResourceSemantic({ *origin, *rightParenthesis }, mode, *index, space);</span>
 725 }
 726 
 727 auto Parser::parseSpecializationConstantSemantic() -&gt; Expected&lt;AST::SpecializationConstantSemantic, Error&gt;
 728 {
<a name="108" id="anc108"></a><span class="line-modified"> 729     CONSUME_TYPE(origin, Specialized);</span>
<span class="line-modified"> 730     return AST::SpecializationConstantSemantic(*origin);</span>


 731 }
 732 
 733 auto Parser::parseStageInOutSemantic() -&gt; Expected&lt;AST::StageInOutSemantic, Error&gt;
 734 {
<a name="109" id="anc109"></a><span class="line-modified"> 735     CONSUME_TYPE(origin, Attribute);</span>
<span class="line-modified"> 736     CONSUME_TYPE(leftParenthesis, LeftParenthesis);</span>





 737 
 738     auto index = consumeNonNegativeIntegralLiteral();
 739     if (!index)
<a name="110" id="anc110"></a><span class="line-modified"> 740         return makeUnexpected(index.error());</span>
 741 
<a name="111" id="anc111"></a><span class="line-modified"> 742     CONSUME_TYPE(rightParenthesis, RightParenthesis);</span>


 743 
<a name="112" id="anc112"></a><span class="line-modified"> 744     return AST::StageInOutSemantic({ *origin, *rightParenthesis }, *index);</span>
 745 }
 746 
<a name="113" id="anc113"></a><span class="line-modified"> 747 auto Parser::parseSemantic() -&gt; Expected&lt;std::unique_ptr&lt;AST::Semantic&gt;, Error&gt;</span>
 748 {
<a name="114" id="anc114"></a><span class="line-modified"> 749     if (!tryType(Token::Type::Colon))</span>
<span class="line-modified"> 750         return { nullptr };</span>





















 751 
<a name="115" id="anc115"></a><span class="line-modified"> 752     PEEK(token);</span>
<span class="line-added"> 753     switch (token-&gt;type) {</span>
<span class="line-added"> 754     case Token::Type::Attribute: {</span>
<span class="line-added"> 755         PARSE(result, StageInOutSemantic);</span>
<span class="line-added"> 756         return { makeUnique&lt;AST::Semantic&gt;(WTFMove(*result)) };</span>
<span class="line-added"> 757     }</span>
<span class="line-added"> 758     case Token::Type::Specialized:  {</span>
<span class="line-added"> 759         PARSE(result, SpecializationConstantSemantic);</span>
<span class="line-added"> 760         return { makeUnique&lt;AST::Semantic&gt;(WTFMove(*result)) };</span>
<span class="line-added"> 761     }</span>
<span class="line-added"> 762     case Token::Type::Register:  {</span>
<span class="line-added"> 763         PARSE(result, ResourceSemantic);</span>
<span class="line-added"> 764         return { makeUnique&lt;AST::Semantic&gt;(WTFMove(*result)) };</span>
<span class="line-added"> 765     }</span>
<span class="line-added"> 766     default:  {</span>
<span class="line-added"> 767         PARSE(result, BuiltInSemantic);</span>
<span class="line-added"> 768         return { makeUnique&lt;AST::Semantic&gt;(WTFMove(*result)) };</span>
<span class="line-added"> 769     }</span>
<span class="line-added"> 770     }</span>
 771 }
 772 AST::Qualifiers Parser::parseQualifiers()
 773 {
 774     AST::Qualifiers qualifiers;
<a name="116" id="anc116"></a><span class="line-modified"> 775     while (auto next = tryType(Token::Type::Qualifier)) {</span>
<span class="line-modified"> 776         auto nextStringView = next-&gt;stringView(m_lexer);</span>
<span class="line-modified"> 777         if (&quot;nointerpolation&quot; == nextStringView)</span>
<span class="line-modified"> 778             qualifiers.append(AST::Qualifier::Nointerpolation);</span>
<span class="line-modified"> 779         else if (&quot;noperspective&quot; == nextStringView)</span>
<span class="line-modified"> 780             qualifiers.append(AST::Qualifier::Noperspective);</span>
<span class="line-modified"> 781         else if (&quot;uniform&quot; == nextStringView)</span>
<span class="line-modified"> 782             qualifiers.append(AST::Qualifier::Uniform);</span>
<span class="line-modified"> 783         else if (&quot;centroid&quot; == nextStringView)</span>
<span class="line-modified"> 784             qualifiers.append(AST::Qualifier::Centroid);</span>
<span class="line-modified"> 785         else {</span>
<span class="line-modified"> 786             ASSERT(&quot;sample&quot; == nextStringView);</span>
<span class="line-modified"> 787             qualifiers.append(AST::Qualifier::Sample);</span>
<span class="line-modified"> 788         }</span>


 789     }
 790     return qualifiers;
 791 }
 792 
 793 auto Parser::parseStructureElement() -&gt; Expected&lt;AST::StructureElement, Error&gt;
 794 {
<a name="117" id="anc117"></a><span class="line-modified"> 795     PEEK(origin);</span>


 796 
 797     AST::Qualifiers qualifiers = parseQualifiers();
 798 
<a name="118" id="anc118"></a><span class="line-modified"> 799     PARSE(type, Type);</span>
<span class="line-modified"> 800     CONSUME_TYPE(name, Identifier);</span>
<span class="line-modified"> 801     PARSE(semantic, Semantic);</span>
<span class="line-modified"> 802     CONSUME_TYPE(semicolon, Semicolon);</span>












 803 
<a name="119" id="anc119"></a><span class="line-modified"> 804     return AST::StructureElement({ *origin, *semicolon }, WTFMove(qualifiers), WTFMove(*type), name-&gt;stringView(m_lexer).toString(), WTFMove(*semantic));</span>







 805 }
 806 
 807 auto Parser::parseStructureDefinition() -&gt; Expected&lt;AST::StructureDefinition, Error&gt;
 808 {
<a name="120" id="anc120"></a><span class="line-modified"> 809     CONSUME_TYPE(origin, Struct);</span>
<span class="line-modified"> 810     CONSUME_TYPE(name, Identifier);</span>
<span class="line-modified"> 811     CONSUME_TYPE(leftCurlyBracket, LeftCurlyBracket);</span>








 812 
 813     AST::StructureElements structureElements;
<a name="121" id="anc121"></a><span class="line-modified"> 814     while (!peekType(Token::Type::RightCurlyBracket)) {</span>
<span class="line-modified"> 815         PARSE(structureElement, StructureElement);</span>
<span class="line-modified"> 816         structureElements.append(WTFMove(*structureElement));</span>





 817     }
 818 
<a name="122" id="anc122"></a><span class="line-modified"> 819     auto rightCurlyBracket = m_lexer.consumeToken();</span>


 820 
<a name="123" id="anc123"></a><span class="line-modified"> 821     return AST::StructureDefinition({ *origin, rightCurlyBracket }, name-&gt;stringView(m_lexer).toString(), WTFMove(structureElements));</span>
 822 }
 823 
 824 auto Parser::parseEnumerationDefinition() -&gt; Expected&lt;AST::EnumerationDefinition, Error&gt;
 825 {
<a name="124" id="anc124"></a><span class="line-modified"> 826     CONSUME_TYPE(origin, Enum);</span>
<span class="line-modified"> 827     CONSUME_TYPE(name, Identifier);</span>





 828 
<a name="125" id="anc125"></a><span class="line-modified"> 829     auto type = ([&amp;]() -&gt; Expected&lt;Ref&lt;AST::UnnamedType&gt;, Error&gt; {</span>
<span class="line-modified"> 830         if (tryType(Token::Type::Colon)) {</span>
<span class="line-modified"> 831             PARSE(parsedType, Type);</span>


 832             return WTFMove(*parsedType);
 833         }
<a name="126" id="anc126"></a><span class="line-modified"> 834         return { AST::TypeReference::create(*origin, &quot;int&quot;_str, AST::TypeArguments()) };</span>
 835     })();
 836     if (!type)
<a name="127" id="anc127"></a><span class="line-modified"> 837         return makeUnexpected(type.error());</span>
 838 
<a name="128" id="anc128"></a><span class="line-modified"> 839     CONSUME_TYPE(leftCurlyBracket, LeftCurlyBracket);</span>


 840 
<a name="129" id="anc129"></a><span class="line-modified"> 841     int64_t nextValue = 0;</span>
<span class="line-modified"> 842     PARSE(firstEnumerationMember, EnumerationMember, nextValue);</span>
<span class="line-modified"> 843     nextValue = firstEnumerationMember-&gt;value() + 1;</span>
 844 
<a name="130" id="anc130"></a><span class="line-modified"> 845     AST::EnumerationDefinition result({ }, name-&gt;stringView(m_lexer).toString(), WTFMove(*type));</span>
 846     auto success = result.add(WTFMove(*firstEnumerationMember));
 847     if (!success)
 848         return fail(&quot;Cannot add enumeration member&quot;_str);
 849 
<a name="131" id="anc131"></a><span class="line-modified"> 850     while (tryType(Token::Type::Comma)) {</span>
<span class="line-modified"> 851         PARSE(member, EnumerationMember, nextValue);</span>
<span class="line-modified"> 852         nextValue = member-&gt;value() + 1;</span>

 853         success = result.add(WTFMove(*member));
 854         if (!success)
 855             return fail(&quot;Cannot add enumeration member&quot;_str);
 856     }
 857 
<a name="132" id="anc132"></a><span class="line-modified"> 858     CONSUME_TYPE(rightCurlyBracket, RightCurlyBracket);</span>
<span class="line-modified"> 859     result.updateCodeLocation({ *origin, *rightCurlyBracket});</span>

 860 
 861     return WTFMove(result);
 862 }
 863 
<a name="133" id="anc133"></a><span class="line-modified"> 864 auto Parser::parseEnumerationMember(int64_t defaultValue) -&gt; Expected&lt;AST::EnumerationMember, Error&gt;</span>
 865 {
<a name="134" id="anc134"></a><span class="line-modified"> 866     CONSUME_TYPE(identifier, Identifier);</span>
<span class="line-modified"> 867     auto name = identifier-&gt;stringView(m_lexer).toString();</span>
<span class="line-modified"> 868 </span>
<span class="line-modified"> 869     if (tryType(Token::Type::EqualsSign)) {</span>
<span class="line-added"> 870         PARSE(constantExpression, ConstantExpression);</span>
 871 
<a name="135" id="anc135"></a><span class="line-modified"> 872         Optional&lt;int64_t&gt; value;</span>
<span class="line-modified"> 873         constantExpression-&gt;visit(WTF::makeVisitor([&amp;](AST::IntegerLiteral&amp; integerLiteral) {</span>
<span class="line-modified"> 874             value = integerLiteral.value();</span>
<span class="line-modified"> 875         }, [&amp;](AST::UnsignedIntegerLiteral&amp; unsignedIntegerLiteral) {</span>
<span class="line-modified"> 876             value = unsignedIntegerLiteral.value();</span>
<span class="line-added"> 877         }, [&amp;](AST::FloatLiteral&amp;) {</span>
<span class="line-added"> 878         }, [&amp;](AST::NullLiteral&amp;) {</span>
<span class="line-added"> 879         }, [&amp;](AST::BooleanLiteral&amp;) {</span>
<span class="line-added"> 880         }, [&amp;](AST::EnumerationMemberLiteral&amp;) {</span>
<span class="line-added"> 881         }));</span>
<span class="line-added"> 882 </span>
<span class="line-added"> 883         if (!value)</span>
<span class="line-added"> 884             return makeUnexpected(Error(&quot;enum initialization values can only be an int or uint constant.&quot;));</span>
<span class="line-added"> 885         return AST::EnumerationMember(*identifier, WTFMove(name), *value);</span>
 886     }
<a name="136" id="anc136"></a><span class="line-modified"> 887     return AST::EnumerationMember(*identifier, WTFMove(name), defaultValue);</span>
 888 }
 889 
 890 auto Parser::parseNativeTypeDeclaration() -&gt; Expected&lt;AST::NativeTypeDeclaration, Error&gt;
 891 {
<a name="137" id="anc137"></a><span class="line-modified"> 892     CONSUME_TYPE(origin, Native);</span>
<span class="line-modified"> 893     CONSUME_TYPE(parsedTypedef, Typedef);</span>
<span class="line-modified"> 894     CONSUME_TYPE(name, Identifier);</span>
<span class="line-modified"> 895     PARSE(typeArguments, TypeArguments);</span>
<span class="line-modified"> 896     CONSUME_TYPE(semicolon, Semicolon);</span>






 897 
<a name="138" id="anc138"></a><span class="line-modified"> 898     return AST::NativeTypeDeclaration({ *origin, *semicolon }, name-&gt;stringView(m_lexer).toString(), WTFMove(*typeArguments));</span>








 899 }
 900 
 901 auto Parser::parseNumThreadsFunctionAttribute() -&gt; Expected&lt;AST::NumThreadsFunctionAttribute, Error&gt;
 902 {
<a name="139" id="anc139"></a><span class="line-modified"> 903     CONSUME_TYPE(origin, NumThreads);</span>
<span class="line-modified"> 904     CONSUME_TYPE(leftParenthesis, LeftParenthesis);</span>





 905 
 906     auto width = consumeNonNegativeIntegralLiteral();
 907     if (!width)
<a name="140" id="anc140"></a><span class="line-modified"> 908         return makeUnexpected(width.error());</span>
 909 
<a name="141" id="anc141"></a><span class="line-modified"> 910     CONSUME_TYPE(comma, Comma);</span>


 911 
 912     auto height = consumeNonNegativeIntegralLiteral();
 913     if (!height)
<a name="142" id="anc142"></a><span class="line-modified"> 914         return makeUnexpected(height.error());</span>
 915 
<a name="143" id="anc143"></a><span class="line-modified"> 916     CONSUME_TYPE(secondComma, Comma);</span>


 917 
 918     auto depth = consumeNonNegativeIntegralLiteral();
 919     if (!depth)
<a name="144" id="anc144"></a><span class="line-modified"> 920         return makeUnexpected(depth.error());</span>
 921 
<a name="145" id="anc145"></a><span class="line-modified"> 922     CONSUME_TYPE(rightParenthesis, RightParenthesis);</span>


 923 
<a name="146" id="anc146"></a><span class="line-modified"> 924     return AST::NumThreadsFunctionAttribute({ *origin, *rightParenthesis }, *width, *height, *depth);</span>
 925 }
 926 
 927 auto Parser::parseAttributeBlock() -&gt; Expected&lt;AST::AttributeBlock, Error&gt;
 928 {
<a name="147" id="anc147"></a><span class="line-modified"> 929     CONSUME_TYPE(leftSquareBracket, LeftSquareBracket);</span>


 930 
 931     AST::AttributeBlock result;
 932 
<a name="148" id="anc148"></a><span class="line-modified"> 933     while (!tryType(Token::Type::RightSquareBracket)) {</span>
<span class="line-modified"> 934         PARSE(numThreadsFunctionAttribute, NumThreadsFunctionAttribute);</span>
<span class="line-modified"> 935         result.append(WTFMove(*numThreadsFunctionAttribute));</span>







 936     }
 937 
<a name="149" id="anc149"></a>



 938     return WTFMove(result);
 939 }
 940 
 941 auto Parser::parseParameter() -&gt; Expected&lt;AST::VariableDeclaration, Error&gt;
 942 {
<a name="150" id="anc150"></a><span class="line-modified"> 943     auto startOffset = m_lexer.peek().startOffset();</span>


 944 
 945     AST::Qualifiers qualifiers = parseQualifiers();
<a name="151" id="anc151"></a><span class="line-modified"> 946     PARSE(type, Type);</span>



 947 
 948     String name;
<a name="152" id="anc152"></a><span class="line-modified"> 949     if (auto token = tryType(Token::Type::Identifier))</span>
<span class="line-modified"> 950         name = token-&gt;stringView(m_lexer).toString();</span>
 951 
<a name="153" id="anc153"></a><span class="line-modified"> 952     PARSE(semantic, Semantic);</span>
<span class="line-modified"> 953 </span>
<span class="line-modified"> 954     auto endOffset = m_lexer.peek().startOffset();</span>



 955 
<a name="154" id="anc154"></a><span class="line-modified"> 956     return AST::VariableDeclaration({ startOffset, endOffset, m_lexer.nameSpace() }, WTFMove(qualifiers), { WTFMove(*type) }, WTFMove(name), WTFMove(*semantic), nullptr);</span>
 957 }
 958 
 959 auto Parser::parseParameters() -&gt; Expected&lt;AST::VariableDeclarations, Error&gt;
 960 {
<a name="155" id="anc155"></a>



 961     AST::VariableDeclarations parameters;
<a name="156" id="anc156"></a><span class="line-modified"> 962 </span>
<span class="line-added"> 963     CONSUME_TYPE(leftParenthesis, LeftParenthesis);</span>
<span class="line-added"> 964 </span>
<span class="line-added"> 965     if (tryType(Token::Type::RightParenthesis))</span>
 966         return WTFMove(parameters);
 967 
<a name="157" id="anc157"></a><span class="line-modified"> 968     PARSE(firstParameter, Parameter);</span>
<span class="line-modified"> 969     parameters.append(makeUniqueRef&lt;AST::VariableDeclaration&gt;(WTFMove(*firstParameter)));</span>


 970 
<a name="158" id="anc158"></a><span class="line-modified"> 971     while (tryType(Token::Type::Comma)) {</span>
<span class="line-modified"> 972         PARSE(parameter, Parameter);</span>
<span class="line-modified"> 973         parameters.append(makeUniqueRef&lt;AST::VariableDeclaration&gt;(WTFMove(*parameter)));</span>


 974     }
 975 
<a name="159" id="anc159"></a><span class="line-modified"> 976     CONSUME_TYPE(rightParenthesis, RightParenthesis);</span>


 977 
 978     return WTFMove(parameters);
 979 }
 980 
 981 auto Parser::parseFunctionDefinition() -&gt; Expected&lt;AST::FunctionDefinition, Error&gt;
 982 {
<a name="160" id="anc160"></a><span class="line-modified"> 983     PARSE(functionDeclaration, FunctionDeclaration);</span>
<span class="line-modified"> 984     PARSE(block, Block);</span>






 985     return AST::FunctionDefinition(WTFMove(*functionDeclaration), WTFMove(*block));
 986 }
 987 
<a name="161" id="anc161"></a><span class="line-modified"> 988 auto Parser::parseComputeFunctionDeclaration() -&gt; Expected&lt;AST::FunctionDeclaration, Error&gt;</span>
 989 {
<a name="162" id="anc162"></a><span class="line-modified"> 990     PEEK(origin);</span>


 991 
<a name="163" id="anc163"></a><span class="line-modified"> 992     PARSE(attributeBlock, AttributeBlock);</span>
<span class="line-modified"> 993     CONSUME_TYPE(compute, Compute);</span>
<span class="line-modified"> 994     PARSE(type, Type);</span>
<span class="line-modified"> 995     CONSUME_TYPE(name, Identifier);</span>
<span class="line-modified"> 996     PARSE(parameters, Parameters);</span>
<span class="line-modified"> 997     PARSE(semantic, Semantic);</span>





















 998 
<a name="164" id="anc164"></a><span class="line-modified"> 999     auto endOffset = m_lexer.peek().startOffset();</span>


1000 
<a name="165" id="anc165"></a><span class="line-modified">1001     bool isOperator = false;</span>
<span class="line-modified">1002     return AST::FunctionDeclaration({ origin-&gt;startOffset(), endOffset, m_lexer.nameSpace() }, WTFMove(*attributeBlock), AST::EntryPointType::Compute, WTFMove(*type), name-&gt;stringView(m_lexer).toString(), WTFMove(*parameters), WTFMove(*semantic), isOperator, m_mode);</span>
<span class="line-modified">1003 }</span>
1004 
<a name="166" id="anc166"></a><span class="line-modified">1005 auto Parser::parseVertexOrFragmentFunctionDeclaration() -&gt; Expected&lt;AST::FunctionDeclaration, Error&gt;</span>
<span class="line-modified">1006 {</span>
<span class="line-modified">1007     auto entryPoint = consumeTypes&lt;Token::Type::Vertex, Token::Type::Fragment&gt;();</span>
<span class="line-added">1008     if (!entryPoint)</span>
<span class="line-added">1009         return makeUnexpected(entryPoint.error());</span>
<span class="line-added">1010     auto entryPointType = (entryPoint-&gt;type == Token::Type::Vertex) ? AST::EntryPointType::Vertex : AST::EntryPointType::Fragment;</span>
1011 
<a name="167" id="anc167"></a><span class="line-modified">1012     PARSE(type, Type);</span>
<span class="line-added">1013     CONSUME_TYPE(name, Identifier);</span>
<span class="line-added">1014     PARSE(parameters, Parameters);</span>
<span class="line-added">1015     PARSE(semantic, Semantic);</span>
1016 
<a name="168" id="anc168"></a><span class="line-modified">1017     auto endOffset = m_lexer.peek().startOffset();</span>





1018 
<a name="169" id="anc169"></a><span class="line-modified">1019     bool isOperator = false;</span>
<span class="line-added">1020     return AST::FunctionDeclaration({ entryPoint-&gt;startOffset(), endOffset, m_lexer.nameSpace() }, { }, entryPointType, WTFMove(*type), name-&gt;stringView(m_lexer).toString(), WTFMove(*parameters), WTFMove(*semantic), isOperator, m_mode);</span>
1021 }
1022 
1023 auto Parser::parseRegularFunctionDeclaration() -&gt; Expected&lt;AST::FunctionDeclaration, Error&gt;
1024 {
<a name="170" id="anc170"></a><span class="line-modified">1025     PEEK(origin);</span>


1026 
<a name="171" id="anc171"></a><span class="line-modified">1027     PARSE(type, Type);</span>


1028 
<a name="172" id="anc172"></a><span class="line-modified">1029     auto name = consumeTypes&lt;Token::Type::Identifier, Token::Type::OperatorName&gt;();</span>
1030     if (!name)
<a name="173" id="anc173"></a><span class="line-modified">1031         return makeUnexpected(name.error());</span>
<span class="line-modified">1032     auto isOperator = name-&gt;type == Token::Type::OperatorName;</span>
1033 
<a name="174" id="anc174"></a><span class="line-modified">1034     PARSE(parameters, Parameters);</span>
<span class="line-modified">1035     PARSE(semantic, Semantic);</span>

1036 
<a name="175" id="anc175"></a><span class="line-modified">1037     auto endOffset = m_lexer.peek().startOffset();</span>





1038 
<a name="176" id="anc176"></a><span class="line-modified">1039     return AST::FunctionDeclaration({ origin-&gt;startOffset(), endOffset, m_lexer.nameSpace() }, { }, WTF::nullopt, WTFMove(*type), name-&gt;stringView(m_lexer).toString(), WTFMove(*parameters), WTFMove(*semantic), isOperator, m_mode);</span>
1040 }
1041 
1042 auto Parser::parseOperatorFunctionDeclaration() -&gt; Expected&lt;AST::FunctionDeclaration, Error&gt;
1043 {
<a name="177" id="anc177"></a><span class="line-modified">1044     CONSUME_TYPE(origin, Operator);</span>
<span class="line-modified">1045     PARSE(type, Type);</span>
<span class="line-modified">1046     PARSE(parameters, Parameters);</span>
<span class="line-modified">1047     PARSE(semantic, Semantic);</span>



1048 
<a name="178" id="anc178"></a><span class="line-modified">1049     auto endOffset = m_lexer.peek().startOffset();</span>


1050 
1051     bool isOperator = true;
<a name="179" id="anc179"></a><span class="line-modified">1052     return AST::FunctionDeclaration({ origin-&gt;startOffset(), endOffset, m_lexer.nameSpace() }, { }, WTF::nullopt, WTFMove(*type), &quot;operator cast&quot;_str, WTFMove(*parameters), WTFMove(*semantic), isOperator, m_mode);</span>








1053 }
1054 
1055 auto Parser::parseFunctionDeclaration() -&gt; Expected&lt;AST::FunctionDeclaration, Error&gt;
1056 {
<a name="180" id="anc180"></a><span class="line-modified">1057     PEEK(token);</span>
<span class="line-modified">1058     switch (token-&gt;type) {</span>
<span class="line-modified">1059     case Token::Type::Operator:</span>










1060         return parseOperatorFunctionDeclaration();
<a name="181" id="anc181"></a><span class="line-modified">1061     case Token::Type::Vertex:</span>
<span class="line-modified">1062     case Token::Type::Fragment:</span>
<span class="line-modified">1063         return parseVertexOrFragmentFunctionDeclaration();</span>
<span class="line-modified">1064     case Token::Type::LeftSquareBracket:</span>
<span class="line-modified">1065         return parseComputeFunctionDeclaration();</span>
<span class="line-added">1066     default:</span>
<span class="line-added">1067         return parseRegularFunctionDeclaration();</span>
<span class="line-added">1068     }</span>
1069 }
1070 
1071 auto Parser::parseNativeFunctionDeclaration() -&gt; Expected&lt;AST::NativeFunctionDeclaration, Error&gt;
1072 {
<a name="182" id="anc182"></a><span class="line-modified">1073     CONSUME_TYPE(native, Native);</span>
<span class="line-modified">1074     PARSE(functionDeclaration, FunctionDeclaration);</span>
<span class="line-modified">1075     CONSUME_TYPE(semicolon, Semicolon);</span>












1076 
1077     return AST::NativeFunctionDeclaration(WTFMove(*functionDeclaration));
1078 }
1079 
1080 auto Parser::parseBlock() -&gt; Expected&lt;AST::Block, Error&gt;
1081 {
<a name="183" id="anc183"></a><span class="line-modified">1082     CONSUME_TYPE(origin, LeftCurlyBracket);</span>
<span class="line-modified">1083     PARSE(result, BlockBody);</span>
<span class="line-modified">1084     CONSUME_TYPE(rightCurlyBracket, RightCurlyBracket);</span>
<span class="line-modified">1085     result-&gt;updateCodeLocation({ *origin, *rightCurlyBracket });</span>
<span class="line-modified">1086     return WTFMove(*result);</span>






1087 }
1088 
<a name="184" id="anc184"></a><span class="line-modified">1089 auto Parser::parseBlockBody() -&gt; Expected&lt;AST::Block, Error&gt;</span>
1090 {
<a name="185" id="anc185"></a><span class="line-added">1091     auto startOffset = m_lexer.peek().startOffset();</span>
<span class="line-added">1092 </span>
1093     AST::Statements statements;
<a name="186" id="anc186"></a><span class="line-modified">1094     while (!peekTypes&lt;Token::Type::RightCurlyBracket, Token::Type::Case, Token::Type::Default&gt;()) {</span>
<span class="line-modified">1095         PARSE(statement, Statement);</span>
<span class="line-modified">1096         statements.append(WTFMove(*statement));</span>





1097     }
<a name="187" id="anc187"></a><span class="line-modified">1098 </span>
<span class="line-added">1099     auto endOffset = m_lexer.peek().startOffset();</span>
<span class="line-added">1100 </span>
<span class="line-added">1101     return AST::Block({ startOffset, endOffset, m_lexer.nameSpace() }, WTFMove(statements));</span>
1102 }
1103 
1104 auto Parser::parseIfStatement() -&gt; Expected&lt;AST::IfStatement, Error&gt;
1105 {
<a name="188" id="anc188"></a><span class="line-modified">1106     CONSUME_TYPE(origin, If);</span>
<span class="line-modified">1107     CONSUME_TYPE(leftParenthesis, LeftParenthesis);</span>
<span class="line-modified">1108     PARSE(conditional, Expression);</span>
<span class="line-modified">1109     CONSUME_TYPE(rightParenthesis, RightParenthesis);</span>
<span class="line-modified">1110     PARSE(body, Statement);</span>














1111 
<a name="189" id="anc189"></a><span class="line-modified">1112     std::unique_ptr&lt;AST::Statement&gt; elseBody(nullptr);</span>
<span class="line-modified">1113     if (tryType(Token::Type::Else)) {</span>
<span class="line-modified">1114         PARSE(parsedElseBody, Statement);</span>
<span class="line-modified">1115         elseBody = (*parsedElseBody).moveToUniquePtr();</span>


1116     }
1117 
<a name="190" id="anc190"></a><span class="line-added">1118     auto endOffset = m_lexer.peek().startOffset();</span>
<span class="line-added">1119 </span>
1120     Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; castArguments;
1121     castArguments.append(WTFMove(*conditional));
<a name="191" id="anc191"></a><span class="line-modified">1122     auto boolCast = makeUniqueRef&lt;AST::CallExpression&gt;(Token(*origin), &quot;bool&quot;_str, WTFMove(castArguments));</span>
<span class="line-modified">1123     return AST::IfStatement({ origin-&gt;startOffset(), endOffset, m_lexer.nameSpace() }, WTFMove(boolCast), WTFMove(*body), WTFMove(elseBody));</span>
1124 }
1125 
1126 auto Parser::parseSwitchStatement() -&gt; Expected&lt;AST::SwitchStatement, Error&gt;
1127 {
<a name="192" id="anc192"></a><span class="line-modified">1128     CONSUME_TYPE(origin, Switch);</span>
<span class="line-modified">1129     CONSUME_TYPE(leftParenthesis, LeftParenthesis);</span>
<span class="line-modified">1130     PARSE(value, Expression);</span>
<span class="line-added">1131     CONSUME_TYPE(rightParenthesis, RightParenthesis);</span>
<span class="line-added">1132     CONSUME_TYPE(leftCurlyBracket, LeftCurlyBracket);</span>
1133 
<a name="193" id="anc193"></a><span class="line-modified">1134     Vector&lt;AST::SwitchCase&gt; switchCases;</span>
<span class="line-modified">1135     PEEK(nextToken);</span>
<span class="line-modified">1136     while (nextToken-&gt;type != Token::Type::RightCurlyBracket) {</span>
<span class="line-added">1137         PARSE(switchCase, SwitchCase);</span>
<span class="line-added">1138         switchCases.append(WTFMove(*switchCase));</span>
<span class="line-added">1139         PEEK(nextTokenInLoop);</span>
<span class="line-added">1140         nextToken = nextTokenInLoop;</span>
<span class="line-added">1141     }</span>
1142 
<a name="194" id="anc194"></a><span class="line-modified">1143     auto endToken = m_lexer.consumeToken();</span>


1144 
<a name="195" id="anc195"></a><span class="line-modified">1145     return AST::SwitchStatement({ *origin, endToken }, WTFMove(*value), WTFMove(switchCases));</span>
<span class="line-modified">1146 }</span>

1147 
<a name="196" id="anc196"></a><span class="line-modified">1148 auto Parser::parseSwitchCase() -&gt; Expected&lt;AST::SwitchCase, Error&gt;</span>
<span class="line-modified">1149 {</span>
<span class="line-modified">1150     auto origin = consumeTypes&lt;Token::Type::Case, Token::Type::Default&gt;();</span>
<span class="line-modified">1151     if (!origin)</span>
<span class="line-modified">1152         return makeUnexpected(origin.error());</span>






















1153 
1154     switch (origin-&gt;type) {
<a name="197" id="anc197"></a><span class="line-modified">1155     case Token::Type::Case: {</span>
<span class="line-modified">1156         PARSE(value, ConstantExpression);</span>
<span class="line-modified">1157         CONSUME_TYPE(colon, Colon);</span>

1158 
<a name="198" id="anc198"></a><span class="line-modified">1159         PARSE(block, BlockBody);</span>


1160 
<a name="199" id="anc199"></a><span class="line-modified">1161         return AST::SwitchCase({ origin-&gt;codeLocation,  block-&gt;codeLocation()}, WTFMove(*value), WTFMove(*block));</span>


1162     }
1163     default: {
<a name="200" id="anc200"></a><span class="line-modified">1164         ASSERT(origin-&gt;type == Token::Type::Default);</span>
<span class="line-modified">1165         CONSUME_TYPE(colon, Colon);</span>


1166 
<a name="201" id="anc201"></a><span class="line-modified">1167         PARSE(block, BlockBody);</span>
1168 
<a name="202" id="anc202"></a><span class="line-modified">1169         return AST::SwitchCase({ origin-&gt;codeLocation,  block-&gt;codeLocation()}, WTF::nullopt, WTFMove(*block));</span>
1170     }
1171     }
1172 }
1173 
1174 auto Parser::parseForLoop() -&gt; Expected&lt;AST::ForLoop, Error&gt;
1175 {
<a name="203" id="anc203"></a><span class="line-modified">1176     CONSUME_TYPE(origin, For);</span>
<span class="line-modified">1177     CONSUME_TYPE(leftParenthesis, LeftParenthesis);</span>

1178 
<a name="204" id="anc204"></a><span class="line-modified">1179     auto parseRemainder = [&amp;](UniqueRef&lt;AST::Statement&gt;&amp;&amp; initialization) -&gt; Expected&lt;AST::ForLoop, Error&gt; {</span>
<span class="line-modified">1180         CONSUME_TYPE(semicolon, Semicolon);</span>


1181 
<a name="205" id="anc205"></a><span class="line-modified">1182         std::unique_ptr&lt;AST::Expression&gt; condition(nullptr);</span>
<span class="line-added">1183         if (!tryType(Token::Type::Semicolon)) {</span>
1184             if (auto expression = parseExpression())
<a name="206" id="anc206"></a><span class="line-modified">1185                 condition = (*expression).moveToUniquePtr();</span>
<span class="line-modified">1186             else</span>
<span class="line-modified">1187                 return makeUnexpected(expression.error());</span>
<span class="line-modified">1188             CONSUME_TYPE(secondSemicolon, Semicolon);</span>
<span class="line-modified">1189         }</span>


1190 
<a name="207" id="anc207"></a><span class="line-modified">1191         std::unique_ptr&lt;AST::Expression&gt; increment(nullptr);</span>
<span class="line-added">1192         if (!tryType(Token::Type::RightParenthesis)) {</span>
1193             if (auto expression = parseExpression())
<a name="208" id="anc208"></a><span class="line-modified">1194                 increment = (*expression).moveToUniquePtr();</span>
<span class="line-modified">1195             else</span>
<span class="line-modified">1196                 return makeUnexpected(expression.error());</span>
<span class="line-modified">1197             CONSUME_TYPE(rightParenthesis, RightParenthesis);</span>
<span class="line-modified">1198         }</span>






1199 
<a name="209" id="anc209"></a><span class="line-modified">1200         PARSE(body, Statement);</span>
<span class="line-added">1201         CodeLocation location(origin-&gt;codeLocation, (*body)-&gt;codeLocation());</span>
<span class="line-added">1202         return AST::ForLoop(location, WTFMove(initialization), WTFMove(condition), WTFMove(increment), WTFMove(*body));</span>
1203     };
1204 
<a name="210" id="anc210"></a>



1205     auto variableDeclarations = backtrackingScope&lt;Expected&lt;AST::VariableDeclarationsStatement, Error&gt;&gt;([&amp;]() {
1206         return parseVariableDeclarations();
1207     });
<a name="211" id="anc211"></a><span class="line-modified">1208     if (variableDeclarations) {</span>
<span class="line-modified">1209         UniqueRef&lt;AST::Statement&gt; declarationStatement = makeUniqueRef&lt;AST::VariableDeclarationsStatement&gt;(WTFMove(*variableDeclarations));</span>
<span class="line-added">1210         return parseRemainder(WTFMove(declarationStatement));</span>
<span class="line-added">1211     }</span>
1212 
<a name="212" id="anc212"></a><span class="line-modified">1213     PARSE(effectfulExpression, EffectfulExpression);</span>


1214 
1215     return parseRemainder(WTFMove(*effectfulExpression));
1216 }
1217 
1218 auto Parser::parseWhileLoop() -&gt; Expected&lt;AST::WhileLoop, Error&gt;
1219 {
<a name="213" id="anc213"></a><span class="line-modified">1220     CONSUME_TYPE(origin, While);</span>
<span class="line-modified">1221     CONSUME_TYPE(leftParenthesis, LeftParenthesis);</span>
<span class="line-modified">1222     PARSE(conditional, Expression);</span>
<span class="line-modified">1223     CONSUME_TYPE(rightParenthesis, RightParenthesis);</span>
<span class="line-modified">1224     PARSE(body, Statement);</span>










1225 
<a name="214" id="anc214"></a><span class="line-modified">1226     CodeLocation location(origin-&gt;codeLocation,  (*body)-&gt;codeLocation());</span>
<span class="line-modified">1227     return AST::WhileLoop(location, WTFMove(*conditional), WTFMove(*body));</span>



1228 }
1229 
1230 auto Parser::parseDoWhileLoop() -&gt; Expected&lt;AST::DoWhileLoop, Error&gt;
1231 {
<a name="215" id="anc215"></a><span class="line-modified">1232     CONSUME_TYPE(origin, Do);</span>
<span class="line-modified">1233     PARSE(body, Statement);</span>
<span class="line-modified">1234     CONSUME_TYPE(whileKeyword, While);</span>
<span class="line-modified">1235     CONSUME_TYPE(leftParenthesis, LeftParenthesis);</span>
<span class="line-modified">1236     PARSE(conditional, Expression);</span>
<span class="line-modified">1237     CONSUME_TYPE(rightParenthesis, RightParenthesis);</span>
<span class="line-modified">1238     CONSUME_TYPE(semicolon, Semicolon);</span>




1239 
<a name="216" id="anc216"></a><span class="line-modified">1240     return AST::DoWhileLoop({ *origin, *semicolon}, WTFMove(*body), WTFMove(*conditional));</span>












1241 }
1242 
<a name="217" id="anc217"></a><span class="line-modified">1243 auto Parser::parseVariableDeclaration(Ref&lt;AST::UnnamedType&gt;&amp;&amp; type) -&gt; Expected&lt;AST::VariableDeclaration, Error&gt;</span>
1244 {
<a name="218" id="anc218"></a><span class="line-modified">1245     PEEK(origin);</span>


1246 
1247     auto qualifiers = parseQualifiers();
1248 
<a name="219" id="anc219"></a><span class="line-modified">1249     CONSUME_TYPE(name, Identifier);</span>
<span class="line-modified">1250     PARSE(semantic, Semantic);</span>
















1251 
<a name="220" id="anc220"></a><span class="line-modified">1252     std::unique_ptr&lt;AST::Expression&gt; initializer = nullptr;</span>
<span class="line-modified">1253     if (tryType(Token::Type::EqualsSign)) {</span>
<span class="line-modified">1254         PARSE(initializingExpression, PossibleTernaryConditional);</span>
<span class="line-modified">1255         initializer = initializingExpression.value().moveToUniquePtr();</span>

1256     }
1257 
<a name="221" id="anc221"></a><span class="line-modified">1258     auto endOffset = m_lexer.peek().startOffset();</span>
<span class="line-added">1259     return AST::VariableDeclaration({ origin-&gt;startOffset(), endOffset, m_lexer.nameSpace() }, WTFMove(qualifiers), { WTFMove(type) }, name-&gt;stringView(m_lexer).toString(), WTFMove(*semantic), WTFMove(initializer));</span>
1260 }
1261 
1262 auto Parser::parseVariableDeclarations() -&gt; Expected&lt;AST::VariableDeclarationsStatement, Error&gt;
1263 {
<a name="222" id="anc222"></a><span class="line-modified">1264     PEEK(origin);</span>


1265 
<a name="223" id="anc223"></a><span class="line-modified">1266     PARSE(type, Type);</span>


1267 
<a name="224" id="anc224"></a><span class="line-modified">1268     auto firstVariableDeclaration = parseVariableDeclaration(type-&gt;copyRef());</span>
1269     if (!firstVariableDeclaration)
<a name="225" id="anc225"></a><span class="line-modified">1270         return makeUnexpected(firstVariableDeclaration.error());</span>
1271 
<a name="226" id="anc226"></a><span class="line-modified">1272     Vector&lt;UniqueRef&lt;AST::VariableDeclaration&gt;&gt; result;</span>
<span class="line-modified">1273     result.append(makeUniqueRef&lt;AST::VariableDeclaration&gt;(WTFMove(*firstVariableDeclaration)));</span>
1274 
<a name="227" id="anc227"></a><span class="line-modified">1275     while (tryType(Token::Type::Comma)) {</span>
<span class="line-modified">1276         auto variableDeclaration = parseVariableDeclaration(type-&gt;copyRef());</span>
1277         if (!variableDeclaration)
<a name="228" id="anc228"></a><span class="line-modified">1278             return makeUnexpected(variableDeclaration.error());</span>
<span class="line-modified">1279         result.append(makeUniqueRef&lt;AST::VariableDeclaration&gt;(WTFMove(*variableDeclaration)));</span>
1280     }
1281 
<a name="229" id="anc229"></a><span class="line-modified">1282     auto endOffset = m_lexer.peek().startOffset();</span>
<span class="line-added">1283     return AST::VariableDeclarationsStatement({ origin-&gt;startOffset(), endOffset, m_lexer.nameSpace() }, WTFMove(result));</span>
1284 }
1285 
1286 auto Parser::parseStatement() -&gt; Expected&lt;UniqueRef&lt;AST::Statement&gt;, Error&gt;
1287 {
<a name="230" id="anc230"></a><span class="line-modified">1288     PEEK(token);</span>
<span class="line-modified">1289     switch (token-&gt;type) {</span>
<span class="line-modified">1290     case Token::Type::LeftCurlyBracket: {</span>
<span class="line-modified">1291         PARSE(block, Block);</span>
<span class="line-modified">1292         return { makeUniqueRef&lt;AST::Block&gt;(WTFMove(*block)) };</span>
<span class="line-modified">1293     }</span>
<span class="line-modified">1294     case Token::Type::If: {</span>
<span class="line-modified">1295         PARSE(ifStatement, IfStatement);</span>
<span class="line-modified">1296         return { makeUniqueRef&lt;AST::IfStatement&gt;(WTFMove(*ifStatement)) };</span>
<span class="line-modified">1297     }</span>
<span class="line-modified">1298     case Token::Type::Switch: {</span>
<span class="line-modified">1299         PARSE(switchStatement, SwitchStatement);</span>
<span class="line-modified">1300         return { makeUniqueRef&lt;AST::SwitchStatement&gt;(WTFMove(*switchStatement)) };</span>
<span class="line-modified">1301     }</span>
<span class="line-modified">1302     case Token::Type::For: {</span>
<span class="line-modified">1303         PARSE(forLoop, ForLoop);</span>
<span class="line-modified">1304         return { makeUniqueRef&lt;AST::ForLoop&gt;(WTFMove(*forLoop)) };</span>
<span class="line-modified">1305     }</span>
<span class="line-modified">1306     case Token::Type::While: {</span>
<span class="line-modified">1307         PARSE(whileLoop, WhileLoop);</span>
<span class="line-modified">1308         return { makeUniqueRef&lt;AST::WhileLoop&gt;(WTFMove(*whileLoop)) };</span>
<span class="line-modified">1309     }</span>
<span class="line-modified">1310     case Token::Type::Do: {</span>
<span class="line-modified">1311         PARSE(doWhileLoop, DoWhileLoop);</span>
<span class="line-modified">1312         return { makeUniqueRef&lt;AST::DoWhileLoop&gt;(WTFMove(*doWhileLoop)) };</span>
<span class="line-modified">1313     }</span>
<span class="line-modified">1314     case Token::Type::Break: {</span>
<span class="line-modified">1315         auto breakToken = m_lexer.consumeToken();</span>
<span class="line-modified">1316         CONSUME_TYPE(semicolon, Semicolon);</span>
<span class="line-modified">1317         auto breakObject = AST::Break(WTFMove(breakToken));</span>
<span class="line-modified">1318         return { makeUniqueRef&lt;AST::Break&gt;(WTFMove(breakObject)) };</span>
<span class="line-modified">1319     }</span>
<span class="line-modified">1320     case Token::Type::Continue: {</span>
<span class="line-modified">1321         auto continueToken = m_lexer.consumeToken();</span>
<span class="line-modified">1322         CONSUME_TYPE(semicolon, Semicolon);</span>
<span class="line-modified">1323         auto continueObject = AST::Continue(WTFMove(continueToken));</span>
<span class="line-modified">1324         return { makeUniqueRef&lt;AST::Continue&gt;(WTFMove(continueObject)) };</span>
<span class="line-modified">1325     }</span>
<span class="line-modified">1326     case Token::Type::Fallthrough: {</span>
<span class="line-modified">1327         auto fallthroughToken = m_lexer.consumeToken();</span>
<span class="line-modified">1328         CONSUME_TYPE(semicolon, Semicolon);</span>
<span class="line-modified">1329         auto fallthroughObject = AST::Fallthrough(WTFMove(fallthroughToken));</span>
<span class="line-modified">1330         return { makeUniqueRef&lt;AST::Fallthrough&gt;(WTFMove(fallthroughObject)) };</span>
<span class="line-modified">1331     }</span>
<span class="line-modified">1332     case Token::Type::Return: {</span>
<span class="line-modified">1333         auto returnToken = m_lexer.consumeToken();</span>
<span class="line-modified">1334         if (auto semicolon = tryType(Token::Type::Semicolon)) {</span>
<span class="line-modified">1335             auto returnObject = AST::Return(WTFMove(returnToken), nullptr);</span>
<span class="line-modified">1336             return { makeUniqueRef&lt;AST::Return&gt;(WTFMove(returnObject)) };</span>
<span class="line-modified">1337         }</span>
<span class="line-modified">1338         PARSE(expression, Expression);</span>
<span class="line-modified">1339         CONSUME_TYPE(finalSemicolon, Semicolon);</span>
<span class="line-modified">1340         auto returnObject = AST::Return(WTFMove(returnToken), (*expression).moveToUniquePtr());</span>
<span class="line-modified">1341         return { makeUniqueRef&lt;AST::Return&gt;(WTFMove(returnObject)) };</span>
<span class="line-modified">1342     }</span>
<span class="line-modified">1343     case Token::Type::Constant:</span>
<span class="line-modified">1344     case Token::Type::Device:</span>
<span class="line-modified">1345     case Token::Type::Threadgroup:</span>
<span class="line-modified">1346     case Token::Type::Thread: {</span>
<span class="line-modified">1347         PARSE(variableDeclarations, VariableDeclarations);</span>
<span class="line-modified">1348         CONSUME_TYPE(semicolon, Semicolon);</span>
<span class="line-modified">1349         return { makeUniqueRef&lt;AST::VariableDeclarationsStatement&gt;(WTFMove(*variableDeclarations)) };</span>
<span class="line-modified">1350     }</span>
<span class="line-modified">1351     case Token::Type::Identifier: {</span>
<span class="line-modified">1352         PEEK_FURTHER(nextToken);</span>
<span class="line-modified">1353         switch (nextToken-&gt;type) {</span>
<span class="line-modified">1354         case Token::Type::Identifier:</span>
<span class="line-modified">1355         case Token::Type::LessThanSign:</span>
<span class="line-modified">1356         case Token::Type::Star:</span>
<span class="line-modified">1357         case Token::Type::Qualifier: {</span>
<span class="line-modified">1358             PARSE(variableDeclarations, VariableDeclarations);</span>
<span class="line-modified">1359             CONSUME_TYPE(semicolon, Semicolon);</span>
<span class="line-modified">1360             return { makeUniqueRef&lt;AST::VariableDeclarationsStatement&gt;(WTFMove(*variableDeclarations)) };</span>
<span class="line-modified">1361         }</span>
<span class="line-modified">1362         default:</span>
<span class="line-modified">1363             break;</span>
<span class="line-modified">1364         }</span>
<span class="line-modified">1365         break;</span>








































1366     }
<a name="231" id="anc231"></a><span class="line-modified">1367     default:</span>
<span class="line-modified">1368         break;</span>




















1369     }
1370 
1371     {
<a name="232" id="anc232"></a><span class="line-modified">1372         auto effectfulExpression = backtrackingScope&lt;Expected&lt;UniqueRef&lt;AST::Statement&gt;, Error&gt;&gt;([&amp;]() -&gt; Expected&lt;UniqueRef&lt;AST::Statement&gt;, Error&gt; {</span>
<span class="line-modified">1373             PARSE(result, EffectfulExpression);</span>
<span class="line-modified">1374             CONSUME_TYPE(semicolon, Semicolon);</span>






1375             return result;
1376         });
<a name="233" id="anc233"></a><span class="line-modified">1377         if (effectfulExpression)</span>
<span class="line-modified">1378             return WTFMove(*effectfulExpression);</span>
1379     }
1380 
<a name="234" id="anc234"></a><span class="line-modified">1381     PARSE(variableDeclarations, VariableDeclarations);</span>
<span class="line-modified">1382     CONSUME_TYPE(semicolon, Semicolon);</span>
<span class="line-modified">1383     return { makeUniqueRef&lt;AST::VariableDeclarationsStatement&gt;(WTFMove(*variableDeclarations)) };</span>












1384 }
1385 
<a name="235" id="anc235"></a><span class="line-modified">1386 auto Parser::parseEffectfulExpression() -&gt; Expected&lt;UniqueRef&lt;AST::Statement&gt;, Error&gt;</span>
1387 {
<a name="236" id="anc236"></a><span class="line-modified">1388     PEEK(origin);</span>
<span class="line-modified">1389     if (origin-&gt;type == Token::Type::Semicolon)</span>
<span class="line-modified">1390         return { makeUniqueRef&lt;AST::Block&gt;(*origin, Vector&lt;UniqueRef&lt;AST::Statement&gt;&gt;()) };</span>
1391 
1392     Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; expressions;
<a name="237" id="anc237"></a><span class="line-added">1393     PARSE(effectfulExpression, EffectfulAssignment);</span>
<span class="line-added">1394     expressions.append(WTFMove(*effectfulExpression));</span>
1395 
<a name="238" id="anc238"></a><span class="line-modified">1396     while (tryType(Token::Type::Comma)) {</span>
<span class="line-modified">1397         PARSE(expression, EffectfulAssignment);</span>













1398         expressions.append(WTFMove(*expression));
1399     }
1400 
1401     if (expressions.size() == 1)
<a name="239" id="anc239"></a><span class="line-modified">1402         return { makeUniqueRef&lt;AST::EffectfulExpressionStatement&gt;(WTFMove(expressions[0])) };</span>
<span class="line-modified">1403     unsigned endOffset = m_lexer.peek().startOffset();</span>
<span class="line-added">1404     CodeLocation location(origin-&gt;startOffset(), endOffset, m_lexer.nameSpace());</span>
<span class="line-added">1405     auto commaExpression = makeUniqueRef&lt;AST::CommaExpression&gt;(location, WTFMove(expressions));</span>
<span class="line-added">1406     return { makeUniqueRef&lt;AST::EffectfulExpressionStatement&gt;(WTFMove(commaExpression)) };</span>
1407 }
1408 
1409 auto Parser::parseEffectfulAssignment() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
1410 {
<a name="240" id="anc240"></a><span class="line-modified">1411     PEEK(origin);</span>




1412 
<a name="241" id="anc241"></a><span class="line-modified">1413     bool isEffectful = false;</span>
<span class="line-modified">1414     PARSE(expression, PossiblePrefix, &amp;isEffectful);</span>









1415 
<a name="242" id="anc242"></a><span class="line-modified">1416     if (!isEffectful || peekTypes&lt;</span>
<span class="line-modified">1417         Token::Type::EqualsSign,</span>
<span class="line-modified">1418         Token::Type::PlusEquals,</span>
<span class="line-modified">1419         Token::Type::MinusEquals,</span>
<span class="line-modified">1420         Token::Type::TimesEquals,</span>
<span class="line-modified">1421         Token::Type::DivideEquals,</span>
<span class="line-modified">1422         Token::Type::ModEquals,</span>
<span class="line-modified">1423         Token::Type::XorEquals,</span>
<span class="line-modified">1424         Token::Type::AndEquals,</span>
<span class="line-modified">1425         Token::Type::OrEquals,</span>
<span class="line-modified">1426         Token::Type::RightShiftEquals,</span>
<span class="line-modified">1427         Token::Type::LeftShiftEquals</span>
<span class="line-modified">1428     &gt;()) {</span>
<span class="line-modified">1429         return completeAssignment(WTFMove(*expression));</span>







1430     }
<a name="243" id="anc243"></a>










1431 
<a name="244" id="anc244"></a><span class="line-modified">1432     return expression;</span>


























































1433 }
1434 
1435 auto Parser::parseLimitedSuffixOperator(UniqueRef&lt;AST::Expression&gt;&amp;&amp; previous) -&gt; SuffixExpression
1436 {
<a name="245" id="anc245"></a><span class="line-modified">1437     auto type = consumeTypes&lt;</span>
<span class="line-added">1438         Token::Type::FullStop,</span>
<span class="line-added">1439         Token::Type::Arrow,</span>
<span class="line-added">1440         Token::Type::LeftSquareBracket&gt;();</span>
1441     if (!type)
1442         return SuffixExpression(WTFMove(previous), false);
1443 
1444     switch (type-&gt;type) {
<a name="246" id="anc246"></a><span class="line-modified">1445     case Token::Type::FullStop: {</span>
<span class="line-modified">1446         auto identifier = consumeType(Token::Type::Identifier);</span>
1447         if (!identifier)
1448             return SuffixExpression(WTFMove(previous), false);
<a name="247" id="anc247"></a><span class="line-modified">1449         CodeLocation location(previous-&gt;codeLocation(), *identifier);</span>
<span class="line-added">1450         return SuffixExpression(makeUniqueRef&lt;AST::DotExpression&gt;(location, WTFMove(previous), identifier-&gt;stringView(m_lexer).toString()), true);</span>
1451     }
<a name="248" id="anc248"></a><span class="line-modified">1452     case Token::Type::Arrow: {</span>
<span class="line-modified">1453         auto identifier = consumeType(Token::Type::Identifier);</span>
1454         if (!identifier)
1455             return SuffixExpression(WTFMove(previous), false);
<a name="249" id="anc249"></a><span class="line-modified">1456         CodeLocation location(previous-&gt;codeLocation(), *identifier);</span>
<span class="line-added">1457         return SuffixExpression(makeUniqueRef&lt;AST::DotExpression&gt;(location, makeUniqueRef&lt;AST::DereferenceExpression&gt;(location, WTFMove(previous)), identifier-&gt;stringView(m_lexer).toString()), true);</span>
1458     }
1459     default: {
<a name="250" id="anc250"></a><span class="line-modified">1460         ASSERT(type-&gt;type == Token::Type::LeftSquareBracket);</span>
1461         auto expression = parseExpression();
1462         if (!expression)
1463             return SuffixExpression(WTFMove(previous), false);
<a name="251" id="anc251"></a><span class="line-modified">1464         if (auto rightSquareBracket = consumeType(Token::Type::RightSquareBracket)) {</span>
<span class="line-modified">1465             CodeLocation location(previous-&gt;codeLocation(), *rightSquareBracket);</span>
<span class="line-modified">1466             return SuffixExpression(makeUniqueRef&lt;AST::IndexExpression&gt;(location, WTFMove(previous), WTFMove(*expression)), true);</span>
<span class="line-added">1467         }</span>
<span class="line-added">1468         return SuffixExpression(WTFMove(previous), false);</span>
1469     }
1470     }
1471 }
1472 
1473 auto Parser::parseSuffixOperator(UniqueRef&lt;AST::Expression&gt;&amp;&amp; previous) -&gt; SuffixExpression
1474 {
<a name="252" id="anc252"></a><span class="line-modified">1475     auto suffix = consumeTypes&lt;</span>
<span class="line-added">1476         Token::Type::FullStop,</span>
<span class="line-added">1477         Token::Type::Arrow,</span>
<span class="line-added">1478         Token::Type::LeftSquareBracket,</span>
<span class="line-added">1479         Token::Type::PlusPlus,</span>
<span class="line-added">1480         Token::Type::MinusMinus&gt;();</span>
1481     if (!suffix)
1482         return SuffixExpression(WTFMove(previous), false);
1483 
1484     switch (suffix-&gt;type) {
<a name="253" id="anc253"></a><span class="line-modified">1485     case Token::Type::FullStop: {</span>
<span class="line-modified">1486         auto identifier = consumeType(Token::Type::Identifier);</span>
1487         if (!identifier)
1488             return SuffixExpression(WTFMove(previous), false);
<a name="254" id="anc254"></a><span class="line-modified">1489         CodeLocation location(previous-&gt;codeLocation(), *identifier);</span>
<span class="line-added">1490         return SuffixExpression(makeUniqueRef&lt;AST::DotExpression&gt;(location, WTFMove(previous), identifier-&gt;stringView(m_lexer).toString()), true);</span>
1491     }
<a name="255" id="anc255"></a><span class="line-modified">1492     case Token::Type::Arrow: {</span>
<span class="line-modified">1493         auto identifier = consumeType(Token::Type::Identifier);</span>
1494         if (!identifier)
1495             return SuffixExpression(WTFMove(previous), false);
<a name="256" id="anc256"></a><span class="line-modified">1496         CodeLocation location(previous-&gt;codeLocation(), *identifier);</span>
<span class="line-added">1497         return SuffixExpression(makeUniqueRef&lt;AST::DotExpression&gt;(location, makeUniqueRef&lt;AST::DereferenceExpression&gt;(WTFMove(*suffix), WTFMove(previous)), identifier-&gt;stringView(m_lexer).toString()), true);</span>
1498     }
<a name="257" id="anc257"></a><span class="line-modified">1499     case Token::Type::LeftSquareBracket: {</span>
1500         auto expression = parseExpression();
1501         if (!expression)
1502             return SuffixExpression(WTFMove(previous), false);
<a name="258" id="anc258"></a><span class="line-modified">1503         if (auto rightSquareBracket = consumeType(Token::Type::RightSquareBracket)) {</span>
<span class="line-modified">1504             CodeLocation location(previous-&gt;codeLocation(), *rightSquareBracket);</span>
<span class="line-modified">1505             return SuffixExpression(makeUniqueRef&lt;AST::IndexExpression&gt;(location, WTFMove(previous), WTFMove(*expression)), true);</span>
<span class="line-added">1506         }</span>
<span class="line-added">1507         return SuffixExpression(WTFMove(previous), false);</span>
1508     }
<a name="259" id="anc259"></a><span class="line-modified">1509     case Token::Type::PlusPlus: {</span>
<span class="line-modified">1510         CodeLocation location(previous-&gt;codeLocation(), *suffix);</span>
<span class="line-added">1511         auto result = makeUniqueRef&lt;AST::ReadModifyWriteExpression&gt;(location, WTFMove(previous));</span>
1512         Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
1513         callArguments.append(result-&gt;oldVariableReference());
<a name="260" id="anc260"></a><span class="line-modified">1514         result-&gt;setNewValueExpression(makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator++&quot;_str, WTFMove(callArguments)));</span>
1515         result-&gt;setResultExpression(result-&gt;oldVariableReference());
1516         return SuffixExpression(WTFMove(result), true);
1517     }
1518     default: {
<a name="261" id="anc261"></a><span class="line-modified">1519         ASSERT(suffix-&gt;type == Token::Type::MinusMinus);</span>
<span class="line-modified">1520         CodeLocation location(previous-&gt;codeLocation(), *suffix);</span>
<span class="line-added">1521         auto result = makeUniqueRef&lt;AST::ReadModifyWriteExpression&gt;(location, WTFMove(previous));</span>
1522         Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
1523         callArguments.append(result-&gt;oldVariableReference());
<a name="262" id="anc262"></a><span class="line-modified">1524         result-&gt;setNewValueExpression(makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator--&quot;_str, WTFMove(callArguments)));</span>
1525         result-&gt;setResultExpression(result-&gt;oldVariableReference());
1526         return SuffixExpression(WTFMove(result), true);
1527     }
1528     }
1529 }
1530 
1531 auto Parser::parseExpression() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
1532 {
<a name="263" id="anc263"></a><span class="line-modified">1533     PARSE(first, PossibleTernaryConditional);</span>







1534     Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; expressions;
<a name="264" id="anc264"></a><span class="line-added">1535     unsigned startOffset = (*first)-&gt;codeLocation().startOffset();</span>
1536     expressions.append(WTFMove(*first));
1537 
<a name="265" id="anc265"></a><span class="line-modified">1538     while (tryType(Token::Type::Comma)) {</span>
<span class="line-modified">1539         PARSE(expression, PossibleTernaryConditional);</span>


1540         expressions.append(WTFMove(*expression));
1541     }
1542 
1543     if (expressions.size() == 1)
1544         return WTFMove(expressions[0]);
<a name="266" id="anc266"></a><span class="line-modified">1545     auto endOffset = m_lexer.peek().startOffset();</span>
<span class="line-added">1546     CodeLocation location(startOffset, endOffset, m_lexer.nameSpace());</span>
<span class="line-added">1547     return { makeUniqueRef&lt;AST::CommaExpression&gt;(location, WTFMove(expressions)) };</span>
1548 }
1549 
<a name="267" id="anc267"></a><span class="line-modified">1550 auto Parser::completeTernaryConditional(UniqueRef&lt;AST::Expression&gt;&amp;&amp; predicate) -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;</span>
1551 {
<a name="268" id="anc268"></a><span class="line-modified">1552     CONSUME_TYPE(questionMark, QuestionMark);</span>
<span class="line-modified">1553     PARSE(bodyExpression, Expression);</span>
<span class="line-modified">1554     CONSUME_TYPE(colon, Colon);</span>
<span class="line-modified">1555     PARSE(elseExpression, PossibleTernaryConditional);</span>



















1556 
<a name="269" id="anc269"></a><span class="line-added">1557     CodeLocation predicateLocation = predicate-&gt;codeLocation();</span>
1558     Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; castArguments;
<a name="270" id="anc270"></a><span class="line-modified">1559     castArguments.append(WTFMove(predicate));</span>
<span class="line-modified">1560     auto boolCast = makeUniqueRef&lt;AST::CallExpression&gt;(predicateLocation, &quot;bool&quot;_str, WTFMove(castArguments));</span>
<span class="line-modified">1561     CodeLocation location(predicateLocation, (*elseExpression)-&gt;codeLocation());</span>
<span class="line-modified">1562     return { makeUniqueRef&lt;AST::TernaryExpression&gt;(location, WTFMove(boolCast), WTFMove(*bodyExpression), WTFMove(*elseExpression)) };</span>
<span class="line-modified">1563 }</span>
<span class="line-modified">1564 </span>
<span class="line-modified">1565 auto Parser::completeAssignment(UniqueRef&lt;AST::Expression&gt;&amp;&amp; left) -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;</span>
<span class="line-modified">1566 {</span>
<span class="line-modified">1567     auto assignmentOperator = consumeTypes&lt;</span>
<span class="line-modified">1568         Token::Type::EqualsSign,</span>
<span class="line-modified">1569         Token::Type::PlusEquals,</span>
<span class="line-modified">1570         Token::Type::MinusEquals,</span>
<span class="line-modified">1571         Token::Type::TimesEquals,</span>
<span class="line-modified">1572         Token::Type::DivideEquals,</span>
<span class="line-modified">1573         Token::Type::ModEquals,</span>
<span class="line-modified">1574         Token::Type::XorEquals,</span>
<span class="line-modified">1575         Token::Type::AndEquals,</span>
<span class="line-modified">1576         Token::Type::OrEquals,</span>
<span class="line-modified">1577         Token::Type::RightShiftEquals,</span>
<span class="line-modified">1578         Token::Type::LeftShiftEquals&gt;();</span>








1579     if (!assignmentOperator)
<a name="271" id="anc271"></a><span class="line-modified">1580         return makeUnexpected(assignmentOperator.error());</span>
1581 
<a name="272" id="anc272"></a><span class="line-modified">1582     PARSE(right, PossibleTernaryConditional);</span>
<span class="line-modified">1583     CodeLocation location = { left-&gt;codeLocation(), (*right)-&gt;codeLocation() };</span>

1584 
<a name="273" id="anc273"></a><span class="line-modified">1585     if (assignmentOperator-&gt;type == Token::Type::EqualsSign)</span>
<span class="line-modified">1586         return { makeUniqueRef&lt;AST::AssignmentExpression&gt;(location, WTFMove(left), WTFMove(*right))};</span>
1587 
1588     String name;
1589     switch (assignmentOperator-&gt;type) {
<a name="274" id="anc274"></a><span class="line-modified">1590     case Token::Type::PlusEquals:</span>
1591         name = &quot;operator+&quot;_str;
1592         break;
<a name="275" id="anc275"></a><span class="line-modified">1593     case Token::Type::MinusEquals:</span>
1594         name = &quot;operator-&quot;_str;
1595         break;
<a name="276" id="anc276"></a><span class="line-modified">1596     case Token::Type::TimesEquals:</span>
1597         name = &quot;operator*&quot;_str;
1598         break;
<a name="277" id="anc277"></a><span class="line-modified">1599     case Token::Type::DivideEquals:</span>
1600         name = &quot;operator/&quot;_str;
1601         break;
<a name="278" id="anc278"></a><span class="line-modified">1602     case Token::Type::ModEquals:</span>
1603         name = &quot;operator%&quot;_str;
1604         break;
<a name="279" id="anc279"></a><span class="line-modified">1605     case Token::Type::XorEquals:</span>
1606         name = &quot;operator^&quot;_str;
1607         break;
<a name="280" id="anc280"></a><span class="line-modified">1608     case Token::Type::AndEquals:</span>
1609         name = &quot;operator&amp;&quot;_str;
1610         break;
<a name="281" id="anc281"></a><span class="line-modified">1611     case Token::Type::OrEquals:</span>
1612         name = &quot;operator|&quot;_str;
1613         break;
<a name="282" id="anc282"></a><span class="line-modified">1614     case Token::Type::RightShiftEquals:</span>
1615         name = &quot;operator&gt;&gt;&quot;_str;
1616         break;
1617     default:
<a name="283" id="anc283"></a><span class="line-modified">1618         ASSERT(assignmentOperator-&gt;type == Token::Type::LeftShiftEquals);</span>
1619         name = &quot;operator&lt;&lt;&quot;_str;
1620         break;
1621     }
1622 
<a name="284" id="anc284"></a><span class="line-modified">1623     auto result = makeUniqueRef&lt;AST::ReadModifyWriteExpression&gt;(location, WTFMove(left));</span>
1624     Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
1625     callArguments.append(result-&gt;oldVariableReference());
1626     callArguments.append(WTFMove(*right));
<a name="285" id="anc285"></a><span class="line-modified">1627     result-&gt;setNewValueExpression(makeUniqueRef&lt;AST::CallExpression&gt;(location, WTFMove(name), WTFMove(callArguments)));</span>
1628     result-&gt;setResultExpression(result-&gt;newVariableReference());
1629     return { WTFMove(result) };
1630 }
1631 
1632 auto Parser::parsePossibleTernaryConditional() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
1633 {
<a name="286" id="anc286"></a><span class="line-modified">1634     PARSE(expression, PossiblePrefix);</span>




1635 
<a name="287" id="anc287"></a><span class="line-modified">1636     if (peekTypes&lt;Token::Type::EqualsSign,</span>
<span class="line-modified">1637         Token::Type::PlusEquals,</span>
<span class="line-modified">1638         Token::Type::MinusEquals,</span>
<span class="line-modified">1639         Token::Type::TimesEquals,</span>
<span class="line-modified">1640         Token::Type::DivideEquals,</span>
<span class="line-added">1641         Token::Type::ModEquals,</span>
<span class="line-added">1642         Token::Type::XorEquals,</span>
<span class="line-added">1643         Token::Type::AndEquals,</span>
<span class="line-added">1644         Token::Type::OrEquals,</span>
<span class="line-added">1645         Token::Type::RightShiftEquals,</span>
<span class="line-added">1646         Token::Type::LeftShiftEquals&gt;()) {</span>
<span class="line-added">1647         return completeAssignment(WTFMove(*expression));</span>
<span class="line-added">1648     }</span>
1649 
<a name="288" id="anc288"></a><span class="line-modified">1650     expression = completePossibleShift(WTFMove(*expression));</span>
<span class="line-modified">1651     if (!expression)</span>
<span class="line-modified">1652         return makeUnexpected(expression.error());</span>
<span class="line-modified">1653 </span>
<span class="line-modified">1654     expression = completePossibleMultiply(WTFMove(*expression));</span>
<span class="line-added">1655     if (!expression)</span>
<span class="line-added">1656         return makeUnexpected(expression.error());</span>
<span class="line-added">1657 </span>
<span class="line-added">1658     expression = completePossibleAdd(WTFMove(*expression));</span>
<span class="line-added">1659     if (!expression)</span>
<span class="line-added">1660         return makeUnexpected(expression.error());</span>
<span class="line-added">1661 </span>
<span class="line-added">1662     expression = completePossibleRelationalBinaryOperation(WTFMove(*expression));</span>
<span class="line-added">1663     if (!expression)</span>
<span class="line-added">1664         return makeUnexpected(expression.error());</span>
1665 
<a name="289" id="anc289"></a><span class="line-modified">1666     expression = completePossibleLogicalBinaryOperation(WTFMove(*expression));</span>
<span class="line-added">1667     if (!expression)</span>
<span class="line-added">1668         return makeUnexpected(expression.error());</span>
<span class="line-added">1669 </span>
<span class="line-added">1670     PEEK(nextToken);</span>
<span class="line-added">1671     if (nextToken-&gt;type == Token::Type::QuestionMark)</span>
<span class="line-added">1672         return completeTernaryConditional(WTFMove(*expression));</span>
<span class="line-added">1673     return expression;</span>
1674 }
1675 
1676 auto Parser::parsePossibleLogicalBinaryOperation() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
1677 {
<a name="290" id="anc290"></a><span class="line-modified">1678     PARSE(parsedPrevious, PossibleRelationalBinaryOperation);</span>
<span class="line-modified">1679     return completePossibleLogicalBinaryOperation(WTFMove(*parsedPrevious));</span>
<span class="line-modified">1680 }</span>
<span class="line-modified">1681 </span>
<span class="line-modified">1682 auto Parser::completePossibleLogicalBinaryOperation(UniqueRef&lt;AST::Expression&gt;&amp;&amp; previous) -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;</span>
<span class="line-modified">1683 {</span>
<span class="line-modified">1684     while (auto logicalBinaryOperation = tryTypes&lt;</span>
<span class="line-modified">1685         Token::Type::OrOr,</span>
<span class="line-modified">1686         Token::Type::AndAnd,</span>
<span class="line-modified">1687         Token::Type::Or,</span>
<span class="line-modified">1688         Token::Type::Xor,</span>
<span class="line-modified">1689         Token::Type::And</span>
<span class="line-modified">1690         &gt;()) {</span>
<span class="line-modified">1691         PARSE(next, PossibleRelationalBinaryOperation);</span>
<span class="line-modified">1692         CodeLocation location(previous-&gt;codeLocation(), (*next)-&gt;codeLocation());</span>
1693 
1694         switch (logicalBinaryOperation-&gt;type) {
<a name="291" id="anc291"></a><span class="line-modified">1695         case Token::Type::OrOr:</span>
<span class="line-modified">1696             previous = makeUniqueRef&lt;AST::LogicalExpression&gt;(location, AST::LogicalExpression::Type::Or, WTFMove(previous), WTFMove(*next));</span>
1697             break;
<a name="292" id="anc292"></a><span class="line-modified">1698         case Token::Type::AndAnd:</span>
<span class="line-modified">1699             previous = makeUniqueRef&lt;AST::LogicalExpression&gt;(location, AST::LogicalExpression::Type::And, WTFMove(previous), WTFMove(*next));</span>
1700             break;
<a name="293" id="anc293"></a><span class="line-modified">1701         case Token::Type::Or: {</span>
1702             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
1703             callArguments.append(WTFMove(previous));
1704             callArguments.append(WTFMove(*next));
<a name="294" id="anc294"></a><span class="line-modified">1705             previous = makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator|&quot;_str, WTFMove(callArguments));</span>
1706             break;
1707         }
<a name="295" id="anc295"></a><span class="line-modified">1708         case Token::Type::Xor: {</span>
1709             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
1710             callArguments.append(WTFMove(previous));
1711             callArguments.append(WTFMove(*next));
<a name="296" id="anc296"></a><span class="line-modified">1712             previous = makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator^&quot;_str, WTFMove(callArguments));</span>
1713             break;
1714         }
1715         default: {
<a name="297" id="anc297"></a><span class="line-modified">1716             ASSERT(logicalBinaryOperation-&gt;type == Token::Type::And);</span>
1717             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
1718             callArguments.append(WTFMove(previous));
1719             callArguments.append(WTFMove(*next));
<a name="298" id="anc298"></a><span class="line-modified">1720             previous = makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator&amp;&quot;_str, WTFMove(callArguments));</span>
1721             break;
1722         }
1723         }
1724     }
1725 
1726     return { WTFMove(previous) };
1727 }
1728 
1729 auto Parser::parsePossibleRelationalBinaryOperation() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
1730 {
<a name="299" id="anc299"></a><span class="line-modified">1731     PARSE(parsedPrevious, PossibleShift);</span>
<span class="line-modified">1732     return completePossibleRelationalBinaryOperation(WTFMove(*parsedPrevious));</span>
<span class="line-modified">1733 }</span>
<span class="line-modified">1734 </span>
<span class="line-modified">1735 auto Parser::completePossibleRelationalBinaryOperation(UniqueRef&lt;AST::Expression&gt;&amp;&amp; previous) -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;</span>
<span class="line-modified">1736 {</span>
<span class="line-modified">1737     while (auto relationalBinaryOperation = tryTypes&lt;</span>
<span class="line-modified">1738         Token::Type::LessThanSign,</span>
<span class="line-modified">1739         Token::Type::GreaterThanSign,</span>
<span class="line-modified">1740         Token::Type::LessThanOrEqualTo,</span>
<span class="line-modified">1741         Token::Type::GreaterThanOrEqualTo,</span>
<span class="line-modified">1742         Token::Type::EqualComparison,</span>
<span class="line-modified">1743         Token::Type::NotEqual</span>
<span class="line-modified">1744         &gt;()) {</span>
<span class="line-modified">1745         PARSE(next, PossibleShift);</span>
<span class="line-modified">1746         CodeLocation location(previous-&gt;codeLocation(), (*next)-&gt;codeLocation());</span>
<span class="line-added">1747 </span>
<span class="line-added">1748         Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;</span>
<span class="line-added">1749         callArguments.append(WTFMove(previous));</span>
<span class="line-added">1750         callArguments.append(WTFMove(*next));</span>
1751 
1752         switch (relationalBinaryOperation-&gt;type) {
<a name="300" id="anc300"></a><span class="line-modified">1753         case Token::Type::LessThanSign: {</span>
<span class="line-modified">1754             previous = makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator&lt;&quot;_str, WTFMove(callArguments));</span>



1755             break;
1756         }
<a name="301" id="anc301"></a><span class="line-modified">1757         case Token::Type::GreaterThanSign: {</span>
<span class="line-modified">1758             previous = makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator&gt;&quot;_str, WTFMove(callArguments));</span>



1759             break;
1760         }
<a name="302" id="anc302"></a><span class="line-modified">1761         case Token::Type::LessThanOrEqualTo: {</span>
<span class="line-modified">1762             previous = makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator&lt;=&quot;_str, WTFMove(callArguments));</span>



1763             break;
1764         }
<a name="303" id="anc303"></a><span class="line-modified">1765         case Token::Type::GreaterThanOrEqualTo: {</span>
<span class="line-modified">1766             previous = makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator&gt;=&quot;_str, WTFMove(callArguments));</span>



1767             break;
1768         }
<a name="304" id="anc304"></a><span class="line-modified">1769         case Token::Type::EqualComparison: {</span>
<span class="line-modified">1770             previous = makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator==&quot;_str, WTFMove(callArguments));</span>



1771             break;
1772         }
1773         default: {
<a name="305" id="anc305"></a><span class="line-modified">1774             ASSERT(relationalBinaryOperation-&gt;type == Token::Type::NotEqual);</span>
<span class="line-modified">1775             previous = makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator==&quot;_str, WTFMove(callArguments));</span>
<span class="line-modified">1776             previous = makeUniqueRef&lt;AST::LogicalNotExpression&gt;(location, WTFMove(previous));</span>



1777             break;
1778         }
1779         }
1780     }
1781 
1782     return WTFMove(previous);
1783 }
1784 
1785 auto Parser::parsePossibleShift() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
1786 {
<a name="306" id="anc306"></a><span class="line-modified">1787     PARSE(parsedPrevious, PossibleAdd);</span>
<span class="line-modified">1788     return completePossibleShift(WTFMove(*parsedPrevious));</span>
<span class="line-modified">1789 }</span>
<span class="line-modified">1790 </span>
<span class="line-added">1791 auto Parser::completePossibleShift(UniqueRef&lt;AST::Expression&gt;&amp;&amp; previous) -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;</span>
<span class="line-added">1792 {</span>
<span class="line-added">1793     while (auto shift = tryTypes&lt;</span>
<span class="line-added">1794         Token::Type::LeftShift,</span>
<span class="line-added">1795         Token::Type::RightShift</span>
<span class="line-added">1796         &gt;()) {</span>
<span class="line-added">1797         PARSE(next, PossibleAdd);</span>
<span class="line-added">1798         CodeLocation location(previous-&gt;codeLocation(), (*next)-&gt;codeLocation());</span>
1799 
<a name="307" id="anc307"></a><span class="line-modified">1800         Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;</span>
<span class="line-modified">1801         callArguments.append(WTFMove(previous));</span>
<span class="line-modified">1802         callArguments.append(WTFMove(*next));</span>




1803 
1804         switch (shift-&gt;type) {
<a name="308" id="anc308"></a><span class="line-modified">1805         case Token::Type::LeftShift: {</span>
<span class="line-modified">1806             previous = makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator&lt;&lt;&quot;_str, WTFMove(callArguments));</span>



1807             break;
1808         }
1809         default: {
<a name="309" id="anc309"></a><span class="line-modified">1810             ASSERT(shift-&gt;type == Token::Type::RightShift);</span>
<span class="line-modified">1811             previous = makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator&gt;&gt;&quot;_str, WTFMove(callArguments));</span>



1812             break;
1813         }
1814         }
1815     }
1816 
1817     return WTFMove(previous);
1818 }
1819 
1820 auto Parser::parsePossibleAdd() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
1821 {
<a name="310" id="anc310"></a><span class="line-modified">1822     PARSE(parsedPrevious, PossibleMultiply);</span>
<span class="line-modified">1823     return completePossibleAdd(WTFMove(*parsedPrevious));</span>
<span class="line-modified">1824 }</span>

1825 
<a name="311" id="anc311"></a><span class="line-modified">1826 auto Parser::completePossibleAdd(UniqueRef&lt;AST::Expression&gt;&amp;&amp; previous) -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;</span>
<span class="line-modified">1827 {</span>
<span class="line-modified">1828     while (auto add = tryTypes&lt;</span>
<span class="line-modified">1829         Token::Type::Plus,</span>
<span class="line-modified">1830         Token::Type::Minus</span>
<span class="line-modified">1831         &gt;()) {</span>
<span class="line-modified">1832         PARSE(next, PossibleMultiply);</span>
<span class="line-added">1833         CodeLocation location(previous-&gt;codeLocation(), (*next)-&gt;codeLocation());</span>
<span class="line-added">1834 </span>
<span class="line-added">1835         Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;</span>
<span class="line-added">1836         callArguments.append(WTFMove(previous));</span>
<span class="line-added">1837         callArguments.append(WTFMove(*next));</span>
1838 
1839         switch (add-&gt;type) {
<a name="312" id="anc312"></a><span class="line-modified">1840         case Token::Type::Plus: {</span>
<span class="line-modified">1841             previous = makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator+&quot;_str, WTFMove(callArguments));</span>



1842             break;
1843         }
1844         default: {
<a name="313" id="anc313"></a><span class="line-modified">1845             ASSERT(add-&gt;type == Token::Type::Minus);</span>
<span class="line-modified">1846             previous = makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator-&quot;_str, WTFMove(callArguments));</span>



1847             break;
1848         }
1849         }
1850     }
1851 
1852     return WTFMove(previous);
1853 }
1854 
1855 auto Parser::parsePossibleMultiply() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
1856 {
<a name="314" id="anc314"></a><span class="line-modified">1857     PARSE(parsedPrevious, PossiblePrefix);</span>
<span class="line-modified">1858     return completePossibleMultiply(WTFMove(*parsedPrevious));</span>
<span class="line-modified">1859 }</span>

1860 
<a name="315" id="anc315"></a><span class="line-modified">1861 auto Parser::completePossibleMultiply(UniqueRef&lt;AST::Expression&gt;&amp;&amp; previous) -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;</span>
<span class="line-modified">1862 {</span>
<span class="line-modified">1863     while (auto multiply = tryTypes&lt;</span>
<span class="line-modified">1864         Token::Type::Star,</span>
<span class="line-modified">1865         Token::Type::Divide,</span>
<span class="line-modified">1866         Token::Type::Mod</span>
<span class="line-modified">1867         &gt;()) {</span>
<span class="line-modified">1868         PARSE(next, PossiblePrefix);</span>
<span class="line-added">1869         CodeLocation location(previous-&gt;codeLocation(), (*next)-&gt;codeLocation());</span>
<span class="line-added">1870 </span>
<span class="line-added">1871         Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;</span>
<span class="line-added">1872         callArguments.append(WTFMove(previous));</span>
<span class="line-added">1873         callArguments.append(WTFMove(*next));</span>
1874 
1875         switch (multiply-&gt;type) {
<a name="316" id="anc316"></a><span class="line-modified">1876         case Token::Type::Star: {</span>
<span class="line-modified">1877             previous = makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator*&quot;_str, WTFMove(callArguments));</span>



1878             break;
1879         }
<a name="317" id="anc317"></a><span class="line-modified">1880         case Token::Type::Divide: {</span>
<span class="line-modified">1881             previous = makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator/&quot;_str, WTFMove(callArguments));</span>



1882             break;
1883         }
1884         default: {
<a name="318" id="anc318"></a><span class="line-modified">1885             ASSERT(multiply-&gt;type == Token::Type::Mod);</span>
<span class="line-modified">1886             previous = makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator%&quot;_str, WTFMove(callArguments));</span>



1887             break;
1888         }
1889         }
1890     }
1891 
1892     return WTFMove(previous);
1893 }
1894 
<a name="319" id="anc319"></a><span class="line-modified">1895 auto Parser::parsePossiblePrefix(bool *isEffectful) -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;</span>
1896 {
<a name="320" id="anc320"></a><span class="line-modified">1897     if (auto prefix = tryTypes&lt;</span>
<span class="line-modified">1898         Token::Type::PlusPlus,</span>
<span class="line-modified">1899         Token::Type::MinusMinus,</span>
<span class="line-modified">1900         Token::Type::Plus,</span>
<span class="line-modified">1901         Token::Type::Minus,</span>
<span class="line-modified">1902         Token::Type::Tilde,</span>
<span class="line-modified">1903         Token::Type::ExclamationPoint,</span>
<span class="line-modified">1904         Token::Type::And,</span>
<span class="line-modified">1905         Token::Type::At,</span>
<span class="line-modified">1906         Token::Type::Star</span>
<span class="line-modified">1907     &gt;()) {</span>
<span class="line-modified">1908         PARSE(next, PossiblePrefix);</span>
<span class="line-modified">1909         CodeLocation location(*prefix, (*next)-&gt;codeLocation());</span>

1910 
1911         switch (prefix-&gt;type) {
<a name="321" id="anc321"></a><span class="line-modified">1912         case Token::Type::PlusPlus: {</span>
<span class="line-modified">1913             if (isEffectful)</span>
<span class="line-added">1914                 *isEffectful = true;</span>
<span class="line-added">1915             auto result = makeUniqueRef&lt;AST::ReadModifyWriteExpression&gt;(location, WTFMove(*next));</span>
1916             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
1917             callArguments.append(result-&gt;oldVariableReference());
<a name="322" id="anc322"></a><span class="line-modified">1918             result-&gt;setNewValueExpression(makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator++&quot;_str, WTFMove(callArguments)));</span>
1919             result-&gt;setResultExpression(result-&gt;newVariableReference());
1920             return { WTFMove(result) };
1921         }
<a name="323" id="anc323"></a><span class="line-modified">1922         case Token::Type::MinusMinus: {</span>
<span class="line-modified">1923             if (isEffectful)</span>
<span class="line-added">1924                 *isEffectful = true;</span>
<span class="line-added">1925             auto result = makeUniqueRef&lt;AST::ReadModifyWriteExpression&gt;(location, WTFMove(*next));</span>
1926             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
1927             callArguments.append(result-&gt;oldVariableReference());
<a name="324" id="anc324"></a><span class="line-modified">1928             result-&gt;setNewValueExpression(makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator--&quot;_str, WTFMove(callArguments)));</span>
1929             result-&gt;setResultExpression(result-&gt;newVariableReference());
1930             return { WTFMove(result) };
1931         }
<a name="325" id="anc325"></a><span class="line-modified">1932         case Token::Type::Plus: {</span>
1933             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
1934             callArguments.append(WTFMove(*next));
<a name="326" id="anc326"></a><span class="line-modified">1935             return { makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator+&quot;_str, WTFMove(callArguments)) };</span>
1936         }
<a name="327" id="anc327"></a><span class="line-modified">1937         case Token::Type::Minus: {</span>
1938             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
1939             callArguments.append(WTFMove(*next));
<a name="328" id="anc328"></a><span class="line-modified">1940             return { makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator-&quot;_str, WTFMove(callArguments)) };</span>
1941         }
<a name="329" id="anc329"></a><span class="line-modified">1942         case Token::Type::Tilde: {</span>
1943             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
1944             callArguments.append(WTFMove(*next));
<a name="330" id="anc330"></a><span class="line-modified">1945             return { makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator~&quot;_str, WTFMove(callArguments)) };</span>
1946         }
<a name="331" id="anc331"></a><span class="line-modified">1947         case Token::Type::ExclamationPoint: {</span>
1948             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; castArguments;
1949             castArguments.append(WTFMove(*next));
<a name="332" id="anc332"></a><span class="line-modified">1950             auto boolCast = makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;bool&quot;_str, WTFMove(castArguments));</span>
<span class="line-modified">1951             return { makeUniqueRef&lt;AST::LogicalNotExpression&gt;(location, WTFMove(boolCast)) };</span>
1952         }
<a name="333" id="anc333"></a><span class="line-modified">1953         case Token::Type::And:</span>
<span class="line-modified">1954             return { makeUniqueRef&lt;AST::MakePointerExpression&gt;(location, WTFMove(*next), AST::AddressEscapeMode::Escapes) };</span>
<span class="line-modified">1955         case Token::Type::At:</span>
<span class="line-modified">1956             return { makeUniqueRef&lt;AST::MakeArrayReferenceExpression&gt;(location, WTFMove(*next), AST::AddressEscapeMode::Escapes) };</span>
1957         default:
<a name="334" id="anc334"></a><span class="line-modified">1958             ASSERT(prefix-&gt;type == Token::Type::Star);</span>
<span class="line-modified">1959             return { makeUniqueRef&lt;AST::DereferenceExpression&gt;(location, WTFMove(*next)) };</span>
1960         }
1961     }
1962 
<a name="335" id="anc335"></a><span class="line-modified">1963     return parsePossibleSuffix(isEffectful);</span>
1964 }
1965 
<a name="336" id="anc336"></a><span class="line-modified">1966 auto Parser::parsePossibleSuffix(bool *isEffectful) -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;</span>
1967 {
<a name="337" id="anc337"></a><span class="line-modified">1968     PEEK(token);</span>
<span class="line-modified">1969     PEEK_FURTHER(nextToken);</span>


1970 
<a name="338" id="anc338"></a><span class="line-added">1971     if (token-&gt;type == Token::Type::Identifier &amp;&amp; nextToken-&gt;type == Token::Type::LeftParenthesis) {</span>
<span class="line-added">1972         PARSE(expression, CallExpression);</span>
<span class="line-added">1973         if (isEffectful)</span>
<span class="line-added">1974             *isEffectful = true;</span>
1975         while (true) {
<a name="339" id="anc339"></a><span class="line-modified">1976             PEEK(suffixToken);</span>
<span class="line-modified">1977             if (suffixToken-&gt;type != Token::Type::FullStop &amp;&amp; suffixToken-&gt;type != Token::Type::Arrow &amp;&amp; suffixToken-&gt;type != Token::Type::LeftSquareBracket)</span>



1978                 break;
<a name="340" id="anc340"></a><span class="line-added">1979             auto result = parseLimitedSuffixOperator(WTFMove(*expression));</span>
<span class="line-added">1980             expression = WTFMove(result.result);</span>
1981         }
1982         return expression;
<a name="341" id="anc341"></a><span class="line-modified">1983     }</span>


1984 
<a name="342" id="anc342"></a><span class="line-modified">1985     if (token-&gt;type == Token::Type::LeftParenthesis &amp;&amp; isEffectful)</span>
<span class="line-modified">1986         *isEffectful = true;</span>


1987 
<a name="343" id="anc343"></a><span class="line-modified">1988     PARSE(expression, Term);</span>
<span class="line-modified">1989     bool isLastSuffixTokenEffectful = false;</span>
<span class="line-modified">1990     while (true) {</span>
<span class="line-modified">1991         PEEK(suffixToken);</span>
<span class="line-modified">1992         if (suffixToken-&gt;type != Token::Type::FullStop</span>
<span class="line-modified">1993             &amp;&amp; suffixToken-&gt;type != Token::Type::Arrow</span>
<span class="line-modified">1994             &amp;&amp; suffixToken-&gt;type != Token::Type::LeftSquareBracket</span>
<span class="line-added">1995             &amp;&amp; suffixToken-&gt;type != Token::Type::PlusPlus</span>
<span class="line-added">1996             &amp;&amp; suffixToken-&gt;type != Token::Type::MinusMinus) {</span>
<span class="line-added">1997             break;</span>
1998         }
<a name="344" id="anc344"></a><span class="line-modified">1999         isLastSuffixTokenEffectful = suffixToken-&gt;type == Token::Type::PlusPlus || suffixToken-&gt;type == Token::Type::MinusMinus;</span>
<span class="line-modified">2000         auto result = parseSuffixOperator(WTFMove(*expression));</span>
<span class="line-modified">2001         expression = WTFMove(result.result);</span>
<span class="line-modified">2002     }</span>
<span class="line-modified">2003     if (isLastSuffixTokenEffectful &amp;&amp; isEffectful)</span>
<span class="line-modified">2004         *isEffectful = true;</span>
<span class="line-added">2005     return expression;</span>
2006 }
2007 
2008 auto Parser::parseCallExpression() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
2009 {
<a name="345" id="anc345"></a><span class="line-modified">2010     CONSUME_TYPE(name, Identifier);</span>
<span class="line-modified">2011     auto callName = name-&gt;stringView(m_lexer).toString();</span>


2012 
<a name="346" id="anc346"></a><span class="line-modified">2013     CONSUME_TYPE(leftParenthesis, LeftParenthesis);</span>


2014 
2015     Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; arguments;
<a name="347" id="anc347"></a><span class="line-modified">2016     if (tryType(Token::Type::RightParenthesis))</span>
2017         return { makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*name), WTFMove(callName), WTFMove(arguments)) };
2018 
<a name="348" id="anc348"></a><span class="line-modified">2019     PARSE(firstArgument, PossibleTernaryConditional);</span>


2020     arguments.append(WTFMove(*firstArgument));
<a name="349" id="anc349"></a><span class="line-modified">2021     while (tryType(Token::Type::Comma)) {</span>
<span class="line-modified">2022         PARSE(argument, PossibleTernaryConditional);</span>


2023         arguments.append(WTFMove(*argument));
2024     }
2025 
<a name="350" id="anc350"></a><span class="line-modified">2026     CONSUME_TYPE(rightParenthesis, RightParenthesis);</span>
<span class="line-modified">2027     CodeLocation location(*name, *rightParenthesis);</span>

2028 
<a name="351" id="anc351"></a><span class="line-modified">2029     return { makeUniqueRef&lt;AST::CallExpression&gt;(location, WTFMove(callName), WTFMove(arguments)) };</span>
2030 }
2031 
2032 auto Parser::parseTerm() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
2033 {
<a name="352" id="anc352"></a><span class="line-modified">2034     auto type = consumeTypes&lt;</span>
<span class="line-modified">2035         Token::Type::IntLiteral,</span>
<span class="line-modified">2036         Token::Type::UintLiteral,</span>
<span class="line-modified">2037         Token::Type::FloatLiteral,</span>
<span class="line-modified">2038         Token::Type::Null,</span>
<span class="line-modified">2039         Token::Type::True,</span>
<span class="line-modified">2040         Token::Type::False,</span>
<span class="line-modified">2041         Token::Type::Identifier,</span>
<span class="line-modified">2042         Token::Type::LeftParenthesis&gt;();</span>

2043     if (!type)
<a name="353" id="anc353"></a><span class="line-modified">2044         return makeUnexpected(type.error());</span>
2045 
2046     switch (type-&gt;type) {
<a name="354" id="anc354"></a><span class="line-modified">2047     case Token::Type::IntLiteral: {</span>
<span class="line-modified">2048         auto value = intLiteralToInt(type-&gt;stringView(m_lexer));</span>
2049         if (!value)
<a name="355" id="anc355"></a><span class="line-modified">2050             return makeUnexpected(value.error());</span>
<span class="line-modified">2051         return { makeUniqueRef&lt;AST::IntegerLiteral&gt;(*type, *value) };</span>
2052     }
<a name="356" id="anc356"></a><span class="line-modified">2053     case Token::Type::UintLiteral: {</span>
<span class="line-modified">2054         auto value = uintLiteralToUint(type-&gt;stringView(m_lexer));</span>
2055         if (!value)
<a name="357" id="anc357"></a><span class="line-modified">2056             return makeUnexpected(value.error());</span>
<span class="line-modified">2057         return { makeUniqueRef&lt;AST::UnsignedIntegerLiteral&gt;(*type, *value) };</span>
2058     }
<a name="358" id="anc358"></a><span class="line-modified">2059     case Token::Type::FloatLiteral: {</span>
<span class="line-modified">2060         auto value = floatLiteralToFloat(type-&gt;stringView(m_lexer));</span>
2061         if (!value)
<a name="359" id="anc359"></a><span class="line-modified">2062             return makeUnexpected(value.error());</span>
<span class="line-modified">2063         return { makeUniqueRef&lt;AST::FloatLiteral&gt;(*type, *value) };</span>
<span class="line-modified">2064     }</span>
<span class="line-modified">2065     case Token::Type::Null:</span>
<span class="line-modified">2066         return { makeUniqueRef&lt;AST::NullLiteral&gt;(*type) };</span>
<span class="line-modified">2067     case Token::Type::True:</span>
<span class="line-modified">2068         return { makeUniqueRef&lt;AST::BooleanLiteral&gt;(*type, true) };</span>
<span class="line-modified">2069     case Token::Type::False:</span>
<span class="line-modified">2070         return { makeUniqueRef&lt;AST::BooleanLiteral&gt;(*type, false) };</span>
<span class="line-modified">2071     case Token::Type::Identifier: {</span>
<span class="line-modified">2072         auto name = type-&gt;stringView(m_lexer).toString();</span>
<span class="line-modified">2073         return { makeUniqueRef&lt;AST::VariableReference&gt;(*type, WTFMove(name)) };</span>
2074     }
2075     default: {
<a name="360" id="anc360"></a><span class="line-modified">2076         ASSERT(type-&gt;type == Token::Type::LeftParenthesis);</span>
<span class="line-modified">2077         PARSE(expression, Expression);</span>
<span class="line-modified">2078         CONSUME_TYPE(rightParenthesis, RightParenthesis);</span>





2079 
2080         return { WTFMove(*expression) };
2081     }
2082     }
2083 }
2084 
2085 } // namespace WHLSL
2086 
2087 } // namespace WebCore
2088 
2089 #endif // ENABLE(WEBGPU)
<a name="361" id="anc361"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="361" type="hidden" />
</body>
</html>