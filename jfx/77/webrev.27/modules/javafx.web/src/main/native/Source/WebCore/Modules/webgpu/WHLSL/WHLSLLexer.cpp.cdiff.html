<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/WHLSLLexer.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WHLSLIntrinsics.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="WHLSLLexer.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/WHLSLLexer.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 30,11 ***</span>
  
  namespace WebCore {
  
  namespace WHLSL {
  
<span class="line-modified">! const char* Lexer::Token::typeName(Type type)</span>
  {
      switch (type) {
      case Type::IntLiteral:
          return &quot;int literal&quot;;
      case Type::UintLiteral:
<span class="line-new-header">--- 30,11 ---</span>
  
  namespace WebCore {
  
  namespace WHLSL {
  
<span class="line-modified">! const char* Token::typeName(Type type)</span>
  {
      switch (type) {
      case Type::IntLiteral:
          return &quot;int literal&quot;;
      case Type::UintLiteral:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 71,12 ***</span>
          return &quot;while&quot;;
      case Type::Do:
          return &quot;do&quot;;
      case Type::Return:
          return &quot;return&quot;;
<span class="line-removed">-     case Type::Trap:</span>
<span class="line-removed">-         return &quot;trap&quot;;</span>
      case Type::Null:
          return &quot;null&quot;;
      case Type::True:
          return &quot;true&quot;;
      case Type::False:
<span class="line-new-header">--- 71,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 245,580 ***</span>
          return &quot;~&quot;;
      case Type::ExclamationPoint:
          return &quot;!&quot;;
      case Type::At:
          return &quot;@&quot;;
      }
  }
  
<span class="line-modified">! auto Lexer::recognizeKeyword(unsigned end) -&gt; Optional&lt;Token::Type&gt;</span>
  {
<span class="line-modified">!     auto substring = m_stringView.substring(m_offset, end - m_offset);</span>
<span class="line-modified">!     if (substring == &quot;struct&quot;)</span>
<span class="line-modified">!         return Token::Type::Struct;</span>
<span class="line-removed">-     if (substring == &quot;typedef&quot;)</span>
<span class="line-removed">-         return Token::Type::Typedef;</span>
<span class="line-removed">-     if (substring == &quot;enum&quot;)</span>
<span class="line-removed">-         return Token::Type::Enum;</span>
<span class="line-removed">-     if (substring == &quot;operator&quot;)</span>
<span class="line-removed">-         return Token::Type::Operator;</span>
<span class="line-removed">-     if (substring == &quot;if&quot;)</span>
<span class="line-removed">-         return Token::Type::If;</span>
<span class="line-removed">-     if (substring == &quot;else&quot;)</span>
<span class="line-removed">-         return Token::Type::Else;</span>
<span class="line-removed">-     if (substring == &quot;continue&quot;)</span>
<span class="line-removed">-         return Token::Type::Continue;</span>
<span class="line-removed">-     if (substring == &quot;break&quot;)</span>
<span class="line-removed">-         return Token::Type::Break;</span>
<span class="line-removed">-     if (substring == &quot;switch&quot;)</span>
<span class="line-removed">-         return Token::Type::Switch;</span>
<span class="line-removed">-     if (substring == &quot;case&quot;)</span>
<span class="line-removed">-         return Token::Type::Case;</span>
<span class="line-removed">-     if (substring == &quot;default&quot;)</span>
<span class="line-removed">-         return Token::Type::Default;</span>
<span class="line-removed">-     if (substring == &quot;fallthrough&quot;)</span>
<span class="line-removed">-         return Token::Type::Fallthrough;</span>
<span class="line-removed">-     if (substring == &quot;for&quot;)</span>
<span class="line-removed">-         return Token::Type::For;</span>
<span class="line-removed">-     if (substring == &quot;while&quot;)</span>
<span class="line-removed">-         return Token::Type::While;</span>
<span class="line-removed">-     if (substring == &quot;do&quot;)</span>
<span class="line-removed">-         return Token::Type::Do;</span>
<span class="line-removed">-     if (substring == &quot;return&quot;)</span>
<span class="line-removed">-         return Token::Type::Return;</span>
<span class="line-removed">-     if (substring == &quot;trap&quot;)</span>
<span class="line-removed">-         return Token::Type::Trap;</span>
<span class="line-removed">-     if (substring == &quot;null&quot;)</span>
<span class="line-removed">-         return Token::Type::Null;</span>
<span class="line-removed">-     if (substring == &quot;true&quot;)</span>
<span class="line-removed">-         return Token::Type::True;</span>
<span class="line-removed">-     if (substring == &quot;false&quot;)</span>
<span class="line-removed">-         return Token::Type::False;</span>
<span class="line-removed">-     if (substring == &quot;constant&quot;)</span>
<span class="line-removed">-         return Token::Type::Constant;</span>
<span class="line-removed">-     if (substring == &quot;device&quot;)</span>
<span class="line-removed">-         return Token::Type::Device;</span>
<span class="line-removed">-     if (substring == &quot;threadgroup&quot;)</span>
<span class="line-removed">-         return Token::Type::Threadgroup;</span>
<span class="line-removed">-     if (substring == &quot;thread&quot;)</span>
<span class="line-removed">-         return Token::Type::Thread;</span>
<span class="line-removed">-     if (substring == &quot;space&quot;)</span>
<span class="line-removed">-         return Token::Type::Space;</span>
<span class="line-removed">-     if (substring == &quot;vertex&quot;)</span>
<span class="line-removed">-         return Token::Type::Vertex;</span>
<span class="line-removed">-     if (substring == &quot;fragment&quot;)</span>
<span class="line-removed">-         return Token::Type::Fragment;</span>
<span class="line-removed">-     if (substring == &quot;compute&quot;)</span>
<span class="line-removed">-         return Token::Type::Compute;</span>
<span class="line-removed">-     if (substring == &quot;numthreads&quot;)</span>
<span class="line-removed">-         return Token::Type::NumThreads;</span>
<span class="line-removed">-     if (substring == &quot;SV_InstanceID&quot;)</span>
<span class="line-removed">-         return Token::Type::SVInstanceID;</span>
<span class="line-removed">-     if (substring == &quot;SV_VertexID&quot;)</span>
<span class="line-removed">-         return Token::Type::SVVertexID;</span>
<span class="line-removed">-     if (substring == &quot;PSIZE&quot;)</span>
<span class="line-removed">-         return Token::Type::PSize;</span>
<span class="line-removed">-     if (substring == &quot;SV_Position&quot;)</span>
<span class="line-removed">-         return Token::Type::SVPosition;</span>
<span class="line-removed">-     if (substring == &quot;SV_IsFrontFace&quot;)</span>
<span class="line-removed">-         return Token::Type::SVIsFrontFace;</span>
<span class="line-removed">-     if (substring == &quot;SV_SampleIndex&quot;)</span>
<span class="line-removed">-         return Token::Type::SVSampleIndex;</span>
<span class="line-removed">-     if (substring == &quot;SV_InnerCoverage&quot;)</span>
<span class="line-removed">-         return Token::Type::SVInnerCoverage;</span>
<span class="line-removed">-     if (substring == &quot;SV_Target&quot;)</span>
<span class="line-removed">-         return Token::Type::SVTarget;</span>
<span class="line-removed">-     if (substring == &quot;SV_Depth&quot;)</span>
<span class="line-removed">-         return Token::Type::SVDepth;</span>
<span class="line-removed">-     if (substring == &quot;SV_Coverage&quot;)</span>
<span class="line-removed">-         return Token::Type::SVCoverage;</span>
<span class="line-removed">-     if (substring == &quot;SV_DispatchThreadID&quot;)</span>
<span class="line-removed">-         return Token::Type::SVDispatchThreadID;</span>
<span class="line-removed">-     if (substring == &quot;SV_GroupID&quot;)</span>
<span class="line-removed">-         return Token::Type::SVGroupID;</span>
<span class="line-removed">-     if (substring == &quot;SV_GroupIndex&quot;)</span>
<span class="line-removed">-         return Token::Type::SVGroupIndex;</span>
<span class="line-removed">-     if (substring == &quot;SV_GroupThreadID&quot;)</span>
<span class="line-removed">-         return Token::Type::SVGroupThreadID;</span>
<span class="line-removed">-     if (substring == &quot;attribute&quot;)</span>
<span class="line-removed">-         return Token::Type::Attribute;</span>
<span class="line-removed">-     if (substring == &quot;register&quot;)</span>
<span class="line-removed">-         return Token::Type::Register;</span>
<span class="line-removed">-     if (substring == &quot;specialized&quot;)</span>
<span class="line-removed">-         return Token::Type::Specialized;</span>
<span class="line-removed">-     if (substring == &quot;native&quot;)</span>
<span class="line-removed">-         return Token::Type::Native;</span>
<span class="line-removed">-     if (substring == &quot;restricted&quot;)</span>
<span class="line-removed">-         return Token::Type::Restricted;</span>
<span class="line-removed">-     if (substring == &quot;_&quot;)</span>
<span class="line-removed">-         return Token::Type::Underscore;</span>
<span class="line-removed">-     if (substring == &quot;auto&quot;)</span>
<span class="line-removed">-         return Token::Type::Auto;</span>
<span class="line-removed">-     if (substring == &quot;protocol&quot;)</span>
<span class="line-removed">-         return Token::Type::Protocol;</span>
<span class="line-removed">-     if (substring == &quot;const&quot;)</span>
<span class="line-removed">-         return Token::Type::Const;</span>
<span class="line-removed">-     if (substring == &quot;static&quot;)</span>
<span class="line-removed">-         return Token::Type::Static;</span>
<span class="line-removed">-     if (substring == &quot;nointerpolation&quot;)</span>
<span class="line-removed">-         return Token::Type::Qualifier;</span>
<span class="line-removed">-     if (substring == &quot;noperspective&quot;)</span>
<span class="line-removed">-         return Token::Type::Qualifier;</span>
<span class="line-removed">-     if (substring == &quot;uniform&quot;)</span>
<span class="line-removed">-         return Token::Type::Qualifier;</span>
<span class="line-removed">-     if (substring == &quot;centroid&quot;)</span>
<span class="line-removed">-         return Token::Type::Qualifier;</span>
<span class="line-removed">-     if (substring == &quot;sample&quot;)</span>
<span class="line-removed">-         return Token::Type::Qualifier;</span>
<span class="line-removed">-     return WTF::nullopt;</span>
  }
  
<span class="line-modified">! auto Lexer::consumeTokenFromStream() -&gt; Optional&lt;Token&gt;</span>
  {
<span class="line-modified">!     auto prepare = [&amp;](unsigned newOffset, Token::Type type) -&gt; Optional&lt;Token&gt; {</span>
<span class="line-modified">!         auto oldOffset = m_offset;</span>
<span class="line-modified">!         m_offset = newOffset;</span>
<span class="line-modified">!         skipWhitespaceAndComments();</span>
<span class="line-removed">-         return {{ m_stringView.substring(oldOffset, newOffset - oldOffset), m_lineNumber, type }};</span>
<span class="line-removed">-     };</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (auto newOffset = floatLiteral(m_offset))</span>
<span class="line-removed">-         return prepare(*newOffset, Token::Type::FloatLiteral);</span>
<span class="line-removed">-     if (auto newOffset = uintLiteral(m_offset))</span>
<span class="line-removed">-         return prepare(*newOffset, Token::Type::UintLiteral);</span>
<span class="line-removed">-     if (auto newOffset = intLiteral(m_offset))</span>
<span class="line-removed">-         return prepare(*newOffset, Token::Type::IntLiteral);</span>
<span class="line-removed">-     if (auto newOffset = operatorName(m_offset))</span>
<span class="line-removed">-         return prepare(*newOffset, Token::Type::OperatorName);</span>
<span class="line-removed">-     if (auto newOffset = identifier(m_offset)) {</span>
<span class="line-removed">-         if (auto result = recognizeKeyword(*newOffset))</span>
<span class="line-removed">-             return prepare(*newOffset, *result);</span>
<span class="line-removed">-         return prepare(*newOffset, Token::Type::Identifier);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     // Sorted by length, so longer matches are preferable to shorter matches.</span>
<span class="line-removed">-     if (auto newOffset = string(&quot;&gt;&gt;=&quot;, m_offset))</span>
<span class="line-removed">-         return prepare(*newOffset, Token::Type::RightShiftEquals);</span>
<span class="line-removed">-     if (auto newOffset = string(&quot;&lt;&lt;=&quot;, m_offset))</span>
<span class="line-removed">-         return prepare(*newOffset, Token::Type::LeftShiftEquals);</span>
<span class="line-removed">-     if (auto newOffset = string(&quot;+=&quot;, m_offset))</span>
<span class="line-removed">-         return prepare(*newOffset, Token::Type::PlusEquals);</span>
<span class="line-removed">-     if (auto newOffset = string(&quot;-=&quot;, m_offset))</span>
<span class="line-removed">-         return prepare(*newOffset, Token::Type::MinusEquals);</span>
<span class="line-removed">-     if (auto newOffset = string(&quot;*=&quot;, m_offset))</span>
<span class="line-removed">-         return prepare(*newOffset, Token::Type::TimesEquals);</span>
<span class="line-removed">-     if (auto newOffset = string(&quot;/=&quot;, m_offset))</span>
<span class="line-removed">-         return prepare(*newOffset, Token::Type::DivideEquals);</span>
<span class="line-removed">-     if (auto newOffset = string(&quot;%=&quot;, m_offset))</span>
<span class="line-removed">-         return prepare(*newOffset, Token::Type::ModEquals);</span>
<span class="line-removed">-     if (auto newOffset = string(&quot;^=&quot;, m_offset))</span>
<span class="line-removed">-         return prepare(*newOffset, Token::Type::XorEquals);</span>
<span class="line-removed">-     if (auto newOffset = string(&quot;&amp;=&quot;, m_offset))</span>
<span class="line-removed">-         return prepare(*newOffset, Token::Type::AndEquals);</span>
<span class="line-removed">-     if (auto newOffset = string(&quot;|=&quot;, m_offset))</span>
<span class="line-removed">-         return prepare(*newOffset, Token::Type::OrEquals);</span>
<span class="line-removed">-     if (auto newOffset = string(&quot;++&quot;, m_offset))</span>
<span class="line-removed">-         return prepare(*newOffset, Token::Type::PlusPlus);</span>
<span class="line-removed">-     if (auto newOffset = string(&quot;--&quot;, m_offset))</span>
<span class="line-removed">-         return prepare(*newOffset, Token::Type::MinusMinus);</span>
<span class="line-removed">-     if (auto newOffset = string(&quot;-&gt;&quot;, m_offset))</span>
<span class="line-removed">-         return prepare(*newOffset, Token::Type::Arrow);</span>
<span class="line-removed">-     if (auto newOffset = string(&quot;[]&quot;, m_offset))</span>
<span class="line-removed">-         return prepare(*newOffset, Token::Type::SquareBracketPair);</span>
<span class="line-removed">-     if (auto newOffset = string(&quot;||&quot;, m_offset))</span>
<span class="line-removed">-         return prepare(*newOffset, Token::Type::OrOr);</span>
<span class="line-removed">-     if (auto newOffset = string(&quot;&amp;&amp;&quot;, m_offset))</span>
<span class="line-removed">-         return prepare(*newOffset, Token::Type::AndAnd);</span>
<span class="line-removed">-     if (auto newOffset = string(&quot;&lt;=&quot;, m_offset))</span>
<span class="line-removed">-         return prepare(*newOffset, Token::Type::LessThanOrEqualTo);</span>
<span class="line-removed">-     if (auto newOffset = string(&quot;&gt;=&quot;, m_offset))</span>
<span class="line-removed">-         return prepare(*newOffset, Token::Type::GreaterThanOrEqualTo);</span>
<span class="line-removed">-     if (auto newOffset = string(&quot;==&quot;, m_offset))</span>
<span class="line-removed">-         return prepare(*newOffset, Token::Type::EqualComparison);</span>
<span class="line-removed">-     if (auto newOffset = string(&quot;!=&quot;, m_offset))</span>
<span class="line-removed">-         return prepare(*newOffset, Token::Type::NotEqual);</span>
<span class="line-removed">-     if (auto newOffset = string(&quot;&gt;&gt;&quot;, m_offset))</span>
<span class="line-removed">-         return prepare(*newOffset, Token::Type::RightShift);</span>
<span class="line-removed">-     if (auto newOffset = string(&quot;&lt;&lt;&quot;, m_offset))</span>
<span class="line-removed">-         return prepare(*newOffset, Token::Type::LeftShift);</span>
<span class="line-removed">-     if (auto newOffset = character(&#39;=&#39;, m_offset))</span>
<span class="line-removed">-         return prepare(*newOffset, Token::Type::EqualsSign);</span>
<span class="line-removed">-     if (auto newOffset = character(&#39;;&#39;, m_offset))</span>
<span class="line-removed">-         return prepare(*newOffset, Token::Type::Semicolon);</span>
<span class="line-removed">-     if (auto newOffset = character(&#39;{&#39;, m_offset))</span>
<span class="line-removed">-         return prepare(*newOffset, Token::Type::LeftCurlyBracket);</span>
<span class="line-removed">-     if (auto newOffset = character(&#39;}&#39;, m_offset))</span>
<span class="line-removed">-         return prepare(*newOffset, Token::Type::RightCurlyBracket);</span>
<span class="line-removed">-     if (auto newOffset = character(&#39;:&#39;, m_offset))</span>
<span class="line-removed">-         return prepare(*newOffset, Token::Type::Colon);</span>
<span class="line-removed">-     if (auto newOffset = character(&#39;,&#39;, m_offset))</span>
<span class="line-removed">-         return prepare(*newOffset, Token::Type::Comma);</span>
<span class="line-removed">-     if (auto newOffset = character(&#39;(&#39;, m_offset))</span>
<span class="line-removed">-         return prepare(*newOffset, Token::Type::LeftParenthesis);</span>
<span class="line-removed">-     if (auto newOffset = character(&#39;)&#39;, m_offset))</span>
<span class="line-removed">-         return prepare(*newOffset, Token::Type::RightParenthesis);</span>
<span class="line-removed">-     if (auto newOffset = character(&#39;[&#39;, m_offset))</span>
<span class="line-removed">-         return prepare(*newOffset, Token::Type::LeftSquareBracket);</span>
<span class="line-removed">-     if (auto newOffset = character(&#39;]&#39;, m_offset))</span>
<span class="line-removed">-         return prepare(*newOffset, Token::Type::RightSquareBracket);</span>
<span class="line-removed">-     if (auto newOffset = character(&#39;*&#39;, m_offset))</span>
<span class="line-removed">-         return prepare(*newOffset, Token::Type::Star);</span>
<span class="line-removed">-     if (auto newOffset = character(&#39;&lt;&#39;, m_offset))</span>
<span class="line-removed">-         return prepare(*newOffset, Token::Type::LessThanSign);</span>
<span class="line-removed">-     if (auto newOffset = character(&#39;&gt;&#39;, m_offset))</span>
<span class="line-removed">-         return prepare(*newOffset, Token::Type::GreaterThanSign);</span>
<span class="line-removed">-     if (auto newOffset = character(&#39;.&#39;, m_offset))</span>
<span class="line-removed">-         return prepare(*newOffset, Token::Type::FullStop);</span>
<span class="line-removed">-     if (auto newOffset = character(&#39;?&#39;, m_offset))</span>
<span class="line-removed">-         return prepare(*newOffset, Token::Type::QuestionMark);</span>
<span class="line-removed">-     if (auto newOffset = character(&#39;|&#39;, m_offset))</span>
<span class="line-removed">-         return prepare(*newOffset, Token::Type::Or);</span>
<span class="line-removed">-     if (auto newOffset = character(&#39;^&#39;, m_offset))</span>
<span class="line-removed">-         return prepare(*newOffset, Token::Type::Xor);</span>
<span class="line-removed">-     if (auto newOffset = character(&#39;&amp;&#39;, m_offset))</span>
<span class="line-removed">-         return prepare(*newOffset, Token::Type::And);</span>
<span class="line-removed">-     if (auto newOffset = character(&#39;+&#39;, m_offset))</span>
<span class="line-removed">-         return prepare(*newOffset, Token::Type::Plus);</span>
<span class="line-removed">-     if (auto newOffset = character(&#39;-&#39;, m_offset))</span>
<span class="line-removed">-         return prepare(*newOffset, Token::Type::Minus);</span>
<span class="line-removed">-     if (auto newOffset = character(&#39;/&#39;, m_offset))</span>
<span class="line-removed">-         return prepare(*newOffset, Token::Type::Divide);</span>
<span class="line-removed">-     if (auto newOffset = character(&#39;%&#39;, m_offset))</span>
<span class="line-removed">-         return prepare(*newOffset, Token::Type::Mod);</span>
<span class="line-removed">-     if (auto newOffset = character(&#39;~&#39;, m_offset))</span>
<span class="line-removed">-         return prepare(*newOffset, Token::Type::Tilde);</span>
<span class="line-removed">-     if (auto newOffset = character(&#39;!&#39;, m_offset))</span>
<span class="line-removed">-         return prepare(*newOffset, Token::Type::ExclamationPoint);</span>
<span class="line-removed">-     if (auto newOffset = character(&#39;@&#39;, m_offset))</span>
<span class="line-removed">-         return prepare(*newOffset, Token::Type::At);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     return WTF::nullopt;</span>
  }
  
<span class="line-modified">! void Lexer::skipWhitespaceAndComments()</span>
  {
<span class="line-modified">!     unsigned savedOffset;</span>
<span class="line-modified">!     do {</span>
<span class="line-modified">!         savedOffset = m_offset;</span>
<span class="line-removed">-         skipWhitespace();</span>
<span class="line-removed">-         skipLineComment();</span>
<span class="line-removed">-         skipLongComment();</span>
<span class="line-removed">-     } while (savedOffset != m_offset);</span>
  }
  
<span class="line-modified">! static inline bool isWhitespace(UChar codeUnit)</span>
  {
<span class="line-modified">!     switch (codeUnit) {</span>
<span class="line-removed">-     case &#39; &#39;:</span>
<span class="line-removed">-     case &#39;\t&#39;:</span>
<span class="line-removed">-     case &#39;\r&#39;:</span>
<span class="line-removed">-     case &#39;\n&#39;:</span>
<span class="line-removed">-         return true;</span>
<span class="line-removed">-     default:</span>
<span class="line-removed">-         return false;</span>
<span class="line-removed">-     }</span>
  }
  
<span class="line-modified">! static inline bool isNewline(UChar codeUnit)</span>
  {
<span class="line-modified">!     switch (codeUnit) {</span>
<span class="line-modified">!     case &#39;\r&#39;:</span>
<span class="line-modified">!     case &#39;\n&#39;:</span>
<span class="line-modified">!         return true;</span>
<span class="line-modified">!     default:</span>
          return false;
<span class="line-modified">!     }</span>
<span class="line-removed">- }</span>
  
<span class="line-modified">! // We can take advantage of two properties of Unicode:</span>
<span class="line-modified">! // 1. The consitutent UTF-16 code units for all non-BMP code points are surrogates,</span>
<span class="line-modified">! //        which means we&#39;ll never see a false match. If we see a BMP code unit, we</span>
<span class="line-removed">- //        really have a BMP code point.</span>
<span class="line-removed">- // 2. Everything we&#39;re looking for is in BMP</span>
  
<span class="line-modified">! void Lexer::skipWhitespace()</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     for ( ; m_offset &lt; m_stringView.length() &amp;&amp; isWhitespace(m_stringView[m_offset]); ++m_offset) {</span>
<span class="line-modified">!         if (m_stringView[m_offset] == &#39;\r&#39; &amp;&amp; m_offset + 1 &lt; m_stringView.length() &amp;&amp; m_stringView[m_offset + 1] == &#39;\n&#39;) {</span>
<span class="line-modified">!             ++m_offset;</span>
<span class="line-modified">!             ++m_lineNumber;</span>
<span class="line-removed">-         } else if (isNewline(m_stringView[m_offset]))</span>
<span class="line-removed">-             ++m_lineNumber;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- }</span>
  
<span class="line-modified">! void Lexer::skipLineComment()</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     if (m_offset + 1 &gt;= m_stringView.length() || m_stringView[m_offset] != &#39;/&#39; || m_stringView[m_offset + 1] != &#39;/&#39;)</span>
<span class="line-modified">!         return;</span>
  
<span class="line-modified">!     m_offset += 2;</span>
<span class="line-modified">!     for ( ; m_offset &lt; m_stringView.length() &amp;&amp; !isNewline(m_stringView[m_offset]); ++m_offset) { }</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! void Lexer::skipLongComment()</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     if (m_offset + 1 &gt;= m_stringView.length() || m_stringView[m_offset] != &#39;/&#39; || m_stringView[m_offset + 1] != &#39;*&#39;)</span>
<span class="line-modified">!         return;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     m_offset += 2;</span>
<span class="line-modified">!     do {</span>
<span class="line-modified">!         for ( ; m_offset &lt; m_stringView.length() &amp;&amp; m_stringView[m_offset] != &#39;*&#39;; ++m_offset) {</span>
<span class="line-modified">!             if (m_stringView[m_offset] == &#39;\r&#39; &amp;&amp; m_offset + 1 &lt; m_stringView.length() &amp;&amp; m_stringView[m_offset + 1] == &#39;\n&#39;) {</span>
<span class="line-modified">!                 ++m_offset;</span>
<span class="line-modified">!                 ++m_lineNumber;</span>
<span class="line-modified">!             } else if (isNewline(m_stringView[m_offset]))</span>
<span class="line-modified">!                 ++m_lineNumber;</span>
          }
<span class="line-modified">!         if (m_offset &lt; m_stringView.length())</span>
<span class="line-modified">!             ++m_offset;</span>
<span class="line-modified">!         if (m_offset &lt; m_stringView.length() &amp;&amp; m_stringView[m_offset] == &#39;/&#39;) {</span>
<span class="line-modified">!             ++m_offset;</span>
              break;
          }
<span class="line-removed">-     } while (m_offset &lt; m_stringView.length());</span>
<span class="line-removed">- }</span>
  
<span class="line-modified">! // Regular expression are unnecessary; we shouldn&#39;t need to compile them.</span>
  
<span class="line-modified">! Optional&lt;unsigned&gt; Lexer::coreDecimalIntLiteral(unsigned offset) const</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     if (offset &gt;= m_stringView.length())</span>
<span class="line-modified">!         return WTF::nullopt;</span>
<span class="line-modified">!     if (m_stringView[offset] == &#39;0&#39;)</span>
<span class="line-modified">!         return offset + 1;</span>
<span class="line-modified">!     if (m_stringView[offset] &gt;= &#39;1&#39; &amp;&amp; m_stringView[offset] &lt;= &#39;9&#39;) {</span>
<span class="line-modified">!         ++offset;</span>
<span class="line-modified">!         for ( ; offset &lt; m_stringView.length() &amp;&amp; m_stringView[offset] &gt;= &#39;0&#39; &amp;&amp; m_stringView[offset] &lt;= &#39;9&#39;; ++offset) {</span>
          }
<span class="line-removed">-         return offset;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     return WTF::nullopt;</span>
<span class="line-removed">- }</span>
  
<span class="line-modified">! Optional&lt;unsigned&gt; Lexer::decimalIntLiteral(unsigned offset) const</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     if (offset &lt; m_stringView.length() &amp;&amp; m_stringView[offset] == &#39;-&#39;)</span>
<span class="line-modified">!         ++offset;</span>
<span class="line-modified">!     return coreDecimalIntLiteral(offset);</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! Optional&lt;unsigned&gt; Lexer::decimalUintLiteral(unsigned offset) const</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     auto result = coreDecimalIntLiteral(offset);</span>
<span class="line-modified">!     if (!result)</span>
<span class="line-modified">!         return WTF::nullopt;</span>
<span class="line-modified">!     if (*result &lt; m_stringView.length() &amp;&amp; m_stringView[*result] == &#39;u&#39;)</span>
<span class="line-modified">!         return *result + 1;</span>
<span class="line-modified">!     return WTF::nullopt;</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! static inline bool isHexadecimalCharacter(UChar character)</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     return (character &gt;= &#39;0&#39; &amp;&amp; character &lt;= &#39;9&#39;)</span>
<span class="line-removed">-         || (character &gt;= &#39;a&#39; &amp;&amp; character &lt;= &#39;f&#39;)</span>
<span class="line-removed">-         || (character &gt;= &#39;A&#39; &amp;&amp; character &lt;= &#39;F&#39;);</span>
<span class="line-removed">- }</span>
  
<span class="line-removed">- Optional&lt;unsigned&gt; Lexer::coreHexadecimalIntLiteral(unsigned offset) const</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     if (offset + 1 &gt;= m_stringView.length() || m_stringView[offset] != &#39;0&#39; || m_stringView[offset + 1] != &#39;x&#39;)</span>
<span class="line-removed">-         return WTF::nullopt;</span>
  
<span class="line-modified">!     offset += 2;</span>
<span class="line-modified">!     if (offset &gt;= m_stringView.length() || !isHexadecimalCharacter(m_stringView[offset]))</span>
<span class="line-modified">!         return WTF::nullopt;</span>
<span class="line-modified">!     ++offset;</span>
<span class="line-modified">!     for ( ; offset &lt; m_stringView.length() &amp;&amp; isHexadecimalCharacter(m_stringView[offset]); ++offset) {</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!     return offset;</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! Optional&lt;unsigned&gt; Lexer::hexadecimalIntLiteral(unsigned offset) const</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     if (offset &lt; m_stringView.length() &amp;&amp; m_stringView[offset] == &#39;-&#39;)</span>
<span class="line-modified">!         ++offset;</span>
<span class="line-modified">!     return coreHexadecimalIntLiteral(offset);</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! Optional&lt;unsigned&gt; Lexer::hexadecimalUintLiteral(unsigned offset) const</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     auto result = coreHexadecimalIntLiteral(offset);</span>
<span class="line-modified">!     if (!result)</span>
<span class="line-modified">!         return WTF::nullopt;</span>
<span class="line-modified">!     if (*result &lt; m_stringView.length() &amp;&amp; m_stringView[*result] == &#39;u&#39;)</span>
<span class="line-modified">!         return *result + 1;</span>
<span class="line-modified">!     return WTF::nullopt;</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! Optional&lt;unsigned&gt; Lexer::intLiteral(unsigned offset) const</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     if (auto result = decimalIntLiteral(offset))</span>
<span class="line-removed">-         return result;</span>
<span class="line-removed">-     if (auto result = hexadecimalIntLiteral(offset))</span>
<span class="line-removed">-         return result;</span>
<span class="line-removed">-     return WTF::nullopt;</span>
<span class="line-removed">- }</span>
  
<span class="line-modified">! Optional&lt;unsigned&gt; Lexer::uintLiteral(unsigned offset) const</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     if (auto result = decimalUintLiteral(offset))</span>
<span class="line-modified">!         return result;</span>
<span class="line-modified">!     if (auto result = hexadecimalUintLiteral(offset))</span>
<span class="line-modified">!         return result;</span>
<span class="line-modified">!     return WTF::nullopt;</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! Optional&lt;unsigned&gt; Lexer::digit(unsigned offset) const</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     if (offset &lt; m_stringView.length() &amp;&amp; m_stringView[offset] &gt;= &#39;0&#39; &amp;&amp; m_stringView[offset] &lt;= &#39;9&#39;)</span>
<span class="line-modified">!         return offset + 1;</span>
<span class="line-modified">!     return WTF::nullopt;</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! unsigned Lexer::digitStar(unsigned offset) const</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     while (true) {</span>
<span class="line-modified">!         auto result = digit(offset);</span>
<span class="line-modified">!         if (!result)</span>
<span class="line-modified">!             return offset;</span>
<span class="line-modified">!         offset = *result;</span>
      }
<span class="line-removed">- }</span>
  
<span class="line-modified">! Optional&lt;unsigned&gt; Lexer::character(char character, unsigned offset) const</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     if (offset &lt; m_stringView.length() &amp;&amp; m_stringView[offset] == character)</span>
<span class="line-modified">!         return offset + 1;</span>
<span class="line-modified">!     return WTF::nullopt;</span>
  }
  
<span class="line-modified">! Optional&lt;unsigned&gt; Lexer::coreFloatLiteralType1(unsigned offset) const</span>
  {
<span class="line-modified">!     auto result = digit(offset);</span>
<span class="line-modified">!     if (!result)</span>
<span class="line-modified">!         return WTF::nullopt;</span>
<span class="line-modified">!     auto result2 = digitStar(*result);</span>
<span class="line-modified">!     auto result3 = character(&#39;.&#39;, result2);</span>
<span class="line-modified">!     if (!result3)</span>
<span class="line-modified">!         return WTF::nullopt;</span>
<span class="line-modified">!     return digitStar(*result3);</span>
  }
  
<span class="line-modified">! Optional&lt;unsigned&gt; Lexer::coreFloatLiteral(unsigned offset) const</span>
  {
<span class="line-modified">!     if (auto type1 = coreFloatLiteralType1(offset))</span>
<span class="line-modified">!         return type1;</span>
<span class="line-modified">!     auto result = digitStar(offset);</span>
<span class="line-modified">!     auto result2 = character(&#39;.&#39;, result);</span>
<span class="line-modified">!     if (!result2)</span>
<span class="line-modified">!         return WTF::nullopt;</span>
<span class="line-modified">!     auto result3 = digit(*result2);</span>
<span class="line-removed">-     if (!result3)</span>
<span class="line-removed">-         return WTF::nullopt;</span>
<span class="line-removed">-     return digitStar(*result3);</span>
  }
  
<span class="line-modified">! Optional&lt;unsigned&gt; Lexer::floatLiteral(unsigned offset) const</span>
  {
<span class="line-modified">!     if (offset &lt; m_stringView.length() &amp;&amp; m_stringView[offset] == &#39;-&#39;)</span>
<span class="line-modified">!         ++offset;</span>
<span class="line-modified">!     auto result = coreFloatLiteral(offset);</span>
<span class="line-modified">!     if (!result)</span>
<span class="line-modified">!         return WTF::nullopt;</span>
<span class="line-modified">!     offset = *result;</span>
<span class="line-modified">!     if (offset &lt; m_stringView.length() &amp;&amp; m_stringView[offset] == &#39;f&#39;)</span>
<span class="line-modified">!         ++offset;</span>
<span class="line-modified">!     return offset;</span>
  }
  
<span class="line-modified">! Optional&lt;unsigned&gt; Lexer::validIdentifier(unsigned offset) const</span>
  {
<span class="line-modified">!     if (offset &gt;= m_stringView.length()</span>
<span class="line-modified">!         || !((m_stringView[offset] &gt;= &#39;a&#39; &amp;&amp; m_stringView[offset] &lt;= &#39;z&#39;)</span>
<span class="line-removed">-             || (m_stringView[offset] &gt;= &#39;A&#39; &amp;&amp; m_stringView[offset] &lt;= &#39;Z&#39;)</span>
<span class="line-removed">-             || (m_stringView[offset] == &#39;_&#39;)))</span>
          return WTF::nullopt;
<span class="line-modified">!     ++offset;</span>
<span class="line-modified">!     while (true) {</span>
<span class="line-modified">!         if (offset &gt;= m_stringView.length()</span>
<span class="line-modified">!             || !((m_stringView[offset] &gt;= &#39;a&#39; &amp;&amp; m_stringView[offset] &lt;= &#39;z&#39;)</span>
<span class="line-modified">!                 || (m_stringView[offset] &gt;= &#39;A&#39; &amp;&amp; m_stringView[offset] &lt;= &#39;Z&#39;)</span>
<span class="line-removed">-                 || (m_stringView[offset] &gt;= &#39;0&#39; &amp;&amp; m_stringView[offset] &lt;= &#39;9&#39;)</span>
<span class="line-removed">-                 || (m_stringView[offset] == &#39;_&#39;)))</span>
<span class="line-removed">-             return offset;</span>
<span class="line-removed">-         ++offset;</span>
      }
  }
  
<span class="line-modified">! Optional&lt;unsigned&gt; Lexer::identifier(unsigned offset) const</span>
  {
<span class="line-modified">!     return validIdentifier(offset);</span>
  }
  
<span class="line-modified">! Optional&lt;unsigned&gt; Lexer::operatorName(unsigned offset) const</span>
  {
<span class="line-modified">!     if (auto result = string(&quot;operator&amp;.&quot;, offset))</span>
<span class="line-modified">!         return validIdentifier(*result);</span>
<span class="line-modified">!     if (auto result = string(&quot;operator.&quot;, offset)) {</span>
<span class="line-modified">!         if ((result = validIdentifier(*result))) {</span>
<span class="line-modified">!             if (auto result2 = character(&#39;=&#39;, *result))</span>
<span class="line-modified">!                 return result2;</span>
<span class="line-modified">!             return *result;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!     if (auto result = string(&quot;operator&quot;, offset)) {</span>
<span class="line-modified">!         // Sorted by length, so longer matches are preferable to shorter matches.</span>
<span class="line-modified">!         if (auto result2 = string(&quot;&amp;[]&quot;, *result))</span>
<span class="line-modified">!             return result2;</span>
<span class="line-modified">!         if (auto result2 = string(&quot;[]=&quot;, *result))</span>
<span class="line-modified">!             return result2;</span>
<span class="line-modified">!         if (auto result2 = string(&quot;&gt;&gt;&quot;, *result))</span>
<span class="line-modified">!             return result2;</span>
<span class="line-modified">!         if (auto result2 = string(&quot;&lt;&lt;&quot;, *result))</span>
<span class="line-modified">!             return result2;</span>
<span class="line-modified">!         if (auto result2 = string(&quot;++&quot;, *result))</span>
<span class="line-modified">!             return result2;</span>
<span class="line-removed">-         if (auto result2 = string(&quot;--&quot;, *result))</span>
<span class="line-removed">-             return result2;</span>
<span class="line-removed">-         if (auto result2 = string(&quot;&amp;&amp;&quot;, *result))</span>
<span class="line-removed">-             return result2;</span>
<span class="line-removed">-         if (auto result2 = string(&quot;||&quot;, *result))</span>
<span class="line-removed">-             return result2;</span>
<span class="line-removed">-         if (auto result2 = string(&quot;&gt;=&quot;, *result))</span>
<span class="line-removed">-             return result2;</span>
<span class="line-removed">-         if (auto result2 = string(&quot;&lt;=&quot;, *result))</span>
<span class="line-removed">-             return result2;</span>
<span class="line-removed">-         if (auto result2 = string(&quot;==&quot;, *result))</span>
<span class="line-removed">-             return result2;</span>
<span class="line-removed">-         if (auto result2 = string(&quot;[]&quot;, *result))</span>
<span class="line-removed">-             return result2;</span>
<span class="line-removed">-         if (auto result2 = character(&#39;+&#39;, *result))</span>
<span class="line-removed">-             return result2;</span>
<span class="line-removed">-         if (auto result2 = character(&#39;-&#39;, *result))</span>
<span class="line-removed">-             return result2;</span>
<span class="line-removed">-         if (auto result2 = character(&#39;*&#39;, *result))</span>
<span class="line-removed">-             return result2;</span>
<span class="line-removed">-         if (auto result2 = character(&#39;/&#39;, *result))</span>
<span class="line-removed">-             return result2;</span>
<span class="line-removed">-         if (auto result2 = character(&#39;%&#39;, *result))</span>
<span class="line-removed">-             return result2;</span>
<span class="line-removed">-         if (auto result2 = character(&#39;&lt;&#39;, *result))</span>
<span class="line-removed">-             return result2;</span>
<span class="line-removed">-         if (auto result2 = character(&#39;&gt;&#39;, *result))</span>
<span class="line-removed">-             return result2;</span>
<span class="line-removed">-         if (auto result2 = character(&#39;!&#39;, *result))</span>
<span class="line-removed">-             return result2;</span>
<span class="line-removed">-         if (auto result2 = character(&#39;~&#39;, *result))</span>
<span class="line-removed">-             return result2;</span>
<span class="line-removed">-         if (auto result2 = character(&#39;&amp;&#39;, *result))</span>
<span class="line-removed">-             return result2;</span>
<span class="line-removed">-         if (auto result2 = character(&#39;^&#39;, *result))</span>
<span class="line-removed">-             return result2;</span>
<span class="line-removed">-         if (auto result2 = character(&#39;|&#39;, *result))</span>
<span class="line-removed">-             return result2;</span>
      }
<span class="line-removed">-     return WTF::nullopt;</span>
  }
  
  } // namespace WHLSL
  
  } // namespace WebCore
<span class="line-new-header">--- 243,1530 ---</span>
          return &quot;~&quot;;
      case Type::ExclamationPoint:
          return &quot;!&quot;;
      case Type::At:
          return &quot;@&quot;;
<span class="line-added">+     case Type::EndOfFile:</span>
<span class="line-added">+         return &quot;EOF&quot;;</span>
<span class="line-added">+     case Type::Invalid:</span>
<span class="line-added">+         return &quot;LEXING_ERROR&quot;;</span>
      }
  }
  
<span class="line-modified">! static ALWAYS_INLINE bool isValidIdentifierStart(UChar theChar)</span>
  {
<span class="line-modified">!     return (theChar &gt;= &#39;a&#39; &amp;&amp; theChar &lt;= &#39;z&#39;)</span>
<span class="line-modified">!         || (theChar &gt;= &#39;A&#39; &amp;&amp; theChar &lt;= &#39;Z&#39;)</span>
<span class="line-modified">!         || (theChar == &#39;_&#39;);</span>
  }
  
<span class="line-modified">! static ALWAYS_INLINE bool isValidNonStartingIdentifierChar(UChar theChar)</span>
  {
<span class="line-modified">!     return (theChar &gt;= &#39;a&#39; &amp;&amp; theChar &lt;= &#39;z&#39;)</span>
<span class="line-modified">!         || (theChar &gt;= &#39;A&#39; &amp;&amp; theChar &lt;= &#39;Z&#39;)</span>
<span class="line-modified">!         || (theChar &gt;= &#39;0&#39; &amp;&amp; theChar &lt;= &#39;9&#39;)</span>
<span class="line-modified">!         || (theChar == &#39;_&#39;);</span>
  }
  
<span class="line-modified">! static ALWAYS_INLINE bool isHexadecimalCharacter(UChar character)</span>
  {
<span class="line-modified">!     return (character &gt;= &#39;0&#39; &amp;&amp; character &lt;= &#39;9&#39;)</span>
<span class="line-modified">!         || (character &gt;= &#39;a&#39; &amp;&amp; character &lt;= &#39;f&#39;)</span>
<span class="line-modified">!         || (character &gt;= &#39;A&#39; &amp;&amp; character &lt;= &#39;F&#39;);</span>
  }
  
<span class="line-modified">! static ALWAYS_INLINE bool isDigit(UChar theChar)</span>
  {
<span class="line-modified">!     return theChar &gt;= &#39;0&#39; &amp;&amp; theChar &lt;= &#39;9&#39;;</span>
  }
  
<span class="line-modified">! auto Lexer::consumeTokenFromStream() -&gt; Token</span>
  {
<span class="line-modified">!     UChar current = 0;</span>
<span class="line-modified">!     unsigned offset = m_offset;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     auto peek = [&amp;] () -&gt; UChar {</span>
<span class="line-modified">!         if (offset &lt; m_stringView.length())</span>
<span class="line-added">+             return m_stringView[offset];</span>
<span class="line-added">+         return 0;</span>
<span class="line-added">+     };</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto shift = [&amp;] {</span>
<span class="line-added">+         if (offset &lt; m_stringView.length()) {</span>
<span class="line-added">+             current = m_stringView[offset];</span>
<span class="line-added">+             ++offset;</span>
<span class="line-added">+             return current;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         current = 0;</span>
<span class="line-added">+         return current;</span>
<span class="line-added">+     };</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto consume = [&amp;] (UChar theChar) {</span>
<span class="line-added">+         if (peek() == theChar) {</span>
<span class="line-added">+             shift();</span>
<span class="line-added">+             return true;</span>
<span class="line-added">+         }</span>
          return false;
<span class="line-modified">!     };</span>
  
<span class="line-modified">!     auto nextIsIdentifier = [&amp;] {</span>
<span class="line-modified">!         return isValidNonStartingIdentifierChar(peek());</span>
<span class="line-modified">!     };</span>
  
<span class="line-modified">!     auto token = [&amp;] (Token::Type type) -&gt; Token {</span>
<span class="line-modified">!         auto oldOffset = m_offset;</span>
<span class="line-modified">!         m_offset = offset;</span>
<span class="line-modified">!         skipWhitespaceAndComments();</span>
<span class="line-modified">!         return { { oldOffset, offset, m_nameSpace }, type };</span>
<span class="line-modified">!     };</span>
  
<span class="line-modified">!     switch (shift()) {</span>
<span class="line-modified">!     case &#39;A&#39;:</span>
<span class="line-modified">!     case &#39;B&#39;:</span>
<span class="line-modified">!     case &#39;C&#39;:</span>
<span class="line-added">+     case &#39;D&#39;:</span>
<span class="line-added">+     case &#39;E&#39;:</span>
<span class="line-added">+     case &#39;F&#39;:</span>
<span class="line-added">+     case &#39;G&#39;:</span>
<span class="line-added">+     case &#39;H&#39;:</span>
<span class="line-added">+     case &#39;I&#39;:</span>
<span class="line-added">+     case &#39;J&#39;:</span>
<span class="line-added">+     case &#39;K&#39;:</span>
<span class="line-added">+     case &#39;L&#39;:</span>
<span class="line-added">+     case &#39;M&#39;:</span>
<span class="line-added">+     case &#39;N&#39;:</span>
<span class="line-added">+     case &#39;O&#39;:</span>
<span class="line-added">+     case &#39;Q&#39;:</span>
<span class="line-added">+     case &#39;R&#39;:</span>
<span class="line-added">+     case &#39;T&#39;:</span>
<span class="line-added">+     case &#39;U&#39;:</span>
<span class="line-added">+     case &#39;V&#39;:</span>
<span class="line-added">+     case &#39;W&#39;:</span>
<span class="line-added">+     case &#39;X&#39;:</span>
<span class="line-added">+     case &#39;Y&#39;:</span>
<span class="line-added">+     case &#39;Z&#39;:</span>
<span class="line-added">+     case &#39;g&#39;:</span>
<span class="line-added">+     case &#39;h&#39;:</span>
<span class="line-added">+     case &#39;j&#39;:</span>
<span class="line-added">+     case &#39;k&#39;:</span>
<span class="line-added">+     case &#39;l&#39;:</span>
<span class="line-added">+     case &#39;m&#39;:</span>
<span class="line-added">+     case &#39;q&#39;:</span>
<span class="line-added">+     case &#39;x&#39;:</span>
<span class="line-added">+     case &#39;y&#39;:</span>
<span class="line-added">+     case &#39;z&#39;:</span>
<span class="line-added">+ parseIdentifier:</span>
<span class="line-added">+         while (isValidNonStartingIdentifierChar(peek()))</span>
<span class="line-added">+             shift();</span>
<span class="line-added">+         return token(Token::Type::Identifier);</span>
  
<span class="line-modified">!     case &#39;s&#39;:</span>
<span class="line-modified">!         switch (peek()) {</span>
<span class="line-modified">!         case &#39;a&#39;:</span>
<span class="line-added">+             shift();</span>
<span class="line-added">+             if (!consume(&#39;m&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (!consume(&#39;p&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (!consume(&#39;l&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (!consume(&#39;e&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (nextIsIdentifier())</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             return token(Token::Type::Qualifier);</span>
  
<span class="line-modified">!         case &#39;w&#39;:</span>
<span class="line-modified">!             shift();</span>
<span class="line-modified">!             if (!consume(&#39;i&#39;))</span>
<span class="line-modified">!                 goto parseIdentifier;</span>
<span class="line-modified">!             if (!consume(&#39;t&#39;))</span>
<span class="line-modified">!                 goto parseIdentifier;</span>
<span class="line-modified">!             if (!consume(&#39;c&#39;))</span>
<span class="line-modified">!                 goto parseIdentifier;</span>
<span class="line-modified">!             if (!consume(&#39;h&#39;))</span>
<span class="line-modified">!                 goto parseIdentifier;</span>
<span class="line-modified">!             if (nextIsIdentifier())</span>
<span class="line-modified">!                 goto parseIdentifier;</span>
<span class="line-modified">!             return token(Token::Type::Switch);</span>
<span class="line-added">+ </span>
<span class="line-added">+         case &#39;t&#39;:</span>
<span class="line-added">+             shift();</span>
<span class="line-added">+             switch (peek()) {</span>
<span class="line-added">+             case &#39;r&#39;:</span>
<span class="line-added">+                 shift();</span>
<span class="line-added">+                 if (!consume(&#39;u&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (!consume(&#39;c&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (!consume(&#39;t&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (nextIsIdentifier())</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 return token(Token::Type::Struct);</span>
<span class="line-added">+             case &#39;a&#39;:</span>
<span class="line-added">+                 shift();</span>
<span class="line-added">+                 if (!consume(&#39;t&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (!consume(&#39;i&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (!consume(&#39;c&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (nextIsIdentifier())</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 return token(Token::Type::Static);</span>
<span class="line-added">+             default:</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             }</span>
<span class="line-added">+             break;</span>
<span class="line-added">+ </span>
<span class="line-added">+         case &#39;p&#39;:</span>
<span class="line-added">+             shift();</span>
<span class="line-added">+             switch (peek()) {</span>
<span class="line-added">+             case &#39;a&#39;:</span>
<span class="line-added">+                 shift();</span>
<span class="line-added">+                 if (!consume(&#39;c&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (!consume(&#39;e&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (nextIsIdentifier())</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 return token(Token::Type::Space);</span>
<span class="line-added">+             case &#39;e&#39;:</span>
<span class="line-added">+                 shift();</span>
<span class="line-added">+                 if (!consume(&#39;c&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (!consume(&#39;i&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (!consume(&#39;a&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (!consume(&#39;l&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (!consume(&#39;i&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (!consume(&#39;z&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (!consume(&#39;e&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (!consume(&#39;d&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (nextIsIdentifier())</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 return token(Token::Type::Specialized);</span>
<span class="line-added">+             default:</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             }</span>
<span class="line-added">+         default:</span>
<span class="line-added">+             goto parseIdentifier;</span>
          }
<span class="line-modified">! </span>
<span class="line-modified">!     case &#39;S&#39;:</span>
<span class="line-modified">!         if (!consume(&#39;V&#39;))</span>
<span class="line-modified">!             goto parseIdentifier;</span>
<span class="line-added">+         if (!consume(&#39;_&#39;))</span>
<span class="line-added">+             goto parseIdentifier;</span>
<span class="line-added">+ </span>
<span class="line-added">+         switch (peek()) {</span>
<span class="line-added">+         case &#39;G&#39;:</span>
<span class="line-added">+             shift();</span>
<span class="line-added">+             if (!consume(&#39;r&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (!consume(&#39;o&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (!consume(&#39;u&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (!consume(&#39;p&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+ </span>
<span class="line-added">+             switch (peek()) {</span>
<span class="line-added">+             case &#39;I&#39;:</span>
<span class="line-added">+                 shift();</span>
<span class="line-added">+                 switch (peek()) {</span>
<span class="line-added">+                 case &#39;D&#39;:</span>
<span class="line-added">+                     shift();</span>
<span class="line-added">+                     if (nextIsIdentifier())</span>
<span class="line-added">+                         goto parseIdentifier;</span>
<span class="line-added">+                     return token(Token::Type::SVGroupID);</span>
<span class="line-added">+                 case &#39;n&#39;:</span>
<span class="line-added">+                     shift();</span>
<span class="line-added">+                     if (!consume(&#39;d&#39;))</span>
<span class="line-added">+                         goto parseIdentifier;</span>
<span class="line-added">+                     if (!consume(&#39;e&#39;))</span>
<span class="line-added">+                         goto parseIdentifier;</span>
<span class="line-added">+                     if (!consume(&#39;x&#39;))</span>
<span class="line-added">+                         goto parseIdentifier;</span>
<span class="line-added">+                     if (nextIsIdentifier())</span>
<span class="line-added">+                         goto parseIdentifier;</span>
<span class="line-added">+                     return token(Token::Type::SVGroupIndex);</span>
<span class="line-added">+ </span>
<span class="line-added">+                 default:</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+ </span>
<span class="line-added">+             case &#39;T&#39;:</span>
<span class="line-added">+                 shift();</span>
<span class="line-added">+                 if (!consume(&#39;h&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (!consume(&#39;r&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (!consume(&#39;e&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (!consume(&#39;a&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (!consume(&#39;d&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (!consume(&#39;I&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (!consume(&#39;D&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (nextIsIdentifier())</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 return token(Token::Type::SVGroupThreadID);</span>
<span class="line-added">+ </span>
<span class="line-added">+             default:</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             }</span>
<span class="line-added">+         case &#39;D&#39;:</span>
<span class="line-added">+             shift();</span>
<span class="line-added">+             switch (peek()) {</span>
<span class="line-added">+             case &#39;e&#39;:</span>
<span class="line-added">+                 shift();</span>
<span class="line-added">+                 if (!consume(&#39;p&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (!consume(&#39;t&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (!consume(&#39;h&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (nextIsIdentifier())</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 return token(Token::Type::SVDepth);</span>
<span class="line-added">+             case &#39;i&#39;:</span>
<span class="line-added">+                 shift();</span>
<span class="line-added">+                 if (!consume(&#39;s&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (!consume(&#39;p&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (!consume(&#39;a&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (!consume(&#39;t&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (!consume(&#39;c&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (!consume(&#39;h&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (!consume(&#39;T&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (!consume(&#39;h&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (!consume(&#39;r&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (!consume(&#39;e&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (!consume(&#39;a&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (!consume(&#39;d&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (!consume(&#39;I&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (!consume(&#39;D&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (nextIsIdentifier())</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 return token(Token::Type::SVDispatchThreadID);</span>
<span class="line-added">+             default:</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             }</span>
<span class="line-added">+         case &#39;C&#39;:</span>
<span class="line-added">+             shift();</span>
<span class="line-added">+             if (!consume(&#39;o&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (!consume(&#39;v&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (!consume(&#39;e&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (!consume(&#39;r&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (!consume(&#39;a&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (!consume(&#39;g&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (!consume(&#39;e&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (nextIsIdentifier())</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             return token(Token::Type::SVCoverage);</span>
<span class="line-added">+         case &#39;T&#39;:</span>
<span class="line-added">+             shift();</span>
<span class="line-added">+             if (!consume(&#39;a&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (!consume(&#39;r&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (!consume(&#39;g&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (!consume(&#39;e&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (!consume(&#39;t&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (nextIsIdentifier())</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             return token(Token::Type::SVTarget);</span>
<span class="line-added">+         case &#39;S&#39;:</span>
<span class="line-added">+             shift();</span>
<span class="line-added">+             if (!consume(&#39;a&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (!consume(&#39;m&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (!consume(&#39;p&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (!consume(&#39;l&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (!consume(&#39;e&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (!consume(&#39;I&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (!consume(&#39;n&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (!consume(&#39;d&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (!consume(&#39;e&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (!consume(&#39;x&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (nextIsIdentifier())</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             return token(Token::Type::SVSampleIndex);</span>
<span class="line-added">+         case &#39;P&#39;:</span>
<span class="line-added">+             shift();</span>
<span class="line-added">+             if (!consume(&#39;o&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (!consume(&#39;s&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (!consume(&#39;i&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (!consume(&#39;t&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (!consume(&#39;i&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (!consume(&#39;o&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (!consume(&#39;n&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (nextIsIdentifier())</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             return token(Token::Type::SVPosition);</span>
<span class="line-added">+         case &#39;V&#39;:</span>
<span class="line-added">+             shift();</span>
<span class="line-added">+             if (!consume(&#39;e&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (!consume(&#39;r&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (!consume(&#39;t&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (!consume(&#39;e&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (!consume(&#39;x&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (!consume(&#39;I&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (!consume(&#39;D&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (nextIsIdentifier())</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             return token(Token::Type::SVVertexID);</span>
<span class="line-added">+         case &#39;I&#39;:</span>
<span class="line-added">+             shift();</span>
<span class="line-added">+             switch (peek()) {</span>
<span class="line-added">+             case &#39;s&#39;:</span>
<span class="line-added">+                 shift();</span>
<span class="line-added">+                 if (!consume(&#39;F&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (!consume(&#39;r&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (!consume(&#39;o&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (!consume(&#39;n&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (!consume(&#39;t&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (!consume(&#39;F&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (!consume(&#39;a&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (!consume(&#39;c&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (!consume(&#39;e&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (nextIsIdentifier())</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 return token(Token::Type::SVIsFrontFace);</span>
<span class="line-added">+             case &#39;n&#39;:</span>
<span class="line-added">+                 shift();</span>
<span class="line-added">+                 switch (peek()) {</span>
<span class="line-added">+                 case &#39;n&#39;:</span>
<span class="line-added">+                     shift();</span>
<span class="line-added">+                     if (!consume(&#39;e&#39;))</span>
<span class="line-added">+                         goto parseIdentifier;</span>
<span class="line-added">+                     if (!consume(&#39;r&#39;))</span>
<span class="line-added">+                         goto parseIdentifier;</span>
<span class="line-added">+                     if (!consume(&#39;C&#39;))</span>
<span class="line-added">+                         goto parseIdentifier;</span>
<span class="line-added">+                     if (!consume(&#39;o&#39;))</span>
<span class="line-added">+                         goto parseIdentifier;</span>
<span class="line-added">+                     if (!consume(&#39;v&#39;))</span>
<span class="line-added">+                         goto parseIdentifier;</span>
<span class="line-added">+                     if (!consume(&#39;e&#39;))</span>
<span class="line-added">+                         goto parseIdentifier;</span>
<span class="line-added">+                     if (!consume(&#39;r&#39;))</span>
<span class="line-added">+                         goto parseIdentifier;</span>
<span class="line-added">+                     if (!consume(&#39;a&#39;))</span>
<span class="line-added">+                         goto parseIdentifier;</span>
<span class="line-added">+                     if (!consume(&#39;g&#39;))</span>
<span class="line-added">+                         goto parseIdentifier;</span>
<span class="line-added">+                     if (!consume(&#39;e&#39;))</span>
<span class="line-added">+                         goto parseIdentifier;</span>
<span class="line-added">+                     if (nextIsIdentifier())</span>
<span class="line-added">+                         goto parseIdentifier;</span>
<span class="line-added">+                     return token(Token::Type::SVInnerCoverage);</span>
<span class="line-added">+                 case &#39;s&#39;:</span>
<span class="line-added">+                     shift();</span>
<span class="line-added">+                     if (!consume(&#39;t&#39;))</span>
<span class="line-added">+                         goto parseIdentifier;</span>
<span class="line-added">+                     if (!consume(&#39;a&#39;))</span>
<span class="line-added">+                         goto parseIdentifier;</span>
<span class="line-added">+                     if (!consume(&#39;n&#39;))</span>
<span class="line-added">+                         goto parseIdentifier;</span>
<span class="line-added">+                     if (!consume(&#39;c&#39;))</span>
<span class="line-added">+                         goto parseIdentifier;</span>
<span class="line-added">+                     if (!consume(&#39;e&#39;))</span>
<span class="line-added">+                         goto parseIdentifier;</span>
<span class="line-added">+                     if (!consume(&#39;I&#39;))</span>
<span class="line-added">+                         goto parseIdentifier;</span>
<span class="line-added">+                     if (!consume(&#39;D&#39;))</span>
<span class="line-added">+                         goto parseIdentifier;</span>
<span class="line-added">+                     if (nextIsIdentifier())</span>
<span class="line-added">+                         goto parseIdentifier;</span>
<span class="line-added">+                     return token(Token::Type::SVInstanceID);</span>
<span class="line-added">+                 default:</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+ </span>
<span class="line-added">+             default:</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             }</span>
<span class="line-added">+         default:</span>
<span class="line-added">+             goto parseIdentifier;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+     case &#39;t&#39;:</span>
<span class="line-added">+         switch (peek()) {</span>
<span class="line-added">+         case &#39;r&#39;:</span>
<span class="line-added">+             shift();</span>
<span class="line-added">+             if (!consume(&#39;u&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (!consume(&#39;e&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (nextIsIdentifier())</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             return token(Token::Type::True);</span>
<span class="line-added">+         case &#39;y&#39;:</span>
<span class="line-added">+             shift();</span>
<span class="line-added">+             if (!consume(&#39;p&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (!consume(&#39;e&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (!consume(&#39;d&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (!consume(&#39;e&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (!consume(&#39;f&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (nextIsIdentifier())</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             return token(Token::Type::Typedef);</span>
<span class="line-added">+         case &#39;h&#39;:</span>
<span class="line-added">+             shift();</span>
<span class="line-added">+             if (!consume(&#39;r&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (!consume(&#39;e&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (!consume(&#39;a&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (!consume(&#39;d&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+ </span>
<span class="line-added">+             if (!nextIsIdentifier())</span>
<span class="line-added">+                 return token(Token::Type::Thread);</span>
<span class="line-added">+ </span>
<span class="line-added">+             if (peek() != &#39;g&#39;)</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+ </span>
<span class="line-added">+             shift();</span>
<span class="line-added">+             RELEASE_ASSERT(current == &#39;g&#39;);</span>
<span class="line-added">+             if (!consume(&#39;r&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (!consume(&#39;o&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (!consume(&#39;u&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (!consume(&#39;p&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (nextIsIdentifier())</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             return token(Token::Type::Threadgroup);</span>
<span class="line-added">+ </span>
<span class="line-added">+         default:</span>
<span class="line-added">+             goto parseIdentifier;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+     case &#39;e&#39;:</span>
<span class="line-added">+         switch (peek()) {</span>
<span class="line-added">+         case &#39;n&#39;:</span>
<span class="line-added">+             shift();</span>
<span class="line-added">+             if (!consume(&#39;u&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (!consume(&#39;m&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (nextIsIdentifier())</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             return token(Token::Type::Enum);</span>
<span class="line-added">+         case &#39;l&#39;:</span>
<span class="line-added">+             shift();</span>
<span class="line-added">+             if (!consume(&#39;s&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (!consume(&#39;e&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (nextIsIdentifier())</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             return token(Token::Type::Else);</span>
<span class="line-added">+         default:</span>
<span class="line-added">+             goto parseIdentifier;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+     case &#39;o&#39;:</span>
<span class="line-added">+         if (!consume(&#39;p&#39;))</span>
<span class="line-added">+             goto parseIdentifier;</span>
<span class="line-added">+         if (!consume(&#39;e&#39;))</span>
<span class="line-added">+             goto parseIdentifier;</span>
<span class="line-added">+         if (!consume(&#39;r&#39;))</span>
<span class="line-added">+             goto parseIdentifier;</span>
<span class="line-added">+         if (!consume(&#39;a&#39;))</span>
<span class="line-added">+             goto parseIdentifier;</span>
<span class="line-added">+         if (!consume(&#39;t&#39;))</span>
<span class="line-added">+             goto parseIdentifier;</span>
<span class="line-added">+         if (!consume(&#39;o&#39;))</span>
<span class="line-added">+             goto parseIdentifier;</span>
<span class="line-added">+         if (!consume(&#39;r&#39;))</span>
<span class="line-added">+             goto parseIdentifier;</span>
<span class="line-added">+         if (nextIsIdentifier())</span>
<span class="line-added">+             goto parseIdentifier;</span>
<span class="line-added">+ </span>
<span class="line-added">+         switch (peek()) {</span>
<span class="line-added">+         case &#39;&amp;&#39;:</span>
<span class="line-added">+             shift();</span>
<span class="line-added">+             switch (peek()) {</span>
<span class="line-added">+             case &#39;[&#39;:</span>
<span class="line-added">+                 shift();</span>
<span class="line-added">+                 if (consume(&#39;]&#39;))</span>
<span class="line-added">+                     return token(Token::Type::OperatorName);</span>
<span class="line-added">+                 return token(Token::Type::Invalid);</span>
<span class="line-added">+             case &#39;.&#39;:</span>
<span class="line-added">+                 shift();</span>
<span class="line-added">+                 if (!isValidIdentifierStart(peek()))</span>
<span class="line-added">+                     return token(Token::Type::Invalid);</span>
<span class="line-added">+                 shift();</span>
<span class="line-added">+                 while (isValidNonStartingIdentifierChar(peek()))</span>
<span class="line-added">+                     shift();</span>
<span class="line-added">+                 return token(Token::Type::OperatorName);</span>
<span class="line-added">+             default:</span>
<span class="line-added">+                 return token(Token::Type::OperatorName);</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
<span class="line-added">+         case &#39;[&#39;:</span>
<span class="line-added">+             shift();</span>
<span class="line-added">+             if (!consume(&#39;]&#39;))</span>
<span class="line-added">+                 return token(Token::Type::Invalid);</span>
<span class="line-added">+             consume(&#39;=&#39;);</span>
<span class="line-added">+             return token(Token::Type::OperatorName);</span>
<span class="line-added">+ </span>
<span class="line-added">+         case &#39;&gt;&#39;:</span>
<span class="line-added">+             shift();</span>
<span class="line-added">+             if (consume(&#39;&gt;&#39;))</span>
<span class="line-added">+                 return token(Token::Type::OperatorName);</span>
<span class="line-added">+             if (consume(&#39;=&#39;))</span>
<span class="line-added">+                 return token(Token::Type::OperatorName);</span>
<span class="line-added">+             return token(Token::Type::OperatorName);</span>
<span class="line-added">+ </span>
<span class="line-added">+         case &#39;&lt;&#39;:</span>
<span class="line-added">+             shift();</span>
<span class="line-added">+             if (consume(&#39;&lt;&#39;))</span>
<span class="line-added">+                 return token(Token::Type::OperatorName);</span>
<span class="line-added">+             if (consume(&#39;=&#39;))</span>
<span class="line-added">+                 return token(Token::Type::OperatorName);</span>
<span class="line-added">+             return token(Token::Type::OperatorName);</span>
<span class="line-added">+ </span>
<span class="line-added">+         case &#39;+&#39;:</span>
<span class="line-added">+             shift();</span>
<span class="line-added">+             consume(&#39;+&#39;);</span>
<span class="line-added">+             return token(Token::Type::OperatorName);</span>
<span class="line-added">+ </span>
<span class="line-added">+         case &#39;-&#39;:</span>
<span class="line-added">+             shift();</span>
<span class="line-added">+             consume(&#39;-&#39;);</span>
<span class="line-added">+             return token(Token::Type::OperatorName);</span>
<span class="line-added">+ </span>
<span class="line-added">+         case &#39;|&#39;:</span>
<span class="line-added">+             shift();</span>
<span class="line-added">+             return token(Token::Type::OperatorName);</span>
<span class="line-added">+ </span>
<span class="line-added">+         case &#39;=&#39;:</span>
<span class="line-added">+             shift();</span>
<span class="line-added">+             if (!consume(&#39;=&#39;))</span>
<span class="line-added">+                 return token(Token::Type::Invalid);</span>
<span class="line-added">+             return token(Token::Type::OperatorName);</span>
<span class="line-added">+ </span>
<span class="line-added">+         case &#39;*&#39;:</span>
<span class="line-added">+             shift();</span>
<span class="line-added">+             return token(Token::Type::OperatorName);</span>
<span class="line-added">+ </span>
<span class="line-added">+         case &#39;/&#39;:</span>
<span class="line-added">+             shift();</span>
<span class="line-added">+             return token(Token::Type::OperatorName);</span>
<span class="line-added">+ </span>
<span class="line-added">+         case &#39;%&#39;:</span>
<span class="line-added">+             shift();</span>
<span class="line-added">+             return token(Token::Type::OperatorName);</span>
<span class="line-added">+ </span>
<span class="line-added">+         case &#39;!&#39;:</span>
<span class="line-added">+             shift();</span>
<span class="line-added">+             return token(Token::Type::OperatorName);</span>
<span class="line-added">+ </span>
<span class="line-added">+         case &#39;~&#39;:</span>
<span class="line-added">+             shift();</span>
<span class="line-added">+             return token(Token::Type::OperatorName);</span>
<span class="line-added">+ </span>
<span class="line-added">+         case &#39;^&#39;:</span>
<span class="line-added">+             shift();</span>
<span class="line-added">+             return token(Token::Type::OperatorName);</span>
<span class="line-added">+ </span>
<span class="line-added">+         case &#39;.&#39;:</span>
<span class="line-added">+             shift();</span>
<span class="line-added">+             if (!isValidIdentifierStart(peek()))</span>
<span class="line-added">+                 return token(Token::Type::Invalid);</span>
<span class="line-added">+             shift();</span>
<span class="line-added">+             while (isValidNonStartingIdentifierChar(peek()))</span>
<span class="line-added">+                 shift();</span>
<span class="line-added">+             consume(&#39;=&#39;);</span>
<span class="line-added">+             return token(Token::Type::OperatorName);</span>
<span class="line-added">+         default:</span>
              break;
          }
  
<span class="line-modified">!         return token(Token::Type::Operator);</span>
  
<span class="line-modified">!     case &#39;i&#39;:</span>
<span class="line-modified">!         if (!consume(&#39;f&#39;))</span>
<span class="line-modified">!             goto parseIdentifier;</span>
<span class="line-modified">!         if (nextIsIdentifier())</span>
<span class="line-modified">!             goto parseIdentifier;</span>
<span class="line-modified">!         return token(Token::Type::If);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     case &#39;c&#39;:</span>
<span class="line-modified">!         switch (peek()) {</span>
<span class="line-added">+         case &#39;a&#39;:</span>
<span class="line-added">+             shift();</span>
<span class="line-added">+             if (!consume(&#39;s&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (!consume(&#39;e&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (nextIsIdentifier())</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             return token(Token::Type::Case);</span>
<span class="line-added">+ </span>
<span class="line-added">+         case &#39;e&#39;:</span>
<span class="line-added">+             shift();</span>
<span class="line-added">+             if (!consume(&#39;n&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (!consume(&#39;t&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (!consume(&#39;r&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (!consume(&#39;o&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (!consume(&#39;i&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (!consume(&#39;d&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (nextIsIdentifier())</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             return token(Token::Type::Qualifier);</span>
<span class="line-added">+         case &#39;o&#39;:</span>
<span class="line-added">+             shift();</span>
<span class="line-added">+             switch (peek()) {</span>
<span class="line-added">+             case &#39;m&#39;:</span>
<span class="line-added">+                 shift();</span>
<span class="line-added">+                 if (!consume(&#39;p&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (!consume(&#39;u&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (!consume(&#39;t&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (!consume(&#39;e&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (nextIsIdentifier())</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 return token(Token::Type::Compute);</span>
<span class="line-added">+             case &#39;n&#39;:</span>
<span class="line-added">+                 shift();</span>
<span class="line-added">+                 switch (peek()) {</span>
<span class="line-added">+                 case &#39;t&#39;:</span>
<span class="line-added">+                     shift();</span>
<span class="line-added">+                     if (!consume(&#39;i&#39;))</span>
<span class="line-added">+                         goto parseIdentifier;</span>
<span class="line-added">+                     if (!consume(&#39;n&#39;))</span>
<span class="line-added">+                         goto parseIdentifier;</span>
<span class="line-added">+                     if (!consume(&#39;u&#39;))</span>
<span class="line-added">+                         goto parseIdentifier;</span>
<span class="line-added">+                     if (!consume(&#39;e&#39;))</span>
<span class="line-added">+                         goto parseIdentifier;</span>
<span class="line-added">+                     if (nextIsIdentifier())</span>
<span class="line-added">+                         goto parseIdentifier;</span>
<span class="line-added">+                     return token(Token::Type::Continue);</span>
<span class="line-added">+                 case &#39;s&#39;:</span>
<span class="line-added">+                     shift();</span>
<span class="line-added">+                     if (!consume(&#39;t&#39;))</span>
<span class="line-added">+                         goto parseIdentifier;</span>
<span class="line-added">+ </span>
<span class="line-added">+                     if (!nextIsIdentifier())</span>
<span class="line-added">+                         return token(Token::Type::Const);</span>
<span class="line-added">+ </span>
<span class="line-added">+                     if (!consume(&#39;a&#39;))</span>
<span class="line-added">+                         goto parseIdentifier;</span>
<span class="line-added">+                     if (!consume(&#39;n&#39;))</span>
<span class="line-added">+                         goto parseIdentifier;</span>
<span class="line-added">+                     if (!consume(&#39;t&#39;))</span>
<span class="line-added">+                         goto parseIdentifier;</span>
<span class="line-added">+                     if (nextIsIdentifier())</span>
<span class="line-added">+                         goto parseIdentifier;</span>
<span class="line-added">+                     return token(Token::Type::Constant);</span>
<span class="line-added">+ </span>
<span class="line-added">+                 default:</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+ </span>
<span class="line-added">+             default:</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
<span class="line-added">+         default:</span>
<span class="line-added">+             goto parseIdentifier;</span>
          }
  
<span class="line-modified">!     case &#39;b&#39;:</span>
<span class="line-modified">!         if (!consume(&#39;r&#39;))</span>
<span class="line-modified">!             goto parseIdentifier;</span>
<span class="line-modified">!         if (!consume(&#39;e&#39;))</span>
<span class="line-modified">!             goto parseIdentifier;</span>
<span class="line-modified">!         if (!consume(&#39;a&#39;))</span>
<span class="line-added">+             goto parseIdentifier;</span>
<span class="line-added">+         if (!consume(&#39;k&#39;))</span>
<span class="line-added">+             goto parseIdentifier;</span>
<span class="line-added">+         if (nextIsIdentifier())</span>
<span class="line-added">+             goto parseIdentifier;</span>
<span class="line-added">+         return token(Token::Type::Break);</span>
  
<span class="line-modified">!     case &#39;d&#39;:</span>
<span class="line-modified">!         switch (peek()) {</span>
<span class="line-modified">!         case &#39;o&#39;:</span>
<span class="line-modified">!             shift();</span>
<span class="line-modified">!             if (nextIsIdentifier())</span>
<span class="line-modified">!                 goto parseIdentifier;</span>
<span class="line-modified">!             return token(Token::Type::Do);</span>
<span class="line-modified">!         case &#39;e&#39;:</span>
<span class="line-modified">!             shift();</span>
<span class="line-added">+             switch (peek()) {</span>
<span class="line-added">+             case &#39;f&#39;:</span>
<span class="line-added">+                 shift();</span>
<span class="line-added">+                 if (!consume(&#39;a&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (!consume(&#39;u&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (!consume(&#39;l&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (!consume(&#39;t&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (nextIsIdentifier())</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 return token(Token::Type::Default);</span>
<span class="line-added">+             case &#39;v&#39;:</span>
<span class="line-added">+                 shift();</span>
<span class="line-added">+                 if (!consume(&#39;i&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (!consume(&#39;c&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (!consume(&#39;e&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (nextIsIdentifier())</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 return token(Token::Type::Device);</span>
<span class="line-added">+             default:</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             }</span>
  
<span class="line-modified">!         default:</span>
<span class="line-modified">!             goto parseIdentifier;</span>
<span class="line-modified">!         }</span>
  
  
<span class="line-modified">!     case &#39;f&#39;:</span>
<span class="line-modified">!         switch (peek()) {</span>
<span class="line-modified">!         case &#39;o&#39;:</span>
<span class="line-modified">!             shift();</span>
<span class="line-modified">!             if (!consume(&#39;r&#39;))</span>
<span class="line-modified">!                 goto parseIdentifier;</span>
<span class="line-modified">!             if (nextIsIdentifier())</span>
<span class="line-modified">!                 goto parseIdentifier;</span>
<span class="line-added">+             return token(Token::Type::For);</span>
<span class="line-added">+         case &#39;r&#39;:</span>
<span class="line-added">+             shift();</span>
<span class="line-added">+             if (!consume(&#39;a&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (!consume(&#39;g&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (!consume(&#39;m&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (!consume(&#39;e&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (!consume(&#39;n&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (!consume(&#39;t&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (nextIsIdentifier())</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             return token(Token::Type::Fragment);</span>
<span class="line-added">+         case &#39;a&#39;:</span>
<span class="line-added">+             shift();</span>
<span class="line-added">+             if (!consume(&#39;l&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
  
<span class="line-modified">!             switch (peek()) {</span>
<span class="line-modified">!             case &#39;l&#39;:</span>
<span class="line-modified">!                 shift();</span>
<span class="line-modified">!                 if (!consume(&#39;t&#39;))</span>
<span class="line-modified">!                     goto parseIdentifier;</span>
<span class="line-modified">!                 if (!consume(&#39;h&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (!consume(&#39;r&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (!consume(&#39;o&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (!consume(&#39;u&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (!consume(&#39;g&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (!consume(&#39;h&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (nextIsIdentifier())</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 return token(Token::Type::Fallthrough);</span>
  
<span class="line-modified">!             case &#39;s&#39;:</span>
<span class="line-modified">!                 shift();</span>
<span class="line-modified">!                 if (!consume(&#39;e&#39;))</span>
<span class="line-modified">!                     goto parseIdentifier;</span>
<span class="line-modified">!                 if (nextIsIdentifier())</span>
<span class="line-modified">!                     goto parseIdentifier;</span>
<span class="line-modified">!                 return token(Token::Type::False);</span>
<span class="line-modified">!             default:</span>
<span class="line-modified">!                 goto parseIdentifier;</span>
<span class="line-added">+             }</span>
<span class="line-added">+         case &#39;e&#39;:</span>
<span class="line-added">+             shift();</span>
<span class="line-added">+             switch (peek()) {</span>
<span class="line-added">+             case &#39;f&#39;:</span>
<span class="line-added">+                 shift();</span>
<span class="line-added">+                 if (!consume(&#39;a&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (!consume(&#39;u&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (!consume(&#39;l&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (!consume(&#39;t&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (nextIsIdentifier())</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 return token(Token::Type::Default);</span>
<span class="line-added">+             case &#39;v&#39;:</span>
<span class="line-added">+                 shift();</span>
<span class="line-added">+                 if (!consume(&#39;i&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (!consume(&#39;c&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (!consume(&#39;e&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (nextIsIdentifier())</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 return token(Token::Type::Device);</span>
<span class="line-added">+             default:</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             }</span>
  
<span class="line-modified">!         default:</span>
<span class="line-modified">!             goto parseIdentifier;</span>
<span class="line-modified">!         }</span>
  
<span class="line-modified">!     case &#39;w&#39;:</span>
<span class="line-modified">!         if (!consume(&#39;h&#39;))</span>
<span class="line-modified">!             goto parseIdentifier;</span>
<span class="line-modified">!         if (!consume(&#39;i&#39;))</span>
<span class="line-modified">!             goto parseIdentifier;</span>
<span class="line-modified">!         if (!consume(&#39;l&#39;))</span>
<span class="line-modified">!             goto parseIdentifier;</span>
<span class="line-modified">!         if (!consume(&#39;e&#39;))</span>
<span class="line-added">+             goto parseIdentifier;</span>
<span class="line-added">+         if (nextIsIdentifier())</span>
<span class="line-added">+             goto parseIdentifier;</span>
<span class="line-added">+         return token(Token::Type::While);</span>
  
<span class="line-modified">!     case &#39;r&#39;:</span>
<span class="line-modified">!         if (!consume(&#39;e&#39;))</span>
<span class="line-modified">!             goto parseIdentifier;</span>
<span class="line-modified">!         switch (peek()) {</span>
<span class="line-modified">!         case &#39;t&#39;:</span>
<span class="line-modified">!             shift();</span>
<span class="line-added">+             if (!consume(&#39;u&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (!consume(&#39;r&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (!consume(&#39;n&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (nextIsIdentifier())</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             return token(Token::Type::Return);</span>
<span class="line-added">+         case &#39;g&#39;:</span>
<span class="line-added">+             shift();</span>
<span class="line-added">+             if (!consume(&#39;i&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (!consume(&#39;s&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (!consume(&#39;t&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (!consume(&#39;e&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (!consume(&#39;r&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (nextIsIdentifier())</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             return token(Token::Type::Register);</span>
<span class="line-added">+         case &#39;s&#39;:</span>
<span class="line-added">+             shift();</span>
<span class="line-added">+             if (!consume(&#39;t&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (!consume(&#39;r&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (!consume(&#39;i&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (!consume(&#39;c&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (!consume(&#39;t&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (!consume(&#39;e&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (!consume(&#39;d&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (nextIsIdentifier())</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             return token(Token::Type::Restricted);</span>
<span class="line-added">+         default:</span>
<span class="line-added">+             goto parseIdentifier;</span>
<span class="line-added">+         }</span>
  
<span class="line-modified">!     case &#39;n&#39;:</span>
<span class="line-modified">!         switch (peek()) {</span>
<span class="line-modified">!         case &#39;a&#39;:</span>
<span class="line-modified">!             shift();</span>
<span class="line-modified">!             if (!consume(&#39;t&#39;))</span>
<span class="line-modified">!                 goto parseIdentifier;</span>
<span class="line-modified">!             if (!consume(&#39;i&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (!consume(&#39;v&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (!consume(&#39;e&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (nextIsIdentifier())</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             return token(Token::Type::Native);</span>
<span class="line-added">+         case &#39;u&#39;:</span>
<span class="line-added">+             shift();</span>
<span class="line-added">+             switch (peek()) {</span>
<span class="line-added">+             case &#39;l&#39;:</span>
<span class="line-added">+                 shift();</span>
<span class="line-added">+                 if (!consume(&#39;l&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (nextIsIdentifier())</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 return token(Token::Type::Null);</span>
<span class="line-added">+             case &#39;m&#39;:</span>
<span class="line-added">+                 shift();</span>
<span class="line-added">+                 if (!consume(&#39;t&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (!consume(&#39;h&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (!consume(&#39;r&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (!consume(&#39;e&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (!consume(&#39;a&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (!consume(&#39;d&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (!consume(&#39;s&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (nextIsIdentifier())</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 return token(Token::Type::NumThreads);</span>
<span class="line-added">+             default:</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
<span class="line-added">+         case &#39;o&#39;:</span>
<span class="line-added">+             shift();</span>
<span class="line-added">+             switch (peek()) {</span>
<span class="line-added">+             case &#39;i&#39;:</span>
<span class="line-added">+                 shift();</span>
<span class="line-added">+                 if (!consume(&#39;n&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (!consume(&#39;t&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (!consume(&#39;e&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (!consume(&#39;r&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (!consume(&#39;p&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (!consume(&#39;o&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (!consume(&#39;l&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (!consume(&#39;a&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (!consume(&#39;t&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (!consume(&#39;i&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (!consume(&#39;o&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (!consume(&#39;n&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (nextIsIdentifier())</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 return token(Token::Type::Qualifier);</span>
<span class="line-added">+             case &#39;p&#39;:</span>
<span class="line-added">+                 shift();</span>
<span class="line-added">+                 if (!consume(&#39;e&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (!consume(&#39;r&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (!consume(&#39;s&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (!consume(&#39;p&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (!consume(&#39;e&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (!consume(&#39;c&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (!consume(&#39;t&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (!consume(&#39;i&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (!consume(&#39;v&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (!consume(&#39;e&#39;))</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 if (nextIsIdentifier())</span>
<span class="line-added">+                     goto parseIdentifier;</span>
<span class="line-added">+                 return token(Token::Type::Qualifier);</span>
<span class="line-added">+             default:</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
<span class="line-added">+         default:</span>
<span class="line-added">+             goto parseIdentifier;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+     case &#39;v&#39;:</span>
<span class="line-added">+         if (!consume(&#39;e&#39;))</span>
<span class="line-added">+             goto parseIdentifier;</span>
<span class="line-added">+         if (!consume(&#39;r&#39;))</span>
<span class="line-added">+             goto parseIdentifier;</span>
<span class="line-added">+         if (!consume(&#39;t&#39;))</span>
<span class="line-added">+             goto parseIdentifier;</span>
<span class="line-added">+         if (!consume(&#39;e&#39;))</span>
<span class="line-added">+             goto parseIdentifier;</span>
<span class="line-added">+         if (!consume(&#39;x&#39;))</span>
<span class="line-added">+             goto parseIdentifier;</span>
<span class="line-added">+         if (nextIsIdentifier())</span>
<span class="line-added">+             goto parseIdentifier;</span>
<span class="line-added">+         return token(Token::Type::Vertex);</span>
<span class="line-added">+ </span>
<span class="line-added">+     case &#39;P&#39;:</span>
<span class="line-added">+         if (!consume(&#39;S&#39;))</span>
<span class="line-added">+             goto parseIdentifier;</span>
<span class="line-added">+         if (!consume(&#39;I&#39;))</span>
<span class="line-added">+             goto parseIdentifier;</span>
<span class="line-added">+         if (!consume(&#39;Z&#39;))</span>
<span class="line-added">+             goto parseIdentifier;</span>
<span class="line-added">+         if (!consume(&#39;E&#39;))</span>
<span class="line-added">+             goto parseIdentifier;</span>
<span class="line-added">+         if (nextIsIdentifier())</span>
<span class="line-added">+             goto parseIdentifier;</span>
<span class="line-added">+         return token(Token::Type::PSize);</span>
<span class="line-added">+ </span>
<span class="line-added">+     case &#39;u&#39;:</span>
<span class="line-added">+         if (!consume(&#39;n&#39;))</span>
<span class="line-added">+             goto parseIdentifier;</span>
<span class="line-added">+         if (!consume(&#39;i&#39;))</span>
<span class="line-added">+             goto parseIdentifier;</span>
<span class="line-added">+         if (!consume(&#39;f&#39;))</span>
<span class="line-added">+             goto parseIdentifier;</span>
<span class="line-added">+         if (!consume(&#39;o&#39;))</span>
<span class="line-added">+             goto parseIdentifier;</span>
<span class="line-added">+         if (!consume(&#39;r&#39;))</span>
<span class="line-added">+             goto parseIdentifier;</span>
<span class="line-added">+         if (!consume(&#39;m&#39;))</span>
<span class="line-added">+             goto parseIdentifier;</span>
<span class="line-added">+         if (nextIsIdentifier())</span>
<span class="line-added">+             goto parseIdentifier;</span>
<span class="line-added">+         return token(Token::Type::Qualifier);</span>
<span class="line-added">+ </span>
<span class="line-added">+     case &#39;p&#39;:</span>
<span class="line-added">+         if (!consume(&#39;r&#39;))</span>
<span class="line-added">+             goto parseIdentifier;</span>
<span class="line-added">+         if (!consume(&#39;o&#39;))</span>
<span class="line-added">+             goto parseIdentifier;</span>
<span class="line-added">+         if (!consume(&#39;t&#39;))</span>
<span class="line-added">+             goto parseIdentifier;</span>
<span class="line-added">+         if (!consume(&#39;o&#39;))</span>
<span class="line-added">+             goto parseIdentifier;</span>
<span class="line-added">+         if (!consume(&#39;c&#39;))</span>
<span class="line-added">+             goto parseIdentifier;</span>
<span class="line-added">+         if (!consume(&#39;o&#39;))</span>
<span class="line-added">+             goto parseIdentifier;</span>
<span class="line-added">+         if (!consume(&#39;l&#39;))</span>
<span class="line-added">+             goto parseIdentifier;</span>
<span class="line-added">+         if (nextIsIdentifier())</span>
<span class="line-added">+             goto parseIdentifier;</span>
<span class="line-added">+         return token(Token::Type::Protocol);</span>
<span class="line-added">+ </span>
<span class="line-added">+     case &#39;_&#39;:</span>
<span class="line-added">+         if (nextIsIdentifier())</span>
<span class="line-added">+             goto parseIdentifier;</span>
<span class="line-added">+         return token(Token::Type::Underscore);</span>
<span class="line-added">+ </span>
<span class="line-added">+     case &#39;a&#39;:</span>
<span class="line-added">+         switch (peek()) {</span>
<span class="line-added">+         case &#39;t&#39;:</span>
<span class="line-added">+             shift();</span>
<span class="line-added">+             if (!consume(&#39;t&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (!consume(&#39;r&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (!consume(&#39;i&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (!consume(&#39;b&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (!consume(&#39;u&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (!consume(&#39;t&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (!consume(&#39;e&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (nextIsIdentifier())</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             return token(Token::Type::Attribute);</span>
<span class="line-added">+         case &#39;u&#39;:</span>
<span class="line-added">+             shift();</span>
<span class="line-added">+             if (!consume(&#39;t&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (!consume(&#39;o&#39;))</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             if (nextIsIdentifier())</span>
<span class="line-added">+                 goto parseIdentifier;</span>
<span class="line-added">+             return token(Token::Type::Auto);</span>
<span class="line-added">+         default:</span>
<span class="line-added">+             goto parseIdentifier;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+     case &#39;&gt;&#39;:</span>
<span class="line-added">+         if (consume(&#39;&gt;&#39;)) {</span>
<span class="line-added">+             if (consume(&#39;=&#39;))</span>
<span class="line-added">+                 return token(Token::Type::RightShiftEquals);</span>
<span class="line-added">+             return token(Token::Type::RightShift);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         if (consume(&#39;=&#39;))</span>
<span class="line-added">+             return token(Token::Type::GreaterThanOrEqualTo);</span>
<span class="line-added">+         return token(Token::Type::GreaterThanSign);</span>
<span class="line-added">+     case &#39;&lt;&#39;:</span>
<span class="line-added">+         if (consume(&#39;&lt;&#39;)) {</span>
<span class="line-added">+             if (consume(&#39;=&#39;))</span>
<span class="line-added">+                 return token(Token::Type::LeftShiftEquals);</span>
<span class="line-added">+             return token(Token::Type::LeftShift);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         if (consume(&#39;=&#39;))</span>
<span class="line-added">+             return token(Token::Type::LessThanOrEqualTo);</span>
<span class="line-added">+         return token(Token::Type::LessThanSign);</span>
<span class="line-added">+ </span>
<span class="line-added">+     case &#39;+&#39;:</span>
<span class="line-added">+         if (consume(&#39;=&#39;))</span>
<span class="line-added">+             return token(Token::Type::PlusEquals);</span>
<span class="line-added">+         if (consume(&#39;+&#39;))</span>
<span class="line-added">+             return token(Token::Type::PlusPlus);</span>
<span class="line-added">+         return token(Token::Type::Plus);</span>
<span class="line-added">+ </span>
<span class="line-added">+     case &#39;-&#39;:</span>
<span class="line-added">+         if (consume(&#39;=&#39;))</span>
<span class="line-added">+             return token(Token::Type::MinusEquals);</span>
<span class="line-added">+         if (consume(&#39;-&#39;))</span>
<span class="line-added">+             return token(Token::Type::MinusMinus);</span>
<span class="line-added">+         if (consume(&#39;&gt;&#39;))</span>
<span class="line-added">+             return token(Token::Type::Arrow);</span>
<span class="line-added">+         if (isDigit(peek())) {</span>
<span class="line-added">+             shift();</span>
<span class="line-added">+             goto parseNumber;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         if (consume(&#39;.&#39;))</span>
<span class="line-added">+             goto parseFloatAfterDot;</span>
<span class="line-added">+         return token(Token::Type::Minus);</span>
<span class="line-added">+ </span>
<span class="line-added">+     case &#39;*&#39;:</span>
<span class="line-added">+         if (consume(&#39;=&#39;))</span>
<span class="line-added">+             return token(Token::Type::TimesEquals);</span>
<span class="line-added">+         return token(Token::Type::Star);</span>
<span class="line-added">+ </span>
<span class="line-added">+     case &#39;/&#39;:</span>
<span class="line-added">+         if (consume(&#39;=&#39;))</span>
<span class="line-added">+             return token(Token::Type::DivideEquals);</span>
<span class="line-added">+         return token(Token::Type::Divide);</span>
<span class="line-added">+ </span>
<span class="line-added">+     case &#39;%&#39;:</span>
<span class="line-added">+         if (consume(&#39;=&#39;))</span>
<span class="line-added">+             return token(Token::Type::ModEquals);</span>
<span class="line-added">+         return token(Token::Type::Mod);</span>
<span class="line-added">+ </span>
<span class="line-added">+     case &#39;^&#39;:</span>
<span class="line-added">+         if (consume(&#39;=&#39;))</span>
<span class="line-added">+             return token(Token::Type::XorEquals);</span>
<span class="line-added">+         return token(Token::Type::Xor);</span>
<span class="line-added">+ </span>
<span class="line-added">+     case &#39;&amp;&#39;:</span>
<span class="line-added">+         if (consume(&#39;=&#39;))</span>
<span class="line-added">+             return token(Token::Type::AndEquals);</span>
<span class="line-added">+         if (consume(&#39;&amp;&#39;))</span>
<span class="line-added">+             return token(Token::Type::AndAnd);</span>
<span class="line-added">+         return token(Token::Type::And);</span>
<span class="line-added">+ </span>
<span class="line-added">+     case &#39;|&#39;:</span>
<span class="line-added">+         if (consume(&#39;=&#39;))</span>
<span class="line-added">+             return token(Token::Type::OrEquals);</span>
<span class="line-added">+         if (consume(&#39;|&#39;))</span>
<span class="line-added">+             return token(Token::Type::OrOr);</span>
<span class="line-added">+         return token(Token::Type::Or);</span>
<span class="line-added">+ </span>
<span class="line-added">+     case &#39;[&#39;:</span>
<span class="line-added">+         if (consume(&#39;]&#39;))</span>
<span class="line-added">+             return token(Token::Type::SquareBracketPair);</span>
<span class="line-added">+         return token(Token::Type::LeftSquareBracket);</span>
<span class="line-added">+ </span>
<span class="line-added">+     case &#39;=&#39;:</span>
<span class="line-added">+         if (consume(&#39;=&#39;))</span>
<span class="line-added">+             return token(Token::Type::EqualComparison);</span>
<span class="line-added">+         return token(Token::Type::EqualsSign);</span>
<span class="line-added">+ </span>
<span class="line-added">+     case &#39;!&#39;:</span>
<span class="line-added">+         if (consume(&#39;=&#39;))</span>
<span class="line-added">+             return token(Token::Type::NotEqual);</span>
<span class="line-added">+         return token(Token::Type::ExclamationPoint);</span>
<span class="line-added">+ </span>
<span class="line-added">+     case &#39;;&#39;:</span>
<span class="line-added">+         return token(Token::Type::Semicolon);</span>
<span class="line-added">+ </span>
<span class="line-added">+     case &#39;{&#39;:</span>
<span class="line-added">+         return token(Token::Type::LeftCurlyBracket);</span>
<span class="line-added">+ </span>
<span class="line-added">+     case &#39;}&#39;:</span>
<span class="line-added">+         return token(Token::Type::RightCurlyBracket);</span>
<span class="line-added">+ </span>
<span class="line-added">+     case &#39;:&#39;:</span>
<span class="line-added">+         return token(Token::Type::Colon);</span>
<span class="line-added">+ </span>
<span class="line-added">+     case &#39;,&#39;:</span>
<span class="line-added">+         return token(Token::Type::Comma);</span>
<span class="line-added">+ </span>
<span class="line-added">+     case &#39;(&#39;:</span>
<span class="line-added">+         return token(Token::Type::LeftParenthesis);</span>
<span class="line-added">+ </span>
<span class="line-added">+     case &#39;)&#39;:</span>
<span class="line-added">+         return token(Token::Type::RightParenthesis);</span>
<span class="line-added">+ </span>
<span class="line-added">+     case &#39;]&#39;:</span>
<span class="line-added">+         return token(Token::Type::RightSquareBracket);</span>
<span class="line-added">+ </span>
<span class="line-added">+     case &#39;.&#39;:</span>
<span class="line-added">+         if (isDigit(peek()))</span>
<span class="line-added">+             goto parseFloatAfterDot;</span>
<span class="line-added">+         return token(Token::Type::FullStop);</span>
<span class="line-added">+ </span>
<span class="line-added">+     case &#39;?&#39;:</span>
<span class="line-added">+         return token(Token::Type::QuestionMark);</span>
<span class="line-added">+ </span>
<span class="line-added">+     case &#39;~&#39;:</span>
<span class="line-added">+         return token(Token::Type::Tilde);</span>
<span class="line-added">+ </span>
<span class="line-added">+     case &#39;@&#39;:</span>
<span class="line-added">+         return token(Token::Type::At);</span>
<span class="line-added">+ </span>
<span class="line-added">+     case &#39;0&#39;:</span>
<span class="line-added">+     case &#39;1&#39;:</span>
<span class="line-added">+     case &#39;2&#39;:</span>
<span class="line-added">+     case &#39;3&#39;:</span>
<span class="line-added">+     case &#39;4&#39;:</span>
<span class="line-added">+     case &#39;5&#39;:</span>
<span class="line-added">+     case &#39;6&#39;:</span>
<span class="line-added">+     case &#39;7&#39;:</span>
<span class="line-added">+     case &#39;8&#39;:</span>
<span class="line-added">+     case &#39;9&#39;: {</span>
<span class="line-added">+ parseNumber:</span>
<span class="line-added">+         if (current == &#39;0&#39; &amp;&amp; consume(&#39;x&#39;)) {</span>
<span class="line-added">+             while (isHexadecimalCharacter(peek()))</span>
<span class="line-added">+                 shift();</span>
<span class="line-added">+             if (consume(&#39;u&#39;))</span>
<span class="line-added">+                 return token(Token::Type::UintLiteral);</span>
<span class="line-added">+             return token(Token::Type::IntLiteral);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         while (isDigit(peek()))</span>
<span class="line-added">+             shift();</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (consume(&#39;.&#39;)) {</span>
<span class="line-added">+ parseFloatAfterDot:</span>
<span class="line-added">+             while (isDigit(peek()))</span>
<span class="line-added">+                 shift();</span>
<span class="line-added">+             consume(&#39;f&#39;);</span>
<span class="line-added">+             return token(Token::Type::FloatLiteral);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (consume(&#39;f&#39;))</span>
<span class="line-added">+             return token(Token::Type::FloatLiteral);</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (consume(&#39;u&#39;))</span>
<span class="line-added">+             return token(Token::Type::UintLiteral);</span>
<span class="line-added">+ </span>
<span class="line-added">+         return token(Token::Type::IntLiteral);</span>
      }
  
<span class="line-modified">!     default:</span>
<span class="line-modified">!         break;</span>
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     if (m_offset == m_stringView.length())</span>
<span class="line-added">+         return token(Token::Type::EndOfFile);</span>
<span class="line-added">+     return token(Token::Type::Invalid);</span>
  }
  
<span class="line-modified">! </span>
<span class="line-added">+ // We can take advantage of two properties of Unicode:</span>
<span class="line-added">+ // 1. The consitutent UTF-16 code units for all non-BMP code points are surrogates,</span>
<span class="line-added">+ // which means we&#39;ll never see a false match. If we see a BMP code unit, we</span>
<span class="line-added">+ // really have a BMP code point.</span>
<span class="line-added">+ // 2. Everything we&#39;re looking for is in BMP</span>
<span class="line-added">+ </span>
<span class="line-added">+ static inline bool isWhitespace(UChar codeUnit)</span>
  {
<span class="line-modified">!     switch (codeUnit) {</span>
<span class="line-modified">!     case &#39; &#39;:</span>
<span class="line-modified">!     case &#39;\t&#39;:</span>
<span class="line-modified">!     case &#39;\r&#39;:</span>
<span class="line-modified">!     case &#39;\n&#39;:</span>
<span class="line-modified">!         return true;</span>
<span class="line-modified">!     default:</span>
<span class="line-modified">!         return false;</span>
<span class="line-added">+     }</span>
  }
  
<span class="line-modified">! static inline bool isNewline(UChar codeUnit)</span>
  {
<span class="line-modified">!     switch (codeUnit) {</span>
<span class="line-modified">!     case &#39;\r&#39;:</span>
<span class="line-modified">!     case &#39;\n&#39;:</span>
<span class="line-modified">!         return true;</span>
<span class="line-modified">!     default:</span>
<span class="line-modified">!         return false;</span>
<span class="line-modified">!     }</span>
  }
  
<span class="line-modified">! auto Lexer::lineAndColumnNumberFromOffset(const StringView&amp; stringView, unsigned targetOffset) -&gt; LineAndColumn</span>
  {
<span class="line-modified">!     // Counting from 1 to match most text editors.</span>
<span class="line-modified">!     unsigned lineNumber = 1;</span>
<span class="line-modified">!     unsigned columnNumber = 1;</span>
<span class="line-modified">!     for (unsigned offset = 0; offset &lt; std::min(stringView.length(), targetOffset); ++offset) {</span>
<span class="line-modified">!         ++columnNumber;</span>
<span class="line-modified">!         if (isNewline(stringView[offset])) {</span>
<span class="line-modified">!             ++lineNumber;</span>
<span class="line-modified">!             columnNumber = 1;</span>
<span class="line-modified">!         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return { lineNumber, columnNumber };</span>
  }
  
<span class="line-modified">! static Optional&lt;StringView&gt; sourceFromNameSpace(AST::NameSpace nameSpace, const String&amp; source1, const String* source2)</span>
  {
<span class="line-modified">!     switch (nameSpace) {</span>
<span class="line-modified">!     case AST::NameSpace::StandardLibrary:</span>
          return WTF::nullopt;
<span class="line-modified">!     case AST::NameSpace::NameSpace1:</span>
<span class="line-modified">!         return StringView(source1);</span>
<span class="line-modified">!     case AST::NameSpace::NameSpace2:</span>
<span class="line-modified">!         ASSERT(source2);</span>
<span class="line-modified">!         return StringView(*source2);</span>
      }
  }
  
<span class="line-modified">! String Lexer::errorString(Error error, const String&amp; source1, const String* source2)</span>
  {
<span class="line-modified">!     if (auto codeLocation = error.codeLocation()) {</span>
<span class="line-added">+         if (auto source = sourceFromNameSpace(codeLocation.nameSpace(), source1, source2)) {</span>
<span class="line-added">+             auto lineAndColumn = lineAndColumnNumberFromOffset(*source, error.codeLocation().startOffset());</span>
<span class="line-added">+             return makeString(lineAndColumn.line, &#39;:&#39;, lineAndColumn.column, &quot;: &quot;, error.message());</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return error.message();</span>
  }
  
<span class="line-modified">! void Lexer::skipWhitespaceAndComments()</span>
  {
<span class="line-modified">!     while (m_offset &lt; m_stringView.length()) {</span>
<span class="line-modified">!         if (isWhitespace(m_stringView[m_offset]))</span>
<span class="line-modified">!             ++m_offset;</span>
<span class="line-modified">!         else if (m_stringView[m_offset] == &#39;/&#39; &amp;&amp; m_offset + 1 &lt; m_stringView.length()) {</span>
<span class="line-modified">!             if (m_stringView[m_offset + 1] == &#39;/&#39;) {</span>
<span class="line-modified">!                 // Line comment</span>
<span class="line-modified">!                 m_offset += 2;</span>
<span class="line-modified">!                 // Note that in the case of \r\n this makes the comment end on the \r. It is fine, as the \n after that is simple whitespace.</span>
<span class="line-modified">!                 for ( ; m_offset &lt; m_stringView.length() &amp;&amp; !isNewline(m_stringView[m_offset]); ++m_offset) { }</span>
<span class="line-modified">!             } else if (m_stringView[m_offset + 1] == &#39;*&#39;) {</span>
<span class="line-modified">!                 // Long comment</span>
<span class="line-modified">!                 for ( ; m_offset &lt; m_stringView.length() ; ++m_offset) {</span>
<span class="line-modified">!                     if (m_stringView[m_offset] == &#39;*&#39; &amp;&amp; m_offset + 1 &lt; m_stringView.length() &amp;&amp; m_stringView[m_offset + 1] == &#39;/&#39;) {</span>
<span class="line-modified">!                         m_offset += 2;</span>
<span class="line-modified">!                         break;</span>
<span class="line-modified">!                     }</span>
<span class="line-modified">!                 }</span>
<span class="line-modified">!             } else</span>
<span class="line-modified">!                 break;</span>
<span class="line-modified">!         } else</span>
<span class="line-modified">!             break;</span>
      }
  }
  
  } // namespace WHLSL
  
  } // namespace WebCore
</pre>
<center><a href="WHLSLIntrinsics.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="WHLSLLexer.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>