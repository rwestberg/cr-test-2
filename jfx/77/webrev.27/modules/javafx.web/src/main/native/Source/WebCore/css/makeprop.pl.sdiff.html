<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/css/makeprop.pl</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="makeSelectorPseudoElementsMap.py.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="makevalues.pl.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/css/makeprop.pl</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 231         return 1;
 232     }
 233     if (substr($a, 0, 1) ne &quot;-&quot; &amp;&amp; substr($b, 0, 1) eq &quot;-&quot;) {
 234         return -1;
 235     }
 236     return $a cmp $b;
 237 }
 238 
 239 @names = sort sortByDescendingPriorityAndName @names;
 240 
 241 open GPERF, &quot;&gt;CSSPropertyNames.gperf&quot; || die &quot;Could not open CSSPropertyNames.gperf for writing&quot;;
 242 print GPERF &lt;&lt; &quot;EOF&quot;;
 243 %{
 244 /* This file is automatically generated from $inputFile by makeprop, do not edit */
 245 #include &quot;config.h&quot;
 246 #include \&quot;CSSProperty.h\&quot;
 247 #include \&quot;CSSPropertyNames.h\&quot;
 248 #include \&quot;HashTools.h\&quot;
 249 #include &quot;RuntimeEnabledFeatures.h&quot;
 250 #include &lt;wtf/ASCIICType.h&gt;
<span class="line-modified"> 251 #include &lt;wtf/text/AtomicString.h&gt;</span>
 252 #include &lt;wtf/text/WTFString.h&gt;
 253 #include &lt;string.h&gt;
 254 
 255 IGNORE_WARNINGS_BEGIN(\&quot;implicit-fallthrough\&quot;)
 256 
 257 // Older versions of gperf like to use the `register` keyword.
 258 #define register
 259 
 260 namespace WebCore {
 261 
 262 // Using std::numeric_limits&lt;uint16_t&gt;::max() here would be cleaner,
 263 // but is not possible due to missing constexpr support in MSVC 2013.
 264 static_assert(numCSSProperties + 1 &lt;= 65535, &quot;CSSPropertyID should fit into uint16_t.&quot;);
 265 
 266 EOF
 267 
 268 print GPERF &quot;const char* const propertyNameStrings[numCSSProperties] = {\n&quot;;
 269 foreach my $name (@names) {
 270   print GPERF &quot;    \&quot;$name\&quot;,\n&quot;;
 271 }
</pre>
<hr />
<pre>
 333   print GPERF &quot;    case CSSPropertyID::CSSProperty&quot; . $nameToId{$name} . &quot;:\n&quot;;
 334   print GPERF &quot;        return RuntimeEnabledFeatures::sharedFeatures().&quot; . $runtimeFlags{$name} . &quot;Enabled();\n&quot;;
 335 }
 336 
 337 print GPERF &lt;&lt; &quot;EOF&quot;;
 338     default:
 339         return true;
 340     }
 341 }
 342 
 343 const char* getPropertyName(CSSPropertyID id)
 344 {
 345     if (id &lt; firstCSSProperty)
 346         return 0;
 347     int index = id - firstCSSProperty;
 348     if (index &gt;= numCSSProperties)
 349         return 0;
 350     return propertyNameStrings[index];
 351 }
 352 
<span class="line-modified"> 353 const AtomicString&amp; getPropertyNameAtomicString(CSSPropertyID id)</span>
 354 {
 355     if (id &lt; firstCSSProperty)
 356         return nullAtom();
 357     int index = id - firstCSSProperty;
 358     if (index &gt;= numCSSProperties)
 359         return nullAtom();
 360 
<span class="line-modified"> 361     static AtomicString* propertyStrings = new AtomicString[numCSSProperties]; // Intentionally never destroyed.</span>
<span class="line-modified"> 362     AtomicString&amp; propertyString = propertyStrings[index];</span>
 363     if (propertyString.isNull()) {
 364         const char* propertyName = propertyNameStrings[index];
<span class="line-modified"> 365         propertyString = AtomicString(propertyName, strlen(propertyName), AtomicString::ConstructFromLiteral);</span>
 366     }
 367     return propertyString;
 368 }
 369 
 370 String getPropertyNameString(CSSPropertyID id)
 371 {
<span class="line-modified"> 372     // We share the StringImpl with the AtomicStrings.</span>
<span class="line-modified"> 373     return getPropertyNameAtomicString(id).string();</span>
 374 }
 375 
 376 String getJSPropertyName(CSSPropertyID id)
 377 {
 378     char result[maxCSSPropertyNameLength + 1];
 379     const char* cssPropertyName = getPropertyName(id);
 380     const char* propertyNamePointer = cssPropertyName;
 381     if (!propertyNamePointer)
 382         return emptyString();
 383 
 384     char* resultPointer = result;
 385     while (char character = *propertyNamePointer++) {
 386         if (character == &#39;-&#39;) {
 387             char nextCharacter = *propertyNamePointer++;
 388             if (!nextCharacter)
 389                 break;
 390             character = (propertyNamePointer - 2 != cssPropertyName) ? toASCIIUpper(nextCharacter) : nextCharacter;
 391         }
 392         *resultPointer++ = character;
 393     }
</pre>
<hr />
<pre>
 470   $i = $i + 1;
 471   if (length($name) &gt; $maxLen) {
 472     $maxLen = length($name);
 473   }
 474 }
 475 my $num = $i - $first;
 476 my $last = $i - 1;
 477 
 478 print HEADER &quot;};\n\n&quot;;
 479 print HEADER &quot;const int firstCSSProperty = $first;\n&quot;;
 480 print HEADER &quot;const int numCSSProperties = $num;\n&quot;;
 481 print HEADER &quot;const int lastCSSProperty = $last;\n&quot;;
 482 print HEADER &quot;const size_t maxCSSPropertyNameLength = $maxLen;\n&quot;;
 483 print HEADER &quot;const CSSPropertyID lastHighPriorityProperty = CSSProperty&quot; . $nameToId{$lastHighPriorityPropertyName} . &quot;;\n&quot;;
 484 
 485 print HEADER &lt;&lt; &quot;EOF&quot;;
 486 
 487 bool isInternalCSSProperty(const CSSPropertyID);
 488 bool isEnabledCSSProperty(const CSSPropertyID);
 489 const char* getPropertyName(CSSPropertyID);
<span class="line-modified"> 490 const WTF::AtomicString&amp; getPropertyNameAtomicString(CSSPropertyID id);</span>
 491 WTF::String getPropertyNameString(CSSPropertyID id);
 492 WTF::String getJSPropertyName(CSSPropertyID);
 493 
 494 inline CSSPropertyID convertToCSSPropertyID(int value)
 495 {
 496     ASSERT((value &gt;= firstCSSProperty &amp;&amp; value &lt;= lastCSSProperty) || value == CSSPropertyInvalid || value == CSSPropertyCustom);
 497     return static_cast&lt;CSSPropertyID&gt;(value);
 498 }
 499 
 500 } // namespace WebCore
 501 
 502 namespace WTF {
 503 template&lt;&gt; struct DefaultHash&lt;WebCore::CSSPropertyID&gt; { typedef IntHash&lt;unsigned&gt; Hash; };
 504 template&lt;&gt; struct HashTraits&lt;WebCore::CSSPropertyID&gt; : GenericHashTraits&lt;WebCore::CSSPropertyID&gt; {
 505     static const bool emptyValueIsZero = true;
 506     static void constructDeletedValue(WebCore::CSSPropertyID&amp; slot) { slot = static_cast&lt;WebCore::CSSPropertyID&gt;(WebCore::lastCSSProperty + 1); }
 507     static bool isDeletedValue(WebCore::CSSPropertyID value) { return value == (WebCore::lastCSSProperty + 1); }
 508 };
 509 } // namespace WTF
 510 
</pre>
<hr />
<pre>
 794 }
 795 
 796 sub generateFillLayerPropertyInheritValueSetter {
 797   my $name = shift;
 798   my $indent = shift;
 799 
 800   my $getter = $propertiesWithStyleBuilderOptions{$name}{&quot;getter&quot;};
 801   my $setter = $propertiesWithStyleBuilderOptions{$name}{&quot;setter&quot;};
 802   my $clearFunction = getClearFunction($name);
 803   my $testFunction = getTestFunction($name);
 804 
 805   my $setterContent = &quot;&quot;;
 806   $setterContent .= $indent . &quot;// Check for no-op before copying anything.\n&quot;;
 807   $setterContent .= $indent . &quot;if (styleResolver.parentStyle()-&gt;&quot; . getLayersFunction($name) .&quot;() == styleResolver.style()-&gt;&quot; . getLayersFunction($name) . &quot;())\n&quot;;
 808   $setterContent .= $indent . &quot;    return;\n&quot;;
 809   $setterContent .= &quot;\n&quot;;
 810   $setterContent .= $indent . &quot;auto* child = &amp;styleResolver.style()-&gt;&quot; . getLayersAccessorFunction($name) . &quot;();\n&quot;;
 811   $setterContent .= $indent . &quot;FillLayer* previousChild = nullptr;\n&quot;;
 812   $setterContent .= $indent . &quot;for (auto* parent = &amp;styleResolver.parentStyle()-&gt;&quot; . getLayersFunction($name) . &quot;(); parent &amp;&amp; parent-&gt;&quot; . $testFunction . &quot;(); parent = parent-&gt;next()) {\n&quot;;
 813   $setterContent .= $indent . &quot;    if (!child) {\n&quot;;
<span class="line-modified"> 814   $setterContent .= $indent . &quot;        previousChild-&gt;setNext(std::make_unique&lt;FillLayer&gt;(&quot; . getFillLayerType($name) . &quot;));\n&quot;;</span>
 815   $setterContent .= $indent . &quot;        child = previousChild-&gt;next();\n&quot;;
 816   $setterContent .= $indent . &quot;    }\n&quot;;
 817   $setterContent .= $indent . &quot;    child-&gt;&quot; . $setter . &quot;(parent-&gt;&quot; . $getter . &quot;());\n&quot;;
 818   $setterContent .= $indent . &quot;    previousChild = child;\n&quot;;
 819   $setterContent .= $indent . &quot;    child = previousChild-&gt;next();\n&quot;;
 820   $setterContent .= $indent . &quot;}\n&quot;;
 821   $setterContent .= $indent . &quot;for (; child; child = child-&gt;next())\n&quot;;
 822   $setterContent .= $indent . &quot;    child-&gt;&quot; . $clearFunction . &quot;();\n&quot;;
 823 
 824   return $setterContent;
 825 }
 826 
 827 sub generateFillLayerPropertyValueSetter {
 828   my $name = shift;
 829   my $indent = shift;
 830 
 831   my $CSSPropertyId = &quot;CSSProperty&quot; . $nameToId{$name};
 832 
 833   my $setterContent = &quot;&quot;;
 834   $setterContent .= $indent . &quot;auto* child = &amp;styleResolver.style()-&gt;&quot; . getLayersAccessorFunction($name) . &quot;();\n&quot;;
 835   $setterContent .= $indent . &quot;FillLayer* previousChild = nullptr;\n&quot;;
 836   $setterContent .= $indent . &quot;if (is&lt;CSSValueList&gt;(value) &amp;&amp; !is&lt;CSSImageSetValue&gt;(value)) {\n&quot;;
 837   $setterContent .= $indent . &quot;    // Walk each value and put it into a layer, creating new layers as needed.\n&quot;;
 838   $setterContent .= $indent . &quot;    for (auto&amp; item : downcast&lt;CSSValueList&gt;(value)) {\n&quot;;
 839   $setterContent .= $indent . &quot;        if (!child) {\n&quot;;
<span class="line-modified"> 840   $setterContent .= $indent . &quot;            previousChild-&gt;setNext(std::make_unique&lt;FillLayer&gt;(&quot; . getFillLayerType($name) . &quot;));\n&quot;;</span>
 841   $setterContent .= $indent . &quot;            child = previousChild-&gt;next();\n&quot;;
 842   $setterContent .= $indent . &quot;        }\n&quot;;
 843   $setterContent .= $indent . &quot;        styleResolver.styleMap()-&gt;&quot; . getFillLayerMapfunction($name) . &quot;(&quot; . $CSSPropertyId . &quot;, *child, item);\n&quot;;
 844   $setterContent .= $indent . &quot;        previousChild = child;\n&quot;;
 845   $setterContent .= $indent . &quot;        child = child-&gt;next();\n&quot;;
 846   $setterContent .= $indent . &quot;    }\n&quot;;
 847   $setterContent .= $indent . &quot;} else {\n&quot;;
 848   $setterContent .= $indent . &quot;    styleResolver.styleMap()-&gt;&quot; . getFillLayerMapfunction($name) . &quot;(&quot; . $CSSPropertyId . &quot;, *child, value);\n&quot;;
 849   $setterContent .= $indent . &quot;    child = child-&gt;next();\n&quot;;
 850   $setterContent .= $indent . &quot;}\n&quot;;
 851   $setterContent .= $indent . &quot;for (; child; child = child-&gt;next())\n&quot;;
 852   $setterContent .= $indent . &quot;    child-&gt;&quot; . getClearFunction($name) . &quot;();\n&quot;;
 853 
 854   return $setterContent;
 855 }
 856 
 857 sub generateSetValueStatement
 858 {
 859   my $name = shift;
 860   my $value = shift;
</pre>
</td>
<td>
<hr />
<pre>
 231         return 1;
 232     }
 233     if (substr($a, 0, 1) ne &quot;-&quot; &amp;&amp; substr($b, 0, 1) eq &quot;-&quot;) {
 234         return -1;
 235     }
 236     return $a cmp $b;
 237 }
 238 
 239 @names = sort sortByDescendingPriorityAndName @names;
 240 
 241 open GPERF, &quot;&gt;CSSPropertyNames.gperf&quot; || die &quot;Could not open CSSPropertyNames.gperf for writing&quot;;
 242 print GPERF &lt;&lt; &quot;EOF&quot;;
 243 %{
 244 /* This file is automatically generated from $inputFile by makeprop, do not edit */
 245 #include &quot;config.h&quot;
 246 #include \&quot;CSSProperty.h\&quot;
 247 #include \&quot;CSSPropertyNames.h\&quot;
 248 #include \&quot;HashTools.h\&quot;
 249 #include &quot;RuntimeEnabledFeatures.h&quot;
 250 #include &lt;wtf/ASCIICType.h&gt;
<span class="line-modified"> 251 #include &lt;wtf/text/AtomString.h&gt;</span>
 252 #include &lt;wtf/text/WTFString.h&gt;
 253 #include &lt;string.h&gt;
 254 
 255 IGNORE_WARNINGS_BEGIN(\&quot;implicit-fallthrough\&quot;)
 256 
 257 // Older versions of gperf like to use the `register` keyword.
 258 #define register
 259 
 260 namespace WebCore {
 261 
 262 // Using std::numeric_limits&lt;uint16_t&gt;::max() here would be cleaner,
 263 // but is not possible due to missing constexpr support in MSVC 2013.
 264 static_assert(numCSSProperties + 1 &lt;= 65535, &quot;CSSPropertyID should fit into uint16_t.&quot;);
 265 
 266 EOF
 267 
 268 print GPERF &quot;const char* const propertyNameStrings[numCSSProperties] = {\n&quot;;
 269 foreach my $name (@names) {
 270   print GPERF &quot;    \&quot;$name\&quot;,\n&quot;;
 271 }
</pre>
<hr />
<pre>
 333   print GPERF &quot;    case CSSPropertyID::CSSProperty&quot; . $nameToId{$name} . &quot;:\n&quot;;
 334   print GPERF &quot;        return RuntimeEnabledFeatures::sharedFeatures().&quot; . $runtimeFlags{$name} . &quot;Enabled();\n&quot;;
 335 }
 336 
 337 print GPERF &lt;&lt; &quot;EOF&quot;;
 338     default:
 339         return true;
 340     }
 341 }
 342 
 343 const char* getPropertyName(CSSPropertyID id)
 344 {
 345     if (id &lt; firstCSSProperty)
 346         return 0;
 347     int index = id - firstCSSProperty;
 348     if (index &gt;= numCSSProperties)
 349         return 0;
 350     return propertyNameStrings[index];
 351 }
 352 
<span class="line-modified"> 353 const AtomString&amp; getPropertyNameAtomString(CSSPropertyID id)</span>
 354 {
 355     if (id &lt; firstCSSProperty)
 356         return nullAtom();
 357     int index = id - firstCSSProperty;
 358     if (index &gt;= numCSSProperties)
 359         return nullAtom();
 360 
<span class="line-modified"> 361     static AtomString* propertyStrings = new AtomString[numCSSProperties]; // Intentionally never destroyed.</span>
<span class="line-modified"> 362     AtomString&amp; propertyString = propertyStrings[index];</span>
 363     if (propertyString.isNull()) {
 364         const char* propertyName = propertyNameStrings[index];
<span class="line-modified"> 365         propertyString = AtomString(propertyName, strlen(propertyName), AtomString::ConstructFromLiteral);</span>
 366     }
 367     return propertyString;
 368 }
 369 
 370 String getPropertyNameString(CSSPropertyID id)
 371 {
<span class="line-modified"> 372     // We share the StringImpl with the AtomStrings.</span>
<span class="line-modified"> 373     return getPropertyNameAtomString(id).string();</span>
 374 }
 375 
 376 String getJSPropertyName(CSSPropertyID id)
 377 {
 378     char result[maxCSSPropertyNameLength + 1];
 379     const char* cssPropertyName = getPropertyName(id);
 380     const char* propertyNamePointer = cssPropertyName;
 381     if (!propertyNamePointer)
 382         return emptyString();
 383 
 384     char* resultPointer = result;
 385     while (char character = *propertyNamePointer++) {
 386         if (character == &#39;-&#39;) {
 387             char nextCharacter = *propertyNamePointer++;
 388             if (!nextCharacter)
 389                 break;
 390             character = (propertyNamePointer - 2 != cssPropertyName) ? toASCIIUpper(nextCharacter) : nextCharacter;
 391         }
 392         *resultPointer++ = character;
 393     }
</pre>
<hr />
<pre>
 470   $i = $i + 1;
 471   if (length($name) &gt; $maxLen) {
 472     $maxLen = length($name);
 473   }
 474 }
 475 my $num = $i - $first;
 476 my $last = $i - 1;
 477 
 478 print HEADER &quot;};\n\n&quot;;
 479 print HEADER &quot;const int firstCSSProperty = $first;\n&quot;;
 480 print HEADER &quot;const int numCSSProperties = $num;\n&quot;;
 481 print HEADER &quot;const int lastCSSProperty = $last;\n&quot;;
 482 print HEADER &quot;const size_t maxCSSPropertyNameLength = $maxLen;\n&quot;;
 483 print HEADER &quot;const CSSPropertyID lastHighPriorityProperty = CSSProperty&quot; . $nameToId{$lastHighPriorityPropertyName} . &quot;;\n&quot;;
 484 
 485 print HEADER &lt;&lt; &quot;EOF&quot;;
 486 
 487 bool isInternalCSSProperty(const CSSPropertyID);
 488 bool isEnabledCSSProperty(const CSSPropertyID);
 489 const char* getPropertyName(CSSPropertyID);
<span class="line-modified"> 490 const WTF::AtomString&amp; getPropertyNameAtomString(CSSPropertyID id);</span>
 491 WTF::String getPropertyNameString(CSSPropertyID id);
 492 WTF::String getJSPropertyName(CSSPropertyID);
 493 
 494 inline CSSPropertyID convertToCSSPropertyID(int value)
 495 {
 496     ASSERT((value &gt;= firstCSSProperty &amp;&amp; value &lt;= lastCSSProperty) || value == CSSPropertyInvalid || value == CSSPropertyCustom);
 497     return static_cast&lt;CSSPropertyID&gt;(value);
 498 }
 499 
 500 } // namespace WebCore
 501 
 502 namespace WTF {
 503 template&lt;&gt; struct DefaultHash&lt;WebCore::CSSPropertyID&gt; { typedef IntHash&lt;unsigned&gt; Hash; };
 504 template&lt;&gt; struct HashTraits&lt;WebCore::CSSPropertyID&gt; : GenericHashTraits&lt;WebCore::CSSPropertyID&gt; {
 505     static const bool emptyValueIsZero = true;
 506     static void constructDeletedValue(WebCore::CSSPropertyID&amp; slot) { slot = static_cast&lt;WebCore::CSSPropertyID&gt;(WebCore::lastCSSProperty + 1); }
 507     static bool isDeletedValue(WebCore::CSSPropertyID value) { return value == (WebCore::lastCSSProperty + 1); }
 508 };
 509 } // namespace WTF
 510 
</pre>
<hr />
<pre>
 794 }
 795 
 796 sub generateFillLayerPropertyInheritValueSetter {
 797   my $name = shift;
 798   my $indent = shift;
 799 
 800   my $getter = $propertiesWithStyleBuilderOptions{$name}{&quot;getter&quot;};
 801   my $setter = $propertiesWithStyleBuilderOptions{$name}{&quot;setter&quot;};
 802   my $clearFunction = getClearFunction($name);
 803   my $testFunction = getTestFunction($name);
 804 
 805   my $setterContent = &quot;&quot;;
 806   $setterContent .= $indent . &quot;// Check for no-op before copying anything.\n&quot;;
 807   $setterContent .= $indent . &quot;if (styleResolver.parentStyle()-&gt;&quot; . getLayersFunction($name) .&quot;() == styleResolver.style()-&gt;&quot; . getLayersFunction($name) . &quot;())\n&quot;;
 808   $setterContent .= $indent . &quot;    return;\n&quot;;
 809   $setterContent .= &quot;\n&quot;;
 810   $setterContent .= $indent . &quot;auto* child = &amp;styleResolver.style()-&gt;&quot; . getLayersAccessorFunction($name) . &quot;();\n&quot;;
 811   $setterContent .= $indent . &quot;FillLayer* previousChild = nullptr;\n&quot;;
 812   $setterContent .= $indent . &quot;for (auto* parent = &amp;styleResolver.parentStyle()-&gt;&quot; . getLayersFunction($name) . &quot;(); parent &amp;&amp; parent-&gt;&quot; . $testFunction . &quot;(); parent = parent-&gt;next()) {\n&quot;;
 813   $setterContent .= $indent . &quot;    if (!child) {\n&quot;;
<span class="line-modified"> 814   $setterContent .= $indent . &quot;        previousChild-&gt;setNext(makeUnique&lt;FillLayer&gt;(&quot; . getFillLayerType($name) . &quot;));\n&quot;;</span>
 815   $setterContent .= $indent . &quot;        child = previousChild-&gt;next();\n&quot;;
 816   $setterContent .= $indent . &quot;    }\n&quot;;
 817   $setterContent .= $indent . &quot;    child-&gt;&quot; . $setter . &quot;(parent-&gt;&quot; . $getter . &quot;());\n&quot;;
 818   $setterContent .= $indent . &quot;    previousChild = child;\n&quot;;
 819   $setterContent .= $indent . &quot;    child = previousChild-&gt;next();\n&quot;;
 820   $setterContent .= $indent . &quot;}\n&quot;;
 821   $setterContent .= $indent . &quot;for (; child; child = child-&gt;next())\n&quot;;
 822   $setterContent .= $indent . &quot;    child-&gt;&quot; . $clearFunction . &quot;();\n&quot;;
 823 
 824   return $setterContent;
 825 }
 826 
 827 sub generateFillLayerPropertyValueSetter {
 828   my $name = shift;
 829   my $indent = shift;
 830 
 831   my $CSSPropertyId = &quot;CSSProperty&quot; . $nameToId{$name};
 832 
 833   my $setterContent = &quot;&quot;;
 834   $setterContent .= $indent . &quot;auto* child = &amp;styleResolver.style()-&gt;&quot; . getLayersAccessorFunction($name) . &quot;();\n&quot;;
 835   $setterContent .= $indent . &quot;FillLayer* previousChild = nullptr;\n&quot;;
 836   $setterContent .= $indent . &quot;if (is&lt;CSSValueList&gt;(value) &amp;&amp; !is&lt;CSSImageSetValue&gt;(value)) {\n&quot;;
 837   $setterContent .= $indent . &quot;    // Walk each value and put it into a layer, creating new layers as needed.\n&quot;;
 838   $setterContent .= $indent . &quot;    for (auto&amp; item : downcast&lt;CSSValueList&gt;(value)) {\n&quot;;
 839   $setterContent .= $indent . &quot;        if (!child) {\n&quot;;
<span class="line-modified"> 840   $setterContent .= $indent . &quot;            previousChild-&gt;setNext(makeUnique&lt;FillLayer&gt;(&quot; . getFillLayerType($name) . &quot;));\n&quot;;</span>
 841   $setterContent .= $indent . &quot;            child = previousChild-&gt;next();\n&quot;;
 842   $setterContent .= $indent . &quot;        }\n&quot;;
 843   $setterContent .= $indent . &quot;        styleResolver.styleMap()-&gt;&quot; . getFillLayerMapfunction($name) . &quot;(&quot; . $CSSPropertyId . &quot;, *child, item);\n&quot;;
 844   $setterContent .= $indent . &quot;        previousChild = child;\n&quot;;
 845   $setterContent .= $indent . &quot;        child = child-&gt;next();\n&quot;;
 846   $setterContent .= $indent . &quot;    }\n&quot;;
 847   $setterContent .= $indent . &quot;} else {\n&quot;;
 848   $setterContent .= $indent . &quot;    styleResolver.styleMap()-&gt;&quot; . getFillLayerMapfunction($name) . &quot;(&quot; . $CSSPropertyId . &quot;, *child, value);\n&quot;;
 849   $setterContent .= $indent . &quot;    child = child-&gt;next();\n&quot;;
 850   $setterContent .= $indent . &quot;}\n&quot;;
 851   $setterContent .= $indent . &quot;for (; child; child = child-&gt;next())\n&quot;;
 852   $setterContent .= $indent . &quot;    child-&gt;&quot; . getClearFunction($name) . &quot;();\n&quot;;
 853 
 854   return $setterContent;
 855 }
 856 
 857 sub generateSetValueStatement
 858 {
 859   my $name = shift;
 860   my $value = shift;
</pre>
</td>
</tr>
</table>
<center><a href="makeSelectorPseudoElementsMap.py.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="makevalues.pl.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>