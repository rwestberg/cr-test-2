<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/page/animation/CSSPropertyAnimation.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2007, 2008, 2009, 2013, 2016 Apple Inc. All rights reserved.
   3  * Copyright (C) 2012, 2013 Adobe Systems Incorporated. All rights reserved.
   4  *
   5  * Redistribution and use in source and binary forms, with or without
   6  * modification, are permitted provided that the following conditions
   7  * are met:
   8  *
   9  * 1.  Redistributions of source code must retain the above copyright
  10  *     notice, this list of conditions and the following disclaimer.
  11  * 2.  Redistributions in binary form must reproduce the above copyright
  12  *     notice, this list of conditions and the following disclaimer in the
  13  *     documentation and/or other materials provided with the distribution.
  14  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
  15  *     its contributors may be used to endorse or promote products derived
  16  *     from this software without specific prior written permission.
  17  *
  18  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
  19  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  20  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  21  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  22  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  23  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  24  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  25  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  26  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  27  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  28  */
  29 
  30 #include &quot;config.h&quot;
  31 #include &quot;CSSPropertyAnimation.h&quot;
  32 
  33 #include &quot;CSSComputedStyleDeclaration.h&quot;
  34 #include &quot;CSSCrossfadeValue.h&quot;
  35 #include &quot;CSSFilterImageValue.h&quot;
  36 #include &quot;CSSImageGeneratorValue.h&quot;
  37 #include &quot;CSSImageValue.h&quot;
  38 #include &quot;CSSPrimitiveValue.h&quot;
  39 #include &quot;CSSPropertyBlendingClient.h&quot;
  40 #include &quot;CSSPropertyNames.h&quot;
  41 #include &quot;CachedImage.h&quot;
  42 #include &quot;CalculationValue.h&quot;
  43 #include &quot;ClipPathOperation.h&quot;
  44 #include &quot;FloatConversion.h&quot;
  45 #include &quot;FontCascade.h&quot;
  46 #include &quot;FontSelectionAlgorithm.h&quot;
  47 #include &quot;FontTaggedSettings.h&quot;
  48 #include &quot;GapLength.h&quot;
  49 #include &quot;IdentityTransformOperation.h&quot;
  50 #include &quot;Logging.h&quot;
  51 #include &quot;Matrix3DTransformOperation.h&quot;
  52 #include &quot;MatrixTransformOperation.h&quot;
  53 #include &quot;RenderBox.h&quot;
  54 #include &quot;RenderStyle.h&quot;
  55 #include &quot;StyleCachedImage.h&quot;
  56 #include &quot;StyleGeneratedImage.h&quot;
  57 #include &quot;StylePropertyShorthand.h&quot;
  58 #include &quot;StyleResolver.h&quot;
  59 #include &lt;algorithm&gt;
  60 #include &lt;memory&gt;
  61 #include &lt;wtf/MathExtras.h&gt;
  62 #include &lt;wtf/NeverDestroyed.h&gt;
  63 #include &lt;wtf/Noncopyable.h&gt;
  64 #include &lt;wtf/PointerComparison.h&gt;
  65 #include &lt;wtf/RefCounted.h&gt;
  66 #include &lt;wtf/text/TextStream.h&gt;
  67 
  68 namespace WebCore {
  69 
  70 static inline int blendFunc(const CSSPropertyBlendingClient*, int from, int to, double progress)
  71 {
  72     return blend(from, to, progress);
  73 }
  74 
  75 static inline double blendFunc(const CSSPropertyBlendingClient*, double from, double to, double progress)
  76 {
  77     return blend(from, to, progress);
  78 }
  79 
  80 static inline float blendFunc(const CSSPropertyBlendingClient*, float from, float to, double progress)
  81 {
  82     return narrowPrecisionToFloat(from + (to - from) * progress);
  83 }
  84 
  85 static inline Color blendFunc(const CSSPropertyBlendingClient*, const Color&amp; from, const Color&amp; to, double progress)
  86 {
  87     return blend(from, to, progress);
  88 }
  89 
  90 static inline Length blendFunc(const CSSPropertyBlendingClient*, const Length&amp; from, const Length&amp; to, double progress)
  91 {
  92     return blend(from, to, progress);
  93 }
  94 
  95 static inline GapLength blendFunc(const CSSPropertyBlendingClient*, const GapLength&amp; from, const GapLength&amp; to, double progress)
  96 {
  97     return (from.isNormal() || to.isNormal()) ? to : blend(from.length(), to.length(), progress);
  98 }
  99 
 100 static inline LengthSize blendFunc(const CSSPropertyBlendingClient* anim, const LengthSize&amp; from, const LengthSize&amp; to, double progress)
 101 {
 102     return { blendFunc(anim, from.width, to.width, progress), blendFunc(anim, from.height, to.height, progress) };
 103 }
 104 
 105 static inline ShadowStyle blendFunc(const CSSPropertyBlendingClient* anim, ShadowStyle from, ShadowStyle to, double progress)
 106 {
 107     if (from == to)
 108         return to;
 109 
 110     double fromVal = from == Normal ? 1 : 0;
 111     double toVal = to == Normal ? 1 : 0;
 112     double result = blendFunc(anim, fromVal, toVal, progress);
 113     return result &gt; 0 ? Normal : Inset;
 114 }
 115 
 116 static inline std::unique_ptr&lt;ShadowData&gt; blendFunc(const CSSPropertyBlendingClient* anim, const ShadowData* from, const ShadowData* to, double progress)
 117 {
 118     ASSERT(from &amp;&amp; to);
 119     if (from-&gt;style() != to-&gt;style())
<a name="1" id="anc1"></a><span class="line-modified"> 120         return std::make_unique&lt;ShadowData&gt;(*to);</span>
 121 
<a name="2" id="anc2"></a><span class="line-modified"> 122     return std::make_unique&lt;ShadowData&gt;(blend(from-&gt;location(), to-&gt;location(), progress),</span>
 123         blend(from-&gt;radius(), to-&gt;radius(), progress),
 124         blend(from-&gt;spread(), to-&gt;spread(), progress),
 125         blendFunc(anim, from-&gt;style(), to-&gt;style(), progress),
 126         from-&gt;isWebkitBoxShadow(),
 127         blend(from-&gt;color(), to-&gt;color(), progress));
 128 }
 129 
 130 static inline TransformOperations blendFunc(const CSSPropertyBlendingClient* animation, const TransformOperations&amp; from, const TransformOperations&amp; to, double progress)
 131 {
 132     if (animation-&gt;transformFunctionListsMatch())
 133         return to.blendByMatchingOperations(from, progress);
 134     return to.blendByUsingMatrixInterpolation(from, progress, is&lt;RenderBox&gt;(animation-&gt;renderer()) ? downcast&lt;RenderBox&gt;(*animation-&gt;renderer()).borderBoxRect().size() : LayoutSize());
 135 }
 136 
 137 static inline RefPtr&lt;ClipPathOperation&gt; blendFunc(const CSSPropertyBlendingClient*, ClipPathOperation* from, ClipPathOperation* to, double progress)
 138 {
 139     if (!from || !to)
 140         return to;
 141 
 142     // Other clip-path operations than BasicShapes can not be animated.
 143     if (from-&gt;type() != ClipPathOperation::Shape || to-&gt;type() != ClipPathOperation::Shape)
 144         return to;
 145 
 146     const BasicShape&amp; fromShape = downcast&lt;ShapeClipPathOperation&gt;(*from).basicShape();
 147     const BasicShape&amp; toShape = downcast&lt;ShapeClipPathOperation&gt;(*to).basicShape();
 148 
 149     if (!fromShape.canBlend(toShape))
 150         return to;
 151 
 152     return ShapeClipPathOperation::create(toShape.blend(fromShape, progress));
 153 }
 154 
 155 static inline RefPtr&lt;ShapeValue&gt; blendFunc(const CSSPropertyBlendingClient*, ShapeValue* from, ShapeValue* to, double progress)
 156 {
 157     if (!from || !to)
 158         return to;
 159 
 160     if (from-&gt;type() != ShapeValue::Type::Shape || to-&gt;type() != ShapeValue::Type::Shape)
 161         return to;
 162 
 163     if (from-&gt;cssBox() != to-&gt;cssBox())
 164         return to;
 165 
 166     const BasicShape&amp; fromShape = *from-&gt;shape();
 167     const BasicShape&amp; toShape = *to-&gt;shape();
 168 
 169     if (!fromShape.canBlend(toShape))
 170         return to;
 171 
 172     return ShapeValue::create(toShape.blend(fromShape, progress), to-&gt;cssBox());
 173 }
 174 
 175 static inline RefPtr&lt;FilterOperation&gt; blendFunc(const CSSPropertyBlendingClient*, FilterOperation* fromOp, FilterOperation* toOp, double progress, bool blendToPassthrough = false)
 176 {
 177     ASSERT(toOp);
 178     return toOp-&gt;blend(fromOp, progress, blendToPassthrough);
 179 }
 180 
 181 static inline FilterOperations blendFilterOperations(const CSSPropertyBlendingClient* anim,  const FilterOperations&amp; from, const FilterOperations&amp; to, double progress)
 182 {
 183     FilterOperations result;
 184     size_t fromSize = from.operations().size();
 185     size_t toSize = to.operations().size();
 186     size_t size = std::max(fromSize, toSize);
 187     for (size_t i = 0; i &lt; size; i++) {
 188         RefPtr&lt;FilterOperation&gt; fromOp = (i &lt; fromSize) ? from.operations()[i].get() : 0;
 189         RefPtr&lt;FilterOperation&gt; toOp = (i &lt; toSize) ? to.operations()[i].get() : 0;
 190         RefPtr&lt;FilterOperation&gt; blendedOp = toOp ? blendFunc(anim, fromOp.get(), toOp.get(), progress) : (fromOp ? blendFunc(anim, 0, fromOp.get(), progress, true) : 0);
 191         if (blendedOp)
 192             result.operations().append(blendedOp);
 193         else {
 194             auto identityOp = PassthroughFilterOperation::create();
 195             if (progress &gt; 0.5)
 196                 result.operations().append(toOp ? toOp : WTFMove(identityOp));
 197             else
 198                 result.operations().append(fromOp ? fromOp : WTFMove(identityOp));
 199         }
 200     }
 201     return result;
 202 }
 203 
 204 static inline FilterOperations blendFunc(const CSSPropertyBlendingClient* anim, const FilterOperations&amp; from, const FilterOperations&amp; to, double progress, CSSPropertyID propertyID = CSSPropertyFilter)
 205 {
 206     FilterOperations result;
 207 
 208     // If we have a filter function list, use that to do a per-function animation.
 209 
 210     bool listsMatch = false;
 211     switch (propertyID) {
 212     case CSSPropertyFilter:
 213         listsMatch = anim-&gt;filterFunctionListsMatch();
 214         break;
 215 #if ENABLE(FILTERS_LEVEL_2)
 216     case CSSPropertyWebkitBackdropFilter:
 217         listsMatch = anim-&gt;backdropFilterFunctionListsMatch();
 218         break;
 219 #endif
 220     case CSSPropertyAppleColorFilter:
 221         listsMatch = anim-&gt;colorFilterFunctionListsMatch();
 222         break;
 223     default:
 224         break;
 225     }
 226 
 227     if (listsMatch)
 228         result = blendFilterOperations(anim, from, to, progress);
 229     else {
 230         // If the filter function lists don&#39;t match, we could try to cross-fade, but don&#39;t yet have a way to represent that in CSS.
 231         // For now we&#39;ll just fail to animate.
 232         result = to;
 233     }
 234 
 235     return result;
 236 }
 237 
 238 static inline RefPtr&lt;StyleImage&gt; blendFilter(const CSSPropertyBlendingClient* anim, CachedImage* image, const FilterOperations&amp; from, const FilterOperations&amp; to, double progress)
 239 {
 240     ASSERT(image);
 241     FilterOperations filterResult = blendFilterOperations(anim, from, to, progress);
 242 
 243     auto imageValue = CSSImageValue::create(*image);
 244     auto filterValue = ComputedStyleExtractor::valueForFilter(anim-&gt;currentStyle(), filterResult, DoNotAdjustPixelValues);
 245 
 246     auto result = CSSFilterImageValue::create(WTFMove(imageValue), WTFMove(filterValue));
 247     result.get().setFilterOperations(filterResult);
 248     return StyleGeneratedImage::create(WTFMove(result));
 249 }
 250 
 251 static inline Visibility blendFunc(const CSSPropertyBlendingClient* anim, Visibility from, Visibility to, double progress)
 252 {
 253     // Any non-zero result means we consider the object to be visible. Only at 0 do we consider the object to be
 254     // invisible. The invisible value we use (Visibility::Hidden vs. Visibility::Collapse) depends on the specified from/to values.
 255     double fromVal = from == Visibility::Visible ? 1. : 0.;
 256     double toVal = to == Visibility::Visible ? 1. : 0.;
 257     if (fromVal == toVal)
 258         return to;
 259     double result = blendFunc(anim, fromVal, toVal, progress);
 260     return result &gt; 0. ? Visibility::Visible : (to != Visibility::Visible ? to : from);
 261 }
 262 
 263 static inline TextUnderlineOffset blendFunc(const CSSPropertyBlendingClient* anim, const TextUnderlineOffset&amp; from, const TextUnderlineOffset&amp; to, double progress)
 264 {
 265     if (from.isLength() &amp;&amp; to.isLength())
 266         return TextUnderlineOffset::createWithLength(blendFunc(anim, from.lengthValue(), to.lengthValue(), progress));
 267     return TextUnderlineOffset::createWithAuto();
 268 }
 269 
 270 static inline TextDecorationThickness blendFunc(const CSSPropertyBlendingClient* anim, const TextDecorationThickness&amp; from, const TextDecorationThickness&amp; to, double progress)
 271 {
 272     if (from.isLength() &amp;&amp; to.isLength())
 273         return TextDecorationThickness::createWithLength(blendFunc(anim, from.lengthValue(), to.lengthValue(), progress));
 274     return TextDecorationThickness::createWithAuto();
 275 }
 276 
 277 static inline LengthBox blendFunc(const CSSPropertyBlendingClient* anim, const LengthBox&amp; from, const LengthBox&amp; to, double progress)
 278 {
 279     LengthBox result(blendFunc(anim, from.top(), to.top(), progress),
 280                      blendFunc(anim, from.right(), to.right(), progress),
 281                      blendFunc(anim, from.bottom(), to.bottom(), progress),
 282                      blendFunc(anim, from.left(), to.left(), progress));
 283     return result;
 284 }
 285 
 286 static inline SVGLengthValue blendFunc(const CSSPropertyBlendingClient*, const SVGLengthValue&amp; from, const SVGLengthValue&amp; to, double progress)
 287 {
 288     return to.blend(from, narrowPrecisionToFloat(progress));
 289 }
 290 
 291 static inline Vector&lt;SVGLengthValue&gt; blendFunc(const CSSPropertyBlendingClient*, const Vector&lt;SVGLengthValue&gt;&amp; from, const Vector&lt;SVGLengthValue&gt;&amp; to, double progress)
 292 {
 293     size_t fromLength = from.size();
 294     size_t toLength = to.size();
 295     if (!fromLength)
 296         return !progress ? from : to;
 297     if (!toLength)
 298         return progress == 1 ? from : to;
 299     size_t resultLength = fromLength;
 300     if (fromLength != toLength) {
 301         if (!remainder(std::max(fromLength, toLength), std::min(fromLength, toLength)))
 302             resultLength = std::max(fromLength, toLength);
 303         else
 304             resultLength = fromLength * toLength;
 305     }
 306     Vector&lt;SVGLengthValue&gt; result(resultLength);
 307     for (size_t i = 0; i &lt; resultLength; ++i)
 308         result[i] = to[i % toLength].blend(from[i % fromLength], narrowPrecisionToFloat(progress));
 309     return result;
 310 }
 311 
 312 static inline RefPtr&lt;StyleImage&gt; crossfadeBlend(const CSSPropertyBlendingClient*, StyleCachedImage* fromStyleImage, StyleCachedImage* toStyleImage, double progress)
 313 {
 314     // If progress is at one of the extremes, we want getComputedStyle to show the image,
 315     // not a completed cross-fade, so we hand back one of the existing images.
 316     if (!progress)
 317         return fromStyleImage;
 318     if (progress == 1)
 319         return toStyleImage;
 320     if (!fromStyleImage-&gt;cachedImage() || !toStyleImage-&gt;cachedImage())
 321         return toStyleImage;
 322 
 323     auto fromImageValue = CSSImageValue::create(*fromStyleImage-&gt;cachedImage());
 324     auto toImageValue = CSSImageValue::create(*toStyleImage-&gt;cachedImage());
 325     auto percentageValue = CSSPrimitiveValue::create(progress, CSSPrimitiveValue::CSS_NUMBER);
 326 
 327     auto crossfadeValue = CSSCrossfadeValue::create(WTFMove(fromImageValue), WTFMove(toImageValue), WTFMove(percentageValue));
 328     return StyleGeneratedImage::create(WTFMove(crossfadeValue));
 329 }
 330 
 331 static inline RefPtr&lt;StyleImage&gt; blendFunc(const CSSPropertyBlendingClient* anim, StyleImage* from, StyleImage* to, double progress)
 332 {
 333     if (!from || !to)
 334         return to;
 335 
 336     // Animation between two generated images. Cross fade for all other cases.
 337     if (is&lt;StyleGeneratedImage&gt;(*from) &amp;&amp; is&lt;StyleGeneratedImage&gt;(*to)) {
 338         CSSImageGeneratorValue&amp; fromGenerated = downcast&lt;StyleGeneratedImage&gt;(*from).imageValue();
 339         CSSImageGeneratorValue&amp; toGenerated = downcast&lt;StyleGeneratedImage&gt;(*to).imageValue();
 340 
 341         if (is&lt;CSSFilterImageValue&gt;(fromGenerated) &amp;&amp; is&lt;CSSFilterImageValue&gt;(toGenerated)) {
 342             // Animation of generated images just possible if input images are equal.
 343             // Otherwise fall back to cross fade animation.
 344             CSSFilterImageValue&amp; fromFilter = downcast&lt;CSSFilterImageValue&gt;(fromGenerated);
 345             CSSFilterImageValue&amp; toFilter = downcast&lt;CSSFilterImageValue&gt;(toGenerated);
 346             if (fromFilter.equalInputImages(toFilter) &amp;&amp; fromFilter.cachedImage())
 347                 return blendFilter(anim, fromFilter.cachedImage(), fromFilter.filterOperations(), toFilter.filterOperations(), progress);
 348         }
 349 
 350         if (is&lt;CSSCrossfadeValue&gt;(fromGenerated) &amp;&amp; is&lt;CSSCrossfadeValue&gt;(toGenerated)) {
 351             CSSCrossfadeValue&amp; fromCrossfade = downcast&lt;CSSCrossfadeValue&gt;(fromGenerated);
 352             CSSCrossfadeValue&amp; toCrossfade = downcast&lt;CSSCrossfadeValue&gt;(toGenerated);
 353             if (fromCrossfade.equalInputImages(toCrossfade)) {
 354                 if (auto crossfadeBlend = toCrossfade.blend(fromCrossfade, progress))
 355                     return StyleGeneratedImage::create(*crossfadeBlend);
 356             }
 357         }
 358 
 359         // FIXME: Add support for animation between two *gradient() functions.
 360         // https://bugs.webkit.org/show_bug.cgi?id=119956
 361     } else if (is&lt;StyleGeneratedImage&gt;(*from) &amp;&amp; is&lt;StyleCachedImage&gt;(*to)) {
 362         CSSImageGeneratorValue&amp; fromGenerated = downcast&lt;StyleGeneratedImage&gt;(*from).imageValue();
 363         if (is&lt;CSSFilterImageValue&gt;(fromGenerated)) {
 364             CSSFilterImageValue&amp; fromFilter = downcast&lt;CSSFilterImageValue&gt;(fromGenerated);
 365             if (fromFilter.cachedImage() &amp;&amp; downcast&lt;StyleCachedImage&gt;(*to).cachedImage() == fromFilter.cachedImage())
 366                 return blendFilter(anim, fromFilter.cachedImage(), fromFilter.filterOperations(), FilterOperations(), progress);
 367         }
 368         // FIXME: Add interpolation between cross-fade and image source.
 369     } else if (is&lt;StyleCachedImage&gt;(*from) &amp;&amp; is&lt;StyleGeneratedImage&gt;(*to)) {
 370         CSSImageGeneratorValue&amp; toGenerated = downcast&lt;StyleGeneratedImage&gt;(*to).imageValue();
 371         if (is&lt;CSSFilterImageValue&gt;(toGenerated)) {
 372             CSSFilterImageValue&amp; toFilter = downcast&lt;CSSFilterImageValue&gt;(toGenerated);
 373             if (toFilter.cachedImage() &amp;&amp; downcast&lt;StyleCachedImage&gt;(*from).cachedImage() == toFilter.cachedImage())
 374                 return blendFilter(anim, toFilter.cachedImage(), FilterOperations(), toFilter.filterOperations(), progress);
 375         }
 376         // FIXME: Add interpolation between image source and cross-fade.
 377     }
 378 
 379     // FIXME: Add support cross fade between cached and generated images.
 380     // https://bugs.webkit.org/show_bug.cgi?id=78293
 381     if (is&lt;StyleCachedImage&gt;(*from) &amp;&amp; is&lt;StyleCachedImage&gt;(*to))
 382         return crossfadeBlend(anim, downcast&lt;StyleCachedImage&gt;(from), downcast&lt;StyleCachedImage&gt;(to), progress);
 383 
 384     return to;
 385 }
 386 
 387 static inline NinePieceImage blendFunc(const CSSPropertyBlendingClient* anim, const NinePieceImage&amp; from, const NinePieceImage&amp; to, double progress)
 388 {
 389     if (!from.hasImage() || !to.hasImage())
 390         return to;
 391 
 392     // FIXME (74112): Support transitioning between NinePieceImages that differ by more than image content.
 393 
 394     if (from.imageSlices() != to.imageSlices() || from.borderSlices() != to.borderSlices() || from.outset() != to.outset() || from.fill() != to.fill() || from.horizontalRule() != to.horizontalRule() || from.verticalRule() != to.verticalRule())
 395         return to;
 396 
 397     if (auto* renderer = anim-&gt;renderer()) {
 398         if (from.image()-&gt;imageSize(renderer, 1.0) != to.image()-&gt;imageSize(renderer, 1.0))
 399             return to;
 400     }
 401 
 402     return NinePieceImage(blendFunc(anim, from.image(), to.image(), progress),
 403         from.imageSlices(), from.fill(), from.borderSlices(), from.outset(), from.horizontalRule(), from.verticalRule());
 404 }
 405 
 406 #if ENABLE(VARIATION_FONTS)
 407 
 408 static inline FontVariationSettings blendFunc(const CSSPropertyBlendingClient* anim, const FontVariationSettings&amp; from, const FontVariationSettings&amp; to, double progress)
 409 {
 410     if (from.size() != to.size())
 411         return FontVariationSettings();
 412     FontVariationSettings result;
 413     unsigned size = from.size();
 414     for (unsigned i = 0; i &lt; size; ++i) {
 415         auto&amp; fromItem = from.at(i);
 416         auto&amp; toItem = to.at(i);
 417         if (fromItem.tag() != toItem.tag())
 418             return FontVariationSettings();
 419         float interpolated = blendFunc(anim, fromItem.value(), toItem.value(), progress);
 420         result.insert({ fromItem.tag(), interpolated });
 421     }
 422     return result;
 423 }
 424 
 425 #endif
 426 
 427 static inline FontSelectionValue blendFunc(const CSSPropertyBlendingClient* anim, FontSelectionValue from, FontSelectionValue to, double progress)
 428 {
 429     return FontSelectionValue(blendFunc(anim, static_cast&lt;float&gt;(from), static_cast&lt;float&gt;(to), progress));
 430 }
 431 
 432 static inline Optional&lt;FontSelectionValue&gt; blendFunc(const CSSPropertyBlendingClient* anim, Optional&lt;FontSelectionValue&gt; from, Optional&lt;FontSelectionValue&gt; to, double progress)
 433 {
 434     return FontSelectionValue(blendFunc(anim, static_cast&lt;float&gt;(from.value()), static_cast&lt;float&gt;(to.value()), progress));
 435 }
 436 
 437 class AnimationPropertyWrapperBase {
 438     WTF_MAKE_NONCOPYABLE(AnimationPropertyWrapperBase);
 439     WTF_MAKE_FAST_ALLOCATED;
 440 public:
<a name="3" id="anc3"></a><span class="line-modified"> 441     AnimationPropertyWrapperBase(CSSPropertyID prop)</span>
 442         : m_prop(prop)
 443     {
 444     }
 445     virtual ~AnimationPropertyWrapperBase() = default;
 446 
 447     virtual bool isShorthandWrapper() const { return false; }
 448     virtual bool equals(const RenderStyle* a, const RenderStyle* b) const = 0;
 449     virtual bool canInterpolate(const RenderStyle*, const RenderStyle*) const { return true; }
 450     virtual void blend(const CSSPropertyBlendingClient*, RenderStyle*, const RenderStyle*, const RenderStyle*, double) const = 0;
 451 
 452 #if !LOG_DISABLED
 453     virtual void logBlend(const RenderStyle* a, const RenderStyle* b, const RenderStyle* result, double) const = 0;
 454 #endif
 455 
 456     CSSPropertyID property() const { return m_prop; }
 457 
 458     virtual bool animationIsAccelerated() const { return false; }
 459 
 460 private:
 461     CSSPropertyID m_prop;
 462 };
 463 
 464 template &lt;typename T&gt;
 465 class PropertyWrapperGetter : public AnimationPropertyWrapperBase {
 466     WTF_MAKE_FAST_ALLOCATED;
 467 public:
 468     PropertyWrapperGetter(CSSPropertyID prop, T (RenderStyle::*getter)() const)
 469         : AnimationPropertyWrapperBase(prop)
 470         , m_getter(getter)
 471     {
 472     }
 473 
 474     bool equals(const RenderStyle* a, const RenderStyle* b) const override
 475     {
 476         if (a == b)
 477             return true;
 478         if (!a || !b)
 479             return false;
 480         return (a-&gt;*m_getter)() == (b-&gt;*m_getter)();
 481     }
 482 
 483     T value(const RenderStyle* a) const
 484     {
 485         return (a-&gt;*m_getter)();
 486     }
 487 
 488 #if !LOG_DISABLED
 489     void logBlend(const RenderStyle* a, const RenderStyle* b, const RenderStyle* result, double progress) const final
 490     {
 491         LOG_WITH_STREAM(Animations, stream &lt;&lt; &quot;  blending &quot; &lt;&lt; getPropertyName(property()) &lt;&lt; &quot; from &quot; &lt;&lt; value(a) &lt;&lt; &quot; to &quot; &lt;&lt; value(b) &lt;&lt; &quot; at &quot; &lt;&lt; TextStream::FormatNumberRespectingIntegers(progress) &lt;&lt; &quot; -&gt; &quot; &lt;&lt; value(result));
 492     }
 493 #endif
 494 
 495 protected:
 496     T (RenderStyle::*m_getter)() const;
 497 };
 498 
 499 template &lt;typename T&gt;
 500 class PropertyWrapper : public PropertyWrapperGetter&lt;T&gt; {
 501     WTF_MAKE_FAST_ALLOCATED;
 502 public:
 503     PropertyWrapper(CSSPropertyID prop, T (RenderStyle::*getter)() const, void (RenderStyle::*setter)(T))
 504         : PropertyWrapperGetter&lt;T&gt;(prop, getter)
 505         , m_setter(setter)
 506     {
 507     }
 508 
 509     void blend(const CSSPropertyBlendingClient* anim, RenderStyle* dst, const RenderStyle* a, const RenderStyle* b, double progress) const override
 510     {
 511         (dst-&gt;*m_setter)(blendFunc(anim, (a-&gt;*PropertyWrapperGetter&lt;T&gt;::m_getter)(), (b-&gt;*PropertyWrapperGetter&lt;T&gt;::m_getter)(), progress));
 512     }
 513 
 514 protected:
 515     void (RenderStyle::*m_setter)(T);
 516 };
 517 
 518 template &lt;typename T&gt;
 519 class RefCountedPropertyWrapper : public PropertyWrapperGetter&lt;T*&gt; {
 520     WTF_MAKE_FAST_ALLOCATED;
 521 public:
 522     RefCountedPropertyWrapper(CSSPropertyID prop, T* (RenderStyle::*getter)() const, void (RenderStyle::*setter)(RefPtr&lt;T&gt;&amp;&amp;))
 523         : PropertyWrapperGetter&lt;T*&gt;(prop, getter)
 524         , m_setter(setter)
 525     {
 526     }
 527 
 528     void blend(const CSSPropertyBlendingClient* anim, RenderStyle* dst, const RenderStyle* a, const RenderStyle* b, double progress) const override
 529     {
 530         (dst-&gt;*m_setter)(blendFunc(anim, (a-&gt;*PropertyWrapperGetter&lt;T*&gt;::m_getter)(), (b-&gt;*PropertyWrapperGetter&lt;T*&gt;::m_getter)(), progress));
 531     }
 532 
 533 protected:
 534     void (RenderStyle::*m_setter)(RefPtr&lt;T&gt;&amp;&amp;);
 535 };
 536 
 537 class LengthPropertyWrapper : public PropertyWrapperGetter&lt;const Length&amp;&gt; {
 538     WTF_MAKE_FAST_ALLOCATED;
 539 public:
 540     LengthPropertyWrapper(CSSPropertyID prop, const Length&amp; (RenderStyle::*getter)() const, void (RenderStyle::*setter)(Length&amp;&amp;))
 541         : PropertyWrapperGetter&lt;const Length&amp;&gt;(prop, getter)
 542         , m_setter(setter)
 543     {
 544     }
 545 
 546     bool canInterpolate(const RenderStyle* a, const RenderStyle* b) const override
 547     {
 548         return !(a-&gt;*PropertyWrapperGetter&lt;const Length&amp;&gt;::m_getter)().isAuto() &amp;&amp; !(b-&gt;*PropertyWrapperGetter&lt;const Length&amp;&gt;::m_getter)().isAuto();
 549     }
 550 
 551     void blend(const CSSPropertyBlendingClient* anim, RenderStyle* dst, const RenderStyle* a, const RenderStyle* b, double progress) const override
 552     {
 553         (dst-&gt;*m_setter)(blendFunc(anim, (a-&gt;*PropertyWrapperGetter&lt;const Length&amp;&gt;::m_getter)(), (b-&gt;*PropertyWrapperGetter&lt;const Length&amp;&gt;::m_getter)(), progress));
 554     }
 555 
 556 protected:
 557     void (RenderStyle::*m_setter)(Length&amp;&amp;);
 558 };
 559 
 560 template &lt;typename T&gt;
 561 class LengthVariantPropertyWrapper : public PropertyWrapperGetter&lt;const T&amp;&gt; {
 562     WTF_MAKE_FAST_ALLOCATED;
 563 public:
 564     LengthVariantPropertyWrapper(CSSPropertyID prop, const T&amp; (RenderStyle::*getter)() const, void (RenderStyle::*setter)(T&amp;&amp;))
 565         : PropertyWrapperGetter&lt;const T&amp;&gt;(prop, getter)
 566         , m_setter(setter)
 567     {
 568     }
 569 
 570     void blend(const CSSPropertyBlendingClient* anim, RenderStyle* dst, const RenderStyle* a, const RenderStyle* b, double progress) const override
 571     {
 572         (dst-&gt;*m_setter)(blendFunc(anim, (a-&gt;*PropertyWrapperGetter&lt;const T&amp;&gt;::m_getter)(), (b-&gt;*PropertyWrapperGetter&lt;const T&amp;&gt;::m_getter)(), progress));
 573     }
 574 
 575 protected:
 576     void (RenderStyle::*m_setter)(T&amp;&amp;);
 577 };
 578 
 579 class PropertyWrapperClipPath : public RefCountedPropertyWrapper&lt;ClipPathOperation&gt; {
 580     WTF_MAKE_FAST_ALLOCATED;
 581 public:
 582     PropertyWrapperClipPath(CSSPropertyID prop, ClipPathOperation* (RenderStyle::*getter)() const, void (RenderStyle::*setter)(RefPtr&lt;ClipPathOperation&gt;&amp;&amp;))
 583         : RefCountedPropertyWrapper&lt;ClipPathOperation&gt;(prop, getter, setter)
 584     {
 585     }
 586 
 587     bool equals(const RenderStyle* a, const RenderStyle* b) const override
 588     {
 589         // If the style pointers are the same, don&#39;t bother doing the test.
 590         // If either is null, return false. If both are null, return true.
 591         if (a == b)
 592             return true;
 593         if (!a || !b)
 594             return false;
 595 
 596         ClipPathOperation* clipPathA = (a-&gt;*m_getter)();
 597         ClipPathOperation* clipPathB = (b-&gt;*m_getter)();
 598         if (clipPathA == clipPathB)
 599             return true;
 600         if (!clipPathA || !clipPathB)
 601             return false;
 602         return *clipPathA == *clipPathB;
 603     }
 604 };
 605 
 606 #if ENABLE(VARIATION_FONTS)
 607 class PropertyWrapperFontVariationSettings : public PropertyWrapper&lt;FontVariationSettings&gt; {
 608     WTF_MAKE_FAST_ALLOCATED;
 609 public:
 610     PropertyWrapperFontVariationSettings(CSSPropertyID prop, FontVariationSettings (RenderStyle::*getter)() const, void (RenderStyle::*setter)(FontVariationSettings))
 611         : PropertyWrapper&lt;FontVariationSettings&gt;(prop, getter, setter)
 612     {
 613     }
 614 
 615     bool equals(const RenderStyle* a, const RenderStyle* b) const override
 616     {
 617         // If the style pointers are the same, don&#39;t bother doing the test.
 618         // If either is null, return false. If both are null, return true.
 619         if (a == b)
 620             return true;
 621         if (!a || !b)
 622             return false;
 623 
 624         const FontVariationSettings&amp; variationSettingsA = (a-&gt;*m_getter)();
 625         const FontVariationSettings&amp; variationSettingsB = (b-&gt;*m_getter)();
 626         return variationSettingsA == variationSettingsB;
 627     }
 628 };
 629 #endif
 630 
 631 class PropertyWrapperShape : public RefCountedPropertyWrapper&lt;ShapeValue&gt; {
 632     WTF_MAKE_FAST_ALLOCATED;
 633 public:
 634     PropertyWrapperShape(CSSPropertyID prop, ShapeValue* (RenderStyle::*getter)() const, void (RenderStyle::*setter)(RefPtr&lt;ShapeValue&gt;&amp;&amp;))
 635         : RefCountedPropertyWrapper&lt;ShapeValue&gt;(prop, getter, setter)
 636     {
 637     }
 638 
 639     bool equals(const RenderStyle* a, const RenderStyle* b) const override
 640     {
 641         // If the style pointers are the same, don&#39;t bother doing the test.
 642         // If either is null, return false. If both are null, return true.
 643         if (a == b)
 644             return true;
 645         if (!a || !b)
 646             return false;
 647 
 648         ShapeValue* shapeA = (a-&gt;*m_getter)();
 649         ShapeValue* shapeB = (b-&gt;*m_getter)();
 650         if (shapeA == shapeB)
 651             return true;
 652         if (!shapeA || !shapeB)
 653             return false;
 654         return *shapeA == *shapeB;
 655     }
 656 };
 657 
 658 class StyleImagePropertyWrapper : public RefCountedPropertyWrapper&lt;StyleImage&gt; {
 659     WTF_MAKE_FAST_ALLOCATED;
 660 public:
 661     StyleImagePropertyWrapper(CSSPropertyID prop, StyleImage* (RenderStyle::*getter)() const, void (RenderStyle::*setter)(RefPtr&lt;StyleImage&gt;&amp;&amp;))
 662         : RefCountedPropertyWrapper&lt;StyleImage&gt;(prop, getter, setter)
 663     {
 664     }
 665 
 666     bool equals(const RenderStyle* a, const RenderStyle* b) const override
 667     {
 668        if (a == b)
 669            return true;
 670        if (!a || !b)
 671             return false;
 672 
 673         StyleImage* imageA = (a-&gt;*m_getter)();
 674         StyleImage* imageB = (b-&gt;*m_getter)();
 675         return arePointingToEqualData(imageA, imageB);
 676     }
 677 };
 678 
 679 class PropertyWrapperColor : public PropertyWrapperGetter&lt;const Color&amp;&gt; {
 680     WTF_MAKE_FAST_ALLOCATED;
 681 public:
 682     PropertyWrapperColor(CSSPropertyID prop, const Color&amp; (RenderStyle::*getter)() const, void (RenderStyle::*setter)(const Color&amp;))
 683         : PropertyWrapperGetter&lt;const Color&amp;&gt;(prop, getter)
 684         , m_setter(setter)
 685     {
 686     }
 687 
 688     void blend(const CSSPropertyBlendingClient* anim, RenderStyle* dst, const RenderStyle* a, const RenderStyle* b, double progress) const override
 689     {
 690         (dst-&gt;*m_setter)(blendFunc(anim, (a-&gt;*PropertyWrapperGetter&lt;const Color&amp;&gt;::m_getter)(), (b-&gt;*PropertyWrapperGetter&lt;const Color&amp;&gt;::m_getter)(), progress));
 691     }
 692 
 693 protected:
 694     void (RenderStyle::*m_setter)(const Color&amp;);
 695 };
 696 
 697 class PropertyWrapperAcceleratedOpacity : public PropertyWrapper&lt;float&gt; {
 698     WTF_MAKE_FAST_ALLOCATED;
 699 public:
 700     PropertyWrapperAcceleratedOpacity()
 701         : PropertyWrapper&lt;float&gt;(CSSPropertyOpacity, &amp;RenderStyle::opacity, &amp;RenderStyle::setOpacity)
 702     {
 703     }
 704 
 705     bool animationIsAccelerated() const override { return true; }
 706 
 707     void blend(const CSSPropertyBlendingClient* anim, RenderStyle* dst, const RenderStyle* a, const RenderStyle* b, double progress) const override
 708     {
 709         dst-&gt;setOpacity(blendFunc(anim, a-&gt;opacity(), b-&gt;opacity(), progress));
 710     }
 711 };
 712 
 713 class PropertyWrapperAcceleratedTransform : public PropertyWrapper&lt;const TransformOperations&amp;&gt; {
 714     WTF_MAKE_FAST_ALLOCATED;
 715 public:
 716     PropertyWrapperAcceleratedTransform()
 717         : PropertyWrapper&lt;const TransformOperations&amp;&gt;(CSSPropertyTransform, &amp;RenderStyle::transform, &amp;RenderStyle::setTransform)
 718     {
 719     }
 720 
 721     bool animationIsAccelerated() const override { return true; }
 722 
 723     void blend(const CSSPropertyBlendingClient* anim, RenderStyle* dst, const RenderStyle* a, const RenderStyle* b, double progress) const override
 724     {
 725         dst-&gt;setTransform(blendFunc(anim, a-&gt;transform(), b-&gt;transform(), progress));
 726     }
 727 };
 728 
 729 class PropertyWrapperFilter : public PropertyWrapper&lt;const FilterOperations&amp;&gt; {
 730     WTF_MAKE_FAST_ALLOCATED;
 731 public:
 732     PropertyWrapperFilter(CSSPropertyID propertyID, const FilterOperations&amp; (RenderStyle::*getter)() const, void (RenderStyle::*setter)(const FilterOperations&amp;))
 733         : PropertyWrapper&lt;const FilterOperations&amp;&gt;(propertyID, getter, setter)
 734     {
 735     }
 736 
 737     bool animationIsAccelerated() const override
 738     {
 739         return property() == CSSPropertyFilter
 740 #if ENABLE(FILTERS_LEVEL_2)
 741             || property() == CSSPropertyWebkitBackdropFilter
 742 #endif
 743             ;
 744     }
 745 
 746     void blend(const CSSPropertyBlendingClient* anim, RenderStyle* dst, const RenderStyle* a, const RenderStyle* b, double progress) const override
 747     {
 748         (dst-&gt;*m_setter)(blendFunc(anim, (a-&gt;*PropertyWrapperGetter&lt;const FilterOperations&amp;&gt;::m_getter)(), (b-&gt;*PropertyWrapperGetter&lt;const FilterOperations&amp;&gt;::m_getter)(), progress, property()));
 749     }
 750 };
 751 
 752 static inline size_t shadowListLength(const ShadowData* shadow)
 753 {
 754     size_t count;
 755     for (count = 0; shadow; shadow = shadow-&gt;next())
 756         ++count;
 757     return count;
 758 }
 759 
 760 static inline const ShadowData* shadowForBlending(const ShadowData* srcShadow, const ShadowData* otherShadow)
 761 {
 762     static NeverDestroyed&lt;ShadowData&gt; defaultShadowData(IntPoint(), 0, 0, Normal, false, Color::transparent);
 763     static NeverDestroyed&lt;ShadowData&gt; defaultInsetShadowData(IntPoint(), 0, 0, Inset, false, Color::transparent);
 764     static NeverDestroyed&lt;ShadowData&gt; defaultWebKitBoxShadowData(IntPoint(), 0, 0, Normal, true, Color::transparent);
 765     static NeverDestroyed&lt;ShadowData&gt; defaultInsetWebKitBoxShadowData(IntPoint(), 0, 0, Inset, true, Color::transparent);
 766 
 767     if (srcShadow)
 768         return srcShadow;
 769 
 770     if (otherShadow-&gt;style() == Inset)
 771         return otherShadow-&gt;isWebkitBoxShadow() ? &amp;defaultInsetWebKitBoxShadowData.get() : &amp;defaultInsetShadowData.get();
 772 
 773     return otherShadow-&gt;isWebkitBoxShadow() ? &amp;defaultWebKitBoxShadowData.get() : &amp;defaultShadowData.get();
 774 }
 775 
 776 class PropertyWrapperShadow : public AnimationPropertyWrapperBase {
 777     WTF_MAKE_FAST_ALLOCATED;
 778 public:
 779     PropertyWrapperShadow(CSSPropertyID prop, const ShadowData* (RenderStyle::*getter)() const, void (RenderStyle::*setter)(std::unique_ptr&lt;ShadowData&gt;, bool))
 780         : AnimationPropertyWrapperBase(prop)
 781         , m_getter(getter)
 782         , m_setter(setter)
 783     {
 784     }
 785 
 786     bool equals(const RenderStyle* a, const RenderStyle* b) const override
 787     {
 788         if (a == b)
 789             return true;
 790         if (!a || !b)
 791             return false;
 792 
 793         const ShadowData* shadowA = (a-&gt;*m_getter)();
 794         const ShadowData* shadowB = (b-&gt;*m_getter)();
 795 
 796         while (true) {
 797             // end of both lists
 798             if (!shadowA &amp;&amp; !shadowB)
 799                 return true;
 800 
 801             // end of just one of the lists
 802             if (!shadowA || !shadowB)
 803                 return false;
 804 
 805             if (*shadowA != *shadowB)
 806                 return false;
 807 
 808             shadowA = shadowA-&gt;next();
 809             shadowB = shadowB-&gt;next();
 810         }
 811 
 812         return true;
 813     }
 814 
 815     void blend(const CSSPropertyBlendingClient* anim, RenderStyle* dst, const RenderStyle* a, const RenderStyle* b, double progress) const override
 816     {
 817         const ShadowData* shadowA = (a-&gt;*m_getter)();
 818         const ShadowData* shadowB = (b-&gt;*m_getter)();
 819 
 820         int fromLength = shadowListLength(shadowA);
 821         int toLength = shadowListLength(shadowB);
 822 
 823         if (fromLength == toLength || (fromLength &lt;= 1 &amp;&amp; toLength &lt;= 1)) {
 824             (dst-&gt;*m_setter)(blendSimpleOrMatchedShadowLists(anim, progress, shadowA, shadowB), false);
 825             return;
 826         }
 827 
 828         (dst-&gt;*m_setter)(blendMismatchedShadowLists(anim, progress, shadowA, shadowB, fromLength, toLength), false);
 829     }
 830 
 831 #if !LOG_DISABLED
 832     void logBlend(const RenderStyle*, const RenderStyle*, const RenderStyle*, double progress) const final
 833     {
 834         // FIXME: better logging.
 835         LOG_WITH_STREAM(Animations, stream &lt;&lt; &quot;  blending ShadowData at &quot; &lt;&lt; TextStream::FormatNumberRespectingIntegers(progress));
 836     }
 837 #endif
 838 
 839 private:
 840     std::unique_ptr&lt;ShadowData&gt; blendSimpleOrMatchedShadowLists(const CSSPropertyBlendingClient* anim, double progress, const ShadowData* shadowA, const ShadowData* shadowB) const
 841     {
 842         std::unique_ptr&lt;ShadowData&gt; newShadowData;
 843         ShadowData* lastShadow = 0;
 844 
 845         while (shadowA || shadowB) {
 846             const ShadowData* srcShadow = shadowForBlending(shadowA, shadowB);
 847             const ShadowData* dstShadow = shadowForBlending(shadowB, shadowA);
 848 
 849             std::unique_ptr&lt;ShadowData&gt; blendedShadow = blendFunc(anim, srcShadow, dstShadow, progress);
 850             ShadowData* blendedShadowPtr = blendedShadow.get();
 851 
 852             if (!lastShadow)
 853                 newShadowData = WTFMove(blendedShadow);
 854             else
 855                 lastShadow-&gt;setNext(WTFMove(blendedShadow));
 856 
 857             lastShadow = blendedShadowPtr;
 858 
 859             shadowA = shadowA ? shadowA-&gt;next() : 0;
 860             shadowB = shadowB ? shadowB-&gt;next() : 0;
 861         }
 862 
 863         return newShadowData;
 864     }
 865 
 866     std::unique_ptr&lt;ShadowData&gt; blendMismatchedShadowLists(const CSSPropertyBlendingClient* anim, double progress, const ShadowData* shadowA, const ShadowData* shadowB, int fromLength, int toLength) const
 867     {
 868         // The shadows in ShadowData are stored in reverse order, so when animating mismatched lists,
 869         // reverse them and match from the end.
 870         Vector&lt;const ShadowData*, 4&gt; fromShadows(fromLength);
 871         for (int i = fromLength - 1; i &gt;= 0; --i) {
 872             fromShadows[i] = shadowA;
 873             shadowA = shadowA-&gt;next();
 874         }
 875 
 876         Vector&lt;const ShadowData*, 4&gt; toShadows(toLength);
 877         for (int i = toLength - 1; i &gt;= 0; --i) {
 878             toShadows[i] = shadowB;
 879             shadowB = shadowB-&gt;next();
 880         }
 881 
 882         std::unique_ptr&lt;ShadowData&gt; newShadowData;
 883 
 884         int maxLength = std::max(fromLength, toLength);
 885         for (int i = 0; i &lt; maxLength; ++i) {
 886             const ShadowData* fromShadow = i &lt; fromLength ? fromShadows[i] : 0;
 887             const ShadowData* toShadow = i &lt; toLength ? toShadows[i] : 0;
 888 
 889             const ShadowData* srcShadow = shadowForBlending(fromShadow, toShadow);
 890             const ShadowData* dstShadow = shadowForBlending(toShadow, fromShadow);
 891 
 892             std::unique_ptr&lt;ShadowData&gt; blendedShadow = blendFunc(anim, srcShadow, dstShadow, progress);
 893             // Insert at the start of the list to preserve the order.
 894             blendedShadow-&gt;setNext(WTFMove(newShadowData));
 895             newShadowData = WTFMove(blendedShadow);
 896         }
 897 
 898         return newShadowData;
 899     }
 900 
 901     const ShadowData* (RenderStyle::*m_getter)() const;
 902     void (RenderStyle::*m_setter)(std::unique_ptr&lt;ShadowData&gt;, bool);
 903 };
 904 
 905 class PropertyWrapperMaybeInvalidColor : public AnimationPropertyWrapperBase {
 906     WTF_MAKE_FAST_ALLOCATED;
 907 public:
 908     PropertyWrapperMaybeInvalidColor(CSSPropertyID prop, const Color&amp; (RenderStyle::*getter)() const, void (RenderStyle::*setter)(const Color&amp;))
 909         : AnimationPropertyWrapperBase(prop)
 910         , m_getter(getter)
 911         , m_setter(setter)
 912     {
 913     }
 914 
 915     bool equals(const RenderStyle* a, const RenderStyle* b) const override
 916     {
 917         if (a == b)
 918             return true;
 919         if (!a || !b)
 920             return false;
 921 
 922         Color fromColor = value(a);
 923         Color toColor = value(b);
 924 
 925         if (!fromColor.isValid() &amp;&amp; !toColor.isValid())
 926             return true;
 927 
 928         if (!fromColor.isValid())
 929             fromColor = a-&gt;color();
 930         if (!toColor.isValid())
 931             toColor = b-&gt;color();
 932 
 933         return fromColor == toColor;
 934     }
 935 
 936     void blend(const CSSPropertyBlendingClient* anim, RenderStyle* dst, const RenderStyle* a, const RenderStyle* b, double progress) const override
 937     {
 938         Color fromColor = value(a);
 939         Color toColor = value(b);
 940 
 941         if (!fromColor.isValid() &amp;&amp; !toColor.isValid())
 942             return;
 943 
 944         if (!fromColor.isValid())
 945             fromColor = a-&gt;color();
 946         if (!toColor.isValid())
 947             toColor = b-&gt;color();
 948         (dst-&gt;*m_setter)(blendFunc(anim, fromColor, toColor, progress));
 949     }
 950 
 951     Color value(const RenderStyle* a) const
 952     {
 953         return (a-&gt;*m_getter)();
 954     }
 955 
 956 #if !LOG_DISABLED
 957     void logBlend(const RenderStyle* a, const RenderStyle* b, const RenderStyle* result, double progress) const final
 958     {
 959         // FIXME: better logging.
 960         LOG_WITH_STREAM(Animations, stream &lt;&lt; &quot;  blending &quot; &lt;&lt; getPropertyName(property()) &lt;&lt; &quot; from &quot; &lt;&lt; value(a) &lt;&lt; &quot; to &quot; &lt;&lt; value(b) &lt;&lt; &quot; at &quot; &lt;&lt; TextStream::FormatNumberRespectingIntegers(progress) &lt;&lt; &quot; -&gt; &quot; &lt;&lt; value(result));
 961     }
 962 #endif
 963 
 964 private:
 965     const Color&amp; (RenderStyle::*m_getter)() const;
 966     void (RenderStyle::*m_setter)(const Color&amp;);
 967 };
 968 
 969 
 970 enum MaybeInvalidColorTag { MaybeInvalidColor };
 971 class PropertyWrapperVisitedAffectedColor : public AnimationPropertyWrapperBase {
 972     WTF_MAKE_FAST_ALLOCATED;
 973 public:
 974     PropertyWrapperVisitedAffectedColor(CSSPropertyID prop, const Color&amp; (RenderStyle::*getter)() const, void (RenderStyle::*setter)(const Color&amp;),
 975         const Color&amp; (RenderStyle::*visitedGetter)() const, void (RenderStyle::*visitedSetter)(const Color&amp;))
 976         : AnimationPropertyWrapperBase(prop)
<a name="4" id="anc4"></a><span class="line-modified"> 977         , m_wrapper(std::make_unique&lt;PropertyWrapperColor&gt;(prop, getter, setter))</span>
<span class="line-modified"> 978         , m_visitedWrapper(std::make_unique&lt;PropertyWrapperColor&gt;(prop, visitedGetter, visitedSetter))</span>
 979     {
 980     }
 981     PropertyWrapperVisitedAffectedColor(CSSPropertyID prop, MaybeInvalidColorTag, const Color&amp; (RenderStyle::*getter)() const, void (RenderStyle::*setter)(const Color&amp;),
 982         const Color&amp; (RenderStyle::*visitedGetter)() const, void (RenderStyle::*visitedSetter)(const Color&amp;))
 983         : AnimationPropertyWrapperBase(prop)
<a name="5" id="anc5"></a><span class="line-modified"> 984         , m_wrapper(std::make_unique&lt;PropertyWrapperMaybeInvalidColor&gt;(prop, getter, setter))</span>
<span class="line-modified"> 985         , m_visitedWrapper(std::make_unique&lt;PropertyWrapperMaybeInvalidColor&gt;(prop, visitedGetter, visitedSetter))</span>
 986     {
 987     }
 988     bool equals(const RenderStyle* a, const RenderStyle* b) const override
 989     {
 990         return m_wrapper-&gt;equals(a, b) &amp;&amp; m_visitedWrapper-&gt;equals(a, b);
 991     }
 992     void blend(const CSSPropertyBlendingClient* anim, RenderStyle* dst, const RenderStyle* a, const RenderStyle* b, double progress) const override
 993     {
 994         m_wrapper-&gt;blend(anim, dst, a, b, progress);
 995         m_visitedWrapper-&gt;blend(anim, dst, a, b, progress);
 996     }
 997 
 998 #if !LOG_DISABLED
 999     void logBlend(const RenderStyle* a, const RenderStyle* b, const RenderStyle* result, double progress) const final
1000     {
1001         m_wrapper-&gt;logBlend(a, b, result, progress);
1002         m_visitedWrapper-&gt;logBlend(a, b, result, progress);
1003     }
1004 #endif
1005 
1006 private:
1007     std::unique_ptr&lt;AnimationPropertyWrapperBase&gt; m_wrapper;
1008     std::unique_ptr&lt;AnimationPropertyWrapperBase&gt; m_visitedWrapper;
1009 };
1010 
1011 // Wrapper base class for an animatable property in a FillLayer
1012 class FillLayerAnimationPropertyWrapperBase {
1013     WTF_MAKE_FAST_ALLOCATED;
1014 public:
1015     FillLayerAnimationPropertyWrapperBase(CSSPropertyID property)
1016         : m_property(property)
1017     {
1018     }
1019     virtual ~FillLayerAnimationPropertyWrapperBase() = default;
1020 
1021     CSSPropertyID property() const { return m_property; }
1022 
1023     virtual bool equals(const FillLayer*, const FillLayer*) const = 0;
1024     virtual void blend(const CSSPropertyBlendingClient*, FillLayer*, const FillLayer*, const FillLayer*, double) const = 0;
1025 
1026 #if !LOG_DISABLED
1027     virtual void logBlend(const FillLayer* result, const FillLayer*, const FillLayer*, double) const = 0;
1028 #endif
1029 private:
1030     CSSPropertyID m_property;
1031 };
1032 
1033 template &lt;typename T&gt;
1034 class FillLayerPropertyWrapperGetter : public FillLayerAnimationPropertyWrapperBase {
1035     WTF_MAKE_FAST_ALLOCATED;
1036     WTF_MAKE_NONCOPYABLE(FillLayerPropertyWrapperGetter);
1037 public:
1038     FillLayerPropertyWrapperGetter(CSSPropertyID property, T (FillLayer::*getter)() const)
1039         : FillLayerAnimationPropertyWrapperBase(property)
1040         , m_getter(getter)
1041     {
1042     }
1043 
1044     bool equals(const FillLayer* a, const FillLayer* b) const override
1045     {
1046         if (a == b)
1047             return true;
1048         if (!a || !b)
1049             return false;
1050         return (a-&gt;*m_getter)() == (b-&gt;*m_getter)();
1051     }
1052 
1053     T value(const FillLayer* layer) const
1054     {
1055         return (layer-&gt;*m_getter)();
1056     }
1057 
1058 #if !LOG_DISABLED
1059     void logBlend(const FillLayer* result, const FillLayer* a, const FillLayer* b, double progress) const override
1060     {
1061         LOG_WITH_STREAM(Animations, stream &lt;&lt; &quot;  blending &quot; &lt;&lt; getPropertyName(property()) &lt;&lt; &quot; from &quot; &lt;&lt; value(a) &lt;&lt; &quot; to &quot; &lt;&lt; value(b) &lt;&lt; &quot; at &quot; &lt;&lt; TextStream::FormatNumberRespectingIntegers(progress) &lt;&lt; &quot; -&gt; &quot; &lt;&lt; value(result));
1062     }
1063 #endif
1064 
1065 protected:
1066     T (FillLayer::*m_getter)() const;
1067 };
1068 
1069 template &lt;typename T&gt;
1070 class FillLayerPropertyWrapper : public FillLayerPropertyWrapperGetter&lt;const T&amp;&gt; {
1071     WTF_MAKE_FAST_ALLOCATED;
1072 public:
1073     FillLayerPropertyWrapper(CSSPropertyID property, const T&amp; (FillLayer::*getter)() const, void (FillLayer::*setter)(T))
1074         : FillLayerPropertyWrapperGetter&lt;const T&amp;&gt;(property, getter)
1075         , m_setter(setter)
1076     {
1077     }
1078 
1079     void blend(const CSSPropertyBlendingClient* anim, FillLayer* dst, const FillLayer* a, const FillLayer* b, double progress) const override
1080     {
1081         (dst-&gt;*m_setter)(blendFunc(anim, (a-&gt;*FillLayerPropertyWrapperGetter&lt;const T&amp;&gt;::m_getter)(), (b-&gt;*FillLayerPropertyWrapperGetter&lt;const T&amp;&gt;::m_getter)(), progress));
1082     }
1083 
1084 #if !LOG_DISABLED
1085     void logBlend(const FillLayer* result, const FillLayer* a, const FillLayer* b, double progress) const override
1086     {
1087         LOG_WITH_STREAM(Animations, stream &lt;&lt; &quot;  blending &quot; &lt;&lt; getPropertyName(FillLayerPropertyWrapperGetter&lt;const T&amp;&gt;::property())
1088             &lt;&lt; &quot; from &quot; &lt;&lt; FillLayerPropertyWrapperGetter&lt;const T&amp;&gt;::value(a)
1089             &lt;&lt; &quot; to &quot; &lt;&lt; FillLayerPropertyWrapperGetter&lt;const T&amp;&gt;::value(b)
1090             &lt;&lt; &quot; at &quot; &lt;&lt; TextStream::FormatNumberRespectingIntegers(progress) &lt;&lt; &quot; -&gt; &quot; &lt;&lt; FillLayerPropertyWrapperGetter&lt;const T&amp;&gt;::value(result));
1091     }
1092 #endif
1093 
1094 protected:
1095     void (FillLayer::*m_setter)(T);
1096 };
1097 
1098 class FillLayerPositionPropertyWrapper : public FillLayerPropertyWrapperGetter&lt;const Length&amp;&gt; {
1099     WTF_MAKE_FAST_ALLOCATED;
1100 public:
1101     FillLayerPositionPropertyWrapper(CSSPropertyID property, const Length&amp; (FillLayer::*lengthGetter)() const, void (FillLayer::*lengthSetter)(Length), Edge (FillLayer::*originGetter)() const, void (FillLayer::*originSetter)(Edge), Edge farEdge)
1102         : FillLayerPropertyWrapperGetter&lt;const Length&amp;&gt;(property, lengthGetter)
1103         , m_lengthSetter(lengthSetter)
1104         , m_originGetter(originGetter)
1105         , m_originSetter(originSetter)
1106         , m_farEdge(farEdge)
1107     {
1108     }
1109 
1110     bool equals(const FillLayer* a, const FillLayer* b) const override
1111     {
1112         if (a == b)
1113             return true;
1114         if (!a || !b)
1115             return false;
1116 
1117         Length fromLength = (a-&gt;*FillLayerPropertyWrapperGetter&lt;const Length&amp;&gt;::m_getter)();
1118         Length toLength = (b-&gt;*FillLayerPropertyWrapperGetter&lt;const Length&amp;&gt;::m_getter)();
1119 
1120         Edge fromEdge = (a-&gt;*m_originGetter)();
1121         Edge toEdge = (b-&gt;*m_originGetter)();
1122 
1123         return fromLength == toLength &amp;&amp; fromEdge == toEdge;
1124     }
1125 
1126     void blend(const CSSPropertyBlendingClient* anim, FillLayer* dst, const FillLayer* a, const FillLayer* b, double progress) const override
1127     {
1128         Length fromLength = (a-&gt;*FillLayerPropertyWrapperGetter&lt;const Length&amp;&gt;::m_getter)();
1129         Length toLength = (b-&gt;*FillLayerPropertyWrapperGetter&lt;const Length&amp;&gt;::m_getter)();
1130 
1131         Edge fromEdge = (a-&gt;*m_originGetter)();
1132         Edge toEdge = (b-&gt;*m_originGetter)();
1133 
1134         if (fromEdge != toEdge) {
1135             // Convert the right/bottom into a calc expression,
1136             if (fromEdge == m_farEdge)
1137                 fromLength = convertTo100PercentMinusLength(fromLength);
1138             else if (toEdge == m_farEdge) {
1139                 toLength = convertTo100PercentMinusLength(toLength);
1140                 (dst-&gt;*m_originSetter)(fromEdge); // Now we have a calc(100% - l), it&#39;s relative to the left/top edge.
1141             }
1142         }
1143 
1144         (dst-&gt;*m_lengthSetter)(blendFunc(anim, fromLength, toLength, progress));
1145     }
1146 
1147 #if !LOG_DISABLED
1148     void logBlend(const FillLayer* result, const FillLayer* a, const FillLayer* b, double progress) const override
1149     {
1150         LOG_WITH_STREAM(Animations, stream &lt;&lt; &quot;  blending &quot; &lt;&lt; getPropertyName(property()) &lt;&lt; &quot; from &quot; &lt;&lt; value(a) &lt;&lt; &quot; to &quot; &lt;&lt; value(b) &lt;&lt; &quot; at &quot; &lt;&lt; TextStream::FormatNumberRespectingIntegers(progress) &lt;&lt; &quot; -&gt; &quot; &lt;&lt; value(result));
1151     }
1152 #endif
1153 
1154 protected:
1155     void (FillLayer::*m_lengthSetter)(Length);
1156     Edge (FillLayer::*m_originGetter)() const;
1157     void (FillLayer::*m_originSetter)(Edge);
1158     Edge m_farEdge;
1159 };
1160 
1161 template &lt;typename T&gt;
1162 class FillLayerRefCountedPropertyWrapper : public FillLayerPropertyWrapperGetter&lt;T*&gt; {
1163     WTF_MAKE_FAST_ALLOCATED;
1164 public:
1165     FillLayerRefCountedPropertyWrapper(CSSPropertyID property, T* (FillLayer::*getter)() const, void (FillLayer::*setter)(RefPtr&lt;T&gt;&amp;&amp;))
1166         : FillLayerPropertyWrapperGetter&lt;T*&gt;(property, getter)
1167         , m_setter(setter)
1168     {
1169     }
1170 
1171     void blend(const CSSPropertyBlendingClient* anim, FillLayer* dst, const FillLayer* a, const FillLayer* b, double progress) const override
1172     {
1173         (dst-&gt;*m_setter)(blendFunc(anim, (a-&gt;*FillLayerPropertyWrapperGetter&lt;T*&gt;::m_getter)(), (b-&gt;*FillLayerPropertyWrapperGetter&lt;T*&gt;::m_getter)(), progress));
1174     }
1175 
1176 #if !LOG_DISABLED
1177     void logBlend(const FillLayer* result, const FillLayer* a, const FillLayer* b, double progress) const override
1178     {
1179         LOG_WITH_STREAM(Animations, stream &lt;&lt; &quot;  blending &quot; &lt;&lt; getPropertyName(FillLayerPropertyWrapperGetter&lt;T*&gt;::property())
1180             &lt;&lt; &quot; from &quot; &lt;&lt; FillLayerPropertyWrapperGetter&lt;T*&gt;::value(a)
1181             &lt;&lt; &quot; to &quot; &lt;&lt; FillLayerPropertyWrapperGetter&lt;T*&gt;::value(b)
1182             &lt;&lt; &quot; at &quot; &lt;&lt; TextStream::FormatNumberRespectingIntegers(progress) &lt;&lt; &quot; -&gt; &quot; &lt;&lt; FillLayerPropertyWrapperGetter&lt;T*&gt;::value(result));
1183     }
1184 #endif
1185 
1186 protected:
1187     void (FillLayer::*m_setter)(RefPtr&lt;T&gt;&amp;&amp;);
1188 };
1189 
1190 class FillLayerStyleImagePropertyWrapper : public FillLayerRefCountedPropertyWrapper&lt;StyleImage&gt; {
1191     WTF_MAKE_FAST_ALLOCATED;
1192 public:
1193     FillLayerStyleImagePropertyWrapper(CSSPropertyID property, StyleImage* (FillLayer::*getter)() const, void (FillLayer::*setter)(RefPtr&lt;StyleImage&gt;&amp;&amp;))
1194         : FillLayerRefCountedPropertyWrapper&lt;StyleImage&gt;(property, getter, setter)
1195     {
1196     }
1197 
1198     bool equals(const FillLayer* a, const FillLayer* b) const override
1199     {
1200        if (a == b)
1201            return true;
1202        if (!a || !b)
1203             return false;
1204 
1205         StyleImage* imageA = (a-&gt;*m_getter)();
1206         StyleImage* imageB = (b-&gt;*m_getter)();
1207         return arePointingToEqualData(imageA, imageB);
1208     }
1209 
1210 #if !LOG_DISABLED
1211     void logBlend(const FillLayer* result, const FillLayer* a, const FillLayer* b, double progress) const override
1212     {
1213         LOG_WITH_STREAM(Animations, stream &lt;&lt; &quot;  blending &quot; &lt;&lt; getPropertyName(property()) &lt;&lt; &quot; from &quot; &lt;&lt; value(a) &lt;&lt; &quot; to &quot; &lt;&lt; value(b) &lt;&lt; &quot; at &quot; &lt;&lt; TextStream::FormatNumberRespectingIntegers(progress) &lt;&lt; &quot; -&gt; &quot; &lt;&lt; value(result));
1214     }
1215 #endif
1216 };
1217 
1218 class FillLayersPropertyWrapper : public AnimationPropertyWrapperBase {
1219     WTF_MAKE_FAST_ALLOCATED;
1220 public:
1221     typedef const FillLayer&amp; (RenderStyle::*LayersGetter)() const;
1222     typedef FillLayer&amp; (RenderStyle::*LayersAccessor)();
1223 
1224     FillLayersPropertyWrapper(CSSPropertyID property, LayersGetter getter, LayersAccessor accessor)
1225         : AnimationPropertyWrapperBase(property)
1226         , m_layersGetter(getter)
1227         , m_layersAccessor(accessor)
1228     {
1229         switch (property) {
1230         case CSSPropertyBackgroundPositionX:
1231         case CSSPropertyWebkitMaskPositionX:
<a name="6" id="anc6"></a><span class="line-modified">1232             m_fillLayerPropertyWrapper = std::make_unique&lt;FillLayerPositionPropertyWrapper&gt;(property, &amp;FillLayer::xPosition, &amp;FillLayer::setXPosition, &amp;FillLayer::backgroundXOrigin, &amp;FillLayer::setBackgroundXOrigin, Edge::Right);</span>
1233             break;
1234         case CSSPropertyBackgroundPositionY:
1235         case CSSPropertyWebkitMaskPositionY:
<a name="7" id="anc7"></a><span class="line-modified">1236             m_fillLayerPropertyWrapper = std::make_unique&lt;FillLayerPositionPropertyWrapper&gt;(property, &amp;FillLayer::yPosition, &amp;FillLayer::setYPosition, &amp;FillLayer::backgroundYOrigin, &amp;FillLayer::setBackgroundYOrigin, Edge::Bottom);</span>
1237             break;
1238         case CSSPropertyBackgroundSize:
1239         case CSSPropertyWebkitBackgroundSize:
1240         case CSSPropertyWebkitMaskSize:
<a name="8" id="anc8"></a><span class="line-modified">1241             m_fillLayerPropertyWrapper = std::make_unique&lt;FillLayerPropertyWrapper&lt;LengthSize&gt;&gt;(property, &amp;FillLayer::sizeLength, &amp;FillLayer::setSizeLength);</span>
1242             break;
1243         case CSSPropertyBackgroundImage:
<a name="9" id="anc9"></a><span class="line-modified">1244             m_fillLayerPropertyWrapper = std::make_unique&lt;FillLayerStyleImagePropertyWrapper&gt;(property, &amp;FillLayer::image, &amp;FillLayer::setImage);</span>
1245             break;
1246         default:
1247             break;
1248         }
1249     }
1250 
1251     bool equals(const RenderStyle* a, const RenderStyle* b) const override
1252     {
1253         if (a == b)
1254             return true;
1255         if (!a || !b)
1256             return false;
1257 
1258         auto* fromLayer = &amp;(a-&gt;*m_layersGetter)();
1259         auto* toLayer = &amp;(b-&gt;*m_layersGetter)();
1260 
1261         while (fromLayer &amp;&amp; toLayer) {
1262             if (!m_fillLayerPropertyWrapper-&gt;equals(fromLayer, toLayer))
1263                 return false;
1264 
1265             fromLayer = fromLayer-&gt;next();
1266             toLayer = toLayer-&gt;next();
1267         }
1268 
1269         return true;
1270     }
1271 
1272     void blend(const CSSPropertyBlendingClient* anim, RenderStyle* dst, const RenderStyle* a, const RenderStyle* b, double progress) const override
1273     {
1274         auto* aLayer = &amp;(a-&gt;*m_layersGetter)();
1275         auto* bLayer = &amp;(b-&gt;*m_layersGetter)();
1276         auto* dstLayer = &amp;(dst-&gt;*m_layersAccessor)();
1277 
1278         while (aLayer &amp;&amp; bLayer &amp;&amp; dstLayer) {
1279             m_fillLayerPropertyWrapper-&gt;blend(anim, dstLayer, aLayer, bLayer, progress);
1280             aLayer = aLayer-&gt;next();
1281             bLayer = bLayer-&gt;next();
1282             dstLayer = dstLayer-&gt;next();
1283         }
1284     }
1285 
1286 #if !LOG_DISABLED
1287     void logBlend(const RenderStyle* from, const RenderStyle* to, const RenderStyle* result, double progress) const final
1288     {
1289         auto* aLayer = &amp;(from-&gt;*m_layersGetter)();
1290         auto* bLayer = &amp;(to-&gt;*m_layersGetter)();
1291         auto* dstLayer = &amp;(result-&gt;*m_layersGetter)();
1292 
1293         while (aLayer &amp;&amp; bLayer &amp;&amp; dstLayer) {
1294             m_fillLayerPropertyWrapper-&gt;logBlend(dstLayer, aLayer, bLayer, progress);
1295             aLayer = aLayer-&gt;next();
1296             bLayer = bLayer-&gt;next();
1297             dstLayer = dstLayer-&gt;next();
1298         }
1299     }
1300 #endif
1301 
1302 private:
1303     std::unique_ptr&lt;FillLayerAnimationPropertyWrapperBase&gt; m_fillLayerPropertyWrapper;
1304 
1305     LayersGetter m_layersGetter;
1306     LayersAccessor m_layersAccessor;
1307 };
1308 
1309 class ShorthandPropertyWrapper : public AnimationPropertyWrapperBase {
1310     WTF_MAKE_FAST_ALLOCATED;
1311 public:
1312     ShorthandPropertyWrapper(CSSPropertyID property, Vector&lt;AnimationPropertyWrapperBase*&gt; longhandWrappers)
1313         : AnimationPropertyWrapperBase(property)
1314         , m_propertyWrappers(WTFMove(longhandWrappers))
1315     {
1316     }
1317 
1318     bool isShorthandWrapper() const override { return true; }
1319 
1320     bool equals(const RenderStyle* a, const RenderStyle* b) const override
1321     {
1322         if (a == b)
1323             return true;
1324         if (!a || !b)
1325             return false;
1326 
1327         for (auto&amp; wrapper : m_propertyWrappers) {
1328             if (!wrapper-&gt;equals(a, b))
1329                 return false;
1330         }
1331         return true;
1332     }
1333 
1334     void blend(const CSSPropertyBlendingClient* anim, RenderStyle* dst, const RenderStyle* a, const RenderStyle* b, double progress) const override
1335     {
1336         for (auto&amp; wrapper : m_propertyWrappers)
1337             wrapper-&gt;blend(anim, dst, a, b, progress);
1338     }
1339 
1340 #if !LOG_DISABLED
1341     void logBlend(const RenderStyle* a, const RenderStyle* b, const RenderStyle* dst, double progress) const final
1342     {
1343         for (auto&amp; wrapper : m_propertyWrappers)
1344             wrapper-&gt;logBlend(a, b, dst, progress);
1345     }
1346 #endif
1347 
1348     const Vector&lt;AnimationPropertyWrapperBase*&gt;&amp; propertyWrappers() const { return m_propertyWrappers; }
1349 
1350 private:
1351     Vector&lt;AnimationPropertyWrapperBase*&gt; m_propertyWrappers;
1352 };
1353 
1354 class PropertyWrapperFlex : public AnimationPropertyWrapperBase {
1355     WTF_MAKE_FAST_ALLOCATED;
1356 public:
1357     PropertyWrapperFlex()
1358         : AnimationPropertyWrapperBase(CSSPropertyFlex)
1359     {
1360     }
1361 
1362     bool equals(const RenderStyle* a, const RenderStyle* b) const override
1363     {
1364         if (a == b)
1365             return true;
1366         if (!a || !b)
1367             return false;
1368 
1369         return a-&gt;flexBasis() == b-&gt;flexBasis() &amp;&amp; a-&gt;flexGrow() == b-&gt;flexGrow() &amp;&amp; a-&gt;flexShrink() == b-&gt;flexShrink();
1370     }
1371 
1372     void blend(const CSSPropertyBlendingClient* anim, RenderStyle* dst, const RenderStyle* a, const RenderStyle* b, double progress) const override
1373     {
1374         dst-&gt;setFlexBasis(blendFunc(anim, a-&gt;flexBasis(), b-&gt;flexBasis(), progress));
1375         dst-&gt;setFlexGrow(blendFunc(anim, a-&gt;flexGrow(), b-&gt;flexGrow(), progress));
1376         dst-&gt;setFlexShrink(blendFunc(anim, a-&gt;flexShrink(), b-&gt;flexShrink(), progress));
1377     }
1378 
1379 #if !LOG_DISABLED
1380     void logBlend(const RenderStyle*, const RenderStyle*, const RenderStyle*, double progress) const final
1381     {
1382         // FIXME: better logging.
1383         LOG_WITH_STREAM(Animations, stream &lt;&lt; &quot;  blending flex at &quot; &lt;&lt; TextStream::FormatNumberRespectingIntegers(progress));
1384     }
1385 #endif
1386 };
1387 
1388 class PropertyWrapperSVGPaint : public AnimationPropertyWrapperBase {
1389     WTF_MAKE_FAST_ALLOCATED;
1390 public:
1391     PropertyWrapperSVGPaint(CSSPropertyID prop, SVGPaintType (RenderStyle::*paintTypeGetter)() const, Color (RenderStyle::*getter)() const, void (RenderStyle::*setter)(const Color&amp;))
1392         : AnimationPropertyWrapperBase(prop)
1393         , m_paintTypeGetter(paintTypeGetter)
1394         , m_getter(getter)
1395         , m_setter(setter)
1396     {
1397     }
1398 
1399     bool equals(const RenderStyle* a, const RenderStyle* b) const override
1400     {
1401         if (a == b)
1402             return true;
1403         if (!a || !b)
1404             return false;
1405 
1406         if ((a-&gt;*m_paintTypeGetter)() != (b-&gt;*m_paintTypeGetter)())
1407             return false;
1408 
1409         // We only support animations between SVGPaints that are pure Color values.
1410         // For everything else we must return true for this method, otherwise
1411         // we will try to animate between values forever.
1412         if ((a-&gt;*m_paintTypeGetter)() == SVGPaintType::RGBColor) {
1413             Color fromColor = (a-&gt;*m_getter)();
1414             Color toColor = (b-&gt;*m_getter)();
1415 
1416             if (!fromColor.isValid() &amp;&amp; !toColor.isValid())
1417                 return true;
1418 
1419             if (!fromColor.isValid())
1420                 fromColor = Color();
1421             if (!toColor.isValid())
1422                 toColor = Color();
1423 
1424             return fromColor == toColor;
1425         }
1426         return true;
1427     }
1428 
1429     void blend(const CSSPropertyBlendingClient* anim, RenderStyle* dst, const RenderStyle* a, const RenderStyle* b, double progress) const override
1430     {
1431         if ((a-&gt;*m_paintTypeGetter)() != SVGPaintType::RGBColor
1432             || (b-&gt;*m_paintTypeGetter)() != SVGPaintType::RGBColor)
1433             return;
1434 
1435         Color fromColor = (a-&gt;*m_getter)();
1436         Color toColor = (b-&gt;*m_getter)();
1437 
1438         if (!fromColor.isValid() &amp;&amp; !toColor.isValid())
1439             return;
1440 
1441         if (!fromColor.isValid())
1442             fromColor = Color();
1443         if (!toColor.isValid())
1444             toColor = Color();
1445         (dst-&gt;*m_setter)(blendFunc(anim, fromColor, toColor, progress));
1446     }
1447 
1448 #if !LOG_DISABLED
1449     void logBlend(const RenderStyle*, const RenderStyle*, const RenderStyle*, double progress) const final
1450     {
1451         // FIXME: better logging.
1452         LOG_WITH_STREAM(Animations, stream &lt;&lt; &quot;  blending SVGPaint at &quot; &lt;&lt; TextStream::FormatNumberRespectingIntegers(progress));
1453     }
1454 #endif
1455 
1456 private:
1457     SVGPaintType (RenderStyle::*m_paintTypeGetter)() const;
1458     Color (RenderStyle::*m_getter)() const;
1459     void (RenderStyle::*m_setter)(const Color&amp;);
1460 };
1461 
1462 class PropertyWrapperFontStyle : public PropertyWrapper&lt;Optional&lt;FontSelectionValue&gt;&gt; {
1463     WTF_MAKE_FAST_ALLOCATED;
1464 public:
1465     PropertyWrapperFontStyle()
1466         : PropertyWrapper&lt;Optional&lt;FontSelectionValue&gt;&gt;(CSSPropertyFontStyle, &amp;RenderStyle::fontItalic, &amp;RenderStyle::setFontItalic)
1467     {
1468     }
1469 
1470     bool canInterpolate(const RenderStyle* from, const RenderStyle* to) const override
1471     {
1472         return from-&gt;fontItalic() &amp;&amp; to-&gt;fontItalic() &amp;&amp; from-&gt;fontDescription().fontStyleAxis() == FontStyleAxis::slnt &amp;&amp; to-&gt;fontDescription().fontStyleAxis() == FontStyleAxis::slnt;
1473     }
1474 
1475     void blend(const CSSPropertyBlendingClient* anim, RenderStyle* dst, const RenderStyle* from, const RenderStyle* to, double progress) const override
1476     {
1477         auto discrete = !canInterpolate(from, to);
1478 
1479         auto blendedStyleAxis = FontStyleAxis::slnt;
1480         if (discrete)
1481             blendedStyleAxis = (progress &lt; 0.5 ? from : to)-&gt;fontDescription().fontStyleAxis();
1482 
1483         auto fromFontItalic = from-&gt;fontItalic();
1484         auto toFontItalic = to-&gt;fontItalic();
1485         auto blendedFontItalic = progress &lt; 0.5 ? fromFontItalic : toFontItalic;
1486         if (!discrete)
1487             blendedFontItalic = blendFunc(anim, fromFontItalic, toFontItalic, progress);
1488 
1489         FontSelector* currentFontSelector = dst-&gt;fontCascade().fontSelector();
1490         auto description = dst-&gt;fontDescription();
1491         description.setItalic(blendedFontItalic);
1492         description.setFontStyleAxis(blendedStyleAxis);
1493         dst-&gt;setFontDescription(WTFMove(description));
1494         dst-&gt;fontCascade().update(currentFontSelector);
1495     }
1496 };
1497 
1498 class CSSPropertyAnimationWrapperMap {
1499     WTF_MAKE_FAST_ALLOCATED;
1500 public:
1501     static CSSPropertyAnimationWrapperMap&amp; singleton()
1502     {
1503         // FIXME: This data is never destroyed. Maybe we should ref count it and toss it when the last CSSAnimationController is destroyed?
1504         static NeverDestroyed&lt;CSSPropertyAnimationWrapperMap&gt; map;
1505         return map;
1506     }
1507 
1508     AnimationPropertyWrapperBase* wrapperForProperty(CSSPropertyID propertyID)
1509     {
1510         if (propertyID &lt; firstCSSProperty || propertyID &gt; lastCSSProperty)
1511             return nullptr;
1512 
1513         unsigned wrapperIndex = indexFromPropertyID(propertyID);
1514         if (wrapperIndex == cInvalidPropertyWrapperIndex)
1515             return nullptr;
1516 
1517         return m_propertyWrappers[wrapperIndex].get();
1518     }
1519 
1520     AnimationPropertyWrapperBase* wrapperForIndex(unsigned index)
1521     {
1522         ASSERT(index &lt; m_propertyWrappers.size());
1523         return m_propertyWrappers[index].get();
1524     }
1525 
1526     unsigned size()
1527     {
1528         return m_propertyWrappers.size();
1529     }
1530 
1531 private:
1532     CSSPropertyAnimationWrapperMap();
1533     ~CSSPropertyAnimationWrapperMap() = delete;
1534 
1535     unsigned char&amp; indexFromPropertyID(CSSPropertyID propertyID)
1536     {
1537         return m_propertyToIdMap[propertyID - firstCSSProperty];
1538     }
1539 
1540     Vector&lt;std::unique_ptr&lt;AnimationPropertyWrapperBase&gt;&gt; m_propertyWrappers;
1541     unsigned char m_propertyToIdMap[numCSSProperties];
1542 
1543     static const unsigned char cInvalidPropertyWrapperIndex = UCHAR_MAX;
1544 
1545     friend class WTF::NeverDestroyed&lt;CSSPropertyAnimationWrapperMap&gt;;
1546 };
1547 
1548 CSSPropertyAnimationWrapperMap::CSSPropertyAnimationWrapperMap()
1549 {
1550     // build the list of property wrappers to do the comparisons and blends
1551     AnimationPropertyWrapperBase* animatableLonghandPropertyWrappers[] = {
1552         new LengthPropertyWrapper(CSSPropertyLeft, &amp;RenderStyle::left, &amp;RenderStyle::setLeft),
1553         new LengthPropertyWrapper(CSSPropertyRight, &amp;RenderStyle::right, &amp;RenderStyle::setRight),
1554         new LengthPropertyWrapper(CSSPropertyTop, &amp;RenderStyle::top, &amp;RenderStyle::setTop),
1555         new LengthPropertyWrapper(CSSPropertyBottom, &amp;RenderStyle::bottom, &amp;RenderStyle::setBottom),
1556 
1557         new LengthPropertyWrapper(CSSPropertyWidth, &amp;RenderStyle::width, &amp;RenderStyle::setWidth),
1558         new LengthPropertyWrapper(CSSPropertyMinWidth, &amp;RenderStyle::minWidth, &amp;RenderStyle::setMinWidth),
1559         new LengthPropertyWrapper(CSSPropertyMaxWidth, &amp;RenderStyle::maxWidth, &amp;RenderStyle::setMaxWidth),
1560 
1561         new LengthPropertyWrapper(CSSPropertyHeight, &amp;RenderStyle::height, &amp;RenderStyle::setHeight),
1562         new LengthPropertyWrapper(CSSPropertyMinHeight, &amp;RenderStyle::minHeight, &amp;RenderStyle::setMinHeight),
1563         new LengthPropertyWrapper(CSSPropertyMaxHeight, &amp;RenderStyle::maxHeight, &amp;RenderStyle::setMaxHeight),
1564 
1565         new PropertyWrapperFlex(),
1566 
1567         new PropertyWrapper&lt;float&gt;(CSSPropertyBorderLeftWidth, &amp;RenderStyle::borderLeftWidth, &amp;RenderStyle::setBorderLeftWidth),
1568         new PropertyWrapper&lt;float&gt;(CSSPropertyBorderRightWidth, &amp;RenderStyle::borderRightWidth, &amp;RenderStyle::setBorderRightWidth),
1569         new PropertyWrapper&lt;float&gt;(CSSPropertyBorderTopWidth, &amp;RenderStyle::borderTopWidth, &amp;RenderStyle::setBorderTopWidth),
1570         new PropertyWrapper&lt;float&gt;(CSSPropertyBorderBottomWidth, &amp;RenderStyle::borderBottomWidth, &amp;RenderStyle::setBorderBottomWidth),
1571         new LengthPropertyWrapper(CSSPropertyMarginLeft, &amp;RenderStyle::marginLeft, &amp;RenderStyle::setMarginLeft),
1572         new LengthPropertyWrapper(CSSPropertyMarginRight, &amp;RenderStyle::marginRight, &amp;RenderStyle::setMarginRight),
1573         new LengthPropertyWrapper(CSSPropertyMarginTop, &amp;RenderStyle::marginTop, &amp;RenderStyle::setMarginTop),
1574         new LengthPropertyWrapper(CSSPropertyMarginBottom, &amp;RenderStyle::marginBottom, &amp;RenderStyle::setMarginBottom),
1575         new LengthPropertyWrapper(CSSPropertyPaddingLeft, &amp;RenderStyle::paddingLeft, &amp;RenderStyle::setPaddingLeft),
1576         new LengthPropertyWrapper(CSSPropertyPaddingRight, &amp;RenderStyle::paddingRight, &amp;RenderStyle::setPaddingRight),
1577         new LengthPropertyWrapper(CSSPropertyPaddingTop, &amp;RenderStyle::paddingTop, &amp;RenderStyle::setPaddingTop),
1578         new LengthPropertyWrapper(CSSPropertyPaddingBottom, &amp;RenderStyle::paddingBottom, &amp;RenderStyle::setPaddingBottom),
1579 
1580         new PropertyWrapperVisitedAffectedColor(CSSPropertyCaretColor, &amp;RenderStyle::caretColor, &amp;RenderStyle::setCaretColor, &amp;RenderStyle::visitedLinkCaretColor, &amp;RenderStyle::setVisitedLinkCaretColor),
1581 
1582         new PropertyWrapperVisitedAffectedColor(CSSPropertyColor, &amp;RenderStyle::color, &amp;RenderStyle::setColor, &amp;RenderStyle::visitedLinkColor, &amp;RenderStyle::setVisitedLinkColor),
1583 
1584         new PropertyWrapperVisitedAffectedColor(CSSPropertyBackgroundColor, &amp;RenderStyle::backgroundColor, &amp;RenderStyle::setBackgroundColor, &amp;RenderStyle::visitedLinkBackgroundColor, &amp;RenderStyle::setVisitedLinkBackgroundColor),
1585 
1586         new FillLayersPropertyWrapper(CSSPropertyBackgroundImage, &amp;RenderStyle::backgroundLayers, &amp;RenderStyle::ensureBackgroundLayers),
1587         new StyleImagePropertyWrapper(CSSPropertyListStyleImage, &amp;RenderStyle::listStyleImage, &amp;RenderStyle::setListStyleImage),
1588         new StyleImagePropertyWrapper(CSSPropertyWebkitMaskImage, &amp;RenderStyle::maskImage, &amp;RenderStyle::setMaskImage),
1589 
1590         new StyleImagePropertyWrapper(CSSPropertyBorderImageSource, &amp;RenderStyle::borderImageSource, &amp;RenderStyle::setBorderImageSource),
1591         new LengthVariantPropertyWrapper&lt;LengthBox&gt;(CSSPropertyBorderImageSlice, &amp;RenderStyle::borderImageSlices, &amp;RenderStyle::setBorderImageSlices),
1592         new LengthVariantPropertyWrapper&lt;LengthBox&gt;(CSSPropertyBorderImageWidth, &amp;RenderStyle::borderImageWidth, &amp;RenderStyle::setBorderImageWidth),
1593         new LengthVariantPropertyWrapper&lt;LengthBox&gt;(CSSPropertyBorderImageOutset, &amp;RenderStyle::borderImageOutset, &amp;RenderStyle::setBorderImageOutset),
1594 
1595         new StyleImagePropertyWrapper(CSSPropertyWebkitMaskBoxImageSource, &amp;RenderStyle::maskBoxImageSource, &amp;RenderStyle::setMaskBoxImageSource),
1596         new PropertyWrapper&lt;const NinePieceImage&amp;&gt;(CSSPropertyWebkitMaskBoxImage, &amp;RenderStyle::maskBoxImage, &amp;RenderStyle::setMaskBoxImage),
1597 
1598         new FillLayersPropertyWrapper(CSSPropertyBackgroundPositionX, &amp;RenderStyle::backgroundLayers, &amp;RenderStyle::ensureBackgroundLayers),
1599         new FillLayersPropertyWrapper(CSSPropertyBackgroundPositionY, &amp;RenderStyle::backgroundLayers, &amp;RenderStyle::ensureBackgroundLayers),
1600         new FillLayersPropertyWrapper(CSSPropertyBackgroundSize, &amp;RenderStyle::backgroundLayers, &amp;RenderStyle::ensureBackgroundLayers),
1601         new FillLayersPropertyWrapper(CSSPropertyWebkitBackgroundSize, &amp;RenderStyle::backgroundLayers, &amp;RenderStyle::ensureBackgroundLayers),
1602 
1603         new FillLayersPropertyWrapper(CSSPropertyWebkitMaskPositionX, &amp;RenderStyle::maskLayers, &amp;RenderStyle::ensureMaskLayers),
1604         new FillLayersPropertyWrapper(CSSPropertyWebkitMaskPositionY, &amp;RenderStyle::maskLayers, &amp;RenderStyle::ensureMaskLayers),
1605         new FillLayersPropertyWrapper(CSSPropertyWebkitMaskSize, &amp;RenderStyle::maskLayers, &amp;RenderStyle::ensureMaskLayers),
1606 
1607         new PropertyWrapper&lt;float&gt;(CSSPropertyFontSize, &amp;RenderStyle::computedFontSize, &amp;RenderStyle::setFontSize),
1608         new PropertyWrapper&lt;unsigned short&gt;(CSSPropertyColumnRuleWidth, &amp;RenderStyle::columnRuleWidth, &amp;RenderStyle::setColumnRuleWidth),
1609         new LengthVariantPropertyWrapper&lt;GapLength&gt;(CSSPropertyColumnGap, &amp;RenderStyle::columnGap, &amp;RenderStyle::setColumnGap),
1610         new LengthVariantPropertyWrapper&lt;GapLength&gt;(CSSPropertyRowGap, &amp;RenderStyle::rowGap, &amp;RenderStyle::setRowGap),
1611         new PropertyWrapper&lt;unsigned short&gt;(CSSPropertyColumnCount, &amp;RenderStyle::columnCount, &amp;RenderStyle::setColumnCount),
1612         new PropertyWrapper&lt;float&gt;(CSSPropertyColumnWidth, &amp;RenderStyle::columnWidth, &amp;RenderStyle::setColumnWidth),
1613         new PropertyWrapper&lt;float&gt;(CSSPropertyWebkitBorderHorizontalSpacing, &amp;RenderStyle::horizontalBorderSpacing, &amp;RenderStyle::setHorizontalBorderSpacing),
1614         new PropertyWrapper&lt;float&gt;(CSSPropertyWebkitBorderVerticalSpacing, &amp;RenderStyle::verticalBorderSpacing, &amp;RenderStyle::setVerticalBorderSpacing),
1615         new PropertyWrapper&lt;int&gt;(CSSPropertyZIndex, &amp;RenderStyle::zIndex, &amp;RenderStyle::setZIndex),
1616         new PropertyWrapper&lt;short&gt;(CSSPropertyOrphans, &amp;RenderStyle::orphans, &amp;RenderStyle::setOrphans),
1617         new PropertyWrapper&lt;short&gt;(CSSPropertyWidows, &amp;RenderStyle::widows, &amp;RenderStyle::setWidows),
1618         new LengthPropertyWrapper(CSSPropertyLineHeight, &amp;RenderStyle::specifiedLineHeight, &amp;RenderStyle::setLineHeight),
1619         new PropertyWrapper&lt;float&gt;(CSSPropertyOutlineOffset, &amp;RenderStyle::outlineOffset, &amp;RenderStyle::setOutlineOffset),
1620         new PropertyWrapper&lt;float&gt;(CSSPropertyOutlineWidth, &amp;RenderStyle::outlineWidth, &amp;RenderStyle::setOutlineWidth),
1621         new PropertyWrapper&lt;float&gt;(CSSPropertyLetterSpacing, &amp;RenderStyle::letterSpacing, &amp;RenderStyle::setLetterSpacing),
1622         new LengthPropertyWrapper(CSSPropertyWordSpacing, &amp;RenderStyle::wordSpacing, &amp;RenderStyle::setWordSpacing),
1623         new LengthPropertyWrapper(CSSPropertyTextIndent, &amp;RenderStyle::textIndent, &amp;RenderStyle::setTextIndent),
1624 
1625         new PropertyWrapper&lt;float&gt;(CSSPropertyPerspective, &amp;RenderStyle::perspective, &amp;RenderStyle::setPerspective),
1626         new LengthPropertyWrapper(CSSPropertyPerspectiveOriginX, &amp;RenderStyle::perspectiveOriginX, &amp;RenderStyle::setPerspectiveOriginX),
1627         new LengthPropertyWrapper(CSSPropertyPerspectiveOriginY, &amp;RenderStyle::perspectiveOriginY, &amp;RenderStyle::setPerspectiveOriginY),
1628         new LengthPropertyWrapper(CSSPropertyTransformOriginX, &amp;RenderStyle::transformOriginX, &amp;RenderStyle::setTransformOriginX),
1629         new LengthPropertyWrapper(CSSPropertyTransformOriginY, &amp;RenderStyle::transformOriginY, &amp;RenderStyle::setTransformOriginY),
1630         new PropertyWrapper&lt;float&gt;(CSSPropertyTransformOriginZ, &amp;RenderStyle::transformOriginZ, &amp;RenderStyle::setTransformOriginZ),
1631         new LengthVariantPropertyWrapper&lt;LengthSize&gt;(CSSPropertyBorderTopLeftRadius, &amp;RenderStyle::borderTopLeftRadius, &amp;RenderStyle::setBorderTopLeftRadius),
1632         new LengthVariantPropertyWrapper&lt;LengthSize&gt;(CSSPropertyBorderTopRightRadius, &amp;RenderStyle::borderTopRightRadius, &amp;RenderStyle::setBorderTopRightRadius),
1633         new LengthVariantPropertyWrapper&lt;LengthSize&gt;(CSSPropertyBorderBottomLeftRadius, &amp;RenderStyle::borderBottomLeftRadius, &amp;RenderStyle::setBorderBottomLeftRadius),
1634         new LengthVariantPropertyWrapper&lt;LengthSize&gt;(CSSPropertyBorderBottomRightRadius, &amp;RenderStyle::borderBottomRightRadius, &amp;RenderStyle::setBorderBottomRightRadius),
1635         new PropertyWrapper&lt;Visibility&gt;(CSSPropertyVisibility, &amp;RenderStyle::visibility, &amp;RenderStyle::setVisibility),
1636         new PropertyWrapper&lt;float&gt;(CSSPropertyZoom, &amp;RenderStyle::zoom, &amp;RenderStyle::setZoomWithoutReturnValue),
1637 
1638         new LengthVariantPropertyWrapper&lt;LengthBox&gt;(CSSPropertyClip, &amp;RenderStyle::clip, &amp;RenderStyle::setClip),
1639 
1640         new PropertyWrapperAcceleratedOpacity(),
1641         new PropertyWrapperAcceleratedTransform(),
1642 
1643         new PropertyWrapperFilter(CSSPropertyFilter, &amp;RenderStyle::filter, &amp;RenderStyle::setFilter),
1644 #if ENABLE(FILTERS_LEVEL_2)
1645         new PropertyWrapperFilter(CSSPropertyWebkitBackdropFilter, &amp;RenderStyle::backdropFilter, &amp;RenderStyle::setBackdropFilter),
1646 #endif
1647         new PropertyWrapperFilter(CSSPropertyAppleColorFilter, &amp;RenderStyle::appleColorFilter, &amp;RenderStyle::setAppleColorFilter),
1648 
1649         new PropertyWrapperClipPath(CSSPropertyWebkitClipPath, &amp;RenderStyle::clipPath, &amp;RenderStyle::setClipPath),
1650 
1651         new PropertyWrapperShape(CSSPropertyShapeOutside, &amp;RenderStyle::shapeOutside, &amp;RenderStyle::setShapeOutside),
1652         new LengthPropertyWrapper(CSSPropertyShapeMargin, &amp;RenderStyle::shapeMargin, &amp;RenderStyle::setShapeMargin),
1653         new PropertyWrapper&lt;float&gt;(CSSPropertyShapeImageThreshold, &amp;RenderStyle::shapeImageThreshold, &amp;RenderStyle::setShapeImageThreshold),
1654 
1655         new PropertyWrapperVisitedAffectedColor(CSSPropertyColumnRuleColor, MaybeInvalidColor, &amp;RenderStyle::columnRuleColor, &amp;RenderStyle::setColumnRuleColor, &amp;RenderStyle::visitedLinkColumnRuleColor, &amp;RenderStyle::setVisitedLinkColumnRuleColor),
1656         new PropertyWrapperVisitedAffectedColor(CSSPropertyWebkitTextStrokeColor, MaybeInvalidColor, &amp;RenderStyle::textStrokeColor, &amp;RenderStyle::setTextStrokeColor, &amp;RenderStyle::visitedLinkTextStrokeColor, &amp;RenderStyle::setVisitedLinkTextStrokeColor),
1657         new PropertyWrapperVisitedAffectedColor(CSSPropertyWebkitTextFillColor, MaybeInvalidColor, &amp;RenderStyle::textFillColor, &amp;RenderStyle::setTextFillColor, &amp;RenderStyle::visitedLinkTextFillColor, &amp;RenderStyle::setVisitedLinkTextFillColor),
1658         new PropertyWrapperVisitedAffectedColor(CSSPropertyBorderLeftColor, MaybeInvalidColor, &amp;RenderStyle::borderLeftColor, &amp;RenderStyle::setBorderLeftColor, &amp;RenderStyle::visitedLinkBorderLeftColor, &amp;RenderStyle::setVisitedLinkBorderLeftColor),
1659         new PropertyWrapperVisitedAffectedColor(CSSPropertyBorderRightColor, MaybeInvalidColor, &amp;RenderStyle::borderRightColor, &amp;RenderStyle::setBorderRightColor, &amp;RenderStyle::visitedLinkBorderRightColor, &amp;RenderStyle::setVisitedLinkBorderRightColor),
1660         new PropertyWrapperVisitedAffectedColor(CSSPropertyBorderTopColor, MaybeInvalidColor, &amp;RenderStyle::borderTopColor, &amp;RenderStyle::setBorderTopColor, &amp;RenderStyle::visitedLinkBorderTopColor, &amp;RenderStyle::setVisitedLinkBorderTopColor),
1661         new PropertyWrapperVisitedAffectedColor(CSSPropertyBorderBottomColor, MaybeInvalidColor, &amp;RenderStyle::borderBottomColor, &amp;RenderStyle::setBorderBottomColor, &amp;RenderStyle::visitedLinkBorderBottomColor, &amp;RenderStyle::setVisitedLinkBorderBottomColor),
1662         new PropertyWrapperVisitedAffectedColor(CSSPropertyOutlineColor, MaybeInvalidColor, &amp;RenderStyle::outlineColor, &amp;RenderStyle::setOutlineColor, &amp;RenderStyle::visitedLinkOutlineColor, &amp;RenderStyle::setVisitedLinkOutlineColor),
1663 
1664         new PropertyWrapperShadow(CSSPropertyBoxShadow, &amp;RenderStyle::boxShadow, &amp;RenderStyle::setBoxShadow),
1665         new PropertyWrapperShadow(CSSPropertyWebkitBoxShadow, &amp;RenderStyle::boxShadow, &amp;RenderStyle::setBoxShadow),
1666         new PropertyWrapperShadow(CSSPropertyTextShadow, &amp;RenderStyle::textShadow, &amp;RenderStyle::setTextShadow),
1667 
1668         new PropertyWrapperSVGPaint(CSSPropertyFill, &amp;RenderStyle::fillPaintType, &amp;RenderStyle::fillPaintColor, &amp;RenderStyle::setFillPaintColor),
1669         new PropertyWrapper&lt;float&gt;(CSSPropertyFillOpacity, &amp;RenderStyle::fillOpacity, &amp;RenderStyle::setFillOpacity),
1670 
1671         new PropertyWrapperSVGPaint(CSSPropertyStroke, &amp;RenderStyle::strokePaintType, &amp;RenderStyle::strokePaintColor, &amp;RenderStyle::setStrokePaintColor),
1672         new PropertyWrapper&lt;float&gt;(CSSPropertyStrokeOpacity, &amp;RenderStyle::strokeOpacity, &amp;RenderStyle::setStrokeOpacity),
1673         new PropertyWrapper&lt;Vector&lt;SVGLengthValue&gt;&gt;(CSSPropertyStrokeDasharray, &amp;RenderStyle::strokeDashArray, &amp;RenderStyle::setStrokeDashArray),
1674         new PropertyWrapper&lt;float&gt;(CSSPropertyStrokeMiterlimit, &amp;RenderStyle::strokeMiterLimit, &amp;RenderStyle::setStrokeMiterLimit),
1675 
1676         new LengthPropertyWrapper(CSSPropertyCx, &amp;RenderStyle::cx, &amp;RenderStyle::setCx),
1677         new LengthPropertyWrapper(CSSPropertyCy, &amp;RenderStyle::cy, &amp;RenderStyle::setCy),
1678         new LengthPropertyWrapper(CSSPropertyR, &amp;RenderStyle::r, &amp;RenderStyle::setR),
1679         new LengthPropertyWrapper(CSSPropertyRx, &amp;RenderStyle::rx, &amp;RenderStyle::setRx),
1680         new LengthPropertyWrapper(CSSPropertyRy, &amp;RenderStyle::ry, &amp;RenderStyle::setRy),
1681         new LengthPropertyWrapper(CSSPropertyStrokeDashoffset, &amp;RenderStyle::strokeDashOffset, &amp;RenderStyle::setStrokeDashOffset),
1682         new LengthPropertyWrapper(CSSPropertyStrokeWidth, &amp;RenderStyle::strokeWidth, &amp;RenderStyle::setStrokeWidth),
1683         new LengthPropertyWrapper(CSSPropertyX, &amp;RenderStyle::x, &amp;RenderStyle::setX),
1684         new LengthPropertyWrapper(CSSPropertyY, &amp;RenderStyle::y, &amp;RenderStyle::setY),
1685 
1686         new PropertyWrapper&lt;float&gt;(CSSPropertyFloodOpacity, &amp;RenderStyle::floodOpacity, &amp;RenderStyle::setFloodOpacity),
1687         new PropertyWrapperMaybeInvalidColor(CSSPropertyFloodColor, &amp;RenderStyle::floodColor, &amp;RenderStyle::setFloodColor),
1688 
1689         new PropertyWrapper&lt;float&gt;(CSSPropertyStopOpacity, &amp;RenderStyle::stopOpacity, &amp;RenderStyle::setStopOpacity),
1690         new PropertyWrapperMaybeInvalidColor(CSSPropertyStopColor, &amp;RenderStyle::stopColor, &amp;RenderStyle::setStopColor),
1691 
1692         new PropertyWrapperMaybeInvalidColor(CSSPropertyLightingColor, &amp;RenderStyle::lightingColor, &amp;RenderStyle::setLightingColor),
1693 
1694         new PropertyWrapper&lt;SVGLengthValue&gt;(CSSPropertyBaselineShift, &amp;RenderStyle::baselineShiftValue, &amp;RenderStyle::setBaselineShiftValue),
1695         new PropertyWrapper&lt;SVGLengthValue&gt;(CSSPropertyKerning, &amp;RenderStyle::kerning, &amp;RenderStyle::setKerning),
1696 #if ENABLE(VARIATION_FONTS)
1697         new PropertyWrapperFontVariationSettings(CSSPropertyFontVariationSettings, &amp;RenderStyle::fontVariationSettings, &amp;RenderStyle::setFontVariationSettings),
1698 #endif
1699         new PropertyWrapper&lt;FontSelectionValue&gt;(CSSPropertyFontWeight, &amp;RenderStyle::fontWeight, &amp;RenderStyle::setFontWeight),
1700         new PropertyWrapper&lt;FontSelectionValue&gt;(CSSPropertyFontStretch, &amp;RenderStyle::fontStretch, &amp;RenderStyle::setFontStretch),
1701         new PropertyWrapperFontStyle(),
1702         new PropertyWrapper&lt;TextDecorationThickness&gt;(CSSPropertyTextDecorationThickness, &amp;RenderStyle::textDecorationThickness, &amp;RenderStyle::setTextDecorationThickness),
1703         new PropertyWrapper&lt;TextUnderlineOffset&gt;(CSSPropertyTextUnderlineOffset, &amp;RenderStyle::textUnderlineOffset, &amp;RenderStyle::setTextUnderlineOffset),
1704     };
1705     const unsigned animatableLonghandPropertiesCount = WTF_ARRAY_LENGTH(animatableLonghandPropertyWrappers);
1706 
1707     static const CSSPropertyID animatableShorthandProperties[] = {
1708         CSSPropertyBackground, // for background-color, background-position, background-image
1709         CSSPropertyBackgroundPosition,
1710         CSSPropertyFont, // for font-size, font-weight
1711         CSSPropertyWebkitMask, // for mask-position
1712         CSSPropertyWebkitMaskPosition,
1713         CSSPropertyBorderTop, CSSPropertyBorderRight, CSSPropertyBorderBottom, CSSPropertyBorderLeft,
1714         CSSPropertyBorderColor,
1715         CSSPropertyBorderRadius,
1716         CSSPropertyBorderWidth,
1717         CSSPropertyBorder,
1718         CSSPropertyBorderImage,
1719         CSSPropertyBorderSpacing,
1720         CSSPropertyListStyle, // for list-style-image
1721         CSSPropertyMargin,
1722         CSSPropertyOutline,
1723         CSSPropertyPadding,
1724         CSSPropertyWebkitTextStroke,
1725         CSSPropertyColumnRule,
1726         CSSPropertyWebkitBorderRadius,
1727         CSSPropertyTransformOrigin
1728     };
1729     const unsigned animatableShorthandPropertiesCount = WTF_ARRAY_LENGTH(animatableShorthandProperties);
1730 
1731     // TODO:
1732     //
1733     //  CSSPropertyVerticalAlign
1734     //
1735     // Compound properties that have components that should be animatable:
1736     //
1737     //  CSSPropertyColumns
1738     //  CSSPropertyWebkitBoxReflect
1739 
1740     // Make sure unused slots have a value
1741     for (int i = 0; i &lt; numCSSProperties; ++i)
1742         m_propertyToIdMap[i] = cInvalidPropertyWrapperIndex;
1743 
1744     COMPILE_ASSERT(animatableLonghandPropertiesCount + animatableShorthandPropertiesCount &lt; UCHAR_MAX, numberOfAnimatablePropertiesMustBeLessThanUCharMax);
1745     m_propertyWrappers.reserveInitialCapacity(animatableLonghandPropertiesCount + animatableShorthandPropertiesCount);
1746 
1747     // First we put the non-shorthand property wrappers into the map, so the shorthand-building
1748     // code can find them.
1749 
1750     for (unsigned i = 0; i &lt; animatableLonghandPropertiesCount; ++i) {
1751         AnimationPropertyWrapperBase* wrapper = animatableLonghandPropertyWrappers[i];
1752         m_propertyWrappers.uncheckedAppend(std::unique_ptr&lt;AnimationPropertyWrapperBase&gt;(wrapper));
1753         indexFromPropertyID(wrapper-&gt;property()) = i;
1754     }
1755 
1756     for (size_t i = 0; i &lt; animatableShorthandPropertiesCount; ++i) {
1757         CSSPropertyID propertyID = animatableShorthandProperties[i];
1758         StylePropertyShorthand shorthand = shorthandForProperty(propertyID);
1759         if (!shorthand.length())
1760             continue;
1761 
1762         Vector&lt;AnimationPropertyWrapperBase*&gt; longhandWrappers;
1763         longhandWrappers.reserveInitialCapacity(shorthand.length());
1764         const CSSPropertyID* properties = shorthand.properties();
1765         for (unsigned j = 0; j &lt; shorthand.length(); ++j) {
1766             unsigned wrapperIndex = indexFromPropertyID(properties[j]);
1767             if (wrapperIndex == cInvalidPropertyWrapperIndex)
1768                 continue;
1769             ASSERT(m_propertyWrappers[wrapperIndex]);
1770             longhandWrappers.uncheckedAppend(m_propertyWrappers[wrapperIndex].get());
1771         }
1772 
<a name="10" id="anc10"></a><span class="line-modified">1773         m_propertyWrappers.uncheckedAppend(std::make_unique&lt;ShorthandPropertyWrapper&gt;(propertyID, WTFMove(longhandWrappers)));</span>
1774         indexFromPropertyID(propertyID) = animatableLonghandPropertiesCount + i;
1775     }
1776 }
1777 
1778 static bool gatherEnclosingShorthandProperties(CSSPropertyID property, AnimationPropertyWrapperBase* wrapper, HashSet&lt;CSSPropertyID&gt;&amp; propertySet)
1779 {
1780     if (!wrapper-&gt;isShorthandWrapper())
1781         return false;
1782 
1783     ShorthandPropertyWrapper* shorthandWrapper = static_cast&lt;ShorthandPropertyWrapper*&gt;(wrapper);
1784     bool contained = false;
1785     for (auto&amp; currWrapper : shorthandWrapper-&gt;propertyWrappers()) {
1786         if (gatherEnclosingShorthandProperties(property, currWrapper, propertySet) || currWrapper-&gt;property() == property)
1787             contained = true;
1788     }
1789 
1790     if (contained)
1791         propertySet.add(wrapper-&gt;property());
1792 
1793     return contained;
1794 }
1795 
1796 // Returns true if we need to start animation timers
1797 bool CSSPropertyAnimation::blendProperties(const CSSPropertyBlendingClient* anim, CSSPropertyID prop, RenderStyle* dst, const RenderStyle* a, const RenderStyle* b, double progress)
1798 {
1799     ASSERT(prop != CSSPropertyInvalid);
1800 
1801     AnimationPropertyWrapperBase* wrapper = CSSPropertyAnimationWrapperMap::singleton().wrapperForProperty(prop);
1802     if (wrapper) {
1803         wrapper-&gt;blend(anim, dst, a, b, progress);
1804 #if !LOG_DISABLED
1805         wrapper-&gt;logBlend(a, b, dst, progress);
1806 #endif
1807         return !wrapper-&gt;animationIsAccelerated() || !anim-&gt;isAccelerated();
1808     }
1809     return false;
1810 }
1811 
1812 bool CSSPropertyAnimation::isPropertyAnimatable(CSSPropertyID prop)
1813 {
1814     return CSSPropertyAnimationWrapperMap::singleton().wrapperForProperty(prop);
1815 }
1816 
1817 bool CSSPropertyAnimation::animationOfPropertyIsAccelerated(CSSPropertyID prop)
1818 {
1819     AnimationPropertyWrapperBase* wrapper = CSSPropertyAnimationWrapperMap::singleton().wrapperForProperty(prop);
1820     return wrapper ? wrapper-&gt;animationIsAccelerated() : false;
1821 }
1822 
1823 // Note: this is inefficient. It&#39;s only called from pauseTransitionAtTime().
1824 HashSet&lt;CSSPropertyID&gt; CSSPropertyAnimation::animatableShorthandsAffectingProperty(CSSPropertyID property)
1825 {
1826     CSSPropertyAnimationWrapperMap&amp; map = CSSPropertyAnimationWrapperMap::singleton();
1827 
1828     HashSet&lt;CSSPropertyID&gt; foundProperties;
1829     for (unsigned i = 0; i &lt; map.size(); ++i)
1830         gatherEnclosingShorthandProperties(property, map.wrapperForIndex(i), foundProperties);
1831 
1832     return foundProperties;
1833 }
1834 
1835 bool CSSPropertyAnimation::propertiesEqual(CSSPropertyID prop, const RenderStyle* a, const RenderStyle* b)
1836 {
1837     AnimationPropertyWrapperBase* wrapper = CSSPropertyAnimationWrapperMap::singleton().wrapperForProperty(prop);
1838     if (wrapper)
1839         return wrapper-&gt;equals(a, b);
1840     return true;
1841 }
1842 
1843 bool CSSPropertyAnimation::canPropertyBeInterpolated(CSSPropertyID prop, const RenderStyle* a, const RenderStyle* b)
1844 {
1845     AnimationPropertyWrapperBase* wrapper = CSSPropertyAnimationWrapperMap::singleton().wrapperForProperty(prop);
1846     if (wrapper)
1847         return wrapper-&gt;canInterpolate(a, b);
1848     return false;
1849 }
1850 
1851 CSSPropertyID CSSPropertyAnimation::getPropertyAtIndex(int i, Optional&lt;bool&gt;&amp; isShorthand)
1852 {
1853     CSSPropertyAnimationWrapperMap&amp; map = CSSPropertyAnimationWrapperMap::singleton();
1854 
1855     if (i &lt; 0 || static_cast&lt;unsigned&gt;(i) &gt;= map.size())
1856         return CSSPropertyInvalid;
1857 
1858     AnimationPropertyWrapperBase* wrapper = map.wrapperForIndex(i);
1859     isShorthand = wrapper-&gt;isShorthandWrapper();
1860     return wrapper-&gt;property();
1861 }
1862 
1863 int CSSPropertyAnimation::getNumProperties()
1864 {
1865     return CSSPropertyAnimationWrapperMap::singleton().size();
1866 }
1867 
1868 }
<a name="11" id="anc11"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="11" type="hidden" />
</body>
</html>