<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/editing/markup.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2004-2017 Apple Inc. All rights reserved.
   3  * Copyright (C) 2008, 2009, 2010, 2011 Google Inc. All rights reserved.
   4  * Copyright (C) 2011 Igalia S.L.
   5  * Copyright (C) 2011 Motorola Mobility. All rights reserved.
   6  *
   7  * Redistribution and use in source and binary forms, with or without
   8  * modification, are permitted provided that the following conditions
   9  * are met:
  10  * 1. Redistributions of source code must retain the above copyright
  11  *    notice, this list of conditions and the following disclaimer.
  12  * 2. Redistributions in binary form must reproduce the above copyright
  13  *    notice, this list of conditions and the following disclaimer in the
  14  *    documentation and/or other materials provided with the distribution.
  15  *
  16  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  17  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  18  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  19  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  20  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  21  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  22  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  23  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  24  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  25  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  26  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  27  */
  28 
  29 #include &quot;config.h&quot;
  30 #include &quot;markup.h&quot;
  31 
  32 #include &quot;ArchiveResource.h&quot;
  33 #include &quot;CSSPrimitiveValue.h&quot;
  34 #include &quot;CSSPropertyNames.h&quot;
  35 #include &quot;CSSValue.h&quot;
  36 #include &quot;CSSValueKeywords.h&quot;
  37 #include &quot;CacheStorageProvider.h&quot;
  38 #include &quot;ChildListMutationScope.h&quot;
  39 #include &quot;Comment.h&quot;
  40 #include &quot;ComposedTreeIterator.h&quot;
<a name="1" id="anc1"></a><span class="line-added">  41 #include &quot;CustomHeaderFields.h&quot;</span>
  42 #include &quot;DocumentFragment.h&quot;
  43 #include &quot;DocumentLoader.h&quot;
  44 #include &quot;DocumentType.h&quot;
  45 #include &quot;Editing.h&quot;
  46 #include &quot;Editor.h&quot;
  47 #include &quot;EditorClient.h&quot;
  48 #include &quot;ElementIterator.h&quot;
  49 #include &quot;EmptyClients.h&quot;
  50 #include &quot;File.h&quot;
  51 #include &quot;Frame.h&quot;
  52 #include &quot;FrameLoader.h&quot;
  53 #include &quot;HTMLAttachmentElement.h&quot;
  54 #include &quot;HTMLBRElement.h&quot;
  55 #include &quot;HTMLBodyElement.h&quot;
  56 #include &quot;HTMLDivElement.h&quot;
  57 #include &quot;HTMLHeadElement.h&quot;
  58 #include &quot;HTMLHtmlElement.h&quot;
  59 #include &quot;HTMLImageElement.h&quot;
  60 #include &quot;HTMLNames.h&quot;
  61 #include &quot;HTMLStyleElement.h&quot;
  62 #include &quot;HTMLTableElement.h&quot;
  63 #include &quot;HTMLTextAreaElement.h&quot;
  64 #include &quot;HTMLTextFormControlElement.h&quot;
  65 #include &quot;LibWebRTCProvider.h&quot;
  66 #include &quot;MarkupAccumulator.h&quot;
  67 #include &quot;NodeList.h&quot;
  68 #include &quot;Page.h&quot;
  69 #include &quot;PageConfiguration.h&quot;
<a name="2" id="anc2"></a><span class="line-added">  70 #include &quot;PasteboardItemInfo.h&quot;</span>
  71 #include &quot;Range.h&quot;
  72 #include &quot;RenderBlock.h&quot;
  73 #include &quot;RuntimeEnabledFeatures.h&quot;
  74 #include &quot;Settings.h&quot;
  75 #include &quot;SocketProvider.h&quot;
  76 #include &quot;StyleProperties.h&quot;
  77 #include &quot;TextIterator.h&quot;
  78 #include &quot;TypedElementDescendantIterator.h&quot;
  79 #include &quot;VisibleSelection.h&quot;
  80 #include &quot;VisibleUnits.h&quot;
  81 #include &lt;wtf/StdLibExtras.h&gt;
  82 #include &lt;wtf/URL.h&gt;
  83 #include &lt;wtf/URLParser.h&gt;
  84 #include &lt;wtf/text/StringBuilder.h&gt;
  85 
  86 namespace WebCore {
  87 
  88 using namespace HTMLNames;
  89 
  90 static bool propertyMissingOrEqualToNone(StyleProperties*, CSSPropertyID);
  91 
  92 class AttributeChange {
  93 public:
  94     AttributeChange()
  95         : m_name(nullAtom(), nullAtom(), nullAtom())
  96     {
  97     }
  98 
  99     AttributeChange(Element* element, const QualifiedName&amp; name, const String&amp; value)
 100         : m_element(element), m_name(name), m_value(value)
 101     {
 102     }
 103 
 104     void apply()
 105     {
 106         m_element-&gt;setAttribute(m_name, m_value);
 107     }
 108 
 109 private:
 110     RefPtr&lt;Element&gt; m_element;
 111     QualifiedName m_name;
 112     String m_value;
 113 };
 114 
 115 static void completeURLs(DocumentFragment* fragment, const String&amp; baseURL)
 116 {
 117     Vector&lt;AttributeChange&gt; changes;
 118 
 119     URL parsedBaseURL({ }, baseURL);
 120 
 121     for (auto&amp; element : descendantsOfType&lt;Element&gt;(*fragment)) {
 122         if (!element.hasAttributes())
 123             continue;
 124         for (const Attribute&amp; attribute : element.attributesIterator()) {
 125             if (element.attributeContainsURL(attribute) &amp;&amp; !attribute.value().isEmpty())
 126                 changes.append(AttributeChange(&amp;element, attribute.name(), element.completeURLsInAttributeValue(parsedBaseURL, attribute)));
 127         }
 128     }
 129 
 130     for (auto&amp; change : changes)
 131         change.apply();
 132 }
 133 
<a name="3" id="anc3"></a><span class="line-modified"> 134 void replaceSubresourceURLs(Ref&lt;DocumentFragment&gt;&amp;&amp; fragment, HashMap&lt;AtomString, AtomString&gt;&amp;&amp; replacementMap)</span>
 135 {
 136     Vector&lt;AttributeChange&gt; changes;
 137     for (auto&amp; element : descendantsOfType&lt;Element&gt;(fragment)) {
 138         if (!element.hasAttributes())
 139             continue;
 140         for (const Attribute&amp; attribute : element.attributesIterator()) {
 141             // FIXME: This won&#39;t work for srcset.
 142             if (element.attributeContainsURL(attribute) &amp;&amp; !attribute.value().isEmpty()) {
 143                 auto replacement = replacementMap.get(attribute.value());
 144                 if (!replacement.isNull())
 145                     changes.append({ &amp;element, attribute.name(), replacement });
 146             }
 147         }
 148     }
 149     for (auto&amp; change : changes)
 150         change.apply();
 151 }
 152 
 153 struct ElementAttribute {
 154     Ref&lt;Element&gt; element;
 155     QualifiedName attributeName;
 156 };
 157 
 158 void removeSubresourceURLAttributes(Ref&lt;DocumentFragment&gt;&amp;&amp; fragment, WTF::Function&lt;bool(const URL&amp;)&gt; shouldRemoveURL)
 159 {
 160     Vector&lt;ElementAttribute&gt; attributesToRemove;
 161     for (auto&amp; element : descendantsOfType&lt;Element&gt;(fragment)) {
 162         if (!element.hasAttributes())
 163             continue;
 164         for (const Attribute&amp; attribute : element.attributesIterator()) {
 165             // FIXME: This won&#39;t work for srcset.
 166             if (element.attributeContainsURL(attribute) &amp;&amp; !attribute.value().isEmpty()) {
 167                 URL url({ }, attribute.value());
 168                 if (shouldRemoveURL(url))
 169                     attributesToRemove.append({ element, attribute.name() });
 170             }
 171         }
 172     }
 173     for (auto&amp; item : attributesToRemove)
 174         item.element-&gt;removeAttribute(item.attributeName);
 175 }
 176 
 177 std::unique_ptr&lt;Page&gt; createPageForSanitizingWebContent()
 178 {
 179     auto pageConfiguration = pageConfigurationWithEmptyClients();
 180 
<a name="4" id="anc4"></a><span class="line-modified"> 181     auto page = makeUnique&lt;Page&gt;(WTFMove(pageConfiguration));</span>
<span class="line-added"> 182     page-&gt;setIsForSanitizingWebContent();</span>
 183     page-&gt;settings().setMediaEnabled(false);
 184     page-&gt;settings().setScriptEnabled(false);
 185     page-&gt;settings().setPluginsEnabled(false);
 186     page-&gt;settings().setAcceleratedCompositingEnabled(false);
 187 
 188     Frame&amp; frame = page-&gt;mainFrame();
<a name="5" id="anc5"></a><span class="line-modified"> 189     frame.setView(FrameView::create(frame, IntSize { 800, 600 }));</span>
 190     frame.init();
 191 
 192     FrameLoader&amp; loader = frame.loader();
 193     static char markup[] = &quot;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;&quot;;
 194     ASSERT(loader.activeDocumentLoader());
 195     auto&amp; writer = loader.activeDocumentLoader()-&gt;writer();
 196     writer.setMIMEType(&quot;text/html&quot;);
 197     writer.begin();
 198     writer.insertDataSynchronously(String(markup));
 199     writer.end();
 200     RELEASE_ASSERT(page-&gt;mainFrame().document()-&gt;body());
 201 
 202     return page;
 203 }
 204 
 205 String sanitizeMarkup(const String&amp; rawHTML, MSOListQuirks msoListQuirks, Optional&lt;WTF::Function&lt;void(DocumentFragment&amp;)&gt;&gt; fragmentSanitizer)
 206 {
 207     auto page = createPageForSanitizingWebContent();
 208     Document* stagingDocument = page-&gt;mainFrame().document();
 209     ASSERT(stagingDocument);
 210 
 211     auto fragment = createFragmentFromMarkup(*stagingDocument, rawHTML, emptyString(), DisallowScriptingAndPluginContent);
 212 
 213     if (fragmentSanitizer)
 214         (*fragmentSanitizer)(fragment);
 215 
 216     return sanitizedMarkupForFragmentInDocument(WTFMove(fragment), *stagingDocument, msoListQuirks, rawHTML);
 217 }
 218 
 219 enum class MSOListMode { Preserve, DoNotPreserve };
 220 class StyledMarkupAccumulator final : public MarkupAccumulator {
 221 public:
 222     enum RangeFullySelectsNode { DoesFullySelectNode, DoesNotFullySelectNode };
 223 
 224     StyledMarkupAccumulator(const Position&amp; start, const Position&amp; end, Vector&lt;Node*&gt;* nodes, ResolveURLs, SerializeComposedTree,
 225         AnnotateForInterchange, MSOListMode, bool needsPositionStyleConversion, Node* highestNodeToBeSerialized = nullptr);
 226 
 227     Node* serializeNodes(const Position&amp; start, const Position&amp; end);
 228     void wrapWithNode(Node&amp;, bool convertBlocksToInlines = false, RangeFullySelectsNode = DoesFullySelectNode);
 229     void wrapWithStyleNode(StyleProperties*, Document&amp;, bool isBlock = false);
 230     String takeResults();
 231 
 232     bool needRelativeStyleWrapper() const { return m_needRelativeStyleWrapper; }
 233     bool needClearingDiv() const { return m_needClearingDiv; }
 234 
 235     using MarkupAccumulator::appendString;
 236 
 237     ContainerNode* parentNode(Node&amp; node)
 238     {
 239         if (UNLIKELY(m_useComposedTree))
 240             return node.parentInComposedTree();
 241         return node.parentOrShadowHostNode();
 242     }
 243 
 244 private:
 245     void appendStyleNodeOpenTag(StringBuilder&amp;, StyleProperties*, Document&amp;, bool isBlock = false);
 246     const String&amp; styleNodeCloseTag(bool isBlock = false);
 247 
 248     String renderedTextRespectingRange(const Text&amp;);
 249     String textContentRespectingRange(const Text&amp;);
 250 
 251     bool shouldPreserveMSOListStyleForElement(const Element&amp;);
 252 
 253     void appendStartTag(StringBuilder&amp; out, const Element&amp;, bool addDisplayInline, RangeFullySelectsNode);
 254     void appendEndTag(StringBuilder&amp; out, const Element&amp;) override;
 255     void appendCustomAttributes(StringBuilder&amp;, const Element&amp;, Namespaces*) override;
 256 
 257     void appendText(StringBuilder&amp; out, const Text&amp;) override;
 258     void appendStartTag(StringBuilder&amp; out, const Element&amp; element, Namespaces*) override
 259     {
 260         appendStartTag(out, element, false, DoesFullySelectNode);
 261     }
 262 
 263     Node* firstChild(Node&amp; node)
 264     {
 265         if (UNLIKELY(m_useComposedTree))
 266             return firstChildInComposedTreeIgnoringUserAgentShadow(node);
 267         return node.firstChild();
 268     }
 269 
 270     Node* nextSibling(Node&amp; node)
 271     {
 272         if (UNLIKELY(m_useComposedTree))
 273             return nextSiblingInComposedTreeIgnoringUserAgentShadow(node);
 274         return node.nextSibling();
 275     }
 276 
 277     Node* nextSkippingChildren(Node&amp; node)
 278     {
 279         if (UNLIKELY(m_useComposedTree))
 280             return nextSkippingChildrenInComposedTreeIgnoringUserAgentShadow(node);
 281         return NodeTraversal::nextSkippingChildren(node);
 282     }
 283 
 284     bool hasChildNodes(Node&amp; node)
 285     {
 286         if (UNLIKELY(m_useComposedTree))
 287             return firstChildInComposedTreeIgnoringUserAgentShadow(node);
 288         return node.hasChildNodes();
 289     }
 290 
 291     bool isDescendantOf(Node&amp; node, Node&amp; possibleAncestor)
 292     {
 293         if (UNLIKELY(m_useComposedTree))
 294             return node.isDescendantOrShadowDescendantOf(&amp;possibleAncestor);
 295         return node.isDescendantOf(&amp;possibleAncestor);
 296     }
 297 
 298     enum class NodeTraversalMode { EmitString, DoNotEmitString };
 299     Node* traverseNodesForSerialization(Node* startNode, Node* pastEnd, NodeTraversalMode);
 300 
 301     bool appendNodeToPreserveMSOList(Node&amp;);
 302 
 303     bool shouldAnnotate()
 304     {
 305         return m_annotate == AnnotateForInterchange::Yes;
 306     }
 307 
 308     bool shouldApplyWrappingStyle(const Node&amp; node) const
 309     {
 310         return m_highestNodeToBeSerialized &amp;&amp; m_highestNodeToBeSerialized-&gt;parentNode() == node.parentNode() &amp;&amp; m_wrappingStyle &amp;&amp; m_wrappingStyle-&gt;style();
 311     }
 312 
 313     Position m_start;
 314     Position m_end;
 315     Vector&lt;String&gt; m_reversedPrecedingMarkup;
 316     const AnnotateForInterchange m_annotate;
 317     RefPtr&lt;Node&gt; m_highestNodeToBeSerialized;
 318     RefPtr&lt;EditingStyle&gt; m_wrappingStyle;
 319     bool m_useComposedTree;
 320     bool m_needsPositionStyleConversion;
 321     bool m_needRelativeStyleWrapper { false };
 322     bool m_needClearingDiv { false };
 323     bool m_shouldPreserveMSOList;
 324     bool m_inMSOList { false };
 325 };
 326 
 327 inline StyledMarkupAccumulator::StyledMarkupAccumulator(const Position&amp; start, const Position&amp; end, Vector&lt;Node*&gt;* nodes, ResolveURLs urlsToResolve, SerializeComposedTree serializeComposedTree,
 328     AnnotateForInterchange annotate, MSOListMode msoListMode, bool needsPositionStyleConversion, Node* highestNodeToBeSerialized)
 329     : MarkupAccumulator(nodes, urlsToResolve)
 330     , m_start(start)
 331     , m_end(end)
 332     , m_annotate(annotate)
 333     , m_highestNodeToBeSerialized(highestNodeToBeSerialized)
 334     , m_useComposedTree(serializeComposedTree == SerializeComposedTree::Yes)
 335     , m_needsPositionStyleConversion(needsPositionStyleConversion)
 336     , m_shouldPreserveMSOList(msoListMode == MSOListMode::Preserve)
 337 {
 338 }
 339 
 340 void StyledMarkupAccumulator::wrapWithNode(Node&amp; node, bool convertBlocksToInlines, RangeFullySelectsNode rangeFullySelectsNode)
 341 {
 342     StringBuilder markup;
 343     if (is&lt;Element&gt;(node))
 344         appendStartTag(markup, downcast&lt;Element&gt;(node), convertBlocksToInlines &amp;&amp; isBlock(&amp;node), rangeFullySelectsNode);
 345     else
 346         appendNonElementNode(markup, node, nullptr);
 347     m_reversedPrecedingMarkup.append(markup.toString());
 348     endAppendingNode(node);
 349     if (m_nodes)
 350         m_nodes-&gt;append(&amp;node);
 351 }
 352 
 353 void StyledMarkupAccumulator::wrapWithStyleNode(StyleProperties* style, Document&amp; document, bool isBlock)
 354 {
 355     StringBuilder openTag;
 356     appendStyleNodeOpenTag(openTag, style, document, isBlock);
 357     m_reversedPrecedingMarkup.append(openTag.toString());
 358     appendString(styleNodeCloseTag(isBlock));
 359 }
 360 
 361 void StyledMarkupAccumulator::appendStyleNodeOpenTag(StringBuilder&amp; out, StyleProperties* style, Document&amp; document, bool isBlock)
 362 {
 363     // wrappingStyleForSerialization should have removed -webkit-text-decorations-in-effect
 364     ASSERT(propertyMissingOrEqualToNone(style, CSSPropertyWebkitTextDecorationsInEffect));
 365     if (isBlock)
 366         out.appendLiteral(&quot;&lt;div style=\&quot;&quot;);
 367     else
 368         out.appendLiteral(&quot;&lt;span style=\&quot;&quot;);
 369     appendAttributeValue(out, style-&gt;asText(), document.isHTMLDocument());
 370     out.appendLiteral(&quot;\&quot;&gt;&quot;);
 371 }
 372 
 373 const String&amp; StyledMarkupAccumulator::styleNodeCloseTag(bool isBlock)
 374 {
 375     static NeverDestroyed&lt;const String&gt; divClose(MAKE_STATIC_STRING_IMPL(&quot;&lt;/div&gt;&quot;));
 376     static NeverDestroyed&lt;const String&gt; styleSpanClose(MAKE_STATIC_STRING_IMPL(&quot;&lt;/span&gt;&quot;));
 377     return isBlock ? divClose : styleSpanClose;
 378 }
 379 
 380 String StyledMarkupAccumulator::takeResults()
 381 {
 382     StringBuilder result;
 383     result.reserveCapacity(totalLength(m_reversedPrecedingMarkup) + length());
 384 
 385     for (size_t i = m_reversedPrecedingMarkup.size(); i &gt; 0; --i)
 386         result.append(m_reversedPrecedingMarkup[i - 1]);
 387 
 388     concatenateMarkup(result);
 389 
 390     // We remove &#39;\0&#39; characters because they are not visibly rendered to the user.
 391     return result.toString().replaceWithLiteral(&#39;\0&#39;, &quot;&quot;);
 392 }
 393 
 394 void StyledMarkupAccumulator::appendText(StringBuilder&amp; out, const Text&amp; text)
 395 {
 396     const bool parentIsTextarea = is&lt;HTMLTextAreaElement&gt;(text.parentElement());
 397     const bool wrappingSpan = shouldApplyWrappingStyle(text) &amp;&amp; !parentIsTextarea;
 398     if (wrappingSpan) {
 399         RefPtr&lt;EditingStyle&gt; wrappingStyle = m_wrappingStyle-&gt;copy();
 400         // FIXME: &lt;rdar://problem/5371536&gt; Style rules that match pasted content can change it&#39;s appearance
 401         // Make sure spans are inline style in paste side e.g. span { display: block }.
 402         wrappingStyle-&gt;forceInline();
 403         // FIXME: Should this be included in forceInline?
 404         wrappingStyle-&gt;style()-&gt;setProperty(CSSPropertyFloat, CSSValueNone);
 405 
 406         appendStyleNodeOpenTag(out, wrappingStyle-&gt;style(), text.document());
 407     }
 408 
 409     if (!shouldAnnotate() || parentIsTextarea) {
 410         auto content = textContentRespectingRange(text);
 411         appendCharactersReplacingEntities(out, content, 0, content.length(), entityMaskForText(text));
 412     } else {
 413         const bool useRenderedText = !enclosingElementWithTag(firstPositionInNode(const_cast&lt;Text*&gt;(&amp;text)), selectTag);
 414         String content = useRenderedText ? renderedTextRespectingRange(text) : textContentRespectingRange(text);
 415         StringBuilder buffer;
 416         appendCharactersReplacingEntities(buffer, content, 0, content.length(), EntityMaskInPCDATA);
 417         out.append(convertHTMLTextToInterchangeFormat(buffer.toString(), &amp;text));
 418     }
 419 
 420     if (wrappingSpan)
 421         out.append(styleNodeCloseTag());
 422 }
 423 
 424 String StyledMarkupAccumulator::renderedTextRespectingRange(const Text&amp; text)
 425 {
 426     TextIteratorBehavior behavior = TextIteratorDefaultBehavior;
 427     Position start = &amp;text == m_start.containerNode() ? m_start : firstPositionInNode(const_cast&lt;Text*&gt;(&amp;text));
 428     Position end;
 429     if (&amp;text == m_end.containerNode())
 430         end = m_end;
 431     else {
 432         end = lastPositionInNode(const_cast&lt;Text*&gt;(&amp;text));
 433         if (!m_end.isNull())
 434             behavior = TextIteratorBehavesAsIfNodesFollowing;
 435     }
 436 
 437     return plainText(Range::create(text.document(), start, end).ptr(), behavior);
 438 }
 439 
 440 String StyledMarkupAccumulator::textContentRespectingRange(const Text&amp; text)
 441 {
 442     if (m_start.isNull() &amp;&amp; m_end.isNull())
 443         return text.data();
 444 
 445     unsigned start = 0;
 446     unsigned end = std::numeric_limits&lt;unsigned&gt;::max();
 447     if (&amp;text == m_start.containerNode())
 448         start = m_start.offsetInContainerNode();
 449     if (&amp;text == m_end.containerNode())
 450         end = m_end.offsetInContainerNode();
 451     ASSERT(start &lt; end);
 452     return text.data().substring(start, end - start);
 453 }
 454 
 455 void StyledMarkupAccumulator::appendCustomAttributes(StringBuilder&amp; out, const Element&amp; element, Namespaces* namespaces)
 456 {
 457 #if ENABLE(ATTACHMENT_ELEMENT)
 458     if (!RuntimeEnabledFeatures::sharedFeatures().attachmentElementEnabled())
 459         return;
 460 
 461     if (is&lt;HTMLAttachmentElement&gt;(element)) {
 462         auto&amp; attachment = downcast&lt;HTMLAttachmentElement&gt;(element);
 463         appendAttribute(out, element, { webkitattachmentidAttr, attachment.uniqueIdentifier() }, namespaces);
 464         if (auto* file = attachment.file()) {
 465             // These attributes are only intended for File deserialization, and are removed from the generated attachment
 466             // element after we&#39;ve deserialized and set its backing File, in restoreAttachmentElementsInFragment.
 467             appendAttribute(out, element, { webkitattachmentpathAttr, file-&gt;path() }, namespaces);
 468             appendAttribute(out, element, { webkitattachmentbloburlAttr, file-&gt;url().string() }, namespaces);
 469         }
 470     } else if (is&lt;HTMLImageElement&gt;(element)) {
 471         if (auto attachment = downcast&lt;HTMLImageElement&gt;(element).attachmentElement())
 472             appendAttribute(out, element, { webkitattachmentidAttr, attachment-&gt;uniqueIdentifier() }, namespaces);
 473     }
 474 #else
 475     UNUSED_PARAM(out);
 476     UNUSED_PARAM(element);
 477     UNUSED_PARAM(namespaces);
 478 #endif
 479 }
 480 
 481 bool StyledMarkupAccumulator::shouldPreserveMSOListStyleForElement(const Element&amp; element)
 482 {
 483     if (m_inMSOList)
 484         return true;
 485     if (m_shouldPreserveMSOList) {
 486         auto style = element.getAttribute(styleAttr);
 487         return style.startsWith(&quot;mso-list:&quot;) || style.contains(&quot;;mso-list:&quot;) || style.contains(&quot;\nmso-list:&quot;);
 488     }
 489     return false;
 490 }
 491 
 492 void StyledMarkupAccumulator::appendStartTag(StringBuilder&amp; out, const Element&amp; element, bool addDisplayInline, RangeFullySelectsNode rangeFullySelectsNode)
 493 {
 494     const bool documentIsHTML = element.document().isHTMLDocument();
 495     const bool isSlotElement = is&lt;HTMLSlotElement&gt;(element);
 496     if (UNLIKELY(isSlotElement))
 497         out.append(&quot;&lt;span&quot;);
 498     else
 499         appendOpenTag(out, element, nullptr);
 500 
 501     appendCustomAttributes(out, element, nullptr);
 502 
 503     const bool shouldAnnotateOrForceInline = element.isHTMLElement() &amp;&amp; (shouldAnnotate() || addDisplayInline);
 504     bool shouldOverrideStyleAttr = (shouldAnnotateOrForceInline || shouldApplyWrappingStyle(element) || isSlotElement) &amp;&amp; !shouldPreserveMSOListStyleForElement(element);
 505     if (element.hasAttributes()) {
 506         for (const Attribute&amp; attribute : element.attributesIterator()) {
 507             // We&#39;ll handle the style attribute separately, below.
 508             if (attribute.name() == styleAttr &amp;&amp; shouldOverrideStyleAttr)
 509                 continue;
 510             if (element.isEventHandlerAttribute(attribute) || element.isJavaScriptURLAttribute(attribute))
 511                 continue;
 512             appendAttribute(out, element, attribute, 0);
 513         }
 514     }
 515 
 516     if (shouldOverrideStyleAttr) {
 517         RefPtr&lt;EditingStyle&gt; newInlineStyle;
 518 
 519         if (shouldApplyWrappingStyle(element)) {
 520             newInlineStyle = m_wrappingStyle-&gt;copy();
 521             newInlineStyle-&gt;removePropertiesInElementDefaultStyle(*const_cast&lt;Element*&gt;(&amp;element));
 522             newInlineStyle-&gt;removeStyleConflictingWithStyleOfNode(*const_cast&lt;Element*&gt;(&amp;element));
 523         } else
 524             newInlineStyle = EditingStyle::create();
 525 
 526         if (isSlotElement)
 527             newInlineStyle-&gt;addDisplayContents();
 528 
 529         if (is&lt;StyledElement&gt;(element) &amp;&amp; downcast&lt;StyledElement&gt;(element).inlineStyle())
 530             newInlineStyle-&gt;overrideWithStyle(*downcast&lt;StyledElement&gt;(element).inlineStyle());
 531 
 532         if (shouldAnnotateOrForceInline) {
 533             if (shouldAnnotate())
 534                 newInlineStyle-&gt;mergeStyleFromRulesForSerialization(downcast&lt;HTMLElement&gt;(*const_cast&lt;Element*&gt;(&amp;element)));
 535 
 536             if (addDisplayInline)
 537                 newInlineStyle-&gt;forceInline();
 538 
 539             if (m_needsPositionStyleConversion) {
 540                 m_needRelativeStyleWrapper |= newInlineStyle-&gt;convertPositionStyle();
 541                 m_needClearingDiv |= newInlineStyle-&gt;isFloating();
 542             }
 543 
 544             // If the node is not fully selected by the range, then we don&#39;t want to keep styles that affect its relationship to the nodes around it
 545             // only the ones that affect it and the nodes within it.
 546             if (rangeFullySelectsNode == DoesNotFullySelectNode &amp;&amp; newInlineStyle-&gt;style())
 547                 newInlineStyle-&gt;style()-&gt;removeProperty(CSSPropertyFloat);
 548         }
 549 
 550         if (!newInlineStyle-&gt;isEmpty()) {
 551             out.appendLiteral(&quot; style=\&quot;&quot;);
 552             appendAttributeValue(out, newInlineStyle-&gt;style()-&gt;asText(), documentIsHTML);
 553             out.append(&#39;\&quot;&#39;);
 554         }
 555     }
 556 
 557     appendCloseTag(out, element);
 558 }
 559 
 560 void StyledMarkupAccumulator::appendEndTag(StringBuilder&amp; out, const Element&amp; element)
 561 {
 562     if (UNLIKELY(is&lt;HTMLSlotElement&gt;(element)))
 563         out.append(&quot;&lt;/span&gt;&quot;);
 564     else
 565         MarkupAccumulator::appendEndTag(out, element);
 566 }
 567 
 568 Node* StyledMarkupAccumulator::serializeNodes(const Position&amp; start, const Position&amp; end)
 569 {
 570     ASSERT(comparePositions(start, end) &lt;= 0);
 571     auto startNode = start.firstNode();
 572     Node* pastEnd = end.computeNodeAfterPosition();
 573     if (!pastEnd &amp;&amp; end.containerNode())
 574         pastEnd = nextSkippingChildren(*end.containerNode());
 575 
 576     if (!m_highestNodeToBeSerialized) {
 577         Node* lastClosed = traverseNodesForSerialization(startNode.get(), pastEnd, NodeTraversalMode::DoNotEmitString);
 578         m_highestNodeToBeSerialized = lastClosed;
 579     }
 580 
 581     if (m_highestNodeToBeSerialized &amp;&amp; m_highestNodeToBeSerialized-&gt;parentNode())
 582         m_wrappingStyle = EditingStyle::wrappingStyleForSerialization(*m_highestNodeToBeSerialized-&gt;parentNode(), shouldAnnotate());
 583 
 584     return traverseNodesForSerialization(startNode.get(), pastEnd, NodeTraversalMode::EmitString);
 585 }
 586 
 587 Node* StyledMarkupAccumulator::traverseNodesForSerialization(Node* startNode, Node* pastEnd, NodeTraversalMode traversalMode)
 588 {
 589     const bool shouldEmit = traversalMode == NodeTraversalMode::EmitString;
 590 
 591     m_inMSOList = false;
 592 
 593     unsigned depth = 0;
 594     auto enterNode = [&amp;] (Node&amp; node) {
 595         if (UNLIKELY(m_shouldPreserveMSOList) &amp;&amp; shouldEmit) {
 596             if (appendNodeToPreserveMSOList(node))
 597                 return false;
 598         }
 599 
 600         bool isDisplayContents = is&lt;Element&gt;(node) &amp;&amp; downcast&lt;Element&gt;(node).hasDisplayContents();
 601         if (!node.renderer() &amp;&amp; !isDisplayContents &amp;&amp; !enclosingElementWithTag(firstPositionInOrBeforeNode(&amp;node), selectTag))
 602             return false;
 603 
 604         ++depth;
 605         if (shouldEmit)
 606             startAppendingNode(node);
 607 
 608         return true;
 609     };
 610 
 611     Node* lastClosed = nullptr;
 612     auto exitNode = [&amp;] (Node&amp; node) {
 613         bool closing = depth;
 614         if (depth)
 615             --depth;
 616         if (shouldEmit) {
 617             if (closing)
 618                 endAppendingNode(node);
 619             else
 620                 wrapWithNode(node);
 621         }
 622         lastClosed = &amp;node;
 623     };
 624 
 625     Node* lastNode = nullptr;
 626     Node* next = nullptr;
 627     for (auto* n = startNode; n != pastEnd; lastNode = n, n = next) {
 628 
 629         Vector&lt;Node*, 8&gt; exitedAncestors;
 630         next = nullptr;
 631         if (auto* child = firstChild(*n))
 632             next = child;
 633         else if (auto* sibling = nextSibling(*n))
 634             next = sibling;
 635         else {
 636             for (auto* ancestor = parentNode(*n); ancestor; ancestor = parentNode(*ancestor)) {
 637                 exitedAncestors.append(ancestor);
 638                 if (auto* sibling = nextSibling(*ancestor)) {
 639                     next = sibling;
 640                     break;
 641                 }
 642             }
 643         }
 644         ASSERT(next || !pastEnd);
 645 
 646         if (isBlock(n) &amp;&amp; canHaveChildrenForEditing(*n) &amp;&amp; next == pastEnd) {
 647             // Don&#39;t write out empty block containers that aren&#39;t fully selected.
 648             continue;
 649         }
 650 
 651         if (!enterNode(*n)) {
 652             next = nextSkippingChildren(*n);
 653             // Don&#39;t skip over pastEnd.
 654             if (pastEnd &amp;&amp; isDescendantOf(*pastEnd, *n))
 655                 next = pastEnd;
 656             ASSERT(next || !pastEnd);
 657         } else {
 658             if (!hasChildNodes(*n))
 659                 exitNode(*n);
 660         }
 661 
 662         for (auto* ancestor : exitedAncestors) {
 663             if (!depth &amp;&amp; next == pastEnd)
 664                 break;
 665             exitNode(*ancestor);
 666         }
 667     }
 668 
 669     ASSERT(lastNode || !depth);
 670     if (depth) {
 671         for (auto* ancestor = parentNode(pastEnd ? *pastEnd : *lastNode); ancestor &amp;&amp; depth; ancestor = parentNode(*ancestor))
 672             exitNode(*ancestor);
 673     }
 674 
 675     return lastClosed;
 676 }
 677 
 678 bool StyledMarkupAccumulator::appendNodeToPreserveMSOList(Node&amp; node)
 679 {
 680     if (is&lt;Comment&gt;(node)) {
 681         auto&amp; commentNode = downcast&lt;Comment&gt;(node);
 682         if (!m_inMSOList &amp;&amp; commentNode.data() == &quot;[if !supportLists]&quot;)
 683             m_inMSOList = true;
 684         else if (m_inMSOList &amp;&amp; commentNode.data() == &quot;[endif]&quot;)
 685             m_inMSOList = false;
 686         else
 687             return false;
 688         startAppendingNode(commentNode);
 689         return true;
 690     }
 691     if (is&lt;HTMLStyleElement&gt;(node)) {
 692         auto* firstChild = node.firstChild();
 693         if (!is&lt;Text&gt;(firstChild))
 694             return false;
 695 
 696         auto&amp; textChild = downcast&lt;Text&gt;(*firstChild);
 697         auto&amp; styleContent = textChild.data();
 698 
 699         const auto msoStyleDefinitionsStart = styleContent.find(&quot;/* Style Definitions */&quot;);
 700         const auto msoListDefinitionsStart = styleContent.find(&quot;/* List Definitions */&quot;);
 701         const auto lastListItem = styleContent.reverseFind(&quot;\n@list&quot;);
 702         if (msoListDefinitionsStart == notFound || lastListItem == notFound)
 703             return false;
 704         const auto start = msoStyleDefinitionsStart != notFound &amp;&amp; msoStyleDefinitionsStart &lt; msoListDefinitionsStart ? msoStyleDefinitionsStart : msoListDefinitionsStart;
 705 
 706         const auto msoListDefinitionsEnd = styleContent.find(&quot;;}\n&quot;, lastListItem);
 707         if (msoListDefinitionsEnd == notFound || start &gt;= msoListDefinitionsEnd)
 708             return false;
 709 
 710         appendString(&quot;&lt;head&gt;&lt;style class=\&quot;&quot; WebKitMSOListQuirksStyle &quot;\&quot;&gt;\n&lt;!--\n&quot;);
 711         appendStringView(StringView(textChild.data()).substring(start, msoListDefinitionsEnd - start + 3));
 712         appendString(&quot;\n--&gt;\n&lt;/style&gt;&lt;/head&gt;&quot;);
 713 
 714         return true;
 715     }
 716     return false;
 717 }
 718 
 719 static Node* ancestorToRetainStructureAndAppearanceForBlock(Node* commonAncestorBlock)
 720 {
 721     if (!commonAncestorBlock)
 722         return nullptr;
 723 
 724     if (commonAncestorBlock-&gt;hasTagName(tbodyTag) || commonAncestorBlock-&gt;hasTagName(trTag)) {
 725         ContainerNode* table = commonAncestorBlock-&gt;parentNode();
 726         while (table &amp;&amp; !is&lt;HTMLTableElement&gt;(*table))
 727             table = table-&gt;parentNode();
 728 
 729         return table;
 730     }
 731 
 732     if (isNonTableCellHTMLBlockElement(commonAncestorBlock))
 733         return commonAncestorBlock;
 734 
 735     return nullptr;
 736 }
 737 
 738 static inline Node* ancestorToRetainStructureAndAppearance(Node* commonAncestor)
 739 {
 740     return ancestorToRetainStructureAndAppearanceForBlock(enclosingBlock(commonAncestor));
 741 }
 742 
 743 static bool propertyMissingOrEqualToNone(StyleProperties* style, CSSPropertyID propertyID)
 744 {
 745     if (!style)
 746         return false;
 747     RefPtr&lt;CSSValue&gt; value = style-&gt;getPropertyCSSValue(propertyID);
 748     if (!value)
 749         return true;
 750     if (!is&lt;CSSPrimitiveValue&gt;(*value))
 751         return false;
 752     return downcast&lt;CSSPrimitiveValue&gt;(*value).valueID() == CSSValueNone;
 753 }
 754 
 755 static bool needInterchangeNewlineAfter(const VisiblePosition&amp; v)
 756 {
 757     VisiblePosition next = v.next();
 758     Node* upstreamNode = next.deepEquivalent().upstream().deprecatedNode();
 759     Node* downstreamNode = v.deepEquivalent().downstream().deprecatedNode();
 760     // Add an interchange newline if a paragraph break is selected and a br won&#39;t already be added to the markup to represent it.
 761     return isEndOfParagraph(v) &amp;&amp; isStartOfParagraph(next) &amp;&amp; !(upstreamNode-&gt;hasTagName(brTag) &amp;&amp; upstreamNode == downstreamNode);
 762 }
 763 
 764 static RefPtr&lt;EditingStyle&gt; styleFromMatchedRulesAndInlineDecl(Node&amp; node)
 765 {
 766     if (!is&lt;HTMLElement&gt;(node))
 767         return nullptr;
 768 
 769     auto&amp; element = downcast&lt;HTMLElement&gt;(node);
 770     auto style = EditingStyle::create(element.inlineStyle());
 771     style-&gt;mergeStyleFromRules(element);
<a name="6" id="anc6"></a><span class="line-modified"> 772     return style;</span>
 773 }
 774 
 775 static bool isElementPresentational(const Node* node)
 776 {
 777     return node-&gt;hasTagName(uTag) || node-&gt;hasTagName(sTag) || node-&gt;hasTagName(strikeTag)
 778         || node-&gt;hasTagName(iTag) || node-&gt;hasTagName(emTag) || node-&gt;hasTagName(bTag) || node-&gt;hasTagName(strongTag);
 779 }
 780 
 781 static Node* highestAncestorToWrapMarkup(const Position&amp; start, const Position&amp; end, Node&amp; commonAncestor, AnnotateForInterchange annotate)
 782 {
 783     Node* specialCommonAncestor = nullptr;
 784     if (annotate == AnnotateForInterchange::Yes) {
 785         // Include ancestors that aren&#39;t completely inside the range but are required to retain
 786         // the structure and appearance of the copied markup.
 787         specialCommonAncestor = ancestorToRetainStructureAndAppearance(&amp;commonAncestor);
 788 
 789         if (auto* parentListNode = enclosingNodeOfType(start, isListItem)) {
 790             if (!editingIgnoresContent(*parentListNode) &amp;&amp; VisibleSelection::selectionFromContentsOfNode(parentListNode) == VisibleSelection(start, end)) {
 791                 specialCommonAncestor = parentListNode-&gt;parentNode();
 792                 while (specialCommonAncestor &amp;&amp; !isListHTMLElement(specialCommonAncestor))
 793                     specialCommonAncestor = specialCommonAncestor-&gt;parentNode();
 794             }
 795         }
 796 
 797         // Retain the Mail quote level by including all ancestor mail block quotes.
 798         if (Node* highestMailBlockquote = highestEnclosingNodeOfType(start, isMailBlockquote, CanCrossEditingBoundary))
 799             specialCommonAncestor = highestMailBlockquote;
 800     }
 801 
 802     auto* checkAncestor = specialCommonAncestor ? specialCommonAncestor : &amp;commonAncestor;
 803     if (checkAncestor-&gt;renderer() &amp;&amp; checkAncestor-&gt;renderer()-&gt;containingBlock()) {
 804         Node* newSpecialCommonAncestor = highestEnclosingNodeOfType(firstPositionInNode(checkAncestor), &amp;isElementPresentational, CanCrossEditingBoundary, checkAncestor-&gt;renderer()-&gt;containingBlock()-&gt;element());
 805         if (newSpecialCommonAncestor)
 806             specialCommonAncestor = newSpecialCommonAncestor;
 807     }
 808 
 809     // If a single tab is selected, commonAncestor will be a text node inside a tab span.
 810     // If two or more tabs are selected, commonAncestor will be the tab span.
 811     // In either case, if there is a specialCommonAncestor already, it will necessarily be above
 812     // any tab span that needs to be included.
 813     if (!specialCommonAncestor &amp;&amp; isTabSpanTextNode(&amp;commonAncestor))
 814         specialCommonAncestor = commonAncestor.parentNode();
 815     if (!specialCommonAncestor &amp;&amp; isTabSpanNode(&amp;commonAncestor))
 816         specialCommonAncestor = &amp;commonAncestor;
 817 
 818     if (auto* enclosingAnchor = enclosingElementWithTag(firstPositionInNode(specialCommonAncestor ? specialCommonAncestor : &amp;commonAncestor), aTag))
 819         specialCommonAncestor = enclosingAnchor;
 820 
 821     return specialCommonAncestor;
 822 }
 823 
 824 static String serializePreservingVisualAppearanceInternal(const Position&amp; start, const Position&amp; end, Vector&lt;Node*&gt;* nodes, ResolveURLs urlsToResolve, SerializeComposedTree serializeComposedTree,
 825     AnnotateForInterchange annotate, ConvertBlocksToInlines convertBlocksToInlines, MSOListMode msoListMode)
 826 {
 827     static NeverDestroyed&lt;const String&gt; interchangeNewlineString(MAKE_STATIC_STRING_IMPL(&quot;&lt;br class=\&quot;&quot; AppleInterchangeNewline &quot;\&quot;&gt;&quot;));
 828 
 829     if (!comparePositions(start, end))
 830         return emptyString();
 831 
 832     RefPtr&lt;Node&gt; commonAncestor = commonShadowIncludingAncestor(start, end);
 833     if (!commonAncestor)
 834         return emptyString();
 835 
 836     auto&amp; document = *start.document();
 837     document.updateLayoutIgnorePendingStylesheets();
 838 
 839     VisiblePosition visibleStart { start };
 840     VisiblePosition visibleEnd { end };
 841 
 842     auto body = makeRefPtr(enclosingElementWithTag(firstPositionInNode(commonAncestor.get()), bodyTag));
 843     RefPtr&lt;Element&gt; fullySelectedRoot;
 844     // FIXME: Do this for all fully selected blocks, not just the body.
 845     if (body &amp;&amp; VisiblePosition(firstPositionInNode(body.get())) == visibleStart &amp;&amp; VisiblePosition(lastPositionInNode(body.get())) == visibleEnd)
 846         fullySelectedRoot = body;
 847     bool needsPositionStyleConversion = body &amp;&amp; fullySelectedRoot == body &amp;&amp; document.settings().shouldConvertPositionStyleOnCopy();
 848 
 849     Node* specialCommonAncestor = highestAncestorToWrapMarkup(start, end, *commonAncestor, annotate);
 850 
 851     StyledMarkupAccumulator accumulator(start, end, nodes, urlsToResolve, serializeComposedTree, annotate, msoListMode, needsPositionStyleConversion, specialCommonAncestor);
 852 
 853     Position startAdjustedForInterchangeNewline = start;
 854     if (annotate == AnnotateForInterchange::Yes &amp;&amp; needInterchangeNewlineAfter(visibleStart)) {
 855         if (visibleStart == visibleEnd.previous())
 856             return interchangeNewlineString;
 857 
 858         accumulator.appendString(interchangeNewlineString);
 859         startAdjustedForInterchangeNewline = visibleStart.next().deepEquivalent();
 860 
 861         if (comparePositions(startAdjustedForInterchangeNewline, end) &gt;= 0)
 862             return interchangeNewlineString;
 863     }
 864 
 865     Node* lastClosed = accumulator.serializeNodes(startAdjustedForInterchangeNewline, end);
 866 
 867     if (specialCommonAncestor &amp;&amp; lastClosed) {
 868         // Also include all of the ancestors of lastClosed up to this special ancestor.
 869         for (ContainerNode* ancestor = accumulator.parentNode(*lastClosed); ancestor; ancestor = accumulator.parentNode(*ancestor)) {
 870             if (ancestor == fullySelectedRoot &amp;&amp; convertBlocksToInlines == ConvertBlocksToInlines::No) {
 871                 RefPtr&lt;EditingStyle&gt; fullySelectedRootStyle = styleFromMatchedRulesAndInlineDecl(*fullySelectedRoot);
 872 
 873                 // Bring the background attribute over, but not as an attribute because a background attribute on a div
 874                 // appears to have no effect.
 875                 if ((!fullySelectedRootStyle || !fullySelectedRootStyle-&gt;style() || !fullySelectedRootStyle-&gt;style()-&gt;getPropertyCSSValue(CSSPropertyBackgroundImage))
 876                     &amp;&amp; fullySelectedRoot-&gt;hasAttributeWithoutSynchronization(backgroundAttr))
 877                     fullySelectedRootStyle-&gt;style()-&gt;setProperty(CSSPropertyBackgroundImage, &quot;url(&#39;&quot; + fullySelectedRoot-&gt;getAttribute(backgroundAttr) + &quot;&#39;)&quot;);
 878 
 879                 if (fullySelectedRootStyle-&gt;style()) {
 880                     // Reset the CSS properties to avoid an assertion error in addStyleMarkup().
 881                     // This assertion is caused at least when we select all text of a &lt;body&gt; element whose
 882                     // &#39;text-decoration&#39; property is &quot;inherit&quot;, and copy it.
 883                     if (!propertyMissingOrEqualToNone(fullySelectedRootStyle-&gt;style(), CSSPropertyTextDecoration))
 884                         fullySelectedRootStyle-&gt;style()-&gt;setProperty(CSSPropertyTextDecoration, CSSValueNone);
 885                     if (!propertyMissingOrEqualToNone(fullySelectedRootStyle-&gt;style(), CSSPropertyWebkitTextDecorationsInEffect))
 886                         fullySelectedRootStyle-&gt;style()-&gt;setProperty(CSSPropertyWebkitTextDecorationsInEffect, CSSValueNone);
 887                     accumulator.wrapWithStyleNode(fullySelectedRootStyle-&gt;style(), document, true);
 888                 }
 889             } else {
 890                 // Since this node and all the other ancestors are not in the selection we want to set RangeFullySelectsNode to DoesNotFullySelectNode
 891                 // so that styles that affect the exterior of the node are not included.
 892                 accumulator.wrapWithNode(*ancestor, convertBlocksToInlines == ConvertBlocksToInlines::Yes, StyledMarkupAccumulator::DoesNotFullySelectNode);
 893             }
 894             if (nodes)
 895                 nodes-&gt;append(ancestor);
 896 
 897             if (ancestor == specialCommonAncestor)
 898                 break;
 899         }
 900     }
 901 
 902     if (accumulator.needRelativeStyleWrapper() &amp;&amp; needsPositionStyleConversion) {
 903         if (accumulator.needClearingDiv())
 904             accumulator.appendString(&quot;&lt;div style=\&quot;clear: both;\&quot;&gt;&lt;/div&gt;&quot;);
 905         RefPtr&lt;EditingStyle&gt; positionRelativeStyle = styleFromMatchedRulesAndInlineDecl(*body);
 906         positionRelativeStyle-&gt;style()-&gt;setProperty(CSSPropertyPosition, CSSValueRelative);
 907         accumulator.wrapWithStyleNode(positionRelativeStyle-&gt;style(), document, true);
 908     }
 909 
 910     // FIXME: The interchange newline should be placed in the block that it&#39;s in, not after all of the content, unconditionally.
 911     if (annotate == AnnotateForInterchange::Yes &amp;&amp; needInterchangeNewlineAfter(visibleEnd.previous()))
 912         accumulator.appendString(interchangeNewlineString);
 913 
 914     return accumulator.takeResults();
 915 }
 916 
 917 String serializePreservingVisualAppearance(const Range&amp; range, Vector&lt;Node*&gt;* nodes, AnnotateForInterchange annotate, ConvertBlocksToInlines convertBlocksToInlines, ResolveURLs urlsToReslve)
 918 {
 919     return serializePreservingVisualAppearanceInternal(range.startPosition(), range.endPosition(), nodes, urlsToReslve, SerializeComposedTree::No,
 920         annotate, convertBlocksToInlines, MSOListMode::DoNotPreserve);
 921 }
 922 
 923 String serializePreservingVisualAppearance(const VisibleSelection&amp; selection, ResolveURLs resolveURLs, SerializeComposedTree serializeComposedTree, Vector&lt;Node*&gt;* nodes)
 924 {
 925     return serializePreservingVisualAppearanceInternal(selection.start(), selection.end(), nodes, resolveURLs, serializeComposedTree,
 926         AnnotateForInterchange::Yes, ConvertBlocksToInlines::No, MSOListMode::DoNotPreserve);
 927 }
 928 
 929 
 930 static bool shouldPreserveMSOLists(const String&amp; markup)
 931 {
 932     if (!markup.startsWith(&quot;&lt;html xmlns:&quot;))
 933         return false;
 934     auto tagClose = markup.find(&#39;&gt;&#39;);
 935     if (tagClose == notFound)
 936         return false;
 937     auto htmlTag = markup.substring(0, tagClose);
 938     return htmlTag.contains(&quot;xmlns:o=\&quot;urn:schemas-microsoft-com:office:office\&quot;&quot;)
 939         &amp;&amp; htmlTag.contains(&quot;xmlns:w=\&quot;urn:schemas-microsoft-com:office:word\&quot;&quot;);
 940 }
 941 
 942 String sanitizedMarkupForFragmentInDocument(Ref&lt;DocumentFragment&gt;&amp;&amp; fragment, Document&amp; document, MSOListQuirks msoListQuirks, const String&amp; originalMarkup)
 943 {
 944     MSOListMode msoListMode = msoListQuirks == MSOListQuirks::CheckIfNeeded &amp;&amp; shouldPreserveMSOLists(originalMarkup)
 945         ? MSOListMode::Preserve : MSOListMode::DoNotPreserve;
 946 
 947     auto bodyElement = makeRefPtr(document.body());
 948     ASSERT(bodyElement);
 949     bodyElement-&gt;appendChild(fragment.get());
 950 
 951     // SerializeComposedTree::No because there can&#39;t be a shadow tree in the pasted fragment.
 952     auto result = serializePreservingVisualAppearanceInternal(firstPositionInNode(bodyElement.get()), lastPositionInNode(bodyElement.get()), nullptr,
 953         ResolveURLs::YesExcludingLocalFileURLsForPrivacy, SerializeComposedTree::No, AnnotateForInterchange::Yes, ConvertBlocksToInlines::No,  msoListMode);
 954 
 955     if (msoListMode == MSOListMode::Preserve) {
 956         StringBuilder builder;
 957         builder.appendLiteral(&quot;&lt;html xmlns:o=\&quot;urn:schemas-microsoft-com:office:office\&quot;\n&quot;
 958             &quot;xmlns:w=\&quot;urn:schemas-microsoft-com:office:word\&quot;\n&quot;
 959             &quot;xmlns:m=\&quot;http://schemas.microsoft.com/office/2004/12/omml\&quot;\n&quot;
 960             &quot;xmlns=\&quot;http://www.w3.org/TR/REC-html40\&quot;&gt;&quot;);
 961         builder.append(result);
 962         builder.appendLiteral(&quot;&lt;/html&gt;&quot;);
 963         return builder.toString();
 964     }
 965 
 966     return result;
 967 }
 968 
 969 static void restoreAttachmentElementsInFragment(DocumentFragment&amp; fragment)
 970 {
 971 #if ENABLE(ATTACHMENT_ELEMENT)
 972     if (!RuntimeEnabledFeatures::sharedFeatures().attachmentElementEnabled())
 973         return;
 974 
 975     // When creating a fragment we must strip the webkit-attachment-path attribute after restoring the File object.
 976     Vector&lt;Ref&lt;HTMLAttachmentElement&gt;&gt; attachments;
 977     for (auto&amp; attachment : descendantsOfType&lt;HTMLAttachmentElement&gt;(fragment))
 978         attachments.append(attachment);
 979 
 980     for (auto&amp; attachment : attachments) {
 981         attachment-&gt;setUniqueIdentifier(attachment-&gt;attributeWithoutSynchronization(webkitattachmentidAttr));
 982 
 983         auto attachmentPath = attachment-&gt;attachmentPath();
 984         auto blobURL = attachment-&gt;blobURL();
 985         if (!attachmentPath.isEmpty())
<a name="7" id="anc7"></a><span class="line-modified"> 986             attachment-&gt;setFile(File::create(fragment.document().sessionID(), attachmentPath));</span>
 987         else if (!blobURL.isEmpty())
<a name="8" id="anc8"></a><span class="line-modified"> 988             attachment-&gt;setFile(File::deserialize(fragment.document().sessionID(), { }, blobURL, attachment-&gt;attachmentType(), attachment-&gt;attachmentTitle()));</span>
 989 
 990         // Remove temporary attributes that were previously added in StyledMarkupAccumulator::appendCustomAttributes.
 991         attachment-&gt;removeAttribute(webkitattachmentidAttr);
 992         attachment-&gt;removeAttribute(webkitattachmentpathAttr);
 993         attachment-&gt;removeAttribute(webkitattachmentbloburlAttr);
 994     }
 995 
 996     Vector&lt;Ref&lt;HTMLImageElement&gt;&gt; images;
 997     for (auto&amp; image : descendantsOfType&lt;HTMLImageElement&gt;(fragment))
 998         images.append(image);
 999 
1000     for (auto&amp; image : images) {
1001         auto attachmentIdentifier = image-&gt;attributeWithoutSynchronization(webkitattachmentidAttr);
1002         if (attachmentIdentifier.isEmpty())
1003             continue;
1004 
1005         auto attachment = HTMLAttachmentElement::create(HTMLNames::attachmentTag, *fragment.ownerDocument());
1006         attachment-&gt;setUniqueIdentifier(attachmentIdentifier);
1007         image-&gt;setAttachmentElement(WTFMove(attachment));
1008         image-&gt;removeAttribute(webkitattachmentidAttr);
1009     }
1010 #else
1011     UNUSED_PARAM(fragment);
1012 #endif
1013 }
1014 
1015 Ref&lt;DocumentFragment&gt; createFragmentFromMarkup(Document&amp; document, const String&amp; markup, const String&amp; baseURL, ParserContentPolicy parserContentPolicy)
1016 {
1017     // We use a fake body element here to trick the HTML parser into using the InBody insertion mode.
1018     auto fakeBody = HTMLBodyElement::create(document);
1019     auto fragment = DocumentFragment::create(document);
1020 
1021     fragment-&gt;parseHTML(markup, fakeBody.ptr(), parserContentPolicy);
1022     restoreAttachmentElementsInFragment(fragment);
1023     if (!baseURL.isEmpty() &amp;&amp; baseURL != WTF::blankURL() &amp;&amp; baseURL != document.baseURL())
1024         completeURLs(fragment.ptr(), baseURL);
1025 
1026     return fragment;
1027 }
1028 
1029 String serializeFragment(const Node&amp; node, SerializedNodes root, Vector&lt;Node*&gt;* nodes, ResolveURLs urlsToResolve, Vector&lt;QualifiedName&gt;* tagNamesToSkip, SerializationSyntax serializationSyntax)
1030 {
1031     MarkupAccumulator accumulator(nodes, urlsToResolve, serializationSyntax);
1032     return accumulator.serializeNodes(const_cast&lt;Node&amp;&gt;(node), root, tagNamesToSkip);
1033 }
1034 
1035 static void fillContainerFromString(ContainerNode&amp; paragraph, const String&amp; string)
1036 {
1037     Document&amp; document = paragraph.document();
1038 
1039     if (string.isEmpty()) {
1040         paragraph.appendChild(createBlockPlaceholderElement(document));
1041         return;
1042     }
1043 
1044     ASSERT(string.find(&#39;\n&#39;) == notFound);
1045 
1046     Vector&lt;String&gt; tabList = string.splitAllowingEmptyEntries(&#39;\t&#39;);
1047     String tabText = emptyString();
1048     bool first = true;
1049     size_t numEntries = tabList.size();
1050     for (size_t i = 0; i &lt; numEntries; ++i) {
1051         const String&amp; s = tabList[i];
1052 
1053         // append the non-tab textual part
1054         if (!s.isEmpty()) {
1055             if (!tabText.isEmpty()) {
1056                 paragraph.appendChild(createTabSpanElement(document, tabText));
1057                 tabText = emptyString();
1058             }
1059             Ref&lt;Node&gt; textNode = document.createTextNode(stringWithRebalancedWhitespace(s, first, i + 1 == numEntries));
1060             paragraph.appendChild(textNode);
1061         }
1062 
1063         // there is a tab after every entry, except the last entry
1064         // (if the last character is a tab, the list gets an extra empty entry)
1065         if (i + 1 != numEntries)
1066             tabText.append(&#39;\t&#39;);
1067         else if (!tabText.isEmpty())
1068             paragraph.appendChild(createTabSpanElement(document, tabText));
1069 
1070         first = false;
1071     }
1072 }
1073 
1074 bool isPlainTextMarkup(Node* node)
1075 {
1076     ASSERT(node);
1077     if (!is&lt;HTMLDivElement&gt;(*node))
1078         return false;
1079 
1080     HTMLDivElement&amp; element = downcast&lt;HTMLDivElement&gt;(*node);
1081     if (element.hasAttributes())
1082         return false;
1083 
1084     Node* firstChild = element.firstChild();
1085     if (!firstChild)
1086         return false;
1087 
1088     Node* secondChild = firstChild-&gt;nextSibling();
1089     if (!secondChild)
1090         return firstChild-&gt;isTextNode() || firstChild-&gt;firstChild();
1091 
1092     if (secondChild-&gt;nextSibling())
1093         return false;
1094 
1095     return isTabSpanTextNode(firstChild-&gt;firstChild()) &amp;&amp; secondChild-&gt;isTextNode();
1096 }
1097 
1098 static bool contextPreservesNewline(const Range&amp; context)
1099 {
1100     VisiblePosition position(context.startPosition());
1101     Node* container = position.deepEquivalent().containerNode();
1102     if (!container || !container-&gt;renderer())
1103         return false;
1104 
1105     return container-&gt;renderer()-&gt;style().preserveNewline();
1106 }
1107 
1108 Ref&lt;DocumentFragment&gt; createFragmentFromText(Range&amp; context, const String&amp; text)
1109 {
1110     Document&amp; document = context.ownerDocument();
1111     Ref&lt;DocumentFragment&gt; fragment = document.createDocumentFragment();
1112 
1113     if (text.isEmpty())
1114         return fragment;
1115 
1116     String string = text;
1117     string.replace(&quot;\r\n&quot;, &quot;\n&quot;);
1118     string.replace(&#39;\r&#39;, &#39;\n&#39;);
1119 
1120     auto createHTMLBRElement = [&amp;document]() {
1121         auto element = HTMLBRElement::create(document);
1122         element-&gt;setAttributeWithoutSynchronization(classAttr, AppleInterchangeNewline);
1123         return element;
1124     };
1125 
1126     if (contextPreservesNewline(context)) {
1127         fragment-&gt;appendChild(document.createTextNode(string));
1128         if (string.endsWith(&#39;\n&#39;)) {
1129             fragment-&gt;appendChild(createHTMLBRElement());
1130         }
1131         return fragment;
1132     }
1133 
1134     // A string with no newlines gets added inline, rather than being put into a paragraph.
1135     if (string.find(&#39;\n&#39;) == notFound) {
1136         fillContainerFromString(fragment, string);
1137         return fragment;
1138     }
1139 
1140     if (string.length() == 1 &amp;&amp; string[0] == &#39;\n&#39;) {
1141         // This is a single newline char, thus just create one HTMLBRElement.
1142         fragment-&gt;appendChild(createHTMLBRElement());
1143         return fragment;
1144     }
1145 
1146     // Break string into paragraphs. Extra line breaks turn into empty paragraphs.
1147     Node* blockNode = enclosingBlock(context.firstNode());
1148     Element* block = downcast&lt;Element&gt;(blockNode);
1149     bool useClonesOfEnclosingBlock = blockNode
1150         &amp;&amp; blockNode-&gt;isElementNode()
1151         &amp;&amp; !block-&gt;hasTagName(bodyTag)
1152         &amp;&amp; !block-&gt;hasTagName(htmlTag)
1153         &amp;&amp; block != editableRootForPosition(context.startPosition());
1154     bool useLineBreak = enclosingTextFormControl(context.startPosition());
1155 
1156     Vector&lt;String&gt; list = string.splitAllowingEmptyEntries(&#39;\n&#39;);
1157     size_t numLines = list.size();
1158     for (size_t i = 0; i &lt; numLines; ++i) {
1159         const String&amp; s = list[i];
1160 
1161         RefPtr&lt;Element&gt; element;
1162         if (s.isEmpty() &amp;&amp; i + 1 == numLines) {
1163             // For last line, use the &quot;magic BR&quot; rather than a P.
1164             element = createHTMLBRElement();
1165         } else if (useLineBreak) {
1166             element = HTMLBRElement::create(document);
1167             fillContainerFromString(fragment, s);
1168         } else {
1169             if (useClonesOfEnclosingBlock)
1170                 element = block-&gt;cloneElementWithoutChildren(document);
1171             else
1172                 element = createDefaultParagraphElement(document);
1173             fillContainerFromString(*element, s);
1174         }
1175         fragment-&gt;appendChild(*element);
1176     }
1177     return fragment;
1178 }
1179 
1180 String documentTypeString(const Document&amp; document)
1181 {
1182     DocumentType* documentType = document.doctype();
1183     if (!documentType)
1184         return emptyString();
1185     return serializeFragment(*documentType, SerializedNodes::SubtreeIncludingNode);
1186 }
1187 
1188 String urlToMarkup(const URL&amp; url, const String&amp; title)
1189 {
1190     StringBuilder markup;
1191     markup.appendLiteral(&quot;&lt;a href=\&quot;&quot;);
1192     markup.append(url.string());
1193     markup.appendLiteral(&quot;\&quot;&gt;&quot;);
1194     MarkupAccumulator::appendCharactersReplacingEntities(markup, title, 0, title.length(), EntityMaskInPCDATA);
1195     markup.appendLiteral(&quot;&lt;/a&gt;&quot;);
1196     return markup.toString();
1197 }
1198 
1199 ExceptionOr&lt;Ref&lt;DocumentFragment&gt;&gt; createFragmentForInnerOuterHTML(Element&amp; contextElement, const String&amp; markup, ParserContentPolicy parserContentPolicy)
1200 {
1201     auto* document = &amp;contextElement.document();
1202     if (contextElement.hasTagName(templateTag))
1203         document = &amp;document-&gt;ensureTemplateDocument();
1204     auto fragment = DocumentFragment::create(*document);
1205 
1206     if (document-&gt;isHTMLDocument()) {
1207         fragment-&gt;parseHTML(markup, &amp;contextElement, parserContentPolicy);
<a name="9" id="anc9"></a><span class="line-modified">1208         return fragment;</span>
1209     }
1210 
1211     bool wasValid = fragment-&gt;parseXML(markup, &amp;contextElement, parserContentPolicy);
1212     if (!wasValid)
1213         return Exception { SyntaxError };
<a name="10" id="anc10"></a><span class="line-modified">1214     return fragment;</span>
1215 }
1216 
1217 RefPtr&lt;DocumentFragment&gt; createFragmentForTransformToFragment(Document&amp; outputDoc, const String&amp; sourceString, const String&amp; sourceMIMEType)
1218 {
1219     RefPtr&lt;DocumentFragment&gt; fragment = outputDoc.createDocumentFragment();
1220 
1221     if (sourceMIMEType == &quot;text/html&quot;) {
1222         // As far as I can tell, there isn&#39;t a spec for how transformToFragment is supposed to work.
1223         // Based on the documentation I can find, it looks like we want to start parsing the fragment in the InBody insertion mode.
1224         // Unfortunately, that&#39;s an implementation detail of the parser.
1225         // We achieve that effect here by passing in a fake body element as context for the fragment.
1226         auto fakeBody = HTMLBodyElement::create(outputDoc);
1227         fragment-&gt;parseHTML(sourceString, fakeBody.ptr());
1228     } else if (sourceMIMEType == &quot;text/plain&quot;)
1229         fragment-&gt;parserAppendChild(Text::create(outputDoc, sourceString));
1230     else {
1231         bool successfulParse = fragment-&gt;parseXML(sourceString, 0);
1232         if (!successfulParse)
1233             return nullptr;
1234     }
1235 
1236     // FIXME: Do we need to mess with URLs here?
1237 
1238     return fragment;
1239 }
1240 
<a name="11" id="anc11"></a><span class="line-modified">1241 Ref&lt;DocumentFragment&gt; createFragmentForImageAndURL(Document&amp; document, const String&amp; url, PresentationSize preferredSize)</span>
1242 {
1243     auto imageElement = HTMLImageElement::create(document);
1244     imageElement-&gt;setAttributeWithoutSynchronization(HTMLNames::srcAttr, url);
<a name="12" id="anc12"></a><span class="line-modified">1245     if (preferredSize.width)</span>
<span class="line-added">1246         imageElement-&gt;setAttributeWithoutSynchronization(HTMLNames::widthAttr, AtomString::number(*preferredSize.width));</span>
<span class="line-added">1247     if (preferredSize.height)</span>
<span class="line-added">1248         imageElement-&gt;setAttributeWithoutSynchronization(HTMLNames::heightAttr, AtomString::number(*preferredSize.height));</span>
1249     auto fragment = document.createDocumentFragment();
1250     fragment-&gt;appendChild(imageElement);
1251 
1252     return fragment;
1253 }
1254 
1255 static Vector&lt;Ref&lt;HTMLElement&gt;&gt; collectElementsToRemoveFromFragment(ContainerNode&amp; container)
1256 {
1257     Vector&lt;Ref&lt;HTMLElement&gt;&gt; toRemove;
1258     for (auto&amp; element : childrenOfType&lt;HTMLElement&gt;(container)) {
1259         if (is&lt;HTMLHtmlElement&gt;(element)) {
1260             toRemove.append(element);
1261             collectElementsToRemoveFromFragment(element);
1262             continue;
1263         }
1264         if (is&lt;HTMLHeadElement&gt;(element) || is&lt;HTMLBodyElement&gt;(element))
1265             toRemove.append(element);
1266     }
1267     return toRemove;
1268 }
1269 
1270 static void removeElementFromFragmentPreservingChildren(DocumentFragment&amp; fragment, HTMLElement&amp; element)
1271 {
1272     RefPtr&lt;Node&gt; nextChild;
1273     for (RefPtr&lt;Node&gt; child = element.firstChild(); child; child = nextChild) {
1274         nextChild = child-&gt;nextSibling();
1275         element.removeChild(*child);
1276         fragment.insertBefore(*child, &amp;element);
1277     }
1278     fragment.removeChild(element);
1279 }
1280 
1281 ExceptionOr&lt;Ref&lt;DocumentFragment&gt;&gt; createContextualFragment(Element&amp; element, const String&amp; markup, ParserContentPolicy parserContentPolicy)
1282 {
1283     auto result = createFragmentForInnerOuterHTML(element, markup, parserContentPolicy);
1284     if (result.hasException())
1285         return result.releaseException();
1286 
1287     auto fragment = result.releaseReturnValue();
1288 
1289     // We need to pop &lt;html&gt; and &lt;body&gt; elements and remove &lt;head&gt; to
1290     // accommodate folks passing complete HTML documents to make the
1291     // child of an element.
1292     auto toRemove = collectElementsToRemoveFromFragment(fragment);
1293     for (auto&amp; element : toRemove)
1294         removeElementFromFragmentPreservingChildren(fragment, element);
1295 
<a name="13" id="anc13"></a><span class="line-modified">1296     return fragment;</span>
1297 }
1298 
1299 static inline bool hasOneChild(ContainerNode&amp; node)
1300 {
1301     Node* firstChild = node.firstChild();
1302     return firstChild &amp;&amp; !firstChild-&gt;nextSibling();
1303 }
1304 
1305 static inline bool hasOneTextChild(ContainerNode&amp; node)
1306 {
1307     return hasOneChild(node) &amp;&amp; node.firstChild()-&gt;isTextNode();
1308 }
1309 
1310 static inline bool hasMutationEventListeners(const Document&amp; document)
1311 {
1312     return document.hasListenerType(Document::DOMSUBTREEMODIFIED_LISTENER)
1313         || document.hasListenerType(Document::DOMNODEINSERTED_LISTENER)
1314         || document.hasListenerType(Document::DOMNODEREMOVED_LISTENER)
1315         || document.hasListenerType(Document::DOMNODEREMOVEDFROMDOCUMENT_LISTENER)
1316         || document.hasListenerType(Document::DOMCHARACTERDATAMODIFIED_LISTENER);
1317 }
1318 
1319 // We can use setData instead of replacing Text node as long as script can&#39;t observe the difference.
1320 static inline bool canUseSetDataOptimization(const Text&amp; containerChild, const ChildListMutationScope&amp; mutationScope)
1321 {
1322     bool authorScriptMayHaveReference = containerChild.refCount();
1323     return !authorScriptMayHaveReference &amp;&amp; !mutationScope.canObserve() &amp;&amp; !hasMutationEventListeners(containerChild.document());
1324 }
1325 
1326 ExceptionOr&lt;void&gt; replaceChildrenWithFragment(ContainerNode&amp; container, Ref&lt;DocumentFragment&gt;&amp;&amp; fragment)
1327 {
1328     Ref&lt;ContainerNode&gt; containerNode(container);
1329     ChildListMutationScope mutation(containerNode);
1330 
1331     if (!fragment-&gt;firstChild()) {
1332         containerNode-&gt;removeChildren();
1333         return { };
1334     }
1335 
1336     auto* containerChild = containerNode-&gt;firstChild();
1337     if (containerChild &amp;&amp; !containerChild-&gt;nextSibling()) {
1338         if (is&lt;Text&gt;(*containerChild) &amp;&amp; hasOneTextChild(fragment) &amp;&amp; canUseSetDataOptimization(downcast&lt;Text&gt;(*containerChild), mutation)) {
1339             ASSERT(!fragment-&gt;firstChild()-&gt;refCount());
1340             downcast&lt;Text&gt;(*containerChild).setData(downcast&lt;Text&gt;(*fragment-&gt;firstChild()).data());
1341             return { };
1342         }
1343 
1344         return containerNode-&gt;replaceChild(fragment, *containerChild);
1345     }
1346 
1347     containerNode-&gt;removeChildren();
1348     return containerNode-&gt;appendChild(fragment);
1349 }
1350 
1351 }
<a name="14" id="anc14"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="14" type="hidden" />
</body>
</html>