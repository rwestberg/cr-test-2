<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WebCore/css/CSSComputedStyleDeclaration.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2004 Zack Rusin &lt;zack@kde.org&gt;
   3  * Copyright (C) 2004-2019 Apple Inc. All rights reserved.
   4  * Copyright (C) 2007 Alexey Proskuryakov &lt;ap@webkit.org&gt;
   5  * Copyright (C) 2007 Nicholas Shanks &lt;webkit@nickshanks.com&gt;
   6  * Copyright (C) 2011 Sencha, Inc. All rights reserved.
   7  * Copyright (C) 2013 Adobe Systems Incorporated. All rights reserved.
   8  *
   9  * This library is free software; you can redistribute it and/or
  10  * modify it under the terms of the GNU Lesser General Public
  11  * License as published by the Free Software Foundation; either
  12  * version 2 of the License, or (at your option) any later version.
  13  *
  14  * This library is distributed in the hope that it will be useful,
  15  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  16  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  17  * Lesser General Public License for more details.
  18  *
  19  * You should have received a copy of the GNU Lesser General Public
  20  * License along with this library; if not, write to the Free Software
  21  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
  22  * 02110-1301  USA
  23  */
  24 
  25 #include &quot;config.h&quot;
  26 #include &quot;CSSComputedStyleDeclaration.h&quot;
  27 
  28 #include &quot;BasicShapeFunctions.h&quot;
  29 #include &quot;CSSAnimationController.h&quot;
  30 #include &quot;CSSAspectRatioValue.h&quot;
  31 #include &quot;CSSBasicShapes.h&quot;
  32 #include &quot;CSSBorderImage.h&quot;
  33 #include &quot;CSSBorderImageSliceValue.h&quot;
  34 #include &quot;CSSFontFeatureValue.h&quot;
  35 #include &quot;CSSFontStyleValue.h&quot;
  36 #include &quot;CSSFontValue.h&quot;
  37 #include &quot;CSSFontVariationValue.h&quot;
  38 #include &quot;CSSFunctionValue.h&quot;
  39 #include &quot;CSSLineBoxContainValue.h&quot;
  40 #include &quot;CSSPrimitiveValue.h&quot;
  41 #include &quot;CSSPrimitiveValueMappings.h&quot;
  42 #include &quot;CSSPropertyNames.h&quot;
  43 #include &quot;CSSPropertyParser.h&quot;
  44 #include &quot;CSSReflectValue.h&quot;
  45 #include &quot;CSSSelector.h&quot;
  46 #include &quot;CSSShadowValue.h&quot;
  47 #include &quot;CSSTimingFunctionValue.h&quot;
  48 #include &quot;CSSValueList.h&quot;
  49 #include &quot;CSSValuePool.h&quot;
  50 #include &quot;ComposedTreeAncestorIterator.h&quot;
  51 #include &quot;ContentData.h&quot;
  52 #include &quot;CursorList.h&quot;
  53 #include &quot;DeprecatedCSSOMValue.h&quot;
  54 #include &quot;Document.h&quot;
  55 #include &quot;DocumentTimeline.h&quot;
  56 #include &quot;FontCascade.h&quot;
  57 #include &quot;FontSelectionValueInlines.h&quot;
  58 #include &quot;FontTaggedSettings.h&quot;
  59 #include &quot;NodeRenderStyle.h&quot;
  60 #include &quot;Pair.h&quot;
  61 #include &quot;Rect.h&quot;
  62 #include &quot;RenderBlock.h&quot;
  63 #include &quot;RenderBox.h&quot;
  64 #include &quot;RenderInline.h&quot;
  65 #include &quot;RenderStyle.h&quot;
  66 #include &quot;RuntimeEnabledFeatures.h&quot;
  67 #include &quot;SVGElement.h&quot;
  68 #include &quot;Settings.h&quot;
  69 #include &quot;ShapeValue.h&quot;
  70 #include &quot;StyleProperties.h&quot;
  71 #include &quot;StylePropertyShorthand.h&quot;
  72 #include &quot;StylePropertyShorthandFunctions.h&quot;
  73 #include &quot;StyleResolver.h&quot;
  74 #include &quot;StyleScope.h&quot;
  75 #include &quot;StyleScrollSnapPoints.h&quot;
  76 #include &quot;TouchAction.h&quot;
  77 #include &quot;WebKitFontFamilyNames.h&quot;
  78 #include &quot;WillChangeData.h&quot;
  79 #include &lt;wtf/NeverDestroyed.h&gt;
  80 #include &lt;wtf/text/StringBuilder.h&gt;
  81 
  82 #include &quot;CSSGridLineNamesValue.h&quot;
  83 #include &quot;CSSGridTemplateAreasValue.h&quot;
  84 #include &quot;RenderGrid.h&quot;
  85 
  86 #if ENABLE(DASHBOARD_SUPPORT)
  87 #include &quot;DashboardRegion.h&quot;
  88 #endif
  89 
  90 namespace WebCore {
  91 
  92 // List of all properties we know how to compute, omitting shorthands.
  93 static const CSSPropertyID computedProperties[] = {
  94     CSSPropertyAlt,
  95     CSSPropertyAnimationDelay,
  96     CSSPropertyAnimationDirection,
  97     CSSPropertyAnimationDuration,
  98     CSSPropertyAnimationFillMode,
  99     CSSPropertyAnimationIterationCount,
 100     CSSPropertyAnimationName,
 101     CSSPropertyAnimationPlayState,
 102     CSSPropertyAnimationTimingFunction,
 103     CSSPropertyBackgroundAttachment,
 104     CSSPropertyBackgroundBlendMode,
 105     CSSPropertyBackgroundClip,
 106     CSSPropertyBackgroundColor,
 107     CSSPropertyBackgroundImage,
 108     CSSPropertyBackgroundOrigin,
 109     CSSPropertyBackgroundPosition, // more-specific background-position-x/y are non-standard
 110     CSSPropertyBackgroundRepeat,
 111     CSSPropertyBackgroundSize,
 112     CSSPropertyBorderBottomColor,
 113     CSSPropertyBorderBottomLeftRadius,
 114     CSSPropertyBorderBottomRightRadius,
 115     CSSPropertyBorderBottomStyle,
 116     CSSPropertyBorderBottomWidth,
 117     CSSPropertyBorderCollapse,
 118     CSSPropertyBorderImageOutset,
 119     CSSPropertyBorderImageRepeat,
 120     CSSPropertyBorderImageSlice,
 121     CSSPropertyBorderImageSource,
 122     CSSPropertyBorderImageWidth,
 123     CSSPropertyBorderLeftColor,
 124     CSSPropertyBorderLeftStyle,
 125     CSSPropertyBorderLeftWidth,
 126     CSSPropertyBorderRightColor,
 127     CSSPropertyBorderRightStyle,
 128     CSSPropertyBorderRightWidth,
 129     CSSPropertyBorderTopColor,
 130     CSSPropertyBorderTopLeftRadius,
 131     CSSPropertyBorderTopRightRadius,
 132     CSSPropertyBorderTopStyle,
 133     CSSPropertyBorderTopWidth,
 134     CSSPropertyBottom,
 135     CSSPropertyBoxShadow,
 136     CSSPropertyBoxSizing,
 137     CSSPropertyCaptionSide,
 138     CSSPropertyCaretColor,
 139     CSSPropertyClear,
 140     CSSPropertyClip,
 141     CSSPropertyColor,
 142     CSSPropertyAppleColorFilter,
 143     CSSPropertyCounterIncrement,
 144     CSSPropertyCounterReset,
 145     CSSPropertyContent,
 146     CSSPropertyCursor,
 147     CSSPropertyDirection,
 148     CSSPropertyDisplay,
 149     CSSPropertyEmptyCells,
 150     CSSPropertyFloat,
 151     CSSPropertyFontFamily,
 152     CSSPropertyFontSize,
 153     CSSPropertyFontStretch,
 154     CSSPropertyFontStyle,
 155     CSSPropertyFontSynthesis,
 156     CSSPropertyFontVariant,
 157     CSSPropertyFontWeight,
 158 #if ENABLE(VARIATION_FONTS)
 159     CSSPropertyFontOpticalSizing,
 160 #endif
 161     CSSPropertyHangingPunctuation,
 162     CSSPropertyHeight,
 163 #if ENABLE(CSS_IMAGE_ORIENTATION)
 164     CSSPropertyImageOrientation,
 165 #endif
 166     CSSPropertyImageRendering,
 167 #if ENABLE(CSS_IMAGE_RESOLUTION)
 168     CSSPropertyImageResolution,
 169 #endif
 170     CSSPropertyLeft,
 171     CSSPropertyLetterSpacing,
 172     CSSPropertyLineHeight,
 173     CSSPropertyListStyleImage,
 174     CSSPropertyListStylePosition,
 175     CSSPropertyListStyleType,
 176     CSSPropertyMarginBottom,
 177     CSSPropertyMarginLeft,
 178     CSSPropertyMarginRight,
 179     CSSPropertyMarginTop,
 180     CSSPropertyMaxHeight,
 181     CSSPropertyMaxWidth,
 182     CSSPropertyMinHeight,
 183     CSSPropertyMinWidth,
 184     CSSPropertyObjectFit,
 185     CSSPropertyObjectPosition,
 186     CSSPropertyOpacity,
 187     CSSPropertyOrphans,
 188     CSSPropertyOutlineColor,
 189     CSSPropertyOutlineOffset,
 190     CSSPropertyOutlineStyle,
 191     CSSPropertyOutlineWidth,
 192     CSSPropertyOverflowWrap,
 193     CSSPropertyOverflowX,
 194     CSSPropertyOverflowY,
 195     CSSPropertyPaddingBottom,
 196     CSSPropertyPaddingLeft,
 197     CSSPropertyPaddingRight,
 198     CSSPropertyPaddingTop,
 199     CSSPropertyPageBreakAfter,
 200     CSSPropertyPageBreakBefore,
 201     CSSPropertyPageBreakInside,
 202     CSSPropertyPointerEvents,
 203     CSSPropertyPosition,
 204     CSSPropertyResize,
 205     CSSPropertyRight,
 206     CSSPropertySpeakAs,
 207     CSSPropertyTableLayout,
 208     CSSPropertyTabSize,
 209     CSSPropertyTextAlign,
 210     CSSPropertyTextDecoration,
 211 #if ENABLE(CSS3_TEXT)
 212     CSSPropertyWebkitTextAlignLast,
 213     CSSPropertyWebkitTextJustify,
 214 #endif // CSS3_TEXT
 215     CSSPropertyTextDecorationLine,
 216     CSSPropertyTextDecorationStyle,
 217     CSSPropertyTextDecorationColor,
 218     CSSPropertyTextDecorationSkip,
 219     CSSPropertyTextUnderlinePosition,
 220     CSSPropertyTextIndent,
 221     CSSPropertyTextRendering,
 222     CSSPropertyTextShadow,
 223     CSSPropertyTextOverflow,
 224     CSSPropertyTextTransform,
 225     CSSPropertyTop,
 226     CSSPropertyTransform,
 227     CSSPropertyTransformBox,
 228     CSSPropertyTransformOrigin,
 229     CSSPropertyTransformStyle,
 230     CSSPropertyTransitionDelay,
 231     CSSPropertyTransitionDuration,
 232     CSSPropertyTransitionProperty,
 233     CSSPropertyTransitionTimingFunction,
 234     CSSPropertyUnicodeBidi,
 235     CSSPropertyVerticalAlign,
 236     CSSPropertyVisibility,
 237     CSSPropertyWhiteSpace,
 238     CSSPropertyWidows,
 239     CSSPropertyWidth,
 240     CSSPropertyWillChange,
 241     CSSPropertyWordBreak,
 242     CSSPropertyWordSpacing,
 243     CSSPropertyWordWrap,
 244 #if ENABLE(CSS_SCROLL_SNAP)
 245     CSSPropertyScrollSnapMargin,
 246     CSSPropertyScrollSnapMarginLeft,
 247     CSSPropertyScrollSnapMarginTop,
 248     CSSPropertyScrollSnapMarginRight,
 249     CSSPropertyScrollSnapMarginBottom,
 250     CSSPropertyScrollPadding,
 251     CSSPropertyScrollPaddingLeft,
 252     CSSPropertyScrollPaddingTop,
 253     CSSPropertyScrollPaddingRight,
 254     CSSPropertyScrollPaddingBottom,
 255     CSSPropertyScrollSnapType,
 256     CSSPropertyScrollSnapAlign,
 257 #endif
 258     CSSPropertyZIndex,
 259     CSSPropertyZoom,
 260     CSSPropertyWebkitAppearance,
 261     CSSPropertyWebkitBackfaceVisibility,
 262     CSSPropertyWebkitBackgroundClip,
 263     CSSPropertyWebkitBackgroundComposite,
 264     CSSPropertyWebkitBackgroundOrigin,
 265     CSSPropertyWebkitBackgroundSize,
 266 #if ENABLE(CSS_COMPOSITING)
 267     CSSPropertyMixBlendMode,
 268     CSSPropertyIsolation,
 269 #endif
 270     CSSPropertyWebkitBorderFit,
 271     CSSPropertyWebkitBorderHorizontalSpacing,
 272     CSSPropertyWebkitBorderImage,
 273     CSSPropertyWebkitBorderVerticalSpacing,
 274     CSSPropertyWebkitBoxAlign,
 275 #if ENABLE(CSS_BOX_DECORATION_BREAK)
 276     CSSPropertyWebkitBoxDecorationBreak,
 277 #endif
 278     CSSPropertyWebkitBoxDirection,
 279     CSSPropertyWebkitBoxFlex,
 280     CSSPropertyWebkitBoxFlexGroup,
 281     CSSPropertyWebkitBoxLines,
 282     CSSPropertyWebkitBoxOrdinalGroup,
 283     CSSPropertyWebkitBoxOrient,
 284     CSSPropertyWebkitBoxPack,
 285     CSSPropertyWebkitBoxReflect,
 286     CSSPropertyWebkitBoxShadow,
 287     CSSPropertyWebkitClipPath,
 288     CSSPropertyWebkitColumnBreakAfter,
 289     CSSPropertyWebkitColumnBreakBefore,
 290     CSSPropertyWebkitColumnBreakInside,
 291     CSSPropertyWebkitColumnAxis,
 292     CSSPropertyColumnCount,
 293     CSSPropertyColumnFill,
 294     CSSPropertyColumnGap,
 295     CSSPropertyRowGap,
 296     CSSPropertyWebkitColumnProgression,
 297     CSSPropertyColumnRuleColor,
 298     CSSPropertyColumnRuleStyle,
 299     CSSPropertyColumnRuleWidth,
 300     CSSPropertyColumnSpan,
 301     CSSPropertyColumnWidth,
 302 #if ENABLE(CURSOR_VISIBILITY)
 303     CSSPropertyWebkitCursorVisibility,
 304 #endif
 305 #if ENABLE(DASHBOARD_SUPPORT)
 306     CSSPropertyWebkitDashboardRegion,
 307 #endif
 308     CSSPropertyAlignContent,
 309     CSSPropertyAlignItems,
 310     CSSPropertyAlignSelf,
 311     CSSPropertyFilter,
 312     CSSPropertyFlexBasis,
 313     CSSPropertyFlexDirection,
 314     CSSPropertyFlexFlow,
 315     CSSPropertyFlexGrow,
 316     CSSPropertyFlexShrink,
 317     CSSPropertyFlexWrap,
 318     CSSPropertyJustifyContent,
 319     CSSPropertyJustifySelf,
 320     CSSPropertyJustifyItems,
 321     CSSPropertyPlaceContent,
 322     CSSPropertyPlaceItems,
 323     CSSPropertyPlaceSelf,
 324 #if ENABLE(FILTERS_LEVEL_2)
 325     CSSPropertyWebkitBackdropFilter,
 326 #endif
 327     CSSPropertyWebkitFontKerning,
 328     CSSPropertyWebkitFontSmoothing,
 329     CSSPropertyFontVariantLigatures,
 330     CSSPropertyFontVariantPosition,
 331     CSSPropertyFontVariantCaps,
 332     CSSPropertyFontVariantNumeric,
 333     CSSPropertyFontVariantAlternates,
 334     CSSPropertyFontVariantEastAsian,
 335 #if ENABLE(VARIATION_FONTS)
 336     CSSPropertyFontVariationSettings,
 337 #endif
 338     CSSPropertyGridAutoColumns,
 339     CSSPropertyGridAutoFlow,
 340     CSSPropertyGridAutoRows,
 341     CSSPropertyGridColumnEnd,
 342     CSSPropertyGridColumnStart,
 343     CSSPropertyGridTemplateAreas,
 344     CSSPropertyGridTemplateColumns,
 345     CSSPropertyGridTemplateRows,
 346     CSSPropertyGridRowEnd,
 347     CSSPropertyGridRowStart,
 348     CSSPropertyWebkitHyphenateCharacter,
 349     CSSPropertyWebkitHyphenateLimitAfter,
 350     CSSPropertyWebkitHyphenateLimitBefore,
 351     CSSPropertyWebkitHyphenateLimitLines,
 352     CSSPropertyWebkitHyphens,
 353     CSSPropertyWebkitInitialLetter,
 354     CSSPropertyWebkitLineAlign,
 355     CSSPropertyWebkitLineBoxContain,
 356     CSSPropertyLineBreak,
 357     CSSPropertyWebkitLineClamp,
 358     CSSPropertyWebkitLineGrid,
 359     CSSPropertyWebkitLineSnap,
 360     CSSPropertyWebkitLocale,
 361     CSSPropertyWebkitMarginBeforeCollapse,
 362     CSSPropertyWebkitMarginAfterCollapse,
 363     CSSPropertyWebkitMarqueeDirection,
 364     CSSPropertyWebkitMarqueeIncrement,
 365     CSSPropertyWebkitMarqueeRepetition,
 366     CSSPropertyWebkitMarqueeStyle,
 367     CSSPropertyWebkitMaskBoxImage,
 368     CSSPropertyWebkitMaskBoxImageOutset,
 369     CSSPropertyWebkitMaskBoxImageRepeat,
 370     CSSPropertyWebkitMaskBoxImageSlice,
 371     CSSPropertyWebkitMaskBoxImageSource,
 372     CSSPropertyWebkitMaskBoxImageWidth,
 373     CSSPropertyWebkitMaskClip,
 374     CSSPropertyWebkitMaskComposite,
 375     CSSPropertyWebkitMaskImage,
 376     CSSPropertyWebkitMaskOrigin,
 377     CSSPropertyWebkitMaskPosition,
 378     CSSPropertyWebkitMaskRepeat,
 379     CSSPropertyWebkitMaskSize,
 380     CSSPropertyWebkitMaskSourceType,
 381     CSSPropertyWebkitNbspMode,
 382     CSSPropertyOrder,
 383 #if ENABLE(ACCELERATED_OVERFLOW_SCROLLING)
 384     CSSPropertyWebkitOverflowScrolling,
 385 #endif
 386     CSSPropertyPerspective,
 387     CSSPropertyPerspectiveOrigin,
 388     CSSPropertyWebkitPrintColorAdjust,
 389     CSSPropertyWebkitRtlOrdering,
 390 #if PLATFORM(IOS_FAMILY)
 391     CSSPropertyWebkitTouchCallout,
 392 #endif
 393 #if ENABLE(TOUCH_EVENTS)
 394     CSSPropertyWebkitTapHighlightColor,
 395 #endif
 396     CSSPropertyWebkitTextCombine,
 397     CSSPropertyWebkitTextDecorationsInEffect,
 398     CSSPropertyWebkitTextEmphasisColor,
 399     CSSPropertyWebkitTextEmphasisPosition,
 400     CSSPropertyWebkitTextEmphasisStyle,
 401     CSSPropertyWebkitTextFillColor,
 402     CSSPropertyWebkitTextOrientation,
 403     CSSPropertyWebkitTextSecurity,
 404 #if ENABLE(TEXT_AUTOSIZING)
 405     CSSPropertyWebkitTextSizeAdjust,
 406 #endif
 407     CSSPropertyWebkitTextStrokeColor,
 408     CSSPropertyWebkitTextStrokeWidth,
 409     CSSPropertyWebkitTextZoom,
 410     CSSPropertyWebkitTransformStyle,
 411     CSSPropertyWebkitUserDrag,
 412     CSSPropertyWebkitUserModify,
 413     CSSPropertyWebkitUserSelect,
 414     CSSPropertyShapeImageThreshold,
 415     CSSPropertyShapeMargin,
 416     CSSPropertyShapeOutside,
 417     CSSPropertyShapeRendering,
 418     CSSPropertyBufferedRendering,
 419     CSSPropertyClipPath,
 420     CSSPropertyClipRule,
 421     CSSPropertyCx,
 422     CSSPropertyCy,
 423     CSSPropertyMask,
 424     CSSPropertyMaskType,
 425     CSSPropertyFloodColor,
 426     CSSPropertyFloodOpacity,
 427     CSSPropertyLightingColor,
 428     CSSPropertyStopColor,
 429     CSSPropertyStopOpacity,
 430     CSSPropertyColorInterpolation,
 431     CSSPropertyColorInterpolationFilters,
 432     CSSPropertyColorRendering,
 433     CSSPropertyFill,
 434     CSSPropertyFillOpacity,
 435     CSSPropertyFillRule,
 436     CSSPropertyMarkerEnd,
 437     CSSPropertyMarkerMid,
 438     CSSPropertyMarkerStart,
 439     CSSPropertyPaintOrder,
 440     CSSPropertyR,
 441     CSSPropertyRx,
 442     CSSPropertyRy,
 443     CSSPropertyStroke,
 444     CSSPropertyStrokeColor,
 445     CSSPropertyStrokeDasharray,
 446     CSSPropertyStrokeDashoffset,
 447     CSSPropertyStrokeLinecap,
 448     CSSPropertyStrokeLinejoin,
 449     CSSPropertyStrokeMiterlimit,
 450     CSSPropertyStrokeOpacity,
 451     CSSPropertyStrokeWidth,
 452 #if ENABLE(DARK_MODE_CSS)
 453     CSSPropertySupportedColorSchemes,
 454 #endif
 455     CSSPropertyAlignmentBaseline,
 456     CSSPropertyBaselineShift,
 457     CSSPropertyDominantBaseline,
 458     CSSPropertyKerning,
 459     CSSPropertyTextAnchor,
 460     CSSPropertyWritingMode,
 461     CSSPropertyGlyphOrientationHorizontal,
 462     CSSPropertyGlyphOrientationVertical,
 463     CSSPropertyVectorEffect,
 464     CSSPropertyX,
 465     CSSPropertyY
 466 };
 467 
 468 const unsigned numComputedProperties = WTF_ARRAY_LENGTH(computedProperties);
 469 
 470 static CSSValueID valueForRepeatRule(int rule)
 471 {
 472     switch (rule) {
 473         case RepeatImageRule:
 474             return CSSValueRepeat;
 475         case RoundImageRule:
 476             return CSSValueRound;
 477         case SpaceImageRule:
 478             return CSSValueSpace;
 479         default:
 480             return CSSValueStretch;
 481     }
 482 }
 483 
 484 static Ref&lt;CSSPrimitiveValue&gt; valueForImageSliceSide(const Length&amp; length)
 485 {
 486     // These values can be percentages, numbers, or while an animation of mixed types is in progress,
 487     // a calculation that combines a percentage and a number.
 488     if (length.isPercent())
 489         return CSSValuePool::singleton().createValue(length.percent(), CSSPrimitiveValue::CSS_PERCENTAGE);
 490     if (length.isFixed())
 491         return CSSValuePool::singleton().createValue(length.value(), CSSPrimitiveValue::CSS_NUMBER);
 492 
 493     // Calculating the actual length currently in use would require most of the code from RenderBoxModelObject::paintNinePieceImage.
 494     // And even if we could do that, it&#39;s not clear if that&#39;s exactly what we&#39;d want during animation.
 495     // FIXME: For now, just return 0.
 496     ASSERT(length.isCalculated());
 497     return CSSValuePool::singleton().createValue(0, CSSPrimitiveValue::CSS_NUMBER);
 498 }
 499 
 500 static Ref&lt;CSSBorderImageSliceValue&gt; valueForNinePieceImageSlice(const NinePieceImage&amp; image)
 501 {
 502     auto&amp; slices = image.imageSlices();
 503 
 504     RefPtr&lt;CSSPrimitiveValue&gt; top = valueForImageSliceSide(slices.top());
 505 
 506     RefPtr&lt;CSSPrimitiveValue&gt; right;
 507     RefPtr&lt;CSSPrimitiveValue&gt; bottom;
 508     RefPtr&lt;CSSPrimitiveValue&gt; left;
 509 
 510     if (slices.right() == slices.top() &amp;&amp; slices.bottom() == slices.top() &amp;&amp; slices.left() == slices.top()) {
 511         right = top;
 512         bottom = top;
 513         left = top;
 514     } else {
 515         right = valueForImageSliceSide(slices.right());
 516 
 517         if (slices.bottom() == slices.top() &amp;&amp; slices.right() == slices.left()) {
 518             bottom = top;
 519             left = right;
 520         } else {
 521             bottom = valueForImageSliceSide(slices.bottom());
 522 
 523             if (slices.left() == slices.right())
 524                 left = right;
 525             else
 526                 left = valueForImageSliceSide(slices.left());
 527         }
 528     }
 529 
 530     auto quad = Quad::create();
 531     quad-&gt;setTop(WTFMove(top));
 532     quad-&gt;setRight(WTFMove(right));
 533     quad-&gt;setBottom(WTFMove(bottom));
 534     quad-&gt;setLeft(WTFMove(left));
 535 
 536     return CSSBorderImageSliceValue::create(CSSValuePool::singleton().createValue(WTFMove(quad)), image.fill());
 537 }
 538 
 539 static Ref&lt;CSSPrimitiveValue&gt; valueForNinePieceImageQuad(const LengthBox&amp; box)
 540 {
 541     RefPtr&lt;CSSPrimitiveValue&gt; top;
 542     RefPtr&lt;CSSPrimitiveValue&gt; right;
 543     RefPtr&lt;CSSPrimitiveValue&gt; bottom;
 544     RefPtr&lt;CSSPrimitiveValue&gt; left;
 545 
 546     auto&amp; cssValuePool = CSSValuePool::singleton();
 547 
 548     if (box.top().isRelative())
 549         top = cssValuePool.createValue(box.top().value(), CSSPrimitiveValue::CSS_NUMBER);
 550     else
 551         top = cssValuePool.createValue(box.top());
 552 
 553     if (box.right() == box.top() &amp;&amp; box.bottom() == box.top() &amp;&amp; box.left() == box.top()) {
 554         right = top;
 555         bottom = top;
 556         left = top;
 557     } else {
 558         if (box.right().isRelative())
 559             right = cssValuePool.createValue(box.right().value(), CSSPrimitiveValue::CSS_NUMBER);
 560         else
 561             right = cssValuePool.createValue(box.right());
 562 
 563         if (box.bottom() == box.top() &amp;&amp; box.right() == box.left()) {
 564             bottom = top;
 565             left = right;
 566         } else {
 567             if (box.bottom().isRelative())
 568                 bottom = cssValuePool.createValue(box.bottom().value(), CSSPrimitiveValue::CSS_NUMBER);
 569             else
 570                 bottom = cssValuePool.createValue(box.bottom());
 571 
 572             if (box.left() == box.right())
 573                 left = right;
 574             else {
 575                 if (box.left().isRelative())
 576                     left = cssValuePool.createValue(box.left().value(), CSSPrimitiveValue::CSS_NUMBER);
 577                 else
 578                     left = cssValuePool.createValue(box.left());
 579             }
 580         }
 581     }
 582 
 583     auto quad = Quad::create();
 584     quad-&gt;setTop(WTFMove(top));
 585     quad-&gt;setRight(WTFMove(right));
 586     quad-&gt;setBottom(WTFMove(bottom));
 587     quad-&gt;setLeft(WTFMove(left));
 588 
 589     return cssValuePool.createValue(WTFMove(quad));
 590 }
 591 
 592 static Ref&lt;CSSValue&gt; valueForNinePieceImageRepeat(const NinePieceImage&amp; image)
 593 {
 594     auto&amp; cssValuePool = CSSValuePool::singleton();
 595     auto horizontalRepeat = cssValuePool.createIdentifierValue(valueForRepeatRule(image.horizontalRule()));
 596     RefPtr&lt;CSSPrimitiveValue&gt; verticalRepeat;
 597     if (image.horizontalRule() == image.verticalRule())
 598         verticalRepeat = horizontalRepeat.copyRef();
 599     else
 600         verticalRepeat = cssValuePool.createIdentifierValue(valueForRepeatRule(image.verticalRule()));
 601     return cssValuePool.createValue(Pair::create(WTFMove(horizontalRepeat), WTFMove(verticalRepeat)));
 602 }
 603 
 604 static Ref&lt;CSSValue&gt; valueForNinePieceImage(const NinePieceImage&amp; image)
 605 {
 606     if (!image.hasImage())
 607         return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
 608 
 609     // Image first.
 610     RefPtr&lt;CSSValue&gt; imageValue;
 611     if (image.image())
 612         imageValue = image.image()-&gt;cssValue();
 613 
 614     // Create the image slice.
 615     RefPtr&lt;CSSBorderImageSliceValue&gt; imageSlices = valueForNinePieceImageSlice(image);
 616 
 617     // Create the border area slices.
 618     RefPtr&lt;CSSValue&gt; borderSlices = valueForNinePieceImageQuad(image.borderSlices());
 619 
 620     // Create the border outset.
 621     RefPtr&lt;CSSValue&gt; outset = valueForNinePieceImageQuad(image.outset());
 622 
 623     // Create the repeat rules.
 624     RefPtr&lt;CSSValue&gt; repeat = valueForNinePieceImageRepeat(image);
 625 
 626     return createBorderImageValue(WTFMove(imageValue), WTFMove(imageSlices), WTFMove(borderSlices), WTFMove(outset), WTFMove(repeat));
 627 }
 628 
 629 inline static Ref&lt;CSSPrimitiveValue&gt; zoomAdjustedPixelValue(double value, const RenderStyle&amp; style)
 630 {
 631     return CSSValuePool::singleton().createValue(adjustFloatForAbsoluteZoom(value, style), CSSPrimitiveValue::CSS_PX);
 632 }
 633 
 634 inline static Ref&lt;CSSPrimitiveValue&gt; zoomAdjustedNumberValue(double value, const RenderStyle&amp; style)
 635 {
 636     return CSSValuePool::singleton().createValue(value / style.effectiveZoom(), CSSPrimitiveValue::CSS_NUMBER);
 637 }
 638 
 639 static Ref&lt;CSSValue&gt; zoomAdjustedPixelValueForLength(const Length&amp; length, const RenderStyle&amp; style)
 640 {
 641     if (length.isFixed())
 642         return zoomAdjustedPixelValue(length.value(), style);
 643     return CSSValuePool::singleton().createValue(length, style);
 644 }
 645 
 646 static Ref&lt;CSSValue&gt; valueForReflection(const StyleReflection* reflection, const RenderStyle&amp; style)
 647 {
 648     if (!reflection)
 649         return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
 650 
 651     RefPtr&lt;CSSPrimitiveValue&gt; offset;
 652     if (reflection-&gt;offset().isPercentOrCalculated())
 653         offset = CSSValuePool::singleton().createValue(reflection-&gt;offset().percent(), CSSPrimitiveValue::CSS_PERCENTAGE);
 654     else
 655         offset = zoomAdjustedPixelValue(reflection-&gt;offset().value(), style);
 656 
 657     RefPtr&lt;CSSPrimitiveValue&gt; direction;
 658     switch (reflection-&gt;direction()) {
 659     case ReflectionBelow:
 660         direction = CSSValuePool::singleton().createIdentifierValue(CSSValueBelow);
 661         break;
 662     case ReflectionAbove:
 663         direction = CSSValuePool::singleton().createIdentifierValue(CSSValueAbove);
 664         break;
 665     case ReflectionLeft:
 666         direction = CSSValuePool::singleton().createIdentifierValue(CSSValueLeft);
 667         break;
 668     case ReflectionRight:
 669         direction = CSSValuePool::singleton().createIdentifierValue(CSSValueRight);
 670         break;
 671     }
 672 
 673     return CSSReflectValue::create(direction.releaseNonNull(), offset.releaseNonNull(), valueForNinePieceImage(reflection-&gt;mask()));
 674 }
 675 
 676 static Ref&lt;CSSValueList&gt; createPositionListForLayer(CSSPropertyID propertyID, const FillLayer&amp; layer, const RenderStyle&amp; style)
 677 {
 678     auto list = CSSValueList::createSpaceSeparated();
 679     if (layer.isBackgroundXOriginSet()) {
 680         ASSERT_UNUSED(propertyID, propertyID == CSSPropertyBackgroundPosition || propertyID == CSSPropertyWebkitMaskPosition);
 681         list-&gt;append(CSSValuePool::singleton().createValue(layer.backgroundXOrigin()));
 682     }
 683     list-&gt;append(zoomAdjustedPixelValueForLength(layer.xPosition(), style));
 684     if (layer.isBackgroundYOriginSet()) {
 685         ASSERT(propertyID == CSSPropertyBackgroundPosition || propertyID == CSSPropertyWebkitMaskPosition);
 686         list-&gt;append(CSSValuePool::singleton().createValue(layer.backgroundYOrigin()));
 687     }
 688     list-&gt;append(zoomAdjustedPixelValueForLength(layer.yPosition(), style));
 689     return list;
 690 }
 691 
 692 static Length getOffsetComputedLength(const RenderStyle&amp; style, CSSPropertyID propertyID)
 693 {
 694     // If specified as a length, the corresponding absolute length; if specified as
 695     // a percentage, the specified value; otherwise, &#39;auto&#39;. Hence, we can just
 696     // return the value in the style.
 697     //
 698     // See http://www.w3.org/TR/CSS21/cascade.html#computed-value
 699     switch (propertyID) {
 700     case CSSPropertyLeft:
 701         return style.left();
 702     case CSSPropertyRight:
 703         return style.right();
 704     case CSSPropertyTop:
 705         return style.top();
 706     case CSSPropertyBottom:
 707         return style.bottom();
 708     default:
 709         ASSERT_NOT_REACHED();
 710     }
 711 
 712     return { };
 713 }
 714 
 715 static LayoutUnit getOffsetUsedStyleRelative(RenderBox&amp; box, CSSPropertyID propertyID)
 716 {
 717     // For relatively positioned boxes, the offset is with respect to the top edges
 718     // of the box itself. This ties together top/bottom and left/right to be
 719     // opposites of each other.
 720     //
 721     // See http://www.w3.org/TR/CSS2/visuren.html#relative-positioning
 722     //
 723     // Specifically;
 724     //   Since boxes are not split or stretched as a result of &#39;left&#39; or
 725     //   &#39;right&#39;, the used values are always: left = -right.
 726     // and
 727     //   Since boxes are not split or stretched as a result of &#39;top&#39; or
 728     //   &#39;bottom&#39;, the used values are always: top = -bottom.
 729     switch (propertyID) {
 730     case CSSPropertyTop:
 731         return box.relativePositionOffset().height();
 732     case CSSPropertyBottom:
 733         return -(box.relativePositionOffset().height());
 734     case CSSPropertyLeft:
 735         return box.relativePositionOffset().width();
 736     case CSSPropertyRight:
 737         return -(box.relativePositionOffset().width());
 738     default:
 739         ASSERT_NOT_REACHED();
 740     }
 741 
 742     return 0;
 743 }
 744 
 745 static LayoutUnit getOffsetUsedStyleOutOfFlowPositioned(RenderBlock&amp; container, RenderBox&amp; box, CSSPropertyID propertyID)
 746 {
 747     // For out-of-flow positioned boxes, the offset is how far an box&#39;s margin
 748     // edge is offset below the edge of the box&#39;s containing block.
 749     // See http://www.w3.org/TR/CSS2/visuren.html#position-props
 750 
 751     // Margins are included in offsetTop/offsetLeft so we need to remove them here.
 752     switch (propertyID) {
 753     case CSSPropertyTop:
 754         return box.offsetTop() - box.marginTop();
 755     case CSSPropertyBottom:
 756         return container.clientHeight() - (box.offsetTop() + box.offsetHeight()) - box.marginBottom();
 757     case CSSPropertyLeft:
 758         return box.offsetLeft() - box.marginLeft();
 759     case CSSPropertyRight:
 760         return container.clientWidth() - (box.offsetLeft() + box.offsetWidth()) - box.marginRight();
 761     default:
 762         ASSERT_NOT_REACHED();
 763     }
 764 
 765     return 0;
 766 }
 767 
 768 static RefPtr&lt;CSSValue&gt; positionOffsetValue(const RenderStyle&amp; style, CSSPropertyID propertyID, RenderObject* renderer)
 769 {
 770     auto offset = getOffsetComputedLength(style, propertyID);
 771 
 772     // If the element is not displayed; return the &quot;computed value&quot;.
 773     if (!renderer || !renderer-&gt;isBox())
 774         return zoomAdjustedPixelValueForLength(offset, style);
 775 
 776     auto&amp; box = downcast&lt;RenderBox&gt;(*renderer);
 777     auto* containingBlock = box.containingBlock();
 778 
 779     // Resolve a &quot;computed value&quot; percentage if the element is positioned.
 780     // TODO: percentages for sticky positioning should be handled here (bug 189549).
 781     if (containingBlock &amp;&amp; offset.isPercentOrCalculated() &amp;&amp; box.isPositioned() &amp;&amp; !box.isStickilyPositioned()) {
 782         bool isVerticalProperty;
 783         if (propertyID == CSSPropertyTop || propertyID == CSSPropertyBottom)
 784             isVerticalProperty = true;
 785         else {
 786             ASSERT(propertyID == CSSPropertyLeft || propertyID == CSSPropertyRight);
 787             isVerticalProperty = false;
 788         }
 789         LayoutUnit containingBlockSize;
 790         if (isVerticalProperty == containingBlock-&gt;isHorizontalWritingMode()) {
 791             containingBlockSize = box.isOutOfFlowPositioned()
 792                 ? box.containingBlockLogicalHeightForPositioned(*containingBlock, false)
 793                 : box.containingBlockLogicalHeightForContent(ExcludeMarginBorderPadding);
 794         } else {
 795             containingBlockSize = box.isOutOfFlowPositioned()
 796                 ? box.containingBlockLogicalWidthForPositioned(*containingBlock, nullptr, false)
 797                 : box.containingBlockLogicalWidthForContent();
 798         }
 799         return zoomAdjustedPixelValue(floatValueForLength(offset, containingBlockSize), style);
 800     }
 801 
 802     // Return a &quot;computed value&quot; length.
 803     if (!offset.isAuto())
 804         return zoomAdjustedPixelValueForLength(offset, style);
 805 
 806     // The property won&#39;t be overconstrained if its computed value is &quot;auto&quot;, so the &quot;used value&quot; can be returned.
 807     if (box.isRelativelyPositioned())
 808         return zoomAdjustedPixelValue(getOffsetUsedStyleRelative(box, propertyID), style);
 809 
 810     if (containingBlock &amp;&amp; box.isOutOfFlowPositioned())
 811         return zoomAdjustedPixelValue(getOffsetUsedStyleOutOfFlowPositioned(*containingBlock, box, propertyID), style);
 812 
 813     return CSSValuePool::singleton().createIdentifierValue(CSSValueAuto);
 814 }
 815 
 816 Ref&lt;CSSPrimitiveValue&gt; ComputedStyleExtractor::currentColorOrValidColor(const RenderStyle* style, const Color&amp; color) const
 817 {
 818     // This function does NOT look at visited information, so that computed style doesn&#39;t expose that.
 819     if (!color.isValid())
 820         return CSSValuePool::singleton().createColorValue(style-&gt;color());
 821     return CSSValuePool::singleton().createColorValue(color);
 822 }
 823 
 824 static Ref&lt;CSSPrimitiveValue&gt; percentageOrZoomAdjustedValue(Length length, const RenderStyle&amp; style)
 825 {
 826     if (length.isPercent())
 827         return CSSValuePool::singleton().createValue(length.percent(), CSSPrimitiveValue::CSS_PERCENTAGE);
 828 
 829     return zoomAdjustedPixelValue(valueForLength(length, 0), style);
 830 }
 831 
 832 static Ref&lt;CSSPrimitiveValue&gt; autoOrZoomAdjustedValue(Length length, const RenderStyle&amp; style)
 833 {
 834     if (length.isAuto())
 835         return CSSValuePool::singleton().createIdentifierValue(CSSValueAuto);
 836 
 837     return zoomAdjustedPixelValue(valueForLength(length, 0), style);
 838 }
 839 
 840 static Ref&lt;CSSValueList&gt; borderRadiusCornerValues(const LengthSize&amp; radius, const RenderStyle&amp; style)
 841 {
 842     auto list = CSSValueList::createSpaceSeparated();
 843     list-&gt;append(percentageOrZoomAdjustedValue(radius.width, style));
 844     list-&gt;append(percentageOrZoomAdjustedValue(radius.height, style));
 845     return list;
 846 }
 847 
 848 static Ref&lt;CSSValue&gt; borderRadiusCornerValue(const LengthSize&amp; radius, const RenderStyle&amp; style)
 849 {
 850     if (radius.width == radius.height)
 851         return percentageOrZoomAdjustedValue(radius.width, style);
 852     return borderRadiusCornerValues(radius, style);
 853 }
 854 
 855 static Ref&lt;CSSValueList&gt; borderRadiusShorthandValue(const RenderStyle&amp; style)
 856 {
 857     auto list = CSSValueList::createSlashSeparated();
 858     bool showHorizontalBottomLeft = style.borderTopRightRadius().width != style.borderBottomLeftRadius().width;
 859     bool showHorizontalBottomRight = showHorizontalBottomLeft || (style.borderBottomRightRadius().width != style.borderTopLeftRadius().width);
 860     bool showHorizontalTopRight = showHorizontalBottomRight || (style.borderTopRightRadius().width != style.borderTopLeftRadius().width);
 861 
 862     bool showVerticalBottomLeft = style.borderTopRightRadius().height != style.borderBottomLeftRadius().height;
 863     bool showVerticalBottomRight = showVerticalBottomLeft || (style.borderBottomRightRadius().height != style.borderTopLeftRadius().height);
 864     bool showVerticalTopRight = showVerticalBottomRight || (style.borderTopRightRadius().height != style.borderTopLeftRadius().height);
 865 
 866     auto topLeftRadius = borderRadiusCornerValues(style.borderTopLeftRadius(), style);
 867     auto topRightRadius = borderRadiusCornerValues(style.borderTopRightRadius(), style);
 868     auto bottomRightRadius = borderRadiusCornerValues(style.borderBottomRightRadius(), style);
 869     auto bottomLeftRadius = borderRadiusCornerValues(style.borderBottomLeftRadius(), style);
 870 
 871     auto horizontalRadii = CSSValueList::createSpaceSeparated();
 872     horizontalRadii-&gt;append(*topLeftRadius-&gt;item(0));
 873     if (showHorizontalTopRight)
 874         horizontalRadii-&gt;append(*topRightRadius-&gt;item(0));
 875     if (showHorizontalBottomRight)
 876         horizontalRadii-&gt;append(*bottomRightRadius-&gt;item(0));
 877     if (showHorizontalBottomLeft)
 878         horizontalRadii-&gt;append(*bottomLeftRadius-&gt;item(0));
 879 
 880     list-&gt;append(WTFMove(horizontalRadii));
 881 
 882     auto verticalRadiiList = CSSValueList::createSpaceSeparated();
 883     verticalRadiiList-&gt;append(*topLeftRadius-&gt;item(1));
 884     if (showVerticalTopRight)
 885         verticalRadiiList-&gt;append(*topRightRadius-&gt;item(1));
 886     if (showVerticalBottomRight)
 887         verticalRadiiList-&gt;append(*bottomRightRadius-&gt;item(1));
 888     if (showVerticalBottomLeft)
 889         verticalRadiiList-&gt;append(*bottomLeftRadius-&gt;item(1));
 890 
 891     if (!verticalRadiiList-&gt;equals(downcast&lt;CSSValueList&gt;(*list-&gt;item(0))))
 892         list-&gt;append(WTFMove(verticalRadiiList));
 893 
 894     return list;
 895 }
 896 
 897 static LayoutRect sizingBox(RenderObject&amp; renderer)
 898 {
 899     if (!is&lt;RenderBox&gt;(renderer))
 900         return LayoutRect();
 901 
 902     auto&amp; box = downcast&lt;RenderBox&gt;(renderer);
 903     return box.style().boxSizing() == BoxSizing::BorderBox ? box.borderBoxRect() : box.computedCSSContentBoxRect();
 904 }
 905 
 906 static Ref&lt;CSSFunctionValue&gt; matrixTransformValue(const TransformationMatrix&amp; transform, const RenderStyle&amp; style)
 907 {
 908     RefPtr&lt;CSSFunctionValue&gt; transformValue;
 909     auto&amp; cssValuePool = CSSValuePool::singleton();
 910     if (transform.isAffine()) {
 911         transformValue = CSSFunctionValue::create(CSSValueMatrix);
 912 
 913         transformValue-&gt;append(cssValuePool.createValue(transform.a(), CSSPrimitiveValue::CSS_NUMBER));
 914         transformValue-&gt;append(cssValuePool.createValue(transform.b(), CSSPrimitiveValue::CSS_NUMBER));
 915         transformValue-&gt;append(cssValuePool.createValue(transform.c(), CSSPrimitiveValue::CSS_NUMBER));
 916         transformValue-&gt;append(cssValuePool.createValue(transform.d(), CSSPrimitiveValue::CSS_NUMBER));
 917         transformValue-&gt;append(zoomAdjustedNumberValue(transform.e(), style));
 918         transformValue-&gt;append(zoomAdjustedNumberValue(transform.f(), style));
 919     } else {
 920         transformValue = CSSFunctionValue::create(CSSValueMatrix3d);
 921 
 922         transformValue-&gt;append(cssValuePool.createValue(transform.m11(), CSSPrimitiveValue::CSS_NUMBER));
 923         transformValue-&gt;append(cssValuePool.createValue(transform.m12(), CSSPrimitiveValue::CSS_NUMBER));
 924         transformValue-&gt;append(cssValuePool.createValue(transform.m13(), CSSPrimitiveValue::CSS_NUMBER));
 925         transformValue-&gt;append(cssValuePool.createValue(transform.m14(), CSSPrimitiveValue::CSS_NUMBER));
 926 
 927         transformValue-&gt;append(cssValuePool.createValue(transform.m21(), CSSPrimitiveValue::CSS_NUMBER));
 928         transformValue-&gt;append(cssValuePool.createValue(transform.m22(), CSSPrimitiveValue::CSS_NUMBER));
 929         transformValue-&gt;append(cssValuePool.createValue(transform.m23(), CSSPrimitiveValue::CSS_NUMBER));
 930         transformValue-&gt;append(cssValuePool.createValue(transform.m24(), CSSPrimitiveValue::CSS_NUMBER));
 931 
 932         transformValue-&gt;append(cssValuePool.createValue(transform.m31(), CSSPrimitiveValue::CSS_NUMBER));
 933         transformValue-&gt;append(cssValuePool.createValue(transform.m32(), CSSPrimitiveValue::CSS_NUMBER));
 934         transformValue-&gt;append(cssValuePool.createValue(transform.m33(), CSSPrimitiveValue::CSS_NUMBER));
 935         transformValue-&gt;append(cssValuePool.createValue(transform.m34(), CSSPrimitiveValue::CSS_NUMBER));
 936 
 937         transformValue-&gt;append(zoomAdjustedNumberValue(transform.m41(), style));
 938         transformValue-&gt;append(zoomAdjustedNumberValue(transform.m42(), style));
 939         transformValue-&gt;append(zoomAdjustedNumberValue(transform.m43(), style));
 940         transformValue-&gt;append(cssValuePool.createValue(transform.m44(), CSSPrimitiveValue::CSS_NUMBER));
 941     }
 942 
 943     return transformValue.releaseNonNull();
 944 }
 945 
 946 static Ref&lt;CSSValue&gt; computedTransform(RenderObject* renderer, const RenderStyle&amp; style)
 947 {
 948     // Inline renderers do not support transforms.
 949     if (!renderer || is&lt;RenderInline&gt;(*renderer) || !style.hasTransform())
 950         return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
 951 
 952     FloatRect pixelSnappedRect;
 953     if (is&lt;RenderBox&gt;(*renderer))
 954         pixelSnappedRect = snapRectToDevicePixels(downcast&lt;RenderBox&gt;(*renderer).borderBoxRect(), renderer-&gt;document().deviceScaleFactor());
 955 
 956     TransformationMatrix transform;
 957     style.applyTransform(transform, pixelSnappedRect, RenderStyle::ExcludeTransformOrigin);
 958     // Note that this does not flatten to an affine transform if ENABLE(3D_TRANSFORMS) is off, by design.
 959 
 960     // FIXME: Need to print out individual functions (https://bugs.webkit.org/show_bug.cgi?id=23924)
 961     auto list = CSSValueList::createSpaceSeparated();
 962     list-&gt;append(matrixTransformValue(transform, style));
 963     return WTFMove(list);
 964 }
 965 
 966 static inline Ref&lt;CSSPrimitiveValue&gt; adjustLengthForZoom(double length, const RenderStyle&amp; style, AdjustPixelValuesForComputedStyle adjust)
 967 {
 968     return adjust == AdjustPixelValues ? zoomAdjustedPixelValue(length, style) : CSSValuePool::singleton().createValue(length, CSSPrimitiveValue::CSS_PX);
 969 }
 970 
 971 static inline Ref&lt;CSSPrimitiveValue&gt; adjustLengthForZoom(const Length&amp; length, const RenderStyle&amp; style, AdjustPixelValuesForComputedStyle adjust)
 972 {
 973     return adjust == AdjustPixelValues ? zoomAdjustedPixelValue(length.value(), style) : CSSValuePool::singleton().createValue(length);
 974 }
 975 
 976 Ref&lt;CSSValue&gt; ComputedStyleExtractor::valueForShadow(const ShadowData* shadow, CSSPropertyID propertyID, const RenderStyle&amp; style, AdjustPixelValuesForComputedStyle adjust)
 977 {
 978     auto&amp; cssValuePool = CSSValuePool::singleton();
 979     if (!shadow)
 980         return cssValuePool.createIdentifierValue(CSSValueNone);
 981 
 982     auto list = CSSValueList::createCommaSeparated();
 983     for (const ShadowData* currShadowData = shadow; currShadowData; currShadowData = currShadowData-&gt;next()) {
 984         auto x = adjustLengthForZoom(currShadowData-&gt;x(), style, adjust);
 985         auto y = adjustLengthForZoom(currShadowData-&gt;y(), style, adjust);
 986         auto blur = adjustLengthForZoom(currShadowData-&gt;radius(), style, adjust);
 987         auto spread = propertyID == CSSPropertyTextShadow ? RefPtr&lt;CSSPrimitiveValue&gt;() : adjustLengthForZoom(currShadowData-&gt;spread(), style, adjust);
 988         auto style = propertyID == CSSPropertyTextShadow || currShadowData-&gt;style() == Normal ? RefPtr&lt;CSSPrimitiveValue&gt;() : cssValuePool.createIdentifierValue(CSSValueInset);
 989         auto color = cssValuePool.createColorValue(currShadowData-&gt;color());
 990         list-&gt;prepend(CSSShadowValue::create(WTFMove(x), WTFMove(y), WTFMove(blur), WTFMove(spread), WTFMove(style), WTFMove(color)));
 991     }
 992     return WTFMove(list);
 993 }
 994 
 995 Ref&lt;CSSValue&gt; ComputedStyleExtractor::valueForFilter(const RenderStyle&amp; style, const FilterOperations&amp; filterOperations, AdjustPixelValuesForComputedStyle adjust)
 996 {
 997     auto&amp; cssValuePool = CSSValuePool::singleton();
 998     if (filterOperations.operations().isEmpty())
 999         return cssValuePool.createIdentifierValue(CSSValueNone);
1000 
1001     auto list = CSSValueList::createSpaceSeparated();
1002 
1003     Vector&lt;RefPtr&lt;FilterOperation&gt;&gt;::const_iterator end = filterOperations.operations().end();
1004     for (Vector&lt;RefPtr&lt;FilterOperation&gt;&gt;::const_iterator it = filterOperations.operations().begin(); it != end; ++it) {
1005         FilterOperation&amp; filterOperation = **it;
1006 
1007         if (filterOperation.type() == FilterOperation::REFERENCE) {
1008             ReferenceFilterOperation&amp; referenceOperation = downcast&lt;ReferenceFilterOperation&gt;(filterOperation);
1009             list-&gt;append(cssValuePool.createValue(referenceOperation.url(), CSSPrimitiveValue::CSS_URI));
1010         } else {
1011             RefPtr&lt;CSSFunctionValue&gt; filterValue;
1012             switch (filterOperation.type()) {
1013             case FilterOperation::GRAYSCALE: {
1014                 filterValue = CSSFunctionValue::create(CSSValueGrayscale);
1015                 filterValue-&gt;append(cssValuePool.createValue(downcast&lt;BasicColorMatrixFilterOperation&gt;(filterOperation).amount(), CSSPrimitiveValue::CSS_NUMBER));
1016                 break;
1017             }
1018             case FilterOperation::SEPIA: {
1019                 filterValue = CSSFunctionValue::create(CSSValueSepia);
1020                 filterValue-&gt;append(cssValuePool.createValue(downcast&lt;BasicColorMatrixFilterOperation&gt;(filterOperation).amount(), CSSPrimitiveValue::CSS_NUMBER));
1021                 break;
1022             }
1023             case FilterOperation::SATURATE: {
1024                 filterValue = CSSFunctionValue::create(CSSValueSaturate);
1025                 filterValue-&gt;append(cssValuePool.createValue(downcast&lt;BasicColorMatrixFilterOperation&gt;(filterOperation).amount(), CSSPrimitiveValue::CSS_NUMBER));
1026                 break;
1027             }
1028             case FilterOperation::HUE_ROTATE: {
1029                 filterValue = CSSFunctionValue::create(CSSValueHueRotate);
1030                 filterValue-&gt;append(cssValuePool.createValue(downcast&lt;BasicColorMatrixFilterOperation&gt;(filterOperation).amount(), CSSPrimitiveValue::CSS_DEG));
1031                 break;
1032             }
1033             case FilterOperation::INVERT: {
1034                 filterValue = CSSFunctionValue::create(CSSValueInvert);
1035                 filterValue-&gt;append(cssValuePool.createValue(downcast&lt;BasicComponentTransferFilterOperation&gt;(filterOperation).amount(), CSSPrimitiveValue::CSS_NUMBER));
1036                 break;
1037             }
1038             case FilterOperation::APPLE_INVERT_LIGHTNESS: {
1039                 filterValue = CSSFunctionValue::create(CSSValueAppleInvertLightness);
1040                 break;
1041             }
1042             case FilterOperation::OPACITY: {
1043                 filterValue = CSSFunctionValue::create(CSSValueOpacity);
1044                 filterValue-&gt;append(cssValuePool.createValue(downcast&lt;BasicComponentTransferFilterOperation&gt;(filterOperation).amount(), CSSPrimitiveValue::CSS_NUMBER));
1045                 break;
1046             }
1047             case FilterOperation::BRIGHTNESS: {
1048                 filterValue = CSSFunctionValue::create(CSSValueBrightness);
1049                 filterValue-&gt;append(cssValuePool.createValue(downcast&lt;BasicComponentTransferFilterOperation&gt;(filterOperation).amount(), CSSPrimitiveValue::CSS_NUMBER));
1050                 break;
1051             }
1052             case FilterOperation::CONTRAST: {
1053                 filterValue = CSSFunctionValue::create(CSSValueContrast);
1054                 filterValue-&gt;append(cssValuePool.createValue(downcast&lt;BasicComponentTransferFilterOperation&gt;(filterOperation).amount(), CSSPrimitiveValue::CSS_NUMBER));
1055                 break;
1056             }
1057             case FilterOperation::BLUR: {
1058                 filterValue = CSSFunctionValue::create(CSSValueBlur);
1059                 filterValue-&gt;append(adjustLengthForZoom(downcast&lt;BlurFilterOperation&gt;(filterOperation).stdDeviation(), style, adjust));
1060                 break;
1061             }
1062             case FilterOperation::DROP_SHADOW: {
1063                 DropShadowFilterOperation&amp; dropShadowOperation = downcast&lt;DropShadowFilterOperation&gt;(filterOperation);
1064                 filterValue = CSSFunctionValue::create(CSSValueDropShadow);
1065                 // We want our computed style to look like that of a text shadow (has neither spread nor inset style).
1066                 ShadowData shadowData = ShadowData(dropShadowOperation.location(), dropShadowOperation.stdDeviation(), 0, Normal, false, dropShadowOperation.color());
1067                 filterValue-&gt;append(valueForShadow(&amp;shadowData, CSSPropertyTextShadow, style, adjust));
1068                 break;
1069             }
1070             default:
1071                 ASSERT_NOT_REACHED();
1072                 filterValue = CSSFunctionValue::create(CSSValueInvalid);
1073                 break;
1074             }
1075             list-&gt;append(filterValue.releaseNonNull());
1076         }
1077     }
1078     return WTFMove(list);
1079 }
1080 
1081 static Ref&lt;CSSValue&gt; specifiedValueForGridTrackBreadth(const GridLength&amp; trackBreadth, const RenderStyle&amp; style)
1082 {
1083     if (!trackBreadth.isLength())
1084         return CSSValuePool::singleton().createValue(trackBreadth.flex(), CSSPrimitiveValue::CSS_FR);
1085 
1086     const Length&amp; trackBreadthLength = trackBreadth.length();
1087     if (trackBreadthLength.isAuto())
1088         return CSSValuePool::singleton().createIdentifierValue(CSSValueAuto);
1089     return zoomAdjustedPixelValueForLength(trackBreadthLength, style);
1090 }
1091 
1092 static Ref&lt;CSSValue&gt; specifiedValueForGridTrackSize(const GridTrackSize&amp; trackSize, const RenderStyle&amp; style)
1093 {
1094     switch (trackSize.type()) {
1095     case LengthTrackSizing:
1096         return specifiedValueForGridTrackBreadth(trackSize.minTrackBreadth(), style);
1097     case FitContentTrackSizing: {
1098         auto fitContentTrackSize = CSSFunctionValue::create(CSSValueFitContent);
1099         fitContentTrackSize-&gt;append(zoomAdjustedPixelValueForLength(trackSize.fitContentTrackBreadth().length(), style));
1100         return WTFMove(fitContentTrackSize);
1101     }
1102     default:
1103         ASSERT(trackSize.type() == MinMaxTrackSizing);
1104         if (trackSize.minTrackBreadth().isAuto() &amp;&amp; trackSize.maxTrackBreadth().isFlex())
1105             return CSSValuePool::singleton().createValue(trackSize.maxTrackBreadth().flex(), CSSPrimitiveValue::CSS_FR);
1106 
1107         auto minMaxTrackBreadths = CSSFunctionValue::create(CSSValueMinmax);
1108         minMaxTrackBreadths-&gt;append(specifiedValueForGridTrackBreadth(trackSize.minTrackBreadth(), style));
1109         minMaxTrackBreadths-&gt;append(specifiedValueForGridTrackBreadth(trackSize.maxTrackBreadth(), style));
1110         return WTFMove(minMaxTrackBreadths);
1111     }
1112 }
1113 
1114 class OrderedNamedLinesCollector {
1115     WTF_MAKE_NONCOPYABLE(OrderedNamedLinesCollector);
1116 public:
1117     OrderedNamedLinesCollector(const RenderStyle&amp; style, bool isRowAxis, unsigned autoRepeatTracksCount)
1118         : m_orderedNamedGridLines(isRowAxis ? style.orderedNamedGridColumnLines() : style.orderedNamedGridRowLines())
1119         , m_orderedNamedAutoRepeatGridLines(isRowAxis ? style.autoRepeatOrderedNamedGridColumnLines() : style.autoRepeatOrderedNamedGridRowLines())
1120         , m_insertionPoint(isRowAxis ? style.gridAutoRepeatColumnsInsertionPoint() : style.gridAutoRepeatRowsInsertionPoint())
1121         , m_autoRepeatTotalTracks(autoRepeatTracksCount)
1122         , m_autoRepeatTrackListLength(isRowAxis ? style.gridAutoRepeatColumns().size() : style.gridAutoRepeatRows().size())
1123     {
1124     }
1125 
1126     bool isEmpty() const { return m_orderedNamedGridLines.isEmpty() &amp;&amp; m_orderedNamedAutoRepeatGridLines.isEmpty(); }
1127     void collectLineNamesForIndex(CSSGridLineNamesValue&amp;, unsigned index) const;
1128 
1129 private:
1130 
1131     enum NamedLinesType { NamedLines, AutoRepeatNamedLines };
1132     void appendLines(CSSGridLineNamesValue&amp;, unsigned index, NamedLinesType) const;
1133 
1134     const OrderedNamedGridLinesMap&amp; m_orderedNamedGridLines;
1135     const OrderedNamedGridLinesMap&amp; m_orderedNamedAutoRepeatGridLines;
1136     unsigned m_insertionPoint;
1137     unsigned m_autoRepeatTotalTracks;
1138     unsigned m_autoRepeatTrackListLength;
1139 };
1140 
1141 void OrderedNamedLinesCollector::appendLines(CSSGridLineNamesValue&amp; lineNamesValue, unsigned index, NamedLinesType type) const
1142 {
1143     auto iter = type == NamedLines ? m_orderedNamedGridLines.find(index) : m_orderedNamedAutoRepeatGridLines.find(index);
1144     auto endIter = type == NamedLines ? m_orderedNamedGridLines.end() : m_orderedNamedAutoRepeatGridLines.end();
1145     if (iter == endIter)
1146         return;
1147 
1148     auto&amp; cssValuePool = CSSValuePool::singleton();
1149     for (const auto&amp; lineName : iter-&gt;value)
1150         lineNamesValue.append(cssValuePool.createValue(lineName, CSSPrimitiveValue::CSS_STRING));
1151 }
1152 
1153 void OrderedNamedLinesCollector::collectLineNamesForIndex(CSSGridLineNamesValue&amp; lineNamesValue, unsigned i) const
1154 {
1155     ASSERT(!isEmpty());
1156     if (m_orderedNamedAutoRepeatGridLines.isEmpty() || i &lt; m_insertionPoint) {
1157         appendLines(lineNamesValue, i, NamedLines);
1158         return;
1159     }
1160 
1161     ASSERT(m_autoRepeatTotalTracks);
1162 
1163     if (i &gt; m_insertionPoint + m_autoRepeatTotalTracks) {
1164         appendLines(lineNamesValue, i - (m_autoRepeatTotalTracks - 1), NamedLines);
1165         return;
1166     }
1167 
1168     if (i == m_insertionPoint) {
1169         appendLines(lineNamesValue, i, NamedLines);
1170         appendLines(lineNamesValue, 0, AutoRepeatNamedLines);
1171         return;
1172     }
1173 
1174     if (i == m_insertionPoint + m_autoRepeatTotalTracks) {
1175         appendLines(lineNamesValue, m_autoRepeatTrackListLength, AutoRepeatNamedLines);
1176         appendLines(lineNamesValue, m_insertionPoint + 1, NamedLines);
1177         return;
1178     }
1179 
1180     unsigned autoRepeatIndexInFirstRepetition = (i - m_insertionPoint) % m_autoRepeatTrackListLength;
1181     if (!autoRepeatIndexInFirstRepetition &amp;&amp; i &gt; m_insertionPoint)
1182         appendLines(lineNamesValue, m_autoRepeatTrackListLength, AutoRepeatNamedLines);
1183     appendLines(lineNamesValue, autoRepeatIndexInFirstRepetition, AutoRepeatNamedLines);
1184 }
1185 
1186 static void addValuesForNamedGridLinesAtIndex(OrderedNamedLinesCollector&amp; collector, unsigned i, CSSValueList&amp; list)
1187 {
1188     if (collector.isEmpty())
1189         return;
1190 
1191     auto lineNames = CSSGridLineNamesValue::create();
1192     collector.collectLineNamesForIndex(lineNames.get(), i);
1193     if (lineNames-&gt;length())
1194         list.append(WTFMove(lineNames));
1195 }
1196 
1197 static Ref&lt;CSSValueList&gt; valueForGridTrackSizeList(GridTrackSizingDirection direction, const RenderStyle&amp; style)
1198 {
1199     auto&amp; autoTrackSizes = direction == ForColumns ? style.gridAutoColumns() : style.gridAutoRows();
1200 
1201     auto list = CSSValueList::createSpaceSeparated();
1202     for (auto&amp; trackSize : autoTrackSizes)
1203         list-&gt;append(specifiedValueForGridTrackSize(trackSize, style));
1204     return list;
1205 }
1206 
1207 static Ref&lt;CSSValue&gt; valueForGridTrackList(GridTrackSizingDirection direction, RenderObject* renderer, const RenderStyle&amp; style)
1208 {
1209     bool isRowAxis = direction == ForColumns;
1210     bool isRenderGrid = is&lt;RenderGrid&gt;(renderer);
1211     auto&amp; trackSizes = isRowAxis ? style.gridColumns() : style.gridRows();
1212     auto&amp; autoRepeatTrackSizes = isRowAxis ? style.gridAutoRepeatColumns() : style.gridAutoRepeatRows();
1213 
1214     // Handle the &#39;none&#39; case.
1215     bool trackListIsEmpty = trackSizes.isEmpty() &amp;&amp; autoRepeatTrackSizes.isEmpty();
1216     if (isRenderGrid &amp;&amp; trackListIsEmpty) {
1217         // For grids we should consider every listed track, whether implicitly or explicitly
1218         // created. Empty grids have a sole grid line per axis.
1219         auto&amp; grid = downcast&lt;RenderGrid&gt;(*renderer);
1220         auto&amp; positions = isRowAxis ? grid.columnPositions() : grid.rowPositions();
1221         trackListIsEmpty = positions.size() == 1;
1222     }
1223 
1224     if (trackListIsEmpty)
1225         return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
1226 
1227     unsigned autoRepeatTotalTracks = isRenderGrid ? downcast&lt;RenderGrid&gt;(renderer)-&gt;autoRepeatCountForDirection(direction) : 0;
1228     OrderedNamedLinesCollector collector(style, isRowAxis, autoRepeatTotalTracks);
1229     auto list = CSSValueList::createSpaceSeparated();
1230     unsigned insertionIndex;
1231     if (isRenderGrid) {
1232         auto computedTrackSizes = downcast&lt;RenderGrid&gt;(*renderer).trackSizesForComputedStyle(direction);
1233         unsigned numTracks = computedTrackSizes.size();
1234 
1235         for (unsigned i = 0; i &lt; numTracks; ++i) {
1236             addValuesForNamedGridLinesAtIndex(collector, i, list.get());
1237             list-&gt;append(zoomAdjustedPixelValue(computedTrackSizes[i], style));
1238         }
1239         addValuesForNamedGridLinesAtIndex(collector, numTracks + 1, list.get());
1240         insertionIndex = numTracks;
1241     } else {
1242         for (unsigned i = 0; i &lt; trackSizes.size(); ++i) {
1243             addValuesForNamedGridLinesAtIndex(collector, i, list.get());
1244             list-&gt;append(specifiedValueForGridTrackSize(trackSizes[i], style));
1245         }
1246         insertionIndex = trackSizes.size();
1247     }
1248 
1249     // Those are the trailing &lt;ident&gt;* allowed in the syntax.
1250     addValuesForNamedGridLinesAtIndex(collector, insertionIndex, list.get());
1251     return WTFMove(list);
1252 }
1253 
1254 static Ref&lt;CSSValue&gt; valueForGridPosition(const GridPosition&amp; position)
1255 {
1256     auto&amp; cssValuePool = CSSValuePool::singleton();
1257     if (position.isAuto())
1258         return cssValuePool.createIdentifierValue(CSSValueAuto);
1259 
1260     if (position.isNamedGridArea())
1261         return cssValuePool.createValue(position.namedGridLine(), CSSPrimitiveValue::CSS_STRING);
1262 
1263     auto list = CSSValueList::createSpaceSeparated();
1264     if (position.isSpan()) {
1265         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueSpan));
1266         list-&gt;append(cssValuePool.createValue(position.spanPosition(), CSSPrimitiveValue::CSS_NUMBER));
1267     } else
1268         list-&gt;append(cssValuePool.createValue(position.integerPosition(), CSSPrimitiveValue::CSS_NUMBER));
1269 
1270     if (!position.namedGridLine().isNull())
1271         list-&gt;append(cssValuePool.createValue(position.namedGridLine(), CSSPrimitiveValue::CSS_STRING));
1272     return WTFMove(list);
1273 }
1274 
1275 static Ref&lt;CSSValue&gt; createTransitionPropertyValue(const Animation&amp; animation)
1276 {
1277     switch (animation.animationMode()) {
1278     case Animation::AnimateNone:
1279         return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
1280     case Animation::AnimateAll:
1281         return CSSValuePool::singleton().createIdentifierValue(CSSValueAll);
1282     case Animation::AnimateSingleProperty:
1283         return CSSValuePool::singleton().createValue(getPropertyNameString(animation.property()), CSSPrimitiveValue::CSS_STRING);
1284     case Animation::AnimateUnknownProperty:
1285         return CSSValuePool::singleton().createValue(animation.unknownProperty(), CSSPrimitiveValue::CSS_STRING);
1286     }
1287     ASSERT_NOT_REACHED();
1288     return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
1289 }
1290 
1291 static Ref&lt;CSSValueList&gt; transitionPropertyValue(const AnimationList* animationList)
1292 {
1293     auto list = CSSValueList::createCommaSeparated();
1294     if (animationList) {
1295         for (size_t i = 0; i &lt; animationList-&gt;size(); ++i)
1296             list-&gt;append(createTransitionPropertyValue(animationList-&gt;animation(i)));
1297     } else
1298         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueAll));
1299     return list;
1300 }
1301 
1302 #if ENABLE(CSS_SCROLL_SNAP)
1303 
1304 static Ref&lt;CSSValueList&gt; valueForScrollSnapType(const ScrollSnapType&amp; type)
1305 {
1306     auto value = CSSValueList::createSpaceSeparated();
1307     if (type.strictness == ScrollSnapStrictness::None)
1308         value-&gt;append(CSSValuePool::singleton().createValue(CSSValueNone));
1309     else {
1310         value-&gt;append(CSSPrimitiveValue::create(type.axis));
1311         value-&gt;append(CSSPrimitiveValue::create(type.strictness));
1312     }
1313     return value;
1314 }
1315 
1316 static Ref&lt;CSSValueList&gt; valueForScrollSnapAlignment(const ScrollSnapAlign&amp; alignment)
1317 {
1318     auto value = CSSValueList::createSpaceSeparated();
1319     value-&gt;append(CSSPrimitiveValue::create(alignment.x));
1320     value-&gt;append(CSSPrimitiveValue::create(alignment.y));
1321     return value;
1322 }
1323 
1324 #endif
1325 
1326 static Ref&lt;CSSValue&gt; willChangePropertyValue(const WillChangeData* willChangeData)
1327 {
1328     auto&amp; cssValuePool = CSSValuePool::singleton();
1329     if (!willChangeData || !willChangeData-&gt;numFeatures())
1330         return cssValuePool.createIdentifierValue(CSSValueAuto);
1331 
1332     auto list = CSSValueList::createCommaSeparated();
1333     for (size_t i = 0; i &lt; willChangeData-&gt;numFeatures(); ++i) {
1334         WillChangeData::FeaturePropertyPair feature = willChangeData-&gt;featureAt(i);
1335         switch (feature.first) {
1336         case WillChangeData::ScrollPosition:
1337             list-&gt;append(cssValuePool.createIdentifierValue(CSSValueScrollPosition));
1338             break;
1339         case WillChangeData::Contents:
1340             list-&gt;append(cssValuePool.createIdentifierValue(CSSValueContents));
1341             break;
1342         case WillChangeData::Property:
1343             list-&gt;append(cssValuePool.createIdentifierValue(feature.second));
1344             break;
1345         case WillChangeData::Invalid:
1346             ASSERT_NOT_REACHED();
1347             break;
1348         }
1349     }
1350 
1351     return WTFMove(list);
1352 }
1353 
1354 static inline void appendLigaturesValue(CSSValueList&amp; list, FontVariantLigatures value, CSSValueID yesValue, CSSValueID noValue)
1355 {
1356     switch (value) {
1357     case FontVariantLigatures::Normal:
1358         return;
1359     case FontVariantLigatures::No:
1360         list.append(CSSValuePool::singleton().createIdentifierValue(noValue));
1361         return;
1362     case FontVariantLigatures::Yes:
1363         list.append(CSSValuePool::singleton().createIdentifierValue(yesValue));
1364         return;
1365     }
1366     ASSERT_NOT_REACHED();
1367 }
1368 
1369 static Ref&lt;CSSValue&gt; fontVariantLigaturesPropertyValue(FontVariantLigatures common, FontVariantLigatures discretionary, FontVariantLigatures historical, FontVariantLigatures contextualAlternates)
1370 {
1371     auto&amp; cssValuePool = CSSValuePool::singleton();
1372     if (common == FontVariantLigatures::No &amp;&amp; discretionary == FontVariantLigatures::No &amp;&amp; historical == FontVariantLigatures::No &amp;&amp; contextualAlternates == FontVariantLigatures::No)
1373         return cssValuePool.createIdentifierValue(CSSValueNone);
1374     if (common == FontVariantLigatures::Normal &amp;&amp; discretionary == FontVariantLigatures::Normal &amp;&amp; historical == FontVariantLigatures::Normal &amp;&amp; contextualAlternates == FontVariantLigatures::Normal)
1375         return cssValuePool.createIdentifierValue(CSSValueNormal);
1376 
1377     auto valueList = CSSValueList::createSpaceSeparated();
1378     appendLigaturesValue(valueList, common, CSSValueCommonLigatures, CSSValueNoCommonLigatures);
1379     appendLigaturesValue(valueList, discretionary, CSSValueDiscretionaryLigatures, CSSValueNoDiscretionaryLigatures);
1380     appendLigaturesValue(valueList, historical, CSSValueHistoricalLigatures, CSSValueNoHistoricalLigatures);
1381     appendLigaturesValue(valueList, contextualAlternates, CSSValueContextual, CSSValueNoContextual);
1382     return WTFMove(valueList);
1383 }
1384 
1385 static Ref&lt;CSSValue&gt; fontVariantPositionPropertyValue(FontVariantPosition position)
1386 {
1387     auto&amp; cssValuePool = CSSValuePool::singleton();
1388     CSSValueID valueID = CSSValueNormal;
1389     switch (position) {
1390     case FontVariantPosition::Normal:
1391         break;
1392     case FontVariantPosition::Subscript:
1393         valueID = CSSValueSub;
1394         break;
1395     case FontVariantPosition::Superscript:
1396         valueID = CSSValueSuper;
1397         break;
1398     }
1399     return cssValuePool.createIdentifierValue(valueID);
1400 }
1401 
1402 static Ref&lt;CSSValue&gt; fontVariantCapsPropertyValue(FontVariantCaps caps)
1403 {
1404     auto&amp; cssValuePool = CSSValuePool::singleton();
1405     CSSValueID valueID = CSSValueNormal;
1406     switch (caps) {
1407     case FontVariantCaps::Normal:
1408         break;
1409     case FontVariantCaps::Small:
1410         valueID = CSSValueSmallCaps;
1411         break;
1412     case FontVariantCaps::AllSmall:
1413         valueID = CSSValueAllSmallCaps;
1414         break;
1415     case FontVariantCaps::Petite:
1416         valueID = CSSValuePetiteCaps;
1417         break;
1418     case FontVariantCaps::AllPetite:
1419         valueID = CSSValueAllPetiteCaps;
1420         break;
1421     case FontVariantCaps::Unicase:
1422         valueID = CSSValueUnicase;
1423         break;
1424     case FontVariantCaps::Titling:
1425         valueID = CSSValueTitlingCaps;
1426         break;
1427     }
1428     return cssValuePool.createIdentifierValue(valueID);
1429 }
1430 
1431 static Ref&lt;CSSValue&gt; fontVariantNumericPropertyValue(FontVariantNumericFigure figure, FontVariantNumericSpacing spacing, FontVariantNumericFraction fraction, FontVariantNumericOrdinal ordinal, FontVariantNumericSlashedZero slashedZero)
1432 {
1433     auto&amp; cssValuePool = CSSValuePool::singleton();
1434     if (figure == FontVariantNumericFigure::Normal &amp;&amp; spacing == FontVariantNumericSpacing::Normal &amp;&amp; fraction == FontVariantNumericFraction::Normal &amp;&amp; ordinal == FontVariantNumericOrdinal::Normal &amp;&amp; slashedZero == FontVariantNumericSlashedZero::Normal)
1435         return cssValuePool.createIdentifierValue(CSSValueNormal);
1436 
1437     auto valueList = CSSValueList::createSpaceSeparated();
1438     switch (figure) {
1439     case FontVariantNumericFigure::Normal:
1440         break;
1441     case FontVariantNumericFigure::LiningNumbers:
1442         valueList-&gt;append(cssValuePool.createIdentifierValue(CSSValueLiningNums));
1443         break;
1444     case FontVariantNumericFigure::OldStyleNumbers:
1445         valueList-&gt;append(cssValuePool.createIdentifierValue(CSSValueOldstyleNums));
1446         break;
1447     }
1448 
1449     switch (spacing) {
1450     case FontVariantNumericSpacing::Normal:
1451         break;
1452     case FontVariantNumericSpacing::ProportionalNumbers:
1453         valueList-&gt;append(cssValuePool.createIdentifierValue(CSSValueProportionalNums));
1454         break;
1455     case FontVariantNumericSpacing::TabularNumbers:
1456         valueList-&gt;append(cssValuePool.createIdentifierValue(CSSValueTabularNums));
1457         break;
1458     }
1459 
1460     switch (fraction) {
1461     case FontVariantNumericFraction::Normal:
1462         break;
1463     case FontVariantNumericFraction::DiagonalFractions:
1464         valueList-&gt;append(cssValuePool.createIdentifierValue(CSSValueDiagonalFractions));
1465         break;
1466     case FontVariantNumericFraction::StackedFractions:
1467         valueList-&gt;append(cssValuePool.createIdentifierValue(CSSValueStackedFractions));
1468         break;
1469     }
1470 
1471     if (ordinal == FontVariantNumericOrdinal::Yes)
1472         valueList-&gt;append(cssValuePool.createIdentifierValue(CSSValueOrdinal));
1473     if (slashedZero == FontVariantNumericSlashedZero::Yes)
1474         valueList-&gt;append(cssValuePool.createIdentifierValue(CSSValueSlashedZero));
1475 
1476     return WTFMove(valueList);
1477 }
1478 
1479 static Ref&lt;CSSValue&gt; fontVariantAlternatesPropertyValue(FontVariantAlternates alternates)
1480 {
1481     auto&amp; cssValuePool = CSSValuePool::singleton();
1482     CSSValueID valueID = CSSValueNormal;
1483     switch (alternates) {
1484     case FontVariantAlternates::Normal:
1485         break;
1486     case FontVariantAlternates::HistoricalForms:
1487         valueID = CSSValueHistoricalForms;
1488         break;
1489     }
1490     return cssValuePool.createIdentifierValue(valueID);
1491 }
1492 
1493 static Ref&lt;CSSValue&gt; fontVariantEastAsianPropertyValue(FontVariantEastAsianVariant variant, FontVariantEastAsianWidth width, FontVariantEastAsianRuby ruby)
1494 {
1495     auto&amp; cssValuePool = CSSValuePool::singleton();
1496     if (variant == FontVariantEastAsianVariant::Normal &amp;&amp; width == FontVariantEastAsianWidth::Normal &amp;&amp; ruby == FontVariantEastAsianRuby::Normal)
1497         return cssValuePool.createIdentifierValue(CSSValueNormal);
1498 
1499     auto valueList = CSSValueList::createSpaceSeparated();
1500     switch (variant) {
1501     case FontVariantEastAsianVariant::Normal:
1502         break;
1503     case FontVariantEastAsianVariant::Jis78:
1504         valueList-&gt;append(cssValuePool.createIdentifierValue(CSSValueJis78));
1505         break;
1506     case FontVariantEastAsianVariant::Jis83:
1507         valueList-&gt;append(cssValuePool.createIdentifierValue(CSSValueJis83));
1508         break;
1509     case FontVariantEastAsianVariant::Jis90:
1510         valueList-&gt;append(cssValuePool.createIdentifierValue(CSSValueJis90));
1511         break;
1512     case FontVariantEastAsianVariant::Jis04:
1513         valueList-&gt;append(cssValuePool.createIdentifierValue(CSSValueJis04));
1514         break;
1515     case FontVariantEastAsianVariant::Simplified:
1516         valueList-&gt;append(cssValuePool.createIdentifierValue(CSSValueSimplified));
1517         break;
1518     case FontVariantEastAsianVariant::Traditional:
1519         valueList-&gt;append(cssValuePool.createIdentifierValue(CSSValueTraditional));
1520         break;
1521     }
1522 
1523     switch (width) {
1524     case FontVariantEastAsianWidth::Normal:
1525         break;
1526     case FontVariantEastAsianWidth::Full:
1527         valueList-&gt;append(cssValuePool.createIdentifierValue(CSSValueFullWidth));
1528         break;
1529     case FontVariantEastAsianWidth::Proportional:
1530         valueList-&gt;append(cssValuePool.createIdentifierValue(CSSValueProportionalWidth));
1531         break;
1532     }
1533 
1534     if (ruby == FontVariantEastAsianRuby::Yes)
1535         valueList-&gt;append(cssValuePool.createIdentifierValue(CSSValueRuby));
1536 
1537     return WTFMove(valueList);
1538 }
1539 
1540 static Ref&lt;CSSValueList&gt; delayValue(const AnimationList* animationList)
1541 {
1542     auto&amp; cssValuePool = CSSValuePool::singleton();
1543     auto list = CSSValueList::createCommaSeparated();
1544     if (animationList) {
1545         for (size_t i = 0; i &lt; animationList-&gt;size(); ++i)
1546             list-&gt;append(cssValuePool.createValue(animationList-&gt;animation(i).delay(), CSSPrimitiveValue::CSS_S));
1547     } else {
1548         // Note that initialAnimationDelay() is used for both transitions and animations
1549         list-&gt;append(cssValuePool.createValue(Animation::initialDelay(), CSSPrimitiveValue::CSS_S));
1550     }
1551     return list;
1552 }
1553 
1554 static Ref&lt;CSSValueList&gt; durationValue(const AnimationList* animationList)
1555 {
1556     auto&amp; cssValuePool = CSSValuePool::singleton();
1557     auto list = CSSValueList::createCommaSeparated();
1558     if (animationList) {
1559         for (size_t i = 0; i &lt; animationList-&gt;size(); ++i)
1560             list-&gt;append(cssValuePool.createValue(animationList-&gt;animation(i).duration(), CSSPrimitiveValue::CSS_S));
1561     } else {
1562         // Note that initialAnimationDuration() is used for both transitions and animations
1563         list-&gt;append(cssValuePool.createValue(Animation::initialDuration(), CSSPrimitiveValue::CSS_S));
1564     }
1565     return list;
1566 }
1567 
1568 static Ref&lt;CSSValue&gt; createTimingFunctionValue(const TimingFunction&amp; timingFunction)
1569 {
1570     switch (timingFunction.type()) {
1571     case TimingFunction::CubicBezierFunction: {
1572         auto&amp; function = downcast&lt;CubicBezierTimingFunction&gt;(timingFunction);
1573         if (function.timingFunctionPreset() != CubicBezierTimingFunction::Custom) {
1574             CSSValueID valueId = CSSValueInvalid;
1575             switch (function.timingFunctionPreset()) {
1576             case CubicBezierTimingFunction::Ease:
1577                 valueId = CSSValueEase;
1578                 break;
1579             case CubicBezierTimingFunction::EaseIn:
1580                 valueId = CSSValueEaseIn;
1581                 break;
1582             case CubicBezierTimingFunction::EaseOut:
1583                 valueId = CSSValueEaseOut;
1584                 break;
1585             default:
1586                 ASSERT(function.timingFunctionPreset() == CubicBezierTimingFunction::EaseInOut);
1587                 valueId = CSSValueEaseInOut;
1588                 break;
1589             }
1590             return CSSValuePool::singleton().createIdentifierValue(valueId);
1591         }
1592         return CSSCubicBezierTimingFunctionValue::create(function.x1(), function.y1(), function.x2(), function.y2());
1593     }
1594     case TimingFunction::StepsFunction: {
1595         auto&amp; function = downcast&lt;StepsTimingFunction&gt;(timingFunction);
1596         return CSSStepsTimingFunctionValue::create(function.numberOfSteps(), function.stepAtStart());
1597     }
1598     case TimingFunction::SpringFunction: {
1599         auto&amp; function = downcast&lt;SpringTimingFunction&gt;(timingFunction);
1600         return CSSSpringTimingFunctionValue::create(function.mass(), function.stiffness(), function.damping(), function.initialVelocity());
1601     }
1602     default:
1603         ASSERT(timingFunction.type() == TimingFunction::LinearFunction);
1604         return CSSValuePool::singleton().createIdentifierValue(CSSValueLinear);
1605     }
1606 }
1607 
1608 static Ref&lt;CSSValueList&gt; timingFunctionValue(const AnimationList* animationList)
1609 {
1610     auto list = CSSValueList::createCommaSeparated();
1611     if (animationList) {
1612         for (size_t i = 0; i &lt; animationList-&gt;size(); ++i)
1613             list-&gt;append(createTimingFunctionValue(*animationList-&gt;animation(i).timingFunction()));
1614     } else
1615         // Note that initialAnimationTimingFunction() is used for both transitions and animations
1616         list-&gt;append(createTimingFunctionValue(Animation::initialTimingFunction()));
1617     return list;
1618 }
1619 
1620 static Ref&lt;CSSValue&gt; createLineBoxContainValue(unsigned lineBoxContain)
1621 {
1622     if (!lineBoxContain)
1623         return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
1624     return CSSLineBoxContainValue::create(lineBoxContain);
1625 }
1626 
1627 static Element* styleElementForNode(Node* node)
1628 {
1629     if (!node)
1630         return nullptr;
1631     if (is&lt;Element&gt;(*node))
1632         return downcast&lt;Element&gt;(node);
1633     return composedTreeAncestors(*node).first();
1634 }
1635 
1636 ComputedStyleExtractor::ComputedStyleExtractor(Node* node, bool allowVisitedStyle, PseudoId pseudoElementSpecifier)
1637     : m_element(styleElementForNode(node))
1638     , m_pseudoElementSpecifier(pseudoElementSpecifier)
1639     , m_allowVisitedStyle(allowVisitedStyle)
1640 {
1641 }
1642 
1643 ComputedStyleExtractor::ComputedStyleExtractor(Element* element, bool allowVisitedStyle, PseudoId pseudoElementSpecifier)
1644     : m_element(element)
1645     , m_pseudoElementSpecifier(pseudoElementSpecifier)
1646     , m_allowVisitedStyle(allowVisitedStyle)
1647 {
1648 }
1649 
1650 CSSComputedStyleDeclaration::CSSComputedStyleDeclaration(Element&amp; element, bool allowVisitedStyle, const String&amp; pseudoElementName)
1651     : m_element(element)
1652     , m_allowVisitedStyle(allowVisitedStyle)
1653     , m_refCount(1)
1654 {
1655     unsigned nameWithoutColonsStart = pseudoElementName[0] == &#39;:&#39; ? (pseudoElementName[1] == &#39;:&#39; ? 2 : 1) : 0;
1656     m_pseudoElementSpecifier = CSSSelector::pseudoId(CSSSelector::parsePseudoElementType(
1657     (pseudoElementName.substringSharingImpl(nameWithoutColonsStart))));
1658 }
1659 
1660 CSSComputedStyleDeclaration::~CSSComputedStyleDeclaration() = default;
1661 
1662 void CSSComputedStyleDeclaration::ref()
1663 {
1664     ++m_refCount;
1665 }
1666 
1667 void CSSComputedStyleDeclaration::deref()
1668 {
1669     ASSERT(m_refCount);
1670     if (!--m_refCount)
1671         delete this;
1672 }
1673 
1674 String CSSComputedStyleDeclaration::cssText() const
1675 {
1676     StringBuilder result;
1677 
1678     for (unsigned i = 0; i &lt; numComputedProperties; i++) {
1679         if (i)
1680             result.append(&#39; &#39;);
1681         result.append(getPropertyName(computedProperties[i]));
1682         result.appendLiteral(&quot;: &quot;);
1683         result.append(getPropertyValue(computedProperties[i]));
1684         result.append(&#39;;&#39;);
1685     }
1686 
1687     return result.toString();
1688 }
1689 
1690 ExceptionOr&lt;void&gt; CSSComputedStyleDeclaration::setCssText(const String&amp;)
1691 {
1692     return Exception { NoModificationAllowedError };
1693 }
1694 
1695 RefPtr&lt;CSSPrimitiveValue&gt; ComputedStyleExtractor::getFontSizeCSSValuePreferringKeyword()
1696 {
1697     if (!m_element)
1698         return nullptr;
1699 
1700     m_element-&gt;document().updateLayoutIgnorePendingStylesheets();
1701 
1702     auto* style = m_element-&gt;computedStyle(m_pseudoElementSpecifier);
1703     if (!style)
1704         return nullptr;
1705 
1706     if (CSSValueID sizeIdentifier = style-&gt;fontDescription().keywordSizeAsIdentifier())
1707         return CSSValuePool::singleton().createIdentifierValue(sizeIdentifier);
1708 
1709     return zoomAdjustedPixelValue(style-&gt;fontDescription().computedSize(), *style);
1710 }
1711 
1712 bool ComputedStyleExtractor::useFixedFontDefaultSize()
1713 {
1714     if (!m_element)
1715         return false;
1716     auto* style = m_element-&gt;computedStyle(m_pseudoElementSpecifier);
1717     if (!style)
1718         return false;
1719 
1720     return style-&gt;fontDescription().useFixedDefaultSize();
1721 }
1722 
1723 static CSSValueID identifierForFamily(const AtomicString&amp; family)
1724 {
1725     if (family == cursiveFamily)
1726         return CSSValueCursive;
1727     if (family == fantasyFamily)
1728         return CSSValueFantasy;
1729     if (family == monospaceFamily)
1730         return CSSValueMonospace;
1731     if (family == pictographFamily)
1732         return CSSValueWebkitPictograph;
1733     if (family == sansSerifFamily)
1734         return CSSValueSansSerif;
1735     if (family == serifFamily)
1736         return CSSValueSerif;
1737     if (family == systemUiFamily)
1738         return CSSValueSystemUi;
1739     return CSSValueInvalid;
1740 }
1741 
1742 static Ref&lt;CSSPrimitiveValue&gt; valueForFamily(const AtomicString&amp; family)
1743 {
1744     if (CSSValueID familyIdentifier = identifierForFamily(family))
1745         return CSSValuePool::singleton().createIdentifierValue(familyIdentifier);
1746     return CSSValuePool::singleton().createFontFamilyValue(family);
1747 }
1748 
1749 #if ENABLE(POINTER_EVENTS)
1750 static Ref&lt;CSSValue&gt; touchActionFlagsToCSSValue(OptionSet&lt;TouchAction&gt; touchActions)
1751 {
1752     auto&amp; cssValuePool = CSSValuePool::singleton();
1753 
1754     if (touchActions &amp; TouchAction::Auto)
1755         return cssValuePool.createIdentifierValue(CSSValueAuto);
1756     if (touchActions &amp; TouchAction::None)
1757         return cssValuePool.createIdentifierValue(CSSValueNone);
1758     if (touchActions &amp; TouchAction::Manipulation)
1759         return cssValuePool.createIdentifierValue(CSSValueManipulation);
1760 
1761     auto list = CSSValueList::createSpaceSeparated();
1762     if (touchActions &amp; TouchAction::PanX)
1763         list-&gt;append(cssValuePool.createIdentifierValue(CSSValuePanX));
1764     if (touchActions &amp; TouchAction::PanY)
1765         list-&gt;append(cssValuePool.createIdentifierValue(CSSValuePanY));
1766     if (touchActions &amp; TouchAction::PinchZoom)
1767         list-&gt;append(cssValuePool.createIdentifierValue(CSSValuePinchZoom));
1768 
1769     if (!list-&gt;length())
1770         return cssValuePool.createIdentifierValue(CSSValueAuto);
1771     return WTFMove(list);
1772 }
1773 #endif
1774 
1775 static Ref&lt;CSSValue&gt; renderTextDecorationFlagsToCSSValue(OptionSet&lt;TextDecoration&gt; textDecoration)
1776 {
1777     auto&amp; cssValuePool = CSSValuePool::singleton();
1778     // Blink value is ignored.
1779     auto list = CSSValueList::createSpaceSeparated();
1780     if (textDecoration &amp; TextDecoration::Underline)
1781         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueUnderline));
1782     if (textDecoration &amp; TextDecoration::Overline)
1783         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueOverline));
1784     if (textDecoration &amp; TextDecoration::LineThrough)
1785         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueLineThrough));
1786 #if ENABLE(LETTERPRESS)
1787     if (textDecoration &amp; TextDecoration::Letterpress)
1788         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueWebkitLetterpress));
1789 #endif
1790 
1791     if (!list-&gt;length())
1792         return cssValuePool.createIdentifierValue(CSSValueNone);
1793     return WTFMove(list);
1794 }
1795 
1796 static Ref&lt;CSSValue&gt; renderTextDecorationStyleFlagsToCSSValue(TextDecorationStyle textDecorationStyle)
1797 {
1798     switch (textDecorationStyle) {
1799     case TextDecorationStyle::Solid:
1800         return CSSValuePool::singleton().createIdentifierValue(CSSValueSolid);
1801     case TextDecorationStyle::Double:
1802         return CSSValuePool::singleton().createIdentifierValue(CSSValueDouble);
1803     case TextDecorationStyle::Dotted:
1804         return CSSValuePool::singleton().createIdentifierValue(CSSValueDotted);
1805     case TextDecorationStyle::Dashed:
1806         return CSSValuePool::singleton().createIdentifierValue(CSSValueDashed);
1807     case TextDecorationStyle::Wavy:
1808         return CSSValuePool::singleton().createIdentifierValue(CSSValueWavy);
1809     }
1810 
1811     ASSERT_NOT_REACHED();
1812     return CSSValuePool::singleton().createExplicitInitialValue();
1813 }
1814 
1815 static Ref&lt;CSSValue&gt; renderTextDecorationSkipFlagsToCSSValue(OptionSet&lt;TextDecorationSkip&gt; textDecorationSkip)
1816 {
1817     // FIXME: This should probably return a CSSValueList with the set of all TextDecorationSkips.
1818     switch (static_cast&lt;TextDecorationSkip&gt;(textDecorationSkip.toRaw())) {
1819     case TextDecorationSkip::Auto:
1820         return CSSValuePool::singleton().createIdentifierValue(CSSValueAuto);
1821     case TextDecorationSkip::None:
1822         return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
1823     case TextDecorationSkip::Ink:
1824         return CSSValuePool::singleton().createIdentifierValue(CSSValueInk);
1825     case TextDecorationSkip::Objects:
1826         return CSSValuePool::singleton().createIdentifierValue(CSSValueObjects);
1827     }
1828 
1829     ASSERT_NOT_REACHED();
1830     return CSSValuePool::singleton().createExplicitInitialValue();
1831 }
1832 
1833 static Ref&lt;CSSValue&gt; textUnderlineOffsetToCSSValue(const TextUnderlineOffset&amp; textUnderlineOffset)
1834 {
1835     if (textUnderlineOffset.isAuto())
1836         return CSSValuePool::singleton().createIdentifierValue(CSSValueAuto);
1837     ASSERT(textUnderlineOffset.isLength());
1838     return CSSValuePool::singleton().createValue(textUnderlineOffset.lengthValue(), CSSPrimitiveValue::CSS_PX);
1839 }
1840 
1841 static Ref&lt;CSSValue&gt; textDecorationThicknessToCSSValue(const TextDecorationThickness&amp; textDecorationThickness)
1842 {
1843     if (textDecorationThickness.isAuto())
1844         return CSSValuePool::singleton().createIdentifierValue(CSSValueAuto);
1845     if (textDecorationThickness.isFromFont())
1846         return CSSValuePool::singleton().createIdentifierValue(CSSValueFromFont);
1847     ASSERT(textDecorationThickness.isLength());
1848     return CSSValuePool::singleton().createValue(textDecorationThickness.lengthValue(), CSSPrimitiveValue::CSS_PX);
1849 }
1850 
1851 static Ref&lt;CSSValue&gt; renderEmphasisPositionFlagsToCSSValue(OptionSet&lt;TextEmphasisPosition&gt; textEmphasisPosition)
1852 {
1853     ASSERT(!((textEmphasisPosition &amp; TextEmphasisPosition::Over) &amp;&amp; (textEmphasisPosition &amp; TextEmphasisPosition::Under)));
1854     ASSERT(!((textEmphasisPosition &amp; TextEmphasisPosition::Left) &amp;&amp; (textEmphasisPosition &amp; TextEmphasisPosition::Right)));
1855     auto&amp; cssValuePool = CSSValuePool::singleton();
1856     auto list = CSSValueList::createSpaceSeparated();
1857     if (textEmphasisPosition &amp; TextEmphasisPosition::Over)
1858         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueOver));
1859     if (textEmphasisPosition &amp; TextEmphasisPosition::Under)
1860         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueUnder));
1861     if (textEmphasisPosition &amp; TextEmphasisPosition::Left)
1862         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueLeft));
1863     if (textEmphasisPosition &amp; TextEmphasisPosition::Right)
1864         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueRight));
1865     if (!list-&gt;length())
1866         return cssValuePool.createIdentifierValue(CSSValueNone);
1867     return WTFMove(list);
1868 }
1869 
1870 static Ref&lt;CSSValue&gt; speakAsToCSSValue(OptionSet&lt;SpeakAs&gt; speakAs)
1871 {
1872     auto&amp; cssValuePool = CSSValuePool::singleton();
1873     auto list = CSSValueList::createSpaceSeparated();
1874     if (speakAs &amp; SpeakAs::SpellOut)
1875         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueSpellOut));
1876     if (speakAs &amp; SpeakAs::Digits)
1877         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueDigits));
1878     if (speakAs &amp; SpeakAs::LiteralPunctuation)
1879         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueLiteralPunctuation));
1880     if (speakAs &amp; SpeakAs::NoPunctuation)
1881         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueNoPunctuation));
1882     if (!list-&gt;length())
1883         return cssValuePool.createIdentifierValue(CSSValueNormal);
1884     return WTFMove(list);
1885 }
1886 
1887 static Ref&lt;CSSValue&gt; hangingPunctuationToCSSValue(OptionSet&lt;HangingPunctuation&gt; hangingPunctuation)
1888 {
1889     auto&amp; cssValuePool = CSSValuePool::singleton();
1890     auto list = CSSValueList::createSpaceSeparated();
1891     if (hangingPunctuation &amp; HangingPunctuation::First)
1892         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueFirst));
1893     if (hangingPunctuation &amp; HangingPunctuation::AllowEnd)
1894         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueAllowEnd));
1895     if (hangingPunctuation &amp; HangingPunctuation::ForceEnd)
1896         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueForceEnd));
1897     if (hangingPunctuation &amp; HangingPunctuation::Last)
1898         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueLast));
1899     if (!list-&gt;length())
1900         return cssValuePool.createIdentifierValue(CSSValueNone);
1901     return WTFMove(list);
1902 }
1903 
1904 static Ref&lt;CSSValue&gt; fillRepeatToCSSValue(FillRepeat xRepeat, FillRepeat yRepeat)
1905 {
1906     // For backwards compatibility, if both values are equal, just return one of them. And
1907     // if the two values are equivalent to repeat-x or repeat-y, just return the shorthand.
1908     auto&amp; cssValuePool = CSSValuePool::singleton();
1909     if (xRepeat == yRepeat)
1910         return cssValuePool.createValue(xRepeat);
1911     if (xRepeat == FillRepeat::Repeat &amp;&amp; yRepeat == FillRepeat::NoRepeat)
1912         return cssValuePool.createIdentifierValue(CSSValueRepeatX);
1913     if (xRepeat == FillRepeat::NoRepeat &amp;&amp; yRepeat == FillRepeat::Repeat)
1914         return cssValuePool.createIdentifierValue(CSSValueRepeatY);
1915 
1916     auto list = CSSValueList::createSpaceSeparated();
1917     list-&gt;append(cssValuePool.createValue(xRepeat));
1918     list-&gt;append(cssValuePool.createValue(yRepeat));
1919     return WTFMove(list);
1920 }
1921 
1922 static Ref&lt;CSSValue&gt; fillSourceTypeToCSSValue(MaskSourceType type)
1923 {
1924     switch (type) {
1925     case MaskSourceType::Alpha:
1926         return CSSValuePool::singleton().createValue(CSSValueAlpha);
1927     default:
1928         ASSERT(type == MaskSourceType::Luminance);
1929         return CSSValuePool::singleton().createValue(CSSValueLuminance);
1930     }
1931 }
1932 
1933 static Ref&lt;CSSValue&gt; fillSizeToCSSValue(const FillSize&amp; fillSize, const RenderStyle&amp; style)
1934 {
1935     if (fillSize.type == FillSizeType::Contain)
1936         return CSSValuePool::singleton().createIdentifierValue(CSSValueContain);
1937 
1938     if (fillSize.type == FillSizeType::Cover)
1939         return CSSValuePool::singleton().createIdentifierValue(CSSValueCover);
1940 
1941     if (fillSize.size.height.isAuto())
1942         return zoomAdjustedPixelValueForLength(fillSize.size.width, style);
1943 
1944     auto list = CSSValueList::createSpaceSeparated();
1945     list-&gt;append(zoomAdjustedPixelValueForLength(fillSize.size.width, style));
1946     list-&gt;append(zoomAdjustedPixelValueForLength(fillSize.size.height, style));
1947     return WTFMove(list);
1948 }
1949 
1950 static Ref&lt;CSSValue&gt; altTextToCSSValue(const RenderStyle&amp; style)
1951 {
1952     return CSSValuePool::singleton().createValue(style.contentAltText(), CSSPrimitiveValue::CSS_STRING);
1953 }
1954 
1955 static Ref&lt;CSSValueList&gt; contentToCSSValue(const RenderStyle&amp; style)
1956 {
1957     auto&amp; cssValuePool = CSSValuePool::singleton();
1958     auto list = CSSValueList::createSpaceSeparated();
1959     for (auto* contentData = style.contentData(); contentData; contentData = contentData-&gt;next()) {
1960         if (is&lt;CounterContentData&gt;(*contentData))
1961             list-&gt;append(cssValuePool.createValue(downcast&lt;CounterContentData&gt;(*contentData).counter().identifier(), CSSPrimitiveValue::CSS_COUNTER_NAME));
1962         else if (is&lt;ImageContentData&gt;(*contentData))
1963             list-&gt;append(downcast&lt;ImageContentData&gt;(*contentData).image().cssValue());
1964         else if (is&lt;TextContentData&gt;(*contentData))
1965             list-&gt;append(cssValuePool.createValue(downcast&lt;TextContentData&gt;(*contentData).text(), CSSPrimitiveValue::CSS_STRING));
1966     }
1967     return list;
1968 }
1969 
1970 static Ref&lt;CSSValue&gt; counterToCSSValue(const RenderStyle&amp; style, CSSPropertyID propertyID)
1971 {
1972     auto* map = style.counterDirectives();
1973     if (!map)
1974         return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
1975 
1976     auto&amp; cssValuePool = CSSValuePool::singleton();
1977     auto list = CSSValueList::createSpaceSeparated();
1978     for (auto&amp; keyValue : *map) {
1979         list-&gt;append(cssValuePool.createValue(keyValue.key, CSSPrimitiveValue::CSS_STRING));
1980         double number = (propertyID == CSSPropertyCounterIncrement ? keyValue.value.incrementValue : keyValue.value.resetValue).valueOr(0);
1981         list-&gt;append(cssValuePool.createValue(number, CSSPrimitiveValue::CSS_NUMBER));
1982     }
1983     return WTFMove(list);
1984 }
1985 
1986 static void logUnimplementedPropertyID(CSSPropertyID propertyID)
1987 {
1988     static NeverDestroyed&lt;HashSet&lt;CSSPropertyID&gt;&gt; propertyIDSet;
1989     if (!propertyIDSet.get().add(propertyID).isNewEntry)
1990         return;
1991 
1992     LOG_ERROR(&quot;WebKit does not yet implement getComputedStyle for &#39;%s&#39;.&quot;, getPropertyName(propertyID));
1993 }
1994 
1995 static Ref&lt;CSSValueList&gt; fontFamilyListFromStyle(const RenderStyle&amp; style)
1996 {
1997     auto list = CSSValueList::createCommaSeparated();
1998     for (unsigned i = 0; i &lt; style.fontCascade().familyCount(); ++i)
1999         list-&gt;append(valueForFamily(style.fontCascade().familyAt(i)));
2000     return list;
2001 }
2002 
2003 static Ref&lt;CSSValue&gt; fontFamilyFromStyle(const RenderStyle&amp; style)
2004 {
2005     if (style.fontCascade().familyCount() == 1)
2006         return valueForFamily(style.fontCascade().familyAt(0));
2007     return fontFamilyListFromStyle(style);
2008 }
2009 
2010 static Ref&lt;CSSPrimitiveValue&gt; lineHeightFromStyle(const RenderStyle&amp; style)
2011 {
2012     Length length = style.lineHeight();
2013     if (length.isNegative()) // If true, line-height not set; use the font&#39;s line spacing.
2014         return zoomAdjustedPixelValue(style.fontMetrics().floatLineSpacing(), style);
2015     if (length.isPercent()) {
2016         // This is imperfect, because it doesn&#39;t include the zoom factor and the real computation
2017         // for how high to be in pixels does include things like minimum font size and the zoom factor.
2018         // On the other hand, since font-size doesn&#39;t include the zoom factor, we really can&#39;t do
2019         // that here either.
2020         return zoomAdjustedPixelValue(static_cast&lt;int&gt;(length.percent() * style.fontDescription().computedSize()) / 100, style);
2021     }
2022     return zoomAdjustedPixelValue(floatValueForLength(length, 0), style);
2023 }
2024 
2025 static Ref&lt;CSSPrimitiveValue&gt; fontSizeFromStyle(const RenderStyle&amp; style)
2026 {
2027     return zoomAdjustedPixelValue(style.fontDescription().computedSize(), style);
2028 }
2029 
2030 Ref&lt;CSSPrimitiveValue&gt; ComputedStyleExtractor::fontNonKeywordWeightFromStyleValue(FontSelectionValue weight)
2031 {
2032     return CSSValuePool::singleton().createValue(static_cast&lt;float&gt;(weight), CSSPrimitiveValue::CSS_NUMBER);
2033 }
2034 
2035 Ref&lt;CSSPrimitiveValue&gt; ComputedStyleExtractor::fontWeightFromStyleValue(FontSelectionValue weight)
2036 {
2037     if (auto value = fontWeightKeyword(weight))
2038         return CSSValuePool::singleton().createIdentifierValue(value.value());
2039     return fontNonKeywordWeightFromStyleValue(weight);
2040 }
2041 
2042 static Ref&lt;CSSPrimitiveValue&gt; fontWeightFromStyle(const RenderStyle&amp; style)
2043 {
2044     return ComputedStyleExtractor::fontWeightFromStyleValue(style.fontDescription().weight());
2045 }
2046 
2047 Ref&lt;CSSPrimitiveValue&gt; ComputedStyleExtractor::fontNonKeywordStretchFromStyleValue(FontSelectionValue stretch)
2048 {
2049     return CSSValuePool::singleton().createValue(static_cast&lt;float&gt;(stretch), CSSPrimitiveValue::CSS_PERCENTAGE);
2050 }
2051 
2052 Ref&lt;CSSPrimitiveValue&gt; ComputedStyleExtractor::fontStretchFromStyleValue(FontSelectionValue stretch)
2053 {
2054     if (auto keyword = fontStretchKeyword(stretch))
2055         return CSSValuePool::singleton().createIdentifierValue(keyword.value());
2056     return fontNonKeywordStretchFromStyleValue(stretch);
2057 }
2058 
2059 static Ref&lt;CSSPrimitiveValue&gt; fontStretchFromStyle(const RenderStyle&amp; style)
2060 {
2061     return ComputedStyleExtractor::fontStretchFromStyleValue(style.fontDescription().stretch());
2062 }
2063 
2064 Ref&lt;CSSFontStyleValue&gt; ComputedStyleExtractor::fontNonKeywordStyleFromStyleValue(FontSelectionValue italic)
2065 {
2066     return CSSFontStyleValue::create(CSSValuePool::singleton().createIdentifierValue(CSSValueOblique), CSSValuePool::singleton().createValue(static_cast&lt;float&gt;(italic), CSSPrimitiveValue::CSS_DEG));
2067 }
2068 
2069 Ref&lt;CSSFontStyleValue&gt; ComputedStyleExtractor::fontStyleFromStyleValue(Optional&lt;FontSelectionValue&gt; italic, FontStyleAxis fontStyleAxis)
2070 {
2071     if (auto keyword = fontStyleKeyword(italic, fontStyleAxis))
2072         return CSSFontStyleValue::create(CSSValuePool::singleton().createIdentifierValue(keyword.value()));
2073     return fontNonKeywordStyleFromStyleValue(italic.value());
2074 }
2075 
2076 static Ref&lt;CSSFontStyleValue&gt; fontStyleFromStyle(const RenderStyle&amp; style)
2077 {
2078     return ComputedStyleExtractor::fontStyleFromStyleValue(style.fontDescription().italic(), style.fontDescription().fontStyleAxis());
2079 }
2080 
2081 static Ref&lt;CSSValue&gt; fontVariantFromStyle(const RenderStyle&amp; style)
2082 {
2083     if (style.fontDescription().variantSettings().isAllNormal())
2084         return CSSValuePool::singleton().createIdentifierValue(CSSValueNormal);
2085 
2086     auto list = CSSValueList::createSpaceSeparated();
2087 
2088     switch (style.fontDescription().variantCommonLigatures()) {
2089     case FontVariantLigatures::Normal:
2090         break;
2091     case FontVariantLigatures::Yes:
2092         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueCommonLigatures));
2093         break;
2094     case FontVariantLigatures::No:
2095         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueNoCommonLigatures));
2096         break;
2097     }
2098 
2099     switch (style.fontDescription().variantDiscretionaryLigatures()) {
2100     case FontVariantLigatures::Normal:
2101         break;
2102     case FontVariantLigatures::Yes:
2103         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueDiscretionaryLigatures));
2104         break;
2105     case FontVariantLigatures::No:
2106         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueNoDiscretionaryLigatures));
2107         break;
2108     }
2109 
2110     switch (style.fontDescription().variantHistoricalLigatures()) {
2111     case FontVariantLigatures::Normal:
2112         break;
2113     case FontVariantLigatures::Yes:
2114         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueHistoricalLigatures));
2115         break;
2116     case FontVariantLigatures::No:
2117         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueNoHistoricalLigatures));
2118         break;
2119     }
2120 
2121     switch (style.fontDescription().variantContextualAlternates()) {
2122     case FontVariantLigatures::Normal:
2123         break;
2124     case FontVariantLigatures::Yes:
2125         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueContextual));
2126         break;
2127     case FontVariantLigatures::No:
2128         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueNoContextual));
2129         break;
2130     }
2131 
2132     switch (style.fontDescription().variantPosition()) {
2133     case FontVariantPosition::Normal:
2134         break;
2135     case FontVariantPosition::Subscript:
2136         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueSub));
2137         break;
2138     case FontVariantPosition::Superscript:
2139         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueSuper));
2140         break;
2141     }
2142 
2143     switch (style.fontDescription().variantCaps()) {
2144     case FontVariantCaps::Normal:
2145         break;
2146     case FontVariantCaps::Small:
2147         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueSmallCaps));
2148         break;
2149     case FontVariantCaps::AllSmall:
2150         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueAllSmallCaps));
2151         break;
2152     case FontVariantCaps::Petite:
2153         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValuePetiteCaps));
2154         break;
2155     case FontVariantCaps::AllPetite:
2156         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueAllPetiteCaps));
2157         break;
2158     case FontVariantCaps::Unicase:
2159         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueUnicase));
2160         break;
2161     case FontVariantCaps::Titling:
2162         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueTitlingCaps));
2163         break;
2164     }
2165 
2166     switch (style.fontDescription().variantNumericFigure()) {
2167     case FontVariantNumericFigure::Normal:
2168         break;
2169     case FontVariantNumericFigure::LiningNumbers:
2170         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueLiningNums));
2171         break;
2172     case FontVariantNumericFigure::OldStyleNumbers:
2173         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueOldstyleNums));
2174         break;
2175     }
2176 
2177     switch (style.fontDescription().variantNumericSpacing()) {
2178     case FontVariantNumericSpacing::Normal:
2179         break;
2180     case FontVariantNumericSpacing::ProportionalNumbers:
2181         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueProportionalNums));
2182         break;
2183     case FontVariantNumericSpacing::TabularNumbers:
2184         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueTabularNums));
2185         break;
2186     }
2187 
2188     switch (style.fontDescription().variantNumericFraction()) {
2189     case FontVariantNumericFraction::Normal:
2190         break;
2191     case FontVariantNumericFraction::DiagonalFractions:
2192         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueDiagonalFractions));
2193         break;
2194     case FontVariantNumericFraction::StackedFractions:
2195         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueStackedFractions));
2196         break;
2197     }
2198 
2199     switch (style.fontDescription().variantNumericOrdinal()) {
2200     case FontVariantNumericOrdinal::Normal:
2201         break;
2202     case FontVariantNumericOrdinal::Yes:
2203         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueOrdinal));
2204         break;
2205     }
2206 
2207     switch (style.fontDescription().variantNumericSlashedZero()) {
2208     case FontVariantNumericSlashedZero::Normal:
2209         break;
2210     case FontVariantNumericSlashedZero::Yes:
2211         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueSlashedZero));
2212         break;
2213     }
2214 
2215     switch (style.fontDescription().variantAlternates()) {
2216     case FontVariantAlternates::Normal:
2217         break;
2218     case FontVariantAlternates::HistoricalForms:
2219         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueHistoricalForms));
2220         break;
2221     }
2222 
2223     switch (style.fontDescription().variantEastAsianVariant()) {
2224     case FontVariantEastAsianVariant::Normal:
2225         break;
2226     case FontVariantEastAsianVariant::Jis78:
2227         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueJis78));
2228         break;
2229     case FontVariantEastAsianVariant::Jis83:
2230         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueJis83));
2231         break;
2232     case FontVariantEastAsianVariant::Jis90:
2233         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueJis90));
2234         break;
2235     case FontVariantEastAsianVariant::Jis04:
2236         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueJis04));
2237         break;
2238     case FontVariantEastAsianVariant::Simplified:
2239         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueSimplified));
2240         break;
2241     case FontVariantEastAsianVariant::Traditional:
2242         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueTraditional));
2243         break;
2244     }
2245 
2246     switch (style.fontDescription().variantEastAsianWidth()) {
2247     case FontVariantEastAsianWidth::Normal:
2248         break;
2249     case FontVariantEastAsianWidth::Full:
2250         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueFullWidth));
2251         break;
2252     case FontVariantEastAsianWidth::Proportional:
2253         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueProportionalWidth));
2254         break;
2255     }
2256 
2257     switch (style.fontDescription().variantEastAsianRuby()) {
2258     case FontVariantEastAsianRuby::Normal:
2259         break;
2260     case FontVariantEastAsianRuby::Yes:
2261         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueRuby));
2262         break;
2263     }
2264 
2265     return WTFMove(list);
2266 }
2267 
2268 static Ref&lt;CSSValue&gt; fontSynthesisFromStyle(const RenderStyle&amp; style)
2269 {
2270     if (style.fontDescription().fontSynthesis() == FontSynthesisNone)
2271         return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
2272 
2273     auto list = CSSValueList::createSpaceSeparated();
2274     if (style.fontDescription().fontSynthesis() &amp; FontSynthesisStyle)
2275         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueStyle));
2276     if (style.fontDescription().fontSynthesis() &amp; FontSynthesisWeight)
2277         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueWeight));
2278     if (style.fontDescription().fontSynthesis() &amp; FontSynthesisSmallCaps)
2279         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueSmallCaps));
2280     return WTFMove(list);
2281 }
2282 
2283 typedef const Length&amp; (RenderStyle::*RenderStyleLengthGetter)() const;
2284 typedef LayoutUnit (RenderBoxModelObject::*RenderBoxComputedCSSValueGetter)() const;
2285 
2286 template&lt;RenderStyleLengthGetter lengthGetter, RenderBoxComputedCSSValueGetter computedCSSValueGetter&gt;
2287 static RefPtr&lt;CSSValue&gt; zoomAdjustedPaddingOrMarginPixelValue(const RenderStyle&amp; style, RenderObject* renderer)
2288 {
2289     Length unzoomzedLength = (style.*lengthGetter)();
2290     if (!is&lt;RenderBox&gt;(renderer) || unzoomzedLength.isFixed())
2291         return zoomAdjustedPixelValueForLength(unzoomzedLength, style);
2292     return zoomAdjustedPixelValue((downcast&lt;RenderBox&gt;(*renderer).*computedCSSValueGetter)(), style);
2293 }
2294 
2295 template&lt;RenderStyleLengthGetter lengthGetter&gt;
2296 static bool paddingOrMarginIsRendererDependent(const RenderStyle* style, RenderObject* renderer)
2297 {
2298     return renderer &amp;&amp; style &amp;&amp; renderer-&gt;isBox() &amp;&amp; !(style-&gt;*lengthGetter)().isFixed();
2299 }
2300 
2301 static bool positionOffsetValueIsRendererDependent(const RenderStyle* style, RenderObject* renderer)
2302 {
2303     return renderer &amp;&amp; style &amp;&amp; renderer-&gt;isBox();
2304 }
2305 
2306 static CSSValueID convertToPageBreak(BreakBetween value)
2307 {
2308     if (value == BreakBetween::Page || value == BreakBetween::LeftPage || value == BreakBetween::RightPage
2309         || value == BreakBetween::RectoPage || value == BreakBetween::VersoPage)
2310         return CSSValueAlways; // CSS 2.1 allows us to map these to always.
2311     if (value == BreakBetween::Avoid || value == BreakBetween::AvoidPage)
2312         return CSSValueAvoid;
2313     return CSSValueAuto;
2314 }
2315 
2316 static CSSValueID convertToColumnBreak(BreakBetween value)
2317 {
2318     if (value == BreakBetween::Column)
2319         return CSSValueAlways;
2320     if (value == BreakBetween::Avoid || value == BreakBetween::AvoidColumn)
2321         return CSSValueAvoid;
2322     return CSSValueAuto;
2323 }
2324 
2325 static CSSValueID convertToPageBreak(BreakInside value)
2326 {
2327     if (value == BreakInside::Avoid || value == BreakInside::AvoidPage)
2328         return CSSValueAvoid;
2329     return CSSValueAuto;
2330 }
2331 
2332 static CSSValueID convertToColumnBreak(BreakInside value)
2333 {
2334     if (value == BreakInside::Avoid || value == BreakInside::AvoidColumn)
2335         return CSSValueAvoid;
2336     return CSSValueAuto;
2337 }
2338 
2339 static inline bool isNonReplacedInline(RenderObject&amp; renderer)
2340 {
2341     return renderer.isInline() &amp;&amp; !renderer.isReplaced();
2342 }
2343 
2344 static bool isLayoutDependent(CSSPropertyID propertyID, const RenderStyle* style, RenderObject* renderer)
2345 {
2346     switch (propertyID) {
2347     case CSSPropertyTop:
2348     case CSSPropertyBottom:
2349     case CSSPropertyLeft:
2350     case CSSPropertyRight:
2351     case CSSPropertyInsetBlockStart:
2352     case CSSPropertyInsetBlockEnd:
2353     case CSSPropertyInsetInlineStart:
2354     case CSSPropertyInsetInlineEnd:
2355         return positionOffsetValueIsRendererDependent(style, renderer);
2356     case CSSPropertyWidth:
2357     case CSSPropertyHeight:
2358     case CSSPropertyInlineSize:
2359     case CSSPropertyBlockSize:
2360         return renderer &amp;&amp; !renderer-&gt;isRenderSVGModelObject() &amp;&amp; !isNonReplacedInline(*renderer);
2361     case CSSPropertyPerspectiveOrigin:
2362     case CSSPropertyTransformOrigin:
2363     case CSSPropertyTransform:
2364     case CSSPropertyFilter: // Why are filters layout-dependent?
2365 #if ENABLE(FILTERS_LEVEL_2)
2366     case CSSPropertyWebkitBackdropFilter: // Ditto for backdrop-filter.
2367 #endif
2368         return true;
2369     case CSSPropertyMargin: {
2370         if (!renderer || !renderer-&gt;isBox())
2371             return false;
2372         return !(style &amp;&amp; style-&gt;marginTop().isFixed() &amp;&amp; style-&gt;marginRight().isFixed()
2373             &amp;&amp; style-&gt;marginBottom().isFixed() &amp;&amp; style-&gt;marginLeft().isFixed());
2374     }
2375     case CSSPropertyMarginTop:
2376         return paddingOrMarginIsRendererDependent&lt;&amp;RenderStyle::marginTop&gt;(style, renderer);
2377     case CSSPropertyMarginRight:
2378         return paddingOrMarginIsRendererDependent&lt;&amp;RenderStyle::marginRight&gt;(style, renderer);
2379     case CSSPropertyMarginBottom:
2380         return paddingOrMarginIsRendererDependent&lt;&amp;RenderStyle::marginBottom&gt;(style, renderer);
2381     case CSSPropertyMarginLeft:
2382         return paddingOrMarginIsRendererDependent&lt;&amp;RenderStyle::marginLeft&gt;(style, renderer);
2383     case CSSPropertyPadding: {
2384         if (!renderer || !renderer-&gt;isBox())
2385             return false;
2386         return !(style &amp;&amp; style-&gt;paddingTop().isFixed() &amp;&amp; style-&gt;paddingRight().isFixed()
2387             &amp;&amp; style-&gt;paddingBottom().isFixed() &amp;&amp; style-&gt;paddingLeft().isFixed());
2388     }
2389     case CSSPropertyPaddingTop:
2390         return paddingOrMarginIsRendererDependent&lt;&amp;RenderStyle::paddingTop&gt;(style, renderer);
2391     case CSSPropertyPaddingRight:
2392         return paddingOrMarginIsRendererDependent&lt;&amp;RenderStyle::paddingRight&gt;(style, renderer);
2393     case CSSPropertyPaddingBottom:
2394         return paddingOrMarginIsRendererDependent&lt;&amp;RenderStyle::paddingBottom&gt;(style, renderer);
2395     case CSSPropertyPaddingLeft:
2396         return paddingOrMarginIsRendererDependent&lt;&amp;RenderStyle::paddingLeft&gt;(style, renderer);
2397     case CSSPropertyGridTemplateColumns:
2398     case CSSPropertyGridTemplateRows:
2399     case CSSPropertyGridTemplate:
2400     case CSSPropertyGrid:
2401         return renderer &amp;&amp; renderer-&gt;isRenderGrid();
2402     default:
2403         return false;
2404     }
2405 }
2406 
2407 Element* ComputedStyleExtractor::styledElement() const
2408 {
2409     if (!m_element)
2410         return nullptr;
2411     PseudoElement* pseudoElement;
2412     if (m_pseudoElementSpecifier == PseudoId::Before &amp;&amp; (pseudoElement = m_element-&gt;beforePseudoElement()))
2413         return pseudoElement;
2414     if (m_pseudoElementSpecifier == PseudoId::After &amp;&amp; (pseudoElement = m_element-&gt;afterPseudoElement()))
2415         return pseudoElement;
2416     return m_element.get();
2417 }
2418 
2419 RenderElement* ComputedStyleExtractor::styledRenderer() const
2420 {
2421     auto* element = styledElement();
2422     if (!element)
2423         return nullptr;
2424     if (m_pseudoElementSpecifier != PseudoId::None &amp;&amp; element == m_element.get())
2425         return nullptr;
2426     if (element-&gt;hasDisplayContents())
2427         return nullptr;
2428     return element-&gt;renderer();
2429 }
2430 
2431 static bool isImplicitlyInheritedGridOrFlexProperty(CSSPropertyID propertyID)
2432 {
2433     // It would be nice if grid and flex worked within normal CSS mechanisms and not invented their own inheritance system.
2434     switch (propertyID) {
2435     case CSSPropertyAlignSelf:
2436     case CSSPropertyJustifySelf:
2437     case CSSPropertyJustifyItems:
2438     // FIXME: In StyleResolver::adjustRenderStyle z-index is adjusted based on the parent display property for grid/flex.
2439     case CSSPropertyZIndex:
2440         return true;
2441     default:
2442         return false;
2443     }
2444 }
2445 
2446 // In CSS 2.1 the returned object should actually contain the &quot;used values&quot;
2447 // rather then the &quot;computed values&quot; (despite the name saying otherwise).
2448 //
2449 // See;
2450 // http://www.w3.org/TR/CSS21/cascade.html#used-value
2451 // http://www.w3.org/TR/DOM-Level-2-Style/css.html#CSS-CSSStyleDeclaration
2452 // https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle#Notes
2453 RefPtr&lt;CSSValue&gt; CSSComputedStyleDeclaration::getPropertyCSSValue(CSSPropertyID propertyID, EUpdateLayout updateLayout) const
2454 {
2455     return ComputedStyleExtractor(m_element.ptr(), m_allowVisitedStyle, m_pseudoElementSpecifier).propertyValue(propertyID, updateLayout);
2456 }
2457 
2458 Ref&lt;MutableStyleProperties&gt; CSSComputedStyleDeclaration::copyProperties() const
2459 {
2460     return ComputedStyleExtractor(m_element.ptr(), m_allowVisitedStyle, m_pseudoElementSpecifier).copyProperties();
2461 }
2462 
2463 static inline bool hasValidStyleForProperty(Element&amp; element, CSSPropertyID propertyID)
2464 {
2465     if (element.styleValidity() != Style::Validity::Valid)
2466         return false;
2467     if (element.document().hasPendingFullStyleRebuild())
2468         return false;
2469     if (!element.document().childNeedsStyleRecalc())
2470         return true;
2471 
2472     bool isInherited = CSSProperty::isInheritedProperty(propertyID) || isImplicitlyInheritedGridOrFlexProperty(propertyID);
2473     bool maybeExplicitlyInherited = !isInherited;
2474 
2475     const auto* currentElement = &amp;element;
2476     for (auto&amp; ancestor : composedTreeAncestors(element)) {
2477         if (ancestor.styleValidity() &gt;= Style::Validity::SubtreeInvalid)
2478             return false;
2479 
2480         if (maybeExplicitlyInherited) {
2481             auto* style = currentElement-&gt;renderStyle();
2482             maybeExplicitlyInherited = !style || style-&gt;hasExplicitlyInheritedProperties();
2483         }
2484 
2485         if ((isInherited || maybeExplicitlyInherited) &amp;&amp; ancestor.styleValidity() == Style::Validity::ElementInvalid)
2486             return false;
2487 
2488         if (ancestor.directChildNeedsStyleRecalc() &amp;&amp; currentElement-&gt;styleIsAffectedByPreviousSibling())
2489             return false;
2490 
2491         currentElement = &amp;ancestor;
2492     }
2493 
2494     return true;
2495 }
2496 
2497 static bool updateStyleIfNeededForProperty(Element&amp; element, CSSPropertyID propertyID)
2498 {
2499     auto&amp; document = element.document();
2500 
2501     document.styleScope().flushPendingUpdate();
2502 
2503     if (hasValidStyleForProperty(element, propertyID))
2504         return false;
2505 
2506     document.updateStyleIfNeeded();
2507     return true;
2508 }
2509 
2510 static inline const RenderStyle* computeRenderStyleForProperty(Element&amp; element, PseudoId pseudoElementSpecifier, CSSPropertyID propertyID, std::unique_ptr&lt;RenderStyle&gt;&amp; ownedStyle)
2511 {
2512     auto* renderer = element.renderer();
2513 
2514     if (renderer &amp;&amp; renderer-&gt;isComposited() &amp;&amp; CSSAnimationController::supportsAcceleratedAnimationOfProperty(propertyID)) {
2515         if (auto timeline = element.document().existingTimeline())
2516             ownedStyle = timeline-&gt;animatedStyleForRenderer(*renderer);
2517         else
2518             ownedStyle = renderer-&gt;animation().animatedStyleForRenderer(*renderer);
2519         if (pseudoElementSpecifier != PseudoId::None &amp;&amp; !element.isPseudoElement()) {
2520             // FIXME: This cached pseudo style will only exist if the animation has been run at least once.
2521             return ownedStyle-&gt;getCachedPseudoStyle(pseudoElementSpecifier);
2522         }
2523         return ownedStyle.get();
2524     }
2525 
2526     return element.computedStyle(element.isPseudoElement() ? PseudoId::None : pseudoElementSpecifier);
2527 }
2528 
2529 static Ref&lt;CSSValue&gt; shapePropertyValue(const RenderStyle&amp; style, const ShapeValue* shapeValue)
2530 {
2531     if (!shapeValue)
2532         return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
2533 
2534     if (shapeValue-&gt;type() == ShapeValue::Type::Box)
2535         return CSSValuePool::singleton().createValue(shapeValue-&gt;cssBox());
2536 
2537     if (shapeValue-&gt;type() == ShapeValue::Type::Image) {
2538         if (shapeValue-&gt;image())
2539             return shapeValue-&gt;image()-&gt;cssValue();
2540         return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
2541     }
2542 
2543     ASSERT(shapeValue-&gt;type() == ShapeValue::Type::Shape);
2544 
2545     auto list = CSSValueList::createSpaceSeparated();
2546     list-&gt;append(valueForBasicShape(style, *shapeValue-&gt;shape()));
2547     if (shapeValue-&gt;cssBox() != CSSBoxType::BoxMissing)
2548         list-&gt;append(CSSValuePool::singleton().createValue(shapeValue-&gt;cssBox()));
2549     return WTFMove(list);
2550 }
2551 
2552 static Ref&lt;CSSValueList&gt; valueForItemPositionWithOverflowAlignment(const StyleSelfAlignmentData&amp; data)
2553 {
2554     auto&amp; cssValuePool = CSSValuePool::singleton();
2555     auto result = CSSValueList::createSpaceSeparated();
2556     if (data.positionType() == ItemPositionType::Legacy)
2557         result-&gt;append(cssValuePool.createIdentifierValue(CSSValueLegacy));
2558     if (data.position() == ItemPosition::Baseline)
2559         result-&gt;append(cssValuePool.createIdentifierValue(CSSValueBaseline));
2560     else if (data.position() == ItemPosition::LastBaseline) {
2561         result-&gt;append(cssValuePool.createIdentifierValue(CSSValueLast));
2562         result-&gt;append(cssValuePool.createIdentifierValue(CSSValueBaseline));
2563     } else {
2564         if (data.position() &gt;= ItemPosition::Center &amp;&amp; data.overflow() != OverflowAlignment::Default)
2565             result-&gt;append(cssValuePool.createValue(data.overflow()));
2566         if (data.position() == ItemPosition::Legacy)
2567             result-&gt;append(cssValuePool.createIdentifierValue(CSSValueNormal));
2568         else
2569             result-&gt;append(cssValuePool.createValue(data.position()));
2570     }
2571     ASSERT(result-&gt;length() &lt;= 2);
2572     return result;
2573 }
2574 
2575 static Ref&lt;CSSValueList&gt; valueForContentPositionAndDistributionWithOverflowAlignment(const StyleContentAlignmentData&amp; data)
2576 {
2577     auto&amp; cssValuePool = CSSValuePool::singleton();
2578     auto result = CSSValueList::createSpaceSeparated();
2579     // Handle content-distribution values
2580     if (data.distribution() != ContentDistribution::Default)
2581         result-&gt;append(cssValuePool.createValue(data.distribution()));
2582 
2583     // Handle content-position values (either as fallback or actual value)
2584     switch (data.position()) {
2585     case ContentPosition::Normal:
2586         // Handle &#39;normal&#39; value, not valid as content-distribution fallback.
2587         if (data.distribution() == ContentDistribution::Default)
2588             result-&gt;append(cssValuePool.createIdentifierValue(CSSValueNormal));
2589         break;
2590     case ContentPosition::LastBaseline:
2591         result-&gt;append(cssValuePool.createIdentifierValue(CSSValueLast));
2592         result-&gt;append(cssValuePool.createIdentifierValue(CSSValueBaseline));
2593         break;
2594     default:
2595         // Handle overflow-alignment (only allowed for content-position values)
2596         if ((data.position() &gt;= ContentPosition::Center || data.distribution() != ContentDistribution::Default) &amp;&amp; data.overflow() != OverflowAlignment::Default)
2597             result-&gt;append(cssValuePool.createValue(data.overflow()));
2598         result-&gt;append(cssValuePool.createValue(data.position()));
2599     }
2600 
2601     ASSERT(result-&gt;length() &gt; 0);
2602     ASSERT(result-&gt;length() &lt;= 3);
2603     return result;
2604 }
2605 
2606 static Ref&lt;CSSValue&gt; paintOrder(PaintOrder paintOrder)
2607 {
2608     if (paintOrder == PaintOrder::Normal)
2609         return CSSPrimitiveValue::createIdentifier(CSSValueNormal);
2610 
2611     auto paintOrderList = CSSValueList::createSpaceSeparated();
2612     switch (paintOrder) {
2613     case PaintOrder::Normal:
2614         ASSERT_NOT_REACHED();
2615         break;
2616     case PaintOrder::Fill:
2617         paintOrderList-&gt;append(CSSPrimitiveValue::createIdentifier(CSSValueFill));
2618         break;
2619     case PaintOrder::FillMarkers:
2620         paintOrderList-&gt;append(CSSPrimitiveValue::createIdentifier(CSSValueFill));
2621         paintOrderList-&gt;append(CSSPrimitiveValue::createIdentifier(CSSValueMarkers));
2622         break;
2623     case PaintOrder::Stroke:
2624         paintOrderList-&gt;append(CSSPrimitiveValue::createIdentifier(CSSValueStroke));
2625         break;
2626     case PaintOrder::StrokeMarkers:
2627         paintOrderList-&gt;append(CSSPrimitiveValue::createIdentifier(CSSValueStroke));
2628         paintOrderList-&gt;append(CSSPrimitiveValue::createIdentifier(CSSValueMarkers));
2629         break;
2630     case PaintOrder::Markers:
2631         paintOrderList-&gt;append(CSSPrimitiveValue::createIdentifier(CSSValueMarkers));
2632         break;
2633     case PaintOrder::MarkersStroke:
2634         paintOrderList-&gt;append(CSSPrimitiveValue::createIdentifier(CSSValueMarkers));
2635         paintOrderList-&gt;append(CSSPrimitiveValue::createIdentifier(CSSValueStroke));
2636         break;
2637     }
2638     return WTFMove(paintOrderList);
2639 }
2640 
2641 inline static bool isFlexOrGrid(ContainerNode* element)
2642 {
2643     return element &amp;&amp; element-&gt;computedStyle() &amp;&amp; element-&gt;computedStyle()-&gt;isDisplayFlexibleOrGridBox();
2644 }
2645 
2646 RefPtr&lt;CSSValue&gt; ComputedStyleExtractor::customPropertyValue(const String&amp; propertyName)
2647 {
2648     Element* styledElement = this-&gt;styledElement();
2649     if (!styledElement)
2650         return nullptr;
2651 
2652     if (updateStyleIfNeededForProperty(*styledElement, CSSPropertyCustom)) {
2653         // Style update may change styledElement() to PseudoElement or back.
2654         styledElement = this-&gt;styledElement();
2655     }
2656 
2657     std::unique_ptr&lt;RenderStyle&gt; ownedStyle;
2658     auto* style = computeRenderStyleForProperty(*styledElement, m_pseudoElementSpecifier, CSSPropertyCustom, ownedStyle);
2659     if (!style)
2660         return nullptr;
2661 
2662     auto* registered = styledElement-&gt;document().getCSSRegisteredCustomPropertySet().get(propertyName);
2663     auto* value = style-&gt;getCustomProperty(propertyName);
2664 
2665     if (registered &amp;&amp; !value)
2666         return registered-&gt;initialValueCopy();
2667 
2668     if (!value)
2669         return nullptr;
2670 
2671     return WTF::switchOn(value-&gt;value(), [&amp;](const Ref&lt;CSSVariableReferenceValue&gt;&amp;) {
2672         ASSERT_NOT_REACHED();
2673         return RefPtr&lt;CSSValue&gt;();
2674     }, [&amp;](const CSSValueID&amp;) {
2675         return CSSCustomPropertyValue::create(*value);
2676     }, [&amp;](const Ref&lt;CSSVariableData&gt;&amp;) {
2677         return CSSCustomPropertyValue::create(*value);
2678     }, [&amp;](const Length&amp; value) {
2679         return zoomAdjustedPixelValueForLength(value, *style);
2680     }, [&amp;](const Ref&lt;StyleImage&gt;&amp;) {
2681         return CSSCustomPropertyValue::create(*value);
2682     });
2683 }
2684 
2685 String ComputedStyleExtractor::customPropertyText(const String&amp; propertyName)
2686 {
2687     RefPtr&lt;CSSValue&gt; propertyValue = customPropertyValue(propertyName);
2688     return propertyValue ? propertyValue-&gt;cssText() : emptyString();
2689 }
2690 
2691 static Ref&lt;CSSFontValue&gt; fontShorthandValueForSelectionProperties(const FontDescription&amp; fontDescription)
2692 {
2693     auto computedFont = CSSFontValue::create();
2694 
2695     auto variantCaps = fontDescription.variantCaps();
2696     if (variantCaps == FontVariantCaps::Small)
2697         computedFont-&gt;variant = CSSValuePool::singleton().createIdentifierValue(CSSValueSmallCaps);
2698     else if (variantCaps == FontVariantCaps::Normal)
2699         computedFont-&gt;variant = CSSValuePool::singleton().createIdentifierValue(CSSValueNormal);
2700     else
2701         return CSSFontValue::create();
2702 
2703     auto weight = fontDescription.weight();
2704     if (auto value = fontWeightKeyword(weight))
2705         computedFont-&gt;weight = CSSValuePool::singleton().createIdentifierValue(value.value());
2706     else if (isCSS21Weight(weight))
2707         computedFont-&gt;weight = CSSValuePool::singleton().createValue(static_cast&lt;float&gt;(weight), CSSPrimitiveValue::CSS_NUMBER);
2708     else
2709         return CSSFontValue::create();
2710 
2711     if (auto keyword = fontStretchKeyword(fontDescription.stretch()))
2712         computedFont-&gt;stretch = CSSValuePool::singleton().createIdentifierValue(keyword.value());
2713     else
2714         return CSSFontValue::create();
2715 
2716     if (auto italic = fontStyleKeyword(fontDescription.italic(), fontDescription.fontStyleAxis()))
2717         computedFont-&gt;style = CSSFontStyleValue::create(CSSValuePool::singleton().createIdentifierValue(italic.value()));
2718     else
2719         return CSSFontValue::create();
2720 
2721     return computedFont;
2722 }
2723 
2724 RefPtr&lt;CSSValue&gt; ComputedStyleExtractor::propertyValue(CSSPropertyID propertyID, EUpdateLayout updateLayout)
2725 {
2726     auto* styledElement = this-&gt;styledElement();
2727     if (!styledElement)
2728         return nullptr;
2729 
2730     std::unique_ptr&lt;RenderStyle&gt; ownedStyle;
2731     const RenderStyle* style = nullptr;
2732     RenderElement* renderer = nullptr;
2733     bool forceFullLayout = false;
2734     if (updateLayout) {
2735         Document&amp; document = m_element-&gt;document();
2736 
2737         if (updateStyleIfNeededForProperty(*styledElement, propertyID)) {
2738             // Style update may change styledElement() to PseudoElement or back.
2739             styledElement = this-&gt;styledElement();
2740         }
2741         renderer = styledRenderer();
2742 
2743         if (propertyID == CSSPropertyDisplay &amp;&amp; !renderer &amp;&amp; is&lt;SVGElement&gt;(*styledElement) &amp;&amp; !downcast&lt;SVGElement&gt;(*styledElement).isValid())
2744             return nullptr;
2745 
2746         style = computeRenderStyleForProperty(*styledElement, m_pseudoElementSpecifier, propertyID, ownedStyle);
2747 
2748         // FIXME: Some of these cases could be narrowed down or optimized better.
2749         forceFullLayout = isLayoutDependent(propertyID, style, renderer)
2750             || styledElement-&gt;isInShadowTree()
2751             || (document.styleScope().resolverIfExists() &amp;&amp; document.styleScope().resolverIfExists()-&gt;hasViewportDependentMediaQueries() &amp;&amp; document.ownerElement());
2752 
2753         if (forceFullLayout) {
2754             document.updateLayoutIgnorePendingStylesheets();
2755             styledElement = this-&gt;styledElement();
2756         }
2757     }
2758 
2759     if (!updateLayout || forceFullLayout) {
2760         style = computeRenderStyleForProperty(*styledElement, m_pseudoElementSpecifier, propertyID, ownedStyle);
2761         renderer = styledRenderer();
2762     }
2763 
2764     if (!style)
2765         return nullptr;
2766 
2767     return valueForPropertyinStyle(*style, propertyID, renderer);
2768 }
2769 
2770 RefPtr&lt;CSSValue&gt; ComputedStyleExtractor::valueForPropertyinStyle(const RenderStyle&amp; style, CSSPropertyID propertyID, RenderElement* renderer)
2771 {
2772     auto&amp; cssValuePool = CSSValuePool::singleton();
2773     propertyID = CSSProperty::resolveDirectionAwareProperty(propertyID, style.direction(), style.writingMode());
2774 
2775     switch (propertyID) {
2776         case CSSPropertyInvalid:
2777             break;
2778 
2779         case CSSPropertyBackgroundColor:
2780             return cssValuePool.createColorValue(m_allowVisitedStyle? style.visitedDependentColor(CSSPropertyBackgroundColor) : style.backgroundColor());
2781         case CSSPropertyBackgroundImage:
2782         case CSSPropertyWebkitMaskImage: {
2783             auto&amp; layers = propertyID == CSSPropertyWebkitMaskImage ? style.maskLayers() : style.backgroundLayers();
2784             if (!layers.next()) {
2785                 if (layers.image())
2786                     return layers.image()-&gt;cssValue();
2787                 return cssValuePool.createIdentifierValue(CSSValueNone);
2788             }
2789             auto list = CSSValueList::createCommaSeparated();
2790             for (auto* currLayer = &amp;layers; currLayer; currLayer = currLayer-&gt;next()) {
2791                 if (currLayer-&gt;image())
2792                     list-&gt;append(currLayer-&gt;image()-&gt;cssValue());
2793                 else
2794                     list-&gt;append(cssValuePool.createIdentifierValue(CSSValueNone));
2795             }
2796             return WTFMove(list);
2797         }
2798         case CSSPropertyBackgroundSize:
2799         case CSSPropertyWebkitBackgroundSize:
2800         case CSSPropertyWebkitMaskSize: {
2801             auto&amp; layers = propertyID == CSSPropertyWebkitMaskSize ? style.maskLayers() : style.backgroundLayers();
2802             if (!layers.next())
2803                 return fillSizeToCSSValue(layers.size(), style);
2804             auto list = CSSValueList::createCommaSeparated();
2805             for (auto* currLayer = &amp;layers; currLayer; currLayer = currLayer-&gt;next())
2806                 list-&gt;append(fillSizeToCSSValue(currLayer-&gt;size(), style));
2807             return WTFMove(list);
2808         }
2809         case CSSPropertyBackgroundRepeat:
2810         case CSSPropertyWebkitMaskRepeat: {
2811             auto&amp; layers = propertyID == CSSPropertyWebkitMaskRepeat ? style.maskLayers() : style.backgroundLayers();
2812             if (!layers.next())
2813                 return fillRepeatToCSSValue(layers.repeatX(), layers.repeatY());
2814             auto list = CSSValueList::createCommaSeparated();
2815             for (auto* currLayer = &amp;layers; currLayer; currLayer = currLayer-&gt;next())
2816                 list-&gt;append(fillRepeatToCSSValue(currLayer-&gt;repeatX(), currLayer-&gt;repeatY()));
2817             return WTFMove(list);
2818         }
2819         case CSSPropertyWebkitMaskSourceType: {
2820             auto&amp; layers = style.maskLayers();
2821             if (!layers.next())
2822                 return fillSourceTypeToCSSValue(layers.maskSourceType());
2823             auto list = CSSValueList::createCommaSeparated();
2824             for (auto* currLayer = &amp;layers; currLayer; currLayer = currLayer-&gt;next())
2825                 list-&gt;append(fillSourceTypeToCSSValue(currLayer-&gt;maskSourceType()));
2826             return WTFMove(list);
2827         }
2828         case CSSPropertyWebkitBackgroundComposite:
2829         case CSSPropertyWebkitMaskComposite: {
2830             auto&amp; layers = propertyID == CSSPropertyWebkitMaskComposite ? style.maskLayers() : style.backgroundLayers();
2831             if (!layers.next())
2832                 return cssValuePool.createValue(layers.composite());
2833             auto list = CSSValueList::createCommaSeparated();
2834             for (auto* currLayer = &amp;layers; currLayer; currLayer = currLayer-&gt;next())
2835                 list-&gt;append(cssValuePool.createValue(currLayer-&gt;composite()));
2836             return WTFMove(list);
2837         }
2838         case CSSPropertyBackgroundAttachment: {
2839             auto&amp; layers = style.backgroundLayers();
2840             if (!layers.next())
2841                 return cssValuePool.createValue(layers.attachment());
2842             auto list = CSSValueList::createCommaSeparated();
2843             for (auto* currLayer = &amp;layers; currLayer; currLayer = currLayer-&gt;next())
2844                 list-&gt;append(cssValuePool.createValue(currLayer-&gt;attachment()));
2845             return WTFMove(list);
2846         }
2847         case CSSPropertyBackgroundClip:
2848         case CSSPropertyBackgroundOrigin:
2849         case CSSPropertyWebkitBackgroundClip:
2850         case CSSPropertyWebkitBackgroundOrigin:
2851         case CSSPropertyWebkitMaskClip:
2852         case CSSPropertyWebkitMaskOrigin: {
2853             auto&amp; layers = (propertyID == CSSPropertyWebkitMaskClip || propertyID == CSSPropertyWebkitMaskOrigin) ? style.maskLayers() : style.backgroundLayers();
2854             bool isClip = propertyID == CSSPropertyBackgroundClip || propertyID == CSSPropertyWebkitBackgroundClip || propertyID == CSSPropertyWebkitMaskClip;
2855             if (!layers.next())
2856                 return cssValuePool.createValue(isClip ? layers.clip() : layers.origin());
2857             auto list = CSSValueList::createCommaSeparated();
2858             for (auto* currLayer = &amp;layers; currLayer; currLayer = currLayer-&gt;next())
2859                 list-&gt;append(cssValuePool.createValue(isClip ? currLayer-&gt;clip() : currLayer-&gt;origin()));
2860             return WTFMove(list);
2861         }
2862         case CSSPropertyBackgroundPosition:
2863         case CSSPropertyWebkitMaskPosition: {
2864             auto&amp; layers = propertyID == CSSPropertyWebkitMaskPosition ? style.maskLayers() : style.backgroundLayers();
2865             if (!layers.next())
2866                 return createPositionListForLayer(propertyID, layers, style);
2867 
2868             auto list = CSSValueList::createCommaSeparated();
2869             for (auto* currLayer = &amp;layers; currLayer; currLayer = currLayer-&gt;next())
2870                 list-&gt;append(createPositionListForLayer(propertyID, *currLayer, style));
2871             return WTFMove(list);
2872         }
2873         case CSSPropertyBackgroundPositionX:
2874         case CSSPropertyWebkitMaskPositionX: {
2875             auto&amp; layers = propertyID == CSSPropertyWebkitMaskPositionX ? style.maskLayers() : style.backgroundLayers();
2876             if (!layers.next())
2877                 return cssValuePool.createValue(layers.xPosition());
2878 
2879             auto list = CSSValueList::createCommaSeparated();
2880             for (auto* currLayer = &amp;layers; currLayer; currLayer = currLayer-&gt;next())
2881                 list-&gt;append(cssValuePool.createValue(currLayer-&gt;xPosition()));
2882 
2883             return WTFMove(list);
2884         }
2885         case CSSPropertyBackgroundPositionY:
2886         case CSSPropertyWebkitMaskPositionY: {
2887             auto&amp; layers = propertyID == CSSPropertyWebkitMaskPositionY ? style.maskLayers() : style.backgroundLayers();
2888             if (!layers.next())
2889                 return cssValuePool.createValue(layers.yPosition());
2890 
2891             auto list = CSSValueList::createCommaSeparated();
2892             for (auto* currLayer = &amp;layers; currLayer; currLayer = currLayer-&gt;next())
2893                 list-&gt;append(cssValuePool.createValue(currLayer-&gt;yPosition()));
2894 
2895             return WTFMove(list);
2896         }
2897         case CSSPropertyBorderCollapse:
2898             if (style.borderCollapse() == BorderCollapse::Collapse)
2899                 return cssValuePool.createIdentifierValue(CSSValueCollapse);
2900             return cssValuePool.createIdentifierValue(CSSValueSeparate);
2901         case CSSPropertyBorderSpacing: {
2902             auto list = CSSValueList::createSpaceSeparated();
2903             list-&gt;append(zoomAdjustedPixelValue(style.horizontalBorderSpacing(), style));
2904             list-&gt;append(zoomAdjustedPixelValue(style.verticalBorderSpacing(), style));
2905             return WTFMove(list);
2906         }
2907         case CSSPropertyWebkitBorderHorizontalSpacing:
2908             return zoomAdjustedPixelValue(style.horizontalBorderSpacing(), style);
2909         case CSSPropertyWebkitBorderVerticalSpacing:
2910             return zoomAdjustedPixelValue(style.verticalBorderSpacing(), style);
2911         case CSSPropertyBorderImageSource:
2912             if (style.borderImageSource())
2913                 return style.borderImageSource()-&gt;cssValue();
2914             return cssValuePool.createIdentifierValue(CSSValueNone);
2915         case CSSPropertyBorderTopColor:
2916             return m_allowVisitedStyle ? cssValuePool.createColorValue(style.visitedDependentColor(CSSPropertyBorderTopColor)) : currentColorOrValidColor(&amp;style, style.borderTopColor());
2917         case CSSPropertyBorderRightColor:
2918             return m_allowVisitedStyle ? cssValuePool.createColorValue(style.visitedDependentColor(CSSPropertyBorderRightColor)) : currentColorOrValidColor(&amp;style, style.borderRightColor());
2919         case CSSPropertyBorderBottomColor:
2920             return m_allowVisitedStyle ? cssValuePool.createColorValue(style.visitedDependentColor(CSSPropertyBorderBottomColor)) : currentColorOrValidColor(&amp;style, style.borderBottomColor());
2921         case CSSPropertyBorderLeftColor:
2922             return m_allowVisitedStyle ? cssValuePool.createColorValue(style.visitedDependentColor(CSSPropertyBorderLeftColor)) : currentColorOrValidColor(&amp;style, style.borderLeftColor());
2923         case CSSPropertyBorderTopStyle:
2924             return cssValuePool.createValue(style.borderTopStyle());
2925         case CSSPropertyBorderRightStyle:
2926             return cssValuePool.createValue(style.borderRightStyle());
2927         case CSSPropertyBorderBottomStyle:
2928             return cssValuePool.createValue(style.borderBottomStyle());
2929         case CSSPropertyBorderLeftStyle:
2930             return cssValuePool.createValue(style.borderLeftStyle());
2931         case CSSPropertyBorderTopWidth:
2932             return zoomAdjustedPixelValue(style.borderTopWidth(), style);
2933         case CSSPropertyBorderRightWidth:
2934             return zoomAdjustedPixelValue(style.borderRightWidth(), style);
2935         case CSSPropertyBorderBottomWidth:
2936             return zoomAdjustedPixelValue(style.borderBottomWidth(), style);
2937         case CSSPropertyBorderLeftWidth:
2938             return zoomAdjustedPixelValue(style.borderLeftWidth(), style);
2939         case CSSPropertyBottom:
2940             return positionOffsetValue(style, CSSPropertyBottom, renderer);
2941         case CSSPropertyWebkitBoxAlign:
2942             return cssValuePool.createValue(style.boxAlign());
2943 #if ENABLE(CSS_BOX_DECORATION_BREAK)
2944         case CSSPropertyWebkitBoxDecorationBreak:
2945             if (style.boxDecorationBreak() == BoxDecorationBreak::Slice)
2946                 return cssValuePool.createIdentifierValue(CSSValueSlice);
2947         return cssValuePool.createIdentifierValue(CSSValueClone);
2948 #endif
2949         case CSSPropertyWebkitBoxDirection:
2950             return cssValuePool.createValue(style.boxDirection());
2951         case CSSPropertyWebkitBoxFlex:
2952             return cssValuePool.createValue(style.boxFlex(), CSSPrimitiveValue::CSS_NUMBER);
2953         case CSSPropertyWebkitBoxFlexGroup:
2954             return cssValuePool.createValue(style.boxFlexGroup(), CSSPrimitiveValue::CSS_NUMBER);
2955         case CSSPropertyWebkitBoxLines:
2956             return cssValuePool.createValue(style.boxLines());
2957         case CSSPropertyWebkitBoxOrdinalGroup:
2958             return cssValuePool.createValue(style.boxOrdinalGroup(), CSSPrimitiveValue::CSS_NUMBER);
2959         case CSSPropertyWebkitBoxOrient:
2960             return cssValuePool.createValue(style.boxOrient());
2961         case CSSPropertyWebkitBoxPack:
2962             return cssValuePool.createValue(style.boxPack());
2963         case CSSPropertyWebkitBoxReflect:
2964             return valueForReflection(style.boxReflect(), style);
2965         case CSSPropertyBoxShadow:
2966         case CSSPropertyWebkitBoxShadow:
2967             return valueForShadow(style.boxShadow(), propertyID, style);
2968         case CSSPropertyCaptionSide:
2969             return cssValuePool.createValue(style.captionSide());
2970         case CSSPropertyCaretColor:
2971             return m_allowVisitedStyle ? cssValuePool.createColorValue(style.visitedDependentColor(CSSPropertyCaretColor)) : currentColorOrValidColor(&amp;style, style.caretColor());
2972         case CSSPropertyClear:
2973             return cssValuePool.createValue(style.clear());
2974         case CSSPropertyColor:
2975             return cssValuePool.createColorValue(m_allowVisitedStyle ? style.visitedDependentColor(CSSPropertyColor) : style.color());
2976         case CSSPropertyWebkitPrintColorAdjust:
2977             return cssValuePool.createValue(style.printColorAdjust());
2978         case CSSPropertyWebkitColumnAxis:
2979             return cssValuePool.createValue(style.columnAxis());
2980         case CSSPropertyColumnCount:
2981             if (style.hasAutoColumnCount())
2982                 return cssValuePool.createIdentifierValue(CSSValueAuto);
2983             return cssValuePool.createValue(style.columnCount(), CSSPrimitiveValue::CSS_NUMBER);
2984         case CSSPropertyColumnFill:
2985             return cssValuePool.createValue(style.columnFill());
2986         case CSSPropertyColumnGap:
2987             if (style.columnGap().isNormal())
2988                 return cssValuePool.createIdentifierValue(CSSValueNormal);
2989             return zoomAdjustedPixelValueForLength(style.columnGap().length(), style);
2990         case CSSPropertyRowGap:
2991             if (style.rowGap().isNormal())
2992                 return cssValuePool.createIdentifierValue(CSSValueNormal);
2993             return zoomAdjustedPixelValueForLength(style.rowGap().length(), style);
2994         case CSSPropertyWebkitColumnProgression:
2995             return cssValuePool.createValue(style.columnProgression());
2996         case CSSPropertyColumnRuleColor:
2997             return m_allowVisitedStyle ? cssValuePool.createColorValue(style.visitedDependentColor(CSSPropertyOutlineColor)) : currentColorOrValidColor(&amp;style, style.columnRuleColor());
2998         case CSSPropertyColumnRuleStyle:
2999             return cssValuePool.createValue(style.columnRuleStyle());
3000         case CSSPropertyColumnRuleWidth:
3001             return zoomAdjustedPixelValue(style.columnRuleWidth(), style);
3002         case CSSPropertyColumnSpan:
3003             return cssValuePool.createIdentifierValue(style.columnSpan() == ColumnSpan::All ? CSSValueAll : CSSValueNone);
3004         case CSSPropertyWebkitColumnBreakAfter:
3005             return cssValuePool.createValue(convertToColumnBreak(style.breakAfter()));
3006         case CSSPropertyWebkitColumnBreakBefore:
3007             return cssValuePool.createValue(convertToColumnBreak(style.breakBefore()));
3008         case CSSPropertyWebkitColumnBreakInside:
3009             return cssValuePool.createValue(convertToColumnBreak(style.breakInside()));
3010         case CSSPropertyColumnWidth:
3011             if (style.hasAutoColumnWidth())
3012                 return cssValuePool.createIdentifierValue(CSSValueAuto);
3013             return zoomAdjustedPixelValue(style.columnWidth(), style);
3014         case CSSPropertyTabSize:
3015             return cssValuePool.createValue(style.tabSize(), CSSPrimitiveValue::CSS_NUMBER);
3016         case CSSPropertyCursor: {
3017             RefPtr&lt;CSSValueList&gt; list;
3018             auto* cursors = style.cursors();
3019             if (cursors &amp;&amp; cursors-&gt;size() &gt; 0) {
3020                 list = CSSValueList::createCommaSeparated();
3021                 for (unsigned i = 0; i &lt; cursors-&gt;size(); ++i)
3022                     if (StyleImage* image = cursors-&gt;at(i).image())
3023                         list-&gt;append(image-&gt;cssValue());
3024             }
3025             auto value = cssValuePool.createValue(style.cursor());
3026             if (list) {
3027                 list-&gt;append(WTFMove(value));
3028                 return list;
3029             }
3030             return WTFMove(value);
3031         }
3032 #if ENABLE(CURSOR_VISIBILITY)
3033         case CSSPropertyWebkitCursorVisibility:
3034             return cssValuePool.createValue(style.cursorVisibility());
3035 #endif
3036         case CSSPropertyDirection:
3037             return cssValuePool.createValue(style.direction());
3038         case CSSPropertyDisplay:
3039             return cssValuePool.createValue(style.display());
3040         case CSSPropertyEmptyCells:
3041             return cssValuePool.createValue(style.emptyCells());
3042         case CSSPropertyAlignContent:
3043             return valueForContentPositionAndDistributionWithOverflowAlignment(style.alignContent());
3044         case CSSPropertyAlignItems:
3045             return valueForItemPositionWithOverflowAlignment(style.alignItems());
3046         case CSSPropertyAlignSelf:
3047             return valueForItemPositionWithOverflowAlignment(style.alignSelf());
3048         case CSSPropertyFlex:
3049             return getCSSPropertyValuesForShorthandProperties(flexShorthand());
3050         case CSSPropertyFlexBasis:
3051             return cssValuePool.createValue(style.flexBasis(), style);
3052         case CSSPropertyFlexDirection:
3053             return cssValuePool.createValue(style.flexDirection());
3054         case CSSPropertyFlexFlow:
3055             return getCSSPropertyValuesForShorthandProperties(flexFlowShorthand());
3056         case CSSPropertyFlexGrow:
3057             return cssValuePool.createValue(style.flexGrow());
3058         case CSSPropertyFlexShrink:
3059             return cssValuePool.createValue(style.flexShrink());
3060         case CSSPropertyFlexWrap:
3061             return cssValuePool.createValue(style.flexWrap());
3062         case CSSPropertyJustifyContent:
3063             return valueForContentPositionAndDistributionWithOverflowAlignment(style.justifyContent());
3064         case CSSPropertyJustifyItems:
3065             return valueForItemPositionWithOverflowAlignment(style.justifyItems());
3066         case CSSPropertyJustifySelf:
3067             return valueForItemPositionWithOverflowAlignment(style.justifySelf());
3068         case CSSPropertyPlaceContent:
3069             return getCSSPropertyValuesForShorthandProperties(placeContentShorthand());
3070         case CSSPropertyPlaceItems:
3071             return getCSSPropertyValuesForShorthandProperties(placeItemsShorthand());
3072         case CSSPropertyPlaceSelf:
3073             return getCSSPropertyValuesForShorthandProperties(placeSelfShorthand());
3074         case CSSPropertyOrder:
3075             return cssValuePool.createValue(style.order(), CSSPrimitiveValue::CSS_NUMBER);
3076         case CSSPropertyFloat:
3077             if (style.display() != DisplayType::None &amp;&amp; style.hasOutOfFlowPosition())
3078                 return cssValuePool.createIdentifierValue(CSSValueNone);
3079             return cssValuePool.createValue(style.floating());
3080         case CSSPropertyFont: {
3081             auto computedFont = fontShorthandValueForSelectionProperties(style.fontDescription());
3082             computedFont-&gt;size = fontSizeFromStyle(style);
3083             computedFont-&gt;lineHeight = lineHeightFromStyle(style);
3084             computedFont-&gt;family = fontFamilyListFromStyle(style);
3085             return WTFMove(computedFont);
3086         }
3087         case CSSPropertyFontFamily:
3088             return fontFamilyFromStyle(style);
3089         case CSSPropertyFontSize:
3090             return fontSizeFromStyle(style);
3091         case CSSPropertyFontStyle:
3092             return fontStyleFromStyle(style);
3093         case CSSPropertyFontStretch:
3094             return fontStretchFromStyle(style);
3095         case CSSPropertyFontVariant:
3096             return fontVariantFromStyle(style);
3097         case CSSPropertyFontWeight:
3098             return fontWeightFromStyle(style);
3099         case CSSPropertyFontSynthesis:
3100             return fontSynthesisFromStyle(style);
3101         case CSSPropertyFontFeatureSettings: {
3102             const FontFeatureSettings&amp; featureSettings = style.fontDescription().featureSettings();
3103             if (!featureSettings.size())
3104                 return cssValuePool.createIdentifierValue(CSSValueNormal);
3105             auto list = CSSValueList::createCommaSeparated();
3106             for (auto&amp; feature : featureSettings)
3107                 list-&gt;append(CSSFontFeatureValue::create(FontTag(feature.tag()), feature.value()));
3108             return WTFMove(list);
3109         }
3110 #if ENABLE(VARIATION_FONTS)
3111         case CSSPropertyFontVariationSettings: {
3112             const FontVariationSettings&amp; variationSettings = style.fontDescription().variationSettings();
3113             if (variationSettings.isEmpty())
3114                 return cssValuePool.createIdentifierValue(CSSValueNormal);
3115             auto list = CSSValueList::createCommaSeparated();
3116             for (auto&amp; feature : variationSettings)
3117                 list-&gt;append(CSSFontVariationValue::create(feature.tag(), feature.value()));
3118             return WTFMove(list);
3119         }
3120         case CSSPropertyFontOpticalSizing:
3121             return cssValuePool.createValue(style.fontDescription().opticalSizing());
3122 #endif
3123         case CSSPropertyGridAutoFlow: {
3124             auto list = CSSValueList::createSpaceSeparated();
3125             ASSERT(style.isGridAutoFlowDirectionRow() || style.isGridAutoFlowDirectionColumn());
3126             if (style.isGridAutoFlowDirectionRow())
3127                 list-&gt;append(cssValuePool.createIdentifierValue(CSSValueRow));
3128             else
3129                 list-&gt;append(cssValuePool.createIdentifierValue(CSSValueColumn));
3130 
3131             if (style.isGridAutoFlowAlgorithmDense())
3132                 list-&gt;append(cssValuePool.createIdentifierValue(CSSValueDense));
3133 
3134             return WTFMove(list);
3135         }
3136 
3137         // Specs mention that getComputedStyle() should return the used value of the property instead of the computed
3138         // one for grid-template-{rows|columns} but not for the grid-auto-{rows|columns} as things like
3139         // grid-auto-columns: 2fr; cannot be resolved to a value in pixels as the &#39;2fr&#39; means very different things
3140         // depending on the size of the explicit grid or the number of implicit tracks added to the grid. See
3141         // http://lists.w3.org/Archives/Public/www-style/2013Nov/0014.html
3142         case CSSPropertyGridAutoColumns:
3143             return valueForGridTrackSizeList(ForColumns, style);
3144         case CSSPropertyGridAutoRows:
3145             return valueForGridTrackSizeList(ForRows, style);
3146 
3147         case CSSPropertyGridTemplateColumns:
3148             return valueForGridTrackList(ForColumns, renderer, style);
3149         case CSSPropertyGridTemplateRows:
3150             return valueForGridTrackList(ForRows, renderer, style);
3151 
3152         case CSSPropertyGridColumnStart:
3153             return valueForGridPosition(style.gridItemColumnStart());
3154         case CSSPropertyGridColumnEnd:
3155             return valueForGridPosition(style.gridItemColumnEnd());
3156         case CSSPropertyGridRowStart:
3157             return valueForGridPosition(style.gridItemRowStart());
3158         case CSSPropertyGridRowEnd:
3159             return valueForGridPosition(style.gridItemRowEnd());
3160         case CSSPropertyGridArea:
3161             return getCSSPropertyValuesForGridShorthand(gridAreaShorthand());
3162         case CSSPropertyGridTemplate:
3163             return getCSSPropertyValuesForGridShorthand(gridTemplateShorthand());
3164         case CSSPropertyGrid:
3165             return getCSSPropertyValuesForGridShorthand(gridShorthand());
3166         case CSSPropertyGridColumn:
3167             return getCSSPropertyValuesForGridShorthand(gridColumnShorthand());
3168         case CSSPropertyGridRow:
3169             return getCSSPropertyValuesForGridShorthand(gridRowShorthand());
3170         case CSSPropertyGridTemplateAreas:
3171             if (!style.namedGridAreaRowCount()) {
3172                 ASSERT(!style.namedGridAreaColumnCount());
3173                 return cssValuePool.createIdentifierValue(CSSValueNone);
3174             }
3175             return CSSGridTemplateAreasValue::create(style.namedGridArea(), style.namedGridAreaRowCount(), style.namedGridAreaColumnCount());
3176         case CSSPropertyGap:
3177             return getCSSPropertyValuesForShorthandProperties(gapShorthand());
3178         case CSSPropertyHeight:
3179             if (renderer &amp;&amp; !renderer-&gt;isRenderSVGModelObject()) {
3180                 // According to http://www.w3.org/TR/CSS2/visudet.html#the-height-property,
3181                 // the &quot;height&quot; property does not apply for non-replaced inline elements.
3182                 if (isNonReplacedInline(*renderer))
3183                     return cssValuePool.createIdentifierValue(CSSValueAuto);
3184                 return zoomAdjustedPixelValue(sizingBox(*renderer).height(), style);
3185             }
3186             return zoomAdjustedPixelValueForLength(style.height(), style);
3187         case CSSPropertyWebkitHyphens:
3188             return cssValuePool.createValue(style.hyphens());
3189         case CSSPropertyWebkitHyphenateCharacter:
3190             if (style.hyphenationString().isNull())
3191                 return cssValuePool.createIdentifierValue(CSSValueAuto);
3192             return cssValuePool.createValue(style.hyphenationString(), CSSPrimitiveValue::CSS_STRING);
3193         case CSSPropertyWebkitHyphenateLimitAfter:
3194             if (style.hyphenationLimitAfter() &lt; 0)
3195                 return CSSPrimitiveValue::createIdentifier(CSSValueAuto);
3196             return CSSPrimitiveValue::create(style.hyphenationLimitAfter(), CSSPrimitiveValue::CSS_NUMBER);
3197         case CSSPropertyWebkitHyphenateLimitBefore:
3198             if (style.hyphenationLimitBefore() &lt; 0)
3199                 return CSSPrimitiveValue::createIdentifier(CSSValueAuto);
3200             return CSSPrimitiveValue::create(style.hyphenationLimitBefore(), CSSPrimitiveValue::CSS_NUMBER);
3201         case CSSPropertyWebkitHyphenateLimitLines:
3202             if (style.hyphenationLimitLines() &lt; 0)
3203                 return CSSPrimitiveValue::createIdentifier(CSSValueNoLimit);
3204             return CSSPrimitiveValue::create(style.hyphenationLimitLines(), CSSPrimitiveValue::CSS_NUMBER);
3205         case CSSPropertyWebkitBorderFit:
3206             if (style.borderFit() == BorderFit::Border)
3207                 return cssValuePool.createIdentifierValue(CSSValueBorder);
3208             return cssValuePool.createIdentifierValue(CSSValueLines);
3209 #if ENABLE(CSS_IMAGE_ORIENTATION)
3210         case CSSPropertyImageOrientation:
3211             return cssValuePool.createValue(style.imageOrientation());
3212 #endif
3213         case CSSPropertyImageRendering:
3214             return CSSPrimitiveValue::create(style.imageRendering());
3215 #if ENABLE(CSS_IMAGE_RESOLUTION)
3216         case CSSPropertyImageResolution:
3217             return cssValuePool.createValue(style.imageResolution(), CSSPrimitiveValue::CSS_DPPX);
3218 #endif
3219         case CSSPropertyLeft:
3220             return positionOffsetValue(style, CSSPropertyLeft, renderer);
3221         case CSSPropertyLetterSpacing:
3222             if (!style.letterSpacing())
3223                 return cssValuePool.createIdentifierValue(CSSValueNormal);
3224             return zoomAdjustedPixelValue(style.letterSpacing(), style);
3225         case CSSPropertyWebkitLineClamp:
3226             if (style.lineClamp().isNone())
3227                 return cssValuePool.createIdentifierValue(CSSValueNone);
3228             return cssValuePool.createValue(style.lineClamp().value(), style.lineClamp().isPercentage() ? CSSPrimitiveValue::CSS_PERCENTAGE : CSSPrimitiveValue::CSS_NUMBER);
3229         case CSSPropertyLineHeight:
3230             return lineHeightFromStyle(style);
3231         case CSSPropertyListStyleImage:
3232             if (style.listStyleImage())
3233                 return style.listStyleImage()-&gt;cssValue();
3234             return cssValuePool.createIdentifierValue(CSSValueNone);
3235         case CSSPropertyListStylePosition:
3236             return cssValuePool.createValue(style.listStylePosition());
3237         case CSSPropertyListStyleType:
3238             return cssValuePool.createValue(style.listStyleType());
3239         case CSSPropertyWebkitLocale:
3240             if (style.locale().isNull())
3241                 return cssValuePool.createIdentifierValue(CSSValueAuto);
3242             return cssValuePool.createValue(style.locale(), CSSPrimitiveValue::CSS_STRING);
3243         case CSSPropertyMarginTop:
3244             return zoomAdjustedPaddingOrMarginPixelValue&lt;&amp;RenderStyle::marginTop, &amp;RenderBoxModelObject::marginTop&gt;(style, renderer);
3245         case CSSPropertyMarginRight: {
3246             Length marginRight = style.marginRight();
3247             if (marginRight.isFixed() || !is&lt;RenderBox&gt;(renderer))
3248                 return zoomAdjustedPixelValueForLength(marginRight, style);
3249             float value;
3250             if (marginRight.isPercentOrCalculated()) {
3251                 // RenderBox gives a marginRight() that is the distance between the right-edge of the child box
3252                 // and the right-edge of the containing box, when display == DisplayType::Block. Let&#39;s calculate the absolute
3253                 // value of the specified margin-right % instead of relying on RenderBox&#39;s marginRight() value.
3254                 value = minimumValueForLength(marginRight, downcast&lt;RenderBox&gt;(*renderer).containingBlockLogicalWidthForContent());
3255             } else
3256                 value = downcast&lt;RenderBox&gt;(*renderer).marginRight();
3257             return zoomAdjustedPixelValue(value, style);
3258         }
3259         case CSSPropertyMarginBottom:
3260             return zoomAdjustedPaddingOrMarginPixelValue&lt;&amp;RenderStyle::marginBottom, &amp;RenderBoxModelObject::marginBottom&gt;(style, renderer);
3261         case CSSPropertyMarginLeft:
3262             return zoomAdjustedPaddingOrMarginPixelValue&lt;&amp;RenderStyle::marginLeft, &amp;RenderBoxModelObject::marginLeft&gt;(style, renderer);
3263         case CSSPropertyWebkitMarqueeDirection:
3264             return cssValuePool.createValue(style.marqueeDirection());
3265         case CSSPropertyWebkitMarqueeIncrement:
3266             return cssValuePool.createValue(style.marqueeIncrement());
3267         case CSSPropertyWebkitMarqueeRepetition:
3268             if (style.marqueeLoopCount() &lt; 0)
3269                 return cssValuePool.createIdentifierValue(CSSValueInfinite);
3270             return cssValuePool.createValue(style.marqueeLoopCount(), CSSPrimitiveValue::CSS_NUMBER);
3271         case CSSPropertyWebkitMarqueeStyle:
3272             return cssValuePool.createValue(style.marqueeBehavior());
3273         case CSSPropertyWebkitUserModify:
3274             return cssValuePool.createValue(style.userModify());
3275         case CSSPropertyMaxHeight: {
3276             const Length&amp; maxHeight = style.maxHeight();
3277             if (maxHeight.isUndefined())
3278                 return cssValuePool.createIdentifierValue(CSSValueNone);
3279             return zoomAdjustedPixelValueForLength(maxHeight, style);
3280         }
3281         case CSSPropertyMaxWidth: {
3282             const Length&amp; maxWidth = style.maxWidth();
3283             if (maxWidth.isUndefined())
3284                 return cssValuePool.createIdentifierValue(CSSValueNone);
3285             return zoomAdjustedPixelValueForLength(maxWidth, style);
3286         }
3287         case CSSPropertyMinHeight:
3288             if (style.minHeight().isAuto()) {
3289                 auto* styledElement = this-&gt;styledElement();
3290                 if (styledElement &amp;&amp; isFlexOrGrid(styledElement-&gt;parentNode()))
3291                     return cssValuePool.createIdentifierValue(CSSValueAuto);
3292                 return zoomAdjustedPixelValue(0, style);
3293             }
3294             return zoomAdjustedPixelValueForLength(style.minHeight(), style);
3295         case CSSPropertyMinWidth:
3296             if (style.minWidth().isAuto()) {
3297                 auto* styledElement = this-&gt;styledElement();
3298                 if (styledElement &amp;&amp; isFlexOrGrid(styledElement-&gt;parentNode()))
3299                     return cssValuePool.createIdentifierValue(CSSValueAuto);
3300                 return zoomAdjustedPixelValue(0, style);
3301             }
3302             return zoomAdjustedPixelValueForLength(style.minWidth(), style);
3303         case CSSPropertyObjectFit:
3304             return cssValuePool.createValue(style.objectFit());
3305         case CSSPropertyObjectPosition: {
3306             auto list = CSSValueList::createSpaceSeparated();
3307             list-&gt;append(zoomAdjustedPixelValueForLength(style.objectPosition().x(), style));
3308             list-&gt;append(zoomAdjustedPixelValueForLength(style.objectPosition().y(), style));
3309             return WTFMove(list);
3310         }
3311         case CSSPropertyOpacity:
3312             return cssValuePool.createValue(style.opacity(), CSSPrimitiveValue::CSS_NUMBER);
3313         case CSSPropertyOrphans:
3314             if (style.hasAutoOrphans())
3315                 return cssValuePool.createIdentifierValue(CSSValueAuto);
3316             return cssValuePool.createValue(style.orphans(), CSSPrimitiveValue::CSS_NUMBER);
3317         case CSSPropertyOutlineColor:
3318             return m_allowVisitedStyle ? cssValuePool.createColorValue(style.visitedDependentColor(CSSPropertyOutlineColor)) : currentColorOrValidColor(&amp;style, style.outlineColor());
3319         case CSSPropertyOutlineOffset:
3320             return zoomAdjustedPixelValue(style.outlineOffset(), style);
3321         case CSSPropertyOutlineStyle:
3322             if (style.outlineStyleIsAuto() == OutlineIsAuto::On)
3323                 return cssValuePool.createIdentifierValue(CSSValueAuto);
3324             return cssValuePool.createValue(style.outlineStyle());
3325         case CSSPropertyOutlineWidth:
3326             return zoomAdjustedPixelValue(style.outlineWidth(), style);
3327         case CSSPropertyOverflow:
3328             return cssValuePool.createValue(std::max(style.overflowX(), style.overflowY()));
3329         case CSSPropertyOverflowWrap:
3330             return cssValuePool.createValue(style.overflowWrap());
3331         case CSSPropertyOverflowX:
3332             return cssValuePool.createValue(style.overflowX());
3333         case CSSPropertyOverflowY:
3334             return cssValuePool.createValue(style.overflowY());
3335         case CSSPropertyPaddingTop:
3336             return zoomAdjustedPaddingOrMarginPixelValue&lt;&amp;RenderStyle::paddingTop, &amp;RenderBoxModelObject::computedCSSPaddingTop&gt;(style, renderer);
3337         case CSSPropertyPaddingRight:
3338             return zoomAdjustedPaddingOrMarginPixelValue&lt;&amp;RenderStyle::paddingRight, &amp;RenderBoxModelObject::computedCSSPaddingRight&gt;(style, renderer);
3339         case CSSPropertyPaddingBottom:
3340             return zoomAdjustedPaddingOrMarginPixelValue&lt;&amp;RenderStyle::paddingBottom, &amp;RenderBoxModelObject::computedCSSPaddingBottom&gt;(style, renderer);
3341         case CSSPropertyPaddingLeft:
3342             return zoomAdjustedPaddingOrMarginPixelValue&lt;&amp;RenderStyle::paddingLeft, &amp;RenderBoxModelObject::computedCSSPaddingLeft&gt;(style, renderer);
3343         case CSSPropertyPageBreakAfter:
3344             return cssValuePool.createValue(convertToPageBreak(style.breakAfter()));
3345         case CSSPropertyPageBreakBefore:
3346             return cssValuePool.createValue(convertToPageBreak(style.breakBefore()));
3347         case CSSPropertyPageBreakInside:
3348             return cssValuePool.createValue(convertToPageBreak(style.breakInside()));
3349         case CSSPropertyBreakAfter:
3350             return cssValuePool.createValue(style.breakAfter());
3351         case CSSPropertyBreakBefore:
3352             return cssValuePool.createValue(style.breakBefore());
3353         case CSSPropertyBreakInside:
3354             return cssValuePool.createValue(style.breakInside());
3355         case CSSPropertyHangingPunctuation:
3356             return hangingPunctuationToCSSValue(style.hangingPunctuation());
3357         case CSSPropertyPosition:
3358             return cssValuePool.createValue(style.position());
3359         case CSSPropertyRight:
3360             return positionOffsetValue(style, CSSPropertyRight, renderer);
3361         case CSSPropertyWebkitRubyPosition:
3362             return cssValuePool.createValue(style.rubyPosition());
3363         case CSSPropertyTableLayout:
3364             return cssValuePool.createValue(style.tableLayout());
3365         case CSSPropertyTextAlign:
3366             return cssValuePool.createValue(style.textAlign());
3367         case CSSPropertyTextDecoration:
3368             return renderTextDecorationFlagsToCSSValue(style.textDecoration());
3369 #if ENABLE(CSS3_TEXT)
3370         case CSSPropertyWebkitTextAlignLast:
3371             return cssValuePool.createValue(style.textAlignLast());
3372         case CSSPropertyWebkitTextJustify:
3373             return cssValuePool.createValue(style.textJustify());
3374 #endif // CSS3_TEXT
3375         case CSSPropertyWebkitTextDecoration:
3376             return getCSSPropertyValuesForShorthandProperties(webkitTextDecorationShorthand());
3377         case CSSPropertyTextDecorationLine:
3378             return renderTextDecorationFlagsToCSSValue(style.textDecoration());
3379         case CSSPropertyTextDecorationStyle:
3380             return renderTextDecorationStyleFlagsToCSSValue(style.textDecorationStyle());
3381         case CSSPropertyTextDecorationColor:
3382             return currentColorOrValidColor(&amp;style, style.textDecorationColor());
3383         case CSSPropertyTextDecorationSkip:
3384             return renderTextDecorationSkipFlagsToCSSValue(style.textDecorationSkip());
3385         case CSSPropertyTextUnderlinePosition:
3386             return cssValuePool.createValue(style.textUnderlinePosition());
3387         case CSSPropertyTextUnderlineOffset:
3388             return textUnderlineOffsetToCSSValue(style.textUnderlineOffset());
3389         case CSSPropertyTextDecorationThickness:
3390             return textDecorationThicknessToCSSValue(style.textDecorationThickness());
3391         case CSSPropertyWebkitTextDecorationsInEffect:
3392             return renderTextDecorationFlagsToCSSValue(style.textDecorationsInEffect());
3393         case CSSPropertyWebkitTextFillColor:
3394             return currentColorOrValidColor(&amp;style, style.textFillColor());
3395         case CSSPropertyWebkitTextEmphasisColor:
3396             return currentColorOrValidColor(&amp;style, style.textEmphasisColor());
3397         case CSSPropertyWebkitTextEmphasisPosition:
3398             return renderEmphasisPositionFlagsToCSSValue(style.textEmphasisPosition());
3399         case CSSPropertyWebkitTextEmphasisStyle:
3400             switch (style.textEmphasisMark()) {
3401             case TextEmphasisMark::None:
3402                 return cssValuePool.createIdentifierValue(CSSValueNone);
3403             case TextEmphasisMark::Custom:
3404                 return cssValuePool.createValue(style.textEmphasisCustomMark(), CSSPrimitiveValue::CSS_STRING);
3405             case TextEmphasisMark::Auto:
3406                 ASSERT_NOT_REACHED();
3407 #if ASSERT_DISABLED
3408                 FALLTHROUGH;
3409 #endif
3410             case TextEmphasisMark::Dot:
3411             case TextEmphasisMark::Circle:
3412             case TextEmphasisMark::DoubleCircle:
3413             case TextEmphasisMark::Triangle:
3414             case TextEmphasisMark::Sesame:
3415                 auto list = CSSValueList::createSpaceSeparated();
3416                 list-&gt;append(cssValuePool.createValue(style.textEmphasisFill()));
3417                 list-&gt;append(cssValuePool.createValue(style.textEmphasisMark()));
3418                 return WTFMove(list);
3419             }
3420             RELEASE_ASSERT_NOT_REACHED();
3421         case CSSPropertyTextIndent: {
3422             // If CSS3_TEXT is disabled or text-indent has only one value(&lt;length&gt; | &lt;percentage&gt;),
3423             // getPropertyCSSValue() returns CSSValue.
3424             auto textIndent = zoomAdjustedPixelValueForLength(style.textIndent(), style);
3425 #if ENABLE(CSS3_TEXT)
3426             // If CSS3_TEXT is enabled and text-indent has -webkit-each-line or -webkit-hanging,
3427             // getPropertyCSSValue() returns CSSValueList.
3428             if (style.textIndentLine() == TextIndentLine::EachLine || style.textIndentType() == TextIndentType::Hanging) {
3429                 auto list = CSSValueList::createSpaceSeparated();
3430                 list-&gt;append(WTFMove(textIndent));
3431                 if (style.textIndentLine() == TextIndentLine::EachLine)
3432                     list-&gt;append(cssValuePool.createIdentifierValue(CSSValueWebkitEachLine));
3433                 if (style.textIndentType() == TextIndentType::Hanging)
3434                     list-&gt;append(cssValuePool.createIdentifierValue(CSSValueWebkitHanging));
3435                 return WTFMove(list);
3436             }
3437 #endif
3438             return WTFMove(textIndent);
3439         }
3440         case CSSPropertyTextShadow:
3441             return valueForShadow(style.textShadow(), propertyID, style);
3442         case CSSPropertyTextRendering:
3443             return cssValuePool.createValue(style.fontDescription().textRenderingMode());
3444         case CSSPropertyTextOverflow:
3445             if (style.textOverflow() == TextOverflow::Ellipsis)
3446                 return cssValuePool.createIdentifierValue(CSSValueEllipsis);
3447             return cssValuePool.createIdentifierValue(CSSValueClip);
3448         case CSSPropertyWebkitTextSecurity:
3449             return cssValuePool.createValue(style.textSecurity());
3450 #if ENABLE(TEXT_AUTOSIZING)
3451         case CSSPropertyWebkitTextSizeAdjust:
3452             if (style.textSizeAdjust().isAuto())
3453                 return cssValuePool.createIdentifierValue(CSSValueAuto);
3454             if (style.textSizeAdjust().isNone())
3455                 return cssValuePool.createIdentifierValue(CSSValueNone);
3456             return CSSPrimitiveValue::create(style.textSizeAdjust().percentage(), CSSPrimitiveValue::CSS_PERCENTAGE);
3457 #endif
3458         case CSSPropertyWebkitTextStrokeColor:
3459             return currentColorOrValidColor(&amp;style, style.textStrokeColor());
3460         case CSSPropertyWebkitTextStrokeWidth:
3461             return zoomAdjustedPixelValue(style.textStrokeWidth(), style);
3462         case CSSPropertyTextTransform:
3463             return cssValuePool.createValue(style.textTransform());
3464         case CSSPropertyTop:
3465             return positionOffsetValue(style, CSSPropertyTop, renderer);
3466         case CSSPropertyUnicodeBidi:
3467             return cssValuePool.createValue(style.unicodeBidi());
3468         case CSSPropertyVerticalAlign:
3469             switch (style.verticalAlign()) {
3470             case VerticalAlign::Baseline:
3471                 return cssValuePool.createIdentifierValue(CSSValueBaseline);
3472             case VerticalAlign::Middle:
3473                 return cssValuePool.createIdentifierValue(CSSValueMiddle);
3474             case VerticalAlign::Sub:
3475                 return cssValuePool.createIdentifierValue(CSSValueSub);
3476             case VerticalAlign::Super:
3477                 return cssValuePool.createIdentifierValue(CSSValueSuper);
3478             case VerticalAlign::TextTop:
3479                 return cssValuePool.createIdentifierValue(CSSValueTextTop);
3480             case VerticalAlign::TextBottom:
3481                 return cssValuePool.createIdentifierValue(CSSValueTextBottom);
3482             case VerticalAlign::Top:
3483                 return cssValuePool.createIdentifierValue(CSSValueTop);
3484             case VerticalAlign::Bottom:
3485                 return cssValuePool.createIdentifierValue(CSSValueBottom);
3486             case VerticalAlign::BaselineMiddle:
3487                 return cssValuePool.createIdentifierValue(CSSValueWebkitBaselineMiddle);
3488             case VerticalAlign::Length:
3489                 return cssValuePool.createValue(style.verticalAlignLength());
3490             }
3491             ASSERT_NOT_REACHED();
3492             return nullptr;
3493         case CSSPropertyVisibility:
3494             return cssValuePool.createValue(style.visibility());
3495         case CSSPropertyWhiteSpace:
3496             return cssValuePool.createValue(style.whiteSpace());
3497         case CSSPropertyWidows:
3498             if (style.hasAutoWidows())
3499                 return cssValuePool.createIdentifierValue(CSSValueAuto);
3500             return cssValuePool.createValue(style.widows(), CSSPrimitiveValue::CSS_NUMBER);
3501         case CSSPropertyWidth:
3502             if (renderer &amp;&amp; !renderer-&gt;isRenderSVGModelObject()) {
3503                 // According to http://www.w3.org/TR/CSS2/visudet.html#the-width-property,
3504                 // the &quot;width&quot; property does not apply for non-replaced inline elements.
3505                 if (isNonReplacedInline(*renderer))
3506                     return cssValuePool.createIdentifierValue(CSSValueAuto);
3507                 return zoomAdjustedPixelValue(sizingBox(*renderer).width(), style);
3508             }
3509             return zoomAdjustedPixelValueForLength(style.width(), style);
3510         case CSSPropertyWillChange:
3511             return willChangePropertyValue(style.willChange());
3512         case CSSPropertyWordBreak:
3513             return cssValuePool.createValue(style.wordBreak());
3514         case CSSPropertyWordSpacing:
3515             return zoomAdjustedPixelValue(style.fontCascade().wordSpacing(), style);
3516         case CSSPropertyWordWrap:
3517             return cssValuePool.createValue(style.overflowWrap());
3518         case CSSPropertyLineBreak:
3519             return cssValuePool.createValue(style.lineBreak());
3520         case CSSPropertyWebkitNbspMode:
3521             return cssValuePool.createValue(style.nbspMode());
3522         case CSSPropertyResize:
3523             return cssValuePool.createValue(style.resize());
3524         case CSSPropertyWebkitFontKerning:
3525             return cssValuePool.createValue(style.fontDescription().kerning());
3526         case CSSPropertyWebkitFontSmoothing:
3527             return cssValuePool.createValue(style.fontDescription().fontSmoothing());
3528         case CSSPropertyFontVariantLigatures:
3529             return fontVariantLigaturesPropertyValue(style.fontDescription().variantCommonLigatures(), style.fontDescription().variantDiscretionaryLigatures(), style.fontDescription().variantHistoricalLigatures(), style.fontDescription().variantContextualAlternates());
3530         case CSSPropertyFontVariantPosition:
3531             return fontVariantPositionPropertyValue(style.fontDescription().variantPosition());
3532         case CSSPropertyFontVariantCaps:
3533             return fontVariantCapsPropertyValue(style.fontDescription().variantCaps());
3534         case CSSPropertyFontVariantNumeric:
3535             return fontVariantNumericPropertyValue(style.fontDescription().variantNumericFigure(), style.fontDescription().variantNumericSpacing(), style.fontDescription().variantNumericFraction(), style.fontDescription().variantNumericOrdinal(), style.fontDescription().variantNumericSlashedZero());
3536         case CSSPropertyFontVariantAlternates:
3537             return fontVariantAlternatesPropertyValue(style.fontDescription().variantAlternates());
3538         case CSSPropertyFontVariantEastAsian:
3539             return fontVariantEastAsianPropertyValue(style.fontDescription().variantEastAsianVariant(), style.fontDescription().variantEastAsianWidth(), style.fontDescription().variantEastAsianRuby());
3540         case CSSPropertyZIndex:
3541             if (style.hasAutoZIndex())
3542                 return cssValuePool.createIdentifierValue(CSSValueAuto);
3543             return cssValuePool.createValue(style.zIndex(), CSSPrimitiveValue::CSS_NUMBER);
3544         case CSSPropertyZoom:
3545             return cssValuePool.createValue(style.zoom(), CSSPrimitiveValue::CSS_NUMBER);
3546         case CSSPropertyBoxSizing:
3547             if (style.boxSizing() == BoxSizing::ContentBox)
3548                 return cssValuePool.createIdentifierValue(CSSValueContentBox);
3549             return cssValuePool.createIdentifierValue(CSSValueBorderBox);
3550 #if ENABLE(DASHBOARD_SUPPORT)
3551         case CSSPropertyWebkitDashboardRegion:
3552         {
3553             const Vector&lt;StyleDashboardRegion&gt;&amp; regions = style.dashboardRegions();
3554             unsigned count = regions.size();
3555             if (count == 1 &amp;&amp; regions[0].type == StyleDashboardRegion::None)
3556                 return cssValuePool.createIdentifierValue(CSSValueNone);
3557 
3558             RefPtr&lt;DashboardRegion&gt; firstRegion;
3559             DashboardRegion* previousRegion = nullptr;
3560             for (unsigned i = 0; i &lt; count; i++) {
3561                 auto region = DashboardRegion::create();
3562                 StyleDashboardRegion styleRegion = regions[i];
3563 
3564                 region-&gt;m_label = styleRegion.label;
3565                 LengthBox offset = styleRegion.offset;
3566                 region-&gt;setTop(zoomAdjustedPixelValue(offset.top().value(), style));
3567                 region-&gt;setRight(zoomAdjustedPixelValue(offset.right().value(), style));
3568                 region-&gt;setBottom(zoomAdjustedPixelValue(offset.bottom().value(), style));
3569                 region-&gt;setLeft(zoomAdjustedPixelValue(offset.left().value(), style));
3570                 region-&gt;m_isRectangle = (styleRegion.type == StyleDashboardRegion::Rectangle);
3571                 region-&gt;m_isCircle = (styleRegion.type == StyleDashboardRegion::Circle);
3572 
3573                 if (previousRegion)
3574                     previousRegion-&gt;m_next = region.copyRef();
3575                 else
3576                     firstRegion = region.copyRef();
3577                 previousRegion = region.ptr();
3578             }
3579             return cssValuePool.createValue(WTFMove(firstRegion));
3580         }
3581 #endif
3582         case CSSPropertyAnimationDelay:
3583             return delayValue(style.animations());
3584         case CSSPropertyAnimationDirection: {
3585             auto list = CSSValueList::createCommaSeparated();
3586             const AnimationList* t = style.animations();
3587             if (t) {
3588                 for (size_t i = 0; i &lt; t-&gt;size(); ++i) {
3589                     switch (t-&gt;animation(i).direction()) {
3590                     case Animation::AnimationDirectionNormal:
3591                         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueNormal));
3592                         break;
3593                     case Animation::AnimationDirectionAlternate:
3594                         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueAlternate));
3595                         break;
3596                     case Animation::AnimationDirectionReverse:
3597                         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueReverse));
3598                         break;
3599                     case Animation::AnimationDirectionAlternateReverse:
3600                         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueAlternateReverse));
3601                         break;
3602                     }
3603                 }
3604             } else
3605                 list-&gt;append(cssValuePool.createIdentifierValue(CSSValueNormal));
3606             return WTFMove(list);
3607         }
3608         case CSSPropertyAnimationDuration:
3609             return durationValue(style.animations());
3610         case CSSPropertyAnimationFillMode: {
3611             auto list = CSSValueList::createCommaSeparated();
3612             const AnimationList* t = style.animations();
3613             if (t) {
3614                 for (size_t i = 0; i &lt; t-&gt;size(); ++i) {
3615                     switch (t-&gt;animation(i).fillMode()) {
3616                     case AnimationFillMode::None:
3617                         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueNone));
3618                         break;
3619                     case AnimationFillMode::Forwards:
3620                         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueForwards));
3621                         break;
3622                     case AnimationFillMode::Backwards:
3623                         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueBackwards));
3624                         break;
3625                     case AnimationFillMode::Both:
3626                         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueBoth));
3627                         break;
3628                     }
3629                 }
3630             } else
3631                 list-&gt;append(cssValuePool.createIdentifierValue(CSSValueNone));
3632             return WTFMove(list);
3633         }
3634         case CSSPropertyAnimationIterationCount: {
3635             auto list = CSSValueList::createCommaSeparated();
3636             const AnimationList* t = style.animations();
3637             if (t) {
3638                 for (size_t i = 0; i &lt; t-&gt;size(); ++i) {
3639                     double iterationCount = t-&gt;animation(i).iterationCount();
3640                     if (iterationCount == Animation::IterationCountInfinite)
3641                         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueInfinite));
3642                     else
3643                         list-&gt;append(cssValuePool.createValue(iterationCount, CSSPrimitiveValue::CSS_NUMBER));
3644                 }
3645             } else
3646                 list-&gt;append(cssValuePool.createValue(Animation::initialIterationCount(), CSSPrimitiveValue::CSS_NUMBER));
3647             return WTFMove(list);
3648         }
3649         case CSSPropertyAnimationName: {
3650             auto list = CSSValueList::createCommaSeparated();
3651             const AnimationList* t = style.animations();
3652             if (t) {
3653                 for (size_t i = 0; i &lt; t-&gt;size(); ++i)
3654                     list-&gt;append(cssValuePool.createValue(t-&gt;animation(i).name(), CSSPrimitiveValue::CSS_STRING));
3655             } else
3656                 list-&gt;append(cssValuePool.createIdentifierValue(CSSValueNone));
3657             return WTFMove(list);
3658         }
3659         case CSSPropertyAnimationPlayState: {
3660             auto list = CSSValueList::createCommaSeparated();
3661             const AnimationList* t = style.animations();
3662             if (t) {
3663                 for (size_t i = 0; i &lt; t-&gt;size(); ++i) {
3664                     switch (t-&gt;animation(i).playState()) {
3665                     case AnimationPlayState::Playing:
3666                         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueRunning));
3667                         break;
3668                     case AnimationPlayState::Paused:
3669                         list-&gt;append(cssValuePool.createIdentifierValue(CSSValuePaused));
3670                         break;
3671                     }
3672                 }
3673             } else
3674                 list-&gt;append(cssValuePool.createIdentifierValue(CSSValueRunning));
3675             return WTFMove(list);
3676         }
3677         case CSSPropertyAnimationTimingFunction:
3678             return timingFunctionValue(style.animations());
3679         case CSSPropertyWebkitAppearance:
3680             return cssValuePool.createValue(style.appearance());
3681         case CSSPropertyWebkitAspectRatio:
3682             switch (style.aspectRatioType()) {
3683             case AspectRatioType::Auto:
3684                 return cssValuePool.createIdentifierValue(CSSValueAuto);
3685             case AspectRatioType::FromDimensions:
3686                 return cssValuePool.createIdentifierValue(CSSValueFromDimensions);
3687             case AspectRatioType::FromIntrinsic:
3688                 return cssValuePool.createIdentifierValue(CSSValueFromIntrinsic);
3689             case AspectRatioType::Specified:
3690                 return CSSAspectRatioValue::create(style.aspectRatioNumerator(), style.aspectRatioDenominator());
3691             }
3692             ASSERT_NOT_REACHED();
3693             return nullptr;
3694         case CSSPropertyWebkitBackfaceVisibility:
3695             return cssValuePool.createIdentifierValue((style.backfaceVisibility() == BackfaceVisibility::Hidden) ? CSSValueHidden : CSSValueVisible);
3696         case CSSPropertyWebkitBorderImage:
3697             return valueForNinePieceImage(style.borderImage());
3698         case CSSPropertyBorderImageOutset:
3699             return valueForNinePieceImageQuad(style.borderImage().outset());
3700         case CSSPropertyBorderImageRepeat:
3701             return valueForNinePieceImageRepeat(style.borderImage());
3702         case CSSPropertyBorderImageSlice:
3703             return valueForNinePieceImageSlice(style.borderImage());
3704         case CSSPropertyBorderImageWidth:
3705             return valueForNinePieceImageQuad(style.borderImage().borderSlices());
3706         case CSSPropertyWebkitMaskBoxImage:
3707             return valueForNinePieceImage(style.maskBoxImage());
3708         case CSSPropertyWebkitMaskBoxImageOutset:
3709             return valueForNinePieceImageQuad(style.maskBoxImage().outset());
3710         case CSSPropertyWebkitMaskBoxImageRepeat:
3711             return valueForNinePieceImageRepeat(style.maskBoxImage());
3712         case CSSPropertyWebkitMaskBoxImageSlice:
3713             return valueForNinePieceImageSlice(style.maskBoxImage());
3714         case CSSPropertyWebkitMaskBoxImageWidth:
3715             return valueForNinePieceImageQuad(style.maskBoxImage().borderSlices());
3716         case CSSPropertyWebkitMaskBoxImageSource:
3717             if (style.maskBoxImageSource())
3718                 return style.maskBoxImageSource()-&gt;cssValue();
3719             return cssValuePool.createIdentifierValue(CSSValueNone);
3720         case CSSPropertyWebkitFontSizeDelta:
3721             // Not a real style property -- used by the editing engine -- so has no computed value.
3722             break;
3723         case CSSPropertyWebkitInitialLetter: {
3724             auto drop = !style.initialLetterDrop() ? cssValuePool.createIdentifierValue(CSSValueNormal) : cssValuePool.createValue(style.initialLetterDrop(), CSSPrimitiveValue::CSS_NUMBER);
3725             auto size = !style.initialLetterHeight() ? cssValuePool.createIdentifierValue(CSSValueNormal) : cssValuePool.createValue(style.initialLetterHeight(), CSSPrimitiveValue::CSS_NUMBER);
3726             return cssValuePool.createValue(Pair::create(WTFMove(drop), WTFMove(size)));
3727         }
3728         case CSSPropertyWebkitMarginBottomCollapse:
3729         case CSSPropertyWebkitMarginAfterCollapse:
3730             return cssValuePool.createValue(style.marginAfterCollapse());
3731         case CSSPropertyWebkitMarginTopCollapse:
3732         case CSSPropertyWebkitMarginBeforeCollapse:
3733             return cssValuePool.createValue(style.marginBeforeCollapse());
3734 #if ENABLE(ACCELERATED_OVERFLOW_SCROLLING)
3735         case CSSPropertyWebkitOverflowScrolling:
3736             if (!style.useTouchOverflowScrolling())
3737                 return cssValuePool.createIdentifierValue(CSSValueAuto);
3738             return cssValuePool.createIdentifierValue(CSSValueTouch);
3739 #endif
3740         case CSSPropertyPerspective:
3741             if (!style.hasPerspective())
3742                 return cssValuePool.createIdentifierValue(CSSValueNone);
3743             return zoomAdjustedPixelValue(style.perspective(), style);
3744         case CSSPropertyPerspectiveOrigin: {
3745             auto list = CSSValueList::createSpaceSeparated();
3746             if (renderer) {
3747                 LayoutRect box;
3748                 if (is&lt;RenderBox&gt;(*renderer))
3749                     box = downcast&lt;RenderBox&gt;(*renderer).borderBoxRect();
3750 
3751                 list-&gt;append(zoomAdjustedPixelValue(minimumValueForLength(style.perspectiveOriginX(), box.width()), style));
3752                 list-&gt;append(zoomAdjustedPixelValue(minimumValueForLength(style.perspectiveOriginY(), box.height()), style));
3753             } else {
3754                 list-&gt;append(zoomAdjustedPixelValueForLength(style.perspectiveOriginX(), style));
3755                 list-&gt;append(zoomAdjustedPixelValueForLength(style.perspectiveOriginY(), style));
3756             }
3757             return WTFMove(list);
3758         }
3759         case CSSPropertyWebkitRtlOrdering:
3760             return cssValuePool.createIdentifierValue(style.rtlOrdering() == Order::Visual ? CSSValueVisual : CSSValueLogical);
3761 #if ENABLE(TOUCH_EVENTS)
3762         case CSSPropertyWebkitTapHighlightColor:
3763             return currentColorOrValidColor(&amp;style, style.tapHighlightColor());
3764 #endif
3765 #if ENABLE(POINTER_EVENTS)
3766         case CSSPropertyTouchAction:
3767             return touchActionFlagsToCSSValue(style.touchActions());
3768 #endif
3769 #if PLATFORM(IOS_FAMILY)
3770         case CSSPropertyWebkitTouchCallout:
3771             return cssValuePool.createIdentifierValue(style.touchCalloutEnabled() ? CSSValueDefault : CSSValueNone);
3772 #endif
3773         case CSSPropertyWebkitUserDrag:
3774             return cssValuePool.createValue(style.userDrag());
3775         case CSSPropertyWebkitUserSelect:
3776             return cssValuePool.createValue(style.userSelect());
3777         case CSSPropertyBorderBottomLeftRadius:
3778             return borderRadiusCornerValue(style.borderBottomLeftRadius(), style);
3779         case CSSPropertyBorderBottomRightRadius:
3780             return borderRadiusCornerValue(style.borderBottomRightRadius(), style);
3781         case CSSPropertyBorderTopLeftRadius:
3782             return borderRadiusCornerValue(style.borderTopLeftRadius(), style);
3783         case CSSPropertyBorderTopRightRadius:
3784             return borderRadiusCornerValue(style.borderTopRightRadius(), style);
3785         case CSSPropertyClip: {
3786             if (!style.hasClip())
3787                 return cssValuePool.createIdentifierValue(CSSValueAuto);
3788             auto rect = Rect::create();
3789             rect-&gt;setTop(autoOrZoomAdjustedValue(style.clip().top(), style));
3790             rect-&gt;setRight(autoOrZoomAdjustedValue(style.clip().right(), style));
3791             rect-&gt;setBottom(autoOrZoomAdjustedValue(style.clip().bottom(), style));
3792             rect-&gt;setLeft(autoOrZoomAdjustedValue(style.clip().left(), style));
3793             return cssValuePool.createValue(WTFMove(rect));
3794         }
3795         case CSSPropertySpeakAs:
3796             return speakAsToCSSValue(style.speakAs());
3797         case CSSPropertyTransform:
3798             return computedTransform(renderer, style);
3799         case CSSPropertyTransformBox:
3800             return CSSPrimitiveValue::create(style.transformBox());
3801         case CSSPropertyTransformOrigin: {
3802             auto list = CSSValueList::createSpaceSeparated();
3803             if (renderer) {
3804                 LayoutRect box;
3805                 if (is&lt;RenderBox&gt;(*renderer))
3806                     box = downcast&lt;RenderBox&gt;(*renderer).borderBoxRect();
3807 
3808                 list-&gt;append(zoomAdjustedPixelValue(minimumValueForLength(style.transformOriginX(), box.width()), style));
3809                 list-&gt;append(zoomAdjustedPixelValue(minimumValueForLength(style.transformOriginY(), box.height()), style));
3810                 if (style.transformOriginZ())
3811                     list-&gt;append(zoomAdjustedPixelValue(style.transformOriginZ(), style));
3812             } else {
3813                 list-&gt;append(zoomAdjustedPixelValueForLength(style.transformOriginX(), style));
3814                 list-&gt;append(zoomAdjustedPixelValueForLength(style.transformOriginY(), style));
3815                 if (style.transformOriginZ())
3816                     list-&gt;append(zoomAdjustedPixelValue(style.transformOriginZ(), style));
3817             }
3818             return WTFMove(list);
3819         }
3820         case CSSPropertyTransformStyle:
3821         case CSSPropertyWebkitTransformStyle:
3822             return cssValuePool.createIdentifierValue((style.transformStyle3D() == TransformStyle3D::Preserve3D) ? CSSValuePreserve3d : CSSValueFlat);
3823         case CSSPropertyTransitionDelay:
3824             return delayValue(style.transitions());
3825         case CSSPropertyTransitionDuration:
3826             return durationValue(style.transitions());
3827         case CSSPropertyTransitionProperty:
3828             return transitionPropertyValue(style.transitions());
3829         case CSSPropertyTransitionTimingFunction:
3830             return timingFunctionValue(style.transitions());
3831         case CSSPropertyTransition: {
3832             if (auto* animationList = style.transitions()) {
3833                 auto transitionsList = CSSValueList::createCommaSeparated();
3834                 for (size_t i = 0; i &lt; animationList-&gt;size(); ++i) {
3835                     auto list = CSSValueList::createSpaceSeparated();
3836                     auto&amp; animation = animationList-&gt;animation(i);
3837                     list-&gt;append(createTransitionPropertyValue(animation));
3838                     list-&gt;append(cssValuePool.createValue(animation.duration(), CSSPrimitiveValue::CSS_S));
3839                     list-&gt;append(createTimingFunctionValue(*animation.timingFunction()));
3840                     list-&gt;append(cssValuePool.createValue(animation.delay(), CSSPrimitiveValue::CSS_S));
3841                     transitionsList-&gt;append(WTFMove(list));
3842                 }
3843                 return WTFMove(transitionsList);
3844             }
3845 
3846             auto list = CSSValueList::createSpaceSeparated();
3847             // transition-property default value.
3848             list-&gt;append(cssValuePool.createIdentifierValue(CSSValueAll));
3849             list-&gt;append(cssValuePool.createValue(Animation::initialDuration(), CSSPrimitiveValue::CSS_S));
3850             list-&gt;append(createTimingFunctionValue(Animation::initialTimingFunction()));
3851             list-&gt;append(cssValuePool.createValue(Animation::initialDelay(), CSSPrimitiveValue::CSS_S));
3852             return WTFMove(list);
3853         }
3854         case CSSPropertyPointerEvents:
3855             return cssValuePool.createValue(style.pointerEvents());
3856         case CSSPropertyWebkitLineGrid:
3857             if (style.lineGrid().isNull())
3858                 return cssValuePool.createIdentifierValue(CSSValueNone);
3859             return cssValuePool.createValue(style.lineGrid(), CSSPrimitiveValue::CSS_STRING);
3860         case CSSPropertyWebkitLineSnap:
3861             return CSSPrimitiveValue::create(style.lineSnap());
3862         case CSSPropertyWebkitLineAlign:
3863             return CSSPrimitiveValue::create(style.lineAlign());
3864         case CSSPropertyWritingMode:
3865             return cssValuePool.createValue(style.writingMode());
3866         case CSSPropertyWebkitTextCombine:
3867             return cssValuePool.createValue(style.textCombine());
3868         case CSSPropertyWebkitTextOrientation:
3869             return CSSPrimitiveValue::create(style.textOrientation());
3870         case CSSPropertyWebkitLineBoxContain:
3871             return createLineBoxContainValue(style.lineBoxContain());
3872         case CSSPropertyAlt:
3873             return altTextToCSSValue(style);
3874         case CSSPropertyContent:
3875             return contentToCSSValue(style);
3876         case CSSPropertyCounterIncrement:
3877             return counterToCSSValue(style, propertyID);
3878         case CSSPropertyCounterReset:
3879             return counterToCSSValue(style, propertyID);
3880         case CSSPropertyWebkitClipPath: {
3881             auto* operation = style.clipPath();
3882             if (!operation)
3883                 return cssValuePool.createIdentifierValue(CSSValueNone);
3884             if (is&lt;ReferenceClipPathOperation&gt;(*operation))
3885                 return CSSPrimitiveValue::create(downcast&lt;ReferenceClipPathOperation&gt;(*operation).url(), CSSPrimitiveValue::CSS_URI);
3886             auto list = CSSValueList::createSpaceSeparated();
3887             if (is&lt;ShapeClipPathOperation&gt;(*operation)) {
3888                 auto&amp; shapeOperation = downcast&lt;ShapeClipPathOperation&gt;(*operation);
3889                 list-&gt;append(valueForBasicShape(style, shapeOperation.basicShape()));
3890                 if (shapeOperation.referenceBox() != CSSBoxType::BoxMissing)
3891                     list-&gt;append(cssValuePool.createValue(shapeOperation.referenceBox()));
3892             }
3893             if (is&lt;BoxClipPathOperation&gt;(*operation))
3894                 list-&gt;append(cssValuePool.createValue(downcast&lt;BoxClipPathOperation&gt;(*operation).referenceBox()));
3895             return WTFMove(list);
3896         }
3897         case CSSPropertyShapeMargin:
3898             return cssValuePool.createValue(style.shapeMargin(), style);
3899         case CSSPropertyShapeImageThreshold:
3900             return cssValuePool.createValue(style.shapeImageThreshold(), CSSPrimitiveValue::CSS_NUMBER);
3901         case CSSPropertyShapeOutside:
3902             return shapePropertyValue(style, style.shapeOutside());
3903         case CSSPropertyFilter:
3904             return valueForFilter(style, style.filter());
3905         case CSSPropertyAppleColorFilter:
3906             return valueForFilter(style, style.appleColorFilter());
3907 #if ENABLE(FILTERS_LEVEL_2)
3908         case CSSPropertyWebkitBackdropFilter:
3909             return valueForFilter(style, style.backdropFilter());
3910 #endif
3911 #if ENABLE(CSS_COMPOSITING)
3912         case CSSPropertyMixBlendMode:
3913             return cssValuePool.createValue(style.blendMode());
3914         case CSSPropertyIsolation:
3915             return cssValuePool.createValue(style.isolation());
3916 #endif
3917         case CSSPropertyBackgroundBlendMode: {
3918             auto&amp; layers = style.backgroundLayers();
3919             if (!layers.next())
3920                 return cssValuePool.createValue(layers.blendMode());
3921             auto list = CSSValueList::createCommaSeparated();
3922             for (auto* currLayer = &amp;layers; currLayer; currLayer = currLayer-&gt;next())
3923                 list-&gt;append(cssValuePool.createValue(currLayer-&gt;blendMode()));
3924             return WTFMove(list);
3925         }
3926         case CSSPropertyBackground:
3927             return getBackgroundShorthandValue();
3928         case CSSPropertyBorder: {
3929             auto value = propertyValue(CSSPropertyBorderTop, DoNotUpdateLayout);
3930             const CSSPropertyID properties[3] = { CSSPropertyBorderRight, CSSPropertyBorderBottom, CSSPropertyBorderLeft };
3931             for (auto&amp; property : properties) {
3932                 if (!compareCSSValuePtr&lt;CSSValue&gt;(value, propertyValue(property, DoNotUpdateLayout)))
3933                     return nullptr;
3934             }
3935             return value;
3936         }
3937         case CSSPropertyBorderBlock: {
3938             auto value = propertyValue(CSSPropertyBorderBlockStart, DoNotUpdateLayout);
3939             if (!compareCSSValuePtr&lt;CSSValue&gt;(value, propertyValue(CSSPropertyBorderBlockEnd, DoNotUpdateLayout)))
3940                 return nullptr;
3941             return value;
3942         }
3943         case CSSPropertyBorderBlockColor:
3944             return getCSSPropertyValuesFor2SidesShorthand(borderBlockColorShorthand());
3945         case CSSPropertyBorderBlockStyle:
3946             return getCSSPropertyValuesFor2SidesShorthand(borderBlockStyleShorthand());
3947         case CSSPropertyBorderBlockWidth:
3948             return getCSSPropertyValuesFor2SidesShorthand(borderBlockWidthShorthand());
3949         case CSSPropertyBorderBottom:
3950             return getCSSPropertyValuesForShorthandProperties(borderBottomShorthand());
3951         case CSSPropertyBorderColor:
3952             return getCSSPropertyValuesFor4SidesShorthand(borderColorShorthand());
3953         case CSSPropertyBorderLeft:
3954             return getCSSPropertyValuesForShorthandProperties(borderLeftShorthand());
3955         case CSSPropertyBorderImage:
3956             return valueForNinePieceImage(style.borderImage());
3957         case CSSPropertyBorderInline: {
3958             auto value = propertyValue(CSSPropertyBorderInlineStart, DoNotUpdateLayout);
3959             if (!compareCSSValuePtr&lt;CSSValue&gt;(value, propertyValue(CSSPropertyBorderInlineEnd, DoNotUpdateLayout)))
3960                 return nullptr;
3961             return value;
3962         }
3963         case CSSPropertyBorderInlineColor:
3964             return getCSSPropertyValuesFor2SidesShorthand(borderInlineColorShorthand());
3965         case CSSPropertyBorderInlineStyle:
3966             return getCSSPropertyValuesFor2SidesShorthand(borderInlineStyleShorthand());
3967         case CSSPropertyBorderInlineWidth:
3968             return getCSSPropertyValuesFor2SidesShorthand(borderInlineWidthShorthand());
3969         case CSSPropertyBorderRadius:
3970             return borderRadiusShorthandValue(style);
3971         case CSSPropertyBorderRight:
3972             return getCSSPropertyValuesForShorthandProperties(borderRightShorthand());
3973         case CSSPropertyBorderStyle:
3974             return getCSSPropertyValuesFor4SidesShorthand(borderStyleShorthand());
3975         case CSSPropertyBorderTop:
3976             return getCSSPropertyValuesForShorthandProperties(borderTopShorthand());
3977         case CSSPropertyBorderWidth:
3978             return getCSSPropertyValuesFor4SidesShorthand(borderWidthShorthand());
3979         case CSSPropertyColumnRule:
3980             return getCSSPropertyValuesForShorthandProperties(columnRuleShorthand());
3981         case CSSPropertyColumns:
3982             return getCSSPropertyValuesForShorthandProperties(columnsShorthand());
3983         case CSSPropertyInset:
3984             return getCSSPropertyValuesFor4SidesShorthand(insetShorthand());
3985         case CSSPropertyInsetBlock:
3986             return getCSSPropertyValuesFor2SidesShorthand(insetBlockShorthand());
3987         case CSSPropertyInsetInline:
3988             return getCSSPropertyValuesFor2SidesShorthand(insetInlineShorthand());
3989         case CSSPropertyListStyle:
3990             return getCSSPropertyValuesForShorthandProperties(listStyleShorthand());
3991         case CSSPropertyMargin:
3992             return getCSSPropertyValuesFor4SidesShorthand(marginShorthand());
3993         case CSSPropertyMarginBlock:
3994             return getCSSPropertyValuesFor2SidesShorthand(marginBlockShorthand());
3995         case CSSPropertyMarginInline:
3996             return getCSSPropertyValuesFor2SidesShorthand(marginInlineShorthand());
3997         case CSSPropertyOutline:
3998             return getCSSPropertyValuesForShorthandProperties(outlineShorthand());
3999         case CSSPropertyPadding:
4000             return getCSSPropertyValuesFor4SidesShorthand(paddingShorthand());
4001         case CSSPropertyPaddingBlock:
4002             return getCSSPropertyValuesFor2SidesShorthand(paddingBlockShorthand());
4003         case CSSPropertyPaddingInline:
4004             return getCSSPropertyValuesFor2SidesShorthand(paddingInlineShorthand());
4005 #if ENABLE(CSS_SCROLL_SNAP)
4006         case CSSPropertyScrollSnapMargin:
4007             return getCSSPropertyValuesFor4SidesShorthand(scrollSnapMarginShorthand());
4008         case CSSPropertyScrollSnapMarginBottom:
4009             return zoomAdjustedPixelValueForLength(style.scrollSnapMarginBottom(), style);
4010         case CSSPropertyScrollSnapMarginTop:
4011             return zoomAdjustedPixelValueForLength(style.scrollSnapMarginTop(), style);
4012         case CSSPropertyScrollSnapMarginRight:
4013             return zoomAdjustedPixelValueForLength(style.scrollSnapMarginRight(), style);
4014         case CSSPropertyScrollSnapMarginLeft:
4015             return zoomAdjustedPixelValueForLength(style.scrollSnapMarginLeft(), style);
4016         case CSSPropertyScrollPadding:
4017             return getCSSPropertyValuesFor4SidesShorthand(scrollPaddingShorthand());
4018         case CSSPropertyScrollPaddingBottom:
4019             return zoomAdjustedPixelValueForLength(style.scrollPaddingBottom(), style);
4020         case CSSPropertyScrollPaddingTop:
4021             return zoomAdjustedPixelValueForLength(style.scrollPaddingTop(), style);
4022         case CSSPropertyScrollPaddingRight:
4023             return zoomAdjustedPixelValueForLength(style.scrollPaddingRight(), style);
4024         case CSSPropertyScrollPaddingLeft:
4025             return zoomAdjustedPixelValueForLength(style.scrollPaddingLeft(), style);
4026         case CSSPropertyScrollSnapType:
4027             return valueForScrollSnapType(style.scrollSnapType());
4028         case CSSPropertyScrollSnapAlign:
4029             return valueForScrollSnapAlignment(style.scrollSnapAlign());
4030 #endif
4031 
4032 #if ENABLE(CSS_TRAILING_WORD)
4033         case CSSPropertyAppleTrailingWord:
4034             return cssValuePool.createValue(style.trailingWord());
4035 #endif
4036 
4037 #if ENABLE(APPLE_PAY)
4038         case CSSPropertyApplePayButtonStyle:
4039             return cssValuePool.createValue(style.applePayButtonStyle());
4040         case CSSPropertyApplePayButtonType:
4041             return cssValuePool.createValue(style.applePayButtonType());
4042 #endif
4043 
4044 #if ENABLE(DARK_MODE_CSS)
4045         case CSSPropertySupportedColorSchemes: {
4046             if (!RuntimeEnabledFeatures::sharedFeatures().darkModeCSSEnabled())
4047                 return nullptr;
4048 
4049             auto supportedColorSchemes = style.supportedColorSchemes();
4050             if (supportedColorSchemes.isAuto())
4051                 return cssValuePool.createIdentifierValue(CSSValueAuto);
4052 
4053             auto list = CSSValueList::createSpaceSeparated();
4054             if (supportedColorSchemes.contains(ColorSchemes::Light))
4055                 list-&gt;append(cssValuePool.createIdentifierValue(CSSValueLight));
4056             if (supportedColorSchemes.contains(ColorSchemes::Dark))
4057                 list-&gt;append(cssValuePool.createIdentifierValue(CSSValueDark));
4058             if (!supportedColorSchemes.allowsTransformations())
4059                 list-&gt;append(cssValuePool.createIdentifierValue(CSSValueOnly));
4060             ASSERT(list-&gt;length());
4061             return WTFMove(list);
4062         }
4063 #endif
4064 
4065         /* Individual properties not part of the spec */
4066         case CSSPropertyBackgroundRepeatX:
4067         case CSSPropertyBackgroundRepeatY:
4068             break;
4069 
4070         // Length properties for SVG.
4071         case CSSPropertyCx:
4072             return zoomAdjustedPixelValueForLength(style.svgStyle().cx(), style);
4073         case CSSPropertyCy:
4074             return zoomAdjustedPixelValueForLength(style.svgStyle().cy(), style);
4075         case CSSPropertyR:
4076             return zoomAdjustedPixelValueForLength(style.svgStyle().r(), style);
4077         case CSSPropertyRx:
4078             return zoomAdjustedPixelValueForLength(style.svgStyle().rx(), style);
4079         case CSSPropertyRy:
4080             return zoomAdjustedPixelValueForLength(style.svgStyle().ry(), style);
4081         case CSSPropertyStrokeDashoffset:
4082             return zoomAdjustedPixelValueForLength(style.svgStyle().strokeDashOffset(), style);
4083         case CSSPropertyX:
4084             return zoomAdjustedPixelValueForLength(style.svgStyle().x(), style);
4085         case CSSPropertyY:
4086             return zoomAdjustedPixelValueForLength(style.svgStyle().y(), style);
4087         case CSSPropertyWebkitTextZoom:
4088             return cssValuePool.createValue(style.textZoom());
4089 
4090         case CSSPropertyPaintOrder:
4091             return paintOrder(style.paintOrder());
4092         case CSSPropertyStrokeLinecap:
4093             return CSSPrimitiveValue::create(style.capStyle());
4094         case CSSPropertyStrokeLinejoin:
4095             return CSSPrimitiveValue::create(style.joinStyle());
4096         case CSSPropertyStrokeWidth:
4097             return zoomAdjustedPixelValueForLength(style.strokeWidth(), style);
4098         case CSSPropertyStrokeColor:
4099             return currentColorOrValidColor(&amp;style, style.strokeColor());
4100         case CSSPropertyStrokeMiterlimit:
4101             return CSSPrimitiveValue::create(style.strokeMiterLimit(), CSSPrimitiveValue::CSS_NUMBER);
4102 
4103         /* Unimplemented CSS 3 properties (including CSS3 shorthand properties) */
4104         case CSSPropertyAll:
4105         case CSSPropertyAnimation:
4106         case CSSPropertyWebkitTextEmphasis:
4107             break;
4108 
4109         /* Directional properties are resolved by resolveDirectionAwareProperty() before the switch. */
4110         case CSSPropertyBorderBlockEnd:
4111         case CSSPropertyBorderBlockEndColor:
4112         case CSSPropertyBorderBlockEndStyle:
4113         case CSSPropertyBorderBlockEndWidth:
4114         case CSSPropertyBorderBlockStart:
4115         case CSSPropertyBorderBlockStartColor:
4116         case CSSPropertyBorderBlockStartStyle:
4117         case CSSPropertyBorderBlockStartWidth:
4118         case CSSPropertyBorderInlineEnd:
4119         case CSSPropertyBorderInlineEndColor:
4120         case CSSPropertyBorderInlineEndStyle:
4121         case CSSPropertyBorderInlineEndWidth:
4122         case CSSPropertyBorderInlineStart:
4123         case CSSPropertyBorderInlineStartColor:
4124         case CSSPropertyBorderInlineStartStyle:
4125         case CSSPropertyBorderInlineStartWidth:
4126         case CSSPropertyInsetBlockEnd:
4127         case CSSPropertyInsetBlockStart:
4128         case CSSPropertyInsetInlineEnd:
4129         case CSSPropertyInsetInlineStart:
4130         case CSSPropertyMarginBlockEnd:
4131         case CSSPropertyMarginBlockStart:
4132         case CSSPropertyMarginInlineEnd:
4133         case CSSPropertyMarginInlineStart:
4134         case CSSPropertyPaddingBlockEnd:
4135         case CSSPropertyPaddingBlockStart:
4136         case CSSPropertyPaddingInlineEnd:
4137         case CSSPropertyPaddingInlineStart:
4138         case CSSPropertyBlockSize:
4139         case CSSPropertyInlineSize:
4140         case CSSPropertyMaxBlockSize:
4141         case CSSPropertyMaxInlineSize:
4142         case CSSPropertyMinBlockSize:
4143         case CSSPropertyMinInlineSize:
4144             ASSERT_NOT_REACHED();
4145             break;
4146 
4147         /* Unimplemented @font-face properties */
4148         case CSSPropertySrc:
4149         case CSSPropertyUnicodeRange:
4150         case CSSPropertyFontDisplay:
4151             break;
4152 
4153         /* Other unimplemented properties */
4154         case CSSPropertyPage: // for @page
4155         case CSSPropertyQuotes: // FIXME: needs implementation
4156         case CSSPropertySize: // for @page
4157             break;
4158 
4159         /* Unimplemented -webkit- properties */
4160         case CSSPropertyWebkitBorderRadius:
4161         case CSSPropertyWebkitMarginCollapse:
4162         case CSSPropertyWebkitMarquee:
4163         case CSSPropertyWebkitMarqueeSpeed:
4164         case CSSPropertyWebkitMask:
4165         case CSSPropertyWebkitMaskRepeatX:
4166         case CSSPropertyWebkitMaskRepeatY:
4167         case CSSPropertyPerspectiveOriginX:
4168         case CSSPropertyPerspectiveOriginY:
4169         case CSSPropertyWebkitTextStroke:
4170         case CSSPropertyTransformOriginX:
4171         case CSSPropertyTransformOriginY:
4172         case CSSPropertyTransformOriginZ:
4173             break;
4174 
4175 #if ENABLE(CSS_DEVICE_ADAPTATION)
4176         case CSSPropertyMaxZoom:
4177         case CSSPropertyMinZoom:
4178         case CSSPropertyOrientation:
4179         case CSSPropertyUserZoom:
4180             break;
4181 #endif
4182 
4183         case CSSPropertyBufferedRendering:
4184         case CSSPropertyClipPath:
4185         case CSSPropertyClipRule:
4186         case CSSPropertyMask:
4187         case CSSPropertyEnableBackground:
4188         case CSSPropertyFloodColor:
4189         case CSSPropertyFloodOpacity:
4190         case CSSPropertyLightingColor:
4191         case CSSPropertyStopColor:
4192         case CSSPropertyStopOpacity:
4193         case CSSPropertyColorInterpolation:
4194         case CSSPropertyColorInterpolationFilters:
4195         case CSSPropertyColorProfile:
4196         case CSSPropertyColorRendering:
4197         case CSSPropertyFill:
4198         case CSSPropertyFillOpacity:
4199         case CSSPropertyFillRule:
4200         case CSSPropertyMarker:
4201         case CSSPropertyMarkerEnd:
4202         case CSSPropertyMarkerMid:
4203         case CSSPropertyMarkerStart:
4204         case CSSPropertyMaskType:
4205         case CSSPropertyShapeRendering:
4206         case CSSPropertyStroke:
4207         case CSSPropertyStrokeDasharray:
4208         case CSSPropertyStrokeOpacity:
4209         case CSSPropertyAlignmentBaseline:
4210         case CSSPropertyBaselineShift:
4211         case CSSPropertyDominantBaseline:
4212         case CSSPropertyGlyphOrientationHorizontal:
4213         case CSSPropertyGlyphOrientationVertical:
4214         case CSSPropertyKerning:
4215         case CSSPropertyTextAnchor:
4216         case CSSPropertyVectorEffect:
4217             return svgPropertyValue(propertyID);
4218         case CSSPropertyCustom:
4219             ASSERT_NOT_REACHED();
4220             return nullptr;
4221     }
4222 
4223     logUnimplementedPropertyID(propertyID);
4224     return nullptr;
4225 }
4226 
4227 String CSSComputedStyleDeclaration::getPropertyValue(CSSPropertyID propertyID) const
4228 {
4229     auto value = getPropertyCSSValue(propertyID);
4230     if (!value)
4231         return emptyString(); // FIXME: Should this be null instead, as it is in StyleProperties::getPropertyValue?
4232     return value-&gt;cssText();
4233 }
4234 
4235 unsigned CSSComputedStyleDeclaration::length() const
4236 {
4237     updateStyleIfNeededForProperty(m_element.get(), CSSPropertyCustom);
4238 
4239     auto* style = m_element-&gt;computedStyle(m_pseudoElementSpecifier);
4240     if (!style)
4241         return 0;
4242 
4243     return numComputedProperties + style-&gt;inheritedCustomProperties().size() + style-&gt;nonInheritedCustomProperties().size();
4244 }
4245 
4246 String CSSComputedStyleDeclaration::item(unsigned i) const
4247 {
4248     if (i &gt;= length())
4249         return String();
4250 
4251     if (i &lt; numComputedProperties)
4252         return getPropertyNameString(computedProperties[i]);
4253 
4254     auto* style = m_element-&gt;computedStyle(m_pseudoElementSpecifier);
4255     if (!style)
4256         return String();
4257 
4258     const auto&amp; inheritedCustomProperties = style-&gt;inheritedCustomProperties();
4259 
4260     if (i &lt; numComputedProperties + inheritedCustomProperties.size()) {
4261         auto results = copyToVector(inheritedCustomProperties.keys());
4262         return results.at(i - numComputedProperties);
4263     }
4264 
4265     const auto&amp; nonInheritedCustomProperties = style-&gt;nonInheritedCustomProperties();
4266     auto results = copyToVector(nonInheritedCustomProperties.keys());
4267     return results.at(i - inheritedCustomProperties.size() - numComputedProperties);
4268 }
4269 
4270 bool ComputedStyleExtractor::propertyMatches(CSSPropertyID propertyID, const CSSValue* value)
4271 {
4272     if (!m_element)
4273         return false;
4274     if (propertyID == CSSPropertyFontSize &amp;&amp; is&lt;CSSPrimitiveValue&gt;(*value)) {
4275         m_element-&gt;document().updateLayoutIgnorePendingStylesheets();
4276         if (auto* style = m_element-&gt;computedStyle(m_pseudoElementSpecifier)) {
4277             if (CSSValueID sizeIdentifier = style-&gt;fontDescription().keywordSizeAsIdentifier()) {
4278                 auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(*value);
4279                 if (primitiveValue.isValueID() &amp;&amp; primitiveValue.valueID() == sizeIdentifier)
4280                     return true;
4281             }
4282         }
4283     }
4284     RefPtr&lt;CSSValue&gt; computedValue = propertyValue(propertyID);
4285     return computedValue &amp;&amp; value &amp;&amp; computedValue-&gt;equals(*value);
4286 }
4287 
4288 Ref&lt;MutableStyleProperties&gt; ComputedStyleExtractor::copyProperties()
4289 {
4290     return copyPropertiesInSet(computedProperties, numComputedProperties);
4291 }
4292 
4293 Ref&lt;CSSValueList&gt; ComputedStyleExtractor::getCSSPropertyValuesForShorthandProperties(const StylePropertyShorthand&amp; shorthand)
4294 {
4295     auto list = CSSValueList::createSpaceSeparated();
4296     for (size_t i = 0; i &lt; shorthand.length(); ++i)
4297         list-&gt;append(propertyValue(shorthand.properties()[i], DoNotUpdateLayout).releaseNonNull());
4298     return list;
4299 }
4300 
4301 RefPtr&lt;CSSValueList&gt; ComputedStyleExtractor::getCSSPropertyValuesFor2SidesShorthand(const StylePropertyShorthand&amp; shorthand)
4302 {
4303     auto list = CSSValueList::createSpaceSeparated();
4304 
4305     // Assume the properties are in the usual order start, end.
4306     auto startValue = propertyValue(shorthand.properties()[0], DoNotUpdateLayout);
4307     auto endValue = propertyValue(shorthand.properties()[1], DoNotUpdateLayout);
4308 
4309     // All 2 properties must be specified.
4310     if (!startValue || !endValue)
4311         return nullptr;
4312 
4313     bool showEnd = !compareCSSValuePtr(startValue, endValue);
4314 
4315     list-&gt;append(startValue.releaseNonNull());
4316     if (showEnd)
4317         list-&gt;append(endValue.releaseNonNull());
4318 
4319     return WTFMove(list);
4320 }
4321 
4322 RefPtr&lt;CSSValueList&gt; ComputedStyleExtractor::getCSSPropertyValuesFor4SidesShorthand(const StylePropertyShorthand&amp; shorthand)
4323 {
4324     auto list = CSSValueList::createSpaceSeparated();
4325 
4326     // Assume the properties are in the usual order top, right, bottom, left.
4327     auto topValue = propertyValue(shorthand.properties()[0], DoNotUpdateLayout);
4328     auto rightValue = propertyValue(shorthand.properties()[1], DoNotUpdateLayout);
4329     auto bottomValue = propertyValue(shorthand.properties()[2], DoNotUpdateLayout);
4330     auto leftValue = propertyValue(shorthand.properties()[3], DoNotUpdateLayout);
4331 
4332     // All 4 properties must be specified.
4333     if (!topValue || !rightValue || !bottomValue || !leftValue)
4334         return nullptr;
4335 
4336     bool showLeft = !compareCSSValuePtr(rightValue, leftValue);
4337     bool showBottom = !compareCSSValuePtr(topValue, bottomValue) || showLeft;
4338     bool showRight = !compareCSSValuePtr(topValue, rightValue) || showBottom;
4339 
4340     list-&gt;append(topValue.releaseNonNull());
4341     if (showRight)
4342         list-&gt;append(rightValue.releaseNonNull());
4343     if (showBottom)
4344         list-&gt;append(bottomValue.releaseNonNull());
4345     if (showLeft)
4346         list-&gt;append(leftValue.releaseNonNull());
4347 
4348     return WTFMove(list);
4349 }
4350 
4351 Ref&lt;CSSValueList&gt; ComputedStyleExtractor::getCSSPropertyValuesForGridShorthand(const StylePropertyShorthand&amp; shorthand)
4352 {
4353     auto list = CSSValueList::createSlashSeparated();
4354     for (size_t i = 0; i &lt; shorthand.length(); ++i)
4355         list-&gt;append(propertyValue(shorthand.properties()[i], DoNotUpdateLayout).releaseNonNull());
4356     return list;
4357 }
4358 
4359 Ref&lt;MutableStyleProperties&gt; ComputedStyleExtractor::copyPropertiesInSet(const CSSPropertyID* set, unsigned length)
4360 {
4361     Vector&lt;CSSProperty, 256&gt; list;
4362     list.reserveInitialCapacity(length);
4363     for (unsigned i = 0; i &lt; length; ++i) {
4364         if (auto value = propertyValue(set[i]))
4365             list.append(CSSProperty(set[i], WTFMove(value), false));
4366     }
4367     return MutableStyleProperties::create(list.data(), list.size());
4368 }
4369 
4370 CSSRule* CSSComputedStyleDeclaration::parentRule() const
4371 {
4372     return nullptr;
4373 }
4374 
4375 RefPtr&lt;DeprecatedCSSOMValue&gt; CSSComputedStyleDeclaration::getPropertyCSSValue(const String&amp; propertyName)
4376 {
4377     if (isCustomPropertyName(propertyName)) {
4378         auto value = ComputedStyleExtractor(m_element.ptr(), m_allowVisitedStyle, m_pseudoElementSpecifier).customPropertyValue(propertyName);
4379         if (!value)
4380             return nullptr;
4381         return value-&gt;createDeprecatedCSSOMWrapper(*this);
4382     }
4383 
4384     CSSPropertyID propertyID = cssPropertyID(propertyName);
4385     if (!propertyID)
4386         return nullptr;
4387     auto value = getPropertyCSSValue(propertyID);
4388     if (!value)
4389         return nullptr;
4390     return value-&gt;createDeprecatedCSSOMWrapper(*this);
4391 }
4392 
4393 String CSSComputedStyleDeclaration::getPropertyValue(const String &amp;propertyName)
4394 {
4395     if (isCustomPropertyName(propertyName))
4396         return ComputedStyleExtractor(m_element.ptr(), m_allowVisitedStyle, m_pseudoElementSpecifier).customPropertyText(propertyName);
4397 
4398     CSSPropertyID propertyID = cssPropertyID(propertyName);
4399     if (!propertyID)
4400         return String();
4401     return getPropertyValue(propertyID);
4402 }
4403 
4404 String CSSComputedStyleDeclaration::getPropertyPriority(const String&amp;)
4405 {
4406     // All computed styles have a priority of not &quot;important&quot;.
4407     return emptyString(); // FIXME: Should this sometimes be null instead of empty, to match a normal style declaration?
4408 }
4409 
4410 String CSSComputedStyleDeclaration::getPropertyShorthand(const String&amp;)
4411 {
4412     return emptyString(); // FIXME: Should this sometimes be null instead of empty, to match a normal style declaration?
4413 }
4414 
4415 bool CSSComputedStyleDeclaration::isPropertyImplicit(const String&amp;)
4416 {
4417     return false;
4418 }
4419 
4420 ExceptionOr&lt;void&gt; CSSComputedStyleDeclaration::setProperty(const String&amp;, const String&amp;, const String&amp;)
4421 {
4422     return Exception { NoModificationAllowedError };
4423 }
4424 
4425 ExceptionOr&lt;String&gt; CSSComputedStyleDeclaration::removeProperty(const String&amp;)
4426 {
4427     return Exception { NoModificationAllowedError };
4428 }
4429 
4430 RefPtr&lt;CSSValue&gt; CSSComputedStyleDeclaration::getPropertyCSSValueInternal(CSSPropertyID propertyID)
4431 {
4432     return getPropertyCSSValue(propertyID);
4433 }
4434 
4435 String CSSComputedStyleDeclaration::getPropertyValueInternal(CSSPropertyID propertyID)
4436 {
4437     return getPropertyValue(propertyID);
4438 }
4439 
4440 ExceptionOr&lt;bool&gt; CSSComputedStyleDeclaration::setPropertyInternal(CSSPropertyID, const String&amp;, bool)
4441 {
4442     return Exception { NoModificationAllowedError };
4443 }
4444 
4445 Ref&lt;CSSValueList&gt; ComputedStyleExtractor::getBackgroundShorthandValue()
4446 {
4447     static const CSSPropertyID propertiesBeforeSlashSeperator[5] = { CSSPropertyBackgroundColor, CSSPropertyBackgroundImage, CSSPropertyBackgroundRepeat, CSSPropertyBackgroundAttachment, CSSPropertyBackgroundPosition };
4448     static const CSSPropertyID propertiesAfterSlashSeperator[3] = { CSSPropertyBackgroundSize, CSSPropertyBackgroundOrigin, CSSPropertyBackgroundClip };
4449 
4450     auto list = CSSValueList::createSlashSeparated();
4451     list-&gt;append(getCSSPropertyValuesForShorthandProperties(StylePropertyShorthand(CSSPropertyBackground, propertiesBeforeSlashSeperator)));
4452     list-&gt;append(getCSSPropertyValuesForShorthandProperties(StylePropertyShorthand(CSSPropertyBackground, propertiesAfterSlashSeperator)));
4453     return list;
4454 }
4455 
4456 } // namespace WebCore
    </pre>
  </body>
</html>