<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/WHLSLIntrinsics.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WHLSLInferTypes.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="WHLSLIntrinsics.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/WHLSLIntrinsics.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 67,67 ***</span>
  
      if (nativeTypeDeclaration.name() == &quot;void&quot;)
          m_voidType = &amp;nativeTypeDeclaration;
      else if (nativeTypeDeclaration.name() == &quot;bool&quot;)
          m_boolType = &amp;nativeTypeDeclaration;
<span class="line-modified">!     else if (nativeTypeDeclaration.name() == &quot;uchar&quot;) {</span>
<span class="line-removed">-         nativeTypeDeclaration.setIsInt();</span>
<span class="line-removed">-         nativeTypeDeclaration.setIsNumber();</span>
<span class="line-removed">-         nativeTypeDeclaration.setCanRepresentInteger([](int x) {</span>
<span class="line-removed">-             return x &gt;= 0 &amp;&amp; x &lt;= 0xFF;</span>
<span class="line-removed">-         });</span>
<span class="line-removed">-         nativeTypeDeclaration.setCanRepresentUnsignedInteger([](unsigned x) {</span>
<span class="line-removed">-             return x &lt;= 0xFF;</span>
<span class="line-removed">-         });</span>
<span class="line-removed">-         nativeTypeDeclaration.setCanRepresentFloat([](float x) {</span>
<span class="line-removed">-             return static_cast&lt;float&gt;(static_cast&lt;uint8_t&gt;(x)) == x;</span>
<span class="line-removed">-         });</span>
<span class="line-removed">-         nativeTypeDeclaration.setSuccessor([](int64_t x) -&gt; int64_t {</span>
<span class="line-removed">-             return static_cast&lt;uint8_t&gt;(x + 1);</span>
<span class="line-removed">-         });</span>
<span class="line-removed">-         nativeTypeDeclaration.setFormatValueFromInteger([](int x) -&gt; int64_t {</span>
<span class="line-removed">-             return static_cast&lt;uint8_t&gt;(x);</span>
<span class="line-removed">-         });</span>
<span class="line-removed">-         nativeTypeDeclaration.setFormatValueFromUnsignedInteger([](unsigned x) -&gt; int64_t {</span>
<span class="line-removed">-             return static_cast&lt;uint8_t&gt;(x);</span>
<span class="line-removed">-         });</span>
<span class="line-removed">-         nativeTypeDeclaration.setIterateAllValues([](const std::function&lt;bool(int64_t)&gt;&amp; callback) {</span>
<span class="line-removed">-             for (int64_t i = 0; i &lt; 0x100; ++i) {</span>
<span class="line-removed">-                 if (callback(i))</span>
<span class="line-removed">-                     break;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         });</span>
<span class="line-removed">-         m_ucharType = &amp;nativeTypeDeclaration;</span>
<span class="line-removed">-     } else if (nativeTypeDeclaration.name() == &quot;ushort&quot;) {</span>
<span class="line-removed">-         nativeTypeDeclaration.setIsInt();</span>
<span class="line-removed">-         nativeTypeDeclaration.setIsNumber();</span>
<span class="line-removed">-         nativeTypeDeclaration.setCanRepresentInteger([](int x) {</span>
<span class="line-removed">-             return x &gt;= 0 &amp;&amp; x &lt;= 0xFFFF;</span>
<span class="line-removed">-         });</span>
<span class="line-removed">-         nativeTypeDeclaration.setCanRepresentUnsignedInteger([](unsigned x) {</span>
<span class="line-removed">-             return x &lt;= 0xFFFF;</span>
<span class="line-removed">-         });</span>
<span class="line-removed">-         nativeTypeDeclaration.setCanRepresentFloat([](float x) {</span>
<span class="line-removed">-             return static_cast&lt;float&gt;(static_cast&lt;uint16_t&gt;(x)) == x;</span>
<span class="line-removed">-         });</span>
<span class="line-removed">-         nativeTypeDeclaration.setSuccessor([](int64_t x) -&gt; int64_t {</span>
<span class="line-removed">-             return static_cast&lt;uint16_t&gt;(x + 1);</span>
<span class="line-removed">-         });</span>
<span class="line-removed">-         nativeTypeDeclaration.setFormatValueFromInteger([](int x) -&gt; int64_t {</span>
<span class="line-removed">-             return static_cast&lt;uint16_t&gt;(x);</span>
<span class="line-removed">-         });</span>
<span class="line-removed">-         nativeTypeDeclaration.setFormatValueFromUnsignedInteger([](unsigned x) -&gt; int64_t {</span>
<span class="line-removed">-             return static_cast&lt;uint16_t&gt;(x);</span>
<span class="line-removed">-         });</span>
<span class="line-removed">-         nativeTypeDeclaration.setIterateAllValues([](const std::function&lt;bool(int64_t)&gt;&amp; callback) {</span>
<span class="line-removed">-             for (int64_t i = 0; i &lt; 0x10000; ++i) {</span>
<span class="line-removed">-                 if (callback(i))</span>
<span class="line-removed">-                     break;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         });</span>
<span class="line-removed">-         m_ushortType = &amp;nativeTypeDeclaration;</span>
<span class="line-removed">-     } else if (nativeTypeDeclaration.name() == &quot;uint&quot;) {</span>
          nativeTypeDeclaration.setIsInt();
          nativeTypeDeclaration.setIsNumber();
          nativeTypeDeclaration.setCanRepresentInteger([](int x) {
              return x &gt;= 0;
          });
<span class="line-new-header">--- 67,11 ---</span>
  
      if (nativeTypeDeclaration.name() == &quot;void&quot;)
          m_voidType = &amp;nativeTypeDeclaration;
      else if (nativeTypeDeclaration.name() == &quot;bool&quot;)
          m_boolType = &amp;nativeTypeDeclaration;
<span class="line-modified">!     else if (nativeTypeDeclaration.name() == &quot;uint&quot;) {</span>
          nativeTypeDeclaration.setIsInt();
          nativeTypeDeclaration.setIsNumber();
          nativeTypeDeclaration.setCanRepresentInteger([](int x) {
              return x &gt;= 0;
          });
</pre>
<hr />
<pre>
<span class="line-old-header">*** 151,68 ***</span>
                  if (callback(i))
                      break;
              }
          });
          m_uintType = &amp;nativeTypeDeclaration;
<span class="line-removed">-     } else if (nativeTypeDeclaration.name() == &quot;char&quot;) {</span>
<span class="line-removed">-         nativeTypeDeclaration.setIsInt();</span>
<span class="line-removed">-         nativeTypeDeclaration.setIsNumber();</span>
<span class="line-removed">-         nativeTypeDeclaration.setIsSigned();</span>
<span class="line-removed">-         nativeTypeDeclaration.setCanRepresentInteger([](int x) {</span>
<span class="line-removed">-             return x &gt;= -128 &amp;&amp; x &lt;= 127;</span>
<span class="line-removed">-         });</span>
<span class="line-removed">-         nativeTypeDeclaration.setCanRepresentUnsignedInteger([](unsigned x) {</span>
<span class="line-removed">-             return x &lt;= 127;</span>
<span class="line-removed">-         });</span>
<span class="line-removed">-         nativeTypeDeclaration.setCanRepresentFloat([](float x) {</span>
<span class="line-removed">-             return static_cast&lt;float&gt;(static_cast&lt;int8_t&gt;(x)) == x;</span>
<span class="line-removed">-         });</span>
<span class="line-removed">-         nativeTypeDeclaration.setSuccessor([](int64_t x) -&gt; int64_t {</span>
<span class="line-removed">-             return static_cast&lt;int8_t&gt;(x + 1);</span>
<span class="line-removed">-         });</span>
<span class="line-removed">-         nativeTypeDeclaration.setFormatValueFromInteger([](int x) -&gt; int64_t {</span>
<span class="line-removed">-             return static_cast&lt;int8_t&gt;(x);</span>
<span class="line-removed">-         });</span>
<span class="line-removed">-         nativeTypeDeclaration.setFormatValueFromUnsignedInteger([](unsigned x) -&gt; int64_t {</span>
<span class="line-removed">-             return static_cast&lt;int8_t&gt;(x);</span>
<span class="line-removed">-         });</span>
<span class="line-removed">-         nativeTypeDeclaration.setIterateAllValues([](const std::function&lt;bool(int64_t)&gt;&amp; callback) {</span>
<span class="line-removed">-             for (int64_t i = -128; i &lt; 128; ++i) {</span>
<span class="line-removed">-                 if (callback(i))</span>
<span class="line-removed">-                     break;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         });</span>
<span class="line-removed">-         m_charType = &amp;nativeTypeDeclaration;</span>
<span class="line-removed">-     } else if (nativeTypeDeclaration.name() == &quot;short&quot;) {</span>
<span class="line-removed">-         nativeTypeDeclaration.setIsInt();</span>
<span class="line-removed">-         nativeTypeDeclaration.setIsNumber();</span>
<span class="line-removed">-         nativeTypeDeclaration.setIsSigned();</span>
<span class="line-removed">-         nativeTypeDeclaration.setCanRepresentInteger([](int x) {</span>
<span class="line-removed">-             return x &gt;= -32768 &amp;&amp; x &lt;= 32767;</span>
<span class="line-removed">-         });</span>
<span class="line-removed">-         nativeTypeDeclaration.setCanRepresentUnsignedInteger([](unsigned x) {</span>
<span class="line-removed">-             return x &lt;= 32767;</span>
<span class="line-removed">-         });</span>
<span class="line-removed">-         nativeTypeDeclaration.setCanRepresentFloat([](float x) {</span>
<span class="line-removed">-             return static_cast&lt;float&gt;(static_cast&lt;int16_t&gt;(x)) == x;</span>
<span class="line-removed">-         });</span>
<span class="line-removed">-         nativeTypeDeclaration.setSuccessor([](int64_t x) -&gt; int64_t {</span>
<span class="line-removed">-             return static_cast&lt;int16_t&gt;(x + 1);</span>
<span class="line-removed">-         });</span>
<span class="line-removed">-         nativeTypeDeclaration.setFormatValueFromInteger([](int x) -&gt; int64_t {</span>
<span class="line-removed">-             return static_cast&lt;int16_t&gt;(x);</span>
<span class="line-removed">-         });</span>
<span class="line-removed">-         nativeTypeDeclaration.setFormatValueFromUnsignedInteger([](unsigned x) -&gt; int64_t {</span>
<span class="line-removed">-             return static_cast&lt;int16_t&gt;(x);</span>
<span class="line-removed">-         });</span>
<span class="line-removed">-         nativeTypeDeclaration.setIterateAllValues([](const std::function&lt;bool(int64_t)&gt;&amp; callback) {</span>
<span class="line-removed">-             for (int64_t i = -32768; i &lt; 32768; ++i) {</span>
<span class="line-removed">-                 if (callback(i))</span>
<span class="line-removed">-                     break;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         });</span>
<span class="line-removed">-         m_shortType = &amp;nativeTypeDeclaration;</span>
      } else if (nativeTypeDeclaration.name() == &quot;int&quot;) {
          nativeTypeDeclaration.setIsInt();
          nativeTypeDeclaration.setIsNumber();
          nativeTypeDeclaration.setIsSigned();
          nativeTypeDeclaration.setCanRepresentInteger([](int) {
<span class="line-new-header">--- 95,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 238,23 ***</span>
                  if (callback(i))
                      break;
              }
          });
          m_intType = &amp;nativeTypeDeclaration;
<span class="line-removed">-     } else if (nativeTypeDeclaration.name() == &quot;half&quot;) {</span>
<span class="line-removed">-         nativeTypeDeclaration.setIsNumber();</span>
<span class="line-removed">-         nativeTypeDeclaration.setIsFloating();</span>
<span class="line-removed">-         nativeTypeDeclaration.setCanRepresentInteger([](int) {</span>
<span class="line-removed">-             return true;</span>
<span class="line-removed">-         });</span>
<span class="line-removed">-         nativeTypeDeclaration.setCanRepresentUnsignedInteger([](unsigned) {</span>
<span class="line-removed">-             return true;</span>
<span class="line-removed">-         });</span>
<span class="line-removed">-         nativeTypeDeclaration.setCanRepresentFloat([](float) {</span>
<span class="line-removed">-             return true;</span>
<span class="line-removed">-         });</span>
<span class="line-removed">-         m_halfType = &amp;nativeTypeDeclaration;</span>
      } else if (nativeTypeDeclaration.name() == &quot;float&quot;) {
          nativeTypeDeclaration.setIsNumber();
          nativeTypeDeclaration.setIsFloating();
          nativeTypeDeclaration.setCanRepresentInteger([](int) {
              return true;
<span class="line-new-header">--- 124,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 264,49 ***</span>
          });
          nativeTypeDeclaration.setCanRepresentFloat([](float) {
              return true;
          });
          m_floatType = &amp;nativeTypeDeclaration;
<span class="line-modified">!     } else if (nativeTypeDeclaration.name() == &quot;atomic_int&quot;)</span>
          m_atomicIntType = &amp;nativeTypeDeclaration;
<span class="line-modified">!     else if (nativeTypeDeclaration.name() == &quot;atomic_uint&quot;)</span>
          m_atomicUintType = &amp;nativeTypeDeclaration;
<span class="line-modified">!     else if (nativeTypeDeclaration.name() == &quot;sampler&quot;)</span>
          m_samplerType = &amp;nativeTypeDeclaration;
<span class="line-modified">!     else</span>
          ASSERT_NOT_REACHED();
      return true;
  }
  
  bool Intrinsics::addVector(AST::NativeTypeDeclaration&amp; nativeTypeDeclaration)
  {
      if (nativeTypeDeclaration.name() != &quot;vector&quot;)
          return false;
  
      ASSERT(nativeTypeDeclaration.typeArguments().size() == 2);
<span class="line-modified">!     ASSERT(WTF::holds_alternative&lt;UniqueRef&lt;AST::TypeReference&gt;&gt;(nativeTypeDeclaration.typeArguments()[0]));</span>
      ASSERT(WTF::holds_alternative&lt;AST::ConstantExpression&gt;(nativeTypeDeclaration.typeArguments()[1]));
<span class="line-modified">!     auto&amp; innerType = static_cast&lt;AST::TypeReference&amp;&gt;(WTF::get&lt;UniqueRef&lt;AST::TypeReference&gt;&gt;(nativeTypeDeclaration.typeArguments()[0]));</span>
      auto&amp; lengthExpression = WTF::get&lt;AST::ConstantExpression&gt;(nativeTypeDeclaration.typeArguments()[1]);
      ASSERT(!innerType.typeArguments().size());
      AST::NativeTypeDeclaration** array;
      if (innerType.name() == &quot;bool&quot;)
          array = m_vectorBool;
<span class="line-removed">-     else if (innerType.name() == &quot;uchar&quot;)</span>
<span class="line-removed">-         array = m_vectorUchar;</span>
<span class="line-removed">-     else if (innerType.name() == &quot;ushort&quot;)</span>
<span class="line-removed">-         array = m_vectorUshort;</span>
      else if (innerType.name() == &quot;uint&quot;)
          array = m_vectorUint;
<span class="line-removed">-     else if (innerType.name() == &quot;char&quot;)</span>
<span class="line-removed">-         array = m_vectorChar;</span>
<span class="line-removed">-     else if (innerType.name() == &quot;short&quot;)</span>
<span class="line-removed">-         array = m_vectorShort;</span>
      else if (innerType.name() == &quot;int&quot;)
          array = m_vectorInt;
<span class="line-removed">-     else if (innerType.name() == &quot;half&quot;)</span>
<span class="line-removed">-         array = m_vectorHalf;</span>
      else {
          ASSERT(innerType.name() == &quot;float&quot;);
          array = m_vectorFloat;
      }
      int length = lengthExpression.integerLiteral().value();
<span class="line-new-header">--- 137,42 ---</span>
          });
          nativeTypeDeclaration.setCanRepresentFloat([](float) {
              return true;
          });
          m_floatType = &amp;nativeTypeDeclaration;
<span class="line-modified">!     } else if (nativeTypeDeclaration.name() == &quot;atomic_int&quot;) {</span>
<span class="line-added">+         nativeTypeDeclaration.setIsAtomic();</span>
          m_atomicIntType = &amp;nativeTypeDeclaration;
<span class="line-modified">!     } else if (nativeTypeDeclaration.name() == &quot;atomic_uint&quot;) {</span>
<span class="line-added">+         nativeTypeDeclaration.setIsAtomic();</span>
          m_atomicUintType = &amp;nativeTypeDeclaration;
<span class="line-modified">!     } else if (nativeTypeDeclaration.name() == &quot;sampler&quot;) {</span>
          m_samplerType = &amp;nativeTypeDeclaration;
<span class="line-modified">!         nativeTypeDeclaration.setIsOpaqueType();</span>
<span class="line-added">+     } else</span>
          ASSERT_NOT_REACHED();
      return true;
  }
  
  bool Intrinsics::addVector(AST::NativeTypeDeclaration&amp; nativeTypeDeclaration)
  {
      if (nativeTypeDeclaration.name() != &quot;vector&quot;)
          return false;
  
      ASSERT(nativeTypeDeclaration.typeArguments().size() == 2);
<span class="line-modified">!     ASSERT(WTF::holds_alternative&lt;Ref&lt;AST::TypeReference&gt;&gt;(nativeTypeDeclaration.typeArguments()[0]));</span>
      ASSERT(WTF::holds_alternative&lt;AST::ConstantExpression&gt;(nativeTypeDeclaration.typeArguments()[1]));
<span class="line-modified">!     auto&amp; innerType = static_cast&lt;AST::TypeReference&amp;&gt;(WTF::get&lt;Ref&lt;AST::TypeReference&gt;&gt;(nativeTypeDeclaration.typeArguments()[0]));</span>
      auto&amp; lengthExpression = WTF::get&lt;AST::ConstantExpression&gt;(nativeTypeDeclaration.typeArguments()[1]);
      ASSERT(!innerType.typeArguments().size());
      AST::NativeTypeDeclaration** array;
      if (innerType.name() == &quot;bool&quot;)
          array = m_vectorBool;
      else if (innerType.name() == &quot;uint&quot;)
          array = m_vectorUint;
      else if (innerType.name() == &quot;int&quot;)
          array = m_vectorInt;
      else {
          ASSERT(innerType.name() == &quot;float&quot;);
          array = m_vectorFloat;
      }
      int length = lengthExpression.integerLiteral().value();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 319,47 ***</span>
  bool Intrinsics::addMatrix(AST::NativeTypeDeclaration&amp; nativeTypeDeclaration)
  {
      if (nativeTypeDeclaration.name() != &quot;matrix&quot;)
          return false;
  
      ASSERT(nativeTypeDeclaration.typeArguments().size() == 3);
<span class="line-modified">!     ASSERT(WTF::holds_alternative&lt;UniqueRef&lt;AST::TypeReference&gt;&gt;(nativeTypeDeclaration.typeArguments()[0]));</span>
      ASSERT(WTF::holds_alternative&lt;AST::ConstantExpression&gt;(nativeTypeDeclaration.typeArguments()[1]));
      ASSERT(WTF::holds_alternative&lt;AST::ConstantExpression&gt;(nativeTypeDeclaration.typeArguments()[2]));
<span class="line-removed">-     auto&amp; innerType = static_cast&lt;AST::TypeReference&amp;&gt;(WTF::get&lt;UniqueRef&lt;AST::TypeReference&gt;&gt;(nativeTypeDeclaration.typeArguments()[0]));</span>
<span class="line-removed">-     auto&amp; rowExpression = WTF::get&lt;AST::ConstantExpression&gt;(nativeTypeDeclaration.typeArguments()[1]);</span>
<span class="line-removed">-     auto&amp; columnExpression = WTF::get&lt;AST::ConstantExpression&gt;(nativeTypeDeclaration.typeArguments()[2]);</span>
<span class="line-removed">-     ASSERT(!innerType.typeArguments().size());</span>
<span class="line-removed">-     AST::NativeTypeDeclaration* (*array)[3];</span>
<span class="line-removed">-     if (innerType.name() == &quot;half&quot;)</span>
<span class="line-removed">-         array = m_matrixHalf;</span>
<span class="line-removed">-     if (innerType.name() == &quot;float&quot;)</span>
<span class="line-removed">-         array = m_matrixFloat;</span>
<span class="line-removed">-     int row = rowExpression.integerLiteral().value();</span>
<span class="line-removed">-     ASSERT(row &gt;= 2 &amp;&amp; row &lt;= 4);</span>
<span class="line-removed">-     int column = columnExpression.integerLiteral().value();</span>
<span class="line-removed">-     ASSERT(column &gt;= 2 &amp;&amp; column &lt;= 4);</span>
<span class="line-removed">-     nativeTypeDeclaration.setIsMatrix();</span>
<span class="line-removed">-     array[row - 2][column - 2] = &amp;nativeTypeDeclaration;</span>
      return true;
  }
  
  bool Intrinsics::addFullTexture(AST::NativeTypeDeclaration&amp; nativeTypeDeclaration, AST::TypeReference&amp; innerType)
  {
<span class="line-modified">!     unsigned textureTypeIndex = WTF_ARRAY_LENGTH(m_textureTypeNames);</span>
<span class="line-removed">-     for (unsigned i = 0; i &lt; WTF_ARRAY_LENGTH(m_textureTypeNames); ++i) {</span>
<span class="line-removed">-         if (nativeTypeDeclaration.name() == m_textureTypeNames[i])</span>
<span class="line-removed">-             textureTypeIndex = i;</span>
<span class="line-removed">-     }</span>
      if (textureTypeIndex == WTF_ARRAY_LENGTH(m_textureTypeNames))
          return false;
  
      unsigned innerTypeIndex = WTF_ARRAY_LENGTH(m_textureInnerTypeNames);
      unsigned vectorLength;
      for (unsigned i = 0; i &lt; WTF_ARRAY_LENGTH(m_textureInnerTypeNames); ++i) {
          if (innerType.name().startsWith(m_textureInnerTypeNames[i])) {
<span class="line-modified">!             textureTypeIndex = i;</span>
              if (innerType.name() == m_textureInnerTypeNames[i])
                  vectorLength = 1;
              else {
                  ASSERT(innerType.name().length() == strlen(m_textureInnerTypeNames[i]) + 1);
                  ASSERT(innerType.name()[innerType.name().length() - 1] == &#39;2&#39;
<span class="line-new-header">--- 185,30 ---</span>
  bool Intrinsics::addMatrix(AST::NativeTypeDeclaration&amp; nativeTypeDeclaration)
  {
      if (nativeTypeDeclaration.name() != &quot;matrix&quot;)
          return false;
  
<span class="line-added">+     nativeTypeDeclaration.setIsMatrix();</span>
<span class="line-added">+ </span>
      ASSERT(nativeTypeDeclaration.typeArguments().size() == 3);
<span class="line-modified">!     ASSERT(WTF::holds_alternative&lt;Ref&lt;AST::TypeReference&gt;&gt;(nativeTypeDeclaration.typeArguments()[0]));</span>
      ASSERT(WTF::holds_alternative&lt;AST::ConstantExpression&gt;(nativeTypeDeclaration.typeArguments()[1]));
      ASSERT(WTF::holds_alternative&lt;AST::ConstantExpression&gt;(nativeTypeDeclaration.typeArguments()[2]));
      return true;
  }
  
  bool Intrinsics::addFullTexture(AST::NativeTypeDeclaration&amp; nativeTypeDeclaration, AST::TypeReference&amp; innerType)
  {
<span class="line-modified">!     auto textureTypeIndex = std::find(m_textureTypeNames, m_textureTypeNames + WTF_ARRAY_LENGTH(m_textureTypeNames), nativeTypeDeclaration.name()) - m_textureTypeNames;</span>
      if (textureTypeIndex == WTF_ARRAY_LENGTH(m_textureTypeNames))
          return false;
  
      unsigned innerTypeIndex = WTF_ARRAY_LENGTH(m_textureInnerTypeNames);
      unsigned vectorLength;
      for (unsigned i = 0; i &lt; WTF_ARRAY_LENGTH(m_textureInnerTypeNames); ++i) {
          if (innerType.name().startsWith(m_textureInnerTypeNames[i])) {
<span class="line-modified">!             innerTypeIndex = i;</span>
              if (innerType.name() == m_textureInnerTypeNames[i])
                  vectorLength = 1;
              else {
                  ASSERT(innerType.name().length() == strlen(m_textureInnerTypeNames[i]) + 1);
                  ASSERT(innerType.name()[innerType.name().length() - 1] == &#39;2&#39;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 369,52 ***</span>
              }
          }
      }
      ASSERT(innerTypeIndex != WTF_ARRAY_LENGTH(m_textureInnerTypeNames));
      nativeTypeDeclaration.setIsTexture();
      m_fullTextures[textureTypeIndex][innerTypeIndex][vectorLength - 1] = &amp;nativeTypeDeclaration;
      return true;
  }
  
<span class="line-modified">! bool Intrinsics::addDepthTexture(AST::NativeTypeDeclaration&amp; nativeTypeDeclaration, AST::TypeReference&amp; innerType)</span>
  {
<span class="line-modified">!     AST::NativeTypeDeclaration** texture;</span>
      if (nativeTypeDeclaration.name() == &quot;TextureDepth2D&quot;)
          texture = m_textureDepth2D;
<span class="line-removed">-     else if (nativeTypeDeclaration.name() == &quot;RWTextureDepth2D&quot;)</span>
<span class="line-removed">-         texture = m_rwTextureDepth2D;</span>
      else if (nativeTypeDeclaration.name() == &quot;TextureDepth2DArray&quot;)
          texture = m_textureDepth2DArray;
<span class="line-modified">!     else if (nativeTypeDeclaration.name() == &quot;RWTextureDepth2DArray&quot;)</span>
<span class="line-modified">!         texture = m_rwTextureDepth2DArray;</span>
<span class="line-removed">-     else if (nativeTypeDeclaration.name() == &quot;TextureDepthCube&quot;)</span>
          texture = m_textureDepthCube;
<span class="line-removed">-     else</span>
<span class="line-removed">-         ASSERT_NOT_REACHED();</span>
<span class="line-removed">-     unsigned innerTypeIndex = WTF_ARRAY_LENGTH(m_depthTextureInnerTypes);</span>
<span class="line-removed">-     for (unsigned i = 0; i &lt; WTF_ARRAY_LENGTH(m_depthTextureInnerTypes); ++i) {</span>
<span class="line-removed">-         if (innerType.name() == m_depthTextureInnerTypes[i])</span>
<span class="line-removed">-             innerTypeIndex = i;</span>
      }
      ASSERT(innerTypeIndex != WTF_ARRAY_LENGTH(m_depthTextureInnerTypes));
      nativeTypeDeclaration.setIsTexture();
      texture[innerTypeIndex] = &amp;nativeTypeDeclaration;
<span class="line-removed">-     return true;</span>
  }
  
  void Intrinsics::addTexture(AST::NativeTypeDeclaration&amp; nativeTypeDeclaration)
  {
      ASSERT(nativeTypeDeclaration.typeArguments().size() == 1);
<span class="line-modified">!     ASSERT(WTF::holds_alternative&lt;UniqueRef&lt;AST::TypeReference&gt;&gt;(nativeTypeDeclaration.typeArguments()[0]));</span>
<span class="line-modified">!     auto&amp; innerType = static_cast&lt;AST::TypeReference&amp;&gt;(WTF::get&lt;UniqueRef&lt;AST::TypeReference&gt;&gt;(nativeTypeDeclaration.typeArguments()[0]));</span>
      ASSERT(!innerType.typeArguments().size());
      if (addFullTexture(nativeTypeDeclaration, innerType)) {
          m_textureSet.add(&amp;nativeTypeDeclaration);
          return;
      }
<span class="line-modified">!     if (addDepthTexture(nativeTypeDeclaration, innerType))</span>
<span class="line-modified">!         m_textureSet.add(&amp;nativeTypeDeclaration);</span>
  }
  
  void Intrinsics::add(AST::NativeTypeDeclaration&amp; nativeTypeDeclaration)
  {
      if (addPrimitive(nativeTypeDeclaration))
<span class="line-new-header">--- 218,59 ---</span>
              }
          }
      }
      ASSERT(innerTypeIndex != WTF_ARRAY_LENGTH(m_textureInnerTypeNames));
      nativeTypeDeclaration.setIsTexture();
<span class="line-added">+     nativeTypeDeclaration.setIsOpaqueType();</span>
<span class="line-added">+     if (nativeTypeDeclaration.name() == &quot;Texture1DArray&quot; || nativeTypeDeclaration.name() == &quot;RWTexture1DArray&quot; || nativeTypeDeclaration.name() == &quot;Texture2DArray&quot; || nativeTypeDeclaration.name() == &quot;RWTexture2DArray&quot;)</span>
<span class="line-added">+         nativeTypeDeclaration.setIsTextureArray();</span>
<span class="line-added">+     if (nativeTypeDeclaration.name() == &quot;RWTexture1D&quot; || nativeTypeDeclaration.name() == &quot;RWTexture2D&quot; || nativeTypeDeclaration.name() == &quot;RWTexture3D&quot; || nativeTypeDeclaration.name() == &quot;RWTexture1DArray&quot; || nativeTypeDeclaration.name() == &quot;RWTexture2DArray&quot;)</span>
<span class="line-added">+         nativeTypeDeclaration.setIsWritableTexture();</span>
<span class="line-added">+     if (nativeTypeDeclaration.name() == &quot;Texture1D&quot; || nativeTypeDeclaration.name() == &quot;RWTexture1D&quot; || nativeTypeDeclaration.name() == &quot;Texture1DArray&quot; || nativeTypeDeclaration.name() == &quot;RWTexture1DArray&quot;)</span>
<span class="line-added">+         nativeTypeDeclaration.setTextureDimension(1);</span>
<span class="line-added">+     if (nativeTypeDeclaration.name() == &quot;Texture2D&quot; || nativeTypeDeclaration.name() == &quot;RWTexture2D&quot; || nativeTypeDeclaration.name() == &quot;TextureCube&quot; || nativeTypeDeclaration.name() == &quot;Texture2DArray&quot; || nativeTypeDeclaration.name() == &quot;RWTexture2DArray&quot;)</span>
<span class="line-added">+         nativeTypeDeclaration.setTextureDimension(2);</span>
<span class="line-added">+     if (nativeTypeDeclaration.name() == &quot;Texture3D&quot; || nativeTypeDeclaration.name() == &quot;RWTexture3D&quot;)</span>
<span class="line-added">+         nativeTypeDeclaration.setTextureDimension(3);</span>
      m_fullTextures[textureTypeIndex][innerTypeIndex][vectorLength - 1] = &amp;nativeTypeDeclaration;
      return true;
  }
  
<span class="line-modified">! void Intrinsics::addDepthTexture(AST::NativeTypeDeclaration&amp; nativeTypeDeclaration, AST::TypeReference&amp; innerType)</span>
  {
<span class="line-modified">!     AST::NativeTypeDeclaration** texture = nullptr;</span>
      if (nativeTypeDeclaration.name() == &quot;TextureDepth2D&quot;)
          texture = m_textureDepth2D;
      else if (nativeTypeDeclaration.name() == &quot;TextureDepth2DArray&quot;)
          texture = m_textureDepth2DArray;
<span class="line-modified">!     else {</span>
<span class="line-modified">!         ASSERT(nativeTypeDeclaration.name() == &quot;TextureDepthCube&quot;);</span>
          texture = m_textureDepthCube;
      }
<span class="line-added">+     auto innerTypeIndex = std::find(m_depthTextureInnerTypes, m_depthTextureInnerTypes + WTF_ARRAY_LENGTH(m_depthTextureInnerTypes), innerType.name()) - m_depthTextureInnerTypes;</span>
      ASSERT(innerTypeIndex != WTF_ARRAY_LENGTH(m_depthTextureInnerTypes));
      nativeTypeDeclaration.setIsTexture();
<span class="line-added">+     nativeTypeDeclaration.setIsOpaqueType();</span>
<span class="line-added">+     if (texture == m_textureDepth2DArray)</span>
<span class="line-added">+         nativeTypeDeclaration.setIsTextureArray();</span>
<span class="line-added">+     nativeTypeDeclaration.setTextureDimension(2);</span>
<span class="line-added">+     nativeTypeDeclaration.setIsDepthTexture();</span>
      texture[innerTypeIndex] = &amp;nativeTypeDeclaration;
  }
  
  void Intrinsics::addTexture(AST::NativeTypeDeclaration&amp; nativeTypeDeclaration)
  {
      ASSERT(nativeTypeDeclaration.typeArguments().size() == 1);
<span class="line-modified">!     ASSERT(WTF::holds_alternative&lt;Ref&lt;AST::TypeReference&gt;&gt;(nativeTypeDeclaration.typeArguments()[0]));</span>
<span class="line-modified">!     auto&amp; innerType = static_cast&lt;AST::TypeReference&amp;&gt;(WTF::get&lt;Ref&lt;AST::TypeReference&gt;&gt;(nativeTypeDeclaration.typeArguments()[0]));</span>
      ASSERT(!innerType.typeArguments().size());
      if (addFullTexture(nativeTypeDeclaration, innerType)) {
          m_textureSet.add(&amp;nativeTypeDeclaration);
          return;
      }
<span class="line-modified">!     addDepthTexture(nativeTypeDeclaration, innerType);</span>
<span class="line-modified">!     m_textureSet.add(&amp;nativeTypeDeclaration);</span>
  }
  
  void Intrinsics::add(AST::NativeTypeDeclaration&amp; nativeTypeDeclaration)
  {
      if (addPrimitive(nativeTypeDeclaration))
</pre>
<center><a href="WHLSLInferTypes.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="WHLSLIntrinsics.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>