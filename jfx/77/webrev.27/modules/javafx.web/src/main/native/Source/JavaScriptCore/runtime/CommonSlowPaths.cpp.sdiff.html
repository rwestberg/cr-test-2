<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/CommonSlowPaths.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CommonIdentifiers.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CommonSlowPaths.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/CommonSlowPaths.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  55 #include &quot;JSPropertyNameEnumerator.h&quot;
  56 #include &quot;JSString.h&quot;
  57 #include &quot;JSWithScope.h&quot;
  58 #include &quot;LLIntCommon.h&quot;
  59 #include &quot;LLIntExceptions.h&quot;
  60 #include &quot;LowLevelInterpreter.h&quot;
  61 #include &quot;MathCommon.h&quot;
  62 #include &quot;ObjectConstructor.h&quot;
  63 #include &quot;OpcodeInlines.h&quot;
  64 #include &quot;ScopedArguments.h&quot;
  65 #include &quot;StructureRareDataInlines.h&quot;
  66 #include &quot;ThunkGenerators.h&quot;
  67 #include &quot;TypeProfilerLog.h&quot;
  68 #include &lt;wtf/StringPrintStream.h&gt;
  69 #include &lt;wtf/Variant.h&gt;
  70 
  71 namespace JSC {
  72 
  73 #define BEGIN_NO_SET_PC() \
  74     VM&amp; vm = exec-&gt;vm();      \
<span class="line-modified">  75     NativeCallFrameTracer tracer(&amp;vm, exec); \</span>
  76     auto throwScope = DECLARE_THROW_SCOPE(vm); \
  77     UNUSED_PARAM(throwScope)
  78 
  79 #ifndef NDEBUG
  80 #define SET_PC_FOR_STUBS() do { \
  81         exec-&gt;codeBlock()-&gt;bytecodeOffset(pc); \
  82         exec-&gt;setCurrentVPC(pc); \
  83     } while (false)
  84 #else
  85 #define SET_PC_FOR_STUBS() do { \
  86         exec-&gt;setCurrentVPC(pc); \
  87     } while (false)
  88 #endif
  89 
  90 #define RETURN_TO_THROW(exec, pc)   pc = LLInt::returnToThrow(exec)
  91 
  92 #define BEGIN()                           \
  93     BEGIN_NO_SET_PC();                    \
  94     SET_PC_FOR_STUBS()
  95 
</pre>
<hr />
<pre>
 163             CALL_END_IMPL(cceExec, LLInt::callToThrow(cceExec), ExceptionHandlerPtrTag); \
 164     } while (false)
 165 
 166 static void throwArityCheckStackOverflowError(ExecState* exec, ThrowScope&amp; scope)
 167 {
 168     JSObject* error = createStackOverflowError(exec);
 169     throwException(exec, scope, error);
 170 #if LLINT_TRACING
 171     if (UNLIKELY(Options::traceLLIntSlowPath()))
 172         dataLog(&quot;Throwing exception &quot;, JSValue(scope.exception()), &quot;.\n&quot;);
 173 #endif
 174 }
 175 
 176 SLOW_PATH_DECL(slow_path_call_arityCheck)
 177 {
 178     BEGIN();
 179     int slotsToAdd = CommonSlowPaths::arityCheckFor(exec, vm, CodeForCall);
 180     if (UNLIKELY(slotsToAdd &lt; 0)) {
 181         CodeBlock* codeBlock = CommonSlowPaths::codeBlockFromCallFrameCallee(exec, CodeForCall);
 182         exec-&gt;convertToStackOverflowFrame(vm, codeBlock);
<span class="line-modified"> 183         NativeCallFrameTracer tracer(&amp;vm, exec);</span>
 184         ErrorHandlingScope errorScope(vm);
 185         throwScope.release();
 186         throwArityCheckStackOverflowError(exec, throwScope);
 187         RETURN_TWO(bitwise_cast&lt;void*&gt;(static_cast&lt;uintptr_t&gt;(1)), exec);
 188     }
 189     RETURN_TWO(0, bitwise_cast&lt;void*&gt;(static_cast&lt;uintptr_t&gt;(slotsToAdd)));
 190 }
 191 
 192 SLOW_PATH_DECL(slow_path_construct_arityCheck)
 193 {
 194     BEGIN();
 195     int slotsToAdd = CommonSlowPaths::arityCheckFor(exec, vm, CodeForConstruct);
 196     if (UNLIKELY(slotsToAdd &lt; 0)) {
 197         CodeBlock* codeBlock = CommonSlowPaths::codeBlockFromCallFrameCallee(exec, CodeForConstruct);
 198         exec-&gt;convertToStackOverflowFrame(vm, codeBlock);
<span class="line-modified"> 199         NativeCallFrameTracer tracer(&amp;vm, exec);</span>
 200         ErrorHandlingScope errorScope(vm);
 201         throwArityCheckStackOverflowError(exec, throwScope);
 202         RETURN_TWO(bitwise_cast&lt;void*&gt;(static_cast&lt;uintptr_t&gt;(1)), exec);
 203     }
 204     RETURN_TWO(0, bitwise_cast&lt;void*&gt;(static_cast&lt;uintptr_t&gt;(slotsToAdd)));
 205 }
 206 
 207 SLOW_PATH_DECL(slow_path_create_direct_arguments)
 208 {
 209     BEGIN();
 210     auto bytecode = pc-&gt;as&lt;OpCreateDirectArguments&gt;();
 211     RETURN(DirectArguments::createByCopying(exec));
 212 }
 213 
 214 SLOW_PATH_DECL(slow_path_create_scoped_arguments)
 215 {
 216     BEGIN();
 217     auto bytecode = pc-&gt;as&lt;OpCreateScopedArguments&gt;();
 218     JSLexicalEnvironment* scope = jsCast&lt;JSLexicalEnvironment*&gt;(GET(bytecode.m_scope).jsValue());
 219     ScopedArgumentsTable* table = scope-&gt;symbolTable()-&gt;arguments();
</pre>
<hr />
<pre>
 225     BEGIN();
 226     auto bytecode = pc-&gt;as&lt;OpCreateClonedArguments&gt;();
 227     RETURN(ClonedArguments::createWithMachineFrame(exec, exec, ArgumentsMode::Cloned));
 228 }
 229 
 230 SLOW_PATH_DECL(slow_path_create_this)
 231 {
 232     BEGIN();
 233     auto bytecode = pc-&gt;as&lt;OpCreateThis&gt;();
 234     JSObject* result;
 235     JSObject* constructorAsObject = asObject(GET(bytecode.m_callee).jsValue());
 236     if (constructorAsObject-&gt;type() == JSFunctionType &amp;&amp; jsCast&lt;JSFunction*&gt;(constructorAsObject)-&gt;canUseAllocationProfile()) {
 237         JSFunction* constructor = jsCast&lt;JSFunction*&gt;(constructorAsObject);
 238         WriteBarrier&lt;JSCell&gt;&amp; cachedCallee = bytecode.metadata(exec).m_cachedCallee;
 239         if (!cachedCallee)
 240             cachedCallee.set(vm, exec-&gt;codeBlock(), constructor);
 241         else if (cachedCallee.unvalidatedGet() != JSCell::seenMultipleCalleeObjects() &amp;&amp; cachedCallee.get() != constructor)
 242             cachedCallee.setWithoutWriteBarrier(JSCell::seenMultipleCalleeObjects());
 243 
 244         size_t inlineCapacity = bytecode.m_inlineCapacity;
<span class="line-modified"> 245         ObjectAllocationProfile* allocationProfile = constructor-&gt;ensureRareDataAndAllocationProfile(exec, inlineCapacity)-&gt;objectAllocationProfile();</span>
 246         throwScope.releaseAssertNoException();
 247         Structure* structure = allocationProfile-&gt;structure();
 248         result = constructEmptyObject(exec, structure);
 249         if (structure-&gt;hasPolyProto()) {
 250             JSObject* prototype = allocationProfile-&gt;prototype();
 251             ASSERT(prototype == constructor-&gt;prototypeForConstruction(vm, exec));
 252             result-&gt;putDirect(vm, knownPolyProtoOffset, prototype);
 253             prototype-&gt;didBecomePrototype();
 254             ASSERT_WITH_MESSAGE(!hasIndexedProperties(result-&gt;indexingType()), &quot;We rely on JSFinalObject not starting out with an indexing type otherwise we would potentially need to convert to slow put storage&quot;);
 255         }
 256     } else {
 257         // http://ecma-international.org/ecma-262/6.0/#sec-ordinarycreatefromconstructor
 258         JSValue proto = constructorAsObject-&gt;get(exec, vm.propertyNames-&gt;prototype);
 259         CHECK_EXCEPTION();
 260         if (proto.isObject())
 261             result = constructEmptyObject(exec, asObject(proto));
 262         else
 263             result = constructEmptyObject(exec);
 264     }
 265     RETURN(result);
 266 }
 267 
 268 SLOW_PATH_DECL(slow_path_to_this)
 269 {
 270     BEGIN();
 271     auto bytecode = pc-&gt;as&lt;OpToThis&gt;();
 272     auto&amp; metadata = bytecode.metadata(exec);
 273     JSValue v1 = GET(bytecode.m_srcDst).jsValue();
 274     if (v1.isCell()) {
<span class="line-modified"> 275         Structure* myStructure = v1.asCell()-&gt;structure(vm);</span>
<span class="line-modified"> 276         Structure* otherStructure = metadata.m_cachedStructure.get();</span>
<span class="line-modified"> 277         if (myStructure != otherStructure) {</span>
<span class="line-modified"> 278             if (otherStructure)</span>
 279                 metadata.m_toThisStatus = ToThisConflicted;
<span class="line-modified"> 280             metadata.m_cachedStructure.set(vm, exec-&gt;codeBlock(), myStructure);</span>

 281         }
 282     } else {
 283         metadata.m_toThisStatus = ToThisConflicted;
<span class="line-modified"> 284         metadata.m_cachedStructure.clear();</span>
 285     }
 286     // Note: We only need to do this value profiling here on the slow path. The fast path
 287     // just returns the input to to_this if the structure check succeeds. If the structure
 288     // check succeeds, doing value profiling here is equivalent to doing it with a potentially
 289     // different object that still has the same structure on the fast path since it&#39;ll produce
 290     // the same SpeculatedType. Therefore, we don&#39;t need to worry about value profiling on the
 291     // fast path.
 292     auto value = v1.toThis(exec, exec-&gt;codeBlock()-&gt;isStrictMode() ? StrictMode : NotStrictMode);
 293     RETURN_WITH_PROFILING_CUSTOM(bytecode.m_srcDst, value, PROFILE_VALUE(value));
 294 }
 295 
 296 SLOW_PATH_DECL(slow_path_throw_tdz_error)
 297 {
 298     BEGIN();
 299     THROW(createTDZError(exec));
 300 }
 301 
 302 SLOW_PATH_DECL(slow_path_check_tdz)
 303 {
 304     BEGIN();
</pre>
<hr />
<pre>
 618 
 619     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 620         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 621             JSBigInt* result = JSBigInt::remainder(exec, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));
 622             CHECK_EXCEPTION();
 623             RETURN(result);
 624         }
 625 
 626         THROW(createTypeError(exec, &quot;Invalid mix of BigInt and other type in remainder operation.&quot;));
 627     }
 628 
 629     double a = WTF::get&lt;double&gt;(leftNumeric);
 630     double b = WTF::get&lt;double&gt;(rightNumeric);
 631     RETURN(jsNumber(jsMod(a, b)));
 632 }
 633 
 634 SLOW_PATH_DECL(slow_path_pow)
 635 {
 636     BEGIN();
 637     auto bytecode = pc-&gt;as&lt;OpPow&gt;();
<span class="line-modified"> 638     double a = GET_C(bytecode.m_lhs).jsValue().toNumber(exec);</span>
<span class="line-modified"> 639     if (UNLIKELY(throwScope.exception()))</span>
<span class="line-modified"> 640         RETURN(JSValue());</span>
<span class="line-modified"> 641     double b = GET_C(bytecode.m_rhs).jsValue().toNumber(exec);</span>
<span class="line-modified"> 642     if (UNLIKELY(throwScope.exception()))</span>
<span class="line-modified"> 643         RETURN(JSValue());</span>














 644     RETURN(jsNumber(operationMathPow(a, b)));
 645 }
 646 
 647 SLOW_PATH_DECL(slow_path_lshift)
 648 {
 649     BEGIN();
 650     auto bytecode = pc-&gt;as&lt;OpLshift&gt;();
 651     JSValue left = GET_C(bytecode.m_lhs).jsValue();
 652     JSValue right = GET_C(bytecode.m_rhs).jsValue();
 653     auto leftNumeric = left.toBigIntOrInt32(exec);
 654     CHECK_EXCEPTION();
 655     auto rightNumeric = right.toBigIntOrInt32(exec);
 656     CHECK_EXCEPTION();
 657 
 658     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 659         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 660             JSBigInt* result = JSBigInt::leftShift(exec, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));
 661             CHECK_EXCEPTION();
<span class="line-modified"> 662             RETURN(result);</span>
 663         }
 664 
 665         THROW(createTypeError(exec, &quot;Invalid mix of BigInt and other type in left shift operation.&quot;));
 666     }
 667 
<span class="line-modified"> 668     RETURN(jsNumber(WTF::get&lt;int32_t&gt;(leftNumeric) &lt;&lt; (WTF::get&lt;int32_t&gt;(rightNumeric) &amp; 31)));</span>
 669 }
 670 
 671 SLOW_PATH_DECL(slow_path_rshift)
 672 {
 673     BEGIN();
 674     auto bytecode = pc-&gt;as&lt;OpRshift&gt;();
 675     JSValue left = GET_C(bytecode.m_lhs).jsValue();
 676     JSValue right = GET_C(bytecode.m_rhs).jsValue();
 677     auto leftNumeric = left.toBigIntOrInt32(exec);
 678     CHECK_EXCEPTION();
 679     auto rightNumeric = right.toBigIntOrInt32(exec);
 680     CHECK_EXCEPTION();
 681 
 682     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 683         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 684             JSBigInt* result = JSBigInt::signedRightShift(exec, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));
 685             CHECK_EXCEPTION();
 686             RETURN(result);
 687         }
 688 
</pre>
<hr />
<pre>
 698     auto bytecode = pc-&gt;as&lt;OpUrshift&gt;();
 699     uint32_t a = GET_C(bytecode.m_lhs).jsValue().toUInt32(exec);
 700     if (UNLIKELY(throwScope.exception()))
 701         RETURN(JSValue());
 702     uint32_t b = GET_C(bytecode.m_rhs).jsValue().toUInt32(exec);
 703     RETURN(jsNumber(static_cast&lt;int32_t&gt;(a &gt;&gt; (b &amp; 31))));
 704 }
 705 
 706 SLOW_PATH_DECL(slow_path_unsigned)
 707 {
 708     BEGIN();
 709     auto bytecode = pc-&gt;as&lt;OpUnsigned&gt;();
 710     uint32_t a = GET_C(bytecode.m_operand).jsValue().toUInt32(exec);
 711     RETURN(jsNumber(a));
 712 }
 713 
 714 SLOW_PATH_DECL(slow_path_bitnot)
 715 {
 716     BEGIN();
 717     auto bytecode = pc-&gt;as&lt;OpBitnot&gt;();
<span class="line-modified"> 718     int32_t operand = GET_C(bytecode.m_operand).jsValue().toInt32(exec);</span>
 719     CHECK_EXCEPTION();
<span class="line-modified"> 720     RETURN_PROFILED(jsNumber(~operand));</span>







 721 }
 722 
 723 SLOW_PATH_DECL(slow_path_bitand)
 724 {
 725     BEGIN();
 726     auto bytecode = pc-&gt;as&lt;OpBitand&gt;();
 727     auto leftNumeric = GET_C(bytecode.m_lhs).jsValue().toBigIntOrInt32(exec);
 728     CHECK_EXCEPTION();
 729     auto rightNumeric = GET_C(bytecode.m_rhs).jsValue().toBigIntOrInt32(exec);
 730     CHECK_EXCEPTION();
 731     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 732         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 733             JSBigInt* result = JSBigInt::bitwiseAnd(exec, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));
 734             CHECK_EXCEPTION();
 735             RETURN_PROFILED(result);
 736         }
 737 
 738         THROW(createTypeError(exec, &quot;Invalid mix of BigInt and other type in bitwise &#39;and&#39; operation.&quot;));
 739     }
 740 
</pre>
<hr />
<pre>
 849     if (!couldDelete &amp;&amp; exec-&gt;codeBlock()-&gt;isStrictMode())
 850         THROW(createTypeError(exec, UnableToDeletePropertyError));
 851 
 852     RETURN(jsBoolean(couldDelete));
 853 }
 854 
 855 SLOW_PATH_DECL(slow_path_strcat)
 856 {
 857     BEGIN();
 858     auto bytecode = pc-&gt;as&lt;OpStrcat&gt;();
 859     RETURN(jsStringFromRegisterArray(exec, &amp;GET(bytecode.m_src), bytecode.m_count));
 860 }
 861 
 862 SLOW_PATH_DECL(slow_path_to_primitive)
 863 {
 864     BEGIN();
 865     auto bytecode = pc-&gt;as&lt;OpToPrimitive&gt;();
 866     RETURN(GET_C(bytecode.m_src).jsValue().toPrimitive(exec));
 867 }
 868 
<span class="line-removed"> 869 SLOW_PATH_DECL(slow_path_enter)</span>
<span class="line-removed"> 870 {</span>
<span class="line-removed"> 871     BEGIN();</span>
<span class="line-removed"> 872     CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
<span class="line-removed"> 873     Heap::heap(codeBlock)-&gt;writeBarrier(codeBlock);</span>
<span class="line-removed"> 874     END();</span>
<span class="line-removed"> 875 }</span>
<span class="line-removed"> 876 </span>
 877 SLOW_PATH_DECL(slow_path_get_enumerable_length)
 878 {
 879     BEGIN();
 880     auto bytecode = pc-&gt;as&lt;OpGetEnumerableLength&gt;();
 881     JSValue enumeratorValue = GET(bytecode.m_base).jsValue();
 882     if (enumeratorValue.isUndefinedOrNull())
 883         RETURN(jsNumber(0));
 884 
 885     JSPropertyNameEnumerator* enumerator = jsCast&lt;JSPropertyNameEnumerator*&gt;(enumeratorValue.asCell());
 886 
 887     RETURN(jsNumber(enumerator-&gt;indexedLength()));
 888 }
 889 
 890 SLOW_PATH_DECL(slow_path_has_indexed_property)
 891 {
 892     BEGIN();
 893     auto bytecode = pc-&gt;as&lt;OpHasIndexedProperty&gt;();
 894     auto&amp; metadata = bytecode.metadata(exec);
 895     JSObject* base = GET(bytecode.m_base).jsValue().toObject(exec);
 896     CHECK_EXCEPTION();
 897     JSValue property = GET(bytecode.m_property).jsValue();
 898     metadata.m_arrayProfile.observeStructure(base-&gt;structure(vm));
<span class="line-modified"> 899     ASSERT(property.isUInt32());</span>
<span class="line-modified"> 900     RETURN(jsBoolean(base-&gt;hasPropertyGeneric(exec, property.asUInt32(), PropertySlot::InternalMethodType::GetOwnProperty)));</span>
 901 }
 902 
 903 SLOW_PATH_DECL(slow_path_has_structure_property)
 904 {
 905     BEGIN();
 906     auto bytecode = pc-&gt;as&lt;OpHasStructureProperty&gt;();
 907     JSObject* base = GET(bytecode.m_base).jsValue().toObject(exec);
 908     CHECK_EXCEPTION();
 909     JSValue property = GET(bytecode.m_property).jsValue();
 910     ASSERT(property.isString());
 911     JSPropertyNameEnumerator* enumerator = jsCast&lt;JSPropertyNameEnumerator*&gt;(GET(bytecode.m_enumerator).jsValue().asCell());
 912     if (base-&gt;structure(vm)-&gt;id() == enumerator-&gt;cachedStructureID())
 913         RETURN(jsBoolean(true));
 914     JSString* string = asString(property);
 915     auto propertyName = string-&gt;toIdentifier(exec);
 916     CHECK_EXCEPTION();
 917     RETURN(jsBoolean(base-&gt;hasPropertyGeneric(exec, propertyName, PropertySlot::InternalMethodType::GetOwnProperty)));
 918 }
 919 
 920 SLOW_PATH_DECL(slow_path_has_generic_property)
</pre>
<hr />
<pre>
 933 
 934 SLOW_PATH_DECL(slow_path_get_direct_pname)
 935 {
 936     BEGIN();
 937     auto bytecode = pc-&gt;as&lt;OpGetDirectPname&gt;();
 938     JSValue baseValue = GET_C(bytecode.m_base).jsValue();
 939     JSValue property = GET(bytecode.m_property).jsValue();
 940     ASSERT(property.isString());
 941     JSString* string = asString(property);
 942     auto propertyName = string-&gt;toIdentifier(exec);
 943     CHECK_EXCEPTION();
 944     RETURN(baseValue.get(exec, propertyName));
 945 }
 946 
 947 SLOW_PATH_DECL(slow_path_get_property_enumerator)
 948 {
 949     BEGIN();
 950     auto bytecode = pc-&gt;as&lt;OpGetPropertyEnumerator&gt;();
 951     JSValue baseValue = GET(bytecode.m_base).jsValue();
 952     if (baseValue.isUndefinedOrNull())
<span class="line-modified"> 953         RETURN(JSPropertyNameEnumerator::create(vm));</span>
 954 
 955     JSObject* base = baseValue.toObject(exec);
 956     CHECK_EXCEPTION();
 957 
 958     RETURN(propertyNameEnumerator(exec, base));
 959 }
 960 
 961 SLOW_PATH_DECL(slow_path_enumerator_structure_pname)
 962 {
 963     BEGIN();
 964     auto bytecode = pc-&gt;as&lt;OpEnumeratorStructurePname&gt;();
 965     JSPropertyNameEnumerator* enumerator = jsCast&lt;JSPropertyNameEnumerator*&gt;(GET(bytecode.m_enumerator).jsValue().asCell());
 966     uint32_t index = GET(bytecode.m_index).jsValue().asUInt32();
 967 
 968     JSString* propertyName = nullptr;
 969     if (index &lt; enumerator-&gt;endStructurePropertyIndex())
 970         propertyName = enumerator-&gt;propertyNameAtIndex(index);
 971     RETURN(propertyName ? propertyName : jsNull());
 972 }
 973 
 974 SLOW_PATH_DECL(slow_path_enumerator_generic_pname)
 975 {
 976     BEGIN();
 977     auto bytecode = pc-&gt;as&lt;OpEnumeratorGenericPname&gt;();
 978     JSPropertyNameEnumerator* enumerator = jsCast&lt;JSPropertyNameEnumerator*&gt;(GET(bytecode.m_enumerator).jsValue().asCell());
 979     uint32_t index = GET(bytecode.m_index).jsValue().asUInt32();
 980 
 981     JSString* propertyName = nullptr;
 982     if (enumerator-&gt;endStructurePropertyIndex() &lt;= index &amp;&amp; index &lt; enumerator-&gt;endGenericPropertyIndex())
 983         propertyName = enumerator-&gt;propertyNameAtIndex(index);
 984     RETURN(propertyName ? propertyName : jsNull());
 985 }
 986 
 987 SLOW_PATH_DECL(slow_path_to_index_string)
 988 {
 989     BEGIN();
 990     auto bytecode = pc-&gt;as&lt;OpToIndexString&gt;();
<span class="line-modified"> 991     RETURN(jsString(exec, Identifier::from(exec, GET(bytecode.m_index).jsValue().asUInt32()).string()));</span>


 992 }
 993 
 994 SLOW_PATH_DECL(slow_path_profile_type_clear_log)
 995 {
 996     BEGIN();
 997     vm.typeProfilerLog()-&gt;processLogEntries(vm, &quot;LLInt log full.&quot;_s);
 998     END();
 999 }
1000 
1001 SLOW_PATH_DECL(slow_path_unreachable)
1002 {
1003     BEGIN();
1004     UNREACHABLE_FOR_PLATFORM();
1005     END();
1006 }
1007 
1008 SLOW_PATH_DECL(slow_path_create_lexical_environment)
1009 {
1010     BEGIN();
1011     auto bytecode = pc-&gt;as&lt;OpCreateLexicalEnvironment&gt;();
</pre>
<hr />
<pre>
1031 }
1032 
1033 SLOW_PATH_DECL(slow_path_resolve_scope_for_hoisting_func_decl_in_eval)
1034 {
1035     BEGIN();
1036     auto bytecode = pc-&gt;as&lt;OpResolveScopeForHoistingFuncDeclInEval&gt;();
1037     const Identifier&amp; ident = exec-&gt;codeBlock()-&gt;identifier(bytecode.m_property);
1038     JSScope* scope = exec-&gt;uncheckedR(bytecode.m_scope.offset()).Register::scope();
1039     JSValue resolvedScope = JSScope::resolveScopeForHoistingFuncDeclInEval(exec, scope, ident);
1040 
1041     CHECK_EXCEPTION();
1042 
1043     RETURN(resolvedScope);
1044 }
1045 
1046 SLOW_PATH_DECL(slow_path_resolve_scope)
1047 {
1048     BEGIN();
1049     auto bytecode = pc-&gt;as&lt;OpResolveScope&gt;();
1050     auto&amp; metadata = bytecode.metadata(exec);
<span class="line-modified">1051     const Identifier&amp; ident = exec-&gt;codeBlock()-&gt;identifier(bytecode.m_var);</span>

1052     JSScope* scope = exec-&gt;uncheckedR(bytecode.m_scope.offset()).Register::scope();
1053     JSObject* resolvedScope = JSScope::resolve(exec, scope, ident);
1054     // Proxy can throw an error here, e.g. Proxy in with statement&#39;s @unscopables.
1055     CHECK_EXCEPTION();
1056 
1057     ResolveType resolveType = metadata.m_resolveType;
1058 
1059     // ModuleVar does not keep the scope register value alive in DFG.
1060     ASSERT(resolveType != ModuleVar);
1061 
1062     switch (resolveType) {
1063     case GlobalProperty:
1064     case GlobalPropertyWithVarInjectionChecks:
1065     case UnresolvedProperty:
1066     case UnresolvedPropertyWithVarInjectionChecks: {
1067         if (resolvedScope-&gt;isGlobalObject()) {
1068             JSGlobalObject* globalObject = jsCast&lt;JSGlobalObject*&gt;(resolvedScope);
1069             bool hasProperty = globalObject-&gt;hasProperty(exec, ident);
1070             CHECK_EXCEPTION();
1071             if (hasProperty) {
<span class="line-modified">1072                 ConcurrentJSLocker locker(exec-&gt;codeBlock()-&gt;m_lock);</span>
1073                 metadata.m_resolveType = needsVarInjectionChecks(resolveType) ? GlobalPropertyWithVarInjectionChecks : GlobalProperty;
<span class="line-modified">1074                 metadata.m_globalObject = globalObject;</span>
1075                 metadata.m_globalLexicalBindingEpoch = globalObject-&gt;globalLexicalBindingEpoch();
1076             }
1077         } else if (resolvedScope-&gt;isGlobalLexicalEnvironment()) {
1078             JSGlobalLexicalEnvironment* globalLexicalEnvironment = jsCast&lt;JSGlobalLexicalEnvironment*&gt;(resolvedScope);
<span class="line-modified">1079             ConcurrentJSLocker locker(exec-&gt;codeBlock()-&gt;m_lock);</span>
1080             metadata.m_resolveType = needsVarInjectionChecks(resolveType) ? GlobalLexicalVarWithVarInjectionChecks : GlobalLexicalVar;
<span class="line-modified">1081             metadata.m_globalLexicalEnvironment = globalLexicalEnvironment;</span>
1082         }
1083         break;
1084     }
1085     default:
1086         break;
1087     }
1088 
1089     RETURN(resolvedScope);
1090 }
1091 
1092 SLOW_PATH_DECL(slow_path_create_rest)
1093 {
1094     BEGIN();
1095     auto bytecode = pc-&gt;as&lt;OpCreateRest&gt;();
1096     unsigned arraySize = GET_C(bytecode.m_arraySize).jsValue().asUInt32();
1097     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();
1098     Structure* structure = globalObject-&gt;restParameterStructure();
1099     unsigned numParamsToSkip = bytecode.m_numParametersToSkip;
1100     JSValue* argumentsToCopyRegion = exec-&gt;addressOfArgumentsStart() + numParamsToSkip;
1101     RETURN(constructArray(exec, structure, argumentsToCopyRegion, arraySize));
</pre>
<hr />
<pre>
1108     const Identifier&amp; ident = exec-&gt;codeBlock()-&gt;identifier(bytecode.m_property);
1109     JSValue baseValue = GET_C(bytecode.m_base).jsValue();
1110     JSValue thisVal = GET_C(bytecode.m_thisValue).jsValue();
1111     PropertySlot slot(thisVal, PropertySlot::PropertySlot::InternalMethodType::Get);
1112     JSValue result = baseValue.get(exec, ident, slot);
1113     RETURN_PROFILED(result);
1114 }
1115 
1116 SLOW_PATH_DECL(slow_path_get_by_val_with_this)
1117 {
1118     BEGIN();
1119 
1120     auto bytecode = pc-&gt;as&lt;OpGetByValWithThis&gt;();
1121     JSValue baseValue = GET_C(bytecode.m_base).jsValue();
1122     JSValue thisValue = GET_C(bytecode.m_thisValue).jsValue();
1123     JSValue subscript = GET_C(bytecode.m_property).jsValue();
1124 
1125     if (LIKELY(baseValue.isCell() &amp;&amp; subscript.isString())) {
1126         Structure&amp; structure = *baseValue.asCell()-&gt;structure(vm);
1127         if (JSCell::canUseFastGetOwnProperty(structure)) {
<span class="line-modified">1128             if (RefPtr&lt;AtomicStringImpl&gt; existingAtomicString = asString(subscript)-&gt;toExistingAtomicString(exec)) {</span>
<span class="line-modified">1129                 if (JSValue result = baseValue.asCell()-&gt;fastGetOwnProperty(vm, structure, existingAtomicString.get()))</span>


1130                     RETURN_PROFILED(result);
1131             }
1132         }
1133     }
1134 
1135     PropertySlot slot(thisValue, PropertySlot::PropertySlot::InternalMethodType::Get);
1136     if (subscript.isUInt32()) {
1137         uint32_t i = subscript.asUInt32();
1138         if (isJSString(baseValue) &amp;&amp; asString(baseValue)-&gt;canGetIndex(i))
1139             RETURN_PROFILED(asString(baseValue)-&gt;getIndex(exec, i));
1140 
1141         RETURN_PROFILED(baseValue.get(exec, i, slot));
1142     }
1143 
1144     baseValue.requireObjectCoercible(exec);
1145     CHECK_EXCEPTION();
1146     auto property = subscript.toPropertyKey(exec);
1147     CHECK_EXCEPTION();
1148     RETURN_PROFILED(baseValue.get(exec, property, slot));
1149 }
</pre>
</td>
<td>
<hr />
<pre>
  55 #include &quot;JSPropertyNameEnumerator.h&quot;
  56 #include &quot;JSString.h&quot;
  57 #include &quot;JSWithScope.h&quot;
  58 #include &quot;LLIntCommon.h&quot;
  59 #include &quot;LLIntExceptions.h&quot;
  60 #include &quot;LowLevelInterpreter.h&quot;
  61 #include &quot;MathCommon.h&quot;
  62 #include &quot;ObjectConstructor.h&quot;
  63 #include &quot;OpcodeInlines.h&quot;
  64 #include &quot;ScopedArguments.h&quot;
  65 #include &quot;StructureRareDataInlines.h&quot;
  66 #include &quot;ThunkGenerators.h&quot;
  67 #include &quot;TypeProfilerLog.h&quot;
  68 #include &lt;wtf/StringPrintStream.h&gt;
  69 #include &lt;wtf/Variant.h&gt;
  70 
  71 namespace JSC {
  72 
  73 #define BEGIN_NO_SET_PC() \
  74     VM&amp; vm = exec-&gt;vm();      \
<span class="line-modified">  75     NativeCallFrameTracer tracer(vm, exec); \</span>
  76     auto throwScope = DECLARE_THROW_SCOPE(vm); \
  77     UNUSED_PARAM(throwScope)
  78 
  79 #ifndef NDEBUG
  80 #define SET_PC_FOR_STUBS() do { \
  81         exec-&gt;codeBlock()-&gt;bytecodeOffset(pc); \
  82         exec-&gt;setCurrentVPC(pc); \
  83     } while (false)
  84 #else
  85 #define SET_PC_FOR_STUBS() do { \
  86         exec-&gt;setCurrentVPC(pc); \
  87     } while (false)
  88 #endif
  89 
  90 #define RETURN_TO_THROW(exec, pc)   pc = LLInt::returnToThrow(exec)
  91 
  92 #define BEGIN()                           \
  93     BEGIN_NO_SET_PC();                    \
  94     SET_PC_FOR_STUBS()
  95 
</pre>
<hr />
<pre>
 163             CALL_END_IMPL(cceExec, LLInt::callToThrow(cceExec), ExceptionHandlerPtrTag); \
 164     } while (false)
 165 
 166 static void throwArityCheckStackOverflowError(ExecState* exec, ThrowScope&amp; scope)
 167 {
 168     JSObject* error = createStackOverflowError(exec);
 169     throwException(exec, scope, error);
 170 #if LLINT_TRACING
 171     if (UNLIKELY(Options::traceLLIntSlowPath()))
 172         dataLog(&quot;Throwing exception &quot;, JSValue(scope.exception()), &quot;.\n&quot;);
 173 #endif
 174 }
 175 
 176 SLOW_PATH_DECL(slow_path_call_arityCheck)
 177 {
 178     BEGIN();
 179     int slotsToAdd = CommonSlowPaths::arityCheckFor(exec, vm, CodeForCall);
 180     if (UNLIKELY(slotsToAdd &lt; 0)) {
 181         CodeBlock* codeBlock = CommonSlowPaths::codeBlockFromCallFrameCallee(exec, CodeForCall);
 182         exec-&gt;convertToStackOverflowFrame(vm, codeBlock);
<span class="line-modified"> 183         NativeCallFrameTracer tracer(vm, exec);</span>
 184         ErrorHandlingScope errorScope(vm);
 185         throwScope.release();
 186         throwArityCheckStackOverflowError(exec, throwScope);
 187         RETURN_TWO(bitwise_cast&lt;void*&gt;(static_cast&lt;uintptr_t&gt;(1)), exec);
 188     }
 189     RETURN_TWO(0, bitwise_cast&lt;void*&gt;(static_cast&lt;uintptr_t&gt;(slotsToAdd)));
 190 }
 191 
 192 SLOW_PATH_DECL(slow_path_construct_arityCheck)
 193 {
 194     BEGIN();
 195     int slotsToAdd = CommonSlowPaths::arityCheckFor(exec, vm, CodeForConstruct);
 196     if (UNLIKELY(slotsToAdd &lt; 0)) {
 197         CodeBlock* codeBlock = CommonSlowPaths::codeBlockFromCallFrameCallee(exec, CodeForConstruct);
 198         exec-&gt;convertToStackOverflowFrame(vm, codeBlock);
<span class="line-modified"> 199         NativeCallFrameTracer tracer(vm, exec);</span>
 200         ErrorHandlingScope errorScope(vm);
 201         throwArityCheckStackOverflowError(exec, throwScope);
 202         RETURN_TWO(bitwise_cast&lt;void*&gt;(static_cast&lt;uintptr_t&gt;(1)), exec);
 203     }
 204     RETURN_TWO(0, bitwise_cast&lt;void*&gt;(static_cast&lt;uintptr_t&gt;(slotsToAdd)));
 205 }
 206 
 207 SLOW_PATH_DECL(slow_path_create_direct_arguments)
 208 {
 209     BEGIN();
 210     auto bytecode = pc-&gt;as&lt;OpCreateDirectArguments&gt;();
 211     RETURN(DirectArguments::createByCopying(exec));
 212 }
 213 
 214 SLOW_PATH_DECL(slow_path_create_scoped_arguments)
 215 {
 216     BEGIN();
 217     auto bytecode = pc-&gt;as&lt;OpCreateScopedArguments&gt;();
 218     JSLexicalEnvironment* scope = jsCast&lt;JSLexicalEnvironment*&gt;(GET(bytecode.m_scope).jsValue());
 219     ScopedArgumentsTable* table = scope-&gt;symbolTable()-&gt;arguments();
</pre>
<hr />
<pre>
 225     BEGIN();
 226     auto bytecode = pc-&gt;as&lt;OpCreateClonedArguments&gt;();
 227     RETURN(ClonedArguments::createWithMachineFrame(exec, exec, ArgumentsMode::Cloned));
 228 }
 229 
 230 SLOW_PATH_DECL(slow_path_create_this)
 231 {
 232     BEGIN();
 233     auto bytecode = pc-&gt;as&lt;OpCreateThis&gt;();
 234     JSObject* result;
 235     JSObject* constructorAsObject = asObject(GET(bytecode.m_callee).jsValue());
 236     if (constructorAsObject-&gt;type() == JSFunctionType &amp;&amp; jsCast&lt;JSFunction*&gt;(constructorAsObject)-&gt;canUseAllocationProfile()) {
 237         JSFunction* constructor = jsCast&lt;JSFunction*&gt;(constructorAsObject);
 238         WriteBarrier&lt;JSCell&gt;&amp; cachedCallee = bytecode.metadata(exec).m_cachedCallee;
 239         if (!cachedCallee)
 240             cachedCallee.set(vm, exec-&gt;codeBlock(), constructor);
 241         else if (cachedCallee.unvalidatedGet() != JSCell::seenMultipleCalleeObjects() &amp;&amp; cachedCallee.get() != constructor)
 242             cachedCallee.setWithoutWriteBarrier(JSCell::seenMultipleCalleeObjects());
 243 
 244         size_t inlineCapacity = bytecode.m_inlineCapacity;
<span class="line-modified"> 245         ObjectAllocationProfileWithPrototype* allocationProfile = constructor-&gt;ensureRareDataAndAllocationProfile(exec, inlineCapacity)-&gt;objectAllocationProfile();</span>
 246         throwScope.releaseAssertNoException();
 247         Structure* structure = allocationProfile-&gt;structure();
 248         result = constructEmptyObject(exec, structure);
 249         if (structure-&gt;hasPolyProto()) {
 250             JSObject* prototype = allocationProfile-&gt;prototype();
 251             ASSERT(prototype == constructor-&gt;prototypeForConstruction(vm, exec));
 252             result-&gt;putDirect(vm, knownPolyProtoOffset, prototype);
 253             prototype-&gt;didBecomePrototype();
 254             ASSERT_WITH_MESSAGE(!hasIndexedProperties(result-&gt;indexingType()), &quot;We rely on JSFinalObject not starting out with an indexing type otherwise we would potentially need to convert to slow put storage&quot;);
 255         }
 256     } else {
 257         // http://ecma-international.org/ecma-262/6.0/#sec-ordinarycreatefromconstructor
 258         JSValue proto = constructorAsObject-&gt;get(exec, vm.propertyNames-&gt;prototype);
 259         CHECK_EXCEPTION();
 260         if (proto.isObject())
 261             result = constructEmptyObject(exec, asObject(proto));
 262         else
 263             result = constructEmptyObject(exec);
 264     }
 265     RETURN(result);
 266 }
 267 
 268 SLOW_PATH_DECL(slow_path_to_this)
 269 {
 270     BEGIN();
 271     auto bytecode = pc-&gt;as&lt;OpToThis&gt;();
 272     auto&amp; metadata = bytecode.metadata(exec);
 273     JSValue v1 = GET(bytecode.m_srcDst).jsValue();
 274     if (v1.isCell()) {
<span class="line-modified"> 275         StructureID myStructureID = v1.asCell()-&gt;structureID();</span>
<span class="line-modified"> 276         StructureID otherStructureID = metadata.m_cachedStructureID;</span>
<span class="line-modified"> 277         if (myStructureID != otherStructureID) {</span>
<span class="line-modified"> 278             if (otherStructureID)</span>
 279                 metadata.m_toThisStatus = ToThisConflicted;
<span class="line-modified"> 280             metadata.m_cachedStructureID = myStructureID;</span>
<span class="line-added"> 281             vm.heap.writeBarrier(exec-&gt;codeBlock(), vm.getStructure(myStructureID));</span>
 282         }
 283     } else {
 284         metadata.m_toThisStatus = ToThisConflicted;
<span class="line-modified"> 285         metadata.m_cachedStructureID = 0;</span>
 286     }
 287     // Note: We only need to do this value profiling here on the slow path. The fast path
 288     // just returns the input to to_this if the structure check succeeds. If the structure
 289     // check succeeds, doing value profiling here is equivalent to doing it with a potentially
 290     // different object that still has the same structure on the fast path since it&#39;ll produce
 291     // the same SpeculatedType. Therefore, we don&#39;t need to worry about value profiling on the
 292     // fast path.
 293     auto value = v1.toThis(exec, exec-&gt;codeBlock()-&gt;isStrictMode() ? StrictMode : NotStrictMode);
 294     RETURN_WITH_PROFILING_CUSTOM(bytecode.m_srcDst, value, PROFILE_VALUE(value));
 295 }
 296 
 297 SLOW_PATH_DECL(slow_path_throw_tdz_error)
 298 {
 299     BEGIN();
 300     THROW(createTDZError(exec));
 301 }
 302 
 303 SLOW_PATH_DECL(slow_path_check_tdz)
 304 {
 305     BEGIN();
</pre>
<hr />
<pre>
 619 
 620     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 621         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 622             JSBigInt* result = JSBigInt::remainder(exec, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));
 623             CHECK_EXCEPTION();
 624             RETURN(result);
 625         }
 626 
 627         THROW(createTypeError(exec, &quot;Invalid mix of BigInt and other type in remainder operation.&quot;));
 628     }
 629 
 630     double a = WTF::get&lt;double&gt;(leftNumeric);
 631     double b = WTF::get&lt;double&gt;(rightNumeric);
 632     RETURN(jsNumber(jsMod(a, b)));
 633 }
 634 
 635 SLOW_PATH_DECL(slow_path_pow)
 636 {
 637     BEGIN();
 638     auto bytecode = pc-&gt;as&lt;OpPow&gt;();
<span class="line-modified"> 639     JSValue left = GET_C(bytecode.m_lhs).jsValue();</span>
<span class="line-modified"> 640     JSValue right = GET_C(bytecode.m_rhs).jsValue();</span>
<span class="line-modified"> 641     auto leftNumeric = left.toNumeric(exec);</span>
<span class="line-modified"> 642     CHECK_EXCEPTION();</span>
<span class="line-modified"> 643     auto rightNumeric = right.toNumeric(exec);</span>
<span class="line-modified"> 644     CHECK_EXCEPTION();</span>
<span class="line-added"> 645 </span>
<span class="line-added"> 646     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {</span>
<span class="line-added"> 647         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {</span>
<span class="line-added"> 648             JSBigInt* result = JSBigInt::exponentiate(exec, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));</span>
<span class="line-added"> 649             CHECK_EXCEPTION();</span>
<span class="line-added"> 650             RETURN(result);</span>
<span class="line-added"> 651         }</span>
<span class="line-added"> 652 </span>
<span class="line-added"> 653         THROW(createTypeError(exec, &quot;Invalid mix of BigInt and other type in exponentiation operation.&quot;));</span>
<span class="line-added"> 654     }</span>
<span class="line-added"> 655 </span>
<span class="line-added"> 656     double a = WTF::get&lt;double&gt;(leftNumeric);</span>
<span class="line-added"> 657     double b = WTF::get&lt;double&gt;(rightNumeric);</span>
<span class="line-added"> 658 </span>
 659     RETURN(jsNumber(operationMathPow(a, b)));
 660 }
 661 
 662 SLOW_PATH_DECL(slow_path_lshift)
 663 {
 664     BEGIN();
 665     auto bytecode = pc-&gt;as&lt;OpLshift&gt;();
 666     JSValue left = GET_C(bytecode.m_lhs).jsValue();
 667     JSValue right = GET_C(bytecode.m_rhs).jsValue();
 668     auto leftNumeric = left.toBigIntOrInt32(exec);
 669     CHECK_EXCEPTION();
 670     auto rightNumeric = right.toBigIntOrInt32(exec);
 671     CHECK_EXCEPTION();
 672 
 673     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 674         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 675             JSBigInt* result = JSBigInt::leftShift(exec, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));
 676             CHECK_EXCEPTION();
<span class="line-modified"> 677             RETURN_PROFILED(result);</span>
 678         }
 679 
 680         THROW(createTypeError(exec, &quot;Invalid mix of BigInt and other type in left shift operation.&quot;));
 681     }
 682 
<span class="line-modified"> 683     RETURN_PROFILED(jsNumber(WTF::get&lt;int32_t&gt;(leftNumeric) &lt;&lt; (WTF::get&lt;int32_t&gt;(rightNumeric) &amp; 31)));</span>
 684 }
 685 
 686 SLOW_PATH_DECL(slow_path_rshift)
 687 {
 688     BEGIN();
 689     auto bytecode = pc-&gt;as&lt;OpRshift&gt;();
 690     JSValue left = GET_C(bytecode.m_lhs).jsValue();
 691     JSValue right = GET_C(bytecode.m_rhs).jsValue();
 692     auto leftNumeric = left.toBigIntOrInt32(exec);
 693     CHECK_EXCEPTION();
 694     auto rightNumeric = right.toBigIntOrInt32(exec);
 695     CHECK_EXCEPTION();
 696 
 697     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 698         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 699             JSBigInt* result = JSBigInt::signedRightShift(exec, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));
 700             CHECK_EXCEPTION();
 701             RETURN(result);
 702         }
 703 
</pre>
<hr />
<pre>
 713     auto bytecode = pc-&gt;as&lt;OpUrshift&gt;();
 714     uint32_t a = GET_C(bytecode.m_lhs).jsValue().toUInt32(exec);
 715     if (UNLIKELY(throwScope.exception()))
 716         RETURN(JSValue());
 717     uint32_t b = GET_C(bytecode.m_rhs).jsValue().toUInt32(exec);
 718     RETURN(jsNumber(static_cast&lt;int32_t&gt;(a &gt;&gt; (b &amp; 31))));
 719 }
 720 
 721 SLOW_PATH_DECL(slow_path_unsigned)
 722 {
 723     BEGIN();
 724     auto bytecode = pc-&gt;as&lt;OpUnsigned&gt;();
 725     uint32_t a = GET_C(bytecode.m_operand).jsValue().toUInt32(exec);
 726     RETURN(jsNumber(a));
 727 }
 728 
 729 SLOW_PATH_DECL(slow_path_bitnot)
 730 {
 731     BEGIN();
 732     auto bytecode = pc-&gt;as&lt;OpBitnot&gt;();
<span class="line-modified"> 733     auto operandNumeric = GET_C(bytecode.m_operand).jsValue().toBigIntOrInt32(exec);</span>
 734     CHECK_EXCEPTION();
<span class="line-modified"> 735 </span>
<span class="line-added"> 736     if (WTF::holds_alternative&lt;JSBigInt*&gt;(operandNumeric)) {</span>
<span class="line-added"> 737         JSBigInt* result = JSBigInt::bitwiseNot(exec, WTF::get&lt;JSBigInt*&gt;(operandNumeric));</span>
<span class="line-added"> 738         CHECK_EXCEPTION();</span>
<span class="line-added"> 739         RETURN_PROFILED(result);</span>
<span class="line-added"> 740     }</span>
<span class="line-added"> 741 </span>
<span class="line-added"> 742     RETURN_PROFILED(jsNumber(~WTF::get&lt;int32_t&gt;(operandNumeric)));</span>
 743 }
 744 
 745 SLOW_PATH_DECL(slow_path_bitand)
 746 {
 747     BEGIN();
 748     auto bytecode = pc-&gt;as&lt;OpBitand&gt;();
 749     auto leftNumeric = GET_C(bytecode.m_lhs).jsValue().toBigIntOrInt32(exec);
 750     CHECK_EXCEPTION();
 751     auto rightNumeric = GET_C(bytecode.m_rhs).jsValue().toBigIntOrInt32(exec);
 752     CHECK_EXCEPTION();
 753     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 754         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 755             JSBigInt* result = JSBigInt::bitwiseAnd(exec, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));
 756             CHECK_EXCEPTION();
 757             RETURN_PROFILED(result);
 758         }
 759 
 760         THROW(createTypeError(exec, &quot;Invalid mix of BigInt and other type in bitwise &#39;and&#39; operation.&quot;));
 761     }
 762 
</pre>
<hr />
<pre>
 871     if (!couldDelete &amp;&amp; exec-&gt;codeBlock()-&gt;isStrictMode())
 872         THROW(createTypeError(exec, UnableToDeletePropertyError));
 873 
 874     RETURN(jsBoolean(couldDelete));
 875 }
 876 
 877 SLOW_PATH_DECL(slow_path_strcat)
 878 {
 879     BEGIN();
 880     auto bytecode = pc-&gt;as&lt;OpStrcat&gt;();
 881     RETURN(jsStringFromRegisterArray(exec, &amp;GET(bytecode.m_src), bytecode.m_count));
 882 }
 883 
 884 SLOW_PATH_DECL(slow_path_to_primitive)
 885 {
 886     BEGIN();
 887     auto bytecode = pc-&gt;as&lt;OpToPrimitive&gt;();
 888     RETURN(GET_C(bytecode.m_src).jsValue().toPrimitive(exec));
 889 }
 890 








 891 SLOW_PATH_DECL(slow_path_get_enumerable_length)
 892 {
 893     BEGIN();
 894     auto bytecode = pc-&gt;as&lt;OpGetEnumerableLength&gt;();
 895     JSValue enumeratorValue = GET(bytecode.m_base).jsValue();
 896     if (enumeratorValue.isUndefinedOrNull())
 897         RETURN(jsNumber(0));
 898 
 899     JSPropertyNameEnumerator* enumerator = jsCast&lt;JSPropertyNameEnumerator*&gt;(enumeratorValue.asCell());
 900 
 901     RETURN(jsNumber(enumerator-&gt;indexedLength()));
 902 }
 903 
 904 SLOW_PATH_DECL(slow_path_has_indexed_property)
 905 {
 906     BEGIN();
 907     auto bytecode = pc-&gt;as&lt;OpHasIndexedProperty&gt;();
 908     auto&amp; metadata = bytecode.metadata(exec);
 909     JSObject* base = GET(bytecode.m_base).jsValue().toObject(exec);
 910     CHECK_EXCEPTION();
 911     JSValue property = GET(bytecode.m_property).jsValue();
 912     metadata.m_arrayProfile.observeStructure(base-&gt;structure(vm));
<span class="line-modified"> 913     ASSERT(property.isUInt32AsAnyInt());</span>
<span class="line-modified"> 914     RETURN(jsBoolean(base-&gt;hasPropertyGeneric(exec, property.asUInt32AsAnyInt(), PropertySlot::InternalMethodType::GetOwnProperty)));</span>
 915 }
 916 
 917 SLOW_PATH_DECL(slow_path_has_structure_property)
 918 {
 919     BEGIN();
 920     auto bytecode = pc-&gt;as&lt;OpHasStructureProperty&gt;();
 921     JSObject* base = GET(bytecode.m_base).jsValue().toObject(exec);
 922     CHECK_EXCEPTION();
 923     JSValue property = GET(bytecode.m_property).jsValue();
 924     ASSERT(property.isString());
 925     JSPropertyNameEnumerator* enumerator = jsCast&lt;JSPropertyNameEnumerator*&gt;(GET(bytecode.m_enumerator).jsValue().asCell());
 926     if (base-&gt;structure(vm)-&gt;id() == enumerator-&gt;cachedStructureID())
 927         RETURN(jsBoolean(true));
 928     JSString* string = asString(property);
 929     auto propertyName = string-&gt;toIdentifier(exec);
 930     CHECK_EXCEPTION();
 931     RETURN(jsBoolean(base-&gt;hasPropertyGeneric(exec, propertyName, PropertySlot::InternalMethodType::GetOwnProperty)));
 932 }
 933 
 934 SLOW_PATH_DECL(slow_path_has_generic_property)
</pre>
<hr />
<pre>
 947 
 948 SLOW_PATH_DECL(slow_path_get_direct_pname)
 949 {
 950     BEGIN();
 951     auto bytecode = pc-&gt;as&lt;OpGetDirectPname&gt;();
 952     JSValue baseValue = GET_C(bytecode.m_base).jsValue();
 953     JSValue property = GET(bytecode.m_property).jsValue();
 954     ASSERT(property.isString());
 955     JSString* string = asString(property);
 956     auto propertyName = string-&gt;toIdentifier(exec);
 957     CHECK_EXCEPTION();
 958     RETURN(baseValue.get(exec, propertyName));
 959 }
 960 
 961 SLOW_PATH_DECL(slow_path_get_property_enumerator)
 962 {
 963     BEGIN();
 964     auto bytecode = pc-&gt;as&lt;OpGetPropertyEnumerator&gt;();
 965     JSValue baseValue = GET(bytecode.m_base).jsValue();
 966     if (baseValue.isUndefinedOrNull())
<span class="line-modified"> 967         RETURN(vm.emptyPropertyNameEnumerator());</span>
 968 
 969     JSObject* base = baseValue.toObject(exec);
 970     CHECK_EXCEPTION();
 971 
 972     RETURN(propertyNameEnumerator(exec, base));
 973 }
 974 
 975 SLOW_PATH_DECL(slow_path_enumerator_structure_pname)
 976 {
 977     BEGIN();
 978     auto bytecode = pc-&gt;as&lt;OpEnumeratorStructurePname&gt;();
 979     JSPropertyNameEnumerator* enumerator = jsCast&lt;JSPropertyNameEnumerator*&gt;(GET(bytecode.m_enumerator).jsValue().asCell());
 980     uint32_t index = GET(bytecode.m_index).jsValue().asUInt32();
 981 
 982     JSString* propertyName = nullptr;
 983     if (index &lt; enumerator-&gt;endStructurePropertyIndex())
 984         propertyName = enumerator-&gt;propertyNameAtIndex(index);
 985     RETURN(propertyName ? propertyName : jsNull());
 986 }
 987 
 988 SLOW_PATH_DECL(slow_path_enumerator_generic_pname)
 989 {
 990     BEGIN();
 991     auto bytecode = pc-&gt;as&lt;OpEnumeratorGenericPname&gt;();
 992     JSPropertyNameEnumerator* enumerator = jsCast&lt;JSPropertyNameEnumerator*&gt;(GET(bytecode.m_enumerator).jsValue().asCell());
 993     uint32_t index = GET(bytecode.m_index).jsValue().asUInt32();
 994 
 995     JSString* propertyName = nullptr;
 996     if (enumerator-&gt;endStructurePropertyIndex() &lt;= index &amp;&amp; index &lt; enumerator-&gt;endGenericPropertyIndex())
 997         propertyName = enumerator-&gt;propertyNameAtIndex(index);
 998     RETURN(propertyName ? propertyName : jsNull());
 999 }
1000 
1001 SLOW_PATH_DECL(slow_path_to_index_string)
1002 {
1003     BEGIN();
1004     auto bytecode = pc-&gt;as&lt;OpToIndexString&gt;();
<span class="line-modified">1005     JSValue indexValue = GET(bytecode.m_index).jsValue();</span>
<span class="line-added">1006     ASSERT(indexValue.isUInt32AsAnyInt());</span>
<span class="line-added">1007     RETURN(jsString(vm, Identifier::from(vm, indexValue.asUInt32AsAnyInt()).string()));</span>
1008 }
1009 
1010 SLOW_PATH_DECL(slow_path_profile_type_clear_log)
1011 {
1012     BEGIN();
1013     vm.typeProfilerLog()-&gt;processLogEntries(vm, &quot;LLInt log full.&quot;_s);
1014     END();
1015 }
1016 
1017 SLOW_PATH_DECL(slow_path_unreachable)
1018 {
1019     BEGIN();
1020     UNREACHABLE_FOR_PLATFORM();
1021     END();
1022 }
1023 
1024 SLOW_PATH_DECL(slow_path_create_lexical_environment)
1025 {
1026     BEGIN();
1027     auto bytecode = pc-&gt;as&lt;OpCreateLexicalEnvironment&gt;();
</pre>
<hr />
<pre>
1047 }
1048 
1049 SLOW_PATH_DECL(slow_path_resolve_scope_for_hoisting_func_decl_in_eval)
1050 {
1051     BEGIN();
1052     auto bytecode = pc-&gt;as&lt;OpResolveScopeForHoistingFuncDeclInEval&gt;();
1053     const Identifier&amp; ident = exec-&gt;codeBlock()-&gt;identifier(bytecode.m_property);
1054     JSScope* scope = exec-&gt;uncheckedR(bytecode.m_scope.offset()).Register::scope();
1055     JSValue resolvedScope = JSScope::resolveScopeForHoistingFuncDeclInEval(exec, scope, ident);
1056 
1057     CHECK_EXCEPTION();
1058 
1059     RETURN(resolvedScope);
1060 }
1061 
1062 SLOW_PATH_DECL(slow_path_resolve_scope)
1063 {
1064     BEGIN();
1065     auto bytecode = pc-&gt;as&lt;OpResolveScope&gt;();
1066     auto&amp; metadata = bytecode.metadata(exec);
<span class="line-modified">1067     CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
<span class="line-added">1068     const Identifier&amp; ident = codeBlock-&gt;identifier(bytecode.m_var);</span>
1069     JSScope* scope = exec-&gt;uncheckedR(bytecode.m_scope.offset()).Register::scope();
1070     JSObject* resolvedScope = JSScope::resolve(exec, scope, ident);
1071     // Proxy can throw an error here, e.g. Proxy in with statement&#39;s @unscopables.
1072     CHECK_EXCEPTION();
1073 
1074     ResolveType resolveType = metadata.m_resolveType;
1075 
1076     // ModuleVar does not keep the scope register value alive in DFG.
1077     ASSERT(resolveType != ModuleVar);
1078 
1079     switch (resolveType) {
1080     case GlobalProperty:
1081     case GlobalPropertyWithVarInjectionChecks:
1082     case UnresolvedProperty:
1083     case UnresolvedPropertyWithVarInjectionChecks: {
1084         if (resolvedScope-&gt;isGlobalObject()) {
1085             JSGlobalObject* globalObject = jsCast&lt;JSGlobalObject*&gt;(resolvedScope);
1086             bool hasProperty = globalObject-&gt;hasProperty(exec, ident);
1087             CHECK_EXCEPTION();
1088             if (hasProperty) {
<span class="line-modified">1089                 ConcurrentJSLocker locker(codeBlock-&gt;m_lock);</span>
1090                 metadata.m_resolveType = needsVarInjectionChecks(resolveType) ? GlobalPropertyWithVarInjectionChecks : GlobalProperty;
<span class="line-modified">1091                 metadata.m_globalObject.set(vm, codeBlock, globalObject);</span>
1092                 metadata.m_globalLexicalBindingEpoch = globalObject-&gt;globalLexicalBindingEpoch();
1093             }
1094         } else if (resolvedScope-&gt;isGlobalLexicalEnvironment()) {
1095             JSGlobalLexicalEnvironment* globalLexicalEnvironment = jsCast&lt;JSGlobalLexicalEnvironment*&gt;(resolvedScope);
<span class="line-modified">1096             ConcurrentJSLocker locker(codeBlock-&gt;m_lock);</span>
1097             metadata.m_resolveType = needsVarInjectionChecks(resolveType) ? GlobalLexicalVarWithVarInjectionChecks : GlobalLexicalVar;
<span class="line-modified">1098             metadata.m_globalLexicalEnvironment.set(vm, codeBlock, globalLexicalEnvironment);</span>
1099         }
1100         break;
1101     }
1102     default:
1103         break;
1104     }
1105 
1106     RETURN(resolvedScope);
1107 }
1108 
1109 SLOW_PATH_DECL(slow_path_create_rest)
1110 {
1111     BEGIN();
1112     auto bytecode = pc-&gt;as&lt;OpCreateRest&gt;();
1113     unsigned arraySize = GET_C(bytecode.m_arraySize).jsValue().asUInt32();
1114     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();
1115     Structure* structure = globalObject-&gt;restParameterStructure();
1116     unsigned numParamsToSkip = bytecode.m_numParametersToSkip;
1117     JSValue* argumentsToCopyRegion = exec-&gt;addressOfArgumentsStart() + numParamsToSkip;
1118     RETURN(constructArray(exec, structure, argumentsToCopyRegion, arraySize));
</pre>
<hr />
<pre>
1125     const Identifier&amp; ident = exec-&gt;codeBlock()-&gt;identifier(bytecode.m_property);
1126     JSValue baseValue = GET_C(bytecode.m_base).jsValue();
1127     JSValue thisVal = GET_C(bytecode.m_thisValue).jsValue();
1128     PropertySlot slot(thisVal, PropertySlot::PropertySlot::InternalMethodType::Get);
1129     JSValue result = baseValue.get(exec, ident, slot);
1130     RETURN_PROFILED(result);
1131 }
1132 
1133 SLOW_PATH_DECL(slow_path_get_by_val_with_this)
1134 {
1135     BEGIN();
1136 
1137     auto bytecode = pc-&gt;as&lt;OpGetByValWithThis&gt;();
1138     JSValue baseValue = GET_C(bytecode.m_base).jsValue();
1139     JSValue thisValue = GET_C(bytecode.m_thisValue).jsValue();
1140     JSValue subscript = GET_C(bytecode.m_property).jsValue();
1141 
1142     if (LIKELY(baseValue.isCell() &amp;&amp; subscript.isString())) {
1143         Structure&amp; structure = *baseValue.asCell()-&gt;structure(vm);
1144         if (JSCell::canUseFastGetOwnProperty(structure)) {
<span class="line-modified">1145             RefPtr&lt;AtomStringImpl&gt; existingAtomString = asString(subscript)-&gt;toExistingAtomString(exec);</span>
<span class="line-modified">1146             CHECK_EXCEPTION();</span>
<span class="line-added">1147             if (existingAtomString) {</span>
<span class="line-added">1148                 if (JSValue result = baseValue.asCell()-&gt;fastGetOwnProperty(vm, structure, existingAtomString.get()))</span>
1149                     RETURN_PROFILED(result);
1150             }
1151         }
1152     }
1153 
1154     PropertySlot slot(thisValue, PropertySlot::PropertySlot::InternalMethodType::Get);
1155     if (subscript.isUInt32()) {
1156         uint32_t i = subscript.asUInt32();
1157         if (isJSString(baseValue) &amp;&amp; asString(baseValue)-&gt;canGetIndex(i))
1158             RETURN_PROFILED(asString(baseValue)-&gt;getIndex(exec, i));
1159 
1160         RETURN_PROFILED(baseValue.get(exec, i, slot));
1161     }
1162 
1163     baseValue.requireObjectCoercible(exec);
1164     CHECK_EXCEPTION();
1165     auto property = subscript.toPropertyKey(exec);
1166     CHECK_EXCEPTION();
1167     RETURN_PROFILED(baseValue.get(exec, property, slot));
1168 }
</pre>
</td>
</tr>
</table>
<center><a href="CommonIdentifiers.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CommonSlowPaths.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>