<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/offlineasm/mips.rb</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 # Copyright (C) 2012-2018 Apple Inc. All rights reserved.
   2 # Copyright (C) 2012 MIPS Technologies, Inc. All rights reserved.
   3 #
   4 # Redistribution and use in source and binary forms, with or without
   5 # modification, are permitted provided that the following conditions
   6 # are met:
   7 # 1. Redistributions of source code must retain the above copyright
   8 #    notice, this list of conditions and the following disclaimer.
   9 # 2. Redistributions in binary form must reproduce the above copyright
  10 #    notice, this list of conditions and the following disclaimer in the
  11 #    documentation and/or other materials provided with the distribution.
  12 #
  13 # THIS SOFTWARE IS PROVIDED BY MIPS TECHNOLOGIES, INC. ``AS IS&#39;&#39; AND ANY
  14 # EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15 # IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16 # PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL MIPS TECHNOLOGIES, INC. OR
  17 # CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18 # EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19 # PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20 # PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21 # OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22 # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23 # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24 
  25 require &#39;risc&#39;
  26 
  27 # GPR conventions, to match the baseline JIT
  28 #
  29 # $a0 =&gt; a0, t7
  30 # $a1 =&gt; a1, t8
  31 # $a2 =&gt; a2, t9
  32 # $a3 =&gt; a3, t10
  33 # $v0 =&gt; t0, r0
  34 # $v1 =&gt; t1, r1
  35 # $t0 =&gt;            (scratch)
  36 # $t1 =&gt;            (scratch)
  37 # $t2 =&gt;         t2
  38 # $t3 =&gt;         t3
  39 # $t4 =&gt;         t4
  40 # $t5 =&gt;         t5
  41 # $t6 =&gt;         t6
  42 # $t7 =&gt;            (scratch)
  43 # $t8 =&gt;            (scratch)
  44 # $t9 =&gt;            (stores the callee of a call opcode)
  45 # $gp =&gt;            (globals)
  46 # $s4 =&gt;            (callee-save used to preserve $gp across calls)
  47 # $ra =&gt; lr
  48 # $sp =&gt; sp
  49 # $fp =&gt; cfr
  50 #
  51 # FPR conventions, to match the baseline JIT
  52 # We don&#39;t have fa2 or fa3!
  53 #  $f0 =&gt; ft0, fr
  54 #  $f2 =&gt; ft1
  55 #  $f4 =&gt; ft2
  56 #  $f6 =&gt; ft3
  57 #  $f8 =&gt; ft4
  58 # $f10 =&gt; ft5
  59 # $f12 =&gt;        fa0
  60 # $f14 =&gt;        fa1
  61 # $f16 =&gt;            (scratch)
  62 # $f18 =&gt;            (scratch)
  63 
  64 class Assembler
  65     def putStr(str)
  66         @outp.puts str
  67     end
  68 end
  69 
  70 class Node
  71     def mipsSingleHi
  72         doubleOperand = mipsOperand
  73         raise &quot;Bogus register name #{doubleOperand}&quot; unless doubleOperand =~ /^\$f/
  74         &quot;$f&quot; + ($~.post_match.to_i + 1).to_s
  75     end
  76     def mipsSingleLo
  77         doubleOperand = mipsOperand
  78         raise &quot;Bogus register name #{doubleOperand}&quot; unless doubleOperand =~ /^\$f/
  79         doubleOperand
  80     end
  81 end
  82 
  83 class SpecialRegister &lt; NoChildren
  84     def mipsOperand
  85         @name
  86     end
  87 
  88     def dump
  89         @name
  90     end
  91 
  92     def register?
  93         true
  94     end
  95 end
  96 
  97 MIPS_TEMP_GPRS = [SpecialRegister.new(&quot;$t0&quot;), SpecialRegister.new(&quot;$t1&quot;), SpecialRegister.new(&quot;$t7&quot;), SpecialRegister.new(&quot;$t8&quot;)]
  98 MIPS_ZERO_REG = SpecialRegister.new(&quot;$zero&quot;)
  99 MIPS_GP_REG = SpecialRegister.new(&quot;$gp&quot;)
 100 MIPS_GPSAVE_REG = SpecialRegister.new(&quot;$s4&quot;)
 101 MIPS_CALL_REG = SpecialRegister.new(&quot;$t9&quot;)
 102 MIPS_TEMP_FPRS = [SpecialRegister.new(&quot;$f16&quot;)]
 103 MIPS_SCRATCH_FPR = SpecialRegister.new(&quot;$f18&quot;)
 104 
 105 def mipsMoveImmediate(value, register)
 106     if value == 0
 107         $asm.puts &quot;add #{register.mipsOperand}, $zero, $zero&quot;
 108     else
 109         $asm.puts &quot;li #{register.mipsOperand}, #{value}&quot;
 110     end
 111 end
 112 
 113 class RegisterID
 114     def mipsOperand
 115         case name
 116         when &quot;a0&quot;, &quot;t7&quot;
 117             &quot;$a0&quot;
 118         when &quot;a1&quot;, &quot;t8&quot;
 119             &quot;$a1&quot;
 120         when &quot;a2&quot;, &quot;t9&quot;
 121             &quot;$a2&quot;
 122         when &quot;a3&quot;, &quot;t10&quot;
 123             &quot;$a3&quot;
 124         when &quot;t0&quot;, &quot;r0&quot;
 125             &quot;$v0&quot;
 126         when &quot;t1&quot;, &quot;r1&quot;
 127             &quot;$v1&quot;
 128         when &quot;t2&quot;
 129             &quot;$t2&quot;
 130         when &quot;t3&quot;
 131             &quot;$t3&quot;
 132         when &quot;t4&quot;
 133             &quot;$t4&quot;
 134         when &quot;t5&quot;
 135             &quot;$t5&quot;
 136         when &quot;cfr&quot;
 137             &quot;$fp&quot;
 138         when &quot;csr0&quot;
 139             &quot;$s0&quot;
 140         when &quot;lr&quot;
 141             &quot;$ra&quot;
 142         when &quot;sp&quot;
 143             &quot;$sp&quot;
 144         else
 145             raise &quot;Bad register #{name} for MIPS at #{codeOriginString}&quot;
 146         end
 147     end
 148 end
 149 
 150 class FPRegisterID
 151     def mipsOperand
 152         case name
 153         when &quot;ft0&quot;, &quot;fr&quot;
 154             &quot;$f0&quot;
 155         when &quot;ft1&quot;
 156             &quot;$f2&quot;
 157         when &quot;ft2&quot;
 158             &quot;$f4&quot;
 159         when &quot;ft3&quot;
 160             &quot;$f6&quot;
 161         when &quot;ft4&quot;
 162             &quot;$f8&quot;
 163         when &quot;ft5&quot;
 164             &quot;$f10&quot;
 165         when &quot;fa0&quot;
 166             &quot;$f12&quot;
 167         when &quot;fa1&quot;
 168             &quot;$f14&quot;
 169         else
 170             raise &quot;Bad register #{name} for MIPS at #{codeOriginString}&quot;
 171         end
 172     end
 173 end
 174 
 175 class Immediate
 176     def mipsOperand
 177         raise &quot;Invalid immediate #{value} at #{codeOriginString}&quot; if value &lt; -0x7fff or value &gt; 0xffff
 178         &quot;#{value}&quot;
 179     end
 180 end
 181 
 182 class Address
 183     def mipsOperand
 184         raise &quot;Bad offset at #{codeOriginString}&quot; if offset.value &lt; -0x7fff or offset.value &gt; 0x7fff
 185         &quot;#{offset.value}(#{base.mipsOperand})&quot;
 186     end
 187 end
 188 
 189 class AbsoluteAddress
 190     def mipsOperand
 191         raise &quot;Unconverted absolute address at #{codeOriginString}&quot;
 192     end
 193 end
 194 
 195 #
 196 # Negate condition of branches to labels.
 197 #
 198 
 199 class Instruction
 200     def mipsNegateCondition(list)
 201         /^(b(add|sub|or|mul|t)?)([ipb])/.match(opcode)
 202         case $~.post_match
 203         when &quot;eq&quot;
 204             op = &quot;neq&quot;
 205         when &quot;neq&quot;
 206             op = &quot;eq&quot;
 207         when &quot;z&quot;
 208             op = &quot;nz&quot;
 209         when &quot;nz&quot;
 210             op = &quot;z&quot;
 211         when &quot;gt&quot;
 212             op = &quot;lteq&quot;
 213         when &quot;gteq&quot;
 214             op = &quot;lt&quot;
 215         when &quot;lt&quot;
 216             op = &quot;gteq&quot;
 217         when &quot;lteq&quot;
 218             op = &quot;gt&quot;
 219         when &quot;a&quot;
 220             op = &quot;beq&quot;
 221         when &quot;b&quot;
 222             op = &quot;aeq&quot;
 223         when &quot;aeq&quot;
 224             op = &quot;b&quot;
 225         when &quot;beq&quot;
 226             op = &quot;a&quot;
 227         else
 228             raise &quot;Can&#39;t negate #{opcode} branch.&quot;
 229         end
 230         noBranch = LocalLabel.unique(&quot;nobranch&quot;)
 231         noBranchRef = LocalLabelReference.new(codeOrigin, noBranch)
 232         toRef = operands[-1]
 233         list &lt;&lt; Instruction.new(codeOrigin, &quot;#{$1}#{$3}#{op}&quot;, operands[0..-2].push(noBranchRef), annotation)
 234         list &lt;&lt; Instruction.new(codeOrigin, &quot;la&quot;, [toRef, MIPS_CALL_REG])
 235         list &lt;&lt; Instruction.new(codeOrigin, &quot;jmp&quot;, [MIPS_CALL_REG])
 236         list &lt;&lt; noBranch
 237     end
 238 end
 239 
 240 def mipsLowerFarBranchOps(list)
 241     newList = []
 242     list.each {
 243         | node |
 244         if node.is_a? Instruction
 245             annotation = node.annotation
 246             case node.opcode
 247             when /^b(add|sub|or|mul|t)?([ipb])/
 248                 if node.operands[-1].is_a? LabelReference
 249                     node.mipsNegateCondition(newList)
 250                     next
 251                 end
 252             end
 253         end
 254         newList &lt;&lt; node
 255     }
 256     newList
 257 end
 258 
 259 #
 260 # Lower &#39;and&#39; masked branches
 261 #
 262 
 263 def lowerMIPSCondBranch(list, condOp, node)
 264     if node.operands.size == 2
 265         list &lt;&lt; Instruction.new(node.codeOrigin,
 266                                 condOp,
 267                                 [node.operands[0], MIPS_ZERO_REG, node.operands[-1]],
 268                                 node.annotation)
 269     elsif node.operands.size == 3
 270         tl = condOp[-1, 1]
 271         tmp = Tmp.new(node.codeOrigin, :gpr)
 272         list &lt;&lt; Instruction.new(node.codeOrigin,
 273                                 &quot;and&quot; + tl,
 274                                 [node.operands[0], node.operands[1], tmp],
 275                                 node.annotation)
 276         list &lt;&lt; Instruction.new(node.codeOrigin,
 277                                 condOp,
 278                                 [tmp, MIPS_ZERO_REG, node.operands[-1]])
 279     else
 280         raise &quot;Expected 2 or 3 operands but got #{node.operands.size} at #{node.codeOriginString}&quot;
 281     end
 282 end
 283 
 284 #
 285 # Lowering of branch ops. For example:
 286 #
 287 # baddiz foo, bar, baz
 288 #
 289 # will become:
 290 #
 291 # addi foo, bar
 292 # bz baz
 293 #
 294 
 295 def mipsLowerSimpleBranchOps(list)
 296     newList = []
 297     list.each {
 298         | node |
 299         if node.is_a? Instruction
 300             annotation = node.annotation
 301             case node.opcode
 302             when /^b(addi|subi|ori|addp)/
 303                 op = $1
 304                 bc = $~.post_match
 305                 branch = &quot;b&quot; + bc
 306 
 307                 case op
 308                 when &quot;addi&quot;, &quot;addp&quot;
 309                     op = &quot;addi&quot;
 310                 when &quot;subi&quot;
 311                     op = &quot;subi&quot;
 312                 when &quot;ori&quot;
 313                     op = &quot;ori&quot;
 314                 end
 315 
 316                 if bc == &quot;o&quot;
 317                     case op
 318                     when &quot;addi&quot;
 319                         #  addu $s0, $s1, $s2
 320                         #  xor $t0, $s1, $s2
 321                         #  blt $t0, $zero, no overflow
 322                         #  xor $t0, $s0, $s1
 323                         #  blt $t0, $zero, overflow
 324                         # no overflow:
 325                         #
 326                         tr = Tmp.new(node.codeOrigin, :gpr)
 327                         tmp = Tmp.new(node.codeOrigin, :gpr)
 328                         noFlow = LocalLabel.unique(&quot;noflow&quot;)
 329                         noFlowRef = LocalLabelReference.new(node.codeOrigin, noFlow)
 330                         newList &lt;&lt; Instruction.new(node.codeOrigin, op, [node.operands[0], node.operands[1], tr], annotation)
 331                         newList &lt;&lt; Instruction.new(node.codeOrigin, &quot;xori&quot;, [node.operands[0], node.operands[1], tmp])
 332                         newList &lt;&lt; Instruction.new(node.codeOrigin, &quot;bilt&quot;, [tmp, MIPS_ZERO_REG, noFlowRef])
 333                         newList &lt;&lt; Instruction.new(node.codeOrigin, &quot;xori&quot;, [tr, node.operands[0], tmp])
 334                         newList &lt;&lt; Instruction.new(node.codeOrigin, &quot;bilt&quot;, [tmp, MIPS_ZERO_REG, node.operands[2]])
 335                         newList &lt;&lt; noFlow
 336                         newList &lt;&lt; Instruction.new(node.codeOrigin, &quot;move&quot;, [tr, node.operands[1]])
 337                     when &quot;subi&quot;
 338                         #  subu $s0, $s1, $s2
 339                         #  xor $t0, $s1, $s2
 340                         #  bge $t0, $zero, no overflow
 341                         #  xor $t0, $s0, $s1
 342                         #  blt $t0, $zero, overflow
 343                         # no overflow:
 344                         #
 345                         tr = Tmp.new(node.codeOrigin, :gpr)
 346                         tmp = Tmp.new(node.codeOrigin, :gpr)
 347                         noFlow = LocalLabel.unique(&quot;noflow&quot;)
 348                         noFlowRef = LocalLabelReference.new(node.codeOrigin, noFlow)
 349                         newList &lt;&lt; Instruction.new(node.codeOrigin, op, [node.operands[1], node.operands[0], tr], annotation)
 350                         newList &lt;&lt; Instruction.new(node.codeOrigin, &quot;xori&quot;, [node.operands[1], node.operands[0], tmp])
 351                         newList &lt;&lt; Instruction.new(node.codeOrigin, &quot;bigteq&quot;, [tmp, MIPS_ZERO_REG, noFlowRef])
 352                         newList &lt;&lt; Instruction.new(node.codeOrigin, &quot;xori&quot;, [tr, node.operands[1], tmp])
 353                         newList &lt;&lt; Instruction.new(node.codeOrigin, &quot;bilt&quot;, [tmp, MIPS_ZERO_REG, node.operands[2]])
 354                         newList &lt;&lt; noFlow
 355                         newList &lt;&lt; Instruction.new(node.codeOrigin, &quot;move&quot;, [tr, node.operands[1]])
 356                     when &quot;ori&quot;
 357                         # no ovwerflow at ori
 358                         newList &lt;&lt; Instruction.new(node.codeOrigin, op, node.operands[0..1], annotation)
 359                     end
 360                 else
 361                     if node.operands[1].is_a? Address
 362                         addr = node.operands[1]
 363                         tr = Tmp.new(node.codeOrigin, :gpr)
 364                         newList &lt;&lt; Instruction.new(node.codeOrigin, &quot;loadp&quot;, [addr, tr], annotation)
 365                         newList &lt;&lt; Instruction.new(node.codeOrigin, op, [node.operands[0], tr])
 366                         newList &lt;&lt; Instruction.new(node.codeOrigin, &quot;storep&quot;, [tr, addr])
 367                     else
 368                         tr = node.operands[1]
 369                         newList &lt;&lt; Instruction.new(node.codeOrigin, op, node.operands[0..-2], annotation)
 370                     end
 371                     newList &lt;&lt; Instruction.new(node.codeOrigin, branch, [tr, MIPS_ZERO_REG, node.operands[-1]])
 372                 end
 373             when &quot;bia&quot;, &quot;bpa&quot;, &quot;bba&quot;
 374                 tmp = Tmp.new(node.codeOrigin, :gpr)
 375                 comp = node.opcode[1] == ?b ? &quot;sltub&quot; : &quot;sltu&quot;
 376                 newList &lt;&lt; Instruction.new(node.codeOrigin, comp, [tmp, node.operands[1], node.operands[0]], annotation)
 377                 newList &lt;&lt; Instruction.new(node.codeOrigin, &quot;bnz&quot;, [tmp, MIPS_ZERO_REG, node.operands[2]])
 378             when &quot;biaeq&quot;, &quot;bpaeq&quot;, &quot;bbaeq&quot;
 379                 tmp = Tmp.new(node.codeOrigin, :gpr)
 380                 comp = node.opcode[1] == ?b ? &quot;sltub&quot; : &quot;sltu&quot;
 381                 newList &lt;&lt; Instruction.new(node.codeOrigin, comp, [tmp, node.operands[0], node.operands[1]], annotation)
 382                 newList &lt;&lt; Instruction.new(node.codeOrigin, &quot;bz&quot;, [tmp, MIPS_ZERO_REG, node.operands[2]])
 383             when &quot;bib&quot;, &quot;bpb&quot;, &quot;bbb&quot;
 384                 tmp = Tmp.new(node.codeOrigin, :gpr)
 385                 comp = node.opcode[1] == ?b ? &quot;sltub&quot; : &quot;sltu&quot;
 386                 newList &lt;&lt; Instruction.new(node.codeOrigin, comp, [tmp, node.operands[0], node.operands[1]], annotation)
 387                 newList &lt;&lt; Instruction.new(node.codeOrigin, &quot;bnz&quot;, [tmp, MIPS_ZERO_REG, node.operands[2]])
 388             when &quot;bibeq&quot;, &quot;bpbeq&quot;, &quot;bbbeq&quot;
 389                 tmp = Tmp.new(node.codeOrigin, :gpr)
 390                 comp = node.opcode[1] == ?b ? &quot;sltub&quot; : &quot;sltu&quot;
 391                 newList &lt;&lt; Instruction.new(node.codeOrigin, comp, [tmp, node.operands[1], node.operands[0]], annotation)
 392                 newList &lt;&lt; Instruction.new(node.codeOrigin, &quot;bz&quot;, [tmp, MIPS_ZERO_REG, node.operands[2]])
 393             when /^bt(i|p|b)/
 394                 lowerMIPSCondBranch(newList, &quot;b&quot; + $~.post_match + $1, node)
 395             else
 396                 newList &lt;&lt; node
 397             end
 398         else
 399             newList &lt;&lt; node
 400         end
 401     }
 402     newList
 403 end
 404 
 405 #
 406 # Specialization of lowering of malformed BaseIndex addresses.
 407 #
 408 
 409 class Node
 410     def mipsLowerMalformedAddressesRecurse(list)
 411         mapChildren {
 412             | subNode |
 413             subNode.mipsLowerMalformedAddressesRecurse(list)
 414         }
 415     end
 416 
 417     def mipsLowerShiftedAddressesRecurse(list, isFirst, tmp)
 418         mapChildren {
 419             | subNode |
 420             subNode.mipsLowerShiftedAddressesRecurse(list, isFirst, tmp)
 421         }
 422     end
 423 end
 424 
 425 class BaseIndex
 426     def mipsLowerMalformedAddressesRecurse(list)
 427         tmp = Tmp.new(codeOrigin, :gpr)
 428         if scaleShift == 0
 429             list &lt;&lt; Instruction.new(codeOrigin, &quot;addp&quot;, [base, index, tmp])
 430             Address.new(codeOrigin, tmp, Immediate.new(codeOrigin, offset.value));
 431         end
 432     end
 433 
 434     def mipsLowerShiftedAddressesRecurse(list, isFirst, tmp)
 435         if isFirst
 436             list &lt;&lt; Instruction.new(codeOrigin, &quot;lshifti&quot;, [index, Immediate.new(codeOrigin, scaleShift), tmp]);
 437             list &lt;&lt; Instruction.new(codeOrigin, &quot;addp&quot;, [base, tmp])
 438         end
 439         Address.new(codeOrigin, tmp, Immediate.new(codeOrigin, offset.value));
 440     end
 441 end
 442 
 443 #
 444 # Lowering of BaseIndex addresses with optimization for MIPS.
 445 #
 446 # offline asm instruction pair:
 447 #   loadi 4[cfr, t0, 8], t2
 448 #   loadi 0[cfr, t0, 8], t0
 449 #
 450 # lowered instructions: 
 451 #   lshifti t0, 3, tmp
 452 #   addp    cfr, tmp
 453 #   loadi   4[tmp], t2
 454 #   loadi   0[tmp], t0
 455 #
 456 
 457 def mipsHasShiftedBaseIndexAddress(instruction)
 458     instruction.operands.each_with_index {
 459         | operand, index |
 460         if operand.is_a? BaseIndex and operand.scaleShift != 0
 461             return index
 462         end
 463     }
 464     -1
 465 end
 466 
 467 def mipsScaleOfBaseIndexMatches(baseIndex0, baseIndex1)
 468     baseIndex0.base == baseIndex1.base and
 469     baseIndex0.index == baseIndex1.index and
 470     baseIndex0.scale == baseIndex1.scale
 471 end
 472 
 473 def mipsLowerBaseIndexAddresses(list)
 474     newList = [ list[0] ]
 475     tmp = nil
 476     list.each_cons(2) {
 477         | nodes |
 478         if nodes[1].is_a? Instruction
 479             ind = mipsHasShiftedBaseIndexAddress(nodes[1])
 480             if ind != -1
 481                 if nodes[0].is_a? Instruction and
 482                     nodes[0].opcode == nodes[1].opcode and
 483                     ind == mipsHasShiftedBaseIndexAddress(nodes[0]) and
 484                     mipsScaleOfBaseIndexMatches(nodes[0].operands[ind], nodes[1].operands[ind])
 485 
 486                     newList &lt;&lt; nodes[1].mipsLowerShiftedAddressesRecurse(newList, false, tmp)
 487                 else
 488                     tmp = Tmp.new(codeOrigin, :gpr)
 489                     newList &lt;&lt; nodes[1].mipsLowerShiftedAddressesRecurse(newList, true, tmp)
 490                 end
 491             else
 492                 newList &lt;&lt; nodes[1].mipsLowerMalformedAddressesRecurse(newList)
 493             end
 494         else
 495             newList &lt;&lt; nodes[1]
 496         end
 497     }
 498     newList
 499 end
 500 
 501 #
 502 # Lowering of misplaced immediates of MIPS specific instructions. For example:
 503 #
 504 # sltu reg, 4, 2
 505 #
 506 # will become:
 507 #
 508 # move 4, tmp
 509 # sltu reg, tmp, 2
 510 #
 511 
 512 def mipsLowerMisplacedImmediates(list)
 513     newList = []
 514     list.each {
 515         | node |
 516         if node.is_a? Instruction
 517             case node.opcode
 518             when &quot;slt&quot;, &quot;sltu&quot;, &quot;sltb&quot;, &quot;sltub&quot;
 519                 if node.operands[1].is_a? Immediate
 520                     tmp = Tmp.new(node.codeOrigin, :gpr)
 521                     newList &lt;&lt; Instruction.new(node.codeOrigin, &quot;move&quot;, [node.operands[1], tmp], node.annotation)
 522                     newList &lt;&lt; Instruction.new(node.codeOrigin, node.opcode,
 523                                                [node.operands[0], tmp, node.operands[2]],
 524                                                node.annotation)
 525                 else
 526                     newList &lt;&lt; node
 527                 end
 528             when /^(addi|subi)/
 529                 newList &lt;&lt; node.riscLowerMalformedImmediatesRecurse(newList, -0x7fff..0x7fff)
 530             when &quot;andi&quot;, &quot;andp&quot;, &quot;ori&quot;, &quot;orp&quot;, &quot;xori&quot;, &quot;xorp&quot;
 531                 newList &lt;&lt; node.riscLowerMalformedImmediatesRecurse(newList, 0..0xffff)
 532             else
 533                 newList &lt;&lt; node
 534             end
 535         else
 536             newList &lt;&lt; node
 537         end
 538     }
 539     newList
 540 end
 541 
 542 #
 543 # Specialization of lowering of misplaced addresses.
 544 #
 545 
 546 class LocalLabelReference
 547     def register?
 548         false
 549     end
 550 end
 551 
 552 def mipsAsRegister(preList, postList, operand, needRestore)
 553     tmp = MIPS_CALL_REG
 554     if operand.address?
 555         preList &lt;&lt; Instruction.new(operand.codeOrigin, &quot;loadp&quot;, [operand, MIPS_CALL_REG])
 556     elsif operand.is_a? LabelReference
 557         preList &lt;&lt; Instruction.new(operand.codeOrigin, &quot;la&quot;, [operand, MIPS_CALL_REG])
 558     elsif operand.register? and operand != MIPS_CALL_REG
 559         preList &lt;&lt; Instruction.new(operand.codeOrigin, &quot;move&quot;, [operand, MIPS_CALL_REG])
 560     else
 561         needRestore = false
 562         tmp = operand
 563     end
 564     if needRestore
 565         postList &lt;&lt; Instruction.new(operand.codeOrigin, &quot;move&quot;, [MIPS_GPSAVE_REG, MIPS_GP_REG])
 566     end
 567     tmp
 568 end
 569 
 570 def mipsLowerMisplacedAddresses(list)
 571     newList = []
 572     list.each {
 573         | node |
 574         if node.is_a? Instruction
 575             postInstructions = []
 576             annotation = node.annotation
 577             case node.opcode
 578             when &quot;jmp&quot;
 579                 newList &lt;&lt; Instruction.new(node.codeOrigin,
 580                                            node.opcode,
 581                                            [mipsAsRegister(newList, [], node.operands[0], false)])
 582             when &quot;call&quot;
 583                 newList &lt;&lt; Instruction.new(node.codeOrigin,
 584                                            node.opcode,
 585                                            [mipsAsRegister(newList, postInstructions, node.operands[0], true)])
 586             when &quot;slt&quot;, &quot;sltu&quot;
 587                 newList &lt;&lt; Instruction.new(node.codeOrigin,
 588                                            node.opcode,
 589                                            riscAsRegisters(newList, [], node.operands, &quot;i&quot;))
 590             when &quot;sltub&quot;, &quot;sltb&quot;
 591                 newList &lt;&lt; Instruction.new(node.codeOrigin,
 592                                            node.opcode,
 593                                            riscAsRegisters(newList, [], node.operands, &quot;b&quot;))
 594             when &quot;andb&quot;
 595                 newList &lt;&lt; Instruction.new(node.codeOrigin,
 596                                            &quot;andi&quot;,
 597                                            riscAsRegisters(newList, [], node.operands, &quot;b&quot;))
 598             when /^(bz|bnz|bs|bo)/
 599                 tl = $~.post_match == &quot;&quot; ? &quot;i&quot; : $~.post_match
 600                 newList &lt;&lt; Instruction.new(node.codeOrigin,
 601                                            node.opcode,
 602                                            riscAsRegisters(newList, [], node.operands, tl))
 603             else
 604                 newList &lt;&lt; node
 605             end
 606             newList += postInstructions
 607         else
 608             newList &lt;&lt; node
 609         end
 610     }
 611     newList
 612 end
 613 
 614 #
 615 # Lowering compares and tests.
 616 #
 617 
 618 def mipsLowerCompareTemplate(list, node, opCmp, opMov)
 619     tmp0 = Tmp.new(node.codeOrigin, :gpr)
 620     tmp1 = Tmp.new(node.codeOrigin, :gpr)
 621     list &lt;&lt; Instruction.new(node.codeOrigin, &quot;move&quot;, [Immediate.new(nil, 0), node.operands[2]])
 622     list &lt;&lt; Instruction.new(node.codeOrigin, opCmp, [node.operands[1], node.operands[0], tmp0])
 623     list &lt;&lt; Instruction.new(node.codeOrigin, &quot;move&quot;, [Immediate.new(nil, 1), tmp1])
 624     list &lt;&lt; Instruction.new(node.codeOrigin, opMov, [node.operands[2], tmp1, tmp0])
 625 end
 626 
 627 def mipsLowerCompares(list)
 628     newList = []
 629     list.each {
 630         | node |
 631         if node.is_a? Instruction
 632             case node.opcode
 633             when &quot;cieq&quot;, &quot;cpeq&quot;, &quot;cbeq&quot;
 634                 mipsLowerCompareTemplate(newList, node, &quot;subp&quot;, &quot;movz&quot;)
 635             when &quot;cineq&quot;, &quot;cpneq&quot;, &quot;cbneq&quot;
 636                 mipsLowerCompareTemplate(newList, node, &quot;subp&quot;, &quot;movn&quot;)
 637             when &quot;tiz&quot;, &quot;tbz&quot;, &quot;tpz&quot;
 638                 mipsLowerCompareTemplate(newList, node, &quot;andp&quot;, &quot;movz&quot;)
 639             when &quot;tinz&quot;, &quot;tbnz&quot;, &quot;tpnz&quot;
 640                 mipsLowerCompareTemplate(newList, node, &quot;andp&quot;, &quot;movn&quot;)
 641             when &quot;tio&quot;, &quot;tbo&quot;, &quot;tpo&quot;
 642                 tmp = Tmp.new(node.codeOrigin, :gpr)
 643                 list &lt;&lt; Instruction.new(node.codeOrigin, &quot;andp&quot;, [node.operands[1], node.operands[0], tmp])
 644                 list &lt;&lt; Instruction.new(node.codeOrigin, &quot;slt&quot;, [node.operands[2], MIPS_ZERO_REG, tmp])
 645             when &quot;tis&quot;, &quot;tbs&quot;, &quot;tps&quot;
 646                 tmp = Tmp.new(node.codeOrigin, :gpr)
 647                 list &lt;&lt; Instruction.new(node.codeOrigin, &quot;andp&quot;, [node.operands[1], node.operands[0], tmp])
 648                 list &lt;&lt; Instruction.new(node.codeOrigin, &quot;slt&quot;, [node.operands[2], tmp, MIPS_ZERO_REG])
 649             else
 650                 newList &lt;&lt; node
 651             end
 652         else
 653             newList &lt;&lt; node
 654         end
 655     }
 656     newList
 657 end
 658 
 659 #
 660 # Lea support.
 661 #
 662 
 663 class Address
 664     def mipsEmitLea(destination)
 665         if destination == base
 666             $asm.puts &quot;addiu #{destination.mipsOperand}, #{offset.value}&quot;
 667         else
 668             $asm.puts &quot;addiu #{destination.mipsOperand}, #{base.mipsOperand}, #{offset.value}&quot;
 669         end
 670     end
 671 end
 672 
 673 #
 674 # Add PIC compatible header code to all the LLInt rutins.
 675 #
 676 
 677 def mipsAddPICCode(list)
 678     myList = []
 679     list.each {
 680         | node |
 681         myList &lt;&lt; node
 682         if node.is_a? Label
 683             myList &lt;&lt; Instruction.new(node.codeOrigin, &quot;pichdr&quot;, [])
 684         end
 685     }
 686     myList
 687 end
 688 
 689 #
 690 # Actual lowering code follows.
 691 #
 692 
 693 class Sequence
 694     def getModifiedListMIPS
 695         result = @list
 696 
 697         # Verify that we will only see instructions and labels.
 698         result.each {
 699             | node |
 700             unless node.is_a? Instruction or
 701                     node.is_a? Label or
 702                     node.is_a? LocalLabel or
 703                     node.is_a? Skip
 704                 raise &quot;Unexpected #{node.inspect} at #{node.codeOrigin}&quot;
 705             end
 706         }
 707 
 708         result = mipsAddPICCode(result)
 709         result = mipsLowerFarBranchOps(result)
 710         result = mipsLowerSimpleBranchOps(result)
 711         result = riscLowerSimpleBranchOps(result)
 712         result = riscLowerHardBranchOps(result)
 713         result = riscLowerShiftOps(result)
 714         result = mipsLowerBaseIndexAddresses(result)
 715         result = riscLowerMalformedAddresses(result) {
 716             | node, address |
 717             if address.is_a? Address
 718                 (-0x7fff..0x7fff).include? address.offset.value
 719             else
 720                 false
 721             end
 722         }
 723         result = riscLowerMalformedAddressesDouble(result)
 724         result = riscLowerMisplacedImmediates(result, [&quot;storeb&quot;, &quot;storei&quot;, &quot;storep&quot;])
 725         result = mipsLowerMisplacedImmediates(result)
 726         result = riscLowerMalformedImmediates(result, -0x7fff..0x7fff)
 727         result = mipsLowerMisplacedAddresses(result)
 728         result = riscLowerMisplacedAddresses(result)
 729         result = riscLowerRegisterReuse(result)
 730         result = mipsLowerCompares(result)
 731         result = assignRegistersToTemporaries(result, :gpr, MIPS_TEMP_GPRS)
 732         result = assignRegistersToTemporaries(result, :fpr, MIPS_TEMP_FPRS)
 733 
 734         return result
 735     end
 736 end
 737 
 738 def mipsOperands(operands)
 739     operands.map{|v| v.mipsOperand}.join(&quot;, &quot;)
 740 end
 741 
 742 def mipsFlippedOperands(operands)
 743     mipsOperands([operands[-1]] + operands[0..-2])
 744 end
 745 
 746 def getMIPSOpcode(opcode, suffix)
 747 
 748 end
 749 
 750 def emitMIPSCompact(opcode, opcodei, operands)
 751     postfix = &quot;&quot;
 752     if opcode == &quot;sub&quot;
 753         if operands[0].is_a? Immediate
 754             opcode = &quot;add&quot;
 755             operands[0] = Immediate.new(operands[0].codeOrigin, -1 * operands[0].value)
 756         elsif operands[1].is_a? Immediate
 757             opcode = &quot;add&quot;
 758             operands[1] = Immediate.new(operands[1].codeOrigin, -1 * operands[1].value)
 759         end
 760         postfix = &quot;u&quot;
 761     elsif opcode == &quot;add&quot;
 762         postfix = &quot;u&quot;
 763     end
 764     if operands.size == 3
 765         if operands[0].is_a? Immediate
 766             $asm.puts &quot;#{opcode}i#{postfix} #{operands[2].mipsOperand}, #{operands[1].mipsOperand}, #{operands[0].value}&quot;
 767         elsif operands[1].is_a? Immediate
 768             $asm.puts &quot;#{opcode}i#{postfix} #{operands[2].mipsOperand}, #{operands[0].mipsOperand}, #{operands[1].value}&quot;
 769         else
 770             $asm.puts &quot;#{opcode}#{postfix} #{mipsFlippedOperands(operands)}&quot;
 771         end
 772     else
 773         raise unless operands.size == 2
 774         raise unless operands[1].register?
 775         if operands[0].is_a? Immediate
 776             $asm.puts &quot;#{opcode}i#{postfix} #{operands[1].mipsOperand}, #{operands[1].mipsOperand}, #{operands[0].mipsOperand}&quot;
 777         else
 778             $asm.puts &quot;#{opcode}#{postfix} #{operands[1].mipsOperand}, #{operands[1].mipsOperand}, #{operands[0].mipsOperand}&quot;
 779         end
 780     end
 781 end
 782 
 783 def emitMIPSShiftCompact(opcode, operands)
 784     if operands.size == 3
 785         if (operands[1].is_a? Immediate)
 786             $asm.puts &quot;#{opcode} #{operands[2].mipsOperand}, #{operands[0].mipsOperand}, #{operands[1].value}&quot;
 787         else
 788             $asm.puts &quot;#{opcode}v #{mipsFlippedOperands(operands)}&quot;
 789         end
 790     else
 791         raise unless operands.size == 2
 792         if operands[0].register?
 793             $asm.puts &quot;#{opcode}v #{operands[1].mipsOperand}, #{operands[1].mipsOperand}, #{operands[0].mipsOperand}&quot;
 794         else
 795             $asm.puts &quot;#{opcode} #{operands[1].mipsOperand}, #{operands[1].mipsOperand}, #{operands[0].value}&quot;
 796         end
 797     end
 798 end
 799 
 800 def emitMIPS(opcode, operands)
 801     if operands.size == 3
 802         $asm.puts &quot;#{opcode} #{mipsFlippedOperands(operands)}&quot;
 803     else
 804         raise unless operands.size == 2
 805         $asm.puts &quot;#{opcode} #{operands[1].mipsOperand}, #{operands[1].mipsOperand}, #{operands[0].mipsOperand}&quot;
 806     end
 807 end
 808 
 809 def emitMIPSDoubleBranch(branchOpcode, neg, operands)
 810     $asm.puts &quot;c.#{branchOpcode}.d #{mipsOperands(operands[0..1])}&quot;
 811     if (!neg)
 812         $asm.puts &quot;bc1t #{operands[2].asmLabel}&quot;
 813     else
 814         $asm.puts &quot;bc1f #{operands[2].asmLabel}&quot;
 815     end
 816 end
 817 
 818 def emitMIPSJumpOrCall(opcode, operand)
 819     if operand.label?
 820         raise &quot;Direct call/jump to a not local label.&quot; unless operand.is_a? LocalLabelReference
 821         $asm.puts &quot;#{opcode} #{operand.asmLabel}&quot;
 822     else
 823         raise &quot;Invalid call/jump register.&quot; unless operand == MIPS_CALL_REG
 824         $asm.puts &quot;#{opcode}r #{MIPS_CALL_REG.mipsOperand}&quot;
 825     end
 826 end
 827 
 828 class Instruction
 829     def lowerMIPS
 830         case opcode
 831         when &quot;addi&quot;, &quot;addp&quot;, &quot;addis&quot;
 832             if operands.size == 3 and operands[0].is_a? Immediate
 833                 raise unless operands[1].register?
 834                 raise unless operands[2].register?
 835                 if operands[0].value == 0 #and suffix.empty?
 836                     unless operands[1] == operands[2]
 837                         $asm.puts &quot;move #{operands[2].mipsOperand}, #{operands[1].mipsOperand}&quot;
 838                     end
 839                 else
 840                     $asm.puts &quot;addiu #{operands[2].mipsOperand}, #{operands[1].mipsOperand}, #{operands[0].mipsOperand}&quot;
 841                 end
 842             elsif operands.size == 3 and operands[0].register?
 843                 raise unless operands[1].register?
 844                 raise unless operands[2].register?
 845                 $asm.puts &quot;addu #{mipsFlippedOperands(operands)}&quot;
 846             else
 847                 if operands[0].is_a? Immediate
 848                     unless Immediate.new(nil, 0) == operands[0]
 849                         $asm.puts &quot;addiu #{operands[1].mipsOperand}, #{mipsFlippedOperands(operands)}&quot;
 850                     end
 851                 else
 852                     $asm.puts &quot;addu #{operands[1].mipsOperand}, #{operands[1].mipsOperand}, #{operands[0].mipsOperand}&quot;
 853                 end
 854             end
 855         when &quot;andi&quot;, &quot;andp&quot;
 856             emitMIPSCompact(&quot;and&quot;, &quot;and&quot;, operands)
 857         when &quot;ori&quot;, &quot;orp&quot;
 858             emitMIPSCompact(&quot;or&quot;, &quot;orr&quot;, operands)
 859         when &quot;oris&quot;
 860             emitMIPSCompact(&quot;or&quot;, &quot;orrs&quot;, operands)
 861         when &quot;xori&quot;, &quot;xorp&quot;
 862             emitMIPSCompact(&quot;xor&quot;, &quot;eor&quot;, operands)
 863         when &quot;lshifti&quot;, &quot;lshiftp&quot;
 864             emitMIPSShiftCompact(&quot;sll&quot;, operands)
 865         when &quot;rshifti&quot;, &quot;rshiftp&quot;
 866             emitMIPSShiftCompact(&quot;sra&quot;, operands)
 867         when &quot;urshifti&quot;, &quot;urshiftp&quot;
 868             emitMIPSShiftCompact(&quot;srl&quot;, operands)
 869         when &quot;muli&quot;, &quot;mulp&quot;
 870             emitMIPS(&quot;mul&quot;, operands)
 871         when &quot;subi&quot;, &quot;subp&quot;, &quot;subis&quot;
 872             emitMIPSCompact(&quot;sub&quot;, &quot;subs&quot;, operands)
 873         when &quot;negi&quot;, &quot;negp&quot;
 874             $asm.puts &quot;negu #{operands[0].mipsOperand}, #{operands[0].mipsOperand}&quot;
 875         when &quot;noti&quot;
 876             $asm.puts &quot;nor #{operands[0].mipsOperand}, #{operands[0].mipsOperand}, $zero&quot;
 877         when &quot;loadi&quot;, &quot;loadis&quot;, &quot;loadp&quot;
 878             $asm.puts &quot;lw #{mipsFlippedOperands(operands)}&quot;
 879         when &quot;storei&quot;, &quot;storep&quot;
 880             $asm.puts &quot;sw #{mipsOperands(operands)}&quot;
 881         when &quot;loadb&quot;
 882             $asm.puts &quot;lbu #{mipsFlippedOperands(operands)}&quot;
<a name="1" id="anc1"></a><span class="line-modified"> 883         when &quot;loadbsi&quot;</span>
 884             $asm.puts &quot;lb #{mipsFlippedOperands(operands)}&quot;
 885         when &quot;storeb&quot;
 886             $asm.puts &quot;sb #{mipsOperands(operands)}&quot;
 887         when &quot;loadh&quot;
 888             $asm.puts &quot;lhu #{mipsFlippedOperands(operands)}&quot;
<a name="2" id="anc2"></a><span class="line-modified"> 889         when &quot;loadhsi&quot;</span>
 890             $asm.puts &quot;lh #{mipsFlippedOperands(operands)}&quot;
 891         when &quot;storeh&quot;
 892             $asm.puts &quot;shv #{mipsOperands(operands)}&quot;
 893         when &quot;loadd&quot;
 894             $asm.puts &quot;ldc1 #{mipsFlippedOperands(operands)}&quot;
 895         when &quot;stored&quot;
 896             $asm.puts &quot;sdc1 #{mipsOperands(operands)}&quot;
 897         when &quot;la&quot;
 898             $asm.puts &quot;la #{operands[1].mipsOperand}, #{operands[0].asmLabel}&quot;
 899         when &quot;addd&quot;
 900             emitMIPS(&quot;add.d&quot;, operands)
 901         when &quot;divd&quot;
 902             emitMIPS(&quot;div.d&quot;, operands)
 903         when &quot;subd&quot;
 904             emitMIPS(&quot;sub.d&quot;, operands)
 905         when &quot;muld&quot;
 906             emitMIPS(&quot;mul.d&quot;, operands)
 907         when &quot;sqrtd&quot;
 908             $asm.puts &quot;sqrt.d #{mipsFlippedOperands(operands)}&quot;
 909         when &quot;ci2d&quot;
 910             raise &quot;invalid ops of #{self.inspect} at #{codeOriginString}&quot; unless operands[1].is_a? FPRegisterID and operands[0].register?
 911             $asm.puts &quot;mtc1 #{operands[0].mipsOperand}, #{operands[1].mipsOperand}&quot;
 912             $asm.puts &quot;cvt.d.w #{operands[1].mipsOperand}, #{operands[1].mipsOperand}&quot;
 913         when &quot;bdeq&quot;
 914             emitMIPSDoubleBranch(&quot;eq&quot;, false, operands)
 915         when &quot;bdneq&quot;
 916             emitMIPSDoubleBranch(&quot;ueq&quot;, true, operands)
 917         when &quot;bdgt&quot;
 918             emitMIPSDoubleBranch(&quot;ule&quot;, true, operands)
 919         when &quot;bdgteq&quot;
 920             emitMIPSDoubleBranch(&quot;ult&quot;, true, operands)
 921         when &quot;bdlt&quot;
 922             emitMIPSDoubleBranch(&quot;olt&quot;, false, operands)
 923         when &quot;bdlteq&quot;
 924             emitMIPSDoubleBranch(&quot;ole&quot;, false, operands)
 925         when &quot;bdequn&quot;
 926             emitMIPSDoubleBranch(&quot;ueq&quot;, false, operands)
 927         when &quot;bdnequn&quot;
 928             emitMIPSDoubleBranch(&quot;eq&quot;, true, operands)
 929         when &quot;bdgtun&quot;
 930             emitMIPSDoubleBranch(&quot;ole&quot;, true, operands)
 931         when &quot;bdgtequn&quot;
 932             emitMIPSDoubleBranch(&quot;olt&quot;, true, operands)
 933         when &quot;bdltun&quot;
 934             emitMIPSDoubleBranch(&quot;ult&quot;, false, operands)
 935         when &quot;bdltequn&quot;
 936             emitMIPSDoubleBranch(&quot;ule&quot;, false, operands)
 937         when &quot;btd2i&quot;
 938             # FIXME: may be a good idea to just get rid of this instruction, since the interpreter
 939             # currently does not use it.
 940             raise &quot;MIPS does not support this opcode yet, #{codeOrigin}&quot;
 941         when &quot;td2i&quot;
 942             $asm.puts &quot;cvt.w.d #{MIPS_SCRATCH_FPR.mipsSingleLo}, #{operands[0].mipsOperand}&quot;
 943             $asm.puts &quot;mfc1 #{operands[1].mipsOperand}, #{MIPS_SCRATCH_FPR.mipsSingleLo}&quot;
 944         when &quot;bcd2i&quot;
 945             $asm.puts &quot;cvt.w.d #{MIPS_SCRATCH_FPR.mipsSingleLo}, #{operands[0].mipsOperand}&quot;
 946             $asm.puts &quot;mfc1 #{operands[1].mipsOperand}, #{MIPS_SCRATCH_FPR.mipsSingleLo}&quot;
 947             $asm.puts &quot;cvt.d.w #{MIPS_SCRATCH_FPR.mipsOperand}, #{MIPS_SCRATCH_FPR.mipsSingleLo}&quot;
 948             emitMIPSDoubleBranch(&quot;eq&quot;, true, [MIPS_SCRATCH_FPR, operands[0], operands[2]])
 949             $asm.puts &quot;beq #{operands[1].mipsOperand}, $zero, #{operands[2].asmLabel}&quot;
 950         when &quot;movdz&quot;
 951             # FIXME: either support this or remove it.
 952             raise &quot;MIPS does not support this opcode yet, #{codeOrigin}&quot;
 953         when &quot;pop&quot;
 954             operands.each {
 955                 | op |
 956                 $asm.puts &quot;lw #{op.mipsOperand}, 0($sp)&quot;
 957                 $asm.puts &quot;addiu $sp, $sp, 4&quot;
 958             }
 959         when &quot;push&quot;
 960             operands.each {
 961                 | op |
 962                 $asm.puts &quot;addiu $sp, $sp, -4&quot;
 963                 $asm.puts &quot;sw #{op.mipsOperand}, 0($sp)&quot;
 964             }
 965         when &quot;move&quot;, &quot;sxi2p&quot;, &quot;zxi2p&quot;
 966             if operands[0].is_a? Immediate
 967                 mipsMoveImmediate(operands[0].value, operands[1])
 968             else
 969                 $asm.puts &quot;move #{mipsFlippedOperands(operands)}&quot;
 970             end
 971         when &quot;nop&quot;
 972             $asm.puts &quot;nop&quot;
 973         when &quot;bieq&quot;, &quot;bpeq&quot;, &quot;bbeq&quot;
 974             $asm.puts &quot;beq #{mipsOperands(operands[0..1])}, #{operands[2].asmLabel}&quot;
 975         when &quot;bineq&quot;, &quot;bpneq&quot;, &quot;bbneq&quot;
 976             $asm.puts &quot;bne #{mipsOperands(operands[0..1])}, #{operands[2].asmLabel}&quot;
 977         when &quot;bigt&quot;, &quot;bpgt&quot;, &quot;bbgt&quot;
 978             $asm.puts &quot;bgt #{mipsOperands(operands[0..1])}, #{operands[2].asmLabel}&quot;
 979         when &quot;bigteq&quot;, &quot;bpgteq&quot;, &quot;bbgteq&quot;
 980             $asm.puts &quot;bge #{mipsOperands(operands[0..1])}, #{operands[2].asmLabel}&quot;
 981         when &quot;bilt&quot;, &quot;bplt&quot;, &quot;bblt&quot;
 982             $asm.puts &quot;blt #{mipsOperands(operands[0..1])}, #{operands[2].asmLabel}&quot;
 983         when &quot;bilteq&quot;, &quot;bplteq&quot;, &quot;bblteq&quot;
 984             $asm.puts &quot;ble #{mipsOperands(operands[0..1])}, #{operands[2].asmLabel}&quot;
 985         when &quot;jmp&quot;
 986             emitMIPSJumpOrCall(&quot;j&quot;, operands[0])
 987         when &quot;call&quot;
 988             emitMIPSJumpOrCall(&quot;jal&quot;, operands[0])
 989         when &quot;break&quot;
 990             $asm.puts &quot;break&quot;
 991         when &quot;ret&quot;
 992             $asm.puts &quot;jr $ra&quot;
 993         when &quot;cia&quot;, &quot;cpa&quot;, &quot;cba&quot;
 994             $asm.puts &quot;sltu #{operands[2].mipsOperand}, #{operands[1].mipsOperand}, #{operands[0].mipsOperand}&quot;
 995         when &quot;ciaeq&quot;, &quot;cpaeq&quot;, &quot;cbaeq&quot;
 996             $asm.puts &quot;sltu #{operands[2].mipsOperand}, #{operands[0].mipsOperand}, #{operands[1].mipsOperand}&quot;
 997             $asm.puts &quot;xori #{operands[2].mipsOperand}, 1&quot;
 998         when &quot;cib&quot;, &quot;cpb&quot;, &quot;cbb&quot;
 999             $asm.puts &quot;sltu #{operands[2].mipsOperand}, #{operands[0].mipsOperand}, #{operands[1].mipsOperand}&quot;
1000         when &quot;cibeq&quot;, &quot;cpbeq&quot;, &quot;cbbeq&quot;
1001             $asm.puts &quot;sltu #{operands[2].mipsOperand}, #{operands[1].mipsOperand}, #{operands[0].mipsOperand}&quot;
1002             $asm.puts &quot;xori #{operands[2].mipsOperand}, 1&quot;
1003         when &quot;cigt&quot;, &quot;cpgt&quot;, &quot;cbgt&quot;
1004             $asm.puts &quot;slt #{operands[2].mipsOperand}, #{operands[1].mipsOperand}, #{operands[0].mipsOperand}&quot;
1005         when &quot;cigteq&quot;, &quot;cpgteq&quot;, &quot;cbgteq&quot;
1006             $asm.puts &quot;slt #{operands[2].mipsOperand}, #{operands[0].mipsOperand}, #{operands[1].mipsOperand}&quot;
1007             $asm.puts &quot;xori #{operands[2].mipsOperand}, 1&quot;
1008         when &quot;cilt&quot;, &quot;cplt&quot;, &quot;cblt&quot;
1009             $asm.puts &quot;slt #{operands[2].mipsOperand}, #{operands[0].mipsOperand}, #{operands[1].mipsOperand}&quot;
1010         when &quot;cilteq&quot;, &quot;cplteq&quot;, &quot;cblteq&quot;
1011             $asm.puts &quot;slt #{operands[2].mipsOperand}, #{operands[1].mipsOperand}, #{operands[0].mipsOperand}&quot;
1012             $asm.puts &quot;xori #{operands[2].mipsOperand}, 1&quot;
1013         when &quot;peek&quot;
1014             $asm.puts &quot;lw #{operands[1].mipsOperand}, #{operands[0].value * 4}($sp)&quot;
1015         when &quot;poke&quot;
1016             $asm.puts &quot;sw #{operands[1].mipsOperand}, #{operands[0].value * 4}($sp)&quot;
1017         when &quot;fii2d&quot;
1018             $asm.puts &quot;mtc1 #{operands[0].mipsOperand}, #{operands[2].mipsSingleLo}&quot;
1019             $asm.putStr(&quot;#if WTF_MIPS_ISA_REV_AT_LEAST(2)&quot;)
1020             $asm.puts &quot;mthc1 #{operands[1].mipsOperand}, #{operands[2].mipsSingleLo}&quot;
1021             $asm.putStr(&quot;#else&quot;)
1022             $asm.puts &quot;mtc1 #{operands[1].mipsOperand}, #{operands[2].mipsSingleHi}&quot;
1023             $asm.putStr(&quot;#endif&quot;)
1024         when &quot;fd2ii&quot;
1025             $asm.puts &quot;mfc1 #{operands[1].mipsOperand}, #{operands[0].mipsSingleLo}&quot;
1026             $asm.putStr(&quot;#if WTF_MIPS_ISA_REV_AT_LEAST(2)&quot;)
1027             $asm.puts &quot;mfhc1 #{operands[2].mipsOperand}, #{operands[0].mipsSingleLo}&quot;
1028             $asm.putStr(&quot;#else&quot;)
1029             $asm.puts &quot;mfc1 #{operands[2].mipsOperand}, #{operands[0].mipsSingleHi}&quot;
1030             $asm.putStr(&quot;#endif&quot;)
1031         when /^bo/
1032             $asm.puts &quot;bgt #{operands[0].mipsOperand}, #{operands[1].mipsOperand}, #{operands[2].asmLabel}&quot;
1033         when /^bs/
1034             $asm.puts &quot;blt #{operands[0].mipsOperand}, #{operands[1].mipsOperand}, #{operands[2].asmLabel}&quot;
1035         when /^bz/
1036             $asm.puts &quot;beq #{operands[0].mipsOperand}, #{operands[1].mipsOperand}, #{operands[2].asmLabel}&quot;
1037         when /^bnz/
1038             $asm.puts &quot;bne #{operands[0].mipsOperand}, #{operands[1].mipsOperand}, #{operands[2].asmLabel}&quot;
1039         when &quot;leai&quot;, &quot;leap&quot;
1040             if operands[0].is_a? LabelReference
1041                 labelRef = operands[0]
1042                 raise unless labelRef.offset == 0
1043                 $asm.puts &quot;lw #{operands[1].mipsOperand}, %got(#{labelRef.asmLabel})($gp)&quot;
1044             else
1045                 operands[0].mipsEmitLea(operands[1])
1046             end
1047 
1048         when &quot;smulli&quot;
1049             raise &quot;Wrong number of arguments to smull in #{self.inspect} at #{codeOriginString}&quot; unless operands.length == 4
1050             $asm.puts &quot;mult #{operands[0].mipsOperand}, #{operands[1].mipsOperand}&quot;
1051             $asm.puts &quot;mflo #{operands[2].mipsOperand}&quot;
1052             $asm.puts &quot;mfhi #{operands[3].mipsOperand}&quot;
1053         when &quot;movz&quot;
1054             $asm.puts &quot;movz #{operands[0].mipsOperand}, #{operands[1].mipsOperand}, #{operands[2].mipsOperand}&quot;
1055         when &quot;movn&quot;
1056             $asm.puts &quot;movn #{operands[0].mipsOperand}, #{operands[1].mipsOperand}, #{operands[2].mipsOperand}&quot;
1057         when &quot;setcallreg&quot;
1058             $asm.puts &quot;move #{MIPS_CALL_REG.mipsOperand}, #{operands[0].mipsOperand}&quot;
1059         when &quot;slt&quot;, &quot;sltb&quot;
1060             $asm.puts &quot;slt #{operands[0].mipsOperand}, #{operands[1].mipsOperand}, #{operands[2].mipsOperand}&quot;
1061         when &quot;sltu&quot;, &quot;sltub&quot;
1062             $asm.puts &quot;sltu #{operands[0].mipsOperand}, #{operands[1].mipsOperand}, #{operands[2].mipsOperand}&quot;
1063         when &quot;pichdr&quot;
1064             $asm.putStr(&quot;OFFLINE_ASM_CPLOAD(#{MIPS_CALL_REG.mipsOperand})&quot;)
1065         when &quot;memfence&quot;
1066             $asm.puts &quot;sync&quot;
1067         else
1068             lowerDefault
1069         end
1070     end
1071 end
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>