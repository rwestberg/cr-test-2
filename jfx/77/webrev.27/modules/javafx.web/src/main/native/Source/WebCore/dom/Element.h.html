<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/dom/Element.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
  3  *           (C) 1999 Antti Koivisto (koivisto@kde.org)
  4  *           (C) 2001 Peter Kelly (pmk@post.com)
  5  *           (C) 2001 Dirk Mueller (mueller@kde.org)
  6  * Copyright (C) 2003-2017 Apple Inc. All rights reserved.
  7  *
  8  * This library is free software; you can redistribute it and/or
  9  * modify it under the terms of the GNU Library General Public
 10  * License as published by the Free Software Foundation; either
 11  * version 2 of the License, or (at your option) any later version.
 12  *
 13  * This library is distributed in the hope that it will be useful,
 14  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 15  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 16  * Library General Public License for more details.
 17  *
 18  * You should have received a copy of the GNU Library General Public License
 19  * along with this library; see the file COPYING.LIB.  If not, write to
 20  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 21  * Boston, MA 02110-1301, USA.
 22  *
 23  */
 24 
 25 #pragma once
 26 
 27 #include &quot;AXTextStateChangeIntent.h&quot;
 28 #include &quot;Document.h&quot;
 29 #include &quot;ElementData.h&quot;
 30 #include &quot;HTMLNames.h&quot;
 31 #include &quot;KeyframeAnimationOptions.h&quot;
 32 #include &quot;ScrollToOptions.h&quot;
 33 #include &quot;ScrollTypes.h&quot;
 34 #include &quot;ShadowRootMode.h&quot;
 35 #include &quot;SimulatedClickOptions.h&quot;
 36 #include &quot;StyleChange.h&quot;
 37 
 38 namespace WebCore {
 39 
 40 class CustomElementReactionQueue;
 41 class DatasetDOMStringMap;
 42 class DOMRect;
 43 class DOMRectList;
 44 class DOMTokenList;
 45 class ElementRareData;
 46 class Frame;
 47 class HTMLDocument;
 48 class IntSize;
 49 class JSCustomElementInterface;
 50 class KeyboardEvent;
 51 class Locale;
 52 class PlatformKeyboardEvent;
 53 class PlatformMouseEvent;
 54 class PlatformWheelEvent;
 55 class PseudoElement;
 56 class RenderTreePosition;
 57 class StylePropertyMap;
 58 class WebAnimation;
 59 struct ElementStyle;
 60 struct ScrollIntoViewOptions;
 61 
 62 #if ENABLE(INTERSECTION_OBSERVER)
 63 struct IntersectionObserverData;
 64 #endif
 65 
 66 #if ENABLE(RESIZE_OBSERVER)
 67 struct ResizeObserverData;
 68 #endif
 69 
 70 enum SpellcheckAttributeState {
 71     SpellcheckAttributeTrue,
 72     SpellcheckAttributeFalse,
 73     SpellcheckAttributeDefault
 74 };
 75 
 76 class Element : public ContainerNode {
 77     WTF_MAKE_ISO_ALLOCATED(Element);
 78 public:
 79     static Ref&lt;Element&gt; create(const QualifiedName&amp;, Document&amp;);
 80     virtual ~Element();
 81 
 82     WEBCORE_EXPORT bool hasAttribute(const QualifiedName&amp;) const;
 83     WEBCORE_EXPORT const AtomString&amp; getAttribute(const QualifiedName&amp;) const;
 84     template&lt;typename... QualifiedNames&gt;
 85     const AtomString&amp; getAttribute(const QualifiedName&amp;, const QualifiedNames&amp;...) const;
 86     WEBCORE_EXPORT void setAttribute(const QualifiedName&amp;, const AtomString&amp; value);
 87     WEBCORE_EXPORT void setAttributeWithoutSynchronization(const QualifiedName&amp;, const AtomString&amp; value);
 88     void setSynchronizedLazyAttribute(const QualifiedName&amp;, const AtomString&amp; value);
 89     bool removeAttribute(const QualifiedName&amp;);
 90     Vector&lt;String&gt; getAttributeNames() const;
 91 
 92     // Typed getters and setters for language bindings.
 93     WEBCORE_EXPORT int getIntegralAttribute(const QualifiedName&amp; attributeName) const;
 94     WEBCORE_EXPORT void setIntegralAttribute(const QualifiedName&amp; attributeName, int value);
 95     WEBCORE_EXPORT unsigned getUnsignedIntegralAttribute(const QualifiedName&amp; attributeName) const;
 96     WEBCORE_EXPORT void setUnsignedIntegralAttribute(const QualifiedName&amp; attributeName, unsigned value);
 97 
 98     // Call this to get the value of an attribute that is known not to be the style
 99     // attribute or one of the SVG animatable attributes.
100     bool hasAttributeWithoutSynchronization(const QualifiedName&amp;) const;
101     const AtomString&amp; attributeWithoutSynchronization(const QualifiedName&amp;) const;
102 #ifndef NDEBUG
103     WEBCORE_EXPORT bool fastAttributeLookupAllowed(const QualifiedName&amp;) const;
104 #endif
105 
106 #if DUMP_NODE_STATISTICS
107     bool hasNamedNodeMap() const;
108 #endif
109     WEBCORE_EXPORT bool hasAttributes() const;
110     // This variant will not update the potentially invalid attributes. To be used when not interested
111     // in style attribute or one of the SVG animation attributes.
112     bool hasAttributesWithoutUpdate() const;
113 
114     WEBCORE_EXPORT bool hasAttribute(const AtomString&amp; qualifiedName) const;
115     WEBCORE_EXPORT bool hasAttributeNS(const AtomString&amp; namespaceURI, const AtomString&amp; localName) const;
116 
117     WEBCORE_EXPORT const AtomString&amp; getAttribute(const AtomString&amp; qualifiedName) const;
118     WEBCORE_EXPORT const AtomString&amp; getAttributeNS(const AtomString&amp; namespaceURI, const AtomString&amp; localName) const;
119 
120     WEBCORE_EXPORT ExceptionOr&lt;void&gt; setAttribute(const AtomString&amp; qualifiedName, const AtomString&amp; value);
121     static ExceptionOr&lt;QualifiedName&gt; parseAttributeName(const AtomString&amp; namespaceURI, const AtomString&amp; qualifiedName);
122     WEBCORE_EXPORT ExceptionOr&lt;void&gt; setAttributeNS(const AtomString&amp; namespaceURI, const AtomString&amp; qualifiedName, const AtomString&amp; value);
123 
124     ExceptionOr&lt;bool&gt; toggleAttribute(const AtomString&amp; qualifiedName, Optional&lt;bool&gt; force);
125 
126     const AtomString&amp; getIdAttribute() const;
127     void setIdAttribute(const AtomString&amp;);
128 
129     const AtomString&amp; getNameAttribute() const;
130 
131     // Call this to get the value of the id attribute for style resolution purposes.
132     // The value will already be lowercased if the document is in compatibility mode,
133     // so this function is not suitable for non-style uses.
134     const AtomString&amp; idForStyleResolution() const;
135 
136     // Internal methods that assume the existence of attribute storage, one should use hasAttributes()
137     // before calling them.
138     AttributeIteratorAccessor attributesIterator() const { return elementData()-&gt;attributesIterator(); }
139     unsigned attributeCount() const;
140     const Attribute&amp; attributeAt(unsigned index) const;
141     const Attribute* findAttributeByName(const QualifiedName&amp;) const;
142     unsigned findAttributeIndexByName(const QualifiedName&amp; name) const { return elementData()-&gt;findAttributeIndexByName(name); }
143     unsigned findAttributeIndexByName(const AtomString&amp; name, bool shouldIgnoreAttributeCase) const { return elementData()-&gt;findAttributeIndexByName(name, shouldIgnoreAttributeCase); }
144 
145     WEBCORE_EXPORT void scrollIntoView(Optional&lt;Variant&lt;bool, ScrollIntoViewOptions&gt;&gt;&amp;&amp; arg);
146     WEBCORE_EXPORT void scrollIntoView(bool alignToTop = true);
147     WEBCORE_EXPORT void scrollIntoViewIfNeeded(bool centerIfNeeded = true);
148     WEBCORE_EXPORT void scrollIntoViewIfNotVisible(bool centerIfNotVisible = true);
149 
150     void scrollBy(const ScrollToOptions&amp;);
151     void scrollBy(double x, double y);
152     virtual void scrollTo(const ScrollToOptions&amp;, ScrollClamping = ScrollClamping::Clamped);
153     void scrollTo(double x, double y);
154 
155     WEBCORE_EXPORT void scrollByLines(int lines);
156     WEBCORE_EXPORT void scrollByPages(int pages);
157 
158     WEBCORE_EXPORT double offsetLeftForBindings();
159     WEBCORE_EXPORT double offsetLeft();
160     WEBCORE_EXPORT double offsetTopForBindings();
161     WEBCORE_EXPORT double offsetTop();
162     WEBCORE_EXPORT double offsetWidth();
163     WEBCORE_EXPORT double offsetHeight();
164 
165     bool mayCauseRepaintInsideViewport(const IntRect* visibleRect = nullptr) const;
166 
167     // FIXME: Replace uses of offsetParent in the platform with calls
168     // to the render layer and merge bindingsOffsetParent and offsetParent.
169     WEBCORE_EXPORT Element* offsetParentForBindings();
170 
171     const Element* rootElement() const;
172 
173     Element* offsetParent();
174     WEBCORE_EXPORT double clientLeft();
175     WEBCORE_EXPORT double clientTop();
176     WEBCORE_EXPORT double clientWidth();
177     WEBCORE_EXPORT double clientHeight();
178 
179     virtual int scrollLeft();
180     virtual int scrollTop();
181     virtual void setScrollLeft(int);
182     virtual void setScrollTop(int);
183     virtual int scrollWidth();
184     virtual int scrollHeight();
185 
186     WEBCORE_EXPORT IntRect boundsInRootViewSpace();
187 
188     Optional&lt;std::pair&lt;RenderObject*, FloatRect&gt;&gt; boundingAbsoluteRectWithoutLayout();
189 
190     WEBCORE_EXPORT FloatRect boundingClientRect();
191 
192     WEBCORE_EXPORT Ref&lt;DOMRectList&gt; getClientRects();
193     Ref&lt;DOMRect&gt; getBoundingClientRect();
194 
195     // Returns the absolute bounding box translated into client coordinates.
196     WEBCORE_EXPORT IntRect clientRect() const;
197     // Returns the absolute bounding box translated into screen coordinates.
198     WEBCORE_EXPORT IntRect screenRect() const;
199 
200     WEBCORE_EXPORT bool removeAttribute(const AtomString&amp; qualifiedName);
201     WEBCORE_EXPORT bool removeAttributeNS(const AtomString&amp; namespaceURI, const AtomString&amp; localName);
202 
203     Ref&lt;Attr&gt; detachAttribute(unsigned index);
204 
205     WEBCORE_EXPORT RefPtr&lt;Attr&gt; getAttributeNode(const AtomString&amp; qualifiedName);
206     WEBCORE_EXPORT RefPtr&lt;Attr&gt; getAttributeNodeNS(const AtomString&amp; namespaceURI, const AtomString&amp; localName);
207     WEBCORE_EXPORT ExceptionOr&lt;RefPtr&lt;Attr&gt;&gt; setAttributeNode(Attr&amp;);
208     WEBCORE_EXPORT ExceptionOr&lt;RefPtr&lt;Attr&gt;&gt; setAttributeNodeNS(Attr&amp;);
209     WEBCORE_EXPORT ExceptionOr&lt;Ref&lt;Attr&gt;&gt; removeAttributeNode(Attr&amp;);
210 
211     RefPtr&lt;Attr&gt; attrIfExists(const QualifiedName&amp;);
212     RefPtr&lt;Attr&gt; attrIfExists(const AtomString&amp; localName, bool shouldIgnoreAttributeCase);
213     Ref&lt;Attr&gt; ensureAttr(const QualifiedName&amp;);
214 
215     const Vector&lt;RefPtr&lt;Attr&gt;&gt;&amp; attrNodeList();
216 
217     const QualifiedName&amp; tagQName() const { return m_tagName; }
218 #if ENABLE(JIT)
219     static ptrdiff_t tagQNameMemoryOffset() { return OBJECT_OFFSETOF(Element, m_tagName); }
220 #endif // ENABLE(JIT)
221     String tagName() const { return nodeName(); }
222     bool hasTagName(const QualifiedName&amp; tagName) const { return m_tagName.matches(tagName); }
223     bool hasTagName(const HTMLQualifiedName&amp; tagName) const { return ContainerNode::hasTagName(tagName); }
224     bool hasTagName(const MathMLQualifiedName&amp; tagName) const { return ContainerNode::hasTagName(tagName); }
225     bool hasTagName(const SVGQualifiedName&amp; tagName) const { return ContainerNode::hasTagName(tagName); }
226 
227     // A fast function for checking the local name against another atomic string.
228     bool hasLocalName(const AtomString&amp; other) const { return m_tagName.localName() == other; }
229 
230     const AtomString&amp; localName() const final { return m_tagName.localName(); }
231     const AtomString&amp; prefix() const final { return m_tagName.prefix(); }
232     const AtomString&amp; namespaceURI() const final { return m_tagName.namespaceURI(); }
233 
234     ExceptionOr&lt;void&gt; setPrefix(const AtomString&amp;) final;
235 
236     String nodeName() const override;
237 
238     Ref&lt;Element&gt; cloneElementWithChildren(Document&amp;);
239     Ref&lt;Element&gt; cloneElementWithoutChildren(Document&amp;);
240 
241     void normalizeAttributes();
242     String nodeNamePreservingCase() const;
243 
244     WEBCORE_EXPORT void setBooleanAttribute(const QualifiedName&amp; name, bool);
245 
246     // For exposing to DOM only.
247     WEBCORE_EXPORT NamedNodeMap&amp; attributes() const;
248 
249     enum AttributeModificationReason {
250         ModifiedDirectly,
251         ModifiedByCloning
252     };
253 
254     // This method is called whenever an attribute is added, changed or removed.
255     virtual void attributeChanged(const QualifiedName&amp;, const AtomString&amp; oldValue, const AtomString&amp; newValue, AttributeModificationReason = ModifiedDirectly);
256     virtual void parseAttribute(const QualifiedName&amp;, const AtomString&amp;) { }
257 
258     // Only called by the parser immediately after element construction.
259     void parserSetAttributes(const Vector&lt;Attribute&gt;&amp;);
260 
261     bool isEventHandlerAttribute(const Attribute&amp;) const;
262     bool isJavaScriptURLAttribute(const Attribute&amp;) const;
263 
264     // Remove attributes that might introduce scripting from the vector leaving the element unchanged.
265     void stripScriptingAttributes(Vector&lt;Attribute&gt;&amp;) const;
266 
267     const ElementData* elementData() const { return m_elementData.get(); }
268     static ptrdiff_t elementDataMemoryOffset() { return OBJECT_OFFSETOF(Element, m_elementData); }
269     UniqueElementData&amp; ensureUniqueElementData();
270 
271     void synchronizeAllAttributes() const;
272 
273     // Clones attributes only.
274     void cloneAttributesFromElement(const Element&amp;);
275 
276     // Clones all attribute-derived data, including subclass specifics (through copyNonAttributeProperties.)
277     void cloneDataFromElement(const Element&amp;);
278 
279     virtual void didMoveToNewDocument(Document&amp; oldDocument, Document&amp; newDocument);
280 
281     bool hasEquivalentAttributes(const Element&amp; other) const;
282 
283     virtual void copyNonAttributePropertiesFromElement(const Element&amp;) { }
284 
285     virtual RenderPtr&lt;RenderElement&gt; createElementRenderer(RenderStyle&amp;&amp;, const RenderTreePosition&amp;);
286     virtual bool rendererIsNeeded(const RenderStyle&amp;);
287 
288     WEBCORE_EXPORT ShadowRoot* shadowRoot() const;
289     ShadowRoot* shadowRootForBindings(JSC::ExecState&amp;) const;
290 
291     struct ShadowRootInit {
292         ShadowRootMode mode;
293     };
294     ExceptionOr&lt;ShadowRoot&amp;&gt; attachShadow(const ShadowRootInit&amp;);
295 
296     RefPtr&lt;ShadowRoot&gt; userAgentShadowRoot() const;
297     WEBCORE_EXPORT ShadowRoot&amp; ensureUserAgentShadowRoot();
298 
299     void setIsDefinedCustomElement(JSCustomElementInterface&amp;);
300     void setIsFailedCustomElement(JSCustomElementInterface&amp;);
301     void setIsCustomElementUpgradeCandidate();
302     void enqueueToUpgrade(JSCustomElementInterface&amp;);
303     CustomElementReactionQueue* reactionQueue() const;
304 
305     // FIXME: this should not be virtual, do not override this.
306     virtual const AtomString&amp; shadowPseudoId() const;
307 
308     bool isInActiveChain() const { return isUserActionElement() &amp;&amp; isUserActionElementInActiveChain(); }
309     bool active() const { return isUserActionElement() &amp;&amp; isUserActionElementActive(); }
310     bool hovered() const { return isUserActionElement() &amp;&amp; isUserActionElementHovered(); }
311     bool focused() const { return isUserActionElement() &amp;&amp; isUserActionElementFocused(); }
312     bool hasFocusWithin() const { return getFlag(HasFocusWithin); };
313 
314     virtual void setActive(bool flag = true, bool pause = false);
315     virtual void setHovered(bool flag = true);
316     virtual void setFocus(bool flag);
317     void setHasFocusWithin(bool flag);
318 
319     Optional&lt;int&gt; tabIndexSetExplicitly() const;
320     bool shouldBeIgnoredInSequentialFocusNavigation() const { return defaultTabIndex() &lt; 0 &amp;&amp; !supportsFocus(); }
321     virtual bool supportsFocus() const;
322     virtual bool isFocusable() const;
323     virtual bool isKeyboardFocusable(KeyboardEvent*) const;
324     virtual bool isMouseFocusable() const;
325 
326     virtual bool shouldUseInputMethod();
327 
328     virtual int tabIndexForBindings() const;
329     WEBCORE_EXPORT void setTabIndexForBindings(int);
330     virtual RefPtr&lt;Element&gt; focusDelegate();
331 
332     ExceptionOr&lt;void&gt; insertAdjacentHTML(const String&amp; where, const String&amp; html, NodeVector* addedNodes);
333 
334     WEBCORE_EXPORT ExceptionOr&lt;Element*&gt; insertAdjacentElement(const String&amp; where, Element&amp; newChild);
335     WEBCORE_EXPORT ExceptionOr&lt;void&gt; insertAdjacentHTML(const String&amp; where, const String&amp; html);
336     WEBCORE_EXPORT ExceptionOr&lt;void&gt; insertAdjacentText(const String&amp; where, const String&amp; text);
337 
338     const RenderStyle* computedStyle(PseudoId = PseudoId::None) override;
339 
340     bool needsStyleInvalidation() const;
341 
342     // Methods for indicating the style is affected by dynamic updates (e.g., children changing, our position changing in our sibling list, etc.)
343     bool styleAffectedByActive() const { return hasStyleFlag(ElementStyleFlag::StyleAffectedByActive); }
344     bool styleAffectedByEmpty() const { return hasStyleFlag(ElementStyleFlag::StyleAffectedByEmpty); }
345     bool styleAffectedByFocusWithin() const { return getFlag(StyleAffectedByFocusWithinFlag); }
346     bool descendantsAffectedByPreviousSibling() const { return getFlag(DescendantsAffectedByPreviousSiblingFlag); }
347     bool childrenAffectedByHover() const { return getFlag(ChildrenAffectedByHoverRulesFlag); }
348     bool childrenAffectedByDrag() const { return hasStyleFlag(ElementStyleFlag::ChildrenAffectedByDrag); }
349     bool childrenAffectedByFirstChildRules() const { return getFlag(ChildrenAffectedByFirstChildRulesFlag); }
350     bool childrenAffectedByLastChildRules() const { return getFlag(ChildrenAffectedByLastChildRulesFlag); }
351     bool childrenAffectedByForwardPositionalRules() const { return hasStyleFlag(ElementStyleFlag::ChildrenAffectedByForwardPositionalRules); }
352     bool descendantsAffectedByForwardPositionalRules() const { return hasStyleFlag(ElementStyleFlag::DescendantsAffectedByForwardPositionalRules); }
353     bool childrenAffectedByBackwardPositionalRules() const { return hasStyleFlag(ElementStyleFlag::ChildrenAffectedByBackwardPositionalRules); }
354     bool descendantsAffectedByBackwardPositionalRules() const { return hasStyleFlag(ElementStyleFlag::DescendantsAffectedByBackwardPositionalRules); }
355     bool childrenAffectedByPropertyBasedBackwardPositionalRules() const { return hasStyleFlag(ElementStyleFlag::ChildrenAffectedByPropertyBasedBackwardPositionalRules); }
356     bool affectsNextSiblingElementStyle() const { return getFlag(AffectsNextSiblingElementStyle); }
357     unsigned childIndex() const { return hasRareData() ? rareDataChildIndex() : 0; }
358 
359     bool hasFlagsSetDuringStylingOfChildren() const;
360 
361     void setStyleAffectedByEmpty() { setStyleFlag(ElementStyleFlag::StyleAffectedByEmpty); }
362     void setStyleAffectedByFocusWithin() { setFlag(StyleAffectedByFocusWithinFlag); }
363     void setDescendantsAffectedByPreviousSibling() { setFlag(DescendantsAffectedByPreviousSiblingFlag); }
364     void setChildrenAffectedByHover() { setFlag(ChildrenAffectedByHoverRulesFlag); }
365     void setStyleAffectedByActive() { setStyleFlag(ElementStyleFlag::StyleAffectedByActive); }
366     void setChildrenAffectedByDrag() { setStyleFlag(ElementStyleFlag::ChildrenAffectedByDrag); }
367     void setChildrenAffectedByFirstChildRules() { setFlag(ChildrenAffectedByFirstChildRulesFlag); }
368     void setChildrenAffectedByLastChildRules() { setFlag(ChildrenAffectedByLastChildRulesFlag); }
369     void setChildrenAffectedByForwardPositionalRules() { setStyleFlag(ElementStyleFlag::ChildrenAffectedByForwardPositionalRules); }
370     void setDescendantsAffectedByForwardPositionalRules() { setStyleFlag(ElementStyleFlag::DescendantsAffectedByForwardPositionalRules); }
371     void setChildrenAffectedByBackwardPositionalRules() { setStyleFlag(ElementStyleFlag::ChildrenAffectedByBackwardPositionalRules); }
372     void setDescendantsAffectedByBackwardPositionalRules() { setStyleFlag(ElementStyleFlag::DescendantsAffectedByBackwardPositionalRules); }
373     void setChildrenAffectedByPropertyBasedBackwardPositionalRules() { setStyleFlag(ElementStyleFlag::ChildrenAffectedByPropertyBasedBackwardPositionalRules); }
374     void setAffectsNextSiblingElementStyle() { setFlag(AffectsNextSiblingElementStyle); }
375     void setStyleIsAffectedByPreviousSibling() { setFlag(StyleIsAffectedByPreviousSibling); }
376     void setChildIndex(unsigned);
377 
378     WEBCORE_EXPORT AtomString computeInheritedLanguage() const;
379     Locale&amp; locale() const;
380 
381     virtual void accessKeyAction(bool /*sendToAnyEvent*/) { }
382 
383     virtual bool isURLAttribute(const Attribute&amp;) const { return false; }
384     virtual bool attributeContainsURL(const Attribute&amp; attribute) const { return isURLAttribute(attribute); }
385     virtual String completeURLsInAttributeValue(const URL&amp; base, const Attribute&amp;) const;
386     virtual bool isHTMLContentAttribute(const Attribute&amp;) const { return false; }
387 
388     WEBCORE_EXPORT URL getURLAttribute(const QualifiedName&amp;) const;
389     URL getNonEmptyURLAttribute(const QualifiedName&amp;) const;
390 
391     virtual const AtomString&amp; imageSourceURL() const;
392     virtual String target() const { return String(); }
393 
394     static AXTextStateChangeIntent defaultFocusTextStateChangeIntent() { return AXTextStateChangeIntent(AXTextStateChangeTypeSelectionMove, AXTextSelection { AXTextSelectionDirectionDiscontiguous, AXTextSelectionGranularityUnknown, true }); }
395     virtual void focus(bool restorePreviousSelection = true, FocusDirection = FocusDirectionNone);
396     virtual RefPtr&lt;Element&gt; focusAppearanceUpdateTarget();
397     virtual void updateFocusAppearance(SelectionRestorationMode, SelectionRevealMode = SelectionRevealMode::Reveal);
398     virtual void blur();
399 
400     WEBCORE_EXPORT String innerHTML() const;
401     WEBCORE_EXPORT String outerHTML() const;
402     WEBCORE_EXPORT ExceptionOr&lt;void&gt; setInnerHTML(const String&amp;);
403     WEBCORE_EXPORT ExceptionOr&lt;void&gt; setOuterHTML(const String&amp;);
404     WEBCORE_EXPORT String innerText();
405     WEBCORE_EXPORT String outerText();
406 
407     virtual String title() const;
408 
409     const AtomString&amp; pseudo() const;
410     WEBCORE_EXPORT void setPseudo(const AtomString&amp;);
411 
412     LayoutSize minimumSizeForResizing() const;
413     void setMinimumSizeForResizing(const LayoutSize&amp;);
414 
415     // Use Document::registerForDocumentActivationCallbacks() to subscribe to these
416     virtual void prepareForDocumentSuspension() { }
417     virtual void resumeFromDocumentSuspension() { }
418 
419     // Use Document::registerForMediaVolumeCallbacks() to subscribe to this
420     virtual void mediaVolumeDidChange() { }
421 
422     // Use Document::registerForPrivateBrowsingStateChangedCallbacks() to subscribe to this.
423     virtual void privateBrowsingStateDidChange(PAL::SessionID) { }
424 
425     virtual void willBecomeFullscreenElement();
426     virtual void ancestorWillEnterFullscreen() { }
427     virtual void didBecomeFullscreenElement() { }
428     virtual void willStopBeingFullscreenElement() { }
429 
430 #if ENABLE(VIDEO_TRACK)
431     virtual void captionPreferencesChanged() { }
432 #endif
433 
434     bool isFinishedParsingChildren() const { return isParsingChildrenFinished(); }
435     void finishParsingChildren() override;
436     void beginParsingChildren() final;
437 
438     WEBCORE_EXPORT PseudoElement* beforePseudoElement() const;
439     WEBCORE_EXPORT PseudoElement* afterPseudoElement() const;
440     bool childNeedsShadowWalker() const;
441     void didShadowTreeAwareChildrenChange();
442 
443     virtual bool matchesValidPseudoClass() const;
444     virtual bool matchesInvalidPseudoClass() const;
445     virtual bool matchesReadWritePseudoClass() const;
446     virtual bool matchesIndeterminatePseudoClass() const;
447     virtual bool matchesDefaultPseudoClass() const;
448     WEBCORE_EXPORT ExceptionOr&lt;bool&gt; matches(const String&amp; selectors);
449     WEBCORE_EXPORT ExceptionOr&lt;Element*&gt; closest(const String&amp; selectors);
450     virtual bool shouldAppearIndeterminate() const;
451 
452     WEBCORE_EXPORT DOMTokenList&amp; classList();
453 
454     DatasetDOMStringMap&amp; dataset();
455 
456 #if ENABLE(VIDEO)
457     virtual bool isMediaElement() const { return false; }
458 #endif
459 
460     virtual bool isFormControlElement() const { return false; }
461     virtual bool isSpinButtonElement() const { return false; }
462     virtual bool isTextFormControlElement() const { return false; }
463     virtual bool isTextField() const { return false; }
464     virtual bool isOptionalFormControl() const { return false; }
465     virtual bool isRequiredFormControl() const { return false; }
466     virtual bool isInRange() const { return false; }
467     virtual bool isOutOfRange() const { return false; }
468     virtual bool isUploadButton() const { return false; }
469     virtual bool isSliderContainerElement() const { return false; }
470 
471     bool canContainRangeEndPoint() const override;
472 
473     // Used for disabled form elements; if true, prevents mouse events from being dispatched
474     // to event listeners, and prevents DOMActivate events from being sent at all.
475     virtual bool isDisabledFormControl() const { return false; }
476 
477     virtual bool childShouldCreateRenderer(const Node&amp;) const;
478 
479     bool hasPendingResources() const;
480     void setHasPendingResources();
481     void clearHasPendingResources();
482     virtual void buildPendingResource() { };
483 
484     bool hasCSSAnimation() const;
485     void setHasCSSAnimation();
486     void clearHasCSSAnimation();
487 
488 #if ENABLE(FULLSCREEN_API)
489     WEBCORE_EXPORT bool containsFullScreenElement() const;
490     void setContainsFullScreenElement(bool);
491     void setContainsFullScreenElementOnAncestorsCrossingFrameBoundaries(bool);
492     WEBCORE_EXPORT virtual void webkitRequestFullscreen();
493 #endif
494 
495 #if ENABLE(POINTER_EVENTS)
496     ExceptionOr&lt;void&gt; setPointerCapture(int32_t);
497     ExceptionOr&lt;void&gt; releasePointerCapture(int32_t);
498     bool hasPointerCapture(int32_t);
499 #endif
500 
501 #if ENABLE(POINTER_LOCK)
502     WEBCORE_EXPORT void requestPointerLock();
503 #endif
504 
505     bool isSpellCheckingEnabled() const;
506 
507     bool hasID() const;
508     bool hasClass() const;
509     bool hasName() const;
510     const SpaceSplitString&amp; classNames() const;
511 
512     IntPoint savedLayerScrollPosition() const;
513     void setSavedLayerScrollPosition(const IntPoint&amp;);
514 
515     bool dispatchMouseEvent(const PlatformMouseEvent&amp;, const AtomString&amp; eventType, int clickCount = 0, Element* relatedTarget = nullptr);
516     bool dispatchWheelEvent(const PlatformWheelEvent&amp;);
517     bool dispatchKeyEvent(const PlatformKeyboardEvent&amp;);
518     void dispatchSimulatedClick(Event* underlyingEvent, SimulatedClickMouseEventOptions = SendNoEvents, SimulatedClickVisualOptions = ShowPressedLook);
519     void dispatchFocusInEvent(const AtomString&amp; eventType, RefPtr&lt;Element&gt;&amp;&amp; oldFocusedElement);
520     void dispatchFocusOutEvent(const AtomString&amp; eventType, RefPtr&lt;Element&gt;&amp;&amp; newFocusedElement);
521     virtual void dispatchFocusEvent(RefPtr&lt;Element&gt;&amp;&amp; oldFocusedElement, FocusDirection);
522     virtual void dispatchBlurEvent(RefPtr&lt;Element&gt;&amp;&amp; newFocusedElement);
523     void dispatchWebKitImageReadyEventForTesting();
524 
525     WEBCORE_EXPORT bool dispatchMouseForceWillBegin();
526 
527     virtual void willRecalcStyle(Style::Change);
528     virtual void didRecalcStyle(Style::Change);
529     virtual void willResetComputedStyle();
530     virtual void willAttachRenderers();
531     virtual void didAttachRenderers();
532     virtual void willDetachRenderers();
533     virtual void didDetachRenderers();
534     virtual Optional&lt;ElementStyle&gt; resolveCustomStyle(const RenderStyle&amp; parentStyle, const RenderStyle* shadowHostStyle);
535 
536     LayoutRect absoluteEventHandlerBounds(bool&amp; includesFixedPositionElements) override;
537 
538     const RenderStyle* existingComputedStyle() const;
539     WEBCORE_EXPORT const RenderStyle* renderOrDisplayContentsStyle() const;
540 
541     void setBeforePseudoElement(Ref&lt;PseudoElement&gt;&amp;&amp;);
542     void setAfterPseudoElement(Ref&lt;PseudoElement&gt;&amp;&amp;);
543     void clearBeforePseudoElement();
544     void clearAfterPseudoElement();
545     void resetComputedStyle();
546     void resetStyleRelations();
547     void clearHoverAndActiveStatusBeforeDetachingRenderer();
548 
549     WEBCORE_EXPORT URL absoluteLinkURL() const;
550 
551 #if ENABLE(TOUCH_EVENTS)
552     bool allowsDoubleTapGesture() const override;
553 #endif
554 
555     StyleResolver&amp; styleResolver();
556     ElementStyle resolveStyle(const RenderStyle* parentStyle);
557 
558     // Invalidates the style of a single element. Style is resolved lazily.
559     // Descendant elements are resolved as needed, for example if an inherited property changes.
560     // This should be called whenever an element changes in a manner that can affect its style.
561     void invalidateStyle();
562 
563     // As above but also call RenderElement::setStyle with StyleDifference::RecompositeLayer flag for
564     // the element even when the style doesn&#39;t change. This is mostly needed by the animation code.
565     WEBCORE_EXPORT void invalidateStyleAndLayerComposition();
566 
567     // Invalidate the element and all its descendants. This is used when there is some sort of change
568     // in the tree that may affect the style of any of the descendants and we don&#39;t know how to optimize
569     // the case to limit the scope. This is expensive and should be avoided.
570     void invalidateStyleForSubtree();
571 
572     // Invalidates renderers for the element and all its descendants causing them to be torn down
573     // and rebuild during style resolution. Style is also recomputed. This is used in code dealing with
574     // custom (not style based) renderers. This is expensive and should be avoided.
575     // Elements newly added to the tree are also in this state.
576     void invalidateStyleAndRenderersForSubtree();
577 
578     void invalidateStyleInternal();
579     void invalidateStyleForSubtreeInternal();
580 
581     bool hasDisplayContents() const;
582     void storeDisplayContentsStyle(std::unique_ptr&lt;RenderStyle&gt;);
583 
584     using ContainerNode::setAttributeEventListener;
585     void setAttributeEventListener(const AtomString&amp; eventType, const QualifiedName&amp; attributeName, const AtomString&amp; value);
586 
587 #if ENABLE(INTERSECTION_OBSERVER)
588     IntersectionObserverData&amp; ensureIntersectionObserverData();
589     IntersectionObserverData* intersectionObserverData();
590 #endif
591 
592 #if ENABLE(RESIZE_OBSERVER)
593     ResizeObserverData&amp; ensureResizeObserverData();
594     ResizeObserverData* resizeObserverData();
595 #endif
596 
597     Element* findAnchorElementForLink(String&amp; outAnchorName);
598 
599     ExceptionOr&lt;Ref&lt;WebAnimation&gt;&gt; animate(JSC::ExecState&amp;, JSC::Strong&lt;JSC::JSObject&gt;&amp;&amp;, Optional&lt;Variant&lt;double, KeyframeAnimationOptions&gt;&gt;&amp;&amp;);
600     Vector&lt;RefPtr&lt;WebAnimation&gt;&gt; getAnimations();
601 
602     ElementIdentifier createElementIdentifier();
603 
604 protected:
605     Element(const QualifiedName&amp;, Document&amp;, ConstructionType);
606 
607     InsertedIntoAncestorResult insertedIntoAncestor(InsertionType, ContainerNode&amp;) override;
608     void removedFromAncestor(RemovalType, ContainerNode&amp;) override;
609     void childrenChanged(const ChildChange&amp;) override;
610     void removeAllEventListeners() final;
611     virtual void parserDidSetAttributes();
612 
613     void clearTabIndexExplicitlyIfNeeded();
614     void setTabIndexExplicitly(int);
615 
616     // classAttributeChanged() exists to share code between
617     // parseAttribute (called via setAttribute()) and
618     // svgAttributeChanged (called when element.className.baseValue is set)
619     void classAttributeChanged(const AtomString&amp; newClassString);
620 
621     void addShadowRoot(Ref&lt;ShadowRoot&gt;&amp;&amp;);
622 
623     static ExceptionOr&lt;void&gt; mergeWithNextTextNode(Text&amp;);
624 
625 #if ENABLE(CSS_TYPED_OM)
626     StylePropertyMap* attributeStyleMap();
627     void setAttributeStyleMap(Ref&lt;StylePropertyMap&gt;&amp;&amp;);
628 #endif
629 
630 private:
631     Frame* documentFrameWithNonNullView() const;
632 
633     bool isTextNode() const;
634 
635     bool isUserActionElementInActiveChain() const;
636     bool isUserActionElementActive() const;
637     bool isUserActionElementFocused() const;
638     bool isUserActionElementHovered() const;
639 
640     virtual void didAddUserAgentShadowRoot(ShadowRoot&amp;) { }
641 
642     void didAddAttribute(const QualifiedName&amp;, const AtomString&amp;);
643     void willModifyAttribute(const QualifiedName&amp;, const AtomString&amp; oldValue, const AtomString&amp; newValue);
644     void didModifyAttribute(const QualifiedName&amp;, const AtomString&amp; oldValue, const AtomString&amp; newValue);
645     void didRemoveAttribute(const QualifiedName&amp;, const AtomString&amp; oldValue);
646 
647     void synchronizeAttribute(const QualifiedName&amp;) const;
648     void synchronizeAttribute(const AtomString&amp; localName) const;
649 
650     void updateName(const AtomString&amp; oldName, const AtomString&amp; newName);
651     void updateNameForTreeScope(TreeScope&amp;, const AtomString&amp; oldName, const AtomString&amp; newName);
652     void updateNameForDocument(HTMLDocument&amp;, const AtomString&amp; oldName, const AtomString&amp; newName);
653 
654     enum class NotifyObservers { No, Yes };
655     void updateId(const AtomString&amp; oldId, const AtomString&amp; newId, NotifyObservers = NotifyObservers::Yes);
656     void updateIdForTreeScope(TreeScope&amp;, const AtomString&amp; oldId, const AtomString&amp; newId, NotifyObservers = NotifyObservers::Yes);
657 
658     enum HTMLDocumentNamedItemMapsUpdatingCondition { AlwaysUpdateHTMLDocumentNamedItemMaps, UpdateHTMLDocumentNamedItemMapsOnlyIfDiffersFromNameAttribute };
659     void updateIdForDocument(HTMLDocument&amp;, const AtomString&amp; oldId, const AtomString&amp; newId, HTMLDocumentNamedItemMapsUpdatingCondition);
660     void updateLabel(TreeScope&amp;, const AtomString&amp; oldForAttributeValue, const AtomString&amp; newForAttributeValue);
661 
662     ExceptionOr&lt;Node*&gt; insertAdjacent(const String&amp; where, Ref&lt;Node&gt;&amp;&amp; newChild);
663 
664     void scrollByUnits(int units, ScrollGranularity);
665 
666     NodeType nodeType() const final;
667     bool childTypeAllowed(NodeType) const final;
668 
669     enum SynchronizationOfLazyAttribute { NotInSynchronizationOfLazyAttribute, InSynchronizationOfLazyAttribute };
670     void setAttributeInternal(unsigned index, const QualifiedName&amp;, const AtomString&amp; value, SynchronizationOfLazyAttribute);
671     void addAttributeInternal(const QualifiedName&amp;, const AtomString&amp; value, SynchronizationOfLazyAttribute);
672     void removeAttributeInternal(unsigned index, SynchronizationOfLazyAttribute);
673 
674     LayoutRect absoluteEventBounds(bool&amp; boundsIncludeAllDescendantElements, bool&amp; includesFixedPositionElements);
675     LayoutRect absoluteEventBoundsOfElementAndDescendants(bool&amp; includesFixedPositionElements);
676 
677 #if ENABLE(TREE_DEBUGGING)
678     void formatForDebugger(char* buffer, unsigned length) const override;
679 #endif
680 
681 #if ENABLE(INTERSECTION_OBSERVER)
682     void disconnectFromIntersectionObservers();
683 #endif
684 
685 #if ENABLE(RESIZE_OBSERVER)
686     void disconnectFromResizeObservers();
687 #endif
688 
689     // The cloneNode function is private so that non-virtual cloneElementWith/WithoutChildren are used instead.
690     Ref&lt;Node&gt; cloneNodeInternal(Document&amp;, CloningOperation) override;
691     virtual Ref&lt;Element&gt; cloneElementWithoutAttributesAndChildren(Document&amp;);
692 
693     void removeShadowRoot();
694 
695     const RenderStyle&amp; resolveComputedStyle();
696     const RenderStyle&amp; resolvePseudoElementStyle(PseudoId);
697 
698     unsigned rareDataChildIndex() const;
699 
700     SpellcheckAttributeState spellcheckAttributeState() const;
701 
702     void createUniqueElementData();
703 
704     ElementRareData* elementRareData() const;
705     ElementRareData&amp; ensureElementRareData();
706 
707     virtual int defaultTabIndex() const;
708 
709     void detachAllAttrNodesFromElement();
710     void detachAttrNodeFromElementWithValue(Attr*, const AtomString&amp; value);
711 
712     // Anyone thinking of using this should call document instead of ownerDocument.
713     void ownerDocument() const = delete;
714 
715     void attachAttributeNodeIfNeeded(Attr&amp;);
716 
717     QualifiedName m_tagName;
718     RefPtr&lt;ElementData&gt; m_elementData;
719 };
720 
721 inline bool Node::hasAttributes() const
722 {
723     return is&lt;Element&gt;(*this) &amp;&amp; downcast&lt;Element&gt;(*this).hasAttributes();
724 }
725 
726 inline NamedNodeMap* Node::attributes() const
727 {
728     return is&lt;Element&gt;(*this) ? &amp;downcast&lt;Element&gt;(*this).attributes() : nullptr;
729 }
730 
731 inline Element* Node::parentElement() const
732 {
733     ContainerNode* parent = parentNode();
734     return is&lt;Element&gt;(parent) ? downcast&lt;Element&gt;(parent) : nullptr;
735 }
736 
737 inline const Element* Element::rootElement() const
738 {
739     if (isConnected())
740         return document().documentElement();
741 
742     const Element* highest = this;
743     while (highest-&gt;parentElement())
744         highest = highest-&gt;parentElement();
745     return highest;
746 }
747 
748 inline bool Element::hasAttributeWithoutSynchronization(const QualifiedName&amp; name) const
749 {
750     ASSERT(fastAttributeLookupAllowed(name));
751     return elementData() &amp;&amp; findAttributeByName(name);
752 }
753 
754 inline const AtomString&amp; Element::attributeWithoutSynchronization(const QualifiedName&amp; name) const
755 {
756     if (elementData()) {
757         if (const Attribute* attribute = findAttributeByName(name))
758             return attribute-&gt;value();
759     }
760     return nullAtom();
761 }
762 
763 inline bool Element::hasAttributesWithoutUpdate() const
764 {
765     return elementData() &amp;&amp; !elementData()-&gt;isEmpty();
766 }
767 
768 inline const AtomString&amp; Element::idForStyleResolution() const
769 {
770     return hasID() ? elementData()-&gt;idForStyleResolution() : nullAtom();
771 }
772 
773 inline const AtomString&amp; Element::getIdAttribute() const
774 {
775     if (hasID())
776         return elementData()-&gt;findAttributeByName(HTMLNames::idAttr)-&gt;value();
777     return nullAtom();
778 }
779 
780 inline const AtomString&amp; Element::getNameAttribute() const
781 {
782     if (hasName())
783         return elementData()-&gt;findAttributeByName(HTMLNames::nameAttr)-&gt;value();
784     return nullAtom();
785 }
786 
787 inline void Element::setIdAttribute(const AtomString&amp; value)
788 {
789     setAttributeWithoutSynchronization(HTMLNames::idAttr, value);
790 }
791 
792 inline const SpaceSplitString&amp; Element::classNames() const
793 {
794     ASSERT(hasClass());
795     ASSERT(elementData());
796     return elementData()-&gt;classNames();
797 }
798 
799 inline unsigned Element::attributeCount() const
800 {
801     ASSERT(elementData());
802     return elementData()-&gt;length();
803 }
804 
805 inline const Attribute&amp; Element::attributeAt(unsigned index) const
806 {
807     ASSERT(elementData());
808     return elementData()-&gt;attributeAt(index);
809 }
810 
811 inline const Attribute* Element::findAttributeByName(const QualifiedName&amp; name) const
812 {
813     ASSERT(elementData());
814     return elementData()-&gt;findAttributeByName(name);
815 }
816 
817 inline bool Element::hasID() const
818 {
819     return elementData() &amp;&amp; elementData()-&gt;hasID();
820 }
821 
822 inline bool Element::hasClass() const
823 {
824     return elementData() &amp;&amp; elementData()-&gt;hasClass();
825 }
826 
827 inline bool Element::hasName() const
828 {
829     return elementData() &amp;&amp; elementData()-&gt;hasName();
830 }
831 
832 inline UniqueElementData&amp; Element::ensureUniqueElementData()
833 {
834     if (!elementData() || !elementData()-&gt;isUnique())
835         createUniqueElementData();
836     return static_cast&lt;UniqueElementData&amp;&gt;(*m_elementData);
837 }
838 
839 inline bool shouldIgnoreAttributeCase(const Element&amp; element)
840 {
841     return element.isHTMLElement() &amp;&amp; element.document().isHTMLDocument();
842 }
843 
844 inline void Element::setHasFocusWithin(bool flag)
845 {
846     if (hasFocusWithin() == flag)
847         return;
848     setFlag(flag, HasFocusWithin);
849     if (styleAffectedByFocusWithin())
850         invalidateStyleForSubtree();
851 }
852 
853 template&lt;typename... QualifiedNames&gt;
854 inline const AtomString&amp; Element::getAttribute(const QualifiedName&amp; name, const QualifiedNames&amp;... names) const
855 {
856     const AtomString&amp; value = getAttribute(name);
857     if (!value.isNull())
858         return value;
859     return getAttribute(names...);
860 }
861 
862 } // namespace WebCore
863 
864 SPECIALIZE_TYPE_TRAITS_BEGIN(WebCore::Element)
865     static bool isType(const WebCore::Node&amp; node) { return node.isElementNode(); }
866     static bool isType(const WebCore::EventTarget&amp; target) { return is&lt;WebCore::Node&gt;(target) &amp;&amp; isType(downcast&lt;WebCore::Node&gt;(target)); }
867 SPECIALIZE_TYPE_TRAITS_END()
    </pre>
  </body>
</html>