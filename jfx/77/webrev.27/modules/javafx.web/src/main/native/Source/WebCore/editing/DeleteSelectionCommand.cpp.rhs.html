<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/editing/DeleteSelectionCommand.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2005 Apple Inc.  All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;DeleteSelectionCommand.h&quot;
 28 
 29 #include &quot;Document.h&quot;
 30 #include &quot;DocumentMarkerController.h&quot;
 31 #include &quot;Editing.h&quot;
 32 #include &quot;Editor.h&quot;
 33 #include &quot;EditorClient.h&quot;
 34 #include &quot;ElementIterator.h&quot;
 35 #include &quot;Frame.h&quot;
 36 #include &quot;HTMLBRElement.h&quot;
 37 #include &quot;HTMLLinkElement.h&quot;
 38 #include &quot;HTMLNames.h&quot;
 39 #include &quot;HTMLStyleElement.h&quot;
 40 #include &quot;HTMLTableElement.h&quot;
 41 #include &quot;NodeTraversal.h&quot;
 42 #include &quot;RenderTableCell.h&quot;
 43 #include &quot;RenderText.h&quot;
 44 #include &quot;RenderedDocumentMarker.h&quot;
 45 #include &quot;Text.h&quot;
 46 #include &quot;VisibleUnits.h&quot;
 47 
 48 namespace WebCore {
 49 
 50 using namespace HTMLNames;
 51 
 52 static bool isTableRow(const Node* node)
 53 {
 54     return node &amp;&amp; node-&gt;hasTagName(trTag);
 55 }
 56 
 57 static bool isTableCellEmpty(Node* cell)
 58 {
 59     ASSERT(isTableCell(cell));
 60     return VisiblePosition(firstPositionInNode(cell)) == VisiblePosition(lastPositionInNode(cell));
 61 }
 62 
 63 static bool isTableRowEmpty(Node* row)
 64 {
 65     if (!isTableRow(row))
 66         return false;
 67 
 68     for (Node* child = row-&gt;firstChild(); child; child = child-&gt;nextSibling())
 69         if (isTableCell(child) &amp;&amp; !isTableCellEmpty(child))
 70             return false;
 71 
 72     return true;
 73 }
 74 
 75 DeleteSelectionCommand::DeleteSelectionCommand(Document&amp; document, bool smartDelete, bool mergeBlocksAfterDelete, bool replace, bool expandForSpecialElements, bool sanitizeMarkup, EditAction editingAction)
 76     : CompositeEditCommand(document, editingAction)
 77     , m_hasSelectionToDelete(false)
 78     , m_smartDelete(smartDelete)
 79     , m_mergeBlocksAfterDelete(mergeBlocksAfterDelete)
 80     , m_needPlaceholder(false)
 81     , m_replace(replace)
 82     , m_expandForSpecialElements(expandForSpecialElements)
 83     , m_pruneStartBlockIfNecessary(false)
 84     , m_startsAtEmptyLine(false)
 85     , m_sanitizeMarkup(sanitizeMarkup)
 86 {
 87 }
 88 
 89 DeleteSelectionCommand::DeleteSelectionCommand(const VisibleSelection&amp; selection, bool smartDelete, bool mergeBlocksAfterDelete, bool replace, bool expandForSpecialElements, bool sanitizeMarkup, EditAction editingAction)
 90     : CompositeEditCommand(selection.start().anchorNode()-&gt;document(), editingAction)
 91     , m_hasSelectionToDelete(true)
 92     , m_smartDelete(smartDelete)
 93     , m_mergeBlocksAfterDelete(mergeBlocksAfterDelete)
 94     , m_needPlaceholder(false)
 95     , m_replace(replace)
 96     , m_expandForSpecialElements(expandForSpecialElements)
 97     , m_pruneStartBlockIfNecessary(false)
 98     , m_startsAtEmptyLine(false)
 99     , m_sanitizeMarkup(sanitizeMarkup)
100     , m_selectionToDelete(selection)
101 {
102 }
103 
104 void DeleteSelectionCommand::initializeStartEnd(Position&amp; start, Position&amp; end)
105 {
106     HTMLElement* startSpecialContainer = nullptr;
107     HTMLElement* endSpecialContainer = nullptr;
108 
109     start = m_selectionToDelete.start();
110     end = m_selectionToDelete.end();
111 
112     // For HRs, we&#39;ll get a position at (HR,1) when hitting delete from the beginning of the previous line, or (HR,0) when forward deleting,
113     // but in these cases, we want to delete it, so manually expand the selection
114     if (start.deprecatedNode()-&gt;hasTagName(hrTag))
115         start = positionBeforeNode(start.deprecatedNode());
116     else if (end.deprecatedNode()-&gt;hasTagName(hrTag))
117         end = positionAfterNode(end.deprecatedNode());
118 
119     // FIXME: This is only used so that moveParagraphs can avoid the bugs in special element expansion.
120     if (!m_expandForSpecialElements)
121         return;
122 
123     while (1) {
124         startSpecialContainer = nullptr;
125         endSpecialContainer = nullptr;
126 
127         Position s = positionBeforeContainingSpecialElement(start, &amp;startSpecialContainer);
128         Position e = positionAfterContainingSpecialElement(end, &amp;endSpecialContainer);
129 
130         if (!startSpecialContainer &amp;&amp; !endSpecialContainer)
131             break;
132 
133         m_mergeBlocksAfterDelete = false;
134 
135         if (VisiblePosition(start) != m_selectionToDelete.visibleStart() || VisiblePosition(end) != m_selectionToDelete.visibleEnd())
136             break;
137 
138         // If we&#39;re going to expand to include the startSpecialContainer, it must be fully selected.
139         if (startSpecialContainer &amp;&amp; !endSpecialContainer &amp;&amp; comparePositions(positionInParentAfterNode(startSpecialContainer), end) &gt; -1)
140             break;
141 
142         // If we&#39;re going to expand to include the endSpecialContainer, it must be fully selected.
143         if (endSpecialContainer &amp;&amp; !startSpecialContainer &amp;&amp; comparePositions(start, positionInParentBeforeNode(endSpecialContainer)) &gt; -1)
144             break;
145 
146         if (startSpecialContainer &amp;&amp; startSpecialContainer-&gt;isDescendantOf(endSpecialContainer))
147             // Don&#39;t adjust the end yet, it is the end of a special element that contains the start
148             // special element (which may or may not be fully selected).
149             start = s;
150         else if (endSpecialContainer &amp;&amp; endSpecialContainer-&gt;isDescendantOf(startSpecialContainer))
151             // Don&#39;t adjust the start yet, it is the start of a special element that contains the end
152             // special element (which may or may not be fully selected).
153             end = e;
154         else {
155             start = s;
156             end = e;
157         }
158     }
159 }
160 
161 void DeleteSelectionCommand::setStartingSelectionOnSmartDelete(const Position&amp; start, const Position&amp; end)
162 {
163     VisiblePosition newBase;
164     VisiblePosition newExtent;
165     if (startingSelection().isBaseFirst()) {
166         newBase = start;
167         newExtent = end;
168     } else {
169         newBase = end;
170         newExtent = start;
171     }
172     setStartingSelection(VisibleSelection(newBase, newExtent, startingSelection().isDirectional()));
173 }
174 
<a name="1" id="anc1"></a><span class="line-added">175 bool DeleteSelectionCommand::shouldSmartDeleteParagraphSpacers()</span>
<span class="line-added">176 {</span>
<span class="line-added">177     return document().editingBehavior().shouldSmartInsertDeleteParagraphs();</span>
<span class="line-added">178 }</span>
<span class="line-added">179 </span>
<span class="line-added">180 void DeleteSelectionCommand::smartDeleteParagraphSpacers()</span>
<span class="line-added">181 {</span>
<span class="line-added">182     VisiblePosition visibleStart { m_upstreamStart };</span>
<span class="line-added">183     VisiblePosition visibleEnd { m_downstreamEnd };</span>
<span class="line-added">184     bool selectionEndsInParagraphSeperator = isEndOfParagraph(visibleEnd);</span>
<span class="line-added">185     bool selectionEndIsEndOfContent = endOfEditableContent(visibleEnd) == visibleEnd;</span>
<span class="line-added">186     bool startAndEndInSameUnsplittableElement = unsplittableElementForPosition(visibleStart.deepEquivalent()) == unsplittableElementForPosition(visibleEnd.deepEquivalent());</span>
<span class="line-added">187     visibleStart = visibleStart.previous(CannotCrossEditingBoundary);</span>
<span class="line-added">188     visibleEnd = visibleEnd.next(CannotCrossEditingBoundary);</span>
<span class="line-added">189     bool previousPositionIsBlankParagraph = isBlankParagraph(visibleStart);</span>
<span class="line-added">190     bool endPositonIsBlankParagraph = isBlankParagraph(visibleEnd);</span>
<span class="line-added">191     bool hasBlankParagraphAfterEndOrIsEndOfContent = !selectionEndIsEndOfContent &amp;&amp; (endPositonIsBlankParagraph || selectionEndsInParagraphSeperator);</span>
<span class="line-added">192     if (startAndEndInSameUnsplittableElement &amp;&amp; previousPositionIsBlankParagraph &amp;&amp; hasBlankParagraphAfterEndOrIsEndOfContent) {</span>
<span class="line-added">193         m_needPlaceholder = false;</span>
<span class="line-added">194         Position position;</span>
<span class="line-added">195         if (endPositonIsBlankParagraph)</span>
<span class="line-added">196             position = startOfNextParagraph(startOfNextParagraph(m_downstreamEnd)).deepEquivalent();</span>
<span class="line-added">197         else</span>
<span class="line-added">198             position = VisiblePosition(m_downstreamEnd).next().deepEquivalent();</span>
<span class="line-added">199         m_upstreamEnd = position.upstream();</span>
<span class="line-added">200         m_downstreamEnd = position.downstream();</span>
<span class="line-added">201         m_trailingWhitespace = m_downstreamEnd.trailingWhitespacePosition(VP_DEFAULT_AFFINITY);</span>
<span class="line-added">202         setStartingSelectionOnSmartDelete(m_upstreamStart, m_downstreamEnd);</span>
<span class="line-added">203     }</span>
<span class="line-added">204     if (startAndEndInSameUnsplittableElement &amp;&amp; selectionEndIsEndOfContent &amp;&amp; previousPositionIsBlankParagraph &amp;&amp; selectionEndsInParagraphSeperator) {</span>
<span class="line-added">205         m_needPlaceholder = false;</span>
<span class="line-added">206         VisiblePosition endOfParagraphBeforeStart = endOfParagraph(VisiblePosition { m_upstreamStart }.previous().previous());</span>
<span class="line-added">207         Position position = endOfParagraphBeforeStart.deepEquivalent();</span>
<span class="line-added">208         m_upstreamStart = position.upstream();</span>
<span class="line-added">209         m_downstreamStart = position.downstream();</span>
<span class="line-added">210         m_leadingWhitespace = m_upstreamStart.leadingWhitespacePosition(DOWNSTREAM);</span>
<span class="line-added">211         setStartingSelectionOnSmartDelete(m_upstreamStart, m_upstreamEnd);</span>
<span class="line-added">212     }</span>
<span class="line-added">213 }</span>
<span class="line-added">214 </span>
215 bool DeleteSelectionCommand::initializePositionData()
216 {
217     Position start, end;
218     initializeStartEnd(start, end);
219 
220     if (!isEditablePosition(start, ContentIsEditable))
221         start = firstEditablePositionAfterPositionInRoot(start, highestEditableRoot(start));
222     if (!isEditablePosition(end, ContentIsEditable))
223         end = lastEditablePositionBeforePositionInRoot(end, highestEditableRoot(start));
224 
225     if (start.isNull() || end.isNull())
226         return false;
227 
228     m_upstreamStart = start.upstream();
229     m_downstreamStart = start.downstream();
230     m_upstreamEnd = end.upstream();
231     m_downstreamEnd = end.downstream();
232 
233     m_startRoot = editableRootForPosition(start);
234     m_endRoot = editableRootForPosition(end);
235 
236     m_startTableRow = enclosingNodeOfType(start, &amp;isTableRow);
237     m_endTableRow = enclosingNodeOfType(end, &amp;isTableRow);
238 
239     // Don&#39;t move content out of a table cell.
240     // If the cell is non-editable, enclosingNodeOfType won&#39;t return it by default, so
241     // tell that function that we don&#39;t care if it returns non-editable nodes.
242     Node* startCell = enclosingNodeOfType(m_upstreamStart, &amp;isTableCell, CanCrossEditingBoundary);
243     Node* endCell = enclosingNodeOfType(m_downstreamEnd, &amp;isTableCell, CanCrossEditingBoundary);
244     // FIXME: This isn&#39;t right.  A borderless table with two rows and a single column would appear as two paragraphs.
245     if (endCell &amp;&amp; endCell != startCell)
246         m_mergeBlocksAfterDelete = false;
247 
248     // Usually the start and the end of the selection to delete are pulled together as a result of the deletion.
249     // Sometimes they aren&#39;t (like when no merge is requested), so we must choose one position to hold the caret
250     // and receive the placeholder after deletion.
251     VisiblePosition visibleEnd(m_downstreamEnd);
252     if (m_mergeBlocksAfterDelete &amp;&amp; !isEndOfParagraph(visibleEnd))
253         m_endingPosition = m_downstreamEnd;
254     else
255         m_endingPosition = m_downstreamStart;
256 
257     // We don&#39;t want to merge into a block if it will mean changing the quote level of content after deleting
258     // selections that contain a whole number paragraphs plus a line break, since it is unclear to most users
259     // that such a selection actually ends at the start of the next paragraph. This matches TextEdit behavior
260     // for indented paragraphs.
261     // Only apply this rule if the endingSelection is a range selection.  If it is a caret, then other operations have created
262     // the selection we&#39;re deleting (like the process of creating a selection to delete during a backspace), and the user isn&#39;t in the situation described above.
263     if (numEnclosingMailBlockquotes(start) != numEnclosingMailBlockquotes(end)
264             &amp;&amp; isStartOfParagraph(visibleEnd) &amp;&amp; isStartOfParagraph(VisiblePosition(start))
265             &amp;&amp; endingSelection().isRange()) {
266         m_mergeBlocksAfterDelete = false;
267         m_pruneStartBlockIfNecessary = true;
268     }
269 
270     // Handle leading and trailing whitespace, as well as smart delete adjustments to the selection
271     m_leadingWhitespace = m_upstreamStart.leadingWhitespacePosition(m_selectionToDelete.affinity());
272     m_trailingWhitespace = m_downstreamEnd.trailingWhitespacePosition(VP_DEFAULT_AFFINITY);
273 
274     if (m_smartDelete) {
275 
276         // skip smart delete if the selection to delete already starts or ends with whitespace
277         Position pos = VisiblePosition(m_upstreamStart, m_selectionToDelete.affinity()).deepEquivalent();
278         bool skipSmartDelete = pos.trailingWhitespacePosition(VP_DEFAULT_AFFINITY, true).isNotNull();
279         if (!skipSmartDelete)
280             skipSmartDelete = m_downstreamEnd.leadingWhitespacePosition(VP_DEFAULT_AFFINITY, true).isNotNull();
281 
282         // extend selection upstream if there is whitespace there
283         bool hasLeadingWhitespaceBeforeAdjustment = m_upstreamStart.leadingWhitespacePosition(m_selectionToDelete.affinity(), true).isNotNull();
284         if (!skipSmartDelete &amp;&amp; hasLeadingWhitespaceBeforeAdjustment) {
285             VisiblePosition visiblePos = VisiblePosition(m_upstreamStart, VP_DEFAULT_AFFINITY).previous();
286             pos = visiblePos.deepEquivalent();
287             // Expand out one character upstream for smart delete and recalculate
288             // positions based on this change.
289             m_upstreamStart = pos.upstream();
290             m_downstreamStart = pos.downstream();
291             m_leadingWhitespace = m_upstreamStart.leadingWhitespacePosition(visiblePos.affinity());
292 
293             setStartingSelectionOnSmartDelete(m_upstreamStart, m_upstreamEnd);
294         }
295 
296         // trailing whitespace is only considered for smart delete if there is no leading
297         // whitespace, as in the case where you double-click the first word of a paragraph.
298         if (!skipSmartDelete &amp;&amp; !hasLeadingWhitespaceBeforeAdjustment &amp;&amp; m_downstreamEnd.trailingWhitespacePosition(VP_DEFAULT_AFFINITY, true).isNotNull()) {
299             // Expand out one character downstream for smart delete and recalculate
300             // positions based on this change.
301             pos = VisiblePosition(m_downstreamEnd, VP_DEFAULT_AFFINITY).next().deepEquivalent();
302             m_upstreamEnd = pos.upstream();
303             m_downstreamEnd = pos.downstream();
304             m_trailingWhitespace = m_downstreamEnd.trailingWhitespacePosition(VP_DEFAULT_AFFINITY);
305 
306             setStartingSelectionOnSmartDelete(m_downstreamStart, m_downstreamEnd);
307         }
<a name="2" id="anc2"></a><span class="line-added">308 </span>
<span class="line-added">309         if (shouldSmartDeleteParagraphSpacers())</span>
<span class="line-added">310             smartDeleteParagraphSpacers();</span>
311     }
312 
313     // We must pass call parentAnchoredEquivalent on the positions since some editing positions
314     // that appear inside their nodes aren&#39;t really inside them.  [hr, 0] is one example.
315     // FIXME: parentAnchoredEquivalent should eventually be moved into enclosing element getters
316     // like the one below, since editing functions should obviously accept editing positions.
317     // FIXME: Passing false to enclosingNodeOfType tells it that it&#39;s OK to return a non-editable
318     // node.  This was done to match existing behavior, but it seems wrong.
319     m_startBlock = enclosingNodeOfType(m_downstreamStart.parentAnchoredEquivalent(), &amp;isBlock, CanCrossEditingBoundary);
320     m_endBlock = enclosingNodeOfType(m_upstreamEnd.parentAnchoredEquivalent(), &amp;isBlock, CanCrossEditingBoundary);
321 
322     return true;
323 }
324 
325 void DeleteSelectionCommand::saveTypingStyleState()
326 {
327     // A common case is deleting characters that are all from the same text node. In
328     // that case, the style at the start of the selection before deletion will be the
329     // same as the style at the start of the selection after deletion (since those
330     // two positions will be identical). Therefore there is no need to save the
331     // typing style at the start of the selection, nor is there a reason to
332     // compute the style at the start of the selection after deletion (see the
333     // early return in calculateTypingStyleAfterDelete).
334     // However, if typing style was previously set from another text node at the previous
335     // position (now deleted), we need to clear that style as well.
336     if (m_upstreamStart.deprecatedNode() == m_downstreamEnd.deprecatedNode() &amp;&amp; m_upstreamStart.deprecatedNode()-&gt;isTextNode()) {
337         frame().selection().clearTypingStyle();
338         return;
339     }
340 
341     // Figure out the typing style in effect before the delete is done.
342     m_typingStyle = EditingStyle::create(m_selectionToDelete.start(), EditingStyle::EditingPropertiesInEffect);
343     m_typingStyle-&gt;removeStyleAddedByNode(enclosingAnchorElement(m_selectionToDelete.start()));
344 
345     // If we&#39;re deleting into a Mail blockquote, save the style at end() instead of start()
346     // We&#39;ll use this later in computeTypingStyleAfterDelete if we end up outside of a Mail blockquote
347     if (enclosingNodeOfType(m_selectionToDelete.start(), isMailBlockquote))
348         m_deleteIntoBlockquoteStyle = EditingStyle::create(m_selectionToDelete.end());
349     else
350         m_deleteIntoBlockquoteStyle = nullptr;
351 }
352 
353 bool DeleteSelectionCommand::handleSpecialCaseBRDelete()
354 {
355     Node* nodeAfterUpstreamStart = m_upstreamStart.computeNodeAfterPosition();
356     Node* nodeAfterDownstreamStart = m_downstreamStart.computeNodeAfterPosition();
357     // Upstream end will appear before BR due to canonicalization
358     Node* nodeAfterUpstreamEnd = m_upstreamEnd.computeNodeAfterPosition();
359 
360     if (!nodeAfterUpstreamStart || !nodeAfterDownstreamStart)
361         return false;
362 
363     // Check for special-case where the selection contains only a BR on a line by itself after another BR.
364     bool upstreamStartIsBR = nodeAfterUpstreamStart-&gt;hasTagName(brTag);
365     bool downstreamStartIsBR = nodeAfterDownstreamStart-&gt;hasTagName(brTag);
366     // We should consider that the BR is on a line by itself also when we have &lt;br&gt;&lt;br&gt;. This test should be true only
367     // when the two elements are siblings and should be false in a case like &lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;br&gt;.
368     bool isBROnLineByItself = upstreamStartIsBR &amp;&amp; downstreamStartIsBR &amp;&amp; ((nodeAfterDownstreamStart == nodeAfterUpstreamEnd) || (nodeAfterUpstreamEnd &amp;&amp; nodeAfterUpstreamEnd-&gt;hasTagName(brTag) &amp;&amp; nodeAfterUpstreamStart-&gt;nextSibling() == nodeAfterUpstreamEnd));
369 
370     if (isBROnLineByItself) {
371         removeNode(*nodeAfterDownstreamStart);
372         return true;
373     }
374 
375     // FIXME: This code doesn&#39;t belong in here.
376     // We detect the case where the start is an empty line consisting of BR not wrapped in a block element.
377     if (upstreamStartIsBR &amp;&amp; downstreamStartIsBR
378         &amp;&amp; !(isStartOfBlock(positionBeforeNode(nodeAfterUpstreamStart)) &amp;&amp; isEndOfBlock(positionAfterNode(nodeAfterDownstreamStart)))
379         &amp;&amp; (!nodeAfterUpstreamEnd || nodeAfterUpstreamEnd-&gt;hasTagName(brTag) || nodeAfterUpstreamEnd-&gt;previousSibling() != nodeAfterUpstreamStart)) {
380         m_startsAtEmptyLine = true;
381         m_endingPosition = m_downstreamEnd;
382     }
383 
384     return false;
385 }
386 
387 static Position firstEditablePositionInNode(Node* node)
388 {
389     ASSERT(node);
390     Node* next = node;
391     while (next &amp;&amp; !next-&gt;hasEditableStyle())
392         next = NodeTraversal::next(*next, node);
393     return next ? firstPositionInOrBeforeNode(next) : Position();
394 }
395 
396 void DeleteSelectionCommand::insertBlockPlaceholderForTableCellIfNeeded(Element&amp; element)
397 {
398     // Make sure empty cell has some height.
399     auto* renderer = element.renderer();
400     if (!is&lt;RenderTableCell&gt;(renderer))
401         return;
402     if (downcast&lt;RenderTableCell&gt;(*renderer).contentHeight() &gt; 0)
403         return;
404     insertBlockPlaceholder(firstEditablePositionInNode(&amp;element));
405 }
406 
407 void DeleteSelectionCommand::removeNodeUpdatingStates(Node&amp; node, ShouldAssumeContentIsAlwaysEditable shouldAssumeContentIsAlwaysEditable)
408 {
409     if (&amp;node == m_startBlock &amp;&amp; !isEndOfBlock(VisiblePosition(firstPositionInNode(m_startBlock.get())).previous()))
410         m_needPlaceholder = true;
411     else if (&amp;node == m_endBlock &amp;&amp; !isStartOfBlock(VisiblePosition(lastPositionInNode(m_startBlock.get())).next()))
412         m_needPlaceholder = true;
413 
414     // FIXME: Update the endpoints of the range being deleted.
415     updatePositionForNodeRemoval(m_endingPosition, node);
416     updatePositionForNodeRemoval(m_leadingWhitespace, node);
417     updatePositionForNodeRemoval(m_trailingWhitespace, node);
418 
419     CompositeEditCommand::removeNode(node, shouldAssumeContentIsAlwaysEditable);
420 }
421 
422 static inline bool shouldRemoveContentOnly(const Node&amp; node)
423 {
424     return isTableStructureNode(&amp;node) || node.isRootEditableElement();
425 }
426 
427 void DeleteSelectionCommand::removeNode(Node&amp; node, ShouldAssumeContentIsAlwaysEditable shouldAssumeContentIsAlwaysEditable)
428 {
429     Ref&lt;Node&gt; protectedNode = node;
430     if (m_startRoot != m_endRoot &amp;&amp; !(node.isDescendantOf(m_startRoot.get()) &amp;&amp; node.isDescendantOf(m_endRoot.get()))) {
431         // If a node is not in both the start and end editable roots, remove it only if its inside an editable region.
432         if (!node.parentNode()-&gt;hasEditableStyle()) {
433             // Don&#39;t remove non-editable atomic nodes.
434             if (!node.firstChild())
435                 return;
436             // Search this non-editable region for editable regions to empty.
437             RefPtr&lt;Node&gt; child = node.firstChild();
438             while (child) {
439                 RefPtr&lt;Node&gt; nextChild = child-&gt;nextSibling();
440                 removeNode(*child, shouldAssumeContentIsAlwaysEditable);
441                 // Bail if nextChild is no longer node&#39;s child.
442                 if (nextChild &amp;&amp; nextChild-&gt;parentNode() != &amp;node)
443                     return;
444                 child = nextChild;
445             }
446 
447             // Don&#39;t remove editable regions that are inside non-editable ones, just clear them.
448             return;
449         }
450     }
451 
452     if (shouldRemoveContentOnly(node)) {
453         // Do not remove an element of table structure; remove its contents.
454         // Likewise for the root editable element.
455         auto* child = NodeTraversal::next(node, &amp;node);
456         while (child) {
457             if (shouldRemoveContentOnly(*child)) {
458                 child = NodeTraversal::next(*child, &amp;node);
459                 continue;
460             }
461             auto* remove = child;
462             child = NodeTraversal::nextSkippingChildren(*child, &amp;node);
463             removeNodeUpdatingStates(*remove, shouldAssumeContentIsAlwaysEditable);
464         }
465 
466         ASSERT(is&lt;Element&gt;(node));
467         auto&amp; element = downcast&lt;Element&gt;(node);
468         document().updateLayoutIgnorePendingStylesheets();
469         // Check if we need to insert a placeholder for descendant table cells.
470         auto* descendant = ElementTraversal::next(element, &amp;element);
471         while (descendant) {
472             auto* placeholderCandidate = descendant;
473             descendant = ElementTraversal::next(*descendant, &amp;element);
474             insertBlockPlaceholderForTableCellIfNeeded(*placeholderCandidate);
475         }
476         insertBlockPlaceholderForTableCellIfNeeded(element);
477         return;
478     }
479     removeNodeUpdatingStates(node, shouldAssumeContentIsAlwaysEditable);
480 }
481 
482 static void updatePositionForTextRemoval(Node* node, int offset, int count, Position&amp; position)
483 {
484     if (position.anchorType() != Position::PositionIsOffsetInAnchor || position.containerNode() != node)
485         return;
486 
487     if (position.offsetInContainerNode() &gt; offset + count)
488         position.moveToOffset(position.offsetInContainerNode() - count);
489     else if (position.offsetInContainerNode() &gt; offset)
490         position.moveToOffset(offset);
491 }
492 
493 void DeleteSelectionCommand::deleteTextFromNode(Text&amp; node, unsigned offset, unsigned count)
494 {
495     // FIXME: Update the endpoints of the range being deleted.
496     updatePositionForTextRemoval(&amp;node, offset, count, m_endingPosition);
497     updatePositionForTextRemoval(&amp;node, offset, count, m_leadingWhitespace);
498     updatePositionForTextRemoval(&amp;node, offset, count, m_trailingWhitespace);
499     updatePositionForTextRemoval(&amp;node, offset, count, m_downstreamEnd);
500 
501     CompositeEditCommand::deleteTextFromNode(node, offset, count);
502 }
503 
504 void DeleteSelectionCommand::makeStylingElementsDirectChildrenOfEditableRootToPreventStyleLoss()
505 {
506     RefPtr&lt;Range&gt; range = m_selectionToDelete.toNormalizedRange();
507     RefPtr&lt;Node&gt; node = range ? range-&gt;firstNode() : nullptr;
508     while (node &amp;&amp; node != range-&gt;pastLastNode()) {
509         RefPtr&lt;Node&gt; nextNode = NodeTraversal::next(*node);
510         if ((is&lt;HTMLStyleElement&gt;(*node) &amp;&amp; !downcast&lt;HTMLStyleElement&gt;(*node).hasAttributeWithoutSynchronization(scopedAttr)) || is&lt;HTMLLinkElement&gt;(*node)) {
511             nextNode = NodeTraversal::nextSkippingChildren(*node);
512             RefPtr&lt;ContainerNode&gt; rootEditableElement = node-&gt;rootEditableElement();
513             if (rootEditableElement) {
514                 removeNode(*node);
515                 appendNode(*node, *rootEditableElement);
516             }
517         }
518         node = nextNode;
519     }
520 }
521 
522 void DeleteSelectionCommand::handleGeneralDelete()
523 {
524     if (m_upstreamStart.isNull())
525         return;
526 
527     int startOffset = m_upstreamStart.deprecatedEditingOffset();
528     Node* startNode = m_upstreamStart.deprecatedNode();
529 
530     makeStylingElementsDirectChildrenOfEditableRootToPreventStyleLoss();
531 
532     // Never remove the start block unless it&#39;s a table, in which case we won&#39;t merge content in.
533     if (startNode == m_startBlock &amp;&amp; !startOffset &amp;&amp; canHaveChildrenForEditing(*startNode) &amp;&amp; !is&lt;HTMLTableElement&gt;(*startNode)) {
534         startOffset = 0;
535         startNode = NodeTraversal::next(*startNode);
536         if (!startNode)
537             return;
538     }
539 
540     int startNodeCaretMaxOffset = caretMaxOffset(*startNode);
541     if (startOffset &gt;= startNodeCaretMaxOffset &amp;&amp; is&lt;Text&gt;(*startNode)) {
542         Text&amp; text = downcast&lt;Text&gt;(*startNode);
543         if (text.length() &gt; static_cast&lt;unsigned&gt;(startNodeCaretMaxOffset))
544             deleteTextFromNode(text, startNodeCaretMaxOffset, text.length() - startNodeCaretMaxOffset);
545     }
546 
547     if (startOffset &gt;= lastOffsetForEditing(*startNode)) {
548         startNode = NodeTraversal::nextSkippingChildren(*startNode);
549         startOffset = 0;
550     }
551 
552     // Done adjusting the start.  See if we&#39;re all done.
553     if (!startNode)
554         return;
555 
556     if (startNode == m_downstreamEnd.deprecatedNode()) {
557         if (m_downstreamEnd.deprecatedEditingOffset() - startOffset &gt; 0) {
558             if (is&lt;Text&gt;(*startNode)) {
559                 // in a text node that needs to be trimmed
560                 Text&amp; text = downcast&lt;Text&gt;(*startNode);
561                 deleteTextFromNode(text, startOffset, m_downstreamEnd.deprecatedEditingOffset() - startOffset);
562             } else {
563                 removeChildrenInRange(*startNode, startOffset, m_downstreamEnd.deprecatedEditingOffset());
564                 m_endingPosition = m_upstreamStart;
565             }
566         }
567 
568         // The selection to delete is all in one node.
569         if (!startNode-&gt;renderer() || (!startOffset &amp;&amp; m_downstreamEnd.atLastEditingPositionForNode()))
570             removeNode(*startNode);
571     }
572     else {
573         bool startNodeWasDescendantOfEndNode = m_upstreamStart.deprecatedNode()-&gt;isDescendantOf(m_downstreamEnd.deprecatedNode());
574         // The selection to delete spans more than one node.
575         RefPtr&lt;Node&gt; node(startNode);
576 
577         if (startOffset &gt; 0) {
578             if (is&lt;Text&gt;(*startNode)) {
579                 // in a text node that needs to be trimmed
580                 Text&amp; text = downcast&lt;Text&gt;(*node);
581                 deleteTextFromNode(text, startOffset, text.length() - startOffset);
582                 node = NodeTraversal::next(*node);
583             } else {
584                 node = startNode-&gt;traverseToChildAt(startOffset);
585             }
586         } else if (startNode == m_upstreamEnd.deprecatedNode() &amp;&amp; is&lt;Text&gt;(*startNode)) {
587             Text&amp; text = downcast&lt;Text&gt;(*m_upstreamEnd.deprecatedNode());
588             deleteTextFromNode(text, 0, m_upstreamEnd.deprecatedEditingOffset());
589         }
590 
591         // handle deleting all nodes that are completely selected
592         while (node &amp;&amp; node != m_downstreamEnd.deprecatedNode()) {
593             if (comparePositions(firstPositionInOrBeforeNode(node.get()), m_downstreamEnd) &gt;= 0) {
594                 // NodeTraversal::nextSkippingChildren just blew past the end position, so stop deleting
595                 node = nullptr;
596             } else if (!m_downstreamEnd.deprecatedNode()-&gt;isDescendantOf(*node)) {
597                 RefPtr&lt;Node&gt; nextNode = NodeTraversal::nextSkippingChildren(*node);
598                 // if we just removed a node from the end container, update end position so the
599                 // check above will work
600                 updatePositionForNodeRemoval(m_downstreamEnd, *node);
601                 removeNode(*node);
602                 node = nextNode.get();
603             } else {
604                 Node* n = node-&gt;lastDescendant();
605                 if (m_downstreamEnd.deprecatedNode() == n &amp;&amp; m_downstreamEnd.deprecatedEditingOffset() &gt;= caretMaxOffset(*n)) {
606                     removeNode(*node);
607                     node = nullptr;
608                 } else
609                     node = NodeTraversal::next(*node);
610             }
611         }
612 
<a name="3" id="anc3"></a><span class="line-modified">613         if (!m_downstreamEnd.isNull() &amp;&amp; !m_downstreamEnd.isOrphan() &amp;&amp; m_downstreamEnd.deprecatedNode() != startNode</span>
<span class="line-added">614             &amp;&amp; !m_upstreamStart.deprecatedNode()-&gt;isDescendantOf(m_downstreamEnd.deprecatedNode())</span>
<span class="line-added">615             &amp;&amp; m_downstreamEnd.deprecatedEditingOffset() &gt;= caretMinOffset(*m_downstreamEnd.deprecatedNode())) {</span>
616             if (m_downstreamEnd.atLastEditingPositionForNode() &amp;&amp; !canHaveChildrenForEditing(*m_downstreamEnd.deprecatedNode())) {
617                 // The node itself is fully selected, not just its contents.  Delete it.
618                 removeNode(*m_downstreamEnd.deprecatedNode());
619             } else {
620                 if (is&lt;Text&gt;(*m_downstreamEnd.deprecatedNode())) {
621                     // in a text node that needs to be trimmed
622                     Text&amp; text = downcast&lt;Text&gt;(*m_downstreamEnd.deprecatedNode());
623                     if (m_downstreamEnd.deprecatedEditingOffset() &gt; 0) {
624                         deleteTextFromNode(text, 0, m_downstreamEnd.deprecatedEditingOffset());
625                     }
626                 // Remove children of m_downstreamEnd.deprecatedNode() that come after m_upstreamStart.
627                 // Don&#39;t try to remove children if m_upstreamStart was inside m_downstreamEnd.deprecatedNode()
628                 // and m_upstreamStart has been removed from the document, because then we don&#39;t
629                 // know how many children to remove.
630                 // FIXME: Make m_upstreamStart a position we update as we remove content, then we can
631                 // always know which children to remove.
632                 } else if (!(startNodeWasDescendantOfEndNode &amp;&amp; !m_upstreamStart.anchorNode()-&gt;isConnected())) {
633                     unsigned offset = 0;
634                     if (m_upstreamStart.deprecatedNode()-&gt;isDescendantOf(m_downstreamEnd.deprecatedNode())) {
635                         Node* n = m_upstreamStart.deprecatedNode();
636                         while (n &amp;&amp; n-&gt;parentNode() != m_downstreamEnd.deprecatedNode())
637                             n = n-&gt;parentNode();
638                         if (n)
639                             offset = n-&gt;computeNodeIndex() + 1;
640                     }
641                     removeChildrenInRange(*m_downstreamEnd.deprecatedNode(), offset, m_downstreamEnd.deprecatedEditingOffset());
642                     m_downstreamEnd = createLegacyEditingPosition(m_downstreamEnd.deprecatedNode(), offset);
643                 }
644             }
645         }
646     }
647 }
648 
649 void DeleteSelectionCommand::fixupWhitespace()
650 {
651     document().updateLayoutIgnorePendingStylesheets();
652     // FIXME: isRenderedCharacter should be removed, and we should use VisiblePosition::characterAfter and VisiblePosition::characterBefore
653     if (m_leadingWhitespace.isNotNull() &amp;&amp; !m_leadingWhitespace.isRenderedCharacter() &amp;&amp; is&lt;Text&gt;(*m_leadingWhitespace.deprecatedNode())) {
654         Text&amp; textNode = downcast&lt;Text&gt;(*m_leadingWhitespace.deprecatedNode());
655         ASSERT(!textNode.renderer() || textNode.renderer()-&gt;style().collapseWhiteSpace());
656         replaceTextInNodePreservingMarkers(textNode, m_leadingWhitespace.deprecatedEditingOffset(), 1, nonBreakingSpaceString());
657     }
658     if (m_trailingWhitespace.isNotNull() &amp;&amp; !m_trailingWhitespace.isRenderedCharacter() &amp;&amp; is&lt;Text&gt;(*m_trailingWhitespace.deprecatedNode())) {
659         Text&amp; textNode = downcast&lt;Text&gt;(*m_trailingWhitespace.deprecatedNode());
660         ASSERT(!textNode.renderer() || textNode.renderer()-&gt;style().collapseWhiteSpace());
661         replaceTextInNodePreservingMarkers(textNode, m_trailingWhitespace.deprecatedEditingOffset(), 1, nonBreakingSpaceString());
662     }
663 }
664 
665 // If a selection starts in one block and ends in another, we have to merge to bring content before the
666 // start together with content after the end.
667 void DeleteSelectionCommand::mergeParagraphs()
668 {
669     if (!m_mergeBlocksAfterDelete) {
670         if (m_pruneStartBlockIfNecessary) {
671             // We aren&#39;t going to merge into the start block, so remove it if it&#39;s empty.
672             prune(m_startBlock.get());
673             // Removing the start block during a deletion is usually an indication that we need
674             // a placeholder, but not in this case.
675             m_needPlaceholder = false;
676         }
677         return;
678     }
679 
680     // It shouldn&#39;t have been asked to both try and merge content into the start block and prune it.
681     ASSERT(!m_pruneStartBlockIfNecessary);
682 
683     // FIXME: Deletion should adjust selection endpoints as it removes nodes so that we never get into this state (4099839).
<a name="4" id="anc4"></a><span class="line-modified">684     if (m_downstreamEnd.isNull() || m_upstreamStart.isNull() || !m_downstreamEnd.anchorNode()-&gt;isConnected() || !m_upstreamStart.anchorNode()-&gt;isConnected())</span>
685          return;
686 
687     // FIXME: The deletion algorithm shouldn&#39;t let this happen.
688     if (comparePositions(m_upstreamStart, m_downstreamEnd) &gt; 0)
689         return;
690 
691     // There&#39;s nothing to merge.
692     if (m_upstreamStart == m_downstreamEnd)
693         return;
694 
695     VisiblePosition startOfParagraphToMove(m_downstreamEnd);
696     VisiblePosition mergeDestination(m_upstreamStart);
697 
698     // m_downstreamEnd&#39;s block has been emptied out by deletion.  There is no content inside of it to
699     // move, so just remove it.
700     Element* endBlock = enclosingBlock(m_downstreamEnd.deprecatedNode());
701     if (!endBlock)
702         return;
703 
704     if (!endBlock-&gt;contains(startOfParagraphToMove.deepEquivalent().deprecatedNode()) || !startOfParagraphToMove.deepEquivalent().deprecatedNode()) {
705         removeNode(*endBlock);
706         return;
707     }
708 
709     // We need to merge into m_upstreamStart&#39;s block, but it&#39;s been emptied out and collapsed by deletion.
710     if (!mergeDestination.deepEquivalent().deprecatedNode() || !mergeDestination.deepEquivalent().deprecatedNode()-&gt;isDescendantOf(enclosingBlock(m_upstreamStart.containerNode())) || m_startsAtEmptyLine) {
711         insertNodeAt(HTMLBRElement::create(document()), m_upstreamStart);
712         mergeDestination = VisiblePosition(m_upstreamStart);
713     }
714 
715     if (mergeDestination == startOfParagraphToMove)
716         return;
717 
718     VisiblePosition endOfParagraphToMove = endOfParagraph(startOfParagraphToMove, CanSkipOverEditingBoundary);
719 
720     if (mergeDestination == endOfParagraphToMove)
721         return;
722 
723     // The rule for merging into an empty block is: only do so if its farther to the right.
724     // FIXME: Consider RTL.
725     if (!m_startsAtEmptyLine &amp;&amp; isStartOfParagraph(mergeDestination) &amp;&amp; startOfParagraphToMove.absoluteCaretBounds().x() &gt; mergeDestination.absoluteCaretBounds().x()) {
726         if (mergeDestination.deepEquivalent().downstream().deprecatedNode()-&gt;hasTagName(brTag)) {
727             removeNodeAndPruneAncestors(*mergeDestination.deepEquivalent().downstream().deprecatedNode());
728             m_endingPosition = startOfParagraphToMove.deepEquivalent();
729             return;
730         }
731     }
732 
733     // Block images, tables and horizontal rules cannot be made inline with content at mergeDestination.  If there is
734     // any (!isStartOfParagraph(mergeDestination)), don&#39;t merge, just move the caret to just before the selection we deleted.
735     // See https://bugs.webkit.org/show_bug.cgi?id=25439
736     if (isRenderedAsNonInlineTableImageOrHR(startOfParagraphToMove.deepEquivalent().deprecatedNode()) &amp;&amp; !isStartOfParagraph(mergeDestination)) {
737         m_endingPosition = m_upstreamStart;
738         return;
739     }
740 
741     auto range = Range::create(document(), startOfParagraphToMove.deepEquivalent().parentAnchoredEquivalent(), endOfParagraphToMove.deepEquivalent().parentAnchoredEquivalent());
742     auto rangeToBeReplaced = Range::create(document(), mergeDestination.deepEquivalent().parentAnchoredEquivalent(), mergeDestination.deepEquivalent().parentAnchoredEquivalent());
743     if (!frame().editor().client()-&gt;shouldMoveRangeAfterDelete(range.ptr(), rangeToBeReplaced.ptr()))
744         return;
745 
746     // moveParagraphs will insert placeholders if it removes blocks that would require their use, don&#39;t let block
747     // removals that it does cause the insertion of *another* placeholder.
748     bool needPlaceholder = m_needPlaceholder;
749     bool paragraphToMergeIsEmpty = (startOfParagraphToMove == endOfParagraphToMove);
750     moveParagraph(startOfParagraphToMove, endOfParagraphToMove, mergeDestination, false, !paragraphToMergeIsEmpty);
751     m_needPlaceholder = needPlaceholder;
752     // The endingPosition was likely clobbered by the move, so recompute it (moveParagraph selects the moved paragraph).
753     m_endingPosition = endingSelection().start();
754 }
755 
756 void DeleteSelectionCommand::removePreviouslySelectedEmptyTableRows()
757 {
758     if (m_endTableRow &amp;&amp; m_endTableRow-&gt;isConnected() &amp;&amp; m_endTableRow != m_startTableRow) {
759         Node* row = m_endTableRow-&gt;previousSibling();
760         while (row &amp;&amp; row != m_startTableRow) {
761             RefPtr&lt;Node&gt; previousRow = row-&gt;previousSibling();
762             if (isTableRowEmpty(row))
763                 // Use a raw removeNode, instead of DeleteSelectionCommand&#39;s, because
764                 // that won&#39;t remove rows, it only empties them in preparation for this function.
765                 CompositeEditCommand::removeNode(*row);
766             row = previousRow.get();
767         }
768     }
769 
770     // Remove empty rows after the start row.
771     if (m_startTableRow &amp;&amp; m_startTableRow-&gt;isConnected() &amp;&amp; m_startTableRow != m_endTableRow) {
772         Node* row = m_startTableRow-&gt;nextSibling();
773         while (row &amp;&amp; row != m_endTableRow) {
774             RefPtr&lt;Node&gt; nextRow = row-&gt;nextSibling();
775             if (isTableRowEmpty(row))
776                 CompositeEditCommand::removeNode(*row);
777             row = nextRow.get();
778         }
779     }
780 
781     if (m_endTableRow &amp;&amp; m_endTableRow-&gt;isConnected() &amp;&amp; m_endTableRow != m_startTableRow) {
782         if (isTableRowEmpty(m_endTableRow.get())) {
783             // Don&#39;t remove m_endTableRow if it&#39;s where we&#39;re putting the ending selection.
784             if (!m_endingPosition.deprecatedNode()-&gt;isDescendantOf(*m_endTableRow)) {
785                 // FIXME: We probably shouldn&#39;t remove m_endTableRow unless it&#39;s fully selected, even if it is empty.
786                 // We&#39;ll need to start adjusting the selection endpoints during deletion to know whether or not m_endTableRow
787                 // was fully selected here.
788                 CompositeEditCommand::removeNode(*m_endTableRow);
789             }
790         }
791     }
792 }
793 
794 void DeleteSelectionCommand::calculateTypingStyleAfterDelete()
795 {
796     if (!m_typingStyle)
797         return;
798 
799     // Compute the difference between the style before the delete and the style now
800     // after the delete has been done. Set this style on the frame, so other editing
801     // commands being composed with this one will work, and also cache it on the command,
802     // so the Frame::appliedEditing can set it after the whole composite command
803     // has completed.
804 
805     // If we deleted into a blockquote, but are now no longer in a blockquote, use the alternate typing style
806     if (m_deleteIntoBlockquoteStyle &amp;&amp; !enclosingNodeOfType(m_endingPosition, isMailBlockquote, CanCrossEditingBoundary))
807         m_typingStyle = m_deleteIntoBlockquoteStyle;
808     m_deleteIntoBlockquoteStyle = nullptr;
809 
810     m_typingStyle-&gt;prepareToApplyAt(m_endingPosition);
811     if (m_typingStyle-&gt;isEmpty())
812         m_typingStyle = nullptr;
813     // This is where we&#39;ve deleted all traces of a style but not a whole paragraph (that&#39;s handled above).
814     // In this case if we start typing, the new characters should have the same style as the just deleted ones,
815     // but, if we change the selection, come back and start typing that style should be lost.  Also see
816     // preserveTypingStyle() below.
817     frame().selection().setTypingStyle(m_typingStyle.copyRef());
818 }
819 
820 void DeleteSelectionCommand::clearTransientState()
821 {
822     m_selectionToDelete = VisibleSelection();
823     m_upstreamStart.clear();
824     m_downstreamStart.clear();
825     m_upstreamEnd.clear();
826     m_downstreamEnd.clear();
827     m_endingPosition.clear();
828     m_leadingWhitespace.clear();
829     m_trailingWhitespace.clear();
830 }
831 
832 String DeleteSelectionCommand::originalStringForAutocorrectionAtBeginningOfSelection()
833 {
834     if (!m_selectionToDelete.isRange())
835         return String();
836 
837     VisiblePosition startOfSelection = m_selectionToDelete.start();
838     if (!isStartOfWord(startOfSelection))
839         return String();
840 
841     VisiblePosition nextPosition = startOfSelection.next();
842     if (nextPosition.isNull())
843         return String();
844 
845     auto rangeOfFirstCharacter = Range::create(document(), startOfSelection.deepEquivalent(), nextPosition.deepEquivalent());
846     for (auto* marker : document().markers().markersInRange(rangeOfFirstCharacter, DocumentMarker::Autocorrected)) {
847         int startOffset = marker-&gt;startOffset();
848         if (startOffset == startOfSelection.deepEquivalent().offsetInContainerNode())
849             return marker-&gt;description();
850     }
851     return String();
852 }
853 
854 // This method removes div elements with no attributes that have only one child or no children at all.
855 void DeleteSelectionCommand::removeRedundantBlocks()
856 {
857     Node* node = m_endingPosition.containerNode();
858     Node* rootNode = node-&gt;rootEditableElement();
859 
860     while (node != rootNode) {
861         if (isRemovableBlock(node)) {
862             if (node == m_endingPosition.anchorNode())
863                 updatePositionForNodeRemovalPreservingChildren(m_endingPosition, *node);
864 
865             CompositeEditCommand::removeNodePreservingChildren(*node);
866             node = m_endingPosition.anchorNode();
867         } else
868             node = node-&gt;parentNode();
869     }
870 }
871 
872 void DeleteSelectionCommand::doApply()
873 {
874     // If selection has not been set to a custom selection when the command was created,
875     // use the current ending selection.
876     if (!m_hasSelectionToDelete)
877         m_selectionToDelete = endingSelection();
878 
879     if (!m_selectionToDelete.isNonOrphanedRange())
880         return;
881 
882     String originalString = originalStringForAutocorrectionAtBeginningOfSelection();
883 
884     // If the deletion is occurring in a text field, and we&#39;re not deleting to replace the selection, then let the frame call across the bridge to notify the form delegate.
885     if (!m_replace) {
886         Element* textControl = enclosingTextFormControl(m_selectionToDelete.start());
887         if (textControl &amp;&amp; textControl-&gt;focused())
888             frame().editor().textWillBeDeletedInTextField(textControl);
889     }
890 
891     // save this to later make the selection with
892     EAffinity affinity = m_selectionToDelete.affinity();
893 
894     Position downstreamEnd = m_selectionToDelete.end().downstream();
895     m_needPlaceholder = isStartOfParagraph(m_selectionToDelete.visibleStart(), CanCrossEditingBoundary)
896             &amp;&amp; isEndOfParagraph(m_selectionToDelete.visibleEnd(), CanCrossEditingBoundary)
897             &amp;&amp; !lineBreakExistsAtVisiblePosition(m_selectionToDelete.visibleEnd());
898     if (m_needPlaceholder) {
899         // Don&#39;t need a placeholder when deleting a selection that starts just before a table
900         // and ends inside it (we do need placeholders to hold open empty cells, but that&#39;s
901         // handled elsewhere).
902         if (auto* table = isLastPositionBeforeTable(m_selectionToDelete.visibleStart())) {
903             if (m_selectionToDelete.end().deprecatedNode()-&gt;isDescendantOf(*table))
904                 m_needPlaceholder = false;
905         }
906     }
907 
908 
909     // set up our state
910     if (!initializePositionData())
911         return;
912 
913     // Delete any text that may hinder our ability to fixup whitespace after the delete
914     deleteInsignificantTextDownstream(m_trailingWhitespace);
915 
916     saveTypingStyleState();
917 
918     // deleting just a BR is handled specially, at least because we do not
919     // want to replace it with a placeholder BR!
920     if (handleSpecialCaseBRDelete()) {
921         calculateTypingStyleAfterDelete();
922         setEndingSelection(VisibleSelection(m_endingPosition, affinity, endingSelection().isDirectional()));
923         clearTransientState();
924         rebalanceWhitespace();
925         return;
926     }
927 
928     handleGeneralDelete();
929 
930     fixupWhitespace();
931 
932     mergeParagraphs();
933 
934     removePreviouslySelectedEmptyTableRows();
935 
936     if (m_needPlaceholder) {
937         if (m_sanitizeMarkup)
938             removeRedundantBlocks();
939         insertNodeAt(HTMLBRElement::create(document()), m_endingPosition);
940     }
941 
942     bool shouldRebalaceWhiteSpace = true;
943     if (!frame().editor().behavior().shouldRebalanceWhiteSpacesInSecureField()) {
944         Node* node = m_endingPosition.deprecatedNode();
945         if (is&lt;Text&gt;(node)) {
946             Text&amp; textNode = downcast&lt;Text&gt;(*node);
947             if (textNode.length() &amp;&amp; textNode.renderer())
948                 shouldRebalaceWhiteSpace = textNode.renderer()-&gt;style().textSecurity() == TextSecurity::None;
949         }
950     }
951     if (shouldRebalaceWhiteSpace)
952         rebalanceWhitespaceAt(m_endingPosition);
953 
954     calculateTypingStyleAfterDelete();
955 
956     if (!originalString.isEmpty())
957         frame().editor().deletedAutocorrectionAtPosition(m_endingPosition, originalString);
958 
959     setEndingSelection(VisibleSelection(m_endingPosition, affinity, endingSelection().isDirectional()));
960     clearTransientState();
961 }
962 
963 // Normally deletion doesn&#39;t preserve the typing style that was present before it.  For example,
964 // type a character, Bold, then delete the character and start typing.  The Bold typing style shouldn&#39;t
965 // stick around.  Deletion should preserve a typing style that *it* sets, however.
966 bool DeleteSelectionCommand::preservesTypingStyle() const
967 {
968     return m_typingStyle;
969 }
970 
971 } // namespace WebCore
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>