diff a/modules/javafx.web/src/main/native/Source/WebCore/inspector/InspectorOverlay.cpp b/modules/javafx.web/src/main/native/Source/WebCore/inspector/InspectorOverlay.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/inspector/InspectorOverlay.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/inspector/InspectorOverlay.cpp
@@ -1,7 +1,8 @@
 /*
  * Copyright (C) 2011 Google Inc. All rights reserved.
+ * Copyright (C) 2019 Apple Inc. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
  *
@@ -27,62 +28,94 @@
  */
 
 #include "config.h"
 #include "InspectorOverlay.h"
 
-#include "CacheStorageProvider.h"
-#include "DocumentLoader.h"
-#include "EditorClient.h"
+#include "AXObjectCache.h"
+#include "AccessibilityObject.h"
+#include "DOMCSSNamespace.h"
+#include "DOMTokenList.h"
 #include "Element.h"
-#include "EmptyClients.h"
+#include "FloatPoint.h"
+#include "FloatRoundedRect.h"
+#include "FloatSize.h"
+#include "FontCascade.h"
+#include "FontCascadeDescription.h"
 #include "Frame.h"
 #include "FrameView.h"
 #include "GraphicsContext.h"
 #include "InspectorClient.h"
-#include "InspectorOverlayPage.h"
-#include "LibWebRTCProvider.h"
+#include "IntPoint.h"
+#include "IntRect.h"
+#include "IntSize.h"
 #include "Node.h"
+#include "NodeList.h"
 #include "Page.h"
-#include "PageConfiguration.h"
-#include "PolygonShape.h"
 #include "PseudoElement.h"
-#include "RTCController.h"
-#include "RectangleShape.h"
+#include "RenderBox.h"
 #include "RenderBoxModelObject.h"
-#include "RenderElement.h"
 #include "RenderInline.h"
-#include "RenderView.h"
-#include "ScriptController.h"
-#include "ScriptSourceCode.h"
+#include "RenderObject.h"
 #include "Settings.h"
-#include "SocketProvider.h"
-#include "StyledElement.h"
-#include <JavaScriptCore/InspectorProtocolObjects.h>
-#include <wtf/JSONValues.h>
-
-#if PLATFORM(MAC)
-#include "LocalDefaultSystemAppearance.h"
-#endif
+#include <wtf/MathExtras.h>
+#include <wtf/text/StringBuilder.h>
 
 namespace WebCore {
 
 using namespace Inspector;
 
+static constexpr float elementDataSpacing = 2;
+static constexpr float elementDataArrowSize = 7;
+static constexpr float elementDataBorderSize = 1;
+
+static constexpr float rulerSize = 15;
+static constexpr float rulerLabelSize = 13;
+static constexpr float rulerStepIncrement = 50;
+static constexpr float rulerStepLength = 8;
+static constexpr float rulerSubStepIncrement = 5;
+static constexpr float rulerSubStepLength = 5;
+
+static constexpr UChar ellipsis = 0x2026;
+static constexpr UChar multiplicationSign = 0x00D7;
+
+static void truncateWithEllipsis(String& string, size_t length)
+{
+    if (string.length() > length) {
+        string.truncate(length);
+        string.append(ellipsis);
+    }
+}
+
+static FloatPoint localPointToRootPoint(const FrameView* view, const FloatPoint& point)
+{
+    return view->contentsToRootView(roundedIntPoint(point));
+}
+
 static void contentsQuadToCoordinateSystem(const FrameView* mainView, const FrameView* view, FloatQuad& quad, InspectorOverlay::CoordinateSystem coordinateSystem)
 {
-    quad.setP1(view->contentsToRootView(roundedIntPoint(quad.p1())));
-    quad.setP2(view->contentsToRootView(roundedIntPoint(quad.p2())));
-    quad.setP3(view->contentsToRootView(roundedIntPoint(quad.p3())));
-    quad.setP4(view->contentsToRootView(roundedIntPoint(quad.p4())));
+    quad.setP1(localPointToRootPoint(view, quad.p1()));
+    quad.setP2(localPointToRootPoint(view, quad.p2()));
+    quad.setP3(localPointToRootPoint(view, quad.p3()));
+    quad.setP4(localPointToRootPoint(view, quad.p4()));
 
     if (coordinateSystem == InspectorOverlay::CoordinateSystem::View)
         quad += toIntSize(mainView->scrollPosition());
 }
 
-static void contentsQuadToPage(const FrameView* mainView, const FrameView* view, FloatQuad& quad)
+static Element* effectiveElementForNode(Node& node)
 {
-    contentsQuadToCoordinateSystem(mainView, view, quad, InspectorOverlay::CoordinateSystem::View);
+    if (!is<Element>(node) || !node.document().frame())
+        return nullptr;
+
+    Element* element = nullptr;
+    if (is<PseudoElement>(node)) {
+        if (Element* hostElement = downcast<PseudoElement>(node).hostElement())
+            element = hostElement;
+    } else
+        element = &downcast<Element>(node);
+
+    return element;
 }
 
 static void buildRendererHighlight(RenderObject* renderer, const HighlightConfig& highlightConfig, Highlight& highlight, InspectorOverlay::CoordinateSystem coordinateSystem)
 {
     Frame* containingFrame = renderer->document().frame();
@@ -164,10 +197,170 @@
     highlight.setDataFromConfig(highlightConfig);
     highlight.type = HighlightType::Rects;
     highlight.quads.append(quad);
 }
 
+static Path quadToPath(const FloatQuad& quad, Highlight::Bounds& bounds)
+{
+    Path path;
+    path.moveTo(quad.p1());
+    path.addLineTo(quad.p2());
+    path.addLineTo(quad.p3());
+    path.addLineTo(quad.p4());
+    path.closeSubpath();
+
+    bounds.unite(path.boundingRect());
+
+    return path;
+}
+
+static void drawOutlinedQuadWithClip(GraphicsContext& context, const FloatQuad& quad, const FloatQuad& clipQuad, const Color& fillColor, Highlight::Bounds& bounds)
+{
+    GraphicsContextStateSaver stateSaver(context);
+
+    context.setFillColor(fillColor);
+    context.setStrokeThickness(0);
+    context.fillPath(quadToPath(quad, bounds));
+
+    context.setCompositeOperation(CompositeDestinationOut);
+    context.setFillColor(Color::createUnchecked(255, 0, 0));
+    context.fillPath(quadToPath(clipQuad, bounds));
+}
+
+static void drawOutlinedQuad(GraphicsContext& context, const FloatQuad& quad, const Color& fillColor, const Color& outlineColor, Highlight::Bounds& bounds)
+{
+    Path path = quadToPath(quad, bounds);
+
+    GraphicsContextStateSaver stateSaver(context);
+
+    context.setStrokeThickness(2);
+
+    context.clipPath(path);
+
+    context.setFillColor(fillColor);
+    context.fillPath(path);
+
+    context.setStrokeColor(outlineColor);
+    context.strokePath(path);
+}
+
+static void drawFragmentHighlight(GraphicsContext& context, Node& node, const HighlightConfig& highlightConfig, Highlight::Bounds& bounds)
+{
+    Highlight highlight;
+    buildNodeHighlight(node, highlightConfig, highlight, InspectorOverlay::CoordinateSystem::Document);
+
+    FloatQuad marginQuad;
+    FloatQuad borderQuad;
+    FloatQuad paddingQuad;
+    FloatQuad contentQuad;
+
+    size_t size = highlight.quads.size();
+    if (size >= 1)
+        marginQuad = highlight.quads[0];
+    if (size >= 2)
+        borderQuad = highlight.quads[1];
+    if (size >= 3)
+        paddingQuad = highlight.quads[2];
+    if (size >= 4)
+        contentQuad = highlight.quads[3];
+
+    if (!marginQuad.isEmpty() && marginQuad != borderQuad && highlight.marginColor.isVisible())
+        drawOutlinedQuadWithClip(context, marginQuad, borderQuad, highlight.marginColor, bounds);
+
+    if (!borderQuad.isEmpty() && borderQuad != paddingQuad && highlight.borderColor.isVisible())
+        drawOutlinedQuadWithClip(context, borderQuad, paddingQuad, highlight.borderColor, bounds);
+
+    if (!paddingQuad.isEmpty() && paddingQuad != contentQuad && highlight.paddingColor.isVisible())
+        drawOutlinedQuadWithClip(context, paddingQuad, contentQuad, highlight.paddingColor, bounds);
+
+    if (!contentQuad.isEmpty() && (highlight.contentColor.isVisible() || highlight.contentOutlineColor.isVisible()))
+        drawOutlinedQuad(context, contentQuad, highlight.contentColor, highlight.contentOutlineColor, bounds);
+}
+
+static void drawShapeHighlight(GraphicsContext& context, Node& node, Highlight::Bounds& bounds)
+{
+    RenderObject* renderer = node.renderer();
+    if (!renderer || !is<RenderBox>(renderer))
+        return;
+
+    const ShapeOutsideInfo* shapeOutsideInfo = downcast<RenderBox>(renderer)->shapeOutsideInfo();
+    if (!shapeOutsideInfo)
+        return;
+
+    Frame* containingFrame = node.document().frame();
+    if (!containingFrame)
+        return;
+
+    FrameView* containingView = containingFrame->view();
+    FrameView* mainView = containingFrame->page()->mainFrame().view();
+
+    const Color shapeHighlightColor(96, 82, 127, 204);
+
+    Shape::DisplayPaths paths;
+    shapeOutsideInfo->computedShape().buildDisplayPaths(paths);
+
+    if (paths.shape.isEmpty()) {
+        LayoutRect shapeBounds = shapeOutsideInfo->computedShapePhysicalBoundingBox();
+        FloatQuad shapeQuad = renderer->localToAbsoluteQuad(FloatRect(shapeBounds));
+        contentsQuadToCoordinateSystem(mainView, containingView, shapeQuad, InspectorOverlay::CoordinateSystem::Document);
+        drawOutlinedQuad(context, shapeQuad, shapeHighlightColor, Color::transparent, bounds);
+        return;
+    }
+
+    const auto mapPoints = [&] (const Path& path) {
+        Path newPath;
+        path.apply([&] (const PathElement& pathElement) {
+            const auto localToRoot = [&] (size_t index) {
+                const FloatPoint& point = pathElement.points[index];
+                return localPointToRootPoint(containingView, renderer->localToAbsolute(shapeOutsideInfo->shapeToRendererPoint(point)));
+            };
+
+            switch (pathElement.type) {
+            case PathElementMoveToPoint:
+                newPath.moveTo(localToRoot(0));
+                break;
+
+            case PathElementAddLineToPoint:
+                newPath.addLineTo(localToRoot(0));
+                break;
+
+            case PathElementAddCurveToPoint:
+                newPath.addBezierCurveTo(localToRoot(0), localToRoot(1), localToRoot(2));
+                break;
+
+            case PathElementAddQuadCurveToPoint:
+                newPath.addQuadCurveTo(localToRoot(0), localToRoot(1));
+                break;
+
+            case PathElementCloseSubpath:
+                newPath.closeSubpath();
+                break;
+            }
+        });
+        return newPath;
+    };
+
+    if (paths.marginShape.length()) {
+        Path marginPath = mapPoints(paths.marginShape);
+        bounds.unite(marginPath.boundingRect());
+
+        GraphicsContextStateSaver stateSaver(context);
+
+        const Color shapeMarginHighlightColor(96, 82, 127, 153);
+        context.setFillColor(shapeMarginHighlightColor);
+        context.fillPath(marginPath);
+    }
+
+    Path shapePath = mapPoints(paths.shape);
+    bounds.unite(shapePath.boundingRect());
+
+    GraphicsContextStateSaver stateSaver(context);
+
+    context.setFillColor(shapeHighlightColor);
+    context.fillPath(shapePath);
+}
+
 InspectorOverlay::InspectorOverlay(Page& page, InspectorClient* client)
     : m_page(page)
     , m_client(client)
     , m_paintRectUpdateTimer(*this, &InspectorOverlay::updatePaintRectsTimerFired)
 {
@@ -178,23 +371,51 @@
 void InspectorOverlay::paint(GraphicsContext& context)
 {
     if (!shouldShowOverlay())
         return;
 
-    Page* overlayPage = this->overlayPage();
-    if (!overlayPage)
-        return;
+    FloatSize viewportSize = m_page.mainFrame().view()->sizeForVisibleContent();
+
+    context.clearRect({ FloatPoint::zero(), viewportSize });
 
     GraphicsContextStateSaver stateSaver(context);
-    FrameView* view = overlayPage->mainFrame().view();
 
-#if PLATFORM(MAC)
-    LocalDefaultSystemAppearance localAppearance(view->useDarkAppearance());
-#endif
+    if (m_indicating) {
+        GraphicsContextStateSaver stateSaver(context);
+
+        const Color indicatingColor(111, 168, 220, 168);
+        context.setFillColor(indicatingColor);
+        context.fillRect({ FloatPoint::zero(), viewportSize });
+    }
+
+    RulerExclusion rulerExclusion;
+
+    if (m_highlightQuad) {
+        auto quadRulerExclusion = drawQuadHighlight(context, *m_highlightQuad);
+        rulerExclusion.bounds.unite(quadRulerExclusion.bounds);
+    }
+
+    if (m_highlightNodeList) {
+        for (unsigned i = 0; i < m_highlightNodeList->length(); ++i) {
+            if (auto* node = m_highlightNodeList->item(i)) {
+                auto nodeRulerExclusion = drawNodeHighlight(context, *node);
+                rulerExclusion.bounds.unite(nodeRulerExclusion.bounds);
+            }
+        }
+    }
+
+    if (m_highlightNode) {
+        auto nodeRulerExclusion = drawNodeHighlight(context, *m_highlightNode);
+        rulerExclusion.bounds.unite(nodeRulerExclusion.bounds);
+        rulerExclusion.titlePath = nodeRulerExclusion.titlePath;
+    }
+
+    if (!m_paintRects.isEmpty())
+        drawPaintRects(context, m_paintRects);
 
-    view->updateLayoutAndStyleIfNeededRecursive();
-    view->paint(context, IntRect(0, 0, view->width(), view->height()));
+    if (m_showRulers || m_showRulersDuringElementSelection)
+        drawRulers(context, rulerExclusion);
 }
 
 void InspectorOverlay::getHighlight(Highlight& highlight, InspectorOverlay::CoordinateSystem coordinateSystem) const
 {
     if (!m_highlightNode && !m_highlightQuad && !m_highlightNodeList)
@@ -214,16 +435,10 @@
         highlight.type = HighlightType::NodeList;
     } else
         buildQuadHighlight(*m_highlightQuad, m_quadHighlightConfig, highlight);
 }
 
-void InspectorOverlay::setPausedInDebuggerMessage(const String* message)
-{
-    m_pausedInDebuggerMessage = message ? *message : String();
-    update();
-}
-
 void InspectorOverlay::hideHighlight()
 {
     m_highlightNode = nullptr;
     m_highlightNodeList = nullptr;
     m_highlightQuad = nullptr;
@@ -266,23 +481,23 @@
     m_client->didSetSearchingForNode(enabled);
 }
 
 void InspectorOverlay::setIndicating(bool indicating)
 {
-    m_indicating = indicating;
+    if (m_indicating == indicating)
+        return;
 
-    if (m_indicating)
-        evaluateInOverlay("showPageIndication"_s);
-    else
-        evaluateInOverlay("hidePageIndication"_s);
+    m_indicating = indicating;
 
     update();
 }
 
 bool InspectorOverlay::shouldShowOverlay() const
 {
-    return m_highlightNode || m_highlightNodeList || m_highlightQuad || m_indicating || m_showingPaintRects || m_showRulers || !m_pausedInDebuggerMessage.isNull();
+    // Don't show the overlay when m_showRulersDuringElementSelection is true, as it's only supposed
+    // to have an effect when element selection is active (e.g. a node is hovered).
+    return m_highlightNode || m_highlightNodeList || m_highlightQuad || m_indicating || m_showPaintRects || m_showRulers;
 }
 
 void InspectorOverlay::update()
 {
     if (!shouldShowOverlay()) {
@@ -292,111 +507,29 @@
 
     FrameView* view = m_page.mainFrame().view();
     if (!view)
         return;
 
-    Page* overlayPage = this->overlayPage();
-    if (overlayPage) {
-        FrameView* overlayView = overlayPage->mainFrame().view();
-        IntSize frameViewFullSize = view->sizeForVisibleContent(ScrollableArea::IncludeScrollbars);
-        overlayView->resize(frameViewFullSize);
-    }
-
-    // Clear canvas and paint things.
-    IntSize viewportSize = view->sizeForVisibleContent();
-    IntPoint scrollOffset = view->scrollPosition();
-    reset(viewportSize, scrollOffset);
-
-    // Include scrollbars to avoid masking them by the gutter.
-    drawNodeHighlight();
-    drawQuadHighlight();
-    drawPausedInDebuggerMessage();
-    drawPaintRects();
-
-    if (m_showRulers)
-        drawRulers();
-
-    // Position DOM elements.
-    if (overlayPage) {
-        overlayPage->mainFrame().document()->resolveStyle(Document::ResolveStyleType::Rebuild);
-        FrameView* overlayView = overlayPage->mainFrame().view();
-        if (overlayView->needsLayout())
-            overlayView->layoutContext().layout();
-    }
-
-    forcePaint();
-}
-
-static Ref<Inspector::Protocol::OverlayTypes::Point> buildObjectForPoint(const FloatPoint& point)
-{
-    return Inspector::Protocol::OverlayTypes::Point::create()
-        .setX(point.x())
-        .setY(point.y())
-        .release();
-}
-
-static Ref<Inspector::Protocol::OverlayTypes::Rect> buildObjectForRect(const FloatRect& rect)
-{
-    return Inspector::Protocol::OverlayTypes::Rect::create()
-        .setX(rect.x())
-        .setY(rect.y())
-        .setWidth(rect.width())
-        .setHeight(rect.height())
-        .release();
-}
-
-static Ref<Inspector::Protocol::OverlayTypes::Quad> buildArrayForQuad(const FloatQuad& quad)
-{
-    auto array = Inspector::Protocol::OverlayTypes::Quad::create();
-    array->addItem(buildObjectForPoint(quad.p1()));
-    array->addItem(buildObjectForPoint(quad.p2()));
-    array->addItem(buildObjectForPoint(quad.p3()));
-    array->addItem(buildObjectForPoint(quad.p4()));
-    return array;
-}
-
-static Ref<Inspector::Protocol::OverlayTypes::FragmentHighlightData> buildObjectForHighlight(const Highlight& highlight)
-{
-    auto arrayOfQuads = JSON::ArrayOf<Inspector::Protocol::OverlayTypes::Quad>::create();
-    for (auto& quad : highlight.quads)
-        arrayOfQuads->addItem(buildArrayForQuad(quad));
-
-    return Inspector::Protocol::OverlayTypes::FragmentHighlightData::create()
-        .setQuads(WTFMove(arrayOfQuads))
-        .setContentColor(highlight.contentColor.serialized())
-        .setContentOutlineColor(highlight.contentOutlineColor.serialized())
-        .setPaddingColor(highlight.paddingColor.serialized())
-        .setBorderColor(highlight.borderColor.serialized())
-        .setMarginColor(highlight.marginColor.serialized())
-        .release();
-}
-
-static Ref<Inspector::Protocol::OverlayTypes::Size> buildObjectForSize(const IntSize& size)
-{
-    return Inspector::Protocol::OverlayTypes::Size::create()
-        .setWidth(size.width())
-        .setHeight(size.height())
-        .release();
+    m_client->highlight();
 }
 
-void InspectorOverlay::setShowingPaintRects(bool showingPaintRects)
+void InspectorOverlay::setShowPaintRects(bool showPaintRects)
 {
-    if (m_showingPaintRects == showingPaintRects)
+    if (m_showPaintRects == showPaintRects)
         return;
 
-    m_showingPaintRects = showingPaintRects;
-    if (!m_showingPaintRects) {
+    m_showPaintRects = showPaintRects;
+    if (!m_showPaintRects) {
         m_paintRects.clear();
         m_paintRectUpdateTimer.stop();
-        drawPaintRects();
-        forcePaint();
+        update();
     }
 }
 
 void InspectorOverlay::showPaintRect(const FloatRect& rect)
 {
-    if (!m_showingPaintRects)
+    if (!m_showPaintRects)
         return;
 
     IntRect rootRect = m_page.mainFrame().view()->contentsToRootView(enclosingIntRect(rect));
 
     const auto removeDelay = 250_ms;
@@ -407,12 +540,11 @@
     if (!m_paintRectUpdateTimer.isActive()) {
         const Seconds paintRectsUpdateInterval { 32_ms };
         m_paintRectUpdateTimer.startRepeating(paintRectsUpdateInterval);
     }
 
-    drawPaintRects();
-    forcePaint();
+    update();
 }
 
 void InspectorOverlay::setShowRulers(bool showRulers)
 {
     if (m_showRulers == showRulers)
@@ -433,392 +565,534 @@
     }
 
     if (m_paintRects.isEmpty())
         m_paintRectUpdateTimer.stop();
 
-    if (rectsChanged) {
-        drawPaintRects();
-        forcePaint();
-    }
+    if (rectsChanged)
+        update();
 }
 
-void InspectorOverlay::drawPaintRects()
+InspectorOverlay::RulerExclusion InspectorOverlay::drawNodeHighlight(GraphicsContext& context, Node& node)
 {
-    auto arrayOfRects = JSON::ArrayOf<Inspector::Protocol::OverlayTypes::Rect>::create();
-    for (const auto& pair : m_paintRects)
-        arrayOfRects->addItem(buildObjectForRect(pair.second));
+    RulerExclusion rulerExclusion;
 
-    evaluateInOverlay("updatePaintRects"_s, WTFMove(arrayOfRects));
-}
+    drawFragmentHighlight(context, node, m_nodeHighlightConfig, rulerExclusion.bounds);
 
-void InspectorOverlay::drawRulers()
-{
-    evaluateInOverlay("drawRulers"_s);
+    if (m_nodeHighlightConfig.showInfo)
+        drawShapeHighlight(context, node, rulerExclusion.bounds);
+
+    if (m_showRulers || m_showRulersDuringElementSelection)
+        drawBounds(context, rulerExclusion.bounds);
+
+    // Ensure that the title information is drawn after the bounds.
+    if (m_nodeHighlightConfig.showInfo)
+        rulerExclusion.titlePath = drawElementTitle(context, node, rulerExclusion.bounds);
+
+    return rulerExclusion;
 }
 
-static RefPtr<JSON::ArrayOf<Inspector::Protocol::OverlayTypes::FragmentHighlightData>> buildArrayForRendererFragments(RenderObject* renderer, const HighlightConfig& config)
+InspectorOverlay::RulerExclusion InspectorOverlay::drawQuadHighlight(GraphicsContext& context, const FloatQuad& quad)
 {
-    auto arrayOfFragments = JSON::ArrayOf<Inspector::Protocol::OverlayTypes::FragmentHighlightData>::create();
+    RulerExclusion rulerExclusion;
 
     Highlight highlight;
-    buildRendererHighlight(renderer, config, highlight, InspectorOverlay::CoordinateSystem::View);
-    arrayOfFragments->addItem(buildObjectForHighlight(highlight));
+    buildQuadHighlight(quad, m_quadHighlightConfig, highlight);
+
+    if (highlight.quads.size() >= 1) {
+        drawOutlinedQuad(context, highlight.quads[0], highlight.contentColor, highlight.contentOutlineColor, rulerExclusion.bounds);
 
-    return WTFMove(arrayOfFragments);
+        if (m_showRulers || m_showRulersDuringElementSelection)
+            drawBounds(context, rulerExclusion.bounds);
+    }
+
+    return rulerExclusion;
 }
 
-static FloatPoint localPointToRoot(RenderObject* renderer, const FrameView* mainView, const FrameView* view, const FloatPoint& point)
+void InspectorOverlay::drawPaintRects(GraphicsContext& context, const Deque<TimeRectPair>& paintRects)
 {
-    FloatPoint result = renderer->localToAbsolute(point);
-    result = view->contentsToRootView(roundedIntPoint(result));
-    result += toIntSize(mainView->scrollPosition());
-    return result;
-}
+    GraphicsContextStateSaver stateSaver(context);
 
-struct PathApplyInfo {
-    FrameView* rootView;
-    FrameView* view;
-    Inspector::Protocol::OverlayTypes::DisplayPath* pathArray;
-    RenderObject* renderer;
-    const ShapeOutsideInfo* shapeOutsideInfo;
-};
+    const Color paintRectsColor(1.0f, 0.0f, 0.0f, 0.5f);
+    context.setFillColor(paintRectsColor);
 
-static void appendPathCommandAndPoints(PathApplyInfo& info, const String& command, const FloatPoint points[], unsigned length)
+    for (const TimeRectPair& pair : paintRects)
+        context.fillRect(pair.second);
+}
+
+void InspectorOverlay::drawBounds(GraphicsContext& context, const Highlight::Bounds& bounds)
 {
-    FloatPoint point;
-    info.pathArray->addItem(command);
-    for (unsigned i = 0; i < length; i++) {
-        point = info.shapeOutsideInfo->shapeToRendererPoint(points[i]);
-        point = localPointToRoot(info.renderer, info.rootView, info.view, point);
-        info.pathArray->addItem(point.x());
-        info.pathArray->addItem(point.y());
+    FrameView* pageView = m_page.mainFrame().view();
+    FloatSize viewportSize = pageView->sizeForVisibleContent();
+    FloatSize contentInset(0, pageView->topContentInset(ScrollView::TopContentInsetType::WebCoreOrPlatformContentInset));
+
+    Path path;
+
+    if (bounds.y() > contentInset.height()) {
+        path.moveTo({ bounds.x(), bounds.y() });
+        path.addLineTo({ bounds.x(), contentInset.height() });
+
+        path.moveTo({ bounds.maxX(), bounds.y() });
+        path.addLineTo({ bounds.maxX(), contentInset.height() });
+    }
+
+    if (bounds.maxY() < viewportSize.height()) {
+        path.moveTo({ bounds.x(), viewportSize.height() });
+        path.addLineTo({ bounds.x(), bounds.maxY() });
+
+        path.moveTo({ bounds.maxX(), viewportSize.height() });
+        path.addLineTo({ bounds.maxX(), bounds.maxY() });
     }
-}
 
-static void appendPathSegment(PathApplyInfo& pathApplyInfo, const PathElement& pathElement)
-{
-    FloatPoint point;
-    switch (pathElement.type) {
-    // The points member will contain 1 value.
-    case PathElementMoveToPoint:
-        appendPathCommandAndPoints(pathApplyInfo, "M"_s, pathElement.points, 1);
-        break;
-    // The points member will contain 1 value.
-    case PathElementAddLineToPoint:
-        appendPathCommandAndPoints(pathApplyInfo, "L"_s, pathElement.points, 1);
-        break;
-    // The points member will contain 3 values.
-    case PathElementAddCurveToPoint:
-        appendPathCommandAndPoints(pathApplyInfo, "C"_s, pathElement.points, 3);
-        break;
-    // The points member will contain 2 values.
-    case PathElementAddQuadCurveToPoint:
-        appendPathCommandAndPoints(pathApplyInfo, "Q"_s, pathElement.points, 2);
-        break;
-    // The points member will contain no values.
-    case PathElementCloseSubpath:
-        appendPathCommandAndPoints(pathApplyInfo, "Z"_s, nullptr, 0);
-        break;
+    if (bounds.x() > contentInset.width()) {
+        path.moveTo({ bounds.x(), bounds.y() });
+        path.addLineTo({ contentInset.width(), bounds.y() });
+
+        path.moveTo({ bounds.x(), bounds.maxY() });
+        path.addLineTo({ contentInset.width(), bounds.maxY() });
+    }
+
+    if (bounds.maxX() < viewportSize.width()) {
+        path.moveTo({ bounds.maxX(), bounds.y() });
+        path.addLineTo({ viewportSize.width(), bounds.y() });
+
+        path.moveTo({ bounds.maxX(), bounds.maxY() });
+        path.addLineTo({ viewportSize.width(), bounds.maxY() });
     }
+
+    GraphicsContextStateSaver stateSaver(context);
+
+    context.setStrokeThickness(1);
+
+    const Color boundsColor(1.0f, 0.0f, 0.0f, 0.6f);
+    context.setStrokeColor(boundsColor);
+
+    context.strokePath(path);
 }
 
-static RefPtr<Inspector::Protocol::OverlayTypes::ShapeOutsideData> buildObjectForShapeOutside(Frame* containingFrame, RenderBox* renderer)
+void InspectorOverlay::drawRulers(GraphicsContext& context, const InspectorOverlay::RulerExclusion& rulerExclusion)
 {
-    const ShapeOutsideInfo* shapeOutsideInfo = renderer->shapeOutsideInfo();
-    if (!shapeOutsideInfo)
-        return nullptr;
+    const Color rulerBackgroundColor(1.0f, 1.0f, 1.0f, 0.6f);
+    const Color lightRulerColor(0.0f, 0.0f, 0.0f, 0.2f);
+    const Color darkRulerColor(0.0f, 0.0f, 0.0f, 0.5f);
+
+    IntPoint scrollOffset;
+
+    FrameView* pageView = m_page.mainFrame().view();
+    if (!pageView->delegatesScrolling())
+        scrollOffset = pageView->visibleContentRect().location();
+
+    FloatSize viewportSize = pageView->sizeForVisibleContent();
+    FloatSize contentInset(0, pageView->topContentInset(ScrollView::TopContentInsetType::WebCoreOrPlatformContentInset));
+    float pageScaleFactor = m_page.pageScaleFactor();
+    float pageZoomFactor = m_page.mainFrame().pageZoomFactor();
+
+    float pageFactor = pageZoomFactor * pageScaleFactor;
+    float scrollX = scrollOffset.x() * pageScaleFactor;
+    float scrollY = scrollOffset.y() * pageScaleFactor;
+
+    const auto zoom = [&] (float value) -> float {
+        return value * pageFactor;
+    };
+
+    const auto unzoom = [&] (float value) -> float {
+        return value / pageFactor;
+    };
+
+    const auto multipleBelow = [&] (float value, float step) -> float {
+        return value - std::fmod(value, step);
+    };
+
+    float width = viewportSize.width() / pageFactor;
+    float height = viewportSize.height() / pageFactor;
+    float minX = unzoom(scrollX);
+    float minY = unzoom(scrollY);
+    float maxX = minX + width;
+    float maxY = minY + height;
+
+    bool drawTopEdge = true;
+    bool drawLeftEdge = true;
+
+    // Determine which side (top/bottom and left/right) to draw the rulers.
+    {
+        FloatRect topEdge(contentInset.width(), contentInset.height(), zoom(width) - contentInset.width(), rulerSize);
+        FloatRect bottomEdge(contentInset.width(), zoom(height) - rulerSize, zoom(width) - contentInset.width(), rulerSize);
+        drawTopEdge = !rulerExclusion.bounds.intersects(topEdge) || rulerExclusion.bounds.intersects(bottomEdge);
+
+        FloatRect rightEdge(zoom(width) - rulerSize, contentInset.height(), rulerSize, zoom(height) - contentInset.height());
+        FloatRect leftEdge(contentInset.width(), contentInset.height(), rulerSize, zoom(height) - contentInset.height());
+        drawLeftEdge = !rulerExclusion.bounds.intersects(leftEdge) || rulerExclusion.bounds.intersects(rightEdge);
+    }
 
-    LayoutRect shapeBounds = shapeOutsideInfo->computedShapePhysicalBoundingBox();
-    FloatQuad shapeQuad = renderer->localToAbsoluteQuad(FloatRect(shapeBounds));
-    contentsQuadToPage(containingFrame->page()->mainFrame().view(), containingFrame->view(), shapeQuad);
+    float cornerX = drawLeftEdge ? contentInset.width() : zoom(width) - rulerSize;
+    float cornerY = drawTopEdge ? contentInset.height() : zoom(height) - rulerSize;
 
-    auto shapeObject = Inspector::Protocol::OverlayTypes::ShapeOutsideData::create()
-        .setBounds(buildArrayForQuad(shapeQuad))
-        .release();
+    // Draw backgrounds.
+    {
+        GraphicsContextStateSaver backgroundStateSaver(context);
 
-    Shape::DisplayPaths paths;
-    shapeOutsideInfo->computedShape().buildDisplayPaths(paths);
+        context.setFillColor(rulerBackgroundColor);
 
-    if (paths.shape.length()) {
-        auto shapePath = Inspector::Protocol::OverlayTypes::DisplayPath::create();
-        PathApplyInfo info;
-        info.rootView = containingFrame->page()->mainFrame().view();
-        info.view = containingFrame->view();
-        info.pathArray = &shapePath.get();
-        info.renderer = renderer;
-        info.shapeOutsideInfo = shapeOutsideInfo;
-
-        paths.shape.apply([&info](const PathElement& pathElement) {
-            appendPathSegment(info, pathElement);
-        });
+        context.fillRect({ cornerX, cornerY, rulerSize, rulerSize });
+
+        if (drawLeftEdge)
+            context.fillRect({ cornerX + rulerSize, cornerY, zoom(width) - cornerX - rulerSize, rulerSize });
+        else
+            context.fillRect({ contentInset.width(), cornerY, cornerX - contentInset.width(), rulerSize });
+
+        if (drawTopEdge)
+            context.fillRect({ cornerX, cornerY + rulerSize, rulerSize, zoom(height) - cornerY - rulerSize });
+        else
+            context.fillRect({ cornerX, contentInset.height(), rulerSize, cornerY - contentInset.height() });
+    }
+
+    // Draw lines.
+    {
+        FontCascadeDescription fontDescription;
+        fontDescription.setOneFamily(m_page.settings().sansSerifFontFamily());
+        fontDescription.setComputedSize(10);
+
+        FontCascade font(WTFMove(fontDescription), 0, 0);
+        font.update(nullptr);
+
+        GraphicsContextStateSaver lineStateSaver(context);
+
+        context.setFillColor(darkRulerColor);
+        context.setStrokeThickness(1);
+
+        // Draw horizontal ruler.
+        {
+            GraphicsContextStateSaver horizontalRulerStateSaver(context);
+
+            context.translate(contentInset.width() - scrollX + 0.5f, cornerY - scrollY);
+
+            for (float x = multipleBelow(minX, rulerSubStepIncrement); x < maxX; x += rulerSubStepIncrement) {
+                if (!x && !scrollX)
+                    continue;
+
+                Path path;
+                path.moveTo({ zoom(x), drawTopEdge ? scrollY : scrollY + rulerSize });
+
+                float lineLength = 0.0f;
+                if (std::fmod(x, rulerStepIncrement)) {
+                    lineLength = rulerSubStepLength;
+                    context.setStrokeColor(lightRulerColor);
+                } else {
+                    lineLength = std::fmod(x, rulerStepIncrement * 2) ? rulerSubStepLength : rulerStepLength;
+                    context.setStrokeColor(darkRulerColor);
+                }
+                path.addLineTo({ zoom(x), scrollY + (drawTopEdge ? lineLength : rulerSize - lineLength) });
 
-        shapeObject->setShape(shapePath.copyRef());
+                context.strokePath(path);
+            }
 
-        if (paths.marginShape.length()) {
-            auto marginShapePath = Inspector::Protocol::OverlayTypes::DisplayPath::create();
-            info.pathArray = &marginShapePath.get();
+            // Draw labels.
+            for (float x = multipleBelow(minX, rulerStepIncrement * 2); x < maxX; x += rulerStepIncrement * 2) {
+                if (!x && !scrollX)
+                    continue;
 
-            paths.marginShape.apply([&info](const PathElement& pathElement) {
-                appendPathSegment(info, pathElement);
-            });
+                GraphicsContextStateSaver verticalLabelStateSaver(context);
+                context.translate(zoom(x) + 0.5f, scrollY);
+                context.drawText(font, TextRun(String::numberToStringFixedPrecision(x)), { 2, drawTopEdge ? rulerLabelSize : rulerLabelSize - rulerSize + font.fontMetrics().height() - 1.0f });
+            }
+        }
 
-            shapeObject->setMarginShape(marginShapePath.copyRef());
+        // Draw vertical ruler.
+        {
+            GraphicsContextStateSaver veritcalRulerStateSaver(context);
+
+            context.translate(cornerX - scrollX, contentInset.height() - scrollY + 0.5f);
+
+            for (float y = multipleBelow(minY, rulerSubStepIncrement); y < maxY; y += rulerSubStepIncrement) {
+                if (!y && !scrollY)
+                    continue;
+
+                Path path;
+                path.moveTo({ drawLeftEdge ? scrollX : scrollX + rulerSize, zoom(y) });
+
+                float lineLength = 0.0f;
+                if (std::fmod(y, rulerStepIncrement)) {
+                    lineLength = rulerSubStepLength;
+                    context.setStrokeColor(lightRulerColor);
+                } else {
+                    lineLength = std::fmod(y, rulerStepIncrement * 2) ? rulerSubStepLength : rulerStepLength;
+                    context.setStrokeColor(darkRulerColor);
+                }
+                path.addLineTo({ scrollX + (drawLeftEdge ? lineLength : rulerSize - lineLength), zoom(y) });
+
+                context.strokePath(path);
+            }
+
+            // Draw labels.
+            for (float y = multipleBelow(minY, rulerStepIncrement * 2); y < maxY; y += rulerStepIncrement * 2) {
+                if (!y && !scrollY)
+                    continue;
+
+                GraphicsContextStateSaver horizontalLabelStateSaver(context);
+                context.translate(scrollX, zoom(y) + 0.5f);
+                context.rotate(drawLeftEdge ? -piOverTwoFloat : piOverTwoFloat);
+                context.drawText(font, TextRun(String::numberToStringFixedPrecision(y)), { 2, drawLeftEdge ? rulerLabelSize : rulerLabelSize - rulerSize });
+            }
         }
     }
 
-    return WTFMove(shapeObject);
+    // Draw viewport size.
+    {
+        FontCascadeDescription fontDescription;
+        fontDescription.setOneFamily(m_page.settings().sansSerifFontFamily());
+        fontDescription.setComputedSize(12);
+
+        FontCascade font(WTFMove(fontDescription), 0, 0);
+        font.update(nullptr);
+
+        auto viewportRect = pageView->visualViewportRect();
+        auto viewportWidthText = String::numberToStringFixedPrecision(viewportRect.width() / pageZoomFactor);
+        auto viewportHeightText = String::numberToStringFixedPrecision(viewportRect.height() / pageZoomFactor);
+        TextRun viewportTextRun(makeString(viewportWidthText, "px", ' ', multiplicationSign, ' ', viewportHeightText, "px"));
+
+        const float margin = 4;
+        const float padding = 2;
+        const float radius = 4;
+        float fontWidth = font.width(viewportTextRun);
+        float fontHeight = font.fontMetrics().floatHeight();
+        FloatRect viewportTextRect(margin, margin, (padding * 2.0f) + fontWidth, (padding * 2.0f) + fontHeight);
+        const auto viewportTextRectCenter = viewportTextRect.center();
+
+        GraphicsContextStateSaver viewportSizeStateSaver(context);
+
+        float leftTranslateX = rulerSize;
+        float rightTranslateX = 0.0f - (margin * 2.0f) - (padding * 2.0f) - fontWidth;
+        float translateX = cornerX + (drawLeftEdge ? leftTranslateX : rightTranslateX);
+
+        float topTranslateY = rulerSize;
+        float bottomTranslateY = 0.0f - (margin * 2.0f) - (padding * 2.0f) - fontHeight;
+        float translateY = cornerY + (drawTopEdge ? topTranslateY : bottomTranslateY);
+
+        FloatPoint translate(translateX, translateY);
+        if (rulerExclusion.titlePath.contains(viewportTextRectCenter + translate)) {
+            // Try the opposite horizontal side.
+            float oppositeTranslateX = drawLeftEdge ? zoom(width) + rightTranslateX : contentInset.width() + leftTranslateX;
+            translate.setX(oppositeTranslateX);
+
+            if (rulerExclusion.titlePath.contains(viewportTextRectCenter + translate)) {
+                translate.setX(translateX);
+
+                // Try the opposite vertical side.
+                float oppositeTranslateY = drawTopEdge ? zoom(height) + bottomTranslateY : contentInset.height() + topTranslateY;
+                translate.setY(oppositeTranslateY);
+
+                if (rulerExclusion.titlePath.contains(viewportTextRectCenter + translate)) {
+                    // Try the opposite corner.
+                    translate.setX(oppositeTranslateX);
+                }
+            }
+        }
+        context.translate(translate);
+
+        context.fillRoundedRect(FloatRoundedRect(viewportTextRect, FloatRoundedRect::Radii(radius)), rulerBackgroundColor);
+
+        context.setFillColor(Color::black);
+        context.drawText(font, viewportTextRun, {margin +  padding, margin + padding + fontHeight - font.fontMetrics().descent() });
+    }
 }
 
-static RefPtr<Inspector::Protocol::OverlayTypes::ElementData> buildObjectForElementData(Node* node, HighlightType)
+Path InspectorOverlay::drawElementTitle(GraphicsContext& context, Node& node, const Highlight::Bounds& bounds)
 {
-    if (!is<Element>(node) || !node->document().frame())
-        return nullptr;
+    if (bounds.isEmpty())
+        return { };
 
-    Element* effectiveElement = downcast<Element>(node);
-    if (node->isPseudoElement()) {
-        Element* hostElement = downcast<PseudoElement>(*node).hostElement();
-        if (!hostElement)
-            return nullptr;
-        effectiveElement = hostElement;
-    }
+    Element* element = effectiveElementForNode(node);
+    if (!element)
+        return { };
 
-    Element& element = *effectiveElement;
-    bool isXHTML = element.document().isXHTMLDocument();
-    auto elementData = Inspector::Protocol::OverlayTypes::ElementData::create()
-        .setTagName(isXHTML ? element.nodeName() : element.nodeName().convertToASCIILowercase())
-        .setIdValue(element.getIdAttribute())
-        .release();
-
-    if (element.hasClass() && is<StyledElement>(element)) {
-        auto classes = JSON::ArrayOf<String>::create();
-        HashSet<AtomicString> usedClassNames;
-        const SpaceSplitString& classNamesString = downcast<StyledElement>(element).classNames();
-        for (size_t i = 0; i < classNamesString.size(); ++i) {
-            const AtomicString& className = classNamesString[i];
-            if (usedClassNames.contains(className))
-                continue;
-
-            usedClassNames.add(className);
-            classes->addItem(className);
+    RenderObject* renderer = node.renderer();
+    if (!renderer)
+        return { };
+
+    String elementTagName = element->nodeName();
+    if (!element->document().isXHTMLDocument())
+        elementTagName = elementTagName.convertToASCIILowercase();
+
+    String elementIDValue;
+    if (element->hasID())
+        elementIDValue = makeString('#', DOMCSSNamespace::escape(element->getIdAttribute()));
+
+    String elementClassValue;
+    if (element->hasClass()) {
+        StringBuilder builder;
+        DOMTokenList& classList = element->classList();
+        for (size_t i = 0; i < classList.length(); ++i) {
+            builder.append('.');
+            builder.append(DOMCSSNamespace::escape(classList.item(i)));
         }
-        elementData->setClasses(WTFMove(classes));
-    }
 
-    if (node->isPseudoElement()) {
-        if (node->pseudoId() == PseudoId::Before)
-            elementData->setPseudoElement("before");
-        else if (node->pseudoId() == PseudoId::After)
-            elementData->setPseudoElement("after");
+        elementClassValue = builder.toString();
+        truncateWithEllipsis(elementClassValue, 50);
     }
 
-    RenderElement* renderer = element.renderer();
-    if (!renderer)
-        return nullptr;
-
-    Frame* containingFrame = node->document().frame();
-    FrameView* containingView = containingFrame->view();
-    IntRect boundingBox = snappedIntRect(containingView->contentsToRootView(renderer->absoluteBoundingBoxRect()));
-    RenderBoxModelObject* modelObject = is<RenderBoxModelObject>(*renderer) ? downcast<RenderBoxModelObject>(renderer) : nullptr;
-    auto sizeObject = Inspector::Protocol::OverlayTypes::Size::create()
-        .setWidth(modelObject ? adjustForAbsoluteZoom(roundToInt(modelObject->offsetWidth()), *modelObject) : boundingBox.width())
-        .setHeight(modelObject ? adjustForAbsoluteZoom(roundToInt(modelObject->offsetHeight()), *modelObject) : boundingBox.height())
-        .release();
-    elementData->setSize(WTFMove(sizeObject));
-
-    if (is<RenderBox>(*renderer)) {
-        auto& renderBox = downcast<RenderBox>(*renderer);
-        if (RefPtr<Inspector::Protocol::OverlayTypes::ShapeOutsideData> shapeObject = buildObjectForShapeOutside(containingFrame, &renderBox))
-            elementData->setShapeOutsideData(WTFMove(shapeObject));
+    String elementPseudoType;
+    if (node.isBeforePseudoElement())
+        elementPseudoType = "::before"_s;
+    else if (node.isAfterPseudoElement())
+        elementPseudoType = "::after"_s;
+
+    String elementWidth;
+    String elementHeight;
+    if (is<RenderBoxModelObject>(renderer)) {
+        RenderBoxModelObject* modelObject = downcast<RenderBoxModelObject>(renderer);
+        elementWidth = String::number(adjustForAbsoluteZoom(roundToInt(modelObject->offsetWidth()), *modelObject));
+        elementHeight = String::number(adjustForAbsoluteZoom(roundToInt(modelObject->offsetHeight()), *modelObject));
+    } else {
+        FrameView* containingView = node.document().frame()->view();
+        IntRect boundingBox = snappedIntRect(containingView->contentsToRootView(renderer->absoluteBoundingBoxRect()));
+        elementWidth = String::number(boundingBox.width());
+        elementHeight = String::number(boundingBox.height());
     }
 
     // Need to enable AX to get the computed role.
     if (!WebCore::AXObjectCache::accessibilityEnabled())
         WebCore::AXObjectCache::enableAccessibility();
 
-    if (AXObjectCache* axObjectCache = node->document().axObjectCache()) {
-        if (AccessibilityObject* axObject = axObjectCache->getOrCreate(node))
-            elementData->setRole(axObject->computedRoleString());
+    String elementRole;
+    if (AXObjectCache* axObjectCache = node.document().axObjectCache()) {
+        if (AccessibilityObject* axObject = axObjectCache->getOrCreate(&node))
+            elementRole = axObject->computedRoleString();
     }
 
-    return WTFMove(elementData);
-}
+    FontCascadeDescription fontDescription;
+    fontDescription.setFamilies({ "Menlo", m_page.settings().fixedFontFamily() });
+    fontDescription.setComputedSize(11);
 
-RefPtr<Inspector::Protocol::OverlayTypes::NodeHighlightData> InspectorOverlay::buildHighlightObjectForNode(Node* node, HighlightType type) const
-{
-    if (!node)
-        return nullptr;
+    FontCascade font(WTFMove(fontDescription), 0, 0);
+    font.update(nullptr);
 
-    RenderObject* renderer = node->renderer();
-    if (!renderer)
-        return nullptr;
+    int fontHeight = font.fontMetrics().height();
 
-    RefPtr<JSON::ArrayOf<Inspector::Protocol::OverlayTypes::FragmentHighlightData>> arrayOfFragmentHighlights = buildArrayForRendererFragments(renderer, m_nodeHighlightConfig);
-    if (!arrayOfFragmentHighlights)
-        return nullptr;
+    float elementDataWidth;
+    float elementDataHeight = fontHeight;
+    bool hasSecondLine = !elementRole.isEmpty();
 
-    // The main view's scroll offset is shared across all quads.
-    FrameView* mainView = m_page.mainFrame().view();
+    {
+        String firstLine = makeString(elementTagName, elementIDValue, elementClassValue, elementPseudoType, ' ', elementWidth, "px", ' ', multiplicationSign, ' ', elementHeight, "px");
+        String secondLine = makeString("Role ", elementRole);
 
-    auto nodeHighlightObject = Inspector::Protocol::OverlayTypes::NodeHighlightData::create()
-        .setScrollOffset(buildObjectForPoint(!mainView->delegatesScrolling() ? mainView->visibleContentRect().location() : FloatPoint()))
-        .setFragments(WTFMove(arrayOfFragmentHighlights))
-        .release();
+        float firstLineWidth = font.width(TextRun(firstLine));
+        float secondLineWidth = font.width(TextRun(secondLine));
 
-    if (m_nodeHighlightConfig.showInfo) {
-        if (RefPtr<Inspector::Protocol::OverlayTypes::ElementData> elementData = buildObjectForElementData(node, type))
-            nodeHighlightObject->setElementData(WTFMove(elementData));
+        elementDataWidth = std::fmax(firstLineWidth, secondLineWidth);
+        if (hasSecondLine)
+            elementDataHeight += fontHeight;
     }
 
-    return WTFMove(nodeHighlightObject);
-}
+    FrameView* pageView = m_page.mainFrame().view();
 
-Ref<JSON::ArrayOf<Inspector::Protocol::OverlayTypes::NodeHighlightData>> InspectorOverlay::buildObjectForHighlightedNodes() const
-{
-    auto highlights = JSON::ArrayOf<Inspector::Protocol::OverlayTypes::NodeHighlightData>::create();
+    FloatSize viewportSize = pageView->sizeForVisibleContent();
+    viewportSize.expand(-elementDataSpacing, -elementDataSpacing);
 
-    if (m_highlightNode) {
-        if (RefPtr<Inspector::Protocol::OverlayTypes::NodeHighlightData> nodeHighlightData = buildHighlightObjectForNode(m_highlightNode.get(), HighlightType::Node))
-            highlights->addItem(WTFMove(nodeHighlightData));
-    } else if (m_highlightNodeList) {
-        for (unsigned i = 0; i < m_highlightNodeList->length(); ++i) {
-            if (RefPtr<Inspector::Protocol::OverlayTypes::NodeHighlightData> nodeHighlightData = buildHighlightObjectForNode(m_highlightNodeList->item(i), HighlightType::NodeList))
-                highlights->addItem(WTFMove(nodeHighlightData));
-        }
+    FloatSize contentInset(0, pageView->topContentInset(ScrollView::TopContentInsetType::WebCoreOrPlatformContentInset));
+    contentInset.expand(elementDataSpacing, elementDataSpacing);
+    if (m_showRulers || m_showRulersDuringElementSelection)
+        contentInset.expand(rulerSize, rulerSize);
+
+    float anchorTop = bounds.y();
+    float anchorBottom = bounds.maxY();
+
+    bool renderArrowUp = false;
+    bool renderArrowDown = false;
+
+    float boxWidth = elementDataWidth + (elementDataSpacing * 2);
+    float boxHeight = elementDataArrowSize + elementDataHeight + (elementDataSpacing * 2);
+
+    float boxX = bounds.x();
+    if (boxX < contentInset.width())
+        boxX = contentInset.width();
+    else if (boxX > viewportSize.width() - boxWidth)
+        boxX = viewportSize.width() - boxWidth;
+    else
+        boxX += elementDataSpacing;
+
+    float boxY;
+    if (anchorTop > viewportSize.height()) {
+        boxY = viewportSize.height() - boxHeight;
+        renderArrowDown = true;
+    } else if (anchorBottom < contentInset.height()) {
+        boxY = contentInset.height() + elementDataArrowSize;
+        renderArrowUp = true;
+    } else if (anchorTop - boxHeight - elementDataSpacing > contentInset.height()) {
+        boxY = anchorTop - boxHeight - elementDataSpacing;
+        renderArrowDown = true;
+    } else if (anchorBottom + boxHeight + elementDataSpacing < viewportSize.height()) {
+        boxY = anchorBottom + elementDataArrowSize + elementDataSpacing;
+        renderArrowUp = true;
+    } else {
+        boxY = contentInset.height();
+        renderArrowDown = true;
     }
 
-    return highlights;
-}
+    Path path;
+    path.moveTo({ boxX, boxY });
+    if (renderArrowUp) {
+        path.addLineTo({ boxX + (elementDataArrowSize * 2), boxY });
+        path.addLineTo({ boxX + (elementDataArrowSize * 3), boxY - elementDataArrowSize });
+        path.addLineTo({ boxX + (elementDataArrowSize * 4), boxY });
+    }
+    path.addLineTo({ boxX + elementDataWidth + (elementDataSpacing * 2), boxY });
+    path.addLineTo({ boxX + elementDataWidth + (elementDataSpacing * 2), boxY + elementDataHeight + (elementDataSpacing * 2) });
+    if (renderArrowDown) {
+        path.addLineTo({ boxX + (elementDataArrowSize * 4), boxY + elementDataHeight + (elementDataSpacing * 2) });
+        path.addLineTo({ boxX + (elementDataArrowSize * 3), boxY + elementDataHeight + (elementDataSpacing * 2) + elementDataArrowSize });
+        path.addLineTo({ boxX + (elementDataArrowSize * 2), boxY + elementDataHeight + (elementDataSpacing * 2) });
+    }
+    path.addLineTo({ boxX, boxY + elementDataHeight + (elementDataSpacing * 2) });
+    path.closeSubpath();
 
-void InspectorOverlay::drawNodeHighlight()
-{
-    if (m_highlightNode || m_highlightNodeList)
-        evaluateInOverlay("drawNodeHighlight", buildObjectForHighlightedNodes());
-}
+    GraphicsContextStateSaver stateSaver(context);
 
-void InspectorOverlay::drawQuadHighlight()
-{
-    if (!m_highlightQuad)
-        return;
+    context.translate(elementDataBorderSize / 2.0f, elementDataBorderSize / 2.0f);
 
-    Highlight highlight;
-    buildQuadHighlight(*m_highlightQuad, m_quadHighlightConfig, highlight);
-    evaluateInOverlay("drawQuadHighlight", buildObjectForHighlight(highlight));
-}
-
-void InspectorOverlay::drawPausedInDebuggerMessage()
-{
-    if (!m_pausedInDebuggerMessage.isNull())
-        evaluateInOverlay("drawPausedInDebuggerMessage", m_pausedInDebuggerMessage);
-}
-
-Page* InspectorOverlay::overlayPage()
-{
-#if PLATFORM(IOS_FAMILY)
-    return nullptr;
-#else
-    if (m_overlayPage)
-        return m_overlayPage.get();
-
-    auto pageConfiguration = pageConfigurationWithEmptyClients();
-    m_overlayPage = std::make_unique<Page>(WTFMove(pageConfiguration));
-    m_overlayPage->setDeviceScaleFactor(m_page.deviceScaleFactor());
-
-    Settings& settings = m_page.settings();
-    Settings& overlaySettings = m_overlayPage->settings();
-
-    overlaySettings.setStandardFontFamily(settings.standardFontFamily());
-    overlaySettings.setSerifFontFamily(settings.serifFontFamily());
-    overlaySettings.setSansSerifFontFamily(settings.sansSerifFontFamily());
-    overlaySettings.setCursiveFontFamily(settings.cursiveFontFamily());
-    overlaySettings.setFantasyFontFamily(settings.fantasyFontFamily());
-    overlaySettings.setPictographFontFamily(settings.pictographFontFamily());
-    overlaySettings.setMinimumFontSize(settings.minimumFontSize());
-    overlaySettings.setMinimumLogicalFontSize(settings.minimumLogicalFontSize());
-    overlaySettings.setMediaEnabled(false);
-    overlaySettings.setScriptEnabled(true);
-    overlaySettings.setPluginsEnabled(false);
-
-    Frame& frame = m_overlayPage->mainFrame();
-    frame.setView(FrameView::create(frame));
-    frame.init();
-    FrameLoader& loader = frame.loader();
-    frame.view()->setCanHaveScrollbars(false);
-    frame.view()->setTransparent(true);
-    ASSERT(loader.activeDocumentLoader());
-    auto& writer = loader.activeDocumentLoader()->writer();
-    writer.setMIMEType("text/html");
-    writer.begin();
-    writer.insertDataSynchronously(String(reinterpret_cast<const char*>(InspectorOverlayPage_html), sizeof(InspectorOverlayPage_html)));
-    writer.end();
-
-#if OS(WINDOWS)
-    evaluateInOverlay("setPlatform", "windows");
-#elif OS(MAC_OS_X)
-    evaluateInOverlay("setPlatform", "mac");
-#elif OS(UNIX)
-    evaluateInOverlay("setPlatform", "linux");
-#endif
-
-    return m_overlayPage.get();
-#endif
-}
-
-void InspectorOverlay::forcePaint()
-{
-    // This overlay page is very weird and doesn't automatically paint. We have to force paints manually.
-    m_client->highlight();
-}
+    const Color elementTitleBackgroundColor(255, 255, 194);
+    context.setFillColor(elementTitleBackgroundColor);
 
-void InspectorOverlay::reset(const IntSize& viewportSize, const IntPoint& scrollOffset)
-{
-    auto configObject = Inspector::Protocol::OverlayTypes::OverlayConfiguration::create()
-        .setDeviceScaleFactor(m_page.deviceScaleFactor())
-        .setViewportSize(buildObjectForSize(viewportSize))
-        .setPageScaleFactor(m_page.pageScaleFactor())
-        .setPageZoomFactor(m_page.mainFrame().pageZoomFactor())
-        .setScrollOffset(buildObjectForPoint(scrollOffset))
-        .setContentInset(buildObjectForSize(IntSize(0, m_page.mainFrame().view()->topContentInset(ScrollView::TopContentInsetType::WebCoreOrPlatformContentInset))))
-        .setShowRulers(m_showRulers)
-        .release();
-    evaluateInOverlay("reset", WTFMove(configObject));
-}
+    context.fillPath(path);
 
-static void evaluateCommandInOverlay(Page* page, Ref<JSON::Array>&& command)
-{
-    if (!page)
-        return;
+    context.setStrokeThickness(elementDataBorderSize);
 
-    page->mainFrame().script().evaluate(ScriptSourceCode(makeString("dispatch(", command->toJSONString(), ')')));
-}
+    const Color elementTitleBorderColor(128, 128, 128);
+    context.setStrokeColor(elementTitleBorderColor);
 
-void InspectorOverlay::evaluateInOverlay(const String& method)
-{
-    Ref<JSON::Array> command = JSON::Array::create();
-    command->pushString(method);
+    context.strokePath(path);
 
-    evaluateCommandInOverlay(overlayPage(), WTFMove(command));
-}
+    float textPositionX = boxX + elementDataSpacing;
+    float textPositionY = boxY - (elementDataSpacing / 2.0f) + fontHeight;
+    const auto drawText = [&] (const String& text, const Color& color) {
+        if (text.isEmpty())
+            return;
 
-void InspectorOverlay::evaluateInOverlay(const String& method, const String& argument)
-{
-    Ref<JSON::Array> command = JSON::Array::create();
-    command->pushString(method);
-    command->pushString(argument);
+        context.setFillColor(color);
+        textPositionX += context.drawText(font, TextRun(text), { textPositionX, textPositionY });
+    };
 
-    evaluateCommandInOverlay(overlayPage(), WTFMove(command));
-}
+    drawText(elementTagName, Color(136, 18, 128)); // Keep this in sync with XMLViewer.css (.tag)
+    drawText(elementIDValue, Color(26, 26, 166)); // Keep this in sync with XMLViewer.css (.attribute-value)
+    drawText(elementClassValue, Color(153, 69, 0)); // Keep this in sync with XMLViewer.css (.attribute-name)
+    drawText(elementPseudoType, Color(136, 18, 128)); // Keep this in sync with XMLViewer.css (.tag)
+    drawText(" "_s, Color::black);
+    drawText(elementWidth, Color::black);
+    drawText("px"_s, Color::darkGray);
+    drawText(" "_s, Color::darkGray);
+    drawText(makeString(multiplicationSign), Color::darkGray);
+    drawText(" "_s, Color::darkGray);
+    drawText(elementHeight, Color::black);
+    drawText("px"_s, Color::darkGray);
 
-void InspectorOverlay::evaluateInOverlay(const String& method, RefPtr<JSON::Value>&& argument)
-{
-    Ref<JSON::Array> command = JSON::Array::create();
-    command->pushString(method);
-    command->pushValue(WTFMove(argument));
+    if (hasSecondLine) {
+        textPositionX = boxX + elementDataSpacing;
+        textPositionY += fontHeight;
 
-    evaluateCommandInOverlay(overlayPage(), WTFMove(command));
-}
+        drawText("Role"_s, Color(170, 13, 145));
+        drawText(" "_s, Color::black);
+        drawText(elementRole, Color::black);
+    }
 
-void InspectorOverlay::freePage()
-{
-    m_overlayPage = nullptr;
+    return path;
 }
 
 } // namespace WebCore
