<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/svg/properties/SVGAnimatedPropertyAccessorImpl.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2018-2019 Apple Inc.  All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;SVGAnimatedPropertyAccessor.h&quot;
 29 #include &quot;SVGAnimatedPropertyAnimatorImpl.h&quot;
 30 #include &quot;SVGAnimatedPropertyImpl.h&quot;
 31 #include &quot;SVGNames.h&quot;
 32 
 33 namespace WebCore {
 34 
 35 template&lt;typename OwnerType&gt;
 36 class SVGAnimatedAngleAccessor final : public SVGAnimatedPropertyAccessor&lt;OwnerType, SVGAnimatedAngle&gt; {
 37     using Base = SVGAnimatedPropertyAccessor&lt;OwnerType, SVGAnimatedAngle&gt;;
 38 
 39 public:
 40     using Base::Base;
 41     template&lt;Ref&lt;SVGAnimatedAngle&gt; OwnerType::*property&gt;
 42     constexpr static const SVGMemberAccessor&lt;OwnerType&gt;&amp; singleton() { return Base::template singleton&lt;SVGAnimatedAngleAccessor, property&gt;(); }
 43 };
 44 
 45 template&lt;typename OwnerType&gt;
 46 class SVGAnimatedBooleanAccessor final : public SVGAnimatedPropertyAccessor&lt;OwnerType, SVGAnimatedBoolean&gt; {
 47     using Base = SVGAnimatedPropertyAccessor&lt;OwnerType, SVGAnimatedBoolean&gt;;
 48     using Base::property;
 49 
 50 public:
 51     using Base::Base;
 52     template&lt;Ref&lt;SVGAnimatedBoolean&gt; OwnerType::*property&gt;
 53     constexpr static const SVGMemberAccessor&lt;OwnerType&gt;&amp; singleton() { return Base::template singleton&lt;SVGAnimatedBooleanAccessor, property&gt;(); }
 54 
 55 private:
 56     RefPtr&lt;SVGAttributeAnimator&gt; createAnimator(OwnerType&amp; owner, const QualifiedName&amp; attributeName, AnimationMode animationMode, CalcMode calcMode, bool isAccumulated, bool isAdditive) const final
 57     {
 58         return SVGAnimatedBooleanAnimator::create(attributeName, property(owner), animationMode, calcMode, isAccumulated, isAdditive);
 59     }
 60 
 61     void appendAnimatedInstance(OwnerType&amp; owner, SVGAttributeAnimator&amp; animator) const final
 62     {
 63         static_cast&lt;SVGAnimatedBooleanAnimator&amp;&gt;(animator).appendAnimatedInstance(property(owner));
 64     }
 65 };
 66 
 67 template&lt;typename OwnerType, typename EnumType&gt;
 68 class SVGAnimatedEnumerationAccessor final : public SVGAnimatedPropertyAccessor&lt;OwnerType, SVGAnimatedEnumeration&gt; {
 69     using Base = SVGAnimatedPropertyAccessor&lt;OwnerType, SVGAnimatedEnumeration&gt;;
 70     using Base::property;
 71 
 72 public:
 73     using Base::Base;
 74     template&lt;Ref&lt;SVGAnimatedEnumeration&gt; OwnerType::*property&gt;
 75     constexpr static const SVGMemberAccessor&lt;OwnerType&gt;&amp; singleton() { return Base::template singleton&lt;SVGAnimatedEnumerationAccessor, property&gt;(); }
 76 
 77 private:
 78     RefPtr&lt;SVGAttributeAnimator&gt; createAnimator(OwnerType&amp; owner, const QualifiedName&amp; attributeName, AnimationMode animationMode, CalcMode calcMode, bool isAccumulated, bool isAdditive) const final
 79     {
 80         return SVGAnimatedEnumerationAnimator&lt;EnumType&gt;::create(attributeName, property(owner), animationMode, calcMode, isAccumulated, isAdditive);
 81     }
 82 
 83     void appendAnimatedInstance(OwnerType&amp; owner, SVGAttributeAnimator&amp; animator) const final
 84     {
 85         static_cast&lt;SVGAnimatedEnumerationAnimator&lt;EnumType&gt;&amp;&gt;(animator).appendAnimatedInstance(property(owner));
 86     }
 87 };
 88 
 89 template&lt;typename OwnerType&gt;
 90 class SVGAnimatedIntegerAccessor final : public SVGAnimatedPropertyAccessor&lt;OwnerType, SVGAnimatedInteger&gt; {
 91     using Base = SVGAnimatedPropertyAccessor&lt;OwnerType, SVGAnimatedInteger&gt;;
 92 
 93 public:
 94     using Base::Base;
 95     using Base::property;
 96     template&lt;Ref&lt;SVGAnimatedInteger&gt; OwnerType::*property&gt;
 97     constexpr static const SVGMemberAccessor&lt;OwnerType&gt;&amp; singleton() { return Base::template singleton&lt;SVGAnimatedIntegerAccessor, property&gt;(); }
 98 
 99 private:
100     RefPtr&lt;SVGAttributeAnimator&gt; createAnimator(OwnerType&amp; owner, const QualifiedName&amp; attributeName, AnimationMode animationMode, CalcMode calcMode, bool isAccumulated, bool isAdditive) const final
101     {
102         return SVGAnimatedIntegerAnimator::create(attributeName, property(owner), animationMode, calcMode, isAccumulated, isAdditive);
103     }
104 
105     void appendAnimatedInstance(OwnerType&amp; owner, SVGAttributeAnimator&amp; animator) const final
106     {
107         static_cast&lt;SVGAnimatedIntegerAnimator&amp;&gt;(animator).appendAnimatedInstance(property(owner));
108     }
109 };
110 
111 template&lt;typename OwnerType&gt;
112 class SVGAnimatedLengthAccessor final : public SVGAnimatedPropertyAccessor&lt;OwnerType, SVGAnimatedLength&gt; {
113     using Base = SVGAnimatedPropertyAccessor&lt;OwnerType, SVGAnimatedLength&gt;;
114     using Base::property;
115 
116 public:
117     using Base::Base;
118     template&lt;Ref&lt;SVGAnimatedLength&gt; OwnerType::*property&gt;
119     constexpr static const SVGMemberAccessor&lt;OwnerType&gt;&amp; singleton() { return Base::template singleton&lt;SVGAnimatedLengthAccessor, property&gt;(); }
120 
121 private:
122     bool isAnimatedLength() const override { return true; }
123 
124     RefPtr&lt;SVGAttributeAnimator&gt; createAnimator(OwnerType&amp; owner, const QualifiedName&amp; attributeName, AnimationMode animationMode, CalcMode calcMode, bool isAccumulated, bool isAdditive) const final
125     {
126         SVGLengthMode lengthMode = property(owner)-&gt;baseVal()-&gt;value().unitMode();
127         return SVGAnimatedLengthAnimator::create(attributeName, property(owner), animationMode, calcMode, isAccumulated, isAdditive, lengthMode);
128     }
129 
130     void appendAnimatedInstance(OwnerType&amp; owner, SVGAttributeAnimator&amp; animator) const final
131     {
132         static_cast&lt;SVGAnimatedLengthAnimator&amp;&gt;(animator).appendAnimatedInstance(property(owner));
133     }
134 };
135 
136 template&lt;typename OwnerType&gt;
137 class SVGAnimatedLengthListAccessor final : public SVGAnimatedPropertyAccessor&lt;OwnerType, SVGAnimatedLengthList&gt; {
138     using Base = SVGAnimatedPropertyAccessor&lt;OwnerType, SVGAnimatedLengthList&gt;;
139     using Base::property;
140 
141 public:
142     using Base::Base;
143     template&lt;Ref&lt;SVGAnimatedLengthList&gt; OwnerType::*property&gt;
144     constexpr static const SVGMemberAccessor&lt;OwnerType&gt;&amp; singleton() { return Base::template singleton&lt;SVGAnimatedLengthListAccessor, property&gt;(); }
145 
146 private:
147     RefPtr&lt;SVGAttributeAnimator&gt; createAnimator(OwnerType&amp; owner, const QualifiedName&amp; attributeName, AnimationMode animationMode, CalcMode calcMode, bool isAccumulated, bool isAdditive) const final
148     {
149         return SVGAnimatedLengthListAnimator::create(attributeName, property(owner), animationMode, calcMode, isAccumulated, isAdditive, LengthModeWidth);
150     }
151 
152     void appendAnimatedInstance(OwnerType&amp; owner, SVGAttributeAnimator&amp; animator) const final
153     {
154         static_cast&lt;SVGAnimatedLengthListAnimator&amp;&gt;(animator).appendAnimatedInstance(property(owner));
155     }
156 };
157 
158 template&lt;typename OwnerType&gt;
159 class SVGAnimatedNumberAccessor final : public SVGAnimatedPropertyAccessor&lt;OwnerType, SVGAnimatedNumber&gt; {
160     using Base = SVGAnimatedPropertyAccessor&lt;OwnerType, SVGAnimatedNumber&gt;;
161 
162 public:
163     using Base::Base;
164     using Base::property;
165     template&lt;Ref&lt;SVGAnimatedNumber&gt; OwnerType::*property&gt;
166     constexpr static const SVGMemberAccessor&lt;OwnerType&gt;&amp; singleton() { return Base::template singleton&lt;SVGAnimatedNumberAccessor, property&gt;(); }
167 
168 private:
169     RefPtr&lt;SVGAttributeAnimator&gt; createAnimator(OwnerType&amp; owner, const QualifiedName&amp; attributeName, AnimationMode animationMode, CalcMode calcMode, bool isAccumulated, bool isAdditive) const final
170     {
171         return SVGAnimatedNumberAnimator::create(attributeName, property(owner), animationMode, calcMode, isAccumulated, isAdditive);
172     }
173 
174     void appendAnimatedInstance(OwnerType&amp; owner, SVGAttributeAnimator&amp; animator) const final
175     {
176         static_cast&lt;SVGAnimatedNumberAnimator&amp;&gt;(animator).appendAnimatedInstance(property(owner));
177     }
178 };
179 
180 template&lt;typename OwnerType&gt;
181 class SVGAnimatedNumberListAccessor final : public SVGAnimatedPropertyAccessor&lt;OwnerType, SVGAnimatedNumberList&gt; {
182     using Base = SVGAnimatedPropertyAccessor&lt;OwnerType, SVGAnimatedNumberList&gt;;
183     using Base::property;
184 
185 public:
186     using Base::Base;
187     template&lt;Ref&lt;SVGAnimatedNumberList&gt; OwnerType::*property&gt;
188     constexpr static const SVGMemberAccessor&lt;OwnerType&gt;&amp; singleton() { return Base::template singleton&lt;SVGAnimatedNumberListAccessor, property&gt;(); }
189 
190 private:
191     RefPtr&lt;SVGAttributeAnimator&gt; createAnimator(OwnerType&amp; owner, const QualifiedName&amp; attributeName, AnimationMode animationMode, CalcMode calcMode, bool isAccumulated, bool isAdditive) const final
192     {
193         return SVGAnimatedNumberListAnimator::create(attributeName, property(owner), animationMode, calcMode, isAccumulated, isAdditive);
194     }
195 
196     void appendAnimatedInstance(OwnerType&amp; owner, SVGAttributeAnimator&amp; animator) const final
197     {
198         static_cast&lt;SVGAnimatedNumberListAnimator&amp;&gt;(animator).appendAnimatedInstance(property(owner));
199     }
200 };
201 
202 template&lt;typename OwnerType&gt;
203 class SVGAnimatedPathSegListAccessor final : public SVGAnimatedPropertyAccessor&lt;OwnerType, SVGAnimatedPathSegList&gt; {
204     using Base = SVGAnimatedPropertyAccessor&lt;OwnerType, SVGAnimatedPathSegList&gt;;
205     using Base::property;
206 
207 public:
208     using Base::Base;
209     template&lt;Ref&lt;SVGAnimatedPathSegList&gt; OwnerType::*property&gt;
210     constexpr static const SVGMemberAccessor&lt;OwnerType&gt;&amp; singleton() { return Base::template singleton&lt;SVGAnimatedPathSegListAccessor, property&gt;(); }
211 
212 private:
213     RefPtr&lt;SVGAttributeAnimator&gt; createAnimator(OwnerType&amp; owner, const QualifiedName&amp; attributeName, AnimationMode animationMode, CalcMode calcMode, bool isAccumulated, bool isAdditive) const final
214     {
215         return SVGAnimatedPathSegListAnimator::create(attributeName, property(owner), animationMode, calcMode, isAccumulated, isAdditive);
216     }
217 
218     void appendAnimatedInstance(OwnerType&amp; owner, SVGAttributeAnimator&amp; animator) const final
219     {
220         static_cast&lt;SVGAnimatedPathSegListAnimator&amp;&gt;(animator).appendAnimatedInstance(property(owner));
221     }
222 };
223 
224 template&lt;typename OwnerType&gt;
225 class SVGAnimatedPointListAccessor final : public SVGAnimatedPropertyAccessor&lt;OwnerType, SVGAnimatedPointList&gt; {
226     using Base = SVGAnimatedPropertyAccessor&lt;OwnerType, SVGAnimatedPointList&gt;;
227     using Base::property;
228 
229 public:
230     using Base::Base;
231     template&lt;Ref&lt;SVGAnimatedPointList&gt; OwnerType::*property&gt;
232     constexpr static const SVGMemberAccessor&lt;OwnerType&gt;&amp; singleton() { return Base::template singleton&lt;SVGAnimatedPointListAccessor, property&gt;(); }
233 
234 private:
235     RefPtr&lt;SVGAttributeAnimator&gt; createAnimator(OwnerType&amp; owner, const QualifiedName&amp; attributeName, AnimationMode animationMode, CalcMode calcMode, bool isAccumulated, bool isAdditive) const final
236     {
237         return SVGAnimatedPointListAnimator::create(attributeName, property(owner), animationMode, calcMode, isAccumulated, isAdditive);
238     }
239 
240     void appendAnimatedInstance(OwnerType&amp; owner, SVGAttributeAnimator&amp; animator) const final
241     {
242         static_cast&lt;SVGAnimatedPointListAnimator&amp;&gt;(animator).appendAnimatedInstance(property(owner));
243     }
244 };
245 
246 template&lt;typename OwnerType&gt;
247 class SVGAnimatedOrientTypeAccessor final : public SVGAnimatedPropertyAccessor&lt;OwnerType, SVGAnimatedOrientType&gt; {
248     using Base = SVGAnimatedPropertyAccessor&lt;OwnerType, SVGAnimatedOrientType&gt;;
249 
250 public:
251     using Base::Base;
252     template&lt;Ref&lt;SVGAnimatedOrientType&gt; OwnerType::*property&gt;
253     constexpr static const SVGMemberAccessor&lt;OwnerType&gt;&amp; singleton() {return Base::template singleton&lt;SVGAnimatedOrientTypeAccessor, property&gt;(); }
254 };
255 
256 template&lt;typename OwnerType&gt;
257 class SVGAnimatedPreserveAspectRatioAccessor final : public SVGAnimatedPropertyAccessor&lt;OwnerType, SVGAnimatedPreserveAspectRatio&gt; {
258     using Base = SVGAnimatedPropertyAccessor&lt;OwnerType, SVGAnimatedPreserveAspectRatio&gt;;
259     using Base::property;
260 
261 public:
262     using Base::Base;
263     template&lt;Ref&lt;SVGAnimatedPreserveAspectRatio&gt; OwnerType::*property&gt;
264     constexpr static const SVGMemberAccessor&lt;OwnerType&gt;&amp; singleton() { return Base::template singleton&lt;SVGAnimatedPreserveAspectRatioAccessor, property&gt;(); }
265 
266 private:
267     RefPtr&lt;SVGAttributeAnimator&gt; createAnimator(OwnerType&amp; owner, const QualifiedName&amp; attributeName, AnimationMode animationMode, CalcMode calcMode, bool isAccumulated, bool isAdditive) const final
268     {
269         return SVGAnimatedPreserveAspectRatioAnimator::create(attributeName, property(owner), animationMode, calcMode, isAccumulated, isAdditive);
270     }
271 
272     void appendAnimatedInstance(OwnerType&amp; owner, SVGAttributeAnimator&amp; animator) const final
273     {
274         static_cast&lt;SVGAnimatedPreserveAspectRatioAnimator&amp;&gt;(animator).appendAnimatedInstance(property(owner));
275     }
276 };
277 
278 template&lt;typename OwnerType&gt;
279 class SVGAnimatedRectAccessor final : public SVGAnimatedPropertyAccessor&lt;OwnerType, SVGAnimatedRect&gt; {
280     using Base = SVGAnimatedPropertyAccessor&lt;OwnerType, SVGAnimatedRect&gt;;
281     using Base::property;
282 
283 public:
284     using Base::Base;
285     template&lt;Ref&lt;SVGAnimatedRect&gt; OwnerType::*property&gt;
286     constexpr static const SVGMemberAccessor&lt;OwnerType&gt;&amp; singleton() { return Base::template singleton&lt;SVGAnimatedRectAccessor, property&gt;(); }
287 
288 private:
289     RefPtr&lt;SVGAttributeAnimator&gt; createAnimator(OwnerType&amp; owner, const QualifiedName&amp; attributeName, AnimationMode animationMode, CalcMode calcMode, bool isAccumulated, bool isAdditive) const final
290     {
291         return SVGAnimatedRectAnimator::create(attributeName, property(owner), animationMode, calcMode, isAccumulated, isAdditive);
292     }
293 
294     void appendAnimatedInstance(OwnerType&amp; owner, SVGAttributeAnimator&amp; animator) const final
295     {
296         static_cast&lt;SVGAnimatedRectAnimator&amp;&gt;(animator).appendAnimatedInstance(property(owner));
297     }
298 };
299 
300 template&lt;typename OwnerType&gt;
301 class SVGAnimatedStringAccessor final : public SVGAnimatedPropertyAccessor&lt;OwnerType, SVGAnimatedString&gt; {
302     using Base = SVGAnimatedPropertyAccessor&lt;OwnerType, SVGAnimatedString&gt;;
303     using Base::property;
304 
305 public:
306     using Base::Base;
307     template&lt;Ref&lt;SVGAnimatedString&gt; OwnerType::*property&gt;
308     constexpr static const SVGMemberAccessor&lt;OwnerType&gt;&amp; singleton() { return Base::template singleton&lt;SVGAnimatedStringAccessor, property&gt;(); }
309 
310 private:
311     RefPtr&lt;SVGAttributeAnimator&gt; createAnimator(OwnerType&amp; owner, const QualifiedName&amp; attributeName, AnimationMode animationMode, CalcMode calcMode, bool isAccumulated, bool isAdditive) const final
312     {
313         return SVGAnimatedStringAnimator::create(attributeName, property(owner), animationMode, calcMode, isAccumulated, isAdditive);
314     }
315 
316     void appendAnimatedInstance(OwnerType&amp; owner, SVGAttributeAnimator&amp; animator) const final
317     {
318         static_cast&lt;SVGAnimatedStringAnimator&amp;&gt;(animator).appendAnimatedInstance(property(owner));
319     }
320 };
321 
322 template&lt;typename OwnerType&gt;
323 class SVGAnimatedTransformListAccessor final : public SVGAnimatedPropertyAccessor&lt;OwnerType, SVGAnimatedTransformList&gt; {
324     using Base = SVGAnimatedPropertyAccessor&lt;OwnerType, SVGAnimatedTransformList&gt;;
325     using Base::property;
326 
327 public:
328     using Base::Base;
329     template&lt;Ref&lt;SVGAnimatedTransformList&gt; OwnerType::*property&gt;
330     constexpr static const SVGMemberAccessor&lt;OwnerType&gt;&amp; singleton() { return Base::template singleton&lt;SVGAnimatedTransformListAccessor, property&gt;(); }
331 
332 private:
333     RefPtr&lt;SVGAttributeAnimator&gt; createAnimator(OwnerType&amp; owner, const QualifiedName&amp; attributeName, AnimationMode animationMode, CalcMode calcMode, bool isAccumulated, bool isAdditive) const final
334     {
335         return SVGAnimatedTransformListAnimator::create(attributeName, property(owner), animationMode, calcMode, isAccumulated, isAdditive);
336     }
337 
338     void appendAnimatedInstance(OwnerType&amp; owner, SVGAttributeAnimator&amp; animator) const final
339     {
340         static_cast&lt;SVGAnimatedTransformListAnimator&amp;&gt;(animator).appendAnimatedInstance(property(owner));
341     }
342 };
343 
344 }
    </pre>
  </body>
</html>