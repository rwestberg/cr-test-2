<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WTF/wtf/Optional.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 // Copyright (C) 2011 - 2012 Andrzej Krzemienski.
   2 //
   3 // Use, modification, and distribution is subject to the Boost Software
   4 // License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
   5 // http://www.boost.org/LICENSE_1_0.txt)
   6 //
   7 // The idea and interface is based on Boost.Optional library
   8 // authored by Fernando Luis Cacciola Carballal
   9 //
  10 // Boost Software License - Version 1.0 - August 17th, 2003
  11 //
  12 // Permission is hereby granted, free of charge, to any person or organization
  13 // obtaining a copy of the software and accompanying documentation covered by
  14 // this license (the &quot;Software&quot;) to use, reproduce, display, distribute,
  15 // execute, and transmit the Software, and to prepare derivative works of the
  16 // Software, and to permit third-parties to whom the Software is furnished to
  17 // do so, all subject to the following:
  18 //
  19 // The copyright notices in the Software and this entire statement, including
  20 // the above license grant, this restriction and the following disclaimer,
  21 // must be included in all copies of the Software, in whole or in part, and
  22 // all derivative works of the Software, unless such copies or derivative
  23 // works are solely in the form of machine-executable object code generated by
  24 // a source language processor.
  25 //
  26 // THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  27 // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  28 // FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
  29 // SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
  30 // FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
  31 // ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  32 // DEALINGS IN THE SOFTWARE.
  33 
  34 // Copied from https://github.com/akrzemi1/Optional (8456c3923776b33b4ae852734273fe934c3e4e61)
  35 
  36 // Modified to make it compile with exceptions disabled.
  37 
  38 #pragma once
  39 
  40 # include &lt;utility&gt;
  41 # include &lt;type_traits&gt;
  42 # include &lt;initializer_list&gt;
  43 # include &lt;cassert&gt;
  44 # include &lt;string&gt;
  45 # include &lt;stdexcept&gt;
  46 # include &lt;wtf/Assertions.h&gt;
  47 # include &lt;wtf/Compiler.h&gt;
  48 # include &lt;wtf/StdLibExtras.h&gt;
  49 
  50 # define TR2_OPTIONAL_REQUIRES(...) typename std::enable_if&lt;__VA_ARGS__::value, bool&gt;::type = false
  51 
  52 # if defined __GNUC__ // NOTE: GNUC is also defined for Clang
  53 #   if (__GNUC__ == 4) &amp;&amp; (__GNUC_MINOR__ &gt;= 8)
  54 #     define TR2_OPTIONAL_GCC_4_8_AND_HIGHER___
  55 #   elif (__GNUC__ &gt; 4)
  56 #     define TR2_OPTIONAL_GCC_4_8_AND_HIGHER___
  57 #   endif
  58 #
  59 #   if (__GNUC__ == 4) &amp;&amp; (__GNUC_MINOR__ &gt;= 7)
  60 #     define TR2_OPTIONAL_GCC_4_7_AND_HIGHER___
  61 #   elif (__GNUC__ &gt; 4)
  62 #     define TR2_OPTIONAL_GCC_4_7_AND_HIGHER___
  63 #   endif
  64 #
  65 #   if (__GNUC__ == 4) &amp;&amp; (__GNUC_MINOR__ == 8) &amp;&amp; (__GNUC_PATCHLEVEL__ &gt;= 1)
  66 #     define TR2_OPTIONAL_GCC_4_8_1_AND_HIGHER___
  67 #   elif (__GNUC__ == 4) &amp;&amp; (__GNUC_MINOR__ &gt;= 9)
  68 #     define TR2_OPTIONAL_GCC_4_8_1_AND_HIGHER___
  69 #   elif (__GNUC__ &gt; 4)
  70 #     define TR2_OPTIONAL_GCC_4_8_1_AND_HIGHER___
  71 #   endif
  72 # endif
  73 #
  74 # if defined __clang_major__
  75 #   if (__clang_major__ == 3 &amp;&amp; __clang_minor__ &gt;= 5)
  76 #     define TR2_OPTIONAL_CLANG_3_5_AND_HIGHTER_
  77 #   elif (__clang_major__ &gt; 3)
  78 #     define TR2_OPTIONAL_CLANG_3_5_AND_HIGHTER_
  79 #   endif
  80 #   if defined TR2_OPTIONAL_CLANG_3_5_AND_HIGHTER_
  81 #     define TR2_OPTIONAL_CLANG_3_4_2_AND_HIGHER_
  82 #   elif (__clang_major__ == 3 &amp;&amp; __clang_minor__ == 4 &amp;&amp; __clang_patchlevel__ &gt;= 2)
  83 #     define TR2_OPTIONAL_CLANG_3_4_2_AND_HIGHER_
  84 #   endif
  85 # endif
  86 #
  87 # if defined _MSC_VER
  88 #   if (_MSC_VER &gt;= 1900)
  89 #     define TR2_OPTIONAL_MSVC_2015_AND_HIGHER___
  90 #   endif
  91 # endif
  92 
  93 # if defined __clang__
  94 #   if (__clang_major__ &gt; 2) || (__clang_major__ == 2) &amp;&amp; (__clang_minor__ &gt;= 9)
  95 #     define OPTIONAL_HAS_THIS_RVALUE_REFS 1
  96 #   else
  97 #     define OPTIONAL_HAS_THIS_RVALUE_REFS 0
  98 #   endif
  99 # elif defined TR2_OPTIONAL_GCC_4_8_1_AND_HIGHER___
 100 #   define OPTIONAL_HAS_THIS_RVALUE_REFS 1
 101 # elif defined TR2_OPTIONAL_MSVC_2015_AND_HIGHER___
 102 #   define OPTIONAL_HAS_THIS_RVALUE_REFS 1
 103 # else
 104 #   define OPTIONAL_HAS_THIS_RVALUE_REFS 0
 105 # endif
 106 
 107 
 108 # if defined TR2_OPTIONAL_GCC_4_8_1_AND_HIGHER___
 109 #   define OPTIONAL_HAS_CONSTEXPR_INIT_LIST 1
 110 #   define OPTIONAL_CONSTEXPR_INIT_LIST constexpr
 111 # else
 112 #   define OPTIONAL_HAS_CONSTEXPR_INIT_LIST 0
 113 #   define OPTIONAL_CONSTEXPR_INIT_LIST
 114 # endif
 115 
 116 # // In C++11 constexpr implies const, so we need to make non-const members also non-constexpr
 117 # if (defined __cplusplus) &amp;&amp; (__cplusplus == 201103L)
 118 #   define OPTIONAL_MUTABLE_CONSTEXPR
 119 # else
 120 #   define OPTIONAL_MUTABLE_CONSTEXPR constexpr
 121 # endif
 122 
 123 #if COMPILER_SUPPORTS(EXCEPTIONS)
 124 #define __THROW_EXCEPTION(__exception) throw __exception;
 125 #define __NOEXCEPT noexcept
 126 #define __NOEXCEPT_(__exception) noexcept(__exception)
 127 #else
 128 #define __THROW_EXCEPTION(__exception) do { (void)__exception; CRASH(); } while (0);
 129 #define __NOEXCEPT
 130 #define __NOEXCEPT_(...)
 131 #endif
 132 
 133 namespace WTF {
 134 namespace detail_ {
 135 
 136 // NOTE: All our target compilers support is_trivially_destructible.
 137 // // BEGIN workaround for missing is_trivially_destructible
 138 // # if defined TR2_OPTIONAL_GCC_4_8_AND_HIGHER___
 139 //     // leave it: it is already there
 140 // # elif defined TR2_OPTIONAL_CLANG_3_4_2_AND_HIGHER_
 141 //     // leave it: it is already there
 142 // # elif defined TR2_OPTIONAL_MSVC_2015_AND_HIGHER___
 143 //     // leave it: it is already there
 144 // # elif defined TR2_OPTIONAL_DISABLE_EMULATION_OF_TYPE_TRAITS
 145 //     // leave it: the user doesn&#39;t want it
 146 // # else
 147 //     template &lt;typename T&gt;
 148 //     using is_trivially_destructible = std::has_trivial_destructor&lt;T&gt;;
 149 // # endif
 150 // // END workaround for missing is_trivially_destructible
 151 
 152 #if COMPILER_SUPPORTS(EXCEPTIONS)
 153 # if defined(TR2_OPTIONAL_GCC_4_7_AND_HIGHER___) || defined(TR2_OPTIONAL_CLANG_3_4_2_AND_HIGHER_) || defined(TR2_OPTIONAL_MSVC_2015_AND_HIGHER___)
 154     // leave it; our metafunctions are already defined.
 155     template &lt;typename T&gt;
 156     using is_nothrow_move_constructible = std::is_nothrow_move_constructible&lt;T&gt;;
 157     template &lt;typename T&gt;
 158     using is_nothrow_move_assignable = std::is_nothrow_move_assignable&lt;T&gt;;
 159 # elif defined TR2_OPTIONAL_DISABLE_EMULATION_OF_TYPE_TRAITS
 160     // leave it: the user doesn&#39;t want it
 161 # else
 162 
 163 
 164 // workaround for missing traits in GCC and CLANG
 165 template &lt;class T&gt;
 166 struct is_nothrow_move_constructible
 167 {
 168   constexpr static bool value = std::is_nothrow_constructible&lt;T, T&amp;&amp;&gt;::value;
 169 };
 170 
 171 
 172 template &lt;class T, class U&gt;
 173 struct is_assignable
 174 {
 175   template &lt;class X, class Y&gt;
 176   constexpr static bool has_assign(...) { return false; }
 177 
 178   template &lt;class X, class Y, size_t S = sizeof((std::declval&lt;X&gt;() = std::declval&lt;Y&gt;(), true)) &gt;
 179   // the comma operator is necessary for the cases where operator= returns void
 180   constexpr static bool has_assign(bool) { return true; }
 181 
 182   constexpr static bool value = has_assign&lt;T, U&gt;(true);
 183 };
 184 
 185 
 186 template &lt;class T&gt;
 187 struct is_nothrow_move_assignable
 188 {
 189   template &lt;class X, bool has_any_move_assign&gt;
 190   struct has_nothrow_move_assign {
 191     constexpr static bool value = false;
 192   };
 193 
 194   template &lt;class X&gt;
 195   struct has_nothrow_move_assign&lt;X, true&gt; {
 196     constexpr static bool value = __NOEXCEPT_( std::declval&lt;X&amp;&gt;() = std::declval&lt;X&amp;&amp;&gt;() );
 197   };
 198 
 199   constexpr static bool value = has_nothrow_move_assign&lt;T, is_assignable&lt;T&amp;, T&amp;&amp;&gt;::value&gt;::value;
 200 };
 201 // end workaround
 202 
 203 
 204 # endif
 205 #endif
 206 
 207 } // namespace detail_
 208 
 209 // 20.5.4, Optional for object types
 210 template &lt;class T&gt; class Optional;
 211 
 212 // 20.5.5, Optional for lvalue reference types
 213 template &lt;class T&gt; class Optional&lt;T&amp;&gt;;
 214 
 215 namespace detail_ {
 216 
 217 // workaround: std utility functions aren&#39;t constexpr yet
 218 template &lt;class T&gt; constexpr T&amp;&amp; constexpr_forward(typename std::remove_reference&lt;T&gt;::type&amp; t) __NOEXCEPT
 219 {
 220   return static_cast&lt;T&amp;&amp;&gt;(t);
 221 }
 222 
 223 template &lt;class T&gt; constexpr T&amp;&amp; constexpr_forward(typename std::remove_reference&lt;T&gt;::type&amp;&amp; t) __NOEXCEPT
 224 {
 225     static_assert(!std::is_lvalue_reference&lt;T&gt;::value, &quot;!!&quot;);
 226     return static_cast&lt;T&amp;&amp;&gt;(t);
 227 }
 228 
 229 template &lt;class T&gt; constexpr typename std::remove_reference&lt;T&gt;::type&amp;&amp; constexpr_move(T&amp;&amp; t) __NOEXCEPT
 230 {
 231     return static_cast&lt;typename std::remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);
 232 }
 233 
 234 
 235 // static_addressof: a constexpr version of addressof
 236 template &lt;typename T&gt;
 237 struct has_overloaded_addressof
 238 {
 239   template &lt;class X&gt;
 240   constexpr static bool has_overload(...) { return false; }
 241 
 242   template &lt;class X, size_t S = sizeof(std::declval&lt;X&amp;&gt;().operator&amp;()) &gt;
 243   constexpr static bool has_overload(bool) { return true; }
 244 
 245   constexpr static bool value = has_overload&lt;T&gt;(true);
 246 };
 247 
 248 template &lt;typename T, TR2_OPTIONAL_REQUIRES(!has_overloaded_addressof&lt;T&gt;)&gt;
 249 constexpr T* static_addressof(T&amp; ref)
 250 {
 251   return &amp;ref;
 252 }
 253 
 254 template &lt;typename T, TR2_OPTIONAL_REQUIRES(has_overloaded_addressof&lt;T&gt;)&gt;
 255 T* static_addressof(T&amp; ref)
 256 {
 257   return std::addressof(ref);
 258 }
 259 
 260 
 261 // the call to convert&lt;A&gt;(b) has return type A and converts b to type A iff b decltype(b) is implicitly convertible to A
 262 template &lt;class U&gt;
 263 constexpr U convert(U v) { return v; }
 264 
 265 } // namespace detail
 266 
 267 
 268 constexpr struct trivial_init_t{} trivial_init{};
 269 
 270 
 271 // 20.5.7, Disengaged state indicator
 272 struct nullopt_t
 273 {
 274   struct init{};
 275   constexpr explicit nullopt_t(init){}
 276 };
 277 constexpr nullopt_t nullopt{nullopt_t::init()};
 278 
 279 
 280 template &lt;class T&gt;
 281 union storage_t
 282 {
 283   unsigned char dummy_;
 284   T value_;
 285 
 286   constexpr storage_t( trivial_init_t ) __NOEXCEPT : dummy_() {};
 287 
 288   template &lt;class... Args&gt;
 289   constexpr storage_t( Args&amp;&amp;... args ) : value_(detail_::constexpr_forward&lt;Args&gt;(args)...) {}
 290 
 291   ~storage_t(){}
 292 };
 293 
 294 
 295 template &lt;class T&gt;
 296 union constexpr_storage_t
 297 {
 298     unsigned char dummy_;
 299     T value_;
 300 
 301     constexpr constexpr_storage_t( trivial_init_t ) __NOEXCEPT : dummy_() {};
 302 
 303     template &lt;class... Args&gt;
 304     constexpr constexpr_storage_t( Args&amp;&amp;... args ) : value_(detail_::constexpr_forward&lt;Args&gt;(args)...) {}
 305 
 306     ~constexpr_storage_t() = default;
 307 };
 308 
 309 
 310 template &lt;class T&gt;
 311 struct Optional_base
 312 {
 313     bool init_;
 314     storage_t&lt;T&gt; storage_;
 315 
 316     constexpr Optional_base() __NOEXCEPT : init_(false), storage_(trivial_init) {};
 317 
 318     explicit constexpr Optional_base(const T&amp; v) : init_(true), storage_(v) {}
 319 
 320     explicit constexpr Optional_base(T&amp;&amp; v) : init_(true), storage_(detail_::constexpr_move(v)) {}
 321 
 322     template &lt;class... Args&gt; explicit Optional_base(std::in_place_t, Args&amp;&amp;... args)
 323         : init_(true), storage_(detail_::constexpr_forward&lt;Args&gt;(args)...) {}
 324 
 325     template &lt;class U, class... Args, TR2_OPTIONAL_REQUIRES(std::is_constructible&lt;T, std::initializer_list&lt;U&gt;&gt;)&gt;
 326     explicit Optional_base(std::in_place_t, std::initializer_list&lt;U&gt; il, Args&amp;&amp;... args)
 327         : init_(true), storage_(il, std::forward&lt;Args&gt;(args)...) {}
 328 
 329     ~Optional_base() { if (init_) storage_.value_.T::~T(); }
 330 };
 331 
 332 
 333 template &lt;class T&gt;
 334 struct constexpr_Optional_base
 335 {
 336     bool init_;
 337     constexpr_storage_t&lt;T&gt; storage_;
 338 
 339     constexpr constexpr_Optional_base() __NOEXCEPT : init_(false), storage_(trivial_init) {};
 340 
 341     explicit constexpr constexpr_Optional_base(const T&amp; v) : init_(true), storage_(v) {}
 342 
 343     explicit constexpr constexpr_Optional_base(T&amp;&amp; v) : init_(true), storage_(detail_::constexpr_move(v)) {}
 344 
 345     template &lt;class... Args&gt; explicit constexpr constexpr_Optional_base(std::in_place_t, Args&amp;&amp;... args)
 346       : init_(true), storage_(detail_::constexpr_forward&lt;Args&gt;(args)...) {}
 347 
 348     template &lt;class U, class... Args, TR2_OPTIONAL_REQUIRES(std::is_constructible&lt;T, std::initializer_list&lt;U&gt;&gt;)&gt;
 349     OPTIONAL_CONSTEXPR_INIT_LIST explicit constexpr_Optional_base(std::in_place_t, std::initializer_list&lt;U&gt; il, Args&amp;&amp;... args)
 350       : init_(true), storage_(il, std::forward&lt;Args&gt;(args)...) {}
 351 
 352     ~constexpr_Optional_base() = default;
 353 };
 354 
 355 template &lt;class T&gt;
 356 using OptionalBase = typename std::conditional&lt;
 357     std::is_trivially_destructible&lt;T&gt;::value,                          // if possible
 358     constexpr_Optional_base&lt;typename std::remove_const&lt;T&gt;::type&gt;, // use base with trivial destructor
 359     Optional_base&lt;typename std::remove_const&lt;T&gt;::type&gt;
 360 &gt;::type;
 361 
 362 
 363 
 364 template &lt;class T&gt;
 365 class Optional : private OptionalBase&lt;T&gt;
 366 {
 367   static_assert( !std::is_same&lt;typename std::decay&lt;T&gt;::type, nullopt_t&gt;::value, &quot;bad T&quot; );
 368   static_assert( !std::is_same&lt;typename std::decay&lt;T&gt;::type, std::in_place_t&gt;::value, &quot;bad T&quot; );
 369 
 370 
 371   constexpr bool initialized() const __NOEXCEPT { return OptionalBase&lt;T&gt;::init_; }
 372   typename std::remove_const&lt;T&gt;::type* dataptr() {  return std::addressof(OptionalBase&lt;T&gt;::storage_.value_); }
 373   constexpr const T* dataptr() const { return detail_::static_addressof(OptionalBase&lt;T&gt;::storage_.value_); }
 374 
 375 # if OPTIONAL_HAS_THIS_RVALUE_REFS == 1
 376   constexpr const T&amp; contained_val() const&amp; { return OptionalBase&lt;T&gt;::storage_.value_; }
 377   OPTIONAL_MUTABLE_CONSTEXPR T&amp;&amp; contained_val() &amp;&amp; { return std::move(OptionalBase&lt;T&gt;::storage_.value_); }
 378   OPTIONAL_MUTABLE_CONSTEXPR T&amp; contained_val() &amp; { return OptionalBase&lt;T&gt;::storage_.value_; }
 379 # else
 380   constexpr const T&amp; contained_val() const { return OptionalBase&lt;T&gt;::storage_.value_; }
 381   T&amp; contained_val() { return OptionalBase&lt;T&gt;::storage_.value_; }
 382 # endif
 383 
 384   void clear() __NOEXCEPT {
 385     if (initialized()) dataptr()-&gt;T::~T();
 386     OptionalBase&lt;T&gt;::init_ = false;
 387   }
 388 
 389   template &lt;class... Args&gt;
 390   void initialize(Args&amp;&amp;... args) __NOEXCEPT_(__NOEXCEPT_(T(std::forward&lt;Args&gt;(args)...)))
 391   {
 392     ASSERT(!OptionalBase&lt;T&gt;::init_);
 393     ::new (static_cast&lt;void*&gt;(dataptr())) T(std::forward&lt;Args&gt;(args)...);
 394     OptionalBase&lt;T&gt;::init_ = true;
 395   }
 396 
 397   template &lt;class U, class... Args&gt;
 398   void initialize(std::initializer_list&lt;U&gt; il, Args&amp;&amp;... args) __NOEXCEPT_(__NOEXCEPT_(T(il, std::forward&lt;Args&gt;(args)...)))
 399   {
 400     ASSERT(!OptionalBase&lt;T&gt;::init_);
 401     ::new (static_cast&lt;void*&gt;(dataptr())) T(il, std::forward&lt;Args&gt;(args)...);
 402     OptionalBase&lt;T&gt;::init_ = true;
 403   }
 404 
 405 public:
 406   typedef T value_type;
 407 
 408   // 20.5.5.1, constructors
 409   constexpr Optional() __NOEXCEPT : OptionalBase&lt;T&gt;()  {};
 410   constexpr Optional(nullopt_t) __NOEXCEPT : OptionalBase&lt;T&gt;() {};
 411 
 412   Optional(const Optional&amp; rhs)
 413   : OptionalBase&lt;T&gt;()
 414   {
 415     if (rhs.initialized()) {
 416         ::new (static_cast&lt;void*&gt;(dataptr())) T(*rhs);
 417         OptionalBase&lt;T&gt;::init_ = true;
 418     }
 419   }
 420 
 421   Optional(Optional&amp;&amp; rhs) __NOEXCEPT_(detail_::is_nothrow_move_constructible&lt;T&gt;::value)
 422   : OptionalBase&lt;T&gt;()
 423   {
 424     if (rhs.initialized()) {
 425         ::new (static_cast&lt;void*&gt;(dataptr())) T(std::move(*rhs));
 426         OptionalBase&lt;T&gt;::init_ = true;
 427         rhs.clear();
 428     }
 429   }
 430 
 431   constexpr Optional(const T&amp; v) : OptionalBase&lt;T&gt;(v) {}
 432 
 433   constexpr Optional(T&amp;&amp; v) : OptionalBase&lt;T&gt;(detail_::constexpr_move(v)) {}
 434 
 435   template &lt;class... Args&gt;
 436   explicit constexpr Optional(std::in_place_t, Args&amp;&amp;... args)
 437       : OptionalBase&lt;T&gt;(std::in_place_t{}, detail_::constexpr_forward&lt;Args&gt;(args)...) {}
 438 
 439   template &lt;class U, class... Args, TR2_OPTIONAL_REQUIRES(std::is_constructible&lt;T, std::initializer_list&lt;U&gt;&gt;)&gt;
 440   OPTIONAL_CONSTEXPR_INIT_LIST explicit Optional(std::in_place_t, std::initializer_list&lt;U&gt; il, Args&amp;&amp;... args)
 441       : OptionalBase&lt;T&gt;(std::in_place_t{}, il, detail_::constexpr_forward&lt;Args&gt;(args)...) {}
 442 
 443   // 20.5.4.2, Destructor
 444   ~Optional() = default;
 445 
 446   // 20.5.4.3, assignment
 447   Optional&amp; operator=(nullopt_t) __NOEXCEPT
 448   {
 449     clear();
 450     return *this;
 451   }
 452 
 453   Optional&amp; operator=(const Optional&amp; rhs)
 454   {
 455     if      (initialized() == true  &amp;&amp; rhs.initialized() == false) clear();
 456     else if (initialized() == false &amp;&amp; rhs.initialized() == true)  initialize(*rhs);
 457     else if (initialized() == true  &amp;&amp; rhs.initialized() == true)  contained_val() = *rhs;
 458     return *this;
 459   }
 460 
 461   Optional&amp; operator=(Optional&amp;&amp; rhs)
 462   __NOEXCEPT_(detail_::is_nothrow_move_assignable&lt;T&gt;::value &amp;&amp; detail_::is_nothrow_move_constructible&lt;T&gt;::value)
 463   {
 464     if      (initialized() == true  &amp;&amp; rhs.initialized() == false) clear();
 465     else if (initialized() == false &amp;&amp; rhs.initialized() == true)  { initialize(std::move(*rhs)); rhs.clear(); }
 466     else if (initialized() == true  &amp;&amp; rhs.initialized() == true)  { contained_val() = std::move(*rhs); rhs.clear(); }
 467     return *this;
 468   }
 469 
 470   template &lt;class U&gt;
 471   auto operator=(U&amp;&amp; v)
 472   -&gt; typename std::enable_if
 473   &lt;
 474     std::is_same&lt;typename std::decay&lt;U&gt;::type, T&gt;::value,
 475     Optional&amp;
 476   &gt;::type
 477   {
 478     if (initialized()) { contained_val() = std::forward&lt;U&gt;(v); }
 479     else               { initialize(std::forward&lt;U&gt;(v));  }
 480     return *this;
 481   }
 482 
 483 
 484   template &lt;class... Args&gt;
 485   void emplace(Args&amp;&amp;... args)
 486   {
 487     clear();
 488     initialize(std::forward&lt;Args&gt;(args)...);
 489   }
 490 
 491   template &lt;class U, class... Args&gt;
 492   void emplace(std::initializer_list&lt;U&gt; il, Args&amp;&amp;... args)
 493   {
 494     clear();
 495     initialize&lt;U, Args...&gt;(il, std::forward&lt;Args&gt;(args)...);
 496   }
 497 
 498   // 20.5.4.4, Swap
 499   void swap(Optional&lt;T&gt;&amp; rhs) __NOEXCEPT_(detail_::is_nothrow_move_constructible&lt;T&gt;::value &amp;&amp; __NOEXCEPT_(swap(std::declval&lt;T&amp;&gt;(), std::declval&lt;T&amp;&gt;())))
 500   {
 501     if      (initialized() == true  &amp;&amp; rhs.initialized() == false) { rhs.initialize(std::move(**this)); clear(); }
 502     else if (initialized() == false &amp;&amp; rhs.initialized() == true)  { initialize(std::move(*rhs)); rhs.clear(); }
 503     else if (initialized() == true  &amp;&amp; rhs.initialized() == true)  { using std::swap; swap(**this, *rhs); }
 504   }
 505 
 506   // 20.5.4.5, Observers
 507 
 508   explicit constexpr operator bool() const __NOEXCEPT { return initialized(); }
 509   constexpr bool hasValue() const __NOEXCEPT { return initialized(); }
 510 
 511   constexpr T const* operator -&gt;() const {
 512     RELEASE_ASSERT_UNDER_CONSTEXPR_CONTEXT(initialized());
 513     return dataptr();
 514   }
 515 
 516   OPTIONAL_MUTABLE_CONSTEXPR T* operator -&gt;() {
 517     RELEASE_ASSERT_UNDER_CONSTEXPR_CONTEXT(initialized());
 518     return dataptr();
 519   }
 520 
 521   constexpr T const&amp; operator *() const&amp; {
 522     RELEASE_ASSERT_UNDER_CONSTEXPR_CONTEXT(initialized());
 523     return contained_val();
 524   }
 525 
 526   OPTIONAL_MUTABLE_CONSTEXPR T&amp; operator *() &amp; {
 527     RELEASE_ASSERT_UNDER_CONSTEXPR_CONTEXT(initialized());
 528     return contained_val();
 529   }
 530 
 531   OPTIONAL_MUTABLE_CONSTEXPR T&amp;&amp; operator *() &amp;&amp; {
 532     RELEASE_ASSERT_UNDER_CONSTEXPR_CONTEXT(initialized());
 533     return detail_::constexpr_move(contained_val());
 534   }
 535 
 536   constexpr T const&amp; value() const&amp; {
 537     RELEASE_ASSERT_UNDER_CONSTEXPR_CONTEXT(initialized());
 538     return contained_val();
 539   }
 540 
 541   OPTIONAL_MUTABLE_CONSTEXPR T&amp; value() &amp; {
 542     RELEASE_ASSERT_UNDER_CONSTEXPR_CONTEXT(initialized());
 543     return contained_val();
 544   }
 545 
 546   OPTIONAL_MUTABLE_CONSTEXPR T&amp;&amp; value() &amp;&amp; {
 547     RELEASE_ASSERT_UNDER_CONSTEXPR_CONTEXT(initialized());
 548     return std::move(contained_val());
 549   }
 550 
 551 # if OPTIONAL_HAS_THIS_RVALUE_REFS == 1
 552 
 553   template &lt;class V&gt;
 554   constexpr T valueOr(V&amp;&amp; v) const&amp;
 555   {
 556     return *this ? **this : detail_::convert&lt;T&gt;(detail_::constexpr_forward&lt;V&gt;(v));
 557   }
 558 
 559   template &lt;class V&gt;
 560   OPTIONAL_MUTABLE_CONSTEXPR T valueOr(V&amp;&amp; v) &amp;&amp;
 561   {
 562     return *this ? detail_::constexpr_move(const_cast&lt;Optional&lt;T&gt;&amp;&gt;(*this).contained_val()) : detail_::convert&lt;T&gt;(detail_::constexpr_forward&lt;V&gt;(v));
 563   }
 564 
 565 # else
 566 
 567   template &lt;class V&gt;
 568   constexpr T valueOr(V&amp;&amp; v) const
 569   {
 570     return *this ? **this : detail_::convert&lt;T&gt;(detail_::constexpr_forward&lt;V&gt;(v));
 571   }
 572 
 573 # endif
 574 
 575   // 20.6.3.6, modifiers
 576   void reset() __NOEXCEPT { clear(); }
 577 };
 578 
 579 
 580 template &lt;class T&gt;
 581 class Optional&lt;T&amp;&gt;
 582 {
 583   static_assert( !std::is_same&lt;T, nullopt_t&gt;::value, &quot;bad T&quot; );
 584   static_assert( !std::is_same&lt;T, std::in_place_t&gt;::value, &quot;bad T&quot; );
 585   T* ref;
 586 
 587 public:
 588 
 589   // 20.5.5.1, construction/destruction
 590   constexpr Optional() __NOEXCEPT : ref(nullptr) {}
 591 
 592   constexpr Optional(nullopt_t) __NOEXCEPT : ref(nullptr) {}
 593 
 594   constexpr Optional(T&amp; v) __NOEXCEPT : ref(detail_::static_addressof(v)) {}
 595 
 596   Optional(T&amp;&amp;) = delete;
 597 
 598   constexpr Optional(const Optional&amp; rhs) __NOEXCEPT : ref(rhs.ref) {}
 599 
 600   explicit constexpr Optional(std::in_place_t, T&amp; v) __NOEXCEPT : ref(detail_::static_addressof(v)) {}
 601 
 602   explicit Optional(std::in_place_t, T&amp;&amp;) = delete;
 603 
 604   ~Optional() = default;
 605 
 606   // 20.5.5.2, mutation
 607   Optional&amp; operator=(nullopt_t) __NOEXCEPT {
 608     ref = nullptr;
 609     return *this;
 610   }
 611 
 612   // Optional&amp; operator=(const Optional&amp; rhs) __NOEXCEPT {
 613     // ref = rhs.ref;
 614     // return *this;
 615   // }
 616 
 617   // Optional&amp; operator=(Optional&amp;&amp; rhs) __NOEXCEPT {
 618     // ref = rhs.ref;
 619     // return *this;
 620   // }
 621 
 622   template &lt;typename U&gt;
 623   auto operator=(U&amp;&amp; rhs) __NOEXCEPT
 624   -&gt; typename std::enable_if
 625   &lt;
 626     std::is_same&lt;typename std::decay&lt;U&gt;::type, Optional&lt;T&amp;&gt;&gt;::value,
 627     Optional&amp;
 628   &gt;::type
 629   {
 630     ref = rhs.ref;
 631     return *this;
 632   }
 633 
 634   template &lt;typename U&gt;
 635   auto operator=(U&amp;&amp; rhs) __NOEXCEPT
 636   -&gt; typename std::enable_if
 637   &lt;
 638     !std::is_same&lt;typename std::decay&lt;U&gt;::type, Optional&lt;T&amp;&gt;&gt;::value,
 639     Optional&amp;
 640   &gt;::type
 641   = delete;
 642 
 643   void emplace(T&amp; v) __NOEXCEPT {
 644     ref = detail_::static_addressof(v);
 645   }
 646 
 647   void emplace(T&amp;&amp;) = delete;
 648 
 649 
 650   void swap(Optional&lt;T&amp;&gt;&amp; rhs) __NOEXCEPT
 651   {
 652     std::swap(ref, rhs.ref);
 653   }
 654 
 655   // 20.5.5.3, observers
 656   constexpr T* operator-&gt;() const {
 657     RELEASE_ASSERT_UNDER_CONSTEXPR_CONTEXT(ref);
 658     return ref;
 659   }
 660 
 661   constexpr T&amp; operator*() const {
 662     RELEASE_ASSERT_UNDER_CONSTEXPR_CONTEXT(ref);
 663     return *ref;
 664   }
 665 
 666   constexpr T&amp; value() const {
 667     RELEASE_ASSERT_UNDER_CONSTEXPR_CONTEXT(ref());
 668     return *ref;
 669   }
 670 
 671   explicit constexpr operator bool() const __NOEXCEPT {
 672     return ref != nullptr;
 673   }
 674 
 675   constexpr bool hasValue() const __NOEXCEPT {
 676     return ref != nullptr;
 677   }
 678 
 679   template &lt;class V&gt;
 680   constexpr typename std::decay&lt;T&gt;::type valueOr(V&amp;&amp; v) const
 681   {
 682     return *this ? **this : detail_::convert&lt;typename std::decay&lt;T&gt;::type&gt;(detail_::constexpr_forward&lt;V&gt;(v));
 683   }
 684 
 685   // x.x.x.x, modifiers
 686   void reset() __NOEXCEPT { ref = nullptr; }
 687 };
 688 
 689 
 690 template &lt;class T&gt;
 691 class Optional&lt;T&amp;&amp;&gt;
 692 {
 693   static_assert( sizeof(T) == 0, &quot;Optional rvalue references disallowed&quot; );
 694 };
 695 
 696 
 697 // 20.5.8, Relational operators
 698 template &lt;class T&gt; constexpr bool operator==(const Optional&lt;T&gt;&amp; x, const Optional&lt;T&gt;&amp; y)
 699 {
 700   return bool(x) != bool(y) ? false : bool(x) == false ? true : *x == *y;
 701 }
 702 
 703 template &lt;class T&gt; constexpr bool operator!=(const Optional&lt;T&gt;&amp; x, const Optional&lt;T&gt;&amp; y)
 704 {
 705   return !(x == y);
 706 }
 707 
 708 template &lt;class T&gt; constexpr bool operator&lt;(const Optional&lt;T&gt;&amp; x, const Optional&lt;T&gt;&amp; y)
 709 {
 710   return (!y) ? false : (!x) ? true : *x &lt; *y;
 711 }
 712 
 713 template &lt;class T&gt; constexpr bool operator&gt;(const Optional&lt;T&gt;&amp; x, const Optional&lt;T&gt;&amp; y)
 714 {
 715   return (y &lt; x);
 716 }
 717 
 718 template &lt;class T&gt; constexpr bool operator&lt;=(const Optional&lt;T&gt;&amp; x, const Optional&lt;T&gt;&amp; y)
 719 {
 720   return !(y &lt; x);
 721 }
 722 
 723 template &lt;class T&gt; constexpr bool operator&gt;=(const Optional&lt;T&gt;&amp; x, const Optional&lt;T&gt;&amp; y)
 724 {
 725   return !(x &lt; y);
 726 }
 727 
 728 
 729 // 20.5.9, Comparison with nullopt
 730 template &lt;class T&gt; constexpr bool operator==(const Optional&lt;T&gt;&amp; x, nullopt_t) __NOEXCEPT
 731 {
 732   return (!x);
 733 }
 734 
 735 template &lt;class T&gt; constexpr bool operator==(nullopt_t, const Optional&lt;T&gt;&amp; x) __NOEXCEPT
 736 {
 737   return (!x);
 738 }
 739 
 740 template &lt;class T&gt; constexpr bool operator!=(const Optional&lt;T&gt;&amp; x, nullopt_t) __NOEXCEPT
 741 {
 742   return bool(x);
 743 }
 744 
 745 template &lt;class T&gt; constexpr bool operator!=(nullopt_t, const Optional&lt;T&gt;&amp; x) __NOEXCEPT
 746 {
 747   return bool(x);
 748 }
 749 
 750 template &lt;class T&gt; constexpr bool operator&lt;(const Optional&lt;T&gt;&amp;, nullopt_t) __NOEXCEPT
 751 {
 752   return false;
 753 }
 754 
 755 template &lt;class T&gt; constexpr bool operator&lt;(nullopt_t, const Optional&lt;T&gt;&amp; x) __NOEXCEPT
 756 {
 757   return bool(x);
 758 }
 759 
 760 template &lt;class T&gt; constexpr bool operator&lt;=(const Optional&lt;T&gt;&amp; x, nullopt_t) __NOEXCEPT
 761 {
 762   return (!x);
 763 }
 764 
 765 template &lt;class T&gt; constexpr bool operator&lt;=(nullopt_t, const Optional&lt;T&gt;&amp;) __NOEXCEPT
 766 {
 767   return true;
 768 }
 769 
 770 template &lt;class T&gt; constexpr bool operator&gt;(const Optional&lt;T&gt;&amp; x, nullopt_t) __NOEXCEPT
 771 {
 772   return bool(x);
 773 }
 774 
 775 template &lt;class T&gt; constexpr bool operator&gt;(nullopt_t, const Optional&lt;T&gt;&amp;) __NOEXCEPT
 776 {
 777   return false;
 778 }
 779 
 780 template &lt;class T&gt; constexpr bool operator&gt;=(const Optional&lt;T&gt;&amp;, nullopt_t) __NOEXCEPT
 781 {
 782   return true;
 783 }
 784 
 785 template &lt;class T&gt; constexpr bool operator&gt;=(nullopt_t, const Optional&lt;T&gt;&amp; x) __NOEXCEPT
 786 {
 787   return (!x);
 788 }
 789 
 790 
 791 
 792 // 20.5.10, Comparison with T
 793 template &lt;class T&gt; constexpr bool operator==(const Optional&lt;T&gt;&amp; x, const T&amp; v)
 794 {
 795   return bool(x) ? *x == v : false;
 796 }
 797 
 798 template &lt;class T&gt; constexpr bool operator==(const T&amp; v, const Optional&lt;T&gt;&amp; x)
 799 {
 800   return bool(x) ? v == *x : false;
 801 }
 802 
 803 template &lt;class T&gt; constexpr bool operator!=(const Optional&lt;T&gt;&amp; x, const T&amp; v)
 804 {
 805   return bool(x) ? *x != v : true;
 806 }
 807 
 808 template &lt;class T&gt; constexpr bool operator!=(const T&amp; v, const Optional&lt;T&gt;&amp; x)
 809 {
 810   return bool(x) ? v != *x : true;
 811 }
 812 
 813 template &lt;class T&gt; constexpr bool operator&lt;(const Optional&lt;T&gt;&amp; x, const T&amp; v)
 814 {
 815   return bool(x) ? *x &lt; v : true;
 816 }
 817 
 818 template &lt;class T&gt; constexpr bool operator&gt;(const T&amp; v, const Optional&lt;T&gt;&amp; x)
 819 {
 820   return bool(x) ? v &gt; *x : true;
 821 }
 822 
 823 template &lt;class T&gt; constexpr bool operator&gt;(const Optional&lt;T&gt;&amp; x, const T&amp; v)
 824 {
 825   return bool(x) ? *x &gt; v : false;
 826 }
 827 
 828 template &lt;class T&gt; constexpr bool operator&lt;(const T&amp; v, const Optional&lt;T&gt;&amp; x)
 829 {
 830   return bool(x) ? v &lt; *x : false;
 831 }
 832 
 833 template &lt;class T&gt; constexpr bool operator&gt;=(const Optional&lt;T&gt;&amp; x, const T&amp; v)
 834 {
 835   return bool(x) ? *x &gt;= v : false;
 836 }
 837 
 838 template &lt;class T&gt; constexpr bool operator&lt;=(const T&amp; v, const Optional&lt;T&gt;&amp; x)
 839 {
 840   return bool(x) ? v &lt;= *x : false;
 841 }
 842 
 843 template &lt;class T&gt; constexpr bool operator&lt;=(const Optional&lt;T&gt;&amp; x, const T&amp; v)
 844 {
 845   return bool(x) ? *x &lt;= v : true;
 846 }
 847 
 848 template &lt;class T&gt; constexpr bool operator&gt;=(const T&amp; v, const Optional&lt;T&gt;&amp; x)
 849 {
 850   return bool(x) ? v &gt;= *x : true;
 851 }
 852 
 853 
 854 // Comparison of Optional&lt;T&amp;&gt; with T
 855 template &lt;class T&gt; constexpr bool operator==(const Optional&lt;T&amp;&gt;&amp; x, const T&amp; v)
 856 {
 857   return bool(x) ? *x == v : false;
 858 }
 859 
 860 template &lt;class T&gt; constexpr bool operator==(const T&amp; v, const Optional&lt;T&amp;&gt;&amp; x)
 861 {
 862   return bool(x) ? v == *x : false;
 863 }
 864 
 865 template &lt;class T&gt; constexpr bool operator!=(const Optional&lt;T&amp;&gt;&amp; x, const T&amp; v)
 866 {
 867   return bool(x) ? *x != v : true;
 868 }
 869 
 870 template &lt;class T&gt; constexpr bool operator!=(const T&amp; v, const Optional&lt;T&amp;&gt;&amp; x)
 871 {
 872   return bool(x) ? v != *x : true;
 873 }
 874 
 875 template &lt;class T&gt; constexpr bool operator&lt;(const Optional&lt;T&amp;&gt;&amp; x, const T&amp; v)
 876 {
 877   return bool(x) ? *x &lt; v : true;
 878 }
 879 
 880 template &lt;class T&gt; constexpr bool operator&gt;(const T&amp; v, const Optional&lt;T&amp;&gt;&amp; x)
 881 {
 882   return bool(x) ? v &gt; *x : true;
 883 }
 884 
 885 template &lt;class T&gt; constexpr bool operator&gt;(const Optional&lt;T&amp;&gt;&amp; x, const T&amp; v)
 886 {
 887   return bool(x) ? *x &gt; v : false;
 888 }
 889 
 890 template &lt;class T&gt; constexpr bool operator&lt;(const T&amp; v, const Optional&lt;T&amp;&gt;&amp; x)
 891 {
 892   return bool(x) ? v &lt; *x : false;
 893 }
 894 
 895 template &lt;class T&gt; constexpr bool operator&gt;=(const Optional&lt;T&amp;&gt;&amp; x, const T&amp; v)
 896 {
 897   return bool(x) ? *x &gt;= v : false;
 898 }
 899 
 900 template &lt;class T&gt; constexpr bool operator&lt;=(const T&amp; v, const Optional&lt;T&amp;&gt;&amp; x)
 901 {
 902   return bool(x) ? v &lt;= *x : false;
 903 }
 904 
 905 template &lt;class T&gt; constexpr bool operator&lt;=(const Optional&lt;T&amp;&gt;&amp; x, const T&amp; v)
 906 {
 907   return bool(x) ? *x &lt;= v : true;
 908 }
 909 
 910 template &lt;class T&gt; constexpr bool operator&gt;=(const T&amp; v, const Optional&lt;T&amp;&gt;&amp; x)
 911 {
 912   return bool(x) ? v &gt;= *x : true;
 913 }
 914 
 915 // Comparison of Optional&lt;T const&amp;&gt; with T
 916 template &lt;class T&gt; constexpr bool operator==(const Optional&lt;const T&amp;&gt;&amp; x, const T&amp; v)
 917 {
 918   return bool(x) ? *x == v : false;
 919 }
 920 
 921 template &lt;class T&gt; constexpr bool operator==(const T&amp; v, const Optional&lt;const T&amp;&gt;&amp; x)
 922 {
 923   return bool(x) ? v == *x : false;
 924 }
 925 
 926 template &lt;class T&gt; constexpr bool operator!=(const Optional&lt;const T&amp;&gt;&amp; x, const T&amp; v)
 927 {
 928   return bool(x) ? *x != v : true;
 929 }
 930 
 931 template &lt;class T&gt; constexpr bool operator!=(const T&amp; v, const Optional&lt;const T&amp;&gt;&amp; x)
 932 {
 933   return bool(x) ? v != *x : true;
 934 }
 935 
 936 template &lt;class T&gt; constexpr bool operator&lt;(const Optional&lt;const T&amp;&gt;&amp; x, const T&amp; v)
 937 {
 938   return bool(x) ? *x &lt; v : true;
 939 }
 940 
 941 template &lt;class T&gt; constexpr bool operator&gt;(const T&amp; v, const Optional&lt;const T&amp;&gt;&amp; x)
 942 {
 943   return bool(x) ? v &gt; *x : true;
 944 }
 945 
 946 template &lt;class T&gt; constexpr bool operator&gt;(const Optional&lt;const T&amp;&gt;&amp; x, const T&amp; v)
 947 {
 948   return bool(x) ? *x &gt; v : false;
 949 }
 950 
 951 template &lt;class T&gt; constexpr bool operator&lt;(const T&amp; v, const Optional&lt;const T&amp;&gt;&amp; x)
 952 {
 953   return bool(x) ? v &lt; *x : false;
 954 }
 955 
 956 template &lt;class T&gt; constexpr bool operator&gt;=(const Optional&lt;const T&amp;&gt;&amp; x, const T&amp; v)
 957 {
 958   return bool(x) ? *x &gt;= v : false;
 959 }
 960 
 961 template &lt;class T&gt; constexpr bool operator&lt;=(const T&amp; v, const Optional&lt;const T&amp;&gt;&amp; x)
 962 {
 963   return bool(x) ? v &lt;= *x : false;
 964 }
 965 
 966 template &lt;class T&gt; constexpr bool operator&lt;=(const Optional&lt;const T&amp;&gt;&amp; x, const T&amp; v)
 967 {
 968   return bool(x) ? *x &lt;= v : true;
 969 }
 970 
 971 template &lt;class T&gt; constexpr bool operator&gt;=(const T&amp; v, const Optional&lt;const T&amp;&gt;&amp; x)
 972 {
 973   return bool(x) ? v &gt;= *x : true;
 974 }
 975 
 976 
 977 // 20.5.12, Specialized algorithms
 978 template &lt;class T&gt;
 979 void swap(Optional&lt;T&gt;&amp; x, Optional&lt;T&gt;&amp; y) __NOEXCEPT_(__NOEXCEPT_(x.swap(y)))
 980 {
 981   x.swap(y);
 982 }
 983 
 984 
 985 template &lt;class T&gt;
 986 constexpr Optional&lt;typename std::decay&lt;T&gt;::type&gt; makeOptional(T&amp;&amp; v)
 987 {
 988   return Optional&lt;typename std::decay&lt;T&gt;::type&gt;(detail_::constexpr_forward&lt;T&gt;(v));
 989 }
 990 
 991 template &lt;class X&gt;
 992 constexpr Optional&lt;X&amp;&gt; makeOptional(std::reference_wrapper&lt;X&gt; v)
 993 {
 994   return Optional&lt;X&amp;&gt;(v.get());
 995 }
 996 
 997 } // namespace WTF
 998 
 999 namespace std
1000 {
1001   template &lt;typename T&gt;
1002   struct hash&lt;WTF::Optional&lt;T&gt;&gt;
1003   {
1004     typedef typename hash&lt;T&gt;::result_type result_type;
1005     typedef WTF::Optional&lt;T&gt; argument_type;
1006 
1007     constexpr result_type operator()(argument_type const&amp; arg) const {
1008       return arg ? std::hash&lt;T&gt;{}(*arg) : result_type{};
1009     }
1010   };
1011 
1012   template &lt;typename T&gt;
1013   struct hash&lt;WTF::Optional&lt;T&amp;&gt;&gt;
1014   {
1015     typedef typename hash&lt;T&gt;::result_type result_type;
1016     typedef WTF::Optional&lt;T&amp;&gt; argument_type;
1017 
1018     constexpr result_type operator()(argument_type const&amp; arg) const {
1019       return arg ? std::hash&lt;T&gt;{}(*arg) : result_type{};
1020     }
1021   };
1022 }
1023 
1024 # undef TR2_OPTIONAL_REQUIRES
1025 
1026 namespace WTF {
1027 
1028 // -- WebKit Additions --
1029 template &lt;class OptionalType, class Callback&gt;
1030 ALWAYS_INLINE
1031 auto valueOrCompute(OptionalType Optional, Callback callback) -&gt; typename OptionalType::value_type
1032 {
1033     if (Optional)
1034         return *Optional;
1035     return callback();
1036 }
1037 
1038 } // namespace WTF
1039 
1040 using WTF::Optional;
1041 using WTF::makeOptional;
1042 using WTF::valueOrCompute;
    </pre>
  </body>
</html>