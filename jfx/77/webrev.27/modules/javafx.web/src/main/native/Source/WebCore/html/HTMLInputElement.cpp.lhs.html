<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/html/HTMLInputElement.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
   3  *           (C) 1999 Antti Koivisto (koivisto@kde.org)
   4  *           (C) 2001 Dirk Mueller (mueller@kde.org)
   5  * Copyright (C) 2004-2018 Apple Inc. All rights reserved.
   6  *           (C) 2006 Alexey Proskuryakov (ap@nypop.com)
   7  * Copyright (C) 2007 Samuel Weinig (sam@webkit.org)
   8  * Copyright (C) 2010 Google Inc. All rights reserved.
   9  * Copyright (C) 2008 Torch Mobile Inc. All rights reserved. (http://www.torchmobile.com/)
  10  * Copyright (C) 2012 Samsung Electronics. All rights reserved.
  11  *
  12  * This library is free software; you can redistribute it and/or
  13  * modify it under the terms of the GNU Library General Public
  14  * License as published by the Free Software Foundation; either
  15  * version 2 of the License, or (at your option) any later version.
  16  *
  17  * This library is distributed in the hope that it will be useful,
  18  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  19  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  20  * Library General Public License for more details.
  21  *
  22  * You should have received a copy of the GNU Library General Public License
  23  * along with this library; see the file COPYING.LIB.  If not, write to
  24  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  25  * Boston, MA 02110-1301, USA.
  26  *
  27  */
  28 
  29 #include &quot;config.h&quot;
  30 #include &quot;HTMLInputElement.h&quot;
  31 
  32 #include &quot;AXObjectCache.h&quot;
  33 #include &quot;BeforeTextInsertedEvent.h&quot;
  34 #include &quot;CSSGradientValue.h&quot;
  35 #include &quot;CSSPropertyNames.h&quot;
  36 #include &quot;CSSValuePool.h&quot;
  37 #include &quot;Chrome.h&quot;
  38 #include &quot;ChromeClient.h&quot;
  39 #include &quot;DateTimeChooser.h&quot;
  40 #include &quot;Document.h&quot;
  41 #include &quot;Editor.h&quot;
  42 #include &quot;EventNames.h&quot;
  43 #include &quot;FileInputType.h&quot;
  44 #include &quot;FileList.h&quot;
  45 #include &quot;FormController.h&quot;
  46 #include &quot;Frame.h&quot;
  47 #include &quot;FrameSelection.h&quot;
  48 #include &quot;FrameView.h&quot;
  49 #include &quot;HTMLDataListElement.h&quot;
  50 #include &quot;HTMLFormElement.h&quot;
  51 #include &quot;HTMLImageLoader.h&quot;
  52 #include &quot;HTMLOptionElement.h&quot;
  53 #include &quot;HTMLParserIdioms.h&quot;
  54 #include &quot;IdTargetObserver.h&quot;
  55 #include &quot;KeyboardEvent.h&quot;
  56 #include &quot;LocalizedStrings.h&quot;
  57 #include &quot;MouseEvent.h&quot;
  58 #include &quot;Page.h&quot;
  59 #include &quot;PlatformMouseEvent.h&quot;
  60 #include &quot;RenderTextControlSingleLine.h&quot;
  61 #include &quot;RenderTheme.h&quot;
  62 #include &quot;ScopedEventQueue.h&quot;
  63 #include &quot;SearchInputType.h&quot;
  64 #include &quot;Settings.h&quot;
  65 #include &quot;StyleResolver.h&quot;
  66 #include &quot;TextControlInnerElements.h&quot;
  67 #include &lt;wtf/IsoMallocInlines.h&gt;
  68 #include &lt;wtf/Language.h&gt;
  69 #include &lt;wtf/MathExtras.h&gt;
  70 #include &lt;wtf/Ref.h&gt;
  71 
  72 #if ENABLE(TOUCH_EVENTS)
  73 #include &quot;TouchEvent.h&quot;
  74 #endif
  75 
  76 namespace WebCore {
  77 
  78 WTF_MAKE_ISO_ALLOCATED_IMPL(HTMLInputElement);
  79 
  80 using namespace HTMLNames;
  81 
  82 #if ENABLE(DATALIST_ELEMENT)
  83 class ListAttributeTargetObserver : IdTargetObserver {
  84     WTF_MAKE_FAST_ALLOCATED;
  85 public:
<a name="1" id="anc1"></a><span class="line-modified">  86     ListAttributeTargetObserver(const AtomicString&amp; id, HTMLInputElement*);</span>
  87 
  88     void idTargetChanged() override;
  89 
  90 private:
  91     HTMLInputElement* m_element;
  92 };
  93 #endif
  94 
  95 // FIXME: According to HTML4, the length attribute&#39;s value can be arbitrarily
  96 // large. However, due to https://bugs.webkit.org/show_bug.cgi?id=14536 things
  97 // get rather sluggish when a text field has a larger number of characters than
  98 // this, even when just clicking in the text field.
  99 const unsigned HTMLInputElement::maxEffectiveLength = 524288;
 100 const int defaultSize = 20;
 101 const int maxSavedResults = 256;
 102 
 103 HTMLInputElement::HTMLInputElement(const QualifiedName&amp; tagName, Document&amp; document, HTMLFormElement* form, bool createdByParser)
 104     : HTMLTextFormControlElement(tagName, document, form)
 105     , m_size(defaultSize)
 106     , m_isChecked(false)
 107     , m_dirtyCheckednessFlag(false)
 108     , m_isIndeterminate(false)
 109     , m_hasType(false)
 110     , m_isActivatedSubmit(false)
 111     , m_autocomplete(Uninitialized)
 112     , m_isAutoFilled(false)
<a name="2" id="anc2"></a>
 113     , m_autoFillButtonType(static_cast&lt;uint8_t&gt;(AutoFillButtonType::None))
 114     , m_lastAutoFillButtonType(static_cast&lt;uint8_t&gt;(AutoFillButtonType::None))
 115     , m_isAutoFillAvailable(false)
 116 #if ENABLE(DATALIST_ELEMENT)
 117     , m_hasNonEmptyList(false)
 118 #endif
 119     , m_stateRestored(false)
 120     , m_parsingInProgress(createdByParser)
 121     , m_valueAttributeWasUpdatedAfterParsing(false)
 122     , m_wasModifiedByUser(false)
 123     , m_canReceiveDroppedFiles(false)
 124 #if ENABLE(TOUCH_EVENTS)
 125     , m_hasTouchEventHandler(false)
 126 #endif
 127     , m_isSpellcheckDisabledExceptTextReplacement(false)
 128 {
 129     // m_inputType is lazily created when constructed by the parser to avoid constructing unnecessarily a text inputType and
 130     // its shadow subtree, just to destroy them when the |type| attribute gets set by the parser to something else than &#39;text&#39;.
 131     if (!createdByParser)
 132         m_inputType = InputType::createText(*this);
 133 
 134     ASSERT(hasTagName(inputTag));
 135     setHasCustomStyleResolveCallbacks();
 136 }
 137 
 138 Ref&lt;HTMLInputElement&gt; HTMLInputElement::create(const QualifiedName&amp; tagName, Document&amp; document, HTMLFormElement* form, bool createdByParser)
 139 {
 140     bool shouldCreateShadowRootLazily = createdByParser;
 141     Ref&lt;HTMLInputElement&gt; inputElement = adoptRef(*new HTMLInputElement(tagName, document, form, createdByParser));
 142     if (!shouldCreateShadowRootLazily)
 143         inputElement-&gt;ensureUserAgentShadowRoot();
 144     return inputElement;
 145 }
 146 
 147 HTMLImageLoader&amp; HTMLInputElement::ensureImageLoader()
 148 {
 149     if (!m_imageLoader)
<a name="3" id="anc3"></a><span class="line-modified"> 150         m_imageLoader = std::make_unique&lt;HTMLImageLoader&gt;(*this);</span>
 151     return *m_imageLoader;
 152 }
 153 
 154 void HTMLInputElement::didAddUserAgentShadowRoot(ShadowRoot&amp;)
 155 {
 156     Ref&lt;InputType&gt; protectedInputType(*m_inputType);
 157     protectedInputType-&gt;createShadowSubtree();
 158     updateInnerTextElementEditability();
 159 }
 160 
 161 HTMLInputElement::~HTMLInputElement()
 162 {
 163     if (needsSuspensionCallback())
 164         document().unregisterForDocumentSuspensionCallbacks(*this);
 165 
 166     // Need to remove form association while this is still an HTMLInputElement
 167     // so that virtual functions are called correctly.
<a name="4" id="anc4"></a><span class="line-modified"> 168     setForm(0);</span>
<span class="line-modified"> 169     // setForm(0) may register this to a document-level radio button group.</span>
<span class="line-modified"> 170     // We should unregister it to avoid accessing a deleted object.</span>



 171     if (isRadioButton())
 172         document().formController().radioButtonGroups().removeButton(*this);
<a name="5" id="anc5"></a>
 173 #if ENABLE(TOUCH_EVENTS)
 174     if (m_hasTouchEventHandler)
 175         document().didRemoveEventTargetNode(*this);
 176 #endif
 177 }
 178 
<a name="6" id="anc6"></a><span class="line-modified"> 179 const AtomicString&amp; HTMLInputElement::name() const</span>
 180 {
 181     return m_name.isNull() ? emptyAtom() : m_name;
 182 }
 183 
 184 Vector&lt;FileChooserFileInfo&gt; HTMLInputElement::filesFromFileInputFormControlState(const FormControlState&amp; state)
 185 {
 186     return FileInputType::filesFromFormControlState(state);
 187 }
 188 
 189 HTMLElement* HTMLInputElement::containerElement() const
 190 {
 191     return m_inputType-&gt;containerElement();
 192 }
 193 
 194 RefPtr&lt;TextControlInnerTextElement&gt; HTMLInputElement::innerTextElement() const
 195 {
 196     return m_inputType-&gt;innerTextElement();
 197 }
 198 
 199 HTMLElement* HTMLInputElement::innerBlockElement() const
 200 {
 201     return m_inputType-&gt;innerBlockElement();
 202 }
 203 
 204 HTMLElement* HTMLInputElement::innerSpinButtonElement() const
 205 {
 206     return m_inputType-&gt;innerSpinButtonElement();
 207 }
 208 
 209 HTMLElement* HTMLInputElement::capsLockIndicatorElement() const
 210 {
 211     return m_inputType-&gt;capsLockIndicatorElement();
 212 }
 213 
 214 HTMLElement* HTMLInputElement::autoFillButtonElement() const
 215 {
 216     return m_inputType-&gt;autoFillButtonElement();
 217 }
 218 
 219 HTMLElement* HTMLInputElement::resultsButtonElement() const
 220 {
 221     return m_inputType-&gt;resultsButtonElement();
 222 }
 223 
 224 HTMLElement* HTMLInputElement::cancelButtonElement() const
 225 {
 226     return m_inputType-&gt;cancelButtonElement();
 227 }
 228 
 229 HTMLElement* HTMLInputElement::sliderThumbElement() const
 230 {
 231     return m_inputType-&gt;sliderThumbElement();
 232 }
 233 
 234 HTMLElement* HTMLInputElement::sliderTrackElement() const
 235 {
 236     return m_inputType-&gt;sliderTrackElement();
 237 }
 238 
 239 HTMLElement* HTMLInputElement::placeholderElement() const
 240 {
 241     return m_inputType-&gt;placeholderElement();
 242 }
 243 
 244 #if ENABLE(DATALIST_ELEMENT)
 245 HTMLElement* HTMLInputElement::dataListButtonElement() const
 246 {
 247     return m_inputType-&gt;dataListButtonElement();
 248 }
 249 #endif
 250 
 251 bool HTMLInputElement::shouldAutocomplete() const
 252 {
 253     if (m_autocomplete != Uninitialized)
 254         return m_autocomplete == On;
 255     return HTMLTextFormControlElement::shouldAutocomplete();
 256 }
 257 
 258 bool HTMLInputElement::isValidValue(const String&amp; value) const
 259 {
 260     if (!m_inputType-&gt;canSetStringValue()) {
 261         ASSERT_NOT_REACHED();
 262         return false;
 263     }
 264     return !m_inputType-&gt;typeMismatchFor(value)
 265         &amp;&amp; !m_inputType-&gt;stepMismatch(value)
 266         &amp;&amp; !m_inputType-&gt;rangeUnderflow(value)
 267         &amp;&amp; !m_inputType-&gt;rangeOverflow(value)
 268         &amp;&amp; !tooShort(value, IgnoreDirtyFlag)
 269         &amp;&amp; !tooLong(value, IgnoreDirtyFlag)
 270         &amp;&amp; !m_inputType-&gt;patternMismatch(value)
 271         &amp;&amp; !m_inputType-&gt;valueMissing(value);
 272 }
 273 
 274 bool HTMLInputElement::tooShort() const
 275 {
 276     return willValidate() &amp;&amp; tooShort(value(), CheckDirtyFlag);
 277 }
 278 
 279 bool HTMLInputElement::tooLong() const
 280 {
 281     return willValidate() &amp;&amp; tooLong(value(), CheckDirtyFlag);
 282 }
 283 
 284 bool HTMLInputElement::typeMismatch() const
 285 {
 286     return willValidate() &amp;&amp; m_inputType-&gt;typeMismatch();
 287 }
 288 
 289 bool HTMLInputElement::valueMissing() const
 290 {
 291     return willValidate() &amp;&amp; m_inputType-&gt;valueMissing(value());
 292 }
 293 
 294 bool HTMLInputElement::hasBadInput() const
 295 {
 296     return willValidate() &amp;&amp; m_inputType-&gt;hasBadInput();
 297 }
 298 
 299 bool HTMLInputElement::patternMismatch() const
 300 {
 301     return willValidate() &amp;&amp; m_inputType-&gt;patternMismatch(value());
 302 }
 303 
 304 bool HTMLInputElement::tooShort(StringView value, NeedsToCheckDirtyFlag check) const
 305 {
 306     if (!supportsMinLength())
 307         return false;
 308 
 309     int min = minLength();
 310     if (min &lt;= 0)
 311         return false;
 312 
 313     if (check == CheckDirtyFlag) {
 314         // Return false for the default value or a value set by a script even if
 315         // it is shorter than minLength.
 316         if (!hasDirtyValue() || !m_wasModifiedByUser)
 317             return false;
 318     }
 319 
 320     // The empty string is excluded from tooShort validation.
 321     if (value.isEmpty())
 322         return false;
 323 
 324     // FIXME: The HTML specification says that the &quot;number of characters&quot; is measured using code-unit length.
 325     return numGraphemeClusters(value) &lt; static_cast&lt;unsigned&gt;(min);
 326 }
 327 
 328 bool HTMLInputElement::tooLong(StringView value, NeedsToCheckDirtyFlag check) const
 329 {
 330     if (!supportsMaxLength())
 331         return false;
 332     unsigned max = effectiveMaxLength();
 333     if (check == CheckDirtyFlag) {
 334         // Return false for the default value or a value set by a script even if
 335         // it is longer than maxLength.
 336         if (!hasDirtyValue() || !m_wasModifiedByUser)
 337             return false;
 338     }
 339     // FIXME: The HTML specification says that the &quot;number of characters&quot; is measured using code-unit length.
 340     return numGraphemeClusters(value) &gt; max;
 341 }
 342 
 343 bool HTMLInputElement::rangeUnderflow() const
 344 {
 345     return willValidate() &amp;&amp; m_inputType-&gt;rangeUnderflow(value());
 346 }
 347 
 348 bool HTMLInputElement::rangeOverflow() const
 349 {
 350     return willValidate() &amp;&amp; m_inputType-&gt;rangeOverflow(value());
 351 }
 352 
 353 String HTMLInputElement::validationMessage() const
 354 {
 355     if (!willValidate())
 356         return String();
 357 
 358     if (customError())
 359         return customValidationMessage();
 360 
 361     return m_inputType-&gt;validationMessage();
 362 }
 363 
 364 double HTMLInputElement::minimum() const
 365 {
 366     return m_inputType-&gt;minimum();
 367 }
 368 
 369 double HTMLInputElement::maximum() const
 370 {
 371     return m_inputType-&gt;maximum();
 372 }
 373 
 374 bool HTMLInputElement::stepMismatch() const
 375 {
 376     return willValidate() &amp;&amp; m_inputType-&gt;stepMismatch(value());
 377 }
 378 
 379 bool HTMLInputElement::isValid() const
 380 {
 381     if (!willValidate())
 382         return true;
 383 
 384     String value = this-&gt;value();
 385     bool someError = m_inputType-&gt;typeMismatch() || m_inputType-&gt;stepMismatch(value) || m_inputType-&gt;rangeUnderflow(value) || m_inputType-&gt;rangeOverflow(value)
 386         || tooShort(value, CheckDirtyFlag) || tooLong(value, CheckDirtyFlag) || m_inputType-&gt;patternMismatch(value) || m_inputType-&gt;valueMissing(value)
 387         || m_inputType-&gt;hasBadInput() || customError();
 388     return !someError;
 389 }
 390 
 391 bool HTMLInputElement::getAllowedValueStep(Decimal* step) const
 392 {
 393     return m_inputType-&gt;getAllowedValueStep(step);
 394 }
 395 
 396 StepRange HTMLInputElement::createStepRange(AnyStepHandling anyStepHandling) const
 397 {
 398     return m_inputType-&gt;createStepRange(anyStepHandling);
 399 }
 400 
 401 #if ENABLE(DATALIST_ELEMENT)
 402 Optional&lt;Decimal&gt; HTMLInputElement::findClosestTickMarkValue(const Decimal&amp; value)
 403 {
 404     return m_inputType-&gt;findClosestTickMarkValue(value);
 405 }
 406 #endif
 407 
 408 ExceptionOr&lt;void&gt; HTMLInputElement::stepUp(int n)
 409 {
 410     return m_inputType-&gt;stepUp(n);
 411 }
 412 
 413 ExceptionOr&lt;void&gt; HTMLInputElement::stepDown(int n)
 414 {
 415     return m_inputType-&gt;stepUp(-n);
 416 }
 417 
 418 void HTMLInputElement::blur()
 419 {
 420     m_inputType-&gt;blur();
 421 }
 422 
 423 void HTMLInputElement::defaultBlur()
 424 {
 425     HTMLTextFormControlElement::blur();
 426 }
 427 
 428 bool HTMLInputElement::hasCustomFocusLogic() const
 429 {
 430     return m_inputType-&gt;hasCustomFocusLogic();
 431 }
 432 
<a name="7" id="anc7"></a>




 433 bool HTMLInputElement::isKeyboardFocusable(KeyboardEvent* event) const
 434 {
 435     return m_inputType-&gt;isKeyboardFocusable(event);
 436 }
 437 
 438 bool HTMLInputElement::isMouseFocusable() const
 439 {
 440     return m_inputType-&gt;isMouseFocusable();
 441 }
 442 
<a name="8" id="anc8"></a>




 443 bool HTMLInputElement::isTextFormControlFocusable() const
 444 {
 445     return HTMLTextFormControlElement::isFocusable();
 446 }
 447 
 448 bool HTMLInputElement::isTextFormControlKeyboardFocusable(KeyboardEvent* event) const
 449 {
 450     return HTMLTextFormControlElement::isKeyboardFocusable(event);
 451 }
 452 
 453 bool HTMLInputElement::isTextFormControlMouseFocusable() const
 454 {
 455     return HTMLTextFormControlElement::isMouseFocusable();
 456 }
 457 
 458 void HTMLInputElement::updateFocusAppearance(SelectionRestorationMode restorationMode, SelectionRevealMode revealMode)
 459 {
 460     if (isTextField()) {
 461         if (restorationMode == SelectionRestorationMode::SetDefault || !hasCachedSelection())
 462             setDefaultSelectionAfterFocus(revealMode);
 463         else
 464             restoreCachedSelection(revealMode);
 465     } else
 466         HTMLTextFormControlElement::updateFocusAppearance(restorationMode, revealMode);
 467 }
 468 
 469 void HTMLInputElement::setDefaultSelectionAfterFocus(SelectionRevealMode revealMode)
 470 {
 471     ASSERT(isTextField());
 472     int start = 0;
 473     auto direction = SelectionHasNoDirection;
 474     auto* frame = document().frame();
 475     if (frame &amp;&amp; frame-&gt;editor().behavior().shouldMoveSelectionToEndWhenFocusingTextInput()) {
 476         start = std::numeric_limits&lt;int&gt;::max();
 477         direction = SelectionHasForwardDirection;
 478     }
 479     setSelectionRange(start, std::numeric_limits&lt;int&gt;::max(), direction, revealMode, Element::defaultFocusTextStateChangeIntent());
 480 }
 481 
 482 void HTMLInputElement::endEditing()
 483 {
 484     if (!isTextField())
 485         return;
 486 
 487     if (RefPtr&lt;Frame&gt; frame = document().frame())
 488         frame-&gt;editor().textFieldDidEndEditing(this);
 489 }
 490 
 491 bool HTMLInputElement::shouldUseInputMethod()
 492 {
 493     return m_inputType-&gt;shouldUseInputMethod();
 494 }
 495 
 496 void HTMLInputElement::handleFocusEvent(Node* oldFocusedNode, FocusDirection direction)
 497 {
 498     m_inputType-&gt;handleFocusEvent(oldFocusedNode, direction);
 499 }
 500 
 501 void HTMLInputElement::handleBlurEvent()
 502 {
 503     m_inputType-&gt;handleBlurEvent();
 504 }
 505 
<a name="9" id="anc9"></a><span class="line-modified"> 506 void HTMLInputElement::setType(const AtomicString&amp; type)</span>
 507 {
 508     setAttributeWithoutSynchronization(typeAttr, type);
 509 }
 510 
 511 void HTMLInputElement::resignStrongPasswordAppearance()
 512 {
 513     if (!hasAutoFillStrongPasswordButton())
 514         return;
 515     setAutoFilled(false);
<a name="10" id="anc10"></a>
 516     setShowAutoFillButton(AutoFillButtonType::None);
 517     if (auto* page = document().page())
 518         page-&gt;chrome().client().inputElementDidResignStrongPasswordAppearance(*this);
 519 }
 520 
 521 void HTMLInputElement::updateType()
 522 {
 523     ASSERT(m_inputType);
 524     auto newType = InputType::create(*this, attributeWithoutSynchronization(typeAttr));
 525     m_hasType = true;
 526     if (m_inputType-&gt;formControlType() == newType-&gt;formControlType())
 527         return;
 528 
 529     removeFromRadioButtonGroup();
 530     resignStrongPasswordAppearance();
 531 
 532     bool didStoreValue = m_inputType-&gt;storesValueSeparateFromAttribute();
 533     bool willStoreValue = newType-&gt;storesValueSeparateFromAttribute();
 534     bool neededSuspensionCallback = needsSuspensionCallback();
 535     bool didRespectHeightAndWidth = m_inputType-&gt;shouldRespectHeightAndWidthAttributes();
 536     bool wasSuccessfulSubmitButtonCandidate = m_inputType-&gt;canBeSuccessfulSubmitButton();
 537 
 538     if (didStoreValue &amp;&amp; !willStoreValue &amp;&amp; hasDirtyValue()) {
 539         setAttributeWithoutSynchronization(valueAttr, m_valueIfDirty);
 540         m_valueIfDirty = String();
 541     }
 542 
 543     m_inputType-&gt;destroyShadowSubtree();
 544     m_inputType-&gt;detachFromElement();
 545 
 546     m_inputType = WTFMove(newType);
 547     m_inputType-&gt;createShadowSubtree();
 548     updateInnerTextElementEditability();
 549 
 550     setNeedsWillValidateCheck();
 551 
 552     if (!didStoreValue &amp;&amp; willStoreValue)
 553         m_valueIfDirty = sanitizeValue(attributeWithoutSynchronization(valueAttr));
 554     else
 555         updateValueIfNeeded();
 556 
 557     setFormControlValueMatchesRenderer(false);
 558     m_inputType-&gt;updateInnerTextValue();
 559 
 560     m_wasModifiedByUser = false;
 561 
 562     if (neededSuspensionCallback)
 563         unregisterForSuspensionCallbackIfNeeded();
 564     else
 565         registerForSuspensionCallbackIfNeeded();
 566 
 567     if (didRespectHeightAndWidth != m_inputType-&gt;shouldRespectHeightAndWidthAttributes()) {
 568         ASSERT(elementData());
 569         // FIXME: We don&#39;t have the old attribute values so we pretend that we didn&#39;t have the old values.
 570         if (const Attribute* height = findAttributeByName(heightAttr))
 571             attributeChanged(heightAttr, nullAtom(), height-&gt;value());
 572         if (const Attribute* width = findAttributeByName(widthAttr))
 573             attributeChanged(widthAttr, nullAtom(), width-&gt;value());
 574         if (const Attribute* align = findAttributeByName(alignAttr))
 575             attributeChanged(alignAttr, nullAtom(), align-&gt;value());
 576     }
 577 
 578     if (form() &amp;&amp; wasSuccessfulSubmitButtonCandidate != m_inputType-&gt;canBeSuccessfulSubmitButton())
 579         form()-&gt;resetDefaultButton();
 580 
 581     runPostTypeUpdateTasks();
 582 }
 583 
 584 inline void HTMLInputElement::runPostTypeUpdateTasks()
 585 {
 586     ASSERT(m_inputType);
 587 #if ENABLE(TOUCH_EVENTS)
 588     bool hasTouchEventHandler = m_inputType-&gt;hasTouchEventHandler();
 589     if (hasTouchEventHandler != m_hasTouchEventHandler) {
 590         if (hasTouchEventHandler)
 591             document().didAddTouchEventHandler(*this);
 592         else
 593             document().didRemoveTouchEventHandler(*this);
 594         m_hasTouchEventHandler = hasTouchEventHandler;
 595     }
 596 #endif
 597 
 598     if (renderer())
 599         invalidateStyleAndRenderersForSubtree();
 600 
 601     if (document().focusedElement() == this)
 602         updateFocusAppearance(SelectionRestorationMode::Restore, SelectionRevealMode::Reveal);
 603 
 604     setChangedSinceLastFormControlChangeEvent(false);
 605 
 606     addToRadioButtonGroup();
 607 
 608     updateValidity();
 609 }
 610 
 611 void HTMLInputElement::subtreeHasChanged()
 612 {
 613     m_inputType-&gt;subtreeHasChanged();
 614     // When typing in an input field, childrenChanged is not called, so we need to force the directionality check.
 615     calculateAndAdjustDirectionality();
 616 }
 617 
<a name="11" id="anc11"></a><span class="line-modified"> 618 const AtomicString&amp; HTMLInputElement::formControlType() const</span>
 619 {
 620     return m_inputType-&gt;formControlType();
 621 }
 622 
 623 bool HTMLInputElement::shouldSaveAndRestoreFormControlState() const
 624 {
 625     if (!m_inputType-&gt;shouldSaveAndRestoreFormControlState())
 626         return false;
 627     return HTMLTextFormControlElement::shouldSaveAndRestoreFormControlState();
 628 }
 629 
 630 FormControlState HTMLInputElement::saveFormControlState() const
 631 {
 632     return m_inputType-&gt;saveFormControlState();
 633 }
 634 
 635 void HTMLInputElement::restoreFormControlState(const FormControlState&amp; state)
 636 {
 637     m_inputType-&gt;restoreFormControlState(state);
 638     m_stateRestored = true;
 639 }
 640 
 641 bool HTMLInputElement::canStartSelection() const
 642 {
 643     if (!isTextField())
 644         return false;
 645     return HTMLTextFormControlElement::canStartSelection();
 646 }
 647 
 648 bool HTMLInputElement::canHaveSelection() const
 649 {
 650     return isTextField();
 651 }
 652 
 653 void HTMLInputElement::accessKeyAction(bool sendMouseEvents)
 654 {
 655     Ref&lt;InputType&gt; protectedInputType(*m_inputType);
 656     protectedInputType-&gt;accessKeyAction(sendMouseEvents);
 657 }
 658 
 659 bool HTMLInputElement::isPresentationAttribute(const QualifiedName&amp; name) const
 660 {
 661     if (name == vspaceAttr || name == hspaceAttr || name == widthAttr || name == heightAttr || (name == borderAttr &amp;&amp; isImageButton()))
 662         return true;
 663     return HTMLTextFormControlElement::isPresentationAttribute(name);
 664 }
 665 
<a name="12" id="anc12"></a><span class="line-modified"> 666 void HTMLInputElement::collectStyleForPresentationAttribute(const QualifiedName&amp; name, const AtomicString&amp; value, MutableStyleProperties&amp; style)</span>
 667 {
 668     if (name == vspaceAttr) {
 669         addHTMLLengthToStyle(style, CSSPropertyMarginTop, value);
 670         addHTMLLengthToStyle(style, CSSPropertyMarginBottom, value);
 671     } else if (name == hspaceAttr) {
 672         addHTMLLengthToStyle(style, CSSPropertyMarginLeft, value);
 673         addHTMLLengthToStyle(style, CSSPropertyMarginRight, value);
 674     } else if (name == alignAttr) {
 675         if (m_inputType-&gt;shouldRespectAlignAttribute())
 676             applyAlignmentAttributeToStyle(value, style);
 677     } else if (name == widthAttr) {
 678         if (m_inputType-&gt;shouldRespectHeightAndWidthAttributes())
 679             addHTMLLengthToStyle(style, CSSPropertyWidth, value);
 680     } else if (name == heightAttr) {
 681         if (m_inputType-&gt;shouldRespectHeightAndWidthAttributes())
 682             addHTMLLengthToStyle(style, CSSPropertyHeight, value);
 683     } else if (name == borderAttr &amp;&amp; isImageButton())
 684         applyBorderAttributeToStyle(value, style);
 685     else
 686         HTMLTextFormControlElement::collectStyleForPresentationAttribute(name, value, style);
 687 }
 688 
 689 inline void HTMLInputElement::initializeInputType()
 690 {
 691     ASSERT(m_parsingInProgress);
 692     ASSERT(!m_inputType);
 693 
<a name="13" id="anc13"></a><span class="line-modified"> 694     const AtomicString&amp; type = attributeWithoutSynchronization(typeAttr);</span>
 695     if (type.isNull()) {
 696         m_inputType = InputType::createText(*this);
 697         ensureUserAgentShadowRoot();
 698         setNeedsWillValidateCheck();
 699         return;
 700     }
 701 
 702     m_hasType = true;
 703     m_inputType = InputType::create(*this, type);
 704     ensureUserAgentShadowRoot();
 705     setNeedsWillValidateCheck();
 706     registerForSuspensionCallbackIfNeeded();
 707     runPostTypeUpdateTasks();
 708 }
 709 
<a name="14" id="anc14"></a><span class="line-modified"> 710 void HTMLInputElement::parseAttribute(const QualifiedName&amp; name, const AtomicString&amp; value)</span>
 711 {
 712     ASSERT(m_inputType);
 713     Ref&lt;InputType&gt; protectedInputType(*m_inputType);
 714 
 715     if (name == nameAttr) {
 716         removeFromRadioButtonGroup();
 717         m_name = value;
 718         addToRadioButtonGroup();
 719         HTMLTextFormControlElement::parseAttribute(name, value);
 720     } else if (name == autocompleteAttr) {
 721         if (equalLettersIgnoringASCIICase(value, &quot;off&quot;)) {
 722             m_autocomplete = Off;
 723             registerForSuspensionCallbackIfNeeded();
 724         } else {
 725             bool needsToUnregister = m_autocomplete == Off;
 726 
 727             if (value.isEmpty())
 728                 m_autocomplete = Uninitialized;
 729             else
 730                 m_autocomplete = On;
 731 
 732             if (needsToUnregister)
 733                 unregisterForSuspensionCallbackIfNeeded();
 734         }
 735     } else if (name == typeAttr)
 736         updateType();
 737     else if (name == valueAttr) {
 738         // Changes to the value attribute may change whether or not this element has a default value.
 739         // If this field is autocomplete=off that might affect the return value of needsSuspensionCallback.
 740         if (m_autocomplete == Off) {
 741             unregisterForSuspensionCallbackIfNeeded();
 742             registerForSuspensionCallbackIfNeeded();
 743         }
 744         // We only need to setChanged if the form is looking at the default value right now.
 745         if (!hasDirtyValue()) {
 746             updatePlaceholderVisibility();
 747             invalidateStyleForSubtree();
 748         }
 749         setFormControlValueMatchesRenderer(false);
 750         updateValidity();
 751         m_valueAttributeWasUpdatedAfterParsing = !m_parsingInProgress;
 752     } else if (name == checkedAttr) {
 753         if (m_inputType-&gt;isCheckable())
 754             invalidateStyleForSubtree();
 755 
 756         // Another radio button in the same group might be checked by state
 757         // restore. We shouldn&#39;t call setChecked() even if this has the checked
 758         // attribute. So, delay the setChecked() call until
 759         // finishParsingChildren() is called if parsing is in progress.
 760         if ((!m_parsingInProgress || !document().formController().hasFormStateToRestore()) &amp;&amp; !m_dirtyCheckednessFlag) {
 761             setChecked(!value.isNull());
 762             // setChecked() above sets the dirty checkedness flag so we need to reset it.
 763             m_dirtyCheckednessFlag = false;
 764         }
 765     } else if (name == maxlengthAttr)
 766         maxLengthAttributeChanged(value);
 767     else if (name == minlengthAttr)
 768         minLengthAttributeChanged(value);
 769     else if (name == sizeAttr) {
 770         unsigned oldSize = m_size;
 771         m_size = limitToOnlyHTMLNonNegativeNumbersGreaterThanZero(value, defaultSize);
 772         if (m_size != oldSize &amp;&amp; renderer())
 773             renderer()-&gt;setNeedsLayoutAndPrefWidthsRecalc();
 774     } else if (name == resultsAttr)
 775         m_maxResults = !value.isNull() ? std::min(value.toInt(), maxSavedResults) : -1;
 776     else if (name == autosaveAttr || name == incrementalAttr)
 777         invalidateStyleForSubtree();
 778     else if (name == maxAttr || name == minAttr || name == multipleAttr || name == patternAttr || name == precisionAttr || name == stepAttr)
 779         updateValidity();
 780 #if ENABLE(DATALIST_ELEMENT)
 781     else if (name == listAttr) {
 782         m_hasNonEmptyList = !value.isEmpty();
 783         if (m_hasNonEmptyList) {
 784             resetListAttributeTargetObserver();
 785             listAttributeTargetChanged();
 786         }
 787     }
 788 #endif
 789     else
 790         HTMLTextFormControlElement::parseAttribute(name, value);
 791 
 792     m_inputType-&gt;attributeChanged(name);
 793 }
 794 
 795 void HTMLInputElement::disabledStateChanged()
 796 {
 797     HTMLTextFormControlElement::disabledStateChanged();
 798     m_inputType-&gt;disabledStateChanged();
 799 }
 800 
 801 void HTMLInputElement::readOnlyStateChanged()
 802 {
 803     HTMLTextFormControlElement::readOnlyStateChanged();
 804     m_inputType-&gt;readOnlyStateChanged();
 805 }
 806 
 807 void HTMLInputElement::parserDidSetAttributes()
 808 {
 809     ASSERT(m_parsingInProgress);
 810     initializeInputType();
 811 }
 812 
 813 void HTMLInputElement::finishParsingChildren()
 814 {
 815     m_parsingInProgress = false;
 816     ASSERT(m_inputType);
 817     HTMLTextFormControlElement::finishParsingChildren();
 818     if (!m_stateRestored) {
 819         bool checked = hasAttributeWithoutSynchronization(checkedAttr);
 820         if (checked)
 821             setChecked(checked);
 822         m_dirtyCheckednessFlag = false;
 823     }
 824 }
 825 
 826 bool HTMLInputElement::rendererIsNeeded(const RenderStyle&amp; style)
 827 {
 828     return m_inputType-&gt;rendererIsNeeded() &amp;&amp; HTMLTextFormControlElement::rendererIsNeeded(style);
 829 }
 830 
 831 RenderPtr&lt;RenderElement&gt; HTMLInputElement::createElementRenderer(RenderStyle&amp;&amp; style, const RenderTreePosition&amp;)
 832 {
 833     return m_inputType-&gt;createInputRenderer(WTFMove(style));
 834 }
 835 
 836 void HTMLInputElement::willAttachRenderers()
 837 {
 838     if (!m_hasType)
 839         updateType();
 840 }
 841 
 842 void HTMLInputElement::didAttachRenderers()
 843 {
 844     HTMLTextFormControlElement::didAttachRenderers();
 845 
 846     m_inputType-&gt;attach();
 847 
 848     if (document().focusedElement() == this) {
 849         document().view()-&gt;queuePostLayoutCallback([protectedThis = makeRef(*this)] {
 850             protectedThis-&gt;updateFocusAppearance(SelectionRestorationMode::Restore, SelectionRevealMode::Reveal);
 851         });
 852     }
 853 }
 854 
 855 void HTMLInputElement::didDetachRenderers()
 856 {
 857     setFormControlValueMatchesRenderer(false);
 858     m_inputType-&gt;detach();
 859 }
 860 
 861 String HTMLInputElement::altText() const
 862 {
 863     // http://www.w3.org/TR/1998/REC-html40-19980424/appendix/notes.html#altgen
 864     // also heavily discussed by Hixie on bugzilla
 865     // note this is intentionally different to HTMLImageElement::altText()
 866     String alt = attributeWithoutSynchronization(altAttr);
 867     // fall back to title attribute
 868     if (alt.isNull())
 869         alt = attributeWithoutSynchronization(titleAttr);
 870     if (alt.isNull())
 871         alt = attributeWithoutSynchronization(valueAttr);
 872     if (alt.isEmpty())
 873         alt = inputElementAltText();
 874     return alt;
 875 }
 876 
 877 bool HTMLInputElement::isSuccessfulSubmitButton() const
 878 {
 879     // HTML spec says that buttons must have names to be considered successful.
 880     // However, other browsers do not impose this constraint. So we do not.
 881     return !isDisabledFormControl() &amp;&amp; m_inputType-&gt;canBeSuccessfulSubmitButton();
 882 }
 883 
 884 bool HTMLInputElement::matchesDefaultPseudoClass() const
 885 {
 886     ASSERT(m_inputType);
 887     if (m_inputType-&gt;canBeSuccessfulSubmitButton())
 888         return !isDisabledFormControl() &amp;&amp; form() &amp;&amp; form()-&gt;defaultButton() == this;
 889     return m_inputType-&gt;isCheckable() &amp;&amp; hasAttributeWithoutSynchronization(checkedAttr);
 890 }
 891 
 892 bool HTMLInputElement::isActivatedSubmit() const
 893 {
 894     return m_isActivatedSubmit;
 895 }
 896 
 897 void HTMLInputElement::setActivatedSubmit(bool flag)
 898 {
 899     m_isActivatedSubmit = flag;
 900 }
 901 
 902 bool HTMLInputElement::appendFormData(DOMFormData&amp; formData, bool multipart)
 903 {
 904     Ref&lt;InputType&gt; protectedInputType(*m_inputType);
 905     return m_inputType-&gt;isFormDataAppendable() &amp;&amp; m_inputType-&gt;appendFormData(formData, multipart);
 906 }
 907 
 908 void HTMLInputElement::reset()
 909 {
 910     if (m_inputType-&gt;storesValueSeparateFromAttribute())
 911         setValue(String());
 912 
 913     setAutoFilled(false);
<a name="15" id="anc15"></a>
 914     setShowAutoFillButton(AutoFillButtonType::None);
 915     setChecked(hasAttributeWithoutSynchronization(checkedAttr));
 916     m_dirtyCheckednessFlag = false;
 917 }
 918 
 919 bool HTMLInputElement::isTextField() const
 920 {
 921     return m_inputType-&gt;isTextField();
 922 }
 923 
 924 bool HTMLInputElement::isTextType() const
 925 {
 926     return m_inputType-&gt;isTextType();
 927 }
 928 
 929 void HTMLInputElement::setChecked(bool nowChecked)
 930 {
 931     if (checked() == nowChecked)
 932         return;
 933 
 934     m_dirtyCheckednessFlag = true;
 935     m_isChecked = nowChecked;
 936     invalidateStyleForSubtree();
 937 
 938     if (RadioButtonGroups* buttons = radioButtonGroups())
 939         buttons-&gt;updateCheckedState(*this);
 940     if (renderer() &amp;&amp; renderer()-&gt;style().hasAppearance())
 941         renderer()-&gt;theme().stateChanged(*renderer(), ControlStates::CheckedState);
 942     updateValidity();
 943 
 944     // Ideally we&#39;d do this from the render tree (matching
 945     // RenderTextView), but it&#39;s not possible to do it at the moment
 946     // because of the way the code is structured.
 947     if (renderer()) {
 948         if (AXObjectCache* cache = renderer()-&gt;document().existingAXObjectCache())
 949             cache-&gt;checkedStateChanged(this);
 950     }
 951 
 952     invalidateStyleForSubtree();
 953 }
 954 
 955 void HTMLInputElement::setIndeterminate(bool newValue)
 956 {
 957     if (indeterminate() == newValue)
 958         return;
 959 
 960     m_isIndeterminate = newValue;
 961 
 962     invalidateStyleForSubtree();
 963 
 964     if (renderer() &amp;&amp; renderer()-&gt;style().hasAppearance())
 965         renderer()-&gt;theme().stateChanged(*renderer(), ControlStates::CheckedState);
 966 }
 967 
 968 unsigned HTMLInputElement::size() const
 969 {
 970     return m_size;
 971 }
 972 
 973 bool HTMLInputElement::sizeShouldIncludeDecoration(int&amp; preferredSize) const
 974 {
 975     return m_inputType-&gt;sizeShouldIncludeDecoration(defaultSize, preferredSize);
 976 }
 977 
 978 float HTMLInputElement::decorationWidth() const
 979 {
 980     return m_inputType-&gt;decorationWidth();
 981 }
 982 
 983 void HTMLInputElement::copyNonAttributePropertiesFromElement(const Element&amp; source)
 984 {
 985     auto&amp; sourceElement = downcast&lt;HTMLInputElement&gt;(source);
 986 
 987     m_valueIfDirty = sourceElement.m_valueIfDirty;
 988     m_wasModifiedByUser = false;
 989     setChecked(sourceElement.m_isChecked);
 990     m_dirtyCheckednessFlag = sourceElement.m_dirtyCheckednessFlag;
 991     m_isIndeterminate = sourceElement.m_isIndeterminate;
 992 
 993     HTMLTextFormControlElement::copyNonAttributePropertiesFromElement(source);
 994 
 995     updateValidity();
 996     setFormControlValueMatchesRenderer(false);
 997     m_inputType-&gt;updateInnerTextValue();
 998 }
 999 
1000 String HTMLInputElement::value() const
1001 {
1002     String value;
1003     if (m_inputType-&gt;getTypeSpecificValue(value))
1004         return value;
1005 
1006     value = m_valueIfDirty;
1007     if (!value.isNull())
1008         return value;
1009 
1010     auto&amp; valueString = attributeWithoutSynchronization(valueAttr);
1011     value = sanitizeValue(valueString);
1012     if (!value.isNull())
1013         return value;
1014 
1015     return m_inputType-&gt;fallbackValue();
1016 }
1017 
1018 String HTMLInputElement::valueWithDefault() const
1019 {
1020     String value = this-&gt;value();
1021     if (!value.isNull())
1022         return value;
1023 
1024     return m_inputType-&gt;defaultValue();
1025 }
1026 
1027 void HTMLInputElement::setValueForUser(const String&amp; value)
1028 {
1029     // Call setValue and make it send a change event.
1030     setValue(value, DispatchChangeEvent);
1031 }
1032 
1033 ExceptionOr&lt;void&gt; HTMLInputElement::setValue(const String&amp; value, TextFieldEventBehavior eventBehavior)
1034 {
1035     if (isFileUpload() &amp;&amp; !value.isEmpty())
1036         return Exception { InvalidStateError };
1037 
1038     if (!m_inputType-&gt;canSetValue(value))
1039         return { };
1040 
1041     Ref&lt;HTMLInputElement&gt; protectedThis(*this);
1042     EventQueueScope scope;
1043     String sanitizedValue = sanitizeValue(value);
1044     bool valueChanged = sanitizedValue != this-&gt;value();
1045 
1046     setLastChangeWasNotUserEdit();
1047     setFormControlValueMatchesRenderer(false);
1048     m_inputType-&gt;setValue(sanitizedValue, valueChanged, eventBehavior);
1049 
1050     bool wasModifiedProgrammatically = eventBehavior == DispatchNoEvent;
1051     if (wasModifiedProgrammatically)
1052         resignStrongPasswordAppearance();
1053     return { };
1054 }
1055 
1056 void HTMLInputElement::setValueInternal(const String&amp; sanitizedValue, TextFieldEventBehavior eventBehavior)
1057 {
1058     m_valueIfDirty = sanitizedValue;
1059     m_wasModifiedByUser = eventBehavior != DispatchNoEvent;
1060     updateValidity();
1061 }
1062 
1063 double HTMLInputElement::valueAsDate() const
1064 {
1065     return m_inputType-&gt;valueAsDate();
1066 }
1067 
1068 ExceptionOr&lt;void&gt; HTMLInputElement::setValueAsDate(double value)
1069 {
1070     return m_inputType-&gt;setValueAsDate(value);
1071 }
1072 
1073 double HTMLInputElement::valueAsNumber() const
1074 {
1075     return m_inputType-&gt;valueAsDouble();
1076 }
1077 
1078 ExceptionOr&lt;void&gt; HTMLInputElement::setValueAsNumber(double newValue, TextFieldEventBehavior eventBehavior)
1079 {
1080     if (!std::isfinite(newValue))
1081         return Exception { NotSupportedError };
1082     return m_inputType-&gt;setValueAsDouble(newValue, eventBehavior);
1083 }
1084 
1085 void HTMLInputElement::setValueFromRenderer(const String&amp; value)
1086 {
1087     // File upload controls will never use this.
1088     ASSERT(!isFileUpload());
1089 
1090     // Renderer and our event handler are responsible for sanitizing values.
1091     // Input types that support the selection API do *not* sanitize their
1092     // user input in order to retain parity between what&#39;s in the model and
1093     // what&#39;s on the screen.
1094     ASSERT(m_inputType-&gt;supportsSelectionAPI() || value == sanitizeValue(value) || sanitizeValue(value).isEmpty());
1095 
1096     // Workaround for bug where trailing \n is included in the result of textContent.
1097     // The assert macro above may also be simplified by removing the expression
1098     // that calls isEmpty.
1099     // http://bugs.webkit.org/show_bug.cgi?id=9661
1100     m_valueIfDirty = value == &quot;\n&quot; ? emptyString() : value;
1101 
1102     setFormControlValueMatchesRenderer(true);
1103     m_wasModifiedByUser = true;
1104 
1105     // Input event is fired by the Node::defaultEventHandler for editable controls.
1106     if (!isTextField())
1107         dispatchInputEvent();
1108 
1109     updateValidity();
1110 
1111     // Clear auto fill flag (and yellow background) on user edit.
1112     setAutoFilled(false);
1113 }
1114 
1115 void HTMLInputElement::willDispatchEvent(Event&amp; event, InputElementClickState&amp; state)
1116 {
1117     if (event.type() == eventNames().textInputEvent &amp;&amp; m_inputType-&gt;shouldSubmitImplicitly(event))
1118         event.stopPropagation();
1119     if (event.type() == eventNames().clickEvent &amp;&amp; is&lt;MouseEvent&gt;(event) &amp;&amp; downcast&lt;MouseEvent&gt;(event).button() == LeftButton) {
1120         m_inputType-&gt;willDispatchClick(state);
1121         state.stateful = true;
1122     }
1123 }
1124 
1125 void HTMLInputElement::didDispatchClickEvent(Event&amp; event, const InputElementClickState&amp; state)
1126 {
1127     m_inputType-&gt;didDispatchClick(event, state);
1128 }
1129 
1130 void HTMLInputElement::didBlur()
1131 {
1132     m_inputType-&gt;elementDidBlur();
1133 }
1134 
1135 void HTMLInputElement::defaultEventHandler(Event&amp; event)
1136 {
1137     if (is&lt;MouseEvent&gt;(event) &amp;&amp; event.type() == eventNames().clickEvent &amp;&amp; downcast&lt;MouseEvent&gt;(event).button() == LeftButton) {
1138         m_inputType-&gt;handleClickEvent(downcast&lt;MouseEvent&gt;(event));
1139         if (event.defaultHandled())
1140             return;
1141     }
1142 
1143 #if ENABLE(TOUCH_EVENTS)
1144     if (is&lt;TouchEvent&gt;(event)) {
1145         m_inputType-&gt;handleTouchEvent(downcast&lt;TouchEvent&gt;(event));
1146         if (event.defaultHandled())
1147             return;
1148     }
1149 #endif
1150 
1151     if (is&lt;KeyboardEvent&gt;(event) &amp;&amp; event.type() == eventNames().keydownEvent) {
<a name="16" id="anc16"></a><span class="line-modified">1152         m_inputType-&gt;handleKeydownEvent(downcast&lt;KeyboardEvent&gt;(event));</span>
<span class="line-modified">1153         if (event.defaultHandled())</span>
1154             return;
1155     }
1156 
1157     // Call the base event handler before any of our own event handling for almost all events in text fields.
1158     // Makes editing keyboard handling take precedence over the keydown and keypress handling in this function.
1159     bool callBaseClassEarly = isTextField() &amp;&amp; (event.type() == eventNames().keydownEvent || event.type() == eventNames().keypressEvent);
1160     if (callBaseClassEarly) {
1161         HTMLTextFormControlElement::defaultEventHandler(event);
1162         if (event.defaultHandled())
1163             return;
1164     }
1165 
1166     // DOMActivate events cause the input to be &quot;activated&quot; - in the case of image and submit inputs, this means
1167     // actually submitting the form. For reset inputs, the form is reset. These events are sent when the user clicks
1168     // on the element, or presses enter while it is the active element. JavaScript code wishing to activate the element
1169     // must dispatch a DOMActivate event - a click event will not do the job.
1170     if (event.type() == eventNames().DOMActivateEvent) {
1171         m_inputType-&gt;handleDOMActivateEvent(event);
1172         if (event.defaultHandled())
1173             return;
1174     }
1175 
1176     // Use key press event here since sending simulated mouse events
1177     // on key down blocks the proper sending of the key press event.
1178     if (is&lt;KeyboardEvent&gt;(event)) {
1179         KeyboardEvent&amp; keyboardEvent = downcast&lt;KeyboardEvent&gt;(event);
1180         if (keyboardEvent.type() == eventNames().keypressEvent) {
1181             m_inputType-&gt;handleKeypressEvent(keyboardEvent);
1182             if (keyboardEvent.defaultHandled())
1183                 return;
1184         } else if (keyboardEvent.type() == eventNames().keyupEvent) {
1185             m_inputType-&gt;handleKeyupEvent(keyboardEvent);
1186             if (keyboardEvent.defaultHandled())
1187                 return;
1188         }
1189     }
1190 
1191     if (m_inputType-&gt;shouldSubmitImplicitly(event)) {
1192         if (isSearchField()) {
1193             addSearchResult();
1194             onSearch();
1195         }
1196         // Form submission finishes editing, just as loss of focus does.
1197         // If there was a change, send the event now.
1198         if (wasChangedSinceLastFormControlChangeEvent())
1199             dispatchFormControlChangeEvent();
1200 
1201         // Form may never have been present, or may have been destroyed by code responding to the change event.
1202         if (auto formElement = makeRefPtr(form()))
1203             formElement-&gt;submitImplicitly(event, canTriggerImplicitSubmission());
1204 
1205         event.setDefaultHandled();
1206         return;
1207     }
1208 
1209     if (is&lt;BeforeTextInsertedEvent&gt;(event))
1210         m_inputType-&gt;handleBeforeTextInsertedEvent(downcast&lt;BeforeTextInsertedEvent&gt;(event));
1211 
1212     if (is&lt;MouseEvent&gt;(event) &amp;&amp; event.type() == eventNames().mousedownEvent) {
1213         m_inputType-&gt;handleMouseDownEvent(downcast&lt;MouseEvent&gt;(event));
1214         if (event.defaultHandled())
1215             return;
1216     }
1217 
1218     m_inputType-&gt;forwardEvent(event);
1219 
1220     if (!callBaseClassEarly &amp;&amp; !event.defaultHandled())
1221         HTMLTextFormControlElement::defaultEventHandler(event);
1222 }
1223 
1224 bool HTMLInputElement::willRespondToMouseClickEvents()
1225 {
1226     if (!isDisabledFormControl())
1227         return true;
1228 
1229     return HTMLTextFormControlElement::willRespondToMouseClickEvents();
1230 }
1231 
1232 bool HTMLInputElement::isURLAttribute(const Attribute&amp; attribute) const
1233 {
1234     return attribute.name() == srcAttr || attribute.name() == formactionAttr || HTMLTextFormControlElement::isURLAttribute(attribute);
1235 }
1236 
1237 String HTMLInputElement::defaultValue() const
1238 {
1239     return attributeWithoutSynchronization(valueAttr);
1240 }
1241 
1242 void HTMLInputElement::setDefaultValue(const String &amp;value)
1243 {
1244     setAttributeWithoutSynchronization(valueAttr, value);
1245 }
1246 
1247 static inline bool isRFC2616TokenCharacter(UChar ch)
1248 {
1249     return isASCII(ch) &amp;&amp; ch &gt; &#39; &#39; &amp;&amp; ch != &#39;&quot;&#39; &amp;&amp; ch != &#39;(&#39; &amp;&amp; ch != &#39;)&#39; &amp;&amp; ch != &#39;,&#39; &amp;&amp; ch != &#39;/&#39; &amp;&amp; (ch &lt; &#39;:&#39; || ch &gt; &#39;@&#39;) &amp;&amp; (ch &lt; &#39;[&#39; || ch &gt; &#39;]&#39;) &amp;&amp; ch != &#39;{&#39; &amp;&amp; ch != &#39;}&#39; &amp;&amp; ch != 0x7f;
1250 }
1251 
1252 static bool isValidMIMEType(const String&amp; type)
1253 {
1254     size_t slashPosition = type.find(&#39;/&#39;);
1255     if (slashPosition == notFound || !slashPosition || slashPosition == type.length() - 1)
1256         return false;
1257     for (size_t i = 0; i &lt; type.length(); ++i) {
1258         if (!isRFC2616TokenCharacter(type[i]) &amp;&amp; i != slashPosition)
1259             return false;
1260     }
1261     return true;
1262 }
1263 
1264 static bool isValidFileExtension(const String&amp; type)
1265 {
1266     if (type.length() &lt; 2)
1267         return false;
1268     return type[0] == &#39;.&#39;;
1269 }
1270 
1271 static Vector&lt;String&gt; parseAcceptAttribute(const String&amp; acceptString, bool (*predicate)(const String&amp;))
1272 {
1273     Vector&lt;String&gt; types;
1274     if (acceptString.isEmpty())
1275         return types;
1276 
1277     for (auto&amp; splitType : acceptString.split(&#39;,&#39;)) {
1278         String trimmedType = stripLeadingAndTrailingHTMLSpaces(splitType);
1279         if (trimmedType.isEmpty())
1280             continue;
1281         if (!predicate(trimmedType))
1282             continue;
1283         types.append(trimmedType.convertToASCIILowercase());
1284     }
1285 
1286     return types;
1287 }
1288 
1289 Vector&lt;String&gt; HTMLInputElement::acceptMIMETypes()
1290 {
1291     return parseAcceptAttribute(attributeWithoutSynchronization(acceptAttr), isValidMIMEType);
1292 }
1293 
1294 Vector&lt;String&gt; HTMLInputElement::acceptFileExtensions()
1295 {
1296     return parseAcceptAttribute(attributeWithoutSynchronization(acceptAttr), isValidFileExtension);
1297 }
1298 
1299 String HTMLInputElement::accept() const
1300 {
1301     return attributeWithoutSynchronization(acceptAttr);
1302 }
1303 
1304 String HTMLInputElement::alt() const
1305 {
1306     return attributeWithoutSynchronization(altAttr);
1307 }
1308 
1309 unsigned HTMLInputElement::effectiveMaxLength() const
1310 {
1311     // The number -1 represents no maximum at all; conveniently it becomes a super-large value when converted to unsigned.
1312     return std::min&lt;unsigned&gt;(maxLength(), maxEffectiveLength);
1313 }
1314 
1315 bool HTMLInputElement::multiple() const
1316 {
1317     return hasAttributeWithoutSynchronization(multipleAttr);
1318 }
1319 
1320 ExceptionOr&lt;void&gt; HTMLInputElement::setSize(unsigned size)
1321 {
1322     if (!size)
1323         return Exception { IndexSizeError };
1324     setUnsignedIntegralAttribute(sizeAttr, limitToOnlyHTMLNonNegativeNumbersGreaterThanZero(size, defaultSize));
1325     return { };
1326 }
1327 
1328 URL HTMLInputElement::src() const
1329 {
1330     return document().completeURL(attributeWithoutSynchronization(srcAttr));
1331 }
1332 
1333 void HTMLInputElement::setAutoFilled(bool autoFilled)
1334 {
1335     if (autoFilled == m_isAutoFilled)
1336         return;
1337 
1338     m_isAutoFilled = autoFilled;
1339     invalidateStyleForSubtree();
1340 }
1341 
<a name="17" id="anc17"></a>








1342 void HTMLInputElement::setShowAutoFillButton(AutoFillButtonType autoFillButtonType)
1343 {
1344     if (static_cast&lt;uint8_t&gt;(autoFillButtonType) == m_autoFillButtonType)
1345         return;
1346 
1347     m_lastAutoFillButtonType = m_autoFillButtonType;
1348     m_autoFillButtonType = static_cast&lt;uint8_t&gt;(autoFillButtonType);
1349     m_inputType-&gt;updateAutoFillButton();
1350     updateInnerTextElementEditability();
1351     invalidateStyleForSubtree();
1352 }
1353 
1354 FileList* HTMLInputElement::files()
1355 {
1356     return m_inputType-&gt;files();
1357 }
1358 
1359 void HTMLInputElement::setFiles(RefPtr&lt;FileList&gt;&amp;&amp; files)
1360 {
1361     m_inputType-&gt;setFiles(WTFMove(files));
1362 }
1363 
1364 #if ENABLE(DRAG_SUPPORT)
1365 bool HTMLInputElement::receiveDroppedFiles(const DragData&amp; dragData)
1366 {
1367     return m_inputType-&gt;receiveDroppedFiles(dragData);
1368 }
1369 #endif
1370 
1371 Icon* HTMLInputElement::icon() const
1372 {
1373     return m_inputType-&gt;icon();
1374 }
1375 
1376 String HTMLInputElement::displayString() const
1377 {
1378     return m_inputType-&gt;displayString();
1379 }
1380 
1381 bool HTMLInputElement::canReceiveDroppedFiles() const
1382 {
1383     return m_canReceiveDroppedFiles;
1384 }
1385 
1386 void HTMLInputElement::setCanReceiveDroppedFiles(bool canReceiveDroppedFiles)
1387 {
1388     if (m_canReceiveDroppedFiles == canReceiveDroppedFiles)
1389         return;
1390     m_canReceiveDroppedFiles = canReceiveDroppedFiles;
1391     if (renderer())
1392         renderer()-&gt;updateFromElement();
1393 }
1394 
1395 String HTMLInputElement::visibleValue() const
1396 {
1397     return m_inputType-&gt;visibleValue();
1398 }
1399 
1400 String HTMLInputElement::sanitizeValue(const String&amp; proposedValue) const
1401 {
1402     if (proposedValue.isNull())
1403         return proposedValue;
1404     return m_inputType-&gt;sanitizeValue(proposedValue);
1405 }
1406 
1407 String HTMLInputElement::localizeValue(const String&amp; proposedValue) const
1408 {
1409     if (proposedValue.isNull())
1410         return proposedValue;
1411     return m_inputType-&gt;localizeValue(proposedValue);
1412 }
1413 
1414 bool HTMLInputElement::isInRange() const
1415 {
1416     return willValidate() &amp;&amp; m_inputType-&gt;isInRange(value());
1417 }
1418 
1419 bool HTMLInputElement::isOutOfRange() const
1420 {
1421     return willValidate() &amp;&amp; m_inputType-&gt;isOutOfRange(value());
1422 }
1423 
1424 bool HTMLInputElement::needsSuspensionCallback()
1425 {
1426     if (m_inputType-&gt;shouldResetOnDocumentActivation())
1427         return true;
1428 
1429     // Sensitive input elements are marked with autocomplete=off, and we want to wipe them out
1430     // when going back; returning true here arranges for us to call reset at the time
1431     // the page is restored. Non-empty textual default values indicate that the field
1432     // is not really sensitive -- there&#39;s no default value for an account number --
1433     // and we would see unexpected results if we reset to something other than blank.
1434     bool isSensitive = m_autocomplete == Off &amp;&amp; !(m_inputType-&gt;isTextType() &amp;&amp; !defaultValue().isEmpty());
1435 
1436     return isSensitive;
1437 }
1438 
1439 void HTMLInputElement::registerForSuspensionCallbackIfNeeded()
1440 {
1441     if (needsSuspensionCallback())
1442         document().registerForDocumentSuspensionCallbacks(*this);
1443 }
1444 
1445 void HTMLInputElement::unregisterForSuspensionCallbackIfNeeded()
1446 {
1447     if (!needsSuspensionCallback())
1448         document().unregisterForDocumentSuspensionCallbacks(*this);
1449 }
1450 
1451 bool HTMLInputElement::isRequiredFormControl() const
1452 {
1453     return m_inputType-&gt;supportsRequired() &amp;&amp; isRequired();
1454 }
1455 
1456 bool HTMLInputElement::matchesReadWritePseudoClass() const
1457 {
1458     return m_inputType-&gt;supportsReadOnly() &amp;&amp; !isDisabledOrReadOnly();
1459 }
1460 
1461 void HTMLInputElement::addSearchResult()
1462 {
1463     m_inputType-&gt;addSearchResult();
1464 }
1465 
1466 void HTMLInputElement::onSearch()
1467 {
1468     // The type of the input element could have changed during event handling. If we are no longer
1469     // a search field, don&#39;t try to do search things.
1470     if (!isSearchField())
1471         return;
1472 
1473     if (m_inputType)
1474         downcast&lt;SearchInputType&gt;(*m_inputType.get()).stopSearchEventTimer();
1475     dispatchEvent(Event::create(eventNames().searchEvent, Event::CanBubble::Yes, Event::IsCancelable::No));
1476 }
1477 
1478 void HTMLInputElement::resumeFromDocumentSuspension()
1479 {
1480     ASSERT(needsSuspensionCallback());
1481 
1482 #if ENABLE(INPUT_TYPE_COLOR)
1483     // &lt;input type=color&gt; uses prepareForDocumentSuspension to detach the color picker UI,
1484     // so it should not be reset when being loaded from page cache.
1485     if (isColorControl())
1486         return;
1487 #endif // ENABLE(INPUT_TYPE_COLOR)
<a name="18" id="anc18"></a><span class="line-modified">1488     reset();</span>


1489 }
1490 
1491 #if ENABLE(INPUT_TYPE_COLOR)
1492 void HTMLInputElement::prepareForDocumentSuspension()
1493 {
1494     if (!isColorControl())
1495         return;
1496     m_inputType-&gt;detach();
1497 }
1498 #endif // ENABLE(INPUT_TYPE_COLOR)
1499 
1500 
1501 void HTMLInputElement::willChangeForm()
1502 {
1503     removeFromRadioButtonGroup();
1504     HTMLTextFormControlElement::willChangeForm();
1505 }
1506 
1507 void HTMLInputElement::didChangeForm()
1508 {
1509     HTMLTextFormControlElement::didChangeForm();
1510     addToRadioButtonGroup();
1511 }
1512 
1513 Node::InsertedIntoAncestorResult HTMLInputElement::insertedIntoAncestor(InsertionType insertionType, ContainerNode&amp; parentOfInsertedTree)
1514 {
1515     HTMLTextFormControlElement::insertedIntoAncestor(insertionType, parentOfInsertedTree);
1516 #if ENABLE(DATALIST_ELEMENT)
1517     resetListAttributeTargetObserver();
1518 #endif
1519     return InsertedIntoAncestorResult::NeedsPostInsertionCallback;
1520 }
1521 
1522 void HTMLInputElement::didFinishInsertingNode()
1523 {
1524     HTMLTextFormControlElement::didFinishInsertingNode();
1525     if (isConnected() &amp;&amp; !form())
1526         addToRadioButtonGroup();
1527 }
1528 
1529 void HTMLInputElement::removedFromAncestor(RemovalType removalType, ContainerNode&amp; oldParentOfRemovedTree)
1530 {
1531     if (removalType.disconnectedFromDocument &amp;&amp; !form())
1532         removeFromRadioButtonGroup();
1533     HTMLTextFormControlElement::removedFromAncestor(removalType, oldParentOfRemovedTree);
1534     ASSERT(!isConnected());
1535 #if ENABLE(DATALIST_ELEMENT)
1536     resetListAttributeTargetObserver();
1537 #endif
1538 }
1539 
1540 void HTMLInputElement::didMoveToNewDocument(Document&amp; oldDocument, Document&amp; newDocument)
1541 {
1542     if (imageLoader())
1543         imageLoader()-&gt;elementDidMoveToNewDocument();
1544 
1545     // Always unregister for cache callbacks when leaving a document, even if we would otherwise like to be registered
1546     if (needsSuspensionCallback()) {
1547         oldDocument.unregisterForDocumentSuspensionCallbacks(*this);
1548         newDocument.registerForDocumentSuspensionCallbacks(*this);
1549     }
<a name="19" id="anc19"></a>


1550     if (isRadioButton())
1551         oldDocument.formController().radioButtonGroups().removeButton(*this);
<a name="20" id="anc20"></a>
1552 #if ENABLE(TOUCH_EVENTS)
1553     if (m_hasTouchEventHandler) {
1554         oldDocument.didRemoveEventTargetNode(*this);
1555         newDocument.didAddTouchEventHandler(*this);
1556     }
1557 #endif
1558 
1559     HTMLTextFormControlElement::didMoveToNewDocument(oldDocument, newDocument);
1560 }
1561 
1562 void HTMLInputElement::addSubresourceAttributeURLs(ListHashSet&lt;URL&gt;&amp; urls) const
1563 {
1564     HTMLTextFormControlElement::addSubresourceAttributeURLs(urls);
1565 
1566     addSubresourceURL(urls, src());
1567 }
1568 
1569 bool HTMLInputElement::computeWillValidate() const
1570 {
1571     return m_inputType-&gt;supportsValidation() &amp;&amp; HTMLTextFormControlElement::computeWillValidate();
1572 }
1573 
1574 void HTMLInputElement::requiredStateChanged()
1575 {
1576     HTMLTextFormControlElement::requiredStateChanged();
1577     if (auto* buttons = radioButtonGroups())
1578         buttons-&gt;requiredStateChanged(*this);
1579     m_inputType-&gt;requiredStateChanged();
1580 }
1581 
1582 Color HTMLInputElement::valueAsColor() const
1583 {
1584     return m_inputType-&gt;valueAsColor();
1585 }
1586 
1587 void HTMLInputElement::selectColor(StringView color)
1588 {
1589     m_inputType-&gt;selectColor(color);
1590 }
1591 
1592 Vector&lt;Color&gt; HTMLInputElement::suggestedColors() const
1593 {
1594     return m_inputType-&gt;suggestedColors();
1595 }
1596 
1597 #if ENABLE(DATALIST_ELEMENT)
1598 
1599 RefPtr&lt;HTMLElement&gt; HTMLInputElement::list() const
1600 {
1601     return dataList();
1602 }
1603 
1604 RefPtr&lt;HTMLDataListElement&gt; HTMLInputElement::dataList() const
1605 {
1606     if (!m_hasNonEmptyList)
1607         return nullptr;
1608 
1609     if (!m_inputType-&gt;shouldRespectListAttribute())
1610         return nullptr;
1611 
1612     RefPtr&lt;Element&gt; element = treeScope().getElementById(attributeWithoutSynchronization(listAttr));
1613     if (!is&lt;HTMLDataListElement&gt;(element))
1614         return nullptr;
1615 
1616     return downcast&lt;HTMLDataListElement&gt;(element.get());
1617 }
1618 
1619 void HTMLInputElement::resetListAttributeTargetObserver()
1620 {
1621     if (isConnected())
<a name="21" id="anc21"></a><span class="line-modified">1622         m_listAttributeTargetObserver = std::make_unique&lt;ListAttributeTargetObserver&gt;(attributeWithoutSynchronization(listAttr), this);</span>
1623     else
1624         m_listAttributeTargetObserver = nullptr;
1625 }
1626 
1627 void HTMLInputElement::listAttributeTargetChanged()
1628 {
1629     m_inputType-&gt;listAttributeTargetChanged();
1630 }
1631 
1632 #endif // ENABLE(DATALIST_ELEMENT)
1633 
1634 bool HTMLInputElement::isPresentingAttachedView() const
1635 {
1636     return m_inputType-&gt;isPresentingAttachedView();
1637 }
1638 
1639 bool HTMLInputElement::isSteppable() const
1640 {
1641     return m_inputType-&gt;isSteppable();
1642 }
1643 
1644 #if PLATFORM(IOS_FAMILY)
1645 DateComponents::Type HTMLInputElement::dateType() const
1646 {
1647     return m_inputType-&gt;dateType();
1648 }
1649 #endif
1650 
1651 bool HTMLInputElement::isTextButton() const
1652 {
1653     return m_inputType-&gt;isTextButton();
1654 }
1655 
1656 bool HTMLInputElement::isRadioButton() const
1657 {
1658     return m_inputType-&gt;isRadioButton();
1659 }
1660 
1661 bool HTMLInputElement::isSearchField() const
1662 {
1663     return m_inputType-&gt;isSearchField();
1664 }
1665 
1666 bool HTMLInputElement::isInputTypeHidden() const
1667 {
1668     return m_inputType-&gt;isHiddenType();
1669 }
1670 
1671 bool HTMLInputElement::isPasswordField() const
1672 {
1673     return m_inputType-&gt;isPasswordField();
1674 }
1675 
1676 bool HTMLInputElement::isCheckbox() const
1677 {
1678     return m_inputType-&gt;isCheckbox();
1679 }
1680 
1681 bool HTMLInputElement::isRangeControl() const
1682 {
1683     return m_inputType-&gt;isRangeControl();
1684 }
1685 
1686 #if ENABLE(INPUT_TYPE_COLOR)
1687 bool HTMLInputElement::isColorControl() const
1688 {
1689     return m_inputType-&gt;isColorControl();
1690 }
1691 #endif
1692 
1693 bool HTMLInputElement::isText() const
1694 {
1695     return m_inputType-&gt;isTextType();
1696 }
1697 
1698 bool HTMLInputElement::isEmailField() const
1699 {
1700     return m_inputType-&gt;isEmailField();
1701 }
1702 
1703 bool HTMLInputElement::isFileUpload() const
1704 {
1705     return m_inputType-&gt;isFileUpload();
1706 }
1707 
1708 bool HTMLInputElement::isImageButton() const
1709 {
1710     return m_inputType-&gt;isImageButton();
1711 }
1712 
1713 bool HTMLInputElement::isNumberField() const
1714 {
1715     return m_inputType-&gt;isNumberField();
1716 }
1717 
1718 bool HTMLInputElement::isSubmitButton() const
1719 {
1720     return m_inputType-&gt;isSubmitButton();
1721 }
1722 
1723 bool HTMLInputElement::isTelephoneField() const
1724 {
1725     return m_inputType-&gt;isTelephoneField();
1726 }
1727 
1728 bool HTMLInputElement::isURLField() const
1729 {
1730     return m_inputType-&gt;isURLField();
1731 }
1732 
1733 bool HTMLInputElement::isDateField() const
1734 {
1735     return m_inputType-&gt;isDateField();
1736 }
1737 
1738 bool HTMLInputElement::isDateTimeField() const
1739 {
1740     return m_inputType-&gt;isDateTimeField();
1741 }
1742 
1743 bool HTMLInputElement::isDateTimeLocalField() const
1744 {
1745     return m_inputType-&gt;isDateTimeLocalField();
1746 }
1747 
1748 bool HTMLInputElement::isMonthField() const
1749 {
1750     return m_inputType-&gt;isMonthField();
1751 }
1752 
1753 bool HTMLInputElement::isTimeField() const
1754 {
1755     return m_inputType-&gt;isTimeField();
1756 }
1757 
1758 bool HTMLInputElement::isWeekField() const
1759 {
1760     return m_inputType-&gt;isWeekField();
1761 }
1762 
1763 bool HTMLInputElement::isEnumeratable() const
1764 {
1765     return m_inputType-&gt;isEnumeratable();
1766 }
1767 
1768 bool HTMLInputElement::supportLabels() const
1769 {
1770     return m_inputType-&gt;supportLabels();
1771 }
1772 
1773 bool HTMLInputElement::shouldAppearChecked() const
1774 {
1775     return checked() &amp;&amp; m_inputType-&gt;isCheckable();
1776 }
1777 
1778 bool HTMLInputElement::supportsPlaceholder() const
1779 {
1780     return m_inputType-&gt;supportsPlaceholder();
1781 }
1782 
1783 void HTMLInputElement::updatePlaceholderText()
1784 {
1785     return m_inputType-&gt;updatePlaceholderText();
1786 }
1787 
1788 bool HTMLInputElement::isEmptyValue() const
1789 {
1790     return m_inputType-&gt;isEmptyValue();
1791 }
1792 
<a name="22" id="anc22"></a><span class="line-modified">1793 void HTMLInputElement::maxLengthAttributeChanged(const AtomicString&amp; newValue)</span>
1794 {
1795     unsigned oldEffectiveMaxLength = effectiveMaxLength();
1796     internalSetMaxLength(parseHTMLNonNegativeInteger(newValue).value_or(-1));
1797     if (oldEffectiveMaxLength != effectiveMaxLength())
1798         updateValueIfNeeded();
1799 
1800     // FIXME: Do we really need to do this if the effective maxLength has not changed?
1801     invalidateStyleForSubtree();
1802     updateValidity();
1803 }
1804 
<a name="23" id="anc23"></a><span class="line-modified">1805 void HTMLInputElement::minLengthAttributeChanged(const AtomicString&amp; newValue)</span>
1806 {
1807     int oldMinLength = minLength();
1808     internalSetMinLength(parseHTMLNonNegativeInteger(newValue).value_or(-1));
1809     if (oldMinLength != minLength())
1810         updateValueIfNeeded();
1811 
1812     // FIXME: Do we really need to do this if the effective minLength has not changed?
1813     invalidateStyleForSubtree();
1814     updateValidity();
1815 }
1816 
1817 void HTMLInputElement::updateValueIfNeeded()
1818 {
1819     String newValue = sanitizeValue(m_valueIfDirty);
1820     ASSERT(!m_valueIfDirty.isNull() || newValue.isNull());
1821     if (newValue != m_valueIfDirty)
1822         setValue(newValue);
1823 }
1824 
1825 String HTMLInputElement::defaultToolTip() const
1826 {
1827     return m_inputType-&gt;defaultToolTip();
1828 }
1829 
1830 bool HTMLInputElement::matchesIndeterminatePseudoClass() const
1831 {
1832     // For input elements, matchesIndeterminatePseudoClass()
1833     // is not equivalent to shouldAppearIndeterminate() because of radio button.
1834     //
1835     // A group of radio button without any checked button is indeterminate
1836     // for the :indeterminate selector. On the other hand, RenderTheme
1837     // currently only supports single element being indeterminate.
1838     // Because of this, radio is indetermindate for CSS but not for render theme.
1839     return m_inputType-&gt;matchesIndeterminatePseudoClass();
1840 }
1841 
1842 bool HTMLInputElement::shouldAppearIndeterminate() const
1843 {
1844     return m_inputType-&gt;shouldAppearIndeterminate();
1845 }
1846 
1847 #if ENABLE(MEDIA_CAPTURE)
1848 MediaCaptureType HTMLInputElement::mediaCaptureType() const
1849 {
1850     if (!isFileUpload())
1851         return MediaCaptureTypeNone;
1852 
1853     auto&amp; captureAttribute = attributeWithoutSynchronization(captureAttr);
1854     if (captureAttribute.isNull())
1855         return MediaCaptureTypeNone;
1856 
1857     if (equalLettersIgnoringASCIICase(captureAttribute, &quot;user&quot;))
1858         return MediaCaptureTypeUser;
1859 
1860     return MediaCaptureTypeEnvironment;
1861 }
1862 #endif
1863 
1864 bool HTMLInputElement::isInRequiredRadioButtonGroup()
1865 {
1866     ASSERT(isRadioButton());
1867     if (RadioButtonGroups* buttons = radioButtonGroups())
1868         return buttons-&gt;isInRequiredGroup(*this);
1869     return false;
1870 }
1871 
1872 Vector&lt;HTMLInputElement*&gt; HTMLInputElement::radioButtonGroup() const
1873 {
1874     RadioButtonGroups* buttons = radioButtonGroups();
1875     if (!buttons)
1876         return { };
1877     return buttons-&gt;groupMembers(*this);
1878 }
1879 
1880 HTMLInputElement* HTMLInputElement::checkedRadioButtonForGroup() const
1881 {
1882     if (RadioButtonGroups* buttons = radioButtonGroups())
1883         return buttons-&gt;checkedButtonForGroup(name());
<a name="24" id="anc24"></a><span class="line-modified">1884     return 0;</span>
1885 }
1886 
1887 RadioButtonGroups* HTMLInputElement::radioButtonGroups() const
1888 {
1889     if (!isRadioButton())
1890         return nullptr;
1891     if (auto* formElement = form())
1892         return &amp;formElement-&gt;radioButtonGroups();
1893     if (isConnected())
1894         return &amp;document().formController().radioButtonGroups();
1895     return nullptr;
1896 }
1897 
1898 inline void HTMLInputElement::addToRadioButtonGroup()
1899 {
1900     if (auto* buttons = radioButtonGroups())
1901         buttons-&gt;addButton(*this);
1902 }
1903 
1904 inline void HTMLInputElement::removeFromRadioButtonGroup()
1905 {
1906     if (auto* buttons = radioButtonGroups())
1907         buttons-&gt;removeButton(*this);
1908 }
1909 
1910 unsigned HTMLInputElement::height() const
1911 {
1912     return m_inputType-&gt;height();
1913 }
1914 
1915 unsigned HTMLInputElement::width() const
1916 {
1917     return m_inputType-&gt;width();
1918 }
1919 
1920 void HTMLInputElement::setHeight(unsigned height)
1921 {
1922     setUnsignedIntegralAttribute(heightAttr, height);
1923 }
1924 
1925 void HTMLInputElement::setWidth(unsigned width)
1926 {
1927     setUnsignedIntegralAttribute(widthAttr, width);
1928 }
1929 
1930 #if ENABLE(DATALIST_ELEMENT)
<a name="25" id="anc25"></a><span class="line-modified">1931 ListAttributeTargetObserver::ListAttributeTargetObserver(const AtomicString&amp; id, HTMLInputElement* element)</span>
1932     : IdTargetObserver(element-&gt;treeScope().idTargetObserverRegistry(), id)
1933     , m_element(element)
1934 {
1935 }
1936 
1937 void ListAttributeTargetObserver::idTargetChanged()
1938 {
1939     m_element-&gt;listAttributeTargetChanged();
1940 }
1941 #endif
1942 
1943 ExceptionOr&lt;void&gt; HTMLInputElement::setRangeText(const String&amp; replacement)
1944 {
1945     if (!m_inputType-&gt;supportsSelectionAPI())
1946         return Exception { InvalidStateError };
1947 
1948     return HTMLTextFormControlElement::setRangeText(replacement);
1949 }
1950 
1951 ExceptionOr&lt;void&gt; HTMLInputElement::setRangeText(const String&amp; replacement, unsigned start, unsigned end, const String&amp; selectionMode)
1952 {
1953     if (!m_inputType-&gt;supportsSelectionAPI())
1954         return Exception { InvalidStateError };
1955 
1956     return HTMLTextFormControlElement::setRangeText(replacement, start, end, selectionMode);
1957 }
1958 
1959 bool HTMLInputElement::shouldTruncateText(const RenderStyle&amp; style) const
1960 {
1961     if (!isTextField())
1962         return false;
1963     return document().focusedElement() != this &amp;&amp; style.textOverflow() == TextOverflow::Ellipsis;
1964 }
1965 
1966 ExceptionOr&lt;int&gt; HTMLInputElement::selectionStartForBindings() const
1967 {
1968     if (!canHaveSelection())
1969         return Exception { TypeError };
1970 
1971     return selectionStart();
1972 }
1973 
1974 ExceptionOr&lt;void&gt; HTMLInputElement::setSelectionStartForBindings(int start)
1975 {
1976     if (!canHaveSelection())
1977         return Exception { TypeError };
1978 
1979     setSelectionStart(start);
1980     return { };
1981 }
1982 
1983 ExceptionOr&lt;int&gt; HTMLInputElement::selectionEndForBindings() const
1984 {
1985     if (!canHaveSelection())
1986         return Exception { TypeError };
1987 
1988     return selectionEnd();
1989 }
1990 
1991 ExceptionOr&lt;void&gt; HTMLInputElement::setSelectionEndForBindings(int end)
1992 {
1993     if (!canHaveSelection())
1994         return Exception { TypeError };
1995 
1996     setSelectionEnd(end);
1997     return { };
1998 }
1999 
2000 ExceptionOr&lt;String&gt; HTMLInputElement::selectionDirectionForBindings() const
2001 {
2002     if (!canHaveSelection())
2003         return Exception { TypeError };
2004 
2005     return String { selectionDirection() };
2006 }
2007 
2008 ExceptionOr&lt;void&gt; HTMLInputElement::setSelectionDirectionForBindings(const String&amp; direction)
2009 {
2010     if (!canHaveSelection())
2011         return Exception { TypeError };
2012 
2013     setSelectionDirection(direction);
2014     return { };
2015 }
2016 
2017 ExceptionOr&lt;void&gt; HTMLInputElement::setSelectionRangeForBindings(int start, int end, const String&amp; direction)
2018 {
2019     if (!canHaveSelection())
2020         return Exception { TypeError };
2021 
2022     setSelectionRange(start, end, direction);
2023     return { };
2024 }
2025 
2026 static Ref&lt;CSSLinearGradientValue&gt; autoFillStrongPasswordMaskImage()
2027 {
2028     CSSGradientColorStop firstStop;
2029     firstStop.m_color = CSSValuePool::singleton().createColorValue(Color::black);
2030     firstStop.m_position = CSSValuePool::singleton().createValue(50, CSSPrimitiveValue::UnitType::CSS_PERCENTAGE);
2031 
2032     CSSGradientColorStop secondStop;
2033     secondStop.m_color = CSSValuePool::singleton().createColorValue(Color::transparent);
2034     secondStop.m_position = CSSValuePool::singleton().createValue(100, CSSPrimitiveValue::UnitType::CSS_PERCENTAGE);
2035 
2036     auto gradient = CSSLinearGradientValue::create(CSSGradientRepeat::NonRepeating, CSSGradientType::CSSLinearGradient);
2037     gradient-&gt;setAngle(CSSValuePool::singleton().createValue(90, CSSPrimitiveValue::UnitType::CSS_DEG));
2038     gradient-&gt;addStop(firstStop);
2039     gradient-&gt;addStop(secondStop);
2040     return gradient;
2041 }
2042 
2043 RenderStyle HTMLInputElement::createInnerTextStyle(const RenderStyle&amp; style)
2044 {
2045     auto textBlockStyle = RenderStyle::create();
2046     textBlockStyle.inheritFrom(style);
2047     adjustInnerTextStyle(style, textBlockStyle);
2048 
2049     textBlockStyle.setWhiteSpace(WhiteSpace::Pre);
2050     textBlockStyle.setOverflowWrap(OverflowWrap::Normal);
2051     textBlockStyle.setOverflowX(Overflow::Hidden);
2052     textBlockStyle.setOverflowY(Overflow::Hidden);
2053     textBlockStyle.setTextOverflow(shouldTruncateText(style) ? TextOverflow::Ellipsis : TextOverflow::Clip);
2054 
2055     textBlockStyle.setDisplay(DisplayType::Block);
2056 
2057     if (hasAutoFillStrongPasswordButton() &amp;&amp; !isDisabledOrReadOnly()) {
2058         textBlockStyle.setDisplay(DisplayType::InlineBlock);
2059         textBlockStyle.setMaxWidth(Length { 100, Percent });
2060         textBlockStyle.setColor({ 0.0f, 0.0f, 0.0f, 0.6f });
2061         textBlockStyle.setTextOverflow(TextOverflow::Clip);
2062         textBlockStyle.setMaskImage(styleResolver().styleImage(autoFillStrongPasswordMaskImage()));
2063         // A stacking context is needed for the mask.
2064         if (textBlockStyle.hasAutoZIndex())
2065             textBlockStyle.setZIndex(0);
2066     }
2067 
2068     // Do not allow line-height to be smaller than our default.
2069     if (textBlockStyle.fontMetrics().lineSpacing() &gt; style.computedLineHeight())
2070         textBlockStyle.setLineHeight(RenderStyle::initialLineHeight());
2071 
2072     return textBlockStyle;
2073 }
2074 
2075 #if ENABLE(DATE_AND_TIME_INPUT_TYPES)
2076 bool HTMLInputElement::setupDateTimeChooserParameters(DateTimeChooserParameters&amp; parameters)
2077 {
2078     if (!document().view())
2079         return false;
2080 
2081     parameters.type = type();
2082     parameters.minimum = minimum();
2083     parameters.maximum = maximum();
2084     parameters.required = isRequired();
2085 
2086     if (!document().settings().langAttributeAwareFormControlUIEnabled())
2087         parameters.locale = defaultLanguage();
2088     else {
<a name="26" id="anc26"></a><span class="line-modified">2089         AtomicString computedLocale = computeInheritedLanguage();</span>
<span class="line-modified">2090         parameters.locale = computedLocale.isEmpty() ? AtomicString(defaultLanguage()) : computedLocale;</span>
2091     }
2092 
2093     StepRange stepRange = createStepRange(RejectAny);
2094     if (stepRange.hasStep()) {
2095         parameters.step = stepRange.step().toDouble();
2096         parameters.stepBase = stepRange.stepBase().toDouble();
2097     } else {
2098         parameters.step = 1.0;
2099         parameters.stepBase = 0;
2100     }
2101 
2102     if (RenderElement* renderer = this-&gt;renderer())
2103         parameters.anchorRectInRootView = document().view()-&gt;contentsToRootView(renderer-&gt;absoluteBoundingBoxRect());
2104     else
2105         parameters.anchorRectInRootView = IntRect();
2106     parameters.currentValue = value();
2107     parameters.isAnchorElementRTL = computedStyle()-&gt;direction() == TextDirection::RTL;
2108 #if ENABLE(DATALIST_ELEMENT)
2109     if (auto dataList = this-&gt;dataList()) {
2110         Ref&lt;HTMLCollection&gt; options = dataList-&gt;options();
2111         for (unsigned i = 0; RefPtr&lt;HTMLOptionElement&gt; option = downcast&lt;HTMLOptionElement&gt;(options-&gt;item(i)); ++i) {
2112             if (!isValidValue(option-&gt;value()))
2113                 continue;
2114             parameters.suggestionValues.append(sanitizeValue(option-&gt;value()));
2115             parameters.localizedSuggestionValues.append(localizeValue(option-&gt;value()));
2116             parameters.suggestionLabels.append(option-&gt;value() == option-&gt;label() ? String() : option-&gt;label());
2117         }
2118     }
2119 #endif
2120     return true;
2121 }
2122 #endif
2123 
2124 void HTMLInputElement::capsLockStateMayHaveChanged()
2125 {
2126     m_inputType-&gt;capsLockStateMayHaveChanged();
2127 }
2128 
2129 } // namespace
<a name="27" id="anc27"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="27" type="hidden" />
</body>
</html>