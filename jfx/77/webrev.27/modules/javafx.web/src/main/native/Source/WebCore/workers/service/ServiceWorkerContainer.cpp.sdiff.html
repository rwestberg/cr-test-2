<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/workers/service/ServiceWorkerContainer.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ServiceWorkerClients.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ServiceWorkerContainer.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/workers/service/ServiceWorkerContainer.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;ServiceWorkerContainer.h&quot;
 28 
 29 #if ENABLE(SERVICE_WORKER)
 30 
 31 #include &quot;Document.h&quot;
 32 #include &quot;Event.h&quot;
 33 #include &quot;EventNames.h&quot;
 34 #include &quot;Exception.h&quot;
 35 #include &quot;IDLTypes.h&quot;
 36 #include &quot;JSDOMPromiseDeferred.h&quot;
 37 #include &quot;JSServiceWorkerRegistration.h&quot;
 38 #include &quot;Logging.h&quot;

 39 #include &quot;NavigatorBase.h&quot;
 40 #include &quot;ResourceError.h&quot;
 41 #include &quot;SchemeRegistry.h&quot;
 42 #include &quot;ScriptExecutionContext.h&quot;
 43 #include &quot;SecurityOrigin.h&quot;
 44 #include &quot;ServiceWorker.h&quot;
 45 #include &quot;ServiceWorkerFetchResult.h&quot;
 46 #include &quot;ServiceWorkerGlobalScope.h&quot;
 47 #include &quot;ServiceWorkerJob.h&quot;
 48 #include &quot;ServiceWorkerJobData.h&quot;
 49 #include &quot;ServiceWorkerProvider.h&quot;
 50 #include &quot;ServiceWorkerThread.h&quot;

 51 #include &lt;wtf/RunLoop.h&gt;
 52 #include &lt;wtf/Scope.h&gt;
 53 #include &lt;wtf/URL.h&gt;
 54 
 55 #define CONTAINER_RELEASE_LOG_IF_ALLOWED(fmt, ...) RELEASE_LOG_IF(isAlwaysOnLoggingAllowed(), ServiceWorker, &quot;%p - ServiceWorkerContainer::&quot; fmt, this, ##__VA_ARGS__)
 56 #define CONTAINER_RELEASE_LOG_ERROR_IF_ALLOWED(fmt, ...) RELEASE_LOG_ERROR_IF(isAlwaysOnLoggingAllowed(), ServiceWorker, &quot;%p - ServiceWorkerContainer::&quot; fmt, this, ##__VA_ARGS__)
 57 
 58 namespace WebCore {
 59 


 60 ServiceWorkerContainer::ServiceWorkerContainer(ScriptExecutionContext* context, NavigatorBase&amp; navigator)
 61     : ActiveDOMObject(context)
 62     , m_navigator(navigator)
 63 {
 64     suspendIfNeeded();
 65 }
 66 
 67 ServiceWorkerContainer::~ServiceWorkerContainer()
 68 {
 69 #ifndef NDEBUG
 70     ASSERT(m_creationThread.ptr() == &amp;Thread::current());
 71 #endif
 72 }
 73 
 74 void ServiceWorkerContainer::refEventTarget()
 75 {
 76     m_navigator.ref();
 77 }
 78 
 79 void ServiceWorkerContainer::derefEventTarget()
 80 {
 81     m_navigator.deref();
 82 }
 83 
 84 auto ServiceWorkerContainer::ready() -&gt; ReadyPromise&amp;
 85 {
 86     if (!m_readyPromise) {
<span class="line-modified"> 87         m_readyPromise = std::make_unique&lt;ReadyPromise&gt;();</span>
 88 
 89         if (m_isStopped || !scriptExecutionContext()-&gt;sessionID().isValid())
 90             return *m_readyPromise;
 91 
 92         auto&amp; context = *scriptExecutionContext();
 93         auto contextIdentifier = this-&gt;contextIdentifier();
 94         callOnMainThread([connection = makeRef(ensureSWClientConnection()), topOrigin = context.topOrigin().isolatedCopy(), clientURL = context.url().isolatedCopy(), contextIdentifier]() mutable {
 95             connection-&gt;whenRegistrationReady(topOrigin, clientURL, [contextIdentifier](auto&amp;&amp; registrationData) {
 96                 ScriptExecutionContext::postTaskTo(contextIdentifier, [registrationData = crossThreadCopy(registrationData)](auto&amp; context) mutable {
 97                     auto* serviceWorkerContainer = context.serviceWorkerContainer();
 98                     if (!serviceWorkerContainer)
 99                         return;
100                     if (serviceWorkerContainer-&gt;m_isStopped || !context.sessionID().isValid())
101                         return;
102 
103                     auto registration = ServiceWorkerRegistration::getOrCreate(context, *serviceWorkerContainer, WTFMove(registrationData));
104                     serviceWorkerContainer-&gt;m_readyPromise-&gt;resolve(WTFMove(registration));
105                 });
106             });
107         });
</pre>
<hr />
<pre>
159     if (!jobData.scopeURL.isNull() &amp;&amp; !SchemeRegistry::canServiceWorkersHandleURLScheme(jobData.scopeURL.protocol().toStringWithoutCopying())) {
160         CONTAINER_RELEASE_LOG_ERROR_IF_ALLOWED(&quot;addRegistration: scopeURL scheme is not HTTP or HTTPS&quot;);
161         promise-&gt;reject(Exception { TypeError, &quot;Scope URL provided to serviceWorker.register() must be either HTTP or HTTPS&quot;_s });
162         return;
163     }
164 
165     path = jobData.scopeURL.path();
166     if (path.containsIgnoringASCIICase(&quot;%2f&quot;) || path.containsIgnoringASCIICase(&quot;%5c&quot;)) {
167         CONTAINER_RELEASE_LOG_ERROR_IF_ALLOWED(&quot;addRegistration: scopeURL contains invalid character&quot;);
168         promise-&gt;reject(Exception { TypeError, &quot;Scope URL provided to serviceWorker.register() cannot have a path that contains &#39;%2f&#39; or &#39;%5c&#39;&quot;_s });
169         return;
170     }
171 
172     CONTAINER_RELEASE_LOG_IF_ALLOWED(&quot;addRegistration: Registering service worker. Job ID: %&quot; PRIu64, jobData.identifier().jobIdentifier.toUInt64());
173 
174     jobData.clientCreationURL = context-&gt;url();
175     jobData.topOrigin = context-&gt;topOrigin().data();
176     jobData.type = ServiceWorkerJobType::Register;
177     jobData.registrationOptions = options;
178 
<span class="line-modified">179     scheduleJob(std::make_unique&lt;ServiceWorkerJob&gt;(*this, WTFMove(promise), WTFMove(jobData)));</span>
180 }
181 
182 void ServiceWorkerContainer::removeRegistration(const URL&amp; scopeURL, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
183 {
184     auto* context = scriptExecutionContext();
185     if (!context || !context-&gt;sessionID().isValid()) {
186         ASSERT_NOT_REACHED();
187         promise-&gt;reject(Exception(InvalidStateError));
188         return;
189     }
190 
191     if (!m_swConnection) {
192         ASSERT_NOT_REACHED();
193         promise-&gt;reject(Exception(InvalidStateError));
194         return;
195     }
196 
197     ServiceWorkerJobData jobData(m_swConnection-&gt;serverConnectionIdentifier(), contextIdentifier());
198     jobData.clientCreationURL = context-&gt;url();
199     jobData.topOrigin = context-&gt;topOrigin().data();
200     jobData.type = ServiceWorkerJobType::Unregister;
201     jobData.scopeURL = scopeURL;
202 
203     CONTAINER_RELEASE_LOG_IF_ALLOWED(&quot;removeRegistration: Unregistering service worker. Job ID: %&quot; PRIu64, jobData.identifier().jobIdentifier.toUInt64());
204 
<span class="line-modified">205     scheduleJob(std::make_unique&lt;ServiceWorkerJob&gt;(*this, WTFMove(promise), WTFMove(jobData)));</span>
206 }
207 
208 void ServiceWorkerContainer::updateRegistration(const URL&amp; scopeURL, const URL&amp; scriptURL, WorkerType, RefPtr&lt;DeferredPromise&gt;&amp;&amp; promise)
209 {
210     ASSERT(!m_isStopped);
211 
212     auto&amp; context = *scriptExecutionContext();
213     ASSERT(context.sessionID().isValid());
214 
215     if (!m_swConnection) {
216         ASSERT_NOT_REACHED();
217         if (promise)
218             promise-&gt;reject(Exception(InvalidStateError));
219         return;
220     }
221 
222     ServiceWorkerJobData jobData(m_swConnection-&gt;serverConnectionIdentifier(), contextIdentifier());
223     jobData.clientCreationURL = context.url();
224     jobData.topOrigin = context.topOrigin().data();
225     jobData.type = ServiceWorkerJobType::Update;
226     jobData.scopeURL = scopeURL;
227     jobData.scriptURL = scriptURL;
228 
229     CONTAINER_RELEASE_LOG_IF_ALLOWED(&quot;removeRegistration: Updating service worker. Job ID: %&quot; PRIu64, jobData.identifier().jobIdentifier.toUInt64());
230 
<span class="line-modified">231     scheduleJob(std::make_unique&lt;ServiceWorkerJob&gt;(*this, WTFMove(promise), WTFMove(jobData)));</span>
232 }
233 
234 void ServiceWorkerContainer::scheduleJob(std::unique_ptr&lt;ServiceWorkerJob&gt;&amp;&amp; job)
235 {
236 #ifndef NDEBUG
237     ASSERT(m_creationThread.ptr() == &amp;Thread::current());
238 #endif
239 
240     ASSERT(m_swConnection);
241     ASSERT(!isStopped());
242 
243     auto&amp; jobData = job-&gt;data();
244     auto jobIdentifier = job-&gt;identifier();
245     ASSERT(!m_jobMap.contains(jobIdentifier));
246     m_jobMap.add(jobIdentifier, OngoingJob { WTFMove(job), makePendingActivity(*this) });
247 
248     callOnMainThread([connection = m_swConnection, contextIdentifier = this-&gt;contextIdentifier(), jobData = jobData.isolatedCopy()] {
249         connection-&gt;scheduleJob(contextIdentifier, jobData);
250     });
251 }
252 
253 void ServiceWorkerContainer::getRegistration(const String&amp; clientURL, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
254 {
255     auto* context = scriptExecutionContext();
256     if (m_isStopped || !context-&gt;sessionID().isValid()) {
257         promise-&gt;reject(Exception { InvalidStateError });
258         return;
259     }
260 
261     URL parsedURL = context-&gt;completeURL(clientURL);
262     if (!protocolHostAndPortAreEqual(parsedURL, context-&gt;url())) {
263         promise-&gt;reject(Exception { SecurityError, &quot;Origin of clientURL is not client&#39;s origin&quot;_s });
264         return;
265     }
266 
267     uint64_t pendingPromiseIdentifier = ++m_lastPendingPromiseIdentifier;
<span class="line-modified">268     auto pendingPromise = std::make_unique&lt;PendingPromise&gt;(WTFMove(promise), makePendingActivity(*this));</span>
269     m_pendingPromises.add(pendingPromiseIdentifier, WTFMove(pendingPromise));
270 
271     auto contextIdentifier = this-&gt;contextIdentifier();
272     callOnMainThread([connection = makeRef(ensureSWClientConnection()), topOrigin = context-&gt;topOrigin().data().isolatedCopy(), parsedURL = parsedURL.isolatedCopy(), contextIdentifier, pendingPromiseIdentifier]() mutable {
273         connection-&gt;matchRegistration(WTFMove(topOrigin), parsedURL, [contextIdentifier, pendingPromiseIdentifier] (auto&amp;&amp; result) mutable {
274             ScriptExecutionContext::postTaskTo(contextIdentifier, [pendingPromiseIdentifier, result = crossThreadCopy(result)](auto&amp; context) mutable {
275                 auto* serviceWorkerContainer = context.serviceWorkerContainer();
276                 if (!serviceWorkerContainer)
277                     return;
278                 if (serviceWorkerContainer-&gt;m_isStopped || !context.sessionID().isValid())
279                     return;
280 
281                 serviceWorkerContainer-&gt;didFinishGetRegistrationRequest(pendingPromiseIdentifier, WTFMove(result));
282             });
283         });
284     });
285 }
286 
287 void ServiceWorkerContainer::didFinishGetRegistrationRequest(uint64_t pendingPromiseIdentifier, Optional&lt;ServiceWorkerRegistrationData&gt;&amp;&amp; result)
288 {
</pre>
<hr />
<pre>
291 #endif
292 
293     auto pendingPromise = m_pendingPromises.take(pendingPromiseIdentifier);
294     if (!pendingPromise)
295         return;
296 
297     if (m_isStopped || !scriptExecutionContext()-&gt;sessionID().isValid()) {
298         pendingPromise-&gt;promise-&gt;reject(Exception { InvalidStateError });
299         return;
300     }
301 
302     if (!result) {
303         pendingPromise-&gt;promise-&gt;resolve();
304         return;
305     }
306 
307     auto registration = ServiceWorkerRegistration::getOrCreate(*scriptExecutionContext(), *this, WTFMove(result.value()));
308     pendingPromise-&gt;promise-&gt;resolve&lt;IDLInterface&lt;ServiceWorkerRegistration&gt;&gt;(WTFMove(registration));
309 }
310 
<span class="line-modified">311 void ServiceWorkerContainer::scheduleTaskToUpdateRegistrationState(ServiceWorkerRegistrationIdentifier identifier, ServiceWorkerRegistrationState state, const Optional&lt;ServiceWorkerData&gt;&amp; serviceWorkerData)</span>
312 {
<span class="line-modified">313     auto* context = scriptExecutionContext();</span>
<span class="line-removed">314     if (!context)</span>
315         return;
316 
317     RefPtr&lt;ServiceWorker&gt; serviceWorker;
318     if (serviceWorkerData)
<span class="line-modified">319         serviceWorker = ServiceWorker::getOrCreate(*context, ServiceWorkerData { *serviceWorkerData });</span>
320 
<span class="line-modified">321     context-&gt;postTask([this, protectedThis = makeRef(*this), identifier, state, serviceWorker = WTFMove(serviceWorker)](ScriptExecutionContext&amp;) mutable {</span>
<span class="line-modified">322         if (auto* registration = m_registrations.get(identifier))</span>
<span class="line-removed">323             registration-&gt;updateStateFromServer(state, WTFMove(serviceWorker));</span>
<span class="line-removed">324     });</span>
325 }
326 
327 void ServiceWorkerContainer::getRegistrations(Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
328 {
329     auto* context = scriptExecutionContext();
330     if (m_isStopped || !context-&gt;sessionID().isValid()) {
331         promise-&gt;reject(Exception { InvalidStateError });
332         return;
333     }
334 
335     uint64_t pendingPromiseIdentifier = ++m_lastPendingPromiseIdentifier;
<span class="line-modified">336     auto pendingPromise = std::make_unique&lt;PendingPromise&gt;(WTFMove(promise), makePendingActivity(*this));</span>
337     m_pendingPromises.add(pendingPromiseIdentifier, WTFMove(pendingPromise));
338 
339     auto contextIdentifier = this-&gt;contextIdentifier();
340     auto contextURL = context-&gt;url();
341     callOnMainThread([connection = makeRef(ensureSWClientConnection()), topOrigin = context-&gt;topOrigin().data().isolatedCopy(), contextURL = contextURL.isolatedCopy(), contextIdentifier, pendingPromiseIdentifier]() mutable {
342         connection-&gt;getRegistrations(WTFMove(topOrigin), contextURL, [contextIdentifier, pendingPromiseIdentifier] (auto&amp;&amp; registrationDatas) mutable {
343             ScriptExecutionContext::postTaskTo(contextIdentifier, [pendingPromiseIdentifier, registrationDatas = crossThreadCopy(registrationDatas)](auto&amp; context) mutable {
344                 auto* serviceWorkerContainer = context.serviceWorkerContainer();
345                 if (!serviceWorkerContainer)
346                     return;
347                 if (serviceWorkerContainer-&gt;m_isStopped || !context.sessionID().isValid())
348                     return;
349 
350                 serviceWorkerContainer-&gt;didFinishGetRegistrationsRequest(pendingPromiseIdentifier, WTFMove(registrationDatas));
351             });
352         });
353     });
354 }
355 
356 void ServiceWorkerContainer::didFinishGetRegistrationsRequest(uint64_t pendingPromiseIdentifier, Vector&lt;ServiceWorkerRegistrationData&gt;&amp;&amp; registrationDatas)
</pre>
<hr />
<pre>
387 
388     ASSERT_WITH_MESSAGE(job.hasPromise() || job.data().type == ServiceWorkerJobType::Update, &quot;Only soft updates have no promise&quot;);
389 
390     auto guard = WTF::makeScopeExit([this, &amp;job] {
391         destroyJob(job);
392     });
393 
394     CONTAINER_RELEASE_LOG_ERROR_IF_ALLOWED(&quot;jobFailedWithException: Job %&quot; PRIu64 &quot; failed with error %s&quot;, job.identifier().toUInt64(), exception.message().utf8().data());
395 
396     auto promise = job.takePromise();
397     if (!promise)
398         return;
399 
400     if (auto* context = scriptExecutionContext()) {
401         context-&gt;postTask([promise = WTFMove(promise), exception](auto&amp;) mutable {
402             promise-&gt;reject(exception);
403         });
404     }
405 }
406 
<span class="line-modified">407 void ServiceWorkerContainer::scheduleTaskToFireUpdateFoundEvent(ServiceWorkerRegistrationIdentifier identifier)</span>
408 {
409 #ifndef NDEBUG
410     ASSERT(m_creationThread.ptr() == &amp;Thread::current());
411 #endif
412 
413     if (auto* registration = m_registrations.get(identifier))
<span class="line-modified">414         registration-&gt;scheduleTaskToFireUpdateFoundEvent();</span>
415 }
416 
417 void ServiceWorkerContainer::jobResolvedWithRegistration(ServiceWorkerJob&amp; job, ServiceWorkerRegistrationData&amp;&amp; data, ShouldNotifyWhenResolved shouldNotifyWhenResolved)
418 {
419 #ifndef NDEBUG
420     ASSERT(m_creationThread.ptr() == &amp;Thread::current());
421 #endif
422     ASSERT_WITH_MESSAGE(job.hasPromise() || job.data().type == ServiceWorkerJobType::Update, &quot;Only soft updates have no promise&quot;);
423 
<span class="line-removed">424     auto guard = WTF::makeScopeExit([this, &amp;job] {</span>
<span class="line-removed">425         destroyJob(job);</span>
<span class="line-removed">426     });</span>
<span class="line-removed">427 </span>
428     if (job.data().type == ServiceWorkerJobType::Register)
429         CONTAINER_RELEASE_LOG_IF_ALLOWED(&quot;jobResolvedWithRegistration: Registration job %&quot; PRIu64 &quot; succeeded&quot;, job.identifier().toUInt64());
430     else {
431         ASSERT(job.data().type == ServiceWorkerJobType::Update);
432         CONTAINER_RELEASE_LOG_IF_ALLOWED(&quot;jobResolvedWithRegistration: Update job %&quot; PRIu64 &quot; succeeded&quot;, job.identifier().toUInt64());
433     }
434 
<span class="line-modified">435     std::function&lt;void()&gt; notifyWhenResolvedIfNeeded;</span>
<span class="line-modified">436     if (shouldNotifyWhenResolved == ShouldNotifyWhenResolved::Yes) {</span>
<span class="line-modified">437         notifyWhenResolvedIfNeeded = [connection = m_swConnection, registrationKey = data.key]() mutable {</span>
<span class="line-removed">438             callOnMainThread([connection = WTFMove(connection), registrationKey = registrationKey.isolatedCopy()] {</span>
<span class="line-removed">439                 connection-&gt;didResolveRegistrationPromise(registrationKey);</span>
<span class="line-removed">440             });</span>
<span class="line-removed">441         };</span>
<span class="line-removed">442     }</span>
443 
<span class="line-modified">444     if (isStopped()) {</span>
<span class="line-modified">445         if (notifyWhenResolvedIfNeeded)</span>
<span class="line-modified">446             notifyWhenResolvedIfNeeded();</span>



447         return;
<span class="line-removed">448     }</span>
449 
450     auto promise = job.takePromise();
<span class="line-modified">451     if (!promise) {</span>
<span class="line-removed">452         if (notifyWhenResolvedIfNeeded)</span>
<span class="line-removed">453             notifyWhenResolvedIfNeeded();</span>
454         return;
<span class="line-removed">455     }</span>
456 
<span class="line-modified">457     scriptExecutionContext()-&gt;postTask([this, protectedThis = makeRef(*this), promise = WTFMove(promise), jobIdentifier = job.identifier(), data = WTFMove(data), notifyWhenResolvedIfNeeded = WTFMove(notifyWhenResolvedIfNeeded)](ScriptExecutionContext&amp; context) mutable {</span>


458         if (isStopped() || !context.sessionID().isValid()) {
<span class="line-modified">459             if (notifyWhenResolvedIfNeeded)</span>
<span class="line-modified">460                 notifyWhenResolvedIfNeeded();</span>
461             return;
462         }
463 
464         auto registration = ServiceWorkerRegistration::getOrCreate(context, *this, WTFMove(data));
465 
466         CONTAINER_RELEASE_LOG_IF_ALLOWED(&quot;jobResolvedWithRegistration: Resolving promise for job %&quot; PRIu64 &quot;. Registration ID: %&quot; PRIu64, jobIdentifier.toUInt64(), registration-&gt;identifier().toUInt64());
467 
<span class="line-modified">468         if (notifyWhenResolvedIfNeeded) {</span>
<span class="line-modified">469             promise-&gt;whenSettled([notifyWhenResolvedIfNeeded = WTFMove(notifyWhenResolvedIfNeeded)] {</span>
<span class="line-modified">470                 notifyWhenResolvedIfNeeded();</span>

471             });
472         }
473 
474         promise-&gt;resolve&lt;IDLInterface&lt;ServiceWorkerRegistration&gt;&gt;(WTFMove(registration));
475     });
476 }
477 
















478 void ServiceWorkerContainer::jobResolvedWithUnregistrationResult(ServiceWorkerJob&amp; job, bool unregistrationResult)
479 {
480 #ifndef NDEBUG
481     ASSERT(m_creationThread.ptr() == &amp;Thread::current());
482 #endif
483 
484     ASSERT(job.hasPromise());
485 
486     auto guard = WTF::makeScopeExit([this, &amp;job] {
487         destroyJob(job);
488     });
489 
490     CONTAINER_RELEASE_LOG_IF_ALLOWED(&quot;jobResolvedWithUnregistrationResult: Unregister job %&quot; PRIu64 &quot; finished. Success? %d&quot;, job.identifier().toUInt64(), unregistrationResult);
491 
492     auto* context = scriptExecutionContext();
493     if (!context) {
494         LOG_ERROR(&quot;ServiceWorkerContainer::jobResolvedWithUnregistrationResult called but the containers ScriptExecutionContext is gone&quot;);
495         return;
496     }
497 
</pre>
<hr />
<pre>
548     destroyJob(job);
549 }
550 
551 void ServiceWorkerContainer::notifyFailedFetchingScript(ServiceWorkerJob&amp; job, const ResourceError&amp; error)
552 {
553     callOnMainThread([connection = m_swConnection, jobIdentifier = job.identifier(), registrationKey = job.data().registrationKey().isolatedCopy(), error = error.isolatedCopy()] {
554         connection-&gt;failedFetchingScript(jobIdentifier, registrationKey, error);
555     });
556 }
557 
558 void ServiceWorkerContainer::destroyJob(ServiceWorkerJob&amp; job)
559 {
560 #ifndef NDEBUG
561     ASSERT(m_creationThread.ptr() == &amp;Thread::current());
562 #endif
563 
564     ASSERT(m_jobMap.contains(job.identifier()));
565     m_jobMap.remove(job.identifier());
566 }
567 
<span class="line-removed">568 SWServerConnectionIdentifier ServiceWorkerContainer::connectionIdentifier()</span>
<span class="line-removed">569 {</span>
<span class="line-removed">570     ASSERT(m_swConnection);</span>
<span class="line-removed">571     return m_swConnection-&gt;serverConnectionIdentifier();</span>
<span class="line-removed">572 }</span>
<span class="line-removed">573 </span>
574 const char* ServiceWorkerContainer::activeDOMObjectName() const
575 {
576     return &quot;ServiceWorkerContainer&quot;;
577 }
578 
579 bool ServiceWorkerContainer::canSuspendForDocumentSuspension() const
580 {
581     return !hasPendingActivity();
582 }
583 
584 SWClientConnection&amp; ServiceWorkerContainer::ensureSWClientConnection()
585 {
586     ASSERT(scriptExecutionContext());
587     ASSERT(scriptExecutionContext()-&gt;sessionID().isValid());
588     if (!m_swConnection) {
589         ASSERT(scriptExecutionContext());
590         callOnMainThreadAndWait([this, sessionID = scriptExecutionContext()-&gt;sessionID()]() {
591             m_swConnection = &amp;ServiceWorkerProvider::singleton().serviceWorkerConnectionForSession(sessionID);
592         });
593     }
</pre>
<hr />
<pre>
597 void ServiceWorkerContainer::addRegistration(ServiceWorkerRegistration&amp; registration)
598 {
599 #ifndef NDEBUG
600     ASSERT(m_creationThread.ptr() == &amp;Thread::current());
601 #endif
602 
603     ensureSWClientConnection().addServiceWorkerRegistrationInServer(registration.identifier());
604     m_registrations.add(registration.identifier(), &amp;registration);
605 }
606 
607 void ServiceWorkerContainer::removeRegistration(ServiceWorkerRegistration&amp; registration)
608 {
609 #ifndef NDEBUG
610     ASSERT(m_creationThread.ptr() == &amp;Thread::current());
611 #endif
612 
613     m_swConnection-&gt;removeServiceWorkerRegistrationInServer(registration.identifier());
614     m_registrations.remove(registration.identifier());
615 }
616 
<span class="line-modified">617 void ServiceWorkerContainer::scheduleTaskToFireControllerChangeEvent()</span>
618 {
619 #ifndef NDEBUG
620     ASSERT(m_creationThread.ptr() == &amp;Thread::current());
621 #endif
622 
623     if (m_isStopped)
624         return;
625 
<span class="line-modified">626     scriptExecutionContext()-&gt;postTask([this, protectedThis = makeRef(*this)](ScriptExecutionContext&amp;) mutable {</span>
<span class="line-removed">627         if (m_isStopped)</span>
<span class="line-removed">628             return;</span>
<span class="line-removed">629 </span>
<span class="line-removed">630         dispatchEvent(Event::create(eventNames().controllerchangeEvent, Event::CanBubble::No, Event::IsCancelable::No));</span>
<span class="line-removed">631     });</span>
632 }
633 
634 void ServiceWorkerContainer::stop()
635 {
636     m_isStopped = true;
637     removeAllEventListeners();
638     m_pendingPromises.clear();
639     m_readyPromise = nullptr;
640     auto jobMap = WTFMove(m_jobMap);
641     for (auto&amp; ongoingJob : jobMap.values()) {
<span class="line-modified">642         notifyFailedFetchingScript(*ongoingJob.job.get(), ResourceError { errorDomainWebKitInternal, 0, ongoingJob.job-&gt;data().scriptURL, &quot;Job cancelled&quot;_s, ResourceError::Type::Cancellation });</span>
<span class="line-modified">643         ongoingJob.job-&gt;cancelPendingLoad();</span>
644     }




645 }
646 
647 DocumentOrWorkerIdentifier ServiceWorkerContainer::contextIdentifier()
648 {
649 #ifndef NDEBUG
650     ASSERT(m_creationThread.ptr() == &amp;Thread::current());
651 #endif
652 
653     ASSERT(scriptExecutionContext());
654     if (is&lt;ServiceWorkerGlobalScope&gt;(*scriptExecutionContext()))
655         return downcast&lt;ServiceWorkerGlobalScope&gt;(*scriptExecutionContext()).thread().identifier();
656     return downcast&lt;Document&gt;(*scriptExecutionContext()).identifier();
657 }
658 
659 ServiceWorkerJob* ServiceWorkerContainer::job(ServiceWorkerJobIdentifier identifier)
660 {
661     auto iterator = m_jobMap.find(identifier);
662     if (iterator == m_jobMap.end())
663         return nullptr;
664     return iterator-&gt;value.job.get();
</pre>
</td>
<td>
<hr />
<pre>
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;ServiceWorkerContainer.h&quot;
 28 
 29 #if ENABLE(SERVICE_WORKER)
 30 
 31 #include &quot;Document.h&quot;
 32 #include &quot;Event.h&quot;
 33 #include &quot;EventNames.h&quot;
 34 #include &quot;Exception.h&quot;
 35 #include &quot;IDLTypes.h&quot;
 36 #include &quot;JSDOMPromiseDeferred.h&quot;
 37 #include &quot;JSServiceWorkerRegistration.h&quot;
 38 #include &quot;Logging.h&quot;
<span class="line-added"> 39 #include &quot;MessageEvent.h&quot;</span>
 40 #include &quot;NavigatorBase.h&quot;
 41 #include &quot;ResourceError.h&quot;
 42 #include &quot;SchemeRegistry.h&quot;
 43 #include &quot;ScriptExecutionContext.h&quot;
 44 #include &quot;SecurityOrigin.h&quot;
 45 #include &quot;ServiceWorker.h&quot;
 46 #include &quot;ServiceWorkerFetchResult.h&quot;
 47 #include &quot;ServiceWorkerGlobalScope.h&quot;
 48 #include &quot;ServiceWorkerJob.h&quot;
 49 #include &quot;ServiceWorkerJobData.h&quot;
 50 #include &quot;ServiceWorkerProvider.h&quot;
 51 #include &quot;ServiceWorkerThread.h&quot;
<span class="line-added"> 52 #include &lt;wtf/IsoMallocInlines.h&gt;</span>
 53 #include &lt;wtf/RunLoop.h&gt;
 54 #include &lt;wtf/Scope.h&gt;
 55 #include &lt;wtf/URL.h&gt;
 56 
 57 #define CONTAINER_RELEASE_LOG_IF_ALLOWED(fmt, ...) RELEASE_LOG_IF(isAlwaysOnLoggingAllowed(), ServiceWorker, &quot;%p - ServiceWorkerContainer::&quot; fmt, this, ##__VA_ARGS__)
 58 #define CONTAINER_RELEASE_LOG_ERROR_IF_ALLOWED(fmt, ...) RELEASE_LOG_ERROR_IF(isAlwaysOnLoggingAllowed(), ServiceWorker, &quot;%p - ServiceWorkerContainer::&quot; fmt, this, ##__VA_ARGS__)
 59 
 60 namespace WebCore {
 61 
<span class="line-added"> 62 WTF_MAKE_ISO_ALLOCATED_IMPL(ServiceWorkerContainer);</span>
<span class="line-added"> 63 </span>
 64 ServiceWorkerContainer::ServiceWorkerContainer(ScriptExecutionContext* context, NavigatorBase&amp; navigator)
 65     : ActiveDOMObject(context)
 66     , m_navigator(navigator)
 67 {
 68     suspendIfNeeded();
 69 }
 70 
 71 ServiceWorkerContainer::~ServiceWorkerContainer()
 72 {
 73 #ifndef NDEBUG
 74     ASSERT(m_creationThread.ptr() == &amp;Thread::current());
 75 #endif
 76 }
 77 
 78 void ServiceWorkerContainer::refEventTarget()
 79 {
 80     m_navigator.ref();
 81 }
 82 
 83 void ServiceWorkerContainer::derefEventTarget()
 84 {
 85     m_navigator.deref();
 86 }
 87 
 88 auto ServiceWorkerContainer::ready() -&gt; ReadyPromise&amp;
 89 {
 90     if (!m_readyPromise) {
<span class="line-modified"> 91         m_readyPromise = makeUnique&lt;ReadyPromise&gt;();</span>
 92 
 93         if (m_isStopped || !scriptExecutionContext()-&gt;sessionID().isValid())
 94             return *m_readyPromise;
 95 
 96         auto&amp; context = *scriptExecutionContext();
 97         auto contextIdentifier = this-&gt;contextIdentifier();
 98         callOnMainThread([connection = makeRef(ensureSWClientConnection()), topOrigin = context.topOrigin().isolatedCopy(), clientURL = context.url().isolatedCopy(), contextIdentifier]() mutable {
 99             connection-&gt;whenRegistrationReady(topOrigin, clientURL, [contextIdentifier](auto&amp;&amp; registrationData) {
100                 ScriptExecutionContext::postTaskTo(contextIdentifier, [registrationData = crossThreadCopy(registrationData)](auto&amp; context) mutable {
101                     auto* serviceWorkerContainer = context.serviceWorkerContainer();
102                     if (!serviceWorkerContainer)
103                         return;
104                     if (serviceWorkerContainer-&gt;m_isStopped || !context.sessionID().isValid())
105                         return;
106 
107                     auto registration = ServiceWorkerRegistration::getOrCreate(context, *serviceWorkerContainer, WTFMove(registrationData));
108                     serviceWorkerContainer-&gt;m_readyPromise-&gt;resolve(WTFMove(registration));
109                 });
110             });
111         });
</pre>
<hr />
<pre>
163     if (!jobData.scopeURL.isNull() &amp;&amp; !SchemeRegistry::canServiceWorkersHandleURLScheme(jobData.scopeURL.protocol().toStringWithoutCopying())) {
164         CONTAINER_RELEASE_LOG_ERROR_IF_ALLOWED(&quot;addRegistration: scopeURL scheme is not HTTP or HTTPS&quot;);
165         promise-&gt;reject(Exception { TypeError, &quot;Scope URL provided to serviceWorker.register() must be either HTTP or HTTPS&quot;_s });
166         return;
167     }
168 
169     path = jobData.scopeURL.path();
170     if (path.containsIgnoringASCIICase(&quot;%2f&quot;) || path.containsIgnoringASCIICase(&quot;%5c&quot;)) {
171         CONTAINER_RELEASE_LOG_ERROR_IF_ALLOWED(&quot;addRegistration: scopeURL contains invalid character&quot;);
172         promise-&gt;reject(Exception { TypeError, &quot;Scope URL provided to serviceWorker.register() cannot have a path that contains &#39;%2f&#39; or &#39;%5c&#39;&quot;_s });
173         return;
174     }
175 
176     CONTAINER_RELEASE_LOG_IF_ALLOWED(&quot;addRegistration: Registering service worker. Job ID: %&quot; PRIu64, jobData.identifier().jobIdentifier.toUInt64());
177 
178     jobData.clientCreationURL = context-&gt;url();
179     jobData.topOrigin = context-&gt;topOrigin().data();
180     jobData.type = ServiceWorkerJobType::Register;
181     jobData.registrationOptions = options;
182 
<span class="line-modified">183     scheduleJob(makeUnique&lt;ServiceWorkerJob&gt;(*this, WTFMove(promise), WTFMove(jobData)));</span>
184 }
185 
186 void ServiceWorkerContainer::removeRegistration(const URL&amp; scopeURL, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
187 {
188     auto* context = scriptExecutionContext();
189     if (!context || !context-&gt;sessionID().isValid()) {
190         ASSERT_NOT_REACHED();
191         promise-&gt;reject(Exception(InvalidStateError));
192         return;
193     }
194 
195     if (!m_swConnection) {
196         ASSERT_NOT_REACHED();
197         promise-&gt;reject(Exception(InvalidStateError));
198         return;
199     }
200 
201     ServiceWorkerJobData jobData(m_swConnection-&gt;serverConnectionIdentifier(), contextIdentifier());
202     jobData.clientCreationURL = context-&gt;url();
203     jobData.topOrigin = context-&gt;topOrigin().data();
204     jobData.type = ServiceWorkerJobType::Unregister;
205     jobData.scopeURL = scopeURL;
206 
207     CONTAINER_RELEASE_LOG_IF_ALLOWED(&quot;removeRegistration: Unregistering service worker. Job ID: %&quot; PRIu64, jobData.identifier().jobIdentifier.toUInt64());
208 
<span class="line-modified">209     scheduleJob(makeUnique&lt;ServiceWorkerJob&gt;(*this, WTFMove(promise), WTFMove(jobData)));</span>
210 }
211 
212 void ServiceWorkerContainer::updateRegistration(const URL&amp; scopeURL, const URL&amp; scriptURL, WorkerType, RefPtr&lt;DeferredPromise&gt;&amp;&amp; promise)
213 {
214     ASSERT(!m_isStopped);
215 
216     auto&amp; context = *scriptExecutionContext();
217     ASSERT(context.sessionID().isValid());
218 
219     if (!m_swConnection) {
220         ASSERT_NOT_REACHED();
221         if (promise)
222             promise-&gt;reject(Exception(InvalidStateError));
223         return;
224     }
225 
226     ServiceWorkerJobData jobData(m_swConnection-&gt;serverConnectionIdentifier(), contextIdentifier());
227     jobData.clientCreationURL = context.url();
228     jobData.topOrigin = context.topOrigin().data();
229     jobData.type = ServiceWorkerJobType::Update;
230     jobData.scopeURL = scopeURL;
231     jobData.scriptURL = scriptURL;
232 
233     CONTAINER_RELEASE_LOG_IF_ALLOWED(&quot;removeRegistration: Updating service worker. Job ID: %&quot; PRIu64, jobData.identifier().jobIdentifier.toUInt64());
234 
<span class="line-modified">235     scheduleJob(makeUnique&lt;ServiceWorkerJob&gt;(*this, WTFMove(promise), WTFMove(jobData)));</span>
236 }
237 
238 void ServiceWorkerContainer::scheduleJob(std::unique_ptr&lt;ServiceWorkerJob&gt;&amp;&amp; job)
239 {
240 #ifndef NDEBUG
241     ASSERT(m_creationThread.ptr() == &amp;Thread::current());
242 #endif
243 
244     ASSERT(m_swConnection);
245     ASSERT(!isStopped());
246 
247     auto&amp; jobData = job-&gt;data();
248     auto jobIdentifier = job-&gt;identifier();
249     ASSERT(!m_jobMap.contains(jobIdentifier));
250     m_jobMap.add(jobIdentifier, OngoingJob { WTFMove(job), makePendingActivity(*this) });
251 
252     callOnMainThread([connection = m_swConnection, contextIdentifier = this-&gt;contextIdentifier(), jobData = jobData.isolatedCopy()] {
253         connection-&gt;scheduleJob(contextIdentifier, jobData);
254     });
255 }
256 
257 void ServiceWorkerContainer::getRegistration(const String&amp; clientURL, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
258 {
259     auto* context = scriptExecutionContext();
260     if (m_isStopped || !context-&gt;sessionID().isValid()) {
261         promise-&gt;reject(Exception { InvalidStateError });
262         return;
263     }
264 
265     URL parsedURL = context-&gt;completeURL(clientURL);
266     if (!protocolHostAndPortAreEqual(parsedURL, context-&gt;url())) {
267         promise-&gt;reject(Exception { SecurityError, &quot;Origin of clientURL is not client&#39;s origin&quot;_s });
268         return;
269     }
270 
271     uint64_t pendingPromiseIdentifier = ++m_lastPendingPromiseIdentifier;
<span class="line-modified">272     auto pendingPromise = makeUnique&lt;PendingPromise&gt;(WTFMove(promise), makePendingActivity(*this));</span>
273     m_pendingPromises.add(pendingPromiseIdentifier, WTFMove(pendingPromise));
274 
275     auto contextIdentifier = this-&gt;contextIdentifier();
276     callOnMainThread([connection = makeRef(ensureSWClientConnection()), topOrigin = context-&gt;topOrigin().data().isolatedCopy(), parsedURL = parsedURL.isolatedCopy(), contextIdentifier, pendingPromiseIdentifier]() mutable {
277         connection-&gt;matchRegistration(WTFMove(topOrigin), parsedURL, [contextIdentifier, pendingPromiseIdentifier] (auto&amp;&amp; result) mutable {
278             ScriptExecutionContext::postTaskTo(contextIdentifier, [pendingPromiseIdentifier, result = crossThreadCopy(result)](auto&amp; context) mutable {
279                 auto* serviceWorkerContainer = context.serviceWorkerContainer();
280                 if (!serviceWorkerContainer)
281                     return;
282                 if (serviceWorkerContainer-&gt;m_isStopped || !context.sessionID().isValid())
283                     return;
284 
285                 serviceWorkerContainer-&gt;didFinishGetRegistrationRequest(pendingPromiseIdentifier, WTFMove(result));
286             });
287         });
288     });
289 }
290 
291 void ServiceWorkerContainer::didFinishGetRegistrationRequest(uint64_t pendingPromiseIdentifier, Optional&lt;ServiceWorkerRegistrationData&gt;&amp;&amp; result)
292 {
</pre>
<hr />
<pre>
295 #endif
296 
297     auto pendingPromise = m_pendingPromises.take(pendingPromiseIdentifier);
298     if (!pendingPromise)
299         return;
300 
301     if (m_isStopped || !scriptExecutionContext()-&gt;sessionID().isValid()) {
302         pendingPromise-&gt;promise-&gt;reject(Exception { InvalidStateError });
303         return;
304     }
305 
306     if (!result) {
307         pendingPromise-&gt;promise-&gt;resolve();
308         return;
309     }
310 
311     auto registration = ServiceWorkerRegistration::getOrCreate(*scriptExecutionContext(), *this, WTFMove(result.value()));
312     pendingPromise-&gt;promise-&gt;resolve&lt;IDLInterface&lt;ServiceWorkerRegistration&gt;&gt;(WTFMove(registration));
313 }
314 
<span class="line-modified">315 void ServiceWorkerContainer::updateRegistrationState(ServiceWorkerRegistrationIdentifier identifier, ServiceWorkerRegistrationState state, const Optional&lt;ServiceWorkerData&gt;&amp; serviceWorkerData)</span>
316 {
<span class="line-modified">317     if (m_isStopped)</span>

318         return;
319 
320     RefPtr&lt;ServiceWorker&gt; serviceWorker;
321     if (serviceWorkerData)
<span class="line-modified">322         serviceWorker = ServiceWorker::getOrCreate(*scriptExecutionContext(), ServiceWorkerData { *serviceWorkerData });</span>
323 
<span class="line-modified">324     if (auto* registration = m_registrations.get(identifier))</span>
<span class="line-modified">325         registration-&gt;updateStateFromServer(state, WTFMove(serviceWorker));</span>


326 }
327 
328 void ServiceWorkerContainer::getRegistrations(Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
329 {
330     auto* context = scriptExecutionContext();
331     if (m_isStopped || !context-&gt;sessionID().isValid()) {
332         promise-&gt;reject(Exception { InvalidStateError });
333         return;
334     }
335 
336     uint64_t pendingPromiseIdentifier = ++m_lastPendingPromiseIdentifier;
<span class="line-modified">337     auto pendingPromise = makeUnique&lt;PendingPromise&gt;(WTFMove(promise), makePendingActivity(*this));</span>
338     m_pendingPromises.add(pendingPromiseIdentifier, WTFMove(pendingPromise));
339 
340     auto contextIdentifier = this-&gt;contextIdentifier();
341     auto contextURL = context-&gt;url();
342     callOnMainThread([connection = makeRef(ensureSWClientConnection()), topOrigin = context-&gt;topOrigin().data().isolatedCopy(), contextURL = contextURL.isolatedCopy(), contextIdentifier, pendingPromiseIdentifier]() mutable {
343         connection-&gt;getRegistrations(WTFMove(topOrigin), contextURL, [contextIdentifier, pendingPromiseIdentifier] (auto&amp;&amp; registrationDatas) mutable {
344             ScriptExecutionContext::postTaskTo(contextIdentifier, [pendingPromiseIdentifier, registrationDatas = crossThreadCopy(registrationDatas)](auto&amp; context) mutable {
345                 auto* serviceWorkerContainer = context.serviceWorkerContainer();
346                 if (!serviceWorkerContainer)
347                     return;
348                 if (serviceWorkerContainer-&gt;m_isStopped || !context.sessionID().isValid())
349                     return;
350 
351                 serviceWorkerContainer-&gt;didFinishGetRegistrationsRequest(pendingPromiseIdentifier, WTFMove(registrationDatas));
352             });
353         });
354     });
355 }
356 
357 void ServiceWorkerContainer::didFinishGetRegistrationsRequest(uint64_t pendingPromiseIdentifier, Vector&lt;ServiceWorkerRegistrationData&gt;&amp;&amp; registrationDatas)
</pre>
<hr />
<pre>
388 
389     ASSERT_WITH_MESSAGE(job.hasPromise() || job.data().type == ServiceWorkerJobType::Update, &quot;Only soft updates have no promise&quot;);
390 
391     auto guard = WTF::makeScopeExit([this, &amp;job] {
392         destroyJob(job);
393     });
394 
395     CONTAINER_RELEASE_LOG_ERROR_IF_ALLOWED(&quot;jobFailedWithException: Job %&quot; PRIu64 &quot; failed with error %s&quot;, job.identifier().toUInt64(), exception.message().utf8().data());
396 
397     auto promise = job.takePromise();
398     if (!promise)
399         return;
400 
401     if (auto* context = scriptExecutionContext()) {
402         context-&gt;postTask([promise = WTFMove(promise), exception](auto&amp;) mutable {
403             promise-&gt;reject(exception);
404         });
405     }
406 }
407 
<span class="line-modified">408 void ServiceWorkerContainer::fireUpdateFoundEvent(ServiceWorkerRegistrationIdentifier identifier)</span>
409 {
410 #ifndef NDEBUG
411     ASSERT(m_creationThread.ptr() == &amp;Thread::current());
412 #endif
413 
414     if (auto* registration = m_registrations.get(identifier))
<span class="line-modified">415         registration-&gt;fireUpdateFoundEvent();</span>
416 }
417 
418 void ServiceWorkerContainer::jobResolvedWithRegistration(ServiceWorkerJob&amp; job, ServiceWorkerRegistrationData&amp;&amp; data, ShouldNotifyWhenResolved shouldNotifyWhenResolved)
419 {
420 #ifndef NDEBUG
421     ASSERT(m_creationThread.ptr() == &amp;Thread::current());
422 #endif
423     ASSERT_WITH_MESSAGE(job.hasPromise() || job.data().type == ServiceWorkerJobType::Update, &quot;Only soft updates have no promise&quot;);
424 




425     if (job.data().type == ServiceWorkerJobType::Register)
426         CONTAINER_RELEASE_LOG_IF_ALLOWED(&quot;jobResolvedWithRegistration: Registration job %&quot; PRIu64 &quot; succeeded&quot;, job.identifier().toUInt64());
427     else {
428         ASSERT(job.data().type == ServiceWorkerJobType::Update);
429         CONTAINER_RELEASE_LOG_IF_ALLOWED(&quot;jobResolvedWithRegistration: Update job %&quot; PRIu64 &quot; succeeded&quot;, job.identifier().toUInt64());
430     }
431 
<span class="line-modified">432     auto guard = WTF::makeScopeExit([this, &amp;job] {</span>
<span class="line-modified">433         destroyJob(job);</span>
<span class="line-modified">434     });</span>





435 
<span class="line-modified">436     auto notifyIfExitEarly = WTF::makeScopeExit([this, &amp;data, &amp;shouldNotifyWhenResolved] {</span>
<span class="line-modified">437         if (shouldNotifyWhenResolved == ShouldNotifyWhenResolved::Yes)</span>
<span class="line-modified">438             notifyRegistrationIsSettled(data.key);</span>
<span class="line-added">439     });</span>
<span class="line-added">440 </span>
<span class="line-added">441     if (isStopped())</span>
442         return;

443 
444     auto promise = job.takePromise();
<span class="line-modified">445     if (!promise)</span>


446         return;

447 
<span class="line-modified">448     notifyIfExitEarly.release();</span>
<span class="line-added">449 </span>
<span class="line-added">450     scriptExecutionContext()-&gt;postTask([this, protectedThis = RefPtr&lt;ServiceWorkerContainer&gt;(this), promise = WTFMove(promise), jobIdentifier = job.identifier(), data = WTFMove(data), shouldNotifyWhenResolved](ScriptExecutionContext&amp; context) mutable {</span>
451         if (isStopped() || !context.sessionID().isValid()) {
<span class="line-modified">452             if (shouldNotifyWhenResolved == ShouldNotifyWhenResolved::Yes)</span>
<span class="line-modified">453                 notifyRegistrationIsSettled(data.key);</span>
454             return;
455         }
456 
457         auto registration = ServiceWorkerRegistration::getOrCreate(context, *this, WTFMove(data));
458 
459         CONTAINER_RELEASE_LOG_IF_ALLOWED(&quot;jobResolvedWithRegistration: Resolving promise for job %&quot; PRIu64 &quot;. Registration ID: %&quot; PRIu64, jobIdentifier.toUInt64(), registration-&gt;identifier().toUInt64());
460 
<span class="line-modified">461         if (shouldNotifyWhenResolved == ShouldNotifyWhenResolved::Yes) {</span>
<span class="line-modified">462             m_ongoingSettledRegistrations.add(++m_lastOngoingSettledRegistrationIdentifier, registration-&gt;data().key);</span>
<span class="line-modified">463             promise-&gt;whenSettled([this, protectedThis = WTFMove(protectedThis), identifier = m_lastOngoingSettledRegistrationIdentifier] {</span>
<span class="line-added">464                 notifyRegistrationIsSettled(m_ongoingSettledRegistrations.take(identifier));</span>
465             });
466         }
467 
468         promise-&gt;resolve&lt;IDLInterface&lt;ServiceWorkerRegistration&gt;&gt;(WTFMove(registration));
469     });
470 }
471 
<span class="line-added">472 void ServiceWorkerContainer::postMessage(MessageWithMessagePorts&amp;&amp; message, ServiceWorkerData&amp;&amp; sourceData, String&amp;&amp; sourceOrigin)</span>
<span class="line-added">473 {</span>
<span class="line-added">474     auto&amp; context = *scriptExecutionContext();</span>
<span class="line-added">475     MessageEventSource source = RefPtr&lt;ServiceWorker&gt; { ServiceWorker::getOrCreate(context, WTFMove(sourceData)) };</span>
<span class="line-added">476 </span>
<span class="line-added">477     auto messageEvent = MessageEvent::create(MessagePort::entanglePorts(context, WTFMove(message.transferredPorts)), message.message.releaseNonNull(), sourceOrigin, { }, WTFMove(source));</span>
<span class="line-added">478     dispatchEvent(messageEvent);</span>
<span class="line-added">479 }</span>
<span class="line-added">480 </span>
<span class="line-added">481 void ServiceWorkerContainer::notifyRegistrationIsSettled(const ServiceWorkerRegistrationKey&amp; registrationKey)</span>
<span class="line-added">482 {</span>
<span class="line-added">483     callOnMainThread([connection = m_swConnection, registrationKey = registrationKey.isolatedCopy()] {</span>
<span class="line-added">484         connection-&gt;didResolveRegistrationPromise(registrationKey);</span>
<span class="line-added">485     });</span>
<span class="line-added">486 }</span>
<span class="line-added">487 </span>
488 void ServiceWorkerContainer::jobResolvedWithUnregistrationResult(ServiceWorkerJob&amp; job, bool unregistrationResult)
489 {
490 #ifndef NDEBUG
491     ASSERT(m_creationThread.ptr() == &amp;Thread::current());
492 #endif
493 
494     ASSERT(job.hasPromise());
495 
496     auto guard = WTF::makeScopeExit([this, &amp;job] {
497         destroyJob(job);
498     });
499 
500     CONTAINER_RELEASE_LOG_IF_ALLOWED(&quot;jobResolvedWithUnregistrationResult: Unregister job %&quot; PRIu64 &quot; finished. Success? %d&quot;, job.identifier().toUInt64(), unregistrationResult);
501 
502     auto* context = scriptExecutionContext();
503     if (!context) {
504         LOG_ERROR(&quot;ServiceWorkerContainer::jobResolvedWithUnregistrationResult called but the containers ScriptExecutionContext is gone&quot;);
505         return;
506     }
507 
</pre>
<hr />
<pre>
558     destroyJob(job);
559 }
560 
561 void ServiceWorkerContainer::notifyFailedFetchingScript(ServiceWorkerJob&amp; job, const ResourceError&amp; error)
562 {
563     callOnMainThread([connection = m_swConnection, jobIdentifier = job.identifier(), registrationKey = job.data().registrationKey().isolatedCopy(), error = error.isolatedCopy()] {
564         connection-&gt;failedFetchingScript(jobIdentifier, registrationKey, error);
565     });
566 }
567 
568 void ServiceWorkerContainer::destroyJob(ServiceWorkerJob&amp; job)
569 {
570 #ifndef NDEBUG
571     ASSERT(m_creationThread.ptr() == &amp;Thread::current());
572 #endif
573 
574     ASSERT(m_jobMap.contains(job.identifier()));
575     m_jobMap.remove(job.identifier());
576 }
577 






578 const char* ServiceWorkerContainer::activeDOMObjectName() const
579 {
580     return &quot;ServiceWorkerContainer&quot;;
581 }
582 
583 bool ServiceWorkerContainer::canSuspendForDocumentSuspension() const
584 {
585     return !hasPendingActivity();
586 }
587 
588 SWClientConnection&amp; ServiceWorkerContainer::ensureSWClientConnection()
589 {
590     ASSERT(scriptExecutionContext());
591     ASSERT(scriptExecutionContext()-&gt;sessionID().isValid());
592     if (!m_swConnection) {
593         ASSERT(scriptExecutionContext());
594         callOnMainThreadAndWait([this, sessionID = scriptExecutionContext()-&gt;sessionID()]() {
595             m_swConnection = &amp;ServiceWorkerProvider::singleton().serviceWorkerConnectionForSession(sessionID);
596         });
597     }
</pre>
<hr />
<pre>
601 void ServiceWorkerContainer::addRegistration(ServiceWorkerRegistration&amp; registration)
602 {
603 #ifndef NDEBUG
604     ASSERT(m_creationThread.ptr() == &amp;Thread::current());
605 #endif
606 
607     ensureSWClientConnection().addServiceWorkerRegistrationInServer(registration.identifier());
608     m_registrations.add(registration.identifier(), &amp;registration);
609 }
610 
611 void ServiceWorkerContainer::removeRegistration(ServiceWorkerRegistration&amp; registration)
612 {
613 #ifndef NDEBUG
614     ASSERT(m_creationThread.ptr() == &amp;Thread::current());
615 #endif
616 
617     m_swConnection-&gt;removeServiceWorkerRegistrationInServer(registration.identifier());
618     m_registrations.remove(registration.identifier());
619 }
620 
<span class="line-modified">621 void ServiceWorkerContainer::fireControllerChangeEvent()</span>
622 {
623 #ifndef NDEBUG
624     ASSERT(m_creationThread.ptr() == &amp;Thread::current());
625 #endif
626 
627     if (m_isStopped)
628         return;
629 
<span class="line-modified">630     dispatchEvent(Event::create(eventNames().controllerchangeEvent, Event::CanBubble::No, Event::IsCancelable::No));</span>





631 }
632 
633 void ServiceWorkerContainer::stop()
634 {
635     m_isStopped = true;
636     removeAllEventListeners();
637     m_pendingPromises.clear();
638     m_readyPromise = nullptr;
639     auto jobMap = WTFMove(m_jobMap);
640     for (auto&amp; ongoingJob : jobMap.values()) {
<span class="line-modified">641         if (ongoingJob.job-&gt;cancelPendingLoad())</span>
<span class="line-modified">642             notifyFailedFetchingScript(*ongoingJob.job.get(), ResourceError { errorDomainWebKitInternal, 0, ongoingJob.job-&gt;data().scriptURL, &quot;Job cancelled&quot;_s, ResourceError::Type::Cancellation });</span>
643     }
<span class="line-added">644 </span>
<span class="line-added">645     auto registrationMap = WTFMove(m_ongoingSettledRegistrations);</span>
<span class="line-added">646     for (auto&amp; registration : registrationMap.values())</span>
<span class="line-added">647         notifyRegistrationIsSettled(registration);</span>
648 }
649 
650 DocumentOrWorkerIdentifier ServiceWorkerContainer::contextIdentifier()
651 {
652 #ifndef NDEBUG
653     ASSERT(m_creationThread.ptr() == &amp;Thread::current());
654 #endif
655 
656     ASSERT(scriptExecutionContext());
657     if (is&lt;ServiceWorkerGlobalScope&gt;(*scriptExecutionContext()))
658         return downcast&lt;ServiceWorkerGlobalScope&gt;(*scriptExecutionContext()).thread().identifier();
659     return downcast&lt;Document&gt;(*scriptExecutionContext()).identifier();
660 }
661 
662 ServiceWorkerJob* ServiceWorkerContainer::job(ServiceWorkerJobIdentifier identifier)
663 {
664     auto iterator = m_jobMap.find(identifier);
665     if (iterator == m_jobMap.end())
666         return nullptr;
667     return iterator-&gt;value.job.get();
</pre>
</td>
</tr>
</table>
<center><a href="ServiceWorkerClients.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ServiceWorkerContainer.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>