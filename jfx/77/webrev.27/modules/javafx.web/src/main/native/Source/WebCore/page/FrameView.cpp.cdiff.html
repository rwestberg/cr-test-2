<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/page/FrameView.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FrameTree.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="FrameView.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/page/FrameView.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 32,10 ***</span>
<span class="line-new-header">--- 32,11 ---</span>
  #include &quot;CSSAnimationController.h&quot;
  #include &quot;CachedImage.h&quot;
  #include &quot;CachedResourceLoader.h&quot;
  #include &quot;Chrome.h&quot;
  #include &quot;ChromeClient.h&quot;
<span class="line-added">+ #include &quot;CustomHeaderFields.h&quot;</span>
  #include &quot;DOMWindow.h&quot;
  #include &quot;DebugPageOverlays.h&quot;
  #include &quot;DeprecatedGlobalSettings.h&quot;
  #include &quot;DocumentLoader.h&quot;
  #include &quot;DocumentMarkerController.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 83,10 ***</span>
<span class="line-new-header">--- 84,11 ---</span>
  #include &quot;RenderStyle.h&quot;
  #include &quot;RenderText.h&quot;
  #include &quot;RenderTheme.h&quot;
  #include &quot;RenderView.h&quot;
  #include &quot;RenderWidget.h&quot;
<span class="line-added">+ #include &quot;ResizeObserver.h&quot;</span>
  #include &quot;RuntimeEnabledFeatures.h&quot;
  #include &quot;SVGDocument.h&quot;
  #include &quot;SVGSVGElement.h&quot;
  #include &quot;ScriptRunner.h&quot;
  #include &quot;ScriptedAnimationController.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 95,10 ***</span>
<span class="line-new-header">--- 97,11 ---</span>
  #include &quot;Settings.h&quot;
  #include &quot;StyleResolver.h&quot;
  #include &quot;StyleScope.h&quot;
  #include &quot;TextResourceDecoder.h&quot;
  #include &quot;TiledBacking.h&quot;
<span class="line-added">+ #include &quot;VelocityData.h&quot;</span>
  #include &quot;VisualViewport.h&quot;
  #include &quot;WheelEventTestTrigger.h&quot;
  #include &lt;wtf/text/TextStream.h&gt;
  
  #include &lt;wtf/IsoMallocInlines.h&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 140,22 ***</span>
  static constexpr unsigned defaultSignificantRenderedTextCharacterThreshold = 3000;
  static constexpr float defaultSignificantRenderedTextMeanLength = 50;
  static constexpr unsigned mainArticleSignificantRenderedTextCharacterThreshold = 1500;
  static constexpr float mainArticleSignificantRenderedTextMeanLength = 25;
  
<span class="line-removed">- static OptionSet&lt;RenderLayer::UpdateLayerPositionsFlag&gt; updateLayerPositionFlags(RenderLayer* layer, bool isRelayoutingSubtree, bool didFullRepaint)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     auto flags = RenderLayer::updateLayerPositionsDefaultFlags();</span>
<span class="line-removed">-     if (didFullRepaint) {</span>
<span class="line-removed">-         flags.remove(RenderLayer::CheckForRepaint);</span>
<span class="line-removed">-         flags.add(RenderLayer::NeedsFullRepaintInBacking);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     if (isRelayoutingSubtree &amp;&amp; layer-&gt;enclosingPaginationLayer(RenderLayer::IncludeCompositedPaginatedLayers))</span>
<span class="line-removed">-         flags.add(RenderLayer::UpdatePagination);</span>
<span class="line-removed">-     return flags;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  Pagination::Mode paginationModeForRenderStyle(const RenderStyle&amp; style)
  {
      Overflow overflow = style.overflowY();
      if (overflow != Overflow::PagedX &amp;&amp; overflow != Overflow::PagedY)
          return Pagination::Unpaginated;
<span class="line-new-header">--- 143,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 311,26 ***</span>
  
  void FrameView::init()
  {
      reset();
  
<span class="line-removed">-     m_margins = LayoutSize(-1, -1); // undefined</span>
      m_size = LayoutSize();
  
<span class="line-modified">!     // Propagate the marginwidth/height and scrolling modes to the view.</span>
<span class="line-modified">!     Element* ownerElement = frame().ownerElement();</span>
<span class="line-modified">!     if (is&lt;HTMLFrameElementBase&gt;(ownerElement)) {</span>
<span class="line-modified">!         HTMLFrameElementBase&amp; frameElement = downcast&lt;HTMLFrameElementBase&gt;(*ownerElement);</span>
<span class="line-removed">-         if (frameElement.scrollingMode() == ScrollbarAlwaysOff)</span>
<span class="line-removed">-             setCanHaveScrollbars(false);</span>
<span class="line-removed">-         LayoutUnit marginWidth = frameElement.marginWidth();</span>
<span class="line-removed">-         LayoutUnit marginHeight = frameElement.marginHeight();</span>
<span class="line-removed">-         if (marginWidth != -1)</span>
<span class="line-removed">-             setMarginWidth(marginWidth);</span>
<span class="line-removed">-         if (marginHeight != -1)</span>
<span class="line-removed">-             setMarginHeight(marginHeight);</span>
<span class="line-removed">-     }</span>
  
      Page* page = frame().page();
      if (page &amp;&amp; page-&gt;chrome().client().shouldPaintEntireContents())
          setPaintsEntireContents(true);
  }
<span class="line-new-header">--- 302,16 ---</span>
  
  void FrameView::init()
  {
      reset();
  
      m_size = LayoutSize();
  
<span class="line-modified">!     // Propagate the scrolling mode to the view.</span>
<span class="line-modified">!     auto* ownerElement = frame().ownerElement();</span>
<span class="line-modified">!     if (is&lt;HTMLFrameElementBase&gt;(ownerElement) &amp;&amp; downcast&lt;HTMLFrameElementBase&gt;(*ownerElement).scrollingMode() == ScrollbarAlwaysOff)</span>
<span class="line-modified">!         setCanHaveScrollbars(false);</span>
  
      Page* page = frame().page();
      if (page &amp;&amp; page-&gt;chrome().client().shouldPaintEntireContents())
          setPaintsEntireContents(true);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 456,12 ***</span>
  {
      Ref&lt;FrameView&gt; protectedThis(*this);
      IntRect oldRect = frameRect();
      if (newRect == oldRect)
          return;
      // Every scroll that happens as the result of frame size change is programmatic.
<span class="line-modified">!     SetForScope&lt;bool&gt; changeInProgrammaticScroll(m_inProgrammaticScroll, true);</span>
      ScrollView::setFrameRect(newRect);
  
      updateScrollableAreaSet();
  
      if (RenderView* renderView = this-&gt;renderView()) {
<span class="line-new-header">--- 437,15 ---</span>
  {
      Ref&lt;FrameView&gt; protectedThis(*this);
      IntRect oldRect = frameRect();
      if (newRect == oldRect)
          return;
<span class="line-added">+ </span>
      // Every scroll that happens as the result of frame size change is programmatic.
<span class="line-modified">!     auto oldScrollType = currentScrollType();</span>
<span class="line-added">+     setCurrentScrollType(ScrollType::Programmatic);</span>
<span class="line-added">+ </span>
      ScrollView::setFrameRect(newRect);
  
      updateScrollableAreaSet();
  
      if (RenderView* renderView = this-&gt;renderView()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 471,10 ***</span>
<span class="line-new-header">--- 455,11 ---</span>
  
      if (frame().isMainFrame() &amp;&amp; frame().page())
          frame().page()-&gt;pageOverlayController().didChangeViewSize();
  
      viewportContentsChanged();
<span class="line-added">+     setCurrentScrollType(oldScrollType);</span>
  }
  
  bool FrameView::scheduleAnimation()
  {
      auto* page = frame().page();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 482,22 ***</span>
          return false;
      page-&gt;chrome().scheduleAnimation();
      return true;
  }
  
<span class="line-removed">- void FrameView::setMarginWidth(LayoutUnit w)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     // make it update the rendering area when set</span>
<span class="line-removed">-     m_margins.setWidth(w);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void FrameView::setMarginHeight(LayoutUnit h)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     // make it update the rendering area when set</span>
<span class="line-removed">-     m_margins.setHeight(h);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  FrameFlattening FrameView::effectiveFrameFlattening() const
  {
  #if PLATFORM(IOS_FAMILY)
      // On iOS when async frame scrolling is enabled, it does not make sense to use full frame flattening.
      // In that case, we just consider that frame flattening is disabled. This allows people to test
<span class="line-new-header">--- 467,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1087,17 ***</span>
      if (platformWidget())
          platformSetTopContentInset(newTopContentInset);
  
      layoutContext().layout();
      // Every scroll that happens as the result of content inset change is programmatic.
<span class="line-modified">!     SetForScope&lt;bool&gt; changeInProgrammaticScroll(m_inProgrammaticScroll, true);</span>
      updateScrollbars(scrollPosition());
      if (renderView-&gt;usesCompositing())
          renderView-&gt;compositor().frameViewDidChangeSize();
  
      if (TiledBacking* tiledBacking = this-&gt;tiledBacking())
          tiledBacking-&gt;setTopContentInset(newTopContentInset);
  }
  
  void FrameView::topContentDirectionDidChange()
  {
      m_needsDeferredScrollbarsUpdate = true;
<span class="line-new-header">--- 1060,21 ---</span>
      if (platformWidget())
          platformSetTopContentInset(newTopContentInset);
  
      layoutContext().layout();
      // Every scroll that happens as the result of content inset change is programmatic.
<span class="line-modified">!     auto oldScrollType = currentScrollType();</span>
<span class="line-added">+     setCurrentScrollType(ScrollType::Programmatic);</span>
<span class="line-added">+ </span>
      updateScrollbars(scrollPosition());
      if (renderView-&gt;usesCompositing())
          renderView-&gt;compositor().frameViewDidChangeSize();
  
      if (TiledBacking* tiledBacking = this-&gt;tiledBacking())
          tiledBacking-&gt;setTopContentInset(newTopContentInset);
<span class="line-added">+ </span>
<span class="line-added">+     setCurrentScrollType(oldScrollType);</span>
  }
  
  void FrameView::topContentDirectionDidChange()
  {
      m_needsDeferredScrollbarsUpdate = true;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1135,14 ***</span>
      return false;
  }
  
  bool FrameView::flushCompositingStateIncludingSubframes()
  {
<span class="line-removed">- #if PLATFORM(COCOA)</span>
<span class="line-removed">-     InspectorInstrumentation::willComposite(frame());</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
      bool allFramesFlushed = flushCompositingStateForThisFrame(frame());
  
      for (Frame* child = frame().tree().firstRenderedChild(); child; child = child-&gt;tree().traverseNextRendered(m_frame.ptr())) {
          if (!child-&gt;view())
              continue;
<span class="line-new-header">--- 1112,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1258,20 ***</span>
  
  void FrameView::didLayout(WeakPtr&lt;RenderElement&gt; layoutRoot)
  {
      renderView()-&gt;releaseProtectedRenderWidgets();
      auto* layoutRootEnclosingLayer = layoutRoot-&gt;enclosingLayer();
<span class="line-modified">!     layoutRootEnclosingLayer-&gt;updateLayerPositionsAfterLayout(renderView()-&gt;layer(), updateLayerPositionFlags(layoutRootEnclosingLayer, !is&lt;RenderView&gt;(*layoutRoot), layoutContext().needsFullRepaint()));</span>
  
      updateCompositingLayersAfterLayout();
  
  #if PLATFORM(COCOA) || PLATFORM(WIN) || PLATFORM(GTK)
      if (auto* cache = frame().document()-&gt;existingAXObjectCache())
          cache-&gt;postNotification(layoutRoot.get(), AXObjectCache::AXLayoutComplete);
  #endif
  
<span class="line-modified">!     frame().document()-&gt;invalidateRenderingDependentRegions(Document::AnnotationsAction::Update);</span>
  
      updateCanBlitOnScrollRecursively();
  
      handleDeferredScrollUpdateAfterContentSizeChange();
  
<span class="line-new-header">--- 1231,20 ---</span>
  
  void FrameView::didLayout(WeakPtr&lt;RenderElement&gt; layoutRoot)
  {
      renderView()-&gt;releaseProtectedRenderWidgets();
      auto* layoutRootEnclosingLayer = layoutRoot-&gt;enclosingLayer();
<span class="line-modified">!     layoutRootEnclosingLayer-&gt;updateLayerPositionsAfterLayout(!is&lt;RenderView&gt;(*layoutRoot), layoutContext().needsFullRepaint());</span>
  
      updateCompositingLayersAfterLayout();
  
  #if PLATFORM(COCOA) || PLATFORM(WIN) || PLATFORM(GTK)
      if (auto* cache = frame().document()-&gt;existingAXObjectCache())
          cache-&gt;postNotification(layoutRoot.get(), AXObjectCache::AXLayoutComplete);
  #endif
  
<span class="line-modified">!     frame().document()-&gt;invalidateRenderingDependentRegions();</span>
  
      updateCanBlitOnScrollRecursively();
  
      handleDeferredScrollUpdateAfterContentSizeChange();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1304,11 ***</span>
  }
  
  void FrameView::addEmbeddedObjectToUpdate(RenderEmbeddedObject&amp; embeddedObject)
  {
      if (!m_embeddedObjectsToUpdate)
<span class="line-modified">!         m_embeddedObjectsToUpdate = std::make_unique&lt;ListHashSet&lt;RenderEmbeddedObject*&gt;&gt;();</span>
  
      HTMLFrameOwnerElement&amp; element = embeddedObject.frameOwnerElement();
      if (is&lt;HTMLObjectElement&gt;(element) || is&lt;HTMLEmbedElement&gt;(element)) {
          // Tell the DOM element that it needs a widget update.
          HTMLPlugInImageElement&amp; pluginElement = downcast&lt;HTMLPlugInImageElement&gt;(element);
<span class="line-new-header">--- 1277,11 ---</span>
  }
  
  void FrameView::addEmbeddedObjectToUpdate(RenderEmbeddedObject&amp; embeddedObject)
  {
      if (!m_embeddedObjectsToUpdate)
<span class="line-modified">!         m_embeddedObjectsToUpdate = makeUnique&lt;ListHashSet&lt;RenderEmbeddedObject*&gt;&gt;();</span>
  
      HTMLFrameOwnerElement&amp; element = embeddedObject.frameOwnerElement();
      if (is&lt;HTMLObjectElement&gt;(element) || is&lt;HTMLEmbedElement&gt;(element)) {
          // Tell the DOM element that it needs a widget update.
          HTMLPlugInImageElement&amp; pluginElement = downcast&lt;HTMLPlugInImageElement&gt;(element);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1440,11 ***</span>
  void FrameView::addSlowRepaintObject(RenderElement&amp; renderer)
  {
      bool hadSlowRepaintObjects = hasSlowRepaintObjects();
  
      if (!m_slowRepaintObjects)
<span class="line-modified">!         m_slowRepaintObjects = std::make_unique&lt;HashSet&lt;const RenderElement*&gt;&gt;();</span>
  
      m_slowRepaintObjects-&gt;add(&amp;renderer);
      if (hadSlowRepaintObjects)
          return;
  
<span class="line-new-header">--- 1413,11 ---</span>
  void FrameView::addSlowRepaintObject(RenderElement&amp; renderer)
  {
      bool hadSlowRepaintObjects = hasSlowRepaintObjects();
  
      if (!m_slowRepaintObjects)
<span class="line-modified">!         m_slowRepaintObjects = makeUnique&lt;HashSet&lt;const RenderElement*&gt;&gt;();</span>
  
      m_slowRepaintObjects-&gt;add(&amp;renderer);
      if (hadSlowRepaintObjects)
          return;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1475,11 ***</span>
  }
  
  void FrameView::addViewportConstrainedObject(RenderLayerModelObject* object)
  {
      if (!m_viewportConstrainedObjects)
<span class="line-modified">!         m_viewportConstrainedObjects = std::make_unique&lt;ViewportConstrainedObjectSet&gt;();</span>
  
      if (!m_viewportConstrainedObjects-&gt;contains(object)) {
          m_viewportConstrainedObjects-&gt;add(object);
          if (platformWidget())
              updateCanBlitOnScrollRecursively();
<span class="line-new-header">--- 1448,11 ---</span>
  }
  
  void FrameView::addViewportConstrainedObject(RenderLayerModelObject* object)
  {
      if (!m_viewportConstrainedObjects)
<span class="line-modified">!         m_viewportConstrainedObjects = makeUnique&lt;ViewportConstrainedObjectSet&gt;();</span>
  
      if (!m_viewportConstrainedObjects-&gt;contains(object)) {
          m_viewportConstrainedObjects-&gt;add(object);
          if (platformWidget())
              updateCanBlitOnScrollRecursively();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1513,11 ***</span>
      auto documentHeight = documentSize.height();
      auto layoutViewportHeight = baseLayoutViewportSize.height();
      if (layoutViewportHeight &gt; documentHeight)
          return baseLayoutViewportSize;
  
<span class="line-modified">!     return { baseLayoutViewportSize.width(), std::min&lt;LayoutUnit&gt;(documentHeight, (1 + heightExpansionFactor) * layoutViewportHeight) };</span>
  }
  
  LayoutRect FrameView::computeUpdatedLayoutViewportRect(const LayoutRect&amp; layoutViewport, const LayoutRect&amp; documentRect, const LayoutSize&amp; unobscuredContentSize, const LayoutRect&amp; unobscuredContentRect, const LayoutSize&amp; baseLayoutViewportSize, const LayoutPoint&amp; stableLayoutViewportOriginMin, const LayoutPoint&amp; stableLayoutViewportOriginMax, LayoutViewportConstraint constraint)
  {
      LayoutRect layoutViewportRect = layoutViewport;
<span class="line-new-header">--- 1486,11 ---</span>
      auto documentHeight = documentSize.height();
      auto layoutViewportHeight = baseLayoutViewportSize.height();
      if (layoutViewportHeight &gt; documentHeight)
          return baseLayoutViewportSize;
  
<span class="line-modified">!     return { baseLayoutViewportSize.width(), std::min(documentHeight, LayoutUnit((1 + heightExpansionFactor) * layoutViewportHeight)) };</span>
  }
  
  LayoutRect FrameView::computeUpdatedLayoutViewportRect(const LayoutRect&amp; layoutViewport, const LayoutRect&amp; documentRect, const LayoutSize&amp; unobscuredContentSize, const LayoutRect&amp; unobscuredContentRect, const LayoutSize&amp; baseLayoutViewportSize, const LayoutPoint&amp; stableLayoutViewportOriginMin, const LayoutPoint&amp; stableLayoutViewportOriginMax, LayoutViewportConstraint constraint)
  {
      LayoutRect layoutViewportRect = layoutViewport;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1662,31 ***</span>
      LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;layoutViewport: &quot; &lt;&lt; layoutViewport);
      LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;visualViewport: &quot; &lt;&lt; visualViewportRect() &lt;&lt; &quot; (is override &quot; &lt;&lt; (bool)m_visualViewportOverrideRect &lt;&lt; &quot;)&quot;);
      LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;stable origins: min: &quot; &lt;&lt; minStableLayoutViewportOrigin() &lt;&lt; &quot; max: &quot;&lt;&lt; maxStableLayoutViewportOrigin());
  
      if (m_layoutViewportOverrideRect) {
<span class="line-modified">!         if (m_inProgrammaticScroll) {</span>
              LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;computing new override layout viewport because of programmatic scrolling&quot;);
              LayoutPoint newOrigin = computeLayoutViewportOrigin(visualViewportRect(), minStableLayoutViewportOrigin(), maxStableLayoutViewportOrigin(), layoutViewport, StickToDocumentBounds);
              setLayoutViewportOverrideRect(LayoutRect(newOrigin, m_layoutViewportOverrideRect.value().size()));
          }
<span class="line-modified">!         if (frame().settings().visualViewportAPIEnabled()) {</span>
<span class="line-removed">-             if (auto* window = frame().window())</span>
<span class="line-removed">-                 window-&gt;visualViewport().update();</span>
<span class="line-removed">-         }</span>
          return;
      }
  
      LayoutPoint newLayoutViewportOrigin = computeLayoutViewportOrigin(visualViewportRect(), minStableLayoutViewportOrigin(), maxStableLayoutViewportOrigin(), layoutViewport, scrollBehaviorForFixedElements());
      if (newLayoutViewportOrigin != m_layoutViewportOrigin) {
          setBaseLayoutViewportOrigin(newLayoutViewportOrigin);
          LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;layoutViewport changed to &quot; &lt;&lt; layoutViewportRect());
      }
<span class="line-modified">!     if (frame().settings().visualViewportAPIEnabled()) {</span>
<span class="line-removed">-         if (auto* window = frame().window())</span>
<span class="line-removed">-             window-&gt;visualViewport().update();</span>
<span class="line-removed">-     }</span>
  }
  
  LayoutPoint FrameView::minStableLayoutViewportOrigin() const
  {
      return unscaledMinimumScrollPosition();
<span class="line-new-header">--- 1635,25 ---</span>
      LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;layoutViewport: &quot; &lt;&lt; layoutViewport);
      LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;visualViewport: &quot; &lt;&lt; visualViewportRect() &lt;&lt; &quot; (is override &quot; &lt;&lt; (bool)m_visualViewportOverrideRect &lt;&lt; &quot;)&quot;);
      LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;stable origins: min: &quot; &lt;&lt; minStableLayoutViewportOrigin() &lt;&lt; &quot; max: &quot;&lt;&lt; maxStableLayoutViewportOrigin());
  
      if (m_layoutViewportOverrideRect) {
<span class="line-modified">!         if (currentScrollType() == ScrollType::Programmatic) {</span>
              LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;computing new override layout viewport because of programmatic scrolling&quot;);
              LayoutPoint newOrigin = computeLayoutViewportOrigin(visualViewportRect(), minStableLayoutViewportOrigin(), maxStableLayoutViewportOrigin(), layoutViewport, StickToDocumentBounds);
              setLayoutViewportOverrideRect(LayoutRect(newOrigin, m_layoutViewportOverrideRect.value().size()));
          }
<span class="line-modified">!         layoutOrVisualViewportChanged();</span>
          return;
      }
  
      LayoutPoint newLayoutViewportOrigin = computeLayoutViewportOrigin(visualViewportRect(), minStableLayoutViewportOrigin(), maxStableLayoutViewportOrigin(), layoutViewport, scrollBehaviorForFixedElements());
      if (newLayoutViewportOrigin != m_layoutViewportOrigin) {
          setBaseLayoutViewportOrigin(newLayoutViewportOrigin);
          LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;layoutViewport changed to &quot; &lt;&lt; layoutViewportRect());
      }
<span class="line-modified">!     layoutOrVisualViewportChanged();</span>
  }
  
  LayoutPoint FrameView::minStableLayoutViewportOrigin() const
  {
      return unscaledMinimumScrollPosition();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1960,33 ***</span>
          frameView.updateScriptedAnimationsAndTimersThrottlingState(visibleRect);
  
          if (auto* renderView = frameView.frame().contentRenderer())
              renderView-&gt;updateVisibleViewportRect(visibleRect);
      });
<span class="line-removed">- </span>
<span class="line-removed">- #if ENABLE(INTERSECTION_OBSERVER)</span>
<span class="line-removed">-     if (auto* document = frame().document()) {</span>
<span class="line-removed">-         if (auto* page = frame().page()) {</span>
<span class="line-removed">-             if (document-&gt;numberOfIntersectionObservers())</span>
<span class="line-removed">-                 page-&gt;addDocumentNeedingIntersectionObservationUpdate(*document);</span>
<span class="line-removed">-             if (!frame().isMainFrame()) {</span>
<span class="line-removed">-                 if (auto* mainDocument = frame().mainFrame().document()) {</span>
<span class="line-removed">-                     if (mainDocument-&gt;numberOfIntersectionObservers())</span>
<span class="line-removed">-                         page-&gt;addDocumentNeedingIntersectionObservationUpdate(*mainDocument);</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- #endif</span>
  }
  
<span class="line-modified">! IntRect FrameView::unobscuredContentRectExpandedByContentInsets() const</span>
  {
<span class="line-modified">!     FloatRect unobscuredContentRect = this-&gt;unobscuredContentRect();</span>
      if (auto* page = frame().page())
<span class="line-modified">!         unobscuredContentRect.expand(page-&gt;contentInsets());</span>
<span class="line-modified">!     return IntRect(unobscuredContentRect);</span>
  }
  
  bool FrameView::fixedElementsLayoutRelativeToFrame() const
  {
      return frame().settings().fixedElementsLayoutRelativeToFrame();
<span class="line-new-header">--- 1927,24 ---</span>
          frameView.updateScriptedAnimationsAndTimersThrottlingState(visibleRect);
  
          if (auto* renderView = frameView.frame().contentRenderer())
              renderView-&gt;updateVisibleViewportRect(visibleRect);
      });
  }
  
<span class="line-modified">! IntRect FrameView::viewRectExpandedByContentInsets() const</span>
  {
<span class="line-modified">!     FloatRect viewRect;</span>
<span class="line-added">+     if (delegatesScrolling() &amp;&amp; platformWidget())</span>
<span class="line-added">+         viewRect = unobscuredContentRect();</span>
<span class="line-added">+     else</span>
<span class="line-added">+         viewRect = visualViewportRect();</span>
<span class="line-added">+ </span>
      if (auto* page = frame().page())
<span class="line-modified">!         viewRect.expand(page-&gt;contentInsets());</span>
<span class="line-modified">! </span>
<span class="line-added">+     return IntRect(viewRect);</span>
  }
  
  bool FrameView::fixedElementsLayoutRelativeToFrame() const
  {
      return frame().settings().fixedElementsLayoutRelativeToFrame();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2007,37 ***</span>
      Page* page = frame().page();
      return page &amp;&amp; page-&gt;isVisible() &amp;&amp; page-&gt;focusController().isActive();
  }
  
  #if ENABLE(DARK_MODE_CSS)
<span class="line-modified">! RenderObject* FrameView::rendererForSupportedColorSchemes() const</span>
  {
      auto* document = frame().document();
      auto* documentElement = document ? document-&gt;documentElement() : nullptr;
      auto* documentElementRenderer = documentElement ? documentElement-&gt;renderer() : nullptr;
<span class="line-modified">!     if (documentElementRenderer &amp;&amp; documentElementRenderer-&gt;style().hasExplicitlySetSupportedColorSchemes())</span>
          return documentElementRenderer;
      auto* bodyElement = document ? document-&gt;bodyOrFrameset() : nullptr;
      return bodyElement ? bodyElement-&gt;renderer() : nullptr;
  }
  #endif
  
  bool FrameView::useDarkAppearance() const
  {
  #if ENABLE(DARK_MODE_CSS)
<span class="line-modified">!     if (auto* renderer = rendererForSupportedColorSchemes())</span>
          return renderer-&gt;useDarkAppearance();
  #endif
      if (auto* document = frame().document())
          return document-&gt;useDarkAppearance(nullptr);
      return false;
  }
  
  OptionSet&lt;StyleColor::Options&gt; FrameView::styleColorOptions() const
  {
  #if ENABLE(DARK_MODE_CSS)
<span class="line-modified">!     if (auto* renderer = rendererForSupportedColorSchemes())</span>
          return renderer-&gt;styleColorOptions();
  #endif
      if (auto* document = frame().document())
          return document-&gt;styleColorOptions(nullptr);
      return { };
<span class="line-new-header">--- 1965,37 ---</span>
      Page* page = frame().page();
      return page &amp;&amp; page-&gt;isVisible() &amp;&amp; page-&gt;focusController().isActive();
  }
  
  #if ENABLE(DARK_MODE_CSS)
<span class="line-modified">! RenderObject* FrameView::rendererForColorScheme() const</span>
  {
      auto* document = frame().document();
      auto* documentElement = document ? document-&gt;documentElement() : nullptr;
      auto* documentElementRenderer = documentElement ? documentElement-&gt;renderer() : nullptr;
<span class="line-modified">!     if (documentElementRenderer &amp;&amp; documentElementRenderer-&gt;style().hasExplicitlySetColorScheme())</span>
          return documentElementRenderer;
      auto* bodyElement = document ? document-&gt;bodyOrFrameset() : nullptr;
      return bodyElement ? bodyElement-&gt;renderer() : nullptr;
  }
  #endif
  
  bool FrameView::useDarkAppearance() const
  {
  #if ENABLE(DARK_MODE_CSS)
<span class="line-modified">!     if (auto* renderer = rendererForColorScheme())</span>
          return renderer-&gt;useDarkAppearance();
  #endif
      if (auto* document = frame().document())
          return document-&gt;useDarkAppearance(nullptr);
      return false;
  }
  
  OptionSet&lt;StyleColor::Options&gt; FrameView::styleColorOptions() const
  {
  #if ENABLE(DARK_MODE_CSS)
<span class="line-modified">!     if (auto* renderer = rendererForColorScheme())</span>
          return renderer-&gt;styleColorOptions();
  #endif
      if (auto* document = frame().document())
          return document-&gt;styleColorOptions(nullptr);
      return { };
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2266,18 ***</span>
  
  void FrameView::setScrollPosition(const ScrollPosition&amp; scrollPosition)
  {
      LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;FrameView::setScrollPosition &quot; &lt;&lt; scrollPosition &lt;&lt; &quot; , clearing anchor&quot;);
  
<span class="line-modified">!     SetForScope&lt;bool&gt; changeInProgrammaticScroll(m_inProgrammaticScroll, true);</span>
      m_maintainScrollPositionAnchor = nullptr;
      m_shouldScrollToFocusedElement = false;
      m_delayedScrollToFocusedElementTimer.stop();
      Page* page = frame().page();
      if (page &amp;&amp; page-&gt;expectsWheelEventTriggers())
          scrollAnimator().setWheelEventTestTrigger(page-&gt;testTrigger());
      ScrollView::setScrollPosition(scrollPosition);
  }
  
  void FrameView::resetScrollAnchor()
  {
      ASSERT(frame().document());
<span class="line-new-header">--- 2224,22 ---</span>
  
  void FrameView::setScrollPosition(const ScrollPosition&amp; scrollPosition)
  {
      LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;FrameView::setScrollPosition &quot; &lt;&lt; scrollPosition &lt;&lt; &quot; , clearing anchor&quot;);
  
<span class="line-modified">!     auto oldScrollType = currentScrollType();</span>
<span class="line-added">+     setCurrentScrollType(ScrollType::Programmatic);</span>
<span class="line-added">+ </span>
      m_maintainScrollPositionAnchor = nullptr;
      m_shouldScrollToFocusedElement = false;
      m_delayedScrollToFocusedElementTimer.stop();
      Page* page = frame().page();
      if (page &amp;&amp; page-&gt;expectsWheelEventTriggers())
          scrollAnimator().setWheelEventTestTrigger(page-&gt;testTrigger());
      ScrollView::setScrollPosition(scrollPosition);
<span class="line-added">+ </span>
<span class="line-added">+     setCurrentScrollType(oldScrollType);</span>
  }
  
  void FrameView::resetScrollAnchor()
  {
      ASSERT(frame().document());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2547,11 ***</span>
          return true;
  
      if (scrollingCoordinator-&gt;shouldUpdateScrollLayerPositionSynchronously(*this))
          return true;
  
<span class="line-modified">!     if (inProgrammaticScroll())</span>
          return true;
  
      return false;
  #endif
      return true;
<span class="line-new-header">--- 2509,11 ---</span>
          return true;
  
      if (scrollingCoordinator-&gt;shouldUpdateScrollLayerPositionSynchronously(*this))
          return true;
  
<span class="line-modified">!     if (currentScrollType() == ScrollType::Programmatic)</span>
          return true;
  
      return false;
  #endif
      return true;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2766,21 ***</span>
          return;
  
      tiledBacking-&gt;setScrollability(computeScrollability());
  }
  
<span class="line-modified">! #if PLATFORM(IOS_FAMILY)</span>
<span class="line-modified">! </span>
<span class="line-removed">- void FrameView::didUpdateViewportOverrideRects()</span>
  {
      if (!frame().settings().visualViewportAPIEnabled())
          return;
  
      if (auto* window = frame().window())
          window-&gt;visualViewport().update();
  }
  
  void FrameView::unobscuredContentSizeChanged()
  {
      updateTiledBackingAdaptiveSizing();
  }
  
<span class="line-new-header">--- 2728,27 ---</span>
          return;
  
      tiledBacking-&gt;setScrollability(computeScrollability());
  }
  
<span class="line-modified">! // FIXME: This shouldn&#39;t be called from outside; FrameView should call it when the relevant viewports change.</span>
<span class="line-modified">! void FrameView::layoutOrVisualViewportChanged()</span>
  {
      if (!frame().settings().visualViewportAPIEnabled())
          return;
  
      if (auto* window = frame().window())
          window-&gt;visualViewport().update();
<span class="line-added">+ </span>
<span class="line-added">+     if (auto* page = frame().page()) {</span>
<span class="line-added">+         if (auto* scrollingCoordinator = page-&gt;scrollingCoordinator())</span>
<span class="line-added">+             scrollingCoordinator-&gt;frameViewVisualViewportChanged(*this);</span>
<span class="line-added">+     }</span>
  }
  
<span class="line-added">+ #if PLATFORM(IOS_FAMILY)</span>
<span class="line-added">+ </span>
  void FrameView::unobscuredContentSizeChanged()
  {
      updateTiledBackingAdaptiveSizing();
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2923,11 ***</span>
  }
  
  void FrameView::setNeedsCompositingConfigurationUpdate()
  {
      RenderView* renderView = this-&gt;renderView();
<span class="line-modified">!     if (renderView-&gt;usesCompositing()) {</span>
          if (auto* rootLayer = renderView-&gt;layer())
              rootLayer-&gt;setNeedsCompositingConfigurationUpdate();
          renderView-&gt;compositor().scheduleCompositingLayerUpdate();
      }
  }
<span class="line-new-header">--- 2891,11 ---</span>
  }
  
  void FrameView::setNeedsCompositingConfigurationUpdate()
  {
      RenderView* renderView = this-&gt;renderView();
<span class="line-modified">!     if (renderView &amp;&amp; renderView-&gt;usesCompositing()) {</span>
          if (auto* rootLayer = renderView-&gt;layer())
              rootLayer-&gt;setNeedsCompositingConfigurationUpdate();
          renderView-&gt;compositor().scheduleCompositingLayerUpdate();
      }
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2984,11 ***</span>
      return m_baseBackgroundColor;
  }
  
  void FrameView::setBaseBackgroundColor(const Color&amp; backgroundColor)
  {
<span class="line-modified">!     m_baseBackgroundColor = backgroundColor.isValid() ? backgroundColor : Color::white;</span>
  
      if (!isViewForDocumentInFrame())
          return;
  
      recalculateScrollbarOverlayStyle();
<span class="line-new-header">--- 2952,15 ---</span>
      return m_baseBackgroundColor;
  }
  
  void FrameView::setBaseBackgroundColor(const Color&amp; backgroundColor)
  {
<span class="line-modified">!     Color newBaseBackgroundColor = backgroundColor.isValid() ? backgroundColor : Color::white;</span>
<span class="line-added">+     if (m_baseBackgroundColor == newBaseBackgroundColor)</span>
<span class="line-added">+         return;</span>
<span class="line-added">+ </span>
<span class="line-added">+     m_baseBackgroundColor = newBaseBackgroundColor;</span>
  
      if (!isViewForDocumentInFrame())
          return;
  
      recalculateScrollbarOverlayStyle();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2996,11 ***</span>
      setNeedsCompositingConfigurationUpdate();
  }
  
  void FrameView::updateBackgroundRecursively(const Optional&lt;Color&gt;&amp; backgroundColor)
  {
<span class="line-modified">! #if ENABLE(DARK_MODE_CSS) &amp;&amp; PLATFORM(MAC)</span>
      Color baseBackgroundColor = backgroundColor.valueOr(RenderTheme::singleton().systemColor(CSSValueAppleSystemControlBackground, styleColorOptions()));
  #else
      Color baseBackgroundColor = backgroundColor.valueOr(Color::white);
  #endif
  
<span class="line-new-header">--- 2968,11 ---</span>
      setNeedsCompositingConfigurationUpdate();
  }
  
  void FrameView::updateBackgroundRecursively(const Optional&lt;Color&gt;&amp; backgroundColor)
  {
<span class="line-modified">! #if HAVE(OS_DARK_MODE_SUPPORT)</span>
      Color baseBackgroundColor = backgroundColor.valueOr(RenderTheme::singleton().systemColor(CSSValueAppleSystemControlBackground, styleColorOptions()));
  #else
      Color baseBackgroundColor = backgroundColor.valueOr(Color::white);
  #endif
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3438,95 ***</span>
  
      auto* renderView = document-&gt;renderView();
      if (!renderView)
          return;
  
      LOG(Layout, &quot;FrameView %p autoSizeIfEnabled&quot;, this);
      SetForScope&lt;bool&gt; changeInAutoSize(m_inAutoSize, true);
      if (layoutContext().subtreeLayoutRoot())
          layoutContext().convertSubtreeLayoutToFullLayout();
<span class="line-removed">-     // Start from the minimum size and allow it to grow.</span>
<span class="line-removed">-     resize(m_minAutoSize.width(), m_minAutoSize.height());</span>
<span class="line-removed">-     IntSize size = frameRect().size();</span>
<span class="line-removed">-     // Do the resizing twice. The first time is basically a rough calculation using the preferred width</span>
<span class="line-removed">-     // which may result in a height change during the second iteration.</span>
<span class="line-removed">-     for (int i = 0; i &lt; 2; i++) {</span>
<span class="line-removed">-         // Update various sizes including contentsSize, scrollHeight, etc.</span>
<span class="line-removed">-         document-&gt;updateLayoutIgnorePendingStylesheets();</span>
<span class="line-removed">-         int width = renderView-&gt;minPreferredLogicalWidth();</span>
<span class="line-removed">-         int height = renderView-&gt;documentRect().height();</span>
<span class="line-removed">-         IntSize newSize(width, height);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // Check to see if a scrollbar is needed for a given dimension and</span>
<span class="line-removed">-         // if so, increase the other dimension to account for the scrollbar.</span>
<span class="line-removed">-         // Since the dimensions are only for the view rectangle, once a</span>
<span class="line-removed">-         // dimension exceeds the maximum, there is no need to increase it further.</span>
<span class="line-removed">-         if (newSize.width() &gt; m_maxAutoSize.width()) {</span>
<span class="line-removed">-             RefPtr&lt;Scrollbar&gt; localHorizontalScrollbar = horizontalScrollbar();</span>
<span class="line-removed">-             if (!localHorizontalScrollbar)</span>
<span class="line-removed">-                 localHorizontalScrollbar = createScrollbar(HorizontalScrollbar);</span>
<span class="line-removed">-             newSize.expand(0, localHorizontalScrollbar-&gt;occupiedHeight());</span>
<span class="line-removed">- </span>
<span class="line-removed">-             // Don&#39;t bother checking for a vertical scrollbar because the width is at</span>
<span class="line-removed">-             // already greater the maximum.</span>
<span class="line-removed">-         } else if (newSize.height() &gt; m_maxAutoSize.height()) {</span>
<span class="line-removed">-             RefPtr&lt;Scrollbar&gt; localVerticalScrollbar = verticalScrollbar();</span>
<span class="line-removed">-             if (!localVerticalScrollbar)</span>
<span class="line-removed">-                 localVerticalScrollbar = createScrollbar(VerticalScrollbar);</span>
<span class="line-removed">-             newSize.expand(localVerticalScrollbar-&gt;occupiedWidth(), 0);</span>
<span class="line-removed">- </span>
<span class="line-removed">-             // Don&#39;t bother checking for a horizontal scrollbar because the height is</span>
<span class="line-removed">-             // already greater the maximum.</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // Ensure the size is at least the min bounds.</span>
<span class="line-removed">-         newSize = newSize.expandedTo(m_minAutoSize);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // Bound the dimensions by the max bounds and determine what scrollbars to show.</span>
<span class="line-removed">-         ScrollbarMode horizonalScrollbarMode = ScrollbarAlwaysOff;</span>
<span class="line-removed">-         if (newSize.width() &gt; m_maxAutoSize.width()) {</span>
<span class="line-removed">-             newSize.setWidth(m_maxAutoSize.width());</span>
<span class="line-removed">-             horizonalScrollbarMode = ScrollbarAlwaysOn;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         ScrollbarMode verticalScrollbarMode = ScrollbarAlwaysOff;</span>
<span class="line-removed">-         if (newSize.height() &gt; m_maxAutoSize.height()) {</span>
<span class="line-removed">-             newSize.setHeight(m_maxAutoSize.height());</span>
<span class="line-removed">-             verticalScrollbarMode = ScrollbarAlwaysOn;</span>
<span class="line-removed">-         }</span>
  
<span class="line-modified">!         if (newSize == size)</span>
<span class="line-modified">!             continue;</span>
  
<span class="line-modified">!         // While loading only allow the size to increase (to avoid twitching during intermediate smaller states)</span>
<span class="line-modified">!         // unless autoresize has just been turned on or the maximum size is smaller than the current size.</span>
<span class="line-modified">!         if (m_didRunAutosize &amp;&amp; size.height() &lt;= m_maxAutoSize.height() &amp;&amp; size.width() &lt;= m_maxAutoSize.width()</span>
<span class="line-modified">!             &amp;&amp; !frame().loader().isComplete() &amp;&amp; (newSize.height() &lt; size.height() || newSize.width() &lt; size.width()))</span>
<span class="line-removed">-             break;</span>
  
<span class="line-removed">-         // The first time around, resize to the minimum height again; otherwise,</span>
<span class="line-removed">-         // on pages (e.g. quirks mode) where the body/document resize to the view size,</span>
<span class="line-removed">-         // we&#39;ll end up not shrinking back down after resizing to the computed preferred width.</span>
<span class="line-removed">-         resize(newSize.width(), i ? newSize.height() : m_minAutoSize.height());</span>
<span class="line-removed">-         // Force the scrollbar state to avoid the scrollbar code adding them and causing them to be needed. For example,</span>
<span class="line-removed">-         // a vertical scrollbar may cause text to wrap and thus increase the height (which is the only reason the scollbar is needed).</span>
<span class="line-removed">-         setVerticalScrollbarLock(false);</span>
<span class="line-removed">-         setHorizontalScrollbarLock(false);</span>
<span class="line-removed">-         setScrollbarModes(horizonalScrollbarMode, verticalScrollbarMode, true, true);</span>
<span class="line-removed">-     }</span>
      Ref&lt;FrameView&gt; protectedThis(*this);
<span class="line-removed">-     // All the resizing above may have invalidated style (for example if viewport units are being used).</span>
      document-&gt;updateStyleIfNeeded();
<span class="line-modified">!     // FIXME: Use the final layout&#39;s result as the content size (webkit.org/b/173561).</span>
      m_autoSizeContentSize = contentsSize();
<span class="line-removed">-     if (m_autoSizeFixedMinimumHeight) {</span>
<span class="line-removed">-         auto contentsSize = this-&gt;contentsSize();</span>
<span class="line-removed">-         resize(contentsSize.width(), std::max(m_autoSizeFixedMinimumHeight, contentsSize.height()));</span>
<span class="line-removed">-         document-&gt;updateLayoutIgnorePendingStylesheets();</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     m_didRunAutosize = true;</span>
  
<span class="line-modified">!     LOG_WITH_STREAM(Layout, stream &lt;&lt; &quot;FrameView &quot; &lt;&lt; this &lt;&lt; &quot; autoSizeIfEnabled() changed size from &quot; &lt;&lt; size &lt;&lt; &quot; to &quot; &lt;&lt; frameRect().size());</span>
  }
  
  void FrameView::setAutoSizeFixedMinimumHeight(int fixedMinimumHeight)
  {
      if (m_autoSizeFixedMinimumHeight == fixedMinimumHeight)
<span class="line-new-header">--- 3410,45 ---</span>
  
      auto* renderView = document-&gt;renderView();
      if (!renderView)
          return;
  
<span class="line-added">+     auto* firstChild = renderView-&gt;firstChild();</span>
<span class="line-added">+     if (!firstChild)</span>
<span class="line-added">+         return;</span>
<span class="line-added">+ </span>
      LOG(Layout, &quot;FrameView %p autoSizeIfEnabled&quot;, this);
      SetForScope&lt;bool&gt; changeInAutoSize(m_inAutoSize, true);
      if (layoutContext().subtreeLayoutRoot())
          layoutContext().convertSubtreeLayoutToFullLayout();
  
<span class="line-modified">!     ScrollbarMode horizonalScrollbarMode = ScrollbarAlwaysOff;</span>
<span class="line-modified">!     ScrollbarMode verticalScrollbarMode = ScrollbarAlwaysOff;</span>
<span class="line-added">+     setVerticalScrollbarLock(false);</span>
<span class="line-added">+     setHorizontalScrollbarLock(false);</span>
<span class="line-added">+     setScrollbarModes(horizonalScrollbarMode, verticalScrollbarMode, true, true);</span>
  
<span class="line-modified">!     ASSERT(is&lt;RenderElement&gt;(*firstChild));</span>
<span class="line-modified">!     auto&amp; documentRenderer = downcast&lt;RenderElement&gt;(*firstChild);</span>
<span class="line-modified">!     documentRenderer.mutableStyle().setMaxWidth(Length(m_autoSizeConstraint.width(), Fixed));</span>
<span class="line-modified">!     resize(m_autoSizeConstraint.width(), m_autoSizeConstraint.height());</span>
  
      Ref&lt;FrameView&gt; protectedThis(*this);
      document-&gt;updateStyleIfNeeded();
<span class="line-modified">!     document-&gt;updateLayoutIgnorePendingStylesheets();</span>
<span class="line-added">+     // While the final content size could slightly be different after the next resize/layout (see below), we intentionally save and report</span>
<span class="line-added">+     // the current value to avoid unstable layout (e.g. content &quot;height: 100%&quot;).</span>
<span class="line-added">+     // See also webkit.org/b/173561</span>
      m_autoSizeContentSize = contentsSize();
  
<span class="line-modified">!     auto finalWidth = std::max(m_autoSizeConstraint.width(), m_autoSizeContentSize.width());</span>
<span class="line-added">+     auto finalHeight = m_autoSizeFixedMinimumHeight ? std::max(m_autoSizeFixedMinimumHeight, m_autoSizeContentSize.height()) : m_autoSizeContentSize.height();</span>
<span class="line-added">+     resize(finalWidth, finalHeight);</span>
<span class="line-added">+     document-&gt;updateLayoutIgnorePendingStylesheets();</span>
<span class="line-added">+     if (auto* page = frame().page())</span>
<span class="line-added">+         page-&gt;chrome().client().intrinsicContentsSizeChanged(m_autoSizeContentSize);</span>
<span class="line-added">+     m_didRunAutosize = true;</span>
  }
  
  void FrameView::setAutoSizeFixedMinimumHeight(int fixedMinimumHeight)
  {
      if (m_autoSizeFixedMinimumHeight == fixedMinimumHeight)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4093,11 ***</span>
  {
      LOG(Scrolling, &quot;FrameView::setWasScrolledByUser at %d&quot;, wasScrolledByUser);
  
      m_shouldScrollToFocusedElement = false;
      m_delayedScrollToFocusedElementTimer.stop();
<span class="line-modified">!     if (m_inProgrammaticScroll)</span>
          return;
      m_maintainScrollPositionAnchor = nullptr;
      if (m_wasScrolledByUser == wasScrolledByUser)
          return;
      m_wasScrolledByUser = wasScrolledByUser;
<span class="line-new-header">--- 4015,11 ---</span>
  {
      LOG(Scrolling, &quot;FrameView::setWasScrolledByUser at %d&quot;, wasScrolledByUser);
  
      m_shouldScrollToFocusedElement = false;
      m_delayedScrollToFocusedElementTimer.stop();
<span class="line-modified">!     if (currentScrollType() == ScrollType::Programmatic)</span>
          return;
      m_maintainScrollPositionAnchor = nullptr;
      if (m_wasScrolledByUser == wasScrolledByUser)
          return;
      m_wasScrolledByUser = wasScrolledByUser;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4152,13 ***</span>
          notifyWidgetsInAllFrames(DidPaintFlattened);
  
      m_paintBehavior = paintingState.paintBehavior;
      m_lastPaintTime = MonotonicTime::now();
  
<span class="line-removed">-     // Regions may have changed as a result of the visibility/z-index of element changing.</span>
<span class="line-removed">-     frame().document()-&gt;updateZOrderDependentRegions();</span>
<span class="line-removed">- </span>
      if (paintingState.isTopLevelPainter)
          sCurrentPaintTimeStamp = MonotonicTime();
  
      if (!context.paintingDisabled()) {
          InspectorInstrumentation::didPaint(*renderView(), dirtyRect);
<span class="line-new-header">--- 4074,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4515,28 ***</span>
          return false;
  
      return &amp;renderView-&gt;frameView() == this;
  }
  
<span class="line-modified">! void FrameView::enableAutoSizeMode(bool enable, const IntSize&amp; minSize, const IntSize&amp; maxSize)</span>
  {
<span class="line-modified">!     ASSERT(!enable || !minSize.isEmpty());</span>
<span class="line-modified">!     ASSERT(minSize.width() &lt;= maxSize.width());</span>
<span class="line-removed">-     ASSERT(minSize.height() &lt;= maxSize.height());</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (m_shouldAutoSize == enable &amp;&amp; m_minAutoSize == minSize &amp;&amp; m_maxAutoSize == maxSize)</span>
          return;
  
      m_shouldAutoSize = enable;
<span class="line-modified">!     m_minAutoSize = minSize;</span>
<span class="line-modified">!     m_maxAutoSize = maxSize;</span>
      m_didRunAutosize = false;
  
      setNeedsLayoutAfterViewConfigurationChange();
      layoutContext().scheduleLayout();
      if (m_shouldAutoSize) {
<span class="line-modified">!         overrideViewportSizeForCSSViewportUnits({ minSize.width(), m_overrideViewportSize ? m_overrideViewportSize-&gt;height : WTF::nullopt });</span>
          return;
      }
  
      clearViewportSizeOverrideForCSSViewportUnits();
      // Since autosize mode forces the scrollbar mode, change them to being auto.
<span class="line-new-header">--- 4434,25 ---</span>
          return false;
  
      return &amp;renderView-&gt;frameView() == this;
  }
  
<span class="line-modified">! void FrameView::enableAutoSizeMode(bool enable, const IntSize&amp; viewSize)</span>
  {
<span class="line-modified">!     ASSERT(!enable || !viewSize.isEmpty());</span>
<span class="line-modified">!     if (m_shouldAutoSize == enable &amp;&amp; m_autoSizeConstraint == viewSize)</span>
          return;
  
      m_shouldAutoSize = enable;
<span class="line-modified">!     m_autoSizeConstraint = viewSize;</span>
<span class="line-modified">!     m_autoSizeContentSize = contentsSize();</span>
      m_didRunAutosize = false;
  
      setNeedsLayoutAfterViewConfigurationChange();
      layoutContext().scheduleLayout();
      if (m_shouldAutoSize) {
<span class="line-modified">!         overrideViewportSizeForCSSViewportUnits({ m_autoSizeConstraint.width(), m_overrideViewportSize ? m_overrideViewportSize-&gt;height : WTF::nullopt });</span>
          return;
      }
  
      clearViewportSizeOverrideForCSSViewportUnits();
      // Since autosize mode forces the scrollbar mode, change them to being auto.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4596,11 ***</span>
          LayoutUnit docLogicalTop = horizontalWritingMode ? updatedDocumentRect.y() : updatedDocumentRect.x();
          LayoutUnit docLogicalRight = horizontalWritingMode ? updatedDocumentRect.maxX() : updatedDocumentRect.maxY();
          LayoutUnit clippedLogicalLeft;
          if (!renderView.style().isLeftToRightDirection())
              clippedLogicalLeft = docLogicalRight - pageLogicalWidth;
<span class="line-modified">!         LayoutRect overflow(clippedLogicalLeft, docLogicalTop, pageLogicalWidth, docLogicalHeight);</span>
  
          if (!horizontalWritingMode)
              overflow = overflow.transposedRect();
          renderView.clearLayoutOverflow();
          renderView.addLayoutOverflow(overflow); // This is how we clip in case we overflow again.
<span class="line-new-header">--- 4512,11 ---</span>
          LayoutUnit docLogicalTop = horizontalWritingMode ? updatedDocumentRect.y() : updatedDocumentRect.x();
          LayoutUnit docLogicalRight = horizontalWritingMode ? updatedDocumentRect.maxX() : updatedDocumentRect.maxY();
          LayoutUnit clippedLogicalLeft;
          if (!renderView.style().isLeftToRightDirection())
              clippedLogicalLeft = docLogicalRight - pageLogicalWidth;
<span class="line-modified">!         LayoutRect overflow { clippedLogicalLeft, docLogicalTop, LayoutUnit(pageLogicalWidth), docLogicalHeight };</span>
  
          if (!horizontalWritingMode)
              overflow = overflow.transposedRect();
          renderView.clearLayoutOverflow();
          renderView.addLayoutOverflow(overflow); // This is how we clip in case we overflow again.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4839,17 ***</span>
<span class="line-new-header">--- 4755,41 ---</span>
  {
      point.move(-documentToClientOffset());
      return point;
  }
  
<span class="line-added">+ FloatPoint FrameView::absoluteToLayoutViewportPoint(FloatPoint p) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     ASSERT(frame().settings().visualViewportEnabled());</span>
<span class="line-added">+     p.scale(1 / frame().frameScaleFactor());</span>
<span class="line-added">+     p.moveBy(-layoutViewportRect().location());</span>
<span class="line-added">+     return p;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  FloatPoint FrameView::layoutViewportToAbsolutePoint(FloatPoint p) const
  {
      ASSERT(frame().settings().visualViewportEnabled());
      p.moveBy(layoutViewportRect().location());
      return p.scaled(frame().frameScaleFactor());
  }
  
<span class="line-added">+ FloatRect FrameView::layoutViewportToAbsoluteRect(FloatRect rect) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     ASSERT(frame().settings().visualViewportEnabled());</span>
<span class="line-added">+     rect.moveBy(layoutViewportRect().location());</span>
<span class="line-added">+     rect.scale(frame().frameScaleFactor());</span>
<span class="line-added">+     return rect;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ FloatRect FrameView::absoluteToLayoutViewportRect(FloatRect rect) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     ASSERT(frame().settings().visualViewportEnabled());</span>
<span class="line-added">+     rect.scale(1 / frame().frameScaleFactor());</span>
<span class="line-added">+     rect.moveBy(-layoutViewportRect().location());</span>
<span class="line-added">+     return rect;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  FloatRect FrameView::clientToLayoutViewportRect(FloatRect rect) const
  {
      ASSERT(frame().settings().visualViewportEnabled());
      rect.scale(frame().pageZoomFactor());
      return rect;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4907,11 ***</span>
  }
  
  bool FrameView::addScrollableArea(ScrollableArea* scrollableArea)
  {
      if (!m_scrollableAreas)
<span class="line-modified">!         m_scrollableAreas = std::make_unique&lt;ScrollableAreaSet&gt;();</span>
  
      if (m_scrollableAreas-&gt;add(scrollableArea).isNewEntry) {
          scrollableAreaSetChanged();
          return true;
      }
<span class="line-new-header">--- 4847,11 ---</span>
  }
  
  bool FrameView::addScrollableArea(ScrollableArea* scrollableArea)
  {
      if (!m_scrollableAreas)
<span class="line-modified">!         m_scrollableAreas = makeUnique&lt;ScrollableAreaSet&gt;();</span>
  
      if (m_scrollableAreas-&gt;add(scrollableArea).isNewEntry) {
          scrollableAreaSetChanged();
          return true;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5077,14 ***</span>
      m_useCustomSizeForResizeEvent = true;
      m_customSizeForResizeEvent = customSize;
      sendResizeEventIfNeeded();
  }
  
<span class="line-modified">! void FrameView::setScrollVelocity(double horizontalVelocity, double verticalVelocity, double scaleChangeRate, MonotonicTime timestamp)</span>
  {
      if (TiledBacking* tiledBacking = this-&gt;tiledBacking())
<span class="line-modified">!         tiledBacking-&gt;setVelocity(VelocityData(horizontalVelocity, verticalVelocity, scaleChangeRate, timestamp));</span>
  }
  #endif // PLATFORM(IOS_FAMILY)
  
  void FrameView::setScrollingPerformanceLoggingEnabled(bool flag)
  {
<span class="line-new-header">--- 5017,14 ---</span>
      m_useCustomSizeForResizeEvent = true;
      m_customSizeForResizeEvent = customSize;
      sendResizeEventIfNeeded();
  }
  
<span class="line-modified">! void FrameView::setScrollVelocity(const VelocityData&amp; velocityData)</span>
  {
      if (TiledBacking* tiledBacking = this-&gt;tiledBacking())
<span class="line-modified">!         tiledBacking-&gt;setVelocity(velocityData);</span>
  }
  #endif // PLATFORM(IOS_FAMILY)
  
  void FrameView::setScrollingPerformanceLoggingEnabled(bool flag)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5220,11 ***</span>
      return value / (frame().pageZoomFactor() * frame().frameScaleFactor());
  }
  
  LayoutUnit FrameView::mapFromCSSToLayoutUnits(int value) const
  {
<span class="line-modified">!     return value * frame().pageZoomFactor() * frame().frameScaleFactor();</span>
  }
  
  void FrameView::didAddWidgetToRenderTree(Widget&amp; widget)
  {
      ASSERT(!m_widgetsInRenderTree.contains(&amp;widget));
<span class="line-new-header">--- 5160,11 ---</span>
      return value / (frame().pageZoomFactor() * frame().frameScaleFactor());
  }
  
  LayoutUnit FrameView::mapFromCSSToLayoutUnits(int value) const
  {
<span class="line-modified">!     return LayoutUnit(value * frame().pageZoomFactor() * frame().frameScaleFactor());</span>
  }
  
  void FrameView::didAddWidgetToRenderTree(Widget&amp; widget)
  {
      ASSERT(!m_widgetsInRenderTree.contains(&amp;widget));
</pre>
<center><a href="FrameTree.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="FrameView.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>