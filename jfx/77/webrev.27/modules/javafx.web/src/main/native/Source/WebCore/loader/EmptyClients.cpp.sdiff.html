<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/loader/EmptyClients.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DocumentWriter.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="EmptyClients.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/loader/EmptyClients.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 17  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 18  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 19  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 20  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 21  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 22  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 23  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 24  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 25  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 26  */
 27 
 28 #include &quot;config.h&quot;
 29 #include &quot;EmptyClients.h&quot;
 30 
 31 #include &quot;ApplicationCacheStorage.h&quot;
 32 #include &quot;BackForwardClient.h&quot;
 33 #include &quot;CacheStorageProvider.h&quot;
 34 #include &quot;ColorChooser.h&quot;
 35 #include &quot;ContextMenuClient.h&quot;
 36 #include &quot;CookieJar.h&quot;

 37 #include &quot;DataListSuggestionPicker.h&quot;
 38 #include &quot;DatabaseProvider.h&quot;
 39 #include &quot;DiagnosticLoggingClient.h&quot;
 40 #include &quot;DocumentFragment.h&quot;
 41 #include &quot;DocumentLoader.h&quot;
 42 #include &quot;DragClient.h&quot;
 43 #include &quot;EditorClient.h&quot;
 44 #include &quot;EmptyFrameLoaderClient.h&quot;
 45 #include &quot;FileChooser.h&quot;
 46 #include &quot;FormState.h&quot;
 47 #include &quot;Frame.h&quot;
 48 #include &quot;FrameLoaderClient.h&quot;
 49 #include &quot;FrameNetworkingContext.h&quot;
 50 #include &quot;HTMLFormElement.h&quot;
 51 #include &quot;HistoryItem.h&quot;
 52 #include &quot;InProcessIDBServer.h&quot;
 53 #include &quot;InspectorClient.h&quot;
 54 #include &quot;LibWebRTCProvider.h&quot;
 55 #include &quot;NetworkStorageSession.h&quot;
 56 #include &quot;Page.h&quot;
</pre>
<hr />
<pre>
 91     unsigned forwardListCount() const final { return 0; }
 92     void close() final { }
 93 };
 94 
 95 #if ENABLE(CONTEXT_MENUS)
 96 
 97 class EmptyContextMenuClient final : public ContextMenuClient {
 98     void contextMenuDestroyed() final { }
 99 
100     void downloadURL(const URL&amp;) final { }
101     void searchWithGoogle(const Frame*) final { }
102     void lookUpInDictionary(Frame*) final { }
103     bool isSpeaking() final { return false; }
104     void speak(const String&amp;) final { }
105     void stopSpeaking() final { }
106 
107 #if PLATFORM(COCOA)
108     void searchWithSpotlight() final { }
109 #endif
110 




111 #if USE(ACCESSIBILITY_CONTEXT_MENUS)
112     void showContextMenu() final { }
113 #endif
114 };
115 
116 #endif // ENABLE(CONTEXT_MENUS)
117 
118 class EmptyDatabaseProvider final : public DatabaseProvider {
119 #if ENABLE(INDEXED_DATABASE)
<span class="line-modified">120     IDBClient::IDBConnectionToServer&amp; idbConnectionToServerForSession(const PAL::SessionID&amp;) final</span>
121     {
<span class="line-modified">122         static auto&amp; sharedConnection = InProcessIDBServer::create().leakRef();</span>
123         return sharedConnection.connectionToServer();
124     }
125 #endif
126 };
127 
128 class EmptyDiagnosticLoggingClient final : public DiagnosticLoggingClient {
129     void logDiagnosticMessage(const String&amp;, const String&amp;, ShouldSample) final { }
130     void logDiagnosticMessageWithResult(const String&amp;, const String&amp;, DiagnosticLoggingResultType, ShouldSample) final { }
131     void logDiagnosticMessageWithValue(const String&amp;, const String&amp;, double, unsigned, ShouldSample) final { }
132     void logDiagnosticMessageWithEnhancedPrivacy(const String&amp;, const String&amp;, ShouldSample) final { }

133 };
134 
135 #if ENABLE(DRAG_SUPPORT)
136 
137 class EmptyDragClient final : public DragClient {
138     void willPerformDragDestinationAction(DragDestinationAction, const DragData&amp;) final { }
139     void willPerformDragSourceAction(DragSourceAction, const IntPoint&amp;, DataTransfer&amp;) final { }
140     DragSourceAction dragSourceActionMaskForPoint(const IntPoint&amp;) final { return DragSourceActionNone; }
141     void startDrag(DragItem, DataTransfer&amp;, Frame&amp;) final { }
142     void dragControllerDestroyed() final { }
143 };
144 
145 #endif // ENABLE(DRAG_SUPPORT)
146 
147 class EmptyEditorClient final : public EditorClient {
148     WTF_MAKE_FAST_ALLOCATED;
149 
150 public:
151     EmptyEditorClient() = default;
152 
</pre>
<hr />
<pre>
165     bool shouldInsertNode(Node*, Range*, EditorInsertAction) final { return false; }
166     bool shouldInsertText(const String&amp;, Range*, EditorInsertAction) final { return false; }
167     bool shouldChangeSelectedRange(Range*, Range*, EAffinity, bool) final { return false; }
168 
169     bool shouldApplyStyle(StyleProperties*, Range*) final { return false; }
170     void didApplyStyle() final { }
171     bool shouldMoveRangeAfterDelete(Range*, Range*) final { return false; }
172 
173     void didBeginEditing() final { }
174     void respondToChangedContents() final { }
175     void respondToChangedSelection(Frame*) final { }
176     void updateEditorStateAfterLayoutIfEditabilityChanged() final { }
177     void discardedComposition(Frame*) final { }
178     void canceledComposition() final { }
179     void didUpdateComposition() final { }
180     void didEndEditing() final { }
181     void didEndUserTriggeredSelectionChanges() final { }
182     void willWriteSelectionToPasteboard(Range*) final { }
183     void didWriteSelectionToPasteboard() final { }
184     void getClientPasteboardDataForRange(Range*, Vector&lt;String&gt;&amp;, Vector&lt;RefPtr&lt;SharedBuffer&gt;&gt;&amp;) final { }
<span class="line-removed">185     String replacementURLForResource(Ref&lt;SharedBuffer&gt;&amp;&amp;, const String&amp;) final { return { }; }</span>
186     void requestCandidatesForSelection(const VisibleSelection&amp;) final { }
187     void handleAcceptedCandidateWithSoftSpaces(TextCheckingResult) final { }
188 
189     void registerUndoStep(UndoStep&amp;) final;
190     void registerRedoStep(UndoStep&amp;) final;
191     void clearUndoRedoOperations() final { }
192 


193     bool canCopyCut(Frame*, bool defaultValue) const final { return defaultValue; }
194     bool canPaste(Frame*, bool defaultValue) const final { return defaultValue; }
195     bool canUndo() const final { return false; }
196     bool canRedo() const final { return false; }
197 
198     void undo() final { }
199     void redo() final { }
200 
<span class="line-modified">201     void handleKeyboardEvent(KeyboardEvent*) final { }</span>
<span class="line-modified">202     void handleInputMethodKeydown(KeyboardEvent*) final { }</span>
203 
204     void textFieldDidBeginEditing(Element*) final { }
205     void textFieldDidEndEditing(Element*) final { }
206     void textDidChangeInTextField(Element*) final { }
207     bool doTextFieldCommandFromEvent(Element*, KeyboardEvent*) final { return false; }
208     void textWillBeDeletedInTextField(Element*) final { }
209     void textDidChangeInTextArea(Element*) final { }
210     void overflowScrollPositionChanged() final { }
211 
212 #if PLATFORM(IOS_FAMILY)
213     void startDelayingAndCoalescingContentChangeNotifications() final { }
214     void stopDelayingAndCoalescingContentChangeNotifications() final { }
215     bool hasRichlyEditableSelection() final { return false; }
216     int getPasteboardItemsCount() final { return 0; }
217     RefPtr&lt;DocumentFragment&gt; documentFragmentFromDelegate(int) final { return nullptr; }
218     bool performsTwoStepPaste(DocumentFragment*) final { return false; }
219     void updateStringForFind(const String&amp;) final { }
220 #endif
221 
222     bool performTwoStepDrop(DocumentFragment&amp;, Range&amp;, bool) final { return false; }
</pre>
<hr />
<pre>
244     bool isAutomaticTextReplacementEnabled() final { return false; }
245     void toggleAutomaticTextReplacement() final { }
246     bool isAutomaticSpellingCorrectionEnabled() final { return false; }
247     void toggleAutomaticSpellingCorrection() final { }
248 #endif
249 
250 #if PLATFORM(GTK)
251     bool shouldShowUnicodeMenu() final { return false; }
252 #endif
253 
254     TextCheckerClient* textChecker() final { return &amp;m_textCheckerClient; }
255 
256     void updateSpellingUIWithGrammarString(const String&amp;, const GrammarDetail&amp;) final { }
257     void updateSpellingUIWithMisspelledWord(const String&amp;) final { }
258     void showSpellingUI(bool) final { }
259     bool spellingUIIsShowing() final { return false; }
260 
261     void willSetInputMethodState() final { }
262     void setInputMethodState(bool) final { }
263 


264     class EmptyTextCheckerClient final : public TextCheckerClient {
265         bool shouldEraseMarkersAfterChangeSelection(TextCheckingType) const final { return true; }
266         void ignoreWordInSpellDocument(const String&amp;) final { }
267         void learnWord(const String&amp;) final { }
268         void checkSpellingOfString(StringView, int*, int*) final { }
269         String getAutoCorrectSuggestionForMisspelledWord(const String&amp;) final { return { }; }
270         void checkGrammarOfString(StringView, Vector&lt;GrammarDetail&gt;&amp;, int*, int*) final { }
271 
272 #if USE(UNIFIED_TEXT_CHECKING)
273         Vector&lt;TextCheckingResult&gt; checkTextOfParagraph(StringView, OptionSet&lt;TextCheckingType&gt;, const VisibleSelection&amp;) final { return Vector&lt;TextCheckingResult&gt;(); }
274 #endif
275 
276         void getGuessesForWord(const String&amp;, const String&amp;, const VisibleSelection&amp;, Vector&lt;String&gt;&amp;) final { }
277         void requestCheckingOfString(TextCheckingRequest&amp;, const VisibleSelection&amp;) final;
278     };
279 
280     EmptyTextCheckerClient m_textCheckerClient;
281 };
282 
283 class EmptyFrameNetworkingContext final : public FrameNetworkingContext {
</pre>
<hr />
<pre>
297 #endif
298 
299 #if PLATFORM(COCOA) || PLATFORM(WIN)
300     ResourceError blockedError(const ResourceRequest&amp;) const final { return { }; }
301 #endif
302 };
303 
304 class EmptyInspectorClient final : public InspectorClient {
305     void inspectedPageDestroyed() final { }
306     Inspector::FrontendChannel* openLocalFrontend(InspectorController*) final { return nullptr; }
307     void bringFrontendToFront() final { }
308     void highlight() final { }
309     void hideHighlight() final { }
310 };
311 
312 #if ENABLE(APPLE_PAY)
313 
314 class EmptyPaymentCoordinatorClient final : public PaymentCoordinatorClient {
315     Optional&lt;String&gt; validatedPaymentNetwork(const String&amp;) final { return WTF::nullopt; }
316     bool canMakePayments() final { return false; }
<span class="line-modified">317     void canMakePaymentsWithActiveCard(const String&amp;, const String&amp;, WTF::Function&lt;void(bool)&gt;&amp;&amp; completionHandler) final { callOnMainThread([completionHandler = WTFMove(completionHandler)] { completionHandler(false); }); }</span>
<span class="line-modified">318     void openPaymentSetup(const String&amp;, const String&amp;, WTF::Function&lt;void(bool)&gt;&amp;&amp; completionHandler) final { callOnMainThread([completionHandler = WTFMove(completionHandler)] { completionHandler(false); }); }</span>
319     bool showPaymentUI(const URL&amp;, const Vector&lt;URL&gt;&amp;, const ApplePaySessionPaymentRequest&amp;) final { return false; }
320     void completeMerchantValidation(const PaymentMerchantSession&amp;) final { }
321     void completeShippingMethodSelection(Optional&lt;ShippingMethodUpdate&gt;&amp;&amp;) final { }
322     void completeShippingContactSelection(Optional&lt;ShippingContactUpdate&gt;&amp;&amp;) final { }
323     void completePaymentMethodSelection(Optional&lt;PaymentMethodUpdate&gt;&amp;&amp;) final { }
324     void completePaymentSession(Optional&lt;PaymentAuthorizationResult&gt;&amp;&amp;) final { }
325     void cancelPaymentSession() final { }
326     void abortPaymentSession() final { }
327     void paymentCoordinatorDestroyed() final { }

328 };
329 
330 #endif
331 
332 class EmptyPluginInfoProvider final : public PluginInfoProvider {
333     void refreshPlugins() final { };
334     Vector&lt;PluginInfo&gt; pluginInfo(Page&amp;, Optional&lt;Vector&lt;SupportedPluginIdentifier&gt;&gt;&amp;) final { return { }; }
335     Vector&lt;PluginInfo&gt; webVisiblePluginInfo(Page&amp;, const URL&amp;) final { return { }; }
336 };
337 
338 class EmptyPopupMenu : public PopupMenu {
339 public:
340     EmptyPopupMenu() = default;
341 private:
342     void show(const IntRect&amp;, FrameView*, int) final { }
343     void hide() final { }
344     void updateFromElement() final { }
345     void disconnectClient() final { }
346 };
347 
348 class EmptyProgressTrackerClient final : public ProgressTrackerClient {
349     void willChangeEstimatedProgress() final { }
350     void didChangeEstimatedProgress() final { }
351     void progressStarted(Frame&amp;) final { }
352     void progressEstimateChanged(Frame&amp;) final { }
353     void progressFinished(Frame&amp;) final { }
354 };
355 
356 class EmptySearchPopupMenu : public SearchPopupMenu {
357 public:
358     EmptySearchPopupMenu()
359         : m_popup(adoptRef(*new EmptyPopupMenu))
360     {
361     }
362 
363 private:
364     PopupMenu* popupMenu() final { return m_popup.ptr(); }
<span class="line-modified">365     void saveRecentSearches(const AtomicString&amp;, const Vector&lt;RecentSearch&gt;&amp;) final { }</span>
<span class="line-modified">366     void loadRecentSearches(const AtomicString&amp;, Vector&lt;RecentSearch&gt;&amp;) final { }</span>
367     bool enabled() final { return false; }
368 
369     Ref&lt;EmptyPopupMenu&gt; m_popup;
370 };
371 
372 class EmptyStorageNamespaceProvider final : public StorageNamespaceProvider {
373     struct EmptyStorageArea : public StorageArea {
374         unsigned length() final { return 0; }
375         String key(unsigned) final { return { }; }
376         String item(const String&amp;) final { return { }; }
377         void setItem(Frame*, const String&amp;, const String&amp;, bool&amp;) final { }
378         void removeItem(Frame*, const String&amp;) final { }
379         void clear(Frame*) final { }
380         bool contains(const String&amp;) final { return false; }
381         StorageType storageType() const final { return StorageType::Local; }
382         size_t memoryBytesUsedByCache() final { return 0; }
<span class="line-removed">383         const SecurityOriginData&amp; securityOrigin() const final { static NeverDestroyed&lt;SecurityOriginData&gt; origin; return origin.get(); }</span>
384     };
385 
386     struct EmptyStorageNamespace final : public StorageNamespace {





387         Ref&lt;StorageArea&gt; storageArea(const SecurityOriginData&amp;) final { return adoptRef(*new EmptyStorageArea); }
<span class="line-modified">388         Ref&lt;StorageNamespace&gt; copy(Page*) final { return adoptRef(*new EmptyStorageNamespace); }</span>




389     };
390 
391     Ref&lt;StorageNamespace&gt; createSessionStorageNamespace(Page&amp;, unsigned) final;
<span class="line-modified">392     Ref&lt;StorageNamespace&gt; createLocalStorageNamespace(unsigned) final;</span>
<span class="line-modified">393     Ref&lt;StorageNamespace&gt; createEphemeralLocalStorageNamespace(Page&amp;, unsigned) final;</span>
<span class="line-modified">394     Ref&lt;StorageNamespace&gt; createTransientLocalStorageNamespace(SecurityOrigin&amp;, unsigned) final;</span>
395 };
396 
397 class EmptyUserContentProvider final : public UserContentProvider {
398     void forEachUserScript(Function&lt;void(DOMWrapperWorld&amp;, const UserScript&amp;)&gt;&amp;&amp;) const final { }
399     void forEachUserStyleSheet(Function&lt;void(const UserStyleSheet&amp;)&gt;&amp;&amp;) const final { }
400 #if ENABLE(USER_MESSAGE_HANDLERS)
401     void forEachUserMessageHandler(Function&lt;void(const UserMessageHandlerDescriptor&amp;)&gt;&amp;&amp;) const final { }
402 #endif
403 #if ENABLE(CONTENT_EXTENSIONS)
404     ContentExtensions::ContentExtensionsBackend&amp; userContentExtensionBackend() final { static NeverDestroyed&lt;ContentExtensions::ContentExtensionsBackend&gt; backend; return backend.get(); };
405 #endif
406 };
407 
408 class EmptyVisitedLinkStore final : public VisitedLinkStore {
<span class="line-modified">409     bool isLinkVisited(Page&amp;, SharedStringHash, const URL&amp;, const AtomicString&amp;) final { return false; }</span>
410     void addVisitedLink(Page&amp;, SharedStringHash) final { }
411 };
412 
413 RefPtr&lt;PopupMenu&gt; EmptyChromeClient::createPopupMenu(PopupMenuClient&amp;) const
414 {
415     return adoptRef(*new EmptyPopupMenu);
416 }
417 
418 RefPtr&lt;SearchPopupMenu&gt; EmptyChromeClient::createSearchPopupMenu(PopupMenuClient&amp;) const
419 {
420     return adoptRef(*new EmptySearchPopupMenu);
421 }
422 
423 #if ENABLE(INPUT_TYPE_COLOR)
424 
425 std::unique_ptr&lt;ColorChooser&gt; EmptyChromeClient::createColorChooser(ColorChooserClient&amp;, const Color&amp;)
426 {
427     return nullptr;
428 }
429 
</pre>
<hr />
<pre>
466 void EmptyFrameLoaderClient::dispatchWillSubmitForm(FormState&amp;, CompletionHandler&lt;void()&gt;&amp;&amp; completionHandler)
467 {
468     completionHandler();
469 }
470 
471 Ref&lt;DocumentLoader&gt; EmptyFrameLoaderClient::createDocumentLoader(const ResourceRequest&amp; request, const SubstituteData&amp; substituteData)
472 {
473     return DocumentLoader::create(request, substituteData);
474 }
475 
476 RefPtr&lt;Frame&gt; EmptyFrameLoaderClient::createFrame(const URL&amp;, const String&amp;, HTMLFrameOwnerElement&amp;, const String&amp;)
477 {
478     return nullptr;
479 }
480 
481 RefPtr&lt;Widget&gt; EmptyFrameLoaderClient::createPlugin(const IntSize&amp;, HTMLPlugInElement&amp;, const URL&amp;, const Vector&lt;String&gt;&amp;, const Vector&lt;String&gt;&amp;, const String&amp;, bool)
482 {
483     return nullptr;
484 }
485 
<span class="line-removed">486 void EmptyFrameLoaderClient::recreatePlugin(Widget*)</span>
<span class="line-removed">487 {</span>
<span class="line-removed">488 }</span>
<span class="line-removed">489 </span>
490 RefPtr&lt;Widget&gt; EmptyFrameLoaderClient::createJavaAppletWidget(const IntSize&amp;, HTMLAppletElement&amp;, const URL&amp;, const Vector&lt;String&gt;&amp;, const Vector&lt;String&gt;&amp;)
491 {
492     return nullptr;
493 }
494 
495 inline EmptyFrameNetworkingContext::EmptyFrameNetworkingContext()
496     : FrameNetworkingContext { nullptr }
497 {
498 }
499 
500 Ref&lt;FrameNetworkingContext&gt; EmptyFrameLoaderClient::createNetworkingContext()
501 {
502     return EmptyFrameNetworkingContext::create();
503 }
504 
505 void EmptyEditorClient::EmptyTextCheckerClient::requestCheckingOfString(TextCheckingRequest&amp;, const VisibleSelection&amp;)
506 {
507 }
508 
509 void EmptyEditorClient::registerUndoStep(UndoStep&amp;)
510 {
511 }
512 
513 void EmptyEditorClient::registerRedoStep(UndoStep&amp;)
514 {
515 }
516 
<span class="line-modified">517 Ref&lt;StorageNamespace&gt; EmptyStorageNamespaceProvider::createSessionStorageNamespace(Page&amp;, unsigned)</span>
<span class="line-removed">518 {</span>
<span class="line-removed">519     return adoptRef(*new EmptyStorageNamespace);</span>
<span class="line-removed">520 }</span>
<span class="line-removed">521 </span>
<span class="line-removed">522 Ref&lt;StorageNamespace&gt; EmptyStorageNamespaceProvider::createLocalStorageNamespace(unsigned)</span>
523 {
<span class="line-modified">524     return adoptRef(*new EmptyStorageNamespace);</span>
525 }
526 
<span class="line-modified">527 Ref&lt;StorageNamespace&gt; EmptyStorageNamespaceProvider::createEphemeralLocalStorageNamespace(Page&amp;, unsigned)</span>
528 {
<span class="line-modified">529     return adoptRef(*new EmptyStorageNamespace);</span>
530 }
531 
<span class="line-modified">532 Ref&lt;StorageNamespace&gt; EmptyStorageNamespaceProvider::createTransientLocalStorageNamespace(SecurityOrigin&amp;, unsigned)</span>
533 {
<span class="line-modified">534     return adoptRef(*new EmptyStorageNamespace);</span>
535 }
536 
537 class EmptyStorageSessionProvider : public StorageSessionProvider {
538     NetworkStorageSession* storageSession() const final { return nullptr; }
539 };
540 
541 PageConfiguration pageConfigurationWithEmptyClients()
542 {
543     PageConfiguration pageConfiguration {
544         makeUniqueRef&lt;EmptyEditorClient&gt;(),
545         SocketProvider::create(),
546         LibWebRTCProvider::create(),
547         CacheStorageProvider::create(),
548         adoptRef(*new EmptyBackForwardClient),
549         CookieJar::create(adoptRef(*new EmptyStorageSessionProvider))
550     };
551 
552     static NeverDestroyed&lt;EmptyChromeClient&gt; dummyChromeClient;
553     pageConfiguration.chromeClient = &amp;dummyChromeClient.get();
554 
</pre>
<hr />
<pre>
559 
560 #if ENABLE(CONTEXT_MENUS)
561     static NeverDestroyed&lt;EmptyContextMenuClient&gt; dummyContextMenuClient;
562     pageConfiguration.contextMenuClient = &amp;dummyContextMenuClient.get();
563 #endif
564 
565 #if ENABLE(DRAG_SUPPORT)
566     static NeverDestroyed&lt;EmptyDragClient&gt; dummyDragClient;
567     pageConfiguration.dragClient = &amp;dummyDragClient.get();
568 #endif
569 
570     static NeverDestroyed&lt;EmptyInspectorClient&gt; dummyInspectorClient;
571     pageConfiguration.inspectorClient = &amp;dummyInspectorClient.get();
572 
573     static NeverDestroyed&lt;EmptyFrameLoaderClient&gt; dummyFrameLoaderClient;
574     pageConfiguration.loaderClientForMainFrame = &amp;dummyFrameLoaderClient.get();
575 
576     static NeverDestroyed&lt;EmptyProgressTrackerClient&gt; dummyProgressTrackerClient;
577     pageConfiguration.progressTrackerClient = &amp;dummyProgressTrackerClient.get();
578 
<span class="line-modified">579     pageConfiguration.diagnosticLoggingClient = std::make_unique&lt;EmptyDiagnosticLoggingClient&gt;();</span>
580 
581     pageConfiguration.applicationCacheStorage = ApplicationCacheStorage::create({ }, { });
582     pageConfiguration.databaseProvider = adoptRef(*new EmptyDatabaseProvider);
583     pageConfiguration.pluginInfoProvider = adoptRef(*new EmptyPluginInfoProvider);
584     pageConfiguration.storageNamespaceProvider = adoptRef(*new EmptyStorageNamespaceProvider);
585     pageConfiguration.userContentProvider = adoptRef(*new EmptyUserContentProvider);
586     pageConfiguration.visitedLinkStore = adoptRef(*new EmptyVisitedLinkStore);
587 
588     return pageConfiguration;
589 }
590 
591 DiagnosticLoggingClient&amp; emptyDiagnosticLoggingClient()
592 {
593     static NeverDestroyed&lt;EmptyDiagnosticLoggingClient&gt; client;
594     return client;
595 }
596 
597 }
</pre>
</td>
<td>
<hr />
<pre>
 17  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 18  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 19  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 20  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 21  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 22  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 23  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 24  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 25  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 26  */
 27 
 28 #include &quot;config.h&quot;
 29 #include &quot;EmptyClients.h&quot;
 30 
 31 #include &quot;ApplicationCacheStorage.h&quot;
 32 #include &quot;BackForwardClient.h&quot;
 33 #include &quot;CacheStorageProvider.h&quot;
 34 #include &quot;ColorChooser.h&quot;
 35 #include &quot;ContextMenuClient.h&quot;
 36 #include &quot;CookieJar.h&quot;
<span class="line-added"> 37 #include &quot;DOMPasteAccess.h&quot;</span>
 38 #include &quot;DataListSuggestionPicker.h&quot;
 39 #include &quot;DatabaseProvider.h&quot;
 40 #include &quot;DiagnosticLoggingClient.h&quot;
 41 #include &quot;DocumentFragment.h&quot;
 42 #include &quot;DocumentLoader.h&quot;
 43 #include &quot;DragClient.h&quot;
 44 #include &quot;EditorClient.h&quot;
 45 #include &quot;EmptyFrameLoaderClient.h&quot;
 46 #include &quot;FileChooser.h&quot;
 47 #include &quot;FormState.h&quot;
 48 #include &quot;Frame.h&quot;
 49 #include &quot;FrameLoaderClient.h&quot;
 50 #include &quot;FrameNetworkingContext.h&quot;
 51 #include &quot;HTMLFormElement.h&quot;
 52 #include &quot;HistoryItem.h&quot;
 53 #include &quot;InProcessIDBServer.h&quot;
 54 #include &quot;InspectorClient.h&quot;
 55 #include &quot;LibWebRTCProvider.h&quot;
 56 #include &quot;NetworkStorageSession.h&quot;
 57 #include &quot;Page.h&quot;
</pre>
<hr />
<pre>
 92     unsigned forwardListCount() const final { return 0; }
 93     void close() final { }
 94 };
 95 
 96 #if ENABLE(CONTEXT_MENUS)
 97 
 98 class EmptyContextMenuClient final : public ContextMenuClient {
 99     void contextMenuDestroyed() final { }
100 
101     void downloadURL(const URL&amp;) final { }
102     void searchWithGoogle(const Frame*) final { }
103     void lookUpInDictionary(Frame*) final { }
104     bool isSpeaking() final { return false; }
105     void speak(const String&amp;) final { }
106     void stopSpeaking() final { }
107 
108 #if PLATFORM(COCOA)
109     void searchWithSpotlight() final { }
110 #endif
111 
<span class="line-added">112 #if PLATFORM(GTK)</span>
<span class="line-added">113     void insertEmoji(Frame&amp;) final { }</span>
<span class="line-added">114 #endif</span>
<span class="line-added">115 </span>
116 #if USE(ACCESSIBILITY_CONTEXT_MENUS)
117     void showContextMenu() final { }
118 #endif
119 };
120 
121 #endif // ENABLE(CONTEXT_MENUS)
122 
123 class EmptyDatabaseProvider final : public DatabaseProvider {
124 #if ENABLE(INDEXED_DATABASE)
<span class="line-modified">125     IDBClient::IDBConnectionToServer&amp; idbConnectionToServerForSession(const PAL::SessionID&amp; sessionID) final</span>
126     {
<span class="line-modified">127         static auto&amp; sharedConnection = InProcessIDBServer::create(sessionID).leakRef();</span>
128         return sharedConnection.connectionToServer();
129     }
130 #endif
131 };
132 
133 class EmptyDiagnosticLoggingClient final : public DiagnosticLoggingClient {
134     void logDiagnosticMessage(const String&amp;, const String&amp;, ShouldSample) final { }
135     void logDiagnosticMessageWithResult(const String&amp;, const String&amp;, DiagnosticLoggingResultType, ShouldSample) final { }
136     void logDiagnosticMessageWithValue(const String&amp;, const String&amp;, double, unsigned, ShouldSample) final { }
137     void logDiagnosticMessageWithEnhancedPrivacy(const String&amp;, const String&amp;, ShouldSample) final { }
<span class="line-added">138     void logDiagnosticMessageWithValueDictionary(const String&amp;, const String&amp;, const ValueDictionary&amp;, ShouldSample) final { }</span>
139 };
140 
141 #if ENABLE(DRAG_SUPPORT)
142 
143 class EmptyDragClient final : public DragClient {
144     void willPerformDragDestinationAction(DragDestinationAction, const DragData&amp;) final { }
145     void willPerformDragSourceAction(DragSourceAction, const IntPoint&amp;, DataTransfer&amp;) final { }
146     DragSourceAction dragSourceActionMaskForPoint(const IntPoint&amp;) final { return DragSourceActionNone; }
147     void startDrag(DragItem, DataTransfer&amp;, Frame&amp;) final { }
148     void dragControllerDestroyed() final { }
149 };
150 
151 #endif // ENABLE(DRAG_SUPPORT)
152 
153 class EmptyEditorClient final : public EditorClient {
154     WTF_MAKE_FAST_ALLOCATED;
155 
156 public:
157     EmptyEditorClient() = default;
158 
</pre>
<hr />
<pre>
171     bool shouldInsertNode(Node*, Range*, EditorInsertAction) final { return false; }
172     bool shouldInsertText(const String&amp;, Range*, EditorInsertAction) final { return false; }
173     bool shouldChangeSelectedRange(Range*, Range*, EAffinity, bool) final { return false; }
174 
175     bool shouldApplyStyle(StyleProperties*, Range*) final { return false; }
176     void didApplyStyle() final { }
177     bool shouldMoveRangeAfterDelete(Range*, Range*) final { return false; }
178 
179     void didBeginEditing() final { }
180     void respondToChangedContents() final { }
181     void respondToChangedSelection(Frame*) final { }
182     void updateEditorStateAfterLayoutIfEditabilityChanged() final { }
183     void discardedComposition(Frame*) final { }
184     void canceledComposition() final { }
185     void didUpdateComposition() final { }
186     void didEndEditing() final { }
187     void didEndUserTriggeredSelectionChanges() final { }
188     void willWriteSelectionToPasteboard(Range*) final { }
189     void didWriteSelectionToPasteboard() final { }
190     void getClientPasteboardDataForRange(Range*, Vector&lt;String&gt;&amp;, Vector&lt;RefPtr&lt;SharedBuffer&gt;&gt;&amp;) final { }

191     void requestCandidatesForSelection(const VisibleSelection&amp;) final { }
192     void handleAcceptedCandidateWithSoftSpaces(TextCheckingResult) final { }
193 
194     void registerUndoStep(UndoStep&amp;) final;
195     void registerRedoStep(UndoStep&amp;) final;
196     void clearUndoRedoOperations() final { }
197 
<span class="line-added">198     DOMPasteAccessResponse requestDOMPasteAccess(const String&amp;) final { return DOMPasteAccessResponse::DeniedForGesture; }</span>
<span class="line-added">199 </span>
200     bool canCopyCut(Frame*, bool defaultValue) const final { return defaultValue; }
201     bool canPaste(Frame*, bool defaultValue) const final { return defaultValue; }
202     bool canUndo() const final { return false; }
203     bool canRedo() const final { return false; }
204 
205     void undo() final { }
206     void redo() final { }
207 
<span class="line-modified">208     void handleKeyboardEvent(KeyboardEvent&amp;) final { }</span>
<span class="line-modified">209     void handleInputMethodKeydown(KeyboardEvent&amp;) final { }</span>
210 
211     void textFieldDidBeginEditing(Element*) final { }
212     void textFieldDidEndEditing(Element*) final { }
213     void textDidChangeInTextField(Element*) final { }
214     bool doTextFieldCommandFromEvent(Element*, KeyboardEvent*) final { return false; }
215     void textWillBeDeletedInTextField(Element*) final { }
216     void textDidChangeInTextArea(Element*) final { }
217     void overflowScrollPositionChanged() final { }
218 
219 #if PLATFORM(IOS_FAMILY)
220     void startDelayingAndCoalescingContentChangeNotifications() final { }
221     void stopDelayingAndCoalescingContentChangeNotifications() final { }
222     bool hasRichlyEditableSelection() final { return false; }
223     int getPasteboardItemsCount() final { return 0; }
224     RefPtr&lt;DocumentFragment&gt; documentFragmentFromDelegate(int) final { return nullptr; }
225     bool performsTwoStepPaste(DocumentFragment*) final { return false; }
226     void updateStringForFind(const String&amp;) final { }
227 #endif
228 
229     bool performTwoStepDrop(DocumentFragment&amp;, Range&amp;, bool) final { return false; }
</pre>
<hr />
<pre>
251     bool isAutomaticTextReplacementEnabled() final { return false; }
252     void toggleAutomaticTextReplacement() final { }
253     bool isAutomaticSpellingCorrectionEnabled() final { return false; }
254     void toggleAutomaticSpellingCorrection() final { }
255 #endif
256 
257 #if PLATFORM(GTK)
258     bool shouldShowUnicodeMenu() final { return false; }
259 #endif
260 
261     TextCheckerClient* textChecker() final { return &amp;m_textCheckerClient; }
262 
263     void updateSpellingUIWithGrammarString(const String&amp;, const GrammarDetail&amp;) final { }
264     void updateSpellingUIWithMisspelledWord(const String&amp;) final { }
265     void showSpellingUI(bool) final { }
266     bool spellingUIIsShowing() final { return false; }
267 
268     void willSetInputMethodState() final { }
269     void setInputMethodState(bool) final { }
270 
<span class="line-added">271     bool canShowFontPanel() const final { return false; }</span>
<span class="line-added">272 </span>
273     class EmptyTextCheckerClient final : public TextCheckerClient {
274         bool shouldEraseMarkersAfterChangeSelection(TextCheckingType) const final { return true; }
275         void ignoreWordInSpellDocument(const String&amp;) final { }
276         void learnWord(const String&amp;) final { }
277         void checkSpellingOfString(StringView, int*, int*) final { }
278         String getAutoCorrectSuggestionForMisspelledWord(const String&amp;) final { return { }; }
279         void checkGrammarOfString(StringView, Vector&lt;GrammarDetail&gt;&amp;, int*, int*) final { }
280 
281 #if USE(UNIFIED_TEXT_CHECKING)
282         Vector&lt;TextCheckingResult&gt; checkTextOfParagraph(StringView, OptionSet&lt;TextCheckingType&gt;, const VisibleSelection&amp;) final { return Vector&lt;TextCheckingResult&gt;(); }
283 #endif
284 
285         void getGuessesForWord(const String&amp;, const String&amp;, const VisibleSelection&amp;, Vector&lt;String&gt;&amp;) final { }
286         void requestCheckingOfString(TextCheckingRequest&amp;, const VisibleSelection&amp;) final;
287     };
288 
289     EmptyTextCheckerClient m_textCheckerClient;
290 };
291 
292 class EmptyFrameNetworkingContext final : public FrameNetworkingContext {
</pre>
<hr />
<pre>
306 #endif
307 
308 #if PLATFORM(COCOA) || PLATFORM(WIN)
309     ResourceError blockedError(const ResourceRequest&amp;) const final { return { }; }
310 #endif
311 };
312 
313 class EmptyInspectorClient final : public InspectorClient {
314     void inspectedPageDestroyed() final { }
315     Inspector::FrontendChannel* openLocalFrontend(InspectorController*) final { return nullptr; }
316     void bringFrontendToFront() final { }
317     void highlight() final { }
318     void hideHighlight() final { }
319 };
320 
321 #if ENABLE(APPLE_PAY)
322 
323 class EmptyPaymentCoordinatorClient final : public PaymentCoordinatorClient {
324     Optional&lt;String&gt; validatedPaymentNetwork(const String&amp;) final { return WTF::nullopt; }
325     bool canMakePayments() final { return false; }
<span class="line-modified">326     void canMakePaymentsWithActiveCard(const String&amp;, const String&amp;, CompletionHandler&lt;void(bool)&gt;&amp;&amp; completionHandler) final { callOnMainThread([completionHandler = WTFMove(completionHandler)]() mutable { completionHandler(false); }); }</span>
<span class="line-modified">327     void openPaymentSetup(const String&amp;, const String&amp;, CompletionHandler&lt;void(bool)&gt;&amp;&amp; completionHandler) final { callOnMainThread([completionHandler = WTFMove(completionHandler)]() mutable { completionHandler(false); }); }</span>
328     bool showPaymentUI(const URL&amp;, const Vector&lt;URL&gt;&amp;, const ApplePaySessionPaymentRequest&amp;) final { return false; }
329     void completeMerchantValidation(const PaymentMerchantSession&amp;) final { }
330     void completeShippingMethodSelection(Optional&lt;ShippingMethodUpdate&gt;&amp;&amp;) final { }
331     void completeShippingContactSelection(Optional&lt;ShippingContactUpdate&gt;&amp;&amp;) final { }
332     void completePaymentMethodSelection(Optional&lt;PaymentMethodUpdate&gt;&amp;&amp;) final { }
333     void completePaymentSession(Optional&lt;PaymentAuthorizationResult&gt;&amp;&amp;) final { }
334     void cancelPaymentSession() final { }
335     void abortPaymentSession() final { }
336     void paymentCoordinatorDestroyed() final { }
<span class="line-added">337     bool supportsUnrestrictedApplePay() const final { return false; }</span>
338 };
339 
340 #endif
341 
342 class EmptyPluginInfoProvider final : public PluginInfoProvider {
343     void refreshPlugins() final { };
344     Vector&lt;PluginInfo&gt; pluginInfo(Page&amp;, Optional&lt;Vector&lt;SupportedPluginIdentifier&gt;&gt;&amp;) final { return { }; }
345     Vector&lt;PluginInfo&gt; webVisiblePluginInfo(Page&amp;, const URL&amp;) final { return { }; }
346 };
347 
348 class EmptyPopupMenu : public PopupMenu {
349 public:
350     EmptyPopupMenu() = default;
351 private:
352     void show(const IntRect&amp;, FrameView*, int) final { }
353     void hide() final { }
354     void updateFromElement() final { }
355     void disconnectClient() final { }
356 };
357 
358 class EmptyProgressTrackerClient final : public ProgressTrackerClient {
359     void willChangeEstimatedProgress() final { }
360     void didChangeEstimatedProgress() final { }
361     void progressStarted(Frame&amp;) final { }
362     void progressEstimateChanged(Frame&amp;) final { }
363     void progressFinished(Frame&amp;) final { }
364 };
365 
366 class EmptySearchPopupMenu : public SearchPopupMenu {
367 public:
368     EmptySearchPopupMenu()
369         : m_popup(adoptRef(*new EmptyPopupMenu))
370     {
371     }
372 
373 private:
374     PopupMenu* popupMenu() final { return m_popup.ptr(); }
<span class="line-modified">375     void saveRecentSearches(const AtomString&amp;, const Vector&lt;RecentSearch&gt;&amp;) final { }</span>
<span class="line-modified">376     void loadRecentSearches(const AtomString&amp;, Vector&lt;RecentSearch&gt;&amp;) final { }</span>
377     bool enabled() final { return false; }
378 
379     Ref&lt;EmptyPopupMenu&gt; m_popup;
380 };
381 
382 class EmptyStorageNamespaceProvider final : public StorageNamespaceProvider {
383     struct EmptyStorageArea : public StorageArea {
384         unsigned length() final { return 0; }
385         String key(unsigned) final { return { }; }
386         String item(const String&amp;) final { return { }; }
387         void setItem(Frame*, const String&amp;, const String&amp;, bool&amp;) final { }
388         void removeItem(Frame*, const String&amp;) final { }
389         void clear(Frame*) final { }
390         bool contains(const String&amp;) final { return false; }
391         StorageType storageType() const final { return StorageType::Local; }
392         size_t memoryBytesUsedByCache() final { return 0; }

393     };
394 
395     struct EmptyStorageNamespace final : public StorageNamespace {
<span class="line-added">396         explicit EmptyStorageNamespace(PAL::SessionID sessionID)</span>
<span class="line-added">397             : m_sessionID(sessionID)</span>
<span class="line-added">398         {</span>
<span class="line-added">399         }</span>
<span class="line-added">400     private:</span>
401         Ref&lt;StorageArea&gt; storageArea(const SecurityOriginData&amp;) final { return adoptRef(*new EmptyStorageArea); }
<span class="line-modified">402         Ref&lt;StorageNamespace&gt; copy(Page*) final { return adoptRef(*new EmptyStorageNamespace { m_sessionID }); }</span>
<span class="line-added">403         PAL::SessionID sessionID() const final { return m_sessionID; }</span>
<span class="line-added">404         void setSessionIDForTesting(PAL::SessionID sessionID) final { m_sessionID = sessionID; };</span>
<span class="line-added">405 </span>
<span class="line-added">406         PAL::SessionID m_sessionID;</span>
407     };
408 
409     Ref&lt;StorageNamespace&gt; createSessionStorageNamespace(Page&amp;, unsigned) final;
<span class="line-modified">410     Ref&lt;StorageNamespace&gt; createLocalStorageNamespace(unsigned, PAL::SessionID) final;</span>
<span class="line-modified">411     Ref&lt;StorageNamespace&gt; createTransientLocalStorageNamespace(SecurityOrigin&amp;, unsigned, PAL::SessionID) final;</span>
<span class="line-modified">412 </span>
413 };
414 
415 class EmptyUserContentProvider final : public UserContentProvider {
416     void forEachUserScript(Function&lt;void(DOMWrapperWorld&amp;, const UserScript&amp;)&gt;&amp;&amp;) const final { }
417     void forEachUserStyleSheet(Function&lt;void(const UserStyleSheet&amp;)&gt;&amp;&amp;) const final { }
418 #if ENABLE(USER_MESSAGE_HANDLERS)
419     void forEachUserMessageHandler(Function&lt;void(const UserMessageHandlerDescriptor&amp;)&gt;&amp;&amp;) const final { }
420 #endif
421 #if ENABLE(CONTENT_EXTENSIONS)
422     ContentExtensions::ContentExtensionsBackend&amp; userContentExtensionBackend() final { static NeverDestroyed&lt;ContentExtensions::ContentExtensionsBackend&gt; backend; return backend.get(); };
423 #endif
424 };
425 
426 class EmptyVisitedLinkStore final : public VisitedLinkStore {
<span class="line-modified">427     bool isLinkVisited(Page&amp;, SharedStringHash, const URL&amp;, const AtomString&amp;) final { return false; }</span>
428     void addVisitedLink(Page&amp;, SharedStringHash) final { }
429 };
430 
431 RefPtr&lt;PopupMenu&gt; EmptyChromeClient::createPopupMenu(PopupMenuClient&amp;) const
432 {
433     return adoptRef(*new EmptyPopupMenu);
434 }
435 
436 RefPtr&lt;SearchPopupMenu&gt; EmptyChromeClient::createSearchPopupMenu(PopupMenuClient&amp;) const
437 {
438     return adoptRef(*new EmptySearchPopupMenu);
439 }
440 
441 #if ENABLE(INPUT_TYPE_COLOR)
442 
443 std::unique_ptr&lt;ColorChooser&gt; EmptyChromeClient::createColorChooser(ColorChooserClient&amp;, const Color&amp;)
444 {
445     return nullptr;
446 }
447 
</pre>
<hr />
<pre>
484 void EmptyFrameLoaderClient::dispatchWillSubmitForm(FormState&amp;, CompletionHandler&lt;void()&gt;&amp;&amp; completionHandler)
485 {
486     completionHandler();
487 }
488 
489 Ref&lt;DocumentLoader&gt; EmptyFrameLoaderClient::createDocumentLoader(const ResourceRequest&amp; request, const SubstituteData&amp; substituteData)
490 {
491     return DocumentLoader::create(request, substituteData);
492 }
493 
494 RefPtr&lt;Frame&gt; EmptyFrameLoaderClient::createFrame(const URL&amp;, const String&amp;, HTMLFrameOwnerElement&amp;, const String&amp;)
495 {
496     return nullptr;
497 }
498 
499 RefPtr&lt;Widget&gt; EmptyFrameLoaderClient::createPlugin(const IntSize&amp;, HTMLPlugInElement&amp;, const URL&amp;, const Vector&lt;String&gt;&amp;, const Vector&lt;String&gt;&amp;, const String&amp;, bool)
500 {
501     return nullptr;
502 }
503 




504 RefPtr&lt;Widget&gt; EmptyFrameLoaderClient::createJavaAppletWidget(const IntSize&amp;, HTMLAppletElement&amp;, const URL&amp;, const Vector&lt;String&gt;&amp;, const Vector&lt;String&gt;&amp;)
505 {
506     return nullptr;
507 }
508 
509 inline EmptyFrameNetworkingContext::EmptyFrameNetworkingContext()
510     : FrameNetworkingContext { nullptr }
511 {
512 }
513 
514 Ref&lt;FrameNetworkingContext&gt; EmptyFrameLoaderClient::createNetworkingContext()
515 {
516     return EmptyFrameNetworkingContext::create();
517 }
518 
519 void EmptyEditorClient::EmptyTextCheckerClient::requestCheckingOfString(TextCheckingRequest&amp;, const VisibleSelection&amp;)
520 {
521 }
522 
523 void EmptyEditorClient::registerUndoStep(UndoStep&amp;)
524 {
525 }
526 
527 void EmptyEditorClient::registerRedoStep(UndoStep&amp;)
528 {
529 }
530 
<span class="line-modified">531 Ref&lt;StorageNamespace&gt; EmptyStorageNamespaceProvider::createSessionStorageNamespace(Page&amp; page, unsigned)</span>





532 {
<span class="line-modified">533     return adoptRef(*new EmptyStorageNamespace { page.sessionID() });</span>
534 }
535 
<span class="line-modified">536 Ref&lt;StorageNamespace&gt; EmptyStorageNamespaceProvider::createLocalStorageNamespace(unsigned, PAL::SessionID sessionID)</span>
537 {
<span class="line-modified">538     return adoptRef(*new EmptyStorageNamespace { sessionID });</span>
539 }
540 
<span class="line-modified">541 Ref&lt;StorageNamespace&gt; EmptyStorageNamespaceProvider::createTransientLocalStorageNamespace(SecurityOrigin&amp;, unsigned, PAL::SessionID sessionID)</span>
542 {
<span class="line-modified">543     return adoptRef(*new EmptyStorageNamespace { sessionID });</span>
544 }
545 
546 class EmptyStorageSessionProvider : public StorageSessionProvider {
547     NetworkStorageSession* storageSession() const final { return nullptr; }
548 };
549 
550 PageConfiguration pageConfigurationWithEmptyClients()
551 {
552     PageConfiguration pageConfiguration {
553         makeUniqueRef&lt;EmptyEditorClient&gt;(),
554         SocketProvider::create(),
555         LibWebRTCProvider::create(),
556         CacheStorageProvider::create(),
557         adoptRef(*new EmptyBackForwardClient),
558         CookieJar::create(adoptRef(*new EmptyStorageSessionProvider))
559     };
560 
561     static NeverDestroyed&lt;EmptyChromeClient&gt; dummyChromeClient;
562     pageConfiguration.chromeClient = &amp;dummyChromeClient.get();
563 
</pre>
<hr />
<pre>
568 
569 #if ENABLE(CONTEXT_MENUS)
570     static NeverDestroyed&lt;EmptyContextMenuClient&gt; dummyContextMenuClient;
571     pageConfiguration.contextMenuClient = &amp;dummyContextMenuClient.get();
572 #endif
573 
574 #if ENABLE(DRAG_SUPPORT)
575     static NeverDestroyed&lt;EmptyDragClient&gt; dummyDragClient;
576     pageConfiguration.dragClient = &amp;dummyDragClient.get();
577 #endif
578 
579     static NeverDestroyed&lt;EmptyInspectorClient&gt; dummyInspectorClient;
580     pageConfiguration.inspectorClient = &amp;dummyInspectorClient.get();
581 
582     static NeverDestroyed&lt;EmptyFrameLoaderClient&gt; dummyFrameLoaderClient;
583     pageConfiguration.loaderClientForMainFrame = &amp;dummyFrameLoaderClient.get();
584 
585     static NeverDestroyed&lt;EmptyProgressTrackerClient&gt; dummyProgressTrackerClient;
586     pageConfiguration.progressTrackerClient = &amp;dummyProgressTrackerClient.get();
587 
<span class="line-modified">588     pageConfiguration.diagnosticLoggingClient = makeUnique&lt;EmptyDiagnosticLoggingClient&gt;();</span>
589 
590     pageConfiguration.applicationCacheStorage = ApplicationCacheStorage::create({ }, { });
591     pageConfiguration.databaseProvider = adoptRef(*new EmptyDatabaseProvider);
592     pageConfiguration.pluginInfoProvider = adoptRef(*new EmptyPluginInfoProvider);
593     pageConfiguration.storageNamespaceProvider = adoptRef(*new EmptyStorageNamespaceProvider);
594     pageConfiguration.userContentProvider = adoptRef(*new EmptyUserContentProvider);
595     pageConfiguration.visitedLinkStore = adoptRef(*new EmptyVisitedLinkStore);
596 
597     return pageConfiguration;
598 }
599 
600 DiagnosticLoggingClient&amp; emptyDiagnosticLoggingClient()
601 {
602     static NeverDestroyed&lt;EmptyDiagnosticLoggingClient&gt; client;
603     return client;
604 }
605 
606 }
</pre>
</td>
</tr>
</table>
<center><a href="DocumentWriter.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="EmptyClients.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>