<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/html/track/VTTCue.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2011, 2013 Google Inc.  All rights reserved.
   3  * Copyright (C) 2011-2017 Apple Inc. All rights reserved.
   4  *
   5  * Redistribution and use in source and binary forms, with or without
   6  * modification, are permitted provided that the following conditions are
   7  * met:
   8  *
   9  *     * Redistributions of source code must retain the above copyright
  10  * notice, this list of conditions and the following disclaimer.
  11  *     * Redistributions in binary form must reproduce the above
  12  * copyright notice, this list of conditions and the following disclaimer
  13  * in the documentation and/or other materials provided with the
  14  * distribution.
  15  *     * Neither the name of Google Inc. nor the names of its
  16  * contributors may be used to endorse or promote products derived from
  17  * this software without specific prior written permission.
  18  *
  19  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  20  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  21  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  22  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  23  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  24  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  25  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  26  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  27  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  28  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  29  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  30  */
  31 
  32 #include &quot;config.h&quot;
  33 #include &quot;VTTCue.h&quot;
  34 
  35 #if ENABLE(VIDEO_TRACK)
  36 
  37 #include &quot;CSSPropertyNames.h&quot;
  38 #include &quot;CSSValueKeywords.h&quot;
  39 #include &quot;DocumentFragment.h&quot;
  40 #include &quot;Event.h&quot;
  41 #include &quot;HTMLDivElement.h&quot;
  42 #include &quot;HTMLSpanElement.h&quot;
  43 #include &quot;HTMLStyleElement.h&quot;
  44 #include &quot;Logging.h&quot;
  45 #include &quot;NodeTraversal.h&quot;
  46 #include &quot;RenderVTTCue.h&quot;
  47 #include &quot;ScriptDisallowedScope.h&quot;
  48 #include &quot;Text.h&quot;
  49 #include &quot;TextTrack.h&quot;
  50 #include &quot;TextTrackCueList.h&quot;
  51 #include &quot;VTTRegionList.h&quot;
  52 #include &quot;VTTScanner.h&quot;
  53 #include &quot;WebVTTElement.h&quot;
  54 #include &quot;WebVTTParser.h&quot;
  55 #include &lt;wtf/IsoMallocInlines.h&gt;
  56 #include &lt;wtf/MathExtras.h&gt;
  57 #include &lt;wtf/text/StringBuilder.h&gt;
  58 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
  59 
  60 namespace WebCore {
  61 
  62 WTF_MAKE_ISO_ALLOCATED_IMPL(VTTCueBox);
<a name="1" id="anc1"></a><span class="line-added">  63 WTF_MAKE_ISO_ALLOCATED_IMPL(VTTCue);</span>
  64 
  65 // This constant should correspond with the percentage returned by CaptionUserPreferences::captionFontSizeScaleAndImportance.
  66 const static double DEFAULTCAPTIONFONTSIZEPERCENTAGE = 5;
  67 
  68 static const int undefinedPosition = -1;
  69 
  70 static const CSSValueID displayWritingModeMap[] = {
  71     CSSValueHorizontalTb, CSSValueVerticalRl, CSSValueVerticalLr
  72 };
  73 COMPILE_ASSERT(WTF_ARRAY_LENGTH(displayWritingModeMap) == VTTCue::NumberOfWritingDirections, displayWritingModeMap_has_wrong_size);
  74 
  75 static const CSSValueID displayAlignmentMap[] = {
  76     CSSValueStart, CSSValueCenter, CSSValueEnd, CSSValueLeft, CSSValueRight
  77 };
  78 COMPILE_ASSERT(WTF_ARRAY_LENGTH(displayAlignmentMap) == VTTCue::NumberOfAlignments, displayAlignmentMap_has_wrong_size);
  79 
  80 static const String&amp; startKeyword()
  81 {
  82     static NeverDestroyed&lt;const String&gt; start(MAKE_STATIC_STRING_IMPL(&quot;start&quot;));
  83     return start;
  84 }
  85 
  86 static const String&amp; centerKeyword()
  87 {
  88     static NeverDestroyed&lt;const String&gt; center(MAKE_STATIC_STRING_IMPL(&quot;center&quot;));
  89     return center;
  90 }
  91 
  92 static const String&amp; endKeyword()
  93 {
  94     static NeverDestroyed&lt;const String&gt; end(MAKE_STATIC_STRING_IMPL(&quot;end&quot;));
  95     return end;
  96 }
  97 
  98 static const String&amp; leftKeyword()
  99 {
 100     static NeverDestroyed&lt;const String&gt; left(MAKE_STATIC_STRING_IMPL(&quot;left&quot;));
 101     return left;
 102 }
 103 
 104 static const String&amp; rightKeyword()
 105 {
 106     static NeverDestroyed&lt;const String&gt; right(MAKE_STATIC_STRING_IMPL(&quot;right&quot;));
 107     return right;
 108 }
 109 
 110 static const String&amp; horizontalKeyword()
 111 {
 112     return emptyString();
 113 }
 114 
 115 static const String&amp; verticalGrowingLeftKeyword()
 116 {
 117     static NeverDestroyed&lt;const String&gt; verticalrl(MAKE_STATIC_STRING_IMPL(&quot;rl&quot;));
 118     return verticalrl;
 119 }
 120 
 121 static const String&amp; verticalGrowingRightKeyword()
 122 {
 123     static NeverDestroyed&lt;const String&gt; verticallr(MAKE_STATIC_STRING_IMPL(&quot;lr&quot;));
 124     return verticallr;
 125 }
 126 
 127 // ----------------------------
 128 
 129 Ref&lt;VTTCueBox&gt; VTTCueBox::create(Document&amp; document, VTTCue&amp; cue)
 130 {
 131     VTTCueBox&amp; cueBox = *new VTTCueBox(document, cue);
 132     cueBox.setPseudo(VTTCueBox::vttCueBoxShadowPseudoId());
 133     return adoptRef(cueBox);
 134 }
 135 
 136 VTTCueBox::VTTCueBox(Document&amp; document, VTTCue&amp; cue)
 137     : HTMLElement(divTag, document)
 138     , m_cue(makeWeakPtr(cue))
 139 {
 140     setPseudo(vttCueBoxShadowPseudoId());
 141 }
 142 
 143 VTTCue* VTTCueBox::getCue() const
 144 {
 145     return m_cue.get();
 146 }
 147 
 148 void VTTCueBox::applyCSSProperties(const IntSize&amp; videoSize)
 149 {
 150     if (!m_cue)
 151         return;
 152 
 153     auto cue = makeRef(*m_cue);
 154 
 155     // FIXME: Apply all the initial CSS positioning properties. http://wkb.ug/79916
 156     if (!cue-&gt;regionId().isEmpty()) {
 157         setInlineStyleProperty(CSSPropertyPosition, CSSValueRelative);
 158         return;
 159     }
 160 
 161     // 3.5.1 On the (root) List of WebVTT Node Objects:
 162 
 163     // the &#39;position&#39; property must be set to &#39;absolute&#39;
 164     setInlineStyleProperty(CSSPropertyPosition, CSSValueAbsolute);
 165 
 166     //  the &#39;unicode-bidi&#39; property must be set to &#39;plaintext&#39;
 167     setInlineStyleProperty(CSSPropertyUnicodeBidi, CSSValuePlaintext);
 168 
 169     // the &#39;direction&#39; property must be set to direction
 170     setInlineStyleProperty(CSSPropertyDirection, cue-&gt;getCSSWritingDirection());
 171 
 172     // the &#39;writing-mode&#39; property must be set to writing-mode
 173     setInlineStyleProperty(CSSPropertyWritingMode, cue-&gt;getCSSWritingMode(), false);
 174 
 175     auto position = cue-&gt;getCSSPosition();
 176 
 177     // the &#39;top&#39; property must be set to top,
 178     setInlineStyleProperty(CSSPropertyTop, position.second, CSSPrimitiveValue::CSS_PERCENTAGE);
 179 
 180     // the &#39;left&#39; property must be set to left
<a name="2" id="anc2"></a><span class="line-modified"> 181     if (cue-&gt;vertical() == horizontalKeyword())</span>
<span class="line-added"> 182         setInlineStyleProperty(CSSPropertyLeft, position.first, CSSPrimitiveValue::CSS_PERCENTAGE);</span>
<span class="line-added"> 183     else if (cue-&gt;vertical() == verticalGrowingRightKeyword())</span>
<span class="line-added"> 184         setInlineStyleProperty(CSSPropertyLeft, makeString(&quot;calc(-&quot;, FormattedNumber::fixedWidth(videoSize.width(), 2), &quot;px - &quot;, FormattedNumber::fixedWidth(cue-&gt;getCSSSize(), 2), &quot;px)&quot;));</span>
 185 
 186     double authorFontSize = std::min(videoSize.width(), videoSize.height()) * DEFAULTCAPTIONFONTSIZEPERCENTAGE / 100.0;
 187     double multiplier = 1.0;
 188     if (authorFontSize)
 189         multiplier = m_fontSizeFromCaptionUserPrefs / authorFontSize;
 190 
 191     double textPosition = cue-&gt;calculateComputedTextPosition();
 192     double maxSize = 100.0;
 193     CSSValueID alignment = cue-&gt;getCSSAlignment();
 194     if (alignment == CSSValueEnd || alignment == CSSValueRight)
 195         maxSize = textPosition;
 196     else if (alignment == CSSValueStart || alignment == CSSValueLeft)
 197         maxSize = 100.0 - textPosition;
 198 
 199     double newCueSize = std::min(cue-&gt;getCSSSize() * multiplier, 100.0);
 200     // the &#39;width&#39; property must be set to width, and the &#39;height&#39; property  must be set to height
 201     if (cue-&gt;vertical() == horizontalKeyword()) {
 202         setInlineStyleProperty(CSSPropertyWidth, newCueSize, CSSPrimitiveValue::CSS_PERCENTAGE);
 203         setInlineStyleProperty(CSSPropertyHeight, CSSValueAuto);
 204         setInlineStyleProperty(CSSPropertyMinWidth, &quot;min-content&quot;);
 205         setInlineStyleProperty(CSSPropertyMaxWidth, maxSize, CSSPrimitiveValue::CSS_PERCENTAGE);
 206         if ((alignment == CSSValueMiddle || alignment == CSSValueCenter) &amp;&amp; multiplier != 1.0)
 207             setInlineStyleProperty(CSSPropertyLeft, static_cast&lt;double&gt;(position.first - (newCueSize - cue-&gt;getCSSSize()) / 2), CSSPrimitiveValue::CSS_PERCENTAGE);
 208     } else {
 209         setInlineStyleProperty(CSSPropertyWidth, CSSValueAuto);
 210         setInlineStyleProperty(CSSPropertyHeight, newCueSize, CSSPrimitiveValue::CSS_PERCENTAGE);
 211         setInlineStyleProperty(CSSPropertyMinHeight, &quot;min-content&quot;);
 212         setInlineStyleProperty(CSSPropertyMaxHeight, maxSize, CSSPrimitiveValue::CSS_PERCENTAGE);
 213         if ((alignment == CSSValueMiddle || alignment == CSSValueCenter) &amp;&amp; multiplier != 1.0)
 214             setInlineStyleProperty(CSSPropertyTop, static_cast&lt;double&gt;(position.second - (newCueSize - cue-&gt;getCSSSize()) / 2), CSSPrimitiveValue::CSS_PERCENTAGE);
 215     }
 216 
 217     // The &#39;text-align&#39; property on the (root) List of WebVTT Node Objects must
 218     // be set to the value in the second cell of the row of the table below
 219     // whose first cell is the value of the corresponding cue&#39;s text track cue
 220     // alignment:
 221     setInlineStyleProperty(CSSPropertyTextAlign, cue-&gt;getCSSAlignment());
 222 
 223     if (!cue-&gt;snapToLines()) {
 224         // 10.13.1 Set up x and y:
 225         // Note: x and y are set through the CSS left and top above.
 226 
 227         // 10.13.2 Position the boxes in boxes such that the point x% along the
 228         // width of the bounding box of the boxes in boxes is x% of the way
 229         // across the width of the video&#39;s rendering area, and the point y%
 230         // along the height of the bounding box of the boxes in boxes is y%
 231         // of the way across the height of the video&#39;s rendering area, while
 232         // maintaining the relative positions of the boxes in boxes to each
 233         // other.
 234         setInlineStyleProperty(CSSPropertyTransform,
 235             makeString(&quot;translate(&quot;, FormattedNumber::fixedWidth(-position.first, 2), &quot;%, &quot;, FormattedNumber::fixedWidth(-position.second, 2), &quot;%)&quot;));
 236 
 237         setInlineStyleProperty(CSSPropertyWhiteSpace, CSSValuePre);
 238     }
 239 
 240     // Make sure shadow or stroke is not clipped.
 241     setInlineStyleProperty(CSSPropertyOverflow, CSSValueVisible);
 242     cue-&gt;element().setInlineStyleProperty(CSSPropertyOverflow, CSSValueVisible);
 243 }
 244 
<a name="3" id="anc3"></a><span class="line-modified"> 245 const AtomString&amp; VTTCueBox::vttCueBoxShadowPseudoId()</span>
 246 {
<a name="4" id="anc4"></a><span class="line-modified"> 247     static NeverDestroyed&lt;const AtomString&gt; trackDisplayBoxShadowPseudoId(&quot;-webkit-media-text-track-display&quot;, AtomString::ConstructFromLiteral);</span>
 248     return trackDisplayBoxShadowPseudoId;
 249 }
 250 
 251 RenderPtr&lt;RenderElement&gt; VTTCueBox::createElementRenderer(RenderStyle&amp;&amp; style, const RenderTreePosition&amp;)
 252 {
 253     return createRenderer&lt;RenderVTTCue&gt;(*this, WTFMove(style));
 254 }
 255 
 256 // ----------------------------
 257 
<a name="5" id="anc5"></a><span class="line-modified"> 258 const AtomString&amp; VTTCue::cueBackdropShadowPseudoId()</span>
 259 {
<a name="6" id="anc6"></a><span class="line-modified"> 260     static NeverDestroyed&lt;const AtomString&gt; cueBackdropShadowPseudoId(&quot;-webkit-media-text-track-display-backdrop&quot;, AtomString::ConstructFromLiteral);</span>
 261     return cueBackdropShadowPseudoId;
 262 }
 263 
 264 Ref&lt;VTTCue&gt; VTTCue::create(ScriptExecutionContext&amp; context, const WebVTTCueData&amp; data)
 265 {
 266     return adoptRef(*new VTTCue(context, data));
 267 }
 268 
 269 VTTCue::VTTCue(ScriptExecutionContext&amp; context, const MediaTime&amp; start, const MediaTime&amp; end, const String&amp; content)
 270     : TextTrackCue(context, start, end)
 271     , m_content(content)
 272 {
 273     initialize(context);
 274 }
 275 
 276 VTTCue::VTTCue(ScriptExecutionContext&amp; context, const WebVTTCueData&amp; cueData)
 277     : TextTrackCue(context, MediaTime::zeroTime(), MediaTime::zeroTime())
 278 {
 279     initialize(context);
 280     setText(cueData.content());
 281     setStartTime(cueData.startTime());
 282     setEndTime(cueData.endTime());
 283     setId(cueData.id());
 284     setCueSettings(cueData.settings());
 285     m_originalStartTime = cueData.originalStartTime();
 286 }
 287 
 288 VTTCue::~VTTCue()
 289 {
 290 }
 291 
 292 void VTTCue::initialize(ScriptExecutionContext&amp; context)
 293 {
 294     m_linePosition = undefinedPosition;
 295     m_computedLinePosition = undefinedPosition;
 296     m_textPosition = std::numeric_limits&lt;double&gt;::quiet_NaN();
 297     m_cueSize = 100;
 298     m_writingDirection = Horizontal;
 299     m_cueAlignment = Center;
 300     m_webVTTNodeTree = nullptr;
 301     m_cueBackdropBox = HTMLDivElement::create(downcast&lt;Document&gt;(context));
 302     m_cueHighlightBox = HTMLSpanElement::create(spanTag, downcast&lt;Document&gt;(context));
 303     m_displayDirection = CSSValueLtr;
 304     m_displaySize = 0;
 305     m_snapToLines = true;
 306     m_displayTreeShouldChange = true;
 307     m_notifyRegion = true;
 308     m_originalStartTime = MediaTime::zeroTime();
 309 }
 310 
 311 Ref&lt;VTTCueBox&gt; VTTCue::createDisplayTree()
 312 {
 313     return VTTCueBox::create(ownerDocument(), *this);
 314 }
 315 
 316 VTTCueBox&amp; VTTCue::displayTreeInternal()
 317 {
 318     if (!m_displayTree)
 319         m_displayTree = createDisplayTree();
 320     return *m_displayTree;
 321 }
 322 
 323 void VTTCue::didChange()
 324 {
 325     TextTrackCue::didChange();
 326     m_displayTreeShouldChange = true;
 327 }
 328 
 329 const String&amp; VTTCue::vertical() const
 330 {
 331     switch (m_writingDirection) {
 332     case Horizontal:
 333         return horizontalKeyword();
 334     case VerticalGrowingLeft:
 335         return verticalGrowingLeftKeyword();
 336     case VerticalGrowingRight:
 337         return verticalGrowingRightKeyword();
 338     default:
 339         ASSERT_NOT_REACHED();
 340         return emptyString();
 341     }
 342 }
 343 
 344 ExceptionOr&lt;void&gt; VTTCue::setVertical(const String&amp; value)
 345 {
 346     // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html#dom-texttrackcue-vertical
 347     // On setting, the text track cue writing direction must be set to the value given
 348     // in the first cell of the row in the table above whose second cell is a
 349     // case-sensitive match for the new value, if any. If none of the values match, then
 350     // the user agent must instead throw a SyntaxError exception.
 351 
 352     WritingDirection direction = m_writingDirection;
 353     if (value == horizontalKeyword())
 354         direction = Horizontal;
 355     else if (value == verticalGrowingLeftKeyword())
 356         direction = VerticalGrowingLeft;
 357     else if (value == verticalGrowingRightKeyword())
 358         direction = VerticalGrowingRight;
 359     else
 360         return Exception { SyntaxError };
 361 
 362     if (direction == m_writingDirection)
 363         return { };
 364 
 365     willChange();
 366     m_writingDirection = direction;
 367     didChange();
 368 
 369     return { };
 370 }
 371 
 372 void VTTCue::setSnapToLines(bool value)
 373 {
 374     if (m_snapToLines == value)
 375         return;
 376 
 377     willChange();
 378     m_snapToLines = value;
 379     didChange();
 380 }
 381 
 382 ExceptionOr&lt;void&gt; VTTCue::setLine(double position)
 383 {
 384     // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html#dom-texttrackcue-line
 385     // On setting, if the text track cue snap-to-lines flag is not set, and the new
 386     // value is negative or greater than 100, then throw an IndexSizeError exception.
 387     if (!m_snapToLines &amp;&amp; !(position &gt;= 0 &amp;&amp; position &lt;= 100))
 388         return Exception { IndexSizeError };
 389 
 390     // Otherwise, set the text track cue line position to the new value.
 391     if (m_linePosition == position)
 392         return { };
 393 
 394     willChange();
 395     m_linePosition = position;
 396     m_computedLinePosition = calculateComputedLinePosition();
 397     didChange();
 398 
 399     return { };
 400 }
 401 
 402 VTTCue::LineAndPositionSetting VTTCue::position() const
 403 {
 404     if (textPositionIsAuto())
 405         return Auto;
 406     return m_textPosition;
 407 }
 408 
 409 ExceptionOr&lt;void&gt; VTTCue::setPosition(const LineAndPositionSetting&amp; position)
 410 {
 411     // http://dev.w3.org/html5/webvtt/#dfn-vttcue-position
 412     // On setting, if the new value is negative or greater than 100, then an
 413     // IndexSizeError exception must be thrown. Otherwise, the WebVTT cue
 414     // position must be set to the new value; if the new value is the string
 415     // &quot;auto&quot;, then it must be interpreted as the special value auto.
 416     double textPosition = 0;
 417     if (WTF::holds_alternative&lt;AutoKeyword&gt;(position)) {
 418         if (textPositionIsAuto())
 419             return { };
 420         textPosition = std::numeric_limits&lt;double&gt;::quiet_NaN();
 421     } else {
 422         if (!(WTF::get&lt;double&gt;(position) &gt;= 0 &amp;&amp; WTF::get&lt;double&gt;(position) &lt;= 100))
 423             return Exception { IndexSizeError };
 424 
 425         // Otherwise, set the text track cue line position to the new value.
 426         textPosition = WTF::get&lt;double&gt;(position);
 427         if (m_textPosition == textPosition)
 428             return { };
 429     }
 430 
 431     willChange();
 432     m_textPosition = textPosition;
 433     didChange();
 434 
 435     return { };
 436 }
 437 
 438 ExceptionOr&lt;void&gt; VTTCue::setSize(int size)
 439 {
 440     // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html#dom-texttrackcue-size
 441     // On setting, if the new value is negative or greater than 100, then throw an IndexSizeError
 442     // exception. Otherwise, set the text track cue size to the new value.
 443     if (!(size &gt;= 0 &amp;&amp; size &lt;= 100))
 444         return Exception { IndexSizeError };
 445 
 446     // Otherwise, set the text track cue line position to the new value.
 447     if (m_cueSize == size)
 448         return { };
 449 
 450     willChange();
 451     m_cueSize = size;
 452     didChange();
 453 
 454     return { };
 455 }
 456 
 457 const String&amp; VTTCue::align() const
 458 {
 459     switch (m_cueAlignment) {
 460     case Start:
 461         return startKeyword();
 462     case Center:
 463         return centerKeyword();
 464     case End:
 465         return endKeyword();
 466     case Left:
 467         return leftKeyword();
 468     case Right:
 469         return rightKeyword();
 470     default:
 471         ASSERT_NOT_REACHED();
 472         return emptyString();
 473     }
 474 }
 475 
 476 ExceptionOr&lt;void&gt; VTTCue::setAlign(const String&amp; value)
 477 {
 478     // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html#dom-texttrackcue-align
 479     // On setting, the text track cue alignment must be set to the value given in the
 480     // first cell of the row in the table above whose second cell is a case-sensitive
 481     // match for the new value, if any. If none of the values match, then the user
 482     // agent must instead throw a SyntaxError exception.
 483 
 484     CueAlignment alignment;
 485     if (value == startKeyword())
 486         alignment = Start;
 487     else if (value == centerKeyword())
 488         alignment = Center;
 489     else if (value == endKeyword())
 490         alignment = End;
 491     else if (value == leftKeyword())
 492         alignment = Left;
 493     else if (value == rightKeyword())
 494         alignment = Right;
 495     else
 496         return Exception { SyntaxError };
 497 
 498     if (alignment == m_cueAlignment)
 499         return { };
 500 
 501     willChange();
 502     m_cueAlignment = alignment;
 503     didChange();
 504 
 505     return { };
 506 }
 507 
 508 void VTTCue::setText(const String&amp; text)
 509 {
 510     if (m_content == text)
 511         return;
 512 
 513     willChange();
 514     // Clear the document fragment but don&#39;t bother to create it again just yet as we can do that
 515     // when it is requested.
 516     m_webVTTNodeTree = nullptr;
 517     m_content = text;
 518     didChange();
 519 }
 520 
 521 void VTTCue::createWebVTTNodeTree()
 522 {
 523     if (!m_webVTTNodeTree)
 524         m_webVTTNodeTree = WebVTTParser::createDocumentFragmentFromCueText(ownerDocument(), m_content);
 525 }
 526 
 527 void VTTCue::copyWebVTTNodeToDOMTree(ContainerNode* webVTTNode, ContainerNode* parent)
 528 {
 529     for (RefPtr&lt;Node&gt; node = webVTTNode-&gt;firstChild(); node; node = node-&gt;nextSibling()) {
 530         RefPtr&lt;Node&gt; clonedNode;
 531         if (is&lt;WebVTTElement&gt;(*node))
 532             clonedNode = downcast&lt;WebVTTElement&gt;(*node).createEquivalentHTMLElement(ownerDocument());
 533         else
 534             clonedNode = node-&gt;cloneNode(false);
 535         parent-&gt;appendChild(*clonedNode);
 536         if (is&lt;ContainerNode&gt;(*node))
 537             copyWebVTTNodeToDOMTree(downcast&lt;ContainerNode&gt;(node.get()), downcast&lt;ContainerNode&gt;(clonedNode.get()));
 538     }
 539 }
 540 
 541 RefPtr&lt;DocumentFragment&gt; VTTCue::getCueAsHTML()
 542 {
 543     createWebVTTNodeTree();
 544     if (!m_webVTTNodeTree)
 545         return nullptr;
 546 
 547     auto clonedFragment = DocumentFragment::create(ownerDocument());
 548     copyWebVTTNodeToDOMTree(m_webVTTNodeTree.get(), clonedFragment.ptr());
<a name="7" id="anc7"></a><span class="line-modified"> 549     return clonedFragment;</span>
 550 }
 551 
 552 RefPtr&lt;DocumentFragment&gt; VTTCue::createCueRenderingTree()
 553 {
 554     createWebVTTNodeTree();
 555     if (!m_webVTTNodeTree)
 556         return nullptr;
 557 
 558     auto clonedFragment = DocumentFragment::create(ownerDocument());
 559 
 560     // The cloned fragment is never exposed to author scripts so it&#39;s safe to dispatch events here.
 561     ScriptDisallowedScope::EventAllowedScope allowedScope(clonedFragment);
 562 
 563     m_webVTTNodeTree-&gt;cloneChildNodes(clonedFragment);
<a name="8" id="anc8"></a><span class="line-modified"> 564     return clonedFragment;</span>
 565 }
 566 
 567 void VTTCue::setRegionId(const String&amp; regionId)
 568 {
 569     if (m_regionId == regionId)
 570         return;
 571 
 572     willChange();
 573     m_regionId = regionId;
 574     didChange();
 575 }
 576 
 577 void VTTCue::notifyRegionWhenRemovingDisplayTree(bool notifyRegion)
 578 {
 579     m_notifyRegion = notifyRegion;
 580 }
 581 
 582 void VTTCue::setIsActive(bool active)
 583 {
 584     TextTrackCue::setIsActive(active);
 585 
 586     if (!active) {
 587         if (!hasDisplayTree())
 588             return;
 589 
 590         // Remove the display tree as soon as the cue becomes inactive.
 591         removeDisplayTree();
 592     }
 593 }
 594 
 595 int VTTCue::calculateComputedLinePosition()
 596 {
 597     // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html#text-track-cue-computed-line-position
 598 
 599     // If the text track cue line position is numeric, then that is the text
 600     // track cue computed line position.
 601     if (m_linePosition != undefinedPosition)
 602         return m_linePosition;
 603 
 604     // If the text track cue snap-to-lines flag of the text track cue is not
 605     // set, the text track cue computed line position is the value 100;
 606     if (!m_snapToLines)
 607         return 100;
 608 
 609     // Otherwise, it is the value returned by the following algorithm:
 610 
 611     // If cue is not associated with a text track, return -1 and abort these
 612     // steps.
 613     if (!track())
 614         return -1;
 615 
 616     // Let n be the number of text tracks whose text track mode is showing or
 617     // showing by default and that are in the media element&#39;s list of text
 618     // tracks before track.
 619     int n = track()-&gt;trackIndexRelativeToRenderedTracks();
 620 
 621     // Increment n by one.
 622     n++;
 623 
 624     // Negate n.
 625     n = -n;
 626 
 627     return n;
 628 }
 629 
 630 static bool isCueParagraphSeparator(UChar character)
 631 {
 632     // Within a cue, paragraph boundaries are only denoted by Type B characters,
 633     // such as U+000A LINE FEED (LF), U+0085 NEXT LINE (NEL), and U+2029 PARAGRAPH SEPARATOR.
 634     return u_charType(character) == U_PARAGRAPH_SEPARATOR;
 635 }
 636 
 637 bool VTTCue::textPositionIsAuto() const
 638 {
 639     return std::isnan(m_textPosition);
 640 }
 641 
 642 void VTTCue::determineTextDirection()
 643 {
 644     static NeverDestroyed&lt;const String&gt; rtTag(MAKE_STATIC_STRING_IMPL(&quot;rt&quot;));
 645     createWebVTTNodeTree();
 646     if (!m_webVTTNodeTree)
 647         return;
 648 
 649     // Apply the Unicode Bidirectional Algorithm&#39;s Paragraph Level steps to the
 650     // concatenation of the values of each WebVTT Text Object in nodes, in a
 651     // pre-order, depth-first traversal, excluding WebVTT Ruby Text Objects and
 652     // their descendants.
 653     StringBuilder paragraphBuilder;
 654     for (RefPtr&lt;Node&gt; node = m_webVTTNodeTree-&gt;firstChild(); node; node = NodeTraversal::next(*node, m_webVTTNodeTree.get())) {
 655         // FIXME: The code does not match the comment above. This does not actually exclude Ruby Text Object descendant.
 656         if (!node-&gt;isTextNode() || node-&gt;localName() == rtTag)
 657             continue;
 658 
 659         paragraphBuilder.append(node-&gt;nodeValue());
 660     }
 661 
 662     String paragraph = paragraphBuilder.toString();
 663     if (!paragraph.length())
 664         return;
 665 
 666     for (size_t i = 0; i &lt; paragraph.length(); ++i) {
 667         UChar current = paragraph[i];
 668         if (!current || isCueParagraphSeparator(current))
 669             return;
 670 
 671         if (UChar current = paragraph[i]) {
 672             UCharDirection charDirection = u_charDirection(current);
 673             if (charDirection == U_LEFT_TO_RIGHT) {
 674                 m_displayDirection = CSSValueLtr;
 675                 return;
 676             }
 677             if (charDirection == U_RIGHT_TO_LEFT || charDirection == U_RIGHT_TO_LEFT_ARABIC) {
 678                 m_displayDirection = CSSValueRtl;
 679                 return;
 680             }
 681         }
 682     }
 683 }
 684 
 685 double VTTCue::calculateComputedTextPosition() const
 686 {
 687     // http://dev.w3.org/html5/webvtt/#dfn-cue-computed-position
 688 
 689     // 1. If the position is numeric, then return the value of the position and
 690     // abort these steps. (Otherwise, the position is the special value auto.)
 691     if (!textPositionIsAuto())
 692         return m_textPosition;
 693 
 694     switch (m_cueAlignment) {
 695     case Start:
 696     case Left:
 697         // 2. If the cue text alignment is start or left, return 0 and abort these
 698         // steps.
 699         return 0;
 700     case End:
 701     case Right:
 702         // 3. If the cue text alignment is end or right, return 100 and abort these
 703         // steps.
 704         return 100;
 705     case Center:
 706         // 4. If the cue text alignment is center, return 50 and abort these steps.
 707         return 50;
 708     default:
 709         ASSERT_NOT_REACHED();
 710         return 0;
 711     }
 712 }
 713 
 714 void VTTCue::calculateDisplayParameters()
 715 {
 716     // Steps 10.2, 10.3
 717     determineTextDirection();
 718 
 719     // 10.4 If the text track cue writing direction is horizontal, then let
 720     // block-flow be &#39;tb&#39;. Otherwise, if the text track cue writing direction is
 721     // vertical growing left, then let block-flow be &#39;lr&#39;. Otherwise, the text
 722     // track cue writing direction is vertical growing right; let block-flow be
 723     // &#39;rl&#39;.
 724 
 725     // The above step is done through the writing direction static map.
 726 
 727     // 10.5 Determine the value of maximum size for cue as per the appropriate
 728     // rules from the following list:
 729     double computedTextPosition = calculateComputedTextPosition();
 730     int maximumSize = computedTextPosition;
 731     if ((m_writingDirection == Horizontal &amp;&amp; m_cueAlignment == Start &amp;&amp; m_displayDirection == CSSValueLtr)
 732         || (m_writingDirection == Horizontal &amp;&amp; m_cueAlignment == End &amp;&amp; m_displayDirection == CSSValueRtl)
 733         || (m_writingDirection == Horizontal &amp;&amp; m_cueAlignment == Left)
 734         || (m_writingDirection == VerticalGrowingLeft &amp;&amp; (m_cueAlignment == Start || m_cueAlignment == Left))
 735         || (m_writingDirection == VerticalGrowingRight &amp;&amp; (m_cueAlignment == Start || m_cueAlignment == Left))) {
 736         maximumSize = 100 - computedTextPosition;
 737     } else if ((m_writingDirection == Horizontal &amp;&amp; m_cueAlignment == End &amp;&amp; m_displayDirection == CSSValueLtr)
 738         || (m_writingDirection == Horizontal &amp;&amp; m_cueAlignment == Start &amp;&amp; m_displayDirection == CSSValueRtl)
 739         || (m_writingDirection == Horizontal &amp;&amp; m_cueAlignment == Right)
 740         || (m_writingDirection == VerticalGrowingLeft &amp;&amp; (m_cueAlignment == End || m_cueAlignment == Right))
 741         || (m_writingDirection == VerticalGrowingRight &amp;&amp; (m_cueAlignment == End || m_cueAlignment == Right))) {
 742         maximumSize = computedTextPosition;
 743     } else if (m_cueAlignment == Center) {
 744         maximumSize = computedTextPosition &lt;= 50 ? computedTextPosition : (100 - computedTextPosition);
 745         maximumSize = maximumSize * 2;
 746     } else
 747         ASSERT_NOT_REACHED();
 748 
 749     // 10.6 If the text track cue size is less than maximum size, then let size
 750     // be text track cue size. Otherwise, let size be maximum size.
 751     m_displaySize = std::min(m_cueSize, maximumSize);
 752 
 753     // FIXME: Understand why step 10.7 is missing (just a copy/paste error?)
 754     // Could be done within a spec implementation check - http://crbug.com/301580
 755 
 756     // 10.8 Determine the value of x-position or y-position for cue as per the
 757     // appropriate rules from the following list:
 758     if (m_writingDirection == Horizontal) {
 759         switch (m_cueAlignment) {
 760         case Start:
 761             if (m_displayDirection == CSSValueLtr)
 762                 m_displayPosition.first = computedTextPosition;
 763             else
 764                 m_displayPosition.first = 100 - computedTextPosition - m_displaySize;
 765             break;
 766         case End:
 767             if (m_displayDirection == CSSValueRtl)
 768                 m_displayPosition.first = 100 - computedTextPosition;
 769             else
 770                 m_displayPosition.first = computedTextPosition - m_displaySize;
 771             break;
 772         case Left:
 773             if (m_displayDirection == CSSValueLtr)
 774                 m_displayPosition.first = computedTextPosition;
 775             else
 776                 m_displayPosition.first = 100 - computedTextPosition;
 777             break;
 778         case Right:
 779             if (m_displayDirection == CSSValueLtr)
 780                 m_displayPosition.first = computedTextPosition - m_displaySize;
 781             else
 782                 m_displayPosition.first = 100 - computedTextPosition - m_displaySize;
 783             break;
 784         case Center:
 785             if (m_displayDirection == CSSValueLtr)
 786                 m_displayPosition.first = computedTextPosition - m_displaySize / 2;
 787             else
 788                 m_displayPosition.first = 100 - computedTextPosition - m_displaySize / 2;
 789             break;
 790         case NumberOfAlignments:
 791             ASSERT_NOT_REACHED();
 792         }
 793     }
 794 
 795     // A text track cue has a text track cue computed line position whose value
 796     // is defined in terms of the other aspects of the cue.
 797     m_computedLinePosition = calculateComputedLinePosition();
 798 
 799     // 10.9 Determine the value of whichever of x-position or y-position is not
 800     // yet calculated for cue as per the appropriate rules from the following
 801     // list:
 802     if (m_snapToLines &amp;&amp; m_displayPosition.second == undefinedPosition &amp;&amp; m_writingDirection == Horizontal)
 803         m_displayPosition.second = 0;
 804 
 805     if (!m_snapToLines &amp;&amp; m_displayPosition.second == undefinedPosition &amp;&amp; m_writingDirection == Horizontal)
 806         m_displayPosition.second = m_computedLinePosition;
 807 
 808     if (m_snapToLines &amp;&amp; m_displayPosition.first == undefinedPosition
 809         &amp;&amp; (m_writingDirection == VerticalGrowingLeft || m_writingDirection == VerticalGrowingRight))
 810         m_displayPosition.first = 0;
 811 
 812     if (!m_snapToLines &amp;&amp; (m_writingDirection == VerticalGrowingLeft || m_writingDirection == VerticalGrowingRight))
 813         m_displayPosition.first = m_computedLinePosition;
 814 }
 815 
 816 void VTTCue::markFutureAndPastNodes(ContainerNode* root, const MediaTime&amp; previousTimestamp, const MediaTime&amp; movieTime)
 817 {
 818     static NeverDestroyed&lt;const String&gt; timestampTag(MAKE_STATIC_STRING_IMPL(&quot;timestamp&quot;));
 819 
 820     bool isPastNode = true;
 821     MediaTime currentTimestamp = previousTimestamp;
 822     if (currentTimestamp &gt; movieTime)
 823         isPastNode = false;
 824 
 825     for (RefPtr&lt;Node&gt; child = root-&gt;firstChild(); child; child = NodeTraversal::next(*child, root)) {
 826         if (child-&gt;nodeName() == timestampTag) {
 827             MediaTime currentTimestamp;
 828             bool check = WebVTTParser::collectTimeStamp(child-&gt;nodeValue(), currentTimestamp);
 829             ASSERT_UNUSED(check, check);
 830 
 831             currentTimestamp += m_originalStartTime;
 832             if (currentTimestamp &gt; movieTime)
 833                 isPastNode = false;
 834         }
 835 
 836         if (is&lt;WebVTTElement&gt;(*child)) {
 837             downcast&lt;WebVTTElement&gt;(*child).setIsPastNode(isPastNode);
 838             // Make an elemenet id match a cue id for style matching purposes.
 839             if (!id().isEmpty())
 840                 downcast&lt;WebVTTElement&gt;(*child).setIdAttribute(id());
 841         }
 842     }
 843 }
 844 
 845 void VTTCue::updateDisplayTree(const MediaTime&amp; movieTime)
 846 {
 847     // The display tree may contain WebVTT timestamp objects representing
 848     // timestamps (processing instructions), along with displayable nodes.
 849 
 850     if (!track()-&gt;isRendered())
 851         return;
 852 
 853     // Mutating the VTT contents is safe because it&#39;s never exposed to author scripts.
 854     ScriptDisallowedScope::EventAllowedScope allowedScopeForCueHighlightBox(*m_cueHighlightBox);
 855 
 856     // Clear the contents of the set.
 857     m_cueHighlightBox-&gt;removeChildren();
 858 
 859     // Update the two sets containing past and future WebVTT objects.
 860     RefPtr&lt;DocumentFragment&gt; referenceTree = createCueRenderingTree();
 861     if (!referenceTree)
 862         return;
 863 
 864     ScriptDisallowedScope::EventAllowedScope allowedScopeForReferenceTree(*referenceTree);
 865 
 866     markFutureAndPastNodes(referenceTree.get(), startMediaTime(), movieTime);
 867     m_cueHighlightBox-&gt;appendChild(*referenceTree);
 868 }
 869 
 870 VTTCueBox&amp; VTTCue::getDisplayTree(const IntSize&amp; videoSize, int fontSize)
 871 {
 872     Ref&lt;VTTCueBox&gt; displayTree = displayTreeInternal();
 873     if (!m_displayTreeShouldChange || !track()-&gt;isRendered())
 874         return displayTree.get();
 875 
 876     // 10.1 - 10.10
 877     calculateDisplayParameters();
 878 
 879     // 10.11. Apply the terms of the CSS specifications to nodes within the
 880     // following constraints, thus obtaining a set of CSS boxes positioned
 881     // relative to an initial containing block:
 882     displayTree-&gt;removeChildren();
 883 
 884     // The document tree is the tree of WebVTT Node Objects rooted at nodes.
 885 
 886     // The children of the nodes must be wrapped in an anonymous box whose
 887     // &#39;display&#39; property has the value &#39;inline&#39;. This is the WebVTT cue
 888     // background box.
 889 
 890     // Note: This is contained by default in m_cueHighlightBox.
 891     m_cueHighlightBox-&gt;setPseudo(cueShadowPseudoId());
 892 
 893     m_cueBackdropBox-&gt;setPseudo(cueBackdropShadowPseudoId());
 894     m_cueBackdropBox-&gt;appendChild(*m_cueHighlightBox);
 895     displayTree-&gt;appendChild(*m_cueBackdropBox);
 896 
 897     // FIXME(BUG 79916): Runs of children of WebVTT Ruby Objects that are not
 898     // WebVTT Ruby Text Objects must be wrapped in anonymous boxes whose
 899     // &#39;display&#39; property has the value &#39;ruby-base&#39;.
 900 
 901     displayTree-&gt;setFontSizeFromCaptionUserPrefs(fontSize);
 902     displayTree-&gt;applyCSSProperties(videoSize);
 903 
 904     if (displayTree-&gt;document().page()) {
 905         auto cssString = displayTree-&gt;document().page()-&gt;captionUserPreferencesStyleSheet();
 906         auto style = HTMLStyleElement::create(HTMLNames::styleTag, displayTree-&gt;document(), false);
 907         style-&gt;setTextContent(cssString);
 908         displayTree-&gt;appendChild(style);
 909     }
 910 
 911     const auto&amp; styleSheets = track()-&gt;styleSheets();
 912     if (styleSheets) {
 913         for (const auto&amp; cssString : *styleSheets) {
 914             auto style = HTMLStyleElement::create(HTMLNames::styleTag, displayTree-&gt;document(), false);
 915             style-&gt;setTextContent(cssString);
 916             displayTree-&gt;appendChild(style);
 917         }
 918     }
 919 
 920     m_displayTreeShouldChange = false;
 921 
 922     // 10.15. Let cue&#39;s text track cue display state have the CSS boxes in
 923     // boxes.
 924     return displayTree.get();
 925 }
 926 
 927 void VTTCue::removeDisplayTree()
 928 {
 929     // The region needs to be informed about the cue removal.
 930     if (m_notifyRegion &amp;&amp; track()) {
 931         if (VTTRegionList* regions = track()-&gt;regions()) {
 932             if (RefPtr&lt;VTTRegion&gt; region = regions-&gt;getRegionById(m_regionId)) {
 933                 if (hasDisplayTree())
 934                     region-&gt;willRemoveTextTrackCueBox(m_displayTree.get());
 935             }
 936         }
 937     }
 938 
 939     if (!hasDisplayTree())
 940         return;
 941 
 942     // The display tree is never exposed to author scripts so it&#39;s safe to dispatch events here.
 943     ScriptDisallowedScope::EventAllowedScope allowedScope(displayTreeInternal());
 944     displayTreeInternal().remove();
 945 }
 946 
 947 std::pair&lt;double, double&gt; VTTCue::getPositionCoordinates() const
 948 {
 949     // This method is used for setting x and y when snap to lines is not set.
 950     std::pair&lt;double, double&gt; coordinates;
 951 
 952     auto textPosition = calculateComputedTextPosition();
 953 
 954     if (m_writingDirection == Horizontal &amp;&amp; m_displayDirection == CSSValueLtr) {
 955         coordinates.first = textPosition;
 956         coordinates.second = m_computedLinePosition;
 957 
 958         return coordinates;
 959     }
 960 
 961     if (m_writingDirection == Horizontal &amp;&amp; m_displayDirection == CSSValueRtl) {
 962         coordinates.first = 100 - textPosition;
 963         coordinates.second = m_computedLinePosition;
 964 
 965         return coordinates;
 966     }
 967 
 968     if (m_writingDirection == VerticalGrowingLeft) {
 969         coordinates.first = 100 - m_computedLinePosition;
 970         coordinates.second = textPosition;
 971 
 972         return coordinates;
 973     }
 974 
 975     if (m_writingDirection == VerticalGrowingRight) {
 976         coordinates.first = m_computedLinePosition;
 977         coordinates.second = textPosition;
 978 
 979         return coordinates;
 980     }
 981 
 982     ASSERT_NOT_REACHED();
 983 
 984     return coordinates;
 985 }
 986 
 987 VTTCue::CueSetting VTTCue::settingName(VTTScanner&amp; input)
 988 {
 989     CueSetting parsedSetting = None;
 990     if (input.scan(&quot;vertical&quot;))
 991         parsedSetting = Vertical;
 992     else if (input.scan(&quot;line&quot;))
 993         parsedSetting = Line;
 994     else if (input.scan(&quot;position&quot;))
 995         parsedSetting = Position;
 996     else if (input.scan(&quot;size&quot;))
 997         parsedSetting = Size;
 998     else if (input.scan(&quot;align&quot;))
 999         parsedSetting = Align;
1000     else if (input.scan(&quot;region&quot;))
1001         parsedSetting = RegionId;
1002 
1003     // Verify that a &#39;:&#39; follows.
1004     if (parsedSetting != None &amp;&amp; input.scan(&#39;:&#39;))
1005         return parsedSetting;
1006 
1007     return None;
1008 }
1009 
1010 void VTTCue::setCueSettings(const String&amp; inputString)
1011 {
1012     if (inputString.isEmpty())
1013         return;
1014 
1015     VTTScanner input(inputString);
1016 
1017     while (!input.isAtEnd()) {
1018 
1019         // The WebVTT cue settings part of a WebVTT cue consists of zero or more of the following components, in any order,
1020         // separated from each other by one or more U+0020 SPACE characters or U+0009 CHARACTER TABULATION (tab) characters.
1021         input.skipWhile&lt;WebVTTParser::isValidSettingDelimiter&gt;();
1022         if (input.isAtEnd())
1023             break;
1024 
1025         // When the user agent is to parse the WebVTT settings given by a string input for a text track cue cue,
1026         // the user agent must run the following steps:
1027         // 1. Let settings be the result of splitting input on spaces.
1028         // 2. For each token setting in the list settings, run the following substeps:
1029         //    1. If setting does not contain a U+003A COLON character (:), or if the first U+003A COLON character (:)
1030         //       in setting is either the first or last character of setting, then jump to the step labeled next setting.
1031         //    2. Let name be the leading substring of setting up to and excluding the first U+003A COLON character (:) in that string.
1032         CueSetting name = settingName(input);
1033 
1034         // 3. Let value be the trailing substring of setting starting from the character immediately after the first U+003A COLON character (:) in that string.
1035         VTTScanner::Run valueRun = input.collectUntil&lt;WebVTTParser::isValidSettingDelimiter&gt;();
1036 
1037         // 4. Run the appropriate substeps that apply for the value of name, as follows:
1038         switch (name) {
1039         case Vertical: {
1040             // If name is a case-sensitive match for &quot;vertical&quot;
1041             // 1. If value is a case-sensitive match for the string &quot;rl&quot;, then let cue&#39;s text track cue writing direction
1042             //    be vertical growing left.
1043             if (input.scanRun(valueRun, verticalGrowingLeftKeyword()))
1044                 m_writingDirection = VerticalGrowingLeft;
1045 
1046             // 2. Otherwise, if value is a case-sensitive match for the string &quot;lr&quot;, then let cue&#39;s text track cue writing
1047             //    direction be vertical growing right.
1048             else if (input.scanRun(valueRun, verticalGrowingRightKeyword()))
1049                 m_writingDirection = VerticalGrowingRight;
1050 
1051             else
1052                 LOG(Media, &quot;VTTCue::setCueSettings, invalid Vertical&quot;);
1053             break;
1054         }
1055         case Line: {
1056             bool isValid = false;
1057             do {
1058                 // 1-2 - Collect chars that are either &#39;-&#39;, &#39;%&#39;, or a digit.
1059                 // 1. If value contains any characters other than U+002D HYPHEN-MINUS characters (-), U+0025 PERCENT SIGN
1060                 //    characters (%), and characters in the range U+0030 DIGIT ZERO (0) to U+0039 DIGIT NINE (9), then jump
1061                 //    to the step labeled next setting.
1062                 float linePosition;
1063                 bool isNegative;
1064                 if (!input.scanFloat(linePosition, &amp;isNegative))
1065                     break;
1066 
1067                 bool isPercentage = input.scan(&#39;%&#39;);
1068                 if (!input.isAt(valueRun.end())) {
1069                     if (!input.scan(&#39;,&#39;))
1070                         break;
1071                     // FIXME: implement handling of line setting alignment.
1072                     if (!input.scan(startKeyword().characters8(), startKeyword().length())
1073                         &amp;&amp; !input.scan(centerKeyword().characters8(), centerKeyword().length())
1074                         &amp;&amp; !input.scan(endKeyword().characters8(), endKeyword().length())) {
1075                         LOG(Media, &quot;VTTCue::setCueSettings, invalid line setting alignment&quot;);
1076                         break;
1077                     }
1078                 }
1079 
1080                 // 2. If value does not contain at least one character in the range U+0030 DIGIT ZERO (0) to U+0039 DIGIT
1081                 //    NINE (9), then jump to the step labeled next setting.
1082                 // 3. If any character in value other than the first character is a U+002D HYPHEN-MINUS character (-), then
1083                 //    jump to the step labeled next setting.
1084                 // 4. If any character in value other than the last character is a U+0025 PERCENT SIGN character (%), then
1085                 //    jump to the step labeled next setting.
1086                 // 5. If the first character in value is a U+002D HYPHEN-MINUS character (-) and the last character in value is a
1087                 //    U+0025 PERCENT SIGN character (%), then jump to the step labeled next setting.
1088                 if (isPercentage &amp;&amp; isNegative)
1089                     break;
1090 
1091                 // 6. Ignoring the trailing percent sign, if any, interpret value as a (potentially signed) integer, and
1092                 //    let number be that number.
1093                 // 7. If the last character in value is a U+0025 PERCENT SIGN character (%), but number is not in the range
1094                 //    0 ≤ number ≤ 100, then jump to the step labeled next setting.
1095                 // 8. Let cue&#39;s text track cue line position be number.
1096                 // 9. If the last character in value is a U+0025 PERCENT SIGN character (%), then let cue&#39;s text track cue
1097                 //    snap-to-lines flag be false. Otherwise, let it be true.
1098                 if (isPercentage) {
1099                     if (linePosition &lt; 0 || linePosition &gt; 100)
1100                         break;
1101 
1102                     // 10 - If &#39;%&#39; then set snap-to-lines flag to false.
1103                     m_snapToLines = false;
1104                 } else {
1105                     if (linePosition - static_cast&lt;int&gt;(linePosition))
1106                         break;
1107 
1108                     m_snapToLines = true;
1109                 }
1110 
1111                 m_linePosition = linePosition;
1112                 isValid = true;
1113             } while (0);
1114 
1115             if (!isValid)
1116                 LOG(Media, &quot;VTTCue::setCueSettings, invalid Line&quot;);
1117 
1118             break;
1119         }
1120         case Position: {
1121             float position;
1122             if (WebVTTParser::parseFloatPercentageValue(input, position) &amp;&amp; input.isAt(valueRun.end()))
1123                 m_textPosition = position;
1124             else
1125                 LOG(Media, &quot;VTTCue::setCueSettings, invalid Position&quot;);
1126             break;
1127         }
1128         case Size: {
1129             float cueSize;
1130             if (WebVTTParser::parseFloatPercentageValue(input, cueSize) &amp;&amp; input.isAt(valueRun.end()))
1131                 m_cueSize = cueSize;
1132             else
1133                 LOG(Media, &quot;VTTCue::setCueSettings, invalid Size&quot;);
1134             break;
1135         }
1136         case Align: {
1137             // 1. If value is a case-sensitive match for the string &quot;start&quot;, then let cue&#39;s text track cue alignment be start alignment.
1138             if (input.scanRun(valueRun, startKeyword()))
1139                 m_cueAlignment = Start;
1140 
1141             // 2. If value is a case-sensitive match for the string &quot;center&quot;, then let cue&#39;s text track cue alignment be center alignment.
1142             else if (input.scanRun(valueRun, centerKeyword()))
1143                 m_cueAlignment = Center;
1144 
1145             // 3. If value is a case-sensitive match for the string &quot;end&quot;, then let cue&#39;s text track cue alignment be end alignment.
1146             else if (input.scanRun(valueRun, endKeyword()))
1147                 m_cueAlignment = End;
1148 
1149             // 4. If value is a case-sensitive match for the string &quot;left&quot;, then let cue&#39;s text track cue alignment be left alignment.
1150             else if (input.scanRun(valueRun, leftKeyword()))
1151                 m_cueAlignment = Left;
1152 
1153             // 5. If value is a case-sensitive match for the string &quot;right&quot;, then let cue&#39;s text track cue alignment be right alignment.
1154             else if (input.scanRun(valueRun, rightKeyword()))
1155                 m_cueAlignment = Right;
1156 
1157             else
1158                 LOG(Media, &quot;VTTCue::setCueSettings, invalid Align&quot;);
1159 
1160             break;
1161         }
1162         case RegionId:
1163             m_regionId = input.extractString(valueRun);
1164             break;
1165         case None:
1166             break;
1167         }
1168 
1169         // Make sure the entire run is consumed.
1170         input.skipRun(valueRun);
1171     }
1172 
1173     // If cue&#39;s line position is not auto or cue&#39;s size is not 100 or cue&#39;s
1174     // writing direction is not horizontal, but cue&#39;s region identifier is not
1175     // the empty string, let cue&#39;s region identifier be the empty string.
1176     if (m_regionId.isEmpty())
1177         return;
1178 
1179     if (m_linePosition != undefinedPosition || m_cueSize != 100 || m_writingDirection != Horizontal)
1180         m_regionId = emptyString();
1181 }
1182 
1183 CSSValueID VTTCue::getCSSAlignment() const
1184 {
1185     return displayAlignmentMap[m_cueAlignment];
1186 }
1187 
1188 CSSValueID VTTCue::getCSSWritingDirection() const
1189 {
1190     return m_displayDirection;
1191 }
1192 
1193 CSSValueID VTTCue::getCSSWritingMode() const
1194 {
1195     return displayWritingModeMap[m_writingDirection];
1196 }
1197 
1198 int VTTCue::getCSSSize() const
1199 {
1200     return m_displaySize;
1201 }
1202 
1203 std::pair&lt;double, double&gt; VTTCue::getCSSPosition() const
1204 {
1205     if (!m_snapToLines)
1206         return getPositionCoordinates();
1207 
1208     return m_displayPosition;
1209 }
1210 
1211 bool VTTCue::cueContentsMatch(const TextTrackCue&amp; cue) const
1212 {
1213     RefPtr&lt;const VTTCue&gt; vttCue = toVTTCue(&amp;cue);
1214     if (text() != vttCue-&gt;text())
1215         return false;
1216     if (cueSettings() != vttCue-&gt;cueSettings())
1217         return false;
1218     if (position() != vttCue-&gt;position())
1219         return false;
1220     if (line() != vttCue-&gt;line())
1221         return false;
1222     if (size() != vttCue-&gt;size())
1223         return false;
1224     if (align() != vttCue-&gt;align())
1225         return false;
1226 
1227     return true;
1228 }
1229 
1230 bool VTTCue::isEqual(const TextTrackCue&amp; cue, TextTrackCue::CueMatchRules match) const
1231 {
1232     if (!TextTrackCue::isEqual(cue, match))
1233         return false;
1234 
1235     if (cue.cueType() != WebVTT)
1236         return false;
1237 
1238     return cueContentsMatch(cue);
1239 }
1240 
1241 bool VTTCue::doesExtendCue(const TextTrackCue&amp; cue) const
1242 {
1243     if (!cueContentsMatch(cue))
1244         return false;
1245 
1246     return TextTrackCue::doesExtendCue(cue);
1247 }
1248 
1249 void VTTCue::setFontSize(int fontSize, const IntSize&amp;, bool important)
1250 {
1251     if (!hasDisplayTree() || !fontSize)
1252         return;
1253 
1254     m_displayTreeShouldChange = true;
1255     displayTreeInternal().setInlineStyleProperty(CSSPropertyFontSize, fontSize, CSSPrimitiveValue::CSS_PX, important);
1256 }
1257 
1258 VTTCue* toVTTCue(TextTrackCue* cue)
1259 {
1260     return const_cast&lt;VTTCue*&gt;(toVTTCue(const_cast&lt;const TextTrackCue*&gt;(cue)));
1261 }
1262 
1263 const VTTCue* toVTTCue(const TextTrackCue* cue)
1264 {
1265     ASSERT_WITH_SECURITY_IMPLICATION(cue-&gt;isRenderable());
1266     return static_cast&lt;const VTTCue*&gt;(cue);
1267 }
1268 
1269 String VTTCue::toJSONString() const
1270 {
1271     auto object = JSON::Object::create();
1272     toJSON(object.get());
1273 
1274     return object-&gt;toJSONString();
1275 }
1276 
1277 void VTTCue::toJSON(JSON::Object&amp; object) const
1278 {
1279     TextTrackCue::toJSON(object);
1280 
1281 #if !LOG_DISABLED
1282     object.setString(&quot;text&quot;_s, text());
1283 #endif
1284     object.setString(&quot;vertical&quot;_s, vertical());
1285     object.setBoolean(&quot;snapToLines&quot;_s, snapToLines());
1286     object.setDouble(&quot;line&quot;_s, m_linePosition);
1287     if (textPositionIsAuto())
1288         object.setString(&quot;position&quot;_s, &quot;auto&quot;);
1289     else
1290         object.setDouble(&quot;position&quot;_s, m_textPosition);
1291     object.setInteger(&quot;size&quot;_s, m_cueSize);
1292     object.setString(&quot;align&quot;_s, align());
1293     object.setString(&quot;regionId&quot;_s, regionId());
1294 }
1295 
1296 } // namespace WebCore
1297 
1298 #endif
<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>