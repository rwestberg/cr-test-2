<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WebCore/html/shadow/MediaControlElements.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2008, 2009, 2010, 2011 Apple Inc. All rights reserved.
   3  * Copyright (C) 2012 Google Inc. All rights reserved.
   4  *
   5  * Redistribution and use in source and binary forms, with or without
   6  * modification, are permitted provided that the following conditions
   7  * are met:
   8  *
   9  * 1.  Redistributions of source code must retain the above copyright
  10  *     notice, this list of conditions and the following disclaimer.
  11  * 2.  Redistributions in binary form must reproduce the above copyright
  12  *     notice, this list of conditions and the following disclaimer in the
  13  *     documentation and/or other materials provided with the distribution.
  14  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
  15  *     its contributors may be used to endorse or promote products derived
  16  *     from this software without specific prior written permission.
  17  *
  18  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
  19  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  20  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  21  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  22  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  23  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  24  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  25  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  26  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  27  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  28  */
  29 
  30 #include &quot;config.h&quot;
  31 #include &quot;MediaControlElements.h&quot;
  32 
  33 #if ENABLE(VIDEO)
  34 
  35 #include &quot;DOMTokenList.h&quot;
  36 #include &quot;ElementChildIterator.h&quot;
  37 #include &quot;EventHandler.h&quot;
  38 #include &quot;EventNames.h&quot;
  39 #include &quot;Frame.h&quot;
  40 #include &quot;GraphicsContext.h&quot;
  41 #include &quot;HTMLHeadingElement.h&quot;
  42 #include &quot;HTMLLIElement.h&quot;
  43 #include &quot;HTMLUListElement.h&quot;
  44 #include &quot;HTMLVideoElement.h&quot;
  45 #include &quot;ImageBuffer.h&quot;
  46 #include &quot;LocalizedStrings.h&quot;
  47 #include &quot;Logging.h&quot;
  48 #include &quot;MediaControls.h&quot;
  49 #include &quot;MouseEvent.h&quot;
  50 #include &quot;Page.h&quot;
  51 #include &quot;PageGroup.h&quot;
  52 #include &quot;RenderLayer.h&quot;
  53 #include &quot;RenderMediaControlElements.h&quot;
  54 #include &quot;RenderSlider.h&quot;
  55 #include &quot;RenderTheme.h&quot;
  56 #include &quot;RenderVideo.h&quot;
  57 #include &quot;RenderView.h&quot;
  58 #include &quot;Settings.h&quot;
  59 #include &quot;ShadowRoot.h&quot;
  60 #include &quot;TextTrackList.h&quot;
  61 #include &quot;VTTRegionList.h&quot;
  62 #include &lt;wtf/IsoMallocInlines.h&gt;
  63 #include &lt;wtf/Language.h&gt;
  64 
  65 namespace WebCore {
  66 
  67 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlPanelElement);
  68 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlPanelEnclosureElement);
  69 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlOverlayEnclosureElement);
  70 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlTimelineContainerElement);
  71 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlVolumeSliderContainerElement);
  72 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlStatusDisplayElement);
  73 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlPanelMuteButtonElement);
  74 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlVolumeSliderMuteButtonElement);
  75 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlPlayButtonElement);
  76 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlOverlayPlayButtonElement);
  77 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlSeekForwardButtonElement);
  78 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlSeekBackButtonElement);
  79 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlRewindButtonElement);
  80 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlReturnToRealtimeButtonElement);
  81 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlToggleClosedCaptionsButtonElement);
  82 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlClosedCaptionsContainerElement);
  83 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlClosedCaptionsTrackListElement);
  84 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlTimelineElement);
  85 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlFullscreenButtonElement);
  86 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlPanelVolumeSliderElement);
  87 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlFullscreenVolumeSliderElement);
  88 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlFullscreenVolumeMinButtonElement);
  89 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlFullscreenVolumeMaxButtonElement);
  90 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlTimeRemainingDisplayElement);
  91 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlCurrentTimeDisplayElement);
  92 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlTextTrackContainerElement);
  93 
  94 using namespace HTMLNames;
  95 
  96 static const AtomicString&amp; getMediaControlCurrentTimeDisplayElementShadowPseudoId();
  97 static const AtomicString&amp; getMediaControlTimeRemainingDisplayElementShadowPseudoId();
  98 
  99 MediaControlPanelElement::MediaControlPanelElement(Document&amp; document)
 100     : MediaControlDivElement(document, MediaControlsPanel)
 101     , m_canBeDragged(false)
 102     , m_isBeingDragged(false)
 103     , m_isDisplayed(false)
 104     , m_opaque(true)
 105     , m_transitionTimer(*this, &amp;MediaControlPanelElement::transitionTimerFired)
 106 {
 107     setPseudo(AtomicString(&quot;-webkit-media-controls-panel&quot;, AtomicString::ConstructFromLiteral));
 108 }
 109 
 110 Ref&lt;MediaControlPanelElement&gt; MediaControlPanelElement::create(Document&amp; document)
 111 {
 112     return adoptRef(*new MediaControlPanelElement(document));
 113 }
 114 
 115 void MediaControlPanelElement::startDrag(const LayoutPoint&amp; eventLocation)
 116 {
 117     if (!m_canBeDragged)
 118         return;
 119 
 120     if (m_isBeingDragged)
 121         return;
 122 
 123     auto renderer = this-&gt;renderer();
 124     if (!renderer || !renderer-&gt;isBox())
 125         return;
 126 
 127     RefPtr&lt;Frame&gt; frame = document().frame();
 128     if (!frame)
 129         return;
 130 
 131     m_lastDragEventLocation = eventLocation;
 132 
 133     frame-&gt;eventHandler().setCapturingMouseEventsElement(this);
 134 
 135     m_isBeingDragged = true;
 136 }
 137 
 138 void MediaControlPanelElement::continueDrag(const LayoutPoint&amp; eventLocation)
 139 {
 140     if (!m_isBeingDragged)
 141         return;
 142 
 143     LayoutSize distanceDragged = eventLocation - m_lastDragEventLocation;
 144     m_cumulativeDragOffset.move(distanceDragged);
 145     m_lastDragEventLocation = eventLocation;
 146     setPosition(m_cumulativeDragOffset);
 147 }
 148 
 149 void MediaControlPanelElement::endDrag()
 150 {
 151     if (!m_isBeingDragged)
 152         return;
 153 
 154     m_isBeingDragged = false;
 155 
 156     RefPtr&lt;Frame&gt; frame = document().frame();
 157     if (!frame)
 158         return;
 159 
 160     frame-&gt;eventHandler().setCapturingMouseEventsElement(nullptr);
 161 }
 162 
 163 void MediaControlPanelElement::startTimer()
 164 {
 165     stopTimer();
 166 
 167     // The timer is required to set the property display:&#39;none&#39; on the panel,
 168     // such that captions are correctly displayed at the bottom of the video
 169     // at the end of the fadeout transition.
 170     Seconds duration = RenderTheme::singleton().mediaControlsFadeOutDuration();
 171     m_transitionTimer.startOneShot(duration);
 172 }
 173 
 174 void MediaControlPanelElement::stopTimer()
 175 {
 176     if (m_transitionTimer.isActive())
 177         m_transitionTimer.stop();
 178 }
 179 
 180 void MediaControlPanelElement::transitionTimerFired()
 181 {
 182     if (!m_opaque)
 183         hide();
 184 
 185     stopTimer();
 186 }
 187 
 188 void MediaControlPanelElement::setPosition(const LayoutPoint&amp; position)
 189 {
 190     double left = position.x();
 191     double top = position.y();
 192 
 193     // Set the left and top to control the panel&#39;s position; this depends on it being absolute positioned.
 194     // Set the margin to zero since the position passed in will already include the effect of the margin.
 195     setInlineStyleProperty(CSSPropertyLeft, left, CSSPrimitiveValue::CSS_PX);
 196     setInlineStyleProperty(CSSPropertyTop, top, CSSPrimitiveValue::CSS_PX);
 197     setInlineStyleProperty(CSSPropertyMarginLeft, 0.0, CSSPrimitiveValue::CSS_PX);
 198     setInlineStyleProperty(CSSPropertyMarginTop, 0.0, CSSPrimitiveValue::CSS_PX);
 199 
 200     classList().add(&quot;dragged&quot;);
 201 }
 202 
 203 void MediaControlPanelElement::resetPosition()
 204 {
 205     removeInlineStyleProperty(CSSPropertyLeft);
 206     removeInlineStyleProperty(CSSPropertyTop);
 207     removeInlineStyleProperty(CSSPropertyMarginLeft);
 208     removeInlineStyleProperty(CSSPropertyMarginTop);
 209 
 210     classList().remove(&quot;dragged&quot;);
 211 
 212     m_cumulativeDragOffset.setX(0);
 213     m_cumulativeDragOffset.setY(0);
 214 }
 215 
 216 void MediaControlPanelElement::makeOpaque()
 217 {
 218     if (m_opaque)
 219         return;
 220 
 221     double duration = RenderTheme::singleton().mediaControlsFadeInDuration();
 222 
 223     setInlineStyleProperty(CSSPropertyTransitionProperty, CSSPropertyOpacity);
 224     setInlineStyleProperty(CSSPropertyTransitionDuration, duration, CSSPrimitiveValue::CSS_S);
 225     setInlineStyleProperty(CSSPropertyOpacity, 1.0, CSSPrimitiveValue::CSS_NUMBER);
 226 
 227     m_opaque = true;
 228 
 229     if (m_isDisplayed)
 230         show();
 231 }
 232 
 233 void MediaControlPanelElement::makeTransparent()
 234 {
 235     if (!m_opaque)
 236         return;
 237 
 238     Seconds duration = RenderTheme::singleton().mediaControlsFadeOutDuration();
 239 
 240     setInlineStyleProperty(CSSPropertyTransitionProperty, CSSPropertyOpacity);
 241     setInlineStyleProperty(CSSPropertyTransitionDuration, duration.value(), CSSPrimitiveValue::CSS_S);
 242     setInlineStyleProperty(CSSPropertyOpacity, 0.0, CSSPrimitiveValue::CSS_NUMBER);
 243 
 244     m_opaque = false;
 245     startTimer();
 246 }
 247 
 248 void MediaControlPanelElement::defaultEventHandler(Event&amp; event)
 249 {
 250     MediaControlDivElement::defaultEventHandler(event);
 251 
 252     if (is&lt;MouseEvent&gt;(event)) {
 253         LayoutPoint location = downcast&lt;MouseEvent&gt;(event).absoluteLocation();
 254         if (event.type() == eventNames().mousedownEvent &amp;&amp; event.target() == this) {
 255             startDrag(location);
 256             event.setDefaultHandled();
 257         } else if (event.type() == eventNames().mousemoveEvent &amp;&amp; m_isBeingDragged)
 258             continueDrag(location);
 259         else if (event.type() == eventNames().mouseupEvent &amp;&amp; m_isBeingDragged) {
 260             continueDrag(location);
 261             endDrag();
 262             event.setDefaultHandled();
 263         }
 264     }
 265 }
 266 
 267 void MediaControlPanelElement::setCanBeDragged(bool canBeDragged)
 268 {
 269     if (m_canBeDragged == canBeDragged)
 270         return;
 271 
 272     m_canBeDragged = canBeDragged;
 273 
 274     if (!canBeDragged)
 275         endDrag();
 276 }
 277 
 278 void MediaControlPanelElement::setIsDisplayed(bool isDisplayed)
 279 {
 280     m_isDisplayed = isDisplayed;
 281 }
 282 
 283 // ----------------------------
 284 
 285 MediaControlPanelEnclosureElement::MediaControlPanelEnclosureElement(Document&amp; document)
 286     // Mapping onto same MediaControlElementType as panel element, since it has similar properties.
 287     : MediaControlDivElement(document, MediaControlsPanel)
 288 {
 289     setPseudo(AtomicString(&quot;-webkit-media-controls-enclosure&quot;, AtomicString::ConstructFromLiteral));
 290 }
 291 
 292 Ref&lt;MediaControlPanelEnclosureElement&gt; MediaControlPanelEnclosureElement::create(Document&amp; document)
 293 {
 294     return adoptRef(*new MediaControlPanelEnclosureElement(document));
 295 }
 296 
 297 // ----------------------------
 298 
 299 MediaControlOverlayEnclosureElement::MediaControlOverlayEnclosureElement(Document&amp; document)
 300     // Mapping onto same MediaControlElementType as panel element, since it has similar properties.
 301     : MediaControlDivElement(document, MediaControlsPanel)
 302 {
 303     setPseudo(AtomicString(&quot;-webkit-media-controls-overlay-enclosure&quot;, AtomicString::ConstructFromLiteral));
 304 }
 305 
 306 Ref&lt;MediaControlOverlayEnclosureElement&gt; MediaControlOverlayEnclosureElement::create(Document&amp; document)
 307 {
 308     return adoptRef(*new MediaControlOverlayEnclosureElement(document));
 309 }
 310 
 311 // ----------------------------
 312 
 313 MediaControlTimelineContainerElement::MediaControlTimelineContainerElement(Document&amp; document)
 314     : MediaControlDivElement(document, MediaTimelineContainer)
 315 {
 316     setPseudo(AtomicString(&quot;-webkit-media-controls-timeline-container&quot;, AtomicString::ConstructFromLiteral));
 317 }
 318 
 319 Ref&lt;MediaControlTimelineContainerElement&gt; MediaControlTimelineContainerElement::create(Document&amp; document)
 320 {
 321     Ref&lt;MediaControlTimelineContainerElement&gt; element = adoptRef(*new MediaControlTimelineContainerElement(document));
 322     element-&gt;hide();
 323     return element;
 324 }
 325 
 326 void MediaControlTimelineContainerElement::setTimeDisplaysHidden(bool hidden)
 327 {
 328     for (auto&amp; element : childrenOfType&lt;Element&gt;(*this)) {
 329         if (element.shadowPseudoId() != getMediaControlTimeRemainingDisplayElementShadowPseudoId()
 330             &amp;&amp; element.shadowPseudoId() != getMediaControlCurrentTimeDisplayElementShadowPseudoId())
 331             continue;
 332 
 333         MediaControlTimeDisplayElement&amp; timeDisplay = static_cast&lt;MediaControlTimeDisplayElement&amp;&gt;(element);
 334         if (hidden)
 335             timeDisplay.hide();
 336         else
 337             timeDisplay.show();
 338     }
 339 }
 340 
 341 RenderPtr&lt;RenderElement&gt; MediaControlTimelineContainerElement::createElementRenderer(RenderStyle&amp;&amp; style, const RenderTreePosition&amp;)
 342 {
 343     return createRenderer&lt;RenderMediaControlTimelineContainer&gt;(*this, WTFMove(style));
 344 }
 345 
 346 // ----------------------------
 347 
 348 MediaControlVolumeSliderContainerElement::MediaControlVolumeSliderContainerElement(Document&amp; document)
 349     : MediaControlDivElement(document, MediaVolumeSliderContainer)
 350 {
 351     setPseudo(AtomicString(&quot;-webkit-media-controls-volume-slider-container&quot;, AtomicString::ConstructFromLiteral));
 352 }
 353 
 354 Ref&lt;MediaControlVolumeSliderContainerElement&gt; MediaControlVolumeSliderContainerElement::create(Document&amp; document)
 355 {
 356     Ref&lt;MediaControlVolumeSliderContainerElement&gt; element = adoptRef(*new MediaControlVolumeSliderContainerElement(document));
 357     element-&gt;hide();
 358     return element;
 359 }
 360 
 361 RenderPtr&lt;RenderElement&gt; MediaControlVolumeSliderContainerElement::createElementRenderer(RenderStyle&amp;&amp; style, const RenderTreePosition&amp;)
 362 {
 363     return createRenderer&lt;RenderMediaVolumeSliderContainer&gt;(*this, WTFMove(style));
 364 }
 365 
 366 void MediaControlVolumeSliderContainerElement::defaultEventHandler(Event&amp; event)
 367 {
 368     // Poor man&#39;s mouseleave event detection.
 369 
 370     if (!is&lt;MouseEvent&gt;(event) || event.type() != eventNames().mouseoutEvent)
 371         return;
 372 
 373     if (!is&lt;Node&gt;(downcast&lt;MouseEvent&gt;(event).relatedTarget()))
 374         return;
 375 
 376     if (containsIncludingShadowDOM(&amp;downcast&lt;Node&gt;(*downcast&lt;MouseEvent&gt;(event).relatedTarget())))
 377         return;
 378 
 379     hide();
 380 }
 381 
 382 // ----------------------------
 383 
 384 MediaControlStatusDisplayElement::MediaControlStatusDisplayElement(Document&amp; document)
 385     : MediaControlDivElement(document, MediaStatusDisplay)
 386     , m_stateBeingDisplayed(Nothing)
 387 {
 388     setPseudo(AtomicString(&quot;-webkit-media-controls-status-display&quot;, AtomicString::ConstructFromLiteral));
 389 }
 390 
 391 Ref&lt;MediaControlStatusDisplayElement&gt; MediaControlStatusDisplayElement::create(Document&amp; document)
 392 {
 393     Ref&lt;MediaControlStatusDisplayElement&gt; element = adoptRef(*new MediaControlStatusDisplayElement(document));
 394     element-&gt;hide();
 395     return element;
 396 }
 397 
 398 void MediaControlStatusDisplayElement::update()
 399 {
 400     // Get the new state that we&#39;ll have to display.
 401     StateBeingDisplayed newStateToDisplay = Nothing;
 402 
 403     if (mediaController()-&gt;readyState() &lt;= MediaControllerInterface::HAVE_METADATA &amp;&amp; mediaController()-&gt;hasCurrentSrc())
 404         newStateToDisplay = Loading;
 405     else if (mediaController()-&gt;isLiveStream())
 406         newStateToDisplay = LiveBroadcast;
 407 
 408     if (newStateToDisplay == m_stateBeingDisplayed)
 409         return;
 410 
 411     if (m_stateBeingDisplayed == Nothing)
 412         show();
 413     else if (newStateToDisplay == Nothing)
 414         hide();
 415 
 416     m_stateBeingDisplayed = newStateToDisplay;
 417 
 418     switch (m_stateBeingDisplayed) {
 419     case Nothing:
 420         setInnerText(emptyString());
 421         break;
 422     case Loading:
 423         setInnerText(mediaElementLoadingStateText());
 424         break;
 425     case LiveBroadcast:
 426         setInnerText(mediaElementLiveBroadcastStateText());
 427         break;
 428     }
 429 }
 430 
 431 // ----------------------------
 432 
 433 MediaControlPanelMuteButtonElement::MediaControlPanelMuteButtonElement(Document&amp; document, MediaControls* controls)
 434     : MediaControlMuteButtonElement(document, MediaMuteButton)
 435     , m_controls(controls)
 436 {
 437     setPseudo(AtomicString(&quot;-webkit-media-controls-mute-button&quot;, AtomicString::ConstructFromLiteral));
 438 }
 439 
 440 Ref&lt;MediaControlPanelMuteButtonElement&gt; MediaControlPanelMuteButtonElement::create(Document&amp; document, MediaControls* controls)
 441 {
 442     ASSERT(controls);
 443 
 444     Ref&lt;MediaControlPanelMuteButtonElement&gt; button = adoptRef(*new MediaControlPanelMuteButtonElement(document, controls));
 445     button-&gt;ensureUserAgentShadowRoot();
 446     button-&gt;setType(&quot;button&quot;);
 447     return button;
 448 }
 449 
 450 void MediaControlPanelMuteButtonElement::defaultEventHandler(Event&amp; event)
 451 {
 452     if (event.type() == eventNames().mouseoverEvent)
 453         m_controls-&gt;showVolumeSlider();
 454 
 455     MediaControlMuteButtonElement::defaultEventHandler(event);
 456 }
 457 
 458 // ----------------------------
 459 
 460 MediaControlVolumeSliderMuteButtonElement::MediaControlVolumeSliderMuteButtonElement(Document&amp; document)
 461     : MediaControlMuteButtonElement(document, MediaMuteButton)
 462 {
 463     setPseudo(AtomicString(&quot;-webkit-media-controls-volume-slider-mute-button&quot;, AtomicString::ConstructFromLiteral));
 464 }
 465 
 466 Ref&lt;MediaControlVolumeSliderMuteButtonElement&gt; MediaControlVolumeSliderMuteButtonElement::create(Document&amp; document)
 467 {
 468     Ref&lt;MediaControlVolumeSliderMuteButtonElement&gt; button = adoptRef(*new MediaControlVolumeSliderMuteButtonElement(document));
 469     button-&gt;ensureUserAgentShadowRoot();
 470     button-&gt;setType(&quot;button&quot;);
 471     return button;
 472 }
 473 
 474 // ----------------------------
 475 
 476 MediaControlPlayButtonElement::MediaControlPlayButtonElement(Document&amp; document)
 477     : MediaControlInputElement(document, MediaPlayButton)
 478 {
 479     setPseudo(AtomicString(&quot;-webkit-media-controls-play-button&quot;, AtomicString::ConstructFromLiteral));
 480 }
 481 
 482 Ref&lt;MediaControlPlayButtonElement&gt; MediaControlPlayButtonElement::create(Document&amp; document)
 483 {
 484     Ref&lt;MediaControlPlayButtonElement&gt; button = adoptRef(*new MediaControlPlayButtonElement(document));
 485     button-&gt;ensureUserAgentShadowRoot();
 486     button-&gt;setType(&quot;button&quot;);
 487     return button;
 488 }
 489 
 490 void MediaControlPlayButtonElement::defaultEventHandler(Event&amp; event)
 491 {
 492     if (event.type() == eventNames().clickEvent) {
 493         if (mediaController()-&gt;canPlay())
 494             mediaController()-&gt;play();
 495         else
 496             mediaController()-&gt;pause();
 497         updateDisplayType();
 498         event.setDefaultHandled();
 499     }
 500     HTMLInputElement::defaultEventHandler(event);
 501 }
 502 
 503 void MediaControlPlayButtonElement::updateDisplayType()
 504 {
 505     setDisplayType(mediaController()-&gt;canPlay() ? MediaPlayButton : MediaPauseButton);
 506 }
 507 
 508 // ----------------------------
 509 
 510 MediaControlOverlayPlayButtonElement::MediaControlOverlayPlayButtonElement(Document&amp; document)
 511     : MediaControlInputElement(document, MediaOverlayPlayButton)
 512 {
 513     setPseudo(AtomicString(&quot;-webkit-media-controls-overlay-play-button&quot;, AtomicString::ConstructFromLiteral));
 514 }
 515 
 516 Ref&lt;MediaControlOverlayPlayButtonElement&gt; MediaControlOverlayPlayButtonElement::create(Document&amp; document)
 517 {
 518     Ref&lt;MediaControlOverlayPlayButtonElement&gt; button = adoptRef(*new MediaControlOverlayPlayButtonElement(document));
 519     button-&gt;ensureUserAgentShadowRoot();
 520     button-&gt;setType(&quot;button&quot;);
 521     return button;
 522 }
 523 
 524 void MediaControlOverlayPlayButtonElement::defaultEventHandler(Event&amp; event)
 525 {
 526     if (event.type() == eventNames().clickEvent &amp;&amp; mediaController()-&gt;canPlay()) {
 527         mediaController()-&gt;play();
 528         updateDisplayType();
 529         event.setDefaultHandled();
 530     }
 531     HTMLInputElement::defaultEventHandler(event);
 532 }
 533 
 534 void MediaControlOverlayPlayButtonElement::updateDisplayType()
 535 {
 536     if (mediaController()-&gt;canPlay()) {
 537         show();
 538     } else
 539         hide();
 540 }
 541 
 542 // ----------------------------
 543 
 544 MediaControlSeekForwardButtonElement::MediaControlSeekForwardButtonElement(Document&amp; document)
 545     : MediaControlSeekButtonElement(document, MediaSeekForwardButton)
 546 {
 547     setPseudo(AtomicString(&quot;-webkit-media-controls-seek-forward-button&quot;, AtomicString::ConstructFromLiteral));
 548 }
 549 
 550 Ref&lt;MediaControlSeekForwardButtonElement&gt; MediaControlSeekForwardButtonElement::create(Document&amp; document)
 551 {
 552     Ref&lt;MediaControlSeekForwardButtonElement&gt; button = adoptRef(*new MediaControlSeekForwardButtonElement(document));
 553     button-&gt;ensureUserAgentShadowRoot();
 554     button-&gt;setType(&quot;button&quot;);
 555     return button;
 556 }
 557 
 558 // ----------------------------
 559 
 560 MediaControlSeekBackButtonElement::MediaControlSeekBackButtonElement(Document&amp; document)
 561     : MediaControlSeekButtonElement(document, MediaSeekBackButton)
 562 {
 563     setPseudo(AtomicString(&quot;-webkit-media-controls-seek-back-button&quot;, AtomicString::ConstructFromLiteral));
 564 }
 565 
 566 Ref&lt;MediaControlSeekBackButtonElement&gt; MediaControlSeekBackButtonElement::create(Document&amp; document)
 567 {
 568     Ref&lt;MediaControlSeekBackButtonElement&gt; button = adoptRef(*new MediaControlSeekBackButtonElement(document));
 569     button-&gt;ensureUserAgentShadowRoot();
 570     button-&gt;setType(&quot;button&quot;);
 571     return button;
 572 }
 573 
 574 // ----------------------------
 575 
 576 MediaControlRewindButtonElement::MediaControlRewindButtonElement(Document&amp; document)
 577     : MediaControlInputElement(document, MediaRewindButton)
 578 {
 579     setPseudo(AtomicString(&quot;-webkit-media-controls-rewind-button&quot;, AtomicString::ConstructFromLiteral));
 580 }
 581 
 582 Ref&lt;MediaControlRewindButtonElement&gt; MediaControlRewindButtonElement::create(Document&amp; document)
 583 {
 584     Ref&lt;MediaControlRewindButtonElement&gt; button = adoptRef(*new MediaControlRewindButtonElement(document));
 585     button-&gt;ensureUserAgentShadowRoot();
 586     button-&gt;setType(&quot;button&quot;);
 587     return button;
 588 }
 589 
 590 void MediaControlRewindButtonElement::defaultEventHandler(Event&amp; event)
 591 {
 592     if (event.type() == eventNames().clickEvent) {
 593         mediaController()-&gt;setCurrentTime(std::max&lt;double&gt;(0, mediaController()-&gt;currentTime() - 30));
 594         event.setDefaultHandled();
 595     }
 596     HTMLInputElement::defaultEventHandler(event);
 597 }
 598 
 599 // ----------------------------
 600 
 601 MediaControlReturnToRealtimeButtonElement::MediaControlReturnToRealtimeButtonElement(Document&amp; document)
 602     : MediaControlInputElement(document, MediaReturnToRealtimeButton)
 603 {
 604     setPseudo(AtomicString(&quot;-webkit-media-controls-return-to-realtime-button&quot;, AtomicString::ConstructFromLiteral));
 605 }
 606 
 607 Ref&lt;MediaControlReturnToRealtimeButtonElement&gt; MediaControlReturnToRealtimeButtonElement::create(Document&amp; document)
 608 {
 609     Ref&lt;MediaControlReturnToRealtimeButtonElement&gt; button = adoptRef(*new MediaControlReturnToRealtimeButtonElement(document));
 610     button-&gt;ensureUserAgentShadowRoot();
 611     button-&gt;setType(&quot;button&quot;);
 612     button-&gt;hide();
 613     return button;
 614 }
 615 
 616 void MediaControlReturnToRealtimeButtonElement::defaultEventHandler(Event&amp; event)
 617 {
 618     if (event.type() == eventNames().clickEvent) {
 619         mediaController()-&gt;returnToRealtime();
 620         event.setDefaultHandled();
 621     }
 622     HTMLInputElement::defaultEventHandler(event);
 623 }
 624 
 625 // ----------------------------
 626 
 627 MediaControlToggleClosedCaptionsButtonElement::MediaControlToggleClosedCaptionsButtonElement(Document&amp; document, MediaControls* controls)
 628     : MediaControlInputElement(document, MediaShowClosedCaptionsButton)
 629 #if PLATFORM(COCOA) || PLATFORM(WIN) || PLATFORM(GTK)
 630     , m_controls(controls)
 631 #endif
 632 {
 633 #if !PLATFORM(COCOA) &amp;&amp; !PLATFORM(WIN) || !PLATFORM(GTK)
 634     UNUSED_PARAM(controls);
 635 #endif
 636     setPseudo(AtomicString(&quot;-webkit-media-controls-toggle-closed-captions-button&quot;, AtomicString::ConstructFromLiteral));
 637 }
 638 
 639 Ref&lt;MediaControlToggleClosedCaptionsButtonElement&gt; MediaControlToggleClosedCaptionsButtonElement::create(Document&amp; document, MediaControls* controls)
 640 {
 641     ASSERT(controls);
 642 
 643     Ref&lt;MediaControlToggleClosedCaptionsButtonElement&gt; button = adoptRef(*new MediaControlToggleClosedCaptionsButtonElement(document, controls));
 644     button-&gt;ensureUserAgentShadowRoot();
 645     button-&gt;setType(&quot;button&quot;);
 646     button-&gt;hide();
 647     return button;
 648 }
 649 
 650 void MediaControlToggleClosedCaptionsButtonElement::updateDisplayType()
 651 {
 652     bool captionsVisible = mediaController()-&gt;closedCaptionsVisible();
 653     setDisplayType(captionsVisible ? MediaHideClosedCaptionsButton : MediaShowClosedCaptionsButton);
 654     setChecked(captionsVisible);
 655 }
 656 
 657 void MediaControlToggleClosedCaptionsButtonElement::defaultEventHandler(Event&amp; event)
 658 {
 659     if (event.type() == eventNames().clickEvent) {
 660         // FIXME: It&#39;s not great that the shared code is dictating behavior of platform-specific
 661         // UI. Not all ports may want the closed captions button to toggle a list of tracks, so
 662         // we have to use #if.
 663         // https://bugs.webkit.org/show_bug.cgi?id=101877
 664 #if !PLATFORM(COCOA) &amp;&amp; !PLATFORM(WIN) &amp;&amp; !PLATFORM(GTK)
 665         mediaController()-&gt;setClosedCaptionsVisible(!mediaController()-&gt;closedCaptionsVisible());
 666         setChecked(mediaController()-&gt;closedCaptionsVisible());
 667         updateDisplayType();
 668 #else
 669         m_controls-&gt;toggleClosedCaptionTrackList();
 670 #endif
 671         event.setDefaultHandled();
 672     }
 673 
 674     HTMLInputElement::defaultEventHandler(event);
 675 }
 676 
 677 // ----------------------------
 678 
 679 MediaControlClosedCaptionsContainerElement::MediaControlClosedCaptionsContainerElement(Document&amp; document)
 680     : MediaControlDivElement(document, MediaClosedCaptionsContainer)
 681 {
 682     setPseudo(AtomicString(&quot;-webkit-media-controls-closed-captions-container&quot;, AtomicString::ConstructFromLiteral));
 683 }
 684 
 685 Ref&lt;MediaControlClosedCaptionsContainerElement&gt; MediaControlClosedCaptionsContainerElement::create(Document&amp; document)
 686 {
 687     Ref&lt;MediaControlClosedCaptionsContainerElement&gt; element = adoptRef(*new MediaControlClosedCaptionsContainerElement(document));
 688     element-&gt;setAttributeWithoutSynchronization(dirAttr, AtomicString(&quot;auto&quot;, AtomicString::ConstructFromLiteral));
 689     element-&gt;hide();
 690     return element;
 691 }
 692 
 693 // ----------------------------
 694 
 695 MediaControlClosedCaptionsTrackListElement::MediaControlClosedCaptionsTrackListElement(Document&amp; document, MediaControls* controls)
 696     : MediaControlDivElement(document, MediaClosedCaptionsTrackList)
 697 #if ENABLE(VIDEO_TRACK)
 698     , m_controls(controls)
 699 #endif
 700 {
 701 #if !ENABLE(VIDEO_TRACK)
 702     UNUSED_PARAM(controls);
 703 #endif
 704     setPseudo(AtomicString(&quot;-webkit-media-controls-closed-captions-track-list&quot;, AtomicString::ConstructFromLiteral));
 705 }
 706 
 707 Ref&lt;MediaControlClosedCaptionsTrackListElement&gt; MediaControlClosedCaptionsTrackListElement::create(Document&amp; document, MediaControls* controls)
 708 {
 709     ASSERT(controls);
 710     Ref&lt;MediaControlClosedCaptionsTrackListElement&gt; element = adoptRef(*new MediaControlClosedCaptionsTrackListElement(document, controls));
 711     return element;
 712 }
 713 
 714 void MediaControlClosedCaptionsTrackListElement::defaultEventHandler(Event&amp; event)
 715 {
 716 #if ENABLE(VIDEO_TRACK)
 717     if (event.type() == eventNames().clickEvent) {
 718         if (!is&lt;Element&gt;(event.target()))
 719             return;
 720 
 721         // When we created the elements in the track list, we gave them a custom
 722         // attribute representing the index in the HTMLMediaElement&#39;s list of tracks.
 723         // Check if the event target has such a custom element and, if so,
 724         // tell the HTMLMediaElement to enable that track.
 725 
 726         auto textTrack = makeRefPtr(m_menuToTrackMap.get(&amp;downcast&lt;Element&gt;(*event.target())));
 727         m_menuToTrackMap.clear();
 728         m_controls-&gt;toggleClosedCaptionTrackList();
 729         if (!textTrack)
 730             return;
 731 
 732         auto mediaElement = parentMediaElement(this);
 733         if (!mediaElement)
 734             return;
 735 
 736         mediaElement-&gt;setSelectedTextTrack(textTrack.get());
 737 
 738         updateDisplay();
 739     }
 740 
 741     MediaControlDivElement::defaultEventHandler(event);
 742 #else
 743     UNUSED_PARAM(event);
 744 #endif
 745 }
 746 
 747 void MediaControlClosedCaptionsTrackListElement::updateDisplay()
 748 {
 749 #if ENABLE(VIDEO_TRACK)
 750     static NeverDestroyed&lt;AtomicString&gt; selectedClassValue(&quot;selected&quot;, AtomicString::ConstructFromLiteral);
 751 
 752     if (!mediaController()-&gt;hasClosedCaptions())
 753         return;
 754 
 755     if (!document().page())
 756         return;
 757     CaptionUserPreferences::CaptionDisplayMode displayMode = document().page()-&gt;group().captionPreferences().captionDisplayMode();
 758 
 759     auto mediaElement = parentMediaElement(this);
 760     if (!mediaElement)
 761         return;
 762 
 763     if (!mediaElement-&gt;textTracks() || !mediaElement-&gt;textTracks()-&gt;length())
 764         return;
 765 
 766     rebuildTrackListMenu();
 767 
 768     RefPtr&lt;Element&gt; offMenuItem;
 769     bool trackMenuItemSelected = false;
 770 
 771     for (auto&amp; trackItem : m_menuItems) {
 772         RefPtr&lt;TextTrack&gt; textTrack;
 773         MenuItemToTrackMap::iterator iter = m_menuToTrackMap.find(trackItem.get());
 774         if (iter == m_menuToTrackMap.end())
 775             continue;
 776         textTrack = iter-&gt;value;
 777         if (!textTrack)
 778             continue;
 779 
 780         if (textTrack == TextTrack::captionMenuOffItem()) {
 781             offMenuItem = trackItem;
 782             continue;
 783         }
 784 
 785         if (textTrack == TextTrack::captionMenuAutomaticItem()) {
 786             if (displayMode == CaptionUserPreferences::Automatic)
 787                 trackItem-&gt;classList().add(selectedClassValue);
 788             else
 789                 trackItem-&gt;classList().remove(selectedClassValue);
 790             continue;
 791         }
 792 
 793         if (displayMode != CaptionUserPreferences::Automatic &amp;&amp; textTrack-&gt;mode() == TextTrack::Mode::Showing) {
 794             trackMenuItemSelected = true;
 795             trackItem-&gt;classList().add(selectedClassValue);
 796         } else
 797             trackItem-&gt;classList().remove(selectedClassValue);
 798     }
 799 
 800     if (offMenuItem) {
 801         if (displayMode == CaptionUserPreferences::ForcedOnly &amp;&amp; !trackMenuItemSelected)
 802             offMenuItem-&gt;classList().add(selectedClassValue);
 803         else
 804             offMenuItem-&gt;classList().remove(selectedClassValue);
 805     }
 806 #endif
 807 }
 808 
 809 void MediaControlClosedCaptionsTrackListElement::rebuildTrackListMenu()
 810 {
 811 #if ENABLE(VIDEO_TRACK)
 812     // Remove any existing content.
 813     removeChildren();
 814     m_menuItems.clear();
 815     m_menuToTrackMap.clear();
 816 
 817     if (!mediaController()-&gt;hasClosedCaptions())
 818         return;
 819 
 820     auto mediaElement = parentMediaElement(this);
 821     if (!mediaElement)
 822         return;
 823 
 824     auto* trackList = mediaElement-&gt;textTracks();
 825     if (!trackList || !trackList-&gt;length())
 826         return;
 827 
 828     if (!document().page())
 829         return;
 830     auto&amp; captionPreferences = document().page()-&gt;group().captionPreferences();
 831     Vector&lt;RefPtr&lt;TextTrack&gt;&gt; tracksForMenu = captionPreferences.sortedTrackListForMenu(trackList);
 832 
 833     auto captionsHeader = HTMLHeadingElement::create(h3Tag, document());
 834     captionsHeader-&gt;appendChild(document().createTextNode(textTrackSubtitlesText()));
 835     appendChild(captionsHeader);
 836     auto captionsMenuList = HTMLUListElement::create(document());
 837 
 838     for (auto&amp; textTrack : tracksForMenu) {
 839         auto menuItem = HTMLLIElement::create(document());
 840         menuItem-&gt;appendChild(document().createTextNode(captionPreferences.displayNameForTrack(textTrack.get())));
 841         captionsMenuList-&gt;appendChild(menuItem);
 842         m_menuItems.append(menuItem.ptr());
 843         m_menuToTrackMap.add(menuItem.ptr(), textTrack);
 844     }
 845 
 846     appendChild(captionsMenuList);
 847 #endif
 848 }
 849 
 850 // ----------------------------
 851 
 852 MediaControlTimelineElement::MediaControlTimelineElement(Document&amp; document, MediaControls* controls)
 853     : MediaControlInputElement(document, MediaSlider)
 854     , m_controls(controls)
 855 {
 856     setPseudo(AtomicString(&quot;-webkit-media-controls-timeline&quot;, AtomicString::ConstructFromLiteral));
 857 }
 858 
 859 Ref&lt;MediaControlTimelineElement&gt; MediaControlTimelineElement::create(Document&amp; document, MediaControls* controls)
 860 {
 861     ASSERT(controls);
 862 
 863     Ref&lt;MediaControlTimelineElement&gt; timeline = adoptRef(*new MediaControlTimelineElement(document, controls));
 864     timeline-&gt;ensureUserAgentShadowRoot();
 865     timeline-&gt;setType(&quot;range&quot;);
 866     timeline-&gt;setAttributeWithoutSynchronization(precisionAttr, AtomicString(&quot;float&quot;, AtomicString::ConstructFromLiteral));
 867     return timeline;
 868 }
 869 
 870 void MediaControlTimelineElement::defaultEventHandler(Event&amp; event)
 871 {
 872     // Left button is 0. Rejects mouse events not from left button.
 873     if (is&lt;MouseEvent&gt;(event) &amp;&amp; downcast&lt;MouseEvent&gt;(event).button())
 874         return;
 875 
 876     if (!renderer())
 877         return;
 878 
 879     if (event.type() == eventNames().mousedownEvent)
 880         mediaController()-&gt;beginScrubbing();
 881 
 882     if (event.type() == eventNames().mouseupEvent)
 883         mediaController()-&gt;endScrubbing();
 884 
 885     MediaControlInputElement::defaultEventHandler(event);
 886 
 887     if (event.type() == eventNames().mouseoverEvent || event.type() == eventNames().mouseoutEvent || event.type() == eventNames().mousemoveEvent)
 888         return;
 889 
 890     double time = value().toDouble();
 891     if ((event.isInputEvent() || event.type() == eventNames().inputEvent) &amp;&amp; time != mediaController()-&gt;currentTime())
 892         mediaController()-&gt;setCurrentTime(time);
 893 
 894     RenderSlider&amp; slider = downcast&lt;RenderSlider&gt;(*renderer());
 895     if (slider.inDragMode())
 896         m_controls-&gt;updateCurrentTimeDisplay();
 897 }
 898 
 899 #if !PLATFORM(IOS_FAMILY)
 900 bool MediaControlTimelineElement::willRespondToMouseClickEvents()
 901 {
 902     if (!renderer())
 903         return false;
 904 
 905     return true;
 906 }
 907 #endif // !PLATFORM(IOS_FAMILY)
 908 
 909 void MediaControlTimelineElement::setPosition(double currentTime)
 910 {
 911     setValue(String::numberToStringECMAScript(currentTime));
 912 }
 913 
 914 void MediaControlTimelineElement::setDuration(double duration)
 915 {
 916     setAttribute(maxAttr, AtomicString::number(duration));
 917 }
 918 
 919 // ----------------------------
 920 
 921 MediaControlPanelVolumeSliderElement::MediaControlPanelVolumeSliderElement(Document&amp; document)
 922     : MediaControlVolumeSliderElement(document)
 923 {
 924     setPseudo(AtomicString(&quot;-webkit-media-controls-volume-slider&quot;, AtomicString::ConstructFromLiteral));
 925 }
 926 
 927 Ref&lt;MediaControlPanelVolumeSliderElement&gt; MediaControlPanelVolumeSliderElement::create(Document&amp; document)
 928 {
 929     Ref&lt;MediaControlPanelVolumeSliderElement&gt; slider = adoptRef(*new MediaControlPanelVolumeSliderElement(document));
 930     slider-&gt;ensureUserAgentShadowRoot();
 931     slider-&gt;setType(&quot;range&quot;);
 932     slider-&gt;setAttributeWithoutSynchronization(precisionAttr, AtomicString(&quot;float&quot;, AtomicString::ConstructFromLiteral));
 933     slider-&gt;setAttributeWithoutSynchronization(maxAttr, AtomicString(&quot;1&quot;, AtomicString::ConstructFromLiteral));
 934     return slider;
 935 }
 936 
 937 // ----------------------------
 938 
 939 MediaControlFullscreenVolumeSliderElement::MediaControlFullscreenVolumeSliderElement(Document&amp; document)
 940     : MediaControlVolumeSliderElement(document)
 941 {
 942     setPseudo(AtomicString(&quot;-webkit-media-controls-fullscreen-volume-slider&quot;, AtomicString::ConstructFromLiteral));
 943 }
 944 
 945 Ref&lt;MediaControlFullscreenVolumeSliderElement&gt; MediaControlFullscreenVolumeSliderElement::create(Document&amp; document)
 946 {
 947     Ref&lt;MediaControlFullscreenVolumeSliderElement&gt; slider = adoptRef(*new MediaControlFullscreenVolumeSliderElement(document));
 948     slider-&gt;ensureUserAgentShadowRoot();
 949     slider-&gt;setType(&quot;range&quot;);
 950     slider-&gt;setAttributeWithoutSynchronization(precisionAttr, AtomicString(&quot;float&quot;, AtomicString::ConstructFromLiteral));
 951     slider-&gt;setAttributeWithoutSynchronization(maxAttr, AtomicString(&quot;1&quot;, AtomicString::ConstructFromLiteral));
 952     return slider;
 953 }
 954 
 955 // ----------------------------
 956 
 957 MediaControlFullscreenButtonElement::MediaControlFullscreenButtonElement(Document&amp; document)
 958     : MediaControlInputElement(document, MediaEnterFullscreenButton)
 959 {
 960     setPseudo(AtomicString(&quot;-webkit-media-controls-fullscreen-button&quot;, AtomicString::ConstructFromLiteral));
 961 }
 962 
 963 Ref&lt;MediaControlFullscreenButtonElement&gt; MediaControlFullscreenButtonElement::create(Document&amp; document)
 964 {
 965     Ref&lt;MediaControlFullscreenButtonElement&gt; button = adoptRef(*new MediaControlFullscreenButtonElement(document));
 966     button-&gt;ensureUserAgentShadowRoot();
 967     button-&gt;setType(&quot;button&quot;);
 968     button-&gt;hide();
 969     return button;
 970 }
 971 
 972 void MediaControlFullscreenButtonElement::defaultEventHandler(Event&amp; event)
 973 {
 974     if (event.type() == eventNames().clickEvent) {
 975 #if ENABLE(FULLSCREEN_API)
 976         // Only use the new full screen API if the fullScreenEnabled setting has
 977         // been explicitly enabled. Otherwise, use the old fullscreen API. This
 978         // allows apps which embed a WebView to retain the existing full screen
 979         // video implementation without requiring them to implement their own full
 980         // screen behavior.
 981         if (document().settings().fullScreenEnabled()) {
 982             if (document().webkitIsFullScreen() &amp;&amp; document().webkitCurrentFullScreenElement() == parentMediaElement(this))
 983                 document().webkitCancelFullScreen();
 984             else
 985                 document().requestFullScreenForElement(parentMediaElement(this).get(), Document::ExemptIFrameAllowFullScreenRequirement);
 986         } else
 987 #endif
 988             mediaController()-&gt;enterFullscreen();
 989         event.setDefaultHandled();
 990     }
 991     HTMLInputElement::defaultEventHandler(event);
 992 }
 993 
 994 void MediaControlFullscreenButtonElement::setIsFullscreen(bool isFullscreen)
 995 {
 996     setDisplayType(isFullscreen ? MediaExitFullscreenButton : MediaEnterFullscreenButton);
 997 }
 998 
 999 // ----------------------------
1000 
1001 MediaControlFullscreenVolumeMinButtonElement::MediaControlFullscreenVolumeMinButtonElement(Document&amp; document)
1002     : MediaControlInputElement(document, MediaUnMuteButton)
1003 {
1004     setPseudo(AtomicString(&quot;-webkit-media-controls-fullscreen-volume-min-button&quot;, AtomicString::ConstructFromLiteral));
1005 }
1006 
1007 Ref&lt;MediaControlFullscreenVolumeMinButtonElement&gt; MediaControlFullscreenVolumeMinButtonElement::create(Document&amp; document)
1008 {
1009     Ref&lt;MediaControlFullscreenVolumeMinButtonElement&gt; button = adoptRef(*new MediaControlFullscreenVolumeMinButtonElement(document));
1010     button-&gt;ensureUserAgentShadowRoot();
1011     button-&gt;setType(&quot;button&quot;);
1012     return button;
1013 }
1014 
1015 void MediaControlFullscreenVolumeMinButtonElement::defaultEventHandler(Event&amp; event)
1016 {
1017     if (event.type() == eventNames().clickEvent) {
1018         mediaController()-&gt;setVolume(0);
1019         event.setDefaultHandled();
1020     }
1021     HTMLInputElement::defaultEventHandler(event);
1022 }
1023 
1024 // ----------------------------
1025 
1026 MediaControlFullscreenVolumeMaxButtonElement::MediaControlFullscreenVolumeMaxButtonElement(Document&amp; document)
1027 : MediaControlInputElement(document, MediaMuteButton)
1028 {
1029     setPseudo(AtomicString(&quot;-webkit-media-controls-fullscreen-volume-max-button&quot;, AtomicString::ConstructFromLiteral));
1030 }
1031 
1032 Ref&lt;MediaControlFullscreenVolumeMaxButtonElement&gt; MediaControlFullscreenVolumeMaxButtonElement::create(Document&amp; document)
1033 {
1034     Ref&lt;MediaControlFullscreenVolumeMaxButtonElement&gt; button = adoptRef(*new MediaControlFullscreenVolumeMaxButtonElement(document));
1035     button-&gt;ensureUserAgentShadowRoot();
1036     button-&gt;setType(&quot;button&quot;);
1037     return button;
1038 }
1039 
1040 void MediaControlFullscreenVolumeMaxButtonElement::defaultEventHandler(Event&amp; event)
1041 {
1042     if (event.type() == eventNames().clickEvent) {
1043         mediaController()-&gt;setVolume(1);
1044         event.setDefaultHandled();
1045     }
1046     HTMLInputElement::defaultEventHandler(event);
1047 }
1048 
1049 // ----------------------------
1050 
1051 MediaControlTimeRemainingDisplayElement::MediaControlTimeRemainingDisplayElement(Document&amp; document)
1052     : MediaControlTimeDisplayElement(document, MediaTimeRemainingDisplay)
1053 {
1054     setPseudo(getMediaControlTimeRemainingDisplayElementShadowPseudoId());
1055 }
1056 
1057 Ref&lt;MediaControlTimeRemainingDisplayElement&gt; MediaControlTimeRemainingDisplayElement::create(Document&amp; document)
1058 {
1059     return adoptRef(*new MediaControlTimeRemainingDisplayElement(document));
1060 }
1061 
1062 static const AtomicString&amp; getMediaControlTimeRemainingDisplayElementShadowPseudoId()
1063 {
1064     static NeverDestroyed&lt;AtomicString&gt; id(&quot;-webkit-media-controls-time-remaining-display&quot;, AtomicString::ConstructFromLiteral);
1065     return id;
1066 }
1067 
1068 // ----------------------------
1069 
1070 MediaControlCurrentTimeDisplayElement::MediaControlCurrentTimeDisplayElement(Document&amp; document)
1071     : MediaControlTimeDisplayElement(document, MediaCurrentTimeDisplay)
1072 {
1073     setPseudo(getMediaControlCurrentTimeDisplayElementShadowPseudoId());
1074 }
1075 
1076 Ref&lt;MediaControlCurrentTimeDisplayElement&gt; MediaControlCurrentTimeDisplayElement::create(Document&amp; document)
1077 {
1078     return adoptRef(*new MediaControlCurrentTimeDisplayElement(document));
1079 }
1080 
1081 static const AtomicString&amp; getMediaControlCurrentTimeDisplayElementShadowPseudoId()
1082 {
1083     static NeverDestroyed&lt;AtomicString&gt; id(&quot;-webkit-media-controls-current-time-display&quot;, AtomicString::ConstructFromLiteral);
1084     return id;
1085 }
1086 
1087 // ----------------------------
1088 
1089 #if ENABLE(VIDEO_TRACK)
1090 
1091 MediaControlTextTrackContainerElement::MediaControlTextTrackContainerElement(Document&amp; document)
1092     : MediaControlDivElement(document, MediaTextTrackDisplayContainer)
1093     , m_updateTimer(*this, &amp;MediaControlTextTrackContainerElement::updateTimerFired)
1094     , m_fontSize(0)
1095     , m_fontSizeIsImportant(false)
1096     , m_updateTextTrackRepresentationStyle(false)
1097 {
1098     setPseudo(AtomicString(&quot;-webkit-media-text-track-container&quot;, AtomicString::ConstructFromLiteral));
1099 }
1100 
1101 Ref&lt;MediaControlTextTrackContainerElement&gt; MediaControlTextTrackContainerElement::create(Document&amp; document)
1102 {
1103     auto element = adoptRef(*new MediaControlTextTrackContainerElement(document));
1104     element-&gt;hide();
1105     return element;
1106 }
1107 
1108 RenderPtr&lt;RenderElement&gt; MediaControlTextTrackContainerElement::createElementRenderer(RenderStyle&amp;&amp; style, const RenderTreePosition&amp;)
1109 {
1110     return createRenderer&lt;RenderTextTrackContainerElement&gt;(*this, WTFMove(style));
1111 }
1112 
1113 static bool compareCueIntervalForDisplay(const CueInterval&amp; one, const CueInterval&amp; two)
1114 {
1115     return one.data()-&gt;isPositionedAbove(two.data());
1116 };
1117 
1118 void MediaControlTextTrackContainerElement::updateDisplay()
1119 {
1120     if (!mediaController()-&gt;closedCaptionsVisible())
1121         removeChildren();
1122 
1123     auto mediaElement = parentMediaElement(this);
1124     // 1. If the media element is an audio element, or is another playback
1125     // mechanism with no rendering area, abort these steps. There is nothing to
1126     // render.
1127     if (!mediaElement || !mediaElement-&gt;isVideo())
1128         return;
1129 
1130     // 2. Let video be the media element or other playback mechanism.
1131     HTMLVideoElement&amp; video = downcast&lt;HTMLVideoElement&gt;(*mediaElement);
1132 
1133     // 3. Let output be an empty list of absolutely positioned CSS block boxes.
1134     Vector&lt;RefPtr&lt;HTMLDivElement&gt;&gt; output;
1135 
1136     // 4. If the user agent is exposing a user interface for video, add to
1137     // output one or more completely transparent positioned CSS block boxes that
1138     // cover the same region as the user interface.
1139 
1140     // 5. If the last time these rules were run, the user agent was not exposing
1141     // a user interface for video, but now it is, let reset be true. Otherwise,
1142     // let reset be false.
1143 
1144     // There is nothing to be done explicitly for 4th and 5th steps, as
1145     // everything is handled through CSS. The caption box is on top of the
1146     // controls box, in a container set with the -webkit-box display property.
1147 
1148     // 6. Let tracks be the subset of video&#39;s list of text tracks that have as
1149     // their rules for updating the text track rendering these rules for
1150     // updating the display of WebVTT text tracks, and whose text track mode is
1151     // showing or showing by default.
1152     // 7. Let cues be an empty list of text track cues.
1153     // 8. For each track track in tracks, append to cues all the cues from
1154     // track&#39;s list of cues that have their text track cue active flag set.
1155     CueList activeCues = video.currentlyActiveCues();
1156 
1157     // 9. If reset is false, then, for each text track cue cue in cues: if cue&#39;s
1158     // text track cue display state has a set of CSS boxes, then add those boxes
1159     // to output, and remove cue from cues.
1160 
1161     // There is nothing explicitly to be done here, as all the caching occurs
1162     // within the TextTrackCue instance itself. If parameters of the cue change,
1163     // the display tree is cleared.
1164 
1165     // If the number of CSS boxes in the output is less than the number of cues
1166     // we wish to render (e.g., we are adding another cue in a set of roll-up
1167     // cues), remove all the existing CSS boxes representing the cues and re-add
1168     // them so that the new cue is at the bottom.
1169     // FIXME: Calling countChildNodes() here is inefficient. We don&#39;t need to
1170     // traverse all children just to check if there are less children than cues.
1171     if (countChildNodes() &lt; activeCues.size())
1172         removeChildren();
1173 
1174     activeCues.removeAllMatching([] (CueInterval&amp; cueInterval) {
1175         if (!cueInterval.data() || !cueInterval.data()-&gt;isRenderable())
1176             return true;
1177 
1178         RefPtr&lt;VTTCue&gt; cue = toVTTCue(cueInterval.data());
1179 
1180         return !cue-&gt;isRenderable()
1181             || !cue-&gt;track()
1182             || !cue-&gt;track()-&gt;isRendered()
1183             || cue-&gt;track()-&gt;mode() == TextTrack::Mode::Disabled
1184             || !cue-&gt;isActive()
1185             || cue-&gt;text().isEmpty();
1186     });
1187 
1188     // Sort the active cues for the appropriate display order. For example, for roll-up
1189     // or paint-on captions, we need to add the cues in reverse chronological order,
1190     // so that the newest captions appear at the bottom.
1191     std::sort(activeCues.begin(), activeCues.end(), &amp;compareCueIntervalForDisplay);
1192 
1193     // 10. For each text track cue cue in cues that has not yet had
1194     // corresponding CSS boxes added to output, in text track cue order, run the
1195     // following substeps:
1196     for (size_t i = 0; i &lt; activeCues.size(); ++i) {
1197         if (!mediaController()-&gt;closedCaptionsVisible())
1198             continue;
1199 
1200         RefPtr&lt;VTTCue&gt; cue = toVTTCue(activeCues[i].data());
1201         ASSERT(cue);
1202         if (!cue)
1203             continue;
1204 
1205         LOG(Media, &quot;MediaControlTextTrackContainerElement::updateDisplay(%p) - adding and positioning cue #%zu: \&quot;%s\&quot;, start=%.2f, end=%.2f, line=%.2f&quot;, this, i, cue-&gt;text().utf8().data(), cue-&gt;startTime(), cue-&gt;endTime(), cue-&gt;line());
1206         Ref&lt;VTTCueBox&gt; displayBox = cue-&gt;getDisplayTree(m_videoDisplaySize.size(), m_fontSize);
1207         RefPtr&lt;VTTRegion&gt; region = cue-&gt;track()-&gt;regions()-&gt;getRegionById(cue-&gt;regionId());
1208         if (!region) {
1209             // If cue has an empty text track cue region identifier or there is no
1210             // WebVTT region whose region identifier is identical to cue&#39;s text
1211             // track cue region identifier, run the following substeps:
1212             if (displayBox-&gt;hasChildNodes() &amp;&amp; !contains(displayBox.ptr())) {
1213                 // Note: the display tree of a cue is removed when the active flag of the cue is unset.
1214                 appendChild(displayBox);
1215                 cue-&gt;setFontSize(m_fontSize, m_videoDisplaySize.size(), m_fontSizeIsImportant);
1216             }
1217         } else {
1218             // Let region be the WebVTT region whose region identifier
1219             // matches the text track cue region identifier of cue.
1220             Ref&lt;HTMLDivElement&gt; regionNode = region-&gt;getDisplayTree();
1221 
1222             // Append the region to the viewport, if it was not already.
1223             if (!contains(regionNode.ptr()))
1224                 appendChild(region-&gt;getDisplayTree());
1225 
1226             region-&gt;appendTextTrackCueBox(WTFMove(displayBox));
1227         }
1228     }
1229 
1230     // 11. Return output.
1231     if (hasChildNodes()) {
1232         show();
1233         updateTextTrackRepresentation();
1234     } else {
1235         hide();
1236         clearTextTrackRepresentation();
1237     }
1238 }
1239 
1240 void MediaControlTextTrackContainerElement::updateActiveCuesFontSize()
1241 {
1242     if (!document().page())
1243         return;
1244 
1245     auto mediaElement = parentMediaElement(this);
1246     if (!mediaElement)
1247         return;
1248 
1249     float smallestDimension = std::min(m_videoDisplaySize.size().height(), m_videoDisplaySize.size().width());
1250     float fontScale = document().page()-&gt;group().captionPreferences().captionFontSizeScaleAndImportance(m_fontSizeIsImportant);
1251     m_fontSize = lroundf(smallestDimension * fontScale);
1252 
1253     for (auto&amp; activeCue : mediaElement-&gt;currentlyActiveCues()) {
1254         RefPtr&lt;TextTrackCue&gt; cue = activeCue.data();
1255         if (!cue-&gt;isRenderable())
1256             continue;
1257 
1258         toVTTCue(cue.get())-&gt;setFontSize(m_fontSize, m_videoDisplaySize.size(), m_fontSizeIsImportant);
1259     }
1260 
1261 }
1262 
1263 void MediaControlTextTrackContainerElement::updateTextStrokeStyle()
1264 {
1265     if (!document().page())
1266         return;
1267 
1268     auto mediaElement = parentMediaElement(this);
1269     if (!mediaElement)
1270         return;
1271 
1272     String language;
1273 
1274     // FIXME: Since it is possible to have more than one text track enabled, the following code may not find the correct language.
1275     // The default UI only allows a user to enable one track at a time, so it should be OK for now, but we should consider doing
1276     // this differently, see &lt;https://bugs.webkit.org/show_bug.cgi?id=169875&gt;.
1277     if (auto* tracks = mediaElement-&gt;textTracks()) {
1278         for (unsigned i = 0; i &lt; tracks-&gt;length(); ++i) {
1279             auto track = tracks-&gt;item(i);
1280             if (track &amp;&amp; track-&gt;mode() == TextTrack::Mode::Showing) {
1281                 language = track-&gt;validBCP47Language();
1282                 break;
1283             }
1284         }
1285     }
1286 
1287     float strokeWidth;
1288     bool important;
1289 
1290     // FIXME: find a way to set this property in the stylesheet like the other user style preferences, see &lt;https://bugs.webkit.org/show_bug.cgi?id=169874&gt;.
1291     if (document().page()-&gt;group().captionPreferences().captionStrokeWidthForFont(m_fontSize, language, strokeWidth, important))
1292         setInlineStyleProperty(CSSPropertyStrokeWidth, strokeWidth, CSSPrimitiveValue::CSS_PX, important);
1293 }
1294 
1295 void MediaControlTextTrackContainerElement::updateTimerFired()
1296 {
1297     if (!document().page())
1298         return;
1299 
1300     if (m_textTrackRepresentation)
1301         updateStyleForTextTrackRepresentation();
1302 
1303     updateActiveCuesFontSize();
1304     updateDisplay();
1305     updateTextStrokeStyle();
1306 }
1307 
1308 void MediaControlTextTrackContainerElement::updateTextTrackRepresentation()
1309 {
1310     auto mediaElement = parentMediaElement(this);
1311     if (!mediaElement)
1312         return;
1313 
1314     if (!mediaElement-&gt;requiresTextTrackRepresentation()) {
1315         if (m_textTrackRepresentation) {
1316             clearTextTrackRepresentation();
1317             updateSizes(true);
1318         }
1319         return;
1320     }
1321 
1322     if (!m_textTrackRepresentation) {
1323         m_textTrackRepresentation = TextTrackRepresentation::create(*this);
1324         if (document().page())
1325             m_textTrackRepresentation-&gt;setContentScale(document().page()-&gt;deviceScaleFactor());
1326         m_updateTextTrackRepresentationStyle = true;
1327         mediaElement-&gt;setTextTrackRepresentation(m_textTrackRepresentation.get());
1328     }
1329 
1330     m_textTrackRepresentation-&gt;update();
1331     updateStyleForTextTrackRepresentation();
1332 }
1333 
1334 void MediaControlTextTrackContainerElement::clearTextTrackRepresentation()
1335 {
1336     if (!m_textTrackRepresentation)
1337         return;
1338 
1339     m_textTrackRepresentation = nullptr;
1340     m_updateTextTrackRepresentationStyle = true;
1341     if (auto mediaElement = parentMediaElement(this))
1342         mediaElement-&gt;setTextTrackRepresentation(nullptr);
1343     updateStyleForTextTrackRepresentation();
1344     updateActiveCuesFontSize();
1345 }
1346 
1347 void MediaControlTextTrackContainerElement::updateStyleForTextTrackRepresentation()
1348 {
1349     if (!m_updateTextTrackRepresentationStyle)
1350         return;
1351     m_updateTextTrackRepresentationStyle = false;
1352 
1353     if (m_textTrackRepresentation) {
1354         setInlineStyleProperty(CSSPropertyWidth, m_videoDisplaySize.size().width(), CSSPrimitiveValue::CSS_PX);
1355         setInlineStyleProperty(CSSPropertyHeight, m_videoDisplaySize.size().height(), CSSPrimitiveValue::CSS_PX);
1356         setInlineStyleProperty(CSSPropertyPosition, CSSValueAbsolute);
1357         setInlineStyleProperty(CSSPropertyLeft, 0, CSSPrimitiveValue::CSS_PX);
1358         setInlineStyleProperty(CSSPropertyTop, 0, CSSPrimitiveValue::CSS_PX);
1359         return;
1360     }
1361 
1362     removeInlineStyleProperty(CSSPropertyPosition);
1363     removeInlineStyleProperty(CSSPropertyWidth);
1364     removeInlineStyleProperty(CSSPropertyHeight);
1365     removeInlineStyleProperty(CSSPropertyLeft);
1366     removeInlineStyleProperty(CSSPropertyTop);
1367 }
1368 
1369 void MediaControlTextTrackContainerElement::enteredFullscreen()
1370 {
1371     if (hasChildNodes())
1372         updateTextTrackRepresentation();
1373     updateSizes(true);
1374 }
1375 
1376 void MediaControlTextTrackContainerElement::exitedFullscreen()
1377 {
1378     clearTextTrackRepresentation();
1379     updateSizes(true);
1380 }
1381 
1382 void MediaControlTextTrackContainerElement::updateSizes(bool forceUpdate)
1383 {
1384     auto mediaElement = parentMediaElement(this);
1385     if (!mediaElement)
1386         return;
1387 
1388     if (!document().page())
1389         return;
1390 
1391     IntRect videoBox;
1392     if (m_textTrackRepresentation) {
1393         videoBox = m_textTrackRepresentation-&gt;bounds();
1394         float deviceScaleFactor = document().page()-&gt;deviceScaleFactor();
1395         videoBox.setWidth(videoBox.width() * deviceScaleFactor);
1396         videoBox.setHeight(videoBox.height() * deviceScaleFactor);
1397     } else {
1398         if (!is&lt;RenderVideo&gt;(mediaElement-&gt;renderer()))
1399             return;
1400         videoBox = downcast&lt;RenderVideo&gt;(*mediaElement-&gt;renderer()).videoBox();
1401     }
1402 
1403     if (!forceUpdate &amp;&amp; m_videoDisplaySize == videoBox)
1404         return;
1405 
1406     m_videoDisplaySize = videoBox;
1407     m_updateTextTrackRepresentationStyle = true;
1408     mediaElement-&gt;syncTextTrackBounds();
1409 
1410     // FIXME (121170): This function is called during layout, and should lay out the text tracks immediately.
1411     m_updateTimer.startOneShot(0_s);
1412 }
1413 
1414 RefPtr&lt;Image&gt; MediaControlTextTrackContainerElement::createTextTrackRepresentationImage()
1415 {
1416     if (!hasChildNodes())
1417         return nullptr;
1418 
1419     RefPtr&lt;Frame&gt; frame = document().frame();
1420     if (!frame)
1421         return nullptr;
1422 
1423     document().updateLayout();
1424 
1425     auto* renderer = this-&gt;renderer();
1426     if (!renderer)
1427         return nullptr;
1428 
1429     if (!renderer-&gt;hasLayer())
1430         return nullptr;
1431 
1432     RenderLayer* layer = downcast&lt;RenderLayerModelObject&gt;(*renderer).layer();
1433 
1434     float deviceScaleFactor = 1;
1435     if (Page* page = document().page())
1436         deviceScaleFactor = page-&gt;deviceScaleFactor();
1437 
1438     IntRect paintingRect = IntRect(IntPoint(), layer-&gt;size());
1439 
1440     // FIXME (149422): This buffer should not be unconditionally unaccelerated.
1441     std::unique_ptr&lt;ImageBuffer&gt; buffer(ImageBuffer::create(paintingRect.size(), Unaccelerated, deviceScaleFactor));
1442     if (!buffer)
1443         return nullptr;
1444 
1445     layer-&gt;paint(buffer-&gt;context(), paintingRect, LayoutSize(), { PaintBehavior::FlattenCompositingLayers, PaintBehavior::Snapshotting }, nullptr, RenderLayer::paintLayerPaintingCompositingAllPhasesFlags());
1446 
1447     return ImageBuffer::sinkIntoImage(WTFMove(buffer));
1448 }
1449 
1450 void MediaControlTextTrackContainerElement::textTrackRepresentationBoundsChanged(const IntRect&amp;)
1451 {
1452     if (hasChildNodes())
1453         updateTextTrackRepresentation();
1454     updateSizes();
1455 }
1456 
1457 #endif // ENABLE(VIDEO_TRACK)
1458 
1459 // ----------------------------
1460 
1461 } // namespace WebCore
1462 
1463 #endif // ENABLE(VIDEO)
    </pre>
  </body>
</html>