<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderElement.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
   3  *           (C) 1999 Antti Koivisto (koivisto@kde.org)
   4  *           (C) 2005 Allan Sandfeld Jensen (kde@carewolf.com)
   5  *           (C) 2005, 2006 Samuel Weinig (sam.weinig@gmail.com)
   6  * Copyright (C) 2005, 2006, 2007, 2008, 2009, 2013, 2015 Apple Inc. All rights reserved.
   7  * Copyright (C) 2010, 2012 Google Inc. All rights reserved.
   8  *
   9  * This library is free software; you can redistribute it and/or
  10  * modify it under the terms of the GNU Library General Public
  11  * License as published by the Free Software Foundation; either
  12  * version 2 of the License, or (at your option) any later version.
  13  *
  14  * This library is distributed in the hope that it will be useful,
  15  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  16  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  17  * Library General Public License for more details.
  18  *
  19  * You should have received a copy of the GNU Library General Public License
  20  * along with this library; see the file COPYING.LIB.  If not, write to
  21  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  22  * Boston, MA 02110-1301, USA.
  23  */
  24 
  25 #include &quot;config.h&quot;
  26 #include &quot;RenderElement.h&quot;
  27 
  28 #include &quot;AXObjectCache.h&quot;
  29 #if PLATFORM(IOS_FAMILY)
  30 #include &quot;ContentChangeObserver.h&quot;
  31 #endif
  32 #include &quot;ContentData.h&quot;
  33 #include &quot;CursorList.h&quot;
  34 #include &quot;ElementChildIterator.h&quot;
  35 #include &quot;EventHandler.h&quot;
  36 #include &quot;FocusController.h&quot;
  37 #include &quot;Frame.h&quot;
  38 #include &quot;FrameSelection.h&quot;
  39 #include &quot;HTMLAnchorElement.h&quot;
  40 #include &quot;HTMLBodyElement.h&quot;
  41 #include &quot;HTMLHtmlElement.h&quot;
  42 #include &quot;HTMLImageElement.h&quot;
  43 #include &quot;HTMLNames.h&quot;
  44 #include &quot;LengthFunctions.h&quot;
  45 #include &quot;Logging.h&quot;
  46 #include &quot;Page.h&quot;
  47 #include &quot;PathUtilities.h&quot;
  48 #include &quot;RenderBlock.h&quot;
  49 #include &quot;RenderChildIterator.h&quot;
  50 #include &quot;RenderCounter.h&quot;
  51 #include &quot;RenderDeprecatedFlexibleBox.h&quot;
  52 #include &quot;RenderDescendantIterator.h&quot;
  53 #include &quot;RenderFlexibleBox.h&quot;
  54 #include &quot;RenderFragmentedFlow.h&quot;
  55 #include &quot;RenderGrid.h&quot;
  56 #include &quot;RenderImage.h&quot;
  57 #include &quot;RenderImageResourceStyleImage.h&quot;
  58 #include &quot;RenderInline.h&quot;
  59 #include &quot;RenderIterator.h&quot;
  60 #include &quot;RenderLayer.h&quot;
  61 #include &quot;RenderLayerCompositor.h&quot;
  62 #include &quot;RenderLineBreak.h&quot;
  63 #include &quot;RenderListItem.h&quot;
  64 #if !ASSERT_DISABLED
  65 #include &quot;RenderListMarker.h&quot;
  66 #endif
  67 #include &quot;RenderFragmentContainer.h&quot;
  68 #include &quot;RenderTableCaption.h&quot;
  69 #include &quot;RenderTableCell.h&quot;
  70 #include &quot;RenderTableCol.h&quot;
  71 #include &quot;RenderTableRow.h&quot;
  72 #include &quot;RenderText.h&quot;
  73 #include &quot;RenderTheme.h&quot;
  74 #include &quot;RenderTreeBuilder.h&quot;
  75 #include &quot;RenderView.h&quot;
  76 #include &quot;SVGImage.h&quot;
  77 #include &quot;SVGRenderSupport.h&quot;
  78 #include &quot;Settings.h&quot;
  79 #include &quot;ShadowRoot.h&quot;
  80 #include &quot;StylePendingResources.h&quot;
  81 #include &quot;StyleResolver.h&quot;
  82 #include &quot;TextAutoSizing.h&quot;
  83 #include &lt;wtf/IsoMallocInlines.h&gt;
  84 #include &lt;wtf/MathExtras.h&gt;
  85 #include &lt;wtf/StackStats.h&gt;
  86 
  87 namespace WebCore {
  88 
  89 WTF_MAKE_ISO_ALLOCATED_IMPL(RenderElement);
  90 
  91 struct SameSizeAsRenderElement : public RenderObject {
  92     unsigned bitfields : 25;
  93     void* firstChild;
  94     void* lastChild;
  95     RenderStyle style;
  96 };
  97 
  98 static_assert(sizeof(RenderElement) == sizeof(SameSizeAsRenderElement), &quot;RenderElement should stay small&quot;);
  99 
 100 inline RenderElement::RenderElement(ContainerNode&amp; elementOrDocument, RenderStyle&amp;&amp; style, BaseTypeFlags baseTypeFlags)
 101     : RenderObject(elementOrDocument)
 102     , m_baseTypeFlags(baseTypeFlags)
 103     , m_ancestorLineBoxDirty(false)
 104     , m_hasInitializedStyle(false)
 105     , m_renderInlineAlwaysCreatesLineBoxes(false)
 106     , m_renderBoxNeedsLazyRepaint(false)
 107     , m_hasPausedImageAnimations(false)
 108     , m_hasCounterNodeMap(false)
 109     , m_hasContinuationChainNode(false)
 110     , m_isContinuation(false)
 111     , m_isFirstLetter(false)
 112     , m_hasValidCachedFirstLineStyle(false)
 113     , m_renderBlockHasMarginBeforeQuirk(false)
 114     , m_renderBlockHasMarginAfterQuirk(false)
 115     , m_renderBlockShouldForceRelayoutChildren(false)
 116     , m_renderBlockFlowHasMarkupTruncation(false)
 117     , m_renderBlockFlowLineLayoutPath(RenderBlockFlow::UndeterminedPath)
 118     , m_isRegisteredForVisibleInViewportCallback(false)
 119     , m_visibleInViewportState(static_cast&lt;unsigned&gt;(VisibleInViewportState::Unknown))
 120     , m_firstChild(nullptr)
 121     , m_lastChild(nullptr)
 122     , m_style(WTFMove(style))
 123 {
 124 }
 125 
 126 RenderElement::RenderElement(Element&amp; element, RenderStyle&amp;&amp; style, BaseTypeFlags baseTypeFlags)
 127     : RenderElement(static_cast&lt;ContainerNode&amp;&gt;(element), WTFMove(style), baseTypeFlags)
 128 {
 129 }
 130 
 131 RenderElement::RenderElement(Document&amp; document, RenderStyle&amp;&amp; style, BaseTypeFlags baseTypeFlags)
 132     : RenderElement(static_cast&lt;ContainerNode&amp;&gt;(document), WTFMove(style), baseTypeFlags)
 133 {
 134 }
 135 
 136 RenderElement::~RenderElement()
 137 {
 138     // Do not add any code here. Add it to willBeDestroyed() instead.
 139     ASSERT(!m_firstChild);
 140 }
 141 
 142 RenderPtr&lt;RenderElement&gt; RenderElement::createFor(Element&amp; element, RenderStyle&amp;&amp; style, RendererCreationType creationType)
 143 {
 144     // Minimal support for content properties replacing an entire element.
 145     // Works only if we have exactly one piece of content and it&#39;s a URL.
 146     // Otherwise acts as if we didn&#39;t support this feature.
 147     const ContentData* contentData = style.contentData();
 148     if (creationType == CreateAllRenderers &amp;&amp; contentData &amp;&amp; !contentData-&gt;next() &amp;&amp; is&lt;ImageContentData&gt;(*contentData) &amp;&amp; !element.isPseudoElement()) {
 149         Style::loadPendingResources(style, element.document(), &amp;element);
 150         auto&amp; styleImage = downcast&lt;ImageContentData&gt;(*contentData).image();
 151         auto image = createRenderer&lt;RenderImage&gt;(element, WTFMove(style), const_cast&lt;StyleImage*&gt;(&amp;styleImage));
 152         image-&gt;setIsGeneratedContent();
 153         return image;
 154     }
 155 
 156     switch (style.display()) {
 157     case DisplayType::None:
 158     case DisplayType::Contents:
 159         return nullptr;
 160     case DisplayType::Inline:
 161         if (creationType == CreateAllRenderers)
 162             return createRenderer&lt;RenderInline&gt;(element, WTFMove(style));
 163         FALLTHROUGH; // Fieldsets should make a block flow if display:inline is set.
 164     case DisplayType::Block:
 165     case DisplayType::FlowRoot:
 166     case DisplayType::InlineBlock:
 167     case DisplayType::Compact:
 168         return createRenderer&lt;RenderBlockFlow&gt;(element, WTFMove(style));
 169     case DisplayType::ListItem:
 170         return createRenderer&lt;RenderListItem&gt;(element, WTFMove(style));
 171     case DisplayType::Flex:
 172     case DisplayType::InlineFlex:
 173     case DisplayType::WebKitFlex:
 174     case DisplayType::WebKitInlineFlex:
 175         return createRenderer&lt;RenderFlexibleBox&gt;(element, WTFMove(style));
 176     case DisplayType::Grid:
 177     case DisplayType::InlineGrid:
 178         return createRenderer&lt;RenderGrid&gt;(element, WTFMove(style));
 179     case DisplayType::Box:
 180     case DisplayType::InlineBox:
 181         return createRenderer&lt;RenderDeprecatedFlexibleBox&gt;(element, WTFMove(style));
 182     default: {
 183         if (creationType == OnlyCreateBlockAndFlexboxRenderers)
 184             return createRenderer&lt;RenderBlockFlow&gt;(element, WTFMove(style));
 185         switch (style.display()) {
 186         case DisplayType::Table:
 187         case DisplayType::InlineTable:
 188             return createRenderer&lt;RenderTable&gt;(element, WTFMove(style));
 189         case DisplayType::TableCell:
 190             return createRenderer&lt;RenderTableCell&gt;(element, WTFMove(style));
 191         case DisplayType::TableCaption:
 192             return createRenderer&lt;RenderTableCaption&gt;(element, WTFMove(style));
 193         case DisplayType::TableRowGroup:
 194         case DisplayType::TableHeaderGroup:
 195         case DisplayType::TableFooterGroup:
 196             return createRenderer&lt;RenderTableSection&gt;(element, WTFMove(style));
 197         case DisplayType::TableRow:
 198             return createRenderer&lt;RenderTableRow&gt;(element, WTFMove(style));
 199         case DisplayType::TableColumnGroup:
 200         case DisplayType::TableColumn:
 201             return createRenderer&lt;RenderTableCol&gt;(element, WTFMove(style));
 202         default:
 203             break;
 204         }
 205         break;
 206     }
 207     }
 208     ASSERT_NOT_REACHED();
 209     return nullptr;
 210 }
 211 
 212 std::unique_ptr&lt;RenderStyle&gt; RenderElement::computeFirstLineStyle() const
 213 {
 214     ASSERT(view().usesFirstLineRules());
 215 
 216     RenderElement&amp; rendererForFirstLineStyle = isBeforeOrAfterContent() ? *parent() : const_cast&lt;RenderElement&amp;&gt;(*this);
 217 
 218     if (rendererForFirstLineStyle.isRenderBlockFlow() || rendererForFirstLineStyle.isRenderButton()) {
 219         RenderBlock* firstLineBlock = rendererForFirstLineStyle.firstLineBlock();
 220         if (!firstLineBlock)
 221             return nullptr;
 222         auto* firstLineStyle = firstLineBlock-&gt;getCachedPseudoStyle(PseudoId::FirstLine, &amp;style());
 223         if (!firstLineStyle)
 224             return nullptr;
 225         return RenderStyle::clonePtr(*firstLineStyle);
 226     }
 227 
 228     if (!rendererForFirstLineStyle.isRenderInline())
 229         return nullptr;
 230 
 231     auto&amp; parentStyle = rendererForFirstLineStyle.parent()-&gt;firstLineStyle();
 232     if (&amp;parentStyle == &amp;rendererForFirstLineStyle.parent()-&gt;style())
 233         return nullptr;
 234 
 235     if (rendererForFirstLineStyle.isAnonymous()) {
 236         auto* textRendererWithDisplayContentsParent = RenderText::findByDisplayContentsInlineWrapperCandidate(rendererForFirstLineStyle);
 237         if (!textRendererWithDisplayContentsParent)
 238             return nullptr;
 239         auto* composedTreeParentElement = textRendererWithDisplayContentsParent-&gt;textNode()-&gt;parentElementInComposedTree();
 240         if (!composedTreeParentElement)
 241             return nullptr;
 242 
 243         auto style = composedTreeParentElement-&gt;styleResolver().styleForElement(*composedTreeParentElement, &amp;parentStyle).renderStyle;
 244         ASSERT(style-&gt;display() == DisplayType::Contents);
 245 
 246         // We act as if there was an unstyled &lt;span&gt; around the text node. Only styling happens via inheritance.
 247         auto firstLineStyle = RenderStyle::createPtr();
 248         firstLineStyle-&gt;inheritFrom(*style);
 249         return firstLineStyle;
 250     }
 251 
 252     return rendererForFirstLineStyle.element()-&gt;styleResolver().styleForElement(*element(), &amp;parentStyle).renderStyle;
 253 }
 254 
 255 const RenderStyle&amp; RenderElement::firstLineStyle() const
 256 {
 257     if (!view().usesFirstLineRules())
 258         return style();
 259 
 260     if (!m_hasValidCachedFirstLineStyle) {
 261         auto firstLineStyle = computeFirstLineStyle();
 262         if (firstLineStyle || hasRareData())
 263             const_cast&lt;RenderElement&amp;&gt;(*this).ensureRareData().cachedFirstLineStyle = WTFMove(firstLineStyle);
 264         m_hasValidCachedFirstLineStyle = true;
 265     }
 266 
 267     return (hasRareData() &amp;&amp; rareData().cachedFirstLineStyle) ? *rareData().cachedFirstLineStyle : style();
 268 }
 269 
 270 StyleDifference RenderElement::adjustStyleDifference(StyleDifference diff, OptionSet&lt;StyleDifferenceContextSensitiveProperty&gt; contextSensitiveProperties) const
 271 {
 272     // If transform changed, and we are not composited, need to do a layout.
 273     if (contextSensitiveProperties &amp; StyleDifferenceContextSensitiveProperty::Transform) {
 274         // FIXME: when transforms are taken into account for overflow, we will need to do a layout.
 275         if (!hasLayer() || !downcast&lt;RenderLayerModelObject&gt;(*this).layer()-&gt;isComposited()) {
 276             if (!hasLayer())
 277                 diff = std::max(diff, StyleDifference::Layout);
 278             else {
 279                 // We need to set at least SimplifiedLayout, but if PositionedMovementOnly is already set
 280                 // then we actually need SimplifiedLayoutAndPositionedMovement.
 281                 diff = std::max(diff, (diff == StyleDifference::LayoutPositionedMovementOnly) ? StyleDifference::SimplifiedLayoutAndPositionedMovement : StyleDifference::SimplifiedLayout);
 282             }
 283 
 284         } else
 285             diff = std::max(diff, StyleDifference::RecompositeLayer);
 286     }
 287 
 288     if (contextSensitiveProperties &amp; StyleDifferenceContextSensitiveProperty::Opacity) {
 289         if (!hasLayer() || !downcast&lt;RenderLayerModelObject&gt;(*this).layer()-&gt;isComposited())
 290             diff = std::max(diff, StyleDifference::RepaintLayer);
 291         else
 292             diff = std::max(diff, StyleDifference::RecompositeLayer);
 293     }
 294 
 295     if (contextSensitiveProperties &amp; StyleDifferenceContextSensitiveProperty::ClipPath) {
 296         if (hasLayer()
 297             &amp;&amp; downcast&lt;RenderLayerModelObject&gt;(*this).layer()-&gt;isComposited()
 298             &amp;&amp; hasClipPath()
 299             &amp;&amp; RenderLayerCompositor::canCompositeClipPath(*downcast&lt;RenderLayerModelObject&gt;(*this).layer()))
 300             diff = std::max(diff, StyleDifference::RecompositeLayer);
 301         else
 302             diff = std::max(diff, StyleDifference::Repaint);
 303     }
 304 
 305     if (contextSensitiveProperties &amp; StyleDifferenceContextSensitiveProperty::WillChange) {
 306         if (style().willChange() &amp;&amp; style().willChange()-&gt;canTriggerCompositing())
 307             diff = std::max(diff, StyleDifference::RecompositeLayer);
 308     }
 309 
 310     if ((contextSensitiveProperties &amp; StyleDifferenceContextSensitiveProperty::Filter) &amp;&amp; hasLayer()) {
 311         auto&amp; layer = *downcast&lt;RenderLayerModelObject&gt;(*this).layer();
 312         if (!layer.isComposited() || layer.paintsWithFilters())
 313             diff = std::max(diff, StyleDifference::RepaintLayer);
 314         else
 315             diff = std::max(diff, StyleDifference::RecompositeLayer);
 316     }
 317 
 318     // The answer to requiresLayer() for plugins, iframes, and canvas can change without the actual
 319     // style changing, since it depends on whether we decide to composite these elements. When the
 320     // layer status of one of these elements changes, we need to force a layout.
 321     if (diff &lt; StyleDifference::Layout &amp;&amp; isRenderLayerModelObject()) {
 322         if (hasLayer() != downcast&lt;RenderLayerModelObject&gt;(*this).requiresLayer())
 323             diff = StyleDifference::Layout;
 324     }
 325 
 326     // If we have no layer(), just treat a RepaintLayer hint as a normal Repaint.
 327     if (diff == StyleDifference::RepaintLayer &amp;&amp; !hasLayer())
 328         diff = StyleDifference::Repaint;
 329 
 330     return diff;
 331 }
 332 
 333 inline bool RenderElement::hasImmediateNonWhitespaceTextChildOrBorderOrOutline() const
 334 {
 335     for (auto&amp; child : childrenOfType&lt;RenderObject&gt;(*this)) {
 336         if (is&lt;RenderText&gt;(child) &amp;&amp; !downcast&lt;RenderText&gt;(child).isAllCollapsibleWhitespace())
 337             return true;
 338         if (child.style().hasOutline() || child.style().hasBorder())
 339             return true;
 340     }
 341     return false;
 342 }
 343 
 344 inline bool RenderElement::shouldRepaintForStyleDifference(StyleDifference diff) const
 345 {
 346     return diff == StyleDifference::Repaint || (diff == StyleDifference::RepaintIfTextOrBorderOrOutline &amp;&amp; hasImmediateNonWhitespaceTextChildOrBorderOrOutline());
 347 }
 348 
 349 void RenderElement::updateFillImages(const FillLayer* oldLayers, const FillLayer&amp; newLayers)
 350 {
 351     // Optimize the common case.
 352     if (FillLayer::imagesIdentical(oldLayers, &amp;newLayers))
 353         return;
 354 
 355     // Add before removing, to avoid removing all clients of an image that is in both sets.
 356     for (auto* layer = &amp;newLayers; layer; layer = layer-&gt;next()) {
 357         if (layer-&gt;image())
 358             layer-&gt;image()-&gt;addClient(this);
 359     }
 360     for (auto* layer = oldLayers; layer; layer = layer-&gt;next()) {
 361         if (layer-&gt;image())
 362             layer-&gt;image()-&gt;removeClient(this);
 363     }
 364 }
 365 
 366 void RenderElement::updateImage(StyleImage* oldImage, StyleImage* newImage)
 367 {
 368     if (oldImage == newImage)
 369         return;
 370     if (oldImage)
 371         oldImage-&gt;removeClient(this);
 372     if (newImage)
 373         newImage-&gt;addClient(this);
 374 }
 375 
 376 void RenderElement::updateShapeImage(const ShapeValue* oldShapeValue, const ShapeValue* newShapeValue)
 377 {
 378     if (oldShapeValue || newShapeValue)
 379         updateImage(oldShapeValue ? oldShapeValue-&gt;image() : nullptr, newShapeValue ? newShapeValue-&gt;image() : nullptr);
 380 }
 381 
 382 void RenderElement::initializeStyle()
 383 {
 384     Style::loadPendingResources(m_style, document(), element());
 385 
 386     styleWillChange(StyleDifference::NewStyle, style());
 387     m_hasInitializedStyle = true;
 388     styleDidChange(StyleDifference::NewStyle, nullptr);
 389 
 390     // We shouldn&#39;t have any text children that would need styleDidChange at this point.
 391     ASSERT(!childrenOfType&lt;RenderText&gt;(*this).first());
 392 
 393     // It would be nice to assert that !parent() here, but some RenderLayer subrenderers
 394     // have their parent set before getting a call to initializeStyle() :|
 395 }
 396 
 397 void RenderElement::setStyle(RenderStyle&amp;&amp; style, StyleDifference minimalStyleDifference)
 398 {
 399     // FIXME: Should change RenderView so it can use initializeStyle too.
 400     // If we do that, we can assert m_hasInitializedStyle unconditionally,
 401     // and remove the check of m_hasInitializedStyle below too.
 402     ASSERT(m_hasInitializedStyle || isRenderView());
 403 
 404     StyleDifference diff = StyleDifference::Equal;
 405     OptionSet&lt;StyleDifferenceContextSensitiveProperty&gt; contextSensitiveProperties;
 406     if (m_hasInitializedStyle)
 407         diff = m_style.diff(style, contextSensitiveProperties);
 408 
 409     diff = std::max(diff, minimalStyleDifference);
 410 
 411     diff = adjustStyleDifference(diff, contextSensitiveProperties);
 412 
 413     Style::loadPendingResources(style, document(), element());
 414 
 415     styleWillChange(diff, style);
 416     auto oldStyle = m_style.replace(WTFMove(style));
 417     bool detachedFromParent = !parent();
 418 
 419     // Make sure we invalidate the containing block cache for flows when the contianing block context changes
 420     // so that styleDidChange can safely use RenderBlock::locateEnclosingFragmentedFlow()
 421     if (oldStyle.position() != m_style.position())
 422         adjustFragmentedFlowStateOnContainingBlockChangeIfNeeded();
 423 
 424     styleDidChange(diff, &amp;oldStyle);
 425 
 426     // Text renderers use their parent style. Notify them about the change.
 427     for (auto&amp; child : childrenOfType&lt;RenderText&gt;(*this))
 428         child.styleDidChange(diff, &amp;oldStyle);
 429 
 430     // FIXME: |this| might be destroyed here. This can currently happen for a RenderTextFragment when
 431     // its first-letter block gets an update in RenderTextFragment::styleDidChange. For RenderTextFragment(s),
 432     // we will safely bail out with the detachedFromParent flag. We might want to broaden this condition
 433     // in the future as we move renderer changes out of layout and into style changes.
 434     if (detachedFromParent)
 435         return;
 436 
 437     // Now that the layer (if any) has been updated, we need to adjust the diff again,
 438     // check whether we should layout now, and decide if we need to repaint.
 439     StyleDifference updatedDiff = adjustStyleDifference(diff, contextSensitiveProperties);
 440 
 441     if (diff &lt;= StyleDifference::LayoutPositionedMovementOnly) {
 442         if (updatedDiff == StyleDifference::Layout)
 443             setNeedsLayoutAndPrefWidthsRecalc();
 444         else if (updatedDiff == StyleDifference::LayoutPositionedMovementOnly)
 445             setNeedsPositionedMovementLayout(&amp;oldStyle);
 446         else if (updatedDiff == StyleDifference::SimplifiedLayoutAndPositionedMovement) {
 447             setNeedsPositionedMovementLayout(&amp;oldStyle);
 448             setNeedsSimplifiedNormalFlowLayout();
 449         } else if (updatedDiff == StyleDifference::SimplifiedLayout)
 450             setNeedsSimplifiedNormalFlowLayout();
 451     }
 452 
 453     if (updatedDiff == StyleDifference::RepaintLayer || shouldRepaintForStyleDifference(updatedDiff)) {
 454         // Do a repaint with the new style now, e.g., for example if we go from
 455         // not having an outline to having an outline.
 456         repaint();
 457     }
 458 }
 459 
 460 void RenderElement::didAttachChild(RenderObject&amp; child, RenderObject*)
 461 {
 462     if (is&lt;RenderText&gt;(child))
 463         downcast&lt;RenderText&gt;(child).styleDidChange(StyleDifference::Equal, nullptr);
 464     // SVG creates renderers for &lt;g display=&quot;none&quot;&gt;, as SVG requires children of hidden
 465     // &lt;g&gt;s to have renderers - at least that&#39;s how our implementation works. Consider:
 466     // &lt;g display=&quot;none&quot;&gt;&lt;foreignObject&gt;&lt;body style=&quot;position: relative&quot;&gt;FOO...
 467     // - requiresLayer() would return true for the &lt;body&gt;, creating a new RenderLayer
 468     // - when the document is painted, both layers are painted. The &lt;body&gt; layer doesn&#39;t
 469     //   know that it&#39;s inside a &quot;hidden SVG subtree&quot;, and thus paints, even if it shouldn&#39;t.
 470     // To avoid the problem alltogether, detect early if we&#39;re inside a hidden SVG subtree
 471     // and stop creating layers at all for these cases - they&#39;re not used anyways.
 472     if (child.hasLayer() &amp;&amp; !layerCreationAllowedForSubtree())
 473         downcast&lt;RenderLayerModelObject&gt;(child).layer()-&gt;removeOnlyThisLayer();
 474 }
 475 
 476 RenderObject* RenderElement::attachRendererInternal(RenderPtr&lt;RenderObject&gt; child, RenderObject* beforeChild)
 477 {
 478     child-&gt;setParent(this);
 479 
 480     if (m_firstChild == beforeChild)
 481         m_firstChild = child.get();
 482 
 483     if (beforeChild) {
 484         auto* previousSibling = beforeChild-&gt;previousSibling();
 485         if (previousSibling)
 486             previousSibling-&gt;setNextSibling(child.get());
 487         child-&gt;setPreviousSibling(previousSibling);
 488         child-&gt;setNextSibling(beforeChild);
 489         beforeChild-&gt;setPreviousSibling(child.get());
 490         return child.release();
 491     }
 492     if (m_lastChild)
 493         m_lastChild-&gt;setNextSibling(child.get());
 494     child-&gt;setPreviousSibling(m_lastChild);
 495     m_lastChild = child.get();
 496     return child.release();
 497 }
 498 
 499 RenderPtr&lt;RenderObject&gt; RenderElement::detachRendererInternal(RenderObject&amp; renderer)
 500 {
 501     auto* parent = renderer.parent();
 502     ASSERT(parent);
 503     auto* nextSibling = renderer.nextSibling();
 504 
 505     if (renderer.previousSibling())
 506         renderer.previousSibling()-&gt;setNextSibling(nextSibling);
 507     if (nextSibling)
 508         nextSibling-&gt;setPreviousSibling(renderer.previousSibling());
 509 
 510     if (parent-&gt;firstChild() == &amp;renderer)
 511         parent-&gt;m_firstChild = nextSibling;
 512     if (parent-&gt;lastChild() == &amp;renderer)
 513         parent-&gt;m_lastChild = renderer.previousSibling();
 514 
 515     renderer.setPreviousSibling(nullptr);
 516     renderer.setNextSibling(nullptr);
 517     renderer.setParent(nullptr);
 518     return RenderPtr&lt;RenderObject&gt;(&amp;renderer);
 519 }
 520 
 521 RenderBlock* RenderElement::containingBlockForFixedPosition() const
 522 {
 523     auto* renderer = parent();
 524     while (renderer &amp;&amp; !renderer-&gt;canContainFixedPositionObjects())
 525         renderer = renderer-&gt;parent();
 526 
 527     ASSERT(!renderer || !renderer-&gt;isAnonymousBlock());
 528     return downcast&lt;RenderBlock&gt;(renderer);
 529 }
 530 
 531 RenderBlock* RenderElement::containingBlockForAbsolutePosition() const
 532 {
 533     // A relatively positioned RenderInline forwards its absolute positioned descendants to
 534     // its nearest non-anonymous containing block (to avoid having a positioned objects list in all RenderInlines).
 535     auto* renderer = isRenderInline() ? const_cast&lt;RenderElement*&gt;(downcast&lt;RenderElement&gt;(this)) : parent();
 536     while (renderer &amp;&amp; !renderer-&gt;canContainAbsolutelyPositionedObjects())
 537         renderer = renderer-&gt;parent();
 538     // Make sure we only return non-anonymous RenderBlock as containing block.
 539     while (renderer &amp;&amp; (!is&lt;RenderBlock&gt;(*renderer) || renderer-&gt;isAnonymousBlock()))
 540         renderer = renderer-&gt;containingBlock();
 541     return downcast&lt;RenderBlock&gt;(renderer);
 542 }
 543 
 544 static void addLayers(RenderElement&amp; renderer, RenderLayer* parentLayer, RenderElement*&amp; newObject, RenderLayer*&amp; beforeChild)
 545 {
 546     if (renderer.hasLayer()) {
 547         if (!beforeChild &amp;&amp; newObject) {
 548             // We need to figure out the layer that follows newObject. We only do
 549             // this the first time we find a child layer, and then we update the
 550             // pointer values for newObject and beforeChild used by everyone else.
 551             beforeChild = newObject-&gt;parent()-&gt;findNextLayer(parentLayer, newObject);
 552             newObject = nullptr;
 553         }
 554         parentLayer-&gt;addChild(*downcast&lt;RenderLayerModelObject&gt;(renderer).layer(), beforeChild);
 555         return;
 556     }
 557 
 558     for (auto&amp; child : childrenOfType&lt;RenderElement&gt;(renderer))
 559         addLayers(child, parentLayer, newObject, beforeChild);
 560 }
 561 
 562 void RenderElement::addLayers(RenderLayer* parentLayer)
 563 {
 564     if (!parentLayer)
 565         return;
 566 
 567     RenderElement* renderer = this;
 568     RenderLayer* beforeChild = nullptr;
 569     WebCore::addLayers(*this, parentLayer, renderer, beforeChild);
 570 }
 571 
 572 void RenderElement::removeLayers(RenderLayer* parentLayer)
 573 {
 574     if (!parentLayer)
 575         return;
 576 
 577     if (hasLayer()) {
 578         parentLayer-&gt;removeChild(*downcast&lt;RenderLayerModelObject&gt;(*this).layer());
 579         return;
 580     }
 581 
 582     for (auto&amp; child : childrenOfType&lt;RenderElement&gt;(*this))
 583         child.removeLayers(parentLayer);
 584 }
 585 
 586 void RenderElement::moveLayers(RenderLayer* oldParent, RenderLayer* newParent)
 587 {
 588     if (!newParent)
 589         return;
 590 
 591     if (hasLayer()) {
 592         RenderLayer* layer = downcast&lt;RenderLayerModelObject&gt;(*this).layer();
 593         ASSERT(oldParent == layer-&gt;parent());
 594         if (oldParent)
 595             oldParent-&gt;removeChild(*layer);
 596         newParent-&gt;addChild(*layer);
 597         return;
 598     }
 599 
 600     for (auto&amp; child : childrenOfType&lt;RenderElement&gt;(*this))
 601         child.moveLayers(oldParent, newParent);
 602 }
 603 
 604 RenderLayer* RenderElement::findNextLayer(RenderLayer* parentLayer, RenderObject* startPoint, bool checkParent)
 605 {
 606     // Error check the parent layer passed in. If it&#39;s null, we can&#39;t find anything.
 607     if (!parentLayer)
 608         return nullptr;
 609 
 610     // Step 1: If our layer is a child of the desired parent, then return our layer.
 611     RenderLayer* ourLayer = hasLayer() ? downcast&lt;RenderLayerModelObject&gt;(*this).layer() : nullptr;
 612     if (ourLayer &amp;&amp; ourLayer-&gt;parent() == parentLayer)
 613         return ourLayer;
 614 
 615     // Step 2: If we don&#39;t have a layer, or our layer is the desired parent, then descend
 616     // into our siblings trying to find the next layer whose parent is the desired parent.
 617     if (!ourLayer || ourLayer == parentLayer) {
 618         for (RenderObject* child = startPoint ? startPoint-&gt;nextSibling() : firstChild(); child; child = child-&gt;nextSibling()) {
 619             if (!is&lt;RenderElement&gt;(*child))
 620                 continue;
 621             RenderLayer* nextLayer = downcast&lt;RenderElement&gt;(*child).findNextLayer(parentLayer, nullptr, false);
 622             if (nextLayer)
 623                 return nextLayer;
 624         }
 625     }
 626 
 627     // Step 3: If our layer is the desired parent layer, then we&#39;re finished. We didn&#39;t
 628     // find anything.
 629     if (parentLayer == ourLayer)
 630         return nullptr;
 631 
 632     // Step 4: If |checkParent| is set, climb up to our parent and check its siblings that
 633     // follow us to see if we can locate a layer.
 634     if (checkParent &amp;&amp; parent())
 635         return parent()-&gt;findNextLayer(parentLayer, this, true);
 636 
 637     return nullptr;
 638 }
 639 
 640 bool RenderElement::layerCreationAllowedForSubtree() const
 641 {
 642     RenderElement* parentRenderer = parent();
 643     while (parentRenderer) {
 644         if (parentRenderer-&gt;isSVGHiddenContainer())
 645             return false;
 646         parentRenderer = parentRenderer-&gt;parent();
 647     }
 648 
 649     return true;
 650 }
 651 
 652 void RenderElement::propagateStyleToAnonymousChildren(StylePropagationType propagationType)
 653 {
 654     // FIXME: We could save this call when the change only affected non-inherited properties.
 655     for (auto&amp; elementChild : childrenOfType&lt;RenderElement&gt;(*this)) {
 656         if (!elementChild.isAnonymous() || elementChild.style().styleType() != PseudoId::None)
 657             continue;
 658 
 659         if (propagationType == PropagateToBlockChildrenOnly &amp;&amp; !is&lt;RenderBlock&gt;(elementChild))
 660             continue;
 661 
 662 #if ENABLE(FULLSCREEN_API)
 663         if (elementChild.isRenderFullScreen() || elementChild.isRenderFullScreenPlaceholder())
 664             continue;
 665 #endif
 666 
 667         // RenderFragmentedFlows are updated through the RenderView::styleDidChange function.
 668         if (is&lt;RenderFragmentedFlow&gt;(elementChild))
 669             continue;
 670 
 671         auto newStyle = RenderStyle::createAnonymousStyleWithDisplay(style(), elementChild.style().display());
 672         if (style().specifiesColumns()) {
 673             if (elementChild.style().specifiesColumns())
 674                 newStyle.inheritColumnPropertiesFrom(style());
 675             if (elementChild.style().columnSpan() == ColumnSpan::All)
 676                 newStyle.setColumnSpan(ColumnSpan::All);
 677         }
 678 
 679         // Preserve the position style of anonymous block continuations as they can have relative or sticky position when
 680         // they contain block descendants of relative or sticky positioned inlines.
 681         if (elementChild.isInFlowPositioned() &amp;&amp; elementChild.isContinuation())
 682             newStyle.setPosition(elementChild.style().position());
 683 
 684         updateAnonymousChildStyle(newStyle);
 685 
 686         elementChild.setStyle(WTFMove(newStyle));
 687     }
 688 }
 689 
 690 static inline bool rendererHasBackground(const RenderElement* renderer)
 691 {
 692     return renderer &amp;&amp; renderer-&gt;hasBackground();
 693 }
 694 
 695 void RenderElement::invalidateCachedFirstLineStyle()
 696 {
 697     if (!m_hasValidCachedFirstLineStyle)
 698         return;
 699     m_hasValidCachedFirstLineStyle = false;
 700     // Invalidate the subtree as descendant&#39;s first line style may depend on ancestor&#39;s.
 701     for (auto&amp; descendant : descendantsOfType&lt;RenderElement&gt;(*this))
 702         descendant.m_hasValidCachedFirstLineStyle = false;
 703 }
 704 
 705 void RenderElement::styleWillChange(StyleDifference diff, const RenderStyle&amp; newStyle)
 706 {
 707     ASSERT(settings().shouldAllowUserInstalledFonts() || newStyle.fontDescription().shouldAllowUserInstalledFonts() == AllowUserInstalledFonts::No);
 708 
 709     auto* oldStyle = hasInitializedStyle() ? &amp;style() : nullptr;
 710     if (oldStyle) {
 711         // If our z-index changes value or our visibility changes,
 712         // we need to dirty our stacking context&#39;s z-order list.
 713         bool visibilityChanged = m_style.visibility() != newStyle.visibility()
 714             || m_style.zIndex() != newStyle.zIndex()
 715             || m_style.hasAutoZIndex() != newStyle.hasAutoZIndex();
 716 
 717         if (visibilityChanged)
 718             document().invalidateRenderingDependentRegions();
 719 
 720         if (visibilityChanged) {
 721             if (AXObjectCache* cache = document().existingAXObjectCache())
 722                 cache-&gt;childrenChanged(parent(), this);
 723         }
 724 
 725         // Keep layer hierarchy visibility bits up to date if visibility changes.
 726         if (m_style.visibility() != newStyle.visibility()) {
 727             if (RenderLayer* layer = enclosingLayer()) {
 728                 if (newStyle.visibility() == Visibility::Visible)
 729                     layer-&gt;setHasVisibleContent();
 730                 else if (layer-&gt;hasVisibleContent() &amp;&amp; (this == &amp;layer-&gt;renderer() || layer-&gt;renderer().style().visibility() != Visibility::Visible)) {
 731                     layer-&gt;dirtyVisibleContentStatus();
 732                     if (diff &gt; StyleDifference::RepaintLayer)
 733                         repaint();
 734                 }
 735             }
 736         }
 737 
 738         auto needsInvalidateEventRegion = [&amp;] {
 739             if (m_style.pointerEvents() != newStyle.pointerEvents())
 740                 return true;
 741 #if ENABLE(POINTER_EVENTS)
 742             if (m_style.effectiveTouchActions() != newStyle.effectiveTouchActions())
 743                 return true;
 744 #endif
 745             return false;
 746         };
 747 
 748         if (needsInvalidateEventRegion()) {
 749             // Usually the event region gets updated as a result of paint invalidation. Here we need to request an update explicitly.
 750             if (auto* layer = enclosingLayer())
 751                 layer-&gt;invalidateEventRegion();
 752         }
 753 
 754         if (m_parent &amp;&amp; (newStyle.outlineSize() &lt; m_style.outlineSize() || shouldRepaintForStyleDifference(diff)))
 755             repaint();
 756 
 757         if (isFloating() &amp;&amp; m_style.floating() != newStyle.floating()) {
 758             // For changes in float styles, we need to conceivably remove ourselves
 759             // from the floating objects list.
 760             downcast&lt;RenderBox&gt;(*this).removeFloatingOrPositionedChildFromBlockLists();
 761         } else if (isOutOfFlowPositioned() &amp;&amp; m_style.position() != newStyle.position()) {
 762             // For changes in positioning styles, we need to conceivably remove ourselves
 763             // from the positioned objects list.
 764             downcast&lt;RenderBox&gt;(*this).removeFloatingOrPositionedChildFromBlockLists();
 765         }
 766 
 767         // reset style flags
 768         if (diff == StyleDifference::Layout || diff == StyleDifference::LayoutPositionedMovementOnly) {
 769             setFloating(false);
 770             clearPositionedState();
 771         }
 772 
 773         if (newStyle.hasPseudoStyle(PseudoId::FirstLine) || oldStyle-&gt;hasPseudoStyle(PseudoId::FirstLine))
 774             invalidateCachedFirstLineStyle();
 775 
 776         setHorizontalWritingMode(true);
 777         setHasVisibleBoxDecorations(false);
 778         setHasOverflowClip(false);
 779         setHasTransformRelatedProperty(false);
 780         setHasReflection(false);
 781     }
 782 
 783     bool hadOutline = oldStyle &amp;&amp; oldStyle-&gt;hasOutline();
 784     bool hasOutline = newStyle.hasOutline();
 785     if (hadOutline != hasOutline) {
 786         if (hasOutline)
 787             view().incrementRendersWithOutline();
 788         else
 789             view().decrementRendersWithOutline();
 790     }
 791 
 792     bool newStyleSlowScroll = false;
 793     if (newStyle.hasFixedBackgroundImage() &amp;&amp; !settings().fixedBackgroundsPaintRelativeToDocument()) {
 794         newStyleSlowScroll = true;
 795         bool drawsRootBackground = isDocumentElementRenderer() || (isBody() &amp;&amp; !rendererHasBackground(document().documentElement()-&gt;renderer()));
 796         if (drawsRootBackground &amp;&amp; newStyle.hasEntirelyFixedBackground() &amp;&amp; view().compositor().supportsFixedRootBackgroundCompositing())
 797             newStyleSlowScroll = false;
 798     }
 799 
 800     if (view().frameView().hasSlowRepaintObject(*this)) {
 801         if (!newStyleSlowScroll)
 802             view().frameView().removeSlowRepaintObject(*this);
 803     } else if (newStyleSlowScroll)
 804         view().frameView().addSlowRepaintObject(*this);
 805 
 806     if (isDocumentElementRenderer() || isBody())
 807         view().frameView().updateExtendBackgroundIfNecessary();
 808 }
 809 
 810 #if !PLATFORM(IOS_FAMILY)
 811 static bool areNonIdenticalCursorListsEqual(const RenderStyle* a, const RenderStyle* b)
 812 {
 813     ASSERT(a-&gt;cursors() != b-&gt;cursors());
 814     return a-&gt;cursors() &amp;&amp; b-&gt;cursors() &amp;&amp; *a-&gt;cursors() == *b-&gt;cursors();
 815 }
 816 
 817 static inline bool areCursorsEqual(const RenderStyle* a, const RenderStyle* b)
 818 {
 819     return a-&gt;cursor() == b-&gt;cursor() &amp;&amp; (a-&gt;cursors() == b-&gt;cursors() || areNonIdenticalCursorListsEqual(a, b));
 820 }
 821 #endif
 822 
 823 void RenderElement::styleDidChange(StyleDifference diff, const RenderStyle* oldStyle)
 824 {
 825     updateFillImages(oldStyle ? &amp;oldStyle-&gt;backgroundLayers() : nullptr, m_style.backgroundLayers());
 826     updateFillImages(oldStyle ? &amp;oldStyle-&gt;maskLayers() : nullptr, m_style.maskLayers());
 827     updateImage(oldStyle ? oldStyle-&gt;borderImage().image() : nullptr, m_style.borderImage().image());
 828     updateImage(oldStyle ? oldStyle-&gt;maskBoxImage().image() : nullptr, m_style.maskBoxImage().image());
 829     updateShapeImage(oldStyle ? oldStyle-&gt;shapeOutside() : nullptr, m_style.shapeOutside());
 830 
 831     SVGRenderSupport::styleChanged(*this, oldStyle);
 832 
 833     if (!m_parent)
 834         return;
 835 
 836     if (diff == StyleDifference::Layout || diff == StyleDifference::SimplifiedLayout) {
 837         RenderCounter::rendererStyleChanged(*this, oldStyle, &amp;m_style);
 838 
 839         // If the object already needs layout, then setNeedsLayout won&#39;t do
 840         // any work. But if the containing block has changed, then we may need
 841         // to mark the new containing blocks for layout. The change that can
 842         // directly affect the containing block of this object is a change to
 843         // the position style.
 844         if (needsLayout() &amp;&amp; oldStyle-&gt;position() != m_style.position())
 845             markContainingBlocksForLayout();
 846 
 847         if (diff == StyleDifference::Layout)
 848             setNeedsLayoutAndPrefWidthsRecalc();
 849         else
 850             setNeedsSimplifiedNormalFlowLayout();
 851     } else if (diff == StyleDifference::SimplifiedLayoutAndPositionedMovement) {
 852         setNeedsPositionedMovementLayout(oldStyle);
 853         setNeedsSimplifiedNormalFlowLayout();
 854     } else if (diff == StyleDifference::LayoutPositionedMovementOnly)
 855         setNeedsPositionedMovementLayout(oldStyle);
 856 
 857     // Don&#39;t check for repaint here; we need to wait until the layer has been
 858     // updated by subclasses before we know if we have to repaint (in setStyle()).
 859 
 860 #if !PLATFORM(IOS_FAMILY)
 861     if (oldStyle &amp;&amp; !areCursorsEqual(oldStyle, &amp;style()))
 862         frame().eventHandler().scheduleCursorUpdate();
 863 #endif
 864 
 865     bool hadOutlineAuto = oldStyle &amp;&amp; oldStyle-&gt;outlineStyleIsAuto() == OutlineIsAuto::On;
 866     bool hasOutlineAuto = outlineStyleForRepaint().outlineStyleIsAuto() == OutlineIsAuto::On;
 867     if (hasOutlineAuto != hadOutlineAuto) {
 868         updateOutlineAutoAncestor(hasOutlineAuto);
 869         issueRepaintForOutlineAuto(hasOutlineAuto ? outlineStyleForRepaint().outlineSize() : oldStyle-&gt;outlineSize());
 870     }
 871 }
 872 
 873 void RenderElement::insertedIntoTree()
 874 {
 875     // Keep our layer hierarchy updated. Optimize for the common case where we don&#39;t have any children
 876     // and don&#39;t have a layer attached to ourselves.
 877     RenderLayer* layer = nullptr;
 878     if (firstChild() || hasLayer()) {
 879         layer = parent()-&gt;enclosingLayer();
 880         addLayers(layer);
 881     }
 882 
 883     // If |this| is visible but this object was not, tell the layer it has some visible content
 884     // that needs to be drawn and layer visibility optimization can&#39;t be used
 885     if (parent()-&gt;style().visibility() != Visibility::Visible &amp;&amp; style().visibility() == Visibility::Visible &amp;&amp; !hasLayer()) {
 886         if (!layer)
 887             layer = parent()-&gt;enclosingLayer();
 888         if (layer)
 889             layer-&gt;setHasVisibleContent();
 890     }
 891 
 892     RenderObject::insertedIntoTree();
 893 }
 894 
 895 void RenderElement::willBeRemovedFromTree()
 896 {
 897     // If we remove a visible child from an invisible parent, we don&#39;t know the layer visibility any more.
 898     RenderLayer* layer = nullptr;
 899     if (parent()-&gt;style().visibility() != Visibility::Visible &amp;&amp; style().visibility() == Visibility::Visible &amp;&amp; !hasLayer()) {
 900         if ((layer = parent()-&gt;enclosingLayer()))
 901             layer-&gt;dirtyVisibleContentStatus();
 902     }
 903     // Keep our layer hierarchy updated.
 904     if (firstChild() || hasLayer()) {
 905         if (!layer)
 906             layer = parent()-&gt;enclosingLayer();
 907         removeLayers(layer);
 908     }
 909 
 910     if (isOutOfFlowPositioned() &amp;&amp; parent()-&gt;childrenInline())
 911         parent()-&gt;dirtyLinesFromChangedChild(*this);
 912 
 913     RenderObject::willBeRemovedFromTree();
 914 }
 915 
 916 inline void RenderElement::clearSubtreeLayoutRootIfNeeded() const
 917 {
 918     if (renderTreeBeingDestroyed())
 919         return;
 920 
 921     if (view().frameView().layoutContext().subtreeLayoutRoot() != this)
 922         return;
 923 
 924     // Normally when a renderer is detached from the tree, the appropriate dirty bits get set
 925     // which ensures that this renderer is no longer the layout root.
 926     ASSERT_NOT_REACHED();
 927 
 928     // This indicates a failure to layout the child, which is why
 929     // the layout root is still set to |this|. Make sure to clear it
 930     // since we are getting destroyed.
 931     view().frameView().layoutContext().clearSubtreeLayoutRoot();
 932 }
 933 
 934 void RenderElement::willBeDestroyed()
 935 {
 936 #if PLATFORM(IOS_FAMILY)
 937     if (!renderTreeBeingDestroyed() &amp;&amp; element())
 938         document().contentChangeObserver().rendererWillBeDestroyed(*element());
 939 #endif
 940     if (m_style.hasFixedBackgroundImage() &amp;&amp; !settings().fixedBackgroundsPaintRelativeToDocument())
 941         view().frameView().removeSlowRepaintObject(*this);
 942 
 943     unregisterForVisibleInViewportCallback();
 944 
 945     if (hasCounterNodeMap())
 946         RenderCounter::destroyCounterNodes(*this);
 947 
 948     if (style().hasOutline())
 949         view().decrementRendersWithOutline();
 950 
 951     RenderObject::willBeDestroyed();
 952 
 953     clearSubtreeLayoutRootIfNeeded();
 954 
 955     if (hasInitializedStyle()) {
 956         for (auto* bgLayer = &amp;m_style.backgroundLayers(); bgLayer; bgLayer = bgLayer-&gt;next()) {
 957             if (auto* backgroundImage = bgLayer-&gt;image())
 958                 backgroundImage-&gt;removeClient(this);
 959         }
 960         for (auto* maskLayer = &amp;m_style.maskLayers(); maskLayer; maskLayer = maskLayer-&gt;next()) {
 961             if (auto* maskImage = maskLayer-&gt;image())
 962                 maskImage-&gt;removeClient(this);
 963         }
 964         if (auto* borderImage = m_style.borderImage().image())
 965             borderImage-&gt;removeClient(this);
 966         if (auto* maskBoxImage = m_style.maskBoxImage().image())
 967             maskBoxImage-&gt;removeClient(this);
 968         if (auto shapeValue = m_style.shapeOutside()) {
 969             if (auto shapeImage = shapeValue-&gt;image())
 970                 shapeImage-&gt;removeClient(this);
 971         }
 972     }
 973     if (m_hasPausedImageAnimations)
 974         view().removeRendererWithPausedImageAnimations(*this);
 975 }
 976 
 977 void RenderElement::setNeedsPositionedMovementLayout(const RenderStyle* oldStyle)
 978 {
 979     ASSERT(!isSetNeedsLayoutForbidden());
 980     if (needsPositionedMovementLayout())
 981         return;
 982     setNeedsPositionedMovementLayoutBit(true);
 983     markContainingBlocksForLayout();
 984     if (hasLayer()) {
 985         if (oldStyle &amp;&amp; style().diffRequiresLayerRepaint(*oldStyle, downcast&lt;RenderLayerModelObject&gt;(*this).layer()-&gt;isComposited()))
 986             setLayerNeedsFullRepaint();
 987         else
 988             setLayerNeedsFullRepaintForPositionedMovementLayout();
 989     }
 990 }
 991 
 992 void RenderElement::clearChildNeedsLayout()
 993 {
 994     setNormalChildNeedsLayoutBit(false);
 995     setPosChildNeedsLayoutBit(false);
 996     setNeedsSimplifiedNormalFlowLayoutBit(false);
 997     setNormalChildNeedsLayoutBit(false);
 998     setNeedsPositionedMovementLayoutBit(false);
 999 }
1000 
1001 void RenderElement::setNeedsSimplifiedNormalFlowLayout()
1002 {
1003     ASSERT(!isSetNeedsLayoutForbidden());
1004     if (needsSimplifiedNormalFlowLayout())
1005         return;
1006     setNeedsSimplifiedNormalFlowLayoutBit(true);
1007     markContainingBlocksForLayout();
1008     if (hasLayer())
1009         setLayerNeedsFullRepaint();
1010 }
1011 
1012 static inline void paintPhase(RenderElement&amp; element, PaintPhase phase, PaintInfo&amp; paintInfo, const LayoutPoint&amp; childPoint)
1013 {
1014     paintInfo.phase = phase;
1015     element.paint(paintInfo, childPoint);
1016 }
1017 
1018 void RenderElement::paintAsInlineBlock(PaintInfo&amp; paintInfo, const LayoutPoint&amp; childPoint)
1019 {
1020     // Paint all phases atomically, as though the element established its own stacking context.
1021     // (See Appendix E.2, section 6.4 on inline block/table/replaced elements in the CSS2.1 specification.)
1022     // This is also used by other elements (e.g. flex items and grid items).
1023     PaintPhase paintPhaseToUse = isExcludedAndPlacedInBorder() ? paintInfo.phase : PaintPhase::Foreground;
1024     if (paintInfo.phase == PaintPhase::Selection || paintInfo.phase == PaintPhase::EventRegion)
1025         paint(paintInfo, childPoint);
1026     else if (paintInfo.phase == paintPhaseToUse) {
1027         paintPhase(*this, PaintPhase::BlockBackground, paintInfo, childPoint);
1028         paintPhase(*this, PaintPhase::ChildBlockBackgrounds, paintInfo, childPoint);
1029         paintPhase(*this, PaintPhase::Float, paintInfo, childPoint);
1030         paintPhase(*this, PaintPhase::Foreground, paintInfo, childPoint);
1031         paintPhase(*this, PaintPhase::Outline, paintInfo, childPoint);
1032 
1033         // Reset |paintInfo| to the original phase.
1034         paintInfo.phase = paintPhaseToUse;
1035     }
1036 }
1037 
1038 void RenderElement::layout()
1039 {
1040     StackStats::LayoutCheckPoint layoutCheckPoint;
1041     ASSERT(needsLayout());
1042     for (auto* child = firstChild(); child; child = child-&gt;nextSibling()) {
1043         if (child-&gt;needsLayout())
1044             downcast&lt;RenderElement&gt;(*child).layout();
1045         ASSERT(!child-&gt;needsLayout());
1046     }
1047     clearNeedsLayout();
1048 }
1049 
1050 static bool mustRepaintFillLayers(const RenderElement&amp; renderer, const FillLayer&amp; layer)
1051 {
1052     // Nobody will use multiple layers without wanting fancy positioning.
1053     if (layer.next())
1054         return true;
1055 
1056     // Make sure we have a valid image.
1057     auto* image = layer.image();
1058     if (!image || !image-&gt;canRender(&amp;renderer, renderer.style().effectiveZoom()))
1059         return false;
1060 
1061     if (!layer.xPosition().isZero() || !layer.yPosition().isZero())
1062         return true;
1063 
1064     auto sizeType = layer.sizeType();
1065 
1066     if (sizeType == FillSizeType::Contain || sizeType == FillSizeType::Cover)
1067         return true;
1068 
1069     if (sizeType == FillSizeType::Size) {
1070         auto size = layer.sizeLength();
1071         if (size.width.isPercentOrCalculated() || size.height.isPercentOrCalculated())
1072             return true;
1073         // If the image has neither an intrinsic width nor an intrinsic height, its size is determined as for &#39;contain&#39;.
1074         if ((size.width.isAuto() || size.height.isAuto()) &amp;&amp; image-&gt;isGeneratedImage())
1075             return true;
1076     } else if (image-&gt;usesImageContainerSize())
1077         return true;
1078 
1079     return false;
1080 }
1081 
1082 static bool mustRepaintBackgroundOrBorder(const RenderElement&amp; renderer)
1083 {
1084     if (renderer.hasMask() &amp;&amp; mustRepaintFillLayers(renderer, renderer.style().maskLayers()))
1085         return true;
1086 
1087     // If we don&#39;t have a background/border/mask, then nothing to do.
1088     if (!renderer.hasVisibleBoxDecorations())
1089         return false;
1090 
1091     if (mustRepaintFillLayers(renderer, renderer.style().backgroundLayers()))
1092         return true;
1093 
1094     // Our fill layers are ok. Let&#39;s check border.
1095     if (renderer.style().hasBorder() &amp;&amp; renderer.borderImageIsLoadedAndCanBeRendered())
1096         return true;
1097 
1098     return false;
1099 }
1100 
1101 bool RenderElement::repaintAfterLayoutIfNeeded(const RenderLayerModelObject* repaintContainer, const LayoutRect&amp; oldBounds, const LayoutRect&amp; oldOutlineBox, const LayoutRect* newBoundsPtr, const LayoutRect* newOutlineBoxRectPtr)
1102 {
1103     if (view().printing())
1104         return false; // Don&#39;t repaint if we&#39;re printing.
1105 
1106     // This ASSERT fails due to animations. See https://bugs.webkit.org/show_bug.cgi?id=37048
1107     // ASSERT(!newBoundsPtr || *newBoundsPtr == clippedOverflowRectForRepaint(repaintContainer));
1108     LayoutRect newBounds = newBoundsPtr ? *newBoundsPtr : clippedOverflowRectForRepaint(repaintContainer);
1109     LayoutRect newOutlineBox;
1110 
1111     bool fullRepaint = selfNeedsLayout();
1112     // Presumably a background or a border exists if border-fit:lines was specified.
1113     if (!fullRepaint &amp;&amp; style().borderFit() == BorderFit::Lines)
1114         fullRepaint = true;
1115     if (!fullRepaint) {
1116         // This ASSERT fails due to animations. See https://bugs.webkit.org/show_bug.cgi?id=37048
1117         // ASSERT(!newOutlineBoxRectPtr || *newOutlineBoxRectPtr == outlineBoundsForRepaint(repaintContainer));
1118         newOutlineBox = newOutlineBoxRectPtr ? *newOutlineBoxRectPtr : outlineBoundsForRepaint(repaintContainer);
1119         fullRepaint = (newOutlineBox.location() != oldOutlineBox.location() || (mustRepaintBackgroundOrBorder(*this) &amp;&amp; (newBounds != oldBounds || newOutlineBox != oldOutlineBox)));
1120     }
1121 
1122     if (!repaintContainer)
1123         repaintContainer = &amp;view();
1124 
1125     if (fullRepaint) {
1126         repaintUsingContainer(repaintContainer, oldBounds);
1127         if (newBounds != oldBounds)
1128             repaintUsingContainer(repaintContainer, newBounds);
1129         return true;
1130     }
1131 
1132     if (newBounds == oldBounds &amp;&amp; newOutlineBox == oldOutlineBox)
1133         return false;
1134 
1135     LayoutUnit deltaLeft = newBounds.x() - oldBounds.x();
1136     if (deltaLeft &gt; 0)
1137         repaintUsingContainer(repaintContainer, LayoutRect(oldBounds.x(), oldBounds.y(), deltaLeft, oldBounds.height()));
1138     else if (deltaLeft &lt; 0)
1139         repaintUsingContainer(repaintContainer, LayoutRect(newBounds.x(), newBounds.y(), -deltaLeft, newBounds.height()));
1140 
1141     LayoutUnit deltaRight = newBounds.maxX() - oldBounds.maxX();
1142     if (deltaRight &gt; 0)
1143         repaintUsingContainer(repaintContainer, LayoutRect(oldBounds.maxX(), newBounds.y(), deltaRight, newBounds.height()));
1144     else if (deltaRight &lt; 0)
1145         repaintUsingContainer(repaintContainer, LayoutRect(newBounds.maxX(), oldBounds.y(), -deltaRight, oldBounds.height()));
1146 
1147     LayoutUnit deltaTop = newBounds.y() - oldBounds.y();
1148     if (deltaTop &gt; 0)
1149         repaintUsingContainer(repaintContainer, LayoutRect(oldBounds.x(), oldBounds.y(), oldBounds.width(), deltaTop));
1150     else if (deltaTop &lt; 0)
1151         repaintUsingContainer(repaintContainer, LayoutRect(newBounds.x(), newBounds.y(), newBounds.width(), -deltaTop));
1152 
1153     LayoutUnit deltaBottom = newBounds.maxY() - oldBounds.maxY();
1154     if (deltaBottom &gt; 0)
1155         repaintUsingContainer(repaintContainer, LayoutRect(newBounds.x(), oldBounds.maxY(), newBounds.width(), deltaBottom));
1156     else if (deltaBottom &lt; 0)
1157         repaintUsingContainer(repaintContainer, LayoutRect(oldBounds.x(), newBounds.maxY(), oldBounds.width(), -deltaBottom));
1158 
1159     if (newOutlineBox == oldOutlineBox)
1160         return false;
1161 
1162     // We didn&#39;t move, but we did change size. Invalidate the delta, which will consist of possibly
1163     // two rectangles (but typically only one).
1164     const RenderStyle&amp; outlineStyle = outlineStyleForRepaint();
1165     LayoutUnit outlineWidth { outlineStyle.outlineSize() };
1166     LayoutBoxExtent insetShadowExtent = style().getBoxShadowInsetExtent();
1167     LayoutUnit width = absoluteValue(newOutlineBox.width() - oldOutlineBox.width());
1168     if (width) {
1169         LayoutUnit shadowLeft;
1170         LayoutUnit shadowRight;
1171         style().getBoxShadowHorizontalExtent(shadowLeft, shadowRight);
1172         LayoutUnit borderRight = is&lt;RenderBox&gt;(*this) ? downcast&lt;RenderBox&gt;(*this).borderRight() : 0_lu;
1173         LayoutUnit boxWidth = is&lt;RenderBox&gt;(*this) ? downcast&lt;RenderBox&gt;(*this).width() : 0_lu;
1174         LayoutUnit minInsetRightShadowExtent = std::min&lt;LayoutUnit&gt;(-insetShadowExtent.right(), std::min(newBounds.width(), oldBounds.width()));
1175         LayoutUnit borderWidth = std::max(borderRight, std::max(valueForLength(style().borderTopRightRadius().width, boxWidth), valueForLength(style().borderBottomRightRadius().width, boxWidth)));
1176         LayoutUnit decorationsWidth = std::max(LayoutUnit(-outlineStyle.outlineOffset()), borderWidth + minInsetRightShadowExtent) + std::max(outlineWidth, shadowRight);
1177         LayoutRect rightRect(newOutlineBox.x() + std::min(newOutlineBox.width(), oldOutlineBox.width()) - decorationsWidth,
1178             newOutlineBox.y(),
1179             width + decorationsWidth,
1180             std::max(newOutlineBox.height(), oldOutlineBox.height()));
1181         LayoutUnit right = std::min(newBounds.maxX(), oldBounds.maxX());
1182         if (rightRect.x() &lt; right) {
1183             rightRect.setWidth(std::min(rightRect.width(), right - rightRect.x()));
1184             repaintUsingContainer(repaintContainer, rightRect);
1185         }
1186     }
1187     LayoutUnit height = absoluteValue(newOutlineBox.height() - oldOutlineBox.height());
1188     if (height) {
1189         LayoutUnit shadowTop;
1190         LayoutUnit shadowBottom;
1191         style().getBoxShadowVerticalExtent(shadowTop, shadowBottom);
1192         LayoutUnit borderBottom = is&lt;RenderBox&gt;(*this) ? downcast&lt;RenderBox&gt;(*this).borderBottom() : 0_lu;
1193         LayoutUnit boxHeight = is&lt;RenderBox&gt;(*this) ? downcast&lt;RenderBox&gt;(*this).height() : 0_lu;
1194         LayoutUnit minInsetBottomShadowExtent = std::min&lt;LayoutUnit&gt;(-insetShadowExtent.bottom(), std::min(newBounds.height(), oldBounds.height()));
1195         LayoutUnit borderHeight = std::max(borderBottom, std::max(valueForLength(style().borderBottomLeftRadius().height, boxHeight),
1196             valueForLength(style().borderBottomRightRadius().height, boxHeight)));
1197         LayoutUnit decorationsHeight = std::max(LayoutUnit(-outlineStyle.outlineOffset()), borderHeight + minInsetBottomShadowExtent) + std::max(outlineWidth, shadowBottom);
1198         LayoutRect bottomRect(newOutlineBox.x(),
1199             std::min(newOutlineBox.maxY(), oldOutlineBox.maxY()) - decorationsHeight,
1200             std::max(newOutlineBox.width(), oldOutlineBox.width()),
1201             height + decorationsHeight);
1202         LayoutUnit bottom = std::min(newBounds.maxY(), oldBounds.maxY());
1203         if (bottomRect.y() &lt; bottom) {
1204             bottomRect.setHeight(std::min(bottomRect.height(), bottom - bottomRect.y()));
1205             repaintUsingContainer(repaintContainer, bottomRect);
1206         }
1207     }
1208     return false;
1209 }
1210 
1211 bool RenderElement::borderImageIsLoadedAndCanBeRendered() const
1212 {
1213     ASSERT(style().hasBorder());
1214 
1215     StyleImage* borderImage = style().borderImage().image();
1216     return borderImage &amp;&amp; borderImage-&gt;canRender(this, style().effectiveZoom()) &amp;&amp; borderImage-&gt;isLoaded();
1217 }
1218 
1219 bool RenderElement::mayCauseRepaintInsideViewport(const IntRect* optionalViewportRect) const
1220 {
1221     auto&amp; frameView = view().frameView();
1222     if (frameView.isOffscreen())
1223         return false;
1224 
1225     if (!hasOverflowClip()) {
1226         // FIXME: Computing the overflow rect is expensive if any descendant has
1227         // its own self-painting layer. As a result, we prefer to abort early in
1228         // this case and assume it may cause us to repaint inside the viewport.
1229         if (!hasLayer() || downcast&lt;RenderLayerModelObject&gt;(*this).layer()-&gt;firstChild())
1230             return true;
1231     }
1232 
1233     // Compute viewport rect if it was not provided.
1234     const IntRect&amp; visibleRect = optionalViewportRect ? *optionalViewportRect : frameView.windowToContents(frameView.windowClipRect());
1235     return visibleRect.intersects(enclosingIntRect(absoluteClippedOverflowRect()));
1236 }
1237 
1238 bool RenderElement::isVisibleInDocumentRect(const IntRect&amp; documentRect) const
1239 {
1240     if (document().activeDOMObjectsAreSuspended())
1241         return false;
1242     if (style().visibility() != Visibility::Visible)
1243         return false;
1244     if (view().frameView().isOffscreen())
1245         return false;
1246 
1247     // Use background rect if we are the root or if we are the body and the background is propagated to the root.
1248     // FIXME: This is overly conservative as the image may not be a background-image, in which case it will not
1249     // be propagated to the root. At this point, we unfortunately don&#39;t have access to the image anymore so we
1250     // can no longer check if it is a background image.
1251     bool backgroundIsPaintedByRoot = isDocumentElementRenderer();
1252     if (isBody()) {
1253         auto&amp; rootRenderer = *parent(); // If &lt;body&gt; has a renderer then &lt;html&gt; does too.
1254         ASSERT(rootRenderer.isDocumentElementRenderer());
1255         ASSERT(is&lt;HTMLHtmlElement&gt;(rootRenderer.element()));
1256         // FIXME: Should share body background propagation code.
1257         backgroundIsPaintedByRoot = !rootRenderer.hasBackground();
1258 
1259     }
1260 
1261     LayoutRect backgroundPaintingRect = backgroundIsPaintedByRoot ? view().backgroundRect() : absoluteClippedOverflowRect();
1262     if (!documentRect.intersects(enclosingIntRect(backgroundPaintingRect)))
1263         return false;
1264 
1265     return true;
1266 }
1267 
1268 void RenderElement::registerForVisibleInViewportCallback()
1269 {
1270     if (m_isRegisteredForVisibleInViewportCallback)
1271         return;
1272     m_isRegisteredForVisibleInViewportCallback = true;
1273 
1274     view().registerForVisibleInViewportCallback(*this);
1275 }
1276 
1277 void RenderElement::unregisterForVisibleInViewportCallback()
1278 {
1279     if (!m_isRegisteredForVisibleInViewportCallback)
1280         return;
1281     m_isRegisteredForVisibleInViewportCallback = false;
1282 
1283     view().unregisterForVisibleInViewportCallback(*this);
1284 }
1285 
1286 void RenderElement::setVisibleInViewportState(VisibleInViewportState state)
1287 {
1288     if (state == visibleInViewportState())
1289         return;
1290     m_visibleInViewportState = static_cast&lt;unsigned&gt;(state);
1291     visibleInViewportStateChanged();
1292 }
1293 
1294 void RenderElement::visibleInViewportStateChanged()
1295 {
1296     ASSERT_NOT_REACHED();
1297 }
1298 
1299 bool RenderElement::isVisibleInViewport() const
1300 {
1301     auto&amp; frameView = view().frameView();
1302     auto visibleRect = frameView.windowToContents(frameView.windowClipRect());
1303     return isVisibleInDocumentRect(visibleRect);
1304 }
1305 
1306 VisibleInViewportState RenderElement::imageFrameAvailable(CachedImage&amp; image, ImageAnimatingState animatingState, const IntRect* changeRect)
1307 {
1308     bool isVisible = isVisibleInViewport();
1309 
1310     if (!isVisible &amp;&amp; animatingState == ImageAnimatingState::Yes)
1311         view().addRendererWithPausedImageAnimations(*this, image);
1312 
1313     // Static images should repaint even if they are outside the viewport rectangle
1314     // because they should be inside the TileCoverageRect.
1315     if (isVisible || animatingState == ImageAnimatingState::No)
1316         imageChanged(&amp;image, changeRect);
1317 
1318     if (element() &amp;&amp; image.image()-&gt;isBitmapImage())
1319         element()-&gt;dispatchWebKitImageReadyEventForTesting();
1320 
1321     return isVisible ? VisibleInViewportState::Yes : VisibleInViewportState::No;
1322 }
1323 
1324 void RenderElement::didRemoveCachedImageClient(CachedImage&amp; cachedImage)
1325 {
1326     if (hasPausedImageAnimations())
1327         view().removeRendererWithPausedImageAnimations(*this, cachedImage);
1328 }
1329 
1330 bool RenderElement::repaintForPausedImageAnimationsIfNeeded(const IntRect&amp; visibleRect, CachedImage&amp; cachedImage)
1331 {
1332     ASSERT(m_hasPausedImageAnimations);
1333     if (!isVisibleInDocumentRect(visibleRect))
1334         return false;
1335 
1336     repaint();
1337 
1338     if (auto* image = cachedImage.image()) {
1339         if (is&lt;SVGImage&gt;(image))
1340             downcast&lt;SVGImage&gt;(image)-&gt;scheduleStartAnimation();
1341         else
1342             image-&gt;startAnimation();
1343     }
1344 
1345     // For directly-composited animated GIFs it does not suffice to call repaint() to resume animation. We need to mark the image as changed.
1346     if (is&lt;RenderBoxModelObject&gt;(*this))
1347         downcast&lt;RenderBoxModelObject&gt;(*this).contentChanged(ImageChanged);
1348 
1349     return true;
1350 }
1351 
1352 const RenderStyle* RenderElement::getCachedPseudoStyle(PseudoId pseudo, const RenderStyle* parentStyle) const
1353 {
1354     if (pseudo &lt; PseudoId::FirstInternalPseudoId &amp;&amp; !style().hasPseudoStyle(pseudo))
1355         return nullptr;
1356 
1357     RenderStyle* cachedStyle = style().getCachedPseudoStyle(pseudo);
1358     if (cachedStyle)
1359         return cachedStyle;
1360 
1361     std::unique_ptr&lt;RenderStyle&gt; result = getUncachedPseudoStyle(PseudoStyleRequest(pseudo), parentStyle);
1362     if (result)
1363         return const_cast&lt;RenderStyle&amp;&gt;(m_style).addCachedPseudoStyle(WTFMove(result));
1364     return nullptr;
1365 }
1366 
1367 std::unique_ptr&lt;RenderStyle&gt; RenderElement::getUncachedPseudoStyle(const PseudoStyleRequest&amp; pseudoStyleRequest, const RenderStyle* parentStyle, const RenderStyle* ownStyle) const
1368 {
1369     if (pseudoStyleRequest.pseudoId &lt; PseudoId::FirstInternalPseudoId &amp;&amp; !ownStyle &amp;&amp; !style().hasPseudoStyle(pseudoStyleRequest.pseudoId))
1370         return nullptr;
1371 
1372     if (!parentStyle) {
1373         ASSERT(!ownStyle);
1374         parentStyle = &amp;style();
1375     }
1376 
1377     if (isAnonymous())
1378         return nullptr;
1379 
1380     auto&amp; styleResolver = element()-&gt;styleResolver();
1381 
1382     std::unique_ptr&lt;RenderStyle&gt; style = styleResolver.pseudoStyleForElement(*element(), pseudoStyleRequest, *parentStyle);
1383 
1384     if (style)
1385         Style::loadPendingResources(*style, document(), element());
1386 
1387     return style;
1388 }
1389 
1390 Color RenderElement::selectionColor(CSSPropertyID colorProperty) const
1391 {
1392     // If the element is unselectable, or we are only painting the selection,
1393     // don&#39;t override the foreground color with the selection foreground color.
1394     if (style().userSelect() == UserSelect::None
1395         || (view().frameView().paintBehavior().containsAny({ PaintBehavior::SelectionOnly, PaintBehavior::SelectionAndBackgroundsOnly })))
1396         return Color();
1397 
1398     if (std::unique_ptr&lt;RenderStyle&gt; pseudoStyle = selectionPseudoStyle()) {
1399         Color color = pseudoStyle-&gt;visitedDependentColorWithColorFilter(colorProperty);
1400         if (!color.isValid())
1401             color = pseudoStyle-&gt;visitedDependentColorWithColorFilter(CSSPropertyColor);
1402         return color;
1403     }
1404 
1405     if (frame().selection().isFocusedAndActive())
1406         return theme().activeSelectionForegroundColor(styleColorOptions());
1407     return theme().inactiveSelectionForegroundColor(styleColorOptions());
1408 }
1409 
1410 std::unique_ptr&lt;RenderStyle&gt; RenderElement::selectionPseudoStyle() const
1411 {
1412     if (isAnonymous())
1413         return nullptr;
1414 
1415     if (ShadowRoot* root = element()-&gt;containingShadowRoot()) {
1416         if (root-&gt;mode() == ShadowRootMode::UserAgent) {
1417             if (Element* shadowHost = element()-&gt;shadowHost())
1418                 return shadowHost-&gt;renderer()-&gt;getUncachedPseudoStyle(PseudoStyleRequest(PseudoId::Selection));
1419         }
1420     }
1421 
1422     return getUncachedPseudoStyle(PseudoStyleRequest(PseudoId::Selection));
1423 }
1424 
1425 Color RenderElement::selectionForegroundColor() const
1426 {
1427     return selectionColor(CSSPropertyWebkitTextFillColor);
1428 }
1429 
1430 Color RenderElement::selectionEmphasisMarkColor() const
1431 {
1432     return selectionColor(CSSPropertyWebkitTextEmphasisColor);
1433 }
1434 
1435 Color RenderElement::selectionBackgroundColor() const
1436 {
1437     if (style().userSelect() == UserSelect::None)
1438         return Color();
1439 
1440     if (frame().selection().shouldShowBlockCursor() &amp;&amp; frame().selection().isCaret())
1441         return theme().transformSelectionBackgroundColor(style().visitedDependentColorWithColorFilter(CSSPropertyColor), styleColorOptions());
1442 
1443     std::unique_ptr&lt;RenderStyle&gt; pseudoStyle = selectionPseudoStyle();
1444     if (pseudoStyle &amp;&amp; pseudoStyle-&gt;visitedDependentColorWithColorFilter(CSSPropertyBackgroundColor).isValid())
1445         return theme().transformSelectionBackgroundColor(pseudoStyle-&gt;visitedDependentColorWithColorFilter(CSSPropertyBackgroundColor), styleColorOptions());
1446 
1447     if (frame().selection().isFocusedAndActive())
1448         return theme().activeSelectionBackgroundColor(styleColorOptions());
1449     return theme().inactiveSelectionBackgroundColor(styleColorOptions());
1450 }
1451 
1452 bool RenderElement::getLeadingCorner(FloatPoint&amp; point, bool&amp; insideFixed) const
1453 {
1454     if (!isInline() || isReplaced()) {
1455         point = localToAbsolute(FloatPoint(), UseTransforms, &amp;insideFixed);
1456         return true;
1457     }
1458 
1459     // find the next text/image child, to get a position
1460     const RenderObject* o = this;
1461     while (o) {
1462         const RenderObject* p = o;
1463         if (RenderObject* child = o-&gt;firstChildSlow())
1464             o = child;
1465         else if (o-&gt;nextSibling())
1466             o = o-&gt;nextSibling();
1467         else {
1468             RenderObject* next = 0;
1469             while (!next &amp;&amp; o-&gt;parent()) {
1470                 o = o-&gt;parent();
1471                 next = o-&gt;nextSibling();
1472             }
1473             o = next;
1474 
1475             if (!o)
1476                 break;
1477         }
1478         ASSERT(o);
1479 
1480         if (!o-&gt;isInline() || o-&gt;isReplaced()) {
1481             point = o-&gt;localToAbsolute(FloatPoint(), UseTransforms, &amp;insideFixed);
1482             return true;
1483         }
1484 
1485         if (p-&gt;node() &amp;&amp; p-&gt;node() == element() &amp;&amp; is&lt;RenderText&gt;(*o) &amp;&amp; !downcast&lt;RenderText&gt;(*o).firstTextBox()) {
1486             // do nothing - skip unrendered whitespace that is a child or next sibling of the anchor
1487         } else if (is&lt;RenderText&gt;(*o) || o-&gt;isReplaced()) {
1488             point = FloatPoint();
1489             if (is&lt;RenderText&gt;(*o) &amp;&amp; downcast&lt;RenderText&gt;(*o).firstTextBox())
1490                 point.move(downcast&lt;RenderText&gt;(*o).linesBoundingBox().x(), downcast&lt;RenderText&gt;(*o).topOfFirstText());
1491             else if (is&lt;RenderBox&gt;(*o))
1492                 point.moveBy(downcast&lt;RenderBox&gt;(*o).location());
1493             point = o-&gt;container()-&gt;localToAbsolute(point, UseTransforms, &amp;insideFixed);
1494             return true;
1495         }
1496     }
1497 
1498     // If the target doesn&#39;t have any children or siblings that could be used to calculate the scroll position, we must be
1499     // at the end of the document. Scroll to the bottom. FIXME: who said anything about scrolling?
1500     if (!o &amp;&amp; document().view()) {
1501         point = FloatPoint(0, document().view()-&gt;contentsHeight());
1502         return true;
1503     }
1504     return false;
1505 }
1506 
1507 bool RenderElement::getTrailingCorner(FloatPoint&amp; point, bool&amp; insideFixed) const
1508 {
1509     if (!isInline() || isReplaced()) {
1510         point = localToAbsolute(LayoutPoint(downcast&lt;RenderBox&gt;(*this).size()), UseTransforms, &amp;insideFixed);
1511         return true;
1512     }
1513 
1514     // find the last text/image child, to get a position
1515     const RenderObject* o = this;
1516     while (o) {
1517         if (RenderObject* child = o-&gt;lastChildSlow())
1518             o = child;
1519         else if (o-&gt;previousSibling())
1520             o = o-&gt;previousSibling();
1521         else {
1522             RenderObject* prev = 0;
1523             while (!prev) {
1524                 o = o-&gt;parent();
1525                 if (!o)
1526                     return false;
1527                 prev = o-&gt;previousSibling();
1528             }
1529             o = prev;
1530         }
1531         ASSERT(o);
1532         if (is&lt;RenderText&gt;(*o) || o-&gt;isReplaced()) {
1533             point = FloatPoint();
1534             if (is&lt;RenderText&gt;(*o)) {
1535                 LayoutRect linesBox = downcast&lt;RenderText&gt;(*o).linesBoundingBox();
1536                 if (!linesBox.maxX() &amp;&amp; !linesBox.maxY())
1537                     continue;
1538                 point.moveBy(linesBox.maxXMaxYCorner());
1539             } else
1540                 point.moveBy(downcast&lt;RenderBox&gt;(*o).frameRect().maxXMaxYCorner());
1541             point = o-&gt;container()-&gt;localToAbsolute(point, UseTransforms, &amp;insideFixed);
1542             return true;
1543         }
1544     }
1545     return true;
1546 }
1547 
1548 LayoutRect RenderElement::absoluteAnchorRect(bool* insideFixed) const
1549 {
1550     FloatPoint leading, trailing;
1551     bool leadingInFixed = false;
1552     bool trailingInFixed = false;
1553     getLeadingCorner(leading, leadingInFixed);
1554     getTrailingCorner(trailing, trailingInFixed);
1555 
1556     FloatPoint upperLeft = leading;
1557     FloatPoint lowerRight = trailing;
1558 
1559     // Vertical writing modes might mean the leading point is not in the top left
1560     if (!isInline() || isReplaced()) {
1561         upperLeft = FloatPoint(std::min(leading.x(), trailing.x()), std::min(leading.y(), trailing.y()));
1562         lowerRight = FloatPoint(std::max(leading.x(), trailing.x()), std::max(leading.y(), trailing.y()));
1563     } // Otherwise, it&#39;s not obvious what to do.
1564 
1565     if (insideFixed) {
1566         // For now, just look at the leading corner. Handling one inside fixed and one not would be tricky.
1567         *insideFixed = leadingInFixed;
1568     }
1569 
1570     return enclosingLayoutRect(FloatRect(upperLeft, lowerRight.expandedTo(upperLeft) - upperLeft));
1571 }
1572 
1573 const RenderElement* RenderElement::enclosingRendererWithTextDecoration(OptionSet&lt;TextDecoration&gt; textDecoration, bool firstLine) const
1574 {
1575     const RenderElement* current = this;
1576     do {
1577         if (current-&gt;isRenderBlock())
1578             return current;
1579         if (!current-&gt;isRenderInline() || current-&gt;isRubyText())
1580             return nullptr;
1581 
1582         const RenderStyle&amp; styleToUse = firstLine ? current-&gt;firstLineStyle() : current-&gt;style();
1583         if (styleToUse.textDecoration() &amp; textDecoration)
1584             return current;
1585         current = current-&gt;parent();
1586     } while (current &amp;&amp; (!current-&gt;element() || (!is&lt;HTMLAnchorElement&gt;(*current-&gt;element()) &amp;&amp; !current-&gt;element()-&gt;hasTagName(HTMLNames::fontTag))));
1587 
1588     return current;
1589 }
1590 
1591 void RenderElement::drawLineForBoxSide(GraphicsContext&amp; graphicsContext, const FloatRect&amp; rect, BoxSide side, Color color, BorderStyle borderStyle, float adjacentWidth1, float adjacentWidth2, bool antialias) const
1592 {
1593     auto drawBorderRect = [&amp;graphicsContext] (const FloatRect&amp; rect)
1594     {
1595         if (rect.isEmpty())
1596             return;
1597         graphicsContext.drawRect(rect);
1598     };
1599 
1600     auto drawLineFor = [this, &amp;graphicsContext, color, antialias] (const FloatRect&amp; rect, BoxSide side, BorderStyle borderStyle, const FloatSize&amp; adjacent)
1601     {
1602         if (rect.isEmpty())
1603             return;
1604         drawLineForBoxSide(graphicsContext, rect, side, color, borderStyle, adjacent.width(), adjacent.height(), antialias);
1605     };
1606 
1607     float x1 = rect.x();
1608     float x2 = rect.maxX();
1609     float y1 = rect.y();
1610     float y2 = rect.maxY();
1611     float thickness;
1612     float length;
1613     if (side == BSTop || side == BSBottom) {
1614         thickness = y2 - y1;
1615         length = x2 - x1;
1616     } else {
1617         thickness = x2 - x1;
1618         length = y2 - y1;
1619     }
1620     // FIXME: We really would like this check to be an ASSERT as we don&#39;t want to draw empty borders. However
1621     // nothing guarantees that the following recursive calls to drawLineForBoxSide will have non-null dimensions.
1622     if (!thickness || !length)
1623         return;
1624 
1625     float deviceScaleFactor = document().deviceScaleFactor();
1626     if (borderStyle == BorderStyle::Double &amp;&amp; (thickness * deviceScaleFactor) &lt; 3)
1627         borderStyle = BorderStyle::Solid;
1628 
1629     switch (borderStyle) {
1630     case BorderStyle::None:
1631     case BorderStyle::Hidden:
1632         return;
1633     case BorderStyle::Dotted:
1634     case BorderStyle::Dashed: {
1635         bool wasAntialiased = graphicsContext.shouldAntialias();
1636         StrokeStyle oldStrokeStyle = graphicsContext.strokeStyle();
1637         graphicsContext.setShouldAntialias(antialias);
1638         graphicsContext.setStrokeColor(color);
1639         graphicsContext.setStrokeThickness(thickness);
1640         graphicsContext.setStrokeStyle(borderStyle == BorderStyle::Dashed ? DashedStroke : DottedStroke);
1641         graphicsContext.drawLine(roundPointToDevicePixels(LayoutPoint(x1, y1), deviceScaleFactor), roundPointToDevicePixels(LayoutPoint(x2, y2), deviceScaleFactor));
1642         graphicsContext.setShouldAntialias(wasAntialiased);
1643         graphicsContext.setStrokeStyle(oldStrokeStyle);
1644         break;
1645     }
1646     case BorderStyle::Double: {
1647         float thirdOfThickness = ceilToDevicePixel(thickness / 3, deviceScaleFactor);
1648         ASSERT(thirdOfThickness);
1649 
1650         if (!adjacentWidth1 &amp;&amp; !adjacentWidth2) {
1651             StrokeStyle oldStrokeStyle = graphicsContext.strokeStyle();
1652             graphicsContext.setStrokeStyle(NoStroke);
1653             graphicsContext.setFillColor(color);
1654 
1655             bool wasAntialiased = graphicsContext.shouldAntialias();
1656             graphicsContext.setShouldAntialias(antialias);
1657 
1658             switch (side) {
1659             case BSTop:
1660             case BSBottom:
1661                 drawBorderRect(snapRectToDevicePixels(LayoutRect(x1, y1, length, thirdOfThickness), deviceScaleFactor));
1662                 drawBorderRect(snapRectToDevicePixels(LayoutRect(x1, y2 - thirdOfThickness, length, thirdOfThickness), deviceScaleFactor));
1663                 break;
1664             case BSLeft:
1665             case BSRight:
1666                 drawBorderRect(snapRectToDevicePixels(LayoutRect(x1, y1, thirdOfThickness, length), deviceScaleFactor));
1667                 drawBorderRect(snapRectToDevicePixels(LayoutRect(x2 - thirdOfThickness, y1, thirdOfThickness, length), deviceScaleFactor));
1668                 break;
1669             }
1670 
1671             graphicsContext.setShouldAntialias(wasAntialiased);
1672             graphicsContext.setStrokeStyle(oldStrokeStyle);
1673         } else {
1674             float adjacent1BigThird = ceilToDevicePixel(adjacentWidth1 / 3, deviceScaleFactor);
1675             float adjacent2BigThird = ceilToDevicePixel(adjacentWidth2 / 3, deviceScaleFactor);
1676 
1677             float offset1 = floorToDevicePixel(fabs(adjacentWidth1) * 2 / 3, deviceScaleFactor);
1678             float offset2 = floorToDevicePixel(fabs(adjacentWidth2) * 2 / 3, deviceScaleFactor);
1679 
1680             float mitreOffset1 = adjacentWidth1 &lt; 0 ? offset1 : 0;
1681             float mitreOffset2 = adjacentWidth1 &gt; 0 ? offset1 : 0;
1682             float mitreOffset3 = adjacentWidth2 &lt; 0 ? offset2 : 0;
1683             float mitreOffset4 = adjacentWidth2 &gt; 0 ? offset2 : 0;
1684 
1685             FloatRect paintBorderRect;
1686             switch (side) {
1687             case BSTop:
1688                 paintBorderRect = snapRectToDevicePixels(LayoutRect(x1 + mitreOffset1, y1, (x2 - mitreOffset3) - (x1 + mitreOffset1), thirdOfThickness), deviceScaleFactor);
1689                 drawLineFor(paintBorderRect, side, BorderStyle::Solid, FloatSize(adjacent1BigThird, adjacent2BigThird));
1690 
1691                 paintBorderRect = snapRectToDevicePixels(LayoutRect(x1 + mitreOffset2, y2 - thirdOfThickness, (x2 - mitreOffset4) - (x1 + mitreOffset2), thirdOfThickness), deviceScaleFactor);
1692                 drawLineFor(paintBorderRect, side, BorderStyle::Solid, FloatSize(adjacent1BigThird, adjacent2BigThird));
1693                 break;
1694             case BSLeft:
1695                 paintBorderRect = snapRectToDevicePixels(LayoutRect(x1, y1 + mitreOffset1, thirdOfThickness, (y2 - mitreOffset3) - (y1 + mitreOffset1)), deviceScaleFactor);
1696                 drawLineFor(paintBorderRect, side, BorderStyle::Solid, FloatSize(adjacent1BigThird, adjacent2BigThird));
1697 
1698                 paintBorderRect = snapRectToDevicePixels(LayoutRect(x2 - thirdOfThickness, y1 + mitreOffset2, thirdOfThickness, (y2 - mitreOffset4) - (y1 + mitreOffset2)), deviceScaleFactor);
1699                 drawLineFor(paintBorderRect, side, BorderStyle::Solid, FloatSize(adjacent1BigThird, adjacent2BigThird));
1700                 break;
1701             case BSBottom:
1702                 paintBorderRect = snapRectToDevicePixels(LayoutRect(x1 + mitreOffset2, y1, (x2 - mitreOffset4) - (x1 + mitreOffset2), thirdOfThickness), deviceScaleFactor);
1703                 drawLineFor(paintBorderRect, side, BorderStyle::Solid, FloatSize(adjacent1BigThird, adjacent2BigThird));
1704 
1705                 paintBorderRect = snapRectToDevicePixels(LayoutRect(x1 + mitreOffset1, y2 - thirdOfThickness, (x2 - mitreOffset3) - (x1 + mitreOffset1), thirdOfThickness), deviceScaleFactor);
1706                 drawLineFor(paintBorderRect, side, BorderStyle::Solid, FloatSize(adjacent1BigThird, adjacent2BigThird));
1707                 break;
1708             case BSRight:
1709                 paintBorderRect = snapRectToDevicePixels(LayoutRect(x1, y1 + mitreOffset2, thirdOfThickness, (y2 - mitreOffset4) - (y1 + mitreOffset2)), deviceScaleFactor);
1710                 drawLineFor(paintBorderRect, side, BorderStyle::Solid, FloatSize(adjacent1BigThird, adjacent2BigThird));
1711 
1712                 paintBorderRect = snapRectToDevicePixels(LayoutRect(x2 - thirdOfThickness, y1 + mitreOffset1, thirdOfThickness, (y2 - mitreOffset3) - (y1 + mitreOffset1)), deviceScaleFactor);
1713                 drawLineFor(paintBorderRect, side, BorderStyle::Solid, FloatSize(adjacent1BigThird, adjacent2BigThird));
1714                 break;
1715             default:
1716                 break;
1717             }
1718         }
1719         break;
1720     }
1721     case BorderStyle::Ridge:
1722     case BorderStyle::Groove: {
1723         BorderStyle s1;
1724         BorderStyle s2;
1725         if (borderStyle == BorderStyle::Groove) {
1726             s1 = BorderStyle::Inset;
1727             s2 = BorderStyle::Outset;
1728         } else {
1729             s1 = BorderStyle::Outset;
1730             s2 = BorderStyle::Inset;
1731         }
1732 
1733         float adjacent1BigHalf = ceilToDevicePixel(adjacentWidth1 / 2, deviceScaleFactor);
1734         float adjacent2BigHalf = ceilToDevicePixel(adjacentWidth2 / 2, deviceScaleFactor);
1735 
1736         float adjacent1SmallHalf = floorToDevicePixel(adjacentWidth1 / 2, deviceScaleFactor);
1737         float adjacent2SmallHalf = floorToDevicePixel(adjacentWidth2 / 2, deviceScaleFactor);
1738 
1739         float offset1 = 0;
1740         float offset2 = 0;
1741         float offset3 = 0;
1742         float offset4 = 0;
1743 
1744         if (((side == BSTop || side == BSLeft) &amp;&amp; adjacentWidth1 &lt; 0) || ((side == BSBottom || side == BSRight) &amp;&amp; adjacentWidth1 &gt; 0))
1745             offset1 = floorToDevicePixel(adjacentWidth1 / 2, deviceScaleFactor);
1746 
1747         if (((side == BSTop || side == BSLeft) &amp;&amp; adjacentWidth2 &lt; 0) || ((side == BSBottom || side == BSRight) &amp;&amp; adjacentWidth2 &gt; 0))
1748             offset2 = ceilToDevicePixel(adjacentWidth2 / 2, deviceScaleFactor);
1749 
1750         if (((side == BSTop || side == BSLeft) &amp;&amp; adjacentWidth1 &gt; 0) || ((side == BSBottom || side == BSRight) &amp;&amp; adjacentWidth1 &lt; 0))
1751             offset3 = floorToDevicePixel(fabs(adjacentWidth1) / 2, deviceScaleFactor);
1752 
1753         if (((side == BSTop || side == BSLeft) &amp;&amp; adjacentWidth2 &gt; 0) || ((side == BSBottom || side == BSRight) &amp;&amp; adjacentWidth2 &lt; 0))
1754             offset4 = ceilToDevicePixel(adjacentWidth2 / 2, deviceScaleFactor);
1755 
1756         float adjustedX = ceilToDevicePixel((x1 + x2) / 2, deviceScaleFactor);
1757         float adjustedY = ceilToDevicePixel((y1 + y2) / 2, deviceScaleFactor);
1758         // Quads can&#39;t use the default snapping rect functions.
1759         x1 = roundToDevicePixel(x1, deviceScaleFactor);
1760         x2 = roundToDevicePixel(x2, deviceScaleFactor);
1761         y1 = roundToDevicePixel(y1, deviceScaleFactor);
1762         y2 = roundToDevicePixel(y2, deviceScaleFactor);
1763 
1764         switch (side) {
1765         case BSTop:
1766             drawLineFor(FloatRect(FloatPoint(x1 + offset1, y1), FloatPoint(x2 - offset2, adjustedY)), side, s1, FloatSize(adjacent1BigHalf, adjacent2BigHalf));
1767             drawLineFor(FloatRect(FloatPoint(x1 + offset3, adjustedY), FloatPoint(x2 - offset4, y2)), side, s2, FloatSize(adjacent1SmallHalf, adjacent2SmallHalf));
1768             break;
1769         case BSLeft:
1770             drawLineFor(FloatRect(FloatPoint(x1, y1 + offset1), FloatPoint(adjustedX, y2 - offset2)), side, s1, FloatSize(adjacent1BigHalf, adjacent2BigHalf));
1771             drawLineFor(FloatRect(FloatPoint(adjustedX, y1 + offset3), FloatPoint(x2, y2 - offset4)), side, s2, FloatSize(adjacent1SmallHalf, adjacent2SmallHalf));
1772             break;
1773         case BSBottom:
1774             drawLineFor(FloatRect(FloatPoint(x1 + offset1, y1), FloatPoint(x2 - offset2, adjustedY)), side, s2, FloatSize(adjacent1BigHalf, adjacent2BigHalf));
1775             drawLineFor(FloatRect(FloatPoint(x1 + offset3, adjustedY), FloatPoint(x2 - offset4, y2)), side, s1, FloatSize(adjacent1SmallHalf, adjacent2SmallHalf));
1776             break;
1777         case BSRight:
1778             drawLineFor(FloatRect(FloatPoint(x1, y1 + offset1), FloatPoint(adjustedX, y2 - offset2)), side, s2, FloatSize(adjacent1BigHalf, adjacent2BigHalf));
1779             drawLineFor(FloatRect(FloatPoint(adjustedX, y1 + offset3), FloatPoint(x2, y2 - offset4)), side, s1, FloatSize(adjacent1SmallHalf, adjacent2SmallHalf));
1780             break;
1781         }
1782         break;
1783     }
1784     case BorderStyle::Inset:
1785     case BorderStyle::Outset:
1786         calculateBorderStyleColor(borderStyle, side, color);
1787         FALLTHROUGH;
1788     case BorderStyle::Solid: {
1789         StrokeStyle oldStrokeStyle = graphicsContext.strokeStyle();
1790         ASSERT(x2 &gt;= x1);
1791         ASSERT(y2 &gt;= y1);
1792         if (!adjacentWidth1 &amp;&amp; !adjacentWidth2) {
1793             graphicsContext.setStrokeStyle(NoStroke);
1794             graphicsContext.setFillColor(color);
1795             bool wasAntialiased = graphicsContext.shouldAntialias();
1796             graphicsContext.setShouldAntialias(antialias);
1797             drawBorderRect(snapRectToDevicePixels(LayoutRect(x1, y1, x2 - x1, y2 - y1), deviceScaleFactor));
1798             graphicsContext.setShouldAntialias(wasAntialiased);
1799             graphicsContext.setStrokeStyle(oldStrokeStyle);
1800             return;
1801         }
1802 
1803         // FIXME: These roundings should be replaced by ASSERT(device pixel positioned) when all the callers have transitioned to device pixels.
1804         x1 = roundToDevicePixel(x1, deviceScaleFactor);
1805         y1 = roundToDevicePixel(y1, deviceScaleFactor);
1806         x2 = roundToDevicePixel(x2, deviceScaleFactor);
1807         y2 = roundToDevicePixel(y2, deviceScaleFactor);
1808 
1809         Vector&lt;FloatPoint&gt; quad;
1810         quad.reserveInitialCapacity(4);
1811         switch (side) {
1812         case BSTop:
1813             quad.uncheckedAppend({ x1 + std::max&lt;float&gt;(-adjacentWidth1, 0), y1 });
1814             quad.uncheckedAppend({ x1 + std::max&lt;float&gt;( adjacentWidth1, 0), y2 });
1815             quad.uncheckedAppend({ x2 - std::max&lt;float&gt;( adjacentWidth2, 0), y2 });
1816             quad.uncheckedAppend({ x2 - std::max&lt;float&gt;(-adjacentWidth2, 0), y1 });
1817             break;
1818         case BSBottom:
1819             quad.uncheckedAppend({ x1 + std::max&lt;float&gt;( adjacentWidth1, 0), y1 });
1820             quad.uncheckedAppend({ x1 + std::max&lt;float&gt;(-adjacentWidth1, 0), y2 });
1821             quad.uncheckedAppend({ x2 - std::max&lt;float&gt;(-adjacentWidth2, 0), y2 });
1822             quad.uncheckedAppend({ x2 - std::max&lt;float&gt;( adjacentWidth2, 0), y1 });
1823             break;
1824         case BSLeft:
1825             quad.uncheckedAppend({ x1, y1 + std::max&lt;float&gt;(-adjacentWidth1, 0) });
1826             quad.uncheckedAppend({ x1, y2 - std::max&lt;float&gt;(-adjacentWidth2, 0) });
1827             quad.uncheckedAppend({ x2, y2 - std::max&lt;float&gt;( adjacentWidth2, 0) });
1828             quad.uncheckedAppend({ x2, y1 + std::max&lt;float&gt;( adjacentWidth1, 0) });
1829             break;
1830         case BSRight:
1831             quad.uncheckedAppend({ x1, y1 + std::max&lt;float&gt;( adjacentWidth1, 0) });
1832             quad.uncheckedAppend({ x1, y2 - std::max&lt;float&gt;( adjacentWidth2, 0) });
1833             quad.uncheckedAppend({ x2, y2 - std::max&lt;float&gt;(-adjacentWidth2, 0) });
1834             quad.uncheckedAppend({ x2, y1 + std::max&lt;float&gt;(-adjacentWidth1, 0) });
1835             break;
1836         }
1837 
1838         graphicsContext.setStrokeStyle(NoStroke);
1839         graphicsContext.setFillColor(color);
1840         bool wasAntialiased = graphicsContext.shouldAntialias();
1841         graphicsContext.setShouldAntialias(antialias);
1842         graphicsContext.fillPath(Path::polygonPathFromPoints(quad));
1843         graphicsContext.setShouldAntialias(wasAntialiased);
1844 
1845         graphicsContext.setStrokeStyle(oldStrokeStyle);
1846         break;
1847     }
1848     }
1849 }
1850 
1851 static bool usePlatformFocusRingColorForOutlineStyleAuto()
1852 {
1853 #if PLATFORM(COCOA)
1854     return true;
1855 #else
1856     return false;
1857 #endif
1858 }
1859 
1860 static bool useShrinkWrappedFocusRingForOutlineStyleAuto()
1861 {
1862 #if PLATFORM(COCOA)
1863     return true;
1864 #else
1865     return false;
1866 #endif
1867 }
1868 
1869 static bool drawFocusRing(GraphicsContext&amp; context, Page&amp; page, const Path&amp; path, const RenderStyle&amp; style, Color focusRingColor)
1870 {
1871     bool needsRepaint = false;
1872 #if PLATFORM(MAC)
1873     context.drawFocusRing(path, page.focusController().timeSinceFocusWasSet().seconds(), needsRepaint, focusRingColor);
1874     UNUSED_PARAM(style);
1875 #else
1876     context.drawFocusRing(path, style.outlineWidth(), style.outlineOffset(), focusRingColor);
1877     UNUSED_PARAM(page);
1878 #endif
1879     return needsRepaint;
1880 }
1881 
1882 static bool drawFocusRing(GraphicsContext&amp; context, Page&amp; page, Vector&lt;FloatRect&gt; rects, const RenderStyle&amp; style, Color focusRingColor)
1883 {
1884     bool needsRepaint = false;
1885 #if PLATFORM(MAC)
1886     context.drawFocusRing(rects, page.focusController().timeSinceFocusWasSet().seconds(), needsRepaint, focusRingColor);
1887     UNUSED_PARAM(style);
1888 #else
1889     context.drawFocusRing(rects, style.outlineWidth(), style.outlineOffset(), focusRingColor);
1890     UNUSED_PARAM(page);
1891 #endif
1892     return needsRepaint;
1893 }
1894 
1895 
1896 void RenderElement::paintFocusRing(PaintInfo&amp; paintInfo, const RenderStyle&amp; style, const Vector&lt;LayoutRect&gt;&amp; focusRingRects)
1897 {
1898     ASSERT(style.outlineStyleIsAuto() == OutlineIsAuto::On);
1899     float outlineOffset = style.outlineOffset();
1900     Vector&lt;FloatRect&gt; pixelSnappedFocusRingRects;
1901     float deviceScaleFactor = document().deviceScaleFactor();
1902     for (auto rect : focusRingRects) {
1903         rect.inflate(outlineOffset);
1904         pixelSnappedFocusRingRects.append(snapRectToDevicePixels(rect, deviceScaleFactor));
1905     }
1906     Color focusRingColor = usePlatformFocusRingColorForOutlineStyleAuto() ? RenderTheme::singleton().focusRingColor(styleColorOptions()) : style.visitedDependentColorWithColorFilter(CSSPropertyOutlineColor);
1907     bool needsRepaint;
1908     if (useShrinkWrappedFocusRingForOutlineStyleAuto() &amp;&amp; style.hasBorderRadius()) {
1909         Path path = PathUtilities::pathWithShrinkWrappedRectsForOutline(pixelSnappedFocusRingRects, style.border(), outlineOffset, style.direction(), style.writingMode(),
1910             document().deviceScaleFactor());
1911         if (path.isEmpty()) {
1912             for (auto rect : pixelSnappedFocusRingRects)
1913                 path.addRect(rect);
1914         }
1915         needsRepaint = drawFocusRing(paintInfo.context(), page(), path, style, focusRingColor);
1916     } else
1917         needsRepaint = drawFocusRing(paintInfo.context(), page(), pixelSnappedFocusRingRects, style, focusRingColor);
1918     if (needsRepaint)
1919         page().focusController().setFocusedElementNeedsRepaint();
1920 }
1921 
1922 void RenderElement::paintOutline(PaintInfo&amp; paintInfo, const LayoutRect&amp; paintRect)
1923 {
1924     GraphicsContext&amp; graphicsContext = paintInfo.context();
1925     if (graphicsContext.paintingDisabled())
1926         return;
1927 
1928     if (!hasOutline())
1929         return;
1930 
1931     auto&amp; styleToUse = style();
1932     float outlineWidth = floorToDevicePixel(styleToUse.outlineWidth(), document().deviceScaleFactor());
1933     float outlineOffset = floorToDevicePixel(styleToUse.outlineOffset(), document().deviceScaleFactor());
1934 
1935     // Only paint the focus ring by hand if the theme isn&#39;t able to draw it.
1936     if (styleToUse.outlineStyleIsAuto() == OutlineIsAuto::On &amp;&amp; !theme().supportsFocusRing(styleToUse)) {
1937         Vector&lt;LayoutRect&gt; focusRingRects;
1938         LayoutRect paintRectToUse { paintRect };
1939 #if PLATFORM(IOS_FAMILY)
1940         // Workaround for &lt;rdar://problem/6209763&gt;. Force the painting bounds of checkboxes and radio controls to be square.
1941         // FIXME: Consolidate this code with the same code in RenderBox::paintBoxDecorations(). See &lt;https://bugs.webkit.org/show_bug.cgi?id=194781&gt;.
1942         if (style().appearance() == CheckboxPart || style().appearance() == RadioPart) {
1943             int width = std::min(paintRect.width(), paintRect.height());
1944             int height = width;
1945             paintRectToUse = IntRect { paintRect.x(), paintRect.y() + (downcast&lt;RenderBox&gt;(*this).height() - height) / 2, width, height }; // Vertically center the checkbox, like on desktop
1946         }
1947 #endif
1948         addFocusRingRects(focusRingRects, paintRectToUse.location(), paintInfo.paintContainer);
1949         paintFocusRing(paintInfo, styleToUse, focusRingRects);
1950     }
1951 
1952     if (hasOutlineAnnotation() &amp;&amp; styleToUse.outlineStyleIsAuto() == OutlineIsAuto::Off &amp;&amp; !theme().supportsFocusRing(styleToUse))
1953         addPDFURLRect(paintInfo, paintRect.location());
1954 
1955     if (styleToUse.outlineStyleIsAuto() == OutlineIsAuto::On || styleToUse.outlineStyle() == BorderStyle::None)
1956         return;
1957 
1958     FloatRect outer = paintRect;
1959     outer.inflate(outlineOffset + outlineWidth);
1960     FloatRect inner = outer;
1961     inner.inflate(-outlineWidth);
1962 
1963     // FIXME: This prevents outlines from painting inside the object. See bug 12042
1964     if (outer.isEmpty())
1965         return;
1966 
1967     BorderStyle outlineStyle = styleToUse.outlineStyle();
1968     Color outlineColor = styleToUse.visitedDependentColorWithColorFilter(CSSPropertyOutlineColor);
1969 
1970     bool useTransparencyLayer = !outlineColor.isOpaque();
1971     if (useTransparencyLayer) {
1972         if (outlineStyle == BorderStyle::Solid) {
1973             Path path;
1974             path.addRect(outer);
1975             path.addRect(inner);
1976             graphicsContext.setFillRule(WindRule::EvenOdd);
1977             graphicsContext.setFillColor(outlineColor);
1978             graphicsContext.fillPath(path);
1979             return;
1980         }
1981         graphicsContext.beginTransparencyLayer(outlineColor.alphaAsFloat());
1982         outlineColor = outlineColor.opaqueColor();
1983     }
1984 
1985     float leftOuter = outer.x();
1986     float leftInner = inner.x();
1987     float rightOuter = outer.maxX();
1988     float rightInner = std::min(inner.maxX(), rightOuter);
1989     float topOuter = outer.y();
1990     float topInner = inner.y();
1991     float bottomOuter = outer.maxY();
1992     float bottomInner = std::min(inner.maxY(), bottomOuter);
1993 
1994     drawLineForBoxSide(graphicsContext, FloatRect(FloatPoint(leftOuter, topOuter), FloatPoint(leftInner, bottomOuter)), BSLeft, outlineColor, outlineStyle, outlineWidth, outlineWidth);
1995     drawLineForBoxSide(graphicsContext, FloatRect(FloatPoint(leftOuter, topOuter), FloatPoint(rightOuter, topInner)), BSTop, outlineColor, outlineStyle, outlineWidth, outlineWidth);
1996     drawLineForBoxSide(graphicsContext, FloatRect(FloatPoint(rightInner, topOuter), FloatPoint(rightOuter, bottomOuter)), BSRight, outlineColor, outlineStyle, outlineWidth, outlineWidth);
1997     drawLineForBoxSide(graphicsContext, FloatRect(FloatPoint(leftOuter, bottomInner), FloatPoint(rightOuter, bottomOuter)), BSBottom, outlineColor, outlineStyle, outlineWidth, outlineWidth);
1998 
1999     if (useTransparencyLayer)
2000         graphicsContext.endTransparencyLayer();
2001 }
2002 
2003 void RenderElement::issueRepaintForOutlineAuto(float outlineSize)
2004 {
2005     LayoutRect repaintRect;
2006     Vector&lt;LayoutRect&gt; focusRingRects;
2007     addFocusRingRects(focusRingRects, LayoutPoint(), containerForRepaint());
2008     for (auto rect : focusRingRects) {
2009         rect.inflate(outlineSize);
2010         repaintRect.unite(rect);
2011     }
2012     repaintRectangle(repaintRect);
2013 }
2014 
2015 void RenderElement::updateOutlineAutoAncestor(bool hasOutlineAuto)
2016 {
2017     for (auto&amp; child : childrenOfType&lt;RenderObject&gt;(*this)) {
2018         if (hasOutlineAuto == child.hasOutlineAutoAncestor())
2019             continue;
2020         child.setHasOutlineAutoAncestor(hasOutlineAuto);
2021         bool childHasOutlineAuto = child.outlineStyleForRepaint().outlineStyleIsAuto() == OutlineIsAuto::On;
2022         if (childHasOutlineAuto)
2023             continue;
2024         if (!is&lt;RenderElement&gt;(child))
2025             continue;
2026         downcast&lt;RenderElement&gt;(child).updateOutlineAutoAncestor(hasOutlineAuto);
2027     }
2028     if (is&lt;RenderBoxModelObject&gt;(*this)) {
2029         if (auto* continuation = downcast&lt;RenderBoxModelObject&gt;(*this).continuation())
2030             continuation-&gt;updateOutlineAutoAncestor(hasOutlineAuto);
2031     }
2032 }
2033 
2034 bool RenderElement::hasOutlineAnnotation() const
2035 {
2036     return element() &amp;&amp; element()-&gt;isLink() &amp;&amp; document().printing();
2037 }
2038 
2039 bool RenderElement::hasSelfPaintingLayer() const
2040 {
2041     if (!hasLayer())
2042         return false;
2043     auto&amp; layerModelObject = downcast&lt;RenderLayerModelObject&gt;(*this);
2044     return layerModelObject.hasSelfPaintingLayer();
2045 }
2046 
2047 bool RenderElement::checkForRepaintDuringLayout() const
2048 {
2049     if (document().view()-&gt;layoutContext().needsFullRepaint() || !everHadLayout() || hasSelfPaintingLayer())
2050         return false;
2051     return !settings().repaintOutsideLayoutEnabled();
2052 }
2053 
2054 ImageOrientation RenderElement::imageOrientation() const
2055 {
2056 #if USE(CG) || USE(CAIRO) || USE(DIRECT2D)
2057     // This can only be enabled for ports which honor the orientation flag in their drawing code.
2058     if (document().isImageDocument())
2059         return ImageOrientation::FromImage;
2060 #endif
2061     // Respect the image&#39;s orientation if it&#39;s being used as a full-page image or it&#39;s
2062     // an &lt;img&gt; and the setting to respect it everywhere is set.
2063     if (settings().shouldRespectImageOrientation() &amp;&amp; is&lt;HTMLImageElement&gt;(element()))
2064         return ImageOrientation::FromImage;
2065     return style().imageOrientation();
2066 }
2067 
2068 void RenderElement::adjustFragmentedFlowStateOnContainingBlockChangeIfNeeded()
2069 {
2070     if (fragmentedFlowState() == NotInsideFragmentedFlow)
2071         return;
2072 
2073     // Invalidate the containing block caches.
2074     if (is&lt;RenderBlock&gt;(*this))
2075         downcast&lt;RenderBlock&gt;(*this).resetEnclosingFragmentedFlowAndChildInfoIncludingDescendants();
2076 
2077     // Adjust the flow tread state on the subtree.
2078     setFragmentedFlowState(RenderObject::computedFragmentedFlowState(*this));
2079     for (auto&amp; descendant : descendantsOfType&lt;RenderObject&gt;(*this))
2080         descendant.setFragmentedFlowState(RenderObject::computedFragmentedFlowState(descendant));
2081 }
2082 
2083 void RenderElement::removeFromRenderFragmentedFlow()
2084 {
2085     ASSERT(fragmentedFlowState() != NotInsideFragmentedFlow);
2086     // Sometimes we remove the element from the flow, but it&#39;s not destroyed at that time.
2087     // It&#39;s only until later when we actually destroy it and remove all the children from it.
2088     // Currently, that happens for firstLetter elements and list markers.
2089     // Pass in the flow thread so that we don&#39;t have to look it up for all the children.
2090     removeFromRenderFragmentedFlowIncludingDescendants(true);
2091 }
2092 
2093 void RenderElement::removeFromRenderFragmentedFlowIncludingDescendants(bool shouldUpdateState)
2094 {
2095     // Once we reach another flow thread we don&#39;t need to update the flow thread state
2096     // but we have to continue cleanup the flow thread info.
2097     if (isRenderFragmentedFlow())
2098         shouldUpdateState = false;
2099 
2100     for (auto&amp; child : childrenOfType&lt;RenderObject&gt;(*this)) {
2101         if (is&lt;RenderElement&gt;(child)) {
2102             downcast&lt;RenderElement&gt;(child).removeFromRenderFragmentedFlowIncludingDescendants(shouldUpdateState);
2103             continue;
2104         }
2105         if (shouldUpdateState)
2106             child.setFragmentedFlowState(NotInsideFragmentedFlow);
2107     }
2108 
2109     // We have to ask for our containing flow thread as it may be above the removed sub-tree.
2110     RenderFragmentedFlow* enclosingFragmentedFlow = this-&gt;enclosingFragmentedFlow();
2111     while (enclosingFragmentedFlow) {
2112         enclosingFragmentedFlow-&gt;removeFlowChildInfo(*this);
2113 
2114         if (enclosingFragmentedFlow-&gt;fragmentedFlowState() == NotInsideFragmentedFlow)
2115             break;
2116         auto* parent = enclosingFragmentedFlow-&gt;parent();
2117         if (!parent)
2118             break;
2119         enclosingFragmentedFlow = parent-&gt;enclosingFragmentedFlow();
2120     }
2121     if (is&lt;RenderBlock&gt;(*this))
2122         downcast&lt;RenderBlock&gt;(*this).setCachedEnclosingFragmentedFlowNeedsUpdate();
2123 
2124     if (shouldUpdateState)
2125         setFragmentedFlowState(NotInsideFragmentedFlow);
2126 }
2127 
2128 void RenderElement::resetEnclosingFragmentedFlowAndChildInfoIncludingDescendants(RenderFragmentedFlow* fragmentedFlow)
2129 {
2130     if (fragmentedFlow)
2131         fragmentedFlow-&gt;removeFlowChildInfo(*this);
2132 
2133     for (auto&amp; child : childrenOfType&lt;RenderElement&gt;(*this))
2134         child.resetEnclosingFragmentedFlowAndChildInfoIncludingDescendants(fragmentedFlow);
2135 }
2136 
2137 #if ENABLE(TEXT_AUTOSIZING)
2138 static RenderObject::BlockContentHeightType includeNonFixedHeight(const RenderObject&amp; renderer)
2139 {
2140     const RenderStyle&amp; style = renderer.style();
2141     if (style.height().type() == Fixed) {
2142         if (is&lt;RenderBlock&gt;(renderer)) {
2143             // For fixed height styles, if the overflow size of the element spills out of the specified
2144             // height, assume we can apply text auto-sizing.
2145             if (style.overflowY() == Overflow::Visible
2146                 &amp;&amp; style.height().value() &lt; downcast&lt;RenderBlock&gt;(renderer).layoutOverflowRect().maxY())
2147                 return RenderObject::OverflowHeight;
2148         }
2149         return RenderObject::FixedHeight;
2150     }
2151     return RenderObject::FlexibleHeight;
2152 }
2153 
2154 void RenderElement::adjustComputedFontSizesOnBlocks(float size, float visibleWidth)
2155 {
2156     Document* document = view().frameView().frame().document();
2157     if (!document)
2158         return;
2159 
2160     Vector&lt;int&gt; depthStack;
2161     int currentDepth = 0;
2162     int newFixedDepth = 0;
2163 
2164     // We don&#39;t apply autosizing to nodes with fixed height normally.
2165     // But we apply it to nodes which are located deep enough
2166     // (nesting depth is greater than some const) inside of a parent block
2167     // which has fixed height but its content overflows intentionally.
2168     for (RenderObject* descendent = traverseNext(this, includeNonFixedHeight, currentDepth, newFixedDepth); descendent; descendent = descendent-&gt;traverseNext(this, includeNonFixedHeight, currentDepth, newFixedDepth)) {
2169         while (depthStack.size() &gt; 0 &amp;&amp; currentDepth &lt;= depthStack[depthStack.size() - 1])
2170             depthStack.remove(depthStack.size() - 1);
2171         if (newFixedDepth)
2172             depthStack.append(newFixedDepth);
2173 
2174         int stackSize = depthStack.size();
2175         if (is&lt;RenderBlockFlow&gt;(*descendent) &amp;&amp; !descendent-&gt;isListItem() &amp;&amp; (!stackSize || currentDepth - depthStack[stackSize - 1] &gt; TextAutoSizingFixedHeightDepth))
2176             downcast&lt;RenderBlockFlow&gt;(*descendent).adjustComputedFontSizes(size, visibleWidth);
2177         newFixedDepth = 0;
2178     }
2179 
2180     // Remove style from auto-sizing table that are no longer valid.
2181     document-&gt;textAutoSizing().updateRenderTree();
2182 }
2183 
2184 void RenderElement::resetTextAutosizing()
2185 {
2186     Document* document = view().frameView().frame().document();
2187     if (!document)
2188         return;
2189 
2190     LOG(TextAutosizing, &quot;RenderElement::resetTextAutosizing()&quot;);
2191 
2192     document-&gt;textAutoSizing().reset();
2193 
2194     Vector&lt;int&gt; depthStack;
2195     int currentDepth = 0;
2196     int newFixedDepth = 0;
2197 
2198     for (RenderObject* descendent = traverseNext(this, includeNonFixedHeight, currentDepth, newFixedDepth); descendent; descendent = descendent-&gt;traverseNext(this, includeNonFixedHeight, currentDepth, newFixedDepth)) {
2199         while (depthStack.size() &gt; 0 &amp;&amp; currentDepth &lt;= depthStack[depthStack.size() - 1])
2200             depthStack.remove(depthStack.size() - 1);
2201         if (newFixedDepth)
2202             depthStack.append(newFixedDepth);
2203 
2204         int stackSize = depthStack.size();
2205         if (is&lt;RenderBlockFlow&gt;(*descendent) &amp;&amp; !descendent-&gt;isListItem() &amp;&amp; (!stackSize || currentDepth - depthStack[stackSize - 1] &gt; TextAutoSizingFixedHeightDepth))
2206             downcast&lt;RenderBlockFlow&gt;(*descendent).resetComputedFontSize();
2207         newFixedDepth = 0;
2208     }
2209 }
2210 #endif // ENABLE(TEXT_AUTOSIZING)
2211 
2212 }
    </pre>
  </body>
</html>