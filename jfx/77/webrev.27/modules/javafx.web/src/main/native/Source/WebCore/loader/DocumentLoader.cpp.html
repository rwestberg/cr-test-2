<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/loader/DocumentLoader.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2006-2018 Apple Inc. All rights reserved.
   3  * Copyright (C) 2011 Google Inc. All rights reserved.
   4  *
   5  * Redistribution and use in source and binary forms, with or without
   6  * modification, are permitted provided that the following conditions
   7  * are met:
   8  *
   9  * 1.  Redistributions of source code must retain the above copyright
  10  *     notice, this list of conditions and the following disclaimer.
  11  * 2.  Redistributions in binary form must reproduce the above copyright
  12  *     notice, this list of conditions and the following disclaimer in the
  13  *     documentation and/or other materials provided with the distribution.
  14  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
  15  *     its contributors may be used to endorse or promote products derived
  16  *     from this software without specific prior written permission.
  17  *
  18  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
  19  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  20  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  21  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  22  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  23  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  24  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  25  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  26  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  27  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  28  */
  29 
  30 #include &quot;config.h&quot;
  31 #include &quot;DocumentLoader.h&quot;
  32 
  33 #include &quot;ApplicationCacheHost.h&quot;
  34 #include &quot;Archive.h&quot;
  35 #include &quot;ArchiveResourceCollection.h&quot;
  36 #include &quot;CachedPage.h&quot;
  37 #include &quot;CachedRawResource.h&quot;
  38 #include &quot;CachedResourceLoader.h&quot;
  39 #include &quot;ContentExtensionError.h&quot;
  40 #include &quot;ContentSecurityPolicy.h&quot;
  41 #include &quot;CustomHeaderFields.h&quot;
  42 #include &quot;DOMWindow.h&quot;
  43 #include &quot;Document.h&quot;
  44 #include &quot;DocumentParser.h&quot;
  45 #include &quot;DocumentWriter.h&quot;
  46 #include &quot;ElementChildIterator.h&quot;
  47 #include &quot;Event.h&quot;
  48 #include &quot;EventNames.h&quot;
  49 #include &quot;ExtensionStyleSheets.h&quot;
  50 #include &quot;FormState.h&quot;
  51 #include &quot;Frame.h&quot;
  52 #include &quot;FrameLoader.h&quot;
  53 #include &quot;FrameLoaderClient.h&quot;
  54 #include &quot;FrameTree.h&quot;
  55 #include &quot;HTMLFormElement.h&quot;
  56 #include &quot;HTMLFrameOwnerElement.h&quot;
  57 #include &quot;HTTPHeaderNames.h&quot;
  58 #include &quot;HistoryItem.h&quot;
  59 #include &quot;HistoryController.h&quot;
  60 #include &quot;IconLoader.h&quot;
  61 #include &quot;InspectorInstrumentation.h&quot;
  62 #include &quot;LinkIconCollector.h&quot;
  63 #include &quot;LinkIconType.h&quot;
  64 #include &quot;LoaderStrategy.h&quot;
  65 #include &quot;Logging.h&quot;
  66 #include &quot;MemoryCache.h&quot;
  67 #include &quot;NetworkLoadMetrics.h&quot;
  68 #include &quot;Page.h&quot;
  69 #include &quot;PingLoader.h&quot;
  70 #include &quot;PlatformStrategies.h&quot;
  71 #include &quot;PolicyChecker.h&quot;
  72 #include &quot;ProgressTracker.h&quot;
  73 #include &quot;ResourceHandle.h&quot;
  74 #include &quot;ResourceLoadObserver.h&quot;
  75 #include &quot;RuntimeEnabledFeatures.h&quot;
  76 #include &quot;SWClientConnection.h&quot;
  77 #include &quot;SchemeRegistry.h&quot;
  78 #include &quot;ScriptableDocumentParser.h&quot;
  79 #include &quot;SecurityPolicy.h&quot;
  80 #include &quot;ServiceWorker.h&quot;
  81 #include &quot;ServiceWorkerClientData.h&quot;
  82 #include &quot;ServiceWorkerProvider.h&quot;
  83 #include &quot;Settings.h&quot;
  84 #include &quot;SubresourceLoader.h&quot;
  85 #include &quot;TextResourceDecoder.h&quot;
  86 #include &lt;wtf/Assertions.h&gt;
  87 #include &lt;wtf/CompletionHandler.h&gt;
  88 #include &lt;wtf/NeverDestroyed.h&gt;
  89 #include &lt;wtf/Ref.h&gt;
  90 #include &lt;wtf/text/CString.h&gt;
  91 #include &lt;wtf/text/WTFString.h&gt;
  92 
  93 #if ENABLE(APPLICATION_MANIFEST)
  94 #include &quot;ApplicationManifestLoader.h&quot;
  95 #include &quot;HTMLHeadElement.h&quot;
  96 #include &quot;HTMLLinkElement.h&quot;
  97 #endif
  98 
  99 #if ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)
 100 #include &quot;ArchiveFactory.h&quot;
 101 #endif
 102 
 103 #if ENABLE(CONTENT_FILTERING)
 104 #include &quot;ContentFilter.h&quot;
 105 #endif
 106 
 107 #if USE(QUICK_LOOK)
 108 #include &quot;PreviewConverter.h&quot;
 109 #include &quot;QuickLook.h&quot;
 110 #endif
 111 
 112 #define RELEASE_LOG_IF_ALLOWED(fmt, ...) RELEASE_LOG_IF(isAlwaysOnLoggingAllowed(), Network, &quot;%p - DocumentLoader::&quot; fmt, this, ##__VA_ARGS__)
 113 
 114 namespace WebCore {
 115 
 116 static void cancelAll(const ResourceLoaderMap&amp; loaders)
 117 {
 118     for (auto&amp; loader : copyToVector(loaders.values()))
 119         loader-&gt;cancel();
 120 }
 121 
 122 static void setAllDefersLoading(const ResourceLoaderMap&amp; loaders, bool defers)
 123 {
 124     for (auto&amp; loader : copyToVector(loaders.values()))
 125         loader-&gt;setDefersLoading(defers);
 126 }
 127 
 128 static bool shouldPendingCachedResourceLoadPreventPageCache(CachedResource&amp; cachedResource)
 129 {
 130     if (!cachedResource.isLoading())
 131         return false;
 132 
 133     switch (cachedResource.type()) {
 134     case CachedResource::Type::ImageResource:
 135     case CachedResource::Type::Icon:
 136     case CachedResource::Type::Beacon:
 137     case CachedResource::Type::Ping:
 138     case CachedResource::Type::LinkPrefetch:
 139         return false;
 140     case CachedResource::Type::MainResource:
 141     case CachedResource::Type::CSSStyleSheet:
 142     case CachedResource::Type::Script:
 143     case CachedResource::Type::FontResource:
 144 #if ENABLE(SVG_FONTS)
 145     case CachedResource::Type::SVGFontResource:
 146 #endif
 147     case CachedResource::Type::MediaResource:
 148     case CachedResource::Type::RawResource:
 149     case CachedResource::Type::SVGDocumentResource:
 150 #if ENABLE(XSLT)
 151     case CachedResource::Type::XSLStyleSheet:
 152 #endif
 153 #if ENABLE(VIDEO_TRACK)
 154     case CachedResource::Type::TextTrackResource:
 155 #endif
 156 #if ENABLE(APPLICATION_MANIFEST)
 157     case CachedResource::Type::ApplicationManifest:
 158 #endif
 159         break;
 160     };
 161     return !cachedResource.areAllClientsXMLHttpRequests();
 162 }
 163 
 164 static bool areAllLoadersPageCacheAcceptable(const ResourceLoaderMap&amp; loaders)
 165 {
 166     for (auto&amp; loader : copyToVector(loaders.values())) {
 167         if (!loader-&gt;frameLoader() || !loader-&gt;frameLoader()-&gt;frame().page())
 168             return false;
 169 
 170         CachedResource* cachedResource = MemoryCache::singleton().resourceForRequest(loader-&gt;request(), loader-&gt;frameLoader()-&gt;frame().page()-&gt;sessionID());
 171         if (!cachedResource)
 172             return false;
 173 
 174         // Only image and XHR loads do not prevent the page from entering the PageCache.
 175         // All non-image loads will prevent the page from entering the PageCache.
 176         if (shouldPendingCachedResourceLoadPreventPageCache(*cachedResource))
 177             return false;
 178     }
 179     return true;
 180 }
 181 
 182 DocumentLoader::DocumentLoader(const ResourceRequest&amp; request, const SubstituteData&amp; substituteData)
 183     : FrameDestructionObserver(nullptr)
 184     , m_cachedResourceLoader(CachedResourceLoader::create(this))
 185     , m_originalRequest(request)
 186     , m_substituteData(substituteData)
 187     , m_originalRequestCopy(request)
 188     , m_request(request)
 189     , m_originalSubstituteDataWasValid(substituteData.isValid())
 190     , m_substituteResourceDeliveryTimer(*this, &amp;DocumentLoader::substituteResourceDeliveryTimerFired)
 191     , m_dataLoadTimer(*this, &amp;DocumentLoader::handleSubstituteDataLoadNow)
 192     , m_applicationCacheHost(makeUnique&lt;ApplicationCacheHost&gt;(*this))
 193 {
 194 }
 195 
 196 FrameLoader* DocumentLoader::frameLoader() const
 197 {
 198     if (!m_frame)
 199         return nullptr;
 200     return &amp;m_frame-&gt;loader();
 201 }
 202 
 203 SubresourceLoader* DocumentLoader::mainResourceLoader() const
 204 {
 205     if (!m_mainResource)
 206         return nullptr;
 207     return m_mainResource-&gt;loader();
 208 }
 209 
 210 DocumentLoader::~DocumentLoader()
 211 {
 212     ASSERT(!m_frame || !isLoading() || frameLoader()-&gt;activeDocumentLoader() != this);
 213     ASSERT_WITH_MESSAGE(!m_waitingForContentPolicy, &quot;The content policy callback should never outlive its DocumentLoader.&quot;);
 214     ASSERT_WITH_MESSAGE(!m_waitingForNavigationPolicy, &quot;The navigation policy callback should never outlive its DocumentLoader.&quot;);
 215 
 216     m_cachedResourceLoader-&gt;clearDocumentLoader();
 217     clearMainResource();
 218 }
 219 
 220 RefPtr&lt;SharedBuffer&gt; DocumentLoader::mainResourceData() const
 221 {
 222     if (m_substituteData.isValid())
 223         return m_substituteData.content()-&gt;copy();
 224     if (m_mainResource)
 225         return m_mainResource-&gt;resourceBuffer();
 226     return nullptr;
 227 }
 228 
 229 Document* DocumentLoader::document() const
 230 {
 231     if (m_frame &amp;&amp; m_frame-&gt;loader().documentLoader() == this)
 232         return m_frame-&gt;document();
 233     return nullptr;
 234 }
 235 
 236 void DocumentLoader::replaceRequestURLForSameDocumentNavigation(const URL&amp; url)
 237 {
 238     m_originalRequestCopy.setURL(url);
 239     m_request.setURL(url);
 240 }
 241 
 242 void DocumentLoader::setRequest(const ResourceRequest&amp; req)
 243 {
 244     // Replacing an unreachable URL with alternate content looks like a server-side
 245     // redirect at this point, but we can replace a committed dataSource.
 246     bool handlingUnreachableURL = false;
 247 
 248     handlingUnreachableURL = m_substituteData.isValid() &amp;&amp; !m_substituteData.failingURL().isEmpty();
 249 
 250     bool shouldNotifyAboutProvisionalURLChange = false;
 251     if (handlingUnreachableURL)
 252         m_committed = false;
 253     else if (isLoadingMainResource() &amp;&amp; req.url() != m_request.url())
 254         shouldNotifyAboutProvisionalURLChange = true;
 255 
 256     // We should never be getting a redirect callback after the data
 257     // source is committed, except in the unreachable URL case. It
 258     // would be a WebFoundation bug if it sent a redirect callback after commit.
 259     ASSERT(!m_committed);
 260 
 261     m_request = req;
 262     if (shouldNotifyAboutProvisionalURLChange)
 263         frameLoader()-&gt;client().dispatchDidChangeProvisionalURL();
 264 }
 265 
 266 void DocumentLoader::setMainDocumentError(const ResourceError&amp; error)
 267 {
 268     if (!error.isNull())
 269         RELEASE_LOG_IF_ALLOWED(&quot;setMainDocumentError: (frame = %p, main = %d, type = %d, code = %d)&quot;, m_frame, m_frame-&gt;isMainFrame(), static_cast&lt;int&gt;(error.type()), error.errorCode());
 270 
 271     m_mainDocumentError = error;
 272     frameLoader()-&gt;client().setMainDocumentError(this, error);
 273 }
 274 
 275 void DocumentLoader::mainReceivedError(const ResourceError&amp; error)
 276 {
 277     ASSERT(!error.isNull());
 278 
 279     if (!frameLoader())
 280         return;
 281 
 282     if (!error.isNull())
 283         RELEASE_LOG_IF_ALLOWED(&quot;mainReceivedError: (frame = %p, main = %d, type = %d, code = %d)&quot;, m_frame, m_frame-&gt;isMainFrame(), static_cast&lt;int&gt;(error.type()), error.errorCode());
 284 
 285     if (m_identifierForLoadWithoutResourceLoader) {
 286         ASSERT(!mainResourceLoader());
 287         frameLoader()-&gt;client().dispatchDidFailLoading(this, m_identifierForLoadWithoutResourceLoader, error);
 288     }
 289 
 290     // There is a bug in CFNetwork where callbacks can be dispatched even when loads are deferred.
 291     // See &lt;rdar://problem/6304600&gt; for more details.
 292 #if !USE(CF)
 293     ASSERT(!mainResourceLoader() || !mainResourceLoader()-&gt;defersLoading());
 294 #endif
 295 
 296     m_applicationCacheHost-&gt;failedLoadingMainResource();
 297 
 298     setMainDocumentError(error);
 299     clearMainResourceLoader();
 300     frameLoader()-&gt;receivedMainResourceError(error);
 301 }
 302 
 303 // Cancels the data source&#39;s pending loads.  Conceptually, a data source only loads
 304 // one document at a time, but one document may have many related resources.
 305 // stopLoading will stop all loads initiated by the data source,
 306 // but not loads initiated by child frames&#39; data sources -- that&#39;s the WebFrame&#39;s job.
 307 void DocumentLoader::stopLoading()
 308 {
 309     RefPtr&lt;Frame&gt; protectedFrame(m_frame);
 310     Ref&lt;DocumentLoader&gt; protectedThis(*this);
 311 
 312     // In some rare cases, calling FrameLoader::stopLoading could cause isLoading() to return false.
 313     // (This can happen when there&#39;s a single XMLHttpRequest currently loading and stopLoading causes it
 314     // to stop loading. Because of this, we need to save it so we don&#39;t return early.
 315     bool loading = isLoading();
 316 
 317     // We may want to audit the existing subresource loaders when we are on a page which has completed
 318     // loading but there are subresource loads during cancellation. This must be done before the
 319     // frame-&gt;stopLoading() call, which may evict the CachedResources, which we rely on to check
 320     // the type of the resource loads.
 321     if (loading &amp;&amp; m_committed &amp;&amp; !mainResourceLoader() &amp;&amp; !m_subresourceLoaders.isEmpty())
 322         m_subresourceLoadersArePageCacheAcceptable = areAllLoadersPageCacheAcceptable(m_subresourceLoaders);
 323 
 324     if (m_committed) {
 325         // Attempt to stop the frame if the document loader is loading, or if it is done loading but
 326         // still  parsing. Failure to do so can cause a world leak.
 327         Document* doc = m_frame-&gt;document();
 328 
 329         if (loading || doc-&gt;parsing())
 330             m_frame-&gt;loader().stopLoading(UnloadEventPolicyNone);
 331     }
 332 
 333     for (auto callbackIdentifier : m_iconLoaders.values())
 334         notifyFinishedLoadingIcon(callbackIdentifier, nullptr);
 335     m_iconLoaders.clear();
 336     m_iconsPendingLoadDecision.clear();
 337 
 338 #if ENABLE(APPLICATION_MANIFEST)
 339     for (auto callbackIdentifier : m_applicationManifestLoaders.values())
 340         notifyFinishedLoadingApplicationManifest(callbackIdentifier, WTF::nullopt);
 341     m_applicationManifestLoaders.clear();
 342 #endif
 343 
 344     // Always cancel multipart loaders
 345     cancelAll(m_multipartSubresourceLoaders);
 346 
 347     // Appcache uses ResourceHandle directly, DocumentLoader doesn&#39;t count these loads.
 348     m_applicationCacheHost-&gt;stopLoadingInFrame(*m_frame);
 349 
 350 #if ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)
 351     clearArchiveResources();
 352 #endif
 353 
 354     if (!loading) {
 355         // If something above restarted loading we might run into mysterious crashes like
 356         // https://bugs.webkit.org/show_bug.cgi?id=62764 and &lt;rdar://problem/9328684&gt;
 357         ASSERT(!isLoading());
 358         return;
 359     }
 360 
 361     // We might run in to infinite recursion if we&#39;re stopping loading as the result of
 362     // detaching from the frame, so break out of that recursion here.
 363     // See &lt;rdar://problem/9673866&gt; for more details.
 364     if (m_isStopping)
 365         return;
 366 
 367     m_isStopping = true;
 368 
 369     // The frame may have been detached from this document by the onunload handler
 370     if (auto* frameLoader = DocumentLoader::frameLoader()) {
 371         RELEASE_LOG_IF_ALLOWED(&quot;stopLoading: canceling load (frame = %p, main = %d)&quot;, m_frame, m_frame-&gt;isMainFrame());
 372         if (isLoadingMainResource()) {
 373             // Stop the main resource loader and let it send the cancelled message.
 374             cancelMainResourceLoad(frameLoader-&gt;cancelledError(m_request));
 375         } else if (!m_subresourceLoaders.isEmpty() || !m_plugInStreamLoaders.isEmpty()) {
 376             // The main resource loader already finished loading. Set the cancelled error on the
 377             // document and let the subresourceLoaders and pluginLoaders send individual cancelled messages below.
 378             setMainDocumentError(frameLoader-&gt;cancelledError(m_request));
 379         } else {
 380             // If there are no resource loaders, we need to manufacture a cancelled message.
 381             // (A back/forward navigation has no resource loaders because its resources are cached.)
 382             mainReceivedError(frameLoader-&gt;cancelledError(m_request));
 383         }
 384     }
 385 
 386     // We always need to explicitly cancel the Document&#39;s parser when stopping the load.
 387     // Otherwise cancelling the parser while starting the next page load might result
 388     // in unexpected side effects such as erroneous event dispatch. ( http://webkit.org/b/117112 )
 389     if (Document* document = this-&gt;document())
 390         document-&gt;cancelParsing();
 391 
 392     stopLoadingSubresources();
 393     stopLoadingPlugIns();
 394 
 395     m_isStopping = false;
 396 }
 397 
 398 void DocumentLoader::commitIfReady()
 399 {
 400     if (!m_committed) {
 401         m_committed = true;
 402         frameLoader()-&gt;commitProvisionalLoad();
 403     }
 404 }
 405 
 406 bool DocumentLoader::isLoading() const
 407 {
 408     // if (document() &amp;&amp; document()-&gt;hasActiveParser())
 409     //     return true;
 410     // FIXME: The above code should be enabled, but it seems to cause
 411     // http/tests/security/feed-urls-from-remote.html to timeout on Mac WK1
 412     // see http://webkit.org/b/110554 and http://webkit.org/b/110401
 413 
 414     return isLoadingMainResource() || !m_subresourceLoaders.isEmpty() || !m_plugInStreamLoaders.isEmpty();
 415 }
 416 
 417 void DocumentLoader::notifyFinished(CachedResource&amp; resource)
 418 {
 419     ASSERT(isMainThread());
 420 #if ENABLE(CONTENT_FILTERING)
 421     if (m_contentFilter &amp;&amp; !m_contentFilter-&gt;continueAfterNotifyFinished(resource))
 422         return;
 423 #endif
 424 
 425     ASSERT_UNUSED(resource, m_mainResource == &amp;resource);
 426     ASSERT(m_mainResource);
 427     if (!m_mainResource-&gt;errorOccurred() &amp;&amp; !m_mainResource-&gt;wasCanceled()) {
 428         finishedLoading();
 429         return;
 430     }
 431 
 432     if (m_request.cachePolicy() == ResourceRequestCachePolicy::ReturnCacheDataDontLoad &amp;&amp; !m_mainResource-&gt;wasCanceled()) {
 433         frameLoader()-&gt;retryAfterFailedCacheOnlyMainResourceLoad();
 434         return;
 435     }
 436 
 437     if (!m_mainResource-&gt;resourceError().isNull())
 438         RELEASE_LOG_IF_ALLOWED(&quot;notifyFinished: canceling load (frame = %p, main = %d)&quot;, m_frame, m_frame-&gt;isMainFrame());
 439 
 440     mainReceivedError(m_mainResource-&gt;resourceError());
 441 }
 442 
 443 void DocumentLoader::finishedLoading()
 444 {
 445     // There is a bug in CFNetwork where callbacks can be dispatched even when loads are deferred.
 446     // See &lt;rdar://problem/6304600&gt; for more details.
 447 #if !USE(CF)
 448     ASSERT(!m_frame-&gt;page()-&gt;defersLoading() || frameLoader()-&gt;stateMachine().creatingInitialEmptyDocument() || InspectorInstrumentation::isDebuggerPaused(m_frame));
 449 #endif
 450 
 451     Ref&lt;DocumentLoader&gt; protectedThis(*this);
 452 
 453     if (m_identifierForLoadWithoutResourceLoader) {
 454         // A didFinishLoading delegate might try to cancel the load (despite it
 455         // being finished). Clear m_identifierForLoadWithoutResourceLoader
 456         // before calling dispatchDidFinishLoading so that we don&#39;t later try to
 457         // cancel the already-finished substitute load.
 458         NetworkLoadMetrics emptyMetrics;
 459         unsigned long identifier = m_identifierForLoadWithoutResourceLoader;
 460         m_identifierForLoadWithoutResourceLoader = 0;
 461         frameLoader()-&gt;notifier().dispatchDidFinishLoading(this, identifier, emptyMetrics, nullptr);
 462     }
 463 
 464     maybeFinishLoadingMultipartContent();
 465 
 466     MonotonicTime responseEndTime = m_timeOfLastDataReceived ? m_timeOfLastDataReceived : MonotonicTime::now();
 467     timing().setResponseEnd(responseEndTime);
 468 
 469     commitIfReady();
 470     if (!frameLoader())
 471         return;
 472 
 473     if (!maybeCreateArchive()) {
 474         // If this is an empty document, it will not have actually been created yet. Commit dummy data so that
 475         // DocumentWriter::begin() gets called and creates the Document.
 476         if (!m_gotFirstByte)
 477             commitData(0, 0);
 478         frameLoader()-&gt;client().finishedLoading(this);
 479     }
 480 
 481     m_writer.end();
 482     if (!m_mainDocumentError.isNull())
 483         return;
 484     clearMainResourceLoader();
 485     if (!frameLoader())
 486         return;
 487     if (!frameLoader()-&gt;stateMachine().creatingInitialEmptyDocument())
 488         frameLoader()-&gt;checkLoadComplete();
 489 
 490     // If the document specified an application cache manifest, it violates the author&#39;s intent if we store it in the memory cache
 491     // and deny the appcache the chance to intercept it in the future, so remove from the memory cache.
 492     if (m_frame) {
 493         if (m_mainResource &amp;&amp; m_frame-&gt;document()-&gt;hasManifest())
 494             MemoryCache::singleton().remove(*m_mainResource);
 495     }
 496     m_applicationCacheHost-&gt;finishedLoadingMainResource();
 497 }
 498 
 499 bool DocumentLoader::isPostOrRedirectAfterPost(const ResourceRequest&amp; newRequest, const ResourceResponse&amp; redirectResponse)
 500 {
 501     if (newRequest.httpMethod() == &quot;POST&quot;)
 502         return true;
 503 
 504     int status = redirectResponse.httpStatusCode();
 505     if (((status &gt;= 301 &amp;&amp; status &lt;= 303) || status == 307)
 506         &amp;&amp; m_originalRequest.httpMethod() == &quot;POST&quot;)
 507         return true;
 508 
 509     return false;
 510 }
 511 
 512 void DocumentLoader::handleSubstituteDataLoadNow()
 513 {
 514     ResourceResponse response = m_substituteData.response();
 515     if (response.url().isEmpty())
 516         response = ResourceResponse(m_request.url(), m_substituteData.mimeType(), m_substituteData.content()-&gt;size(), m_substituteData.textEncoding());
 517 
 518     responseReceived(response, nullptr);
 519 }
 520 
 521 void DocumentLoader::startDataLoadTimer()
 522 {
 523     m_dataLoadTimer.startOneShot(0_s);
 524 
 525 #if HAVE(RUNLOOP_TIMER)
 526     if (SchedulePairHashSet* scheduledPairs = m_frame-&gt;page()-&gt;scheduledRunLoopPairs())
 527         m_dataLoadTimer.schedule(*scheduledPairs);
 528 #endif
 529 }
 530 
 531 #if ENABLE(SERVICE_WORKER)
 532 void DocumentLoader::matchRegistration(const URL&amp; url, SWClientConnection::RegistrationCallback&amp;&amp; callback)
 533 {
 534     auto shouldTryLoadingThroughServiceWorker = !frameLoader()-&gt;isReloadingFromOrigin() &amp;&amp; m_frame-&gt;page() &amp;&amp; RuntimeEnabledFeatures::sharedFeatures().serviceWorkerEnabled() &amp;&amp; SchemeRegistry::canServiceWorkersHandleURLScheme(url.protocol().toStringWithoutCopying());
 535     if (!shouldTryLoadingThroughServiceWorker) {
 536         callback(WTF::nullopt);
 537         return;
 538     }
 539 
 540     auto origin = (!m_frame-&gt;isMainFrame() &amp;&amp; m_frame-&gt;document()) ? m_frame-&gt;document()-&gt;topOrigin().data() : SecurityOriginData::fromURL(url);
 541     auto sessionID = m_frame-&gt;page()-&gt;sessionID();
 542     auto&amp; provider = ServiceWorkerProvider::singleton();
 543     if (!provider.mayHaveServiceWorkerRegisteredForOrigin(sessionID, origin)) {
 544         callback(WTF::nullopt);
 545         return;
 546     }
 547 
 548     auto&amp; connection = ServiceWorkerProvider::singleton().serviceWorkerConnectionForSession(sessionID);
 549     connection.matchRegistration(WTFMove(origin), url, WTFMove(callback));
 550 }
 551 
 552 static inline bool areRegistrationsEqual(const Optional&lt;ServiceWorkerRegistrationData&gt;&amp; a, const Optional&lt;ServiceWorkerRegistrationData&gt;&amp; b)
 553 {
 554     if (!a)
 555         return !b;
 556     if (!b)
 557         return false;
 558     return a-&gt;identifier == b-&gt;identifier;
 559 }
 560 #endif
 561 
 562 void DocumentLoader::redirectReceived(CachedResource&amp; resource, ResourceRequest&amp;&amp; request, const ResourceResponse&amp; redirectResponse, CompletionHandler&lt;void(ResourceRequest&amp;&amp;)&gt;&amp;&amp; completionHandler)
 563 {
 564     ASSERT_UNUSED(resource, &amp;resource == m_mainResource);
 565 #if ENABLE(SERVICE_WORKER)
 566     bool isRedirectionFromServiceWorker = redirectResponse.source() == ResourceResponse::Source::ServiceWorker;
 567     willSendRequest(WTFMove(request), redirectResponse, [isRedirectionFromServiceWorker, completionHandler = WTFMove(completionHandler), protectedThis = makeRef(*this), this] (auto&amp;&amp; request) mutable {
 568         ASSERT(!m_substituteData.isValid());
 569         if (request.isNull() || !m_mainDocumentError.isNull() || !m_frame) {
 570             completionHandler({ });
 571             return;
 572         }
 573 
 574         auto url = request.url();
 575         this-&gt;matchRegistration(url, [request = WTFMove(request), isRedirectionFromServiceWorker, completionHandler = WTFMove(completionHandler), protectedThis = WTFMove(protectedThis), this] (auto&amp;&amp; registrationData) mutable {
 576             if (!m_mainDocumentError.isNull() || !m_frame) {
 577                 completionHandler({ });
 578                 return;
 579             }
 580 
 581             if (!registrationData &amp;&amp; this-&gt;tryLoadingRedirectRequestFromApplicationCache(request)) {
 582                 completionHandler({ });
 583                 return;
 584             }
 585 
 586             bool shouldContinueLoad = areRegistrationsEqual(m_serviceWorkerRegistrationData, registrationData)
 587                 &amp;&amp; isRedirectionFromServiceWorker == !!registrationData;
 588 
 589             if (shouldContinueLoad) {
 590                 completionHandler(WTFMove(request));
 591                 return;
 592             }
 593 
 594             this-&gt;restartLoadingDueToServiceWorkerRegistrationChange(WTFMove(request), WTFMove(registrationData));
 595             completionHandler({ });
 596             return;
 597         });
 598     });
 599 #else
 600     willSendRequest(WTFMove(request), redirectResponse, WTFMove(completionHandler));
 601 #endif
 602 }
 603 
 604 void DocumentLoader::willSendRequest(ResourceRequest&amp;&amp; newRequest, const ResourceResponse&amp; redirectResponse, CompletionHandler&lt;void(ResourceRequest&amp;&amp;)&gt;&amp;&amp; completionHandler)
 605 {
 606     // Note that there are no asserts here as there are for the other callbacks. This is due to the
 607     // fact that this &quot;callback&quot; is sent when starting every load, and the state of callback
 608     // deferrals plays less of a part in this function in preventing the bad behavior deferring
 609     // callbacks is meant to prevent.
 610     ASSERT(!newRequest.isNull());
 611 
 612     bool didReceiveRedirectResponse = !redirectResponse.isNull();
 613     if (!frameLoader()-&gt;checkIfFormActionAllowedByCSP(newRequest.url(), didReceiveRedirectResponse)) {
 614         RELEASE_LOG_IF_ALLOWED(&quot;willSendRequest: canceling - form action not allowed by CSP (frame = %p, main = %d)&quot;, m_frame, m_frame-&gt;isMainFrame());
 615         cancelMainResourceLoad(frameLoader()-&gt;cancelledError(newRequest));
 616         return completionHandler(WTFMove(newRequest));
 617     }
 618 
 619     ASSERT(timing().fetchStart());
 620     if (didReceiveRedirectResponse) {
 621         // If the redirecting url is not allowed to display content from the target origin,
 622         // then block the redirect.
 623         Ref&lt;SecurityOrigin&gt; redirectingOrigin(SecurityOrigin::create(redirectResponse.url()));
 624         if (!redirectingOrigin.get().canDisplay(newRequest.url())) {
 625             RELEASE_LOG_IF_ALLOWED(&quot;willSendRequest: canceling - redirecting URL not allowed to display content from target(frame = %p, main = %d)&quot;, m_frame, m_frame-&gt;isMainFrame());
 626             FrameLoader::reportLocalLoadFailed(m_frame, newRequest.url().string());
 627             cancelMainResourceLoad(frameLoader()-&gt;cancelledError(newRequest));
 628             return completionHandler(WTFMove(newRequest));
 629         }
 630         if (!portAllowed(newRequest.url())) {
 631             RELEASE_LOG_IF_ALLOWED(&quot;willSendRequest: canceling - port not allowed (frame = %p, main = %d)&quot;, m_frame, m_frame-&gt;isMainFrame());
 632             FrameLoader::reportBlockedPortFailed(m_frame, newRequest.url().string());
 633             cancelMainResourceLoad(frameLoader()-&gt;blockedError(newRequest));
 634             return completionHandler(WTFMove(newRequest));
 635         }
 636         timing().addRedirect(redirectResponse.url(), newRequest.url());
 637     }
 638 
 639     ASSERT(m_frame);
 640 
 641     Frame&amp; topFrame = m_frame-&gt;tree().top();
 642 
 643     ASSERT(m_frame-&gt;document());
 644     ASSERT(topFrame.document());
 645 
 646     // Update cookie policy base URL as URL changes, except for subframes, which use the
 647     // URL of the main frame which doesn&#39;t change when we redirect.
 648     if (m_frame-&gt;isMainFrame())
 649         newRequest.setFirstPartyForCookies(newRequest.url());
 650 
 651     FrameLoader::addSameSiteInfoToRequestIfNeeded(newRequest, m_frame-&gt;document());
 652 
 653     if (!didReceiveRedirectResponse)
 654         frameLoader()-&gt;client().dispatchWillChangeDocument(m_frame-&gt;document()-&gt;url(), newRequest.url());
 655 
 656     // If we&#39;re fielding a redirect in response to a POST, force a load from origin, since
 657     // this is a common site technique to return to a page viewing some data that the POST
 658     // just modified.
 659     // Also, POST requests always load from origin, but this does not affect subresources.
 660     if (newRequest.cachePolicy() == ResourceRequestCachePolicy::UseProtocolCachePolicy &amp;&amp; isPostOrRedirectAfterPost(newRequest, redirectResponse))
 661         newRequest.setCachePolicy(ResourceRequestCachePolicy::ReloadIgnoringCacheData);
 662 
 663     if (&amp;topFrame != m_frame) {
 664         if (!m_frame-&gt;loader().mixedContentChecker().canDisplayInsecureContent(m_frame-&gt;document()-&gt;securityOrigin(), MixedContentChecker::ContentType::Active, newRequest.url(), MixedContentChecker::AlwaysDisplayInNonStrictMode::Yes)) {
 665             cancelMainResourceLoad(frameLoader()-&gt;cancelledError(newRequest));
 666             return completionHandler(WTFMove(newRequest));
 667         }
 668         if (!frameLoader()-&gt;mixedContentChecker().canDisplayInsecureContent(topFrame.document()-&gt;securityOrigin(), MixedContentChecker::ContentType::Active, newRequest.url())) {
 669             cancelMainResourceLoad(frameLoader()-&gt;cancelledError(newRequest));
 670             return completionHandler(WTFMove(newRequest));
 671         }
 672     }
 673 
 674 #if ENABLE(CONTENT_FILTERING)
 675     if (m_contentFilter &amp;&amp; !m_contentFilter-&gt;continueAfterWillSendRequest(newRequest, redirectResponse))
 676         return completionHandler(WTFMove(newRequest));
 677 #endif
 678 
 679     setRequest(newRequest);
 680 
 681     if (!didReceiveRedirectResponse)
 682         return completionHandler(WTFMove(newRequest));
 683 
 684     auto navigationPolicyCompletionHandler = [this, protectedThis = makeRef(*this), completionHandler = WTFMove(completionHandler)] (ResourceRequest&amp;&amp; request, WeakPtr&lt;FormState&gt;&amp;&amp;, NavigationPolicyDecision navigationPolicyDecision) mutable {
 685         m_waitingForNavigationPolicy = false;
 686         switch (navigationPolicyDecision) {
 687         case NavigationPolicyDecision::IgnoreLoad:
 688         case NavigationPolicyDecision::StopAllLoads:
 689             stopLoadingForPolicyChange();
 690             break;
 691         case NavigationPolicyDecision::ContinueLoad:
 692             break;
 693         }
 694 
 695         completionHandler(WTFMove(request));
 696     };
 697 
 698     ASSERT(!m_waitingForNavigationPolicy);
 699     m_waitingForNavigationPolicy = true;
 700 
 701     // FIXME: Add a load type check.
 702     auto&amp; policyChecker = frameLoader()-&gt;policyChecker();
 703     RELEASE_ASSERT(!isBackForwardLoadType(policyChecker.loadType()) || frameLoader()-&gt;history().provisionalItem());
 704     policyChecker.checkNavigationPolicy(WTFMove(newRequest), redirectResponse, WTFMove(navigationPolicyCompletionHandler));
 705 }
 706 
 707 bool DocumentLoader::tryLoadingRequestFromApplicationCache()
 708 {
 709     m_applicationCacheHost-&gt;maybeLoadMainResource(m_request, m_substituteData);
 710     return tryLoadingSubstituteData();
 711 }
 712 
 713 bool DocumentLoader::tryLoadingSubstituteData()
 714 {
 715     if (!m_substituteData.isValid() || !m_frame-&gt;page())
 716         return false;
 717 
 718     RELEASE_LOG_IF_ALLOWED(&quot;startLoadingMainResource: Returning substitute data (frame = %p, main = %d)&quot;, m_frame, m_frame-&gt;isMainFrame());
 719     m_identifierForLoadWithoutResourceLoader = m_frame-&gt;page()-&gt;progress().createUniqueIdentifier();
 720     frameLoader()-&gt;notifier().assignIdentifierToInitialRequest(m_identifierForLoadWithoutResourceLoader, this, m_request);
 721     frameLoader()-&gt;notifier().dispatchWillSendRequest(this, m_identifierForLoadWithoutResourceLoader, m_request, ResourceResponse());
 722 
 723     if (!m_deferMainResourceDataLoad || frameLoader()-&gt;loadsSynchronously())
 724         handleSubstituteDataLoadNow();
 725     else
 726         startDataLoadTimer();
 727 
 728     return true;
 729 }
 730 
 731 bool DocumentLoader::tryLoadingRedirectRequestFromApplicationCache(const ResourceRequest&amp; request)
 732 {
 733     m_applicationCacheHost-&gt;maybeLoadMainResourceForRedirect(request, m_substituteData);
 734     if (!m_substituteData.isValid())
 735         return false;
 736 
 737     RELEASE_ASSERT(m_mainResource);
 738     auto* loader = m_mainResource-&gt;loader();
 739     m_identifierForLoadWithoutResourceLoader = loader ? loader-&gt;identifier() : m_mainResource-&gt;identifierForLoadWithoutResourceLoader();
 740 
 741     // We need to remove our reference to the CachedResource in favor of a SubstituteData load, which can triger the cancellation of the underyling ResourceLoader.
 742     // If the ResourceLoader is indeed cancelled, it would normally send resource load callbacks.
 743     // Therefore, sever our relationship with the network load but prevent the ResourceLoader from sending ResourceLoadNotifier callbacks.
 744 
 745     auto resourceLoader = makeRefPtr(mainResourceLoader());
 746     if (resourceLoader) {
 747         ASSERT(resourceLoader-&gt;shouldSendResourceLoadCallbacks());
 748         resourceLoader-&gt;setSendCallbackPolicy(SendCallbackPolicy::DoNotSendCallbacks);
 749     }
 750 
 751     clearMainResource();
 752 
 753     if (resourceLoader)
 754         resourceLoader-&gt;setSendCallbackPolicy(SendCallbackPolicy::SendCallbacks);
 755 
 756     handleSubstituteDataLoadNow();
 757     return true;
 758 }
 759 
 760 #if ENABLE(SERVICE_WORKER)
 761 void DocumentLoader::restartLoadingDueToServiceWorkerRegistrationChange(ResourceRequest&amp;&amp; request, Optional&lt;ServiceWorkerRegistrationData&gt;&amp;&amp; registrationData)
 762 {
 763     clearMainResource();
 764 
 765     ASSERT(!isCommitted());
 766     m_serviceWorkerRegistrationData = WTFMove(registrationData);
 767     loadMainResource(WTFMove(request));
 768 
 769     if (m_mainResource)
 770         frameLoader()-&gt;client().dispatchDidReceiveServerRedirectForProvisionalLoad();
 771 }
 772 #endif
 773 
 774 void DocumentLoader::stopLoadingAfterXFrameOptionsOrContentSecurityPolicyDenied(unsigned long identifier, const ResourceResponse&amp; response)
 775 {
 776     Ref&lt;DocumentLoader&gt; protectedThis { *this };
 777     InspectorInstrumentation::continueAfterXFrameOptionsDenied(*m_frame, identifier, *this, response);
 778     m_frame-&gt;document()-&gt;enforceSandboxFlags(SandboxOrigin);
 779     if (HTMLFrameOwnerElement* ownerElement = m_frame-&gt;ownerElement())
 780         ownerElement-&gt;dispatchEvent(Event::create(eventNames().loadEvent, Event::CanBubble::No, Event::IsCancelable::No));
 781 
 782     // The load event might have detached this frame. In that case, the load will already have been cancelled during detach.
 783     if (FrameLoader* frameLoader = this-&gt;frameLoader())
 784         cancelMainResourceLoad(frameLoader-&gt;cancelledError(m_request));
 785 }
 786 
 787 void DocumentLoader::responseReceived(CachedResource&amp; resource, const ResourceResponse&amp; response, CompletionHandler&lt;void()&gt;&amp;&amp; completionHandler)
 788 {
 789     ASSERT_UNUSED(resource, m_mainResource == &amp;resource);
 790     responseReceived(response, WTFMove(completionHandler));
 791 }
 792 
 793 void DocumentLoader::responseReceived(const ResourceResponse&amp; response, CompletionHandler&lt;void()&gt;&amp;&amp; completionHandler)
 794 {
 795     CompletionHandlerCallingScope completionHandlerCaller(WTFMove(completionHandler));
 796 
 797 #if ENABLE(CONTENT_FILTERING)
 798     if (m_contentFilter &amp;&amp; !m_contentFilter-&gt;continueAfterResponseReceived(response))
 799         return;
 800 #endif
 801 
 802     Ref&lt;DocumentLoader&gt; protectedThis(*this);
 803     bool willLoadFallback = m_applicationCacheHost-&gt;maybeLoadFallbackForMainResponse(request(), response);
 804 
 805     // The memory cache doesn&#39;t understand the application cache or its caching rules. So if a main resource is served
 806     // from the application cache, ensure we don&#39;t save the result for future use.
 807     if (willLoadFallback)
 808         MemoryCache::singleton().remove(*m_mainResource);
 809 
 810     if (willLoadFallback)
 811         return;
 812 
 813     ASSERT(m_identifierForLoadWithoutResourceLoader || m_mainResource);
 814     unsigned long identifier = m_identifierForLoadWithoutResourceLoader ? m_identifierForLoadWithoutResourceLoader : m_mainResource-&gt;identifier();
 815     ASSERT(identifier);
 816 
 817     if (m_substituteData.isValid() || !platformStrategies()-&gt;loaderStrategy()-&gt;havePerformedSecurityChecks(response)) {
 818         auto url = response.url();
 819         ContentSecurityPolicy contentSecurityPolicy(URL { url }, this);
 820         contentSecurityPolicy.didReceiveHeaders(ContentSecurityPolicyResponseHeaders { response }, m_request.httpReferrer());
 821         if (!contentSecurityPolicy.allowFrameAncestors(*m_frame, url)) {
 822             stopLoadingAfterXFrameOptionsOrContentSecurityPolicyDenied(identifier, response);
 823             return;
 824         }
 825 
 826         if (!contentSecurityPolicy.overridesXFrameOptions()) {
 827             String frameOptions = response.httpHeaderFields().get(HTTPHeaderName::XFrameOptions);
 828             if (!frameOptions.isNull()) {
 829                 if (frameLoader()-&gt;shouldInterruptLoadForXFrameOptions(frameOptions, url, identifier)) {
 830                     String message = &quot;Refused to display &#39;&quot; + url.stringCenterEllipsizedToLength() + &quot;&#39; in a frame because it set &#39;X-Frame-Options&#39; to &#39;&quot; + frameOptions + &quot;&#39;.&quot;;
 831                     m_frame-&gt;document()-&gt;addConsoleMessage(MessageSource::Security, MessageLevel::Error, message, identifier);
 832                     stopLoadingAfterXFrameOptionsOrContentSecurityPolicyDenied(identifier, response);
 833                     return;
 834                 }
 835             }
 836         }
 837     }
 838 
 839     // There is a bug in CFNetwork where callbacks can be dispatched even when loads are deferred.
 840     // See &lt;rdar://problem/6304600&gt; for more details.
 841 #if !USE(CF)
 842     ASSERT(!mainResourceLoader() || !mainResourceLoader()-&gt;defersLoading());
 843 #endif
 844 
 845     if (m_isLoadingMultipartContent) {
 846         setupForReplace();
 847         m_mainResource-&gt;clear();
 848     } else if (response.isMultipart())
 849         m_isLoadingMultipartContent = true;
 850 
 851     m_response = response;
 852 
 853     if (m_identifierForLoadWithoutResourceLoader) {
 854         if (m_mainResource &amp;&amp; m_mainResource-&gt;wasRedirected()) {
 855             ASSERT(m_mainResource-&gt;status() == CachedResource::Status::Cached);
 856             frameLoader()-&gt;client().dispatchDidReceiveServerRedirectForProvisionalLoad();
 857         }
 858         addResponse(m_response);
 859         frameLoader()-&gt;notifier().dispatchDidReceiveResponse(this, m_identifierForLoadWithoutResourceLoader, m_response, 0);
 860     }
 861 
 862     ASSERT(!m_waitingForContentPolicy);
 863     ASSERT(frameLoader());
 864     m_waitingForContentPolicy = true;
 865 
 866     // Always show content with valid substitute data.
 867     if (m_substituteData.isValid()) {
 868         continueAfterContentPolicy(PolicyAction::Use);
 869         return;
 870     }
 871 
 872 #if ENABLE(FTPDIR)
 873     // Respect the hidden FTP Directory Listing pref so it can be tested even if the policy delegate might otherwise disallow it
 874     if (m_frame-&gt;settings().forceFTPDirectoryListings() &amp;&amp; m_response.mimeType() == &quot;application/x-ftp-directory&quot;) {
 875         continueAfterContentPolicy(PolicyAction::Use);
 876         return;
 877     }
 878 #endif
 879 
 880     RefPtr&lt;SubresourceLoader&gt; mainResourceLoader = this-&gt;mainResourceLoader();
 881     if (mainResourceLoader)
 882         mainResourceLoader-&gt;markInAsyncResponsePolicyCheck();
 883     auto requestIdentifier = PolicyCheckIdentifier::create();
 884     frameLoader()-&gt;checkContentPolicy(m_response, requestIdentifier, [this, protectedThis = makeRef(*this), mainResourceLoader = WTFMove(mainResourceLoader),
 885         completionHandler = completionHandlerCaller.release(), requestIdentifier] (PolicyAction policy, PolicyCheckIdentifier responseIdentifeir) mutable {
 886         RELEASE_ASSERT(responseIdentifeir.isValidFor(requestIdentifier));
 887         continueAfterContentPolicy(policy);
 888         if (mainResourceLoader)
 889             mainResourceLoader-&gt;didReceiveResponsePolicy();
 890         if (completionHandler)
 891             completionHandler();
 892     });
 893 }
 894 
 895 // Prevent web archives from loading if
 896 // 1) it is remote;
 897 // 2) it is not the main frame;
 898 // 3) it is not any of { loaded by clients; loaded by drag; reloaded from any of the previous two };
 899 // because they can claim to be from any domain and thus avoid cross-domain security checks (4120255, 45524528, 47610130).
 900 bool DocumentLoader::disallowWebArchive() const
 901 {
 902     using MIMETypeHashSet = HashSet&lt;String, ASCIICaseInsensitiveHash&gt;;
 903     static NeverDestroyed&lt;MIMETypeHashSet&gt; webArchiveMIMETypes {
 904         MIMETypeHashSet {
 905             &quot;application/x-webarchive&quot;_s,
 906             &quot;application/x-mimearchive&quot;_s,
 907             &quot;multipart/related&quot;_s,
 908 #if PLATFORM(GTK)
 909             &quot;message/rfc822&quot;_s,
 910 #endif
 911         }
 912     };
 913 
 914     String mimeType = m_response.mimeType();
 915     if (mimeType.isNull() || !webArchiveMIMETypes.get().contains(mimeType))
 916         return false;
 917 
 918 #if USE(QUICK_LOOK)
 919     if (isQuickLookPreviewURL(m_response.url()))
 920         return false;
 921 #endif
 922 
 923     if (m_substituteData.isValid())
 924         return false;
 925 
 926     if (!SchemeRegistry::shouldTreatURLSchemeAsLocal(m_request.url().protocol().toStringWithoutCopying()))
 927         return true;
 928 
 929     if (!frame() || (frame()-&gt;isMainFrame() &amp;&amp; m_allowsWebArchiveForMainFrame))
 930         return false;
 931 
 932     // On purpose of maintaining existing tests.
 933     if (frame()-&gt;mainFrame().loader().alwaysAllowLocalWebarchive())
 934         return false;
 935     return true;
 936 }
 937 
 938 void DocumentLoader::continueAfterContentPolicy(PolicyAction policy)
 939 {
 940     ASSERT(m_waitingForContentPolicy);
 941     m_waitingForContentPolicy = false;
 942     if (isStopping())
 943         return;
 944 
 945     switch (policy) {
 946     case PolicyAction::Use: {
 947         if (!frameLoader()-&gt;client().canShowMIMEType(m_response.mimeType()) || disallowWebArchive()) {
 948             frameLoader()-&gt;policyChecker().cannotShowMIMEType(m_response);
 949             // Check reachedTerminalState since the load may have already been canceled inside of _handleUnimplementablePolicyWithErrorCode::.
 950             stopLoadingForPolicyChange();
 951             return;
 952         }
 953         break;
 954     }
 955 
 956     case PolicyAction::Download: {
 957         // m_mainResource can be null, e.g. when loading a substitute resource from application cache.
 958         if (!m_mainResource) {
 959             RELEASE_LOG_IF_ALLOWED(&quot;continueAfterContentPolicy: cannot show URL (frame = %p, main = %d)&quot;, m_frame, m_frame-&gt;isMainFrame());
 960             mainReceivedError(frameLoader()-&gt;client().cannotShowURLError(m_request));
 961             return;
 962         }
 963 
 964         if (ResourceLoader* mainResourceLoader = this-&gt;mainResourceLoader())
 965             InspectorInstrumentation::continueWithPolicyDownload(*m_frame, mainResourceLoader-&gt;identifier(), *this, m_response);
 966 
 967         // When starting the request, we didn&#39;t know that it would result in download and not navigation. Now we know that main document URL didn&#39;t change.
 968         // Download may use this knowledge for purposes unrelated to cookies, notably for setting file quarantine data.
 969         frameLoader()-&gt;setOriginalURLForDownloadRequest(m_request);
 970 
 971         PAL::SessionID sessionID = PAL::SessionID::defaultSessionID();
 972         if (frame() &amp;&amp; frame()-&gt;page())
 973             sessionID = frame()-&gt;page()-&gt;sessionID();
 974 
 975         if (m_request.url().protocolIsData()) {
 976             // We decode data URL internally, there is no resource load to convert.
 977             frameLoader()-&gt;client().startDownload(m_request);
 978         } else
 979             frameLoader()-&gt;client().convertMainResourceLoadToDownload(this, sessionID, m_request, m_response);
 980 
 981         // The main resource might be loading from the memory cache, or its loader might have gone missing.
 982         if (mainResourceLoader()) {
 983             static_cast&lt;ResourceLoader*&gt;(mainResourceLoader())-&gt;didFail(interruptedForPolicyChangeError());
 984             return;
 985         }
 986 
 987         // We must stop loading even if there is no main resource loader. Otherwise, we might remain
 988         // the client of a CachedRawResource that will continue to send us data.
 989         stopLoadingForPolicyChange();
 990         return;
 991     }
 992     case PolicyAction::StopAllLoads:
 993         ASSERT_NOT_REACHED();
 994 #if ASSERT_DISABLED
 995         FALLTHROUGH;
 996 #endif
 997     case PolicyAction::Ignore:
 998         if (ResourceLoader* mainResourceLoader = this-&gt;mainResourceLoader())
 999             InspectorInstrumentation::continueWithPolicyIgnore(*m_frame, mainResourceLoader-&gt;identifier(), *this, m_response);
1000         stopLoadingForPolicyChange();
1001         return;
1002     }
1003 
1004     if (m_response.isHTTP()) {
1005         int status = m_response.httpStatusCode(); // Status may be zero when loading substitute data, in particular from a WebArchive.
1006         if (status &amp;&amp; (status &lt; 200 || status &gt;= 300)) {
1007             bool hostedByObject = frameLoader()-&gt;isHostedByObjectElement();
1008 
1009             frameLoader()-&gt;handleFallbackContent();
1010             // object elements are no longer rendered after we fallback, so don&#39;t
1011             // keep trying to process data from their load
1012 
1013             if (hostedByObject)
1014                 cancelMainResourceLoad(frameLoader()-&gt;cancelledError(m_request));
1015         }
1016     }
1017 
1018     if (!isStopping() &amp;&amp; m_substituteData.isValid() &amp;&amp; isLoadingMainResource()) {
1019         auto content = m_substituteData.content();
1020         if (content &amp;&amp; content-&gt;size())
1021             dataReceived(content-&gt;data(), content-&gt;size());
1022         if (isLoadingMainResource())
1023             finishedLoading();
1024 
1025         // Remove ourselves as a client of this CachedResource as we&#39;ve decided to commit substitute data but the
1026         // load may keep going and be useful to other clients of the CachedResource. If we did not do this, we
1027         // may receive data later on even though this DocumentLoader has finished loading.
1028         clearMainResource();
1029     }
1030 }
1031 
1032 void DocumentLoader::commitLoad(const char* data, int length)
1033 {
1034     // Both unloading the old page and parsing the new page may execute JavaScript which destroys the datasource
1035     // by starting a new load, so retain temporarily.
1036     RefPtr&lt;Frame&gt; protectedFrame(m_frame);
1037     Ref&lt;DocumentLoader&gt; protectedThis(*this);
1038 
1039     commitIfReady();
1040     FrameLoader* frameLoader = DocumentLoader::frameLoader();
1041     if (!frameLoader)
1042         return;
1043 #if ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)
1044     if (ArchiveFactory::isArchiveMIMEType(response().mimeType()))
1045         return;
1046 #endif
1047     frameLoader-&gt;client().committedLoad(this, data, length);
1048 
1049     if (isMultipartReplacingLoad())
1050         frameLoader-&gt;client().didReplaceMultipartContent();
1051 }
1052 
1053 ResourceError DocumentLoader::interruptedForPolicyChangeError() const
1054 {
1055     return frameLoader()-&gt;client().interruptedForPolicyChangeError(request());
1056 }
1057 
1058 void DocumentLoader::stopLoadingForPolicyChange()
1059 {
1060     ResourceError error = interruptedForPolicyChangeError();
1061     error.setType(ResourceError::Type::Cancellation);
1062     cancelMainResourceLoad(error);
1063 }
1064 
1065 #if ENABLE(SERVICE_WORKER)
1066 static inline bool isLocalURL(const URL&amp; url)
1067 {
1068     // https://fetch.spec.whatwg.org/#is-local
1069     auto protocol = url.protocol().toStringWithoutCopying();
1070     return equalLettersIgnoringASCIICase(protocol, &quot;data&quot;) || equalLettersIgnoringASCIICase(protocol, &quot;blob&quot;) || equalLettersIgnoringASCIICase(protocol, &quot;about&quot;);
1071 }
1072 #endif
1073 
1074 void DocumentLoader::commitData(const char* bytes, size_t length)
1075 {
1076     if (!m_gotFirstByte) {
1077         m_gotFirstByte = true;
1078         bool hasBegun = m_writer.begin(documentURL(), false);
1079         m_writer.setDocumentWasLoadedAsPartOfNavigation();
1080 
1081         if (SecurityPolicy::allowSubstituteDataAccessToLocal() &amp;&amp; m_originalSubstituteDataWasValid) {
1082             // If this document was loaded with substituteData, then the document can
1083             // load local resources. See https://bugs.webkit.org/show_bug.cgi?id=16756
1084             // and https://bugs.webkit.org/show_bug.cgi?id=19760 for further
1085             // discussion.
1086             m_frame-&gt;document()-&gt;securityOrigin().grantLoadLocalResources();
1087         }
1088 
1089         if (frameLoader()-&gt;stateMachine().creatingInitialEmptyDocument())
1090             return;
1091 
1092 #if ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)
1093         if (m_archive &amp;&amp; m_archive-&gt;shouldOverrideBaseURL())
1094             m_frame-&gt;document()-&gt;setBaseURLOverride(m_archive-&gt;mainResource()-&gt;url());
1095 #endif
1096 #if ENABLE(SERVICE_WORKER)
1097         if (RuntimeEnabledFeatures::sharedFeatures().serviceWorkerEnabled()) {
1098             if (m_serviceWorkerRegistrationData &amp;&amp; m_serviceWorkerRegistrationData-&gt;activeWorker) {
1099                 m_frame-&gt;document()-&gt;setActiveServiceWorker(ServiceWorker::getOrCreate(*m_frame-&gt;document(), WTFMove(m_serviceWorkerRegistrationData-&gt;activeWorker.value())));
1100                 m_serviceWorkerRegistrationData = { };
1101             } else if (isLocalURL(m_frame-&gt;document()-&gt;url())) {
1102                 if (auto* parent = m_frame-&gt;document()-&gt;parentDocument())
1103                     m_frame-&gt;document()-&gt;setActiveServiceWorker(parent-&gt;activeServiceWorker());
1104             }
1105 
1106             if (m_frame-&gt;document()-&gt;activeServiceWorker() || SchemeRegistry::canServiceWorkersHandleURLScheme(m_frame-&gt;document()-&gt;url().protocol().toStringWithoutCopying()))
1107                 m_frame-&gt;document()-&gt;setServiceWorkerConnection(ServiceWorkerProvider::singleton().existingServiceWorkerConnectionForSession(m_frame-&gt;page()-&gt;sessionID()));
1108 
1109             // We currently unregister the temporary service worker client since we now registered the real document.
1110             // FIXME: We should make the real document use the temporary client identifier.
1111             unregisterTemporaryServiceWorkerClient();
1112         }
1113 #endif
1114         // Call receivedFirstData() exactly once per load. We should only reach this point multiple times
1115         // for multipart loads, and FrameLoader::isReplacing() will be true after the first time.
1116         if (!isMultipartReplacingLoad())
1117             frameLoader()-&gt;receivedFirstData();
1118 
1119         // The load could be canceled under receivedFirstData(), which makes delegate calls and even sometimes dispatches DOM events.
1120         if (!isLoading())
1121             return;
1122 
1123         if (auto* window = m_frame-&gt;document()-&gt;domWindow())
1124             window-&gt;prewarmLocalStorageIfNecessary();
1125 
1126         bool userChosen;
1127         String encoding;
1128         if (overrideEncoding().isNull()) {
1129             userChosen = false;
1130             encoding = response().textEncodingName();
1131 #if ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)
1132             if (m_archive &amp;&amp; m_archive-&gt;shouldUseMainResourceEncoding())
1133                 encoding = m_archive-&gt;mainResource()-&gt;textEncoding();
1134 #endif
1135         } else {
1136             userChosen = true;
1137             encoding = overrideEncoding();
1138         }
1139 
1140         m_writer.setEncoding(encoding, userChosen);
1141 
1142         RELEASE_ASSERT(hasBegun);
1143     }
1144 
1145 #if ENABLE(CONTENT_EXTENSIONS)
1146     auto&amp; extensionStyleSheets = m_frame-&gt;document()-&gt;extensionStyleSheets();
1147 
1148     for (auto&amp; pendingStyleSheet : m_pendingNamedContentExtensionStyleSheets)
1149         extensionStyleSheets.maybeAddContentExtensionSheet(pendingStyleSheet.key, *pendingStyleSheet.value);
1150     for (auto&amp; pendingSelectorEntry : m_pendingContentExtensionDisplayNoneSelectors) {
1151         for (const auto&amp; pendingSelector : pendingSelectorEntry.value)
1152             extensionStyleSheets.addDisplayNoneSelector(pendingSelectorEntry.key, pendingSelector.first, pendingSelector.second);
1153     }
1154 
1155     m_pendingNamedContentExtensionStyleSheets.clear();
1156     m_pendingContentExtensionDisplayNoneSelectors.clear();
1157 #endif
1158 
1159     ASSERT(m_frame-&gt;document()-&gt;parsing());
1160     m_writer.addData(bytes, length);
1161 }
1162 
1163 void DocumentLoader::dataReceived(CachedResource&amp; resource, const char* data, int length)
1164 {
1165     ASSERT_UNUSED(resource, &amp;resource == m_mainResource);
1166     dataReceived(data, length);
1167 }
1168 
1169 void DocumentLoader::dataReceived(const char* data, int length)
1170 {
1171 #if ENABLE(CONTENT_FILTERING)
1172     if (m_contentFilter &amp;&amp; !m_contentFilter-&gt;continueAfterDataReceived(data, length))
1173         return;
1174 #endif
1175 
1176     ASSERT(data);
1177     ASSERT(length);
1178     ASSERT(!m_response.isNull());
1179 
1180     // There is a bug in CFNetwork where callbacks can be dispatched even when loads are deferred.
1181     // See &lt;rdar://problem/6304600&gt; for more details.
1182 #if !USE(CF)
1183     ASSERT(!mainResourceLoader() || !mainResourceLoader()-&gt;defersLoading());
1184 #endif
1185 
1186     if (m_identifierForLoadWithoutResourceLoader)
1187         frameLoader()-&gt;notifier().dispatchDidReceiveData(this, m_identifierForLoadWithoutResourceLoader, data, length, -1);
1188 
1189     m_applicationCacheHost-&gt;mainResourceDataReceived(data, length, -1, false);
1190     m_timeOfLastDataReceived = MonotonicTime::now();
1191 
1192     if (!isMultipartReplacingLoad())
1193         commitLoad(data, length);
1194 }
1195 
1196 void DocumentLoader::setupForReplace()
1197 {
1198     if (!mainResourceData())
1199         return;
1200 
1201     frameLoader()-&gt;client().willReplaceMultipartContent();
1202 
1203     maybeFinishLoadingMultipartContent();
1204     maybeCreateArchive();
1205     m_writer.end();
1206     frameLoader()-&gt;setReplacing();
1207     m_gotFirstByte = false;
1208 
1209     stopLoadingSubresources();
1210     stopLoadingPlugIns();
1211 #if ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)
1212     clearArchiveResources();
1213 #endif
1214 }
1215 
1216 void DocumentLoader::checkLoadComplete()
1217 {
1218     if (!m_frame || isLoading())
1219         return;
1220 
1221     ASSERT(this == frameLoader()-&gt;activeDocumentLoader());
1222     m_frame-&gt;document()-&gt;domWindow()-&gt;finishedLoading();
1223 }
1224 
1225 void DocumentLoader::applyPoliciesToSettings()
1226 {
1227     if (!m_frame) {
1228         ASSERT_NOT_REACHED();
1229         return;
1230     }
1231 
1232     if (!m_frame-&gt;isMainFrame())
1233         return;
1234 
1235 #if ENABLE(MEDIA_SOURCE)
1236     m_frame-&gt;settings().setMediaSourceEnabled(m_mediaSourcePolicy == MediaSourcePolicy::Default ? Settings::platformDefaultMediaSourceEnabled() : m_mediaSourcePolicy == MediaSourcePolicy::Enable);
1237 #endif
1238 }
1239 
1240 void DocumentLoader::attachToFrame(Frame&amp; frame)
1241 {
1242     if (m_frame == &amp;frame)
1243         return;
1244 
1245     ASSERT(!m_frame);
1246     observeFrame(&amp;frame);
1247     m_writer.setFrame(frame);
1248     attachToFrame();
1249 
1250 #ifndef NDEBUG
1251     m_hasEverBeenAttached = true;
1252 #endif
1253 
1254     applyPoliciesToSettings();
1255 }
1256 
1257 void DocumentLoader::attachToFrame()
1258 {
1259     ASSERT(m_frame);
1260 }
1261 
1262 void DocumentLoader::detachFromFrame()
1263 {
1264 #ifndef NDEBUG
1265     if (m_hasEverBeenAttached)
1266         ASSERT_WITH_MESSAGE(m_frame, &quot;detachFromFrame() is being called on a DocumentLoader twice without an attachToFrame() inbetween&quot;);
1267     else
1268         ASSERT_WITH_MESSAGE(m_frame, &quot;detachFromFrame() is being called on a DocumentLoader that has never attached to any Frame&quot;);
1269 #endif
1270     RefPtr&lt;Frame&gt; protectedFrame(m_frame);
1271     Ref&lt;DocumentLoader&gt; protectedThis(*this);
1272 
1273     // It never makes sense to have a document loader that is detached from its
1274     // frame have any loads active, so kill all the loads.
1275     stopLoading();
1276     if (m_mainResource &amp;&amp; m_mainResource-&gt;hasClient(*this))
1277         m_mainResource-&gt;removeClient(*this);
1278 #if ENABLE(CONTENT_FILTERING)
1279     if (m_contentFilter)
1280         m_contentFilter-&gt;stopFilteringMainResource();
1281 #endif
1282 
1283     m_applicationCacheHost-&gt;setDOMApplicationCache(nullptr);
1284 
1285     cancelPolicyCheckIfNeeded();
1286 
1287     // cancelPolicyCheckIfNeeded can clear m_frame if the policy check
1288     // is stopped, resulting in a recursive call into this detachFromFrame.
1289     // If m_frame is nullptr after cancelPolicyCheckIfNeeded, our work is
1290     // already done so just return.
1291     if (!m_frame)
1292         return;
1293 
1294     InspectorInstrumentation::loaderDetachedFromFrame(*m_frame, *this);
1295 
1296     observeFrame(nullptr);
1297 }
1298 
1299 void DocumentLoader::clearMainResourceLoader()
1300 {
1301     m_loadingMainResource = false;
1302 
1303     if (this == frameLoader()-&gt;activeDocumentLoader())
1304         checkLoadComplete();
1305 }
1306 
1307 #if ENABLE(APPLICATION_MANIFEST)
1308 uint64_t DocumentLoader::loadApplicationManifest()
1309 {
1310     static uint64_t nextCallbackID = 1;
1311 
1312     auto* document = this-&gt;document();
1313     if (!document)
1314         return 0;
1315 
1316     if (!m_frame-&gt;isMainFrame())
1317         return 0;
1318 
1319     if (document-&gt;url().isEmpty() || document-&gt;url().protocolIsAbout())
1320         return 0;
1321 
1322     auto head = document-&gt;head();
1323     if (!head)
1324         return 0;
1325 
1326     URL manifestURL;
1327     bool useCredentials = false;
1328     for (const auto&amp; link : childrenOfType&lt;HTMLLinkElement&gt;(*head)) {
1329         if (link.isApplicationManifest()) {
1330             manifestURL = link.href();
1331             useCredentials = equalIgnoringASCIICase(link.attributeWithoutSynchronization(HTMLNames::crossoriginAttr), &quot;use-credentials&quot;);
1332             break;
1333         }
1334     }
1335 
1336     if (manifestURL.isEmpty() || !manifestURL.isValid())
1337         return 0;
1338 
1339     auto manifestLoader = makeUnique&lt;ApplicationManifestLoader&gt;(*this, manifestURL, useCredentials);
1340     auto* rawManifestLoader = manifestLoader.get();
1341     auto callbackID = nextCallbackID++;
1342     m_applicationManifestLoaders.set(WTFMove(manifestLoader), callbackID);
1343 
1344     if (!rawManifestLoader-&gt;startLoading()) {
1345         m_applicationManifestLoaders.remove(rawManifestLoader);
1346         return 0;
1347     }
1348 
1349     return callbackID;
1350 }
1351 
1352 void DocumentLoader::finishedLoadingApplicationManifest(ApplicationManifestLoader&amp; loader)
1353 {
1354     // If the DocumentLoader has detached from its frame, all manifest loads should have already been canceled.
1355     ASSERT(m_frame);
1356 
1357     auto callbackIdentifier = m_applicationManifestLoaders.get(&amp;loader);
1358     notifyFinishedLoadingApplicationManifest(callbackIdentifier, loader.processManifest());
1359     m_applicationManifestLoaders.remove(&amp;loader);
1360 }
1361 
1362 void DocumentLoader::notifyFinishedLoadingApplicationManifest(uint64_t callbackIdentifier, Optional&lt;ApplicationManifest&gt; manifest)
1363 {
1364     RELEASE_ASSERT(callbackIdentifier);
1365     RELEASE_ASSERT(m_frame);
1366     m_frame-&gt;loader().client().finishedLoadingApplicationManifest(callbackIdentifier, manifest);
1367 }
1368 #endif
1369 
1370 bool DocumentLoader::isLoadingInAPISense() const
1371 {
1372     // Once a frame has loaded, we no longer need to consider subresources,
1373     // but we still need to consider subframes.
1374     if (frameLoader()-&gt;state() != FrameStateComplete) {
1375         if (m_frame-&gt;settings().needsIsLoadingInAPISenseQuirk() &amp;&amp; !m_subresourceLoaders.isEmpty())
1376             return true;
1377 
1378         ASSERT(m_frame-&gt;document());
1379         auto&amp; document = *m_frame-&gt;document();
1380         if ((isLoadingMainResource() || !document.loadEventFinished()) &amp;&amp; isLoading())
1381             return true;
1382         if (m_cachedResourceLoader-&gt;requestCount())
1383             return true;
1384         if (document.isDelayingLoadEvent())
1385             return true;
1386         if (document.processingLoadEvent())
1387             return true;
1388         if (document.hasActiveParser())
1389             return true;
1390         auto* scriptableParser = document.scriptableDocumentParser();
1391         if (scriptableParser &amp;&amp; scriptableParser-&gt;hasScriptsWaitingForStylesheets())
1392             return true;
1393     }
1394     return frameLoader()-&gt;subframeIsLoading();
1395 }
1396 
1397 bool DocumentLoader::maybeCreateArchive()
1398 {
1399 #if !ENABLE(WEB_ARCHIVE) &amp;&amp; !ENABLE(MHTML)
1400     return false;
1401 #else
1402     // Give the archive machinery a crack at this document. If the MIME type is not an archive type, it will return 0.
1403     m_archive = ArchiveFactory::create(m_response.url(), mainResourceData().get(), m_response.mimeType());
1404     if (!m_archive)
1405         return false;
1406 
1407     addAllArchiveResources(*m_archive);
1408     ASSERT(m_archive-&gt;mainResource());
1409     auto&amp; mainResource = *m_archive-&gt;mainResource();
1410     m_parsedArchiveData = &amp;mainResource.data();
1411     m_writer.setMIMEType(mainResource.mimeType());
1412 
1413     ASSERT(m_frame-&gt;document());
1414     commitData(mainResource.data().data(), mainResource.data().size());
1415     return true;
1416 #endif
1417 }
1418 
1419 #if ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)
1420 
1421 void DocumentLoader::setArchive(Ref&lt;Archive&gt;&amp;&amp; archive)
1422 {
1423     m_archive = WTFMove(archive);
1424     addAllArchiveResources(*m_archive);
1425 }
1426 
1427 void DocumentLoader::addAllArchiveResources(Archive&amp; archive)
1428 {
1429     if (!m_archiveResourceCollection)
1430         m_archiveResourceCollection = makeUnique&lt;ArchiveResourceCollection&gt;();
1431     m_archiveResourceCollection-&gt;addAllResources(archive);
1432 }
1433 
1434 // FIXME: Adding a resource directly to a DocumentLoader/ArchiveResourceCollection seems like bad design, but is API some apps rely on.
1435 // Can we change the design in a manner that will let us deprecate that API without reducing functionality of those apps?
1436 void DocumentLoader::addArchiveResource(Ref&lt;ArchiveResource&gt;&amp;&amp; resource)
1437 {
1438     if (!m_archiveResourceCollection)
1439         m_archiveResourceCollection = makeUnique&lt;ArchiveResourceCollection&gt;();
1440     m_archiveResourceCollection-&gt;addResource(WTFMove(resource));
1441 }
1442 
1443 RefPtr&lt;Archive&gt; DocumentLoader::popArchiveForSubframe(const String&amp; frameName, const URL&amp; url)
1444 {
1445     return m_archiveResourceCollection ? m_archiveResourceCollection-&gt;popSubframeArchive(frameName, url) : nullptr;
1446 }
1447 
1448 void DocumentLoader::clearArchiveResources()
1449 {
1450     m_archiveResourceCollection = nullptr;
1451     m_substituteResourceDeliveryTimer.stop();
1452 }
1453 
1454 SharedBuffer* DocumentLoader::parsedArchiveData() const
1455 {
1456     return m_parsedArchiveData.get();
1457 }
1458 
1459 #endif // ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)
1460 
1461 ArchiveResource* DocumentLoader::archiveResourceForURL(const URL&amp; url) const
1462 {
1463     if (!m_archiveResourceCollection)
1464         return nullptr;
1465     auto* resource = m_archiveResourceCollection-&gt;archiveResourceForURL(url);
1466     if (!resource || resource-&gt;shouldIgnoreWhenUnarchiving())
1467         return nullptr;
1468     return resource;
1469 }
1470 
1471 RefPtr&lt;ArchiveResource&gt; DocumentLoader::mainResource() const
1472 {
1473     RefPtr&lt;SharedBuffer&gt; data = mainResourceData();
1474     if (!data)
1475         data = SharedBuffer::create();
1476     auto&amp; response = this-&gt;response();
1477     return ArchiveResource::create(WTFMove(data), response.url(), response.mimeType(), response.textEncodingName(), frame()-&gt;tree().uniqueName());
1478 }
1479 
1480 RefPtr&lt;ArchiveResource&gt; DocumentLoader::subresource(const URL&amp; url) const
1481 {
1482     if (!isCommitted())
1483         return nullptr;
1484 
1485     auto* resource = m_cachedResourceLoader-&gt;cachedResource(url);
1486     if (!resource || !resource-&gt;isLoaded())
1487         return archiveResourceForURL(url);
1488 
1489     if (resource-&gt;type() == CachedResource::Type::MainResource)
1490         return nullptr;
1491 
1492     auto* data = resource-&gt;resourceBuffer();
1493     if (!data)
1494         return nullptr;
1495 
1496     return ArchiveResource::create(data, url, resource-&gt;response());
1497 }
1498 
1499 Vector&lt;Ref&lt;ArchiveResource&gt;&gt; DocumentLoader::subresources() const
1500 {
1501     if (!isCommitted())
1502         return { };
1503 
1504     Vector&lt;Ref&lt;ArchiveResource&gt;&gt; subresources;
1505     for (auto&amp; handle : m_cachedResourceLoader-&gt;allCachedResources().values()) {
1506         if (auto subresource = this-&gt;subresource({ { }, handle-&gt;url() }))
1507             subresources.append(subresource.releaseNonNull());
1508     }
1509     return subresources;
1510 }
1511 
1512 void DocumentLoader::deliverSubstituteResourcesAfterDelay()
1513 {
1514     if (m_pendingSubstituteResources.isEmpty())
1515         return;
1516     ASSERT(m_frame);
1517     ASSERT(m_frame-&gt;page());
1518     if (m_frame-&gt;page()-&gt;defersLoading())
1519         return;
1520 
1521     if (!m_substituteResourceDeliveryTimer.isActive())
1522         m_substituteResourceDeliveryTimer.startOneShot(0_s);
1523 }
1524 
1525 void DocumentLoader::substituteResourceDeliveryTimerFired()
1526 {
1527     if (m_pendingSubstituteResources.isEmpty())
1528         return;
1529     ASSERT(m_frame);
1530     ASSERT(m_frame-&gt;page());
1531     if (m_frame-&gt;page()-&gt;defersLoading())
1532         return;
1533 
1534     auto pendingSubstituteResources = WTFMove(m_pendingSubstituteResources);
1535     for (auto&amp; pendingSubstituteResource : pendingSubstituteResources) {
1536         auto&amp; loader = pendingSubstituteResource.key;
1537         if (auto&amp; resource = pendingSubstituteResource.value)
1538             resource-&gt;deliver(*loader);
1539         else {
1540             // A null resource means that we should fail the load.
1541             // FIXME: Maybe we should use another error here - something like &quot;not in cache&quot;.
1542             loader-&gt;didFail(loader-&gt;cannotShowURLError());
1543         }
1544     }
1545 }
1546 
1547 #ifndef NDEBUG
1548 
1549 bool DocumentLoader::isSubstituteLoadPending(ResourceLoader* loader) const
1550 {
1551     return m_pendingSubstituteResources.contains(loader);
1552 }
1553 
1554 #endif
1555 
1556 void DocumentLoader::cancelPendingSubstituteLoad(ResourceLoader* loader)
1557 {
1558     if (m_pendingSubstituteResources.isEmpty())
1559         return;
1560     m_pendingSubstituteResources.remove(loader);
1561     if (m_pendingSubstituteResources.isEmpty())
1562         m_substituteResourceDeliveryTimer.stop();
1563 }
1564 
1565 #if ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)
1566 
1567 bool DocumentLoader::scheduleArchiveLoad(ResourceLoader&amp; loader, const ResourceRequest&amp; request)
1568 {
1569     if (auto* resource = archiveResourceForURL(request.url())) {
1570         scheduleSubstituteResourceLoad(loader, *resource);
1571         return true;
1572     }
1573 
1574     if (!m_archive)
1575         return false;
1576 
1577 #if ENABLE(WEB_ARCHIVE)
1578     // The idea of WebArchiveDebugMode is that we should fail instead of trying to fetch from the network.
1579     // Returning true ensures the caller will not try to fetch from the network.
1580     if (m_frame-&gt;settings().webArchiveDebugModeEnabled() &amp;&amp; responseMIMEType() == &quot;application/x-webarchive&quot;)
1581         return true;
1582 #endif
1583 
1584     // If we want to load from the archive only, then we should always return true so that the caller
1585     // does not try to fetch form the network.
1586     return m_archive-&gt;shouldLoadFromArchiveOnly();
1587 }
1588 
1589 #endif
1590 
1591 void DocumentLoader::scheduleSubstituteResourceLoad(ResourceLoader&amp; loader, SubstituteResource&amp; resource)
1592 {
1593 #if ENABLE(SERVICE_WORKER)
1594     ASSERT(!loader.options().serviceWorkerRegistrationIdentifier);
1595 #endif
1596     m_pendingSubstituteResources.set(&amp;loader, &amp;resource);
1597     deliverSubstituteResourcesAfterDelay();
1598 }
1599 
1600 void DocumentLoader::scheduleCannotShowURLError(ResourceLoader&amp; loader)
1601 {
1602     m_pendingSubstituteResources.set(&amp;loader, nullptr);
1603     deliverSubstituteResourcesAfterDelay();
1604 }
1605 
1606 void DocumentLoader::addResponse(const ResourceResponse&amp; response)
1607 {
1608     if (!m_stopRecordingResponses)
1609         m_responses.append(response);
1610 }
1611 
1612 void DocumentLoader::stopRecordingResponses()
1613 {
1614     m_stopRecordingResponses = true;
1615     m_responses.shrinkToFit();
1616 }
1617 
1618 void DocumentLoader::setCustomHeaderFields(Vector&lt;CustomHeaderFields&gt;&amp;&amp; fields)
1619 {
1620     m_customHeaderFields = WTFMove(fields);
1621 }
1622 
1623 void DocumentLoader::setTitle(const StringWithDirection&amp; title)
1624 {
1625     if (m_pageTitle == title)
1626         return;
1627 
1628     frameLoader()-&gt;willChangeTitle(this);
1629     m_pageTitle = title;
1630     frameLoader()-&gt;didChangeTitle(this);
1631 }
1632 
1633 URL DocumentLoader::urlForHistory() const
1634 {
1635     // Return the URL to be used for history and B/F list.
1636     // Returns nil for WebDataProtocol URLs that aren&#39;t alternates
1637     // for unreachable URLs, because these can&#39;t be stored in history.
1638     if (m_substituteData.isValid() &amp;&amp; !m_substituteData.shouldRevealToSessionHistory())
1639         return unreachableURL();
1640 
1641     return m_originalRequestCopy.url();
1642 }
1643 
1644 bool DocumentLoader::urlForHistoryReflectsFailure() const
1645 {
1646     return m_substituteData.isValid() || m_response.httpStatusCode() &gt;= 400;
1647 }
1648 
1649 URL DocumentLoader::documentURL() const
1650 {
1651     URL url = substituteData().response().url();
1652 #if ENABLE(WEB_ARCHIVE)
1653     if (url.isEmpty() &amp;&amp; m_archive &amp;&amp; m_archive-&gt;shouldUseMainResourceURL())
1654         url = m_archive-&gt;mainResource()-&gt;url();
1655 #endif
1656     if (url.isEmpty())
1657         url = m_request.url();
1658     if (url.isEmpty())
1659         url = m_response.url();
1660     return url;
1661 }
1662 
1663 #if PLATFORM(IOS_FAMILY)
1664 
1665 // FIXME: This method seems to violate the encapsulation of this class.
1666 void DocumentLoader::setResponseMIMEType(const String&amp; responseMimeType)
1667 {
1668     m_response.setMimeType(responseMimeType);
1669 }
1670 
1671 #endif
1672 
1673 void DocumentLoader::setDefersLoading(bool defers)
1674 {
1675     // Multiple frames may be loading the same main resource simultaneously. If deferral state changes,
1676     // each frame&#39;s DocumentLoader will try to send a setDefersLoading() to the same underlying ResourceLoader. Ensure only
1677     // the &quot;owning&quot; DocumentLoader does so, as setDefersLoading() is not resilient to setting the same value repeatedly.
1678     if (mainResourceLoader() &amp;&amp; mainResourceLoader()-&gt;documentLoader() == this)
1679         mainResourceLoader()-&gt;setDefersLoading(defers);
1680 
1681     setAllDefersLoading(m_subresourceLoaders, defers);
1682     setAllDefersLoading(m_plugInStreamLoaders, defers);
1683     if (!defers)
1684         deliverSubstituteResourcesAfterDelay();
1685 }
1686 
1687 void DocumentLoader::setMainResourceDataBufferingPolicy(DataBufferingPolicy dataBufferingPolicy)
1688 {
1689     if (m_mainResource)
1690         m_mainResource-&gt;setDataBufferingPolicy(dataBufferingPolicy);
1691 }
1692 
1693 void DocumentLoader::stopLoadingPlugIns()
1694 {
1695     cancelAll(m_plugInStreamLoaders);
1696 }
1697 
1698 void DocumentLoader::stopLoadingSubresources()
1699 {
1700     cancelAll(m_subresourceLoaders);
1701     ASSERT(m_subresourceLoaders.isEmpty());
1702 }
1703 
1704 void DocumentLoader::addSubresourceLoader(ResourceLoader* loader)
1705 {
1706     // The main resource&#39;s underlying ResourceLoader will ask to be added here.
1707     // It is much simpler to handle special casing of main resource loads if we don&#39;t
1708     // let it be added. In the main resource load case, mainResourceLoader()
1709     // will still be null at this point, but m_gotFirstByte should be false here if and only
1710     // if we are just starting the main resource load.
1711     if (!m_gotFirstByte)
1712         return;
1713     ASSERT(loader-&gt;identifier());
1714     ASSERT(!m_subresourceLoaders.contains(loader-&gt;identifier()));
1715     ASSERT(!mainResourceLoader() || mainResourceLoader() != loader);
1716 
1717     // Application Cache loaders are handled by their ApplicationCacheGroup directly.
1718     if (loader-&gt;options().applicationCacheMode == ApplicationCacheMode::Bypass)
1719         return;
1720 
1721 #if !ASSERT_DISABLED
1722     if (document()) {
1723         switch (document()-&gt;pageCacheState()) {
1724         case Document::NotInPageCache:
1725             break;
1726         case Document::AboutToEnterPageCache: {
1727             // A page about to enter PageCache should only be able to start ping loads.
1728             auto* cachedResource = MemoryCache::singleton().resourceForRequest(loader-&gt;request(), loader-&gt;frameLoader()-&gt;frame().page()-&gt;sessionID());
1729             ASSERT(cachedResource &amp;&amp; CachedResource::shouldUsePingLoad(cachedResource-&gt;type()));
1730             break;
1731         }
1732         case Document::InPageCache:
1733             // A page in the PageCache should not be able to start loads.
1734             ASSERT_NOT_REACHED();
1735             break;
1736         }
1737     }
1738 #endif
1739 
1740     m_subresourceLoaders.add(loader-&gt;identifier(), loader);
1741 }
1742 
1743 void DocumentLoader::removeSubresourceLoader(LoadCompletionType type, ResourceLoader* loader)
1744 {
1745     ASSERT(loader-&gt;identifier());
1746 
1747     if (!m_subresourceLoaders.remove(loader-&gt;identifier()))
1748         return;
1749     checkLoadComplete();
1750     if (Frame* frame = m_frame)
1751         frame-&gt;loader().subresourceLoadDone(type);
1752 }
1753 
1754 void DocumentLoader::addPlugInStreamLoader(ResourceLoader&amp; loader)
1755 {
1756     ASSERT(loader.identifier());
1757     ASSERT(!m_plugInStreamLoaders.contains(loader.identifier()));
1758 
1759     m_plugInStreamLoaders.add(loader.identifier(), &amp;loader);
1760 }
1761 
1762 void DocumentLoader::removePlugInStreamLoader(ResourceLoader&amp; loader)
1763 {
1764     ASSERT(loader.identifier());
1765     ASSERT(&amp;loader == m_plugInStreamLoaders.get(loader.identifier()));
1766 
1767     m_plugInStreamLoaders.remove(loader.identifier());
1768     checkLoadComplete();
1769 }
1770 
1771 bool DocumentLoader::isMultipartReplacingLoad() const
1772 {
1773     return isLoadingMultipartContent() &amp;&amp; frameLoader()-&gt;isReplacing();
1774 }
1775 
1776 bool DocumentLoader::maybeLoadEmpty()
1777 {
1778     bool shouldLoadEmpty = !m_substituteData.isValid() &amp;&amp; (m_request.url().isEmpty() || SchemeRegistry::shouldLoadURLSchemeAsEmptyDocument(m_request.url().protocol().toStringWithoutCopying()));
1779     if (!shouldLoadEmpty &amp;&amp; !frameLoader()-&gt;client().representationExistsForURLScheme(m_request.url().protocol().toStringWithoutCopying()))
1780         return false;
1781 
1782     if (m_request.url().isEmpty() &amp;&amp; !frameLoader()-&gt;stateMachine().creatingInitialEmptyDocument()) {
1783         m_request.setURL(WTF::blankURL());
1784         if (isLoadingMainResource())
1785             frameLoader()-&gt;client().dispatchDidChangeProvisionalURL();
1786     }
1787 
1788     String mimeType = shouldLoadEmpty ? &quot;text/html&quot; : frameLoader()-&gt;client().generatedMIMETypeForURLScheme(m_request.url().protocol().toStringWithoutCopying());
1789     m_response = ResourceResponse(m_request.url(), mimeType, 0, String());
1790     finishedLoading();
1791     return true;
1792 }
1793 
1794 void DocumentLoader::startLoadingMainResource()
1795 {
1796     m_mainDocumentError = ResourceError();
1797     timing().markStartTimeAndFetchStart();
1798     ASSERT(!m_mainResource);
1799     ASSERT(!m_loadingMainResource);
1800     m_loadingMainResource = true;
1801 
1802     Ref&lt;DocumentLoader&gt; protectedThis(*this);
1803 
1804     if (maybeLoadEmpty()) {
1805         RELEASE_LOG_IF_ALLOWED(&quot;startLoadingMainResource: Returning empty document (frame = %p, main = %d)&quot;, m_frame, m_frame ? m_frame-&gt;isMainFrame() : false);
1806         return;
1807     }
1808 
1809 #if ENABLE(CONTENT_FILTERING)
1810     m_contentFilter = !m_substituteData.isValid() ? ContentFilter::create(*this) : nullptr;
1811 #endif
1812 
1813     // Make sure we re-apply the user agent to the Document&#39;s ResourceRequest upon reload in case the embedding
1814     // application has changed it.
1815     m_request.clearHTTPUserAgent();
1816     frameLoader()-&gt;addExtraFieldsToMainResourceRequest(m_request);
1817 
1818     ASSERT(timing().startTime());
1819     ASSERT(timing().fetchStart());
1820 
1821     willSendRequest(ResourceRequest(m_request), ResourceResponse(), [this, protectedThis = WTFMove(protectedThis)] (ResourceRequest&amp;&amp; request) mutable {
1822         m_request = request;
1823 
1824         // willSendRequest() may lead to our Frame being detached or cancelling the load via nulling the ResourceRequest.
1825         if (!m_frame || m_request.isNull()) {
1826             RELEASE_LOG_IF_ALLOWED(&quot;startLoadingMainResource: Load canceled after willSendRequest (frame = %p, main = %d)&quot;, m_frame, m_frame ? m_frame-&gt;isMainFrame() : false);
1827             return;
1828         }
1829 
1830         request.setRequester(ResourceRequest::Requester::Main);
1831         // If this is a reload the cache layer might have made the previous request conditional. DocumentLoader can&#39;t handle 304 responses itself.
1832         request.makeUnconditional();
1833 
1834         RELEASE_LOG_IF_ALLOWED(&quot;startLoadingMainResource: Starting load (frame = %p, main = %d)&quot;, m_frame, m_frame-&gt;isMainFrame());
1835 
1836 #if ENABLE(SERVICE_WORKER)
1837         // FIXME: Implement local URL interception by getting the service worker of the parent.
1838         auto url = request.url();
1839         matchRegistration(url, [request = WTFMove(request), protectedThis = WTFMove(protectedThis), this] (auto&amp;&amp; registrationData) mutable {
1840             if (!m_mainDocumentError.isNull() || !m_frame) {
1841                 RELEASE_LOG_IF_ALLOWED(&quot;startLoadingMainResource callback: Load canceled because of main document error (frame = %p, main = %d)&quot;, m_frame, m_frame ? m_frame-&gt;isMainFrame() : false);
1842                 return;
1843             }
1844 
1845             m_serviceWorkerRegistrationData = WTFMove(registrationData);
1846 
1847             // Prefer existing substitute data (from WKWebView.loadData etc) over service worker fetch.
1848             if (this-&gt;tryLoadingSubstituteData()) {
1849                 RELEASE_LOG_IF_ALLOWED(&quot;startLoadingMainResource callback: Load canceled because of substitute data (frame = %p, main = %d)&quot;, m_frame, m_frame ? m_frame-&gt;isMainFrame() : false);
1850                 return;
1851             }
1852             // Try app cache only if there is no service worker.
1853             if (!m_serviceWorkerRegistrationData &amp;&amp; this-&gt;tryLoadingRequestFromApplicationCache()) {
1854                 RELEASE_LOG_IF_ALLOWED(&quot;startLoadingMainResource callback: Loaded from Application Cache (frame = %p, main = %d)&quot;, m_frame, m_frame-&gt;isMainFrame());
1855                 return;
1856             }
1857             this-&gt;loadMainResource(WTFMove(request));
1858         });
1859 #else
1860         if (tryLoadingRequestFromApplicationCache()) {
1861             RELEASE_LOG_IF_ALLOWED(&quot;startLoadingMainResource: Loaded from Application Cache (frame = %p, main = %d)&quot;, m_frame, m_frame-&gt;isMainFrame());
1862             return;
1863         }
1864         loadMainResource(WTFMove(request));
1865 #endif
1866     });
1867 }
1868 
1869 void DocumentLoader::registerTemporaryServiceWorkerClient(const URL&amp; url)
1870 {
1871 #if ENABLE(SERVICE_WORKER)
1872     ASSERT(!m_temporaryServiceWorkerClient);
1873 
1874     if (!m_serviceWorkerRegistrationData)
1875         return;
1876 
1877     m_temporaryServiceWorkerClient = TemporaryServiceWorkerClient {
1878         DocumentIdentifier::generate(),
1879         m_frame-&gt;page()-&gt;sessionID()
1880     };
1881 
1882     auto&amp; serviceWorkerConnection = ServiceWorkerProvider::singleton().serviceWorkerConnectionForSession(m_temporaryServiceWorkerClient-&gt;sessionID);
1883 
1884     // FIXME: Compute ServiceWorkerClientFrameType appropriately.
1885     ServiceWorkerClientData data { { serviceWorkerConnection.serverConnectionIdentifier(), m_temporaryServiceWorkerClient-&gt;documentIdentifier }, ServiceWorkerClientType::Window, ServiceWorkerClientFrameType::None, url };
1886 
1887     RefPtr&lt;SecurityOrigin&gt; topOrigin;
1888     if (m_frame-&gt;isMainFrame())
1889         topOrigin = SecurityOrigin::create(url);
1890     else
1891         topOrigin = &amp;m_frame-&gt;mainFrame().document()-&gt;topOrigin();
1892     serviceWorkerConnection.registerServiceWorkerClient(*topOrigin, WTFMove(data), m_serviceWorkerRegistrationData-&gt;identifier, m_frame-&gt;loader().userAgent(url));
1893 #else
1894     UNUSED_PARAM(url);
1895 #endif
1896 }
1897 
1898 void DocumentLoader::unregisterTemporaryServiceWorkerClient()
1899 {
1900 #if ENABLE(SERVICE_WORKER)
1901     if (!m_temporaryServiceWorkerClient)
1902         return;
1903 
1904     auto&amp; serviceWorkerConnection = ServiceWorkerProvider::singleton().serviceWorkerConnectionForSession(m_temporaryServiceWorkerClient-&gt;sessionID);
1905     serviceWorkerConnection.unregisterServiceWorkerClient(m_temporaryServiceWorkerClient-&gt;documentIdentifier);
1906     m_temporaryServiceWorkerClient = WTF::nullopt;
1907 #endif
1908 }
1909 
1910 void DocumentLoader::loadMainResource(ResourceRequest&amp;&amp; request)
1911 {
1912     static NeverDestroyed&lt;ResourceLoaderOptions&gt; mainResourceLoadOptions(
1913         SendCallbackPolicy::SendCallbacks,
1914         ContentSniffingPolicy::SniffContent,
1915         DataBufferingPolicy::BufferData,
1916         StoredCredentialsPolicy::Use,
1917         ClientCredentialPolicy::MayAskClientForCredentials,
1918         FetchOptions::Credentials::Include,
1919         SecurityCheckPolicy::SkipSecurityCheck,
1920         FetchOptions::Mode::Navigate,
1921         CertificateInfoPolicy::IncludeCertificateInfo,
1922         ContentSecurityPolicyImposition::SkipPolicyCheck,
1923         DefersLoadingPolicy::AllowDefersLoading,
1924         CachingPolicy::AllowCaching);
1925     CachedResourceRequest mainResourceRequest(WTFMove(request), mainResourceLoadOptions);
1926     if (!m_frame-&gt;isMainFrame() &amp;&amp; m_frame-&gt;document()) {
1927         // If we are loading the main resource of a subframe, use the cache partition of the main document.
1928         mainResourceRequest.setDomainForCachePartition(*m_frame-&gt;document());
1929     } else {
1930         auto origin = SecurityOrigin::create(mainResourceRequest.resourceRequest().url());
1931         origin-&gt;setStorageBlockingPolicy(frameLoader()-&gt;frame().settings().storageBlockingPolicy());
1932         mainResourceRequest.setDomainForCachePartition(origin-&gt;domainForCachePartition());
1933     }
1934 
1935 #if ENABLE(SERVICE_WORKER)
1936     mainResourceRequest.setNavigationServiceWorkerRegistrationData(m_serviceWorkerRegistrationData);
1937     if (mainResourceRequest.options().serviceWorkersMode != ServiceWorkersMode::None) {
1938         // As per step 12 of https://w3c.github.io/ServiceWorker/#on-fetch-request-algorithm, the active service worker should be controlling the document.
1939         // Since we did not yet create the document, we register a temporary service worker client instead.
1940         registerTemporaryServiceWorkerClient(mainResourceRequest.resourceRequest().url());
1941     }
1942 #endif
1943 
1944     m_mainResource = m_cachedResourceLoader-&gt;requestMainResource(WTFMove(mainResourceRequest)).value_or(nullptr);
1945 
1946     if (!m_mainResource) {
1947         // The frame may have gone away if this load was cancelled synchronously and this was the last pending load.
1948         // This is because we may have fired the load event in a parent frame.
1949         if (!m_frame) {
1950             RELEASE_LOG_IF_ALLOWED(&quot;loadMainResource: Unable to load main resource, frame has gone away (frame = %p, main = %d)&quot;, m_frame, m_frame-&gt;isMainFrame());
1951             return;
1952         }
1953 
1954         if (!m_request.url().isValid()) {
1955             RELEASE_LOG_IF_ALLOWED(&quot;loadMainResource: Unable to load main resource, URL is invalid (frame = %p, main = %d)&quot;, m_frame, m_frame-&gt;isMainFrame());
1956             cancelMainResourceLoad(frameLoader()-&gt;client().cannotShowURLError(m_request));
1957             return;
1958         }
1959 
1960         RELEASE_LOG_IF_ALLOWED(&quot;loadMainResource: Unable to load main resource, returning empty document (frame = %p, main = %d)&quot;, m_frame, m_frame-&gt;isMainFrame());
1961 
1962         setRequest(ResourceRequest());
1963         // If the load was aborted by clearing m_request, it&#39;s possible the ApplicationCacheHost
1964         // is now in a state where starting an empty load will be inconsistent. Replace it with
1965         // a new ApplicationCacheHost.
1966         m_applicationCacheHost = makeUnique&lt;ApplicationCacheHost&gt;(*this);
1967         maybeLoadEmpty();
1968         return;
1969     }
1970 
1971     ASSERT(m_frame);
1972 
1973 #if ENABLE(CONTENT_EXTENSIONS)
1974     if (m_mainResource-&gt;errorOccurred() &amp;&amp; m_frame-&gt;page() &amp;&amp; m_mainResource-&gt;resourceError().domain() == ContentExtensions::WebKitContentBlockerDomain) {
1975         RELEASE_LOG_IF_ALLOWED(&quot;loadMainResource: Blocked by content blocker error (frame = %p, main = %d)&quot;, m_frame, m_frame-&gt;isMainFrame());
1976         cancelMainResourceLoad(frameLoader()-&gt;blockedByContentBlockerError(m_request));
1977         return;
1978     }
1979 #endif
1980 
1981     if (!mainResourceLoader()) {
1982         m_identifierForLoadWithoutResourceLoader = m_frame-&gt;page()-&gt;progress().createUniqueIdentifier();
1983         frameLoader()-&gt;notifier().assignIdentifierToInitialRequest(m_identifierForLoadWithoutResourceLoader, this, mainResourceRequest.resourceRequest());
1984         frameLoader()-&gt;notifier().dispatchWillSendRequest(this, m_identifierForLoadWithoutResourceLoader, mainResourceRequest.resourceRequest(), ResourceResponse());
1985     }
1986 
1987     becomeMainResourceClient();
1988 
1989     // A bunch of headers are set when the underlying ResourceLoader is created, and m_request needs to include those.
1990     ResourceRequest updatedRequest = mainResourceLoader() ? mainResourceLoader()-&gt;originalRequest() : mainResourceRequest.resourceRequest();
1991     // If there was a fragment identifier on m_request, the cache will have stripped it. m_request should include
1992     // the fragment identifier, so add that back in.
1993     if (equalIgnoringFragmentIdentifier(m_request.url(), updatedRequest.url()))
1994         updatedRequest.setURL(m_request.url());
1995     setRequest(updatedRequest);
1996 }
1997 
1998 void DocumentLoader::cancelPolicyCheckIfNeeded()
1999 {
2000     if (m_waitingForContentPolicy || m_waitingForNavigationPolicy) {
2001         RELEASE_ASSERT(frameLoader());
2002         frameLoader()-&gt;policyChecker().stopCheck();
2003         m_waitingForContentPolicy = false;
2004         m_waitingForNavigationPolicy = false;
2005     }
2006 }
2007 
2008 void DocumentLoader::cancelMainResourceLoad(const ResourceError&amp; resourceError)
2009 {
2010     Ref&lt;DocumentLoader&gt; protectedThis(*this);
2011     ResourceError error = resourceError.isNull() ? frameLoader()-&gt;cancelledError(m_request) : resourceError;
2012 
2013     RELEASE_LOG_IF_ALLOWED(&quot;cancelMainResourceLoad: (frame = %p, main = %d, type = %d, code = %d)&quot;, m_frame, m_frame-&gt;isMainFrame(), static_cast&lt;int&gt;(error.type()), error.errorCode());
2014 
2015     m_dataLoadTimer.stop();
2016 
2017     cancelPolicyCheckIfNeeded();
2018 
2019     if (mainResourceLoader())
2020         mainResourceLoader()-&gt;cancel(error);
2021 
2022     clearMainResource();
2023 
2024     mainReceivedError(error);
2025 }
2026 
2027 void DocumentLoader::willContinueMainResourceLoadAfterRedirect(const ResourceRequest&amp; newRequest)
2028 {
2029     setRequest(newRequest);
2030 }
2031 
2032 void DocumentLoader::clearMainResource()
2033 {
2034     ASSERT(isMainThread());
2035     if (m_mainResource &amp;&amp; m_mainResource-&gt;hasClient(*this))
2036         m_mainResource-&gt;removeClient(*this);
2037 #if ENABLE(CONTENT_FILTERING)
2038     if (m_contentFilter)
2039         m_contentFilter-&gt;stopFilteringMainResource();
2040 #endif
2041 
2042     m_mainResource = nullptr;
2043 
2044     unregisterTemporaryServiceWorkerClient();
2045 }
2046 
2047 void DocumentLoader::subresourceLoaderFinishedLoadingOnePart(ResourceLoader* loader)
2048 {
2049     unsigned long identifier = loader-&gt;identifier();
2050     ASSERT(identifier);
2051 
2052     if (!m_multipartSubresourceLoaders.add(identifier, loader).isNewEntry) {
2053         ASSERT(m_multipartSubresourceLoaders.get(identifier) == loader);
2054         ASSERT(!m_subresourceLoaders.contains(identifier));
2055     } else {
2056         ASSERT(m_subresourceLoaders.contains(identifier));
2057         m_subresourceLoaders.remove(identifier);
2058     }
2059 
2060     checkLoadComplete();
2061     if (Frame* frame = m_frame)
2062         frame-&gt;loader().checkLoadComplete();
2063 }
2064 
2065 void DocumentLoader::maybeFinishLoadingMultipartContent()
2066 {
2067     if (!isMultipartReplacingLoad())
2068         return;
2069 
2070     frameLoader()-&gt;setupForReplace();
2071     m_committed = false;
2072     RefPtr&lt;SharedBuffer&gt; resourceData = mainResourceData();
2073     commitLoad(resourceData-&gt;data(), resourceData-&gt;size());
2074 }
2075 
2076 void DocumentLoader::startIconLoading()
2077 {
2078     static uint64_t nextIconCallbackID = 1;
2079 
2080     auto* document = this-&gt;document();
2081     if (!document)
2082         return;
2083 
2084     if (!m_frame-&gt;isMainFrame())
2085         return;
2086 
2087     if (document-&gt;url().isEmpty() || document-&gt;url().protocolIsAbout())
2088         return;
2089 
2090     m_linkIcons = LinkIconCollector { *document }.iconsOfTypes({ LinkIconType::Favicon, LinkIconType::TouchIcon, LinkIconType::TouchPrecomposedIcon });
2091 
2092     auto findResult = m_linkIcons.findMatching([](auto&amp; icon) { return icon.type == LinkIconType::Favicon; });
2093     if (findResult == notFound)
2094         m_linkIcons.append({ document-&gt;completeURL(&quot;/favicon.ico&quot;_s), LinkIconType::Favicon, String(), WTF::nullopt, { } });
2095 
2096     if (!m_linkIcons.size())
2097         return;
2098 
2099     Vector&lt;std::pair&lt;WebCore::LinkIcon&amp;, uint64_t&gt;&gt; iconDecisions;
2100     iconDecisions.reserveInitialCapacity(m_linkIcons.size());
2101     for (auto&amp; icon : m_linkIcons) {
2102         auto result = m_iconsPendingLoadDecision.add(nextIconCallbackID++, icon);
2103         iconDecisions.uncheckedAppend({ icon, result.iterator-&gt;key });
2104     }
2105 
2106     m_frame-&gt;loader().client().getLoadDecisionForIcons(iconDecisions);
2107 }
2108 
2109 void DocumentLoader::didGetLoadDecisionForIcon(bool decision, uint64_t loadIdentifier, uint64_t newCallbackID)
2110 {
2111     auto icon = m_iconsPendingLoadDecision.take(loadIdentifier);
2112 
2113     // If the decision was not to load or this DocumentLoader is already detached, there is no load to perform.
2114     if (!decision || !m_frame)
2115         return;
2116 
2117     // If the LinkIcon we just took is empty, then the DocumentLoader had all of its loaders stopped
2118     // while this icon load decision was pending.
2119     // In this case we need to notify the client that the icon finished loading with empty data.
2120     if (icon.url.isEmpty()) {
2121         notifyFinishedLoadingIcon(newCallbackID, nullptr);
2122         return;
2123     }
2124 
2125     auto iconLoader = makeUnique&lt;IconLoader&gt;(*this, icon.url);
2126     auto* rawIconLoader = iconLoader.get();
2127     m_iconLoaders.set(WTFMove(iconLoader), newCallbackID);
2128 
2129     rawIconLoader-&gt;startLoading();
2130 }
2131 
2132 void DocumentLoader::finishedLoadingIcon(IconLoader&amp; loader, SharedBuffer* buffer)
2133 {
2134     // If the DocumentLoader has detached from its frame, all icon loads should have already been cancelled.
2135     ASSERT(m_frame);
2136 
2137     auto callbackIdentifier = m_iconLoaders.take(&amp;loader);
2138     notifyFinishedLoadingIcon(callbackIdentifier, buffer);
2139 }
2140 
2141 void DocumentLoader::notifyFinishedLoadingIcon(uint64_t callbackIdentifier, SharedBuffer* buffer)
2142 {
2143     RELEASE_ASSERT(callbackIdentifier);
2144     RELEASE_ASSERT(m_frame);
2145     m_frame-&gt;loader().client().finishedLoadingIcon(callbackIdentifier, buffer);
2146 }
2147 
2148 void DocumentLoader::dispatchOnloadEvents()
2149 {
2150     m_wasOnloadDispatched = true;
2151     m_applicationCacheHost-&gt;stopDeferringEvents();
2152 }
2153 
2154 void DocumentLoader::setTriggeringAction(NavigationAction&amp;&amp; action)
2155 {
2156     m_triggeringAction = WTFMove(action);
2157     m_triggeringAction.setShouldOpenExternalURLsPolicy(m_frame ? shouldOpenExternalURLsPolicyToPropagate() : m_shouldOpenExternalURLsPolicy);
2158 }
2159 
2160 ShouldOpenExternalURLsPolicy DocumentLoader::shouldOpenExternalURLsPolicyToPropagate() const
2161 {
2162     if (!m_frame)
2163         return ShouldOpenExternalURLsPolicy::ShouldNotAllow;
2164 
2165     if (m_frame-&gt;isMainFrame())
2166         return m_shouldOpenExternalURLsPolicy;
2167 
2168     if (auto* currentDocument = document()) {
2169         if (currentDocument-&gt;securityOrigin().isSameOriginAs(currentDocument-&gt;topOrigin()))
2170             return m_shouldOpenExternalURLsPolicy;
2171     }
2172 
2173     return ShouldOpenExternalURLsPolicy::ShouldNotAllow;
2174 }
2175 
2176 void DocumentLoader::becomeMainResourceClient()
2177 {
2178 #if ENABLE(CONTENT_FILTERING)
2179     if (m_contentFilter)
2180         m_contentFilter-&gt;startFilteringMainResource(*m_mainResource);
2181 #endif
2182     m_mainResource-&gt;addClient(*this);
2183 }
2184 
2185 #if ENABLE(CONTENT_EXTENSIONS)
2186 void DocumentLoader::addPendingContentExtensionSheet(const String&amp; identifier, StyleSheetContents&amp; sheet)
2187 {
2188     ASSERT(!m_gotFirstByte);
2189     m_pendingNamedContentExtensionStyleSheets.set(identifier, &amp;sheet);
2190 }
2191 
2192 void DocumentLoader::addPendingContentExtensionDisplayNoneSelector(const String&amp; identifier, const String&amp; selector, uint32_t selectorID)
2193 {
2194     ASSERT(!m_gotFirstByte);
2195     auto addResult = m_pendingContentExtensionDisplayNoneSelectors.add(identifier, Vector&lt;std::pair&lt;String, uint32_t&gt;&gt;());
2196     addResult.iterator-&gt;value.append(std::make_pair(selector, selectorID));
2197 }
2198 #endif
2199 
2200 bool DocumentLoader::isAlwaysOnLoggingAllowed() const
2201 {
2202     return !m_frame || m_frame-&gt;isAlwaysOnLoggingAllowed();
2203 }
2204 
2205 #if USE(QUICK_LOOK)
2206 
2207 void DocumentLoader::setPreviewConverter(std::unique_ptr&lt;PreviewConverter&gt;&amp;&amp; previewConverter)
2208 {
2209     m_previewConverter = WTFMove(previewConverter);
2210 }
2211 
2212 PreviewConverter* DocumentLoader::previewConverter() const
2213 {
2214     return m_previewConverter.get();
2215 }
2216 
2217 #endif
2218 
2219 void DocumentLoader::addConsoleMessage(MessageSource messageSource, MessageLevel messageLevel, const String&amp; message, unsigned long requestIdentifier)
2220 {
2221     static_cast&lt;ScriptExecutionContext*&gt;(m_frame-&gt;document())-&gt;addConsoleMessage(messageSource, messageLevel, message, requestIdentifier);
2222 }
2223 
2224 void DocumentLoader::sendCSPViolationReport(URL&amp;&amp; reportURL, Ref&lt;FormData&gt;&amp;&amp; report)
2225 {
2226     PingLoader::sendViolationReport(*m_frame, WTFMove(reportURL), WTFMove(report), ViolationReportType::ContentSecurityPolicy);
2227 }
2228 
2229 void DocumentLoader::enqueueSecurityPolicyViolationEvent(SecurityPolicyViolationEvent::Init&amp;&amp; eventInit)
2230 {
2231     m_frame-&gt;document()-&gt;enqueueSecurityPolicyViolationEvent(WTFMove(eventInit));
2232 }
2233 
2234 } // namespace WebCore
    </pre>
  </body>
</html>