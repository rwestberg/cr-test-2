<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/jsc.cpp</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  *  Copyright (C) 1999-2000 Harri Porten (porten@kde.org)
<a name="1" id="anc1"></a><span class="line-modified">   3  *  Copyright (C) 2004-2018 Apple Inc. All rights reserved.</span>
   4  *  Copyright (C) 2006 Bjoern Graf (bjoern.graf@gmail.com)
   5  *
   6  *  This library is free software; you can redistribute it and/or
   7  *  modify it under the terms of the GNU Library General Public
   8  *  License as published by the Free Software Foundation; either
   9  *  version 2 of the License, or (at your option) any later version.
  10  *
  11  *  This library is distributed in the hope that it will be useful,
  12  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  13  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  14  *  Library General Public License for more details.
  15  *
  16  *  You should have received a copy of the GNU Library General Public License
  17  *  along with this library; see the file COPYING.LIB.  If not, write to
  18  *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  19  *  Boston, MA 02110-1301, USA.
  20  *
  21  */
  22 
  23 #include &quot;config.h&quot;
  24 
  25 #include &quot;ArrayBuffer.h&quot;
  26 #include &quot;ArrayPrototype.h&quot;
  27 #include &quot;BuiltinNames.h&quot;
  28 #include &quot;ButterflyInlines.h&quot;
<a name="2" id="anc2"></a>
  29 #include &quot;CatchScope.h&quot;
  30 #include &quot;CodeBlock.h&quot;
  31 #include &quot;CodeCache.h&quot;
  32 #include &quot;Completion.h&quot;
  33 #include &quot;ConfigFile.h&quot;
  34 #include &quot;Disassembler.h&quot;
  35 #include &quot;Exception.h&quot;
  36 #include &quot;ExceptionHelpers.h&quot;
  37 #include &quot;HeapProfiler.h&quot;
  38 #include &quot;HeapSnapshotBuilder.h&quot;
  39 #include &quot;InitializeThreading.h&quot;
  40 #include &quot;Interpreter.h&quot;
  41 #include &quot;JIT.h&quot;
  42 #include &quot;JSArray.h&quot;
  43 #include &quot;JSArrayBuffer.h&quot;
  44 #include &quot;JSBigInt.h&quot;
  45 #include &quot;JSCInlines.h&quot;
  46 #include &quot;JSFunction.h&quot;
  47 #include &quot;JSInternalPromise.h&quot;
  48 #include &quot;JSInternalPromiseDeferred.h&quot;
  49 #include &quot;JSLock.h&quot;
  50 #include &quot;JSModuleLoader.h&quot;
  51 #include &quot;JSNativeStdFunction.h&quot;
  52 #include &quot;JSONObject.h&quot;
  53 #include &quot;JSSourceCode.h&quot;
  54 #include &quot;JSString.h&quot;
  55 #include &quot;JSTypedArrays.h&quot;
  56 #include &quot;JSWebAssemblyInstance.h&quot;
  57 #include &quot;JSWebAssemblyMemory.h&quot;
  58 #include &quot;LLIntThunks.h&quot;
  59 #include &quot;ObjectConstructor.h&quot;
  60 #include &quot;ParserError.h&quot;
  61 #include &quot;ProfilerDatabase.h&quot;
  62 #include &quot;PromiseDeferredTimer.h&quot;
  63 #include &quot;ProtoCallFrame.h&quot;
  64 #include &quot;ReleaseHeapAccessScope.h&quot;
  65 #include &quot;SamplingProfiler.h&quot;
  66 #include &quot;StackVisitor.h&quot;
  67 #include &quot;StructureInlines.h&quot;
  68 #include &quot;StructureRareDataInlines.h&quot;
  69 #include &quot;SuperSampler.h&quot;
  70 #include &quot;TestRunnerUtils.h&quot;
  71 #include &quot;TypedArrayInlines.h&quot;
<a name="3" id="anc3"></a>
  72 #include &quot;WasmContext.h&quot;
  73 #include &quot;WasmFaultSignalHandler.h&quot;
  74 #include &quot;WasmMemory.h&quot;
  75 #include &lt;locale.h&gt;
  76 #include &lt;math.h&gt;
  77 #include &lt;stdio.h&gt;
  78 #include &lt;stdlib.h&gt;
  79 #include &lt;string.h&gt;
  80 #include &lt;sys/stat.h&gt;
  81 #include &lt;sys/types.h&gt;
  82 #include &lt;thread&gt;
  83 #include &lt;type_traits&gt;
  84 #include &lt;wtf/Box.h&gt;
  85 #include &lt;wtf/CommaPrinter.h&gt;
<a name="4" id="anc4"></a>
  86 #include &lt;wtf/MainThread.h&gt;
  87 #include &lt;wtf/MemoryPressureHandler.h&gt;
  88 #include &lt;wtf/MonotonicTime.h&gt;
  89 #include &lt;wtf/NeverDestroyed.h&gt;
  90 #include &lt;wtf/Scope.h&gt;
  91 #include &lt;wtf/StringPrintStream.h&gt;
  92 #include &lt;wtf/URL.h&gt;
  93 #include &lt;wtf/WallTime.h&gt;
  94 #include &lt;wtf/text/StringBuilder.h&gt;
  95 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
  96 
  97 #if OS(WINDOWS)
  98 #include &lt;direct.h&gt;
  99 #include &lt;fcntl.h&gt;
 100 #include &lt;io.h&gt;
<a name="5" id="anc5"></a><span class="line-removed"> 101 #include &lt;wtf/text/win/WCharStringExtras.h&gt;</span>
 102 #else
 103 #include &lt;unistd.h&gt;
 104 #endif
 105 
 106 #if PLATFORM(COCOA)
 107 #include &lt;crt_externs.h&gt;
 108 #endif
 109 
 110 #if HAVE(READLINE)
 111 // readline/history.h has a Function typedef which conflicts with the WTF::Function template from WTF/Forward.h
 112 // We #define it to something else to avoid this conflict.
 113 #define Function ReadlineFunction
 114 #include &lt;readline/history.h&gt;
 115 #include &lt;readline/readline.h&gt;
 116 #undef Function
 117 #endif
 118 
 119 #if HAVE(SYS_TIME_H)
 120 #include &lt;sys/time.h&gt;
 121 #endif
 122 
 123 #if HAVE(SIGNAL_H)
 124 #include &lt;signal.h&gt;
 125 #endif
 126 
 127 #if COMPILER(MSVC)
 128 #include &lt;crtdbg.h&gt;
 129 #include &lt;mmsystem.h&gt;
 130 #include &lt;windows.h&gt;
 131 #endif
 132 
 133 #if PLATFORM(IOS_FAMILY) &amp;&amp; CPU(ARM_THUMB2)
 134 #include &lt;fenv.h&gt;
 135 #include &lt;arm/arch.h&gt;
 136 #endif
 137 
<a name="6" id="anc6"></a><span class="line-modified"> 138 #if __has_include(&lt;WebKitAdditions/MemoryFootprint.h&gt;)</span>
<span class="line-modified"> 139 #include &lt;WebKitAdditions/MemoryFootprint.h&gt;</span>






 140 #else
 141 struct MemoryFootprint {
 142     uint64_t current;
 143     uint64_t peak;
 144 
 145     static MemoryFootprint now()
 146     {
 147         return { 0L, 0L };
 148     }
 149 
 150     static void resetPeak()
 151     {
 152     }
 153 };
 154 #endif
 155 
 156 #if !defined(PATH_MAX)
 157 #define PATH_MAX 4096
 158 #endif
 159 
 160 using namespace JSC;
 161 
 162 namespace {
 163 
 164 NO_RETURN_WITH_VALUE static void jscExit(int status)
 165 {
 166     waitForAsynchronousDisassembly();
 167 
 168 #if ENABLE(DFG_JIT)
 169     if (DFG::isCrashing()) {
 170         for (;;) {
 171 #if OS(WINDOWS)
 172             Sleep(1000);
 173 #else
 174             pause();
 175 #endif
 176         }
 177     }
 178 #endif // ENABLE(DFG_JIT)
 179     exit(status);
 180 }
 181 
 182 class Masquerader : public JSNonFinalObject {
 183 public:
 184     Masquerader(VM&amp; vm, Structure* structure)
 185         : Base(vm, structure)
 186     {
 187     }
 188 
 189     typedef JSNonFinalObject Base;
 190     static const unsigned StructureFlags = Base::StructureFlags | JSC::MasqueradesAsUndefined;
 191 
 192     static Masquerader* create(VM&amp; vm, JSGlobalObject* globalObject)
 193     {
 194         globalObject-&gt;masqueradesAsUndefinedWatchpoint()-&gt;fireAll(vm, &quot;Masquerading object allocated&quot;);
 195         Structure* structure = createStructure(vm, globalObject, jsNull());
<a name="7" id="anc7"></a><span class="line-modified"> 196         Masquerader* result = new (NotNull, allocateCell&lt;Masquerader&gt;(vm.heap, sizeof(Masquerader))) Masquerader(vm, structure);</span>
 197         result-&gt;finishCreation(vm);
 198         return result;
 199     }
 200 
 201     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 202     {
 203         return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
 204     }
 205 
 206     DECLARE_INFO;
 207 };
 208 
 209 const ClassInfo Masquerader::s_info = { &quot;Masquerader&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(Masquerader) };
 210 static unsigned asyncTestPasses { 0 };
 211 static unsigned asyncTestExpectedPasses { 0 };
 212 
 213 }
 214 
 215 template&lt;typename Vector&gt;
 216 static bool fillBufferWithContentsOfFile(const String&amp; fileName, Vector&amp; buffer);
 217 static RefPtr&lt;Uint8Array&gt; fillBufferWithContentsOfFile(const String&amp; fileName);
 218 
 219 class CommandLine;
 220 class GlobalObject;
 221 class Workers;
 222 
 223 template&lt;typename Func&gt;
 224 int runJSC(const CommandLine&amp;, bool isWorker, const Func&amp;);
 225 static void checkException(ExecState*, GlobalObject*, bool isLastFile, bool hasException, JSValue, CommandLine&amp;, bool&amp; success);
 226 
 227 class Message : public ThreadSafeRefCounted&lt;Message&gt; {
 228 public:
 229     Message(ArrayBufferContents&amp;&amp;, int32_t);
 230     ~Message();
 231 
 232     ArrayBufferContents&amp;&amp; releaseContents() { return WTFMove(m_contents); }
 233     int32_t index() const { return m_index; }
 234 
 235 private:
 236     ArrayBufferContents m_contents;
 237     int32_t m_index { 0 };
 238 };
 239 
 240 class Worker : public BasicRawSentinelNode&lt;Worker&gt; {
 241 public:
 242     Worker(Workers&amp;);
 243     ~Worker();
 244 
 245     void enqueue(const AbstractLocker&amp;, RefPtr&lt;Message&gt;);
 246     RefPtr&lt;Message&gt; dequeue();
 247 
 248     static Worker&amp; current();
 249 
 250 private:
 251     static ThreadSpecific&lt;Worker*&gt;&amp; currentWorker();
 252 
 253     Workers&amp; m_workers;
 254     Deque&lt;RefPtr&lt;Message&gt;&gt; m_messages;
 255 };
 256 
 257 class Workers {
 258     WTF_MAKE_FAST_ALLOCATED;
 259     WTF_MAKE_NONCOPYABLE(Workers);
 260 public:
 261     Workers();
 262     ~Workers();
 263 
 264     template&lt;typename Func&gt;
 265     void broadcast(const Func&amp;);
 266 
 267     void report(const String&amp;);
 268     String tryGetReport();
 269     String getReport();
 270 
 271     static Workers&amp; singleton();
 272 
 273 private:
 274     friend class Worker;
 275 
 276     Lock m_lock;
 277     Condition m_condition;
 278     SentinelLinkedList&lt;Worker, BasicRawSentinelNode&lt;Worker&gt;&gt; m_workers;
 279     Deque&lt;String&gt; m_reports;
 280 };
 281 
 282 
 283 static EncodedJSValue JSC_HOST_CALL functionCreateGlobalObject(ExecState*);
 284 
 285 static EncodedJSValue JSC_HOST_CALL functionPrintStdOut(ExecState*);
 286 static EncodedJSValue JSC_HOST_CALL functionPrintStdErr(ExecState*);
 287 static EncodedJSValue JSC_HOST_CALL functionDebug(ExecState*);
 288 static EncodedJSValue JSC_HOST_CALL functionDescribe(ExecState*);
 289 static EncodedJSValue JSC_HOST_CALL functionDescribeArray(ExecState*);
 290 static EncodedJSValue JSC_HOST_CALL functionSleepSeconds(ExecState*);
 291 static EncodedJSValue JSC_HOST_CALL functionJSCStack(ExecState*);
 292 static EncodedJSValue JSC_HOST_CALL functionGCAndSweep(ExecState*);
 293 static EncodedJSValue JSC_HOST_CALL functionFullGC(ExecState*);
 294 static EncodedJSValue JSC_HOST_CALL functionEdenGC(ExecState*);
 295 static EncodedJSValue JSC_HOST_CALL functionForceGCSlowPaths(ExecState*);
 296 static EncodedJSValue JSC_HOST_CALL functionHeapSize(ExecState*);
 297 static EncodedJSValue JSC_HOST_CALL functionCreateMemoryFootprint(ExecState*);
 298 static EncodedJSValue JSC_HOST_CALL functionResetMemoryPeak(ExecState*);
 299 static EncodedJSValue JSC_HOST_CALL functionAddressOf(ExecState*);
 300 static EncodedJSValue JSC_HOST_CALL functionVersion(ExecState*);
 301 static EncodedJSValue JSC_HOST_CALL functionRun(ExecState*);
 302 static EncodedJSValue JSC_HOST_CALL functionRunString(ExecState*);
 303 static EncodedJSValue JSC_HOST_CALL functionLoad(ExecState*);
 304 static EncodedJSValue JSC_HOST_CALL functionLoadString(ExecState*);
 305 static EncodedJSValue JSC_HOST_CALL functionReadFile(ExecState*);
 306 static EncodedJSValue JSC_HOST_CALL functionCheckSyntax(ExecState*);
 307 static EncodedJSValue JSC_HOST_CALL functionReadline(ExecState*);
 308 static EncodedJSValue JSC_HOST_CALL functionPreciseTime(ExecState*);
 309 static EncodedJSValue JSC_HOST_CALL functionNeverInlineFunction(ExecState*);
 310 static EncodedJSValue JSC_HOST_CALL functionNoDFG(ExecState*);
 311 static EncodedJSValue JSC_HOST_CALL functionNoFTL(ExecState*);
 312 static EncodedJSValue JSC_HOST_CALL functionNoOSRExitFuzzing(ExecState*);
 313 static EncodedJSValue JSC_HOST_CALL functionOptimizeNextInvocation(ExecState*);
 314 static EncodedJSValue JSC_HOST_CALL functionNumberOfDFGCompiles(ExecState*);
 315 static EncodedJSValue JSC_HOST_CALL functionJSCOptions(ExecState*);
 316 static EncodedJSValue JSC_HOST_CALL functionReoptimizationRetryCount(ExecState*);
 317 static EncodedJSValue JSC_HOST_CALL functionTransferArrayBuffer(ExecState*);
 318 static EncodedJSValue JSC_HOST_CALL functionFailNextNewCodeBlock(ExecState*);
 319 static NO_RETURN_WITH_VALUE EncodedJSValue JSC_HOST_CALL functionQuit(ExecState*);
 320 static EncodedJSValue JSC_HOST_CALL functionFalse(ExecState*);
 321 static EncodedJSValue JSC_HOST_CALL functionUndefined1(ExecState*);
 322 static EncodedJSValue JSC_HOST_CALL functionUndefined2(ExecState*);
 323 static EncodedJSValue JSC_HOST_CALL functionIsInt32(ExecState*);
 324 static EncodedJSValue JSC_HOST_CALL functionIsPureNaN(ExecState*);
 325 static EncodedJSValue JSC_HOST_CALL functionEffectful42(ExecState*);
 326 static EncodedJSValue JSC_HOST_CALL functionIdentity(ExecState*);
 327 static EncodedJSValue JSC_HOST_CALL functionMakeMasquerader(ExecState*);
 328 static EncodedJSValue JSC_HOST_CALL functionHasCustomProperties(ExecState*);
 329 static EncodedJSValue JSC_HOST_CALL functionDumpTypesForAllVariables(ExecState*);
 330 static EncodedJSValue JSC_HOST_CALL functionDrainMicrotasks(ExecState*);
<a name="8" id="anc8"></a>
 331 static EncodedJSValue JSC_HOST_CALL functionIs32BitPlatform(ExecState*);
 332 static EncodedJSValue JSC_HOST_CALL functionCheckModuleSyntax(ExecState*);
 333 static EncodedJSValue JSC_HOST_CALL functionPlatformSupportsSamplingProfiler(ExecState*);
 334 static EncodedJSValue JSC_HOST_CALL functionGenerateHeapSnapshot(ExecState*);
 335 static EncodedJSValue JSC_HOST_CALL functionGenerateHeapSnapshotForGCDebugging(ExecState*);
 336 static EncodedJSValue JSC_HOST_CALL functionResetSuperSamplerState(ExecState*);
 337 static EncodedJSValue JSC_HOST_CALL functionEnsureArrayStorage(ExecState*);
 338 #if ENABLE(SAMPLING_PROFILER)
 339 static EncodedJSValue JSC_HOST_CALL functionStartSamplingProfiler(ExecState*);
 340 static EncodedJSValue JSC_HOST_CALL functionSamplingProfilerStackTraces(ExecState*);
 341 #endif
 342 
 343 static EncodedJSValue JSC_HOST_CALL functionMaxArguments(ExecState*);
 344 static EncodedJSValue JSC_HOST_CALL functionAsyncTestStart(ExecState*);
 345 static EncodedJSValue JSC_HOST_CALL functionAsyncTestPassed(ExecState*);
 346 
 347 #if ENABLE(WEBASSEMBLY)
 348 static EncodedJSValue JSC_HOST_CALL functionWebAssemblyMemoryMode(ExecState*);
 349 #endif
 350 
 351 #if ENABLE(SAMPLING_FLAGS)
 352 static EncodedJSValue JSC_HOST_CALL functionSetSamplingFlags(ExecState*);
 353 static EncodedJSValue JSC_HOST_CALL functionClearSamplingFlags(ExecState*);
 354 #endif
 355 
 356 static EncodedJSValue JSC_HOST_CALL functionGetRandomSeed(ExecState*);
 357 static EncodedJSValue JSC_HOST_CALL functionSetRandomSeed(ExecState*);
 358 static EncodedJSValue JSC_HOST_CALL functionIsRope(ExecState*);
 359 static EncodedJSValue JSC_HOST_CALL functionCallerSourceOrigin(ExecState*);
 360 static EncodedJSValue JSC_HOST_CALL functionDollarCreateRealm(ExecState*);
 361 static EncodedJSValue JSC_HOST_CALL functionDollarDetachArrayBuffer(ExecState*);
 362 static EncodedJSValue JSC_HOST_CALL functionDollarEvalScript(ExecState*);
 363 static EncodedJSValue JSC_HOST_CALL functionDollarAgentStart(ExecState*);
 364 static EncodedJSValue JSC_HOST_CALL functionDollarAgentReceiveBroadcast(ExecState*);
 365 static EncodedJSValue JSC_HOST_CALL functionDollarAgentReport(ExecState*);
 366 static EncodedJSValue JSC_HOST_CALL functionDollarAgentSleep(ExecState*);
 367 static EncodedJSValue JSC_HOST_CALL functionDollarAgentBroadcast(ExecState*);
 368 static EncodedJSValue JSC_HOST_CALL functionDollarAgentGetReport(ExecState*);
 369 static EncodedJSValue JSC_HOST_CALL functionDollarAgentLeaving(ExecState*);
 370 static EncodedJSValue JSC_HOST_CALL functionDollarAgentMonotonicNow(ExecState*);
 371 static EncodedJSValue JSC_HOST_CALL functionWaitForReport(ExecState*);
 372 static EncodedJSValue JSC_HOST_CALL functionHeapCapacity(ExecState*);
 373 static EncodedJSValue JSC_HOST_CALL functionFlashHeapAccess(ExecState*);
 374 static EncodedJSValue JSC_HOST_CALL functionDisableRichSourceInfo(ExecState*);
 375 static EncodedJSValue JSC_HOST_CALL functionMallocInALoop(ExecState*);
 376 static EncodedJSValue JSC_HOST_CALL functionTotalCompileTime(ExecState*);
 377 
<a name="9" id="anc9"></a>

 378 struct Script {
 379     enum class StrictMode {
 380         Strict,
 381         Sloppy
 382     };
 383 
 384     enum class ScriptType {
 385         Script,
 386         Module
 387     };
 388 
 389     enum class CodeSource {
 390         File,
 391         CommandLine
 392     };
 393 
 394     StrictMode strictMode;
 395     CodeSource codeSource;
 396     ScriptType scriptType;
 397     char* argument;
 398 
 399     Script(StrictMode strictMode, CodeSource codeSource, ScriptType scriptType, char *argument)
 400         : strictMode(strictMode)
 401         , codeSource(codeSource)
 402         , scriptType(scriptType)
 403         , argument(argument)
 404     {
 405         if (strictMode == StrictMode::Strict)
 406             ASSERT(codeSource == CodeSource::File);
 407     }
 408 };
 409 
 410 class CommandLine {
 411 public:
 412     CommandLine(int argc, char** argv)
 413     {
 414         parseArguments(argc, argv);
 415     }
 416 
<a name="10" id="anc10"></a>



 417     bool m_interactive { false };
 418     bool m_dump { false };
 419     bool m_module { false };
 420     bool m_exitCode { false };
<a name="11" id="anc11"></a><span class="line-modified"> 421     Vector&lt;Script&gt; m_scripts;</span>
<span class="line-removed"> 422     Vector&lt;String&gt; m_arguments;</span>
 423     bool m_profile { false };
<a name="12" id="anc12"></a><span class="line-removed"> 424     String m_profilerOutput;</span>
<span class="line-removed"> 425     String m_uncaughtExceptionName;</span>
 426     bool m_treatWatchdogExceptionAsSuccess { false };
 427     bool m_alwaysDumpUncaughtException { false };
 428     bool m_dumpMemoryFootprint { false };
 429     bool m_dumpSamplingProfilerData { false };
 430     bool m_enableRemoteDebugging { false };
 431 
 432     void parseArguments(int, char**);
 433 };
 434 
 435 static const char interactivePrompt[] = &quot;&gt;&gt;&gt; &quot;;
 436 
 437 class StopWatch {
 438 public:
 439     void start();
 440     void stop();
 441     long getElapsedMS(); // call stop() first
 442 
 443 private:
 444     MonotonicTime m_startTime;
 445     MonotonicTime m_stopTime;
 446 };
 447 
 448 void StopWatch::start()
 449 {
 450     m_startTime = MonotonicTime::now();
 451 }
 452 
 453 void StopWatch::stop()
 454 {
 455     m_stopTime = MonotonicTime::now();
 456 }
 457 
 458 long StopWatch::getElapsedMS()
 459 {
 460     return (m_stopTime - m_startTime).millisecondsAs&lt;long&gt;();
 461 }
 462 
 463 template&lt;typename Vector&gt;
 464 static inline String stringFromUTF(const Vector&amp; utf8)
 465 {
 466     return String::fromUTF8WithLatin1Fallback(utf8.data(), utf8.size());
 467 }
 468 
 469 class GlobalObject : public JSGlobalObject {
 470 private:
 471     GlobalObject(VM&amp;, Structure*);
 472 
 473 public:
 474     typedef JSGlobalObject Base;
 475 
 476     static GlobalObject* create(VM&amp; vm, Structure* structure, const Vector&lt;String&gt;&amp; arguments)
 477     {
 478         GlobalObject* object = new (NotNull, allocateCell&lt;GlobalObject&gt;(vm.heap)) GlobalObject(vm, structure);
 479         object-&gt;finishCreation(vm, arguments);
 480         return object;
 481     }
 482 
 483     static const bool needsDestruction = false;
 484 
 485     DECLARE_INFO;
 486     static const GlobalObjectMethodTable s_globalObjectMethodTable;
 487 
 488     static Structure* createStructure(VM&amp; vm, JSValue prototype)
 489     {
 490         return Structure::create(vm, 0, prototype, TypeInfo(GlobalObjectType, StructureFlags), info());
 491     }
 492 
 493     static RuntimeFlags javaScriptRuntimeFlags(const JSGlobalObject*) { return RuntimeFlags::createAllEnabled(); }
 494 
 495 protected:
 496     void finishCreation(VM&amp; vm, const Vector&lt;String&gt;&amp; arguments)
 497     {
 498         Base::finishCreation(vm);
 499 
 500         addFunction(vm, &quot;debug&quot;, functionDebug, 1);
 501         addFunction(vm, &quot;describe&quot;, functionDescribe, 1);
 502         addFunction(vm, &quot;describeArray&quot;, functionDescribeArray, 1);
 503         addFunction(vm, &quot;print&quot;, functionPrintStdOut, 1);
 504         addFunction(vm, &quot;printErr&quot;, functionPrintStdErr, 1);
 505         addFunction(vm, &quot;quit&quot;, functionQuit, 0);
 506         addFunction(vm, &quot;gc&quot;, functionGCAndSweep, 0);
 507         addFunction(vm, &quot;fullGC&quot;, functionFullGC, 0);
 508         addFunction(vm, &quot;edenGC&quot;, functionEdenGC, 0);
 509         addFunction(vm, &quot;forceGCSlowPaths&quot;, functionForceGCSlowPaths, 0);
 510         addFunction(vm, &quot;gcHeapSize&quot;, functionHeapSize, 0);
 511         addFunction(vm, &quot;MemoryFootprint&quot;, functionCreateMemoryFootprint, 0);
 512         addFunction(vm, &quot;resetMemoryPeak&quot;, functionResetMemoryPeak, 0);
 513         addFunction(vm, &quot;addressOf&quot;, functionAddressOf, 1);
 514         addFunction(vm, &quot;version&quot;, functionVersion, 1);
 515         addFunction(vm, &quot;run&quot;, functionRun, 1);
 516         addFunction(vm, &quot;runString&quot;, functionRunString, 1);
 517         addFunction(vm, &quot;load&quot;, functionLoad, 1);
 518         addFunction(vm, &quot;loadString&quot;, functionLoadString, 1);
 519         addFunction(vm, &quot;readFile&quot;, functionReadFile, 2);
 520         addFunction(vm, &quot;read&quot;, functionReadFile, 2);
 521         addFunction(vm, &quot;checkSyntax&quot;, functionCheckSyntax, 1);
 522         addFunction(vm, &quot;sleepSeconds&quot;, functionSleepSeconds, 1);
 523         addFunction(vm, &quot;jscStack&quot;, functionJSCStack, 1);
 524         addFunction(vm, &quot;readline&quot;, functionReadline, 0);
 525         addFunction(vm, &quot;preciseTime&quot;, functionPreciseTime, 0);
 526         addFunction(vm, &quot;neverInlineFunction&quot;, functionNeverInlineFunction, 1);
 527         addFunction(vm, &quot;noInline&quot;, functionNeverInlineFunction, 1);
 528         addFunction(vm, &quot;noDFG&quot;, functionNoDFG, 1);
 529         addFunction(vm, &quot;noFTL&quot;, functionNoFTL, 1);
 530         addFunction(vm, &quot;noOSRExitFuzzing&quot;, functionNoOSRExitFuzzing, 1);
 531         addFunction(vm, &quot;numberOfDFGCompiles&quot;, functionNumberOfDFGCompiles, 1);
 532         addFunction(vm, &quot;jscOptions&quot;, functionJSCOptions, 0);
 533         addFunction(vm, &quot;optimizeNextInvocation&quot;, functionOptimizeNextInvocation, 1);
 534         addFunction(vm, &quot;reoptimizationRetryCount&quot;, functionReoptimizationRetryCount, 1);
 535         addFunction(vm, &quot;transferArrayBuffer&quot;, functionTransferArrayBuffer, 1);
 536         addFunction(vm, &quot;failNextNewCodeBlock&quot;, functionFailNextNewCodeBlock, 1);
 537 #if ENABLE(SAMPLING_FLAGS)
 538         addFunction(vm, &quot;setSamplingFlags&quot;, functionSetSamplingFlags, 1);
 539         addFunction(vm, &quot;clearSamplingFlags&quot;, functionClearSamplingFlags, 1);
 540 #endif
 541 
<a name="13" id="anc13"></a><span class="line-modified"> 542         putDirectNativeFunction(vm, this, Identifier::fromString(&amp;vm, &quot;OSRExit&quot;), 0, functionUndefined1, OSRExitIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified"> 543         putDirectNativeFunction(vm, this, Identifier::fromString(&amp;vm, &quot;isFinalTier&quot;), 0, functionFalse, IsFinalTierIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified"> 544         putDirectNativeFunction(vm, this, Identifier::fromString(&amp;vm, &quot;predictInt32&quot;), 0, functionUndefined2, SetInt32HeapPredictionIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified"> 545         putDirectNativeFunction(vm, this, Identifier::fromString(&amp;vm, &quot;isInt32&quot;), 0, functionIsInt32, CheckInt32Intrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified"> 546         putDirectNativeFunction(vm, this, Identifier::fromString(&amp;vm, &quot;isPureNaN&quot;), 0, functionIsPureNaN, CheckInt32Intrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified"> 547         putDirectNativeFunction(vm, this, Identifier::fromString(&amp;vm, &quot;fiatInt52&quot;), 0, functionIdentity, FiatInt52Intrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
 548 
 549         addFunction(vm, &quot;effectful42&quot;, functionEffectful42, 0);
 550         addFunction(vm, &quot;makeMasquerader&quot;, functionMakeMasquerader, 0);
 551         addFunction(vm, &quot;hasCustomProperties&quot;, functionHasCustomProperties, 0);
 552 
 553         addFunction(vm, &quot;createGlobalObject&quot;, functionCreateGlobalObject, 0);
 554 
 555         addFunction(vm, &quot;dumpTypesForAllVariables&quot;, functionDumpTypesForAllVariables , 0);
 556 
 557         addFunction(vm, &quot;drainMicrotasks&quot;, functionDrainMicrotasks, 0);
<a name="14" id="anc14"></a>
 558 
 559         addFunction(vm, &quot;getRandomSeed&quot;, functionGetRandomSeed, 0);
 560         addFunction(vm, &quot;setRandomSeed&quot;, functionSetRandomSeed, 1);
 561         addFunction(vm, &quot;isRope&quot;, functionIsRope, 1);
 562         addFunction(vm, &quot;callerSourceOrigin&quot;, functionCallerSourceOrigin, 0);
 563 
 564         addFunction(vm, &quot;is32BitPlatform&quot;, functionIs32BitPlatform, 0);
 565 
 566         addFunction(vm, &quot;checkModuleSyntax&quot;, functionCheckModuleSyntax, 1);
 567 
 568         addFunction(vm, &quot;platformSupportsSamplingProfiler&quot;, functionPlatformSupportsSamplingProfiler, 0);
 569         addFunction(vm, &quot;generateHeapSnapshot&quot;, functionGenerateHeapSnapshot, 0);
 570         addFunction(vm, &quot;generateHeapSnapshotForGCDebugging&quot;, functionGenerateHeapSnapshotForGCDebugging, 0);
 571         addFunction(vm, &quot;resetSuperSamplerState&quot;, functionResetSuperSamplerState, 0);
 572         addFunction(vm, &quot;ensureArrayStorage&quot;, functionEnsureArrayStorage, 0);
 573 #if ENABLE(SAMPLING_PROFILER)
 574         addFunction(vm, &quot;startSamplingProfiler&quot;, functionStartSamplingProfiler, 0);
 575         addFunction(vm, &quot;samplingProfilerStackTraces&quot;, functionSamplingProfilerStackTraces, 0);
 576 #endif
 577 
 578         addFunction(vm, &quot;maxArguments&quot;, functionMaxArguments, 0);
 579 
 580         addFunction(vm, &quot;asyncTestStart&quot;, functionAsyncTestStart, 1);
 581         addFunction(vm, &quot;asyncTestPassed&quot;, functionAsyncTestPassed, 1);
 582 
 583 #if ENABLE(WEBASSEMBLY)
 584         addFunction(vm, &quot;WebAssemblyMemoryMode&quot;, functionWebAssemblyMemoryMode, 1);
 585 #endif
 586 
 587         if (!arguments.isEmpty()) {
 588             JSArray* array = constructEmptyArray(globalExec(), 0);
 589             for (size_t i = 0; i &lt; arguments.size(); ++i)
<a name="15" id="anc15"></a><span class="line-modified"> 590                 array-&gt;putDirectIndex(globalExec(), i, jsString(globalExec(), arguments[i]));</span>
<span class="line-modified"> 591             putDirect(vm, Identifier::fromString(globalExec(), &quot;arguments&quot;), array);</span>
 592         }
 593 
<a name="16" id="anc16"></a><span class="line-modified"> 594         putDirect(vm, Identifier::fromString(globalExec(), &quot;console&quot;), jsUndefined());</span>
 595 
 596         Structure* plainObjectStructure = JSFinalObject::createStructure(vm, this, objectPrototype(), 0);
 597 
 598         JSObject* dollar = JSFinalObject::create(vm, plainObjectStructure);
<a name="17" id="anc17"></a><span class="line-modified"> 599         putDirect(vm, Identifier::fromString(globalExec(), &quot;$&quot;), dollar);</span>
<span class="line-modified"> 600         putDirect(vm, Identifier::fromString(globalExec(), &quot;$262&quot;), dollar);</span>
 601 
 602         addFunction(vm, dollar, &quot;createRealm&quot;, functionDollarCreateRealm, 0);
 603         addFunction(vm, dollar, &quot;detachArrayBuffer&quot;, functionDollarDetachArrayBuffer, 1);
 604         addFunction(vm, dollar, &quot;evalScript&quot;, functionDollarEvalScript, 1);
 605 
<a name="18" id="anc18"></a><span class="line-modified"> 606         dollar-&gt;putDirect(vm, Identifier::fromString(globalExec(), &quot;global&quot;), this);</span>
 607 
 608         JSObject* agent = JSFinalObject::create(vm, plainObjectStructure);
<a name="19" id="anc19"></a><span class="line-modified"> 609         dollar-&gt;putDirect(vm, Identifier::fromString(globalExec(), &quot;agent&quot;), agent);</span>
 610 
 611         // The test262 INTERPRETING.md document says that some of these functions are just in the main
 612         // thread and some are in the other threads. We just put them in all threads.
 613         addFunction(vm, agent, &quot;start&quot;, functionDollarAgentStart, 1);
 614         addFunction(vm, agent, &quot;receiveBroadcast&quot;, functionDollarAgentReceiveBroadcast, 1);
 615         addFunction(vm, agent, &quot;report&quot;, functionDollarAgentReport, 1);
 616         addFunction(vm, agent, &quot;sleep&quot;, functionDollarAgentSleep, 1);
 617         addFunction(vm, agent, &quot;broadcast&quot;, functionDollarAgentBroadcast, 1);
 618         addFunction(vm, agent, &quot;getReport&quot;, functionDollarAgentGetReport, 0);
 619         addFunction(vm, agent, &quot;leaving&quot;, functionDollarAgentLeaving, 0);
 620         addFunction(vm, agent, &quot;monotonicNow&quot;, functionDollarAgentMonotonicNow, 0);
 621 
 622         addFunction(vm, &quot;waitForReport&quot;, functionWaitForReport, 0);
 623 
 624         addFunction(vm, &quot;heapCapacity&quot;, functionHeapCapacity, 0);
 625         addFunction(vm, &quot;flashHeapAccess&quot;, functionFlashHeapAccess, 0);
 626 
 627         addFunction(vm, &quot;disableRichSourceInfo&quot;, functionDisableRichSourceInfo, 0);
 628         addFunction(vm, &quot;mallocInALoop&quot;, functionMallocInALoop, 0);
 629         addFunction(vm, &quot;totalCompileTime&quot;, functionTotalCompileTime, 0);
<a name="20" id="anc20"></a>

 630     }
 631 
 632     void addFunction(VM&amp; vm, JSObject* object, const char* name, NativeFunction function, unsigned arguments)
 633     {
<a name="21" id="anc21"></a><span class="line-modified"> 634         Identifier identifier = Identifier::fromString(&amp;vm, name);</span>
 635         object-&gt;putDirect(vm, identifier, JSFunction::create(vm, this, arguments, identifier.string(), function));
 636     }
 637 
 638     void addFunction(VM&amp; vm, const char* name, NativeFunction function, unsigned arguments)
 639     {
 640         addFunction(vm, this, name, function, arguments);
 641     }
 642 
 643     static JSInternalPromise* moduleLoaderImportModule(JSGlobalObject*, ExecState*, JSModuleLoader*, JSString*, JSValue, const SourceOrigin&amp;);
 644     static Identifier moduleLoaderResolve(JSGlobalObject*, ExecState*, JSModuleLoader*, JSValue, JSValue, JSValue);
 645     static JSInternalPromise* moduleLoaderFetch(JSGlobalObject*, ExecState*, JSModuleLoader*, JSValue, JSValue, JSValue);
 646     static JSObject* moduleLoaderCreateImportMetaProperties(JSGlobalObject*, ExecState*, JSModuleLoader*, JSValue, JSModuleRecord*, JSValue);
 647 };
 648 
 649 static bool supportsRichSourceInfo = true;
 650 static bool shellSupportsRichSourceInfo(const JSGlobalObject*)
 651 {
 652     return supportsRichSourceInfo;
 653 }
 654 
 655 const ClassInfo GlobalObject::s_info = { &quot;global&quot;, &amp;JSGlobalObject::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(GlobalObject) };
 656 const GlobalObjectMethodTable GlobalObject::s_globalObjectMethodTable = {
 657     &amp;shellSupportsRichSourceInfo,
 658     &amp;shouldInterruptScript,
 659     &amp;javaScriptRuntimeFlags,
 660     nullptr, // queueTaskToEventLoop
 661     &amp;shouldInterruptScriptBeforeTimeout,
 662     &amp;moduleLoaderImportModule,
 663     &amp;moduleLoaderResolve,
 664     &amp;moduleLoaderFetch,
 665     &amp;moduleLoaderCreateImportMetaProperties,
 666     nullptr, // moduleLoaderEvaluate
 667     nullptr, // promiseRejectionTracker
 668     nullptr, // defaultLanguage
 669     nullptr, // compileStreaming
 670     nullptr, // instantinateStreaming
 671 };
 672 
 673 GlobalObject::GlobalObject(VM&amp; vm, Structure* structure)
 674     : JSGlobalObject(vm, structure, &amp;s_globalObjectMethodTable)
 675 {
 676 }
 677 
 678 static UChar pathSeparator()
 679 {
 680 #if OS(WINDOWS)
 681     return &#39;\\&#39;;
 682 #else
 683     return &#39;/&#39;;
 684 #endif
 685 }
 686 
 687 struct DirectoryName {
 688     // In unix, it is &quot;/&quot;. In Windows, it becomes a drive letter like &quot;C:\&quot;
 689     String rootName;
 690 
 691     // If the directory name is &quot;/home/WebKit&quot;, this becomes &quot;home/WebKit&quot;. If the directory name is &quot;/&quot;, this becomes &quot;&quot;.
 692     String queryName;
 693 };
 694 
 695 struct ModuleName {
 696     ModuleName(const String&amp; moduleName);
 697 
 698     bool startsWithRoot() const
 699     {
 700         return !queries.isEmpty() &amp;&amp; queries[0].isEmpty();
 701     }
 702 
 703     Vector&lt;String&gt; queries;
 704 };
 705 
 706 ModuleName::ModuleName(const String&amp; moduleName)
 707 {
 708     // A module name given from code is represented as the UNIX style path. Like, `./A/B.js`.
 709     queries = moduleName.splitAllowingEmptyEntries(&#39;/&#39;);
 710 }
 711 
 712 static Optional&lt;DirectoryName&gt; extractDirectoryName(const String&amp; absolutePathToFile)
 713 {
 714     size_t firstSeparatorPosition = absolutePathToFile.find(pathSeparator());
 715     if (firstSeparatorPosition == notFound)
 716         return WTF::nullopt;
 717     DirectoryName directoryName;
 718     directoryName.rootName = absolutePathToFile.substring(0, firstSeparatorPosition + 1); // Include the separator.
 719     size_t lastSeparatorPosition = absolutePathToFile.reverseFind(pathSeparator());
 720     ASSERT_WITH_MESSAGE(lastSeparatorPosition != notFound, &quot;If the separator is not found, this function already returns when performing the forward search.&quot;);
 721     if (firstSeparatorPosition == lastSeparatorPosition)
 722         directoryName.queryName = StringImpl::empty();
 723     else {
 724         size_t queryStartPosition = firstSeparatorPosition + 1;
 725         size_t queryLength = lastSeparatorPosition - queryStartPosition; // Not include the last separator.
 726         directoryName.queryName = absolutePathToFile.substring(queryStartPosition, queryLength);
 727     }
 728     return directoryName;
 729 }
 730 
 731 static Optional&lt;DirectoryName&gt; currentWorkingDirectory()
 732 {
 733 #if OS(WINDOWS)
 734     // https://msdn.microsoft.com/en-us/library/windows/desktop/aa364934.aspx
 735     // https://msdn.microsoft.com/en-us/library/windows/desktop/aa365247.aspx#maxpath
 736     // The _MAX_PATH in Windows is 260. If the path of the current working directory is longer than that, _getcwd truncates the result.
 737     // And other I/O functions taking a path name also truncate it. To avoid this situation,
 738     //
 739     // (1). When opening the file in Windows for modules, we always use the abosolute path and add &quot;\\?\&quot; prefix to the path name.
 740     // (2). When retrieving the current working directory, use GetCurrentDirectory instead of _getcwd.
 741     //
 742     // In the path utility functions inside the JSC shell, we does not handle the UNC and UNCW including the network host name.
 743     DWORD bufferLength = ::GetCurrentDirectoryW(0, nullptr);
 744     if (!bufferLength)
 745         return WTF::nullopt;
 746     // In Windows, wchar_t is the UTF-16LE.
 747     // https://msdn.microsoft.com/en-us/library/dd374081.aspx
 748     // https://msdn.microsoft.com/en-us/library/windows/desktop/ff381407.aspx
 749     Vector&lt;wchar_t&gt; buffer(bufferLength);
 750     DWORD lengthNotIncludingNull = ::GetCurrentDirectoryW(bufferLength, buffer.data());
<a name="22" id="anc22"></a><span class="line-modified"> 751     String directoryString = wcharToString(buffer.data(), lengthNotIncludingNull);</span>
 752     // We don&#39;t support network path like \\host\share\&lt;path name&gt;.
 753     if (directoryString.startsWith(&quot;\\\\&quot;))
 754         return WTF::nullopt;
 755 #else
 756     Vector&lt;char&gt; buffer(PATH_MAX);
 757     if (!getcwd(buffer.data(), PATH_MAX))
 758         return WTF::nullopt;
 759     String directoryString = String::fromUTF8(buffer.data());
 760 #endif
 761     if (directoryString.isEmpty())
 762         return WTF::nullopt;
 763 
 764     if (directoryString[directoryString.length() - 1] == pathSeparator())
 765         return extractDirectoryName(directoryString);
 766     // Append the seperator to represents the file name. extractDirectoryName only accepts the absolute file name.
 767     return extractDirectoryName(makeString(directoryString, pathSeparator()));
 768 }
 769 
 770 static String resolvePath(const DirectoryName&amp; directoryName, const ModuleName&amp; moduleName)
 771 {
 772     Vector&lt;String&gt; directoryPieces = directoryName.queryName.split(pathSeparator());
 773 
 774     // Only first &#39;/&#39; is recognized as the path from the root.
 775     if (moduleName.startsWithRoot())
 776         directoryPieces.clear();
 777 
 778     for (const auto&amp; query : moduleName.queries) {
 779         if (query == String(&quot;..&quot;_s)) {
 780             if (!directoryPieces.isEmpty())
 781                 directoryPieces.removeLast();
 782         } else if (!query.isEmpty() &amp;&amp; query != String(&quot;.&quot;_s))
 783             directoryPieces.append(query);
 784     }
 785 
 786     StringBuilder builder;
 787     builder.append(directoryName.rootName);
 788     for (size_t i = 0; i &lt; directoryPieces.size(); ++i) {
 789         builder.append(directoryPieces[i]);
 790         if (i + 1 != directoryPieces.size())
 791             builder.append(pathSeparator());
 792     }
 793     return builder.toString();
 794 }
 795 
 796 static String absolutePath(const String&amp; fileName)
 797 {
 798     auto directoryName = currentWorkingDirectory();
 799     if (!directoryName)
 800         return fileName;
 801     return resolvePath(directoryName.value(), ModuleName(fileName.impl()));
 802 }
 803 
 804 JSInternalPromise* GlobalObject::moduleLoaderImportModule(JSGlobalObject* globalObject, ExecState* exec, JSModuleLoader*, JSString* moduleNameValue, JSValue parameters, const SourceOrigin&amp; sourceOrigin)
 805 {
 806     VM&amp; vm = globalObject-&gt;vm();
 807     auto throwScope = DECLARE_THROW_SCOPE(vm);
 808 
 809     auto* deferred = JSInternalPromiseDeferred::tryCreate(exec, globalObject);
 810     RETURN_IF_EXCEPTION(throwScope, nullptr);
 811 
 812     auto catchScope = DECLARE_CATCH_SCOPE(vm);
 813     auto reject = [&amp;] (JSValue rejectionReason) {
 814         catchScope.clearException();
 815         auto result = deferred-&gt;reject(exec, rejectionReason);
 816         catchScope.clearException();
 817         return result;
 818     };
 819 
 820     if (sourceOrigin.isNull())
 821         return reject(createError(exec, &quot;Could not resolve the module specifier.&quot;_s));
 822 
 823     const auto&amp; referrer = sourceOrigin.string();
 824     const auto&amp; moduleName = moduleNameValue-&gt;value(exec);
 825     if (UNLIKELY(catchScope.exception()))
 826         return reject(catchScope.exception());
 827 
 828     auto directoryName = extractDirectoryName(referrer.impl());
 829     if (!directoryName)
 830         return reject(createError(exec, makeString(&quot;Could not resolve the referrer name &#39;&quot;, String(referrer.impl()), &quot;&#39;.&quot;)));
 831 
<a name="23" id="anc23"></a><span class="line-modified"> 832     auto result = JSC::importModule(exec, Identifier::fromString(&amp;vm, resolvePath(directoryName.value(), ModuleName(moduleName))), parameters, jsUndefined());</span>
 833     if (UNLIKELY(catchScope.exception()))
 834         return reject(catchScope.exception());
 835     return result;
 836 }
 837 
 838 Identifier GlobalObject::moduleLoaderResolve(JSGlobalObject* globalObject, ExecState* exec, JSModuleLoader*, JSValue keyValue, JSValue referrerValue, JSValue)
 839 {
 840     VM&amp; vm = globalObject-&gt;vm();
 841     auto scope = DECLARE_THROW_SCOPE(vm);
 842 
 843     scope.releaseAssertNoException();
 844     const Identifier key = keyValue.toPropertyKey(exec);
 845     RETURN_IF_EXCEPTION(scope, { });
 846 
 847     if (key.isSymbol())
 848         return key;
 849 
 850     if (referrerValue.isUndefined()) {
 851         auto directoryName = currentWorkingDirectory();
 852         if (!directoryName) {
 853             throwException(exec, scope, createError(exec, &quot;Could not resolve the current working directory.&quot;_s));
 854             return { };
 855         }
<a name="24" id="anc24"></a><span class="line-modified"> 856         return Identifier::fromString(&amp;vm, resolvePath(directoryName.value(), ModuleName(key.impl())));</span>
 857     }
 858 
 859     const Identifier referrer = referrerValue.toPropertyKey(exec);
 860     RETURN_IF_EXCEPTION(scope, { });
 861 
 862     if (referrer.isSymbol()) {
 863         auto directoryName = currentWorkingDirectory();
 864         if (!directoryName) {
 865             throwException(exec, scope, createError(exec, &quot;Could not resolve the current working directory.&quot;_s));
 866             return { };
 867         }
<a name="25" id="anc25"></a><span class="line-modified"> 868         return Identifier::fromString(&amp;vm, resolvePath(directoryName.value(), ModuleName(key.impl())));</span>
 869     }
 870 
 871     // If the referrer exists, we assume that the referrer is the correct absolute path.
 872     auto directoryName = extractDirectoryName(referrer.impl());
 873     if (!directoryName) {
 874         throwException(exec, scope, createError(exec, makeString(&quot;Could not resolve the referrer name &#39;&quot;, String(referrer.impl()), &quot;&#39;.&quot;)));
 875         return { };
 876     }
<a name="26" id="anc26"></a><span class="line-modified"> 877     return Identifier::fromString(&amp;vm, resolvePath(directoryName.value(), ModuleName(key.impl())));</span>
 878 }
 879 
 880 template&lt;typename Vector&gt;
 881 static void convertShebangToJSComment(Vector&amp; buffer)
 882 {
 883     if (buffer.size() &gt;= 2) {
 884         if (buffer[0] == &#39;#&#39; &amp;&amp; buffer[1] == &#39;!&#39;)
 885             buffer[0] = buffer[1] = &#39;/&#39;;
 886     }
 887 }
 888 
 889 static RefPtr&lt;Uint8Array&gt; fillBufferWithContentsOfFile(FILE* file)
 890 {
 891     if (fseek(file, 0, SEEK_END) == -1)
 892         return nullptr;
 893     long bufferCapacity = ftell(file);
 894     if (bufferCapacity == -1)
 895         return nullptr;
 896     if (fseek(file, 0, SEEK_SET) == -1)
 897         return nullptr;
 898     auto result = Uint8Array::tryCreate(bufferCapacity);
 899     if (!result)
 900         return nullptr;
 901     size_t readSize = fread(result-&gt;data(), 1, bufferCapacity, file);
 902     if (readSize != static_cast&lt;size_t&gt;(bufferCapacity))
 903         return nullptr;
 904     return result;
 905 }
 906 
 907 static RefPtr&lt;Uint8Array&gt; fillBufferWithContentsOfFile(const String&amp; fileName)
 908 {
 909     FILE* f = fopen(fileName.utf8().data(), &quot;rb&quot;);
 910     if (!f) {
 911         fprintf(stderr, &quot;Could not open file: %s\n&quot;, fileName.utf8().data());
 912         return nullptr;
 913     }
 914 
 915     RefPtr&lt;Uint8Array&gt; result = fillBufferWithContentsOfFile(f);
 916     fclose(f);
 917 
 918     return result;
 919 }
 920 
 921 template&lt;typename Vector&gt;
 922 static bool fillBufferWithContentsOfFile(FILE* file, Vector&amp; buffer)
 923 {
 924     // We might have injected &quot;use strict&quot;; at the top.
 925     size_t initialSize = buffer.size();
 926     if (fseek(file, 0, SEEK_END) == -1)
 927         return false;
 928     long bufferCapacity = ftell(file);
 929     if (bufferCapacity == -1)
 930         return false;
 931     if (fseek(file, 0, SEEK_SET) == -1)
 932         return false;
 933     buffer.resize(bufferCapacity + initialSize);
 934     size_t readSize = fread(buffer.data() + initialSize, 1, buffer.size(), file);
 935     return readSize == buffer.size() - initialSize;
 936 }
 937 
 938 static bool fillBufferWithContentsOfFile(const String&amp; fileName, Vector&lt;char&gt;&amp; buffer)
 939 {
 940     FILE* f = fopen(fileName.utf8().data(), &quot;rb&quot;);
 941     if (!f) {
 942         fprintf(stderr, &quot;Could not open file: %s\n&quot;, fileName.utf8().data());
 943         return false;
 944     }
 945 
 946     bool result = fillBufferWithContentsOfFile(f, buffer);
 947     fclose(f);
 948 
 949     return result;
 950 }
 951 
 952 static bool fetchScriptFromLocalFileSystem(const String&amp; fileName, Vector&lt;char&gt;&amp; buffer)
 953 {
 954     if (!fillBufferWithContentsOfFile(fileName, buffer))
 955         return false;
 956     convertShebangToJSComment(buffer);
 957     return true;
 958 }
 959 
 960 class ShellSourceProvider : public StringSourceProvider {
 961 public:
 962     static Ref&lt;ShellSourceProvider&gt; create(const String&amp; source, const SourceOrigin&amp; sourceOrigin, URL&amp;&amp; url, const TextPosition&amp; startPosition, SourceProviderSourceType sourceType)
 963     {
 964         return adoptRef(*new ShellSourceProvider(source, sourceOrigin, WTFMove(url), startPosition, sourceType));
 965     }
 966 
 967     ~ShellSourceProvider()
 968     {
<a name="27" id="anc27"></a><span class="line-modified"> 969 #if OS(DARWIN)</span>
<span class="line-removed"> 970         if (m_cachedBytecode.size())</span>
<span class="line-removed"> 971             munmap(const_cast&lt;void*&gt;(m_cachedBytecode.data()), m_cachedBytecode.size());</span>
<span class="line-removed"> 972 #endif</span>
 973     }
 974 
<a name="28" id="anc28"></a><span class="line-modified"> 975     const CachedBytecode* cachedBytecode() const override</span>
 976     {
<a name="29" id="anc29"></a><span class="line-modified"> 977         return &amp;m_cachedBytecode;</span>












 978     }
 979 
 980     void cacheBytecode(const BytecodeCacheGenerator&amp; generator) const override
 981     {
<a name="30" id="anc30"></a><span class="line-modified"> 982 #if OS(DARWIN)</span>

















 983         String filename = cachePath();
<a name="31" id="anc31"></a><span class="line-modified"> 984         if (filename.isNull())</span>

 985             return;
<a name="32" id="anc32"></a><span class="line-modified"> 986         int fd = open(filename.utf8().data(), O_CREAT | O_WRONLY | O_TRUNC | O_EXLOCK | O_NONBLOCK, 0666);</span>
<span class="line-modified"> 987         if (fd == -1)</span>





 988             return;
<a name="33" id="anc33"></a><span class="line-modified"> 989         CachedBytecode cachedBytecode = generator();</span>
<span class="line-modified"> 990         write(fd, cachedBytecode.data(), cachedBytecode.size());</span>
<span class="line-modified"> 991         close(fd);</span>
<span class="line-modified"> 992 #endif</span>












 993     }
 994 
 995 private:
 996     String cachePath() const
 997     {
<a name="34" id="anc34"></a><span class="line-modified"> 998         const char* cachePath = Options::diskCachePath();</span>
<span class="line-removed"> 999         if (!cachePath)</span>
1000             return static_cast&lt;const char*&gt;(nullptr);
<a name="35" id="anc35"></a><span class="line-modified">1001         String filename = sourceOrigin().string();</span>
<span class="line-modified">1002         filename.replace(&#39;/&#39;, &#39;_&#39;);</span>
<span class="line-modified">1003         return makeString(cachePath, &#39;/&#39;, source().toString().hash(), &#39;-&#39;, filename, &quot;.bytecode-cache&quot;);</span>
1004     }
1005 
<a name="36" id="anc36"></a><span class="line-modified">1006     void loadBytecode()</span>
1007     {
<a name="37" id="anc37"></a><span class="line-modified">1008 #if OS(DARWIN)</span>


1009         String filename = cachePath();
1010         if (filename.isNull())
1011             return;
1012 
<a name="38" id="anc38"></a><span class="line-modified">1013         int fd = open(filename.utf8().data(), O_RDONLY | O_SHLOCK | O_NONBLOCK);</span>
<span class="line-modified">1014         if (fd == -1)</span>
1015             return;
1016 
1017         auto closeFD = makeScopeExit([&amp;] {
<a name="39" id="anc39"></a><span class="line-modified">1018             close(fd);</span>
1019         });
1020 
<a name="40" id="anc40"></a><span class="line-modified">1021         struct stat sb;</span>
<span class="line-modified">1022         int res = fstat(fd, &amp;sb);</span>
<span class="line-removed">1023         size_t size = static_cast&lt;size_t&gt;(sb.st_size);</span>
<span class="line-removed">1024         if (res || !size)</span>
<span class="line-removed">1025             return;</span>
1026 
<a name="41" id="anc41"></a><span class="line-modified">1027         void* buffer = mmap(nullptr, size, PROT_READ, MAP_PRIVATE, fd, 0);</span>
<span class="line-removed">1028         if (buffer == MAP_FAILED)</span>
1029             return;
<a name="42" id="anc42"></a><span class="line-modified">1030         m_cachedBytecode = CachedBytecode { buffer, size };</span>
<span class="line-modified">1031 #endif</span>
1032     }
1033 
1034     ShellSourceProvider(const String&amp; source, const SourceOrigin&amp; sourceOrigin, URL&amp;&amp; url, const TextPosition&amp; startPosition, SourceProviderSourceType sourceType)
1035         : StringSourceProvider(source, sourceOrigin, WTFMove(url), startPosition, sourceType)
1036     {
<a name="43" id="anc43"></a><span class="line-removed">1037         loadBytecode();</span>
1038     }
1039 
<a name="44" id="anc44"></a><span class="line-modified">1040     CachedBytecode m_cachedBytecode;</span>






1041 };
1042 
1043 static inline SourceCode jscSource(const String&amp; source, const SourceOrigin&amp; sourceOrigin, URL&amp;&amp; url = URL(), const TextPosition&amp; startPosition = TextPosition(), SourceProviderSourceType sourceType = SourceProviderSourceType::Program)
1044 {
1045     return SourceCode(ShellSourceProvider::create(source, sourceOrigin, WTFMove(url), startPosition, sourceType), startPosition.m_line.oneBasedInt(), startPosition.m_column.oneBasedInt());
1046 }
1047 
1048 template&lt;typename Vector&gt;
1049 static inline SourceCode jscSource(const Vector&amp; utf8, const SourceOrigin&amp; sourceOrigin, const String&amp; filename)
1050 {
1051     // FIXME: This should use an absolute file URL https://bugs.webkit.org/show_bug.cgi?id=193077
1052     String str = stringFromUTF(utf8);
1053     return jscSource(str, sourceOrigin, URL({ }, filename));
1054 }
1055 
1056 template&lt;typename Vector&gt;
1057 static bool fetchModuleFromLocalFileSystem(const String&amp; fileName, Vector&amp; buffer)
1058 {
1059     // We assume that fileName is always an absolute path.
1060 #if OS(WINDOWS)
1061     // https://msdn.microsoft.com/en-us/library/windows/desktop/aa365247.aspx#maxpath
1062     // Use long UNC to pass the long path name to the Windows APIs.
<a name="45" id="anc45"></a><span class="line-modified">1063     String longUNCPathName = WTF::makeString(&quot;\\\\?\\&quot;, fileName);</span>
<span class="line-removed">1064     auto pathName = stringToNullTerminatedWChar(longUNCPathName);</span>
1065     struct _stat status { };
1066     if (_wstat(pathName.data(), &amp;status))
1067         return false;
1068     if ((status.st_mode &amp; S_IFMT) != S_IFREG)
1069         return false;
1070 
1071     FILE* f = _wfopen(pathName.data(), L&quot;rb&quot;);
1072 #else
1073     auto pathName = fileName.utf8();
1074     struct stat status { };
1075     if (stat(pathName.data(), &amp;status))
1076         return false;
1077     if ((status.st_mode &amp; S_IFMT) != S_IFREG)
1078         return false;
1079 
1080     FILE* f = fopen(pathName.data(), &quot;r&quot;);
1081 #endif
1082     if (!f) {
1083         fprintf(stderr, &quot;Could not open file: %s\n&quot;, fileName.utf8().data());
1084         return false;
1085     }
1086 
1087     bool result = fillBufferWithContentsOfFile(f, buffer);
1088     if (result)
1089         convertShebangToJSComment(buffer);
1090     fclose(f);
1091 
1092     return result;
1093 }
1094 
1095 JSInternalPromise* GlobalObject::moduleLoaderFetch(JSGlobalObject* globalObject, ExecState* exec, JSModuleLoader*, JSValue key, JSValue, JSValue)
1096 {
1097     VM&amp; vm = globalObject-&gt;vm();
1098     auto throwScope = DECLARE_THROW_SCOPE(vm);
1099     JSInternalPromiseDeferred* deferred = JSInternalPromiseDeferred::tryCreate(exec, globalObject);
1100     RETURN_IF_EXCEPTION(throwScope, nullptr);
1101 
1102     auto catchScope = DECLARE_CATCH_SCOPE(vm);
1103     auto reject = [&amp;] (JSValue rejectionReason) {
1104         catchScope.clearException();
1105         auto result = deferred-&gt;reject(exec, rejectionReason);
1106         catchScope.clearException();
1107         return result;
1108     };
1109 
1110     String moduleKey = key.toWTFString(exec);
1111     if (UNLIKELY(catchScope.exception()))
1112         return reject(catchScope.exception());
1113 
1114     // Here, now we consider moduleKey as the fileName.
1115     Vector&lt;uint8_t&gt; buffer;
1116     if (!fetchModuleFromLocalFileSystem(moduleKey, buffer))
1117         return reject(createError(exec, makeString(&quot;Could not open file &#39;&quot;, moduleKey, &quot;&#39;.&quot;)));
1118 
1119 
1120     URL moduleURL = URL({ }, moduleKey);
1121 #if ENABLE(WEBASSEMBLY)
1122     // FileSystem does not have mime-type header. The JSC shell recognizes WebAssembly&#39;s magic header.
1123     if (buffer.size() &gt;= 4) {
1124         if (buffer[0] == &#39;\0&#39; &amp;&amp; buffer[1] == &#39;a&#39; &amp;&amp; buffer[2] == &#39;s&#39; &amp;&amp; buffer[3] == &#39;m&#39;) {
1125             auto source = SourceCode(WebAssemblySourceProvider::create(WTFMove(buffer), SourceOrigin { moduleKey }, WTFMove(moduleURL)));
1126             catchScope.releaseAssertNoException();
1127             auto sourceCode = JSSourceCode::create(vm, WTFMove(source));
1128             catchScope.releaseAssertNoException();
1129             auto result = deferred-&gt;resolve(exec, sourceCode);
1130             catchScope.clearException();
1131             return result;
1132         }
1133     }
1134 #endif
1135 
1136     auto sourceCode = JSSourceCode::create(vm, jscSource(stringFromUTF(buffer), SourceOrigin { moduleKey }, WTFMove(moduleURL), TextPosition(), SourceProviderSourceType::Module));
1137     catchScope.releaseAssertNoException();
1138     auto result = deferred-&gt;resolve(exec, sourceCode);
1139     catchScope.clearException();
1140     return result;
1141 }
1142 
1143 JSObject* GlobalObject::moduleLoaderCreateImportMetaProperties(JSGlobalObject* globalObject, ExecState* exec, JSModuleLoader*, JSValue key, JSModuleRecord*, JSValue)
1144 {
1145     VM&amp; vm = exec-&gt;vm();
1146     auto scope = DECLARE_THROW_SCOPE(vm);
1147 
1148     JSObject* metaProperties = constructEmptyObject(exec, globalObject-&gt;nullPrototypeObjectStructure());
1149     RETURN_IF_EXCEPTION(scope, nullptr);
1150 
<a name="46" id="anc46"></a><span class="line-modified">1151     metaProperties-&gt;putDirect(vm, Identifier::fromString(&amp;vm, &quot;filename&quot;), key);</span>
1152     RETURN_IF_EXCEPTION(scope, nullptr);
1153 
1154     return metaProperties;
1155 }
1156 
1157 static CString cStringFromViewWithString(ExecState* exec, ThrowScope&amp; scope, StringViewWithUnderlyingString&amp; viewWithString)
1158 {
1159     Expected&lt;CString, UTF8ConversionError&gt; expectedString = viewWithString.view.tryGetUtf8();
1160     if (expectedString)
1161         return expectedString.value();
1162     switch (expectedString.error()) {
1163     case UTF8ConversionError::OutOfMemory:
1164         throwOutOfMemoryError(exec, scope);
1165         break;
1166     case UTF8ConversionError::IllegalSource:
1167         scope.throwException(exec, createError(exec, &quot;Illegal source encountered during UTF8 conversion&quot;));
1168         break;
1169     case UTF8ConversionError::SourceExhausted:
1170         scope.throwException(exec, createError(exec, &quot;Source exhausted during UTF8 conversion&quot;));
1171         break;
1172     default:
1173         RELEASE_ASSERT_NOT_REACHED();
1174     }
1175     return { };
1176 }
1177 
1178 static EncodedJSValue printInternal(ExecState* exec, FILE* out)
1179 {
1180     VM&amp; vm = exec-&gt;vm();
1181     auto scope = DECLARE_THROW_SCOPE(vm);
1182 
1183     if (asyncTestExpectedPasses) {
1184         JSValue value = exec-&gt;argument(0);
1185         if (value.isString() &amp;&amp; WTF::equal(asString(value)-&gt;value(exec).impl(), &quot;Test262:AsyncTestComplete&quot;)) {
1186             asyncTestPasses++;
1187             return JSValue::encode(jsUndefined());
1188         }
1189     }
1190 
1191     for (unsigned i = 0; i &lt; exec-&gt;argumentCount(); ++i) {
1192         if (i)
1193             if (EOF == fputc(&#39; &#39;, out))
1194                 goto fail;
1195 
1196         auto viewWithString = exec-&gt;uncheckedArgument(i).toString(exec)-&gt;viewWithUnderlyingString(exec);
1197         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1198         auto string = cStringFromViewWithString(exec, scope, viewWithString);
1199         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1200         if (fprintf(out, &quot;%s&quot;, string.data()) &lt; 0)
1201             goto fail;
1202     }
1203 
1204     fputc(&#39;\n&#39;, out);
1205 fail:
1206     fflush(out);
1207     return JSValue::encode(jsUndefined());
1208 }
1209 
1210 EncodedJSValue JSC_HOST_CALL functionPrintStdOut(ExecState* exec) { return printInternal(exec, stdout); }
1211 EncodedJSValue JSC_HOST_CALL functionPrintStdErr(ExecState* exec) { return printInternal(exec, stderr); }
1212 
1213 EncodedJSValue JSC_HOST_CALL functionDebug(ExecState* exec)
1214 {
1215     VM&amp; vm = exec-&gt;vm();
1216     auto scope = DECLARE_THROW_SCOPE(vm);
1217     auto viewWithString = exec-&gt;argument(0).toString(exec)-&gt;viewWithUnderlyingString(exec);
1218     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1219     auto string = cStringFromViewWithString(exec, scope, viewWithString);
1220     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1221     fprintf(stderr, &quot;--&gt; %s\n&quot;, string.data());
1222     return JSValue::encode(jsUndefined());
1223 }
1224 
1225 EncodedJSValue JSC_HOST_CALL functionDescribe(ExecState* exec)
1226 {
<a name="47" id="anc47"></a>
1227     if (exec-&gt;argumentCount() &lt; 1)
1228         return JSValue::encode(jsUndefined());
<a name="48" id="anc48"></a><span class="line-modified">1229     return JSValue::encode(jsString(exec, toString(exec-&gt;argument(0))));</span>
1230 }
1231 
1232 EncodedJSValue JSC_HOST_CALL functionDescribeArray(ExecState* exec)
1233 {
1234     if (exec-&gt;argumentCount() &lt; 1)
1235         return JSValue::encode(jsUndefined());
1236     VM&amp; vm = exec-&gt;vm();
1237     JSObject* object = jsDynamicCast&lt;JSObject*&gt;(vm, exec-&gt;argument(0));
1238     if (!object)
<a name="49" id="anc49"></a><span class="line-modified">1239         return JSValue::encode(jsNontrivialString(exec, &quot;&lt;not object&gt;&quot;_s));</span>
<span class="line-modified">1240     return JSValue::encode(jsNontrivialString(exec, toString(&quot;&lt;Butterfly: &quot;, RawPointer(object-&gt;butterfly()), &quot;; public length: &quot;, object-&gt;getArrayLength(), &quot;; vector length: &quot;, object-&gt;getVectorLength(), &quot;&gt;&quot;)));</span>
1241 }
1242 
1243 EncodedJSValue JSC_HOST_CALL functionSleepSeconds(ExecState* exec)
1244 {
1245     VM&amp; vm = exec-&gt;vm();
1246     auto scope = DECLARE_THROW_SCOPE(vm);
1247 
1248     if (exec-&gt;argumentCount() &gt;= 1) {
1249         Seconds seconds = Seconds(exec-&gt;argument(0).toNumber(exec));
1250         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1251         sleep(seconds);
1252     }
1253 
1254     return JSValue::encode(jsUndefined());
1255 }
1256 
1257 class FunctionJSCStackFunctor {
1258 public:
1259     FunctionJSCStackFunctor(StringBuilder&amp; trace)
1260         : m_trace(trace)
1261     {
1262     }
1263 
1264     StackVisitor::Status operator()(StackVisitor&amp; visitor) const
1265     {
1266         m_trace.append(makeString(&quot;    &quot;, visitor-&gt;index(), &quot;   &quot;, visitor-&gt;toString(), &#39;\n&#39;));
1267         return StackVisitor::Continue;
1268     }
1269 
1270 private:
1271     StringBuilder&amp; m_trace;
1272 };
1273 
1274 EncodedJSValue JSC_HOST_CALL functionJSCStack(ExecState* exec)
1275 {
1276     StringBuilder trace;
1277     trace.appendLiteral(&quot;--&gt; Stack trace:\n&quot;);
1278 
1279     FunctionJSCStackFunctor functor(trace);
1280     exec-&gt;iterate(functor);
1281     fprintf(stderr, &quot;%s&quot;, trace.toString().utf8().data());
1282     return JSValue::encode(jsUndefined());
1283 }
1284 
1285 EncodedJSValue JSC_HOST_CALL functionGCAndSweep(ExecState* exec)
1286 {
1287     VM&amp; vm = exec-&gt;vm();
1288     JSLockHolder lock(vm);
1289     vm.heap.collectNow(Sync, CollectionScope::Full);
1290     return JSValue::encode(jsNumber(vm.heap.sizeAfterLastFullCollection()));
1291 }
1292 
1293 EncodedJSValue JSC_HOST_CALL functionFullGC(ExecState* exec)
1294 {
1295     VM&amp; vm = exec-&gt;vm();
1296     JSLockHolder lock(vm);
1297     vm.heap.collectSync(CollectionScope::Full);
1298     return JSValue::encode(jsNumber(vm.heap.sizeAfterLastFullCollection()));
1299 }
1300 
1301 EncodedJSValue JSC_HOST_CALL functionEdenGC(ExecState* exec)
1302 {
1303     VM&amp; vm = exec-&gt;vm();
1304     JSLockHolder lock(vm);
1305     vm.heap.collectSync(CollectionScope::Eden);
1306     return JSValue::encode(jsNumber(vm.heap.sizeAfterLastEdenCollection()));
1307 }
1308 
1309 EncodedJSValue JSC_HOST_CALL functionForceGCSlowPaths(ExecState*)
1310 {
1311     // It&#39;s best for this to be the first thing called in the
1312     // JS program so the option is set to true before we JIT.
1313     Options::forceGCSlowPaths() = true;
1314     return JSValue::encode(jsUndefined());
1315 }
1316 
1317 EncodedJSValue JSC_HOST_CALL functionHeapSize(ExecState* exec)
1318 {
1319     VM&amp; vm = exec-&gt;vm();
1320     JSLockHolder lock(vm);
1321     return JSValue::encode(jsNumber(vm.heap.size()));
1322 }
1323 
1324 class JSCMemoryFootprint : public JSDestructibleObject {
1325     using Base = JSDestructibleObject;
1326 public:
1327     JSCMemoryFootprint(VM&amp; vm, Structure* structure)
1328         : Base(vm, structure)
1329     { }
1330 
1331     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
1332     {
1333         return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
1334     }
1335 
1336     static JSCMemoryFootprint* create(VM&amp; vm, JSGlobalObject* globalObject)
1337     {
1338         Structure* structure = createStructure(vm, globalObject, jsNull());
<a name="50" id="anc50"></a><span class="line-modified">1339         JSCMemoryFootprint* footprint = new (NotNull, allocateCell&lt;JSCMemoryFootprint&gt;(vm.heap, sizeof(JSCMemoryFootprint))) JSCMemoryFootprint(vm, structure);</span>
1340         footprint-&gt;finishCreation(vm);
1341         return footprint;
1342     }
1343 
1344     void finishCreation(VM&amp; vm)
1345     {
1346         Base::finishCreation(vm);
1347 
1348         auto addProperty = [&amp;] (VM&amp; vm, const char* name, JSValue value) {
1349             JSCMemoryFootprint::addProperty(vm, name, value);
1350         };
1351 
1352         MemoryFootprint footprint = MemoryFootprint::now();
1353 
1354         addProperty(vm, &quot;current&quot;, jsNumber(footprint.current));
1355         addProperty(vm, &quot;peak&quot;, jsNumber(footprint.peak));
1356     }
1357 
1358     DECLARE_INFO;
1359 
1360 private:
1361     void addProperty(VM&amp; vm, const char* name, JSValue value)
1362     {
<a name="51" id="anc51"></a><span class="line-modified">1363         Identifier identifier = Identifier::fromString(&amp;vm, name);</span>
1364         putDirect(vm, identifier, value);
1365     }
1366 };
1367 
1368 const ClassInfo JSCMemoryFootprint::s_info = { &quot;MemoryFootprint&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSCMemoryFootprint) };
1369 
1370 EncodedJSValue JSC_HOST_CALL functionCreateMemoryFootprint(ExecState* exec)
1371 {
1372     VM&amp; vm = exec-&gt;vm();
1373     JSLockHolder lock(vm);
1374     return JSValue::encode(JSCMemoryFootprint::create(vm, exec-&gt;lexicalGlobalObject()));
1375 }
1376 
1377 EncodedJSValue JSC_HOST_CALL functionResetMemoryPeak(ExecState*)
1378 {
1379     MemoryFootprint::resetPeak();
1380     return JSValue::encode(jsUndefined());
1381 }
1382 
1383 // This function is not generally very helpful in 64-bit code as the tag and payload
1384 // share a register. But in 32-bit JITed code the tag may not be checked if an
1385 // optimization removes type checking requirements, such as in ===.
1386 EncodedJSValue JSC_HOST_CALL functionAddressOf(ExecState* exec)
1387 {
1388     JSValue value = exec-&gt;argument(0);
1389     if (!value.isCell())
1390         return JSValue::encode(jsUndefined());
1391     // Need to cast to uint64_t so bitwise_cast will play along.
1392     uint64_t asNumber = reinterpret_cast&lt;uint64_t&gt;(value.asCell());
1393     EncodedJSValue returnValue = JSValue::encode(jsNumber(bitwise_cast&lt;double&gt;(asNumber)));
1394     return returnValue;
1395 }
1396 
1397 EncodedJSValue JSC_HOST_CALL functionVersion(ExecState*)
1398 {
1399     // We need this function for compatibility with the Mozilla JS tests but for now
1400     // we don&#39;t actually do any version-specific handling
1401     return JSValue::encode(jsUndefined());
1402 }
1403 
1404 EncodedJSValue JSC_HOST_CALL functionRun(ExecState* exec)
1405 {
1406     VM&amp; vm = exec-&gt;vm();
1407     auto scope = DECLARE_THROW_SCOPE(vm);
1408 
1409     String fileName = exec-&gt;argument(0).toWTFString(exec);
1410     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1411     Vector&lt;char&gt; script;
1412     if (!fetchScriptFromLocalFileSystem(fileName, script))
1413         return JSValue::encode(throwException(exec, scope, createError(exec, &quot;Could not open file.&quot;_s)));
1414 
1415     GlobalObject* globalObject = GlobalObject::create(vm, GlobalObject::createStructure(vm, jsNull()), Vector&lt;String&gt;());
1416 
1417     JSArray* array = constructEmptyArray(globalObject-&gt;globalExec(), 0);
1418     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1419     for (unsigned i = 1; i &lt; exec-&gt;argumentCount(); ++i) {
1420         array-&gt;putDirectIndex(globalObject-&gt;globalExec(), i - 1, exec-&gt;uncheckedArgument(i));
1421         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1422     }
<a name="52" id="anc52"></a><span class="line-modified">1423     globalObject-&gt;putDirect(</span>
<span class="line-removed">1424         vm, Identifier::fromString(globalObject-&gt;globalExec(), &quot;arguments&quot;), array);</span>
1425 
1426     NakedPtr&lt;Exception&gt; exception;
1427     StopWatch stopWatch;
1428     stopWatch.start();
1429     evaluate(globalObject-&gt;globalExec(), jscSource(script, SourceOrigin { absolutePath(fileName) }, fileName), JSValue(), exception);
1430     stopWatch.stop();
1431 
1432     if (exception) {
1433         throwException(globalObject-&gt;globalExec(), scope, exception);
1434         return JSValue::encode(jsUndefined());
1435     }
1436 
1437     return JSValue::encode(jsNumber(stopWatch.getElapsedMS()));
1438 }
1439 
1440 EncodedJSValue JSC_HOST_CALL functionRunString(ExecState* exec)
1441 {
1442     VM&amp; vm = exec-&gt;vm();
1443     auto scope = DECLARE_THROW_SCOPE(vm);
1444 
1445     String source = exec-&gt;argument(0).toWTFString(exec);
1446     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1447 
1448     GlobalObject* globalObject = GlobalObject::create(vm, GlobalObject::createStructure(vm, jsNull()), Vector&lt;String&gt;());
1449 
1450     JSArray* array = constructEmptyArray(globalObject-&gt;globalExec(), 0);
1451     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1452     for (unsigned i = 1; i &lt; exec-&gt;argumentCount(); ++i) {
1453         array-&gt;putDirectIndex(globalObject-&gt;globalExec(), i - 1, exec-&gt;uncheckedArgument(i));
1454         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1455     }
<a name="53" id="anc53"></a><span class="line-modified">1456     globalObject-&gt;putDirect(</span>
<span class="line-removed">1457         vm, Identifier::fromString(globalObject-&gt;globalExec(), &quot;arguments&quot;), array);</span>
1458 
1459     NakedPtr&lt;Exception&gt; exception;
<a name="54" id="anc54"></a><span class="line-modified">1460     evaluate(globalObject-&gt;globalExec(), makeSource(source, exec-&gt;callerSourceOrigin()), JSValue(), exception);</span>
1461 
1462     if (exception) {
1463         scope.throwException(globalObject-&gt;globalExec(), exception);
1464         return JSValue::encode(jsUndefined());
1465     }
1466 
1467     return JSValue::encode(globalObject);
1468 }
1469 
1470 EncodedJSValue JSC_HOST_CALL functionLoad(ExecState* exec)
1471 {
1472     VM&amp; vm = exec-&gt;vm();
1473     auto scope = DECLARE_THROW_SCOPE(vm);
1474 
1475     String fileName = exec-&gt;argument(0).toWTFString(exec);
1476     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1477     Vector&lt;char&gt; script;
1478     if (!fetchScriptFromLocalFileSystem(fileName, script))
1479         return JSValue::encode(throwException(exec, scope, createError(exec, &quot;Could not open file.&quot;_s)));
1480 
1481     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();
1482 
1483     NakedPtr&lt;Exception&gt; evaluationException;
1484     JSValue result = evaluate(globalObject-&gt;globalExec(), jscSource(script, SourceOrigin { absolutePath(fileName) }, fileName), JSValue(), evaluationException);
1485     if (evaluationException)
1486         throwException(exec, scope, evaluationException);
1487     return JSValue::encode(result);
1488 }
1489 
1490 EncodedJSValue JSC_HOST_CALL functionLoadString(ExecState* exec)
1491 {
1492     VM&amp; vm = exec-&gt;vm();
1493     auto scope = DECLARE_THROW_SCOPE(vm);
1494 
1495     String sourceCode = exec-&gt;argument(0).toWTFString(exec);
1496     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1497     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();
1498 
1499     NakedPtr&lt;Exception&gt; evaluationException;
<a name="55" id="anc55"></a><span class="line-modified">1500     JSValue result = evaluate(globalObject-&gt;globalExec(), makeSource(sourceCode, exec-&gt;callerSourceOrigin()), JSValue(), evaluationException);</span>
1501     if (evaluationException)
1502         throwException(exec, scope, evaluationException);
1503     return JSValue::encode(result);
1504 }
1505 
1506 EncodedJSValue JSC_HOST_CALL functionReadFile(ExecState* exec)
1507 {
1508     VM&amp; vm = exec-&gt;vm();
1509     auto scope = DECLARE_THROW_SCOPE(vm);
1510 
1511     String fileName = exec-&gt;argument(0).toWTFString(exec);
1512     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1513 
1514     bool isBinary = false;
1515     if (exec-&gt;argumentCount() &gt; 1) {
1516         String type = exec-&gt;argument(1).toWTFString(exec);
1517         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1518         if (type != &quot;binary&quot;)
1519             return throwVMError(exec, scope, &quot;Expected &#39;binary&#39; as second argument.&quot;);
1520         isBinary = true;
1521     }
1522 
1523     RefPtr&lt;Uint8Array&gt; content = fillBufferWithContentsOfFile(fileName);
1524     if (!content)
1525         return throwVMError(exec, scope, &quot;Could not open file.&quot;);
1526 
1527     if (!isBinary)
<a name="56" id="anc56"></a><span class="line-modified">1528         return JSValue::encode(jsString(exec, String::fromUTF8WithLatin1Fallback(content-&gt;data(), content-&gt;length())));</span>
1529 
1530     Structure* structure = exec-&gt;lexicalGlobalObject()-&gt;typedArrayStructure(TypeUint8);
1531     JSObject* result = JSUint8Array::create(vm, structure, WTFMove(content));
1532     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1533 
1534     return JSValue::encode(result);
1535 }
1536 
1537 EncodedJSValue JSC_HOST_CALL functionCheckSyntax(ExecState* exec)
1538 {
1539     VM&amp; vm = exec-&gt;vm();
1540     auto scope = DECLARE_THROW_SCOPE(vm);
1541 
1542     String fileName = exec-&gt;argument(0).toWTFString(exec);
1543     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1544     Vector&lt;char&gt; script;
1545     if (!fetchScriptFromLocalFileSystem(fileName, script))
1546         return JSValue::encode(throwException(exec, scope, createError(exec, &quot;Could not open file.&quot;_s)));
1547 
1548     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();
1549 
1550     StopWatch stopWatch;
1551     stopWatch.start();
1552 
1553     JSValue syntaxException;
1554     bool validSyntax = checkSyntax(globalObject-&gt;globalExec(), jscSource(script, SourceOrigin { absolutePath(fileName) }, fileName), &amp;syntaxException);
1555     stopWatch.stop();
1556 
1557     if (!validSyntax)
1558         throwException(exec, scope, syntaxException);
1559     return JSValue::encode(jsNumber(stopWatch.getElapsedMS()));
1560 }
1561 
1562 #if ENABLE(SAMPLING_FLAGS)
1563 EncodedJSValue JSC_HOST_CALL functionSetSamplingFlags(ExecState* exec)
1564 {
1565     for (unsigned i = 0; i &lt; exec-&gt;argumentCount(); ++i) {
1566         unsigned flag = static_cast&lt;unsigned&gt;(exec-&gt;uncheckedArgument(i).toNumber(exec));
1567         if ((flag &gt;= 1) &amp;&amp; (flag &lt;= 32))
1568             SamplingFlags::setFlag(flag);
1569     }
1570     return JSValue::encode(jsNull());
1571 }
1572 
1573 EncodedJSValue JSC_HOST_CALL functionClearSamplingFlags(ExecState* exec)
1574 {
1575     for (unsigned i = 0; i &lt; exec-&gt;argumentCount(); ++i) {
1576         unsigned flag = static_cast&lt;unsigned&gt;(exec-&gt;uncheckedArgument(i).toNumber(exec));
1577         if ((flag &gt;= 1) &amp;&amp; (flag &lt;= 32))
1578             SamplingFlags::clearFlag(flag);
1579     }
1580     return JSValue::encode(jsNull());
1581 }
1582 #endif
1583 
1584 EncodedJSValue JSC_HOST_CALL functionGetRandomSeed(ExecState* exec)
1585 {
1586     return JSValue::encode(jsNumber(exec-&gt;lexicalGlobalObject()-&gt;weakRandom().seed()));
1587 }
1588 
1589 EncodedJSValue JSC_HOST_CALL functionSetRandomSeed(ExecState* exec)
1590 {
1591     VM&amp; vm = exec-&gt;vm();
1592     auto scope = DECLARE_THROW_SCOPE(vm);
1593 
1594     unsigned seed = exec-&gt;argument(0).toUInt32(exec);
1595     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1596     exec-&gt;lexicalGlobalObject()-&gt;weakRandom().setSeed(seed);
1597     return JSValue::encode(jsUndefined());
1598 }
1599 
1600 EncodedJSValue JSC_HOST_CALL functionIsRope(ExecState* exec)
1601 {
1602     JSValue argument = exec-&gt;argument(0);
1603     if (!argument.isString())
1604         return JSValue::encode(jsBoolean(false));
1605     const StringImpl* impl = asString(argument)-&gt;tryGetValueImpl();
1606     return JSValue::encode(jsBoolean(!impl));
1607 }
1608 
1609 EncodedJSValue JSC_HOST_CALL functionCallerSourceOrigin(ExecState* state)
1610 {
1611     SourceOrigin sourceOrigin = state-&gt;callerSourceOrigin();
1612     if (sourceOrigin.isNull())
1613         return JSValue::encode(jsNull());
<a name="57" id="anc57"></a><span class="line-modified">1614     return JSValue::encode(jsString(state, sourceOrigin.string()));</span>
1615 }
1616 
1617 EncodedJSValue JSC_HOST_CALL functionReadline(ExecState* exec)
1618 {
1619     Vector&lt;char, 256&gt; line;
1620     int c;
1621     while ((c = getchar()) != EOF) {
1622         // FIXME: Should we also break on \r?
1623         if (c == &#39;\n&#39;)
1624             break;
1625         line.append(c);
1626     }
1627     line.append(&#39;\0&#39;);
<a name="58" id="anc58"></a><span class="line-modified">1628     return JSValue::encode(jsString(exec, line.data()));</span>
1629 }
1630 
1631 EncodedJSValue JSC_HOST_CALL functionPreciseTime(ExecState*)
1632 {
1633     return JSValue::encode(jsNumber(WallTime::now().secondsSinceEpoch().value()));
1634 }
1635 
1636 EncodedJSValue JSC_HOST_CALL functionNeverInlineFunction(ExecState* exec)
1637 {
1638     return JSValue::encode(setNeverInline(exec));
1639 }
1640 
1641 EncodedJSValue JSC_HOST_CALL functionNoDFG(ExecState* exec)
1642 {
1643     return JSValue::encode(setNeverOptimize(exec));
1644 }
1645 
1646 EncodedJSValue JSC_HOST_CALL functionNoFTL(ExecState* exec)
1647 {
1648     if (exec-&gt;argumentCount()) {
1649         FunctionExecutable* executable = getExecutableForFunction(exec-&gt;argument(0));
1650         if (executable)
1651             executable-&gt;setNeverFTLOptimize(true);
1652     }
1653     return JSValue::encode(jsUndefined());
1654 }
1655 
1656 EncodedJSValue JSC_HOST_CALL functionNoOSRExitFuzzing(ExecState* exec)
1657 {
1658     return JSValue::encode(setCannotUseOSRExitFuzzing(exec));
1659 }
1660 
1661 EncodedJSValue JSC_HOST_CALL functionOptimizeNextInvocation(ExecState* exec)
1662 {
1663     return JSValue::encode(optimizeNextInvocation(exec));
1664 }
1665 
1666 EncodedJSValue JSC_HOST_CALL functionNumberOfDFGCompiles(ExecState* exec)
1667 {
1668     return JSValue::encode(numberOfDFGCompiles(exec));
1669 }
1670 
1671 Message::Message(ArrayBufferContents&amp;&amp; contents, int32_t index)
1672     : m_contents(WTFMove(contents))
1673     , m_index(index)
1674 {
1675 }
1676 
1677 Message::~Message()
1678 {
1679 }
1680 
1681 Worker::Worker(Workers&amp; workers)
1682     : m_workers(workers)
1683 {
1684     auto locker = holdLock(m_workers.m_lock);
1685     m_workers.m_workers.append(this);
1686 
1687     *currentWorker() = this;
1688 }
1689 
1690 Worker::~Worker()
1691 {
1692     auto locker = holdLock(m_workers.m_lock);
1693     RELEASE_ASSERT(isOnList());
1694     remove();
1695 }
1696 
1697 void Worker::enqueue(const AbstractLocker&amp;, RefPtr&lt;Message&gt; message)
1698 {
1699     m_messages.append(message);
1700 }
1701 
1702 RefPtr&lt;Message&gt; Worker::dequeue()
1703 {
1704     auto locker = holdLock(m_workers.m_lock);
1705     while (m_messages.isEmpty())
1706         m_workers.m_condition.wait(m_workers.m_lock);
1707     return m_messages.takeFirst();
1708 }
1709 
1710 Worker&amp; Worker::current()
1711 {
1712     return **currentWorker();
1713 }
1714 
1715 ThreadSpecific&lt;Worker*&gt;&amp; Worker::currentWorker()
1716 {
1717     static ThreadSpecific&lt;Worker*&gt;* result;
1718     static std::once_flag flag;
1719     std::call_once(
1720         flag,
1721         [] () {
1722             result = new ThreadSpecific&lt;Worker*&gt;();
1723         });
1724     return *result;
1725 }
1726 
1727 Workers::Workers()
1728 {
1729 }
1730 
1731 Workers::~Workers()
1732 {
1733     UNREACHABLE_FOR_PLATFORM();
1734 }
1735 
1736 template&lt;typename Func&gt;
1737 void Workers::broadcast(const Func&amp; func)
1738 {
1739     auto locker = holdLock(m_lock);
1740     for (Worker* worker = m_workers.begin(); worker != m_workers.end(); worker = worker-&gt;next()) {
1741         if (worker != &amp;Worker::current())
1742             func(locker, *worker);
1743     }
1744     m_condition.notifyAll();
1745 }
1746 
1747 void Workers::report(const String&amp; string)
1748 {
1749     auto locker = holdLock(m_lock);
1750     m_reports.append(string.isolatedCopy());
1751     m_condition.notifyAll();
1752 }
1753 
1754 String Workers::tryGetReport()
1755 {
1756     auto locker = holdLock(m_lock);
1757     if (m_reports.isEmpty())
1758         return String();
1759     return m_reports.takeFirst();
1760 }
1761 
1762 String Workers::getReport()
1763 {
1764     auto locker = holdLock(m_lock);
1765     while (m_reports.isEmpty())
1766         m_condition.wait(m_lock);
1767     return m_reports.takeFirst();
1768 }
1769 
1770 Workers&amp; Workers::singleton()
1771 {
1772     static Workers* result;
1773     static std::once_flag flag;
1774     std::call_once(
1775         flag,
1776         [] {
1777             result = new Workers();
1778         });
1779     return *result;
1780 }
1781 
1782 EncodedJSValue JSC_HOST_CALL functionDollarCreateRealm(ExecState* exec)
1783 {
1784     VM&amp; vm = exec-&gt;vm();
1785     GlobalObject* result = GlobalObject::create(vm, GlobalObject::createStructure(vm, jsNull()), Vector&lt;String&gt;());
<a name="59" id="anc59"></a><span class="line-modified">1786     return JSValue::encode(result-&gt;getDirect(vm, Identifier::fromString(exec, &quot;$&quot;)));</span>
1787 }
1788 
1789 EncodedJSValue JSC_HOST_CALL functionDollarDetachArrayBuffer(ExecState* exec)
1790 {
1791     return functionTransferArrayBuffer(exec);
1792 }
1793 
1794 EncodedJSValue JSC_HOST_CALL functionDollarEvalScript(ExecState* exec)
1795 {
1796     VM&amp; vm = exec-&gt;vm();
1797     auto scope = DECLARE_THROW_SCOPE(vm);
1798 
1799     String sourceCode = exec-&gt;argument(0).toWTFString(exec);
1800     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1801 
1802     GlobalObject* globalObject = jsDynamicCast&lt;GlobalObject*&gt;(vm,
<a name="60" id="anc60"></a><span class="line-modified">1803         exec-&gt;thisValue().get(exec, Identifier::fromString(exec, &quot;global&quot;)));</span>
1804     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1805     if (!globalObject)
1806         return JSValue::encode(throwException(exec, scope, createError(exec, &quot;Expected global to point to a global object&quot;_s)));
1807 
1808     NakedPtr&lt;Exception&gt; evaluationException;
1809     JSValue result = evaluate(globalObject-&gt;globalExec(), jscSource(sourceCode, exec-&gt;callerSourceOrigin()), JSValue(), evaluationException);
1810     if (evaluationException)
1811         throwException(exec, scope, evaluationException);
1812     return JSValue::encode(result);
1813 }
1814 
1815 EncodedJSValue JSC_HOST_CALL functionDollarAgentStart(ExecState* exec)
1816 {
1817     VM&amp; vm = exec-&gt;vm();
1818     auto scope = DECLARE_THROW_SCOPE(vm);
1819 
1820     String sourceCode = exec-&gt;argument(0).toWTFString(exec).isolatedCopy();
1821     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1822 
1823     Lock didStartLock;
1824     Condition didStartCondition;
1825     bool didStart = false;
1826 
1827     Thread::create(
1828         &quot;JSC Agent&quot;,
1829         [sourceCode, &amp;didStartLock, &amp;didStartCondition, &amp;didStart] () {
1830             CommandLine commandLine(0, nullptr);
1831             commandLine.m_interactive = false;
1832             runJSC(
1833                 commandLine, true,
1834                 [&amp;] (VM&amp;, GlobalObject* globalObject, bool&amp; success) {
1835                     // Notify the thread that started us that we have registered a worker.
1836                     {
1837                         auto locker = holdLock(didStartLock);
1838                         didStart = true;
1839                         didStartCondition.notifyOne();
1840                     }
1841 
1842                     NakedPtr&lt;Exception&gt; evaluationException;
1843                     JSValue result;
<a name="61" id="anc61"></a><span class="line-modified">1844                     result = evaluate(globalObject-&gt;globalExec(), makeSource(sourceCode, SourceOrigin(&quot;worker&quot;_s)), JSValue(), evaluationException);</span>
1845                     if (evaluationException)
1846                         result = evaluationException-&gt;value();
1847                     checkException(globalObject-&gt;globalExec(), globalObject, true, evaluationException, result, commandLine, success);
1848                     if (!success)
1849                         exit(1);
1850                 });
1851         })-&gt;detach();
1852 
1853     {
1854         auto locker = holdLock(didStartLock);
1855         while (!didStart)
1856             didStartCondition.wait(didStartLock);
1857     }
1858 
1859     return JSValue::encode(jsUndefined());
1860 }
1861 
1862 EncodedJSValue JSC_HOST_CALL functionDollarAgentReceiveBroadcast(ExecState* exec)
1863 {
1864     VM&amp; vm = exec-&gt;vm();
1865     auto scope = DECLARE_THROW_SCOPE(vm);
1866 
1867     JSValue callback = exec-&gt;argument(0);
1868     CallData callData;
1869     CallType callType = getCallData(vm, callback, callData);
1870     if (callType == CallType::None)
1871         return JSValue::encode(throwException(exec, scope, createError(exec, &quot;Expected callback&quot;_s)));
1872 
1873     RefPtr&lt;Message&gt; message;
1874     {
1875         ReleaseHeapAccessScope releaseAccess(vm.heap);
1876         message = Worker::current().dequeue();
1877     }
1878 
1879     auto nativeBuffer = ArrayBuffer::create(message-&gt;releaseContents());
1880     ArrayBufferSharingMode sharingMode = nativeBuffer-&gt;sharingMode();
1881     JSArrayBuffer* jsBuffer = JSArrayBuffer::create(vm, exec-&gt;lexicalGlobalObject()-&gt;arrayBufferStructure(sharingMode), WTFMove(nativeBuffer));
1882 
1883     MarkedArgumentBuffer args;
1884     args.append(jsBuffer);
1885     args.append(jsNumber(message-&gt;index()));
1886     if (UNLIKELY(args.hasOverflowed()))
1887         return JSValue::encode(throwOutOfMemoryError(exec, scope));
1888     RELEASE_AND_RETURN(scope, JSValue::encode(call(exec, callback, callType, callData, jsNull(), args)));
1889 }
1890 
1891 EncodedJSValue JSC_HOST_CALL functionDollarAgentReport(ExecState* exec)
1892 {
1893     VM&amp; vm = exec-&gt;vm();
1894     auto scope = DECLARE_THROW_SCOPE(vm);
1895 
1896     String report = exec-&gt;argument(0).toWTFString(exec);
1897     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1898 
1899     Workers::singleton().report(report);
1900 
1901     return JSValue::encode(jsUndefined());
1902 }
1903 
1904 EncodedJSValue JSC_HOST_CALL functionDollarAgentSleep(ExecState* exec)
1905 {
1906     VM&amp; vm = exec-&gt;vm();
1907     auto scope = DECLARE_THROW_SCOPE(vm);
1908 
1909     if (exec-&gt;argumentCount() &gt;= 1) {
1910         Seconds seconds = Seconds::fromMilliseconds(exec-&gt;argument(0).toNumber(exec));
1911         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1912         sleep(seconds);
1913     }
1914     return JSValue::encode(jsUndefined());
1915 }
1916 
1917 EncodedJSValue JSC_HOST_CALL functionDollarAgentBroadcast(ExecState* exec)
1918 {
1919     VM&amp; vm = exec-&gt;vm();
1920     auto scope = DECLARE_THROW_SCOPE(vm);
1921 
1922     JSArrayBuffer* jsBuffer = jsDynamicCast&lt;JSArrayBuffer*&gt;(vm, exec-&gt;argument(0));
1923     if (!jsBuffer || !jsBuffer-&gt;isShared())
1924         return JSValue::encode(throwException(exec, scope, createError(exec, &quot;Expected SharedArrayBuffer&quot;_s)));
1925 
1926     int32_t index = exec-&gt;argument(1).toInt32(exec);
1927     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1928 
1929     Workers::singleton().broadcast(
1930         [&amp;] (const AbstractLocker&amp; locker, Worker&amp; worker) {
1931             ArrayBuffer* nativeBuffer = jsBuffer-&gt;impl();
1932             ArrayBufferContents contents;
1933             nativeBuffer-&gt;transferTo(vm, contents); // &quot;transferTo&quot; means &quot;share&quot; if the buffer is shared.
1934             RefPtr&lt;Message&gt; message = adoptRef(new Message(WTFMove(contents), index));
1935             worker.enqueue(locker, message);
1936         });
1937 
1938     return JSValue::encode(jsUndefined());
1939 }
1940 
1941 EncodedJSValue JSC_HOST_CALL functionDollarAgentGetReport(ExecState* exec)
1942 {
1943     VM&amp; vm = exec-&gt;vm();
1944 
1945     String string = Workers::singleton().tryGetReport();
1946     if (!string)
1947         return JSValue::encode(jsNull());
1948 
<a name="62" id="anc62"></a><span class="line-modified">1949     return JSValue::encode(jsString(&amp;vm, string));</span>
1950 }
1951 
1952 EncodedJSValue JSC_HOST_CALL functionDollarAgentLeaving(ExecState*)
1953 {
1954     return JSValue::encode(jsUndefined());
1955 }
1956 
1957 EncodedJSValue JSC_HOST_CALL functionDollarAgentMonotonicNow(ExecState*)
1958 {
1959     return JSValue::encode(jsNumber(MonotonicTime::now().secondsSinceEpoch().milliseconds()));
1960 }
1961 
1962 EncodedJSValue JSC_HOST_CALL functionWaitForReport(ExecState* exec)
1963 {
1964     VM&amp; vm = exec-&gt;vm();
1965 
1966     String string;
1967     {
1968         ReleaseHeapAccessScope releaseAccess(vm.heap);
1969         string = Workers::singleton().getReport();
1970     }
1971     if (!string)
1972         return JSValue::encode(jsNull());
1973 
<a name="63" id="anc63"></a><span class="line-modified">1974     return JSValue::encode(jsString(&amp;vm, string));</span>
1975 }
1976 
1977 EncodedJSValue JSC_HOST_CALL functionHeapCapacity(ExecState* exec)
1978 {
1979     VM&amp; vm = exec-&gt;vm();
1980     return JSValue::encode(jsNumber(vm.heap.capacity()));
1981 }
1982 
1983 EncodedJSValue JSC_HOST_CALL functionFlashHeapAccess(ExecState* exec)
1984 {
1985     VM&amp; vm = exec-&gt;vm();
1986     auto scope = DECLARE_THROW_SCOPE(vm);
1987 
1988     double sleepTimeMs = 0;
1989     if (exec-&gt;argumentCount() &gt;= 1) {
1990         sleepTimeMs = exec-&gt;argument(0).toNumber(exec);
1991         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1992     }
1993 
1994     vm.heap.releaseAccess();
1995     if (sleepTimeMs)
1996         sleep(Seconds::fromMilliseconds(sleepTimeMs));
1997     vm.heap.acquireAccess();
1998     return JSValue::encode(jsUndefined());
1999 }
2000 
2001 EncodedJSValue JSC_HOST_CALL functionDisableRichSourceInfo(ExecState*)
2002 {
2003     supportsRichSourceInfo = false;
2004     return JSValue::encode(jsUndefined());
2005 }
2006 
2007 EncodedJSValue JSC_HOST_CALL functionMallocInALoop(ExecState*)
2008 {
2009     Vector&lt;void*&gt; ptrs;
2010     for (unsigned i = 0; i &lt; 5000; ++i)
2011         ptrs.append(fastMalloc(1024 * 2));
2012     for (void* ptr : ptrs)
2013         fastFree(ptr);
2014     return JSValue::encode(jsUndefined());
2015 }
2016 
2017 EncodedJSValue JSC_HOST_CALL functionTotalCompileTime(ExecState*)
2018 {
2019 #if ENABLE(JIT)
2020     return JSValue::encode(jsNumber(JIT::totalCompileTime().milliseconds()));
2021 #else
2022     return JSValue::encode(jsNumber(0));
2023 #endif
2024 }
2025 
2026 template&lt;typename ValueType&gt;
2027 typename std::enable_if&lt;!std::is_fundamental&lt;ValueType&gt;::value&gt;::type addOption(VM&amp;, JSObject*, const Identifier&amp;, ValueType) { }
2028 
2029 template&lt;typename ValueType&gt;
2030 typename std::enable_if&lt;std::is_fundamental&lt;ValueType&gt;::value&gt;::type addOption(VM&amp; vm, JSObject* optionsObject, const Identifier&amp; identifier, ValueType value)
2031 {
2032     optionsObject-&gt;putDirect(vm, identifier, JSValue(value));
2033 }
2034 
2035 EncodedJSValue JSC_HOST_CALL functionJSCOptions(ExecState* exec)
2036 {
2037     VM&amp; vm = exec-&gt;vm();
2038     JSObject* optionsObject = constructEmptyObject(exec);
2039 #define FOR_EACH_OPTION(type_, name_, defaultValue_, availability_, description_) \
<a name="64" id="anc64"></a><span class="line-modified">2040     addOption(vm, optionsObject, Identifier::fromString(exec, #name_), Options::name_());</span>
2041     JSC_OPTIONS(FOR_EACH_OPTION)
2042 #undef FOR_EACH_OPTION
2043     return JSValue::encode(optionsObject);
2044 }
2045 
2046 EncodedJSValue JSC_HOST_CALL functionReoptimizationRetryCount(ExecState* exec)
2047 {
2048     if (exec-&gt;argumentCount() &lt; 1)
2049         return JSValue::encode(jsUndefined());
2050 
2051     CodeBlock* block = getSomeBaselineCodeBlockForFunction(exec-&gt;argument(0));
2052     if (!block)
2053         return JSValue::encode(jsNumber(0));
2054 
2055     return JSValue::encode(jsNumber(block-&gt;reoptimizationRetryCounter()));
2056 }
2057 
2058 EncodedJSValue JSC_HOST_CALL functionTransferArrayBuffer(ExecState* exec)
2059 {
2060     VM&amp; vm = exec-&gt;vm();
2061     auto scope = DECLARE_THROW_SCOPE(vm);
2062 
2063     if (exec-&gt;argumentCount() &lt; 1)
2064         return JSValue::encode(throwException(exec, scope, createError(exec, &quot;Not enough arguments&quot;_s)));
2065 
2066     JSArrayBuffer* buffer = jsDynamicCast&lt;JSArrayBuffer*&gt;(vm, exec-&gt;argument(0));
2067     if (!buffer)
2068         return JSValue::encode(throwException(exec, scope, createError(exec, &quot;Expected an array buffer&quot;_s)));
2069 
2070     ArrayBufferContents dummyContents;
2071     buffer-&gt;impl()-&gt;transferTo(vm, dummyContents);
2072 
2073     return JSValue::encode(jsUndefined());
2074 }
2075 
2076 EncodedJSValue JSC_HOST_CALL functionFailNextNewCodeBlock(ExecState* exec)
2077 {
2078     VM&amp; vm = exec-&gt;vm();
2079     vm.setFailNextNewCodeBlock();
2080     return JSValue::encode(jsUndefined());
2081 }
2082 
2083 EncodedJSValue JSC_HOST_CALL functionQuit(ExecState* exec)
2084 {
2085     VM&amp; vm = exec-&gt;vm();
2086     vm.codeCache()-&gt;write(vm);
2087 
2088     jscExit(EXIT_SUCCESS);
2089 
2090 #if COMPILER(MSVC)
2091     // Without this, Visual Studio will complain that this method does not return a value.
2092     return JSValue::encode(jsUndefined());
2093 #endif
2094 }
2095 
2096 EncodedJSValue JSC_HOST_CALL functionFalse(ExecState*) { return JSValue::encode(jsBoolean(false)); }
2097 
2098 EncodedJSValue JSC_HOST_CALL functionUndefined1(ExecState*) { return JSValue::encode(jsUndefined()); }
2099 EncodedJSValue JSC_HOST_CALL functionUndefined2(ExecState*) { return JSValue::encode(jsUndefined()); }
2100 EncodedJSValue JSC_HOST_CALL functionIsInt32(ExecState* exec)
2101 {
2102     for (size_t i = 0; i &lt; exec-&gt;argumentCount(); ++i) {
2103         if (!exec-&gt;argument(i).isInt32())
2104             return JSValue::encode(jsBoolean(false));
2105     }
2106     return JSValue::encode(jsBoolean(true));
2107 }
2108 
2109 EncodedJSValue JSC_HOST_CALL functionIsPureNaN(ExecState* exec)
2110 {
2111     for (size_t i = 0; i &lt; exec-&gt;argumentCount(); ++i) {
2112         JSValue value = exec-&gt;argument(i);
2113         if (!value.isNumber())
2114             return JSValue::encode(jsBoolean(false));
2115         double number = value.asNumber();
2116         if (!std::isnan(number))
2117             return JSValue::encode(jsBoolean(false));
2118         if (isImpureNaN(number))
2119             return JSValue::encode(jsBoolean(false));
2120     }
2121     return JSValue::encode(jsBoolean(true));
2122 }
2123 
2124 EncodedJSValue JSC_HOST_CALL functionIdentity(ExecState* exec) { return JSValue::encode(exec-&gt;argument(0)); }
2125 
2126 EncodedJSValue JSC_HOST_CALL functionEffectful42(ExecState*)
2127 {
2128     return JSValue::encode(jsNumber(42));
2129 }
2130 
2131 EncodedJSValue JSC_HOST_CALL functionMakeMasquerader(ExecState* exec)
2132 {
2133     VM&amp; vm = exec-&gt;vm();
2134     return JSValue::encode(Masquerader::create(vm, exec-&gt;lexicalGlobalObject()));
2135 }
2136 
2137 EncodedJSValue JSC_HOST_CALL functionHasCustomProperties(ExecState* exec)
2138 {
2139     JSValue value = exec-&gt;argument(0);
2140     if (value.isObject())
2141         return JSValue::encode(jsBoolean(asObject(value)-&gt;hasCustomProperties(exec-&gt;vm())));
2142     return JSValue::encode(jsBoolean(false));
2143 }
2144 
2145 EncodedJSValue JSC_HOST_CALL functionDumpTypesForAllVariables(ExecState* exec)
2146 {
2147     VM&amp; vm = exec-&gt;vm();
2148     vm.dumpTypeProfilerData();
2149     return JSValue::encode(jsUndefined());
2150 }
2151 
2152 EncodedJSValue JSC_HOST_CALL functionDrainMicrotasks(ExecState* exec)
2153 {
2154     VM&amp; vm = exec-&gt;vm();
2155     vm.drainMicrotasks();
2156     return JSValue::encode(jsUndefined());
2157 }
2158 
<a name="65" id="anc65"></a>






2159 EncodedJSValue JSC_HOST_CALL functionIs32BitPlatform(ExecState*)
2160 {
2161 #if USE(JSVALUE64)
2162     return JSValue::encode(JSValue(JSC::JSValue::JSFalse));
2163 #else
2164     return JSValue::encode(JSValue(JSC::JSValue::JSTrue));
2165 #endif
2166 }
2167 
2168 EncodedJSValue JSC_HOST_CALL functionCreateGlobalObject(ExecState* exec)
2169 {
2170     VM&amp; vm = exec-&gt;vm();
2171     return JSValue::encode(GlobalObject::create(vm, GlobalObject::createStructure(vm, jsNull()), Vector&lt;String&gt;()));
2172 }
2173 
2174 EncodedJSValue JSC_HOST_CALL functionCheckModuleSyntax(ExecState* exec)
2175 {
2176     VM&amp; vm = exec-&gt;vm();
2177     auto scope = DECLARE_THROW_SCOPE(vm);
2178 
2179     String source = exec-&gt;argument(0).toWTFString(exec);
2180     RETURN_IF_EXCEPTION(scope, encodedJSValue());
2181 
2182     StopWatch stopWatch;
2183     stopWatch.start();
2184 
2185     ParserError error;
<a name="66" id="anc66"></a><span class="line-modified">2186     bool validSyntax = checkModuleSyntax(exec, makeSource(source, { }, URL(), TextPosition(), SourceProviderSourceType::Module), error);</span>
2187     RETURN_IF_EXCEPTION(scope, encodedJSValue());
2188     stopWatch.stop();
2189 
2190     if (!validSyntax)
<a name="67" id="anc67"></a><span class="line-modified">2191         throwException(exec, scope, jsNontrivialString(exec, toString(&quot;SyntaxError: &quot;, error.message(), &quot;:&quot;, error.line())));</span>
2192     return JSValue::encode(jsNumber(stopWatch.getElapsedMS()));
2193 }
2194 
2195 EncodedJSValue JSC_HOST_CALL functionPlatformSupportsSamplingProfiler(ExecState*)
2196 {
2197 #if ENABLE(SAMPLING_PROFILER)
2198     return JSValue::encode(JSValue(JSC::JSValue::JSTrue));
2199 #else
2200     return JSValue::encode(JSValue(JSC::JSValue::JSFalse));
2201 #endif
2202 }
2203 
2204 EncodedJSValue JSC_HOST_CALL functionGenerateHeapSnapshot(ExecState* exec)
2205 {
2206     VM&amp; vm = exec-&gt;vm();
2207     JSLockHolder lock(vm);
2208     auto scope = DECLARE_THROW_SCOPE(vm);
2209 
2210     HeapSnapshotBuilder snapshotBuilder(vm.ensureHeapProfiler());
2211     snapshotBuilder.buildSnapshot();
2212 
2213     String jsonString = snapshotBuilder.json();
2214     EncodedJSValue result = JSValue::encode(JSONParse(exec, jsonString));
2215     scope.releaseAssertNoException();
2216     return result;
2217 }
2218 
2219 EncodedJSValue JSC_HOST_CALL functionGenerateHeapSnapshotForGCDebugging(ExecState* exec)
2220 {
2221     VM&amp; vm = exec-&gt;vm();
2222     JSLockHolder lock(vm);
2223     auto scope = DECLARE_THROW_SCOPE(vm);
2224     String jsonString;
2225     {
2226         DeferGCForAWhile deferGC(vm.heap); // Prevent concurrent GC from interfering with the full GC that the snapshot does.
2227 
2228         HeapSnapshotBuilder snapshotBuilder(vm.ensureHeapProfiler(), HeapSnapshotBuilder::SnapshotType::GCDebuggingSnapshot);
2229         snapshotBuilder.buildSnapshot();
2230 
2231         jsonString = snapshotBuilder.json();
2232     }
2233     scope.releaseAssertNoException();
<a name="68" id="anc68"></a><span class="line-modified">2234     return JSValue::encode(jsString(&amp;vm, jsonString));</span>
2235 }
2236 
2237 EncodedJSValue JSC_HOST_CALL functionResetSuperSamplerState(ExecState*)
2238 {
2239     resetSuperSamplerState();
2240     return JSValue::encode(jsUndefined());
2241 }
2242 
2243 EncodedJSValue JSC_HOST_CALL functionEnsureArrayStorage(ExecState* exec)
2244 {
2245     VM&amp; vm = exec-&gt;vm();
2246     for (unsigned i = 0; i &lt; exec-&gt;argumentCount(); ++i) {
2247         if (JSObject* object = jsDynamicCast&lt;JSObject*&gt;(vm, exec-&gt;argument(i)))
2248             object-&gt;ensureArrayStorage(vm);
2249     }
2250     return JSValue::encode(jsUndefined());
2251 }
2252 
2253 #if ENABLE(SAMPLING_PROFILER)
2254 EncodedJSValue JSC_HOST_CALL functionStartSamplingProfiler(ExecState* exec)
2255 {
2256     VM&amp; vm = exec-&gt;vm();
2257     SamplingProfiler&amp; samplingProfiler = vm.ensureSamplingProfiler(WTF::Stopwatch::create());
2258     samplingProfiler.noticeCurrentThreadAsJSCExecutionThread();
2259     samplingProfiler.start();
2260     return JSValue::encode(jsUndefined());
2261 }
2262 
2263 EncodedJSValue JSC_HOST_CALL functionSamplingProfilerStackTraces(ExecState* exec)
2264 {
2265     VM&amp; vm = exec-&gt;vm();
2266     auto scope = DECLARE_THROW_SCOPE(vm);
2267 
2268     if (!vm.samplingProfiler())
2269         return JSValue::encode(throwException(exec, scope, createError(exec, &quot;Sampling profiler was never started&quot;_s)));
2270 
2271     String jsonString = vm.samplingProfiler()-&gt;stackTracesAsJSON();
2272     EncodedJSValue result = JSValue::encode(JSONParse(exec, jsonString));
2273     scope.releaseAssertNoException();
2274     return result;
2275 }
2276 #endif // ENABLE(SAMPLING_PROFILER)
2277 
2278 EncodedJSValue JSC_HOST_CALL functionMaxArguments(ExecState*)
2279 {
2280     return JSValue::encode(jsNumber(JSC::maxArguments));
2281 }
2282 
2283 EncodedJSValue JSC_HOST_CALL functionAsyncTestStart(ExecState* exec)
2284 {
2285     VM&amp; vm = exec-&gt;vm();
2286     auto scope = DECLARE_THROW_SCOPE(vm);
2287 
2288     JSValue numberOfAsyncPasses = exec-&gt;argument(0);
2289     if (!numberOfAsyncPasses.isUInt32())
<a name="69" id="anc69"></a><span class="line-modified">2290         return throwVMError(exec, scope, &quot;Expected first argument to a uint32&quot;_s);</span>
2291 
2292     asyncTestExpectedPasses += numberOfAsyncPasses.asUInt32();
2293     return encodedJSUndefined();
2294 }
2295 
2296 EncodedJSValue JSC_HOST_CALL functionAsyncTestPassed(ExecState*)
2297 {
2298     asyncTestPasses++;
2299     return encodedJSUndefined();
2300 }
2301 
2302 #if ENABLE(WEBASSEMBLY)
2303 
2304 static EncodedJSValue JSC_HOST_CALL functionWebAssemblyMemoryMode(ExecState* exec)
2305 {
2306     VM&amp; vm = exec-&gt;vm();
2307     auto scope = DECLARE_THROW_SCOPE(vm);
2308 
<a name="70" id="anc70"></a><span class="line-modified">2309     if (!Options::useWebAssembly())</span>
2310         return throwVMTypeError(exec, scope, &quot;WebAssemblyMemoryMode should only be called if the useWebAssembly option is set&quot;_s);
2311 
2312     if (JSObject* object = exec-&gt;argument(0).getObject()) {
2313         if (auto* memory = jsDynamicCast&lt;JSWebAssemblyMemory*&gt;(vm, object))
<a name="71" id="anc71"></a><span class="line-modified">2314             return JSValue::encode(jsString(&amp;vm, makeString(memory-&gt;memory().mode())));</span>
2315         if (auto* instance = jsDynamicCast&lt;JSWebAssemblyInstance*&gt;(vm, object))
<a name="72" id="anc72"></a><span class="line-modified">2316             return JSValue::encode(jsString(&amp;vm, makeString(instance-&gt;memoryMode())));</span>
2317     }
2318 
2319     return throwVMTypeError(exec, scope, &quot;WebAssemblyMemoryMode expects either a WebAssembly.Memory or WebAssembly.Instance&quot;_s);
2320 }
2321 
2322 #endif // ENABLE(WEBASSEMBLY)
2323 
<a name="73" id="anc73"></a>












2324 // Use SEH for Release builds only to get rid of the crash report dialog
2325 // (luckily the same tests fail in Release and Debug builds so far). Need to
2326 // be in a separate main function because the jscmain function requires object
2327 // unwinding.
2328 
2329 #if COMPILER(MSVC) &amp;&amp; !defined(_DEBUG)
2330 #define TRY       __try {
2331 #define EXCEPT(x) } __except (EXCEPTION_EXECUTE_HANDLER) { x; }
2332 #else
2333 #define TRY
2334 #define EXCEPT(x)
2335 #endif
2336 
2337 int jscmain(int argc, char** argv);
2338 
2339 static double s_desiredTimeout;
2340 static double s_timeoutMultiplier = 1.0;
2341 
2342 static void startTimeoutThreadIfNeeded()
2343 {
2344     if (char* timeoutString = getenv(&quot;JSCTEST_timeout&quot;)) {
2345         if (sscanf(timeoutString, &quot;%lf&quot;, &amp;s_desiredTimeout) != 1) {
2346             dataLog(&quot;WARNING: timeout string is malformed, got &quot;, timeoutString,
2347                 &quot; but expected a number. Not using a timeout.\n&quot;);
2348         } else {
2349             Thread::create(&quot;jsc Timeout Thread&quot;, [] () {
2350                 Seconds timeoutDuration(s_desiredTimeout * s_timeoutMultiplier);
2351                 sleep(timeoutDuration);
2352                 dataLog(&quot;Timed out after &quot;, timeoutDuration, &quot; seconds!\n&quot;);
2353                 CRASH();
2354             });
2355         }
2356     }
2357 }
2358 
2359 int main(int argc, char** argv)
2360 {
2361 #if PLATFORM(IOS_FAMILY) &amp;&amp; CPU(ARM_THUMB2)
2362     // Enabled IEEE754 denormal support.
2363     fenv_t env;
2364     fegetenv( &amp;env );
2365     env.__fpscr &amp;= ~0x01000000u;
2366     fesetenv( &amp;env );
2367 #endif
2368 
2369 #if OS(WINDOWS)
2370     // Cygwin calls ::SetErrorMode(SEM_FAILCRITICALERRORS), which we will inherit. This is bad for
2371     // testing/debugging, as it causes the post-mortem debugger not to be invoked. We reset the
2372     // error mode here to work around Cygwin&#39;s behavior. See &lt;http://webkit.org/b/55222&gt;.
2373     ::SetErrorMode(0);
2374 
2375     _setmode(_fileno(stdout), _O_BINARY);
2376     _setmode(_fileno(stderr), _O_BINARY);
2377 
2378 #if defined(_DEBUG)
2379     _CrtSetReportFile(_CRT_WARN, _CRTDBG_FILE_STDERR);
2380     _CrtSetReportMode(_CRT_WARN, _CRTDBG_MODE_FILE);
2381     _CrtSetReportFile(_CRT_ERROR, _CRTDBG_FILE_STDERR);
2382     _CrtSetReportMode(_CRT_ERROR, _CRTDBG_MODE_FILE);
2383     _CrtSetReportFile(_CRT_ASSERT, _CRTDBG_FILE_STDERR);
2384     _CrtSetReportMode(_CRT_ASSERT, _CRTDBG_MODE_FILE);
2385 #endif
2386 
2387     timeBeginPeriod(1);
2388 #endif
2389 
2390 #if PLATFORM(GTK)
2391     if (!setlocale(LC_ALL, &quot;&quot;))
2392         WTFLogAlways(&quot;Locale not supported by C library.\n\tUsing the fallback &#39;C&#39; locale.&quot;);
2393 #endif
2394 
2395     // Need to initialize WTF threading before we start any threads. Cannot initialize JSC
2396     // threading yet, since that would do somethings that we&#39;d like to defer until after we
2397     // have a chance to parse options.
2398     WTF::initializeThreading();
2399 
2400 #if PLATFORM(IOS_FAMILY)
2401     Options::crashIfCantAllocateJITMemory() = true;
2402 #endif
2403 
2404     // We can&#39;t use destructors in the following code because it uses Windows
2405     // Structured Exception Handling
2406     int res = 0;
2407     TRY
2408         res = jscmain(argc, argv);
2409     EXCEPT(res = 3)
2410     finalizeStatsAtEndOfTesting();
2411 
2412     jscExit(res);
2413 }
2414 
2415 static void dumpException(GlobalObject* globalObject, JSValue exception)
2416 {
2417     VM&amp; vm = globalObject-&gt;vm();
2418     auto scope = DECLARE_CATCH_SCOPE(vm);
2419 
2420 #define CHECK_EXCEPTION() do { \
2421         if (scope.exception()) { \
2422             scope.clearException(); \
2423             return; \
2424         } \
2425     } while (false)
2426 
2427     auto exceptionString = exception.toWTFString(globalObject-&gt;globalExec());
2428     Expected&lt;CString, UTF8ConversionError&gt; expectedCString = exceptionString.tryGetUtf8();
2429     if (expectedCString)
2430         printf(&quot;Exception: %s\n&quot;, expectedCString.value().data());
2431     else
2432         printf(&quot;Exception: &lt;out of memory while extracting exception string&gt;\n&quot;);
2433 
<a name="74" id="anc74"></a><span class="line-modified">2434     Identifier nameID = Identifier::fromString(globalObject-&gt;globalExec(), &quot;name&quot;);</span>
2435     CHECK_EXCEPTION();
<a name="75" id="anc75"></a><span class="line-modified">2436     Identifier fileNameID = Identifier::fromString(globalObject-&gt;globalExec(), &quot;sourceURL&quot;);</span>
2437     CHECK_EXCEPTION();
<a name="76" id="anc76"></a><span class="line-modified">2438     Identifier lineNumberID = Identifier::fromString(globalObject-&gt;globalExec(), &quot;line&quot;);</span>
2439     CHECK_EXCEPTION();
<a name="77" id="anc77"></a><span class="line-modified">2440     Identifier stackID = Identifier::fromString(globalObject-&gt;globalExec(), &quot;stack&quot;);</span>
2441     CHECK_EXCEPTION();
2442 
2443     JSValue nameValue = exception.get(globalObject-&gt;globalExec(), nameID);
2444     CHECK_EXCEPTION();
2445     JSValue fileNameValue = exception.get(globalObject-&gt;globalExec(), fileNameID);
2446     CHECK_EXCEPTION();
2447     JSValue lineNumberValue = exception.get(globalObject-&gt;globalExec(), lineNumberID);
2448     CHECK_EXCEPTION();
2449     JSValue stackValue = exception.get(globalObject-&gt;globalExec(), stackID);
2450     CHECK_EXCEPTION();
2451 
2452     if (nameValue.toWTFString(globalObject-&gt;globalExec()) == &quot;SyntaxError&quot;
2453         &amp;&amp; (!fileNameValue.isUndefinedOrNull() || !lineNumberValue.isUndefinedOrNull())) {
2454         printf(
2455             &quot;at %s:%s\n&quot;,
2456             fileNameValue.toWTFString(globalObject-&gt;globalExec()).utf8().data(),
2457             lineNumberValue.toWTFString(globalObject-&gt;globalExec()).utf8().data());
2458     }
2459 
2460     if (!stackValue.isUndefinedOrNull()) {
2461         auto stackString = stackValue.toWTFString(globalObject-&gt;globalExec());
2462         if (stackString.length())
2463             printf(&quot;%s\n&quot;, stackString.utf8().data());
2464     }
2465 
2466 #undef CHECK_EXCEPTION
2467 }
2468 
2469 static bool checkUncaughtException(VM&amp; vm, GlobalObject* globalObject, JSValue exception, CommandLine&amp; options)
2470 {
2471     const String&amp; expectedExceptionName = options.m_uncaughtExceptionName;
2472     auto scope = DECLARE_CATCH_SCOPE(vm);
2473     scope.clearException();
2474     if (!exception) {
2475         printf(&quot;Expected uncaught exception with name &#39;%s&#39; but none was thrown\n&quot;, expectedExceptionName.utf8().data());
2476         return false;
2477     }
2478 
2479     ExecState* exec = globalObject-&gt;globalExec();
<a name="78" id="anc78"></a><span class="line-modified">2480     JSValue exceptionClass = globalObject-&gt;get(exec, Identifier::fromString(exec, expectedExceptionName));</span>
2481     if (!exceptionClass.isObject() || scope.exception()) {
2482         printf(&quot;Expected uncaught exception with name &#39;%s&#39; but given exception class is not defined\n&quot;, expectedExceptionName.utf8().data());
2483         return false;
2484     }
2485 
2486     bool isInstanceOfExpectedException = jsCast&lt;JSObject*&gt;(exceptionClass)-&gt;hasInstance(exec, exception);
2487     if (scope.exception()) {
2488         printf(&quot;Expected uncaught exception with name &#39;%s&#39; but given exception class fails performing hasInstance\n&quot;, expectedExceptionName.utf8().data());
2489         return false;
2490     }
2491     if (isInstanceOfExpectedException) {
2492         if (options.m_alwaysDumpUncaughtException)
2493             dumpException(globalObject, exception);
2494         return true;
2495     }
2496 
2497     printf(&quot;Expected uncaught exception with name &#39;%s&#39; but exception value is not instance of this exception class\n&quot;, expectedExceptionName.utf8().data());
2498     dumpException(globalObject, exception);
2499     return false;
2500 }
2501 
2502 static void checkException(ExecState* exec, GlobalObject* globalObject, bool isLastFile, bool hasException, JSValue value, CommandLine&amp; options, bool&amp; success)
2503 {
2504     VM&amp; vm = globalObject-&gt;vm();
2505 
2506     if (options.m_treatWatchdogExceptionAsSuccess &amp;&amp; value.inherits&lt;TerminatedExecutionError&gt;(vm)) {
2507         ASSERT(hasException);
2508         return;
2509     }
2510 
2511     if (!options.m_uncaughtExceptionName || !isLastFile) {
2512         success = success &amp;&amp; !hasException;
2513         if (options.m_dump &amp;&amp; !hasException)
2514             printf(&quot;End: %s\n&quot;, value.toWTFString(exec).utf8().data());
2515         if (hasException)
2516             dumpException(globalObject, value);
2517     } else
2518         success = success &amp;&amp; checkUncaughtException(vm, globalObject, (hasException) ? value : JSValue(), options);
2519 }
2520 
2521 static void runWithOptions(GlobalObject* globalObject, CommandLine&amp; options, bool&amp; success)
2522 {
2523     Vector&lt;Script&gt;&amp; scripts = options.m_scripts;
2524     String fileName;
2525     Vector&lt;char&gt; scriptBuffer;
2526 
2527     if (options.m_dump)
2528         JSC::Options::dumpGeneratedBytecodes() = true;
2529 
2530     VM&amp; vm = globalObject-&gt;vm();
2531     auto scope = DECLARE_CATCH_SCOPE(vm);
2532 
2533 #if ENABLE(SAMPLING_FLAGS)
2534     SamplingFlags::start();
2535 #endif
2536 
2537     for (size_t i = 0; i &lt; scripts.size(); i++) {
2538         JSInternalPromise* promise = nullptr;
2539         bool isModule = options.m_module || scripts[i].scriptType == Script::ScriptType::Module;
2540         if (scripts[i].codeSource == Script::CodeSource::File) {
2541             fileName = scripts[i].argument;
2542             if (scripts[i].strictMode == Script::StrictMode::Strict)
2543                 scriptBuffer.append(&quot;\&quot;use strict\&quot;;\n&quot;, strlen(&quot;\&quot;use strict\&quot;;\n&quot;));
2544 
2545             if (isModule) {
2546                 promise = loadAndEvaluateModule(globalObject-&gt;globalExec(), fileName, jsUndefined(), jsUndefined());
2547                 scope.releaseAssertNoException();
2548             } else {
2549                 if (!fetchScriptFromLocalFileSystem(fileName, scriptBuffer)) {
2550                     success = false; // fail early so we can catch missing files
2551                     return;
2552                 }
2553             }
2554         } else {
2555             size_t commandLineLength = strlen(scripts[i].argument);
2556             scriptBuffer.resize(commandLineLength);
2557             std::copy(scripts[i].argument, scripts[i].argument + commandLineLength, scriptBuffer.begin());
2558             fileName = &quot;[Command Line]&quot;_s;
2559         }
2560 
2561         bool isLastFile = i == scripts.size() - 1;
2562         if (isModule) {
2563             if (!promise) {
2564                 // FIXME: This should use an absolute file URL https://bugs.webkit.org/show_bug.cgi?id=193077
2565                 promise = loadAndEvaluateModule(globalObject-&gt;globalExec(), jscSource(stringFromUTF(scriptBuffer), SourceOrigin { absolutePath(fileName) }, URL({ }, fileName), TextPosition(), SourceProviderSourceType::Module), jsUndefined());
2566             }
2567             scope.clearException();
2568 
2569             JSFunction* fulfillHandler = JSNativeStdFunction::create(vm, globalObject, 1, String(), [&amp;success, &amp;options, isLastFile](ExecState* exec) {
2570                 checkException(exec, jsCast&lt;GlobalObject*&gt;(exec-&gt;lexicalGlobalObject()), isLastFile, false, exec-&gt;argument(0), options, success);
2571                 return JSValue::encode(jsUndefined());
2572             });
2573 
2574             JSFunction* rejectHandler = JSNativeStdFunction::create(vm, globalObject, 1, String(), [&amp;success, &amp;options, isLastFile](ExecState* exec) {
2575                 checkException(exec, jsCast&lt;GlobalObject*&gt;(exec-&gt;lexicalGlobalObject()), isLastFile, true, exec-&gt;argument(0), options, success);
2576                 return JSValue::encode(jsUndefined());
2577             });
2578 
2579             promise-&gt;then(globalObject-&gt;globalExec(), fulfillHandler, rejectHandler);
2580             scope.releaseAssertNoException();
2581             vm.drainMicrotasks();
2582         } else {
2583             NakedPtr&lt;Exception&gt; evaluationException;
2584             JSValue returnValue = evaluate(globalObject-&gt;globalExec(), jscSource(scriptBuffer, SourceOrigin { absolutePath(fileName) }, fileName), JSValue(), evaluationException);
2585             scope.assertNoException();
2586             if (evaluationException)
2587                 returnValue = evaluationException-&gt;value();
2588             checkException(globalObject-&gt;globalExec(), globalObject, isLastFile, evaluationException, returnValue, options, success);
2589         }
2590 
2591         scriptBuffer.clear();
2592         scope.clearException();
2593     }
2594 
2595 #if ENABLE(REGEXP_TRACING)
2596     vm.dumpRegExpTrace();
2597 #endif
2598 }
2599 
2600 #define RUNNING_FROM_XCODE 0
2601 
2602 static void runInteractive(GlobalObject* globalObject)
2603 {
2604     VM&amp; vm = globalObject-&gt;vm();
2605     auto scope = DECLARE_CATCH_SCOPE(vm);
2606 
2607     Optional&lt;DirectoryName&gt; directoryName = currentWorkingDirectory();
2608     if (!directoryName)
2609         return;
2610     SourceOrigin sourceOrigin(resolvePath(directoryName.value(), ModuleName(&quot;interpreter&quot;)));
2611 
2612     bool shouldQuit = false;
2613     while (!shouldQuit) {
2614 #if HAVE(READLINE) &amp;&amp; !RUNNING_FROM_XCODE
2615         ParserError error;
2616         String source;
2617         do {
2618             error = ParserError();
2619             char* line = readline(source.isEmpty() ? interactivePrompt : &quot;... &quot;);
2620             shouldQuit = !line;
2621             if (!line)
2622                 break;
2623             source = source + String::fromUTF8(line);
2624             source = source + &#39;\n&#39;;
<a name="79" id="anc79"></a><span class="line-modified">2625             checkSyntax(vm, makeSource(source, sourceOrigin), error);</span>
2626             if (!line[0]) {
2627                 free(line);
2628                 break;
2629             }
2630             add_history(line);
2631             free(line);
2632         } while (error.syntaxErrorType() == ParserError::SyntaxErrorRecoverable);
2633 
2634         if (error.isValid()) {
2635             printf(&quot;%s:%d\n&quot;, error.message().utf8().data(), error.line());
2636             continue;
2637         }
2638 
2639 
2640         NakedPtr&lt;Exception&gt; evaluationException;
<a name="80" id="anc80"></a><span class="line-modified">2641         JSValue returnValue = evaluate(globalObject-&gt;globalExec(), makeSource(source, sourceOrigin), JSValue(), evaluationException);</span>
2642 #else
2643         printf(&quot;%s&quot;, interactivePrompt);
2644         Vector&lt;char, 256&gt; line;
2645         int c;
2646         while ((c = getchar()) != EOF) {
2647             // FIXME: Should we also break on \r?
2648             if (c == &#39;\n&#39;)
2649                 break;
2650             line.append(c);
2651         }
2652         if (line.isEmpty())
2653             break;
2654 
2655         NakedPtr&lt;Exception&gt; evaluationException;
2656         JSValue returnValue = evaluate(globalObject-&gt;globalExec(), jscSource(line, sourceOrigin, sourceOrigin.string()), JSValue(), evaluationException);
2657 #endif
2658         if (evaluationException)
2659             printf(&quot;Exception: %s\n&quot;, evaluationException-&gt;value().toWTFString(globalObject-&gt;globalExec()).utf8().data());
2660         else
2661             printf(&quot;%s\n&quot;, returnValue.toWTFString(globalObject-&gt;globalExec()).utf8().data());
2662 
2663         scope.clearException();
2664         vm.drainMicrotasks();
2665     }
2666     printf(&quot;\n&quot;);
2667 }
2668 
2669 static NO_RETURN void printUsageStatement(bool help = false)
2670 {
2671     fprintf(stderr, &quot;Usage: jsc [options] [files] [-- arguments]\n&quot;);
2672     fprintf(stderr, &quot;  -d         Dumps bytecode (debug builds only)\n&quot;);
2673     fprintf(stderr, &quot;  -e         Evaluate argument as script code\n&quot;);
2674     fprintf(stderr, &quot;  -f         Specifies a source file (deprecated)\n&quot;);
2675     fprintf(stderr, &quot;  -h|--help  Prints this help message\n&quot;);
2676     fprintf(stderr, &quot;  -i         Enables interactive mode (default if no files are specified)\n&quot;);
2677     fprintf(stderr, &quot;  -m         Execute as a module\n&quot;);
2678 #if HAVE(SIGNAL_H)
2679     fprintf(stderr, &quot;  -s         Installs signal handlers that exit on a crash (Unix platforms only)\n&quot;);
2680 #endif
2681     fprintf(stderr, &quot;  -p &lt;file&gt;  Outputs profiling data to a file\n&quot;);
2682     fprintf(stderr, &quot;  -x         Output exit code before terminating\n&quot;);
2683     fprintf(stderr, &quot;\n&quot;);
2684     fprintf(stderr, &quot;  --sample                   Collects and outputs sampling profiler data\n&quot;);
2685     fprintf(stderr, &quot;  --test262-async            Check that some script calls the print function with the string &#39;Test262:AsyncTestComplete&#39;\n&quot;);
2686     fprintf(stderr, &quot;  --strict-file=&lt;file&gt;       Parse the given file as if it were in strict mode (this option may be passed more than once)\n&quot;);
2687     fprintf(stderr, &quot;  --module-file=&lt;file&gt;       Parse and evaluate the given file as module (this option may be passed more than once)\n&quot;);
2688     fprintf(stderr, &quot;  --exception=&lt;name&gt;         Check the last script exits with an uncaught exception with the specified name\n&quot;);
2689     fprintf(stderr, &quot;  --watchdog-exception-ok    Uncaught watchdog exceptions exit with success\n&quot;);
2690     fprintf(stderr, &quot;  --dumpException            Dump uncaught exception text\n&quot;);
2691     fprintf(stderr, &quot;  --footprint                Dump memory footprint after done executing\n&quot;);
2692     fprintf(stderr, &quot;  --options                  Dumps all JSC VM options and exits\n&quot;);
2693     fprintf(stderr, &quot;  --dumpOptions              Dumps all non-default JSC VM options before continuing\n&quot;);
2694     fprintf(stderr, &quot;  --&lt;jsc VM option&gt;=&lt;value&gt;  Sets the specified JSC VM option\n&quot;);
<a name="81" id="anc81"></a>
2695     fprintf(stderr, &quot;\n&quot;);
2696     fprintf(stderr, &quot;Files with a .mjs extension will always be evaluated as modules.\n&quot;);
2697     fprintf(stderr, &quot;\n&quot;);
2698 
2699     jscExit(help ? EXIT_SUCCESS : EXIT_FAILURE);
2700 }
2701 
2702 static bool isMJSFile(char *filename)
2703 {
2704     filename = strrchr(filename, &#39;.&#39;);
2705 
2706     if (filename)
2707         return !strcmp(filename, &quot;.mjs&quot;);
2708 
2709     return false;
2710 }
2711 
2712 void CommandLine::parseArguments(int argc, char** argv)
2713 {
2714     Options::initialize();
2715 
2716     if (Options::dumpOptions()) {
2717         printf(&quot;Command line:&quot;);
2718 #if PLATFORM(COCOA)
2719         for (char** envp = *_NSGetEnviron(); *envp; envp++) {
2720             const char* env = *envp;
2721             if (!strncmp(&quot;JSC_&quot;, env, 4))
2722                 printf(&quot; %s&quot;, env);
2723         }
2724 #endif // PLATFORM(COCOA)
2725         for (int i = 0; i &lt; argc; ++i)
2726             printf(&quot; %s&quot;, argv[i]);
2727         printf(&quot;\n&quot;);
2728     }
2729 
2730     int i = 1;
2731     JSC::Options::DumpLevel dumpOptionsLevel = JSC::Options::DumpLevel::None;
2732     bool needToExit = false;
2733 
2734     bool hasBadJSCOptions = false;
2735     for (; i &lt; argc; ++i) {
2736         const char* arg = argv[i];
2737         if (!strcmp(arg, &quot;-f&quot;)) {
2738             if (++i == argc)
2739                 printUsageStatement();
2740             m_scripts.append(Script(Script::StrictMode::Sloppy, Script::CodeSource::File, Script::ScriptType::Script, argv[i]));
2741             continue;
2742         }
2743         if (!strcmp(arg, &quot;-e&quot;)) {
2744             if (++i == argc)
2745                 printUsageStatement();
2746             m_scripts.append(Script(Script::StrictMode::Sloppy, Script::CodeSource::CommandLine, Script::ScriptType::Script, argv[i]));
2747             continue;
2748         }
2749         if (!strcmp(arg, &quot;-i&quot;)) {
2750             m_interactive = true;
2751             continue;
2752         }
2753         if (!strcmp(arg, &quot;-d&quot;)) {
2754             m_dump = true;
2755             continue;
2756         }
2757         if (!strcmp(arg, &quot;-p&quot;)) {
2758             if (++i == argc)
2759                 printUsageStatement();
2760             m_profile = true;
2761             m_profilerOutput = argv[i];
2762             continue;
2763         }
2764         if (!strcmp(arg, &quot;-m&quot;)) {
2765             m_module = true;
2766             continue;
2767         }
2768         if (!strcmp(arg, &quot;-s&quot;)) {
2769 #if HAVE(SIGNAL_H)
2770             signal(SIGILL, _exit);
2771             signal(SIGFPE, _exit);
2772             signal(SIGBUS, _exit);
2773             signal(SIGSEGV, _exit);
2774 #endif
2775             continue;
2776         }
2777         if (!strcmp(arg, &quot;-x&quot;)) {
2778             m_exitCode = true;
2779             continue;
2780         }
2781         if (!strcmp(arg, &quot;--&quot;)) {
2782             ++i;
2783             break;
2784         }
2785         if (!strcmp(arg, &quot;-h&quot;) || !strcmp(arg, &quot;--help&quot;))
2786             printUsageStatement(true);
2787 
2788         if (!strcmp(arg, &quot;--options&quot;)) {
2789             dumpOptionsLevel = JSC::Options::DumpLevel::Verbose;
2790             needToExit = true;
2791             continue;
2792         }
2793         if (!strcmp(arg, &quot;--dumpOptions&quot;)) {
2794             dumpOptionsLevel = JSC::Options::DumpLevel::Overridden;
2795             continue;
2796         }
2797         if (!strcmp(arg, &quot;--sample&quot;)) {
2798             JSC::Options::useSamplingProfiler() = true;
2799             JSC::Options::collectSamplingProfilerDataForJSCShell() = true;
2800             m_dumpSamplingProfilerData = true;
2801             continue;
2802         }
<a name="82" id="anc82"></a>



2803 
2804         static const char* timeoutMultiplierOptStr = &quot;--timeoutMultiplier=&quot;;
2805         static const unsigned timeoutMultiplierOptStrLength = strlen(timeoutMultiplierOptStr);
2806         if (!strncmp(arg, timeoutMultiplierOptStr, timeoutMultiplierOptStrLength)) {
2807             const char* valueStr = &amp;arg[timeoutMultiplierOptStrLength];
2808             if (sscanf(valueStr, &quot;%lf&quot;, &amp;s_timeoutMultiplier) != 1)
2809                 dataLog(&quot;WARNING: --timeoutMultiplier=&quot;, valueStr, &quot; is invalid. Expects a numeric ratio.\n&quot;);
2810             continue;
2811         }
2812 
2813         if (!strcmp(arg, &quot;--test262-async&quot;)) {
2814             asyncTestExpectedPasses++;
2815             continue;
2816         }
2817 
2818         if (!strcmp(arg, &quot;--remote-debug&quot;)) {
2819             m_enableRemoteDebugging = true;
2820             continue;
2821         }
2822 
2823         static const unsigned strictFileStrLength = strlen(&quot;--strict-file=&quot;);
2824         if (!strncmp(arg, &quot;--strict-file=&quot;, strictFileStrLength)) {
2825             m_scripts.append(Script(Script::StrictMode::Strict, Script::CodeSource::File, Script::ScriptType::Script, argv[i] + strictFileStrLength));
2826             continue;
2827         }
2828 
2829         static const unsigned moduleFileStrLength = strlen(&quot;--module-file=&quot;);
2830         if (!strncmp(arg, &quot;--module-file=&quot;, moduleFileStrLength)) {
2831             m_scripts.append(Script(Script::StrictMode::Sloppy, Script::CodeSource::File, Script::ScriptType::Module, argv[i] + moduleFileStrLength));
2832             continue;
2833         }
2834 
2835         if (!strcmp(arg, &quot;--dumpException&quot;)) {
2836             m_alwaysDumpUncaughtException = true;
2837             continue;
2838         }
2839 
2840         if (!strcmp(arg, &quot;--footprint&quot;)) {
2841             m_dumpMemoryFootprint = true;
2842             continue;
2843         }
2844 
2845         static const unsigned exceptionStrLength = strlen(&quot;--exception=&quot;);
2846         if (!strncmp(arg, &quot;--exception=&quot;, exceptionStrLength)) {
2847             m_uncaughtExceptionName = String(arg + exceptionStrLength);
2848             continue;
2849         }
2850 
2851         if (!strcmp(arg, &quot;--watchdog-exception-ok&quot;)) {
2852             m_treatWatchdogExceptionAsSuccess = true;
2853             continue;
2854         }
2855 
2856         // See if the -- option is a JSC VM option.
2857         if (strstr(arg, &quot;--&quot;) == arg) {
2858             if (!JSC::Options::setOption(&amp;arg[2])) {
2859                 hasBadJSCOptions = true;
2860                 dataLog(&quot;ERROR: invalid option: &quot;, arg, &quot;\n&quot;);
2861             }
2862             continue;
2863         }
2864 
2865         // This arg is not recognized by the VM nor by jsc. Pass it on to the
2866         // script.
2867         Script::ScriptType scriptType = isMJSFile(argv[i]) ? Script::ScriptType::Module : Script::ScriptType::Script;
2868         m_scripts.append(Script(Script::StrictMode::Sloppy, Script::CodeSource::File, scriptType, argv[i]));
2869     }
2870 
2871     if (hasBadJSCOptions &amp;&amp; JSC::Options::validateOptions())
2872         CRASH();
2873 
2874     if (m_scripts.isEmpty())
2875         m_interactive = true;
2876 
2877     for (; i &lt; argc; ++i)
2878         m_arguments.append(argv[i]);
2879 
2880     if (dumpOptionsLevel != JSC::Options::DumpLevel::None) {
2881         const char* optionsTitle = (dumpOptionsLevel == JSC::Options::DumpLevel::Overridden)
2882             ? &quot;Modified JSC runtime options:&quot;
2883             : &quot;All JSC runtime options:&quot;;
2884         JSC::Options::dumpAllOptions(stderr, dumpOptionsLevel, optionsTitle);
2885     }
2886     JSC::Options::ensureOptionsAreCoherent();
2887     if (needToExit)
2888         jscExit(EXIT_SUCCESS);
2889 }
2890 
2891 template&lt;typename Func&gt;
2892 int runJSC(const CommandLine&amp; options, bool isWorker, const Func&amp; func)
2893 {
2894     Worker worker(Workers::singleton());
2895 
2896     VM&amp; vm = VM::create(LargeHeap).leakRef();
2897     int result;
2898     bool success = true;
2899     GlobalObject* globalObject = nullptr;
2900     {
2901         JSLockHolder locker(vm);
2902 
2903         if (options.m_profile &amp;&amp; !vm.m_perBytecodeProfiler)
<a name="83" id="anc83"></a><span class="line-modified">2904             vm.m_perBytecodeProfiler = std::make_unique&lt;Profiler::Database&gt;(vm);</span>
2905 
2906         globalObject = GlobalObject::create(vm, GlobalObject::createStructure(vm, jsNull()), options.m_arguments);
2907         globalObject-&gt;setRemoteDebuggingEnabled(options.m_enableRemoteDebugging);
2908         func(vm, globalObject, success);
2909         vm.drainMicrotasks();
2910     }
2911     vm.promiseDeferredTimer-&gt;runRunLoop();
2912     {
2913         JSLockHolder locker(vm);
2914         if (options.m_interactive &amp;&amp; success)
2915             runInteractive(globalObject);
2916     }
2917 
2918     result = success &amp;&amp; (asyncTestExpectedPasses == asyncTestPasses) ? 0 : 3;
2919 
2920     if (options.m_exitCode) {
2921         printf(&quot;jsc exiting %d&quot;, result);
2922         if (asyncTestExpectedPasses != asyncTestPasses)
2923             printf(&quot; because expected: %d async test passes but got: %d async test passes&quot;, asyncTestExpectedPasses, asyncTestPasses);
2924         printf(&quot;\n&quot;);
2925     }
2926 
2927     if (options.m_profile) {
2928         JSLockHolder locker(vm);
2929         if (!vm.m_perBytecodeProfiler-&gt;save(options.m_profilerOutput.utf8().data()))
2930             fprintf(stderr, &quot;could not save profiler output.\n&quot;);
2931     }
2932 
2933 #if ENABLE(JIT)
2934     {
2935         JSLockHolder locker(vm);
2936         if (Options::useExceptionFuzz())
2937             printf(&quot;JSC EXCEPTION FUZZ: encountered %u checks.\n&quot;, numberOfExceptionFuzzChecks());
2938         bool fireAtEnabled =
2939         Options::fireExecutableAllocationFuzzAt() || Options::fireExecutableAllocationFuzzAtOrAfter();
2940         if (Options::useExecutableAllocationFuzz() &amp;&amp; (!fireAtEnabled || Options::verboseExecutableAllocationFuzz()))
2941             printf(&quot;JSC EXECUTABLE ALLOCATION FUZZ: encountered %u checks.\n&quot;, numberOfExecutableAllocationFuzzChecks());
2942         if (Options::useOSRExitFuzz()) {
2943             printf(&quot;JSC OSR EXIT FUZZ: encountered %u static checks.\n&quot;, numberOfStaticOSRExitFuzzChecks());
2944             printf(&quot;JSC OSR EXIT FUZZ: encountered %u dynamic checks.\n&quot;, numberOfOSRExitFuzzChecks());
2945         }
2946 
2947 
2948         auto compileTimeStats = JIT::compileTimeStats();
2949         Vector&lt;CString&gt; compileTimeKeys;
2950         for (auto&amp; entry : compileTimeStats)
2951             compileTimeKeys.append(entry.key);
2952         std::sort(compileTimeKeys.begin(), compileTimeKeys.end());
2953         for (const CString&amp; key : compileTimeKeys)
2954             printf(&quot;%40s: %.3lf ms\n&quot;, key.data(), compileTimeStats.get(key).milliseconds());
2955     }
2956 #endif
2957 
2958     if (Options::gcAtEnd()) {
2959         // We need to hold the API lock to do a GC.
2960         JSLockHolder locker(&amp;vm);
2961         vm.heap.collectNow(Sync, CollectionScope::Full);
2962     }
2963 
2964     if (options.m_dumpSamplingProfilerData) {
2965 #if ENABLE(SAMPLING_PROFILER)
2966         JSLockHolder locker(&amp;vm);
2967         vm.samplingProfiler()-&gt;reportTopFunctions();
2968         vm.samplingProfiler()-&gt;reportTopBytecodes();
2969 #else
2970         dataLog(&quot;Sampling profiler is not enabled on this platform\n&quot;);
2971 #endif
2972     }
2973 
2974     vm.codeCache()-&gt;write(vm);
2975 
<a name="84" id="anc84"></a><span class="line-modified">2976     if (isWorker) {</span>
2977         JSLockHolder locker(vm);
2978         // This is needed because we don&#39;t want the worker&#39;s main
2979         // thread to die before its compilation threads finish.
2980         vm.deref();
2981     }
2982 
2983     return result;
2984 }
2985 
2986 int jscmain(int argc, char** argv)
2987 {
2988     // Need to override and enable restricted options before we start parsing options below.
2989     Options::enableRestrictedOptions(true);
2990 
<a name="85" id="anc85"></a>

2991     // Note that the options parsing can affect VM creation, and thus
2992     // comes first.
2993     CommandLine options(argc, argv);
2994 
2995     processConfigFile(Options::configFile(), &quot;jsc&quot;);
2996 
2997     // Initialize JSC before getting VM.
<a name="86" id="anc86"></a><span class="line-removed">2998     WTF::initializeMainThread();</span>
2999     JSC::initializeThreading();
3000     startTimeoutThreadIfNeeded();
3001 #if ENABLE(WEBASSEMBLY)
3002     JSC::Wasm::enableFastMemory();
3003 #endif
3004     Gigacage::disableDisablingPrimitiveGigacageIfShouldBeEnabled();
3005 
3006 #if PLATFORM(COCOA)
3007     auto&amp; memoryPressureHandler = MemoryPressureHandler::singleton();
3008     {
3009         dispatch_queue_t queue = dispatch_queue_create(&quot;jsc shell memory pressure handler&quot;, DISPATCH_QUEUE_SERIAL);
3010         memoryPressureHandler.setDispatchQueue(queue);
3011         dispatch_release(queue);
3012     }
3013     Box&lt;Critical&gt; memoryPressureCriticalState = Box&lt;Critical&gt;::create(Critical::No);
3014     Box&lt;Synchronous&gt; memoryPressureSynchronousState = Box&lt;Synchronous&gt;::create(Synchronous::No);
3015     memoryPressureHandler.setLowMemoryHandler([=] (Critical critical, Synchronous synchronous) {
3016         // We set these racily with respect to reading them from the JS execution thread.
3017         *memoryPressureCriticalState = critical;
3018         *memoryPressureSynchronousState = synchronous;
3019     });
3020     memoryPressureHandler.setShouldLogMemoryMemoryPressureEvents(false);
3021     memoryPressureHandler.install();
3022 
3023     auto onEachMicrotaskTick = [&amp;] (VM&amp; vm) {
3024         if (*memoryPressureCriticalState == Critical::No)
3025             return;
3026 
3027         *memoryPressureCriticalState = Critical::No;
3028         bool isSynchronous = *memoryPressureSynchronousState == Synchronous::Yes;
3029 
3030         WTF::releaseFastMallocFreeMemory();
3031         vm.deleteAllCode(DeleteAllCodeIfNotCollecting);
3032 
3033         if (!vm.heap.isCurrentThreadBusy()) {
3034             if (isSynchronous) {
3035                 vm.heap.collectNow(Sync, CollectionScope::Full);
3036                 WTF::releaseFastMallocFreeMemory();
3037             } else
3038                 vm.heap.collectNowFullIfNotDoneRecently(Async);
3039         }
3040     };
3041 #endif
3042 
3043     int result = runJSC(
3044         options, false,
3045         [&amp;] (VM&amp; vm, GlobalObject* globalObject, bool&amp; success) {
3046             UNUSED_PARAM(vm);
3047 #if PLATFORM(COCOA)
3048             vm.setOnEachMicrotaskTick(WTFMove(onEachMicrotaskTick));
3049 #endif
3050             runWithOptions(globalObject, options, success);
3051         });
3052 
3053     printSuperSamplerState();
3054 
3055     if (options.m_dumpMemoryFootprint) {
3056         MemoryFootprint footprint = MemoryFootprint::now();
3057 
3058         printf(&quot;Memory Footprint:\n    Current Footprint: %&quot; PRIu64 &quot;\n    Peak Footprint: %&quot; PRIu64 &quot;\n&quot;, footprint.current, footprint.peak);
3059     }
3060 
3061     return result;
3062 }
3063 
3064 #if OS(WINDOWS)
3065 extern &quot;C&quot; __declspec(dllexport) int WINAPI dllLauncherEntryPoint(int argc, const char* argv[])
3066 {
3067     return main(argc, const_cast&lt;char**&gt;(argv));
3068 }
3069 #endif
<a name="87" id="anc87"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="87" type="hidden" />
</body>
</html>