<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/JITOperations.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JITOpcodes32_64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JITOperations.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/JITOperations.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  59 #include &quot;JSCPtrTag.h&quot;
  60 #include &quot;JSGeneratorFunction.h&quot;
  61 #include &quot;JSGlobalObjectFunctions.h&quot;
  62 #include &quot;JSLexicalEnvironment.h&quot;
  63 #include &quot;JSWithScope.h&quot;
  64 #include &quot;ModuleProgramCodeBlock.h&quot;
  65 #include &quot;ObjectConstructor.h&quot;
  66 #include &quot;PolymorphicAccess.h&quot;
  67 #include &quot;ProgramCodeBlock.h&quot;
  68 #include &quot;PropertyName.h&quot;
  69 #include &quot;RegExpObject.h&quot;
  70 #include &quot;Repatch.h&quot;
  71 #include &quot;ScopedArguments.h&quot;
  72 #include &quot;ShadowChicken.h&quot;
  73 #include &quot;StructureStubInfo.h&quot;
  74 #include &quot;SuperSampler.h&quot;
  75 #include &quot;TestRunnerUtils.h&quot;
  76 #include &quot;ThunkGenerators.h&quot;
  77 #include &quot;TypeProfilerLog.h&quot;
  78 #include &quot;VMInlines.h&quot;

  79 #include &lt;wtf/InlineASM.h&gt;
  80 
  81 namespace JSC {
  82 
  83 extern &quot;C&quot; {
  84 
  85 #if COMPILER(MSVC)
  86 void * _ReturnAddress(void);
  87 #pragma intrinsic(_ReturnAddress)
  88 
  89 #define OUR_RETURN_ADDRESS _ReturnAddress()
  90 #else
  91 #define OUR_RETURN_ADDRESS __builtin_return_address(0)
  92 #endif
  93 
  94 #if ENABLE(OPCODE_SAMPLING)
<span class="line-modified">  95 #define CTI_SAMPLER vm-&gt;interpreter-&gt;sampler()</span>
  96 #else
  97 #define CTI_SAMPLER 0
  98 #endif
  99 
 100 
 101 void JIT_OPERATION operationThrowStackOverflowError(ExecState* exec, CodeBlock* codeBlock)
 102 {
 103     // We pass in our own code block, because the callframe hasn&#39;t been populated.
<span class="line-modified"> 104     VM* vm = codeBlock-&gt;vm();</span>
<span class="line-modified"> 105     auto scope = DECLARE_THROW_SCOPE(*vm);</span>
<span class="line-modified"> 106     exec-&gt;convertToStackOverflowFrame(*vm, codeBlock);</span>
 107     NativeCallFrameTracer tracer(vm, exec);
 108     throwStackOverflowError(exec, scope);
 109 }
 110 










 111 int32_t JIT_OPERATION operationCallArityCheck(ExecState* exec)
 112 {
<span class="line-modified"> 113     VM* vm = &amp;exec-&gt;vm();</span>
<span class="line-modified"> 114     auto scope = DECLARE_THROW_SCOPE(*vm);</span>
 115 
<span class="line-modified"> 116     int32_t missingArgCount = CommonSlowPaths::arityCheckFor(exec, *vm, CodeForCall);</span>
 117     if (UNLIKELY(missingArgCount &lt; 0)) {
 118         CodeBlock* codeBlock = CommonSlowPaths::codeBlockFromCallFrameCallee(exec, CodeForCall);
<span class="line-modified"> 119         exec-&gt;convertToStackOverflowFrame(*vm, codeBlock);</span>
 120         NativeCallFrameTracer tracer(vm, exec);
<span class="line-modified"> 121         throwStackOverflowError(vm-&gt;topCallFrame, scope);</span>
 122     }
 123 
 124     return missingArgCount;
 125 }
 126 
 127 int32_t JIT_OPERATION operationConstructArityCheck(ExecState* exec)
 128 {
<span class="line-modified"> 129     VM* vm = &amp;exec-&gt;vm();</span>
<span class="line-modified"> 130     auto scope = DECLARE_THROW_SCOPE(*vm);</span>
 131 
<span class="line-modified"> 132     int32_t missingArgCount = CommonSlowPaths::arityCheckFor(exec, *vm, CodeForConstruct);</span>
 133     if (UNLIKELY(missingArgCount &lt; 0)) {
 134         CodeBlock* codeBlock = CommonSlowPaths::codeBlockFromCallFrameCallee(exec, CodeForConstruct);
<span class="line-modified"> 135         exec-&gt;convertToStackOverflowFrame(*vm, codeBlock);</span>
 136         NativeCallFrameTracer tracer(vm, exec);
<span class="line-modified"> 137         throwStackOverflowError(vm-&gt;topCallFrame, scope);</span>
 138     }
 139 
 140     return missingArgCount;
 141 }
 142 
 143 EncodedJSValue JIT_OPERATION operationTryGetById(ExecState* exec, StructureStubInfo* stubInfo, EncodedJSValue base, UniquedStringImpl* uid)
 144 {
<span class="line-modified"> 145     VM* vm = &amp;exec-&gt;vm();</span>
 146     NativeCallFrameTracer tracer(vm, exec);
 147     Identifier ident = Identifier::fromUid(vm, uid);
 148     stubInfo-&gt;tookSlowPath = true;
 149 
 150     JSValue baseValue = JSValue::decode(base);
 151     PropertySlot slot(baseValue, PropertySlot::InternalMethodType::VMInquiry);
 152     baseValue.getPropertySlot(exec, ident, slot);
 153 
 154     return JSValue::encode(slot.getPureResult());
 155 }
 156 
 157 
 158 EncodedJSValue JIT_OPERATION operationTryGetByIdGeneric(ExecState* exec, EncodedJSValue base, UniquedStringImpl* uid)
 159 {
<span class="line-modified"> 160     VM* vm = &amp;exec-&gt;vm();</span>
 161     NativeCallFrameTracer tracer(vm, exec);
 162     Identifier ident = Identifier::fromUid(vm, uid);
 163 
 164     JSValue baseValue = JSValue::decode(base);
 165     PropertySlot slot(baseValue, PropertySlot::InternalMethodType::VMInquiry);
 166     baseValue.getPropertySlot(exec, ident, slot);
 167 
 168     return JSValue::encode(slot.getPureResult());
 169 }
 170 
 171 EncodedJSValue JIT_OPERATION operationTryGetByIdOptimize(ExecState* exec, StructureStubInfo* stubInfo, EncodedJSValue base, UniquedStringImpl* uid)
 172 {
<span class="line-modified"> 173     VM* vm = &amp;exec-&gt;vm();</span>
 174     NativeCallFrameTracer tracer(vm, exec);
<span class="line-modified"> 175     auto scope = DECLARE_THROW_SCOPE(*vm);</span>
 176     Identifier ident = Identifier::fromUid(vm, uid);
 177 
 178     JSValue baseValue = JSValue::decode(base);
 179     PropertySlot slot(baseValue, PropertySlot::InternalMethodType::VMInquiry);
 180 
 181     baseValue.getPropertySlot(exec, ident, slot);
 182     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 183 
<span class="line-modified"> 184     if (stubInfo-&gt;considerCaching(exec-&gt;codeBlock(), baseValue.structureOrNull()) &amp;&amp; !slot.isTaintedByOpaqueObject() &amp;&amp; (slot.isCacheableValue() || slot.isCacheableGetter() || slot.isUnset()))</span>
 185         repatchGetByID(exec, baseValue, ident, slot, *stubInfo, GetByIDKind::Try);
 186 
 187     return JSValue::encode(slot.getPureResult());
 188 }
 189 
 190 EncodedJSValue JIT_OPERATION operationGetByIdDirect(ExecState* exec, StructureStubInfo* stubInfo, EncodedJSValue base, UniquedStringImpl* uid)
 191 {
 192     VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 193     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
 194     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified"> 195     Identifier ident = Identifier::fromUid(&amp;vm, uid);</span>
 196     stubInfo-&gt;tookSlowPath = true;
 197 
 198     JSValue baseValue = JSValue::decode(base);
 199     PropertySlot slot(baseValue, PropertySlot::InternalMethodType::GetOwnProperty);
 200 
 201     bool found = baseValue.getOwnPropertySlot(exec, ident, slot);
 202     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 203 
 204     RELEASE_AND_RETURN(scope, JSValue::encode(found ? slot.getValue(exec, ident) : jsUndefined()));
 205 }
 206 
 207 EncodedJSValue JIT_OPERATION operationGetByIdDirectGeneric(ExecState* exec, EncodedJSValue base, UniquedStringImpl* uid)
 208 {
 209     VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 210     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
 211     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified"> 212     Identifier ident = Identifier::fromUid(&amp;vm, uid);</span>
 213 
 214     JSValue baseValue = JSValue::decode(base);
 215     PropertySlot slot(baseValue, PropertySlot::InternalMethodType::GetOwnProperty);
 216 
 217     bool found = baseValue.getOwnPropertySlot(exec, ident, slot);
 218     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 219 
 220     RELEASE_AND_RETURN(scope, JSValue::encode(found ? slot.getValue(exec, ident) : jsUndefined()));
 221 }
 222 
 223 EncodedJSValue JIT_OPERATION operationGetByIdDirectOptimize(ExecState* exec, StructureStubInfo* stubInfo, EncodedJSValue base, UniquedStringImpl* uid)
 224 {
 225     VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 226     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
 227     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified"> 228     Identifier ident = Identifier::fromUid(&amp;vm, uid);</span>
 229 
 230     JSValue baseValue = JSValue::decode(base);
 231     PropertySlot slot(baseValue, PropertySlot::InternalMethodType::GetOwnProperty);
 232 
 233     bool found = baseValue.getOwnPropertySlot(exec, ident, slot);
 234     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 235 
<span class="line-modified"> 236     if (stubInfo-&gt;considerCaching(exec-&gt;codeBlock(), baseValue.structureOrNull()))</span>
 237         repatchGetByID(exec, baseValue, ident, slot, *stubInfo, GetByIDKind::Direct);
 238 
 239     RELEASE_AND_RETURN(scope, JSValue::encode(found ? slot.getValue(exec, ident) : jsUndefined()));
 240 }
 241 
 242 EncodedJSValue JIT_OPERATION operationGetById(ExecState* exec, StructureStubInfo* stubInfo, EncodedJSValue base, UniquedStringImpl* uid)
 243 {
 244     SuperSamplerScope superSamplerScope(false);
 245 
<span class="line-modified"> 246     VM* vm = &amp;exec-&gt;vm();</span>
 247     NativeCallFrameTracer tracer(vm, exec);
 248 
 249     stubInfo-&gt;tookSlowPath = true;
 250 
 251     JSValue baseValue = JSValue::decode(base);
 252     PropertySlot slot(baseValue, PropertySlot::InternalMethodType::Get);
 253     Identifier ident = Identifier::fromUid(vm, uid);

 254 
<span class="line-modified"> 255     LOG_IC((ICEvent::OperationGetById, baseValue.classInfoOrNull(*vm), ident));</span>
<span class="line-modified"> 256     return JSValue::encode(baseValue.get(exec, ident, slot));</span>

 257 }
 258 
 259 EncodedJSValue JIT_OPERATION operationGetByIdGeneric(ExecState* exec, EncodedJSValue base, UniquedStringImpl* uid)
 260 {
 261     SuperSamplerScope superSamplerScope(false);
 262 
<span class="line-modified"> 263     VM* vm = &amp;exec-&gt;vm();</span>
 264     NativeCallFrameTracer tracer(vm, exec);
 265 
 266     JSValue baseValue = JSValue::decode(base);
 267     PropertySlot slot(baseValue, PropertySlot::InternalMethodType::Get);
 268     Identifier ident = Identifier::fromUid(vm, uid);
<span class="line-modified"> 269     LOG_IC((ICEvent::OperationGetByIdGeneric, baseValue.classInfoOrNull(*vm), ident));</span>
<span class="line-modified"> 270     return JSValue::encode(baseValue.get(exec, ident, slot));</span>



 271 }
 272 
 273 EncodedJSValue JIT_OPERATION operationGetByIdOptimize(ExecState* exec, StructureStubInfo* stubInfo, EncodedJSValue base, UniquedStringImpl* uid)
 274 {
 275     SuperSamplerScope superSamplerScope(false);
 276 
<span class="line-modified"> 277     VM* vm = &amp;exec-&gt;vm();</span>
 278     NativeCallFrameTracer tracer(vm, exec);
 279     Identifier ident = Identifier::fromUid(vm, uid);
 280 
 281     JSValue baseValue = JSValue::decode(base);
<span class="line-removed"> 282     LOG_IC((ICEvent::OperationGetByIdOptimize, baseValue.classInfoOrNull(*vm), ident));</span>
 283 
 284     return JSValue::encode(baseValue.getPropertySlot(exec, ident, [&amp;] (bool found, PropertySlot&amp; slot) -&gt; JSValue {
<span class="line-modified"> 285         if (stubInfo-&gt;considerCaching(exec-&gt;codeBlock(), baseValue.structureOrNull()))</span>



 286             repatchGetByID(exec, baseValue, ident, slot, *stubInfo, GetByIDKind::Normal);
 287         return found ? slot.getValue(exec, ident) : jsUndefined();
 288     }));
 289 }
 290 
 291 EncodedJSValue JIT_OPERATION operationGetByIdWithThis(ExecState* exec, StructureStubInfo* stubInfo, EncodedJSValue base, EncodedJSValue thisEncoded, UniquedStringImpl* uid)
 292 {
 293     SuperSamplerScope superSamplerScope(false);
 294 
<span class="line-modified"> 295     VM* vm = &amp;exec-&gt;vm();</span>
 296     NativeCallFrameTracer tracer(vm, exec);
 297     Identifier ident = Identifier::fromUid(vm, uid);
 298 
 299     stubInfo-&gt;tookSlowPath = true;
 300 
 301     JSValue baseValue = JSValue::decode(base);
 302     JSValue thisValue = JSValue::decode(thisEncoded);
 303     PropertySlot slot(thisValue, PropertySlot::InternalMethodType::Get);
 304 
 305     return JSValue::encode(baseValue.get(exec, ident, slot));
 306 }
 307 
 308 EncodedJSValue JIT_OPERATION operationGetByIdWithThisGeneric(ExecState* exec, EncodedJSValue base, EncodedJSValue thisEncoded, UniquedStringImpl* uid)
 309 {
 310     SuperSamplerScope superSamplerScope(false);
 311 
<span class="line-modified"> 312     VM* vm = &amp;exec-&gt;vm();</span>
 313     NativeCallFrameTracer tracer(vm, exec);
 314     Identifier ident = Identifier::fromUid(vm, uid);
 315 
 316     JSValue baseValue = JSValue::decode(base);
 317     JSValue thisValue = JSValue::decode(thisEncoded);
 318     PropertySlot slot(thisValue, PropertySlot::InternalMethodType::Get);
 319 
 320     return JSValue::encode(baseValue.get(exec, ident, slot));
 321 }
 322 
 323 EncodedJSValue JIT_OPERATION operationGetByIdWithThisOptimize(ExecState* exec, StructureStubInfo* stubInfo, EncodedJSValue base, EncodedJSValue thisEncoded, UniquedStringImpl* uid)
 324 {
 325     SuperSamplerScope superSamplerScope(false);
 326 
<span class="line-modified"> 327     VM* vm = &amp;exec-&gt;vm();</span>
 328     NativeCallFrameTracer tracer(vm, exec);
 329     Identifier ident = Identifier::fromUid(vm, uid);
 330 
 331     JSValue baseValue = JSValue::decode(base);
 332     JSValue thisValue = JSValue::decode(thisEncoded);
<span class="line-removed"> 333     LOG_IC((ICEvent::OperationGetByIdWithThisOptimize, baseValue.classInfoOrNull(*vm), ident));</span>
 334 
 335     PropertySlot slot(thisValue, PropertySlot::InternalMethodType::Get);
 336     return JSValue::encode(baseValue.getPropertySlot(exec, ident, slot, [&amp;] (bool found, PropertySlot&amp; slot) -&gt; JSValue {
<span class="line-modified"> 337         if (stubInfo-&gt;considerCaching(exec-&gt;codeBlock(), baseValue.structureOrNull()))</span>


 338             repatchGetByID(exec, baseValue, ident, slot, *stubInfo, GetByIDKind::WithThis);
 339         return found ? slot.getValue(exec, ident) : jsUndefined();
 340     }));
 341 }
 342 
 343 EncodedJSValue JIT_OPERATION operationInById(ExecState* exec, StructureStubInfo* stubInfo, EncodedJSValue base, UniquedStringImpl* uid)
 344 {
 345     SuperSamplerScope superSamplerScope(false);
 346 
 347     VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 348     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
 349     auto scope = DECLARE_THROW_SCOPE(vm);
 350 
 351     stubInfo-&gt;tookSlowPath = true;
 352 
<span class="line-modified"> 353     Identifier ident = Identifier::fromUid(&amp;vm, uid);</span>
 354 
 355     JSValue baseValue = JSValue::decode(base);
 356     if (!baseValue.isObject()) {
 357         throwException(exec, scope, createInvalidInParameterError(exec, baseValue));
 358         return JSValue::encode(jsUndefined());
 359     }
 360     JSObject* baseObject = asObject(baseValue);
 361 
 362     LOG_IC((ICEvent::OperationInById, baseObject-&gt;classInfo(vm), ident));
 363 
 364     scope.release();
 365     PropertySlot slot(baseObject, PropertySlot::InternalMethodType::HasProperty);
 366     return JSValue::encode(jsBoolean(baseObject-&gt;getPropertySlot(exec, ident, slot)));
 367 }
 368 
 369 EncodedJSValue JIT_OPERATION operationInByIdGeneric(ExecState* exec, EncodedJSValue base, UniquedStringImpl* uid)
 370 {
 371     SuperSamplerScope superSamplerScope(false);
 372 
 373     VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 374     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
 375     auto scope = DECLARE_THROW_SCOPE(vm);
 376 
<span class="line-modified"> 377     Identifier ident = Identifier::fromUid(&amp;vm, uid);</span>
 378 
 379     JSValue baseValue = JSValue::decode(base);
 380     if (!baseValue.isObject()) {
 381         throwException(exec, scope, createInvalidInParameterError(exec, baseValue));
 382         return JSValue::encode(jsUndefined());
 383     }
 384     JSObject* baseObject = asObject(baseValue);
 385 
 386     LOG_IC((ICEvent::OperationInByIdGeneric, baseObject-&gt;classInfo(vm), ident));
 387 
 388     scope.release();
 389     PropertySlot slot(baseObject, PropertySlot::InternalMethodType::HasProperty);
 390     return JSValue::encode(jsBoolean(baseObject-&gt;getPropertySlot(exec, ident, slot)));
 391 }
 392 
 393 EncodedJSValue JIT_OPERATION operationInByIdOptimize(ExecState* exec, StructureStubInfo* stubInfo, EncodedJSValue base, UniquedStringImpl* uid)
 394 {
 395     SuperSamplerScope superSamplerScope(false);
 396 
 397     VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 398     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
 399     auto scope = DECLARE_THROW_SCOPE(vm);
 400 
<span class="line-modified"> 401     Identifier ident = Identifier::fromUid(&amp;vm, uid);</span>
 402 
 403     JSValue baseValue = JSValue::decode(base);
 404     if (!baseValue.isObject()) {
 405         throwException(exec, scope, createInvalidInParameterError(exec, baseValue));
 406         return JSValue::encode(jsUndefined());
 407     }
 408     JSObject* baseObject = asObject(baseValue);
 409 
 410     LOG_IC((ICEvent::OperationInByIdOptimize, baseObject-&gt;classInfo(vm), ident));
 411 
 412     scope.release();
 413     PropertySlot slot(baseObject, PropertySlot::InternalMethodType::HasProperty);
 414     bool found = baseObject-&gt;getPropertySlot(exec, ident, slot);
<span class="line-modified"> 415     if (stubInfo-&gt;considerCaching(exec-&gt;codeBlock(), baseObject-&gt;structure(vm)))</span>
 416         repatchInByID(exec, baseObject, ident, found, slot, *stubInfo);
 417     return JSValue::encode(jsBoolean(found));
 418 }
 419 
 420 EncodedJSValue JIT_OPERATION operationInByVal(ExecState* exec, JSCell* base, EncodedJSValue key)
 421 {
 422     SuperSamplerScope superSamplerScope(false);
 423 
<span class="line-modified"> 424     VM* vm = &amp;exec-&gt;vm();</span>
 425     NativeCallFrameTracer tracer(vm, exec);
 426 
 427     return JSValue::encode(jsBoolean(CommonSlowPaths::opInByVal(exec, base, JSValue::decode(key))));
 428 }
 429 
 430 void JIT_OPERATION operationPutByIdStrict(ExecState* exec, StructureStubInfo* stubInfo, EncodedJSValue encodedValue, EncodedJSValue encodedBase, UniquedStringImpl* uid)
 431 {
 432     SuperSamplerScope superSamplerScope(false);
 433 
<span class="line-modified"> 434     VM* vm = &amp;exec-&gt;vm();</span>
 435     NativeCallFrameTracer tracer(vm, exec);
 436 
 437     stubInfo-&gt;tookSlowPath = true;
 438 
 439     JSValue baseValue = JSValue::decode(encodedBase);
 440     Identifier ident = Identifier::fromUid(vm, uid);
<span class="line-removed"> 441     LOG_IC((ICEvent::OperationPutByIdStrict, baseValue.classInfoOrNull(*vm), ident));</span>
<span class="line-removed"> 442 </span>
 443     PutPropertySlot slot(baseValue, true, exec-&gt;codeBlock()-&gt;putByIdContext());
 444     baseValue.putInline(exec, ident, JSValue::decode(encodedValue), slot);


 445 }
 446 
 447 void JIT_OPERATION operationPutByIdNonStrict(ExecState* exec, StructureStubInfo* stubInfo, EncodedJSValue encodedValue, EncodedJSValue encodedBase, UniquedStringImpl* uid)
 448 {
 449     SuperSamplerScope superSamplerScope(false);
 450 
<span class="line-modified"> 451     VM* vm = &amp;exec-&gt;vm();</span>
 452     NativeCallFrameTracer tracer(vm, exec);
 453 
 454     stubInfo-&gt;tookSlowPath = true;
 455 
 456     JSValue baseValue = JSValue::decode(encodedBase);
 457     Identifier ident = Identifier::fromUid(vm, uid);
<span class="line-removed"> 458     LOG_IC((ICEvent::OperationPutByIdNonStrict, baseValue.classInfoOrNull(*vm), ident));</span>
 459     PutPropertySlot slot(baseValue, false, exec-&gt;codeBlock()-&gt;putByIdContext());
 460     baseValue.putInline(exec, ident, JSValue::decode(encodedValue), slot);


 461 }
 462 
 463 void JIT_OPERATION operationPutByIdDirectStrict(ExecState* exec, StructureStubInfo* stubInfo, EncodedJSValue encodedValue, EncodedJSValue encodedBase, UniquedStringImpl* uid)
 464 {
 465     SuperSamplerScope superSamplerScope(false);
 466 
 467     VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 468     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
 469 
 470     stubInfo-&gt;tookSlowPath = true;
 471 
 472     JSValue baseValue = JSValue::decode(encodedBase);
<span class="line-modified"> 473     Identifier ident = Identifier::fromUid(&amp;vm, uid);</span>
<span class="line-removed"> 474     LOG_IC((ICEvent::OperationPutByIdDirectStrict, baseValue.classInfoOrNull(vm), ident));</span>
 475     PutPropertySlot slot(baseValue, true, exec-&gt;codeBlock()-&gt;putByIdContext());
 476     CommonSlowPaths::putDirectWithReify(vm, exec, asObject(baseValue), ident, JSValue::decode(encodedValue), slot);


 477 }
 478 
 479 void JIT_OPERATION operationPutByIdDirectNonStrict(ExecState* exec, StructureStubInfo* stubInfo, EncodedJSValue encodedValue, EncodedJSValue encodedBase, UniquedStringImpl* uid)
 480 {
 481     SuperSamplerScope superSamplerScope(false);
 482 
 483     VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 484     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
 485 
 486     stubInfo-&gt;tookSlowPath = true;
 487 
 488     JSValue baseValue = JSValue::decode(encodedBase);
<span class="line-modified"> 489     Identifier ident = Identifier::fromUid(&amp;vm, uid);</span>
<span class="line-removed"> 490     LOG_IC((ICEvent::OperationPutByIdDirectNonStrict, baseValue.classInfoOrNull(vm), ident));</span>
 491     PutPropertySlot slot(baseValue, false, exec-&gt;codeBlock()-&gt;putByIdContext());
 492     CommonSlowPaths::putDirectWithReify(vm, exec, asObject(baseValue), ident, JSValue::decode(encodedValue), slot);


 493 }
 494 
 495 void JIT_OPERATION operationPutByIdStrictOptimize(ExecState* exec, StructureStubInfo* stubInfo, EncodedJSValue encodedValue, EncodedJSValue encodedBase, UniquedStringImpl* uid)
 496 {
 497     SuperSamplerScope superSamplerScope(false);
 498 
<span class="line-modified"> 499     VM* vm = &amp;exec-&gt;vm();</span>
 500     NativeCallFrameTracer tracer(vm, exec);
<span class="line-modified"> 501     auto scope = DECLARE_THROW_SCOPE(*vm);</span>
 502 
 503     Identifier ident = Identifier::fromUid(vm, uid);
 504     AccessType accessType = static_cast&lt;AccessType&gt;(stubInfo-&gt;accessType);
 505 
 506     JSValue value = JSValue::decode(encodedValue);
 507     JSValue baseValue = JSValue::decode(encodedBase);
<span class="line-removed"> 508     LOG_IC((ICEvent::OperationPutByIdStrictOptimize, baseValue.classInfoOrNull(*vm), ident));</span>
 509     CodeBlock* codeBlock = exec-&gt;codeBlock();
 510     PutPropertySlot slot(baseValue, true, codeBlock-&gt;putByIdContext());
 511 
<span class="line-modified"> 512     Structure* structure = baseValue.isCell() ? baseValue.asCell()-&gt;structure(*vm) : nullptr;</span>
 513     baseValue.putInline(exec, ident, value, slot);



 514     RETURN_IF_EXCEPTION(scope, void());
 515 
 516     if (accessType != static_cast&lt;AccessType&gt;(stubInfo-&gt;accessType))
 517         return;
 518 
<span class="line-modified"> 519     if (stubInfo-&gt;considerCaching(codeBlock, structure))</span>
 520         repatchPutByID(exec, baseValue, structure, ident, slot, *stubInfo, NotDirect);
 521 }
 522 
 523 void JIT_OPERATION operationPutByIdNonStrictOptimize(ExecState* exec, StructureStubInfo* stubInfo, EncodedJSValue encodedValue, EncodedJSValue encodedBase, UniquedStringImpl* uid)
 524 {
 525     SuperSamplerScope superSamplerScope(false);
 526 
<span class="line-modified"> 527     VM* vm = &amp;exec-&gt;vm();</span>
 528     NativeCallFrameTracer tracer(vm, exec);
<span class="line-modified"> 529     auto scope = DECLARE_THROW_SCOPE(*vm);</span>
 530 
 531     Identifier ident = Identifier::fromUid(vm, uid);
 532     AccessType accessType = static_cast&lt;AccessType&gt;(stubInfo-&gt;accessType);
 533 
 534     JSValue value = JSValue::decode(encodedValue);
 535     JSValue baseValue = JSValue::decode(encodedBase);
<span class="line-removed"> 536     LOG_IC((ICEvent::OperationPutByIdNonStrictOptimize, baseValue.classInfoOrNull(*vm), ident));</span>
 537     CodeBlock* codeBlock = exec-&gt;codeBlock();
 538     PutPropertySlot slot(baseValue, false, codeBlock-&gt;putByIdContext());
 539 
<span class="line-modified"> 540     Structure* structure = baseValue.isCell() ? baseValue.asCell()-&gt;structure(*vm) : nullptr;</span>
 541     baseValue.putInline(exec, ident, value, slot);



 542     RETURN_IF_EXCEPTION(scope, void());
 543 
 544     if (accessType != static_cast&lt;AccessType&gt;(stubInfo-&gt;accessType))
 545         return;
 546 
<span class="line-modified"> 547     if (stubInfo-&gt;considerCaching(codeBlock, structure))</span>
 548         repatchPutByID(exec, baseValue, structure, ident, slot, *stubInfo, NotDirect);
 549 }
 550 
 551 void JIT_OPERATION operationPutByIdDirectStrictOptimize(ExecState* exec, StructureStubInfo* stubInfo, EncodedJSValue encodedValue, EncodedJSValue encodedBase, UniquedStringImpl* uid)
 552 {
 553     SuperSamplerScope superSamplerScope(false);
 554 
 555     VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 556     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
 557     auto scope = DECLARE_THROW_SCOPE(vm);
 558 
<span class="line-modified"> 559     Identifier ident = Identifier::fromUid(&amp;vm, uid);</span>
 560     AccessType accessType = static_cast&lt;AccessType&gt;(stubInfo-&gt;accessType);
 561 
 562     JSValue value = JSValue::decode(encodedValue);
 563     JSObject* baseObject = asObject(JSValue::decode(encodedBase));
<span class="line-removed"> 564     LOG_IC((ICEvent::OperationPutByIdDirectStrictOptimize, baseObject-&gt;classInfo(vm), ident));</span>
 565     CodeBlock* codeBlock = exec-&gt;codeBlock();
 566     PutPropertySlot slot(baseObject, true, codeBlock-&gt;putByIdContext());
 567     Structure* structure = nullptr;
 568     CommonSlowPaths::putDirectWithReify(vm, exec, baseObject, ident, value, slot, &amp;structure);



 569     RETURN_IF_EXCEPTION(scope, void());
 570 
 571     if (accessType != static_cast&lt;AccessType&gt;(stubInfo-&gt;accessType))
 572         return;
 573 
<span class="line-modified"> 574     if (stubInfo-&gt;considerCaching(codeBlock, structure))</span>
 575         repatchPutByID(exec, baseObject, structure, ident, slot, *stubInfo, Direct);
 576 }
 577 
 578 void JIT_OPERATION operationPutByIdDirectNonStrictOptimize(ExecState* exec, StructureStubInfo* stubInfo, EncodedJSValue encodedValue, EncodedJSValue encodedBase, UniquedStringImpl* uid)
 579 {
 580     SuperSamplerScope superSamplerScope(false);
 581 
 582     VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 583     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
 584     auto scope = DECLARE_THROW_SCOPE(vm);
 585 
<span class="line-modified"> 586     Identifier ident = Identifier::fromUid(&amp;vm, uid);</span>
 587     AccessType accessType = static_cast&lt;AccessType&gt;(stubInfo-&gt;accessType);
 588 
 589     JSValue value = JSValue::decode(encodedValue);
 590     JSObject* baseObject = asObject(JSValue::decode(encodedBase));
<span class="line-removed"> 591     LOG_IC((ICEvent::OperationPutByIdDirectNonStrictOptimize, baseObject-&gt;classInfo(vm), ident));</span>
 592     CodeBlock* codeBlock = exec-&gt;codeBlock();
 593     PutPropertySlot slot(baseObject, false, codeBlock-&gt;putByIdContext());
 594     Structure* structure = nullptr;
 595     CommonSlowPaths::putDirectWithReify(vm, exec, baseObject, ident, value, slot, &amp;structure);



 596     RETURN_IF_EXCEPTION(scope, void());
 597 
 598     if (accessType != static_cast&lt;AccessType&gt;(stubInfo-&gt;accessType))
 599         return;
 600 
<span class="line-modified"> 601     if (stubInfo-&gt;considerCaching(codeBlock, structure))</span>
 602         repatchPutByID(exec, baseObject, structure, ident, slot, *stubInfo, Direct);
 603 }
 604 
 605 ALWAYS_INLINE static bool isStringOrSymbol(JSValue value)
 606 {
 607     return value.isString() || value.isSymbol();
 608 }
 609 
 610 static void putByVal(CallFrame* callFrame, JSValue baseValue, JSValue subscript, JSValue value, ByValInfo* byValInfo)
 611 {
 612     VM&amp; vm = callFrame-&gt;vm();
 613     auto scope = DECLARE_THROW_SCOPE(vm);
 614     if (LIKELY(subscript.isUInt32())) {
 615         byValInfo-&gt;tookSlowPath = true;
 616         uint32_t i = subscript.asUInt32();
 617         if (baseValue.isObject()) {
 618             JSObject* object = asObject(baseValue);
<span class="line-modified"> 619             if (object-&gt;canSetIndexQuickly(i)) {</span>
 620                 object-&gt;setIndexQuickly(vm, i, value);
 621                 return;
 622             }
 623 
<span class="line-removed"> 624             // FIXME: This will make us think that in-bounds typed array accesses are actually</span>
<span class="line-removed"> 625             // out-of-bounds.</span>
<span class="line-removed"> 626             // https://bugs.webkit.org/show_bug.cgi?id=149886</span>
 627             byValInfo-&gt;arrayProfile-&gt;setOutOfBounds();
 628             scope.release();
 629             object-&gt;methodTable(vm)-&gt;putByIndex(object, callFrame, i, value, callFrame-&gt;codeBlock()-&gt;isStrictMode());
 630             return;
 631         }
 632 
 633         scope.release();
 634         baseValue.putByIndex(callFrame, i, value, callFrame-&gt;codeBlock()-&gt;isStrictMode());
 635         return;




 636     }
 637 
 638     auto property = subscript.toPropertyKey(callFrame);
 639     // Don&#39;t put to an object if toString threw an exception.
 640     RETURN_IF_EXCEPTION(scope, void());
 641 
 642     if (byValInfo-&gt;stubInfo &amp;&amp; (!isStringOrSymbol(subscript) || byValInfo-&gt;cachedId != property))
 643         byValInfo-&gt;tookSlowPath = true;
 644 
 645     scope.release();
 646     PutPropertySlot slot(baseValue, callFrame-&gt;codeBlock()-&gt;isStrictMode());
 647     baseValue.putInline(callFrame, property, value, slot);
 648 }
 649 
 650 static void directPutByVal(CallFrame* callFrame, JSObject* baseObject, JSValue subscript, JSValue value, ByValInfo* byValInfo)
 651 {
 652     VM&amp; vm = callFrame-&gt;vm();
 653     auto scope = DECLARE_THROW_SCOPE(vm);
 654     bool isStrictMode = callFrame-&gt;codeBlock()-&gt;isStrictMode();
 655 
</pre>
<hr />
<pre>
 703         byValInfo-&gt;tookSlowPath = true;
 704 
 705     scope.release();
 706     PutPropertySlot slot(baseObject, isStrictMode);
 707     CommonSlowPaths::putDirectWithReify(vm, callFrame, baseObject, property, value, slot);
 708 }
 709 
 710 enum class OptimizationResult {
 711     NotOptimized,
 712     SeenOnce,
 713     Optimized,
 714     GiveUp,
 715 };
 716 
 717 static OptimizationResult tryPutByValOptimize(ExecState* exec, JSValue baseValue, JSValue subscript, ByValInfo* byValInfo, ReturnAddressPtr returnAddress)
 718 {
 719     // See if it&#39;s worth optimizing at all.
 720     OptimizationResult optimizationResult = OptimizationResult::NotOptimized;
 721 
 722     VM&amp; vm = exec-&gt;vm();

 723 
 724     if (baseValue.isObject() &amp;&amp; isCopyOnWrite(baseValue.getObject()-&gt;indexingMode()))
 725         return OptimizationResult::GiveUp;
 726 
 727     if (baseValue.isObject() &amp;&amp; subscript.isInt32()) {
 728         JSObject* object = asObject(baseValue);
 729 
 730         ASSERT(exec-&gt;bytecodeOffset());
 731         ASSERT(!byValInfo-&gt;stubRoutine);
 732 
 733         Structure* structure = object-&gt;structure(vm);
 734         if (hasOptimizableIndexing(structure)) {
 735             // Attempt to optimize.
 736             JITArrayMode arrayMode = jitArrayModeForStructure(structure);
 737             if (jitArrayModePermitsPut(arrayMode) &amp;&amp; arrayMode != byValInfo-&gt;arrayMode) {
 738                 CodeBlock* codeBlock = exec-&gt;codeBlock();
 739                 ConcurrentJSLocker locker(codeBlock-&gt;m_lock);
 740                 byValInfo-&gt;arrayProfile-&gt;computeUpdatedPrediction(locker, codeBlock, structure);
<span class="line-modified"> 741                 JIT::compilePutByVal(locker, &amp;vm, codeBlock, byValInfo, returnAddress, arrayMode);</span>
 742                 optimizationResult = OptimizationResult::Optimized;
 743             }
 744         }
 745 
 746         // If we failed to patch and we have some object that intercepts indexed get, then don&#39;t even wait until 10 times.
 747         if (optimizationResult != OptimizationResult::Optimized &amp;&amp; object-&gt;structure(vm)-&gt;typeInfo().interceptsGetOwnPropertySlotByIndexEvenWhenLengthIsNotZero())
 748             optimizationResult = OptimizationResult::GiveUp;
 749     }
 750 
 751     if (baseValue.isObject() &amp;&amp; isStringOrSymbol(subscript)) {
 752         const Identifier propertyName = subscript.toPropertyKey(exec);

 753         if (subscript.isSymbol() || !parseIndex(propertyName)) {
 754             ASSERT(exec-&gt;bytecodeOffset());
 755             ASSERT(!byValInfo-&gt;stubRoutine);
 756             if (byValInfo-&gt;seen) {
 757                 if (byValInfo-&gt;cachedId == propertyName) {
<span class="line-modified"> 758                     JIT::compilePutByValWithCachedId&lt;OpPutByVal&gt;(&amp;vm, exec-&gt;codeBlock(), byValInfo, returnAddress, NotDirect, propertyName);</span>
 759                     optimizationResult = OptimizationResult::Optimized;
 760                 } else {
 761                     // Seem like a generic property access site.
 762                     optimizationResult = OptimizationResult::GiveUp;
 763                 }
 764             } else {
 765                 CodeBlock* codeBlock = exec-&gt;codeBlock();
 766                 ConcurrentJSLocker locker(codeBlock-&gt;m_lock);
 767                 byValInfo-&gt;seen = true;
 768                 byValInfo-&gt;cachedId = propertyName;
 769                 if (subscript.isSymbol())
 770                     byValInfo-&gt;cachedSymbol.set(vm, codeBlock, asSymbol(subscript));
 771                 optimizationResult = OptimizationResult::SeenOnce;
 772             }
 773         }
 774     }
 775 
 776     if (optimizationResult != OptimizationResult::Optimized &amp;&amp; optimizationResult != OptimizationResult::SeenOnce) {
 777         // If we take slow path more than 10 times without patching then make sure we
 778         // never make that mistake again. For cases where we see non-index-intercepting
 779         // objects, this gives 10 iterations worth of opportunity for us to observe
 780         // that the put_by_val may be polymorphic. We count up slowPathCount even if
 781         // the result is GiveUp.
 782         if (++byValInfo-&gt;slowPathCount &gt;= 10)
 783             optimizationResult = OptimizationResult::GiveUp;
 784     }
 785 
 786     return optimizationResult;
 787 }
 788 
 789 void JIT_OPERATION operationPutByValOptimize(ExecState* exec, EncodedJSValue encodedBaseValue, EncodedJSValue encodedSubscript, EncodedJSValue encodedValue, ByValInfo* byValInfo)
 790 {
 791     VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 792     NativeCallFrameTracer tracer(&amp;vm, exec);</span>

 793 
 794     JSValue baseValue = JSValue::decode(encodedBaseValue);
 795     JSValue subscript = JSValue::decode(encodedSubscript);
 796     JSValue value = JSValue::decode(encodedValue);
<span class="line-modified"> 797     if (tryPutByValOptimize(exec, baseValue, subscript, byValInfo, ReturnAddressPtr(OUR_RETURN_ADDRESS)) == OptimizationResult::GiveUp) {</span>


 798         // Don&#39;t ever try to optimize.
 799         byValInfo-&gt;tookSlowPath = true;
 800         ctiPatchCallByReturnAddress(ReturnAddressPtr(OUR_RETURN_ADDRESS), operationPutByValGeneric);
 801     }
<span class="line-modified"> 802     putByVal(exec, baseValue, subscript, value, byValInfo);</span>
 803 }
 804 
 805 static OptimizationResult tryDirectPutByValOptimize(ExecState* exec, JSObject* object, JSValue subscript, ByValInfo* byValInfo, ReturnAddressPtr returnAddress)
 806 {
 807     // See if it&#39;s worth optimizing at all.
 808     OptimizationResult optimizationResult = OptimizationResult::NotOptimized;
 809 
 810     VM&amp; vm = exec-&gt;vm();

 811 
 812     if (subscript.isInt32()) {
 813         ASSERT(exec-&gt;bytecodeOffset());
 814         ASSERT(!byValInfo-&gt;stubRoutine);
 815 
 816         Structure* structure = object-&gt;structure(vm);
 817         if (hasOptimizableIndexing(structure)) {
 818             // Attempt to optimize.
 819             JITArrayMode arrayMode = jitArrayModeForStructure(structure);
 820             if (jitArrayModePermitsPutDirect(arrayMode) &amp;&amp; arrayMode != byValInfo-&gt;arrayMode) {
 821                 CodeBlock* codeBlock = exec-&gt;codeBlock();
 822                 ConcurrentJSLocker locker(codeBlock-&gt;m_lock);
 823                 byValInfo-&gt;arrayProfile-&gt;computeUpdatedPrediction(locker, codeBlock, structure);
 824 
<span class="line-modified"> 825                 JIT::compileDirectPutByVal(locker, &amp;vm, codeBlock, byValInfo, returnAddress, arrayMode);</span>
 826                 optimizationResult = OptimizationResult::Optimized;
 827             }
 828         }
 829 
 830         // If we failed to patch and we have some object that intercepts indexed get, then don&#39;t even wait until 10 times.
 831         if (optimizationResult != OptimizationResult::Optimized &amp;&amp; object-&gt;structure(vm)-&gt;typeInfo().interceptsGetOwnPropertySlotByIndexEvenWhenLengthIsNotZero())
 832             optimizationResult = OptimizationResult::GiveUp;
 833     } else if (isStringOrSymbol(subscript)) {
 834         const Identifier propertyName = subscript.toPropertyKey(exec);

 835         if (subscript.isSymbol() || !parseIndex(propertyName)) {
 836             ASSERT(exec-&gt;bytecodeOffset());
 837             ASSERT(!byValInfo-&gt;stubRoutine);
 838             if (byValInfo-&gt;seen) {
 839                 if (byValInfo-&gt;cachedId == propertyName) {
<span class="line-modified"> 840                     JIT::compilePutByValWithCachedId&lt;OpPutByValDirect&gt;(&amp;vm, exec-&gt;codeBlock(), byValInfo, returnAddress, Direct, propertyName);</span>
 841                     optimizationResult = OptimizationResult::Optimized;
 842                 } else {
 843                     // Seem like a generic property access site.
 844                     optimizationResult = OptimizationResult::GiveUp;
 845                 }
 846             } else {
 847                 CodeBlock* codeBlock = exec-&gt;codeBlock();
 848                 ConcurrentJSLocker locker(codeBlock-&gt;m_lock);
 849                 byValInfo-&gt;seen = true;
 850                 byValInfo-&gt;cachedId = propertyName;
 851                 if (subscript.isSymbol())
 852                     byValInfo-&gt;cachedSymbol.set(vm, codeBlock, asSymbol(subscript));
 853                 optimizationResult = OptimizationResult::SeenOnce;
 854             }
 855         }
 856     }
 857 
 858     if (optimizationResult != OptimizationResult::Optimized &amp;&amp; optimizationResult != OptimizationResult::SeenOnce) {
 859         // If we take slow path more than 10 times without patching then make sure we
 860         // never make that mistake again. For cases where we see non-index-intercepting
 861         // objects, this gives 10 iterations worth of opportunity for us to observe
 862         // that the get_by_val may be polymorphic. We count up slowPathCount even if
 863         // the result is GiveUp.
 864         if (++byValInfo-&gt;slowPathCount &gt;= 10)
 865             optimizationResult = OptimizationResult::GiveUp;
 866     }
 867 
 868     return optimizationResult;
 869 }
 870 
 871 void JIT_OPERATION operationDirectPutByValOptimize(ExecState* exec, EncodedJSValue encodedBaseValue, EncodedJSValue encodedSubscript, EncodedJSValue encodedValue, ByValInfo* byValInfo)
 872 {
 873     VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 874     NativeCallFrameTracer tracer(&amp;vm, exec);</span>

 875 
 876     JSValue baseValue = JSValue::decode(encodedBaseValue);
 877     JSValue subscript = JSValue::decode(encodedSubscript);
 878     JSValue value = JSValue::decode(encodedValue);
 879     RELEASE_ASSERT(baseValue.isObject());
 880     JSObject* object = asObject(baseValue);
<span class="line-modified"> 881     if (tryDirectPutByValOptimize(exec, object, subscript, byValInfo, ReturnAddressPtr(OUR_RETURN_ADDRESS)) == OptimizationResult::GiveUp) {</span>


 882         // Don&#39;t ever try to optimize.
 883         byValInfo-&gt;tookSlowPath = true;
 884         ctiPatchCallByReturnAddress(ReturnAddressPtr(OUR_RETURN_ADDRESS), operationDirectPutByValGeneric);
 885     }
 886 
<span class="line-modified"> 887     directPutByVal(exec, object, subscript, value, byValInfo);</span>
 888 }
 889 
 890 void JIT_OPERATION operationPutByValGeneric(ExecState* exec, EncodedJSValue encodedBaseValue, EncodedJSValue encodedSubscript, EncodedJSValue encodedValue, ByValInfo* byValInfo)
 891 {
 892     VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 893     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
 894 
 895     JSValue baseValue = JSValue::decode(encodedBaseValue);
 896     JSValue subscript = JSValue::decode(encodedSubscript);
 897     JSValue value = JSValue::decode(encodedValue);
 898 
 899     putByVal(exec, baseValue, subscript, value, byValInfo);
 900 }
 901 
 902 
 903 void JIT_OPERATION operationDirectPutByValGeneric(ExecState* exec, EncodedJSValue encodedBaseValue, EncodedJSValue encodedSubscript, EncodedJSValue encodedValue, ByValInfo* byValInfo)
 904 {
 905     VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 906     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
 907 
 908     JSValue baseValue = JSValue::decode(encodedBaseValue);
 909     JSValue subscript = JSValue::decode(encodedSubscript);
 910     JSValue value = JSValue::decode(encodedValue);
 911     RELEASE_ASSERT(baseValue.isObject());
 912     directPutByVal(exec, asObject(baseValue), subscript, value, byValInfo);
 913 }
 914 
 915 EncodedJSValue JIT_OPERATION operationCallEval(ExecState* exec, ExecState* execCallee)
 916 {
<span class="line-modified"> 917     VM* vm = &amp;exec-&gt;vm();</span>
<span class="line-modified"> 918     auto scope = DECLARE_THROW_SCOPE(*vm);</span>
 919 
 920     execCallee-&gt;setCodeBlock(0);
 921 
 922     if (!isHostFunction(execCallee-&gt;guaranteedJSValueCallee(), globalFuncEval))
 923         return JSValue::encode(JSValue());
 924 
 925     JSValue result = eval(execCallee);
 926     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 927 
 928     return JSValue::encode(result);
 929 }
 930 
 931 static SlowPathReturnType handleHostCall(ExecState* execCallee, JSValue callee, CallLinkInfo* callLinkInfo)
 932 {
 933     ExecState* exec = execCallee-&gt;callerFrame();
<span class="line-modified"> 934     VM* vm = &amp;exec-&gt;vm();</span>
<span class="line-modified"> 935     auto scope = DECLARE_THROW_SCOPE(*vm);</span>
 936 
 937     execCallee-&gt;setCodeBlock(0);
 938 
 939     if (callLinkInfo-&gt;specializationKind() == CodeForCall) {
 940         CallData callData;
<span class="line-modified"> 941         CallType callType = getCallData(*vm, callee, callData);</span>
 942 
 943         ASSERT(callType != CallType::JS);
 944 
 945         if (callType == CallType::Host) {
 946             NativeCallFrameTracer tracer(vm, execCallee);
 947             execCallee-&gt;setCallee(asObject(callee));
<span class="line-modified"> 948             vm-&gt;hostCallReturnValue = JSValue::decode(callData.native.function(execCallee));</span>
 949             if (UNLIKELY(scope.exception())) {
 950                 return encodeResult(
<span class="line-modified"> 951                     vm-&gt;getCTIStub(throwExceptionFromCallSlowPathGenerator).retaggedCode&lt;JSEntryPtrTag&gt;().executableAddress(),</span>
 952                     reinterpret_cast&lt;void*&gt;(KeepTheFrame));
 953             }
 954 
 955             return encodeResult(
 956                 tagCFunctionPtr&lt;void*, JSEntryPtrTag&gt;(getHostCallReturnValue),
 957                 reinterpret_cast&lt;void*&gt;(callLinkInfo-&gt;callMode() == CallMode::Tail ? ReuseTheFrame : KeepTheFrame));
 958         }
 959 
 960         ASSERT(callType == CallType::None);
 961         throwException(exec, scope, createNotAFunctionError(exec, callee));
 962         return encodeResult(
<span class="line-modified"> 963             vm-&gt;getCTIStub(throwExceptionFromCallSlowPathGenerator).retaggedCode&lt;JSEntryPtrTag&gt;().executableAddress(),</span>
 964             reinterpret_cast&lt;void*&gt;(KeepTheFrame));
 965     }
 966 
 967     ASSERT(callLinkInfo-&gt;specializationKind() == CodeForConstruct);
 968 
 969     ConstructData constructData;
<span class="line-modified"> 970     ConstructType constructType = getConstructData(*vm, callee, constructData);</span>
 971 
 972     ASSERT(constructType != ConstructType::JS);
 973 
 974     if (constructType == ConstructType::Host) {
 975         NativeCallFrameTracer tracer(vm, execCallee);
 976         execCallee-&gt;setCallee(asObject(callee));
<span class="line-modified"> 977         vm-&gt;hostCallReturnValue = JSValue::decode(constructData.native.function(execCallee));</span>
 978         if (UNLIKELY(scope.exception())) {
 979             return encodeResult(
<span class="line-modified"> 980                 vm-&gt;getCTIStub(throwExceptionFromCallSlowPathGenerator).retaggedCode&lt;JSEntryPtrTag&gt;().executableAddress(),</span>
 981                 reinterpret_cast&lt;void*&gt;(KeepTheFrame));
 982         }
 983 
 984         return encodeResult(tagCFunctionPtr&lt;void*, JSEntryPtrTag&gt;(getHostCallReturnValue), reinterpret_cast&lt;void*&gt;(KeepTheFrame));
 985     }
 986 
 987     ASSERT(constructType == ConstructType::None);
 988     throwException(exec, scope, createNotAConstructorError(exec, callee));
 989     return encodeResult(
<span class="line-modified"> 990         vm-&gt;getCTIStub(throwExceptionFromCallSlowPathGenerator).retaggedCode&lt;JSEntryPtrTag&gt;().executableAddress(),</span>
 991         reinterpret_cast&lt;void*&gt;(KeepTheFrame));
 992 }
 993 
 994 SlowPathReturnType JIT_OPERATION operationLinkCall(ExecState* execCallee, CallLinkInfo* callLinkInfo)
 995 {
 996     ExecState* exec = execCallee-&gt;callerFrame();
<span class="line-modified"> 997     VM* vm = &amp;exec-&gt;vm();</span>
<span class="line-modified"> 998     auto throwScope = DECLARE_THROW_SCOPE(*vm);</span>
 999 
1000     CodeSpecializationKind kind = callLinkInfo-&gt;specializationKind();
1001     NativeCallFrameTracer tracer(vm, exec);
1002 
1003     RELEASE_ASSERT(!callLinkInfo-&gt;isDirect());
1004 
1005     JSValue calleeAsValue = execCallee-&gt;guaranteedJSValueCallee();
1006     JSCell* calleeAsFunctionCell = getJSFunction(calleeAsValue);
1007     if (!calleeAsFunctionCell) {
<span class="line-modified">1008         if (auto* internalFunction = jsDynamicCast&lt;InternalFunction*&gt;(*vm, calleeAsValue)) {</span>
<span class="line-modified">1009             MacroAssemblerCodePtr&lt;JSEntryPtrTag&gt; codePtr = vm-&gt;getCTIInternalFunctionTrampolineFor(kind);</span>
1010             RELEASE_ASSERT(!!codePtr);
1011 
1012             if (!callLinkInfo-&gt;seenOnce())
1013                 callLinkInfo-&gt;setSeen();
1014             else
1015                 linkFor(execCallee, *callLinkInfo, nullptr, internalFunction, codePtr);
1016 
1017             void* linkedTarget = codePtr.executableAddress();
1018             return encodeResult(linkedTarget, reinterpret_cast&lt;void*&gt;(callLinkInfo-&gt;callMode() == CallMode::Tail ? ReuseTheFrame : KeepTheFrame));
1019         }
1020         RELEASE_AND_RETURN(throwScope, handleHostCall(execCallee, calleeAsValue, callLinkInfo));
1021     }
1022 
1023     JSFunction* callee = jsCast&lt;JSFunction*&gt;(calleeAsFunctionCell);
1024     JSScope* scope = callee-&gt;scopeUnchecked();
1025     ExecutableBase* executable = callee-&gt;executable();
1026 
1027     MacroAssemblerCodePtr&lt;JSEntryPtrTag&gt; codePtr;
1028     CodeBlock* codeBlock = nullptr;
<span class="line-modified">1029     if (executable-&gt;isHostFunction())</span>
<span class="line-modified">1030         codePtr = executable-&gt;entrypointFor(kind, MustCheckArity);</span>
<span class="line-modified">1031     else {</span>


1032         FunctionExecutable* functionExecutable = static_cast&lt;FunctionExecutable*&gt;(executable);
1033 
1034         auto handleThrowException = [&amp;] () {
<span class="line-modified">1035             void* throwTarget = vm-&gt;getCTIStub(throwExceptionFromCallSlowPathGenerator).retaggedCode&lt;JSEntryPtrTag&gt;().executableAddress();</span>
1036             return encodeResult(throwTarget, reinterpret_cast&lt;void*&gt;(KeepTheFrame));
1037         };
1038 
1039         if (!isCall(kind) &amp;&amp; functionExecutable-&gt;constructAbility() == ConstructAbility::CannotConstruct) {
1040             throwException(exec, throwScope, createNotAConstructorError(exec, callee));
1041             return handleThrowException();
1042         }
1043 
1044         CodeBlock** codeBlockSlot = execCallee-&gt;addressOfCodeBlock();
<span class="line-modified">1045         JSObject* error = functionExecutable-&gt;prepareForExecution&lt;FunctionExecutable&gt;(*vm, callee, scope, kind, *codeBlockSlot);</span>
<span class="line-modified">1046         EXCEPTION_ASSERT(throwScope.exception() == reinterpret_cast&lt;Exception*&gt;(error));</span>
<span class="line-modified">1047         if (error)</span>
1048             return handleThrowException();
1049         codeBlock = *codeBlockSlot;
1050         ArityCheckMode arity;
1051         if (execCallee-&gt;argumentCountIncludingThis() &lt; static_cast&lt;size_t&gt;(codeBlock-&gt;numParameters()) || callLinkInfo-&gt;isVarargs())
1052             arity = MustCheckArity;
1053         else
1054             arity = ArityCheckNotRequired;
1055         codePtr = functionExecutable-&gt;entrypointFor(kind, arity);
1056     }

1057     if (!callLinkInfo-&gt;seenOnce())
1058         callLinkInfo-&gt;setSeen();
1059     else
1060         linkFor(execCallee, *callLinkInfo, codeBlock, callee, codePtr);
1061 
1062     return encodeResult(codePtr.executableAddress(), reinterpret_cast&lt;void*&gt;(callLinkInfo-&gt;callMode() == CallMode::Tail ? ReuseTheFrame : KeepTheFrame));
1063 }
1064 
1065 void JIT_OPERATION operationLinkDirectCall(ExecState* exec, CallLinkInfo* callLinkInfo, JSFunction* callee)
1066 {
<span class="line-modified">1067     VM* vm = &amp;exec-&gt;vm();</span>
<span class="line-modified">1068     auto throwScope = DECLARE_THROW_SCOPE(*vm);</span>
1069 
1070     CodeSpecializationKind kind = callLinkInfo-&gt;specializationKind();
1071     NativeCallFrameTracer tracer(vm, exec);
1072 
1073     RELEASE_ASSERT(callLinkInfo-&gt;isDirect());
1074 
1075     // This would happen if the executable died during GC but the CodeBlock did not die. That should
1076     // not happen because the CodeBlock should have a weak reference to any executable it uses for
1077     // this purpose.
1078     RELEASE_ASSERT(callLinkInfo-&gt;executable());
1079 
1080     // Having a CodeBlock indicates that this is linked. We shouldn&#39;t be taking this path if it&#39;s
1081     // linked.
1082     RELEASE_ASSERT(!callLinkInfo-&gt;codeBlock());
1083 
1084     // We just don&#39;t support this yet.
1085     RELEASE_ASSERT(!callLinkInfo-&gt;isVarargs());
1086 
1087     ExecutableBase* executable = callLinkInfo-&gt;executable();
1088     RELEASE_ASSERT(callee-&gt;executable() == callLinkInfo-&gt;executable());
1089 
1090     JSScope* scope = callee-&gt;scopeUnchecked();
1091 
1092     MacroAssemblerCodePtr&lt;JSEntryPtrTag&gt; codePtr;
1093     CodeBlock* codeBlock = nullptr;
1094     if (executable-&gt;isHostFunction())
1095         codePtr = executable-&gt;entrypointFor(kind, MustCheckArity);
1096     else {
1097         FunctionExecutable* functionExecutable = static_cast&lt;FunctionExecutable*&gt;(executable);
1098 
1099         RELEASE_ASSERT(isCall(kind) || functionExecutable-&gt;constructAbility() != ConstructAbility::CannotConstruct);
1100 
<span class="line-modified">1101         JSObject* error = functionExecutable-&gt;prepareForExecution&lt;FunctionExecutable&gt;(*vm, callee, scope, kind, codeBlock);</span>
<span class="line-modified">1102         EXCEPTION_ASSERT_UNUSED(throwScope, throwScope.exception() == reinterpret_cast&lt;Exception*&gt;(error));</span>
<span class="line-modified">1103         if (error)</span>
1104             return;
1105         unsigned argumentStackSlots = callLinkInfo-&gt;maxNumArguments();
1106         if (argumentStackSlots &lt; static_cast&lt;size_t&gt;(codeBlock-&gt;numParameters()))
1107             codePtr = functionExecutable-&gt;entrypointFor(kind, MustCheckArity);
1108         else
1109             codePtr = functionExecutable-&gt;entrypointFor(kind, ArityCheckNotRequired);
1110     }
1111 
1112     linkDirectFor(exec, *callLinkInfo, codeBlock, codePtr);
1113 }
1114 
1115 inline SlowPathReturnType virtualForWithFunction(
1116     ExecState* execCallee, CallLinkInfo* callLinkInfo, JSCell*&amp; calleeAsFunctionCell)
1117 {
1118     ExecState* exec = execCallee-&gt;callerFrame();
<span class="line-modified">1119     VM* vm = &amp;exec-&gt;vm();</span>
<span class="line-modified">1120     auto throwScope = DECLARE_THROW_SCOPE(*vm);</span>
1121 
1122     CodeSpecializationKind kind = callLinkInfo-&gt;specializationKind();
1123     NativeCallFrameTracer tracer(vm, exec);
1124 
1125     JSValue calleeAsValue = execCallee-&gt;guaranteedJSValueCallee();
1126     calleeAsFunctionCell = getJSFunction(calleeAsValue);
1127     if (UNLIKELY(!calleeAsFunctionCell)) {
<span class="line-modified">1128         if (jsDynamicCast&lt;InternalFunction*&gt;(*vm, calleeAsValue)) {</span>
<span class="line-modified">1129             MacroAssemblerCodePtr&lt;JSEntryPtrTag&gt; codePtr = vm-&gt;getCTIInternalFunctionTrampolineFor(kind);</span>
1130             ASSERT(!!codePtr);
1131             return encodeResult(codePtr.executableAddress(), reinterpret_cast&lt;void*&gt;(callLinkInfo-&gt;callMode() == CallMode::Tail ? ReuseTheFrame : KeepTheFrame));
1132         }
1133         RELEASE_AND_RETURN(throwScope, handleHostCall(execCallee, calleeAsValue, callLinkInfo));
1134     }
1135 
1136     JSFunction* function = jsCast&lt;JSFunction*&gt;(calleeAsFunctionCell);
1137     JSScope* scope = function-&gt;scopeUnchecked();
1138     ExecutableBase* executable = function-&gt;executable();
1139     if (UNLIKELY(!executable-&gt;hasJITCodeFor(kind))) {
1140         FunctionExecutable* functionExecutable = static_cast&lt;FunctionExecutable*&gt;(executable);
1141 
1142         if (!isCall(kind) &amp;&amp; functionExecutable-&gt;constructAbility() == ConstructAbility::CannotConstruct) {
1143             throwException(exec, throwScope, createNotAConstructorError(exec, function));
1144             return encodeResult(
<span class="line-modified">1145                 vm-&gt;getCTIStub(throwExceptionFromCallSlowPathGenerator).retaggedCode&lt;JSEntryPtrTag&gt;().executableAddress(),</span>
1146                 reinterpret_cast&lt;void*&gt;(KeepTheFrame));
1147         }
1148 
1149         CodeBlock** codeBlockSlot = execCallee-&gt;addressOfCodeBlock();
<span class="line-modified">1150         JSObject* error = functionExecutable-&gt;prepareForExecution&lt;FunctionExecutable&gt;(*vm, function, scope, kind, *codeBlockSlot);</span>
<span class="line-modified">1151         EXCEPTION_ASSERT(throwScope.exception() == reinterpret_cast&lt;Exception*&gt;(error));</span>
<span class="line-modified">1152         if (error) {</span>
1153             return encodeResult(
<span class="line-modified">1154                 vm-&gt;getCTIStub(throwExceptionFromCallSlowPathGenerator).retaggedCode&lt;JSEntryPtrTag&gt;().executableAddress(),</span>
1155                 reinterpret_cast&lt;void*&gt;(KeepTheFrame));
1156         }
1157     }
1158     return encodeResult(executable-&gt;entrypointFor(
1159         kind, MustCheckArity).executableAddress(),
1160         reinterpret_cast&lt;void*&gt;(callLinkInfo-&gt;callMode() == CallMode::Tail ? ReuseTheFrame : KeepTheFrame));
1161 }
1162 
1163 SlowPathReturnType JIT_OPERATION operationLinkPolymorphicCall(ExecState* execCallee, CallLinkInfo* callLinkInfo)
1164 {
1165     ASSERT(callLinkInfo-&gt;specializationKind() == CodeForCall);
1166     JSCell* calleeAsFunctionCell;
1167     SlowPathReturnType result = virtualForWithFunction(execCallee, callLinkInfo, calleeAsFunctionCell);
1168 
1169     linkPolymorphicCall(execCallee, *callLinkInfo, CallVariant(calleeAsFunctionCell));
1170 
1171     return result;
1172 }
1173 
1174 SlowPathReturnType JIT_OPERATION operationVirtualCall(ExecState* execCallee, CallLinkInfo* callLinkInfo)
1175 {
1176     JSCell* calleeAsFunctionCellIgnored;
1177     return virtualForWithFunction(execCallee, callLinkInfo, calleeAsFunctionCellIgnored);
1178 }
1179 
1180 size_t JIT_OPERATION operationCompareLess(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)
1181 {
<span class="line-modified">1182     VM* vm = &amp;exec-&gt;vm();</span>
1183     NativeCallFrameTracer tracer(vm, exec);
1184 
1185     return jsLess&lt;true&gt;(exec, JSValue::decode(encodedOp1), JSValue::decode(encodedOp2));
1186 }
1187 
1188 size_t JIT_OPERATION operationCompareLessEq(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)
1189 {
<span class="line-modified">1190     VM* vm = &amp;exec-&gt;vm();</span>
1191     NativeCallFrameTracer tracer(vm, exec);
1192 
1193     return jsLessEq&lt;true&gt;(exec, JSValue::decode(encodedOp1), JSValue::decode(encodedOp2));
1194 }
1195 
1196 size_t JIT_OPERATION operationCompareGreater(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)
1197 {
<span class="line-modified">1198     VM* vm = &amp;exec-&gt;vm();</span>
1199     NativeCallFrameTracer tracer(vm, exec);
1200 
1201     return jsLess&lt;false&gt;(exec, JSValue::decode(encodedOp2), JSValue::decode(encodedOp1));
1202 }
1203 
1204 size_t JIT_OPERATION operationCompareGreaterEq(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)
1205 {
<span class="line-modified">1206     VM* vm = &amp;exec-&gt;vm();</span>
1207     NativeCallFrameTracer tracer(vm, exec);
1208 
1209     return jsLessEq&lt;false&gt;(exec, JSValue::decode(encodedOp2), JSValue::decode(encodedOp1));
1210 }
1211 
1212 size_t JIT_OPERATION operationCompareEq(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)
1213 {
<span class="line-modified">1214     VM* vm = &amp;exec-&gt;vm();</span>
1215     NativeCallFrameTracer tracer(vm, exec);
1216 
1217     return JSValue::equalSlowCaseInline(exec, JSValue::decode(encodedOp1), JSValue::decode(encodedOp2));
1218 }
1219 
1220 #if USE(JSVALUE64)
1221 EncodedJSValue JIT_OPERATION operationCompareStringEq(ExecState* exec, JSCell* left, JSCell* right)
1222 #else
1223 size_t JIT_OPERATION operationCompareStringEq(ExecState* exec, JSCell* left, JSCell* right)
1224 #endif
1225 {
<span class="line-modified">1226     VM* vm = &amp;exec-&gt;vm();</span>
1227     NativeCallFrameTracer tracer(vm, exec);
1228 
1229     bool result = asString(left)-&gt;equal(exec, asString(right));
1230 #if USE(JSVALUE64)
1231     return JSValue::encode(jsBoolean(result));
1232 #else
1233     return result;
1234 #endif
1235 }
1236 
1237 size_t JIT_OPERATION operationCompareStrictEq(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)
1238 {
<span class="line-modified">1239     VM* vm = &amp;exec-&gt;vm();</span>
1240     NativeCallFrameTracer tracer(vm, exec);
1241 
1242     JSValue src1 = JSValue::decode(encodedOp1);
1243     JSValue src2 = JSValue::decode(encodedOp2);
1244 
1245     return JSValue::strictEqual(exec, src1, src2);
1246 }
1247 
1248 EncodedJSValue JIT_OPERATION operationNewArrayWithProfile(ExecState* exec, ArrayAllocationProfile* profile, const JSValue* values, int size)
1249 {
<span class="line-modified">1250     VM* vm = &amp;exec-&gt;vm();</span>
1251     NativeCallFrameTracer tracer(vm, exec);
1252     return JSValue::encode(constructArrayNegativeIndexed(exec, profile, values, size));
1253 }
1254 
1255 EncodedJSValue JIT_OPERATION operationNewArrayWithSizeAndProfile(ExecState* exec, ArrayAllocationProfile* profile, EncodedJSValue size)
1256 {
<span class="line-modified">1257     VM* vm = &amp;exec-&gt;vm();</span>
1258     NativeCallFrameTracer tracer(vm, exec);
1259     JSValue sizeValue = JSValue::decode(size);
1260     return JSValue::encode(constructArrayWithSizeQuirk(exec, profile, exec-&gt;lexicalGlobalObject(), sizeValue));
1261 }
1262 
1263 }
1264 
1265 template&lt;typename FunctionType&gt;
1266 static EncodedJSValue operationNewFunctionCommon(ExecState* exec, JSScope* scope, JSCell* functionExecutable, bool isInvalidated)
1267 {
1268     VM&amp; vm = exec-&gt;vm();
1269     ASSERT(functionExecutable-&gt;inherits&lt;FunctionExecutable&gt;(vm));
<span class="line-modified">1270     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
1271     if (isInvalidated)
1272         return JSValue::encode(FunctionType::createWithInvalidatedReallocationWatchpoint(vm, static_cast&lt;FunctionExecutable*&gt;(functionExecutable), scope));
1273     return JSValue::encode(FunctionType::create(vm, static_cast&lt;FunctionExecutable*&gt;(functionExecutable), scope));
1274 }
1275 
1276 extern &quot;C&quot; {
1277 
1278 EncodedJSValue JIT_OPERATION operationNewFunction(ExecState* exec, JSScope* scope, JSCell* functionExecutable)
1279 {
1280     return operationNewFunctionCommon&lt;JSFunction&gt;(exec, scope, functionExecutable, false);
1281 }
1282 
1283 EncodedJSValue JIT_OPERATION operationNewFunctionWithInvalidatedReallocationWatchpoint(ExecState* exec, JSScope* scope, JSCell* functionExecutable)
1284 {
1285     return operationNewFunctionCommon&lt;JSFunction&gt;(exec, scope, functionExecutable, true);
1286 }
1287 
1288 EncodedJSValue JIT_OPERATION operationNewGeneratorFunction(ExecState* exec, JSScope* scope, JSCell* functionExecutable)
1289 {
1290     return operationNewFunctionCommon&lt;JSGeneratorFunction&gt;(exec, scope, functionExecutable, false);
</pre>
<hr />
<pre>
1300     return operationNewFunctionCommon&lt;JSAsyncFunction&gt;(exec, scope, functionExecutable, false);
1301 }
1302 
1303 EncodedJSValue JIT_OPERATION operationNewAsyncFunctionWithInvalidatedReallocationWatchpoint(ExecState* exec, JSScope* scope, JSCell* functionExecutable)
1304 {
1305     return operationNewFunctionCommon&lt;JSAsyncFunction&gt;(exec, scope, functionExecutable, true);
1306 }
1307 
1308 EncodedJSValue JIT_OPERATION operationNewAsyncGeneratorFunction(ExecState* exec, JSScope* scope, JSCell* functionExecutable)
1309 {
1310     return operationNewFunctionCommon&lt;JSAsyncGeneratorFunction&gt;(exec, scope, functionExecutable, false);
1311 }
1312 
1313 EncodedJSValue JIT_OPERATION operationNewAsyncGeneratorFunctionWithInvalidatedReallocationWatchpoint(ExecState* exec, JSScope* scope, JSCell* functionExecutable)
1314 {
1315     return operationNewFunctionCommon&lt;JSAsyncGeneratorFunction&gt;(exec, scope, functionExecutable, true);
1316 }
1317 
1318 void JIT_OPERATION operationSetFunctionName(ExecState* exec, JSCell* funcCell, EncodedJSValue encodedName)
1319 {
<span class="line-modified">1320     VM* vm = &amp;exec-&gt;vm();</span>
1321     NativeCallFrameTracer tracer(vm, exec);
1322 
1323     JSFunction* func = jsCast&lt;JSFunction*&gt;(funcCell);
1324     JSValue name = JSValue::decode(encodedName);
1325     func-&gt;setFunctionName(exec, name);
1326 }
1327 
1328 JSCell* JIT_OPERATION operationNewObject(ExecState* exec, Structure* structure)
1329 {
<span class="line-modified">1330     VM* vm = &amp;exec-&gt;vm();</span>
1331     NativeCallFrameTracer tracer(vm, exec);
1332 
1333     return constructEmptyObject(exec, structure);
1334 }
1335 
1336 JSCell* JIT_OPERATION operationNewRegexp(ExecState* exec, JSCell* regexpPtr)
1337 {
1338     SuperSamplerScope superSamplerScope(false);
1339     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1340     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
1341 
1342     RegExp* regexp = static_cast&lt;RegExp*&gt;(regexpPtr);
1343     ASSERT(regexp-&gt;isValid());
1344     return RegExpObject::create(vm, exec-&gt;lexicalGlobalObject()-&gt;regExpStructure(), regexp);
1345 }
1346 
1347 // The only reason for returning an UnusedPtr (instead of void) is so that we can reuse the
1348 // existing DFG slow path generator machinery when creating the slow path for CheckTraps
1349 // in the DFG. If a DFG slow path generator that supports a void return type is added in the
1350 // future, we can switch to using that then.
1351 UnusedPtr JIT_OPERATION operationHandleTraps(ExecState* exec)
1352 {
1353     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1354     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
1355     ASSERT(vm.needTrapHandling());
1356     vm.handleTraps(exec);
1357     return nullptr;
1358 }
1359 
1360 void JIT_OPERATION operationDebug(ExecState* exec, int32_t debugHookType)
1361 {
1362     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1363     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
1364 
1365     vm.interpreter-&gt;debug(exec, static_cast&lt;DebugHookType&gt;(debugHookType));
1366 }
1367 
1368 #if ENABLE(DFG_JIT)
1369 static void updateAllPredictionsAndOptimizeAfterWarmUp(CodeBlock* codeBlock)
1370 {
1371     codeBlock-&gt;updateAllPredictions();
1372     codeBlock-&gt;optimizeAfterWarmUp();
1373 }
1374 
1375 SlowPathReturnType JIT_OPERATION operationOptimize(ExecState* exec, uint32_t bytecodeIndex)
1376 {
1377     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1378     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
1379 
1380     // Defer GC for a while so that it doesn&#39;t run between when we enter into this
1381     // slow path and when we figure out the state of our code block. This prevents
1382     // a number of awkward reentrancy scenarios, including:
1383     //
1384     // - The optimized version of our code block being jettisoned by GC right after
1385     //   we concluded that we wanted to use it, but have not planted it into the JS
1386     //   stack yet.
1387     //
1388     // - An optimized version of our code block being installed just as we decided
1389     //   that it wasn&#39;t ready yet.
1390     //
1391     // Note that jettisoning won&#39;t happen if we already initiated OSR, because in
1392     // that case we would have already planted the optimized code block into the JS
1393     // stack.
1394     DeferGCForAWhile deferGC(vm.heap);
1395 
1396     CodeBlock* codeBlock = exec-&gt;codeBlock();
<span class="line-modified">1397     if (UNLIKELY(codeBlock-&gt;jitType() != JITCode::BaselineJIT)) {</span>
1398         dataLog(&quot;Unexpected code block in Baseline-&gt;DFG tier-up: &quot;, *codeBlock, &quot;\n&quot;);
1399         RELEASE_ASSERT_NOT_REACHED();
1400     }
1401 
1402     if (bytecodeIndex) {
1403         // If we&#39;re attempting to OSR from a loop, assume that this should be
1404         // separately optimized.
1405         codeBlock-&gt;m_shouldAlwaysBeInlined = false;
1406     }
1407 
1408     if (UNLIKELY(Options::verboseOSR())) {
1409         dataLog(
1410             *codeBlock, &quot;: Entered optimize with bytecodeIndex = &quot;, bytecodeIndex,
1411             &quot;, executeCounter = &quot;, codeBlock-&gt;jitExecuteCounter(),
1412             &quot;, optimizationDelayCounter = &quot;, codeBlock-&gt;reoptimizationRetryCounter(),
1413             &quot;, exitCounter = &quot;);
1414         if (codeBlock-&gt;hasOptimizedReplacement())
1415             dataLog(codeBlock-&gt;replacement()-&gt;osrExitCounter());
1416         else
1417             dataLog(&quot;N/A&quot;);
</pre>
<hr />
<pre>
1603         if (UNLIKELY(Options::verboseOSR())) {
1604             dataLog(
1605                 &quot;Triggering reoptimization of &quot;, codeBlock, &quot; -&gt; &quot;,
1606                 codeBlock-&gt;replacement(), &quot; (after OSR fail).\n&quot;);
1607         }
1608         optimizedCodeBlock-&gt;jettison(Profiler::JettisonDueToBaselineLoopReoptimizationTriggerOnOSREntryFail, CountReoptimization);
1609         return encodeResult(0, 0);
1610     }
1611 
1612     // OSR failed this time, but it might succeed next time! Let the code run a bit
1613     // longer and then try again.
1614     codeBlock-&gt;optimizeAfterWarmUp();
1615 
1616     CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayOptimizeToDFG&quot;, (&quot;OSR failed&quot;));
1617     return encodeResult(0, 0);
1618 }
1619 
1620 char* JIT_OPERATION operationTryOSREnterAtCatch(ExecState* exec, uint32_t bytecodeIndex)
1621 {
1622     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1623     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
1624 
1625     CodeBlock* optimizedReplacement = exec-&gt;codeBlock()-&gt;replacement();
1626     if (UNLIKELY(!optimizedReplacement))
1627         return nullptr;
1628 
1629     switch (optimizedReplacement-&gt;jitType()) {
<span class="line-modified">1630     case JITCode::DFGJIT:</span>
<span class="line-modified">1631     case JITCode::FTLJIT: {</span>
1632         MacroAssemblerCodePtr&lt;ExceptionHandlerPtrTag&gt; entry = DFG::prepareCatchOSREntry(exec, optimizedReplacement, bytecodeIndex);
1633         return entry.executableAddress&lt;char*&gt;();
1634     }
1635     default:
1636         break;
1637     }
1638     return nullptr;
1639 }
1640 
1641 char* JIT_OPERATION operationTryOSREnterAtCatchAndValueProfile(ExecState* exec, uint32_t bytecodeIndex)
1642 {
1643     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1644     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
1645 
1646     CodeBlock* codeBlock = exec-&gt;codeBlock();
1647     CodeBlock* optimizedReplacement = codeBlock-&gt;replacement();
1648     if (UNLIKELY(!optimizedReplacement))
1649         return nullptr;
1650 
1651     switch (optimizedReplacement-&gt;jitType()) {
<span class="line-modified">1652     case JITCode::DFGJIT:</span>
<span class="line-modified">1653     case JITCode::FTLJIT: {</span>
1654         MacroAssemblerCodePtr&lt;ExceptionHandlerPtrTag&gt; entry = DFG::prepareCatchOSREntry(exec, optimizedReplacement, bytecodeIndex);
1655         return entry.executableAddress&lt;char*&gt;();
1656     }
1657     default:
1658         break;
1659     }
1660 
1661     codeBlock-&gt;ensureCatchLivenessIsComputedForBytecodeOffset(bytecodeIndex);
1662     auto bytecode = codeBlock-&gt;instructions().at(bytecodeIndex)-&gt;as&lt;OpCatch&gt;();
1663     auto&amp; metadata = bytecode.metadata(codeBlock);
1664     metadata.m_buffer-&gt;forEach([&amp;] (ValueProfileAndOperand&amp; profile) {
<span class="line-modified">1665         profile.m_profile.m_buckets[0] = JSValue::encode(exec-&gt;uncheckedR(profile.m_operand).jsValue());</span>
1666     });
1667 
1668     return nullptr;
1669 }
1670 
1671 #endif
1672 
1673 void JIT_OPERATION operationPutByIndex(ExecState* exec, EncodedJSValue encodedArrayValue, int32_t index, EncodedJSValue encodedValue)
1674 {
1675     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1676     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
1677 
1678     JSValue arrayValue = JSValue::decode(encodedArrayValue);
1679     ASSERT(isJSArray(arrayValue));
1680     asArray(arrayValue)-&gt;putDirectIndex(exec, index, JSValue::decode(encodedValue));
1681 }
1682 
1683 enum class AccessorType {
1684     Getter,
1685     Setter
1686 };
1687 
1688 static void putAccessorByVal(ExecState* exec, JSObject* base, JSValue subscript, int32_t attribute, JSObject* accessor, AccessorType accessorType)
1689 {
1690     VM&amp; vm = exec-&gt;vm();
1691     auto scope = DECLARE_THROW_SCOPE(vm);
1692     auto propertyKey = subscript.toPropertyKey(exec);
1693     RETURN_IF_EXCEPTION(scope, void());
1694 
1695     scope.release();
1696     if (accessorType == AccessorType::Getter)
1697         base-&gt;putGetter(exec, propertyKey, accessor, attribute);
1698     else
1699         base-&gt;putSetter(exec, propertyKey, accessor, attribute);
1700 }
1701 
1702 void JIT_OPERATION operationPutGetterById(ExecState* exec, JSCell* object, UniquedStringImpl* uid, int32_t options, JSCell* getter)
1703 {
1704     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1705     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
1706 
1707     ASSERT(object &amp;&amp; object-&gt;isObject());
1708     JSObject* baseObj = object-&gt;getObject();
1709 
1710     ASSERT(getter-&gt;isObject());
1711     baseObj-&gt;putGetter(exec, uid, getter, options);
1712 }
1713 
1714 void JIT_OPERATION operationPutSetterById(ExecState* exec, JSCell* object, UniquedStringImpl* uid, int32_t options, JSCell* setter)
1715 {
1716     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1717     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
1718 
1719     ASSERT(object &amp;&amp; object-&gt;isObject());
1720     JSObject* baseObj = object-&gt;getObject();
1721 
1722     ASSERT(setter-&gt;isObject());
1723     baseObj-&gt;putSetter(exec, uid, setter, options);
1724 }
1725 
1726 void JIT_OPERATION operationPutGetterByVal(ExecState* exec, JSCell* base, EncodedJSValue encodedSubscript, int32_t attribute, JSCell* getter)
1727 {
1728     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1729     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
1730 
1731     putAccessorByVal(exec, asObject(base), JSValue::decode(encodedSubscript), attribute, asObject(getter), AccessorType::Getter);
1732 }
1733 
1734 void JIT_OPERATION operationPutSetterByVal(ExecState* exec, JSCell* base, EncodedJSValue encodedSubscript, int32_t attribute, JSCell* setter)
1735 {
1736     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1737     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
1738 
1739     putAccessorByVal(exec, asObject(base), JSValue::decode(encodedSubscript), attribute, asObject(setter), AccessorType::Setter);
1740 }
1741 
1742 #if USE(JSVALUE64)
1743 void JIT_OPERATION operationPutGetterSetter(ExecState* exec, JSCell* object, UniquedStringImpl* uid, int32_t attribute, EncodedJSValue encodedGetterValue, EncodedJSValue encodedSetterValue)
1744 {
1745     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1746     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
1747 
1748     ASSERT(object &amp;&amp; object-&gt;isObject());
1749     JSObject* baseObject = asObject(object);
1750 
1751     JSValue getter = JSValue::decode(encodedGetterValue);
1752     JSValue setter = JSValue::decode(encodedSetterValue);
1753     ASSERT(getter.isObject() || setter.isObject());
1754     GetterSetter* accessor = GetterSetter::create(vm, exec-&gt;lexicalGlobalObject(), getter, setter);
1755     CommonSlowPaths::putDirectAccessorWithReify(vm, exec, baseObject, uid, accessor, attribute);
1756 }
1757 
1758 #else
1759 void JIT_OPERATION operationPutGetterSetter(ExecState* exec, JSCell* object, UniquedStringImpl* uid, int32_t attribute, JSCell* getterCell, JSCell* setterCell)
1760 {
1761     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1762     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
1763 
1764     ASSERT(object &amp;&amp; object-&gt;isObject());
1765     JSObject* baseObject = asObject(object);
1766 
1767     ASSERT(getterCell || setterCell);
1768     JSObject* getter = getterCell ? getterCell-&gt;getObject() : nullptr;
1769     JSObject* setter = setterCell ? setterCell-&gt;getObject() : nullptr;
1770     GetterSetter* accessor = GetterSetter::create(vm, exec-&gt;lexicalGlobalObject(), getter, setter);
1771     CommonSlowPaths::putDirectAccessorWithReify(vm, exec, baseObject, uid, accessor, attribute);
1772 }
1773 #endif
1774 
1775 void JIT_OPERATION operationPopScope(ExecState* exec, int32_t scopeReg)
1776 {
1777     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1778     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
1779 
1780     JSScope* scope = exec-&gt;uncheckedR(scopeReg).Register::scope();
1781     exec-&gt;uncheckedR(scopeReg) = scope-&gt;next();
1782 }
1783 
1784 int32_t JIT_OPERATION operationInstanceOfCustom(ExecState* exec, EncodedJSValue encodedValue, JSObject* constructor, EncodedJSValue encodedHasInstance)
1785 {
1786     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1787     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
1788 
1789     JSValue value = JSValue::decode(encodedValue);
1790     JSValue hasInstanceValue = JSValue::decode(encodedHasInstance);
1791 
<span class="line-removed">1792     ASSERT(hasInstanceValue != exec-&gt;lexicalGlobalObject()-&gt;functionProtoHasInstanceSymbolFunction() || !constructor-&gt;structure(vm)-&gt;typeInfo().implementsDefaultHasInstance());</span>
<span class="line-removed">1793 </span>
1794     if (constructor-&gt;hasInstance(exec, value, hasInstanceValue))
1795         return 1;
1796     return 0;
1797 }
1798 
1799 }
1800 
1801 static JSValue getByVal(ExecState* exec, JSValue baseValue, JSValue subscript, ByValInfo* byValInfo, ReturnAddressPtr returnAddress)
1802 {
1803     VM&amp; vm = exec-&gt;vm();
1804     auto scope = DECLARE_THROW_SCOPE(vm);
1805 
1806     if (LIKELY(baseValue.isCell() &amp;&amp; subscript.isString())) {
1807         Structure&amp; structure = *baseValue.asCell()-&gt;structure(vm);
1808         if (JSCell::canUseFastGetOwnProperty(structure)) {
<span class="line-modified">1809             if (RefPtr&lt;AtomicStringImpl&gt; existingAtomicString = asString(subscript)-&gt;toExistingAtomicString(exec)) {</span>
<span class="line-modified">1810                 if (JSValue result = baseValue.asCell()-&gt;fastGetOwnProperty(vm, structure, existingAtomicString.get())) {</span>


1811                     ASSERT(exec-&gt;bytecodeOffset());
<span class="line-modified">1812                     if (byValInfo-&gt;stubInfo &amp;&amp; byValInfo-&gt;cachedId.impl() != existingAtomicString)</span>
1813                         byValInfo-&gt;tookSlowPath = true;
1814                     return result;
1815                 }
1816             }
1817         }
1818     }
1819 
<span class="line-modified">1820     if (subscript.isUInt32()) {</span>
1821         ASSERT(exec-&gt;bytecodeOffset());
1822         byValInfo-&gt;tookSlowPath = true;
1823 
<span class="line-modified">1824         uint32_t i = subscript.asUInt32();</span>
1825         if (isJSString(baseValue)) {
<span class="line-modified">1826             if (asString(baseValue)-&gt;canGetIndex(i)) {</span>
1827                 ctiPatchCallByReturnAddress(returnAddress, operationGetByValString);
1828                 RELEASE_AND_RETURN(scope, asString(baseValue)-&gt;getIndex(exec, i));
1829             }
1830             byValInfo-&gt;arrayProfile-&gt;setOutOfBounds();
1831         } else if (baseValue.isObject()) {
1832             JSObject* object = asObject(baseValue);
1833             if (object-&gt;canGetIndexQuickly(i))
1834                 return object-&gt;getIndexQuickly(i);
1835 
1836             bool skipMarkingOutOfBounds = false;
1837 
<span class="line-modified">1838             if (object-&gt;indexingType() == ArrayWithContiguous &amp;&amp; i &lt; object-&gt;butterfly()-&gt;publicLength()) {</span>
1839                 // FIXME: expand this to ArrayStorage, Int32, and maybe Double:
1840                 // https://bugs.webkit.org/show_bug.cgi?id=182940
1841                 auto* globalObject = object-&gt;globalObject(vm);
1842                 skipMarkingOutOfBounds = globalObject-&gt;isOriginalArrayStructure(object-&gt;structure(vm)) &amp;&amp; globalObject-&gt;arrayPrototypeChainIsSane();
1843             }
1844 
1845             if (!skipMarkingOutOfBounds &amp;&amp; !CommonSlowPaths::canAccessArgumentIndexQuickly(*object, i)) {
1846                 // FIXME: This will make us think that in-bounds typed array accesses are actually
1847                 // out-of-bounds.
1848                 // https://bugs.webkit.org/show_bug.cgi?id=149886
1849                 byValInfo-&gt;arrayProfile-&gt;setOutOfBounds();
1850             }
1851         }
1852 
<span class="line-modified">1853         RELEASE_AND_RETURN(scope, baseValue.get(exec, i));</span>

1854     }
1855 
1856     baseValue.requireObjectCoercible(exec);
1857     RETURN_IF_EXCEPTION(scope, JSValue());
1858     auto property = subscript.toPropertyKey(exec);
1859     RETURN_IF_EXCEPTION(scope, JSValue());
1860 
1861     ASSERT(exec-&gt;bytecodeOffset());
1862     if (byValInfo-&gt;stubInfo &amp;&amp; (!isStringOrSymbol(subscript) || byValInfo-&gt;cachedId != property))
1863         byValInfo-&gt;tookSlowPath = true;
1864 
1865     RELEASE_AND_RETURN(scope, baseValue.get(exec, property));
1866 }
1867 
1868 static OptimizationResult tryGetByValOptimize(ExecState* exec, JSValue baseValue, JSValue subscript, ByValInfo* byValInfo, ReturnAddressPtr returnAddress)
1869 {
1870     // See if it&#39;s worth optimizing this at all.
1871     OptimizationResult optimizationResult = OptimizationResult::NotOptimized;
1872 
1873     VM&amp; vm = exec-&gt;vm();

1874 
1875     if (baseValue.isObject() &amp;&amp; subscript.isInt32()) {
1876         JSObject* object = asObject(baseValue);
1877 
1878         ASSERT(exec-&gt;bytecodeOffset());
1879         ASSERT(!byValInfo-&gt;stubRoutine);
1880 
1881         if (hasOptimizableIndexing(object-&gt;structure(vm))) {
1882             // Attempt to optimize.
1883             Structure* structure = object-&gt;structure(vm);
1884             JITArrayMode arrayMode = jitArrayModeForStructure(structure);
1885             if (arrayMode != byValInfo-&gt;arrayMode) {
1886                 // If we reached this case, we got an interesting array mode we did not expect when we compiled.
1887                 // Let&#39;s update the profile to do better next time.
1888                 CodeBlock* codeBlock = exec-&gt;codeBlock();
1889                 ConcurrentJSLocker locker(codeBlock-&gt;m_lock);
1890                 byValInfo-&gt;arrayProfile-&gt;computeUpdatedPrediction(locker, codeBlock, structure);
1891 
<span class="line-modified">1892                 JIT::compileGetByVal(locker, &amp;vm, codeBlock, byValInfo, returnAddress, arrayMode);</span>
1893                 optimizationResult = OptimizationResult::Optimized;
1894             }
1895         }
1896 
1897         // If we failed to patch and we have some object that intercepts indexed get, then don&#39;t even wait until 10 times.
1898         if (optimizationResult != OptimizationResult::Optimized &amp;&amp; object-&gt;structure(vm)-&gt;typeInfo().interceptsGetOwnPropertySlotByIndexEvenWhenLengthIsNotZero())
1899             optimizationResult = OptimizationResult::GiveUp;
1900     }
1901 
1902     if (baseValue.isObject() &amp;&amp; isStringOrSymbol(subscript)) {
1903         const Identifier propertyName = subscript.toPropertyKey(exec);

1904         if (subscript.isSymbol() || !parseIndex(propertyName)) {
1905             ASSERT(exec-&gt;bytecodeOffset());
1906             ASSERT(!byValInfo-&gt;stubRoutine);
1907             if (byValInfo-&gt;seen) {
1908                 if (byValInfo-&gt;cachedId == propertyName) {
<span class="line-modified">1909                     JIT::compileGetByValWithCachedId(&amp;vm, exec-&gt;codeBlock(), byValInfo, returnAddress, propertyName);</span>
1910                     optimizationResult = OptimizationResult::Optimized;
1911                 } else {
1912                     // Seem like a generic property access site.
1913                     optimizationResult = OptimizationResult::GiveUp;
1914                 }
1915             } else {
1916                 CodeBlock* codeBlock = exec-&gt;codeBlock();
1917                 ConcurrentJSLocker locker(codeBlock-&gt;m_lock);
1918                 byValInfo-&gt;seen = true;
1919                 byValInfo-&gt;cachedId = propertyName;
1920                 if (subscript.isSymbol())
1921                     byValInfo-&gt;cachedSymbol.set(vm, codeBlock, asSymbol(subscript));
1922                 optimizationResult = OptimizationResult::SeenOnce;
1923             }
1924         }
1925     }
1926 
1927     if (optimizationResult != OptimizationResult::Optimized &amp;&amp; optimizationResult != OptimizationResult::SeenOnce) {
1928         // If we take slow path more than 10 times without patching then make sure we
1929         // never make that mistake again. For cases where we see non-index-intercepting
1930         // objects, this gives 10 iterations worth of opportunity for us to observe
1931         // that the get_by_val may be polymorphic. We count up slowPathCount even if
1932         // the result is GiveUp.
1933         if (++byValInfo-&gt;slowPathCount &gt;= 10)
1934             optimizationResult = OptimizationResult::GiveUp;
1935     }
1936 
1937     return optimizationResult;
1938 }
1939 
1940 extern &quot;C&quot; {
1941 
1942 EncodedJSValue JIT_OPERATION operationGetByValGeneric(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedSubscript, ByValInfo* byValInfo)
1943 {
1944     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1945     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
1946     JSValue baseValue = JSValue::decode(encodedBase);
1947     JSValue subscript = JSValue::decode(encodedSubscript);
1948 
1949     JSValue result = getByVal(exec, baseValue, subscript, byValInfo, ReturnAddressPtr(OUR_RETURN_ADDRESS));
1950     return JSValue::encode(result);
1951 }
1952 
1953 EncodedJSValue JIT_OPERATION operationGetByValOptimize(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedSubscript, ByValInfo* byValInfo)
1954 {
1955     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1956     NativeCallFrameTracer tracer(&amp;vm, exec);</span>

1957 
1958     JSValue baseValue = JSValue::decode(encodedBase);
1959     JSValue subscript = JSValue::decode(encodedSubscript);
1960     ReturnAddressPtr returnAddress = ReturnAddressPtr(OUR_RETURN_ADDRESS);
<span class="line-modified">1961     if (tryGetByValOptimize(exec, baseValue, subscript, byValInfo, returnAddress) == OptimizationResult::GiveUp) {</span>


1962         // Don&#39;t ever try to optimize.
1963         byValInfo-&gt;tookSlowPath = true;
1964         ctiPatchCallByReturnAddress(returnAddress, operationGetByValGeneric);
1965     }
1966 
<span class="line-modified">1967     return JSValue::encode(getByVal(exec, baseValue, subscript, byValInfo, returnAddress));</span>
1968 }
1969 
1970 EncodedJSValue JIT_OPERATION operationHasIndexedPropertyDefault(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedSubscript, ByValInfo* byValInfo)
1971 {
1972     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1973     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
1974     JSValue baseValue = JSValue::decode(encodedBase);
1975     JSValue subscript = JSValue::decode(encodedSubscript);
1976 
1977     ASSERT(baseValue.isObject());
<span class="line-modified">1978     ASSERT(subscript.isUInt32());</span>
1979 
1980     JSObject* object = asObject(baseValue);
1981     bool didOptimize = false;
1982 
1983     ASSERT(exec-&gt;bytecodeOffset());
1984     ASSERT(!byValInfo-&gt;stubRoutine);
1985 
1986     if (hasOptimizableIndexing(object-&gt;structure(vm))) {
1987         // Attempt to optimize.
1988         JITArrayMode arrayMode = jitArrayModeForStructure(object-&gt;structure(vm));
1989         if (arrayMode != byValInfo-&gt;arrayMode) {
<span class="line-modified">1990             JIT::compileHasIndexedProperty(&amp;vm, exec-&gt;codeBlock(), byValInfo, ReturnAddressPtr(OUR_RETURN_ADDRESS), arrayMode);</span>
1991             didOptimize = true;
1992         }
1993     }
1994 
1995     if (!didOptimize) {
1996         // If we take slow path more than 10 times without patching then make sure we
1997         // never make that mistake again. Or, if we failed to patch and we have some object
1998         // that intercepts indexed get, then don&#39;t even wait until 10 times. For cases
1999         // where we see non-index-intercepting objects, this gives 10 iterations worth of
2000         // opportunity for us to observe that the get_by_val may be polymorphic.
2001         if (++byValInfo-&gt;slowPathCount &gt;= 10
2002             || object-&gt;structure(vm)-&gt;typeInfo().interceptsGetOwnPropertySlotByIndexEvenWhenLengthIsNotZero()) {
2003             // Don&#39;t ever try to optimize.
2004             ctiPatchCallByReturnAddress(ReturnAddressPtr(OUR_RETURN_ADDRESS), operationHasIndexedPropertyGeneric);
2005         }
2006     }
2007 
<span class="line-modified">2008     uint32_t index = subscript.asUInt32();</span>
2009     if (object-&gt;canGetIndexQuickly(index))
2010         return JSValue::encode(JSValue(JSValue::JSTrue));
2011 
<span class="line-modified">2012     if (!CommonSlowPaths::canAccessArgumentIndexQuickly(*object, index)) {</span>
<span class="line-removed">2013         // FIXME: This will make us think that in-bounds typed array accesses are actually</span>
<span class="line-removed">2014         // out-of-bounds.</span>
<span class="line-removed">2015         // https://bugs.webkit.org/show_bug.cgi?id=149886</span>
2016         byValInfo-&gt;arrayProfile-&gt;setOutOfBounds();
<span class="line-removed">2017     }</span>
2018     return JSValue::encode(jsBoolean(object-&gt;hasPropertyGeneric(exec, index, PropertySlot::InternalMethodType::GetOwnProperty)));
2019 }
2020 
2021 EncodedJSValue JIT_OPERATION operationHasIndexedPropertyGeneric(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedSubscript, ByValInfo* byValInfo)
2022 {
2023     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2024     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
2025     JSValue baseValue = JSValue::decode(encodedBase);
2026     JSValue subscript = JSValue::decode(encodedSubscript);
2027 
2028     ASSERT(baseValue.isObject());
<span class="line-modified">2029     ASSERT(subscript.isUInt32());</span>
2030 
2031     JSObject* object = asObject(baseValue);
<span class="line-modified">2032     uint32_t index = subscript.asUInt32();</span>
2033     if (object-&gt;canGetIndexQuickly(index))
2034         return JSValue::encode(JSValue(JSValue::JSTrue));
2035 
<span class="line-modified">2036     if (!CommonSlowPaths::canAccessArgumentIndexQuickly(*object, index)) {</span>
<span class="line-removed">2037         // FIXME: This will make us think that in-bounds typed array accesses are actually</span>
<span class="line-removed">2038         // out-of-bounds.</span>
<span class="line-removed">2039         // https://bugs.webkit.org/show_bug.cgi?id=149886</span>
2040         byValInfo-&gt;arrayProfile-&gt;setOutOfBounds();
<span class="line-modified">2041     }</span>
<span class="line-removed">2042     return JSValue::encode(jsBoolean(object-&gt;hasPropertyGeneric(exec, subscript.asUInt32(), PropertySlot::InternalMethodType::GetOwnProperty)));</span>
2043 }
2044 
2045 EncodedJSValue JIT_OPERATION operationGetByValString(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedSubscript, ByValInfo* byValInfo)
2046 {
2047     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2048     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
2049     auto scope = DECLARE_THROW_SCOPE(vm);
2050     JSValue baseValue = JSValue::decode(encodedBase);
2051     JSValue subscript = JSValue::decode(encodedSubscript);
2052 
2053     JSValue result;
2054     if (LIKELY(subscript.isUInt32())) {
2055         uint32_t i = subscript.asUInt32();
2056         if (isJSString(baseValue) &amp;&amp; asString(baseValue)-&gt;canGetIndex(i))
2057             RELEASE_AND_RETURN(scope, JSValue::encode(asString(baseValue)-&gt;getIndex(exec, i)));
2058 
2059         result = baseValue.get(exec, i);
2060         RETURN_IF_EXCEPTION(scope, encodedJSValue());
2061         if (!isJSString(baseValue)) {
2062             ASSERT(exec-&gt;bytecodeOffset());
2063             auto getByValFunction = byValInfo-&gt;stubRoutine ? operationGetByValGeneric : operationGetByValOptimize;
2064             ctiPatchCallByReturnAddress(ReturnAddressPtr(OUR_RETURN_ADDRESS), getByValFunction);
2065         }
2066     } else {
2067         baseValue.requireObjectCoercible(exec);
2068         RETURN_IF_EXCEPTION(scope, encodedJSValue());
2069         auto property = subscript.toPropertyKey(exec);
2070         RETURN_IF_EXCEPTION(scope, encodedJSValue());
2071         scope.release();
2072         result = baseValue.get(exec, property);
2073     }
2074 
2075     return JSValue::encode(result);
2076 }
2077 
2078 EncodedJSValue JIT_OPERATION operationDeleteByIdJSResult(ExecState* exec, EncodedJSValue base, UniquedStringImpl* uid)
2079 {
2080     return JSValue::encode(jsBoolean(operationDeleteById(exec, base, uid)));
2081 }
2082 
2083 size_t JIT_OPERATION operationDeleteById(ExecState* exec, EncodedJSValue encodedBase, UniquedStringImpl* uid)
2084 {
2085     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2086     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
2087     auto scope = DECLARE_THROW_SCOPE(vm);
2088 
2089     JSObject* baseObj = JSValue::decode(encodedBase).toObject(exec);
2090     RETURN_IF_EXCEPTION(scope, false);
2091     if (!baseObj)
2092         return false;
<span class="line-modified">2093     bool couldDelete = baseObj-&gt;methodTable(vm)-&gt;deleteProperty(baseObj, exec, Identifier::fromUid(&amp;vm, uid));</span>
2094     RETURN_IF_EXCEPTION(scope, false);
2095     if (!couldDelete &amp;&amp; exec-&gt;codeBlock()-&gt;isStrictMode())
2096         throwTypeError(exec, scope, UnableToDeletePropertyError);
2097     return couldDelete;
2098 }
2099 
2100 EncodedJSValue JIT_OPERATION operationDeleteByValJSResult(ExecState* exec, EncodedJSValue base,  EncodedJSValue key)
2101 {
2102     return JSValue::encode(jsBoolean(operationDeleteByVal(exec, base, key)));
2103 }
2104 
2105 size_t JIT_OPERATION operationDeleteByVal(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedKey)
2106 {
2107     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2108     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
2109     auto scope = DECLARE_THROW_SCOPE(vm);
2110 
2111     JSObject* baseObj = JSValue::decode(encodedBase).toObject(exec);
2112     RETURN_IF_EXCEPTION(scope, false);
2113     JSValue key = JSValue::decode(encodedKey);
2114     if (!baseObj)
2115         return false;
2116 
2117     bool couldDelete;
2118     uint32_t index;
2119     if (key.getUInt32(index))
2120         couldDelete = baseObj-&gt;methodTable(vm)-&gt;deletePropertyByIndex(baseObj, exec, index);
2121     else {
2122         Identifier property = key.toPropertyKey(exec);
2123         RETURN_IF_EXCEPTION(scope, false);
2124         couldDelete = baseObj-&gt;methodTable(vm)-&gt;deleteProperty(baseObj, exec, property);
2125     }
2126     RETURN_IF_EXCEPTION(scope, false);
2127     if (!couldDelete &amp;&amp; exec-&gt;codeBlock()-&gt;isStrictMode())
2128         throwTypeError(exec, scope, UnableToDeletePropertyError);
2129     return couldDelete;
2130 }
2131 
2132 JSCell* JIT_OPERATION operationPushWithScope(ExecState* exec, JSCell* currentScopeCell, EncodedJSValue objectValue)
2133 {
2134     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2135     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
2136     auto scope = DECLARE_THROW_SCOPE(vm);
2137 
2138     JSObject* object = JSValue::decode(objectValue).toObject(exec);
2139     RETURN_IF_EXCEPTION(scope, nullptr);
2140 
2141     JSScope* currentScope = jsCast&lt;JSScope*&gt;(currentScopeCell);
2142 
2143     return JSWithScope::create(vm, exec-&gt;lexicalGlobalObject(), currentScope, object);
2144 }
2145 
2146 JSCell* JIT_OPERATION operationPushWithScopeObject(ExecState* exec, JSCell* currentScopeCell, JSObject* object)
2147 {
2148     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2149     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
2150     JSScope* currentScope = jsCast&lt;JSScope*&gt;(currentScopeCell);
2151     return JSWithScope::create(vm, exec-&gt;lexicalGlobalObject(), currentScope, object);
2152 }
2153 
2154 EncodedJSValue JIT_OPERATION operationInstanceOf(ExecState* exec, EncodedJSValue encodedValue, EncodedJSValue encodedProto)
2155 {
2156     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2157     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
2158     JSValue value = JSValue::decode(encodedValue);
2159     JSValue proto = JSValue::decode(encodedProto);
2160 
2161     bool result = JSObject::defaultHasInstance(exec, value, proto);
2162     return JSValue::encode(jsBoolean(result));
2163 }
2164 
2165 EncodedJSValue JIT_OPERATION operationInstanceOfGeneric(ExecState* exec, StructureStubInfo* stubInfo, EncodedJSValue encodedValue, EncodedJSValue encodedProto)
2166 {
2167     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2168     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
2169     JSValue value = JSValue::decode(encodedValue);
2170     JSValue proto = JSValue::decode(encodedProto);
2171 
2172     stubInfo-&gt;tookSlowPath = true;
2173 
2174     bool result = JSObject::defaultHasInstance(exec, value, proto);
2175     return JSValue::encode(jsBoolean(result));
2176 }
2177 
2178 EncodedJSValue JIT_OPERATION operationInstanceOfOptimize(ExecState* exec, StructureStubInfo* stubInfo, EncodedJSValue encodedValue, EncodedJSValue encodedProto)
2179 {
2180     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2181     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
2182     auto scope = DECLARE_THROW_SCOPE(vm);
2183     JSValue value = JSValue::decode(encodedValue);
2184     JSValue proto = JSValue::decode(encodedProto);
2185 
2186     bool result = JSObject::defaultHasInstance(exec, value, proto);
2187     RETURN_IF_EXCEPTION(scope, JSValue::encode(jsUndefined()));
2188 
<span class="line-modified">2189     if (stubInfo-&gt;considerCaching(exec-&gt;codeBlock(), value.structureOrNull()))</span>
2190         repatchInstanceOf(exec, value, proto, *stubInfo, result);
2191 
2192     return JSValue::encode(jsBoolean(result));
2193 }
2194 
2195 int32_t JIT_OPERATION operationSizeFrameForForwardArguments(ExecState* exec, EncodedJSValue, int32_t numUsedStackSlots, int32_t)
2196 {
2197     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2198     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
2199     return sizeFrameForForwardArguments(exec, vm, numUsedStackSlots);
2200 }
2201 
2202 int32_t JIT_OPERATION operationSizeFrameForVarargs(ExecState* exec, EncodedJSValue encodedArguments, int32_t numUsedStackSlots, int32_t firstVarArgOffset)
2203 {
2204     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2205     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
2206     JSValue arguments = JSValue::decode(encodedArguments);
2207     return sizeFrameForVarargs(exec, vm, arguments, numUsedStackSlots, firstVarArgOffset);
2208 }
2209 
2210 CallFrame* JIT_OPERATION operationSetupForwardArgumentsFrame(ExecState* exec, CallFrame* newCallFrame, EncodedJSValue, int32_t, int32_t length)
2211 {
2212     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2213     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
2214     setupForwardArgumentsFrame(exec, newCallFrame, length);
2215     return newCallFrame;
2216 }
2217 
2218 CallFrame* JIT_OPERATION operationSetupVarargsFrame(ExecState* exec, CallFrame* newCallFrame, EncodedJSValue encodedArguments, int32_t firstVarArgOffset, int32_t length)
2219 {
2220     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2221     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
2222     JSValue arguments = JSValue::decode(encodedArguments);
2223     setupVarargsFrame(exec, newCallFrame, arguments, firstVarArgOffset, length);
2224     return newCallFrame;
2225 }
2226 
2227 char* JIT_OPERATION operationSwitchCharWithUnknownKeyType(ExecState* exec, EncodedJSValue encodedKey, size_t tableIndex)
2228 {
2229     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2230     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
2231     JSValue key = JSValue::decode(encodedKey);
2232     CodeBlock* codeBlock = exec-&gt;codeBlock();
2233 
2234     SimpleJumpTable&amp; jumpTable = codeBlock-&gt;switchJumpTable(tableIndex);
2235     void* result = jumpTable.ctiDefault.executableAddress();
2236 
2237     if (key.isString()) {
2238         StringImpl* value = asString(key)-&gt;value(exec).impl();
2239         if (value-&gt;length() == 1)
2240             result = jumpTable.ctiForValue((*value)[0]).executableAddress();
2241     }
2242 
2243     assertIsTaggedWith(result, JSSwitchPtrTag);
2244     return reinterpret_cast&lt;char*&gt;(result);
2245 }
2246 
2247 char* JIT_OPERATION operationSwitchImmWithUnknownKeyType(ExecState* exec, EncodedJSValue encodedKey, size_t tableIndex)
2248 {
2249     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2250     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
2251     JSValue key = JSValue::decode(encodedKey);
2252     CodeBlock* codeBlock = exec-&gt;codeBlock();
2253 
2254     SimpleJumpTable&amp; jumpTable = codeBlock-&gt;switchJumpTable(tableIndex);
2255     void* result;
2256     if (key.isInt32())
2257         result = jumpTable.ctiForValue(key.asInt32()).executableAddress();
2258     else if (key.isDouble() &amp;&amp; key.asDouble() == static_cast&lt;int32_t&gt;(key.asDouble()))
2259         result = jumpTable.ctiForValue(static_cast&lt;int32_t&gt;(key.asDouble())).executableAddress();
2260     else
2261         result = jumpTable.ctiDefault.executableAddress();
2262     assertIsTaggedWith(result, JSSwitchPtrTag);
2263     return reinterpret_cast&lt;char*&gt;(result);
2264 }
2265 
2266 char* JIT_OPERATION operationSwitchStringWithUnknownKeyType(ExecState* exec, EncodedJSValue encodedKey, size_t tableIndex)
2267 {
2268     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2269     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
2270     JSValue key = JSValue::decode(encodedKey);
2271     CodeBlock* codeBlock = exec-&gt;codeBlock();

2272 
2273     void* result;
2274     StringJumpTable&amp; jumpTable = codeBlock-&gt;stringSwitchJumpTable(tableIndex);
2275 
2276     if (key.isString()) {
2277         StringImpl* value = asString(key)-&gt;value(exec).impl();



2278         result = jumpTable.ctiForValue(value).executableAddress();
2279     } else
2280         result = jumpTable.ctiDefault.executableAddress();
2281 
2282     assertIsTaggedWith(result, JSSwitchPtrTag);
2283     return reinterpret_cast&lt;char*&gt;(result);
2284 }
2285 
2286 EncodedJSValue JIT_OPERATION operationGetFromScope(ExecState* exec, const Instruction* pc)
2287 {
2288     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2289     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
2290     auto throwScope = DECLARE_THROW_SCOPE(vm);
2291 
2292     CodeBlock* codeBlock = exec-&gt;codeBlock();
2293 
2294     auto bytecode = pc-&gt;as&lt;OpGetFromScope&gt;();
2295     const Identifier&amp; ident = codeBlock-&gt;identifier(bytecode.m_var);
2296     JSObject* scope = jsCast&lt;JSObject*&gt;(exec-&gt;uncheckedR(bytecode.m_scope.offset()).jsValue());
2297     GetPutInfo&amp; getPutInfo = bytecode.metadata(codeBlock).m_getPutInfo;
2298 
2299     // ModuleVar is always converted to ClosureVar for get_from_scope.
2300     ASSERT(getPutInfo.resolveType() != ModuleVar);
2301 
2302     RELEASE_AND_RETURN(throwScope, JSValue::encode(scope-&gt;getPropertySlot(exec, ident, [&amp;] (bool found, PropertySlot&amp; slot) -&gt; JSValue {
2303         if (!found) {
2304             if (getPutInfo.resolveMode() == ThrowIfNotFound)
2305                 throwException(exec, throwScope, createUndefinedVariableError(exec, ident));
2306             return jsUndefined();
2307         }
2308 
2309         JSValue result = JSValue();
2310         if (scope-&gt;isGlobalLexicalEnvironment()) {
2311             // When we can&#39;t statically prove we need a TDZ check, we must perform the check on the slow path.
2312             result = slot.getValue(exec, ident);
2313             if (result == jsTDZValue()) {
2314                 throwException(exec, throwScope, createTDZError(exec));
2315                 return jsUndefined();
2316             }
2317         }
2318 
2319         CommonSlowPaths::tryCacheGetFromScopeGlobal(exec, vm, bytecode, scope, slot, ident);
2320 
2321         if (!result)
2322             return slot.getValue(exec, ident);
2323         return result;
2324     })));
2325 }
2326 
2327 void JIT_OPERATION operationPutToScope(ExecState* exec, const Instruction* pc)
2328 {
2329     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2330     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
2331     auto throwScope = DECLARE_THROW_SCOPE(vm);
2332 
2333     CodeBlock* codeBlock = exec-&gt;codeBlock();
2334     auto bytecode = pc-&gt;as&lt;OpPutToScope&gt;();
2335     auto&amp; metadata = bytecode.metadata(codeBlock);
2336 
2337     const Identifier&amp; ident = codeBlock-&gt;identifier(bytecode.m_var);
2338     JSObject* scope = jsCast&lt;JSObject*&gt;(exec-&gt;uncheckedR(bytecode.m_scope.offset()).jsValue());
2339     JSValue value = exec-&gt;r(bytecode.m_value.offset()).jsValue();
2340     GetPutInfo&amp; getPutInfo = metadata.m_getPutInfo;
2341 
2342     // ModuleVar does not keep the scope register value alive in DFG.
2343     ASSERT(getPutInfo.resolveType() != ModuleVar);
2344 
2345     if (getPutInfo.resolveType() == LocalClosureVar) {
2346         JSLexicalEnvironment* environment = jsCast&lt;JSLexicalEnvironment*&gt;(scope);
2347         environment-&gt;variableAt(ScopeOffset(metadata.m_operand)).set(vm, environment, value);
2348         if (WatchpointSet* set = metadata.m_watchpointSet)
2349             set-&gt;touch(vm, &quot;Executed op_put_scope&lt;LocalClosureVar&gt;&quot;);
2350         return;
2351     }
2352 
2353     bool hasProperty = scope-&gt;hasProperty(exec, ident);
<span class="line-modified">2354     EXCEPTION_ASSERT(!throwScope.exception() || !hasProperty);</span>
2355     if (hasProperty
2356         &amp;&amp; scope-&gt;isGlobalLexicalEnvironment()
2357         &amp;&amp; !isInitialization(getPutInfo.initializationMode())) {
2358         // When we can&#39;t statically prove we need a TDZ check, we must perform the check on the slow path.
2359         PropertySlot slot(scope, PropertySlot::InternalMethodType::Get);
2360         JSGlobalLexicalEnvironment::getOwnPropertySlot(scope, exec, ident, slot);
2361         if (slot.getValue(exec, ident) == jsTDZValue()) {
2362             throwException(exec, throwScope, createTDZError(exec));
2363             return;
2364         }
2365     }
2366 
2367     if (getPutInfo.resolveMode() == ThrowIfNotFound &amp;&amp; !hasProperty) {
2368         throwException(exec, throwScope, createUndefinedVariableError(exec, ident));
2369         return;
2370     }
2371 
2372     PutPropertySlot slot(scope, codeBlock-&gt;isStrictMode(), PutPropertySlot::UnknownContext, isInitialization(getPutInfo.initializationMode()));
2373     scope-&gt;methodTable(vm)-&gt;put(scope, exec, ident, value, slot);
2374 
2375     RETURN_IF_EXCEPTION(throwScope, void());
2376 
2377     CommonSlowPaths::tryCachePutToScopeGlobal(exec, codeBlock, bytecode, scope, slot, ident);
2378 }
2379 
2380 void JIT_OPERATION operationThrow(ExecState* exec, EncodedJSValue encodedExceptionValue)
2381 {
<span class="line-modified">2382     VM* vm = &amp;exec-&gt;vm();</span>
2383     NativeCallFrameTracer tracer(vm, exec);
<span class="line-modified">2384     auto scope = DECLARE_THROW_SCOPE(*vm);</span>
2385 
2386     JSValue exceptionValue = JSValue::decode(encodedExceptionValue);
2387     throwException(exec, scope, exceptionValue);
2388 
2389     // Results stored out-of-band in vm.targetMachinePCForThrow &amp; vm.callFrameForCatch
2390     genericUnwind(vm, exec);
2391 }
2392 
2393 char* JIT_OPERATION operationReallocateButterflyToHavePropertyStorageWithInitialCapacity(ExecState* exec, JSObject* object)
2394 {
2395     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2396     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
2397 
2398     ASSERT(!object-&gt;structure(vm)-&gt;outOfLineCapacity());
2399     Butterfly* result = object-&gt;allocateMoreOutOfLineStorage(vm, 0, initialOutOfLineCapacity);
2400     object-&gt;nukeStructureAndSetButterfly(vm, object-&gt;structureID(), result);
2401     return reinterpret_cast&lt;char*&gt;(result);
2402 }
2403 
2404 char* JIT_OPERATION operationReallocateButterflyToGrowPropertyStorage(ExecState* exec, JSObject* object, size_t newSize)
2405 {
2406     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2407     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
2408 
2409     Butterfly* result = object-&gt;allocateMoreOutOfLineStorage(vm, object-&gt;structure(vm)-&gt;outOfLineCapacity(), newSize);
2410     object-&gt;nukeStructureAndSetButterfly(vm, object-&gt;structureID(), result);
2411     return reinterpret_cast&lt;char*&gt;(result);
2412 }
2413 
2414 void JIT_OPERATION operationOSRWriteBarrier(ExecState* exec, JSCell* cell)
2415 {
<span class="line-modified">2416     VM* vm = &amp;exec-&gt;vm();</span>
2417     NativeCallFrameTracer tracer(vm, exec);
<span class="line-modified">2418     vm-&gt;heap.writeBarrier(cell);</span>
2419 }
2420 
2421 void JIT_OPERATION operationWriteBarrierSlowPath(ExecState* exec, JSCell* cell)
2422 {
<span class="line-modified">2423     VM* vm = &amp;exec-&gt;vm();</span>
2424     NativeCallFrameTracer tracer(vm, exec);
<span class="line-modified">2425     vm-&gt;heap.writeBarrierSlowPath(cell);</span>
2426 }
2427 
<span class="line-modified">2428 void JIT_OPERATION lookupExceptionHandler(VM* vm, ExecState* exec)</span>
2429 {

2430     NativeCallFrameTracer tracer(vm, exec);
2431     genericUnwind(vm, exec);
<span class="line-modified">2432     ASSERT(vm-&gt;targetMachinePCForThrow);</span>
2433 }
2434 
2435 void JIT_OPERATION lookupExceptionHandlerFromCallerFrame(VM* vm, ExecState* exec)
2436 {
2437     ASSERT(exec-&gt;isStackOverflowFrame());
2438     ASSERT(jsCast&lt;ErrorInstance*&gt;(vm-&gt;exceptionForInspection()-&gt;value().asCell())-&gt;isStackOverflowError());
2439     lookupExceptionHandler(vm, exec);
2440 }
2441 
2442 void JIT_OPERATION operationVMHandleException(ExecState* exec)
2443 {
<span class="line-modified">2444     VM* vm = &amp;exec-&gt;vm();</span>
2445     NativeCallFrameTracer tracer(vm, exec);
2446     genericUnwind(vm, exec);
2447 }
2448 
2449 // This function &quot;should&quot; just take the ExecState*, but doing so would make it more difficult
2450 // to call from exception check sites. So, unlike all of our other functions, we allow
2451 // ourselves to play some gnarly ABI tricks just to simplify the calling convention. This is
2452 // particularly safe here since this is never called on the critical path - it&#39;s only for
2453 // testing.
2454 void JIT_OPERATION operationExceptionFuzz(ExecState* exec)
2455 {
<span class="line-modified">2456     VM* vm = &amp;exec-&gt;vm();</span>
2457     NativeCallFrameTracer tracer(vm, exec);
<span class="line-modified">2458     auto scope = DECLARE_THROW_SCOPE(*vm);</span>
2459     UNUSED_PARAM(scope);
2460 #if COMPILER(GCC_COMPATIBLE)
2461     void* returnPC = __builtin_return_address(0);
2462     doExceptionFuzzing(exec, scope, &quot;JITOperations&quot;, returnPC);
2463 #endif // COMPILER(GCC_COMPATIBLE)
2464 }
2465 
2466 ALWAYS_INLINE static EncodedJSValue unprofiledAdd(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)
2467 {
<span class="line-modified">2468     VM* vm = &amp;exec-&gt;vm();</span>
2469     NativeCallFrameTracer tracer(vm, exec);
2470 
2471     JSValue op1 = JSValue::decode(encodedOp1);
2472     JSValue op2 = JSValue::decode(encodedOp2);
2473 
2474     return JSValue::encode(jsAdd(exec, op1, op2));
2475 }
2476 
2477 ALWAYS_INLINE static EncodedJSValue profiledAdd(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, ArithProfile&amp; arithProfile)
2478 {
<span class="line-modified">2479     VM* vm = &amp;exec-&gt;vm();</span>
2480     NativeCallFrameTracer tracer(vm, exec);
2481 
2482     JSValue op1 = JSValue::decode(encodedOp1);
2483     JSValue op2 = JSValue::decode(encodedOp2);
2484 
2485     arithProfile.observeLHSAndRHS(op1, op2);
2486     JSValue result = jsAdd(exec, op1, op2);
2487     arithProfile.observeResult(result);
2488 
2489     return JSValue::encode(result);
2490 }
2491 
2492 EncodedJSValue JIT_OPERATION operationValueAdd(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)
2493 {
2494     return unprofiledAdd(exec, encodedOp1, encodedOp2);
2495 }
2496 
2497 EncodedJSValue JIT_OPERATION operationValueAddProfiled(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, ArithProfile* arithProfile)
2498 {
2499     ASSERT(arithProfile);
2500     return profiledAdd(exec, encodedOp1, encodedOp2, *arithProfile);
2501 }
2502 
2503 EncodedJSValue JIT_OPERATION operationValueAddProfiledOptimize(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, JITAddIC* addIC)
2504 {
<span class="line-modified">2505     VM* vm = &amp;exec-&gt;vm();</span>
2506     NativeCallFrameTracer tracer(vm, exec);
2507 
2508     JSValue op1 = JSValue::decode(encodedOp1);
2509     JSValue op2 = JSValue::decode(encodedOp2);
2510 
2511     ArithProfile* arithProfile = addIC-&gt;arithProfile();
2512     ASSERT(arithProfile);
2513     arithProfile-&gt;observeLHSAndRHS(op1, op2);
2514     auto nonOptimizeVariant = operationValueAddProfiledNoOptimize;
2515     addIC-&gt;generateOutOfLine(exec-&gt;codeBlock(), nonOptimizeVariant);
2516 
2517 #if ENABLE(MATH_IC_STATS)
2518     exec-&gt;codeBlock()-&gt;dumpMathICStats();
2519 #endif
2520 
2521     JSValue result = jsAdd(exec, op1, op2);
2522     arithProfile-&gt;observeResult(result);
2523 
2524     return JSValue::encode(result);
2525 }
2526 
2527 EncodedJSValue JIT_OPERATION operationValueAddProfiledNoOptimize(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, JITAddIC* addIC)
2528 {
<span class="line-modified">2529     VM* vm = &amp;exec-&gt;vm();</span>
2530     NativeCallFrameTracer tracer(vm, exec);
2531 
2532     ArithProfile* arithProfile = addIC-&gt;arithProfile();
2533     ASSERT(arithProfile);
2534     return profiledAdd(exec, encodedOp1, encodedOp2, *arithProfile);
2535 }
2536 
2537 EncodedJSValue JIT_OPERATION operationValueAddOptimize(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, JITAddIC* addIC)
2538 {
<span class="line-modified">2539     VM* vm = &amp;exec-&gt;vm();</span>
2540     NativeCallFrameTracer tracer(vm, exec);
2541 
2542     JSValue op1 = JSValue::decode(encodedOp1);
2543     JSValue op2 = JSValue::decode(encodedOp2);
2544 
2545     auto nonOptimizeVariant = operationValueAddNoOptimize;
2546     if (ArithProfile* arithProfile = addIC-&gt;arithProfile())
2547         arithProfile-&gt;observeLHSAndRHS(op1, op2);
2548     addIC-&gt;generateOutOfLine(exec-&gt;codeBlock(), nonOptimizeVariant);
2549 
2550 #if ENABLE(MATH_IC_STATS)
2551     exec-&gt;codeBlock()-&gt;dumpMathICStats();
2552 #endif
2553 
2554     return JSValue::encode(jsAdd(exec, op1, op2));
2555 }
2556 
2557 EncodedJSValue JIT_OPERATION operationValueAddNoOptimize(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, JITAddIC*)
2558 {
<span class="line-modified">2559     VM* vm = &amp;exec-&gt;vm();</span>
2560     NativeCallFrameTracer tracer(vm, exec);
2561 
2562     JSValue op1 = JSValue::decode(encodedOp1);
2563     JSValue op2 = JSValue::decode(encodedOp2);
2564 
2565     JSValue result = jsAdd(exec, op1, op2);
2566 
2567     return JSValue::encode(result);
2568 }
2569 
2570 ALWAYS_INLINE static EncodedJSValue unprofiledMul(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)
2571 {
2572     JSValue op1 = JSValue::decode(encodedOp1);
2573     JSValue op2 = JSValue::decode(encodedOp2);
2574 
2575     return JSValue::encode(jsMul(exec, op1, op2));
2576 }
2577 
2578 ALWAYS_INLINE static EncodedJSValue profiledMul(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, ArithProfile&amp; arithProfile, bool shouldObserveLHSAndRHSTypes = true)
2579 {
2580     VM&amp; vm = exec-&gt;vm();
2581     auto scope = DECLARE_THROW_SCOPE(vm);
2582     JSValue op1 = JSValue::decode(encodedOp1);
2583     JSValue op2 = JSValue::decode(encodedOp2);
2584 
2585     if (shouldObserveLHSAndRHSTypes)
2586         arithProfile.observeLHSAndRHS(op1, op2);
2587 
2588     JSValue result = jsMul(exec, op1, op2);
2589     RETURN_IF_EXCEPTION(scope, encodedJSValue());
2590     arithProfile.observeResult(result);
2591     return JSValue::encode(result);
2592 }
2593 
2594 EncodedJSValue JIT_OPERATION operationValueMul(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)
2595 {
<span class="line-modified">2596     VM* vm = &amp;exec-&gt;vm();</span>
2597     NativeCallFrameTracer tracer(vm, exec);
2598 
2599     return unprofiledMul(exec, encodedOp1, encodedOp2);
2600 }
2601 
2602 EncodedJSValue JIT_OPERATION operationValueMulNoOptimize(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, JITMulIC*)
2603 {
<span class="line-modified">2604     VM* vm = &amp;exec-&gt;vm();</span>
2605     NativeCallFrameTracer tracer(vm, exec);
2606 
2607     return unprofiledMul(exec, encodedOp1, encodedOp2);
2608 }
2609 
2610 EncodedJSValue JIT_OPERATION operationValueMulOptimize(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, JITMulIC* mulIC)
2611 {
<span class="line-modified">2612     VM* vm = &amp;exec-&gt;vm();</span>
2613     NativeCallFrameTracer tracer(vm, exec);
2614 
2615     auto nonOptimizeVariant = operationValueMulNoOptimize;
2616     if (ArithProfile* arithProfile = mulIC-&gt;arithProfile())
2617         arithProfile-&gt;observeLHSAndRHS(JSValue::decode(encodedOp1), JSValue::decode(encodedOp2));
2618     mulIC-&gt;generateOutOfLine(exec-&gt;codeBlock(), nonOptimizeVariant);
2619 
2620 #if ENABLE(MATH_IC_STATS)
2621     exec-&gt;codeBlock()-&gt;dumpMathICStats();
2622 #endif
2623 
2624     return unprofiledMul(exec, encodedOp1, encodedOp2);
2625 }
2626 
2627 EncodedJSValue JIT_OPERATION operationValueMulProfiled(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, ArithProfile* arithProfile)
2628 {
<span class="line-modified">2629     VM* vm = &amp;exec-&gt;vm();</span>
2630     NativeCallFrameTracer tracer(vm, exec);
2631 
2632     ASSERT(arithProfile);
2633     return profiledMul(exec, encodedOp1, encodedOp2, *arithProfile);
2634 }
2635 
2636 EncodedJSValue JIT_OPERATION operationValueMulProfiledOptimize(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, JITMulIC* mulIC)
2637 {
<span class="line-modified">2638     VM* vm = &amp;exec-&gt;vm();</span>
2639     NativeCallFrameTracer tracer(vm, exec);
2640 
2641     ArithProfile* arithProfile = mulIC-&gt;arithProfile();
2642     ASSERT(arithProfile);
2643     arithProfile-&gt;observeLHSAndRHS(JSValue::decode(encodedOp1), JSValue::decode(encodedOp2));
2644     auto nonOptimizeVariant = operationValueMulProfiledNoOptimize;
2645     mulIC-&gt;generateOutOfLine(exec-&gt;codeBlock(), nonOptimizeVariant);
2646 
2647 #if ENABLE(MATH_IC_STATS)
2648     exec-&gt;codeBlock()-&gt;dumpMathICStats();
2649 #endif
2650 
2651     return profiledMul(exec, encodedOp1, encodedOp2, *arithProfile, false);
2652 }
2653 
2654 EncodedJSValue JIT_OPERATION operationValueMulProfiledNoOptimize(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, JITMulIC* mulIC)
2655 {
<span class="line-modified">2656     VM* vm = &amp;exec-&gt;vm();</span>
2657     NativeCallFrameTracer tracer(vm, exec);
2658 
2659     ArithProfile* arithProfile = mulIC-&gt;arithProfile();
2660     ASSERT(arithProfile);
2661     return profiledMul(exec, encodedOp1, encodedOp2, *arithProfile);
2662 }
2663 
2664 ALWAYS_INLINE static EncodedJSValue unprofiledNegate(ExecState* exec, EncodedJSValue encodedOperand)
2665 {
2666     VM&amp; vm = exec-&gt;vm();
2667     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">2668     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
2669 
2670     JSValue operand = JSValue::decode(encodedOperand);
2671 
2672     JSValue primValue = operand.toPrimitive(exec, PreferNumber);
2673     RETURN_IF_EXCEPTION(scope, encodedJSValue());
2674 
2675     if (primValue.isBigInt())
2676         return JSValue::encode(JSBigInt::unaryMinus(vm, asBigInt(primValue)));
2677 
2678     double number = primValue.toNumber(exec);
2679     RETURN_IF_EXCEPTION(scope, encodedJSValue());
2680     return JSValue::encode(jsNumber(-number));
2681 }
2682 
2683 ALWAYS_INLINE static EncodedJSValue profiledNegate(ExecState* exec, EncodedJSValue encodedOperand, ArithProfile&amp; arithProfile)
2684 {
2685     VM&amp; vm = exec-&gt;vm();
2686     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">2687     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
2688 
2689     JSValue operand = JSValue::decode(encodedOperand);
2690     arithProfile.observeLHS(operand);
2691 
2692     JSValue primValue = operand.toPrimitive(exec);
2693     RETURN_IF_EXCEPTION(scope, encodedJSValue());
2694 
2695     if (primValue.isBigInt()) {
2696         JSBigInt* result = JSBigInt::unaryMinus(vm, asBigInt(primValue));
2697         arithProfile.observeResult(result);
2698 
2699         return JSValue::encode(result);
2700     }
2701 
2702     double number = primValue.toNumber(exec);
2703     RETURN_IF_EXCEPTION(scope, encodedJSValue());
2704     JSValue result = jsNumber(-number);
2705     arithProfile.observeResult(result);
2706     return JSValue::encode(result);
2707 }
2708 
2709 EncodedJSValue JIT_OPERATION operationArithNegate(ExecState* exec, EncodedJSValue operand)
2710 {
2711     return unprofiledNegate(exec, operand);
2712 }
2713 
2714 EncodedJSValue JIT_OPERATION operationArithNegateProfiled(ExecState* exec, EncodedJSValue operand, ArithProfile* arithProfile)
2715 {
2716     ASSERT(arithProfile);
2717     return profiledNegate(exec, operand, *arithProfile);
2718 }
2719 
2720 EncodedJSValue JIT_OPERATION operationArithNegateProfiledOptimize(ExecState* exec, EncodedJSValue encodedOperand, JITNegIC* negIC)
2721 {
2722     VM&amp; vm = exec-&gt;vm();
2723     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">2724     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
2725 
2726     JSValue operand = JSValue::decode(encodedOperand);
2727 
2728     ArithProfile* arithProfile = negIC-&gt;arithProfile();
2729     ASSERT(arithProfile);
2730     arithProfile-&gt;observeLHS(operand);
2731     negIC-&gt;generateOutOfLine(exec-&gt;codeBlock(), operationArithNegateProfiled);
2732 
2733 #if ENABLE(MATH_IC_STATS)
2734     exec-&gt;codeBlock()-&gt;dumpMathICStats();
2735 #endif
2736 
2737     JSValue primValue = operand.toPrimitive(exec);
2738     RETURN_IF_EXCEPTION(scope, encodedJSValue());
2739 
2740     if (primValue.isBigInt()) {
2741         JSBigInt* result = JSBigInt::unaryMinus(vm, asBigInt(primValue));
2742         arithProfile-&gt;observeResult(result);
2743         return JSValue::encode(result);
2744     }
2745 
2746     double number = primValue.toNumber(exec);
2747     RETURN_IF_EXCEPTION(scope, encodedJSValue());
2748     JSValue result = jsNumber(-number);
2749     arithProfile-&gt;observeResult(result);
2750     return JSValue::encode(result);
2751 }
2752 
2753 EncodedJSValue JIT_OPERATION operationArithNegateOptimize(ExecState* exec, EncodedJSValue encodedOperand, JITNegIC* negIC)
2754 {
2755     VM&amp; vm = exec-&gt;vm();
2756     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">2757     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
2758 
2759     JSValue operand = JSValue::decode(encodedOperand);
2760 
2761     if (ArithProfile* arithProfile = negIC-&gt;arithProfile())
2762         arithProfile-&gt;observeLHS(operand);
2763     negIC-&gt;generateOutOfLine(exec-&gt;codeBlock(), operationArithNegate);
2764 
2765 #if ENABLE(MATH_IC_STATS)
2766     exec-&gt;codeBlock()-&gt;dumpMathICStats();
2767 #endif
2768 
2769     JSValue primValue = operand.toPrimitive(exec);
2770     RETURN_IF_EXCEPTION(scope, encodedJSValue());
2771 
2772     if (primValue.isBigInt())
2773         return JSValue::encode(JSBigInt::unaryMinus(vm, asBigInt(primValue)));
2774 
2775     double number = primValue.toNumber(exec);
2776     RETURN_IF_EXCEPTION(scope, encodedJSValue());
2777     return JSValue::encode(jsNumber(-number));
</pre>
<hr />
<pre>
2786 }
2787 
2788 ALWAYS_INLINE static EncodedJSValue profiledSub(VM&amp; vm, ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, ArithProfile&amp; arithProfile, bool shouldObserveLHSAndRHSTypes = true)
2789 {
2790     auto scope = DECLARE_THROW_SCOPE(vm);
2791 
2792     JSValue op1 = JSValue::decode(encodedOp1);
2793     JSValue op2 = JSValue::decode(encodedOp2);
2794 
2795     if (shouldObserveLHSAndRHSTypes)
2796         arithProfile.observeLHSAndRHS(op1, op2);
2797 
2798     JSValue result = jsSub(exec, op1, op2);
2799     RETURN_IF_EXCEPTION(scope, encodedJSValue());
2800     arithProfile.observeResult(result);
2801     return JSValue::encode(result);
2802 }
2803 
2804 EncodedJSValue JIT_OPERATION operationValueSub(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)
2805 {
<span class="line-modified">2806     VM* vm = &amp;exec-&gt;vm();</span>
2807     NativeCallFrameTracer tracer(vm, exec);
2808     return unprofiledSub(exec, encodedOp1, encodedOp2);
2809 }
2810 
2811 EncodedJSValue JIT_OPERATION operationValueSubProfiled(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, ArithProfile* arithProfile)
2812 {
2813     ASSERT(arithProfile);
2814 
<span class="line-modified">2815     VM* vm = &amp;exec-&gt;vm();</span>
2816     NativeCallFrameTracer tracer(vm, exec);
2817 
<span class="line-modified">2818     return profiledSub(*vm, exec, encodedOp1, encodedOp2, *arithProfile);</span>
2819 }
2820 
2821 EncodedJSValue JIT_OPERATION operationValueSubOptimize(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, JITSubIC* subIC)
2822 {
<span class="line-modified">2823     VM* vm = &amp;exec-&gt;vm();</span>
2824     NativeCallFrameTracer tracer(vm, exec);
2825 
2826     auto nonOptimizeVariant = operationValueSubNoOptimize;
2827     if (ArithProfile* arithProfile = subIC-&gt;arithProfile())
2828         arithProfile-&gt;observeLHSAndRHS(JSValue::decode(encodedOp1), JSValue::decode(encodedOp2));
2829     subIC-&gt;generateOutOfLine(exec-&gt;codeBlock(), nonOptimizeVariant);
2830 
2831 #if ENABLE(MATH_IC_STATS)
2832     exec-&gt;codeBlock()-&gt;dumpMathICStats();
2833 #endif
2834 
2835     return unprofiledSub(exec, encodedOp1, encodedOp2);
2836 }
2837 
2838 EncodedJSValue JIT_OPERATION operationValueSubNoOptimize(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, JITSubIC*)
2839 {
<span class="line-modified">2840     VM* vm = &amp;exec-&gt;vm();</span>
2841     NativeCallFrameTracer tracer(vm, exec);
2842 
2843     return unprofiledSub(exec, encodedOp1, encodedOp2);
2844 }
2845 
2846 EncodedJSValue JIT_OPERATION operationValueSubProfiledOptimize(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, JITSubIC* subIC)
2847 {
<span class="line-modified">2848     VM* vm = &amp;exec-&gt;vm();</span>
2849     NativeCallFrameTracer tracer(vm, exec);
2850 
2851     ArithProfile* arithProfile = subIC-&gt;arithProfile();
2852     ASSERT(arithProfile);
2853     arithProfile-&gt;observeLHSAndRHS(JSValue::decode(encodedOp1), JSValue::decode(encodedOp2));
2854     auto nonOptimizeVariant = operationValueSubProfiledNoOptimize;
2855     subIC-&gt;generateOutOfLine(exec-&gt;codeBlock(), nonOptimizeVariant);
2856 
2857 #if ENABLE(MATH_IC_STATS)
2858     exec-&gt;codeBlock()-&gt;dumpMathICStats();
2859 #endif
2860 
<span class="line-modified">2861     return profiledSub(*vm, exec, encodedOp1, encodedOp2, *arithProfile, false);</span>
2862 }
2863 
2864 EncodedJSValue JIT_OPERATION operationValueSubProfiledNoOptimize(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, JITSubIC* subIC)
2865 {
<span class="line-modified">2866     VM* vm = &amp;exec-&gt;vm();</span>
2867     NativeCallFrameTracer tracer(vm, exec);
2868 
2869     ArithProfile* arithProfile = subIC-&gt;arithProfile();
2870     ASSERT(arithProfile);
<span class="line-modified">2871     return profiledSub(*vm, exec, encodedOp1, encodedOp2, *arithProfile);</span>
2872 }
2873 
2874 void JIT_OPERATION operationProcessTypeProfilerLog(ExecState* exec)
2875 {
2876     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2877     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
2878     vm.typeProfilerLog()-&gt;processLogEntries(vm, &quot;Log Full, called from inside baseline JIT&quot;_s);
2879 }
2880 
2881 void JIT_OPERATION operationProcessShadowChickenLog(ExecState* exec)
2882 {
2883     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2884     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
2885     RELEASE_ASSERT(vm.shadowChicken());
2886     vm.shadowChicken()-&gt;update(vm, exec);
2887 }
2888 
2889 int32_t JIT_OPERATION operationCheckIfExceptionIsUncatchableAndNotifyProfiler(ExecState* exec)
2890 {
2891     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2892     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
2893     auto scope = DECLARE_THROW_SCOPE(vm);
2894     RELEASE_ASSERT(!!scope.exception());
2895 
2896     if (isTerminatedExecutionException(vm, scope.exception())) {
<span class="line-modified">2897         genericUnwind(&amp;vm, exec);</span>
2898         return 1;
2899     }
2900     return 0;
2901 }
2902 
2903 } // extern &quot;C&quot;
2904 
2905 } // namespace JSC
2906 
2907 #endif // ENABLE(JIT)
</pre>
</td>
<td>
<hr />
<pre>
  59 #include &quot;JSCPtrTag.h&quot;
  60 #include &quot;JSGeneratorFunction.h&quot;
  61 #include &quot;JSGlobalObjectFunctions.h&quot;
  62 #include &quot;JSLexicalEnvironment.h&quot;
  63 #include &quot;JSWithScope.h&quot;
  64 #include &quot;ModuleProgramCodeBlock.h&quot;
  65 #include &quot;ObjectConstructor.h&quot;
  66 #include &quot;PolymorphicAccess.h&quot;
  67 #include &quot;ProgramCodeBlock.h&quot;
  68 #include &quot;PropertyName.h&quot;
  69 #include &quot;RegExpObject.h&quot;
  70 #include &quot;Repatch.h&quot;
  71 #include &quot;ScopedArguments.h&quot;
  72 #include &quot;ShadowChicken.h&quot;
  73 #include &quot;StructureStubInfo.h&quot;
  74 #include &quot;SuperSampler.h&quot;
  75 #include &quot;TestRunnerUtils.h&quot;
  76 #include &quot;ThunkGenerators.h&quot;
  77 #include &quot;TypeProfilerLog.h&quot;
  78 #include &quot;VMInlines.h&quot;
<span class="line-added">  79 #include &quot;WebAssemblyFunction.h&quot;</span>
  80 #include &lt;wtf/InlineASM.h&gt;
  81 
  82 namespace JSC {
  83 
  84 extern &quot;C&quot; {
  85 
  86 #if COMPILER(MSVC)
  87 void * _ReturnAddress(void);
  88 #pragma intrinsic(_ReturnAddress)
  89 
  90 #define OUR_RETURN_ADDRESS _ReturnAddress()
  91 #else
  92 #define OUR_RETURN_ADDRESS __builtin_return_address(0)
  93 #endif
  94 
  95 #if ENABLE(OPCODE_SAMPLING)
<span class="line-modified">  96 #define CTI_SAMPLER vm.interpreter-&gt;sampler()</span>
  97 #else
  98 #define CTI_SAMPLER 0
  99 #endif
 100 
 101 
 102 void JIT_OPERATION operationThrowStackOverflowError(ExecState* exec, CodeBlock* codeBlock)
 103 {
 104     // We pass in our own code block, because the callframe hasn&#39;t been populated.
<span class="line-modified"> 105     VM&amp; vm = codeBlock-&gt;vm();</span>
<span class="line-modified"> 106     auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-modified"> 107     exec-&gt;convertToStackOverflowFrame(vm, codeBlock);</span>
 108     NativeCallFrameTracer tracer(vm, exec);
 109     throwStackOverflowError(exec, scope);
 110 }
 111 
<span class="line-added"> 112 void JIT_OPERATION throwStackOverflowErrorFromThunk(VM* vmPointer, ExecState* exec)</span>
<span class="line-added"> 113 {</span>
<span class="line-added"> 114     VM&amp; vm = *vmPointer;</span>
<span class="line-added"> 115     auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-added"> 116     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-added"> 117     throwStackOverflowError(exec, scope);</span>
<span class="line-added"> 118     genericUnwind(vm, exec);</span>
<span class="line-added"> 119     ASSERT(vm.targetMachinePCForThrow);</span>
<span class="line-added"> 120 }</span>
<span class="line-added"> 121 </span>
 122 int32_t JIT_OPERATION operationCallArityCheck(ExecState* exec)
 123 {
<span class="line-modified"> 124     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 125     auto scope = DECLARE_THROW_SCOPE(vm);</span>
 126 
<span class="line-modified"> 127     int32_t missingArgCount = CommonSlowPaths::arityCheckFor(exec, vm, CodeForCall);</span>
 128     if (UNLIKELY(missingArgCount &lt; 0)) {
 129         CodeBlock* codeBlock = CommonSlowPaths::codeBlockFromCallFrameCallee(exec, CodeForCall);
<span class="line-modified"> 130         exec-&gt;convertToStackOverflowFrame(vm, codeBlock);</span>
 131         NativeCallFrameTracer tracer(vm, exec);
<span class="line-modified"> 132         throwStackOverflowError(vm.topCallFrame, scope);</span>
 133     }
 134 
 135     return missingArgCount;
 136 }
 137 
 138 int32_t JIT_OPERATION operationConstructArityCheck(ExecState* exec)
 139 {
<span class="line-modified"> 140     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 141     auto scope = DECLARE_THROW_SCOPE(vm);</span>
 142 
<span class="line-modified"> 143     int32_t missingArgCount = CommonSlowPaths::arityCheckFor(exec, vm, CodeForConstruct);</span>
 144     if (UNLIKELY(missingArgCount &lt; 0)) {
 145         CodeBlock* codeBlock = CommonSlowPaths::codeBlockFromCallFrameCallee(exec, CodeForConstruct);
<span class="line-modified"> 146         exec-&gt;convertToStackOverflowFrame(vm, codeBlock);</span>
 147         NativeCallFrameTracer tracer(vm, exec);
<span class="line-modified"> 148         throwStackOverflowError(vm.topCallFrame, scope);</span>
 149     }
 150 
 151     return missingArgCount;
 152 }
 153 
 154 EncodedJSValue JIT_OPERATION operationTryGetById(ExecState* exec, StructureStubInfo* stubInfo, EncodedJSValue base, UniquedStringImpl* uid)
 155 {
<span class="line-modified"> 156     VM&amp; vm = exec-&gt;vm();</span>
 157     NativeCallFrameTracer tracer(vm, exec);
 158     Identifier ident = Identifier::fromUid(vm, uid);
 159     stubInfo-&gt;tookSlowPath = true;
 160 
 161     JSValue baseValue = JSValue::decode(base);
 162     PropertySlot slot(baseValue, PropertySlot::InternalMethodType::VMInquiry);
 163     baseValue.getPropertySlot(exec, ident, slot);
 164 
 165     return JSValue::encode(slot.getPureResult());
 166 }
 167 
 168 
 169 EncodedJSValue JIT_OPERATION operationTryGetByIdGeneric(ExecState* exec, EncodedJSValue base, UniquedStringImpl* uid)
 170 {
<span class="line-modified"> 171     VM&amp; vm = exec-&gt;vm();</span>
 172     NativeCallFrameTracer tracer(vm, exec);
 173     Identifier ident = Identifier::fromUid(vm, uid);
 174 
 175     JSValue baseValue = JSValue::decode(base);
 176     PropertySlot slot(baseValue, PropertySlot::InternalMethodType::VMInquiry);
 177     baseValue.getPropertySlot(exec, ident, slot);
 178 
 179     return JSValue::encode(slot.getPureResult());
 180 }
 181 
 182 EncodedJSValue JIT_OPERATION operationTryGetByIdOptimize(ExecState* exec, StructureStubInfo* stubInfo, EncodedJSValue base, UniquedStringImpl* uid)
 183 {
<span class="line-modified"> 184     VM&amp; vm = exec-&gt;vm();</span>
 185     NativeCallFrameTracer tracer(vm, exec);
<span class="line-modified"> 186     auto scope = DECLARE_THROW_SCOPE(vm);</span>
 187     Identifier ident = Identifier::fromUid(vm, uid);
 188 
 189     JSValue baseValue = JSValue::decode(base);
 190     PropertySlot slot(baseValue, PropertySlot::InternalMethodType::VMInquiry);
 191 
 192     baseValue.getPropertySlot(exec, ident, slot);
 193     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 194 
<span class="line-modified"> 195     if (stubInfo-&gt;considerCaching(vm, exec-&gt;codeBlock(), baseValue.structureOrNull()) &amp;&amp; !slot.isTaintedByOpaqueObject() &amp;&amp; (slot.isCacheableValue() || slot.isCacheableGetter() || slot.isUnset()))</span>
 196         repatchGetByID(exec, baseValue, ident, slot, *stubInfo, GetByIDKind::Try);
 197 
 198     return JSValue::encode(slot.getPureResult());
 199 }
 200 
 201 EncodedJSValue JIT_OPERATION operationGetByIdDirect(ExecState* exec, StructureStubInfo* stubInfo, EncodedJSValue base, UniquedStringImpl* uid)
 202 {
 203     VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 204     NativeCallFrameTracer tracer(vm, exec);</span>
 205     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified"> 206     Identifier ident = Identifier::fromUid(vm, uid);</span>
 207     stubInfo-&gt;tookSlowPath = true;
 208 
 209     JSValue baseValue = JSValue::decode(base);
 210     PropertySlot slot(baseValue, PropertySlot::InternalMethodType::GetOwnProperty);
 211 
 212     bool found = baseValue.getOwnPropertySlot(exec, ident, slot);
 213     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 214 
 215     RELEASE_AND_RETURN(scope, JSValue::encode(found ? slot.getValue(exec, ident) : jsUndefined()));
 216 }
 217 
 218 EncodedJSValue JIT_OPERATION operationGetByIdDirectGeneric(ExecState* exec, EncodedJSValue base, UniquedStringImpl* uid)
 219 {
 220     VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 221     NativeCallFrameTracer tracer(vm, exec);</span>
 222     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified"> 223     Identifier ident = Identifier::fromUid(vm, uid);</span>
 224 
 225     JSValue baseValue = JSValue::decode(base);
 226     PropertySlot slot(baseValue, PropertySlot::InternalMethodType::GetOwnProperty);
 227 
 228     bool found = baseValue.getOwnPropertySlot(exec, ident, slot);
 229     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 230 
 231     RELEASE_AND_RETURN(scope, JSValue::encode(found ? slot.getValue(exec, ident) : jsUndefined()));
 232 }
 233 
 234 EncodedJSValue JIT_OPERATION operationGetByIdDirectOptimize(ExecState* exec, StructureStubInfo* stubInfo, EncodedJSValue base, UniquedStringImpl* uid)
 235 {
 236     VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 237     NativeCallFrameTracer tracer(vm, exec);</span>
 238     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified"> 239     Identifier ident = Identifier::fromUid(vm, uid);</span>
 240 
 241     JSValue baseValue = JSValue::decode(base);
 242     PropertySlot slot(baseValue, PropertySlot::InternalMethodType::GetOwnProperty);
 243 
 244     bool found = baseValue.getOwnPropertySlot(exec, ident, slot);
 245     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 246 
<span class="line-modified"> 247     if (stubInfo-&gt;considerCaching(vm, exec-&gt;codeBlock(), baseValue.structureOrNull()))</span>
 248         repatchGetByID(exec, baseValue, ident, slot, *stubInfo, GetByIDKind::Direct);
 249 
 250     RELEASE_AND_RETURN(scope, JSValue::encode(found ? slot.getValue(exec, ident) : jsUndefined()));
 251 }
 252 
 253 EncodedJSValue JIT_OPERATION operationGetById(ExecState* exec, StructureStubInfo* stubInfo, EncodedJSValue base, UniquedStringImpl* uid)
 254 {
 255     SuperSamplerScope superSamplerScope(false);
 256 
<span class="line-modified"> 257     VM&amp; vm = exec-&gt;vm();</span>
 258     NativeCallFrameTracer tracer(vm, exec);
 259 
 260     stubInfo-&gt;tookSlowPath = true;
 261 
 262     JSValue baseValue = JSValue::decode(base);
 263     PropertySlot slot(baseValue, PropertySlot::InternalMethodType::Get);
 264     Identifier ident = Identifier::fromUid(vm, uid);
<span class="line-added"> 265     JSValue result = baseValue.get(exec, ident, slot);</span>
 266 
<span class="line-modified"> 267     LOG_IC((ICEvent::OperationGetById, baseValue.classInfoOrNull(vm), ident, baseValue == slot.slotBase()));</span>
<span class="line-modified"> 268 </span>
<span class="line-added"> 269     return JSValue::encode(result);</span>
 270 }
 271 
 272 EncodedJSValue JIT_OPERATION operationGetByIdGeneric(ExecState* exec, EncodedJSValue base, UniquedStringImpl* uid)
 273 {
 274     SuperSamplerScope superSamplerScope(false);
 275 
<span class="line-modified"> 276     VM&amp; vm = exec-&gt;vm();</span>
 277     NativeCallFrameTracer tracer(vm, exec);
 278 
 279     JSValue baseValue = JSValue::decode(base);
 280     PropertySlot slot(baseValue, PropertySlot::InternalMethodType::Get);
 281     Identifier ident = Identifier::fromUid(vm, uid);
<span class="line-modified"> 282     JSValue result = baseValue.get(exec, ident, slot);</span>
<span class="line-modified"> 283 </span>
<span class="line-added"> 284     LOG_IC((ICEvent::OperationGetByIdGeneric, baseValue.classInfoOrNull(vm), ident, baseValue == slot.slotBase()));</span>
<span class="line-added"> 285 </span>
<span class="line-added"> 286     return JSValue::encode(result);</span>
 287 }
 288 
 289 EncodedJSValue JIT_OPERATION operationGetByIdOptimize(ExecState* exec, StructureStubInfo* stubInfo, EncodedJSValue base, UniquedStringImpl* uid)
 290 {
 291     SuperSamplerScope superSamplerScope(false);
 292 
<span class="line-modified"> 293     VM&amp; vm = exec-&gt;vm();</span>
 294     NativeCallFrameTracer tracer(vm, exec);
 295     Identifier ident = Identifier::fromUid(vm, uid);
 296 
 297     JSValue baseValue = JSValue::decode(base);

 298 
 299     return JSValue::encode(baseValue.getPropertySlot(exec, ident, [&amp;] (bool found, PropertySlot&amp; slot) -&gt; JSValue {
<span class="line-modified"> 300 </span>
<span class="line-added"> 301         LOG_IC((ICEvent::OperationGetByIdOptimize, baseValue.classInfoOrNull(vm), ident, baseValue == slot.slotBase()));</span>
<span class="line-added"> 302 </span>
<span class="line-added"> 303         if (stubInfo-&gt;considerCaching(vm, exec-&gt;codeBlock(), baseValue.structureOrNull()))</span>
 304             repatchGetByID(exec, baseValue, ident, slot, *stubInfo, GetByIDKind::Normal);
 305         return found ? slot.getValue(exec, ident) : jsUndefined();
 306     }));
 307 }
 308 
 309 EncodedJSValue JIT_OPERATION operationGetByIdWithThis(ExecState* exec, StructureStubInfo* stubInfo, EncodedJSValue base, EncodedJSValue thisEncoded, UniquedStringImpl* uid)
 310 {
 311     SuperSamplerScope superSamplerScope(false);
 312 
<span class="line-modified"> 313     VM&amp; vm = exec-&gt;vm();</span>
 314     NativeCallFrameTracer tracer(vm, exec);
 315     Identifier ident = Identifier::fromUid(vm, uid);
 316 
 317     stubInfo-&gt;tookSlowPath = true;
 318 
 319     JSValue baseValue = JSValue::decode(base);
 320     JSValue thisValue = JSValue::decode(thisEncoded);
 321     PropertySlot slot(thisValue, PropertySlot::InternalMethodType::Get);
 322 
 323     return JSValue::encode(baseValue.get(exec, ident, slot));
 324 }
 325 
 326 EncodedJSValue JIT_OPERATION operationGetByIdWithThisGeneric(ExecState* exec, EncodedJSValue base, EncodedJSValue thisEncoded, UniquedStringImpl* uid)
 327 {
 328     SuperSamplerScope superSamplerScope(false);
 329 
<span class="line-modified"> 330     VM&amp; vm = exec-&gt;vm();</span>
 331     NativeCallFrameTracer tracer(vm, exec);
 332     Identifier ident = Identifier::fromUid(vm, uid);
 333 
 334     JSValue baseValue = JSValue::decode(base);
 335     JSValue thisValue = JSValue::decode(thisEncoded);
 336     PropertySlot slot(thisValue, PropertySlot::InternalMethodType::Get);
 337 
 338     return JSValue::encode(baseValue.get(exec, ident, slot));
 339 }
 340 
 341 EncodedJSValue JIT_OPERATION operationGetByIdWithThisOptimize(ExecState* exec, StructureStubInfo* stubInfo, EncodedJSValue base, EncodedJSValue thisEncoded, UniquedStringImpl* uid)
 342 {
 343     SuperSamplerScope superSamplerScope(false);
 344 
<span class="line-modified"> 345     VM&amp; vm = exec-&gt;vm();</span>
 346     NativeCallFrameTracer tracer(vm, exec);
 347     Identifier ident = Identifier::fromUid(vm, uid);
 348 
 349     JSValue baseValue = JSValue::decode(base);
 350     JSValue thisValue = JSValue::decode(thisEncoded);

 351 
 352     PropertySlot slot(thisValue, PropertySlot::InternalMethodType::Get);
 353     return JSValue::encode(baseValue.getPropertySlot(exec, ident, slot, [&amp;] (bool found, PropertySlot&amp; slot) -&gt; JSValue {
<span class="line-modified"> 354         LOG_IC((ICEvent::OperationGetByIdWithThisOptimize, baseValue.classInfoOrNull(vm), ident, baseValue == slot.slotBase()));</span>
<span class="line-added"> 355 </span>
<span class="line-added"> 356         if (stubInfo-&gt;considerCaching(vm, exec-&gt;codeBlock(), baseValue.structureOrNull()))</span>
 357             repatchGetByID(exec, baseValue, ident, slot, *stubInfo, GetByIDKind::WithThis);
 358         return found ? slot.getValue(exec, ident) : jsUndefined();
 359     }));
 360 }
 361 
 362 EncodedJSValue JIT_OPERATION operationInById(ExecState* exec, StructureStubInfo* stubInfo, EncodedJSValue base, UniquedStringImpl* uid)
 363 {
 364     SuperSamplerScope superSamplerScope(false);
 365 
 366     VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 367     NativeCallFrameTracer tracer(vm, exec);</span>
 368     auto scope = DECLARE_THROW_SCOPE(vm);
 369 
 370     stubInfo-&gt;tookSlowPath = true;
 371 
<span class="line-modified"> 372     Identifier ident = Identifier::fromUid(vm, uid);</span>
 373 
 374     JSValue baseValue = JSValue::decode(base);
 375     if (!baseValue.isObject()) {
 376         throwException(exec, scope, createInvalidInParameterError(exec, baseValue));
 377         return JSValue::encode(jsUndefined());
 378     }
 379     JSObject* baseObject = asObject(baseValue);
 380 
 381     LOG_IC((ICEvent::OperationInById, baseObject-&gt;classInfo(vm), ident));
 382 
 383     scope.release();
 384     PropertySlot slot(baseObject, PropertySlot::InternalMethodType::HasProperty);
 385     return JSValue::encode(jsBoolean(baseObject-&gt;getPropertySlot(exec, ident, slot)));
 386 }
 387 
 388 EncodedJSValue JIT_OPERATION operationInByIdGeneric(ExecState* exec, EncodedJSValue base, UniquedStringImpl* uid)
 389 {
 390     SuperSamplerScope superSamplerScope(false);
 391 
 392     VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 393     NativeCallFrameTracer tracer(vm, exec);</span>
 394     auto scope = DECLARE_THROW_SCOPE(vm);
 395 
<span class="line-modified"> 396     Identifier ident = Identifier::fromUid(vm, uid);</span>
 397 
 398     JSValue baseValue = JSValue::decode(base);
 399     if (!baseValue.isObject()) {
 400         throwException(exec, scope, createInvalidInParameterError(exec, baseValue));
 401         return JSValue::encode(jsUndefined());
 402     }
 403     JSObject* baseObject = asObject(baseValue);
 404 
 405     LOG_IC((ICEvent::OperationInByIdGeneric, baseObject-&gt;classInfo(vm), ident));
 406 
 407     scope.release();
 408     PropertySlot slot(baseObject, PropertySlot::InternalMethodType::HasProperty);
 409     return JSValue::encode(jsBoolean(baseObject-&gt;getPropertySlot(exec, ident, slot)));
 410 }
 411 
 412 EncodedJSValue JIT_OPERATION operationInByIdOptimize(ExecState* exec, StructureStubInfo* stubInfo, EncodedJSValue base, UniquedStringImpl* uid)
 413 {
 414     SuperSamplerScope superSamplerScope(false);
 415 
 416     VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 417     NativeCallFrameTracer tracer(vm, exec);</span>
 418     auto scope = DECLARE_THROW_SCOPE(vm);
 419 
<span class="line-modified"> 420     Identifier ident = Identifier::fromUid(vm, uid);</span>
 421 
 422     JSValue baseValue = JSValue::decode(base);
 423     if (!baseValue.isObject()) {
 424         throwException(exec, scope, createInvalidInParameterError(exec, baseValue));
 425         return JSValue::encode(jsUndefined());
 426     }
 427     JSObject* baseObject = asObject(baseValue);
 428 
 429     LOG_IC((ICEvent::OperationInByIdOptimize, baseObject-&gt;classInfo(vm), ident));
 430 
 431     scope.release();
 432     PropertySlot slot(baseObject, PropertySlot::InternalMethodType::HasProperty);
 433     bool found = baseObject-&gt;getPropertySlot(exec, ident, slot);
<span class="line-modified"> 434     if (stubInfo-&gt;considerCaching(vm, exec-&gt;codeBlock(), baseObject-&gt;structure(vm)))</span>
 435         repatchInByID(exec, baseObject, ident, found, slot, *stubInfo);
 436     return JSValue::encode(jsBoolean(found));
 437 }
 438 
 439 EncodedJSValue JIT_OPERATION operationInByVal(ExecState* exec, JSCell* base, EncodedJSValue key)
 440 {
 441     SuperSamplerScope superSamplerScope(false);
 442 
<span class="line-modified"> 443     VM&amp; vm = exec-&gt;vm();</span>
 444     NativeCallFrameTracer tracer(vm, exec);
 445 
 446     return JSValue::encode(jsBoolean(CommonSlowPaths::opInByVal(exec, base, JSValue::decode(key))));
 447 }
 448 
 449 void JIT_OPERATION operationPutByIdStrict(ExecState* exec, StructureStubInfo* stubInfo, EncodedJSValue encodedValue, EncodedJSValue encodedBase, UniquedStringImpl* uid)
 450 {
 451     SuperSamplerScope superSamplerScope(false);
 452 
<span class="line-modified"> 453     VM&amp; vm = exec-&gt;vm();</span>
 454     NativeCallFrameTracer tracer(vm, exec);
 455 
 456     stubInfo-&gt;tookSlowPath = true;
 457 
 458     JSValue baseValue = JSValue::decode(encodedBase);
 459     Identifier ident = Identifier::fromUid(vm, uid);


 460     PutPropertySlot slot(baseValue, true, exec-&gt;codeBlock()-&gt;putByIdContext());
 461     baseValue.putInline(exec, ident, JSValue::decode(encodedValue), slot);
<span class="line-added"> 462 </span>
<span class="line-added"> 463     LOG_IC((ICEvent::OperationPutByIdStrict, baseValue.classInfoOrNull(vm), ident, slot.base() == baseValue));</span>
 464 }
 465 
 466 void JIT_OPERATION operationPutByIdNonStrict(ExecState* exec, StructureStubInfo* stubInfo, EncodedJSValue encodedValue, EncodedJSValue encodedBase, UniquedStringImpl* uid)
 467 {
 468     SuperSamplerScope superSamplerScope(false);
 469 
<span class="line-modified"> 470     VM&amp; vm = exec-&gt;vm();</span>
 471     NativeCallFrameTracer tracer(vm, exec);
 472 
 473     stubInfo-&gt;tookSlowPath = true;
 474 
 475     JSValue baseValue = JSValue::decode(encodedBase);
 476     Identifier ident = Identifier::fromUid(vm, uid);

 477     PutPropertySlot slot(baseValue, false, exec-&gt;codeBlock()-&gt;putByIdContext());
 478     baseValue.putInline(exec, ident, JSValue::decode(encodedValue), slot);
<span class="line-added"> 479 </span>
<span class="line-added"> 480     LOG_IC((ICEvent::OperationPutByIdNonStrict, baseValue.classInfoOrNull(vm), ident, slot.base() == baseValue));</span>
 481 }
 482 
 483 void JIT_OPERATION operationPutByIdDirectStrict(ExecState* exec, StructureStubInfo* stubInfo, EncodedJSValue encodedValue, EncodedJSValue encodedBase, UniquedStringImpl* uid)
 484 {
 485     SuperSamplerScope superSamplerScope(false);
 486 
 487     VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 488     NativeCallFrameTracer tracer(vm, exec);</span>
 489 
 490     stubInfo-&gt;tookSlowPath = true;
 491 
 492     JSValue baseValue = JSValue::decode(encodedBase);
<span class="line-modified"> 493     Identifier ident = Identifier::fromUid(vm, uid);</span>

 494     PutPropertySlot slot(baseValue, true, exec-&gt;codeBlock()-&gt;putByIdContext());
 495     CommonSlowPaths::putDirectWithReify(vm, exec, asObject(baseValue), ident, JSValue::decode(encodedValue), slot);
<span class="line-added"> 496 </span>
<span class="line-added"> 497     LOG_IC((ICEvent::OperationPutByIdDirectStrict, baseValue.classInfoOrNull(vm), ident, slot.base() == baseValue));</span>
 498 }
 499 
 500 void JIT_OPERATION operationPutByIdDirectNonStrict(ExecState* exec, StructureStubInfo* stubInfo, EncodedJSValue encodedValue, EncodedJSValue encodedBase, UniquedStringImpl* uid)
 501 {
 502     SuperSamplerScope superSamplerScope(false);
 503 
 504     VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 505     NativeCallFrameTracer tracer(vm, exec);</span>
 506 
 507     stubInfo-&gt;tookSlowPath = true;
 508 
 509     JSValue baseValue = JSValue::decode(encodedBase);
<span class="line-modified"> 510     Identifier ident = Identifier::fromUid(vm, uid);</span>

 511     PutPropertySlot slot(baseValue, false, exec-&gt;codeBlock()-&gt;putByIdContext());
 512     CommonSlowPaths::putDirectWithReify(vm, exec, asObject(baseValue), ident, JSValue::decode(encodedValue), slot);
<span class="line-added"> 513 </span>
<span class="line-added"> 514     LOG_IC((ICEvent::OperationPutByIdDirectNonStrict, baseValue.classInfoOrNull(vm), ident, slot.base() == baseValue));</span>
 515 }
 516 
 517 void JIT_OPERATION operationPutByIdStrictOptimize(ExecState* exec, StructureStubInfo* stubInfo, EncodedJSValue encodedValue, EncodedJSValue encodedBase, UniquedStringImpl* uid)
 518 {
 519     SuperSamplerScope superSamplerScope(false);
 520 
<span class="line-modified"> 521     VM&amp; vm = exec-&gt;vm();</span>
 522     NativeCallFrameTracer tracer(vm, exec);
<span class="line-modified"> 523     auto scope = DECLARE_THROW_SCOPE(vm);</span>
 524 
 525     Identifier ident = Identifier::fromUid(vm, uid);
 526     AccessType accessType = static_cast&lt;AccessType&gt;(stubInfo-&gt;accessType);
 527 
 528     JSValue value = JSValue::decode(encodedValue);
 529     JSValue baseValue = JSValue::decode(encodedBase);

 530     CodeBlock* codeBlock = exec-&gt;codeBlock();
 531     PutPropertySlot slot(baseValue, true, codeBlock-&gt;putByIdContext());
 532 
<span class="line-modified"> 533     Structure* structure = baseValue.isCell() ? baseValue.asCell()-&gt;structure(vm) : nullptr;</span>
 534     baseValue.putInline(exec, ident, value, slot);
<span class="line-added"> 535 </span>
<span class="line-added"> 536     LOG_IC((ICEvent::OperationPutByIdStrictOptimize, baseValue.classInfoOrNull(vm), ident, slot.base() == baseValue));</span>
<span class="line-added"> 537 </span>
 538     RETURN_IF_EXCEPTION(scope, void());
 539 
 540     if (accessType != static_cast&lt;AccessType&gt;(stubInfo-&gt;accessType))
 541         return;
 542 
<span class="line-modified"> 543     if (stubInfo-&gt;considerCaching(vm, codeBlock, structure))</span>
 544         repatchPutByID(exec, baseValue, structure, ident, slot, *stubInfo, NotDirect);
 545 }
 546 
 547 void JIT_OPERATION operationPutByIdNonStrictOptimize(ExecState* exec, StructureStubInfo* stubInfo, EncodedJSValue encodedValue, EncodedJSValue encodedBase, UniquedStringImpl* uid)
 548 {
 549     SuperSamplerScope superSamplerScope(false);
 550 
<span class="line-modified"> 551     VM&amp; vm = exec-&gt;vm();</span>
 552     NativeCallFrameTracer tracer(vm, exec);
<span class="line-modified"> 553     auto scope = DECLARE_THROW_SCOPE(vm);</span>
 554 
 555     Identifier ident = Identifier::fromUid(vm, uid);
 556     AccessType accessType = static_cast&lt;AccessType&gt;(stubInfo-&gt;accessType);
 557 
 558     JSValue value = JSValue::decode(encodedValue);
 559     JSValue baseValue = JSValue::decode(encodedBase);

 560     CodeBlock* codeBlock = exec-&gt;codeBlock();
 561     PutPropertySlot slot(baseValue, false, codeBlock-&gt;putByIdContext());
 562 
<span class="line-modified"> 563     Structure* structure = baseValue.isCell() ? baseValue.asCell()-&gt;structure(vm) : nullptr;</span>
 564     baseValue.putInline(exec, ident, value, slot);
<span class="line-added"> 565 </span>
<span class="line-added"> 566     LOG_IC((ICEvent::OperationPutByIdNonStrictOptimize, baseValue.classInfoOrNull(vm), ident, slot.base() == baseValue));</span>
<span class="line-added"> 567 </span>
 568     RETURN_IF_EXCEPTION(scope, void());
 569 
 570     if (accessType != static_cast&lt;AccessType&gt;(stubInfo-&gt;accessType))
 571         return;
 572 
<span class="line-modified"> 573     if (stubInfo-&gt;considerCaching(vm, codeBlock, structure))</span>
 574         repatchPutByID(exec, baseValue, structure, ident, slot, *stubInfo, NotDirect);
 575 }
 576 
 577 void JIT_OPERATION operationPutByIdDirectStrictOptimize(ExecState* exec, StructureStubInfo* stubInfo, EncodedJSValue encodedValue, EncodedJSValue encodedBase, UniquedStringImpl* uid)
 578 {
 579     SuperSamplerScope superSamplerScope(false);
 580 
 581     VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 582     NativeCallFrameTracer tracer(vm, exec);</span>
 583     auto scope = DECLARE_THROW_SCOPE(vm);
 584 
<span class="line-modified"> 585     Identifier ident = Identifier::fromUid(vm, uid);</span>
 586     AccessType accessType = static_cast&lt;AccessType&gt;(stubInfo-&gt;accessType);
 587 
 588     JSValue value = JSValue::decode(encodedValue);
 589     JSObject* baseObject = asObject(JSValue::decode(encodedBase));

 590     CodeBlock* codeBlock = exec-&gt;codeBlock();
 591     PutPropertySlot slot(baseObject, true, codeBlock-&gt;putByIdContext());
 592     Structure* structure = nullptr;
 593     CommonSlowPaths::putDirectWithReify(vm, exec, baseObject, ident, value, slot, &amp;structure);
<span class="line-added"> 594 </span>
<span class="line-added"> 595     LOG_IC((ICEvent::OperationPutByIdDirectStrictOptimize, baseObject-&gt;classInfo(vm), ident, slot.base() == baseObject));</span>
<span class="line-added"> 596 </span>
 597     RETURN_IF_EXCEPTION(scope, void());
 598 
 599     if (accessType != static_cast&lt;AccessType&gt;(stubInfo-&gt;accessType))
 600         return;
 601 
<span class="line-modified"> 602     if (stubInfo-&gt;considerCaching(vm, codeBlock, structure))</span>
 603         repatchPutByID(exec, baseObject, structure, ident, slot, *stubInfo, Direct);
 604 }
 605 
 606 void JIT_OPERATION operationPutByIdDirectNonStrictOptimize(ExecState* exec, StructureStubInfo* stubInfo, EncodedJSValue encodedValue, EncodedJSValue encodedBase, UniquedStringImpl* uid)
 607 {
 608     SuperSamplerScope superSamplerScope(false);
 609 
 610     VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 611     NativeCallFrameTracer tracer(vm, exec);</span>
 612     auto scope = DECLARE_THROW_SCOPE(vm);
 613 
<span class="line-modified"> 614     Identifier ident = Identifier::fromUid(vm, uid);</span>
 615     AccessType accessType = static_cast&lt;AccessType&gt;(stubInfo-&gt;accessType);
 616 
 617     JSValue value = JSValue::decode(encodedValue);
 618     JSObject* baseObject = asObject(JSValue::decode(encodedBase));

 619     CodeBlock* codeBlock = exec-&gt;codeBlock();
 620     PutPropertySlot slot(baseObject, false, codeBlock-&gt;putByIdContext());
 621     Structure* structure = nullptr;
 622     CommonSlowPaths::putDirectWithReify(vm, exec, baseObject, ident, value, slot, &amp;structure);
<span class="line-added"> 623 </span>
<span class="line-added"> 624     LOG_IC((ICEvent::OperationPutByIdDirectNonStrictOptimize, baseObject-&gt;classInfo(vm), ident, slot.base() == baseObject));</span>
<span class="line-added"> 625 </span>
 626     RETURN_IF_EXCEPTION(scope, void());
 627 
 628     if (accessType != static_cast&lt;AccessType&gt;(stubInfo-&gt;accessType))
 629         return;
 630 
<span class="line-modified"> 631     if (stubInfo-&gt;considerCaching(vm, codeBlock, structure))</span>
 632         repatchPutByID(exec, baseObject, structure, ident, slot, *stubInfo, Direct);
 633 }
 634 
 635 ALWAYS_INLINE static bool isStringOrSymbol(JSValue value)
 636 {
 637     return value.isString() || value.isSymbol();
 638 }
 639 
 640 static void putByVal(CallFrame* callFrame, JSValue baseValue, JSValue subscript, JSValue value, ByValInfo* byValInfo)
 641 {
 642     VM&amp; vm = callFrame-&gt;vm();
 643     auto scope = DECLARE_THROW_SCOPE(vm);
 644     if (LIKELY(subscript.isUInt32())) {
 645         byValInfo-&gt;tookSlowPath = true;
 646         uint32_t i = subscript.asUInt32();
 647         if (baseValue.isObject()) {
 648             JSObject* object = asObject(baseValue);
<span class="line-modified"> 649             if (object-&gt;canSetIndexQuickly(i, value)) {</span>
 650                 object-&gt;setIndexQuickly(vm, i, value);
 651                 return;
 652             }
 653 



 654             byValInfo-&gt;arrayProfile-&gt;setOutOfBounds();
 655             scope.release();
 656             object-&gt;methodTable(vm)-&gt;putByIndex(object, callFrame, i, value, callFrame-&gt;codeBlock()-&gt;isStrictMode());
 657             return;
 658         }
 659 
 660         scope.release();
 661         baseValue.putByIndex(callFrame, i, value, callFrame-&gt;codeBlock()-&gt;isStrictMode());
 662         return;
<span class="line-added"> 663     } else if (subscript.isInt32()) {</span>
<span class="line-added"> 664         byValInfo-&gt;tookSlowPath = true;</span>
<span class="line-added"> 665         if (baseValue.isObject())</span>
<span class="line-added"> 666             byValInfo-&gt;arrayProfile-&gt;setOutOfBounds();</span>
 667     }
 668 
 669     auto property = subscript.toPropertyKey(callFrame);
 670     // Don&#39;t put to an object if toString threw an exception.
 671     RETURN_IF_EXCEPTION(scope, void());
 672 
 673     if (byValInfo-&gt;stubInfo &amp;&amp; (!isStringOrSymbol(subscript) || byValInfo-&gt;cachedId != property))
 674         byValInfo-&gt;tookSlowPath = true;
 675 
 676     scope.release();
 677     PutPropertySlot slot(baseValue, callFrame-&gt;codeBlock()-&gt;isStrictMode());
 678     baseValue.putInline(callFrame, property, value, slot);
 679 }
 680 
 681 static void directPutByVal(CallFrame* callFrame, JSObject* baseObject, JSValue subscript, JSValue value, ByValInfo* byValInfo)
 682 {
 683     VM&amp; vm = callFrame-&gt;vm();
 684     auto scope = DECLARE_THROW_SCOPE(vm);
 685     bool isStrictMode = callFrame-&gt;codeBlock()-&gt;isStrictMode();
 686 
</pre>
<hr />
<pre>
 734         byValInfo-&gt;tookSlowPath = true;
 735 
 736     scope.release();
 737     PutPropertySlot slot(baseObject, isStrictMode);
 738     CommonSlowPaths::putDirectWithReify(vm, callFrame, baseObject, property, value, slot);
 739 }
 740 
 741 enum class OptimizationResult {
 742     NotOptimized,
 743     SeenOnce,
 744     Optimized,
 745     GiveUp,
 746 };
 747 
 748 static OptimizationResult tryPutByValOptimize(ExecState* exec, JSValue baseValue, JSValue subscript, ByValInfo* byValInfo, ReturnAddressPtr returnAddress)
 749 {
 750     // See if it&#39;s worth optimizing at all.
 751     OptimizationResult optimizationResult = OptimizationResult::NotOptimized;
 752 
 753     VM&amp; vm = exec-&gt;vm();
<span class="line-added"> 754     auto scope = DECLARE_THROW_SCOPE(vm);</span>
 755 
 756     if (baseValue.isObject() &amp;&amp; isCopyOnWrite(baseValue.getObject()-&gt;indexingMode()))
 757         return OptimizationResult::GiveUp;
 758 
 759     if (baseValue.isObject() &amp;&amp; subscript.isInt32()) {
 760         JSObject* object = asObject(baseValue);
 761 
 762         ASSERT(exec-&gt;bytecodeOffset());
 763         ASSERT(!byValInfo-&gt;stubRoutine);
 764 
 765         Structure* structure = object-&gt;structure(vm);
 766         if (hasOptimizableIndexing(structure)) {
 767             // Attempt to optimize.
 768             JITArrayMode arrayMode = jitArrayModeForStructure(structure);
 769             if (jitArrayModePermitsPut(arrayMode) &amp;&amp; arrayMode != byValInfo-&gt;arrayMode) {
 770                 CodeBlock* codeBlock = exec-&gt;codeBlock();
 771                 ConcurrentJSLocker locker(codeBlock-&gt;m_lock);
 772                 byValInfo-&gt;arrayProfile-&gt;computeUpdatedPrediction(locker, codeBlock, structure);
<span class="line-modified"> 773                 JIT::compilePutByVal(locker, vm, codeBlock, byValInfo, returnAddress, arrayMode);</span>
 774                 optimizationResult = OptimizationResult::Optimized;
 775             }
 776         }
 777 
 778         // If we failed to patch and we have some object that intercepts indexed get, then don&#39;t even wait until 10 times.
 779         if (optimizationResult != OptimizationResult::Optimized &amp;&amp; object-&gt;structure(vm)-&gt;typeInfo().interceptsGetOwnPropertySlotByIndexEvenWhenLengthIsNotZero())
 780             optimizationResult = OptimizationResult::GiveUp;
 781     }
 782 
 783     if (baseValue.isObject() &amp;&amp; isStringOrSymbol(subscript)) {
 784         const Identifier propertyName = subscript.toPropertyKey(exec);
<span class="line-added"> 785         RETURN_IF_EXCEPTION(scope, OptimizationResult::GiveUp);</span>
 786         if (subscript.isSymbol() || !parseIndex(propertyName)) {
 787             ASSERT(exec-&gt;bytecodeOffset());
 788             ASSERT(!byValInfo-&gt;stubRoutine);
 789             if (byValInfo-&gt;seen) {
 790                 if (byValInfo-&gt;cachedId == propertyName) {
<span class="line-modified"> 791                     JIT::compilePutByValWithCachedId&lt;OpPutByVal&gt;(vm, exec-&gt;codeBlock(), byValInfo, returnAddress, NotDirect, propertyName);</span>
 792                     optimizationResult = OptimizationResult::Optimized;
 793                 } else {
 794                     // Seem like a generic property access site.
 795                     optimizationResult = OptimizationResult::GiveUp;
 796                 }
 797             } else {
 798                 CodeBlock* codeBlock = exec-&gt;codeBlock();
 799                 ConcurrentJSLocker locker(codeBlock-&gt;m_lock);
 800                 byValInfo-&gt;seen = true;
 801                 byValInfo-&gt;cachedId = propertyName;
 802                 if (subscript.isSymbol())
 803                     byValInfo-&gt;cachedSymbol.set(vm, codeBlock, asSymbol(subscript));
 804                 optimizationResult = OptimizationResult::SeenOnce;
 805             }
 806         }
 807     }
 808 
 809     if (optimizationResult != OptimizationResult::Optimized &amp;&amp; optimizationResult != OptimizationResult::SeenOnce) {
 810         // If we take slow path more than 10 times without patching then make sure we
 811         // never make that mistake again. For cases where we see non-index-intercepting
 812         // objects, this gives 10 iterations worth of opportunity for us to observe
 813         // that the put_by_val may be polymorphic. We count up slowPathCount even if
 814         // the result is GiveUp.
 815         if (++byValInfo-&gt;slowPathCount &gt;= 10)
 816             optimizationResult = OptimizationResult::GiveUp;
 817     }
 818 
 819     return optimizationResult;
 820 }
 821 
 822 void JIT_OPERATION operationPutByValOptimize(ExecState* exec, EncodedJSValue encodedBaseValue, EncodedJSValue encodedSubscript, EncodedJSValue encodedValue, ByValInfo* byValInfo)
 823 {
 824     VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 825     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-added"> 826     auto scope = DECLARE_THROW_SCOPE(vm);</span>
 827 
 828     JSValue baseValue = JSValue::decode(encodedBaseValue);
 829     JSValue subscript = JSValue::decode(encodedSubscript);
 830     JSValue value = JSValue::decode(encodedValue);
<span class="line-modified"> 831     OptimizationResult result = tryPutByValOptimize(exec, baseValue, subscript, byValInfo, ReturnAddressPtr(OUR_RETURN_ADDRESS));</span>
<span class="line-added"> 832     RETURN_IF_EXCEPTION(scope, void());</span>
<span class="line-added"> 833     if (result == OptimizationResult::GiveUp) {</span>
 834         // Don&#39;t ever try to optimize.
 835         byValInfo-&gt;tookSlowPath = true;
 836         ctiPatchCallByReturnAddress(ReturnAddressPtr(OUR_RETURN_ADDRESS), operationPutByValGeneric);
 837     }
<span class="line-modified"> 838     RELEASE_AND_RETURN(scope, putByVal(exec, baseValue, subscript, value, byValInfo));</span>
 839 }
 840 
 841 static OptimizationResult tryDirectPutByValOptimize(ExecState* exec, JSObject* object, JSValue subscript, ByValInfo* byValInfo, ReturnAddressPtr returnAddress)
 842 {
 843     // See if it&#39;s worth optimizing at all.
 844     OptimizationResult optimizationResult = OptimizationResult::NotOptimized;
 845 
 846     VM&amp; vm = exec-&gt;vm();
<span class="line-added"> 847     auto scope = DECLARE_THROW_SCOPE(vm);</span>
 848 
 849     if (subscript.isInt32()) {
 850         ASSERT(exec-&gt;bytecodeOffset());
 851         ASSERT(!byValInfo-&gt;stubRoutine);
 852 
 853         Structure* structure = object-&gt;structure(vm);
 854         if (hasOptimizableIndexing(structure)) {
 855             // Attempt to optimize.
 856             JITArrayMode arrayMode = jitArrayModeForStructure(structure);
 857             if (jitArrayModePermitsPutDirect(arrayMode) &amp;&amp; arrayMode != byValInfo-&gt;arrayMode) {
 858                 CodeBlock* codeBlock = exec-&gt;codeBlock();
 859                 ConcurrentJSLocker locker(codeBlock-&gt;m_lock);
 860                 byValInfo-&gt;arrayProfile-&gt;computeUpdatedPrediction(locker, codeBlock, structure);
 861 
<span class="line-modified"> 862                 JIT::compileDirectPutByVal(locker, vm, codeBlock, byValInfo, returnAddress, arrayMode);</span>
 863                 optimizationResult = OptimizationResult::Optimized;
 864             }
 865         }
 866 
 867         // If we failed to patch and we have some object that intercepts indexed get, then don&#39;t even wait until 10 times.
 868         if (optimizationResult != OptimizationResult::Optimized &amp;&amp; object-&gt;structure(vm)-&gt;typeInfo().interceptsGetOwnPropertySlotByIndexEvenWhenLengthIsNotZero())
 869             optimizationResult = OptimizationResult::GiveUp;
 870     } else if (isStringOrSymbol(subscript)) {
 871         const Identifier propertyName = subscript.toPropertyKey(exec);
<span class="line-added"> 872         RETURN_IF_EXCEPTION(scope, OptimizationResult::GiveUp);</span>
 873         if (subscript.isSymbol() || !parseIndex(propertyName)) {
 874             ASSERT(exec-&gt;bytecodeOffset());
 875             ASSERT(!byValInfo-&gt;stubRoutine);
 876             if (byValInfo-&gt;seen) {
 877                 if (byValInfo-&gt;cachedId == propertyName) {
<span class="line-modified"> 878                     JIT::compilePutByValWithCachedId&lt;OpPutByValDirect&gt;(vm, exec-&gt;codeBlock(), byValInfo, returnAddress, Direct, propertyName);</span>
 879                     optimizationResult = OptimizationResult::Optimized;
 880                 } else {
 881                     // Seem like a generic property access site.
 882                     optimizationResult = OptimizationResult::GiveUp;
 883                 }
 884             } else {
 885                 CodeBlock* codeBlock = exec-&gt;codeBlock();
 886                 ConcurrentJSLocker locker(codeBlock-&gt;m_lock);
 887                 byValInfo-&gt;seen = true;
 888                 byValInfo-&gt;cachedId = propertyName;
 889                 if (subscript.isSymbol())
 890                     byValInfo-&gt;cachedSymbol.set(vm, codeBlock, asSymbol(subscript));
 891                 optimizationResult = OptimizationResult::SeenOnce;
 892             }
 893         }
 894     }
 895 
 896     if (optimizationResult != OptimizationResult::Optimized &amp;&amp; optimizationResult != OptimizationResult::SeenOnce) {
 897         // If we take slow path more than 10 times without patching then make sure we
 898         // never make that mistake again. For cases where we see non-index-intercepting
 899         // objects, this gives 10 iterations worth of opportunity for us to observe
 900         // that the get_by_val may be polymorphic. We count up slowPathCount even if
 901         // the result is GiveUp.
 902         if (++byValInfo-&gt;slowPathCount &gt;= 10)
 903             optimizationResult = OptimizationResult::GiveUp;
 904     }
 905 
 906     return optimizationResult;
 907 }
 908 
 909 void JIT_OPERATION operationDirectPutByValOptimize(ExecState* exec, EncodedJSValue encodedBaseValue, EncodedJSValue encodedSubscript, EncodedJSValue encodedValue, ByValInfo* byValInfo)
 910 {
 911     VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 912     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-added"> 913     auto scope = DECLARE_THROW_SCOPE(vm);</span>
 914 
 915     JSValue baseValue = JSValue::decode(encodedBaseValue);
 916     JSValue subscript = JSValue::decode(encodedSubscript);
 917     JSValue value = JSValue::decode(encodedValue);
 918     RELEASE_ASSERT(baseValue.isObject());
 919     JSObject* object = asObject(baseValue);
<span class="line-modified"> 920     OptimizationResult result = tryDirectPutByValOptimize(exec, object, subscript, byValInfo, ReturnAddressPtr(OUR_RETURN_ADDRESS));</span>
<span class="line-added"> 921     RETURN_IF_EXCEPTION(scope, void());</span>
<span class="line-added"> 922     if (result == OptimizationResult::GiveUp) {</span>
 923         // Don&#39;t ever try to optimize.
 924         byValInfo-&gt;tookSlowPath = true;
 925         ctiPatchCallByReturnAddress(ReturnAddressPtr(OUR_RETURN_ADDRESS), operationDirectPutByValGeneric);
 926     }
 927 
<span class="line-modified"> 928     RELEASE_AND_RETURN(scope, directPutByVal(exec, object, subscript, value, byValInfo));</span>
 929 }
 930 
 931 void JIT_OPERATION operationPutByValGeneric(ExecState* exec, EncodedJSValue encodedBaseValue, EncodedJSValue encodedSubscript, EncodedJSValue encodedValue, ByValInfo* byValInfo)
 932 {
 933     VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 934     NativeCallFrameTracer tracer(vm, exec);</span>
 935 
 936     JSValue baseValue = JSValue::decode(encodedBaseValue);
 937     JSValue subscript = JSValue::decode(encodedSubscript);
 938     JSValue value = JSValue::decode(encodedValue);
 939 
 940     putByVal(exec, baseValue, subscript, value, byValInfo);
 941 }
 942 
 943 
 944 void JIT_OPERATION operationDirectPutByValGeneric(ExecState* exec, EncodedJSValue encodedBaseValue, EncodedJSValue encodedSubscript, EncodedJSValue encodedValue, ByValInfo* byValInfo)
 945 {
 946     VM&amp; vm = exec-&gt;vm();
<span class="line-modified"> 947     NativeCallFrameTracer tracer(vm, exec);</span>
 948 
 949     JSValue baseValue = JSValue::decode(encodedBaseValue);
 950     JSValue subscript = JSValue::decode(encodedSubscript);
 951     JSValue value = JSValue::decode(encodedValue);
 952     RELEASE_ASSERT(baseValue.isObject());
 953     directPutByVal(exec, asObject(baseValue), subscript, value, byValInfo);
 954 }
 955 
 956 EncodedJSValue JIT_OPERATION operationCallEval(ExecState* exec, ExecState* execCallee)
 957 {
<span class="line-modified"> 958     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 959     auto scope = DECLARE_THROW_SCOPE(vm);</span>
 960 
 961     execCallee-&gt;setCodeBlock(0);
 962 
 963     if (!isHostFunction(execCallee-&gt;guaranteedJSValueCallee(), globalFuncEval))
 964         return JSValue::encode(JSValue());
 965 
 966     JSValue result = eval(execCallee);
 967     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 968 
 969     return JSValue::encode(result);
 970 }
 971 
 972 static SlowPathReturnType handleHostCall(ExecState* execCallee, JSValue callee, CallLinkInfo* callLinkInfo)
 973 {
 974     ExecState* exec = execCallee-&gt;callerFrame();
<span class="line-modified"> 975     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 976     auto scope = DECLARE_THROW_SCOPE(vm);</span>
 977 
 978     execCallee-&gt;setCodeBlock(0);
 979 
 980     if (callLinkInfo-&gt;specializationKind() == CodeForCall) {
 981         CallData callData;
<span class="line-modified"> 982         CallType callType = getCallData(vm, callee, callData);</span>
 983 
 984         ASSERT(callType != CallType::JS);
 985 
 986         if (callType == CallType::Host) {
 987             NativeCallFrameTracer tracer(vm, execCallee);
 988             execCallee-&gt;setCallee(asObject(callee));
<span class="line-modified"> 989             vm.hostCallReturnValue = JSValue::decode(callData.native.function(execCallee));</span>
 990             if (UNLIKELY(scope.exception())) {
 991                 return encodeResult(
<span class="line-modified"> 992                     vm.getCTIStub(throwExceptionFromCallSlowPathGenerator).retaggedCode&lt;JSEntryPtrTag&gt;().executableAddress(),</span>
 993                     reinterpret_cast&lt;void*&gt;(KeepTheFrame));
 994             }
 995 
 996             return encodeResult(
 997                 tagCFunctionPtr&lt;void*, JSEntryPtrTag&gt;(getHostCallReturnValue),
 998                 reinterpret_cast&lt;void*&gt;(callLinkInfo-&gt;callMode() == CallMode::Tail ? ReuseTheFrame : KeepTheFrame));
 999         }
1000 
1001         ASSERT(callType == CallType::None);
1002         throwException(exec, scope, createNotAFunctionError(exec, callee));
1003         return encodeResult(
<span class="line-modified">1004             vm.getCTIStub(throwExceptionFromCallSlowPathGenerator).retaggedCode&lt;JSEntryPtrTag&gt;().executableAddress(),</span>
1005             reinterpret_cast&lt;void*&gt;(KeepTheFrame));
1006     }
1007 
1008     ASSERT(callLinkInfo-&gt;specializationKind() == CodeForConstruct);
1009 
1010     ConstructData constructData;
<span class="line-modified">1011     ConstructType constructType = getConstructData(vm, callee, constructData);</span>
1012 
1013     ASSERT(constructType != ConstructType::JS);
1014 
1015     if (constructType == ConstructType::Host) {
1016         NativeCallFrameTracer tracer(vm, execCallee);
1017         execCallee-&gt;setCallee(asObject(callee));
<span class="line-modified">1018         vm.hostCallReturnValue = JSValue::decode(constructData.native.function(execCallee));</span>
1019         if (UNLIKELY(scope.exception())) {
1020             return encodeResult(
<span class="line-modified">1021                 vm.getCTIStub(throwExceptionFromCallSlowPathGenerator).retaggedCode&lt;JSEntryPtrTag&gt;().executableAddress(),</span>
1022                 reinterpret_cast&lt;void*&gt;(KeepTheFrame));
1023         }
1024 
1025         return encodeResult(tagCFunctionPtr&lt;void*, JSEntryPtrTag&gt;(getHostCallReturnValue), reinterpret_cast&lt;void*&gt;(KeepTheFrame));
1026     }
1027 
1028     ASSERT(constructType == ConstructType::None);
1029     throwException(exec, scope, createNotAConstructorError(exec, callee));
1030     return encodeResult(
<span class="line-modified">1031         vm.getCTIStub(throwExceptionFromCallSlowPathGenerator).retaggedCode&lt;JSEntryPtrTag&gt;().executableAddress(),</span>
1032         reinterpret_cast&lt;void*&gt;(KeepTheFrame));
1033 }
1034 
1035 SlowPathReturnType JIT_OPERATION operationLinkCall(ExecState* execCallee, CallLinkInfo* callLinkInfo)
1036 {
1037     ExecState* exec = execCallee-&gt;callerFrame();
<span class="line-modified">1038     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1039     auto throwScope = DECLARE_THROW_SCOPE(vm);</span>
1040 
1041     CodeSpecializationKind kind = callLinkInfo-&gt;specializationKind();
1042     NativeCallFrameTracer tracer(vm, exec);
1043 
1044     RELEASE_ASSERT(!callLinkInfo-&gt;isDirect());
1045 
1046     JSValue calleeAsValue = execCallee-&gt;guaranteedJSValueCallee();
1047     JSCell* calleeAsFunctionCell = getJSFunction(calleeAsValue);
1048     if (!calleeAsFunctionCell) {
<span class="line-modified">1049         if (auto* internalFunction = jsDynamicCast&lt;InternalFunction*&gt;(vm, calleeAsValue)) {</span>
<span class="line-modified">1050             MacroAssemblerCodePtr&lt;JSEntryPtrTag&gt; codePtr = vm.getCTIInternalFunctionTrampolineFor(kind);</span>
1051             RELEASE_ASSERT(!!codePtr);
1052 
1053             if (!callLinkInfo-&gt;seenOnce())
1054                 callLinkInfo-&gt;setSeen();
1055             else
1056                 linkFor(execCallee, *callLinkInfo, nullptr, internalFunction, codePtr);
1057 
1058             void* linkedTarget = codePtr.executableAddress();
1059             return encodeResult(linkedTarget, reinterpret_cast&lt;void*&gt;(callLinkInfo-&gt;callMode() == CallMode::Tail ? ReuseTheFrame : KeepTheFrame));
1060         }
1061         RELEASE_AND_RETURN(throwScope, handleHostCall(execCallee, calleeAsValue, callLinkInfo));
1062     }
1063 
1064     JSFunction* callee = jsCast&lt;JSFunction*&gt;(calleeAsFunctionCell);
1065     JSScope* scope = callee-&gt;scopeUnchecked();
1066     ExecutableBase* executable = callee-&gt;executable();
1067 
1068     MacroAssemblerCodePtr&lt;JSEntryPtrTag&gt; codePtr;
1069     CodeBlock* codeBlock = nullptr;
<span class="line-modified">1070     if (executable-&gt;isHostFunction()) {</span>
<span class="line-modified">1071         codePtr = jsToWasmICCodePtr(vm, kind, callee);</span>
<span class="line-modified">1072         if (!codePtr)</span>
<span class="line-added">1073             codePtr = executable-&gt;entrypointFor(kind, MustCheckArity);</span>
<span class="line-added">1074     } else {</span>
1075         FunctionExecutable* functionExecutable = static_cast&lt;FunctionExecutable*&gt;(executable);
1076 
1077         auto handleThrowException = [&amp;] () {
<span class="line-modified">1078             void* throwTarget = vm.getCTIStub(throwExceptionFromCallSlowPathGenerator).retaggedCode&lt;JSEntryPtrTag&gt;().executableAddress();</span>
1079             return encodeResult(throwTarget, reinterpret_cast&lt;void*&gt;(KeepTheFrame));
1080         };
1081 
1082         if (!isCall(kind) &amp;&amp; functionExecutable-&gt;constructAbility() == ConstructAbility::CannotConstruct) {
1083             throwException(exec, throwScope, createNotAConstructorError(exec, callee));
1084             return handleThrowException();
1085         }
1086 
1087         CodeBlock** codeBlockSlot = execCallee-&gt;addressOfCodeBlock();
<span class="line-modified">1088         Exception* error = functionExecutable-&gt;prepareForExecution&lt;FunctionExecutable&gt;(vm, callee, scope, kind, *codeBlockSlot);</span>
<span class="line-modified">1089         EXCEPTION_ASSERT(throwScope.exception() == error);</span>
<span class="line-modified">1090         if (UNLIKELY(error))</span>
1091             return handleThrowException();
1092         codeBlock = *codeBlockSlot;
1093         ArityCheckMode arity;
1094         if (execCallee-&gt;argumentCountIncludingThis() &lt; static_cast&lt;size_t&gt;(codeBlock-&gt;numParameters()) || callLinkInfo-&gt;isVarargs())
1095             arity = MustCheckArity;
1096         else
1097             arity = ArityCheckNotRequired;
1098         codePtr = functionExecutable-&gt;entrypointFor(kind, arity);
1099     }
<span class="line-added">1100 </span>
1101     if (!callLinkInfo-&gt;seenOnce())
1102         callLinkInfo-&gt;setSeen();
1103     else
1104         linkFor(execCallee, *callLinkInfo, codeBlock, callee, codePtr);
1105 
1106     return encodeResult(codePtr.executableAddress(), reinterpret_cast&lt;void*&gt;(callLinkInfo-&gt;callMode() == CallMode::Tail ? ReuseTheFrame : KeepTheFrame));
1107 }
1108 
1109 void JIT_OPERATION operationLinkDirectCall(ExecState* exec, CallLinkInfo* callLinkInfo, JSFunction* callee)
1110 {
<span class="line-modified">1111     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1112     auto throwScope = DECLARE_THROW_SCOPE(vm);</span>
1113 
1114     CodeSpecializationKind kind = callLinkInfo-&gt;specializationKind();
1115     NativeCallFrameTracer tracer(vm, exec);
1116 
1117     RELEASE_ASSERT(callLinkInfo-&gt;isDirect());
1118 
1119     // This would happen if the executable died during GC but the CodeBlock did not die. That should
1120     // not happen because the CodeBlock should have a weak reference to any executable it uses for
1121     // this purpose.
1122     RELEASE_ASSERT(callLinkInfo-&gt;executable());
1123 
1124     // Having a CodeBlock indicates that this is linked. We shouldn&#39;t be taking this path if it&#39;s
1125     // linked.
1126     RELEASE_ASSERT(!callLinkInfo-&gt;codeBlock());
1127 
1128     // We just don&#39;t support this yet.
1129     RELEASE_ASSERT(!callLinkInfo-&gt;isVarargs());
1130 
1131     ExecutableBase* executable = callLinkInfo-&gt;executable();
1132     RELEASE_ASSERT(callee-&gt;executable() == callLinkInfo-&gt;executable());
1133 
1134     JSScope* scope = callee-&gt;scopeUnchecked();
1135 
1136     MacroAssemblerCodePtr&lt;JSEntryPtrTag&gt; codePtr;
1137     CodeBlock* codeBlock = nullptr;
1138     if (executable-&gt;isHostFunction())
1139         codePtr = executable-&gt;entrypointFor(kind, MustCheckArity);
1140     else {
1141         FunctionExecutable* functionExecutable = static_cast&lt;FunctionExecutable*&gt;(executable);
1142 
1143         RELEASE_ASSERT(isCall(kind) || functionExecutable-&gt;constructAbility() != ConstructAbility::CannotConstruct);
1144 
<span class="line-modified">1145         Exception* error = functionExecutable-&gt;prepareForExecution&lt;FunctionExecutable&gt;(vm, callee, scope, kind, codeBlock);</span>
<span class="line-modified">1146         EXCEPTION_ASSERT_UNUSED(throwScope, throwScope.exception() == error);</span>
<span class="line-modified">1147         if (UNLIKELY(error))</span>
1148             return;
1149         unsigned argumentStackSlots = callLinkInfo-&gt;maxNumArguments();
1150         if (argumentStackSlots &lt; static_cast&lt;size_t&gt;(codeBlock-&gt;numParameters()))
1151             codePtr = functionExecutable-&gt;entrypointFor(kind, MustCheckArity);
1152         else
1153             codePtr = functionExecutable-&gt;entrypointFor(kind, ArityCheckNotRequired);
1154     }
1155 
1156     linkDirectFor(exec, *callLinkInfo, codeBlock, codePtr);
1157 }
1158 
1159 inline SlowPathReturnType virtualForWithFunction(
1160     ExecState* execCallee, CallLinkInfo* callLinkInfo, JSCell*&amp; calleeAsFunctionCell)
1161 {
1162     ExecState* exec = execCallee-&gt;callerFrame();
<span class="line-modified">1163     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1164     auto throwScope = DECLARE_THROW_SCOPE(vm);</span>
1165 
1166     CodeSpecializationKind kind = callLinkInfo-&gt;specializationKind();
1167     NativeCallFrameTracer tracer(vm, exec);
1168 
1169     JSValue calleeAsValue = execCallee-&gt;guaranteedJSValueCallee();
1170     calleeAsFunctionCell = getJSFunction(calleeAsValue);
1171     if (UNLIKELY(!calleeAsFunctionCell)) {
<span class="line-modified">1172         if (jsDynamicCast&lt;InternalFunction*&gt;(vm, calleeAsValue)) {</span>
<span class="line-modified">1173             MacroAssemblerCodePtr&lt;JSEntryPtrTag&gt; codePtr = vm.getCTIInternalFunctionTrampolineFor(kind);</span>
1174             ASSERT(!!codePtr);
1175             return encodeResult(codePtr.executableAddress(), reinterpret_cast&lt;void*&gt;(callLinkInfo-&gt;callMode() == CallMode::Tail ? ReuseTheFrame : KeepTheFrame));
1176         }
1177         RELEASE_AND_RETURN(throwScope, handleHostCall(execCallee, calleeAsValue, callLinkInfo));
1178     }
1179 
1180     JSFunction* function = jsCast&lt;JSFunction*&gt;(calleeAsFunctionCell);
1181     JSScope* scope = function-&gt;scopeUnchecked();
1182     ExecutableBase* executable = function-&gt;executable();
1183     if (UNLIKELY(!executable-&gt;hasJITCodeFor(kind))) {
1184         FunctionExecutable* functionExecutable = static_cast&lt;FunctionExecutable*&gt;(executable);
1185 
1186         if (!isCall(kind) &amp;&amp; functionExecutable-&gt;constructAbility() == ConstructAbility::CannotConstruct) {
1187             throwException(exec, throwScope, createNotAConstructorError(exec, function));
1188             return encodeResult(
<span class="line-modified">1189                 vm.getCTIStub(throwExceptionFromCallSlowPathGenerator).retaggedCode&lt;JSEntryPtrTag&gt;().executableAddress(),</span>
1190                 reinterpret_cast&lt;void*&gt;(KeepTheFrame));
1191         }
1192 
1193         CodeBlock** codeBlockSlot = execCallee-&gt;addressOfCodeBlock();
<span class="line-modified">1194         Exception* error = functionExecutable-&gt;prepareForExecution&lt;FunctionExecutable&gt;(vm, function, scope, kind, *codeBlockSlot);</span>
<span class="line-modified">1195         EXCEPTION_ASSERT(throwScope.exception() == error);</span>
<span class="line-modified">1196         if (UNLIKELY(error)) {</span>
1197             return encodeResult(
<span class="line-modified">1198                 vm.getCTIStub(throwExceptionFromCallSlowPathGenerator).retaggedCode&lt;JSEntryPtrTag&gt;().executableAddress(),</span>
1199                 reinterpret_cast&lt;void*&gt;(KeepTheFrame));
1200         }
1201     }
1202     return encodeResult(executable-&gt;entrypointFor(
1203         kind, MustCheckArity).executableAddress(),
1204         reinterpret_cast&lt;void*&gt;(callLinkInfo-&gt;callMode() == CallMode::Tail ? ReuseTheFrame : KeepTheFrame));
1205 }
1206 
1207 SlowPathReturnType JIT_OPERATION operationLinkPolymorphicCall(ExecState* execCallee, CallLinkInfo* callLinkInfo)
1208 {
1209     ASSERT(callLinkInfo-&gt;specializationKind() == CodeForCall);
1210     JSCell* calleeAsFunctionCell;
1211     SlowPathReturnType result = virtualForWithFunction(execCallee, callLinkInfo, calleeAsFunctionCell);
1212 
1213     linkPolymorphicCall(execCallee, *callLinkInfo, CallVariant(calleeAsFunctionCell));
1214 
1215     return result;
1216 }
1217 
1218 SlowPathReturnType JIT_OPERATION operationVirtualCall(ExecState* execCallee, CallLinkInfo* callLinkInfo)
1219 {
1220     JSCell* calleeAsFunctionCellIgnored;
1221     return virtualForWithFunction(execCallee, callLinkInfo, calleeAsFunctionCellIgnored);
1222 }
1223 
1224 size_t JIT_OPERATION operationCompareLess(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)
1225 {
<span class="line-modified">1226     VM&amp; vm = exec-&gt;vm();</span>
1227     NativeCallFrameTracer tracer(vm, exec);
1228 
1229     return jsLess&lt;true&gt;(exec, JSValue::decode(encodedOp1), JSValue::decode(encodedOp2));
1230 }
1231 
1232 size_t JIT_OPERATION operationCompareLessEq(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)
1233 {
<span class="line-modified">1234     VM&amp; vm = exec-&gt;vm();</span>
1235     NativeCallFrameTracer tracer(vm, exec);
1236 
1237     return jsLessEq&lt;true&gt;(exec, JSValue::decode(encodedOp1), JSValue::decode(encodedOp2));
1238 }
1239 
1240 size_t JIT_OPERATION operationCompareGreater(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)
1241 {
<span class="line-modified">1242     VM&amp; vm = exec-&gt;vm();</span>
1243     NativeCallFrameTracer tracer(vm, exec);
1244 
1245     return jsLess&lt;false&gt;(exec, JSValue::decode(encodedOp2), JSValue::decode(encodedOp1));
1246 }
1247 
1248 size_t JIT_OPERATION operationCompareGreaterEq(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)
1249 {
<span class="line-modified">1250     VM&amp; vm = exec-&gt;vm();</span>
1251     NativeCallFrameTracer tracer(vm, exec);
1252 
1253     return jsLessEq&lt;false&gt;(exec, JSValue::decode(encodedOp2), JSValue::decode(encodedOp1));
1254 }
1255 
1256 size_t JIT_OPERATION operationCompareEq(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)
1257 {
<span class="line-modified">1258     VM&amp; vm = exec-&gt;vm();</span>
1259     NativeCallFrameTracer tracer(vm, exec);
1260 
1261     return JSValue::equalSlowCaseInline(exec, JSValue::decode(encodedOp1), JSValue::decode(encodedOp2));
1262 }
1263 
1264 #if USE(JSVALUE64)
1265 EncodedJSValue JIT_OPERATION operationCompareStringEq(ExecState* exec, JSCell* left, JSCell* right)
1266 #else
1267 size_t JIT_OPERATION operationCompareStringEq(ExecState* exec, JSCell* left, JSCell* right)
1268 #endif
1269 {
<span class="line-modified">1270     VM&amp; vm = exec-&gt;vm();</span>
1271     NativeCallFrameTracer tracer(vm, exec);
1272 
1273     bool result = asString(left)-&gt;equal(exec, asString(right));
1274 #if USE(JSVALUE64)
1275     return JSValue::encode(jsBoolean(result));
1276 #else
1277     return result;
1278 #endif
1279 }
1280 
1281 size_t JIT_OPERATION operationCompareStrictEq(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)
1282 {
<span class="line-modified">1283     VM&amp; vm = exec-&gt;vm();</span>
1284     NativeCallFrameTracer tracer(vm, exec);
1285 
1286     JSValue src1 = JSValue::decode(encodedOp1);
1287     JSValue src2 = JSValue::decode(encodedOp2);
1288 
1289     return JSValue::strictEqual(exec, src1, src2);
1290 }
1291 
1292 EncodedJSValue JIT_OPERATION operationNewArrayWithProfile(ExecState* exec, ArrayAllocationProfile* profile, const JSValue* values, int size)
1293 {
<span class="line-modified">1294     VM&amp; vm = exec-&gt;vm();</span>
1295     NativeCallFrameTracer tracer(vm, exec);
1296     return JSValue::encode(constructArrayNegativeIndexed(exec, profile, values, size));
1297 }
1298 
1299 EncodedJSValue JIT_OPERATION operationNewArrayWithSizeAndProfile(ExecState* exec, ArrayAllocationProfile* profile, EncodedJSValue size)
1300 {
<span class="line-modified">1301     VM&amp; vm = exec-&gt;vm();</span>
1302     NativeCallFrameTracer tracer(vm, exec);
1303     JSValue sizeValue = JSValue::decode(size);
1304     return JSValue::encode(constructArrayWithSizeQuirk(exec, profile, exec-&gt;lexicalGlobalObject(), sizeValue));
1305 }
1306 
1307 }
1308 
1309 template&lt;typename FunctionType&gt;
1310 static EncodedJSValue operationNewFunctionCommon(ExecState* exec, JSScope* scope, JSCell* functionExecutable, bool isInvalidated)
1311 {
1312     VM&amp; vm = exec-&gt;vm();
1313     ASSERT(functionExecutable-&gt;inherits&lt;FunctionExecutable&gt;(vm));
<span class="line-modified">1314     NativeCallFrameTracer tracer(vm, exec);</span>
1315     if (isInvalidated)
1316         return JSValue::encode(FunctionType::createWithInvalidatedReallocationWatchpoint(vm, static_cast&lt;FunctionExecutable*&gt;(functionExecutable), scope));
1317     return JSValue::encode(FunctionType::create(vm, static_cast&lt;FunctionExecutable*&gt;(functionExecutable), scope));
1318 }
1319 
1320 extern &quot;C&quot; {
1321 
1322 EncodedJSValue JIT_OPERATION operationNewFunction(ExecState* exec, JSScope* scope, JSCell* functionExecutable)
1323 {
1324     return operationNewFunctionCommon&lt;JSFunction&gt;(exec, scope, functionExecutable, false);
1325 }
1326 
1327 EncodedJSValue JIT_OPERATION operationNewFunctionWithInvalidatedReallocationWatchpoint(ExecState* exec, JSScope* scope, JSCell* functionExecutable)
1328 {
1329     return operationNewFunctionCommon&lt;JSFunction&gt;(exec, scope, functionExecutable, true);
1330 }
1331 
1332 EncodedJSValue JIT_OPERATION operationNewGeneratorFunction(ExecState* exec, JSScope* scope, JSCell* functionExecutable)
1333 {
1334     return operationNewFunctionCommon&lt;JSGeneratorFunction&gt;(exec, scope, functionExecutable, false);
</pre>
<hr />
<pre>
1344     return operationNewFunctionCommon&lt;JSAsyncFunction&gt;(exec, scope, functionExecutable, false);
1345 }
1346 
1347 EncodedJSValue JIT_OPERATION operationNewAsyncFunctionWithInvalidatedReallocationWatchpoint(ExecState* exec, JSScope* scope, JSCell* functionExecutable)
1348 {
1349     return operationNewFunctionCommon&lt;JSAsyncFunction&gt;(exec, scope, functionExecutable, true);
1350 }
1351 
1352 EncodedJSValue JIT_OPERATION operationNewAsyncGeneratorFunction(ExecState* exec, JSScope* scope, JSCell* functionExecutable)
1353 {
1354     return operationNewFunctionCommon&lt;JSAsyncGeneratorFunction&gt;(exec, scope, functionExecutable, false);
1355 }
1356 
1357 EncodedJSValue JIT_OPERATION operationNewAsyncGeneratorFunctionWithInvalidatedReallocationWatchpoint(ExecState* exec, JSScope* scope, JSCell* functionExecutable)
1358 {
1359     return operationNewFunctionCommon&lt;JSAsyncGeneratorFunction&gt;(exec, scope, functionExecutable, true);
1360 }
1361 
1362 void JIT_OPERATION operationSetFunctionName(ExecState* exec, JSCell* funcCell, EncodedJSValue encodedName)
1363 {
<span class="line-modified">1364     VM&amp; vm = exec-&gt;vm();</span>
1365     NativeCallFrameTracer tracer(vm, exec);
1366 
1367     JSFunction* func = jsCast&lt;JSFunction*&gt;(funcCell);
1368     JSValue name = JSValue::decode(encodedName);
1369     func-&gt;setFunctionName(exec, name);
1370 }
1371 
1372 JSCell* JIT_OPERATION operationNewObject(ExecState* exec, Structure* structure)
1373 {
<span class="line-modified">1374     VM&amp; vm = exec-&gt;vm();</span>
1375     NativeCallFrameTracer tracer(vm, exec);
1376 
1377     return constructEmptyObject(exec, structure);
1378 }
1379 
1380 JSCell* JIT_OPERATION operationNewRegexp(ExecState* exec, JSCell* regexpPtr)
1381 {
1382     SuperSamplerScope superSamplerScope(false);
1383     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1384     NativeCallFrameTracer tracer(vm, exec);</span>
1385 
1386     RegExp* regexp = static_cast&lt;RegExp*&gt;(regexpPtr);
1387     ASSERT(regexp-&gt;isValid());
1388     return RegExpObject::create(vm, exec-&gt;lexicalGlobalObject()-&gt;regExpStructure(), regexp);
1389 }
1390 
1391 // The only reason for returning an UnusedPtr (instead of void) is so that we can reuse the
1392 // existing DFG slow path generator machinery when creating the slow path for CheckTraps
1393 // in the DFG. If a DFG slow path generator that supports a void return type is added in the
1394 // future, we can switch to using that then.
1395 UnusedPtr JIT_OPERATION operationHandleTraps(ExecState* exec)
1396 {
1397     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1398     NativeCallFrameTracer tracer(vm, exec);</span>
1399     ASSERT(vm.needTrapHandling());
1400     vm.handleTraps(exec);
1401     return nullptr;
1402 }
1403 
1404 void JIT_OPERATION operationDebug(ExecState* exec, int32_t debugHookType)
1405 {
1406     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1407     NativeCallFrameTracer tracer(vm, exec);</span>
1408 
1409     vm.interpreter-&gt;debug(exec, static_cast&lt;DebugHookType&gt;(debugHookType));
1410 }
1411 
1412 #if ENABLE(DFG_JIT)
1413 static void updateAllPredictionsAndOptimizeAfterWarmUp(CodeBlock* codeBlock)
1414 {
1415     codeBlock-&gt;updateAllPredictions();
1416     codeBlock-&gt;optimizeAfterWarmUp();
1417 }
1418 
1419 SlowPathReturnType JIT_OPERATION operationOptimize(ExecState* exec, uint32_t bytecodeIndex)
1420 {
1421     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1422     NativeCallFrameTracer tracer(vm, exec);</span>
1423 
1424     // Defer GC for a while so that it doesn&#39;t run between when we enter into this
1425     // slow path and when we figure out the state of our code block. This prevents
1426     // a number of awkward reentrancy scenarios, including:
1427     //
1428     // - The optimized version of our code block being jettisoned by GC right after
1429     //   we concluded that we wanted to use it, but have not planted it into the JS
1430     //   stack yet.
1431     //
1432     // - An optimized version of our code block being installed just as we decided
1433     //   that it wasn&#39;t ready yet.
1434     //
1435     // Note that jettisoning won&#39;t happen if we already initiated OSR, because in
1436     // that case we would have already planted the optimized code block into the JS
1437     // stack.
1438     DeferGCForAWhile deferGC(vm.heap);
1439 
1440     CodeBlock* codeBlock = exec-&gt;codeBlock();
<span class="line-modified">1441     if (UNLIKELY(codeBlock-&gt;jitType() != JITType::BaselineJIT)) {</span>
1442         dataLog(&quot;Unexpected code block in Baseline-&gt;DFG tier-up: &quot;, *codeBlock, &quot;\n&quot;);
1443         RELEASE_ASSERT_NOT_REACHED();
1444     }
1445 
1446     if (bytecodeIndex) {
1447         // If we&#39;re attempting to OSR from a loop, assume that this should be
1448         // separately optimized.
1449         codeBlock-&gt;m_shouldAlwaysBeInlined = false;
1450     }
1451 
1452     if (UNLIKELY(Options::verboseOSR())) {
1453         dataLog(
1454             *codeBlock, &quot;: Entered optimize with bytecodeIndex = &quot;, bytecodeIndex,
1455             &quot;, executeCounter = &quot;, codeBlock-&gt;jitExecuteCounter(),
1456             &quot;, optimizationDelayCounter = &quot;, codeBlock-&gt;reoptimizationRetryCounter(),
1457             &quot;, exitCounter = &quot;);
1458         if (codeBlock-&gt;hasOptimizedReplacement())
1459             dataLog(codeBlock-&gt;replacement()-&gt;osrExitCounter());
1460         else
1461             dataLog(&quot;N/A&quot;);
</pre>
<hr />
<pre>
1647         if (UNLIKELY(Options::verboseOSR())) {
1648             dataLog(
1649                 &quot;Triggering reoptimization of &quot;, codeBlock, &quot; -&gt; &quot;,
1650                 codeBlock-&gt;replacement(), &quot; (after OSR fail).\n&quot;);
1651         }
1652         optimizedCodeBlock-&gt;jettison(Profiler::JettisonDueToBaselineLoopReoptimizationTriggerOnOSREntryFail, CountReoptimization);
1653         return encodeResult(0, 0);
1654     }
1655 
1656     // OSR failed this time, but it might succeed next time! Let the code run a bit
1657     // longer and then try again.
1658     codeBlock-&gt;optimizeAfterWarmUp();
1659 
1660     CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayOptimizeToDFG&quot;, (&quot;OSR failed&quot;));
1661     return encodeResult(0, 0);
1662 }
1663 
1664 char* JIT_OPERATION operationTryOSREnterAtCatch(ExecState* exec, uint32_t bytecodeIndex)
1665 {
1666     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1667     NativeCallFrameTracer tracer(vm, exec);</span>
1668 
1669     CodeBlock* optimizedReplacement = exec-&gt;codeBlock()-&gt;replacement();
1670     if (UNLIKELY(!optimizedReplacement))
1671         return nullptr;
1672 
1673     switch (optimizedReplacement-&gt;jitType()) {
<span class="line-modified">1674     case JITType::DFGJIT:</span>
<span class="line-modified">1675     case JITType::FTLJIT: {</span>
1676         MacroAssemblerCodePtr&lt;ExceptionHandlerPtrTag&gt; entry = DFG::prepareCatchOSREntry(exec, optimizedReplacement, bytecodeIndex);
1677         return entry.executableAddress&lt;char*&gt;();
1678     }
1679     default:
1680         break;
1681     }
1682     return nullptr;
1683 }
1684 
1685 char* JIT_OPERATION operationTryOSREnterAtCatchAndValueProfile(ExecState* exec, uint32_t bytecodeIndex)
1686 {
1687     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1688     NativeCallFrameTracer tracer(vm, exec);</span>
1689 
1690     CodeBlock* codeBlock = exec-&gt;codeBlock();
1691     CodeBlock* optimizedReplacement = codeBlock-&gt;replacement();
1692     if (UNLIKELY(!optimizedReplacement))
1693         return nullptr;
1694 
1695     switch (optimizedReplacement-&gt;jitType()) {
<span class="line-modified">1696     case JITType::DFGJIT:</span>
<span class="line-modified">1697     case JITType::FTLJIT: {</span>
1698         MacroAssemblerCodePtr&lt;ExceptionHandlerPtrTag&gt; entry = DFG::prepareCatchOSREntry(exec, optimizedReplacement, bytecodeIndex);
1699         return entry.executableAddress&lt;char*&gt;();
1700     }
1701     default:
1702         break;
1703     }
1704 
1705     codeBlock-&gt;ensureCatchLivenessIsComputedForBytecodeOffset(bytecodeIndex);
1706     auto bytecode = codeBlock-&gt;instructions().at(bytecodeIndex)-&gt;as&lt;OpCatch&gt;();
1707     auto&amp; metadata = bytecode.metadata(codeBlock);
1708     metadata.m_buffer-&gt;forEach([&amp;] (ValueProfileAndOperand&amp; profile) {
<span class="line-modified">1709         profile.m_buckets[0] = JSValue::encode(exec-&gt;uncheckedR(profile.m_operand).jsValue());</span>
1710     });
1711 
1712     return nullptr;
1713 }
1714 
1715 #endif
1716 
1717 void JIT_OPERATION operationPutByIndex(ExecState* exec, EncodedJSValue encodedArrayValue, int32_t index, EncodedJSValue encodedValue)
1718 {
1719     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1720     NativeCallFrameTracer tracer(vm, exec);</span>
1721 
1722     JSValue arrayValue = JSValue::decode(encodedArrayValue);
1723     ASSERT(isJSArray(arrayValue));
1724     asArray(arrayValue)-&gt;putDirectIndex(exec, index, JSValue::decode(encodedValue));
1725 }
1726 
1727 enum class AccessorType {
1728     Getter,
1729     Setter
1730 };
1731 
1732 static void putAccessorByVal(ExecState* exec, JSObject* base, JSValue subscript, int32_t attribute, JSObject* accessor, AccessorType accessorType)
1733 {
1734     VM&amp; vm = exec-&gt;vm();
1735     auto scope = DECLARE_THROW_SCOPE(vm);
1736     auto propertyKey = subscript.toPropertyKey(exec);
1737     RETURN_IF_EXCEPTION(scope, void());
1738 
1739     scope.release();
1740     if (accessorType == AccessorType::Getter)
1741         base-&gt;putGetter(exec, propertyKey, accessor, attribute);
1742     else
1743         base-&gt;putSetter(exec, propertyKey, accessor, attribute);
1744 }
1745 
1746 void JIT_OPERATION operationPutGetterById(ExecState* exec, JSCell* object, UniquedStringImpl* uid, int32_t options, JSCell* getter)
1747 {
1748     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1749     NativeCallFrameTracer tracer(vm, exec);</span>
1750 
1751     ASSERT(object &amp;&amp; object-&gt;isObject());
1752     JSObject* baseObj = object-&gt;getObject();
1753 
1754     ASSERT(getter-&gt;isObject());
1755     baseObj-&gt;putGetter(exec, uid, getter, options);
1756 }
1757 
1758 void JIT_OPERATION operationPutSetterById(ExecState* exec, JSCell* object, UniquedStringImpl* uid, int32_t options, JSCell* setter)
1759 {
1760     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1761     NativeCallFrameTracer tracer(vm, exec);</span>
1762 
1763     ASSERT(object &amp;&amp; object-&gt;isObject());
1764     JSObject* baseObj = object-&gt;getObject();
1765 
1766     ASSERT(setter-&gt;isObject());
1767     baseObj-&gt;putSetter(exec, uid, setter, options);
1768 }
1769 
1770 void JIT_OPERATION operationPutGetterByVal(ExecState* exec, JSCell* base, EncodedJSValue encodedSubscript, int32_t attribute, JSCell* getter)
1771 {
1772     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1773     NativeCallFrameTracer tracer(vm, exec);</span>
1774 
1775     putAccessorByVal(exec, asObject(base), JSValue::decode(encodedSubscript), attribute, asObject(getter), AccessorType::Getter);
1776 }
1777 
1778 void JIT_OPERATION operationPutSetterByVal(ExecState* exec, JSCell* base, EncodedJSValue encodedSubscript, int32_t attribute, JSCell* setter)
1779 {
1780     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1781     NativeCallFrameTracer tracer(vm, exec);</span>
1782 
1783     putAccessorByVal(exec, asObject(base), JSValue::decode(encodedSubscript), attribute, asObject(setter), AccessorType::Setter);
1784 }
1785 
1786 #if USE(JSVALUE64)
1787 void JIT_OPERATION operationPutGetterSetter(ExecState* exec, JSCell* object, UniquedStringImpl* uid, int32_t attribute, EncodedJSValue encodedGetterValue, EncodedJSValue encodedSetterValue)
1788 {
1789     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1790     NativeCallFrameTracer tracer(vm, exec);</span>
1791 
1792     ASSERT(object &amp;&amp; object-&gt;isObject());
1793     JSObject* baseObject = asObject(object);
1794 
1795     JSValue getter = JSValue::decode(encodedGetterValue);
1796     JSValue setter = JSValue::decode(encodedSetterValue);
1797     ASSERT(getter.isObject() || setter.isObject());
1798     GetterSetter* accessor = GetterSetter::create(vm, exec-&gt;lexicalGlobalObject(), getter, setter);
1799     CommonSlowPaths::putDirectAccessorWithReify(vm, exec, baseObject, uid, accessor, attribute);
1800 }
1801 
1802 #else
1803 void JIT_OPERATION operationPutGetterSetter(ExecState* exec, JSCell* object, UniquedStringImpl* uid, int32_t attribute, JSCell* getterCell, JSCell* setterCell)
1804 {
1805     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1806     NativeCallFrameTracer tracer(vm, exec);</span>
1807 
1808     ASSERT(object &amp;&amp; object-&gt;isObject());
1809     JSObject* baseObject = asObject(object);
1810 
1811     ASSERT(getterCell || setterCell);
1812     JSObject* getter = getterCell ? getterCell-&gt;getObject() : nullptr;
1813     JSObject* setter = setterCell ? setterCell-&gt;getObject() : nullptr;
1814     GetterSetter* accessor = GetterSetter::create(vm, exec-&gt;lexicalGlobalObject(), getter, setter);
1815     CommonSlowPaths::putDirectAccessorWithReify(vm, exec, baseObject, uid, accessor, attribute);
1816 }
1817 #endif
1818 
1819 void JIT_OPERATION operationPopScope(ExecState* exec, int32_t scopeReg)
1820 {
1821     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1822     NativeCallFrameTracer tracer(vm, exec);</span>
1823 
1824     JSScope* scope = exec-&gt;uncheckedR(scopeReg).Register::scope();
1825     exec-&gt;uncheckedR(scopeReg) = scope-&gt;next();
1826 }
1827 
1828 int32_t JIT_OPERATION operationInstanceOfCustom(ExecState* exec, EncodedJSValue encodedValue, JSObject* constructor, EncodedJSValue encodedHasInstance)
1829 {
1830     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1831     NativeCallFrameTracer tracer(vm, exec);</span>
1832 
1833     JSValue value = JSValue::decode(encodedValue);
1834     JSValue hasInstanceValue = JSValue::decode(encodedHasInstance);
1835 


1836     if (constructor-&gt;hasInstance(exec, value, hasInstanceValue))
1837         return 1;
1838     return 0;
1839 }
1840 
1841 }
1842 
1843 static JSValue getByVal(ExecState* exec, JSValue baseValue, JSValue subscript, ByValInfo* byValInfo, ReturnAddressPtr returnAddress)
1844 {
1845     VM&amp; vm = exec-&gt;vm();
1846     auto scope = DECLARE_THROW_SCOPE(vm);
1847 
1848     if (LIKELY(baseValue.isCell() &amp;&amp; subscript.isString())) {
1849         Structure&amp; structure = *baseValue.asCell()-&gt;structure(vm);
1850         if (JSCell::canUseFastGetOwnProperty(structure)) {
<span class="line-modified">1851             RefPtr&lt;AtomStringImpl&gt; existingAtomString = asString(subscript)-&gt;toExistingAtomString(exec);</span>
<span class="line-modified">1852             RETURN_IF_EXCEPTION(scope, JSValue());</span>
<span class="line-added">1853             if (existingAtomString) {</span>
<span class="line-added">1854                 if (JSValue result = baseValue.asCell()-&gt;fastGetOwnProperty(vm, structure, existingAtomString.get())) {</span>
1855                     ASSERT(exec-&gt;bytecodeOffset());
<span class="line-modified">1856                     if (byValInfo-&gt;stubInfo &amp;&amp; byValInfo-&gt;cachedId.impl() != existingAtomString)</span>
1857                         byValInfo-&gt;tookSlowPath = true;
1858                     return result;
1859                 }
1860             }
1861         }
1862     }
1863 
<span class="line-modified">1864     if (subscript.isInt32()) {</span>
1865         ASSERT(exec-&gt;bytecodeOffset());
1866         byValInfo-&gt;tookSlowPath = true;
1867 
<span class="line-modified">1868         int32_t i = subscript.asInt32();</span>
1869         if (isJSString(baseValue)) {
<span class="line-modified">1870             if (i &gt;= 0 &amp;&amp; asString(baseValue)-&gt;canGetIndex(i)) {</span>
1871                 ctiPatchCallByReturnAddress(returnAddress, operationGetByValString);
1872                 RELEASE_AND_RETURN(scope, asString(baseValue)-&gt;getIndex(exec, i));
1873             }
1874             byValInfo-&gt;arrayProfile-&gt;setOutOfBounds();
1875         } else if (baseValue.isObject()) {
1876             JSObject* object = asObject(baseValue);
1877             if (object-&gt;canGetIndexQuickly(i))
1878                 return object-&gt;getIndexQuickly(i);
1879 
1880             bool skipMarkingOutOfBounds = false;
1881 
<span class="line-modified">1882             if (object-&gt;indexingType() == ArrayWithContiguous &amp;&amp; i &gt;= 0 &amp;&amp; static_cast&lt;uint32_t&gt;(i) &lt; object-&gt;butterfly()-&gt;publicLength()) {</span>
1883                 // FIXME: expand this to ArrayStorage, Int32, and maybe Double:
1884                 // https://bugs.webkit.org/show_bug.cgi?id=182940
1885                 auto* globalObject = object-&gt;globalObject(vm);
1886                 skipMarkingOutOfBounds = globalObject-&gt;isOriginalArrayStructure(object-&gt;structure(vm)) &amp;&amp; globalObject-&gt;arrayPrototypeChainIsSane();
1887             }
1888 
1889             if (!skipMarkingOutOfBounds &amp;&amp; !CommonSlowPaths::canAccessArgumentIndexQuickly(*object, i)) {
1890                 // FIXME: This will make us think that in-bounds typed array accesses are actually
1891                 // out-of-bounds.
1892                 // https://bugs.webkit.org/show_bug.cgi?id=149886
1893                 byValInfo-&gt;arrayProfile-&gt;setOutOfBounds();
1894             }
1895         }
1896 
<span class="line-modified">1897         if (i &gt;= 0)</span>
<span class="line-added">1898             RELEASE_AND_RETURN(scope, baseValue.get(exec, static_cast&lt;uint32_t&gt;(i)));</span>
1899     }
1900 
1901     baseValue.requireObjectCoercible(exec);
1902     RETURN_IF_EXCEPTION(scope, JSValue());
1903     auto property = subscript.toPropertyKey(exec);
1904     RETURN_IF_EXCEPTION(scope, JSValue());
1905 
1906     ASSERT(exec-&gt;bytecodeOffset());
1907     if (byValInfo-&gt;stubInfo &amp;&amp; (!isStringOrSymbol(subscript) || byValInfo-&gt;cachedId != property))
1908         byValInfo-&gt;tookSlowPath = true;
1909 
1910     RELEASE_AND_RETURN(scope, baseValue.get(exec, property));
1911 }
1912 
1913 static OptimizationResult tryGetByValOptimize(ExecState* exec, JSValue baseValue, JSValue subscript, ByValInfo* byValInfo, ReturnAddressPtr returnAddress)
1914 {
1915     // See if it&#39;s worth optimizing this at all.
1916     OptimizationResult optimizationResult = OptimizationResult::NotOptimized;
1917 
1918     VM&amp; vm = exec-&gt;vm();
<span class="line-added">1919     auto scope = DECLARE_THROW_SCOPE(vm);</span>
1920 
1921     if (baseValue.isObject() &amp;&amp; subscript.isInt32()) {
1922         JSObject* object = asObject(baseValue);
1923 
1924         ASSERT(exec-&gt;bytecodeOffset());
1925         ASSERT(!byValInfo-&gt;stubRoutine);
1926 
1927         if (hasOptimizableIndexing(object-&gt;structure(vm))) {
1928             // Attempt to optimize.
1929             Structure* structure = object-&gt;structure(vm);
1930             JITArrayMode arrayMode = jitArrayModeForStructure(structure);
1931             if (arrayMode != byValInfo-&gt;arrayMode) {
1932                 // If we reached this case, we got an interesting array mode we did not expect when we compiled.
1933                 // Let&#39;s update the profile to do better next time.
1934                 CodeBlock* codeBlock = exec-&gt;codeBlock();
1935                 ConcurrentJSLocker locker(codeBlock-&gt;m_lock);
1936                 byValInfo-&gt;arrayProfile-&gt;computeUpdatedPrediction(locker, codeBlock, structure);
1937 
<span class="line-modified">1938                 JIT::compileGetByVal(locker, vm, codeBlock, byValInfo, returnAddress, arrayMode);</span>
1939                 optimizationResult = OptimizationResult::Optimized;
1940             }
1941         }
1942 
1943         // If we failed to patch and we have some object that intercepts indexed get, then don&#39;t even wait until 10 times.
1944         if (optimizationResult != OptimizationResult::Optimized &amp;&amp; object-&gt;structure(vm)-&gt;typeInfo().interceptsGetOwnPropertySlotByIndexEvenWhenLengthIsNotZero())
1945             optimizationResult = OptimizationResult::GiveUp;
1946     }
1947 
1948     if (baseValue.isObject() &amp;&amp; isStringOrSymbol(subscript)) {
1949         const Identifier propertyName = subscript.toPropertyKey(exec);
<span class="line-added">1950         RETURN_IF_EXCEPTION(scope, OptimizationResult::GiveUp);</span>
1951         if (subscript.isSymbol() || !parseIndex(propertyName)) {
1952             ASSERT(exec-&gt;bytecodeOffset());
1953             ASSERT(!byValInfo-&gt;stubRoutine);
1954             if (byValInfo-&gt;seen) {
1955                 if (byValInfo-&gt;cachedId == propertyName) {
<span class="line-modified">1956                     JIT::compileGetByValWithCachedId(vm, exec-&gt;codeBlock(), byValInfo, returnAddress, propertyName);</span>
1957                     optimizationResult = OptimizationResult::Optimized;
1958                 } else {
1959                     // Seem like a generic property access site.
1960                     optimizationResult = OptimizationResult::GiveUp;
1961                 }
1962             } else {
1963                 CodeBlock* codeBlock = exec-&gt;codeBlock();
1964                 ConcurrentJSLocker locker(codeBlock-&gt;m_lock);
1965                 byValInfo-&gt;seen = true;
1966                 byValInfo-&gt;cachedId = propertyName;
1967                 if (subscript.isSymbol())
1968                     byValInfo-&gt;cachedSymbol.set(vm, codeBlock, asSymbol(subscript));
1969                 optimizationResult = OptimizationResult::SeenOnce;
1970             }
1971         }
1972     }
1973 
1974     if (optimizationResult != OptimizationResult::Optimized &amp;&amp; optimizationResult != OptimizationResult::SeenOnce) {
1975         // If we take slow path more than 10 times without patching then make sure we
1976         // never make that mistake again. For cases where we see non-index-intercepting
1977         // objects, this gives 10 iterations worth of opportunity for us to observe
1978         // that the get_by_val may be polymorphic. We count up slowPathCount even if
1979         // the result is GiveUp.
1980         if (++byValInfo-&gt;slowPathCount &gt;= 10)
1981             optimizationResult = OptimizationResult::GiveUp;
1982     }
1983 
1984     return optimizationResult;
1985 }
1986 
1987 extern &quot;C&quot; {
1988 
1989 EncodedJSValue JIT_OPERATION operationGetByValGeneric(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedSubscript, ByValInfo* byValInfo)
1990 {
1991     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">1992     NativeCallFrameTracer tracer(vm, exec);</span>
1993     JSValue baseValue = JSValue::decode(encodedBase);
1994     JSValue subscript = JSValue::decode(encodedSubscript);
1995 
1996     JSValue result = getByVal(exec, baseValue, subscript, byValInfo, ReturnAddressPtr(OUR_RETURN_ADDRESS));
1997     return JSValue::encode(result);
1998 }
1999 
2000 EncodedJSValue JIT_OPERATION operationGetByValOptimize(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedSubscript, ByValInfo* byValInfo)
2001 {
2002     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2003     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-added">2004     auto scope = DECLARE_THROW_SCOPE(vm);</span>
2005 
2006     JSValue baseValue = JSValue::decode(encodedBase);
2007     JSValue subscript = JSValue::decode(encodedSubscript);
2008     ReturnAddressPtr returnAddress = ReturnAddressPtr(OUR_RETURN_ADDRESS);
<span class="line-modified">2009     OptimizationResult result = tryGetByValOptimize(exec, baseValue, subscript, byValInfo, returnAddress);</span>
<span class="line-added">2010     RETURN_IF_EXCEPTION(scope, { });</span>
<span class="line-added">2011     if (result == OptimizationResult::GiveUp) {</span>
2012         // Don&#39;t ever try to optimize.
2013         byValInfo-&gt;tookSlowPath = true;
2014         ctiPatchCallByReturnAddress(returnAddress, operationGetByValGeneric);
2015     }
2016 
<span class="line-modified">2017     RELEASE_AND_RETURN(scope, JSValue::encode(getByVal(exec, baseValue, subscript, byValInfo, returnAddress)));</span>
2018 }
2019 
2020 EncodedJSValue JIT_OPERATION operationHasIndexedPropertyDefault(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedSubscript, ByValInfo* byValInfo)
2021 {
2022     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2023     NativeCallFrameTracer tracer(vm, exec);</span>
2024     JSValue baseValue = JSValue::decode(encodedBase);
2025     JSValue subscript = JSValue::decode(encodedSubscript);
2026 
2027     ASSERT(baseValue.isObject());
<span class="line-modified">2028     ASSERT(subscript.isUInt32AsAnyInt());</span>
2029 
2030     JSObject* object = asObject(baseValue);
2031     bool didOptimize = false;
2032 
2033     ASSERT(exec-&gt;bytecodeOffset());
2034     ASSERT(!byValInfo-&gt;stubRoutine);
2035 
2036     if (hasOptimizableIndexing(object-&gt;structure(vm))) {
2037         // Attempt to optimize.
2038         JITArrayMode arrayMode = jitArrayModeForStructure(object-&gt;structure(vm));
2039         if (arrayMode != byValInfo-&gt;arrayMode) {
<span class="line-modified">2040             JIT::compileHasIndexedProperty(vm, exec-&gt;codeBlock(), byValInfo, ReturnAddressPtr(OUR_RETURN_ADDRESS), arrayMode);</span>
2041             didOptimize = true;
2042         }
2043     }
2044 
2045     if (!didOptimize) {
2046         // If we take slow path more than 10 times without patching then make sure we
2047         // never make that mistake again. Or, if we failed to patch and we have some object
2048         // that intercepts indexed get, then don&#39;t even wait until 10 times. For cases
2049         // where we see non-index-intercepting objects, this gives 10 iterations worth of
2050         // opportunity for us to observe that the get_by_val may be polymorphic.
2051         if (++byValInfo-&gt;slowPathCount &gt;= 10
2052             || object-&gt;structure(vm)-&gt;typeInfo().interceptsGetOwnPropertySlotByIndexEvenWhenLengthIsNotZero()) {
2053             // Don&#39;t ever try to optimize.
2054             ctiPatchCallByReturnAddress(ReturnAddressPtr(OUR_RETURN_ADDRESS), operationHasIndexedPropertyGeneric);
2055         }
2056     }
2057 
<span class="line-modified">2058     uint32_t index = subscript.asUInt32AsAnyInt();</span>
2059     if (object-&gt;canGetIndexQuickly(index))
2060         return JSValue::encode(JSValue(JSValue::JSTrue));
2061 
<span class="line-modified">2062     if (!CommonSlowPaths::canAccessArgumentIndexQuickly(*object, index))</span>



2063         byValInfo-&gt;arrayProfile-&gt;setOutOfBounds();

2064     return JSValue::encode(jsBoolean(object-&gt;hasPropertyGeneric(exec, index, PropertySlot::InternalMethodType::GetOwnProperty)));
2065 }
2066 
2067 EncodedJSValue JIT_OPERATION operationHasIndexedPropertyGeneric(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedSubscript, ByValInfo* byValInfo)
2068 {
2069     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2070     NativeCallFrameTracer tracer(vm, exec);</span>
2071     JSValue baseValue = JSValue::decode(encodedBase);
2072     JSValue subscript = JSValue::decode(encodedSubscript);
2073 
2074     ASSERT(baseValue.isObject());
<span class="line-modified">2075     ASSERT(subscript.isUInt32AsAnyInt());</span>
2076 
2077     JSObject* object = asObject(baseValue);
<span class="line-modified">2078     uint32_t index = subscript.asUInt32AsAnyInt();</span>
2079     if (object-&gt;canGetIndexQuickly(index))
2080         return JSValue::encode(JSValue(JSValue::JSTrue));
2081 
<span class="line-modified">2082     if (!CommonSlowPaths::canAccessArgumentIndexQuickly(*object, index))</span>



2083         byValInfo-&gt;arrayProfile-&gt;setOutOfBounds();
<span class="line-modified">2084     return JSValue::encode(jsBoolean(object-&gt;hasPropertyGeneric(exec, index, PropertySlot::InternalMethodType::GetOwnProperty)));</span>

2085 }
2086 
2087 EncodedJSValue JIT_OPERATION operationGetByValString(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedSubscript, ByValInfo* byValInfo)
2088 {
2089     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2090     NativeCallFrameTracer tracer(vm, exec);</span>
2091     auto scope = DECLARE_THROW_SCOPE(vm);
2092     JSValue baseValue = JSValue::decode(encodedBase);
2093     JSValue subscript = JSValue::decode(encodedSubscript);
2094 
2095     JSValue result;
2096     if (LIKELY(subscript.isUInt32())) {
2097         uint32_t i = subscript.asUInt32();
2098         if (isJSString(baseValue) &amp;&amp; asString(baseValue)-&gt;canGetIndex(i))
2099             RELEASE_AND_RETURN(scope, JSValue::encode(asString(baseValue)-&gt;getIndex(exec, i)));
2100 
2101         result = baseValue.get(exec, i);
2102         RETURN_IF_EXCEPTION(scope, encodedJSValue());
2103         if (!isJSString(baseValue)) {
2104             ASSERT(exec-&gt;bytecodeOffset());
2105             auto getByValFunction = byValInfo-&gt;stubRoutine ? operationGetByValGeneric : operationGetByValOptimize;
2106             ctiPatchCallByReturnAddress(ReturnAddressPtr(OUR_RETURN_ADDRESS), getByValFunction);
2107         }
2108     } else {
2109         baseValue.requireObjectCoercible(exec);
2110         RETURN_IF_EXCEPTION(scope, encodedJSValue());
2111         auto property = subscript.toPropertyKey(exec);
2112         RETURN_IF_EXCEPTION(scope, encodedJSValue());
2113         scope.release();
2114         result = baseValue.get(exec, property);
2115     }
2116 
2117     return JSValue::encode(result);
2118 }
2119 
2120 EncodedJSValue JIT_OPERATION operationDeleteByIdJSResult(ExecState* exec, EncodedJSValue base, UniquedStringImpl* uid)
2121 {
2122     return JSValue::encode(jsBoolean(operationDeleteById(exec, base, uid)));
2123 }
2124 
2125 size_t JIT_OPERATION operationDeleteById(ExecState* exec, EncodedJSValue encodedBase, UniquedStringImpl* uid)
2126 {
2127     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2128     NativeCallFrameTracer tracer(vm, exec);</span>
2129     auto scope = DECLARE_THROW_SCOPE(vm);
2130 
2131     JSObject* baseObj = JSValue::decode(encodedBase).toObject(exec);
2132     RETURN_IF_EXCEPTION(scope, false);
2133     if (!baseObj)
2134         return false;
<span class="line-modified">2135     bool couldDelete = baseObj-&gt;methodTable(vm)-&gt;deleteProperty(baseObj, exec, Identifier::fromUid(vm, uid));</span>
2136     RETURN_IF_EXCEPTION(scope, false);
2137     if (!couldDelete &amp;&amp; exec-&gt;codeBlock()-&gt;isStrictMode())
2138         throwTypeError(exec, scope, UnableToDeletePropertyError);
2139     return couldDelete;
2140 }
2141 
2142 EncodedJSValue JIT_OPERATION operationDeleteByValJSResult(ExecState* exec, EncodedJSValue base,  EncodedJSValue key)
2143 {
2144     return JSValue::encode(jsBoolean(operationDeleteByVal(exec, base, key)));
2145 }
2146 
2147 size_t JIT_OPERATION operationDeleteByVal(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedKey)
2148 {
2149     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2150     NativeCallFrameTracer tracer(vm, exec);</span>
2151     auto scope = DECLARE_THROW_SCOPE(vm);
2152 
2153     JSObject* baseObj = JSValue::decode(encodedBase).toObject(exec);
2154     RETURN_IF_EXCEPTION(scope, false);
2155     JSValue key = JSValue::decode(encodedKey);
2156     if (!baseObj)
2157         return false;
2158 
2159     bool couldDelete;
2160     uint32_t index;
2161     if (key.getUInt32(index))
2162         couldDelete = baseObj-&gt;methodTable(vm)-&gt;deletePropertyByIndex(baseObj, exec, index);
2163     else {
2164         Identifier property = key.toPropertyKey(exec);
2165         RETURN_IF_EXCEPTION(scope, false);
2166         couldDelete = baseObj-&gt;methodTable(vm)-&gt;deleteProperty(baseObj, exec, property);
2167     }
2168     RETURN_IF_EXCEPTION(scope, false);
2169     if (!couldDelete &amp;&amp; exec-&gt;codeBlock()-&gt;isStrictMode())
2170         throwTypeError(exec, scope, UnableToDeletePropertyError);
2171     return couldDelete;
2172 }
2173 
2174 JSCell* JIT_OPERATION operationPushWithScope(ExecState* exec, JSCell* currentScopeCell, EncodedJSValue objectValue)
2175 {
2176     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2177     NativeCallFrameTracer tracer(vm, exec);</span>
2178     auto scope = DECLARE_THROW_SCOPE(vm);
2179 
2180     JSObject* object = JSValue::decode(objectValue).toObject(exec);
2181     RETURN_IF_EXCEPTION(scope, nullptr);
2182 
2183     JSScope* currentScope = jsCast&lt;JSScope*&gt;(currentScopeCell);
2184 
2185     return JSWithScope::create(vm, exec-&gt;lexicalGlobalObject(), currentScope, object);
2186 }
2187 
2188 JSCell* JIT_OPERATION operationPushWithScopeObject(ExecState* exec, JSCell* currentScopeCell, JSObject* object)
2189 {
2190     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2191     NativeCallFrameTracer tracer(vm, exec);</span>
2192     JSScope* currentScope = jsCast&lt;JSScope*&gt;(currentScopeCell);
2193     return JSWithScope::create(vm, exec-&gt;lexicalGlobalObject(), currentScope, object);
2194 }
2195 
2196 EncodedJSValue JIT_OPERATION operationInstanceOf(ExecState* exec, EncodedJSValue encodedValue, EncodedJSValue encodedProto)
2197 {
2198     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2199     NativeCallFrameTracer tracer(vm, exec);</span>
2200     JSValue value = JSValue::decode(encodedValue);
2201     JSValue proto = JSValue::decode(encodedProto);
2202 
2203     bool result = JSObject::defaultHasInstance(exec, value, proto);
2204     return JSValue::encode(jsBoolean(result));
2205 }
2206 
2207 EncodedJSValue JIT_OPERATION operationInstanceOfGeneric(ExecState* exec, StructureStubInfo* stubInfo, EncodedJSValue encodedValue, EncodedJSValue encodedProto)
2208 {
2209     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2210     NativeCallFrameTracer tracer(vm, exec);</span>
2211     JSValue value = JSValue::decode(encodedValue);
2212     JSValue proto = JSValue::decode(encodedProto);
2213 
2214     stubInfo-&gt;tookSlowPath = true;
2215 
2216     bool result = JSObject::defaultHasInstance(exec, value, proto);
2217     return JSValue::encode(jsBoolean(result));
2218 }
2219 
2220 EncodedJSValue JIT_OPERATION operationInstanceOfOptimize(ExecState* exec, StructureStubInfo* stubInfo, EncodedJSValue encodedValue, EncodedJSValue encodedProto)
2221 {
2222     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2223     NativeCallFrameTracer tracer(vm, exec);</span>
2224     auto scope = DECLARE_THROW_SCOPE(vm);
2225     JSValue value = JSValue::decode(encodedValue);
2226     JSValue proto = JSValue::decode(encodedProto);
2227 
2228     bool result = JSObject::defaultHasInstance(exec, value, proto);
2229     RETURN_IF_EXCEPTION(scope, JSValue::encode(jsUndefined()));
2230 
<span class="line-modified">2231     if (stubInfo-&gt;considerCaching(vm, exec-&gt;codeBlock(), value.structureOrNull()))</span>
2232         repatchInstanceOf(exec, value, proto, *stubInfo, result);
2233 
2234     return JSValue::encode(jsBoolean(result));
2235 }
2236 
2237 int32_t JIT_OPERATION operationSizeFrameForForwardArguments(ExecState* exec, EncodedJSValue, int32_t numUsedStackSlots, int32_t)
2238 {
2239     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2240     NativeCallFrameTracer tracer(vm, exec);</span>
2241     return sizeFrameForForwardArguments(exec, vm, numUsedStackSlots);
2242 }
2243 
2244 int32_t JIT_OPERATION operationSizeFrameForVarargs(ExecState* exec, EncodedJSValue encodedArguments, int32_t numUsedStackSlots, int32_t firstVarArgOffset)
2245 {
2246     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2247     NativeCallFrameTracer tracer(vm, exec);</span>
2248     JSValue arguments = JSValue::decode(encodedArguments);
2249     return sizeFrameForVarargs(exec, vm, arguments, numUsedStackSlots, firstVarArgOffset);
2250 }
2251 
2252 CallFrame* JIT_OPERATION operationSetupForwardArgumentsFrame(ExecState* exec, CallFrame* newCallFrame, EncodedJSValue, int32_t, int32_t length)
2253 {
2254     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2255     NativeCallFrameTracer tracer(vm, exec);</span>
2256     setupForwardArgumentsFrame(exec, newCallFrame, length);
2257     return newCallFrame;
2258 }
2259 
2260 CallFrame* JIT_OPERATION operationSetupVarargsFrame(ExecState* exec, CallFrame* newCallFrame, EncodedJSValue encodedArguments, int32_t firstVarArgOffset, int32_t length)
2261 {
2262     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2263     NativeCallFrameTracer tracer(vm, exec);</span>
2264     JSValue arguments = JSValue::decode(encodedArguments);
2265     setupVarargsFrame(exec, newCallFrame, arguments, firstVarArgOffset, length);
2266     return newCallFrame;
2267 }
2268 
2269 char* JIT_OPERATION operationSwitchCharWithUnknownKeyType(ExecState* exec, EncodedJSValue encodedKey, size_t tableIndex)
2270 {
2271     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2272     NativeCallFrameTracer tracer(vm, exec);</span>
2273     JSValue key = JSValue::decode(encodedKey);
2274     CodeBlock* codeBlock = exec-&gt;codeBlock();
2275 
2276     SimpleJumpTable&amp; jumpTable = codeBlock-&gt;switchJumpTable(tableIndex);
2277     void* result = jumpTable.ctiDefault.executableAddress();
2278 
2279     if (key.isString()) {
2280         StringImpl* value = asString(key)-&gt;value(exec).impl();
2281         if (value-&gt;length() == 1)
2282             result = jumpTable.ctiForValue((*value)[0]).executableAddress();
2283     }
2284 
2285     assertIsTaggedWith(result, JSSwitchPtrTag);
2286     return reinterpret_cast&lt;char*&gt;(result);
2287 }
2288 
2289 char* JIT_OPERATION operationSwitchImmWithUnknownKeyType(ExecState* exec, EncodedJSValue encodedKey, size_t tableIndex)
2290 {
2291     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2292     NativeCallFrameTracer tracer(vm, exec);</span>
2293     JSValue key = JSValue::decode(encodedKey);
2294     CodeBlock* codeBlock = exec-&gt;codeBlock();
2295 
2296     SimpleJumpTable&amp; jumpTable = codeBlock-&gt;switchJumpTable(tableIndex);
2297     void* result;
2298     if (key.isInt32())
2299         result = jumpTable.ctiForValue(key.asInt32()).executableAddress();
2300     else if (key.isDouble() &amp;&amp; key.asDouble() == static_cast&lt;int32_t&gt;(key.asDouble()))
2301         result = jumpTable.ctiForValue(static_cast&lt;int32_t&gt;(key.asDouble())).executableAddress();
2302     else
2303         result = jumpTable.ctiDefault.executableAddress();
2304     assertIsTaggedWith(result, JSSwitchPtrTag);
2305     return reinterpret_cast&lt;char*&gt;(result);
2306 }
2307 
2308 char* JIT_OPERATION operationSwitchStringWithUnknownKeyType(ExecState* exec, EncodedJSValue encodedKey, size_t tableIndex)
2309 {
2310     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2311     NativeCallFrameTracer tracer(vm, exec);</span>
2312     JSValue key = JSValue::decode(encodedKey);
2313     CodeBlock* codeBlock = exec-&gt;codeBlock();
<span class="line-added">2314     auto throwScope = DECLARE_THROW_SCOPE(vm);</span>
2315 
2316     void* result;
2317     StringJumpTable&amp; jumpTable = codeBlock-&gt;stringSwitchJumpTable(tableIndex);
2318 
2319     if (key.isString()) {
2320         StringImpl* value = asString(key)-&gt;value(exec).impl();
<span class="line-added">2321 </span>
<span class="line-added">2322         RETURN_IF_EXCEPTION(throwScope, nullptr);</span>
<span class="line-added">2323 </span>
2324         result = jumpTable.ctiForValue(value).executableAddress();
2325     } else
2326         result = jumpTable.ctiDefault.executableAddress();
2327 
2328     assertIsTaggedWith(result, JSSwitchPtrTag);
2329     return reinterpret_cast&lt;char*&gt;(result);
2330 }
2331 
2332 EncodedJSValue JIT_OPERATION operationGetFromScope(ExecState* exec, const Instruction* pc)
2333 {
2334     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2335     NativeCallFrameTracer tracer(vm, exec);</span>
2336     auto throwScope = DECLARE_THROW_SCOPE(vm);
2337 
2338     CodeBlock* codeBlock = exec-&gt;codeBlock();
2339 
2340     auto bytecode = pc-&gt;as&lt;OpGetFromScope&gt;();
2341     const Identifier&amp; ident = codeBlock-&gt;identifier(bytecode.m_var);
2342     JSObject* scope = jsCast&lt;JSObject*&gt;(exec-&gt;uncheckedR(bytecode.m_scope.offset()).jsValue());
2343     GetPutInfo&amp; getPutInfo = bytecode.metadata(codeBlock).m_getPutInfo;
2344 
2345     // ModuleVar is always converted to ClosureVar for get_from_scope.
2346     ASSERT(getPutInfo.resolveType() != ModuleVar);
2347 
2348     RELEASE_AND_RETURN(throwScope, JSValue::encode(scope-&gt;getPropertySlot(exec, ident, [&amp;] (bool found, PropertySlot&amp; slot) -&gt; JSValue {
2349         if (!found) {
2350             if (getPutInfo.resolveMode() == ThrowIfNotFound)
2351                 throwException(exec, throwScope, createUndefinedVariableError(exec, ident));
2352             return jsUndefined();
2353         }
2354 
2355         JSValue result = JSValue();
2356         if (scope-&gt;isGlobalLexicalEnvironment()) {
2357             // When we can&#39;t statically prove we need a TDZ check, we must perform the check on the slow path.
2358             result = slot.getValue(exec, ident);
2359             if (result == jsTDZValue()) {
2360                 throwException(exec, throwScope, createTDZError(exec));
2361                 return jsUndefined();
2362             }
2363         }
2364 
2365         CommonSlowPaths::tryCacheGetFromScopeGlobal(exec, vm, bytecode, scope, slot, ident);
2366 
2367         if (!result)
2368             return slot.getValue(exec, ident);
2369         return result;
2370     })));
2371 }
2372 
2373 void JIT_OPERATION operationPutToScope(ExecState* exec, const Instruction* pc)
2374 {
2375     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2376     NativeCallFrameTracer tracer(vm, exec);</span>
2377     auto throwScope = DECLARE_THROW_SCOPE(vm);
2378 
2379     CodeBlock* codeBlock = exec-&gt;codeBlock();
2380     auto bytecode = pc-&gt;as&lt;OpPutToScope&gt;();
2381     auto&amp; metadata = bytecode.metadata(codeBlock);
2382 
2383     const Identifier&amp; ident = codeBlock-&gt;identifier(bytecode.m_var);
2384     JSObject* scope = jsCast&lt;JSObject*&gt;(exec-&gt;uncheckedR(bytecode.m_scope.offset()).jsValue());
2385     JSValue value = exec-&gt;r(bytecode.m_value.offset()).jsValue();
2386     GetPutInfo&amp; getPutInfo = metadata.m_getPutInfo;
2387 
2388     // ModuleVar does not keep the scope register value alive in DFG.
2389     ASSERT(getPutInfo.resolveType() != ModuleVar);
2390 
2391     if (getPutInfo.resolveType() == LocalClosureVar) {
2392         JSLexicalEnvironment* environment = jsCast&lt;JSLexicalEnvironment*&gt;(scope);
2393         environment-&gt;variableAt(ScopeOffset(metadata.m_operand)).set(vm, environment, value);
2394         if (WatchpointSet* set = metadata.m_watchpointSet)
2395             set-&gt;touch(vm, &quot;Executed op_put_scope&lt;LocalClosureVar&gt;&quot;);
2396         return;
2397     }
2398 
2399     bool hasProperty = scope-&gt;hasProperty(exec, ident);
<span class="line-modified">2400     RETURN_IF_EXCEPTION(throwScope, void());</span>
2401     if (hasProperty
2402         &amp;&amp; scope-&gt;isGlobalLexicalEnvironment()
2403         &amp;&amp; !isInitialization(getPutInfo.initializationMode())) {
2404         // When we can&#39;t statically prove we need a TDZ check, we must perform the check on the slow path.
2405         PropertySlot slot(scope, PropertySlot::InternalMethodType::Get);
2406         JSGlobalLexicalEnvironment::getOwnPropertySlot(scope, exec, ident, slot);
2407         if (slot.getValue(exec, ident) == jsTDZValue()) {
2408             throwException(exec, throwScope, createTDZError(exec));
2409             return;
2410         }
2411     }
2412 
2413     if (getPutInfo.resolveMode() == ThrowIfNotFound &amp;&amp; !hasProperty) {
2414         throwException(exec, throwScope, createUndefinedVariableError(exec, ident));
2415         return;
2416     }
2417 
2418     PutPropertySlot slot(scope, codeBlock-&gt;isStrictMode(), PutPropertySlot::UnknownContext, isInitialization(getPutInfo.initializationMode()));
2419     scope-&gt;methodTable(vm)-&gt;put(scope, exec, ident, value, slot);
2420 
2421     RETURN_IF_EXCEPTION(throwScope, void());
2422 
2423     CommonSlowPaths::tryCachePutToScopeGlobal(exec, codeBlock, bytecode, scope, slot, ident);
2424 }
2425 
2426 void JIT_OPERATION operationThrow(ExecState* exec, EncodedJSValue encodedExceptionValue)
2427 {
<span class="line-modified">2428     VM&amp; vm = exec-&gt;vm();</span>
2429     NativeCallFrameTracer tracer(vm, exec);
<span class="line-modified">2430     auto scope = DECLARE_THROW_SCOPE(vm);</span>
2431 
2432     JSValue exceptionValue = JSValue::decode(encodedExceptionValue);
2433     throwException(exec, scope, exceptionValue);
2434 
2435     // Results stored out-of-band in vm.targetMachinePCForThrow &amp; vm.callFrameForCatch
2436     genericUnwind(vm, exec);
2437 }
2438 
2439 char* JIT_OPERATION operationReallocateButterflyToHavePropertyStorageWithInitialCapacity(ExecState* exec, JSObject* object)
2440 {
2441     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2442     NativeCallFrameTracer tracer(vm, exec);</span>
2443 
2444     ASSERT(!object-&gt;structure(vm)-&gt;outOfLineCapacity());
2445     Butterfly* result = object-&gt;allocateMoreOutOfLineStorage(vm, 0, initialOutOfLineCapacity);
2446     object-&gt;nukeStructureAndSetButterfly(vm, object-&gt;structureID(), result);
2447     return reinterpret_cast&lt;char*&gt;(result);
2448 }
2449 
2450 char* JIT_OPERATION operationReallocateButterflyToGrowPropertyStorage(ExecState* exec, JSObject* object, size_t newSize)
2451 {
2452     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2453     NativeCallFrameTracer tracer(vm, exec);</span>
2454 
2455     Butterfly* result = object-&gt;allocateMoreOutOfLineStorage(vm, object-&gt;structure(vm)-&gt;outOfLineCapacity(), newSize);
2456     object-&gt;nukeStructureAndSetButterfly(vm, object-&gt;structureID(), result);
2457     return reinterpret_cast&lt;char*&gt;(result);
2458 }
2459 
2460 void JIT_OPERATION operationOSRWriteBarrier(ExecState* exec, JSCell* cell)
2461 {
<span class="line-modified">2462     VM&amp; vm = exec-&gt;vm();</span>
2463     NativeCallFrameTracer tracer(vm, exec);
<span class="line-modified">2464     vm.heap.writeBarrier(cell);</span>
2465 }
2466 
2467 void JIT_OPERATION operationWriteBarrierSlowPath(ExecState* exec, JSCell* cell)
2468 {
<span class="line-modified">2469     VM&amp; vm = exec-&gt;vm();</span>
2470     NativeCallFrameTracer tracer(vm, exec);
<span class="line-modified">2471     vm.heap.writeBarrierSlowPath(cell);</span>
2472 }
2473 
<span class="line-modified">2474 void JIT_OPERATION lookupExceptionHandler(VM* vmPointer, ExecState* exec)</span>
2475 {
<span class="line-added">2476     VM&amp; vm = *vmPointer;</span>
2477     NativeCallFrameTracer tracer(vm, exec);
2478     genericUnwind(vm, exec);
<span class="line-modified">2479     ASSERT(vm.targetMachinePCForThrow);</span>
2480 }
2481 
2482 void JIT_OPERATION lookupExceptionHandlerFromCallerFrame(VM* vm, ExecState* exec)
2483 {
2484     ASSERT(exec-&gt;isStackOverflowFrame());
2485     ASSERT(jsCast&lt;ErrorInstance*&gt;(vm-&gt;exceptionForInspection()-&gt;value().asCell())-&gt;isStackOverflowError());
2486     lookupExceptionHandler(vm, exec);
2487 }
2488 
2489 void JIT_OPERATION operationVMHandleException(ExecState* exec)
2490 {
<span class="line-modified">2491     VM&amp; vm = exec-&gt;vm();</span>
2492     NativeCallFrameTracer tracer(vm, exec);
2493     genericUnwind(vm, exec);
2494 }
2495 
2496 // This function &quot;should&quot; just take the ExecState*, but doing so would make it more difficult
2497 // to call from exception check sites. So, unlike all of our other functions, we allow
2498 // ourselves to play some gnarly ABI tricks just to simplify the calling convention. This is
2499 // particularly safe here since this is never called on the critical path - it&#39;s only for
2500 // testing.
2501 void JIT_OPERATION operationExceptionFuzz(ExecState* exec)
2502 {
<span class="line-modified">2503     VM&amp; vm = exec-&gt;vm();</span>
2504     NativeCallFrameTracer tracer(vm, exec);
<span class="line-modified">2505     auto scope = DECLARE_THROW_SCOPE(vm);</span>
2506     UNUSED_PARAM(scope);
2507 #if COMPILER(GCC_COMPATIBLE)
2508     void* returnPC = __builtin_return_address(0);
2509     doExceptionFuzzing(exec, scope, &quot;JITOperations&quot;, returnPC);
2510 #endif // COMPILER(GCC_COMPATIBLE)
2511 }
2512 
2513 ALWAYS_INLINE static EncodedJSValue unprofiledAdd(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)
2514 {
<span class="line-modified">2515     VM&amp; vm = exec-&gt;vm();</span>
2516     NativeCallFrameTracer tracer(vm, exec);
2517 
2518     JSValue op1 = JSValue::decode(encodedOp1);
2519     JSValue op2 = JSValue::decode(encodedOp2);
2520 
2521     return JSValue::encode(jsAdd(exec, op1, op2));
2522 }
2523 
2524 ALWAYS_INLINE static EncodedJSValue profiledAdd(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, ArithProfile&amp; arithProfile)
2525 {
<span class="line-modified">2526     VM&amp; vm = exec-&gt;vm();</span>
2527     NativeCallFrameTracer tracer(vm, exec);
2528 
2529     JSValue op1 = JSValue::decode(encodedOp1);
2530     JSValue op2 = JSValue::decode(encodedOp2);
2531 
2532     arithProfile.observeLHSAndRHS(op1, op2);
2533     JSValue result = jsAdd(exec, op1, op2);
2534     arithProfile.observeResult(result);
2535 
2536     return JSValue::encode(result);
2537 }
2538 
2539 EncodedJSValue JIT_OPERATION operationValueAdd(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)
2540 {
2541     return unprofiledAdd(exec, encodedOp1, encodedOp2);
2542 }
2543 
2544 EncodedJSValue JIT_OPERATION operationValueAddProfiled(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, ArithProfile* arithProfile)
2545 {
2546     ASSERT(arithProfile);
2547     return profiledAdd(exec, encodedOp1, encodedOp2, *arithProfile);
2548 }
2549 
2550 EncodedJSValue JIT_OPERATION operationValueAddProfiledOptimize(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, JITAddIC* addIC)
2551 {
<span class="line-modified">2552     VM&amp; vm = exec-&gt;vm();</span>
2553     NativeCallFrameTracer tracer(vm, exec);
2554 
2555     JSValue op1 = JSValue::decode(encodedOp1);
2556     JSValue op2 = JSValue::decode(encodedOp2);
2557 
2558     ArithProfile* arithProfile = addIC-&gt;arithProfile();
2559     ASSERT(arithProfile);
2560     arithProfile-&gt;observeLHSAndRHS(op1, op2);
2561     auto nonOptimizeVariant = operationValueAddProfiledNoOptimize;
2562     addIC-&gt;generateOutOfLine(exec-&gt;codeBlock(), nonOptimizeVariant);
2563 
2564 #if ENABLE(MATH_IC_STATS)
2565     exec-&gt;codeBlock()-&gt;dumpMathICStats();
2566 #endif
2567 
2568     JSValue result = jsAdd(exec, op1, op2);
2569     arithProfile-&gt;observeResult(result);
2570 
2571     return JSValue::encode(result);
2572 }
2573 
2574 EncodedJSValue JIT_OPERATION operationValueAddProfiledNoOptimize(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, JITAddIC* addIC)
2575 {
<span class="line-modified">2576     VM&amp; vm = exec-&gt;vm();</span>
2577     NativeCallFrameTracer tracer(vm, exec);
2578 
2579     ArithProfile* arithProfile = addIC-&gt;arithProfile();
2580     ASSERT(arithProfile);
2581     return profiledAdd(exec, encodedOp1, encodedOp2, *arithProfile);
2582 }
2583 
2584 EncodedJSValue JIT_OPERATION operationValueAddOptimize(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, JITAddIC* addIC)
2585 {
<span class="line-modified">2586     VM&amp; vm = exec-&gt;vm();</span>
2587     NativeCallFrameTracer tracer(vm, exec);
2588 
2589     JSValue op1 = JSValue::decode(encodedOp1);
2590     JSValue op2 = JSValue::decode(encodedOp2);
2591 
2592     auto nonOptimizeVariant = operationValueAddNoOptimize;
2593     if (ArithProfile* arithProfile = addIC-&gt;arithProfile())
2594         arithProfile-&gt;observeLHSAndRHS(op1, op2);
2595     addIC-&gt;generateOutOfLine(exec-&gt;codeBlock(), nonOptimizeVariant);
2596 
2597 #if ENABLE(MATH_IC_STATS)
2598     exec-&gt;codeBlock()-&gt;dumpMathICStats();
2599 #endif
2600 
2601     return JSValue::encode(jsAdd(exec, op1, op2));
2602 }
2603 
2604 EncodedJSValue JIT_OPERATION operationValueAddNoOptimize(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, JITAddIC*)
2605 {
<span class="line-modified">2606     VM&amp; vm = exec-&gt;vm();</span>
2607     NativeCallFrameTracer tracer(vm, exec);
2608 
2609     JSValue op1 = JSValue::decode(encodedOp1);
2610     JSValue op2 = JSValue::decode(encodedOp2);
2611 
2612     JSValue result = jsAdd(exec, op1, op2);
2613 
2614     return JSValue::encode(result);
2615 }
2616 
2617 ALWAYS_INLINE static EncodedJSValue unprofiledMul(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)
2618 {
2619     JSValue op1 = JSValue::decode(encodedOp1);
2620     JSValue op2 = JSValue::decode(encodedOp2);
2621 
2622     return JSValue::encode(jsMul(exec, op1, op2));
2623 }
2624 
2625 ALWAYS_INLINE static EncodedJSValue profiledMul(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, ArithProfile&amp; arithProfile, bool shouldObserveLHSAndRHSTypes = true)
2626 {
2627     VM&amp; vm = exec-&gt;vm();
2628     auto scope = DECLARE_THROW_SCOPE(vm);
2629     JSValue op1 = JSValue::decode(encodedOp1);
2630     JSValue op2 = JSValue::decode(encodedOp2);
2631 
2632     if (shouldObserveLHSAndRHSTypes)
2633         arithProfile.observeLHSAndRHS(op1, op2);
2634 
2635     JSValue result = jsMul(exec, op1, op2);
2636     RETURN_IF_EXCEPTION(scope, encodedJSValue());
2637     arithProfile.observeResult(result);
2638     return JSValue::encode(result);
2639 }
2640 
2641 EncodedJSValue JIT_OPERATION operationValueMul(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)
2642 {
<span class="line-modified">2643     VM&amp; vm = exec-&gt;vm();</span>
2644     NativeCallFrameTracer tracer(vm, exec);
2645 
2646     return unprofiledMul(exec, encodedOp1, encodedOp2);
2647 }
2648 
2649 EncodedJSValue JIT_OPERATION operationValueMulNoOptimize(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, JITMulIC*)
2650 {
<span class="line-modified">2651     VM&amp; vm = exec-&gt;vm();</span>
2652     NativeCallFrameTracer tracer(vm, exec);
2653 
2654     return unprofiledMul(exec, encodedOp1, encodedOp2);
2655 }
2656 
2657 EncodedJSValue JIT_OPERATION operationValueMulOptimize(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, JITMulIC* mulIC)
2658 {
<span class="line-modified">2659     VM&amp; vm = exec-&gt;vm();</span>
2660     NativeCallFrameTracer tracer(vm, exec);
2661 
2662     auto nonOptimizeVariant = operationValueMulNoOptimize;
2663     if (ArithProfile* arithProfile = mulIC-&gt;arithProfile())
2664         arithProfile-&gt;observeLHSAndRHS(JSValue::decode(encodedOp1), JSValue::decode(encodedOp2));
2665     mulIC-&gt;generateOutOfLine(exec-&gt;codeBlock(), nonOptimizeVariant);
2666 
2667 #if ENABLE(MATH_IC_STATS)
2668     exec-&gt;codeBlock()-&gt;dumpMathICStats();
2669 #endif
2670 
2671     return unprofiledMul(exec, encodedOp1, encodedOp2);
2672 }
2673 
2674 EncodedJSValue JIT_OPERATION operationValueMulProfiled(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, ArithProfile* arithProfile)
2675 {
<span class="line-modified">2676     VM&amp; vm = exec-&gt;vm();</span>
2677     NativeCallFrameTracer tracer(vm, exec);
2678 
2679     ASSERT(arithProfile);
2680     return profiledMul(exec, encodedOp1, encodedOp2, *arithProfile);
2681 }
2682 
2683 EncodedJSValue JIT_OPERATION operationValueMulProfiledOptimize(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, JITMulIC* mulIC)
2684 {
<span class="line-modified">2685     VM&amp; vm = exec-&gt;vm();</span>
2686     NativeCallFrameTracer tracer(vm, exec);
2687 
2688     ArithProfile* arithProfile = mulIC-&gt;arithProfile();
2689     ASSERT(arithProfile);
2690     arithProfile-&gt;observeLHSAndRHS(JSValue::decode(encodedOp1), JSValue::decode(encodedOp2));
2691     auto nonOptimizeVariant = operationValueMulProfiledNoOptimize;
2692     mulIC-&gt;generateOutOfLine(exec-&gt;codeBlock(), nonOptimizeVariant);
2693 
2694 #if ENABLE(MATH_IC_STATS)
2695     exec-&gt;codeBlock()-&gt;dumpMathICStats();
2696 #endif
2697 
2698     return profiledMul(exec, encodedOp1, encodedOp2, *arithProfile, false);
2699 }
2700 
2701 EncodedJSValue JIT_OPERATION operationValueMulProfiledNoOptimize(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, JITMulIC* mulIC)
2702 {
<span class="line-modified">2703     VM&amp; vm = exec-&gt;vm();</span>
2704     NativeCallFrameTracer tracer(vm, exec);
2705 
2706     ArithProfile* arithProfile = mulIC-&gt;arithProfile();
2707     ASSERT(arithProfile);
2708     return profiledMul(exec, encodedOp1, encodedOp2, *arithProfile);
2709 }
2710 
2711 ALWAYS_INLINE static EncodedJSValue unprofiledNegate(ExecState* exec, EncodedJSValue encodedOperand)
2712 {
2713     VM&amp; vm = exec-&gt;vm();
2714     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">2715     NativeCallFrameTracer tracer(vm, exec);</span>
2716 
2717     JSValue operand = JSValue::decode(encodedOperand);
2718 
2719     JSValue primValue = operand.toPrimitive(exec, PreferNumber);
2720     RETURN_IF_EXCEPTION(scope, encodedJSValue());
2721 
2722     if (primValue.isBigInt())
2723         return JSValue::encode(JSBigInt::unaryMinus(vm, asBigInt(primValue)));
2724 
2725     double number = primValue.toNumber(exec);
2726     RETURN_IF_EXCEPTION(scope, encodedJSValue());
2727     return JSValue::encode(jsNumber(-number));
2728 }
2729 
2730 ALWAYS_INLINE static EncodedJSValue profiledNegate(ExecState* exec, EncodedJSValue encodedOperand, ArithProfile&amp; arithProfile)
2731 {
2732     VM&amp; vm = exec-&gt;vm();
2733     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">2734     NativeCallFrameTracer tracer(vm, exec);</span>
2735 
2736     JSValue operand = JSValue::decode(encodedOperand);
2737     arithProfile.observeLHS(operand);
2738 
2739     JSValue primValue = operand.toPrimitive(exec);
2740     RETURN_IF_EXCEPTION(scope, encodedJSValue());
2741 
2742     if (primValue.isBigInt()) {
2743         JSBigInt* result = JSBigInt::unaryMinus(vm, asBigInt(primValue));
2744         arithProfile.observeResult(result);
2745 
2746         return JSValue::encode(result);
2747     }
2748 
2749     double number = primValue.toNumber(exec);
2750     RETURN_IF_EXCEPTION(scope, encodedJSValue());
2751     JSValue result = jsNumber(-number);
2752     arithProfile.observeResult(result);
2753     return JSValue::encode(result);
2754 }
2755 
2756 EncodedJSValue JIT_OPERATION operationArithNegate(ExecState* exec, EncodedJSValue operand)
2757 {
2758     return unprofiledNegate(exec, operand);
2759 }
2760 
2761 EncodedJSValue JIT_OPERATION operationArithNegateProfiled(ExecState* exec, EncodedJSValue operand, ArithProfile* arithProfile)
2762 {
2763     ASSERT(arithProfile);
2764     return profiledNegate(exec, operand, *arithProfile);
2765 }
2766 
2767 EncodedJSValue JIT_OPERATION operationArithNegateProfiledOptimize(ExecState* exec, EncodedJSValue encodedOperand, JITNegIC* negIC)
2768 {
2769     VM&amp; vm = exec-&gt;vm();
2770     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">2771     NativeCallFrameTracer tracer(vm, exec);</span>
2772 
2773     JSValue operand = JSValue::decode(encodedOperand);
2774 
2775     ArithProfile* arithProfile = negIC-&gt;arithProfile();
2776     ASSERT(arithProfile);
2777     arithProfile-&gt;observeLHS(operand);
2778     negIC-&gt;generateOutOfLine(exec-&gt;codeBlock(), operationArithNegateProfiled);
2779 
2780 #if ENABLE(MATH_IC_STATS)
2781     exec-&gt;codeBlock()-&gt;dumpMathICStats();
2782 #endif
2783 
2784     JSValue primValue = operand.toPrimitive(exec);
2785     RETURN_IF_EXCEPTION(scope, encodedJSValue());
2786 
2787     if (primValue.isBigInt()) {
2788         JSBigInt* result = JSBigInt::unaryMinus(vm, asBigInt(primValue));
2789         arithProfile-&gt;observeResult(result);
2790         return JSValue::encode(result);
2791     }
2792 
2793     double number = primValue.toNumber(exec);
2794     RETURN_IF_EXCEPTION(scope, encodedJSValue());
2795     JSValue result = jsNumber(-number);
2796     arithProfile-&gt;observeResult(result);
2797     return JSValue::encode(result);
2798 }
2799 
2800 EncodedJSValue JIT_OPERATION operationArithNegateOptimize(ExecState* exec, EncodedJSValue encodedOperand, JITNegIC* negIC)
2801 {
2802     VM&amp; vm = exec-&gt;vm();
2803     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">2804     NativeCallFrameTracer tracer(vm, exec);</span>
2805 
2806     JSValue operand = JSValue::decode(encodedOperand);
2807 
2808     if (ArithProfile* arithProfile = negIC-&gt;arithProfile())
2809         arithProfile-&gt;observeLHS(operand);
2810     negIC-&gt;generateOutOfLine(exec-&gt;codeBlock(), operationArithNegate);
2811 
2812 #if ENABLE(MATH_IC_STATS)
2813     exec-&gt;codeBlock()-&gt;dumpMathICStats();
2814 #endif
2815 
2816     JSValue primValue = operand.toPrimitive(exec);
2817     RETURN_IF_EXCEPTION(scope, encodedJSValue());
2818 
2819     if (primValue.isBigInt())
2820         return JSValue::encode(JSBigInt::unaryMinus(vm, asBigInt(primValue)));
2821 
2822     double number = primValue.toNumber(exec);
2823     RETURN_IF_EXCEPTION(scope, encodedJSValue());
2824     return JSValue::encode(jsNumber(-number));
</pre>
<hr />
<pre>
2833 }
2834 
2835 ALWAYS_INLINE static EncodedJSValue profiledSub(VM&amp; vm, ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, ArithProfile&amp; arithProfile, bool shouldObserveLHSAndRHSTypes = true)
2836 {
2837     auto scope = DECLARE_THROW_SCOPE(vm);
2838 
2839     JSValue op1 = JSValue::decode(encodedOp1);
2840     JSValue op2 = JSValue::decode(encodedOp2);
2841 
2842     if (shouldObserveLHSAndRHSTypes)
2843         arithProfile.observeLHSAndRHS(op1, op2);
2844 
2845     JSValue result = jsSub(exec, op1, op2);
2846     RETURN_IF_EXCEPTION(scope, encodedJSValue());
2847     arithProfile.observeResult(result);
2848     return JSValue::encode(result);
2849 }
2850 
2851 EncodedJSValue JIT_OPERATION operationValueSub(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)
2852 {
<span class="line-modified">2853     VM&amp; vm = exec-&gt;vm();</span>
2854     NativeCallFrameTracer tracer(vm, exec);
2855     return unprofiledSub(exec, encodedOp1, encodedOp2);
2856 }
2857 
2858 EncodedJSValue JIT_OPERATION operationValueSubProfiled(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, ArithProfile* arithProfile)
2859 {
2860     ASSERT(arithProfile);
2861 
<span class="line-modified">2862     VM&amp; vm = exec-&gt;vm();</span>
2863     NativeCallFrameTracer tracer(vm, exec);
2864 
<span class="line-modified">2865     return profiledSub(vm, exec, encodedOp1, encodedOp2, *arithProfile);</span>
2866 }
2867 
2868 EncodedJSValue JIT_OPERATION operationValueSubOptimize(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, JITSubIC* subIC)
2869 {
<span class="line-modified">2870     VM&amp; vm = exec-&gt;vm();</span>
2871     NativeCallFrameTracer tracer(vm, exec);
2872 
2873     auto nonOptimizeVariant = operationValueSubNoOptimize;
2874     if (ArithProfile* arithProfile = subIC-&gt;arithProfile())
2875         arithProfile-&gt;observeLHSAndRHS(JSValue::decode(encodedOp1), JSValue::decode(encodedOp2));
2876     subIC-&gt;generateOutOfLine(exec-&gt;codeBlock(), nonOptimizeVariant);
2877 
2878 #if ENABLE(MATH_IC_STATS)
2879     exec-&gt;codeBlock()-&gt;dumpMathICStats();
2880 #endif
2881 
2882     return unprofiledSub(exec, encodedOp1, encodedOp2);
2883 }
2884 
2885 EncodedJSValue JIT_OPERATION operationValueSubNoOptimize(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, JITSubIC*)
2886 {
<span class="line-modified">2887     VM&amp; vm = exec-&gt;vm();</span>
2888     NativeCallFrameTracer tracer(vm, exec);
2889 
2890     return unprofiledSub(exec, encodedOp1, encodedOp2);
2891 }
2892 
2893 EncodedJSValue JIT_OPERATION operationValueSubProfiledOptimize(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, JITSubIC* subIC)
2894 {
<span class="line-modified">2895     VM&amp; vm = exec-&gt;vm();</span>
2896     NativeCallFrameTracer tracer(vm, exec);
2897 
2898     ArithProfile* arithProfile = subIC-&gt;arithProfile();
2899     ASSERT(arithProfile);
2900     arithProfile-&gt;observeLHSAndRHS(JSValue::decode(encodedOp1), JSValue::decode(encodedOp2));
2901     auto nonOptimizeVariant = operationValueSubProfiledNoOptimize;
2902     subIC-&gt;generateOutOfLine(exec-&gt;codeBlock(), nonOptimizeVariant);
2903 
2904 #if ENABLE(MATH_IC_STATS)
2905     exec-&gt;codeBlock()-&gt;dumpMathICStats();
2906 #endif
2907 
<span class="line-modified">2908     return profiledSub(vm, exec, encodedOp1, encodedOp2, *arithProfile, false);</span>
2909 }
2910 
2911 EncodedJSValue JIT_OPERATION operationValueSubProfiledNoOptimize(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, JITSubIC* subIC)
2912 {
<span class="line-modified">2913     VM&amp; vm = exec-&gt;vm();</span>
2914     NativeCallFrameTracer tracer(vm, exec);
2915 
2916     ArithProfile* arithProfile = subIC-&gt;arithProfile();
2917     ASSERT(arithProfile);
<span class="line-modified">2918     return profiledSub(vm, exec, encodedOp1, encodedOp2, *arithProfile);</span>
2919 }
2920 
2921 void JIT_OPERATION operationProcessTypeProfilerLog(ExecState* exec)
2922 {
2923     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2924     NativeCallFrameTracer tracer(vm, exec);</span>
2925     vm.typeProfilerLog()-&gt;processLogEntries(vm, &quot;Log Full, called from inside baseline JIT&quot;_s);
2926 }
2927 
2928 void JIT_OPERATION operationProcessShadowChickenLog(ExecState* exec)
2929 {
2930     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2931     NativeCallFrameTracer tracer(vm, exec);</span>
2932     RELEASE_ASSERT(vm.shadowChicken());
2933     vm.shadowChicken()-&gt;update(vm, exec);
2934 }
2935 
2936 int32_t JIT_OPERATION operationCheckIfExceptionIsUncatchableAndNotifyProfiler(ExecState* exec)
2937 {
2938     VM&amp; vm = exec-&gt;vm();
<span class="line-modified">2939     NativeCallFrameTracer tracer(vm, exec);</span>
2940     auto scope = DECLARE_THROW_SCOPE(vm);
2941     RELEASE_ASSERT(!!scope.exception());
2942 
2943     if (isTerminatedExecutionException(vm, scope.exception())) {
<span class="line-modified">2944         genericUnwind(vm, exec);</span>
2945         return 1;
2946     }
2947     return 0;
2948 }
2949 
2950 } // extern &quot;C&quot;
2951 
2952 } // namespace JSC
2953 
2954 #endif // ENABLE(JIT)
</pre>
</td>
</tr>
</table>
<center><a href="JITOpcodes32_64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JITOperations.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>