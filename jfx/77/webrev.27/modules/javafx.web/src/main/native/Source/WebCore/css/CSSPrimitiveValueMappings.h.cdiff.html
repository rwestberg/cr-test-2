<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/css/CSSPrimitiveValueMappings.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CSSPrimitiveValue.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CSSProperties.json.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/css/CSSPrimitiveValueMappings.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1407,10 ***</span>
<span class="line-new-header">--- 1407,13 ---</span>
          m_value.valueID = CSSValueNone;
          break;
      case DisplayType::Contents:
          m_value.valueID = CSSValueContents;
          break;
<span class="line-added">+     case DisplayType::FlowRoot:</span>
<span class="line-added">+         m_value.valueID = CSSValueFlowRoot;</span>
<span class="line-added">+         break;</span>
      }
  }
  
  template&lt;&gt; inline CSSPrimitiveValue::operator DisplayType() const
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1642,10 ***</span>
<span class="line-new-header">--- 1645,13 ---</span>
          m_value.valueID = CSSValueStrict;
          break;
      case LineBreak::AfterWhiteSpace:
          m_value.valueID = CSSValueAfterWhiteSpace;
          break;
<span class="line-added">+     case LineBreak::Anywhere:</span>
<span class="line-added">+         m_value.valueID = CSSValueAnywhere;</span>
<span class="line-added">+         break;</span>
      }
  }
  
  template&lt;&gt; inline CSSPrimitiveValue::operator OptionSet&lt;HangingPunctuation&gt;() const
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1683,10 ***</span>
<span class="line-new-header">--- 1689,12 ---</span>
          return LineBreak::Normal;
      case CSSValueStrict:
          return LineBreak::Strict;
      case CSSValueAfterWhiteSpace:
          return LineBreak::AfterWhiteSpace;
<span class="line-added">+     case CSSValueAnywhere:</span>
<span class="line-added">+         return LineBreak::Anywhere;</span>
      default:
          break;
      }
  
      ASSERT_NOT_REACHED();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2333,11 ***</span>
          break;
      case PositionType::Fixed:
          m_value.valueID = CSSValueFixed;
          break;
      case PositionType::Sticky:
<span class="line-modified">!         m_value.valueID = CSSValueWebkitSticky;</span>
          break;
      }
  }
  
  template&lt;&gt; inline CSSPrimitiveValue::operator PositionType() const
<span class="line-new-header">--- 2341,11 ---</span>
          break;
      case PositionType::Fixed:
          m_value.valueID = CSSValueFixed;
          break;
      case PositionType::Sticky:
<span class="line-modified">!         m_value.valueID = CSSValueSticky;</span>
          break;
      }
  }
  
  template&lt;&gt; inline CSSPrimitiveValue::operator PositionType() const
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2351,10 ***</span>
<span class="line-new-header">--- 2359,11 ---</span>
          return PositionType::Relative;
      case CSSValueAbsolute:
          return PositionType::Absolute;
      case CSSValueFixed:
          return PositionType::Fixed;
<span class="line-added">+     case CSSValueSticky:</span>
      case CSSValueWebkitSticky:
          return PositionType::Sticky;
      default:
          break;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3049,10 ***</span>
<span class="line-new-header">--- 3058,13 ---</span>
          m_value.valueID = CSSValueNowrap;
          break;
      case WhiteSpace::KHTMLNoWrap:
          m_value.valueID = CSSValueWebkitNowrap;
          break;
<span class="line-added">+     case WhiteSpace::BreakSpaces:</span>
<span class="line-added">+         m_value.valueID = CSSValueBreakSpaces;</span>
<span class="line-added">+         break;</span>
      }
  }
  
  template&lt;&gt; inline CSSPrimitiveValue::operator WhiteSpace() const
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3069,10 ***</span>
<span class="line-new-header">--- 3081,12 ---</span>
          return WhiteSpace::PreWrap;
      case CSSValuePreLine:
          return WhiteSpace::PreLine;
      case CSSValueNormal:
          return WhiteSpace::Normal;
<span class="line-added">+     case CSSValueBreakSpaces:</span>
<span class="line-added">+         return WhiteSpace::BreakSpaces;</span>
      default:
          break;
      }
  
      ASSERT_NOT_REACHED();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4858,53 ***</span>
      return MaskType::Luminance;
  }
  
  #if ENABLE(CSS_IMAGE_ORIENTATION)
  
<span class="line-modified">! template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(ImageOrientationEnum e)</span>
      : CSSValue(PrimitiveClass)
  {
      m_primitiveUnitType = CSS_DEG;
      switch (e) {
<span class="line-modified">!     case OriginTopLeft:</span>
          m_value.num = 0;
          break;
<span class="line-modified">!     case OriginRightTop:</span>
          m_value.num = 90;
          break;
<span class="line-modified">!     case OriginBottomRight:</span>
          m_value.num = 180;
          break;
<span class="line-modified">!     case OriginLeftBottom:</span>
          m_value.num = 270;
          break;
<span class="line-modified">!     case OriginTopRight:</span>
<span class="line-modified">!     case OriginLeftTop:</span>
<span class="line-modified">!     case OriginBottomLeft:</span>
<span class="line-modified">!     case OriginRightBottom:</span>
          ASSERT_NOT_REACHED();
      }
  }
  
<span class="line-modified">! template&lt;&gt; inline CSSPrimitiveValue::operator ImageOrientationEnum() const</span>
  {
      ASSERT(isAngle());
      double quarters = 4 * doubleValue(CSS_TURN);
      int orientation = 3 &amp; static_cast&lt;int&gt;(quarters &lt; 0 ? floor(quarters) : ceil(quarters));
      switch (orientation) {
      case 0:
<span class="line-modified">!         return OriginTopLeft;</span>
      case 1:
<span class="line-modified">!         return OriginRightTop;</span>
      case 2:
<span class="line-modified">!         return OriginBottomRight;</span>
      case 3:
<span class="line-modified">!         return OriginLeftBottom;</span>
      }
  
      ASSERT_NOT_REACHED();
<span class="line-modified">!     return OriginTopLeft;</span>
  }
  
  #endif // ENABLE(CSS_IMAGE_ORIENTATION)
  
  template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(CSSBoxType cssBox)
<span class="line-new-header">--- 4872,54 ---</span>
      return MaskType::Luminance;
  }
  
  #if ENABLE(CSS_IMAGE_ORIENTATION)
  
<span class="line-modified">! template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(ImageOrientation e)</span>
      : CSSValue(PrimitiveClass)
  {
      m_primitiveUnitType = CSS_DEG;
      switch (e) {
<span class="line-modified">!     case ImageOrientation::OriginTopLeft:</span>
          m_value.num = 0;
          break;
<span class="line-modified">!     case ImageOrientation::OriginRightTop:</span>
          m_value.num = 90;
          break;
<span class="line-modified">!     case ImageOrientation::OriginBottomRight:</span>
          m_value.num = 180;
          break;
<span class="line-modified">!     case ImageOrientation::OriginLeftBottom:</span>
          m_value.num = 270;
          break;
<span class="line-modified">!     case ImageOrientation::FromImage:</span>
<span class="line-modified">!     case ImageOrientation::OriginTopRight:</span>
<span class="line-modified">!     case ImageOrientation::OriginLeftTop:</span>
<span class="line-modified">!     case ImageOrientation::OriginBottomLeft:</span>
<span class="line-added">+     case ImageOrientation::OriginRightBottom:</span>
          ASSERT_NOT_REACHED();
      }
  }
  
<span class="line-modified">! template&lt;&gt; inline CSSPrimitiveValue::operator ImageOrientation() const</span>
  {
      ASSERT(isAngle());
      double quarters = 4 * doubleValue(CSS_TURN);
      int orientation = 3 &amp; static_cast&lt;int&gt;(quarters &lt; 0 ? floor(quarters) : ceil(quarters));
      switch (orientation) {
      case 0:
<span class="line-modified">!         return ImageOrientation::OriginTopLeft;</span>
      case 1:
<span class="line-modified">!         return ImageOrientation::OriginRightTop;</span>
      case 2:
<span class="line-modified">!         return ImageOrientation::OriginBottomRight;</span>
      case 3:
<span class="line-modified">!         return ImageOrientation::OriginLeftBottom;</span>
      }
  
      ASSERT_NOT_REACHED();
<span class="line-modified">!     return ImageOrientation::None;</span>
  }
  
  #endif // ENABLE(CSS_IMAGE_ORIENTATION)
  
  template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(CSSBoxType cssBox)
</pre>
<center><a href="CSSPrimitiveValue.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CSSProperties.json.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>