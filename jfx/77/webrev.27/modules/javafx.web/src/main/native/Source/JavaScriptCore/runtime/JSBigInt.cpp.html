<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSBigInt.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2017 Caio Lima &lt;ticaiolima@gmail.com&gt;
   3  * Copyright (C) 2017-2018 Apple Inc. All rights reserved.
   4  *
   5  * Redistribution and use in source and binary forms, with or without
   6  * modification, are permitted provided that the following conditions
   7  * are met:
   8  * 1. Redistributions of source code must retain the above copyright
   9  *    notice, this list of conditions and the following disclaimer.
  10  * 2. Redistributions in binary form must reproduce the above copyright
  11  *    notice, this list of conditions and the following disclaimer in the
  12  *    documentation and/or other materials provided with the distribution.
  13  *
  14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  25  *
  26  * Parts of the implementation below:
  27  *
  28  * Copyright 2017 the V8 project authors. All rights reserved.
  29  * Use of this source code is governed by a BSD-style license that can be
  30  * found in the LICENSE file.
  31  *
  32  *
  33  * Copyright (c) 2014 the Dart project authors.  Please see the AUTHORS file [1]
  34  * for details. All rights reserved. Use of this source code is governed by a
  35  * BSD-style license that can be found in the LICENSE file [2].
  36  *
  37  * [1] https://github.com/dart-lang/sdk/blob/master/AUTHORS
  38  * [2] https://github.com/dart-lang/sdk/blob/master/LICENSE
  39  *
  40  * Copyright 2009 The Go Authors. All rights reserved.
  41  * Use of this source code is governed by a BSD-style
  42  * license that can be found in the LICENSE file [3].
  43  *
  44  * [3] https://golang.org/LICENSE
  45  */
  46 
  47 #include &quot;config.h&quot;
  48 #include &quot;JSBigInt.h&quot;
  49 
  50 #include &quot;BigIntObject.h&quot;
  51 #include &quot;CatchScope.h&quot;
  52 #include &quot;JSCInlines.h&quot;
  53 #include &quot;MathCommon.h&quot;
  54 #include &quot;ParseInt.h&quot;
  55 #include &lt;algorithm&gt;
  56 #include &lt;wtf/MathExtras.h&gt;
  57 
  58 #define STATIC_ASSERT(cond) static_assert(cond, &quot;JSBigInt assumes &quot; #cond)
  59 
  60 namespace JSC {
  61 
  62 const ClassInfo JSBigInt::s_info = { &quot;BigInt&quot;, nullptr, nullptr, nullptr, CREATE_METHOD_TABLE(JSBigInt) };
  63 
  64 JSBigInt::JSBigInt(VM&amp; vm, Structure* structure, unsigned length)
  65     : Base(vm, structure)
  66     , m_length(length)
  67 { }
  68 
  69 void JSBigInt::initialize(InitializationType initType)
  70 {
  71     if (initType == InitializationType::WithZero)
  72         memset(dataStorage(), 0, length() * sizeof(Digit));
  73 }
  74 
  75 Structure* JSBigInt::createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
  76 {
  77     return Structure::create(vm, globalObject, prototype, TypeInfo(BigIntType, StructureFlags), info());
  78 }
  79 
  80 JSBigInt* JSBigInt::createZero(VM&amp; vm)
  81 {
  82     JSBigInt* zeroBigInt = createWithLengthUnchecked(vm, 0);
  83     return zeroBigInt;
  84 }
  85 
  86 inline size_t JSBigInt::allocationSize(unsigned length)
  87 {
  88     size_t sizeWithPadding = WTF::roundUpToMultipleOf&lt;sizeof(size_t)&gt;(sizeof(JSBigInt));
  89     return sizeWithPadding + length * sizeof(Digit);
  90 }
  91 
  92 JSBigInt* JSBigInt::tryCreateWithLength(ExecState* exec, unsigned length)
  93 {
  94     VM&amp; vm = exec-&gt;vm();
  95     auto scope = DECLARE_THROW_SCOPE(vm);
  96 
  97     if (UNLIKELY(length &gt; maxLength)) {
  98         throwOutOfMemoryError(exec, scope);
  99         return nullptr;
 100     }
 101 
 102     scope.release();
 103 
 104     return createWithLengthUnchecked(vm, length);
 105 }
 106 
 107 JSBigInt* JSBigInt::createWithLengthUnchecked(VM&amp; vm, unsigned length)
 108 {
 109     ASSERT(length &lt;= maxLength);
 110     JSBigInt* bigInt = new (NotNull, allocateCell&lt;JSBigInt&gt;(vm.heap, allocationSize(length))) JSBigInt(vm, vm.bigIntStructure.get(), length);
 111     bigInt-&gt;finishCreation(vm);
 112     return bigInt;
 113 }
 114 
 115 JSBigInt* JSBigInt::createFrom(VM&amp; vm, int32_t value)
 116 {
 117     if (!value)
 118         return createZero(vm);
 119 
 120     JSBigInt* bigInt = createWithLengthUnchecked(vm, 1);
 121     if (value &lt; 0) {
 122         bigInt-&gt;setDigit(0, static_cast&lt;Digit&gt;(-1 * static_cast&lt;int64_t&gt;(value)));
 123         bigInt-&gt;setSign(true);
 124     } else
 125         bigInt-&gt;setDigit(0, static_cast&lt;Digit&gt;(value));
 126 
 127     return bigInt;
 128 }
 129 
 130 JSBigInt* JSBigInt::createFrom(VM&amp; vm, uint32_t value)
 131 {
 132     if (!value)
 133         return createZero(vm);
 134 
 135     JSBigInt* bigInt = createWithLengthUnchecked(vm, 1);
 136     bigInt-&gt;setDigit(0, static_cast&lt;Digit&gt;(value));
 137     return bigInt;
 138 }
 139 
 140 JSBigInt* JSBigInt::createFrom(VM&amp; vm, int64_t value)
 141 {
 142     if (!value)
 143         return createZero(vm);
 144 
 145     if (sizeof(Digit) == 8) {
 146         JSBigInt* bigInt = createWithLengthUnchecked(vm, 1);
 147         if (value &lt; 0) {
 148             bigInt-&gt;setDigit(0, static_cast&lt;Digit&gt;(static_cast&lt;uint64_t&gt;(-(value + 1)) + 1));
 149             bigInt-&gt;setSign(true);
 150         } else
 151             bigInt-&gt;setDigit(0, static_cast&lt;Digit&gt;(value));
 152 
 153         return bigInt;
 154     }
 155 
 156     JSBigInt* bigInt = createWithLengthUnchecked(vm, 2);
 157     uint64_t tempValue;
 158     bool sign = false;
 159     if (value &lt; 0) {
 160         tempValue = static_cast&lt;uint64_t&gt;(-(value + 1)) + 1;
 161         sign = true;
 162     } else
 163         tempValue = value;
 164 
 165     Digit lowBits  = static_cast&lt;Digit&gt;(tempValue &amp; 0xffffffff);
 166     Digit highBits = static_cast&lt;Digit&gt;((tempValue &gt;&gt; 32) &amp; 0xffffffff);
 167 
 168     bigInt-&gt;setDigit(0, lowBits);
 169     bigInt-&gt;setDigit(1, highBits);
 170     bigInt-&gt;setSign(sign);
 171 
 172     return bigInt;
 173 }
 174 
 175 JSBigInt* JSBigInt::createFrom(VM&amp; vm, bool value)
 176 {
 177     if (!value)
 178         return createZero(vm);
 179 
 180     JSBigInt* bigInt = createWithLengthUnchecked(vm, 1);
 181     bigInt-&gt;setDigit(0, static_cast&lt;Digit&gt;(value));
 182     return bigInt;
 183 }
 184 
 185 JSValue JSBigInt::toPrimitive(ExecState*, PreferredPrimitiveType) const
 186 {
 187     return const_cast&lt;JSBigInt*&gt;(this);
 188 }
 189 
 190 Optional&lt;uint8_t&gt; JSBigInt::singleDigitValueForString()
 191 {
 192     if (isZero())
 193         return 0;
 194 
 195     if (length() == 1 &amp;&amp; !sign()) {
 196         Digit rDigit = digit(0);
 197         if (rDigit &lt;= 9)
 198             return static_cast&lt;uint8_t&gt;(rDigit);
 199     }
 200     return { };
 201 }
 202 
 203 JSBigInt* JSBigInt::parseInt(ExecState* exec, StringView s, ErrorParseMode parserMode)
 204 {
 205     if (s.is8Bit())
 206         return parseInt(exec, s.characters8(), s.length(), parserMode);
 207     return parseInt(exec, s.characters16(), s.length(), parserMode);
 208 }
 209 
 210 JSBigInt* JSBigInt::parseInt(ExecState* exec, VM&amp; vm, StringView s, uint8_t radix, ErrorParseMode parserMode, ParseIntSign sign)
 211 {
 212     if (s.is8Bit())
 213         return parseInt(exec, vm, s.characters8(), s.length(), 0, radix, parserMode, sign, ParseIntMode::DisallowEmptyString);
 214     return parseInt(exec, vm, s.characters16(), s.length(), 0, radix, parserMode, sign, ParseIntMode::DisallowEmptyString);
 215 }
 216 
 217 JSBigInt* JSBigInt::stringToBigInt(ExecState* exec, StringView s)
 218 {
 219     return parseInt(exec, s, ErrorParseMode::IgnoreExceptions);
 220 }
 221 
 222 String JSBigInt::toString(ExecState* exec, unsigned radix)
 223 {
 224     if (this-&gt;isZero())
 225         return exec-&gt;vm().smallStrings.singleCharacterStringRep(&#39;0&#39;);
 226 
 227     if (hasOneBitSet(radix))
 228         return toStringBasePowerOfTwo(exec-&gt;vm(), exec, this, radix);
 229 
 230     return toStringGeneric(exec-&gt;vm(), exec, this, radix);
 231 }
 232 
 233 String JSBigInt::tryGetString(VM&amp; vm, JSBigInt* bigInt, unsigned radix)
 234 {
 235     if (bigInt-&gt;isZero())
 236         return vm.smallStrings.singleCharacterStringRep(&#39;0&#39;);
 237 
 238     if (hasOneBitSet(radix))
 239         return toStringBasePowerOfTwo(vm, nullptr, bigInt, radix);
 240 
 241     return toStringGeneric(vm, nullptr, bigInt, radix);
 242 }
 243 
 244 // Multiplies {this} with {factor} and adds {summand} to the result.
 245 void JSBigInt::inplaceMultiplyAdd(Digit factor, Digit summand)
 246 {
 247     internalMultiplyAdd(this, factor, summand, length(), this);
 248 }
 249 
 250 JSBigInt* JSBigInt::exponentiate(ExecState* exec, JSBigInt* base, JSBigInt* exponent)
 251 {
 252     VM&amp; vm = exec-&gt;vm();
 253     auto scope = DECLARE_THROW_SCOPE(vm);
 254 
 255     if (exponent-&gt;sign()) {
 256         throwRangeError(exec, scope, &quot;Negative exponent is not allowed&quot;_s);
 257         return nullptr;
 258     }
 259 
 260     // 2. If base is 0n and exponent is 0n, return 1n.
 261     if (exponent-&gt;isZero())
 262         return JSBigInt::createFrom(vm, 1);
 263 
 264     // 3. Return a BigInt representing the mathematical value of base raised
 265     //    to the power exponent.
 266     if (base-&gt;isZero())
 267         return base;
 268 
 269     if (base-&gt;length() == 1 &amp;&amp; base-&gt;digit(0) == 1) {
 270         // (-1) ** even_number == 1.
 271         if (base-&gt;sign() &amp;&amp; !(exponent-&gt;digit(0) &amp; 1))
 272             return JSBigInt::unaryMinus(vm, base);
 273 
 274         // (-1) ** odd_number == -1; 1 ** anything == 1.
 275         return base;
 276     }
 277 
 278     // For all bases &gt;= 2, very large exponents would lead to unrepresentable
 279     // results.
 280     static_assert(maxLengthBits &lt; std::numeric_limits&lt;Digit&gt;::max(), &quot;maxLengthBits needs to be less than digit::max()&quot;);
 281     if (exponent-&gt;length() &gt; 1) {
 282         throwRangeError(exec, scope, &quot;BigInt generated from this operation is too big&quot;_s);
 283         return nullptr;
 284     }
 285 
 286     Digit expValue = exponent-&gt;digit(0);
 287     if (expValue == 1)
 288         return base;
 289     if (expValue &gt;= maxLengthBits) {
 290         throwRangeError(exec, scope, &quot;BigInt generated from this operation is too big&quot;_s);
 291         return nullptr;
 292     }
 293 
 294     static_assert(maxLengthBits &lt;= maxInt, &quot;maxLengthBits needs to be &lt;= maxInt&quot;);
 295     int n = static_cast&lt;int&gt;(expValue);
 296     if (base-&gt;length() == 1 &amp;&amp; base-&gt;digit(0) == 2) {
 297         // Fast path for 2^n.
 298         int neededDigits = 1 + (n / digitBits);
 299         JSBigInt* result = JSBigInt::tryCreateWithLength(exec, neededDigits);
 300         RETURN_IF_EXCEPTION(scope, nullptr);
 301 
 302         result-&gt;initialize(InitializationType::WithZero);
 303         // All bits are zero. Now set the n-th bit.
 304         Digit msd = static_cast&lt;Digit&gt;(1) &lt;&lt; (n % digitBits);
 305         result-&gt;setDigit(neededDigits - 1, msd);
 306         // Result is negative for odd powers of -2n.
 307         if (base-&gt;sign())
 308             result-&gt;setSign(static_cast&lt;bool&gt;(n &amp; 1));
 309 
 310         return result;
 311     }
 312 
 313     JSBigInt* result = nullptr;
 314     JSBigInt* runningSquare = base;
 315 
 316     // This implicitly sets the result&#39;s sign correctly.
 317     if (n &amp; 1)
 318         result = base;
 319 
 320     n &gt;&gt;= 1;
 321     for (; n; n &gt;&gt;= 1) {
 322         JSBigInt* maybeResult = JSBigInt::multiply(exec, runningSquare, runningSquare);
 323         RETURN_IF_EXCEPTION(scope, nullptr);
 324         runningSquare = maybeResult;
 325         if (n &amp; 1) {
 326             if (!result)
 327                 result = runningSquare;
 328             else {
 329                 maybeResult = JSBigInt::multiply(exec, result, runningSquare);
 330                 RETURN_IF_EXCEPTION(scope, nullptr);
 331                 result = maybeResult;
 332             }
 333         }
 334     }
 335 
 336     return result;
 337 }
 338 
 339 JSBigInt* JSBigInt::multiply(ExecState* exec, JSBigInt* x, JSBigInt* y)
 340 {
 341     VM&amp; vm = exec-&gt;vm();
 342     auto scope = DECLARE_THROW_SCOPE(vm);
 343 
 344     if (x-&gt;isZero())
 345         return x;
 346     if (y-&gt;isZero())
 347         return y;
 348 
 349     unsigned resultLength = x-&gt;length() + y-&gt;length();
 350     JSBigInt* result = JSBigInt::tryCreateWithLength(exec, resultLength);
 351     RETURN_IF_EXCEPTION(scope, nullptr);
 352     result-&gt;initialize(InitializationType::WithZero);
 353 
 354     for (unsigned i = 0; i &lt; x-&gt;length(); i++)
 355         multiplyAccumulate(y, x-&gt;digit(i), result, i);
 356 
 357     result-&gt;setSign(x-&gt;sign() != y-&gt;sign());
 358     return result-&gt;rightTrim(vm);
 359 }
 360 
 361 JSBigInt* JSBigInt::divide(ExecState* exec, JSBigInt* x, JSBigInt* y)
 362 {
 363     // 1. If y is 0n, throw a RangeError exception.
 364     VM&amp; vm = exec-&gt;vm();
 365     auto scope = DECLARE_THROW_SCOPE(vm);
 366 
 367     if (y-&gt;isZero()) {
 368         throwRangeError(exec, scope, &quot;0 is an invalid divisor value.&quot;_s);
 369         return nullptr;
 370     }
 371 
 372     // 2. Let quotient be the mathematical value of x divided by y.
 373     // 3. Return a BigInt representing quotient rounded towards 0 to the next
 374     //    integral value.
 375     if (absoluteCompare(x, y) == ComparisonResult::LessThan)
 376         return createZero(vm);
 377 
 378     JSBigInt* quotient = nullptr;
 379     bool resultSign = x-&gt;sign() != y-&gt;sign();
 380     if (y-&gt;length() == 1) {
 381         Digit divisor = y-&gt;digit(0);
 382         if (divisor == 1)
 383             return resultSign == x-&gt;sign() ? x : unaryMinus(vm, x);
 384 
 385         Digit remainder;
 386         absoluteDivWithDigitDivisor(vm, x, divisor, &amp;quotient, remainder);
 387     } else {
 388         absoluteDivWithBigIntDivisor(exec, x, y, &amp;quotient, nullptr);
 389         RETURN_IF_EXCEPTION(scope, nullptr);
 390     }
 391 
 392     quotient-&gt;setSign(resultSign);
 393     return quotient-&gt;rightTrim(vm);
 394 }
 395 
 396 JSBigInt* JSBigInt::copy(VM&amp; vm, JSBigInt* x)
 397 {
 398     ASSERT(!x-&gt;isZero());
 399 
 400     JSBigInt* result = JSBigInt::createWithLengthUnchecked(vm, x-&gt;length());
 401     std::copy(x-&gt;dataStorage(), x-&gt;dataStorage() + x-&gt;length(), result-&gt;dataStorage());
 402     result-&gt;setSign(x-&gt;sign());
 403     return result;
 404 }
 405 
 406 JSBigInt* JSBigInt::unaryMinus(VM&amp; vm, JSBigInt* x)
 407 {
 408     if (x-&gt;isZero())
 409         return x;
 410 
 411     JSBigInt* result = copy(vm, x);
 412     result-&gt;setSign(!x-&gt;sign());
 413     return result;
 414 }
 415 
 416 JSBigInt* JSBigInt::remainder(ExecState* exec, JSBigInt* x, JSBigInt* y)
 417 {
 418     // 1. If y is 0n, throw a RangeError exception.
 419     VM&amp; vm = exec-&gt;vm();
 420     auto scope = DECLARE_THROW_SCOPE(vm);
 421 
 422     if (y-&gt;isZero()) {
 423         throwRangeError(exec, scope, &quot;0 is an invalid divisor value.&quot;_s);
 424         return nullptr;
 425     }
 426 
 427     // 2. Return the JSBigInt representing x modulo y.
 428     // See https://github.com/tc39/proposal-bigint/issues/84 though.
 429     if (absoluteCompare(x, y) == ComparisonResult::LessThan)
 430         return x;
 431 
 432     JSBigInt* remainder;
 433     if (y-&gt;length() == 1) {
 434         Digit divisor = y-&gt;digit(0);
 435         if (divisor == 1)
 436             return createZero(vm);
 437 
 438         Digit remainderDigit;
 439         absoluteDivWithDigitDivisor(vm, x, divisor, nullptr, remainderDigit);
 440         if (!remainderDigit)
 441             return createZero(vm);
 442 
 443         remainder = createWithLengthUnchecked(vm, 1);
 444         remainder-&gt;setDigit(0, remainderDigit);
 445     } else {
 446         absoluteDivWithBigIntDivisor(exec, x, y, nullptr, &amp;remainder);
 447         RETURN_IF_EXCEPTION(scope, nullptr);
 448     }
 449 
 450     remainder-&gt;setSign(x-&gt;sign());
 451     return remainder-&gt;rightTrim(vm);
 452 }
 453 
 454 JSBigInt* JSBigInt::add(ExecState* exec, JSBigInt* x, JSBigInt* y)
 455 {
 456     VM&amp; vm = exec-&gt;vm();
 457     bool xSign = x-&gt;sign();
 458 
 459     // x + y == x + y
 460     // -x + -y == -(x + y)
 461     if (xSign == y-&gt;sign())
 462         return absoluteAdd(exec, x, y, xSign);
 463 
 464     // x + -y == x - y == -(y - x)
 465     // -x + y == y - x == -(x - y)
 466     ComparisonResult comparisonResult = absoluteCompare(x, y);
 467     if (comparisonResult == ComparisonResult::GreaterThan || comparisonResult == ComparisonResult::Equal)
 468         return absoluteSub(vm, x, y, xSign);
 469 
 470     return absoluteSub(vm, y, x, !xSign);
 471 }
 472 
 473 JSBigInt* JSBigInt::sub(ExecState* exec, JSBigInt* x, JSBigInt* y)
 474 {
 475     VM&amp; vm = exec-&gt;vm();
 476     bool xSign = x-&gt;sign();
 477     if (xSign != y-&gt;sign()) {
 478         // x - (-y) == x + y
 479         // (-x) - y == -(x + y)
 480         return absoluteAdd(exec, x, y, xSign);
 481     }
 482     // x - y == -(y - x)
 483     // (-x) - (-y) == y - x == -(x - y)
 484     ComparisonResult comparisonResult = absoluteCompare(x, y);
 485     if (comparisonResult == ComparisonResult::GreaterThan || comparisonResult == ComparisonResult::Equal)
 486         return absoluteSub(vm, x, y, xSign);
 487 
 488     return absoluteSub(vm, y, x, !xSign);
 489 }
 490 
 491 JSBigInt* JSBigInt::bitwiseAnd(ExecState* exec, JSBigInt* x, JSBigInt* y)
 492 {
 493     VM&amp; vm = exec-&gt;vm();
 494     auto scope = DECLARE_THROW_SCOPE(vm);
 495 
 496     if (!x-&gt;sign() &amp;&amp; !y-&gt;sign()) {
 497         scope.release();
 498         return absoluteAnd(vm, x, y);
 499     }
 500 
 501     if (x-&gt;sign() &amp;&amp; y-&gt;sign()) {
 502         int resultLength = std::max(x-&gt;length(), y-&gt;length()) + 1;
 503         // (-x) &amp; (-y) == ~(x-1) &amp; ~(y-1) == ~((x-1) | (y-1))
 504         // == -(((x-1) | (y-1)) + 1)
 505         JSBigInt* result = absoluteSubOne(exec, x, resultLength);
 506         RETURN_IF_EXCEPTION(scope, nullptr);
 507 
 508         JSBigInt* y1 = absoluteSubOne(exec, y, y-&gt;length());
 509         RETURN_IF_EXCEPTION(scope, nullptr);
 510         result = absoluteOr(vm, result, y1);
 511         scope.release();
 512         return absoluteAddOne(exec, result, SignOption::Signed);
 513     }
 514 
 515     ASSERT(x-&gt;sign() != y-&gt;sign());
 516     // Assume that x is the positive BigInt.
 517     if (x-&gt;sign())
 518         std::swap(x, y);
 519 
 520     // x &amp; (-y) == x &amp; ~(y-1) == x &amp; ~(y-1)
 521     JSBigInt* y1 = absoluteSubOne(exec, y, y-&gt;length());
 522     RETURN_IF_EXCEPTION(scope, nullptr);
 523     return absoluteAndNot(vm, x, y1);
 524 }
 525 
 526 JSBigInt* JSBigInt::bitwiseOr(ExecState* exec, JSBigInt* x, JSBigInt* y)
 527 {
 528     VM&amp; vm = exec-&gt;vm();
 529     auto scope = DECLARE_THROW_SCOPE(vm);
 530 
 531     unsigned resultLength = std::max(x-&gt;length(), y-&gt;length());
 532 
 533     if (!x-&gt;sign() &amp;&amp; !y-&gt;sign()) {
 534         scope.release();
 535         return absoluteOr(vm, x, y);
 536     }
 537 
 538     if (x-&gt;sign() &amp;&amp; y-&gt;sign()) {
 539         // (-x) | (-y) == ~(x-1) | ~(y-1) == ~((x-1) &amp; (y-1))
 540         // == -(((x-1) &amp; (y-1)) + 1)
 541         JSBigInt* result = absoluteSubOne(exec, x, resultLength);
 542         RETURN_IF_EXCEPTION(scope, nullptr);
 543         JSBigInt* y1 = absoluteSubOne(exec, y, y-&gt;length());
 544         RETURN_IF_EXCEPTION(scope, nullptr);
 545         result = absoluteAnd(vm, result, y1);
 546         RETURN_IF_EXCEPTION(scope, nullptr);
 547 
 548         scope.release();
 549         return absoluteAddOne(exec, result, SignOption::Signed);
 550     }
 551 
 552     ASSERT(x-&gt;sign() != y-&gt;sign());
 553 
 554     // Assume that x is the positive BigInt.
 555     if (x-&gt;sign())
 556         std::swap(x, y);
 557 
 558     // x | (-y) == x | ~(y-1) == ~((y-1) &amp;~ x) == -(((y-1) &amp;~ x) + 1)
 559     JSBigInt* result = absoluteSubOne(exec, y, resultLength);
 560     RETURN_IF_EXCEPTION(scope, nullptr);
 561     result = absoluteAndNot(vm, result, x);
 562 
 563     scope.release();
 564     return absoluteAddOne(exec, result, SignOption::Signed);
 565 }
 566 
 567 JSBigInt* JSBigInt::bitwiseXor(ExecState* exec, JSBigInt* x, JSBigInt* y)
 568 {
 569     VM&amp; vm = exec-&gt;vm();
 570     auto scope = DECLARE_THROW_SCOPE(vm);
 571 
 572     if (!x-&gt;sign() &amp;&amp; !y-&gt;sign()) {
 573         scope.release();
 574         return absoluteXor(vm, x, y);
 575     }
 576 
 577     if (x-&gt;sign() &amp;&amp; y-&gt;sign()) {
 578         int resultLength = std::max(x-&gt;length(), y-&gt;length());
 579 
 580         // (-x) ^ (-y) == ~(x-1) ^ ~(y-1) == (x-1) ^ (y-1)
 581         JSBigInt* result = absoluteSubOne(exec, x, resultLength);
 582         RETURN_IF_EXCEPTION(scope, nullptr);
 583         JSBigInt* y1 = absoluteSubOne(exec, y, y-&gt;length());
 584         RETURN_IF_EXCEPTION(scope, nullptr);
 585 
 586         scope.release();
 587         return absoluteXor(vm, result, y1);
 588     }
 589     ASSERT(x-&gt;sign() != y-&gt;sign());
 590     int resultLength = std::max(x-&gt;length(), y-&gt;length()) + 1;
 591 
 592     // Assume that x is the positive BigInt.
 593     if (x-&gt;sign())
 594         std::swap(x, y);
 595 
 596     // x ^ (-y) == x ^ ~(y-1) == ~(x ^ (y-1)) == -((x ^ (y-1)) + 1)
 597     JSBigInt* result = absoluteSubOne(exec, y, resultLength);
 598     RETURN_IF_EXCEPTION(scope, nullptr);
 599 
 600     result = absoluteXor(vm, result, x);
 601     scope.release();
 602     return absoluteAddOne(exec, result, SignOption::Signed);
 603 }
 604 
 605 JSBigInt* JSBigInt::leftShift(ExecState* exec, JSBigInt* x, JSBigInt* y)
 606 {
 607     if (y-&gt;isZero() || x-&gt;isZero())
 608         return x;
 609 
 610     if (y-&gt;sign())
 611         return rightShiftByAbsolute(exec, x, y);
 612 
 613     return leftShiftByAbsolute(exec, x, y);
 614 }
 615 
 616 JSBigInt* JSBigInt::signedRightShift(ExecState* exec, JSBigInt* x, JSBigInt* y)
 617 {
 618     if (y-&gt;isZero() || x-&gt;isZero())
 619         return x;
 620 
 621     if (y-&gt;sign())
 622         return leftShiftByAbsolute(exec, x, y);
 623 
 624     return rightShiftByAbsolute(exec, x, y);
 625 }
 626 
 627 JSBigInt* JSBigInt::bitwiseNot(ExecState* exec, JSBigInt* x)
 628 {
 629     if (x-&gt;sign()) {
 630         // ~(-x) == ~(~(x-1)) == x-1
 631         return absoluteSubOne(exec, x, x-&gt;length());
 632     }
 633     // ~x == -x-1 == -(x+1)
 634     return absoluteAddOne(exec, x, SignOption::Signed);
 635 }
 636 
 637 #if USE(JSVALUE32_64)
 638 #define HAVE_TWO_DIGIT 1
 639 typedef uint64_t TwoDigit;
 640 #elif HAVE(INT128_T)
 641 #define HAVE_TWO_DIGIT 1
 642 typedef __uint128_t TwoDigit;
 643 #else
 644 #define HAVE_TWO_DIGIT 0
 645 #endif
 646 
 647 // {carry} must point to an initialized Digit and will either be incremented
 648 // by one or left alone.
 649 inline JSBigInt::Digit JSBigInt::digitAdd(Digit a, Digit b, Digit&amp; carry)
 650 {
 651     Digit result = a + b;
 652     carry += static_cast&lt;bool&gt;(result &lt; a);
 653     return result;
 654 }
 655 
 656 // {borrow} must point to an initialized Digit and will either be incremented
 657 // by one or left alone.
 658 inline JSBigInt::Digit JSBigInt::digitSub(Digit a, Digit b, Digit&amp; borrow)
 659 {
 660     Digit result = a - b;
 661     borrow += static_cast&lt;bool&gt;(result &gt; a);
 662     return result;
 663 }
 664 
 665 // Returns the low half of the result. High half is in {high}.
 666 inline JSBigInt::Digit JSBigInt::digitMul(Digit a, Digit b, Digit&amp; high)
 667 {
 668 #if HAVE(TWO_DIGIT)
 669     TwoDigit result = static_cast&lt;TwoDigit&gt;(a) * static_cast&lt;TwoDigit&gt;(b);
 670     high = result &gt;&gt; digitBits;
 671 
 672     return static_cast&lt;Digit&gt;(result);
 673 #else
 674     // Multiply in half-pointer-sized chunks.
 675     // For inputs [AH AL]*[BH BL], the result is:
 676     //
 677     //            [AL*BL]  // rLow
 678     //    +    [AL*BH]     // rMid1
 679     //    +    [AH*BL]     // rMid2
 680     //    + [AH*BH]        // rHigh
 681     //    = [R4 R3 R2 R1]  // high = [R4 R3], low = [R2 R1]
 682     //
 683     // Where of course we must be careful with carries between the columns.
 684     Digit aLow = a &amp; halfDigitMask;
 685     Digit aHigh = a &gt;&gt; halfDigitBits;
 686     Digit bLow = b &amp; halfDigitMask;
 687     Digit bHigh = b &gt;&gt; halfDigitBits;
 688 
 689     Digit rLow = aLow * bLow;
 690     Digit rMid1 = aLow * bHigh;
 691     Digit rMid2 = aHigh * bLow;
 692     Digit rHigh = aHigh * bHigh;
 693 
 694     Digit carry = 0;
 695     Digit low = digitAdd(rLow, rMid1 &lt;&lt; halfDigitBits, carry);
 696     low = digitAdd(low, rMid2 &lt;&lt; halfDigitBits, carry);
 697 
 698     high = (rMid1 &gt;&gt; halfDigitBits) + (rMid2 &gt;&gt; halfDigitBits) + rHigh + carry;
 699 
 700     return low;
 701 #endif
 702 }
 703 
 704 // Raises {base} to the power of {exponent}. Does not check for overflow.
 705 inline JSBigInt::Digit JSBigInt::digitPow(Digit base, Digit exponent)
 706 {
 707     Digit result = 1ull;
 708     while (exponent &gt; 0) {
 709         if (exponent &amp; 1)
 710             result *= base;
 711 
 712         exponent &gt;&gt;= 1;
 713         base *= base;
 714     }
 715 
 716     return result;
 717 }
 718 
 719 // Returns the quotient.
 720 // quotient = (high &lt;&lt; digitBits + low - remainder) / divisor
 721 inline JSBigInt::Digit JSBigInt::digitDiv(Digit high, Digit low, Digit divisor, Digit&amp; remainder)
 722 {
 723     ASSERT(high &lt; divisor);
 724 #if CPU(X86_64) &amp;&amp; COMPILER(GCC_COMPATIBLE)
 725     Digit quotient;
 726     Digit rem;
 727     __asm__(&quot;divq  %[divisor]&quot;
 728         // Outputs: {quotient} will be in rax, {rem} in rdx.
 729         : &quot;=a&quot;(quotient), &quot;=d&quot;(rem)
 730         // Inputs: put {high} into rdx, {low} into rax, and {divisor} into
 731         // any register or stack slot.
 732         : &quot;d&quot;(high), &quot;a&quot;(low), [divisor] &quot;rm&quot;(divisor));
 733     remainder = rem;
 734     return quotient;
 735 #elif CPU(X86) &amp;&amp; COMPILER(GCC_COMPATIBLE)
 736     Digit quotient;
 737     Digit rem;
 738     __asm__(&quot;divl  %[divisor]&quot;
 739         // Outputs: {quotient} will be in eax, {rem} in edx.
 740         : &quot;=a&quot;(quotient), &quot;=d&quot;(rem)
 741         // Inputs: put {high} into edx, {low} into eax, and {divisor} into
 742         // any register or stack slot.
 743         : &quot;d&quot;(high), &quot;a&quot;(low), [divisor] &quot;rm&quot;(divisor));
 744     remainder = rem;
 745     return quotient;
 746 #else
 747     static constexpr Digit halfDigitBase = 1ull &lt;&lt; halfDigitBits;
 748     // Adapted from Warren, Hacker&#39;s Delight, p. 152.
 749     unsigned s = clz(divisor);
 750     // If {s} is digitBits here, it causes an undefined behavior.
 751     // But {s} is never digitBits since {divisor} is never zero here.
 752     ASSERT(s != digitBits);
 753     divisor &lt;&lt;= s;
 754 
 755     Digit vn1 = divisor &gt;&gt; halfDigitBits;
 756     Digit vn0 = divisor &amp; halfDigitMask;
 757 
 758     // {sZeroMask} which is 0 if s == 0 and all 1-bits otherwise.
 759     // {s} can be 0. If {s} is 0, performing &quot;low &gt;&gt; (digitBits - s)&quot; must not be done since it causes an undefined behavior
 760     // since `&gt;&gt; digitBits` is undefied in C++. Quoted from C++ spec, &quot;The type of the result is that of the promoted left operand.
 761     // The behavior is undefined if the right operand is negative, or greater than or equal to the length in bits of the promoted
 762     // left operand&quot;. We mask the right operand of the shift by {shiftMask} (`digitBits - 1`), which makes `digitBits - 0` zero.
 763     // This shifting produces a value which covers 0 &lt; {s} &lt;= (digitBits - 1) cases. {s} == digitBits never happen as we asserted.
 764     // Since {sZeroMask} clears the value in the case of {s} == 0, {s} == 0 case is also covered.
 765     STATIC_ASSERT(sizeof(CPURegister) == sizeof(Digit));
 766     Digit sZeroMask = static_cast&lt;Digit&gt;((-static_cast&lt;CPURegister&gt;(s)) &gt;&gt; (digitBits - 1));
 767     static constexpr unsigned shiftMask = digitBits - 1;
 768     Digit un32 = (high &lt;&lt; s) | ((low &gt;&gt; ((digitBits - s) &amp; shiftMask)) &amp; sZeroMask);
 769 
 770     Digit un10 = low &lt;&lt; s;
 771     Digit un1 = un10 &gt;&gt; halfDigitBits;
 772     Digit un0 = un10 &amp; halfDigitMask;
 773     Digit q1 = un32 / vn1;
 774     Digit rhat = un32 - q1 * vn1;
 775 
 776     while (q1 &gt;= halfDigitBase || q1 * vn0 &gt; rhat * halfDigitBase + un1) {
 777         q1--;
 778         rhat += vn1;
 779         if (rhat &gt;= halfDigitBase)
 780             break;
 781     }
 782 
 783     Digit un21 = un32 * halfDigitBase + un1 - q1 * divisor;
 784     Digit q0 = un21 / vn1;
 785     rhat = un21 - q0 * vn1;
 786 
 787     while (q0 &gt;= halfDigitBase || q0 * vn0 &gt; rhat * halfDigitBase + un0) {
 788         q0--;
 789         rhat += vn1;
 790         if (rhat &gt;= halfDigitBase)
 791             break;
 792     }
 793 
 794     remainder = (un21 * halfDigitBase + un0 - q0 * divisor) &gt;&gt; s;
 795     return q1 * halfDigitBase + q0;
 796 #endif
 797 }
 798 
 799 // Multiplies {source} with {factor} and adds {summand} to the result.
 800 // {result} and {source} may be the same BigInt for inplace modification.
 801 void JSBigInt::internalMultiplyAdd(JSBigInt* source, Digit factor, Digit summand, unsigned n, JSBigInt* result)
 802 {
 803     ASSERT(source-&gt;length() &gt;= n);
 804     ASSERT(result-&gt;length() &gt;= n);
 805 
 806     Digit carry = summand;
 807     Digit high = 0;
 808     for (unsigned i = 0; i &lt; n; i++) {
 809         Digit current = source-&gt;digit(i);
 810         Digit newCarry = 0;
 811 
 812         // Compute this round&#39;s multiplication.
 813         Digit newHigh = 0;
 814         current = digitMul(current, factor, newHigh);
 815 
 816         // Add last round&#39;s carryovers.
 817         current = digitAdd(current, high, newCarry);
 818         current = digitAdd(current, carry, newCarry);
 819 
 820         // Store result and prepare for next round.
 821         result-&gt;setDigit(i, current);
 822         carry = newCarry;
 823         high = newHigh;
 824     }
 825 
 826     if (result-&gt;length() &gt; n) {
 827         result-&gt;setDigit(n++, carry + high);
 828 
 829         // Current callers don&#39;t pass in such large results, but let&#39;s be robust.
 830         while (n &lt; result-&gt;length())
 831             result-&gt;setDigit(n++, 0);
 832     } else
 833         ASSERT(!(carry + high));
 834 }
 835 
 836 // Multiplies {multiplicand} with {multiplier} and adds the result to
 837 // {accumulator}, starting at {accumulatorIndex} for the least-significant
 838 // digit.
 839 // Callers must ensure that {accumulator} is big enough to hold the result.
 840 void JSBigInt::multiplyAccumulate(JSBigInt* multiplicand, Digit multiplier, JSBigInt* accumulator, unsigned accumulatorIndex)
 841 {
 842     ASSERT(accumulator-&gt;length() &gt; multiplicand-&gt;length() + accumulatorIndex);
 843     if (!multiplier)
 844         return;
 845 
 846     Digit carry = 0;
 847     Digit high = 0;
 848     for (unsigned i = 0; i &lt; multiplicand-&gt;length(); i++, accumulatorIndex++) {
 849         Digit acc = accumulator-&gt;digit(accumulatorIndex);
 850         Digit newCarry = 0;
 851 
 852         // Add last round&#39;s carryovers.
 853         acc = digitAdd(acc, high, newCarry);
 854         acc = digitAdd(acc, carry, newCarry);
 855 
 856         // Compute this round&#39;s multiplication.
 857         Digit multiplicandDigit = multiplicand-&gt;digit(i);
 858         Digit low = digitMul(multiplier, multiplicandDigit, high);
 859         acc = digitAdd(acc, low, newCarry);
 860 
 861         // Store result and prepare for next round.
 862         accumulator-&gt;setDigit(accumulatorIndex, acc);
 863         carry = newCarry;
 864     }
 865 
 866     while (carry || high) {
 867         ASSERT(accumulatorIndex &lt; accumulator-&gt;length());
 868         Digit acc = accumulator-&gt;digit(accumulatorIndex);
 869         Digit newCarry = 0;
 870         acc = digitAdd(acc, high, newCarry);
 871         high = 0;
 872         acc = digitAdd(acc, carry, newCarry);
 873         accumulator-&gt;setDigit(accumulatorIndex, acc);
 874         carry = newCarry;
 875         accumulatorIndex++;
 876     }
 877 }
 878 
 879 bool JSBigInt::equals(JSBigInt* x, JSBigInt* y)
 880 {
 881     if (x-&gt;sign() != y-&gt;sign())
 882         return false;
 883 
 884     if (x-&gt;length() != y-&gt;length())
 885         return false;
 886 
 887     for (unsigned i = 0; i &lt; x-&gt;length(); i++) {
 888         if (x-&gt;digit(i) != y-&gt;digit(i))
 889             return false;
 890     }
 891 
 892     return true;
 893 }
 894 
 895 JSBigInt::ComparisonResult JSBigInt::compare(JSBigInt* x, JSBigInt* y)
 896 {
 897     bool xSign = x-&gt;sign();
 898 
 899     if (xSign != y-&gt;sign())
 900         return xSign ? ComparisonResult::LessThan : ComparisonResult::GreaterThan;
 901 
 902     ComparisonResult result = absoluteCompare(x, y);
 903     if (result == ComparisonResult::GreaterThan)
 904         return xSign ? ComparisonResult::LessThan : ComparisonResult::GreaterThan;
 905     if (result == ComparisonResult::LessThan)
 906         return xSign ? ComparisonResult::GreaterThan : ComparisonResult::LessThan;
 907 
 908     return ComparisonResult::Equal;
 909 }
 910 
 911 inline JSBigInt::ComparisonResult JSBigInt::absoluteCompare(JSBigInt* x, JSBigInt* y)
 912 {
 913     ASSERT(!x-&gt;length() || x-&gt;digit(x-&gt;length() - 1));
 914     ASSERT(!y-&gt;length() || y-&gt;digit(y-&gt;length() - 1));
 915 
 916     int diff = x-&gt;length() - y-&gt;length();
 917     if (diff)
 918         return diff &lt; 0 ? ComparisonResult::LessThan : ComparisonResult::GreaterThan;
 919 
 920     int i = x-&gt;length() - 1;
 921     while (i &gt;= 0 &amp;&amp; x-&gt;digit(i) == y-&gt;digit(i))
 922         i--;
 923 
 924     if (i &lt; 0)
 925         return ComparisonResult::Equal;
 926 
 927     return x-&gt;digit(i) &gt; y-&gt;digit(i) ? ComparisonResult::GreaterThan : ComparisonResult::LessThan;
 928 }
 929 
 930 JSBigInt* JSBigInt::absoluteAdd(ExecState* exec, JSBigInt* x, JSBigInt* y, bool resultSign)
 931 {
 932     VM&amp; vm = exec-&gt;vm();
 933 
 934     if (x-&gt;length() &lt; y-&gt;length())
 935         return absoluteAdd(exec, y, x, resultSign);
 936 
 937     if (x-&gt;isZero()) {
 938         ASSERT(y-&gt;isZero());
 939         return x;
 940     }
 941 
 942     if (y-&gt;isZero())
 943         return resultSign == x-&gt;sign() ? x : unaryMinus(vm, x);
 944 
 945     JSBigInt* result = JSBigInt::tryCreateWithLength(exec, x-&gt;length() + 1);
 946     if (!result)
 947         return nullptr;
 948     Digit carry = 0;
 949     unsigned i = 0;
 950     for (; i &lt; y-&gt;length(); i++) {
 951         Digit newCarry = 0;
 952         Digit sum = digitAdd(x-&gt;digit(i), y-&gt;digit(i), newCarry);
 953         sum = digitAdd(sum, carry, newCarry);
 954         result-&gt;setDigit(i, sum);
 955         carry = newCarry;
 956     }
 957 
 958     for (; i &lt; x-&gt;length(); i++) {
 959         Digit newCarry = 0;
 960         Digit sum = digitAdd(x-&gt;digit(i), carry, newCarry);
 961         result-&gt;setDigit(i, sum);
 962         carry = newCarry;
 963     }
 964 
 965     result-&gt;setDigit(i, carry);
 966     result-&gt;setSign(resultSign);
 967 
 968     return result-&gt;rightTrim(vm);
 969 }
 970 
 971 JSBigInt* JSBigInt::absoluteSub(VM&amp; vm, JSBigInt* x, JSBigInt* y, bool resultSign)
 972 {
 973     ComparisonResult comparisonResult = absoluteCompare(x, y);
 974     ASSERT(x-&gt;length() &gt;= y-&gt;length());
 975     ASSERT(comparisonResult == ComparisonResult::GreaterThan || comparisonResult == ComparisonResult::Equal);
 976 
 977     if (x-&gt;isZero()) {
 978         ASSERT(y-&gt;isZero());
 979         return x;
 980     }
 981 
 982     if (y-&gt;isZero())
 983         return resultSign == x-&gt;sign() ? x : unaryMinus(vm, x);
 984 
 985     if (comparisonResult == ComparisonResult::Equal)
 986         return JSBigInt::createZero(vm);
 987 
 988     JSBigInt* result = JSBigInt::createWithLengthUnchecked(vm, x-&gt;length());
 989 
 990     Digit borrow = 0;
 991     unsigned i = 0;
 992     for (; i &lt; y-&gt;length(); i++) {
 993         Digit newBorrow = 0;
 994         Digit difference = digitSub(x-&gt;digit(i), y-&gt;digit(i), newBorrow);
 995         difference = digitSub(difference, borrow, newBorrow);
 996         result-&gt;setDigit(i, difference);
 997         borrow = newBorrow;
 998     }
 999 
1000     for (; i &lt; x-&gt;length(); i++) {
1001         Digit newBorrow = 0;
1002         Digit difference = digitSub(x-&gt;digit(i), borrow, newBorrow);
1003         result-&gt;setDigit(i, difference);
1004         borrow = newBorrow;
1005     }
1006 
1007     ASSERT(!borrow);
1008     result-&gt;setSign(resultSign);
1009     return result-&gt;rightTrim(vm);
1010 }
1011 
1012 // Divides {x} by {divisor}, returning the result in {quotient} and {remainder}.
1013 // Mathematically, the contract is:
1014 // quotient = (x - remainder) / divisor, with 0 &lt;= remainder &lt; divisor.
1015 // If {quotient} is an empty handle, an appropriately sized BigInt will be
1016 // allocated for it; otherwise the caller must ensure that it is big enough.
1017 // {quotient} can be the same as {x} for an in-place division. {quotient} can
1018 // also be nullptr if the caller is only interested in the remainder.
1019 void JSBigInt::absoluteDivWithDigitDivisor(VM&amp; vm, JSBigInt* x, Digit divisor, JSBigInt** quotient, Digit&amp; remainder)
1020 {
1021     ASSERT(divisor);
1022 
1023     ASSERT(!x-&gt;isZero());
1024     remainder = 0;
1025     if (divisor == 1) {
1026         if (quotient != nullptr)
1027             *quotient = x;
1028         return;
1029     }
1030 
1031     unsigned length = x-&gt;length();
1032     if (quotient != nullptr) {
1033         if (*quotient == nullptr)
1034             *quotient = JSBigInt::createWithLengthUnchecked(vm, length);
1035 
1036         for (int i = length - 1; i &gt;= 0; i--) {
1037             Digit q = digitDiv(remainder, x-&gt;digit(i), divisor, remainder);
1038             (*quotient)-&gt;setDigit(i, q);
1039         }
1040     } else {
1041         for (int i = length - 1; i &gt;= 0; i--)
1042             digitDiv(remainder, x-&gt;digit(i), divisor, remainder);
1043     }
1044 }
1045 
1046 // Divides {dividend} by {divisor}, returning the result in {quotient} and
1047 // {remainder}. Mathematically, the contract is:
1048 // quotient = (dividend - remainder) / divisor, with 0 &lt;= remainder &lt; divisor.
1049 // Both {quotient} and {remainder} are optional, for callers that are only
1050 // interested in one of them.
1051 // See Knuth, Volume 2, section 4.3.1, Algorithm D.
1052 void JSBigInt::absoluteDivWithBigIntDivisor(ExecState* exec, JSBigInt* dividend, JSBigInt* divisor, JSBigInt** quotient, JSBigInt** remainder)
1053 {
1054     ASSERT(divisor-&gt;length() &gt;= 2);
1055     ASSERT(dividend-&gt;length() &gt;= divisor-&gt;length());
1056     VM&amp; vm = exec-&gt;vm();
1057     auto scope = DECLARE_THROW_SCOPE(vm);
1058 
1059     // The unusual variable names inside this function are consistent with
1060     // Knuth&#39;s book, as well as with Go&#39;s implementation of this algorithm.
1061     // Maintaining this consistency is probably more useful than trying to
1062     // come up with more descriptive names for them.
1063     unsigned n = divisor-&gt;length();
1064     unsigned m = dividend-&gt;length() - n;
1065 
1066     // The quotient to be computed.
1067     JSBigInt* q = nullptr;
1068     if (quotient != nullptr)
1069         q = createWithLengthUnchecked(exec-&gt;vm(), m + 1);
1070 
1071     // In each iteration, {qhatv} holds {divisor} * {current quotient digit}.
1072     // &quot;v&quot; is the book&#39;s name for {divisor}, &quot;qhat&quot; the current quotient digit.
1073     JSBigInt* qhatv = tryCreateWithLength(exec, n + 1);
1074     RETURN_IF_EXCEPTION(scope, void());
1075 
1076     // D1.
1077     // Left-shift inputs so that the divisor&#39;s MSB is set. This is necessary
1078     // to prevent the digit-wise divisions (see digit_div call below) from
1079     // overflowing (they take a two digits wide input, and return a one digit
1080     // result).
1081     Digit lastDigit = divisor-&gt;digit(n - 1);
1082     unsigned shift = clz(lastDigit);
1083 
1084     if (shift &gt; 0) {
1085         divisor = absoluteLeftShiftAlwaysCopy(exec, divisor, shift, LeftShiftMode::SameSizeResult);
1086         RETURN_IF_EXCEPTION(scope, void());
1087     }
1088 
1089     // Holds the (continuously updated) remaining part of the dividend, which
1090     // eventually becomes the remainder.
1091     JSBigInt* u = absoluteLeftShiftAlwaysCopy(exec, dividend, shift, LeftShiftMode::AlwaysAddOneDigit);
1092     RETURN_IF_EXCEPTION(scope, void());
1093 
1094     // D2.
1095     // Iterate over the dividend&#39;s digit (like the &quot;grad school&quot; algorithm).
1096     // {vn1} is the divisor&#39;s most significant digit.
1097     Digit vn1 = divisor-&gt;digit(n - 1);
1098     for (int j = m; j &gt;= 0; j--) {
1099         // D3.
1100         // Estimate the current iteration&#39;s quotient digit (see Knuth for details).
1101         // {qhat} is the current quotient digit.
1102         Digit qhat = std::numeric_limits&lt;Digit&gt;::max();
1103 
1104         // {ujn} is the dividend&#39;s most significant remaining digit.
1105         Digit ujn = u-&gt;digit(j + n);
1106         if (ujn != vn1) {
1107             // {rhat} is the current iteration&#39;s remainder.
1108             Digit rhat = 0;
1109             // Estimate the current quotient digit by dividing the most significant
1110             // digits of dividend and divisor. The result will not be too small,
1111             // but could be a bit too large.
1112             qhat = digitDiv(ujn, u-&gt;digit(j + n - 1), vn1, rhat);
1113 
1114             // Decrement the quotient estimate as needed by looking at the next
1115             // digit, i.e. by testing whether
1116             // qhat * v_{n-2} &gt; (rhat &lt;&lt; digitBits) + u_{j+n-2}.
1117             Digit vn2 = divisor-&gt;digit(n - 2);
1118             Digit ujn2 = u-&gt;digit(j + n - 2);
1119             while (productGreaterThan(qhat, vn2, rhat, ujn2)) {
1120                 qhat--;
1121                 Digit prevRhat = rhat;
1122                 rhat += vn1;
1123                 // v[n-1] &gt;= 0, so this tests for overflow.
1124                 if (rhat &lt; prevRhat)
1125                     break;
1126             }
1127         }
1128 
1129         // D4.
1130         // Multiply the divisor with the current quotient digit, and subtract
1131         // it from the dividend. If there was &quot;borrow&quot;, then the quotient digit
1132         // was one too high, so we must correct it and undo one subtraction of
1133         // the (shifted) divisor.
1134         internalMultiplyAdd(divisor, qhat, 0, n, qhatv);
1135         Digit c = u-&gt;absoluteInplaceSub(qhatv, j);
1136         if (c) {
1137             c = u-&gt;absoluteInplaceAdd(divisor, j);
1138             u-&gt;setDigit(j + n, u-&gt;digit(j + n) + c);
1139             qhat--;
1140         }
1141 
1142         if (quotient != nullptr)
1143             q-&gt;setDigit(j, qhat);
1144     }
1145 
1146     if (quotient != nullptr) {
1147         // Caller will right-trim.
1148         *quotient = q;
1149     }
1150 
1151     if (remainder != nullptr) {
1152         u-&gt;inplaceRightShift(shift);
1153         *remainder = u;
1154     }
1155 }
1156 
1157 // Returns whether (factor1 * factor2) &gt; (high &lt;&lt; digitBits) + low.
1158 inline bool JSBigInt::productGreaterThan(Digit factor1, Digit factor2, Digit high, Digit low)
1159 {
1160     Digit resultHigh;
1161     Digit resultLow = digitMul(factor1, factor2, resultHigh);
1162     return resultHigh &gt; high || (resultHigh == high &amp;&amp; resultLow &gt; low);
1163 }
1164 
1165 // Adds {summand} onto {this}, starting with {summand}&#39;s 0th digit
1166 // at {this}&#39;s {startIndex}&#39;th digit. Returns the &quot;carry&quot; (0 or 1).
1167 JSBigInt::Digit JSBigInt::absoluteInplaceAdd(JSBigInt* summand, unsigned startIndex)
1168 {
1169     Digit carry = 0;
1170     unsigned n = summand-&gt;length();
1171     ASSERT(length() &gt;= startIndex + n);
1172     for (unsigned i = 0; i &lt; n; i++) {
1173         Digit newCarry = 0;
1174         Digit sum = digitAdd(digit(startIndex + i), summand-&gt;digit(i), newCarry);
1175         sum = digitAdd(sum, carry, newCarry);
1176         setDigit(startIndex + i, sum);
1177         carry = newCarry;
1178     }
1179 
1180     return carry;
1181 }
1182 
1183 // Subtracts {subtrahend} from {this}, starting with {subtrahend}&#39;s 0th digit
1184 // at {this}&#39;s {startIndex}-th digit. Returns the &quot;borrow&quot; (0 or 1).
1185 JSBigInt::Digit JSBigInt::absoluteInplaceSub(JSBigInt* subtrahend, unsigned startIndex)
1186 {
1187     Digit borrow = 0;
1188     unsigned n = subtrahend-&gt;length();
1189     ASSERT(length() &gt;= startIndex + n);
1190     for (unsigned i = 0; i &lt; n; i++) {
1191         Digit newBorrow = 0;
1192         Digit difference = digitSub(digit(startIndex + i), subtrahend-&gt;digit(i), newBorrow);
1193         difference = digitSub(difference, borrow, newBorrow);
1194         setDigit(startIndex + i, difference);
1195         borrow = newBorrow;
1196     }
1197 
1198     return borrow;
1199 }
1200 
1201 void JSBigInt::inplaceRightShift(unsigned shift)
1202 {
1203     ASSERT(shift &lt; digitBits);
1204     ASSERT(!(digit(0) &amp; ((static_cast&lt;Digit&gt;(1) &lt;&lt; shift) - 1)));
1205 
1206     if (!shift)
1207         return;
1208 
1209     Digit carry = digit(0) &gt;&gt; shift;
1210     unsigned last = length() - 1;
1211     for (unsigned i = 0; i &lt; last; i++) {
1212         Digit d = digit(i + 1);
1213         setDigit(i, (d &lt;&lt; (digitBits - shift)) | carry);
1214         carry = d &gt;&gt; shift;
1215     }
1216     setDigit(last, carry);
1217 }
1218 
1219 // Always copies the input, even when {shift} == 0.
1220 JSBigInt* JSBigInt::absoluteLeftShiftAlwaysCopy(ExecState* exec, JSBigInt* x, unsigned shift, LeftShiftMode mode)
1221 {
1222     ASSERT(shift &lt; digitBits);
1223     ASSERT(!x-&gt;isZero());
1224 
1225     unsigned n = x-&gt;length();
1226     unsigned resultLength = mode == LeftShiftMode::AlwaysAddOneDigit ? n + 1 : n;
1227     JSBigInt* result = tryCreateWithLength(exec, resultLength);
1228     if (!result)
1229         return nullptr;
1230 
1231     if (!shift) {
1232         for (unsigned i = 0; i &lt; n; i++)
1233             result-&gt;setDigit(i, x-&gt;digit(i));
1234         if (mode == LeftShiftMode::AlwaysAddOneDigit)
1235             result-&gt;setDigit(n, 0);
1236 
1237         return result;
1238     }
1239 
1240     Digit carry = 0;
1241     for (unsigned i = 0; i &lt; n; i++) {
1242         Digit d = x-&gt;digit(i);
1243         result-&gt;setDigit(i, (d &lt;&lt; shift) | carry);
1244         carry = d &gt;&gt; (digitBits - shift);
1245     }
1246 
1247     if (mode == LeftShiftMode::AlwaysAddOneDigit)
1248         result-&gt;setDigit(n, carry);
1249     else {
1250         ASSERT(mode == LeftShiftMode::SameSizeResult);
1251         ASSERT(!carry);
1252     }
1253 
1254     return result;
1255 }
1256 
1257 // Helper for Absolute{And,AndNot,Or,Xor}.
1258 // Performs the given binary {op} on digit pairs of {x} and {y}; when the
1259 // end of the shorter of the two is reached, {extraDigits} configures how
1260 // remaining digits in the longer input (if {symmetric} == Symmetric, in
1261 // {x} otherwise) are handled: copied to the result or ignored.
1262 // Example:
1263 //       y:             [ y2 ][ y1 ][ y0 ]
1264 //       x:       [ x3 ][ x2 ][ x1 ][ x0 ]
1265 //                   |     |     |     |
1266 //                (Copy)  (op)  (op)  (op)
1267 //                   |     |     |     |
1268 //                   v     v     v     v
1269 // result: [  0 ][ x3 ][ r2 ][ r1 ][ r0 ]
1270 template&lt;typename BitwiseOp&gt;
1271 inline JSBigInt* JSBigInt::absoluteBitwiseOp(VM&amp; vm, JSBigInt* x, JSBigInt* y, ExtraDigitsHandling extraDigits, SymmetricOp symmetric, BitwiseOp&amp;&amp; op)
1272 {
1273     unsigned xLength = x-&gt;length();
1274     unsigned yLength = y-&gt;length();
1275     unsigned numPairs = yLength;
1276     if (xLength &lt; yLength) {
1277         numPairs = xLength;
1278         if (symmetric == SymmetricOp::Symmetric) {
1279             std::swap(x, y);
1280             std::swap(xLength, yLength);
1281         }
1282     }
1283 
1284     ASSERT(numPairs == std::min(xLength, yLength));
1285     unsigned resultLength = extraDigits == ExtraDigitsHandling::Copy ? xLength : numPairs;
1286     JSBigInt* result = createWithLengthUnchecked(vm, resultLength);
1287     unsigned i = 0;
1288     for (; i &lt; numPairs; i++)
1289         result-&gt;setDigit(i, op(x-&gt;digit(i), y-&gt;digit(i)));
1290 
1291     if (extraDigits == ExtraDigitsHandling::Copy) {
1292         for (; i &lt; xLength; i++)
1293             result-&gt;setDigit(i, x-&gt;digit(i));
1294     }
1295 
1296     for (; i &lt; resultLength; i++)
1297         result-&gt;setDigit(i, 0);
1298 
1299     return result-&gt;rightTrim(vm);
1300 }
1301 
1302 JSBigInt* JSBigInt::absoluteAnd(VM&amp; vm, JSBigInt* x, JSBigInt* y)
1303 {
1304     auto digitOperation = [](Digit a, Digit b) {
1305         return a &amp; b;
1306     };
1307     return absoluteBitwiseOp(vm, x, y, ExtraDigitsHandling::Skip, SymmetricOp::Symmetric, digitOperation);
1308 }
1309 
1310 JSBigInt* JSBigInt::absoluteOr(VM&amp; vm, JSBigInt* x, JSBigInt* y)
1311 {
1312     auto digitOperation = [](Digit a, Digit b) {
1313         return a | b;
1314     };
1315     return absoluteBitwiseOp(vm, x, y, ExtraDigitsHandling::Copy, SymmetricOp::Symmetric, digitOperation);
1316 }
1317 
1318 JSBigInt* JSBigInt::absoluteAndNot(VM&amp; vm, JSBigInt* x, JSBigInt* y)
1319 {
1320     auto digitOperation = [](Digit a, Digit b) {
1321         return a &amp; ~b;
1322     };
1323     return absoluteBitwiseOp(vm, x, y, ExtraDigitsHandling::Copy, SymmetricOp::NotSymmetric, digitOperation);
1324 }
1325 
1326 JSBigInt* JSBigInt::absoluteXor(VM&amp; vm, JSBigInt* x, JSBigInt* y)
1327 {
1328     auto digitOperation = [](Digit a, Digit b) {
1329         return a ^ b;
1330     };
1331     return absoluteBitwiseOp(vm, x, y, ExtraDigitsHandling::Copy, SymmetricOp::Symmetric, digitOperation);
1332 }
1333 
1334 JSBigInt* JSBigInt::absoluteAddOne(ExecState* exec, JSBigInt* x, SignOption signOption)
1335 {
1336     unsigned inputLength = x-&gt;length();
1337     // The addition will overflow into a new digit if all existing digits are
1338     // at maximum.
1339     bool willOverflow = true;
1340     for (unsigned i = 0; i &lt; inputLength; i++) {
1341         if (std::numeric_limits&lt;Digit&gt;::max() != x-&gt;digit(i)) {
1342             willOverflow = false;
1343             break;
1344         }
1345     }
1346 
1347     unsigned resultLength = inputLength + willOverflow;
1348     JSBigInt* result = tryCreateWithLength(exec, resultLength);
1349     if (!result)
1350         return nullptr;
1351 
1352     Digit carry = 1;
1353     for (unsigned i = 0; i &lt; inputLength; i++) {
1354         Digit newCarry = 0;
1355         result-&gt;setDigit(i, digitAdd(x-&gt;digit(i), carry, newCarry));
1356         carry = newCarry;
1357     }
1358     if (resultLength &gt; inputLength)
1359         result-&gt;setDigit(inputLength, carry);
1360     else
1361         ASSERT(!carry);
1362 
1363     result-&gt;setSign(signOption == SignOption::Signed);
1364     return result-&gt;rightTrim(exec-&gt;vm());
1365 }
1366 
1367 JSBigInt* JSBigInt::absoluteSubOne(ExecState* exec, JSBigInt* x, unsigned resultLength)
1368 {
1369     ASSERT(!x-&gt;isZero());
1370     ASSERT(resultLength &gt;= x-&gt;length());
1371     VM&amp; vm = exec-&gt;vm();
1372     auto scope = DECLARE_THROW_SCOPE(vm);
1373 
1374     JSBigInt* result = tryCreateWithLength(exec, resultLength);
1375     RETURN_IF_EXCEPTION(scope, nullptr);
1376 
1377     unsigned length = x-&gt;length();
1378     Digit borrow = 1;
1379     for (unsigned i = 0; i &lt; length; i++) {
1380         Digit newBorrow = 0;
1381         result-&gt;setDigit(i, digitSub(x-&gt;digit(i), borrow, newBorrow));
1382         borrow = newBorrow;
1383     }
1384     ASSERT(!borrow);
1385     for (unsigned i = length; i &lt; resultLength; i++)
1386         result-&gt;setDigit(i, borrow);
1387 
1388     return result-&gt;rightTrim(vm);
1389 }
1390 
1391 JSBigInt* JSBigInt::leftShiftByAbsolute(ExecState* exec, JSBigInt* x, JSBigInt* y)
1392 {
1393     VM&amp; vm = exec-&gt;vm();
1394     auto scope = DECLARE_THROW_SCOPE(vm);
1395 
1396     auto optionalShift = toShiftAmount(y);
1397     if (!optionalShift) {
1398         throwRangeError(exec, scope, &quot;BigInt generated from this operation is too big&quot;_s);
1399         return nullptr;
1400     }
1401 
1402     Digit shift = *optionalShift;
1403     unsigned digitShift = static_cast&lt;unsigned&gt;(shift / digitBits);
1404     unsigned bitsShift = static_cast&lt;unsigned&gt;(shift % digitBits);
1405     unsigned length = x-&gt;length();
1406     bool grow = bitsShift &amp;&amp; (x-&gt;digit(length - 1) &gt;&gt; (digitBits - bitsShift));
1407     int resultLength = length + digitShift + grow;
1408     if (static_cast&lt;unsigned&gt;(resultLength) &gt; maxLength) {
1409         throwRangeError(exec, scope, &quot;BigInt generated from this operation is too big&quot;_s);
1410         return nullptr;
1411     }
1412 
1413     JSBigInt* result = tryCreateWithLength(exec, resultLength);
1414     RETURN_IF_EXCEPTION(scope, nullptr);
1415     if (!bitsShift) {
1416         unsigned i = 0;
1417         for (; i &lt; digitShift; i++)
1418             result-&gt;setDigit(i, 0ul);
1419 
1420         for (; i &lt; static_cast&lt;unsigned&gt;(resultLength); i++)
1421             result-&gt;setDigit(i, x-&gt;digit(i - digitShift));
1422     } else {
1423         Digit carry = 0;
1424         for (unsigned i = 0; i &lt; digitShift; i++)
1425             result-&gt;setDigit(i, 0ul);
1426 
1427         for (unsigned i = 0; i &lt; length; i++) {
1428             Digit d = x-&gt;digit(i);
1429             result-&gt;setDigit(i + digitShift, (d &lt;&lt; bitsShift) | carry);
1430             carry = d &gt;&gt; (digitBits - bitsShift);
1431         }
1432 
1433         if (grow)
1434             result-&gt;setDigit(length + digitShift, carry);
1435         else
1436             ASSERT(!carry);
1437     }
1438 
1439     result-&gt;setSign(x-&gt;sign());
1440     return result-&gt;rightTrim(vm);
1441 }
1442 
1443 JSBigInt* JSBigInt::rightShiftByAbsolute(ExecState* exec, JSBigInt* x, JSBigInt* y)
1444 {
1445     VM&amp; vm = exec-&gt;vm();
1446     unsigned length = x-&gt;length();
1447     bool sign = x-&gt;sign();
1448     auto optionalShift = toShiftAmount(y);
1449     if (!optionalShift)
1450         return rightShiftByMaximum(vm, sign);
1451 
1452     Digit shift = *optionalShift;
1453     unsigned digitalShift = static_cast&lt;unsigned&gt;(shift / digitBits);
1454     unsigned bitsShift = static_cast&lt;unsigned&gt;(shift % digitBits);
1455     int resultLength = length - digitalShift;
1456     if (resultLength &lt;= 0)
1457         return rightShiftByMaximum(vm, sign);
1458 
1459     // For negative numbers, round down if any bit was shifted out (so that e.g.
1460     // -5n &gt;&gt; 1n == -3n and not -2n). Check now whether this will happen and
1461     // whether it can cause overflow into a new digit. If we allocate the result
1462     // large enough up front, it avoids having to do a second allocation later.
1463     bool mustRoundDown = false;
1464     if (sign) {
1465         const Digit mask = (static_cast&lt;Digit&gt;(1) &lt;&lt; bitsShift) - 1;
1466         if (x-&gt;digit(digitalShift) &amp; mask)
1467             mustRoundDown = true;
1468         else {
1469             for (unsigned i = 0; i &lt; digitalShift; i++) {
1470                 if (x-&gt;digit(i)) {
1471                     mustRoundDown = true;
1472                     break;
1473                 }
1474             }
1475         }
1476     }
1477 
1478     // If bitsShift is non-zero, it frees up bits, preventing overflow.
1479     if (mustRoundDown &amp;&amp; !bitsShift) {
1480         // Overflow cannot happen if the most significant digit has unset bits.
1481         Digit msd = x-&gt;digit(length - 1);
1482         bool roundingCanOverflow = !static_cast&lt;Digit&gt;(~msd);
1483         if (roundingCanOverflow)
1484             resultLength++;
1485     }
1486 
1487     ASSERT(static_cast&lt;unsigned&gt;(resultLength) &lt;= length);
1488     JSBigInt* result = createWithLengthUnchecked(vm, static_cast&lt;unsigned&gt;(resultLength));
1489     if (!bitsShift) {
1490         for (unsigned i = digitalShift; i &lt; length; i++)
1491             result-&gt;setDigit(i - digitalShift, x-&gt;digit(i));
1492     } else {
1493         Digit carry = x-&gt;digit(digitalShift) &gt;&gt; bitsShift;
1494         unsigned last = length - digitalShift - 1;
1495         for (unsigned i = 0; i &lt; last; i++) {
1496             Digit d = x-&gt;digit(i + digitalShift + 1);
1497             result-&gt;setDigit(i, (d &lt;&lt; (digitBits - bitsShift)) | carry);
1498             carry = d &gt;&gt; bitsShift;
1499         }
1500         result-&gt;setDigit(last, carry);
1501     }
1502 
1503     if (sign) {
1504         result-&gt;setSign(true);
1505         if (mustRoundDown) {
1506             // Since the result is negative, rounding down means adding one to
1507             // its absolute value. This cannot overflow.
1508             result = result-&gt;rightTrim(vm);
1509             return absoluteAddOne(exec, result, SignOption::Signed);
1510         }
1511     }
1512 
1513     return result-&gt;rightTrim(vm);
1514 }
1515 
1516 JSBigInt* JSBigInt::rightShiftByMaximum(VM&amp; vm, bool sign)
1517 {
1518     if (sign)
1519         return createFrom(vm, -1);
1520 
1521     return createZero(vm);
1522 }
1523 
1524 // Lookup table for the maximum number of bits required per character of a
1525 // base-N string representation of a number. To increase accuracy, the array
1526 // value is the actual value multiplied by 32. To generate this table:
1527 // for (var i = 0; i &lt;= 36; i++) { print(Math.ceil(Math.log2(i) * 32) + &quot;,&quot;); }
1528 constexpr uint8_t maxBitsPerCharTable[] = {
1529     0,   0,   32,  51,  64,  75,  83,  90,  96, // 0..8
1530     102, 107, 111, 115, 119, 122, 126, 128,     // 9..16
1531     131, 134, 136, 139, 141, 143, 145, 147,     // 17..24
1532     149, 151, 153, 154, 156, 158, 159, 160,     // 25..32
1533     162, 163, 165, 166,                         // 33..36
1534 };
1535 
1536 static constexpr unsigned bitsPerCharTableShift = 5;
1537 static constexpr size_t bitsPerCharTableMultiplier = 1u &lt;&lt; bitsPerCharTableShift;
1538 
1539 // Compute (an overapproximation of) the length of the resulting string:
1540 // Divide bit length of the BigInt by bits representable per character.
1541 uint64_t JSBigInt::calculateMaximumCharactersRequired(unsigned length, unsigned radix, Digit lastDigit, bool sign)
1542 {
1543     unsigned leadingZeros = clz(lastDigit);
1544 
1545     size_t bitLength = length * digitBits - leadingZeros;
1546 
1547     // Maximum number of bits we can represent with one character. We&#39;ll use this
1548     // to find an appropriate chunk size below.
1549     uint8_t maxBitsPerChar = maxBitsPerCharTable[radix];
1550 
1551     // For estimating result length, we have to be pessimistic and work with
1552     // the minimum number of bits one character can represent.
1553     uint8_t minBitsPerChar = maxBitsPerChar - 1;
1554 
1555     // Perform the following computation with uint64_t to avoid overflows.
1556     uint64_t maximumCharactersRequired = bitLength;
1557     maximumCharactersRequired *= bitsPerCharTableMultiplier;
1558 
1559     // Round up.
1560     maximumCharactersRequired += minBitsPerChar - 1;
1561     maximumCharactersRequired /= minBitsPerChar;
1562     maximumCharactersRequired += sign;
1563 
1564     return maximumCharactersRequired;
1565 }
1566 
1567 String JSBigInt::toStringBasePowerOfTwo(VM&amp; vm, ExecState* exec, JSBigInt* x, unsigned radix)
1568 {
1569     ASSERT(hasOneBitSet(radix));
1570     ASSERT(radix &gt;= 2 &amp;&amp; radix &lt;= 32);
1571     ASSERT(!x-&gt;isZero());
1572 
1573     const unsigned length = x-&gt;length();
1574     const bool sign = x-&gt;sign();
1575     const unsigned bitsPerChar = ctz(radix);
1576     const unsigned charMask = radix - 1;
1577     // Compute the length of the resulting string: divide the bit length of the
1578     // BigInt by the number of bits representable per character (rounding up).
1579     const Digit msd = x-&gt;digit(length - 1);
1580 
1581     const unsigned msdLeadingZeros = clz(msd);
1582 
1583     const size_t bitLength = length * digitBits - msdLeadingZeros;
1584     const size_t charsRequired = (bitLength + bitsPerChar - 1) / bitsPerChar + sign;
1585 
1586     if (charsRequired &gt; JSString::MaxLength) {
1587         if (exec) {
1588             auto scope = DECLARE_THROW_SCOPE(vm);
1589             throwOutOfMemoryError(exec, scope);
1590         }
1591         return String();
1592     }
1593 
1594     Vector&lt;LChar&gt; resultString(charsRequired);
1595     Digit digit = 0;
1596     // Keeps track of how many unprocessed bits there are in {digit}.
1597     unsigned availableBits = 0;
1598     int pos = static_cast&lt;int&gt;(charsRequired - 1);
1599     for (unsigned i = 0; i &lt; length - 1; i++) {
1600         Digit newDigit = x-&gt;digit(i);
1601         // Take any leftover bits from the last iteration into account.
1602         int current = (digit | (newDigit &lt;&lt; availableBits)) &amp; charMask;
1603         resultString[pos--] = radixDigits[current];
1604         int consumedBits = bitsPerChar - availableBits;
1605         digit = newDigit &gt;&gt; consumedBits;
1606         availableBits = digitBits - consumedBits;
1607         while (availableBits &gt;= bitsPerChar) {
1608             resultString[pos--] = radixDigits[digit &amp; charMask];
1609             digit &gt;&gt;= bitsPerChar;
1610             availableBits -= bitsPerChar;
1611         }
1612     }
1613     // Take any leftover bits from the last iteration into account.
1614     int current = (digit | (msd &lt;&lt; availableBits)) &amp; charMask;
1615     resultString[pos--] = radixDigits[current];
1616     digit = msd &gt;&gt; (bitsPerChar - availableBits);
1617     while (digit) {
1618         resultString[pos--] = radixDigits[digit &amp; charMask];
1619         digit &gt;&gt;= bitsPerChar;
1620     }
1621 
1622     if (sign)
1623         resultString[pos--] = &#39;-&#39;;
1624 
1625     ASSERT(pos == -1);
1626     return StringImpl::adopt(WTFMove(resultString));
1627 }
1628 
1629 String JSBigInt::toStringGeneric(VM&amp; vm, ExecState* exec, JSBigInt* x, unsigned radix)
1630 {
1631     // FIXME: [JSC] Revisit usage of Vector into JSBigInt::toString
1632     // https://bugs.webkit.org/show_bug.cgi?id=18067
1633     Vector&lt;LChar&gt; resultString;
1634 
1635     ASSERT(radix &gt;= 2 &amp;&amp; radix &lt;= 36);
1636     ASSERT(!x-&gt;isZero());
1637 
1638     unsigned length = x-&gt;length();
1639     bool sign = x-&gt;sign();
1640 
1641     uint8_t maxBitsPerChar = maxBitsPerCharTable[radix];
1642     uint64_t maximumCharactersRequired = calculateMaximumCharactersRequired(length, radix, x-&gt;digit(length - 1), sign);
1643 
1644     if (maximumCharactersRequired &gt; JSString::MaxLength) {
1645         if (exec) {
1646             auto scope = DECLARE_THROW_SCOPE(vm);
1647             throwOutOfMemoryError(exec, scope);
1648         }
1649         return String();
1650     }
1651 
1652     Digit lastDigit;
1653     if (length == 1)
1654         lastDigit = x-&gt;digit(0);
1655     else {
1656         unsigned chunkChars = digitBits * bitsPerCharTableMultiplier / maxBitsPerChar;
1657         Digit chunkDivisor = digitPow(radix, chunkChars);
1658 
1659         // By construction of chunkChars, there can&#39;t have been overflow.
1660         ASSERT(chunkDivisor);
1661         unsigned nonZeroDigit = length - 1;
1662         ASSERT(x-&gt;digit(nonZeroDigit));
1663 
1664         // {rest} holds the part of the BigInt that we haven&#39;t looked at yet.
1665         // Not to be confused with &quot;remainder&quot;!
1666         JSBigInt* rest = nullptr;
1667 
1668         // In the first round, divide the input, allocating a new BigInt for
1669         // the result == rest; from then on divide the rest in-place.
1670         JSBigInt** dividend = &amp;x;
1671         do {
1672             Digit chunk;
1673             absoluteDivWithDigitDivisor(vm, *dividend, chunkDivisor, &amp;rest, chunk);
1674             dividend = &amp;rest;
1675             for (unsigned i = 0; i &lt; chunkChars; i++) {
1676                 resultString.append(radixDigits[chunk % radix]);
1677                 chunk /= radix;
1678             }
1679             ASSERT(!chunk);
1680 
1681             if (!rest-&gt;digit(nonZeroDigit))
1682                 nonZeroDigit--;
1683 
1684             // We can never clear more than one digit per iteration, because
1685             // chunkDivisor is smaller than max digit value.
1686             ASSERT(rest-&gt;digit(nonZeroDigit));
1687         } while (nonZeroDigit &gt; 0);
1688 
1689         lastDigit = rest-&gt;digit(0);
1690     }
1691 
1692     do {
1693         resultString.append(radixDigits[lastDigit % radix]);
1694         lastDigit /= radix;
1695     } while (lastDigit &gt; 0);
1696     ASSERT(resultString.size());
1697     ASSERT(resultString.size() &lt;= static_cast&lt;size_t&gt;(maximumCharactersRequired));
1698 
1699     // Remove leading zeroes.
1700     unsigned newSizeNoLeadingZeroes = resultString.size();
1701     while (newSizeNoLeadingZeroes  &gt; 1 &amp;&amp; resultString[newSizeNoLeadingZeroes - 1] == &#39;0&#39;)
1702         newSizeNoLeadingZeroes--;
1703 
1704     resultString.shrink(newSizeNoLeadingZeroes);
1705 
1706     if (sign)
1707         resultString.append(&#39;-&#39;);
1708 
1709     std::reverse(resultString.begin(), resultString.end());
1710 
1711     return StringImpl::adopt(WTFMove(resultString));
1712 }
1713 
1714 JSBigInt* JSBigInt::rightTrim(VM&amp; vm)
1715 {
1716     if (isZero()) {
1717         ASSERT(!sign());
1718         return this;
1719     }
1720 
1721     int nonZeroIndex = m_length - 1;
1722     while (nonZeroIndex &gt;= 0 &amp;&amp; !digit(nonZeroIndex))
1723         nonZeroIndex--;
1724 
1725     if (nonZeroIndex &lt; 0)
1726         return createZero(vm);
1727 
1728     if (nonZeroIndex == static_cast&lt;int&gt;(m_length - 1))
1729         return this;
1730 
1731     unsigned newLength = nonZeroIndex + 1;
1732     JSBigInt* trimmedBigInt = createWithLengthUnchecked(vm, newLength);
1733     std::copy(dataStorage(), dataStorage() + newLength, trimmedBigInt-&gt;dataStorage());
1734 
1735     trimmedBigInt-&gt;setSign(this-&gt;sign());
1736 
1737     return trimmedBigInt;
1738 }
1739 
1740 JSBigInt* JSBigInt::allocateFor(ExecState* exec, VM&amp; vm, unsigned radix, unsigned charcount)
1741 {
1742     ASSERT(2 &lt;= radix &amp;&amp; radix &lt;= 36);
1743 
1744     size_t bitsPerChar = maxBitsPerCharTable[radix];
1745     size_t chars = charcount;
1746     const unsigned roundup = bitsPerCharTableMultiplier - 1;
1747     if (chars &lt;= (std::numeric_limits&lt;size_t&gt;::max() - roundup) / bitsPerChar) {
1748         size_t bitsMin = bitsPerChar * chars;
1749 
1750         // Divide by 32 (see table), rounding up.
1751         bitsMin = (bitsMin + roundup) &gt;&gt; bitsPerCharTableShift;
1752         if (bitsMin &lt;= static_cast&lt;size_t&gt;(maxInt)) {
1753             // Divide by kDigitsBits, rounding up.
1754             unsigned length = (bitsMin + digitBits - 1) / digitBits;
1755             if (length &lt;= maxLength) {
1756                 JSBigInt* result = JSBigInt::createWithLengthUnchecked(vm, length);
1757                 return result;
1758             }
1759         }
1760     }
1761 
1762     if (exec) {
1763         auto scope = DECLARE_THROW_SCOPE(vm);
1764         throwOutOfMemoryError(exec, scope);
1765     }
1766     return nullptr;
1767 }
1768 
1769 size_t JSBigInt::estimatedSize(JSCell* cell, VM&amp; vm)
1770 {
1771     return Base::estimatedSize(cell, vm) + jsCast&lt;JSBigInt*&gt;(cell)-&gt;m_length * sizeof(Digit);
1772 }
1773 
1774 double JSBigInt::toNumber(ExecState* exec) const
1775 {
1776     VM&amp; vm = exec-&gt;vm();
1777     auto scope = DECLARE_THROW_SCOPE(vm);
1778     throwTypeError(exec, scope, &quot;Conversion from &#39;BigInt&#39; to &#39;number&#39; is not allowed.&quot;_s);
1779     return 0.0;
1780 }
1781 
1782 bool JSBigInt::getPrimitiveNumber(ExecState* exec, double&amp; number, JSValue&amp; result) const
1783 {
1784     result = this;
1785     number = toNumber(exec);
1786     return true;
1787 }
1788 
1789 template &lt;typename CharType&gt;
1790 JSBigInt* JSBigInt::parseInt(ExecState* exec, CharType*  data, unsigned length, ErrorParseMode errorParseMode)
1791 {
1792     VM&amp; vm = exec-&gt;vm();
1793 
1794     unsigned p = 0;
1795     while (p &lt; length &amp;&amp; isStrWhiteSpace(data[p]))
1796         ++p;
1797 
1798     // Check Radix from frist characters
1799     if (static_cast&lt;unsigned&gt;(p) + 1 &lt; static_cast&lt;unsigned&gt;(length) &amp;&amp; data[p] == &#39;0&#39;) {
1800         if (isASCIIAlphaCaselessEqual(data[p + 1], &#39;b&#39;))
1801             return parseInt(exec, vm, data, length, p + 2, 2, errorParseMode, ParseIntSign::Unsigned, ParseIntMode::DisallowEmptyString);
1802 
1803         if (isASCIIAlphaCaselessEqual(data[p + 1], &#39;x&#39;))
1804             return parseInt(exec, vm, data, length, p + 2, 16, errorParseMode, ParseIntSign::Unsigned, ParseIntMode::DisallowEmptyString);
1805 
1806         if (isASCIIAlphaCaselessEqual(data[p + 1], &#39;o&#39;))
1807             return parseInt(exec, vm, data, length, p + 2, 8, errorParseMode, ParseIntSign::Unsigned, ParseIntMode::DisallowEmptyString);
1808     }
1809 
1810     ParseIntSign sign = ParseIntSign::Unsigned;
1811     if (p &lt; length) {
1812         if (data[p] == &#39;+&#39;)
1813             ++p;
1814         else if (data[p] == &#39;-&#39;) {
1815             sign = ParseIntSign::Signed;
1816             ++p;
1817         }
1818     }
1819 
1820     JSBigInt* result = parseInt(exec, vm, data, length, p, 10, errorParseMode, sign);
1821 
1822     if (result &amp;&amp; !result-&gt;isZero())
1823         result-&gt;setSign(sign == ParseIntSign::Signed);
1824 
1825     return result;
1826 }
1827 
1828 template &lt;typename CharType&gt;
1829 JSBigInt* JSBigInt::parseInt(ExecState* exec, VM&amp; vm, CharType* data, unsigned length, unsigned startIndex, unsigned radix, ErrorParseMode errorParseMode, ParseIntSign sign, ParseIntMode parseMode)
1830 {
1831     ASSERT(length &gt;= 0);
1832     unsigned p = startIndex;
1833 
1834     auto scope = DECLARE_THROW_SCOPE(vm);
1835 
1836     if (parseMode != ParseIntMode::AllowEmptyString &amp;&amp; startIndex == length) {
1837         ASSERT(exec);
1838         if (errorParseMode == ErrorParseMode::ThrowExceptions)
1839             throwVMError(exec, scope, createSyntaxError(exec, &quot;Failed to parse String to BigInt&quot;));
1840         return nullptr;
1841     }
1842 
1843     // Skipping leading zeros
1844     while (p &lt; length &amp;&amp; data[p] == &#39;0&#39;)
1845         ++p;
1846 
1847     int endIndex = length - 1;
1848     // Removing trailing spaces
1849     while (endIndex &gt;= static_cast&lt;int&gt;(p) &amp;&amp; isStrWhiteSpace(data[endIndex]))
1850         --endIndex;
1851 
1852     length = endIndex + 1;
1853 
1854     if (p == length)
1855         return createZero(vm);
1856 
1857     unsigned limit0 = &#39;0&#39; + (radix &lt; 10 ? radix : 10);
1858     unsigned limita = &#39;a&#39; + (radix - 10);
1859     unsigned limitA = &#39;A&#39; + (radix - 10);
1860 
1861     JSBigInt* result = allocateFor(exec, vm, radix, length - p);
1862     RETURN_IF_EXCEPTION(scope, nullptr);
1863 
1864     result-&gt;initialize(InitializationType::WithZero);
1865 
1866     for (unsigned i = p; i &lt; length; i++, p++) {
1867         uint32_t digit;
1868         if (data[i] &gt;= &#39;0&#39; &amp;&amp; data[i] &lt; limit0)
1869             digit = data[i] - &#39;0&#39;;
1870         else if (data[i] &gt;= &#39;a&#39; &amp;&amp; data[i] &lt; limita)
1871             digit = data[i] - &#39;a&#39; + 10;
1872         else if (data[i] &gt;= &#39;A&#39; &amp;&amp; data[i] &lt; limitA)
1873             digit = data[i] - &#39;A&#39; + 10;
1874         else
1875             break;
1876 
1877         result-&gt;inplaceMultiplyAdd(static_cast&lt;Digit&gt;(radix), static_cast&lt;Digit&gt;(digit));
1878     }
1879 
1880     result-&gt;setSign(sign == ParseIntSign::Signed ? true : false);
1881     if (p == length)
1882         return result-&gt;rightTrim(vm);
1883 
1884     ASSERT(exec);
1885     if (errorParseMode == ErrorParseMode::ThrowExceptions)
1886         throwVMError(exec, scope, createSyntaxError(exec, &quot;Failed to parse String to BigInt&quot;));
1887 
1888     return nullptr;
1889 }
1890 
1891 inline JSBigInt::Digit JSBigInt::digit(unsigned n)
1892 {
1893     ASSERT(n &lt; length());
1894     return dataStorage()[n];
1895 }
1896 
1897 inline void JSBigInt::setDigit(unsigned n, Digit value)
1898 {
1899     ASSERT(n &lt; length());
1900     dataStorage()[n] = value;
1901 }
1902 
1903 JSObject* JSBigInt::toObject(ExecState* exec, JSGlobalObject* globalObject) const
1904 {
1905     return BigIntObject::create(exec-&gt;vm(), globalObject, const_cast&lt;JSBigInt*&gt;(this));
1906 }
1907 
1908 bool JSBigInt::equalsToNumber(JSValue numValue)
1909 {
1910     ASSERT(numValue.isNumber());
1911 
1912     if (numValue.isInt32()) {
1913         int value = numValue.asInt32();
1914         if (!value)
1915             return this-&gt;isZero();
1916 
1917         return (this-&gt;length() == 1) &amp;&amp; (this-&gt;sign() == (value &lt; 0)) &amp;&amp; (this-&gt;digit(0) == static_cast&lt;Digit&gt;(std::abs(static_cast&lt;int64_t&gt;(value))));
1918     }
1919 
1920     double value = numValue.asDouble();
1921     return compareToDouble(this, value) == ComparisonResult::Equal;
1922 }
1923 
1924 JSBigInt::ComparisonResult JSBigInt::compareToDouble(JSBigInt* x, double y)
1925 {
1926     // This algorithm expect that the double format is IEEE 754
1927 
1928     uint64_t doubleBits = bitwise_cast&lt;uint64_t&gt;(y);
1929     int rawExponent = static_cast&lt;int&gt;(doubleBits &gt;&gt; 52) &amp; 0x7FF;
1930 
1931     if (rawExponent == 0x7FF) {
1932         if (std::isnan(y))
1933             return ComparisonResult::Undefined;
1934 
1935         return (y == std::numeric_limits&lt;double&gt;::infinity()) ? ComparisonResult::LessThan : ComparisonResult::GreaterThan;
1936     }
1937 
1938     bool xSign = x-&gt;sign();
1939 
1940     // Note that this is different from the double&#39;s sign bit for -0. That&#39;s
1941     // intentional because -0 must be treated like 0.
1942     bool ySign = y &lt; 0;
1943     if (xSign != ySign)
1944         return xSign ? ComparisonResult::LessThan : ComparisonResult::GreaterThan;
1945 
1946     if (!y) {
1947         ASSERT(!xSign);
1948         return x-&gt;isZero() ? ComparisonResult::Equal : ComparisonResult::GreaterThan;
1949     }
1950 
1951     if (x-&gt;isZero())
1952         return ComparisonResult::LessThan;
1953 
1954     uint64_t mantissa = doubleBits &amp; 0x000FFFFFFFFFFFFF;
1955 
1956     // Non-finite doubles are handled above.
1957     ASSERT(rawExponent != 0x7FF);
1958     int exponent = rawExponent - 0x3FF;
1959     if (exponent &lt; 0) {
1960         // The absolute value of the double is less than 1. Only 0n has an
1961         // absolute value smaller than that, but we&#39;ve already covered that case.
1962         return xSign ? ComparisonResult::LessThan : ComparisonResult::GreaterThan;
1963     }
1964 
1965     int xLength = x-&gt;length();
1966     Digit xMSD = x-&gt;digit(xLength - 1);
1967     int msdLeadingZeros = clz(xMSD);
1968 
1969     int xBitLength = xLength * digitBits - msdLeadingZeros;
1970     int yBitLength = exponent + 1;
1971     if (xBitLength &lt; yBitLength)
1972         return xSign? ComparisonResult::GreaterThan : ComparisonResult::LessThan;
1973 
1974     if (xBitLength &gt; yBitLength)
1975         return xSign ? ComparisonResult::LessThan : ComparisonResult::GreaterThan;
1976 
1977     // At this point, we know that signs and bit lengths (i.e. position of
1978     // the most significant bit in exponent-free representation) are identical.
1979     // {x} is not zero, {y} is finite and not denormal.
1980     // Now we virtually convert the double to an integer by shifting its
1981     // mantissa according to its exponent, so it will align with the BigInt {x},
1982     // and then we compare them bit for bit until we find a difference or the
1983     // least significant bit.
1984     //                    &lt;----- 52 ------&gt; &lt;-- virtual trailing zeroes --&gt;
1985     // y / mantissa:     1yyyyyyyyyyyyyyyyy 0000000000000000000000000000000
1986     // x / digits:    0001xxxx xxxxxxxx xxxxxxxx ...
1987     //                    &lt;--&gt;          &lt;------&gt;
1988     //              msdTopBit         digitBits
1989     //
1990     mantissa |= 0x0010000000000000;
1991     const int mantissaTopBit = 52; // 0-indexed.
1992 
1993     // 0-indexed position of {x}&#39;s most significant bit within the {msd}.
1994     int msdTopBit = digitBits - 1 - msdLeadingZeros;
1995     ASSERT(msdTopBit == static_cast&lt;int&gt;((xBitLength - 1) % digitBits));
1996 
1997     // Shifted chunk of {mantissa} for comparing with {digit}.
1998     Digit compareMantissa;
1999 
2000     // Number of unprocessed bits in {mantissa}. We&#39;ll keep them shifted to
2001     // the left (i.e. most significant part) of the underlying uint64_t.
2002     int remainingMantissaBits = 0;
2003 
2004     // First, compare the most significant digit against the beginning of
2005     // the mantissa and then we align them.
2006     if (msdTopBit &lt; mantissaTopBit) {
2007         remainingMantissaBits = (mantissaTopBit - msdTopBit);
2008         compareMantissa = static_cast&lt;Digit&gt;(mantissa &gt;&gt; remainingMantissaBits);
2009         mantissa = mantissa &lt;&lt; (64 - remainingMantissaBits);
2010     } else {
2011         compareMantissa = static_cast&lt;Digit&gt;(mantissa &lt;&lt; (msdTopBit - mantissaTopBit));
2012         mantissa = 0;
2013     }
2014 
2015     if (xMSD &gt; compareMantissa)
2016         return xSign ? ComparisonResult::LessThan : ComparisonResult::GreaterThan;
2017 
2018     if (xMSD &lt; compareMantissa)
2019         return xSign ? ComparisonResult::GreaterThan : ComparisonResult::LessThan;
2020 
2021     // Then, compare additional digits against any remaining mantissa bits.
2022     for (int digitIndex = xLength - 2; digitIndex &gt;= 0; digitIndex--) {
2023         if (remainingMantissaBits &gt; 0) {
2024             remainingMantissaBits -= digitBits;
2025             if (sizeof(mantissa) != sizeof(xMSD)) {
2026                 compareMantissa = static_cast&lt;Digit&gt;(mantissa &gt;&gt; (64 - digitBits));
2027                 // &quot;&amp; 63&quot; to appease compilers. digitBits is 32 here anyway.
2028                 mantissa = mantissa &lt;&lt; (digitBits &amp; 63);
2029             } else {
2030                 compareMantissa = static_cast&lt;Digit&gt;(mantissa);
2031                 mantissa = 0;
2032             }
2033         } else
2034             compareMantissa = 0;
2035 
2036         Digit digit = x-&gt;digit(digitIndex);
2037         if (digit &gt; compareMantissa)
2038             return xSign ? ComparisonResult::LessThan : ComparisonResult::GreaterThan;
2039         if (digit &lt; compareMantissa)
2040             return xSign ? ComparisonResult::GreaterThan : ComparisonResult::LessThan;
2041     }
2042 
2043     // Integer parts are equal; check whether {y} has a fractional part.
2044     if (mantissa) {
2045         ASSERT(remainingMantissaBits &gt; 0);
2046         return xSign ? ComparisonResult::GreaterThan : ComparisonResult::LessThan;
2047     }
2048 
2049     return ComparisonResult::Equal;
2050 }
2051 
2052 Optional&lt;JSBigInt::Digit&gt; JSBigInt::toShiftAmount(JSBigInt* x)
2053 {
2054     if (x-&gt;length() &gt; 1)
2055         return WTF::nullopt;
2056 
2057     Digit value = x-&gt;digit(0);
2058     static_assert(maxLengthBits &lt; std::numeric_limits&lt;Digit&gt;::max(), &quot;maxLengthBits needs to be less than digit&quot;);
2059 
2060     if (value &gt; maxLengthBits)
2061         return WTF::nullopt;
2062 
2063     return value;
2064 }
2065 
2066 } // namespace JSC
    </pre>
  </body>
</html>