<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/DatePrototype.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  *  Copyright (C) 1999-2000 Harri Porten (porten@kde.org)
<a name="1" id="anc1"></a><span class="line-modified">   3  *  Copyright (C) 2004-2008, 2016 Apple Inc. All rights reserved.</span>
   4  *  Copyright (C) 2008, 2009 Torch Mobile, Inc. All rights reserved.
   5  *  Copyright (C) 2010 Torch Mobile (Beijing) Co. Ltd. All rights reserved.
   6  *
   7  *  This library is free software; you can redistribute it and/or
   8  *  modify it under the terms of the GNU Lesser General Public
   9  *  License as published by the Free Software Foundation; either
  10  *  version 2 of the License, or (at your option) any later version.
  11  *
  12  *  This library is distributed in the hope that it will be useful,
  13  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  14  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  15  *  Lesser General Public License for more details.
  16  *
  17  *  You should have received a copy of the GNU Lesser General Public
  18  *  License along with this library; if not, write to the Free Software
  19  *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301
  20  *  USA
  21  *
  22  */
  23 
  24 #include &quot;config.h&quot;
  25 #include &quot;DatePrototype.h&quot;
  26 
  27 #include &quot;DateConversion.h&quot;
  28 #include &quot;DateInstance.h&quot;
  29 #include &quot;Error.h&quot;
  30 #include &quot;JSCBuiltins.h&quot;
  31 #include &quot;JSDateMath.h&quot;
  32 #include &quot;JSGlobalObject.h&quot;
  33 #include &quot;JSObject.h&quot;
  34 #include &quot;JSString.h&quot;
  35 #include &quot;Lookup.h&quot;
  36 #include &quot;ObjectPrototype.h&quot;
  37 #include &quot;JSCInlines.h&quot;
  38 #include &lt;limits.h&gt;
  39 #include &lt;locale.h&gt;
  40 #include &lt;math.h&gt;
  41 #include &lt;stdlib.h&gt;
  42 #include &lt;time.h&gt;
  43 #include &lt;wtf/Assertions.h&gt;
  44 #include &lt;wtf/MathExtras.h&gt;
  45 
  46 #if HAVE(LANGINFO_H)
  47 #include &lt;langinfo.h&gt;
  48 #endif
  49 
  50 #if HAVE(SYS_PARAM_H)
  51 #include &lt;sys/param.h&gt;
  52 #endif
  53 
  54 #if HAVE(SYS_TIME_H)
  55 #include &lt;sys/time.h&gt;
  56 #endif
  57 
  58 #if HAVE(SYS_TIMEB_H)
  59 #include &lt;sys/timeb.h&gt;
  60 #endif
  61 
  62 #if !(OS(DARWIN) &amp;&amp; USE(CF))
  63 #include &lt;unicode/udat.h&gt;
  64 #endif
  65 
  66 #if USE(CF)
  67 #include &lt;CoreFoundation/CoreFoundation.h&gt;
  68 #endif
  69 
  70 namespace JSC {
  71 
  72 using namespace WTF;
  73 
  74 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetDate(ExecState*);
  75 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetDay(ExecState*);
  76 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetFullYear(ExecState*);
  77 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetHours(ExecState*);
  78 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetMilliSeconds(ExecState*);
  79 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetMinutes(ExecState*);
  80 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetMonth(ExecState*);
  81 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetSeconds(ExecState*);
  82 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetTimezoneOffset(ExecState*);
  83 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetUTCDate(ExecState*);
  84 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetUTCDay(ExecState*);
  85 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetUTCFullYear(ExecState*);
  86 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetUTCHours(ExecState*);
  87 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetUTCMilliseconds(ExecState*);
  88 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetUTCMinutes(ExecState*);
  89 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetUTCMonth(ExecState*);
  90 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetUTCSeconds(ExecState*);
  91 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetYear(ExecState*);
  92 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetDate(ExecState*);
  93 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetFullYear(ExecState*);
  94 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetHours(ExecState*);
  95 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetMilliSeconds(ExecState*);
  96 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetMinutes(ExecState*);
  97 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetMonth(ExecState*);
  98 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetSeconds(ExecState*);
  99 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetTime(ExecState*);
 100 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetUTCDate(ExecState*);
 101 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetUTCFullYear(ExecState*);
 102 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetUTCHours(ExecState*);
 103 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetUTCMilliseconds(ExecState*);
 104 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetUTCMinutes(ExecState*);
 105 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetUTCMonth(ExecState*);
 106 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetUTCSeconds(ExecState*);
 107 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetYear(ExecState*);
 108 EncodedJSValue JSC_HOST_CALL dateProtoFuncToDateString(ExecState*);
 109 EncodedJSValue JSC_HOST_CALL dateProtoFuncToLocaleDateString(ExecState*);
 110 EncodedJSValue JSC_HOST_CALL dateProtoFuncToLocaleString(ExecState*);
 111 EncodedJSValue JSC_HOST_CALL dateProtoFuncToLocaleTimeString(ExecState*);
 112 EncodedJSValue JSC_HOST_CALL dateProtoFuncToPrimitiveSymbol(ExecState*);
 113 EncodedJSValue JSC_HOST_CALL dateProtoFuncToString(ExecState*);
 114 EncodedJSValue JSC_HOST_CALL dateProtoFuncToTimeString(ExecState*);
 115 EncodedJSValue JSC_HOST_CALL dateProtoFuncToUTCString(ExecState*);
 116 EncodedJSValue JSC_HOST_CALL dateProtoFuncToISOString(ExecState*);
 117 EncodedJSValue JSC_HOST_CALL dateProtoFuncToJSON(ExecState*);
 118 
 119 }
 120 
 121 #include &quot;DatePrototype.lut.h&quot;
 122 
 123 namespace JSC {
 124 
 125 enum LocaleDateTimeFormat { LocaleDateAndTime, LocaleDate, LocaleTime };
 126 
 127 #if OS(DARWIN) &amp;&amp; USE(CF)
 128 
 129 // FIXME: Since this is superior to the strftime-based version, why limit this to OS(DARWIN)?
 130 // Instead we should consider using this whenever USE(CF) is true.
 131 
 132 static CFDateFormatterStyle styleFromArgString(const String&amp; string, CFDateFormatterStyle defaultStyle)
 133 {
 134     if (string == &quot;short&quot;)
 135         return kCFDateFormatterShortStyle;
 136     if (string == &quot;medium&quot;)
 137         return kCFDateFormatterMediumStyle;
 138     if (string == &quot;long&quot;)
 139         return kCFDateFormatterLongStyle;
 140     if (string == &quot;full&quot;)
 141         return kCFDateFormatterFullStyle;
 142     return defaultStyle;
 143 }
 144 
 145 static JSCell* formatLocaleDate(ExecState* exec, DateInstance*, double timeInMilliseconds, LocaleDateTimeFormat format)
 146 {
<a name="2" id="anc2"></a>
 147     CFDateFormatterStyle dateStyle = (format != LocaleTime ? kCFDateFormatterLongStyle : kCFDateFormatterNoStyle);
 148     CFDateFormatterStyle timeStyle = (format != LocaleDate ? kCFDateFormatterLongStyle : kCFDateFormatterNoStyle);
 149 
 150     bool useCustomFormat = false;
 151     String customFormatString;
 152 
 153     String arg0String = exec-&gt;argument(0).toWTFString(exec);
 154     if (arg0String == &quot;custom&quot; &amp;&amp; !exec-&gt;argument(1).isUndefined()) {
 155         useCustomFormat = true;
 156         customFormatString = exec-&gt;argument(1).toWTFString(exec);
 157     } else if (format == LocaleDateAndTime &amp;&amp; !exec-&gt;argument(1).isUndefined()) {
 158         dateStyle = styleFromArgString(arg0String, dateStyle);
 159         timeStyle = styleFromArgString(exec-&gt;argument(1).toWTFString(exec), timeStyle);
 160     } else if (format != LocaleTime &amp;&amp; !exec-&gt;argument(0).isUndefined())
 161         dateStyle = styleFromArgString(arg0String, dateStyle);
 162     else if (format != LocaleDate &amp;&amp; !exec-&gt;argument(0).isUndefined())
 163         timeStyle = styleFromArgString(arg0String, timeStyle);
 164 
 165     CFAbsoluteTime absoluteTime = floor(timeInMilliseconds / msPerSecond) - kCFAbsoluteTimeIntervalSince1970;
 166 
 167     auto formatter = adoptCF(CFDateFormatterCreate(kCFAllocatorDefault, adoptCF(CFLocaleCopyCurrent()).get(), dateStyle, timeStyle));
 168     if (useCustomFormat)
 169         CFDateFormatterSetFormat(formatter.get(), customFormatString.createCFString().get());
<a name="3" id="anc3"></a><span class="line-modified"> 170     return jsNontrivialString(exec, adoptCF(CFDateFormatterCreateStringWithAbsoluteTime(kCFAllocatorDefault, formatter.get(), absoluteTime)).get());</span>
 171 }
 172 
 173 #elif !UCONFIG_NO_FORMATTING
 174 
 175 static JSCell* formatLocaleDate(ExecState* exec, DateInstance*, double timeInMilliseconds, LocaleDateTimeFormat format)
 176 {
<a name="4" id="anc4"></a>
 177     UDateFormatStyle timeStyle = (format != LocaleDate ? UDAT_LONG : UDAT_NONE);
 178     UDateFormatStyle dateStyle = (format != LocaleTime ? UDAT_LONG : UDAT_NONE);
 179 
 180     UErrorCode status = U_ZERO_ERROR;
 181     UDateFormat* df = udat_open(timeStyle, dateStyle, 0, 0, -1, 0, 0, &amp;status);
 182     if (!df)
<a name="5" id="anc5"></a><span class="line-modified"> 183         return jsEmptyString(exec);</span>
 184 
 185     UChar buffer[128];
 186     int32_t length;
 187     length = udat_format(df, timeInMilliseconds, buffer, 128, 0, &amp;status);
 188     udat_close(df);
 189     if (status != U_ZERO_ERROR)
<a name="6" id="anc6"></a><span class="line-modified"> 190         return jsEmptyString(exec);</span>
 191 
<a name="7" id="anc7"></a><span class="line-modified"> 192     return jsNontrivialString(exec, String(buffer, length));</span>
 193 }
 194 
 195 #else
 196 
 197 static JSCell* formatLocaleDate(ExecState* exec, const GregorianDateTime&amp; gdt, LocaleDateTimeFormat format)
 198 {
<a name="8" id="anc8"></a>
 199 #if OS(WINDOWS)
 200     SYSTEMTIME systemTime;
 201     memset(&amp;systemTime, 0, sizeof(systemTime));
 202     systemTime.wYear = gdt.year();
 203     systemTime.wMonth = gdt.month() + 1;
 204     systemTime.wDay = gdt.monthDay();
 205     systemTime.wDayOfWeek = gdt.weekDay();
 206     systemTime.wHour = gdt.hour();
 207     systemTime.wMinute = gdt.minute();
 208     systemTime.wSecond = gdt.second();
 209 
 210     Vector&lt;UChar, 128&gt; buffer;
 211     size_t length = 0;
 212 
 213     if (format == LocaleDate) {
 214         buffer.resize(GetDateFormatW(LOCALE_USER_DEFAULT, DATE_LONGDATE, &amp;systemTime, 0, 0, 0));
 215         length = GetDateFormatW(LOCALE_USER_DEFAULT, DATE_LONGDATE, &amp;systemTime, 0, buffer.data(), buffer.size());
 216     } else if (format == LocaleTime) {
 217         buffer.resize(GetTimeFormatW(LOCALE_USER_DEFAULT, 0, &amp;systemTime, 0, 0, 0));
 218         length = GetTimeFormatW(LOCALE_USER_DEFAULT, 0, &amp;systemTime, 0, buffer.data(), buffer.size());
 219     } else if (format == LocaleDateAndTime) {
 220         buffer.resize(GetDateFormatW(LOCALE_USER_DEFAULT, DATE_LONGDATE, &amp;systemTime, 0, 0, 0) + GetTimeFormatW(LOCALE_USER_DEFAULT, 0, &amp;systemTime, 0, 0, 0));
 221         length = GetDateFormatW(LOCALE_USER_DEFAULT, DATE_LONGDATE, &amp;systemTime, 0, buffer.data(), buffer.size());
 222         if (length) {
 223             buffer[length - 1] = &#39; &#39;;
 224             length += GetTimeFormatW(LOCALE_USER_DEFAULT, 0, &amp;systemTime, 0, buffer.data() + length, buffer.size() - length);
 225         }
 226     } else
 227         RELEASE_ASSERT_NOT_REACHED();
 228 
 229     //  Remove terminating null character.
 230     if (length)
 231         length--;
 232 
<a name="9" id="anc9"></a><span class="line-modified"> 233     return jsNontrivialString(exec, String(buffer.data(), length));</span>
 234 
 235 #else // OS(WINDOWS)
 236 
 237 #if HAVE(LANGINFO_H)
 238     static const nl_item formats[] = { D_T_FMT, D_FMT, T_FMT };
 239 #else
 240     static const char* const formatStrings[] = { &quot;%#c&quot;, &quot;%#x&quot;, &quot;%X&quot; };
 241 #endif
 242 
 243     // Offset year if needed
 244     struct tm localTM = gdt;
 245     int year = gdt.year();
 246     bool yearNeedsOffset = year &lt; 1900 || year &gt; 2038;
 247     if (yearNeedsOffset)
 248         localTM.tm_year = equivalentYearForDST(year) - 1900;
 249 
 250 #if HAVE(LANGINFO_H)
 251     // We do not allow strftime to generate dates with 2-digits years,
 252     // both to avoid ambiguity, and a crash in strncpy, for years that
 253     // need offset.
 254     char* formatString = strdup(nl_langinfo(formats[format]));
 255     char* yPos = strchr(formatString, &#39;y&#39;);
 256     if (yPos)
 257         *yPos = &#39;Y&#39;;
 258 #endif
 259 
 260     // Do the formatting
 261     const int bufsize = 128;
 262     char timebuffer[bufsize];
 263 
 264 #if HAVE(LANGINFO_H)
 265     size_t ret = strftime(timebuffer, bufsize, formatString, &amp;localTM);
 266     free(formatString);
 267 #else
 268     size_t ret = strftime(timebuffer, bufsize, formatStrings[format], &amp;localTM);
 269 #endif
 270 
 271     if (ret == 0)
<a name="10" id="anc10"></a><span class="line-modified"> 272         return jsEmptyString(exec);</span>
 273 
 274     // Copy original into the buffer
 275     if (yearNeedsOffset &amp;&amp; format != LocaleTime) {
 276         static const int yearLen = 5;   // FIXME will be a problem in the year 10,000
 277         char yearString[yearLen];
 278 
 279         snprintf(yearString, yearLen, &quot;%d&quot;, localTM.tm_year + 1900);
 280         char* yearLocation = strstr(timebuffer, yearString);
 281         snprintf(yearString, yearLen, &quot;%d&quot;, year);
 282 
 283         strncpy(yearLocation, yearString, yearLen - 1);
 284     }
 285 
 286     // Convert multi-byte result to UNICODE.
 287     // If __STDC_ISO_10646__ is defined, wide character represents
 288     // UTF-16 (or UTF-32) code point. In most modern Unix like system
 289     // (e.g. Linux with glibc 2.2 and above) the macro is defined,
 290     // and wide character represents UTF-32 code point.
 291     // Here we static_cast potential UTF-32 to UTF-16, it should be
 292     // safe because date and (or) time related characters in different languages
 293     // should be in UNICODE BMP. If mbstowcs fails, we just fall
 294     // back on using multi-byte result as-is.
 295 #ifdef __STDC_ISO_10646__
 296     UChar buffer[bufsize];
 297     wchar_t tempbuffer[bufsize];
 298     size_t length = mbstowcs(tempbuffer, timebuffer, bufsize - 1);
 299     if (length != static_cast&lt;size_t&gt;(-1)) {
 300         for (size_t i = 0; i &lt; length; ++i)
 301             buffer[i] = static_cast&lt;UChar&gt;(tempbuffer[i]);
<a name="11" id="anc11"></a><span class="line-modified"> 302         return jsNontrivialString(exec, String(buffer, length));</span>
 303     }
 304 #endif
 305 
<a name="12" id="anc12"></a><span class="line-modified"> 306     return jsNontrivialString(exec, timebuffer);</span>
 307 #endif // OS(WINDOWS)
 308 }
 309 
 310 static JSCell* formatLocaleDate(ExecState* exec, DateInstance* dateObject, double, LocaleDateTimeFormat format)
 311 {
<a name="13" id="anc13"></a>
 312     const GregorianDateTime* gregorianDateTime = dateObject-&gt;gregorianDateTime(exec);
 313     if (!gregorianDateTime)
<a name="14" id="anc14"></a><span class="line-modified"> 314         return jsNontrivialString(exec, &quot;Invalid Date&quot;_s);</span>
 315     return formatLocaleDate(exec, *gregorianDateTime, format);
 316 }
 317 
 318 #endif // OS(DARWIN) &amp;&amp; USE(CF)
 319 
 320 static EncodedJSValue formateDateInstance(ExecState* exec, DateTimeFormat format, bool asUTCVariant)
 321 {
 322     VM&amp; vm = exec-&gt;vm();
 323     auto scope = DECLARE_THROW_SCOPE(vm);
 324     JSValue thisValue = exec-&gt;thisValue();
 325     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 326     if (UNLIKELY(!thisDateObj))
 327         return throwVMTypeError(exec, scope);
 328 
 329     const GregorianDateTime* gregorianDateTime = asUTCVariant
 330         ? thisDateObj-&gt;gregorianDateTimeUTC(exec)
 331         : thisDateObj-&gt;gregorianDateTime(exec);
 332     if (!gregorianDateTime)
<a name="15" id="anc15"></a><span class="line-modified"> 333         return JSValue::encode(jsNontrivialString(exec, String(&quot;Invalid Date&quot;_s)));</span>
 334 
<a name="16" id="anc16"></a><span class="line-modified"> 335     return JSValue::encode(jsNontrivialString(exec, formatDateTime(*gregorianDateTime, format, asUTCVariant)));</span>
 336 }
 337 
 338 // Converts a list of arguments sent to a Date member function into milliseconds, updating
 339 // ms (representing milliseconds) and t (representing the rest of the date structure) appropriately.
 340 //
 341 // Format of member function: f([hour,] [min,] [sec,] [ms])
 342 static bool fillStructuresUsingTimeArgs(ExecState* exec, int maxArgs, double* ms, GregorianDateTime* t)
 343 {
 344     VM&amp; vm = exec-&gt;vm();
 345     auto scope = DECLARE_THROW_SCOPE(vm);
 346 
 347     double milliseconds = 0;
 348     bool ok = true;
 349     int idx = 0;
 350     int numArgs = exec-&gt;argumentCount();
 351 
 352     // JS allows extra trailing arguments -- ignore them
 353     if (numArgs &gt; maxArgs)
 354         numArgs = maxArgs;
 355 
 356     // hours
 357     if (maxArgs &gt;= 4 &amp;&amp; idx &lt; numArgs) {
 358         t-&gt;setHour(0);
 359         double hours = exec-&gt;uncheckedArgument(idx++).toIntegerPreserveNaN(exec);
 360         RETURN_IF_EXCEPTION(scope, false);
 361         ok = std::isfinite(hours);
 362         milliseconds += hours * msPerHour;
 363     }
 364 
 365     // minutes
 366     if (maxArgs &gt;= 3 &amp;&amp; idx &lt; numArgs &amp;&amp; ok) {
 367         t-&gt;setMinute(0);
 368         double minutes = exec-&gt;uncheckedArgument(idx++).toIntegerPreserveNaN(exec);
 369         RETURN_IF_EXCEPTION(scope, false);
 370         ok = std::isfinite(minutes);
 371         milliseconds += minutes * msPerMinute;
 372     }
 373 
 374     // seconds
 375     if (maxArgs &gt;= 2 &amp;&amp; idx &lt; numArgs &amp;&amp; ok) {
 376         t-&gt;setSecond(0);
 377         double seconds = exec-&gt;uncheckedArgument(idx++).toIntegerPreserveNaN(exec);
 378         RETURN_IF_EXCEPTION(scope, false);
 379         ok = std::isfinite(seconds);
 380         milliseconds += seconds * msPerSecond;
 381     }
 382 
 383     if (!ok)
 384         return false;
 385 
 386     // milliseconds
 387     if (idx &lt; numArgs) {
 388         double millis = exec-&gt;uncheckedArgument(idx).toIntegerPreserveNaN(exec);
 389         RETURN_IF_EXCEPTION(scope, false);
 390         ok = std::isfinite(millis);
 391         milliseconds += millis;
 392     } else
 393         milliseconds += *ms;
 394 
 395     *ms = milliseconds;
 396     return ok;
 397 }
 398 
 399 // Converts a list of arguments sent to a Date member function into years, months, and milliseconds, updating
 400 // ms (representing milliseconds) and t (representing the rest of the date structure) appropriately.
 401 //
 402 // Format of member function: f([years,] [months,] [days])
 403 static bool fillStructuresUsingDateArgs(ExecState *exec, int maxArgs, double *ms, GregorianDateTime *t)
 404 {
 405     VM&amp; vm = exec-&gt;vm();
 406     auto scope = DECLARE_THROW_SCOPE(vm);
 407 
 408     int idx = 0;
 409     bool ok = true;
 410     int numArgs = exec-&gt;argumentCount();
 411 
 412     // JS allows extra trailing arguments -- ignore them
 413     if (numArgs &gt; maxArgs)
 414         numArgs = maxArgs;
 415 
 416     // years
 417     if (maxArgs &gt;= 3 &amp;&amp; idx &lt; numArgs) {
 418         double years = exec-&gt;uncheckedArgument(idx++).toIntegerPreserveNaN(exec);
 419         RETURN_IF_EXCEPTION(scope, false);
 420         ok = std::isfinite(years);
 421         t-&gt;setYear(toInt32(years));
 422     }
 423     // months
 424     if (maxArgs &gt;= 2 &amp;&amp; idx &lt; numArgs &amp;&amp; ok) {
 425         double months = exec-&gt;uncheckedArgument(idx++).toIntegerPreserveNaN(exec);
 426         RETURN_IF_EXCEPTION(scope, false);
 427         ok = std::isfinite(months);
 428         t-&gt;setMonth(toInt32(months));
 429     }
 430     // days
 431     if (idx &lt; numArgs &amp;&amp; ok) {
 432         double days = exec-&gt;uncheckedArgument(idx++).toIntegerPreserveNaN(exec);
 433         RETURN_IF_EXCEPTION(scope, false);
 434         ok = std::isfinite(days);
 435         t-&gt;setMonthDay(0);
 436         *ms += days * msPerDay;
 437     }
 438 
 439     return ok;
 440 }
 441 
 442 const ClassInfo DatePrototype::s_info = {&quot;Object&quot;, &amp;JSNonFinalObject::s_info, &amp;dateTable, nullptr, CREATE_METHOD_TABLE(DatePrototype)};
 443 
 444 /* Source for DatePrototype.lut.h
 445 @begin dateTable
 446   toString              dateProtoFuncToString                DontEnum|Function       0
 447   toISOString           dateProtoFuncToISOString             DontEnum|Function       0
 448   toDateString          dateProtoFuncToDateString            DontEnum|Function       0
 449   toTimeString          dateProtoFuncToTimeString            DontEnum|Function       0
 450   toLocaleString        dateProtoFuncToLocaleString          DontEnum|Function       0
 451   toLocaleDateString    dateProtoFuncToLocaleDateString      DontEnum|Function       0
 452   toLocaleTimeString    dateProtoFuncToLocaleTimeString      DontEnum|Function       0
 453   valueOf               dateProtoFuncGetTime                 DontEnum|Function       0
 454   getTime               dateProtoFuncGetTime                 DontEnum|Function       0
 455   getFullYear           dateProtoFuncGetFullYear             DontEnum|Function       0
 456   getUTCFullYear        dateProtoFuncGetUTCFullYear          DontEnum|Function       0
 457   getMonth              dateProtoFuncGetMonth                DontEnum|Function       0
 458   getUTCMonth           dateProtoFuncGetUTCMonth             DontEnum|Function       0
 459   getDate               dateProtoFuncGetDate                 DontEnum|Function       0
 460   getUTCDate            dateProtoFuncGetUTCDate              DontEnum|Function       0
 461   getDay                dateProtoFuncGetDay                  DontEnum|Function       0
 462   getUTCDay             dateProtoFuncGetUTCDay               DontEnum|Function       0
 463   getHours              dateProtoFuncGetHours                DontEnum|Function       0
 464   getUTCHours           dateProtoFuncGetUTCHours             DontEnum|Function       0
 465   getMinutes            dateProtoFuncGetMinutes              DontEnum|Function       0
 466   getUTCMinutes         dateProtoFuncGetUTCMinutes           DontEnum|Function       0
 467   getSeconds            dateProtoFuncGetSeconds              DontEnum|Function       0
 468   getUTCSeconds         dateProtoFuncGetUTCSeconds           DontEnum|Function       0
 469   getMilliseconds       dateProtoFuncGetMilliSeconds         DontEnum|Function       0
 470   getUTCMilliseconds    dateProtoFuncGetUTCMilliseconds      DontEnum|Function       0
 471   getTimezoneOffset     dateProtoFuncGetTimezoneOffset       DontEnum|Function       0
 472   setTime               dateProtoFuncSetTime                 DontEnum|Function       1
 473   setMilliseconds       dateProtoFuncSetMilliSeconds         DontEnum|Function       1
 474   setUTCMilliseconds    dateProtoFuncSetUTCMilliseconds      DontEnum|Function       1
 475   setSeconds            dateProtoFuncSetSeconds              DontEnum|Function       2
 476   setUTCSeconds         dateProtoFuncSetUTCSeconds           DontEnum|Function       2
 477   setMinutes            dateProtoFuncSetMinutes              DontEnum|Function       3
 478   setUTCMinutes         dateProtoFuncSetUTCMinutes           DontEnum|Function       3
 479   setHours              dateProtoFuncSetHours                DontEnum|Function       4
 480   setUTCHours           dateProtoFuncSetUTCHours             DontEnum|Function       4
 481   setDate               dateProtoFuncSetDate                 DontEnum|Function       1
 482   setUTCDate            dateProtoFuncSetUTCDate              DontEnum|Function       1
 483   setMonth              dateProtoFuncSetMonth                DontEnum|Function       2
 484   setUTCMonth           dateProtoFuncSetUTCMonth             DontEnum|Function       2
 485   setFullYear           dateProtoFuncSetFullYear             DontEnum|Function       3
 486   setUTCFullYear        dateProtoFuncSetUTCFullYear          DontEnum|Function       3
 487   setYear               dateProtoFuncSetYear                 DontEnum|Function       1
 488   getYear               dateProtoFuncGetYear                 DontEnum|Function       0
 489   toJSON                dateProtoFuncToJSON                  DontEnum|Function       1
 490 @end
 491 */
 492 
 493 // ECMA 15.9.4
 494 
 495 DatePrototype::DatePrototype(VM&amp; vm, Structure* structure)
 496     : Base(vm, structure)
 497 {
 498 }
 499 
 500 void DatePrototype::finishCreation(VM&amp; vm, JSGlobalObject* globalObject)
 501 {
 502     Base::finishCreation(vm);
 503     ASSERT(inherits(vm, info()));
 504 
<a name="17" id="anc17"></a><span class="line-modified"> 505     Identifier toUTCStringName = Identifier::fromString(&amp;vm, &quot;toUTCString&quot;_s);</span>
 506     JSFunction* toUTCStringFunction = JSFunction::create(vm, globalObject, 0, toUTCStringName.string(), dateProtoFuncToUTCString);
 507     putDirectWithoutTransition(vm, toUTCStringName, toUTCStringFunction, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
<a name="18" id="anc18"></a><span class="line-modified"> 508     putDirectWithoutTransition(vm, Identifier::fromString(&amp;vm, &quot;toGMTString&quot;_s), toUTCStringFunction, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
 509 
 510 #if ENABLE(INTL)
 511     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(&quot;toLocaleString&quot;, datePrototypeToLocaleStringCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 512     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(&quot;toLocaleDateString&quot;, datePrototypeToLocaleDateStringCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 513     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(&quot;toLocaleTimeString&quot;, datePrototypeToLocaleTimeStringCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 514 #endif
 515 
 516     JSFunction* toPrimitiveFunction = JSFunction::create(vm, globalObject, 1, &quot;[Symbol.toPrimitive]&quot;_s, dateProtoFuncToPrimitiveSymbol, NoIntrinsic);
 517     putDirectWithoutTransition(vm, vm.propertyNames-&gt;toPrimitiveSymbol, toPrimitiveFunction, PropertyAttribute::DontEnum | PropertyAttribute::ReadOnly);
 518 
 519     // The constructor will be added later, after DateConstructor has been built.
 520 }
 521 
 522 // Functions
 523 
 524 EncodedJSValue JSC_HOST_CALL dateProtoFuncToString(ExecState* exec)
 525 {
 526     const bool asUTCVariant = false;
 527     return formateDateInstance(exec, DateTimeFormatDateAndTime, asUTCVariant);
 528 }
 529 
 530 EncodedJSValue JSC_HOST_CALL dateProtoFuncToUTCString(ExecState* exec)
 531 {
 532     const bool asUTCVariant = true;
 533     return formateDateInstance(exec, DateTimeFormatDateAndTime, asUTCVariant);
 534 }
 535 
 536 EncodedJSValue JSC_HOST_CALL dateProtoFuncToISOString(ExecState* exec)
 537 {
 538     VM&amp; vm = exec-&gt;vm();
 539     auto scope = DECLARE_THROW_SCOPE(vm);
 540     JSValue thisValue = exec-&gt;thisValue();
 541     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 542     if (UNLIKELY(!thisDateObj))
 543         return throwVMTypeError(exec, scope);
 544 
 545     if (!std::isfinite(thisDateObj-&gt;internalNumber()))
 546         return throwVMError(exec, scope, createRangeError(exec, &quot;Invalid Date&quot;_s));
 547 
 548     const GregorianDateTime* gregorianDateTime = thisDateObj-&gt;gregorianDateTimeUTC(exec);
 549     if (!gregorianDateTime)
<a name="19" id="anc19"></a><span class="line-modified"> 550         return JSValue::encode(jsNontrivialString(exec, String(&quot;Invalid Date&quot;_s)));</span>
 551     // Maximum amount of space we need in buffer: 7 (max. digits in year) + 2 * 5 (2 characters each for month, day, hour, minute, second) + 4 (. + 3 digits for milliseconds)
 552     // 6 for formatting and one for null termination = 28. We add one extra character to allow us to force null termination.
 553     char buffer[28];
 554     // If the year is outside the bounds of 0 and 9999 inclusive we want to use the extended year format (ES 15.9.1.15.1).
 555     int ms = static_cast&lt;int&gt;(fmod(thisDateObj-&gt;internalNumber(), msPerSecond));
 556     if (ms &lt; 0)
 557         ms += msPerSecond;
 558 
 559     int charactersWritten;
 560     if (gregorianDateTime-&gt;year() &gt; 9999 || gregorianDateTime-&gt;year() &lt; 0)
 561         charactersWritten = snprintf(buffer, sizeof(buffer), &quot;%+07d-%02d-%02dT%02d:%02d:%02d.%03dZ&quot;, gregorianDateTime-&gt;year(), gregorianDateTime-&gt;month() + 1, gregorianDateTime-&gt;monthDay(), gregorianDateTime-&gt;hour(), gregorianDateTime-&gt;minute(), gregorianDateTime-&gt;second(), ms);
 562     else
 563         charactersWritten = snprintf(buffer, sizeof(buffer), &quot;%04d-%02d-%02dT%02d:%02d:%02d.%03dZ&quot;, gregorianDateTime-&gt;year(), gregorianDateTime-&gt;month() + 1, gregorianDateTime-&gt;monthDay(), gregorianDateTime-&gt;hour(), gregorianDateTime-&gt;minute(), gregorianDateTime-&gt;second(), ms);
 564 
 565     ASSERT(charactersWritten &gt; 0 &amp;&amp; static_cast&lt;unsigned&gt;(charactersWritten) &lt; sizeof(buffer));
 566     if (static_cast&lt;unsigned&gt;(charactersWritten) &gt;= sizeof(buffer))
<a name="20" id="anc20"></a><span class="line-modified"> 567         return JSValue::encode(jsEmptyString(exec));</span>
 568 
<a name="21" id="anc21"></a><span class="line-modified"> 569     return JSValue::encode(jsNontrivialString(exec, String(buffer, charactersWritten)));</span>
 570 }
 571 
 572 EncodedJSValue JSC_HOST_CALL dateProtoFuncToDateString(ExecState* exec)
 573 {
 574     const bool asUTCVariant = false;
 575     return formateDateInstance(exec, DateTimeFormatDate, asUTCVariant);
 576 }
 577 
 578 EncodedJSValue JSC_HOST_CALL dateProtoFuncToTimeString(ExecState* exec)
 579 {
 580     const bool asUTCVariant = false;
 581     return formateDateInstance(exec, DateTimeFormatTime, asUTCVariant);
 582 }
 583 
 584 EncodedJSValue JSC_HOST_CALL dateProtoFuncToLocaleString(ExecState* exec)
 585 {
 586     VM&amp; vm = exec-&gt;vm();
 587     auto scope = DECLARE_THROW_SCOPE(vm);
 588     JSValue thisValue = exec-&gt;thisValue();
 589     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 590     if (UNLIKELY(!thisDateObj))
 591         return throwVMTypeError(exec, scope);
 592 
 593     return JSValue::encode(formatLocaleDate(exec, thisDateObj, thisDateObj-&gt;internalNumber(), LocaleDateAndTime));
 594 }
 595 
 596 EncodedJSValue JSC_HOST_CALL dateProtoFuncToLocaleDateString(ExecState* exec)
 597 {
 598     VM&amp; vm = exec-&gt;vm();
 599     auto scope = DECLARE_THROW_SCOPE(vm);
 600     JSValue thisValue = exec-&gt;thisValue();
 601     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 602     if (UNLIKELY(!thisDateObj))
 603         return throwVMTypeError(exec, scope);
 604 
 605     return JSValue::encode(formatLocaleDate(exec, thisDateObj, thisDateObj-&gt;internalNumber(), LocaleDate));
 606 }
 607 
 608 EncodedJSValue JSC_HOST_CALL dateProtoFuncToLocaleTimeString(ExecState* exec)
 609 {
 610     VM&amp; vm = exec-&gt;vm();
 611     auto scope = DECLARE_THROW_SCOPE(vm);
 612     JSValue thisValue = exec-&gt;thisValue();
 613     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 614     if (UNLIKELY(!thisDateObj))
 615         return throwVMTypeError(exec, scope);
 616 
 617     return JSValue::encode(formatLocaleDate(exec, thisDateObj, thisDateObj-&gt;internalNumber(), LocaleTime));
 618 }
 619 
 620 EncodedJSValue JSC_HOST_CALL dateProtoFuncToPrimitiveSymbol(ExecState* exec)
 621 {
 622     VM&amp; vm = exec-&gt;vm();
 623     auto scope = DECLARE_THROW_SCOPE(vm);
 624     JSValue thisValue = exec-&gt;thisValue();
 625     if (!thisValue.isObject())
 626         return throwVMTypeError(exec, scope, &quot;Date.prototype[Symbol.toPrimitive] expected |this| to be an object.&quot;);
 627     JSObject* thisObject = jsCast&lt;JSObject*&gt;(thisValue);
 628 
 629     if (!exec-&gt;argumentCount())
 630         return throwVMTypeError(exec, scope, &quot;Date.prototype[Symbol.toPrimitive] expected a first argument.&quot;);
 631 
 632     JSValue hintValue = exec-&gt;uncheckedArgument(0);
 633     PreferredPrimitiveType type = toPreferredPrimitiveType(exec, hintValue);
 634     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 635 
 636     if (type == NoPreference)
 637         type = PreferString;
 638 
 639     RELEASE_AND_RETURN(scope, JSValue::encode(thisObject-&gt;ordinaryToPrimitive(exec, type)));
 640 }
 641 
 642 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetTime(ExecState* exec)
 643 {
 644     VM&amp; vm = exec-&gt;vm();
 645     auto scope = DECLARE_THROW_SCOPE(vm);
 646     JSValue thisValue = exec-&gt;thisValue();
 647     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 648     if (UNLIKELY(!thisDateObj))
 649         return throwVMTypeError(exec, scope);
 650 
 651     return JSValue::encode(jsNumber(thisDateObj-&gt;internalNumber()));
 652 }
 653 
 654 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetFullYear(ExecState* exec)
 655 {
 656     VM&amp; vm = exec-&gt;vm();
 657     auto scope = DECLARE_THROW_SCOPE(vm);
 658     JSValue thisValue = exec-&gt;thisValue();
 659     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 660     if (UNLIKELY(!thisDateObj))
 661         return throwVMTypeError(exec, scope);
 662 
 663     const GregorianDateTime* gregorianDateTime = thisDateObj-&gt;gregorianDateTime(exec);
 664     if (!gregorianDateTime)
 665         return JSValue::encode(jsNaN());
 666     return JSValue::encode(jsNumber(gregorianDateTime-&gt;year()));
 667 }
 668 
 669 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetUTCFullYear(ExecState* exec)
 670 {
 671     VM&amp; vm = exec-&gt;vm();
 672     auto scope = DECLARE_THROW_SCOPE(vm);
 673     JSValue thisValue = exec-&gt;thisValue();
 674     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 675     if (UNLIKELY(!thisDateObj))
 676         return throwVMTypeError(exec, scope);
 677 
 678     const GregorianDateTime* gregorianDateTime = thisDateObj-&gt;gregorianDateTimeUTC(exec);
 679     if (!gregorianDateTime)
 680         return JSValue::encode(jsNaN());
 681     return JSValue::encode(jsNumber(gregorianDateTime-&gt;year()));
 682 }
 683 
 684 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetMonth(ExecState* exec)
 685 {
 686     VM&amp; vm = exec-&gt;vm();
 687     auto scope = DECLARE_THROW_SCOPE(vm);
 688     JSValue thisValue = exec-&gt;thisValue();
 689     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 690     if (UNLIKELY(!thisDateObj))
 691         return throwVMTypeError(exec, scope);
 692 
 693     const GregorianDateTime* gregorianDateTime = thisDateObj-&gt;gregorianDateTime(exec);
 694     if (!gregorianDateTime)
 695         return JSValue::encode(jsNaN());
 696     return JSValue::encode(jsNumber(gregorianDateTime-&gt;month()));
 697 }
 698 
 699 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetUTCMonth(ExecState* exec)
 700 {
 701     VM&amp; vm = exec-&gt;vm();
 702     auto scope = DECLARE_THROW_SCOPE(vm);
 703     JSValue thisValue = exec-&gt;thisValue();
 704     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 705     if (UNLIKELY(!thisDateObj))
 706         return throwVMTypeError(exec, scope);
 707 
 708     const GregorianDateTime* gregorianDateTime = thisDateObj-&gt;gregorianDateTimeUTC(exec);
 709     if (!gregorianDateTime)
 710         return JSValue::encode(jsNaN());
 711     return JSValue::encode(jsNumber(gregorianDateTime-&gt;month()));
 712 }
 713 
 714 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetDate(ExecState* exec)
 715 {
 716     VM&amp; vm = exec-&gt;vm();
 717     auto scope = DECLARE_THROW_SCOPE(vm);
 718     JSValue thisValue = exec-&gt;thisValue();
 719     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 720     if (UNLIKELY(!thisDateObj))
 721         return throwVMTypeError(exec, scope);
 722 
 723     const GregorianDateTime* gregorianDateTime = thisDateObj-&gt;gregorianDateTime(exec);
 724     if (!gregorianDateTime)
 725         return JSValue::encode(jsNaN());
 726     return JSValue::encode(jsNumber(gregorianDateTime-&gt;monthDay()));
 727 }
 728 
 729 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetUTCDate(ExecState* exec)
 730 {
 731     VM&amp; vm = exec-&gt;vm();
 732     auto scope = DECLARE_THROW_SCOPE(vm);
 733     JSValue thisValue = exec-&gt;thisValue();
 734     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 735     if (UNLIKELY(!thisDateObj))
 736         return throwVMTypeError(exec, scope);
 737 
 738     const GregorianDateTime* gregorianDateTime = thisDateObj-&gt;gregorianDateTimeUTC(exec);
 739     if (!gregorianDateTime)
 740         return JSValue::encode(jsNaN());
 741     return JSValue::encode(jsNumber(gregorianDateTime-&gt;monthDay()));
 742 }
 743 
 744 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetDay(ExecState* exec)
 745 {
 746     VM&amp; vm = exec-&gt;vm();
 747     auto scope = DECLARE_THROW_SCOPE(vm);
 748     JSValue thisValue = exec-&gt;thisValue();
 749     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 750     if (UNLIKELY(!thisDateObj))
 751         return throwVMTypeError(exec, scope);
 752 
 753     const GregorianDateTime* gregorianDateTime = thisDateObj-&gt;gregorianDateTime(exec);
 754     if (!gregorianDateTime)
 755         return JSValue::encode(jsNaN());
 756     return JSValue::encode(jsNumber(gregorianDateTime-&gt;weekDay()));
 757 }
 758 
 759 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetUTCDay(ExecState* exec)
 760 {
 761     VM&amp; vm = exec-&gt;vm();
 762     auto scope = DECLARE_THROW_SCOPE(vm);
 763     JSValue thisValue = exec-&gt;thisValue();
 764     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 765     if (UNLIKELY(!thisDateObj))
 766         return throwVMTypeError(exec, scope);
 767 
 768     const GregorianDateTime* gregorianDateTime = thisDateObj-&gt;gregorianDateTimeUTC(exec);
 769     if (!gregorianDateTime)
 770         return JSValue::encode(jsNaN());
 771     return JSValue::encode(jsNumber(gregorianDateTime-&gt;weekDay()));
 772 }
 773 
 774 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetHours(ExecState* exec)
 775 {
 776     VM&amp; vm = exec-&gt;vm();
 777     auto scope = DECLARE_THROW_SCOPE(vm);
 778     JSValue thisValue = exec-&gt;thisValue();
 779     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 780     if (UNLIKELY(!thisDateObj))
 781         return throwVMTypeError(exec, scope);
 782 
 783     const GregorianDateTime* gregorianDateTime = thisDateObj-&gt;gregorianDateTime(exec);
 784     if (!gregorianDateTime)
 785         return JSValue::encode(jsNaN());
 786     return JSValue::encode(jsNumber(gregorianDateTime-&gt;hour()));
 787 }
 788 
 789 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetUTCHours(ExecState* exec)
 790 {
 791     VM&amp; vm = exec-&gt;vm();
 792     auto scope = DECLARE_THROW_SCOPE(vm);
 793     JSValue thisValue = exec-&gt;thisValue();
 794     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 795     if (UNLIKELY(!thisDateObj))
 796         return throwVMTypeError(exec, scope);
 797 
 798     const GregorianDateTime* gregorianDateTime = thisDateObj-&gt;gregorianDateTimeUTC(exec);
 799     if (!gregorianDateTime)
 800         return JSValue::encode(jsNaN());
 801     return JSValue::encode(jsNumber(gregorianDateTime-&gt;hour()));
 802 }
 803 
 804 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetMinutes(ExecState* exec)
 805 {
 806     VM&amp; vm = exec-&gt;vm();
 807     auto scope = DECLARE_THROW_SCOPE(vm);
 808     JSValue thisValue = exec-&gt;thisValue();
 809     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 810     if (UNLIKELY(!thisDateObj))
 811         return throwVMTypeError(exec, scope);
 812 
 813     const GregorianDateTime* gregorianDateTime = thisDateObj-&gt;gregorianDateTime(exec);
 814     if (!gregorianDateTime)
 815         return JSValue::encode(jsNaN());
 816     return JSValue::encode(jsNumber(gregorianDateTime-&gt;minute()));
 817 }
 818 
 819 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetUTCMinutes(ExecState* exec)
 820 {
 821     VM&amp; vm = exec-&gt;vm();
 822     auto scope = DECLARE_THROW_SCOPE(vm);
 823     JSValue thisValue = exec-&gt;thisValue();
 824     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 825     if (UNLIKELY(!thisDateObj))
 826         return throwVMTypeError(exec, scope);
 827 
 828     const GregorianDateTime* gregorianDateTime = thisDateObj-&gt;gregorianDateTimeUTC(exec);
 829     if (!gregorianDateTime)
 830         return JSValue::encode(jsNaN());
 831     return JSValue::encode(jsNumber(gregorianDateTime-&gt;minute()));
 832 }
 833 
 834 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetSeconds(ExecState* exec)
 835 {
 836     VM&amp; vm = exec-&gt;vm();
 837     auto scope = DECLARE_THROW_SCOPE(vm);
 838     JSValue thisValue = exec-&gt;thisValue();
 839     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 840     if (UNLIKELY(!thisDateObj))
 841         return throwVMTypeError(exec, scope);
 842 
 843     const GregorianDateTime* gregorianDateTime = thisDateObj-&gt;gregorianDateTime(exec);
 844     if (!gregorianDateTime)
 845         return JSValue::encode(jsNaN());
 846     return JSValue::encode(jsNumber(gregorianDateTime-&gt;second()));
 847 }
 848 
 849 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetUTCSeconds(ExecState* exec)
 850 {
 851     VM&amp; vm = exec-&gt;vm();
 852     auto scope = DECLARE_THROW_SCOPE(vm);
 853     JSValue thisValue = exec-&gt;thisValue();
 854     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 855     if (UNLIKELY(!thisDateObj))
 856         return throwVMTypeError(exec, scope);
 857 
 858     const GregorianDateTime* gregorianDateTime = thisDateObj-&gt;gregorianDateTimeUTC(exec);
 859     if (!gregorianDateTime)
 860         return JSValue::encode(jsNaN());
 861     return JSValue::encode(jsNumber(gregorianDateTime-&gt;second()));
 862 }
 863 
 864 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetMilliSeconds(ExecState* exec)
 865 {
 866     VM&amp; vm = exec-&gt;vm();
 867     auto scope = DECLARE_THROW_SCOPE(vm);
 868     JSValue thisValue = exec-&gt;thisValue();
 869     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 870     if (UNLIKELY(!thisDateObj))
 871         return throwVMTypeError(exec, scope);
 872 
 873     double milli = thisDateObj-&gt;internalNumber();
 874     if (std::isnan(milli))
 875         return JSValue::encode(jsNaN());
 876 
 877     double secs = floor(milli / msPerSecond);
 878     double ms = milli - secs * msPerSecond;
 879     return JSValue::encode(jsNumber(ms));
 880 }
 881 
 882 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetUTCMilliseconds(ExecState* exec)
 883 {
 884     VM&amp; vm = exec-&gt;vm();
 885     auto scope = DECLARE_THROW_SCOPE(vm);
 886     JSValue thisValue = exec-&gt;thisValue();
 887     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 888     if (UNLIKELY(!thisDateObj))
 889         return throwVMTypeError(exec, scope);
 890 
 891     double milli = thisDateObj-&gt;internalNumber();
 892     if (std::isnan(milli))
 893         return JSValue::encode(jsNaN());
 894 
 895     double secs = floor(milli / msPerSecond);
 896     double ms = milli - secs * msPerSecond;
 897     return JSValue::encode(jsNumber(ms));
 898 }
 899 
 900 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetTimezoneOffset(ExecState* exec)
 901 {
 902     VM&amp; vm = exec-&gt;vm();
 903     auto scope = DECLARE_THROW_SCOPE(vm);
 904     JSValue thisValue = exec-&gt;thisValue();
 905     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 906     if (UNLIKELY(!thisDateObj))
 907         return throwVMTypeError(exec, scope);
 908 
 909     const GregorianDateTime* gregorianDateTime = thisDateObj-&gt;gregorianDateTime(exec);
 910     if (!gregorianDateTime)
 911         return JSValue::encode(jsNaN());
 912     return JSValue::encode(jsNumber(-gregorianDateTime-&gt;utcOffset() / minutesPerHour));
 913 }
 914 
 915 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetTime(ExecState* exec)
 916 {
 917     VM&amp; vm = exec-&gt;vm();
 918     auto scope = DECLARE_THROW_SCOPE(vm);
 919     JSValue thisValue = exec-&gt;thisValue();
 920     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 921     if (UNLIKELY(!thisDateObj))
 922         return throwVMTypeError(exec, scope);
 923 
 924     double milli = timeClip(exec-&gt;argument(0).toNumber(exec));
 925     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 926     thisDateObj-&gt;setInternalNumber(milli);
 927     return JSValue::encode(jsNumber(milli));
 928 }
 929 
 930 static EncodedJSValue setNewValueFromTimeArgs(ExecState* exec, int numArgsToUse, WTF::TimeType inputTimeType)
 931 {
 932     VM&amp; vm = exec-&gt;vm();
 933     auto scope = DECLARE_THROW_SCOPE(vm);
 934     JSValue thisValue = exec-&gt;thisValue();
 935     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 936     if (UNLIKELY(!thisDateObj))
 937         return throwVMTypeError(exec, scope);
 938 
 939     double milli = thisDateObj-&gt;internalNumber();
 940 
 941     if (!exec-&gt;argumentCount() || std::isnan(milli)) {
 942         thisDateObj-&gt;setInternalNumber(PNaN);
 943         return JSValue::encode(jsNaN());
 944     }
 945 
 946     double secs = floor(milli / msPerSecond);
 947     double ms = milli - secs * msPerSecond;
 948 
 949     const GregorianDateTime* other = inputTimeType == WTF::UTCTime
 950         ? thisDateObj-&gt;gregorianDateTimeUTC(exec)
 951         : thisDateObj-&gt;gregorianDateTime(exec);
 952     if (!other)
 953         return JSValue::encode(jsNaN());
 954 
 955     GregorianDateTime gregorianDateTime;
 956     gregorianDateTime.copyFrom(*other);
 957     bool success = fillStructuresUsingTimeArgs(exec, numArgsToUse, &amp;ms, &amp;gregorianDateTime);
 958     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 959     if (!success) {
 960         thisDateObj-&gt;setInternalNumber(PNaN);
 961         return JSValue::encode(jsNaN());
 962     }
 963 
 964     double newUTCDate = gregorianDateTimeToMS(vm, gregorianDateTime, ms, inputTimeType);
 965     double result = timeClip(newUTCDate);
 966     thisDateObj-&gt;setInternalNumber(result);
 967     return JSValue::encode(jsNumber(result));
 968 }
 969 
 970 static EncodedJSValue setNewValueFromDateArgs(ExecState* exec, int numArgsToUse, WTF::TimeType inputTimeType)
 971 {
 972     VM&amp; vm = exec-&gt;vm();
 973     auto scope = DECLARE_THROW_SCOPE(vm);
 974     JSValue thisValue = exec-&gt;thisValue();
 975     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 976     if (UNLIKELY(!thisDateObj))
 977         return throwVMTypeError(exec, scope);
 978 
 979     if (!exec-&gt;argumentCount()) {
 980         thisDateObj-&gt;setInternalNumber(PNaN);
 981         return JSValue::encode(jsNaN());
 982     }
 983 
 984     double milli = thisDateObj-&gt;internalNumber();
 985     double ms = 0;
 986 
 987     GregorianDateTime gregorianDateTime;
 988     if (numArgsToUse == 3 &amp;&amp; std::isnan(milli))
 989         msToGregorianDateTime(vm, 0, WTF::UTCTime, gregorianDateTime);
 990     else {
 991         ms = milli - floor(milli / msPerSecond) * msPerSecond;
 992         const GregorianDateTime* other = inputTimeType == WTF::UTCTime
 993             ? thisDateObj-&gt;gregorianDateTimeUTC(exec)
 994             : thisDateObj-&gt;gregorianDateTime(exec);
 995         if (!other)
 996             return JSValue::encode(jsNaN());
 997         gregorianDateTime.copyFrom(*other);
 998     }
 999 
1000     bool success = fillStructuresUsingDateArgs(exec, numArgsToUse, &amp;ms, &amp;gregorianDateTime);
1001     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1002     if (!success) {
1003         thisDateObj-&gt;setInternalNumber(PNaN);
1004         return JSValue::encode(jsNaN());
1005     }
1006 
1007     double newUTCDate = gregorianDateTimeToMS(vm, gregorianDateTime, ms, inputTimeType);
1008     double result = timeClip(newUTCDate);
1009     thisDateObj-&gt;setInternalNumber(result);
1010     return JSValue::encode(jsNumber(result));
1011 }
1012 
1013 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetMilliSeconds(ExecState* exec)
1014 {
1015     return setNewValueFromTimeArgs(exec, 1, WTF::LocalTime);
1016 }
1017 
1018 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetUTCMilliseconds(ExecState* exec)
1019 {
1020     return setNewValueFromTimeArgs(exec, 1, WTF::UTCTime);
1021 }
1022 
1023 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetSeconds(ExecState* exec)
1024 {
1025     return setNewValueFromTimeArgs(exec, 2, WTF::LocalTime);
1026 }
1027 
1028 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetUTCSeconds(ExecState* exec)
1029 {
1030     return setNewValueFromTimeArgs(exec, 2, WTF::UTCTime);
1031 }
1032 
1033 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetMinutes(ExecState* exec)
1034 {
1035     return setNewValueFromTimeArgs(exec, 3, WTF::LocalTime);
1036 }
1037 
1038 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetUTCMinutes(ExecState* exec)
1039 {
1040     return setNewValueFromTimeArgs(exec, 3, WTF::UTCTime);
1041 }
1042 
1043 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetHours(ExecState* exec)
1044 {
1045     return setNewValueFromTimeArgs(exec, 4, WTF::LocalTime);
1046 }
1047 
1048 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetUTCHours(ExecState* exec)
1049 {
1050     return setNewValueFromTimeArgs(exec, 4, WTF::UTCTime);
1051 }
1052 
1053 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetDate(ExecState* exec)
1054 {
1055     return setNewValueFromDateArgs(exec, 1, WTF::LocalTime);
1056 }
1057 
1058 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetUTCDate(ExecState* exec)
1059 {
1060     return setNewValueFromDateArgs(exec, 1, WTF::UTCTime);
1061 }
1062 
1063 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetMonth(ExecState* exec)
1064 {
1065     return setNewValueFromDateArgs(exec, 2, WTF::LocalTime);
1066 }
1067 
1068 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetUTCMonth(ExecState* exec)
1069 {
1070     return setNewValueFromDateArgs(exec, 2, WTF::UTCTime);
1071 }
1072 
1073 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetFullYear(ExecState* exec)
1074 {
1075     return setNewValueFromDateArgs(exec, 3, WTF::LocalTime);
1076 }
1077 
1078 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetUTCFullYear(ExecState* exec)
1079 {
1080     return setNewValueFromDateArgs(exec, 3, WTF::UTCTime);
1081 }
1082 
1083 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetYear(ExecState* exec)
1084 {
1085     VM&amp; vm = exec-&gt;vm();
1086     auto scope = DECLARE_THROW_SCOPE(vm);
1087     JSValue thisValue = exec-&gt;thisValue();
1088     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
1089     if (UNLIKELY(!thisDateObj))
1090         return throwVMTypeError(exec, scope);
1091 
1092     if (!exec-&gt;argumentCount()) {
1093         thisDateObj-&gt;setInternalNumber(PNaN);
1094         return JSValue::encode(jsNaN());
1095     }
1096 
1097     double milli = thisDateObj-&gt;internalNumber();
1098     double ms = 0;
1099 
1100     GregorianDateTime gregorianDateTime;
1101     if (std::isnan(milli))
1102         // Based on ECMA 262 B.2.5 (setYear)
1103         // the time must be reset to +0 if it is NaN.
1104         msToGregorianDateTime(vm, 0, WTF::UTCTime, gregorianDateTime);
1105     else {
1106         double secs = floor(milli / msPerSecond);
1107         ms = milli - secs * msPerSecond;
1108         if (const GregorianDateTime* other = thisDateObj-&gt;gregorianDateTime(exec))
1109             gregorianDateTime.copyFrom(*other);
1110     }
1111 
1112     double year = exec-&gt;argument(0).toIntegerPreserveNaN(exec);
1113     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1114     if (!std::isfinite(year)) {
1115         thisDateObj-&gt;setInternalNumber(PNaN);
1116         return JSValue::encode(jsNaN());
1117     }
1118 
1119     gregorianDateTime.setYear(toInt32((year &gt;= 0 &amp;&amp; year &lt;= 99) ? (year + 1900) : year));
1120     double timeInMilliseconds = gregorianDateTimeToMS(vm, gregorianDateTime, ms, WTF::LocalTime);
1121     double result = timeClip(timeInMilliseconds);
1122     thisDateObj-&gt;setInternalNumber(result);
1123     return JSValue::encode(jsNumber(result));
1124 }
1125 
1126 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetYear(ExecState* exec)
1127 {
1128     VM&amp; vm = exec-&gt;vm();
1129     auto scope = DECLARE_THROW_SCOPE(vm);
1130     JSValue thisValue = exec-&gt;thisValue();
1131     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
1132     if (UNLIKELY(!thisDateObj))
1133         return throwVMTypeError(exec, scope);
1134 
1135     const GregorianDateTime* gregorianDateTime = thisDateObj-&gt;gregorianDateTime(exec);
1136     if (!gregorianDateTime)
1137         return JSValue::encode(jsNaN());
1138 
1139     // NOTE: IE returns the full year even in getYear.
1140     return JSValue::encode(jsNumber(gregorianDateTime-&gt;year() - 1900));
1141 }
1142 
1143 EncodedJSValue JSC_HOST_CALL dateProtoFuncToJSON(ExecState* exec)
1144 {
1145     VM&amp; vm = exec-&gt;vm();
1146     auto scope = DECLARE_THROW_SCOPE(vm);
1147     JSValue thisValue = exec-&gt;thisValue();
1148     JSObject* object = jsCast&lt;JSObject*&gt;(thisValue.toThis(exec, NotStrictMode));
1149     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1150 
1151     JSValue timeValue = object-&gt;toPrimitive(exec, PreferNumber);
1152     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1153     if (timeValue.isNumber() &amp;&amp; !(timeValue.isInt32() || std::isfinite(timeValue.asDouble())))
1154         return JSValue::encode(jsNull());
1155 
1156     JSValue toISOValue = object-&gt;get(exec, vm.propertyNames-&gt;toISOString);
1157     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1158 
1159     CallData callData;
1160     CallType callType = getCallData(vm, toISOValue, callData);
1161     if (callType == CallType::None)
1162         return throwVMTypeError(exec, scope, &quot;toISOString is not a function&quot;_s);
1163 
1164     JSValue result = call(exec, asObject(toISOValue), callType, callData, object, *vm.emptyList);
1165     RETURN_IF_EXCEPTION(scope, encodedJSValue());
<a name="22" id="anc22"></a><span class="line-removed">1166     if (result.isObject())</span>
<span class="line-removed">1167         return throwVMTypeError(exec, scope, &quot;toISOString did not return a primitive value&quot;_s);</span>
1168     return JSValue::encode(result);
1169 }
1170 
1171 } // namespace JSC
<a name="23" id="anc23"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="23" type="hidden" />
</body>
</html>