<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/assembler/testmasm.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="X86Assembler.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../b3/B3ArgumentRegValue.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/assembler/testmasm.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 
  28 #include &quot;CCallHelpers.h&quot;
  29 #include &quot;CPU.h&quot;
  30 #include &quot;FPRInfo.h&quot;
  31 #include &quot;GPRInfo.h&quot;
  32 #include &quot;InitializeThreading.h&quot;
  33 #include &quot;LinkBuffer.h&quot;
  34 #include &quot;ProbeContext.h&quot;
  35 #include &quot;StackAlignment.h&quot;
  36 #include &lt;limits&gt;
  37 #include &lt;wtf/Compiler.h&gt;
  38 #include &lt;wtf/DataLog.h&gt;
  39 #include &lt;wtf/Function.h&gt;
  40 #include &lt;wtf/Lock.h&gt;
  41 #include &lt;wtf/NumberOfCores.h&gt;

  42 #include &lt;wtf/Threading.h&gt;

  43 
  44 // We don&#39;t have a NO_RETURN_DUE_TO_EXIT, nor should we. That&#39;s ridiculous.
  45 static bool hiddenTruthBecauseNoReturnIsStupid() { return true; }
  46 
  47 static void usage()
  48 {
  49     dataLog(&quot;Usage: testmasm [&lt;filter&gt;]\n&quot;);
  50     if (hiddenTruthBecauseNoReturnIsStupid())
  51         exit(1);
  52 }
  53 
  54 #if ENABLE(JIT)
  55 
  56 #if ENABLE(MASM_PROBE)
  57 namespace WTF {
  58 
  59 static void printInternal(PrintStream&amp; out, void* value)
  60 {
  61     out.printf(&quot;%p&quot;, value);
  62 }
</pre>
<hr />
<pre>
  91 
  92 #define testWord32(x) (TESTWORD32 + static_cast&lt;uint32_t&gt;(x))
  93 #define testWord64(x) (TESTWORD64 + static_cast&lt;uint64_t&gt;(x))
  94 
  95 #if USE(JSVALUE64)
  96 #define testWord(x) testWord64(x)
  97 #else
  98 #define testWord(x) testWord32(x)
  99 #endif
 100 
 101 // Nothing fancy for now; we just use the existing WTF assertion machinery.
 102 #define CHECK_EQ(_actual, _expected) do {                               \
 103         if ((_actual) == (_expected))                                   \
 104             break;                                                      \
 105         crashLock.lock();                                               \
 106         dataLog(&quot;FAILED while testing &quot; #_actual &quot;: expected: &quot;, _expected, &quot;, actual: &quot;, _actual, &quot;\n&quot;); \
 107         WTFReportAssertionFailure(__FILE__, __LINE__, WTF_PRETTY_FUNCTION, &quot;CHECK_EQ(&quot;#_actual &quot;, &quot; #_expected &quot;)&quot;); \
 108         CRASH();                                                        \
 109     } while (false)
 110 









 111 #if ENABLE(MASM_PROBE)
 112 bool isPC(MacroAssembler::RegisterID id)
 113 {
 114 #if CPU(ARM_THUMB2)
 115     return id == ARMRegisters::pc;
 116 #else
 117     UNUSED_PARAM(id);
 118     return false;
 119 #endif
 120 }
 121 
 122 bool isSP(MacroAssembler::RegisterID id)
 123 {
 124     return id == MacroAssembler::stackPointerRegister;
 125 }
 126 
 127 bool isFP(MacroAssembler::RegisterID id)
 128 {
 129     return id == MacroAssembler::framePointerRegister;
 130 }
</pre>
<hr />
<pre>
 265     };
 266 }
 267 #endif
 268 
 269 static Vector&lt;int32_t&gt; int32Operands()
 270 {
 271     return Vector&lt;int32_t&gt; {
 272         0,
 273         1,
 274         -1,
 275         2,
 276         -2,
 277         42,
 278         -42,
 279         64,
 280         std::numeric_limits&lt;int32_t&gt;::max(),
 281         std::numeric_limits&lt;int32_t&gt;::min(),
 282     };
 283 }
 284 



























































































































































 285 void testCompareDouble(MacroAssembler::DoubleCondition condition)
 286 {
 287     double arg1 = 0;
 288     double arg2 = 0;
 289 
 290     auto compareDouble = compile([&amp;, condition] (CCallHelpers&amp; jit) {
 291         jit.emitFunctionPrologue();
 292 
 293         jit.loadDouble(CCallHelpers::TrustedImmPtr(&amp;arg1), FPRInfo::fpRegT0);
 294         jit.loadDouble(CCallHelpers::TrustedImmPtr(&amp;arg2), FPRInfo::fpRegT1);
 295         jit.move(CCallHelpers::TrustedImm32(-1), GPRInfo::returnValueGPR);
 296         jit.compareDouble(condition, FPRInfo::fpRegT0, FPRInfo::fpRegT1, GPRInfo::returnValueGPR);
 297 
 298         jit.emitFunctionEpilogue();
 299         jit.ret();
 300     });
 301 
 302     auto compareDoubleGeneric = compile([&amp;, condition] (CCallHelpers&amp; jit) {
 303         jit.emitFunctionPrologue();
 304 
</pre>
<hr />
<pre>
 323     }
 324 }
 325 
 326 void testMul32WithImmediates()
 327 {
 328     for (auto immediate : int32Operands()) {
 329         auto mul = compile([=] (CCallHelpers&amp; jit) {
 330             jit.emitFunctionPrologue();
 331 
 332             jit.mul32(CCallHelpers::TrustedImm32(immediate), GPRInfo::argumentGPR0, GPRInfo::returnValueGPR);
 333 
 334             jit.emitFunctionEpilogue();
 335             jit.ret();
 336         });
 337 
 338         for (auto value : int32Operands())
 339             CHECK_EQ(invoke&lt;int&gt;(mul, value), immediate * value);
 340     }
 341 }
 342 



















 343 #if CPU(X86) || CPU(X86_64) || CPU(ARM64)
 344 void testCompareFloat(MacroAssembler::DoubleCondition condition)
 345 {
 346     float arg1 = 0;
 347     float arg2 = 0;
 348 
 349     auto compareFloat = compile([&amp;, condition] (CCallHelpers&amp; jit) {
 350         jit.emitFunctionPrologue();
 351 
 352         jit.loadFloat(CCallHelpers::TrustedImmPtr(&amp;arg1), FPRInfo::fpRegT0);
 353         jit.loadFloat(CCallHelpers::TrustedImmPtr(&amp;arg2), FPRInfo::fpRegT1);
 354         jit.move(CCallHelpers::TrustedImm32(-1), GPRInfo::returnValueGPR);
 355         jit.compareFloat(condition, FPRInfo::fpRegT0, FPRInfo::fpRegT1, GPRInfo::returnValueGPR);
 356 
 357         jit.emitFunctionEpilogue();
 358         jit.ret();
 359     });
 360 
 361     auto compareFloatGeneric = compile([&amp;, condition] (CCallHelpers&amp; jit) {
 362         jit.emitFunctionPrologue();
</pre>
<hr />
<pre>
 917         jit.move(GPRInfo::argumentGPR0, GPRInfo::returnValueGPR);
 918         jit.byteSwap32(GPRInfo::returnValueGPR);
 919         jit.emitFunctionEpilogue();
 920         jit.ret();
 921     });
 922     CHECK_EQ(invoke&lt;uint64_t&gt;(byteSwap32, 0xaabbccddee001122), static_cast&lt;uint64_t&gt;(0x221100ee));
 923     CHECK_EQ(invoke&lt;uint64_t&gt;(byteSwap32, 0xaabbccddee00ffaa), static_cast&lt;uint64_t&gt;(0xaaff00ee));
 924 
 925     auto byteSwap64 = compile([] (CCallHelpers&amp; jit) {
 926         jit.emitFunctionPrologue();
 927         jit.move(GPRInfo::argumentGPR0, GPRInfo::returnValueGPR);
 928         jit.byteSwap64(GPRInfo::returnValueGPR);
 929         jit.emitFunctionEpilogue();
 930         jit.ret();
 931     });
 932     CHECK_EQ(invoke&lt;uint64_t&gt;(byteSwap64, 0xaabbccddee001122), static_cast&lt;uint64_t&gt;(0x221100eeddccbbaa));
 933     CHECK_EQ(invoke&lt;uint64_t&gt;(byteSwap64, 0xaabbccddee00ffaa), static_cast&lt;uint64_t&gt;(0xaaff00eeddccbbaa));
 934 #endif
 935 }
 936 





















































































































 937 #define RUN(test) do {                          \
 938         if (!shouldRun(#test))                  \
 939             break;                              \
 940         numberOfTests++;                        \
 941         tasks.append(                           \
 942             createSharedTask&lt;void()&gt;(           \
 943                 [&amp;] () {                        \
 944                     dataLog(#test &quot;...\n&quot;);     \
 945                     test;                       \
 946                     dataLog(#test &quot;: OK!\n&quot;);   \
 947                 }));                            \
 948     } while (false);
 949 
 950 void run(const char* filter)
 951 {
 952     JSC::initializeThreading();
 953     unsigned numberOfTests = 0;
 954 
 955     Deque&lt;RefPtr&lt;SharedTask&lt;void()&gt;&gt;&gt; tasks;
 956 
 957     auto shouldRun = [&amp;] (const char* testName) -&gt; bool {
<span class="line-modified"> 958 #if OS(UNIX)</span>
<span class="line-removed"> 959         return !filter || !!strcasestr(testName, filter);</span>
<span class="line-removed"> 960 #else</span>
<span class="line-removed"> 961         return !filter || !!strstr(testName, filter);</span>
<span class="line-removed"> 962 #endif</span>
 963     };
 964 
 965     RUN(testSimple());
 966     RUN(testGetEffectiveAddress(0xff00, 42, 8, CCallHelpers::TimesEight));
 967     RUN(testGetEffectiveAddress(0xff00, -200, -300, CCallHelpers::TimesEight));
 968     RUN(testBranchTruncateDoubleToInt32(0, 0));
 969     RUN(testBranchTruncateDoubleToInt32(42, 42));
 970     RUN(testBranchTruncateDoubleToInt32(42.7, 42));
 971     RUN(testBranchTruncateDoubleToInt32(-1234, -1234));
 972     RUN(testBranchTruncateDoubleToInt32(-1234.56, -1234));
 973     RUN(testBranchTruncateDoubleToInt32(std::numeric_limits&lt;double&gt;::infinity(), 0));
 974     RUN(testBranchTruncateDoubleToInt32(-std::numeric_limits&lt;double&gt;::infinity(), 0));
 975     RUN(testBranchTruncateDoubleToInt32(std::numeric_limits&lt;double&gt;::quiet_NaN(), 0));
 976     RUN(testBranchTruncateDoubleToInt32(std::numeric_limits&lt;double&gt;::signaling_NaN(), 0));
 977     RUN(testBranchTruncateDoubleToInt32(std::numeric_limits&lt;double&gt;::max(), 0));
 978     RUN(testBranchTruncateDoubleToInt32(-std::numeric_limits&lt;double&gt;::max(), 0));
 979     // We run this last one to make sure that we don&#39;t use flags that were not
 980     // reset to check a conversion result
 981     RUN(testBranchTruncateDoubleToInt32(123, 123));
 982 
 983     RUN(testCompareDouble(MacroAssembler::DoubleEqual));
 984     RUN(testCompareDouble(MacroAssembler::DoubleNotEqual));
 985     RUN(testCompareDouble(MacroAssembler::DoubleGreaterThan));
 986     RUN(testCompareDouble(MacroAssembler::DoubleGreaterThanOrEqual));
 987     RUN(testCompareDouble(MacroAssembler::DoubleLessThan));
 988     RUN(testCompareDouble(MacroAssembler::DoubleLessThanOrEqual));
 989     RUN(testCompareDouble(MacroAssembler::DoubleEqualOrUnordered));
 990     RUN(testCompareDouble(MacroAssembler::DoubleNotEqualOrUnordered));
 991     RUN(testCompareDouble(MacroAssembler::DoubleGreaterThanOrUnordered));
 992     RUN(testCompareDouble(MacroAssembler::DoubleGreaterThanOrEqualOrUnordered));
 993     RUN(testCompareDouble(MacroAssembler::DoubleLessThanOrUnordered));
 994     RUN(testCompareDouble(MacroAssembler::DoubleLessThanOrEqualOrUnordered));
 995     RUN(testMul32WithImmediates());
 996 













 997 #if CPU(X86) || CPU(X86_64) || CPU(ARM64)
 998     RUN(testCompareFloat(MacroAssembler::DoubleEqual));
 999     RUN(testCompareFloat(MacroAssembler::DoubleNotEqual));
1000     RUN(testCompareFloat(MacroAssembler::DoubleGreaterThan));
1001     RUN(testCompareFloat(MacroAssembler::DoubleGreaterThanOrEqual));
1002     RUN(testCompareFloat(MacroAssembler::DoubleLessThan));
1003     RUN(testCompareFloat(MacroAssembler::DoubleLessThanOrEqual));
1004     RUN(testCompareFloat(MacroAssembler::DoubleEqualOrUnordered));
1005     RUN(testCompareFloat(MacroAssembler::DoubleNotEqualOrUnordered));
1006     RUN(testCompareFloat(MacroAssembler::DoubleGreaterThanOrUnordered));
1007     RUN(testCompareFloat(MacroAssembler::DoubleGreaterThanOrEqualOrUnordered));
1008     RUN(testCompareFloat(MacroAssembler::DoubleLessThanOrUnordered));
1009     RUN(testCompareFloat(MacroAssembler::DoubleLessThanOrEqualOrUnordered));
1010 #endif
1011 
1012 #if ENABLE(MASM_PROBE)
1013     RUN(testProbeReadsArgumentRegisters());
1014     RUN(testProbeWritesArgumentRegisters());
1015     RUN(testProbePreservesGPRS());
1016     RUN(testProbeModifiesStackPointerToInsideProbeStateOnStack());
1017     RUN(testProbeModifiesStackPointerToNBytesBelowSP());
1018     RUN(testProbeModifiesProgramCounter());
1019     RUN(testProbeModifiesStackValues());
1020 #endif // ENABLE(MASM_PROBE)
1021 
1022     RUN(testByteSwap());




1023 
1024     if (tasks.isEmpty())
1025         usage();
1026 
1027     Lock lock;
1028 
1029     Vector&lt;Ref&lt;Thread&gt;&gt; threads;
1030     for (unsigned i = filter ? 1 : WTF::numberOfProcessorCores(); i--;) {
1031         threads.append(
1032             Thread::create(
1033                 &quot;testmasm thread&quot;,
1034                 [&amp;] () {
1035                     for (;;) {
1036                         RefPtr&lt;SharedTask&lt;void()&gt;&gt; task;
1037                         {
1038                             LockHolder locker(lock);
1039                             if (tasks.isEmpty())
1040                                 return;
1041                             task = tasks.takeFirst();
1042                         }
</pre>
</td>
<td>
<hr />
<pre>
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 
  28 #include &quot;CCallHelpers.h&quot;
  29 #include &quot;CPU.h&quot;
  30 #include &quot;FPRInfo.h&quot;
  31 #include &quot;GPRInfo.h&quot;
  32 #include &quot;InitializeThreading.h&quot;
  33 #include &quot;LinkBuffer.h&quot;
  34 #include &quot;ProbeContext.h&quot;
  35 #include &quot;StackAlignment.h&quot;
  36 #include &lt;limits&gt;
  37 #include &lt;wtf/Compiler.h&gt;
  38 #include &lt;wtf/DataLog.h&gt;
  39 #include &lt;wtf/Function.h&gt;
  40 #include &lt;wtf/Lock.h&gt;
  41 #include &lt;wtf/NumberOfCores.h&gt;
<span class="line-added">  42 #include &lt;wtf/PtrTag.h&gt;</span>
  43 #include &lt;wtf/Threading.h&gt;
<span class="line-added">  44 #include &lt;wtf/text/StringCommon.h&gt;</span>
  45 
  46 // We don&#39;t have a NO_RETURN_DUE_TO_EXIT, nor should we. That&#39;s ridiculous.
  47 static bool hiddenTruthBecauseNoReturnIsStupid() { return true; }
  48 
  49 static void usage()
  50 {
  51     dataLog(&quot;Usage: testmasm [&lt;filter&gt;]\n&quot;);
  52     if (hiddenTruthBecauseNoReturnIsStupid())
  53         exit(1);
  54 }
  55 
  56 #if ENABLE(JIT)
  57 
  58 #if ENABLE(MASM_PROBE)
  59 namespace WTF {
  60 
  61 static void printInternal(PrintStream&amp; out, void* value)
  62 {
  63     out.printf(&quot;%p&quot;, value);
  64 }
</pre>
<hr />
<pre>
  93 
  94 #define testWord32(x) (TESTWORD32 + static_cast&lt;uint32_t&gt;(x))
  95 #define testWord64(x) (TESTWORD64 + static_cast&lt;uint64_t&gt;(x))
  96 
  97 #if USE(JSVALUE64)
  98 #define testWord(x) testWord64(x)
  99 #else
 100 #define testWord(x) testWord32(x)
 101 #endif
 102 
 103 // Nothing fancy for now; we just use the existing WTF assertion machinery.
 104 #define CHECK_EQ(_actual, _expected) do {                               \
 105         if ((_actual) == (_expected))                                   \
 106             break;                                                      \
 107         crashLock.lock();                                               \
 108         dataLog(&quot;FAILED while testing &quot; #_actual &quot;: expected: &quot;, _expected, &quot;, actual: &quot;, _actual, &quot;\n&quot;); \
 109         WTFReportAssertionFailure(__FILE__, __LINE__, WTF_PRETTY_FUNCTION, &quot;CHECK_EQ(&quot;#_actual &quot;, &quot; #_expected &quot;)&quot;); \
 110         CRASH();                                                        \
 111     } while (false)
 112 
<span class="line-added"> 113 #define CHECK_NOT_EQ(_actual, _expected) do {                               \</span>
<span class="line-added"> 114         if ((_actual) != (_expected))                                   \</span>
<span class="line-added"> 115             break;                                                      \</span>
<span class="line-added"> 116         crashLock.lock();                                               \</span>
<span class="line-added"> 117         dataLog(&quot;FAILED while testing &quot; #_actual &quot;: expected not: &quot;, _expected, &quot;, actual: &quot;, _actual, &quot;\n&quot;); \</span>
<span class="line-added"> 118         WTFReportAssertionFailure(__FILE__, __LINE__, WTF_PRETTY_FUNCTION, &quot;CHECK_NOT_EQ(&quot;#_actual &quot;, &quot; #_expected &quot;)&quot;); \</span>
<span class="line-added"> 119         CRASH();                                                        \</span>
<span class="line-added"> 120     } while (false)</span>
<span class="line-added"> 121 </span>
 122 #if ENABLE(MASM_PROBE)
 123 bool isPC(MacroAssembler::RegisterID id)
 124 {
 125 #if CPU(ARM_THUMB2)
 126     return id == ARMRegisters::pc;
 127 #else
 128     UNUSED_PARAM(id);
 129     return false;
 130 #endif
 131 }
 132 
 133 bool isSP(MacroAssembler::RegisterID id)
 134 {
 135     return id == MacroAssembler::stackPointerRegister;
 136 }
 137 
 138 bool isFP(MacroAssembler::RegisterID id)
 139 {
 140     return id == MacroAssembler::framePointerRegister;
 141 }
</pre>
<hr />
<pre>
 276     };
 277 }
 278 #endif
 279 
 280 static Vector&lt;int32_t&gt; int32Operands()
 281 {
 282     return Vector&lt;int32_t&gt; {
 283         0,
 284         1,
 285         -1,
 286         2,
 287         -2,
 288         42,
 289         -42,
 290         64,
 291         std::numeric_limits&lt;int32_t&gt;::max(),
 292         std::numeric_limits&lt;int32_t&gt;::min(),
 293     };
 294 }
 295 
<span class="line-added"> 296 #if CPU(X86_64)</span>
<span class="line-added"> 297 static Vector&lt;int64_t&gt; int64Operands()</span>
<span class="line-added"> 298 {</span>
<span class="line-added"> 299     return Vector&lt;int64_t&gt; {</span>
<span class="line-added"> 300         0,</span>
<span class="line-added"> 301         1,</span>
<span class="line-added"> 302         -1,</span>
<span class="line-added"> 303         2,</span>
<span class="line-added"> 304         -2,</span>
<span class="line-added"> 305         42,</span>
<span class="line-added"> 306         -42,</span>
<span class="line-added"> 307         64,</span>
<span class="line-added"> 308         std::numeric_limits&lt;int32_t&gt;::max(),</span>
<span class="line-added"> 309         std::numeric_limits&lt;int32_t&gt;::min(),</span>
<span class="line-added"> 310         std::numeric_limits&lt;int64_t&gt;::max(),</span>
<span class="line-added"> 311         std::numeric_limits&lt;int64_t&gt;::min(),</span>
<span class="line-added"> 312     };</span>
<span class="line-added"> 313 }</span>
<span class="line-added"> 314 #endif</span>
<span class="line-added"> 315 </span>
<span class="line-added"> 316 #if CPU(X86_64)</span>
<span class="line-added"> 317 void testBranchTestBit32RegReg()</span>
<span class="line-added"> 318 {</span>
<span class="line-added"> 319     for (uint32_t value : int32Operands()) {</span>
<span class="line-added"> 320         auto test = compile([=] (CCallHelpers&amp; jit) {</span>
<span class="line-added"> 321             jit.emitFunctionPrologue();</span>
<span class="line-added"> 322 </span>
<span class="line-added"> 323             auto branch = jit.branchTestBit32(MacroAssembler::NonZero, GPRInfo::argumentGPR0, GPRInfo::argumentGPR1);</span>
<span class="line-added"> 324             jit.move(CCallHelpers::TrustedImm32(0), GPRInfo::returnValueGPR);</span>
<span class="line-added"> 325             auto done = jit.jump();</span>
<span class="line-added"> 326             branch.link(&amp;jit);</span>
<span class="line-added"> 327             jit.move(CCallHelpers::TrustedImm32(1), GPRInfo::returnValueGPR);</span>
<span class="line-added"> 328             done.link(&amp;jit);</span>
<span class="line-added"> 329 </span>
<span class="line-added"> 330             jit.emitFunctionEpilogue();</span>
<span class="line-added"> 331             jit.ret();</span>
<span class="line-added"> 332         });</span>
<span class="line-added"> 333 </span>
<span class="line-added"> 334         for (uint32_t value2 : int32Operands())</span>
<span class="line-added"> 335             CHECK_EQ(invoke&lt;int&gt;(test, value, value2), (value&gt;&gt;(value2%32))&amp;1);</span>
<span class="line-added"> 336     }</span>
<span class="line-added"> 337 }</span>
<span class="line-added"> 338 </span>
<span class="line-added"> 339 void testBranchTestBit32RegImm()</span>
<span class="line-added"> 340 {</span>
<span class="line-added"> 341     for (uint32_t value : int32Operands()) {</span>
<span class="line-added"> 342         auto test = compile([=] (CCallHelpers&amp; jit) {</span>
<span class="line-added"> 343             jit.emitFunctionPrologue();</span>
<span class="line-added"> 344 </span>
<span class="line-added"> 345             auto branch = jit.branchTestBit32(MacroAssembler::NonZero, GPRInfo::argumentGPR0, CCallHelpers::TrustedImm32(value));</span>
<span class="line-added"> 346             jit.move(CCallHelpers::TrustedImm32(0), GPRInfo::returnValueGPR);</span>
<span class="line-added"> 347             auto done = jit.jump();</span>
<span class="line-added"> 348             branch.link(&amp;jit);</span>
<span class="line-added"> 349             jit.move(CCallHelpers::TrustedImm32(1), GPRInfo::returnValueGPR);</span>
<span class="line-added"> 350             done.link(&amp;jit);</span>
<span class="line-added"> 351 </span>
<span class="line-added"> 352             jit.emitFunctionEpilogue();</span>
<span class="line-added"> 353             jit.ret();</span>
<span class="line-added"> 354         });</span>
<span class="line-added"> 355 </span>
<span class="line-added"> 356         for (uint32_t value2 : int32Operands())</span>
<span class="line-added"> 357             CHECK_EQ(invoke&lt;int&gt;(test, value2), (value2&gt;&gt;(value%32))&amp;1);</span>
<span class="line-added"> 358     }</span>
<span class="line-added"> 359 }</span>
<span class="line-added"> 360 </span>
<span class="line-added"> 361 void testBranchTestBit32AddrImm()</span>
<span class="line-added"> 362 {</span>
<span class="line-added"> 363     for (uint32_t value : int32Operands()) {</span>
<span class="line-added"> 364         auto test = compile([=] (CCallHelpers&amp; jit) {</span>
<span class="line-added"> 365             jit.emitFunctionPrologue();</span>
<span class="line-added"> 366 </span>
<span class="line-added"> 367             auto branch = jit.branchTestBit32(MacroAssembler::NonZero, MacroAssembler::Address(GPRInfo::argumentGPR0, 0), CCallHelpers::TrustedImm32(value));</span>
<span class="line-added"> 368             jit.move(CCallHelpers::TrustedImm32(0), GPRInfo::returnValueGPR);</span>
<span class="line-added"> 369             auto done = jit.jump();</span>
<span class="line-added"> 370             branch.link(&amp;jit);</span>
<span class="line-added"> 371             jit.move(CCallHelpers::TrustedImm32(1), GPRInfo::returnValueGPR);</span>
<span class="line-added"> 372             done.link(&amp;jit);</span>
<span class="line-added"> 373 </span>
<span class="line-added"> 374             jit.emitFunctionEpilogue();</span>
<span class="line-added"> 375             jit.ret();</span>
<span class="line-added"> 376         });</span>
<span class="line-added"> 377 </span>
<span class="line-added"> 378         for (uint32_t value2 : int32Operands())</span>
<span class="line-added"> 379             CHECK_EQ(invoke&lt;int&gt;(test, &amp;value2), (value2&gt;&gt;(value%32))&amp;1);</span>
<span class="line-added"> 380     }</span>
<span class="line-added"> 381 }</span>
<span class="line-added"> 382 </span>
<span class="line-added"> 383 void testBranchTestBit64RegReg()</span>
<span class="line-added"> 384 {</span>
<span class="line-added"> 385     for (uint64_t value : int64Operands()) {</span>
<span class="line-added"> 386         auto test = compile([=] (CCallHelpers&amp; jit) {</span>
<span class="line-added"> 387             jit.emitFunctionPrologue();</span>
<span class="line-added"> 388 </span>
<span class="line-added"> 389             auto branch = jit.branchTestBit64(MacroAssembler::NonZero, GPRInfo::argumentGPR0, GPRInfo::argumentGPR1);</span>
<span class="line-added"> 390             jit.move(CCallHelpers::TrustedImm64(0), GPRInfo::returnValueGPR);</span>
<span class="line-added"> 391             auto done = jit.jump();</span>
<span class="line-added"> 392             branch.link(&amp;jit);</span>
<span class="line-added"> 393             jit.move(CCallHelpers::TrustedImm64(1), GPRInfo::returnValueGPR);</span>
<span class="line-added"> 394             done.link(&amp;jit);</span>
<span class="line-added"> 395 </span>
<span class="line-added"> 396             jit.emitFunctionEpilogue();</span>
<span class="line-added"> 397             jit.ret();</span>
<span class="line-added"> 398         });</span>
<span class="line-added"> 399 </span>
<span class="line-added"> 400         for (uint64_t value2 : int64Operands())</span>
<span class="line-added"> 401             CHECK_EQ(invoke&lt;long int&gt;(test, value, value2), (value&gt;&gt;(value2%64))&amp;1);</span>
<span class="line-added"> 402     }</span>
<span class="line-added"> 403 }</span>
<span class="line-added"> 404 </span>
<span class="line-added"> 405 void testBranchTestBit64RegImm()</span>
<span class="line-added"> 406 {</span>
<span class="line-added"> 407     for (uint64_t value : int64Operands()) {</span>
<span class="line-added"> 408         auto test = compile([=] (CCallHelpers&amp; jit) {</span>
<span class="line-added"> 409             jit.emitFunctionPrologue();</span>
<span class="line-added"> 410 </span>
<span class="line-added"> 411             auto branch = jit.branchTestBit64(MacroAssembler::NonZero, GPRInfo::argumentGPR0, CCallHelpers::TrustedImm32(value));</span>
<span class="line-added"> 412             jit.move(CCallHelpers::TrustedImm64(0), GPRInfo::returnValueGPR);</span>
<span class="line-added"> 413             auto done = jit.jump();</span>
<span class="line-added"> 414             branch.link(&amp;jit);</span>
<span class="line-added"> 415             jit.move(CCallHelpers::TrustedImm64(1), GPRInfo::returnValueGPR);</span>
<span class="line-added"> 416             done.link(&amp;jit);</span>
<span class="line-added"> 417 </span>
<span class="line-added"> 418             jit.emitFunctionEpilogue();</span>
<span class="line-added"> 419             jit.ret();</span>
<span class="line-added"> 420         });</span>
<span class="line-added"> 421 </span>
<span class="line-added"> 422         for (uint64_t value2 : int64Operands())</span>
<span class="line-added"> 423             CHECK_EQ(invoke&lt;long int&gt;(test, value2), (value2&gt;&gt;(value%64))&amp;1);</span>
<span class="line-added"> 424     }</span>
<span class="line-added"> 425 }</span>
<span class="line-added"> 426 </span>
<span class="line-added"> 427 void testBranchTestBit64AddrImm()</span>
<span class="line-added"> 428 {</span>
<span class="line-added"> 429     for (uint64_t value : int64Operands()) {</span>
<span class="line-added"> 430         auto test = compile([=] (CCallHelpers&amp; jit) {</span>
<span class="line-added"> 431             jit.emitFunctionPrologue();</span>
<span class="line-added"> 432 </span>
<span class="line-added"> 433             auto branch = jit.branchTestBit64(MacroAssembler::NonZero, MacroAssembler::Address(GPRInfo::argumentGPR0, 0), CCallHelpers::TrustedImm32(value));</span>
<span class="line-added"> 434             jit.move(CCallHelpers::TrustedImm64(0), GPRInfo::returnValueGPR);</span>
<span class="line-added"> 435             auto done = jit.jump();</span>
<span class="line-added"> 436             branch.link(&amp;jit);</span>
<span class="line-added"> 437             jit.move(CCallHelpers::TrustedImm64(1), GPRInfo::returnValueGPR);</span>
<span class="line-added"> 438             done.link(&amp;jit);</span>
<span class="line-added"> 439 </span>
<span class="line-added"> 440             jit.emitFunctionEpilogue();</span>
<span class="line-added"> 441             jit.ret();</span>
<span class="line-added"> 442         });</span>
<span class="line-added"> 443 </span>
<span class="line-added"> 444         for (uint64_t value2 : int64Operands())</span>
<span class="line-added"> 445             CHECK_EQ(invoke&lt;long int&gt;(test, &amp;value2), (value2&gt;&gt;(value%64))&amp;1);</span>
<span class="line-added"> 446     }</span>
<span class="line-added"> 447 }</span>
<span class="line-added"> 448 </span>
<span class="line-added"> 449 #endif</span>
<span class="line-added"> 450 </span>
 451 void testCompareDouble(MacroAssembler::DoubleCondition condition)
 452 {
 453     double arg1 = 0;
 454     double arg2 = 0;
 455 
 456     auto compareDouble = compile([&amp;, condition] (CCallHelpers&amp; jit) {
 457         jit.emitFunctionPrologue();
 458 
 459         jit.loadDouble(CCallHelpers::TrustedImmPtr(&amp;arg1), FPRInfo::fpRegT0);
 460         jit.loadDouble(CCallHelpers::TrustedImmPtr(&amp;arg2), FPRInfo::fpRegT1);
 461         jit.move(CCallHelpers::TrustedImm32(-1), GPRInfo::returnValueGPR);
 462         jit.compareDouble(condition, FPRInfo::fpRegT0, FPRInfo::fpRegT1, GPRInfo::returnValueGPR);
 463 
 464         jit.emitFunctionEpilogue();
 465         jit.ret();
 466     });
 467 
 468     auto compareDoubleGeneric = compile([&amp;, condition] (CCallHelpers&amp; jit) {
 469         jit.emitFunctionPrologue();
 470 
</pre>
<hr />
<pre>
 489     }
 490 }
 491 
 492 void testMul32WithImmediates()
 493 {
 494     for (auto immediate : int32Operands()) {
 495         auto mul = compile([=] (CCallHelpers&amp; jit) {
 496             jit.emitFunctionPrologue();
 497 
 498             jit.mul32(CCallHelpers::TrustedImm32(immediate), GPRInfo::argumentGPR0, GPRInfo::returnValueGPR);
 499 
 500             jit.emitFunctionEpilogue();
 501             jit.ret();
 502         });
 503 
 504         for (auto value : int32Operands())
 505             CHECK_EQ(invoke&lt;int&gt;(mul, value), immediate * value);
 506     }
 507 }
 508 
<span class="line-added"> 509 #if CPU(ARM64)</span>
<span class="line-added"> 510 void testMul32SignExtend()</span>
<span class="line-added"> 511 {</span>
<span class="line-added"> 512     for (auto value : int32Operands()) {</span>
<span class="line-added"> 513         auto mul = compile([=] (CCallHelpers&amp; jit) {</span>
<span class="line-added"> 514             jit.emitFunctionPrologue();</span>
<span class="line-added"> 515 </span>
<span class="line-added"> 516             jit.multiplySignExtend32(GPRInfo::argumentGPR0, GPRInfo::argumentGPR1, GPRInfo::returnValueGPR);</span>
<span class="line-added"> 517 </span>
<span class="line-added"> 518             jit.emitFunctionEpilogue();</span>
<span class="line-added"> 519             jit.ret();</span>
<span class="line-added"> 520         });</span>
<span class="line-added"> 521 </span>
<span class="line-added"> 522         for (auto value2 : int32Operands())</span>
<span class="line-added"> 523             CHECK_EQ(invoke&lt;long int&gt;(mul, value, value2), ((long int) value) * ((long int) value2));</span>
<span class="line-added"> 524     }</span>
<span class="line-added"> 525 }</span>
<span class="line-added"> 526 #endif</span>
<span class="line-added"> 527 </span>
 528 #if CPU(X86) || CPU(X86_64) || CPU(ARM64)
 529 void testCompareFloat(MacroAssembler::DoubleCondition condition)
 530 {
 531     float arg1 = 0;
 532     float arg2 = 0;
 533 
 534     auto compareFloat = compile([&amp;, condition] (CCallHelpers&amp; jit) {
 535         jit.emitFunctionPrologue();
 536 
 537         jit.loadFloat(CCallHelpers::TrustedImmPtr(&amp;arg1), FPRInfo::fpRegT0);
 538         jit.loadFloat(CCallHelpers::TrustedImmPtr(&amp;arg2), FPRInfo::fpRegT1);
 539         jit.move(CCallHelpers::TrustedImm32(-1), GPRInfo::returnValueGPR);
 540         jit.compareFloat(condition, FPRInfo::fpRegT0, FPRInfo::fpRegT1, GPRInfo::returnValueGPR);
 541 
 542         jit.emitFunctionEpilogue();
 543         jit.ret();
 544     });
 545 
 546     auto compareFloatGeneric = compile([&amp;, condition] (CCallHelpers&amp; jit) {
 547         jit.emitFunctionPrologue();
</pre>
<hr />
<pre>
1102         jit.move(GPRInfo::argumentGPR0, GPRInfo::returnValueGPR);
1103         jit.byteSwap32(GPRInfo::returnValueGPR);
1104         jit.emitFunctionEpilogue();
1105         jit.ret();
1106     });
1107     CHECK_EQ(invoke&lt;uint64_t&gt;(byteSwap32, 0xaabbccddee001122), static_cast&lt;uint64_t&gt;(0x221100ee));
1108     CHECK_EQ(invoke&lt;uint64_t&gt;(byteSwap32, 0xaabbccddee00ffaa), static_cast&lt;uint64_t&gt;(0xaaff00ee));
1109 
1110     auto byteSwap64 = compile([] (CCallHelpers&amp; jit) {
1111         jit.emitFunctionPrologue();
1112         jit.move(GPRInfo::argumentGPR0, GPRInfo::returnValueGPR);
1113         jit.byteSwap64(GPRInfo::returnValueGPR);
1114         jit.emitFunctionEpilogue();
1115         jit.ret();
1116     });
1117     CHECK_EQ(invoke&lt;uint64_t&gt;(byteSwap64, 0xaabbccddee001122), static_cast&lt;uint64_t&gt;(0x221100eeddccbbaa));
1118     CHECK_EQ(invoke&lt;uint64_t&gt;(byteSwap64, 0xaabbccddee00ffaa), static_cast&lt;uint64_t&gt;(0xaaff00eeddccbbaa));
1119 #endif
1120 }
1121 
<span class="line-added">1122 void testMoveDoubleConditionally32()</span>
<span class="line-added">1123 {</span>
<span class="line-added">1124 #if CPU(X86_64) | CPU(ARM64)</span>
<span class="line-added">1125     double arg1 = 0;</span>
<span class="line-added">1126     double arg2 = 0;</span>
<span class="line-added">1127     const double zero = -0;</span>
<span class="line-added">1128 </span>
<span class="line-added">1129     const double chosenDouble = 6.00000059604644775390625;</span>
<span class="line-added">1130     CHECK_EQ(static_cast&lt;double&gt;(static_cast&lt;float&gt;(chosenDouble)) == chosenDouble, false);</span>
<span class="line-added">1131 </span>
<span class="line-added">1132     auto sel = compile([&amp;] (CCallHelpers&amp; jit) {</span>
<span class="line-added">1133         jit.emitFunctionPrologue();</span>
<span class="line-added">1134         jit.loadDouble(CCallHelpers::TrustedImmPtr(&amp;zero), FPRInfo::returnValueFPR);</span>
<span class="line-added">1135         jit.loadDouble(CCallHelpers::TrustedImmPtr(&amp;arg1), FPRInfo::fpRegT1);</span>
<span class="line-added">1136         jit.loadDouble(CCallHelpers::TrustedImmPtr(&amp;arg2), FPRInfo::fpRegT2);</span>
<span class="line-added">1137 </span>
<span class="line-added">1138         jit.move(MacroAssembler::TrustedImm32(-1), GPRInfo::regT0);</span>
<span class="line-added">1139         jit.moveDoubleConditionally32(MacroAssembler::Equal, GPRInfo::regT0, GPRInfo::regT0, FPRInfo::fpRegT1, FPRInfo::fpRegT2, FPRInfo::returnValueFPR);</span>
<span class="line-added">1140 </span>
<span class="line-added">1141         jit.emitFunctionEpilogue();</span>
<span class="line-added">1142         jit.ret();</span>
<span class="line-added">1143     });</span>
<span class="line-added">1144 </span>
<span class="line-added">1145     arg1 = chosenDouble;</span>
<span class="line-added">1146     arg2 = 43;</span>
<span class="line-added">1147     CHECK_EQ(invoke&lt;double&gt;(sel), chosenDouble);</span>
<span class="line-added">1148 </span>
<span class="line-added">1149     arg1 = 43;</span>
<span class="line-added">1150     arg2 = chosenDouble;</span>
<span class="line-added">1151     CHECK_EQ(invoke&lt;double&gt;(sel), 43.0);</span>
<span class="line-added">1152 </span>
<span class="line-added">1153 #endif</span>
<span class="line-added">1154 }</span>
<span class="line-added">1155 </span>
<span class="line-added">1156 void testMoveDoubleConditionally64()</span>
<span class="line-added">1157 {</span>
<span class="line-added">1158 #if CPU(X86_64) | CPU(ARM64)</span>
<span class="line-added">1159     double arg1 = 0;</span>
<span class="line-added">1160     double arg2 = 0;</span>
<span class="line-added">1161     const double zero = -0;</span>
<span class="line-added">1162 </span>
<span class="line-added">1163     const double chosenDouble = 6.00000059604644775390625;</span>
<span class="line-added">1164     CHECK_EQ(static_cast&lt;double&gt;(static_cast&lt;float&gt;(chosenDouble)) == chosenDouble, false);</span>
<span class="line-added">1165 </span>
<span class="line-added">1166     auto sel = compile([&amp;] (CCallHelpers&amp; jit) {</span>
<span class="line-added">1167         jit.emitFunctionPrologue();</span>
<span class="line-added">1168         jit.loadDouble(CCallHelpers::TrustedImmPtr(&amp;zero), FPRInfo::returnValueFPR);</span>
<span class="line-added">1169         jit.loadDouble(CCallHelpers::TrustedImmPtr(&amp;arg1), FPRInfo::fpRegT1);</span>
<span class="line-added">1170         jit.loadDouble(CCallHelpers::TrustedImmPtr(&amp;arg2), FPRInfo::fpRegT2);</span>
<span class="line-added">1171 </span>
<span class="line-added">1172         jit.move(MacroAssembler::TrustedImm64(-1), GPRInfo::regT0);</span>
<span class="line-added">1173         jit.moveDoubleConditionally64(MacroAssembler::Equal, GPRInfo::regT0, GPRInfo::regT0, FPRInfo::fpRegT1, FPRInfo::fpRegT2, FPRInfo::returnValueFPR);</span>
<span class="line-added">1174 </span>
<span class="line-added">1175         jit.emitFunctionEpilogue();</span>
<span class="line-added">1176         jit.ret();</span>
<span class="line-added">1177     });</span>
<span class="line-added">1178 </span>
<span class="line-added">1179     arg1 = chosenDouble;</span>
<span class="line-added">1180     arg2 = 43;</span>
<span class="line-added">1181     CHECK_EQ(invoke&lt;double&gt;(sel), chosenDouble);</span>
<span class="line-added">1182 </span>
<span class="line-added">1183     arg1 = 43;</span>
<span class="line-added">1184     arg2 = chosenDouble;</span>
<span class="line-added">1185     CHECK_EQ(invoke&lt;double&gt;(sel), 43.0);</span>
<span class="line-added">1186 </span>
<span class="line-added">1187 #endif</span>
<span class="line-added">1188 }</span>
<span class="line-added">1189 </span>
<span class="line-added">1190 static void testCagePreservesPACFailureBit()</span>
<span class="line-added">1191 {</span>
<span class="line-added">1192 #if GIGACAGE_ENABLED</span>
<span class="line-added">1193     ASSERT(!Gigacage::isDisablingPrimitiveGigacageDisabled());</span>
<span class="line-added">1194     auto cage = compile([] (CCallHelpers&amp; jit) {</span>
<span class="line-added">1195         jit.emitFunctionPrologue();</span>
<span class="line-added">1196         jit.cageConditionally(Gigacage::Primitive, GPRInfo::argumentGPR0, GPRInfo::argumentGPR1, GPRInfo::argumentGPR2);</span>
<span class="line-added">1197         jit.move(GPRInfo::argumentGPR0, GPRInfo::returnValueGPR);</span>
<span class="line-added">1198         jit.emitFunctionEpilogue();</span>
<span class="line-added">1199         jit.ret();</span>
<span class="line-added">1200     });</span>
<span class="line-added">1201 </span>
<span class="line-added">1202     void* ptr = Gigacage::tryMalloc(Gigacage::Primitive, 1);</span>
<span class="line-added">1203     void* taggedPtr = tagArrayPtr(ptr, 1);</span>
<span class="line-added">1204     ASSERT(hasOneBitSet(Gigacage::size(Gigacage::Primitive) &lt;&lt; 2));</span>
<span class="line-added">1205     void* notCagedPtr = reinterpret_cast&lt;void*&gt;(reinterpret_cast&lt;uintptr_t&gt;(ptr) + (Gigacage::size(Gigacage::Primitive) &lt;&lt; 2));</span>
<span class="line-added">1206     CHECK_NOT_EQ(Gigacage::caged(Gigacage::Primitive, notCagedPtr), notCagedPtr);</span>
<span class="line-added">1207     void* taggedNotCagedPtr = tagArrayPtr(notCagedPtr, 1);</span>
<span class="line-added">1208 </span>
<span class="line-added">1209     if (isARM64E()) {</span>
<span class="line-added">1210         // FIXME: This won&#39;t work if authentication failures trap but I don&#39;t know how to test for that right now.</span>
<span class="line-added">1211         CHECK_NOT_EQ(invoke&lt;void*&gt;(cage, taggedPtr, 2), ptr);</span>
<span class="line-added">1212         CHECK_EQ(invoke&lt;void*&gt;(cage, taggedNotCagedPtr, 1), untagArrayPtr(taggedPtr, 2));</span>
<span class="line-added">1213     } else</span>
<span class="line-added">1214         CHECK_EQ(invoke&lt;void*&gt;(cage, taggedPtr, 2), ptr);</span>
<span class="line-added">1215 </span>
<span class="line-added">1216     CHECK_EQ(invoke&lt;void*&gt;(cage, taggedPtr, 1), ptr);</span>
<span class="line-added">1217 </span>
<span class="line-added">1218     auto cageWithoutAuthentication = compile([] (CCallHelpers&amp; jit) {</span>
<span class="line-added">1219         jit.emitFunctionPrologue();</span>
<span class="line-added">1220         jit.cageWithoutUntagging(Gigacage::Primitive, GPRInfo::argumentGPR0);</span>
<span class="line-added">1221         jit.move(GPRInfo::argumentGPR0, GPRInfo::returnValueGPR);</span>
<span class="line-added">1222         jit.emitFunctionEpilogue();</span>
<span class="line-added">1223         jit.ret();</span>
<span class="line-added">1224     });</span>
<span class="line-added">1225 </span>
<span class="line-added">1226     CHECK_EQ(invoke&lt;void*&gt;(cageWithoutAuthentication, taggedPtr), taggedPtr);</span>
<span class="line-added">1227     if (isARM64E()) {</span>
<span class="line-added">1228         // FIXME: This won&#39;t work if authentication failures trap but I don&#39;t know how to test for that right now.</span>
<span class="line-added">1229         CHECK_NOT_EQ(invoke&lt;void*&gt;(cageWithoutAuthentication, taggedNotCagedPtr), taggedNotCagedPtr);</span>
<span class="line-added">1230         CHECK_NOT_EQ(untagArrayPtr(invoke&lt;void*&gt;(cageWithoutAuthentication, taggedNotCagedPtr), 1), notCagedPtr);</span>
<span class="line-added">1231         CHECK_NOT_EQ(invoke&lt;void*&gt;(cageWithoutAuthentication, taggedNotCagedPtr), taggedPtr);</span>
<span class="line-added">1232         CHECK_NOT_EQ(untagArrayPtr(invoke&lt;void*&gt;(cageWithoutAuthentication, taggedNotCagedPtr), 1), ptr);</span>
<span class="line-added">1233     }</span>
<span class="line-added">1234 </span>
<span class="line-added">1235     Gigacage::free(Gigacage::Primitive, ptr);</span>
<span class="line-added">1236 #endif</span>
<span class="line-added">1237 }</span>
<span class="line-added">1238 </span>
1239 #define RUN(test) do {                          \
1240         if (!shouldRun(#test))                  \
1241             break;                              \
1242         numberOfTests++;                        \
1243         tasks.append(                           \
1244             createSharedTask&lt;void()&gt;(           \
1245                 [&amp;] () {                        \
1246                     dataLog(#test &quot;...\n&quot;);     \
1247                     test;                       \
1248                     dataLog(#test &quot;: OK!\n&quot;);   \
1249                 }));                            \
1250     } while (false);
1251 
1252 void run(const char* filter)
1253 {
1254     JSC::initializeThreading();
1255     unsigned numberOfTests = 0;
1256 
1257     Deque&lt;RefPtr&lt;SharedTask&lt;void()&gt;&gt;&gt; tasks;
1258 
1259     auto shouldRun = [&amp;] (const char* testName) -&gt; bool {
<span class="line-modified">1260         return !filter || WTF::findIgnoringASCIICaseWithoutLength(testName, filter) != WTF::notFound;</span>




1261     };
1262 
1263     RUN(testSimple());
1264     RUN(testGetEffectiveAddress(0xff00, 42, 8, CCallHelpers::TimesEight));
1265     RUN(testGetEffectiveAddress(0xff00, -200, -300, CCallHelpers::TimesEight));
1266     RUN(testBranchTruncateDoubleToInt32(0, 0));
1267     RUN(testBranchTruncateDoubleToInt32(42, 42));
1268     RUN(testBranchTruncateDoubleToInt32(42.7, 42));
1269     RUN(testBranchTruncateDoubleToInt32(-1234, -1234));
1270     RUN(testBranchTruncateDoubleToInt32(-1234.56, -1234));
1271     RUN(testBranchTruncateDoubleToInt32(std::numeric_limits&lt;double&gt;::infinity(), 0));
1272     RUN(testBranchTruncateDoubleToInt32(-std::numeric_limits&lt;double&gt;::infinity(), 0));
1273     RUN(testBranchTruncateDoubleToInt32(std::numeric_limits&lt;double&gt;::quiet_NaN(), 0));
1274     RUN(testBranchTruncateDoubleToInt32(std::numeric_limits&lt;double&gt;::signaling_NaN(), 0));
1275     RUN(testBranchTruncateDoubleToInt32(std::numeric_limits&lt;double&gt;::max(), 0));
1276     RUN(testBranchTruncateDoubleToInt32(-std::numeric_limits&lt;double&gt;::max(), 0));
1277     // We run this last one to make sure that we don&#39;t use flags that were not
1278     // reset to check a conversion result
1279     RUN(testBranchTruncateDoubleToInt32(123, 123));
1280 
1281     RUN(testCompareDouble(MacroAssembler::DoubleEqual));
1282     RUN(testCompareDouble(MacroAssembler::DoubleNotEqual));
1283     RUN(testCompareDouble(MacroAssembler::DoubleGreaterThan));
1284     RUN(testCompareDouble(MacroAssembler::DoubleGreaterThanOrEqual));
1285     RUN(testCompareDouble(MacroAssembler::DoubleLessThan));
1286     RUN(testCompareDouble(MacroAssembler::DoubleLessThanOrEqual));
1287     RUN(testCompareDouble(MacroAssembler::DoubleEqualOrUnordered));
1288     RUN(testCompareDouble(MacroAssembler::DoubleNotEqualOrUnordered));
1289     RUN(testCompareDouble(MacroAssembler::DoubleGreaterThanOrUnordered));
1290     RUN(testCompareDouble(MacroAssembler::DoubleGreaterThanOrEqualOrUnordered));
1291     RUN(testCompareDouble(MacroAssembler::DoubleLessThanOrUnordered));
1292     RUN(testCompareDouble(MacroAssembler::DoubleLessThanOrEqualOrUnordered));
1293     RUN(testMul32WithImmediates());
1294 
<span class="line-added">1295 #if CPU(X86_64)</span>
<span class="line-added">1296     RUN(testBranchTestBit32RegReg());</span>
<span class="line-added">1297     RUN(testBranchTestBit32RegImm());</span>
<span class="line-added">1298     RUN(testBranchTestBit32AddrImm());</span>
<span class="line-added">1299     RUN(testBranchTestBit64RegReg());</span>
<span class="line-added">1300     RUN(testBranchTestBit64RegImm());</span>
<span class="line-added">1301     RUN(testBranchTestBit64AddrImm());</span>
<span class="line-added">1302 #endif</span>
<span class="line-added">1303 </span>
<span class="line-added">1304 #if CPU(ARM64)</span>
<span class="line-added">1305     RUN(testMul32SignExtend());</span>
<span class="line-added">1306 #endif</span>
<span class="line-added">1307 </span>
1308 #if CPU(X86) || CPU(X86_64) || CPU(ARM64)
1309     RUN(testCompareFloat(MacroAssembler::DoubleEqual));
1310     RUN(testCompareFloat(MacroAssembler::DoubleNotEqual));
1311     RUN(testCompareFloat(MacroAssembler::DoubleGreaterThan));
1312     RUN(testCompareFloat(MacroAssembler::DoubleGreaterThanOrEqual));
1313     RUN(testCompareFloat(MacroAssembler::DoubleLessThan));
1314     RUN(testCompareFloat(MacroAssembler::DoubleLessThanOrEqual));
1315     RUN(testCompareFloat(MacroAssembler::DoubleEqualOrUnordered));
1316     RUN(testCompareFloat(MacroAssembler::DoubleNotEqualOrUnordered));
1317     RUN(testCompareFloat(MacroAssembler::DoubleGreaterThanOrUnordered));
1318     RUN(testCompareFloat(MacroAssembler::DoubleGreaterThanOrEqualOrUnordered));
1319     RUN(testCompareFloat(MacroAssembler::DoubleLessThanOrUnordered));
1320     RUN(testCompareFloat(MacroAssembler::DoubleLessThanOrEqualOrUnordered));
1321 #endif
1322 
1323 #if ENABLE(MASM_PROBE)
1324     RUN(testProbeReadsArgumentRegisters());
1325     RUN(testProbeWritesArgumentRegisters());
1326     RUN(testProbePreservesGPRS());
1327     RUN(testProbeModifiesStackPointerToInsideProbeStateOnStack());
1328     RUN(testProbeModifiesStackPointerToNBytesBelowSP());
1329     RUN(testProbeModifiesProgramCounter());
1330     RUN(testProbeModifiesStackValues());
1331 #endif // ENABLE(MASM_PROBE)
1332 
1333     RUN(testByteSwap());
<span class="line-added">1334     RUN(testMoveDoubleConditionally32());</span>
<span class="line-added">1335     RUN(testMoveDoubleConditionally64());</span>
<span class="line-added">1336 </span>
<span class="line-added">1337     RUN(testCagePreservesPACFailureBit());</span>
1338 
1339     if (tasks.isEmpty())
1340         usage();
1341 
1342     Lock lock;
1343 
1344     Vector&lt;Ref&lt;Thread&gt;&gt; threads;
1345     for (unsigned i = filter ? 1 : WTF::numberOfProcessorCores(); i--;) {
1346         threads.append(
1347             Thread::create(
1348                 &quot;testmasm thread&quot;,
1349                 [&amp;] () {
1350                     for (;;) {
1351                         RefPtr&lt;SharedTask&lt;void()&gt;&gt; task;
1352                         {
1353                             LockHolder locker(lock);
1354                             if (tasks.isEmpty())
1355                                 return;
1356                             task = tasks.takeFirst();
1357                         }
</pre>
</td>
</tr>
</table>
<center><a href="X86Assembler.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../b3/B3ArgumentRegValue.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>