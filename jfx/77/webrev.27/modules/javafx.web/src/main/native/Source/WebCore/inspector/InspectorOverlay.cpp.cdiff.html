<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/inspector/InspectorOverlay.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="InspectorNodeFinder.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="InspectorOverlay.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/inspector/InspectorOverlay.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
<span class="line-new-header">--- 1,8 ---</span>
  /*
   * Copyright (C) 2011 Google Inc. All rights reserved.
<span class="line-added">+  * Copyright (C) 2019 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 27,62 ***</span>
   */
  
  #include &quot;config.h&quot;
  #include &quot;InspectorOverlay.h&quot;
  
<span class="line-modified">! #include &quot;CacheStorageProvider.h&quot;</span>
<span class="line-modified">! #include &quot;DocumentLoader.h&quot;</span>
<span class="line-modified">! #include &quot;EditorClient.h&quot;</span>
  #include &quot;Element.h&quot;
<span class="line-modified">! #include &quot;EmptyClients.h&quot;</span>
  #include &quot;Frame.h&quot;
  #include &quot;FrameView.h&quot;
  #include &quot;GraphicsContext.h&quot;
  #include &quot;InspectorClient.h&quot;
<span class="line-modified">! #include &quot;InspectorOverlayPage.h&quot;</span>
<span class="line-modified">! #include &quot;LibWebRTCProvider.h&quot;</span>
  #include &quot;Node.h&quot;
  #include &quot;Page.h&quot;
<span class="line-removed">- #include &quot;PageConfiguration.h&quot;</span>
<span class="line-removed">- #include &quot;PolygonShape.h&quot;</span>
  #include &quot;PseudoElement.h&quot;
<span class="line-modified">! #include &quot;RTCController.h&quot;</span>
<span class="line-removed">- #include &quot;RectangleShape.h&quot;</span>
  #include &quot;RenderBoxModelObject.h&quot;
<span class="line-removed">- #include &quot;RenderElement.h&quot;</span>
  #include &quot;RenderInline.h&quot;
<span class="line-modified">! #include &quot;RenderView.h&quot;</span>
<span class="line-removed">- #include &quot;ScriptController.h&quot;</span>
<span class="line-removed">- #include &quot;ScriptSourceCode.h&quot;</span>
  #include &quot;Settings.h&quot;
<span class="line-modified">! #include &quot;SocketProvider.h&quot;</span>
<span class="line-modified">! #include &quot;StyledElement.h&quot;</span>
<span class="line-removed">- #include &lt;JavaScriptCore/InspectorProtocolObjects.h&gt;</span>
<span class="line-removed">- #include &lt;wtf/JSONValues.h&gt;</span>
<span class="line-removed">- </span>
<span class="line-removed">- #if PLATFORM(MAC)</span>
<span class="line-removed">- #include &quot;LocalDefaultSystemAppearance.h&quot;</span>
<span class="line-removed">- #endif</span>
  
  namespace WebCore {
  
  using namespace Inspector;
  
  static void contentsQuadToCoordinateSystem(const FrameView* mainView, const FrameView* view, FloatQuad&amp; quad, InspectorOverlay::CoordinateSystem coordinateSystem)
  {
<span class="line-modified">!     quad.setP1(view-&gt;contentsToRootView(roundedIntPoint(quad.p1())));</span>
<span class="line-modified">!     quad.setP2(view-&gt;contentsToRootView(roundedIntPoint(quad.p2())));</span>
<span class="line-modified">!     quad.setP3(view-&gt;contentsToRootView(roundedIntPoint(quad.p3())));</span>
<span class="line-modified">!     quad.setP4(view-&gt;contentsToRootView(roundedIntPoint(quad.p4())));</span>
  
      if (coordinateSystem == InspectorOverlay::CoordinateSystem::View)
          quad += toIntSize(mainView-&gt;scrollPosition());
  }
  
<span class="line-modified">! static void contentsQuadToPage(const FrameView* mainView, const FrameView* view, FloatQuad&amp; quad)</span>
  {
<span class="line-modified">!     contentsQuadToCoordinateSystem(mainView, view, quad, InspectorOverlay::CoordinateSystem::View);</span>
  }
  
  static void buildRendererHighlight(RenderObject* renderer, const HighlightConfig&amp; highlightConfig, Highlight&amp; highlight, InspectorOverlay::CoordinateSystem coordinateSystem)
  {
      Frame* containingFrame = renderer-&gt;document().frame();
<span class="line-new-header">--- 28,94 ---</span>
   */
  
  #include &quot;config.h&quot;
  #include &quot;InspectorOverlay.h&quot;
  
<span class="line-modified">! #include &quot;AXObjectCache.h&quot;</span>
<span class="line-modified">! #include &quot;AccessibilityObject.h&quot;</span>
<span class="line-modified">! #include &quot;DOMCSSNamespace.h&quot;</span>
<span class="line-added">+ #include &quot;DOMTokenList.h&quot;</span>
  #include &quot;Element.h&quot;
<span class="line-modified">! #include &quot;FloatPoint.h&quot;</span>
<span class="line-added">+ #include &quot;FloatRoundedRect.h&quot;</span>
<span class="line-added">+ #include &quot;FloatSize.h&quot;</span>
<span class="line-added">+ #include &quot;FontCascade.h&quot;</span>
<span class="line-added">+ #include &quot;FontCascadeDescription.h&quot;</span>
  #include &quot;Frame.h&quot;
  #include &quot;FrameView.h&quot;
  #include &quot;GraphicsContext.h&quot;
  #include &quot;InspectorClient.h&quot;
<span class="line-modified">! #include &quot;IntPoint.h&quot;</span>
<span class="line-modified">! #include &quot;IntRect.h&quot;</span>
<span class="line-added">+ #include &quot;IntSize.h&quot;</span>
  #include &quot;Node.h&quot;
<span class="line-added">+ #include &quot;NodeList.h&quot;</span>
  #include &quot;Page.h&quot;
  #include &quot;PseudoElement.h&quot;
<span class="line-modified">! #include &quot;RenderBox.h&quot;</span>
  #include &quot;RenderBoxModelObject.h&quot;
  #include &quot;RenderInline.h&quot;
<span class="line-modified">! #include &quot;RenderObject.h&quot;</span>
  #include &quot;Settings.h&quot;
<span class="line-modified">! #include &lt;wtf/MathExtras.h&gt;</span>
<span class="line-modified">! #include &lt;wtf/text/StringBuilder.h&gt;</span>
  
  namespace WebCore {
  
  using namespace Inspector;
  
<span class="line-added">+ static constexpr float elementDataSpacing = 2;</span>
<span class="line-added">+ static constexpr float elementDataArrowSize = 7;</span>
<span class="line-added">+ static constexpr float elementDataBorderSize = 1;</span>
<span class="line-added">+ </span>
<span class="line-added">+ static constexpr float rulerSize = 15;</span>
<span class="line-added">+ static constexpr float rulerLabelSize = 13;</span>
<span class="line-added">+ static constexpr float rulerStepIncrement = 50;</span>
<span class="line-added">+ static constexpr float rulerStepLength = 8;</span>
<span class="line-added">+ static constexpr float rulerSubStepIncrement = 5;</span>
<span class="line-added">+ static constexpr float rulerSubStepLength = 5;</span>
<span class="line-added">+ </span>
<span class="line-added">+ static constexpr UChar ellipsis = 0x2026;</span>
<span class="line-added">+ static constexpr UChar multiplicationSign = 0x00D7;</span>
<span class="line-added">+ </span>
<span class="line-added">+ static void truncateWithEllipsis(String&amp; string, size_t length)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (string.length() &gt; length) {</span>
<span class="line-added">+         string.truncate(length);</span>
<span class="line-added">+         string.append(ellipsis);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static FloatPoint localPointToRootPoint(const FrameView* view, const FloatPoint&amp; point)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return view-&gt;contentsToRootView(roundedIntPoint(point));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  static void contentsQuadToCoordinateSystem(const FrameView* mainView, const FrameView* view, FloatQuad&amp; quad, InspectorOverlay::CoordinateSystem coordinateSystem)
  {
<span class="line-modified">!     quad.setP1(localPointToRootPoint(view, quad.p1()));</span>
<span class="line-modified">!     quad.setP2(localPointToRootPoint(view, quad.p2()));</span>
<span class="line-modified">!     quad.setP3(localPointToRootPoint(view, quad.p3()));</span>
<span class="line-modified">!     quad.setP4(localPointToRootPoint(view, quad.p4()));</span>
  
      if (coordinateSystem == InspectorOverlay::CoordinateSystem::View)
          quad += toIntSize(mainView-&gt;scrollPosition());
  }
  
<span class="line-modified">! static Element* effectiveElementForNode(Node&amp; node)</span>
  {
<span class="line-modified">!     if (!is&lt;Element&gt;(node) || !node.document().frame())</span>
<span class="line-added">+         return nullptr;</span>
<span class="line-added">+ </span>
<span class="line-added">+     Element* element = nullptr;</span>
<span class="line-added">+     if (is&lt;PseudoElement&gt;(node)) {</span>
<span class="line-added">+         if (Element* hostElement = downcast&lt;PseudoElement&gt;(node).hostElement())</span>
<span class="line-added">+             element = hostElement;</span>
<span class="line-added">+     } else</span>
<span class="line-added">+         element = &amp;downcast&lt;Element&gt;(node);</span>
<span class="line-added">+ </span>
<span class="line-added">+     return element;</span>
  }
  
  static void buildRendererHighlight(RenderObject* renderer, const HighlightConfig&amp; highlightConfig, Highlight&amp; highlight, InspectorOverlay::CoordinateSystem coordinateSystem)
  {
      Frame* containingFrame = renderer-&gt;document().frame();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 164,10 ***</span>
<span class="line-new-header">--- 197,170 ---</span>
      highlight.setDataFromConfig(highlightConfig);
      highlight.type = HighlightType::Rects;
      highlight.quads.append(quad);
  }
  
<span class="line-added">+ static Path quadToPath(const FloatQuad&amp; quad, Highlight::Bounds&amp; bounds)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     Path path;</span>
<span class="line-added">+     path.moveTo(quad.p1());</span>
<span class="line-added">+     path.addLineTo(quad.p2());</span>
<span class="line-added">+     path.addLineTo(quad.p3());</span>
<span class="line-added">+     path.addLineTo(quad.p4());</span>
<span class="line-added">+     path.closeSubpath();</span>
<span class="line-added">+ </span>
<span class="line-added">+     bounds.unite(path.boundingRect());</span>
<span class="line-added">+ </span>
<span class="line-added">+     return path;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static void drawOutlinedQuadWithClip(GraphicsContext&amp; context, const FloatQuad&amp; quad, const FloatQuad&amp; clipQuad, const Color&amp; fillColor, Highlight::Bounds&amp; bounds)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     GraphicsContextStateSaver stateSaver(context);</span>
<span class="line-added">+ </span>
<span class="line-added">+     context.setFillColor(fillColor);</span>
<span class="line-added">+     context.setStrokeThickness(0);</span>
<span class="line-added">+     context.fillPath(quadToPath(quad, bounds));</span>
<span class="line-added">+ </span>
<span class="line-added">+     context.setCompositeOperation(CompositeDestinationOut);</span>
<span class="line-added">+     context.setFillColor(Color::createUnchecked(255, 0, 0));</span>
<span class="line-added">+     context.fillPath(quadToPath(clipQuad, bounds));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static void drawOutlinedQuad(GraphicsContext&amp; context, const FloatQuad&amp; quad, const Color&amp; fillColor, const Color&amp; outlineColor, Highlight::Bounds&amp; bounds)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     Path path = quadToPath(quad, bounds);</span>
<span class="line-added">+ </span>
<span class="line-added">+     GraphicsContextStateSaver stateSaver(context);</span>
<span class="line-added">+ </span>
<span class="line-added">+     context.setStrokeThickness(2);</span>
<span class="line-added">+ </span>
<span class="line-added">+     context.clipPath(path);</span>
<span class="line-added">+ </span>
<span class="line-added">+     context.setFillColor(fillColor);</span>
<span class="line-added">+     context.fillPath(path);</span>
<span class="line-added">+ </span>
<span class="line-added">+     context.setStrokeColor(outlineColor);</span>
<span class="line-added">+     context.strokePath(path);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static void drawFragmentHighlight(GraphicsContext&amp; context, Node&amp; node, const HighlightConfig&amp; highlightConfig, Highlight::Bounds&amp; bounds)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     Highlight highlight;</span>
<span class="line-added">+     buildNodeHighlight(node, highlightConfig, highlight, InspectorOverlay::CoordinateSystem::Document);</span>
<span class="line-added">+ </span>
<span class="line-added">+     FloatQuad marginQuad;</span>
<span class="line-added">+     FloatQuad borderQuad;</span>
<span class="line-added">+     FloatQuad paddingQuad;</span>
<span class="line-added">+     FloatQuad contentQuad;</span>
<span class="line-added">+ </span>
<span class="line-added">+     size_t size = highlight.quads.size();</span>
<span class="line-added">+     if (size &gt;= 1)</span>
<span class="line-added">+         marginQuad = highlight.quads[0];</span>
<span class="line-added">+     if (size &gt;= 2)</span>
<span class="line-added">+         borderQuad = highlight.quads[1];</span>
<span class="line-added">+     if (size &gt;= 3)</span>
<span class="line-added">+         paddingQuad = highlight.quads[2];</span>
<span class="line-added">+     if (size &gt;= 4)</span>
<span class="line-added">+         contentQuad = highlight.quads[3];</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (!marginQuad.isEmpty() &amp;&amp; marginQuad != borderQuad &amp;&amp; highlight.marginColor.isVisible())</span>
<span class="line-added">+         drawOutlinedQuadWithClip(context, marginQuad, borderQuad, highlight.marginColor, bounds);</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (!borderQuad.isEmpty() &amp;&amp; borderQuad != paddingQuad &amp;&amp; highlight.borderColor.isVisible())</span>
<span class="line-added">+         drawOutlinedQuadWithClip(context, borderQuad, paddingQuad, highlight.borderColor, bounds);</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (!paddingQuad.isEmpty() &amp;&amp; paddingQuad != contentQuad &amp;&amp; highlight.paddingColor.isVisible())</span>
<span class="line-added">+         drawOutlinedQuadWithClip(context, paddingQuad, contentQuad, highlight.paddingColor, bounds);</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (!contentQuad.isEmpty() &amp;&amp; (highlight.contentColor.isVisible() || highlight.contentOutlineColor.isVisible()))</span>
<span class="line-added">+         drawOutlinedQuad(context, contentQuad, highlight.contentColor, highlight.contentOutlineColor, bounds);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static void drawShapeHighlight(GraphicsContext&amp; context, Node&amp; node, Highlight::Bounds&amp; bounds)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     RenderObject* renderer = node.renderer();</span>
<span class="line-added">+     if (!renderer || !is&lt;RenderBox&gt;(renderer))</span>
<span class="line-added">+         return;</span>
<span class="line-added">+ </span>
<span class="line-added">+     const ShapeOutsideInfo* shapeOutsideInfo = downcast&lt;RenderBox&gt;(renderer)-&gt;shapeOutsideInfo();</span>
<span class="line-added">+     if (!shapeOutsideInfo)</span>
<span class="line-added">+         return;</span>
<span class="line-added">+ </span>
<span class="line-added">+     Frame* containingFrame = node.document().frame();</span>
<span class="line-added">+     if (!containingFrame)</span>
<span class="line-added">+         return;</span>
<span class="line-added">+ </span>
<span class="line-added">+     FrameView* containingView = containingFrame-&gt;view();</span>
<span class="line-added">+     FrameView* mainView = containingFrame-&gt;page()-&gt;mainFrame().view();</span>
<span class="line-added">+ </span>
<span class="line-added">+     const Color shapeHighlightColor(96, 82, 127, 204);</span>
<span class="line-added">+ </span>
<span class="line-added">+     Shape::DisplayPaths paths;</span>
<span class="line-added">+     shapeOutsideInfo-&gt;computedShape().buildDisplayPaths(paths);</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (paths.shape.isEmpty()) {</span>
<span class="line-added">+         LayoutRect shapeBounds = shapeOutsideInfo-&gt;computedShapePhysicalBoundingBox();</span>
<span class="line-added">+         FloatQuad shapeQuad = renderer-&gt;localToAbsoluteQuad(FloatRect(shapeBounds));</span>
<span class="line-added">+         contentsQuadToCoordinateSystem(mainView, containingView, shapeQuad, InspectorOverlay::CoordinateSystem::Document);</span>
<span class="line-added">+         drawOutlinedQuad(context, shapeQuad, shapeHighlightColor, Color::transparent, bounds);</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     const auto mapPoints = [&amp;] (const Path&amp; path) {</span>
<span class="line-added">+         Path newPath;</span>
<span class="line-added">+         path.apply([&amp;] (const PathElement&amp; pathElement) {</span>
<span class="line-added">+             const auto localToRoot = [&amp;] (size_t index) {</span>
<span class="line-added">+                 const FloatPoint&amp; point = pathElement.points[index];</span>
<span class="line-added">+                 return localPointToRootPoint(containingView, renderer-&gt;localToAbsolute(shapeOutsideInfo-&gt;shapeToRendererPoint(point)));</span>
<span class="line-added">+             };</span>
<span class="line-added">+ </span>
<span class="line-added">+             switch (pathElement.type) {</span>
<span class="line-added">+             case PathElementMoveToPoint:</span>
<span class="line-added">+                 newPath.moveTo(localToRoot(0));</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+ </span>
<span class="line-added">+             case PathElementAddLineToPoint:</span>
<span class="line-added">+                 newPath.addLineTo(localToRoot(0));</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+ </span>
<span class="line-added">+             case PathElementAddCurveToPoint:</span>
<span class="line-added">+                 newPath.addBezierCurveTo(localToRoot(0), localToRoot(1), localToRoot(2));</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+ </span>
<span class="line-added">+             case PathElementAddQuadCurveToPoint:</span>
<span class="line-added">+                 newPath.addQuadCurveTo(localToRoot(0), localToRoot(1));</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+ </span>
<span class="line-added">+             case PathElementCloseSubpath:</span>
<span class="line-added">+                 newPath.closeSubpath();</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             }</span>
<span class="line-added">+         });</span>
<span class="line-added">+         return newPath;</span>
<span class="line-added">+     };</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (paths.marginShape.length()) {</span>
<span class="line-added">+         Path marginPath = mapPoints(paths.marginShape);</span>
<span class="line-added">+         bounds.unite(marginPath.boundingRect());</span>
<span class="line-added">+ </span>
<span class="line-added">+         GraphicsContextStateSaver stateSaver(context);</span>
<span class="line-added">+ </span>
<span class="line-added">+         const Color shapeMarginHighlightColor(96, 82, 127, 153);</span>
<span class="line-added">+         context.setFillColor(shapeMarginHighlightColor);</span>
<span class="line-added">+         context.fillPath(marginPath);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     Path shapePath = mapPoints(paths.shape);</span>
<span class="line-added">+     bounds.unite(shapePath.boundingRect());</span>
<span class="line-added">+ </span>
<span class="line-added">+     GraphicsContextStateSaver stateSaver(context);</span>
<span class="line-added">+ </span>
<span class="line-added">+     context.setFillColor(shapeHighlightColor);</span>
<span class="line-added">+     context.fillPath(shapePath);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  InspectorOverlay::InspectorOverlay(Page&amp; page, InspectorClient* client)
      : m_page(page)
      , m_client(client)
      , m_paintRectUpdateTimer(*this, &amp;InspectorOverlay::updatePaintRectsTimerFired)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 178,23 ***</span>
  void InspectorOverlay::paint(GraphicsContext&amp; context)
  {
      if (!shouldShowOverlay())
          return;
  
<span class="line-modified">!     Page* overlayPage = this-&gt;overlayPage();</span>
<span class="line-modified">!     if (!overlayPage)</span>
<span class="line-modified">!         return;</span>
  
      GraphicsContextStateSaver stateSaver(context);
<span class="line-removed">-     FrameView* view = overlayPage-&gt;mainFrame().view();</span>
  
<span class="line-modified">! #if PLATFORM(MAC)</span>
<span class="line-modified">!     LocalDefaultSystemAppearance localAppearance(view-&gt;useDarkAppearance());</span>
<span class="line-modified">! #endif</span>
  
<span class="line-modified">!     view-&gt;updateLayoutAndStyleIfNeededRecursive();</span>
<span class="line-modified">!     view-&gt;paint(context, IntRect(0, 0, view-&gt;width(), view-&gt;height()));</span>
  }
  
  void InspectorOverlay::getHighlight(Highlight&amp; highlight, InspectorOverlay::CoordinateSystem coordinateSystem) const
  {
      if (!m_highlightNode &amp;&amp; !m_highlightQuad &amp;&amp; !m_highlightNodeList)
<span class="line-new-header">--- 371,51 ---</span>
  void InspectorOverlay::paint(GraphicsContext&amp; context)
  {
      if (!shouldShowOverlay())
          return;
  
<span class="line-modified">!     FloatSize viewportSize = m_page.mainFrame().view()-&gt;sizeForVisibleContent();</span>
<span class="line-modified">! </span>
<span class="line-modified">!     context.clearRect({ FloatPoint::zero(), viewportSize });</span>
  
      GraphicsContextStateSaver stateSaver(context);
  
<span class="line-modified">!     if (m_indicating) {</span>
<span class="line-modified">!         GraphicsContextStateSaver stateSaver(context);</span>
<span class="line-modified">! </span>
<span class="line-added">+         const Color indicatingColor(111, 168, 220, 168);</span>
<span class="line-added">+         context.setFillColor(indicatingColor);</span>
<span class="line-added">+         context.fillRect({ FloatPoint::zero(), viewportSize });</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     RulerExclusion rulerExclusion;</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (m_highlightQuad) {</span>
<span class="line-added">+         auto quadRulerExclusion = drawQuadHighlight(context, *m_highlightQuad);</span>
<span class="line-added">+         rulerExclusion.bounds.unite(quadRulerExclusion.bounds);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (m_highlightNodeList) {</span>
<span class="line-added">+         for (unsigned i = 0; i &lt; m_highlightNodeList-&gt;length(); ++i) {</span>
<span class="line-added">+             if (auto* node = m_highlightNodeList-&gt;item(i)) {</span>
<span class="line-added">+                 auto nodeRulerExclusion = drawNodeHighlight(context, *node);</span>
<span class="line-added">+                 rulerExclusion.bounds.unite(nodeRulerExclusion.bounds);</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (m_highlightNode) {</span>
<span class="line-added">+         auto nodeRulerExclusion = drawNodeHighlight(context, *m_highlightNode);</span>
<span class="line-added">+         rulerExclusion.bounds.unite(nodeRulerExclusion.bounds);</span>
<span class="line-added">+         rulerExclusion.titlePath = nodeRulerExclusion.titlePath;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (!m_paintRects.isEmpty())</span>
<span class="line-added">+         drawPaintRects(context, m_paintRects);</span>
  
<span class="line-modified">!     if (m_showRulers || m_showRulersDuringElementSelection)</span>
<span class="line-modified">!         drawRulers(context, rulerExclusion);</span>
  }
  
  void InspectorOverlay::getHighlight(Highlight&amp; highlight, InspectorOverlay::CoordinateSystem coordinateSystem) const
  {
      if (!m_highlightNode &amp;&amp; !m_highlightQuad &amp;&amp; !m_highlightNodeList)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 214,16 ***</span>
          highlight.type = HighlightType::NodeList;
      } else
          buildQuadHighlight(*m_highlightQuad, m_quadHighlightConfig, highlight);
  }
  
<span class="line-removed">- void InspectorOverlay::setPausedInDebuggerMessage(const String* message)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     m_pausedInDebuggerMessage = message ? *message : String();</span>
<span class="line-removed">-     update();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  void InspectorOverlay::hideHighlight()
  {
      m_highlightNode = nullptr;
      m_highlightNodeList = nullptr;
      m_highlightQuad = nullptr;
<span class="line-new-header">--- 435,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 266,23 ***</span>
      m_client-&gt;didSetSearchingForNode(enabled);
  }
  
  void InspectorOverlay::setIndicating(bool indicating)
  {
<span class="line-modified">!     m_indicating = indicating;</span>
  
<span class="line-modified">!     if (m_indicating)</span>
<span class="line-removed">-         evaluateInOverlay(&quot;showPageIndication&quot;_s);</span>
<span class="line-removed">-     else</span>
<span class="line-removed">-         evaluateInOverlay(&quot;hidePageIndication&quot;_s);</span>
  
      update();
  }
  
  bool InspectorOverlay::shouldShowOverlay() const
  {
<span class="line-modified">!     return m_highlightNode || m_highlightNodeList || m_highlightQuad || m_indicating || m_showingPaintRects || m_showRulers || !m_pausedInDebuggerMessage.isNull();</span>
  }
  
  void InspectorOverlay::update()
  {
      if (!shouldShowOverlay()) {
<span class="line-new-header">--- 481,23 ---</span>
      m_client-&gt;didSetSearchingForNode(enabled);
  }
  
  void InspectorOverlay::setIndicating(bool indicating)
  {
<span class="line-modified">!     if (m_indicating == indicating)</span>
<span class="line-added">+         return;</span>
  
<span class="line-modified">!     m_indicating = indicating;</span>
  
      update();
  }
  
  bool InspectorOverlay::shouldShowOverlay() const
  {
<span class="line-modified">!     // Don&#39;t show the overlay when m_showRulersDuringElementSelection is true, as it&#39;s only supposed</span>
<span class="line-added">+     // to have an effect when element selection is active (e.g. a node is hovered).</span>
<span class="line-added">+     return m_highlightNode || m_highlightNodeList || m_highlightQuad || m_indicating || m_showPaintRects || m_showRulers;</span>
  }
  
  void InspectorOverlay::update()
  {
      if (!shouldShowOverlay()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 292,111 ***</span>
  
      FrameView* view = m_page.mainFrame().view();
      if (!view)
          return;
  
<span class="line-modified">!     Page* overlayPage = this-&gt;overlayPage();</span>
<span class="line-removed">-     if (overlayPage) {</span>
<span class="line-removed">-         FrameView* overlayView = overlayPage-&gt;mainFrame().view();</span>
<span class="line-removed">-         IntSize frameViewFullSize = view-&gt;sizeForVisibleContent(ScrollableArea::IncludeScrollbars);</span>
<span class="line-removed">-         overlayView-&gt;resize(frameViewFullSize);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // Clear canvas and paint things.</span>
<span class="line-removed">-     IntSize viewportSize = view-&gt;sizeForVisibleContent();</span>
<span class="line-removed">-     IntPoint scrollOffset = view-&gt;scrollPosition();</span>
<span class="line-removed">-     reset(viewportSize, scrollOffset);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // Include scrollbars to avoid masking them by the gutter.</span>
<span class="line-removed">-     drawNodeHighlight();</span>
<span class="line-removed">-     drawQuadHighlight();</span>
<span class="line-removed">-     drawPausedInDebuggerMessage();</span>
<span class="line-removed">-     drawPaintRects();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (m_showRulers)</span>
<span class="line-removed">-         drawRulers();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // Position DOM elements.</span>
<span class="line-removed">-     if (overlayPage) {</span>
<span class="line-removed">-         overlayPage-&gt;mainFrame().document()-&gt;resolveStyle(Document::ResolveStyleType::Rebuild);</span>
<span class="line-removed">-         FrameView* overlayView = overlayPage-&gt;mainFrame().view();</span>
<span class="line-removed">-         if (overlayView-&gt;needsLayout())</span>
<span class="line-removed">-             overlayView-&gt;layoutContext().layout();</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     forcePaint();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- static Ref&lt;Inspector::Protocol::OverlayTypes::Point&gt; buildObjectForPoint(const FloatPoint&amp; point)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     return Inspector::Protocol::OverlayTypes::Point::create()</span>
<span class="line-removed">-         .setX(point.x())</span>
<span class="line-removed">-         .setY(point.y())</span>
<span class="line-removed">-         .release();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- static Ref&lt;Inspector::Protocol::OverlayTypes::Rect&gt; buildObjectForRect(const FloatRect&amp; rect)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     return Inspector::Protocol::OverlayTypes::Rect::create()</span>
<span class="line-removed">-         .setX(rect.x())</span>
<span class="line-removed">-         .setY(rect.y())</span>
<span class="line-removed">-         .setWidth(rect.width())</span>
<span class="line-removed">-         .setHeight(rect.height())</span>
<span class="line-removed">-         .release();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- static Ref&lt;Inspector::Protocol::OverlayTypes::Quad&gt; buildArrayForQuad(const FloatQuad&amp; quad)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     auto array = Inspector::Protocol::OverlayTypes::Quad::create();</span>
<span class="line-removed">-     array-&gt;addItem(buildObjectForPoint(quad.p1()));</span>
<span class="line-removed">-     array-&gt;addItem(buildObjectForPoint(quad.p2()));</span>
<span class="line-removed">-     array-&gt;addItem(buildObjectForPoint(quad.p3()));</span>
<span class="line-removed">-     array-&gt;addItem(buildObjectForPoint(quad.p4()));</span>
<span class="line-removed">-     return array;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- static Ref&lt;Inspector::Protocol::OverlayTypes::FragmentHighlightData&gt; buildObjectForHighlight(const Highlight&amp; highlight)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     auto arrayOfQuads = JSON::ArrayOf&lt;Inspector::Protocol::OverlayTypes::Quad&gt;::create();</span>
<span class="line-removed">-     for (auto&amp; quad : highlight.quads)</span>
<span class="line-removed">-         arrayOfQuads-&gt;addItem(buildArrayForQuad(quad));</span>
<span class="line-removed">- </span>
<span class="line-removed">-     return Inspector::Protocol::OverlayTypes::FragmentHighlightData::create()</span>
<span class="line-removed">-         .setQuads(WTFMove(arrayOfQuads))</span>
<span class="line-removed">-         .setContentColor(highlight.contentColor.serialized())</span>
<span class="line-removed">-         .setContentOutlineColor(highlight.contentOutlineColor.serialized())</span>
<span class="line-removed">-         .setPaddingColor(highlight.paddingColor.serialized())</span>
<span class="line-removed">-         .setBorderColor(highlight.borderColor.serialized())</span>
<span class="line-removed">-         .setMarginColor(highlight.marginColor.serialized())</span>
<span class="line-removed">-         .release();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- static Ref&lt;Inspector::Protocol::OverlayTypes::Size&gt; buildObjectForSize(const IntSize&amp; size)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     return Inspector::Protocol::OverlayTypes::Size::create()</span>
<span class="line-removed">-         .setWidth(size.width())</span>
<span class="line-removed">-         .setHeight(size.height())</span>
<span class="line-removed">-         .release();</span>
  }
  
<span class="line-modified">! void InspectorOverlay::setShowingPaintRects(bool showingPaintRects)</span>
  {
<span class="line-modified">!     if (m_showingPaintRects == showingPaintRects)</span>
          return;
  
<span class="line-modified">!     m_showingPaintRects = showingPaintRects;</span>
<span class="line-modified">!     if (!m_showingPaintRects) {</span>
          m_paintRects.clear();
          m_paintRectUpdateTimer.stop();
<span class="line-modified">!         drawPaintRects();</span>
<span class="line-removed">-         forcePaint();</span>
      }
  }
  
  void InspectorOverlay::showPaintRect(const FloatRect&amp; rect)
  {
<span class="line-modified">!     if (!m_showingPaintRects)</span>
          return;
  
      IntRect rootRect = m_page.mainFrame().view()-&gt;contentsToRootView(enclosingIntRect(rect));
  
      const auto removeDelay = 250_ms;
<span class="line-new-header">--- 507,29 ---</span>
  
      FrameView* view = m_page.mainFrame().view();
      if (!view)
          return;
  
<span class="line-modified">!     m_client-&gt;highlight();</span>
  }
  
<span class="line-modified">! void InspectorOverlay::setShowPaintRects(bool showPaintRects)</span>
  {
<span class="line-modified">!     if (m_showPaintRects == showPaintRects)</span>
          return;
  
<span class="line-modified">!     m_showPaintRects = showPaintRects;</span>
<span class="line-modified">!     if (!m_showPaintRects) {</span>
          m_paintRects.clear();
          m_paintRectUpdateTimer.stop();
<span class="line-modified">!         update();</span>
      }
  }
  
  void InspectorOverlay::showPaintRect(const FloatRect&amp; rect)
  {
<span class="line-modified">!     if (!m_showPaintRects)</span>
          return;
  
      IntRect rootRect = m_page.mainFrame().view()-&gt;contentsToRootView(enclosingIntRect(rect));
  
      const auto removeDelay = 250_ms;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 407,12 ***</span>
      if (!m_paintRectUpdateTimer.isActive()) {
          const Seconds paintRectsUpdateInterval { 32_ms };
          m_paintRectUpdateTimer.startRepeating(paintRectsUpdateInterval);
      }
  
<span class="line-modified">!     drawPaintRects();</span>
<span class="line-removed">-     forcePaint();</span>
  }
  
  void InspectorOverlay::setShowRulers(bool showRulers)
  {
      if (m_showRulers == showRulers)
<span class="line-new-header">--- 540,11 ---</span>
      if (!m_paintRectUpdateTimer.isActive()) {
          const Seconds paintRectsUpdateInterval { 32_ms };
          m_paintRectUpdateTimer.startRepeating(paintRectsUpdateInterval);
      }
  
<span class="line-modified">!     update();</span>
  }
  
  void InspectorOverlay::setShowRulers(bool showRulers)
  {
      if (m_showRulers == showRulers)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 433,392 ***</span>
      }
  
      if (m_paintRects.isEmpty())
          m_paintRectUpdateTimer.stop();
  
<span class="line-modified">!     if (rectsChanged) {</span>
<span class="line-modified">!         drawPaintRects();</span>
<span class="line-removed">-         forcePaint();</span>
<span class="line-removed">-     }</span>
  }
  
<span class="line-modified">! void InspectorOverlay::drawPaintRects()</span>
  {
<span class="line-modified">!     auto arrayOfRects = JSON::ArrayOf&lt;Inspector::Protocol::OverlayTypes::Rect&gt;::create();</span>
<span class="line-removed">-     for (const auto&amp; pair : m_paintRects)</span>
<span class="line-removed">-         arrayOfRects-&gt;addItem(buildObjectForRect(pair.second));</span>
  
<span class="line-modified">!     evaluateInOverlay(&quot;updatePaintRects&quot;_s, WTFMove(arrayOfRects));</span>
<span class="line-removed">- }</span>
  
<span class="line-modified">! void InspectorOverlay::drawRulers()</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     evaluateInOverlay(&quot;drawRulers&quot;_s);</span>
  }
  
<span class="line-modified">! static RefPtr&lt;JSON::ArrayOf&lt;Inspector::Protocol::OverlayTypes::FragmentHighlightData&gt;&gt; buildArrayForRendererFragments(RenderObject* renderer, const HighlightConfig&amp; config)</span>
  {
<span class="line-modified">!     auto arrayOfFragments = JSON::ArrayOf&lt;Inspector::Protocol::OverlayTypes::FragmentHighlightData&gt;::create();</span>
  
      Highlight highlight;
<span class="line-modified">!     buildRendererHighlight(renderer, config, highlight, InspectorOverlay::CoordinateSystem::View);</span>
<span class="line-modified">!     arrayOfFragments-&gt;addItem(buildObjectForHighlight(highlight));</span>
  
<span class="line-modified">!     return WTFMove(arrayOfFragments);</span>
  }
  
<span class="line-modified">! static FloatPoint localPointToRoot(RenderObject* renderer, const FrameView* mainView, const FrameView* view, const FloatPoint&amp; point)</span>
  {
<span class="line-modified">!     FloatPoint result = renderer-&gt;localToAbsolute(point);</span>
<span class="line-removed">-     result = view-&gt;contentsToRootView(roundedIntPoint(result));</span>
<span class="line-removed">-     result += toIntSize(mainView-&gt;scrollPosition());</span>
<span class="line-removed">-     return result;</span>
<span class="line-removed">- }</span>
  
<span class="line-modified">! struct PathApplyInfo {</span>
<span class="line-modified">!     FrameView* rootView;</span>
<span class="line-removed">-     FrameView* view;</span>
<span class="line-removed">-     Inspector::Protocol::OverlayTypes::DisplayPath* pathArray;</span>
<span class="line-removed">-     RenderObject* renderer;</span>
<span class="line-removed">-     const ShapeOutsideInfo* shapeOutsideInfo;</span>
<span class="line-removed">- };</span>
  
<span class="line-modified">! static void appendPathCommandAndPoints(PathApplyInfo&amp; info, const String&amp; command, const FloatPoint points[], unsigned length)</span>
  {
<span class="line-modified">!     FloatPoint point;</span>
<span class="line-modified">!     info.pathArray-&gt;addItem(command);</span>
<span class="line-modified">!     for (unsigned i = 0; i &lt; length; i++) {</span>
<span class="line-modified">!         point = info.shapeOutsideInfo-&gt;shapeToRendererPoint(points[i]);</span>
<span class="line-modified">!         point = localPointToRoot(info.renderer, info.rootView, info.view, point);</span>
<span class="line-modified">!         info.pathArray-&gt;addItem(point.x());</span>
<span class="line-modified">!         info.pathArray-&gt;addItem(point.y());</span>
      }
<span class="line-removed">- }</span>
  
<span class="line-modified">! static void appendPathSegment(PathApplyInfo&amp; pathApplyInfo, const PathElement&amp; pathElement)</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     FloatPoint point;</span>
<span class="line-modified">!     switch (pathElement.type) {</span>
<span class="line-modified">!     // The points member will contain 1 value.</span>
<span class="line-modified">!     case PathElementMoveToPoint:</span>
<span class="line-modified">!         appendPathCommandAndPoints(pathApplyInfo, &quot;M&quot;_s, pathElement.points, 1);</span>
<span class="line-modified">!         break;</span>
<span class="line-modified">!     // The points member will contain 1 value.</span>
<span class="line-modified">!     case PathElementAddLineToPoint:</span>
<span class="line-modified">!         appendPathCommandAndPoints(pathApplyInfo, &quot;L&quot;_s, pathElement.points, 1);</span>
<span class="line-modified">!         break;</span>
<span class="line-modified">!     // The points member will contain 3 values.</span>
<span class="line-modified">!     case PathElementAddCurveToPoint:</span>
<span class="line-removed">-         appendPathCommandAndPoints(pathApplyInfo, &quot;C&quot;_s, pathElement.points, 3);</span>
<span class="line-removed">-         break;</span>
<span class="line-removed">-     // The points member will contain 2 values.</span>
<span class="line-removed">-     case PathElementAddQuadCurveToPoint:</span>
<span class="line-removed">-         appendPathCommandAndPoints(pathApplyInfo, &quot;Q&quot;_s, pathElement.points, 2);</span>
<span class="line-removed">-         break;</span>
<span class="line-removed">-     // The points member will contain no values.</span>
<span class="line-removed">-     case PathElementCloseSubpath:</span>
<span class="line-removed">-         appendPathCommandAndPoints(pathApplyInfo, &quot;Z&quot;_s, nullptr, 0);</span>
<span class="line-removed">-         break;</span>
      }
  }
  
<span class="line-modified">! static RefPtr&lt;Inspector::Protocol::OverlayTypes::ShapeOutsideData&gt; buildObjectForShapeOutside(Frame* containingFrame, RenderBox* renderer)</span>
  {
<span class="line-modified">!     const ShapeOutsideInfo* shapeOutsideInfo = renderer-&gt;shapeOutsideInfo();</span>
<span class="line-modified">!     if (!shapeOutsideInfo)</span>
<span class="line-modified">!         return nullptr;</span>
  
<span class="line-modified">!     LayoutRect shapeBounds = shapeOutsideInfo-&gt;computedShapePhysicalBoundingBox();</span>
<span class="line-modified">!     FloatQuad shapeQuad = renderer-&gt;localToAbsoluteQuad(FloatRect(shapeBounds));</span>
<span class="line-removed">-     contentsQuadToPage(containingFrame-&gt;page()-&gt;mainFrame().view(), containingFrame-&gt;view(), shapeQuad);</span>
  
<span class="line-modified">!     auto shapeObject = Inspector::Protocol::OverlayTypes::ShapeOutsideData::create()</span>
<span class="line-modified">!         .setBounds(buildArrayForQuad(shapeQuad))</span>
<span class="line-modified">!         .release();</span>
  
<span class="line-modified">!     Shape::DisplayPaths paths;</span>
<span class="line-removed">-     shapeOutsideInfo-&gt;computedShape().buildDisplayPaths(paths);</span>
  
<span class="line-modified">!     if (paths.shape.length()) {</span>
<span class="line-modified">!         auto shapePath = Inspector::Protocol::OverlayTypes::DisplayPath::create();</span>
<span class="line-modified">!         PathApplyInfo info;</span>
<span class="line-modified">!         info.rootView = containingFrame-&gt;page()-&gt;mainFrame().view();</span>
<span class="line-modified">!         info.view = containingFrame-&gt;view();</span>
<span class="line-modified">!         info.pathArray = &amp;shapePath.get();</span>
<span class="line-modified">!         info.renderer = renderer;</span>
<span class="line-modified">!         info.shapeOutsideInfo = shapeOutsideInfo;</span>
<span class="line-modified">! </span>
<span class="line-modified">!         paths.shape.apply([&amp;info](const PathElement&amp; pathElement) {</span>
<span class="line-modified">!             appendPathSegment(info, pathElement);</span>
<span class="line-modified">!         });</span>
  
<span class="line-modified">!         shapeObject-&gt;setShape(shapePath.copyRef());</span>
  
<span class="line-modified">!         if (paths.marginShape.length()) {</span>
<span class="line-modified">!             auto marginShapePath = Inspector::Protocol::OverlayTypes::DisplayPath::create();</span>
<span class="line-modified">!             info.pathArray = &amp;marginShapePath.get();</span>
  
<span class="line-modified">!             paths.marginShape.apply([&amp;info](const PathElement&amp; pathElement) {</span>
<span class="line-modified">!                 appendPathSegment(info, pathElement);</span>
<span class="line-modified">!             });</span>
  
<span class="line-modified">!             shapeObject-&gt;setMarginShape(marginShapePath.copyRef());</span>
          }
      }
  
<span class="line-modified">!     return WTFMove(shapeObject);</span>
  }
  
<span class="line-modified">! static RefPtr&lt;Inspector::Protocol::OverlayTypes::ElementData&gt; buildObjectForElementData(Node* node, HighlightType)</span>
  {
<span class="line-modified">!     if (!is&lt;Element&gt;(node) || !node-&gt;document().frame())</span>
<span class="line-modified">!         return nullptr;</span>
  
<span class="line-modified">!     Element* effectiveElement = downcast&lt;Element&gt;(node);</span>
<span class="line-modified">!     if (node-&gt;isPseudoElement()) {</span>
<span class="line-modified">!         Element* hostElement = downcast&lt;PseudoElement&gt;(*node).hostElement();</span>
<span class="line-removed">-         if (!hostElement)</span>
<span class="line-removed">-             return nullptr;</span>
<span class="line-removed">-         effectiveElement = hostElement;</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     Element&amp; element = *effectiveElement;</span>
<span class="line-modified">!     bool isXHTML = element.document().isXHTMLDocument();</span>
<span class="line-modified">!     auto elementData = Inspector::Protocol::OverlayTypes::ElementData::create()</span>
<span class="line-modified">!         .setTagName(isXHTML ? element.nodeName() : element.nodeName().convertToASCIILowercase())</span>
<span class="line-modified">!         .setIdValue(element.getIdAttribute())</span>
<span class="line-modified">!         .release();</span>
<span class="line-modified">! </span>
<span class="line-modified">!     if (element.hasClass() &amp;&amp; is&lt;StyledElement&gt;(element)) {</span>
<span class="line-modified">!         auto classes = JSON::ArrayOf&lt;String&gt;::create();</span>
<span class="line-modified">!         HashSet&lt;AtomicString&gt; usedClassNames;</span>
<span class="line-modified">!         const SpaceSplitString&amp; classNamesString = downcast&lt;StyledElement&gt;(element).classNames();</span>
<span class="line-modified">!         for (size_t i = 0; i &lt; classNamesString.size(); ++i) {</span>
<span class="line-modified">!             const AtomicString&amp; className = classNamesString[i];</span>
<span class="line-modified">!             if (usedClassNames.contains(className))</span>
<span class="line-modified">!                 continue;</span>
<span class="line-modified">! </span>
<span class="line-modified">!             usedClassNames.add(className);</span>
<span class="line-modified">!             classes-&gt;addItem(className);</span>
          }
<span class="line-removed">-         elementData-&gt;setClasses(WTFMove(classes));</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     if (node-&gt;isPseudoElement()) {</span>
<span class="line-modified">!         if (node-&gt;pseudoId() == PseudoId::Before)</span>
<span class="line-removed">-             elementData-&gt;setPseudoElement(&quot;before&quot;);</span>
<span class="line-removed">-         else if (node-&gt;pseudoId() == PseudoId::After)</span>
<span class="line-removed">-             elementData-&gt;setPseudoElement(&quot;after&quot;);</span>
      }
  
<span class="line-modified">!     RenderElement* renderer = element.renderer();</span>
<span class="line-modified">!     if (!renderer)</span>
<span class="line-modified">!         return nullptr;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     Frame* containingFrame = node-&gt;document().frame();</span>
<span class="line-modified">!     FrameView* containingView = containingFrame-&gt;view();</span>
<span class="line-modified">!     IntRect boundingBox = snappedIntRect(containingView-&gt;contentsToRootView(renderer-&gt;absoluteBoundingBoxRect()));</span>
<span class="line-modified">!     RenderBoxModelObject* modelObject = is&lt;RenderBoxModelObject&gt;(*renderer) ? downcast&lt;RenderBoxModelObject&gt;(renderer) : nullptr;</span>
<span class="line-modified">!     auto sizeObject = Inspector::Protocol::OverlayTypes::Size::create()</span>
<span class="line-modified">!         .setWidth(modelObject ? adjustForAbsoluteZoom(roundToInt(modelObject-&gt;offsetWidth()), *modelObject) : boundingBox.width())</span>
<span class="line-modified">!         .setHeight(modelObject ? adjustForAbsoluteZoom(roundToInt(modelObject-&gt;offsetHeight()), *modelObject) : boundingBox.height())</span>
<span class="line-modified">!         .release();</span>
<span class="line-modified">!     elementData-&gt;setSize(WTFMove(sizeObject));</span>
<span class="line-modified">! </span>
<span class="line-modified">!     if (is&lt;RenderBox&gt;(*renderer)) {</span>
<span class="line-modified">!         auto&amp; renderBox = downcast&lt;RenderBox&gt;(*renderer);</span>
<span class="line-modified">!         if (RefPtr&lt;Inspector::Protocol::OverlayTypes::ShapeOutsideData&gt; shapeObject = buildObjectForShapeOutside(containingFrame, &amp;renderBox))</span>
<span class="line-removed">-             elementData-&gt;setShapeOutsideData(WTFMove(shapeObject));</span>
      }
  
      // Need to enable AX to get the computed role.
      if (!WebCore::AXObjectCache::accessibilityEnabled())
          WebCore::AXObjectCache::enableAccessibility();
  
<span class="line-modified">!     if (AXObjectCache* axObjectCache = node-&gt;document().axObjectCache()) {</span>
<span class="line-modified">!         if (AccessibilityObject* axObject = axObjectCache-&gt;getOrCreate(node))</span>
<span class="line-modified">!             elementData-&gt;setRole(axObject-&gt;computedRoleString());</span>
      }
  
<span class="line-modified">!     return WTFMove(elementData);</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! RefPtr&lt;Inspector::Protocol::OverlayTypes::NodeHighlightData&gt; InspectorOverlay::buildHighlightObjectForNode(Node* node, HighlightType type) const</span>
<span class="line-modified">! {</span>
<span class="line-removed">-     if (!node)</span>
<span class="line-removed">-         return nullptr;</span>
  
<span class="line-modified">!     RenderObject* renderer = node-&gt;renderer();</span>
<span class="line-removed">-     if (!renderer)</span>
<span class="line-removed">-         return nullptr;</span>
  
<span class="line-modified">!     RefPtr&lt;JSON::ArrayOf&lt;Inspector::Protocol::OverlayTypes::FragmentHighlightData&gt;&gt; arrayOfFragmentHighlights = buildArrayForRendererFragments(renderer, m_nodeHighlightConfig);</span>
<span class="line-modified">!     if (!arrayOfFragmentHighlights)</span>
<span class="line-modified">!         return nullptr;</span>
  
<span class="line-modified">!     // The main view&#39;s scroll offset is shared across all quads.</span>
<span class="line-modified">!     FrameView* mainView = m_page.mainFrame().view();</span>
  
<span class="line-modified">!     auto nodeHighlightObject = Inspector::Protocol::OverlayTypes::NodeHighlightData::create()</span>
<span class="line-modified">!         .setScrollOffset(buildObjectForPoint(!mainView-&gt;delegatesScrolling() ? mainView-&gt;visibleContentRect().location() : FloatPoint()))</span>
<span class="line-removed">-         .setFragments(WTFMove(arrayOfFragmentHighlights))</span>
<span class="line-removed">-         .release();</span>
  
<span class="line-modified">!     if (m_nodeHighlightConfig.showInfo) {</span>
<span class="line-modified">!         if (RefPtr&lt;Inspector::Protocol::OverlayTypes::ElementData&gt; elementData = buildObjectForElementData(node, type))</span>
<span class="line-modified">!             nodeHighlightObject-&gt;setElementData(WTFMove(elementData));</span>
      }
  
<span class="line-modified">!     return WTFMove(nodeHighlightObject);</span>
<span class="line-removed">- }</span>
  
<span class="line-modified">! Ref&lt;JSON::ArrayOf&lt;Inspector::Protocol::OverlayTypes::NodeHighlightData&gt;&gt; InspectorOverlay::buildObjectForHighlightedNodes() const</span>
<span class="line-modified">! {</span>
<span class="line-removed">-     auto highlights = JSON::ArrayOf&lt;Inspector::Protocol::OverlayTypes::NodeHighlightData&gt;::create();</span>
  
<span class="line-modified">!     if (m_highlightNode) {</span>
<span class="line-modified">!         if (RefPtr&lt;Inspector::Protocol::OverlayTypes::NodeHighlightData&gt; nodeHighlightData = buildHighlightObjectForNode(m_highlightNode.get(), HighlightType::Node))</span>
<span class="line-modified">!             highlights-&gt;addItem(WTFMove(nodeHighlightData));</span>
<span class="line-modified">!     } else if (m_highlightNodeList) {</span>
<span class="line-modified">!         for (unsigned i = 0; i &lt; m_highlightNodeList-&gt;length(); ++i) {</span>
<span class="line-modified">!             if (RefPtr&lt;Inspector::Protocol::OverlayTypes::NodeHighlightData&gt; nodeHighlightData = buildHighlightObjectForNode(m_highlightNodeList-&gt;item(i), HighlightType::NodeList))</span>
<span class="line-modified">!                 highlights-&gt;addItem(WTFMove(nodeHighlightData));</span>
<span class="line-modified">!         }</span>
      }
  
<span class="line-modified">!     return highlights;</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! void InspectorOverlay::drawNodeHighlight()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     if (m_highlightNode || m_highlightNodeList)</span>
<span class="line-removed">-         evaluateInOverlay(&quot;drawNodeHighlight&quot;, buildObjectForHighlightedNodes());</span>
<span class="line-removed">- }</span>
  
<span class="line-modified">! void InspectorOverlay::drawQuadHighlight()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     if (!m_highlightQuad)</span>
<span class="line-removed">-         return;</span>
  
<span class="line-modified">!     Highlight highlight;</span>
<span class="line-modified">!     buildQuadHighlight(*m_highlightQuad, m_quadHighlightConfig, highlight);</span>
<span class="line-removed">-     evaluateInOverlay(&quot;drawQuadHighlight&quot;, buildObjectForHighlight(highlight));</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void InspectorOverlay::drawPausedInDebuggerMessage()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     if (!m_pausedInDebuggerMessage.isNull())</span>
<span class="line-removed">-         evaluateInOverlay(&quot;drawPausedInDebuggerMessage&quot;, m_pausedInDebuggerMessage);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- Page* InspectorOverlay::overlayPage()</span>
<span class="line-removed">- {</span>
<span class="line-removed">- #if PLATFORM(IOS_FAMILY)</span>
<span class="line-removed">-     return nullptr;</span>
<span class="line-removed">- #else</span>
<span class="line-removed">-     if (m_overlayPage)</span>
<span class="line-removed">-         return m_overlayPage.get();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto pageConfiguration = pageConfigurationWithEmptyClients();</span>
<span class="line-removed">-     m_overlayPage = std::make_unique&lt;Page&gt;(WTFMove(pageConfiguration));</span>
<span class="line-removed">-     m_overlayPage-&gt;setDeviceScaleFactor(m_page.deviceScaleFactor());</span>
<span class="line-removed">- </span>
<span class="line-removed">-     Settings&amp; settings = m_page.settings();</span>
<span class="line-removed">-     Settings&amp; overlaySettings = m_overlayPage-&gt;settings();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     overlaySettings.setStandardFontFamily(settings.standardFontFamily());</span>
<span class="line-removed">-     overlaySettings.setSerifFontFamily(settings.serifFontFamily());</span>
<span class="line-removed">-     overlaySettings.setSansSerifFontFamily(settings.sansSerifFontFamily());</span>
<span class="line-removed">-     overlaySettings.setCursiveFontFamily(settings.cursiveFontFamily());</span>
<span class="line-removed">-     overlaySettings.setFantasyFontFamily(settings.fantasyFontFamily());</span>
<span class="line-removed">-     overlaySettings.setPictographFontFamily(settings.pictographFontFamily());</span>
<span class="line-removed">-     overlaySettings.setMinimumFontSize(settings.minimumFontSize());</span>
<span class="line-removed">-     overlaySettings.setMinimumLogicalFontSize(settings.minimumLogicalFontSize());</span>
<span class="line-removed">-     overlaySettings.setMediaEnabled(false);</span>
<span class="line-removed">-     overlaySettings.setScriptEnabled(true);</span>
<span class="line-removed">-     overlaySettings.setPluginsEnabled(false);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     Frame&amp; frame = m_overlayPage-&gt;mainFrame();</span>
<span class="line-removed">-     frame.setView(FrameView::create(frame));</span>
<span class="line-removed">-     frame.init();</span>
<span class="line-removed">-     FrameLoader&amp; loader = frame.loader();</span>
<span class="line-removed">-     frame.view()-&gt;setCanHaveScrollbars(false);</span>
<span class="line-removed">-     frame.view()-&gt;setTransparent(true);</span>
<span class="line-removed">-     ASSERT(loader.activeDocumentLoader());</span>
<span class="line-removed">-     auto&amp; writer = loader.activeDocumentLoader()-&gt;writer();</span>
<span class="line-removed">-     writer.setMIMEType(&quot;text/html&quot;);</span>
<span class="line-removed">-     writer.begin();</span>
<span class="line-removed">-     writer.insertDataSynchronously(String(reinterpret_cast&lt;const char*&gt;(InspectorOverlayPage_html), sizeof(InspectorOverlayPage_html)));</span>
<span class="line-removed">-     writer.end();</span>
<span class="line-removed">- </span>
<span class="line-removed">- #if OS(WINDOWS)</span>
<span class="line-removed">-     evaluateInOverlay(&quot;setPlatform&quot;, &quot;windows&quot;);</span>
<span class="line-removed">- #elif OS(MAC_OS_X)</span>
<span class="line-removed">-     evaluateInOverlay(&quot;setPlatform&quot;, &quot;mac&quot;);</span>
<span class="line-removed">- #elif OS(UNIX)</span>
<span class="line-removed">-     evaluateInOverlay(&quot;setPlatform&quot;, &quot;linux&quot;);</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
<span class="line-removed">-     return m_overlayPage.get();</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void InspectorOverlay::forcePaint()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     // This overlay page is very weird and doesn&#39;t automatically paint. We have to force paints manually.</span>
<span class="line-removed">-     m_client-&gt;highlight();</span>
<span class="line-removed">- }</span>
  
<span class="line-modified">! void InspectorOverlay::reset(const IntSize&amp; viewportSize, const IntPoint&amp; scrollOffset)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     auto configObject = Inspector::Protocol::OverlayTypes::OverlayConfiguration::create()</span>
<span class="line-removed">-         .setDeviceScaleFactor(m_page.deviceScaleFactor())</span>
<span class="line-removed">-         .setViewportSize(buildObjectForSize(viewportSize))</span>
<span class="line-removed">-         .setPageScaleFactor(m_page.pageScaleFactor())</span>
<span class="line-removed">-         .setPageZoomFactor(m_page.mainFrame().pageZoomFactor())</span>
<span class="line-removed">-         .setScrollOffset(buildObjectForPoint(scrollOffset))</span>
<span class="line-removed">-         .setContentInset(buildObjectForSize(IntSize(0, m_page.mainFrame().view()-&gt;topContentInset(ScrollView::TopContentInsetType::WebCoreOrPlatformContentInset))))</span>
<span class="line-removed">-         .setShowRulers(m_showRulers)</span>
<span class="line-removed">-         .release();</span>
<span class="line-removed">-     evaluateInOverlay(&quot;reset&quot;, WTFMove(configObject));</span>
<span class="line-removed">- }</span>
  
<span class="line-modified">! static void evaluateCommandInOverlay(Page* page, Ref&lt;JSON::Array&gt;&amp;&amp; command)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     if (!page)</span>
<span class="line-removed">-         return;</span>
  
<span class="line-modified">!     page-&gt;mainFrame().script().evaluate(ScriptSourceCode(makeString(&quot;dispatch(&quot;, command-&gt;toJSONString(), &#39;)&#39;)));</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! void InspectorOverlay::evaluateInOverlay(const String&amp; method)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     Ref&lt;JSON::Array&gt; command = JSON::Array::create();</span>
<span class="line-removed">-     command-&gt;pushString(method);</span>
  
<span class="line-modified">!     evaluateCommandInOverlay(overlayPage(), WTFMove(command));</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! void InspectorOverlay::evaluateInOverlay(const String&amp; method, const String&amp; argument)</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     Ref&lt;JSON::Array&gt; command = JSON::Array::create();</span>
<span class="line-removed">-     command-&gt;pushString(method);</span>
<span class="line-removed">-     command-&gt;pushString(argument);</span>
  
<span class="line-modified">!     evaluateCommandInOverlay(overlayPage(), WTFMove(command));</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! void InspectorOverlay::evaluateInOverlay(const String&amp; method, RefPtr&lt;JSON::Value&gt;&amp;&amp; argument)</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     Ref&lt;JSON::Array&gt; command = JSON::Array::create();</span>
<span class="line-removed">-     command-&gt;pushString(method);</span>
<span class="line-removed">-     command-&gt;pushValue(WTFMove(argument));</span>
  
<span class="line-modified">!     evaluateCommandInOverlay(overlayPage(), WTFMove(command));</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! void InspectorOverlay::freePage()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     m_overlayPage = nullptr;</span>
  }
  
  } // namespace WebCore
<span class="line-new-header">--- 565,534 ---</span>
      }
  
      if (m_paintRects.isEmpty())
          m_paintRectUpdateTimer.stop();
  
<span class="line-modified">!     if (rectsChanged)</span>
<span class="line-modified">!         update();</span>
  }
  
<span class="line-modified">! InspectorOverlay::RulerExclusion InspectorOverlay::drawNodeHighlight(GraphicsContext&amp; context, Node&amp; node)</span>
  {
<span class="line-modified">!     RulerExclusion rulerExclusion;</span>
  
<span class="line-modified">!     drawFragmentHighlight(context, node, m_nodeHighlightConfig, rulerExclusion.bounds);</span>
  
<span class="line-modified">!     if (m_nodeHighlightConfig.showInfo)</span>
<span class="line-modified">!         drawShapeHighlight(context, node, rulerExclusion.bounds);</span>
<span class="line-modified">! </span>
<span class="line-added">+     if (m_showRulers || m_showRulersDuringElementSelection)</span>
<span class="line-added">+         drawBounds(context, rulerExclusion.bounds);</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Ensure that the title information is drawn after the bounds.</span>
<span class="line-added">+     if (m_nodeHighlightConfig.showInfo)</span>
<span class="line-added">+         rulerExclusion.titlePath = drawElementTitle(context, node, rulerExclusion.bounds);</span>
<span class="line-added">+ </span>
<span class="line-added">+     return rulerExclusion;</span>
  }
  
<span class="line-modified">! InspectorOverlay::RulerExclusion InspectorOverlay::drawQuadHighlight(GraphicsContext&amp; context, const FloatQuad&amp; quad)</span>
  {
<span class="line-modified">!     RulerExclusion rulerExclusion;</span>
  
      Highlight highlight;
<span class="line-modified">!     buildQuadHighlight(quad, m_quadHighlightConfig, highlight);</span>
<span class="line-modified">! </span>
<span class="line-added">+     if (highlight.quads.size() &gt;= 1) {</span>
<span class="line-added">+         drawOutlinedQuad(context, highlight.quads[0], highlight.contentColor, highlight.contentOutlineColor, rulerExclusion.bounds);</span>
  
<span class="line-modified">!         if (m_showRulers || m_showRulersDuringElementSelection)</span>
<span class="line-added">+             drawBounds(context, rulerExclusion.bounds);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     return rulerExclusion;</span>
  }
  
<span class="line-modified">! void InspectorOverlay::drawPaintRects(GraphicsContext&amp; context, const Deque&lt;TimeRectPair&gt;&amp; paintRects)</span>
  {
<span class="line-modified">!     GraphicsContextStateSaver stateSaver(context);</span>
  
<span class="line-modified">!     const Color paintRectsColor(1.0f, 0.0f, 0.0f, 0.5f);</span>
<span class="line-modified">!     context.setFillColor(paintRectsColor);</span>
  
<span class="line-modified">!     for (const TimeRectPair&amp; pair : paintRects)</span>
<span class="line-added">+         context.fillRect(pair.second);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void InspectorOverlay::drawBounds(GraphicsContext&amp; context, const Highlight::Bounds&amp; bounds)</span>
  {
<span class="line-modified">!     FrameView* pageView = m_page.mainFrame().view();</span>
<span class="line-modified">!     FloatSize viewportSize = pageView-&gt;sizeForVisibleContent();</span>
<span class="line-modified">!     FloatSize contentInset(0, pageView-&gt;topContentInset(ScrollView::TopContentInsetType::WebCoreOrPlatformContentInset));</span>
<span class="line-modified">! </span>
<span class="line-modified">!     Path path;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     if (bounds.y() &gt; contentInset.height()) {</span>
<span class="line-added">+         path.moveTo({ bounds.x(), bounds.y() });</span>
<span class="line-added">+         path.addLineTo({ bounds.x(), contentInset.height() });</span>
<span class="line-added">+ </span>
<span class="line-added">+         path.moveTo({ bounds.maxX(), bounds.y() });</span>
<span class="line-added">+         path.addLineTo({ bounds.maxX(), contentInset.height() });</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (bounds.maxY() &lt; viewportSize.height()) {</span>
<span class="line-added">+         path.moveTo({ bounds.x(), viewportSize.height() });</span>
<span class="line-added">+         path.addLineTo({ bounds.x(), bounds.maxY() });</span>
<span class="line-added">+ </span>
<span class="line-added">+         path.moveTo({ bounds.maxX(), viewportSize.height() });</span>
<span class="line-added">+         path.addLineTo({ bounds.maxX(), bounds.maxY() });</span>
      }
  
<span class="line-modified">!     if (bounds.x() &gt; contentInset.width()) {</span>
<span class="line-modified">!         path.moveTo({ bounds.x(), bounds.y() });</span>
<span class="line-modified">!         path.addLineTo({ contentInset.width(), bounds.y() });</span>
<span class="line-modified">! </span>
<span class="line-modified">!         path.moveTo({ bounds.x(), bounds.maxY() });</span>
<span class="line-modified">!         path.addLineTo({ contentInset.width(), bounds.maxY() });</span>
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     if (bounds.maxX() &lt; viewportSize.width()) {</span>
<span class="line-modified">!         path.moveTo({ bounds.maxX(), bounds.y() });</span>
<span class="line-modified">!         path.addLineTo({ viewportSize.width(), bounds.y() });</span>
<span class="line-modified">! </span>
<span class="line-modified">!         path.moveTo({ bounds.maxX(), bounds.maxY() });</span>
<span class="line-modified">!         path.addLineTo({ viewportSize.width(), bounds.maxY() });</span>
      }
<span class="line-added">+ </span>
<span class="line-added">+     GraphicsContextStateSaver stateSaver(context);</span>
<span class="line-added">+ </span>
<span class="line-added">+     context.setStrokeThickness(1);</span>
<span class="line-added">+ </span>
<span class="line-added">+     const Color boundsColor(1.0f, 0.0f, 0.0f, 0.6f);</span>
<span class="line-added">+     context.setStrokeColor(boundsColor);</span>
<span class="line-added">+ </span>
<span class="line-added">+     context.strokePath(path);</span>
  }
  
<span class="line-modified">! void InspectorOverlay::drawRulers(GraphicsContext&amp; context, const InspectorOverlay::RulerExclusion&amp; rulerExclusion)</span>
  {
<span class="line-modified">!     const Color rulerBackgroundColor(1.0f, 1.0f, 1.0f, 0.6f);</span>
<span class="line-modified">!     const Color lightRulerColor(0.0f, 0.0f, 0.0f, 0.2f);</span>
<span class="line-modified">!     const Color darkRulerColor(0.0f, 0.0f, 0.0f, 0.5f);</span>
<span class="line-added">+ </span>
<span class="line-added">+     IntPoint scrollOffset;</span>
<span class="line-added">+ </span>
<span class="line-added">+     FrameView* pageView = m_page.mainFrame().view();</span>
<span class="line-added">+     if (!pageView-&gt;delegatesScrolling())</span>
<span class="line-added">+         scrollOffset = pageView-&gt;visibleContentRect().location();</span>
<span class="line-added">+ </span>
<span class="line-added">+     FloatSize viewportSize = pageView-&gt;sizeForVisibleContent();</span>
<span class="line-added">+     FloatSize contentInset(0, pageView-&gt;topContentInset(ScrollView::TopContentInsetType::WebCoreOrPlatformContentInset));</span>
<span class="line-added">+     float pageScaleFactor = m_page.pageScaleFactor();</span>
<span class="line-added">+     float pageZoomFactor = m_page.mainFrame().pageZoomFactor();</span>
<span class="line-added">+ </span>
<span class="line-added">+     float pageFactor = pageZoomFactor * pageScaleFactor;</span>
<span class="line-added">+     float scrollX = scrollOffset.x() * pageScaleFactor;</span>
<span class="line-added">+     float scrollY = scrollOffset.y() * pageScaleFactor;</span>
<span class="line-added">+ </span>
<span class="line-added">+     const auto zoom = [&amp;] (float value) -&gt; float {</span>
<span class="line-added">+         return value * pageFactor;</span>
<span class="line-added">+     };</span>
<span class="line-added">+ </span>
<span class="line-added">+     const auto unzoom = [&amp;] (float value) -&gt; float {</span>
<span class="line-added">+         return value / pageFactor;</span>
<span class="line-added">+     };</span>
<span class="line-added">+ </span>
<span class="line-added">+     const auto multipleBelow = [&amp;] (float value, float step) -&gt; float {</span>
<span class="line-added">+         return value - std::fmod(value, step);</span>
<span class="line-added">+     };</span>
<span class="line-added">+ </span>
<span class="line-added">+     float width = viewportSize.width() / pageFactor;</span>
<span class="line-added">+     float height = viewportSize.height() / pageFactor;</span>
<span class="line-added">+     float minX = unzoom(scrollX);</span>
<span class="line-added">+     float minY = unzoom(scrollY);</span>
<span class="line-added">+     float maxX = minX + width;</span>
<span class="line-added">+     float maxY = minY + height;</span>
<span class="line-added">+ </span>
<span class="line-added">+     bool drawTopEdge = true;</span>
<span class="line-added">+     bool drawLeftEdge = true;</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Determine which side (top/bottom and left/right) to draw the rulers.</span>
<span class="line-added">+     {</span>
<span class="line-added">+         FloatRect topEdge(contentInset.width(), contentInset.height(), zoom(width) - contentInset.width(), rulerSize);</span>
<span class="line-added">+         FloatRect bottomEdge(contentInset.width(), zoom(height) - rulerSize, zoom(width) - contentInset.width(), rulerSize);</span>
<span class="line-added">+         drawTopEdge = !rulerExclusion.bounds.intersects(topEdge) || rulerExclusion.bounds.intersects(bottomEdge);</span>
<span class="line-added">+ </span>
<span class="line-added">+         FloatRect rightEdge(zoom(width) - rulerSize, contentInset.height(), rulerSize, zoom(height) - contentInset.height());</span>
<span class="line-added">+         FloatRect leftEdge(contentInset.width(), contentInset.height(), rulerSize, zoom(height) - contentInset.height());</span>
<span class="line-added">+         drawLeftEdge = !rulerExclusion.bounds.intersects(leftEdge) || rulerExclusion.bounds.intersects(rightEdge);</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     float cornerX = drawLeftEdge ? contentInset.width() : zoom(width) - rulerSize;</span>
<span class="line-modified">!     float cornerY = drawTopEdge ? contentInset.height() : zoom(height) - rulerSize;</span>
  
<span class="line-modified">!     // Draw backgrounds.</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         GraphicsContextStateSaver backgroundStateSaver(context);</span>
  
<span class="line-modified">!         context.setFillColor(rulerBackgroundColor);</span>
  
<span class="line-modified">!         context.fillRect({ cornerX, cornerY, rulerSize, rulerSize });</span>
<span class="line-modified">! </span>
<span class="line-modified">!         if (drawLeftEdge)</span>
<span class="line-modified">!             context.fillRect({ cornerX + rulerSize, cornerY, zoom(width) - cornerX - rulerSize, rulerSize });</span>
<span class="line-modified">!         else</span>
<span class="line-modified">!             context.fillRect({ contentInset.width(), cornerY, cornerX - contentInset.width(), rulerSize });</span>
<span class="line-modified">! </span>
<span class="line-modified">!         if (drawTopEdge)</span>
<span class="line-modified">!             context.fillRect({ cornerX, cornerY + rulerSize, rulerSize, zoom(height) - cornerY - rulerSize });</span>
<span class="line-modified">!         else</span>
<span class="line-modified">!             context.fillRect({ cornerX, contentInset.height(), rulerSize, cornerY - contentInset.height() });</span>
<span class="line-modified">!     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Draw lines.</span>
<span class="line-added">+     {</span>
<span class="line-added">+         FontCascadeDescription fontDescription;</span>
<span class="line-added">+         fontDescription.setOneFamily(m_page.settings().sansSerifFontFamily());</span>
<span class="line-added">+         fontDescription.setComputedSize(10);</span>
<span class="line-added">+ </span>
<span class="line-added">+         FontCascade font(WTFMove(fontDescription), 0, 0);</span>
<span class="line-added">+         font.update(nullptr);</span>
<span class="line-added">+ </span>
<span class="line-added">+         GraphicsContextStateSaver lineStateSaver(context);</span>
<span class="line-added">+ </span>
<span class="line-added">+         context.setFillColor(darkRulerColor);</span>
<span class="line-added">+         context.setStrokeThickness(1);</span>
<span class="line-added">+ </span>
<span class="line-added">+         // Draw horizontal ruler.</span>
<span class="line-added">+         {</span>
<span class="line-added">+             GraphicsContextStateSaver horizontalRulerStateSaver(context);</span>
<span class="line-added">+ </span>
<span class="line-added">+             context.translate(contentInset.width() - scrollX + 0.5f, cornerY - scrollY);</span>
<span class="line-added">+ </span>
<span class="line-added">+             for (float x = multipleBelow(minX, rulerSubStepIncrement); x &lt; maxX; x += rulerSubStepIncrement) {</span>
<span class="line-added">+                 if (!x &amp;&amp; !scrollX)</span>
<span class="line-added">+                     continue;</span>
<span class="line-added">+ </span>
<span class="line-added">+                 Path path;</span>
<span class="line-added">+                 path.moveTo({ zoom(x), drawTopEdge ? scrollY : scrollY + rulerSize });</span>
<span class="line-added">+ </span>
<span class="line-added">+                 float lineLength = 0.0f;</span>
<span class="line-added">+                 if (std::fmod(x, rulerStepIncrement)) {</span>
<span class="line-added">+                     lineLength = rulerSubStepLength;</span>
<span class="line-added">+                     context.setStrokeColor(lightRulerColor);</span>
<span class="line-added">+                 } else {</span>
<span class="line-added">+                     lineLength = std::fmod(x, rulerStepIncrement * 2) ? rulerSubStepLength : rulerStepLength;</span>
<span class="line-added">+                     context.setStrokeColor(darkRulerColor);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 path.addLineTo({ zoom(x), scrollY + (drawTopEdge ? lineLength : rulerSize - lineLength) });</span>
  
<span class="line-modified">!                 context.strokePath(path);</span>
<span class="line-added">+             }</span>
  
<span class="line-modified">!             // Draw labels.</span>
<span class="line-modified">!             for (float x = multipleBelow(minX, rulerStepIncrement * 2); x &lt; maxX; x += rulerStepIncrement * 2) {</span>
<span class="line-modified">!                 if (!x &amp;&amp; !scrollX)</span>
<span class="line-added">+                     continue;</span>
  
<span class="line-modified">!                 GraphicsContextStateSaver verticalLabelStateSaver(context);</span>
<span class="line-modified">!                 context.translate(zoom(x) + 0.5f, scrollY);</span>
<span class="line-modified">!                 context.drawText(font, TextRun(String::numberToStringFixedPrecision(x)), { 2, drawTopEdge ? rulerLabelSize : rulerLabelSize - rulerSize + font.fontMetrics().height() - 1.0f });</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
  
<span class="line-modified">!         // Draw vertical ruler.</span>
<span class="line-added">+         {</span>
<span class="line-added">+             GraphicsContextStateSaver veritcalRulerStateSaver(context);</span>
<span class="line-added">+ </span>
<span class="line-added">+             context.translate(cornerX - scrollX, contentInset.height() - scrollY + 0.5f);</span>
<span class="line-added">+ </span>
<span class="line-added">+             for (float y = multipleBelow(minY, rulerSubStepIncrement); y &lt; maxY; y += rulerSubStepIncrement) {</span>
<span class="line-added">+                 if (!y &amp;&amp; !scrollY)</span>
<span class="line-added">+                     continue;</span>
<span class="line-added">+ </span>
<span class="line-added">+                 Path path;</span>
<span class="line-added">+                 path.moveTo({ drawLeftEdge ? scrollX : scrollX + rulerSize, zoom(y) });</span>
<span class="line-added">+ </span>
<span class="line-added">+                 float lineLength = 0.0f;</span>
<span class="line-added">+                 if (std::fmod(y, rulerStepIncrement)) {</span>
<span class="line-added">+                     lineLength = rulerSubStepLength;</span>
<span class="line-added">+                     context.setStrokeColor(lightRulerColor);</span>
<span class="line-added">+                 } else {</span>
<span class="line-added">+                     lineLength = std::fmod(y, rulerStepIncrement * 2) ? rulerSubStepLength : rulerStepLength;</span>
<span class="line-added">+                     context.setStrokeColor(darkRulerColor);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 path.addLineTo({ scrollX + (drawLeftEdge ? lineLength : rulerSize - lineLength), zoom(y) });</span>
<span class="line-added">+ </span>
<span class="line-added">+                 context.strokePath(path);</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
<span class="line-added">+             // Draw labels.</span>
<span class="line-added">+             for (float y = multipleBelow(minY, rulerStepIncrement * 2); y &lt; maxY; y += rulerStepIncrement * 2) {</span>
<span class="line-added">+                 if (!y &amp;&amp; !scrollY)</span>
<span class="line-added">+                     continue;</span>
<span class="line-added">+ </span>
<span class="line-added">+                 GraphicsContextStateSaver horizontalLabelStateSaver(context);</span>
<span class="line-added">+                 context.translate(scrollX, zoom(y) + 0.5f);</span>
<span class="line-added">+                 context.rotate(drawLeftEdge ? -piOverTwoFloat : piOverTwoFloat);</span>
<span class="line-added">+                 context.drawText(font, TextRun(String::numberToStringFixedPrecision(y)), { 2, drawLeftEdge ? rulerLabelSize : rulerLabelSize - rulerSize });</span>
<span class="line-added">+             }</span>
          }
      }
  
<span class="line-modified">!     // Draw viewport size.</span>
<span class="line-added">+     {</span>
<span class="line-added">+         FontCascadeDescription fontDescription;</span>
<span class="line-added">+         fontDescription.setOneFamily(m_page.settings().sansSerifFontFamily());</span>
<span class="line-added">+         fontDescription.setComputedSize(12);</span>
<span class="line-added">+ </span>
<span class="line-added">+         FontCascade font(WTFMove(fontDescription), 0, 0);</span>
<span class="line-added">+         font.update(nullptr);</span>
<span class="line-added">+ </span>
<span class="line-added">+         auto viewportRect = pageView-&gt;visualViewportRect();</span>
<span class="line-added">+         auto viewportWidthText = String::numberToStringFixedPrecision(viewportRect.width() / pageZoomFactor);</span>
<span class="line-added">+         auto viewportHeightText = String::numberToStringFixedPrecision(viewportRect.height() / pageZoomFactor);</span>
<span class="line-added">+         TextRun viewportTextRun(makeString(viewportWidthText, &quot;px&quot;, &#39; &#39;, multiplicationSign, &#39; &#39;, viewportHeightText, &quot;px&quot;));</span>
<span class="line-added">+ </span>
<span class="line-added">+         const float margin = 4;</span>
<span class="line-added">+         const float padding = 2;</span>
<span class="line-added">+         const float radius = 4;</span>
<span class="line-added">+         float fontWidth = font.width(viewportTextRun);</span>
<span class="line-added">+         float fontHeight = font.fontMetrics().floatHeight();</span>
<span class="line-added">+         FloatRect viewportTextRect(margin, margin, (padding * 2.0f) + fontWidth, (padding * 2.0f) + fontHeight);</span>
<span class="line-added">+         const auto viewportTextRectCenter = viewportTextRect.center();</span>
<span class="line-added">+ </span>
<span class="line-added">+         GraphicsContextStateSaver viewportSizeStateSaver(context);</span>
<span class="line-added">+ </span>
<span class="line-added">+         float leftTranslateX = rulerSize;</span>
<span class="line-added">+         float rightTranslateX = 0.0f - (margin * 2.0f) - (padding * 2.0f) - fontWidth;</span>
<span class="line-added">+         float translateX = cornerX + (drawLeftEdge ? leftTranslateX : rightTranslateX);</span>
<span class="line-added">+ </span>
<span class="line-added">+         float topTranslateY = rulerSize;</span>
<span class="line-added">+         float bottomTranslateY = 0.0f - (margin * 2.0f) - (padding * 2.0f) - fontHeight;</span>
<span class="line-added">+         float translateY = cornerY + (drawTopEdge ? topTranslateY : bottomTranslateY);</span>
<span class="line-added">+ </span>
<span class="line-added">+         FloatPoint translate(translateX, translateY);</span>
<span class="line-added">+         if (rulerExclusion.titlePath.contains(viewportTextRectCenter + translate)) {</span>
<span class="line-added">+             // Try the opposite horizontal side.</span>
<span class="line-added">+             float oppositeTranslateX = drawLeftEdge ? zoom(width) + rightTranslateX : contentInset.width() + leftTranslateX;</span>
<span class="line-added">+             translate.setX(oppositeTranslateX);</span>
<span class="line-added">+ </span>
<span class="line-added">+             if (rulerExclusion.titlePath.contains(viewportTextRectCenter + translate)) {</span>
<span class="line-added">+                 translate.setX(translateX);</span>
<span class="line-added">+ </span>
<span class="line-added">+                 // Try the opposite vertical side.</span>
<span class="line-added">+                 float oppositeTranslateY = drawTopEdge ? zoom(height) + bottomTranslateY : contentInset.height() + topTranslateY;</span>
<span class="line-added">+                 translate.setY(oppositeTranslateY);</span>
<span class="line-added">+ </span>
<span class="line-added">+                 if (rulerExclusion.titlePath.contains(viewportTextRectCenter + translate)) {</span>
<span class="line-added">+                     // Try the opposite corner.</span>
<span class="line-added">+                     translate.setX(oppositeTranslateX);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+         context.translate(translate);</span>
<span class="line-added">+ </span>
<span class="line-added">+         context.fillRoundedRect(FloatRoundedRect(viewportTextRect, FloatRoundedRect::Radii(radius)), rulerBackgroundColor);</span>
<span class="line-added">+ </span>
<span class="line-added">+         context.setFillColor(Color::black);</span>
<span class="line-added">+         context.drawText(font, viewportTextRun, {margin +  padding, margin + padding + fontHeight - font.fontMetrics().descent() });</span>
<span class="line-added">+     }</span>
  }
  
<span class="line-modified">! Path InspectorOverlay::drawElementTitle(GraphicsContext&amp; context, Node&amp; node, const Highlight::Bounds&amp; bounds)</span>
  {
<span class="line-modified">!     if (bounds.isEmpty())</span>
<span class="line-modified">!         return { };</span>
  
<span class="line-modified">!     Element* element = effectiveElementForNode(node);</span>
<span class="line-modified">!     if (!element)</span>
<span class="line-modified">!         return { };</span>
  
<span class="line-modified">!     RenderObject* renderer = node.renderer();</span>
<span class="line-modified">!     if (!renderer)</span>
<span class="line-modified">!         return { };</span>
<span class="line-modified">! </span>
<span class="line-modified">!     String elementTagName = element-&gt;nodeName();</span>
<span class="line-modified">!     if (!element-&gt;document().isXHTMLDocument())</span>
<span class="line-modified">!         elementTagName = elementTagName.convertToASCIILowercase();</span>
<span class="line-modified">! </span>
<span class="line-modified">!     String elementIDValue;</span>
<span class="line-modified">!     if (element-&gt;hasID())</span>
<span class="line-modified">!         elementIDValue = makeString(&#39;#&#39;, DOMCSSNamespace::escape(element-&gt;getIdAttribute()));</span>
<span class="line-modified">! </span>
<span class="line-modified">!     String elementClassValue;</span>
<span class="line-modified">!     if (element-&gt;hasClass()) {</span>
<span class="line-modified">!         StringBuilder builder;</span>
<span class="line-modified">!         DOMTokenList&amp; classList = element-&gt;classList();</span>
<span class="line-modified">!         for (size_t i = 0; i &lt; classList.length(); ++i) {</span>
<span class="line-modified">!             builder.append(&#39;.&#39;);</span>
<span class="line-added">+             builder.append(DOMCSSNamespace::escape(classList.item(i)));</span>
          }
  
<span class="line-modified">!         elementClassValue = builder.toString();</span>
<span class="line-modified">!         truncateWithEllipsis(elementClassValue, 50);</span>
      }
  
<span class="line-modified">!     String elementPseudoType;</span>
<span class="line-modified">!     if (node.isBeforePseudoElement())</span>
<span class="line-modified">!         elementPseudoType = &quot;::before&quot;_s;</span>
<span class="line-modified">!     else if (node.isAfterPseudoElement())</span>
<span class="line-modified">!         elementPseudoType = &quot;::after&quot;_s;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     String elementWidth;</span>
<span class="line-modified">!     String elementHeight;</span>
<span class="line-modified">!     if (is&lt;RenderBoxModelObject&gt;(renderer)) {</span>
<span class="line-modified">!         RenderBoxModelObject* modelObject = downcast&lt;RenderBoxModelObject&gt;(renderer);</span>
<span class="line-modified">!         elementWidth = String::number(adjustForAbsoluteZoom(roundToInt(modelObject-&gt;offsetWidth()), *modelObject));</span>
<span class="line-modified">!         elementHeight = String::number(adjustForAbsoluteZoom(roundToInt(modelObject-&gt;offsetHeight()), *modelObject));</span>
<span class="line-modified">!     } else {</span>
<span class="line-modified">!         FrameView* containingView = node.document().frame()-&gt;view();</span>
<span class="line-modified">!         IntRect boundingBox = snappedIntRect(containingView-&gt;contentsToRootView(renderer-&gt;absoluteBoundingBoxRect()));</span>
<span class="line-modified">!         elementWidth = String::number(boundingBox.width());</span>
<span class="line-modified">!         elementHeight = String::number(boundingBox.height());</span>
      }
  
      // Need to enable AX to get the computed role.
      if (!WebCore::AXObjectCache::accessibilityEnabled())
          WebCore::AXObjectCache::enableAccessibility();
  
<span class="line-modified">!     String elementRole;</span>
<span class="line-modified">!     if (AXObjectCache* axObjectCache = node.document().axObjectCache()) {</span>
<span class="line-modified">!         if (AccessibilityObject* axObject = axObjectCache-&gt;getOrCreate(&amp;node))</span>
<span class="line-added">+             elementRole = axObject-&gt;computedRoleString();</span>
      }
  
<span class="line-modified">!     FontCascadeDescription fontDescription;</span>
<span class="line-modified">!     fontDescription.setFamilies({ &quot;Menlo&quot;, m_page.settings().fixedFontFamily() });</span>
<span class="line-added">+     fontDescription.setComputedSize(11);</span>
  
<span class="line-modified">!     FontCascade font(WTFMove(fontDescription), 0, 0);</span>
<span class="line-modified">!     font.update(nullptr);</span>
  
<span class="line-modified">!     int fontHeight = font.fontMetrics().height();</span>
  
<span class="line-modified">!     float elementDataWidth;</span>
<span class="line-modified">!     float elementDataHeight = fontHeight;</span>
<span class="line-modified">!     bool hasSecondLine = !elementRole.isEmpty();</span>
  
<span class="line-modified">!     {</span>
<span class="line-modified">!         String firstLine = makeString(elementTagName, elementIDValue, elementClassValue, elementPseudoType, &#39; &#39;, elementWidth, &quot;px&quot;, &#39; &#39;, multiplicationSign, &#39; &#39;, elementHeight, &quot;px&quot;);</span>
<span class="line-added">+         String secondLine = makeString(&quot;Role &quot;, elementRole);</span>
  
<span class="line-modified">!         float firstLineWidth = font.width(TextRun(firstLine));</span>
<span class="line-modified">!         float secondLineWidth = font.width(TextRun(secondLine));</span>
  
<span class="line-modified">!         elementDataWidth = std::fmax(firstLineWidth, secondLineWidth);</span>
<span class="line-modified">!         if (hasSecondLine)</span>
<span class="line-modified">!             elementDataHeight += fontHeight;</span>
      }
  
<span class="line-modified">!     FrameView* pageView = m_page.mainFrame().view();</span>
  
<span class="line-modified">!     FloatSize viewportSize = pageView-&gt;sizeForVisibleContent();</span>
<span class="line-modified">!     viewportSize.expand(-elementDataSpacing, -elementDataSpacing);</span>
  
<span class="line-modified">!     FloatSize contentInset(0, pageView-&gt;topContentInset(ScrollView::TopContentInsetType::WebCoreOrPlatformContentInset));</span>
<span class="line-modified">!     contentInset.expand(elementDataSpacing, elementDataSpacing);</span>
<span class="line-modified">!     if (m_showRulers || m_showRulersDuringElementSelection)</span>
<span class="line-modified">!         contentInset.expand(rulerSize, rulerSize);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     float anchorTop = bounds.y();</span>
<span class="line-modified">!     float anchorBottom = bounds.maxY();</span>
<span class="line-modified">! </span>
<span class="line-added">+     bool renderArrowUp = false;</span>
<span class="line-added">+     bool renderArrowDown = false;</span>
<span class="line-added">+ </span>
<span class="line-added">+     float boxWidth = elementDataWidth + (elementDataSpacing * 2);</span>
<span class="line-added">+     float boxHeight = elementDataArrowSize + elementDataHeight + (elementDataSpacing * 2);</span>
<span class="line-added">+ </span>
<span class="line-added">+     float boxX = bounds.x();</span>
<span class="line-added">+     if (boxX &lt; contentInset.width())</span>
<span class="line-added">+         boxX = contentInset.width();</span>
<span class="line-added">+     else if (boxX &gt; viewportSize.width() - boxWidth)</span>
<span class="line-added">+         boxX = viewportSize.width() - boxWidth;</span>
<span class="line-added">+     else</span>
<span class="line-added">+         boxX += elementDataSpacing;</span>
<span class="line-added">+ </span>
<span class="line-added">+     float boxY;</span>
<span class="line-added">+     if (anchorTop &gt; viewportSize.height()) {</span>
<span class="line-added">+         boxY = viewportSize.height() - boxHeight;</span>
<span class="line-added">+         renderArrowDown = true;</span>
<span class="line-added">+     } else if (anchorBottom &lt; contentInset.height()) {</span>
<span class="line-added">+         boxY = contentInset.height() + elementDataArrowSize;</span>
<span class="line-added">+         renderArrowUp = true;</span>
<span class="line-added">+     } else if (anchorTop - boxHeight - elementDataSpacing &gt; contentInset.height()) {</span>
<span class="line-added">+         boxY = anchorTop - boxHeight - elementDataSpacing;</span>
<span class="line-added">+         renderArrowDown = true;</span>
<span class="line-added">+     } else if (anchorBottom + boxHeight + elementDataSpacing &lt; viewportSize.height()) {</span>
<span class="line-added">+         boxY = anchorBottom + elementDataArrowSize + elementDataSpacing;</span>
<span class="line-added">+         renderArrowUp = true;</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+         boxY = contentInset.height();</span>
<span class="line-added">+         renderArrowDown = true;</span>
      }
  
<span class="line-modified">!     Path path;</span>
<span class="line-modified">!     path.moveTo({ boxX, boxY });</span>
<span class="line-added">+     if (renderArrowUp) {</span>
<span class="line-added">+         path.addLineTo({ boxX + (elementDataArrowSize * 2), boxY });</span>
<span class="line-added">+         path.addLineTo({ boxX + (elementDataArrowSize * 3), boxY - elementDataArrowSize });</span>
<span class="line-added">+         path.addLineTo({ boxX + (elementDataArrowSize * 4), boxY });</span>
<span class="line-added">+     }</span>
<span class="line-added">+     path.addLineTo({ boxX + elementDataWidth + (elementDataSpacing * 2), boxY });</span>
<span class="line-added">+     path.addLineTo({ boxX + elementDataWidth + (elementDataSpacing * 2), boxY + elementDataHeight + (elementDataSpacing * 2) });</span>
<span class="line-added">+     if (renderArrowDown) {</span>
<span class="line-added">+         path.addLineTo({ boxX + (elementDataArrowSize * 4), boxY + elementDataHeight + (elementDataSpacing * 2) });</span>
<span class="line-added">+         path.addLineTo({ boxX + (elementDataArrowSize * 3), boxY + elementDataHeight + (elementDataSpacing * 2) + elementDataArrowSize });</span>
<span class="line-added">+         path.addLineTo({ boxX + (elementDataArrowSize * 2), boxY + elementDataHeight + (elementDataSpacing * 2) });</span>
<span class="line-added">+     }</span>
<span class="line-added">+     path.addLineTo({ boxX, boxY + elementDataHeight + (elementDataSpacing * 2) });</span>
<span class="line-added">+     path.closeSubpath();</span>
  
<span class="line-modified">!     GraphicsContextStateSaver stateSaver(context);</span>
  
<span class="line-modified">!     context.translate(elementDataBorderSize / 2.0f, elementDataBorderSize / 2.0f);</span>
  
<span class="line-modified">!     const Color elementTitleBackgroundColor(255, 255, 194);</span>
<span class="line-modified">!     context.setFillColor(elementTitleBackgroundColor);</span>
  
<span class="line-modified">!     context.fillPath(path);</span>
  
<span class="line-modified">!     context.setStrokeThickness(elementDataBorderSize);</span>
  
<span class="line-modified">!     const Color elementTitleBorderColor(128, 128, 128);</span>
<span class="line-modified">!     context.setStrokeColor(elementTitleBorderColor);</span>
  
<span class="line-modified">!     context.strokePath(path);</span>
  
<span class="line-modified">!     float textPositionX = boxX + elementDataSpacing;</span>
<span class="line-modified">!     float textPositionY = boxY - (elementDataSpacing / 2.0f) + fontHeight;</span>
<span class="line-added">+     const auto drawText = [&amp;] (const String&amp; text, const Color&amp; color) {</span>
<span class="line-added">+         if (text.isEmpty())</span>
<span class="line-added">+             return;</span>
  
<span class="line-modified">!         context.setFillColor(color);</span>
<span class="line-modified">!         textPositionX += context.drawText(font, TextRun(text), { textPositionX, textPositionY });</span>
<span class="line-modified">!     };</span>
  
<span class="line-modified">!     drawText(elementTagName, Color(136, 18, 128)); // Keep this in sync with XMLViewer.css (.tag)</span>
<span class="line-modified">!     drawText(elementIDValue, Color(26, 26, 166)); // Keep this in sync with XMLViewer.css (.attribute-value)</span>
<span class="line-added">+     drawText(elementClassValue, Color(153, 69, 0)); // Keep this in sync with XMLViewer.css (.attribute-name)</span>
<span class="line-added">+     drawText(elementPseudoType, Color(136, 18, 128)); // Keep this in sync with XMLViewer.css (.tag)</span>
<span class="line-added">+     drawText(&quot; &quot;_s, Color::black);</span>
<span class="line-added">+     drawText(elementWidth, Color::black);</span>
<span class="line-added">+     drawText(&quot;px&quot;_s, Color::darkGray);</span>
<span class="line-added">+     drawText(&quot; &quot;_s, Color::darkGray);</span>
<span class="line-added">+     drawText(makeString(multiplicationSign), Color::darkGray);</span>
<span class="line-added">+     drawText(&quot; &quot;_s, Color::darkGray);</span>
<span class="line-added">+     drawText(elementHeight, Color::black);</span>
<span class="line-added">+     drawText(&quot;px&quot;_s, Color::darkGray);</span>
  
<span class="line-modified">!     if (hasSecondLine) {</span>
<span class="line-modified">!         textPositionX = boxX + elementDataSpacing;</span>
<span class="line-modified">!         textPositionY += fontHeight;</span>
  
<span class="line-modified">!         drawText(&quot;Role&quot;_s, Color(170, 13, 145));</span>
<span class="line-modified">!         drawText(&quot; &quot;_s, Color::black);</span>
<span class="line-added">+         drawText(elementRole, Color::black);</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     return path;</span>
  }
  
  } // namespace WebCore
</pre>
<center><a href="InspectorNodeFinder.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="InspectorOverlay.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>