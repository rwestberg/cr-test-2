<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/xml/parser/XMLDocumentParserLibxml2.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="XMLDocumentParser.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../../../WebKitLegacy/CMakeLists.txt.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/xml/parser/XMLDocumentParserLibxml2.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  75     auto* frame = document.frame();
  76     if (!frame)
  77         return false;
  78 
  79     if (!frame-&gt;settings().developerExtrasEnabled())
  80         return false;
  81 
  82     if (frame-&gt;tree().parent())
  83         return false; // This document is not in a top frame
  84 
  85     return true;
  86 }
  87 
  88 #endif
  89 
  90 class PendingCallbacks {
  91     WTF_MAKE_FAST_ALLOCATED;
  92 public:
  93     void appendStartElementNSCallback(const xmlChar* xmlLocalName, const xmlChar* xmlPrefix, const xmlChar* xmlURI, int numNamespaces, const xmlChar** namespaces, int numAttributes, int numDefaulted, const xmlChar** attributes)
  94     {
<span class="line-modified">  95         auto callback = std::make_unique&lt;PendingStartElementNSCallback&gt;();</span>
  96 
  97         callback-&gt;xmlLocalName = xmlStrdup(xmlLocalName);
  98         callback-&gt;xmlPrefix = xmlStrdup(xmlPrefix);
  99         callback-&gt;xmlURI = xmlStrdup(xmlURI);
 100         callback-&gt;numNamespaces = numNamespaces;
 101         callback-&gt;namespaces = static_cast&lt;xmlChar**&gt;(xmlMalloc(sizeof(xmlChar*) * numNamespaces * 2));
 102         for (int i = 0; i &lt; numNamespaces * 2 ; i++)
 103             callback-&gt;namespaces[i] = xmlStrdup(namespaces[i]);
 104         callback-&gt;numAttributes = numAttributes;
 105         callback-&gt;numDefaulted = numDefaulted;
 106         callback-&gt;attributes = static_cast&lt;xmlChar**&gt;(xmlMalloc(sizeof(xmlChar*) * numAttributes * 5));
 107         for (int i = 0; i &lt; numAttributes; i++) {
 108             // Each attribute has 5 elements in the array:
 109             // name, prefix, uri, value and an end pointer.
 110 
 111             for (int j = 0; j &lt; 3; j++)
 112                 callback-&gt;attributes[i * 5 + j] = xmlStrdup(attributes[i * 5 + j]);
 113 
 114             int len = attributes[i * 5 + 4] - attributes[i * 5 + 3];
 115 
 116             callback-&gt;attributes[i * 5 + 3] = xmlStrndup(attributes[i * 5 + 3], len);
 117             callback-&gt;attributes[i * 5 + 4] = callback-&gt;attributes[i * 5 + 3] + len;
 118         }
 119 
 120         m_callbacks.append(WTFMove(callback));
 121     }
 122 
 123     void appendEndElementNSCallback()
 124     {
<span class="line-modified"> 125         m_callbacks.append(std::make_unique&lt;PendingEndElementNSCallback&gt;());</span>
 126     }
 127 
 128     void appendCharactersCallback(const xmlChar* s, int len)
 129     {
<span class="line-modified"> 130         auto callback = std::make_unique&lt;PendingCharactersCallback&gt;();</span>
 131 
 132         callback-&gt;s = xmlStrndup(s, len);
 133         callback-&gt;len = len;
 134 
 135         m_callbacks.append(WTFMove(callback));
 136     }
 137 
 138     void appendProcessingInstructionCallback(const xmlChar* target, const xmlChar* data)
 139     {
<span class="line-modified"> 140         auto callback = std::make_unique&lt;PendingProcessingInstructionCallback&gt;();</span>
 141 
 142         callback-&gt;target = xmlStrdup(target);
 143         callback-&gt;data = xmlStrdup(data);
 144 
 145         m_callbacks.append(WTFMove(callback));
 146     }
 147 
 148     void appendCDATABlockCallback(const xmlChar* s, int len)
 149     {
<span class="line-modified"> 150         auto callback = std::make_unique&lt;PendingCDATABlockCallback&gt;();</span>
 151 
 152         callback-&gt;s = xmlStrndup(s, len);
 153         callback-&gt;len = len;
 154 
 155         m_callbacks.append(WTFMove(callback));
 156     }
 157 
 158     void appendCommentCallback(const xmlChar* s)
 159     {
<span class="line-modified"> 160         auto callback = std::make_unique&lt;PendingCommentCallback&gt;();</span>
 161 
 162         callback-&gt;s = xmlStrdup(s);
 163 
 164         m_callbacks.append(WTFMove(callback));
 165     }
 166 
 167     void appendInternalSubsetCallback(const xmlChar* name, const xmlChar* externalID, const xmlChar* systemID)
 168     {
<span class="line-modified"> 169         auto callback = std::make_unique&lt;PendingInternalSubsetCallback&gt;();</span>
 170 
 171         callback-&gt;name = xmlStrdup(name);
 172         callback-&gt;externalID = xmlStrdup(externalID);
 173         callback-&gt;systemID = xmlStrdup(systemID);
 174 
 175         m_callbacks.append(WTFMove(callback));
 176     }
 177 
 178     void appendErrorCallback(XMLErrors::ErrorType type, const xmlChar* message, OrdinalNumber lineNumber, OrdinalNumber columnNumber)
 179     {
<span class="line-modified"> 180         auto callback = std::make_unique&lt;PendingErrorCallback&gt;();</span>
 181 
 182         callback-&gt;message = xmlStrdup(message);
 183         callback-&gt;type = type;
 184         callback-&gt;lineNumber = lineNumber;
 185         callback-&gt;columnNumber = columnNumber;
 186 
 187         m_callbacks.append(WTFMove(callback));
 188     }
 189 
 190     void callAndRemoveFirstCallback(XMLDocumentParser* parser)
 191     {
 192         std::unique_ptr&lt;PendingCallback&gt; callback = m_callbacks.takeFirst();
 193         callback-&gt;call(parser);
 194     }
 195 
 196     bool isEmpty() const { return m_callbacks.isEmpty(); }
 197 
 198 private:
 199     struct PendingCallback {

 200         virtual ~PendingCallback() = default;
 201         virtual void call(XMLDocumentParser* parser) = 0;
 202     };
 203 
 204     struct PendingStartElementNSCallback : public PendingCallback {
 205         virtual ~PendingStartElementNSCallback()
 206         {
 207             xmlFree(xmlLocalName);
 208             xmlFree(xmlPrefix);
 209             xmlFree(xmlURI);
 210             for (int i = 0; i &lt; numNamespaces * 2; i++)
 211                 xmlFree(namespaces[i]);
 212             xmlFree(namespaces);
 213             for (int i = 0; i &lt; numAttributes; i++) {
 214                 for (int j = 0; j &lt; 4; j++)
 215                     xmlFree(attributes[i * 5 + j]);
 216             }
 217             xmlFree(attributes);
 218         }
 219 
</pre>
<hr />
<pre>
 547     parser-&gt;instate = XML_PARSER_CONTENT; // We are parsing a CONTENT
 548     parser-&gt;depth = 0;
 549     parser-&gt;str_xml = xmlDictLookup(parser-&gt;dict, reinterpret_cast&lt;xmlChar*&gt;(const_cast&lt;char*&gt;(&quot;xml&quot;)), 3);
 550     parser-&gt;str_xmlns = xmlDictLookup(parser-&gt;dict, reinterpret_cast&lt;xmlChar*&gt;(const_cast&lt;char*&gt;(&quot;xmlns&quot;)), 5);
 551     parser-&gt;str_xml_ns = xmlDictLookup(parser-&gt;dict, XML_XML_NAMESPACE, 36);
 552     parser-&gt;_private = userData;
 553 
 554     return adoptRef(*new XMLParserContext(parser));
 555 }
 556 
 557 // --------------------------------
 558 
 559 bool XMLDocumentParser::supportsXMLVersion(const String&amp; version)
 560 {
 561     return version == &quot;1.0&quot;;
 562 }
 563 
 564 XMLDocumentParser::XMLDocumentParser(Document&amp; document, FrameView* frameView)
 565     : ScriptableDocumentParser(document)
 566     , m_view(frameView)
<span class="line-modified"> 567     , m_pendingCallbacks(std::make_unique&lt;PendingCallbacks&gt;())</span>
 568     , m_currentNode(&amp;document)
 569     , m_scriptStartPosition(TextPosition::belowRangePosition())
 570 {
 571 }
 572 
 573 XMLDocumentParser::XMLDocumentParser(DocumentFragment&amp; fragment, Element* parentElement, ParserContentPolicy parserContentPolicy)
 574     : ScriptableDocumentParser(fragment.document(), parserContentPolicy)
<span class="line-modified"> 575     , m_pendingCallbacks(std::make_unique&lt;PendingCallbacks&gt;())</span>
 576     , m_currentNode(&amp;fragment)
 577     , m_scriptStartPosition(TextPosition::belowRangePosition())
 578     , m_parsingFragment(true)
 579 {
 580     fragment.ref();
 581 
 582     // Add namespaces based on the parent node
 583     Vector&lt;Element*&gt; elemStack;
 584     while (parentElement) {
 585         elemStack.append(parentElement);
 586 
 587         ContainerNode* node = parentElement-&gt;parentNode();
 588         if (!is&lt;Element&gt;(node))
 589             break;
 590         parentElement = downcast&lt;Element&gt;(node);
 591     }
 592 
 593     if (elemStack.isEmpty())
 594         return;
 595 
</pre>
<hr />
<pre>
 656     }
 657 
 658     // FIXME: Why is this here?  And why is it after we process the passed source?
 659     if (document()-&gt;decoder() &amp;&amp; document()-&gt;decoder()-&gt;sawError()) {
 660         // If the decoder saw an error, report it as fatal (stops parsing)
 661         TextPosition position(OrdinalNumber::fromOneBasedInt(context-&gt;context()-&gt;input-&gt;line), OrdinalNumber::fromOneBasedInt(context-&gt;context()-&gt;input-&gt;col));
 662         handleError(XMLErrors::fatal, &quot;Encoding error&quot;, position);
 663     }
 664 }
 665 
 666 static inline String toString(const xmlChar* string, size_t size)
 667 {
 668     return String::fromUTF8(reinterpret_cast&lt;const char*&gt;(string), size);
 669 }
 670 
 671 static inline String toString(const xmlChar* string)
 672 {
 673     return String::fromUTF8(reinterpret_cast&lt;const char*&gt;(string));
 674 }
 675 
<span class="line-modified"> 676 static inline AtomicString toAtomicString(const xmlChar* string, size_t size)</span>
 677 {
<span class="line-modified"> 678     return AtomicString::fromUTF8(reinterpret_cast&lt;const char*&gt;(string), size);</span>
 679 }
 680 
<span class="line-modified"> 681 static inline AtomicString toAtomicString(const xmlChar* string)</span>
 682 {
<span class="line-modified"> 683     return AtomicString::fromUTF8(reinterpret_cast&lt;const char*&gt;(string));</span>
 684 }
 685 
 686 struct _xmlSAX2Namespace {
 687     const xmlChar* prefix;
 688     const xmlChar* uri;
 689 };
 690 typedef struct _xmlSAX2Namespace xmlSAX2Namespace;
 691 
 692 static inline bool handleNamespaceAttributes(Vector&lt;Attribute&gt;&amp; prefixedAttributes, const xmlChar** libxmlNamespaces, int numNamespaces)
 693 {
 694     xmlSAX2Namespace* namespaces = reinterpret_cast&lt;xmlSAX2Namespace*&gt;(libxmlNamespaces);
 695     for (int i = 0; i &lt; numNamespaces; i++) {
<span class="line-modified"> 696         AtomicString namespaceQName = xmlnsAtom();</span>
<span class="line-modified"> 697         AtomicString namespaceURI = toAtomicString(namespaces[i].uri);</span>
 698         if (namespaces[i].prefix)
 699             namespaceQName = &quot;xmlns:&quot; + toString(namespaces[i].prefix);
 700 
 701         auto result = Element::parseAttributeName(XMLNSNames::xmlnsNamespaceURI, namespaceQName);
 702         if (result.hasException())
 703             return false;
 704 
 705         prefixedAttributes.append(Attribute(result.releaseReturnValue(), namespaceURI));
 706     }
 707     return true;
 708 }
 709 
 710 struct _xmlSAX2Attributes {
 711     const xmlChar* localname;
 712     const xmlChar* prefix;
 713     const xmlChar* uri;
 714     const xmlChar* value;
 715     const xmlChar* end;
 716 };
 717 typedef struct _xmlSAX2Attributes xmlSAX2Attributes;
 718 
 719 static inline bool handleElementAttributes(Vector&lt;Attribute&gt;&amp; prefixedAttributes, const xmlChar** libxmlAttributes, int numAttributes)
 720 {
 721     xmlSAX2Attributes* attributes = reinterpret_cast&lt;xmlSAX2Attributes*&gt;(libxmlAttributes);
 722     for (int i = 0; i &lt; numAttributes; i++) {
 723         int valueLength = static_cast&lt;int&gt;(attributes[i].end - attributes[i].value);
<span class="line-modified"> 724         AtomicString attrValue = toAtomicString(attributes[i].value, valueLength);</span>
 725         String attrPrefix = toString(attributes[i].prefix);
<span class="line-modified"> 726         AtomicString attrURI = attrPrefix.isEmpty() ? nullAtom() : toAtomicString(attributes[i].uri);</span>
<span class="line-modified"> 727         AtomicString attrQName = attrPrefix.isEmpty() ? toAtomicString(attributes[i].localname) : attrPrefix + &quot;:&quot; + toString(attributes[i].localname);</span>
 728 
 729         auto result = Element::parseAttributeName(attrURI, attrQName);
 730         if (result.hasException())
 731             return false;
 732 
 733         prefixedAttributes.append(Attribute(result.releaseReturnValue(), attrValue));
 734     }
 735     return true;
 736 }
 737 
 738 // This is a hack around https://bugzilla.gnome.org/show_bug.cgi?id=502960
 739 // Otherwise libxml doesn&#39;t include namespace for parsed entities, breaking entity
 740 // expansion for all entities containing elements.
 741 static inline bool hackAroundLibXMLEntityParsingBug()
 742 {
 743 #if LIBXML_VERSION &gt;= 20704
 744     // This bug has been fixed in libxml 2.7.4.
 745     return false;
 746 #else
 747     return true;
 748 #endif
 749 }
 750 
 751 void XMLDocumentParser::startElementNs(const xmlChar* xmlLocalName, const xmlChar* xmlPrefix, const xmlChar* xmlURI, int numNamespaces, const xmlChar** libxmlNamespaces, int numAttributes, int numDefaulted, const xmlChar** libxmlAttributes)
 752 {
 753     if (isStopped())
 754         return;
 755 
 756     if (m_parserPaused) {
 757         m_pendingCallbacks-&gt;appendStartElementNSCallback(xmlLocalName, xmlPrefix, xmlURI, numNamespaces, libxmlNamespaces, numAttributes, numDefaulted, libxmlAttributes);
 758         return;
 759     }
 760 
 761     if (!updateLeafTextNode())
 762         return;
 763 
<span class="line-modified"> 764     AtomicString localName = toAtomicString(xmlLocalName);</span>
<span class="line-modified"> 765     AtomicString uri = toAtomicString(xmlURI);</span>
<span class="line-modified"> 766     AtomicString prefix = toAtomicString(xmlPrefix);</span>
 767 
 768     if (m_parsingFragment &amp;&amp; uri.isNull()) {
 769         if (!prefix.isNull())
 770             uri = m_prefixToNamespaceMap.get(prefix);
 771         else
 772             uri = m_defaultNamespaceURI;
 773     }
 774 
 775     // If libxml entity parsing is broken, transfer the currentNodes&#39; namespaceURI to the new node,
 776     // if we&#39;re currently expanding elements which originate from an entity declaration.
 777     if (hackAroundLibXMLEntityParsingBug() &amp;&amp; depthTriggeringEntityExpansion() != -1 &amp;&amp; context()-&gt;depth &gt; depthTriggeringEntityExpansion() &amp;&amp; uri.isNull() &amp;&amp; prefix.isNull())
 778         uri = m_currentNode-&gt;namespaceURI();
 779 
 780     bool isFirstElement = !m_sawFirstElement;
 781     m_sawFirstElement = true;
 782 
 783     QualifiedName qName(prefix, localName, uri);
 784     auto newElement = m_currentNode-&gt;document().createElement(qName, true);
 785 
 786     Vector&lt;Attribute&gt; prefixedAttributes;
</pre>
<hr />
<pre>
1137 // a hack to avoid malloc/free. Using a global variable like this could cause trouble
1138 // if libxml implementation details were to change
1139 static xmlChar sharedXHTMLEntityResult[9] = {0, 0, 0, 0, 0, 0, 0, 0, 0};
1140 
1141 static xmlEntityPtr sharedXHTMLEntity()
1142 {
1143     static xmlEntity entity;
1144     if (!entity.type) {
1145         entity.type = XML_ENTITY_DECL;
1146         entity.orig = sharedXHTMLEntityResult;
1147         entity.content = sharedXHTMLEntityResult;
1148         entity.etype = XML_INTERNAL_PREDEFINED_ENTITY;
1149     }
1150     return &amp;entity;
1151 }
1152 
1153 static size_t convertUTF16EntityToUTF8(const UChar* utf16Entity, size_t numberOfCodeUnits, char* target, size_t targetSize)
1154 {
1155     const char* originalTarget = target;
1156     auto conversionResult = WTF::Unicode::convertUTF16ToUTF8(&amp;utf16Entity, utf16Entity + numberOfCodeUnits, &amp;target, target + targetSize);
<span class="line-modified">1157     if (conversionResult != WTF::Unicode::conversionOK)</span>
1158         return 0;
1159 
1160     // Even though we must pass the length, libxml expects the entity string to be null terminated.
1161     ASSERT(target &gt;= originalTarget + 1);
1162     *target = &#39;\0&#39;;
1163     return target - originalTarget;
1164 }
1165 
1166 static xmlEntityPtr getXHTMLEntity(const xmlChar* name)
1167 {
1168     UChar utf16DecodedEntity[4];
1169     size_t numberOfCodeUnits = decodeNamedEntityToUCharArray(reinterpret_cast&lt;const char*&gt;(name), utf16DecodedEntity);
1170     if (!numberOfCodeUnits)
1171         return 0;
1172 
1173     ASSERT(numberOfCodeUnits &lt;= 4);
1174     size_t entityLengthInUTF8 = convertUTF16EntityToUTF8(utf16DecodedEntity, numberOfCodeUnits,
1175         reinterpret_cast&lt;char*&gt;(sharedXHTMLEntityResult), WTF_ARRAY_LENGTH(sharedXHTMLEntityResult));
1176     if (!entityLengthInUTF8)
1177         return 0;
</pre>
<hr />
<pre>
1311 {
1312     if (!isStopped()) {
1313         if (m_context) {
1314             // Tell libxml we&#39;re done.
1315             {
1316                 XMLDocumentParserScope scope(&amp;document()-&gt;cachedResourceLoader());
1317                 xmlParseChunk(context(), 0, 0, 1);
1318             }
1319 
1320             m_context = nullptr;
1321         }
1322     }
1323 
1324 #if ENABLE(XSLT)
1325     bool xmlViewerMode = !m_sawError &amp;&amp; !m_sawCSS &amp;&amp; !m_sawXSLTransform &amp;&amp; shouldRenderInXMLTreeViewerMode(*document());
1326     if (xmlViewerMode) {
1327         XMLTreeViewer xmlTreeViewer(*document());
1328         xmlTreeViewer.transformDocumentToTreeView();
1329     } else if (m_sawXSLTransform) {
1330         xmlDocPtr doc = xmlDocPtrForString(document()-&gt;cachedResourceLoader(), m_originalSourceForTransform.toString(), document()-&gt;url().string());
<span class="line-modified">1331         document()-&gt;setTransformSource(std::make_unique&lt;TransformSource&gt;(doc));</span>
1332 
1333         document()-&gt;setParsing(false); // Make the document think it&#39;s done, so it will apply XSL stylesheets.
1334         document()-&gt;applyPendingXSLTransformsNowIfScheduled();
1335 
1336         // styleResolverChanged() call can detach the parser and null out its document.
1337         // In that case, we just bail out.
1338         if (isDetached())
1339             return;
1340 
1341         document()-&gt;setParsing(true);
1342         DocumentParser::stopParsing();
1343     }
1344 #endif
1345 }
1346 
1347 #if ENABLE(XSLT)
1348 static inline const char* nativeEndianUTF16Encoding()
1349 {
1350     const UChar BOM = 0xFEFF;
1351     const unsigned char BOMHighByte = *reinterpret_cast&lt;const unsigned char*&gt;(&amp;BOM);
</pre>
<hr />
<pre>
1370     return xmlReadMemory(characters, sizeInBytes, url.latin1().data(), encoding, XSLT_PARSE_OPTIONS);
1371 }
1372 #endif
1373 
1374 TextPosition XMLDocumentParser::textPosition() const
1375 {
1376     xmlParserCtxtPtr context = this-&gt;context();
1377     if (!context)
1378         return TextPosition();
1379     return TextPosition(OrdinalNumber::fromOneBasedInt(context-&gt;input-&gt;line),
1380                         OrdinalNumber::fromOneBasedInt(context-&gt;input-&gt;col));
1381 }
1382 
1383 bool XMLDocumentParser::shouldAssociateConsoleMessagesWithTextPosition() const
1384 {
1385     return !m_parserPaused &amp;&amp; !m_requestingScript;
1386 }
1387 
1388 void XMLDocumentParser::stopParsing()
1389 {



1390     DocumentParser::stopParsing();
1391     if (context())
1392         xmlStopParser(context());
1393 }
1394 
1395 void XMLDocumentParser::resumeParsing()
1396 {
1397     ASSERT(!isDetached());
1398     ASSERT(m_parserPaused);
1399 
1400     m_parserPaused = false;
1401 
1402     // First, execute any pending callbacks
1403     while (!m_pendingCallbacks-&gt;isEmpty()) {
1404         m_pendingCallbacks-&gt;callAndRemoveFirstCallback(this);
1405 
1406         // A callback paused the parser
1407         if (m_parserPaused)
1408             return;
1409     }
</pre>
</td>
<td>
<hr />
<pre>
  75     auto* frame = document.frame();
  76     if (!frame)
  77         return false;
  78 
  79     if (!frame-&gt;settings().developerExtrasEnabled())
  80         return false;
  81 
  82     if (frame-&gt;tree().parent())
  83         return false; // This document is not in a top frame
  84 
  85     return true;
  86 }
  87 
  88 #endif
  89 
  90 class PendingCallbacks {
  91     WTF_MAKE_FAST_ALLOCATED;
  92 public:
  93     void appendStartElementNSCallback(const xmlChar* xmlLocalName, const xmlChar* xmlPrefix, const xmlChar* xmlURI, int numNamespaces, const xmlChar** namespaces, int numAttributes, int numDefaulted, const xmlChar** attributes)
  94     {
<span class="line-modified">  95         auto callback = makeUnique&lt;PendingStartElementNSCallback&gt;();</span>
  96 
  97         callback-&gt;xmlLocalName = xmlStrdup(xmlLocalName);
  98         callback-&gt;xmlPrefix = xmlStrdup(xmlPrefix);
  99         callback-&gt;xmlURI = xmlStrdup(xmlURI);
 100         callback-&gt;numNamespaces = numNamespaces;
 101         callback-&gt;namespaces = static_cast&lt;xmlChar**&gt;(xmlMalloc(sizeof(xmlChar*) * numNamespaces * 2));
 102         for (int i = 0; i &lt; numNamespaces * 2 ; i++)
 103             callback-&gt;namespaces[i] = xmlStrdup(namespaces[i]);
 104         callback-&gt;numAttributes = numAttributes;
 105         callback-&gt;numDefaulted = numDefaulted;
 106         callback-&gt;attributes = static_cast&lt;xmlChar**&gt;(xmlMalloc(sizeof(xmlChar*) * numAttributes * 5));
 107         for (int i = 0; i &lt; numAttributes; i++) {
 108             // Each attribute has 5 elements in the array:
 109             // name, prefix, uri, value and an end pointer.
 110 
 111             for (int j = 0; j &lt; 3; j++)
 112                 callback-&gt;attributes[i * 5 + j] = xmlStrdup(attributes[i * 5 + j]);
 113 
 114             int len = attributes[i * 5 + 4] - attributes[i * 5 + 3];
 115 
 116             callback-&gt;attributes[i * 5 + 3] = xmlStrndup(attributes[i * 5 + 3], len);
 117             callback-&gt;attributes[i * 5 + 4] = callback-&gt;attributes[i * 5 + 3] + len;
 118         }
 119 
 120         m_callbacks.append(WTFMove(callback));
 121     }
 122 
 123     void appendEndElementNSCallback()
 124     {
<span class="line-modified"> 125         m_callbacks.append(makeUnique&lt;PendingEndElementNSCallback&gt;());</span>
 126     }
 127 
 128     void appendCharactersCallback(const xmlChar* s, int len)
 129     {
<span class="line-modified"> 130         auto callback = makeUnique&lt;PendingCharactersCallback&gt;();</span>
 131 
 132         callback-&gt;s = xmlStrndup(s, len);
 133         callback-&gt;len = len;
 134 
 135         m_callbacks.append(WTFMove(callback));
 136     }
 137 
 138     void appendProcessingInstructionCallback(const xmlChar* target, const xmlChar* data)
 139     {
<span class="line-modified"> 140         auto callback = makeUnique&lt;PendingProcessingInstructionCallback&gt;();</span>
 141 
 142         callback-&gt;target = xmlStrdup(target);
 143         callback-&gt;data = xmlStrdup(data);
 144 
 145         m_callbacks.append(WTFMove(callback));
 146     }
 147 
 148     void appendCDATABlockCallback(const xmlChar* s, int len)
 149     {
<span class="line-modified"> 150         auto callback = makeUnique&lt;PendingCDATABlockCallback&gt;();</span>
 151 
 152         callback-&gt;s = xmlStrndup(s, len);
 153         callback-&gt;len = len;
 154 
 155         m_callbacks.append(WTFMove(callback));
 156     }
 157 
 158     void appendCommentCallback(const xmlChar* s)
 159     {
<span class="line-modified"> 160         auto callback = makeUnique&lt;PendingCommentCallback&gt;();</span>
 161 
 162         callback-&gt;s = xmlStrdup(s);
 163 
 164         m_callbacks.append(WTFMove(callback));
 165     }
 166 
 167     void appendInternalSubsetCallback(const xmlChar* name, const xmlChar* externalID, const xmlChar* systemID)
 168     {
<span class="line-modified"> 169         auto callback = makeUnique&lt;PendingInternalSubsetCallback&gt;();</span>
 170 
 171         callback-&gt;name = xmlStrdup(name);
 172         callback-&gt;externalID = xmlStrdup(externalID);
 173         callback-&gt;systemID = xmlStrdup(systemID);
 174 
 175         m_callbacks.append(WTFMove(callback));
 176     }
 177 
 178     void appendErrorCallback(XMLErrors::ErrorType type, const xmlChar* message, OrdinalNumber lineNumber, OrdinalNumber columnNumber)
 179     {
<span class="line-modified"> 180         auto callback = makeUnique&lt;PendingErrorCallback&gt;();</span>
 181 
 182         callback-&gt;message = xmlStrdup(message);
 183         callback-&gt;type = type;
 184         callback-&gt;lineNumber = lineNumber;
 185         callback-&gt;columnNumber = columnNumber;
 186 
 187         m_callbacks.append(WTFMove(callback));
 188     }
 189 
 190     void callAndRemoveFirstCallback(XMLDocumentParser* parser)
 191     {
 192         std::unique_ptr&lt;PendingCallback&gt; callback = m_callbacks.takeFirst();
 193         callback-&gt;call(parser);
 194     }
 195 
 196     bool isEmpty() const { return m_callbacks.isEmpty(); }
 197 
 198 private:
 199     struct PendingCallback {
<span class="line-added"> 200         WTF_MAKE_STRUCT_FAST_ALLOCATED;</span>
 201         virtual ~PendingCallback() = default;
 202         virtual void call(XMLDocumentParser* parser) = 0;
 203     };
 204 
 205     struct PendingStartElementNSCallback : public PendingCallback {
 206         virtual ~PendingStartElementNSCallback()
 207         {
 208             xmlFree(xmlLocalName);
 209             xmlFree(xmlPrefix);
 210             xmlFree(xmlURI);
 211             for (int i = 0; i &lt; numNamespaces * 2; i++)
 212                 xmlFree(namespaces[i]);
 213             xmlFree(namespaces);
 214             for (int i = 0; i &lt; numAttributes; i++) {
 215                 for (int j = 0; j &lt; 4; j++)
 216                     xmlFree(attributes[i * 5 + j]);
 217             }
 218             xmlFree(attributes);
 219         }
 220 
</pre>
<hr />
<pre>
 548     parser-&gt;instate = XML_PARSER_CONTENT; // We are parsing a CONTENT
 549     parser-&gt;depth = 0;
 550     parser-&gt;str_xml = xmlDictLookup(parser-&gt;dict, reinterpret_cast&lt;xmlChar*&gt;(const_cast&lt;char*&gt;(&quot;xml&quot;)), 3);
 551     parser-&gt;str_xmlns = xmlDictLookup(parser-&gt;dict, reinterpret_cast&lt;xmlChar*&gt;(const_cast&lt;char*&gt;(&quot;xmlns&quot;)), 5);
 552     parser-&gt;str_xml_ns = xmlDictLookup(parser-&gt;dict, XML_XML_NAMESPACE, 36);
 553     parser-&gt;_private = userData;
 554 
 555     return adoptRef(*new XMLParserContext(parser));
 556 }
 557 
 558 // --------------------------------
 559 
 560 bool XMLDocumentParser::supportsXMLVersion(const String&amp; version)
 561 {
 562     return version == &quot;1.0&quot;;
 563 }
 564 
 565 XMLDocumentParser::XMLDocumentParser(Document&amp; document, FrameView* frameView)
 566     : ScriptableDocumentParser(document)
 567     , m_view(frameView)
<span class="line-modified"> 568     , m_pendingCallbacks(makeUnique&lt;PendingCallbacks&gt;())</span>
 569     , m_currentNode(&amp;document)
 570     , m_scriptStartPosition(TextPosition::belowRangePosition())
 571 {
 572 }
 573 
 574 XMLDocumentParser::XMLDocumentParser(DocumentFragment&amp; fragment, Element* parentElement, ParserContentPolicy parserContentPolicy)
 575     : ScriptableDocumentParser(fragment.document(), parserContentPolicy)
<span class="line-modified"> 576     , m_pendingCallbacks(makeUnique&lt;PendingCallbacks&gt;())</span>
 577     , m_currentNode(&amp;fragment)
 578     , m_scriptStartPosition(TextPosition::belowRangePosition())
 579     , m_parsingFragment(true)
 580 {
 581     fragment.ref();
 582 
 583     // Add namespaces based on the parent node
 584     Vector&lt;Element*&gt; elemStack;
 585     while (parentElement) {
 586         elemStack.append(parentElement);
 587 
 588         ContainerNode* node = parentElement-&gt;parentNode();
 589         if (!is&lt;Element&gt;(node))
 590             break;
 591         parentElement = downcast&lt;Element&gt;(node);
 592     }
 593 
 594     if (elemStack.isEmpty())
 595         return;
 596 
</pre>
<hr />
<pre>
 657     }
 658 
 659     // FIXME: Why is this here?  And why is it after we process the passed source?
 660     if (document()-&gt;decoder() &amp;&amp; document()-&gt;decoder()-&gt;sawError()) {
 661         // If the decoder saw an error, report it as fatal (stops parsing)
 662         TextPosition position(OrdinalNumber::fromOneBasedInt(context-&gt;context()-&gt;input-&gt;line), OrdinalNumber::fromOneBasedInt(context-&gt;context()-&gt;input-&gt;col));
 663         handleError(XMLErrors::fatal, &quot;Encoding error&quot;, position);
 664     }
 665 }
 666 
 667 static inline String toString(const xmlChar* string, size_t size)
 668 {
 669     return String::fromUTF8(reinterpret_cast&lt;const char*&gt;(string), size);
 670 }
 671 
 672 static inline String toString(const xmlChar* string)
 673 {
 674     return String::fromUTF8(reinterpret_cast&lt;const char*&gt;(string));
 675 }
 676 
<span class="line-modified"> 677 static inline AtomString toAtomString(const xmlChar* string, size_t size)</span>
 678 {
<span class="line-modified"> 679     return AtomString::fromUTF8(reinterpret_cast&lt;const char*&gt;(string), size);</span>
 680 }
 681 
<span class="line-modified"> 682 static inline AtomString toAtomString(const xmlChar* string)</span>
 683 {
<span class="line-modified"> 684     return AtomString::fromUTF8(reinterpret_cast&lt;const char*&gt;(string));</span>
 685 }
 686 
 687 struct _xmlSAX2Namespace {
 688     const xmlChar* prefix;
 689     const xmlChar* uri;
 690 };
 691 typedef struct _xmlSAX2Namespace xmlSAX2Namespace;
 692 
 693 static inline bool handleNamespaceAttributes(Vector&lt;Attribute&gt;&amp; prefixedAttributes, const xmlChar** libxmlNamespaces, int numNamespaces)
 694 {
 695     xmlSAX2Namespace* namespaces = reinterpret_cast&lt;xmlSAX2Namespace*&gt;(libxmlNamespaces);
 696     for (int i = 0; i &lt; numNamespaces; i++) {
<span class="line-modified"> 697         AtomString namespaceQName = xmlnsAtom();</span>
<span class="line-modified"> 698         AtomString namespaceURI = toAtomString(namespaces[i].uri);</span>
 699         if (namespaces[i].prefix)
 700             namespaceQName = &quot;xmlns:&quot; + toString(namespaces[i].prefix);
 701 
 702         auto result = Element::parseAttributeName(XMLNSNames::xmlnsNamespaceURI, namespaceQName);
 703         if (result.hasException())
 704             return false;
 705 
 706         prefixedAttributes.append(Attribute(result.releaseReturnValue(), namespaceURI));
 707     }
 708     return true;
 709 }
 710 
 711 struct _xmlSAX2Attributes {
 712     const xmlChar* localname;
 713     const xmlChar* prefix;
 714     const xmlChar* uri;
 715     const xmlChar* value;
 716     const xmlChar* end;
 717 };
 718 typedef struct _xmlSAX2Attributes xmlSAX2Attributes;
 719 
 720 static inline bool handleElementAttributes(Vector&lt;Attribute&gt;&amp; prefixedAttributes, const xmlChar** libxmlAttributes, int numAttributes)
 721 {
 722     xmlSAX2Attributes* attributes = reinterpret_cast&lt;xmlSAX2Attributes*&gt;(libxmlAttributes);
 723     for (int i = 0; i &lt; numAttributes; i++) {
 724         int valueLength = static_cast&lt;int&gt;(attributes[i].end - attributes[i].value);
<span class="line-modified"> 725         AtomString attrValue = toAtomString(attributes[i].value, valueLength);</span>
 726         String attrPrefix = toString(attributes[i].prefix);
<span class="line-modified"> 727         AtomString attrURI = attrPrefix.isEmpty() ? nullAtom() : toAtomString(attributes[i].uri);</span>
<span class="line-modified"> 728         AtomString attrQName = attrPrefix.isEmpty() ? toAtomString(attributes[i].localname) : attrPrefix + &quot;:&quot; + toString(attributes[i].localname);</span>
 729 
 730         auto result = Element::parseAttributeName(attrURI, attrQName);
 731         if (result.hasException())
 732             return false;
 733 
 734         prefixedAttributes.append(Attribute(result.releaseReturnValue(), attrValue));
 735     }
 736     return true;
 737 }
 738 
 739 // This is a hack around https://bugzilla.gnome.org/show_bug.cgi?id=502960
 740 // Otherwise libxml doesn&#39;t include namespace for parsed entities, breaking entity
 741 // expansion for all entities containing elements.
 742 static inline bool hackAroundLibXMLEntityParsingBug()
 743 {
 744 #if LIBXML_VERSION &gt;= 20704
 745     // This bug has been fixed in libxml 2.7.4.
 746     return false;
 747 #else
 748     return true;
 749 #endif
 750 }
 751 
 752 void XMLDocumentParser::startElementNs(const xmlChar* xmlLocalName, const xmlChar* xmlPrefix, const xmlChar* xmlURI, int numNamespaces, const xmlChar** libxmlNamespaces, int numAttributes, int numDefaulted, const xmlChar** libxmlAttributes)
 753 {
 754     if (isStopped())
 755         return;
 756 
 757     if (m_parserPaused) {
 758         m_pendingCallbacks-&gt;appendStartElementNSCallback(xmlLocalName, xmlPrefix, xmlURI, numNamespaces, libxmlNamespaces, numAttributes, numDefaulted, libxmlAttributes);
 759         return;
 760     }
 761 
 762     if (!updateLeafTextNode())
 763         return;
 764 
<span class="line-modified"> 765     AtomString localName = toAtomString(xmlLocalName);</span>
<span class="line-modified"> 766     AtomString uri = toAtomString(xmlURI);</span>
<span class="line-modified"> 767     AtomString prefix = toAtomString(xmlPrefix);</span>
 768 
 769     if (m_parsingFragment &amp;&amp; uri.isNull()) {
 770         if (!prefix.isNull())
 771             uri = m_prefixToNamespaceMap.get(prefix);
 772         else
 773             uri = m_defaultNamespaceURI;
 774     }
 775 
 776     // If libxml entity parsing is broken, transfer the currentNodes&#39; namespaceURI to the new node,
 777     // if we&#39;re currently expanding elements which originate from an entity declaration.
 778     if (hackAroundLibXMLEntityParsingBug() &amp;&amp; depthTriggeringEntityExpansion() != -1 &amp;&amp; context()-&gt;depth &gt; depthTriggeringEntityExpansion() &amp;&amp; uri.isNull() &amp;&amp; prefix.isNull())
 779         uri = m_currentNode-&gt;namespaceURI();
 780 
 781     bool isFirstElement = !m_sawFirstElement;
 782     m_sawFirstElement = true;
 783 
 784     QualifiedName qName(prefix, localName, uri);
 785     auto newElement = m_currentNode-&gt;document().createElement(qName, true);
 786 
 787     Vector&lt;Attribute&gt; prefixedAttributes;
</pre>
<hr />
<pre>
1138 // a hack to avoid malloc/free. Using a global variable like this could cause trouble
1139 // if libxml implementation details were to change
1140 static xmlChar sharedXHTMLEntityResult[9] = {0, 0, 0, 0, 0, 0, 0, 0, 0};
1141 
1142 static xmlEntityPtr sharedXHTMLEntity()
1143 {
1144     static xmlEntity entity;
1145     if (!entity.type) {
1146         entity.type = XML_ENTITY_DECL;
1147         entity.orig = sharedXHTMLEntityResult;
1148         entity.content = sharedXHTMLEntityResult;
1149         entity.etype = XML_INTERNAL_PREDEFINED_ENTITY;
1150     }
1151     return &amp;entity;
1152 }
1153 
1154 static size_t convertUTF16EntityToUTF8(const UChar* utf16Entity, size_t numberOfCodeUnits, char* target, size_t targetSize)
1155 {
1156     const char* originalTarget = target;
1157     auto conversionResult = WTF::Unicode::convertUTF16ToUTF8(&amp;utf16Entity, utf16Entity + numberOfCodeUnits, &amp;target, target + targetSize);
<span class="line-modified">1158     if (conversionResult != WTF::Unicode::ConversionOK)</span>
1159         return 0;
1160 
1161     // Even though we must pass the length, libxml expects the entity string to be null terminated.
1162     ASSERT(target &gt;= originalTarget + 1);
1163     *target = &#39;\0&#39;;
1164     return target - originalTarget;
1165 }
1166 
1167 static xmlEntityPtr getXHTMLEntity(const xmlChar* name)
1168 {
1169     UChar utf16DecodedEntity[4];
1170     size_t numberOfCodeUnits = decodeNamedEntityToUCharArray(reinterpret_cast&lt;const char*&gt;(name), utf16DecodedEntity);
1171     if (!numberOfCodeUnits)
1172         return 0;
1173 
1174     ASSERT(numberOfCodeUnits &lt;= 4);
1175     size_t entityLengthInUTF8 = convertUTF16EntityToUTF8(utf16DecodedEntity, numberOfCodeUnits,
1176         reinterpret_cast&lt;char*&gt;(sharedXHTMLEntityResult), WTF_ARRAY_LENGTH(sharedXHTMLEntityResult));
1177     if (!entityLengthInUTF8)
1178         return 0;
</pre>
<hr />
<pre>
1312 {
1313     if (!isStopped()) {
1314         if (m_context) {
1315             // Tell libxml we&#39;re done.
1316             {
1317                 XMLDocumentParserScope scope(&amp;document()-&gt;cachedResourceLoader());
1318                 xmlParseChunk(context(), 0, 0, 1);
1319             }
1320 
1321             m_context = nullptr;
1322         }
1323     }
1324 
1325 #if ENABLE(XSLT)
1326     bool xmlViewerMode = !m_sawError &amp;&amp; !m_sawCSS &amp;&amp; !m_sawXSLTransform &amp;&amp; shouldRenderInXMLTreeViewerMode(*document());
1327     if (xmlViewerMode) {
1328         XMLTreeViewer xmlTreeViewer(*document());
1329         xmlTreeViewer.transformDocumentToTreeView();
1330     } else if (m_sawXSLTransform) {
1331         xmlDocPtr doc = xmlDocPtrForString(document()-&gt;cachedResourceLoader(), m_originalSourceForTransform.toString(), document()-&gt;url().string());
<span class="line-modified">1332         document()-&gt;setTransformSource(makeUnique&lt;TransformSource&gt;(doc));</span>
1333 
1334         document()-&gt;setParsing(false); // Make the document think it&#39;s done, so it will apply XSL stylesheets.
1335         document()-&gt;applyPendingXSLTransformsNowIfScheduled();
1336 
1337         // styleResolverChanged() call can detach the parser and null out its document.
1338         // In that case, we just bail out.
1339         if (isDetached())
1340             return;
1341 
1342         document()-&gt;setParsing(true);
1343         DocumentParser::stopParsing();
1344     }
1345 #endif
1346 }
1347 
1348 #if ENABLE(XSLT)
1349 static inline const char* nativeEndianUTF16Encoding()
1350 {
1351     const UChar BOM = 0xFEFF;
1352     const unsigned char BOMHighByte = *reinterpret_cast&lt;const unsigned char*&gt;(&amp;BOM);
</pre>
<hr />
<pre>
1371     return xmlReadMemory(characters, sizeInBytes, url.latin1().data(), encoding, XSLT_PARSE_OPTIONS);
1372 }
1373 #endif
1374 
1375 TextPosition XMLDocumentParser::textPosition() const
1376 {
1377     xmlParserCtxtPtr context = this-&gt;context();
1378     if (!context)
1379         return TextPosition();
1380     return TextPosition(OrdinalNumber::fromOneBasedInt(context-&gt;input-&gt;line),
1381                         OrdinalNumber::fromOneBasedInt(context-&gt;input-&gt;col));
1382 }
1383 
1384 bool XMLDocumentParser::shouldAssociateConsoleMessagesWithTextPosition() const
1385 {
1386     return !m_parserPaused &amp;&amp; !m_requestingScript;
1387 }
1388 
1389 void XMLDocumentParser::stopParsing()
1390 {
<span class="line-added">1391     if (m_sawError)</span>
<span class="line-added">1392         insertErrorMessageBlock();</span>
<span class="line-added">1393 </span>
1394     DocumentParser::stopParsing();
1395     if (context())
1396         xmlStopParser(context());
1397 }
1398 
1399 void XMLDocumentParser::resumeParsing()
1400 {
1401     ASSERT(!isDetached());
1402     ASSERT(m_parserPaused);
1403 
1404     m_parserPaused = false;
1405 
1406     // First, execute any pending callbacks
1407     while (!m_pendingCallbacks-&gt;isEmpty()) {
1408         m_pendingCallbacks-&gt;callAndRemoveFirstCallback(this);
1409 
1410         // A callback paused the parser
1411         if (m_parserPaused)
1412             return;
1413     }
</pre>
</td>
</tr>
</table>
<center><a href="XMLDocumentParser.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../../../WebKitLegacy/CMakeLists.txt.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>