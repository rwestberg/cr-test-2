<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WTF/wtf/dtoa/double-conversion.cc</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="diy-fp.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="double-conversion.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WTF/wtf/dtoa/double-conversion.cc</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 42,381 ***</span>
  
  #include &lt;wtf/ASCIICType.h&gt;
  
  namespace WTF {
  namespace double_conversion {
<span class="line-modified">!     </span>
  const DoubleToStringConverter&amp; DoubleToStringConverter::EcmaScriptConverter() {
<span class="line-modified">!         int flags = UNIQUE_ZERO | EMIT_POSITIVE_EXPONENT_SIGN;</span>
<span class="line-modified">!         static DoubleToStringConverter converter(flags,</span>
<span class="line-modified">!                                                  &quot;Infinity&quot;,</span>
<span class="line-modified">!                                                  &quot;NaN&quot;,</span>
<span class="line-modified">!                                                  &#39;e&#39;,</span>
<span class="line-modified">!                                                  -6, 21,</span>
<span class="line-modified">!                                                  6, 0);</span>
<span class="line-modified">!         return converter;</span>
  }
<span class="line-modified">!     </span>
<span class="line-modified">!     </span>
  bool DoubleToStringConverter::HandleSpecialValues(
<span class="line-modified">!                                                       double value,</span>
<span class="line-modified">!                                                       StringBuilder* result_builder) const {</span>
<span class="line-modified">!         Double double_inspect(value);</span>
<span class="line-modified">!         if (double_inspect.IsInfinite()) {</span>
<span class="line-modified">!             if (infinity_symbol_ == NULL) return false;</span>
<span class="line-modified">!             if (value &lt; 0) {</span>
<span class="line-modified">!                 result_builder-&gt;AddCharacter(&#39;-&#39;);</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!             result_builder-&gt;AddString(infinity_symbol_);</span>
<span class="line-modified">!             return true;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         if (double_inspect.IsNan()) {</span>
<span class="line-modified">!             if (nan_symbol_ == NULL) return false;</span>
<span class="line-modified">!             result_builder-&gt;AddString(nan_symbol_);</span>
<span class="line-modified">!             return true;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         return false;</span>
  }
<span class="line-modified">!     </span>
<span class="line-modified">!     </span>
  void DoubleToStringConverter::CreateExponentialRepresentation(
<span class="line-modified">!                                                                   const char* decimal_digits,</span>
<span class="line-modified">!                                                                   int length,</span>
<span class="line-modified">!                                                                   int exponent,</span>
<span class="line-modified">!                                                                   StringBuilder* result_builder) const {</span>
<span class="line-modified">!         ASSERT(length != 0);</span>
<span class="line-modified">!         result_builder-&gt;AddCharacter(decimal_digits[0]);</span>
<span class="line-modified">!         if (length != 1) {</span>
<span class="line-modified">!             result_builder-&gt;AddCharacter(&#39;.&#39;);</span>
<span class="line-modified">!             result_builder-&gt;AddSubstring(&amp;decimal_digits[1], length-1);</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         result_builder-&gt;AddCharacter(exponent_character_);</span>
<span class="line-modified">!         if (exponent &lt; 0) {</span>
<span class="line-modified">!             result_builder-&gt;AddCharacter(&#39;-&#39;);</span>
<span class="line-modified">!             exponent = -exponent;</span>
<span class="line-modified">!         } else {</span>
<span class="line-modified">!             if ((flags_ &amp; EMIT_POSITIVE_EXPONENT_SIGN) != 0) {</span>
<span class="line-modified">!                 result_builder-&gt;AddCharacter(&#39;+&#39;);</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         if (exponent == 0) {</span>
<span class="line-modified">!             result_builder-&gt;AddCharacter(&#39;0&#39;);</span>
<span class="line-modified">!             return;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         ASSERT(exponent &lt; 1e4);</span>
<span class="line-modified">!         const int kMaxExponentLength = 5;</span>
<span class="line-modified">!         char buffer[kMaxExponentLength + 1];</span>
    buffer[kMaxExponentLength] = &#39;\0&#39;;
<span class="line-modified">!         int first_char_pos = kMaxExponentLength;</span>
<span class="line-modified">!         while (exponent &gt; 0) {</span>
<span class="line-modified">!             buffer[--first_char_pos] = &#39;0&#39; + (exponent % 10);</span>
<span class="line-modified">!             exponent /= 10;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         result_builder-&gt;AddSubstring(&amp;buffer[first_char_pos],</span>
<span class="line-modified">!                                      kMaxExponentLength - first_char_pos);</span>
  }
<span class="line-modified">!     </span>
<span class="line-modified">!     </span>
  void DoubleToStringConverter::CreateDecimalRepresentation(
<span class="line-modified">!                                                               const char* decimal_digits,</span>
<span class="line-modified">!                                                               int length,</span>
<span class="line-modified">!                                                               int decimal_point,</span>
<span class="line-modified">!                                                               int digits_after_point,</span>
<span class="line-modified">!                                                               StringBuilder* result_builder) const {</span>
<span class="line-modified">!         // Create a representation that is padded with zeros if needed.</span>
<span class="line-modified">!         if (decimal_point &lt;= 0) {</span>
        // &quot;0.00000decimal_rep&quot; or &quot;0.000decimal_rep00&quot;.
<span class="line-modified">!             result_builder-&gt;AddCharacter(&#39;0&#39;);</span>
<span class="line-modified">!             if (digits_after_point &gt; 0) {</span>
<span class="line-modified">!                 result_builder-&gt;AddCharacter(&#39;.&#39;);</span>
<span class="line-modified">!                 result_builder-&gt;AddPadding(&#39;0&#39;, -decimal_point);</span>
<span class="line-modified">!                 ASSERT(length &lt;= digits_after_point - (-decimal_point));</span>
<span class="line-modified">!                 result_builder-&gt;AddSubstring(decimal_digits, length);</span>
<span class="line-modified">!                 int remaining_digits = digits_after_point - (-decimal_point) - length;</span>
<span class="line-modified">!                 result_builder-&gt;AddPadding(&#39;0&#39;, remaining_digits);</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!         } else if (decimal_point &gt;= length) {</span>
      // &quot;decimal_rep0000.00000&quot; or &quot;decimal_rep.0000&quot;.
<span class="line-modified">!             result_builder-&gt;AddSubstring(decimal_digits, length);</span>
<span class="line-modified">!             result_builder-&gt;AddPadding(&#39;0&#39;, decimal_point - length);</span>
<span class="line-modified">!             if (digits_after_point &gt; 0) {</span>
<span class="line-modified">!                 result_builder-&gt;AddCharacter(&#39;.&#39;);</span>
<span class="line-modified">!                 result_builder-&gt;AddPadding(&#39;0&#39;, digits_after_point);</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!         } else {</span>
      // &quot;decima.l_rep000&quot;.
<span class="line-modified">!             ASSERT(digits_after_point &gt; 0);</span>
<span class="line-modified">!             result_builder-&gt;AddSubstring(decimal_digits, decimal_point);</span>
<span class="line-modified">!             result_builder-&gt;AddCharacter(&#39;.&#39;);</span>
<span class="line-modified">!             ASSERT(length - decimal_point &lt;= digits_after_point);</span>
<span class="line-modified">!             result_builder-&gt;AddSubstring(&amp;decimal_digits[decimal_point],</span>
<span class="line-modified">!                                          length - decimal_point);</span>
<span class="line-modified">!             int remaining_digits = digits_after_point - (length - decimal_point);</span>
<span class="line-modified">!             result_builder-&gt;AddPadding(&#39;0&#39;, remaining_digits);</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         if (digits_after_point == 0) {</span>
<span class="line-modified">!             if ((flags_ &amp; EMIT_TRAILING_DECIMAL_POINT) != 0) {</span>
<span class="line-modified">!                 result_builder-&gt;AddCharacter(&#39;.&#39;);</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!             if ((flags_ &amp; EMIT_TRAILING_ZERO_AFTER_POINT) != 0) {</span>
<span class="line-modified">!                 result_builder-&gt;AddCharacter(&#39;0&#39;);</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!         }</span>
  }
<span class="line-modified">!     </span>
<span class="line-modified">!     </span>
  bool DoubleToStringConverter::ToShortestIeeeNumber(
      double value,
      StringBuilder* result_builder,
      DoubleToStringConverter::DtoaMode mode) const {
    ASSERT(mode == SHORTEST || mode == SHORTEST_SINGLE);
<span class="line-modified">!         if (Double(value).IsSpecial()) {</span>
<span class="line-modified">!             return HandleSpecialValues(value, result_builder);</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         </span>
<span class="line-modified">!         int decimal_point;</span>
<span class="line-modified">!         bool sign;</span>
<span class="line-modified">!         const int kDecimalRepCapacity = kBase10MaximalLength + 1;</span>
<span class="line-modified">!         char decimal_rep[kDecimalRepCapacity];</span>
<span class="line-modified">!         int decimal_rep_length;</span>
<span class="line-modified">!         </span>
    DoubleToAscii(value, mode, 0, decimal_rep, kDecimalRepCapacity,
<span class="line-modified">!                       &amp;sign, &amp;decimal_rep_length, &amp;decimal_point);</span>
<span class="line-modified">!         </span>
<span class="line-modified">!         bool unique_zero = (flags_ &amp; UNIQUE_ZERO) != 0;</span>
<span class="line-modified">!         if (sign &amp;&amp; (value != 0.0 || !unique_zero)) {</span>
<span class="line-modified">!             result_builder-&gt;AddCharacter(&#39;-&#39;);</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         </span>
<span class="line-modified">!         int exponent = decimal_point - 1;</span>
<span class="line-modified">!         if ((decimal_in_shortest_low_ &lt;= exponent) &amp;&amp;</span>
<span class="line-modified">!             (exponent &lt; decimal_in_shortest_high_)) {</span>
<span class="line-modified">!             CreateDecimalRepresentation(decimal_rep, decimal_rep_length,</span>
<span class="line-modified">!                                         decimal_point,</span>
<span class="line-modified">!                                         Max(0, decimal_rep_length - decimal_point),</span>
<span class="line-modified">!                                         result_builder);</span>
<span class="line-modified">!         } else {</span>
<span class="line-modified">!             CreateExponentialRepresentation(decimal_rep, decimal_rep_length, exponent,</span>
<span class="line-modified">!                                             result_builder);</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         return true;</span>
  }
<span class="line-modified">!     </span>
<span class="line-modified">!     </span>
  bool DoubleToStringConverter::ToFixed(double value,
<span class="line-modified">!                                           int requested_digits,</span>
<span class="line-modified">!                                           StringBuilder* result_builder) const {</span>
<span class="line-modified">!         ASSERT(kMaxFixedDigitsBeforePoint == 60);</span>
<span class="line-modified">!         const double kFirstNonFixed = 1e60;</span>
<span class="line-modified">!         </span>
<span class="line-modified">!         if (Double(value).IsSpecial()) {</span>
<span class="line-modified">!             return HandleSpecialValues(value, result_builder);</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         </span>
<span class="line-modified">!         if (requested_digits &gt; kMaxFixedDigitsAfterPoint) return false;</span>
<span class="line-modified">!         if (value &gt;= kFirstNonFixed || value &lt;= -kFirstNonFixed) return false;</span>
<span class="line-modified">!         </span>
<span class="line-modified">!         // Find a sufficiently precise decimal representation of n.</span>
<span class="line-modified">!         int decimal_point;</span>
<span class="line-modified">!         bool sign;</span>
<span class="line-modified">!         // Add space for the &#39;\0&#39; byte.</span>
<span class="line-modified">!         const int kDecimalRepCapacity =</span>
<span class="line-modified">!         kMaxFixedDigitsBeforePoint + kMaxFixedDigitsAfterPoint + 1;</span>
<span class="line-modified">!         char decimal_rep[kDecimalRepCapacity];</span>
<span class="line-modified">!         int decimal_rep_length;</span>
<span class="line-modified">!         DoubleToAscii(value, FIXED, requested_digits,</span>
<span class="line-modified">!                       decimal_rep, kDecimalRepCapacity,</span>
<span class="line-modified">!                       &amp;sign, &amp;decimal_rep_length, &amp;decimal_point);</span>
<span class="line-modified">!         </span>
<span class="line-modified">!         bool unique_zero = ((flags_ &amp; UNIQUE_ZERO) != 0);</span>
<span class="line-modified">!         if (sign &amp;&amp; (value != 0.0 || !unique_zero)) {</span>
<span class="line-modified">!             result_builder-&gt;AddCharacter(&#39;-&#39;);</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         </span>
<span class="line-modified">!         CreateDecimalRepresentation(decimal_rep, decimal_rep_length, decimal_point,</span>
<span class="line-modified">!                                     requested_digits, result_builder);</span>
<span class="line-modified">!         return true;</span>
  }
<span class="line-modified">!     </span>
<span class="line-modified">!     </span>
  bool DoubleToStringConverter::ToExponential(
<span class="line-modified">!                                                 double value,</span>
<span class="line-modified">!                                                 int requested_digits,</span>
<span class="line-modified">!                                                 StringBuilder* result_builder) const {</span>
<span class="line-modified">!         if (Double(value).IsSpecial()) {</span>
<span class="line-modified">!             return HandleSpecialValues(value, result_builder);</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         </span>
<span class="line-modified">!         if (requested_digits &lt; -1) return false;</span>
<span class="line-modified">!         if (requested_digits &gt; kMaxExponentialDigits) return false;</span>
<span class="line-modified">!         </span>
<span class="line-modified">!         int decimal_point;</span>
<span class="line-modified">!         bool sign;</span>
<span class="line-modified">!         // Add space for digit before the decimal point and the &#39;\0&#39; character.</span>
<span class="line-modified">!         const int kDecimalRepCapacity = kMaxExponentialDigits + 2;</span>
<span class="line-modified">!         ASSERT(kDecimalRepCapacity &gt; kBase10MaximalLength);</span>
<span class="line-modified">!         char decimal_rep[kDecimalRepCapacity];</span>
<span class="line-modified">!         int decimal_rep_length;</span>
<span class="line-modified">!         </span>
<span class="line-modified">!         if (requested_digits == -1) {</span>
<span class="line-modified">!             DoubleToAscii(value, SHORTEST, 0,</span>
<span class="line-modified">!                           decimal_rep, kDecimalRepCapacity,</span>
<span class="line-modified">!                           &amp;sign, &amp;decimal_rep_length, &amp;decimal_point);</span>
<span class="line-modified">!         } else {</span>
<span class="line-modified">!             DoubleToAscii(value, PRECISION, requested_digits + 1,</span>
<span class="line-modified">!                           decimal_rep, kDecimalRepCapacity,</span>
<span class="line-modified">!                           &amp;sign, &amp;decimal_rep_length, &amp;decimal_point);</span>
<span class="line-modified">!             ASSERT(decimal_rep_length &lt;= requested_digits + 1);</span>
<span class="line-modified">!             </span>
<span class="line-modified">!             for (int i = decimal_rep_length; i &lt; requested_digits + 1; ++i) {</span>
<span class="line-modified">!                 decimal_rep[i] = &#39;0&#39;;</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!             decimal_rep_length = requested_digits + 1;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         </span>
<span class="line-modified">!         bool unique_zero = ((flags_ &amp; UNIQUE_ZERO) != 0);</span>
<span class="line-modified">!         if (sign &amp;&amp; (value != 0.0 || !unique_zero)) {</span>
<span class="line-modified">!             result_builder-&gt;AddCharacter(&#39;-&#39;);</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         </span>
<span class="line-modified">!         int exponent = decimal_point - 1;</span>
<span class="line-modified">!         CreateExponentialRepresentation(decimal_rep,</span>
<span class="line-modified">!                                         decimal_rep_length,</span>
<span class="line-modified">!                                         exponent,</span>
<span class="line-modified">!                                         result_builder);</span>
<span class="line-modified">!         return true;</span>
  }
<span class="line-modified">!     </span>
<span class="line-modified">!     </span>
  bool DoubleToStringConverter::ToPrecision(double value,
<span class="line-modified">!                                               int precision,</span>
<span class="line-modified">!                                               StringBuilder* result_builder) const {</span>
<span class="line-modified">!         if (Double(value).IsSpecial()) {</span>
<span class="line-modified">!             return HandleSpecialValues(value, result_builder);</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         </span>
<span class="line-modified">!         if (precision &lt; kMinPrecisionDigits || precision &gt; kMaxPrecisionDigits) {</span>
<span class="line-modified">!             return false;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         </span>
<span class="line-modified">!         // Find a sufficiently precise decimal representation of n.</span>
<span class="line-modified">!         int decimal_point;</span>
<span class="line-modified">!         bool sign;</span>
<span class="line-modified">!         // Add one for the terminating null character.</span>
<span class="line-modified">!         const int kDecimalRepCapacity = kMaxPrecisionDigits + 1;</span>
<span class="line-modified">!         char decimal_rep[kDecimalRepCapacity];</span>
<span class="line-modified">!         int decimal_rep_length;</span>
<span class="line-modified">!         </span>
<span class="line-modified">!         DoubleToAscii(value, PRECISION, precision,</span>
<span class="line-modified">!                       decimal_rep, kDecimalRepCapacity,</span>
<span class="line-modified">!                       &amp;sign, &amp;decimal_rep_length, &amp;decimal_point);</span>
<span class="line-modified">!         ASSERT(decimal_rep_length &lt;= precision);</span>
<span class="line-modified">!         </span>
<span class="line-modified">!         bool unique_zero = ((flags_ &amp; UNIQUE_ZERO) != 0);</span>
<span class="line-modified">!         if (sign &amp;&amp; (value != 0.0 || !unique_zero)) {</span>
<span class="line-modified">!             result_builder-&gt;AddCharacter(&#39;-&#39;);</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         </span>
<span class="line-modified">!         // The exponent if we print the number as x.xxeyyy. That is with the</span>
<span class="line-modified">!         // decimal point after the first digit.</span>
<span class="line-modified">!         int exponent = decimal_point - 1;</span>
<span class="line-modified">!         </span>
<span class="line-modified">!         int extra_zero = ((flags_ &amp; EMIT_TRAILING_ZERO_AFTER_POINT) != 0) ? 1 : 0;</span>
<span class="line-modified">!         if ((-decimal_point + 1 &gt; max_leading_padding_zeroes_in_precision_mode_) ||</span>
<span class="line-modified">!             (decimal_point - precision + extra_zero &gt;</span>
<span class="line-modified">!              max_trailing_padding_zeroes_in_precision_mode_)) {</span>
<span class="line-modified">!                 // Fill buffer to contain &#39;precision&#39; digits.</span>
<span class="line-modified">!                 // Usually the buffer is already at the correct length, but &#39;DoubleToAscii&#39;</span>
<span class="line-modified">!                 // is allowed to return less characters.</span>
<span class="line-modified">!                 for (int i = decimal_rep_length; i &lt; precision; ++i) {</span>
<span class="line-modified">!                     decimal_rep[i] = &#39;0&#39;;</span>
<span class="line-modified">!                 }</span>
<span class="line-modified">!                 </span>
<span class="line-modified">!                 CreateExponentialRepresentation(decimal_rep,</span>
<span class="line-modified">!                                                 precision,</span>
<span class="line-modified">!                                                 exponent,</span>
<span class="line-modified">!                                                 result_builder);</span>
<span class="line-modified">!             } else {</span>
<span class="line-modified">!                 CreateDecimalRepresentation(decimal_rep, decimal_rep_length, decimal_point,</span>
<span class="line-modified">!                                             Max(0, precision - decimal_point),</span>
<span class="line-modified">!                                             result_builder);</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!         return true;</span>
  }
<span class="line-modified">!     </span>
<span class="line-modified">!     </span>
  static BignumDtoaMode DtoaToBignumDtoaMode(
<span class="line-modified">!                                                DoubleToStringConverter::DtoaMode dtoa_mode) {</span>
<span class="line-modified">!         switch (dtoa_mode) {</span>
<span class="line-modified">!             case DoubleToStringConverter::SHORTEST:  return BIGNUM_DTOA_SHORTEST;</span>
      case DoubleToStringConverter::SHORTEST_SINGLE:
          return BIGNUM_DTOA_SHORTEST_SINGLE;
<span class="line-modified">!             case DoubleToStringConverter::FIXED:     return BIGNUM_DTOA_FIXED;</span>
<span class="line-modified">!             case DoubleToStringConverter::PRECISION: return BIGNUM_DTOA_PRECISION;</span>
<span class="line-modified">!             default:</span>
<span class="line-modified">!                 UNREACHABLE();</span>
<span class="line-modified">!     }</span>
  }
<span class="line-modified">!     </span>
<span class="line-modified">!     </span>
  void DoubleToStringConverter::DoubleToAscii(double v,
<span class="line-modified">!                                                 DtoaMode mode,</span>
<span class="line-modified">!                                                 int requested_digits,</span>
<span class="line-modified">!                                                 char* buffer,</span>
<span class="line-modified">!                                                 int buffer_length,</span>
<span class="line-modified">!                                                 bool* sign,</span>
<span class="line-modified">!                                                 int* length,</span>
<span class="line-modified">!                                                 int* point) {</span>
    BufferReference&lt;char&gt; bufferReference(buffer, buffer_length);
<span class="line-modified">!         ASSERT(!Double(v).IsSpecial());</span>
    ASSERT(mode == SHORTEST || mode == SHORTEST_SINGLE || requested_digits &gt;= 0);
<span class="line-modified">!         </span>
<span class="line-modified">!         if (Double(v).Sign() &lt; 0) {</span>
<span class="line-modified">!             *sign = true;</span>
<span class="line-modified">!             v = -v;</span>
<span class="line-modified">!         } else {</span>
<span class="line-modified">!             *sign = false;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         </span>
<span class="line-modified">!         if (mode == PRECISION &amp;&amp; requested_digits == 0) {</span>
      bufferReference[0] = &#39;\0&#39;;
<span class="line-modified">!             *length = 0;</span>
<span class="line-modified">!             return;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         </span>
<span class="line-modified">!         if (v == 0) {</span>
      bufferReference[0] = &#39;0&#39;;
      bufferReference[1] = &#39;\0&#39;;
<span class="line-modified">!             *length = 1;</span>
<span class="line-modified">!             *point = 1;</span>
<span class="line-modified">!             return;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         </span>
<span class="line-modified">!         bool fast_worked;</span>
<span class="line-modified">!         switch (mode) {</span>
<span class="line-modified">!             case SHORTEST:</span>
        fast_worked = FastDtoa(v, FAST_DTOA_SHORTEST, 0, bufferReference, length, point);
        break;
      case SHORTEST_SINGLE:
        fast_worked = FastDtoa(v, FAST_DTOA_SHORTEST_SINGLE, 0,
                               bufferReference, length, point);
<span class="line-modified">!                 break;</span>
<span class="line-modified">!             case FIXED:</span>
        fast_worked = FastFixedDtoa(v, requested_digits, bufferReference, length, point);
<span class="line-modified">!                 break;</span>
<span class="line-modified">!             case PRECISION:</span>
<span class="line-modified">!                 fast_worked = FastDtoa(v, FAST_DTOA_PRECISION, requested_digits,</span>
                               bufferReference, length, point);
<span class="line-modified">!                 break;</span>
<span class="line-modified">!             default:</span>
<span class="line-modified">!                 fast_worked = false;</span>
        UNREACHABLE();
<span class="line-modified">!         }</span>
<span class="line-modified">!         if (fast_worked) return;</span>
<span class="line-modified">!         </span>
<span class="line-modified">!         // If the fast dtoa didn&#39;t succeed use the slower bignum version.</span>
<span class="line-modified">!         BignumDtoaMode bignum_mode = DtoaToBignumDtoaMode(mode);</span>
    BignumDtoa(v, bignum_mode, requested_digits, bufferReference, length, point);
    bufferReference[*length] = &#39;\0&#39;;
  }
  
  // Maximum number of significant digits in decimal representation.
<span class="line-new-header">--- 42,381 ---</span>
  
  #include &lt;wtf/ASCIICType.h&gt;
  
  namespace WTF {
  namespace double_conversion {
<span class="line-modified">! </span>
  const DoubleToStringConverter&amp; DoubleToStringConverter::EcmaScriptConverter() {
<span class="line-modified">!   int flags = UNIQUE_ZERO | EMIT_POSITIVE_EXPONENT_SIGN;</span>
<span class="line-modified">!   static DoubleToStringConverter converter(flags,</span>
<span class="line-modified">!                                            &quot;Infinity&quot;,</span>
<span class="line-modified">!                                            &quot;NaN&quot;,</span>
<span class="line-modified">!                                            &#39;e&#39;,</span>
<span class="line-modified">!                                            -6, 21,</span>
<span class="line-modified">!                                            6, 0);</span>
<span class="line-modified">!   return converter;</span>
  }
<span class="line-modified">! </span>
<span class="line-modified">! </span>
  bool DoubleToStringConverter::HandleSpecialValues(
<span class="line-modified">!     double value,</span>
<span class="line-modified">!     StringBuilder* result_builder) const {</span>
<span class="line-modified">!   Double double_inspect(value);</span>
<span class="line-modified">!   if (double_inspect.IsInfinite()) {</span>
<span class="line-modified">!     if (infinity_symbol_ == NULL) return false;</span>
<span class="line-modified">!     if (value &lt; 0) {</span>
<span class="line-modified">!       result_builder-&gt;AddCharacter(&#39;-&#39;);</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!     result_builder-&gt;AddString(infinity_symbol_);</span>
<span class="line-modified">!     return true;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   if (double_inspect.IsNan()) {</span>
<span class="line-modified">!     if (nan_symbol_ == NULL) return false;</span>
<span class="line-modified">!     result_builder-&gt;AddString(nan_symbol_);</span>
<span class="line-modified">!     return true;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   return false;</span>
  }
<span class="line-modified">! </span>
<span class="line-modified">! </span>
  void DoubleToStringConverter::CreateExponentialRepresentation(
<span class="line-modified">!     const char* decimal_digits,</span>
<span class="line-modified">!     int length,</span>
<span class="line-modified">!     int exponent,</span>
<span class="line-modified">!     StringBuilder* result_builder) const {</span>
<span class="line-modified">!   ASSERT(length != 0);</span>
<span class="line-modified">!   result_builder-&gt;AddCharacter(decimal_digits[0]);</span>
<span class="line-modified">!   if (length != 1) {</span>
<span class="line-modified">!     result_builder-&gt;AddCharacter(&#39;.&#39;);</span>
<span class="line-modified">!     result_builder-&gt;AddSubstring(&amp;decimal_digits[1], length-1);</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   result_builder-&gt;AddCharacter(exponent_character_);</span>
<span class="line-modified">!   if (exponent &lt; 0) {</span>
<span class="line-modified">!     result_builder-&gt;AddCharacter(&#39;-&#39;);</span>
<span class="line-modified">!     exponent = -exponent;</span>
<span class="line-modified">!   } else {</span>
<span class="line-modified">!     if ((flags_ &amp; EMIT_POSITIVE_EXPONENT_SIGN) != 0) {</span>
<span class="line-modified">!       result_builder-&gt;AddCharacter(&#39;+&#39;);</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   if (exponent == 0) {</span>
<span class="line-modified">!     result_builder-&gt;AddCharacter(&#39;0&#39;);</span>
<span class="line-modified">!     return;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   ASSERT(exponent &lt; 1e4);</span>
<span class="line-modified">!   const int kMaxExponentLength = 5;</span>
<span class="line-modified">!   char buffer[kMaxExponentLength + 1];</span>
    buffer[kMaxExponentLength] = &#39;\0&#39;;
<span class="line-modified">!   int first_char_pos = kMaxExponentLength;</span>
<span class="line-modified">!   while (exponent &gt; 0) {</span>
<span class="line-modified">!     buffer[--first_char_pos] = &#39;0&#39; + (exponent % 10);</span>
<span class="line-modified">!     exponent /= 10;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   result_builder-&gt;AddSubstring(&amp;buffer[first_char_pos],</span>
<span class="line-modified">!                                kMaxExponentLength - first_char_pos);</span>
  }
<span class="line-modified">! </span>
<span class="line-modified">! </span>
  void DoubleToStringConverter::CreateDecimalRepresentation(
<span class="line-modified">!     const char* decimal_digits,</span>
<span class="line-modified">!     int length,</span>
<span class="line-modified">!     int decimal_point,</span>
<span class="line-modified">!     int digits_after_point,</span>
<span class="line-modified">!     StringBuilder* result_builder) const {</span>
<span class="line-modified">!   // Create a representation that is padded with zeros if needed.</span>
<span class="line-modified">!   if (decimal_point &lt;= 0) {</span>
        // &quot;0.00000decimal_rep&quot; or &quot;0.000decimal_rep00&quot;.
<span class="line-modified">!     result_builder-&gt;AddCharacter(&#39;0&#39;);</span>
<span class="line-modified">!     if (digits_after_point &gt; 0) {</span>
<span class="line-modified">!       result_builder-&gt;AddCharacter(&#39;.&#39;);</span>
<span class="line-modified">!       result_builder-&gt;AddPadding(&#39;0&#39;, -decimal_point);</span>
<span class="line-modified">!       ASSERT(length &lt;= digits_after_point - (-decimal_point));</span>
<span class="line-modified">!       result_builder-&gt;AddSubstring(decimal_digits, length);</span>
<span class="line-modified">!       int remaining_digits = digits_after_point - (-decimal_point) - length;</span>
<span class="line-modified">!       result_builder-&gt;AddPadding(&#39;0&#39;, remaining_digits);</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!   } else if (decimal_point &gt;= length) {</span>
      // &quot;decimal_rep0000.00000&quot; or &quot;decimal_rep.0000&quot;.
<span class="line-modified">!     result_builder-&gt;AddSubstring(decimal_digits, length);</span>
<span class="line-modified">!     result_builder-&gt;AddPadding(&#39;0&#39;, decimal_point - length);</span>
<span class="line-modified">!     if (digits_after_point &gt; 0) {</span>
<span class="line-modified">!       result_builder-&gt;AddCharacter(&#39;.&#39;);</span>
<span class="line-modified">!       result_builder-&gt;AddPadding(&#39;0&#39;, digits_after_point);</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!   } else {</span>
      // &quot;decima.l_rep000&quot;.
<span class="line-modified">!     ASSERT(digits_after_point &gt; 0);</span>
<span class="line-modified">!     result_builder-&gt;AddSubstring(decimal_digits, decimal_point);</span>
<span class="line-modified">!     result_builder-&gt;AddCharacter(&#39;.&#39;);</span>
<span class="line-modified">!     ASSERT(length - decimal_point &lt;= digits_after_point);</span>
<span class="line-modified">!     result_builder-&gt;AddSubstring(&amp;decimal_digits[decimal_point],</span>
<span class="line-modified">!                                  length - decimal_point);</span>
<span class="line-modified">!     int remaining_digits = digits_after_point - (length - decimal_point);</span>
<span class="line-modified">!     result_builder-&gt;AddPadding(&#39;0&#39;, remaining_digits);</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   if (digits_after_point == 0) {</span>
<span class="line-modified">!     if ((flags_ &amp; EMIT_TRAILING_DECIMAL_POINT) != 0) {</span>
<span class="line-modified">!       result_builder-&gt;AddCharacter(&#39;.&#39;);</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!     if ((flags_ &amp; EMIT_TRAILING_ZERO_AFTER_POINT) != 0) {</span>
<span class="line-modified">!       result_builder-&gt;AddCharacter(&#39;0&#39;);</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!   }</span>
  }
<span class="line-modified">! </span>
<span class="line-modified">! </span>
  bool DoubleToStringConverter::ToShortestIeeeNumber(
      double value,
      StringBuilder* result_builder,
      DoubleToStringConverter::DtoaMode mode) const {
    ASSERT(mode == SHORTEST || mode == SHORTEST_SINGLE);
<span class="line-modified">!   if (Double(value).IsSpecial()) {</span>
<span class="line-modified">!     return HandleSpecialValues(value, result_builder);</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   int decimal_point;</span>
<span class="line-modified">!   bool sign;</span>
<span class="line-modified">!   const int kDecimalRepCapacity = kBase10MaximalLength + 1;</span>
<span class="line-modified">!   char decimal_rep[kDecimalRepCapacity];</span>
<span class="line-modified">!   int decimal_rep_length;</span>
<span class="line-modified">! </span>
    DoubleToAscii(value, mode, 0, decimal_rep, kDecimalRepCapacity,
<span class="line-modified">!                 &amp;sign, &amp;decimal_rep_length, &amp;decimal_point);</span>
<span class="line-modified">! </span>
<span class="line-modified">!   bool unique_zero = (flags_ &amp; UNIQUE_ZERO) != 0;</span>
<span class="line-modified">!   if (sign &amp;&amp; (value != 0.0 || !unique_zero)) {</span>
<span class="line-modified">!     result_builder-&gt;AddCharacter(&#39;-&#39;);</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   int exponent = decimal_point - 1;</span>
<span class="line-modified">!   if ((decimal_in_shortest_low_ &lt;= exponent) &amp;&amp;</span>
<span class="line-modified">!       (exponent &lt; decimal_in_shortest_high_)) {</span>
<span class="line-modified">!     CreateDecimalRepresentation(decimal_rep, decimal_rep_length,</span>
<span class="line-modified">!                                 decimal_point,</span>
<span class="line-modified">!                                 Max(0, decimal_rep_length - decimal_point),</span>
<span class="line-modified">!                                 result_builder);</span>
<span class="line-modified">!   } else {</span>
<span class="line-modified">!     CreateExponentialRepresentation(decimal_rep, decimal_rep_length, exponent,</span>
<span class="line-modified">!                                     result_builder);</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   return true;</span>
  }
<span class="line-modified">! </span>
<span class="line-modified">! </span>
  bool DoubleToStringConverter::ToFixed(double value,
<span class="line-modified">!                                       int requested_digits,</span>
<span class="line-modified">!                                       StringBuilder* result_builder) const {</span>
<span class="line-modified">!   ASSERT(kMaxFixedDigitsBeforePoint == 60);</span>
<span class="line-modified">!   const double kFirstNonFixed = 1e60;</span>
<span class="line-modified">! </span>
<span class="line-modified">!   if (Double(value).IsSpecial()) {</span>
<span class="line-modified">!     return HandleSpecialValues(value, result_builder);</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   if (requested_digits &gt; kMaxFixedDigitsAfterPoint) return false;</span>
<span class="line-modified">!   if (value &gt;= kFirstNonFixed || value &lt;= -kFirstNonFixed) return false;</span>
<span class="line-modified">! </span>
<span class="line-modified">!   // Find a sufficiently precise decimal representation of n.</span>
<span class="line-modified">!   int decimal_point;</span>
<span class="line-modified">!   bool sign;</span>
<span class="line-modified">!   // Add space for the &#39;\0&#39; byte.</span>
<span class="line-modified">!   const int kDecimalRepCapacity =</span>
<span class="line-modified">!       kMaxFixedDigitsBeforePoint + kMaxFixedDigitsAfterPoint + 1;</span>
<span class="line-modified">!   char decimal_rep[kDecimalRepCapacity];</span>
<span class="line-modified">!   int decimal_rep_length;</span>
<span class="line-modified">!   DoubleToAscii(value, FIXED, requested_digits,</span>
<span class="line-modified">!                 decimal_rep, kDecimalRepCapacity,</span>
<span class="line-modified">!                 &amp;sign, &amp;decimal_rep_length, &amp;decimal_point);</span>
<span class="line-modified">! </span>
<span class="line-modified">!   bool unique_zero = ((flags_ &amp; UNIQUE_ZERO) != 0);</span>
<span class="line-modified">!   if (sign &amp;&amp; (value != 0.0 || !unique_zero)) {</span>
<span class="line-modified">!     result_builder-&gt;AddCharacter(&#39;-&#39;);</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   CreateDecimalRepresentation(decimal_rep, decimal_rep_length, decimal_point,</span>
<span class="line-modified">!                               requested_digits, result_builder);</span>
<span class="line-modified">!   return true;</span>
  }
<span class="line-modified">! </span>
<span class="line-modified">! </span>
  bool DoubleToStringConverter::ToExponential(
<span class="line-modified">!     double value,</span>
<span class="line-modified">!     int requested_digits,</span>
<span class="line-modified">!     StringBuilder* result_builder) const {</span>
<span class="line-modified">!   if (Double(value).IsSpecial()) {</span>
<span class="line-modified">!     return HandleSpecialValues(value, result_builder);</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   if (requested_digits &lt; -1) return false;</span>
<span class="line-modified">!   if (requested_digits &gt; kMaxExponentialDigits) return false;</span>
<span class="line-modified">! </span>
<span class="line-modified">!   int decimal_point;</span>
<span class="line-modified">!   bool sign;</span>
<span class="line-modified">!   // Add space for digit before the decimal point and the &#39;\0&#39; character.</span>
<span class="line-modified">!   const int kDecimalRepCapacity = kMaxExponentialDigits + 2;</span>
<span class="line-modified">!   ASSERT(kDecimalRepCapacity &gt; kBase10MaximalLength);</span>
<span class="line-modified">!   char decimal_rep[kDecimalRepCapacity];</span>
<span class="line-modified">!   int decimal_rep_length;</span>
<span class="line-modified">! </span>
<span class="line-modified">!   if (requested_digits == -1) {</span>
<span class="line-modified">!     DoubleToAscii(value, SHORTEST, 0,</span>
<span class="line-modified">!                   decimal_rep, kDecimalRepCapacity,</span>
<span class="line-modified">!                   &amp;sign, &amp;decimal_rep_length, &amp;decimal_point);</span>
<span class="line-modified">!   } else {</span>
<span class="line-modified">!     DoubleToAscii(value, PRECISION, requested_digits + 1,</span>
<span class="line-modified">!                   decimal_rep, kDecimalRepCapacity,</span>
<span class="line-modified">!                   &amp;sign, &amp;decimal_rep_length, &amp;decimal_point);</span>
<span class="line-modified">!     ASSERT(decimal_rep_length &lt;= requested_digits + 1);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     for (int i = decimal_rep_length; i &lt; requested_digits + 1; ++i) {</span>
<span class="line-modified">!       decimal_rep[i] = &#39;0&#39;;</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!     decimal_rep_length = requested_digits + 1;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   bool unique_zero = ((flags_ &amp; UNIQUE_ZERO) != 0);</span>
<span class="line-modified">!   if (sign &amp;&amp; (value != 0.0 || !unique_zero)) {</span>
<span class="line-modified">!     result_builder-&gt;AddCharacter(&#39;-&#39;);</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   int exponent = decimal_point - 1;</span>
<span class="line-modified">!   CreateExponentialRepresentation(decimal_rep,</span>
<span class="line-modified">!                                   decimal_rep_length,</span>
<span class="line-modified">!                                   exponent,</span>
<span class="line-modified">!                                   result_builder);</span>
<span class="line-modified">!   return true;</span>
  }
<span class="line-modified">! </span>
<span class="line-modified">! </span>
  bool DoubleToStringConverter::ToPrecision(double value,
<span class="line-modified">!                                           int precision,</span>
<span class="line-modified">!                                           StringBuilder* result_builder) const {</span>
<span class="line-modified">!   if (Double(value).IsSpecial()) {</span>
<span class="line-modified">!     return HandleSpecialValues(value, result_builder);</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   if (precision &lt; kMinPrecisionDigits || precision &gt; kMaxPrecisionDigits) {</span>
<span class="line-modified">!     return false;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   // Find a sufficiently precise decimal representation of n.</span>
<span class="line-modified">!   int decimal_point;</span>
<span class="line-modified">!   bool sign;</span>
<span class="line-modified">!   // Add one for the terminating null character.</span>
<span class="line-modified">!   const int kDecimalRepCapacity = kMaxPrecisionDigits + 1;</span>
<span class="line-modified">!   char decimal_rep[kDecimalRepCapacity];</span>
<span class="line-modified">!   int decimal_rep_length;</span>
<span class="line-modified">! </span>
<span class="line-modified">!   DoubleToAscii(value, PRECISION, precision,</span>
<span class="line-modified">!                 decimal_rep, kDecimalRepCapacity,</span>
<span class="line-modified">!                 &amp;sign, &amp;decimal_rep_length, &amp;decimal_point);</span>
<span class="line-modified">!   ASSERT(decimal_rep_length &lt;= precision);</span>
<span class="line-modified">! </span>
<span class="line-modified">!   bool unique_zero = ((flags_ &amp; UNIQUE_ZERO) != 0);</span>
<span class="line-modified">!   if (sign &amp;&amp; (value != 0.0 || !unique_zero)) {</span>
<span class="line-modified">!     result_builder-&gt;AddCharacter(&#39;-&#39;);</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   // The exponent if we print the number as x.xxeyyy. That is with the</span>
<span class="line-modified">!   // decimal point after the first digit.</span>
<span class="line-modified">!   int exponent = decimal_point - 1;</span>
<span class="line-modified">! </span>
<span class="line-modified">!   int extra_zero = ((flags_ &amp; EMIT_TRAILING_ZERO_AFTER_POINT) != 0) ? 1 : 0;</span>
<span class="line-modified">!   if ((-decimal_point + 1 &gt; max_leading_padding_zeroes_in_precision_mode_) ||</span>
<span class="line-modified">!       (decimal_point - precision + extra_zero &gt;</span>
<span class="line-modified">!        max_trailing_padding_zeroes_in_precision_mode_)) {</span>
<span class="line-modified">!     // Fill buffer to contain &#39;precision&#39; digits.</span>
<span class="line-modified">!     // Usually the buffer is already at the correct length, but &#39;DoubleToAscii&#39;</span>
<span class="line-modified">!     // is allowed to return less characters.</span>
<span class="line-modified">!     for (int i = decimal_rep_length; i &lt; precision; ++i) {</span>
<span class="line-modified">!       decimal_rep[i] = &#39;0&#39;;</span>
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     CreateExponentialRepresentation(decimal_rep,</span>
<span class="line-modified">!                                     precision,</span>
<span class="line-modified">!                                     exponent,</span>
<span class="line-modified">!                                     result_builder);</span>
<span class="line-modified">!   } else {</span>
<span class="line-modified">!     CreateDecimalRepresentation(decimal_rep, decimal_rep_length, decimal_point,</span>
<span class="line-modified">!                                 Max(0, precision - decimal_point),</span>
<span class="line-modified">!                                 result_builder);</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   return true;</span>
  }
<span class="line-modified">! </span>
<span class="line-modified">! </span>
  static BignumDtoaMode DtoaToBignumDtoaMode(
<span class="line-modified">!     DoubleToStringConverter::DtoaMode dtoa_mode) {</span>
<span class="line-modified">!   switch (dtoa_mode) {</span>
<span class="line-modified">!     case DoubleToStringConverter::SHORTEST:  return BIGNUM_DTOA_SHORTEST;</span>
      case DoubleToStringConverter::SHORTEST_SINGLE:
          return BIGNUM_DTOA_SHORTEST_SINGLE;
<span class="line-modified">!     case DoubleToStringConverter::FIXED:     return BIGNUM_DTOA_FIXED;</span>
<span class="line-modified">!     case DoubleToStringConverter::PRECISION: return BIGNUM_DTOA_PRECISION;</span>
<span class="line-modified">!     default:</span>
<span class="line-modified">!       UNREACHABLE();</span>
<span class="line-modified">!   }</span>
  }
<span class="line-modified">! </span>
<span class="line-modified">! </span>
  void DoubleToStringConverter::DoubleToAscii(double v,
<span class="line-modified">!                                             DtoaMode mode,</span>
<span class="line-modified">!                                             int requested_digits,</span>
<span class="line-modified">!                                             char* buffer,</span>
<span class="line-modified">!                                             int buffer_length,</span>
<span class="line-modified">!                                             bool* sign,</span>
<span class="line-modified">!                                             int* length,</span>
<span class="line-modified">!                                             int* point) {</span>
    BufferReference&lt;char&gt; bufferReference(buffer, buffer_length);
<span class="line-modified">!   ASSERT(!Double(v).IsSpecial());</span>
    ASSERT(mode == SHORTEST || mode == SHORTEST_SINGLE || requested_digits &gt;= 0);
<span class="line-modified">! </span>
<span class="line-modified">!   if (Double(v).Sign() &lt; 0) {</span>
<span class="line-modified">!     *sign = true;</span>
<span class="line-modified">!     v = -v;</span>
<span class="line-modified">!   } else {</span>
<span class="line-modified">!     *sign = false;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   if (mode == PRECISION &amp;&amp; requested_digits == 0) {</span>
      bufferReference[0] = &#39;\0&#39;;
<span class="line-modified">!     *length = 0;</span>
<span class="line-modified">!     return;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   if (v == 0) {</span>
      bufferReference[0] = &#39;0&#39;;
      bufferReference[1] = &#39;\0&#39;;
<span class="line-modified">!     *length = 1;</span>
<span class="line-modified">!     *point = 1;</span>
<span class="line-modified">!     return;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   bool fast_worked;</span>
<span class="line-modified">!   switch (mode) {</span>
<span class="line-modified">!     case SHORTEST:</span>
        fast_worked = FastDtoa(v, FAST_DTOA_SHORTEST, 0, bufferReference, length, point);
        break;
      case SHORTEST_SINGLE:
        fast_worked = FastDtoa(v, FAST_DTOA_SHORTEST_SINGLE, 0,
                               bufferReference, length, point);
<span class="line-modified">!       break;</span>
<span class="line-modified">!     case FIXED:</span>
        fast_worked = FastFixedDtoa(v, requested_digits, bufferReference, length, point);
<span class="line-modified">!       break;</span>
<span class="line-modified">!     case PRECISION:</span>
<span class="line-modified">!       fast_worked = FastDtoa(v, FAST_DTOA_PRECISION, requested_digits,</span>
                               bufferReference, length, point);
<span class="line-modified">!       break;</span>
<span class="line-modified">!     default:</span>
<span class="line-modified">!       fast_worked = false;</span>
        UNREACHABLE();
<span class="line-modified">!   }</span>
<span class="line-modified">!   if (fast_worked) return;</span>
<span class="line-modified">! </span>
<span class="line-modified">!   // If the fast dtoa didn&#39;t succeed use the slower bignum version.</span>
<span class="line-modified">!   BignumDtoaMode bignum_mode = DtoaToBignumDtoaMode(mode);</span>
    BignumDtoa(v, bignum_mode, requested_digits, bufferReference, length, point);
    bufferReference[*length] = &#39;\0&#39;;
  }
  
  // Maximum number of significant digits in decimal representation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 425,17 ***</span>
  // (768 digits). If we parse a number whose first digits are equal to a
  // mean of 2 adjacent doubles (that could have up to 769 digits) the result
  // must be rounded to the bigger one unless the tail consists of zeros, so
  // we don&#39;t need to preserve all the digits.
  const int kMaxSignificantDigits = 772;
<span class="line-modified">!     </span>
<span class="line-modified">!     </span>
  static double SignedZero(bool sign) {
<span class="line-modified">!         return sign ? -0.0 : 0.0;</span>
  }
<span class="line-modified">!     </span>
<span class="line-modified">!     </span>
  // Returns true, when the iterator is equal to end.
  template&lt;class Iterator&gt;
  static inline bool Advance(Iterator* it, Iterator&amp; end) {
    ++(*it);
    return *it == end;
<span class="line-new-header">--- 425,17 ---</span>
  // (768 digits). If we parse a number whose first digits are equal to a
  // mean of 2 adjacent doubles (that could have up to 769 digits) the result
  // must be rounded to the bigger one unless the tail consists of zeros, so
  // we don&#39;t need to preserve all the digits.
  const int kMaxSignificantDigits = 772;
<span class="line-modified">! </span>
<span class="line-modified">! </span>
  static double SignedZero(bool sign) {
<span class="line-modified">!   return sign ? -0.0 : 0.0;</span>
  }
<span class="line-modified">! </span>
<span class="line-modified">! </span>
  // Returns true, when the iterator is equal to end.
  template&lt;class Iterator&gt;
  static inline bool Advance(Iterator* it, Iterator&amp; end) {
    ++(*it);
    return *it == end;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 455,190 ***</span>
  }
  
  template &lt;typename FloatingPointType, class Iterator&gt;
  static FloatingPointType StringToIeee(
      Iterator input,
<span class="line-modified">!                                                    size_t length,</span>
<span class="line-modified">!                                                    size_t* processed_characters_count) {</span>
    static_assert(std::is_floating_point&lt;FloatingPointType&gt;::value, &quot;Only floating point types are allowed.&quot;);
  
    Iterator current = input;
    Iterator end = input + length;
<span class="line-modified">!         </span>
<span class="line-modified">!         *processed_characters_count = 0;</span>
<span class="line-modified">!         </span>
<span class="line-modified">!         // To make sure that iterator dereferencing is valid the following</span>
<span class="line-modified">!         // convention is used:</span>
<span class="line-modified">!         // 1. Each &#39;++current&#39; statement is followed by check for equality to &#39;end&#39;.</span>
<span class="line-modified">!         // 3. If &#39;current&#39; becomes equal to &#39;end&#39; the function returns or goes to</span>
<span class="line-modified">!         // &#39;parsing_done&#39;.</span>
<span class="line-modified">!         // 4. &#39;current&#39; is not dereferenced after the &#39;parsing_done&#39; label.</span>
<span class="line-modified">!         // 5. Code before &#39;parsing_done&#39; may rely on &#39;current != end&#39;.</span>
<span class="line-modified">! </span>
<span class="line-modified">!         if (current == end) return 0.0;</span>
<span class="line-modified">!         </span>
<span class="line-modified">!         // The longest form of simplified number is: &quot;-&lt;significant digits&gt;.1eXXX\0&quot;.</span>
    const int kBufferSize = kMaxSignificantDigits + 10;
<span class="line-modified">!         char buffer[kBufferSize];  // NOLINT: size is known at compile time.</span>
    int buffer_pos = 0;
<span class="line-modified">!         </span>
<span class="line-modified">!         // Exponent will be adjusted if insignificant digits of the integer part</span>
<span class="line-modified">!         // or insignificant leading zeros of the fractional part are dropped.</span>
<span class="line-modified">!         int exponent = 0;</span>
<span class="line-modified">!         int significant_digits = 0;</span>
<span class="line-modified">!         int insignificant_digits = 0;</span>
<span class="line-modified">!         bool nonzero_digit_dropped = false;</span>
<span class="line-modified">! </span>
<span class="line-modified">!         bool sign = false;</span>
<span class="line-modified">!         </span>
<span class="line-modified">!         if (*current == &#39;+&#39; || *current == &#39;-&#39;) {</span>
<span class="line-modified">!             sign = (*current == &#39;-&#39;);</span>
<span class="line-modified">!             ++current;</span>
<span class="line-modified">!             if (current == end) return 0.0;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         </span>
<span class="line-modified">!         bool leading_zero = false;</span>
<span class="line-modified">!         if (*current == &#39;0&#39;) {</span>
      if (Advance(&amp;current, end)) {
        *processed_characters_count = static_cast&lt;size_t&gt;(current - input);
<span class="line-modified">!                 return SignedZero(sign);</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!             </span>
<span class="line-modified">!             leading_zero = true;</span>
<span class="line-modified">!             </span>
<span class="line-modified">!             // Ignore leading zeros in the integer part.</span>
<span class="line-modified">!             while (*current == &#39;0&#39;) {</span>
        if (Advance(&amp;current, end)) {
          *processed_characters_count = static_cast&lt;size_t&gt;(current - input);
<span class="line-modified">!                     return SignedZero(sign);</span>
<span class="line-modified">!                 }</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         </span>
<span class="line-modified">!         // Copy significant digits of the integer part (if any) to the buffer.</span>
<span class="line-modified">!         while (isASCIIDigit(*current)) {</span>
<span class="line-modified">!             if (significant_digits &lt; kMaxSignificantDigits) {</span>
<span class="line-modified">!                 ASSERT(buffer_pos &lt; kBufferSize);</span>
<span class="line-modified">!                 buffer[buffer_pos++] = static_cast&lt;char&gt;(*current);</span>
<span class="line-modified">!                 significant_digits++;</span>
<span class="line-modified">!             } else {</span>
<span class="line-modified">!                 insignificant_digits++;  // Move the digit into the exponential part.</span>
<span class="line-modified">!                 nonzero_digit_dropped = nonzero_digit_dropped || *current != &#39;0&#39;;</span>
<span class="line-modified">!             }</span>
      if (Advance(&amp;current, end)) goto parsing_done;
<span class="line-modified">!         }</span>
<span class="line-modified">!         </span>
<span class="line-modified">!         if (*current == &#39;.&#39;) {</span>
      if (Advance(&amp;current, end)) {
<span class="line-modified">!                 if (significant_digits == 0 &amp;&amp; !leading_zero) {</span>
<span class="line-modified">!                     return 0.0;</span>
<span class="line-modified">!                 } else {</span>
<span class="line-modified">!                     goto parsing_done;</span>
<span class="line-modified">!                 }</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!             </span>
<span class="line-modified">!             if (significant_digits == 0) {</span>
<span class="line-modified">!                 // Integer part consists of 0 or is absent. Significant digits start after</span>
<span class="line-modified">!                 // leading zeros (if any).</span>
<span class="line-modified">!                 while (*current == &#39;0&#39;) {</span>
          if (Advance(&amp;current, end)) {
            *processed_characters_count = static_cast&lt;size_t&gt;(current - input);
<span class="line-modified">!                         return SignedZero(sign);</span>
<span class="line-modified">!                     }</span>
<span class="line-modified">!                     exponent--;  // Move this 0 into the exponent.</span>
<span class="line-modified">!                 }</span>
<span class="line-modified">!             }</span>
  
<span class="line-modified">!             // There is a fractional part.</span>
      // We don&#39;t emit a &#39;.&#39;, but adjust the exponent instead.
<span class="line-modified">!             while (isASCIIDigit(*current)) {</span>
<span class="line-modified">!                 if (significant_digits &lt; kMaxSignificantDigits) {</span>
<span class="line-modified">!                     ASSERT(buffer_pos &lt; kBufferSize);</span>
<span class="line-modified">!                     buffer[buffer_pos++] = static_cast&lt;char&gt;(*current);</span>
<span class="line-modified">!                     significant_digits++;</span>
<span class="line-modified">!                     exponent--;</span>
<span class="line-modified">!                 } else {</span>
<span class="line-modified">!                     // Ignore insignificant digits in the fractional part.</span>
<span class="line-modified">!                     nonzero_digit_dropped = nonzero_digit_dropped || *current != &#39;0&#39;;</span>
<span class="line-modified">!                 }</span>
        if (Advance(&amp;current, end)) goto parsing_done;
<span class="line-modified">!             }</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         </span>
<span class="line-modified">!         if (!leading_zero &amp;&amp; exponent == 0 &amp;&amp; significant_digits == 0) {</span>
<span class="line-modified">!             // If leading_zeros is true then the string contains zeros.</span>
<span class="line-modified">!             // If exponent &lt; 0 then string was [+-]\.0*...</span>
<span class="line-modified">!             // If significant_digits != 0 the string is not equal to 0.</span>
<span class="line-modified">!             // Otherwise there are no digits in the string.</span>
<span class="line-modified">!             return 0.0;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         </span>
<span class="line-modified">!         // Parse exponential part.</span>
<span class="line-modified">!         if (*current == &#39;e&#39; || *current == &#39;E&#39;) {</span>
<span class="line-modified">!             ++current;</span>
<span class="line-modified">!             if (current == end) {</span>
<span class="line-modified">!                 --current;</span>
<span class="line-modified">!                 goto parsing_done;</span>
<span class="line-modified">!             }</span>
      char exponen_sign = 0;
<span class="line-modified">!             if (*current == &#39;+&#39; || *current == &#39;-&#39;) {</span>
        exponen_sign = static_cast&lt;char&gt;(*current);
<span class="line-modified">!                 ++current;</span>
<span class="line-modified">!                 if (current == end) {</span>
<span class="line-modified">!                     current -= 2;</span>
<span class="line-modified">!                     goto parsing_done;</span>
<span class="line-modified">!                 }</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!             </span>
<span class="line-modified">!             if (*current &lt; &#39;0&#39; || *current &gt; &#39;9&#39;) {</span>
        if (exponen_sign)
<span class="line-modified">!                     --current;</span>
<span class="line-modified">!                 --current;</span>
<span class="line-modified">!                 goto parsing_done;</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!             </span>
<span class="line-modified">!             const int max_exponent = INT_MAX / 2;</span>
<span class="line-modified">!             ASSERT(-max_exponent / 2 &lt;= exponent &amp;&amp; exponent &lt;= max_exponent / 2);</span>
<span class="line-modified">!             int num = 0;</span>
<span class="line-modified">!             do {</span>
<span class="line-modified">!                 // Check overflow.</span>
<span class="line-modified">!                 int digit = *current - &#39;0&#39;;</span>
<span class="line-modified">!                 if (num &gt;= max_exponent / 10</span>
<span class="line-modified">!                     &amp;&amp; !(num == max_exponent / 10 &amp;&amp; digit &lt;= max_exponent % 10)) {</span>
<span class="line-modified">!                     num = max_exponent;</span>
<span class="line-modified">!                 } else {</span>
<span class="line-modified">!                     num = num * 10 + digit;</span>
<span class="line-modified">!                 }</span>
<span class="line-modified">!                 ++current;</span>
<span class="line-modified">!             } while (current != end &amp;&amp; isASCIIDigit(*current));</span>
<span class="line-modified">!             </span>
      exponent += (exponen_sign == &#39;-&#39; ? -num : num);
<span class="line-modified">!         }</span>
<span class="line-modified">!         </span>
<span class="line-modified">!     parsing_done:</span>
<span class="line-modified">!         exponent += insignificant_digits;</span>
<span class="line-modified">!         </span>
<span class="line-modified">!         if (nonzero_digit_dropped) {</span>
<span class="line-modified">!             buffer[buffer_pos++] = &#39;1&#39;;</span>
<span class="line-modified">!             exponent--;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         </span>
<span class="line-modified">!         ASSERT(buffer_pos &lt; kBufferSize);</span>
<span class="line-modified">!         buffer[buffer_pos] = &#39;\0&#39;;</span>
<span class="line-modified">!         </span>
    auto converted = StringToFloatingPointType&lt;FloatingPointType&gt;(BufferReference&lt;const char&gt;(buffer, buffer_pos), exponent);
    *processed_characters_count = static_cast&lt;size_t&gt;(current - input);
<span class="line-modified">!         return sign? -converted: converted;</span>
  }
  
  double StringToDoubleConverter::StringToDouble(
      const char* buffer,
      size_t length,
      size_t* processed_characters_count) {
    return StringToIeee&lt;double&gt;(buffer, length, processed_characters_count);
  }
<span class="line-modified">!     </span>
  
  double StringToDoubleConverter::StringToDouble(
      const uc16* buffer,
      size_t length,
      size_t* processed_characters_count) {
<span class="line-new-header">--- 455,190 ---</span>
  }
  
  template &lt;typename FloatingPointType, class Iterator&gt;
  static FloatingPointType StringToIeee(
      Iterator input,
<span class="line-modified">!     size_t length,</span>
<span class="line-modified">!     size_t* processed_characters_count) {</span>
    static_assert(std::is_floating_point&lt;FloatingPointType&gt;::value, &quot;Only floating point types are allowed.&quot;);
  
    Iterator current = input;
    Iterator end = input + length;
<span class="line-modified">! </span>
<span class="line-modified">!   *processed_characters_count = 0;</span>
<span class="line-modified">! </span>
<span class="line-modified">!   // To make sure that iterator dereferencing is valid the following</span>
<span class="line-modified">!   // convention is used:</span>
<span class="line-modified">!   // 1. Each &#39;++current&#39; statement is followed by check for equality to &#39;end&#39;.</span>
<span class="line-modified">!   // 3. If &#39;current&#39; becomes equal to &#39;end&#39; the function returns or goes to</span>
<span class="line-modified">!   // &#39;parsing_done&#39;.</span>
<span class="line-modified">!   // 4. &#39;current&#39; is not dereferenced after the &#39;parsing_done&#39; label.</span>
<span class="line-modified">!   // 5. Code before &#39;parsing_done&#39; may rely on &#39;current != end&#39;.</span>
<span class="line-modified">! </span>
<span class="line-modified">!   if (current == end) return 0.0;</span>
<span class="line-modified">! </span>
<span class="line-modified">!   // The longest form of simplified number is: &quot;-&lt;significant digits&gt;.1eXXX\0&quot;.</span>
    const int kBufferSize = kMaxSignificantDigits + 10;
<span class="line-modified">!   char buffer[kBufferSize];  // NOLINT: size is known at compile time.</span>
    int buffer_pos = 0;
<span class="line-modified">! </span>
<span class="line-modified">!   // Exponent will be adjusted if insignificant digits of the integer part</span>
<span class="line-modified">!   // or insignificant leading zeros of the fractional part are dropped.</span>
<span class="line-modified">!   int exponent = 0;</span>
<span class="line-modified">!   int significant_digits = 0;</span>
<span class="line-modified">!   int insignificant_digits = 0;</span>
<span class="line-modified">!   bool nonzero_digit_dropped = false;</span>
<span class="line-modified">! </span>
<span class="line-modified">!   bool sign = false;</span>
<span class="line-modified">! </span>
<span class="line-modified">!   if (*current == &#39;+&#39; || *current == &#39;-&#39;) {</span>
<span class="line-modified">!     sign = (*current == &#39;-&#39;);</span>
<span class="line-modified">!     ++current;</span>
<span class="line-modified">!     if (current == end) return 0.0;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   bool leading_zero = false;</span>
<span class="line-modified">!   if (*current == &#39;0&#39;) {</span>
      if (Advance(&amp;current, end)) {
        *processed_characters_count = static_cast&lt;size_t&gt;(current - input);
<span class="line-modified">!       return SignedZero(sign);</span>
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     leading_zero = true;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     // Ignore leading zeros in the integer part.</span>
<span class="line-modified">!     while (*current == &#39;0&#39;) {</span>
        if (Advance(&amp;current, end)) {
          *processed_characters_count = static_cast&lt;size_t&gt;(current - input);
<span class="line-modified">!         return SignedZero(sign);</span>
<span class="line-modified">!       }</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   // Copy significant digits of the integer part (if any) to the buffer.</span>
<span class="line-modified">!   while (isASCIIDigit(*current)) {</span>
<span class="line-modified">!     if (significant_digits &lt; kMaxSignificantDigits) {</span>
<span class="line-modified">!       ASSERT(buffer_pos &lt; kBufferSize);</span>
<span class="line-modified">!       buffer[buffer_pos++] = static_cast&lt;char&gt;(*current);</span>
<span class="line-modified">!       significant_digits++;</span>
<span class="line-modified">!     } else {</span>
<span class="line-modified">!       insignificant_digits++;  // Move the digit into the exponential part.</span>
<span class="line-modified">!       nonzero_digit_dropped = nonzero_digit_dropped || *current != &#39;0&#39;;</span>
<span class="line-modified">!     }</span>
      if (Advance(&amp;current, end)) goto parsing_done;
<span class="line-modified">!   }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   if (*current == &#39;.&#39;) {</span>
      if (Advance(&amp;current, end)) {
<span class="line-modified">!       if (significant_digits == 0 &amp;&amp; !leading_zero) {</span>
<span class="line-modified">!         return 0.0;</span>
<span class="line-modified">!       } else {</span>
<span class="line-modified">!         goto parsing_done;</span>
<span class="line-modified">!       }</span>
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     if (significant_digits == 0) {</span>
<span class="line-modified">!       // Integer part consists of 0 or is absent. Significant digits start after</span>
<span class="line-modified">!       // leading zeros (if any).</span>
<span class="line-modified">!       while (*current == &#39;0&#39;) {</span>
          if (Advance(&amp;current, end)) {
            *processed_characters_count = static_cast&lt;size_t&gt;(current - input);
<span class="line-modified">!           return SignedZero(sign);</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         exponent--;  // Move this 0 into the exponent.</span>
<span class="line-modified">!       }</span>
<span class="line-modified">!     }</span>
  
<span class="line-modified">!     // There is a fractional part.</span>
      // We don&#39;t emit a &#39;.&#39;, but adjust the exponent instead.
<span class="line-modified">!     while (isASCIIDigit(*current)) {</span>
<span class="line-modified">!       if (significant_digits &lt; kMaxSignificantDigits) {</span>
<span class="line-modified">!         ASSERT(buffer_pos &lt; kBufferSize);</span>
<span class="line-modified">!         buffer[buffer_pos++] = static_cast&lt;char&gt;(*current);</span>
<span class="line-modified">!         significant_digits++;</span>
<span class="line-modified">!         exponent--;</span>
<span class="line-modified">!       } else {</span>
<span class="line-modified">!         // Ignore insignificant digits in the fractional part.</span>
<span class="line-modified">!         nonzero_digit_dropped = nonzero_digit_dropped || *current != &#39;0&#39;;</span>
<span class="line-modified">!       }</span>
        if (Advance(&amp;current, end)) goto parsing_done;
<span class="line-modified">!     }</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   if (!leading_zero &amp;&amp; exponent == 0 &amp;&amp; significant_digits == 0) {</span>
<span class="line-modified">!     // If leading_zeros is true then the string contains zeros.</span>
<span class="line-modified">!     // If exponent &lt; 0 then string was [+-]\.0*...</span>
<span class="line-modified">!     // If significant_digits != 0 the string is not equal to 0.</span>
<span class="line-modified">!     // Otherwise there are no digits in the string.</span>
<span class="line-modified">!     return 0.0;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   // Parse exponential part.</span>
<span class="line-modified">!   if (*current == &#39;e&#39; || *current == &#39;E&#39;) {</span>
<span class="line-modified">!     ++current;</span>
<span class="line-modified">!     if (current == end) {</span>
<span class="line-modified">!       --current;</span>
<span class="line-modified">!       goto parsing_done;</span>
<span class="line-modified">!     }</span>
      char exponen_sign = 0;
<span class="line-modified">!     if (*current == &#39;+&#39; || *current == &#39;-&#39;) {</span>
        exponen_sign = static_cast&lt;char&gt;(*current);
<span class="line-modified">!       ++current;</span>
<span class="line-modified">!       if (current == end) {</span>
<span class="line-modified">!         current -= 2;</span>
<span class="line-modified">!         goto parsing_done;</span>
<span class="line-modified">!       }</span>
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     if (*current &lt; &#39;0&#39; || *current &gt; &#39;9&#39;) {</span>
        if (exponen_sign)
<span class="line-modified">!         --current;</span>
<span class="line-modified">!       --current;</span>
<span class="line-modified">!       goto parsing_done;</span>
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     const int max_exponent = INT_MAX / 2;</span>
<span class="line-modified">!     ASSERT(-max_exponent / 2 &lt;= exponent &amp;&amp; exponent &lt;= max_exponent / 2);</span>
<span class="line-modified">!     int num = 0;</span>
<span class="line-modified">!     do {</span>
<span class="line-modified">!       // Check overflow.</span>
<span class="line-modified">!       int digit = *current - &#39;0&#39;;</span>
<span class="line-modified">!       if (num &gt;= max_exponent / 10</span>
<span class="line-modified">!           &amp;&amp; !(num == max_exponent / 10 &amp;&amp; digit &lt;= max_exponent % 10)) {</span>
<span class="line-modified">!         num = max_exponent;</span>
<span class="line-modified">!       } else {</span>
<span class="line-modified">!         num = num * 10 + digit;</span>
<span class="line-modified">!       }</span>
<span class="line-modified">!       ++current;</span>
<span class="line-modified">!     } while (current != end &amp;&amp; isASCIIDigit(*current));</span>
<span class="line-modified">! </span>
      exponent += (exponen_sign == &#39;-&#39; ? -num : num);
<span class="line-modified">!   }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   parsing_done:</span>
<span class="line-modified">!   exponent += insignificant_digits;</span>
<span class="line-modified">! </span>
<span class="line-modified">!   if (nonzero_digit_dropped) {</span>
<span class="line-modified">!     buffer[buffer_pos++] = &#39;1&#39;;</span>
<span class="line-modified">!     exponent--;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   ASSERT(buffer_pos &lt; kBufferSize);</span>
<span class="line-modified">!   buffer[buffer_pos] = &#39;\0&#39;;</span>
<span class="line-modified">! </span>
    auto converted = StringToFloatingPointType&lt;FloatingPointType&gt;(BufferReference&lt;const char&gt;(buffer, buffer_pos), exponent);
    *processed_characters_count = static_cast&lt;size_t&gt;(current - input);
<span class="line-modified">!   return sign? -converted: converted;</span>
  }
  
  double StringToDoubleConverter::StringToDouble(
      const char* buffer,
      size_t length,
      size_t* processed_characters_count) {
    return StringToIeee&lt;double&gt;(buffer, length, processed_characters_count);
  }
<span class="line-modified">! </span>
  
  double StringToDoubleConverter::StringToDouble(
      const uc16* buffer,
      size_t length,
      size_t* processed_characters_count) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 660,6 ***</span>
      size_t* processed_characters_count) {
    return StringToIeee&lt;float&gt;(buffer, length, processed_characters_count);
  }
  
  }  // namespace double_conversion
<span class="line-modified">! } // namespace WTF</span>
<span class="line-new-header">--- 660,6 ---</span>
      size_t* processed_characters_count) {
    return StringToIeee&lt;float&gt;(buffer, length, processed_characters_count);
  }
  
  }  // namespace double_conversion
<span class="line-modified">! }  // namespace WTF</span>
</pre>
<center><a href="diy-fp.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="double-conversion.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>