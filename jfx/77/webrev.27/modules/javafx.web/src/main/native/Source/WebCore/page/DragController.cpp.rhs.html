<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/page/DragController.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2007-2016 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;DragController.h&quot;
  28 
  29 #include &quot;HTMLAnchorElement.h&quot;
  30 #include &quot;SVGAElement.h&quot;
  31 
  32 #if ENABLE(DRAG_SUPPORT)
  33 #include &quot;CachedImage.h&quot;
  34 #include &quot;CachedResourceLoader.h&quot;
  35 #include &quot;DataTransfer.h&quot;
  36 #include &quot;Document.h&quot;
  37 #include &quot;DocumentFragment.h&quot;
  38 #include &quot;DragActions.h&quot;
  39 #include &quot;DragClient.h&quot;
  40 #include &quot;DragData.h&quot;
  41 #include &quot;DragImage.h&quot;
  42 #include &quot;DragState.h&quot;
  43 #include &quot;Editing.h&quot;
  44 #include &quot;Editor.h&quot;
  45 #include &quot;EditorClient.h&quot;
  46 #include &quot;ElementAncestorIterator.h&quot;
  47 #include &quot;EventHandler.h&quot;
  48 #include &quot;File.h&quot;
  49 #include &quot;FloatRect.h&quot;
  50 #include &quot;FocusController.h&quot;
  51 #include &quot;Frame.h&quot;
  52 #include &quot;FrameLoadRequest.h&quot;
  53 #include &quot;FrameLoader.h&quot;
  54 #include &quot;FrameSelection.h&quot;
  55 #include &quot;FrameView.h&quot;
  56 #include &quot;HTMLAttachmentElement.h&quot;
  57 #include &quot;HTMLImageElement.h&quot;
  58 #include &quot;HTMLInputElement.h&quot;
  59 #include &quot;HTMLParserIdioms.h&quot;
  60 #include &quot;HTMLPlugInElement.h&quot;
  61 #include &quot;HitTestRequest.h&quot;
  62 #include &quot;HitTestResult.h&quot;
  63 #include &quot;Image.h&quot;
  64 #include &quot;ImageOrientation.h&quot;
  65 #include &quot;MoveSelectionCommand.h&quot;
  66 #include &quot;Page.h&quot;
  67 #include &quot;Pasteboard.h&quot;
  68 #include &quot;PlatformKeyboardEvent.h&quot;
  69 #include &quot;PluginDocument.h&quot;
  70 #include &quot;PluginViewBase.h&quot;
  71 #include &quot;Position.h&quot;
  72 #include &quot;PromisedAttachmentInfo.h&quot;
  73 #include &quot;RenderAttachment.h&quot;
  74 #include &quot;RenderFileUploadControl.h&quot;
  75 #include &quot;RenderImage.h&quot;
  76 #include &quot;RenderView.h&quot;
  77 #include &quot;ReplaceSelectionCommand.h&quot;
  78 #include &quot;ResourceRequest.h&quot;
  79 #include &quot;SecurityOrigin.h&quot;
  80 #include &quot;Settings.h&quot;
  81 #include &quot;ShadowRoot.h&quot;
  82 #include &quot;StyleProperties.h&quot;
  83 #include &quot;Text.h&quot;
  84 #include &quot;TextEvent.h&quot;
  85 #include &quot;VisiblePosition.h&quot;
  86 #include &quot;markup.h&quot;
  87 
  88 #if ENABLE(DATA_INTERACTION)
  89 #include &quot;SelectionRect.h&quot;
  90 #endif
  91 
  92 #include &lt;wtf/RefPtr.h&gt;
  93 #include &lt;wtf/SetForScope.h&gt;
  94 #endif
  95 
  96 #if ENABLE(DATA_DETECTION)
  97 #include &quot;DataDetection.h&quot;
  98 #endif
  99 
 100 namespace WebCore {
 101 
 102 bool isDraggableLink(const Element&amp; element)
 103 {
 104     if (is&lt;HTMLAnchorElement&gt;(element)) {
 105         auto&amp; anchorElement = downcast&lt;HTMLAnchorElement&gt;(element);
 106         if (!anchorElement.isLiveLink())
 107             return false;
 108 #if ENABLE(DATA_DETECTION)
 109         return !DataDetection::isDataDetectorURL(anchorElement.href());
 110 #else
 111         return true;
 112 #endif
 113     }
 114     if (is&lt;SVGAElement&gt;(element))
 115         return element.isLink();
 116     return false;
 117 }
 118 
 119 #if ENABLE(DRAG_SUPPORT)
 120 
 121 static PlatformMouseEvent createMouseEvent(const DragData&amp; dragData)
 122 {
 123     bool shiftKey = false;
 124     bool ctrlKey = false;
 125     bool altKey = false;
 126     bool metaKey = false;
 127 
 128     PlatformKeyboardEvent::getCurrentModifierState(shiftKey, ctrlKey, altKey, metaKey);
 129 
 130     return PlatformMouseEvent(dragData.clientPosition(), dragData.globalPosition(),
 131                               LeftButton, PlatformEvent::MouseMoved, 0, shiftKey, ctrlKey, altKey,
 132                               metaKey, WallTime::now(), ForceAtClick, NoTap);
 133 }
 134 
 135 DragController::DragController(Page&amp; page, DragClient&amp; client)
 136     : m_page(page)
 137     , m_client(client)
<a name="1" id="anc1"></a>





 138 {
 139 }
 140 
 141 DragController::~DragController()
 142 {
 143     m_client.dragControllerDestroyed();
 144 }
 145 
 146 static RefPtr&lt;DocumentFragment&gt; documentFragmentFromDragData(const DragData&amp; dragData, Frame&amp; frame, Range&amp; context, bool allowPlainText, bool&amp; chosePlainText)
 147 {
 148     chosePlainText = false;
 149 
 150     Document&amp; document = context.ownerDocument();
 151     if (dragData.containsCompatibleContent()) {
 152         if (auto fragment = frame.editor().webContentFromPasteboard(*Pasteboard::createForDragAndDrop(dragData), context, allowPlainText, chosePlainText))
 153             return fragment;
 154 
 155         if (dragData.containsURL(DragData::DoNotConvertFilenames)) {
 156             String title;
 157             String url = dragData.asURL(DragData::DoNotConvertFilenames, &amp;title);
 158             if (!url.isEmpty()) {
 159                 auto anchor = HTMLAnchorElement::create(document);
 160                 anchor-&gt;setHref(url);
 161                 if (title.isEmpty()) {
 162                     // Try the plain text first because the url might be normalized or escaped.
 163                     if (dragData.containsPlainText())
 164                         title = dragData.asPlainText();
 165                     if (title.isEmpty())
 166                         title = url;
 167                 }
 168                 anchor-&gt;appendChild(document.createTextNode(title));
 169                 auto fragment = document.createDocumentFragment();
 170                 fragment-&gt;appendChild(anchor);
<a name="2" id="anc2"></a><span class="line-modified"> 171                 return fragment;</span>
 172             }
 173         }
 174     }
 175     if (allowPlainText &amp;&amp; dragData.containsPlainText()) {
 176         chosePlainText = true;
 177         return createFragmentFromText(context, dragData.asPlainText()).ptr();
 178     }
 179 
 180     return nullptr;
 181 }
 182 
 183 #if !PLATFORM(IOS_FAMILY)
 184 
 185 DragOperation DragController::platformGenericDragOperation()
 186 {
 187     return DragOperationMove;
 188 }
 189 
 190 #endif
 191 
 192 bool DragController::dragIsMove(FrameSelection&amp; selection, const DragData&amp; dragData)
 193 {
 194     const VisibleSelection&amp; visibleSelection = selection.selection();
 195     return m_documentUnderMouse == m_dragInitiator &amp;&amp; visibleSelection.isContentEditable() &amp;&amp; visibleSelection.isRange() &amp;&amp; !isCopyKeyDown(dragData);
 196 }
 197 
 198 void DragController::clearDragCaret()
 199 {
 200     m_page.dragCaretController().clear();
 201 }
 202 
 203 void DragController::dragEnded()
 204 {
 205     m_dragInitiator = nullptr;
 206     m_didInitiateDrag = false;
 207     m_documentUnderMouse = nullptr;
 208     clearDragCaret();
 209 
 210     m_client.dragEnded();
 211 }
 212 
 213 DragOperation DragController::dragEntered(const DragData&amp; dragData)
 214 {
 215     return dragEnteredOrUpdated(dragData);
 216 }
 217 
 218 void DragController::dragExited(const DragData&amp; dragData)
 219 {
 220     auto&amp; mainFrame = m_page.mainFrame();
 221     if (mainFrame.view())
 222         mainFrame.eventHandler().cancelDragAndDrop(createMouseEvent(dragData), Pasteboard::createForDragAndDrop(dragData), dragData.draggingSourceOperationMask(), dragData.containsFiles());
 223     mouseMovedIntoDocument(nullptr);
 224     if (m_fileInputElementUnderMouse)
 225         m_fileInputElementUnderMouse-&gt;setCanReceiveDroppedFiles(false);
 226     m_fileInputElementUnderMouse = nullptr;
 227 }
 228 
 229 DragOperation DragController::dragUpdated(const DragData&amp; dragData)
 230 {
 231     return dragEnteredOrUpdated(dragData);
 232 }
 233 
 234 inline static bool dragIsHandledByDocument(DragHandlingMethod dragHandlingMethod)
 235 {
 236     return dragHandlingMethod != DragHandlingMethod::None &amp;&amp; dragHandlingMethod != DragHandlingMethod::PageLoad;
 237 }
 238 
 239 bool DragController::performDragOperation(const DragData&amp; dragData)
 240 {
 241     SetForScope&lt;bool&gt; isPerformingDrop(m_isPerformingDrop, true);
 242     TemporarySelectionChange ignoreSelectionChanges(m_page.focusController().focusedOrMainFrame(), WTF::nullopt, TemporarySelectionOption::IgnoreSelectionChanges);
 243 
 244     m_documentUnderMouse = m_page.mainFrame().documentAtPoint(dragData.clientPosition());
 245 
 246     ShouldOpenExternalURLsPolicy shouldOpenExternalURLsPolicy = ShouldOpenExternalURLsPolicy::ShouldNotAllow;
 247     if (m_documentUnderMouse)
 248         shouldOpenExternalURLsPolicy = m_documentUnderMouse-&gt;shouldOpenExternalURLsPolicyToPropagate();
 249 
 250     if ((m_dragDestinationAction &amp; DragDestinationActionDHTML) &amp;&amp; dragIsHandledByDocument(m_dragHandlingMethod)) {
 251         m_client.willPerformDragDestinationAction(DragDestinationActionDHTML, dragData);
 252         Ref&lt;Frame&gt; mainFrame(m_page.mainFrame());
 253         bool preventedDefault = false;
 254         if (mainFrame-&gt;view())
 255             preventedDefault = mainFrame-&gt;eventHandler().performDragAndDrop(createMouseEvent(dragData), Pasteboard::createForDragAndDrop(dragData), dragData.draggingSourceOperationMask(), dragData.containsFiles());
 256         if (preventedDefault) {
 257             clearDragCaret();
 258             m_documentUnderMouse = nullptr;
 259             return true;
 260         }
 261     }
 262 
 263     if ((m_dragDestinationAction &amp; DragDestinationActionEdit) &amp;&amp; concludeEditDrag(dragData)) {
 264         m_client.didConcludeEditDrag();
 265         m_documentUnderMouse = nullptr;
 266         clearDragCaret();
 267         return true;
 268     }
 269 
 270     m_documentUnderMouse = nullptr;
 271     clearDragCaret();
 272 
 273     if (operationForLoad(dragData) == DragOperationNone)
 274         return false;
 275 
 276     auto urlString = dragData.asURL();
 277     if (urlString.isEmpty())
 278         return false;
 279 
 280     m_client.willPerformDragDestinationAction(DragDestinationActionLoad, dragData);
<a name="3" id="anc3"></a><span class="line-modified"> 281     FrameLoadRequest frameLoadRequest { m_page.mainFrame(), ResourceRequest { urlString }, shouldOpenExternalURLsPolicy };</span>
 282     frameLoadRequest.setIsRequestFromClientOrUserInput();
 283     m_page.mainFrame().loader().load(WTFMove(frameLoadRequest));
 284     return true;
 285 }
 286 
 287 void DragController::mouseMovedIntoDocument(Document* newDocument)
 288 {
 289     if (m_documentUnderMouse == newDocument)
 290         return;
 291 
 292     // If we were over another document clear the selection
 293     if (m_documentUnderMouse)
 294         clearDragCaret();
 295     m_documentUnderMouse = newDocument;
 296 }
 297 
 298 DragOperation DragController::dragEnteredOrUpdated(const DragData&amp; dragData)
 299 {
 300     mouseMovedIntoDocument(m_page.mainFrame().documentAtPoint(dragData.clientPosition()));
 301 
 302     m_dragDestinationAction = dragData.dragDestinationAction();
 303     if (m_dragDestinationAction == DragDestinationActionNone) {
 304         clearDragCaret(); // FIXME: Why not call mouseMovedIntoDocument(nullptr)?
 305         return DragOperationNone;
 306     }
 307 
 308     DragOperation dragOperation = DragOperationNone;
 309     m_dragHandlingMethod = tryDocumentDrag(dragData, m_dragDestinationAction, dragOperation);
 310     if (m_dragHandlingMethod == DragHandlingMethod::None &amp;&amp; (m_dragDestinationAction &amp; DragDestinationActionLoad)) {
 311         dragOperation = operationForLoad(dragData);
 312         if (dragOperation != DragOperationNone)
 313             m_dragHandlingMethod = DragHandlingMethod::PageLoad;
 314     } else if (m_dragHandlingMethod == DragHandlingMethod::SetColor)
 315         dragOperation = DragOperationCopy;
 316 
 317     updateSupportedTypeIdentifiersForDragHandlingMethod(m_dragHandlingMethod, dragData);
 318     return dragOperation;
 319 }
 320 
 321 static HTMLInputElement* asFileInput(Node&amp; node)
 322 {
 323     if (!is&lt;HTMLInputElement&gt;(node))
 324         return nullptr;
 325 
 326     auto* inputElement = &amp;downcast&lt;HTMLInputElement&gt;(node);
 327 
 328     // If this is a button inside of the a file input, move up to the file input.
 329     if (inputElement-&gt;isTextButton() &amp;&amp; is&lt;ShadowRoot&gt;(inputElement-&gt;treeScope().rootNode())) {
 330         auto&amp; host = *downcast&lt;ShadowRoot&gt;(inputElement-&gt;treeScope().rootNode()).host();
 331         inputElement = is&lt;HTMLInputElement&gt;(host) ? &amp;downcast&lt;HTMLInputElement&gt;(host) : nullptr;
 332     }
 333 
 334     return inputElement &amp;&amp; inputElement-&gt;isFileUpload() ? inputElement : nullptr;
 335 }
 336 
 337 #if ENABLE(INPUT_TYPE_COLOR)
 338 
 339 static bool isEnabledColorInput(Node&amp; node)
 340 {
 341     if (!is&lt;HTMLInputElement&gt;(node))
<a name="4" id="anc4"></a><span class="line-modified"> 342         return false;</span>
 343     auto&amp; input = downcast&lt;HTMLInputElement&gt;(node);
 344     return input.isColorControl() &amp;&amp; !input.isDisabledFormControl();
 345 }
 346 
 347 static bool isInShadowTreeOfEnabledColorInput(Node&amp; node)
 348 {
 349     auto* host = node.shadowHost();
 350     return host &amp;&amp; isEnabledColorInput(*host);
 351 }
 352 
 353 #endif
 354 
 355 // This can return null if an empty document is loaded.
 356 static Element* elementUnderMouse(Document* documentUnderMouse, const IntPoint&amp; p)
 357 {
 358     Frame* frame = documentUnderMouse-&gt;frame();
 359     float zoomFactor = frame ? frame-&gt;pageZoomFactor() : 1;
 360     LayoutPoint point(p.x() * zoomFactor, p.y() * zoomFactor);
 361 
 362     HitTestResult result(point);
 363     documentUnderMouse-&gt;hitTest(HitTestRequest(), result);
 364 
 365     auto* node = result.innerNode();
 366     if (!node)
 367         return nullptr;
 368     // FIXME: Use parentElementInComposedTree here.
 369     auto* element = is&lt;Element&gt;(*node) ? &amp;downcast&lt;Element&gt;(*node) : node-&gt;parentElement();
 370     auto* host = element-&gt;shadowHost();
 371     return host ? host : element;
 372 }
 373 
 374 #if !ENABLE(DATA_INTERACTION)
 375 
 376 void DragController::updateSupportedTypeIdentifiersForDragHandlingMethod(DragHandlingMethod, const DragData&amp;) const
 377 {
 378 }
 379 
 380 #endif
 381 
 382 DragHandlingMethod DragController::tryDocumentDrag(const DragData&amp; dragData, DragDestinationAction actionMask, DragOperation&amp; dragOperation)
 383 {
 384     if (!m_documentUnderMouse)
 385         return DragHandlingMethod::None;
 386 
 387     if (m_dragInitiator &amp;&amp; !m_documentUnderMouse-&gt;securityOrigin().canReceiveDragData(m_dragInitiator-&gt;securityOrigin()))
 388         return DragHandlingMethod::None;
 389 
 390     bool isHandlingDrag = false;
 391     if (actionMask &amp; DragDestinationActionDHTML) {
 392         isHandlingDrag = tryDHTMLDrag(dragData, dragOperation);
 393         // Do not continue if m_documentUnderMouse has been reset by tryDHTMLDrag.
 394         // tryDHTMLDrag fires dragenter event. The event listener that listens
 395         // to this event may create a nested message loop (open a modal dialog),
 396         // which could process dragleave event and reset m_documentUnderMouse in
 397         // dragExited.
 398         if (!m_documentUnderMouse)
 399             return DragHandlingMethod::None;
 400     }
 401 
 402     // It&#39;s unclear why this check is after tryDHTMLDrag.
 403     // We send drag events in tryDHTMLDrag and that may be the reason.
 404     RefPtr&lt;FrameView&gt; frameView = m_documentUnderMouse-&gt;view();
 405     if (!frameView)
 406         return DragHandlingMethod::None;
 407 
 408     if (isHandlingDrag) {
 409         clearDragCaret();
 410         m_numberOfItemsToBeAccepted = dragData.numberOfFiles();
 411         return DragHandlingMethod::NonDefault;
 412     }
 413 
 414     if ((actionMask &amp; DragDestinationActionEdit) &amp;&amp; canProcessDrag(dragData)) {
 415         if (dragData.containsColor()) {
 416             dragOperation = DragOperationGeneric;
 417             return DragHandlingMethod::SetColor;
 418         }
 419 
 420         IntPoint point = frameView-&gt;windowToContents(dragData.clientPosition());
 421         Element* element = elementUnderMouse(m_documentUnderMouse.get(), point);
 422         if (!element)
 423             return DragHandlingMethod::None;
 424 
 425         HTMLInputElement* elementAsFileInput = asFileInput(*element);
 426         if (m_fileInputElementUnderMouse != elementAsFileInput) {
 427             if (m_fileInputElementUnderMouse)
 428                 m_fileInputElementUnderMouse-&gt;setCanReceiveDroppedFiles(false);
 429             m_fileInputElementUnderMouse = elementAsFileInput;
 430         }
 431 
 432         if (!m_fileInputElementUnderMouse)
 433             m_page.dragCaretController().setCaretPosition(m_documentUnderMouse-&gt;frame()-&gt;visiblePositionForPoint(point));
 434         else
 435             clearDragCaret();
 436 
 437         Frame* innerFrame = element-&gt;document().frame();
 438         dragOperation = dragIsMove(innerFrame-&gt;selection(), dragData) ? DragOperationMove : DragOperationCopy;
<a name="5" id="anc5"></a>
 439 
 440         unsigned numberOfFiles = dragData.numberOfFiles();
 441         if (m_fileInputElementUnderMouse) {
 442             if (m_fileInputElementUnderMouse-&gt;isDisabledFormControl())
 443                 m_numberOfItemsToBeAccepted = 0;
 444             else if (m_fileInputElementUnderMouse-&gt;multiple())
 445                 m_numberOfItemsToBeAccepted = numberOfFiles;
 446             else if (numberOfFiles &gt; 1)
 447                 m_numberOfItemsToBeAccepted = 0;
 448             else
 449                 m_numberOfItemsToBeAccepted = 1;
 450 
 451             if (!m_numberOfItemsToBeAccepted)
 452                 dragOperation = DragOperationNone;
 453             m_fileInputElementUnderMouse-&gt;setCanReceiveDroppedFiles(m_numberOfItemsToBeAccepted);
 454         } else {
<a name="6" id="anc6"></a><span class="line-modified"> 455             // We are not over a file input element. The dragged item(s) will loaded into the view,</span>
<span class="line-modified"> 456             // dropped as text paths on other input elements, or handled by script on the page.</span>
<span class="line-modified"> 457             m_numberOfItemsToBeAccepted = numberOfFiles;</span>
 458         }
 459 
 460         if (m_fileInputElementUnderMouse)
 461             return DragHandlingMethod::UploadFile;
 462 
 463         if (m_page.dragCaretController().isContentRichlyEditable())
 464             return DragHandlingMethod::EditRichText;
 465 
 466         return DragHandlingMethod::EditPlainText;
 467     }
 468 
 469     // We are not over an editable region. Make sure we&#39;re clearing any prior drag cursor.
 470     clearDragCaret();
 471     if (m_fileInputElementUnderMouse)
 472         m_fileInputElementUnderMouse-&gt;setCanReceiveDroppedFiles(false);
 473     m_fileInputElementUnderMouse = nullptr;
 474     return DragHandlingMethod::None;
 475 }
 476 
 477 DragSourceAction DragController::delegateDragSourceAction(const IntPoint&amp; rootViewPoint)
 478 {
 479     m_dragSourceAction = m_client.dragSourceActionMaskForPoint(rootViewPoint);
 480     return m_dragSourceAction;
 481 }
 482 
 483 DragOperation DragController::operationForLoad(const DragData&amp; dragData)
 484 {
 485     Document* document = m_page.mainFrame().documentAtPoint(dragData.clientPosition());
 486 
 487     bool pluginDocumentAcceptsDrags = false;
 488 
 489     if (is&lt;PluginDocument&gt;(document)) {
 490         const Widget* widget = downcast&lt;PluginDocument&gt;(*document).pluginWidget();
 491         const PluginViewBase* pluginView = is&lt;PluginViewBase&gt;(widget) ? downcast&lt;PluginViewBase&gt;(widget) : nullptr;
 492 
 493         if (pluginView)
 494             pluginDocumentAcceptsDrags = pluginView-&gt;shouldAllowNavigationFromDrags();
 495     }
 496 
 497     if (document &amp;&amp; (m_didInitiateDrag || (is&lt;PluginDocument&gt;(*document) &amp;&amp; !pluginDocumentAcceptsDrags) || document-&gt;hasEditableStyle()))
 498         return DragOperationNone;
 499     return dragOperation(dragData);
 500 }
 501 
 502 static bool setSelectionToDragCaret(Frame* frame, VisibleSelection&amp; dragCaret, RefPtr&lt;Range&gt;&amp; range, const IntPoint&amp; point)
 503 {
 504     Ref&lt;Frame&gt; protector(*frame);
 505     frame-&gt;selection().setSelection(dragCaret);
 506     if (frame-&gt;selection().selection().isNone()) {
 507         dragCaret = frame-&gt;visiblePositionForPoint(point);
 508         frame-&gt;selection().setSelection(dragCaret);
 509         range = dragCaret.toNormalizedRange();
 510     }
 511     return !frame-&gt;selection().isNone() &amp;&amp; frame-&gt;selection().selection().isContentEditable();
 512 }
 513 
 514 bool DragController::dispatchTextInputEventFor(Frame* innerFrame, const DragData&amp; dragData)
 515 {
 516     ASSERT(m_page.dragCaretController().hasCaret());
 517     String text = m_page.dragCaretController().isContentRichlyEditable() ? emptyString() : dragData.asPlainText();
 518     Element* target = innerFrame-&gt;editor().findEventTargetFrom(m_page.dragCaretController().caretPosition());
 519     // FIXME: What guarantees target is not null?
 520     auto event = TextEvent::createForDrop(&amp;innerFrame-&gt;windowProxy(), text);
 521     target-&gt;dispatchEvent(event);
 522     return !event-&gt;defaultPrevented();
 523 }
 524 
 525 bool DragController::concludeEditDrag(const DragData&amp; dragData)
 526 {
 527     RefPtr&lt;HTMLInputElement&gt; fileInput = m_fileInputElementUnderMouse;
 528     if (m_fileInputElementUnderMouse) {
 529         m_fileInputElementUnderMouse-&gt;setCanReceiveDroppedFiles(false);
 530         m_fileInputElementUnderMouse = nullptr;
 531     }
 532 
 533     if (!m_documentUnderMouse)
 534         return false;
 535 
 536     IntPoint point = m_documentUnderMouse-&gt;view()-&gt;windowToContents(dragData.clientPosition());
 537     Element* element = elementUnderMouse(m_documentUnderMouse.get(), point);
 538     if (!element)
 539         return false;
 540     RefPtr&lt;Frame&gt; innerFrame = element-&gt;document().frame();
 541     ASSERT(innerFrame);
 542 
 543     if (m_page.dragCaretController().hasCaret() &amp;&amp; !dispatchTextInputEventFor(innerFrame.get(), dragData))
 544         return true;
 545 
 546     if (dragData.containsColor()) {
 547         Color color = dragData.asColor();
 548         if (!color.isValid())
 549             return false;
 550 #if ENABLE(INPUT_TYPE_COLOR)
 551         if (isEnabledColorInput(*element)) {
 552             auto&amp; input = downcast&lt;HTMLInputElement&gt;(*element);
 553             input.setValue(color.serialized(), DispatchInputAndChangeEvent);
 554             return true;
 555         }
 556 #endif
 557         auto innerRange = innerFrame-&gt;selection().toNormalizedRange();
 558         if (!innerRange)
 559             return false;
 560         auto style = MutableStyleProperties::create();
 561         style-&gt;setProperty(CSSPropertyColor, color.serialized(), false);
 562         if (!innerFrame-&gt;editor().shouldApplyStyle(style.ptr(), innerRange.get()))
 563             return false;
 564         m_client.willPerformDragDestinationAction(DragDestinationActionEdit, dragData);
 565         innerFrame-&gt;editor().applyStyle(style.ptr(), EditAction::SetColor);
 566         return true;
 567     }
 568 
 569     if (dragData.containsFiles() &amp;&amp; fileInput) {
 570         // fileInput should be the element we hit tested for, unless it was made
 571         // display:none in a drop event handler.
 572         ASSERT(fileInput == element || !fileInput-&gt;renderer());
 573         if (fileInput-&gt;isDisabledFormControl())
 574             return false;
 575 
 576         return fileInput-&gt;receiveDroppedFiles(dragData);
 577     }
 578 
 579     if (!m_page.dragController().canProcessDrag(dragData))
 580         return false;
 581 
 582     VisibleSelection dragCaret = m_page.dragCaretController().caretPosition();
 583     RefPtr&lt;Range&gt; range = dragCaret.toNormalizedRange();
 584     RefPtr&lt;Element&gt; rootEditableElement = innerFrame-&gt;selection().selection().rootEditableElement();
 585 
 586     // For range to be null a WebKit client must have done something bad while
 587     // manually controlling drag behaviour
 588     if (!range)
 589         return false;
 590 
 591     ResourceCacheValidationSuppressor validationSuppressor(range-&gt;ownerDocument().cachedResourceLoader());
 592     auto&amp; editor = innerFrame-&gt;editor();
 593     bool isMove = dragIsMove(innerFrame-&gt;selection(), dragData);
 594     if (isMove || dragCaret.isContentRichlyEditable()) {
 595         bool chosePlainText = false;
 596         RefPtr&lt;DocumentFragment&gt; fragment = documentFragmentFromDragData(dragData, *innerFrame, *range, true, chosePlainText);
 597         if (!fragment || !editor.shouldInsertFragment(*fragment, range.get(), EditorInsertAction::Dropped))
 598             return false;
 599 
 600         m_client.willPerformDragDestinationAction(DragDestinationActionEdit, dragData);
 601 
 602         if (editor.client() &amp;&amp; editor.client()-&gt;performTwoStepDrop(*fragment, *range, isMove))
 603             return true;
 604 
 605         if (isMove) {
 606             // NSTextView behavior is to always smart delete on moving a selection,
 607             // but only to smart insert if the selection granularity is word granularity.
 608             bool smartDelete = editor.smartInsertDeleteEnabled();
 609             bool smartInsert = smartDelete &amp;&amp; innerFrame-&gt;selection().granularity() == WordGranularity &amp;&amp; dragData.canSmartReplace();
 610             MoveSelectionCommand::create(fragment.releaseNonNull(), dragCaret.base(), smartInsert, smartDelete)-&gt;apply();
 611         } else {
 612             if (setSelectionToDragCaret(innerFrame.get(), dragCaret, range, point)) {
 613                 OptionSet&lt;ReplaceSelectionCommand::CommandOption&gt; options { ReplaceSelectionCommand::SelectReplacement, ReplaceSelectionCommand::PreventNesting };
 614                 if (dragData.canSmartReplace())
 615                     options.add(ReplaceSelectionCommand::SmartReplace);
 616                 if (chosePlainText)
 617                     options.add(ReplaceSelectionCommand::MatchStyle);
 618                 ReplaceSelectionCommand::create(*m_documentUnderMouse, fragment.releaseNonNull(), options, EditAction::InsertFromDrop)-&gt;apply();
 619             }
 620         }
 621     } else {
 622         String text = dragData.asPlainText();
 623         if (text.isEmpty() || !editor.shouldInsertText(text, range.get(), EditorInsertAction::Dropped))
 624             return false;
 625 
 626         m_client.willPerformDragDestinationAction(DragDestinationActionEdit, dragData);
 627         RefPtr&lt;DocumentFragment&gt; fragment = createFragmentFromText(*range, text);
 628         if (!fragment)
 629             return false;
 630 
 631         if (editor.client() &amp;&amp; editor.client()-&gt;performTwoStepDrop(*fragment, *range, isMove))
 632             return true;
 633 
 634         if (setSelectionToDragCaret(innerFrame.get(), dragCaret, range, point))
 635             ReplaceSelectionCommand::create(*m_documentUnderMouse, fragment.get(), { ReplaceSelectionCommand::SelectReplacement, ReplaceSelectionCommand::MatchStyle, ReplaceSelectionCommand::PreventNesting }, EditAction::InsertFromDrop)-&gt;apply();
 636     }
 637 
 638     if (rootEditableElement) {
 639         if (Frame* frame = rootEditableElement-&gt;document().frame())
 640             frame-&gt;eventHandler().updateDragStateAfterEditDragIfNeeded(*rootEditableElement);
 641     }
 642 
 643     return true;
 644 }
 645 
 646 bool DragController::canProcessDrag(const DragData&amp; dragData)
 647 {
 648     IntPoint point = m_page.mainFrame().view()-&gt;windowToContents(dragData.clientPosition());
 649     HitTestResult result = HitTestResult(point);
 650     if (!m_page.mainFrame().contentRenderer())
 651         return false;
 652 
<a name="7" id="anc7"></a><span class="line-modified"> 653     result = m_page.mainFrame().eventHandler().hitTestResultAtPoint(point, HitTestRequest::ReadOnly | HitTestRequest::Active | HitTestRequest::AllowChildFrameContent);</span>
 654 
 655     auto* dragNode = result.innerNonSharedNode();
 656     if (!dragNode)
 657         return false;
 658 
 659     DragData::DraggingPurpose dragPurpose = DragData::DraggingPurpose::ForEditing;
 660     if (asFileInput(*dragNode))
 661         dragPurpose = DragData::DraggingPurpose::ForFileUpload;
 662 #if ENABLE(INPUT_TYPE_COLOR)
 663     else if (isEnabledColorInput(*dragNode) || isInShadowTreeOfEnabledColorInput(*dragNode))
 664         dragPurpose = DragData::DraggingPurpose::ForColorControl;
 665 #endif
 666 
 667     if (!dragData.containsCompatibleContent(dragPurpose))
 668         return false;
 669 
 670     if (dragPurpose == DragData::DraggingPurpose::ForFileUpload)
 671         return true;
 672 
 673 #if ENABLE(INPUT_TYPE_COLOR)
 674     if (dragPurpose == DragData::DraggingPurpose::ForColorControl)
 675         return true;
 676 #endif
 677 
 678     if (is&lt;HTMLPlugInElement&gt;(*dragNode)) {
 679         if (!downcast&lt;HTMLPlugInElement&gt;(*dragNode).canProcessDrag() &amp;&amp; !dragNode-&gt;hasEditableStyle())
 680             return false;
 681     } else if (!dragNode-&gt;hasEditableStyle())
 682         return false;
 683 
 684     if (m_didInitiateDrag &amp;&amp; m_documentUnderMouse == m_dragInitiator &amp;&amp; result.isSelected())
 685         return false;
 686 
 687     return true;
 688 }
 689 
 690 static DragOperation defaultOperationForDrag(DragOperation srcOpMask)
 691 {
 692     // This is designed to match IE&#39;s operation fallback for the case where
 693     // the page calls preventDefault() in a drag event but doesn&#39;t set dropEffect.
 694     if (srcOpMask == DragOperationEvery)
 695         return DragOperationCopy;
 696     if (srcOpMask == DragOperationNone)
 697         return DragOperationNone;
 698     if (srcOpMask &amp; DragOperationMove)
 699         return DragOperationMove;
 700     if (srcOpMask &amp; DragOperationGeneric)
 701         return DragController::platformGenericDragOperation();
 702     if (srcOpMask &amp; DragOperationCopy)
 703         return DragOperationCopy;
 704     if (srcOpMask &amp; DragOperationLink)
 705         return DragOperationLink;
 706 
 707     // FIXME: Does IE really return &quot;generic&quot; even if no operations were allowed by the source?
 708     return DragOperationGeneric;
 709 }
 710 
 711 bool DragController::tryDHTMLDrag(const DragData&amp; dragData, DragOperation&amp; operation)
 712 {
 713     ASSERT(m_documentUnderMouse);
 714     Ref&lt;Frame&gt; mainFrame(m_page.mainFrame());
 715     RefPtr&lt;FrameView&gt; viewProtector = mainFrame-&gt;view();
 716     if (!viewProtector)
 717         return false;
 718 
 719     DragOperation sourceOperation = dragData.draggingSourceOperationMask();
 720     auto targetResponse = mainFrame-&gt;eventHandler().updateDragAndDrop(createMouseEvent(dragData), [&amp;dragData]() { return Pasteboard::createForDragAndDrop(dragData); }, sourceOperation, dragData.containsFiles());
 721     if (!targetResponse.accept)
 722         return false;
 723 
 724     if (!targetResponse.operation)
 725         operation = defaultOperationForDrag(sourceOperation);
 726     else if (!(sourceOperation &amp; targetResponse.operation.value())) // The element picked an operation which is not supported by the source
 727         operation = DragOperationNone;
 728     else
 729         operation = targetResponse.operation.value();
 730 
 731     return true;
 732 }
 733 
 734 static bool imageElementIsDraggable(const HTMLImageElement&amp; image, const Frame&amp; sourceFrame)
 735 {
 736     if (sourceFrame.settings().loadsImagesAutomatically())
 737         return true;
 738 
 739     auto* renderer = image.renderer();
 740     if (!is&lt;RenderImage&gt;(renderer))
 741         return false;
 742 
 743     auto* cachedImage = downcast&lt;RenderImage&gt;(*renderer).cachedImage();
 744     return cachedImage &amp;&amp; !cachedImage-&gt;errorOccurred() &amp;&amp; cachedImage-&gt;imageForRenderer(renderer);
 745 }
 746 
 747 #if ENABLE(ATTACHMENT_ELEMENT)
 748 
 749 static RefPtr&lt;HTMLAttachmentElement&gt; enclosingAttachmentElement(Element&amp; element)
 750 {
 751     if (is&lt;HTMLAttachmentElement&gt;(element))
 752         return downcast&lt;HTMLAttachmentElement&gt;(&amp;element);
 753 
 754     if (is&lt;HTMLAttachmentElement&gt;(element.parentOrShadowHostElement()))
 755         return downcast&lt;HTMLAttachmentElement&gt;(element.parentOrShadowHostElement());
 756 
 757     return { };
 758 }
 759 
 760 #endif
 761 
 762 Element* DragController::draggableElement(const Frame* sourceFrame, Element* startElement, const IntPoint&amp; dragOrigin, DragState&amp; state) const
 763 {
 764     state.type = (sourceFrame-&gt;selection().contains(dragOrigin)) ? DragSourceActionSelection : DragSourceActionNone;
 765     if (!startElement)
 766         return nullptr;
 767 #if ENABLE(ATTACHMENT_ELEMENT)
 768     if (auto attachment = enclosingAttachmentElement(*startElement)) {
 769         auto selection = sourceFrame-&gt;selection().selection();
 770         bool isSingleAttachmentSelection = selection.start() == Position(attachment.get(), Position::PositionIsBeforeAnchor) &amp;&amp; selection.end() == Position(attachment.get(), Position::PositionIsAfterAnchor);
 771         bool isAttachmentElementInCurrentSelection = false;
 772         if (auto selectedRange = selection.toNormalizedRange()) {
 773             auto compareResult = selectedRange-&gt;compareNode(*attachment);
 774             isAttachmentElementInCurrentSelection = !compareResult.hasException() &amp;&amp; compareResult.releaseReturnValue() == Range::NODE_INSIDE;
 775         }
 776 
 777         if (!isAttachmentElementInCurrentSelection || isSingleAttachmentSelection) {
 778             state.type = DragSourceActionAttachment;
 779             return attachment.get();
 780         }
 781     }
 782 #endif
 783 
 784     for (auto* element = startElement; element; element = element-&gt;parentOrShadowHostElement()) {
 785         auto* renderer = element-&gt;renderer();
 786         if (!renderer)
 787             continue;
 788 
 789         UserDrag dragMode = renderer-&gt;style().userDrag();
 790         if ((m_dragSourceAction &amp; DragSourceActionDHTML) &amp;&amp; dragMode == UserDrag::Element) {
 791             state.type = static_cast&lt;DragSourceAction&gt;(state.type | DragSourceActionDHTML);
 792             return element;
 793         }
 794         if (dragMode == UserDrag::Auto) {
 795             if ((m_dragSourceAction &amp; DragSourceActionImage)
 796                 &amp;&amp; is&lt;HTMLImageElement&gt;(*element)
 797                 &amp;&amp; imageElementIsDraggable(downcast&lt;HTMLImageElement&gt;(*element), *sourceFrame)) {
 798                 state.type = static_cast&lt;DragSourceAction&gt;(state.type | DragSourceActionImage);
 799                 return element;
 800             }
 801             if ((m_dragSourceAction &amp; DragSourceActionLink) &amp;&amp; isDraggableLink(*element)) {
 802                 state.type = static_cast&lt;DragSourceAction&gt;(state.type | DragSourceActionLink);
 803                 return element;
 804             }
 805 #if ENABLE(ATTACHMENT_ELEMENT)
 806             if ((m_dragSourceAction &amp; DragSourceActionAttachment)
 807                 &amp;&amp; is&lt;HTMLAttachmentElement&gt;(*element)
 808                 &amp;&amp; downcast&lt;HTMLAttachmentElement&gt;(*element).file()) {
 809                 state.type = static_cast&lt;DragSourceAction&gt;(state.type | DragSourceActionAttachment);
 810                 return element;
 811             }
 812 #endif
 813 #if ENABLE(INPUT_TYPE_COLOR)
 814             if ((m_dragSourceAction &amp; DragSourceActionColor) &amp;&amp; isEnabledColorInput(*element)) {
 815                 state.type = static_cast&lt;DragSourceAction&gt;(state.type | DragSourceActionColor);
 816                 return element;
 817             }
 818 #endif
 819         }
 820     }
 821 
 822     // We either have nothing to drag or we have a selection and we&#39;re not over a draggable element.
<a name="8" id="anc8"></a><span class="line-modified"> 823     if (state.type &amp; DragSourceActionSelection &amp;&amp; m_dragSourceAction &amp; DragSourceActionSelection)</span>
<span class="line-added"> 824         return startElement;</span>
<span class="line-added"> 825 </span>
<span class="line-added"> 826     return nullptr;</span>
 827 }
 828 
 829 static CachedImage* getCachedImage(Element&amp; element)
 830 {
 831     RenderObject* renderer = element.renderer();
 832     if (!is&lt;RenderImage&gt;(renderer))
 833         return nullptr;
 834     auto&amp; image = downcast&lt;RenderImage&gt;(*renderer);
 835     return image.cachedImage();
 836 }
 837 
 838 static Image* getImage(Element&amp; element)
 839 {
 840     CachedImage* cachedImage = getCachedImage(element);
 841     // Don&#39;t use cachedImage-&gt;imageForRenderer() here as that may return BitmapImages for cached SVG Images.
 842     // Users of getImage() want access to the SVGImage, in order to figure out the filename extensions,
 843     // which would be empty when asking the cached BitmapImages.
 844     return (cachedImage &amp;&amp; !cachedImage-&gt;errorOccurred()) ?
 845         cachedImage-&gt;image() : nullptr;
 846 }
 847 
 848 static void selectElement(Element&amp; element)
 849 {
 850     RefPtr&lt;Range&gt; range = element.document().createRange();
 851     range-&gt;selectNode(element);
 852     element.document().frame()-&gt;selection().setSelection(VisibleSelection(*range, DOWNSTREAM));
 853 }
 854 
 855 static IntPoint dragLocForDHTMLDrag(const IntPoint&amp; mouseDraggedPoint, const IntPoint&amp; dragOrigin, const IntPoint&amp; dragImageOffset, bool isLinkImage)
 856 {
 857     // dragImageOffset is the cursor position relative to the lower-left corner of the image.
 858 #if PLATFORM(MAC)
 859     // We add in the Y dimension because we are a flipped view, so adding moves the image down.
 860     const int yOffset = dragImageOffset.y();
 861 #else
 862     const int yOffset = -dragImageOffset.y();
 863 #endif
 864 
 865     if (isLinkImage)
 866         return IntPoint(mouseDraggedPoint.x() - dragImageOffset.x(), mouseDraggedPoint.y() + yOffset);
 867 
 868     return IntPoint(dragOrigin.x() - dragImageOffset.x(), dragOrigin.y() + yOffset);
 869 }
 870 
 871 static FloatPoint dragImageAnchorPointForSelectionDrag(Frame&amp; frame, const IntPoint&amp; mouseDraggedPoint)
 872 {
 873     IntRect draggingRect = enclosingIntRect(frame.selection().selectionBounds());
 874 
 875     float x = (mouseDraggedPoint.x() - draggingRect.x()) / (float)draggingRect.width();
 876     float y = (mouseDraggedPoint.y() - draggingRect.y()) / (float)draggingRect.height();
 877 
 878     return FloatPoint { x, y };
 879 }
 880 
 881 static IntPoint dragLocForSelectionDrag(Frame&amp; src)
 882 {
 883     IntRect draggingRect = enclosingIntRect(src.selection().selectionBounds());
 884     int xpos = draggingRect.maxX();
 885     xpos = draggingRect.x() &lt; xpos ? draggingRect.x() : xpos;
 886     int ypos = draggingRect.maxY();
 887 #if PLATFORM(COCOA)
 888     // Deal with flipped coordinates on Mac
 889     ypos = draggingRect.y() &gt; ypos ? draggingRect.y() : ypos;
 890 #else
 891     ypos = draggingRect.y() &lt; ypos ? draggingRect.y() : ypos;
 892 #endif
 893     return IntPoint(xpos, ypos);
 894 }
 895 
 896 bool DragController::startDrag(Frame&amp; src, const DragState&amp; state, DragOperation srcOp, const PlatformMouseEvent&amp; dragEvent, const IntPoint&amp; dragOrigin, HasNonDefaultPasteboardData hasData)
 897 {
 898     if (!src.view() || !src.contentRenderer() || !state.source)
 899         return false;
 900 
 901     Ref&lt;Frame&gt; protector(src);
<a name="9" id="anc9"></a><span class="line-modified"> 902     HitTestResult hitTestResult = src.eventHandler().hitTestResultAtPoint(dragOrigin, HitTestRequest::ReadOnly | HitTestRequest::Active | HitTestRequest::AllowChildFrameContent);</span>
 903 
 904     bool sourceContainsHitNode = state.source-&gt;containsIncludingShadowDOM(hitTestResult.innerNode());
 905     if (!sourceContainsHitNode) {
 906         // The original node being dragged isn&#39;t under the drag origin anymore... maybe it was
 907         // hidden or moved out from under the cursor. Regardless, we don&#39;t want to start a drag on
 908         // something that&#39;s not actually under the drag origin.
 909         return false;
 910     }
 911 
 912     URL linkURL = hitTestResult.absoluteLinkURL();
 913     URL imageURL = hitTestResult.absoluteImageURL();
 914 
 915     IntPoint mouseDraggedPoint = src.view()-&gt;windowToContents(dragEvent.position());
 916 
 917     m_draggingImageURL = URL();
 918     m_sourceDragOperation = srcOp;
 919 
 920     DragImage dragImage;
 921     IntPoint dragLoc(0, 0);
 922     IntPoint dragImageOffset(0, 0);
 923 
 924     ASSERT(state.dataTransfer);
 925 
 926     DataTransfer&amp; dataTransfer = *state.dataTransfer;
 927     if (state.type == DragSourceActionDHTML) {
 928         dragImage = DragImage { dataTransfer.createDragImage(dragImageOffset) };
 929         // We allow DHTML/JS to set the drag image, even if its a link, image or text we&#39;re dragging.
 930         // This is in the spirit of the IE API, which allows overriding of pasteboard data and DragOp.
 931         if (dragImage) {
 932             dragLoc = dragLocForDHTMLDrag(mouseDraggedPoint, dragOrigin, dragImageOffset, !linkURL.isEmpty());
 933             m_dragOffset = dragImageOffset;
 934         }
 935     }
 936 
 937     if (state.type == DragSourceActionSelection || !imageURL.isEmpty() || !linkURL.isEmpty()) {
 938         // Selection, image, and link drags receive a default set of allowed drag operations that
 939         // follows from:
 940         // http://trac.webkit.org/browser/trunk/WebKit/mac/WebView/WebHTMLView.mm?rev=48526#L3430
 941         m_sourceDragOperation = static_cast&lt;DragOperation&gt;(m_sourceDragOperation | DragOperationGeneric | DragOperationCopy);
 942     }
 943 
 944     ASSERT(state.source);
 945     Element&amp; element = *state.source;
 946 
 947     bool mustUseLegacyDragClient = hasData == HasNonDefaultPasteboardData::Yes || m_client.useLegacyDragClient();
 948 
 949     IntRect dragImageBounds;
 950     Image* image = getImage(element);
 951     if (state.type == DragSourceActionSelection) {
 952         PasteboardWriterData pasteboardWriterData;
 953 
 954         if (hasData == HasNonDefaultPasteboardData::No) {
 955             if (src.selection().selection().isNone()) {
 956                 // The page may have cleared out the selection in the dragstart handler, in which case we should bail
 957                 // out of the drag, since there is no content to write to the pasteboard.
 958                 return false;
 959             }
 960 
 961             // FIXME: This entire block is almost identical to the code in Editor::copy, and the code should be shared.
 962             RefPtr&lt;Range&gt; selectionRange = src.selection().toNormalizedRange();
 963             ASSERT(selectionRange);
 964 
 965             src.editor().willWriteSelectionToPasteboard(selectionRange.get());
 966 
 967             if (enclosingTextFormControl(src.selection().selection().start())) {
 968                 if (mustUseLegacyDragClient)
 969                     dataTransfer.pasteboard().writePlainText(src.editor().selectedTextForDataTransfer(), Pasteboard::CannotSmartReplace);
 970                 else {
 971                     PasteboardWriterData::PlainText plainText;
 972                     plainText.canSmartCopyOrDelete = false;
 973                     plainText.text = src.editor().selectedTextForDataTransfer();
 974                     pasteboardWriterData.setPlainText(WTFMove(plainText));
 975                 }
 976             } else {
 977                 if (mustUseLegacyDragClient) {
 978 #if PLATFORM(COCOA) || PLATFORM(GTK)
 979                     src.editor().writeSelectionToPasteboard(dataTransfer.pasteboard());
 980 #else
 981                     // FIXME: Convert all other platforms to match Mac and delete this.
 982                     dataTransfer.pasteboard().writeSelection(*selectionRange, src.editor().canSmartCopyOrDelete(), src, IncludeImageAltTextForDataTransfer);
 983 #endif
 984                 } else {
 985 #if PLATFORM(COCOA)
 986                     src.editor().writeSelection(pasteboardWriterData);
 987 #endif
 988                 }
 989             }
 990 
 991             src.editor().didWriteSelectionToPasteboard();
 992         }
 993         m_client.willPerformDragSourceAction(DragSourceActionSelection, dragOrigin, dataTransfer);
 994         if (!dragImage) {
 995             TextIndicatorData textIndicator;
 996             dragImage = DragImage { dissolveDragImageToFraction(createDragImageForSelection(src, textIndicator), DragImageAlpha) };
 997             if (textIndicator.contentImage)
 998                 dragImage.setIndicatorData(textIndicator);
 999             dragLoc = dragLocForSelectionDrag(src);
1000             m_dragOffset = IntPoint(dragOrigin.x() - dragLoc.x(), dragOrigin.y() - dragLoc.y());
1001         }
1002 
1003         if (!dragImage)
1004             return false;
1005 
1006         if (mustUseLegacyDragClient) {
1007             doSystemDrag(WTFMove(dragImage), dragLoc, dragOrigin, src, state, { });
1008             return true;
1009         }
1010 
1011         DragItem dragItem;
1012         dragItem.imageAnchorPoint = dragImageAnchorPointForSelectionDrag(src, mouseDraggedPoint);
1013         dragItem.image = WTFMove(dragImage);
1014         dragItem.data = WTFMove(pasteboardWriterData);
1015 
1016         beginDrag(WTFMove(dragItem), src, dragOrigin, mouseDraggedPoint, dataTransfer, DragSourceActionSelection);
1017 
1018         return true;
1019     }
1020 
1021     if (!src.document()-&gt;securityOrigin().canDisplay(linkURL)) {
1022         src.document()-&gt;addConsoleMessage(MessageSource::Security, MessageLevel::Error, &quot;Not allowed to drag local resource: &quot; + linkURL.stringCenterEllipsizedToLength());
1023         return false;
1024     }
1025 
1026     if (!imageURL.isEmpty() &amp;&amp; image &amp;&amp; !image-&gt;isNull() &amp;&amp; (m_dragSourceAction &amp; DragSourceActionImage)) {
1027         // We shouldn&#39;t be starting a drag for an image that can&#39;t provide an extension.
1028         // This is an early detection for problems encountered later upon drop.
1029         ASSERT(!image-&gt;filenameExtension().isEmpty());
1030 
1031 #if ENABLE(ATTACHMENT_ELEMENT)
1032         auto attachmentInfo = promisedAttachmentInfo(src, element);
1033 #else
1034         PromisedAttachmentInfo attachmentInfo;
1035 #endif
1036 
1037         if (hasData == HasNonDefaultPasteboardData::No) {
1038             m_draggingImageURL = imageURL;
1039             if (element.isContentRichlyEditable())
1040                 selectElement(element);
1041             if (!attachmentInfo)
1042                 declareAndWriteDragImage(dataTransfer, element, !linkURL.isEmpty() ? linkURL : imageURL, hitTestResult.altDisplayString());
1043         }
1044 
1045         m_client.willPerformDragSourceAction(DragSourceActionImage, dragOrigin, dataTransfer);
1046 
1047         if (!dragImage)
1048             doImageDrag(element, dragOrigin, hitTestResult.imageRect(), src, m_dragOffset, state, WTFMove(attachmentInfo));
1049         else {
1050             // DHTML defined drag image
1051             doSystemDrag(WTFMove(dragImage), dragLoc, dragOrigin, src, state, WTFMove(attachmentInfo));
1052         }
1053 
1054         return true;
1055     }
1056 
1057     if (!linkURL.isEmpty() &amp;&amp; (m_dragSourceAction &amp; DragSourceActionLink)) {
1058         PasteboardWriterData pasteboardWriterData;
1059 
1060         String textContentWithSimplifiedWhiteSpace = hitTestResult.textContent().simplifyWhiteSpace();
1061 
1062         if (hasData == HasNonDefaultPasteboardData::No) {
1063             // Simplify whitespace so the title put on the dataTransfer resembles what the user sees
1064             // on the web page. This includes replacing newlines with spaces.
1065             if (mustUseLegacyDragClient)
1066                 src.editor().copyURL(linkURL, textContentWithSimplifiedWhiteSpace, dataTransfer.pasteboard());
1067             else
1068                 pasteboardWriterData.setURLData(src.editor().pasteboardWriterURL(linkURL, textContentWithSimplifiedWhiteSpace));
1069         } else {
1070             // Make sure the pasteboard also contains trustworthy link data
1071             // but don&#39;t overwrite more general pasteboard types.
1072             PasteboardURL pasteboardURL;
1073             pasteboardURL.url = linkURL;
1074             pasteboardURL.title = hitTestResult.textContent();
1075             dataTransfer.pasteboard().writeTrustworthyWebURLsPboardType(pasteboardURL);
1076         }
1077 
1078         const VisibleSelection&amp; sourceSelection = src.selection().selection();
1079         if (sourceSelection.isCaret() &amp;&amp; sourceSelection.isContentEditable()) {
1080             // a user can initiate a drag on a link without having any text
1081             // selected.  In this case, we should expand the selection to
1082             // the enclosing anchor element
1083             Position pos = sourceSelection.base();
1084             Node* node = enclosingAnchorElement(pos);
1085             if (node)
1086                 src.selection().setSelection(VisibleSelection::selectionFromContentsOfNode(node));
1087         }
1088 
1089         m_client.willPerformDragSourceAction(DragSourceActionLink, dragOrigin, dataTransfer);
1090         if (!dragImage) {
1091             TextIndicatorData textIndicator;
1092             dragImage = DragImage { createDragImageForLink(element, linkURL, textContentWithSimplifiedWhiteSpace, textIndicator, src.settings().fontRenderingMode(), m_page.deviceScaleFactor()) };
1093             if (dragImage) {
1094                 m_dragOffset = dragOffsetForLinkDragImage(dragImage.get());
1095                 dragLoc = IntPoint(dragOrigin.x() + m_dragOffset.x(), dragOrigin.y() + m_dragOffset.y());
1096                 dragImage = DragImage { platformAdjustDragImageForDeviceScaleFactor(dragImage.get(), m_page.deviceScaleFactor()) };
1097                 if (textIndicator.contentImage)
1098                     dragImage.setIndicatorData(textIndicator);
1099             }
1100         }
1101 
1102         if (mustUseLegacyDragClient) {
1103             doSystemDrag(WTFMove(dragImage), dragLoc, dragOrigin, src, state, { });
1104             return true;
1105         }
1106 
1107         DragItem dragItem;
1108         dragItem.imageAnchorPoint = dragImage ? anchorPointForLinkDragImage(dragImage.get()) : FloatPoint();
1109         dragItem.image = WTFMove(dragImage);
1110         dragItem.data = WTFMove(pasteboardWriterData);
1111 
1112         beginDrag(WTFMove(dragItem), src, dragOrigin, mouseDraggedPoint, dataTransfer, DragSourceActionSelection);
1113 
1114         return true;
1115     }
1116 
1117 #if ENABLE(ATTACHMENT_ELEMENT)
1118     if (is&lt;HTMLAttachmentElement&gt;(element) &amp;&amp; m_dragSourceAction &amp; DragSourceActionAttachment) {
1119         auto&amp; attachment = downcast&lt;HTMLAttachmentElement&gt;(element);
1120         auto* attachmentRenderer = attachment.renderer();
1121 
1122         src.editor().setIgnoreSelectionChanges(true);
1123         auto previousSelection = src.selection().selection();
1124         selectElement(element);
1125 
1126         PromisedAttachmentInfo promisedAttachment;
1127         if (hasData == HasNonDefaultPasteboardData::No) {
1128             promisedAttachment = promisedAttachmentInfo(src, attachment);
1129             auto&amp; editor = src.editor();
1130             if (!promisedAttachment &amp;&amp; editor.client()) {
1131 #if PLATFORM(COCOA)
1132                 // Otherwise, if no file URL is specified, call out to the injected bundle to populate the pasteboard with data.
1133                 editor.willWriteSelectionToPasteboard(src.selection().toNormalizedRange().get());
1134                 editor.writeSelectionToPasteboard(dataTransfer.pasteboard());
1135                 editor.didWriteSelectionToPasteboard();
1136 #endif
1137             }
1138         }
1139 
1140         m_client.willPerformDragSourceAction(DragSourceActionAttachment, dragOrigin, dataTransfer);
1141 
1142         if (!dragImage) {
1143             TextIndicatorData textIndicator;
1144             if (attachmentRenderer)
1145                 attachmentRenderer-&gt;setShouldDrawBorder(false);
1146             dragImage = DragImage { dissolveDragImageToFraction(createDragImageForSelection(src, textIndicator), DragImageAlpha) };
1147             if (attachmentRenderer)
1148                 attachmentRenderer-&gt;setShouldDrawBorder(true);
1149             if (textIndicator.contentImage)
1150                 dragImage.setIndicatorData(textIndicator);
1151             dragLoc = dragLocForSelectionDrag(src);
1152             m_dragOffset = IntPoint(dragOrigin.x() - dragLoc.x(), dragOrigin.y() - dragLoc.y());
1153         }
1154         doSystemDrag(WTFMove(dragImage), dragLoc, dragOrigin, src, state, WTFMove(promisedAttachment));
1155         if (!element.isContentRichlyEditable())
1156             src.selection().setSelection(previousSelection);
1157         src.editor().setIgnoreSelectionChanges(false);
1158         return true;
1159     }
1160 #endif
1161 
1162 #if ENABLE(INPUT_TYPE_COLOR)
1163     bool isColorControl = is&lt;HTMLInputElement&gt;(state.source) &amp;&amp; downcast&lt;HTMLInputElement&gt;(*state.source).isColorControl();
1164     if (isColorControl &amp;&amp; m_dragSourceAction &amp; DragSourceActionColor) {
1165         auto&amp; input = downcast&lt;HTMLInputElement&gt;(*state.source);
1166         auto color = input.valueAsColor();
1167 
1168         Path visiblePath;
1169         dragImage = DragImage { createDragImageForColor(color, input.boundsInRootViewSpace(), input.document().page()-&gt;pageScaleFactor(), visiblePath) };
1170         dragImage.setVisiblePath(visiblePath);
1171         dataTransfer.pasteboard().write(color);
1172         dragImageOffset = IntPoint { dragImageSize(dragImage.get()) };
1173         dragLoc = dragLocForDHTMLDrag(mouseDraggedPoint, dragOrigin, dragImageOffset, false);
1174 
1175         m_client.willPerformDragSourceAction(DragSourceActionColor, dragOrigin, dataTransfer);
1176         doSystemDrag(WTFMove(dragImage), dragLoc, dragOrigin, src, state, { });
1177         return true;
1178     }
1179 #endif
1180 
1181     if (state.type == DragSourceActionDHTML &amp;&amp; dragImage) {
1182         ASSERT(m_dragSourceAction &amp; DragSourceActionDHTML);
1183         m_client.willPerformDragSourceAction(DragSourceActionDHTML, dragOrigin, dataTransfer);
1184         doSystemDrag(WTFMove(dragImage), dragLoc, dragOrigin, src, state, { });
1185         return true;
1186     }
1187 
1188     return false;
1189 }
1190 
1191 void DragController::doImageDrag(Element&amp; element, const IntPoint&amp; dragOrigin, const IntRect&amp; layoutRect, Frame&amp; frame, IntPoint&amp; dragImageOffset, const DragState&amp; state, PromisedAttachmentInfo&amp;&amp; attachmentInfo)
1192 {
1193     IntPoint mouseDownPoint = dragOrigin;
1194     DragImage dragImage;
1195     IntPoint scaledOrigin;
1196 
1197     if (!element.renderer())
1198         return;
1199 
<a name="10" id="anc10"></a><span class="line-modified">1200     ImageOrientation orientation = element.renderer()-&gt;imageOrientation();</span>
1201 
1202     Image* image = getImage(element);
<a name="11" id="anc11"></a><span class="line-modified">1203     if (image &amp;&amp; !layoutRect.isEmpty() &amp;&amp; shouldUseCachedImageForDragImage(*image) &amp;&amp; (dragImage = DragImage { createDragImageFromImage(image, orientation) })) {</span>
1204         dragImage = DragImage { fitDragImageToMaxSize(dragImage.get(), layoutRect.size(), maxDragImageSize()) };
1205         IntSize fittedSize = dragImageSize(dragImage.get());
1206 
1207         dragImage = DragImage { platformAdjustDragImageForDeviceScaleFactor(dragImage.get(), m_page.deviceScaleFactor()) };
1208         dragImage = DragImage { dissolveDragImageToFraction(dragImage.get(), DragImageAlpha) };
1209 
1210         // Properly orient the drag image and orient it differently if it&#39;s smaller than the original.
1211         float scale = fittedSize.width() / (float)layoutRect.width();
1212         float dx = scale * (layoutRect.x() - mouseDownPoint.x());
1213         float originY = layoutRect.y();
1214 #if PLATFORM(COCOA)
1215         // Compensate for accursed flipped coordinates in Cocoa.
1216         originY += layoutRect.height();
1217 #endif
1218         float dy = scale * (originY - mouseDownPoint.y());
1219         scaledOrigin = IntPoint((int)(dx + 0.5), (int)(dy + 0.5));
1220     } else {
1221         if (CachedImage* cachedImage = getCachedImage(element)) {
1222             dragImage = DragImage { createDragImageIconForCachedImageFilename(cachedImage-&gt;response().suggestedFilename()) };
1223             if (dragImage) {
1224                 dragImage = DragImage { platformAdjustDragImageForDeviceScaleFactor(dragImage.get(), m_page.deviceScaleFactor()) };
1225                 scaledOrigin = IntPoint(DragIconRightInset - dragImageSize(dragImage.get()).width(), DragIconBottomInset);
1226             }
1227         }
1228     }
1229 
1230     if (!dragImage)
1231         return;
1232 
1233     dragImageOffset = mouseDownPoint + scaledOrigin;
1234     doSystemDrag(WTFMove(dragImage), dragImageOffset, dragOrigin, frame, state, WTFMove(attachmentInfo));
1235 }
1236 
1237 void DragController::beginDrag(DragItem dragItem, Frame&amp; frame, const IntPoint&amp; mouseDownPoint, const IntPoint&amp; mouseDraggedPoint, DataTransfer&amp; dataTransfer, DragSourceAction dragSourceAction)
1238 {
1239     ASSERT(!m_client.useLegacyDragClient());
1240 
1241     m_didInitiateDrag = true;
1242     m_dragInitiator = frame.document();
1243 
1244     // Protect this frame and view, as a load may occur mid drag and attempt to unload this frame
1245     Ref&lt;Frame&gt; mainFrameProtector(m_page.mainFrame());
1246     RefPtr&lt;FrameView&gt; viewProtector = mainFrameProtector-&gt;view();
1247 
1248     auto mouseDownPointInRootViewCoordinates = viewProtector-&gt;rootViewToContents(frame.view()-&gt;contentsToRootView(mouseDownPoint));
1249     auto mouseDraggedPointInRootViewCoordinates = viewProtector-&gt;rootViewToContents(frame.view()-&gt;contentsToRootView(mouseDraggedPoint));
1250 
1251     m_client.beginDrag(WTFMove(dragItem), frame, mouseDownPointInRootViewCoordinates, mouseDraggedPointInRootViewCoordinates, dataTransfer, dragSourceAction);
1252 }
1253 
1254 void DragController::doSystemDrag(DragImage image, const IntPoint&amp; dragLoc, const IntPoint&amp; eventPos, Frame&amp; frame, const DragState&amp; state, PromisedAttachmentInfo&amp;&amp; promisedAttachmentInfo)
1255 {
1256     m_didInitiateDrag = true;
1257     m_dragInitiator = frame.document();
1258     // Protect this frame and view, as a load may occur mid drag and attempt to unload this frame
1259     Ref&lt;Frame&gt; frameProtector(m_page.mainFrame());
1260     RefPtr&lt;FrameView&gt; viewProtector = frameProtector-&gt;view();
1261 
1262     DragItem item;
1263     item.image = WTFMove(image);
1264     item.sourceAction = state.type;
1265     item.promisedAttachmentInfo = WTFMove(promisedAttachmentInfo);
1266 
1267     auto eventPositionInRootViewCoordinates = frame.view()-&gt;contentsToRootView(eventPos);
1268     auto dragLocationInRootViewCoordinates = frame.view()-&gt;contentsToRootView(dragLoc);
1269     item.eventPositionInContentCoordinates = viewProtector-&gt;rootViewToContents(eventPositionInRootViewCoordinates);
1270     item.dragLocationInContentCoordinates = viewProtector-&gt;rootViewToContents(dragLocationInRootViewCoordinates);
1271     item.dragLocationInWindowCoordinates = viewProtector-&gt;contentsToWindow(item.dragLocationInContentCoordinates);
1272     if (auto element = state.source) {
1273         auto dataTransferImageElement = state.dataTransfer-&gt;dragImageElement();
1274         if (state.type == DragSourceActionDHTML) {
1275             // If the drag image has been customized, fall back to positioning the preview relative to the drag event location.
1276             IntSize dragPreviewSize;
1277             if (dataTransferImageElement)
1278                 dragPreviewSize = dataTransferImageElement-&gt;boundsInRootViewSpace().size();
1279             else {
1280                 dragPreviewSize = dragImageSize(item.image.get());
1281                 if (auto* page = frame.page())
1282                     dragPreviewSize.scale(1 / page-&gt;deviceScaleFactor());
1283             }
1284             item.dragPreviewFrameInRootViewCoordinates = { dragLocationInRootViewCoordinates, WTFMove(dragPreviewSize) };
1285         } else {
1286             // We can position the preview using the bounds of the drag source element.
1287             item.dragPreviewFrameInRootViewCoordinates = element-&gt;boundsInRootViewSpace();
1288         }
1289 
1290         RefPtr&lt;Element&gt; link;
1291         if (element-&gt;isLink())
1292             link = element;
1293         else {
1294             for (auto&amp; currentElement : elementLineage(element.get())) {
1295                 if (currentElement.isLink()) {
1296                     link = &amp;currentElement;
1297                     break;
1298                 }
1299             }
1300         }
1301         if (link) {
1302             auto titleAttribute = link-&gt;attributeWithoutSynchronization(HTMLNames::titleAttr);
1303             item.title = titleAttribute.isEmpty() ? link-&gt;innerText() : titleAttribute.string();
1304             item.url = frame.document()-&gt;completeURL(stripLeadingAndTrailingHTMLSpaces(link-&gt;getAttribute(HTMLNames::hrefAttr)));
1305         }
1306     }
1307     m_client.startDrag(WTFMove(item), *state.dataTransfer, frameProtector.get());
1308     // DragClient::startDrag can cause our Page to dispear, deallocating |this|.
1309     if (!frameProtector-&gt;page())
1310         return;
1311 
1312     cleanupAfterSystemDrag();
1313 }
1314 
1315 // Manual drag caret manipulation
1316 void DragController::placeDragCaret(const IntPoint&amp; windowPoint)
1317 {
1318     mouseMovedIntoDocument(m_page.mainFrame().documentAtPoint(windowPoint));
1319     if (!m_documentUnderMouse)
1320         return;
1321     Frame* frame = m_documentUnderMouse-&gt;frame();
1322     FrameView* frameView = frame-&gt;view();
1323     if (!frameView)
1324         return;
1325     IntPoint framePoint = frameView-&gt;windowToContents(windowPoint);
1326 
1327     m_page.dragCaretController().setCaretPosition(frame-&gt;visiblePositionForPoint(framePoint));
1328 }
1329 
1330 bool DragController::shouldUseCachedImageForDragImage(const Image&amp; image) const
1331 {
1332 #if ENABLE(DATA_INTERACTION)
1333     UNUSED_PARAM(image);
1334     return true;
1335 #else
1336     return image.size().height() * image.size().width() &lt;= MaxOriginalImageArea;
1337 #endif
1338 }
1339 
1340 #if !PLATFORM(COCOA)
1341 
1342 String DragController::platformContentTypeForBlobType(const String&amp; type) const
1343 {
1344     return type;
1345 }
1346 
1347 #endif
1348 
1349 #if ENABLE(ATTACHMENT_ELEMENT)
1350 
1351 PromisedAttachmentInfo DragController::promisedAttachmentInfo(Frame&amp; frame, Element&amp; element)
1352 {
1353     auto* client = frame.editor().client();
1354     if (!client || !client-&gt;supportsClientSideAttachmentData())
1355         return { };
1356 
1357     RefPtr&lt;HTMLAttachmentElement&gt; attachment;
1358     if (is&lt;HTMLAttachmentElement&gt;(element))
1359         attachment = &amp;downcast&lt;HTMLAttachmentElement&gt;(element);
1360     else if (is&lt;HTMLImageElement&gt;(element))
1361         attachment = downcast&lt;HTMLImageElement&gt;(element).attachmentElement();
1362 
1363     if (!attachment)
1364         return { };
1365 
1366     Vector&lt;String&gt; additionalTypes;
1367     Vector&lt;RefPtr&lt;SharedBuffer&gt;&gt; additionalData;
1368 #if PLATFORM(COCOA)
1369     frame.editor().getPasteboardTypesAndDataForAttachment(element, additionalTypes, additionalData);
1370 #endif
1371 
1372     if (auto* file = attachment-&gt;file())
1373         return { file-&gt;url(), platformContentTypeForBlobType(file-&gt;type()), file-&gt;name(), { }, WTFMove(additionalTypes), WTFMove(additionalData) };
1374 
1375     return { { }, { }, { }, attachment-&gt;uniqueIdentifier(), WTFMove(additionalTypes), WTFMove(additionalData) };
1376 }
1377 
1378 #endif // ENABLE(ATTACHMENT_ELEMENT)
1379 
1380 #endif // ENABLE(DRAG_SUPPORT)
1381 
1382 } // namespace WebCore
<a name="12" id="anc12"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="12" type="hidden" />
</body>
</html>