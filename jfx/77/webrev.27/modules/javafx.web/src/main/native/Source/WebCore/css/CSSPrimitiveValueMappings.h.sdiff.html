<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/css/CSSPrimitiveValueMappings.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CSSPrimitiveValue.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CSSProperties.json.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/css/CSSPrimitiveValueMappings.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1392     case DisplayType::Flex:
1393     case DisplayType::WebKitFlex:
1394         m_value.valueID = CSSValueFlex;
1395         break;
1396     case DisplayType::InlineFlex:
1397     case DisplayType::WebKitInlineFlex:
1398         m_value.valueID = CSSValueInlineFlex;
1399         break;
1400     case DisplayType::Grid:
1401         m_value.valueID = CSSValueGrid;
1402         break;
1403     case DisplayType::InlineGrid:
1404         m_value.valueID = CSSValueInlineGrid;
1405         break;
1406     case DisplayType::None:
1407         m_value.valueID = CSSValueNone;
1408         break;
1409     case DisplayType::Contents:
1410         m_value.valueID = CSSValueContents;
1411         break;



1412     }
1413 }
1414 
1415 template&lt;&gt; inline CSSPrimitiveValue::operator DisplayType() const
1416 {
1417     ASSERT(isValueID());
1418 
1419     if (m_value.valueID == CSSValueNone)
1420         return DisplayType::None;
1421 
1422     DisplayType display = static_cast&lt;DisplayType&gt;(m_value.valueID - CSSValueInline);
1423     ASSERT(display &gt;= DisplayType::Inline &amp;&amp; display &lt;= DisplayType::None);
1424     if (display == DisplayType::WebKitFlex)
1425         return DisplayType::Flex;
1426     if (display == DisplayType::WebKitInlineFlex)
1427         return DisplayType::InlineFlex;
1428     return display;
1429 }
1430 
1431 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(EmptyCell e)
</pre>
<hr />
<pre>
1627 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(LineBreak e)
1628     : CSSValue(PrimitiveClass)
1629 {
1630     m_primitiveUnitType = CSS_VALUE_ID;
1631     switch (e) {
1632     case LineBreak::Auto:
1633         m_value.valueID = CSSValueAuto;
1634         break;
1635     case LineBreak::Loose:
1636         m_value.valueID = CSSValueLoose;
1637         break;
1638     case LineBreak::Normal:
1639         m_value.valueID = CSSValueNormal;
1640         break;
1641     case LineBreak::Strict:
1642         m_value.valueID = CSSValueStrict;
1643         break;
1644     case LineBreak::AfterWhiteSpace:
1645         m_value.valueID = CSSValueAfterWhiteSpace;
1646         break;



1647     }
1648 }
1649 
1650 template&lt;&gt; inline CSSPrimitiveValue::operator OptionSet&lt;HangingPunctuation&gt;() const
1651 {
1652     ASSERT(isValueID());
1653 
1654     switch (m_value.valueID) {
1655     case CSSValueNone:
1656         return OptionSet&lt;HangingPunctuation&gt; { };
1657     case CSSValueFirst:
1658         return HangingPunctuation::First;
1659     case CSSValueLast:
1660         return HangingPunctuation::Last;
1661     case CSSValueAllowEnd:
1662         return HangingPunctuation::AllowEnd;
1663     case CSSValueForceEnd:
1664         return HangingPunctuation::ForceEnd;
1665     default:
1666         break;
</pre>
<hr />
<pre>
1668 
1669     ASSERT_NOT_REACHED();
1670     return OptionSet&lt;HangingPunctuation&gt; { };
1671 }
1672 
1673 template&lt;&gt; inline CSSPrimitiveValue::operator LineBreak() const
1674 {
1675     ASSERT(isValueID());
1676 
1677     switch (m_value.valueID) {
1678     case CSSValueAuto:
1679         return LineBreak::Auto;
1680     case CSSValueLoose:
1681         return LineBreak::Loose;
1682     case CSSValueNormal:
1683         return LineBreak::Normal;
1684     case CSSValueStrict:
1685         return LineBreak::Strict;
1686     case CSSValueAfterWhiteSpace:
1687         return LineBreak::AfterWhiteSpace;


1688     default:
1689         break;
1690     }
1691 
1692     ASSERT_NOT_REACHED();
1693     return LineBreak::Auto;
1694 }
1695 
1696 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(ListStylePosition e)
1697     : CSSValue(PrimitiveClass)
1698 {
1699     m_primitiveUnitType = CSS_VALUE_ID;
1700     switch (e) {
1701     case ListStylePosition::Outside:
1702         m_value.valueID = CSSValueOutside;
1703         break;
1704     case ListStylePosition::Inside:
1705         m_value.valueID = CSSValueInside;
1706         break;
1707     }
</pre>
<hr />
<pre>
2318 }
2319 
2320 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(PositionType e)
2321     : CSSValue(PrimitiveClass)
2322 {
2323     m_primitiveUnitType = CSS_VALUE_ID;
2324     switch (e) {
2325     case PositionType::Static:
2326         m_value.valueID = CSSValueStatic;
2327         break;
2328     case PositionType::Relative:
2329         m_value.valueID = CSSValueRelative;
2330         break;
2331     case PositionType::Absolute:
2332         m_value.valueID = CSSValueAbsolute;
2333         break;
2334     case PositionType::Fixed:
2335         m_value.valueID = CSSValueFixed;
2336         break;
2337     case PositionType::Sticky:
<span class="line-modified">2338         m_value.valueID = CSSValueWebkitSticky;</span>
2339         break;
2340     }
2341 }
2342 
2343 template&lt;&gt; inline CSSPrimitiveValue::operator PositionType() const
2344 {
2345     ASSERT(isValueID());
2346 
2347     switch (m_value.valueID) {
2348     case CSSValueStatic:
2349         return PositionType::Static;
2350     case CSSValueRelative:
2351         return PositionType::Relative;
2352     case CSSValueAbsolute:
2353         return PositionType::Absolute;
2354     case CSSValueFixed:
2355         return PositionType::Fixed;

2356     case CSSValueWebkitSticky:
2357         return PositionType::Sticky;
2358     default:
2359         break;
2360     }
2361 
2362     ASSERT_NOT_REACHED();
2363     return PositionType::Static;
2364 }
2365 
2366 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(Resize e)
2367     : CSSValue(PrimitiveClass)
2368 {
2369     m_primitiveUnitType = CSS_VALUE_ID;
2370     switch (e) {
2371     case Resize::Both:
2372         m_value.valueID = CSSValueBoth;
2373         break;
2374     case Resize::Horizontal:
2375         m_value.valueID = CSSValueHorizontal;
</pre>
<hr />
<pre>
3034     m_primitiveUnitType = CSS_VALUE_ID;
3035     switch (e) {
3036     case WhiteSpace::Normal:
3037         m_value.valueID = CSSValueNormal;
3038         break;
3039     case WhiteSpace::Pre:
3040         m_value.valueID = CSSValuePre;
3041         break;
3042     case WhiteSpace::PreWrap:
3043         m_value.valueID = CSSValuePreWrap;
3044         break;
3045     case WhiteSpace::PreLine:
3046         m_value.valueID = CSSValuePreLine;
3047         break;
3048     case WhiteSpace::NoWrap:
3049         m_value.valueID = CSSValueNowrap;
3050         break;
3051     case WhiteSpace::KHTMLNoWrap:
3052         m_value.valueID = CSSValueWebkitNowrap;
3053         break;



3054     }
3055 }
3056 
3057 template&lt;&gt; inline CSSPrimitiveValue::operator WhiteSpace() const
3058 {
3059     ASSERT(isValueID());
3060 
3061     switch (m_value.valueID) {
3062     case CSSValueWebkitNowrap:
3063         return WhiteSpace::KHTMLNoWrap;
3064     case CSSValueNowrap:
3065         return WhiteSpace::NoWrap;
3066     case CSSValuePre:
3067         return WhiteSpace::Pre;
3068     case CSSValuePreWrap:
3069         return WhiteSpace::PreWrap;
3070     case CSSValuePreLine:
3071         return WhiteSpace::PreLine;
3072     case CSSValueNormal:
3073         return WhiteSpace::Normal;


3074     default:
3075         break;
3076     }
3077 
3078     ASSERT_NOT_REACHED();
3079     return WhiteSpace::Normal;
3080 }
3081 
3082 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(WordBreak e)
3083     : CSSValue(PrimitiveClass)
3084 {
3085     m_primitiveUnitType = CSS_VALUE_ID;
3086     switch (e) {
3087     case WordBreak::Normal:
3088         m_value.valueID = CSSValueNormal;
3089         break;
3090     case WordBreak::BreakAll:
3091         m_value.valueID = CSSValueBreakAll;
3092         break;
3093     case WordBreak::KeepAll:
</pre>
<hr />
<pre>
4843 
4844 template&lt;&gt; inline CSSPrimitiveValue::operator MaskType() const
4845 {
4846     ASSERT(isValueID());
4847 
4848     switch (m_value.valueID) {
4849     case CSSValueLuminance:
4850         return MaskType::Luminance;
4851     case CSSValueAlpha:
4852         return MaskType::Alpha;
4853     default:
4854         break;
4855     }
4856 
4857     ASSERT_NOT_REACHED();
4858     return MaskType::Luminance;
4859 }
4860 
4861 #if ENABLE(CSS_IMAGE_ORIENTATION)
4862 
<span class="line-modified">4863 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(ImageOrientationEnum e)</span>
4864     : CSSValue(PrimitiveClass)
4865 {
4866     m_primitiveUnitType = CSS_DEG;
4867     switch (e) {
<span class="line-modified">4868     case OriginTopLeft:</span>
4869         m_value.num = 0;
4870         break;
<span class="line-modified">4871     case OriginRightTop:</span>
4872         m_value.num = 90;
4873         break;
<span class="line-modified">4874     case OriginBottomRight:</span>
4875         m_value.num = 180;
4876         break;
<span class="line-modified">4877     case OriginLeftBottom:</span>
4878         m_value.num = 270;
4879         break;
<span class="line-modified">4880     case OriginTopRight:</span>
<span class="line-modified">4881     case OriginLeftTop:</span>
<span class="line-modified">4882     case OriginBottomLeft:</span>
<span class="line-modified">4883     case OriginRightBottom:</span>

4884         ASSERT_NOT_REACHED();
4885     }
4886 }
4887 
<span class="line-modified">4888 template&lt;&gt; inline CSSPrimitiveValue::operator ImageOrientationEnum() const</span>
4889 {
4890     ASSERT(isAngle());
4891     double quarters = 4 * doubleValue(CSS_TURN);
4892     int orientation = 3 &amp; static_cast&lt;int&gt;(quarters &lt; 0 ? floor(quarters) : ceil(quarters));
4893     switch (orientation) {
4894     case 0:
<span class="line-modified">4895         return OriginTopLeft;</span>
4896     case 1:
<span class="line-modified">4897         return OriginRightTop;</span>
4898     case 2:
<span class="line-modified">4899         return OriginBottomRight;</span>
4900     case 3:
<span class="line-modified">4901         return OriginLeftBottom;</span>
4902     }
4903 
4904     ASSERT_NOT_REACHED();
<span class="line-modified">4905     return OriginTopLeft;</span>
4906 }
4907 
4908 #endif // ENABLE(CSS_IMAGE_ORIENTATION)
4909 
4910 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(CSSBoxType cssBox)
4911     : CSSValue(PrimitiveClass)
4912 {
4913     m_primitiveUnitType = CSS_VALUE_ID;
4914     switch (cssBox) {
4915     case CSSBoxType::MarginBox:
4916         m_value.valueID = CSSValueMarginBox;
4917         break;
4918     case CSSBoxType::BorderBox:
4919         m_value.valueID = CSSValueBorderBox;
4920         break;
4921     case CSSBoxType::PaddingBox:
4922         m_value.valueID = CSSValuePaddingBox;
4923         break;
4924     case CSSBoxType::ContentBox:
4925         m_value.valueID = CSSValueContentBox;
</pre>
</td>
<td>
<hr />
<pre>
1392     case DisplayType::Flex:
1393     case DisplayType::WebKitFlex:
1394         m_value.valueID = CSSValueFlex;
1395         break;
1396     case DisplayType::InlineFlex:
1397     case DisplayType::WebKitInlineFlex:
1398         m_value.valueID = CSSValueInlineFlex;
1399         break;
1400     case DisplayType::Grid:
1401         m_value.valueID = CSSValueGrid;
1402         break;
1403     case DisplayType::InlineGrid:
1404         m_value.valueID = CSSValueInlineGrid;
1405         break;
1406     case DisplayType::None:
1407         m_value.valueID = CSSValueNone;
1408         break;
1409     case DisplayType::Contents:
1410         m_value.valueID = CSSValueContents;
1411         break;
<span class="line-added">1412     case DisplayType::FlowRoot:</span>
<span class="line-added">1413         m_value.valueID = CSSValueFlowRoot;</span>
<span class="line-added">1414         break;</span>
1415     }
1416 }
1417 
1418 template&lt;&gt; inline CSSPrimitiveValue::operator DisplayType() const
1419 {
1420     ASSERT(isValueID());
1421 
1422     if (m_value.valueID == CSSValueNone)
1423         return DisplayType::None;
1424 
1425     DisplayType display = static_cast&lt;DisplayType&gt;(m_value.valueID - CSSValueInline);
1426     ASSERT(display &gt;= DisplayType::Inline &amp;&amp; display &lt;= DisplayType::None);
1427     if (display == DisplayType::WebKitFlex)
1428         return DisplayType::Flex;
1429     if (display == DisplayType::WebKitInlineFlex)
1430         return DisplayType::InlineFlex;
1431     return display;
1432 }
1433 
1434 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(EmptyCell e)
</pre>
<hr />
<pre>
1630 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(LineBreak e)
1631     : CSSValue(PrimitiveClass)
1632 {
1633     m_primitiveUnitType = CSS_VALUE_ID;
1634     switch (e) {
1635     case LineBreak::Auto:
1636         m_value.valueID = CSSValueAuto;
1637         break;
1638     case LineBreak::Loose:
1639         m_value.valueID = CSSValueLoose;
1640         break;
1641     case LineBreak::Normal:
1642         m_value.valueID = CSSValueNormal;
1643         break;
1644     case LineBreak::Strict:
1645         m_value.valueID = CSSValueStrict;
1646         break;
1647     case LineBreak::AfterWhiteSpace:
1648         m_value.valueID = CSSValueAfterWhiteSpace;
1649         break;
<span class="line-added">1650     case LineBreak::Anywhere:</span>
<span class="line-added">1651         m_value.valueID = CSSValueAnywhere;</span>
<span class="line-added">1652         break;</span>
1653     }
1654 }
1655 
1656 template&lt;&gt; inline CSSPrimitiveValue::operator OptionSet&lt;HangingPunctuation&gt;() const
1657 {
1658     ASSERT(isValueID());
1659 
1660     switch (m_value.valueID) {
1661     case CSSValueNone:
1662         return OptionSet&lt;HangingPunctuation&gt; { };
1663     case CSSValueFirst:
1664         return HangingPunctuation::First;
1665     case CSSValueLast:
1666         return HangingPunctuation::Last;
1667     case CSSValueAllowEnd:
1668         return HangingPunctuation::AllowEnd;
1669     case CSSValueForceEnd:
1670         return HangingPunctuation::ForceEnd;
1671     default:
1672         break;
</pre>
<hr />
<pre>
1674 
1675     ASSERT_NOT_REACHED();
1676     return OptionSet&lt;HangingPunctuation&gt; { };
1677 }
1678 
1679 template&lt;&gt; inline CSSPrimitiveValue::operator LineBreak() const
1680 {
1681     ASSERT(isValueID());
1682 
1683     switch (m_value.valueID) {
1684     case CSSValueAuto:
1685         return LineBreak::Auto;
1686     case CSSValueLoose:
1687         return LineBreak::Loose;
1688     case CSSValueNormal:
1689         return LineBreak::Normal;
1690     case CSSValueStrict:
1691         return LineBreak::Strict;
1692     case CSSValueAfterWhiteSpace:
1693         return LineBreak::AfterWhiteSpace;
<span class="line-added">1694     case CSSValueAnywhere:</span>
<span class="line-added">1695         return LineBreak::Anywhere;</span>
1696     default:
1697         break;
1698     }
1699 
1700     ASSERT_NOT_REACHED();
1701     return LineBreak::Auto;
1702 }
1703 
1704 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(ListStylePosition e)
1705     : CSSValue(PrimitiveClass)
1706 {
1707     m_primitiveUnitType = CSS_VALUE_ID;
1708     switch (e) {
1709     case ListStylePosition::Outside:
1710         m_value.valueID = CSSValueOutside;
1711         break;
1712     case ListStylePosition::Inside:
1713         m_value.valueID = CSSValueInside;
1714         break;
1715     }
</pre>
<hr />
<pre>
2326 }
2327 
2328 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(PositionType e)
2329     : CSSValue(PrimitiveClass)
2330 {
2331     m_primitiveUnitType = CSS_VALUE_ID;
2332     switch (e) {
2333     case PositionType::Static:
2334         m_value.valueID = CSSValueStatic;
2335         break;
2336     case PositionType::Relative:
2337         m_value.valueID = CSSValueRelative;
2338         break;
2339     case PositionType::Absolute:
2340         m_value.valueID = CSSValueAbsolute;
2341         break;
2342     case PositionType::Fixed:
2343         m_value.valueID = CSSValueFixed;
2344         break;
2345     case PositionType::Sticky:
<span class="line-modified">2346         m_value.valueID = CSSValueSticky;</span>
2347         break;
2348     }
2349 }
2350 
2351 template&lt;&gt; inline CSSPrimitiveValue::operator PositionType() const
2352 {
2353     ASSERT(isValueID());
2354 
2355     switch (m_value.valueID) {
2356     case CSSValueStatic:
2357         return PositionType::Static;
2358     case CSSValueRelative:
2359         return PositionType::Relative;
2360     case CSSValueAbsolute:
2361         return PositionType::Absolute;
2362     case CSSValueFixed:
2363         return PositionType::Fixed;
<span class="line-added">2364     case CSSValueSticky:</span>
2365     case CSSValueWebkitSticky:
2366         return PositionType::Sticky;
2367     default:
2368         break;
2369     }
2370 
2371     ASSERT_NOT_REACHED();
2372     return PositionType::Static;
2373 }
2374 
2375 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(Resize e)
2376     : CSSValue(PrimitiveClass)
2377 {
2378     m_primitiveUnitType = CSS_VALUE_ID;
2379     switch (e) {
2380     case Resize::Both:
2381         m_value.valueID = CSSValueBoth;
2382         break;
2383     case Resize::Horizontal:
2384         m_value.valueID = CSSValueHorizontal;
</pre>
<hr />
<pre>
3043     m_primitiveUnitType = CSS_VALUE_ID;
3044     switch (e) {
3045     case WhiteSpace::Normal:
3046         m_value.valueID = CSSValueNormal;
3047         break;
3048     case WhiteSpace::Pre:
3049         m_value.valueID = CSSValuePre;
3050         break;
3051     case WhiteSpace::PreWrap:
3052         m_value.valueID = CSSValuePreWrap;
3053         break;
3054     case WhiteSpace::PreLine:
3055         m_value.valueID = CSSValuePreLine;
3056         break;
3057     case WhiteSpace::NoWrap:
3058         m_value.valueID = CSSValueNowrap;
3059         break;
3060     case WhiteSpace::KHTMLNoWrap:
3061         m_value.valueID = CSSValueWebkitNowrap;
3062         break;
<span class="line-added">3063     case WhiteSpace::BreakSpaces:</span>
<span class="line-added">3064         m_value.valueID = CSSValueBreakSpaces;</span>
<span class="line-added">3065         break;</span>
3066     }
3067 }
3068 
3069 template&lt;&gt; inline CSSPrimitiveValue::operator WhiteSpace() const
3070 {
3071     ASSERT(isValueID());
3072 
3073     switch (m_value.valueID) {
3074     case CSSValueWebkitNowrap:
3075         return WhiteSpace::KHTMLNoWrap;
3076     case CSSValueNowrap:
3077         return WhiteSpace::NoWrap;
3078     case CSSValuePre:
3079         return WhiteSpace::Pre;
3080     case CSSValuePreWrap:
3081         return WhiteSpace::PreWrap;
3082     case CSSValuePreLine:
3083         return WhiteSpace::PreLine;
3084     case CSSValueNormal:
3085         return WhiteSpace::Normal;
<span class="line-added">3086     case CSSValueBreakSpaces:</span>
<span class="line-added">3087         return WhiteSpace::BreakSpaces;</span>
3088     default:
3089         break;
3090     }
3091 
3092     ASSERT_NOT_REACHED();
3093     return WhiteSpace::Normal;
3094 }
3095 
3096 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(WordBreak e)
3097     : CSSValue(PrimitiveClass)
3098 {
3099     m_primitiveUnitType = CSS_VALUE_ID;
3100     switch (e) {
3101     case WordBreak::Normal:
3102         m_value.valueID = CSSValueNormal;
3103         break;
3104     case WordBreak::BreakAll:
3105         m_value.valueID = CSSValueBreakAll;
3106         break;
3107     case WordBreak::KeepAll:
</pre>
<hr />
<pre>
4857 
4858 template&lt;&gt; inline CSSPrimitiveValue::operator MaskType() const
4859 {
4860     ASSERT(isValueID());
4861 
4862     switch (m_value.valueID) {
4863     case CSSValueLuminance:
4864         return MaskType::Luminance;
4865     case CSSValueAlpha:
4866         return MaskType::Alpha;
4867     default:
4868         break;
4869     }
4870 
4871     ASSERT_NOT_REACHED();
4872     return MaskType::Luminance;
4873 }
4874 
4875 #if ENABLE(CSS_IMAGE_ORIENTATION)
4876 
<span class="line-modified">4877 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(ImageOrientation e)</span>
4878     : CSSValue(PrimitiveClass)
4879 {
4880     m_primitiveUnitType = CSS_DEG;
4881     switch (e) {
<span class="line-modified">4882     case ImageOrientation::OriginTopLeft:</span>
4883         m_value.num = 0;
4884         break;
<span class="line-modified">4885     case ImageOrientation::OriginRightTop:</span>
4886         m_value.num = 90;
4887         break;
<span class="line-modified">4888     case ImageOrientation::OriginBottomRight:</span>
4889         m_value.num = 180;
4890         break;
<span class="line-modified">4891     case ImageOrientation::OriginLeftBottom:</span>
4892         m_value.num = 270;
4893         break;
<span class="line-modified">4894     case ImageOrientation::FromImage:</span>
<span class="line-modified">4895     case ImageOrientation::OriginTopRight:</span>
<span class="line-modified">4896     case ImageOrientation::OriginLeftTop:</span>
<span class="line-modified">4897     case ImageOrientation::OriginBottomLeft:</span>
<span class="line-added">4898     case ImageOrientation::OriginRightBottom:</span>
4899         ASSERT_NOT_REACHED();
4900     }
4901 }
4902 
<span class="line-modified">4903 template&lt;&gt; inline CSSPrimitiveValue::operator ImageOrientation() const</span>
4904 {
4905     ASSERT(isAngle());
4906     double quarters = 4 * doubleValue(CSS_TURN);
4907     int orientation = 3 &amp; static_cast&lt;int&gt;(quarters &lt; 0 ? floor(quarters) : ceil(quarters));
4908     switch (orientation) {
4909     case 0:
<span class="line-modified">4910         return ImageOrientation::OriginTopLeft;</span>
4911     case 1:
<span class="line-modified">4912         return ImageOrientation::OriginRightTop;</span>
4913     case 2:
<span class="line-modified">4914         return ImageOrientation::OriginBottomRight;</span>
4915     case 3:
<span class="line-modified">4916         return ImageOrientation::OriginLeftBottom;</span>
4917     }
4918 
4919     ASSERT_NOT_REACHED();
<span class="line-modified">4920     return ImageOrientation::None;</span>
4921 }
4922 
4923 #endif // ENABLE(CSS_IMAGE_ORIENTATION)
4924 
4925 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(CSSBoxType cssBox)
4926     : CSSValue(PrimitiveClass)
4927 {
4928     m_primitiveUnitType = CSS_VALUE_ID;
4929     switch (cssBox) {
4930     case CSSBoxType::MarginBox:
4931         m_value.valueID = CSSValueMarginBox;
4932         break;
4933     case CSSBoxType::BorderBox:
4934         m_value.valueID = CSSValueBorderBox;
4935         break;
4936     case CSSBoxType::PaddingBox:
4937         m_value.valueID = CSSValuePaddingBox;
4938         break;
4939     case CSSBoxType::ContentBox:
4940         m_value.valueID = CSSValueContentBox;
</pre>
</td>
</tr>
</table>
<center><a href="CSSPrimitiveValue.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CSSProperties.json.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>