<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WebCore/platform/mediastream/RealtimeMediaSource.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2012 Google Inc. All rights reserved.
   3  * Copyright (C) 2013-2018 Apple Inc. All rights reserved.
   4  * Copyright (C) 2013 Nokia Corporation and/or its subsidiary(-ies).
   5  * Copyright (C) 2015 Ericsson AB. All rights reserved.
   6  *
   7  * Redistribution and use in source and binary forms, with or without
   8  * modification, are permitted provided that the following conditions
   9  * are met:
  10  *
  11  * 1. Redistributions of source code must retain the above copyright
  12  *    notice, this list of conditions and the following disclaimer.
  13  * 2. Redistributions in binary form must reproduce the above copyright
  14  *    notice, this list of conditions and the following disclaimer
  15  *    in the documentation and/or other materials provided with the
  16  *    distribution.
  17  * 3. Neither the name of Google Inc. nor the names of its contributors
  18  *    may be used to endorse or promote products derived from this
  19  *    software without specific prior written permission.
  20  *
  21  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  22  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  23  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  24  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  25  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  26  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  27  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  28  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  29  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  30  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  31  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  32  */
  33 
  34 #include &quot;config.h&quot;
  35 
  36 #if ENABLE(MEDIA_STREAM)
  37 #include &quot;RealtimeMediaSource.h&quot;
  38 
  39 #include &quot;Logging.h&quot;
  40 #include &quot;MediaConstraints.h&quot;
  41 #include &quot;NotImplemented.h&quot;
  42 #include &quot;RealtimeMediaSourceCapabilities.h&quot;
  43 #include &quot;RealtimeMediaSourceCenter.h&quot;
  44 #include &lt;wtf/CompletionHandler.h&gt;
  45 #include &lt;wtf/MainThread.h&gt;
  46 #include &lt;wtf/UUID.h&gt;
  47 #include &lt;wtf/text/StringHash.h&gt;
  48 
  49 namespace WebCore {
  50 
  51 RealtimeMediaSource::RealtimeMediaSource(Type type, String&amp;&amp; name, String&amp;&amp; deviceID, String&amp;&amp; hashSalt)
  52     : m_idHashSalt(WTFMove(hashSalt))
  53     , m_persistentID(WTFMove(deviceID))
  54     , m_type(type)
  55     , m_name(WTFMove(name))
  56 {
  57     if (m_persistentID.isEmpty())
  58         m_persistentID = createCanonicalUUIDString();
  59     else
  60         m_hashedID = RealtimeMediaSourceCenter::singleton().hashStringWithSalt(m_persistentID, m_idHashSalt);
  61 }
  62 
  63 void RealtimeMediaSource::addObserver(RealtimeMediaSource::Observer&amp; observer)
  64 {
  65     auto locker = holdLock(m_observersLock);
  66     m_observers.add(&amp;observer);
  67 }
  68 
  69 void RealtimeMediaSource::removeObserver(RealtimeMediaSource::Observer&amp; observer)
  70 {
  71     auto locker = holdLock(m_observersLock);
  72 
  73     m_observers.remove(&amp;observer);
  74     if (m_observers.isEmpty())
  75         stop();
  76 }
  77 
  78 void RealtimeMediaSource::setInterrupted(bool interrupted, bool pageMuted)
  79 {
  80     if (interrupted == m_interrupted)
  81         return;
  82 
  83     m_interrupted = interrupted;
  84     if (!interrupted &amp;&amp; pageMuted)
  85         return;
  86 
  87     setMuted(interrupted);
  88 }
  89 
  90 void RealtimeMediaSource::setMuted(bool muted)
  91 {
  92     if (muted)
  93         stop();
  94     else {
  95         if (interrupted())
  96             return;
  97 
  98         start();
  99     }
 100 
 101     notifyMutedChange(muted);
 102 }
 103 
 104 void RealtimeMediaSource::notifyMutedChange(bool muted)
 105 {
 106     if (m_muted == muted)
 107         return;
 108 
 109     m_muted = muted;
 110 
 111     notifyMutedObservers();
 112 }
 113 
 114 void RealtimeMediaSource::setInterruptedForTesting(bool interrupted)
 115 {
 116     notifyMutedChange(interrupted);
 117 }
 118 
 119 void RealtimeMediaSource::forEachObserver(const WTF::Function&lt;void(Observer&amp;)&gt;&amp; apply) const
 120 {
 121     Vector&lt;Observer*&gt; observersCopy;
 122     {
 123         auto locker = holdLock(m_observersLock);
 124         observersCopy = copyToVector(m_observers);
 125     }
 126     for (auto* observer : observersCopy) {
 127         auto locker = holdLock(m_observersLock);
 128         // Make sure the observer has not been destroyed.
 129         if (!m_observers.contains(observer))
 130             continue;
 131         apply(*observer);
 132     }
 133 }
 134 
 135 void RealtimeMediaSource::notifyMutedObservers() const
 136 {
 137     forEachObserver([](auto&amp; observer) {
 138         observer.sourceMutedChanged();
 139     });
 140 }
 141 
 142 void RealtimeMediaSource::notifySettingsDidChangeObservers(OptionSet&lt;RealtimeMediaSourceSettings::Flag&gt; flags)
 143 {
 144     ASSERT(isMainThread());
 145 
 146     settingsDidChange(flags);
 147 
 148     if (m_pendingSettingsDidChangeNotification)
 149         return;
 150     m_pendingSettingsDidChangeNotification = true;
 151 
 152     scheduleDeferredTask([this] {
 153         m_pendingSettingsDidChangeNotification = false;
 154         forEachObserver([](auto&amp; observer) {
 155             observer.sourceSettingsChanged();
 156         });
 157     });
 158 }
 159 
 160 void RealtimeMediaSource::videoSampleAvailable(MediaSample&amp; mediaSample)
 161 {
 162     forEachObserver([&amp;](auto&amp; observer) {
 163         observer.videoSampleAvailable(mediaSample);
 164     });
 165 }
 166 
 167 void RealtimeMediaSource::audioSamplesAvailable(const MediaTime&amp; time, const PlatformAudioData&amp; audioData, const AudioStreamDescription&amp; description, size_t numberOfFrames)
 168 {
 169     forEachObserver([&amp;](auto&amp; observer) {
 170         observer.audioSamplesAvailable(time, audioData, description, numberOfFrames);
 171     });
 172 }
 173 
 174 void RealtimeMediaSource::start()
 175 {
 176     if (m_isProducingData || m_isEnded)
 177         return;
 178 
 179     m_isProducingData = true;
 180     startProducingData();
 181 
 182     if (!m_isProducingData)
 183         return;
 184 
 185     forEachObserver([](auto&amp; observer) {
 186         observer.sourceStarted();
 187     });
 188 }
 189 
 190 void RealtimeMediaSource::stop()
 191 {
 192     if (!m_isProducingData)
 193         return;
 194 
 195     m_isProducingData = false;
 196     stopProducingData();
 197 }
 198 
 199 void RealtimeMediaSource::requestToEnd(Observer&amp; callingObserver)
 200 {
 201     if (!m_isProducingData)
 202         return;
 203 
 204     bool hasObserverPreventingStopping = false;
 205     forEachObserver([&amp;](auto&amp; observer) {
 206         if (observer.preventSourceFromStopping())
 207             hasObserverPreventingStopping = true;
 208     });
 209     if (hasObserverPreventingStopping)
 210         return;
 211 
 212     auto protectedThis = makeRef(*this);
 213 
 214     stop();
 215     m_isEnded = true;
 216     hasEnded();
 217 
 218     forEachObserver([callingObserver](auto&amp; observer) {
 219         if (&amp;observer != &amp;callingObserver)
 220             observer.sourceStopped();
 221     });
 222 }
 223 
 224 void RealtimeMediaSource::captureFailed()
 225 {
 226     RELEASE_LOG_ERROR(MediaStream, &quot;RealtimeMediaSource::captureFailed&quot;);
 227 
 228     m_isProducingData = false;
 229     m_captureDidFailed = true;
 230 
 231     forEachObserver([](auto&amp; observer) {
 232         observer.sourceStopped();
 233     });
 234 }
 235 
 236 bool RealtimeMediaSource::supportsSizeAndFrameRate(Optional&lt;int&gt;, Optional&lt;int&gt;, Optional&lt;double&gt;)
 237 {
 238     // The size and frame rate are within the capability limits, so they are supported.
 239     return true;
 240 }
 241 
 242 bool RealtimeMediaSource::supportsSizeAndFrameRate(Optional&lt;IntConstraint&gt; widthConstraint, Optional&lt;IntConstraint&gt; heightConstraint, Optional&lt;DoubleConstraint&gt; frameRateConstraint, String&amp; badConstraint, double&amp; distance)
 243 {
 244     if (!widthConstraint &amp;&amp; !heightConstraint &amp;&amp; !frameRateConstraint)
 245         return true;
 246 
 247     auto&amp; capabilities = this-&gt;capabilities();
 248 
 249     distance = std::numeric_limits&lt;double&gt;::infinity();
 250 
 251     Optional&lt;int&gt; width;
 252     if (widthConstraint &amp;&amp; capabilities.supportsWidth()) {
 253         double constraintDistance = fitnessDistance(*widthConstraint);
 254         if (std::isinf(constraintDistance)) {
 255             badConstraint = widthConstraint-&gt;name();
 256             return false;
 257         }
 258 
 259         distance = std::min(distance, constraintDistance);
 260         if (widthConstraint-&gt;isMandatory()) {
 261             auto range = capabilities.width();
 262             width = widthConstraint-&gt;valueForCapabilityRange(size().width(), range.rangeMin().asInt, range.rangeMax().asInt);
 263         }
 264     }
 265 
 266     Optional&lt;int&gt; height;
 267     if (heightConstraint &amp;&amp; capabilities.supportsHeight()) {
 268         double constraintDistance = fitnessDistance(*heightConstraint);
 269         if (std::isinf(constraintDistance)) {
 270             badConstraint = heightConstraint-&gt;name();
 271             return false;
 272         }
 273 
 274         distance = std::min(distance, constraintDistance);
 275         if (heightConstraint-&gt;isMandatory()) {
 276             auto range = capabilities.height();
 277             height = heightConstraint-&gt;valueForCapabilityRange(size().height(), range.rangeMin().asInt, range.rangeMax().asInt);
 278         }
 279     }
 280 
 281     Optional&lt;double&gt; frameRate;
 282     if (frameRateConstraint &amp;&amp; capabilities.supportsFrameRate()) {
 283         double constraintDistance = fitnessDistance(*frameRateConstraint);
 284         if (std::isinf(constraintDistance)) {
 285             badConstraint = frameRateConstraint-&gt;name();
 286             return false;
 287         }
 288 
 289         distance = std::min(distance, constraintDistance);
 290         if (frameRateConstraint-&gt;isMandatory()) {
 291             auto range = capabilities.frameRate();
 292             frameRate = frameRateConstraint-&gt;valueForCapabilityRange(this-&gt;frameRate(), range.rangeMin().asDouble, range.rangeMax().asDouble);
 293         }
 294     }
 295 
 296     // Each of the non-null values is supported individually, see if they all can be applied at the same time.
 297     if (!supportsSizeAndFrameRate(WTFMove(width), WTFMove(height), WTFMove(frameRate))) {
 298         if (widthConstraint)
 299             badConstraint = widthConstraint-&gt;name();
 300         else if (heightConstraint)
 301             badConstraint = heightConstraint-&gt;name();
 302         else
 303             badConstraint = frameRateConstraint-&gt;name();
 304         return false;
 305     }
 306 
 307     return true;
 308 }
 309 
 310 double RealtimeMediaSource::fitnessDistance(const MediaConstraint&amp; constraint)
 311 {
 312     auto&amp; capabilities = this-&gt;capabilities();
 313 
 314     switch (constraint.constraintType()) {
 315     case MediaConstraintType::Width: {
 316         ASSERT(constraint.isInt());
 317         if (!capabilities.supportsWidth())
 318             return 0;
 319 
 320         auto range = capabilities.width();
 321         return downcast&lt;IntConstraint&gt;(constraint).fitnessDistance(range.rangeMin().asInt, range.rangeMax().asInt);
 322         break;
 323     }
 324 
 325     case MediaConstraintType::Height: {
 326         ASSERT(constraint.isInt());
 327         if (!capabilities.supportsHeight())
 328             return 0;
 329 
 330         auto range = capabilities.height();
 331         return downcast&lt;IntConstraint&gt;(constraint).fitnessDistance(range.rangeMin().asInt, range.rangeMax().asInt);
 332         break;
 333     }
 334 
 335     case MediaConstraintType::FrameRate: {
 336         ASSERT(constraint.isDouble());
 337         if (!capabilities.supportsFrameRate())
 338             return 0;
 339 
 340         auto range = capabilities.frameRate();
 341         return downcast&lt;DoubleConstraint&gt;(constraint).fitnessDistance(range.rangeMin().asDouble, range.rangeMax().asDouble);
 342         break;
 343     }
 344 
 345     case MediaConstraintType::AspectRatio: {
 346         ASSERT(constraint.isDouble());
 347         if (!capabilities.supportsAspectRatio())
 348             return 0;
 349 
 350         auto range = capabilities.aspectRatio();
 351         return downcast&lt;DoubleConstraint&gt;(constraint).fitnessDistance(range.rangeMin().asDouble, range.rangeMax().asDouble);
 352         break;
 353     }
 354 
 355     case MediaConstraintType::Volume: {
 356         ASSERT(constraint.isDouble());
 357         if (!capabilities.supportsVolume())
 358             return 0;
 359 
 360         auto range = capabilities.volume();
 361         return downcast&lt;DoubleConstraint&gt;(constraint).fitnessDistance(range.rangeMin().asDouble, range.rangeMax().asDouble);
 362         break;
 363     }
 364 
 365     case MediaConstraintType::SampleRate: {
 366         ASSERT(constraint.isInt());
 367         if (!capabilities.supportsSampleRate())
 368             return 0;
 369 
 370         if (auto discreteRates = discreteSampleRates())
 371             return downcast&lt;IntConstraint&gt;(constraint).fitnessDistance(*discreteRates);
 372 
 373         auto range = capabilities.sampleRate();
 374         return downcast&lt;IntConstraint&gt;(constraint).fitnessDistance(range.rangeMin().asInt, range.rangeMax().asInt);
 375         break;
 376     }
 377 
 378     case MediaConstraintType::SampleSize: {
 379         ASSERT(constraint.isInt());
 380         if (!capabilities.supportsSampleSize())
 381             return 0;
 382 
 383         if (auto discreteSizes = discreteSampleSizes())
 384             return downcast&lt;IntConstraint&gt;(constraint).fitnessDistance(*discreteSizes);
 385 
 386         auto range = capabilities.sampleSize();
 387         return downcast&lt;IntConstraint&gt;(constraint).fitnessDistance(range.rangeMin().asInt, range.rangeMax().asInt);
 388         break;
 389     }
 390 
 391     case MediaConstraintType::FacingMode: {
 392         ASSERT(constraint.isString());
 393         if (!capabilities.supportsFacingMode())
 394             return 0;
 395 
 396         auto&amp; modes = capabilities.facingMode();
 397         Vector&lt;String&gt; supportedModes;
 398         supportedModes.reserveInitialCapacity(modes.size());
 399         for (auto&amp; mode : modes)
 400             supportedModes.uncheckedAppend(RealtimeMediaSourceSettings::facingMode(mode));
 401         return downcast&lt;StringConstraint&gt;(constraint).fitnessDistance(supportedModes);
 402         break;
 403     }
 404 
 405     case MediaConstraintType::EchoCancellation: {
 406         ASSERT(constraint.isBoolean());
 407         if (!capabilities.supportsEchoCancellation())
 408             return 0;
 409 
 410         bool echoCancellationReadWrite = capabilities.echoCancellation() == RealtimeMediaSourceCapabilities::EchoCancellation::ReadWrite;
 411         return downcast&lt;BooleanConstraint&gt;(constraint).fitnessDistance(echoCancellationReadWrite);
 412         break;
 413     }
 414 
 415     case MediaConstraintType::DeviceId:
 416         ASSERT_NOT_REACHED();
 417         break;
 418 
 419     case MediaConstraintType::GroupId: {
 420         ASSERT(constraint.isString());
 421         if (!capabilities.supportsDeviceId())
 422             return 0;
 423 
 424         return downcast&lt;StringConstraint&gt;(constraint).fitnessDistance(settings().groupId());
 425         break;
 426     }
 427 
 428     case MediaConstraintType::DisplaySurface:
 429     case MediaConstraintType::LogicalSurface:
 430         break;
 431 
 432     case MediaConstraintType::Unknown:
 433         // Unknown (or unsupported) constraints should be ignored.
 434         break;
 435     }
 436 
 437     return 0;
 438 }
 439 
 440 template &lt;typename ValueType&gt;
 441 static void applyNumericConstraint(const NumericConstraint&lt;ValueType&gt;&amp; constraint, ValueType current, Optional&lt;Vector&lt;ValueType&gt;&gt; discreteCapabilityValues, ValueType capabilityMin, ValueType capabilityMax, RealtimeMediaSource&amp; source, void (RealtimeMediaSource::*applier)(ValueType))
 442 {
 443     if (discreteCapabilityValues) {
 444         int value = constraint.valueForDiscreteCapabilityValues(current, *discreteCapabilityValues);
 445         if (value != current)
 446             (source.*applier)(value);
 447         return;
 448     }
 449 
 450     ValueType value = constraint.valueForCapabilityRange(current, capabilityMin, capabilityMax);
 451     if (value != current)
 452         (source.*applier)(value);
 453 }
 454 
 455 void RealtimeMediaSource::setSizeAndFrameRate(Optional&lt;int&gt; width, Optional&lt;int&gt; height, Optional&lt;double&gt; frameRate)
 456 {
 457     IntSize size;
 458     if (width)
 459         size.setWidth(width.value());
 460     if (height)
 461         size.setHeight(height.value());
 462     setSize(size);
 463     if (frameRate)
 464         setFrameRate(frameRate.value());
 465 }
 466 
 467 void RealtimeMediaSource::applyConstraint(const MediaConstraint&amp; constraint)
 468 {
 469     auto&amp; capabilities = this-&gt;capabilities();
 470     switch (constraint.constraintType()) {
 471     case MediaConstraintType::Width:
 472         ASSERT_NOT_REACHED();
 473         break;
 474 
 475     case MediaConstraintType::Height:
 476         ASSERT_NOT_REACHED();
 477         break;
 478 
 479     case MediaConstraintType::FrameRate:
 480         ASSERT_NOT_REACHED();
 481         break;
 482 
 483     case MediaConstraintType::AspectRatio: {
 484         ASSERT(constraint.isDouble());
 485         if (!capabilities.supportsAspectRatio())
 486             return;
 487 
 488         auto range = capabilities.aspectRatio();
 489         applyNumericConstraint(downcast&lt;DoubleConstraint&gt;(constraint), aspectRatio(), { }, range.rangeMin().asDouble, range.rangeMax().asDouble, *this, &amp;RealtimeMediaSource::setAspectRatio);
 490         break;
 491     }
 492 
 493     case MediaConstraintType::Volume: {
 494         ASSERT(constraint.isDouble());
 495         if (!capabilities.supportsVolume())
 496             return;
 497 
 498         auto range = capabilities.volume();
 499         applyNumericConstraint(downcast&lt;DoubleConstraint&gt;(constraint), volume(), { }, range.rangeMin().asDouble, range.rangeMax().asDouble, *this, &amp;RealtimeMediaSource::setVolume);
 500         break;
 501     }
 502 
 503     case MediaConstraintType::SampleRate: {
 504         ASSERT(constraint.isInt());
 505         if (!capabilities.supportsSampleRate())
 506             return;
 507 
 508         auto range = capabilities.sampleRate();
 509         applyNumericConstraint(downcast&lt;IntConstraint&gt;(constraint), sampleRate(), discreteSampleRates(), range.rangeMin().asInt, range.rangeMax().asInt, *this, &amp;RealtimeMediaSource::setSampleRate);
 510         break;
 511     }
 512 
 513     case MediaConstraintType::SampleSize: {
 514         ASSERT(constraint.isInt());
 515         if (!capabilities.supportsSampleSize())
 516             return;
 517 
 518         auto range = capabilities.sampleSize();
 519         applyNumericConstraint(downcast&lt;IntConstraint&gt;(constraint), sampleSize(), { }, range.rangeMin().asInt, range.rangeMax().asInt, *this, &amp;RealtimeMediaSource::setSampleSize);
 520         break;
 521     }
 522 
 523     case MediaConstraintType::EchoCancellation: {
 524         ASSERT(constraint.isBoolean());
 525         if (!capabilities.supportsEchoCancellation())
 526             return;
 527 
 528         bool setting;
 529         const BooleanConstraint&amp; boolConstraint = downcast&lt;BooleanConstraint&gt;(constraint);
 530         if (boolConstraint.getExact(setting) || boolConstraint.getIdeal(setting))
 531             setEchoCancellation(setting);
 532         break;
 533     }
 534 
 535     case MediaConstraintType::FacingMode: {
 536         ASSERT(constraint.isString());
 537         if (!capabilities.supportsFacingMode())
 538             return;
 539 
 540         auto&amp; supportedModes = capabilities.facingMode();
 541         auto filter = [supportedModes](const String&amp; modeString) {
 542             auto mode = RealtimeMediaSourceSettings::videoFacingModeEnum(modeString);
 543             for (auto&amp; supportedMode : supportedModes) {
 544                 if (mode == supportedMode)
 545                     return true;
 546             }
 547             return false;
 548         };
 549 
 550         auto modeString = downcast&lt;StringConstraint&gt;(constraint).find(WTFMove(filter));
 551         if (!modeString.isEmpty())
 552             setFacingMode(RealtimeMediaSourceSettings::videoFacingModeEnum(modeString));
 553         break;
 554     }
 555 
 556     case MediaConstraintType::DeviceId:
 557     case MediaConstraintType::GroupId:
 558         ASSERT(constraint.isString());
 559         // There is nothing to do here, neither can be changed.
 560         break;
 561 
 562     case MediaConstraintType::DisplaySurface:
 563     case MediaConstraintType::LogicalSurface:
 564         ASSERT(constraint.isBoolean());
 565         break;
 566 
 567     case MediaConstraintType::Unknown:
 568         break;
 569     }
 570 }
 571 
 572 bool RealtimeMediaSource::selectSettings(const MediaConstraints&amp; constraints, FlattenedConstraint&amp; candidates, String&amp; failedConstraint, SelectType type)
 573 {
 574     m_fitnessScore = std::numeric_limits&lt;double&gt;::infinity();
 575 
 576     // https://w3c.github.io/mediacapture-main/#dfn-selectsettings
 577     //
 578     // 1. Each constraint specifies one or more values (or a range of values) for its property.
 579     //    A property may appear more than once in the list of &#39;advanced&#39; ConstraintSets. If an
 580     //    empty object or list has been given as the value for a constraint, it must be interpreted
 581     //    as if the constraint were not specified (in other words, an empty constraint == no constraint).
 582     //
 583     //    Note that unknown properties are discarded by WebIDL, which means that unknown/unsupported required
 584     //    constraints will silently disappear. To avoid this being a surprise, application authors are
 585     //    expected to first use the getSupportedConstraints() method as shown in the Examples below.
 586 
 587     // 2. Let object be the ConstrainablePattern object on which this algorithm is applied. Let copy be an
 588     //    unconstrained copy of object (i.e., copy should behave as if it were object with all ConstraintSets
 589     //    removed.)
 590 
 591     // 3. For every possible settings dictionary of copy compute its fitness distance, treating bare values of
 592     //    properties as ideal values. Let candidates be the set of settings dictionaries for which the fitness
 593     //    distance is finite.
 594 
 595     failedConstraint = emptyString();
 596 
 597     // Check width, height and frame rate jointly, because while they may be supported individually the combination may not be supported.
 598     double distance = std::numeric_limits&lt;double&gt;::infinity();
 599     if (!supportsSizeAndFrameRate(constraints.mandatoryConstraints.width(), constraints.mandatoryConstraints.height(), constraints.mandatoryConstraints.frameRate(), failedConstraint, m_fitnessScore))
 600         return false;
 601 
 602     constraints.mandatoryConstraints.filter([&amp;](const MediaConstraint&amp; constraint) {
 603         if (!supportsConstraint(constraint))
 604             return false;
 605 
 606         if (constraint.constraintType() == MediaConstraintType::Width || constraint.constraintType() == MediaConstraintType::Height || constraint.constraintType() == MediaConstraintType::FrameRate) {
 607             candidates.set(constraint);
 608             return false;
 609         }
 610 
 611         // The deviceId can&#39;t be changed, and the constraint value is the hashed device ID, so verify that the
 612         // device&#39;s unique ID hashes to the constraint value but don&#39;t include the constraint in the flattened
 613         // constraint set.
 614         if (constraint.constraintType() == MediaConstraintType::DeviceId) {
 615             if (type == SelectType::ForApplyConstraints)
 616                 return false;
 617 
 618             ASSERT(constraint.isString());
 619             ASSERT(!m_hashedID.isEmpty());
 620 
 621             double constraintDistance = downcast&lt;StringConstraint&gt;(constraint).fitnessDistance(m_hashedID);
 622             if (std::isinf(constraintDistance)) {
 623                 failedConstraint = constraint.name();
 624                 return true;
 625             }
 626 
 627             return false;
 628         }
 629 
 630         double constraintDistance = fitnessDistance(constraint);
 631         if (std::isinf(constraintDistance)) {
 632             failedConstraint = constraint.name();
 633             return true;
 634         }
 635 
 636         distance = std::min(distance, constraintDistance);
 637         candidates.set(constraint);
 638         return false;
 639     });
 640 
 641     if (!failedConstraint.isEmpty())
 642         return false;
 643 
 644     m_fitnessScore = distance;
 645 
 646     // 4. If candidates is empty, return undefined as the result of the SelectSettings() algorithm.
 647     if (candidates.isEmpty())
 648         return true;
 649 
 650     // 5. Iterate over the &#39;advanced&#39; ConstraintSets in newConstraints in the order in which they were specified.
 651     //    For each ConstraintSet:
 652 
 653     // 5.1 compute the fitness distance between it and each settings dictionary in candidates, treating bare
 654     //     values of properties as exact.
 655     Vector&lt;std::pair&lt;double, MediaTrackConstraintSetMap&gt;&gt; supportedConstraints;
 656 
 657     for (const auto&amp; advancedConstraint : constraints.advancedConstraints) {
 658         double constraintDistance = 0;
 659         bool supported = false;
 660 
 661         if (advancedConstraint.width() || advancedConstraint.height() || advancedConstraint.frameRate()) {
 662             String dummy;
 663             if (!supportsSizeAndFrameRate(advancedConstraint.width(), advancedConstraint.height(), advancedConstraint.frameRate(), dummy, constraintDistance))
 664                 continue;
 665 
 666             supported = true;
 667         }
 668 
 669         advancedConstraint.forEach([&amp;](const MediaConstraint&amp; constraint) {
 670 
 671             if (constraint.constraintType() == MediaConstraintType::Width || constraint.constraintType() == MediaConstraintType::Height || constraint.constraintType() == MediaConstraintType::FrameRate)
 672                 return;
 673 
 674             distance = fitnessDistance(constraint);
 675             constraintDistance += distance;
 676             if (!std::isinf(distance))
 677                 supported = true;
 678         });
 679 
 680         m_fitnessScore = std::min(m_fitnessScore, constraintDistance);
 681 
 682         // 5.2 If the fitness distance is finite for one or more settings dictionaries in candidates, keep those
 683         //     settings dictionaries in candidates, discarding others.
 684         //     If the fitness distance is infinite for all settings dictionaries in candidates, ignore this ConstraintSet.
 685         if (supported)
 686             supportedConstraints.append({constraintDistance, advancedConstraint});
 687     }
 688 
 689     // 6. Select one settings dictionary from candidates, and return it as the result of the SelectSettings() algorithm.
 690     //    The UA should use the one with the smallest fitness distance, as calculated in step 3.
 691     if (!supportedConstraints.isEmpty()) {
 692         supportedConstraints.removeAllMatching([&amp;](const std::pair&lt;double, MediaTrackConstraintSetMap&gt;&amp; pair) -&gt; bool {
 693             return std::isinf(pair.first) || pair.first &gt; m_fitnessScore;
 694         });
 695 
 696         if (!supportedConstraints.isEmpty()) {
 697             auto&amp; advancedConstraint = supportedConstraints[0].second;
 698             advancedConstraint.forEach([&amp;](const MediaConstraint&amp; constraint) {
 699                 candidates.merge(constraint);
 700             });
 701 
 702             m_fitnessScore = std::min(m_fitnessScore, supportedConstraints[0].first);
 703         }
 704     }
 705 
 706     return true;
 707 }
 708 
 709 bool RealtimeMediaSource::supportsConstraint(const MediaConstraint&amp; constraint)
 710 {
 711     auto&amp; capabilities = this-&gt;capabilities();
 712 
 713     switch (constraint.constraintType()) {
 714     case MediaConstraintType::Width:
 715         ASSERT(constraint.isInt());
 716         return capabilities.supportsWidth();
 717         break;
 718 
 719     case MediaConstraintType::Height:
 720         ASSERT(constraint.isInt());
 721         return capabilities.supportsHeight();
 722         break;
 723 
 724     case MediaConstraintType::FrameRate:
 725         ASSERT(constraint.isDouble());
 726         return capabilities.supportsFrameRate();
 727         break;
 728 
 729     case MediaConstraintType::AspectRatio:
 730         ASSERT(constraint.isDouble());
 731         return capabilities.supportsAspectRatio();
 732         break;
 733 
 734     case MediaConstraintType::Volume:
 735         ASSERT(constraint.isDouble());
 736         return capabilities.supportsVolume();
 737         break;
 738 
 739     case MediaConstraintType::SampleRate:
 740         ASSERT(constraint.isInt());
 741         return capabilities.supportsSampleRate();
 742         break;
 743 
 744     case MediaConstraintType::SampleSize:
 745         ASSERT(constraint.isInt());
 746         return capabilities.supportsSampleSize();
 747         break;
 748 
 749     case MediaConstraintType::FacingMode:
 750         ASSERT(constraint.isString());
 751         return capabilities.supportsFacingMode();
 752         break;
 753 
 754     case MediaConstraintType::EchoCancellation:
 755         ASSERT(constraint.isBoolean());
 756         return capabilities.supportsEchoCancellation();
 757         break;
 758 
 759     case MediaConstraintType::DeviceId:
 760         ASSERT(constraint.isString());
 761         return capabilities.supportsDeviceId();
 762         break;
 763 
 764     case MediaConstraintType::GroupId:
 765         ASSERT(constraint.isString());
 766         return capabilities.supportsDeviceId();
 767         break;
 768 
 769     case MediaConstraintType::DisplaySurface:
 770     case MediaConstraintType::LogicalSurface:
 771         // https://www.w3.org/TR/screen-capture/#new-constraints-for-captured-display-surfaces
 772         // 5.2.1 New Constraints for Captured Display Surfaces
 773         // Since the source of media cannot be changed after a MediaStreamTrack has been returned,
 774         // these constraints cannot be changed by an application.
 775         return false;
 776         break;
 777 
 778     case MediaConstraintType::Unknown:
 779         // Unknown (or unsupported) constraints should be ignored.
 780         break;
 781     }
 782 
 783     return false;
 784 }
 785 
 786 bool RealtimeMediaSource::supportsConstraints(const MediaConstraints&amp; constraints, String&amp; invalidConstraint)
 787 {
 788     ASSERT(constraints.isValid);
 789 
 790     FlattenedConstraint candidates;
 791     if (!selectSettings(constraints, candidates, invalidConstraint, SelectType::ForSupportsConstraints))
 792         return false;
 793 
 794     return true;
 795 }
 796 
 797 void RealtimeMediaSource::applyConstraints(const FlattenedConstraint&amp; constraints)
 798 {
 799     if (constraints.isEmpty())
 800         return;
 801 
 802     beginConfiguration();
 803 
 804     auto&amp; capabilities = this-&gt;capabilities();
 805 
 806     Optional&lt;int&gt; width;
 807     if (const MediaConstraint* constraint = constraints.find(MediaConstraintType::Width)) {
 808         ASSERT(constraint-&gt;isInt());
 809         if (capabilities.supportsWidth()) {
 810             auto range = capabilities.width();
 811             width = downcast&lt;IntConstraint&gt;(*constraint).valueForCapabilityRange(size().width(), range.rangeMin().asInt, range.rangeMax().asInt);
 812         }
 813     }
 814 
 815     Optional&lt;int&gt; height;
 816     if (const MediaConstraint* constraint = constraints.find(MediaConstraintType::Height)) {
 817         ASSERT(constraint-&gt;isInt());
 818         if (capabilities.supportsHeight()) {
 819             auto range = capabilities.height();
 820             height = downcast&lt;IntConstraint&gt;(*constraint).valueForCapabilityRange(size().height(), range.rangeMin().asInt, range.rangeMax().asInt);
 821         }
 822     }
 823 
 824     Optional&lt;double&gt; frameRate;
 825     if (const MediaConstraint* constraint = constraints.find(MediaConstraintType::FrameRate)) {
 826         ASSERT(constraint-&gt;isDouble());
 827         if (capabilities.supportsFrameRate()) {
 828             auto range = capabilities.frameRate();
 829             frameRate = downcast&lt;DoubleConstraint&gt;(*constraint).valueForCapabilityRange(this-&gt;frameRate(), range.rangeMin().asDouble, range.rangeMax().asDouble);
 830         }
 831     }
 832 
 833     if (width || height || frameRate)
 834         setSizeAndFrameRate(WTFMove(width), WTFMove(height), WTFMove(frameRate));
 835 
 836     for (auto&amp; variant : constraints) {
 837         if (variant.constraintType() == MediaConstraintType::Width || variant.constraintType() == MediaConstraintType::Height || variant.constraintType() == MediaConstraintType::FrameRate)
 838             continue;
 839 
 840         applyConstraint(variant);
 841     }
 842 
 843     commitConfiguration();
 844 }
 845 
 846 Optional&lt;RealtimeMediaSource::ApplyConstraintsError&gt; RealtimeMediaSource::applyConstraints(const MediaConstraints&amp; constraints)
 847 {
 848     ASSERT(constraints.isValid);
 849 
 850     FlattenedConstraint candidates;
 851     String failedConstraint;
 852     if (!selectSettings(constraints, candidates, failedConstraint, SelectType::ForApplyConstraints))
 853         return ApplyConstraintsError { failedConstraint, &quot;Constraint not supported&quot;_s };
 854 
 855     applyConstraints(candidates);
 856     return { };
 857 }
 858 
 859 void RealtimeMediaSource::applyConstraints(const MediaConstraints&amp; constraints, ApplyConstraintsHandler&amp;&amp; completionHandler)
 860 {
 861     completionHandler(applyConstraints(constraints));
 862 }
 863 
 864 void RealtimeMediaSource::setSize(const IntSize&amp; size)
 865 {
 866     if (size == m_size)
 867         return;
 868 
 869     m_size = size;
 870     notifySettingsDidChangeObservers({ RealtimeMediaSourceSettings::Flag::Width, RealtimeMediaSourceSettings::Flag::Height });
 871 }
 872 
 873 const IntSize RealtimeMediaSource::size() const
 874 {
 875     auto size = m_size;
 876 
 877     if (size.isEmpty() &amp;&amp; !m_intrinsicSize.isEmpty()) {
 878         if (size.isZero())
 879             size = m_intrinsicSize;
 880         else if (size.width())
 881             size.setHeight(size.width() * (m_intrinsicSize.height() / static_cast&lt;double&gt;(m_intrinsicSize.width())));
 882         else if (size.height())
 883             size.setWidth(size.height() * (m_intrinsicSize.width() / static_cast&lt;double&gt;(m_intrinsicSize.height())));
 884     }
 885 
 886     return size;
 887 }
 888 
 889 void RealtimeMediaSource::setIntrinsicSize(const IntSize&amp; size)
 890 {
 891     if (m_intrinsicSize == size)
 892         return;
 893 
 894     auto currentSize = this-&gt;size();
 895     m_intrinsicSize = size;
 896 
 897     if (currentSize != this-&gt;size())
 898         notifySettingsDidChangeObservers({ RealtimeMediaSourceSettings::Flag::Width, RealtimeMediaSourceSettings::Flag::Height });
 899 }
 900 
 901 const IntSize RealtimeMediaSource::intrinsicSize() const
 902 {
 903     return m_intrinsicSize;
 904 }
 905 
 906 void RealtimeMediaSource::setFrameRate(double rate)
 907 {
 908     if (m_frameRate == rate)
 909         return;
 910 
 911     m_frameRate = rate;
 912     notifySettingsDidChangeObservers(RealtimeMediaSourceSettings::Flag::FrameRate);
 913 }
 914 
 915 void RealtimeMediaSource::setAspectRatio(double ratio)
 916 {
 917     if (m_aspectRatio == ratio)
 918         return;
 919 
 920     m_aspectRatio = ratio;
 921     m_size.setHeight(m_size.width() / ratio);
 922     notifySettingsDidChangeObservers({ RealtimeMediaSourceSettings::Flag::AspectRatio, RealtimeMediaSourceSettings::Flag::Height });
 923 }
 924 
 925 void RealtimeMediaSource::setFacingMode(RealtimeMediaSourceSettings::VideoFacingMode mode)
 926 {
 927     if (m_facingMode == mode)
 928         return;
 929 
 930     m_facingMode = mode;
 931     notifySettingsDidChangeObservers(RealtimeMediaSourceSettings::Flag::FacingMode);
 932 }
 933 
 934 void RealtimeMediaSource::setVolume(double volume)
 935 {
 936     if (m_volume == volume)
 937         return;
 938 
 939     m_volume = volume;
 940     notifySettingsDidChangeObservers(RealtimeMediaSourceSettings::Flag::Volume);
 941 }
 942 
 943 void RealtimeMediaSource::setSampleRate(int rate)
 944 {
 945     if (m_sampleRate == rate)
 946         return;
 947 
 948     m_sampleRate = rate;
 949     notifySettingsDidChangeObservers(RealtimeMediaSourceSettings::Flag::SampleRate);
 950 }
 951 
 952 Optional&lt;Vector&lt;int&gt;&gt; RealtimeMediaSource::discreteSampleRates() const
 953 {
 954     return WTF::nullopt;
 955 }
 956 
 957 void RealtimeMediaSource::setSampleSize(int size)
 958 {
 959     if (m_sampleSize == size)
 960         return;
 961 
 962     m_sampleSize = size;
 963     notifySettingsDidChangeObservers(RealtimeMediaSourceSettings::Flag::SampleSize);
 964 }
 965 
 966 Optional&lt;Vector&lt;int&gt;&gt; RealtimeMediaSource::discreteSampleSizes() const
 967 {
 968     return WTF::nullopt;
 969 }
 970 
 971 void RealtimeMediaSource::setEchoCancellation(bool echoCancellation)
 972 {
 973     if (m_echoCancellation == echoCancellation)
 974         return;
 975 
 976     m_echoCancellation = echoCancellation;
 977     notifySettingsDidChangeObservers(RealtimeMediaSourceSettings::Flag::EchoCancellation);
 978 }
 979 
 980 void RealtimeMediaSource::scheduleDeferredTask(WTF::Function&lt;void()&gt;&amp;&amp; function)
 981 {
 982     ASSERT(function);
 983     callOnMainThread([weakThis = makeWeakPtr(*this), function = WTFMove(function)] {
 984         if (!weakThis)
 985             return;
 986 
 987         function();
 988     });
 989 }
 990 
 991 const String&amp; RealtimeMediaSource::hashedId() const
 992 {
 993     ASSERT(!m_hashedID.isEmpty());
 994     return m_hashedID;
 995 }
 996 
 997 String RealtimeMediaSource::deviceIDHashSalt() const
 998 {
 999     return m_idHashSalt;
1000 }
1001 
1002 RealtimeMediaSource::Observer::~Observer()
1003 {
1004 }
1005 
1006 } // namespace WebCore
1007 
1008 #endif // ENABLE(MEDIA_STREAM)
    </pre>
  </body>
</html>