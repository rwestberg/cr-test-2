<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLayer.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderLayer.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderLayerBacking.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLayer.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 61,13 ***</span>
<span class="line-new-header">--- 61,15 ---</span>
  namespace WebCore {
  
  class CSSFilter;
  class ClipRects;
  class ClipRectsCache;
<span class="line-added">+ class EventRegionContext;</span>
  class HitTestRequest;
  class HitTestResult;
  class HitTestingTransformState;
<span class="line-added">+ class Region;</span>
  class RenderFragmentedFlow;
  class RenderGeometryMap;
  class RenderLayerBacking;
  class RenderLayerCompositor;
  class RenderLayerFilters;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 113,10 ***</span>
<span class="line-new-header">--- 115,21 ---</span>
      False,
      True,
      Undetermined
  };
  
<span class="line-added">+ enum class IndirectCompositingReason {</span>
<span class="line-added">+     None,</span>
<span class="line-added">+     Stacking,</span>
<span class="line-added">+     OverflowScrollPositioning,</span>
<span class="line-added">+     Overlap,</span>
<span class="line-added">+     BackgroundLayer,</span>
<span class="line-added">+     GraphicalEffect, // opacity, mask, filter, transform etc.</span>
<span class="line-added">+     Perspective,</span>
<span class="line-added">+     Preserve3D</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
  struct ScrollRectToVisibleOptions {
      SelectionRevealMode revealMode { SelectionRevealMode::Reveal };
      const ScrollAlignment&amp; alignX { ScrollAlignment::alignCenterIfNeeded };
      const ScrollAlignment&amp; alignY { ScrollAlignment::alignCenterIfNeeded };
      ShouldAllowCrossOriginScrolling shouldAllowCrossOriginScrolling { ShouldAllowCrossOriginScrolling::No };
</pre>
<hr />
<pre>
<span class="line-old-header">*** 125,10 ***</span>
<span class="line-new-header">--- 138,12 ---</span>
  class RenderLayer final : public ScrollableArea {
      WTF_MAKE_FAST_ALLOCATED;
  public:
      friend class RenderReplica;
      friend class RenderLayerFilters;
<span class="line-added">+     friend class RenderLayerBacking;</span>
<span class="line-added">+     friend class RenderLayerCompositor;</span>
  
      explicit RenderLayer(RenderLayerModelObject&amp;);
      virtual ~RenderLayer();
  
  #if PLATFORM(IOS_FAMILY)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 162,11 ***</span>
  
      void insertOnlyThisLayer();
      void removeOnlyThisLayer();
  
      bool isNormalFlowOnly() const { return m_isNormalFlowOnly; }
<span class="line-modified">!     bool isStackingContext() const { return m_isStackingContext; }</span>
  
      // Gets the enclosing stacking context for this layer, excluding this layer itself.
      RenderLayer* stackingContext() const;
  
      // Gets the enclosing stacking container for this layer, possibly the layer
<span class="line-new-header">--- 177,19 ---</span>
  
      void insertOnlyThisLayer();
      void removeOnlyThisLayer();
  
      bool isNormalFlowOnly() const { return m_isNormalFlowOnly; }
<span class="line-modified">! </span>
<span class="line-added">+     // isStackingContext is true for layers that we&#39;ve determined should be stacking contexts for painting.</span>
<span class="line-added">+     // Not all stacking contexts are CSS stacking contexts.</span>
<span class="line-added">+     bool isStackingContext() const { return isCSSStackingContext() || m_isOpportunisticStackingContext; }</span>
<span class="line-added">+ </span>
<span class="line-added">+     // isCSSStackingContext is true for layers that are stacking contexts from a CSS perspective.</span>
<span class="line-added">+     // isCSSStackingContext() =&gt; isStackingContext().</span>
<span class="line-added">+     // FIXME: m_forcedStackingContext should affect isStackingContext(), not isCSSStackingContext(), but doing so breaks media control mix-blend-mode.</span>
<span class="line-added">+     bool isCSSStackingContext() const { return m_isCSSStackingContext || m_forcedStackingContext; }</span>
  
      // Gets the enclosing stacking context for this layer, excluding this layer itself.
      RenderLayer* stackingContext() const;
  
      // Gets the enclosing stacking container for this layer, possibly the layer
</pre>
<hr />
<pre>
<span class="line-old-header">*** 397,64 ***</span>
  
      LayoutRect rect() const { return LayoutRect(location(), size()); }
  
      IntSize visibleSize() const override;
      IntSize contentsSize() const override;
  
      int scrollWidth() const;
      int scrollHeight() const;
  
      void panScrollFromPoint(const IntPoint&amp;);
  
      // Scrolling methods for layers that can scroll their overflow.
      void scrollByRecursively(const IntSize&amp; delta, ScrollableArea** scrolledArea = nullptr);
  
<span class="line-modified">!     WEBCORE_EXPORT void scrollToOffset(const ScrollOffset&amp;, ScrollClamping = ScrollClamping::Clamped);</span>
<span class="line-removed">-     void scrollToXOffset(int x, ScrollClamping clamping = ScrollClamping::Clamped) { scrollToOffset(ScrollOffset(x, scrollOffset().y()), clamping); }</span>
<span class="line-removed">-     void scrollToYOffset(int y, ScrollClamping clamping = ScrollClamping::Clamped) { scrollToOffset(ScrollOffset(scrollOffset().x(), y), clamping); }</span>
  
<span class="line-modified">!     void scrollToXPosition(int x, ScrollClamping = ScrollClamping::Clamped);</span>
<span class="line-modified">!     void scrollToYPosition(int y, ScrollClamping = ScrollClamping::Clamped);</span>
  
      void setPostLayoutScrollPosition(Optional&lt;ScrollPosition&gt;);
      void applyPostLayoutScrollPositionIfNeeded();
  
<span class="line-removed">-     ScrollOffset scrollOffset() const { return scrollOffsetFromPosition(m_scrollPosition); }</span>
<span class="line-removed">-     IntSize scrollableContentsSize() const;</span>
<span class="line-removed">- </span>
      void availableContentSizeChanged(AvailableSizeChangeReason) override;
  
      // &quot;absoluteRect&quot; is in scaled document coordinates.
      void scrollRectToVisible(const LayoutRect&amp; absoluteRect, bool insideFixed, const ScrollRectToVisibleOptions&amp;);
  
      bool scrollsOverflow() const;
      bool hasScrollbars() const { return m_hBar || m_vBar; }
      void setHasHorizontalScrollbar(bool);
      void setHasVerticalScrollbar(bool);
  
      Ref&lt;Scrollbar&gt; createScrollbar(ScrollbarOrientation);
      void destroyScrollbar(ScrollbarOrientation);
  
      bool hasHorizontalScrollbar() const { return horizontalScrollbar(); }
      bool hasVerticalScrollbar() const { return verticalScrollbar(); }
  
      // ScrollableArea overrides
      ScrollPosition scrollPosition() const override { return m_scrollPosition; }
  
      Scrollbar* horizontalScrollbar() const override { return m_hBar.get(); }
      Scrollbar* verticalScrollbar() const override { return m_vBar.get(); }
      ScrollableArea* enclosingScrollableArea() const override;
      bool isScrollableOrRubberbandable() override;
      bool hasScrollableOrRubberbandableAncestor() override;
      bool useDarkAppearance() const final;
  #if ENABLE(CSS_SCROLL_SNAP)
      void updateSnapOffsets() override;
  #endif
  
<span class="line-removed">-     void setIsUserScroll(bool isUserScroll) override { m_inUserScroll = isUserScroll; }</span>
<span class="line-removed">-     bool isInUserScroll() const { return m_inUserScroll; }</span>
<span class="line-removed">- </span>
      bool requiresScrollPositionReconciliation() const { return m_requiresScrollPositionReconciliation; }
      void setRequiresScrollPositionReconciliation(bool requiresReconciliation = true) { m_requiresScrollPositionReconciliation = requiresReconciliation; }
  
  #if PLATFORM(IOS_FAMILY)
  #if ENABLE(IOS_TOUCH_EVENTS)
<span class="line-new-header">--- 420,67 ---</span>
  
      LayoutRect rect() const { return LayoutRect(location(), size()); }
  
      IntSize visibleSize() const override;
      IntSize contentsSize() const override;
<span class="line-added">+     IntSize reachableTotalContentsSize() const override;</span>
  
      int scrollWidth() const;
      int scrollHeight() const;
  
      void panScrollFromPoint(const IntPoint&amp;);
  
      // Scrolling methods for layers that can scroll their overflow.
      void scrollByRecursively(const IntSize&amp; delta, ScrollableArea** scrolledArea = nullptr);
  
<span class="line-modified">!     WEBCORE_EXPORT void scrollToOffset(const ScrollOffset&amp;, ScrollType = ScrollType::Programmatic, ScrollClamping = ScrollClamping::Clamped);</span>
  
<span class="line-modified">!     void scrollToXPosition(int x, ScrollType, ScrollClamping = ScrollClamping::Clamped);</span>
<span class="line-modified">!     void scrollToYPosition(int y, ScrollType, ScrollClamping = ScrollClamping::Clamped);</span>
<span class="line-added">+ </span>
<span class="line-added">+     // These are only used by marquee.</span>
<span class="line-added">+     void scrollToXOffset(int x) { scrollToOffset(ScrollOffset(x, scrollOffset().y()), ScrollType::Programmatic, ScrollClamping::Unclamped); }</span>
<span class="line-added">+     void scrollToYOffset(int y) { scrollToOffset(ScrollOffset(scrollOffset().x(), y), ScrollType::Programmatic, ScrollClamping::Unclamped); }</span>
  
      void setPostLayoutScrollPosition(Optional&lt;ScrollPosition&gt;);
      void applyPostLayoutScrollPositionIfNeeded();
  
      void availableContentSizeChanged(AvailableSizeChangeReason) override;
  
      // &quot;absoluteRect&quot; is in scaled document coordinates.
      void scrollRectToVisible(const LayoutRect&amp; absoluteRect, bool insideFixed, const ScrollRectToVisibleOptions&amp;);
  
      bool scrollsOverflow() const;
<span class="line-added">+     bool hasScrollableHorizontalOverflow() const;</span>
<span class="line-added">+     bool hasScrollableVerticalOverflow() const;</span>
      bool hasScrollbars() const { return m_hBar || m_vBar; }
      void setHasHorizontalScrollbar(bool);
      void setHasVerticalScrollbar(bool);
  
      Ref&lt;Scrollbar&gt; createScrollbar(ScrollbarOrientation);
      void destroyScrollbar(ScrollbarOrientation);
  
      bool hasHorizontalScrollbar() const { return horizontalScrollbar(); }
      bool hasVerticalScrollbar() const { return verticalScrollbar(); }
  
<span class="line-added">+     bool horizontalScrollbarHiddenByStyle() const override;</span>
<span class="line-added">+     bool verticalScrollbarHiddenByStyle() const override;</span>
<span class="line-added">+ </span>
      // ScrollableArea overrides
      ScrollPosition scrollPosition() const override { return m_scrollPosition; }
  
      Scrollbar* horizontalScrollbar() const override { return m_hBar.get(); }
      Scrollbar* verticalScrollbar() const override { return m_vBar.get(); }
      ScrollableArea* enclosingScrollableArea() const override;
<span class="line-added">+ </span>
      bool isScrollableOrRubberbandable() override;
      bool hasScrollableOrRubberbandableAncestor() override;
      bool useDarkAppearance() const final;
  #if ENABLE(CSS_SCROLL_SNAP)
      void updateSnapOffsets() override;
  #endif
  
      bool requiresScrollPositionReconciliation() const { return m_requiresScrollPositionReconciliation; }
      void setRequiresScrollPositionReconciliation(bool requiresReconciliation = true) { m_requiresScrollPositionReconciliation = requiresReconciliation; }
  
  #if PLATFORM(IOS_FAMILY)
  #if ENABLE(IOS_TOUCH_EVENTS)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 467,11 ***</span>
  #endif
  
      // Returns true when the layer could do touch scrolling, but doesn&#39;t look at whether there is actually scrollable overflow.
      bool canUseCompositedScrolling() const;
      // Returns true when there is actually scrollable overflow (requires layout to be up-to-date).
<span class="line-modified">!     bool hasCompositedScrollableOverflow() const;</span>
  
      int verticalScrollbarWidth(OverlayScrollbarSizeRelevancy = IgnoreOverlayScrollbarSize) const;
      int horizontalScrollbarHeight(OverlayScrollbarSizeRelevancy = IgnoreOverlayScrollbarSize) const;
  
      bool hasOverflowControls() const;
<span class="line-new-header">--- 493,11 ---</span>
  #endif
  
      // Returns true when the layer could do touch scrolling, but doesn&#39;t look at whether there is actually scrollable overflow.
      bool canUseCompositedScrolling() const;
      // Returns true when there is actually scrollable overflow (requires layout to be up-to-date).
<span class="line-modified">!     bool hasCompositedScrollableOverflow() const { return m_hasCompositedScrollableOverflow; }</span>
  
      int verticalScrollbarWidth(OverlayScrollbarSizeRelevancy = IgnoreOverlayScrollbarSize) const;
      int horizontalScrollbarHeight(OverlayScrollbarSizeRelevancy = IgnoreOverlayScrollbarSize) const;
  
      bool hasOverflowControls() const;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 493,29 ***</span>
      bool inResizeMode() const { return m_inResizeMode; }
      void setInResizeMode(bool b) { m_inResizeMode = b; }
  
      bool isRenderViewLayer() const { return m_isRenderViewLayer; }
      bool isForcedStackingContext() const { return m_forcedStackingContext; }
  
      RenderLayerCompositor&amp; compositor() const;
  
      // Notification from the renderer that its content changed (e.g. current frame of image changed).
      // Allows updates of layer content without repainting.
      void contentChanged(ContentChangeType);
  
      bool canRender3DTransforms() const;
  
<span class="line-modified">!     enum UpdateLayerPositionsFlag {</span>
<span class="line-modified">!         CheckForRepaint                 = 1 &lt;&lt; 0,</span>
<span class="line-removed">-         NeedsFullRepaintInBacking       = 1 &lt;&lt; 1,</span>
<span class="line-removed">-         UpdatePagination                = 1 &lt;&lt; 2,</span>
<span class="line-removed">-         SeenTransformedLayer            = 1 &lt;&lt; 3,</span>
<span class="line-removed">-         Seen3DTransformedLayer          = 1 &lt;&lt; 4,</span>
<span class="line-removed">-     };</span>
<span class="line-removed">-     static constexpr OptionSet&lt;UpdateLayerPositionsFlag&gt; updateLayerPositionsDefaultFlags() { return { CheckForRepaint }; }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     void updateLayerPositionsAfterLayout(const RenderLayer* rootLayer, OptionSet&lt;UpdateLayerPositionsFlag&gt;);</span>
  
      void updateLayerPositionsAfterOverflowScroll();
      void updateLayerPositionsAfterDocumentScroll();
  
      bool hasCompositedLayerInEnclosingPaginationChain() const;
<span class="line-new-header">--- 519,22 ---</span>
      bool inResizeMode() const { return m_inResizeMode; }
      void setInResizeMode(bool b) { m_inResizeMode = b; }
  
      bool isRenderViewLayer() const { return m_isRenderViewLayer; }
      bool isForcedStackingContext() const { return m_forcedStackingContext; }
<span class="line-added">+     bool isOpportunisticStackingContext() const { return m_isOpportunisticStackingContext; }</span>
  
      RenderLayerCompositor&amp; compositor() const;
  
      // Notification from the renderer that its content changed (e.g. current frame of image changed).
      // Allows updates of layer content without repainting.
      void contentChanged(ContentChangeType);
  
      bool canRender3DTransforms() const;
  
<span class="line-modified">!     void updateLayerPositionsAfterStyleChange();</span>
<span class="line-modified">!     void updateLayerPositionsAfterLayout(bool isRelayoutingSubtree, bool didFullRepaint);</span>
  
      void updateLayerPositionsAfterOverflowScroll();
      void updateLayerPositionsAfterDocumentScroll();
  
      bool hasCompositedLayerInEnclosingPaginationChain() const;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 529,10 ***</span>
<span class="line-new-header">--- 548,11 ---</span>
  
      void updateTransform();
  
  #if ENABLE(CSS_COMPOSITING)
      void updateBlendMode();
<span class="line-added">+     void willRemoveChildWithBlendMode();</span>
  #endif
  
      const LayoutSize&amp; offsetForInFlowPosition() const { return m_offsetForInFlowPosition; }
  
      void clearClipRectsIncludingDescendants(ClipRectsType typeToClear = AllClipRectTypes);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 551,10 ***</span>
<span class="line-new-header">--- 571,12 ---</span>
      void dirtyVisibleContentStatus();
  
      bool hasVisibleBoxDecorationsOrBackground() const;
      bool hasVisibleBoxDecorations() const;
  
<span class="line-added">+     bool behavesAsFixed() const { return m_behavesAsFixed; }</span>
<span class="line-added">+ </span>
      struct PaintedContentRequest {
          void makeStatesUndetermined()
          {
              if (hasPaintedContent == RequestState::Unknown)
                  hasPaintedContent = RequestState::Undetermined;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 585,10 ***</span>
<span class="line-new-header">--- 607,12 ---</span>
  
      // FIXME: We should ASSERT(!m_hasSelfPaintingLayerDescendantDirty); here but we hit the same bugs as visible content above.
      // Part of the issue is with subtree relayout: we don&#39;t check if our ancestors have some descendant flags dirty, missing some updates.
      bool hasSelfPaintingLayerDescendant() const { return m_hasSelfPaintingLayerDescendant; }
  
<span class="line-added">+     bool ancestorLayerIsInContainingBlockChain(const RenderLayer&amp; ancestor, const RenderLayer* checkLimit = nullptr) const;</span>
<span class="line-added">+ </span>
      // Gets the nearest enclosing positioned ancestor layer (also includes
      // the &lt;html&gt; layer and the root layer).
      RenderLayer* enclosingAncestorForPosition(PositionType) const;
  
      // Returns the nearest enclosing layer that is scrollable.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 608,13 ***</span>
      RenderLayer* enclosingFilterLayer(IncludeSelfOrNot = IncludeSelf) const;
      RenderLayer* enclosingFilterRepaintLayer() const;
      void setFilterBackendNeedsRepaintingInRect(const LayoutRect&amp;);
      bool hasAncestorWithFilterOutsets() const;
  
<span class="line-modified">!     bool canUseConvertToLayerCoords() const</span>
      {
<span class="line-modified">!         // These RenderObject have an impact on their layers&#39; without them knowing about it.</span>
          return !renderer().hasTransform() &amp;&amp; !renderer().isSVGRoot();
      }
  
      // FIXME: adjustForColumns allows us to position compositing layers in columns correctly, but eventually they need to be split across columns too.
      enum ColumnOffsetAdjustment { DontAdjustForColumns, AdjustForColumns };
<span class="line-new-header">--- 632,14 ---</span>
      RenderLayer* enclosingFilterLayer(IncludeSelfOrNot = IncludeSelf) const;
      RenderLayer* enclosingFilterRepaintLayer() const;
      void setFilterBackendNeedsRepaintingInRect(const LayoutRect&amp;);
      bool hasAncestorWithFilterOutsets() const;
  
<span class="line-modified">!     bool canUseOffsetFromAncestor() const</span>
      {
<span class="line-modified">!         // FIXME: This really needs to know if there are transforms on this layer and any of the layers</span>
<span class="line-added">+         // between it and the ancestor in question.</span>
          return !renderer().hasTransform() &amp;&amp; !renderer().isSVGRoot();
      }
  
      // FIXME: adjustForColumns allows us to position compositing layers in columns correctly, but eventually they need to be split across columns too.
      enum ColumnOffsetAdjustment { DontAdjustForColumns, AdjustForColumns };
</pre>
<hr />
<pre>
<span class="line-old-header">*** 637,12 ***</span>
          PaintLayerPaintingCompositingScrollingPhase     = 1 &lt;&lt; 9,
          PaintLayerPaintingOverflowContents              = 1 &lt;&lt; 10,
          PaintLayerPaintingRootBackgroundOnly            = 1 &lt;&lt; 11,
          PaintLayerPaintingSkipRootBackground            = 1 &lt;&lt; 12,
          PaintLayerPaintingChildClippingMaskPhase        = 1 &lt;&lt; 13,
      };
<span class="line-modified">!     static constexpr OptionSet&lt;PaintLayerFlag&gt; paintLayerPaintingCompositingAllPhasesFlags() { return { PaintLayerPaintingCompositingBackgroundPhase,  PaintLayerPaintingCompositingForegroundPhase }; }</span>
  
      enum class SecurityOriginPaintPolicy { AnyOrigin, AccessibleOriginOnly };
  
      // The two main functions that use the layer system.  The paint method
      // paints the layers that intersect the damage rect from back to
<span class="line-new-header">--- 662,13 ---</span>
          PaintLayerPaintingCompositingScrollingPhase     = 1 &lt;&lt; 9,
          PaintLayerPaintingOverflowContents              = 1 &lt;&lt; 10,
          PaintLayerPaintingRootBackgroundOnly            = 1 &lt;&lt; 11,
          PaintLayerPaintingSkipRootBackground            = 1 &lt;&lt; 12,
          PaintLayerPaintingChildClippingMaskPhase        = 1 &lt;&lt; 13,
<span class="line-added">+         PaintLayerCollectingEventRegion                 = 1 &lt;&lt; 14,</span>
      };
<span class="line-modified">!     static constexpr OptionSet&lt;PaintLayerFlag&gt; paintLayerPaintingCompositingAllPhasesFlags() { return { PaintLayerPaintingCompositingBackgroundPhase, PaintLayerPaintingCompositingForegroundPhase }; }</span>
  
      enum class SecurityOriginPaintPolicy { AnyOrigin, AccessibleOriginOnly };
  
      // The two main functions that use the layer system.  The paint method
      // paints the layers that intersect the damage rect from back to
</pre>
<hr />
<pre>
<span class="line-old-header">*** 682,10 ***</span>
<span class="line-new-header">--- 708,12 ---</span>
  
      LayoutRect childrenClipRect() const; // Returns the foreground clip rect of the layer in the document&#39;s coordinate space.
      LayoutRect selfClipRect() const; // Returns the background clip rect of the layer in the document&#39;s coordinate space.
      LayoutRect localClipRect(bool&amp; clipExceedsBounds) const; // Returns the background clip rect of the layer in the local coordinate space.
  
<span class="line-added">+     bool clipCrossesPaintingBoundary() const;</span>
<span class="line-added">+ </span>
      // Pass offsetFromRoot if known.
      bool intersectsDamageRect(const LayoutRect&amp; layerBounds, const LayoutRect&amp; damageRect, const RenderLayer* rootLayer, const LayoutSize&amp; offsetFromRoot, const LayoutRect* cachedBoundingBox = nullptr) const;
  
      enum CalculateLayerBoundsFlag {
          IncludeSelfTransform                    = 1 &lt;&lt; 0,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 755,10 ***</span>
<span class="line-new-header">--- 783,11 ---</span>
      // Note that this transform has the perspective-origin baked in.
      TransformationMatrix perspectiveTransform() const;
      FloatPoint perspectiveOrigin() const;
      bool preserves3D() const { return renderer().style().transformStyle3D() == TransformStyle3D::Preserve3D; }
      bool has3DTransform() const { return m_transform &amp;&amp; !m_transform-&gt;isAffine(); }
<span class="line-added">+     bool hasTransformedAncestor() const { return m_hasTransformedAncestor; }</span>
  
      void filterNeedsRepaint();
      bool hasFilter() const { return renderer().hasFilter(); }
      bool hasBackdropFilter() const
      {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 771,18 ***</span>
  
  #if ENABLE(CSS_COMPOSITING)
      bool hasBlendMode() const { return renderer().hasBlendMode(); }
      BlendMode blendMode() const { return static_cast&lt;BlendMode&gt;(m_blendMode); }
  
<span class="line-modified">!     bool isolatesCompositedBlending() const { return m_hasNotIsolatedCompositedBlendingDescendants &amp;&amp; isStackingContext(); }</span>
      bool hasNotIsolatedCompositedBlendingDescendants() const { return m_hasNotIsolatedCompositedBlendingDescendants; }
      void setHasNotIsolatedCompositedBlendingDescendants(bool hasNotIsolatedCompositedBlendingDescendants)
      {
          m_hasNotIsolatedCompositedBlendingDescendants = hasNotIsolatedCompositedBlendingDescendants;
      }
  
<span class="line-modified">!     bool isolatesBlending() const { return hasNotIsolatedBlendingDescendants() &amp;&amp; isStackingContext(); }</span>
  
      // FIXME: We should ASSERT(!m_hasNotIsolatedBlendingDescendantsStatusDirty); here but we hit the same bugs as visible content above.
      bool hasNotIsolatedBlendingDescendants() const { return m_hasNotIsolatedBlendingDescendants; }
      bool hasNotIsolatedBlendingDescendantsStatusDirty() const { return m_hasNotIsolatedBlendingDescendantsStatusDirty; }
  #else
<span class="line-new-header">--- 800,18 ---</span>
  
  #if ENABLE(CSS_COMPOSITING)
      bool hasBlendMode() const { return renderer().hasBlendMode(); }
      BlendMode blendMode() const { return static_cast&lt;BlendMode&gt;(m_blendMode); }
  
<span class="line-modified">!     bool isolatesCompositedBlending() const { return m_hasNotIsolatedCompositedBlendingDescendants &amp;&amp; isCSSStackingContext(); }</span>
      bool hasNotIsolatedCompositedBlendingDescendants() const { return m_hasNotIsolatedCompositedBlendingDescendants; }
      void setHasNotIsolatedCompositedBlendingDescendants(bool hasNotIsolatedCompositedBlendingDescendants)
      {
          m_hasNotIsolatedCompositedBlendingDescendants = hasNotIsolatedCompositedBlendingDescendants;
      }
  
<span class="line-modified">!     bool isolatesBlending() const { return hasNotIsolatedBlendingDescendants() &amp;&amp; isCSSStackingContext(); }</span>
  
      // FIXME: We should ASSERT(!m_hasNotIsolatedBlendingDescendantsStatusDirty); here but we hit the same bugs as visible content above.
      bool hasNotIsolatedBlendingDescendants() const { return m_hasNotIsolatedBlendingDescendants; }
      bool hasNotIsolatedBlendingDescendantsStatusDirty() const { return m_hasNotIsolatedBlendingDescendantsStatusDirty; }
  #else
</pre>
<hr />
<pre>
<span class="line-old-header">*** 794,10 ***</span>
<span class="line-new-header">--- 823,17 ---</span>
  
      bool isComposited() const { return m_backing != nullptr; }
      bool hasCompositingDescendant() const { return m_hasCompositingDescendant; }
      bool hasCompositedMask() const;
  
<span class="line-added">+     // If non-null, a non-ancestor composited layer that this layer paints into (it is sharing its backing store with this layer).</span>
<span class="line-added">+     RenderLayer* backingProviderLayer() const { return m_backingProviderLayer.get(); }</span>
<span class="line-added">+     void setBackingProviderLayer(RenderLayer*);</span>
<span class="line-added">+     void disconnectFromBackingProviderLayer();</span>
<span class="line-added">+ </span>
<span class="line-added">+     bool paintsIntoProvidedBacking() const { return !!m_backingProviderLayer; }</span>
<span class="line-added">+ </span>
      RenderLayerBacking* backing() const { return m_backing.get(); }
      RenderLayerBacking* ensureBacking();
      void clearBacking(bool layerBeingDestroyed = false);
  
      GraphicsLayer* layerForHorizontalScrollbar() const override;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 805,10 ***</span>
<span class="line-new-header">--- 841,13 ---</span>
      GraphicsLayer* layerForScrollCorner() const override;
  
      bool usesCompositedScrolling() const override;
      bool usesAsyncScrolling() const override;
  
<span class="line-added">+     bool hasCompositedScrollingAncestor() const { return m_hasCompositedScrollingAncestor; }</span>
<span class="line-added">+     void setHasCompositedScrollingAncestor(bool hasCompositedScrollingAncestor) { m_hasCompositedScrollingAncestor = hasCompositedScrollingAncestor; }</span>
<span class="line-added">+ </span>
      bool paintsWithTransparency(OptionSet&lt;PaintBehavior&gt; paintBehavior) const
      {
          return (isTransparent() || hasBlendMode() || (isolatesBlending() &amp;&amp; !renderer().isDocumentElementRenderer())) &amp;&amp; ((paintBehavior &amp; PaintBehavior::FlattenCompositingLayers) || !isComposited());
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 838,10 ***</span>
<span class="line-new-header">--- 877,12 ---</span>
      };
  
      void setViewportConstrainedNotCompositedReason(ViewportConstrainedNotCompositedReason reason) { m_viewportConstrainedNotCompositedReason = reason; }
      ViewportConstrainedNotCompositedReason viewportConstrainedNotCompositedReason() const { return static_cast&lt;ViewportConstrainedNotCompositedReason&gt;(m_viewportConstrainedNotCompositedReason); }
  
<span class="line-added">+     IndirectCompositingReason indirectCompositingReason() const { return static_cast&lt;IndirectCompositingReason&gt;(m_indirectCompositingReason); }</span>
<span class="line-added">+ </span>
      bool isRenderFragmentedFlow() const { return renderer().isRenderFragmentedFlow(); }
      bool isOutOfFlowRenderFragmentedFlow() const { return renderer().isOutOfFlowRenderFragmentedFlow(); }
      bool isInsideFragmentedFlow() const { return renderer().fragmentedFlowState() != RenderObject::NotInsideFragmentedFlow; }
      bool isDirtyRenderFragmentedFlow() const
      {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 854,10 ***</span>
<span class="line-new-header">--- 895,14 ---</span>
      bool shouldPlaceBlockDirectionScrollbarOnLeft() const final { return renderer().shouldPlaceBlockDirectionScrollbarOnLeft(); }
  
      void simulateFrequentPaint() { SinglePaintFrequencyTracking { m_paintFrequencyTracker }; }
      bool paintingFrequently() const { return m_paintFrequencyTracker.paintingFrequently(); }
  
<span class="line-added">+     WEBCORE_EXPORT bool isTransparentOrFullyClippedRespectingParentFrames() const;</span>
<span class="line-added">+ </span>
<span class="line-added">+     void invalidateEventRegion();</span>
<span class="line-added">+ </span>
  private:
  
      void setNextSibling(RenderLayer* next) { m_next = next; }
      void setPreviousSibling(RenderLayer* prev) { m_previous = prev; }
      void setParent(RenderLayer*);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 865,15 ***</span>
      void setLastChild(RenderLayer* last) { m_last = last; }
  
      void dirtyPaintOrderListsOnChildChange(RenderLayer&amp;);
  
      bool shouldBeNormalFlowOnly() const;
<span class="line-modified">!     bool shouldBeStackingContext() const;</span>
  
      // Return true if changed.
      bool setIsNormalFlowOnly(bool);
<span class="line-modified">!     bool setIsStackingContext(bool);</span>
  
      bool isDirtyStackingContext() const { return m_zOrderListsDirty &amp;&amp; isStackingContext(); }
  
      void updateZOrderLists();
      void rebuildZOrderLists();
<span class="line-new-header">--- 910,19 ---</span>
      void setLastChild(RenderLayer* last) { m_last = last; }
  
      void dirtyPaintOrderListsOnChildChange(RenderLayer&amp;);
  
      bool shouldBeNormalFlowOnly() const;
<span class="line-modified">!     bool shouldBeCSSStackingContext() const;</span>
  
      // Return true if changed.
      bool setIsNormalFlowOnly(bool);
<span class="line-modified">! </span>
<span class="line-added">+     bool setIsOpportunisticStackingContext(bool);</span>
<span class="line-added">+     bool setIsCSSStackingContext(bool);</span>
<span class="line-added">+ </span>
<span class="line-added">+     void isStackingContextChanged();</span>
  
      bool isDirtyStackingContext() const { return m_zOrderListsDirty &amp;&amp; isStackingContext(); }
  
      void updateZOrderLists();
      void rebuildZOrderLists();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 900,10 ***</span>
<span class="line-new-header">--- 949,11 ---</span>
          LayoutSize subpixelOffset;
          OverlapTestRequestMap* overlapTestRequests; // May be null.
          OptionSet&lt;PaintBehavior&gt; paintBehavior;
          bool requireSecurityOriginAccessForWidgets;
          bool clipToDirtyRect { true };
<span class="line-added">+         EventRegionContext* eventRegionContext { nullptr };</span>
      };
  
      // Compute, cache and return clip rects computed with the given layer as the root.
      Ref&lt;ClipRects&gt; updateClipRects(const ClipRectsContext&amp;);
      // Compute and return the clip rects. If useCached is true, will used previously computed clip rects on ancestors
</pre>
<hr />
<pre>
<span class="line-old-header">*** 928,14 ***</span>
      void updateSelfPaintingLayer();
  
      void updateScrollbarsAfterStyleChange(const RenderStyle* oldStyle);
      void updateScrollbarsAfterLayout();
  
      // Returns true if the position changed.
<span class="line-modified">!     bool updateLayerPosition();</span>
  
<span class="line-modified">!     void updateLayerPositions(RenderGeometryMap* = nullptr, OptionSet&lt;UpdateLayerPositionsFlag&gt; = updateLayerPositionsDefaultFlags());</span>
  
      enum UpdateLayerPositionsAfterScrollFlag {
          IsOverflowScroll                        = 1 &lt;&lt; 0,
          HasSeenViewportConstrainedAncestor      = 1 &lt;&lt; 1,
          HasSeenAncestorWithOverflowClip         = 1 &lt;&lt; 2,
<span class="line-new-header">--- 978,26 ---</span>
      void updateSelfPaintingLayer();
  
      void updateScrollbarsAfterStyleChange(const RenderStyle* oldStyle);
      void updateScrollbarsAfterLayout();
  
<span class="line-added">+     enum UpdateLayerPositionsFlag {</span>
<span class="line-added">+         CheckForRepaint                     = 1 &lt;&lt; 0,</span>
<span class="line-added">+         NeedsFullRepaintInBacking           = 1 &lt;&lt; 1,</span>
<span class="line-added">+         ContainingClippingLayerChangedSize  = 1 &lt;&lt; 2,</span>
<span class="line-added">+         UpdatePagination                    = 1 &lt;&lt; 3,</span>
<span class="line-added">+         SeenFixedLayer                      = 1 &lt;&lt; 4,</span>
<span class="line-added">+         SeenTransformedLayer                = 1 &lt;&lt; 5,</span>
<span class="line-added">+         Seen3DTransformedLayer              = 1 &lt;&lt; 6,</span>
<span class="line-added">+         SeenCompositedScrollingLayer        = 1 &lt;&lt; 7,</span>
<span class="line-added">+     };</span>
<span class="line-added">+     static OptionSet&lt;UpdateLayerPositionsFlag&gt; flagsForUpdateLayerPositions(RenderLayer&amp; startingLayer);</span>
<span class="line-added">+ </span>
      // Returns true if the position changed.
<span class="line-modified">!     bool updateLayerPosition(OptionSet&lt;UpdateLayerPositionsFlag&gt;* = nullptr);</span>
  
<span class="line-modified">!     void updateLayerPositions(RenderGeometryMap*, OptionSet&lt;UpdateLayerPositionsFlag&gt;);</span>
  
      enum UpdateLayerPositionsAfterScrollFlag {
          IsOverflowScroll                        = 1 &lt;&lt; 0,
          HasSeenViewportConstrainedAncestor      = 1 &lt;&lt; 1,
          HasSeenAncestorWithOverflowClip         = 1 &lt;&lt; 2,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 961,10 ***</span>
<span class="line-new-header">--- 1023,12 ---</span>
      RenderLayerFilters* filtersForPainting(GraphicsContext&amp;, OptionSet&lt;PaintLayerFlag&gt;) const;
      GraphicsContext* setupFilters(GraphicsContext&amp; destinationContext, LayerPaintingInfo&amp;, OptionSet&lt;PaintLayerFlag&gt;, const LayoutSize&amp; offsetFromRoot, LayoutRect&amp; rootRelativeBounds, bool&amp; rootRelativeBoundsComputed);
      void applyFilters(GraphicsContext&amp; originalContext, const LayerPaintingInfo&amp;, const LayerFragments&amp;);
  
      void paintLayer(GraphicsContext&amp;, const LayerPaintingInfo&amp;, OptionSet&lt;PaintLayerFlag&gt;);
<span class="line-added">+     void paintLayerWithEffects(GraphicsContext&amp;, const LayerPaintingInfo&amp;, OptionSet&lt;PaintLayerFlag&gt;);</span>
<span class="line-added">+ </span>
      void paintLayerContentsAndReflection(GraphicsContext&amp;, const LayerPaintingInfo&amp;, OptionSet&lt;PaintLayerFlag&gt;);
      void paintLayerByApplyingTransform(GraphicsContext&amp;, const LayerPaintingInfo&amp;, OptionSet&lt;PaintLayerFlag&gt;, const LayoutSize&amp; translationOffset = LayoutSize());
      void paintLayerContents(GraphicsContext&amp;, const LayerPaintingInfo&amp;, OptionSet&lt;PaintLayerFlag&gt;);
      void paintList(LayerList, GraphicsContext&amp;, const LayerPaintingInfo&amp;, OptionSet&lt;PaintLayerFlag&gt;);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 977,10 ***</span>
<span class="line-new-header">--- 1041,11 ---</span>
      void paintOutlineForFragments(const LayerFragments&amp;, GraphicsContext&amp;, const LayerPaintingInfo&amp;, OptionSet&lt;PaintBehavior&gt;, RenderObject* paintingRootForRenderer);
      void paintOverflowControlsForFragments(const LayerFragments&amp;, GraphicsContext&amp;, const LayerPaintingInfo&amp;);
      void paintMaskForFragments(const LayerFragments&amp;, GraphicsContext&amp;, const LayerPaintingInfo&amp;, OptionSet&lt;PaintBehavior&gt;, RenderObject* paintingRootForRenderer);
      void paintChildClippingMaskForFragments(const LayerFragments&amp;, GraphicsContext&amp;, const LayerPaintingInfo&amp;, OptionSet&lt;PaintBehavior&gt;, RenderObject* paintingRootForRenderer);
      void paintTransformedLayerIntoFragments(GraphicsContext&amp;, const LayerPaintingInfo&amp;, OptionSet&lt;PaintLayerFlag&gt;);
<span class="line-added">+     void collectEventRegionForFragments(const LayerFragments&amp;, GraphicsContext&amp;, const LayerPaintingInfo&amp;);</span>
  
      RenderLayer* transparentPaintingAncestor();
      void beginTransparencyLayers(GraphicsContext&amp;, const LayerPaintingInfo&amp;, const LayoutRect&amp; dirtyRect);
  
      RenderLayer* hitTestLayer(RenderLayer* rootLayer, RenderLayer* containerLayer, const HitTestRequest&amp;, HitTestResult&amp;,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1008,31 ***</span>
      bool listBackgroundIsKnownToBeOpaqueInRect(const LayerList&amp;, const LayoutRect&amp;) const;
  
      void computeScrollDimensions();
      bool hasHorizontalOverflow() const;
      bool hasVerticalOverflow() const;
<span class="line-removed">-     bool hasScrollableHorizontalOverflow() const;</span>
<span class="line-removed">-     bool hasScrollableVerticalOverflow() const;</span>
  
      bool showsOverflowControls() const;
  
      bool shouldBeSelfPaintingLayer() const;
  
<span class="line-removed">-     int scrollOffset(ScrollbarOrientation) const override;</span>
<span class="line-removed">- </span>
      // ScrollableArea interface
      void invalidateScrollbarRect(Scrollbar&amp;, const IntRect&amp;) override;
      void invalidateScrollCornerRect(const IntRect&amp;) override;
      bool isActive() const override;
      bool isScrollCornerVisible() const override;
      IntRect scrollCornerRect() const override;
      IntRect convertFromScrollbarToContainingView(const Scrollbar&amp;, const IntRect&amp;) const override;
      IntRect convertFromContainingViewToScrollbar(const Scrollbar&amp;, const IntRect&amp;) const override;
      IntPoint convertFromScrollbarToContainingView(const Scrollbar&amp;, const IntPoint&amp;) const override;
      IntPoint convertFromContainingViewToScrollbar(const Scrollbar&amp;, const IntPoint&amp;) const override;
<span class="line-removed">-     int scrollSize(ScrollbarOrientation) const override;</span>
      void setScrollOffset(const ScrollOffset&amp;) override;
  
      IntRect visibleContentRectInternal(VisibleContentRectIncludesScrollbars, VisibleContentRectBehavior) const override;
      IntSize overhangAmount() const override;
      IntPoint lastKnownMousePosition() const override;
      bool isHandlingWheelEvent() const override;
<span class="line-new-header">--- 1073,27 ---</span>
      bool listBackgroundIsKnownToBeOpaqueInRect(const LayerList&amp;, const LayoutRect&amp;) const;
  
      void computeScrollDimensions();
      bool hasHorizontalOverflow() const;
      bool hasVerticalOverflow() const;
  
      bool showsOverflowControls() const;
  
      bool shouldBeSelfPaintingLayer() const;
  
      // ScrollableArea interface
      void invalidateScrollbarRect(Scrollbar&amp;, const IntRect&amp;) override;
      void invalidateScrollCornerRect(const IntRect&amp;) override;
      bool isActive() const override;
      bool isScrollCornerVisible() const override;
      IntRect scrollCornerRect() const override;
      IntRect convertFromScrollbarToContainingView(const Scrollbar&amp;, const IntRect&amp;) const override;
      IntRect convertFromContainingViewToScrollbar(const Scrollbar&amp;, const IntRect&amp;) const override;
      IntPoint convertFromScrollbarToContainingView(const Scrollbar&amp;, const IntPoint&amp;) const override;
      IntPoint convertFromContainingViewToScrollbar(const Scrollbar&amp;, const IntPoint&amp;) const override;
      void setScrollOffset(const ScrollOffset&amp;) override;
<span class="line-added">+     ScrollingNodeID scrollingNodeID() const override;</span>
  
      IntRect visibleContentRectInternal(VisibleContentRectIncludesScrollbars, VisibleContentRectBehavior) const override;
      IntSize overhangAmount() const override;
      IntPoint lastKnownMousePosition() const override;
      bool isHandlingWheelEvent() const override;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1066,12 ***</span>
  
      void dirtyAncestorChainVisibleDescendantStatus();
      void setAncestorChainHasVisibleDescendant();
  
      bool has3DTransformedDescendant() const { return m_has3DTransformedDescendant; }
<span class="line-removed">- </span>
<span class="line-removed">-     bool hasTransformedAncestor() const { return m_hasTransformedAncestor; }</span>
      bool has3DTransformedAncestor() const { return m_has3DTransformedAncestor; }
  
      void dirty3DTransformedDescendantStatus();
      // Both updates the status, and returns true if descendants of this have 3d.
      bool update3DTransformedDescendantStatus();
<span class="line-new-header">--- 1127,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1111,28 ***</span>
  
      void updatePagination();
  
      void setHasCompositingDescendant(bool b)  { m_hasCompositingDescendant = b; }
  
<span class="line-removed">-     enum class IndirectCompositingReason {</span>
<span class="line-removed">-         None,</span>
<span class="line-removed">-         Stacking,</span>
<span class="line-removed">-         Overlap,</span>
<span class="line-removed">-         BackgroundLayer,</span>
<span class="line-removed">-         GraphicalEffect, // opacity, mask, filter, transform etc.</span>
<span class="line-removed">-         Perspective,</span>
<span class="line-removed">-         Preserve3D</span>
<span class="line-removed">-     };</span>
<span class="line-removed">- </span>
      void setIndirectCompositingReason(IndirectCompositingReason reason) { m_indirectCompositingReason = static_cast&lt;unsigned&gt;(reason); }
<span class="line-removed">-     IndirectCompositingReason indirectCompositingReason() const { return static_cast&lt;IndirectCompositingReason&gt;(m_indirectCompositingReason); }</span>
      bool mustCompositeForIndirectReasons() const { return m_indirectCompositingReason; }
  
<span class="line-removed">-     friend class RenderLayerBacking;</span>
<span class="line-removed">-     friend class RenderLayerCompositor;</span>
<span class="line-removed">-     friend class RenderLayerModelObject;</span>
<span class="line-removed">- </span>
      LayoutUnit overflowTop() const;
      LayoutUnit overflowBottom() const;
      LayoutUnit overflowLeft() const;
      LayoutUnit overflowRight() const;
  
<span class="line-new-header">--- 1170,13 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1148,11 ***</span>
  
      const bool m_isRenderViewLayer : 1;
      const bool m_forcedStackingContext : 1;
  
      bool m_isNormalFlowOnly : 1;
<span class="line-modified">!     bool m_isStackingContext : 1;</span>
  
      bool m_zOrderListsDirty : 1;
      bool m_normalFlowListDirty: 1;
      bool m_hadNegativeZOrderList : 1;
  
<span class="line-new-header">--- 1192,12 ---</span>
  
      const bool m_isRenderViewLayer : 1;
      const bool m_forcedStackingContext : 1;
  
      bool m_isNormalFlowOnly : 1;
<span class="line-modified">!     bool m_isCSSStackingContext : 1;</span>
<span class="line-added">+     bool m_isOpportunisticStackingContext : 1;</span>
  
      bool m_zOrderListsDirty : 1;
      bool m_normalFlowListDirty: 1;
      bool m_hadNegativeZOrderList : 1;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1178,16 ***</span>
<span class="line-new-header">--- 1223,20 ---</span>
      bool m_hasVisibleContent : 1;
      bool m_visibleDescendantStatusDirty : 1;
      bool m_hasVisibleDescendant : 1;
      bool m_registeredScrollableArea : 1;
      bool m_isFixedIntersectingViewport : 1;
<span class="line-added">+     bool m_behavesAsFixed : 1;</span>
  
      bool m_3DTransformedDescendantStatusDirty : 1;
      bool m_has3DTransformedDescendant : 1;  // Set on a stacking context layer that has 3D descendants anywhere
                                              // in a preserves3D hierarchy. Hint to do 3D-aware hit testing.
      bool m_hasCompositingDescendant : 1; // In the z-order tree.
  
<span class="line-added">+     bool m_hasCompositedScrollingAncestor : 1; // In the layer-order tree.</span>
<span class="line-added">+     bool m_hasCompositedScrollableOverflow : 1;</span>
<span class="line-added">+ </span>
      bool m_hasTransformedAncestor : 1;
      bool m_has3DTransformedAncestor : 1;
  
      unsigned m_indirectCompositingReason : 3;
      unsigned m_viewportConstrainedNotCompositedReason : 2;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1197,11 ***</span>
      bool m_registeredAsTouchEventListenerForScrolling : 1;
  #endif
      bool m_adjustForIOSCaretWhenScrolling : 1;
  #endif
  
<span class="line-removed">-     bool m_inUserScroll : 1;</span>
      bool m_requiresScrollPositionReconciliation : 1;
      bool m_containsDirtyOverlayScrollbars : 1;
      bool m_updatingMarqueePosition : 1;
  
  #if !ASSERT_DISABLED
<span class="line-new-header">--- 1246,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1221,10 ***</span>
<span class="line-new-header">--- 1269,12 ---</span>
      RenderLayer* m_previous { nullptr };
      RenderLayer* m_next { nullptr };
      RenderLayer* m_first { nullptr };
      RenderLayer* m_last { nullptr };
  
<span class="line-added">+     WeakPtr&lt;RenderLayer&gt; m_backingProviderLayer;</span>
<span class="line-added">+ </span>
      // For layers that establish stacking contexts, m_posZOrderList holds a sorted list of all the
      // descendant layers within the stacking context that have z-indices of 0 or greater
      // (auto will count as 0). m_negZOrderList holds descendants within our stacking context with negative
      // z-indices.
      std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt; m_posZOrderList;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1333,11 ***</span>
<span class="line-new-header">--- 1383,14 ---</span>
  
  void makeMatrixRenderable(TransformationMatrix&amp;, bool has3DRendering);
  
  bool compositedWithOwnBackingStore(const RenderLayer&amp;);
  
<span class="line-added">+ WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, ClipRectsType);</span>
  WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, const RenderLayer&amp;);
<span class="line-added">+ WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, const RenderLayer::ClipRectsContext&amp;);</span>
<span class="line-added">+ WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, IndirectCompositingReason);</span>
  
  } // namespace WebCore
  
  #if ENABLE(TREE_DEBUGGING)
  // Outside the WebCore namespace for ease of invocation from lldb.
</pre>
<center><a href="RenderLayer.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderLayerBacking.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>