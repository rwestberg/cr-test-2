<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/inspector/InspectorCanvas.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="InspectorAuditDOMObject.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="InspectorCanvas.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/inspector/InspectorCanvas.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 55,21 ***</span>
  #include &quot;Path2D.h&quot;
  #include &quot;Pattern.h&quot;
  #include &quot;RecordingSwizzleTypes.h&quot;
  #include &quot;SVGPathUtilities.h&quot;
  #include &quot;StringAdaptors.h&quot;
  #if ENABLE(WEBGL)
  #include &quot;WebGLRenderingContext.h&quot;
  #endif
  #if ENABLE(WEBGL2)
  #include &quot;WebGL2RenderingContext.h&quot;
  #endif
<span class="line-modified">! #if ENABLE(WEBMETAL)</span>
<span class="line-modified">! #include &quot;WebMetalRenderingContext.h&quot;</span>
  #endif
  #include &lt;JavaScriptCore/IdentifiersFactory.h&gt;
  #include &lt;JavaScriptCore/ScriptCallStackFactory.h&gt;
  
  namespace WebCore {
  
  using namespace Inspector;
  
<span class="line-new-header">--- 55,25 ---</span>
  #include &quot;Path2D.h&quot;
  #include &quot;Pattern.h&quot;
  #include &quot;RecordingSwizzleTypes.h&quot;
  #include &quot;SVGPathUtilities.h&quot;
  #include &quot;StringAdaptors.h&quot;
<span class="line-added">+ #if ENABLE(CSS_TYPED_OM)</span>
<span class="line-added">+ #include &quot;TypedOMCSSImageValue.h&quot;</span>
<span class="line-added">+ #endif</span>
  #if ENABLE(WEBGL)
  #include &quot;WebGLRenderingContext.h&quot;
  #endif
  #if ENABLE(WEBGL2)
  #include &quot;WebGL2RenderingContext.h&quot;
  #endif
<span class="line-modified">! #if ENABLE(WEBGPU)</span>
<span class="line-modified">! #include &quot;GPUCanvasContext.h&quot;</span>
  #endif
  #include &lt;JavaScriptCore/IdentifiersFactory.h&gt;
  #include &lt;JavaScriptCore/ScriptCallStackFactory.h&gt;
<span class="line-added">+ #include &lt;wtf/Function.h&gt;</span>
  
  namespace WebCore {
  
  using namespace Inspector;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 84,29 ***</span>
  {
  }
  
  HTMLCanvasElement* InspectorCanvas::canvasElement()
  {
<span class="line-modified">!     auto* canvasBase = &amp;m_context.canvasBase();</span>
<span class="line-modified">!     if (is&lt;HTMLCanvasElement&gt;(canvasBase))</span>
<span class="line-removed">-         return downcast&lt;HTMLCanvasElement&gt;(canvasBase);</span>
      return nullptr;
  }
  
  void InspectorCanvas::resetRecordingData()
  {
      m_initialState = nullptr;
      m_frames = nullptr;
      m_currentActions = nullptr;
<span class="line-removed">-     m_actionNeedingSnapshot = nullptr;</span>
      m_serializedDuplicateData = nullptr;
      m_indexedDuplicateData.clear();
      m_recordingName = { };
      m_bufferLimit = 100 * 1024 * 1024;
      m_bufferUsed = 0;
      m_frameCount = WTF::nullopt;
      m_framesCaptured = 0;
  
      m_context.setCallTracingActive(false);
  }
  
  bool InspectorCanvas::hasRecordingData() const
<span class="line-new-header">--- 88,40 ---</span>
  {
  }
  
  HTMLCanvasElement* InspectorCanvas::canvasElement()
  {
<span class="line-modified">!     if (is&lt;HTMLCanvasElement&gt;(m_context.canvasBase()))</span>
<span class="line-modified">!         return &amp;downcast&lt;HTMLCanvasElement&gt;(m_context.canvasBase());</span>
      return nullptr;
  }
  
<span class="line-added">+ void InspectorCanvas::canvasChanged()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (!m_context.callTracingActive())</span>
<span class="line-added">+         return;</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Since 2D contexts are able to be fully reproduced in the frontend, we don&#39;t need snapshots.</span>
<span class="line-added">+     if (is&lt;CanvasRenderingContext2D&gt;(m_context))</span>
<span class="line-added">+         return;</span>
<span class="line-added">+ </span>
<span class="line-added">+     m_contentChanged = true;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void InspectorCanvas::resetRecordingData()
  {
      m_initialState = nullptr;
      m_frames = nullptr;
      m_currentActions = nullptr;
      m_serializedDuplicateData = nullptr;
      m_indexedDuplicateData.clear();
      m_recordingName = { };
      m_bufferLimit = 100 * 1024 * 1024;
      m_bufferUsed = 0;
      m_frameCount = WTF::nullopt;
      m_framesCaptured = 0;
<span class="line-added">+     m_contentChanged = false;</span>
  
      m_context.setCallTracingActive(false);
  }
  
  bool InspectorCanvas::hasRecordingData() const
</pre>
<hr />
<pre>
<span class="line-old-header">*** 122,20 ***</span>
  static bool shouldSnapshotBitmapRendererAction(const String&amp; name)
  {
      return name == &quot;transferFromImageBitmap&quot;;
  }
  
  static bool shouldSnapshotWebGLAction(const String&amp; name)
  {
      return name == &quot;clear&quot;
          || name == &quot;drawArrays&quot;
          || name == &quot;drawElements&quot;;
  }
  
<span class="line-modified">! void InspectorCanvas::recordAction(const String&amp; name, Vector&lt;RecordCanvasActionVariant&gt;&amp;&amp; parameters)</span>
  {
      if (!m_initialState) {
          m_initialState = buildInitialState();
          m_bufferUsed += m_initialState-&gt;memoryCost();
      }
  
      if (!m_frames)
<span class="line-new-header">--- 137,36 ---</span>
  static bool shouldSnapshotBitmapRendererAction(const String&amp; name)
  {
      return name == &quot;transferFromImageBitmap&quot;;
  }
  
<span class="line-added">+ #if ENABLE(WEBGL)</span>
  static bool shouldSnapshotWebGLAction(const String&amp; name)
  {
      return name == &quot;clear&quot;
          || name == &quot;drawArrays&quot;
          || name == &quot;drawElements&quot;;
  }
<span class="line-added">+ #endif</span>
  
<span class="line-modified">! #if ENABLE(WEBGL2)</span>
<span class="line-added">+ static bool shouldSnapshotWebGL2Action(const String&amp; name)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return name == &quot;clear&quot;</span>
<span class="line-added">+         || name == &quot;drawArrays&quot;</span>
<span class="line-added">+         || name == &quot;drawArraysInstanced&quot;</span>
<span class="line-added">+         || name == &quot;drawElements&quot;</span>
<span class="line-added">+         || name == &quot;drawElementsInstanced&quot;;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
<span class="line-added">+ void InspectorCanvas::recordAction(const String&amp; name, std::initializer_list&lt;RecordCanvasActionVariant&gt;&amp;&amp; parameters)</span>
  {
      if (!m_initialState) {
<span class="line-added">+         // We should only construct the initial state for the first action of the recording.</span>
<span class="line-added">+         ASSERT(!m_frames &amp;&amp; !m_currentActions);</span>
<span class="line-added">+ </span>
          m_initialState = buildInitialState();
          m_bufferUsed += m_initialState-&gt;memoryCost();
      }
  
      if (!m_frames)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 154,42 ***</span>
          m_currentFrameStartTime = MonotonicTime::now();
      }
  
      appendActionSnapshotIfNeeded();
  
<span class="line-modified">!     auto action = buildAction(name, WTFMove(parameters));</span>
<span class="line-modified">!     m_bufferUsed += action-&gt;memoryCost();</span>
<span class="line-modified">!     m_currentActions-&gt;addItem(action.ptr());</span>
  
      if (is&lt;ImageBitmapRenderingContext&gt;(m_context) &amp;&amp; shouldSnapshotBitmapRendererAction(name))
<span class="line-modified">!         m_actionNeedingSnapshot = WTFMove(action);</span>
  #if ENABLE(WEBGL)
      else if (is&lt;WebGLRenderingContext&gt;(m_context) &amp;&amp; shouldSnapshotWebGLAction(name))
<span class="line-modified">!         m_actionNeedingSnapshot = WTFMove(action);</span>
  #endif
  }
  
<span class="line-modified">! RefPtr&lt;Inspector::Protocol::Recording::InitialState&gt;&amp;&amp; InspectorCanvas::releaseInitialState()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     return WTFMove(m_initialState);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- RefPtr&lt;JSON::ArrayOf&lt;Inspector::Protocol::Recording::Frame&gt;&gt;&amp;&amp; InspectorCanvas::releaseFrames()</span>
  {
      appendActionSnapshotIfNeeded();
  
<span class="line-removed">-     return WTFMove(m_frames);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- RefPtr&lt;JSON::ArrayOf&lt;JSON::Value&gt;&gt;&amp;&amp; InspectorCanvas::releaseData()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     m_indexedDuplicateData.clear();</span>
<span class="line-removed">-     return WTFMove(m_serializedDuplicateData);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void InspectorCanvas::finalizeFrame()</span>
<span class="line-removed">- {</span>
      if (m_frames &amp;&amp; m_frames-&gt;length() &amp;&amp; !std::isnan(m_currentFrameStartTime)) {
          auto currentFrame = static_cast&lt;Inspector::Protocol::Recording::Frame*&gt;(m_frames-&gt;get(m_frames-&gt;length() - 1).get());
          currentFrame-&gt;setDuration((MonotonicTime::now() - m_currentFrameStartTime).milliseconds());
  
          m_currentFrameStartTime = MonotonicTime::nan();
<span class="line-new-header">--- 185,30 ---</span>
          m_currentFrameStartTime = MonotonicTime::now();
      }
  
      appendActionSnapshotIfNeeded();
  
<span class="line-modified">!     m_lastRecordedAction = buildAction(name, WTFMove(parameters));</span>
<span class="line-modified">!     m_bufferUsed += m_lastRecordedAction-&gt;memoryCost();</span>
<span class="line-modified">!     m_currentActions-&gt;addItem(m_lastRecordedAction.get());</span>
  
      if (is&lt;ImageBitmapRenderingContext&gt;(m_context) &amp;&amp; shouldSnapshotBitmapRendererAction(name))
<span class="line-modified">!         m_contentChanged = true;</span>
  #if ENABLE(WEBGL)
      else if (is&lt;WebGLRenderingContext&gt;(m_context) &amp;&amp; shouldSnapshotWebGLAction(name))
<span class="line-modified">!         m_contentChanged = true;</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ #if ENABLE(WEBGL2)</span>
<span class="line-added">+     else if (is&lt;WebGL2RenderingContext&gt;(m_context) &amp;&amp; shouldSnapshotWebGL2Action(name))</span>
<span class="line-added">+         m_contentChanged = true;</span>
  #endif
  }
  
<span class="line-modified">! void InspectorCanvas::finalizeFrame()</span>
  {
      appendActionSnapshotIfNeeded();
  
      if (m_frames &amp;&amp; m_frames-&gt;length() &amp;&amp; !std::isnan(m_currentFrameStartTime)) {
          auto currentFrame = static_cast&lt;Inspector::Protocol::Recording::Frame*&gt;(m_frames-&gt;get(m_frames-&gt;length() - 1).get());
          currentFrame-&gt;setDuration((MonotonicTime::now() - m_currentFrameStartTime).milliseconds());
  
          m_currentFrameStartTime = MonotonicTime::nan();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 242,13 ***</span>
  #endif
  #if ENABLE(WEBGL2)
      else if (is&lt;WebGL2RenderingContext&gt;(m_context))
          contextType = Inspector::Protocol::Canvas::ContextType::WebGL2;
  #endif
<span class="line-modified">! #if ENABLE(WEBMETAL)</span>
<span class="line-modified">!     else if (is&lt;WebMetalRenderingContext&gt;(m_context))</span>
<span class="line-modified">!         contextType = Inspector::Protocol::Canvas::ContextType::WebMetal;</span>
  #endif
      else {
          ASSERT_NOT_REACHED();
          contextType = Inspector::Protocol::Canvas::ContextType::Canvas2D;
      }
<span class="line-new-header">--- 261,13 ---</span>
  #endif
  #if ENABLE(WEBGL2)
      else if (is&lt;WebGL2RenderingContext&gt;(m_context))
          contextType = Inspector::Protocol::Canvas::ContextType::WebGL2;
  #endif
<span class="line-modified">! #if ENABLE(WEBGPU)</span>
<span class="line-modified">!     else if (is&lt;GPUCanvasContext&gt;(m_context))</span>
<span class="line-modified">!         contextType = Inspector::Protocol::Canvas::ContextType::WebGPU;</span>
  #endif
      else {
          ASSERT_NOT_REACHED();
          contextType = Inspector::Protocol::Canvas::ContextType::Canvas2D;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 302,26 ***</span>
      }
  
      return canvas;
  }
  
<span class="line-modified">! void InspectorCanvas::appendActionSnapshotIfNeeded()</span>
  {
<span class="line-modified">!     if (!m_actionNeedingSnapshot)</span>
<span class="line-modified">!         return;</span>
  
<span class="line-modified">!     m_actionNeedingSnapshot-&gt;addItem(indexForData(getCanvasContentAsDataURL()));</span>
<span class="line-modified">!     m_actionNeedingSnapshot = nullptr;</span>
  }
  
<span class="line-modified">! String InspectorCanvas::getCanvasContentAsDataURL()</span>
  {
<span class="line-modified">!     // FIXME: &lt;https://webkit.org/b/180833&gt; Web Inspector: support OffscreenCanvas for Canvas related operations</span>
  
      auto* node = canvasElement();
<span class="line-modified">!     if (!node)</span>
<span class="line-modified">!         return String();</span>
  
  #if ENABLE(WEBGL)
      if (is&lt;WebGLRenderingContextBase&gt;(m_context))
          downcast&lt;WebGLRenderingContextBase&gt;(m_context).setPreventBufferClearForInspector(true);
  #endif
<span class="line-new-header">--- 321,67 ---</span>
      }
  
      return canvas;
  }
  
<span class="line-modified">! Ref&lt;Inspector::Protocol::Recording::Recording&gt; InspectorCanvas::releaseObjectForRecording()</span>
  {
<span class="line-modified">!     ASSERT(!m_currentActions);</span>
<span class="line-modified">!     ASSERT(!m_lastRecordedAction);</span>
<span class="line-added">+     ASSERT(!m_frames);</span>
<span class="line-added">+ </span>
<span class="line-added">+     Inspector::Protocol::Recording::Type type;</span>
<span class="line-added">+     if (is&lt;CanvasRenderingContext2D&gt;(m_context))</span>
<span class="line-added">+         type = Inspector::Protocol::Recording::Type::Canvas2D;</span>
<span class="line-added">+     else if (is&lt;ImageBitmapRenderingContext&gt;(m_context))</span>
<span class="line-added">+         type = Inspector::Protocol::Recording::Type::CanvasBitmapRenderer;</span>
<span class="line-added">+ #if ENABLE(WEBGL)</span>
<span class="line-added">+     else if (is&lt;WebGLRenderingContext&gt;(m_context))</span>
<span class="line-added">+         type = Inspector::Protocol::Recording::Type::CanvasWebGL;</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ #if ENABLE(WEBGL2)</span>
<span class="line-added">+     else if (is&lt;WebGL2RenderingContext&gt;(m_context))</span>
<span class="line-added">+         type = Inspector::Protocol::Recording::Type::CanvasWebGL2;</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+     else {</span>
<span class="line-added">+         ASSERT_NOT_REACHED();</span>
<span class="line-added">+         type = Inspector::Protocol::Recording::Type::Canvas2D;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto recording = Inspector::Protocol::Recording::Recording::create()</span>
<span class="line-added">+         .setVersion(Inspector::Protocol::Recording::VERSION)</span>
<span class="line-added">+         .setType(type)</span>
<span class="line-added">+         .setInitialState(m_initialState.releaseNonNull())</span>
<span class="line-added">+         .setData(m_serializedDuplicateData.releaseNonNull())</span>
<span class="line-added">+         .release();</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (!m_recordingName.isEmpty())</span>
<span class="line-added">+         recording-&gt;setName(m_recordingName);</span>
  
<span class="line-modified">!     resetRecordingData();</span>
<span class="line-modified">! </span>
<span class="line-added">+     return recording;</span>
  }
  
<span class="line-modified">! String InspectorCanvas::getCanvasContentAsDataURL(ErrorString&amp; errorString)</span>
  {
<span class="line-modified">!     // FIXME: &lt;https://webkit.org/b/173621&gt; Web Inspector: Support getting the content of WebMetal context;</span>
<span class="line-added">+     if (!is&lt;CanvasRenderingContext2D&gt;(m_context)</span>
<span class="line-added">+ #if ENABLE(WEBGL)</span>
<span class="line-added">+         &amp;&amp; !is&lt;WebGLRenderingContextBase&gt;(m_context)</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+         &amp;&amp; !is&lt;ImageBitmapRenderingContext&gt;(m_context)) {</span>
<span class="line-added">+         errorString = &quot;Unsupported canvas context type&quot;_s;</span>
<span class="line-added">+         return emptyString();</span>
<span class="line-added">+     }</span>
  
<span class="line-added">+     // FIXME: &lt;https://webkit.org/b/180833&gt; Web Inspector: support OffscreenCanvas for Canvas related operations</span>
      auto* node = canvasElement();
<span class="line-modified">!     if (!node) {</span>
<span class="line-modified">!         errorString = &quot;Context isn&#39;t related to an HTMLCanvasElement&quot;_s;</span>
<span class="line-added">+         return emptyString();</span>
<span class="line-added">+     }</span>
  
  #if ENABLE(WEBGL)
      if (is&lt;WebGLRenderingContextBase&gt;(m_context))
          downcast&lt;WebGLRenderingContextBase&gt;(m_context).setPreventBufferClearForInspector(true);
  #endif
</pre>
<hr />
<pre>
<span class="line-old-header">*** 331,16 ***</span>
  #if ENABLE(WEBGL)
      if (is&lt;WebGLRenderingContextBase&gt;(m_context))
          downcast&lt;WebGLRenderingContextBase&gt;(m_context).setPreventBufferClearForInspector(false);
  #endif
  
<span class="line-modified">!     if (result.hasException())</span>
<span class="line-modified">!         return String();</span>
  
      return result.releaseReturnValue().string;
  }
  
  int InspectorCanvas::indexForData(DuplicateDataVariant data)
  {
      size_t index = m_indexedDuplicateData.findMatching([&amp;] (auto item) {
          if (data == item)
              return true;
<span class="line-new-header">--- 391,36 ---</span>
  #if ENABLE(WEBGL)
      if (is&lt;WebGLRenderingContextBase&gt;(m_context))
          downcast&lt;WebGLRenderingContextBase&gt;(m_context).setPreventBufferClearForInspector(false);
  #endif
  
<span class="line-modified">!     if (result.hasException()) {</span>
<span class="line-modified">!         errorString = result.releaseException().releaseMessage();</span>
<span class="line-added">+         return emptyString();</span>
<span class="line-added">+     }</span>
  
      return result.releaseReturnValue().string;
  }
  
<span class="line-added">+ void InspectorCanvas::appendActionSnapshotIfNeeded()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (!m_lastRecordedAction)</span>
<span class="line-added">+         return;</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (m_contentChanged) {</span>
<span class="line-added">+         m_bufferUsed -= m_lastRecordedAction-&gt;memoryCost();</span>
<span class="line-added">+ </span>
<span class="line-added">+         ErrorString ignored;</span>
<span class="line-added">+         m_lastRecordedAction-&gt;addItem(indexForData(getCanvasContentAsDataURL(ignored)));</span>
<span class="line-added">+ </span>
<span class="line-added">+         m_bufferUsed += m_lastRecordedAction-&gt;memoryCost();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     m_lastRecordedAction = nullptr;</span>
<span class="line-added">+     m_contentChanged = false;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  int InspectorCanvas::indexForData(DuplicateDataVariant data)
  {
      size_t index = m_indexedDuplicateData.findMatching([&amp;] (auto item) {
          if (data == item)
              return true;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 351,11 ***</span>
              return (*traceA)-&gt;isEqual((*traceB).get());
  
          return false;
      });
      if (index != notFound) {
<span class="line-modified">!         ASSERT(index &lt; std::numeric_limits&lt;int&gt;::max());</span>
          return static_cast&lt;int&gt;(index);
      }
  
      if (!m_serializedDuplicateData)
          m_serializedDuplicateData = JSON::ArrayOf&lt;JSON::Value&gt;::create();
<span class="line-new-header">--- 431,11 ---</span>
              return (*traceA)-&gt;isEqual((*traceB).get());
  
          return false;
      });
      if (index != notFound) {
<span class="line-modified">!         ASSERT(index &lt; static_cast&lt;size_t&gt;(std::numeric_limits&lt;int&gt;::max()));</span>
          return static_cast&lt;int&gt;(index);
      }
  
      if (!m_serializedDuplicateData)
          m_serializedDuplicateData = JSON::ArrayOf&lt;JSON::Value&gt;::create();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 410,10 ***</span>
<span class="line-new-header">--- 490,26 ---</span>
              auto array = JSON::ArrayOf&lt;double&gt;::create();
              for (size_t i = 0; i &lt; scriptCallStack-&gt;size(); ++i)
                  array-&gt;addItem(indexForData(scriptCallStack-&gt;at(i)));
              item = WTFMove(array);
          },
<span class="line-added">+ #if ENABLE(CSS_TYPED_OM)</span>
<span class="line-added">+         [&amp;] (const RefPtr&lt;TypedOMCSSImageValue&gt;&amp; cssImageValue) {</span>
<span class="line-added">+             String dataURL = &quot;data:,&quot;_s;</span>
<span class="line-added">+ </span>
<span class="line-added">+             if (auto* cachedImage = cssImageValue-&gt;image()) {</span>
<span class="line-added">+                 auto* image = cachedImage-&gt;image();</span>
<span class="line-added">+                 if (image &amp;&amp; image != &amp;Image::nullImage()) {</span>
<span class="line-added">+                     auto imageBuffer = ImageBuffer::create(image-&gt;size(), RenderingMode::Unaccelerated);</span>
<span class="line-added">+                     imageBuffer-&gt;context().drawImage(*image, FloatPoint(0, 0));</span>
<span class="line-added">+                     dataURL = imageBuffer-&gt;toDataURL(&quot;image/png&quot;);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
<span class="line-added">+             index = indexForData(dataURL);</span>
<span class="line-added">+         },</span>
<span class="line-added">+ #endif</span>
          [&amp;] (const ScriptCallFrame&amp; scriptCallFrame) {
              auto array = JSON::ArrayOf&lt;double&gt;::create();
              array-&gt;addItem(indexForData(scriptCallFrame.functionName()));
              array-&gt;addItem(indexForData(scriptCallFrame.sourceURL()));
              array-&gt;addItem(static_cast&lt;int&gt;(scriptCallFrame.lineNumber()));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 429,11 ***</span>
  
          m_indexedDuplicateData.append(data);
          index = m_indexedDuplicateData.size() - 1;
      }
  
<span class="line-modified">!     ASSERT(index &lt; std::numeric_limits&lt;int&gt;::max());</span>
      return static_cast&lt;int&gt;(index);
  }
  
  String InspectorCanvas::stringIndexForKey(const String&amp; key)
  {
<span class="line-new-header">--- 525,11 ---</span>
  
          m_indexedDuplicateData.append(data);
          index = m_indexedDuplicateData.size() - 1;
      }
  
<span class="line-modified">!     ASSERT(index &lt; static_cast&lt;size_t&gt;(std::numeric_limits&lt;int&gt;::max()));</span>
      return static_cast&lt;int&gt;(index);
  }
  
  String InspectorCanvas::stringIndexForKey(const String&amp; key)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 552,16 ***</span>
          initialStatePayload-&gt;setStates(WTFMove(statesPayload));
  
      if (parametersPayload-&gt;length())
          initialStatePayload-&gt;setParameters(WTFMove(parametersPayload));
  
<span class="line-modified">!     initialStatePayload-&gt;setContent(getCanvasContentAsDataURL());</span>
  
      return initialStatePayload;
  }
  
<span class="line-modified">! Ref&lt;JSON::ArrayOf&lt;JSON::Value&gt;&gt; InspectorCanvas::buildAction(const String&amp; name, Vector&lt;RecordCanvasActionVariant&gt;&amp;&amp; parameters)</span>
  {
      auto action = JSON::ArrayOf&lt;JSON::Value&gt;::create();
      action-&gt;addItem(indexForData(name));
  
      auto parametersData = JSON::ArrayOf&lt;JSON::Value&gt;::create();
<span class="line-new-header">--- 648,17 ---</span>
          initialStatePayload-&gt;setStates(WTFMove(statesPayload));
  
      if (parametersPayload-&gt;length())
          initialStatePayload-&gt;setParameters(WTFMove(parametersPayload));
  
<span class="line-modified">!     ErrorString ignored;</span>
<span class="line-added">+     initialStatePayload-&gt;setContent(getCanvasContentAsDataURL(ignored));</span>
  
      return initialStatePayload;
  }
  
<span class="line-modified">! Ref&lt;JSON::ArrayOf&lt;JSON::Value&gt;&gt; InspectorCanvas::buildAction(const String&amp; name, std::initializer_list&lt;RecordCanvasActionVariant&gt;&amp;&amp; parameters)</span>
  {
      auto action = JSON::ArrayOf&lt;JSON::Value&gt;::create();
      action-&gt;addItem(indexForData(name));
  
      auto parametersData = JSON::ArrayOf&lt;JSON::Value&gt;::create();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 570,77 ***</span>
      auto addParameter = [&amp;parametersData, &amp;swizzleTypes] (auto value, RecordingSwizzleTypes swizzleType) {
          parametersData-&gt;addItem(value);
          swizzleTypes-&gt;addItem(static_cast&lt;int&gt;(swizzleType));
      };
  
<span class="line-modified">!     for (auto&amp; item : parameters) {</span>
<span class="line-modified">!         WTF::switchOn(item,</span>
              [&amp;] (CanvasDirection value) { addParameter(indexForData(convertEnumerationToString(value)), RecordingSwizzleTypes::String); },
              [&amp;] (CanvasFillRule value) { addParameter(indexForData(convertEnumerationToString(value)), RecordingSwizzleTypes::String); },
              [&amp;] (CanvasLineCap value) { addParameter(indexForData(convertEnumerationToString(value)), RecordingSwizzleTypes::String); },
              [&amp;] (CanvasLineJoin value) { addParameter(indexForData(convertEnumerationToString(value)), RecordingSwizzleTypes::String); },
              [&amp;] (CanvasTextAlign value) { addParameter(indexForData(convertEnumerationToString(value)), RecordingSwizzleTypes::String); },
              [&amp;] (CanvasTextBaseline value) { addParameter(indexForData(convertEnumerationToString(value)), RecordingSwizzleTypes::String); },
              [&amp;] (const DOMMatrix2DInit&amp; value) {
                  auto array = JSON::ArrayOf&lt;double&gt;::create();
                  array-&gt;addItem(value.a.valueOr(1));
                  array-&gt;addItem(value.b.valueOr(0));
                  array-&gt;addItem(value.c.valueOr(0));
                  array-&gt;addItem(value.d.valueOr(1));
                  array-&gt;addItem(value.e.valueOr(0));
                  array-&gt;addItem(value.f.valueOr(0));
                  addParameter(array.ptr(), RecordingSwizzleTypes::DOMMatrix);
              },
<span class="line-modified">!             [&amp;] (const Element*) {</span>
<span class="line-modified">!                 // Elements are not serializable, so add a string as a placeholder since the actual</span>
<span class="line-modified">!                 // element cannot be reconstructed in the frontend.</span>
<span class="line-modified">!                 addParameter(indexForData(&quot;Element&quot;), RecordingSwizzleTypes::None);</span>
              },
<span class="line-modified">!             [&amp;] (HTMLImageElement* value) { addParameter(indexForData(value), RecordingSwizzleTypes::Image); },</span>
<span class="line-modified">!             [&amp;] (ImageBitmap* value) { addParameter(indexForData(value), RecordingSwizzleTypes::ImageBitmap); },</span>
<span class="line-modified">!             [&amp;] (ImageData* value) { addParameter(indexForData(value), RecordingSwizzleTypes::ImageData); },</span>
<span class="line-modified">!             [&amp;] (ImageSmoothingQuality value) { addParameter(indexForData(convertEnumerationToString(value)), RecordingSwizzleTypes::String); },</span>
<span class="line-modified">!             [&amp;] (const Path2D* value) { addParameter(indexForData(buildStringFromPath(value-&gt;path())), RecordingSwizzleTypes::Path2D); },</span>
  #if ENABLE(WEBGL)
              // FIXME: &lt;https://webkit.org/b/176009&gt; Web Inspector: send data for WebGL objects during a recording instead of a placeholder string
<span class="line-modified">!             [&amp;] (const WebGLBuffer*) { addParameter(0, RecordingSwizzleTypes::WebGLBuffer); },</span>
<span class="line-modified">!             [&amp;] (const WebGLFramebuffer*) { addParameter(0, RecordingSwizzleTypes::WebGLFramebuffer); },</span>
<span class="line-modified">!             [&amp;] (const WebGLProgram*) { addParameter(0, RecordingSwizzleTypes::WebGLProgram); },</span>
<span class="line-modified">!             [&amp;] (const WebGLRenderbuffer*) { addParameter(0, RecordingSwizzleTypes::WebGLRenderbuffer); },</span>
<span class="line-modified">!             [&amp;] (const WebGLShader*) { addParameter(0, RecordingSwizzleTypes::WebGLShader); },</span>
<span class="line-modified">!             [&amp;] (const WebGLTexture*) { addParameter(0, RecordingSwizzleTypes::WebGLTexture); },</span>
<span class="line-modified">!             [&amp;] (const WebGLUniformLocation*) { addParameter(0, RecordingSwizzleTypes::WebGLUniformLocation); },</span>
  #endif
<span class="line-modified">!             [&amp;] (const RefPtr&lt;ArrayBuffer&gt;&amp;) { addParameter(0, RecordingSwizzleTypes::TypedArray); },</span>
<span class="line-modified">!             [&amp;] (const RefPtr&lt;ArrayBufferView&gt;&amp;) { addParameter(0, RecordingSwizzleTypes::TypedArray); },</span>
<span class="line-modified">!             [&amp;] (const RefPtr&lt;CanvasGradient&gt;&amp; value) { addParameter(indexForData(value), RecordingSwizzleTypes::CanvasGradient); },</span>
<span class="line-modified">!             [&amp;] (const RefPtr&lt;CanvasPattern&gt;&amp; value) { addParameter(indexForData(value), RecordingSwizzleTypes::CanvasPattern); },</span>
<span class="line-modified">!             [&amp;] (const RefPtr&lt;Float32Array&gt;&amp;) { addParameter(0, RecordingSwizzleTypes::TypedArray); },</span>
<span class="line-modified">!             [&amp;] (const RefPtr&lt;HTMLCanvasElement&gt;&amp; value) { addParameter(indexForData(value), RecordingSwizzleTypes::Image); },</span>
<span class="line-modified">!             [&amp;] (const RefPtr&lt;HTMLImageElement&gt;&amp; value) { addParameter(indexForData(value), RecordingSwizzleTypes::Image); },</span>
  #if ENABLE(VIDEO)
<span class="line-modified">!             [&amp;] (const RefPtr&lt;HTMLVideoElement&gt;&amp; value) { addParameter(indexForData(value), RecordingSwizzleTypes::Image); },</span>
  #endif
  #if ENABLE(CSS_TYPED_OM)
<span class="line-modified">!             // FIXME implement: &lt;https://bugs.webkit.org/show_bug.cgi?id=192609&gt;.</span>
<span class="line-modified">!             [&amp;] (const RefPtr&lt;TypedOMCSSImageValue&gt;&amp;) { },</span>
  #endif
<span class="line-modified">!             [&amp;] (const RefPtr&lt;ImageBitmap&gt;&amp; value) { addParameter(indexForData(value), RecordingSwizzleTypes::ImageBitmap); },</span>
<span class="line-modified">!             [&amp;] (const RefPtr&lt;ImageData&gt;&amp; value) { addParameter(indexForData(value), RecordingSwizzleTypes::ImageData); },</span>
<span class="line-modified">!             [&amp;] (const RefPtr&lt;Int32Array&gt;&amp;) { addParameter(0, RecordingSwizzleTypes::TypedArray); },</span>
              [&amp;] (const Vector&lt;float&gt;&amp; value) { addParameter(buildArrayForVector(value).ptr(), RecordingSwizzleTypes::Array); },
<span class="line-modified">!             [&amp;] (const Vector&lt;int&gt;&amp; value) { addParameter(buildArrayForVector(value).ptr(), RecordingSwizzleTypes::Array); },</span>
              [&amp;] (const String&amp; value) { addParameter(indexForData(value), RecordingSwizzleTypes::String); },
              [&amp;] (double value) { addParameter(value, RecordingSwizzleTypes::Number); },
              [&amp;] (float value) { addParameter(value, RecordingSwizzleTypes::Number); },
              [&amp;] (int64_t value) { addParameter(static_cast&lt;double&gt;(value), RecordingSwizzleTypes::Number); },
              [&amp;] (uint32_t value) { addParameter(static_cast&lt;double&gt;(value), RecordingSwizzleTypes::Number); },
              [&amp;] (int32_t value) { addParameter(value, RecordingSwizzleTypes::Number); },
              [&amp;] (uint8_t value) { addParameter(static_cast&lt;int&gt;(value), RecordingSwizzleTypes::Number); },
              [&amp;] (bool value) { addParameter(value, RecordingSwizzleTypes::Boolean); }
          );
<span class="line-modified">!     }</span>
  
      action-&gt;addItem(WTFMove(parametersData));
      action-&gt;addItem(WTFMove(swizzleTypes));
  
      auto trace = Inspector::createScriptCallStack(JSExecState::currentState(), Inspector::ScriptCallStack::maxCallStackSizeToCapture);
<span class="line-new-header">--- 667,223 ---</span>
      auto addParameter = [&amp;parametersData, &amp;swizzleTypes] (auto value, RecordingSwizzleTypes swizzleType) {
          parametersData-&gt;addItem(value);
          swizzleTypes-&gt;addItem(static_cast&lt;int&gt;(swizzleType));
      };
  
<span class="line-modified">!     // Declared before it&#39;s initialized so it can be used recursively.</span>
<span class="line-modified">!     Function&lt;void(const RecordCanvasActionVariant&amp;)&gt; parseParameter;</span>
<span class="line-added">+     parseParameter = [&amp;] (const auto&amp; parameter) {</span>
<span class="line-added">+         WTF::switchOn(parameter,</span>
              [&amp;] (CanvasDirection value) { addParameter(indexForData(convertEnumerationToString(value)), RecordingSwizzleTypes::String); },
              [&amp;] (CanvasFillRule value) { addParameter(indexForData(convertEnumerationToString(value)), RecordingSwizzleTypes::String); },
              [&amp;] (CanvasLineCap value) { addParameter(indexForData(convertEnumerationToString(value)), RecordingSwizzleTypes::String); },
              [&amp;] (CanvasLineJoin value) { addParameter(indexForData(convertEnumerationToString(value)), RecordingSwizzleTypes::String); },
              [&amp;] (CanvasTextAlign value) { addParameter(indexForData(convertEnumerationToString(value)), RecordingSwizzleTypes::String); },
              [&amp;] (CanvasTextBaseline value) { addParameter(indexForData(convertEnumerationToString(value)), RecordingSwizzleTypes::String); },
<span class="line-added">+             [&amp;] (ImageSmoothingQuality value) { addParameter(indexForData(convertEnumerationToString(value)), RecordingSwizzleTypes::String); },</span>
              [&amp;] (const DOMMatrix2DInit&amp; value) {
                  auto array = JSON::ArrayOf&lt;double&gt;::create();
                  array-&gt;addItem(value.a.valueOr(1));
                  array-&gt;addItem(value.b.valueOr(0));
                  array-&gt;addItem(value.c.valueOr(0));
                  array-&gt;addItem(value.d.valueOr(1));
                  array-&gt;addItem(value.e.valueOr(0));
                  array-&gt;addItem(value.f.valueOr(0));
                  addParameter(array.ptr(), RecordingSwizzleTypes::DOMMatrix);
              },
<span class="line-modified">!             [&amp;] (const Element* value) {</span>
<span class="line-modified">!                 if (value) {</span>
<span class="line-modified">!                     // Elements are not serializable, so add a string as a placeholder since the actual</span>
<span class="line-modified">!                     // element cannot be reconstructed in the frontend.</span>
<span class="line-added">+                     addParameter(indexForData(&quot;Element&quot;), RecordingSwizzleTypes::None);</span>
<span class="line-added">+                 }</span>
              },
<span class="line-modified">!             [&amp;] (HTMLImageElement* value) {</span>
<span class="line-modified">!                 if (value)</span>
<span class="line-modified">!                     addParameter(indexForData(value), RecordingSwizzleTypes::Image); },</span>
<span class="line-modified">!             [&amp;] (ImageBitmap* value) {</span>
<span class="line-modified">!                 if (value)</span>
<span class="line-added">+                     addParameter(indexForData(value), RecordingSwizzleTypes::ImageBitmap); },</span>
<span class="line-added">+             [&amp;] (ImageData* value) {</span>
<span class="line-added">+                 if (value)</span>
<span class="line-added">+                     addParameter(indexForData(value), RecordingSwizzleTypes::ImageData); },</span>
<span class="line-added">+             [&amp;] (const Path2D* value) {</span>
<span class="line-added">+                 if (value)</span>
<span class="line-added">+                     addParameter(indexForData(buildStringFromPath(value-&gt;path())), RecordingSwizzleTypes::Path2D); },</span>
  #if ENABLE(WEBGL)
              // FIXME: &lt;https://webkit.org/b/176009&gt; Web Inspector: send data for WebGL objects during a recording instead of a placeholder string
<span class="line-modified">!             [&amp;] (const WebGLBuffer* value) {</span>
<span class="line-modified">!                 if (value)</span>
<span class="line-modified">!                     addParameter(0, RecordingSwizzleTypes::WebGLBuffer);</span>
<span class="line-modified">!             },</span>
<span class="line-modified">!             [&amp;] (const WebGLFramebuffer* value) {</span>
<span class="line-modified">!                 if (value)</span>
<span class="line-modified">!                     addParameter(0, RecordingSwizzleTypes::WebGLFramebuffer);</span>
<span class="line-added">+             },</span>
<span class="line-added">+             [&amp;] (const WebGLProgram* value) {</span>
<span class="line-added">+                 if (value)</span>
<span class="line-added">+                     addParameter(0, RecordingSwizzleTypes::WebGLProgram);</span>
<span class="line-added">+             },</span>
<span class="line-added">+             [&amp;] (const WebGLQuery* value) {</span>
<span class="line-added">+                 if (value)</span>
<span class="line-added">+                     addParameter(0, RecordingSwizzleTypes::WebGLQuery);</span>
<span class="line-added">+             },</span>
<span class="line-added">+             [&amp;] (const WebGLRenderbuffer* value) {</span>
<span class="line-added">+                 if (value)</span>
<span class="line-added">+                     addParameter(0, RecordingSwizzleTypes::WebGLRenderbuffer);</span>
<span class="line-added">+             },</span>
<span class="line-added">+             [&amp;] (const WebGLSampler* value) {</span>
<span class="line-added">+                 if (value)</span>
<span class="line-added">+                     addParameter(0, RecordingSwizzleTypes::WebGLSampler);</span>
<span class="line-added">+             },</span>
<span class="line-added">+             [&amp;] (const WebGLShader* value) {</span>
<span class="line-added">+                 if (value)</span>
<span class="line-added">+                     addParameter(0, RecordingSwizzleTypes::WebGLShader);</span>
<span class="line-added">+             },</span>
<span class="line-added">+             [&amp;] (const WebGLSync* value) {</span>
<span class="line-added">+                 if (value)</span>
<span class="line-added">+                     addParameter(0, RecordingSwizzleTypes::WebGLSync);</span>
<span class="line-added">+             },</span>
<span class="line-added">+             [&amp;] (const WebGLTexture* value) {</span>
<span class="line-added">+                 if (value)</span>
<span class="line-added">+                     addParameter(0, RecordingSwizzleTypes::WebGLTexture);</span>
<span class="line-added">+             },</span>
<span class="line-added">+             [&amp;] (const WebGLTransformFeedback* value) {</span>
<span class="line-added">+                 if (value)</span>
<span class="line-added">+                     addParameter(0, RecordingSwizzleTypes::WebGLTransformFeedback);</span>
<span class="line-added">+             },</span>
<span class="line-added">+             [&amp;] (const WebGLUniformLocation* value) {</span>
<span class="line-added">+                 if (value)</span>
<span class="line-added">+                     addParameter(0, RecordingSwizzleTypes::WebGLUniformLocation);</span>
<span class="line-added">+             },</span>
<span class="line-added">+             [&amp;] (const WebGLVertexArrayObject* value) {</span>
<span class="line-added">+                 if (value)</span>
<span class="line-added">+                     addParameter(0, RecordingSwizzleTypes::WebGLVertexArrayObject);</span>
<span class="line-added">+             },</span>
  #endif
<span class="line-modified">!             [&amp;] (const RefPtr&lt;ArrayBuffer&gt;&amp; value) {</span>
<span class="line-modified">!                 if (value)</span>
<span class="line-modified">!                     addParameter(0, RecordingSwizzleTypes::TypedArray);</span>
<span class="line-modified">!             },</span>
<span class="line-modified">!             [&amp;] (const RefPtr&lt;ArrayBufferView&gt;&amp; value) {</span>
<span class="line-modified">!                 if (value)</span>
<span class="line-modified">!                     addParameter(0, RecordingSwizzleTypes::TypedArray);</span>
<span class="line-added">+             },</span>
<span class="line-added">+             [&amp;] (const RefPtr&lt;CanvasGradient&gt;&amp; value) {</span>
<span class="line-added">+                 if (value)</span>
<span class="line-added">+                     addParameter(indexForData(value), RecordingSwizzleTypes::CanvasGradient);</span>
<span class="line-added">+             },</span>
<span class="line-added">+             [&amp;] (const RefPtr&lt;CanvasPattern&gt;&amp; value) {</span>
<span class="line-added">+                 if (value)</span>
<span class="line-added">+                     addParameter(indexForData(value), RecordingSwizzleTypes::CanvasPattern);</span>
<span class="line-added">+             },</span>
<span class="line-added">+             [&amp;] (const RefPtr&lt;Float32Array&gt;&amp; value) {</span>
<span class="line-added">+                 if (value)</span>
<span class="line-added">+                     addParameter(0, RecordingSwizzleTypes::TypedArray);</span>
<span class="line-added">+             },</span>
<span class="line-added">+             [&amp;] (const RefPtr&lt;HTMLCanvasElement&gt;&amp; value) {</span>
<span class="line-added">+                 if (value)</span>
<span class="line-added">+                     addParameter(indexForData(value), RecordingSwizzleTypes::Image);</span>
<span class="line-added">+             },</span>
<span class="line-added">+             [&amp;] (const RefPtr&lt;HTMLImageElement&gt;&amp; value) {</span>
<span class="line-added">+                 if (value)</span>
<span class="line-added">+                     addParameter(indexForData(value), RecordingSwizzleTypes::Image);</span>
<span class="line-added">+             },</span>
  #if ENABLE(VIDEO)
<span class="line-modified">!             [&amp;] (const RefPtr&lt;HTMLVideoElement&gt;&amp; value) {</span>
<span class="line-added">+                 if (value)</span>
<span class="line-added">+                     addParameter(indexForData(value), RecordingSwizzleTypes::Image);</span>
<span class="line-added">+             },</span>
  #endif
  #if ENABLE(CSS_TYPED_OM)
<span class="line-modified">!             [&amp;] (const RefPtr&lt;TypedOMCSSImageValue&gt;&amp; value) {</span>
<span class="line-modified">!                 if (value)</span>
<span class="line-added">+                     addParameter(indexForData(value), RecordingSwizzleTypes::Image);</span>
<span class="line-added">+             },</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+             [&amp;] (const RefPtr&lt;ImageBitmap&gt;&amp; value) {</span>
<span class="line-added">+                 if (value)</span>
<span class="line-added">+                     addParameter(indexForData(value), RecordingSwizzleTypes::ImageBitmap);</span>
<span class="line-added">+             },</span>
<span class="line-added">+             [&amp;] (const RefPtr&lt;ImageData&gt;&amp; value) {</span>
<span class="line-added">+                 if (value)</span>
<span class="line-added">+                     addParameter(indexForData(value), RecordingSwizzleTypes::ImageData);</span>
<span class="line-added">+             },</span>
<span class="line-added">+             [&amp;] (const RefPtr&lt;Int32Array&gt;&amp; value) {</span>
<span class="line-added">+                 if (value)</span>
<span class="line-added">+                     addParameter(0, RecordingSwizzleTypes::TypedArray);</span>
<span class="line-added">+             },</span>
<span class="line-added">+             [&amp;] (const RefPtr&lt;Uint32Array&gt;&amp; value) {</span>
<span class="line-added">+                 if (value)</span>
<span class="line-added">+                     addParameter(0, RecordingSwizzleTypes::TypedArray);</span>
<span class="line-added">+             },</span>
<span class="line-added">+             [&amp;] (const CanvasImageSource&amp; value) {</span>
<span class="line-added">+                 WTF::visit(parseParameter, value);</span>
<span class="line-added">+             },</span>
<span class="line-added">+             [&amp;] (const CanvasRenderingContext2DBase::Style&amp; value) {</span>
<span class="line-added">+                 WTF::visit(parseParameter, value);</span>
<span class="line-added">+             },</span>
<span class="line-added">+ #if ENABLE(WEBGL)</span>
<span class="line-added">+             [&amp;] (const WebGLRenderingContextBase::BufferDataSource&amp; value) {</span>
<span class="line-added">+                 WTF::visit(parseParameter, value);</span>
<span class="line-added">+             },</span>
<span class="line-added">+             [&amp;] (const Optional&lt;WebGLRenderingContextBase::BufferDataSource&gt;&amp; value) {</span>
<span class="line-added">+                 if (value)</span>
<span class="line-added">+                     parseParameter(value.value());</span>
<span class="line-added">+             },</span>
<span class="line-added">+             [&amp;] (const WebGLRenderingContextBase::TexImageSource&amp; value) {</span>
<span class="line-added">+                 WTF::visit(parseParameter, value);</span>
<span class="line-added">+             },</span>
<span class="line-added">+             [&amp;] (const Optional&lt;WebGLRenderingContextBase::TexImageSource&gt;&amp; value) {</span>
<span class="line-added">+                 if (value)</span>
<span class="line-added">+                     parseParameter(value.value());</span>
<span class="line-added">+             },</span>
  #endif
<span class="line-modified">!             [&amp;] (const Vector&lt;String&gt;&amp; value) {</span>
<span class="line-modified">!                 auto deduplicated = value.map([&amp;] (const String&amp; item) {</span>
<span class="line-modified">!                     return indexForData(item);</span>
<span class="line-added">+                 });</span>
<span class="line-added">+                 addParameter(buildArrayForVector(deduplicated).ptr(), RecordingSwizzleTypes::String);</span>
<span class="line-added">+             },</span>
              [&amp;] (const Vector&lt;float&gt;&amp; value) { addParameter(buildArrayForVector(value).ptr(), RecordingSwizzleTypes::Array); },
<span class="line-modified">!             [&amp;] (const Vector&lt;uint32_t&gt;&amp; value) {</span>
<span class="line-added">+                 auto mapped = value.map([&amp;] (uint32_t item) {</span>
<span class="line-added">+                     return static_cast&lt;double&gt;(item);</span>
<span class="line-added">+                 });</span>
<span class="line-added">+                 addParameter(buildArrayForVector(mapped).ptr(), RecordingSwizzleTypes::Array);</span>
<span class="line-added">+             },</span>
<span class="line-added">+             [&amp;] (const Vector&lt;int32_t&gt;&amp; value) { addParameter(buildArrayForVector(value).ptr(), RecordingSwizzleTypes::Array); },</span>
<span class="line-added">+ #if ENABLE(WEBGL)</span>
<span class="line-added">+             [&amp;] (const WebGLRenderingContextBase::Float32List::VariantType&amp; value) {</span>
<span class="line-added">+                 WTF::visit(parseParameter, value);</span>
<span class="line-added">+             },</span>
<span class="line-added">+             [&amp;] (const WebGLRenderingContextBase::Int32List::VariantType&amp; value) {</span>
<span class="line-added">+                 WTF::visit(parseParameter, value);</span>
<span class="line-added">+             },</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ #if ENABLE(WEBGL2)</span>
<span class="line-added">+             [&amp;] (const WebGL2RenderingContext::Uint32List::VariantType&amp; value) {</span>
<span class="line-added">+                 WTF::visit(parseParameter, value);</span>
<span class="line-added">+             },</span>
<span class="line-added">+ #endif</span>
              [&amp;] (const String&amp; value) { addParameter(indexForData(value), RecordingSwizzleTypes::String); },
              [&amp;] (double value) { addParameter(value, RecordingSwizzleTypes::Number); },
              [&amp;] (float value) { addParameter(value, RecordingSwizzleTypes::Number); },
<span class="line-added">+             [&amp;] (const Optional&lt;float&gt;&amp; value) {</span>
<span class="line-added">+                 if (value)</span>
<span class="line-added">+                     parseParameter(value.value());</span>
<span class="line-added">+             },</span>
<span class="line-added">+             [&amp;] (uint64_t value) { addParameter(static_cast&lt;double&gt;(value), RecordingSwizzleTypes::Number); },</span>
              [&amp;] (int64_t value) { addParameter(static_cast&lt;double&gt;(value), RecordingSwizzleTypes::Number); },
              [&amp;] (uint32_t value) { addParameter(static_cast&lt;double&gt;(value), RecordingSwizzleTypes::Number); },
              [&amp;] (int32_t value) { addParameter(value, RecordingSwizzleTypes::Number); },
              [&amp;] (uint8_t value) { addParameter(static_cast&lt;int&gt;(value), RecordingSwizzleTypes::Number); },
              [&amp;] (bool value) { addParameter(value, RecordingSwizzleTypes::Boolean); }
          );
<span class="line-modified">!     };</span>
<span class="line-added">+     for (auto&amp; parameter : parameters)</span>
<span class="line-added">+         parseParameter(parameter);</span>
  
      action-&gt;addItem(WTFMove(parametersData));
      action-&gt;addItem(WTFMove(swizzleTypes));
  
      auto trace = Inspector::createScriptCallStack(JSExecState::currentState(), Inspector::ScriptCallStack::maxCallStackSizeToCapture);
</pre>
<center><a href="InspectorAuditDOMObject.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="InspectorCanvas.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>