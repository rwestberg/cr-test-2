<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/inspector/InspectorOverlay.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2011 Google Inc. All rights reserved.
<a name="1" id="anc1"></a><span class="line-added">   3  * Copyright (C) 2019 Apple Inc. All rights reserved.</span>
   4  *
   5  * Redistribution and use in source and binary forms, with or without
   6  * modification, are permitted provided that the following conditions
   7  * are met:
   8  *
   9  * 1.  Redistributions of source code must retain the above copyright
  10  *     notice, this list of conditions and the following disclaimer.
  11  * 2.  Redistributions in binary form must reproduce the above copyright
  12  *     notice, this list of conditions and the following disclaimer in the
  13  *     documentation and/or other materials provided with the distribution.
  14  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
  15  *     its contributors may be used to endorse or promote products derived
  16  *     from this software without specific prior written permission.
  17  *
  18  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
  19  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  20  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  21  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  22  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  23  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  24  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  25  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  26  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  27  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  28  */
  29 
  30 #include &quot;config.h&quot;
  31 #include &quot;InspectorOverlay.h&quot;
  32 
<a name="2" id="anc2"></a><span class="line-modified">  33 #include &quot;AXObjectCache.h&quot;</span>
<span class="line-modified">  34 #include &quot;AccessibilityObject.h&quot;</span>
<span class="line-modified">  35 #include &quot;DOMCSSNamespace.h&quot;</span>
<span class="line-added">  36 #include &quot;DOMTokenList.h&quot;</span>
  37 #include &quot;Element.h&quot;
<a name="3" id="anc3"></a><span class="line-modified">  38 #include &quot;FloatPoint.h&quot;</span>
<span class="line-added">  39 #include &quot;FloatRoundedRect.h&quot;</span>
<span class="line-added">  40 #include &quot;FloatSize.h&quot;</span>
<span class="line-added">  41 #include &quot;FontCascade.h&quot;</span>
<span class="line-added">  42 #include &quot;FontCascadeDescription.h&quot;</span>
  43 #include &quot;Frame.h&quot;
  44 #include &quot;FrameView.h&quot;
  45 #include &quot;GraphicsContext.h&quot;
  46 #include &quot;InspectorClient.h&quot;
<a name="4" id="anc4"></a><span class="line-modified">  47 #include &quot;IntPoint.h&quot;</span>
<span class="line-modified">  48 #include &quot;IntRect.h&quot;</span>
<span class="line-added">  49 #include &quot;IntSize.h&quot;</span>
  50 #include &quot;Node.h&quot;
<a name="5" id="anc5"></a><span class="line-added">  51 #include &quot;NodeList.h&quot;</span>
  52 #include &quot;Page.h&quot;
<a name="6" id="anc6"></a>

  53 #include &quot;PseudoElement.h&quot;
<a name="7" id="anc7"></a><span class="line-modified">  54 #include &quot;RenderBox.h&quot;</span>

  55 #include &quot;RenderBoxModelObject.h&quot;
<a name="8" id="anc8"></a>
  56 #include &quot;RenderInline.h&quot;
<a name="9" id="anc9"></a><span class="line-modified">  57 #include &quot;RenderObject.h&quot;</span>


  58 #include &quot;Settings.h&quot;
<a name="10" id="anc10"></a><span class="line-modified">  59 #include &lt;wtf/MathExtras.h&gt;</span>
<span class="line-modified">  60 #include &lt;wtf/text/StringBuilder.h&gt;</span>






  61 
  62 namespace WebCore {
  63 
  64 using namespace Inspector;
  65 
<a name="11" id="anc11"></a><span class="line-added">  66 static constexpr float elementDataSpacing = 2;</span>
<span class="line-added">  67 static constexpr float elementDataArrowSize = 7;</span>
<span class="line-added">  68 static constexpr float elementDataBorderSize = 1;</span>
<span class="line-added">  69 </span>
<span class="line-added">  70 static constexpr float rulerSize = 15;</span>
<span class="line-added">  71 static constexpr float rulerLabelSize = 13;</span>
<span class="line-added">  72 static constexpr float rulerStepIncrement = 50;</span>
<span class="line-added">  73 static constexpr float rulerStepLength = 8;</span>
<span class="line-added">  74 static constexpr float rulerSubStepIncrement = 5;</span>
<span class="line-added">  75 static constexpr float rulerSubStepLength = 5;</span>
<span class="line-added">  76 </span>
<span class="line-added">  77 static constexpr UChar ellipsis = 0x2026;</span>
<span class="line-added">  78 static constexpr UChar multiplicationSign = 0x00D7;</span>
<span class="line-added">  79 </span>
<span class="line-added">  80 static void truncateWithEllipsis(String&amp; string, size_t length)</span>
<span class="line-added">  81 {</span>
<span class="line-added">  82     if (string.length() &gt; length) {</span>
<span class="line-added">  83         string.truncate(length);</span>
<span class="line-added">  84         string.append(ellipsis);</span>
<span class="line-added">  85     }</span>
<span class="line-added">  86 }</span>
<span class="line-added">  87 </span>
<span class="line-added">  88 static FloatPoint localPointToRootPoint(const FrameView* view, const FloatPoint&amp; point)</span>
<span class="line-added">  89 {</span>
<span class="line-added">  90     return view-&gt;contentsToRootView(roundedIntPoint(point));</span>
<span class="line-added">  91 }</span>
<span class="line-added">  92 </span>
  93 static void contentsQuadToCoordinateSystem(const FrameView* mainView, const FrameView* view, FloatQuad&amp; quad, InspectorOverlay::CoordinateSystem coordinateSystem)
  94 {
<a name="12" id="anc12"></a><span class="line-modified">  95     quad.setP1(localPointToRootPoint(view, quad.p1()));</span>
<span class="line-modified">  96     quad.setP2(localPointToRootPoint(view, quad.p2()));</span>
<span class="line-modified">  97     quad.setP3(localPointToRootPoint(view, quad.p3()));</span>
<span class="line-modified">  98     quad.setP4(localPointToRootPoint(view, quad.p4()));</span>
  99 
 100     if (coordinateSystem == InspectorOverlay::CoordinateSystem::View)
 101         quad += toIntSize(mainView-&gt;scrollPosition());
 102 }
 103 
<a name="13" id="anc13"></a><span class="line-modified"> 104 static Element* effectiveElementForNode(Node&amp; node)</span>
 105 {
<a name="14" id="anc14"></a><span class="line-modified"> 106     if (!is&lt;Element&gt;(node) || !node.document().frame())</span>
<span class="line-added"> 107         return nullptr;</span>
<span class="line-added"> 108 </span>
<span class="line-added"> 109     Element* element = nullptr;</span>
<span class="line-added"> 110     if (is&lt;PseudoElement&gt;(node)) {</span>
<span class="line-added"> 111         if (Element* hostElement = downcast&lt;PseudoElement&gt;(node).hostElement())</span>
<span class="line-added"> 112             element = hostElement;</span>
<span class="line-added"> 113     } else</span>
<span class="line-added"> 114         element = &amp;downcast&lt;Element&gt;(node);</span>
<span class="line-added"> 115 </span>
<span class="line-added"> 116     return element;</span>
 117 }
 118 
 119 static void buildRendererHighlight(RenderObject* renderer, const HighlightConfig&amp; highlightConfig, Highlight&amp; highlight, InspectorOverlay::CoordinateSystem coordinateSystem)
 120 {
 121     Frame* containingFrame = renderer-&gt;document().frame();
 122     if (!containingFrame)
 123         return;
 124 
 125     highlight.setDataFromConfig(highlightConfig);
 126     FrameView* containingView = containingFrame-&gt;view();
 127     FrameView* mainView = containingFrame-&gt;page()-&gt;mainFrame().view();
 128 
 129     // RenderSVGRoot should be highlighted through the isBox() code path, all other SVG elements should just dump their absoluteQuads().
 130     bool isSVGRenderer = renderer-&gt;node() &amp;&amp; renderer-&gt;node()-&gt;isSVGElement() &amp;&amp; !renderer-&gt;isSVGRoot();
 131 
 132     if (isSVGRenderer) {
 133         highlight.type = HighlightType::Rects;
 134         renderer-&gt;absoluteQuads(highlight.quads);
 135         for (auto&amp; quad : highlight.quads)
 136             contentsQuadToCoordinateSystem(mainView, containingView, quad, coordinateSystem);
 137     } else if (is&lt;RenderBox&gt;(*renderer) || is&lt;RenderInline&gt;(*renderer)) {
 138         LayoutRect contentBox;
 139         LayoutRect paddingBox;
 140         LayoutRect borderBox;
 141         LayoutRect marginBox;
 142 
 143         if (is&lt;RenderBox&gt;(*renderer)) {
 144             auto&amp; renderBox = downcast&lt;RenderBox&gt;(*renderer);
 145 
 146             LayoutBoxExtent margins(renderBox.marginTop(), renderBox.marginRight(), renderBox.marginBottom(), renderBox.marginLeft());
 147             paddingBox = renderBox.clientBoxRect();
 148             contentBox = LayoutRect(paddingBox.x() + renderBox.paddingLeft(), paddingBox.y() + renderBox.paddingTop(),
 149                 paddingBox.width() - renderBox.paddingLeft() - renderBox.paddingRight(), paddingBox.height() - renderBox.paddingTop() - renderBox.paddingBottom());
 150             borderBox = LayoutRect(paddingBox.x() - renderBox.borderLeft(), paddingBox.y() - renderBox.borderTop(),
 151                 paddingBox.width() + renderBox.borderLeft() + renderBox.borderRight(), paddingBox.height() + renderBox.borderTop() + renderBox.borderBottom());
 152             marginBox = LayoutRect(borderBox.x() - margins.left(), borderBox.y() - margins.top(),
 153                 borderBox.width() + margins.left() + margins.right(), borderBox.height() + margins.top() + margins.bottom());
 154         } else {
 155             auto&amp; renderInline = downcast&lt;RenderInline&gt;(*renderer);
 156 
 157             // RenderInline&#39;s bounding box includes paddings and borders, excludes margins.
 158             borderBox = renderInline.linesBoundingBox();
 159             paddingBox = LayoutRect(borderBox.x() + renderInline.borderLeft(), borderBox.y() + renderInline.borderTop(),
 160                 borderBox.width() - renderInline.borderLeft() - renderInline.borderRight(), borderBox.height() - renderInline.borderTop() - renderInline.borderBottom());
 161             contentBox = LayoutRect(paddingBox.x() + renderInline.paddingLeft(), paddingBox.y() + renderInline.paddingTop(),
 162                 paddingBox.width() - renderInline.paddingLeft() - renderInline.paddingRight(), paddingBox.height() - renderInline.paddingTop() - renderInline.paddingBottom());
 163             // Ignore marginTop and marginBottom for inlines.
 164             marginBox = LayoutRect(borderBox.x() - renderInline.marginLeft(), borderBox.y(),
 165                 borderBox.width() + renderInline.horizontalMarginExtent(), borderBox.height());
 166         }
 167 
 168         FloatQuad absContentQuad = renderer-&gt;localToAbsoluteQuad(FloatRect(contentBox));
 169         FloatQuad absPaddingQuad = renderer-&gt;localToAbsoluteQuad(FloatRect(paddingBox));
 170         FloatQuad absBorderQuad = renderer-&gt;localToAbsoluteQuad(FloatRect(borderBox));
 171         FloatQuad absMarginQuad = renderer-&gt;localToAbsoluteQuad(FloatRect(marginBox));
 172 
 173         contentsQuadToCoordinateSystem(mainView, containingView, absContentQuad, coordinateSystem);
 174         contentsQuadToCoordinateSystem(mainView, containingView, absPaddingQuad, coordinateSystem);
 175         contentsQuadToCoordinateSystem(mainView, containingView, absBorderQuad, coordinateSystem);
 176         contentsQuadToCoordinateSystem(mainView, containingView, absMarginQuad, coordinateSystem);
 177 
 178         highlight.type = HighlightType::Node;
 179         highlight.quads.append(absMarginQuad);
 180         highlight.quads.append(absBorderQuad);
 181         highlight.quads.append(absPaddingQuad);
 182         highlight.quads.append(absContentQuad);
 183     }
 184 }
 185 
 186 static void buildNodeHighlight(Node&amp; node, const HighlightConfig&amp; highlightConfig, Highlight&amp; highlight, InspectorOverlay::CoordinateSystem coordinateSystem)
 187 {
 188     RenderObject* renderer = node.renderer();
 189     if (!renderer)
 190         return;
 191 
 192     buildRendererHighlight(renderer, highlightConfig, highlight, coordinateSystem);
 193 }
 194 
 195 static void buildQuadHighlight(const FloatQuad&amp; quad, const HighlightConfig&amp; highlightConfig, Highlight&amp; highlight)
 196 {
 197     highlight.setDataFromConfig(highlightConfig);
 198     highlight.type = HighlightType::Rects;
 199     highlight.quads.append(quad);
 200 }
 201 
<a name="15" id="anc15"></a><span class="line-added"> 202 static Path quadToPath(const FloatQuad&amp; quad, Highlight::Bounds&amp; bounds)</span>
<span class="line-added"> 203 {</span>
<span class="line-added"> 204     Path path;</span>
<span class="line-added"> 205     path.moveTo(quad.p1());</span>
<span class="line-added"> 206     path.addLineTo(quad.p2());</span>
<span class="line-added"> 207     path.addLineTo(quad.p3());</span>
<span class="line-added"> 208     path.addLineTo(quad.p4());</span>
<span class="line-added"> 209     path.closeSubpath();</span>
<span class="line-added"> 210 </span>
<span class="line-added"> 211     bounds.unite(path.boundingRect());</span>
<span class="line-added"> 212 </span>
<span class="line-added"> 213     return path;</span>
<span class="line-added"> 214 }</span>
<span class="line-added"> 215 </span>
<span class="line-added"> 216 static void drawOutlinedQuadWithClip(GraphicsContext&amp; context, const FloatQuad&amp; quad, const FloatQuad&amp; clipQuad, const Color&amp; fillColor, Highlight::Bounds&amp; bounds)</span>
<span class="line-added"> 217 {</span>
<span class="line-added"> 218     GraphicsContextStateSaver stateSaver(context);</span>
<span class="line-added"> 219 </span>
<span class="line-added"> 220     context.setFillColor(fillColor);</span>
<span class="line-added"> 221     context.setStrokeThickness(0);</span>
<span class="line-added"> 222     context.fillPath(quadToPath(quad, bounds));</span>
<span class="line-added"> 223 </span>
<span class="line-added"> 224     context.setCompositeOperation(CompositeDestinationOut);</span>
<span class="line-added"> 225     context.setFillColor(Color::createUnchecked(255, 0, 0));</span>
<span class="line-added"> 226     context.fillPath(quadToPath(clipQuad, bounds));</span>
<span class="line-added"> 227 }</span>
<span class="line-added"> 228 </span>
<span class="line-added"> 229 static void drawOutlinedQuad(GraphicsContext&amp; context, const FloatQuad&amp; quad, const Color&amp; fillColor, const Color&amp; outlineColor, Highlight::Bounds&amp; bounds)</span>
<span class="line-added"> 230 {</span>
<span class="line-added"> 231     Path path = quadToPath(quad, bounds);</span>
<span class="line-added"> 232 </span>
<span class="line-added"> 233     GraphicsContextStateSaver stateSaver(context);</span>
<span class="line-added"> 234 </span>
<span class="line-added"> 235     context.setStrokeThickness(2);</span>
<span class="line-added"> 236 </span>
<span class="line-added"> 237     context.clipPath(path);</span>
<span class="line-added"> 238 </span>
<span class="line-added"> 239     context.setFillColor(fillColor);</span>
<span class="line-added"> 240     context.fillPath(path);</span>
<span class="line-added"> 241 </span>
<span class="line-added"> 242     context.setStrokeColor(outlineColor);</span>
<span class="line-added"> 243     context.strokePath(path);</span>
<span class="line-added"> 244 }</span>
<span class="line-added"> 245 </span>
<span class="line-added"> 246 static void drawFragmentHighlight(GraphicsContext&amp; context, Node&amp; node, const HighlightConfig&amp; highlightConfig, Highlight::Bounds&amp; bounds)</span>
<span class="line-added"> 247 {</span>
<span class="line-added"> 248     Highlight highlight;</span>
<span class="line-added"> 249     buildNodeHighlight(node, highlightConfig, highlight, InspectorOverlay::CoordinateSystem::Document);</span>
<span class="line-added"> 250 </span>
<span class="line-added"> 251     FloatQuad marginQuad;</span>
<span class="line-added"> 252     FloatQuad borderQuad;</span>
<span class="line-added"> 253     FloatQuad paddingQuad;</span>
<span class="line-added"> 254     FloatQuad contentQuad;</span>
<span class="line-added"> 255 </span>
<span class="line-added"> 256     size_t size = highlight.quads.size();</span>
<span class="line-added"> 257     if (size &gt;= 1)</span>
<span class="line-added"> 258         marginQuad = highlight.quads[0];</span>
<span class="line-added"> 259     if (size &gt;= 2)</span>
<span class="line-added"> 260         borderQuad = highlight.quads[1];</span>
<span class="line-added"> 261     if (size &gt;= 3)</span>
<span class="line-added"> 262         paddingQuad = highlight.quads[2];</span>
<span class="line-added"> 263     if (size &gt;= 4)</span>
<span class="line-added"> 264         contentQuad = highlight.quads[3];</span>
<span class="line-added"> 265 </span>
<span class="line-added"> 266     if (!marginQuad.isEmpty() &amp;&amp; marginQuad != borderQuad &amp;&amp; highlight.marginColor.isVisible())</span>
<span class="line-added"> 267         drawOutlinedQuadWithClip(context, marginQuad, borderQuad, highlight.marginColor, bounds);</span>
<span class="line-added"> 268 </span>
<span class="line-added"> 269     if (!borderQuad.isEmpty() &amp;&amp; borderQuad != paddingQuad &amp;&amp; highlight.borderColor.isVisible())</span>
<span class="line-added"> 270         drawOutlinedQuadWithClip(context, borderQuad, paddingQuad, highlight.borderColor, bounds);</span>
<span class="line-added"> 271 </span>
<span class="line-added"> 272     if (!paddingQuad.isEmpty() &amp;&amp; paddingQuad != contentQuad &amp;&amp; highlight.paddingColor.isVisible())</span>
<span class="line-added"> 273         drawOutlinedQuadWithClip(context, paddingQuad, contentQuad, highlight.paddingColor, bounds);</span>
<span class="line-added"> 274 </span>
<span class="line-added"> 275     if (!contentQuad.isEmpty() &amp;&amp; (highlight.contentColor.isVisible() || highlight.contentOutlineColor.isVisible()))</span>
<span class="line-added"> 276         drawOutlinedQuad(context, contentQuad, highlight.contentColor, highlight.contentOutlineColor, bounds);</span>
<span class="line-added"> 277 }</span>
<span class="line-added"> 278 </span>
<span class="line-added"> 279 static void drawShapeHighlight(GraphicsContext&amp; context, Node&amp; node, Highlight::Bounds&amp; bounds)</span>
<span class="line-added"> 280 {</span>
<span class="line-added"> 281     RenderObject* renderer = node.renderer();</span>
<span class="line-added"> 282     if (!renderer || !is&lt;RenderBox&gt;(renderer))</span>
<span class="line-added"> 283         return;</span>
<span class="line-added"> 284 </span>
<span class="line-added"> 285     const ShapeOutsideInfo* shapeOutsideInfo = downcast&lt;RenderBox&gt;(renderer)-&gt;shapeOutsideInfo();</span>
<span class="line-added"> 286     if (!shapeOutsideInfo)</span>
<span class="line-added"> 287         return;</span>
<span class="line-added"> 288 </span>
<span class="line-added"> 289     Frame* containingFrame = node.document().frame();</span>
<span class="line-added"> 290     if (!containingFrame)</span>
<span class="line-added"> 291         return;</span>
<span class="line-added"> 292 </span>
<span class="line-added"> 293     FrameView* containingView = containingFrame-&gt;view();</span>
<span class="line-added"> 294     FrameView* mainView = containingFrame-&gt;page()-&gt;mainFrame().view();</span>
<span class="line-added"> 295 </span>
<span class="line-added"> 296     const Color shapeHighlightColor(96, 82, 127, 204);</span>
<span class="line-added"> 297 </span>
<span class="line-added"> 298     Shape::DisplayPaths paths;</span>
<span class="line-added"> 299     shapeOutsideInfo-&gt;computedShape().buildDisplayPaths(paths);</span>
<span class="line-added"> 300 </span>
<span class="line-added"> 301     if (paths.shape.isEmpty()) {</span>
<span class="line-added"> 302         LayoutRect shapeBounds = shapeOutsideInfo-&gt;computedShapePhysicalBoundingBox();</span>
<span class="line-added"> 303         FloatQuad shapeQuad = renderer-&gt;localToAbsoluteQuad(FloatRect(shapeBounds));</span>
<span class="line-added"> 304         contentsQuadToCoordinateSystem(mainView, containingView, shapeQuad, InspectorOverlay::CoordinateSystem::Document);</span>
<span class="line-added"> 305         drawOutlinedQuad(context, shapeQuad, shapeHighlightColor, Color::transparent, bounds);</span>
<span class="line-added"> 306         return;</span>
<span class="line-added"> 307     }</span>
<span class="line-added"> 308 </span>
<span class="line-added"> 309     const auto mapPoints = [&amp;] (const Path&amp; path) {</span>
<span class="line-added"> 310         Path newPath;</span>
<span class="line-added"> 311         path.apply([&amp;] (const PathElement&amp; pathElement) {</span>
<span class="line-added"> 312             const auto localToRoot = [&amp;] (size_t index) {</span>
<span class="line-added"> 313                 const FloatPoint&amp; point = pathElement.points[index];</span>
<span class="line-added"> 314                 return localPointToRootPoint(containingView, renderer-&gt;localToAbsolute(shapeOutsideInfo-&gt;shapeToRendererPoint(point)));</span>
<span class="line-added"> 315             };</span>
<span class="line-added"> 316 </span>
<span class="line-added"> 317             switch (pathElement.type) {</span>
<span class="line-added"> 318             case PathElementMoveToPoint:</span>
<span class="line-added"> 319                 newPath.moveTo(localToRoot(0));</span>
<span class="line-added"> 320                 break;</span>
<span class="line-added"> 321 </span>
<span class="line-added"> 322             case PathElementAddLineToPoint:</span>
<span class="line-added"> 323                 newPath.addLineTo(localToRoot(0));</span>
<span class="line-added"> 324                 break;</span>
<span class="line-added"> 325 </span>
<span class="line-added"> 326             case PathElementAddCurveToPoint:</span>
<span class="line-added"> 327                 newPath.addBezierCurveTo(localToRoot(0), localToRoot(1), localToRoot(2));</span>
<span class="line-added"> 328                 break;</span>
<span class="line-added"> 329 </span>
<span class="line-added"> 330             case PathElementAddQuadCurveToPoint:</span>
<span class="line-added"> 331                 newPath.addQuadCurveTo(localToRoot(0), localToRoot(1));</span>
<span class="line-added"> 332                 break;</span>
<span class="line-added"> 333 </span>
<span class="line-added"> 334             case PathElementCloseSubpath:</span>
<span class="line-added"> 335                 newPath.closeSubpath();</span>
<span class="line-added"> 336                 break;</span>
<span class="line-added"> 337             }</span>
<span class="line-added"> 338         });</span>
<span class="line-added"> 339         return newPath;</span>
<span class="line-added"> 340     };</span>
<span class="line-added"> 341 </span>
<span class="line-added"> 342     if (paths.marginShape.length()) {</span>
<span class="line-added"> 343         Path marginPath = mapPoints(paths.marginShape);</span>
<span class="line-added"> 344         bounds.unite(marginPath.boundingRect());</span>
<span class="line-added"> 345 </span>
<span class="line-added"> 346         GraphicsContextStateSaver stateSaver(context);</span>
<span class="line-added"> 347 </span>
<span class="line-added"> 348         const Color shapeMarginHighlightColor(96, 82, 127, 153);</span>
<span class="line-added"> 349         context.setFillColor(shapeMarginHighlightColor);</span>
<span class="line-added"> 350         context.fillPath(marginPath);</span>
<span class="line-added"> 351     }</span>
<span class="line-added"> 352 </span>
<span class="line-added"> 353     Path shapePath = mapPoints(paths.shape);</span>
<span class="line-added"> 354     bounds.unite(shapePath.boundingRect());</span>
<span class="line-added"> 355 </span>
<span class="line-added"> 356     GraphicsContextStateSaver stateSaver(context);</span>
<span class="line-added"> 357 </span>
<span class="line-added"> 358     context.setFillColor(shapeHighlightColor);</span>
<span class="line-added"> 359     context.fillPath(shapePath);</span>
<span class="line-added"> 360 }</span>
<span class="line-added"> 361 </span>
 362 InspectorOverlay::InspectorOverlay(Page&amp; page, InspectorClient* client)
 363     : m_page(page)
 364     , m_client(client)
 365     , m_paintRectUpdateTimer(*this, &amp;InspectorOverlay::updatePaintRectsTimerFired)
 366 {
 367 }
 368 
 369 InspectorOverlay::~InspectorOverlay() = default;
 370 
 371 void InspectorOverlay::paint(GraphicsContext&amp; context)
 372 {
 373     if (!shouldShowOverlay())
 374         return;
 375 
<a name="16" id="anc16"></a><span class="line-modified"> 376     FloatSize viewportSize = m_page.mainFrame().view()-&gt;sizeForVisibleContent();</span>
<span class="line-modified"> 377 </span>
<span class="line-modified"> 378     context.clearRect({ FloatPoint::zero(), viewportSize });</span>
 379 
 380     GraphicsContextStateSaver stateSaver(context);
<a name="17" id="anc17"></a>
 381 
<a name="18" id="anc18"></a><span class="line-modified"> 382     if (m_indicating) {</span>
<span class="line-modified"> 383         GraphicsContextStateSaver stateSaver(context);</span>
<span class="line-modified"> 384 </span>
<span class="line-added"> 385         const Color indicatingColor(111, 168, 220, 168);</span>
<span class="line-added"> 386         context.setFillColor(indicatingColor);</span>
<span class="line-added"> 387         context.fillRect({ FloatPoint::zero(), viewportSize });</span>
<span class="line-added"> 388     }</span>
<span class="line-added"> 389 </span>
<span class="line-added"> 390     RulerExclusion rulerExclusion;</span>
<span class="line-added"> 391 </span>
<span class="line-added"> 392     if (m_highlightQuad) {</span>
<span class="line-added"> 393         auto quadRulerExclusion = drawQuadHighlight(context, *m_highlightQuad);</span>
<span class="line-added"> 394         rulerExclusion.bounds.unite(quadRulerExclusion.bounds);</span>
<span class="line-added"> 395     }</span>
<span class="line-added"> 396 </span>
<span class="line-added"> 397     if (m_highlightNodeList) {</span>
<span class="line-added"> 398         for (unsigned i = 0; i &lt; m_highlightNodeList-&gt;length(); ++i) {</span>
<span class="line-added"> 399             if (auto* node = m_highlightNodeList-&gt;item(i)) {</span>
<span class="line-added"> 400                 auto nodeRulerExclusion = drawNodeHighlight(context, *node);</span>
<span class="line-added"> 401                 rulerExclusion.bounds.unite(nodeRulerExclusion.bounds);</span>
<span class="line-added"> 402             }</span>
<span class="line-added"> 403         }</span>
<span class="line-added"> 404     }</span>
<span class="line-added"> 405 </span>
<span class="line-added"> 406     if (m_highlightNode) {</span>
<span class="line-added"> 407         auto nodeRulerExclusion = drawNodeHighlight(context, *m_highlightNode);</span>
<span class="line-added"> 408         rulerExclusion.bounds.unite(nodeRulerExclusion.bounds);</span>
<span class="line-added"> 409         rulerExclusion.titlePath = nodeRulerExclusion.titlePath;</span>
<span class="line-added"> 410     }</span>
<span class="line-added"> 411 </span>
<span class="line-added"> 412     if (!m_paintRects.isEmpty())</span>
<span class="line-added"> 413         drawPaintRects(context, m_paintRects);</span>
 414 
<a name="19" id="anc19"></a><span class="line-modified"> 415     if (m_showRulers || m_showRulersDuringElementSelection)</span>
<span class="line-modified"> 416         drawRulers(context, rulerExclusion);</span>
 417 }
 418 
 419 void InspectorOverlay::getHighlight(Highlight&amp; highlight, InspectorOverlay::CoordinateSystem coordinateSystem) const
 420 {
 421     if (!m_highlightNode &amp;&amp; !m_highlightQuad &amp;&amp; !m_highlightNodeList)
 422         return;
 423 
 424     highlight.type = HighlightType::Rects;
 425     if (m_highlightNode)
 426         buildNodeHighlight(*m_highlightNode, m_nodeHighlightConfig, highlight, coordinateSystem);
 427     else if (m_highlightNodeList) {
 428         highlight.setDataFromConfig(m_nodeHighlightConfig);
 429         for (unsigned i = 0; i &lt; m_highlightNodeList-&gt;length(); ++i) {
 430             Highlight nodeHighlight;
 431             buildNodeHighlight(*(m_highlightNodeList-&gt;item(i)), m_nodeHighlightConfig, nodeHighlight, coordinateSystem);
 432             if (nodeHighlight.type == HighlightType::Node)
 433                 highlight.quads.appendVector(nodeHighlight.quads);
 434         }
 435         highlight.type = HighlightType::NodeList;
 436     } else
 437         buildQuadHighlight(*m_highlightQuad, m_quadHighlightConfig, highlight);
 438 }
 439 
<a name="20" id="anc20"></a>





 440 void InspectorOverlay::hideHighlight()
 441 {
 442     m_highlightNode = nullptr;
 443     m_highlightNodeList = nullptr;
 444     m_highlightQuad = nullptr;
 445     update();
 446 }
 447 
 448 void InspectorOverlay::highlightNodeList(RefPtr&lt;NodeList&gt;&amp;&amp; nodes, const HighlightConfig&amp; highlightConfig)
 449 {
 450     m_nodeHighlightConfig = highlightConfig;
 451     m_highlightNodeList = WTFMove(nodes);
 452     m_highlightNode = nullptr;
 453     update();
 454 }
 455 
 456 void InspectorOverlay::highlightNode(Node* node, const HighlightConfig&amp; highlightConfig)
 457 {
 458     m_nodeHighlightConfig = highlightConfig;
 459     m_highlightNode = node;
 460     m_highlightNodeList = nullptr;
 461     update();
 462 }
 463 
 464 void InspectorOverlay::highlightQuad(std::unique_ptr&lt;FloatQuad&gt; quad, const HighlightConfig&amp; highlightConfig)
 465 {
 466     if (highlightConfig.usePageCoordinates)
 467         *quad -= toIntSize(m_page.mainFrame().view()-&gt;scrollPosition());
 468 
 469     m_quadHighlightConfig = highlightConfig;
 470     m_highlightQuad = WTFMove(quad);
 471     update();
 472 }
 473 
 474 Node* InspectorOverlay::highlightedNode() const
 475 {
 476     return m_highlightNode.get();
 477 }
 478 
 479 void InspectorOverlay::didSetSearchingForNode(bool enabled)
 480 {
 481     m_client-&gt;didSetSearchingForNode(enabled);
 482 }
 483 
 484 void InspectorOverlay::setIndicating(bool indicating)
 485 {
<a name="21" id="anc21"></a><span class="line-modified"> 486     if (m_indicating == indicating)</span>
<span class="line-added"> 487         return;</span>
 488 
<a name="22" id="anc22"></a><span class="line-modified"> 489     m_indicating = indicating;</span>



 490 
 491     update();
 492 }
 493 
 494 bool InspectorOverlay::shouldShowOverlay() const
 495 {
<a name="23" id="anc23"></a><span class="line-modified"> 496     // Don&#39;t show the overlay when m_showRulersDuringElementSelection is true, as it&#39;s only supposed</span>
<span class="line-added"> 497     // to have an effect when element selection is active (e.g. a node is hovered).</span>
<span class="line-added"> 498     return m_highlightNode || m_highlightNodeList || m_highlightQuad || m_indicating || m_showPaintRects || m_showRulers;</span>
 499 }
 500 
 501 void InspectorOverlay::update()
 502 {
 503     if (!shouldShowOverlay()) {
 504         m_client-&gt;hideHighlight();
 505         return;
 506     }
 507 
 508     FrameView* view = m_page.mainFrame().view();
 509     if (!view)
 510         return;
 511 
<a name="24" id="anc24"></a><span class="line-modified"> 512     m_client-&gt;highlight();</span>

















































































 513 }
 514 
<a name="25" id="anc25"></a><span class="line-modified"> 515 void InspectorOverlay::setShowPaintRects(bool showPaintRects)</span>
 516 {
<a name="26" id="anc26"></a><span class="line-modified"> 517     if (m_showPaintRects == showPaintRects)</span>
 518         return;
 519 
<a name="27" id="anc27"></a><span class="line-modified"> 520     m_showPaintRects = showPaintRects;</span>
<span class="line-modified"> 521     if (!m_showPaintRects) {</span>
 522         m_paintRects.clear();
 523         m_paintRectUpdateTimer.stop();
<a name="28" id="anc28"></a><span class="line-modified"> 524         update();</span>

 525     }
 526 }
 527 
 528 void InspectorOverlay::showPaintRect(const FloatRect&amp; rect)
 529 {
<a name="29" id="anc29"></a><span class="line-modified"> 530     if (!m_showPaintRects)</span>
 531         return;
 532 
 533     IntRect rootRect = m_page.mainFrame().view()-&gt;contentsToRootView(enclosingIntRect(rect));
 534 
 535     const auto removeDelay = 250_ms;
 536 
 537     MonotonicTime removeTime = MonotonicTime::now() + removeDelay;
 538     m_paintRects.append(TimeRectPair(removeTime, rootRect));
 539 
 540     if (!m_paintRectUpdateTimer.isActive()) {
 541         const Seconds paintRectsUpdateInterval { 32_ms };
 542         m_paintRectUpdateTimer.startRepeating(paintRectsUpdateInterval);
 543     }
 544 
<a name="30" id="anc30"></a><span class="line-modified"> 545     update();</span>

 546 }
 547 
 548 void InspectorOverlay::setShowRulers(bool showRulers)
 549 {
 550     if (m_showRulers == showRulers)
 551         return;
 552 
 553     m_showRulers = showRulers;
 554 
 555     update();
 556 }
 557 
 558 void InspectorOverlay::updatePaintRectsTimerFired()
 559 {
 560     MonotonicTime now = MonotonicTime::now();
 561     bool rectsChanged = false;
 562     while (!m_paintRects.isEmpty() &amp;&amp; m_paintRects.first().first &lt; now) {
 563         m_paintRects.removeFirst();
 564         rectsChanged = true;
 565     }
 566 
 567     if (m_paintRects.isEmpty())
 568         m_paintRectUpdateTimer.stop();
 569 
<a name="31" id="anc31"></a><span class="line-modified"> 570     if (rectsChanged)</span>
<span class="line-modified"> 571         update();</span>


 572 }
 573 
<a name="32" id="anc32"></a><span class="line-modified"> 574 InspectorOverlay::RulerExclusion InspectorOverlay::drawNodeHighlight(GraphicsContext&amp; context, Node&amp; node)</span>
 575 {
<a name="33" id="anc33"></a><span class="line-modified"> 576     RulerExclusion rulerExclusion;</span>


 577 
<a name="34" id="anc34"></a><span class="line-modified"> 578     drawFragmentHighlight(context, node, m_nodeHighlightConfig, rulerExclusion.bounds);</span>

 579 
<a name="35" id="anc35"></a><span class="line-modified"> 580     if (m_nodeHighlightConfig.showInfo)</span>
<span class="line-modified"> 581         drawShapeHighlight(context, node, rulerExclusion.bounds);</span>
<span class="line-modified"> 582 </span>
<span class="line-added"> 583     if (m_showRulers || m_showRulersDuringElementSelection)</span>
<span class="line-added"> 584         drawBounds(context, rulerExclusion.bounds);</span>
<span class="line-added"> 585 </span>
<span class="line-added"> 586     // Ensure that the title information is drawn after the bounds.</span>
<span class="line-added"> 587     if (m_nodeHighlightConfig.showInfo)</span>
<span class="line-added"> 588         rulerExclusion.titlePath = drawElementTitle(context, node, rulerExclusion.bounds);</span>
<span class="line-added"> 589 </span>
<span class="line-added"> 590     return rulerExclusion;</span>
 591 }
 592 
<a name="36" id="anc36"></a><span class="line-modified"> 593 InspectorOverlay::RulerExclusion InspectorOverlay::drawQuadHighlight(GraphicsContext&amp; context, const FloatQuad&amp; quad)</span>
 594 {
<a name="37" id="anc37"></a><span class="line-modified"> 595     RulerExclusion rulerExclusion;</span>
 596 
 597     Highlight highlight;
<a name="38" id="anc38"></a><span class="line-modified"> 598     buildQuadHighlight(quad, m_quadHighlightConfig, highlight);</span>
<span class="line-modified"> 599 </span>
<span class="line-added"> 600     if (highlight.quads.size() &gt;= 1) {</span>
<span class="line-added"> 601         drawOutlinedQuad(context, highlight.quads[0], highlight.contentColor, highlight.contentOutlineColor, rulerExclusion.bounds);</span>
 602 
<a name="39" id="anc39"></a><span class="line-modified"> 603         if (m_showRulers || m_showRulersDuringElementSelection)</span>
<span class="line-added"> 604             drawBounds(context, rulerExclusion.bounds);</span>
<span class="line-added"> 605     }</span>
<span class="line-added"> 606 </span>
<span class="line-added"> 607     return rulerExclusion;</span>
 608 }
 609 
<a name="40" id="anc40"></a><span class="line-modified"> 610 void InspectorOverlay::drawPaintRects(GraphicsContext&amp; context, const Deque&lt;TimeRectPair&gt;&amp; paintRects)</span>
 611 {
<a name="41" id="anc41"></a><span class="line-modified"> 612     GraphicsContextStateSaver stateSaver(context);</span>




 613 
<a name="42" id="anc42"></a><span class="line-modified"> 614     const Color paintRectsColor(1.0f, 0.0f, 0.0f, 0.5f);</span>
<span class="line-modified"> 615     context.setFillColor(paintRectsColor);</span>





 616 
<a name="43" id="anc43"></a><span class="line-modified"> 617     for (const TimeRectPair&amp; pair : paintRects)</span>
<span class="line-added"> 618         context.fillRect(pair.second);</span>
<span class="line-added"> 619 }</span>
<span class="line-added"> 620 </span>
<span class="line-added"> 621 void InspectorOverlay::drawBounds(GraphicsContext&amp; context, const Highlight::Bounds&amp; bounds)</span>
 622 {
<a name="44" id="anc44"></a><span class="line-modified"> 623     FrameView* pageView = m_page.mainFrame().view();</span>
<span class="line-modified"> 624     FloatSize viewportSize = pageView-&gt;sizeForVisibleContent();</span>
<span class="line-modified"> 625     FloatSize contentInset(0, pageView-&gt;topContentInset(ScrollView::TopContentInsetType::WebCoreOrPlatformContentInset));</span>
<span class="line-modified"> 626 </span>
<span class="line-modified"> 627     Path path;</span>
<span class="line-modified"> 628 </span>
<span class="line-modified"> 629     if (bounds.y() &gt; contentInset.height()) {</span>
<span class="line-added"> 630         path.moveTo({ bounds.x(), bounds.y() });</span>
<span class="line-added"> 631         path.addLineTo({ bounds.x(), contentInset.height() });</span>
<span class="line-added"> 632 </span>
<span class="line-added"> 633         path.moveTo({ bounds.maxX(), bounds.y() });</span>
<span class="line-added"> 634         path.addLineTo({ bounds.maxX(), contentInset.height() });</span>
<span class="line-added"> 635     }</span>
<span class="line-added"> 636 </span>
<span class="line-added"> 637     if (bounds.maxY() &lt; viewportSize.height()) {</span>
<span class="line-added"> 638         path.moveTo({ bounds.x(), viewportSize.height() });</span>
<span class="line-added"> 639         path.addLineTo({ bounds.x(), bounds.maxY() });</span>
<span class="line-added"> 640 </span>
<span class="line-added"> 641         path.moveTo({ bounds.maxX(), viewportSize.height() });</span>
<span class="line-added"> 642         path.addLineTo({ bounds.maxX(), bounds.maxY() });</span>
 643     }
<a name="45" id="anc45"></a>
 644 
<a name="46" id="anc46"></a><span class="line-modified"> 645     if (bounds.x() &gt; contentInset.width()) {</span>
<span class="line-modified"> 646         path.moveTo({ bounds.x(), bounds.y() });</span>
<span class="line-modified"> 647         path.addLineTo({ contentInset.width(), bounds.y() });</span>
<span class="line-modified"> 648 </span>
<span class="line-modified"> 649         path.moveTo({ bounds.x(), bounds.maxY() });</span>
<span class="line-modified"> 650         path.addLineTo({ contentInset.width(), bounds.maxY() });</span>
<span class="line-modified"> 651     }</span>
<span class="line-modified"> 652 </span>
<span class="line-modified"> 653     if (bounds.maxX() &lt; viewportSize.width()) {</span>
<span class="line-modified"> 654         path.moveTo({ bounds.maxX(), bounds.y() });</span>
<span class="line-modified"> 655         path.addLineTo({ viewportSize.width(), bounds.y() });</span>
<span class="line-modified"> 656 </span>
<span class="line-modified"> 657         path.moveTo({ bounds.maxX(), bounds.maxY() });</span>
<span class="line-modified"> 658         path.addLineTo({ viewportSize.width(), bounds.maxY() });</span>










 659     }
<a name="47" id="anc47"></a><span class="line-added"> 660 </span>
<span class="line-added"> 661     GraphicsContextStateSaver stateSaver(context);</span>
<span class="line-added"> 662 </span>
<span class="line-added"> 663     context.setStrokeThickness(1);</span>
<span class="line-added"> 664 </span>
<span class="line-added"> 665     const Color boundsColor(1.0f, 0.0f, 0.0f, 0.6f);</span>
<span class="line-added"> 666     context.setStrokeColor(boundsColor);</span>
<span class="line-added"> 667 </span>
<span class="line-added"> 668     context.strokePath(path);</span>
 669 }
 670 
<a name="48" id="anc48"></a><span class="line-modified"> 671 void InspectorOverlay::drawRulers(GraphicsContext&amp; context, const InspectorOverlay::RulerExclusion&amp; rulerExclusion)</span>
 672 {
<a name="49" id="anc49"></a><span class="line-modified"> 673     const Color rulerBackgroundColor(1.0f, 1.0f, 1.0f, 0.6f);</span>
<span class="line-modified"> 674     const Color lightRulerColor(0.0f, 0.0f, 0.0f, 0.2f);</span>
<span class="line-modified"> 675     const Color darkRulerColor(0.0f, 0.0f, 0.0f, 0.5f);</span>
<span class="line-added"> 676 </span>
<span class="line-added"> 677     IntPoint scrollOffset;</span>
<span class="line-added"> 678 </span>
<span class="line-added"> 679     FrameView* pageView = m_page.mainFrame().view();</span>
<span class="line-added"> 680     if (!pageView-&gt;delegatesScrolling())</span>
<span class="line-added"> 681         scrollOffset = pageView-&gt;visibleContentRect().location();</span>
<span class="line-added"> 682 </span>
<span class="line-added"> 683     FloatSize viewportSize = pageView-&gt;sizeForVisibleContent();</span>
<span class="line-added"> 684     FloatSize contentInset(0, pageView-&gt;topContentInset(ScrollView::TopContentInsetType::WebCoreOrPlatformContentInset));</span>
<span class="line-added"> 685     float pageScaleFactor = m_page.pageScaleFactor();</span>
<span class="line-added"> 686     float pageZoomFactor = m_page.mainFrame().pageZoomFactor();</span>
<span class="line-added"> 687 </span>
<span class="line-added"> 688     float pageFactor = pageZoomFactor * pageScaleFactor;</span>
<span class="line-added"> 689     float scrollX = scrollOffset.x() * pageScaleFactor;</span>
<span class="line-added"> 690     float scrollY = scrollOffset.y() * pageScaleFactor;</span>
<span class="line-added"> 691 </span>
<span class="line-added"> 692     const auto zoom = [&amp;] (float value) -&gt; float {</span>
<span class="line-added"> 693         return value * pageFactor;</span>
<span class="line-added"> 694     };</span>
<span class="line-added"> 695 </span>
<span class="line-added"> 696     const auto unzoom = [&amp;] (float value) -&gt; float {</span>
<span class="line-added"> 697         return value / pageFactor;</span>
<span class="line-added"> 698     };</span>
<span class="line-added"> 699 </span>
<span class="line-added"> 700     const auto multipleBelow = [&amp;] (float value, float step) -&gt; float {</span>
<span class="line-added"> 701         return value - std::fmod(value, step);</span>
<span class="line-added"> 702     };</span>
<span class="line-added"> 703 </span>
<span class="line-added"> 704     float width = viewportSize.width() / pageFactor;</span>
<span class="line-added"> 705     float height = viewportSize.height() / pageFactor;</span>
<span class="line-added"> 706     float minX = unzoom(scrollX);</span>
<span class="line-added"> 707     float minY = unzoom(scrollY);</span>
<span class="line-added"> 708     float maxX = minX + width;</span>
<span class="line-added"> 709     float maxY = minY + height;</span>
<span class="line-added"> 710 </span>
<span class="line-added"> 711     bool drawTopEdge = true;</span>
<span class="line-added"> 712     bool drawLeftEdge = true;</span>
<span class="line-added"> 713 </span>
<span class="line-added"> 714     // Determine which side (top/bottom and left/right) to draw the rulers.</span>
<span class="line-added"> 715     {</span>
<span class="line-added"> 716         FloatRect topEdge(contentInset.width(), contentInset.height(), zoom(width) - contentInset.width(), rulerSize);</span>
<span class="line-added"> 717         FloatRect bottomEdge(contentInset.width(), zoom(height) - rulerSize, zoom(width) - contentInset.width(), rulerSize);</span>
<span class="line-added"> 718         drawTopEdge = !rulerExclusion.bounds.intersects(topEdge) || rulerExclusion.bounds.intersects(bottomEdge);</span>
<span class="line-added"> 719 </span>
<span class="line-added"> 720         FloatRect rightEdge(zoom(width) - rulerSize, contentInset.height(), rulerSize, zoom(height) - contentInset.height());</span>
<span class="line-added"> 721         FloatRect leftEdge(contentInset.width(), contentInset.height(), rulerSize, zoom(height) - contentInset.height());</span>
<span class="line-added"> 722         drawLeftEdge = !rulerExclusion.bounds.intersects(leftEdge) || rulerExclusion.bounds.intersects(rightEdge);</span>
<span class="line-added"> 723     }</span>
 724 
<a name="50" id="anc50"></a><span class="line-modified"> 725     float cornerX = drawLeftEdge ? contentInset.width() : zoom(width) - rulerSize;</span>
<span class="line-modified"> 726     float cornerY = drawTopEdge ? contentInset.height() : zoom(height) - rulerSize;</span>

 727 
<a name="51" id="anc51"></a><span class="line-modified"> 728     // Draw backgrounds.</span>
<span class="line-modified"> 729     {</span>
<span class="line-modified"> 730         GraphicsContextStateSaver backgroundStateSaver(context);</span>
 731 
<a name="52" id="anc52"></a><span class="line-modified"> 732         context.setFillColor(rulerBackgroundColor);</span>

 733 
<a name="53" id="anc53"></a><span class="line-modified"> 734         context.fillRect({ cornerX, cornerY, rulerSize, rulerSize });</span>
<span class="line-modified"> 735 </span>
<span class="line-modified"> 736         if (drawLeftEdge)</span>
<span class="line-modified"> 737             context.fillRect({ cornerX + rulerSize, cornerY, zoom(width) - cornerX - rulerSize, rulerSize });</span>
<span class="line-modified"> 738         else</span>
<span class="line-modified"> 739             context.fillRect({ contentInset.width(), cornerY, cornerX - contentInset.width(), rulerSize });</span>
<span class="line-modified"> 740 </span>
<span class="line-modified"> 741         if (drawTopEdge)</span>
<span class="line-modified"> 742             context.fillRect({ cornerX, cornerY + rulerSize, rulerSize, zoom(height) - cornerY - rulerSize });</span>
<span class="line-modified"> 743         else</span>
<span class="line-modified"> 744             context.fillRect({ cornerX, contentInset.height(), rulerSize, cornerY - contentInset.height() });</span>
<span class="line-modified"> 745     }</span>
<span class="line-added"> 746 </span>
<span class="line-added"> 747     // Draw lines.</span>
<span class="line-added"> 748     {</span>
<span class="line-added"> 749         FontCascadeDescription fontDescription;</span>
<span class="line-added"> 750         fontDescription.setOneFamily(m_page.settings().sansSerifFontFamily());</span>
<span class="line-added"> 751         fontDescription.setComputedSize(10);</span>
<span class="line-added"> 752 </span>
<span class="line-added"> 753         FontCascade font(WTFMove(fontDescription), 0, 0);</span>
<span class="line-added"> 754         font.update(nullptr);</span>
<span class="line-added"> 755 </span>
<span class="line-added"> 756         GraphicsContextStateSaver lineStateSaver(context);</span>
<span class="line-added"> 757 </span>
<span class="line-added"> 758         context.setFillColor(darkRulerColor);</span>
<span class="line-added"> 759         context.setStrokeThickness(1);</span>
<span class="line-added"> 760 </span>
<span class="line-added"> 761         // Draw horizontal ruler.</span>
<span class="line-added"> 762         {</span>
<span class="line-added"> 763             GraphicsContextStateSaver horizontalRulerStateSaver(context);</span>
<span class="line-added"> 764 </span>
<span class="line-added"> 765             context.translate(contentInset.width() - scrollX + 0.5f, cornerY - scrollY);</span>
<span class="line-added"> 766 </span>
<span class="line-added"> 767             for (float x = multipleBelow(minX, rulerSubStepIncrement); x &lt; maxX; x += rulerSubStepIncrement) {</span>
<span class="line-added"> 768                 if (!x &amp;&amp; !scrollX)</span>
<span class="line-added"> 769                     continue;</span>
<span class="line-added"> 770 </span>
<span class="line-added"> 771                 Path path;</span>
<span class="line-added"> 772                 path.moveTo({ zoom(x), drawTopEdge ? scrollY : scrollY + rulerSize });</span>
<span class="line-added"> 773 </span>
<span class="line-added"> 774                 float lineLength = 0.0f;</span>
<span class="line-added"> 775                 if (std::fmod(x, rulerStepIncrement)) {</span>
<span class="line-added"> 776                     lineLength = rulerSubStepLength;</span>
<span class="line-added"> 777                     context.setStrokeColor(lightRulerColor);</span>
<span class="line-added"> 778                 } else {</span>
<span class="line-added"> 779                     lineLength = std::fmod(x, rulerStepIncrement * 2) ? rulerSubStepLength : rulerStepLength;</span>
<span class="line-added"> 780                     context.setStrokeColor(darkRulerColor);</span>
<span class="line-added"> 781                 }</span>
<span class="line-added"> 782                 path.addLineTo({ zoom(x), scrollY + (drawTopEdge ? lineLength : rulerSize - lineLength) });</span>
 783 
<a name="54" id="anc54"></a><span class="line-modified"> 784                 context.strokePath(path);</span>
<span class="line-added"> 785             }</span>
 786 
<a name="55" id="anc55"></a><span class="line-modified"> 787             // Draw labels.</span>
<span class="line-modified"> 788             for (float x = multipleBelow(minX, rulerStepIncrement * 2); x &lt; maxX; x += rulerStepIncrement * 2) {</span>
<span class="line-modified"> 789                 if (!x &amp;&amp; !scrollX)</span>
<span class="line-added"> 790                     continue;</span>
 791 
<a name="56" id="anc56"></a><span class="line-modified"> 792                 GraphicsContextStateSaver verticalLabelStateSaver(context);</span>
<span class="line-modified"> 793                 context.translate(zoom(x) + 0.5f, scrollY);</span>
<span class="line-modified"> 794                 context.drawText(font, TextRun(String::numberToStringFixedPrecision(x)), { 2, drawTopEdge ? rulerLabelSize : rulerLabelSize - rulerSize + font.fontMetrics().height() - 1.0f });</span>
<span class="line-added"> 795             }</span>
<span class="line-added"> 796         }</span>
 797 
<a name="57" id="anc57"></a><span class="line-modified"> 798         // Draw vertical ruler.</span>
<span class="line-added"> 799         {</span>
<span class="line-added"> 800             GraphicsContextStateSaver veritcalRulerStateSaver(context);</span>
<span class="line-added"> 801 </span>
<span class="line-added"> 802             context.translate(cornerX - scrollX, contentInset.height() - scrollY + 0.5f);</span>
<span class="line-added"> 803 </span>
<span class="line-added"> 804             for (float y = multipleBelow(minY, rulerSubStepIncrement); y &lt; maxY; y += rulerSubStepIncrement) {</span>
<span class="line-added"> 805                 if (!y &amp;&amp; !scrollY)</span>
<span class="line-added"> 806                     continue;</span>
<span class="line-added"> 807 </span>
<span class="line-added"> 808                 Path path;</span>
<span class="line-added"> 809                 path.moveTo({ drawLeftEdge ? scrollX : scrollX + rulerSize, zoom(y) });</span>
<span class="line-added"> 810 </span>
<span class="line-added"> 811                 float lineLength = 0.0f;</span>
<span class="line-added"> 812                 if (std::fmod(y, rulerStepIncrement)) {</span>
<span class="line-added"> 813                     lineLength = rulerSubStepLength;</span>
<span class="line-added"> 814                     context.setStrokeColor(lightRulerColor);</span>
<span class="line-added"> 815                 } else {</span>
<span class="line-added"> 816                     lineLength = std::fmod(y, rulerStepIncrement * 2) ? rulerSubStepLength : rulerStepLength;</span>
<span class="line-added"> 817                     context.setStrokeColor(darkRulerColor);</span>
<span class="line-added"> 818                 }</span>
<span class="line-added"> 819                 path.addLineTo({ scrollX + (drawLeftEdge ? lineLength : rulerSize - lineLength), zoom(y) });</span>
<span class="line-added"> 820 </span>
<span class="line-added"> 821                 context.strokePath(path);</span>
<span class="line-added"> 822             }</span>
<span class="line-added"> 823 </span>
<span class="line-added"> 824             // Draw labels.</span>
<span class="line-added"> 825             for (float y = multipleBelow(minY, rulerStepIncrement * 2); y &lt; maxY; y += rulerStepIncrement * 2) {</span>
<span class="line-added"> 826                 if (!y &amp;&amp; !scrollY)</span>
<span class="line-added"> 827                     continue;</span>
<span class="line-added"> 828 </span>
<span class="line-added"> 829                 GraphicsContextStateSaver horizontalLabelStateSaver(context);</span>
<span class="line-added"> 830                 context.translate(scrollX, zoom(y) + 0.5f);</span>
<span class="line-added"> 831                 context.rotate(drawLeftEdge ? -piOverTwoFloat : piOverTwoFloat);</span>
<span class="line-added"> 832                 context.drawText(font, TextRun(String::numberToStringFixedPrecision(y)), { 2, drawLeftEdge ? rulerLabelSize : rulerLabelSize - rulerSize });</span>
<span class="line-added"> 833             }</span>
 834         }
 835     }
 836 
<a name="58" id="anc58"></a><span class="line-modified"> 837     // Draw viewport size.</span>
<span class="line-added"> 838     {</span>
<span class="line-added"> 839         FontCascadeDescription fontDescription;</span>
<span class="line-added"> 840         fontDescription.setOneFamily(m_page.settings().sansSerifFontFamily());</span>
<span class="line-added"> 841         fontDescription.setComputedSize(12);</span>
<span class="line-added"> 842 </span>
<span class="line-added"> 843         FontCascade font(WTFMove(fontDescription), 0, 0);</span>
<span class="line-added"> 844         font.update(nullptr);</span>
<span class="line-added"> 845 </span>
<span class="line-added"> 846         auto viewportRect = pageView-&gt;visualViewportRect();</span>
<span class="line-added"> 847         auto viewportWidthText = String::numberToStringFixedPrecision(viewportRect.width() / pageZoomFactor);</span>
<span class="line-added"> 848         auto viewportHeightText = String::numberToStringFixedPrecision(viewportRect.height() / pageZoomFactor);</span>
<span class="line-added"> 849         TextRun viewportTextRun(makeString(viewportWidthText, &quot;px&quot;, &#39; &#39;, multiplicationSign, &#39; &#39;, viewportHeightText, &quot;px&quot;));</span>
<span class="line-added"> 850 </span>
<span class="line-added"> 851         const float margin = 4;</span>
<span class="line-added"> 852         const float padding = 2;</span>
<span class="line-added"> 853         const float radius = 4;</span>
<span class="line-added"> 854         float fontWidth = font.width(viewportTextRun);</span>
<span class="line-added"> 855         float fontHeight = font.fontMetrics().floatHeight();</span>
<span class="line-added"> 856         FloatRect viewportTextRect(margin, margin, (padding * 2.0f) + fontWidth, (padding * 2.0f) + fontHeight);</span>
<span class="line-added"> 857         const auto viewportTextRectCenter = viewportTextRect.center();</span>
<span class="line-added"> 858 </span>
<span class="line-added"> 859         GraphicsContextStateSaver viewportSizeStateSaver(context);</span>
<span class="line-added"> 860 </span>
<span class="line-added"> 861         float leftTranslateX = rulerSize;</span>
<span class="line-added"> 862         float rightTranslateX = 0.0f - (margin * 2.0f) - (padding * 2.0f) - fontWidth;</span>
<span class="line-added"> 863         float translateX = cornerX + (drawLeftEdge ? leftTranslateX : rightTranslateX);</span>
<span class="line-added"> 864 </span>
<span class="line-added"> 865         float topTranslateY = rulerSize;</span>
<span class="line-added"> 866         float bottomTranslateY = 0.0f - (margin * 2.0f) - (padding * 2.0f) - fontHeight;</span>
<span class="line-added"> 867         float translateY = cornerY + (drawTopEdge ? topTranslateY : bottomTranslateY);</span>
<span class="line-added"> 868 </span>
<span class="line-added"> 869         FloatPoint translate(translateX, translateY);</span>
<span class="line-added"> 870         if (rulerExclusion.titlePath.contains(viewportTextRectCenter + translate)) {</span>
<span class="line-added"> 871             // Try the opposite horizontal side.</span>
<span class="line-added"> 872             float oppositeTranslateX = drawLeftEdge ? zoom(width) + rightTranslateX : contentInset.width() + leftTranslateX;</span>
<span class="line-added"> 873             translate.setX(oppositeTranslateX);</span>
<span class="line-added"> 874 </span>
<span class="line-added"> 875             if (rulerExclusion.titlePath.contains(viewportTextRectCenter + translate)) {</span>
<span class="line-added"> 876                 translate.setX(translateX);</span>
<span class="line-added"> 877 </span>
<span class="line-added"> 878                 // Try the opposite vertical side.</span>
<span class="line-added"> 879                 float oppositeTranslateY = drawTopEdge ? zoom(height) + bottomTranslateY : contentInset.height() + topTranslateY;</span>
<span class="line-added"> 880                 translate.setY(oppositeTranslateY);</span>
<span class="line-added"> 881 </span>
<span class="line-added"> 882                 if (rulerExclusion.titlePath.contains(viewportTextRectCenter + translate)) {</span>
<span class="line-added"> 883                     // Try the opposite corner.</span>
<span class="line-added"> 884                     translate.setX(oppositeTranslateX);</span>
<span class="line-added"> 885                 }</span>
<span class="line-added"> 886             }</span>
<span class="line-added"> 887         }</span>
<span class="line-added"> 888         context.translate(translate);</span>
<span class="line-added"> 889 </span>
<span class="line-added"> 890         context.fillRoundedRect(FloatRoundedRect(viewportTextRect, FloatRoundedRect::Radii(radius)), rulerBackgroundColor);</span>
<span class="line-added"> 891 </span>
<span class="line-added"> 892         context.setFillColor(Color::black);</span>
<span class="line-added"> 893         context.drawText(font, viewportTextRun, {margin +  padding, margin + padding + fontHeight - font.fontMetrics().descent() });</span>
<span class="line-added"> 894     }</span>
 895 }
 896 
<a name="59" id="anc59"></a><span class="line-modified"> 897 Path InspectorOverlay::drawElementTitle(GraphicsContext&amp; context, Node&amp; node, const Highlight::Bounds&amp; bounds)</span>
 898 {
<a name="60" id="anc60"></a><span class="line-modified"> 899     if (bounds.isEmpty())</span>
<span class="line-modified"> 900         return { };</span>
 901 
<a name="61" id="anc61"></a><span class="line-modified"> 902     Element* element = effectiveElementForNode(node);</span>
<span class="line-modified"> 903     if (!element)</span>
<span class="line-modified"> 904         return { };</span>




 905 
<a name="62" id="anc62"></a><span class="line-modified"> 906     RenderObject* renderer = node.renderer();</span>
<span class="line-modified"> 907     if (!renderer)</span>
<span class="line-modified"> 908         return { };</span>
<span class="line-modified"> 909 </span>
<span class="line-modified"> 910     String elementTagName = element-&gt;nodeName();</span>
<span class="line-modified"> 911     if (!element-&gt;document().isXHTMLDocument())</span>
<span class="line-modified"> 912         elementTagName = elementTagName.convertToASCIILowercase();</span>
<span class="line-modified"> 913 </span>
<span class="line-modified"> 914     String elementIDValue;</span>
<span class="line-modified"> 915     if (element-&gt;hasID())</span>
<span class="line-modified"> 916         elementIDValue = makeString(&#39;#&#39;, DOMCSSNamespace::escape(element-&gt;getIdAttribute()));</span>
<span class="line-modified"> 917 </span>
<span class="line-modified"> 918     String elementClassValue;</span>
<span class="line-modified"> 919     if (element-&gt;hasClass()) {</span>
<span class="line-modified"> 920         StringBuilder builder;</span>
<span class="line-modified"> 921         DOMTokenList&amp; classList = element-&gt;classList();</span>
<span class="line-modified"> 922         for (size_t i = 0; i &lt; classList.length(); ++i) {</span>
<span class="line-modified"> 923             builder.append(&#39;.&#39;);</span>
<span class="line-added"> 924             builder.append(DOMCSSNamespace::escape(classList.item(i)));</span>
 925         }
<a name="63" id="anc63"></a>

 926 
<a name="64" id="anc64"></a><span class="line-modified"> 927         elementClassValue = builder.toString();</span>
<span class="line-modified"> 928         truncateWithEllipsis(elementClassValue, 50);</span>



 929     }
 930 
<a name="65" id="anc65"></a><span class="line-modified"> 931     String elementPseudoType;</span>
<span class="line-modified"> 932     if (node.isBeforePseudoElement())</span>
<span class="line-modified"> 933         elementPseudoType = &quot;::before&quot;_s;</span>
<span class="line-modified"> 934     else if (node.isAfterPseudoElement())</span>
<span class="line-modified"> 935         elementPseudoType = &quot;::after&quot;_s;</span>
<span class="line-modified"> 936 </span>
<span class="line-modified"> 937     String elementWidth;</span>
<span class="line-modified"> 938     String elementHeight;</span>
<span class="line-modified"> 939     if (is&lt;RenderBoxModelObject&gt;(renderer)) {</span>
<span class="line-modified"> 940         RenderBoxModelObject* modelObject = downcast&lt;RenderBoxModelObject&gt;(renderer);</span>
<span class="line-modified"> 941         elementWidth = String::number(adjustForAbsoluteZoom(roundToInt(modelObject-&gt;offsetWidth()), *modelObject));</span>
<span class="line-modified"> 942         elementHeight = String::number(adjustForAbsoluteZoom(roundToInt(modelObject-&gt;offsetHeight()), *modelObject));</span>
<span class="line-modified"> 943     } else {</span>
<span class="line-modified"> 944         FrameView* containingView = node.document().frame()-&gt;view();</span>
<span class="line-modified"> 945         IntRect boundingBox = snappedIntRect(containingView-&gt;contentsToRootView(renderer-&gt;absoluteBoundingBoxRect()));</span>
<span class="line-modified"> 946         elementWidth = String::number(boundingBox.width());</span>
<span class="line-modified"> 947         elementHeight = String::number(boundingBox.height());</span>

 948     }
 949 
 950     // Need to enable AX to get the computed role.
 951     if (!WebCore::AXObjectCache::accessibilityEnabled())
 952         WebCore::AXObjectCache::enableAccessibility();
 953 
<a name="66" id="anc66"></a><span class="line-modified"> 954     String elementRole;</span>
<span class="line-modified"> 955     if (AXObjectCache* axObjectCache = node.document().axObjectCache()) {</span>
<span class="line-modified"> 956         if (AccessibilityObject* axObject = axObjectCache-&gt;getOrCreate(&amp;node))</span>
<span class="line-added"> 957             elementRole = axObject-&gt;computedRoleString();</span>
 958     }
 959 
<a name="67" id="anc67"></a><span class="line-modified"> 960     FontCascadeDescription fontDescription;</span>
<span class="line-modified"> 961     fontDescription.setFamilies({ &quot;Menlo&quot;, m_page.settings().fixedFontFamily() });</span>
<span class="line-added"> 962     fontDescription.setComputedSize(11);</span>
 963 
<a name="68" id="anc68"></a><span class="line-modified"> 964     FontCascade font(WTFMove(fontDescription), 0, 0);</span>
<span class="line-modified"> 965     font.update(nullptr);</span>


 966 
<a name="69" id="anc69"></a><span class="line-modified"> 967     int fontHeight = font.fontMetrics().height();</span>


 968 
<a name="70" id="anc70"></a><span class="line-modified"> 969     float elementDataWidth;</span>
<span class="line-modified"> 970     float elementDataHeight = fontHeight;</span>
<span class="line-modified"> 971     bool hasSecondLine = !elementRole.isEmpty();</span>
 972 
<a name="71" id="anc71"></a><span class="line-modified"> 973     {</span>
<span class="line-modified"> 974         String firstLine = makeString(elementTagName, elementIDValue, elementClassValue, elementPseudoType, &#39; &#39;, elementWidth, &quot;px&quot;, &#39; &#39;, multiplicationSign, &#39; &#39;, elementHeight, &quot;px&quot;);</span>
<span class="line-added"> 975         String secondLine = makeString(&quot;Role &quot;, elementRole);</span>
 976 
<a name="72" id="anc72"></a><span class="line-modified"> 977         float firstLineWidth = font.width(TextRun(firstLine));</span>
<span class="line-modified"> 978         float secondLineWidth = font.width(TextRun(secondLine));</span>


 979 
<a name="73" id="anc73"></a><span class="line-modified"> 980         elementDataWidth = std::fmax(firstLineWidth, secondLineWidth);</span>
<span class="line-modified"> 981         if (hasSecondLine)</span>
<span class="line-modified"> 982             elementDataHeight += fontHeight;</span>
 983     }
 984 
<a name="74" id="anc74"></a><span class="line-modified"> 985     FrameView* pageView = m_page.mainFrame().view();</span>

 986 
<a name="75" id="anc75"></a><span class="line-modified"> 987     FloatSize viewportSize = pageView-&gt;sizeForVisibleContent();</span>
<span class="line-modified"> 988     viewportSize.expand(-elementDataSpacing, -elementDataSpacing);</span>

 989 
<a name="76" id="anc76"></a><span class="line-modified"> 990     FloatSize contentInset(0, pageView-&gt;topContentInset(ScrollView::TopContentInsetType::WebCoreOrPlatformContentInset));</span>
<span class="line-modified"> 991     contentInset.expand(elementDataSpacing, elementDataSpacing);</span>
<span class="line-modified"> 992     if (m_showRulers || m_showRulersDuringElementSelection)</span>
<span class="line-modified"> 993         contentInset.expand(rulerSize, rulerSize);</span>
<span class="line-modified"> 994 </span>
<span class="line-modified"> 995     float anchorTop = bounds.y();</span>
<span class="line-modified"> 996     float anchorBottom = bounds.maxY();</span>
<span class="line-modified"> 997 </span>
<span class="line-added"> 998     bool renderArrowUp = false;</span>
<span class="line-added"> 999     bool renderArrowDown = false;</span>
<span class="line-added">1000 </span>
<span class="line-added">1001     float boxWidth = elementDataWidth + (elementDataSpacing * 2);</span>
<span class="line-added">1002     float boxHeight = elementDataArrowSize + elementDataHeight + (elementDataSpacing * 2);</span>
<span class="line-added">1003 </span>
<span class="line-added">1004     float boxX = bounds.x();</span>
<span class="line-added">1005     if (boxX &lt; contentInset.width())</span>
<span class="line-added">1006         boxX = contentInset.width();</span>
<span class="line-added">1007     else if (boxX &gt; viewportSize.width() - boxWidth)</span>
<span class="line-added">1008         boxX = viewportSize.width() - boxWidth;</span>
<span class="line-added">1009     else</span>
<span class="line-added">1010         boxX += elementDataSpacing;</span>
<span class="line-added">1011 </span>
<span class="line-added">1012     float boxY;</span>
<span class="line-added">1013     if (anchorTop &gt; viewportSize.height()) {</span>
<span class="line-added">1014         boxY = viewportSize.height() - boxHeight;</span>
<span class="line-added">1015         renderArrowDown = true;</span>
<span class="line-added">1016     } else if (anchorBottom &lt; contentInset.height()) {</span>
<span class="line-added">1017         boxY = contentInset.height() + elementDataArrowSize;</span>
<span class="line-added">1018         renderArrowUp = true;</span>
<span class="line-added">1019     } else if (anchorTop - boxHeight - elementDataSpacing &gt; contentInset.height()) {</span>
<span class="line-added">1020         boxY = anchorTop - boxHeight - elementDataSpacing;</span>
<span class="line-added">1021         renderArrowDown = true;</span>
<span class="line-added">1022     } else if (anchorBottom + boxHeight + elementDataSpacing &lt; viewportSize.height()) {</span>
<span class="line-added">1023         boxY = anchorBottom + elementDataArrowSize + elementDataSpacing;</span>
<span class="line-added">1024         renderArrowUp = true;</span>
<span class="line-added">1025     } else {</span>
<span class="line-added">1026         boxY = contentInset.height();</span>
<span class="line-added">1027         renderArrowDown = true;</span>
1028     }
1029 
<a name="77" id="anc77"></a><span class="line-modified">1030     Path path;</span>
<span class="line-modified">1031     path.moveTo({ boxX, boxY });</span>
<span class="line-added">1032     if (renderArrowUp) {</span>
<span class="line-added">1033         path.addLineTo({ boxX + (elementDataArrowSize * 2), boxY });</span>
<span class="line-added">1034         path.addLineTo({ boxX + (elementDataArrowSize * 3), boxY - elementDataArrowSize });</span>
<span class="line-added">1035         path.addLineTo({ boxX + (elementDataArrowSize * 4), boxY });</span>
<span class="line-added">1036     }</span>
<span class="line-added">1037     path.addLineTo({ boxX + elementDataWidth + (elementDataSpacing * 2), boxY });</span>
<span class="line-added">1038     path.addLineTo({ boxX + elementDataWidth + (elementDataSpacing * 2), boxY + elementDataHeight + (elementDataSpacing * 2) });</span>
<span class="line-added">1039     if (renderArrowDown) {</span>
<span class="line-added">1040         path.addLineTo({ boxX + (elementDataArrowSize * 4), boxY + elementDataHeight + (elementDataSpacing * 2) });</span>
<span class="line-added">1041         path.addLineTo({ boxX + (elementDataArrowSize * 3), boxY + elementDataHeight + (elementDataSpacing * 2) + elementDataArrowSize });</span>
<span class="line-added">1042         path.addLineTo({ boxX + (elementDataArrowSize * 2), boxY + elementDataHeight + (elementDataSpacing * 2) });</span>
<span class="line-added">1043     }</span>
<span class="line-added">1044     path.addLineTo({ boxX, boxY + elementDataHeight + (elementDataSpacing * 2) });</span>
<span class="line-added">1045     path.closeSubpath();</span>
1046 
<a name="78" id="anc78"></a><span class="line-modified">1047     GraphicsContextStateSaver stateSaver(context);</span>




1048 
<a name="79" id="anc79"></a><span class="line-modified">1049     context.translate(elementDataBorderSize / 2.0f, elementDataBorderSize / 2.0f);</span>



1050 
<a name="80" id="anc80"></a><span class="line-modified">1051     const Color elementTitleBackgroundColor(255, 255, 194);</span>
<span class="line-modified">1052     context.setFillColor(elementTitleBackgroundColor);</span>


































































1053 
<a name="81" id="anc81"></a><span class="line-modified">1054     context.fillPath(path);</span>












1055 
<a name="82" id="anc82"></a><span class="line-modified">1056     context.setStrokeThickness(elementDataBorderSize);</span>



1057 
<a name="83" id="anc83"></a><span class="line-modified">1058     const Color elementTitleBorderColor(128, 128, 128);</span>
<span class="line-modified">1059     context.setStrokeColor(elementTitleBorderColor);</span>
1060 
<a name="84" id="anc84"></a><span class="line-modified">1061     context.strokePath(path);</span>



1062 
<a name="85" id="anc85"></a><span class="line-modified">1063     float textPositionX = boxX + elementDataSpacing;</span>
<span class="line-modified">1064     float textPositionY = boxY - (elementDataSpacing / 2.0f) + fontHeight;</span>
<span class="line-added">1065     const auto drawText = [&amp;] (const String&amp; text, const Color&amp; color) {</span>
<span class="line-added">1066         if (text.isEmpty())</span>
<span class="line-added">1067             return;</span>
1068 
<a name="86" id="anc86"></a><span class="line-modified">1069         context.setFillColor(color);</span>
<span class="line-modified">1070         textPositionX += context.drawText(font, TextRun(text), { textPositionX, textPositionY });</span>
<span class="line-modified">1071     };</span>


1072 
<a name="87" id="anc87"></a><span class="line-modified">1073     drawText(elementTagName, Color(136, 18, 128)); // Keep this in sync with XMLViewer.css (.tag)</span>
<span class="line-modified">1074     drawText(elementIDValue, Color(26, 26, 166)); // Keep this in sync with XMLViewer.css (.attribute-value)</span>
<span class="line-added">1075     drawText(elementClassValue, Color(153, 69, 0)); // Keep this in sync with XMLViewer.css (.attribute-name)</span>
<span class="line-added">1076     drawText(elementPseudoType, Color(136, 18, 128)); // Keep this in sync with XMLViewer.css (.tag)</span>
<span class="line-added">1077     drawText(&quot; &quot;_s, Color::black);</span>
<span class="line-added">1078     drawText(elementWidth, Color::black);</span>
<span class="line-added">1079     drawText(&quot;px&quot;_s, Color::darkGray);</span>
<span class="line-added">1080     drawText(&quot; &quot;_s, Color::darkGray);</span>
<span class="line-added">1081     drawText(makeString(multiplicationSign), Color::darkGray);</span>
<span class="line-added">1082     drawText(&quot; &quot;_s, Color::darkGray);</span>
<span class="line-added">1083     drawText(elementHeight, Color::black);</span>
<span class="line-added">1084     drawText(&quot;px&quot;_s, Color::darkGray);</span>
1085 
<a name="88" id="anc88"></a><span class="line-modified">1086     if (hasSecondLine) {</span>
<span class="line-modified">1087         textPositionX = boxX + elementDataSpacing;</span>
<span class="line-modified">1088         textPositionY += fontHeight;</span>


1089 
<a name="89" id="anc89"></a><span class="line-modified">1090         drawText(&quot;Role&quot;_s, Color(170, 13, 145));</span>
<span class="line-modified">1091         drawText(&quot; &quot;_s, Color::black);</span>
<span class="line-added">1092         drawText(elementRole, Color::black);</span>
<span class="line-added">1093     }</span>
1094 
<a name="90" id="anc90"></a><span class="line-modified">1095     return path;</span>


1096 }
1097 
1098 } // namespace WebCore
<a name="91" id="anc91"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="91" type="hidden" />
</body>
</html>