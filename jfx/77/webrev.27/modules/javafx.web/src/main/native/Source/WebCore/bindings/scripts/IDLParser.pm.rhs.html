<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/bindings/scripts/IDLParser.pm</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 # 
   2 # KDOM IDL parser
   3 #
   4 # Copyright (C) 2005 Nikolas Zimmermann &lt;wildfox@kde.org&gt;
   5 # 
   6 # This library is free software; you can redistribute it and/or
   7 # modify it under the terms of the GNU Library General Public
   8 # License as published by the Free Software Foundation; either
   9 # version 2 of the License, or (at your option) any later version.
  10 # 
  11 # This library is distributed in the hope that it will be useful,
  12 # but WITHOUT ANY WARRANTY; without even the implied warranty of
  13 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  14 # Library General Public License for more details.
  15 # 
  16 # You should have received a copy of the GNU Library General Public License
  17 # along with this library; see the file COPYING.LIB.  If not, write to
  18 # the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  19 # Boston, MA 02110-1301, USA.
  20 # 
  21 
  22 package IDLParser;
  23 
  24 use strict;
  25 
  26 use Carp qw&lt;longmess&gt;;
  27 use Data::Dumper;
  28 
  29 use preprocessor;
  30 use Class::Struct;
  31 
  32 use constant StringToken =&gt; 0;
  33 use constant IntegerToken =&gt; 1;
  34 use constant FloatToken =&gt; 2;
  35 use constant IdentifierToken =&gt; 3;
  36 use constant OtherToken =&gt; 4;
  37 use constant EmptyToken =&gt; 5;
  38 
  39 # Used to represent a parsed IDL document
  40 struct( IDLDocument =&gt; {
  41     interfaces =&gt; &#39;@&#39;, # List of &#39;IDLInterface&#39;
  42     enumerations =&gt; &#39;@&#39;, # List of &#39;IDLEnum&#39;
  43     dictionaries =&gt; &#39;@&#39;, # List of &#39;IDLDictionary&#39;
  44     callbackFunctions =&gt; &#39;@&#39;, # List of &#39;IDLCallbackFunction&#39;
  45     fileName =&gt; &#39;$&#39;,
  46 });
  47 
  48 # https://heycam.github.io/webidl/#idl-types
  49 struct( IDLType =&gt; {
  50     name =&gt;         &#39;$&#39;, # Type identifier
  51     isNullable =&gt;   &#39;$&#39;, # Is the type Nullable (T?)
  52     isUnion =&gt;      &#39;$&#39;, # Is the type a union (T or U)
  53     subtypes =&gt;     &#39;@&#39;, # Array of subtypes, only valid if isUnion or sequence
  54     extendedAttributes =&gt; &#39;%&#39;,
  55 });
  56 
  57 # Used to represent &#39;interface&#39; blocks
  58 struct( IDLInterface =&gt; {
  59     type =&gt; &#39;IDLType&#39;,
  60     parentType =&gt; &#39;IDLType&#39;,
  61     constants =&gt; &#39;@&#39;,    # List of &#39;IDLConstant&#39;
  62     operations =&gt; &#39;@&#39;,    # List of &#39;IDLOperation&#39;
  63     anonymousOperations =&gt; &#39;@&#39;, # List of &#39;IDLOperation&#39;
  64     attributes =&gt; &#39;@&#39;,    # List of &#39;IDLAttribute&#39;
  65     constructors =&gt; &#39;@&#39;, # Constructors, list of &#39;IDLOperation&#39;
  66     customConstructors =&gt; &#39;@&#39;, # Custom constructors, list of &#39;IDLOperation&#39;
  67     isException =&gt; &#39;$&#39;, # Used for exception interfaces
  68     isCallback =&gt; &#39;$&#39;, # Used for callback interfaces
  69     isPartial =&gt; &#39;$&#39;, # Used for partial interfaces
  70     iterable =&gt; &#39;$&#39;, # Used for iterable interfaces
  71     mapLike =&gt; &#39;$&#39;, # Used for mapLike interfaces
  72     serializable =&gt; &#39;$&#39;, # Used for serializable interfaces
  73     extendedAttributes =&gt; &#39;$&#39;,
  74 });
  75 
  76 # Used to represent an argument to a IDLOperation.
  77 struct( IDLArgument =&gt; {
  78     name =&gt; &#39;$&#39;,
  79     type =&gt; &#39;IDLType&#39;,
  80     isVariadic =&gt; &#39;$&#39;,
  81     isOptional =&gt; &#39;$&#39;,
  82     default =&gt; &#39;$&#39;,
  83     extendedAttributes =&gt; &#39;%&#39;,
  84 });
  85 
  86 # https://heycam.github.io/webidl/#idl-operations
  87 struct( IDLOperation =&gt; {
  88     name =&gt; &#39;$&#39;,
  89     type =&gt; &#39;IDLType&#39;, # Return type
  90     arguments =&gt; &#39;@&#39;, # List of &#39;IDLArgument&#39;
  91     isStatic =&gt; &#39;$&#39;,
  92     isIterable =&gt; &#39;$&#39;,
  93     isSerializer =&gt; &#39;$&#39;,
  94     isStringifier =&gt; &#39;$&#39;,
  95     isMapLike =&gt; &#39;$&#39;,
  96     specials =&gt; &#39;@&#39;,
  97     extendedAttributes =&gt; &#39;%&#39;,
  98 });
  99 
 100 
 101 # https://heycam.github.io/webidl/#idl-attributes
 102 struct( IDLAttribute =&gt; {
 103     name =&gt; &#39;$&#39;,
 104     type =&gt; &#39;IDLType&#39;,
 105     isStatic =&gt; &#39;$&#39;,
 106     isMapLike =&gt; &#39;$&#39;,
 107     isStringifier =&gt; &#39;$&#39;,
 108     isReadOnly =&gt; &#39;$&#39;,
 109     isInherit =&gt; &#39;$&#39;,
 110     extendedAttributes =&gt; &#39;$&#39;,
 111 });
 112 
 113 # https://heycam.github.io/webidl/#idl-iterable
 114 struct( IDLIterable =&gt; {
 115     isKeyValue =&gt; &#39;$&#39;,
 116     keyType =&gt; &#39;IDLType&#39;,
 117     valueType =&gt; &#39;IDLType&#39;,
 118     operations =&gt; &#39;@&#39;, # Iterable operations (entries, keys, values, [Symbol.Iterator], forEach)
 119     extendedAttributes =&gt; &#39;$&#39;,
 120 });
 121 
 122 # https://heycam.github.io/webidl/#es-maplike
 123 struct( IDLMapLike =&gt; {
 124     isReadOnly =&gt; &#39;$&#39;,
 125     keyType =&gt; &#39;IDLType&#39;,
 126     valueType =&gt; &#39;IDLType&#39;,
 127     attributes =&gt; &#39;@&#39;, # MapLike attributes (size)
 128     operations =&gt; &#39;@&#39;, # MapLike operations (entries, keys, values, forEach, get, has and if not readonly, delete, set and clear)
 129     extendedAttributes =&gt; &#39;$&#39;,
 130 });
 131 
 132 # https://heycam.github.io/webidl/#idl-serializers
 133 struct( IDLSerializable =&gt; {
 134     attributes =&gt; &#39;@&#39;, # List of attributes to serialize
 135     hasAttribute =&gt; &#39;$&#39;, # serializer = { attribute }
 136     hasInherit =&gt; &#39;$&#39;, # serializer = { inherit }
 137     hasGetter =&gt; &#39;$&#39;, # serializer = { getter }
 138     operations =&gt; &#39;@&#39;, # toJSON operation
 139 });
 140 
 141 # https://heycam.github.io/webidl/#idl-constants
 142 struct( IDLConstant =&gt; {
 143     name =&gt; &#39;$&#39;,
 144     type =&gt; &#39;IDLType&#39;,
 145     value =&gt; &#39;$&#39;,
 146     extendedAttributes =&gt; &#39;$&#39;,
 147 });
 148 
 149 # https://heycam.github.io/webidl/#idl-enums
 150 struct( IDLEnum =&gt; {
 151     name =&gt; &#39;$&#39;,
 152     type =&gt; &#39;IDLType&#39;,
 153     values =&gt; &#39;@&#39;,
 154     extendedAttributes =&gt; &#39;$&#39;,
 155 });
 156 
 157 # https://heycam.github.io/webidl/#dfn-dictionary-member
 158 struct( IDLDictionaryMember =&gt; {
 159     name =&gt; &#39;$&#39;,
 160     type =&gt; &#39;IDLType&#39;,
 161     isRequired =&gt; &#39;$&#39;,
 162     default =&gt; &#39;$&#39;,
 163     extendedAttributes =&gt; &#39;$&#39;,
 164 });
 165 
 166 # https://heycam.github.io/webidl/#idl-dictionaries
 167 struct( IDLDictionary =&gt; {
 168     type =&gt; &#39;IDLType&#39;,
 169     parentType =&gt; &#39;IDLType&#39;,
 170     members =&gt; &#39;@&#39;, # List of &#39;IDLDictionaryMember&#39;
 171     extendedAttributes =&gt; &#39;$&#39;,
<a name="1" id="anc1"></a><span class="line-added"> 172     isPartial =&gt; &#39;$&#39;, # Used for partial interfaces</span>
 173 });
 174 
 175 # https://heycam.github.io/webidl/#idl-callback-functions
 176 struct( IDLCallbackFunction =&gt; {
 177     type =&gt; &#39;$&#39;,
 178     operation =&gt; &#39;IDLOperation&#39;,
 179     extendedAttributes =&gt; &#39;$&#39;,
 180 });
 181 
 182 # https://heycam.github.io/webidl/#idl-typedefs
 183 struct( IDLTypedef =&gt; {
 184     type =&gt; &#39;IDLType&#39;,
 185 });
 186 
 187 struct( Token =&gt; {
 188     type =&gt; &#39;$&#39;, # type of token
 189     value =&gt; &#39;$&#39; # value of token
 190 });
 191 
 192 # Maps &#39;typedef name&#39; -&gt; Typedef
 193 my %typedefs = ();
 194 
 195 sub new {
 196     my $class = shift;
 197 
 198     my $emptyToken = Token-&gt;new();
 199     $emptyToken-&gt;type(EmptyToken);
 200     $emptyToken-&gt;value(&quot;empty&quot;);
 201 
 202     my $self = {
 203         DocumentContent =&gt; &quot;&quot;,
 204         EmptyToken =&gt; $emptyToken,
 205         NextToken =&gt; $emptyToken,
 206         Token =&gt; $emptyToken,
 207         Line =&gt; &quot;&quot;,
 208         LineNumber =&gt; 1,
 209         ExtendedAttributeMap =&gt; &quot;&quot;
 210     };
 211     return bless $self, $class;
 212 }
 213 
 214 sub assert
 215 {
 216     my $message = shift;
 217 
 218     my $mess = longmess();
 219     print Dumper($mess);
 220 
 221     die $message;
 222 }
 223 
 224 sub assertTokenValue
 225 {
 226     my $self = shift;
 227     my $token = shift;
 228     my $value = shift;
 229     my $line = shift;
 230     my $msg = &quot;Next token should be &quot; . $value . &quot;, but &quot; . $token-&gt;value() . &quot; on line &quot; . $self-&gt;{Line};
 231     if (defined ($line)) {
 232         $msg .= &quot; IDLParser.pm:&quot; . $line;
 233     }
 234 
 235     assert $msg unless $token-&gt;value() eq $value;
 236 }
 237 
 238 sub assertTokenType
 239 {
 240     my $self = shift;
 241     my $token = shift;
 242     my $type = shift;
 243     
 244     assert &quot;Next token&#39;s type should be &quot; . $type . &quot;, but &quot; . $token-&gt;type() . &quot; on line &quot; . $self-&gt;{Line} unless $token-&gt;type() eq $type;
 245 }
 246 
 247 sub assertUnexpectedToken
 248 {
 249     my $self = shift;
 250     my $token = shift;
 251     my $line = shift;
 252     my $msg = &quot;Unexpected token &quot; . $token . &quot; on line &quot; . $self-&gt;{Line};
 253     if (defined ($line)) {
 254         $msg .= &quot; IDLParser.pm:&quot; . $line;
 255     }
 256 
 257     assert $msg;
 258 }
 259 
 260 sub assertExtendedAttributesValidForContext
 261 {
 262     my $self = shift;
 263     my $extendedAttributeList = shift;
 264     my @contexts = @_;
 265 
 266     for my $extendedAttribute (keys %{$extendedAttributeList}) {
 267         # FIXME: Should this be done here, or when parsing the exteded attribute itself?
 268         # Either way, we should add validation of the values, if any, at the same place.
 269 
 270         # Extended attribute parsing collapses multiple &#39;Constructor&#39; or &#39;CustomConstructor&#39;
 271         # attributes into a single plural version. Eventually, it would be nice if that conversion
 272         # hapened later, and the parser kept things relatively simply, but for now, we just undo
 273         # this transformation for the type check.
 274         if ($extendedAttribute eq &quot;Constructors&quot;) {
 275             $extendedAttribute = &quot;Constructor&quot;;
 276         } elsif ($extendedAttribute eq &quot;CustomConstructors&quot;) {
 277             $extendedAttribute = &quot;CustomConstructor&quot;;
 278         }
 279 
 280         if (!exists $self-&gt;{ExtendedAttributeMap}-&gt;{$extendedAttribute}) {
 281             assert &quot;Unknown extended attribute: &#39;${extendedAttribute}&#39;&quot;;
 282         }
 283 
 284         my $foundAllowedContext = 0;
 285         for my $contextAllowed (@{$self-&gt;{ExtendedAttributeMap}-&gt;{$extendedAttribute}-&gt;{&quot;contextsAllowed&quot;}}) {
 286             for my $context (@contexts) {
 287                 if ($contextAllowed eq $context) {
 288                     $foundAllowedContext = 1;
 289                     last;
 290                 }
 291             }
 292         }
 293 
 294         if (!$foundAllowedContext) {
 295             if (scalar(@contexts) == 1) {
 296                 assert &quot;Extended attribute &#39;${extendedAttribute}&#39; used in invalid context &#39;&quot; . $contexts[0] . &quot;&#39;&quot;;
 297             } else {
 298                 # FIXME: Improved this error message a bit.
 299                 assert &quot;Extended attribute &#39;${extendedAttribute}&#39; used in invalid context&quot;;
 300             }
 301         }
 302     }
 303 }
 304 
 305 sub Parse
 306 {
 307     my $self = shift;
 308     my $fileName = shift;
 309     my $defines = shift;
 310     my $preprocessor = shift;
 311     my $idlAttributes = shift;
 312 
 313     my @definitions = ();
 314 
 315     my @lines = applyPreprocessor($fileName, $defines, $preprocessor);
 316     $self-&gt;{Line} = $lines[0];
 317     $self-&gt;{DocumentContent} = join(&#39; &#39;, @lines);
 318     $self-&gt;{ExtendedAttributeMap} = $idlAttributes;
 319 
 320     addBuiltinTypedefs();
 321 
 322     $self-&gt;getToken();
 323     eval {
 324         my $result = $self-&gt;parseDefinitions();
 325         push(@definitions, @{$result});
 326 
 327         my $next = $self-&gt;nextToken();
 328         $self-&gt;assertTokenType($next, EmptyToken);
 329     };
 330     assert $@ . &quot; in $fileName&quot; if $@;
 331 
 332     my $document = IDLDocument-&gt;new();
 333     $document-&gt;fileName($fileName);
 334     foreach my $definition (@definitions) {
 335         if (ref($definition) eq &quot;IDLInterface&quot;) {
 336             push(@{$document-&gt;interfaces}, $definition);
 337         } elsif (ref($definition) eq &quot;IDLEnum&quot;) {
 338             push(@{$document-&gt;enumerations}, $definition);
 339         } elsif (ref($definition) eq &quot;IDLDictionary&quot;) {
 340             push(@{$document-&gt;dictionaries}, $definition);
 341         } elsif (ref($definition) eq &quot;IDLCallbackFunction&quot;) {
 342             push(@{$document-&gt;callbackFunctions}, $definition);
 343         } else {
 344             die &quot;Unrecognized IDL definition kind: \&quot;&quot; . ref($definition) . &quot;\&quot;&quot;;
 345         }
 346     }
 347     return $document;
 348 }
 349 
 350 sub ParseType
 351 {
 352     my ($self, $type, $idlAttributes) = @_;
 353 
 354     $self-&gt;{Line} = $type;
 355     $self-&gt;{DocumentContent} = $type;
 356     $self-&gt;{ExtendedAttributeMap} = $idlAttributes;
 357 
 358     addBuiltinTypedefs();
 359 
 360     my $result;
 361 
 362     $self-&gt;getToken();
 363     eval {
 364         $result = $self-&gt;parseType();
 365 
 366         my $next = $self-&gt;nextToken();
 367         $self-&gt;assertTokenType($next, EmptyToken);
 368     };
 369     assert $@ . &quot; parsing type ${type}&quot; if $@;
 370 
 371     return $result;
 372 }
 373 
 374 sub nextToken
 375 {
 376     my $self = shift;
 377     return $self-&gt;{NextToken};
 378 }
 379 
 380 sub getToken
 381 {
 382     my $self = shift;
 383     $self-&gt;{Token} = $self-&gt;{NextToken};
 384     $self-&gt;{NextToken} = $self-&gt;getTokenInternal();
 385     return $self-&gt;{Token};
 386 }
 387 
 388 my $whitespaceTokenPattern = &#39;^[\t\n\r ]*[\n\r]&#39;;
 389 my $floatTokenPattern = &#39;^(-?(([0-9]+\.[0-9]*|[0-9]*\.[0-9]+)([Ee][+-]?[0-9]+)?|[0-9]+[Ee][+-]?[0-9]+))&#39;;
 390 my $integerTokenPattern = &#39;^(-?[1-9][0-9]*|-?0[Xx][0-9A-Fa-f]+|-?0[0-7]*)&#39;;
 391 my $stringTokenPattern = &#39;^(\&quot;[^\&quot;]*\&quot;)&#39;;
 392 my $identifierTokenPattern = &#39;^([A-Z_a-z][0-9A-Z_a-z]*)&#39;;
 393 my $otherTokenPattern = &#39;^(\.\.\.|[^\t\n\r 0-9A-Z_a-z])&#39;;
 394 
 395 sub getTokenInternal
 396 {
 397     my $self = shift;
 398 
 399     if ($self-&gt;{DocumentContent} =~ /$whitespaceTokenPattern/) {
 400         $self-&gt;{DocumentContent} =~ s/($whitespaceTokenPattern)//;
 401         my $skipped = $1;
 402         $self-&gt;{LineNumber}++ while ($skipped =~ /\n/g);
 403         if ($self-&gt;{DocumentContent} =~ /^([^\n\r]+)/) {
 404             $self-&gt;{Line} = $self-&gt;{LineNumber} . &quot;:&quot; . $1;
 405         } else {
 406             $self-&gt;{Line} = &quot;Unknown&quot;;
 407         }
 408     }
 409     $self-&gt;{DocumentContent} =~ s/^([\t\n\r ]+)//;
 410     if ($self-&gt;{DocumentContent} eq &quot;&quot;) {
 411         return $self-&gt;{EmptyToken};
 412     }
 413 
 414     my $token = Token-&gt;new();
 415     if ($self-&gt;{DocumentContent} =~ /$floatTokenPattern/) {
 416         $token-&gt;type(FloatToken);
 417         $token-&gt;value($1);
 418         $self-&gt;{DocumentContent} =~ s/$floatTokenPattern//;
 419         return $token;
 420     }
 421     if ($self-&gt;{DocumentContent} =~ /$integerTokenPattern/) {
 422         $token-&gt;type(IntegerToken);
 423         $token-&gt;value($1);
 424         $self-&gt;{DocumentContent} =~ s/$integerTokenPattern//;
 425         return $token;
 426     }
 427     if ($self-&gt;{DocumentContent} =~ /$stringTokenPattern/) {
 428         $token-&gt;type(StringToken);
 429         $token-&gt;value($1);
 430         $self-&gt;{DocumentContent} =~ s/$stringTokenPattern//;
 431         return $token;
 432     }
 433     if ($self-&gt;{DocumentContent} =~ /$identifierTokenPattern/) {
 434         $token-&gt;type(IdentifierToken);
 435         $token-&gt;value($1);
 436         $self-&gt;{DocumentContent} =~ s/$identifierTokenPattern//;
 437         return $token;
 438     }
 439     if ($self-&gt;{DocumentContent} =~ /$otherTokenPattern/) {
 440         $token-&gt;type(OtherToken);
 441         $token-&gt;value($1);
 442         $self-&gt;{DocumentContent} =~ s/$otherTokenPattern//;
 443         return $token;
 444     }
 445     die &quot;Failed in tokenizing at &quot; . $self-&gt;{Line};
 446 }
 447 
 448 sub unquoteString
 449 {
 450     my $self = shift;
 451     my $quotedString = shift;
 452     if ($quotedString =~ /^&quot;([^&quot;]*)&quot;$/) {
 453         return $1;
 454     }
 455     die &quot;Failed to parse string (&quot; . $quotedString . &quot;) at &quot; . $self-&gt;{Line};
 456 }
 457 
 458 sub identifierRemoveNullablePrefix
 459 {
 460     my $type = shift;
 461     $type =~ s/^_//;
 462     return $type;
 463 }
 464 
 465 sub copyExtendedAttributes
 466 {
 467     my $extendedAttributeList = shift;
 468     my $attr = shift;
 469 
 470     for my $key (keys %{$attr}) {
 471         if ($key eq &quot;Constructor&quot;) {
 472             push(@{$extendedAttributeList-&gt;{&quot;Constructors&quot;}}, $attr-&gt;{$key});
 473         } elsif ($key eq &quot;Constructors&quot;) {
 474             my @constructors = @{$attr-&gt;{$key}};
 475             foreach my $constructor (@constructors) {
 476                 push(@{$extendedAttributeList-&gt;{&quot;Constructors&quot;}}, $constructor);
 477             }
 478         } elsif ($key eq &quot;CustomConstructor&quot;) {
 479             push(@{$extendedAttributeList-&gt;{&quot;CustomConstructors&quot;}}, $attr-&gt;{$key});
 480         } elsif ($key eq &quot;CustomConstructors&quot;) {
 481            my @customConstructors = @{$attr-&gt;{$key}};
 482             foreach my $customConstructor (@customConstructors) {
 483                 push(@{$extendedAttributeList-&gt;{&quot;CustomConstructors&quot;}}, $customConstructor);
 484             }
 485         } else {
 486             $extendedAttributeList-&gt;{$key} = $attr-&gt;{$key};
 487         }
 488     }
 489 }
 490 
 491 sub isExtendedAttributeApplicableToTypes
 492 {
 493     my $self = shift;
 494     my $extendedAttribute = shift;
 495 
 496     if (!exists $self-&gt;{ExtendedAttributeMap}-&gt;{$extendedAttribute}) {
 497         assert &quot;Unknown extended attribute: &#39;${extendedAttribute}&#39;&quot;;
 498     }
 499 
 500     for my $contextAllowed (@{$self-&gt;{ExtendedAttributeMap}-&gt;{$extendedAttribute}-&gt;{&quot;contextsAllowed&quot;}}) {
 501         if ($contextAllowed eq &quot;type&quot;) {
 502             return 1;
 503         }
 504     }
 505 
 506     return 0;
 507 }
 508 
 509 sub moveExtendedAttributesApplicableToTypes
 510 {
 511     my $self = shift;
 512     my $type = shift;
 513     my $extendedAttributeList = shift;
 514 
 515     for my $key (keys %{$extendedAttributeList}) {
 516         if ($self-&gt;isExtendedAttributeApplicableToTypes($key)) {
 517             if (!defined $type-&gt;extendedAttributes-&gt;{$key}) {
 518                 $type-&gt;extendedAttributes-&gt;{$key} = $extendedAttributeList-&gt;{$key};
 519             }
 520             delete $extendedAttributeList-&gt;{$key};
 521         }
 522     }
 523 }
 524 
 525 sub typeDescription
 526 {
 527     my $type = shift;
 528 
 529     if (scalar @{$type-&gt;subtypes}) {
 530         return $type-&gt;name . &#39;&lt;&#39; . join(&#39;, &#39;, map { typeDescription($_) } @{$type-&gt;subtypes}) . &#39;&gt;&#39; . ($type-&gt;isNullable ? &quot;?&quot; : &quot;&quot;);
 531     }
 532 
 533     return $type-&gt;name . ($type-&gt;isNullable ? &quot;?&quot; : &quot;&quot;);
 534 }
 535 
 536 sub cloneType
 537 {
 538     my $type = shift;
 539 
 540     my $clonedType = IDLType-&gt;new();
 541     $clonedType-&gt;name($type-&gt;name);
 542     $clonedType-&gt;isNullable($type-&gt;isNullable);
 543     $clonedType-&gt;isUnion($type-&gt;isUnion);
 544 
 545     copyExtendedAttributes($clonedType-&gt;extendedAttributes, $type-&gt;extendedAttributes);
 546 
 547     foreach my $subtype (@{$type-&gt;subtypes}) {
 548         push(@{$clonedType-&gt;subtypes}, cloneType($subtype));
 549     }
 550 
 551     return $clonedType;
 552 }
 553 
 554 sub cloneArgument
 555 {
 556     my $argument = shift;
 557 
 558     my $clonedArgument = IDLArgument-&gt;new();
 559     $clonedArgument-&gt;name($argument-&gt;name);
 560     $clonedArgument-&gt;type(cloneType($argument-&gt;type));
 561     $clonedArgument-&gt;isVariadic($argument-&gt;isVariadic);
 562     $clonedArgument-&gt;isOptional($argument-&gt;isOptional);
 563     $clonedArgument-&gt;default($argument-&gt;default);
 564     copyExtendedAttributes($clonedArgument-&gt;extendedAttributes, $argument-&gt;extendedAttributes);
 565 
 566     return $clonedArgument;
 567 }
 568 
 569 sub cloneOperation
 570 {
 571     my $operation = shift;
 572 
 573     my $clonedOperation = IDLOperation-&gt;new();
 574     $clonedOperation-&gt;name($operation-&gt;name);
 575     $clonedOperation-&gt;type(cloneType($operation-&gt;type));
 576     
 577     foreach my $argument (@{$operation-&gt;arguments}) {
 578         push(@{$clonedOperation-&gt;arguments}, cloneArgument($argument));
 579     }
 580 
 581     $clonedOperation-&gt;isStatic($operation-&gt;isStatic);
 582     $clonedOperation-&gt;isIterable($operation-&gt;isIterable);
 583     $clonedOperation-&gt;isSerializer($operation-&gt;isSerializer);
 584     $clonedOperation-&gt;isStringifier($operation-&gt;isStringifier);
 585     $clonedOperation-&gt;isMapLike($operation-&gt;isMapLike);
 586     $clonedOperation-&gt;specials($operation-&gt;specials);
 587 
 588     copyExtendedAttributes($clonedOperation-&gt;extendedAttributes, $operation-&gt;extendedAttributes);
 589 
 590     return $clonedOperation;
 591 }
 592 
 593 sub makeSimpleType
 594 {
 595     my $typeName = shift;
 596 
 597     return IDLType-&gt;new(name =&gt; $typeName);
 598 }
 599 
 600 sub addBuiltinTypedefs()
 601 {
 602     # NOTE: This leaves out the ArrayBufferView definition as it is
 603     # treated as its own type, and not a union, to allow us to utilize
 604     # the shared base class all the members of the union have.
 605 
 606     # typedef (ArrayBufferView or ArrayBuffer) BufferSource;
 607 
 608     my $bufferSourceType = IDLType-&gt;new(name =&gt; &quot;UNION&quot;, isUnion =&gt; 1);
 609     push(@{$bufferSourceType-&gt;subtypes}, makeSimpleType(&quot;ArrayBufferView&quot;));
 610     push(@{$bufferSourceType-&gt;subtypes}, makeSimpleType(&quot;ArrayBuffer&quot;));
 611     $typedefs{&quot;BufferSource&quot;} = IDLTypedef-&gt;new(type =&gt; $bufferSourceType);
 612 
 613     # typedef unsigned long long DOMTimeStamp;
 614 
 615     my $DOMTimeStampType = IDLType-&gt;new(name =&gt; &quot;unsigned long long&quot;);
 616     $typedefs{&quot;DOMTimeStamp&quot;} = IDLTypedef-&gt;new(type =&gt; $DOMTimeStampType);
 617 }
 618 
 619 my $nextAttribute_1 = &#39;^(attribute|inherit)$&#39;;
 620 my $nextAttribute_2 = &#39;^(readonly|attribute)$&#39;;
 621 my $nextPrimitiveType_1 = &#39;^(int|long|short|unsigned)$&#39;;
 622 my $nextPrimitiveType_2 = &#39;^(double|float|unrestricted)$&#39;;
 623 my $nextArgumentList_1 = &#39;^(\(|ByteString|DOMString|USVString|Date|\[|any|boolean|byte|double|float|in|long|object|octet|optional|sequence|short|unrestricted|unsigned)$&#39;;
 624 my $nextNonAnyType_1 = &#39;^(boolean|byte|double|float|long|octet|short|unrestricted|unsigned)$&#39;;
 625 my $nextStringType_1 = &#39;^(ByteString|DOMString|USVString)$&#39;;
 626 my $nextInterfaceMember_1 = &#39;^(\(|ByteString|DOMString|USVString|Date|any|attribute|boolean|byte|deleter|double|float|getter|inherit|legacycaller|long|object|octet|readonly|sequence|setter|short|unrestricted|unsigned|void)$&#39;;
 627 my $nextOperation_1 = &#39;^(\(|ByteString|DOMString|USVString|Date|any|boolean|byte|deleter|double|float|getter|legacycaller|long|object|octet|sequence|setter|short|unrestricted|unsigned|void)$&#39;;
 628 my $nextUnrestrictedFloatType_1 = &#39;^(double|float)$&#39;;
 629 my $nextExtendedAttributeRest3_1 = &#39;^(\,|\])$&#39;;
 630 my $nextExceptionField_1 = &#39;^(\(|ByteString|DOMString|USVString|Date|any|boolean|byte|double|float|long|object|octet|sequence|short|unrestricted|unsigned)$&#39;;
 631 my $nextType_1 = &#39;^(ByteString|DOMString|USVString|Date|any|boolean|byte|double|float|long|object|octet|sequence|short|unrestricted|unsigned)$&#39;;
 632 my $nextSpecials_1 = &#39;^(deleter|getter|legacycaller|setter)$&#39;;
 633 my $nextDefinitions_1 = &#39;^(callback|dictionary|enum|exception|interface|partial|typedef)$&#39;;
 634 my $nextExceptionMembers_1 = &#39;^(\(|ByteString|DOMString|USVString|Date|\[|any|boolean|byte|const|double|float|long|object|octet|optional|sequence|short|unrestricted|unsigned)$&#39;;
 635 my $nextInterfaceMembers_1 = &#39;^(\(|ByteString|DOMString|USVString|Date|any|attribute|boolean|byte|const|deleter|double|float|getter|inherit|legacycaller|long|object|octet|readonly|sequence|serializer|setter|short|static|stringifier|unrestricted|unsigned|void)$&#39;;
 636 my $nextSingleType_1 = &#39;^(ByteString|DOMString|USVString|Date|boolean|byte|double|float|long|object|octet|sequence|short|unrestricted|unsigned)$&#39;;
 637 my $nextArgumentName_1 = &#39;^(attribute|callback|const|deleter|dictionary|enum|exception|getter|implements|inherit|interface|legacycaller|partial|serializer|setter|static|stringifier|typedef|unrestricted)$&#39;;
 638 my $nextConstValue_1 = &#39;^(false|true)$&#39;;
 639 my $nextConstValue_2 = &#39;^(-|Infinity|NaN)$&#39;;
 640 my $nextDefinition_1 = &#39;^(callback|interface)$&#39;;
 641 my $nextOperationRest_1 = &#39;^(\(|ByteString|DOMString|USVString|Date|any|boolean|byte|double|float|long|object|octet|sequence|short|unrestricted|unsigned|void)$&#39;;
 642 my $nextUnsignedIntegerType_1 = &#39;^(long|short)$&#39;;
 643 my $nextDefaultValue_1 = &#39;^(-|Infinity|NaN|false|null|true)$&#39;;
 644 
 645 
 646 sub parseDefinitions
 647 {
 648     my $self = shift;
 649     my @definitions = ();
 650 
 651     while (1) {
 652         my $extendedAttributeList = $self-&gt;parseExtendedAttributeListAllowEmpty();
 653         my $next = $self-&gt;nextToken();
 654         my $definition;
 655         if ($next-&gt;type() == IdentifierToken || $next-&gt;value() =~ /$nextDefinitions_1/) {
 656             $definition = $self-&gt;parseDefinition($extendedAttributeList);
 657         } else {
 658             last;
 659         }
 660         if (defined ($definition)) {
 661             push(@definitions, $definition);
 662         }
 663     }
 664     $self-&gt;applyTypedefs(\@definitions);
 665     return \@definitions;
 666 }
 667 
 668 sub applyTypedefs
 669 {
 670     my $self = shift;
 671     my $definitions = shift;
 672    
 673     if (!%typedefs) {
 674         return;
 675     }
 676     
 677     foreach my $definition (@$definitions) {
 678         if (ref($definition) eq &quot;IDLInterface&quot;) {
 679             foreach my $constant (@{$definition-&gt;constants}) {
 680                 $constant-&gt;type($self-&gt;typeByApplyingTypedefs($constant-&gt;type));
 681             }
 682             foreach my $attribute (@{$definition-&gt;attributes}) {
 683                 $attribute-&gt;type($self-&gt;typeByApplyingTypedefs($attribute-&gt;type));
 684             }
 685             foreach my $operation (@{$definition-&gt;operations}, @{$definition-&gt;anonymousOperations}, @{$definition-&gt;constructors}, @{$definition-&gt;customConstructors}) {
 686                 $self-&gt;applyTypedefsToOperation($operation);
 687             }
 688             if ($definition-&gt;iterable) {
 689                 if ($definition-&gt;iterable-&gt;keyType) {
 690                     $definition-&gt;iterable-&gt;keyType($self-&gt;typeByApplyingTypedefs($definition-&gt;iterable-&gt;keyType));
 691                 }
 692                 if ($definition-&gt;iterable-&gt;valueType) {
 693                     $definition-&gt;iterable-&gt;valueType($self-&gt;typeByApplyingTypedefs($definition-&gt;iterable-&gt;valueType));
 694                 }
 695                 foreach my $operation (@{$definition-&gt;iterable-&gt;operations}) {
 696                     $self-&gt;applyTypedefsToOperation($operation);
 697                 }
 698             }
 699             if ($definition-&gt;mapLike) {
 700                 if ($definition-&gt;mapLike-&gt;keyType) {
 701                     $definition-&gt;mapLike-&gt;keyType($self-&gt;typeByApplyingTypedefs($definition-&gt;mapLike-&gt;keyType));
 702                 }
 703                 if ($definition-&gt;mapLike-&gt;valueType) {
 704                     $definition-&gt;mapLike-&gt;valueType($self-&gt;typeByApplyingTypedefs($definition-&gt;mapLike-&gt;valueType));
 705                 }
 706                 foreach my $attribute (@{$definition-&gt;mapLike-&gt;attributes}) {
 707                     $attribute-&gt;type($self-&gt;typeByApplyingTypedefs($attribute-&gt;type));
 708                 }
 709                 foreach my $operation (@{$definition-&gt;mapLike-&gt;operations}) {
 710                     $self-&gt;applyTypedefsToOperation($operation);
 711                 }
 712             }
 713         } elsif (ref($definition) eq &quot;IDLDictionary&quot;) {
 714             foreach my $member (@{$definition-&gt;members}) {
 715                 $member-&gt;type($self-&gt;typeByApplyingTypedefs($member-&gt;type));
 716             }
 717         } elsif (ref($definition) eq &quot;IDLCallbackFunction&quot;) {
 718             $self-&gt;applyTypedefsToOperation($definition-&gt;operation);
 719         }
 720     }
 721 }
 722 
 723 sub applyTypedefsToOperation
 724 {
 725     my $self = shift;
 726     my $operation = shift;
 727 
 728     if ($operation-&gt;type) {
 729         $operation-&gt;type($self-&gt;typeByApplyingTypedefs($operation-&gt;type));
 730     }
 731 
 732     foreach my $argument (@{$operation-&gt;arguments}) {
 733         $argument-&gt;type($self-&gt;typeByApplyingTypedefs($argument-&gt;type));
 734     }
 735 }
 736 
 737 sub typeByApplyingTypedefs
 738 {
 739     my $self = shift;
 740     my $type = shift;
 741 
 742     assert(&quot;Missing type&quot;) if !$type;
 743 
 744     my $numberOfSubtypes = scalar @{$type-&gt;subtypes};
 745     if ($numberOfSubtypes) {
 746         for my $i (0..$numberOfSubtypes - 1) {
 747             my $subtype = @{$type-&gt;subtypes}[$i];
 748             my $replacementSubtype = $self-&gt;typeByApplyingTypedefs($subtype);
 749             @{$type-&gt;subtypes}[$i] = $replacementSubtype
 750         }
 751 
 752         return $type;
 753     }
 754 
 755     if (exists $typedefs{$type-&gt;name}) {
 756         my $typedef = $typedefs{$type-&gt;name};
 757 
 758         my $clonedType = cloneType($typedef-&gt;type);
 759         $clonedType-&gt;isNullable($clonedType-&gt;isNullable || $type-&gt;isNullable);
 760         $self-&gt;moveExtendedAttributesApplicableToTypes($clonedType, $type-&gt;extendedAttributes);
 761 
 762         return $self-&gt;typeByApplyingTypedefs($clonedType);
 763     }
 764     
 765     return $type;
 766 }
 767 
 768 sub parseDefinition
 769 {
 770     my $self = shift;
 771     my $extendedAttributeList = shift;
 772 
 773     my $next = $self-&gt;nextToken();
 774     if ($next-&gt;value() =~ /$nextDefinition_1/) {
 775         return $self-&gt;parseCallbackOrInterface($extendedAttributeList);
 776     }
 777     if ($next-&gt;value() eq &quot;partial&quot;) {
 778         return $self-&gt;parsePartial($extendedAttributeList);
 779     }
 780     if ($next-&gt;value() eq &quot;dictionary&quot;) {
 781         return $self-&gt;parseDictionary($extendedAttributeList);
 782     }
 783     if ($next-&gt;value() eq &quot;exception&quot;) {
 784         return $self-&gt;parseException($extendedAttributeList);
 785     }
 786     if ($next-&gt;value() eq &quot;enum&quot;) {
 787         return $self-&gt;parseEnum($extendedAttributeList);
 788     }
 789     if ($next-&gt;value() eq &quot;typedef&quot;) {
 790         return $self-&gt;parseTypedef($extendedAttributeList);
 791     }
 792     if ($next-&gt;type() == IdentifierToken) {
 793         return $self-&gt;parseImplementsStatement($extendedAttributeList);
 794     }
 795     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
 796 }
 797 
 798 sub parseCallbackOrInterface
 799 {
 800     my $self = shift;
 801     my $extendedAttributeList = shift;
 802 
 803     my $next = $self-&gt;nextToken();
 804     if ($next-&gt;value() eq &quot;callback&quot;) {
 805         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;callback&quot;, __LINE__);
 806         return $self-&gt;parseCallbackRestOrInterface($extendedAttributeList);
 807     }
 808     if ($next-&gt;value() eq &quot;interface&quot;) {
 809         return $self-&gt;parseInterface($extendedAttributeList);
 810     }
 811     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
 812 }
 813 
 814 sub parseCallbackRestOrInterface
 815 {
 816     my $self = shift;
 817     my $extendedAttributeList = shift;
 818 
 819     my $next = $self-&gt;nextToken();
 820     if ($next-&gt;value() eq &quot;interface&quot;) {
 821         my $interface = $self-&gt;parseInterface($extendedAttributeList);
 822         $interface-&gt;isCallback(1);
 823         return $interface;
 824     }
 825     if ($next-&gt;type() == IdentifierToken) {
 826         return $self-&gt;parseCallbackRest($extendedAttributeList);
 827     }
 828     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
 829 }
 830 
 831 sub parseInterface
 832 {
 833     my $self = shift;
 834     my $extendedAttributeList = shift;
 835 
 836     my $next = $self-&gt;nextToken();
 837     if ($next-&gt;value() eq &quot;interface&quot;) {
 838         my $interface = IDLInterface-&gt;new();
 839         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;interface&quot;, __LINE__);
 840         my $interfaceNameToken = $self-&gt;getToken();
 841         $self-&gt;assertTokenType($interfaceNameToken, IdentifierToken);
 842         
 843         my $name = identifierRemoveNullablePrefix($interfaceNameToken-&gt;value());
 844         $interface-&gt;type(makeSimpleType($name));
 845 
 846         $next = $self-&gt;nextToken();
 847         if ($next-&gt;value() eq &quot;:&quot;) {
 848             my $parent = $self-&gt;parseInheritance();
 849             $interface-&gt;parentType(makeSimpleType($parent));
 850         }
 851 
 852         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;{&quot;, __LINE__);
 853         my $interfaceMembers = $self-&gt;parseInterfaceMembers();
 854         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;}&quot;, __LINE__);
 855         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;;&quot;, __LINE__);
 856         applyMemberList($interface, $interfaceMembers);
 857 
 858         $self-&gt;assertExtendedAttributesValidForContext($extendedAttributeList, &quot;interface&quot;);
 859         applyExtendedAttributeList($interface, $extendedAttributeList);
 860 
 861         return $interface;
 862     }
 863     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
 864 }
 865 
 866 sub parsePartial
 867 {
 868     my $self = shift;
 869     my $extendedAttributeList = shift;
 870 
 871     my $next = $self-&gt;nextToken();
 872     if ($next-&gt;value() eq &quot;partial&quot;) {
 873         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;partial&quot;, __LINE__);
 874         return $self-&gt;parsePartialDefinition($extendedAttributeList);
 875     }
 876     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
 877 }
 878 
 879 sub parsePartialDefinition
 880 {
 881     my $self = shift;
 882     my $extendedAttributeList = shift;
 883 
 884     my $next = $self-&gt;nextToken();
 885     if ($next-&gt;value() eq &quot;interface&quot;) {
 886         my $interface = $self-&gt;parseInterface($extendedAttributeList);
 887         $interface-&gt;isPartial(1);
 888         return $interface;
 889     }
 890     if ($next-&gt;value() eq &quot;dictionary&quot;) {
<a name="2" id="anc2"></a><span class="line-modified"> 891         my $dictionary = $self-&gt;parseDictionary($extendedAttributeList);</span>
<span class="line-modified"> 892         $dictionary-&gt;isPartial(1);</span>
<span class="line-modified"> 893         return $dictionary;</span>
















 894     }
 895     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
 896 }
 897 
 898 sub parseInterfaceMembers
 899 {
 900     my $self = shift;
 901     my @interfaceMembers = ();
 902 
 903     while (1) {
 904         my $extendedAttributeList = $self-&gt;parseExtendedAttributeListAllowEmpty();
 905         my $next = $self-&gt;nextToken();
 906         my $interfaceMember;
 907 
 908         if ($next-&gt;type() == IdentifierToken || $next-&gt;value() =~ /$nextInterfaceMembers_1/) {
 909             $interfaceMember = $self-&gt;parseInterfaceMember($extendedAttributeList);
 910         } else {
 911             last;
 912         }
 913         if (defined $interfaceMember) {
 914             push(@interfaceMembers, $interfaceMember);
 915         }
 916     }
 917     return \@interfaceMembers;
 918 }
 919 
 920 sub parseInterfaceMember
 921 {
 922     my $self = shift;
 923     my $extendedAttributeList = shift;
 924 
 925     my $next = $self-&gt;nextToken();
 926     if ($next-&gt;value() eq &quot;const&quot;) {
 927         return $self-&gt;parseConst($extendedAttributeList);
 928     }
 929 
 930     if ($next-&gt;value() eq &quot;serializer&quot;) {
 931         return $self-&gt;parseSerializer($extendedAttributeList);
 932     }
 933 
 934     if ($next-&gt;value() eq &quot;stringifier&quot;) {
 935         return $self-&gt;parseStringifier($extendedAttributeList);
 936     }
 937 
 938     if ($next-&gt;value() eq &quot;static&quot;) {
 939         return $self-&gt;parseStaticMember($extendedAttributeList);
 940     }
 941 
 942     if ($next-&gt;value() eq &quot;iterable&quot;) {
 943         return $self-&gt;parseIterableRest($extendedAttributeList);
 944     }
 945 
 946     if ($next-&gt;value() eq &quot;readonly&quot;) {
 947         return $self-&gt;parseReadOnlyMember($extendedAttributeList);
 948     }
 949 
 950     if ($next-&gt;type() == IdentifierToken || $next-&gt;value() =~ /$nextInterfaceMember_1/) {
 951         return $self-&gt;parseOperationOrReadWriteAttributeOrMaplike($extendedAttributeList);
 952     }
 953 
 954     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
 955 }
 956 
 957 sub parseDictionary
 958 {
 959     my $self = shift;
 960     my $extendedAttributeList = shift;
 961 
 962     my $next = $self-&gt;nextToken();
 963     if ($next-&gt;value() eq &quot;dictionary&quot;) {
 964         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;dictionary&quot;, __LINE__);
 965 
 966         my $dictionary = IDLDictionary-&gt;new();
 967 
 968         $self-&gt;assertExtendedAttributesValidForContext($extendedAttributeList, &quot;dictionary&quot;);
 969         $dictionary-&gt;extendedAttributes($extendedAttributeList);
 970 
 971         my $nameToken = $self-&gt;getToken();
 972         $self-&gt;assertTokenType($nameToken, IdentifierToken);
 973 
 974         my $name = $nameToken-&gt;value();
 975         $dictionary-&gt;type(makeSimpleType($name));
 976 
 977         $next = $self-&gt;nextToken();
 978         if ($next-&gt;value() eq &quot;:&quot;) {
 979             my $parent = $self-&gt;parseInheritance();
 980             $dictionary-&gt;parentType(makeSimpleType($parent));
 981         }
 982         
 983         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;{&quot;, __LINE__);
 984         $dictionary-&gt;members($self-&gt;parseDictionaryMembers());
 985         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;}&quot;, __LINE__);
 986         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;;&quot;, __LINE__);
 987         return $dictionary;
 988     }
 989     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
 990 }
 991 
 992 sub parseDictionaryMembers
 993 {
 994     my $self = shift;
 995 
 996     my @members = ();
 997 
 998     while (1) {
 999         my $extendedAttributeList = $self-&gt;parseExtendedAttributeListAllowEmpty();
1000         my $next = $self-&gt;nextToken();
1001         if ($next-&gt;type() == IdentifierToken || $next-&gt;value() =~ /$nextExceptionField_1/) {
1002             push(@members, $self-&gt;parseDictionaryMember($extendedAttributeList));
1003         } else {
1004             last;
1005         }
1006     }
1007 
1008     return \@members;
1009 }
1010 
1011 sub parseDictionaryMember
1012 {
1013     my $self = shift;
1014     my $extendedAttributeList = shift;
1015 
1016     my $next = $self-&gt;nextToken();
1017     if ($next-&gt;type() == IdentifierToken || $next-&gt;value() =~ /$nextExceptionField_1/) {
1018         my $member = IDLDictionaryMember-&gt;new();
1019 
1020         if ($next-&gt;value eq &quot;required&quot;) {
1021             $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;required&quot;, __LINE__);
1022             $member-&gt;isRequired(1);
1023 
1024             my $type = $self-&gt;parseTypeWithExtendedAttributes();
1025             $member-&gt;type($type);
1026         } else {
1027             $member-&gt;isRequired(0);
1028 
1029             my $type = $self-&gt;parseType();
1030             $self-&gt;moveExtendedAttributesApplicableToTypes($type, $extendedAttributeList);
1031             
1032             $member-&gt;type($type);
1033         }
1034 
1035         $self-&gt;assertExtendedAttributesValidForContext($extendedAttributeList, &quot;dictionary-member&quot;);
1036         $member-&gt;extendedAttributes($extendedAttributeList);
1037 
1038         my $nameToken = $self-&gt;getToken();
1039         $self-&gt;assertTokenType($nameToken, IdentifierToken);
1040         $member-&gt;name($nameToken-&gt;value);
1041         $member-&gt;default($self-&gt;parseDefault());
1042         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;;&quot;, __LINE__);
1043         return $member;
1044     }
1045     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1046 }
1047 
<a name="3" id="anc3"></a>















1048 sub parseDefault
1049 {
1050     my $self = shift;
1051     my $next = $self-&gt;nextToken();
1052     if ($next-&gt;value() eq &quot;=&quot;) {
1053         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;=&quot;, __LINE__);
1054         return $self-&gt;parseDefaultValue();
1055     }
1056     return undef;
1057 }
1058 
1059 sub parseDefaultValue
1060 {
1061     my $self = shift;
1062     my $next = $self-&gt;nextToken();
1063     if ($next-&gt;type() == FloatToken || $next-&gt;type() == IntegerToken || $next-&gt;value() =~ /$nextDefaultValue_1/) {
1064         return $self-&gt;parseConstValue();
1065     }
1066     if ($next-&gt;type() == StringToken) {
1067         return $self-&gt;getToken()-&gt;value();
1068     }
1069     if ($next-&gt;value() eq &quot;[&quot;) {
1070         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;[&quot;, __LINE__);
1071         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;]&quot;, __LINE__);
1072         return &quot;[]&quot;;
1073     }
1074     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1075 }
1076 
1077 sub parseException
1078 {
1079     my $self = shift;
1080     my $extendedAttributeList = shift;
1081 
1082     my $next = $self-&gt;nextToken();
1083     if ($next-&gt;value() eq &quot;exception&quot;) {
1084         my $interface = IDLInterface-&gt;new();
1085         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;exception&quot;, __LINE__);
1086         my $exceptionNameToken = $self-&gt;getToken();
1087         $self-&gt;assertTokenType($exceptionNameToken, IdentifierToken);
1088 
1089         my $name = identifierRemoveNullablePrefix($exceptionNameToken-&gt;value());
1090         $interface-&gt;type(makeSimpleType($name));
1091         $interface-&gt;isException(1);
1092 
1093         $next = $self-&gt;nextToken();
1094         if ($next-&gt;value() eq &quot;:&quot;) {
1095             my $parent = $self-&gt;parseInheritance();
1096             $interface-&gt;parentType(makeSimpleType($parent));
1097         }
1098         
1099         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;{&quot;, __LINE__);
1100         my $exceptionMembers = $self-&gt;parseExceptionMembers();
1101         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;}&quot;, __LINE__);
1102         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;;&quot;, __LINE__);
1103         applyMemberList($interface, $exceptionMembers);
1104         
1105         $self-&gt;assertExtendedAttributesValidForContext($extendedAttributeList, &quot;interface&quot;);
1106         applyExtendedAttributeList($interface, $extendedAttributeList);
1107 
1108         return $interface;
1109     }
1110     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1111 }
1112 
1113 sub parseExceptionMembers
1114 {
1115     my $self = shift;
1116     my @members = ();
1117 
1118     while (1) {
1119         my $next = $self-&gt;nextToken();
1120         if ($next-&gt;type() == IdentifierToken || $next-&gt;value() =~ /$nextExceptionMembers_1/) {
1121             my $extendedAttributeList = $self-&gt;parseExtendedAttributeListAllowEmpty();
1122             #my $member = $self-&gt;parseExceptionMember($extendedAttributeList);
1123             my $member = $self-&gt;parseInterfaceMember($extendedAttributeList);
1124             if (defined ($member)) {
1125                 push(@members, $member);
1126             }
1127         } else {
1128             last;
1129         }
1130     }
1131     return \@members;
1132 }
1133 
1134 sub parseInheritance
1135 {
1136     my $self = shift;
1137 
1138     my $next = $self-&gt;nextToken();
1139     if ($next-&gt;value() eq &quot;:&quot;) {
1140         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;:&quot;, __LINE__);
1141         return $self-&gt;parseName();
1142     }
1143     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1144 }
1145 
1146 sub parseEnum
1147 {
1148     my $self = shift;
1149     my $extendedAttributeList = shift;
1150 
1151     my $next = $self-&gt;nextToken();
1152     if ($next-&gt;value() eq &quot;enum&quot;) {
1153         my $enum = IDLEnum-&gt;new();
1154         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;enum&quot;, __LINE__);
1155         my $enumNameToken = $self-&gt;getToken();
1156         $self-&gt;assertTokenType($enumNameToken, IdentifierToken);
1157         my $name = identifierRemoveNullablePrefix($enumNameToken-&gt;value());
1158         $enum-&gt;name($name);
1159         $enum-&gt;type(makeSimpleType($name));
1160         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;{&quot;, __LINE__);
1161         push(@{$enum-&gt;values}, @{$self-&gt;parseEnumValueList()});
1162         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;}&quot;, __LINE__);
1163         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;;&quot;, __LINE__);
1164         
1165         $self-&gt;assertExtendedAttributesValidForContext($extendedAttributeList, &quot;enum&quot;);
1166         $enum-&gt;extendedAttributes($extendedAttributeList);
1167         return $enum;
1168     }
1169     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1170 }
1171 
1172 sub parseEnumValueList
1173 {
1174     my $self = shift;
1175     my @values = ();
1176     my $next = $self-&gt;nextToken();
1177     if ($next-&gt;type() == StringToken) {
1178         my $enumValueToken = $self-&gt;getToken();
1179         $self-&gt;assertTokenType($enumValueToken, StringToken);
1180         my $enumValue = $self-&gt;unquoteString($enumValueToken-&gt;value());
1181         push(@values, $enumValue);
1182         push(@values, @{$self-&gt;parseEnumValues()});
1183         return \@values;
1184     }
1185     # value list must be non-empty
1186     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1187 }
1188 
1189 sub parseEnumValues
1190 {
1191     my $self = shift;
1192     my @values = ();
1193     my $next = $self-&gt;nextToken();
1194     if ($next-&gt;value() eq &quot;,&quot;) {
1195         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;,&quot;, __LINE__);
1196         my $enumValueToken = $self-&gt;getToken();
1197         $self-&gt;assertTokenType($enumValueToken, StringToken);
1198         my $enumValue = $self-&gt;unquoteString($enumValueToken-&gt;value());
1199         push(@values, $enumValue);
1200         push(@values, @{$self-&gt;parseEnumValues()});
1201         return \@values;
1202     }
1203     return \@values; # empty list (end of enumeration-values)
1204 }
1205 
1206 sub parseCallbackRest
1207 {
1208     my $self = shift;
1209     my $extendedAttributeList = shift;
1210 
1211     my $next = $self-&gt;nextToken();
1212     if ($next-&gt;type() == IdentifierToken) {
1213         my $callback = IDLCallbackFunction-&gt;new();
1214 
1215         my $nameToken = $self-&gt;getToken();
1216         $self-&gt;assertTokenType($nameToken, IdentifierToken);
1217 
1218         $callback-&gt;type(makeSimpleType($nameToken-&gt;value()));
1219 
1220         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;=&quot;, __LINE__);
1221 
1222         my $operation = IDLOperation-&gt;new();
1223         $operation-&gt;type($self-&gt;parseReturnType());
1224         
1225         $self-&gt;assertExtendedAttributesValidForContext($extendedAttributeList, &quot;callback-function&quot;, &quot;operation&quot;);
1226         $operation-&gt;extendedAttributes($extendedAttributeList);
1227 
1228         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;(&quot;, __LINE__);
1229 
1230         push(@{$operation-&gt;arguments}, @{$self-&gt;parseArgumentList()});
1231 
1232         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;)&quot;, __LINE__);
1233         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;;&quot;, __LINE__);
1234 
1235         $callback-&gt;operation($operation);
1236         $callback-&gt;extendedAttributes($extendedAttributeList);
1237 
1238         return $callback;
1239     }
1240     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1241 }
1242 
1243 sub parseTypedef
1244 {
1245     my $self = shift;
1246     my $extendedAttributeList = shift;
1247     die &quot;Extended attributes are not applicable to typedefs themselves: &quot; . $self-&gt;{Line} if %{$extendedAttributeList};
1248 
1249     my $next = $self-&gt;nextToken();
1250     if ($next-&gt;value() eq &quot;typedef&quot;) {
1251         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;typedef&quot;, __LINE__);
1252         my $typedef = IDLTypedef-&gt;new();
1253 
1254         my $type = $self-&gt;parseTypeWithExtendedAttributes();
1255         $typedef-&gt;type($type);
1256 
1257         my $nameToken = $self-&gt;getToken();
1258         $self-&gt;assertTokenType($nameToken, IdentifierToken);
1259         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;;&quot;, __LINE__);
1260         my $name = $nameToken-&gt;value();
1261         die &quot;typedef redefinition for &quot; . $name . &quot; at &quot; . $self-&gt;{Line} if (exists $typedefs{$name} &amp;&amp; $typedef-&gt;type-&gt;name ne $typedefs{$name}-&gt;type-&gt;name);
1262         $typedefs{$name} = $typedef;
1263         return;
1264     }
1265     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1266 }
1267 
1268 sub parseImplementsStatement
1269 {
1270     my $self = shift;
1271     my $extendedAttributeList = shift;
1272 
1273     my $next = $self-&gt;nextToken();
1274     if ($next-&gt;type() == IdentifierToken) {
1275         $self-&gt;parseName();
1276         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;implements&quot;, __LINE__);
1277         $self-&gt;parseName();
1278         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;;&quot;, __LINE__);
1279         return;
1280     }
1281     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1282 }
1283 
1284 sub parseConst
1285 {
1286     my $self = shift;
1287     my $extendedAttributeList = shift;
1288 
1289     my $next = $self-&gt;nextToken();
1290     if ($next-&gt;value() eq &quot;const&quot;) {
1291         my $newDataNode = IDLConstant-&gt;new();
1292         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;const&quot;, __LINE__);
1293         my $type = $self-&gt;parseConstType();
1294         $newDataNode-&gt;type($type);
1295         my $constNameToken = $self-&gt;getToken();
1296         $self-&gt;assertTokenType($constNameToken, IdentifierToken);
1297         $newDataNode-&gt;name(identifierRemoveNullablePrefix($constNameToken-&gt;value()));
1298         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;=&quot;, __LINE__);
1299         $newDataNode-&gt;value($self-&gt;parseConstValue());
1300         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;;&quot;, __LINE__);
1301 
1302         $self-&gt;assertExtendedAttributesValidForContext($extendedAttributeList, &quot;constant&quot;);
1303         $newDataNode-&gt;extendedAttributes($extendedAttributeList);
1304 
1305         return $newDataNode;
1306     }
1307     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1308 }
1309 
1310 sub parseConstValue
1311 {
1312     my $self = shift;
1313     my $next = $self-&gt;nextToken();
1314     if ($next-&gt;value() =~ /$nextConstValue_1/) {
1315         return $self-&gt;parseBooleanLiteral();
1316     }
1317     if ($next-&gt;value() eq &quot;null&quot;) {
1318         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;null&quot;, __LINE__);
1319         return &quot;null&quot;;
1320     }
1321     if ($next-&gt;type() == FloatToken || $next-&gt;value() =~ /$nextConstValue_2/) {
1322         return $self-&gt;parseFloatLiteral();
1323     }
1324     if ($next-&gt;type() == IntegerToken) {
1325         return $self-&gt;getToken()-&gt;value();
1326     }
1327     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1328 }
1329 
1330 sub parseBooleanLiteral
1331 {
1332     my $self = shift;
1333     my $next = $self-&gt;nextToken();
1334     if ($next-&gt;value() eq &quot;true&quot;) {
1335         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;true&quot;, __LINE__);
1336         return &quot;true&quot;;
1337     }
1338     if ($next-&gt;value() eq &quot;false&quot;) {
1339         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;false&quot;, __LINE__);
1340         return &quot;false&quot;;
1341     }
1342     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1343 }
1344 
1345 sub parseFloatLiteral
1346 {
1347     my $self = shift;
1348     my $next = $self-&gt;nextToken();
1349     if ($next-&gt;value() eq &quot;-&quot;) {
1350         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;-&quot;, __LINE__);
1351         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;Infinity&quot;, __LINE__);
1352         return &quot;-Infinity&quot;;
1353     }
1354     if ($next-&gt;value() eq &quot;Infinity&quot;) {
1355         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;Infinity&quot;, __LINE__);
1356         return &quot;Infinity&quot;;
1357     }
1358     if ($next-&gt;value() eq &quot;NaN&quot;) {
1359         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;NaN&quot;, __LINE__);
1360         return &quot;NaN&quot;;
1361     }
1362     if ($next-&gt;type() == FloatToken) {
1363         return $self-&gt;getToken()-&gt;value();
1364     }
1365     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1366 }
1367 
1368 sub parseOperationOrReadWriteAttributeOrMaplike
1369 {
1370     my $self = shift;
1371     my $extendedAttributeList = shift;
1372 
1373     my $next = $self-&gt;nextToken();
1374     if ($next-&gt;value() =~ /$nextAttribute_1/) {
1375         return $self-&gt;parseReadWriteAttribute($extendedAttributeList);
1376     }
1377     if ($next-&gt;value() eq &quot;maplike&quot;) {
1378         return $self-&gt;parseMapLikeRest($extendedAttributeList, 0);
1379     }
1380     if ($next-&gt;type() == IdentifierToken || $next-&gt;value() =~ /$nextOperation_1/) {
1381         return $self-&gt;parseOperation($extendedAttributeList);
1382     }
1383     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1384 }
1385 
1386 sub parseReadOnlyMember
1387 {
1388     my $self = shift;
1389     my $extendedAttributeList = shift;
1390 
1391     my $next = $self-&gt;nextToken();
1392     if ($next-&gt;value() eq &quot;readonly&quot;) {
1393         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;readonly&quot;, __LINE__);
1394 
1395         my $next = $self-&gt;nextToken();
1396         if ($next-&gt;value() eq &quot;attribute&quot;) {
1397             my $attribute = $self-&gt;parseAttributeRest($extendedAttributeList);
1398             $attribute-&gt;isReadOnly(1);
1399             return $attribute;
1400         }
1401         if ($next-&gt;value() eq &quot;maplike&quot;) {
1402             return $self-&gt;parseMapLikeRest($extendedAttributeList, 1);
1403         }
1404     }
1405     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1406 }
1407 
1408 sub parseSerializer
1409 {
1410     my $self = shift;
1411     my $extendedAttributeList = shift;
1412 
1413     my $next = $self-&gt;nextToken();
1414     if ($next-&gt;value() eq &quot;serializer&quot;) {
1415         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;serializer&quot;, __LINE__);
1416         my $next = $self-&gt;nextToken();
1417         my $newDataNode;
1418         if ($next-&gt;value() ne &quot;;&quot;) {
1419             $newDataNode = $self-&gt;parseSerializerRest($extendedAttributeList);
1420             my $next = $self-&gt;nextToken();
1421         } else {
1422             $newDataNode = IDLSerializable-&gt;new();
1423         }
1424 
1425         my $toJSONOperation = IDLOperation-&gt;new();
1426         $toJSONOperation-&gt;name(&quot;toJSON&quot;);
1427 
1428         $self-&gt;assertExtendedAttributesValidForContext($extendedAttributeList, &quot;operation&quot;);
1429         $toJSONOperation-&gt;extendedAttributes($extendedAttributeList);
1430         $toJSONOperation-&gt;isSerializer(1);
1431         push(@{$newDataNode-&gt;operations}, $toJSONOperation);
1432 
1433         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;;&quot;, __LINE__);
1434         return $newDataNode;
1435     }
1436     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1437 }
1438 
1439 sub parseSerializerRest
1440 {
1441     my $self = shift;
1442     my $extendedAttributeList = shift;
1443 
1444     my $next = $self-&gt;nextToken();
1445     if ($next-&gt;value() eq &quot;=&quot;) {
1446         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;=&quot;, __LINE__);
1447 
1448         return $self-&gt;parseSerializationPattern();
1449 
1450     }
1451     if ($next-&gt;type() == IdentifierToken || $next-&gt;value() eq &quot;(&quot;) {
1452         return $self-&gt;parseOperationRest($extendedAttributeList);
1453     }
1454 }
1455 
1456 sub parseSerializationPattern
1457 {
1458     my $self = shift;
1459 
1460     my $next = $self-&gt;nextToken();
1461     if ($next-&gt;value() eq &quot;{&quot;) {
1462         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;{&quot;, __LINE__);
1463         my $newDataNode = IDLSerializable-&gt;new();
1464         $self-&gt;parseSerializationAttributes($newDataNode);
1465         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;}&quot;, __LINE__);
1466         return $newDataNode;
1467     }
1468     if ($next-&gt;value() eq &quot;[&quot;) {
1469         die &quot;Serialization of lists pattern is not currently supported.&quot;;
1470     }
1471     if ($next-&gt;type() == IdentifierToken) {
1472         my @attributes = ();
1473         my $token = $self-&gt;getToken();
1474         $self-&gt;assertTokenType($token, IdentifierToken);
1475         push(@attributes, $token-&gt;value());
1476 
1477         my $newDataNode = IDLSerializable-&gt;new();
1478         $newDataNode-&gt;attributes(\@attributes);
1479 
1480         return $newDataNode;
1481     }
1482     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1483 }
1484 
1485 sub parseSerializationAttributes
1486 {
1487     my $self = shift;
1488     my $serializable = shift;
1489 
1490     my @attributes = ();
1491     my @identifiers = $self-&gt;parseIdentifierList();
1492 
1493     for my $identifier (@identifiers) {
1494         if ($identifier eq &quot;getter&quot;) {
1495             $serializable-&gt;hasGetter(1);
1496             die &quot;Serializer getter keyword is not currently supported.&quot;;
1497         }
1498 
1499         if ($identifier eq &quot;inherit&quot;) {
1500             $serializable-&gt;hasInherit(1);
1501             next;
1502         }
1503 
1504         if ($identifier eq &quot;attribute&quot;) {
1505             $serializable-&gt;hasAttribute(1);
1506             # Attributes will be filled in via applyMemberList()
1507             next;
1508         }
1509 
1510         push(@attributes, $identifier);
1511     }
1512 
1513     $serializable-&gt;attributes(\@attributes);
1514 }
1515 
1516 sub parseIdentifierList
1517 {
1518     my $self = shift;
1519     my $next = $self-&gt;nextToken();
1520 
1521     my @identifiers = ();
1522     if ($next-&gt;type == IdentifierToken) {
1523         push(@identifiers, $self-&gt;getToken()-&gt;value());
1524         push(@identifiers, @{$self-&gt;parseIdentifiers()});
1525     }
1526     return @identifiers;
1527 }
1528 
1529 sub parseIdentifiers
1530 {
1531     my $self = shift;
1532     my @idents = ();
1533 
1534     while (1) {
1535         my $next = $self-&gt;nextToken();
1536         if ($next-&gt;value() eq &quot;,&quot;) {
1537             $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;,&quot;, __LINE__);
1538             my $token = $self-&gt;getToken();
1539             $self-&gt;assertTokenType($token, IdentifierToken);
1540             push(@idents, $token-&gt;value());
1541         } else {
1542             last;
1543         }
1544     }
1545     return \@idents;
1546 }
1547 
1548 sub parseStringifier
1549 {
1550     my $self = shift;
1551     my $extendedAttributeList = shift;
1552 
1553     my $next = $self-&gt;nextToken();
1554     if ($next-&gt;value() eq &quot;stringifier&quot;) {
1555         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;stringifier&quot;, __LINE__);
1556 
1557         $next = $self-&gt;nextToken();
1558         if ($next-&gt;value() eq &quot;;&quot;) {
1559             $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;;&quot;, __LINE__);
1560 
1561             my $operation = IDLOperation-&gt;new();
1562             $operation-&gt;isStringifier(1);
1563             $operation-&gt;name(&quot;&quot;);
1564             $operation-&gt;type(makeSimpleType(&quot;DOMString&quot;));
1565             $operation-&gt;extendedAttributes($extendedAttributeList);
1566 
1567             return $operation;
1568         } else {
1569             my $attributeOrOperation = $self-&gt;parseAttributeOrOperationForStringifierOrStatic($extendedAttributeList);
1570             $attributeOrOperation-&gt;isStringifier(1);
1571 
1572             return $attributeOrOperation;
1573         }
1574     }
1575     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1576 }
1577 
1578 sub parseStaticMember
1579 {
1580     my $self = shift;
1581     my $extendedAttributeList = shift;
1582 
1583     my $next = $self-&gt;nextToken();
1584     if ($next-&gt;value() eq &quot;static&quot;) {
1585         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;static&quot;, __LINE__);
1586 
1587         my $attributeOrOperation = $self-&gt;parseAttributeOrOperationForStringifierOrStatic($extendedAttributeList);
1588         $attributeOrOperation-&gt;isStatic(1);
1589 
1590         return $attributeOrOperation;
1591     }
1592     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1593 }
1594 
1595 sub parseAttributeOrOperationForStringifierOrStatic
1596 {
1597     my $self = shift;
1598     my $extendedAttributeList = shift;
1599 
1600     my $next = $self-&gt;nextToken();
1601     if ($next-&gt;value() =~ /$nextAttribute_2/) {
1602         my $isReadOnly = $self-&gt;parseReadOnly();
1603 
1604         my $attribute = $self-&gt;parseAttributeRest($extendedAttributeList);
1605         $attribute-&gt;isReadOnly($isReadOnly);
1606 
1607         return $attribute;
1608     }
1609 
1610     if ($next-&gt;type() == IdentifierToken || $next-&gt;value() =~ /$nextOperationRest_1/) {
1611         my $returnType = $self-&gt;parseReturnType();
1612 
1613         # NOTE: This is a non-standard addition. In WebIDL, there is no way to associate
1614         # extended attributes with a return type.
1615         $self-&gt;moveExtendedAttributesApplicableToTypes($returnType, $extendedAttributeList);
1616 
1617         my $operation = $self-&gt;parseOperationRest($extendedAttributeList);
1618         $operation-&gt;type($returnType);
1619 
1620         return $operation;
1621     }
1622     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1623 }
1624 
1625 sub parseReadWriteAttribute
1626 {
1627     my $self = shift;
1628     my $extendedAttributeList = shift;
1629 
1630     my $next = $self-&gt;nextToken();
1631     if ($next-&gt;value() eq &quot;inherit&quot;) {
1632         my $isInherit = $self-&gt;parseInherit();
1633         my $isReadOnly = $self-&gt;parseReadOnly();
1634 
1635         my $attribute = $self-&gt;parseAttributeRest($extendedAttributeList);
1636 
1637         $attribute-&gt;isInherit($isInherit);
1638         $attribute-&gt;isReadOnly($isReadOnly);
1639 
1640         return $attribute;
1641     } else {
1642         return $self-&gt;parseAttributeRest($extendedAttributeList);
1643     }
1644     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1645 }
1646 
1647 sub parseAttributeRest
1648 {
1649     my $self = shift;
1650     my $extendedAttributeList = shift;
1651 
1652     my $next = $self-&gt;nextToken();
1653     if ($next-&gt;value() eq &quot;attribute&quot;) {
1654         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;attribute&quot;, __LINE__);
1655 
1656         my $attribute = IDLAttribute-&gt;new();
1657         
1658         $self-&gt;assertExtendedAttributesValidForContext($extendedAttributeList, &quot;attribute&quot;);
1659         $attribute-&gt;extendedAttributes($extendedAttributeList);
1660 
1661         my $type = $self-&gt;parseTypeWithExtendedAttributes();
1662         $attribute-&gt;type($type);
1663 
1664         my $token = $self-&gt;getToken();
1665         $self-&gt;assertTokenType($token, IdentifierToken);
1666         $attribute-&gt;name(identifierRemoveNullablePrefix($token-&gt;value()));
1667         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;;&quot;, __LINE__);
1668 
1669         return $attribute;
1670     }
1671     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1672 }
1673 
1674 sub parseInherit
1675 {
1676     my $self = shift;
1677     my $next = $self-&gt;nextToken();
1678     if ($next-&gt;value() eq &quot;inherit&quot;) {
1679         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;inherit&quot;, __LINE__);
1680         return 1;
1681     }
1682     return 0;
1683 }
1684 
1685 sub parseReadOnly
1686 {
1687     my $self = shift;
1688     my $next = $self-&gt;nextToken();
1689     if ($next-&gt;value() eq &quot;readonly&quot;) {
1690         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;readonly&quot;, __LINE__);
1691         return 1;
1692     }
1693     return 0;
1694 }
1695 
1696 sub parseOperation
1697 {
1698     my $self = shift;
1699     my $extendedAttributeList = shift;
1700 
1701     my $next = $self-&gt;nextToken();
1702     if ($next-&gt;value() =~ /$nextSpecials_1/) {
1703         return $self-&gt;parseSpecialOperation($extendedAttributeList);
1704     }
1705     if ($next-&gt;type() == IdentifierToken || $next-&gt;value() =~ /$nextOperationRest_1/) {
1706         my $returnType = $self-&gt;parseReturnType();
1707 
1708         # NOTE: This is a non-standard addition. In WebIDL, there is no way to associate
1709         # extended attributes with a return type.
1710         $self-&gt;moveExtendedAttributesApplicableToTypes($returnType, $extendedAttributeList);
1711 
1712         my $operation = $self-&gt;parseOperationRest($extendedAttributeList);
1713         $operation-&gt;type($returnType);
1714 
1715         return $operation;
1716     }
1717     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1718 }
1719 
1720 sub parseSpecialOperation
1721 {
1722     my $self = shift;
1723     my $extendedAttributeList = shift;
1724 
1725     my $next = $self-&gt;nextToken();
1726     if ($next-&gt;value() =~ /$nextSpecials_1/) {
1727         my @specials = ();
1728         push(@specials, @{$self-&gt;parseSpecials()});
1729         my $returnType = $self-&gt;parseReturnType();
1730 
1731         # NOTE: This is a non-standard addition. In WebIDL, there is no way to associate
1732         # extended attributes with a return type.
1733         $self-&gt;moveExtendedAttributesApplicableToTypes($returnType, $extendedAttributeList);
1734 
1735         my $operation = $self-&gt;parseOperationRest($extendedAttributeList);
1736         $operation-&gt;type($returnType);
1737         $operation-&gt;specials(\@specials);
1738 
1739         return $operation;
1740     }
1741     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1742 }
1743 
1744 sub parseSpecials
1745 {
1746     my $self = shift;
1747     my @specials = ();
1748 
1749     while (1) {
1750         my $next = $self-&gt;nextToken();
1751         if ($next-&gt;value() =~ /$nextSpecials_1/) {
1752             push(@specials, $self-&gt;parseSpecial());
1753         } else {
1754             last;
1755         }
1756     }
1757     return \@specials;
1758 }
1759 
1760 sub parseSpecial
1761 {
1762     my $self = shift;
1763     my $next = $self-&gt;nextToken();
1764     if ($next-&gt;value() eq &quot;getter&quot;) {
1765         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;getter&quot;, __LINE__);
1766         return &quot;getter&quot;;
1767     }
1768     if ($next-&gt;value() eq &quot;setter&quot;) {
1769         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;setter&quot;, __LINE__);
1770         return &quot;setter&quot;;
1771     }
1772     if ($next-&gt;value() eq &quot;deleter&quot;) {
1773         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;deleter&quot;, __LINE__);
1774         return &quot;deleter&quot;;
1775     }
1776     if ($next-&gt;value() eq &quot;legacycaller&quot;) {
1777         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;legacycaller&quot;, __LINE__);
1778         return &quot;legacycaller&quot;;
1779     }
1780     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1781 }
1782 
1783 sub parseIterableRest
1784 {
1785     my $self = shift;
1786     my $extendedAttributeList = shift;
1787 
1788     my $next = $self-&gt;nextToken();
1789     if ($next-&gt;value() eq &quot;iterable&quot;) {
1790         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;iterable&quot;, __LINE__);
1791         my $iterableNode = $self-&gt;parseOptionalIterableInterface($extendedAttributeList);
1792         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;;&quot;, __LINE__);
1793         return $iterableNode;
1794     }
1795     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1796 }
1797 
1798 sub parseOptionalIterableInterface
1799 {
1800     my $self = shift;
1801     my $extendedAttributeList = shift;
1802 
1803     my $newDataNode = IDLIterable-&gt;new();
1804 
1805     $self-&gt;assertExtendedAttributesValidForContext($extendedAttributeList, &quot;iterable&quot;);
1806     $newDataNode-&gt;extendedAttributes($extendedAttributeList);
1807 
1808     $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;&lt;&quot;, __LINE__);
1809     my $type1 = $self-&gt;parseTypeWithExtendedAttributes();
1810 
1811     if ($self-&gt;nextToken()-&gt;value() eq &quot;,&quot;) {
1812         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;,&quot;, __LINE__);
1813 
1814         my $type2 = $self-&gt;parseTypeWithExtendedAttributes();
1815         $newDataNode-&gt;isKeyValue(1);
1816         $newDataNode-&gt;keyType($type1);
1817         $newDataNode-&gt;valueType($type2);
1818     } else {
1819         $newDataNode-&gt;isKeyValue(0);
1820         $newDataNode-&gt;valueType($type1);
1821     }
1822     $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;&gt;&quot;, __LINE__);
1823 
1824     my $symbolIteratorOperation = IDLOperation-&gt;new();
1825     $symbolIteratorOperation-&gt;name(&quot;[Symbol.Iterator]&quot;);
1826     $symbolIteratorOperation-&gt;extendedAttributes($extendedAttributeList);
1827     $symbolIteratorOperation-&gt;isIterable(1);
1828 
1829     my $entriesOperation = IDLOperation-&gt;new();
1830     $entriesOperation-&gt;name(&quot;entries&quot;);
1831     $entriesOperation-&gt;extendedAttributes($extendedAttributeList);
1832     $entriesOperation-&gt;isIterable(1);
1833 
1834     my $keysOperation = IDLOperation-&gt;new();
1835     $keysOperation-&gt;name(&quot;keys&quot;);
1836     $keysOperation-&gt;extendedAttributes($extendedAttributeList);
1837     $keysOperation-&gt;isIterable(1);
1838 
1839     my $valuesOperation = IDLOperation-&gt;new();
1840     $valuesOperation-&gt;name(&quot;values&quot;);
1841     $valuesOperation-&gt;extendedAttributes($extendedAttributeList);
1842     $valuesOperation-&gt;isIterable(1);
1843 
1844     my $forEachOperation = IDLOperation-&gt;new();
1845     $forEachOperation-&gt;name(&quot;forEach&quot;);
1846     $forEachOperation-&gt;extendedAttributes($extendedAttributeList);
1847     $forEachOperation-&gt;isIterable(1);
1848     my $forEachArgument = IDLArgument-&gt;new();
1849     $forEachArgument-&gt;name(&quot;callback&quot;);
1850     $forEachArgument-&gt;type(makeSimpleType(&quot;any&quot;));
1851     push(@{$forEachOperation-&gt;arguments}, ($forEachArgument));
1852 
1853     push(@{$newDataNode-&gt;operations}, $symbolIteratorOperation);
1854     push(@{$newDataNode-&gt;operations}, $entriesOperation);
1855     push(@{$newDataNode-&gt;operations}, $keysOperation);
1856     push(@{$newDataNode-&gt;operations}, $valuesOperation);
1857     push(@{$newDataNode-&gt;operations}, $forEachOperation);
1858 
1859     return $newDataNode;
1860 }
1861 
1862 sub parseMapLikeRest
1863 {
1864     my $self = shift;
1865     my $extendedAttributeList = shift;
1866     my $isReadOnly = shift;
1867 
1868     my $next = $self-&gt;nextToken();
1869     if ($next-&gt;value() eq &quot;maplike&quot;) {
1870         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;maplike&quot;, __LINE__);
1871         my $mapLikeNode = $self-&gt;parseMapLikeProperties($extendedAttributeList, $isReadOnly);
1872         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;;&quot;, __LINE__);
1873         return $mapLikeNode;
1874     }
1875     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1876 }
1877 
1878 sub parseMapLikeProperties
1879 {
1880     my $self = shift;
1881     my $extendedAttributeList = shift;
1882     my $isReadOnly = shift;
1883 
1884     my $maplike = IDLMapLike-&gt;new();
1885     $maplike-&gt;extendedAttributes($extendedAttributeList);
1886     $maplike-&gt;isReadOnly($isReadOnly);
1887 
1888     $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;&lt;&quot;, __LINE__);
1889     $maplike-&gt;keyType($self-&gt;parseTypeWithExtendedAttributes());
1890     $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;,&quot;, __LINE__);
1891     $maplike-&gt;valueType($self-&gt;parseTypeWithExtendedAttributes());
1892     $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;&gt;&quot;, __LINE__);
1893 
1894     # FIXME: Synthetic operations should not be added during parsing. Instead, the CodeGenerator
1895     # should be responsible for them.
1896 
1897     my $notEnumerableExtendedAttributeList = $extendedAttributeList;
1898     $notEnumerableExtendedAttributeList-&gt;{NotEnumerable} = 1;
1899 
1900     my $sizeAttribute = IDLAttribute-&gt;new();
1901     $sizeAttribute-&gt;name(&quot;size&quot;);
1902     $sizeAttribute-&gt;isMapLike(1);
1903     $sizeAttribute-&gt;extendedAttributes($extendedAttributeList);
1904     $sizeAttribute-&gt;isReadOnly(1);
1905     $sizeAttribute-&gt;type(makeSimpleType(&quot;any&quot;));
1906     push(@{$maplike-&gt;attributes}, $sizeAttribute);
1907 
1908     my $getOperation = IDLOperation-&gt;new();
1909     $getOperation-&gt;name(&quot;get&quot;);
1910     $getOperation-&gt;isMapLike(1);
1911     my $getArgument = IDLArgument-&gt;new();
1912     $getArgument-&gt;name(&quot;key&quot;);
1913     $getArgument-&gt;type($maplike-&gt;keyType);
1914     $getArgument-&gt;extendedAttributes($extendedAttributeList);
1915     push(@{$getOperation-&gt;arguments}, ($getArgument));
1916     $getOperation-&gt;extendedAttributes($notEnumerableExtendedAttributeList);
1917     $getOperation-&gt;type(makeSimpleType(&quot;any&quot;));
1918 
1919     my $hasOperation = IDLOperation-&gt;new();
1920     $hasOperation-&gt;name(&quot;has&quot;);
1921     $hasOperation-&gt;isMapLike(1);
1922     my $hasArgument = IDLArgument-&gt;new();
1923     $hasArgument-&gt;name(&quot;key&quot;);
1924     $hasArgument-&gt;type($maplike-&gt;keyType);
1925     $hasArgument-&gt;extendedAttributes($extendedAttributeList);
1926     push(@{$hasOperation-&gt;arguments}, ($hasArgument));
1927     $hasOperation-&gt;extendedAttributes($notEnumerableExtendedAttributeList);
1928     $hasOperation-&gt;type(makeSimpleType(&quot;any&quot;));
1929 
1930     my $entriesOperation = IDLOperation-&gt;new();
1931     $entriesOperation-&gt;name(&quot;entries&quot;);
1932     $entriesOperation-&gt;isMapLike(1);
1933     $entriesOperation-&gt;extendedAttributes($notEnumerableExtendedAttributeList);
1934     $entriesOperation-&gt;type(makeSimpleType(&quot;any&quot;));
1935 
1936     my $keysOperation = IDLOperation-&gt;new();
1937     $keysOperation-&gt;name(&quot;keys&quot;);
1938     $keysOperation-&gt;isMapLike(1);
1939     $keysOperation-&gt;extendedAttributes($notEnumerableExtendedAttributeList);
1940     $keysOperation-&gt;type(makeSimpleType(&quot;any&quot;));
1941 
1942     my $valuesOperation = IDLOperation-&gt;new();
1943     $valuesOperation-&gt;name(&quot;values&quot;);
1944     $valuesOperation-&gt;isMapLike(1);
1945     $valuesOperation-&gt;extendedAttributes($extendedAttributeList);
1946     $valuesOperation-&gt;extendedAttributes-&gt;{NotEnumerable} = 1;
1947     $valuesOperation-&gt;type(makeSimpleType(&quot;any&quot;));
1948 
1949     my $forEachOperation = IDLOperation-&gt;new();
1950     $forEachOperation-&gt;name(&quot;forEach&quot;);
1951     $forEachOperation-&gt;isMapLike(1);
1952     $forEachOperation-&gt;extendedAttributes({});
1953     $forEachOperation-&gt;type(makeSimpleType(&quot;any&quot;));
1954     my $forEachArgument = IDLArgument-&gt;new();
1955     $forEachArgument-&gt;name(&quot;callback&quot;);
1956     $forEachArgument-&gt;type(makeSimpleType(&quot;any&quot;));
1957     $forEachArgument-&gt;extendedAttributes($extendedAttributeList);
1958     push(@{$forEachOperation-&gt;arguments}, ($forEachArgument));
1959 
1960     push(@{$maplike-&gt;operations}, $getOperation);
1961     push(@{$maplike-&gt;operations}, $hasOperation);
1962     push(@{$maplike-&gt;operations}, $entriesOperation);
1963     push(@{$maplike-&gt;operations}, $keysOperation);
1964     push(@{$maplike-&gt;operations}, $valuesOperation);
1965     push(@{$maplike-&gt;operations}, $forEachOperation);
1966 
1967     return $maplike if $isReadOnly;
1968 
1969     my $addOperation = IDLOperation-&gt;new();
1970     $addOperation-&gt;name(&quot;add&quot;);
1971     $addOperation-&gt;isMapLike(1);
1972     my $addArgument = IDLArgument-&gt;new();
1973     $addArgument-&gt;name(&quot;key&quot;);
1974     $addArgument-&gt;type($maplike-&gt;keyType);
1975     $addArgument-&gt;extendedAttributes($extendedAttributeList);
1976     push(@{$addOperation-&gt;arguments}, ($addArgument));
1977     $addOperation-&gt;extendedAttributes($notEnumerableExtendedAttributeList);
1978     $addOperation-&gt;type(makeSimpleType(&quot;any&quot;));
1979 
1980     my $clearOperation = IDLOperation-&gt;new();
1981     $clearOperation-&gt;name(&quot;clear&quot;);
1982     $clearOperation-&gt;isMapLike(1);
1983     $clearOperation-&gt;extendedAttributes($notEnumerableExtendedAttributeList);
1984     $clearOperation-&gt;type(makeSimpleType(&quot;void&quot;));
1985 
1986     my $deleteOperation = IDLOperation-&gt;new();
1987     $deleteOperation-&gt;name(&quot;delete&quot;);
1988     $deleteOperation-&gt;isMapLike(1);
1989     my $deleteArgument = IDLArgument-&gt;new();
1990     $deleteArgument-&gt;name(&quot;key&quot;);
1991     $deleteArgument-&gt;type($maplike-&gt;keyType);
1992     $deleteArgument-&gt;extendedAttributes($extendedAttributeList);
1993     push(@{$deleteOperation-&gt;arguments}, ($deleteArgument));
1994     $deleteOperation-&gt;extendedAttributes($notEnumerableExtendedAttributeList);
1995     $deleteOperation-&gt;type(makeSimpleType(&quot;any&quot;));
1996 
1997     push(@{$maplike-&gt;operations}, $addOperation);
1998     push(@{$maplike-&gt;operations}, $clearOperation);
1999     push(@{$maplike-&gt;operations}, $deleteOperation);
2000 
2001     return $maplike;
2002 }
2003 
2004 sub parseOperationRest
2005 {
2006     my $self = shift;
2007     my $extendedAttributeList = shift;
2008 
2009     my $next = $self-&gt;nextToken();
2010     if ($next-&gt;type() == IdentifierToken || $next-&gt;value() eq &quot;(&quot;) {
2011         my $operation = IDLOperation-&gt;new();
2012 
2013         my $name = $self-&gt;parseOptionalIdentifier();
2014         $operation-&gt;name(identifierRemoveNullablePrefix($name));
2015 
2016         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;(&quot;, $name, __LINE__);
2017 
2018         push(@{$operation-&gt;arguments}, @{$self-&gt;parseArgumentList()});
2019 
2020         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;)&quot;, __LINE__);
2021         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;;&quot;, __LINE__);
2022 
2023         $self-&gt;assertExtendedAttributesValidForContext($extendedAttributeList, &quot;operation&quot;);
2024         $operation-&gt;extendedAttributes($extendedAttributeList);
2025 
2026         return $operation;
2027     }
2028     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
2029 }
2030 
2031 sub parseOptionalIdentifier
2032 {
2033     my $self = shift;
2034     my $next = $self-&gt;nextToken();
2035     if ($next-&gt;type() == IdentifierToken) {
2036         my $token = $self-&gt;getToken();
2037         return $token-&gt;value();
2038     }
2039     return &quot;&quot;;
2040 }
2041 
2042 sub parseArgumentList
2043 {
2044     my $self = shift;
2045     my @arguments = ();
2046 
2047     my $next = $self-&gt;nextToken();
2048     if ($next-&gt;type() == IdentifierToken || $next-&gt;value() =~ /$nextArgumentList_1/) {
2049         push(@arguments, $self-&gt;parseArgument());
2050         push(@arguments, @{$self-&gt;parseArguments()});
2051     }
2052     return \@arguments;
2053 }
2054 
2055 sub parseArguments
2056 {
2057     my $self = shift;
2058     my @arguments = ();
2059 
2060     while (1) {
2061         my $next = $self-&gt;nextToken();
2062         if ($next-&gt;value() eq &quot;,&quot;) {
2063             $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;,&quot;, __LINE__);
2064             push(@arguments, $self-&gt;parseArgument());
2065         } else {
2066             last;
2067         }
2068     }
2069     return \@arguments;
2070 }
2071 
2072 sub parseArgument
2073 {
2074     my $self = shift;
2075     my $next = $self-&gt;nextToken();
2076     if ($next-&gt;type() == IdentifierToken || $next-&gt;value() =~ /$nextArgumentList_1/) {
2077         my $extendedAttributeList = $self-&gt;parseExtendedAttributeListAllowEmpty();
2078         my $argument = $self-&gt;parseOptionalOrRequiredArgument($extendedAttributeList);
2079         return $argument;
2080     }
2081     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
2082 }
2083 
2084 sub parseOptionalOrRequiredArgument
2085 {
2086     my $self = shift;
2087     my $extendedAttributeList = shift;
2088 
2089     my $argument = IDLArgument-&gt;new();
2090 
2091     my $next = $self-&gt;nextToken();
2092     if ($next-&gt;value() eq &quot;optional&quot;) {
2093         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;optional&quot;, __LINE__);
2094 
2095         my $type = $self-&gt;parseTypeWithExtendedAttributes();
2096         $argument-&gt;type($type);
2097         $argument-&gt;isOptional(1);
2098         $argument-&gt;name($self-&gt;parseArgumentName());
2099         $argument-&gt;default($self-&gt;parseDefault());
2100 
2101         $self-&gt;assertExtendedAttributesValidForContext($extendedAttributeList, &quot;argument&quot;);
2102         $argument-&gt;extendedAttributes($extendedAttributeList);
2103 
2104         return $argument;
2105     }
2106     if ($next-&gt;type() == IdentifierToken || $next-&gt;value() =~ /$nextExceptionField_1/) {
2107         my $type = $self-&gt;parseType();
2108         $self-&gt;moveExtendedAttributesApplicableToTypes($type, $extendedAttributeList);
2109 
2110         $argument-&gt;type($type);
2111         $argument-&gt;isOptional(0);
2112         $argument-&gt;isVariadic($self-&gt;parseEllipsis());
2113         $argument-&gt;name($self-&gt;parseArgumentName());
2114 
2115         $self-&gt;assertExtendedAttributesValidForContext($extendedAttributeList, &quot;argument&quot;);
2116         $argument-&gt;extendedAttributes($extendedAttributeList);
2117 
2118         return $argument;
2119     }
2120     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
2121 }
2122 
2123 sub parseArgumentName
2124 {
2125     my $self = shift;
2126     my $next = $self-&gt;nextToken();
2127     if ($next-&gt;value() =~ /$nextArgumentName_1/) {
2128         return $self-&gt;parseArgumentNameKeyword();
2129     }
2130     if ($next-&gt;type() == IdentifierToken) {
2131         return $self-&gt;getToken()-&gt;value();
2132     }
2133     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
2134 }
2135 
2136 sub parseEllipsis
2137 {
2138     my $self = shift;
2139     my $next = $self-&gt;nextToken();
2140     if ($next-&gt;value() eq &quot;...&quot;) {
2141         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;...&quot;, __LINE__);
2142         return 1;
2143     }
2144     return 0;
2145 }
2146 
2147 sub parseExceptionMember
2148 {
2149     my $self = shift;
2150     my $extendedAttributeList = shift;
2151 
2152     my $next = $self-&gt;nextToken();
2153     if ($next-&gt;value() eq &quot;const&quot;) {
2154         return $self-&gt;parseConst($extendedAttributeList);
2155     }
2156     if ($next-&gt;type() == IdentifierToken || $next-&gt;value() =~ /$nextExceptionField_1/) {
2157         return $self-&gt;parseExceptionField($extendedAttributeList);
2158     }
2159     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
2160 }
2161 
2162 sub parseExceptionField
2163 {
2164     my $self = shift;
2165     my $extendedAttributeList = shift;
2166 
2167     my $next = $self-&gt;nextToken();
2168     if ($next-&gt;type() == IdentifierToken || $next-&gt;value() =~ /$nextExceptionField_1/) {
2169         my $newDataNode = IDLAttribute-&gt;new();
2170         $newDataNode-&gt;isReadOnly(1);
2171 
2172         my $type = $self-&gt;parseType();
2173         $newDataNode-&gt;type($type);
2174         
2175         my $token = $self-&gt;getToken();
2176         $self-&gt;assertTokenType($token, IdentifierToken);
2177         $newDataNode-&gt;name(identifierRemoveNullablePrefix($token-&gt;value()));
2178         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;;&quot;, __LINE__);
2179         $newDataNode-&gt;extendedAttributes($extendedAttributeList);
2180         return $newDataNode;
2181     }
2182     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
2183 }
2184 
2185 sub parseExtendedAttributeListAllowEmpty
2186 {
2187     my $self = shift;
2188     my $next = $self-&gt;nextToken();
2189     if ($next-&gt;value() eq &quot;[&quot;) {
2190         return $self-&gt;parseExtendedAttributeList();
2191     }
2192     return {};
2193 }
2194 
2195 sub parseExtendedAttributeList
2196 {
2197     my $self = shift;
2198     my $next = $self-&gt;nextToken();
2199     if ($next-&gt;value() eq &quot;[&quot;) {
2200         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;[&quot;, __LINE__);
2201         my $extendedAttributeList = {};
2202         my $attr = $self-&gt;parseExtendedAttribute();
2203         copyExtendedAttributes($extendedAttributeList, $attr);
2204         $attr = $self-&gt;parseExtendedAttributes();
2205         copyExtendedAttributes($extendedAttributeList, $attr);
2206         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;]&quot;, __LINE__);
2207         return $extendedAttributeList;
2208     }
2209     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
2210 }
2211 
2212 sub parseExtendedAttributes
2213 {
2214     my $self = shift;
2215     my $extendedAttributeList = {};
2216 
2217     while (1) {
2218         my $next = $self-&gt;nextToken();
2219         if ($next-&gt;value() eq &quot;,&quot;) {
2220             $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;,&quot;, __LINE__);
2221             my $attr = $self-&gt;parseExtendedAttribute2();
2222             copyExtendedAttributes($extendedAttributeList, $attr);
2223         } else {
2224             last;
2225         }
2226     }
2227     return $extendedAttributeList;
2228 }
2229 
2230 sub parseExtendedAttribute
2231 {
2232     my $self = shift;
2233     my $next = $self-&gt;nextToken();
2234     if ($next-&gt;type() == IdentifierToken) {
2235         my $name = $self-&gt;parseName();
2236         return $self-&gt;parseExtendedAttributeRest($name);
2237     }
2238     # backward compatibility. Spec doesn&#39; allow &quot;[]&quot;. But WebKit requires.
2239     if ($next-&gt;value() eq &#39;]&#39;) {
2240         return {};
2241     }
2242     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
2243 }
2244 
2245 sub parseExtendedAttribute2
2246 {
2247     my $self = shift;
2248     my $next = $self-&gt;nextToken();
2249     if ($next-&gt;type() == IdentifierToken) {
2250         my $name = $self-&gt;parseName();
2251         return $self-&gt;parseExtendedAttributeRest($name);
2252     }
2253     return {};
2254 }
2255 
2256 sub parseExtendedAttributeRest
2257 {
2258     my $self = shift;
2259     my $name = shift;
2260     my $attrs = {};
2261 
2262     my $next = $self-&gt;nextToken();
2263     if ($next-&gt;value() eq &quot;(&quot;) {
2264         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;(&quot;, __LINE__);
2265         $attrs-&gt;{$name} = $self-&gt;parseArgumentList();
2266         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;)&quot;, __LINE__);
2267         return $attrs;
2268     }
2269     if ($next-&gt;value() eq &quot;=&quot;) {
2270         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;=&quot;, __LINE__);
2271         $attrs-&gt;{$name} = $self-&gt;parseExtendedAttributeRest2();
2272         return $attrs;
2273     }
2274 
2275     if ($name eq &quot;Constructor&quot; || $name eq &quot;CustomConstructor&quot;) {
2276         $attrs-&gt;{$name} = [];
2277     } else {
2278         $attrs-&gt;{$name} = &quot;VALUE_IS_MISSING&quot;;
2279     }
2280     return $attrs;
2281 }
2282 
2283 sub parseExtendedAttributeRest2
2284 {
2285     my $self = shift;
2286     my $next = $self-&gt;nextToken();
2287     if ($next-&gt;value() eq &quot;(&quot;) {
2288         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;(&quot;, __LINE__);
2289         my @arguments = $self-&gt;parseIdentifierList();
2290         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;)&quot;, __LINE__);
2291         return \@arguments;
2292     }
2293     if ($next-&gt;type() == IdentifierToken) {
2294         my $name = $self-&gt;parseName();
2295         return $self-&gt;parseExtendedAttributeRest3($name);
2296     }
2297     if ($next-&gt;type() == IntegerToken) {
2298         my $token = $self-&gt;getToken();
2299         return $token-&gt;value();
2300     }
2301     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
2302 }
2303 
2304 sub parseExtendedAttributeRest3
2305 {
2306     my $self = shift;
2307     my $name = shift;
2308 
2309     my $next = $self-&gt;nextToken();
2310     if ($next-&gt;value() eq &quot;&amp;&quot;) {
2311         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;&amp;&quot;, __LINE__);
2312         my $rightValue = $self-&gt;parseName();
2313         return $name . &quot;&amp;&quot; . $rightValue;
2314     }
2315     if ($next-&gt;value() eq &quot;|&quot;) {
2316         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;|&quot;, __LINE__);
2317         my $rightValue = $self-&gt;parseName();
2318         return $name . &quot;|&quot; . $rightValue;
2319     }
2320     if ($next-&gt;value() eq &quot;(&quot;) {
2321         my $attr = {};
2322         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;(&quot;, __LINE__);
2323         $attr-&gt;{$name} = $self-&gt;parseArgumentList();
2324         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;)&quot;, __LINE__);
2325         return $attr;
2326     }
2327     if ($next-&gt;type() == IdentifierToken || $next-&gt;value() =~ /$nextExtendedAttributeRest3_1/) {
2328         $self-&gt;parseNameNoComma();
2329         return $name;
2330     }
2331     $self-&gt;assertUnexpectedToken($next-&gt;value());
2332 }
2333 
2334 sub parseArgumentNameKeyword
2335 {
2336     my $self = shift;
2337     my $next = $self-&gt;nextToken();
2338     if ($next-&gt;value() eq &quot;attribute&quot;) {
2339         return $self-&gt;getToken()-&gt;value();
2340     }
2341     if ($next-&gt;value() eq &quot;callback&quot;) {
2342         return $self-&gt;getToken()-&gt;value();
2343     }
2344     if ($next-&gt;value() eq &quot;const&quot;) {
2345         return $self-&gt;getToken()-&gt;value();
2346     }
2347     if ($next-&gt;value() eq &quot;deleter&quot;) {
2348         return $self-&gt;getToken()-&gt;value();
2349     }
2350     if ($next-&gt;value() eq &quot;dictionary&quot;) {
2351         return $self-&gt;getToken()-&gt;value();
2352     }
2353     if ($next-&gt;value() eq &quot;enum&quot;) {
2354         return $self-&gt;getToken()-&gt;value();
2355     }
2356     if ($next-&gt;value() eq &quot;exception&quot;) {
2357         return $self-&gt;getToken()-&gt;value();
2358     }
2359     if ($next-&gt;value() eq &quot;getter&quot;) {
2360         return $self-&gt;getToken()-&gt;value();
2361     }
2362     if ($next-&gt;value() eq &quot;implements&quot;) {
2363         return $self-&gt;getToken()-&gt;value();
2364     }
2365     if ($next-&gt;value() eq &quot;inherit&quot;) {
2366         return $self-&gt;getToken()-&gt;value();
2367     }
2368     if ($next-&gt;value() eq &quot;interface&quot;) {
2369         return $self-&gt;getToken()-&gt;value();
2370     }
2371     if ($next-&gt;value() eq &quot;legacycaller&quot;) {
2372         return $self-&gt;getToken()-&gt;value();
2373     }
2374     if ($next-&gt;value() eq &quot;partial&quot;) {
2375         return $self-&gt;getToken()-&gt;value();
2376     }
2377     if ($next-&gt;value() eq &quot;serializer&quot;) {
2378         return $self-&gt;getToken()-&gt;value();
2379     }
2380     if ($next-&gt;value() eq &quot;setter&quot;) {
2381         return $self-&gt;getToken()-&gt;value();
2382     }
2383     if ($next-&gt;value() eq &quot;static&quot;) {
2384         return $self-&gt;getToken()-&gt;value();
2385     }
2386     if ($next-&gt;value() eq &quot;stringifier&quot;) {
2387         return $self-&gt;getToken()-&gt;value();
2388     }
2389     if ($next-&gt;value() eq &quot;typedef&quot;) {
2390         return $self-&gt;getToken()-&gt;value();
2391     }
2392     if ($next-&gt;value() eq &quot;unrestricted&quot;) {
2393         return $self-&gt;getToken()-&gt;value();
2394     }
2395     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
2396 }
2397 
2398 sub parseType
2399 {
2400     my $self = shift;
2401     my $next = $self-&gt;nextToken();
2402 
2403     my $extendedAttributeList = {};
2404 
2405     if ($next-&gt;value() eq &quot;(&quot;) {
2406         my $unionType = $self-&gt;parseUnionType();
2407         $unionType-&gt;isNullable($self-&gt;parseNull());
2408         $unionType-&gt;extendedAttributes($extendedAttributeList);
2409         return $unionType;
2410     }
2411     if ($next-&gt;type() == IdentifierToken || $next-&gt;value() =~ /$nextType_1/) {
2412         my $singleType = $self-&gt;parseSingleType();
2413         $singleType-&gt;extendedAttributes($extendedAttributeList);
2414         return $singleType;
2415     }
2416     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
2417 }
2418 
2419 sub parseTypeWithExtendedAttributes
2420 {
2421     my $self = shift;
2422     
2423     my $extendedAttributeList = $self-&gt;parseExtendedAttributeListAllowEmpty();
2424     $self-&gt;assertExtendedAttributesValidForContext($extendedAttributeList, &quot;type&quot;);
2425 
2426     my $next = $self-&gt;nextToken();
2427     if ($next-&gt;value() eq &quot;(&quot;) {
2428         my $unionType = $self-&gt;parseUnionType();
2429         $unionType-&gt;isNullable($self-&gt;parseNull());
2430         $unionType-&gt;extendedAttributes($extendedAttributeList);
2431         return $unionType;
2432     }
2433     if ($next-&gt;type() == IdentifierToken || $next-&gt;value() =~ /$nextType_1/) {
2434         my $singleType = $self-&gt;parseSingleType();
2435         $singleType-&gt;extendedAttributes($extendedAttributeList);
2436         return $singleType;
2437     }
2438     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
2439 }
2440 
2441 sub parseSingleType
2442 {
2443     my $self = shift;
2444     my $next = $self-&gt;nextToken();
2445     if ($next-&gt;value() eq &quot;any&quot;) {
2446         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;any&quot;, __LINE__);
2447         
2448         my $anyType = IDLType-&gt;new();
2449         $anyType-&gt;name(&quot;any&quot;);
2450         return $anyType;
2451     }
2452     if ($next-&gt;type() == IdentifierToken || $next-&gt;value() =~ /$nextSingleType_1/) {
2453         my $nonAnyType = $self-&gt;parseNonAnyType();
2454         $nonAnyType-&gt;isNullable($self-&gt;parseNull());
2455         return $nonAnyType;
2456     }
2457     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
2458 }
2459 
2460 sub parseUnionType
2461 {
2462     my $self = shift;
2463     my $next = $self-&gt;nextToken();
2464 
2465     my $unionType = IDLType-&gt;new();
2466     $unionType-&gt;name(&quot;UNION&quot;);
2467     $unionType-&gt;isUnion(1);
2468 
2469     if ($next-&gt;value() eq &quot;(&quot;) {
2470         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;(&quot;, __LINE__);
2471         
2472         push(@{$unionType-&gt;subtypes}, $self-&gt;parseUnionMemberType());
2473         push(@{$unionType-&gt;subtypes}, $self-&gt;parseUnionMemberTypes());
2474         
2475         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;)&quot;, __LINE__);
2476 
2477         return $unionType;
2478     }
2479     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
2480 }
2481 
2482 sub parseUnionMemberType
2483 {
2484     my $self = shift;
2485 
2486     my $extendedAttributeList = $self-&gt;parseExtendedAttributeListAllowEmpty();
2487     $self-&gt;assertExtendedAttributesValidForContext($extendedAttributeList, &quot;type&quot;);
2488 
2489     my $next = $self-&gt;nextToken();
2490 
2491     if ($next-&gt;value() eq &quot;(&quot;) {
2492         my $unionType = $self-&gt;parseUnionType();
2493         $unionType-&gt;isNullable($self-&gt;parseNull());
2494         $unionType-&gt;extendedAttributes($extendedAttributeList);
2495         return $unionType;
2496     }
2497 
2498     if ($next-&gt;type() == IdentifierToken || $next-&gt;value() =~ /$nextSingleType_1/) {
2499         my $nonAnyType = $self-&gt;parseNonAnyType();
2500         $nonAnyType-&gt;isNullable($self-&gt;parseNull());
2501         $nonAnyType-&gt;extendedAttributes($extendedAttributeList);
2502         return $nonAnyType;
2503     }
2504     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
2505 }
2506 
2507 sub parseUnionMemberTypes
2508 {
2509     my $self = shift;
2510     my $next = $self-&gt;nextToken();
2511 
2512     my @subtypes = ();
2513 
2514     if ($next-&gt;value() eq &quot;or&quot;) {
2515         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;or&quot;, __LINE__);
2516         push(@subtypes, $self-&gt;parseUnionMemberType());
2517         push(@subtypes, $self-&gt;parseUnionMemberTypes());
2518     }
2519 
2520     return @subtypes;
2521 }
2522 
2523 sub parseNonAnyType
2524 {
2525     my $self = shift;
2526     my $next = $self-&gt;nextToken();
2527 
2528     my $type = IDLType-&gt;new();
2529 
2530     if ($next-&gt;value() =~ /$nextNonAnyType_1/) {
2531         $type-&gt;name($self-&gt;parsePrimitiveType());
2532         return $type;
2533     }
2534     if ($next-&gt;value() =~ /$nextStringType_1/) {
2535         $type-&gt;name($self-&gt;parseStringType());
2536         return $type;
2537     }
2538     if ($next-&gt;value() eq &quot;object&quot;) {
2539         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;object&quot;, __LINE__);
2540 
2541         $type-&gt;name(&quot;object&quot;);
2542         return $type;
2543     }
2544     if ($next-&gt;value() eq &quot;Error&quot;) {
2545         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;Error&quot;, __LINE__);
2546 
2547         $type-&gt;name(&quot;Error&quot;);
2548         return $type;
2549     }
2550     if ($next-&gt;value() eq &quot;DOMException&quot;) {
2551         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;DOMException&quot;, __LINE__);
2552 
2553         $type-&gt;name(&quot;DOMException&quot;);
2554         return $type;
2555     }
2556     if ($next-&gt;value() eq &quot;Date&quot;) {
2557         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;Date&quot;, __LINE__);
2558 
2559         $type-&gt;name(&quot;Date&quot;);
2560         return $type;
2561     }
2562     if ($next-&gt;value() eq &quot;sequence&quot;) {
2563         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;sequence&quot;, __LINE__);
2564         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;&lt;&quot;, __LINE__);
2565 
2566         my $subtype = $self-&gt;parseTypeWithExtendedAttributes();
2567 
2568         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;&gt;&quot;, __LINE__);
2569 
2570         $type-&gt;name(&quot;sequence&quot;);
2571         push(@{$type-&gt;subtypes}, $subtype);
2572 
2573         return $type;
2574     }
2575     if ($next-&gt;value() eq &quot;FrozenArray&quot;) {
2576         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;FrozenArray&quot;, __LINE__);
2577         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;&lt;&quot;, __LINE__);
2578 
2579         my $subtype = $self-&gt;parseTypeWithExtendedAttributes();
2580 
2581         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;&gt;&quot;, __LINE__);
2582 
2583         $type-&gt;name(&quot;FrozenArray&quot;);
2584         push(@{$type-&gt;subtypes}, $subtype);
2585 
2586         return $type;
2587     }
2588     if ($next-&gt;value() eq &quot;Promise&quot;) {
2589         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;Promise&quot;, __LINE__);
2590         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;&lt;&quot;, __LINE__);
2591 
2592         my $subtype = $self-&gt;parseReturnType();
2593 
2594         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;&gt;&quot;, __LINE__);
2595 
2596         $type-&gt;name(&quot;Promise&quot;);
2597         push(@{$type-&gt;subtypes}, $subtype);
2598 
2599         return $type;
2600     }
2601     if ($next-&gt;value() eq &quot;record&quot;) {
2602         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;record&quot;, __LINE__);
2603         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;&lt;&quot;, __LINE__);
2604 
2605         my $keyType = IDLType-&gt;new();
2606         $keyType-&gt;name($self-&gt;parseStringType());
2607 
2608         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;,&quot;, __LINE__);
2609 
2610         my $valueType = $self-&gt;parseTypeWithExtendedAttributes();
2611 
2612         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;&gt;&quot;, __LINE__);
2613 
2614         $type-&gt;name(&quot;record&quot;);
2615         push(@{$type-&gt;subtypes}, $keyType);
2616         push(@{$type-&gt;subtypes}, $valueType);
2617 
2618         return $type;
2619     }
2620     if ($next-&gt;type() == IdentifierToken) {
2621         my $identifier = $self-&gt;getToken();
2622 
2623         $type-&gt;name(identifierRemoveNullablePrefix($identifier-&gt;value()));
2624         return $type;
2625     }
2626     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
2627 }
2628 
2629 sub parseConstType
2630 {
2631     my $self = shift;
2632     my $next = $self-&gt;nextToken();
2633 
2634     my $type = IDLType-&gt;new();
2635 
2636     if ($next-&gt;value() =~ /$nextNonAnyType_1/) {
2637         $type-&gt;name($self-&gt;parsePrimitiveType());
2638         $type-&gt;isNullable($self-&gt;parseNull());
2639         return $type;
2640     }
2641     if ($next-&gt;type() == IdentifierToken) {
2642         my $identifier = $self-&gt;getToken();
2643         
2644         $type-&gt;name($identifier-&gt;value());
2645         $type-&gt;isNullable($self-&gt;parseNull());
2646 
2647         return $type;
2648     }
2649     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
2650 }
2651 
2652 sub parseStringType
2653 {
2654     my $self = shift;
2655     my $next = $self-&gt;nextToken();
2656     if ($next-&gt;value() eq &quot;ByteString&quot;) {
2657         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;ByteString&quot;, __LINE__);
2658         return &quot;ByteString&quot;;
2659     }
2660     if ($next-&gt;value() eq &quot;DOMString&quot;) {
2661         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;DOMString&quot;, __LINE__);
2662         return &quot;DOMString&quot;;
2663     }
2664     if ($next-&gt;value() eq &quot;USVString&quot;) {
2665         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;USVString&quot;, __LINE__);
2666         return &quot;USVString&quot;;
2667     }
2668     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
2669 }
2670 
2671 sub parsePrimitiveType
2672 {
2673     my $self = shift;
2674     my $next = $self-&gt;nextToken();
2675     if ($next-&gt;value() =~ /$nextPrimitiveType_1/) {
2676         return $self-&gt;parseUnsignedIntegerType();
2677     }
2678     if ($next-&gt;value() =~ /$nextPrimitiveType_2/) {
2679         return $self-&gt;parseUnrestrictedFloatType();
2680     }
2681     if ($next-&gt;value() eq &quot;boolean&quot;) {
2682         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;boolean&quot;, __LINE__);
2683         return &quot;boolean&quot;;
2684     }
2685     if ($next-&gt;value() eq &quot;byte&quot;) {
2686         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;byte&quot;, __LINE__);
2687         return &quot;byte&quot;;
2688     }
2689     if ($next-&gt;value() eq &quot;octet&quot;) {
2690         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;octet&quot;, __LINE__);
2691         return &quot;octet&quot;;
2692     }
2693     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
2694 }
2695 
2696 sub parseUnrestrictedFloatType
2697 {
2698     my $self = shift;
2699     my $next = $self-&gt;nextToken();
2700     if ($next-&gt;value() eq &quot;unrestricted&quot;) {
2701         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;unrestricted&quot;, __LINE__);
2702         return &quot;unrestricted &quot; . $self-&gt;parseFloatType();
2703     }
2704     if ($next-&gt;value() =~ /$nextUnrestrictedFloatType_1/) {
2705         return $self-&gt;parseFloatType();
2706     }
2707     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
2708 }
2709 
2710 sub parseFloatType
2711 {
2712     my $self = shift;
2713     my $next = $self-&gt;nextToken();
2714     if ($next-&gt;value() eq &quot;float&quot;) {
2715         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;float&quot;, __LINE__);
2716         return &quot;float&quot;;
2717     }
2718     if ($next-&gt;value() eq &quot;double&quot;) {
2719         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;double&quot;, __LINE__);
2720         return &quot;double&quot;;
2721     }
2722     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
2723 }
2724 
2725 sub parseUnsignedIntegerType
2726 {
2727     my $self = shift;
2728     my $next = $self-&gt;nextToken();
2729     if ($next-&gt;value() eq &quot;unsigned&quot;) {
2730         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;unsigned&quot;, __LINE__);
2731         return &quot;unsigned &quot; . $self-&gt;parseIntegerType();
2732     }
2733     if ($next-&gt;value() =~ /$nextUnsignedIntegerType_1/) {
2734         return $self-&gt;parseIntegerType();
2735     }
2736     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
2737 }
2738 
2739 sub parseIntegerType
2740 {
2741     my $self = shift;
2742     my $next = $self-&gt;nextToken();
2743     if ($next-&gt;value() eq &quot;short&quot;) {
2744         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;short&quot;, __LINE__);
2745         return &quot;short&quot;;
2746     }
2747     if ($next-&gt;value() eq &quot;int&quot;) {
2748         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;int&quot;, __LINE__);
2749         return &quot;int&quot;;
2750     }
2751     if ($next-&gt;value() eq &quot;long&quot;) {
2752         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;long&quot;, __LINE__);
2753         if ($self-&gt;parseOptionalLong()) {
2754             return &quot;long long&quot;;
2755         }
2756         return &quot;long&quot;;
2757     }
2758     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
2759 }
2760 
2761 sub parseOptionalLong
2762 {
2763     my $self = shift;
2764     my $next = $self-&gt;nextToken();
2765     if ($next-&gt;value() eq &quot;long&quot;) {
2766         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;long&quot;, __LINE__);
2767         return 1;
2768     }
2769     return 0;
2770 }
2771 
2772 sub parseNull
2773 {
2774     my $self = shift;
2775     my $next = $self-&gt;nextToken();
2776     if ($next-&gt;value() eq &quot;?&quot;) {
2777         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;?&quot;, __LINE__);
2778         return 1;
2779     }
2780     return 0;
2781 }
2782 
2783 sub parseReturnType
2784 {
2785     my $self = shift;
2786     my $next = $self-&gt;nextToken();
2787     if ($next-&gt;value() eq &quot;void&quot;) {
2788         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;void&quot;, __LINE__);
2789         
2790         my $voidType = IDLType-&gt;new();
2791         $voidType-&gt;name(&quot;void&quot;);
2792         return $voidType;
2793     }
2794     if ($next-&gt;type() == IdentifierToken || $next-&gt;value() =~ /$nextExceptionField_1/) {
2795         return $self-&gt;parseType();
2796     }
2797     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
2798 }
2799 
2800 sub parseOptionalSemicolon
2801 {
2802     my $self = shift;
2803     my $next = $self-&gt;nextToken();
2804     if ($next-&gt;value() eq &quot;;&quot;) {
2805         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;;&quot;, __LINE__);
2806     }
2807 }
2808 
2809 sub parseNameNoComma
2810 {
2811     my $self = shift;
2812     my $next = $self-&gt;nextToken();
2813     if ($next-&gt;type() == IdentifierToken) {
2814         my $identifier = $self-&gt;getToken();
2815         return ($identifier-&gt;value());
2816     }
2817 
2818     return ();
2819 }
2820 
2821 sub parseName
2822 {
2823     my $self = shift;
2824     my $next = $self-&gt;nextToken();
2825     if ($next-&gt;type() == IdentifierToken) {
2826         my $identifier = $self-&gt;getToken();
2827         return $identifier-&gt;value();
2828     }
2829     $self-&gt;assertUnexpectedToken($next-&gt;value());
2830 }
2831 
2832 sub applyMemberList
2833 {
2834     my $interface = shift;
2835     my $members = shift;
2836 
2837     for my $item (@{$members}) {
2838         if (ref($item) eq &quot;IDLAttribute&quot;) {
2839             push(@{$interface-&gt;attributes}, $item);
2840             next;
2841         }
2842         if (ref($item) eq &quot;IDLConstant&quot;) {
2843             push(@{$interface-&gt;constants}, $item);
2844             next;
2845         }
2846         if (ref($item) eq &quot;IDLIterable&quot;) {
2847             $interface-&gt;iterable($item);
2848             next;
2849         }
2850         if (ref($item) eq &quot;IDLMapLike&quot;) {
2851             $interface-&gt;mapLike($item);
2852             next;
2853         }
2854         if (ref($item) eq &quot;IDLOperation&quot;) {
2855             if ($item-&gt;name eq &quot;&quot;) {
2856                 push(@{$interface-&gt;anonymousOperations}, $item);
2857             } else {
2858                 push(@{$interface-&gt;operations}, $item);
2859             }
2860             next;
2861         }
2862         if (ref($item) eq &quot;IDLSerializable&quot;) {
2863             $interface-&gt;serializable($item);
2864             next;
2865         }
2866     }
2867 
2868     if ($interface-&gt;serializable) {
2869         my $numSerializerAttributes = @{$interface-&gt;serializable-&gt;attributes};
2870         if ($interface-&gt;serializable-&gt;hasAttribute) {
2871             foreach my $attribute (@{$interface-&gt;attributes}) {
2872                 push(@{$interface-&gt;serializable-&gt;attributes}, $attribute-&gt;name);
2873             }
2874         } elsif ($numSerializerAttributes == 0) {
2875             foreach my $attribute (@{$interface-&gt;attributes}) {
2876                 push(@{$interface-&gt;serializable-&gt;attributes}, $attribute-&gt;name);
2877             }
2878         }
2879     }
2880 }
2881 
2882 sub applyExtendedAttributeList
2883 {
2884     my $interface = shift;
2885     my $extendedAttributeList = shift;
2886 
2887     if (defined $extendedAttributeList-&gt;{&quot;Constructors&quot;}) {
2888         my @constructorParams = @{$extendedAttributeList-&gt;{&quot;Constructors&quot;}};
2889         my $index = (@constructorParams == 1) ? 0 : 1;
2890         foreach my $param (@constructorParams) {
2891             my $constructor = IDLOperation-&gt;new();
2892             $constructor-&gt;name(&quot;Constructor&quot;);
2893             $constructor-&gt;extendedAttributes($extendedAttributeList);
2894             $constructor-&gt;arguments($param);
2895             push(@{$interface-&gt;constructors}, $constructor);
2896         }
2897         delete $extendedAttributeList-&gt;{&quot;Constructors&quot;};
2898         $extendedAttributeList-&gt;{&quot;Constructor&quot;} = &quot;VALUE_IS_MISSING&quot;;
2899     } elsif (defined $extendedAttributeList-&gt;{&quot;NamedConstructor&quot;}) {
2900         my $newDataNode = IDLOperation-&gt;new();
2901         $newDataNode-&gt;name(&quot;NamedConstructor&quot;);
2902         $newDataNode-&gt;extendedAttributes($extendedAttributeList);
2903         my %attributes = %{$extendedAttributeList-&gt;{&quot;NamedConstructor&quot;}};
2904         my @attributeKeys = keys (%attributes);
2905         my $constructorName = $attributeKeys[0];
2906         push(@{$newDataNode-&gt;arguments}, @{$attributes{$constructorName}});
2907         $extendedAttributeList-&gt;{&quot;NamedConstructor&quot;} = $constructorName;
2908         push(@{$interface-&gt;constructors}, $newDataNode);
2909     }
2910     if (defined $extendedAttributeList-&gt;{&quot;CustomConstructors&quot;}) {
2911         my @customConstructorParams = @{$extendedAttributeList-&gt;{&quot;CustomConstructors&quot;}};
2912         my $index = (@customConstructorParams == 1) ? 0 : 1;
2913         foreach my $param (@customConstructorParams) {
2914             my $customConstructor = IDLOperation-&gt;new();
2915             $customConstructor-&gt;name(&quot;CustomConstructor&quot;);
2916             $customConstructor-&gt;extendedAttributes($extendedAttributeList);
2917             $customConstructor-&gt;arguments($param);
2918             push(@{$interface-&gt;customConstructors}, $customConstructor);
2919         }
2920         delete $extendedAttributeList-&gt;{&quot;CustomConstructors&quot;};
2921         $extendedAttributeList-&gt;{&quot;CustomConstructor&quot;} = &quot;VALUE_IS_MISSING&quot;;
2922     }
2923     
2924     $interface-&gt;extendedAttributes($extendedAttributeList);
2925 }
2926 
2927 1;
2928 
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>