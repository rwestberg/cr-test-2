<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/dom/Document.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Document.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Document.idl.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/dom/Document.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,11 ***</span>
  /*
   * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
   *           (C) 1999 Antti Koivisto (koivisto@kde.org)
   *           (C) 2001 Dirk Mueller (mueller@kde.org)
   *           (C) 2006 Alexey Proskuryakov (ap@webkit.org)
<span class="line-modified">!  * Copyright (C) 2004-2018 Apple Inc. All rights reserved.</span>
   * Copyright (C) 2008, 2009 Torch Mobile Inc. All rights reserved. (http://www.torchmobile.com/)
   * Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies)
   * Copyright (C) 2011 Google Inc. All rights reserved.
   *
   * This library is free software; you can redistribute it and/or
<span class="line-new-header">--- 1,11 ---</span>
  /*
   * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
   *           (C) 1999 Antti Koivisto (koivisto@kde.org)
   *           (C) 2001 Dirk Mueller (mueller@kde.org)
   *           (C) 2006 Alexey Proskuryakov (ap@webkit.org)
<span class="line-modified">!  * Copyright (C) 2004-2019 Apple Inc. All rights reserved.</span>
   * Copyright (C) 2008, 2009 Torch Mobile Inc. All rights reserved. (http://www.torchmobile.com/)
   * Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies)
   * Copyright (C) 2011 Google Inc. All rights reserved.
   *
   * This library is free software; you can redistribute it and/or
</pre>
<hr />
<pre>
<span class="line-old-header">*** 32,20 ***</span>
<span class="line-new-header">--- 32,24 ---</span>
  #include &quot;ContainerNode.h&quot;
  #include &quot;DisabledAdaptations.h&quot;
  #include &quot;DocumentEventQueue.h&quot;
  #include &quot;DocumentIdentifier.h&quot;
  #include &quot;DocumentTiming.h&quot;
<span class="line-added">+ #include &quot;ElementIdentifier.h&quot;</span>
  #include &quot;FocusDirection.h&quot;
  #include &quot;FontSelectorClient.h&quot;
  #include &quot;FrameDestructionObserver.h&quot;
  #include &quot;GenericTaskQueue.h&quot;
<span class="line-added">+ #include &quot;GraphicsTypes.h&quot;</span>
  #include &quot;MediaProducer.h&quot;
  #include &quot;MutationObserver.h&quot;
  #include &quot;OrientationNotifier.h&quot;
<span class="line-added">+ #include &quot;PageIdentifier.h&quot;</span>
  #include &quot;PlatformEvent.h&quot;
  #include &quot;ReferrerPolicy.h&quot;
  #include &quot;Region.h&quot;
<span class="line-added">+ #include &quot;RegistrableDomain.h&quot;</span>
  #include &quot;RenderPtr.h&quot;
  #include &quot;ScriptExecutionContext.h&quot;
  #include &quot;SecurityPolicyViolationEvent.h&quot;
  #include &quot;StringWithDirection.h&quot;
  #include &quot;StyleColor.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 62,12 ***</span>
  #include &lt;wtf/HashCountedSet.h&gt;
  #include &lt;wtf/HashSet.h&gt;
  #include &lt;wtf/Logger.h&gt;
  #include &lt;wtf/ObjectIdentifier.h&gt;
  #include &lt;wtf/UniqueRef.h&gt;
  #include &lt;wtf/WeakPtr.h&gt;
<span class="line-modified">! #include &lt;wtf/text/AtomicStringHash.h&gt;</span>
  
  #if PLATFORM(IOS_FAMILY)
  #include &quot;EventTrackingRegions.h&quot;
  #endif
  
<span class="line-new-header">--- 66,13 ---</span>
  #include &lt;wtf/HashCountedSet.h&gt;
  #include &lt;wtf/HashSet.h&gt;
  #include &lt;wtf/Logger.h&gt;
  #include &lt;wtf/ObjectIdentifier.h&gt;
  #include &lt;wtf/UniqueRef.h&gt;
<span class="line-added">+ #include &lt;wtf/WeakHashSet.h&gt;</span>
  #include &lt;wtf/WeakPtr.h&gt;
<span class="line-modified">! #include &lt;wtf/text/AtomStringHash.h&gt;</span>
  
  #if PLATFORM(IOS_FAMILY)
  #include &quot;EventTrackingRegions.h&quot;
  #endif
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 96,32 ***</span>
  class CachedScript;
  class CanvasRenderingContext2D;
  class CharacterData;
  class Comment;
  class ConstantPropertyMap;
  class DOMImplementation;
  class DOMSelection;
  class DOMWindow;
  class DOMWrapperWorld;
  class Database;
  class DatabaseThread;
<span class="line-removed">- class DeferredPromise;</span>
<span class="line-removed">- class DocumentAnimationScheduler;</span>
  class DocumentFragment;
  class DocumentLoader;
  class DocumentMarkerController;
  class DocumentParser;
  class DocumentSharedObjectPool;
  class DocumentTimeline;
  class DocumentType;
  class ExtensionStyleSheets;
  class FloatQuad;
  class FloatRect;
  class FontFaceSet;
  class FormController;
  class Frame;
  class FrameView;
  class HTMLAllCollection;
  class HTMLBodyElement;
  class HTMLCanvasElement;
  class HTMLCollection;
  class HTMLDocument;
<span class="line-new-header">--- 101,34 ---</span>
  class CachedScript;
  class CanvasRenderingContext2D;
  class CharacterData;
  class Comment;
  class ConstantPropertyMap;
<span class="line-added">+ class ContentChangeObserver;</span>
  class DOMImplementation;
  class DOMSelection;
<span class="line-added">+ class DOMTimerHoldingTank;</span>
  class DOMWindow;
  class DOMWrapperWorld;
  class Database;
  class DatabaseThread;
  class DocumentFragment;
  class DocumentLoader;
  class DocumentMarkerController;
  class DocumentParser;
  class DocumentSharedObjectPool;
  class DocumentTimeline;
  class DocumentType;
<span class="line-added">+ class EditingBehavior;</span>
  class ExtensionStyleSheets;
  class FloatQuad;
  class FloatRect;
  class FontFaceSet;
  class FormController;
  class Frame;
  class FrameView;
<span class="line-added">+ class FullscreenManager;</span>
  class HTMLAllCollection;
  class HTMLBodyElement;
  class HTMLCanvasElement;
  class HTMLCollection;
  class HTMLDocument;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 158,11 ***</span>
  class PlatformMouseEvent;
  class ProcessingInstruction;
  class QualifiedName;
  class Quirks;
  class Range;
<span class="line-removed">- class RenderFullScreen;</span>
  class RenderTreeBuilder;
  class RenderView;
  class RequestAnimationFrameCallback;
  class SVGDocumentExtensions;
  class SVGSVGElement;
<span class="line-new-header">--- 165,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 191,12 ***</span>
  class VisibilityChangeClient;
  class VisitedLinkState;
  class WebAnimation;
  class WebGL2RenderingContext;
  class WebGLRenderingContext;
<span class="line-modified">! class WebGPURenderingContext;</span>
<span class="line-removed">- class WebMetalRenderingContext;</span>
  class WindowProxy;
  class Worklet;
  class XPathEvaluator;
  class XPathExpression;
  class XPathNSResolver;
<span class="line-new-header">--- 197,11 ---</span>
  class VisibilityChangeClient;
  class VisitedLinkState;
  class WebAnimation;
  class WebGL2RenderingContext;
  class WebGLRenderingContext;
<span class="line-modified">! class GPUCanvasContext;</span>
  class WindowProxy;
  class Worklet;
  class XPathEvaluator;
  class XPathExpression;
  class XPathNSResolver;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 213,25 ***</span>
  
  #if ENABLE(XSLT)
  class TransformSource;
  #endif
  
<span class="line-removed">- #if ENABLE(DASHBOARD_SUPPORT)</span>
<span class="line-removed">- struct AnnotatedRegionValue;</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
  #if ENABLE(TOUCH_EVENTS) || ENABLE(IOS_TOUCH_EVENTS)
  class Touch;
  class TouchList;
  #endif
  
  #if PLATFORM(IOS_FAMILY)
  class DeviceMotionClient;
  class DeviceMotionController;
  class DeviceOrientationClient;
  class DeviceOrientationController;
  #endif
  
  #if ENABLE(TEXT_AUTOSIZING)
  class TextAutoSizing;
  #endif
  
<span class="line-new-header">--- 218,24 ---</span>
  
  #if ENABLE(XSLT)
  class TransformSource;
  #endif
  
  #if ENABLE(TOUCH_EVENTS) || ENABLE(IOS_TOUCH_EVENTS)
  class Touch;
  class TouchList;
  #endif
  
<span class="line-added">+ #if ENABLE(DEVICE_ORIENTATION)</span>
  #if PLATFORM(IOS_FAMILY)
  class DeviceMotionClient;
  class DeviceMotionController;
  class DeviceOrientationClient;
  class DeviceOrientationController;
  #endif
<span class="line-added">+ class DeviceOrientationAndMotionAccessController;</span>
<span class="line-added">+ #endif</span>
  
  #if ENABLE(TEXT_AUTOSIZING)
  class TextAutoSizing;
  #endif
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 245,10 ***</span>
<span class="line-new-header">--- 249,14 ---</span>
  
  #if ENABLE(INTERSECTION_OBSERVER)
  class IntersectionObserver;
  #endif
  
<span class="line-added">+ #if ENABLE(RESIZE_OBSERVER)</span>
<span class="line-added">+ class ResizeObserver;</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
  namespace Style {
  class Scope;
  };
  
  const uint64_t HTMLMediaElementInvalidID = 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 314,14 ***</span>
  #endif
  #if ENABLE(WEBGL2)
      RefPtr&lt;WebGL2RenderingContext&gt;,
  #endif
  #if ENABLE(WEBGPU)
<span class="line-modified">!     RefPtr&lt;WebGPURenderingContext&gt;,</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- #if ENABLE(WEBMETAL)</span>
<span class="line-removed">-     RefPtr&lt;WebMetalRenderingContext&gt;,</span>
  #endif
      RefPtr&lt;ImageBitmapRenderingContext&gt;,
      RefPtr&lt;CanvasRenderingContext2D&gt;
  &gt;;
  
<span class="line-new-header">--- 322,11 ---</span>
  #endif
  #if ENABLE(WEBGL2)
      RefPtr&lt;WebGL2RenderingContext&gt;,
  #endif
  #if ENABLE(WEBGPU)
<span class="line-modified">!     RefPtr&lt;GPUCanvasContext&gt;,</span>
  #endif
      RefPtr&lt;ImageBitmapRenderingContext&gt;,
      RefPtr&lt;CanvasRenderingContext2D&gt;
  &gt;;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 338,17 ***</span>
  class Document
      : public ContainerNode
      , public TreeScope
      , public ScriptExecutionContext
      , public FontSelectorClient
<span class="line-removed">-     , public CanMakeWeakPtr&lt;Document&gt;</span>
      , public FrameDestructionObserver
      , public Supplementable&lt;Document&gt;
      , public Logger::Observer {
      WTF_MAKE_ISO_ALLOCATED(Document);
  public:
<span class="line-modified">!     static Ref&lt;Document&gt; create(const URL&amp;);</span>
      static Ref&lt;Document&gt; createNonRenderedPlaceholder(Frame&amp;, const URL&amp;);
      static Ref&lt;Document&gt; create(Document&amp;);
  
      virtual ~Document();
  
<span class="line-new-header">--- 343,16 ---</span>
  class Document
      : public ContainerNode
      , public TreeScope
      , public ScriptExecutionContext
      , public FontSelectorClient
      , public FrameDestructionObserver
      , public Supplementable&lt;Document&gt;
      , public Logger::Observer {
      WTF_MAKE_ISO_ALLOCATED(Document);
  public:
<span class="line-modified">!     static Ref&lt;Document&gt; create(PAL::SessionID, const URL&amp;);</span>
      static Ref&lt;Document&gt; createNonRenderedPlaceholder(Frame&amp;, const URL&amp;);
      static Ref&lt;Document&gt; create(Document&amp;);
  
      virtual ~Document();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 369,11 ***</span>
          --m_referencingNodeCount;
          if (!m_referencingNodeCount &amp;&amp; !refCount()) {
  #if !ASSERT_DISABLED
              m_deletionHasBegun = true;
  #endif
<span class="line-modified">!             m_refCount = 1; // Avoid double destruction through use of RefPtr&lt;T&gt;. (This is a security mitigation in case of programmer error. It will ASSERT in debug builds.)</span>
              delete this;
          }
      }
  
      unsigned referencingNodeCount() const { return m_referencingNodeCount; }
<span class="line-new-header">--- 373,11 ---</span>
          --m_referencingNodeCount;
          if (!m_referencingNodeCount &amp;&amp; !refCount()) {
  #if !ASSERT_DISABLED
              m_deletionHasBegun = true;
  #endif
<span class="line-modified">!             m_refCountAndParentBit = s_refCountIncrement; // Avoid double destruction through use of Ref&lt;T&gt;/RefPtr&lt;T&gt;. (This is a security mitigation in case of programmer error. It will ASSERT in debug builds.)</span>
              delete this;
          }
      }
  
      unsigned referencingNodeCount() const { return m_referencingNodeCount; }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 384,10 ***</span>
<span class="line-new-header">--- 388,14 ---</span>
  
      using DocumentsMap = HashMap&lt;DocumentIdentifier, Document*&gt;;
      WEBCORE_EXPORT static DocumentsMap::ValuesIteratorRange allDocuments();
      WEBCORE_EXPORT static DocumentsMap&amp; allDocumentsMap();
  
<span class="line-added">+     WEBCORE_EXPORT ElementIdentifier identifierForElement(Element&amp;);</span>
<span class="line-added">+     WEBCORE_EXPORT Element* searchForElementByIdentifier(const ElementIdentifier&amp;);</span>
<span class="line-added">+     void identifiedElementWasRemovedFromDocument(Element&amp;);</span>
<span class="line-added">+ </span>
      MediaQueryMatcher&amp; mediaQueryMatcher();
  
      using ContainerNode::ref;
      using ContainerNode::deref;
      using TreeScope::rootNode;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 399,13 ***</span>
  
      ExceptionOr&lt;SelectorQuery&amp;&gt; selectorQueryForString(const String&amp;);
      void clearSelectorQueryCache();
  
      void setViewportArguments(const ViewportArguments&amp; viewportArguments) { m_viewportArguments = viewportArguments; }
<span class="line-modified">!     ViewportArguments viewportArguments() const { return m_viewportArguments; }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     WEBCORE_EXPORT void setOverrideViewportArguments(const Optional&lt;ViewportArguments&gt;&amp;);</span>
  
      OptionSet&lt;DisabledAdaptations&gt; disabledAdaptations() const { return m_disabledAdaptations; }
  #ifndef NDEBUG
      bool didDispatchViewportPropertiesChanged() const { return m_didDispatchViewportPropertiesChanged; }
  #endif
<span class="line-new-header">--- 407,11 ---</span>
  
      ExceptionOr&lt;SelectorQuery&amp;&gt; selectorQueryForString(const String&amp;);
      void clearSelectorQueryCache();
  
      void setViewportArguments(const ViewportArguments&amp; viewportArguments) { m_viewportArguments = viewportArguments; }
<span class="line-modified">!     WEBCORE_EXPORT ViewportArguments viewportArguments() const;</span>
  
      OptionSet&lt;DisabledAdaptations&gt; disabledAdaptations() const { return m_disabledAdaptations; }
  #ifndef NDEBUG
      bool didDispatchViewportPropertiesChanged() const { return m_didDispatchViewportPropertiesChanged; }
  #endif
</pre>
<hr />
<pre>
<span class="line-old-header">*** 423,23 ***</span>
      WEBCORE_EXPORT Element* activeElement();
      WEBCORE_EXPORT bool hasFocus() const;
  
      bool hasManifest() const;
  
<span class="line-modified">!     WEBCORE_EXPORT ExceptionOr&lt;Ref&lt;Element&gt;&gt; createElementForBindings(const AtomicString&amp; tagName);</span>
      WEBCORE_EXPORT Ref&lt;DocumentFragment&gt; createDocumentFragment();
      WEBCORE_EXPORT Ref&lt;Text&gt; createTextNode(const String&amp; data);
      WEBCORE_EXPORT Ref&lt;Comment&gt; createComment(const String&amp; data);
      WEBCORE_EXPORT ExceptionOr&lt;Ref&lt;CDATASection&gt;&gt; createCDATASection(const String&amp; data);
      WEBCORE_EXPORT ExceptionOr&lt;Ref&lt;ProcessingInstruction&gt;&gt; createProcessingInstruction(const String&amp; target, const String&amp; data);
      WEBCORE_EXPORT ExceptionOr&lt;Ref&lt;Attr&gt;&gt; createAttribute(const String&amp; name);
<span class="line-modified">!     WEBCORE_EXPORT ExceptionOr&lt;Ref&lt;Attr&gt;&gt; createAttributeNS(const AtomicString&amp; namespaceURI, const String&amp; qualifiedName, bool shouldIgnoreNamespaceChecks = false);</span>
      WEBCORE_EXPORT ExceptionOr&lt;Ref&lt;Node&gt;&gt; importNode(Node&amp; nodeToImport, bool deep);
<span class="line-modified">!     WEBCORE_EXPORT ExceptionOr&lt;Ref&lt;Element&gt;&gt; createElementNS(const AtomicString&amp; namespaceURI, const String&amp; qualifiedName);</span>
      WEBCORE_EXPORT Ref&lt;Element&gt; createElement(const QualifiedName&amp;, bool createdByParser);
  
<span class="line-modified">!     static CustomElementNameValidationStatus validateCustomElementName(const AtomicString&amp;);</span>
  
      WEBCORE_EXPORT RefPtr&lt;Range&gt; caretRangeFromPoint(int x, int y);
      RefPtr&lt;Range&gt; caretRangeFromPoint(const LayoutPoint&amp; clientPoint);
  
      WEBCORE_EXPORT Element* scrollingElementForAPI();
<span class="line-new-header">--- 429,23 ---</span>
      WEBCORE_EXPORT Element* activeElement();
      WEBCORE_EXPORT bool hasFocus() const;
  
      bool hasManifest() const;
  
<span class="line-modified">!     WEBCORE_EXPORT ExceptionOr&lt;Ref&lt;Element&gt;&gt; createElementForBindings(const AtomString&amp; tagName);</span>
      WEBCORE_EXPORT Ref&lt;DocumentFragment&gt; createDocumentFragment();
      WEBCORE_EXPORT Ref&lt;Text&gt; createTextNode(const String&amp; data);
      WEBCORE_EXPORT Ref&lt;Comment&gt; createComment(const String&amp; data);
      WEBCORE_EXPORT ExceptionOr&lt;Ref&lt;CDATASection&gt;&gt; createCDATASection(const String&amp; data);
      WEBCORE_EXPORT ExceptionOr&lt;Ref&lt;ProcessingInstruction&gt;&gt; createProcessingInstruction(const String&amp; target, const String&amp; data);
      WEBCORE_EXPORT ExceptionOr&lt;Ref&lt;Attr&gt;&gt; createAttribute(const String&amp; name);
<span class="line-modified">!     WEBCORE_EXPORT ExceptionOr&lt;Ref&lt;Attr&gt;&gt; createAttributeNS(const AtomString&amp; namespaceURI, const String&amp; qualifiedName, bool shouldIgnoreNamespaceChecks = false);</span>
      WEBCORE_EXPORT ExceptionOr&lt;Ref&lt;Node&gt;&gt; importNode(Node&amp; nodeToImport, bool deep);
<span class="line-modified">!     WEBCORE_EXPORT ExceptionOr&lt;Ref&lt;Element&gt;&gt; createElementNS(const AtomString&amp; namespaceURI, const String&amp; qualifiedName);</span>
      WEBCORE_EXPORT Ref&lt;Element&gt; createElement(const QualifiedName&amp;, bool createdByParser);
  
<span class="line-modified">!     static CustomElementNameValidationStatus validateCustomElementName(const AtomString&amp;);</span>
  
      WEBCORE_EXPORT RefPtr&lt;Range&gt; caretRangeFromPoint(int x, int y);
      RefPtr&lt;Range&gt; caretRangeFromPoint(const LayoutPoint&amp; clientPoint);
  
      WEBCORE_EXPORT Element* scrollingElementForAPI();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 452,11 ***</span>
  
      String charset() const { return Document::encoding(); }
      WEBCORE_EXPORT String characterSetWithUTF8Fallback() const;
      TextEncoding textEncoding() const;
  
<span class="line-modified">!     AtomicString encoding() const { return textEncoding().domName(); }</span>
  
      WEBCORE_EXPORT void setCharset(const String&amp;); // Used by ObjC / GOBject bindings only.
  
      void setContent(const String&amp;);
  
<span class="line-new-header">--- 458,11 ---</span>
  
      String charset() const { return Document::encoding(); }
      WEBCORE_EXPORT String characterSetWithUTF8Fallback() const;
      TextEncoding textEncoding() const;
  
<span class="line-modified">!     AtomString encoding() const { return textEncoding().domName(); }</span>
  
      WEBCORE_EXPORT void setCharset(const String&amp;); // Used by ObjC / GOBject bindings only.
  
      void setContent(const String&amp;);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 499,14 ***</span>
      WEBCORE_EXPORT Ref&lt;HTMLCollection&gt; links();
      WEBCORE_EXPORT Ref&lt;HTMLCollection&gt; forms();
      WEBCORE_EXPORT Ref&lt;HTMLCollection&gt; anchors();
      WEBCORE_EXPORT Ref&lt;HTMLCollection&gt; scripts();
      Ref&lt;HTMLCollection&gt; all();
<span class="line-modified">!     Ref&lt;HTMLCollection&gt; allFilteredByName(const AtomicString&amp;);</span>
  
<span class="line-modified">!     Ref&lt;HTMLCollection&gt; windowNamedItems(const AtomicString&amp;);</span>
<span class="line-modified">!     Ref&lt;HTMLCollection&gt; documentNamedItems(const AtomicString&amp;);</span>
  
      // Other methods (not part of DOM)
      bool isSynthesized() const { return m_isSynthesized; }
      bool isHTMLDocument() const { return m_documentClasses &amp; HTMLDocumentClass; }
      bool isXHTMLDocument() const { return m_documentClasses &amp; XHTMLDocumentClass; }
<span class="line-new-header">--- 505,14 ---</span>
      WEBCORE_EXPORT Ref&lt;HTMLCollection&gt; links();
      WEBCORE_EXPORT Ref&lt;HTMLCollection&gt; forms();
      WEBCORE_EXPORT Ref&lt;HTMLCollection&gt; anchors();
      WEBCORE_EXPORT Ref&lt;HTMLCollection&gt; scripts();
      Ref&lt;HTMLCollection&gt; all();
<span class="line-modified">!     Ref&lt;HTMLCollection&gt; allFilteredByName(const AtomString&amp;);</span>
  
<span class="line-modified">!     Ref&lt;HTMLCollection&gt; windowNamedItems(const AtomString&amp;);</span>
<span class="line-modified">!     Ref&lt;HTMLCollection&gt; documentNamedItems(const AtomString&amp;);</span>
  
      // Other methods (not part of DOM)
      bool isSynthesized() const { return m_isSynthesized; }
      bool isHTMLDocument() const { return m_documentClasses &amp; HTMLDocumentClass; }
      bool isXHTMLDocument() const { return m_documentClasses &amp; XHTMLDocumentClass; }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 551,19 ***</span>
<span class="line-new-header">--- 557,22 ---</span>
  
      WEBCORE_EXPORT FrameView* view() const; // Can be null.
      WEBCORE_EXPORT Page* page() const; // Can be null.
      const Settings&amp; settings() const { return m_settings.get(); }
      Settings&amp; mutableSettings() { return m_settings.get(); }
<span class="line-added">+     EditingBehavior editingBehavior() const;</span>
  
      const Quirks&amp; quirks() const { return m_quirks; }
  
      float deviceScaleFactor() const;
  
      WEBCORE_EXPORT bool useSystemAppearance() const;
<span class="line-added">+     WEBCORE_EXPORT bool useElevatedUserInterfaceLevel() const;</span>
      WEBCORE_EXPORT bool useDarkAppearance(const RenderStyle*) const;
  
      OptionSet&lt;StyleColor::Options&gt; styleColorOptions(const RenderStyle*) const;
<span class="line-added">+     CompositeOperator compositeOperatorForBackgroundColor(const Color&amp;, const RenderObject&amp;) const;</span>
  
      WEBCORE_EXPORT Ref&lt;Range&gt; createRange();
  
      // The last bool parameter is for ObjC bindings.
      WEBCORE_EXPORT Ref&lt;NodeIterator&gt; createNodeIterator(Node&amp; root, unsigned long whatToShow = 0xFFFFFFFF, RefPtr&lt;NodeFilter&gt;&amp;&amp; = nullptr, bool = false);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 623,18 ***</span>
  
      AXObjectCache* existingAXObjectCache() const;
      WEBCORE_EXPORT AXObjectCache* axObjectCache() const;
      void clearAXObjectCache();
  
<span class="line-modified">!     Optional&lt;uint64_t&gt; pageID() const;</span>
      // to get visually ordered hebrew and arabic pages right
      void setVisuallyOrdered();
      bool visuallyOrdered() const { return m_visuallyOrdered; }
  
      WEBCORE_EXPORT DocumentLoader* loader() const;
  
<span class="line-modified">!     WEBCORE_EXPORT ExceptionOr&lt;RefPtr&lt;WindowProxy&gt;&gt; openForBindings(DOMWindow&amp; activeWindow, DOMWindow&amp; firstDOMWindow, const String&amp; url, const AtomicString&amp; name, const String&amp; features);</span>
      WEBCORE_EXPORT ExceptionOr&lt;Document&amp;&gt; openForBindings(Document* responsibleDocument, const String&amp;, const String&amp;);
  
      // FIXME: We should rename this at some point and give back the name &#39;open&#39; to the HTML specified ones.
      WEBCORE_EXPORT ExceptionOr&lt;void&gt; open(Document* responsibleDocument = nullptr);
      void implicitOpen();
<span class="line-new-header">--- 632,18 ---</span>
  
      AXObjectCache* existingAXObjectCache() const;
      WEBCORE_EXPORT AXObjectCache* axObjectCache() const;
      void clearAXObjectCache();
  
<span class="line-modified">!     Optional&lt;PageIdentifier&gt; pageID() const;</span>
      // to get visually ordered hebrew and arabic pages right
      void setVisuallyOrdered();
      bool visuallyOrdered() const { return m_visuallyOrdered; }
  
      WEBCORE_EXPORT DocumentLoader* loader() const;
  
<span class="line-modified">!     WEBCORE_EXPORT ExceptionOr&lt;RefPtr&lt;WindowProxy&gt;&gt; openForBindings(DOMWindow&amp; activeWindow, DOMWindow&amp; firstDOMWindow, const String&amp; url, const AtomString&amp; name, const String&amp; features);</span>
      WEBCORE_EXPORT ExceptionOr&lt;Document&amp;&gt; openForBindings(Document* responsibleDocument, const String&amp;, const String&amp;);
  
      // FIXME: We should rename this at some point and give back the name &#39;open&#39; to the HTML specified ones.
      WEBCORE_EXPORT ExceptionOr&lt;void&gt; open(Document* responsibleDocument = nullptr);
      void implicitOpen();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 752,11 ***</span>
      void adjustFocusNavigationNodeOnNodeRemoval(Node&amp;, NodeRemoval = NodeRemoval::Node);
  
      void hoveredElementDidDetach(Element&amp;);
      void elementInActiveChainDidDetach(Element&amp;);
  
<span class="line-modified">!     void updateHoverActiveState(const HitTestRequest&amp;, Element*);</span>
  
      // Updates for :target (CSS3 selector).
      void setCSSTarget(Element*);
      Element* cssTarget() const { return m_cssTarget; }
      static ptrdiff_t cssTargetMemoryOffset() { return OBJECT_OFFSETOF(Document, m_cssTarget); }
<span class="line-new-header">--- 761,12 ---</span>
      void adjustFocusNavigationNodeOnNodeRemoval(Node&amp;, NodeRemoval = NodeRemoval::Node);
  
      void hoveredElementDidDetach(Element&amp;);
      void elementInActiveChainDidDetach(Element&amp;);
  
<span class="line-modified">!     enum class CaptureChange : uint8_t { Yes, No };</span>
<span class="line-added">+     void updateHoverActiveState(const HitTestRequest&amp;, Element*, CaptureChange = CaptureChange::No);</span>
  
      // Updates for :target (CSS3 selector).
      void setCSSTarget(Element*);
      Element* cssTarget() const { return m_cssTarget; }
      static ptrdiff_t cssTargetMemoryOffset() { return OBJECT_OFFSETOF(Document, m_cssTarget); }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 815,13 ***</span>
  
      Document&amp; contextDocument() const;
      void setContextDocument(Document&amp; document) { m_contextDocument = makeWeakPtr(document); }
  
      // Helper functions for forwarding DOMWindow event related tasks to the DOMWindow if it exists.
<span class="line-modified">!     void setWindowAttributeEventListener(const AtomicString&amp; eventType, const QualifiedName&amp; attributeName, const AtomicString&amp; value, DOMWrapperWorld&amp;);</span>
<span class="line-modified">!     void setWindowAttributeEventListener(const AtomicString&amp; eventType, RefPtr&lt;EventListener&gt;&amp;&amp;, DOMWrapperWorld&amp;);</span>
<span class="line-modified">!     EventListener* getWindowAttributeEventListener(const AtomicString&amp; eventType, DOMWrapperWorld&amp;);</span>
      WEBCORE_EXPORT void dispatchWindowEvent(Event&amp;, EventTarget* = nullptr);
      void dispatchWindowLoadEvent();
  
      WEBCORE_EXPORT ExceptionOr&lt;Ref&lt;Event&gt;&gt; createEvent(const String&amp; eventType);
  
<span class="line-new-header">--- 825,13 ---</span>
  
      Document&amp; contextDocument() const;
      void setContextDocument(Document&amp; document) { m_contextDocument = makeWeakPtr(document); }
  
      // Helper functions for forwarding DOMWindow event related tasks to the DOMWindow if it exists.
<span class="line-modified">!     void setWindowAttributeEventListener(const AtomString&amp; eventType, const QualifiedName&amp; attributeName, const AtomString&amp; value, DOMWrapperWorld&amp;);</span>
<span class="line-modified">!     void setWindowAttributeEventListener(const AtomString&amp; eventType, RefPtr&lt;EventListener&gt;&amp;&amp;, DOMWrapperWorld&amp;);</span>
<span class="line-modified">!     EventListener* getWindowAttributeEventListener(const AtomString&amp; eventType, DOMWrapperWorld&amp;);</span>
      WEBCORE_EXPORT void dispatchWindowEvent(Event&amp;, EventTarget* = nullptr);
      void dispatchWindowLoadEvent();
  
      WEBCORE_EXPORT ExceptionOr&lt;Ref&lt;Event&gt;&gt; createEvent(const String&amp; eventType);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 848,11 ***</span>
          RESIZE_LISTENER                      = 1 &lt;&lt; 17
      };
  
      bool hasListenerType(ListenerType listenerType) const { return (m_listenerTypes &amp; listenerType); }
      bool hasListenerTypeForEventType(PlatformEvent::Type) const;
<span class="line-modified">!     void addListenerTypeIfNeeded(const AtomicString&amp; eventType);</span>
  
      bool hasMutationObserversOfType(MutationObserver::MutationType type) const
      {
          return m_mutationObserverTypes &amp; type;
      }
<span class="line-new-header">--- 858,11 ---</span>
          RESIZE_LISTENER                      = 1 &lt;&lt; 17
      };
  
      bool hasListenerType(ListenerType listenerType) const { return (m_listenerTypes &amp; listenerType); }
      bool hasListenerTypeForEventType(PlatformEvent::Type) const;
<span class="line-modified">!     void addListenerTypeIfNeeded(const AtomString&amp; eventType);</span>
  
      bool hasMutationObserversOfType(MutationObserver::MutationType type) const
      {
          return m_mutationObserverTypes &amp; type;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 870,31 ***</span>
  #if PLATFORM(IOS_FAMILY)
      void processFormatDetection(const String&amp;);
  
      // Called when &lt;meta name=&quot;apple-mobile-web-app-orientations&quot;&gt; changes.
      void processWebAppOrientations();
  #endif
  
      void processViewport(const String&amp; features, ViewportArguments::Type origin);
      void processDisabledAdaptations(const String&amp; adaptations);
      void updateViewportArguments();
      void processReferrerPolicy(const String&amp; policy, ReferrerPolicySource);
  
  #if ENABLE(DARK_MODE_CSS)
<span class="line-modified">!     void processSupportedColorSchemes(const String&amp; colorSchemes);</span>
  #endif
  
      // Returns the owning element in the parent document.
      // Returns nullptr if this is the top level document.
      HTMLFrameOwnerElement* ownerElement() const;
  
      // Used by DOM bindings; no direction known.
      const String&amp; title() const { return m_title.string; }
      WEBCORE_EXPORT void setTitle(const String&amp;);
  
<span class="line-modified">!     WEBCORE_EXPORT const AtomicString&amp; dir() const;</span>
<span class="line-modified">!     WEBCORE_EXPORT void setDir(const AtomicString&amp;);</span>
  
      void titleElementAdded(Element&amp; titleElement);
      void titleElementRemoved(Element&amp; titleElement);
      void titleElementTextChanged(Element&amp; titleElement);
  
<span class="line-new-header">--- 880,36 ---</span>
  #if PLATFORM(IOS_FAMILY)
      void processFormatDetection(const String&amp;);
  
      // Called when &lt;meta name=&quot;apple-mobile-web-app-orientations&quot;&gt; changes.
      void processWebAppOrientations();
<span class="line-added">+ </span>
<span class="line-added">+     WEBCORE_EXPORT ContentChangeObserver&amp; contentChangeObserver();</span>
<span class="line-added">+ </span>
<span class="line-added">+     DOMTimerHoldingTank* domTimerHoldingTankIfExists() { return m_domTimerHoldingTank.get(); }</span>
<span class="line-added">+     DOMTimerHoldingTank&amp; domTimerHoldingTank();</span>
  #endif
  
      void processViewport(const String&amp; features, ViewportArguments::Type origin);
      void processDisabledAdaptations(const String&amp; adaptations);
      void updateViewportArguments();
      void processReferrerPolicy(const String&amp; policy, ReferrerPolicySource);
  
  #if ENABLE(DARK_MODE_CSS)
<span class="line-modified">!     void processColorScheme(const String&amp; colorScheme);</span>
  #endif
  
      // Returns the owning element in the parent document.
      // Returns nullptr if this is the top level document.
      HTMLFrameOwnerElement* ownerElement() const;
  
      // Used by DOM bindings; no direction known.
      const String&amp; title() const { return m_title.string; }
      WEBCORE_EXPORT void setTitle(const String&amp;);
  
<span class="line-modified">!     WEBCORE_EXPORT const AtomString&amp; dir() const;</span>
<span class="line-modified">!     WEBCORE_EXPORT void setDir(const AtomString&amp;);</span>
  
      void titleElementAdded(Element&amp; titleElement);
      void titleElementRemoved(Element&amp; titleElement);
      void titleElementTextChanged(Element&amp; titleElement);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 952,12 ***</span>
      // and make it sensitive to the type of document.
      static bool isValidName(const String&amp;);
  
      // The following breaks a qualified name into a prefix and a local name.
      // It also does a validity check, and returns an error if the qualified name is invalid.
<span class="line-modified">!     static ExceptionOr&lt;std::pair&lt;AtomicString, AtomicString&gt;&gt; parseQualifiedName(const String&amp; qualifiedName);</span>
<span class="line-modified">!     static ExceptionOr&lt;QualifiedName&gt; parseQualifiedName(const AtomicString&amp; namespaceURI, const String&amp; qualifiedName);</span>
  
      // Checks to make sure prefix and namespace do not conflict (per DOM Core 3)
      static bool hasValidNamespaceForElements(const QualifiedName&amp;);
      static bool hasValidNamespaceForAttributes(const QualifiedName&amp;);
  
<span class="line-new-header">--- 967,12 ---</span>
      // and make it sensitive to the type of document.
      static bool isValidName(const String&amp;);
  
      // The following breaks a qualified name into a prefix and a local name.
      // It also does a validity check, and returns an error if the qualified name is invalid.
<span class="line-modified">!     static ExceptionOr&lt;std::pair&lt;AtomString, AtomString&gt;&gt; parseQualifiedName(const String&amp; qualifiedName);</span>
<span class="line-modified">!     static ExceptionOr&lt;QualifiedName&gt; parseQualifiedName(const AtomString&amp; namespaceURI, const String&amp; qualifiedName);</span>
  
      // Checks to make sure prefix and namespace do not conflict (per DOM Core 3)
      static bool hasValidNamespaceForElements(const QualifiedName&amp;);
      static bool hasValidNamespaceForAttributes(const QualifiedName&amp;);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1016,11 ***</span>
  #endif
  
      void incDOMTreeVersion() { m_domTreeVersion = ++s_globalTreeVersion; }
      uint64_t domTreeVersion() const { return m_domTreeVersion; }
  
<span class="line-modified">!     WEBCORE_EXPORT String originIdentifierForPasteboard();</span>
  
      // XPathEvaluator methods
      WEBCORE_EXPORT ExceptionOr&lt;Ref&lt;XPathExpression&gt;&gt; createExpression(const String&amp; expression, RefPtr&lt;XPathNSResolver&gt;&amp;&amp;);
      WEBCORE_EXPORT Ref&lt;XPathNSResolver&gt; createNSResolver(Node* nodeResolver);
      WEBCORE_EXPORT ExceptionOr&lt;Ref&lt;XPathResult&gt;&gt; evaluate(const String&amp; expression, Node* contextNode, RefPtr&lt;XPathNSResolver&gt;&amp;&amp;, unsigned short type, XPathResult*);
<span class="line-new-header">--- 1031,11 ---</span>
  #endif
  
      void incDOMTreeVersion() { m_domTreeVersion = ++s_globalTreeVersion; }
      uint64_t domTreeVersion() const { return m_domTreeVersion; }
  
<span class="line-modified">!     WEBCORE_EXPORT String originIdentifierForPasteboard() const;</span>
  
      // XPathEvaluator methods
      WEBCORE_EXPORT ExceptionOr&lt;Ref&lt;XPathExpression&gt;&gt; createExpression(const String&amp; expression, RefPtr&lt;XPathNSResolver&gt;&amp;&amp;);
      WEBCORE_EXPORT Ref&lt;XPathNSResolver&gt; createNSResolver(Node* nodeResolver);
      WEBCORE_EXPORT ExceptionOr&lt;Ref&lt;XPathResult&gt;&gt; evaluate(const String&amp; expression, Node* contextNode, RefPtr&lt;XPathNSResolver&gt;&amp;&amp;, unsigned short type, XPathResult*);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1042,10 ***</span>
<span class="line-new-header">--- 1057,13 ---</span>
  
      ScriptedAnimationController* scriptedAnimationController() { return m_scriptedAnimationController.get(); }
      void suspendScriptedAnimationControllerCallbacks();
      void resumeScriptedAnimationControllerCallbacks();
  
<span class="line-added">+     void updateAnimationsAndSendEvents(DOMHighResTimeStamp timestamp);</span>
<span class="line-added">+     void serviceRequestAnimationFrameCallbacks(DOMHighResTimeStamp timestamp);</span>
<span class="line-added">+ </span>
      void windowScreenDidChange(PlatformDisplayID);
  
      void finishedParsing();
  
      enum PageCacheState { NotInPageCache, AboutToEnterPageCache, InPageCache };
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1072,11 ***</span>
  #endif
  
      void registerForPrivateBrowsingStateChangedCallbacks(Element&amp;);
      void unregisterForPrivateBrowsingStateChangedCallbacks(Element&amp;);
      void storageBlockingStateDidChange();
<span class="line-modified">!     void privateBrowsingStateDidChange();</span>
  
  #if ENABLE(VIDEO_TRACK)
      void registerForCaptionPreferencesChangedCallbacks(Element&amp;);
      void unregisterForCaptionPreferencesChangedCallbacks(Element&amp;);
      void captionPreferencesChanged();
<span class="line-new-header">--- 1090,11 ---</span>
  #endif
  
      void registerForPrivateBrowsingStateChangedCallbacks(Element&amp;);
      void unregisterForPrivateBrowsingStateChangedCallbacks(Element&amp;);
      void storageBlockingStateDidChange();
<span class="line-modified">!     void privateBrowsingStateDidChange(PAL::SessionID);</span>
  
  #if ENABLE(VIDEO_TRACK)
      void registerForCaptionPreferencesChangedCallbacks(Element&amp;);
      void unregisterForCaptionPreferencesChangedCallbacks(Element&amp;);
      void captionPreferencesChanged();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1100,29 ***</span>
      void allowsMediaDocumentInlinePlaybackChanged();
  
      void stopAllMediaPlayback();
      void suspendAllMediaPlayback();
      void resumeAllMediaPlayback();
  #endif
  
      WEBCORE_EXPORT void setShouldCreateRenderers(bool);
      bool shouldCreateRenderers();
  
      void setDecoder(RefPtr&lt;TextResourceDecoder&gt;&amp;&amp;);
      TextResourceDecoder* decoder() const { return m_decoder.get(); }
  
      WEBCORE_EXPORT String displayStringModifiedByEncoding(const String&amp;) const;
  
<span class="line-modified">! #if ENABLE(DASHBOARD_SUPPORT)</span>
<span class="line-removed">-     void setHasAnnotatedRegions(bool f) { m_hasAnnotatedRegions = f; }</span>
<span class="line-removed">-     WEBCORE_EXPORT const Vector&lt;AnnotatedRegionValue&gt;&amp; annotatedRegions() const;</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
<span class="line-removed">-     enum class AnnotationsAction { Invalidate, Update };</span>
<span class="line-removed">-     void invalidateRenderingDependentRegions(AnnotationsAction = AnnotationsAction::Invalidate);</span>
<span class="line-removed">-     void invalidateScrollbarDependentRegions();</span>
<span class="line-removed">-     void updateZOrderDependentRegions();</span>
  
      void removeAllEventListeners() final;
  
      WEBCORE_EXPORT const SVGDocumentExtensions* svgExtensions();
      WEBCORE_EXPORT SVGDocumentExtensions&amp; accessSVGExtensions();
<span class="line-new-header">--- 1118,23 ---</span>
      void allowsMediaDocumentInlinePlaybackChanged();
  
      void stopAllMediaPlayback();
      void suspendAllMediaPlayback();
      void resumeAllMediaPlayback();
<span class="line-added">+     void suspendAllMediaBuffering();</span>
<span class="line-added">+     void resumeAllMediaBuffering();</span>
  #endif
  
      WEBCORE_EXPORT void setShouldCreateRenderers(bool);
      bool shouldCreateRenderers();
  
      void setDecoder(RefPtr&lt;TextResourceDecoder&gt;&amp;&amp;);
      TextResourceDecoder* decoder() const { return m_decoder.get(); }
  
      WEBCORE_EXPORT String displayStringModifiedByEncoding(const String&amp;) const;
  
<span class="line-modified">!     void invalidateRenderingDependentRegions();</span>
  
      void removeAllEventListeners() final;
  
      WEBCORE_EXPORT const SVGDocumentExtensions* svgExtensions();
      WEBCORE_EXPORT SVGDocumentExtensions&amp; accessSVGExtensions();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1156,46 ***</span>
      WEBCORE_EXPORT void addMediaCanStartListener(MediaCanStartListener&amp;);
      WEBCORE_EXPORT void removeMediaCanStartListener(MediaCanStartListener&amp;);
      MediaCanStartListener* takeAnyMediaCanStartListener();
  
  #if ENABLE(FULLSCREEN_API)
<span class="line-modified">!     bool webkitIsFullScreen() const { return m_fullScreenElement.get(); }</span>
<span class="line-modified">!     bool webkitFullScreenKeyboardInputAllowed() const { return m_fullScreenElement.get() &amp;&amp; m_areKeysEnabledInFullScreen; }</span>
<span class="line-removed">-     Element* webkitCurrentFullScreenElement() const { return m_fullScreenElement.get(); }</span>
<span class="line-removed">-     Element* webkitCurrentFullScreenElementForBindings() const { return ancestorElementInThisScope(webkitCurrentFullScreenElement()); }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     enum FullScreenCheckType {</span>
<span class="line-removed">-         EnforceIFrameAllowFullScreenRequirement,</span>
<span class="line-removed">-         ExemptIFrameAllowFullScreenRequirement,</span>
<span class="line-removed">-     };</span>
<span class="line-removed">- </span>
<span class="line-removed">-     void requestFullScreenForElement(Element*, FullScreenCheckType);</span>
<span class="line-removed">-     WEBCORE_EXPORT void webkitCancelFullScreen();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     WEBCORE_EXPORT void webkitWillEnterFullScreen(Element&amp;);</span>
<span class="line-removed">-     WEBCORE_EXPORT void webkitDidEnterFullScreen();</span>
<span class="line-removed">-     WEBCORE_EXPORT void webkitWillExitFullScreen();</span>
<span class="line-removed">-     WEBCORE_EXPORT void webkitDidExitFullScreen();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     void setFullScreenRenderer(RenderTreeBuilder&amp;, RenderFullScreen&amp;);</span>
<span class="line-removed">-     RenderFullScreen* fullScreenRenderer() const { return m_fullScreenRenderer.get(); }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     void dispatchFullScreenChangeEvents();</span>
<span class="line-removed">-     bool fullScreenIsAllowedForElement(Element&amp;) const;</span>
<span class="line-removed">-     void fullScreenElementRemoved();</span>
<span class="line-removed">-     void adjustFullScreenElementOnNodeRemoval(Node&amp;, NodeRemoval = NodeRemoval::Node);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     WEBCORE_EXPORT bool isAnimatingFullScreen() const;</span>
<span class="line-removed">-     WEBCORE_EXPORT void setAnimatingFullScreen(bool);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     WEBCORE_EXPORT bool areFullscreenControlsHidden() const;</span>
<span class="line-removed">-     WEBCORE_EXPORT void setFullscreenControlsHidden(bool);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     WEBCORE_EXPORT bool webkitFullscreenEnabled() const;</span>
<span class="line-removed">-     Element* webkitFullscreenElement() const { return !m_fullScreenElementStack.isEmpty() ? m_fullScreenElementStack.last().get() : nullptr; }</span>
<span class="line-removed">-     Element* webkitFullscreenElementForBindings() const { return ancestorElementInThisScope(webkitFullscreenElement()); }</span>
<span class="line-removed">-     WEBCORE_EXPORT void webkitExitFullscreen();</span>
  #endif
  
  #if ENABLE(POINTER_LOCK)
      WEBCORE_EXPORT void exitPointerLock();
  #endif
<span class="line-new-header">--- 1168,12 ---</span>
      WEBCORE_EXPORT void addMediaCanStartListener(MediaCanStartListener&amp;);
      WEBCORE_EXPORT void removeMediaCanStartListener(MediaCanStartListener&amp;);
      MediaCanStartListener* takeAnyMediaCanStartListener();
  
  #if ENABLE(FULLSCREEN_API)
<span class="line-modified">!     FullscreenManager&amp; fullscreenManager() { return m_fullscreenManager; }</span>
<span class="line-modified">!     const FullscreenManager&amp; fullscreenManager() const { return m_fullscreenManager; }</span>
  #endif
  
  #if ENABLE(POINTER_LOCK)
      WEBCORE_EXPORT void exitPointerLock();
  #endif
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1208,16 ***</span>
  
  #if ENABLE(IOS_TOUCH_EVENTS)
  #include &lt;WebKitAdditions/DocumentIOS.h&gt;
  #endif
  
<span class="line-modified">! #if ENABLE(DEVICE_ORIENTATION) &amp;&amp; PLATFORM(IOS_FAMILY)</span>
      DeviceMotionController&amp; deviceMotionController() const;
      DeviceOrientationController&amp; deviceOrientationController() const;
      WEBCORE_EXPORT void simulateDeviceOrientationChange(double alpha, double beta, double gamma);
  #endif
  
      const DocumentTiming&amp; timing() const { return m_documentTiming; }
  
      WEBCORE_EXPORT double monotonicTimestamp() const;
  
      int requestAnimationFrame(Ref&lt;RequestAnimationFrameCallback&gt;&amp;&amp;);
<span class="line-new-header">--- 1186,20 ---</span>
  
  #if ENABLE(IOS_TOUCH_EVENTS)
  #include &lt;WebKitAdditions/DocumentIOS.h&gt;
  #endif
  
<span class="line-modified">! #if ENABLE(DEVICE_ORIENTATION)</span>
<span class="line-added">+ #if PLATFORM(IOS_FAMILY)</span>
      DeviceMotionController&amp; deviceMotionController() const;
      DeviceOrientationController&amp; deviceOrientationController() const;
      WEBCORE_EXPORT void simulateDeviceOrientationChange(double alpha, double beta, double gamma);
  #endif
  
<span class="line-added">+     DeviceOrientationAndMotionAccessController&amp; deviceOrientationAndMotionAccessController();</span>
<span class="line-added">+ #endif // ENABLE(DEVICE_ORIENTATION)</span>
<span class="line-added">+ </span>
      const DocumentTiming&amp; timing() const { return m_documentTiming; }
  
      WEBCORE_EXPORT double monotonicTimestamp() const;
  
      int requestAnimationFrame(Ref&lt;RequestAnimationFrameCallback&gt;&amp;&amp;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1233,10 ***</span>
<span class="line-new-header">--- 1215,11 ---</span>
  
      MonotonicTime lastHandledUserGestureTimestamp() const { return m_lastHandledUserGestureTimestamp; }
      bool hasHadUserInteraction() const { return static_cast&lt;bool&gt;(m_lastHandledUserGestureTimestamp); }
      void updateLastHandledUserGestureTimestamp(MonotonicTime);
      bool processingUserGestureForMedia() const;
<span class="line-added">+     void userActivatedMediaFinishedPlaying() { m_userActivatedMediaFinishedPlayingTimestamp = MonotonicTime::now(); }</span>
  
      void setUserDidInteractWithPage(bool userDidInteractWithPage) { ASSERT(&amp;topDocument() == this); m_userDidInteractWithPage = userDidInteractWithPage; }
      bool userDidInteractWithPage() const { ASSERT(&amp;topDocument() == this); return m_userDidInteractWithPage; }
  
      // Used for testing. Count handlers in the main document, and one per frame which contains handlers.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1251,13 ***</span>
      bool touchEventTargetsContain(Node&amp; node) const { return m_touchEventTargets ? m_touchEventTargets-&gt;contains(&amp;node) : false; }
  #else
      bool hasTouchEventHandlers() const { return false; }
      bool touchEventTargetsContain(Node&amp;) const { return false; }
  #endif
<span class="line-modified">! #if ENABLE(POINTER_EVENTS)</span>
<span class="line-modified">!     void updateTouchActionElements(Element&amp;, const RenderStyle&amp;);</span>
<span class="line-modified">!     const HashSet&lt;RefPtr&lt;Element&gt;&gt;* touchActionElements() const { return m_touchActionElements.get(); }</span>
  #endif
  
      void didAddTouchEventHandler(Node&amp;);
      void didRemoveTouchEventHandler(Node&amp;, EventHandlerRemoval = EventHandlerRemoval::One);
  
<span class="line-new-header">--- 1234,13 ---</span>
      bool touchEventTargetsContain(Node&amp; node) const { return m_touchEventTargets ? m_touchEventTargets-&gt;contains(&amp;node) : false; }
  #else
      bool hasTouchEventHandlers() const { return false; }
      bool touchEventTargetsContain(Node&amp;) const { return false; }
  #endif
<span class="line-modified">! #if PLATFORM(IOS_FAMILY) &amp;&amp; ENABLE(POINTER_EVENTS)</span>
<span class="line-modified">!     bool mayHaveElementsWithNonAutoTouchAction() const { return m_mayHaveElementsWithNonAutoTouchAction; }</span>
<span class="line-modified">!     void setMayHaveElementsWithNonAutoTouchAction() { m_mayHaveElementsWithNonAutoTouchAction = true; }</span>
  #endif
  
      void didAddTouchEventHandler(Node&amp;);
      void didRemoveTouchEventHandler(Node&amp;, EventHandlerRemoval = EventHandlerRemoval::One);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1299,11 ***</span>
      void incrementActiveParserCount() { ++m_activeParserCount; }
      void decrementActiveParserCount();
  
      std::unique_ptr&lt;DocumentParserYieldToken&gt; createParserYieldToken()
      {
<span class="line-modified">!         return std::make_unique&lt;DocumentParserYieldToken&gt;(*this);</span>
      }
  
      bool hasActiveParserYieldToken() const { return m_parserYieldTokenCount; }
  
      DocumentSharedObjectPool* sharedObjectPool() { return m_sharedObjectPool.get(); }
<span class="line-new-header">--- 1282,11 ---</span>
      void incrementActiveParserCount() { ++m_activeParserCount; }
      void decrementActiveParserCount();
  
      std::unique_ptr&lt;DocumentParserYieldToken&gt; createParserYieldToken()
      {
<span class="line-modified">!         return makeUnique&lt;DocumentParserYieldToken&gt;(*this);</span>
      }
  
      bool hasActiveParserYieldToken() const { return m_parserYieldTokenCount; }
  
      DocumentSharedObjectPool* sharedObjectPool() { return m_sharedObjectPool.get(); }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1319,22 ***</span>
      void setIsResolvingTreeStyle(bool);
  
      void updateTextRenderer(Text&amp;, unsigned offsetOfReplacedText, unsigned lengthOfReplacedText);
  
      // Return a Locale for the default locale if the argument is null or empty.
<span class="line-modified">!     Locale&amp; getCachedLocale(const AtomicString&amp; locale = nullAtom());</span>
  
      const Document* templateDocument() const;
      Document&amp; ensureTemplateDocument();
<span class="line-modified">!     void setTemplateDocumentHost(Document* templateDocumentHost) { m_templateDocumentHost = templateDocumentHost; }</span>
<span class="line-modified">!     Document* templateDocumentHost() { return m_templateDocumentHost; }</span>
  
      void didAssociateFormControl(Element&amp;);
      bool hasDisabledFieldsetElement() const { return m_disabledFieldsetElementsCount; }
      void addDisabledFieldsetElement() { m_disabledFieldsetElementsCount++; }
      void removeDisabledFieldsetElement() { ASSERT(m_disabledFieldsetElementsCount); m_disabledFieldsetElementsCount--; }
  
      WEBCORE_EXPORT void addConsoleMessage(std::unique_ptr&lt;Inspector::ConsoleMessage&gt;&amp;&amp;) final;
  
      // The following addConsoleMessage function is deprecated.
      // Callers should try to create the ConsoleMessage themselves.
      WEBCORE_EXPORT void addConsoleMessage(MessageSource, MessageLevel, const String&amp; message, unsigned long requestIdentifier = 0) final;
<span class="line-new-header">--- 1302,24 ---</span>
      void setIsResolvingTreeStyle(bool);
  
      void updateTextRenderer(Text&amp;, unsigned offsetOfReplacedText, unsigned lengthOfReplacedText);
  
      // Return a Locale for the default locale if the argument is null or empty.
<span class="line-modified">!     Locale&amp; getCachedLocale(const AtomString&amp; locale = nullAtom());</span>
  
      const Document* templateDocument() const;
      Document&amp; ensureTemplateDocument();
<span class="line-modified">!     void setTemplateDocumentHost(Document* templateDocumentHost) { m_templateDocumentHost = makeWeakPtr(templateDocumentHost); }</span>
<span class="line-modified">!     Document* templateDocumentHost() { return m_templateDocumentHost.get(); }</span>
  
      void didAssociateFormControl(Element&amp;);
      bool hasDisabledFieldsetElement() const { return m_disabledFieldsetElementsCount; }
      void addDisabledFieldsetElement() { m_disabledFieldsetElementsCount++; }
      void removeDisabledFieldsetElement() { ASSERT(m_disabledFieldsetElementsCount); m_disabledFieldsetElementsCount--; }
  
<span class="line-added">+     void getParserLocation(String&amp; url, unsigned&amp; line, unsigned&amp; column) const;</span>
<span class="line-added">+ </span>
      WEBCORE_EXPORT void addConsoleMessage(std::unique_ptr&lt;Inspector::ConsoleMessage&gt;&amp;&amp;) final;
  
      // The following addConsoleMessage function is deprecated.
      // Callers should try to create the ConsoleMessage themselves.
      WEBCORE_EXPORT void addConsoleMessage(MessageSource, MessageLevel, const String&amp; message, unsigned long requestIdentifier = 0) final;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1388,16 ***</span>
      void removeViewportDependentPicture(HTMLPictureElement&amp;);
  
      void addAppearanceDependentPicture(HTMLPictureElement&amp;);
      void removeAppearanceDependentPicture(HTMLPictureElement&amp;);
  
  #if ENABLE(INTERSECTION_OBSERVER)
      void addIntersectionObserver(IntersectionObserver&amp;);
      void removeIntersectionObserver(IntersectionObserver&amp;);
      unsigned numberOfIntersectionObservers() const { return m_intersectionObservers.size(); }
<span class="line-removed">-     void scheduleForcedIntersectionObservationUpdate();</span>
      void updateIntersectionObservations();
  #endif
  
  #if ENABLE(MEDIA_STREAM)
      void setHasCaptureMediaStreamTrack() { m_hasHadCaptureMediaStreamTrack = true; }
      bool hasHadCaptureMediaStreamTrack() const { return m_hasHadCaptureMediaStreamTrack; }
<span class="line-new-header">--- 1373,30 ---</span>
      void removeViewportDependentPicture(HTMLPictureElement&amp;);
  
      void addAppearanceDependentPicture(HTMLPictureElement&amp;);
      void removeAppearanceDependentPicture(HTMLPictureElement&amp;);
  
<span class="line-added">+     void scheduleTimedRenderingUpdate();</span>
<span class="line-added">+ </span>
  #if ENABLE(INTERSECTION_OBSERVER)
      void addIntersectionObserver(IntersectionObserver&amp;);
      void removeIntersectionObserver(IntersectionObserver&amp;);
      unsigned numberOfIntersectionObservers() const { return m_intersectionObservers.size(); }
      void updateIntersectionObservations();
<span class="line-added">+     void scheduleInitialIntersectionObservationUpdate();</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
<span class="line-added">+ #if ENABLE(RESIZE_OBSERVER)</span>
<span class="line-added">+     void addResizeObserver(ResizeObserver&amp;);</span>
<span class="line-added">+     void removeResizeObserver(ResizeObserver&amp;);</span>
<span class="line-added">+     bool hasResizeObservers();</span>
<span class="line-added">+     // Return the minDepth of the active observations.</span>
<span class="line-added">+     size_t gatherResizeObservations(size_t deeperThan);</span>
<span class="line-added">+     void deliverResizeObservations();</span>
<span class="line-added">+     bool hasSkippedResizeObservations() const;</span>
<span class="line-added">+     void setHasSkippedResizeObservations(bool);</span>
<span class="line-added">+     void updateResizeObservations(Page&amp;);</span>
  #endif
  
  #if ENABLE(MEDIA_STREAM)
      void setHasCaptureMediaStreamTrack() { m_hasHadCaptureMediaStreamTrack = true; }
      bool hasHadCaptureMediaStreamTrack() const { return m_hasHadCaptureMediaStreamTrack; }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1419,11 ***</span>
      WEBCORE_EXPORT bool isTelephoneNumberParsingAllowed() const;
      WEBCORE_EXPORT bool isTelephoneNumberParsingEnabled() const;
  #endif
  
      using ContainerNode::setAttributeEventListener;
<span class="line-modified">!     void setAttributeEventListener(const AtomicString&amp; eventType, const QualifiedName&amp; attributeName, const AtomicString&amp; value, DOMWrapperWorld&amp; isolatedWorld);</span>
  
      DOMSelection* getSelection();
  
      void didInsertInDocumentShadowRoot(ShadowRoot&amp;);
      void didRemoveInDocumentShadowRoot(ShadowRoot&amp;);
<span class="line-new-header">--- 1418,11 ---</span>
      WEBCORE_EXPORT bool isTelephoneNumberParsingAllowed() const;
      WEBCORE_EXPORT bool isTelephoneNumberParsingEnabled() const;
  #endif
  
      using ContainerNode::setAttributeEventListener;
<span class="line-modified">!     void setAttributeEventListener(const AtomString&amp; eventType, const QualifiedName&amp; attributeName, const AtomString&amp; value, DOMWrapperWorld&amp; isolatedWorld);</span>
  
      DOMSelection* getSelection();
  
      void didInsertInDocumentShadowRoot(ShadowRoot&amp;);
      void didRemoveInDocumentShadowRoot(ShadowRoot&amp;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1435,19 ***</span>
      ConstantPropertyMap&amp; constantProperties() const { return *m_constantPropertyMap; }
  
      void orientationChanged(int orientation);
      OrientationNotifier&amp; orientationNotifier() { return m_orientationNotifier; }
  
<span class="line-modified">!     WEBCORE_EXPORT const AtomicString&amp; bgColor() const;</span>
      WEBCORE_EXPORT void setBgColor(const String&amp;);
<span class="line-modified">!     WEBCORE_EXPORT const AtomicString&amp; fgColor() const;</span>
      WEBCORE_EXPORT void setFgColor(const String&amp;);
<span class="line-modified">!     WEBCORE_EXPORT const AtomicString&amp; alinkColor() const;</span>
      WEBCORE_EXPORT void setAlinkColor(const String&amp;);
<span class="line-modified">!     WEBCORE_EXPORT const AtomicString&amp; linkColorForBindings() const;</span>
      WEBCORE_EXPORT void setLinkColorForBindings(const String&amp;);
<span class="line-modified">!     WEBCORE_EXPORT const AtomicString&amp; vlinkColor() const;</span>
      WEBCORE_EXPORT void setVlinkColor(const String&amp;);
  
      // Per https://html.spec.whatwg.org/multipage/obsolete.html#dom-document-clear, this method does nothing.
      void clear() { }
      // Per https://html.spec.whatwg.org/multipage/obsolete.html#dom-document-captureevents, this method does nothing.
<span class="line-new-header">--- 1434,19 ---</span>
      ConstantPropertyMap&amp; constantProperties() const { return *m_constantPropertyMap; }
  
      void orientationChanged(int orientation);
      OrientationNotifier&amp; orientationNotifier() { return m_orientationNotifier; }
  
<span class="line-modified">!     WEBCORE_EXPORT const AtomString&amp; bgColor() const;</span>
      WEBCORE_EXPORT void setBgColor(const String&amp;);
<span class="line-modified">!     WEBCORE_EXPORT const AtomString&amp; fgColor() const;</span>
      WEBCORE_EXPORT void setFgColor(const String&amp;);
<span class="line-modified">!     WEBCORE_EXPORT const AtomString&amp; alinkColor() const;</span>
      WEBCORE_EXPORT void setAlinkColor(const String&amp;);
<span class="line-modified">!     WEBCORE_EXPORT const AtomString&amp; linkColorForBindings() const;</span>
      WEBCORE_EXPORT void setLinkColorForBindings(const String&amp;);
<span class="line-modified">!     WEBCORE_EXPORT const AtomString&amp; vlinkColor() const;</span>
      WEBCORE_EXPORT void setVlinkColor(const String&amp;);
  
      // Per https://html.spec.whatwg.org/multipage/obsolete.html#dom-document-clear, this method does nothing.
      void clear() { }
      // Per https://html.spec.whatwg.org/multipage/obsolete.html#dom-document-captureevents, this method does nothing.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1457,22 ***</span>
  
  #if ENABLE(TEXT_AUTOSIZING)
      TextAutoSizing&amp; textAutoSizing();
  #endif
  
<span class="line-modified">!     Logger&amp; logger();</span>
  
<span class="line-modified">!     void hasStorageAccess(Ref&lt;DeferredPromise&gt;&amp;&amp; passedPromise);</span>
<span class="line-removed">-     void requestStorageAccess(Ref&lt;DeferredPromise&gt;&amp;&amp; passedPromise);</span>
<span class="line-removed">-     void setUserGrantsStorageAccessOverride(bool value) { m_grantStorageAccessOverride = value; }</span>
  
      WEBCORE_EXPORT void setConsoleMessageListener(RefPtr&lt;StringCallback&gt;&amp;&amp;); // For testing.
  
<span class="line-removed">- #if USE(REQUEST_ANIMATION_FRAME_DISPLAY_MONITOR)</span>
<span class="line-removed">-     DocumentAnimationScheduler&amp; animationScheduler();</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
      WEBCORE_EXPORT DocumentTimeline&amp; timeline();
      DocumentTimeline* existingTimeline() const { return m_timeline.get(); }
      Vector&lt;RefPtr&lt;WebAnimation&gt;&gt; getAnimations();
  
  #if ENABLE(ATTACHMENT_ELEMENT)
<span class="line-new-header">--- 1456,17 ---</span>
  
  #if ENABLE(TEXT_AUTOSIZING)
      TextAutoSizing&amp; textAutoSizing();
  #endif
  
<span class="line-modified">!     // For debugging rdar://problem/49877867.</span>
<span class="line-added">+     void setMayBeDetachedFromFrame(bool mayBeDetachedFromFrame) { m_mayBeDetachedFromFrame = mayBeDetachedFromFrame; }</span>
  
<span class="line-modified">!     Logger&amp; logger();</span>
  
      WEBCORE_EXPORT void setConsoleMessageListener(RefPtr&lt;StringCallback&gt;&amp;&amp;); // For testing.
  
      WEBCORE_EXPORT DocumentTimeline&amp; timeline();
      DocumentTimeline* existingTimeline() const { return m_timeline.get(); }
      Vector&lt;RefPtr&lt;WebAnimation&gt;&gt; getAnimations();
  
  #if ENABLE(ATTACHMENT_ELEMENT)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1494,18 ***</span>
  #if ENABLE(IOS_TOUCH_EVENTS)
      bool handlingTouchEvent() const { return m_handlingTouchEvent; }
  #endif
  
  #if ENABLE(RESOURCE_LOAD_STATISTICS)
<span class="line-modified">!     bool hasRequestedPageSpecificStorageAccessWithUserInteraction(const String&amp; primaryDomain);</span>
<span class="line-modified">!     void setHasRequestedPageSpecificStorageAccessWithUserInteraction(const String&amp; primaryDomain);</span>
  #endif
  
      String signedPublicKeyAndChallengeString(unsigned keySizeIndex, const String&amp; challengeString, const URL&amp;);
  
<span class="line-removed">-     void consumeTemporaryTimeUserGesture();</span>
<span class="line-removed">- </span>
      void registerArticleElement(Element&amp;);
      void unregisterArticleElement(Element&amp;);
      void updateMainArticleElementAfterLayout();
      bool hasMainArticleElement() const { return !!m_mainArticleElement; }
  
<span class="line-new-header">--- 1488,18 ---</span>
  #if ENABLE(IOS_TOUCH_EVENTS)
      bool handlingTouchEvent() const { return m_handlingTouchEvent; }
  #endif
  
  #if ENABLE(RESOURCE_LOAD_STATISTICS)
<span class="line-modified">!     bool hasRequestedPageSpecificStorageAccessWithUserInteraction(const RegistrableDomain&amp;);</span>
<span class="line-modified">!     void setHasRequestedPageSpecificStorageAccessWithUserInteraction(const RegistrableDomain&amp;);</span>
<span class="line-added">+     WEBCORE_EXPORT void wasLoadedWithDataTransferFromPrevalentResource();</span>
<span class="line-added">+     void downgradeReferrerToRegistrableDomain();</span>
  #endif
  
      String signedPublicKeyAndChallengeString(unsigned keySizeIndex, const String&amp; challengeString, const URL&amp;);
  
      void registerArticleElement(Element&amp;);
      void unregisterArticleElement(Element&amp;);
      void updateMainArticleElementAfterLayout();
      bool hasMainArticleElement() const { return !!m_mainArticleElement; }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1516,12 ***</span>
      Worklet&amp; ensurePaintWorklet();
      PaintWorkletGlobalScope* paintWorkletGlobalScopeForName(const String&amp; name);
      void setPaintWorkletGlobalScopeForName(const String&amp; name, Ref&lt;PaintWorkletGlobalScope&gt;&amp;&amp;);
  #endif
  
<span class="line-modified">!     void setAsRunningUserScripts() { m_isRunningUserScripts = true; }</span>
<span class="line-modified">!     bool isRunningUserScripts() const { return m_isRunningUserScripts; }</span>
  
      void frameWasDisconnectedFromOwner();
  
      WEBCORE_EXPORT bool hitTest(const HitTestRequest&amp;, HitTestResult&amp;);
      bool hitTest(const HitTestRequest&amp;, const HitTestLocation&amp;, HitTestResult&amp;);
<span class="line-new-header">--- 1510,18 ---</span>
      Worklet&amp; ensurePaintWorklet();
      PaintWorkletGlobalScope* paintWorkletGlobalScopeForName(const String&amp; name);
      void setPaintWorkletGlobalScopeForName(const String&amp; name, Ref&lt;PaintWorkletGlobalScope&gt;&amp;&amp;);
  #endif
  
<span class="line-modified">!     WEBCORE_EXPORT bool hasEvaluatedUserAgentScripts() const;</span>
<span class="line-modified">!     WEBCORE_EXPORT bool isRunningUserScripts() const;</span>
<span class="line-added">+     WEBCORE_EXPORT void setAsRunningUserScripts();</span>
<span class="line-added">+     void setHasEvaluatedUserAgentScripts();</span>
<span class="line-added">+ #if ENABLE(APPLE_PAY)</span>
<span class="line-added">+     WEBCORE_EXPORT bool isApplePayActive() const;</span>
<span class="line-added">+     WEBCORE_EXPORT void setApplePayIsActive();</span>
<span class="line-added">+ #endif</span>
  
      void frameWasDisconnectedFromOwner();
  
      WEBCORE_EXPORT bool hitTest(const HitTestRequest&amp;, HitTestResult&amp;);
      bool hitTest(const HitTestRequest&amp;, const HitTestLocation&amp;, HitTestResult&amp;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1529,11 ***</span>
      bool inHitTesting() const { return m_inHitTesting; }
  #endif
  
  protected:
      enum ConstructionFlags { Synthesized = 1, NonRenderedPlaceholder = 1 &lt;&lt; 1 };
<span class="line-modified">!     Document(Frame*, const URL&amp;, unsigned = DefaultDocumentClass, unsigned constructionFlags = 0);</span>
  
      void clearXMLVersion() { m_xmlVersion = String(); }
  
      virtual Ref&lt;Document&gt; cloneDocumentWithoutChildren() const;
  
<span class="line-new-header">--- 1529,11 ---</span>
      bool inHitTesting() const { return m_inHitTesting; }
  #endif
  
  protected:
      enum ConstructionFlags { Synthesized = 1, NonRenderedPlaceholder = 1 &lt;&lt; 1 };
<span class="line-modified">!     Document(PAL::SessionID, Frame*, const URL&amp;, unsigned = DefaultDocumentClass, unsigned constructionFlags = 0);</span>
  
      void clearXMLVersion() { m_xmlVersion = String(); }
  
      virtual Ref&lt;Document&gt; cloneDocumentWithoutChildren() const;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1594,18 ***</span>
  
      void detachFromFrame();
  
      template&lt;CollectionType&gt; Ref&lt;HTMLCollection&gt; ensureCachedCollection();
  
<span class="line-removed">- #if ENABLE(FULLSCREEN_API)</span>
<span class="line-removed">-     void dispatchFullScreenChangeOrErrorEvent(Deque&lt;RefPtr&lt;Node&gt;&gt;&amp;, const AtomicString&amp; eventName, bool shouldNotifyMediaElement);</span>
<span class="line-removed">-     void clearFullscreenElementStack();</span>
<span class="line-removed">-     void popFullscreenElementStack();</span>
<span class="line-removed">-     void pushFullscreenElementStack(Element&amp;);</span>
<span class="line-removed">-     void addDocumentToFullScreenChangeEventQueue(Document&amp;);</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
      void dispatchDisabledAdaptationsDidChangeForMainFrame();
  
      void setVisualUpdatesAllowed(ReadyState);
      void setVisualUpdatesAllowed(bool);
      void visualUpdatesSuppressionTimerFired();
<span class="line-new-header">--- 1594,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1614,18 ***</span>
  
      void didAssociateFormControlsTimerFired();
  
      void wheelEventHandlersChanged();
  
<span class="line-removed">- #if ENABLE(DASHBOARD_SUPPORT)</span>
<span class="line-removed">-     void setAnnotatedRegionsDirty(bool f = true) { m_annotatedRegionsDirty = f; }</span>
<span class="line-removed">-     bool annotatedRegionsDirty() const { return m_annotatedRegionsDirty; }</span>
<span class="line-removed">-     bool hasAnnotatedRegions () const { return m_hasAnnotatedRegions; }</span>
<span class="line-removed">-     void setAnnotatedRegions(const Vector&lt;AnnotatedRegionValue&gt;&amp;);</span>
<span class="line-removed">-     void updateAnnotatedRegions();</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
      HttpEquivPolicy httpEquivPolicy() const;
      AXObjectCache* existingAXObjectCacheSlow() const;
  
      // DOM Cookies caching.
      const String&amp; cachedDOMCookies() const { return m_cachedDOMCookies; }
<span class="line-new-header">--- 1606,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1651,14 ***</span>
  
      bool shouldEnforceHTTP09Sandbox() const;
  
      void platformSuspendOrStopActiveDOMObjects();
  
<span class="line-removed">-     bool domainIsRegisterable(const String&amp;) const;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     void enableTemporaryTimeUserGesture();</span>
<span class="line-removed">- </span>
      bool isBodyPotentiallyScrollable(HTMLBodyElement&amp;);
  
      const Ref&lt;Settings&gt; m_settings;
  
      UniqueRef&lt;Quirks&gt; m_quirks;
<span class="line-new-header">--- 1635,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1706,11 ***</span>
      UserActionElementSet m_userActionElements;
  
      uint64_t m_domTreeVersion;
      static uint64_t s_globalTreeVersion;
  
<span class="line-modified">!     String m_uniqueIdentifier;</span>
  
      HashSet&lt;NodeIterator*&gt; m_nodeIterators;
      HashSet&lt;Range*&gt; m_ranges;
  
      std::unique_ptr&lt;Style::Scope&gt; m_styleScope;
<span class="line-new-header">--- 1686,11 ---</span>
      UserActionElementSet m_userActionElements;
  
      uint64_t m_domTreeVersion;
      static uint64_t s_globalTreeVersion;
  
<span class="line-modified">!     mutable String m_uniqueIdentifier;</span>
  
      HashSet&lt;NodeIterator*&gt; m_nodeIterators;
      HashSet&lt;Range*&gt; m_ranges;
  
      std::unique_ptr&lt;Style::Scope&gt; m_styleScope;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1771,20 ***</span>
  
      std::unique_ptr&lt;SVGDocumentExtensions&gt; m_svgExtensions;
      HashSet&lt;SVGUseElement*&gt; m_svgUseElements;
  
  #if ENABLE(DARK_MODE_CSS)
<span class="line-modified">!     OptionSet&lt;ColorSchemes&gt; m_supportedColorSchemes;</span>
      bool m_allowsColorSchemeTransformations { true };
  #endif
  
<span class="line-removed">- #if ENABLE(DASHBOARD_SUPPORT)</span>
<span class="line-removed">-     Vector&lt;AnnotatedRegionValue&gt; m_annotatedRegions;</span>
<span class="line-removed">-     bool m_hasAnnotatedRegions { false };</span>
<span class="line-removed">-     bool m_annotatedRegionsDirty { false };</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
      HashMap&lt;String, RefPtr&lt;HTMLCanvasElement&gt;&gt; m_cssCanvasElements;
  
      HashSet&lt;Element*&gt; m_documentSuspensionCallbackElements;
      HashSet&lt;Element*&gt; m_mediaVolumeCallbackElements;
      HashSet&lt;Element*&gt; m_privateBrowsingStateChangedElements;
<span class="line-new-header">--- 1751,14 ---</span>
  
      std::unique_ptr&lt;SVGDocumentExtensions&gt; m_svgExtensions;
      HashSet&lt;SVGUseElement*&gt; m_svgUseElements;
  
  #if ENABLE(DARK_MODE_CSS)
<span class="line-modified">!     OptionSet&lt;ColorScheme&gt; m_colorScheme;</span>
      bool m_allowsColorSchemeTransformations { true };
  #endif
  
      HashMap&lt;String, RefPtr&lt;HTMLCanvasElement&gt;&gt; m_cssCanvasElements;
  
      HashSet&lt;Element*&gt; m_documentSuspensionCallbackElements;
      HashSet&lt;Element*&gt; m_mediaVolumeCallbackElements;
      HashSet&lt;Element*&gt; m_privateBrowsingStateChangedElements;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1817,71 ***</span>
      mutable DocumentEventQueue m_eventQueue;
  
      HashSet&lt;MediaCanStartListener*&gt; m_mediaCanStartListeners;
  
  #if ENABLE(FULLSCREEN_API)
<span class="line-modified">!     RefPtr&lt;Element&gt; m_fullScreenElement;</span>
<span class="line-removed">-     Vector&lt;RefPtr&lt;Element&gt;&gt; m_fullScreenElementStack;</span>
<span class="line-removed">-     WeakPtr&lt;RenderFullScreen&gt; m_fullScreenRenderer { nullptr };</span>
<span class="line-removed">-     GenericTaskQueue&lt;Timer&gt; m_fullScreenTaskQueue;</span>
<span class="line-removed">-     Deque&lt;RefPtr&lt;Node&gt;&gt; m_fullScreenChangeEventTargetQueue;</span>
<span class="line-removed">-     Deque&lt;RefPtr&lt;Node&gt;&gt; m_fullScreenErrorEventTargetQueue;</span>
<span class="line-removed">-     LayoutRect m_savedPlaceholderFrameRect;</span>
<span class="line-removed">-     std::unique_ptr&lt;RenderStyle&gt; m_savedPlaceholderRenderStyle;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     bool m_areKeysEnabledInFullScreen { false };</span>
<span class="line-removed">-     bool m_isAnimatingFullScreen { false };</span>
<span class="line-removed">-     bool m_areFullscreenControlsHidden { false };</span>
  #endif
  
      HashSet&lt;HTMLPictureElement*&gt; m_viewportDependentPictures;
      HashSet&lt;HTMLPictureElement*&gt; m_appearanceDependentPictures;
  
  #if ENABLE(INTERSECTION_OBSERVER)
      Vector&lt;WeakPtr&lt;IntersectionObserver&gt;&gt; m_intersectionObservers;
      Vector&lt;WeakPtr&lt;IntersectionObserver&gt;&gt; m_intersectionObserversWithPendingNotifications;
      Timer m_intersectionObserversNotifyTimer;
  #endif
  
      Timer m_loadEventDelayTimer;
  
      ViewportArguments m_viewportArguments;
<span class="line-removed">-     Optional&lt;ViewportArguments&gt; m_overrideViewportArguments;</span>
      OptionSet&lt;DisabledAdaptations&gt; m_disabledAdaptations;
  
      DocumentTiming m_documentTiming;
  
      RefPtr&lt;MediaQueryMatcher&gt; m_mediaQueryMatcher;
  
  #if ENABLE(TOUCH_EVENTS)
      std::unique_ptr&lt;EventTargetSet&gt; m_touchEventTargets;
  #endif
<span class="line-modified">! #if ENABLE(POINTER_EVENTS)</span>
<span class="line-modified">!     std::unique_ptr&lt;HashSet&lt;RefPtr&lt;Element&gt;&gt;&gt; m_touchActionElements;</span>
  #endif
      std::unique_ptr&lt;EventTargetSet&gt; m_wheelEventTargets;
  
      MonotonicTime m_lastHandledUserGestureTimestamp;
  
      void clearScriptedAnimationController();
      RefPtr&lt;ScriptedAnimationController&gt; m_scriptedAnimationController;
  
      void notifyMediaCaptureOfVisibilityChanged();
  
      void didLogMessage(const WTFLogChannel&amp;, WTFLogLevel, Vector&lt;JSONLogValue&gt;&amp;&amp;) final;
  
<span class="line-modified">! #if ENABLE(RESOURCE_LOAD_STATISTICS)</span>
<span class="line-modified">!     bool hasFrameSpecificStorageAccess() const;</span>
<span class="line-removed">-     void setHasFrameSpecificStorageAccess(bool);</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
<span class="line-removed">- #if ENABLE(DEVICE_ORIENTATION) &amp;&amp; PLATFORM(IOS_FAMILY)</span>
      std::unique_ptr&lt;DeviceMotionClient&gt; m_deviceMotionClient;
      std::unique_ptr&lt;DeviceMotionController&gt; m_deviceMotionController;
      std::unique_ptr&lt;DeviceOrientationClient&gt; m_deviceOrientationClient;
      std::unique_ptr&lt;DeviceOrientationController&gt; m_deviceOrientationController;
  #endif
  
      GenericTaskQueue&lt;Timer&gt; m_logMessageTaskQueue;
  
      Timer m_pendingTasksTimer;
      Vector&lt;Task&gt; m_pendingTasks;
<span class="line-new-header">--- 1791,63 ---</span>
      mutable DocumentEventQueue m_eventQueue;
  
      HashSet&lt;MediaCanStartListener*&gt; m_mediaCanStartListeners;
  
  #if ENABLE(FULLSCREEN_API)
<span class="line-modified">!     UniqueRef&lt;FullscreenManager&gt; m_fullscreenManager;</span>
  #endif
  
      HashSet&lt;HTMLPictureElement*&gt; m_viewportDependentPictures;
      HashSet&lt;HTMLPictureElement*&gt; m_appearanceDependentPictures;
  
  #if ENABLE(INTERSECTION_OBSERVER)
      Vector&lt;WeakPtr&lt;IntersectionObserver&gt;&gt; m_intersectionObservers;
      Vector&lt;WeakPtr&lt;IntersectionObserver&gt;&gt; m_intersectionObserversWithPendingNotifications;
      Timer m_intersectionObserversNotifyTimer;
<span class="line-added">+     Timer m_intersectionObserversInitialUpdateTimer;</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
<span class="line-added">+ #if ENABLE(RESIZE_OBSERVER)</span>
<span class="line-added">+     Vector&lt;WeakPtr&lt;ResizeObserver&gt;&gt; m_resizeObservers;</span>
  #endif
  
      Timer m_loadEventDelayTimer;
  
      ViewportArguments m_viewportArguments;
      OptionSet&lt;DisabledAdaptations&gt; m_disabledAdaptations;
  
      DocumentTiming m_documentTiming;
  
      RefPtr&lt;MediaQueryMatcher&gt; m_mediaQueryMatcher;
  
  #if ENABLE(TOUCH_EVENTS)
      std::unique_ptr&lt;EventTargetSet&gt; m_touchEventTargets;
  #endif
<span class="line-modified">! #if PLATFORM(IOS_FAMILY) &amp;&amp; ENABLE(POINTER_EVENTS)</span>
<span class="line-modified">!     bool m_mayHaveElementsWithNonAutoTouchAction { false };</span>
  #endif
      std::unique_ptr&lt;EventTargetSet&gt; m_wheelEventTargets;
  
      MonotonicTime m_lastHandledUserGestureTimestamp;
<span class="line-added">+     MonotonicTime m_userActivatedMediaFinishedPlayingTimestamp;</span>
  
      void clearScriptedAnimationController();
      RefPtr&lt;ScriptedAnimationController&gt; m_scriptedAnimationController;
  
      void notifyMediaCaptureOfVisibilityChanged();
  
      void didLogMessage(const WTFLogChannel&amp;, WTFLogLevel, Vector&lt;JSONLogValue&gt;&amp;&amp;) final;
  
<span class="line-modified">! #if ENABLE(DEVICE_ORIENTATION)</span>
<span class="line-modified">! #if PLATFORM(IOS_FAMILY)</span>
      std::unique_ptr&lt;DeviceMotionClient&gt; m_deviceMotionClient;
      std::unique_ptr&lt;DeviceMotionController&gt; m_deviceMotionController;
      std::unique_ptr&lt;DeviceOrientationClient&gt; m_deviceOrientationClient;
      std::unique_ptr&lt;DeviceOrientationController&gt; m_deviceOrientationController;
  #endif
<span class="line-added">+     std::unique_ptr&lt;DeviceOrientationAndMotionAccessController&gt; m_deviceOrientationAndMotionAccessController;</span>
<span class="line-added">+ #endif</span>
  
      GenericTaskQueue&lt;Timer&gt; m_logMessageTaskQueue;
  
      Timer m_pendingTasksTimer;
      Vector&lt;Task&gt; m_pendingTasks;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1895,19 ***</span>
      void clearSharedObjectPool();
      Timer m_sharedObjectPoolClearTimer;
  
      std::unique_ptr&lt;DocumentSharedObjectPool&gt; m_sharedObjectPool;
  
<span class="line-modified">!     typedef HashMap&lt;AtomicString, std::unique_ptr&lt;Locale&gt;&gt; LocaleIdentifierToLocaleMap;</span>
      LocaleIdentifierToLocaleMap m_localeCache;
  
      RefPtr&lt;Document&gt; m_templateDocument;
<span class="line-modified">!     Document* m_templateDocumentHost { nullptr }; // Manually managed weakref (backpointer from m_templateDocument).</span>
  
      Ref&lt;CSSFontSelector&gt; m_fontSelector;
  
<span class="line-modified">!     HashSet&lt;MediaProducer*&gt; m_audioProducers;</span>
  
      HashSet&lt;ShadowRoot*&gt; m_inDocumentShadowRoots;
  
  #if ENABLE(WIRELESS_PLAYBACK_TARGET)
      typedef HashMap&lt;uint64_t, WebCore::MediaPlaybackTargetClient*&gt; TargetIdToClientMap;
<span class="line-new-header">--- 1861,19 ---</span>
      void clearSharedObjectPool();
      Timer m_sharedObjectPoolClearTimer;
  
      std::unique_ptr&lt;DocumentSharedObjectPool&gt; m_sharedObjectPool;
  
<span class="line-modified">!     typedef HashMap&lt;AtomString, std::unique_ptr&lt;Locale&gt;&gt; LocaleIdentifierToLocaleMap;</span>
      LocaleIdentifierToLocaleMap m_localeCache;
  
      RefPtr&lt;Document&gt; m_templateDocument;
<span class="line-modified">!     WeakPtr&lt;Document&gt; m_templateDocumentHost; // Manually managed weakref (backpointer from m_templateDocument).</span>
  
      Ref&lt;CSSFontSelector&gt; m_fontSelector;
  
<span class="line-modified">!     WeakHashSet&lt;MediaProducer&gt; m_audioProducers;</span>
  
      HashSet&lt;ShadowRoot*&gt; m_inDocumentShadowRoots;
  
  #if ENABLE(WIRELESS_PLAYBACK_TARGET)
      typedef HashMap&lt;uint64_t, WebCore::MediaPlaybackTargetClient*&gt; TargetIdToClientMap;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2032,14 ***</span>
  
  #if ENABLE(TELEPHONE_NUMBER_DETECTION)
      bool m_isTelephoneNumberParsingAllowed { true };
  #endif
  
<span class="line-removed">- #if ENABLE(INTERSECTION_OBSERVER)</span>
<span class="line-removed">-     bool m_needsForcedIntersectionObservationUpdate { false };</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
  #if ENABLE(MEDIA_STREAM)
      HashSet&lt;HTMLMediaElement*&gt; m_mediaStreamStateChangeElements;
      String m_idHashSalt;
      bool m_hasHadCaptureMediaStreamTrack { false };
  #endif
<span class="line-new-header">--- 1998,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2053,40 ***</span>
      mutable RefPtr&lt;Logger&gt; m_logger;
      RefPtr&lt;StringCallback&gt; m_consoleMessageListener;
  
      static bool hasEverCreatedAnAXObjectCache;
  
<span class="line-removed">-     bool m_grantStorageAccessOverride { false };</span>
<span class="line-removed">- </span>
<span class="line-removed">- #if USE(REQUEST_ANIMATION_FRAME_DISPLAY_MONITOR)</span>
<span class="line-removed">-     RefPtr&lt;DocumentAnimationScheduler&gt; m_animationScheduler;</span>
<span class="line-removed">- #endif</span>
      RefPtr&lt;DocumentTimeline&gt; m_timeline;
      DocumentIdentifier m_identifier;
  
  #if ENABLE(SERVICE_WORKER)
      RefPtr&lt;SWClientConnection&gt; m_serviceWorkerConnection;
  #endif
  
      HashSet&lt;ApplicationStateChangeListener*&gt; m_applicationStateChangeListeners;
  
  #if ENABLE(RESOURCE_LOAD_STATISTICS)
<span class="line-modified">!     String m_primaryDomainRequestedPageSpecificStorageAccessWithUserInteraction { };</span>
  #endif
  
<span class="line-removed">-     std::unique_ptr&lt;UserGestureIndicator&gt; m_temporaryUserGesture;</span>
<span class="line-removed">- </span>
      CSSRegisteredCustomPropertySet m_CSSRegisteredPropertySet;
  
  #if ENABLE(CSS_PAINTING_API)
      RefPtr&lt;Worklet&gt; m_paintWorklet;
      HashMap&lt;String, Ref&lt;PaintWorkletGlobalScope&gt;&gt; m_paintWorkletGlobalScopes;
  #endif
  
      bool m_isRunningUserScripts { false };
  
      Ref&lt;UndoManager&gt; m_undoManager;
  };
  
  Element* eventTargetElementForDocument(Document*);
  
  inline TextEncoding Document::textEncoding() const
<span class="line-new-header">--- 2015,45 ---</span>
      mutable RefPtr&lt;Logger&gt; m_logger;
      RefPtr&lt;StringCallback&gt; m_consoleMessageListener;
  
      static bool hasEverCreatedAnAXObjectCache;
  
      RefPtr&lt;DocumentTimeline&gt; m_timeline;
      DocumentIdentifier m_identifier;
  
  #if ENABLE(SERVICE_WORKER)
      RefPtr&lt;SWClientConnection&gt; m_serviceWorkerConnection;
  #endif
  
      HashSet&lt;ApplicationStateChangeListener*&gt; m_applicationStateChangeListeners;
  
  #if ENABLE(RESOURCE_LOAD_STATISTICS)
<span class="line-modified">!     RegistrableDomain m_registrableDomainRequestedPageSpecificStorageAccessWithUserInteraction { };</span>
<span class="line-added">+     String m_referrerOverride;</span>
  #endif
  
      CSSRegisteredCustomPropertySet m_CSSRegisteredPropertySet;
  
  #if ENABLE(CSS_PAINTING_API)
      RefPtr&lt;Worklet&gt; m_paintWorklet;
      HashMap&lt;String, Ref&lt;PaintWorkletGlobalScope&gt;&gt; m_paintWorkletGlobalScopes;
  #endif
  
<span class="line-added">+     bool m_hasEvaluatedUserAgentScripts { false };</span>
      bool m_isRunningUserScripts { false };
<span class="line-added">+     bool m_mayBeDetachedFromFrame { true };</span>
<span class="line-added">+ #if ENABLE(APPLE_PAY)</span>
<span class="line-added">+     bool m_hasStartedApplePaySession { false };</span>
<span class="line-added">+ #endif</span>
  
      Ref&lt;UndoManager&gt; m_undoManager;
<span class="line-added">+ #if PLATFORM(IOS_FAMILY)</span>
<span class="line-added">+     std::unique_ptr&lt;ContentChangeObserver&gt; m_contentChangeObserver;</span>
<span class="line-added">+     std::unique_ptr&lt;DOMTimerHoldingTank&gt; m_domTimerHoldingTank;</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
<span class="line-added">+     HashMap&lt;Element*, ElementIdentifier&gt; m_identifiedElementsMap;</span>
  };
  
  Element* eventTargetElementForDocument(Document*);
  
  inline TextEncoding Document::textEncoding() const
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2106,18 ***</span>
      if (!hasEverCreatedAnAXObjectCache)
          return nullptr;
      return existingAXObjectCacheSlow();
  }
  
<span class="line-modified">! inline Ref&lt;Document&gt; Document::create(const URL&amp; url)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     return adoptRef(*new Document(nullptr, url));</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- inline Ref&lt;Document&gt; Document::createNonRenderedPlaceholder(Frame&amp; frame, const URL&amp; url)</span>
  {
<span class="line-modified">!     return adoptRef(*new Document(&amp;frame, url, DefaultDocumentClass, NonRenderedPlaceholder));</span>
  }
  
  inline void Document::invalidateAccessKeyCache()
  {
      if (UNLIKELY(m_accessKeyCache))
<span class="line-new-header">--- 2073,13 ---</span>
      if (!hasEverCreatedAnAXObjectCache)
          return nullptr;
      return existingAXObjectCacheSlow();
  }
  
<span class="line-modified">! inline Ref&lt;Document&gt; Document::create(PAL::SessionID sessionID, const URL&amp; url)</span>
  {
<span class="line-modified">!     return adoptRef(*new Document(sessionID, nullptr, url));</span>
  }
  
  inline void Document::invalidateAccessKeyCache()
  {
      if (UNLIKELY(m_accessKeyCache))
</pre>
<center><a href="Document.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Document.idl.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>