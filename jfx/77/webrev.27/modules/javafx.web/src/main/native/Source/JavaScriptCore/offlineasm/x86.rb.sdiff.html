<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/offlineasm/x86.rb</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="registers.rb.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../parser/ASTBuilder.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/offlineasm/x86.rb</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  32 # actually considered as such by the ABI and we need to push/pop our arguments
  33 # on the stack. a0 and a1 are ecx and edx to follow fastcall.
  34 #
  35 # eax =&gt; t0, a2, r0
  36 # edx =&gt; t1, a1, r1
  37 # ecx =&gt; t2, a0
  38 # ebx =&gt; t3, a3     (callee-save)
  39 # esi =&gt; t4         (callee-save)
  40 # edi =&gt; t5         (callee-save)
  41 # ebp =&gt; cfr
  42 # esp =&gt; sp
  43 #
  44 # On x86-64 non-windows
  45 #
  46 # rax =&gt; t0,     r0
  47 # rdi =&gt;     a0
  48 # rsi =&gt; t1, a1
  49 # rdx =&gt; t2, a2, r1
  50 # rcx =&gt; t3, a3
  51 #  r8 =&gt; t4
<span class="line-modified">  52 # r10 =&gt; t5</span>

  53 # rbx =&gt;             csr0 (callee-save, PB, unused in baseline)
  54 # r12 =&gt;             csr1 (callee-save)
  55 # r13 =&gt;             csr2 (callee-save)
  56 # r14 =&gt;             csr3 (callee-save, tagTypeNumber)
  57 # r15 =&gt;             csr4 (callee-save, tagMask)
  58 # rsp =&gt; sp
  59 # rbp =&gt; cfr
  60 # r11 =&gt;                  (scratch)
  61 #
  62 # On x86-64 windows
  63 # Arguments need to be push/pop&#39;d on the stack in addition to being stored in
  64 # the registers. Also, &gt;8 return types are returned in a weird way.
  65 #
  66 # rax =&gt; t0,     r0
<span class="line-modified">  67 # rcx =&gt;     a0</span>
  68 # rdx =&gt; t1, a1, r1
  69 #  r8 =&gt; t2, a2
  70 #  r9 =&gt; t3, a3
  71 # r10 =&gt; t4
  72 # rbx =&gt;             csr0 (callee-save, PB, unused in baseline)
  73 # rsi =&gt;             csr1 (callee-save)
  74 # rdi =&gt;             csr2 (callee-save)
  75 # r12 =&gt;             csr3 (callee-save)
  76 # r13 =&gt;             csr4 (callee-save)
  77 # r14 =&gt;             csr5 (callee-save, tagTypeNumber)
  78 # r15 =&gt;             csr6 (callee-save, tagMask)
  79 # rsp =&gt; sp
  80 # rbp =&gt; cfr
  81 # r11 =&gt;                  (scratch)
  82 
  83 def isX64
  84     case $activeBackend
  85     when &quot;X86&quot;
  86         false
  87     when &quot;X86_WIN&quot;
</pre>
<hr />
<pre>
  93     else
  94         raise &quot;bad value for $activeBackend: #{$activeBackend}&quot;
  95     end
  96 end
  97 
  98 def isWin
  99     case $activeBackend
 100     when &quot;X86&quot;
 101         false
 102     when &quot;X86_WIN&quot;
 103         true
 104     when &quot;X86_64&quot;
 105         false
 106     when &quot;X86_64_WIN&quot;
 107         true
 108     else
 109         raise &quot;bad value for $activeBackend: #{$activeBackend}&quot;
 110     end
 111 end
 112 
<span class="line-removed"> 113 def useX87</span>
<span class="line-removed"> 114     case $activeBackend</span>
<span class="line-removed"> 115     when &quot;X86&quot;</span>
<span class="line-removed"> 116         true</span>
<span class="line-removed"> 117     when &quot;X86_WIN&quot;</span>
<span class="line-removed"> 118         true</span>
<span class="line-removed"> 119     when &quot;X86_64&quot;</span>
<span class="line-removed"> 120         false</span>
<span class="line-removed"> 121     when &quot;X86_64_WIN&quot;</span>
<span class="line-removed"> 122         false</span>
<span class="line-removed"> 123     else</span>
<span class="line-removed"> 124         raise &quot;bad value for $activeBackend: #{$activeBackend}&quot;</span>
<span class="line-removed"> 125     end</span>
<span class="line-removed"> 126 end</span>
<span class="line-removed"> 127 </span>
 128 def isMSVC
 129     $options.has_key?(:assembler) &amp;&amp; $options[:assembler] == &quot;MASM&quot;
 130 end
 131 
 132 def isIntelSyntax
 133     $options.has_key?(:assembler) &amp;&amp; $options[:assembler] == &quot;MASM&quot;
 134 end
 135 
 136 def register(name)
 137     isIntelSyntax ? name : &quot;%&quot; + name
 138 end
 139 
 140 def offsetRegister(off, register)
 141     isIntelSyntax ? &quot;[#{off} + #{register}]&quot; : &quot;#{off}(#{register})&quot;
 142 end
 143 
 144 def callPrefix
 145     isIntelSyntax ? &quot;&quot; : &quot;*&quot;
 146 end
 147 
</pre>
<hr />
<pre>
 324             when &quot;cfr&quot;
 325                 &quot;ebp&quot;
 326             when &quot;sp&quot;
 327                 &quot;esp&quot;
 328             end
 329         end
 330     end
 331 
 332     def x86Operand(kind)
 333         x86GPRName(x86GPR, kind)
 334     end
 335 
 336     def x86CallOperand(kind)
 337         &quot;#{callPrefix}#{x86Operand(:ptr)}&quot;
 338     end
 339 end
 340 
 341 class FPRegisterID
 342     def x86Operand(kind)
 343         raise unless kind == :double
<span class="line-removed"> 344         raise if useX87</span>
 345         case name
 346         when &quot;ft0&quot;, &quot;fa0&quot;, &quot;fr&quot;
 347             register(&quot;xmm0&quot;)
 348         when &quot;ft1&quot;, &quot;fa1&quot;
 349             register(&quot;xmm1&quot;)
 350         when &quot;ft2&quot;, &quot;fa2&quot;
 351             register(&quot;xmm2&quot;)
 352         when &quot;ft3&quot;, &quot;fa3&quot;
 353             register(&quot;xmm3&quot;)
 354         when &quot;ft4&quot;
 355             register(&quot;xmm4&quot;)
 356         when &quot;ft5&quot;
 357             register(&quot;xmm5&quot;)
 358         else
 359             raise &quot;Bad register #{name} for X86 at #{codeOriginString}&quot;
 360         end
 361     end
<span class="line-removed"> 362     def x87DefaultStackPosition</span>
<span class="line-removed"> 363         case name</span>
<span class="line-removed"> 364         when &quot;ft0&quot;, &quot;fr&quot;</span>
<span class="line-removed"> 365             0</span>
<span class="line-removed"> 366         when &quot;ft1&quot;</span>
<span class="line-removed"> 367             1</span>
<span class="line-removed"> 368         when &quot;ft2&quot;, &quot;ft3&quot;, &quot;ft4&quot;, &quot;ft5&quot;</span>
<span class="line-removed"> 369             raise &quot;Unimplemented register #{name} for X86 at #{codeOriginString}&quot;</span>
<span class="line-removed"> 370         else</span>
<span class="line-removed"> 371             raise &quot;Bad register #{name} for X86 at #{codeOriginString}&quot;</span>
<span class="line-removed"> 372         end</span>
<span class="line-removed"> 373     end</span>
<span class="line-removed"> 374     def x87Operand(offset)</span>
<span class="line-removed"> 375         raise unless useX87</span>
<span class="line-removed"> 376         raise unless offset == 0 or offset == 1</span>
<span class="line-removed"> 377         &quot;#{register(&quot;st&quot;)}(#{x87DefaultStackPosition + offset})&quot;</span>
<span class="line-removed"> 378     end</span>
 379     def x86CallOperand(kind)
 380         &quot;#{callPrefix}#{x86Operand(kind)}&quot;
 381     end
 382 end
 383 
 384 class Immediate
 385     def validX86Immediate?
 386         if isX64
 387             value &gt;= -0x80000000 and value &lt;= 0x7fffffff
 388         else
 389             true
 390         end
 391     end
 392     def x86Operand(kind)
 393         &quot;#{const(value)}&quot;
 394     end
 395     def x86CallOperand(kind)
 396         &quot;#{value}&quot;
 397     end
 398 end
</pre>
<hr />
<pre>
 544         orderOperands(operands[0].x86LoadOperand(srcKind, operands[1]), operands[1].x86Operand(dstKind))
 545     end
 546 
 547     def x86Suffix(kind)
 548         if isIntelSyntax
 549             return &quot;&quot;
 550         end
 551 
 552         case kind
 553         when :byte
 554             &quot;b&quot;
 555         when :half
 556             &quot;w&quot;
 557         when :int
 558             &quot;l&quot;
 559         when :ptr
 560             isX64 ? &quot;q&quot; : &quot;l&quot;
 561         when :quad
 562             isX64 ? &quot;q&quot; : raise
 563         when :double
<span class="line-modified"> 564             not useX87 ? &quot;sd&quot; : raise</span>
 565         else
 566             raise
 567         end
 568     end
 569     
 570     def x86Bytes(kind)
 571         case kind
 572         when :byte
 573             1
 574         when :half
 575             2
 576         when :int
 577             4
 578         when :ptr
 579             isX64 ? 8 : 4
 580         when :quad
 581             isX64 ? 8 : raise
 582         when :double
 583             8
 584         else
</pre>
<hr />
<pre>
 616         else
 617             $asm.puts &quot;#{opcode} #{orderOperands(operands[0].x86Operand(kind), operands[1].x86Operand(kind))}&quot;
 618         end
 619     end
 620     
 621     def handleX86Op(opcode, kind)
 622         handleX86OpWithNumOperands(opcode, kind, operands.size)
 623     end
 624     
 625     def handleX86Shift(opcode, kind)
 626         if operands[0].is_a? Immediate or operands[0].x86GPR == &quot;ecx&quot;
 627             $asm.puts &quot;#{opcode} #{orderOperands(operands[0].x86Operand(:byte), operands[1].x86Operand(kind))}&quot;
 628         else
 629             $asm.puts &quot;xchg#{x86Suffix(:ptr)} #{operands[0].x86Operand(:ptr)}, #{x86GPRName(&quot;ecx&quot;, :ptr)}&quot;
 630             $asm.puts &quot;#{opcode} #{orderOperands(register(&quot;cl&quot;), operands[1].x86Operand(kind))}&quot;
 631             $asm.puts &quot;xchg#{x86Suffix(:ptr)} #{operands[0].x86Operand(:ptr)}, #{x86GPRName(&quot;ecx&quot;, :ptr)}&quot;
 632         end
 633     end
 634     
 635     def handleX86DoubleBranch(branchOpcode, mode)
<span class="line-modified"> 636         if useX87</span>
<span class="line-modified"> 637             handleX87Compare(mode)</span>



 638         else
<span class="line-modified"> 639             case mode</span>
<span class="line-removed"> 640             when :normal</span>
<span class="line-removed"> 641                 $asm.puts &quot;ucomisd #{orderOperands(operands[1].x86Operand(:double), operands[0].x86Operand(:double))}&quot;</span>
<span class="line-removed"> 642             when :reverse</span>
<span class="line-removed"> 643                 $asm.puts &quot;ucomisd #{orderOperands(operands[0].x86Operand(:double), operands[1].x86Operand(:double))}&quot;</span>
<span class="line-removed"> 644             else</span>
<span class="line-removed"> 645                 raise mode.inspect</span>
<span class="line-removed"> 646             end</span>
 647         end
 648         $asm.puts &quot;#{branchOpcode} #{operands[2].asmLabel}&quot;
 649     end
 650     
 651     def handleX86IntCompare(opcodeSuffix, kind)
 652         if operands[0].is_a? Immediate and operands[0].value == 0 and operands[1].is_a? RegisterID and (opcodeSuffix == &quot;e&quot; or opcodeSuffix == &quot;ne&quot;)
 653             $asm.puts &quot;test#{x86Suffix(kind)} #{orderOperands(operands[1].x86Operand(kind), operands[1].x86Operand(kind))}&quot;
 654         elsif operands[1].is_a? Immediate and operands[1].value == 0 and operands[0].is_a? RegisterID and (opcodeSuffix == &quot;e&quot; or opcodeSuffix == &quot;ne&quot;)
 655             $asm.puts &quot;test#{x86Suffix(kind)}  #{orderOperands(operands[0].x86Operand(kind), operands[0].x86Operand(kind))}&quot;
 656         else
 657             $asm.puts &quot;cmp#{x86Suffix(kind)} #{orderOperands(operands[1].x86Operand(kind), operands[0].x86Operand(kind))}&quot;
 658         end
 659     end
 660     
 661     def handleX86IntBranch(branchOpcode, kind)
 662         handleX86IntCompare(branchOpcode[1..-1], kind)
 663         $asm.puts &quot;#{branchOpcode} #{operands[2].asmLabel}&quot;
 664     end
 665     
 666     def handleX86Set(setOpcode, operand)
</pre>
<hr />
<pre>
 844         opB = offsetRegister(operands[1].value * x86Bytes(:ptr), sp.x86Operand(:ptr))
 845         $asm.puts &quot;mov#{x86Suffix(:ptr)} #{orderOperands(opA, opB)}&quot;
 846     end
 847 
 848     def handleMove
 849         if Immediate.new(nil, 0) == operands[0] and operands[1].is_a? RegisterID
 850             if isX64
 851                 $asm.puts &quot;xor#{x86Suffix(:quad)} #{operands[1].x86Operand(:quad)}, #{operands[1].x86Operand(:quad)}&quot;
 852             else
 853                 $asm.puts &quot;xor#{x86Suffix(:ptr)} #{operands[1].x86Operand(:ptr)}, #{operands[1].x86Operand(:ptr)}&quot;
 854             end
 855         elsif operands[0] != operands[1]
 856             if isX64
 857                 $asm.puts &quot;mov#{x86Suffix(:quad)} #{x86Operands(:quad, :quad)}&quot;
 858             else
 859                 $asm.puts &quot;mov#{x86Suffix(:ptr)} #{x86Operands(:ptr, :ptr)}&quot;
 860             end
 861         end
 862     end
 863 
<span class="line-removed"> 864     def handleX87Compare(mode)</span>
<span class="line-removed"> 865         floatingPointCompareImplicitOperand = getImplicitOperandString</span>
<span class="line-removed"> 866         case mode</span>
<span class="line-removed"> 867         when :normal</span>
<span class="line-removed"> 868             if (operands[0].x87DefaultStackPosition == 0)</span>
<span class="line-removed"> 869                 $asm.puts &quot;fucomi #{floatingPointCompareImplicitOperand}#{operands[1].x87Operand(0)}&quot;</span>
<span class="line-removed"> 870             else</span>
<span class="line-removed"> 871                 $asm.puts &quot;fld #{operands[0].x87Operand(0)}&quot;</span>
<span class="line-removed"> 872                 $asm.puts &quot;fucomip #{floatingPointCompareImplicitOperand}#{operands[1].x87Operand(1)}&quot;</span>
<span class="line-removed"> 873             end</span>
<span class="line-removed"> 874         when :reverse</span>
<span class="line-removed"> 875             if (operands[1].x87DefaultStackPosition == 0)</span>
<span class="line-removed"> 876                 $asm.puts &quot;fucomi #{floatingPointCompareImplicitOperand}#{operands[0].x87Operand(0)}&quot;</span>
<span class="line-removed"> 877             else</span>
<span class="line-removed"> 878                 $asm.puts &quot;fld #{operands[1].x87Operand(0)}&quot;</span>
<span class="line-removed"> 879                 $asm.puts &quot;fucomip #{floatingPointCompareImplicitOperand}#{operands[0].x87Operand(1)}&quot;</span>
<span class="line-removed"> 880             end</span>
<span class="line-removed"> 881         else</span>
<span class="line-removed"> 882             raise mode.inspect</span>
<span class="line-removed"> 883         end</span>
<span class="line-removed"> 884     end</span>
<span class="line-removed"> 885 </span>
<span class="line-removed"> 886     def handleX87BinOp(opcode, opcodereverse)</span>
<span class="line-removed"> 887         if (operands[1].x87DefaultStackPosition == 0)</span>
<span class="line-removed"> 888             $asm.puts &quot;#{opcode} #{orderOperands(operands[0].x87Operand(0), register(&quot;st&quot;))}&quot;</span>
<span class="line-removed"> 889         elsif (operands[0].x87DefaultStackPosition == 0)</span>
<span class="line-removed"> 890             if !isIntelSyntax</span>
<span class="line-removed"> 891                 $asm.puts &quot;#{opcodereverse} #{register(&quot;st&quot;)}, #{operands[1].x87Operand(0)}&quot;</span>
<span class="line-removed"> 892             else</span>
<span class="line-removed"> 893                 $asm.puts &quot;#{opcode} #{operands[1].x87Operand(0)}, #{register(&quot;st&quot;)}&quot;</span>
<span class="line-removed"> 894             end</span>
<span class="line-removed"> 895         else</span>
<span class="line-removed"> 896             $asm.puts &quot;fld #{operands[0].x87Operand(0)}&quot;</span>
<span class="line-removed"> 897             $asm.puts &quot;#{opcodereverse}p #{orderOperands(register(&quot;st&quot;), operands[1].x87Operand(1))}&quot;</span>
<span class="line-removed"> 898         end</span>
<span class="line-removed"> 899     end</span>
<span class="line-removed"> 900 </span>
 901     def lowerX86
 902         raise unless $activeBackend == &quot;X86&quot;
 903         lowerX86Common
 904     end
 905 
 906     def lowerX86_WIN
 907         raise unless $activeBackend == &quot;X86_WIN&quot; 
 908         lowerX86Common
 909     end
 910     
 911     def lowerX86_64
 912         raise unless $activeBackend == &quot;X86_64&quot;
 913         lowerX86Common
 914     end
 915 
 916     def lowerX86_64_WIN
 917         raise unless $activeBackend == &quot;X86_64_WIN&quot;
 918         lowerX86Common
 919     end
 920 
</pre>
<hr />
<pre>
 995                 else
 996                     $asm.puts &quot;movsxd #{x86LoadOperands(:int, :quad)}&quot;
 997                 end
 998             else
 999                 $asm.puts &quot;mov#{x86Suffix(:int)} #{x86LoadOperands(:int, :int)}&quot;
1000             end
1001         when &quot;loadp&quot;
1002             $asm.puts &quot;mov#{x86Suffix(:ptr)} #{x86LoadOperands(:ptr, :ptr)}&quot;
1003         when &quot;storep&quot;
1004             $asm.puts &quot;mov#{x86Suffix(:ptr)} #{x86Operands(:ptr, :ptr)}&quot;
1005         when &quot;loadq&quot;
1006             $asm.puts &quot;mov#{x86Suffix(:quad)} #{x86LoadOperands(:quad, :quad)}&quot;
1007         when &quot;storeq&quot;
1008             $asm.puts &quot;mov#{x86Suffix(:quad)} #{x86Operands(:quad, :quad)}&quot;
1009         when &quot;loadb&quot;
1010             if !isIntelSyntax
1011                 $asm.puts &quot;movzbl #{x86LoadOperands(:byte, :int)}&quot;
1012             else
1013                 $asm.puts &quot;movzx #{x86LoadOperands(:byte, :int)}&quot;
1014             end
<span class="line-modified">1015         when &quot;loadbs&quot;</span>
1016             if !isIntelSyntax
1017                 $asm.puts &quot;movsbl #{x86LoadOperands(:byte, :int)}&quot;
1018             else
1019                 $asm.puts &quot;movsx #{x86LoadOperands(:byte, :int)}&quot;
1020             end
<span class="line-modified">1021         when &quot;loadbsp&quot;</span>
1022             if !isIntelSyntax
<span class="line-modified">1023                 $asm.puts &quot;movsb#{x86Suffix(:ptr)} #{x86LoadOperands(:byte, :ptr)}&quot;</span>
1024             else
<span class="line-modified">1025                 $asm.puts &quot;movsx #{x86LoadOperands(:byte, :ptr)}&quot;</span>
1026             end
1027         when &quot;loadh&quot;
1028             if !isIntelSyntax
1029                 $asm.puts &quot;movzwl #{x86LoadOperands(:half, :int)}&quot;
1030             else
1031                 $asm.puts &quot;movzx #{x86LoadOperands(:half, :int)}&quot;
1032             end
<span class="line-modified">1033         when &quot;loadhs&quot;</span>
1034             if !isIntelSyntax
1035                 $asm.puts &quot;movswl #{x86LoadOperands(:half, :int)}&quot;
1036             else
1037                 $asm.puts &quot;movsx #{x86LoadOperands(:half, :int)}&quot;
1038             end






1039         when &quot;storeb&quot;
1040             $asm.puts &quot;mov#{x86Suffix(:byte)} #{x86Operands(:byte, :byte)}&quot;
1041         when &quot;loadd&quot;
<span class="line-modified">1042             if useX87</span>
<span class="line-removed">1043                 if !isIntelSyntax</span>
<span class="line-removed">1044                     $asm.puts &quot;fldl #{operands[0].x86Operand(:double)}&quot;</span>
<span class="line-removed">1045                 else</span>
<span class="line-removed">1046                     $asm.puts &quot;fld #{operands[0].x86Operand(:double)}&quot;</span>
<span class="line-removed">1047                 end</span>
<span class="line-removed">1048                 $asm.puts &quot;fstp #{operands[1].x87Operand(1)}&quot;</span>
<span class="line-removed">1049             else</span>
<span class="line-removed">1050                 $asm.puts &quot;movsd #{x86Operands(:double, :double)}&quot;</span>
<span class="line-removed">1051             end</span>
1052         when &quot;moved&quot;
<span class="line-modified">1053             if useX87</span>
<span class="line-removed">1054                 if (operands[0].x87DefaultStackPosition == 0)</span>
<span class="line-removed">1055                     $asm.puts &quot;fst #{operands[1].x87Operand(0)}&quot;</span>
<span class="line-removed">1056                 else</span>
<span class="line-removed">1057                     $asm.puts &quot;fld #{operands[0].x87Operand(0)}&quot;</span>
<span class="line-removed">1058                     $asm.puts &quot;fstp #{operands[1].x87Operand(1)}&quot;</span>
<span class="line-removed">1059                 end</span>
<span class="line-removed">1060             else</span>
<span class="line-removed">1061                 $asm.puts &quot;movsd #{x86Operands(:double, :double)}&quot;</span>
<span class="line-removed">1062             end</span>
1063         when &quot;stored&quot;
<span class="line-modified">1064             if useX87</span>
<span class="line-removed">1065                 if (operands[0].x87DefaultStackPosition == 0)</span>
<span class="line-removed">1066                     $asm.puts &quot;fst#{x86Suffix(:int)} #{operands[1].x86Operand(:double)}&quot;</span>
<span class="line-removed">1067                 else</span>
<span class="line-removed">1068                     $asm.puts &quot;fld #{operands[0].x87Operand(0)}&quot;</span>
<span class="line-removed">1069                     if !isIntelSyntax</span>
<span class="line-removed">1070                         $asm.puts &quot;fstpl #{operands[1].x86Operand(:double)}&quot;</span>
<span class="line-removed">1071                     else</span>
<span class="line-removed">1072                         $asm.puts &quot;fstp #{operands[1].x86Operand(:double)}&quot;</span>
<span class="line-removed">1073                     end</span>
<span class="line-removed">1074                 end</span>
<span class="line-removed">1075             else</span>
<span class="line-removed">1076                 $asm.puts &quot;movsd #{x86Operands(:double, :double)}&quot;</span>
<span class="line-removed">1077             end</span>
1078         when &quot;addd&quot;
<span class="line-modified">1079             if useX87</span>
<span class="line-removed">1080                 handleX87BinOp(&quot;fadd&quot;, &quot;fadd&quot;)</span>
<span class="line-removed">1081             else</span>
<span class="line-removed">1082                 $asm.puts &quot;addsd #{x86Operands(:double, :double)}&quot;</span>
<span class="line-removed">1083             end</span>
1084         when &quot;muld&quot;
<span class="line-modified">1085             if useX87</span>
<span class="line-removed">1086                 handleX87BinOp(&quot;fmul&quot;, &quot;fmul&quot;)</span>
<span class="line-removed">1087             else</span>
<span class="line-removed">1088                 $asm.puts &quot;mulsd #{x86Operands(:double, :double)}&quot;</span>
<span class="line-removed">1089             end</span>
1090         when &quot;subd&quot;
<span class="line-modified">1091             if useX87</span>
<span class="line-removed">1092                 handleX87BinOp(&quot;fsub&quot;, &quot;fsubr&quot;)</span>
<span class="line-removed">1093             else</span>
<span class="line-removed">1094                 $asm.puts &quot;subsd #{x86Operands(:double, :double)}&quot;</span>
<span class="line-removed">1095             end</span>
1096         when &quot;divd&quot;
<span class="line-modified">1097             if useX87</span>
<span class="line-removed">1098                 handleX87BinOp(&quot;fdiv&quot;, &quot;fdivr&quot;)</span>
<span class="line-removed">1099             else</span>
<span class="line-removed">1100                 $asm.puts &quot;divsd #{x86Operands(:double, :double)}&quot;</span>
<span class="line-removed">1101             end</span>
1102         when &quot;sqrtd&quot;
<span class="line-modified">1103             if useX87</span>
<span class="line-removed">1104                 $asm.puts &quot;fld #{operands[0].x87Operand(0)}&quot;</span>
<span class="line-removed">1105                 $asm.puts &quot;fsqrtl&quot;</span>
<span class="line-removed">1106                 $asm.puts &quot;fstp #{operands[1].x87Operand(1)}&quot;</span>
<span class="line-removed">1107             else</span>
<span class="line-removed">1108                 $asm.puts &quot;sqrtsd #{operands[0].x86Operand(:double)}, #{operands[1].x86Operand(:double)}&quot;</span>
<span class="line-removed">1109             end</span>
1110         when &quot;ci2d&quot;
<span class="line-modified">1111             if useX87</span>
<span class="line-removed">1112                 sp = RegisterID.new(nil, &quot;sp&quot;)</span>
<span class="line-removed">1113                 $asm.puts &quot;mov#{x86Suffix(:int)} #{orderOperands(operands[0].x86Operand(:int), offsetRegister(-4, sp.x86Operand(:ptr)))}&quot;</span>
<span class="line-removed">1114                 $asm.puts &quot;fild#{x86Suffix(:ptr)} #{getSizeString(:ptr)}#{offsetRegister(-4, sp.x86Operand(:ptr))}&quot;</span>
<span class="line-removed">1115                 $asm.puts &quot;fstp #{operands[1].x87Operand(1)}&quot;</span>
<span class="line-removed">1116             else</span>
<span class="line-removed">1117                 $asm.puts &quot;cvtsi2sd #{orderOperands(operands[0].x86Operand(:int), operands[1].x86Operand(:double))}&quot;</span>
<span class="line-removed">1118             end</span>
1119         when &quot;bdeq&quot;
<span class="line-modified">1120             if useX87</span>
<span class="line-removed">1121                 handleX87Compare(:normal)</span>
<span class="line-removed">1122             else</span>
<span class="line-removed">1123                 $asm.puts &quot;ucomisd #{orderOperands(operands[0].x86Operand(:double), operands[1].x86Operand(:double))}&quot;</span>
<span class="line-removed">1124             end</span>
1125             if operands[0] == operands[1]
1126                 # This is just a jump ordered, which is a jnp.
1127                 $asm.puts &quot;jnp #{operands[2].asmLabel}&quot;
1128             else
1129                 isUnordered = LocalLabel.unique(&quot;bdeq&quot;)
1130                 $asm.puts &quot;jp #{LabelReference.new(codeOrigin, isUnordered).asmLabel}&quot;
1131                 $asm.puts &quot;je #{LabelReference.new(codeOrigin, operands[2]).asmLabel}&quot;
1132                 isUnordered.lower(&quot;X86&quot;)
1133             end
1134         when &quot;bdneq&quot;
1135             handleX86DoubleBranch(&quot;jne&quot;, :normal)
1136         when &quot;bdgt&quot;
1137             handleX86DoubleBranch(&quot;ja&quot;, :normal)
1138         when &quot;bdgteq&quot;
1139             handleX86DoubleBranch(&quot;jae&quot;, :normal)
1140         when &quot;bdlt&quot;
1141             handleX86DoubleBranch(&quot;ja&quot;, :reverse)
1142         when &quot;bdlteq&quot;
1143             handleX86DoubleBranch(&quot;jae&quot;, :reverse)
1144         when &quot;bdequn&quot;
1145             handleX86DoubleBranch(&quot;je&quot;, :normal)
1146         when &quot;bdnequn&quot;
<span class="line-modified">1147             if useX87</span>
<span class="line-removed">1148                 handleX87Compare(:normal)</span>
<span class="line-removed">1149             else</span>
<span class="line-removed">1150                 $asm.puts &quot;ucomisd #{orderOperands(operands[0].x86Operand(:double), operands[1].x86Operand(:double))}&quot;</span>
<span class="line-removed">1151             end</span>
1152             if operands[0] == operands[1]
1153                 # This is just a jump unordered, which is a jp.
1154                 $asm.puts &quot;jp #{operands[2].asmLabel}&quot;
1155             else
1156                 isUnordered = LocalLabel.unique(&quot;bdnequn&quot;)
1157                 isEqual = LocalLabel.unique(&quot;bdnequn&quot;)
1158                 $asm.puts &quot;jp #{LabelReference.new(codeOrigin, isUnordered).asmLabel}&quot;
1159                 $asm.puts &quot;je #{LabelReference.new(codeOrigin, isEqual).asmLabel}&quot;
1160                 isUnordered.lower(&quot;X86&quot;)
1161                 $asm.puts &quot;jmp #{operands[2].asmLabel}&quot;
1162                 isEqual.lower(&quot;X86&quot;)
1163             end
1164         when &quot;bdgtun&quot;
1165             handleX86DoubleBranch(&quot;jb&quot;, :reverse)
1166         when &quot;bdgtequn&quot;
1167             handleX86DoubleBranch(&quot;jbe&quot;, :reverse)
1168         when &quot;bdltun&quot;
1169             handleX86DoubleBranch(&quot;jb&quot;, :normal)
1170         when &quot;bdltequn&quot;
1171             handleX86DoubleBranch(&quot;jbe&quot;, :normal)
1172         when &quot;btd2i&quot;
<span class="line-removed">1173             # FIXME: unused and unimplemented for x87</span>
<span class="line-removed">1174             raise if useX87</span>
1175             $asm.puts &quot;cvttsd2si #{operands[0].x86Operand(:double)}, #{operands[1].x86Operand(:int)}&quot;
1176             $asm.puts &quot;cmpl $0x80000000 #{operands[1].x86Operand(:int)}&quot;
1177             $asm.puts &quot;je #{operands[2].asmLabel}&quot;
1178         when &quot;td2i&quot;
<span class="line-removed">1179             # FIXME: unused and unimplemented for x87</span>
<span class="line-removed">1180             raise if useX87</span>
1181             $asm.puts &quot;cvttsd2si #{operands[0].x86Operand(:double)}, #{operands[1].x86Operand(:int)}&quot;
1182         when &quot;bcd2i&quot;
<span class="line-modified">1183             if useX87</span>
<span class="line-modified">1184                 floatingPointCompareImplicitOperand = getImplicitOperandString</span>
<span class="line-modified">1185                 sp = RegisterID.new(nil, &quot;sp&quot;)</span>
<span class="line-modified">1186                 if (operands[0].x87DefaultStackPosition == 0)</span>
<span class="line-modified">1187                     $asm.puts &quot;fistl -4(#{sp.x86Operand(:ptr)})&quot;</span>
<span class="line-modified">1188                 else</span>
<span class="line-modified">1189                     $asm.puts &quot;fld #{operands[0].x87Operand(0)}&quot;</span>
<span class="line-removed">1190                     $asm.puts &quot;fistp#{x86Suffix(:ptr)} #{getSizeString(:ptr)}#{offsetRegister(-4, sp.x86Operand(:ptr))}&quot;</span>
<span class="line-removed">1191                 end</span>
<span class="line-removed">1192                 $asm.puts &quot;mov#{x86Suffix(:int)} #{orderOperands(offsetRegister(-4, sp.x86Operand(:ptr)), operands[1].x86Operand(:int))}&quot;</span>
<span class="line-removed">1193                 $asm.puts &quot;test#{x86Suffix(:int)} #{operands[1].x86Operand(:int)}, #{operands[1].x86Operand(:int)}&quot;</span>
<span class="line-removed">1194                 $asm.puts &quot;je #{operands[2].asmLabel}&quot;</span>
<span class="line-removed">1195                 $asm.puts &quot;fild#{x86Suffix(:int)} #{getSizeString(:int)}#{offsetRegister(-4, sp.x86Operand(:ptr))}&quot;</span>
<span class="line-removed">1196                 $asm.puts &quot;fucomip #{floatingPointCompareImplicitOperand}#{operands[0].x87Operand(1)}&quot;</span>
<span class="line-removed">1197                 $asm.puts &quot;jp #{operands[2].asmLabel}&quot;</span>
<span class="line-removed">1198                 $asm.puts &quot;jne #{operands[2].asmLabel}&quot;</span>
<span class="line-removed">1199             else</span>
<span class="line-removed">1200                 $asm.puts &quot;cvttsd2si #{operands[0].x86Operand(:double)}, #{operands[1].x86Operand(:int)}&quot;</span>
<span class="line-removed">1201                 $asm.puts &quot;test#{x86Suffix(:int)} #{operands[1].x86Operand(:int)}, #{operands[1].x86Operand(:int)}&quot;</span>
<span class="line-removed">1202                 $asm.puts &quot;je #{operands[2].asmLabel}&quot;</span>
<span class="line-removed">1203                 $asm.puts &quot;cvtsi2sd #{operands[1].x86Operand(:int)}, %xmm7&quot;</span>
<span class="line-removed">1204                 $asm.puts &quot;ucomisd #{operands[0].x86Operand(:double)}, %xmm7&quot;</span>
<span class="line-removed">1205                 $asm.puts &quot;jp #{operands[2].asmLabel}&quot;</span>
<span class="line-removed">1206                 $asm.puts &quot;jne #{operands[2].asmLabel}&quot;</span>
<span class="line-removed">1207             end</span>
1208         when &quot;movdz&quot;
<span class="line-modified">1209             if useX87</span>
<span class="line-removed">1210                 $asm.puts &quot;fldzl&quot;</span>
<span class="line-removed">1211                 $asm.puts &quot;fstp #{operands[0].x87Operand(1)}&quot;</span>
<span class="line-removed">1212             else</span>
<span class="line-removed">1213                 $asm.puts &quot;xorpd #{operands[0].x86Operand(:double)}, #{operands[0].x86Operand(:double)}&quot;</span>
<span class="line-removed">1214             end</span>
1215         when &quot;pop&quot;
1216             operands.each {
1217                 | op |
1218                 $asm.puts &quot;pop #{op.x86Operand(:ptr)}&quot;
1219             }
1220         when &quot;push&quot;
1221             operands.each {
1222                 | op |
1223                 $asm.puts &quot;push #{op.x86Operand(:ptr)}&quot;
1224             }
1225         when &quot;move&quot;
1226             handleMove
1227         when &quot;sxi2q&quot;
1228             if !isIntelSyntax
1229                 $asm.puts &quot;movslq #{operands[0].x86Operand(:int)}, #{operands[1].x86Operand(:quad)}&quot;
1230             else
1231                 $asm.puts &quot;movsxd #{orderOperands(operands[0].x86Operand(:int), operands[1].x86Operand(:quad))}&quot;
1232             end
1233         when &quot;zxi2q&quot;
1234             $asm.puts &quot;mov#{x86Suffix(:int)} #{orderOperands(operands[0].x86Operand(:int), operands[1].x86Operand(:int))}&quot;
</pre>
<hr />
<pre>
1374             handleX86SubBranch(&quot;jnz&quot;, :int)
1375         when &quot;bmulio&quot;
1376             handleX86OpBranch(&quot;imul#{x86Suffix(:int)}&quot;, &quot;jo&quot;, :int)
1377         when &quot;bmulis&quot;
1378             handleX86OpBranch(&quot;imul#{x86Suffix(:int)}&quot;, &quot;js&quot;, :int)
1379         when &quot;bmuliz&quot;
1380             handleX86OpBranch(&quot;imul#{x86Suffix(:int)}&quot;, &quot;jz&quot;, :int)
1381         when &quot;bmulinz&quot;
1382             handleX86OpBranch(&quot;imul#{x86Suffix(:int)}&quot;, &quot;jnz&quot;, :int)
1383         when &quot;borio&quot;
1384             handleX86OpBranch(&quot;orl&quot;, &quot;jo&quot;, :int)
1385         when &quot;boris&quot;
1386             handleX86OpBranch(&quot;orl&quot;, &quot;js&quot;, :int)
1387         when &quot;boriz&quot;
1388             handleX86OpBranch(&quot;orl&quot;, &quot;jz&quot;, :int)
1389         when &quot;borinz&quot;
1390             handleX86OpBranch(&quot;orl&quot;, &quot;jnz&quot;, :int)
1391         when &quot;break&quot;
1392             $asm.puts &quot;int #{const(3)}&quot;
1393         when &quot;call&quot;
<span class="line-removed">1394             if useX87</span>
<span class="line-removed">1395                 2.times {</span>
<span class="line-removed">1396                     | offset |</span>
<span class="line-removed">1397                     $asm.puts &quot;ffree #{register(&quot;st&quot;)}(#{offset})&quot;</span>
<span class="line-removed">1398                 }</span>
<span class="line-removed">1399             end</span>
1400             op = operands[0].x86CallOperand(:ptr)
1401             if operands[0].is_a? LabelReference
1402                 operands[0].used
1403             end
1404             $asm.puts &quot;call #{op}&quot;
1405         when &quot;ret&quot;
1406             $asm.puts &quot;ret&quot;
1407         when &quot;cieq&quot;
1408             handleX86IntCompareSet(&quot;sete&quot;, :int)
1409         when &quot;cbeq&quot;
1410             handleX86IntCompareSet(&quot;sete&quot;, :byte)
1411         when &quot;cpeq&quot;
1412             handleX86IntCompareSet(&quot;sete&quot;, :ptr)
1413         when &quot;cqeq&quot;
1414             handleX86IntCompareSet(&quot;sete&quot;, :quad)
1415         when &quot;cineq&quot;
1416             handleX86IntCompareSet(&quot;setne&quot;, :int)
1417         when &quot;cbneq&quot;
1418             handleX86IntCompareSet(&quot;setne&quot;, :byte)
1419         when &quot;cpneq&quot;
</pre>
<hr />
<pre>
1500             handleX86SetTest(&quot;sets&quot;, :quad)
1501         when &quot;tqz&quot;
1502             handleX86SetTest(&quot;setz&quot;, :quad)
1503         when &quot;tqnz&quot;
1504             handleX86SetTest(&quot;setnz&quot;, :quad)
1505         when &quot;tbs&quot;
1506             handleX86SetTest(&quot;sets&quot;, :byte)
1507         when &quot;tbz&quot;
1508             handleX86SetTest(&quot;setz&quot;, :byte)
1509         when &quot;tbnz&quot;
1510             handleX86SetTest(&quot;setnz&quot;, :byte)
1511         when &quot;peek&quot;
1512             handleX86Peek()
1513         when &quot;poke&quot;
1514             handleX86Poke()
1515         when &quot;cdqi&quot;
1516             $asm.puts &quot;cdq&quot;
1517         when &quot;idivi&quot;
1518             $asm.puts &quot;idiv#{x86Suffix(:int)} #{operands[0].x86Operand(:int)}&quot;
1519         when &quot;fii2d&quot;
<span class="line-modified">1520             if useX87</span>
<span class="line-modified">1521                 sp = RegisterID.new(nil, &quot;sp&quot;)</span>
<span class="line-modified">1522                 $asm.puts &quot;mov#{x86Suffix(:int)} #{orderOperands(operands[0].x86Operand(:int), offsetRegister(-8, sp.x86Operand(:ptr)))}&quot;</span>
<span class="line-modified">1523                 $asm.puts &quot;mov#{x86Suffix(:int)} #{orderOperands(operands[1].x86Operand(:int), offsetRegister(-4, sp.x86Operand(:ptr)))}&quot;</span>
<span class="line-removed">1524                 $asm.puts &quot;fld#{x86Suffix(:ptr)} #{getSizeString(:double)}#{offsetRegister(-8, sp.x86Operand(:ptr))}&quot;</span>
<span class="line-removed">1525                 $asm.puts &quot;fstp #{operands[2].x87Operand(1)}&quot;</span>
<span class="line-removed">1526             else</span>
<span class="line-removed">1527                 $asm.puts &quot;movd #{operands[0].x86Operand(:int)}, #{operands[2].x86Operand(:double)}&quot;</span>
<span class="line-removed">1528                 $asm.puts &quot;movd #{operands[1].x86Operand(:int)}, %xmm7&quot;</span>
<span class="line-removed">1529                 $asm.puts &quot;psllq $32, %xmm7&quot;</span>
<span class="line-removed">1530                 $asm.puts &quot;por %xmm7, #{operands[2].x86Operand(:double)}&quot;</span>
<span class="line-removed">1531             end</span>
1532         when &quot;fd2ii&quot;
<span class="line-modified">1533             if useX87</span>
<span class="line-modified">1534                 sp = RegisterID.new(nil, &quot;sp&quot;)</span>
<span class="line-modified">1535                 if (operands[0].x87DefaultStackPosition == 0)</span>
<span class="line-modified">1536                     $asm.puts &quot;fst#{x86Suffix(:ptr)} #{getSizeString(:double)}#{offsetRegister(-8, sp.x86Operand(:ptr))}&quot;</span>
<span class="line-removed">1537                 else</span>
<span class="line-removed">1538                     $asm.puts &quot;fld #{operands[0].x87Operand(0)}&quot;</span>
<span class="line-removed">1539                     $asm.puts &quot;fstpl -8(#{sp.x86Operand(:ptr)})&quot;</span>
<span class="line-removed">1540                 end</span>
<span class="line-removed">1541                 $asm.puts &quot;mov#{x86Suffix(:int)} #{orderOperands(offsetRegister(-8, sp.x86Operand(:ptr)), operands[1].x86Operand(:int))}&quot;</span>
<span class="line-removed">1542                 $asm.puts &quot;mov#{x86Suffix(:int)} #{orderOperands(offsetRegister(-4, sp.x86Operand(:ptr)), operands[2].x86Operand(:int))}&quot;</span>
<span class="line-removed">1543             else</span>
<span class="line-removed">1544                 $asm.puts &quot;movd #{operands[0].x86Operand(:double)}, #{operands[1].x86Operand(:int)}&quot;</span>
<span class="line-removed">1545                 $asm.puts &quot;movsd #{operands[0].x86Operand(:double)}, %xmm7&quot;</span>
<span class="line-removed">1546                 $asm.puts &quot;psrlq $32, %xmm7&quot;</span>
<span class="line-removed">1547                 $asm.puts &quot;movd %xmm7, #{operands[2].x86Operand(:int)}&quot;</span>
<span class="line-removed">1548             end</span>
1549         when &quot;fq2d&quot;
<span class="line-modified">1550             if useX87</span>
<span class="line-modified">1551                 sp = RegisterID.new(nil, &quot;sp&quot;)</span>
<span class="line-removed">1552                 $asm.puts &quot;movq #{operands[0].x86Operand(:quad)}, -8(#{sp.x86Operand(:ptr)})&quot;</span>
<span class="line-removed">1553                 $asm.puts &quot;fldl -8(#{sp.x86Operand(:ptr)})&quot;</span>
<span class="line-removed">1554                 $asm.puts &quot;fstp #{operands[1].x87Operand(1)}&quot;</span>
1555             else
<span class="line-modified">1556                 if !isIntelSyntax</span>
<span class="line-modified">1557                     $asm.puts &quot;movq #{operands[0].x86Operand(:quad)}, #{operands[1].x86Operand(:double)}&quot;</span>
<span class="line-modified">1558                 else</span>
<span class="line-removed">1559                     # MASM does not accept register operands with movq.</span>
<span class="line-removed">1560                     # Debugging shows that movd actually moves a qword when using MASM.</span>
<span class="line-removed">1561                     $asm.puts &quot;movd #{operands[1].x86Operand(:double)}, #{operands[0].x86Operand(:quad)}&quot;</span>
<span class="line-removed">1562                 end</span>
1563             end
1564         when &quot;fd2q&quot;
<span class="line-modified">1565             if useX87</span>
<span class="line-modified">1566                 sp = RegisterID.new(nil, &quot;sp&quot;)</span>
<span class="line-removed">1567                 if (operands[0].x87DefaultStackPosition == 0)</span>
<span class="line-removed">1568                     $asm.puts &quot;fst#{x86Suffix(:int)} #{getSizeString(:int)}#{offsetRegister(-8, sp.x86Operand(:ptr))}&quot;</span>
<span class="line-removed">1569                 else</span>
<span class="line-removed">1570                     $asm.puts &quot;fld #{operands[0].x87Operand(0)}&quot;</span>
<span class="line-removed">1571                     $asm.puts &quot;fstpl -8(#{sp.x86Operand(:ptr)})&quot;</span>
<span class="line-removed">1572                 end</span>
<span class="line-removed">1573                 $asm.puts &quot;movq -8(#{sp.x86Operand(:ptr)}), #{operands[1].x86Operand(:quad)}&quot;</span>
1574             else
<span class="line-modified">1575                 if !isIntelSyntax</span>
<span class="line-modified">1576                     $asm.puts &quot;movq #{operands[0].x86Operand(:double)}, #{operands[1].x86Operand(:quad)}&quot;</span>
<span class="line-modified">1577                 else</span>
<span class="line-removed">1578                     # MASM does not accept register operands with movq.</span>
<span class="line-removed">1579                     # Debugging shows that movd actually moves a qword when using MASM.</span>
<span class="line-removed">1580                     $asm.puts &quot;movd #{operands[1].x86Operand(:quad)}, #{operands[0].x86Operand(:double)}&quot;</span>
<span class="line-removed">1581                 end</span>
1582             end
1583         when &quot;bo&quot;
1584             $asm.puts &quot;jo #{operands[0].asmLabel}&quot;
1585         when &quot;bs&quot;
1586             $asm.puts &quot;js #{operands[0].asmLabel}&quot;
1587         when &quot;bz&quot;
1588             $asm.puts &quot;jz #{operands[0].asmLabel}&quot;
1589         when &quot;bnz&quot;
1590             $asm.puts &quot;jnz #{operands[0].asmLabel}&quot;
1591         when &quot;leai&quot;
1592             $asm.puts &quot;lea#{x86Suffix(:int)} #{orderOperands(operands[0].x86AddressOperand(:int), operands[1].x86Operand(:int))}&quot;
1593         when &quot;leap&quot;
1594             $asm.puts &quot;lea#{x86Suffix(:ptr)} #{orderOperands(operands[0].x86AddressOperand(:ptr), operands[1].x86Operand(:ptr))}&quot;
1595         when &quot;memfence&quot;
1596             sp = RegisterID.new(nil, &quot;sp&quot;)
1597             if isIntelSyntax
1598                 $asm.puts &quot;mfence&quot;
1599             else
1600                 $asm.puts &quot;lock; orl $0, (#{sp.x86Operand(:ptr)})&quot;
1601             end
</pre>
</td>
<td>
<hr />
<pre>
  32 # actually considered as such by the ABI and we need to push/pop our arguments
  33 # on the stack. a0 and a1 are ecx and edx to follow fastcall.
  34 #
  35 # eax =&gt; t0, a2, r0
  36 # edx =&gt; t1, a1, r1
  37 # ecx =&gt; t2, a0
  38 # ebx =&gt; t3, a3     (callee-save)
  39 # esi =&gt; t4         (callee-save)
  40 # edi =&gt; t5         (callee-save)
  41 # ebp =&gt; cfr
  42 # esp =&gt; sp
  43 #
  44 # On x86-64 non-windows
  45 #
  46 # rax =&gt; t0,     r0
  47 # rdi =&gt;     a0
  48 # rsi =&gt; t1, a1
  49 # rdx =&gt; t2, a2, r1
  50 # rcx =&gt; t3, a3
  51 #  r8 =&gt; t4
<span class="line-modified">  52 #  r9 =&gt; t5</span>
<span class="line-added">  53 # r10 =&gt; t6</span>
  54 # rbx =&gt;             csr0 (callee-save, PB, unused in baseline)
  55 # r12 =&gt;             csr1 (callee-save)
  56 # r13 =&gt;             csr2 (callee-save)
  57 # r14 =&gt;             csr3 (callee-save, tagTypeNumber)
  58 # r15 =&gt;             csr4 (callee-save, tagMask)
  59 # rsp =&gt; sp
  60 # rbp =&gt; cfr
  61 # r11 =&gt;                  (scratch)
  62 #
  63 # On x86-64 windows
  64 # Arguments need to be push/pop&#39;d on the stack in addition to being stored in
  65 # the registers. Also, &gt;8 return types are returned in a weird way.
  66 #
  67 # rax =&gt; t0,     r0
<span class="line-modified">  68 # rcx =&gt; t5, a0</span>
  69 # rdx =&gt; t1, a1, r1
  70 #  r8 =&gt; t2, a2
  71 #  r9 =&gt; t3, a3
  72 # r10 =&gt; t4
  73 # rbx =&gt;             csr0 (callee-save, PB, unused in baseline)
  74 # rsi =&gt;             csr1 (callee-save)
  75 # rdi =&gt;             csr2 (callee-save)
  76 # r12 =&gt;             csr3 (callee-save)
  77 # r13 =&gt;             csr4 (callee-save)
  78 # r14 =&gt;             csr5 (callee-save, tagTypeNumber)
  79 # r15 =&gt;             csr6 (callee-save, tagMask)
  80 # rsp =&gt; sp
  81 # rbp =&gt; cfr
  82 # r11 =&gt;                  (scratch)
  83 
  84 def isX64
  85     case $activeBackend
  86     when &quot;X86&quot;
  87         false
  88     when &quot;X86_WIN&quot;
</pre>
<hr />
<pre>
  94     else
  95         raise &quot;bad value for $activeBackend: #{$activeBackend}&quot;
  96     end
  97 end
  98 
  99 def isWin
 100     case $activeBackend
 101     when &quot;X86&quot;
 102         false
 103     when &quot;X86_WIN&quot;
 104         true
 105     when &quot;X86_64&quot;
 106         false
 107     when &quot;X86_64_WIN&quot;
 108         true
 109     else
 110         raise &quot;bad value for $activeBackend: #{$activeBackend}&quot;
 111     end
 112 end
 113 















 114 def isMSVC
 115     $options.has_key?(:assembler) &amp;&amp; $options[:assembler] == &quot;MASM&quot;
 116 end
 117 
 118 def isIntelSyntax
 119     $options.has_key?(:assembler) &amp;&amp; $options[:assembler] == &quot;MASM&quot;
 120 end
 121 
 122 def register(name)
 123     isIntelSyntax ? name : &quot;%&quot; + name
 124 end
 125 
 126 def offsetRegister(off, register)
 127     isIntelSyntax ? &quot;[#{off} + #{register}]&quot; : &quot;#{off}(#{register})&quot;
 128 end
 129 
 130 def callPrefix
 131     isIntelSyntax ? &quot;&quot; : &quot;*&quot;
 132 end
 133 
</pre>
<hr />
<pre>
 310             when &quot;cfr&quot;
 311                 &quot;ebp&quot;
 312             when &quot;sp&quot;
 313                 &quot;esp&quot;
 314             end
 315         end
 316     end
 317 
 318     def x86Operand(kind)
 319         x86GPRName(x86GPR, kind)
 320     end
 321 
 322     def x86CallOperand(kind)
 323         &quot;#{callPrefix}#{x86Operand(:ptr)}&quot;
 324     end
 325 end
 326 
 327 class FPRegisterID
 328     def x86Operand(kind)
 329         raise unless kind == :double

 330         case name
 331         when &quot;ft0&quot;, &quot;fa0&quot;, &quot;fr&quot;
 332             register(&quot;xmm0&quot;)
 333         when &quot;ft1&quot;, &quot;fa1&quot;
 334             register(&quot;xmm1&quot;)
 335         when &quot;ft2&quot;, &quot;fa2&quot;
 336             register(&quot;xmm2&quot;)
 337         when &quot;ft3&quot;, &quot;fa3&quot;
 338             register(&quot;xmm3&quot;)
 339         when &quot;ft4&quot;
 340             register(&quot;xmm4&quot;)
 341         when &quot;ft5&quot;
 342             register(&quot;xmm5&quot;)
 343         else
 344             raise &quot;Bad register #{name} for X86 at #{codeOriginString}&quot;
 345         end
 346     end

















 347     def x86CallOperand(kind)
 348         &quot;#{callPrefix}#{x86Operand(kind)}&quot;
 349     end
 350 end
 351 
 352 class Immediate
 353     def validX86Immediate?
 354         if isX64
 355             value &gt;= -0x80000000 and value &lt;= 0x7fffffff
 356         else
 357             true
 358         end
 359     end
 360     def x86Operand(kind)
 361         &quot;#{const(value)}&quot;
 362     end
 363     def x86CallOperand(kind)
 364         &quot;#{value}&quot;
 365     end
 366 end
</pre>
<hr />
<pre>
 512         orderOperands(operands[0].x86LoadOperand(srcKind, operands[1]), operands[1].x86Operand(dstKind))
 513     end
 514 
 515     def x86Suffix(kind)
 516         if isIntelSyntax
 517             return &quot;&quot;
 518         end
 519 
 520         case kind
 521         when :byte
 522             &quot;b&quot;
 523         when :half
 524             &quot;w&quot;
 525         when :int
 526             &quot;l&quot;
 527         when :ptr
 528             isX64 ? &quot;q&quot; : &quot;l&quot;
 529         when :quad
 530             isX64 ? &quot;q&quot; : raise
 531         when :double
<span class="line-modified"> 532             &quot;sd&quot;</span>
 533         else
 534             raise
 535         end
 536     end
 537     
 538     def x86Bytes(kind)
 539         case kind
 540         when :byte
 541             1
 542         when :half
 543             2
 544         when :int
 545             4
 546         when :ptr
 547             isX64 ? 8 : 4
 548         when :quad
 549             isX64 ? 8 : raise
 550         when :double
 551             8
 552         else
</pre>
<hr />
<pre>
 584         else
 585             $asm.puts &quot;#{opcode} #{orderOperands(operands[0].x86Operand(kind), operands[1].x86Operand(kind))}&quot;
 586         end
 587     end
 588     
 589     def handleX86Op(opcode, kind)
 590         handleX86OpWithNumOperands(opcode, kind, operands.size)
 591     end
 592     
 593     def handleX86Shift(opcode, kind)
 594         if operands[0].is_a? Immediate or operands[0].x86GPR == &quot;ecx&quot;
 595             $asm.puts &quot;#{opcode} #{orderOperands(operands[0].x86Operand(:byte), operands[1].x86Operand(kind))}&quot;
 596         else
 597             $asm.puts &quot;xchg#{x86Suffix(:ptr)} #{operands[0].x86Operand(:ptr)}, #{x86GPRName(&quot;ecx&quot;, :ptr)}&quot;
 598             $asm.puts &quot;#{opcode} #{orderOperands(register(&quot;cl&quot;), operands[1].x86Operand(kind))}&quot;
 599             $asm.puts &quot;xchg#{x86Suffix(:ptr)} #{operands[0].x86Operand(:ptr)}, #{x86GPRName(&quot;ecx&quot;, :ptr)}&quot;
 600         end
 601     end
 602     
 603     def handleX86DoubleBranch(branchOpcode, mode)
<span class="line-modified"> 604         case mode</span>
<span class="line-modified"> 605         when :normal</span>
<span class="line-added"> 606             $asm.puts &quot;ucomisd #{orderOperands(operands[1].x86Operand(:double), operands[0].x86Operand(:double))}&quot;</span>
<span class="line-added"> 607         when :reverse</span>
<span class="line-added"> 608             $asm.puts &quot;ucomisd #{orderOperands(operands[0].x86Operand(:double), operands[1].x86Operand(:double))}&quot;</span>
 609         else
<span class="line-modified"> 610             raise mode.inspect</span>







 611         end
 612         $asm.puts &quot;#{branchOpcode} #{operands[2].asmLabel}&quot;
 613     end
 614     
 615     def handleX86IntCompare(opcodeSuffix, kind)
 616         if operands[0].is_a? Immediate and operands[0].value == 0 and operands[1].is_a? RegisterID and (opcodeSuffix == &quot;e&quot; or opcodeSuffix == &quot;ne&quot;)
 617             $asm.puts &quot;test#{x86Suffix(kind)} #{orderOperands(operands[1].x86Operand(kind), operands[1].x86Operand(kind))}&quot;
 618         elsif operands[1].is_a? Immediate and operands[1].value == 0 and operands[0].is_a? RegisterID and (opcodeSuffix == &quot;e&quot; or opcodeSuffix == &quot;ne&quot;)
 619             $asm.puts &quot;test#{x86Suffix(kind)}  #{orderOperands(operands[0].x86Operand(kind), operands[0].x86Operand(kind))}&quot;
 620         else
 621             $asm.puts &quot;cmp#{x86Suffix(kind)} #{orderOperands(operands[1].x86Operand(kind), operands[0].x86Operand(kind))}&quot;
 622         end
 623     end
 624     
 625     def handleX86IntBranch(branchOpcode, kind)
 626         handleX86IntCompare(branchOpcode[1..-1], kind)
 627         $asm.puts &quot;#{branchOpcode} #{operands[2].asmLabel}&quot;
 628     end
 629     
 630     def handleX86Set(setOpcode, operand)
</pre>
<hr />
<pre>
 808         opB = offsetRegister(operands[1].value * x86Bytes(:ptr), sp.x86Operand(:ptr))
 809         $asm.puts &quot;mov#{x86Suffix(:ptr)} #{orderOperands(opA, opB)}&quot;
 810     end
 811 
 812     def handleMove
 813         if Immediate.new(nil, 0) == operands[0] and operands[1].is_a? RegisterID
 814             if isX64
 815                 $asm.puts &quot;xor#{x86Suffix(:quad)} #{operands[1].x86Operand(:quad)}, #{operands[1].x86Operand(:quad)}&quot;
 816             else
 817                 $asm.puts &quot;xor#{x86Suffix(:ptr)} #{operands[1].x86Operand(:ptr)}, #{operands[1].x86Operand(:ptr)}&quot;
 818             end
 819         elsif operands[0] != operands[1]
 820             if isX64
 821                 $asm.puts &quot;mov#{x86Suffix(:quad)} #{x86Operands(:quad, :quad)}&quot;
 822             else
 823                 $asm.puts &quot;mov#{x86Suffix(:ptr)} #{x86Operands(:ptr, :ptr)}&quot;
 824             end
 825         end
 826     end
 827 





































 828     def lowerX86
 829         raise unless $activeBackend == &quot;X86&quot;
 830         lowerX86Common
 831     end
 832 
 833     def lowerX86_WIN
 834         raise unless $activeBackend == &quot;X86_WIN&quot; 
 835         lowerX86Common
 836     end
 837     
 838     def lowerX86_64
 839         raise unless $activeBackend == &quot;X86_64&quot;
 840         lowerX86Common
 841     end
 842 
 843     def lowerX86_64_WIN
 844         raise unless $activeBackend == &quot;X86_64_WIN&quot;
 845         lowerX86Common
 846     end
 847 
</pre>
<hr />
<pre>
 922                 else
 923                     $asm.puts &quot;movsxd #{x86LoadOperands(:int, :quad)}&quot;
 924                 end
 925             else
 926                 $asm.puts &quot;mov#{x86Suffix(:int)} #{x86LoadOperands(:int, :int)}&quot;
 927             end
 928         when &quot;loadp&quot;
 929             $asm.puts &quot;mov#{x86Suffix(:ptr)} #{x86LoadOperands(:ptr, :ptr)}&quot;
 930         when &quot;storep&quot;
 931             $asm.puts &quot;mov#{x86Suffix(:ptr)} #{x86Operands(:ptr, :ptr)}&quot;
 932         when &quot;loadq&quot;
 933             $asm.puts &quot;mov#{x86Suffix(:quad)} #{x86LoadOperands(:quad, :quad)}&quot;
 934         when &quot;storeq&quot;
 935             $asm.puts &quot;mov#{x86Suffix(:quad)} #{x86Operands(:quad, :quad)}&quot;
 936         when &quot;loadb&quot;
 937             if !isIntelSyntax
 938                 $asm.puts &quot;movzbl #{x86LoadOperands(:byte, :int)}&quot;
 939             else
 940                 $asm.puts &quot;movzx #{x86LoadOperands(:byte, :int)}&quot;
 941             end
<span class="line-modified"> 942         when &quot;loadbsi&quot;</span>
 943             if !isIntelSyntax
 944                 $asm.puts &quot;movsbl #{x86LoadOperands(:byte, :int)}&quot;
 945             else
 946                 $asm.puts &quot;movsx #{x86LoadOperands(:byte, :int)}&quot;
 947             end
<span class="line-modified"> 948         when &quot;loadbsq&quot;</span>
 949             if !isIntelSyntax
<span class="line-modified"> 950                 $asm.puts &quot;movsbq #{x86LoadOperands(:byte, :quad)}&quot;</span>
 951             else
<span class="line-modified"> 952                 $asm.puts &quot;movsx #{x86LoadOperands(:byte, :quad)}&quot;</span>
 953             end
 954         when &quot;loadh&quot;
 955             if !isIntelSyntax
 956                 $asm.puts &quot;movzwl #{x86LoadOperands(:half, :int)}&quot;
 957             else
 958                 $asm.puts &quot;movzx #{x86LoadOperands(:half, :int)}&quot;
 959             end
<span class="line-modified"> 960         when &quot;loadhsi&quot;</span>
 961             if !isIntelSyntax
 962                 $asm.puts &quot;movswl #{x86LoadOperands(:half, :int)}&quot;
 963             else
 964                 $asm.puts &quot;movsx #{x86LoadOperands(:half, :int)}&quot;
 965             end
<span class="line-added"> 966         when &quot;loadhsq&quot;</span>
<span class="line-added"> 967             if !isIntelSyntax</span>
<span class="line-added"> 968                 $asm.puts &quot;movswq #{x86LoadOperands(:half, :quad)}&quot;</span>
<span class="line-added"> 969             else</span>
<span class="line-added"> 970                 $asm.puts &quot;movsx #{x86LoadOperands(:half, :quad)}&quot;</span>
<span class="line-added"> 971             end</span>
 972         when &quot;storeb&quot;
 973             $asm.puts &quot;mov#{x86Suffix(:byte)} #{x86Operands(:byte, :byte)}&quot;
 974         when &quot;loadd&quot;
<span class="line-modified"> 975             $asm.puts &quot;movsd #{x86Operands(:double, :double)}&quot;</span>









 976         when &quot;moved&quot;
<span class="line-modified"> 977             $asm.puts &quot;movsd #{x86Operands(:double, :double)}&quot;</span>









 978         when &quot;stored&quot;
<span class="line-modified"> 979             $asm.puts &quot;movsd #{x86Operands(:double, :double)}&quot;</span>













 980         when &quot;addd&quot;
<span class="line-modified"> 981             $asm.puts &quot;addsd #{x86Operands(:double, :double)}&quot;</span>




 982         when &quot;muld&quot;
<span class="line-modified"> 983             $asm.puts &quot;mulsd #{x86Operands(:double, :double)}&quot;</span>




 984         when &quot;subd&quot;
<span class="line-modified"> 985             $asm.puts &quot;subsd #{x86Operands(:double, :double)}&quot;</span>




 986         when &quot;divd&quot;
<span class="line-modified"> 987             $asm.puts &quot;divsd #{x86Operands(:double, :double)}&quot;</span>




 988         when &quot;sqrtd&quot;
<span class="line-modified"> 989             $asm.puts &quot;sqrtsd #{operands[0].x86Operand(:double)}, #{operands[1].x86Operand(:double)}&quot;</span>






 990         when &quot;ci2d&quot;
<span class="line-modified"> 991             $asm.puts &quot;cvtsi2sd #{orderOperands(operands[0].x86Operand(:int), operands[1].x86Operand(:double))}&quot;</span>







 992         when &quot;bdeq&quot;
<span class="line-modified"> 993             $asm.puts &quot;ucomisd #{orderOperands(operands[0].x86Operand(:double), operands[1].x86Operand(:double))}&quot;</span>




 994             if operands[0] == operands[1]
 995                 # This is just a jump ordered, which is a jnp.
 996                 $asm.puts &quot;jnp #{operands[2].asmLabel}&quot;
 997             else
 998                 isUnordered = LocalLabel.unique(&quot;bdeq&quot;)
 999                 $asm.puts &quot;jp #{LabelReference.new(codeOrigin, isUnordered).asmLabel}&quot;
1000                 $asm.puts &quot;je #{LabelReference.new(codeOrigin, operands[2]).asmLabel}&quot;
1001                 isUnordered.lower(&quot;X86&quot;)
1002             end
1003         when &quot;bdneq&quot;
1004             handleX86DoubleBranch(&quot;jne&quot;, :normal)
1005         when &quot;bdgt&quot;
1006             handleX86DoubleBranch(&quot;ja&quot;, :normal)
1007         when &quot;bdgteq&quot;
1008             handleX86DoubleBranch(&quot;jae&quot;, :normal)
1009         when &quot;bdlt&quot;
1010             handleX86DoubleBranch(&quot;ja&quot;, :reverse)
1011         when &quot;bdlteq&quot;
1012             handleX86DoubleBranch(&quot;jae&quot;, :reverse)
1013         when &quot;bdequn&quot;
1014             handleX86DoubleBranch(&quot;je&quot;, :normal)
1015         when &quot;bdnequn&quot;
<span class="line-modified">1016             $asm.puts &quot;ucomisd #{orderOperands(operands[0].x86Operand(:double), operands[1].x86Operand(:double))}&quot;</span>




1017             if operands[0] == operands[1]
1018                 # This is just a jump unordered, which is a jp.
1019                 $asm.puts &quot;jp #{operands[2].asmLabel}&quot;
1020             else
1021                 isUnordered = LocalLabel.unique(&quot;bdnequn&quot;)
1022                 isEqual = LocalLabel.unique(&quot;bdnequn&quot;)
1023                 $asm.puts &quot;jp #{LabelReference.new(codeOrigin, isUnordered).asmLabel}&quot;
1024                 $asm.puts &quot;je #{LabelReference.new(codeOrigin, isEqual).asmLabel}&quot;
1025                 isUnordered.lower(&quot;X86&quot;)
1026                 $asm.puts &quot;jmp #{operands[2].asmLabel}&quot;
1027                 isEqual.lower(&quot;X86&quot;)
1028             end
1029         when &quot;bdgtun&quot;
1030             handleX86DoubleBranch(&quot;jb&quot;, :reverse)
1031         when &quot;bdgtequn&quot;
1032             handleX86DoubleBranch(&quot;jbe&quot;, :reverse)
1033         when &quot;bdltun&quot;
1034             handleX86DoubleBranch(&quot;jb&quot;, :normal)
1035         when &quot;bdltequn&quot;
1036             handleX86DoubleBranch(&quot;jbe&quot;, :normal)
1037         when &quot;btd2i&quot;


1038             $asm.puts &quot;cvttsd2si #{operands[0].x86Operand(:double)}, #{operands[1].x86Operand(:int)}&quot;
1039             $asm.puts &quot;cmpl $0x80000000 #{operands[1].x86Operand(:int)}&quot;
1040             $asm.puts &quot;je #{operands[2].asmLabel}&quot;
1041         when &quot;td2i&quot;


1042             $asm.puts &quot;cvttsd2si #{operands[0].x86Operand(:double)}, #{operands[1].x86Operand(:int)}&quot;
1043         when &quot;bcd2i&quot;
<span class="line-modified">1044             $asm.puts &quot;cvttsd2si #{operands[0].x86Operand(:double)}, #{operands[1].x86Operand(:int)}&quot;</span>
<span class="line-modified">1045             $asm.puts &quot;test#{x86Suffix(:int)} #{operands[1].x86Operand(:int)}, #{operands[1].x86Operand(:int)}&quot;</span>
<span class="line-modified">1046             $asm.puts &quot;je #{operands[2].asmLabel}&quot;</span>
<span class="line-modified">1047             $asm.puts &quot;cvtsi2sd #{operands[1].x86Operand(:int)}, %xmm7&quot;</span>
<span class="line-modified">1048             $asm.puts &quot;ucomisd #{operands[0].x86Operand(:double)}, %xmm7&quot;</span>
<span class="line-modified">1049             $asm.puts &quot;jp #{operands[2].asmLabel}&quot;</span>
<span class="line-modified">1050             $asm.puts &quot;jne #{operands[2].asmLabel}&quot;</span>


















1051         when &quot;movdz&quot;
<span class="line-modified">1052             $asm.puts &quot;xorpd #{operands[0].x86Operand(:double)}, #{operands[0].x86Operand(:double)}&quot;</span>





1053         when &quot;pop&quot;
1054             operands.each {
1055                 | op |
1056                 $asm.puts &quot;pop #{op.x86Operand(:ptr)}&quot;
1057             }
1058         when &quot;push&quot;
1059             operands.each {
1060                 | op |
1061                 $asm.puts &quot;push #{op.x86Operand(:ptr)}&quot;
1062             }
1063         when &quot;move&quot;
1064             handleMove
1065         when &quot;sxi2q&quot;
1066             if !isIntelSyntax
1067                 $asm.puts &quot;movslq #{operands[0].x86Operand(:int)}, #{operands[1].x86Operand(:quad)}&quot;
1068             else
1069                 $asm.puts &quot;movsxd #{orderOperands(operands[0].x86Operand(:int), operands[1].x86Operand(:quad))}&quot;
1070             end
1071         when &quot;zxi2q&quot;
1072             $asm.puts &quot;mov#{x86Suffix(:int)} #{orderOperands(operands[0].x86Operand(:int), operands[1].x86Operand(:int))}&quot;
</pre>
<hr />
<pre>
1212             handleX86SubBranch(&quot;jnz&quot;, :int)
1213         when &quot;bmulio&quot;
1214             handleX86OpBranch(&quot;imul#{x86Suffix(:int)}&quot;, &quot;jo&quot;, :int)
1215         when &quot;bmulis&quot;
1216             handleX86OpBranch(&quot;imul#{x86Suffix(:int)}&quot;, &quot;js&quot;, :int)
1217         when &quot;bmuliz&quot;
1218             handleX86OpBranch(&quot;imul#{x86Suffix(:int)}&quot;, &quot;jz&quot;, :int)
1219         when &quot;bmulinz&quot;
1220             handleX86OpBranch(&quot;imul#{x86Suffix(:int)}&quot;, &quot;jnz&quot;, :int)
1221         when &quot;borio&quot;
1222             handleX86OpBranch(&quot;orl&quot;, &quot;jo&quot;, :int)
1223         when &quot;boris&quot;
1224             handleX86OpBranch(&quot;orl&quot;, &quot;js&quot;, :int)
1225         when &quot;boriz&quot;
1226             handleX86OpBranch(&quot;orl&quot;, &quot;jz&quot;, :int)
1227         when &quot;borinz&quot;
1228             handleX86OpBranch(&quot;orl&quot;, &quot;jnz&quot;, :int)
1229         when &quot;break&quot;
1230             $asm.puts &quot;int #{const(3)}&quot;
1231         when &quot;call&quot;






1232             op = operands[0].x86CallOperand(:ptr)
1233             if operands[0].is_a? LabelReference
1234                 operands[0].used
1235             end
1236             $asm.puts &quot;call #{op}&quot;
1237         when &quot;ret&quot;
1238             $asm.puts &quot;ret&quot;
1239         when &quot;cieq&quot;
1240             handleX86IntCompareSet(&quot;sete&quot;, :int)
1241         when &quot;cbeq&quot;
1242             handleX86IntCompareSet(&quot;sete&quot;, :byte)
1243         when &quot;cpeq&quot;
1244             handleX86IntCompareSet(&quot;sete&quot;, :ptr)
1245         when &quot;cqeq&quot;
1246             handleX86IntCompareSet(&quot;sete&quot;, :quad)
1247         when &quot;cineq&quot;
1248             handleX86IntCompareSet(&quot;setne&quot;, :int)
1249         when &quot;cbneq&quot;
1250             handleX86IntCompareSet(&quot;setne&quot;, :byte)
1251         when &quot;cpneq&quot;
</pre>
<hr />
<pre>
1332             handleX86SetTest(&quot;sets&quot;, :quad)
1333         when &quot;tqz&quot;
1334             handleX86SetTest(&quot;setz&quot;, :quad)
1335         when &quot;tqnz&quot;
1336             handleX86SetTest(&quot;setnz&quot;, :quad)
1337         when &quot;tbs&quot;
1338             handleX86SetTest(&quot;sets&quot;, :byte)
1339         when &quot;tbz&quot;
1340             handleX86SetTest(&quot;setz&quot;, :byte)
1341         when &quot;tbnz&quot;
1342             handleX86SetTest(&quot;setnz&quot;, :byte)
1343         when &quot;peek&quot;
1344             handleX86Peek()
1345         when &quot;poke&quot;
1346             handleX86Poke()
1347         when &quot;cdqi&quot;
1348             $asm.puts &quot;cdq&quot;
1349         when &quot;idivi&quot;
1350             $asm.puts &quot;idiv#{x86Suffix(:int)} #{operands[0].x86Operand(:int)}&quot;
1351         when &quot;fii2d&quot;
<span class="line-modified">1352             $asm.puts &quot;movd #{operands[0].x86Operand(:int)}, #{operands[2].x86Operand(:double)}&quot;</span>
<span class="line-modified">1353             $asm.puts &quot;movd #{operands[1].x86Operand(:int)}, %xmm7&quot;</span>
<span class="line-modified">1354             $asm.puts &quot;psllq $32, %xmm7&quot;</span>
<span class="line-modified">1355             $asm.puts &quot;por %xmm7, #{operands[2].x86Operand(:double)}&quot;</span>








1356         when &quot;fd2ii&quot;
<span class="line-modified">1357             $asm.puts &quot;movd #{operands[0].x86Operand(:double)}, #{operands[1].x86Operand(:int)}&quot;</span>
<span class="line-modified">1358             $asm.puts &quot;movsd #{operands[0].x86Operand(:double)}, %xmm7&quot;</span>
<span class="line-modified">1359             $asm.puts &quot;psrlq $32, %xmm7&quot;</span>
<span class="line-modified">1360             $asm.puts &quot;movd %xmm7, #{operands[2].x86Operand(:int)}&quot;</span>












1361         when &quot;fq2d&quot;
<span class="line-modified">1362             if !isIntelSyntax</span>
<span class="line-modified">1363                 $asm.puts &quot;movq #{operands[0].x86Operand(:quad)}, #{operands[1].x86Operand(:double)}&quot;</span>



1364             else
<span class="line-modified">1365                 # MASM does not accept register operands with movq.</span>
<span class="line-modified">1366                 # Debugging shows that movd actually moves a qword when using MASM.</span>
<span class="line-modified">1367                 $asm.puts &quot;movd #{operands[1].x86Operand(:double)}, #{operands[0].x86Operand(:quad)}&quot;</span>




1368             end
1369         when &quot;fd2q&quot;
<span class="line-modified">1370             if !isIntelSyntax</span>
<span class="line-modified">1371                 $asm.puts &quot;movq #{operands[0].x86Operand(:double)}, #{operands[1].x86Operand(:quad)}&quot;</span>







1372             else
<span class="line-modified">1373                 # MASM does not accept register operands with movq.</span>
<span class="line-modified">1374                 # Debugging shows that movd actually moves a qword when using MASM.</span>
<span class="line-modified">1375                 $asm.puts &quot;movd #{operands[1].x86Operand(:quad)}, #{operands[0].x86Operand(:double)}&quot;</span>




1376             end
1377         when &quot;bo&quot;
1378             $asm.puts &quot;jo #{operands[0].asmLabel}&quot;
1379         when &quot;bs&quot;
1380             $asm.puts &quot;js #{operands[0].asmLabel}&quot;
1381         when &quot;bz&quot;
1382             $asm.puts &quot;jz #{operands[0].asmLabel}&quot;
1383         when &quot;bnz&quot;
1384             $asm.puts &quot;jnz #{operands[0].asmLabel}&quot;
1385         when &quot;leai&quot;
1386             $asm.puts &quot;lea#{x86Suffix(:int)} #{orderOperands(operands[0].x86AddressOperand(:int), operands[1].x86Operand(:int))}&quot;
1387         when &quot;leap&quot;
1388             $asm.puts &quot;lea#{x86Suffix(:ptr)} #{orderOperands(operands[0].x86AddressOperand(:ptr), operands[1].x86Operand(:ptr))}&quot;
1389         when &quot;memfence&quot;
1390             sp = RegisterID.new(nil, &quot;sp&quot;)
1391             if isIntelSyntax
1392                 $asm.puts &quot;mfence&quot;
1393             else
1394                 $asm.puts &quot;lock; orl $0, (#{sp.x86Operand(:ptr)})&quot;
1395             end
</pre>
</td>
</tr>
</table>
<center><a href="registers.rb.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../parser/ASTBuilder.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>