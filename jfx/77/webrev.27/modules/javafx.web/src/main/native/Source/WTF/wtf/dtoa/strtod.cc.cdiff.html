<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WTF/wtf/dtoa/strtod.cc</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="fixed-dtoa.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="strtod.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WTF/wtf/dtoa/strtod.cc</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 53,85 ***</span>
  // Any x &lt;= 10^-324 is interpreted as 0.
  // Note that 2.5e-324 (despite being smaller than the min double) will be read
  // as non-zero (equal to the min non-zero double).
  static const int kMaxDecimalPower = 309;
  static const int kMinDecimalPower = -324;
<span class="line-modified">!     </span>
  // 2^64 = 18446744073709551616
  static const uint64_t kMaxUint64 = UINT64_2PART_C(0xFFFFFFFF, FFFFFFFF);
<span class="line-modified">!     </span>
<span class="line-modified">!     </span>
  #if defined(DOUBLE_CONVERSION_CORRECT_DOUBLE_OPERATIONS)
  static const double exact_powers_of_ten[] = {
<span class="line-modified">!         1.0,  // 10^0</span>
<span class="line-modified">!         10.0,</span>
<span class="line-modified">!         100.0,</span>
<span class="line-modified">!         1000.0,</span>
<span class="line-modified">!         10000.0,</span>
<span class="line-modified">!         100000.0,</span>
<span class="line-modified">!         1000000.0,</span>
<span class="line-modified">!         10000000.0,</span>
<span class="line-modified">!         100000000.0,</span>
<span class="line-modified">!         1000000000.0,</span>
<span class="line-modified">!         10000000000.0,  // 10^10</span>
<span class="line-modified">!         100000000000.0,</span>
<span class="line-modified">!         1000000000000.0,</span>
<span class="line-modified">!         10000000000000.0,</span>
<span class="line-modified">!         100000000000000.0,</span>
<span class="line-modified">!         1000000000000000.0,</span>
<span class="line-modified">!         10000000000000000.0,</span>
<span class="line-modified">!         100000000000000000.0,</span>
<span class="line-modified">!         1000000000000000000.0,</span>
<span class="line-modified">!         10000000000000000000.0,</span>
<span class="line-modified">!         100000000000000000000.0,  // 10^20</span>
<span class="line-modified">!         1000000000000000000000.0,</span>
<span class="line-modified">!         // 10^22 = 0x21e19e0c9bab2400000 = 0x878678326eac9 * 2^22</span>
<span class="line-modified">!         10000000000000000000000.0</span>
  };
  static const int kExactPowersOfTenSize = ARRAY_SIZE(exact_powers_of_ten);
  #endif
<span class="line-modified">!     </span>
  // Maximum number of significant digits in the decimal representation.
  // In fact the value is 772 (see conversions.cc), but to give us some margin
  // we round up to 780.
  static const int kMaxSignificantDecimalDigits = 780;
<span class="line-modified">!     </span>
  static BufferReference&lt;const char&gt; TrimLeadingZeros(BufferReference&lt;const char&gt; buffer) {
<span class="line-modified">!         for (int i = 0; i &lt; buffer.length(); i++) {</span>
<span class="line-modified">!             if (buffer[i] != &#39;0&#39;) {</span>
<span class="line-modified">!                 return buffer.SubBufferReference(i, buffer.length());</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         return BufferReference&lt;const char&gt;(buffer.start(), 0);</span>
  }
<span class="line-modified">!     </span>
<span class="line-modified">!     </span>
  static BufferReference&lt;const char&gt; TrimTrailingZeros(BufferReference&lt;const char&gt; buffer) {
<span class="line-modified">!         for (int i = buffer.length() - 1; i &gt;= 0; --i) {</span>
<span class="line-modified">!             if (buffer[i] != &#39;0&#39;) {</span>
<span class="line-modified">!                 return buffer.SubBufferReference(0, i + 1);</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         return BufferReference&lt;const char&gt;(buffer.start(), 0);</span>
  }
<span class="line-modified">!     </span>
<span class="line-modified">!     </span>
  static void CutToMaxSignificantDigits(BufferReference&lt;const char&gt; buffer,
<span class="line-modified">!                                            int exponent,</span>
<span class="line-modified">!                                            char* significant_buffer,</span>
<span class="line-modified">!                                            int* significant_exponent) {</span>
<span class="line-modified">!         for (int i = 0; i &lt; kMaxSignificantDecimalDigits - 1; ++i) {</span>
<span class="line-modified">!             significant_buffer[i] = buffer[i];</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         // The input buffer has been trimmed. Therefore the last digit must be</span>
<span class="line-modified">!         // different from &#39;0&#39;.</span>
<span class="line-modified">!         ASSERT(buffer[buffer.length() - 1] != &#39;0&#39;);</span>
<span class="line-modified">!         // Set the last digit to be non-zero. This is sufficient to guarantee</span>
<span class="line-modified">!         // correct rounding.</span>
<span class="line-modified">!         significant_buffer[kMaxSignificantDecimalDigits - 1] = &#39;1&#39;;</span>
<span class="line-modified">!         *significant_exponent =</span>
<span class="line-modified">!         exponent + (buffer.length() - kMaxSignificantDecimalDigits);</span>
  }
  
  
  // Trims the buffer and cuts it to at most kMaxSignificantDecimalDigits.
  // If possible the input-buffer is reused, but if the buffer needs to be
<span class="line-new-header">--- 53,85 ---</span>
  // Any x &lt;= 10^-324 is interpreted as 0.
  // Note that 2.5e-324 (despite being smaller than the min double) will be read
  // as non-zero (equal to the min non-zero double).
  static const int kMaxDecimalPower = 309;
  static const int kMinDecimalPower = -324;
<span class="line-modified">! </span>
  // 2^64 = 18446744073709551616
  static const uint64_t kMaxUint64 = UINT64_2PART_C(0xFFFFFFFF, FFFFFFFF);
<span class="line-modified">! </span>
<span class="line-modified">! </span>
  #if defined(DOUBLE_CONVERSION_CORRECT_DOUBLE_OPERATIONS)
  static const double exact_powers_of_ten[] = {
<span class="line-modified">!   1.0,  // 10^0</span>
<span class="line-modified">!   10.0,</span>
<span class="line-modified">!   100.0,</span>
<span class="line-modified">!   1000.0,</span>
<span class="line-modified">!   10000.0,</span>
<span class="line-modified">!   100000.0,</span>
<span class="line-modified">!   1000000.0,</span>
<span class="line-modified">!   10000000.0,</span>
<span class="line-modified">!   100000000.0,</span>
<span class="line-modified">!   1000000000.0,</span>
<span class="line-modified">!   10000000000.0,  // 10^10</span>
<span class="line-modified">!   100000000000.0,</span>
<span class="line-modified">!   1000000000000.0,</span>
<span class="line-modified">!   10000000000000.0,</span>
<span class="line-modified">!   100000000000000.0,</span>
<span class="line-modified">!   1000000000000000.0,</span>
<span class="line-modified">!   10000000000000000.0,</span>
<span class="line-modified">!   100000000000000000.0,</span>
<span class="line-modified">!   1000000000000000000.0,</span>
<span class="line-modified">!   10000000000000000000.0,</span>
<span class="line-modified">!   100000000000000000000.0,  // 10^20</span>
<span class="line-modified">!   1000000000000000000000.0,</span>
<span class="line-modified">!   // 10^22 = 0x21e19e0c9bab2400000 = 0x878678326eac9 * 2^22</span>
<span class="line-modified">!   10000000000000000000000.0</span>
  };
  static const int kExactPowersOfTenSize = ARRAY_SIZE(exact_powers_of_ten);
  #endif
<span class="line-modified">! </span>
  // Maximum number of significant digits in the decimal representation.
  // In fact the value is 772 (see conversions.cc), but to give us some margin
  // we round up to 780.
  static const int kMaxSignificantDecimalDigits = 780;
<span class="line-modified">! </span>
  static BufferReference&lt;const char&gt; TrimLeadingZeros(BufferReference&lt;const char&gt; buffer) {
<span class="line-modified">!   for (int i = 0; i &lt; buffer.length(); i++) {</span>
<span class="line-modified">!     if (buffer[i] != &#39;0&#39;) {</span>
<span class="line-modified">!       return buffer.SubBufferReference(i, buffer.length());</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   return BufferReference&lt;const char&gt;(buffer.start(), 0);</span>
  }
<span class="line-modified">! </span>
<span class="line-modified">! </span>
  static BufferReference&lt;const char&gt; TrimTrailingZeros(BufferReference&lt;const char&gt; buffer) {
<span class="line-modified">!   for (int i = buffer.length() - 1; i &gt;= 0; --i) {</span>
<span class="line-modified">!     if (buffer[i] != &#39;0&#39;) {</span>
<span class="line-modified">!       return buffer.SubBufferReference(0, i + 1);</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   return BufferReference&lt;const char&gt;(buffer.start(), 0);</span>
  }
<span class="line-modified">! </span>
<span class="line-modified">! </span>
  static void CutToMaxSignificantDigits(BufferReference&lt;const char&gt; buffer,
<span class="line-modified">!                                        int exponent,</span>
<span class="line-modified">!                                        char* significant_buffer,</span>
<span class="line-modified">!                                        int* significant_exponent) {</span>
<span class="line-modified">!   for (int i = 0; i &lt; kMaxSignificantDecimalDigits - 1; ++i) {</span>
<span class="line-modified">!     significant_buffer[i] = buffer[i];</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   // The input buffer has been trimmed. Therefore the last digit must be</span>
<span class="line-modified">!   // different from &#39;0&#39;.</span>
<span class="line-modified">!   ASSERT(buffer[buffer.length() - 1] != &#39;0&#39;);</span>
<span class="line-modified">!   // Set the last digit to be non-zero. This is sufficient to guarantee</span>
<span class="line-modified">!   // correct rounding.</span>
<span class="line-modified">!   significant_buffer[kMaxSignificantDecimalDigits - 1] = &#39;1&#39;;</span>
<span class="line-modified">!   *significant_exponent =</span>
<span class="line-modified">!       exponent + (buffer.length() - kMaxSignificantDecimalDigits);</span>
  }
  
  
  // Trims the buffer and cuts it to at most kMaxSignificantDecimalDigits.
  // If possible the input-buffer is reused, but if the buffer needs to be
</pre>
<hr />
<pre>
<span class="line-old-header">*** 151,280 ***</span>
      *trimmed = BufferReference&lt;const char&gt;(buffer_copy_space,
                                   kMaxSignificantDecimalDigits);
    } else {
      *trimmed = right_trimmed;
      *updated_exponent = exponent;
<span class="line-modified">!     }</span>
  }
<span class="line-modified">!     </span>
  
  // Reads digits from the buffer and converts them to a uint64.
  // Reads in as many digits as fit into a uint64.
  // When the string starts with &quot;1844674407370955161&quot; no further digit is read.
  // Since 2^64 = 18446744073709551616 it would still be possible read another
  // digit if it was less or equal than 6, but this would complicate the code.
  static uint64_t ReadUint64(BufferReference&lt;const char&gt; buffer,
<span class="line-modified">!                                int* number_of_read_digits) {</span>
<span class="line-modified">!         uint64_t result = 0;</span>
<span class="line-modified">!         int i = 0;</span>
<span class="line-modified">!         while (i &lt; buffer.length() &amp;&amp; result &lt;= (kMaxUint64 / 10 - 1)) {</span>
<span class="line-modified">!             int digit = buffer[i++] - &#39;0&#39;;</span>
<span class="line-modified">!             ASSERT(0 &lt;= digit &amp;&amp; digit &lt;= 9);</span>
<span class="line-modified">!             result = 10 * result + digit;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         *number_of_read_digits = i;</span>
<span class="line-modified">!         return result;</span>
  }
<span class="line-modified">!     </span>
<span class="line-modified">!     </span>
  // Reads a DiyFp from the buffer.
  // The returned DiyFp is not necessarily normalized.
  // If remaining_decimals is zero then the returned DiyFp is accurate.
  // Otherwise it has been rounded and has error of at most 1/2 ulp.
  static void ReadDiyFp(BufferReference&lt;const char&gt; buffer,
<span class="line-modified">!                           DiyFp* result,</span>
<span class="line-modified">!                           int* remaining_decimals) {</span>
<span class="line-modified">!         int read_digits;</span>
<span class="line-modified">!         uint64_t significand = ReadUint64(buffer, &amp;read_digits);</span>
<span class="line-modified">!         if (buffer.length() == read_digits) {</span>
<span class="line-modified">!             *result = DiyFp(significand, 0);</span>
<span class="line-modified">!             *remaining_decimals = 0;</span>
<span class="line-modified">!         } else {</span>
<span class="line-modified">!             // Round the significand.</span>
<span class="line-modified">!             if (buffer[read_digits] &gt;= &#39;5&#39;) {</span>
<span class="line-modified">!                 significand++;</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!             // Compute the binary exponent.</span>
<span class="line-modified">!             int exponent = 0;</span>
<span class="line-modified">!             *result = DiyFp(significand, exponent);</span>
<span class="line-modified">!             *remaining_decimals = buffer.length() - read_digits;</span>
<span class="line-modified">!         }</span>
  }
<span class="line-modified">!     </span>
<span class="line-modified">!     </span>
  static bool DoubleStrtod(BufferReference&lt;const char&gt; trimmed,
<span class="line-modified">!                              int exponent,</span>
<span class="line-modified">!                              double* result) {</span>
  #if !defined(DOUBLE_CONVERSION_CORRECT_DOUBLE_OPERATIONS)
<span class="line-modified">!         UNUSED_PARAM(trimmed);</span>
<span class="line-modified">!         UNUSED_PARAM(exponent);</span>
<span class="line-modified">!         UNUSED_PARAM(result);</span>
<span class="line-modified">!         // On x86 the floating-point stack can be 64 or 80 bits wide. If it is</span>
<span class="line-modified">!         // 80 bits wide (as is the case on Linux) then double-rounding occurs and the</span>
<span class="line-modified">!         // result is not accurate.</span>
<span class="line-modified">!         // We know that Windows32 uses 64 bits and is therefore accurate.</span>
<span class="line-modified">!         // Note that the ARM simulator is compiled for 32bits. It therefore exhibits</span>
<span class="line-modified">!         // the same problem.</span>
<span class="line-modified">!         return false;</span>
  #else
<span class="line-modified">!         if (trimmed.length() &lt;= kMaxExactDoubleIntegerDecimalDigits) {</span>
<span class="line-modified">!             int read_digits;</span>
<span class="line-modified">!             // The trimmed input fits into a double.</span>
<span class="line-modified">!             // If the 10^exponent (resp. 10^-exponent) fits into a double too then we</span>
<span class="line-modified">!             // can compute the result-double simply by multiplying (resp. dividing) the</span>
<span class="line-modified">!             // two numbers.</span>
<span class="line-modified">!             // This is possible because IEEE guarantees that floating-point operations</span>
<span class="line-modified">!             // return the best possible approximation.</span>
<span class="line-modified">!             if (exponent &lt; 0 &amp;&amp; -exponent &lt; kExactPowersOfTenSize) {</span>
<span class="line-modified">!                 // 10^-exponent fits into a double.</span>
<span class="line-modified">!                 *result = static_cast&lt;double&gt;(ReadUint64(trimmed, &amp;read_digits));</span>
<span class="line-modified">!                 ASSERT(read_digits == trimmed.length());</span>
<span class="line-modified">!                 *result /= exact_powers_of_ten[-exponent];</span>
<span class="line-modified">!                 return true;</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!             if (0 &lt;= exponent &amp;&amp; exponent &lt; kExactPowersOfTenSize) {</span>
<span class="line-modified">!                 // 10^exponent fits into a double.</span>
<span class="line-modified">!                 *result = static_cast&lt;double&gt;(ReadUint64(trimmed, &amp;read_digits));</span>
<span class="line-modified">!                 ASSERT(read_digits == trimmed.length());</span>
<span class="line-modified">!                 *result *= exact_powers_of_ten[exponent];</span>
<span class="line-modified">!                 return true;</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!             int remaining_digits =</span>
<span class="line-modified">!             kMaxExactDoubleIntegerDecimalDigits - trimmed.length();</span>
<span class="line-modified">!             if ((0 &lt;= exponent) &amp;&amp;</span>
<span class="line-modified">!                 (exponent - remaining_digits &lt; kExactPowersOfTenSize)) {</span>
<span class="line-modified">!                 // The trimmed string was short and we can multiply it with</span>
<span class="line-modified">!                 // 10^remaining_digits. As a result the remaining exponent now fits</span>
<span class="line-modified">!                 // into a double too.</span>
<span class="line-modified">!                 *result = static_cast&lt;double&gt;(ReadUint64(trimmed, &amp;read_digits));</span>
<span class="line-modified">!                 ASSERT(read_digits == trimmed.length());</span>
<span class="line-modified">!                 *result *= exact_powers_of_ten[remaining_digits];</span>
<span class="line-modified">!                 *result *= exact_powers_of_ten[exponent - remaining_digits];</span>
<span class="line-modified">!                 return true;</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         return false;</span>
  #endif
  }
<span class="line-modified">!     </span>
<span class="line-modified">!     </span>
  // Returns 10^exponent as an exact DiyFp.
  // The given exponent must be in the range [1; kDecimalExponentDistance[.
  static DiyFp AdjustmentPowerOfTen(int exponent) {
<span class="line-modified">!         ASSERT(0 &lt; exponent);</span>
<span class="line-modified">!         ASSERT(exponent &lt; PowersOfTenCache::kDecimalExponentDistance);</span>
<span class="line-modified">!         // Simply hardcode the remaining powers for the given decimal exponent</span>
<span class="line-modified">!         // distance.</span>
<span class="line-modified">!         ASSERT(PowersOfTenCache::kDecimalExponentDistance == 8);</span>
<span class="line-modified">!         switch (exponent) {</span>
<span class="line-modified">!             case 1: return DiyFp(UINT64_2PART_C(0xa0000000, 00000000), -60);</span>
<span class="line-modified">!             case 2: return DiyFp(UINT64_2PART_C(0xc8000000, 00000000), -57);</span>
<span class="line-modified">!             case 3: return DiyFp(UINT64_2PART_C(0xfa000000, 00000000), -54);</span>
<span class="line-modified">!             case 4: return DiyFp(UINT64_2PART_C(0x9c400000, 00000000), -50);</span>
<span class="line-modified">!             case 5: return DiyFp(UINT64_2PART_C(0xc3500000, 00000000), -47);</span>
<span class="line-modified">!             case 6: return DiyFp(UINT64_2PART_C(0xf4240000, 00000000), -44);</span>
<span class="line-modified">!             case 7: return DiyFp(UINT64_2PART_C(0x98968000, 00000000), -40);</span>
<span class="line-modified">!             default:</span>
<span class="line-modified">!                 UNREACHABLE();</span>
<span class="line-modified">!     }</span>
  }
<span class="line-modified">!     </span>
<span class="line-modified">!     </span>
  // If the function returns true then the result is the correct double.
  // Otherwise it is either the correct double or the double that is just below
  // the correct double.
  static bool DiyFpStrtod(BufferReference&lt;const char&gt; buffer,
<span class="line-modified">!                             int exponent,</span>
<span class="line-modified">!                             double* result) {</span>
<span class="line-modified">!         DiyFp input;</span>
<span class="line-modified">!         int remaining_decimals;</span>
<span class="line-modified">!         ReadDiyFp(buffer, &amp;input, &amp;remaining_decimals);</span>
<span class="line-modified">!         // Since we may have dropped some digits the input is not accurate.</span>
<span class="line-modified">!         // If remaining_decimals is different than 0 than the error is at most</span>
<span class="line-modified">!         // .5 ulp (unit in the last place).</span>
<span class="line-modified">!         // We don&#39;t want to deal with fractions and therefore keep a common</span>
<span class="line-modified">!         // denominator.</span>
<span class="line-modified">!         const int kDenominatorLog = 3;</span>
<span class="line-modified">!         const int kDenominator = 1 &lt;&lt; kDenominatorLog;</span>
<span class="line-modified">!         // Move the remaining decimals into the exponent.</span>
<span class="line-modified">!         exponent += remaining_decimals;</span>
    uint64_t error = (remaining_decimals == 0 ? 0 : kDenominator / 2);
<span class="line-modified">!         </span>
<span class="line-modified">!         int old_e = input.e();</span>
<span class="line-modified">!         input.Normalize();</span>
<span class="line-modified">!         error &lt;&lt;= old_e - input.e();</span>
<span class="line-modified">!         </span>
<span class="line-modified">!         ASSERT(exponent &lt;= PowersOfTenCache::kMaxDecimalExponent);</span>
<span class="line-modified">!         if (exponent &lt; PowersOfTenCache::kMinDecimalExponent) {</span>
<span class="line-modified">!             *result = 0.0;</span>
<span class="line-modified">!             return true;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         DiyFp cached_power;</span>
<span class="line-modified">!         int cached_decimal_exponent;</span>
<span class="line-modified">!         PowersOfTenCache::GetCachedPowerForDecimalExponent(exponent,</span>
<span class="line-modified">!                                                            &amp;cached_power,</span>
<span class="line-modified">!                                                            &amp;cached_decimal_exponent);</span>
<span class="line-modified">!         </span>
<span class="line-modified">!         if (cached_decimal_exponent != exponent) {</span>
<span class="line-modified">!             int adjustment_exponent = exponent - cached_decimal_exponent;</span>
<span class="line-modified">!             DiyFp adjustment_power = AdjustmentPowerOfTen(adjustment_exponent);</span>
<span class="line-modified">!             input.Multiply(adjustment_power);</span>
<span class="line-modified">!             if (kMaxUint64DecimalDigits - buffer.length() &gt;= adjustment_exponent) {</span>
<span class="line-modified">!                 // The product of input with the adjustment power fits into a 64 bit</span>
<span class="line-modified">!                 // integer.</span>
<span class="line-modified">!                 ASSERT(DiyFp::kSignificandSize == 64);</span>
<span class="line-modified">!             } else {</span>
<span class="line-modified">!                 // The adjustment power is exact. There is hence only an error of 0.5.</span>
<span class="line-modified">!                 error += kDenominator / 2;</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         </span>
<span class="line-modified">!         input.Multiply(cached_power);</span>
<span class="line-modified">!         // The error introduced by a multiplication of a*b equals</span>
<span class="line-modified">!         //   error_a + error_b + error_a*error_b/2^64 + 0.5</span>
<span class="line-modified">!         // Substituting a with &#39;input&#39; and b with &#39;cached_power&#39; we have</span>
<span class="line-modified">!         //   error_b = 0.5  (all cached powers have an error of less than 0.5 ulp),</span>
<span class="line-modified">!         //   error_ab = 0 or 1 / kDenominator &gt; error_a*error_b/ 2^64</span>
<span class="line-modified">!         int error_b = kDenominator / 2;</span>
<span class="line-modified">!         int error_ab = (error == 0 ? 0 : 1);  // We round up to 1.</span>
<span class="line-modified">!         int fixed_error = kDenominator / 2;</span>
<span class="line-modified">!         error += error_b + error_ab + fixed_error;</span>
<span class="line-modified">!         </span>
<span class="line-modified">!         old_e = input.e();</span>
<span class="line-modified">!         input.Normalize();</span>
<span class="line-modified">!         error &lt;&lt;= old_e - input.e();</span>
<span class="line-modified">!         </span>
<span class="line-modified">!         // See if the double&#39;s significand changes if we add/subtract the error.</span>
<span class="line-modified">!         int order_of_magnitude = DiyFp::kSignificandSize + input.e();</span>
<span class="line-modified">!         int effective_significand_size =</span>
<span class="line-modified">!         Double::SignificandSizeForOrderOfMagnitude(order_of_magnitude);</span>
<span class="line-modified">!         int precision_digits_count =</span>
<span class="line-modified">!         DiyFp::kSignificandSize - effective_significand_size;</span>
<span class="line-modified">!         if (precision_digits_count + kDenominatorLog &gt;= DiyFp::kSignificandSize) {</span>
<span class="line-modified">!             // This can only happen for very small denormals. In this case the</span>
<span class="line-modified">!             // half-way multiplied by the denominator exceeds the range of an uint64.</span>
<span class="line-modified">!             // Simply shift everything to the right.</span>
<span class="line-modified">!             int shift_amount = (precision_digits_count + kDenominatorLog) -</span>
<span class="line-modified">!             DiyFp::kSignificandSize + 1;</span>
<span class="line-modified">!             input.set_f(input.f() &gt;&gt; shift_amount);</span>
<span class="line-modified">!             input.set_e(input.e() + shift_amount);</span>
<span class="line-modified">!             // We add 1 for the lost precision of error, and kDenominator for</span>
<span class="line-modified">!             // the lost precision of input.f().</span>
<span class="line-modified">!             error = (error &gt;&gt; shift_amount) + 1 + kDenominator;</span>
<span class="line-modified">!             precision_digits_count -= shift_amount;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         // We use uint64_ts now. This only works if the DiyFp uses uint64_ts too.</span>
<span class="line-modified">!         ASSERT(DiyFp::kSignificandSize == 64);</span>
<span class="line-modified">!         ASSERT(precision_digits_count &lt; 64);</span>
<span class="line-modified">!         uint64_t one64 = 1;</span>
<span class="line-modified">!         uint64_t precision_bits_mask = (one64 &lt;&lt; precision_digits_count) - 1;</span>
<span class="line-modified">!         uint64_t precision_bits = input.f() &amp; precision_bits_mask;</span>
<span class="line-modified">!         uint64_t half_way = one64 &lt;&lt; (precision_digits_count - 1);</span>
<span class="line-modified">!         precision_bits *= kDenominator;</span>
<span class="line-modified">!         half_way *= kDenominator;</span>
<span class="line-modified">!         DiyFp rounded_input(input.f() &gt;&gt; precision_digits_count,</span>
<span class="line-modified">!                             input.e() + precision_digits_count);</span>
<span class="line-modified">!         if (precision_bits &gt;= half_way + error) {</span>
<span class="line-modified">!             rounded_input.set_f(rounded_input.f() + 1);</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         // If the last_bits are too close to the half-way case than we are too</span>
<span class="line-modified">!         // inaccurate and round down. In this case we return false so that we can</span>
<span class="line-modified">!         // fall back to a more precise algorithm.</span>
<span class="line-modified">!         </span>
<span class="line-modified">!         *result = Double(rounded_input).value();</span>
<span class="line-modified">!         if (half_way - error &lt; precision_bits &amp;&amp; precision_bits &lt; half_way + error) {</span>
<span class="line-modified">!             // Too imprecise. The caller will have to fall back to a slower version.</span>
<span class="line-modified">!             // However the returned number is guaranteed to be either the correct</span>
<span class="line-modified">!             // double, or the next-lower double.</span>
<span class="line-modified">!             return false;</span>
<span class="line-modified">!         } else {</span>
<span class="line-modified">!             return true;</span>
<span class="line-modified">!         }</span>
  }
<span class="line-modified">!     </span>
<span class="line-modified">!     </span>
  // Returns
  //   - -1 if buffer*10^exponent &lt; diy_fp.
  //   -  0 if buffer*10^exponent == diy_fp.
  //   - +1 if buffer*10^exponent &gt; diy_fp.
  // Preconditions:
  //   buffer.length() + exponent &lt;= kMaxDecimalPower + 1
  //   buffer.length() + exponent &gt; kMinDecimalPower
  //   buffer.length() &lt;= kMaxDecimalSignificantDigits
  static int CompareBufferWithDiyFp(BufferReference&lt;const char&gt; buffer,
<span class="line-modified">!                                int exponent,</span>
                                    DiyFp diy_fp) {
<span class="line-modified">!         ASSERT(buffer.length() + exponent &lt;= kMaxDecimalPower + 1);</span>
<span class="line-modified">!         ASSERT(buffer.length() + exponent &gt; kMinDecimalPower);</span>
<span class="line-modified">!         ASSERT(buffer.length() &lt;= kMaxSignificantDecimalDigits);</span>
<span class="line-modified">!         // Make sure that the Bignum will be able to hold all our numbers.</span>
<span class="line-modified">!         // Our Bignum implementation has a separate field for exponents. Shifts will</span>
<span class="line-modified">!         // consume at most one bigit (&lt; 64 bits).</span>
<span class="line-modified">!         // ln(10) == 3.3219...</span>
<span class="line-modified">!         ASSERT(((kMaxDecimalPower + 1) * 333 / 100) &lt; Bignum::kMaxSignificantBits);</span>
    Bignum buffer_bignum;
    Bignum diy_fp_bignum;
    buffer_bignum.AssignDecimalString(buffer);
    diy_fp_bignum.AssignUInt64(diy_fp.f());
<span class="line-modified">!         if (exponent &gt;= 0) {</span>
      buffer_bignum.MultiplyByPowerOfTen(exponent);
<span class="line-modified">!         } else {</span>
      diy_fp_bignum.MultiplyByPowerOfTen(-exponent);
<span class="line-modified">!         }</span>
    if (diy_fp.e() &gt; 0) {
      diy_fp_bignum.ShiftLeft(diy_fp.e());
<span class="line-modified">!         } else {</span>
      buffer_bignum.ShiftLeft(-diy_fp.e());
    }
    return Bignum::Compare(buffer_bignum, diy_fp_bignum);
  }
  
<span class="line-new-header">--- 151,280 ---</span>
      *trimmed = BufferReference&lt;const char&gt;(buffer_copy_space,
                                   kMaxSignificantDecimalDigits);
    } else {
      *trimmed = right_trimmed;
      *updated_exponent = exponent;
<span class="line-modified">!   }</span>
  }
<span class="line-modified">! </span>
  
  // Reads digits from the buffer and converts them to a uint64.
  // Reads in as many digits as fit into a uint64.
  // When the string starts with &quot;1844674407370955161&quot; no further digit is read.
  // Since 2^64 = 18446744073709551616 it would still be possible read another
  // digit if it was less or equal than 6, but this would complicate the code.
  static uint64_t ReadUint64(BufferReference&lt;const char&gt; buffer,
<span class="line-modified">!                            int* number_of_read_digits) {</span>
<span class="line-modified">!   uint64_t result = 0;</span>
<span class="line-modified">!   int i = 0;</span>
<span class="line-modified">!   while (i &lt; buffer.length() &amp;&amp; result &lt;= (kMaxUint64 / 10 - 1)) {</span>
<span class="line-modified">!     int digit = buffer[i++] - &#39;0&#39;;</span>
<span class="line-modified">!     ASSERT(0 &lt;= digit &amp;&amp; digit &lt;= 9);</span>
<span class="line-modified">!     result = 10 * result + digit;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   *number_of_read_digits = i;</span>
<span class="line-modified">!   return result;</span>
  }
<span class="line-modified">! </span>
<span class="line-modified">! </span>
  // Reads a DiyFp from the buffer.
  // The returned DiyFp is not necessarily normalized.
  // If remaining_decimals is zero then the returned DiyFp is accurate.
  // Otherwise it has been rounded and has error of at most 1/2 ulp.
  static void ReadDiyFp(BufferReference&lt;const char&gt; buffer,
<span class="line-modified">!                       DiyFp* result,</span>
<span class="line-modified">!                       int* remaining_decimals) {</span>
<span class="line-modified">!   int read_digits;</span>
<span class="line-modified">!   uint64_t significand = ReadUint64(buffer, &amp;read_digits);</span>
<span class="line-modified">!   if (buffer.length() == read_digits) {</span>
<span class="line-modified">!     *result = DiyFp(significand, 0);</span>
<span class="line-modified">!     *remaining_decimals = 0;</span>
<span class="line-modified">!   } else {</span>
<span class="line-modified">!     // Round the significand.</span>
<span class="line-modified">!     if (buffer[read_digits] &gt;= &#39;5&#39;) {</span>
<span class="line-modified">!       significand++;</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!     // Compute the binary exponent.</span>
<span class="line-modified">!     int exponent = 0;</span>
<span class="line-modified">!     *result = DiyFp(significand, exponent);</span>
<span class="line-modified">!     *remaining_decimals = buffer.length() - read_digits;</span>
<span class="line-modified">!   }</span>
  }
<span class="line-modified">! </span>
<span class="line-modified">! </span>
  static bool DoubleStrtod(BufferReference&lt;const char&gt; trimmed,
<span class="line-modified">!                          int exponent,</span>
<span class="line-modified">!                          double* result) {</span>
  #if !defined(DOUBLE_CONVERSION_CORRECT_DOUBLE_OPERATIONS)
<span class="line-modified">!   UNUSED_PARAM(trimmed);</span>
<span class="line-modified">!   UNUSED_PARAM(exponent);</span>
<span class="line-modified">!   UNUSED_PARAM(result);</span>
<span class="line-modified">!   // On x86 the floating-point stack can be 64 or 80 bits wide. If it is</span>
<span class="line-modified">!   // 80 bits wide (as is the case on Linux) then double-rounding occurs and the</span>
<span class="line-modified">!   // result is not accurate.</span>
<span class="line-modified">!   // We know that Windows32 uses 64 bits and is therefore accurate.</span>
<span class="line-modified">!   // Note that the ARM simulator is compiled for 32bits. It therefore exhibits</span>
<span class="line-modified">!   // the same problem.</span>
<span class="line-modified">!   return false;</span>
  #else
<span class="line-modified">!   if (trimmed.length() &lt;= kMaxExactDoubleIntegerDecimalDigits) {</span>
<span class="line-modified">!     int read_digits;</span>
<span class="line-modified">!     // The trimmed input fits into a double.</span>
<span class="line-modified">!     // If the 10^exponent (resp. 10^-exponent) fits into a double too then we</span>
<span class="line-modified">!     // can compute the result-double simply by multiplying (resp. dividing) the</span>
<span class="line-modified">!     // two numbers.</span>
<span class="line-modified">!     // This is possible because IEEE guarantees that floating-point operations</span>
<span class="line-modified">!     // return the best possible approximation.</span>
<span class="line-modified">!     if (exponent &lt; 0 &amp;&amp; -exponent &lt; kExactPowersOfTenSize) {</span>
<span class="line-modified">!       // 10^-exponent fits into a double.</span>
<span class="line-modified">!       *result = static_cast&lt;double&gt;(ReadUint64(trimmed, &amp;read_digits));</span>
<span class="line-modified">!       ASSERT(read_digits == trimmed.length());</span>
<span class="line-modified">!       *result /= exact_powers_of_ten[-exponent];</span>
<span class="line-modified">!       return true;</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!     if (0 &lt;= exponent &amp;&amp; exponent &lt; kExactPowersOfTenSize) {</span>
<span class="line-modified">!       // 10^exponent fits into a double.</span>
<span class="line-modified">!       *result = static_cast&lt;double&gt;(ReadUint64(trimmed, &amp;read_digits));</span>
<span class="line-modified">!       ASSERT(read_digits == trimmed.length());</span>
<span class="line-modified">!       *result *= exact_powers_of_ten[exponent];</span>
<span class="line-modified">!       return true;</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!     int remaining_digits =</span>
<span class="line-modified">!         kMaxExactDoubleIntegerDecimalDigits - trimmed.length();</span>
<span class="line-modified">!     if ((0 &lt;= exponent) &amp;&amp;</span>
<span class="line-modified">!         (exponent - remaining_digits &lt; kExactPowersOfTenSize)) {</span>
<span class="line-modified">!       // The trimmed string was short and we can multiply it with</span>
<span class="line-modified">!       // 10^remaining_digits. As a result the remaining exponent now fits</span>
<span class="line-modified">!       // into a double too.</span>
<span class="line-modified">!       *result = static_cast&lt;double&gt;(ReadUint64(trimmed, &amp;read_digits));</span>
<span class="line-modified">!       ASSERT(read_digits == trimmed.length());</span>
<span class="line-modified">!       *result *= exact_powers_of_ten[remaining_digits];</span>
<span class="line-modified">!       *result *= exact_powers_of_ten[exponent - remaining_digits];</span>
<span class="line-modified">!       return true;</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   return false;</span>
  #endif
  }
<span class="line-modified">! </span>
<span class="line-modified">! </span>
  // Returns 10^exponent as an exact DiyFp.
  // The given exponent must be in the range [1; kDecimalExponentDistance[.
  static DiyFp AdjustmentPowerOfTen(int exponent) {
<span class="line-modified">!   ASSERT(0 &lt; exponent);</span>
<span class="line-modified">!   ASSERT(exponent &lt; PowersOfTenCache::kDecimalExponentDistance);</span>
<span class="line-modified">!   // Simply hardcode the remaining powers for the given decimal exponent</span>
<span class="line-modified">!   // distance.</span>
<span class="line-modified">!   ASSERT(PowersOfTenCache::kDecimalExponentDistance == 8);</span>
<span class="line-modified">!   switch (exponent) {</span>
<span class="line-modified">!     case 1: return DiyFp(UINT64_2PART_C(0xa0000000, 00000000), -60);</span>
<span class="line-modified">!     case 2: return DiyFp(UINT64_2PART_C(0xc8000000, 00000000), -57);</span>
<span class="line-modified">!     case 3: return DiyFp(UINT64_2PART_C(0xfa000000, 00000000), -54);</span>
<span class="line-modified">!     case 4: return DiyFp(UINT64_2PART_C(0x9c400000, 00000000), -50);</span>
<span class="line-modified">!     case 5: return DiyFp(UINT64_2PART_C(0xc3500000, 00000000), -47);</span>
<span class="line-modified">!     case 6: return DiyFp(UINT64_2PART_C(0xf4240000, 00000000), -44);</span>
<span class="line-modified">!     case 7: return DiyFp(UINT64_2PART_C(0x98968000, 00000000), -40);</span>
<span class="line-modified">!     default:</span>
<span class="line-modified">!       UNREACHABLE();</span>
<span class="line-modified">!   }</span>
  }
<span class="line-modified">! </span>
<span class="line-modified">! </span>
  // If the function returns true then the result is the correct double.
  // Otherwise it is either the correct double or the double that is just below
  // the correct double.
  static bool DiyFpStrtod(BufferReference&lt;const char&gt; buffer,
<span class="line-modified">!                         int exponent,</span>
<span class="line-modified">!                         double* result) {</span>
<span class="line-modified">!   DiyFp input;</span>
<span class="line-modified">!   int remaining_decimals;</span>
<span class="line-modified">!   ReadDiyFp(buffer, &amp;input, &amp;remaining_decimals);</span>
<span class="line-modified">!   // Since we may have dropped some digits the input is not accurate.</span>
<span class="line-modified">!   // If remaining_decimals is different than 0 than the error is at most</span>
<span class="line-modified">!   // .5 ulp (unit in the last place).</span>
<span class="line-modified">!   // We don&#39;t want to deal with fractions and therefore keep a common</span>
<span class="line-modified">!   // denominator.</span>
<span class="line-modified">!   const int kDenominatorLog = 3;</span>
<span class="line-modified">!   const int kDenominator = 1 &lt;&lt; kDenominatorLog;</span>
<span class="line-modified">!   // Move the remaining decimals into the exponent.</span>
<span class="line-modified">!   exponent += remaining_decimals;</span>
    uint64_t error = (remaining_decimals == 0 ? 0 : kDenominator / 2);
<span class="line-modified">! </span>
<span class="line-modified">!   int old_e = input.e();</span>
<span class="line-modified">!   input.Normalize();</span>
<span class="line-modified">!   error &lt;&lt;= old_e - input.e();</span>
<span class="line-modified">! </span>
<span class="line-modified">!   ASSERT(exponent &lt;= PowersOfTenCache::kMaxDecimalExponent);</span>
<span class="line-modified">!   if (exponent &lt; PowersOfTenCache::kMinDecimalExponent) {</span>
<span class="line-modified">!     *result = 0.0;</span>
<span class="line-modified">!     return true;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   DiyFp cached_power;</span>
<span class="line-modified">!   int cached_decimal_exponent;</span>
<span class="line-modified">!   PowersOfTenCache::GetCachedPowerForDecimalExponent(exponent,</span>
<span class="line-modified">!                                                      &amp;cached_power,</span>
<span class="line-modified">!                                                      &amp;cached_decimal_exponent);</span>
<span class="line-modified">! </span>
<span class="line-modified">!   if (cached_decimal_exponent != exponent) {</span>
<span class="line-modified">!     int adjustment_exponent = exponent - cached_decimal_exponent;</span>
<span class="line-modified">!     DiyFp adjustment_power = AdjustmentPowerOfTen(adjustment_exponent);</span>
<span class="line-modified">!     input.Multiply(adjustment_power);</span>
<span class="line-modified">!     if (kMaxUint64DecimalDigits - buffer.length() &gt;= adjustment_exponent) {</span>
<span class="line-modified">!       // The product of input with the adjustment power fits into a 64 bit</span>
<span class="line-modified">!       // integer.</span>
<span class="line-modified">!       ASSERT(DiyFp::kSignificandSize == 64);</span>
<span class="line-modified">!     } else {</span>
<span class="line-modified">!       // The adjustment power is exact. There is hence only an error of 0.5.</span>
<span class="line-modified">!       error += kDenominator / 2;</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   input.Multiply(cached_power);</span>
<span class="line-modified">!   // The error introduced by a multiplication of a*b equals</span>
<span class="line-modified">!   //   error_a + error_b + error_a*error_b/2^64 + 0.5</span>
<span class="line-modified">!   // Substituting a with &#39;input&#39; and b with &#39;cached_power&#39; we have</span>
<span class="line-modified">!   //   error_b = 0.5  (all cached powers have an error of less than 0.5 ulp),</span>
<span class="line-modified">!   //   error_ab = 0 or 1 / kDenominator &gt; error_a*error_b/ 2^64</span>
<span class="line-modified">!   int error_b = kDenominator / 2;</span>
<span class="line-modified">!   int error_ab = (error == 0 ? 0 : 1);  // We round up to 1.</span>
<span class="line-modified">!   int fixed_error = kDenominator / 2;</span>
<span class="line-modified">!   error += error_b + error_ab + fixed_error;</span>
<span class="line-modified">! </span>
<span class="line-modified">!   old_e = input.e();</span>
<span class="line-modified">!   input.Normalize();</span>
<span class="line-modified">!   error &lt;&lt;= old_e - input.e();</span>
<span class="line-modified">! </span>
<span class="line-modified">!   // See if the double&#39;s significand changes if we add/subtract the error.</span>
<span class="line-modified">!   int order_of_magnitude = DiyFp::kSignificandSize + input.e();</span>
<span class="line-modified">!   int effective_significand_size =</span>
<span class="line-modified">!       Double::SignificandSizeForOrderOfMagnitude(order_of_magnitude);</span>
<span class="line-modified">!   int precision_digits_count =</span>
<span class="line-modified">!       DiyFp::kSignificandSize - effective_significand_size;</span>
<span class="line-modified">!   if (precision_digits_count + kDenominatorLog &gt;= DiyFp::kSignificandSize) {</span>
<span class="line-modified">!     // This can only happen for very small denormals. In this case the</span>
<span class="line-modified">!     // half-way multiplied by the denominator exceeds the range of an uint64.</span>
<span class="line-modified">!     // Simply shift everything to the right.</span>
<span class="line-modified">!     int shift_amount = (precision_digits_count + kDenominatorLog) -</span>
<span class="line-modified">!         DiyFp::kSignificandSize + 1;</span>
<span class="line-modified">!     input.set_f(input.f() &gt;&gt; shift_amount);</span>
<span class="line-modified">!     input.set_e(input.e() + shift_amount);</span>
<span class="line-modified">!     // We add 1 for the lost precision of error, and kDenominator for</span>
<span class="line-modified">!     // the lost precision of input.f().</span>
<span class="line-modified">!     error = (error &gt;&gt; shift_amount) + 1 + kDenominator;</span>
<span class="line-modified">!     precision_digits_count -= shift_amount;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   // We use uint64_ts now. This only works if the DiyFp uses uint64_ts too.</span>
<span class="line-modified">!   ASSERT(DiyFp::kSignificandSize == 64);</span>
<span class="line-modified">!   ASSERT(precision_digits_count &lt; 64);</span>
<span class="line-modified">!   uint64_t one64 = 1;</span>
<span class="line-modified">!   uint64_t precision_bits_mask = (one64 &lt;&lt; precision_digits_count) - 1;</span>
<span class="line-modified">!   uint64_t precision_bits = input.f() &amp; precision_bits_mask;</span>
<span class="line-modified">!   uint64_t half_way = one64 &lt;&lt; (precision_digits_count - 1);</span>
<span class="line-modified">!   precision_bits *= kDenominator;</span>
<span class="line-modified">!   half_way *= kDenominator;</span>
<span class="line-modified">!   DiyFp rounded_input(input.f() &gt;&gt; precision_digits_count,</span>
<span class="line-modified">!                       input.e() + precision_digits_count);</span>
<span class="line-modified">!   if (precision_bits &gt;= half_way + error) {</span>
<span class="line-modified">!     rounded_input.set_f(rounded_input.f() + 1);</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   // If the last_bits are too close to the half-way case than we are too</span>
<span class="line-modified">!   // inaccurate and round down. In this case we return false so that we can</span>
<span class="line-modified">!   // fall back to a more precise algorithm.</span>
<span class="line-modified">! </span>
<span class="line-modified">!   *result = Double(rounded_input).value();</span>
<span class="line-modified">!   if (half_way - error &lt; precision_bits &amp;&amp; precision_bits &lt; half_way + error) {</span>
<span class="line-modified">!     // Too imprecise. The caller will have to fall back to a slower version.</span>
<span class="line-modified">!     // However the returned number is guaranteed to be either the correct</span>
<span class="line-modified">!     // double, or the next-lower double.</span>
<span class="line-modified">!     return false;</span>
<span class="line-modified">!   } else {</span>
<span class="line-modified">!     return true;</span>
<span class="line-modified">!   }</span>
  }
<span class="line-modified">! </span>
<span class="line-modified">! </span>
  // Returns
  //   - -1 if buffer*10^exponent &lt; diy_fp.
  //   -  0 if buffer*10^exponent == diy_fp.
  //   - +1 if buffer*10^exponent &gt; diy_fp.
  // Preconditions:
  //   buffer.length() + exponent &lt;= kMaxDecimalPower + 1
  //   buffer.length() + exponent &gt; kMinDecimalPower
  //   buffer.length() &lt;= kMaxDecimalSignificantDigits
  static int CompareBufferWithDiyFp(BufferReference&lt;const char&gt; buffer,
<span class="line-modified">!                                   int exponent,</span>
                                    DiyFp diy_fp) {
<span class="line-modified">!   ASSERT(buffer.length() + exponent &lt;= kMaxDecimalPower + 1);</span>
<span class="line-modified">!   ASSERT(buffer.length() + exponent &gt; kMinDecimalPower);</span>
<span class="line-modified">!   ASSERT(buffer.length() &lt;= kMaxSignificantDecimalDigits);</span>
<span class="line-modified">!   // Make sure that the Bignum will be able to hold all our numbers.</span>
<span class="line-modified">!   // Our Bignum implementation has a separate field for exponents. Shifts will</span>
<span class="line-modified">!   // consume at most one bigit (&lt; 64 bits).</span>
<span class="line-modified">!   // ln(10) == 3.3219...</span>
<span class="line-modified">!   ASSERT(((kMaxDecimalPower + 1) * 333 / 100) &lt; Bignum::kMaxSignificantBits);</span>
    Bignum buffer_bignum;
    Bignum diy_fp_bignum;
    buffer_bignum.AssignDecimalString(buffer);
    diy_fp_bignum.AssignUInt64(diy_fp.f());
<span class="line-modified">!   if (exponent &gt;= 0) {</span>
      buffer_bignum.MultiplyByPowerOfTen(exponent);
<span class="line-modified">!   } else {</span>
      diy_fp_bignum.MultiplyByPowerOfTen(-exponent);
<span class="line-modified">!   }</span>
    if (diy_fp.e() &gt; 0) {
      diy_fp_bignum.ShiftLeft(diy_fp.e());
<span class="line-modified">!   } else {</span>
      buffer_bignum.ShiftLeft(-diy_fp.e());
    }
    return Bignum::Compare(buffer_bignum, diy_fp_bignum);
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 434,11 ***</span>
  static bool ComputeGuess(BufferReference&lt;const char&gt; trimmed, int exponent,
                           double* guess) {
    if (trimmed.length() == 0) {
      *guess = 0.0;
      return true;
<span class="line-modified">!         }</span>
    if (exponent + trimmed.length() - 1 &gt;= kMaxDecimalPower) {
      *guess = Double::Infinity();
      return true;
    }
    if (exponent + trimmed.length() &lt;= kMinDecimalPower) {
<span class="line-new-header">--- 434,11 ---</span>
  static bool ComputeGuess(BufferReference&lt;const char&gt; trimmed, int exponent,
                           double* guess) {
    if (trimmed.length() == 0) {
      *guess = 0.0;
      return true;
<span class="line-modified">!   }</span>
    if (exponent + trimmed.length() - 1 &gt;= kMaxDecimalPower) {
      *guess = Double::Infinity();
      return true;
    }
    if (exponent + trimmed.length() &lt;= kMinDecimalPower) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 468,22 ***</span>
    bool is_correct = ComputeGuess(trimmed, exponent, &amp;guess);
    if (is_correct) return guess;
  
    DiyFp upper_boundary = Double(guess).UpperBoundary();
    int comparison = CompareBufferWithDiyFp(trimmed, exponent, upper_boundary);
<span class="line-modified">!         if (comparison &lt; 0) {</span>
<span class="line-modified">!             return guess;</span>
<span class="line-modified">!         } else if (comparison &gt; 0) {</span>
<span class="line-modified">!             return Double(guess).NextDouble();</span>
<span class="line-modified">!         } else if ((Double(guess).Significand() &amp; 1) == 0) {</span>
<span class="line-modified">!             // Round towards even.</span>
<span class="line-modified">!             return guess;</span>
<span class="line-modified">!         } else {</span>
<span class="line-modified">!             return Double(guess).NextDouble();</span>
<span class="line-modified">!         }</span>
  }
<span class="line-modified">!     </span>
  static float SanitizedDoubletof(double d) {
    ASSERT(d &gt;= 0.0);
    // ASAN has a sanitize check that disallows casting doubles to floats if
    // they are too big.
    // https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html#available-checks
<span class="line-new-header">--- 468,22 ---</span>
    bool is_correct = ComputeGuess(trimmed, exponent, &amp;guess);
    if (is_correct) return guess;
  
    DiyFp upper_boundary = Double(guess).UpperBoundary();
    int comparison = CompareBufferWithDiyFp(trimmed, exponent, upper_boundary);
<span class="line-modified">!   if (comparison &lt; 0) {</span>
<span class="line-modified">!     return guess;</span>
<span class="line-modified">!   } else if (comparison &gt; 0) {</span>
<span class="line-modified">!     return Double(guess).NextDouble();</span>
<span class="line-modified">!   } else if ((Double(guess).Significand() &amp; 1) == 0) {</span>
<span class="line-modified">!     // Round towards even.</span>
<span class="line-modified">!     return guess;</span>
<span class="line-modified">!   } else {</span>
<span class="line-modified">!     return Double(guess).NextDouble();</span>
<span class="line-modified">!   }</span>
  }
<span class="line-modified">! </span>
  static float SanitizedDoubletof(double d) {
    ASSERT(d &gt;= 0.0);
    // ASAN has a sanitize check that disallows casting doubles to floats if
    // they are too big.
    // https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html#available-checks
</pre>
<hr />
<pre>
<span class="line-old-header">*** 498,14 ***</span>
    if (d &gt;= max_finite) {
      if (d &gt;= half_max_finite_infinity) {
        return Single::Infinity();
      } else {
        return max_finite;
<span class="line-modified">!         }</span>
    } else {
      return static_cast&lt;float&gt;(d);
<span class="line-modified">!         }</span>
  }
  
  float Strtof(BufferReference&lt;const char&gt; buffer, int exponent) {
    char copy_buffer[kMaxSignificantDecimalDigits];
    BufferReference&lt;const char&gt; trimmed;
<span class="line-new-header">--- 498,14 ---</span>
    if (d &gt;= max_finite) {
      if (d &gt;= half_max_finite_infinity) {
        return Single::Infinity();
      } else {
        return max_finite;
<span class="line-modified">!     }</span>
    } else {
      return static_cast&lt;float&gt;(d);
<span class="line-modified">!   }</span>
  }
  
  float Strtof(BufferReference&lt;const char&gt; buffer, int exponent) {
    char copy_buffer[kMaxSignificantDecimalDigits];
    BufferReference&lt;const char&gt; trimmed;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 547,14 ***</span>
    if (is_correct) {
      f4 = f3;
    } else {
      double double_next2 = Double(double_next).NextDouble();
      f4 = SanitizedDoubletof(double_next2);
<span class="line-modified">!         }</span>
    (void) f2;  // Mark variable as used.
    ASSERT(f1 &lt;= f2 &amp;&amp; f2 &lt;= f3 &amp;&amp; f3 &lt;= f4);
<span class="line-modified">!         </span>
    // If the guess doesn&#39;t lie near a single-precision boundary we can simply
    // return its float-value.
    if (f1 == f4) {
      return float_guess;
    }
<span class="line-new-header">--- 547,14 ---</span>
    if (is_correct) {
      f4 = f3;
    } else {
      double double_next2 = Double(double_next).NextDouble();
      f4 = SanitizedDoubletof(double_next2);
<span class="line-modified">!   }</span>
    (void) f2;  // Mark variable as used.
    ASSERT(f1 &lt;= f2 &amp;&amp; f2 &lt;= f3 &amp;&amp; f3 &lt;= f4);
<span class="line-modified">! </span>
    // If the guess doesn&#39;t lie near a single-precision boundary we can simply
    // return its float-value.
    if (f1 == f4) {
      return float_guess;
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 571,21 ***</span>
    if (guess == 0.0f) {
      float min_float = 1e-45f;
      upper_boundary = Double(static_cast&lt;double&gt;(min_float) / 2).AsDiyFp();
    } else {
      upper_boundary = Single(guess).UpperBoundary();
<span class="line-modified">!         }</span>
    int comparison = CompareBufferWithDiyFp(trimmed, exponent, upper_boundary);
    if (comparison &lt; 0) {
      return guess;
    } else if (comparison &gt; 0) {
      return next;
    } else if ((Single(guess).Significand() &amp; 1) == 0) {
      // Round towards even.
      return guess;
    } else {
      return next;
<span class="line-modified">!     }</span>
  }
<span class="line-modified">!     </span>
  }  // namespace double_conversion
<span class="line-modified">! } // namespace WTF</span>
<span class="line-new-header">--- 571,21 ---</span>
    if (guess == 0.0f) {
      float min_float = 1e-45f;
      upper_boundary = Double(static_cast&lt;double&gt;(min_float) / 2).AsDiyFp();
    } else {
      upper_boundary = Single(guess).UpperBoundary();
<span class="line-modified">!   }</span>
    int comparison = CompareBufferWithDiyFp(trimmed, exponent, upper_boundary);
    if (comparison &lt; 0) {
      return guess;
    } else if (comparison &gt; 0) {
      return next;
    } else if ((Single(guess).Significand() &amp; 1) == 0) {
      // Round towards even.
      return guess;
    } else {
      return next;
<span class="line-modified">!   }</span>
  }
<span class="line-modified">! </span>
  }  // namespace double_conversion
<span class="line-modified">! }  // namespace WTF</span>
</pre>
<center><a href="fixed-dtoa.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="strtod.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>