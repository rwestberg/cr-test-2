<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/js/WebAssemblyModuleRecord.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WebAssemblyModuleConstructor.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="WebAssemblyRuntimeErrorConstructor.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/js/WebAssemblyModuleRecord.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 56     instance-&gt;finishCreation(exec, vm, moduleInformation);
 57     return instance;
 58 }
 59 
 60 WebAssemblyModuleRecord::WebAssemblyModuleRecord(VM&amp; vm, Structure* structure, const Identifier&amp; moduleKey)
 61     : Base(vm, structure, moduleKey)
 62 {
 63 }
 64 
 65 void WebAssemblyModuleRecord::destroy(JSCell* cell)
 66 {
 67     WebAssemblyModuleRecord* thisObject = static_cast&lt;WebAssemblyModuleRecord*&gt;(cell);
 68     thisObject-&gt;WebAssemblyModuleRecord::~WebAssemblyModuleRecord();
 69 }
 70 
 71 void WebAssemblyModuleRecord::finishCreation(ExecState* exec, VM&amp; vm, const Wasm::ModuleInformation&amp; moduleInformation)
 72 {
 73     Base::finishCreation(exec, vm);
 74     ASSERT(inherits(vm, info()));
 75     for (const auto&amp; exp : moduleInformation.exports) {
<span class="line-modified"> 76         Identifier field = Identifier::fromString(&amp;vm, String::fromUTF8(exp.field));</span>
 77         addExportEntry(ExportEntry::createLocal(field, field));
 78     }
 79 }
 80 
 81 void WebAssemblyModuleRecord::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
 82 {
 83     WebAssemblyModuleRecord* thisObject = jsCast&lt;WebAssemblyModuleRecord*&gt;(cell);

 84     Base::visitChildren(thisObject, visitor);
 85     visitor.append(thisObject-&gt;m_instance);
 86     visitor.append(thisObject-&gt;m_startFunction);
 87 }
 88 
 89 void WebAssemblyModuleRecord::prepareLink(VM&amp; vm, JSWebAssemblyInstance* instance)
 90 {
 91     RELEASE_ASSERT(!m_instance);
 92     m_instance.set(vm, this, instance);
 93 }
 94 
 95 void WebAssemblyModuleRecord::link(ExecState* exec, JSValue, JSObject* importObject, Wasm::CreationMode creationMode)
 96 {
 97     VM&amp; vm = exec-&gt;vm();
 98     auto scope = DECLARE_THROW_SCOPE(vm);
 99     UNUSED_PARAM(scope);
100     auto* globalObject = exec-&gt;lexicalGlobalObject();
101 
102     RELEASE_ASSERT(m_instance);
103 
104     Wasm::CodeBlock* codeBlock = m_instance-&gt;instance().codeBlock();
105     JSWebAssemblyModule* module = m_instance-&gt;module();
106     const Wasm::ModuleInformation&amp; moduleInformation = module-&gt;moduleInformation();
107 
108     auto exception = [&amp;] (JSObject* error) {
109         throwException(exec, scope, error);
110     };
111 
112     auto importFailMessage = [&amp;] (const Wasm::Import&amp; import, const char* before, const char* after) {
113         return makeString(before, &quot; &quot;, String::fromUTF8(import.module), &quot;:&quot;, String::fromUTF8(import.field), &quot; &quot;, after);
114     };
115 
<span class="line-removed">116     bool hasTableImport = false;</span>
<span class="line-removed">117 </span>
118     for (const auto&amp; import : moduleInformation.imports) {
119         // Validation and linking other than Wasm::ExternalKind::Function is already done in JSWebAssemblyInstance.
120         // Eventually we will move all the linking code in JSWebAssemblyInstance here and remove this switch statement.
121         switch (import.kind) {
122         case Wasm::ExternalKind::Function:
123         case Wasm::ExternalKind::Global:
124         case Wasm::ExternalKind::Table:
125             break;
126         case Wasm::ExternalKind::Memory:
127             continue;
128         }
129 
<span class="line-modified">130         Identifier moduleName = Identifier::fromString(&amp;vm, String::fromUTF8(import.module));</span>
<span class="line-modified">131         Identifier fieldName = Identifier::fromString(&amp;vm, String::fromUTF8(import.field));</span>
132         JSValue value;
133         if (creationMode == Wasm::CreationMode::FromJS) {
134             // 1. Let o be the resultant value of performing Get(importObject, i.module_name).
135             JSValue importModuleValue = importObject-&gt;get(exec, moduleName);
136             RETURN_IF_EXCEPTION(scope, void());
137             // 2. If Type(o) is not Object, throw a TypeError.
138             if (!importModuleValue.isObject())
139                 return exception(createTypeError(exec, importFailMessage(import, &quot;import&quot;, &quot;must be an object&quot;), defaultSourceAppender, runtimeTypeForValue(vm, importModuleValue)));
140 
141             // 3. Let v be the value of performing Get(o, i.item_name)
142             JSObject* object = jsCast&lt;JSObject*&gt;(importModuleValue);
143             value = object-&gt;get(exec, fieldName);
144             RETURN_IF_EXCEPTION(scope, void());
145         } else {
146             AbstractModuleRecord* importedModule = hostResolveImportedModule(exec, moduleName);
147             RETURN_IF_EXCEPTION(scope, void());
148             Resolution resolution = importedModule-&gt;resolveExport(exec, fieldName);
149             RETURN_IF_EXCEPTION(scope, void());
150             switch (resolution.type) {
151             case Resolution::Type::NotFound:
</pre>
<hr />
<pre>
218             // iii. Otherwise:
219             // a. Let closure be a new host function of the given signature which calls v by coercing WebAssembly arguments to JavaScript arguments via ToJSValue and returns the result, if any, by coercing via ToWebAssemblyValue.
220             // Note: done as part of Plan compilation.
221             // iv. Append v to funcs.
222             // Note: adding the JSCell to the instance list fulfills closure requirements b. above (the WebAssembly.Instance wil be kept alive) and v. below (the JSFunction).
223 
224             auto* info = m_instance-&gt;instance().importFunctionInfo(import.kindIndex);
225             info-&gt;targetInstance = calleeInstance;
226             info-&gt;wasmEntrypointLoadLocation = entrypointLoadLocation;
227             m_instance-&gt;instance().importFunction&lt;WriteBarrier&lt;JSObject&gt;&gt;(import.kindIndex)-&gt;set(vm, m_instance.get(), function);
228             break;
229         }
230 
231         case Wasm::ExternalKind::Global: {
232             // 5. If i is a global import:
233             // i. If i is not an immutable global, throw a TypeError.
234             ASSERT(moduleInformation.globals[import.kindIndex].mutability == Wasm::Global::Immutable);
235             // ii. If the global_type of i is i64 or Type(v) is not Number, throw a WebAssembly.LinkError.
236             if (moduleInformation.globals[import.kindIndex].type == Wasm::I64)
237                 return exception(createJSWebAssemblyLinkError(exec, vm, importFailMessage(import, &quot;imported global&quot;, &quot;cannot be an i64&quot;)));
<span class="line-modified">238             if (!value.isNumber())</span>
239                 return exception(createJSWebAssemblyLinkError(exec, vm, importFailMessage(import, &quot;imported global&quot;, &quot;must be a number&quot;)));
240             // iii. Append ToWebAssemblyValue(v) to imports.
241             switch (moduleInformation.globals[import.kindIndex].type) {








242             case Wasm::I32:
243                 m_instance-&gt;instance().setGlobal(import.kindIndex, value.toInt32(exec));
244                 break;
245             case Wasm::F32:
246                 m_instance-&gt;instance().setGlobal(import.kindIndex, bitwise_cast&lt;uint32_t&gt;(value.toFloat(exec)));
247                 break;
248             case Wasm::F64:
249                 m_instance-&gt;instance().setGlobal(import.kindIndex, bitwise_cast&lt;uint64_t&gt;(value.asNumber()));
250                 break;
251             default:
252                 RELEASE_ASSERT_NOT_REACHED();
253             }
254             scope.assertNoException();
255             break;
256         }
257 
258         case Wasm::ExternalKind::Table: {
<span class="line-removed">259             RELEASE_ASSERT(!hasTableImport); // This should be guaranteed by a validation failure.</span>
260             // 7. Otherwise (i is a table import):
<span class="line-removed">261             hasTableImport = true;</span>
262             JSWebAssemblyTable* table = jsDynamicCast&lt;JSWebAssemblyTable*&gt;(vm, value);
263             // i. If v is not a WebAssembly.Table object, throw a WebAssembly.LinkError.
264             if (!table)
265                 return exception(createJSWebAssemblyLinkError(exec, vm, importFailMessage(import, &quot;Table import&quot;, &quot;is not an instance of WebAssembly.Table&quot;)));
266 
<span class="line-modified">267             uint32_t expectedInitial = moduleInformation.tableInformation.initial();</span>
268             uint32_t actualInitial = table-&gt;length();
269             if (actualInitial &lt; expectedInitial)
270                 return exception(createJSWebAssemblyLinkError(exec, vm, importFailMessage(import, &quot;Table import&quot;, &quot;provided an &#39;initial&#39; that is too small&quot;)));
271 
<span class="line-modified">272             if (Optional&lt;uint32_t&gt; expectedMaximum = moduleInformation.tableInformation.maximum()) {</span>
273                 Optional&lt;uint32_t&gt; actualMaximum = table-&gt;maximum();
274                 if (!actualMaximum)
275                     return exception(createJSWebAssemblyLinkError(exec, vm, importFailMessage(import, &quot;Table import&quot;, &quot;does not have a &#39;maximum&#39; but the module requires that it does&quot;)));
276                 if (*actualMaximum &gt; *expectedMaximum)
277                     return exception(createJSWebAssemblyLinkError(exec, vm, importFailMessage(import, &quot;Imported Table&quot;, &quot;&#39;maximum&#39; is larger than the module&#39;s expected &#39;maximum&#39;&quot;)));
278             }
279 





280             // ii. Append v to tables.
281             // iii. Append v.[[Table]] to imports.
<span class="line-modified">282             m_instance-&gt;setTable(vm, table);</span>
283             RETURN_IF_EXCEPTION(scope, void());
284             break;
285         }
286 
287         case Wasm::ExternalKind::Memory:
288             break;
289         }
290     }
291 
<span class="line-modified">292     {</span>
<span class="line-modified">293         if (!!moduleInformation.tableInformation &amp;&amp; moduleInformation.tableInformation.isImport()) {</span>
294             // We should either have a Table import or we should have thrown an exception.
<span class="line-modified">295             RELEASE_ASSERT(hasTableImport);</span>
296         }
297 
<span class="line-modified">298         if (!!moduleInformation.tableInformation &amp;&amp; !hasTableImport) {</span>
<span class="line-modified">299             RELEASE_ASSERT(!moduleInformation.tableInformation.isImport());</span>
300             // We create a Table when it&#39;s a Table definition.
<span class="line-modified">301             RefPtr&lt;Wasm::Table&gt; wasmTable = Wasm::Table::tryCreate(moduleInformation.tableInformation.initial(), moduleInformation.tableInformation.maximum());</span>
302             if (!wasmTable)
303                 return exception(createJSWebAssemblyLinkError(exec, vm, &quot;couldn&#39;t create Table&quot;));
<span class="line-modified">304             JSWebAssemblyTable* table = JSWebAssemblyTable::create(exec, vm, globalObject-&gt;WebAssemblyTableStructure(), wasmTable.releaseNonNull());</span>
305             // We should always be able to allocate a JSWebAssemblyTable we&#39;ve defined.
306             // If it&#39;s defined to be too large, we should have thrown a validation error.
307             scope.assertNoException();
308             ASSERT(table);
<span class="line-modified">309             m_instance-&gt;setTable(vm, table);</span>
310             RETURN_IF_EXCEPTION(scope, void());
311         }
312     }
313 









































314     // Globals
315     {
316         for (size_t globalIndex = moduleInformation.firstInternalGlobal; globalIndex &lt; moduleInformation.globals.size(); ++globalIndex) {
317             const auto&amp; global = moduleInformation.globals[globalIndex];
318             ASSERT(global.initializationType != Wasm::Global::IsImport);
319             if (global.initializationType == Wasm::Global::FromGlobalImport) {
320                 ASSERT(global.initialBitsOrImportNumber &lt; moduleInformation.firstInternalGlobal);
321                 m_instance-&gt;instance().setGlobal(globalIndex, m_instance-&gt;instance().loadI64Global(global.initialBitsOrImportNumber));




322             } else
323                 m_instance-&gt;instance().setGlobal(globalIndex, global.initialBitsOrImportNumber);
324         }
325     }
326 
327     SymbolTable* exportSymbolTable = module-&gt;exportSymbolTable();
<span class="line-removed">328     unsigned functionImportCount = codeBlock-&gt;functionImportCount();</span>
329 
330     // Let exports be a list of (string, JS value) pairs that is mapped from each external value e in instance.exports as follows:
331     JSModuleEnvironment* moduleEnvironment = JSModuleEnvironment::create(vm, globalObject, nullptr, exportSymbolTable, JSValue(), this);
332     for (const auto&amp; exp : moduleInformation.exports) {
333         JSValue exportedValue;
334         switch (exp.kind) {
335         case Wasm::ExternalKind::Function: {
<span class="line-modified">336             // 1. If e is a closure c:</span>
<span class="line-modified">337             //   i. If there is an Exported Function Exotic Object func in funcs whose func.[[Closure]] equals c, then return func.</span>
<span class="line-modified">338             //   ii. (Note: At most one wrapper is created for any closure, so func is unique, even if there are multiple occurrances in the list. Moreover, if the item was an import that is already an Exported Function Exotic Object, then the original function object will be found. For imports that are regular JS functions, a new wrapper will be created.)</span>
<span class="line-removed">339             if (exp.kindIndex &lt; functionImportCount) {</span>
<span class="line-removed">340                 unsigned functionIndex = exp.kindIndex;</span>
<span class="line-removed">341                 JSObject* functionImport = m_instance-&gt;instance().importFunction&lt;WriteBarrier&lt;JSObject&gt;&gt;(functionIndex)-&gt;get();</span>
<span class="line-removed">342                 if (isWebAssemblyHostFunction(vm, functionImport))</span>
<span class="line-removed">343                     exportedValue = functionImport;</span>
<span class="line-removed">344                 else {</span>
<span class="line-removed">345                     Wasm::SignatureIndex signatureIndex = module-&gt;signatureIndexFromFunctionIndexSpace(functionIndex);</span>
<span class="line-removed">346                     exportedValue = WebAssemblyWrapperFunction::create(vm, globalObject, functionImport, functionIndex, m_instance.get(), signatureIndex);</span>
<span class="line-removed">347                 }</span>
<span class="line-removed">348             } else {</span>
<span class="line-removed">349                 //   iii. Otherwise:</span>
<span class="line-removed">350                 //     a. Let func be an Exported Function Exotic Object created from c.</span>
<span class="line-removed">351                 //     b. Append func to funcs.</span>
<span class="line-removed">352                 //     c. Return func.</span>
<span class="line-removed">353                 Wasm::Callee&amp; embedderEntrypointCallee = codeBlock-&gt;embedderEntrypointCalleeFromFunctionIndexSpace(exp.kindIndex);</span>
<span class="line-removed">354                 Wasm::WasmToWasmImportableFunction::LoadLocation entrypointLoadLocation = codeBlock-&gt;entrypointLoadLocationFromFunctionIndexSpace(exp.kindIndex);</span>
<span class="line-removed">355                 Wasm::SignatureIndex signatureIndex = module-&gt;signatureIndexFromFunctionIndexSpace(exp.kindIndex);</span>
<span class="line-removed">356                 const Wasm::Signature&amp; signature = Wasm::SignatureInformation::get(signatureIndex);</span>
<span class="line-removed">357                 WebAssemblyFunction* function = WebAssemblyFunction::create(vm, globalObject, signature.argumentCount(), String::fromUTF8(exp.field), m_instance.get(), embedderEntrypointCallee, entrypointLoadLocation, signatureIndex);</span>
<span class="line-removed">358                 exportedValue = function;</span>
<span class="line-removed">359             }</span>
360             break;
361         }
362         case Wasm::ExternalKind::Table: {
363             // This should be guaranteed by module verification.
<span class="line-modified">364             RELEASE_ASSERT(m_instance-&gt;table());</span>
<span class="line-modified">365             ASSERT(exp.kindIndex == 0);</span>
<span class="line-removed">366 </span>
<span class="line-removed">367             exportedValue = m_instance-&gt;table();</span>
368             break;
369         }
370         case Wasm::ExternalKind::Memory: {
371             ASSERT(exp.kindIndex == 0);
372 
373             exportedValue = m_instance-&gt;memory();
374             break;
375         }
376         case Wasm::ExternalKind::Global: {
377             // Assert: the global is immutable by MVP validation constraint.
378             const Wasm::Global&amp; global = moduleInformation.globals[exp.kindIndex];
379             ASSERT(global.mutability == Wasm::Global::Immutable);
380             // Return ToJSValue(v).
381             switch (global.type) {





382             case Wasm::I32:
383                 exportedValue = JSValue(m_instance-&gt;instance().loadI32Global(exp.kindIndex));
384                 break;
385 
386             case Wasm::I64:
387                 throwException(exec, scope, createJSWebAssemblyLinkError(exec, vm, &quot;exported global cannot be an i64&quot;_s));
388                 return;
389 
390             case Wasm::F32:
391                 exportedValue = jsNumber(purifyNaN(m_instance-&gt;instance().loadF32Global(exp.kindIndex)));
392                 break;
393 
394             case Wasm::F64:
395                 exportedValue = jsNumber(purifyNaN(m_instance-&gt;instance().loadF64Global(exp.kindIndex)));
396                 break;
397 
398             default:
399                 RELEASE_ASSERT_NOT_REACHED();
400             }
401             break;
402         }
403         }
404 
405         bool shouldThrowReadOnlyError = false;
406         bool ignoreReadOnlyErrors = true;
407         bool putResult = false;
<span class="line-modified">408         symbolTablePutTouchWatchpointSet(moduleEnvironment, exec, Identifier::fromString(&amp;vm, String::fromUTF8(exp.field)), exportedValue, shouldThrowReadOnlyError, ignoreReadOnlyErrors, putResult);</span>
409         scope.assertNoException();
410         RELEASE_ASSERT(putResult);
411     }
412 
413     bool hasStart = !!moduleInformation.startFunctionIndexSpace;
414     if (hasStart) {
415         auto startFunctionIndexSpace = moduleInformation.startFunctionIndexSpace.valueOr(0);
416         Wasm::SignatureIndex signatureIndex = module-&gt;signatureIndexFromFunctionIndexSpace(startFunctionIndexSpace);
417         const Wasm::Signature&amp; signature = Wasm::SignatureInformation::get(signatureIndex);
418         // The start function must not take any arguments or return anything. This is enforced by the parser.
419         ASSERT(!signature.argumentCount());
420         ASSERT(signature.returnType() == Wasm::Void);
421         if (startFunctionIndexSpace &lt; codeBlock-&gt;functionImportCount()) {
422             JSObject* startFunction = m_instance-&gt;instance().importFunction&lt;WriteBarrier&lt;JSObject&gt;&gt;(startFunctionIndexSpace)-&gt;get();
423             m_startFunction.set(vm, this, startFunction);
424         } else {
425             Wasm::Callee&amp; embedderEntrypointCallee = codeBlock-&gt;embedderEntrypointCalleeFromFunctionIndexSpace(startFunctionIndexSpace);
426             Wasm::WasmToWasmImportableFunction::LoadLocation entrypointLoadLocation = codeBlock-&gt;entrypointLoadLocationFromFunctionIndexSpace(startFunctionIndexSpace);
<span class="line-modified">427             WebAssemblyFunction* function = WebAssemblyFunction::create(vm, globalObject, signature.argumentCount(), &quot;start&quot;, m_instance.get(), embedderEntrypointCallee, entrypointLoadLocation, signatureIndex);</span>
428             m_startFunction.set(vm, this, function);
429         }
430     }
431     m_moduleEnvironment.set(vm, this, moduleEnvironment);
432 }
433 
434 template &lt;typename Scope, typename M, typename N, typename ...Args&gt;
435 NEVER_INLINE static JSValue dataSegmentFail(ExecState* exec, VM&amp; vm, Scope&amp; scope, M memorySize, N segmentSize, N offset, Args... args)
436 {
437     return throwException(exec, scope, createJSWebAssemblyLinkError(exec, vm, makeString(&quot;Invalid data segment initialization: segment of &quot;_s, String::number(segmentSize), &quot; bytes memory of &quot;_s, String::number(memorySize), &quot; bytes, at offset &quot;_s, String::number(offset), args...)));
438 }
439 
440 JSValue WebAssemblyModuleRecord::evaluate(ExecState* exec)
441 {
442     VM&amp; vm = exec-&gt;vm();
443     auto scope = DECLARE_THROW_SCOPE(vm);
444 
445     Wasm::Module&amp; module = m_instance-&gt;instance().module();
446     Wasm::CodeBlock* codeBlock = m_instance-&gt;instance().codeBlock();
447     const Wasm::ModuleInformation&amp; moduleInformation = module.moduleInformation();
<span class="line-removed">448     JSWebAssemblyTable* table = m_instance-&gt;table();</span>
449 
450     const Vector&lt;Wasm::Segment::Ptr&gt;&amp; data = moduleInformation.data;
451 
452     Optional&lt;JSValue&gt; exception;
453 
454     auto forEachElement = [&amp;] (auto fn) {
455         for (const Wasm::Element&amp; element : moduleInformation.elements) {
456             // It should be a validation error to have any elements without a table.
457             // Also, it could be that a table wasn&#39;t imported, or that the table
458             // imported wasn&#39;t compatible. However, those should error out before
459             // getting here.
<span class="line-modified">460             ASSERT(!!table);</span>
461 
462             if (!element.functionIndices.size())
463                 continue;
464 
<span class="line-modified">465             uint32_t tableIndex = element.offset.isGlobalImport()</span>
466                 ? static_cast&lt;uint32_t&gt;(m_instance-&gt;instance().loadI32Global(element.offset.globalImportIndex()))
467                 : element.offset.constValue();
468 
<span class="line-modified">469             fn(element, tableIndex);</span>
470 
471             if (exception)
472                 break;
473         }
474     };
475 
476     auto forEachSegment = [&amp;] (auto fn) {
477         uint8_t* memory = reinterpret_cast&lt;uint8_t*&gt;(m_instance-&gt;instance().cachedMemory());
478         uint64_t sizeInBytes = m_instance-&gt;instance().cachedMemorySize();
479 
480         for (const Wasm::Segment::Ptr&amp; segment : data) {
481             uint32_t offset = segment-&gt;offset.isGlobalImport()
482                 ? static_cast&lt;uint32_t&gt;(m_instance-&gt;instance().loadI32Global(segment-&gt;offset.globalImportIndex()))
483                 : segment-&gt;offset.constValue();
484 
485             fn(memory, sizeInBytes, segment, offset);
486 
487             if (exception)
488                 break;
489         }
490     };
491 
492     // Validation of all element ranges comes before all Table and Memory initialization.
<span class="line-modified">493     forEachElement([&amp;] (const Wasm::Element&amp; element, uint32_t tableIndex) {</span>
<span class="line-modified">494         uint64_t lastWrittenIndex = static_cast&lt;uint64_t&gt;(tableIndex) + static_cast&lt;uint64_t&gt;(element.functionIndices.size()) - 1;</span>
<span class="line-modified">495         if (UNLIKELY(lastWrittenIndex &gt;= table-&gt;length()))</span>
496             exception = JSValue(throwException(exec, scope, createJSWebAssemblyLinkError(exec, vm, &quot;Element is trying to set an out of bounds table index&quot;_s)));
497     });
498 
499     if (UNLIKELY(exception))
500         return exception.value();
501 
502     // Validation of all segment ranges comes before all Table and Memory initialization.
503     forEachSegment([&amp;] (uint8_t*, uint64_t sizeInBytes, const Wasm::Segment::Ptr&amp; segment, uint32_t offset) {
504         if (UNLIKELY(sizeInBytes &lt; segment-&gt;sizeInBytes))
505             exception = dataSegmentFail(exec, vm, scope, sizeInBytes, segment-&gt;sizeInBytes, offset, &quot;, segment is too big&quot;_s);
506         else if (UNLIKELY(offset &gt; sizeInBytes - segment-&gt;sizeInBytes))
507             exception = dataSegmentFail(exec, vm, scope, sizeInBytes, segment-&gt;sizeInBytes, offset, &quot;, segment writes outside of memory&quot;_s);
508     });
509 
510     if (UNLIKELY(exception))
511         return exception.value();
512 
513     JSGlobalObject* globalObject = m_instance-&gt;globalObject(vm);
<span class="line-modified">514     forEachElement([&amp;] (const Wasm::Element&amp; element, uint32_t tableIndex) {</span>
515         for (uint32_t i = 0; i &lt; element.functionIndices.size(); ++i) {
516             // FIXME: This essentially means we&#39;re exporting an import.
517             // We need a story here. We need to create a WebAssemblyFunction
518             // for the import.
519             // https://bugs.webkit.org/show_bug.cgi?id=165510
520             uint32_t functionIndex = element.functionIndices[i];
521             Wasm::SignatureIndex signatureIndex = module.signatureIndexFromFunctionIndexSpace(functionIndex);
522             if (functionIndex &lt; codeBlock-&gt;functionImportCount()) {
523                 JSObject* functionImport = m_instance-&gt;instance().importFunction&lt;WriteBarrier&lt;JSObject&gt;&gt;(functionIndex)-&gt;get();
524                 if (isWebAssemblyHostFunction(vm, functionImport)) {
525                     WebAssemblyFunction* wasmFunction = jsDynamicCast&lt;WebAssemblyFunction*&gt;(vm, functionImport);
526                     // If we ever import a WebAssemblyWrapperFunction, we set the import as the unwrapped value.
527                     // Because a WebAssemblyWrapperFunction can never wrap another WebAssemblyWrapperFunction,
528                     // the only type this could be is WebAssemblyFunction.
529                     RELEASE_ASSERT(wasmFunction);
<span class="line-modified">530                     table-&gt;setFunction(vm, tableIndex, wasmFunction);</span>
<span class="line-modified">531                     ++tableIndex;</span>
532                     continue;
533                 }
534 
<span class="line-modified">535                 table-&gt;setFunction(vm, tableIndex,</span>
<span class="line-modified">536                     WebAssemblyWrapperFunction::create(vm, globalObject, functionImport, functionIndex, m_instance.get(), signatureIndex));</span>
<span class="line-modified">537                 ++tableIndex;</span>
538                 continue;
539             }
540 
541             Wasm::Callee&amp; embedderEntrypointCallee = codeBlock-&gt;embedderEntrypointCalleeFromFunctionIndexSpace(functionIndex);
542             Wasm::WasmToWasmImportableFunction::LoadLocation entrypointLoadLocation = codeBlock-&gt;entrypointLoadLocationFromFunctionIndexSpace(functionIndex);
543             const Wasm::Signature&amp; signature = Wasm::SignatureInformation::get(signatureIndex);
544             // FIXME: Say we export local function &quot;foo&quot; at function index 0.
545             // What if we also set it to the table an Element w/ index 0.
546             // Does (new Instance(...)).exports.foo === table.get(0)?
547             // https://bugs.webkit.org/show_bug.cgi?id=165825
548             WebAssemblyFunction* function = WebAssemblyFunction::create(
<span class="line-modified">549                 vm, globalObject, signature.argumentCount(), String(), m_instance.get(), embedderEntrypointCallee, entrypointLoadLocation, signatureIndex);</span>
550 
<span class="line-modified">551             table-&gt;setFunction(vm, tableIndex, function);</span>
<span class="line-modified">552             ++tableIndex;</span>
553         }
554     });
555 
556     ASSERT(!exception);
557 
558     forEachSegment([&amp;] (uint8_t* memory, uint64_t, const Wasm::Segment::Ptr&amp; segment, uint32_t offset) {
559         // Empty segments are valid, but only if memory isn&#39;t present, which would be undefined behavior in memcpy.
560         if (segment-&gt;sizeInBytes) {
561             RELEASE_ASSERT(memory);
562             memcpy(memory + offset, &amp;segment-&gt;byte(0), segment-&gt;sizeInBytes);
563         }
564     });
565 
566     ASSERT(!exception);
567 
568     if (JSObject* startFunction = m_startFunction.get()) {
569         CallData callData;
570         CallType callType = JSC::getCallData(vm, startFunction, callData);
571         call(exec, startFunction, callType, callData, jsUndefined(), *vm.emptyList);
572         RETURN_IF_EXCEPTION(scope, { });
</pre>
</td>
<td>
<hr />
<pre>
 56     instance-&gt;finishCreation(exec, vm, moduleInformation);
 57     return instance;
 58 }
 59 
 60 WebAssemblyModuleRecord::WebAssemblyModuleRecord(VM&amp; vm, Structure* structure, const Identifier&amp; moduleKey)
 61     : Base(vm, structure, moduleKey)
 62 {
 63 }
 64 
 65 void WebAssemblyModuleRecord::destroy(JSCell* cell)
 66 {
 67     WebAssemblyModuleRecord* thisObject = static_cast&lt;WebAssemblyModuleRecord*&gt;(cell);
 68     thisObject-&gt;WebAssemblyModuleRecord::~WebAssemblyModuleRecord();
 69 }
 70 
 71 void WebAssemblyModuleRecord::finishCreation(ExecState* exec, VM&amp; vm, const Wasm::ModuleInformation&amp; moduleInformation)
 72 {
 73     Base::finishCreation(exec, vm);
 74     ASSERT(inherits(vm, info()));
 75     for (const auto&amp; exp : moduleInformation.exports) {
<span class="line-modified"> 76         Identifier field = Identifier::fromString(vm, String::fromUTF8(exp.field));</span>
 77         addExportEntry(ExportEntry::createLocal(field, field));
 78     }
 79 }
 80 
 81 void WebAssemblyModuleRecord::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
 82 {
 83     WebAssemblyModuleRecord* thisObject = jsCast&lt;WebAssemblyModuleRecord*&gt;(cell);
<span class="line-added"> 84     ASSERT_GC_OBJECT_INHERITS(thisObject, info());</span>
 85     Base::visitChildren(thisObject, visitor);
 86     visitor.append(thisObject-&gt;m_instance);
 87     visitor.append(thisObject-&gt;m_startFunction);
 88 }
 89 
 90 void WebAssemblyModuleRecord::prepareLink(VM&amp; vm, JSWebAssemblyInstance* instance)
 91 {
 92     RELEASE_ASSERT(!m_instance);
 93     m_instance.set(vm, this, instance);
 94 }
 95 
 96 void WebAssemblyModuleRecord::link(ExecState* exec, JSValue, JSObject* importObject, Wasm::CreationMode creationMode)
 97 {
 98     VM&amp; vm = exec-&gt;vm();
 99     auto scope = DECLARE_THROW_SCOPE(vm);
100     UNUSED_PARAM(scope);
101     auto* globalObject = exec-&gt;lexicalGlobalObject();
102 
103     RELEASE_ASSERT(m_instance);
104 
105     Wasm::CodeBlock* codeBlock = m_instance-&gt;instance().codeBlock();
106     JSWebAssemblyModule* module = m_instance-&gt;module();
107     const Wasm::ModuleInformation&amp; moduleInformation = module-&gt;moduleInformation();
108 
109     auto exception = [&amp;] (JSObject* error) {
110         throwException(exec, scope, error);
111     };
112 
113     auto importFailMessage = [&amp;] (const Wasm::Import&amp; import, const char* before, const char* after) {
114         return makeString(before, &quot; &quot;, String::fromUTF8(import.module), &quot;:&quot;, String::fromUTF8(import.field), &quot; &quot;, after);
115     };
116 


117     for (const auto&amp; import : moduleInformation.imports) {
118         // Validation and linking other than Wasm::ExternalKind::Function is already done in JSWebAssemblyInstance.
119         // Eventually we will move all the linking code in JSWebAssemblyInstance here and remove this switch statement.
120         switch (import.kind) {
121         case Wasm::ExternalKind::Function:
122         case Wasm::ExternalKind::Global:
123         case Wasm::ExternalKind::Table:
124             break;
125         case Wasm::ExternalKind::Memory:
126             continue;
127         }
128 
<span class="line-modified">129         Identifier moduleName = Identifier::fromString(vm, String::fromUTF8(import.module));</span>
<span class="line-modified">130         Identifier fieldName = Identifier::fromString(vm, String::fromUTF8(import.field));</span>
131         JSValue value;
132         if (creationMode == Wasm::CreationMode::FromJS) {
133             // 1. Let o be the resultant value of performing Get(importObject, i.module_name).
134             JSValue importModuleValue = importObject-&gt;get(exec, moduleName);
135             RETURN_IF_EXCEPTION(scope, void());
136             // 2. If Type(o) is not Object, throw a TypeError.
137             if (!importModuleValue.isObject())
138                 return exception(createTypeError(exec, importFailMessage(import, &quot;import&quot;, &quot;must be an object&quot;), defaultSourceAppender, runtimeTypeForValue(vm, importModuleValue)));
139 
140             // 3. Let v be the value of performing Get(o, i.item_name)
141             JSObject* object = jsCast&lt;JSObject*&gt;(importModuleValue);
142             value = object-&gt;get(exec, fieldName);
143             RETURN_IF_EXCEPTION(scope, void());
144         } else {
145             AbstractModuleRecord* importedModule = hostResolveImportedModule(exec, moduleName);
146             RETURN_IF_EXCEPTION(scope, void());
147             Resolution resolution = importedModule-&gt;resolveExport(exec, fieldName);
148             RETURN_IF_EXCEPTION(scope, void());
149             switch (resolution.type) {
150             case Resolution::Type::NotFound:
</pre>
<hr />
<pre>
217             // iii. Otherwise:
218             // a. Let closure be a new host function of the given signature which calls v by coercing WebAssembly arguments to JavaScript arguments via ToJSValue and returns the result, if any, by coercing via ToWebAssemblyValue.
219             // Note: done as part of Plan compilation.
220             // iv. Append v to funcs.
221             // Note: adding the JSCell to the instance list fulfills closure requirements b. above (the WebAssembly.Instance wil be kept alive) and v. below (the JSFunction).
222 
223             auto* info = m_instance-&gt;instance().importFunctionInfo(import.kindIndex);
224             info-&gt;targetInstance = calleeInstance;
225             info-&gt;wasmEntrypointLoadLocation = entrypointLoadLocation;
226             m_instance-&gt;instance().importFunction&lt;WriteBarrier&lt;JSObject&gt;&gt;(import.kindIndex)-&gt;set(vm, m_instance.get(), function);
227             break;
228         }
229 
230         case Wasm::ExternalKind::Global: {
231             // 5. If i is a global import:
232             // i. If i is not an immutable global, throw a TypeError.
233             ASSERT(moduleInformation.globals[import.kindIndex].mutability == Wasm::Global::Immutable);
234             // ii. If the global_type of i is i64 or Type(v) is not Number, throw a WebAssembly.LinkError.
235             if (moduleInformation.globals[import.kindIndex].type == Wasm::I64)
236                 return exception(createJSWebAssemblyLinkError(exec, vm, importFailMessage(import, &quot;imported global&quot;, &quot;cannot be an i64&quot;)));
<span class="line-modified">237             if (!isSubtype(moduleInformation.globals[import.kindIndex].type, Wasm::Anyref) &amp;&amp; !value.isNumber())</span>
238                 return exception(createJSWebAssemblyLinkError(exec, vm, importFailMessage(import, &quot;imported global&quot;, &quot;must be a number&quot;)));
239             // iii. Append ToWebAssemblyValue(v) to imports.
240             switch (moduleInformation.globals[import.kindIndex].type) {
<span class="line-added">241             case Wasm::Funcref:</span>
<span class="line-added">242                 if (!isWebAssemblyHostFunction(vm, value) &amp;&amp; !value.isNull())</span>
<span class="line-added">243                     return exception(createJSWebAssemblyLinkError(exec, vm, importFailMessage(import, &quot;imported global&quot;, &quot;must be a wasm exported function or null&quot;)));</span>
<span class="line-added">244                 m_instance-&gt;instance().setGlobal(import.kindIndex, value);</span>
<span class="line-added">245                 break;</span>
<span class="line-added">246             case Wasm::Anyref:</span>
<span class="line-added">247                 m_instance-&gt;instance().setGlobal(import.kindIndex, value);</span>
<span class="line-added">248                 break;</span>
249             case Wasm::I32:
250                 m_instance-&gt;instance().setGlobal(import.kindIndex, value.toInt32(exec));
251                 break;
252             case Wasm::F32:
253                 m_instance-&gt;instance().setGlobal(import.kindIndex, bitwise_cast&lt;uint32_t&gt;(value.toFloat(exec)));
254                 break;
255             case Wasm::F64:
256                 m_instance-&gt;instance().setGlobal(import.kindIndex, bitwise_cast&lt;uint64_t&gt;(value.asNumber()));
257                 break;
258             default:
259                 RELEASE_ASSERT_NOT_REACHED();
260             }
261             scope.assertNoException();
262             break;
263         }
264 
265         case Wasm::ExternalKind::Table: {

266             // 7. Otherwise (i is a table import):

267             JSWebAssemblyTable* table = jsDynamicCast&lt;JSWebAssemblyTable*&gt;(vm, value);
268             // i. If v is not a WebAssembly.Table object, throw a WebAssembly.LinkError.
269             if (!table)
270                 return exception(createJSWebAssemblyLinkError(exec, vm, importFailMessage(import, &quot;Table import&quot;, &quot;is not an instance of WebAssembly.Table&quot;)));
271 
<span class="line-modified">272             uint32_t expectedInitial = moduleInformation.tables[import.kindIndex].initial();</span>
273             uint32_t actualInitial = table-&gt;length();
274             if (actualInitial &lt; expectedInitial)
275                 return exception(createJSWebAssemblyLinkError(exec, vm, importFailMessage(import, &quot;Table import&quot;, &quot;provided an &#39;initial&#39; that is too small&quot;)));
276 
<span class="line-modified">277             if (Optional&lt;uint32_t&gt; expectedMaximum = moduleInformation.tables[import.kindIndex].maximum()) {</span>
278                 Optional&lt;uint32_t&gt; actualMaximum = table-&gt;maximum();
279                 if (!actualMaximum)
280                     return exception(createJSWebAssemblyLinkError(exec, vm, importFailMessage(import, &quot;Table import&quot;, &quot;does not have a &#39;maximum&#39; but the module requires that it does&quot;)));
281                 if (*actualMaximum &gt; *expectedMaximum)
282                     return exception(createJSWebAssemblyLinkError(exec, vm, importFailMessage(import, &quot;Imported Table&quot;, &quot;&#39;maximum&#39; is larger than the module&#39;s expected &#39;maximum&#39;&quot;)));
283             }
284 
<span class="line-added">285             auto expectedType = moduleInformation.tables[import.kindIndex].type();</span>
<span class="line-added">286             auto actualType = table-&gt;table()-&gt;type();</span>
<span class="line-added">287             if (expectedType != actualType)</span>
<span class="line-added">288                 return exception(createJSWebAssemblyLinkError(exec, vm, importFailMessage(import, &quot;Table import&quot;, &quot;provided a &#39;type&#39; that is wrong&quot;)));</span>
<span class="line-added">289 </span>
290             // ii. Append v to tables.
291             // iii. Append v.[[Table]] to imports.
<span class="line-modified">292             m_instance-&gt;setTable(vm, import.kindIndex, table);</span>
293             RETURN_IF_EXCEPTION(scope, void());
294             break;
295         }
296 
297         case Wasm::ExternalKind::Memory:
298             break;
299         }
300     }
301 
<span class="line-modified">302     for (unsigned i = 0; i &lt; moduleInformation.tableCount(); ++i) {</span>
<span class="line-modified">303         if (moduleInformation.tables[i].isImport()) {</span>
304             // We should either have a Table import or we should have thrown an exception.
<span class="line-modified">305             RELEASE_ASSERT(m_instance-&gt;table(i));</span>
306         }
307 
<span class="line-modified">308         if (!m_instance-&gt;table(i)) {</span>
<span class="line-modified">309             RELEASE_ASSERT(!moduleInformation.tables[i].isImport());</span>
310             // We create a Table when it&#39;s a Table definition.
<span class="line-modified">311             RefPtr&lt;Wasm::Table&gt; wasmTable = Wasm::Table::tryCreate(moduleInformation.tables[i].initial(), moduleInformation.tables[i].maximum(), moduleInformation.tables[i].type());</span>
312             if (!wasmTable)
313                 return exception(createJSWebAssemblyLinkError(exec, vm, &quot;couldn&#39;t create Table&quot;));
<span class="line-modified">314             JSWebAssemblyTable* table = JSWebAssemblyTable::create(exec, vm, globalObject-&gt;webAssemblyTableStructure(), wasmTable.releaseNonNull());</span>
315             // We should always be able to allocate a JSWebAssemblyTable we&#39;ve defined.
316             // If it&#39;s defined to be too large, we should have thrown a validation error.
317             scope.assertNoException();
318             ASSERT(table);
<span class="line-modified">319             m_instance-&gt;setTable(vm, i, table);</span>
320             RETURN_IF_EXCEPTION(scope, void());
321         }
322     }
323 
<span class="line-added">324     unsigned functionImportCount = codeBlock-&gt;functionImportCount();</span>
<span class="line-added">325     auto makeFunctionWrapper = [&amp;] (const String&amp; field, uint32_t index) -&gt; JSValue {</span>
<span class="line-added">326         // If we already made a wrapper, do not make a new one.</span>
<span class="line-added">327         JSValue wrapper = m_instance-&gt;instance().getFunctionWrapper(index);</span>
<span class="line-added">328 </span>
<span class="line-added">329         if (!wrapper.isNull())</span>
<span class="line-added">330             return wrapper;</span>
<span class="line-added">331 </span>
<span class="line-added">332         // 1. If e is a closure c:</span>
<span class="line-added">333         //   i. If there is an Exported Function Exotic Object func in funcs whose func.[[Closure]] equals c, then return func.</span>
<span class="line-added">334         //   ii. (Note: At most one wrapper is created for any closure, so func is unique, even if there are multiple occurrances in the list. Moreover, if the item was an import that is already an Exported Function Exotic Object, then the original function object will be found. For imports that are regular JS functions, a new wrapper will be created.)</span>
<span class="line-added">335         if (index &lt; functionImportCount) {</span>
<span class="line-added">336             JSObject* functionImport = m_instance-&gt;instance().importFunction&lt;WriteBarrier&lt;JSObject&gt;&gt;(index)-&gt;get();</span>
<span class="line-added">337             if (isWebAssemblyHostFunction(vm, functionImport))</span>
<span class="line-added">338                 wrapper = functionImport;</span>
<span class="line-added">339             else {</span>
<span class="line-added">340                 Wasm::SignatureIndex signatureIndex = module-&gt;signatureIndexFromFunctionIndexSpace(index);</span>
<span class="line-added">341                 wrapper = WebAssemblyWrapperFunction::create(vm, globalObject, globalObject-&gt;webAssemblyWrapperFunctionStructure(), functionImport, index, m_instance.get(), signatureIndex);</span>
<span class="line-added">342             }</span>
<span class="line-added">343         } else {</span>
<span class="line-added">344             //   iii. Otherwise:</span>
<span class="line-added">345             //     a. Let func be an Exported Function Exotic Object created from c.</span>
<span class="line-added">346             //     b. Append func to funcs.</span>
<span class="line-added">347             //     c. Return func.</span>
<span class="line-added">348             Wasm::Callee&amp; embedderEntrypointCallee = codeBlock-&gt;embedderEntrypointCalleeFromFunctionIndexSpace(index);</span>
<span class="line-added">349             Wasm::WasmToWasmImportableFunction::LoadLocation entrypointLoadLocation = codeBlock-&gt;entrypointLoadLocationFromFunctionIndexSpace(index);</span>
<span class="line-added">350             Wasm::SignatureIndex signatureIndex = module-&gt;signatureIndexFromFunctionIndexSpace(index);</span>
<span class="line-added">351             const Wasm::Signature&amp; signature = Wasm::SignatureInformation::get(signatureIndex);</span>
<span class="line-added">352             WebAssemblyFunction* function = WebAssemblyFunction::create(vm, globalObject, globalObject-&gt;webAssemblyFunctionStructure(), signature.argumentCount(), field, m_instance.get(), embedderEntrypointCallee, entrypointLoadLocation, signatureIndex);</span>
<span class="line-added">353             wrapper = function;</span>
<span class="line-added">354         }</span>
<span class="line-added">355 </span>
<span class="line-added">356         ASSERT(wrapper.isFunction(vm));</span>
<span class="line-added">357         m_instance-&gt;instance().setFunctionWrapper(index, wrapper);</span>
<span class="line-added">358 </span>
<span class="line-added">359         return wrapper;</span>
<span class="line-added">360     };</span>
<span class="line-added">361 </span>
<span class="line-added">362     for (auto index : moduleInformation.referencedFunctions())</span>
<span class="line-added">363         makeFunctionWrapper(&quot;Referenced function&quot;, index);</span>
<span class="line-added">364 </span>
365     // Globals
366     {
367         for (size_t globalIndex = moduleInformation.firstInternalGlobal; globalIndex &lt; moduleInformation.globals.size(); ++globalIndex) {
368             const auto&amp; global = moduleInformation.globals[globalIndex];
369             ASSERT(global.initializationType != Wasm::Global::IsImport);
370             if (global.initializationType == Wasm::Global::FromGlobalImport) {
371                 ASSERT(global.initialBitsOrImportNumber &lt; moduleInformation.firstInternalGlobal);
372                 m_instance-&gt;instance().setGlobal(globalIndex, m_instance-&gt;instance().loadI64Global(global.initialBitsOrImportNumber));
<span class="line-added">373             } else if (global.initializationType == Wasm::Global::FromRefFunc) {</span>
<span class="line-added">374                 ASSERT(global.initialBitsOrImportNumber &lt; moduleInformation.functionIndexSpaceSize());</span>
<span class="line-added">375                 ASSERT(makeFunctionWrapper(&quot;Global init expr&quot;, global.initialBitsOrImportNumber).isFunction(vm));</span>
<span class="line-added">376                 m_instance-&gt;instance().setGlobal(globalIndex, JSValue::encode(makeFunctionWrapper(&quot;Global init expr&quot;, global.initialBitsOrImportNumber)));</span>
377             } else
378                 m_instance-&gt;instance().setGlobal(globalIndex, global.initialBitsOrImportNumber);
379         }
380     }
381 
382     SymbolTable* exportSymbolTable = module-&gt;exportSymbolTable();

383 
384     // Let exports be a list of (string, JS value) pairs that is mapped from each external value e in instance.exports as follows:
385     JSModuleEnvironment* moduleEnvironment = JSModuleEnvironment::create(vm, globalObject, nullptr, exportSymbolTable, JSValue(), this);
386     for (const auto&amp; exp : moduleInformation.exports) {
387         JSValue exportedValue;
388         switch (exp.kind) {
389         case Wasm::ExternalKind::Function: {
<span class="line-modified">390             exportedValue = makeFunctionWrapper(String::fromUTF8(exp.field), exp.kindIndex);</span>
<span class="line-modified">391             ASSERT(exportedValue.isFunction(vm));</span>
<span class="line-modified">392             ASSERT(makeFunctionWrapper(String::fromUTF8(exp.field), exp.kindIndex) == exportedValue);</span>





















393             break;
394         }
395         case Wasm::ExternalKind::Table: {
396             // This should be guaranteed by module verification.
<span class="line-modified">397             RELEASE_ASSERT(m_instance-&gt;table(exp.kindIndex));</span>
<span class="line-modified">398             exportedValue = m_instance-&gt;table(exp.kindIndex);</span>


399             break;
400         }
401         case Wasm::ExternalKind::Memory: {
402             ASSERT(exp.kindIndex == 0);
403 
404             exportedValue = m_instance-&gt;memory();
405             break;
406         }
407         case Wasm::ExternalKind::Global: {
408             // Assert: the global is immutable by MVP validation constraint.
409             const Wasm::Global&amp; global = moduleInformation.globals[exp.kindIndex];
410             ASSERT(global.mutability == Wasm::Global::Immutable);
411             // Return ToJSValue(v).
412             switch (global.type) {
<span class="line-added">413             case Wasm::Anyref:</span>
<span class="line-added">414             case Wasm::Funcref:</span>
<span class="line-added">415                 exportedValue = JSValue::decode(m_instance-&gt;instance().loadI64Global(exp.kindIndex));</span>
<span class="line-added">416                 break;</span>
<span class="line-added">417 </span>
418             case Wasm::I32:
419                 exportedValue = JSValue(m_instance-&gt;instance().loadI32Global(exp.kindIndex));
420                 break;
421 
422             case Wasm::I64:
423                 throwException(exec, scope, createJSWebAssemblyLinkError(exec, vm, &quot;exported global cannot be an i64&quot;_s));
424                 return;
425 
426             case Wasm::F32:
427                 exportedValue = jsNumber(purifyNaN(m_instance-&gt;instance().loadF32Global(exp.kindIndex)));
428                 break;
429 
430             case Wasm::F64:
431                 exportedValue = jsNumber(purifyNaN(m_instance-&gt;instance().loadF64Global(exp.kindIndex)));
432                 break;
433 
434             default:
435                 RELEASE_ASSERT_NOT_REACHED();
436             }
437             break;
438         }
439         }
440 
441         bool shouldThrowReadOnlyError = false;
442         bool ignoreReadOnlyErrors = true;
443         bool putResult = false;
<span class="line-modified">444         symbolTablePutTouchWatchpointSet(moduleEnvironment, exec, Identifier::fromString(vm, String::fromUTF8(exp.field)), exportedValue, shouldThrowReadOnlyError, ignoreReadOnlyErrors, putResult);</span>
445         scope.assertNoException();
446         RELEASE_ASSERT(putResult);
447     }
448 
449     bool hasStart = !!moduleInformation.startFunctionIndexSpace;
450     if (hasStart) {
451         auto startFunctionIndexSpace = moduleInformation.startFunctionIndexSpace.valueOr(0);
452         Wasm::SignatureIndex signatureIndex = module-&gt;signatureIndexFromFunctionIndexSpace(startFunctionIndexSpace);
453         const Wasm::Signature&amp; signature = Wasm::SignatureInformation::get(signatureIndex);
454         // The start function must not take any arguments or return anything. This is enforced by the parser.
455         ASSERT(!signature.argumentCount());
456         ASSERT(signature.returnType() == Wasm::Void);
457         if (startFunctionIndexSpace &lt; codeBlock-&gt;functionImportCount()) {
458             JSObject* startFunction = m_instance-&gt;instance().importFunction&lt;WriteBarrier&lt;JSObject&gt;&gt;(startFunctionIndexSpace)-&gt;get();
459             m_startFunction.set(vm, this, startFunction);
460         } else {
461             Wasm::Callee&amp; embedderEntrypointCallee = codeBlock-&gt;embedderEntrypointCalleeFromFunctionIndexSpace(startFunctionIndexSpace);
462             Wasm::WasmToWasmImportableFunction::LoadLocation entrypointLoadLocation = codeBlock-&gt;entrypointLoadLocationFromFunctionIndexSpace(startFunctionIndexSpace);
<span class="line-modified">463             WebAssemblyFunction* function = WebAssemblyFunction::create(vm, globalObject, globalObject-&gt;webAssemblyFunctionStructure(), signature.argumentCount(), &quot;start&quot;, m_instance.get(), embedderEntrypointCallee, entrypointLoadLocation, signatureIndex);</span>
464             m_startFunction.set(vm, this, function);
465         }
466     }
467     m_moduleEnvironment.set(vm, this, moduleEnvironment);
468 }
469 
470 template &lt;typename Scope, typename M, typename N, typename ...Args&gt;
471 NEVER_INLINE static JSValue dataSegmentFail(ExecState* exec, VM&amp; vm, Scope&amp; scope, M memorySize, N segmentSize, N offset, Args... args)
472 {
473     return throwException(exec, scope, createJSWebAssemblyLinkError(exec, vm, makeString(&quot;Invalid data segment initialization: segment of &quot;_s, String::number(segmentSize), &quot; bytes memory of &quot;_s, String::number(memorySize), &quot; bytes, at offset &quot;_s, String::number(offset), args...)));
474 }
475 
476 JSValue WebAssemblyModuleRecord::evaluate(ExecState* exec)
477 {
478     VM&amp; vm = exec-&gt;vm();
479     auto scope = DECLARE_THROW_SCOPE(vm);
480 
481     Wasm::Module&amp; module = m_instance-&gt;instance().module();
482     Wasm::CodeBlock* codeBlock = m_instance-&gt;instance().codeBlock();
483     const Wasm::ModuleInformation&amp; moduleInformation = module.moduleInformation();

484 
485     const Vector&lt;Wasm::Segment::Ptr&gt;&amp; data = moduleInformation.data;
486 
487     Optional&lt;JSValue&gt; exception;
488 
489     auto forEachElement = [&amp;] (auto fn) {
490         for (const Wasm::Element&amp; element : moduleInformation.elements) {
491             // It should be a validation error to have any elements without a table.
492             // Also, it could be that a table wasn&#39;t imported, or that the table
493             // imported wasn&#39;t compatible. However, those should error out before
494             // getting here.
<span class="line-modified">495             ASSERT(!!m_instance-&gt;table(element.tableIndex));</span>
496 
497             if (!element.functionIndices.size())
498                 continue;
499 
<span class="line-modified">500             uint32_t elementIndex = element.offset.isGlobalImport()</span>
501                 ? static_cast&lt;uint32_t&gt;(m_instance-&gt;instance().loadI32Global(element.offset.globalImportIndex()))
502                 : element.offset.constValue();
503 
<span class="line-modified">504             fn(element, element.tableIndex, elementIndex);</span>
505 
506             if (exception)
507                 break;
508         }
509     };
510 
511     auto forEachSegment = [&amp;] (auto fn) {
512         uint8_t* memory = reinterpret_cast&lt;uint8_t*&gt;(m_instance-&gt;instance().cachedMemory());
513         uint64_t sizeInBytes = m_instance-&gt;instance().cachedMemorySize();
514 
515         for (const Wasm::Segment::Ptr&amp; segment : data) {
516             uint32_t offset = segment-&gt;offset.isGlobalImport()
517                 ? static_cast&lt;uint32_t&gt;(m_instance-&gt;instance().loadI32Global(segment-&gt;offset.globalImportIndex()))
518                 : segment-&gt;offset.constValue();
519 
520             fn(memory, sizeInBytes, segment, offset);
521 
522             if (exception)
523                 break;
524         }
525     };
526 
527     // Validation of all element ranges comes before all Table and Memory initialization.
<span class="line-modified">528     forEachElement([&amp;] (const Wasm::Element&amp; element, uint32_t tableIndex, uint32_t elementIndex) {</span>
<span class="line-modified">529         uint64_t lastWrittenIndex = static_cast&lt;uint64_t&gt;(elementIndex) + static_cast&lt;uint64_t&gt;(element.functionIndices.size()) - 1;</span>
<span class="line-modified">530         if (UNLIKELY(lastWrittenIndex &gt;= m_instance-&gt;table(tableIndex)-&gt;length()))</span>
531             exception = JSValue(throwException(exec, scope, createJSWebAssemblyLinkError(exec, vm, &quot;Element is trying to set an out of bounds table index&quot;_s)));
532     });
533 
534     if (UNLIKELY(exception))
535         return exception.value();
536 
537     // Validation of all segment ranges comes before all Table and Memory initialization.
538     forEachSegment([&amp;] (uint8_t*, uint64_t sizeInBytes, const Wasm::Segment::Ptr&amp; segment, uint32_t offset) {
539         if (UNLIKELY(sizeInBytes &lt; segment-&gt;sizeInBytes))
540             exception = dataSegmentFail(exec, vm, scope, sizeInBytes, segment-&gt;sizeInBytes, offset, &quot;, segment is too big&quot;_s);
541         else if (UNLIKELY(offset &gt; sizeInBytes - segment-&gt;sizeInBytes))
542             exception = dataSegmentFail(exec, vm, scope, sizeInBytes, segment-&gt;sizeInBytes, offset, &quot;, segment writes outside of memory&quot;_s);
543     });
544 
545     if (UNLIKELY(exception))
546         return exception.value();
547 
548     JSGlobalObject* globalObject = m_instance-&gt;globalObject(vm);
<span class="line-modified">549     forEachElement([&amp;] (const Wasm::Element&amp; element, uint32_t tableIndex, uint32_t elementIndex) {</span>
550         for (uint32_t i = 0; i &lt; element.functionIndices.size(); ++i) {
551             // FIXME: This essentially means we&#39;re exporting an import.
552             // We need a story here. We need to create a WebAssemblyFunction
553             // for the import.
554             // https://bugs.webkit.org/show_bug.cgi?id=165510
555             uint32_t functionIndex = element.functionIndices[i];
556             Wasm::SignatureIndex signatureIndex = module.signatureIndexFromFunctionIndexSpace(functionIndex);
557             if (functionIndex &lt; codeBlock-&gt;functionImportCount()) {
558                 JSObject* functionImport = m_instance-&gt;instance().importFunction&lt;WriteBarrier&lt;JSObject&gt;&gt;(functionIndex)-&gt;get();
559                 if (isWebAssemblyHostFunction(vm, functionImport)) {
560                     WebAssemblyFunction* wasmFunction = jsDynamicCast&lt;WebAssemblyFunction*&gt;(vm, functionImport);
561                     // If we ever import a WebAssemblyWrapperFunction, we set the import as the unwrapped value.
562                     // Because a WebAssemblyWrapperFunction can never wrap another WebAssemblyWrapperFunction,
563                     // the only type this could be is WebAssemblyFunction.
564                     RELEASE_ASSERT(wasmFunction);
<span class="line-modified">565                     m_instance-&gt;table(tableIndex)-&gt;set(elementIndex, wasmFunction);</span>
<span class="line-modified">566                     ++elementIndex;</span>
567                     continue;
568                 }
569 
<span class="line-modified">570                 m_instance-&gt;table(tableIndex)-&gt;set(elementIndex,</span>
<span class="line-modified">571                     WebAssemblyWrapperFunction::create(vm, globalObject, globalObject-&gt;webAssemblyWrapperFunctionStructure(), functionImport, functionIndex, m_instance.get(), signatureIndex));</span>
<span class="line-modified">572                 ++elementIndex;</span>
573                 continue;
574             }
575 
576             Wasm::Callee&amp; embedderEntrypointCallee = codeBlock-&gt;embedderEntrypointCalleeFromFunctionIndexSpace(functionIndex);
577             Wasm::WasmToWasmImportableFunction::LoadLocation entrypointLoadLocation = codeBlock-&gt;entrypointLoadLocationFromFunctionIndexSpace(functionIndex);
578             const Wasm::Signature&amp; signature = Wasm::SignatureInformation::get(signatureIndex);
579             // FIXME: Say we export local function &quot;foo&quot; at function index 0.
580             // What if we also set it to the table an Element w/ index 0.
581             // Does (new Instance(...)).exports.foo === table.get(0)?
582             // https://bugs.webkit.org/show_bug.cgi?id=165825
583             WebAssemblyFunction* function = WebAssemblyFunction::create(
<span class="line-modified">584                 vm, globalObject, globalObject-&gt;webAssemblyFunctionStructure(), signature.argumentCount(), String(), m_instance.get(), embedderEntrypointCallee, entrypointLoadLocation, signatureIndex);</span>
585 
<span class="line-modified">586             m_instance-&gt;table(tableIndex)-&gt;set(elementIndex, function);</span>
<span class="line-modified">587             ++elementIndex;</span>
588         }
589     });
590 
591     ASSERT(!exception);
592 
593     forEachSegment([&amp;] (uint8_t* memory, uint64_t, const Wasm::Segment::Ptr&amp; segment, uint32_t offset) {
594         // Empty segments are valid, but only if memory isn&#39;t present, which would be undefined behavior in memcpy.
595         if (segment-&gt;sizeInBytes) {
596             RELEASE_ASSERT(memory);
597             memcpy(memory + offset, &amp;segment-&gt;byte(0), segment-&gt;sizeInBytes);
598         }
599     });
600 
601     ASSERT(!exception);
602 
603     if (JSObject* startFunction = m_startFunction.get()) {
604         CallData callData;
605         CallType callType = JSC::getCallData(vm, startFunction, callData);
606         call(exec, startFunction, callType, callData, jsUndefined(), *vm.emptyList);
607         RETURN_IF_EXCEPTION(scope, { });
</pre>
</td>
</tr>
</table>
<center><a href="WebAssemblyModuleConstructor.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="WebAssemblyRuntimeErrorConstructor.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>