<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/parser/Parser.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Nodes.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Parser.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/parser/Parser.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 86,10 ***</span>
<span class="line-new-header">--- 86,12 ---</span>
  
  #define semanticFailureDueToKeyword(...) semanticFailureDueToKeywordCheckingToken(m_token, __VA_ARGS__);
  
  namespace JSC {
  
<span class="line-added">+ std::atomic&lt;unsigned&gt; globalParseCount { 0 };</span>
<span class="line-added">+ </span>
  ALWAYS_INLINE static SourceParseMode getAsynFunctionBodyParseMode(SourceParseMode parseMode)
  {
      if (isAsyncGeneratorWrapperParseMode(parseMode))
          return SourceParseMode::AsyncGeneratorBodyMode;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 122,11 ***</span>
      stream.print(std::forward&lt;Args&gt;(args)..., &quot;.&quot;);
      setErrorMessage(stream.toStringWithLatin1Fallback());
  }
  
  template &lt;typename LexerType&gt;
<span class="line-modified">! Parser&lt;LexerType&gt;::Parser(VM* vm, const SourceCode&amp; source, JSParserBuiltinMode builtinMode, JSParserStrictMode strictMode, JSParserScriptMode scriptMode, SourceParseMode parseMode, SuperBinding superBinding, ConstructorKind defaultConstructorKind, DerivedContextType derivedContextType, bool isEvalContext, EvalContextType evalContextType, DebuggerParseData* debuggerParseData)</span>
      : m_vm(vm)
      , m_source(&amp;source)
      , m_hasStackOverflow(false)
      , m_allowsIn(true)
      , m_statementDepth(0)
<span class="line-new-header">--- 124,11 ---</span>
      stream.print(std::forward&lt;Args&gt;(args)..., &quot;.&quot;);
      setErrorMessage(stream.toStringWithLatin1Fallback());
  }
  
  template &lt;typename LexerType&gt;
<span class="line-modified">! Parser&lt;LexerType&gt;::Parser(VM&amp; vm, const SourceCode&amp; source, JSParserBuiltinMode builtinMode, JSParserStrictMode strictMode, JSParserScriptMode scriptMode, SourceParseMode parseMode, SuperBinding superBinding, ConstructorKind defaultConstructorKind, DerivedContextType derivedContextType, bool isEvalContext, EvalContextType evalContextType, DebuggerParseData* debuggerParseData)</span>
      : m_vm(vm)
      , m_source(&amp;source)
      , m_hasStackOverflow(false)
      , m_allowsIn(true)
      , m_statementDepth(0)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 136,17 ***</span>
      , m_superBinding(superBinding)
      , m_defaultConstructorKind(defaultConstructorKind)
      , m_immediateParentAllowsFunctionDeclarationInStatement(false)
      , m_debuggerParseData(debuggerParseData)
  {
<span class="line-modified">!     m_lexer = std::make_unique&lt;LexerType&gt;(vm, builtinMode, scriptMode);</span>
      m_lexer-&gt;setCode(source, &amp;m_parserArena);
      m_token.m_location.line = source.firstLine().oneBasedInt();
      m_token.m_location.startOffset = source.startOffset();
      m_token.m_location.endOffset = source.startOffset();
      m_token.m_location.lineStartOffset = source.startOffset();
<span class="line-modified">!     m_functionCache = vm-&gt;addSourceProviderCache(source.provider());</span>
      m_expressionErrorClassifier = nullptr;
  
      ScopeRef scope = pushScope();
      scope-&gt;setSourceParseMode(parseMode);
      scope-&gt;setIsEvalContext(isEvalContext);
<span class="line-new-header">--- 138,17 ---</span>
      , m_superBinding(superBinding)
      , m_defaultConstructorKind(defaultConstructorKind)
      , m_immediateParentAllowsFunctionDeclarationInStatement(false)
      , m_debuggerParseData(debuggerParseData)
  {
<span class="line-modified">!     m_lexer = makeUnique&lt;LexerType&gt;(vm, builtinMode, scriptMode);</span>
      m_lexer-&gt;setCode(source, &amp;m_parserArena);
      m_token.m_location.line = source.firstLine().oneBasedInt();
      m_token.m_location.startOffset = source.startOffset();
      m_token.m_location.endOffset = source.startOffset();
      m_token.m_location.lineStartOffset = source.startOffset();
<span class="line-modified">!     m_functionCache = vm.addSourceProviderCache(source.provider());</span>
      m_expressionErrorClassifier = nullptr;
  
      ScopeRef scope = pushScope();
      scope-&gt;setSourceParseMode(parseMode);
      scope-&gt;setIsEvalContext(isEvalContext);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 171,14 ***</span>
          scope-&gt;setIsGlobalCodeScope();
  
      next();
  }
  
<span class="line-modified">! class Scope::MaybeParseAsGeneratorForScope : public SetForScope&lt;bool&gt; {</span>
  public:
      MaybeParseAsGeneratorForScope(ScopeRef&amp; scope, bool shouldParseAsGenerator)
<span class="line-modified">!         : SetForScope&lt;bool&gt;(scope-&gt;m_isGenerator, shouldParseAsGenerator) { }</span>
  };
  
  struct DepthManager : private SetForScope&lt;int&gt; {
  public:
      DepthManager(int* depth)
<span class="line-new-header">--- 173,27 ---</span>
          scope-&gt;setIsGlobalCodeScope();
  
      next();
  }
  
<span class="line-modified">! class Scope::MaybeParseAsGeneratorForScope {</span>
  public:
      MaybeParseAsGeneratorForScope(ScopeRef&amp; scope, bool shouldParseAsGenerator)
<span class="line-modified">!         : m_scope(scope)</span>
<span class="line-added">+         , m_oldValue(scope-&gt;m_isGenerator)</span>
<span class="line-added">+     {</span>
<span class="line-added">+         m_scope-&gt;m_isGenerator = shouldParseAsGenerator;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     ~MaybeParseAsGeneratorForScope()</span>
<span class="line-added">+     {</span>
<span class="line-added">+         m_scope-&gt;m_isGenerator = m_oldValue;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+ private:</span>
<span class="line-added">+     ScopeRef m_scope;</span>
<span class="line-added">+     bool m_oldValue;</span>
  };
  
  struct DepthManager : private SetForScope&lt;int&gt; {
  public:
      DepthManager(int* depth)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 195,11 ***</span>
  template &lt;typename LexerType&gt;
  String Parser&lt;LexerType&gt;::parseInner(const Identifier&amp; calleeName, SourceParseMode parseMode, ParsingContext parsingContext, Optional&lt;int&gt; functionConstructorParametersEndPosition)
  {
      String parseError = String();
  
<span class="line-modified">!     ASTBuilder context(const_cast&lt;VM*&gt;(m_vm), m_parserArena, const_cast&lt;SourceCode*&gt;(m_source));</span>
      ScopeRef scope = currentScope();
      scope-&gt;setIsLexicalScope();
      SetForScope&lt;FunctionParsePhase&gt; functionParsePhasePoisoner(m_parserState.functionParsePhase, FunctionParsePhase::Body);
  
      bool isArrowFunctionBodyExpression = parseMode == SourceParseMode::AsyncArrowFunctionBodyMode &amp;&amp; !match(OPENBRACE);
<span class="line-new-header">--- 210,11 ---</span>
  template &lt;typename LexerType&gt;
  String Parser&lt;LexerType&gt;::parseInner(const Identifier&amp; calleeName, SourceParseMode parseMode, ParsingContext parsingContext, Optional&lt;int&gt; functionConstructorParametersEndPosition)
  {
      String parseError = String();
  
<span class="line-modified">!     ASTBuilder context(const_cast&lt;VM&amp;&gt;(m_vm), m_parserArena, const_cast&lt;SourceCode*&gt;(m_source));</span>
      ScopeRef scope = currentScope();
      scope-&gt;setIsLexicalScope();
      SetForScope&lt;FunctionParsePhase&gt; functionParsePhasePoisoner(m_parserState.functionParsePhase, FunctionParsePhase::Body);
  
      bool isArrowFunctionBodyExpression = parseMode == SourceParseMode::AsyncArrowFunctionBodyMode &amp;&amp; !match(OPENBRACE);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 259,11 ***</span>
      VariableEnvironment&amp; varDeclarations = scope-&gt;declaredVariables();
      for (auto&amp; entry : capturedVariables)
          varDeclarations.markVariableAsCaptured(entry);
  
      if (isGeneratorWrapperParseMode(parseMode) || isAsyncFunctionOrAsyncGeneratorWrapperParseMode(parseMode)) {
<span class="line-modified">!         if (scope-&gt;usedVariablesContains(m_vm-&gt;propertyNames-&gt;arguments.impl()))</span>
              context.propagateArgumentsUse();
      }
  
      CodeFeatures features = context.features();
      if (scope-&gt;strictMode())
<span class="line-new-header">--- 274,11 ---</span>
      VariableEnvironment&amp; varDeclarations = scope-&gt;declaredVariables();
      for (auto&amp; entry : capturedVariables)
          varDeclarations.markVariableAsCaptured(entry);
  
      if (isGeneratorWrapperParseMode(parseMode) || isAsyncFunctionOrAsyncGeneratorWrapperParseMode(parseMode)) {
<span class="line-modified">!         if (scope-&gt;usedVariablesContains(m_vm.propertyNames-&gt;arguments.impl()))</span>
              context.propagateArgumentsUse();
      }
  
      CodeFeatures features = context.features();
      if (scope-&gt;strictMode())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 277,11 ***</span>
      if (m_parsingBuiltin &amp;&amp; isProgramParseMode(parseMode)) {
          VariableEnvironment&amp; lexicalVariables = scope-&gt;lexicalVariables();
          const HashSet&lt;UniquedStringImpl*&gt;&amp; closedVariableCandidates = scope-&gt;closedVariableCandidates();
          for (UniquedStringImpl* candidate : closedVariableCandidates) {
              // FIXME: We allow async to leak because it appearing as a closed variable is a side effect of trying to parse async arrow functions.
<span class="line-modified">!             if (!lexicalVariables.contains(candidate) &amp;&amp; !varDeclarations.contains(candidate) &amp;&amp; !candidate-&gt;isSymbol() &amp;&amp; candidate != m_vm-&gt;propertyNames-&gt;async.impl()) {</span>
                  dataLog(&quot;Bad global capture in builtin: &#39;&quot;, candidate, &quot;&#39;\n&quot;);
                  dataLog(m_source-&gt;view());
                  CRASH();
              }
          }
<span class="line-new-header">--- 292,11 ---</span>
      if (m_parsingBuiltin &amp;&amp; isProgramParseMode(parseMode)) {
          VariableEnvironment&amp; lexicalVariables = scope-&gt;lexicalVariables();
          const HashSet&lt;UniquedStringImpl*&gt;&amp; closedVariableCandidates = scope-&gt;closedVariableCandidates();
          for (UniquedStringImpl* candidate : closedVariableCandidates) {
              // FIXME: We allow async to leak because it appearing as a closed variable is a side effect of trying to parse async arrow functions.
<span class="line-modified">!             if (!lexicalVariables.contains(candidate) &amp;&amp; !varDeclarations.contains(candidate) &amp;&amp; !candidate-&gt;isSymbol() &amp;&amp; candidate != m_vm.propertyNames-&gt;async.impl()) {</span>
                  dataLog(&quot;Bad global capture in builtin: &#39;&quot;, candidate, &quot;&#39;\n&quot;);
                  dataLog(m_source-&gt;view());
                  CRASH();
              }
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 313,11 ***</span>
          bool isArrowFunction = false;
          if (match(CLOSEPAREN)) {
              next();
              isArrowFunction = match(ARROWFUNCTION);
          } else {
<span class="line-modified">!             SyntaxChecker syntaxChecker(const_cast&lt;VM*&gt;(m_vm), m_lexer.get());</span>
              // We make fake scope, otherwise parseFormalParameters will add variable to current scope that lead to errors
              AutoPopScopeRef fakeScope(this, pushScope());
              fakeScope-&gt;setSourceParseMode(SourceParseMode::ArrowFunctionMode);
  
              unsigned parametersCount = 0;
<span class="line-new-header">--- 328,11 ---</span>
          bool isArrowFunction = false;
          if (match(CLOSEPAREN)) {
              next();
              isArrowFunction = match(ARROWFUNCTION);
          } else {
<span class="line-modified">!             SyntaxChecker syntaxChecker(const_cast&lt;VM&amp;&gt;(m_vm), m_lexer.get());</span>
              // We make fake scope, otherwise parseFormalParameters will add variable to current scope that lead to errors
              AutoPopScopeRef fakeScope(this, pushScope());
              fakeScope-&gt;setSourceParseMode(SourceParseMode::ArrowFunctionMode);
  
              unsigned parametersCount = 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 360,23 ***</span>
  
      while (TreeStatement statement = parseStatementListItem(context, directive, &amp;directiveLiteralLength)) {
          if (shouldCheckForUseStrict) {
              if (directive) {
                  // &quot;use strict&quot; must be the exact literal without escape sequences or line continuation.
<span class="line-modified">!                 if (directiveLiteralLength == lengthOfUseStrictLiteral &amp;&amp; m_vm-&gt;propertyNames-&gt;useStrictIdentifier == *directive) {</span>
                      setStrictMode();
                      shouldCheckForUseStrict = false; // We saw &quot;use strict&quot;, there is no need to keep checking for it.
                      if (!isValidStrictMode()) {
                          if (m_parserState.lastFunctionName) {
<span class="line-modified">!                             if (m_vm-&gt;propertyNames-&gt;arguments == *m_parserState.lastFunctionName)</span>
                                  semanticFail(&quot;Cannot name a function &#39;arguments&#39; in strict mode&quot;);
<span class="line-modified">!                             if (m_vm-&gt;propertyNames-&gt;eval == *m_parserState.lastFunctionName)</span>
                                  semanticFail(&quot;Cannot name a function &#39;eval&#39; in strict mode&quot;);
                          }
<span class="line-modified">!                         if (hasDeclaredVariable(m_vm-&gt;propertyNames-&gt;arguments))</span>
                              semanticFail(&quot;Cannot declare a variable named &#39;arguments&#39; in strict mode&quot;);
<span class="line-modified">!                         if (hasDeclaredVariable(m_vm-&gt;propertyNames-&gt;eval))</span>
                              semanticFail(&quot;Cannot declare a variable named &#39;eval&#39; in strict mode&quot;);
                          semanticFailIfTrue(currentScope()-&gt;hasNonSimpleParameterList(), &quot;&#39;use strict&#39; directive not allowed inside a function with a non-simple parameter list&quot;);
                          semanticFailIfFalse(isValidStrictMode(), &quot;Invalid parameters or function name in strict mode&quot;);
                      }
                      // Since strict mode is changed, restoring lexer state by calling next() may cause errors.
<span class="line-new-header">--- 375,23 ---</span>
  
      while (TreeStatement statement = parseStatementListItem(context, directive, &amp;directiveLiteralLength)) {
          if (shouldCheckForUseStrict) {
              if (directive) {
                  // &quot;use strict&quot; must be the exact literal without escape sequences or line continuation.
<span class="line-modified">!                 if (directiveLiteralLength == lengthOfUseStrictLiteral &amp;&amp; m_vm.propertyNames-&gt;useStrictIdentifier == *directive) {</span>
                      setStrictMode();
                      shouldCheckForUseStrict = false; // We saw &quot;use strict&quot;, there is no need to keep checking for it.
                      if (!isValidStrictMode()) {
                          if (m_parserState.lastFunctionName) {
<span class="line-modified">!                             if (m_vm.propertyNames-&gt;arguments == *m_parserState.lastFunctionName)</span>
                                  semanticFail(&quot;Cannot name a function &#39;arguments&#39; in strict mode&quot;);
<span class="line-modified">!                             if (m_vm.propertyNames-&gt;eval == *m_parserState.lastFunctionName)</span>
                                  semanticFail(&quot;Cannot name a function &#39;eval&#39; in strict mode&quot;);
                          }
<span class="line-modified">!                         if (hasDeclaredVariable(m_vm.propertyNames-&gt;arguments))</span>
                              semanticFail(&quot;Cannot declare a variable named &#39;arguments&#39; in strict mode&quot;);
<span class="line-modified">!                         if (hasDeclaredVariable(m_vm.propertyNames-&gt;eval))</span>
                              semanticFail(&quot;Cannot declare a variable named &#39;eval&#39; in strict mode&quot;);
                          semanticFailIfTrue(currentScope()-&gt;hasNonSimpleParameterList(), &quot;&#39;use strict&#39; directive not allowed inside a function with a non-simple parameter list&quot;);
                          semanticFailIfFalse(isValidStrictMode(), &quot;Invalid parameters or function name in strict mode&quot;);
                      }
                      // Since strict mode is changed, restoring lexer state by calling next() may cause errors.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 404,11 ***</span>
  
  template &lt;typename LexerType&gt;
  template &lt;class TreeBuilder&gt; TreeSourceElements Parser&lt;LexerType&gt;::parseModuleSourceElements(TreeBuilder&amp; context, SourceParseMode parseMode)
  {
      TreeSourceElements sourceElements = context.createSourceElements();
<span class="line-modified">!     SyntaxChecker syntaxChecker(const_cast&lt;VM*&gt;(m_vm), m_lexer.get());</span>
  
      while (true) {
          TreeStatement statement = 0;
          switch (m_token.m_type) {
          case EXPORT:
<span class="line-new-header">--- 419,11 ---</span>
  
  template &lt;typename LexerType&gt;
  template &lt;class TreeBuilder&gt; TreeSourceElements Parser&lt;LexerType&gt;::parseModuleSourceElements(TreeBuilder&amp; context, SourceParseMode parseMode)
  {
      TreeSourceElements sourceElements = context.createSourceElements();
<span class="line-modified">!     SyntaxChecker syntaxChecker(const_cast&lt;VM&amp;&gt;(m_vm), m_lexer.get());</span>
  
      while (true) {
          TreeStatement statement = 0;
          switch (m_token.m_type) {
          case EXPORT:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 483,22 ***</span>
      unsigned startColumn = tokenColumn();
      int functionNameStart = m_token.m_location.startOffset;
      int parametersStart = m_token.m_location.startOffset;
  
      ParserFunctionInfo&lt;TreeBuilder&gt; info;
<span class="line-modified">!     info.name = &amp;m_vm-&gt;propertyNames-&gt;nullIdentifier;</span>
      createGeneratorParameters(context, info.parameterCount);
      info.startOffset = parametersStart;
      info.startLine = tokenLine();
  
      {
          AutoPopScopeRef generatorBodyScope(this, pushScope());
          generatorBodyScope-&gt;setSourceParseMode(SourceParseMode::GeneratorBodyMode);
          generatorBodyScope-&gt;setConstructorKind(ConstructorKind::None);
          generatorBodyScope-&gt;setExpectedSuperBinding(m_superBinding);
  
<span class="line-modified">!         SyntaxChecker generatorFunctionContext(const_cast&lt;VM*&gt;(m_vm), m_lexer.get());</span>
          failIfFalse(parseSourceElements(generatorFunctionContext, mode), &quot;Cannot parse the body of a generator&quot;);
          popScope(generatorBodyScope, TreeBuilder::NeedsFreeVariableInfo);
      }
      info.body = context.createFunctionMetadata(startLocation, tokenLocation(), startColumn, tokenColumn(), functionKeywordStart, functionNameStart, parametersStart, strictMode(), ConstructorKind::None, m_superBinding, info.parameterCount, SourceParseMode::GeneratorBodyMode, false);
  
<span class="line-new-header">--- 498,22 ---</span>
      unsigned startColumn = tokenColumn();
      int functionNameStart = m_token.m_location.startOffset;
      int parametersStart = m_token.m_location.startOffset;
  
      ParserFunctionInfo&lt;TreeBuilder&gt; info;
<span class="line-modified">!     info.name = &amp;m_vm.propertyNames-&gt;nullIdentifier;</span>
      createGeneratorParameters(context, info.parameterCount);
      info.startOffset = parametersStart;
      info.startLine = tokenLine();
  
      {
          AutoPopScopeRef generatorBodyScope(this, pushScope());
          generatorBodyScope-&gt;setSourceParseMode(SourceParseMode::GeneratorBodyMode);
          generatorBodyScope-&gt;setConstructorKind(ConstructorKind::None);
          generatorBodyScope-&gt;setExpectedSuperBinding(m_superBinding);
  
<span class="line-modified">!         SyntaxChecker generatorFunctionContext(const_cast&lt;VM&amp;&gt;(m_vm), m_lexer.get());</span>
          failIfFalse(parseSourceElements(generatorFunctionContext, mode), &quot;Cannot parse the body of a generator&quot;);
          popScope(generatorBodyScope, TreeBuilder::NeedsFreeVariableInfo);
      }
      info.body = context.createFunctionMetadata(startLocation, tokenLocation(), startColumn, tokenColumn(), functionKeywordStart, functionNameStart, parametersStart, strictMode(), ConstructorKind::None, m_superBinding, info.parameterCount, SourceParseMode::GeneratorBodyMode, false);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 525,21 ***</span>
      unsigned startColumn = tokenColumn();
      int functionNameStart = m_token.m_location.startOffset;
      int parametersStart = m_token.m_location.startOffset;
  
      ParserFunctionInfo&lt;TreeBuilder&gt; info;
<span class="line-modified">!     info.name = &amp;m_vm-&gt;propertyNames-&gt;nullIdentifier;</span>
      createGeneratorParameters(context, info.parameterCount);
      info.startOffset = parametersStart;
      info.startLine = tokenLine();
  
      SourceParseMode innerParseMode = getAsynFunctionBodyParseMode(parseMode);
  
      {
          AutoPopScopeRef asyncFunctionBodyScope(this, pushScope());
          asyncFunctionBodyScope-&gt;setSourceParseMode(innerParseMode);
<span class="line-modified">!         SyntaxChecker syntaxChecker(const_cast&lt;VM*&gt;(m_vm), m_lexer.get());</span>
          if (isArrowFunctionBodyExpression) {
              if (m_debuggerParseData)
                  failIfFalse(parseArrowFunctionSingleExpressionBodySourceElements(context), &quot;Cannot parse the body of async arrow function&quot;);
              else
                  failIfFalse(parseArrowFunctionSingleExpressionBodySourceElements(syntaxChecker), &quot;Cannot parse the body of async arrow function&quot;);
<span class="line-new-header">--- 540,21 ---</span>
      unsigned startColumn = tokenColumn();
      int functionNameStart = m_token.m_location.startOffset;
      int parametersStart = m_token.m_location.startOffset;
  
      ParserFunctionInfo&lt;TreeBuilder&gt; info;
<span class="line-modified">!     info.name = &amp;m_vm.propertyNames-&gt;nullIdentifier;</span>
      createGeneratorParameters(context, info.parameterCount);
      info.startOffset = parametersStart;
      info.startLine = tokenLine();
  
      SourceParseMode innerParseMode = getAsynFunctionBodyParseMode(parseMode);
  
      {
          AutoPopScopeRef asyncFunctionBodyScope(this, pushScope());
          asyncFunctionBodyScope-&gt;setSourceParseMode(innerParseMode);
<span class="line-modified">!         SyntaxChecker syntaxChecker(const_cast&lt;VM&amp;&gt;(m_vm), m_lexer.get());</span>
          if (isArrowFunctionBodyExpression) {
              if (m_debuggerParseData)
                  failIfFalse(parseArrowFunctionSingleExpressionBodySourceElements(context), &quot;Cannot parse the body of async arrow function&quot;);
              else
                  failIfFalse(parseArrowFunctionSingleExpressionBodySourceElements(syntaxChecker), &quot;Cannot parse the body of async arrow function&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 576,19 ***</span>
      unsigned startColumn = tokenColumn();
      int functionNameStart = m_token.m_location.startOffset;
      int parametersStart = m_token.m_location.startOffset;
  
      ParserFunctionInfo&lt;TreeBuilder&gt; info;
<span class="line-modified">!     info.name = &amp;m_vm-&gt;propertyNames-&gt;nullIdentifier;</span>
      createGeneratorParameters(context, info.parameterCount);
      info.startOffset = parametersStart;
      info.startLine = tokenLine();
      SourceParseMode innerParseMode = SourceParseMode::AsyncGeneratorBodyMode;
      {
          AutoPopScopeRef asyncFunctionBodyScope(this, pushScope());
          asyncFunctionBodyScope-&gt;setSourceParseMode(innerParseMode);
<span class="line-modified">!         SyntaxChecker syntaxChecker(const_cast&lt;VM*&gt;(m_vm), m_lexer.get());</span>
          if (isArrowFunctionBodyExpression) {
              if (m_debuggerParseData)
                  failIfFalse(parseArrowFunctionSingleExpressionBodySourceElements(context), &quot;Cannot parse the body of async arrow function&quot;);
              else
                  failIfFalse(parseArrowFunctionSingleExpressionBodySourceElements(syntaxChecker), &quot;Cannot parse the body of async arrow function&quot;);
<span class="line-new-header">--- 591,19 ---</span>
      unsigned startColumn = tokenColumn();
      int functionNameStart = m_token.m_location.startOffset;
      int parametersStart = m_token.m_location.startOffset;
  
      ParserFunctionInfo&lt;TreeBuilder&gt; info;
<span class="line-modified">!     info.name = &amp;m_vm.propertyNames-&gt;nullIdentifier;</span>
      createGeneratorParameters(context, info.parameterCount);
      info.startOffset = parametersStart;
      info.startLine = tokenLine();
      SourceParseMode innerParseMode = SourceParseMode::AsyncGeneratorBodyMode;
      {
          AutoPopScopeRef asyncFunctionBodyScope(this, pushScope());
          asyncFunctionBodyScope-&gt;setSourceParseMode(innerParseMode);
<span class="line-modified">!         SyntaxChecker syntaxChecker(const_cast&lt;VM&amp;&gt;(m_vm), m_lexer.get());</span>
          if (isArrowFunctionBodyExpression) {
              if (m_debuggerParseData)
                  failIfFalse(parseArrowFunctionSingleExpressionBodySourceElements(context), &quot;Cannot parse the body of async arrow function&quot;);
              else
                  failIfFalse(parseArrowFunctionSingleExpressionBodySourceElements(syntaxChecker), &quot;Cannot parse the body of async arrow function&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 621,11 ***</span>
      switch (m_token.m_type) {
      case FUNCTION:
          statement = parseFunctionDeclaration(context, ExportType::NotExported, DeclarationDefaultContext::Standard, functionConstructorParametersEndPosition);
          break;
      case IDENT:
<span class="line-modified">!         if (*m_token.m_data.ident == m_vm-&gt;propertyNames-&gt;async &amp;&amp; !m_token.m_data.escaped) {</span>
              next();
              failIfFalse(match(FUNCTION) &amp;&amp; !m_lexer-&gt;hasLineTerminatorBeforeToken(), &quot;Cannot parse the async function&quot;);
              statement = parseAsyncFunctionDeclaration(context, ExportType::NotExported, DeclarationDefaultContext::Standard, functionConstructorParametersEndPosition);
              break;
          }
<span class="line-new-header">--- 636,11 ---</span>
      switch (m_token.m_type) {
      case FUNCTION:
          statement = parseFunctionDeclaration(context, ExportType::NotExported, DeclarationDefaultContext::Standard, functionConstructorParametersEndPosition);
          break;
      case IDENT:
<span class="line-modified">!         if (*m_token.m_data.ident == m_vm.propertyNames-&gt;async &amp;&amp; !m_token.m_data.escaped) {</span>
              next();
              failIfFalse(match(FUNCTION) &amp;&amp; !m_lexer-&gt;hasLineTerminatorBeforeToken(), &quot;Cannot parse the async function&quot;);
              statement = parseAsyncFunctionDeclaration(context, ExportType::NotExported, DeclarationDefaultContext::Standard, functionConstructorParametersEndPosition);
              break;
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 650,10 ***</span>
<span class="line-new-header">--- 665,11 ---</span>
  {
      // The grammar is documented here:
      // http://www.ecma-international.org/ecma-262/6.0/index.html#sec-statements
      DepthManager statementDepth(&amp;m_statementDepth);
      m_statementDepth++;
<span class="line-added">+     failIfStackOverflow();</span>
      TreeStatement result = 0;
      bool shouldSetEndOffset = true;
      bool shouldSetPauseLocation = false;
  
      switch (m_token.m_type) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 689,11 ***</span>
          break;
      case FUNCTION:
          result = parseFunctionDeclaration(context);
          break;
      case IDENT:
<span class="line-modified">!         if (UNLIKELY(*m_token.m_data.ident == m_vm-&gt;propertyNames-&gt;async &amp;&amp; !m_token.m_data.escaped)) {</span>
              // Eagerly parse as AsyncFunctionDeclaration. This is the uncommon case,
              // but could be mistakenly parsed as an AsyncFunctionExpression.
              SavePoint savePoint = createSavePoint();
              next();
              if (UNLIKELY(match(FUNCTION) &amp;&amp; !m_lexer-&gt;hasLineTerminatorBeforeToken())) {
<span class="line-new-header">--- 705,11 ---</span>
          break;
      case FUNCTION:
          result = parseFunctionDeclaration(context);
          break;
      case IDENT:
<span class="line-modified">!         if (UNLIKELY(*m_token.m_data.ident == m_vm.propertyNames-&gt;async &amp;&amp; !m_token.m_data.escaped)) {</span>
              // Eagerly parse as AsyncFunctionDeclaration. This is the uncommon case,
              // but could be mistakenly parsed as an AsyncFunctionExpression.
              SavePoint savePoint = createSavePoint();
              next();
              if (UNLIKELY(match(FUNCTION) &amp;&amp; !m_lexer-&gt;hasLineTerminatorBeforeToken())) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 925,11 ***</span>
  template &lt;typename LexerType&gt;
  template &lt;class TreeBuilder&gt; TreeDestructuringPattern Parser&lt;LexerType&gt;::createBindingPattern(TreeBuilder&amp; context, DestructuringKind kind, ExportType exportType, const Identifier&amp; name, JSToken token, AssignmentContext bindingContext, const Identifier** duplicateIdentifier)
  {
      ASSERT(!name.isNull());
  
<span class="line-modified">!     ASSERT(name.impl()-&gt;isAtomic() || name.impl()-&gt;isSymbol());</span>
  
      switch (kind) {
      case DestructuringKind::DestructureToVariables: {
          DeclarationResultMask declarationResult = declareVariable(&amp;name);
          failIfTrueIfStrict(declarationResult &amp; DeclarationResult::InvalidStrictMode, &quot;Cannot declare a variable named &#39;&quot;, name.impl(), &quot;&#39; in strict mode&quot;);
<span class="line-new-header">--- 941,11 ---</span>
  template &lt;typename LexerType&gt;
  template &lt;class TreeBuilder&gt; TreeDestructuringPattern Parser&lt;LexerType&gt;::createBindingPattern(TreeBuilder&amp; context, DestructuringKind kind, ExportType exportType, const Identifier&amp; name, JSToken token, AssignmentContext bindingContext, const Identifier** duplicateIdentifier)
  {
      ASSERT(!name.isNull());
  
<span class="line-modified">!     ASSERT(name.impl()-&gt;isAtom() || name.impl()-&gt;isSymbol());</span>
  
      switch (kind) {
      case DestructuringKind::DestructureToVariables: {
          DeclarationResultMask declarationResult = declareVariable(&amp;name);
          failIfTrueIfStrict(declarationResult &amp; DeclarationResult::InvalidStrictMode, &quot;Cannot declare a variable named &#39;&quot;, name.impl(), &quot;&#39; in strict mode&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1022,11 ***</span>
          reclassifyExpressionError(ErrorIndicatesPattern, ErrorIndicatesNothing);
          semanticFail(&quot;Invalid destructuring assignment target&quot;);
      }
  
      if (strictMode() &amp;&amp; m_parserState.lastIdentifier &amp;&amp; context.isResolve(element)) {
<span class="line-modified">!         bool isEvalOrArguments = m_vm-&gt;propertyNames-&gt;eval == *m_parserState.lastIdentifier || m_vm-&gt;propertyNames-&gt;arguments == *m_parserState.lastIdentifier;</span>
          if (isEvalOrArguments &amp;&amp; strictMode())
              reclassifyExpressionError(ErrorIndicatesPattern, ErrorIndicatesNothing);
          failIfTrueIfStrict(isEvalOrArguments, &quot;Cannot modify &#39;&quot;, m_parserState.lastIdentifier-&gt;impl(), &quot;&#39; in strict mode&quot;);
      }
  
<span class="line-new-header">--- 1038,11 ---</span>
          reclassifyExpressionError(ErrorIndicatesPattern, ErrorIndicatesNothing);
          semanticFail(&quot;Invalid destructuring assignment target&quot;);
      }
  
      if (strictMode() &amp;&amp; m_parserState.lastIdentifier &amp;&amp; context.isResolve(element)) {
<span class="line-modified">!         bool isEvalOrArguments = m_vm.propertyNames-&gt;eval == *m_parserState.lastIdentifier || m_vm.propertyNames-&gt;arguments == *m_parserState.lastIdentifier;</span>
          if (isEvalOrArguments &amp;&amp; strictMode())
              reclassifyExpressionError(ErrorIndicatesPattern, ErrorIndicatesNothing);
          failIfTrueIfStrict(isEvalOrArguments, &quot;Cannot modify &#39;&quot;, m_parserState.lastIdentifier-&gt;impl(), &quot;&#39; in strict mode&quot;);
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1050,11 ***</span>
      auto element = parseMemberExpression(context);
  
      semanticFailIfFalse(element &amp;&amp; context.isAssignmentLocation(element), &quot;Invalid destructuring assignment target&quot;);
  
      if (strictMode() &amp;&amp; m_parserState.lastIdentifier &amp;&amp; context.isResolve(element)) {
<span class="line-modified">!         bool isEvalOrArguments = m_vm-&gt;propertyNames-&gt;eval == *m_parserState.lastIdentifier || m_vm-&gt;propertyNames-&gt;arguments == *m_parserState.lastIdentifier;</span>
          failIfTrueIfStrict(isEvalOrArguments, &quot;Cannot modify &#39;&quot;, m_parserState.lastIdentifier-&gt;impl(), &quot;&#39; in strict mode&quot;);
      }
  
      return createAssignmentElement(context, element, startPosition, lastTokenEndPosition());
  }
<span class="line-new-header">--- 1066,11 ---</span>
      auto element = parseMemberExpression(context);
  
      semanticFailIfFalse(element &amp;&amp; context.isAssignmentLocation(element), &quot;Invalid destructuring assignment target&quot;);
  
      if (strictMode() &amp;&amp; m_parserState.lastIdentifier &amp;&amp; context.isResolve(element)) {
<span class="line-modified">!         bool isEvalOrArguments = m_vm.propertyNames-&gt;eval == *m_parserState.lastIdentifier || m_vm.propertyNames-&gt;arguments == *m_parserState.lastIdentifier;</span>
          failIfTrueIfStrict(isEvalOrArguments, &quot;Cannot modify &#39;&quot;, m_parserState.lastIdentifier-&gt;impl(), &quot;&#39; in strict mode&quot;);
      }
  
      return createAssignmentElement(context, element, startPosition, lastTokenEndPosition());
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1178,11 ***</span>
                  next();
                  auto innerPattern = parseObjectRestBindingOrAssignmentElement(context, kind, exportType, duplicateIdentifier, bindingContext);
                  propagateError();
                  if (!innerPattern)
                      return 0;
<span class="line-modified">!                 context.appendObjectPatternRestEntry(*m_vm, objectPattern, location, innerPattern);</span>
                  restElementWasFound = true;
                  context.setContainsObjectRestElement(objectPattern, restElementWasFound);
                  break;
              }
  
<span class="line-new-header">--- 1194,11 ---</span>
                  next();
                  auto innerPattern = parseObjectRestBindingOrAssignmentElement(context, kind, exportType, duplicateIdentifier, bindingContext);
                  propagateError();
                  if (!innerPattern)
                      return 0;
<span class="line-modified">!                 context.appendObjectPatternRestEntry(m_vm, objectPattern, location, innerPattern);</span>
                  restElementWasFound = true;
                  context.setContainsObjectRestElement(objectPattern, restElementWasFound);
                  break;
              }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1197,11 ***</span>
                  next();
                  if (consume(COLON))
                      innerPattern = parseBindingOrAssignmentElement(context, kind, exportType, duplicateIdentifier, hasDestructuringPattern, bindingContext, depth + 1);
                  else {
                      if (kind == DestructuringKind::DestructureToExpressions) {
<span class="line-modified">!                         bool isEvalOrArguments = m_vm-&gt;propertyNames-&gt;eval == *propertyName || m_vm-&gt;propertyNames-&gt;arguments == *propertyName;</span>
                          if (isEvalOrArguments &amp;&amp; strictMode())
                              reclassifyExpressionError(ErrorIndicatesPattern, ErrorIndicatesNothing);
                          failIfTrueIfStrict(isEvalOrArguments, &quot;Cannot modify &#39;&quot;, propertyName-&gt;impl(), &quot;&#39; in strict mode&quot;);
                      }
                      semanticFailIfTrue(isDisallowedIdentifierAwait(identifierToken), &quot;Cannot use &#39;await&#39; as a &quot;, destructuringKindToVariableKindName(kind), &quot; &quot;, disallowedIdentifierAwaitReason());
<span class="line-new-header">--- 1213,11 ---</span>
                  next();
                  if (consume(COLON))
                      innerPattern = parseBindingOrAssignmentElement(context, kind, exportType, duplicateIdentifier, hasDestructuringPattern, bindingContext, depth + 1);
                  else {
                      if (kind == DestructuringKind::DestructureToExpressions) {
<span class="line-modified">!                         bool isEvalOrArguments = m_vm.propertyNames-&gt;eval == *propertyName || m_vm.propertyNames-&gt;arguments == *propertyName;</span>
                          if (isEvalOrArguments &amp;&amp; strictMode())
                              reclassifyExpressionError(ErrorIndicatesPattern, ErrorIndicatesNothing);
                          failIfTrueIfStrict(isEvalOrArguments, &quot;Cannot modify &#39;&quot;, propertyName-&gt;impl(), &quot;&#39; in strict mode&quot;);
                      }
                      semanticFailIfTrue(isDisallowedIdentifierAwait(identifierToken), &quot;Cannot use &#39;await&#39; as a &quot;, destructuringKindToVariableKindName(kind), &quot; &quot;, disallowedIdentifierAwaitReason());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1210,11 ***</span>
              } else {
                  JSTokenType tokenType = m_token.m_type;
                  switch (m_token.m_type) {
                  case DOUBLE:
                  case INTEGER:
<span class="line-modified">!                     propertyName = &amp;m_parserArena.identifierArena().makeNumericIdentifier(const_cast&lt;VM*&gt;(m_vm), m_token.m_data.doubleValue);</span>
                      break;
                  case STRING:
                      propertyName = m_token.m_data.ident;
                      wasString = true;
                      break;
<span class="line-new-header">--- 1226,11 ---</span>
              } else {
                  JSTokenType tokenType = m_token.m_type;
                  switch (m_token.m_type) {
                  case DOUBLE:
                  case INTEGER:
<span class="line-modified">!                     propertyName = &amp;m_parserArena.identifierArena().makeNumericIdentifier(const_cast&lt;VM&amp;&gt;(m_vm), m_token.m_data.doubleValue);</span>
                      break;
                  case STRING:
                      propertyName = m_token.m_data.ident;
                      wasString = true;
                      break;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1249,11 ***</span>
                  return 0;
              failIfFalse(innerPattern, &quot;Cannot parse this destructuring pattern&quot;);
              TreeExpression defaultValue = parseDefaultValueForDestructuringPattern(context);
              propagateError();
              if (propertyExpression) {
<span class="line-modified">!                 context.appendObjectPatternEntry(*m_vm, objectPattern, location, propertyExpression, innerPattern, defaultValue);</span>
                  context.setContainsComputedProperty(objectPattern, true);
              } else {
                  ASSERT(propertyName);
                  context.appendObjectPatternEntry(objectPattern, location, wasString, *propertyName, innerPattern, defaultValue);
              }
<span class="line-new-header">--- 1265,11 ---</span>
                  return 0;
              failIfFalse(innerPattern, &quot;Cannot parse this destructuring pattern&quot;);
              TreeExpression defaultValue = parseDefaultValueForDestructuringPattern(context);
              propagateError();
              if (propertyExpression) {
<span class="line-modified">!                 context.appendObjectPatternEntry(m_vm, objectPattern, location, propertyExpression, innerPattern, defaultValue);</span>
                  context.setContainsComputedProperty(objectPattern, true);
              } else {
                  ASSERT(propertyName);
                  context.appendObjectPatternEntry(objectPattern, location, wasString, *propertyName, innerPattern, defaultValue);
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1305,11 ***</span>
  
      DepthManager statementDepth(&amp;m_statementDepth);
      m_statementDepth++;
  
      if (match(AWAIT)) {
<span class="line-modified">!         semanticFailIfFalse(currentScope()-&gt;isAsyncFunction(), &quot;for-await-of can&#39;t be used only in async function or async generator.&quot;);</span>
          isAwaitFor = true;
          next();
      }
  
      handleProductionOrFail(OPENPAREN, &quot;(&quot;, &quot;start&quot;, &quot;for-loop header&quot;);
<span class="line-new-header">--- 1321,11 ---</span>
  
      DepthManager statementDepth(&amp;m_statementDepth);
      m_statementDepth++;
  
      if (match(AWAIT)) {
<span class="line-modified">!         semanticFailIfFalse(currentScope()-&gt;isAsyncFunction(), &quot;for-await-of can only be used in an async function or async generator&quot;);</span>
          isAwaitFor = true;
          next();
      }
  
      handleProductionOrFail(OPENPAREN, &quot;(&quot;, &quot;start&quot;, &quot;for-loop header&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1380,11 ***</span>
  
          // Handle for-in with var declaration
          JSTextPosition inLocation = tokenStartPosition();
          bool isOfEnumeration = false;
          if (!match(INTOKEN)) {
<span class="line-modified">!             failIfFalse(matchContextualKeyword(m_vm-&gt;propertyNames-&gt;of), &quot;Expected either &#39;in&#39; or &#39;of&#39; in enumeration syntax&quot;);</span>
              isOfEnumeration = true;
              next();
          } else {
              failIfFalse(!isAwaitFor, &quot;Expected &#39;of&#39; in for-await syntax&quot;);
              next();
<span class="line-new-header">--- 1396,11 ---</span>
  
          // Handle for-in with var declaration
          JSTextPosition inLocation = tokenStartPosition();
          bool isOfEnumeration = false;
          if (!match(INTOKEN)) {
<span class="line-modified">!             failIfFalse(matchContextualKeyword(m_vm.propertyNames-&gt;of), &quot;Expected either &#39;in&#39; or &#39;of&#39; in enumeration syntax&quot;);</span>
              isOfEnumeration = true;
              next();
          } else {
              failIfFalse(!isAwaitFor, &quot;Expected &#39;of&#39; in for-await syntax&quot;);
              next();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1430,11 ***</span>
          if (match(OPENBRACE) || match(OPENBRACKET)) {
              SavePoint savePoint = createSavePoint();
              declsStart = tokenStartPosition();
              pattern = tryParseDestructuringPatternExpression(context, AssignmentContext::DeclarationStatement);
              declsEnd = lastTokenEndPosition();
<span class="line-modified">!             if (pattern &amp;&amp; (match(INTOKEN) || matchContextualKeyword(m_vm-&gt;propertyNames-&gt;of)))</span>
                  goto enumerationLoop;
              pattern = TreeDestructuringPattern(0);
              restoreSavePoint(savePoint);
          }
          m_allowsIn = false;
<span class="line-new-header">--- 1446,11 ---</span>
          if (match(OPENBRACE) || match(OPENBRACKET)) {
              SavePoint savePoint = createSavePoint();
              declsStart = tokenStartPosition();
              pattern = tryParseDestructuringPatternExpression(context, AssignmentContext::DeclarationStatement);
              declsEnd = lastTokenEndPosition();
<span class="line-modified">!             if (pattern &amp;&amp; (match(INTOKEN) || matchContextualKeyword(m_vm.propertyNames-&gt;of)))</span>
                  goto enumerationLoop;
              pattern = TreeDestructuringPattern(0);
              restoreSavePoint(savePoint);
          }
          m_allowsIn = false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1485,11 ***</span>
      // For-in and For-of loop
  enumerationLoop:
      failIfFalse(nonLHSCount == m_parserState.nonLHSCount, &quot;Expected a reference on the left hand side of an enumeration statement&quot;);
      bool isOfEnumeration = false;
      if (!match(INTOKEN)) {
<span class="line-modified">!         failIfFalse(matchContextualKeyword(m_vm-&gt;propertyNames-&gt;of), &quot;Expected either &#39;in&#39; or &#39;of&#39; in enumeration syntax&quot;);</span>
          isOfEnumeration = true;
          next();
      } else {
          failIfFalse(!isAwaitFor, &quot;Expected &#39;of&#39; in for-await syntax&quot;);
          next();
<span class="line-new-header">--- 1501,11 ---</span>
      // For-in and For-of loop
  enumerationLoop:
      failIfFalse(nonLHSCount == m_parserState.nonLHSCount, &quot;Expected a reference on the left hand side of an enumeration statement&quot;);
      bool isOfEnumeration = false;
      if (!match(INTOKEN)) {
<span class="line-modified">!         failIfFalse(matchContextualKeyword(m_vm.propertyNames-&gt;of), &quot;Expected either &#39;in&#39; or &#39;of&#39; in enumeration syntax&quot;);</span>
          isOfEnumeration = true;
          next();
      } else {
          failIfFalse(!isAwaitFor, &quot;Expected &#39;of&#39; in for-await syntax&quot;);
          next();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1540,11 ***</span>
      JSTextPosition end = tokenEndPosition();
      next();
  
      if (autoSemiColon()) {
          semanticFailIfFalse(breakIsValid(), &quot;&#39;break&#39; is only valid inside a switch or loop statement&quot;);
<span class="line-modified">!         return context.createBreakStatement(location, &amp;m_vm-&gt;propertyNames-&gt;nullIdentifier, start, end);</span>
      }
      failIfFalse(matchSpecIdentifier(), &quot;Expected an identifier as the target for a break statement&quot;);
      const Identifier* ident = m_token.m_data.ident;
      semanticFailIfFalse(getLabel(ident), &quot;Cannot use the undeclared label &#39;&quot;, ident-&gt;impl(), &quot;&#39;&quot;);
      end = tokenEndPosition();
<span class="line-new-header">--- 1556,11 ---</span>
      JSTextPosition end = tokenEndPosition();
      next();
  
      if (autoSemiColon()) {
          semanticFailIfFalse(breakIsValid(), &quot;&#39;break&#39; is only valid inside a switch or loop statement&quot;);
<span class="line-modified">!         return context.createBreakStatement(location, &amp;m_vm.propertyNames-&gt;nullIdentifier, start, end);</span>
      }
      failIfFalse(matchSpecIdentifier(), &quot;Expected an identifier as the target for a break statement&quot;);
      const Identifier* ident = m_token.m_data.ident;
      semanticFailIfFalse(getLabel(ident), &quot;Cannot use the undeclared label &#39;&quot;, ident-&gt;impl(), &quot;&#39;&quot;);
      end = tokenEndPosition();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1562,11 ***</span>
      JSTextPosition end = tokenEndPosition();
      next();
  
      if (autoSemiColon()) {
          semanticFailIfFalse(continueIsValid(), &quot;&#39;continue&#39; is only valid inside a loop statement&quot;);
<span class="line-modified">!         return context.createContinueStatement(location, &amp;m_vm-&gt;propertyNames-&gt;nullIdentifier, start, end);</span>
      }
      failIfFalse(matchSpecIdentifier(), &quot;Expected an identifier as the target for a continue statement&quot;);
      const Identifier* ident = m_token.m_data.ident;
      ScopeLabelInfo* label = getLabel(ident);
      semanticFailIfFalse(label, &quot;Cannot use the undeclared label &#39;&quot;, ident-&gt;impl(), &quot;&#39;&quot;);
<span class="line-new-header">--- 1578,11 ---</span>
      JSTextPosition end = tokenEndPosition();
      next();
  
      if (autoSemiColon()) {
          semanticFailIfFalse(continueIsValid(), &quot;&#39;continue&#39; is only valid inside a loop statement&quot;);
<span class="line-modified">!         return context.createContinueStatement(location, &amp;m_vm.propertyNames-&gt;nullIdentifier, start, end);</span>
      }
      failIfFalse(matchSpecIdentifier(), &quot;Expected an identifier as the target for a continue statement&quot;);
      const Identifier* ident = m_token.m_data.ident;
      ScopeLabelInfo* label = getLabel(ident);
      semanticFailIfFalse(label, &quot;Cannot use the undeclared label &#39;&quot;, ident-&gt;impl(), &quot;&#39;&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1932,11 ***</span>
          if (!strictMode())
              goto identcase;
          goto defaultCase;
      }
      case IDENT:
<span class="line-modified">!         if (UNLIKELY(*m_token.m_data.ident == m_vm-&gt;propertyNames-&gt;async &amp;&amp; !m_token.m_data.escaped)) {</span>
              if (maybeParseAsyncFunctionDeclarationStatement(context, result, parentAllowsFunctionDeclarationAsStatement))
                  break;
          }
          FALLTHROUGH;
      case AWAIT:
<span class="line-new-header">--- 1948,11 ---</span>
          if (!strictMode())
              goto identcase;
          goto defaultCase;
      }
      case IDENT:
<span class="line-modified">!         if (UNLIKELY(*m_token.m_data.ident == m_vm.propertyNames-&gt;async &amp;&amp; !m_token.m_data.escaped)) {</span>
              if (maybeParseAsyncFunctionDeclarationStatement(context, result, parentAllowsFunctionDeclarationAsStatement))
                  break;
          }
          FALLTHROUGH;
      case AWAIT:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2021,11 ***</span>
  }
  
  template &lt;typename LexerType&gt;
  template &lt;class TreeBuilder&gt; bool Parser&lt;LexerType&gt;::maybeParseAsyncFunctionDeclarationStatement(TreeBuilder&amp; context, TreeStatement&amp; result, bool parentAllowsFunctionDeclarationAsStatement)
  {
<span class="line-modified">!     ASSERT(matchContextualKeyword(m_vm-&gt;propertyNames-&gt;async));</span>
      SavePoint savePoint = createSavePoint();
      next();
      if (match(FUNCTION) &amp;&amp; !m_lexer-&gt;hasLineTerminatorBeforeToken()) {
          const bool isAsync = true;
          result = parseFunctionDeclarationStatement(context, isAsync, parentAllowsFunctionDeclarationAsStatement);
<span class="line-new-header">--- 2037,11 ---</span>
  }
  
  template &lt;typename LexerType&gt;
  template &lt;class TreeBuilder&gt; bool Parser&lt;LexerType&gt;::maybeParseAsyncFunctionDeclarationStatement(TreeBuilder&amp; context, TreeStatement&amp; result, bool parentAllowsFunctionDeclarationAsStatement)
  {
<span class="line-modified">!     ASSERT(matchContextualKeyword(m_vm.propertyNames-&gt;async));</span>
      SavePoint savePoint = createSavePoint();
      next();
      if (match(FUNCTION) &amp;&amp; !m_lexer-&gt;hasLineTerminatorBeforeToken()) {
          const bool isAsync = true;
          result = parseFunctionDeclarationStatement(context, isAsync, parentAllowsFunctionDeclarationAsStatement);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2282,19 ***</span>
          context.appendParameter(parameters, binding, 0);
          ++parameterCount;
      };
  
      // @generator
<span class="line-modified">!     addParameter(m_vm-&gt;propertyNames-&gt;generatorPrivateName);</span>
      // @generatorState
<span class="line-modified">!     addParameter(m_vm-&gt;propertyNames-&gt;generatorStatePrivateName);</span>
      // @generatorValue
<span class="line-modified">!     addParameter(m_vm-&gt;propertyNames-&gt;generatorValuePrivateName);</span>
      // @generatorResumeMode
<span class="line-modified">!     addParameter(m_vm-&gt;propertyNames-&gt;generatorResumeModePrivateName);</span>
      // @generatorFrame
<span class="line-modified">!     addParameter(m_vm-&gt;propertyNames-&gt;generatorFramePrivateName);</span>
  
      return parameters;
  }
  
  template &lt;typename LexerType&gt;
<span class="line-new-header">--- 2298,19 ---</span>
          context.appendParameter(parameters, binding, 0);
          ++parameterCount;
      };
  
      // @generator
<span class="line-modified">!     addParameter(m_vm.propertyNames-&gt;generatorPrivateName);</span>
      // @generatorState
<span class="line-modified">!     addParameter(m_vm.propertyNames-&gt;generatorStatePrivateName);</span>
      // @generatorValue
<span class="line-modified">!     addParameter(m_vm.propertyNames-&gt;generatorValuePrivateName);</span>
      // @generatorResumeMode
<span class="line-modified">!     addParameter(m_vm.propertyNames-&gt;generatorResumeModePrivateName);</span>
      // @generatorFrame
<span class="line-modified">!     addParameter(m_vm.propertyNames-&gt;generatorFramePrivateName);</span>
  
      return parameters;
  }
  
  template &lt;typename LexerType&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2394,11 ***</span>
          }
  
          return false;
      };
  
<span class="line-modified">!     SyntaxChecker syntaxChecker(const_cast&lt;VM*&gt;(m_vm), m_lexer.get());</span>
  
      if (UNLIKELY((SourceParseModeSet(SourceParseMode::ArrowFunctionMode, SourceParseMode::AsyncArrowFunctionMode).contains(mode)))) {
          startLocation = tokenLocation();
          functionInfo.startLine = tokenLine();
          startColumn = tokenColumn();
<span class="line-new-header">--- 2410,11 ---</span>
          }
  
          return false;
      };
  
<span class="line-modified">!     SyntaxChecker syntaxChecker(const_cast&lt;VM&amp;&gt;(m_vm), m_lexer.get());</span>
  
      if (UNLIKELY((SourceParseModeSet(SourceParseMode::ArrowFunctionMode, SourceParseMode::AsyncArrowFunctionMode).contains(mode)))) {
          startLocation = tokenLocation();
          functionInfo.startLine = tokenLine();
          startColumn = tokenColumn();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2571,12 ***</span>
      failIfFalse(functionInfo.body, &quot;Cannot parse the body of this &quot;, stringForFunctionMode(mode));
      context.setEndOffset(functionInfo.body, m_lexer-&gt;currentOffset());
      if (functionScope-&gt;strictMode() &amp;&amp; requirements != FunctionNameRequirements::Unnamed) {
          ASSERT(functionInfo.name);
          RELEASE_ASSERT(SourceParseModeSet(SourceParseMode::NormalFunctionMode, SourceParseMode::MethodMode, SourceParseMode::ArrowFunctionMode, SourceParseMode::GeneratorBodyMode, SourceParseMode::GeneratorWrapperFunctionMode).contains(mode) || isAsyncFunctionOrAsyncGeneratorWrapperParseMode(mode));
<span class="line-modified">!         semanticFailIfTrue(m_vm-&gt;propertyNames-&gt;arguments == *functionInfo.name, &quot;&#39;&quot;, functionInfo.name-&gt;impl(), &quot;&#39; is not a valid function name in strict mode&quot;);</span>
<span class="line-modified">!         semanticFailIfTrue(m_vm-&gt;propertyNames-&gt;eval == *functionInfo.name, &quot;&#39;&quot;, functionInfo.name-&gt;impl(), &quot;&#39; is not a valid function name in strict mode&quot;);</span>
      }
  
      JSTokenLocation location = JSTokenLocation(m_token.m_location);
      functionInfo.endOffset = m_token.m_data.offset;
  
<span class="line-new-header">--- 2587,12 ---</span>
      failIfFalse(functionInfo.body, &quot;Cannot parse the body of this &quot;, stringForFunctionMode(mode));
      context.setEndOffset(functionInfo.body, m_lexer-&gt;currentOffset());
      if (functionScope-&gt;strictMode() &amp;&amp; requirements != FunctionNameRequirements::Unnamed) {
          ASSERT(functionInfo.name);
          RELEASE_ASSERT(SourceParseModeSet(SourceParseMode::NormalFunctionMode, SourceParseMode::MethodMode, SourceParseMode::ArrowFunctionMode, SourceParseMode::GeneratorBodyMode, SourceParseMode::GeneratorWrapperFunctionMode).contains(mode) || isAsyncFunctionOrAsyncGeneratorWrapperParseMode(mode));
<span class="line-modified">!         semanticFailIfTrue(m_vm.propertyNames-&gt;arguments == *functionInfo.name, &quot;&#39;&quot;, functionInfo.name-&gt;impl(), &quot;&#39; is not a valid function name in strict mode&quot;);</span>
<span class="line-modified">!         semanticFailIfTrue(m_vm.propertyNames-&gt;eval == *functionInfo.name, &quot;&#39;&quot;, functionInfo.name-&gt;impl(), &quot;&#39; is not a valid function name in strict mode&quot;);</span>
      }
  
      JSTokenLocation location = JSTokenLocation(m_token.m_location);
      functionInfo.endOffset = m_token.m_data.offset;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2674,11 ***</span>
          //         ...
          //         [+Default] function * ( FormalParameters[+Yield] ) { GeneratorBody }
          //
          // In this case, we use &quot;*default*&quot; as this function declaration&#39;s name.
          requirements = FunctionNameRequirements::None;
<span class="line-modified">!         functionInfo.name = &amp;m_vm-&gt;propertyNames-&gt;starDefaultPrivateName;</span>
      }
  
      failIfFalse((parseFunctionInfo(context, requirements, parseMode, true, ConstructorKind::None, SuperBinding::NotNeeded, functionKeywordStart, functionInfo, FunctionDefinitionType::Declaration, functionConstructorParametersEndPosition)), &quot;Cannot parse this function&quot;);
      ASSERT(functionInfo.name);
  
<span class="line-new-header">--- 2690,11 ---</span>
          //         ...
          //         [+Default] function * ( FormalParameters[+Yield] ) { GeneratorBody }
          //
          // In this case, we use &quot;*default*&quot; as this function declaration&#39;s name.
          requirements = FunctionNameRequirements::None;
<span class="line-modified">!         functionInfo.name = &amp;m_vm.propertyNames-&gt;starDefaultPrivateName;</span>
      }
  
      failIfFalse((parseFunctionInfo(context, requirements, parseMode, true, ConstructorKind::None, SuperBinding::NotNeeded, functionKeywordStart, functionInfo, FunctionDefinitionType::Declaration, functionConstructorParametersEndPosition)), &quot;Cannot parse this function&quot;);
      ASSERT(functionInfo.name);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2732,11 ***</span>
          //         ...
          //         [+Default] function * ( FormalParameters[+Yield] ) { GeneratorBody }
          //
          // In this case, we use &quot;*default*&quot; as this function declaration&#39;s name.
          requirements = FunctionNameRequirements::None;
<span class="line-modified">!         functionInfo.name = &amp;m_vm-&gt;propertyNames-&gt;starDefaultPrivateName;</span>
      }
  
      failIfFalse((parseFunctionInfo(context, requirements, parseMode, true, ConstructorKind::None, SuperBinding::NotNeeded, functionKeywordStart, functionInfo, FunctionDefinitionType::Declaration, functionConstructorParametersEndPosition)), &quot;Cannot parse this async function&quot;);
      failIfFalse(functionInfo.name, &quot;Async function statements must have a name&quot;);
  
<span class="line-new-header">--- 2748,11 ---</span>
          //         ...
          //         [+Default] function * ( FormalParameters[+Yield] ) { GeneratorBody }
          //
          // In this case, we use &quot;*default*&quot; as this function declaration&#39;s name.
          requirements = FunctionNameRequirements::None;
<span class="line-modified">!         functionInfo.name = &amp;m_vm.propertyNames-&gt;starDefaultPrivateName;</span>
      }
  
      failIfFalse((parseFunctionInfo(context, requirements, parseMode, true, ConstructorKind::None, SuperBinding::NotNeeded, functionKeywordStart, functionInfo, FunctionDefinitionType::Declaration, functionConstructorParametersEndPosition)), &quot;Cannot parse this async function&quot;);
      failIfFalse(functionInfo.name, &quot;Async function statements must have a name&quot;);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2778,11 ***</span>
          //         ...
          //         [+Default] class ClassTail[?Yield]
          //
          // In this case, we use &quot;*default*&quot; as this class declaration&#39;s name.
          requirements = FunctionNameRequirements::None;
<span class="line-modified">!         info.className = &amp;m_vm-&gt;propertyNames-&gt;starDefaultPrivateName;</span>
      }
  
      TreeClassExpression classExpr = parseClass(context, requirements, info);
      failIfFalse(classExpr, &quot;Failed to parse class&quot;);
      ASSERT(info.className);
<span class="line-new-header">--- 2794,11 ---</span>
          //         ...
          //         [+Default] class ClassTail[?Yield]
          //
          // In this case, we use &quot;*default*&quot; as this class declaration&#39;s name.
          requirements = FunctionNameRequirements::None;
<span class="line-modified">!         info.className = &amp;m_vm.propertyNames-&gt;starDefaultPrivateName;</span>
      }
  
      TreeClassExpression classExpr = parseClass(context, requirements, info);
      failIfFalse(classExpr, &quot;Failed to parse class&quot;);
      ASSERT(info.className);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2852,22 ***</span>
          JSTokenLocation methodLocation(tokenLocation());
          unsigned methodStart = tokenStart();
  
          // For backwards compatibility, &quot;static&quot; is a non-reserved keyword in non-strict mode.
          ClassElementTag tag = ClassElementTag::Instance;
<span class="line-modified">!         if (match(RESERVED_IF_STRICT) &amp;&amp; *m_token.m_data.ident == m_vm-&gt;propertyNames-&gt;staticKeyword) {</span>
              SavePoint savePoint = createSavePoint();
              next();
              if (match(OPENPAREN)) {
                  // Reparse &quot;static()&quot; as a method named &quot;static&quot;.
                  restoreSavePoint(savePoint);
              } else
                  tag = ClassElementTag::Static;
          }
  
          // FIXME: Figure out a way to share more code with parseProperty.
<span class="line-modified">!         const CommonIdentifiers&amp; propertyNames = *m_vm-&gt;propertyNames;</span>
          const Identifier* ident = &amp;propertyNames.nullIdentifier;
          TreeExpression computedPropertyName = 0;
          bool isGetter = false;
          bool isSetter = false;
          SourceParseMode parseMode = SourceParseMode::MethodMode;
<span class="line-new-header">--- 2868,22 ---</span>
          JSTokenLocation methodLocation(tokenLocation());
          unsigned methodStart = tokenStart();
  
          // For backwards compatibility, &quot;static&quot; is a non-reserved keyword in non-strict mode.
          ClassElementTag tag = ClassElementTag::Instance;
<span class="line-modified">!         if (match(RESERVED_IF_STRICT) &amp;&amp; *m_token.m_data.ident == m_vm.propertyNames-&gt;staticKeyword) {</span>
              SavePoint savePoint = createSavePoint();
              next();
              if (match(OPENPAREN)) {
                  // Reparse &quot;static()&quot; as a method named &quot;static&quot;.
                  restoreSavePoint(savePoint);
              } else
                  tag = ClassElementTag::Static;
          }
  
          // FIXME: Figure out a way to share more code with parseProperty.
<span class="line-modified">!         const CommonIdentifiers&amp; propertyNames = *m_vm.propertyNames;</span>
          const Identifier* ident = &amp;propertyNames.nullIdentifier;
          TreeExpression computedPropertyName = 0;
          bool isGetter = false;
          bool isSetter = false;
          SourceParseMode parseMode = SourceParseMode::MethodMode;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2881,11 ***</span>
              ident = m_token.m_data.ident;
              ASSERT(ident);
              next();
              break;
          case IDENT:
<span class="line-modified">!             if (UNLIKELY(*m_token.m_data.ident == m_vm-&gt;propertyNames-&gt;async &amp;&amp; !m_token.m_data.escaped)) {</span>
                  if (!isGeneratorMethodParseMode(parseMode) &amp;&amp; !isAsyncMethodParseMode(parseMode)) {
                      ident = m_token.m_data.ident;
                      next();
                      if (match(OPENPAREN) || match(COLON) || match(EQUAL) || m_lexer-&gt;hasLineTerminatorBeforeToken())
                          break;
<span class="line-new-header">--- 2897,11 ---</span>
              ident = m_token.m_data.ident;
              ASSERT(ident);
              next();
              break;
          case IDENT:
<span class="line-modified">!             if (UNLIKELY(*m_token.m_data.ident == m_vm.propertyNames-&gt;async &amp;&amp; !m_token.m_data.escaped)) {</span>
                  if (!isGeneratorMethodParseMode(parseMode) &amp;&amp; !isAsyncMethodParseMode(parseMode)) {
                      ident = m_token.m_data.ident;
                      next();
                      if (match(OPENPAREN) || match(COLON) || match(EQUAL) || m_lexer-&gt;hasLineTerminatorBeforeToken())
                          break;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2906,11 ***</span>
                  isSetter = *ident == propertyNames.set;
              }
              break;
          case DOUBLE:
          case INTEGER:
<span class="line-modified">!             ident = &amp;m_parserArena.identifierArena().makeNumericIdentifier(const_cast&lt;VM*&gt;(m_vm), m_token.m_data.doubleValue);</span>
              ASSERT(ident);
              next();
              break;
          case OPENBRACKET:
              next();
<span class="line-new-header">--- 2922,11 ---</span>
                  isSetter = *ident == propertyNames.set;
              }
              break;
          case DOUBLE:
          case INTEGER:
<span class="line-modified">!             ident = &amp;m_parserArena.identifierArena().makeNumericIdentifier(const_cast&lt;VM&amp;&gt;(m_vm), m_token.m_data.doubleValue);</span>
              ASSERT(ident);
              next();
              break;
          case OPENBRACKET:
              next();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2933,12 ***</span>
          } else {
              ParserFunctionInfo&lt;TreeBuilder&gt; methodInfo;
              bool isConstructor = tag == ClassElementTag::Instance &amp;&amp; *ident == propertyNames.constructor;
              if (isAsyncMethodParseMode(parseMode) || isAsyncGeneratorMethodParseMode(parseMode) || isGeneratorMethodParseMode(parseMode)) {
                  isConstructor = false;
<span class="line-modified">!                 semanticFailIfTrue(*ident == m_vm-&gt;propertyNames-&gt;prototype, &quot;Cannot declare &quot;, stringArticleForFunctionMode(parseMode), stringForFunctionMode(parseMode), &quot; named &#39;prototype&#39;&quot;);</span>
<span class="line-modified">!                 semanticFailIfTrue(*ident == m_vm-&gt;propertyNames-&gt;constructor, &quot;Cannot declare &quot;, stringArticleForFunctionMode(parseMode), stringForFunctionMode(parseMode), &quot; named &#39;constructor&#39;&quot;);</span>
              }
  
              methodInfo.name = isConstructor ? info.className : ident;
              failIfFalse((parseFunctionInfo(context, FunctionNameRequirements::Unnamed, parseMode, false, isConstructor ? constructorKind : ConstructorKind::None, SuperBinding::Needed, methodStart, methodInfo, FunctionDefinitionType::Method)), &quot;Cannot parse this method&quot;);
  
<span class="line-new-header">--- 2949,12 ---</span>
          } else {
              ParserFunctionInfo&lt;TreeBuilder&gt; methodInfo;
              bool isConstructor = tag == ClassElementTag::Instance &amp;&amp; *ident == propertyNames.constructor;
              if (isAsyncMethodParseMode(parseMode) || isAsyncGeneratorMethodParseMode(parseMode) || isGeneratorMethodParseMode(parseMode)) {
                  isConstructor = false;
<span class="line-modified">!                 semanticFailIfTrue(*ident == m_vm.propertyNames-&gt;prototype, &quot;Cannot declare &quot;, stringArticleForFunctionMode(parseMode), stringForFunctionMode(parseMode), &quot; named &#39;prototype&#39;&quot;);</span>
<span class="line-modified">!                 semanticFailIfTrue(*ident == m_vm.propertyNames-&gt;constructor, &quot;Cannot declare &quot;, stringArticleForFunctionMode(parseMode), stringForFunctionMode(parseMode), &quot; named &#39;constructor&#39;&quot;);</span>
              }
  
              methodInfo.name = isConstructor ? info.className : ident;
              failIfFalse((parseFunctionInfo(context, FunctionNameRequirements::Unnamed, parseMode, false, isConstructor ? constructorKind : ConstructorKind::None, SuperBinding::Needed, methodStart, methodInfo, FunctionDefinitionType::Method)), &quot;Cannot parse this method&quot;);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3086,11 ***</span>
      int start = tokenLine();
      next();
      handleProductionOrFail2(OPENPAREN, &quot;(&quot;, &quot;start&quot;, &quot;&#39;if&#39; condition&quot;);
  
      TreeExpression condition = parseExpression(context);
<span class="line-modified">!     failIfFalse(condition, &quot;Expected a expression as the condition for an if statement&quot;);</span>
      recordPauseLocation(context.breakpointLocation(condition));
      int end = tokenLine();
      handleProductionOrFail2(CLOSEPAREN, &quot;)&quot;, &quot;end&quot;, &quot;&#39;if&#39; condition&quot;);
  
      const Identifier* unused = 0;
<span class="line-new-header">--- 3102,11 ---</span>
      int start = tokenLine();
      next();
      handleProductionOrFail2(OPENPAREN, &quot;(&quot;, &quot;start&quot;, &quot;&#39;if&#39; condition&quot;);
  
      TreeExpression condition = parseExpression(context);
<span class="line-modified">!     failIfFalse(condition, &quot;Expected an expression as the condition for an if statement&quot;);</span>
      recordPauseLocation(context.breakpointLocation(condition));
      int end = tokenLine();
      handleProductionOrFail2(CLOSEPAREN, &quot;)&quot;, &quot;end&quot;, &quot;&#39;if&#39; condition&quot;);
  
      const Identifier* unused = 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3122,11 ***</span>
          next();
  
          handleProductionOrFail2(OPENPAREN, &quot;(&quot;, &quot;start&quot;, &quot;&#39;if&#39; condition&quot;);
  
          TreeExpression innerCondition = parseExpression(context);
<span class="line-modified">!         failIfFalse(innerCondition, &quot;Expected a expression as the condition for an if statement&quot;);</span>
          recordPauseLocation(context.breakpointLocation(innerCondition));
          int innerEnd = tokenLine();
          handleProductionOrFail2(CLOSEPAREN, &quot;)&quot;, &quot;end&quot;, &quot;&#39;if&#39; condition&quot;);
          const Identifier* unused = 0;
          m_immediateParentAllowsFunctionDeclarationInStatement = true;
<span class="line-new-header">--- 3138,11 ---</span>
          next();
  
          handleProductionOrFail2(OPENPAREN, &quot;(&quot;, &quot;start&quot;, &quot;&#39;if&#39; condition&quot;);
  
          TreeExpression innerCondition = parseExpression(context);
<span class="line-modified">!         failIfFalse(innerCondition, &quot;Expected an expression as the condition for an if statement&quot;);</span>
          recordPauseLocation(context.breakpointLocation(innerCondition));
          int innerEnd = tokenLine();
          handleProductionOrFail2(CLOSEPAREN, &quot;)&quot;, &quot;end&quot;, &quot;&#39;if&#39; condition&quot;);
          const Identifier* unused = 0;
          m_immediateParentAllowsFunctionDeclarationInStatement = true;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3200,14 ***</span>
          // NameSpaceImport :
          // * as ImportedBinding
          // e.g.
          //     * as namespace
          ASSERT(match(TIMES));
<span class="line-modified">!         importedName = &amp;m_vm-&gt;propertyNames-&gt;timesIdentifier;</span>
          next();
  
<span class="line-modified">!         failIfFalse(matchContextualKeyword(m_vm-&gt;propertyNames-&gt;as), &quot;Expected &#39;as&#39; before imported binding name&quot;);</span>
          next();
  
          failIfFalse(matchSpecIdentifier(), &quot;Expected a variable name for the import declaration&quot;);
          localNameToken = m_token;
          localName = m_token.m_data.ident;
<span class="line-new-header">--- 3216,14 ---</span>
          // NameSpaceImport :
          // * as ImportedBinding
          // e.g.
          //     * as namespace
          ASSERT(match(TIMES));
<span class="line-modified">!         importedName = &amp;m_vm.propertyNames-&gt;timesIdentifier;</span>
          next();
  
<span class="line-modified">!         failIfFalse(matchContextualKeyword(m_vm.propertyNames-&gt;as), &quot;Expected &#39;as&#39; before imported binding name&quot;);</span>
          next();
  
          failIfFalse(matchSpecIdentifier(), &quot;Expected a variable name for the import declaration&quot;);
          localNameToken = m_token;
          localName = m_token.m_data.ident;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3226,11 ***</span>
          localNameToken = m_token;
          localName = m_token.m_data.ident;
          importedName = localName;
          next();
  
<span class="line-modified">!         if (matchContextualKeyword(m_vm-&gt;propertyNames-&gt;as)) {</span>
              next();
              failIfFalse(matchSpecIdentifier(), &quot;Expected a variable name for the import declaration&quot;);
              localNameToken = m_token;
              localName = m_token.m_data.ident;
              next();
<span class="line-new-header">--- 3242,11 ---</span>
          localNameToken = m_token;
          localName = m_token.m_data.ident;
          importedName = localName;
          next();
  
<span class="line-modified">!         if (matchContextualKeyword(m_vm.propertyNames-&gt;as)) {</span>
              next();
              failIfFalse(matchSpecIdentifier(), &quot;Expected a variable name for the import declaration&quot;);
              localNameToken = m_token;
              localName = m_token.m_data.ident;
              next();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3242,11 ***</span>
          // ImportedDefaultBinding :
          // ImportedBinding
          ASSERT(matchSpecIdentifier());
          localNameToken = m_token;
          localName = m_token.m_data.ident;
<span class="line-modified">!         importedName = &amp;m_vm-&gt;propertyNames-&gt;defaultKeyword;</span>
          next();
          break;
      }
      }
  
<span class="line-new-header">--- 3258,11 ---</span>
          // ImportedDefaultBinding :
          // ImportedBinding
          ASSERT(matchSpecIdentifier());
          localNameToken = m_token;
          localName = m_token.m_data.ident;
<span class="line-modified">!         importedName = &amp;m_vm.propertyNames-&gt;defaultKeyword;</span>
          next();
          break;
      }
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3320,11 ***</span>
      }
  
      // FromClause :
      // from ModuleSpecifier
  
<span class="line-modified">!     failIfFalse(matchContextualKeyword(m_vm-&gt;propertyNames-&gt;from), &quot;Expected &#39;from&#39; before imported module name&quot;);</span>
      next();
  
      auto moduleName = parseModuleName(context);
      failIfFalse(moduleName, &quot;Cannot parse the module name&quot;);
      failIfFalse(autoSemiColon(), &quot;Expected a &#39;;&#39; following a targeted import declaration&quot;);
<span class="line-new-header">--- 3336,11 ---</span>
      }
  
      // FromClause :
      // from ModuleSpecifier
  
<span class="line-modified">!     failIfFalse(matchContextualKeyword(m_vm.propertyNames-&gt;from), &quot;Expected &#39;from&#39; before imported module name&quot;);</span>
      next();
  
      auto moduleName = parseModuleName(context);
      failIfFalse(moduleName, &quot;Cannot parse the module name&quot;);
      failIfFalse(autoSemiColon(), &quot;Expected a &#39;;&#39; following a targeted import declaration&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3345,11 ***</span>
          hasKeywordForLocalBindings = true;
      const Identifier* localName = m_token.m_data.ident;
      const Identifier* exportedName = localName;
      next();
  
<span class="line-modified">!     if (matchContextualKeyword(m_vm-&gt;propertyNames-&gt;as)) {</span>
          next();
          failIfFalse(matchIdentifierOrKeyword(), &quot;Expected an exported name for the export declaration&quot;);
          exportedName = m_token.m_data.ident;
          next();
      }
<span class="line-new-header">--- 3361,11 ---</span>
          hasKeywordForLocalBindings = true;
      const Identifier* localName = m_token.m_data.ident;
      const Identifier* exportedName = localName;
      next();
  
<span class="line-modified">!     if (matchContextualKeyword(m_vm.propertyNames-&gt;as)) {</span>
          next();
          failIfFalse(matchIdentifierOrKeyword(), &quot;Expected an exported name for the export declaration&quot;);
          exportedName = m_token.m_data.ident;
          next();
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3370,11 ***</span>
      switch (m_token.m_type) {
      case TIMES: {
          // export * FromClause ;
          next();
  
<span class="line-modified">!         failIfFalse(matchContextualKeyword(m_vm-&gt;propertyNames-&gt;from), &quot;Expected &#39;from&#39; before exported module name&quot;);</span>
          next();
          auto moduleName = parseModuleName(context);
          failIfFalse(moduleName, &quot;Cannot parse the &#39;from&#39; clause&quot;);
          failIfFalse(autoSemiColon(), &quot;Expected a &#39;;&#39; following a targeted export declaration&quot;);
  
<span class="line-new-header">--- 3386,11 ---</span>
      switch (m_token.m_type) {
      case TIMES: {
          // export * FromClause ;
          next();
  
<span class="line-modified">!         failIfFalse(matchContextualKeyword(m_vm.propertyNames-&gt;from), &quot;Expected &#39;from&#39; before exported module name&quot;);</span>
          next();
          auto moduleName = parseModuleName(context);
          failIfFalse(moduleName, &quot;Cannot parse the &#39;from&#39; clause&quot;);
          failIfFalse(autoSemiColon(), &quot;Expected a &#39;;&#39; following a targeted export declaration&quot;);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3402,11 ***</span>
              if (startsWithFunction &amp;&amp; match(TIMES))
                  next();
              if (match(IDENT))
                  localName = m_token.m_data.ident;
              restoreSavePoint(savePoint);
<span class="line-modified">!         } else if (matchContextualKeyword(m_vm-&gt;propertyNames-&gt;async)) {</span>
              SavePoint savePoint = createSavePoint();
              next();
              if (match(FUNCTION) &amp;&amp; !m_lexer-&gt;hasLineTerminatorBeforeToken()) {
                  next();
                  if (match(IDENT))
<span class="line-new-header">--- 3418,11 ---</span>
              if (startsWithFunction &amp;&amp; match(TIMES))
                  next();
              if (match(IDENT))
                  localName = m_token.m_data.ident;
              restoreSavePoint(savePoint);
<span class="line-modified">!         } else if (matchContextualKeyword(m_vm.propertyNames-&gt;async)) {</span>
              SavePoint savePoint = createSavePoint();
              next();
              if (match(FUNCTION) &amp;&amp; !m_lexer-&gt;hasLineTerminatorBeforeToken()) {
                  next();
                  if (match(IDENT))
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3415,22 ***</span>
              }
              restoreSavePoint(savePoint);
          }
  
          if (!localName)
<span class="line-modified">!             localName = &amp;m_vm-&gt;propertyNames-&gt;starDefaultPrivateName;</span>
  
          if (isFunctionOrClassDeclaration) {
              if (startsWithFunction) {
                  ASSERT(match(FUNCTION));
                  DepthManager statementDepth(&amp;m_statementDepth);
                  m_statementDepth = 1;
                  result = parseFunctionDeclaration(context, ExportType::NotExported, DeclarationDefaultContext::ExportDefault);
              } else if (match(CLASSTOKEN)) {
                  result = parseClassDeclaration(context, ExportType::NotExported, DeclarationDefaultContext::ExportDefault);
              } else {
<span class="line-modified">!                 ASSERT(matchContextualKeyword(m_vm-&gt;propertyNames-&gt;async));</span>
                  next();
                  DepthManager statementDepth(&amp;m_statementDepth);
                  m_statementDepth = 1;
                  result = parseAsyncFunctionDeclaration(context, ExportType::NotExported, DeclarationDefaultContext::ExportDefault);
              }
<span class="line-new-header">--- 3431,22 ---</span>
              }
              restoreSavePoint(savePoint);
          }
  
          if (!localName)
<span class="line-modified">!             localName = &amp;m_vm.propertyNames-&gt;starDefaultPrivateName;</span>
  
          if (isFunctionOrClassDeclaration) {
              if (startsWithFunction) {
                  ASSERT(match(FUNCTION));
                  DepthManager statementDepth(&amp;m_statementDepth);
                  m_statementDepth = 1;
                  result = parseFunctionDeclaration(context, ExportType::NotExported, DeclarationDefaultContext::ExportDefault);
              } else if (match(CLASSTOKEN)) {
                  result = parseClassDeclaration(context, ExportType::NotExported, DeclarationDefaultContext::ExportDefault);
              } else {
<span class="line-modified">!                 ASSERT(matchContextualKeyword(m_vm.propertyNames-&gt;async));</span>
                  next();
                  DepthManager statementDepth(&amp;m_statementDepth);
                  m_statementDepth = 1;
                  result = parseAsyncFunctionDeclaration(context, ExportType::NotExported, DeclarationDefaultContext::ExportDefault);
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3447,22 ***</span>
              JSTokenLocation location(tokenLocation());
              JSTextPosition start = tokenStartPosition();
              TreeExpression expression = parseAssignmentExpression(context);
              failIfFalse(expression, &quot;Cannot parse expression&quot;);
  
<span class="line-modified">!             DeclarationResultMask declarationResult = declareVariable(&amp;m_vm-&gt;propertyNames-&gt;starDefaultPrivateName, DeclarationType::ConstDeclaration);</span>
              if (declarationResult &amp; DeclarationResult::InvalidDuplicateDeclaration)
                  internalFailWithMessage(false, &quot;Only one &#39;default&#39; export is allowed&quot;);
  
<span class="line-modified">!             TreeExpression assignment = context.createAssignResolve(location, m_vm-&gt;propertyNames-&gt;starDefaultPrivateName, expression, start, start, tokenEndPosition(), AssignmentContext::ConstDeclarationStatement);</span>
              result = context.createExprStatement(location, assignment, start, tokenEndPosition());
              failIfFalse(autoSemiColon(), &quot;Expected a &#39;;&#39; following a targeted export declaration&quot;);
          }
          failIfFalse(result, &quot;Cannot parse the declaration&quot;);
  
<span class="line-modified">!         semanticFailIfFalse(exportName(m_vm-&gt;propertyNames-&gt;defaultKeyword), &quot;Only one &#39;default&#39; export is allowed&quot;);</span>
<span class="line-modified">!         m_moduleScopeData-&gt;exportBinding(*localName, m_vm-&gt;propertyNames-&gt;defaultKeyword);</span>
          return context.createExportDefaultDeclaration(exportLocation, result, *localName);
      }
  
      case OPENBRACE: {
          // export ExportClause FromClause ;
<span class="line-new-header">--- 3463,22 ---</span>
              JSTokenLocation location(tokenLocation());
              JSTextPosition start = tokenStartPosition();
              TreeExpression expression = parseAssignmentExpression(context);
              failIfFalse(expression, &quot;Cannot parse expression&quot;);
  
<span class="line-modified">!             DeclarationResultMask declarationResult = declareVariable(&amp;m_vm.propertyNames-&gt;starDefaultPrivateName, DeclarationType::ConstDeclaration);</span>
              if (declarationResult &amp; DeclarationResult::InvalidDuplicateDeclaration)
                  internalFailWithMessage(false, &quot;Only one &#39;default&#39; export is allowed&quot;);
  
<span class="line-modified">!             TreeExpression assignment = context.createAssignResolve(location, m_vm.propertyNames-&gt;starDefaultPrivateName, expression, start, start, tokenEndPosition(), AssignmentContext::ConstDeclarationStatement);</span>
              result = context.createExprStatement(location, assignment, start, tokenEndPosition());
              failIfFalse(autoSemiColon(), &quot;Expected a &#39;;&#39; following a targeted export declaration&quot;);
          }
          failIfFalse(result, &quot;Cannot parse the declaration&quot;);
  
<span class="line-modified">!         semanticFailIfFalse(exportName(m_vm.propertyNames-&gt;defaultKeyword), &quot;Only one &#39;default&#39; export is allowed&quot;);</span>
<span class="line-modified">!         m_moduleScopeData-&gt;exportBinding(*localName, m_vm.propertyNames-&gt;defaultKeyword);</span>
          return context.createExportDefaultDeclaration(exportLocation, result, *localName);
      }
  
      case OPENBRACE: {
          // export ExportClause FromClause ;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3492,11 ***</span>
                  break;
          }
          handleProductionOrFail2(CLOSEBRACE, &quot;}&quot;, &quot;end&quot;, &quot;export list&quot;);
  
          typename TreeBuilder::ModuleName moduleName = 0;
<span class="line-modified">!         if (matchContextualKeyword(m_vm-&gt;propertyNames-&gt;from)) {</span>
              next();
              moduleName = parseModuleName(context);
              failIfFalse(moduleName, &quot;Cannot parse the &#39;from&#39; clause&quot;);
          }
          failIfFalse(autoSemiColon(), &quot;Expected a &#39;;&#39; following a targeted export declaration&quot;);
<span class="line-new-header">--- 3508,11 ---</span>
                  break;
          }
          handleProductionOrFail2(CLOSEBRACE, &quot;}&quot;, &quot;end&quot;, &quot;export list&quot;);
  
          typename TreeBuilder::ModuleName moduleName = 0;
<span class="line-modified">!         if (matchContextualKeyword(m_vm.propertyNames-&gt;from)) {</span>
              next();
              moduleName = parseModuleName(context);
              failIfFalse(moduleName, &quot;Cannot parse the &#39;from&#39; clause&quot;);
          }
          failIfFalse(autoSemiColon(), &quot;Expected a &#39;;&#39; following a targeted export declaration&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3548,11 ***</span>
          case CLASSTOKEN:
              result = parseClassDeclaration(context, ExportType::Exported);
              break;
  
          case IDENT:
<span class="line-modified">!             if (*m_token.m_data.ident == m_vm-&gt;propertyNames-&gt;async &amp;&amp; !m_token.m_data.escaped) {</span>
                  next();
                  semanticFailIfFalse(match(FUNCTION) &amp;&amp; !m_lexer-&gt;hasLineTerminatorBeforeToken(), &quot;Expected &#39;function&#39; keyword following &#39;async&#39; keyword with no preceding line terminator&quot;);
                  DepthManager statementDepth(&amp;m_statementDepth);
                  m_statementDepth = 1;
                  result = parseAsyncFunctionDeclaration(context, ExportType::Exported);
<span class="line-new-header">--- 3564,11 ---</span>
          case CLASSTOKEN:
              result = parseClassDeclaration(context, ExportType::Exported);
              break;
  
          case IDENT:
<span class="line-modified">!             if (*m_token.m_data.ident == m_vm.propertyNames-&gt;async &amp;&amp; !m_token.m_data.escaped) {</span>
                  next();
                  semanticFailIfFalse(match(FUNCTION) &amp;&amp; !m_lexer-&gt;hasLineTerminatorBeforeToken(), &quot;Expected &#39;function&#39; keyword following &#39;async&#39; keyword with no preceding line terminator&quot;);
                  DepthManager statementDepth(&amp;m_statementDepth);
                  m_statementDepth = 1;
                  result = parseAsyncFunctionDeclaration(context, ExportType::Exported);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3629,10 ***</span>
<span class="line-new-header">--- 3645,18 ---</span>
          return &quot;import.meta&quot;;
      RELEASE_ASSERT_NOT_REACHED();
      return &quot;error&quot;;
  }
  
<span class="line-added">+ template &lt;typename LexerType&gt;</span>
<span class="line-added">+ template &lt;typename TreeBuilder&gt; bool Parser&lt;LexerType&gt;::isSimpleAssignmentTarget(TreeBuilder&amp; context, TreeExpression expr)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     // Web compatibility concerns prevent us from handling a function call LHS as an early error in sloppy mode.</span>
<span class="line-added">+     // This behavior is currently unspecified, but see: https://github.com/tc39/ecma262/issues/257#issuecomment-195106880</span>
<span class="line-added">+     return context.isLocation(expr) || (!strictMode() &amp;&amp; context.isFunctionCall(expr));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  template &lt;typename LexerType&gt;
  template &lt;typename TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseAssignmentExpression(TreeBuilder&amp; context, ExpressionErrorClassifier&amp; classifier)
  {
      ASSERT(!hasError());
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3666,11 ***</span>
          if (!lhs || isArrowFunctionToken) {
              SavePointWithError errorRestorationSavePoint = createSavePointForError();
              restoreSavePoint(savePoint);
              bool isAsyncArrow = false;
              if (UNLIKELY(classifier.indicatesPossibleAsyncArrowFunction())) {
<span class="line-modified">!                 if (matchContextualKeyword(m_vm-&gt;propertyNames-&gt;async)) {</span>
                      next();
                      isAsyncArrow = !m_lexer-&gt;hasLineTerminatorBeforeToken();
                  }
              }
              if (isArrowFunctionParameters()) {
<span class="line-new-header">--- 3690,11 ---</span>
          if (!lhs || isArrowFunctionToken) {
              SavePointWithError errorRestorationSavePoint = createSavePointForError();
              restoreSavePoint(savePoint);
              bool isAsyncArrow = false;
              if (UNLIKELY(classifier.indicatesPossibleAsyncArrowFunction())) {
<span class="line-modified">!                 if (matchContextualKeyword(m_vm.propertyNames-&gt;async)) {</span>
                      next();
                      isAsyncArrow = !m_lexer-&gt;hasLineTerminatorBeforeToken();
                  }
              }
              if (isArrowFunctionParameters()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3734,19 ***</span>
          default:
              goto end;
          }
          m_parserState.nonTrivialExpressionCount++;
          hadAssignment = true;
<span class="line-modified">!         if (UNLIKELY(context.isMetaProperty(lhs)))</span>
<span class="line-modified">!             internalFailWithMessage(false, metaPropertyName(context, lhs), &quot; can&#39;t be the left hand side of an assignment expression&quot;);</span>
          context.assignmentStackAppend(assignmentStack, lhs, start, tokenStartPosition(), m_parserState.assignmentCount, op);
          start = tokenStartPosition();
          m_parserState.assignmentCount++;
          next(TreeBuilder::DontBuildStrings);
          if (strictMode() &amp;&amp; m_parserState.lastIdentifier &amp;&amp; context.isResolve(lhs)) {
<span class="line-modified">!             failIfTrueIfStrict(m_vm-&gt;propertyNames-&gt;eval == *m_parserState.lastIdentifier, &quot;Cannot modify &#39;eval&#39; in strict mode&quot;);</span>
<span class="line-modified">!             failIfTrueIfStrict(m_vm-&gt;propertyNames-&gt;arguments == *m_parserState.lastIdentifier, &quot;Cannot modify &#39;arguments&#39; in strict mode&quot;);</span>
              m_parserState.lastIdentifier = 0;
          }
          lhs = parseAssignmentExpression(context);
          failIfFalse(lhs, &quot;Cannot parse the right hand side of an assignment expression&quot;);
          if (initialNonLHSCount != m_parserState.nonLHSCount) {
<span class="line-new-header">--- 3758,19 ---</span>
          default:
              goto end;
          }
          m_parserState.nonTrivialExpressionCount++;
          hadAssignment = true;
<span class="line-modified">!         semanticFailIfTrue(context.isMetaProperty(lhs), metaPropertyName(context, lhs), &quot; can&#39;t be the left hand side of an assignment expression&quot;);</span>
<span class="line-modified">!         semanticFailIfFalse(isSimpleAssignmentTarget(context, lhs), &quot;Left side of assignment is not a reference&quot;);</span>
          context.assignmentStackAppend(assignmentStack, lhs, start, tokenStartPosition(), m_parserState.assignmentCount, op);
          start = tokenStartPosition();
          m_parserState.assignmentCount++;
          next(TreeBuilder::DontBuildStrings);
          if (strictMode() &amp;&amp; m_parserState.lastIdentifier &amp;&amp; context.isResolve(lhs)) {
<span class="line-modified">!             failIfTrueIfStrict(m_vm.propertyNames-&gt;eval == *m_parserState.lastIdentifier, &quot;Cannot modify &#39;eval&#39; in strict mode&quot;);</span>
<span class="line-modified">!             failIfTrueIfStrict(m_vm.propertyNames-&gt;arguments == *m_parserState.lastIdentifier, &quot;Cannot modify &#39;arguments&#39; in strict mode&quot;);</span>
              m_parserState.lastIdentifier = 0;
          }
          lhs = parseAssignmentExpression(context);
          failIfFalse(lhs, &quot;Cannot parse the right hand side of an assignment expression&quot;);
          if (initialNonLHSCount != m_parserState.nonLHSCount) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3859,18 ***</span>
<span class="line-new-header">--- 3883,24 ---</span>
  {
      int operandStackDepth = 0;
      int operatorStackDepth = 0;
      typename TreeBuilder::BinaryExprContext binaryExprContext(context);
      JSTokenLocation location(tokenLocation());
<span class="line-added">+     bool hasLogicalOperator = false;</span>
<span class="line-added">+     bool hasCoalesceOperator = false;</span>
<span class="line-added">+ </span>
      while (true) {
          JSTextPosition exprStart = tokenStartPosition();
          int initialAssignments = m_parserState.assignmentCount;
          JSTokenType leadingTokenTypeForUnaryExpression = m_token.m_type;
          TreeExpression current = parseUnaryExpression(context);
          failIfFalse(current, &quot;Cannot parse expression&quot;);
  
          context.appendBinaryExpressionInfo(operandStackDepth, current, exprStart, lastTokenEndPosition(), lastTokenEndPosition(), initialAssignments != m_parserState.assignmentCount);
<span class="line-added">+         int precedence = isBinaryOperator(m_token.m_type);</span>
<span class="line-added">+         if (!precedence)</span>
<span class="line-added">+             break;</span>
  
          // 12.6 https://tc39.github.io/ecma262/#sec-exp-operator
          // ExponentiationExpresion is described as follows.
          //
          //     ExponentiationExpression[Yield]:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3891,13 ***</span>
          //          Check this.
          // If the binary operator &lt;&gt; has higher precedence than one of &quot;**&quot;, this check does not work.
          // But it&#39;s OK for ** because the operator &quot;**&quot; has the highest operator precedence in the binary operators.
          failIfTrue(match(POW) &amp;&amp; isUnaryOpExcludingUpdateOp(leadingTokenTypeForUnaryExpression), &quot;Ambiguous unary expression in the left hand side of the exponentiation expression; parentheses must be used to disambiguate the expression&quot;);
  
<span class="line-modified">!         int precedence = isBinaryOperator(m_token.m_type);</span>
<span class="line-modified">!         if (!precedence)</span>
<span class="line-modified">!             break;</span>
          m_parserState.nonTrivialExpressionCount++;
          m_parserState.nonLHSCount++;
          int operatorToken = m_token.m_type;
          next(TreeBuilder::DontBuildStrings);
  
<span class="line-new-header">--- 3921,18 ---</span>
          //          Check this.
          // If the binary operator &lt;&gt; has higher precedence than one of &quot;**&quot;, this check does not work.
          // But it&#39;s OK for ** because the operator &quot;**&quot; has the highest operator precedence in the binary operators.
          failIfTrue(match(POW) &amp;&amp; isUnaryOpExcludingUpdateOp(leadingTokenTypeForUnaryExpression), &quot;Ambiguous unary expression in the left hand side of the exponentiation expression; parentheses must be used to disambiguate the expression&quot;);
  
<span class="line-modified">!         // Mixing ?? with || or &amp;&amp; is currently specified as an early error.</span>
<span class="line-modified">!         // Since ?? is the lowest-precedence binary operator, it suffices to check whether these ever coexist in the operator stack.</span>
<span class="line-modified">!         if (match(AND) || match(OR))</span>
<span class="line-added">+             hasLogicalOperator = true;</span>
<span class="line-added">+         else if (match(COALESCE))</span>
<span class="line-added">+             hasCoalesceOperator = true;</span>
<span class="line-added">+         failIfTrue(hasLogicalOperator &amp;&amp; hasCoalesceOperator, &quot;Coalescing and logical operators used together in the same expression; parentheses must be used to disambiguate&quot;);</span>
<span class="line-added">+ </span>
          m_parserState.nonTrivialExpressionCount++;
          m_parserState.nonLHSCount++;
          int operatorToken = m_token.m_type;
          next(TreeBuilder::DontBuildStrings);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3934,11 ***</span>
          parseMode = SourceParseMode::GeneratorWrapperMethodMode;
  
  parseProperty:
      switch (m_token.m_type) {
      case IDENT:
<span class="line-modified">!         if (UNLIKELY(*m_token.m_data.ident == m_vm-&gt;propertyNames-&gt;async &amp;&amp; !m_token.m_data.escaped)) {</span>
              if (parseMode == SourceParseMode::MethodMode) {
                  SavePoint savePoint = createSavePoint();
                  next();
  
                  if (match(COLON) || match(OPENPAREN) || match(COMMA) || match(CLOSEBRACE)) {
<span class="line-new-header">--- 3969,11 ---</span>
          parseMode = SourceParseMode::GeneratorWrapperMethodMode;
  
  parseProperty:
      switch (m_token.m_type) {
      case IDENT:
<span class="line-modified">!         if (UNLIKELY(*m_token.m_data.ident == m_vm.propertyNames-&gt;async &amp;&amp; !m_token.m_data.escaped)) {</span>
              if (parseMode == SourceParseMode::MethodMode) {
                  SavePoint savePoint = createSavePoint();
                  next();
  
                  if (match(COLON) || match(OPENPAREN) || match(COMMA) || match(CLOSEBRACE)) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3964,21 ***</span>
  namedProperty:
          const Identifier* ident = m_token.m_data.ident;
          unsigned getterOrSetterStartOffset = tokenStart();
          JSToken identToken = m_token;
  
<span class="line-modified">!         if (complete || (wasIdent &amp;&amp; !isGeneratorMethodParseMode(parseMode)  &amp;&amp; (*ident == m_vm-&gt;propertyNames-&gt;get || *ident == m_vm-&gt;propertyNames-&gt;set)))</span>
              nextExpectIdentifier(LexerFlagsIgnoreReservedWords);
          else
              nextExpectIdentifier(LexerFlagsIgnoreReservedWords | TreeBuilder::DontBuildKeywords);
  
          if (!isGeneratorMethodParseMode(parseMode) &amp;&amp; !isAsyncMethodParseMode(parseMode) &amp;&amp; match(COLON)) {
              next();
              TreeExpression node = parseAssignmentExpressionOrPropagateErrorClass(context);
              failIfFalse(node, &quot;Cannot parse expression for property declaration&quot;);
              context.setEndOffset(node, m_lexer-&gt;currentOffset());
<span class="line-modified">!             InferName inferName = ident &amp;&amp; *ident == m_vm-&gt;propertyNames-&gt;underscoreProto ? InferName::Disallowed : InferName::Allowed;</span>
              return context.createProperty(ident, node, PropertyNode::Constant, PropertyNode::Unknown, complete, SuperBinding::NotNeeded, inferName, ClassElementTag::No);
          }
  
          if (match(OPENPAREN)) {
              auto method = parsePropertyMethod(context, ident, parseMode);
<span class="line-new-header">--- 3999,21 ---</span>
  namedProperty:
          const Identifier* ident = m_token.m_data.ident;
          unsigned getterOrSetterStartOffset = tokenStart();
          JSToken identToken = m_token;
  
<span class="line-modified">!         if (complete || (wasIdent &amp;&amp; !isGeneratorMethodParseMode(parseMode)  &amp;&amp; (*ident == m_vm.propertyNames-&gt;get || *ident == m_vm.propertyNames-&gt;set)))</span>
              nextExpectIdentifier(LexerFlagsIgnoreReservedWords);
          else
              nextExpectIdentifier(LexerFlagsIgnoreReservedWords | TreeBuilder::DontBuildKeywords);
  
          if (!isGeneratorMethodParseMode(parseMode) &amp;&amp; !isAsyncMethodParseMode(parseMode) &amp;&amp; match(COLON)) {
              next();
              TreeExpression node = parseAssignmentExpressionOrPropagateErrorClass(context);
              failIfFalse(node, &quot;Cannot parse expression for property declaration&quot;);
              context.setEndOffset(node, m_lexer-&gt;currentOffset());
<span class="line-modified">!             InferName inferName = ident &amp;&amp; *ident == m_vm.propertyNames-&gt;underscoreProto ? InferName::Disallowed : InferName::Allowed;</span>
              return context.createProperty(ident, node, PropertyNode::Constant, PropertyNode::Unknown, complete, SuperBinding::NotNeeded, inferName, ClassElementTag::No);
          }
  
          if (match(OPENPAREN)) {
              auto method = parsePropertyMethod(context, ident, parseMode);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3991,24 ***</span>
  
          if (match(COMMA) || match(CLOSEBRACE)) {
              semanticFailureDueToKeywordCheckingToken(identToken, &quot;shorthand property name&quot;);
              JSTextPosition start = tokenStartPosition();
              JSTokenLocation location(tokenLocation());
<span class="line-modified">!             currentScope()-&gt;useVariable(ident, m_vm-&gt;propertyNames-&gt;eval == *ident);</span>
              if (currentScope()-&gt;isArrowFunction())
                  currentScope()-&gt;setInnerArrowFunctionUsesEval();
              TreeExpression node = context.createResolve(location, *ident, start, lastTokenEndPosition());
              return context.createProperty(ident, node, static_cast&lt;PropertyNode::Type&gt;(PropertyNode::Constant | PropertyNode::Shorthand), PropertyNode::KnownDirect, complete, SuperBinding::NotNeeded, InferName::Allowed, ClassElementTag::No);
          }
  
          if (match(EQUAL)) // CoverInitializedName is exclusive to BindingPattern and AssignmentPattern
              classifyExpressionError(ErrorIndicatesPattern);
  
          PropertyNode::Type type;
<span class="line-modified">!         if (*ident == m_vm-&gt;propertyNames-&gt;get)</span>
              type = PropertyNode::Getter;
<span class="line-modified">!         else if (*ident == m_vm-&gt;propertyNames-&gt;set)</span>
              type = PropertyNode::Setter;
          else
              failWithMessage(&quot;Expected a &#39;:&#39; following the property name &#39;&quot;, ident-&gt;impl(), &quot;&#39;&quot;);
          return parseGetterSetter(context, complete, type, getterOrSetterStartOffset, ConstructorKind::None, ClassElementTag::No);
      }
<span class="line-new-header">--- 4026,24 ---</span>
  
          if (match(COMMA) || match(CLOSEBRACE)) {
              semanticFailureDueToKeywordCheckingToken(identToken, &quot;shorthand property name&quot;);
              JSTextPosition start = tokenStartPosition();
              JSTokenLocation location(tokenLocation());
<span class="line-modified">!             currentScope()-&gt;useVariable(ident, m_vm.propertyNames-&gt;eval == *ident);</span>
              if (currentScope()-&gt;isArrowFunction())
                  currentScope()-&gt;setInnerArrowFunctionUsesEval();
              TreeExpression node = context.createResolve(location, *ident, start, lastTokenEndPosition());
              return context.createProperty(ident, node, static_cast&lt;PropertyNode::Type&gt;(PropertyNode::Constant | PropertyNode::Shorthand), PropertyNode::KnownDirect, complete, SuperBinding::NotNeeded, InferName::Allowed, ClassElementTag::No);
          }
  
          if (match(EQUAL)) // CoverInitializedName is exclusive to BindingPattern and AssignmentPattern
              classifyExpressionError(ErrorIndicatesPattern);
  
          PropertyNode::Type type;
<span class="line-modified">!         if (*ident == m_vm.propertyNames-&gt;get)</span>
              type = PropertyNode::Getter;
<span class="line-modified">!         else if (*ident == m_vm.propertyNames-&gt;set)</span>
              type = PropertyNode::Setter;
          else
              failWithMessage(&quot;Expected a &#39;:&#39; following the property name &#39;&quot;, ident-&gt;impl(), &quot;&#39;&quot;);
          return parseGetterSetter(context, complete, type, getterOrSetterStartOffset, ConstructorKind::None, ClassElementTag::No);
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4016,31 ***</span>
      case INTEGER: {
          double propertyName = m_token.m_data.doubleValue;
          next();
  
          if (match(OPENPAREN)) {
<span class="line-modified">!             const Identifier&amp; ident = m_parserArena.identifierArena().makeNumericIdentifier(const_cast&lt;VM*&gt;(m_vm), propertyName);</span>
              auto method = parsePropertyMethod(context, &amp;ident, parseMode);
              propagateError();
              return context.createProperty(&amp;ident, method, PropertyNode::Constant, PropertyNode::Unknown, complete, SuperBinding::Needed, InferName::Allowed, ClassElementTag::No);
          }
          failIfTrue(parseMode != SourceParseMode::MethodMode, &quot;Expected a parenthesis for argument list&quot;);
  
          consumeOrFail(COLON, &quot;Expected &#39;:&#39; after property name&quot;);
          TreeExpression node = parseAssignmentExpression(context);
          failIfFalse(node, &quot;Cannot parse expression for property declaration&quot;);
          context.setEndOffset(node, m_lexer-&gt;currentOffset());
<span class="line-modified">!         return context.createProperty(const_cast&lt;VM*&gt;(m_vm), m_parserArena, propertyName, node, PropertyNode::Constant, PropertyNode::Unknown, complete, SuperBinding::NotNeeded, ClassElementTag::No);</span>
      }
      case OPENBRACKET: {
          next();
          auto propertyName = parseAssignmentExpression(context);
          failIfFalse(propertyName, &quot;Cannot parse computed property name&quot;);
          handleProductionOrFail(CLOSEBRACKET, &quot;]&quot;, &quot;end&quot;, &quot;computed property name&quot;);
  
          if (match(OPENPAREN)) {
<span class="line-modified">!             auto method = parsePropertyMethod(context, &amp;m_vm-&gt;propertyNames-&gt;nullIdentifier, parseMode);</span>
              propagateError();
              return context.createProperty(propertyName, method, static_cast&lt;PropertyNode::Type&gt;(PropertyNode::Constant | PropertyNode::Computed), PropertyNode::KnownDirect, complete, SuperBinding::Needed, ClassElementTag::No);
          }
          failIfTrue(parseMode != SourceParseMode::MethodMode, &quot;Expected a parenthesis for argument list&quot;);
  
<span class="line-new-header">--- 4051,31 ---</span>
      case INTEGER: {
          double propertyName = m_token.m_data.doubleValue;
          next();
  
          if (match(OPENPAREN)) {
<span class="line-modified">!             const Identifier&amp; ident = m_parserArena.identifierArena().makeNumericIdentifier(const_cast&lt;VM&amp;&gt;(m_vm), propertyName);</span>
              auto method = parsePropertyMethod(context, &amp;ident, parseMode);
              propagateError();
              return context.createProperty(&amp;ident, method, PropertyNode::Constant, PropertyNode::Unknown, complete, SuperBinding::Needed, InferName::Allowed, ClassElementTag::No);
          }
          failIfTrue(parseMode != SourceParseMode::MethodMode, &quot;Expected a parenthesis for argument list&quot;);
  
          consumeOrFail(COLON, &quot;Expected &#39;:&#39; after property name&quot;);
          TreeExpression node = parseAssignmentExpression(context);
          failIfFalse(node, &quot;Cannot parse expression for property declaration&quot;);
          context.setEndOffset(node, m_lexer-&gt;currentOffset());
<span class="line-modified">!         return context.createProperty(const_cast&lt;VM&amp;&gt;(m_vm), m_parserArena, propertyName, node, PropertyNode::Constant, PropertyNode::Unknown, complete, SuperBinding::NotNeeded, ClassElementTag::No);</span>
      }
      case OPENBRACKET: {
          next();
          auto propertyName = parseAssignmentExpression(context);
          failIfFalse(propertyName, &quot;Cannot parse computed property name&quot;);
          handleProductionOrFail(CLOSEBRACKET, &quot;]&quot;, &quot;end&quot;, &quot;computed property name&quot;);
  
          if (match(OPENPAREN)) {
<span class="line-modified">!             auto method = parsePropertyMethod(context, &amp;m_vm.propertyNames-&gt;nullIdentifier, parseMode);</span>
              propagateError();
              return context.createProperty(propertyName, method, static_cast&lt;PropertyNode::Type&gt;(PropertyNode::Constant | PropertyNode::Computed), PropertyNode::KnownDirect, complete, SuperBinding::Needed, ClassElementTag::No);
          }
          failIfTrue(parseMode != SourceParseMode::MethodMode, &quot;Expected a parenthesis for argument list&quot;);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4089,13 ***</span>
  
      JSTokenLocation location(tokenLocation());
  
      if (matchSpecIdentifier() || match(STRING) || m_token.m_type &amp; KeywordTokenFlag) {
          stringPropertyName = m_token.m_data.ident;
<span class="line-modified">!         semanticFailIfTrue(tag == ClassElementTag::Static &amp;&amp; *stringPropertyName == m_vm-&gt;propertyNames-&gt;prototype,</span>
              &quot;Cannot declare a static method named &#39;prototype&#39;&quot;);
<span class="line-modified">!         semanticFailIfTrue(tag == ClassElementTag::Instance &amp;&amp; *stringPropertyName == m_vm-&gt;propertyNames-&gt;constructor,</span>
              &quot;Cannot declare a getter or setter named &#39;constructor&#39;&quot;);
          next();
      } else if (match(DOUBLE) || match(INTEGER)) {
          numericPropertyName = m_token.m_data.doubleValue;
          next();
<span class="line-new-header">--- 4124,13 ---</span>
  
      JSTokenLocation location(tokenLocation());
  
      if (matchSpecIdentifier() || match(STRING) || m_token.m_type &amp; KeywordTokenFlag) {
          stringPropertyName = m_token.m_data.ident;
<span class="line-modified">!         semanticFailIfTrue(tag == ClassElementTag::Static &amp;&amp; *stringPropertyName == m_vm.propertyNames-&gt;prototype,</span>
              &quot;Cannot declare a static method named &#39;prototype&#39;&quot;);
<span class="line-modified">!         semanticFailIfTrue(tag == ClassElementTag::Instance &amp;&amp; *stringPropertyName == m_vm.propertyNames-&gt;constructor,</span>
              &quot;Cannot declare a getter or setter named &#39;constructor&#39;&quot;);
          next();
      } else if (match(DOUBLE) || match(INTEGER)) {
          numericPropertyName = m_token.m_data.doubleValue;
          next();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4120,11 ***</span>
          return context.createGetterOrSetterProperty(location, type, strict, stringPropertyName, info, tag);
  
      if (computedPropertyName)
          return context.createGetterOrSetterProperty(location, static_cast&lt;PropertyNode::Type&gt;(type | PropertyNode::Computed), strict, computedPropertyName, info, tag);
  
<span class="line-modified">!     return context.createGetterOrSetterProperty(const_cast&lt;VM*&gt;(m_vm), m_parserArena, location, type, strict, numericPropertyName, info, tag);</span>
  }
  
  template &lt;typename LexerType&gt;
  template &lt;class TreeBuilder&gt; bool Parser&lt;LexerType&gt;::shouldCheckPropertyForUnderscoreProtoDuplicate(TreeBuilder&amp; context, const TreeProperty&amp; property)
  {
<span class="line-new-header">--- 4155,11 ---</span>
          return context.createGetterOrSetterProperty(location, type, strict, stringPropertyName, info, tag);
  
      if (computedPropertyName)
          return context.createGetterOrSetterProperty(location, static_cast&lt;PropertyNode::Type&gt;(type | PropertyNode::Computed), strict, computedPropertyName, info, tag);
  
<span class="line-modified">!     return context.createGetterOrSetterProperty(const_cast&lt;VM&amp;&gt;(m_vm), m_parserArena, location, type, strict, numericPropertyName, info, tag);</span>
  }
  
  template &lt;typename LexerType&gt;
  template &lt;class TreeBuilder&gt; bool Parser&lt;LexerType&gt;::shouldCheckPropertyForUnderscoreProtoDuplicate(TreeBuilder&amp; context, const TreeProperty&amp; property)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4187,11 ***</span>
          return parseStrictObjectLiteral(context);
      }
  
      bool seenUnderscoreProto = false;
      if (shouldCheckPropertyForUnderscoreProtoDuplicate(context, property))
<span class="line-modified">!         seenUnderscoreProto = *context.getName(property) == m_vm-&gt;propertyNames-&gt;underscoreProto;</span>
  
      TreePropertyList propertyList = context.createPropertyList(location, property);
      TreePropertyList tail = propertyList;
      while (match(COMMA)) {
          next(TreeBuilder::DontBuildStrings);
<span class="line-new-header">--- 4222,11 ---</span>
          return parseStrictObjectLiteral(context);
      }
  
      bool seenUnderscoreProto = false;
      if (shouldCheckPropertyForUnderscoreProtoDuplicate(context, property))
<span class="line-modified">!         seenUnderscoreProto = *context.getName(property) == m_vm.propertyNames-&gt;underscoreProto;</span>
  
      TreePropertyList propertyList = context.createPropertyList(location, property);
      TreePropertyList tail = propertyList;
      while (match(COMMA)) {
          next(TreeBuilder::DontBuildStrings);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4203,11 ***</span>
          if (context.getType(property) &amp; (PropertyNode::Getter | PropertyNode::Setter)) {
              restoreSavePoint(savePoint);
              return parseStrictObjectLiteral(context);
          }
          if (shouldCheckPropertyForUnderscoreProtoDuplicate(context, property)) {
<span class="line-modified">!             if (*context.getName(property) == m_vm-&gt;propertyNames-&gt;underscoreProto) {</span>
                  semanticFailIfTrue(seenUnderscoreProto, &quot;Attempted to redefine __proto__ property&quot;);
                  seenUnderscoreProto = true;
              }
          }
          tail = context.createPropertyList(propertyLocation, property, tail);
<span class="line-new-header">--- 4238,11 ---</span>
          if (context.getType(property) &amp; (PropertyNode::Getter | PropertyNode::Setter)) {
              restoreSavePoint(savePoint);
              return parseStrictObjectLiteral(context);
          }
          if (shouldCheckPropertyForUnderscoreProtoDuplicate(context, property)) {
<span class="line-modified">!             if (*context.getName(property) == m_vm.propertyNames-&gt;underscoreProto) {</span>
                  semanticFailIfTrue(seenUnderscoreProto, &quot;Attempted to redefine __proto__ property&quot;);
                  seenUnderscoreProto = true;
              }
          }
          tail = context.createPropertyList(propertyLocation, property, tail);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4237,11 ***</span>
      TreeProperty property = parseProperty(context, true);
      failIfFalse(property, &quot;Cannot parse object literal property&quot;);
  
      bool seenUnderscoreProto = false;
      if (shouldCheckPropertyForUnderscoreProtoDuplicate(context, property))
<span class="line-modified">!         seenUnderscoreProto = *context.getName(property) == m_vm-&gt;propertyNames-&gt;underscoreProto;</span>
  
      TreePropertyList propertyList = context.createPropertyList(location, property);
      TreePropertyList tail = propertyList;
      while (match(COMMA)) {
          next();
<span class="line-new-header">--- 4272,11 ---</span>
      TreeProperty property = parseProperty(context, true);
      failIfFalse(property, &quot;Cannot parse object literal property&quot;);
  
      bool seenUnderscoreProto = false;
      if (shouldCheckPropertyForUnderscoreProtoDuplicate(context, property))
<span class="line-modified">!         seenUnderscoreProto = *context.getName(property) == m_vm.propertyNames-&gt;underscoreProto;</span>
  
      TreePropertyList propertyList = context.createPropertyList(location, property);
      TreePropertyList tail = propertyList;
      while (match(COMMA)) {
          next();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4249,11 ***</span>
              break;
          JSTokenLocation propertyLocation(tokenLocation());
          property = parseProperty(context, true);
          failIfFalse(property, &quot;Cannot parse object literal property&quot;);
          if (shouldCheckPropertyForUnderscoreProtoDuplicate(context, property)) {
<span class="line-modified">!             if (*context.getName(property) == m_vm-&gt;propertyNames-&gt;underscoreProto) {</span>
                  semanticFailIfTrue(seenUnderscoreProto, &quot;Attempted to redefine __proto__ property&quot;);
                  seenUnderscoreProto = true;
              }
          }
          tail = context.createPropertyList(propertyLocation, property, tail);
<span class="line-new-header">--- 4284,11 ---</span>
              break;
          JSTokenLocation propertyLocation(tokenLocation());
          property = parseProperty(context, true);
          failIfFalse(property, &quot;Cannot parse object literal property&quot;);
          if (shouldCheckPropertyForUnderscoreProtoDuplicate(context, property)) {
<span class="line-modified">!             if (*context.getName(property) == m_vm.propertyNames-&gt;underscoreProto) {</span>
                  semanticFailIfTrue(seenUnderscoreProto, &quot;Attempted to redefine __proto__ property&quot;);
                  seenUnderscoreProto = true;
              }
          }
          tail = context.createPropertyList(propertyLocation, property, tail);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4344,11 ***</span>
  template &lt;typename LexerType&gt;
  template &lt;class TreeBuilder&gt; TreeClassExpression Parser&lt;LexerType&gt;::parseClassExpression(TreeBuilder&amp; context)
  {
      ASSERT(match(CLASSTOKEN));
      ParserClassInfo&lt;TreeBuilder&gt; info;
<span class="line-modified">!     info.className = &amp;m_vm-&gt;propertyNames-&gt;nullIdentifier;</span>
      return parseClass(context, FunctionNameRequirements::None, info);
  }
  
  template &lt;typename LexerType&gt;
  template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseFunctionExpression(TreeBuilder&amp; context)
<span class="line-new-header">--- 4379,11 ---</span>
  template &lt;typename LexerType&gt;
  template &lt;class TreeBuilder&gt; TreeClassExpression Parser&lt;LexerType&gt;::parseClassExpression(TreeBuilder&amp; context)
  {
      ASSERT(match(CLASSTOKEN));
      ParserClassInfo&lt;TreeBuilder&gt; info;
<span class="line-modified">!     info.className = &amp;m_vm.propertyNames-&gt;nullIdentifier;</span>
      return parseClass(context, FunctionNameRequirements::None, info);
  }
  
  template &lt;typename LexerType&gt;
  template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseFunctionExpression(TreeBuilder&amp; context)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4356,11 ***</span>
      ASSERT(match(FUNCTION));
      JSTokenLocation location(tokenLocation());
      unsigned functionKeywordStart = tokenStart();
      next();
      ParserFunctionInfo&lt;TreeBuilder&gt; functionInfo;
<span class="line-modified">!     functionInfo.name = &amp;m_vm-&gt;propertyNames-&gt;nullIdentifier;</span>
      SourceParseMode parseMode = SourceParseMode::NormalFunctionMode;
      if (consume(TIMES))
          parseMode = SourceParseMode::GeneratorWrapperFunctionMode;
      failIfFalse((parseFunctionInfo(context, FunctionNameRequirements::None, parseMode, false, ConstructorKind::None, SuperBinding::NotNeeded, functionKeywordStart, functionInfo, FunctionDefinitionType::Expression)), &quot;Cannot parse function expression&quot;);
      return context.createFunctionExpr(location, functionInfo);
<span class="line-new-header">--- 4391,11 ---</span>
      ASSERT(match(FUNCTION));
      JSTokenLocation location(tokenLocation());
      unsigned functionKeywordStart = tokenStart();
      next();
      ParserFunctionInfo&lt;TreeBuilder&gt; functionInfo;
<span class="line-modified">!     functionInfo.name = &amp;m_vm.propertyNames-&gt;nullIdentifier;</span>
      SourceParseMode parseMode = SourceParseMode::NormalFunctionMode;
      if (consume(TIMES))
          parseMode = SourceParseMode::GeneratorWrapperFunctionMode;
      failIfFalse((parseFunctionInfo(context, FunctionNameRequirements::None, parseMode, false, ConstructorKind::None, SuperBinding::NotNeeded, functionKeywordStart, functionInfo, FunctionDefinitionType::Expression)), &quot;Cannot parse function expression&quot;);
      return context.createFunctionExpr(location, functionInfo);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4377,11 ***</span>
  
      if (consume(TIMES))
          parseMode = SourceParseMode::AsyncGeneratorWrapperFunctionMode;
  
      ParserFunctionInfo&lt;TreeBuilder&gt; functionInfo;
<span class="line-modified">!     functionInfo.name = &amp;m_vm-&gt;propertyNames-&gt;nullIdentifier;</span>
      failIfFalse(parseFunctionInfo(context, FunctionNameRequirements::None, parseMode, false, ConstructorKind::None, SuperBinding::NotNeeded, functionKeywordStart, functionInfo, FunctionDefinitionType::Expression), parseMode == SourceParseMode::AsyncFunctionMode ? &quot;Cannot parse async function expression&quot; : &quot;Cannot parse async generator function expression&quot;);
      return context.createFunctionExpr(location, functionInfo);
  }
  
  template &lt;typename LexerType&gt;
<span class="line-new-header">--- 4412,11 ---</span>
  
      if (consume(TIMES))
          parseMode = SourceParseMode::AsyncGeneratorWrapperFunctionMode;
  
      ParserFunctionInfo&lt;TreeBuilder&gt; functionInfo;
<span class="line-modified">!     functionInfo.name = &amp;m_vm.propertyNames-&gt;nullIdentifier;</span>
      failIfFalse(parseFunctionInfo(context, FunctionNameRequirements::None, parseMode, false, ConstructorKind::None, SuperBinding::NotNeeded, functionKeywordStart, functionInfo, FunctionDefinitionType::Expression), parseMode == SourceParseMode::AsyncFunctionMode ? &quot;Cannot parse async function expression&quot; : &quot;Cannot parse async generator function expression&quot;);
      return context.createFunctionExpr(location, functionInfo);
  }
  
  template &lt;typename LexerType&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4489,11 ***</span>
          else if (currentFunctionScope()-&gt;isAsyncFunctionBoundary())
              return parseAwaitExpression(context);
  
          goto identifierExpression;
      case IDENT: {
<span class="line-modified">!         if (UNLIKELY(*m_token.m_data.ident == m_vm-&gt;propertyNames-&gt;async &amp;&amp; !m_token.m_data.escaped)) {</span>
              JSTextPosition start = tokenStartPosition();
              const Identifier* ident = m_token.m_data.ident;
              JSTokenLocation location(tokenLocation());
              next();
              if (match(FUNCTION) &amp;&amp; !m_lexer-&gt;hasLineTerminatorBeforeToken())
<span class="line-new-header">--- 4524,11 ---</span>
          else if (currentFunctionScope()-&gt;isAsyncFunctionBoundary())
              return parseAwaitExpression(context);
  
          goto identifierExpression;
      case IDENT: {
<span class="line-modified">!         if (UNLIKELY(*m_token.m_data.ident == m_vm.propertyNames-&gt;async &amp;&amp; !m_token.m_data.escaped)) {</span>
              JSTextPosition start = tokenStartPosition();
              const Identifier* ident = m_token.m_data.ident;
              JSTokenLocation location(tokenLocation());
              next();
              if (match(FUNCTION) &amp;&amp; !m_lexer-&gt;hasLineTerminatorBeforeToken())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4514,11 ***</span>
  
          // Avoid using variable if it is an arrow function parameter
          if (UNLIKELY(match(ARROWFUNCTION)))
              return 0;
  
<span class="line-modified">!         return createResolveAndUseVariable(context, ident, *ident == m_vm-&gt;propertyNames-&gt;eval, start, location);</span>
      }
      case BIGINT: {
          const Identifier* ident = m_token.m_data.bigIntString;
          uint8_t radix = m_token.m_data.radix;
          JSTokenLocation location(tokenLocation());
<span class="line-new-header">--- 4549,11 ---</span>
  
          // Avoid using variable if it is an arrow function parameter
          if (UNLIKELY(match(ARROWFUNCTION)))
              return 0;
  
<span class="line-modified">!         return createResolveAndUseVariable(context, ident, *ident == m_vm.propertyNames-&gt;eval, start, location);</span>
      }
      case BIGINT: {
          const Identifier* ident = m_token.m_data.bigIntString;
          uint8_t radix = m_token.m_data.radix;
          JSTokenLocation location(tokenLocation());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4699,11 ***</span>
      semanticFailIfTrue((baseIsSuper || baseIsImport) &amp;&amp; newCount, &quot;Cannot use new with &quot;, getToken());
  
      bool baseIsNewTarget = false;
      if (newCount &amp;&amp; match(DOT)) {
          next();
<span class="line-modified">!         if (matchContextualKeyword(m_vm-&gt;propertyNames-&gt;target)) {</span>
              ScopeRef closestOrdinaryFunctionScope = closestParentOrdinaryFunctionNonLexicalScope();
              semanticFailIfFalse(currentScope()-&gt;isFunction() || closestOrdinaryFunctionScope-&gt;evalContextType() == EvalContextType::FunctionEvalContext, &quot;new.target is only valid inside functions&quot;);
              baseIsNewTarget = true;
              if (currentScope()-&gt;isArrowFunction()) {
                  semanticFailIfFalse(!closestOrdinaryFunctionScope-&gt;isGlobalCodeScope() || closestOrdinaryFunctionScope-&gt;evalContextType() == EvalContextType::FunctionEvalContext, &quot;new.target is not valid inside arrow functions in global code&quot;);
<span class="line-new-header">--- 4734,11 ---</span>
      semanticFailIfTrue((baseIsSuper || baseIsImport) &amp;&amp; newCount, &quot;Cannot use new with &quot;, getToken());
  
      bool baseIsNewTarget = false;
      if (newCount &amp;&amp; match(DOT)) {
          next();
<span class="line-modified">!         if (matchContextualKeyword(m_vm.propertyNames-&gt;target)) {</span>
              ScopeRef closestOrdinaryFunctionScope = closestParentOrdinaryFunctionNonLexicalScope();
              semanticFailIfFalse(currentScope()-&gt;isFunction() || closestOrdinaryFunctionScope-&gt;evalContextType() == EvalContextType::FunctionEvalContext, &quot;new.target is only valid inside functions&quot;);
              baseIsNewTarget = true;
              if (currentScope()-&gt;isArrowFunction()) {
                  semanticFailIfFalse(!closestOrdinaryFunctionScope-&gt;isGlobalCodeScope() || closestOrdinaryFunctionScope-&gt;evalContextType() == EvalContextType::FunctionEvalContext, &quot;new.target is not valid inside arrow functions in global code&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4740,13 ***</span>
          }
      } else if (baseIsImport) {
          next();
          JSTextPosition expressionEnd = lastTokenEndPosition();
          if (consume(DOT)) {
<span class="line-modified">!             if (matchContextualKeyword(m_vm-&gt;propertyNames-&gt;builtinNames().metaPublicName())) {</span>
                  semanticFailIfFalse(m_scriptMode == JSParserScriptMode::Module, &quot;import.meta is only valid inside modules&quot;);
<span class="line-modified">!                 base = context.createImportMetaExpr(location, createResolveAndUseVariable(context, &amp;m_vm-&gt;propertyNames-&gt;metaPrivateName, false, expressionStart, location));</span>
                  next();
              } else {
                  failIfTrue(match(IDENT), &quot;\&quot;import.\&quot; can only followed with meta&quot;);
                  failDueToUnexpectedToken();
              }
<span class="line-new-header">--- 4775,13 ---</span>
          }
      } else if (baseIsImport) {
          next();
          JSTextPosition expressionEnd = lastTokenEndPosition();
          if (consume(DOT)) {
<span class="line-modified">!             if (matchContextualKeyword(m_vm.propertyNames-&gt;builtinNames().metaPublicName())) {</span>
                  semanticFailIfFalse(m_scriptMode == JSParserScriptMode::Module, &quot;import.meta is only valid inside modules&quot;);
<span class="line-modified">!                 base = context.createImportMetaExpr(location, createResolveAndUseVariable(context, &amp;m_vm.propertyNames-&gt;metaPrivateName, false, expressionStart, location));</span>
                  next();
              } else {
                  failIfTrue(match(IDENT), &quot;\&quot;import.\&quot; can only followed with meta&quot;);
                  failDueToUnexpectedToken();
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4756,11 ***</span>
              failIfFalse(expr, &quot;Cannot parse expression&quot;);
              consumeOrFail(CLOSEPAREN, &quot;import call expects exactly one argument&quot;);
              base = context.createImportExpr(location, expr, expressionStart, expressionEnd, lastTokenEndPosition());
          }
      } else if (!baseIsNewTarget) {
<span class="line-modified">!         const bool isAsync = matchContextualKeyword(m_vm-&gt;propertyNames-&gt;async);</span>
  
          base = parsePrimaryExpression(context);
          failIfFalse(base, &quot;Cannot parse base expression&quot;);
          if (UNLIKELY(isAsync &amp;&amp; context.isResolve(base) &amp;&amp; !m_lexer-&gt;hasLineTerminatorBeforeToken())) {
              if (matchSpecIdentifier()) {
<span class="line-new-header">--- 4791,11 ---</span>
              failIfFalse(expr, &quot;Cannot parse expression&quot;);
              consumeOrFail(CLOSEPAREN, &quot;import call expects exactly one argument&quot;);
              base = context.createImportExpr(location, expr, expressionStart, expressionEnd, lastTokenEndPosition());
          }
      } else if (!baseIsNewTarget) {
<span class="line-modified">!         const bool isAsync = matchContextualKeyword(m_vm.propertyNames-&gt;async);</span>
  
          base = parsePrimaryExpression(context);
          failIfFalse(base, &quot;Cannot parse base expression&quot;);
          if (UNLIKELY(isAsync &amp;&amp; context.isResolve(base) &amp;&amp; !m_lexer-&gt;hasLineTerminatorBeforeToken())) {
              if (matchSpecIdentifier()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4771,107 ***</span>
              baseIsAsyncKeyword = true;
          }
      }
  
      failIfFalse(base, &quot;Cannot parse base expression&quot;);
<span class="line-removed">-     while (true) {</span>
<span class="line-removed">-         location = tokenLocation();</span>
<span class="line-removed">-         switch (m_token.m_type) {</span>
<span class="line-removed">-         case OPENBRACKET: {</span>
<span class="line-removed">-             m_parserState.nonTrivialExpressionCount++;</span>
<span class="line-removed">-             JSTextPosition expressionEnd = lastTokenEndPosition();</span>
<span class="line-removed">-             next();</span>
<span class="line-removed">-             int nonLHSCount = m_parserState.nonLHSCount;</span>
<span class="line-removed">-             int initialAssignments = m_parserState.assignmentCount;</span>
<span class="line-removed">-             TreeExpression property = parseExpression(context);</span>
<span class="line-removed">-             failIfFalse(property, &quot;Cannot parse subscript expression&quot;);</span>
<span class="line-removed">-             base = context.createBracketAccess(startLocation, base, property, initialAssignments != m_parserState.assignmentCount, expressionStart, expressionEnd, tokenEndPosition());</span>
  
<span class="line-modified">!             if (UNLIKELY(baseIsSuper &amp;&amp; currentScope()-&gt;isArrowFunction()))</span>
<span class="line-modified">!                 currentFunctionScope()-&gt;setInnerArrowFunctionUsesSuperProperty();</span>
  
<span class="line-modified">!             handleProductionOrFail(CLOSEBRACKET, &quot;]&quot;, &quot;end&quot;, &quot;subscript expression&quot;);</span>
<span class="line-modified">!             m_parserState.nonLHSCount = nonLHSCount;</span>
<span class="line-modified">!             break;</span>
          }
<span class="line-modified">!         case OPENPAREN: {</span>
<span class="line-modified">!             m_parserState.nonTrivialExpressionCount++;</span>
<span class="line-modified">!             int nonLHSCount = m_parserState.nonLHSCount;</span>
<span class="line-modified">!             if (newCount) {</span>
<span class="line-modified">!                 newCount--;</span>
<span class="line-modified">!                 JSTextPosition expressionEnd = lastTokenEndPosition();</span>
<span class="line-removed">-                 TreeArguments arguments = parseArguments(context);</span>
<span class="line-removed">-                 failIfFalse(arguments, &quot;Cannot parse call arguments&quot;);</span>
<span class="line-removed">-                 base = context.createNewExpr(location, base, arguments, expressionStart, expressionEnd, lastTokenEndPosition());</span>
<span class="line-removed">-             } else {</span>
<span class="line-removed">-                 size_t usedVariablesSize = currentScope()-&gt;currentUsedVariablesSize();</span>
                  JSTextPosition expressionEnd = lastTokenEndPosition();
<span class="line-modified">!                 Optional&lt;CallOrApplyDepthScope&gt; callOrApplyDepthScope;</span>
<span class="line-modified">!                 recordCallOrApplyDepth&lt;TreeBuilder&gt;(this, *m_vm, callOrApplyDepthScope, base);</span>
  
<span class="line-modified">!                 TreeArguments arguments = parseArguments(context);</span>
  
<span class="line-modified">!                 if (baseIsAsyncKeyword &amp;&amp; (!arguments || match(ARROWFUNCTION))) {</span>
<span class="line-modified">!                     currentScope()-&gt;revertToPreviousUsedVariables(usedVariablesSize);</span>
<span class="line-modified">!                     forceClassifyExpressionError(ErrorIndicatesAsyncArrowFunction);</span>
<span class="line-modified">!                     failDueToUnexpectedToken();</span>
<span class="line-modified">!                 }</span>
  
<span class="line-modified">!                 failIfFalse(arguments, &quot;Cannot parse call arguments&quot;);</span>
<span class="line-modified">!                 if (baseIsSuper) {</span>
<span class="line-modified">!                     ScopeRef functionScope = currentFunctionScope();</span>
<span class="line-modified">!                     if (!functionScope-&gt;setHasDirectSuper()) {</span>
<span class="line-modified">!                         // It unnecessary to check of using super during reparsing one more time. Also it can lead to syntax error</span>
<span class="line-modified">!                         // in case of arrow function because during reparsing we don&#39;t know whether we currently parse the arrow function</span>
<span class="line-modified">!                         // inside of the constructor or method.</span>
<span class="line-modified">!                         if (!m_lexer-&gt;isReparsingFunction()) {</span>
<span class="line-modified">!                             ScopeRef closestOrdinaryFunctionScope = closestParentOrdinaryFunctionNonLexicalScope();</span>
<span class="line-modified">!                             ConstructorKind functionConstructorKind = !functionScope-&gt;isArrowFunction() &amp;&amp; !closestOrdinaryFunctionScope-&gt;isEvalContext()</span>
<span class="line-modified">!                                 ? functionScope-&gt;constructorKind()</span>
<span class="line-modified">!                                 : closestOrdinaryFunctionScope-&gt;constructorKind();</span>
<span class="line-modified">!                             semanticFailIfTrue(functionConstructorKind == ConstructorKind::None, &quot;super is not valid in this context&quot;);</span>
<span class="line-modified">!                             semanticFailIfTrue(functionConstructorKind != ConstructorKind::Extends, &quot;super is not valid in this context&quot;);</span>
                          }
                      }
<span class="line-modified">!                     if (currentScope()-&gt;isArrowFunction())</span>
<span class="line-modified">!                         functionScope-&gt;setInnerArrowFunctionUsesSuperCall();</span>
                  }
<span class="line-modified">!                 base = context.makeFunctionCallNode(startLocation, base, previousBaseWasSuper, arguments, expressionStart,</span>
<span class="line-modified">!                     expressionEnd, lastTokenEndPosition(), callOrApplyDepthScope ? callOrApplyDepthScope-&gt;distanceToInnermostChild() : 0);</span>
              }
<span class="line-modified">!             m_parserState.nonLHSCount = nonLHSCount;</span>
<span class="line-modified">!             break;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         case DOT: {</span>
<span class="line-modified">!             m_parserState.nonTrivialExpressionCount++;</span>
<span class="line-modified">!             JSTextPosition expressionEnd = lastTokenEndPosition();</span>
<span class="line-modified">!             nextExpectIdentifier(LexerFlagsIgnoreReservedWords | TreeBuilder::DontBuildKeywords);</span>
<span class="line-modified">!             matchOrFail(IDENT, &quot;Expected a property name after &#39;.&#39;&quot;);</span>
<span class="line-modified">!             base = context.createDotAccess(startLocation, base, m_token.m_data.ident, expressionStart, expressionEnd, tokenEndPosition());</span>
<span class="line-modified">!             if (UNLIKELY(baseIsSuper &amp;&amp; currentScope()-&gt;isArrowFunction()))</span>
<span class="line-modified">!                 currentFunctionScope()-&gt;setInnerArrowFunctionUsesSuperProperty();</span>
<span class="line-modified">!             next();</span>
<span class="line-modified">!             break;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         case BACKQUOTE: {</span>
<span class="line-modified">!             semanticFailIfTrue(baseIsSuper, &quot;Cannot use super as tag for tagged templates&quot;);</span>
<span class="line-modified">!             JSTextPosition expressionEnd = lastTokenEndPosition();</span>
<span class="line-modified">!             int nonLHSCount = m_parserState.nonLHSCount;</span>
<span class="line-modified">!             typename TreeBuilder::TemplateLiteral templateLiteral = parseTemplateLiteral(context, LexerType::RawStringsBuildMode::BuildRawStrings);</span>
<span class="line-modified">!             failIfFalse(templateLiteral, &quot;Cannot parse template literal&quot;);</span>
<span class="line-modified">!             base = context.createTaggedTemplate(startLocation, base, templateLiteral, expressionStart, expressionEnd, lastTokenEndPosition());</span>
<span class="line-modified">!             m_parserState.nonLHSCount = nonLHSCount;</span>
<span class="line-modified">!             m_seenTaggedTemplate = true;</span>
<span class="line-modified">!             break;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         default:</span>
<span class="line-modified">!             goto endMemberExpression;</span>
          }
<span class="line-modified">!         previousBaseWasSuper = baseIsSuper;</span>
<span class="line-modified">!         baseIsSuper = false;</span>
<span class="line-modified">!     }</span>
<span class="line-modified">! endMemberExpression:</span>
      semanticFailIfTrue(baseIsSuper, &quot;super is not valid in this context&quot;);
      while (newCount--)
          base = context.createNewExpr(location, base, expressionStart, lastTokenEndPosition());
      return base;
  }
<span class="line-new-header">--- 4806,140 ---</span>
              baseIsAsyncKeyword = true;
          }
      }
  
      failIfFalse(base, &quot;Cannot parse base expression&quot;);
  
<span class="line-modified">!     do {</span>
<span class="line-modified">!         TreeExpression optionalChainBase = 0;</span>
<span class="line-added">+         JSTokenLocation optionalChainLocation;</span>
<span class="line-added">+         JSTokenType type = m_token.m_type;</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (match(QUESTIONDOT)) {</span>
<span class="line-added">+             semanticFailIfTrue(newCount, &quot;Cannot call constructor in an optional chain&quot;);</span>
<span class="line-added">+             semanticFailIfTrue(baseIsSuper, &quot;Cannot use super as the base of an optional chain&quot;);</span>
<span class="line-added">+             optionalChainBase = base;</span>
<span class="line-added">+             optionalChainLocation = tokenLocation();</span>
  
<span class="line-modified">!             SavePoint savePoint = createSavePoint();</span>
<span class="line-modified">!             next();</span>
<span class="line-modified">!             if (match(OPENBRACKET) || match(OPENPAREN) || match(BACKQUOTE))</span>
<span class="line-added">+                 type = m_token.m_type;</span>
<span class="line-added">+             else {</span>
<span class="line-added">+                 type = DOT;</span>
<span class="line-added">+                 restoreSavePoint(savePoint);</span>
<span class="line-added">+             }</span>
          }
<span class="line-modified">! </span>
<span class="line-modified">!         while (true) {</span>
<span class="line-modified">!             location = tokenLocation();</span>
<span class="line-modified">!             switch (type) {</span>
<span class="line-modified">!             case OPENBRACKET: {</span>
<span class="line-modified">!                 m_parserState.nonTrivialExpressionCount++;</span>
                  JSTextPosition expressionEnd = lastTokenEndPosition();
<span class="line-modified">!                 next();</span>
<span class="line-modified">!                 int nonLHSCount = m_parserState.nonLHSCount;</span>
<span class="line-added">+                 int initialAssignments = m_parserState.assignmentCount;</span>
<span class="line-added">+                 TreeExpression property = parseExpression(context);</span>
<span class="line-added">+                 failIfFalse(property, &quot;Cannot parse subscript expression&quot;);</span>
<span class="line-added">+                 base = context.createBracketAccess(startLocation, base, property, initialAssignments != m_parserState.assignmentCount, expressionStart, expressionEnd, tokenEndPosition());</span>
  
<span class="line-modified">!                 if (UNLIKELY(baseIsSuper &amp;&amp; currentScope()-&gt;isArrowFunction()))</span>
<span class="line-added">+                     currentFunctionScope()-&gt;setInnerArrowFunctionUsesSuperProperty();</span>
  
<span class="line-modified">!                 handleProductionOrFail(CLOSEBRACKET, &quot;]&quot;, &quot;end&quot;, &quot;subscript expression&quot;);</span>
<span class="line-modified">!                 m_parserState.nonLHSCount = nonLHSCount;</span>
<span class="line-modified">!                 break;</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!             case OPENPAREN: {</span>
<span class="line-added">+                 m_parserState.nonTrivialExpressionCount++;</span>
<span class="line-added">+                 int nonLHSCount = m_parserState.nonLHSCount;</span>
<span class="line-added">+                 if (newCount) {</span>
<span class="line-added">+                     newCount--;</span>
<span class="line-added">+                     JSTextPosition expressionEnd = lastTokenEndPosition();</span>
<span class="line-added">+                     TreeArguments arguments = parseArguments(context);</span>
<span class="line-added">+                     failIfFalse(arguments, &quot;Cannot parse call arguments&quot;);</span>
<span class="line-added">+                     base = context.createNewExpr(location, base, arguments, expressionStart, expressionEnd, lastTokenEndPosition());</span>
<span class="line-added">+                 } else {</span>
<span class="line-added">+                     size_t usedVariablesSize = currentScope()-&gt;currentUsedVariablesSize();</span>
<span class="line-added">+                     JSTextPosition expressionEnd = lastTokenEndPosition();</span>
<span class="line-added">+                     Optional&lt;CallOrApplyDepthScope&gt; callOrApplyDepthScope;</span>
<span class="line-added">+                     recordCallOrApplyDepth&lt;TreeBuilder&gt;(this, m_vm, callOrApplyDepthScope, base);</span>
<span class="line-added">+ </span>
<span class="line-added">+                     TreeArguments arguments = parseArguments(context);</span>
  
<span class="line-modified">!                     if (baseIsAsyncKeyword &amp;&amp; (!arguments || match(ARROWFUNCTION))) {</span>
<span class="line-modified">!                         currentScope()-&gt;revertToPreviousUsedVariables(usedVariablesSize);</span>
<span class="line-modified">!                         forceClassifyExpressionError(ErrorIndicatesAsyncArrowFunction);</span>
<span class="line-modified">!                         failDueToUnexpectedToken();</span>
<span class="line-modified">!                     }</span>
<span class="line-modified">! </span>
<span class="line-modified">!                     failIfFalse(arguments, &quot;Cannot parse call arguments&quot;);</span>
<span class="line-modified">!                     if (baseIsSuper) {</span>
<span class="line-modified">!                         ScopeRef functionScope = currentFunctionScope();</span>
<span class="line-modified">!                         if (!functionScope-&gt;setHasDirectSuper()) {</span>
<span class="line-modified">!                             // It unnecessary to check of using super during reparsing one more time. Also it can lead to syntax error</span>
<span class="line-modified">!                             // in case of arrow function because during reparsing we don&#39;t know whether we currently parse the arrow function</span>
<span class="line-modified">!                             // inside of the constructor or method.</span>
<span class="line-modified">!                             if (!m_lexer-&gt;isReparsingFunction()) {</span>
<span class="line-added">+                                 ScopeRef closestOrdinaryFunctionScope = closestParentOrdinaryFunctionNonLexicalScope();</span>
<span class="line-added">+                                 ConstructorKind functionConstructorKind = !functionScope-&gt;isArrowFunction() &amp;&amp; !closestOrdinaryFunctionScope-&gt;isEvalContext()</span>
<span class="line-added">+                                     ? functionScope-&gt;constructorKind()</span>
<span class="line-added">+                                     : closestOrdinaryFunctionScope-&gt;constructorKind();</span>
<span class="line-added">+                                 semanticFailIfTrue(functionConstructorKind == ConstructorKind::None, &quot;super is not valid in this context&quot;);</span>
<span class="line-added">+                                 semanticFailIfTrue(functionConstructorKind != ConstructorKind::Extends, &quot;super is not valid in this context&quot;);</span>
<span class="line-added">+                             }</span>
                          }
<span class="line-added">+                         if (currentScope()-&gt;isArrowFunction())</span>
<span class="line-added">+                             functionScope-&gt;setInnerArrowFunctionUsesSuperCall();</span>
                      }
<span class="line-modified">! </span>
<span class="line-modified">!                     bool isOptionalCall = optionalChainLocation.endOffset == static_cast&lt;unsigned&gt;(expressionEnd.offset);</span>
<span class="line-added">+                     base = context.makeFunctionCallNode(startLocation, base, previousBaseWasSuper, arguments, expressionStart,</span>
<span class="line-added">+                         expressionEnd, lastTokenEndPosition(), callOrApplyDepthScope ? callOrApplyDepthScope-&gt;distanceToInnermostChild() : 0, isOptionalCall);</span>
<span class="line-added">+ </span>
<span class="line-added">+                     if (isOptionalCall)</span>
<span class="line-added">+                         optionalChainBase = base;</span>
                  }
<span class="line-modified">!                 m_parserState.nonLHSCount = nonLHSCount;</span>
<span class="line-modified">!                 break;</span>
              }
<span class="line-modified">!             case DOT: {</span>
<span class="line-modified">!                 m_parserState.nonTrivialExpressionCount++;</span>
<span class="line-modified">!                 JSTextPosition expressionEnd = lastTokenEndPosition();</span>
<span class="line-modified">!                 nextExpectIdentifier(LexerFlagsIgnoreReservedWords | TreeBuilder::DontBuildKeywords);</span>
<span class="line-modified">!                 matchOrFail(IDENT, &quot;Expected a property name after &quot;, optionalChainBase ? &quot;&#39;?.&#39;&quot; : &quot;&#39;.&#39;&quot;);</span>
<span class="line-modified">!                 base = context.createDotAccess(startLocation, base, m_token.m_data.ident, expressionStart, expressionEnd, tokenEndPosition());</span>
<span class="line-modified">!                 if (UNLIKELY(baseIsSuper &amp;&amp; currentScope()-&gt;isArrowFunction()))</span>
<span class="line-modified">!                     currentFunctionScope()-&gt;setInnerArrowFunctionUsesSuperProperty();</span>
<span class="line-modified">!                 next();</span>
<span class="line-modified">!                 break;</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!             case BACKQUOTE: {</span>
<span class="line-modified">!                 semanticFailIfTrue(optionalChainBase, &quot;Cannot use tagged templates in an optional chain&quot;);</span>
<span class="line-modified">!                 semanticFailIfTrue(baseIsSuper, &quot;Cannot use super as tag for tagged templates&quot;);</span>
<span class="line-modified">!                 JSTextPosition expressionEnd = lastTokenEndPosition();</span>
<span class="line-modified">!                 int nonLHSCount = m_parserState.nonLHSCount;</span>
<span class="line-modified">!                 typename TreeBuilder::TemplateLiteral templateLiteral = parseTemplateLiteral(context, LexerType::RawStringsBuildMode::BuildRawStrings);</span>
<span class="line-modified">!                 failIfFalse(templateLiteral, &quot;Cannot parse template literal&quot;);</span>
<span class="line-modified">!                 base = context.createTaggedTemplate(startLocation, base, templateLiteral, expressionStart, expressionEnd, lastTokenEndPosition());</span>
<span class="line-modified">!                 m_parserState.nonLHSCount = nonLHSCount;</span>
<span class="line-modified">!                 m_seenTaggedTemplate = true;</span>
<span class="line-modified">!                 break;</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!             default:</span>
<span class="line-modified">!                 goto endOfChain;</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!             previousBaseWasSuper = baseIsSuper;</span>
<span class="line-added">+             baseIsSuper = false;</span>
<span class="line-added">+             type = m_token.m_type;</span>
          }
<span class="line-modified">! endOfChain:</span>
<span class="line-modified">!         if (optionalChainBase)</span>
<span class="line-modified">!             base = context.createOptionalChain(optionalChainLocation, optionalChainBase, base, !match(QUESTIONDOT));</span>
<span class="line-modified">!     } while (match(QUESTIONDOT));</span>
<span class="line-added">+ </span>
      semanticFailIfTrue(baseIsSuper, &quot;super is not valid in this context&quot;);
      while (newCount--)
          base = context.createNewExpr(location, base, expressionStart, lastTokenEndPosition());
      return base;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4882,11 ***</span>
      JSTokenLocation location;
  
      unsigned functionKeywordStart = tokenStart();
      location = tokenLocation();
      ParserFunctionInfo&lt;TreeBuilder&gt; info;
<span class="line-modified">!     info.name = &amp;m_vm-&gt;propertyNames-&gt;nullIdentifier;</span>
  
      SourceParseMode parseMode = isAsync ? SourceParseMode::AsyncArrowFunctionMode : SourceParseMode::ArrowFunctionMode;
      failIfFalse((parseFunctionInfo(context, FunctionNameRequirements::Unnamed, parseMode, true, ConstructorKind::None, SuperBinding::NotNeeded, functionKeywordStart, info, FunctionDefinitionType::Expression)), &quot;Cannot parse arrow function expression&quot;);
  
      return context.createArrowFunctionExpr(location, info);
<span class="line-new-header">--- 4950,11 ---</span>
      JSTokenLocation location;
  
      unsigned functionKeywordStart = tokenStart();
      location = tokenLocation();
      ParserFunctionInfo&lt;TreeBuilder&gt; info;
<span class="line-modified">!     info.name = &amp;m_vm.propertyNames-&gt;nullIdentifier;</span>
  
      SourceParseMode parseMode = isAsync ? SourceParseMode::AsyncArrowFunctionMode : SourceParseMode::ArrowFunctionMode;
      failIfFalse((parseFunctionInfo(context, FunctionNameRequirements::Unnamed, parseMode, true, ConstructorKind::None, SuperBinding::NotNeeded, functionKeywordStart, info, FunctionDefinitionType::Expression)), &quot;Cannot parse arrow function expression&quot;);
  
      return context.createArrowFunctionExpr(location, info);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4926,34 ***</span>
  template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseUnaryExpression(TreeBuilder&amp; context)
  {
      typename TreeBuilder::UnaryExprContext unaryExprContext(context);
      AllowInOverride allowInOverride(this);
      int tokenStackDepth = 0;
<span class="line-modified">!     bool modifiesExpr = false;</span>
<span class="line-removed">-     bool requiresLExpr = false;</span>
      unsigned lastOperator = 0;
  
      if (UNLIKELY(match(AWAIT) &amp;&amp; currentFunctionScope()-&gt;isAsyncFunctionBoundary()))
          return parseAwaitExpression(context);
  
      JSTokenLocation location(tokenLocation());
  
      while (isUnaryOp(m_token.m_type)) {
<span class="line-modified">!         if (strictMode()) {</span>
<span class="line-modified">!             switch (m_token.m_type) {</span>
<span class="line-modified">!             case PLUSPLUS:</span>
<span class="line-modified">!             case MINUSMINUS:</span>
<span class="line-modified">!             case AUTOPLUSPLUS:</span>
<span class="line-modified">!             case AUTOMINUSMINUS:</span>
<span class="line-modified">!                 semanticFailIfTrue(requiresLExpr, &quot;The &quot;, operatorString(true, lastOperator), &quot; operator requires a reference expression&quot;);</span>
<span class="line-modified">!                 modifiesExpr = true;</span>
<span class="line-modified">!                 requiresLExpr = true;</span>
<span class="line-modified">!                 break;</span>
<span class="line-modified">!             default:</span>
<span class="line-removed">-                 semanticFailIfTrue(requiresLExpr, &quot;The &quot;, operatorString(true, lastOperator), &quot; operator requires a reference expression&quot;);</span>
<span class="line-removed">-                 break;</span>
<span class="line-removed">-             }</span>
          }
          lastOperator = m_token.m_type;
          m_parserState.nonLHSCount++;
          context.appendUnaryToken(tokenStackDepth, m_token.m_type, tokenStartPosition());
          next();
<span class="line-new-header">--- 4994,30 ---</span>
  template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseUnaryExpression(TreeBuilder&amp; context)
  {
      typename TreeBuilder::UnaryExprContext unaryExprContext(context);
      AllowInOverride allowInOverride(this);
      int tokenStackDepth = 0;
<span class="line-modified">!     bool hasPrefixUpdateOp = false;</span>
      unsigned lastOperator = 0;
  
      if (UNLIKELY(match(AWAIT) &amp;&amp; currentFunctionScope()-&gt;isAsyncFunctionBoundary()))
          return parseAwaitExpression(context);
  
      JSTokenLocation location(tokenLocation());
  
      while (isUnaryOp(m_token.m_type)) {
<span class="line-modified">!         switch (m_token.m_type) {</span>
<span class="line-modified">!         case PLUSPLUS:</span>
<span class="line-modified">!         case MINUSMINUS:</span>
<span class="line-modified">!         case AUTOPLUSPLUS:</span>
<span class="line-modified">!         case AUTOMINUSMINUS:</span>
<span class="line-modified">!             semanticFailIfTrue(hasPrefixUpdateOp, &quot;The &quot;, operatorString(true, lastOperator), &quot; operator requires a reference expression&quot;);</span>
<span class="line-modified">!             hasPrefixUpdateOp = true;</span>
<span class="line-modified">!             break;</span>
<span class="line-modified">!         default:</span>
<span class="line-modified">!             semanticFailIfTrue(hasPrefixUpdateOp, &quot;The &quot;, operatorString(true, lastOperator), &quot; operator requires a reference expression&quot;);</span>
<span class="line-modified">!             break;</span>
          }
          lastOperator = m_token.m_type;
          m_parserState.nonLHSCount++;
          context.appendUnaryToken(tokenStackDepth, m_token.m_type, tokenStartPosition());
          next();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4965,52 ***</span>
      if (!expr) {
          if (lastOperator)
              failWithMessage(&quot;Cannot parse subexpression of &quot;, operatorString(true, lastOperator), &quot;operator&quot;);
          failWithMessage(&quot;Cannot parse member expression&quot;);
      }
<span class="line-modified">!     if (UNLIKELY(isUpdateOp(static_cast&lt;JSTokenType&gt;(lastOperator)) &amp;&amp; context.isMetaProperty(expr)))</span>
<span class="line-modified">!         internalFailWithMessage(false, metaPropertyName(context, expr), &quot; can&#39;t come after a prefix operator&quot;);</span>
      bool isEvalOrArguments = false;
      if (strictMode()) {
          if (context.isResolve(expr))
<span class="line-modified">!             isEvalOrArguments = *m_parserState.lastIdentifier == m_vm-&gt;propertyNames-&gt;eval || *m_parserState.lastIdentifier == m_vm-&gt;propertyNames-&gt;arguments;</span>
      }
<span class="line-modified">!     failIfTrueIfStrict(isEvalOrArguments &amp;&amp; modifiesExpr, &quot;Cannot modify &#39;&quot;, m_parserState.lastIdentifier-&gt;impl(), &quot;&#39; in strict mode&quot;);</span>
      switch (m_token.m_type) {
      case PLUSPLUS:
<span class="line-modified">!         if (UNLIKELY(context.isMetaProperty(expr)))</span>
<span class="line-modified">!             internalFailWithMessage(false, metaPropertyName(context, expr), &quot; can&#39;t come before a postfix operator&quot;);</span>
          m_parserState.nonTrivialExpressionCount++;
          m_parserState.nonLHSCount++;
          expr = context.makePostfixNode(location, expr, OpPlusPlus, subExprStart, lastTokenEndPosition(), tokenEndPosition());
          m_parserState.assignmentCount++;
          failIfTrueIfStrict(isEvalOrArguments, &quot;Cannot modify &#39;&quot;, m_parserState.lastIdentifier-&gt;impl(), &quot;&#39; in strict mode&quot;);
<span class="line-modified">!         semanticFailIfTrue(requiresLExpr, &quot;The &quot;, operatorString(false, lastOperator), &quot; operator requires a reference expression&quot;);</span>
<span class="line-removed">-         lastOperator = PLUSPLUS;</span>
          next();
          break;
      case MINUSMINUS:
<span class="line-modified">!         if (UNLIKELY(context.isMetaProperty(expr)))</span>
<span class="line-modified">!             internalFailWithMessage(false, metaPropertyName(context, expr), &quot; can&#39;t come before a postfix operator&quot;);</span>
          m_parserState.nonTrivialExpressionCount++;
          m_parserState.nonLHSCount++;
          expr = context.makePostfixNode(location, expr, OpMinusMinus, subExprStart, lastTokenEndPosition(), tokenEndPosition());
          m_parserState.assignmentCount++;
          failIfTrueIfStrict(isEvalOrArguments, &quot;&#39;&quot;, m_parserState.lastIdentifier-&gt;impl(), &quot;&#39; cannot be modified in strict mode&quot;);
<span class="line-modified">!         semanticFailIfTrue(requiresLExpr, &quot;The &quot;, operatorString(false, lastOperator), &quot; operator requires a reference expression&quot;);</span>
<span class="line-removed">-         lastOperator = PLUSPLUS;</span>
          next();
          break;
      default:
          break;
      }
  
      JSTextPosition end = lastTokenEndPosition();
<span class="line-removed">- </span>
<span class="line-removed">-     if (!TreeBuilder::CreatesAST &amp;&amp; (!strictMode()))</span>
<span class="line-removed">-         return expr;</span>
<span class="line-removed">- </span>
      while (tokenStackDepth) {
          switch (context.unaryTokenStackLastType(tokenStackDepth)) {
          case EXCLAMATION:
              expr = context.createLogicalNot(location, expr);
              break;
<span class="line-new-header">--- 5029,48 ---</span>
      if (!expr) {
          if (lastOperator)
              failWithMessage(&quot;Cannot parse subexpression of &quot;, operatorString(true, lastOperator), &quot;operator&quot;);
          failWithMessage(&quot;Cannot parse member expression&quot;);
      }
<span class="line-modified">!     if (isUpdateOp(static_cast&lt;JSTokenType&gt;(lastOperator))) {</span>
<span class="line-modified">!         semanticFailIfTrue(context.isMetaProperty(expr), metaPropertyName(context, expr), &quot; can&#39;t come after a prefix operator&quot;);</span>
<span class="line-added">+         semanticFailIfFalse(isSimpleAssignmentTarget(context, expr), &quot;Prefix &quot;, lastOperator == PLUSPLUS ? &quot;++&quot; : &quot;--&quot;, &quot; operator applied to value that is not a reference&quot;);</span>
<span class="line-added">+     }</span>
      bool isEvalOrArguments = false;
      if (strictMode()) {
          if (context.isResolve(expr))
<span class="line-modified">!             isEvalOrArguments = *m_parserState.lastIdentifier == m_vm.propertyNames-&gt;eval || *m_parserState.lastIdentifier == m_vm.propertyNames-&gt;arguments;</span>
      }
<span class="line-modified">!     failIfTrueIfStrict(isEvalOrArguments &amp;&amp; hasPrefixUpdateOp, &quot;Cannot modify &#39;&quot;, m_parserState.lastIdentifier-&gt;impl(), &quot;&#39; in strict mode&quot;);</span>
      switch (m_token.m_type) {
      case PLUSPLUS:
<span class="line-modified">!         semanticFailIfTrue(context.isMetaProperty(expr), metaPropertyName(context, expr), &quot; can&#39;t come before a postfix operator&quot;);</span>
<span class="line-modified">!         semanticFailIfFalse(isSimpleAssignmentTarget(context, expr), &quot;Postfix ++ operator applied to value that is not a reference&quot;);</span>
          m_parserState.nonTrivialExpressionCount++;
          m_parserState.nonLHSCount++;
          expr = context.makePostfixNode(location, expr, OpPlusPlus, subExprStart, lastTokenEndPosition(), tokenEndPosition());
          m_parserState.assignmentCount++;
          failIfTrueIfStrict(isEvalOrArguments, &quot;Cannot modify &#39;&quot;, m_parserState.lastIdentifier-&gt;impl(), &quot;&#39; in strict mode&quot;);
<span class="line-modified">!         semanticFailIfTrue(hasPrefixUpdateOp, &quot;The &quot;, operatorString(false, lastOperator), &quot; operator requires a reference expression&quot;);</span>
          next();
          break;
      case MINUSMINUS:
<span class="line-modified">!         semanticFailIfTrue(context.isMetaProperty(expr), metaPropertyName(context, expr), &quot; can&#39;t come before a postfix operator&quot;);</span>
<span class="line-modified">!         semanticFailIfFalse(isSimpleAssignmentTarget(context, expr), &quot;Postfix -- operator applied to value that is not a reference&quot;);</span>
          m_parserState.nonTrivialExpressionCount++;
          m_parserState.nonLHSCount++;
          expr = context.makePostfixNode(location, expr, OpMinusMinus, subExprStart, lastTokenEndPosition(), tokenEndPosition());
          m_parserState.assignmentCount++;
          failIfTrueIfStrict(isEvalOrArguments, &quot;&#39;&quot;, m_parserState.lastIdentifier-&gt;impl(), &quot;&#39; cannot be modified in strict mode&quot;);
<span class="line-modified">!         semanticFailIfTrue(hasPrefixUpdateOp, &quot;The &quot;, operatorString(false, lastOperator), &quot; operator requires a reference expression&quot;);</span>
          next();
          break;
      default:
          break;
      }
  
      JSTextPosition end = lastTokenEndPosition();
      while (tokenStackDepth) {
          switch (context.unaryTokenStackLastType(tokenStackDepth)) {
          case EXCLAMATION:
              expr = context.createLogicalNot(location, expr);
              break;
</pre>
<center><a href="Nodes.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Parser.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>