<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/VM.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="TypeSet.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="VM.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/VM.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (C) 2008-2018 Apple Inc. All rights reserved.</span>
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  *
   8  * 1.  Redistributions of source code must retain the above copyright
   9  *     notice, this list of conditions and the following disclaimer.
  10  * 2.  Redistributions in binary form must reproduce the above copyright
  11  *     notice, this list of conditions and the following disclaimer in the
  12  *     documentation and/or other materials provided with the distribution.
  13  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
  14  *     its contributors may be used to endorse or promote products derived
  15  *     from this software without specific prior written permission.
  16  *
  17  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
  18  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  19  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  20  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  21  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  22  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  23  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  24  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  25  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  26  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  27  */
  28 
  29 #include &quot;config.h&quot;
  30 #include &quot;VM.h&quot;
  31 
  32 #include &quot;ArgList.h&quot;
<span class="line-modified">  33 #include &quot;ArrayBufferNeuteringWatchpoint.h&quot;</span>
  34 #include &quot;BuiltinExecutables.h&quot;
  35 #include &quot;BytecodeIntrinsicRegistry.h&quot;
  36 #include &quot;CodeBlock.h&quot;
  37 #include &quot;CodeCache.h&quot;
  38 #include &quot;CommonIdentifiers.h&quot;
  39 #include &quot;CommonSlowPaths.h&quot;
  40 #include &quot;CustomGetterSetter.h&quot;
  41 #include &quot;DFGWorklist.h&quot;
  42 #include &quot;DirectEvalExecutable.h&quot;
  43 #include &quot;Disassembler.h&quot;

  44 #include &quot;Error.h&quot;
  45 #include &quot;ErrorConstructor.h&quot;
  46 #include &quot;ErrorInstance.h&quot;
  47 #include &quot;EvalCodeBlock.h&quot;
  48 #include &quot;Exception.h&quot;
  49 #include &quot;ExecutableToCodeBlockEdge.h&quot;
  50 #include &quot;FTLThunks.h&quot;
  51 #include &quot;FastMallocAlignedMemoryAllocator.h&quot;
  52 #include &quot;FunctionCodeBlock.h&quot;
  53 #include &quot;FunctionConstructor.h&quot;
  54 #include &quot;FunctionExecutable.h&quot;
  55 #include &quot;GCActivityCallback.h&quot;
  56 #include &quot;GetterSetter.h&quot;
  57 #include &quot;GigacageAlignedMemoryAllocator.h&quot;
  58 #include &quot;HasOwnPropertyCache.h&quot;
  59 #include &quot;Heap.h&quot;
  60 #include &quot;HeapIterationScope.h&quot;
  61 #include &quot;HeapProfiler.h&quot;
  62 #include &quot;HostCallReturnValue.h&quot;
  63 #include &quot;Identifier.h&quot;
  64 #include &quot;IncrementalSweeper.h&quot;
  65 #include &quot;IndirectEvalExecutable.h&quot;
<span class="line-removed">  66 #include &quot;InferredValue.h&quot;</span>
  67 #include &quot;Interpreter.h&quot;
  68 #include &quot;IntlCollatorConstructor.h&quot;
  69 #include &quot;IntlDateTimeFormatConstructor.h&quot;
  70 #include &quot;IntlNumberFormatConstructor.h&quot;
  71 #include &quot;IntlPluralRulesConstructor.h&quot;
  72 #include &quot;JITCode.h&quot;
  73 #include &quot;JITWorklist.h&quot;
  74 #include &quot;JSAPIValueWrapper.h&quot;
  75 #include &quot;JSArray.h&quot;
  76 #include &quot;JSArrayBufferConstructor.h&quot;
  77 #include &quot;JSAsyncFunction.h&quot;
  78 #include &quot;JSBigInt.h&quot;
  79 #include &quot;JSBoundFunction.h&quot;
  80 #include &quot;JSCInlines.h&quot;
  81 #include &quot;JSCallbackFunction.h&quot;
  82 #include &quot;JSCustomGetterSetterFunction.h&quot;
  83 #include &quot;JSDestructibleObjectHeapCellType.h&quot;
  84 #include &quot;JSFixedArray.h&quot;
  85 #include &quot;JSFunction.h&quot;
  86 #include &quot;JSGlobalObjectFunctions.h&quot;
  87 #include &quot;JSImmutableButterfly.h&quot;
  88 #include &quot;JSInternalPromiseDeferred.h&quot;
  89 #include &quot;JSLock.h&quot;
  90 #include &quot;JSMap.h&quot;
  91 #include &quot;JSMapIterator.h&quot;
  92 #include &quot;JSPromiseDeferred.h&quot;
  93 #include &quot;JSPropertyNameEnumerator.h&quot;
<span class="line-removed">  94 #include &quot;JSSegmentedVariableObjectHeapCellType.h&quot;</span>
  95 #include &quot;JSScriptFetchParameters.h&quot;
  96 #include &quot;JSScriptFetcher.h&quot;
  97 #include &quot;JSSet.h&quot;
  98 #include &quot;JSSetIterator.h&quot;
  99 #include &quot;JSSourceCode.h&quot;
 100 #include &quot;JSStringHeapCellType.h&quot;
 101 #include &quot;JSTemplateObjectDescriptor.h&quot;
 102 #include &quot;JSWeakMap.h&quot;

 103 #include &quot;JSWeakSet.h&quot;
 104 #include &quot;JSWebAssembly.h&quot;
 105 #include &quot;JSWebAssemblyCodeBlock.h&quot;
 106 #include &quot;JSWebAssemblyCodeBlockHeapCellType.h&quot;
 107 #include &quot;JSWithScope.h&quot;
 108 #include &quot;LLIntData.h&quot;
 109 #include &quot;Lexer.h&quot;
 110 #include &quot;Lookup.h&quot;
 111 #include &quot;MinimumReservedZoneSize.h&quot;
 112 #include &quot;ModuleProgramCodeBlock.h&quot;
 113 #include &quot;ModuleProgramExecutable.h&quot;
 114 #include &quot;NativeErrorConstructor.h&quot;
 115 #include &quot;NativeExecutable.h&quot;
 116 #include &quot;NativeStdFunctionCell.h&quot;
 117 #include &quot;Nodes.h&quot;
 118 #include &quot;ObjCCallbackFunction.h&quot;
 119 #include &quot;Parser.h&quot;
 120 #include &quot;ProfilerDatabase.h&quot;
 121 #include &quot;ProgramCodeBlock.h&quot;
 122 #include &quot;ProgramExecutable.h&quot;
 123 #include &quot;PromiseDeferredTimer.h&quot;
 124 #include &quot;PropertyMapHashTable.h&quot;
 125 #include &quot;ProxyRevoke.h&quot;

 126 #include &quot;RegExpCache.h&quot;
 127 #include &quot;RegExpObject.h&quot;
 128 #include &quot;RegisterAtOffsetList.h&quot;
 129 #include &quot;RuntimeType.h&quot;
 130 #include &quot;SamplingProfiler.h&quot;
 131 #include &quot;ShadowChicken.h&quot;
 132 #include &quot;SimpleTypedArrayController.h&quot;
 133 #include &quot;SourceProviderCache.h&quot;
 134 #include &quot;StackVisitor.h&quot;
 135 #include &quot;StrictEvalActivation.h&quot;
 136 #include &quot;StrongInlines.h&quot;
 137 #include &quot;StructureInlines.h&quot;
 138 #include &quot;TestRunnerUtils.h&quot;
 139 #include &quot;ThunkGenerators.h&quot;
 140 #include &quot;TypeProfiler.h&quot;
 141 #include &quot;TypeProfilerLog.h&quot;
 142 #include &quot;UnlinkedCodeBlock.h&quot;
 143 #include &quot;VMEntryScope.h&quot;
 144 #include &quot;VMInlines.h&quot;
 145 #include &quot;VMInspector.h&quot;
 146 #include &quot;VariableEnvironment.h&quot;
 147 #include &quot;WasmWorklist.h&quot;
 148 #include &quot;Watchdog.h&quot;
 149 #include &quot;WeakGCMapInlines.h&quot;
 150 #include &quot;WebAssemblyFunction.h&quot;

 151 #include &quot;WebAssemblyWrapperFunction.h&quot;
 152 #include &lt;wtf/ProcessID.h&gt;
 153 #include &lt;wtf/ReadWriteLock.h&gt;
 154 #include &lt;wtf/SimpleStats.h&gt;
 155 #include &lt;wtf/StringPrintStream.h&gt;
 156 #include &lt;wtf/Threading.h&gt;
<span class="line-modified"> 157 #include &lt;wtf/text/AtomicStringTable.h&gt;</span>
 158 #include &lt;wtf/text/SymbolRegistry.h&gt;
 159 
 160 #if ENABLE(C_LOOP)
 161 #include &quot;CLoopStack.h&quot;
 162 #include &quot;CLoopStackInlines.h&quot;
 163 #endif
 164 
 165 #if ENABLE(DFG_JIT)
 166 #include &quot;ConservativeRoots.h&quot;
 167 #endif
 168 
 169 #if ENABLE(REGEXP_TRACING)
 170 #include &quot;RegExp.h&quot;
 171 #endif
 172 
 173 namespace JSC {
 174 
 175 #if ENABLE(JIT)
 176 #if !ASSERT_DISABLED
 177 bool VM::s_canUseJITIsSet = false;
 178 #endif
 179 bool VM::s_canUseJIT = false;
 180 #endif
 181 
 182 Atomic&lt;unsigned&gt; VM::s_numberOfIDs;
 183 
 184 // Note: Platform.h will enforce that ENABLE(ASSEMBLER) is true if either
 185 // ENABLE(JIT) or ENABLE(YARR_JIT) or both are enabled. The code below
 186 // just checks for ENABLE(JIT) or ENABLE(YARR_JIT) with this premise in mind.
 187 
 188 #if ENABLE(ASSEMBLER)
<span class="line-modified"> 189 static bool enableAssembler(ExecutableAllocator&amp; executableAllocator)</span>
 190 {
<span class="line-modified"> 191     if (!Options::useJIT() &amp;&amp; !Options::useRegExpJIT())</span>
 192         return false;
 193 
<span class="line-modified"> 194     if (!executableAllocator.isValid()) {</span>





 195         if (Options::crashIfCantAllocateJITMemory())
 196             CRASH();
 197         return false;
 198     }
 199 
<span class="line-modified"> 200     char* canUseJITString = getenv(&quot;JavaScriptCoreUseJIT&quot;);</span>
<span class="line-removed"> 201     return !canUseJITString || atoi(canUseJITString);</span>
 202 }
 203 #endif // ENABLE(!ASSEMBLER)
 204 
 205 bool VM::canUseAssembler()
 206 {
 207 #if ENABLE(ASSEMBLER)
 208     static std::once_flag onceKey;
 209     static bool enabled = false;
 210     std::call_once(onceKey, [] {
<span class="line-modified"> 211         enabled = enableAssembler(ExecutableAllocator::singleton());</span>
 212     });
 213     return enabled;
 214 #else
 215     return false; // interpreter only
 216 #endif
 217 }
 218 
 219 void VM::computeCanUseJIT()
 220 {
 221 #if ENABLE(JIT)
 222 #if !ASSERT_DISABLED
 223     RELEASE_ASSERT(!s_canUseJITIsSet);
 224     s_canUseJITIsSet = true;
 225 #endif
 226     s_canUseJIT = VM::canUseAssembler() &amp;&amp; Options::useJIT();
 227 #endif
 228 }
 229 
<span class="line-removed"> 230 bool VM::canUseRegExpJIT()</span>
<span class="line-removed"> 231 {</span>
<span class="line-removed"> 232 #if ENABLE(YARR_JIT)</span>
<span class="line-removed"> 233     static std::once_flag onceKey;</span>
<span class="line-removed"> 234     static bool enabled = false;</span>
<span class="line-removed"> 235     std::call_once(onceKey, [] {</span>
<span class="line-removed"> 236         enabled = VM::canUseAssembler() &amp;&amp; Options::useRegExpJIT();</span>
<span class="line-removed"> 237     });</span>
<span class="line-removed"> 238     return enabled;</span>
<span class="line-removed"> 239 #else</span>
<span class="line-removed"> 240     return false; // interpreter only</span>
<span class="line-removed"> 241 #endif</span>
<span class="line-removed"> 242 }</span>
<span class="line-removed"> 243 </span>
<span class="line-removed"> 244 bool VM::isInMiniMode()</span>
<span class="line-removed"> 245 {</span>
<span class="line-removed"> 246     return !canUseJIT() || Options::forceMiniVMMode();</span>
<span class="line-removed"> 247 }</span>
<span class="line-removed"> 248 </span>
 249 inline unsigned VM::nextID()
 250 {
 251     for (;;) {
 252         unsigned currentNumberOfIDs = s_numberOfIDs.load();
 253         unsigned newID = currentNumberOfIDs + 1;
 254         if (s_numberOfIDs.compareExchangeWeak(currentNumberOfIDs, newID))
 255             return newID;
 256     }
 257 }
 258 

 259 
 260 VM::VM(VMType vmType, HeapType heapType)
 261     : m_id(nextID())
 262     , m_apiLock(adoptRef(new JSLock(this)))
 263 #if USE(CF)
 264     , m_runLoop(CFRunLoopGetCurrent())
 265 #endif // USE(CF)
<span class="line-modified"> 266     , heap(this, heapType)</span>
<span class="line-modified"> 267     , fastMallocAllocator(std::make_unique&lt;FastMallocAlignedMemoryAllocator&gt;())</span>
<span class="line-modified"> 268     , primitiveGigacageAllocator(std::make_unique&lt;GigacageAlignedMemoryAllocator&gt;(Gigacage::Primitive))</span>
<span class="line-modified"> 269     , jsValueGigacageAllocator(std::make_unique&lt;GigacageAlignedMemoryAllocator&gt;(Gigacage::JSValue))</span>
<span class="line-modified"> 270     , auxiliaryHeapCellType(std::make_unique&lt;HeapCellType&gt;(CellAttributes(DoesNotNeedDestruction, HeapCell::Auxiliary)))</span>
<span class="line-modified"> 271     , immutableButterflyHeapCellType(std::make_unique&lt;HeapCellType&gt;(CellAttributes(DoesNotNeedDestruction, HeapCell::JSCellWithInteriorPointers)))</span>
<span class="line-modified"> 272     , cellHeapCellType(std::make_unique&lt;HeapCellType&gt;(CellAttributes(DoesNotNeedDestruction, HeapCell::JSCell)))</span>
<span class="line-modified"> 273     , destructibleCellHeapCellType(std::make_unique&lt;HeapCellType&gt;(CellAttributes(NeedsDestruction, HeapCell::JSCell)))</span>
<span class="line-modified"> 274     , stringHeapCellType(std::make_unique&lt;JSStringHeapCellType&gt;())</span>
<span class="line-modified"> 275     , destructibleObjectHeapCellType(std::make_unique&lt;JSDestructibleObjectHeapCellType&gt;())</span>
<span class="line-removed"> 276     , segmentedVariableObjectHeapCellType(std::make_unique&lt;JSSegmentedVariableObjectHeapCellType&gt;())</span>
 277 #if ENABLE(WEBASSEMBLY)
<span class="line-modified"> 278     , webAssemblyCodeBlockHeapCellType(std::make_unique&lt;JSWebAssemblyCodeBlockHeapCellType&gt;())</span>

 279 #endif
<span class="line-modified"> 280     , primitiveGigacageAuxiliarySpace(&quot;Primitive Gigacage Auxiliary&quot;, heap, auxiliaryHeapCellType.get(), primitiveGigacageAllocator.get())</span>
<span class="line-modified"> 281     , jsValueGigacageAuxiliarySpace(&quot;JSValue Gigacage Auxiliary&quot;, heap, auxiliaryHeapCellType.get(), jsValueGigacageAllocator.get())</span>
<span class="line-modified"> 282     , immutableButterflyJSValueGigacageAuxiliarySpace(&quot;ImmutableButterfly Gigacage JSCellWithInteriorPointers&quot;, heap, immutableButterflyHeapCellType.get(), jsValueGigacageAllocator.get())</span>
<span class="line-modified"> 283     , cellSpace(&quot;JSCell&quot;, heap, cellHeapCellType.get(), fastMallocAllocator.get())</span>
<span class="line-modified"> 284     , jsValueGigacageCellSpace(&quot;JSValue Gigacage JSCell&quot;, heap, cellHeapCellType.get(), jsValueGigacageAllocator.get())</span>
<span class="line-modified"> 285     , destructibleCellSpace(&quot;Destructible JSCell&quot;, heap, destructibleCellHeapCellType.get(), fastMallocAllocator.get())</span>
<span class="line-modified"> 286     , stringSpace(&quot;JSString&quot;, heap, stringHeapCellType.get(), fastMallocAllocator.get())</span>
<span class="line-modified"> 287     , destructibleObjectSpace(&quot;JSDestructibleObject&quot;, heap, destructibleObjectHeapCellType.get(), fastMallocAllocator.get())</span>
<span class="line-modified"> 288     , eagerlySweptDestructibleObjectSpace(&quot;Eagerly Swept JSDestructibleObject&quot;, heap, destructibleObjectHeapCellType.get(), fastMallocAllocator.get())</span>
<span class="line-modified"> 289     , segmentedVariableObjectSpace(&quot;JSSegmentedVariableObjectSpace&quot;, heap, segmentedVariableObjectHeapCellType.get(), fastMallocAllocator.get())</span>
<span class="line-modified"> 290     , executableToCodeBlockEdgeSpace ISO_SUBSPACE_INIT(heap, cellHeapCellType.get(), ExecutableToCodeBlockEdge)</span>
<span class="line-modified"> 291     , functionSpace ISO_SUBSPACE_INIT(heap, cellHeapCellType.get(), JSFunction)</span>
<span class="line-modified"> 292     , internalFunctionSpace ISO_SUBSPACE_INIT(heap, destructibleObjectHeapCellType.get(), InternalFunction)</span>
<span class="line-modified"> 293     , nativeExecutableSpace ISO_SUBSPACE_INIT(heap, destructibleCellHeapCellType.get(), NativeExecutable)</span>
<span class="line-modified"> 294     , propertyTableSpace ISO_SUBSPACE_INIT(heap, destructibleCellHeapCellType.get(), PropertyTable)</span>
<span class="line-modified"> 295     , structureRareDataSpace ISO_SUBSPACE_INIT(heap, destructibleCellHeapCellType.get(), StructureRareData)</span>
<span class="line-modified"> 296     , structureSpace ISO_SUBSPACE_INIT(heap, destructibleCellHeapCellType.get(), Structure)</span>
 297     , executableToCodeBlockEdgesWithConstraints(executableToCodeBlockEdgeSpace)
 298     , executableToCodeBlockEdgesWithFinalizers(executableToCodeBlockEdgeSpace)
<span class="line-modified"> 299     , codeBlockSpace ISO_SUBSPACE_INIT(heap, destructibleCellHeapCellType.get(), CodeBlock)</span>
<span class="line-modified"> 300     , functionExecutableSpace ISO_SUBSPACE_INIT(heap, destructibleCellHeapCellType.get(), FunctionExecutable)</span>
<span class="line-modified"> 301     , programExecutableSpace ISO_SUBSPACE_INIT(heap, destructibleCellHeapCellType.get(), ProgramExecutable)</span>
<span class="line-modified"> 302     , unlinkedFunctionExecutableSpace ISO_SUBSPACE_INIT(heap, destructibleCellHeapCellType.get(), UnlinkedFunctionExecutable)</span>
 303     , vmType(vmType)
 304     , clientData(0)
 305     , topEntryFrame(nullptr)
 306     , topCallFrame(CallFrame::noCaller())
<span class="line-modified"> 307     , promiseDeferredTimer(std::make_unique&lt;PromiseDeferredTimer&gt;(*this))</span>
<span class="line-modified"> 308     , m_atomicStringTable(vmType == Default ? Thread::current().atomicStringTable() : new AtomicStringTable)</span>
 309     , propertyNames(nullptr)
 310     , emptyList(new ArgList)
<span class="line-modified"> 311     , machineCodeBytesPerBytecodeWordForBaselineJIT(std::make_unique&lt;SimpleStats&gt;())</span>
 312     , customGetterSetterFunctionMap(*this)
 313     , stringCache(*this)
 314     , symbolImplToSymbolMap(*this)
 315     , structureCache(*this)
 316     , interpreter(0)
 317     , entryScope(0)
 318     , m_regExpCache(new RegExpCache(this))
 319     , m_compactVariableMap(adoptRef(*(new CompactVariableMap)))
 320 #if ENABLE(REGEXP_TRACING)
 321     , m_rtTraceList(new RTTraceList())
 322 #endif
 323 #if ENABLE(GC_VALIDATION)
 324     , m_initializingObjectClass(0)
 325 #endif
 326     , m_stackPointerAtVMEntry(0)
<span class="line-modified"> 327     , m_codeCache(std::make_unique&lt;CodeCache&gt;())</span>
<span class="line-modified"> 328     , m_builtinExecutables(std::make_unique&lt;BuiltinExecutables&gt;(*this))</span>
 329     , m_typeProfilerEnabledCount(0)
 330     , m_primitiveGigacageEnabled(IsWatched)
 331     , m_controlFlowProfilerEnabledCount(0)
 332 {



 333     interpreter = new Interpreter(*this);
 334     StackBounds stack = Thread::current().stack();
 335     updateSoftReservedZoneSize(Options::softReservedZoneSize());
 336     setLastStackTop(stack.origin());
 337 
 338     JSRunLoopTimer::Manager::shared().registerVM(*this);
 339 
 340     // Need to be careful to keep everything consistent here
 341     JSLockHolder lock(this);
<span class="line-modified"> 342     AtomicStringTable* existingEntryAtomicStringTable = Thread::current().setCurrentAtomicStringTable(m_atomicStringTable);</span>
 343     structureStructure.set(*this, Structure::createStructure(*this));
 344     structureRareDataStructure.set(*this, StructureRareData::createStructure(*this, 0, jsNull()));
 345     stringStructure.set(*this, JSString::createStructure(*this, 0, jsNull()));
 346 
 347     smallStrings.initializeCommonStrings(*this);
 348 
<span class="line-modified"> 349     propertyNames = new CommonIdentifiers(this);</span>
 350     terminatedExecutionErrorStructure.set(*this, TerminatedExecutionError::createStructure(*this, 0, jsNull()));
 351     propertyNameEnumeratorStructure.set(*this, JSPropertyNameEnumerator::createStructure(*this, 0, jsNull()));
 352     customGetterSetterStructure.set(*this, CustomGetterSetter::createStructure(*this, 0, jsNull()));
 353     domAttributeGetterSetterStructure.set(*this, DOMAttributeGetterSetter::createStructure(*this, 0, jsNull()));
 354     scopedArgumentsTableStructure.set(*this, ScopedArgumentsTable::createStructure(*this, 0, jsNull()));
 355     apiWrapperStructure.set(*this, JSAPIValueWrapper::createStructure(*this, 0, jsNull()));
 356     nativeExecutableStructure.set(*this, NativeExecutable::createStructure(*this, 0, jsNull()));
 357     evalExecutableStructure.set(*this, EvalExecutable::createStructure(*this, 0, jsNull()));
 358     programExecutableStructure.set(*this, ProgramExecutable::createStructure(*this, 0, jsNull()));
 359     functionExecutableStructure.set(*this, FunctionExecutable::createStructure(*this, 0, jsNull()));
 360 #if ENABLE(WEBASSEMBLY)
 361     webAssemblyCodeBlockStructure.set(*this, JSWebAssemblyCodeBlock::createStructure(*this, 0, jsNull()));
 362 #endif
 363     moduleProgramExecutableStructure.set(*this, ModuleProgramExecutable::createStructure(*this, 0, jsNull()));
 364     regExpStructure.set(*this, RegExp::createStructure(*this, 0, jsNull()));
 365     symbolStructure.set(*this, Symbol::createStructure(*this, 0, jsNull()));
 366     symbolTableStructure.set(*this, SymbolTable::createStructure(*this, 0, jsNull()));
 367     fixedArrayStructure.set(*this, JSFixedArray::createStructure(*this, 0, jsNull()));
 368 
 369     immutableButterflyStructures[arrayIndexFromIndexingType(CopyOnWriteArrayWithInt32) - NumberOfIndexingShapes].set(*this, JSImmutableButterfly::createStructure(*this, 0, jsNull(), CopyOnWriteArrayWithInt32));
 370     immutableButterflyStructures[arrayIndexFromIndexingType(CopyOnWriteArrayWithDouble) - NumberOfIndexingShapes].set(*this, JSImmutableButterfly::createStructure(*this, 0, jsNull(), CopyOnWriteArrayWithDouble));
 371     immutableButterflyStructures[arrayIndexFromIndexingType(CopyOnWriteArrayWithContiguous) - NumberOfIndexingShapes].set(*this, JSImmutableButterfly::createStructure(*this, 0, jsNull(), CopyOnWriteArrayWithContiguous));
 372 
 373     sourceCodeStructure.set(*this, JSSourceCode::createStructure(*this, 0, jsNull()));
 374     scriptFetcherStructure.set(*this, JSScriptFetcher::createStructure(*this, 0, jsNull()));
 375     scriptFetchParametersStructure.set(*this, JSScriptFetchParameters::createStructure(*this, 0, jsNull()));
 376     structureChainStructure.set(*this, StructureChain::createStructure(*this, 0, jsNull()));
 377     sparseArrayValueMapStructure.set(*this, SparseArrayValueMap::createStructure(*this, 0, jsNull()));
 378     templateObjectDescriptorStructure.set(*this, JSTemplateObjectDescriptor::createStructure(*this, 0, jsNull()));
<span class="line-modified"> 379     arrayBufferNeuteringWatchpointStructure.set(*this, ArrayBufferNeuteringWatchpoint::createStructure(*this));</span>
 380     unlinkedFunctionExecutableStructure.set(*this, UnlinkedFunctionExecutable::createStructure(*this, 0, jsNull()));
 381     unlinkedProgramCodeBlockStructure.set(*this, UnlinkedProgramCodeBlock::createStructure(*this, 0, jsNull()));
 382     unlinkedEvalCodeBlockStructure.set(*this, UnlinkedEvalCodeBlock::createStructure(*this, 0, jsNull()));
 383     unlinkedFunctionCodeBlockStructure.set(*this, UnlinkedFunctionCodeBlock::createStructure(*this, 0, jsNull()));
 384     unlinkedModuleProgramCodeBlockStructure.set(*this, UnlinkedModuleProgramCodeBlock::createStructure(*this, 0, jsNull()));
 385     propertyTableStructure.set(*this, PropertyTable::createStructure(*this, 0, jsNull()));
<span class="line-removed"> 386     if (VM::canUseJIT())</span>
<span class="line-removed"> 387         inferredValueStructure.set(*this, InferredValue::createStructure(*this, 0, jsNull()));</span>
 388     functionRareDataStructure.set(*this, FunctionRareData::createStructure(*this, 0, jsNull()));
 389     exceptionStructure.set(*this, Exception::createStructure(*this, 0, jsNull()));
 390     promiseDeferredStructure.set(*this, JSPromiseDeferred::createStructure(*this, 0, jsNull()));
 391     internalPromiseDeferredStructure.set(*this, JSInternalPromiseDeferred::createStructure(*this, 0, jsNull()));
 392     nativeStdFunctionCellStructure.set(*this, NativeStdFunctionCell::createStructure(*this, 0, jsNull()));
 393     programCodeBlockStructure.set(*this, ProgramCodeBlock::createStructure(*this, 0, jsNull()));
 394     moduleProgramCodeBlockStructure.set(*this, ModuleProgramCodeBlock::createStructure(*this, 0, jsNull()));
 395     evalCodeBlockStructure.set(*this, EvalCodeBlock::createStructure(*this, 0, jsNull()));
 396     functionCodeBlockStructure.set(*this, FunctionCodeBlock::createStructure(*this, 0, jsNull()));
 397     hashMapBucketSetStructure.set(*this, HashMapBucket&lt;HashMapBucketDataKey&gt;::createStructure(*this, 0, jsNull()));
 398     hashMapBucketMapStructure.set(*this, HashMapBucket&lt;HashMapBucketDataKeyValue&gt;::createStructure(*this, 0, jsNull()));
<span class="line-removed"> 399     setIteratorStructure.set(*this, JSSetIterator::createStructure(*this, 0, jsNull()));</span>
<span class="line-removed"> 400     mapIteratorStructure.set(*this, JSMapIterator::createStructure(*this, 0, jsNull()));</span>
 401     bigIntStructure.set(*this, JSBigInt::createStructure(*this, 0, jsNull()));
 402     executableToCodeBlockEdgeStructure.set(*this, ExecutableToCodeBlockEdge::createStructure(*this, nullptr, jsNull()));
 403 
 404     // Eagerly initialize constant cells since the concurrent compiler can access them.
 405     if (canUseJIT()) {
 406         sentinelMapBucket();
 407         sentinelSetBucket();
 408     }
 409 
<span class="line-modified"> 410     Thread::current().setCurrentAtomicStringTable(existingEntryAtomicStringTable);</span>
<span class="line-removed"> 411 </span>
<span class="line-removed"> 412 #if ENABLE(JIT)</span>
<span class="line-removed"> 413     jitStubs = std::make_unique&lt;JITThunks&gt;();</span>
<span class="line-removed"> 414 #endif</span>
<span class="line-removed"> 415 </span>
<span class="line-removed"> 416 #if ENABLE(FTL_JIT)</span>
<span class="line-removed"> 417     ftlThunks = std::make_unique&lt;FTL::Thunks&gt;();</span>
<span class="line-removed"> 418 #endif // ENABLE(FTL_JIT)</span>
 419 
 420 #if !ENABLE(C_LOOP)
 421     initializeHostCallReturnValue(); // This is needed to convince the linker not to drop host call return support.
 422 #endif
 423 
 424     Gigacage::addPrimitiveDisableCallback(primitiveGigacageDisabledCallback, this);
 425 
 426     heap.notifyIsSafeToCollect();
 427 
 428     LLInt::Data::performAssertions(*this);
 429 
 430     if (UNLIKELY(Options::useProfiler())) {
<span class="line-modified"> 431         m_perBytecodeProfiler = std::make_unique&lt;Profiler::Database&gt;(*this);</span>
 432 
 433         StringPrintStream pathOut;
 434         const char* profilerPath = getenv(&quot;JSC_PROFILER_PATH&quot;);
 435         if (profilerPath)
 436             pathOut.print(profilerPath, &quot;/&quot;);
 437         pathOut.print(&quot;JSCProfile-&quot;, getCurrentProcessID(), &quot;-&quot;, m_perBytecodeProfiler-&gt;databaseID(), &quot;.json&quot;);
 438         m_perBytecodeProfiler-&gt;registerToSaveAtExit(pathOut.toCString().data());
 439     }
 440 
 441     callFrameForCatch = nullptr;
 442 
 443     // Initialize this last, as a free way of asserting that VM initialization itself
 444     // won&#39;t use this.
 445     m_typedArrayController = adoptRef(new SimpleTypedArrayController());
 446 
<span class="line-modified"> 447     m_bytecodeIntrinsicRegistry = std::make_unique&lt;BytecodeIntrinsicRegistry&gt;(*this);</span>
 448 
 449     if (Options::useTypeProfiler())
 450         enableTypeProfiler();
 451     if (Options::useControlFlowProfiler())
 452         enableControlFlowProfiler();
 453 #if ENABLE(SAMPLING_PROFILER)
 454     if (Options::useSamplingProfiler()) {
 455         setShouldBuildPCToCodeOriginMapping();
 456         Ref&lt;Stopwatch&gt; stopwatch = Stopwatch::create();
 457         stopwatch-&gt;start();
 458         m_samplingProfiler = adoptRef(new SamplingProfiler(*this, WTFMove(stopwatch)));
 459         if (Options::samplingProfilerPath())
 460             m_samplingProfiler-&gt;registerForReportAtExit();
 461         m_samplingProfiler-&gt;start();
 462     }
 463 #endif // ENABLE(SAMPLING_PROFILER)
 464 





 465     if (Options::alwaysGeneratePCToCodeOriginMap())
 466         setShouldBuildPCToCodeOriginMapping();
 467 
 468     if (Options::watchdog()) {
 469         Watchdog&amp; watchdog = ensureWatchdog();
 470         watchdog.setTimeLimit(Seconds::fromMilliseconds(Options::watchdog()));
 471     }
 472 
 473 #if ENABLE(JIT)
 474     // Make sure that any stubs that the JIT is going to use are initialized in non-compilation threads.
 475     if (canUseJIT()) {




 476         getCTIInternalFunctionTrampolineFor(CodeForCall);
 477         getCTIInternalFunctionTrampolineFor(CodeForConstruct);
 478     }
 479 #endif
 480 
<span class="line-removed"> 481     if (!canUseJIT())</span>
<span class="line-removed"> 482         noJITValueProfileSingleton = std::make_unique&lt;ValueProfile&gt;(0);</span>
<span class="line-removed"> 483 </span>
 484     if (Options::forceDebuggerBytecodeGeneration() || Options::alwaysUseShadowChicken())
 485         ensureShadowChicken();
 486 
 487     VMInspector::instance().add(this);
 488 }
 489 
 490 static ReadWriteLock s_destructionLock;
 491 
 492 void waitForVMDestruction()
 493 {
 494     auto locker = holdLock(s_destructionLock.write());
 495 }
 496 
 497 VM::~VM()
 498 {
 499     auto destructionLocker = holdLock(s_destructionLock.read());
 500 
 501     Gigacage::removePrimitiveDisableCallback(primitiveGigacageDisabledCallback, this);
 502     promiseDeferredTimer-&gt;stopRunningTasks();
 503 #if ENABLE(WEBASSEMBLY)
</pre>
<hr />
<pre>
 540 
 541     // Clear this first to ensure that nobody tries to remove themselves from it.
 542     m_perBytecodeProfiler = nullptr;
 543 
 544     ASSERT(currentThreadIsHoldingAPILock());
 545     m_apiLock-&gt;willDestroyVM(this);
 546     smallStrings.setIsInitialized(false);
 547     heap.lastChanceToFinalize();
 548 
 549     JSRunLoopTimer::Manager::shared().unregisterVM(*this);
 550 
 551     delete interpreter;
 552 #ifndef NDEBUG
 553     interpreter = reinterpret_cast&lt;Interpreter*&gt;(0xbbadbeef);
 554 #endif
 555 
 556     delete emptyList;
 557 
 558     delete propertyNames;
 559     if (vmType != Default)
<span class="line-modified"> 560         delete m_atomicStringTable;</span>
 561 
 562     delete clientData;
 563     delete m_regExpCache;
 564 
 565 #if ENABLE(REGEXP_TRACING)
 566     delete m_rtTraceList;
 567 #endif
 568 
 569 #if ENABLE(DFG_JIT)
 570     for (unsigned i = 0; i &lt; m_scratchBuffers.size(); ++i)
 571         fastFree(m_scratchBuffers[i]);
 572 #endif
 573 }
 574 
 575 void VM::primitiveGigacageDisabledCallback(void* argument)
 576 {
 577     static_cast&lt;VM*&gt;(argument)-&gt;primitiveGigacageDisabled();
 578 }
 579 
 580 void VM::primitiveGigacageDisabled()
</pre>
<hr />
<pre>
 617         instance = adoptRef(new VM(APIShared, SmallHeap)).leakRef();
 618     return *instance;
 619 }
 620 
 621 VM*&amp; VM::sharedInstanceInternal()
 622 {
 623     static VM* sharedInstance;
 624     return sharedInstance;
 625 }
 626 
 627 Watchdog&amp; VM::ensureWatchdog()
 628 {
 629     if (!m_watchdog)
 630         m_watchdog = adoptRef(new Watchdog(this));
 631     return *m_watchdog;
 632 }
 633 
 634 HeapProfiler&amp; VM::ensureHeapProfiler()
 635 {
 636     if (!m_heapProfiler)
<span class="line-modified"> 637         m_heapProfiler = std::make_unique&lt;HeapProfiler&gt;(*this);</span>
 638     return *m_heapProfiler;
 639 }
 640 
 641 #if ENABLE(SAMPLING_PROFILER)
 642 SamplingProfiler&amp; VM::ensureSamplingProfiler(RefPtr&lt;Stopwatch&gt;&amp;&amp; stopwatch)
 643 {
 644     if (!m_samplingProfiler)
 645         m_samplingProfiler = adoptRef(new SamplingProfiler(*this, WTFMove(stopwatch)));
 646     return *m_samplingProfiler;
 647 }
 648 #endif // ENABLE(SAMPLING_PROFILER)
 649 
 650 #if ENABLE(JIT)
 651 static ThunkGenerator thunkGeneratorForIntrinsic(Intrinsic intrinsic)
 652 {
 653     switch (intrinsic) {
 654     case CharCodeAtIntrinsic:
 655         return charCodeAtThunkGenerator;
 656     case CharAtIntrinsic:
 657         return charAtThunkGenerator;
</pre>
<hr />
<pre>
 681         return randomThunkGenerator;
 682     case BoundThisNoArgsFunctionCallIntrinsic:
 683         return boundThisNoArgsFunctionCallGenerator;
 684     default:
 685         return nullptr;
 686     }
 687 }
 688 
 689 #endif // ENABLE(JIT)
 690 
 691 NativeExecutable* VM::getHostFunction(NativeFunction function, NativeFunction constructor, const String&amp; name)
 692 {
 693     return getHostFunction(function, NoIntrinsic, constructor, nullptr, name);
 694 }
 695 
 696 static Ref&lt;NativeJITCode&gt; jitCodeForCallTrampoline()
 697 {
 698     static NativeJITCode* result;
 699     static std::once_flag onceKey;
 700     std::call_once(onceKey, [&amp;] {
<span class="line-modified"> 701         result = new NativeJITCode(LLInt::getCodeRef&lt;JSEntryPtrTag&gt;(llint_native_call_trampoline), JITCode::HostCallThunk, NoIntrinsic);</span>
 702     });
 703     return makeRef(*result);
 704 }
 705 
 706 static Ref&lt;NativeJITCode&gt; jitCodeForConstructTrampoline()
 707 {
 708     static NativeJITCode* result;
 709     static std::once_flag onceKey;
 710     std::call_once(onceKey, [&amp;] {
<span class="line-modified"> 711         result = new NativeJITCode(LLInt::getCodeRef&lt;JSEntryPtrTag&gt;(llint_native_construct_trampoline), JITCode::HostCallThunk, NoIntrinsic);</span>
 712     });
 713     return makeRef(*result);
 714 }
 715 
 716 NativeExecutable* VM::getHostFunction(NativeFunction function, Intrinsic intrinsic, NativeFunction constructor, const DOMJIT::Signature* signature, const String&amp; name)
 717 {
 718 #if ENABLE(JIT)
 719     if (canUseJIT()) {
 720         return jitStubs-&gt;hostFunctionStub(
<span class="line-modified"> 721             this, function, constructor,</span>
 722             intrinsic != NoIntrinsic ? thunkGeneratorForIntrinsic(intrinsic) : 0,
 723             intrinsic, signature, name);
 724     }
 725 #endif // ENABLE(JIT)
 726     UNUSED_PARAM(intrinsic);
 727     UNUSED_PARAM(signature);
 728     return NativeExecutable::create(*this, jitCodeForCallTrampoline(), function, jitCodeForConstructTrampoline(), constructor, name);
 729 }
 730 
 731 MacroAssemblerCodePtr&lt;JSEntryPtrTag&gt; VM::getCTIInternalFunctionTrampolineFor(CodeSpecializationKind kind)
 732 {
 733 #if ENABLE(JIT)
 734     if (canUseJIT()) {
 735         if (kind == CodeForCall)
<span class="line-modified"> 736             return jitStubs-&gt;ctiInternalFunctionCall(this).retagged&lt;JSEntryPtrTag&gt;();</span>
<span class="line-modified"> 737         return jitStubs-&gt;ctiInternalFunctionConstruct(this).retagged&lt;JSEntryPtrTag&gt;();</span>
 738     }
 739 #endif
 740     if (kind == CodeForCall)
 741         return LLInt::getCodePtr&lt;JSEntryPtrTag&gt;(llint_internal_function_call_trampoline);
 742     return LLInt::getCodePtr&lt;JSEntryPtrTag&gt;(llint_internal_function_construct_trampoline);
 743 }
 744 
 745 VM::ClientData::~ClientData()
 746 {
 747 }
 748 
 749 void VM::resetDateCache()
 750 {

 751     localTimeOffsetCache.reset();
 752     cachedDateString = String();
 753     cachedDateStringValue = std::numeric_limits&lt;double&gt;::quiet_NaN();
 754     dateInstanceCache.reset();
 755 }
 756 
 757 void VM::whenIdle(Function&lt;void()&gt;&amp;&amp; callback)
 758 {
 759     if (!entryScope) {
 760         callback();
 761         return;
 762     }
 763 
 764     entryScope-&gt;addDidPopListener(WTFMove(callback));
 765 }
 766 
 767 void VM::deleteAllLinkedCode(DeleteAllCodeEffort effort)
 768 {
 769     whenIdle([=] () {
 770         heap.deleteAllCodeBlocks(effort);
 771     });
 772 }
 773 
 774 void VM::deleteAllCode(DeleteAllCodeEffort effort)
 775 {
 776     whenIdle([=] () {
 777         m_codeCache-&gt;clear();
 778         m_regExpCache-&gt;deleteAllCode();
 779         heap.deleteAllCodeBlocks(effort);
 780         heap.deleteAllUnlinkedCodeBlocks(effort);
 781         heap.reportAbandonedObjectGraph();
 782     });
 783 }
 784 
 785 void VM::shrinkFootprintWhenIdle()
 786 {
 787     whenIdle([=] () {
<span class="line-modified"> 788         sanitizeStackForVM(this);</span>
 789         deleteAllCode(DeleteAllCodeIfNotCollecting);
 790         heap.collectNow(Synchronousness::Sync, CollectionScope::Full);
 791         // FIXME: Consider stopping various automatic threads here.
 792         // https://bugs.webkit.org/show_bug.cgi?id=185447
 793         WTF::releaseFastMallocFreeMemory();
 794     });
 795 }
 796 
 797 SourceProviderCache* VM::addSourceProviderCache(SourceProvider* sourceProvider)
 798 {
 799     auto addResult = sourceProviderCacheMap.add(sourceProvider, nullptr);
 800     if (addResult.isNewEntry)
 801         addResult.iterator-&gt;value = adoptRef(new SourceProviderCache);
 802     return addResult.iterator-&gt;value.get();
 803 }
 804 
 805 void VM::clearSourceProviderCaches()
 806 {
 807     sourceProviderCacheMap.clear();
 808 }
 809 
<span class="line-modified"> 810 void VM::throwException(ExecState* exec, Exception* exception)</span>
 811 {
 812     ASSERT(exec == topCallFrame || exec-&gt;isGlobalExec() || exec == exec-&gt;lexicalGlobalObject()-&gt;callFrameAtDebuggerEntry());
 813     CallFrame* throwOriginFrame = exec-&gt;isGlobalExec() ? exec : topJSCallFrame();
 814 
 815     if (Options::breakOnThrow()) {
 816         CodeBlock* codeBlock = throwOriginFrame ? throwOriginFrame-&gt;codeBlock() : nullptr;
 817         dataLog(&quot;Throwing exception in call frame &quot;, RawPointer(throwOriginFrame), &quot; for code block &quot;, codeBlock, &quot;\n&quot;);
 818         CRASH();
 819     }
 820 
 821     interpreter-&gt;notifyDebuggerOfExceptionToBeThrown(*this, throwOriginFrame, exception);
 822 
 823     setException(exception);
 824 
 825 #if ENABLE(EXCEPTION_SCOPE_VERIFICATION)
 826     m_nativeStackTraceOfLastThrow = StackTrace::captureStackTrace(Options::unexpectedExceptionStackTraceLimit());
 827     m_throwingThread = &amp;Thread::current();
 828 #endif

 829 }
 830 
<span class="line-modified"> 831 JSValue VM::throwException(ExecState* exec, JSValue thrownValue)</span>
 832 {
 833     VM&amp; vm = *this;
 834     Exception* exception = jsDynamicCast&lt;Exception*&gt;(vm, thrownValue);
 835     if (!exception)
 836         exception = Exception::create(*this, thrownValue);
 837 
<span class="line-modified"> 838     throwException(exec, exception);</span>
<span class="line-removed"> 839     return JSValue(exception);</span>
 840 }
 841 
<span class="line-modified"> 842 JSObject* VM::throwException(ExecState* exec, JSObject* error)</span>
 843 {
<span class="line-modified"> 844     return asObject(throwException(exec, JSValue(error)));</span>
 845 }
 846 
 847 void VM::setStackPointerAtVMEntry(void* sp)
 848 {
 849     m_stackPointerAtVMEntry = sp;
 850     updateStackLimits();
 851 }
 852 
 853 size_t VM::updateSoftReservedZoneSize(size_t softReservedZoneSize)
 854 {
 855     size_t oldSoftReservedZoneSize = m_currentSoftReservedZoneSize;
 856     m_currentSoftReservedZoneSize = softReservedZoneSize;
 857 #if ENABLE(C_LOOP)
 858     interpreter-&gt;cloopStack().setSoftReservedZoneSize(softReservedZoneSize);
 859 #endif
 860 
 861     updateStackLimits();
 862 
 863     return oldSoftReservedZoneSize;
 864 }
</pre>
<hr />
<pre>
 922     // used exclusively by C++ code, and the C++ compiler will automatically commit the
 923     // needed stack pages.
 924     if (lastSoftStackLimit != m_softStackLimit)
 925         preCommitStackMemory(m_softStackLimit);
 926 #endif
 927 }
 928 
 929 #if ENABLE(DFG_JIT)
 930 void VM::gatherScratchBufferRoots(ConservativeRoots&amp; conservativeRoots)
 931 {
 932     auto lock = holdLock(m_scratchBufferLock);
 933     for (auto* scratchBuffer : m_scratchBuffers) {
 934         if (scratchBuffer-&gt;activeLength()) {
 935             void* bufferStart = scratchBuffer-&gt;dataBuffer();
 936             conservativeRoots.add(bufferStart, static_cast&lt;void*&gt;(static_cast&lt;char*&gt;(bufferStart) + scratchBuffer-&gt;activeLength()));
 937         }
 938     }
 939 }
 940 #endif
 941 
<span class="line-modified"> 942 void logSanitizeStack(VM* vm)</span>
 943 {
<span class="line-modified"> 944     if (Options::verboseSanitizeStack() &amp;&amp; vm-&gt;topCallFrame) {</span>
 945         int dummy;
 946         auto&amp; stackBounds = Thread::current().stack();
 947         dataLog(
<span class="line-modified"> 948             &quot;Sanitizing stack for VM = &quot;, RawPointer(vm), &quot; with top call frame at &quot;, RawPointer(vm-&gt;topCallFrame),</span>
 949             &quot;, current stack pointer at &quot;, RawPointer(&amp;dummy), &quot;, in &quot;,
<span class="line-modified"> 950             pointerDump(vm-&gt;topCallFrame-&gt;codeBlock()), &quot;, last code origin = &quot;,</span>
<span class="line-modified"> 951             vm-&gt;topCallFrame-&gt;codeOrigin(), &quot;, last stack top = &quot;, RawPointer(vm-&gt;lastStackTop()), &quot;, in stack range [&quot;, RawPointer(stackBounds.origin()), &quot;, &quot;, RawPointer(stackBounds.end()), &quot;]\n&quot;);</span>
 952     }
 953 }
 954 
 955 #if ENABLE(YARR_JIT_ALL_PARENS_EXPRESSIONS)
 956 char* VM::acquireRegExpPatternContexBuffer()
 957 {
 958     m_regExpPatternContextLock.lock();
 959     ASSERT(m_regExpPatternContextLock.isLocked());
 960     if (!m_regExpPatternContexBuffer)
 961         m_regExpPatternContexBuffer = makeUniqueArray&lt;char&gt;(VM::patternContextBufferSize);
 962     return m_regExpPatternContexBuffer.get();
 963 }
 964 
 965 void VM::releaseRegExpPatternContexBuffer()
 966 {
 967     ASSERT(m_regExpPatternContextLock.isLocked());
 968 
 969     m_regExpPatternContextLock.unlock();
 970 }
 971 #endif
</pre>
<hr />
<pre>
1038     return needsToRecompile;
1039 }
1040 
1041 template&lt;typename Func&gt;
1042 static bool disableProfilerWithRespectToCount(unsigned&amp; counter, const Func&amp; doDisableWork)
1043 {
1044     RELEASE_ASSERT(counter &gt; 0);
1045     bool needsToRecompile = false;
1046     counter--;
1047     if (!counter) {
1048         doDisableWork();
1049         needsToRecompile = true;
1050     }
1051 
1052     return needsToRecompile;
1053 }
1054 
1055 bool VM::enableTypeProfiler()
1056 {
1057     auto enableTypeProfiler = [this] () {
<span class="line-modified">1058         this-&gt;m_typeProfiler = std::make_unique&lt;TypeProfiler&gt;();</span>
<span class="line-modified">1059         this-&gt;m_typeProfilerLog = std::make_unique&lt;TypeProfilerLog&gt;(*this);</span>
1060     };
1061 
1062     return enableProfilerWithRespectToCount(m_typeProfilerEnabledCount, enableTypeProfiler);
1063 }
1064 
1065 bool VM::disableTypeProfiler()
1066 {
1067     auto disableTypeProfiler = [this] () {
1068         this-&gt;m_typeProfiler.reset(nullptr);
1069         this-&gt;m_typeProfilerLog.reset(nullptr);
1070     };
1071 
1072     return disableProfilerWithRespectToCount(m_typeProfilerEnabledCount, disableTypeProfiler);
1073 }
1074 
1075 bool VM::enableControlFlowProfiler()
1076 {
1077     auto enableControlFlowProfiler = [this] () {
<span class="line-modified">1078         this-&gt;m_controlFlowProfiler = std::make_unique&lt;ControlFlowProfiler&gt;();</span>
1079     };
1080 
1081     return enableProfilerWithRespectToCount(m_controlFlowProfilerEnabledCount, enableControlFlowProfiler);
1082 }
1083 
1084 bool VM::disableControlFlowProfiler()
1085 {
1086     auto disableControlFlowProfiler = [this] () {
1087         this-&gt;m_controlFlowProfiler.reset(nullptr);
1088     };
1089 
1090     return disableProfilerWithRespectToCount(m_controlFlowProfilerEnabledCount, disableControlFlowProfiler);
1091 }
1092 
1093 void VM::dumpTypeProfilerData()
1094 {
1095     if (!typeProfiler())
1096         return;
1097 
1098     typeProfilerLog()-&gt;processLogEntries(*this, &quot;VM Dump Types&quot;_s);
1099     typeProfiler()-&gt;dumpTypeProfilerData(*this);
1100 }
1101 
1102 void VM::queueMicrotask(JSGlobalObject&amp; globalObject, Ref&lt;Microtask&gt;&amp;&amp; task)
1103 {
<span class="line-modified">1104     m_microtaskQueue.append(std::make_unique&lt;QueuedTask&gt;(*this, &amp;globalObject, WTFMove(task)));</span>
1105 }
1106 
<span class="line-modified">1107 void VM::drainMicrotasks()</span>
1108 {
<span class="line-modified">1109     while (!m_microtaskQueue.isEmpty()) {</span>
<span class="line-modified">1110         m_microtaskQueue.takeFirst()-&gt;run();</span>
<span class="line-modified">1111         if (m_onEachMicrotaskTick)</span>
<span class="line-modified">1112             m_onEachMicrotaskTick(*this);</span>





















1113     }
1114 }
1115 


















1116 void QueuedTask::run()
1117 {
1118     m_microtask-&gt;run(m_globalObject-&gt;globalExec());
1119 }
1120 
<span class="line-modified">1121 void sanitizeStackForVM(VM* vm)</span>
1122 {
1123     logSanitizeStack(vm);
<span class="line-modified">1124     if (vm-&gt;topCallFrame) {</span>
1125         auto&amp; stackBounds = Thread::current().stack();
<span class="line-modified">1126         ASSERT(vm-&gt;currentThreadIsHoldingAPILock());</span>
<span class="line-modified">1127         ASSERT_UNUSED(stackBounds, stackBounds.contains(vm-&gt;lastStackTop()));</span>
1128     }
1129 #if ENABLE(C_LOOP)
<span class="line-modified">1130     vm-&gt;interpreter-&gt;cloopStack().sanitizeStack();</span>
1131 #else
<span class="line-modified">1132     sanitizeStackForVMImpl(vm);</span>
1133 #endif
1134 }
1135 
1136 size_t VM::committedStackByteCount()
1137 {
1138 #if !ENABLE(C_LOOP)
1139     // When using the C stack, we don&#39;t know how many stack pages are actually
1140     // committed. So, we use the current stack usage as an estimate.
1141     ASSERT(Thread::current().stack().isGrowingDownward());
1142     uint8_t* current = bitwise_cast&lt;uint8_t*&gt;(currentStackPointer());
1143     uint8_t* high = bitwise_cast&lt;uint8_t*&gt;(Thread::current().stack().origin());
1144     return high - current;
1145 #else
1146     return CLoopStack::committedByteCount();
1147 #endif
1148 }
1149 
1150 #if ENABLE(C_LOOP)
1151 bool VM::ensureStackCapacityForCLoop(Register* newTopOfStack)
1152 {
1153     return interpreter-&gt;cloopStack().ensureCapacityFor(newTopOfStack);
1154 }
1155 
1156 bool VM::isSafeToRecurseSoftCLoop() const
1157 {
1158     return interpreter-&gt;cloopStack().isSafeToRecurse();
1159 }





1160 #endif // ENABLE(C_LOOP)
1161 
1162 #if ENABLE(EXCEPTION_SCOPE_VERIFICATION)
1163 void VM::verifyExceptionCheckNeedIsSatisfied(unsigned recursionDepth, ExceptionEventLocation&amp; location)
1164 {
1165     if (!Options::validateExceptionChecks())
1166         return;
1167 
1168     if (UNLIKELY(m_needExceptionCheck)) {
1169         auto throwDepth = m_simulatedThrowPointRecursionDepth;
1170         auto&amp; throwLocation = m_simulatedThrowPointLocation;
1171 
1172         dataLog(
1173             &quot;ERROR: Unchecked JS exception:\n&quot;
1174             &quot;    This scope can throw a JS exception: &quot;, throwLocation, &quot;\n&quot;
1175             &quot;        (ExceptionScope::m_recursionDepth was &quot;, throwDepth, &quot;)\n&quot;
1176             &quot;    But the exception was unchecked as of this scope: &quot;, location, &quot;\n&quot;
1177             &quot;        (ExceptionScope::m_recursionDepth was &quot;, recursionDepth, &quot;)\n&quot;
1178             &quot;\n&quot;);
1179 
</pre>
<hr />
<pre>
1221         ScratchBuffer* newBuffer = ScratchBuffer::create(m_sizeOfLastScratchBuffer);
1222         RELEASE_ASSERT(newBuffer);
1223         m_scratchBuffers.append(newBuffer);
1224     }
1225 
1226     ScratchBuffer* result = m_scratchBuffers.last();
1227     return result;
1228 }
1229 
1230 void VM::clearScratchBuffers()
1231 {
1232     auto lock = holdLock(m_scratchBufferLock);
1233     for (auto* scratchBuffer : m_scratchBuffers)
1234         scratchBuffer-&gt;setActiveLength(0);
1235 }
1236 
1237 void VM::ensureShadowChicken()
1238 {
1239     if (m_shadowChicken)
1240         return;
<span class="line-modified">1241     m_shadowChicken = std::make_unique&lt;ShadowChicken&gt;();</span>
1242 }
1243 
1244 #define DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(name, heapCellType, type) \
1245     IsoSubspace* VM::name##Slow() \
1246     { \
1247         ASSERT(!m_##name); \
<span class="line-modified">1248         auto space = std::make_unique&lt;IsoSubspace&gt; ISO_SUBSPACE_INIT(heap, heapCellType, type); \</span>
1249         WTF::storeStoreFence(); \
1250         m_##name = WTFMove(space); \
1251         return m_##name.get(); \
1252     }
1253 
1254 
<span class="line-modified">1255 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(boundFunctionSpace, cellHeapCellType.get(), JSBoundFunction)</span>
<span class="line-modified">1256 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(callbackFunctionSpace, destructibleObjectHeapCellType.get(), JSCallbackFunction)</span>
<span class="line-modified">1257 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(customGetterSetterFunctionSpace, cellHeapCellType.get(), JSCustomGetterSetterFunction)</span>
<span class="line-modified">1258 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(errorInstanceSpace, destructibleObjectHeapCellType.get(), ErrorInstance)</span>
<span class="line-modified">1259 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(nativeStdFunctionSpace, cellHeapCellType.get(), JSNativeStdFunction)</span>
<span class="line-modified">1260 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(proxyRevokeSpace, destructibleObjectHeapCellType.get(), ProxyRevoke)</span>
<span class="line-modified">1261 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(weakMapSpace, destructibleObjectHeapCellType.get(), JSWeakMap)</span>
<span class="line-modified">1262 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(weakSetSpace, destructibleObjectHeapCellType.get(), JSWeakSet)</span>

1263 #if JSC_OBJC_API_ENABLED
<span class="line-modified">1264 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(objCCallbackFunctionSpace, destructibleObjectHeapCellType.get(), ObjCCallbackFunction)</span>
1265 #endif
1266 #if ENABLE(WEBASSEMBLY)
<span class="line-modified">1267 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(webAssemblyCodeBlockSpace, webAssemblyCodeBlockHeapCellType.get(), JSWebAssemblyCodeBlock)</span>
<span class="line-modified">1268 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(webAssemblyFunctionSpace, cellHeapCellType.get(), WebAssemblyFunction)</span>
<span class="line-modified">1269 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(webAssemblyWrapperFunctionSpace, cellHeapCellType.get(), WebAssemblyWrapperFunction)</span>
1270 #endif
1271 
1272 #undef DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW
1273 
1274 #define DYNAMIC_SPACE_AND_SET_DEFINE_MEMBER_SLOW(name, heapCellType, type) \
1275     IsoSubspace* VM::name##Slow() \
1276     { \
1277         ASSERT(!m_##name); \
<span class="line-modified">1278         auto space = std::make_unique&lt;SpaceAndSet&gt; ISO_SUBSPACE_INIT(heap, heapCellType, type); \</span>
1279         WTF::storeStoreFence(); \
1280         m_##name = WTFMove(space); \
1281         return &amp;m_##name-&gt;space; \
1282     }
1283 
<span class="line-modified">1284 DYNAMIC_SPACE_AND_SET_DEFINE_MEMBER_SLOW(inferredValueSpace, destructibleCellHeapCellType.get(), InferredValue)</span>
<span class="line-modified">1285 DYNAMIC_SPACE_AND_SET_DEFINE_MEMBER_SLOW(evalExecutableSpace, destructibleCellHeapCellType.get(), EvalExecutable)</span>
<span class="line-removed">1286 DYNAMIC_SPACE_AND_SET_DEFINE_MEMBER_SLOW(moduleProgramExecutableSpace, destructibleCellHeapCellType.get(), ModuleProgramExecutable)</span>
1287 
1288 #undef DYNAMIC_SPACE_AND_SET_DEFINE_MEMBER_SLOW
1289 













1290 
1291 JSCell* VM::sentinelSetBucketSlow()
1292 {
1293     ASSERT(!m_sentinelSetBucket);
1294     auto* sentinel = JSSet::BucketType::createSentinel(*this);
1295     m_sentinelSetBucket.set(*this, sentinel);
1296     return sentinel;
1297 }
1298 
1299 JSCell* VM::sentinelMapBucketSlow()
1300 {
1301     ASSERT(!m_sentinelMapBucket);
1302     auto* sentinel = JSMap::BucketType::createSentinel(*this);
1303     m_sentinelMapBucket.set(*this, sentinel);
1304     return sentinel;
1305 }
1306 









1307 JSGlobalObject* VM::vmEntryGlobalObject(const CallFrame* callFrame) const
1308 {
1309     if (callFrame &amp;&amp; callFrame-&gt;isGlobalExec()) {
1310         ASSERT(callFrame-&gt;callee().isCell() &amp;&amp; callFrame-&gt;callee().asCell()-&gt;isObject());
1311         ASSERT(callFrame == callFrame-&gt;lexicalGlobalObject()-&gt;globalExec());
1312         return callFrame-&gt;lexicalGlobalObject();
1313     }
1314     ASSERT(entryScope);
1315     return entryScope-&gt;globalObject();
1316 }
1317 





1318 } // namespace JSC
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (C) 2008-2019 Apple Inc. All rights reserved.</span>
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  *
   8  * 1.  Redistributions of source code must retain the above copyright
   9  *     notice, this list of conditions and the following disclaimer.
  10  * 2.  Redistributions in binary form must reproduce the above copyright
  11  *     notice, this list of conditions and the following disclaimer in the
  12  *     documentation and/or other materials provided with the distribution.
  13  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
  14  *     its contributors may be used to endorse or promote products derived
  15  *     from this software without specific prior written permission.
  16  *
  17  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
  18  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  19  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  20  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  21  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  22  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  23  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  24  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  25  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  26  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  27  */
  28 
  29 #include &quot;config.h&quot;
  30 #include &quot;VM.h&quot;
  31 
  32 #include &quot;ArgList.h&quot;
<span class="line-modified">  33 #include &quot;ArrayBufferNeuteringWatchpointSet.h&quot;</span>
  34 #include &quot;BuiltinExecutables.h&quot;
  35 #include &quot;BytecodeIntrinsicRegistry.h&quot;
  36 #include &quot;CodeBlock.h&quot;
  37 #include &quot;CodeCache.h&quot;
  38 #include &quot;CommonIdentifiers.h&quot;
  39 #include &quot;CommonSlowPaths.h&quot;
  40 #include &quot;CustomGetterSetter.h&quot;
  41 #include &quot;DFGWorklist.h&quot;
  42 #include &quot;DirectEvalExecutable.h&quot;
  43 #include &quot;Disassembler.h&quot;
<span class="line-added">  44 #include &quot;DoublePredictionFuzzerAgent.h&quot;</span>
  45 #include &quot;Error.h&quot;
  46 #include &quot;ErrorConstructor.h&quot;
  47 #include &quot;ErrorInstance.h&quot;
  48 #include &quot;EvalCodeBlock.h&quot;
  49 #include &quot;Exception.h&quot;
  50 #include &quot;ExecutableToCodeBlockEdge.h&quot;
  51 #include &quot;FTLThunks.h&quot;
  52 #include &quot;FastMallocAlignedMemoryAllocator.h&quot;
  53 #include &quot;FunctionCodeBlock.h&quot;
  54 #include &quot;FunctionConstructor.h&quot;
  55 #include &quot;FunctionExecutable.h&quot;
  56 #include &quot;GCActivityCallback.h&quot;
  57 #include &quot;GetterSetter.h&quot;
  58 #include &quot;GigacageAlignedMemoryAllocator.h&quot;
  59 #include &quot;HasOwnPropertyCache.h&quot;
  60 #include &quot;Heap.h&quot;
  61 #include &quot;HeapIterationScope.h&quot;
  62 #include &quot;HeapProfiler.h&quot;
  63 #include &quot;HostCallReturnValue.h&quot;
  64 #include &quot;Identifier.h&quot;
  65 #include &quot;IncrementalSweeper.h&quot;
  66 #include &quot;IndirectEvalExecutable.h&quot;

  67 #include &quot;Interpreter.h&quot;
  68 #include &quot;IntlCollatorConstructor.h&quot;
  69 #include &quot;IntlDateTimeFormatConstructor.h&quot;
  70 #include &quot;IntlNumberFormatConstructor.h&quot;
  71 #include &quot;IntlPluralRulesConstructor.h&quot;
  72 #include &quot;JITCode.h&quot;
  73 #include &quot;JITWorklist.h&quot;
  74 #include &quot;JSAPIValueWrapper.h&quot;
  75 #include &quot;JSArray.h&quot;
  76 #include &quot;JSArrayBufferConstructor.h&quot;
  77 #include &quot;JSAsyncFunction.h&quot;
  78 #include &quot;JSBigInt.h&quot;
  79 #include &quot;JSBoundFunction.h&quot;
  80 #include &quot;JSCInlines.h&quot;
  81 #include &quot;JSCallbackFunction.h&quot;
  82 #include &quot;JSCustomGetterSetterFunction.h&quot;
  83 #include &quot;JSDestructibleObjectHeapCellType.h&quot;
  84 #include &quot;JSFixedArray.h&quot;
  85 #include &quot;JSFunction.h&quot;
  86 #include &quot;JSGlobalObjectFunctions.h&quot;
  87 #include &quot;JSImmutableButterfly.h&quot;
  88 #include &quot;JSInternalPromiseDeferred.h&quot;
  89 #include &quot;JSLock.h&quot;
  90 #include &quot;JSMap.h&quot;
  91 #include &quot;JSMapIterator.h&quot;
  92 #include &quot;JSPromiseDeferred.h&quot;
  93 #include &quot;JSPropertyNameEnumerator.h&quot;

  94 #include &quot;JSScriptFetchParameters.h&quot;
  95 #include &quot;JSScriptFetcher.h&quot;
  96 #include &quot;JSSet.h&quot;
  97 #include &quot;JSSetIterator.h&quot;
  98 #include &quot;JSSourceCode.h&quot;
  99 #include &quot;JSStringHeapCellType.h&quot;
 100 #include &quot;JSTemplateObjectDescriptor.h&quot;
 101 #include &quot;JSWeakMap.h&quot;
<span class="line-added"> 102 #include &quot;JSWeakObjectRef.h&quot;</span>
 103 #include &quot;JSWeakSet.h&quot;
 104 #include &quot;JSWebAssembly.h&quot;
 105 #include &quot;JSWebAssemblyCodeBlock.h&quot;
 106 #include &quot;JSWebAssemblyCodeBlockHeapCellType.h&quot;
 107 #include &quot;JSWithScope.h&quot;
 108 #include &quot;LLIntData.h&quot;
 109 #include &quot;Lexer.h&quot;
 110 #include &quot;Lookup.h&quot;
 111 #include &quot;MinimumReservedZoneSize.h&quot;
 112 #include &quot;ModuleProgramCodeBlock.h&quot;
 113 #include &quot;ModuleProgramExecutable.h&quot;
 114 #include &quot;NativeErrorConstructor.h&quot;
 115 #include &quot;NativeExecutable.h&quot;
 116 #include &quot;NativeStdFunctionCell.h&quot;
 117 #include &quot;Nodes.h&quot;
 118 #include &quot;ObjCCallbackFunction.h&quot;
 119 #include &quot;Parser.h&quot;
 120 #include &quot;ProfilerDatabase.h&quot;
 121 #include &quot;ProgramCodeBlock.h&quot;
 122 #include &quot;ProgramExecutable.h&quot;
 123 #include &quot;PromiseDeferredTimer.h&quot;
 124 #include &quot;PropertyMapHashTable.h&quot;
 125 #include &quot;ProxyRevoke.h&quot;
<span class="line-added"> 126 #include &quot;RandomizingFuzzerAgent.h&quot;</span>
 127 #include &quot;RegExpCache.h&quot;
 128 #include &quot;RegExpObject.h&quot;
 129 #include &quot;RegisterAtOffsetList.h&quot;
 130 #include &quot;RuntimeType.h&quot;
 131 #include &quot;SamplingProfiler.h&quot;
 132 #include &quot;ShadowChicken.h&quot;
 133 #include &quot;SimpleTypedArrayController.h&quot;
 134 #include &quot;SourceProviderCache.h&quot;
 135 #include &quot;StackVisitor.h&quot;
 136 #include &quot;StrictEvalActivation.h&quot;
 137 #include &quot;StrongInlines.h&quot;
 138 #include &quot;StructureInlines.h&quot;
 139 #include &quot;TestRunnerUtils.h&quot;
 140 #include &quot;ThunkGenerators.h&quot;
 141 #include &quot;TypeProfiler.h&quot;
 142 #include &quot;TypeProfilerLog.h&quot;
 143 #include &quot;UnlinkedCodeBlock.h&quot;
 144 #include &quot;VMEntryScope.h&quot;
 145 #include &quot;VMInlines.h&quot;
 146 #include &quot;VMInspector.h&quot;
 147 #include &quot;VariableEnvironment.h&quot;
 148 #include &quot;WasmWorklist.h&quot;
 149 #include &quot;Watchdog.h&quot;
 150 #include &quot;WeakGCMapInlines.h&quot;
 151 #include &quot;WebAssemblyFunction.h&quot;
<span class="line-added"> 152 #include &quot;WebAssemblyFunctionHeapCellType.h&quot;</span>
 153 #include &quot;WebAssemblyWrapperFunction.h&quot;
 154 #include &lt;wtf/ProcessID.h&gt;
 155 #include &lt;wtf/ReadWriteLock.h&gt;
 156 #include &lt;wtf/SimpleStats.h&gt;
 157 #include &lt;wtf/StringPrintStream.h&gt;
 158 #include &lt;wtf/Threading.h&gt;
<span class="line-modified"> 159 #include &lt;wtf/text/AtomStringTable.h&gt;</span>
 160 #include &lt;wtf/text/SymbolRegistry.h&gt;
 161 
 162 #if ENABLE(C_LOOP)
 163 #include &quot;CLoopStack.h&quot;
 164 #include &quot;CLoopStackInlines.h&quot;
 165 #endif
 166 
 167 #if ENABLE(DFG_JIT)
 168 #include &quot;ConservativeRoots.h&quot;
 169 #endif
 170 
 171 #if ENABLE(REGEXP_TRACING)
 172 #include &quot;RegExp.h&quot;
 173 #endif
 174 
 175 namespace JSC {
 176 
 177 #if ENABLE(JIT)
 178 #if !ASSERT_DISABLED
 179 bool VM::s_canUseJITIsSet = false;
 180 #endif
 181 bool VM::s_canUseJIT = false;
 182 #endif
 183 
 184 Atomic&lt;unsigned&gt; VM::s_numberOfIDs;
 185 
 186 // Note: Platform.h will enforce that ENABLE(ASSEMBLER) is true if either
 187 // ENABLE(JIT) or ENABLE(YARR_JIT) or both are enabled. The code below
 188 // just checks for ENABLE(JIT) or ENABLE(YARR_JIT) with this premise in mind.
 189 
 190 #if ENABLE(ASSEMBLER)
<span class="line-modified"> 191 static bool enableAssembler()</span>
 192 {
<span class="line-modified"> 193     if (!Options::useJIT())</span>
 194         return false;
 195 
<span class="line-modified"> 196     char* canUseJITString = getenv(&quot;JavaScriptCoreUseJIT&quot;);</span>
<span class="line-added"> 197     if (canUseJITString &amp;&amp; !atoi(canUseJITString))</span>
<span class="line-added"> 198         return false;</span>
<span class="line-added"> 199 </span>
<span class="line-added"> 200     ExecutableAllocator::initializeUnderlyingAllocator();</span>
<span class="line-added"> 201     if (!ExecutableAllocator::singleton().isValid()) {</span>
 202         if (Options::crashIfCantAllocateJITMemory())
 203             CRASH();
 204         return false;
 205     }
 206 
<span class="line-modified"> 207     return true;</span>

 208 }
 209 #endif // ENABLE(!ASSEMBLER)
 210 
 211 bool VM::canUseAssembler()
 212 {
 213 #if ENABLE(ASSEMBLER)
 214     static std::once_flag onceKey;
 215     static bool enabled = false;
 216     std::call_once(onceKey, [] {
<span class="line-modified"> 217         enabled = enableAssembler();</span>
 218     });
 219     return enabled;
 220 #else
 221     return false; // interpreter only
 222 #endif
 223 }
 224 
 225 void VM::computeCanUseJIT()
 226 {
 227 #if ENABLE(JIT)
 228 #if !ASSERT_DISABLED
 229     RELEASE_ASSERT(!s_canUseJITIsSet);
 230     s_canUseJITIsSet = true;
 231 #endif
 232     s_canUseJIT = VM::canUseAssembler() &amp;&amp; Options::useJIT();
 233 #endif
 234 }
 235 



















 236 inline unsigned VM::nextID()
 237 {
 238     for (;;) {
 239         unsigned currentNumberOfIDs = s_numberOfIDs.load();
 240         unsigned newID = currentNumberOfIDs + 1;
 241         if (s_numberOfIDs.compareExchangeWeak(currentNumberOfIDs, newID))
 242             return newID;
 243     }
 244 }
 245 
<span class="line-added"> 246 static bool vmCreationShouldCrash = false;</span>
 247 
 248 VM::VM(VMType vmType, HeapType heapType)
 249     : m_id(nextID())
 250     , m_apiLock(adoptRef(new JSLock(this)))
 251 #if USE(CF)
 252     , m_runLoop(CFRunLoopGetCurrent())
 253 #endif // USE(CF)
<span class="line-modified"> 254     , heap(*this, heapType)</span>
<span class="line-modified"> 255     , fastMallocAllocator(makeUnique&lt;FastMallocAlignedMemoryAllocator&gt;())</span>
<span class="line-modified"> 256     , primitiveGigacageAllocator(makeUnique&lt;GigacageAlignedMemoryAllocator&gt;(Gigacage::Primitive))</span>
<span class="line-modified"> 257     , jsValueGigacageAllocator(makeUnique&lt;GigacageAlignedMemoryAllocator&gt;(Gigacage::JSValue))</span>
<span class="line-modified"> 258     , auxiliaryHeapCellType(makeUnique&lt;HeapCellType&gt;(CellAttributes(DoesNotNeedDestruction, HeapCell::Auxiliary)))</span>
<span class="line-modified"> 259     , immutableButterflyHeapCellType(makeUnique&lt;HeapCellType&gt;(CellAttributes(DoesNotNeedDestruction, HeapCell::JSCellWithInteriorPointers)))</span>
<span class="line-modified"> 260     , cellHeapCellType(makeUnique&lt;HeapCellType&gt;(CellAttributes(DoesNotNeedDestruction, HeapCell::JSCell)))</span>
<span class="line-modified"> 261     , destructibleCellHeapCellType(makeUnique&lt;HeapCellType&gt;(CellAttributes(NeedsDestruction, HeapCell::JSCell)))</span>
<span class="line-modified"> 262     , stringHeapCellType(makeUnique&lt;JSStringHeapCellType&gt;())</span>
<span class="line-modified"> 263     , destructibleObjectHeapCellType(makeUnique&lt;JSDestructibleObjectHeapCellType&gt;())</span>

 264 #if ENABLE(WEBASSEMBLY)
<span class="line-modified"> 265     , webAssemblyCodeBlockHeapCellType(makeUnique&lt;JSWebAssemblyCodeBlockHeapCellType&gt;())</span>
<span class="line-added"> 266     , webAssemblyFunctionHeapCellType(makeUnique&lt;WebAssemblyFunctionHeapCellType&gt;())</span>
 267 #endif
<span class="line-modified"> 268     , primitiveGigacageAuxiliarySpace(&quot;Primitive Gigacage Auxiliary&quot;, heap, auxiliaryHeapCellType.get(), primitiveGigacageAllocator.get()) // Hash:0x3e7cd762</span>
<span class="line-modified"> 269     , jsValueGigacageAuxiliarySpace(&quot;JSValue Gigacage Auxiliary&quot;, heap, auxiliaryHeapCellType.get(), jsValueGigacageAllocator.get()) // Hash:0x241e946</span>
<span class="line-modified"> 270     , immutableButterflyJSValueGigacageAuxiliarySpace(&quot;ImmutableButterfly Gigacage JSCellWithInteriorPointers&quot;, heap, immutableButterflyHeapCellType.get(), jsValueGigacageAllocator.get()) // Hash:0x7a945300</span>
<span class="line-modified"> 271     , cellSpace(&quot;JSCell&quot;, heap, cellHeapCellType.get(), fastMallocAllocator.get()) // Hash:0xadfb5a79</span>
<span class="line-modified"> 272     , jsValueGigacageCellSpace(&quot;JSValue Gigacage JSCell&quot;, heap, cellHeapCellType.get(), jsValueGigacageAllocator.get()) // Hash:0x2f5b102b</span>
<span class="line-modified"> 273     , destructibleCellSpace(&quot;Destructible JSCell&quot;, heap, destructibleCellHeapCellType.get(), fastMallocAllocator.get()) // Hash:0xbfff3d73</span>
<span class="line-modified"> 274     , stringSpace(&quot;JSString&quot;, heap, stringHeapCellType.get(), fastMallocAllocator.get()) // Hash:0x90cf758f</span>
<span class="line-modified"> 275     , destructibleObjectSpace(&quot;JSDestructibleObject&quot;, heap, destructibleObjectHeapCellType.get(), fastMallocAllocator.get()) // Hash:0x4f5ed7a9</span>
<span class="line-modified"> 276     , eagerlySweptDestructibleObjectSpace(&quot;Eagerly Swept JSDestructibleObject&quot;, heap, destructibleObjectHeapCellType.get(), fastMallocAllocator.get()) // Hash:0x6ebf28e2</span>
<span class="line-modified"> 277     , executableToCodeBlockEdgeSpace ISO_SUBSPACE_INIT(heap, cellHeapCellType.get(), ExecutableToCodeBlockEdge) // Hash:0x7b730b20</span>
<span class="line-modified"> 278     , functionSpace ISO_SUBSPACE_INIT(heap, cellHeapCellType.get(), JSFunction) // Hash:0x800fca72</span>
<span class="line-modified"> 279     , internalFunctionSpace ISO_SUBSPACE_INIT(heap, destructibleObjectHeapCellType.get(), InternalFunction) // Hash:0xf845c464</span>
<span class="line-modified"> 280     , nativeExecutableSpace ISO_SUBSPACE_INIT(heap, destructibleCellHeapCellType.get(), NativeExecutable) // Hash:0x67567f95</span>
<span class="line-modified"> 281     , propertyTableSpace ISO_SUBSPACE_INIT(heap, destructibleCellHeapCellType.get(), PropertyTable) // Hash:0xc6bc9f12</span>
<span class="line-modified"> 282     , structureRareDataSpace ISO_SUBSPACE_INIT(heap, destructibleCellHeapCellType.get(), StructureRareData) // Hash:0xaca4e62d</span>
<span class="line-modified"> 283     , structureSpace ISO_SUBSPACE_INIT(heap, destructibleCellHeapCellType.get(), Structure) // Hash:0x1f1bcdca</span>
<span class="line-modified"> 284     , symbolTableSpace ISO_SUBSPACE_INIT(heap, destructibleCellHeapCellType.get(), SymbolTable) // Hash:0xc5215afd</span>
 285     , executableToCodeBlockEdgesWithConstraints(executableToCodeBlockEdgeSpace)
 286     , executableToCodeBlockEdgesWithFinalizers(executableToCodeBlockEdgeSpace)
<span class="line-modified"> 287     , codeBlockSpace ISO_SUBSPACE_INIT(heap, destructibleCellHeapCellType.get(), CodeBlock) // Hash:0x77e66ec9</span>
<span class="line-modified"> 288     , functionExecutableSpace ISO_SUBSPACE_INIT(heap, destructibleCellHeapCellType.get(), FunctionExecutable) // Hash:0x5d158f3</span>
<span class="line-modified"> 289     , programExecutableSpace ISO_SUBSPACE_INIT(heap, destructibleCellHeapCellType.get(), ProgramExecutable) // Hash:0x527c77e7</span>
<span class="line-modified"> 290     , unlinkedFunctionExecutableSpace ISO_SUBSPACE_INIT(heap, destructibleCellHeapCellType.get(), UnlinkedFunctionExecutable) // Hash:0xf6b828d9</span>
 291     , vmType(vmType)
 292     , clientData(0)
 293     , topEntryFrame(nullptr)
 294     , topCallFrame(CallFrame::noCaller())
<span class="line-modified"> 295     , promiseDeferredTimer(PromiseDeferredTimer::create(*this))</span>
<span class="line-modified"> 296     , m_atomStringTable(vmType == Default ? Thread::current().atomStringTable() : new AtomStringTable)</span>
 297     , propertyNames(nullptr)
 298     , emptyList(new ArgList)
<span class="line-modified"> 299     , machineCodeBytesPerBytecodeWordForBaselineJIT(makeUnique&lt;SimpleStats&gt;())</span>
 300     , customGetterSetterFunctionMap(*this)
 301     , stringCache(*this)
 302     , symbolImplToSymbolMap(*this)
 303     , structureCache(*this)
 304     , interpreter(0)
 305     , entryScope(0)
 306     , m_regExpCache(new RegExpCache(this))
 307     , m_compactVariableMap(adoptRef(*(new CompactVariableMap)))
 308 #if ENABLE(REGEXP_TRACING)
 309     , m_rtTraceList(new RTTraceList())
 310 #endif
 311 #if ENABLE(GC_VALIDATION)
 312     , m_initializingObjectClass(0)
 313 #endif
 314     , m_stackPointerAtVMEntry(0)
<span class="line-modified"> 315     , m_codeCache(makeUnique&lt;CodeCache&gt;())</span>
<span class="line-modified"> 316     , m_builtinExecutables(makeUnique&lt;BuiltinExecutables&gt;(*this))</span>
 317     , m_typeProfilerEnabledCount(0)
 318     , m_primitiveGigacageEnabled(IsWatched)
 319     , m_controlFlowProfilerEnabledCount(0)
 320 {
<span class="line-added"> 321     if (UNLIKELY(vmCreationShouldCrash))</span>
<span class="line-added"> 322         CRASH_WITH_INFO(0x4242424220202020, 0xbadbeef0badbeef, 0x1234123412341234, 0x1337133713371337);</span>
<span class="line-added"> 323 </span>
 324     interpreter = new Interpreter(*this);
 325     StackBounds stack = Thread::current().stack();
 326     updateSoftReservedZoneSize(Options::softReservedZoneSize());
 327     setLastStackTop(stack.origin());
 328 
 329     JSRunLoopTimer::Manager::shared().registerVM(*this);
 330 
 331     // Need to be careful to keep everything consistent here
 332     JSLockHolder lock(this);
<span class="line-modified"> 333     AtomStringTable* existingEntryAtomStringTable = Thread::current().setCurrentAtomStringTable(m_atomStringTable);</span>
 334     structureStructure.set(*this, Structure::createStructure(*this));
 335     structureRareDataStructure.set(*this, StructureRareData::createStructure(*this, 0, jsNull()));
 336     stringStructure.set(*this, JSString::createStructure(*this, 0, jsNull()));
 337 
 338     smallStrings.initializeCommonStrings(*this);
 339 
<span class="line-modified"> 340     propertyNames = new CommonIdentifiers(*this);</span>
 341     terminatedExecutionErrorStructure.set(*this, TerminatedExecutionError::createStructure(*this, 0, jsNull()));
 342     propertyNameEnumeratorStructure.set(*this, JSPropertyNameEnumerator::createStructure(*this, 0, jsNull()));
 343     customGetterSetterStructure.set(*this, CustomGetterSetter::createStructure(*this, 0, jsNull()));
 344     domAttributeGetterSetterStructure.set(*this, DOMAttributeGetterSetter::createStructure(*this, 0, jsNull()));
 345     scopedArgumentsTableStructure.set(*this, ScopedArgumentsTable::createStructure(*this, 0, jsNull()));
 346     apiWrapperStructure.set(*this, JSAPIValueWrapper::createStructure(*this, 0, jsNull()));
 347     nativeExecutableStructure.set(*this, NativeExecutable::createStructure(*this, 0, jsNull()));
 348     evalExecutableStructure.set(*this, EvalExecutable::createStructure(*this, 0, jsNull()));
 349     programExecutableStructure.set(*this, ProgramExecutable::createStructure(*this, 0, jsNull()));
 350     functionExecutableStructure.set(*this, FunctionExecutable::createStructure(*this, 0, jsNull()));
 351 #if ENABLE(WEBASSEMBLY)
 352     webAssemblyCodeBlockStructure.set(*this, JSWebAssemblyCodeBlock::createStructure(*this, 0, jsNull()));
 353 #endif
 354     moduleProgramExecutableStructure.set(*this, ModuleProgramExecutable::createStructure(*this, 0, jsNull()));
 355     regExpStructure.set(*this, RegExp::createStructure(*this, 0, jsNull()));
 356     symbolStructure.set(*this, Symbol::createStructure(*this, 0, jsNull()));
 357     symbolTableStructure.set(*this, SymbolTable::createStructure(*this, 0, jsNull()));
 358     fixedArrayStructure.set(*this, JSFixedArray::createStructure(*this, 0, jsNull()));
 359 
 360     immutableButterflyStructures[arrayIndexFromIndexingType(CopyOnWriteArrayWithInt32) - NumberOfIndexingShapes].set(*this, JSImmutableButterfly::createStructure(*this, 0, jsNull(), CopyOnWriteArrayWithInt32));
 361     immutableButterflyStructures[arrayIndexFromIndexingType(CopyOnWriteArrayWithDouble) - NumberOfIndexingShapes].set(*this, JSImmutableButterfly::createStructure(*this, 0, jsNull(), CopyOnWriteArrayWithDouble));
 362     immutableButterflyStructures[arrayIndexFromIndexingType(CopyOnWriteArrayWithContiguous) - NumberOfIndexingShapes].set(*this, JSImmutableButterfly::createStructure(*this, 0, jsNull(), CopyOnWriteArrayWithContiguous));
 363 
 364     sourceCodeStructure.set(*this, JSSourceCode::createStructure(*this, 0, jsNull()));
 365     scriptFetcherStructure.set(*this, JSScriptFetcher::createStructure(*this, 0, jsNull()));
 366     scriptFetchParametersStructure.set(*this, JSScriptFetchParameters::createStructure(*this, 0, jsNull()));
 367     structureChainStructure.set(*this, StructureChain::createStructure(*this, 0, jsNull()));
 368     sparseArrayValueMapStructure.set(*this, SparseArrayValueMap::createStructure(*this, 0, jsNull()));
 369     templateObjectDescriptorStructure.set(*this, JSTemplateObjectDescriptor::createStructure(*this, 0, jsNull()));
<span class="line-modified"> 370     arrayBufferNeuteringWatchpointStructure.set(*this, ArrayBufferNeuteringWatchpointSet::createStructure(*this));</span>
 371     unlinkedFunctionExecutableStructure.set(*this, UnlinkedFunctionExecutable::createStructure(*this, 0, jsNull()));
 372     unlinkedProgramCodeBlockStructure.set(*this, UnlinkedProgramCodeBlock::createStructure(*this, 0, jsNull()));
 373     unlinkedEvalCodeBlockStructure.set(*this, UnlinkedEvalCodeBlock::createStructure(*this, 0, jsNull()));
 374     unlinkedFunctionCodeBlockStructure.set(*this, UnlinkedFunctionCodeBlock::createStructure(*this, 0, jsNull()));
 375     unlinkedModuleProgramCodeBlockStructure.set(*this, UnlinkedModuleProgramCodeBlock::createStructure(*this, 0, jsNull()));
 376     propertyTableStructure.set(*this, PropertyTable::createStructure(*this, 0, jsNull()));


 377     functionRareDataStructure.set(*this, FunctionRareData::createStructure(*this, 0, jsNull()));
 378     exceptionStructure.set(*this, Exception::createStructure(*this, 0, jsNull()));
 379     promiseDeferredStructure.set(*this, JSPromiseDeferred::createStructure(*this, 0, jsNull()));
 380     internalPromiseDeferredStructure.set(*this, JSInternalPromiseDeferred::createStructure(*this, 0, jsNull()));
 381     nativeStdFunctionCellStructure.set(*this, NativeStdFunctionCell::createStructure(*this, 0, jsNull()));
 382     programCodeBlockStructure.set(*this, ProgramCodeBlock::createStructure(*this, 0, jsNull()));
 383     moduleProgramCodeBlockStructure.set(*this, ModuleProgramCodeBlock::createStructure(*this, 0, jsNull()));
 384     evalCodeBlockStructure.set(*this, EvalCodeBlock::createStructure(*this, 0, jsNull()));
 385     functionCodeBlockStructure.set(*this, FunctionCodeBlock::createStructure(*this, 0, jsNull()));
 386     hashMapBucketSetStructure.set(*this, HashMapBucket&lt;HashMapBucketDataKey&gt;::createStructure(*this, 0, jsNull()));
 387     hashMapBucketMapStructure.set(*this, HashMapBucket&lt;HashMapBucketDataKeyValue&gt;::createStructure(*this, 0, jsNull()));


 388     bigIntStructure.set(*this, JSBigInt::createStructure(*this, 0, jsNull()));
 389     executableToCodeBlockEdgeStructure.set(*this, ExecutableToCodeBlockEdge::createStructure(*this, nullptr, jsNull()));
 390 
 391     // Eagerly initialize constant cells since the concurrent compiler can access them.
 392     if (canUseJIT()) {
 393         sentinelMapBucket();
 394         sentinelSetBucket();
 395     }
 396 
<span class="line-modified"> 397     Thread::current().setCurrentAtomStringTable(existingEntryAtomStringTable);</span>








 398 
 399 #if !ENABLE(C_LOOP)
 400     initializeHostCallReturnValue(); // This is needed to convince the linker not to drop host call return support.
 401 #endif
 402 
 403     Gigacage::addPrimitiveDisableCallback(primitiveGigacageDisabledCallback, this);
 404 
 405     heap.notifyIsSafeToCollect();
 406 
 407     LLInt::Data::performAssertions(*this);
 408 
 409     if (UNLIKELY(Options::useProfiler())) {
<span class="line-modified"> 410         m_perBytecodeProfiler = makeUnique&lt;Profiler::Database&gt;(*this);</span>
 411 
 412         StringPrintStream pathOut;
 413         const char* profilerPath = getenv(&quot;JSC_PROFILER_PATH&quot;);
 414         if (profilerPath)
 415             pathOut.print(profilerPath, &quot;/&quot;);
 416         pathOut.print(&quot;JSCProfile-&quot;, getCurrentProcessID(), &quot;-&quot;, m_perBytecodeProfiler-&gt;databaseID(), &quot;.json&quot;);
 417         m_perBytecodeProfiler-&gt;registerToSaveAtExit(pathOut.toCString().data());
 418     }
 419 
 420     callFrameForCatch = nullptr;
 421 
 422     // Initialize this last, as a free way of asserting that VM initialization itself
 423     // won&#39;t use this.
 424     m_typedArrayController = adoptRef(new SimpleTypedArrayController());
 425 
<span class="line-modified"> 426     m_bytecodeIntrinsicRegistry = makeUnique&lt;BytecodeIntrinsicRegistry&gt;(*this);</span>
 427 
 428     if (Options::useTypeProfiler())
 429         enableTypeProfiler();
 430     if (Options::useControlFlowProfiler())
 431         enableControlFlowProfiler();
 432 #if ENABLE(SAMPLING_PROFILER)
 433     if (Options::useSamplingProfiler()) {
 434         setShouldBuildPCToCodeOriginMapping();
 435         Ref&lt;Stopwatch&gt; stopwatch = Stopwatch::create();
 436         stopwatch-&gt;start();
 437         m_samplingProfiler = adoptRef(new SamplingProfiler(*this, WTFMove(stopwatch)));
 438         if (Options::samplingProfilerPath())
 439             m_samplingProfiler-&gt;registerForReportAtExit();
 440         m_samplingProfiler-&gt;start();
 441     }
 442 #endif // ENABLE(SAMPLING_PROFILER)
 443 
<span class="line-added"> 444     if (Options::useRandomizingFuzzerAgent())</span>
<span class="line-added"> 445         setFuzzerAgent(makeUnique&lt;RandomizingFuzzerAgent&gt;(*this));</span>
<span class="line-added"> 446     else if (Options::useDoublePredictionFuzzerAgent())</span>
<span class="line-added"> 447         setFuzzerAgent(makeUnique&lt;DoublePredictionFuzzerAgent&gt;(*this));</span>
<span class="line-added"> 448 </span>
 449     if (Options::alwaysGeneratePCToCodeOriginMap())
 450         setShouldBuildPCToCodeOriginMapping();
 451 
 452     if (Options::watchdog()) {
 453         Watchdog&amp; watchdog = ensureWatchdog();
 454         watchdog.setTimeLimit(Seconds::fromMilliseconds(Options::watchdog()));
 455     }
 456 
 457 #if ENABLE(JIT)
 458     // Make sure that any stubs that the JIT is going to use are initialized in non-compilation threads.
 459     if (canUseJIT()) {
<span class="line-added"> 460         jitStubs = makeUnique&lt;JITThunks&gt;();</span>
<span class="line-added"> 461 #if ENABLE(FTL_JIT)</span>
<span class="line-added"> 462         ftlThunks = makeUnique&lt;FTL::Thunks&gt;();</span>
<span class="line-added"> 463 #endif // ENABLE(FTL_JIT)</span>
 464         getCTIInternalFunctionTrampolineFor(CodeForCall);
 465         getCTIInternalFunctionTrampolineFor(CodeForConstruct);
 466     }
 467 #endif
 468 



 469     if (Options::forceDebuggerBytecodeGeneration() || Options::alwaysUseShadowChicken())
 470         ensureShadowChicken();
 471 
 472     VMInspector::instance().add(this);
 473 }
 474 
 475 static ReadWriteLock s_destructionLock;
 476 
 477 void waitForVMDestruction()
 478 {
 479     auto locker = holdLock(s_destructionLock.write());
 480 }
 481 
 482 VM::~VM()
 483 {
 484     auto destructionLocker = holdLock(s_destructionLock.read());
 485 
 486     Gigacage::removePrimitiveDisableCallback(primitiveGigacageDisabledCallback, this);
 487     promiseDeferredTimer-&gt;stopRunningTasks();
 488 #if ENABLE(WEBASSEMBLY)
</pre>
<hr />
<pre>
 525 
 526     // Clear this first to ensure that nobody tries to remove themselves from it.
 527     m_perBytecodeProfiler = nullptr;
 528 
 529     ASSERT(currentThreadIsHoldingAPILock());
 530     m_apiLock-&gt;willDestroyVM(this);
 531     smallStrings.setIsInitialized(false);
 532     heap.lastChanceToFinalize();
 533 
 534     JSRunLoopTimer::Manager::shared().unregisterVM(*this);
 535 
 536     delete interpreter;
 537 #ifndef NDEBUG
 538     interpreter = reinterpret_cast&lt;Interpreter*&gt;(0xbbadbeef);
 539 #endif
 540 
 541     delete emptyList;
 542 
 543     delete propertyNames;
 544     if (vmType != Default)
<span class="line-modified"> 545         delete m_atomStringTable;</span>
 546 
 547     delete clientData;
 548     delete m_regExpCache;
 549 
 550 #if ENABLE(REGEXP_TRACING)
 551     delete m_rtTraceList;
 552 #endif
 553 
 554 #if ENABLE(DFG_JIT)
 555     for (unsigned i = 0; i &lt; m_scratchBuffers.size(); ++i)
 556         fastFree(m_scratchBuffers[i]);
 557 #endif
 558 }
 559 
 560 void VM::primitiveGigacageDisabledCallback(void* argument)
 561 {
 562     static_cast&lt;VM*&gt;(argument)-&gt;primitiveGigacageDisabled();
 563 }
 564 
 565 void VM::primitiveGigacageDisabled()
</pre>
<hr />
<pre>
 602         instance = adoptRef(new VM(APIShared, SmallHeap)).leakRef();
 603     return *instance;
 604 }
 605 
 606 VM*&amp; VM::sharedInstanceInternal()
 607 {
 608     static VM* sharedInstance;
 609     return sharedInstance;
 610 }
 611 
 612 Watchdog&amp; VM::ensureWatchdog()
 613 {
 614     if (!m_watchdog)
 615         m_watchdog = adoptRef(new Watchdog(this));
 616     return *m_watchdog;
 617 }
 618 
 619 HeapProfiler&amp; VM::ensureHeapProfiler()
 620 {
 621     if (!m_heapProfiler)
<span class="line-modified"> 622         m_heapProfiler = makeUnique&lt;HeapProfiler&gt;(*this);</span>
 623     return *m_heapProfiler;
 624 }
 625 
 626 #if ENABLE(SAMPLING_PROFILER)
 627 SamplingProfiler&amp; VM::ensureSamplingProfiler(RefPtr&lt;Stopwatch&gt;&amp;&amp; stopwatch)
 628 {
 629     if (!m_samplingProfiler)
 630         m_samplingProfiler = adoptRef(new SamplingProfiler(*this, WTFMove(stopwatch)));
 631     return *m_samplingProfiler;
 632 }
 633 #endif // ENABLE(SAMPLING_PROFILER)
 634 
 635 #if ENABLE(JIT)
 636 static ThunkGenerator thunkGeneratorForIntrinsic(Intrinsic intrinsic)
 637 {
 638     switch (intrinsic) {
 639     case CharCodeAtIntrinsic:
 640         return charCodeAtThunkGenerator;
 641     case CharAtIntrinsic:
 642         return charAtThunkGenerator;
</pre>
<hr />
<pre>
 666         return randomThunkGenerator;
 667     case BoundThisNoArgsFunctionCallIntrinsic:
 668         return boundThisNoArgsFunctionCallGenerator;
 669     default:
 670         return nullptr;
 671     }
 672 }
 673 
 674 #endif // ENABLE(JIT)
 675 
 676 NativeExecutable* VM::getHostFunction(NativeFunction function, NativeFunction constructor, const String&amp; name)
 677 {
 678     return getHostFunction(function, NoIntrinsic, constructor, nullptr, name);
 679 }
 680 
 681 static Ref&lt;NativeJITCode&gt; jitCodeForCallTrampoline()
 682 {
 683     static NativeJITCode* result;
 684     static std::once_flag onceKey;
 685     std::call_once(onceKey, [&amp;] {
<span class="line-modified"> 686         result = new NativeJITCode(LLInt::getCodeRef&lt;JSEntryPtrTag&gt;(llint_native_call_trampoline), JITType::HostCallThunk, NoIntrinsic);</span>
 687     });
 688     return makeRef(*result);
 689 }
 690 
 691 static Ref&lt;NativeJITCode&gt; jitCodeForConstructTrampoline()
 692 {
 693     static NativeJITCode* result;
 694     static std::once_flag onceKey;
 695     std::call_once(onceKey, [&amp;] {
<span class="line-modified"> 696         result = new NativeJITCode(LLInt::getCodeRef&lt;JSEntryPtrTag&gt;(llint_native_construct_trampoline), JITType::HostCallThunk, NoIntrinsic);</span>
 697     });
 698     return makeRef(*result);
 699 }
 700 
 701 NativeExecutable* VM::getHostFunction(NativeFunction function, Intrinsic intrinsic, NativeFunction constructor, const DOMJIT::Signature* signature, const String&amp; name)
 702 {
 703 #if ENABLE(JIT)
 704     if (canUseJIT()) {
 705         return jitStubs-&gt;hostFunctionStub(
<span class="line-modified"> 706             *this, function, constructor,</span>
 707             intrinsic != NoIntrinsic ? thunkGeneratorForIntrinsic(intrinsic) : 0,
 708             intrinsic, signature, name);
 709     }
 710 #endif // ENABLE(JIT)
 711     UNUSED_PARAM(intrinsic);
 712     UNUSED_PARAM(signature);
 713     return NativeExecutable::create(*this, jitCodeForCallTrampoline(), function, jitCodeForConstructTrampoline(), constructor, name);
 714 }
 715 
 716 MacroAssemblerCodePtr&lt;JSEntryPtrTag&gt; VM::getCTIInternalFunctionTrampolineFor(CodeSpecializationKind kind)
 717 {
 718 #if ENABLE(JIT)
 719     if (canUseJIT()) {
 720         if (kind == CodeForCall)
<span class="line-modified"> 721             return jitStubs-&gt;ctiInternalFunctionCall(*this).retagged&lt;JSEntryPtrTag&gt;();</span>
<span class="line-modified"> 722         return jitStubs-&gt;ctiInternalFunctionConstruct(*this).retagged&lt;JSEntryPtrTag&gt;();</span>
 723     }
 724 #endif
 725     if (kind == CodeForCall)
 726         return LLInt::getCodePtr&lt;JSEntryPtrTag&gt;(llint_internal_function_call_trampoline);
 727     return LLInt::getCodePtr&lt;JSEntryPtrTag&gt;(llint_internal_function_construct_trampoline);
 728 }
 729 
 730 VM::ClientData::~ClientData()
 731 {
 732 }
 733 
 734 void VM::resetDateCache()
 735 {
<span class="line-added"> 736     utcTimeOffsetCache.reset();</span>
 737     localTimeOffsetCache.reset();
 738     cachedDateString = String();
 739     cachedDateStringValue = std::numeric_limits&lt;double&gt;::quiet_NaN();
 740     dateInstanceCache.reset();
 741 }
 742 
 743 void VM::whenIdle(Function&lt;void()&gt;&amp;&amp; callback)
 744 {
 745     if (!entryScope) {
 746         callback();
 747         return;
 748     }
 749 
 750     entryScope-&gt;addDidPopListener(WTFMove(callback));
 751 }
 752 
 753 void VM::deleteAllLinkedCode(DeleteAllCodeEffort effort)
 754 {
 755     whenIdle([=] () {
 756         heap.deleteAllCodeBlocks(effort);
 757     });
 758 }
 759 
 760 void VM::deleteAllCode(DeleteAllCodeEffort effort)
 761 {
 762     whenIdle([=] () {
 763         m_codeCache-&gt;clear();
 764         m_regExpCache-&gt;deleteAllCode();
 765         heap.deleteAllCodeBlocks(effort);
 766         heap.deleteAllUnlinkedCodeBlocks(effort);
 767         heap.reportAbandonedObjectGraph();
 768     });
 769 }
 770 
 771 void VM::shrinkFootprintWhenIdle()
 772 {
 773     whenIdle([=] () {
<span class="line-modified"> 774         sanitizeStackForVM(*this);</span>
 775         deleteAllCode(DeleteAllCodeIfNotCollecting);
 776         heap.collectNow(Synchronousness::Sync, CollectionScope::Full);
 777         // FIXME: Consider stopping various automatic threads here.
 778         // https://bugs.webkit.org/show_bug.cgi?id=185447
 779         WTF::releaseFastMallocFreeMemory();
 780     });
 781 }
 782 
 783 SourceProviderCache* VM::addSourceProviderCache(SourceProvider* sourceProvider)
 784 {
 785     auto addResult = sourceProviderCacheMap.add(sourceProvider, nullptr);
 786     if (addResult.isNewEntry)
 787         addResult.iterator-&gt;value = adoptRef(new SourceProviderCache);
 788     return addResult.iterator-&gt;value.get();
 789 }
 790 
 791 void VM::clearSourceProviderCaches()
 792 {
 793     sourceProviderCacheMap.clear();
 794 }
 795 
<span class="line-modified"> 796 Exception* VM::throwException(ExecState* exec, Exception* exception)</span>
 797 {
 798     ASSERT(exec == topCallFrame || exec-&gt;isGlobalExec() || exec == exec-&gt;lexicalGlobalObject()-&gt;callFrameAtDebuggerEntry());
 799     CallFrame* throwOriginFrame = exec-&gt;isGlobalExec() ? exec : topJSCallFrame();
 800 
 801     if (Options::breakOnThrow()) {
 802         CodeBlock* codeBlock = throwOriginFrame ? throwOriginFrame-&gt;codeBlock() : nullptr;
 803         dataLog(&quot;Throwing exception in call frame &quot;, RawPointer(throwOriginFrame), &quot; for code block &quot;, codeBlock, &quot;\n&quot;);
 804         CRASH();
 805     }
 806 
 807     interpreter-&gt;notifyDebuggerOfExceptionToBeThrown(*this, throwOriginFrame, exception);
 808 
 809     setException(exception);
 810 
 811 #if ENABLE(EXCEPTION_SCOPE_VERIFICATION)
 812     m_nativeStackTraceOfLastThrow = StackTrace::captureStackTrace(Options::unexpectedExceptionStackTraceLimit());
 813     m_throwingThread = &amp;Thread::current();
 814 #endif
<span class="line-added"> 815     return exception;</span>
 816 }
 817 
<span class="line-modified"> 818 Exception* VM::throwException(ExecState* exec, JSValue thrownValue)</span>
 819 {
 820     VM&amp; vm = *this;
 821     Exception* exception = jsDynamicCast&lt;Exception*&gt;(vm, thrownValue);
 822     if (!exception)
 823         exception = Exception::create(*this, thrownValue);
 824 
<span class="line-modified"> 825     return throwException(exec, exception);</span>

 826 }
 827 
<span class="line-modified"> 828 Exception* VM::throwException(ExecState* exec, JSObject* error)</span>
 829 {
<span class="line-modified"> 830     return throwException(exec, JSValue(error));</span>
 831 }
 832 
 833 void VM::setStackPointerAtVMEntry(void* sp)
 834 {
 835     m_stackPointerAtVMEntry = sp;
 836     updateStackLimits();
 837 }
 838 
 839 size_t VM::updateSoftReservedZoneSize(size_t softReservedZoneSize)
 840 {
 841     size_t oldSoftReservedZoneSize = m_currentSoftReservedZoneSize;
 842     m_currentSoftReservedZoneSize = softReservedZoneSize;
 843 #if ENABLE(C_LOOP)
 844     interpreter-&gt;cloopStack().setSoftReservedZoneSize(softReservedZoneSize);
 845 #endif
 846 
 847     updateStackLimits();
 848 
 849     return oldSoftReservedZoneSize;
 850 }
</pre>
<hr />
<pre>
 908     // used exclusively by C++ code, and the C++ compiler will automatically commit the
 909     // needed stack pages.
 910     if (lastSoftStackLimit != m_softStackLimit)
 911         preCommitStackMemory(m_softStackLimit);
 912 #endif
 913 }
 914 
 915 #if ENABLE(DFG_JIT)
 916 void VM::gatherScratchBufferRoots(ConservativeRoots&amp; conservativeRoots)
 917 {
 918     auto lock = holdLock(m_scratchBufferLock);
 919     for (auto* scratchBuffer : m_scratchBuffers) {
 920         if (scratchBuffer-&gt;activeLength()) {
 921             void* bufferStart = scratchBuffer-&gt;dataBuffer();
 922             conservativeRoots.add(bufferStart, static_cast&lt;void*&gt;(static_cast&lt;char*&gt;(bufferStart) + scratchBuffer-&gt;activeLength()));
 923         }
 924     }
 925 }
 926 #endif
 927 
<span class="line-modified"> 928 void logSanitizeStack(VM&amp; vm)</span>
 929 {
<span class="line-modified"> 930     if (Options::verboseSanitizeStack() &amp;&amp; vm.topCallFrame) {</span>
 931         int dummy;
 932         auto&amp; stackBounds = Thread::current().stack();
 933         dataLog(
<span class="line-modified"> 934             &quot;Sanitizing stack for VM = &quot;, RawPointer(&amp;vm), &quot; with top call frame at &quot;, RawPointer(vm.topCallFrame),</span>
 935             &quot;, current stack pointer at &quot;, RawPointer(&amp;dummy), &quot;, in &quot;,
<span class="line-modified"> 936             pointerDump(vm.topCallFrame-&gt;codeBlock()), &quot;, last code origin = &quot;,</span>
<span class="line-modified"> 937             vm.topCallFrame-&gt;codeOrigin(), &quot;, last stack top = &quot;, RawPointer(vm.lastStackTop()), &quot;, in stack range [&quot;, RawPointer(stackBounds.origin()), &quot;, &quot;, RawPointer(stackBounds.end()), &quot;]\n&quot;);</span>
 938     }
 939 }
 940 
 941 #if ENABLE(YARR_JIT_ALL_PARENS_EXPRESSIONS)
 942 char* VM::acquireRegExpPatternContexBuffer()
 943 {
 944     m_regExpPatternContextLock.lock();
 945     ASSERT(m_regExpPatternContextLock.isLocked());
 946     if (!m_regExpPatternContexBuffer)
 947         m_regExpPatternContexBuffer = makeUniqueArray&lt;char&gt;(VM::patternContextBufferSize);
 948     return m_regExpPatternContexBuffer.get();
 949 }
 950 
 951 void VM::releaseRegExpPatternContexBuffer()
 952 {
 953     ASSERT(m_regExpPatternContextLock.isLocked());
 954 
 955     m_regExpPatternContextLock.unlock();
 956 }
 957 #endif
</pre>
<hr />
<pre>
1024     return needsToRecompile;
1025 }
1026 
1027 template&lt;typename Func&gt;
1028 static bool disableProfilerWithRespectToCount(unsigned&amp; counter, const Func&amp; doDisableWork)
1029 {
1030     RELEASE_ASSERT(counter &gt; 0);
1031     bool needsToRecompile = false;
1032     counter--;
1033     if (!counter) {
1034         doDisableWork();
1035         needsToRecompile = true;
1036     }
1037 
1038     return needsToRecompile;
1039 }
1040 
1041 bool VM::enableTypeProfiler()
1042 {
1043     auto enableTypeProfiler = [this] () {
<span class="line-modified">1044         this-&gt;m_typeProfiler = makeUnique&lt;TypeProfiler&gt;();</span>
<span class="line-modified">1045         this-&gt;m_typeProfilerLog = makeUnique&lt;TypeProfilerLog&gt;(*this);</span>
1046     };
1047 
1048     return enableProfilerWithRespectToCount(m_typeProfilerEnabledCount, enableTypeProfiler);
1049 }
1050 
1051 bool VM::disableTypeProfiler()
1052 {
1053     auto disableTypeProfiler = [this] () {
1054         this-&gt;m_typeProfiler.reset(nullptr);
1055         this-&gt;m_typeProfilerLog.reset(nullptr);
1056     };
1057 
1058     return disableProfilerWithRespectToCount(m_typeProfilerEnabledCount, disableTypeProfiler);
1059 }
1060 
1061 bool VM::enableControlFlowProfiler()
1062 {
1063     auto enableControlFlowProfiler = [this] () {
<span class="line-modified">1064         this-&gt;m_controlFlowProfiler = makeUnique&lt;ControlFlowProfiler&gt;();</span>
1065     };
1066 
1067     return enableProfilerWithRespectToCount(m_controlFlowProfilerEnabledCount, enableControlFlowProfiler);
1068 }
1069 
1070 bool VM::disableControlFlowProfiler()
1071 {
1072     auto disableControlFlowProfiler = [this] () {
1073         this-&gt;m_controlFlowProfiler.reset(nullptr);
1074     };
1075 
1076     return disableProfilerWithRespectToCount(m_controlFlowProfilerEnabledCount, disableControlFlowProfiler);
1077 }
1078 
1079 void VM::dumpTypeProfilerData()
1080 {
1081     if (!typeProfiler())
1082         return;
1083 
1084     typeProfilerLog()-&gt;processLogEntries(*this, &quot;VM Dump Types&quot;_s);
1085     typeProfiler()-&gt;dumpTypeProfilerData(*this);
1086 }
1087 
1088 void VM::queueMicrotask(JSGlobalObject&amp; globalObject, Ref&lt;Microtask&gt;&amp;&amp; task)
1089 {
<span class="line-modified">1090     m_microtaskQueue.append(makeUnique&lt;QueuedTask&gt;(*this, &amp;globalObject, WTFMove(task)));</span>
1091 }
1092 
<span class="line-modified">1093 void VM::callPromiseRejectionCallback(Strong&lt;JSPromise&gt;&amp; promise)</span>
1094 {
<span class="line-modified">1095     JSObject* callback = promise-&gt;globalObject()-&gt;unhandledRejectionCallback();</span>
<span class="line-modified">1096     if (!callback)</span>
<span class="line-modified">1097         return;</span>
<span class="line-modified">1098 </span>
<span class="line-added">1099     auto scope = DECLARE_CATCH_SCOPE(*this);</span>
<span class="line-added">1100 </span>
<span class="line-added">1101     CallData callData;</span>
<span class="line-added">1102     CallType callType = getCallData(*this, callback, callData);</span>
<span class="line-added">1103     ASSERT(callType != CallType::None);</span>
<span class="line-added">1104 </span>
<span class="line-added">1105     MarkedArgumentBuffer args;</span>
<span class="line-added">1106     args.append(promise.get());</span>
<span class="line-added">1107     args.append(promise-&gt;result(*this));</span>
<span class="line-added">1108     call(promise-&gt;globalObject()-&gt;globalExec(), callback, callType, callData, jsNull(), args);</span>
<span class="line-added">1109     scope.clearException();</span>
<span class="line-added">1110 }</span>
<span class="line-added">1111 </span>
<span class="line-added">1112 void VM::didExhaustMicrotaskQueue()</span>
<span class="line-added">1113 {</span>
<span class="line-added">1114     auto unhandledRejections = WTFMove(m_aboutToBeNotifiedRejectedPromises);</span>
<span class="line-added">1115     for (auto&amp; promise : unhandledRejections) {</span>
<span class="line-added">1116         if (promise-&gt;isHandled(*this))</span>
<span class="line-added">1117             continue;</span>
<span class="line-added">1118 </span>
<span class="line-added">1119         callPromiseRejectionCallback(promise);</span>
1120     }
1121 }
1122 
<span class="line-added">1123 void VM::promiseRejected(JSPromise* promise)</span>
<span class="line-added">1124 {</span>
<span class="line-added">1125     m_aboutToBeNotifiedRejectedPromises.constructAndAppend(*this, promise);</span>
<span class="line-added">1126 }</span>
<span class="line-added">1127 </span>
<span class="line-added">1128 void VM::drainMicrotasks()</span>
<span class="line-added">1129 {</span>
<span class="line-added">1130     do {</span>
<span class="line-added">1131         while (!m_microtaskQueue.isEmpty()) {</span>
<span class="line-added">1132             m_microtaskQueue.takeFirst()-&gt;run();</span>
<span class="line-added">1133             if (m_onEachMicrotaskTick)</span>
<span class="line-added">1134                 m_onEachMicrotaskTick(*this);</span>
<span class="line-added">1135         }</span>
<span class="line-added">1136         didExhaustMicrotaskQueue();</span>
<span class="line-added">1137     } while (!m_microtaskQueue.isEmpty());</span>
<span class="line-added">1138     finalizeSynchronousJSExecution();</span>
<span class="line-added">1139 }</span>
<span class="line-added">1140 </span>
1141 void QueuedTask::run()
1142 {
1143     m_microtask-&gt;run(m_globalObject-&gt;globalExec());
1144 }
1145 
<span class="line-modified">1146 void sanitizeStackForVM(VM&amp; vm)</span>
1147 {
1148     logSanitizeStack(vm);
<span class="line-modified">1149     if (vm.topCallFrame) {</span>
1150         auto&amp; stackBounds = Thread::current().stack();
<span class="line-modified">1151         ASSERT(vm.currentThreadIsHoldingAPILock());</span>
<span class="line-modified">1152         ASSERT_UNUSED(stackBounds, stackBounds.contains(vm.lastStackTop()));</span>
1153     }
1154 #if ENABLE(C_LOOP)
<span class="line-modified">1155     vm.interpreter-&gt;cloopStack().sanitizeStack();</span>
1156 #else
<span class="line-modified">1157     sanitizeStackForVMImpl(&amp;vm);</span>
1158 #endif
1159 }
1160 
1161 size_t VM::committedStackByteCount()
1162 {
1163 #if !ENABLE(C_LOOP)
1164     // When using the C stack, we don&#39;t know how many stack pages are actually
1165     // committed. So, we use the current stack usage as an estimate.
1166     ASSERT(Thread::current().stack().isGrowingDownward());
1167     uint8_t* current = bitwise_cast&lt;uint8_t*&gt;(currentStackPointer());
1168     uint8_t* high = bitwise_cast&lt;uint8_t*&gt;(Thread::current().stack().origin());
1169     return high - current;
1170 #else
1171     return CLoopStack::committedByteCount();
1172 #endif
1173 }
1174 
1175 #if ENABLE(C_LOOP)
1176 bool VM::ensureStackCapacityForCLoop(Register* newTopOfStack)
1177 {
1178     return interpreter-&gt;cloopStack().ensureCapacityFor(newTopOfStack);
1179 }
1180 
1181 bool VM::isSafeToRecurseSoftCLoop() const
1182 {
1183     return interpreter-&gt;cloopStack().isSafeToRecurse();
1184 }
<span class="line-added">1185 </span>
<span class="line-added">1186 void* VM::currentCLoopStackPointer() const</span>
<span class="line-added">1187 {</span>
<span class="line-added">1188     return interpreter-&gt;cloopStack().currentStackPointer();</span>
<span class="line-added">1189 }</span>
1190 #endif // ENABLE(C_LOOP)
1191 
1192 #if ENABLE(EXCEPTION_SCOPE_VERIFICATION)
1193 void VM::verifyExceptionCheckNeedIsSatisfied(unsigned recursionDepth, ExceptionEventLocation&amp; location)
1194 {
1195     if (!Options::validateExceptionChecks())
1196         return;
1197 
1198     if (UNLIKELY(m_needExceptionCheck)) {
1199         auto throwDepth = m_simulatedThrowPointRecursionDepth;
1200         auto&amp; throwLocation = m_simulatedThrowPointLocation;
1201 
1202         dataLog(
1203             &quot;ERROR: Unchecked JS exception:\n&quot;
1204             &quot;    This scope can throw a JS exception: &quot;, throwLocation, &quot;\n&quot;
1205             &quot;        (ExceptionScope::m_recursionDepth was &quot;, throwDepth, &quot;)\n&quot;
1206             &quot;    But the exception was unchecked as of this scope: &quot;, location, &quot;\n&quot;
1207             &quot;        (ExceptionScope::m_recursionDepth was &quot;, recursionDepth, &quot;)\n&quot;
1208             &quot;\n&quot;);
1209 
</pre>
<hr />
<pre>
1251         ScratchBuffer* newBuffer = ScratchBuffer::create(m_sizeOfLastScratchBuffer);
1252         RELEASE_ASSERT(newBuffer);
1253         m_scratchBuffers.append(newBuffer);
1254     }
1255 
1256     ScratchBuffer* result = m_scratchBuffers.last();
1257     return result;
1258 }
1259 
1260 void VM::clearScratchBuffers()
1261 {
1262     auto lock = holdLock(m_scratchBufferLock);
1263     for (auto* scratchBuffer : m_scratchBuffers)
1264         scratchBuffer-&gt;setActiveLength(0);
1265 }
1266 
1267 void VM::ensureShadowChicken()
1268 {
1269     if (m_shadowChicken)
1270         return;
<span class="line-modified">1271     m_shadowChicken = makeUnique&lt;ShadowChicken&gt;();</span>
1272 }
1273 
1274 #define DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(name, heapCellType, type) \
1275     IsoSubspace* VM::name##Slow() \
1276     { \
1277         ASSERT(!m_##name); \
<span class="line-modified">1278         auto space = makeUnique&lt;IsoSubspace&gt; ISO_SUBSPACE_INIT(heap, heapCellType, type); \</span>
1279         WTF::storeStoreFence(); \
1280         m_##name = WTFMove(space); \
1281         return m_##name.get(); \
1282     }
1283 
1284 
<span class="line-modified">1285 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(boundFunctionSpace, cellHeapCellType.get(), JSBoundFunction) // Hash:0xd7916d41</span>
<span class="line-modified">1286 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(callbackFunctionSpace, destructibleObjectHeapCellType.get(), JSCallbackFunction) // Hash:0xe7648ebc</span>
<span class="line-modified">1287 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(customGetterSetterFunctionSpace, cellHeapCellType.get(), JSCustomGetterSetterFunction) // Hash:0x18091000</span>
<span class="line-modified">1288 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(errorInstanceSpace, destructibleObjectHeapCellType.get(), ErrorInstance) // Hash:0x3f40d4a</span>
<span class="line-modified">1289 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(nativeStdFunctionSpace, cellHeapCellType.get(), JSNativeStdFunction) // Hash:0x70ed61e4</span>
<span class="line-modified">1290 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(proxyRevokeSpace, destructibleObjectHeapCellType.get(), ProxyRevoke) // Hash:0xb506a939</span>
<span class="line-modified">1291 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(weakMapSpace, destructibleObjectHeapCellType.get(), JSWeakMap) // Hash:0x662b12a3</span>
<span class="line-modified">1292 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(weakSetSpace, destructibleObjectHeapCellType.get(), JSWeakSet) // Hash:0x4c781b30</span>
<span class="line-added">1293 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(weakObjectRefSpace, cellHeapCellType.get(), JSWeakObjectRef) // Hash:0x8ec68f1f</span>
1294 #if JSC_OBJC_API_ENABLED
<span class="line-modified">1295 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(objCCallbackFunctionSpace, destructibleObjectHeapCellType.get(), ObjCCallbackFunction) // Hash:0x10f610b8</span>
1296 #endif
1297 #if ENABLE(WEBASSEMBLY)
<span class="line-modified">1298 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(webAssemblyCodeBlockSpace, webAssemblyCodeBlockHeapCellType.get(), JSWebAssemblyCodeBlock) // Hash:0x9ad995cd</span>
<span class="line-modified">1299 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(webAssemblyFunctionSpace, webAssemblyFunctionHeapCellType.get(), WebAssemblyFunction) // Hash:0x8b7c32db</span>
<span class="line-modified">1300 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(webAssemblyWrapperFunctionSpace, cellHeapCellType.get(), WebAssemblyWrapperFunction) // Hash:0xd4a5ff01</span>
1301 #endif
1302 
1303 #undef DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW
1304 
1305 #define DYNAMIC_SPACE_AND_SET_DEFINE_MEMBER_SLOW(name, heapCellType, type) \
1306     IsoSubspace* VM::name##Slow() \
1307     { \
1308         ASSERT(!m_##name); \
<span class="line-modified">1309         auto space = makeUnique&lt;SpaceAndSet&gt; ISO_SUBSPACE_INIT(heap, heapCellType, type); \</span>
1310         WTF::storeStoreFence(); \
1311         m_##name = WTFMove(space); \
1312         return &amp;m_##name-&gt;space; \
1313     }
1314 
<span class="line-modified">1315 DYNAMIC_SPACE_AND_SET_DEFINE_MEMBER_SLOW(evalExecutableSpace, destructibleCellHeapCellType.get(), EvalExecutable) // Hash:0x958e3e9d</span>
<span class="line-modified">1316 DYNAMIC_SPACE_AND_SET_DEFINE_MEMBER_SLOW(moduleProgramExecutableSpace, destructibleCellHeapCellType.get(), ModuleProgramExecutable) // Hash:0x6506fa3c</span>

1317 
1318 #undef DYNAMIC_SPACE_AND_SET_DEFINE_MEMBER_SLOW
1319 
<span class="line-added">1320 Structure* VM::setIteratorStructureSlow()</span>
<span class="line-added">1321 {</span>
<span class="line-added">1322     ASSERT(!m_setIteratorStructure);</span>
<span class="line-added">1323     m_setIteratorStructure.set(*this, JSSetIterator::createStructure(*this, 0, jsNull()));</span>
<span class="line-added">1324     return m_setIteratorStructure.get();</span>
<span class="line-added">1325 }</span>
<span class="line-added">1326 </span>
<span class="line-added">1327 Structure* VM::mapIteratorStructureSlow()</span>
<span class="line-added">1328 {</span>
<span class="line-added">1329     ASSERT(!m_mapIteratorStructure);</span>
<span class="line-added">1330     m_mapIteratorStructure.set(*this, JSMapIterator::createStructure(*this, 0, jsNull()));</span>
<span class="line-added">1331     return m_mapIteratorStructure.get();</span>
<span class="line-added">1332 }</span>
1333 
1334 JSCell* VM::sentinelSetBucketSlow()
1335 {
1336     ASSERT(!m_sentinelSetBucket);
1337     auto* sentinel = JSSet::BucketType::createSentinel(*this);
1338     m_sentinelSetBucket.set(*this, sentinel);
1339     return sentinel;
1340 }
1341 
1342 JSCell* VM::sentinelMapBucketSlow()
1343 {
1344     ASSERT(!m_sentinelMapBucket);
1345     auto* sentinel = JSMap::BucketType::createSentinel(*this);
1346     m_sentinelMapBucket.set(*this, sentinel);
1347     return sentinel;
1348 }
1349 
<span class="line-added">1350 JSPropertyNameEnumerator* VM::emptyPropertyNameEnumeratorSlow()</span>
<span class="line-added">1351 {</span>
<span class="line-added">1352     ASSERT(!m_emptyPropertyNameEnumerator);</span>
<span class="line-added">1353     PropertyNameArray propertyNames(*this, PropertyNameMode::Strings, PrivateSymbolMode::Exclude);</span>
<span class="line-added">1354     auto* enumerator = JSPropertyNameEnumerator::create(*this, nullptr, 0, 0, WTFMove(propertyNames));</span>
<span class="line-added">1355     m_emptyPropertyNameEnumerator.set(*this, enumerator);</span>
<span class="line-added">1356     return enumerator;</span>
<span class="line-added">1357 }</span>
<span class="line-added">1358 </span>
1359 JSGlobalObject* VM::vmEntryGlobalObject(const CallFrame* callFrame) const
1360 {
1361     if (callFrame &amp;&amp; callFrame-&gt;isGlobalExec()) {
1362         ASSERT(callFrame-&gt;callee().isCell() &amp;&amp; callFrame-&gt;callee().asCell()-&gt;isObject());
1363         ASSERT(callFrame == callFrame-&gt;lexicalGlobalObject()-&gt;globalExec());
1364         return callFrame-&gt;lexicalGlobalObject();
1365     }
1366     ASSERT(entryScope);
1367     return entryScope-&gt;globalObject();
1368 }
1369 
<span class="line-added">1370 void VM::setCrashOnVMCreation(bool shouldCrash)</span>
<span class="line-added">1371 {</span>
<span class="line-added">1372     vmCreationShouldCrash = shouldCrash;</span>
<span class="line-added">1373 }</span>
<span class="line-added">1374 </span>
1375 } // namespace JSC
</pre>
</td>
</tr>
</table>
<center><a href="TypeSet.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="VM.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>