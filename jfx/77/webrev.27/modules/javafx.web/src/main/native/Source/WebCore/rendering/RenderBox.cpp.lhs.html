<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderBox.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
   3  *           (C) 1999 Antti Koivisto (koivisto@kde.org)
   4  *           (C) 2005 Allan Sandfeld Jensen (kde@carewolf.com)
   5  *           (C) 2005, 2006 Samuel Weinig (sam.weinig@gmail.com)
   6  * Copyright (C) 2005-2010, 2015 Apple Inc. All rights reserved.
   7  *
   8  * This library is free software; you can redistribute it and/or
   9  * modify it under the terms of the GNU Library General Public
  10  * License as published by the Free Software Foundation; either
  11  * version 2 of the License, or (at your option) any later version.
  12  *
  13  * This library is distributed in the hope that it will be useful,
  14  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  15  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  16  * Library General Public License for more details.
  17  *
  18  * You should have received a copy of the GNU Library General Public License
  19  * along with this library; see the file COPYING.LIB.  If not, write to
  20  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  21  * Boston, MA 02110-1301, USA.
  22  *
  23  */
  24 
  25 #include &quot;config.h&quot;
  26 #include &quot;RenderBox.h&quot;
  27 
  28 #include &quot;CSSFontSelector.h&quot;
  29 #include &quot;ControlStates.h&quot;
  30 #include &quot;Document.h&quot;
  31 #include &quot;Editing.h&quot;
  32 #include &quot;EventHandler.h&quot;
  33 #include &quot;FloatQuad.h&quot;
  34 #include &quot;FloatRoundedRect.h&quot;
  35 #include &quot;Frame.h&quot;
  36 #include &quot;FrameView.h&quot;
  37 #include &quot;GraphicsContext.h&quot;
  38 #include &quot;HTMLBodyElement.h&quot;
  39 #include &quot;HTMLButtonElement.h&quot;
  40 #include &quot;HTMLFrameOwnerElement.h&quot;
  41 #include &quot;HTMLHtmlElement.h&quot;
  42 #include &quot;HTMLImageElement.h&quot;
  43 #include &quot;HTMLInputElement.h&quot;
  44 #include &quot;HTMLLegendElement.h&quot;
  45 #include &quot;HTMLNames.h&quot;
  46 #include &quot;HTMLSelectElement.h&quot;
  47 #include &quot;HTMLTextAreaElement.h&quot;
  48 #include &quot;HitTestResult.h&quot;
  49 #include &quot;InlineElementBox.h&quot;
  50 #include &quot;Page.h&quot;
  51 #include &quot;PaintInfo.h&quot;
  52 #include &quot;RenderBoxFragmentInfo.h&quot;
  53 #include &quot;RenderChildIterator.h&quot;
  54 #include &quot;RenderDeprecatedFlexibleBox.h&quot;
  55 #include &quot;RenderFlexibleBox.h&quot;
  56 #include &quot;RenderFragmentContainer.h&quot;
  57 #include &quot;RenderGeometryMap.h&quot;
  58 #include &quot;RenderGrid.h&quot;
  59 #include &quot;RenderInline.h&quot;
  60 #include &quot;RenderIterator.h&quot;
  61 #include &quot;RenderLayer.h&quot;
  62 #include &quot;RenderLayerCompositor.h&quot;
  63 #include &quot;RenderLayoutState.h&quot;
  64 #include &quot;RenderMultiColumnFlow.h&quot;
  65 #include &quot;RenderTableCell.h&quot;
  66 #include &quot;RenderTheme.h&quot;
  67 #include &quot;RenderView.h&quot;
  68 #include &quot;RuntimeApplicationChecks.h&quot;
  69 #include &quot;ScrollAnimator.h&quot;
  70 #include &quot;ScrollbarTheme.h&quot;
  71 #include &quot;Settings.h&quot;
  72 #include &quot;StyleScrollSnapPoints.h&quot;
  73 #include &quot;TransformState.h&quot;
  74 #include &lt;algorithm&gt;
  75 #include &lt;math.h&gt;
  76 #include &lt;wtf/IsoMallocInlines.h&gt;
  77 #include &lt;wtf/StackStats.h&gt;
  78 
  79 namespace WebCore {
  80 
  81 WTF_MAKE_ISO_ALLOCATED_IMPL(RenderBox);
  82 
  83 struct SameSizeAsRenderBox : public RenderBoxModelObject {
  84     virtual ~SameSizeAsRenderBox() = default;
  85     LayoutRect frameRect;
  86     LayoutBoxExtent marginBox;
  87     LayoutUnit preferredLogicalWidths[2];
  88     void* pointers[2];
  89 };
  90 
  91 COMPILE_ASSERT(sizeof(RenderBox) == sizeof(SameSizeAsRenderBox), RenderBox_should_stay_small);
  92 
  93 using namespace HTMLNames;
  94 
  95 // Used by flexible boxes when flexing this element and by table cells.
  96 typedef WTF::HashMap&lt;const RenderBox*, LayoutUnit&gt; OverrideSizeMap;
  97 static OverrideSizeMap* gOverrideContentLogicalHeightMap = nullptr;
  98 static OverrideSizeMap* gOverrideContentLogicalWidthMap = nullptr;
  99 
 100 // Used by grid elements to properly size their grid items.
 101 // FIXME: We should store these based on physical direction.
 102 typedef WTF::HashMap&lt;const RenderBox*, Optional&lt;LayoutUnit&gt;&gt; OverrideOptionalSizeMap;
 103 static OverrideOptionalSizeMap* gOverrideContainingBlockContentLogicalHeightMap = nullptr;
 104 static OverrideOptionalSizeMap* gOverrideContainingBlockContentLogicalWidthMap = nullptr;
 105 
 106 // Size of border belt for autoscroll. When mouse pointer in border belt,
 107 // autoscroll is started.
 108 static const int autoscrollBeltSize = 20;
 109 static const unsigned backgroundObscurationTestMaxDepth = 4;
 110 
 111 using ControlStatesRendererMap = HashMap&lt;const RenderObject*, std::unique_ptr&lt;ControlStates&gt;&gt;;
 112 static ControlStatesRendererMap&amp; controlStatesRendererMap()
 113 {
 114     static NeverDestroyed&lt;ControlStatesRendererMap&gt; map;
 115     return map;
 116 }
 117 
 118 static ControlStates* controlStatesForRenderer(const RenderBox&amp; renderer)
 119 {
 120     return controlStatesRendererMap().ensure(&amp;renderer, [] {
<a name="1" id="anc1"></a><span class="line-modified"> 121         return std::make_unique&lt;ControlStates&gt;();</span>
 122     }).iterator-&gt;value.get();
 123 }
 124 
 125 static void removeControlStatesForRenderer(const RenderBox&amp; renderer)
 126 {
 127     controlStatesRendererMap().remove(&amp;renderer);
 128 }
 129 
 130 bool RenderBox::s_hadOverflowClip = false;
 131 
 132 RenderBox::RenderBox(Element&amp; element, RenderStyle&amp;&amp; style, BaseTypeFlags baseTypeFlags)
 133     : RenderBoxModelObject(element, WTFMove(style), baseTypeFlags)
 134 {
 135     setIsBox();
 136 }
 137 
 138 RenderBox::RenderBox(Document&amp; document, RenderStyle&amp;&amp; style, BaseTypeFlags baseTypeFlags)
 139     : RenderBoxModelObject(document, WTFMove(style), baseTypeFlags)
 140 {
 141     setIsBox();
 142 }
 143 
 144 RenderBox::~RenderBox()
 145 {
 146     // Do not add any code here. Add it to willBeDestroyed() instead.
 147 }
 148 
 149 void RenderBox::willBeDestroyed()
 150 {
 151     if (frame().eventHandler().autoscrollRenderer() == this)
 152         frame().eventHandler().stopAutoscrollTimer(true);
 153 
 154     clearOverrideContentSize();
 155     clearOverrideContainingBlockContentSize();
 156 
 157     RenderBlock::removePercentHeightDescendantIfNeeded(*this);
 158 
 159     ShapeOutsideInfo::removeInfo(*this);
 160 
 161     view().unscheduleLazyRepaint(*this);
 162     removeControlStatesForRenderer(*this);
 163 
 164 #if ENABLE(CSS_SCROLL_SNAP)
 165     if (hasInitializedStyle() &amp;&amp; style().scrollSnapArea().hasSnapPosition())
 166         view().unregisterBoxWithScrollSnapPositions(*this);
 167 #endif
 168 
 169     RenderBoxModelObject::willBeDestroyed();
 170 }
 171 
 172 RenderFragmentContainer* RenderBox::clampToStartAndEndFragments(RenderFragmentContainer* fragment) const
 173 {
 174     RenderFragmentedFlow* fragmentedFlow = enclosingFragmentedFlow();
 175 
 176     ASSERT(isRenderView() || (fragment &amp;&amp; fragmentedFlow));
 177     if (isRenderView())
 178         return fragment;
 179 
 180     // We need to clamp to the block, since we want any lines or blocks that overflow out of the
 181     // logical top or logical bottom of the block to size as though the border box in the first and
 182     // last fragments extended infinitely. Otherwise the lines are going to size according to the fragments
 183     // they overflow into, which makes no sense when this block doesn&#39;t exist in |fragment| at all.
 184     RenderFragmentContainer* startFragment = nullptr;
 185     RenderFragmentContainer* endFragment = nullptr;
 186     if (!fragmentedFlow-&gt;getFragmentRangeForBox(this, startFragment, endFragment))
 187         return fragment;
 188 
 189     if (fragment-&gt;logicalTopForFragmentedFlowContent() &lt; startFragment-&gt;logicalTopForFragmentedFlowContent())
 190         return startFragment;
 191     if (fragment-&gt;logicalTopForFragmentedFlowContent() &gt; endFragment-&gt;logicalTopForFragmentedFlowContent())
 192         return endFragment;
 193 
 194     return fragment;
 195 }
 196 
 197 bool RenderBox::hasFragmentRangeInFragmentedFlow() const
 198 {
 199     RenderFragmentedFlow* fragmentedFlow = enclosingFragmentedFlow();
 200     if (!fragmentedFlow || !fragmentedFlow-&gt;hasValidFragmentInfo())
 201         return false;
 202 
 203     return fragmentedFlow-&gt;hasCachedFragmentRangeForBox(*this);
 204 }
 205 
 206 LayoutRect RenderBox::clientBoxRectInFragment(RenderFragmentContainer* fragment) const
 207 {
 208     if (!fragment)
 209         return clientBoxRect();
 210 
 211     LayoutRect clientBox = borderBoxRectInFragment(fragment);
 212     clientBox.setLocation(clientBox.location() + LayoutSize(borderLeft(), borderTop()));
 213     clientBox.setSize(clientBox.size() - LayoutSize(borderLeft() + borderRight() + verticalScrollbarWidth(), borderTop() + borderBottom() + horizontalScrollbarHeight()));
 214 
 215     return clientBox;
 216 }
 217 
 218 LayoutRect RenderBox::borderBoxRectInFragment(RenderFragmentContainer*, RenderBoxFragmentInfoFlags) const
 219 {
 220     return borderBoxRect();
 221 }
 222 
 223 static RenderBlockFlow* outermostBlockContainingFloatingObject(RenderBox&amp; box)
 224 {
 225     ASSERT(box.isFloating());
 226     RenderBlockFlow* parentBlock = nullptr;
 227     for (auto&amp; ancestor : ancestorsOfType&lt;RenderBlockFlow&gt;(box)) {
 228         if (ancestor.isRenderView())
 229             break;
 230         if (!parentBlock || ancestor.containsFloat(box))
 231             parentBlock = &amp;ancestor;
 232     }
 233     return parentBlock;
 234 }
 235 
 236 void RenderBox::removeFloatingOrPositionedChildFromBlockLists()
 237 {
 238     ASSERT(isFloatingOrOutOfFlowPositioned());
 239 
 240     if (renderTreeBeingDestroyed())
 241         return;
 242 
 243     if (isFloating()) {
 244         if (RenderBlockFlow* parentBlock = outermostBlockContainingFloatingObject(*this)) {
 245             parentBlock-&gt;markSiblingsWithFloatsForLayout(this);
 246             parentBlock-&gt;markAllDescendantsWithFloatsForLayout(this, false);
 247         }
 248     }
 249 
 250     if (isOutOfFlowPositioned())
 251         RenderBlock::removePositionedObject(*this);
 252 }
 253 
 254 void RenderBox::styleWillChange(StyleDifference diff, const RenderStyle&amp; newStyle)
 255 {
 256     s_hadOverflowClip = hasOverflowClip();
 257 
 258     const RenderStyle* oldStyle = hasInitializedStyle() ? &amp;style() : nullptr;
 259     if (oldStyle) {
 260         // The background of the root element or the body element could propagate up to
 261         // the canvas. Issue full repaint, when our style changes substantially.
 262         if (diff &gt;= StyleDifference::Repaint &amp;&amp; (isDocumentElementRenderer() || isBody())) {
 263             view().repaintRootContents();
 264             if (oldStyle-&gt;hasEntirelyFixedBackground() != newStyle.hasEntirelyFixedBackground())
 265                 view().compositor().rootLayerConfigurationChanged();
 266         }
 267 
 268         // When a layout hint happens and an object&#39;s position style changes, we have to do a layout
 269         // to dirty the render tree using the old position value now.
 270         if (diff == StyleDifference::Layout &amp;&amp; parent() &amp;&amp; oldStyle-&gt;position() != newStyle.position()) {
 271             markContainingBlocksForLayout();
 272             if (oldStyle-&gt;position() == PositionType::Static)
 273                 repaint();
 274             else if (newStyle.hasOutOfFlowPosition())
 275                 parent()-&gt;setChildNeedsLayout();
 276             if (isFloating() &amp;&amp; !isOutOfFlowPositioned() &amp;&amp; newStyle.hasOutOfFlowPosition())
 277                 removeFloatingOrPositionedChildFromBlockLists();
 278         }
 279     } else if (isBody())
 280         view().repaintRootContents();
 281 
 282 #if ENABLE(CSS_SCROLL_SNAP)
 283     bool boxContributesSnapPositions = newStyle.scrollSnapArea().hasSnapPosition();
 284     if (boxContributesSnapPositions || (oldStyle &amp;&amp; oldStyle-&gt;scrollSnapArea().hasSnapPosition())) {
 285         if (boxContributesSnapPositions)
 286             view().registerBoxWithScrollSnapPositions(*this);
 287         else
 288             view().unregisterBoxWithScrollSnapPositions(*this);
 289     }
 290 #endif
 291 
 292     RenderBoxModelObject::styleWillChange(diff, newStyle);
 293 }
 294 
 295 void RenderBox::styleDidChange(StyleDifference diff, const RenderStyle* oldStyle)
 296 {
 297     // Horizontal writing mode definition is updated in RenderBoxModelObject::updateFromStyle,
 298     // (as part of the RenderBoxModelObject::styleDidChange call below). So, we can safely cache the horizontal
 299     // writing mode value before style change here.
 300     bool oldHorizontalWritingMode = isHorizontalWritingMode();
 301 
 302     RenderBoxModelObject::styleDidChange(diff, oldStyle);
 303 
 304     const RenderStyle&amp; newStyle = style();
 305     if (needsLayout() &amp;&amp; oldStyle) {
 306         RenderBlock::removePercentHeightDescendantIfNeeded(*this);
 307 
 308         // Normally we can do optimized positioning layout for absolute/fixed positioned objects. There is one special case, however, which is
 309         // when the positioned object&#39;s margin-before is changed. In this case the parent has to get a layout in order to run margin collapsing
 310         // to determine the new static position.
 311         if (isOutOfFlowPositioned() &amp;&amp; newStyle.hasStaticBlockPosition(isHorizontalWritingMode()) &amp;&amp; oldStyle-&gt;marginBefore() != newStyle.marginBefore()
 312             &amp;&amp; parent() &amp;&amp; !parent()-&gt;normalChildNeedsLayout())
 313             parent()-&gt;setChildNeedsLayout();
 314     }
 315 
 316     if (RenderBlock::hasPercentHeightContainerMap() &amp;&amp; firstChild()
 317         &amp;&amp; oldHorizontalWritingMode != isHorizontalWritingMode())
 318         RenderBlock::clearPercentHeightDescendantsFrom(*this);
 319 
 320     // If our zoom factor changes and we have a defined scrollLeft/Top, we need to adjust that value into the
 321     // new zoomed coordinate space.
 322     if (hasOverflowClip() &amp;&amp; layer() &amp;&amp; oldStyle &amp;&amp; oldStyle-&gt;effectiveZoom() != newStyle.effectiveZoom()) {
 323         ScrollPosition scrollPosition = layer()-&gt;scrollPosition();
 324         float zoomScaleFactor = newStyle.effectiveZoom() / oldStyle-&gt;effectiveZoom();
 325         scrollPosition.scale(zoomScaleFactor);
 326         layer()-&gt;setPostLayoutScrollPosition(scrollPosition);
 327     }
 328 
 329     // Our opaqueness might have changed without triggering layout.
 330     if (diff &gt;= StyleDifference::Repaint &amp;&amp; diff &lt;= StyleDifference::RepaintLayer) {
 331         auto parentToInvalidate = parent();
 332         for (unsigned i = 0; i &lt; backgroundObscurationTestMaxDepth &amp;&amp; parentToInvalidate; ++i) {
 333             parentToInvalidate-&gt;invalidateBackgroundObscurationStatus();
 334             parentToInvalidate = parentToInvalidate-&gt;parent();
 335         }
 336     }
 337 
 338     bool isBodyRenderer = isBody();
 339     bool isDocElementRenderer = isDocumentElementRenderer();
 340 
 341     if (isDocElementRenderer || isBodyRenderer) {
 342         // Propagate the new writing mode and direction up to the RenderView.
 343         auto* documentElementRenderer = document().documentElement()-&gt;renderer();
 344         auto&amp; viewStyle = view().mutableStyle();
 345         bool rootStyleChanged = false;
 346         bool viewDirectionOrWritingModeChanged = false;
 347         auto* rootRenderer = isBodyRenderer ? documentElementRenderer : nullptr;
 348         if (viewStyle.direction() != newStyle.direction() &amp;&amp; (isDocElementRenderer || !documentElementRenderer-&gt;style().hasExplicitlySetDirection())) {
 349             viewStyle.setDirection(newStyle.direction());
 350             viewDirectionOrWritingModeChanged = true;
 351             if (isBodyRenderer) {
 352                 rootRenderer-&gt;mutableStyle().setDirection(newStyle.direction());
 353                 rootStyleChanged = true;
 354             }
 355             setNeedsLayoutAndPrefWidthsRecalc();
 356 
 357             view().frameView().topContentDirectionDidChange();
 358         }
 359 
 360         if (viewStyle.writingMode() != newStyle.writingMode() &amp;&amp; (isDocElementRenderer || !documentElementRenderer-&gt;style().hasExplicitlySetWritingMode())) {
 361             viewStyle.setWritingMode(newStyle.writingMode());
 362             viewDirectionOrWritingModeChanged = true;
 363             view().setHorizontalWritingMode(newStyle.isHorizontalWritingMode());
 364             view().markAllDescendantsWithFloatsForLayout();
 365             if (isBodyRenderer) {
 366                 rootStyleChanged = true;
 367                 rootRenderer-&gt;mutableStyle().setWritingMode(newStyle.writingMode());
 368                 rootRenderer-&gt;setHorizontalWritingMode(newStyle.isHorizontalWritingMode());
 369             }
 370             setNeedsLayoutAndPrefWidthsRecalc();
 371         }
 372 
 373 #if ENABLE(DARK_MODE_CSS)
 374         view().frameView().recalculateBaseBackgroundColor();
 375 #endif
 376 
 377         view().frameView().recalculateScrollbarOverlayStyle();
 378 
 379         const Pagination&amp; pagination = view().frameView().pagination();
 380         if (viewDirectionOrWritingModeChanged &amp;&amp; pagination.mode != Pagination::Unpaginated) {
 381             viewStyle.setColumnStylesFromPaginationMode(pagination.mode);
 382             if (view().multiColumnFlow())
 383                 view().updateColumnProgressionFromStyle(viewStyle);
 384         }
 385 
 386         if (viewDirectionOrWritingModeChanged &amp;&amp; view().multiColumnFlow())
 387             view().updateStylesForColumnChildren();
 388 
 389         if (rootStyleChanged &amp;&amp; is&lt;RenderBlockFlow&gt;(rootRenderer) &amp;&amp; downcast&lt;RenderBlockFlow&gt;(*rootRenderer).multiColumnFlow())
 390             downcast&lt;RenderBlockFlow&gt;(*rootRenderer).updateStylesForColumnChildren();
 391 
 392         if (isBodyRenderer &amp;&amp; pagination.mode != Pagination::Unpaginated &amp;&amp; page().paginationLineGridEnabled()) {
 393             // Propagate the body font back up to the RenderView and use it as
 394             // the basis of the grid.
 395             if (newStyle.fontDescription() != view().style().fontDescription()) {
 396                 view().mutableStyle().setFontDescription(FontCascadeDescription { newStyle.fontDescription() });
 397                 view().mutableStyle().fontCascade().update(&amp;document().fontSelector());
 398             }
 399         }
 400 
 401         if (diff != StyleDifference::Equal)
 402             view().compositor().rootOrBodyStyleChanged(*this, oldStyle);
 403     }
 404 
 405     if ((oldStyle &amp;&amp; oldStyle-&gt;shapeOutside()) || style().shapeOutside())
 406         updateShapeOutsideInfoAfterStyleChange(style(), oldStyle);
 407     updateGridPositionAfterStyleChange(style(), oldStyle);
 408 }
 409 
 410 void RenderBox::updateGridPositionAfterStyleChange(const RenderStyle&amp; style, const RenderStyle* oldStyle)
 411 {
 412     if (!oldStyle || !is&lt;RenderGrid&gt;(parent()))
 413         return;
 414 
 415     if (oldStyle-&gt;gridItemColumnStart() == style.gridItemColumnStart()
 416         &amp;&amp; oldStyle-&gt;gridItemColumnEnd() == style.gridItemColumnEnd()
 417         &amp;&amp; oldStyle-&gt;gridItemRowStart() == style.gridItemRowStart()
 418         &amp;&amp; oldStyle-&gt;gridItemRowEnd() == style.gridItemRowEnd()
 419         &amp;&amp; oldStyle-&gt;order() == style.order()
 420         &amp;&amp; oldStyle-&gt;hasOutOfFlowPosition() == style.hasOutOfFlowPosition())
 421         return;
 422 
 423     // Positioned items don&#39;t participate on the layout of the grid,
 424     // so we don&#39;t need to mark the grid as dirty if they change positions.
 425     if (oldStyle-&gt;hasOutOfFlowPosition() &amp;&amp; style.hasOutOfFlowPosition())
 426         return;
 427 
 428     // It should be possible to not dirty the grid in some cases (like moving an
 429     // explicitly placed grid item).
 430     // For now, it&#39;s more simple to just always recompute the grid.
 431     downcast&lt;RenderGrid&gt;(*parent()).dirtyGrid();
 432 }
 433 
 434 void RenderBox::updateShapeOutsideInfoAfterStyleChange(const RenderStyle&amp; style, const RenderStyle* oldStyle)
 435 {
 436     const ShapeValue* shapeOutside = style.shapeOutside();
 437     const ShapeValue* oldShapeOutside = oldStyle ? oldStyle-&gt;shapeOutside() : nullptr;
 438 
 439     Length shapeMargin = style.shapeMargin();
 440     Length oldShapeMargin = oldStyle ? oldStyle-&gt;shapeMargin() : RenderStyle::initialShapeMargin();
 441 
 442     float shapeImageThreshold = style.shapeImageThreshold();
 443     float oldShapeImageThreshold = oldStyle ? oldStyle-&gt;shapeImageThreshold() : RenderStyle::initialShapeImageThreshold();
 444 
 445     // FIXME: A future optimization would do a deep comparison for equality. (bug 100811)
 446     if (shapeOutside == oldShapeOutside &amp;&amp; shapeMargin == oldShapeMargin &amp;&amp; shapeImageThreshold == oldShapeImageThreshold)
 447         return;
 448 
 449     if (!shapeOutside)
 450         ShapeOutsideInfo::removeInfo(*this);
 451     else
 452         ShapeOutsideInfo::ensureInfo(*this).markShapeAsDirty();
 453 
 454     if (shapeOutside || shapeOutside != oldShapeOutside)
 455         markShapeOutsideDependentsForLayout();
 456 }
 457 
 458 void RenderBox::updateFromStyle()
 459 {
 460     RenderBoxModelObject::updateFromStyle();
 461 
 462     const RenderStyle&amp; styleToUse = style();
 463     bool isDocElementRenderer = isDocumentElementRenderer();
 464     bool isViewObject = isRenderView();
 465 
 466     // The root and the RenderView always paint their backgrounds/borders.
 467     if (isDocElementRenderer || isViewObject)
 468         setHasVisibleBoxDecorations(true);
 469 
 470     setFloating(!isOutOfFlowPositioned() &amp;&amp; styleToUse.isFloating());
 471 
 472     // We also handle &lt;body&gt; and &lt;html&gt;, whose overflow applies to the viewport.
 473     if (styleToUse.overflowX() != Overflow::Visible &amp;&amp; !isDocElementRenderer &amp;&amp; isRenderBlock()) {
 474         bool boxHasOverflowClip = true;
 475         if (isBody()) {
 476             // Overflow on the body can propagate to the viewport under the following conditions.
 477             // (1) The root element is &lt;html&gt;.
 478             // (2) We are the primary &lt;body&gt; (can be checked by looking at document.body).
 479             // (3) The root element has visible overflow.
 480             if (is&lt;HTMLHtmlElement&gt;(*document().documentElement())
 481                 &amp;&amp; document().body() == element()
 482                 &amp;&amp; document().documentElement()-&gt;renderer()-&gt;style().overflowX() == Overflow::Visible) {
 483                 boxHasOverflowClip = false;
 484             }
 485         }
 486         // Check for overflow clip.
 487         // It&#39;s sufficient to just check one direction, since it&#39;s illegal to have visible on only one overflow value.
 488         if (boxHasOverflowClip) {
 489             if (!s_hadOverflowClip &amp;&amp; hasRenderOverflow()) {
 490                 // Erase the overflow.
 491                 // Overflow changes have to result in immediate repaints of the entire layout overflow area because
 492                 // repaints issued by removal of descendants get clipped using the updated style when they shouldn&#39;t.
 493                 repaintRectangle(visualOverflowRect());
 494                 repaintRectangle(layoutOverflowRect());
 495             }
 496             setHasOverflowClip();
 497         }
 498     }
 499     setHasTransformRelatedProperty(styleToUse.hasTransformRelatedProperty());
 500     setHasReflection(styleToUse.boxReflect());
 501 }
 502 
 503 void RenderBox::layout()
 504 {
 505     StackStats::LayoutCheckPoint layoutCheckPoint;
 506     ASSERT(needsLayout());
 507 
 508     RenderObject* child = firstChild();
 509     if (!child) {
 510         clearNeedsLayout();
 511         return;
 512     }
 513 
 514     LayoutStateMaintainer statePusher(*this, locationOffset(), style().isFlippedBlocksWritingMode());
 515     while (child) {
 516         if (child-&gt;needsLayout())
 517             downcast&lt;RenderElement&gt;(*child).layout();
 518         ASSERT(!child-&gt;needsLayout());
 519         child = child-&gt;nextSibling();
 520     }
 521     invalidateBackgroundObscurationStatus();
 522     clearNeedsLayout();
 523 }
 524 
 525 // More IE extensions.  clientWidth and clientHeight represent the interior of an object
 526 // excluding border and scrollbar.
 527 LayoutUnit RenderBox::clientWidth() const
 528 {
 529     return paddingBoxWidth();
 530 }
 531 
 532 LayoutUnit RenderBox::clientHeight() const
 533 {
 534     return paddingBoxHeight();
 535 }
 536 
 537 int RenderBox::scrollWidth() const
 538 {
 539     if (hasOverflowClip() &amp;&amp; layer())
 540         return layer()-&gt;scrollWidth();
 541     // For objects with visible overflow, this matches IE.
 542     // FIXME: Need to work right with writing modes.
 543     if (style().isLeftToRightDirection()) {
 544         // FIXME: This should use snappedIntSize() instead with absolute coordinates.
 545         return roundToInt(std::max(clientWidth(), layoutOverflowRect().maxX() - borderLeft()));
 546     }
 547     return roundToInt(clientWidth() - std::min&lt;LayoutUnit&gt;(0, layoutOverflowRect().x() - borderLeft()));
 548 }
 549 
 550 int RenderBox::scrollHeight() const
 551 {
 552     if (hasOverflowClip() &amp;&amp; layer())
 553         return layer()-&gt;scrollHeight();
 554     // For objects with visible overflow, this matches IE.
 555     // FIXME: Need to work right with writing modes.
 556     // FIXME: This should use snappedIntSize() instead with absolute coordinates.
 557     return roundToInt(std::max(clientHeight(), layoutOverflowRect().maxY() - borderTop()));
 558 }
 559 
 560 int RenderBox::scrollLeft() const
 561 {
 562     return hasOverflowClip() &amp;&amp; layer() ? layer()-&gt;scrollPosition().x() : 0;
 563 }
 564 
 565 int RenderBox::scrollTop() const
 566 {
 567     return hasOverflowClip() &amp;&amp; layer() ? layer()-&gt;scrollPosition().y() : 0;
 568 }
 569 
 570 static void setupWheelEventTestTrigger(RenderLayer&amp; layer)
 571 {
 572     Page&amp; page = layer.renderer().page();
 573     if (!page.expectsWheelEventTriggers())
 574         return;
 575     layer.scrollAnimator().setWheelEventTestTrigger(page.testTrigger());
 576 }
 577 
<a name="2" id="anc2"></a><span class="line-modified"> 578 void RenderBox::setScrollLeft(int newLeft, ScrollClamping clamping)</span>
 579 {
 580     if (!hasOverflowClip() || !layer())
 581         return;
 582     setupWheelEventTestTrigger(*layer());
<a name="3" id="anc3"></a><span class="line-modified"> 583     layer()-&gt;scrollToXPosition(newLeft, clamping);</span>
 584 }
 585 
<a name="4" id="anc4"></a><span class="line-modified"> 586 void RenderBox::setScrollTop(int newTop, ScrollClamping clamping)</span>
 587 {
 588     if (!hasOverflowClip() || !layer())
 589         return;
 590     setupWheelEventTestTrigger(*layer());
<a name="5" id="anc5"></a><span class="line-modified"> 591     layer()-&gt;scrollToYPosition(newTop, clamping);</span>
 592 }
 593 
 594 void RenderBox::absoluteRects(Vector&lt;IntRect&gt;&amp; rects, const LayoutPoint&amp; accumulatedOffset) const
 595 {
 596     rects.append(snappedIntRect(accumulatedOffset, size()));
 597 }
 598 
 599 void RenderBox::absoluteQuads(Vector&lt;FloatQuad&gt;&amp; quads, bool* wasFixed) const
 600 {
 601     FloatRect localRect(0, 0, width(), height());
 602 
 603     RenderFragmentedFlow* fragmentedFlow = enclosingFragmentedFlow();
 604     if (fragmentedFlow &amp;&amp; fragmentedFlow-&gt;absoluteQuadsForBox(quads, wasFixed, this, localRect.y(), localRect.maxY()))
 605         return;
 606 
 607     quads.append(localToAbsoluteQuad(localRect, UseTransforms, wasFixed));
 608 }
 609 
 610 void RenderBox::updateLayerTransform()
 611 {
 612     // Transform-origin depends on box size, so we need to update the layer transform after layout.
 613     if (hasLayer())
 614         layer()-&gt;updateTransform();
 615 }
 616 
 617 LayoutUnit RenderBox::constrainLogicalWidthInFragmentByMinMax(LayoutUnit logicalWidth, LayoutUnit availableWidth, RenderBlock&amp; cb, RenderFragmentContainer* fragment) const
 618 {
 619     const RenderStyle&amp; styleToUse = style();
 620     if (!styleToUse.logicalMaxWidth().isUndefined())
 621         logicalWidth = std::min(logicalWidth, computeLogicalWidthInFragmentUsing(MaxSize, styleToUse.logicalMaxWidth(), availableWidth, cb, fragment));
 622     return std::max(logicalWidth, computeLogicalWidthInFragmentUsing(MinSize, styleToUse.logicalMinWidth(), availableWidth, cb, fragment));
 623 }
 624 
 625 LayoutUnit RenderBox::constrainLogicalHeightByMinMax(LayoutUnit logicalHeight, Optional&lt;LayoutUnit&gt; intrinsicContentHeight) const
 626 {
 627     const RenderStyle&amp; styleToUse = style();
 628     if (!styleToUse.logicalMaxHeight().isUndefined()) {
 629         if (Optional&lt;LayoutUnit&gt; maxH = computeLogicalHeightUsing(MaxSize, styleToUse.logicalMaxHeight(), intrinsicContentHeight))
 630             logicalHeight = std::min(logicalHeight, maxH.value());
 631     }
 632     if (Optional&lt;LayoutUnit&gt; computedLogicalHeight = computeLogicalHeightUsing(MinSize, styleToUse.logicalMinHeight(), intrinsicContentHeight))
 633         return std::max(logicalHeight, computedLogicalHeight.value());
 634     return logicalHeight;
 635 }
 636 
 637 LayoutUnit RenderBox::constrainContentBoxLogicalHeightByMinMax(LayoutUnit logicalHeight, Optional&lt;LayoutUnit&gt; intrinsicContentHeight) const
 638 {
 639     const RenderStyle&amp; styleToUse = style();
 640     if (!styleToUse.logicalMaxHeight().isUndefined()) {
 641         if (Optional&lt;LayoutUnit&gt; maxH = computeContentLogicalHeight(MaxSize, styleToUse.logicalMaxHeight(), intrinsicContentHeight))
 642             logicalHeight = std::min(logicalHeight, maxH.value());
 643     }
 644     if (Optional&lt;LayoutUnit&gt; computedContentLogicalHeight = computeContentLogicalHeight(MinSize, styleToUse.logicalMinHeight(), intrinsicContentHeight))
 645         return std::max(logicalHeight, computedContentLogicalHeight.value());
 646     return logicalHeight;
 647 }
 648 
 649 RoundedRect::Radii RenderBox::borderRadii() const
 650 {
 651     auto&amp; style = this-&gt;style();
 652     LayoutRect bounds = frameRect();
 653 
 654     unsigned borderLeft = style.borderLeftWidth();
 655     unsigned borderTop = style.borderTopWidth();
 656     bounds.moveBy(LayoutPoint(borderLeft, borderTop));
 657     bounds.contract(borderLeft + style.borderRightWidth(), borderTop + style.borderBottomWidth());
 658     return style.getRoundedBorderFor(bounds).radii();
 659 }
 660 
<a name="6" id="anc6"></a>









 661 LayoutRect RenderBox::contentBoxRect() const
 662 {
 663     return { contentBoxLocation(), contentSize() };
 664 }
 665 
 666 LayoutPoint RenderBox::contentBoxLocation() const
 667 {
 668     LayoutUnit scrollbarSpace = shouldPlaceBlockDirectionScrollbarOnLeft() ? verticalScrollbarWidth() : 0;
 669     return { borderLeft() + paddingLeft() + scrollbarSpace, borderTop() + paddingTop() };
 670 }
 671 
 672 IntRect RenderBox::absoluteContentBox() const
 673 {
 674     // This is wrong with transforms and flipped writing modes.
 675     IntRect rect = snappedIntRect(contentBoxRect());
 676     FloatPoint absPos = localToAbsolute();
 677     rect.move(absPos.x(), absPos.y());
 678     return rect;
 679 }
 680 
 681 FloatQuad RenderBox::absoluteContentQuad() const
 682 {
 683     LayoutRect rect = contentBoxRect();
 684     return localToAbsoluteQuad(FloatRect(rect));
 685 }
 686 
 687 LayoutRect RenderBox::outlineBoundsForRepaint(const RenderLayerModelObject* repaintContainer, const RenderGeometryMap* geometryMap) const
 688 {
 689     LayoutRect box = borderBoundingBox();
 690     adjustRectForOutlineAndShadow(box);
 691 
 692     if (repaintContainer != this) {
 693         FloatQuad containerRelativeQuad;
 694         if (geometryMap)
 695             containerRelativeQuad = geometryMap-&gt;mapToContainer(box, repaintContainer);
 696         else
 697             containerRelativeQuad = localToContainerQuad(FloatRect(box), repaintContainer);
 698 
 699         box = LayoutRect(containerRelativeQuad.boundingBox());
 700     }
 701 
 702     // FIXME: layoutDelta needs to be applied in parts before/after transforms and
 703     // repaint containers. https://bugs.webkit.org/show_bug.cgi?id=23308
 704     box.move(view().frameView().layoutContext().layoutDelta());
 705 
 706     return LayoutRect(snapRectToDevicePixels(box, document().deviceScaleFactor()));
 707 }
 708 
 709 void RenderBox::addFocusRingRects(Vector&lt;LayoutRect&gt;&amp; rects, const LayoutPoint&amp; additionalOffset, const RenderLayerModelObject*)
 710 {
 711     if (!size().isEmpty())
 712         rects.append(LayoutRect(additionalOffset, size()));
 713 }
 714 
 715 int RenderBox::reflectionOffset() const
 716 {
 717     if (!style().boxReflect())
 718         return 0;
 719     if (style().boxReflect()-&gt;direction() == ReflectionLeft || style().boxReflect()-&gt;direction() == ReflectionRight)
 720         return valueForLength(style().boxReflect()-&gt;offset(), borderBoxRect().width());
 721     return valueForLength(style().boxReflect()-&gt;offset(), borderBoxRect().height());
 722 }
 723 
 724 LayoutRect RenderBox::reflectedRect(const LayoutRect&amp; r) const
 725 {
 726     if (!style().boxReflect())
 727         return LayoutRect();
 728 
 729     LayoutRect box = borderBoxRect();
 730     LayoutRect result = r;
 731     switch (style().boxReflect()-&gt;direction()) {
 732         case ReflectionBelow:
 733             result.setY(box.maxY() + reflectionOffset() + (box.maxY() - r.maxY()));
 734             break;
 735         case ReflectionAbove:
 736             result.setY(box.y() - reflectionOffset() - box.height() + (box.maxY() - r.maxY()));
 737             break;
 738         case ReflectionLeft:
 739             result.setX(box.x() - reflectionOffset() - box.width() + (box.maxX() - r.maxX()));
 740             break;
 741         case ReflectionRight:
 742             result.setX(box.maxX() + reflectionOffset() + (box.maxX() - r.maxX()));
 743             break;
 744     }
 745     return result;
 746 }
 747 
 748 bool RenderBox::fixedElementLaysOutRelativeToFrame(const FrameView&amp; frameView) const
 749 {
 750     return isFixedPositioned() &amp;&amp; container()-&gt;isRenderView() &amp;&amp; frameView.fixedElementsLayoutRelativeToFrame();
 751 }
 752 
 753 bool RenderBox::includeVerticalScrollbarSize() const
 754 {
 755     return hasOverflowClip() &amp;&amp; layer() &amp;&amp; !layer()-&gt;hasOverlayScrollbars()
 756         &amp;&amp; (style().overflowY() == Overflow::Scroll || style().overflowY() == Overflow::Auto);
 757 }
 758 
 759 bool RenderBox::includeHorizontalScrollbarSize() const
 760 {
 761     return hasOverflowClip() &amp;&amp; layer() &amp;&amp; !layer()-&gt;hasOverlayScrollbars()
 762         &amp;&amp; (style().overflowX() == Overflow::Scroll || style().overflowX() == Overflow::Auto);
 763 }
 764 
 765 int RenderBox::verticalScrollbarWidth() const
 766 {
 767     return includeVerticalScrollbarSize() ? layer()-&gt;verticalScrollbarWidth() : 0;
 768 }
 769 
 770 int RenderBox::horizontalScrollbarHeight() const
 771 {
 772     return includeHorizontalScrollbarSize() ? layer()-&gt;horizontalScrollbarHeight() : 0;
 773 }
 774 
 775 int RenderBox::intrinsicScrollbarLogicalWidth() const
 776 {
 777     if (!hasOverflowClip())
 778         return 0;
 779 
 780     if (isHorizontalWritingMode() &amp;&amp; (style().overflowY() == Overflow::Scroll &amp;&amp; !canUseOverlayScrollbars())) {
 781         ASSERT(layer() &amp;&amp; layer()-&gt;hasVerticalScrollbar());
 782         return verticalScrollbarWidth();
 783     }
 784 
 785     if (!isHorizontalWritingMode() &amp;&amp; (style().overflowX() == Overflow::Scroll &amp;&amp; !canUseOverlayScrollbars())) {
 786         ASSERT(layer() &amp;&amp; layer()-&gt;hasHorizontalScrollbar());
 787         return horizontalScrollbarHeight();
 788     }
 789 
 790     return 0;
 791 }
 792 
 793 bool RenderBox::scrollLayer(ScrollDirection direction, ScrollGranularity granularity, float multiplier, Element** stopElement)
 794 {
 795     RenderLayer* boxLayer = layer();
 796     if (boxLayer &amp;&amp; boxLayer-&gt;scroll(direction, granularity, multiplier)) {
 797         if (stopElement)
 798             *stopElement = element();
 799 
 800         return true;
 801     }
 802 
 803     return false;
 804 }
 805 
 806 bool RenderBox::scroll(ScrollDirection direction, ScrollGranularity granularity, float multiplier, Element** stopElement, RenderBox* startBox, const IntPoint&amp; wheelEventAbsolutePoint)
 807 {
 808     if (scrollLayer(direction, granularity, multiplier, stopElement))
 809         return true;
 810 
 811     if (stopElement &amp;&amp; *stopElement &amp;&amp; *stopElement == element())
 812         return true;
 813 
 814     RenderBlock* nextScrollBlock = containingBlock();
 815 
 816     if (nextScrollBlock &amp;&amp; !nextScrollBlock-&gt;isRenderView())
 817         return nextScrollBlock-&gt;scroll(direction, granularity, multiplier, stopElement, startBox, wheelEventAbsolutePoint);
 818 
 819     return false;
 820 }
 821 
 822 bool RenderBox::logicalScroll(ScrollLogicalDirection direction, ScrollGranularity granularity, float multiplier, Element** stopElement)
 823 {
 824     bool scrolled = false;
 825 
 826     RenderLayer* l = layer();
 827     if (l) {
 828 #if PLATFORM(COCOA)
 829         // On Mac only we reset the inline direction position when doing a document scroll (e.g., hitting Home/End).
 830         if (granularity == ScrollByDocument)
 831             scrolled = l-&gt;scroll(logicalToPhysical(ScrollInlineDirectionBackward, isHorizontalWritingMode(), style().isFlippedBlocksWritingMode()), ScrollByDocument, multiplier);
 832 #endif
 833         if (l-&gt;scroll(logicalToPhysical(direction, isHorizontalWritingMode(), style().isFlippedBlocksWritingMode()), granularity, multiplier))
 834             scrolled = true;
 835 
 836         if (scrolled) {
 837             if (stopElement)
 838                 *stopElement = element();
 839             return true;
 840         }
 841     }
 842 
 843     if (stopElement &amp;&amp; *stopElement &amp;&amp; *stopElement == element())
 844         return true;
 845 
 846     RenderBlock* b = containingBlock();
 847     if (b &amp;&amp; !b-&gt;isRenderView())
 848         return b-&gt;logicalScroll(direction, granularity, multiplier, stopElement);
 849     return false;
 850 }
 851 
 852 bool RenderBox::canBeScrolledAndHasScrollableArea() const
 853 {
 854     return canBeProgramaticallyScrolled() &amp;&amp; (hasHorizontalOverflow() || hasVerticalOverflow());
 855 }
 856 
 857 bool RenderBox::isScrollableOrRubberbandableBox() const
 858 {
 859     return canBeScrolledAndHasScrollableArea();
 860 }
 861 
 862 // FIXME: This is badly named. overflow:hidden can be programmatically scrolled, yet this returns false in that case.
 863 bool RenderBox::canBeProgramaticallyScrolled() const
 864 {
 865     if (isRenderView())
 866         return true;
 867 
 868     if (!hasOverflowClip())
 869         return false;
 870 
 871     if (hasScrollableOverflowX() || hasScrollableOverflowY())
 872         return true;
 873 
 874     return element() &amp;&amp; element()-&gt;hasEditableStyle();
 875 }
 876 
 877 bool RenderBox::usesCompositedScrolling() const
 878 {
 879     return hasOverflowClip() &amp;&amp; hasLayer() &amp;&amp; layer()-&gt;usesCompositedScrolling();
 880 }
 881 
 882 void RenderBox::autoscroll(const IntPoint&amp; position)
 883 {
 884     if (layer())
 885         layer()-&gt;autoscroll(position);
 886 }
 887 
 888 // There are two kinds of renderer that can autoscroll.
 889 bool RenderBox::canAutoscroll() const
 890 {
 891     if (isRenderView())
 892         return view().frameView().isScrollable();
 893 
 894     // Check for a box that can be scrolled in its own right.
 895     if (canBeScrolledAndHasScrollableArea())
 896         return true;
 897 
 898     return false;
 899 }
 900 
 901 // If specified point is in border belt, returned offset denotes direction of
 902 // scrolling.
 903 IntSize RenderBox::calculateAutoscrollDirection(const IntPoint&amp; windowPoint) const
 904 {
 905     IntRect box(absoluteBoundingBoxRect());
 906     box.moveBy(view().frameView().scrollPosition());
 907     IntRect windowBox = view().frameView().contentsToWindow(box);
 908 
 909     IntPoint windowAutoscrollPoint = windowPoint;
 910 
 911     if (windowAutoscrollPoint.x() &lt; windowBox.x() + autoscrollBeltSize)
 912         windowAutoscrollPoint.move(-autoscrollBeltSize, 0);
 913     else if (windowAutoscrollPoint.x() &gt; windowBox.maxX() - autoscrollBeltSize)
 914         windowAutoscrollPoint.move(autoscrollBeltSize, 0);
 915 
 916     if (windowAutoscrollPoint.y() &lt; windowBox.y() + autoscrollBeltSize)
 917         windowAutoscrollPoint.move(0, -autoscrollBeltSize);
 918     else if (windowAutoscrollPoint.y() &gt; windowBox.maxY() - autoscrollBeltSize)
 919         windowAutoscrollPoint.move(0, autoscrollBeltSize);
 920 
 921     return windowAutoscrollPoint - windowPoint;
 922 }
 923 
 924 RenderBox* RenderBox::findAutoscrollable(RenderObject* renderer)
 925 {
 926     while (renderer &amp;&amp; !(is&lt;RenderBox&gt;(*renderer) &amp;&amp; downcast&lt;RenderBox&gt;(*renderer).canAutoscroll())) {
 927         if (is&lt;RenderView&gt;(*renderer) &amp;&amp; renderer-&gt;document().ownerElement())
 928             renderer = renderer-&gt;document().ownerElement()-&gt;renderer();
 929         else
 930             renderer = renderer-&gt;parent();
 931     }
 932 
 933     return is&lt;RenderBox&gt;(renderer) ? downcast&lt;RenderBox&gt;(renderer) : nullptr;
 934 }
 935 
 936 void RenderBox::panScroll(const IntPoint&amp; source)
 937 {
 938     if (layer())
 939         layer()-&gt;panScrollFromPoint(source);
 940 }
 941 
 942 bool RenderBox::canUseOverlayScrollbars() const
 943 {
 944     return !style().hasPseudoStyle(PseudoId::Scrollbar) &amp;&amp; ScrollbarTheme::theme().usesOverlayScrollbars();
 945 }
 946 
 947 bool RenderBox::hasVerticalScrollbarWithAutoBehavior() const
 948 {
 949     return hasOverflowClip() &amp;&amp; (style().overflowY() == Overflow::Auto || (style().overflowY() == Overflow::Scroll &amp;&amp; canUseOverlayScrollbars()));
 950 }
 951 
 952 bool RenderBox::hasHorizontalScrollbarWithAutoBehavior() const
 953 {
 954     return hasOverflowClip() &amp;&amp; (style().overflowX() == Overflow::Auto || (style().overflowX() == Overflow::Scroll &amp;&amp; canUseOverlayScrollbars()));
 955 }
 956 
 957 bool RenderBox::needsPreferredWidthsRecalculation() const
 958 {
 959     return style().paddingStart().isPercentOrCalculated() || style().paddingEnd().isPercentOrCalculated();
 960 }
 961 
 962 ScrollPosition RenderBox::scrollPosition() const
 963 {
 964     if (!hasOverflowClip())
 965         return { 0, 0 };
 966 
 967     ASSERT(hasLayer());
 968     return layer()-&gt;scrollPosition();
 969 }
 970 
 971 LayoutSize RenderBox::cachedSizeForOverflowClip() const
 972 {
 973     ASSERT(hasOverflowClip());
 974     ASSERT(hasLayer());
 975     return layer()-&gt;size();
 976 }
 977 
 978 bool RenderBox::applyCachedClipAndScrollPosition(LayoutRect&amp; rect, const RenderLayerModelObject* container, VisibleRectContext context) const
 979 {
 980     flipForWritingMode(rect);
 981 
 982     if (context.m_options.contains(VisibleRectContextOption::ApplyCompositedContainerScrolls) || this != container || !usesCompositedScrolling())
 983         rect.moveBy(-scrollPosition()); // For overflow:auto/scroll/hidden.
 984 
 985     // Do not clip scroll layer contents to reduce the number of repaints while scrolling.
<a name="7" id="anc7"></a><span class="line-modified"> 986     if (!context.m_options.contains(VisibleRectContextOption::ApplyCompositedClips) &amp;&amp; usesCompositedScrolling()) {</span>

 987         flipForWritingMode(rect);
 988         return true;
 989     }
 990 
 991     // height() is inaccurate if we&#39;re in the middle of a layout of this RenderBox, so use the
 992     // layer&#39;s size instead. Even if the layer&#39;s size is wrong, the layer itself will repaint
 993     // anyway if its size does change.
 994     LayoutRect clipRect(LayoutPoint(), cachedSizeForOverflowClip());
 995     bool intersects;
 996     if (context.m_options.contains(VisibleRectContextOption::UseEdgeInclusiveIntersection))
 997         intersects = rect.edgeInclusiveIntersect(clipRect);
 998     else {
 999         rect.intersect(clipRect);
1000         intersects = !rect.isEmpty();
1001     }
1002     flipForWritingMode(rect);
1003     return intersects;
1004 }
1005 
1006 void RenderBox::computeIntrinsicLogicalWidths(LayoutUnit&amp; minLogicalWidth, LayoutUnit&amp; maxLogicalWidth) const
1007 {
1008     minLogicalWidth = minPreferredLogicalWidth() - borderAndPaddingLogicalWidth();
1009     maxLogicalWidth = maxPreferredLogicalWidth() - borderAndPaddingLogicalWidth();
1010 }
1011 
1012 LayoutUnit RenderBox::minPreferredLogicalWidth() const
1013 {
1014     if (preferredLogicalWidthsDirty()) {
1015 #ifndef NDEBUG
1016         SetLayoutNeededForbiddenScope layoutForbiddenScope(const_cast&lt;RenderBox*&gt;(this));
1017 #endif
1018         const_cast&lt;RenderBox*&gt;(this)-&gt;computePreferredLogicalWidths();
1019     }
1020 
1021     return m_minPreferredLogicalWidth;
1022 }
1023 
1024 LayoutUnit RenderBox::maxPreferredLogicalWidth() const
1025 {
1026     if (preferredLogicalWidthsDirty()) {
1027 #ifndef NDEBUG
1028         SetLayoutNeededForbiddenScope layoutForbiddenScope(const_cast&lt;RenderBox*&gt;(this));
1029 #endif
1030         const_cast&lt;RenderBox*&gt;(this)-&gt;computePreferredLogicalWidths();
1031     }
1032 
1033     return m_maxPreferredLogicalWidth;
1034 }
1035 
1036 bool RenderBox::hasOverrideContentLogicalHeight() const
1037 {
1038     return gOverrideContentLogicalHeightMap &amp;&amp; gOverrideContentLogicalHeightMap-&gt;contains(this);
1039 }
1040 
1041 bool RenderBox::hasOverrideContentLogicalWidth() const
1042 {
1043     return gOverrideContentLogicalWidthMap &amp;&amp; gOverrideContentLogicalWidthMap-&gt;contains(this);
1044 }
1045 
1046 void RenderBox::setOverrideContentLogicalHeight(LayoutUnit height)
1047 {
1048     if (!gOverrideContentLogicalHeightMap)
1049         gOverrideContentLogicalHeightMap = new OverrideSizeMap();
1050     gOverrideContentLogicalHeightMap-&gt;set(this, height);
1051 }
1052 
1053 void RenderBox::setOverrideContentLogicalWidth(LayoutUnit width)
1054 {
1055     if (!gOverrideContentLogicalWidthMap)
1056         gOverrideContentLogicalWidthMap = new OverrideSizeMap();
1057     gOverrideContentLogicalWidthMap-&gt;set(this, width);
1058 }
1059 
1060 void RenderBox::clearOverrideContentLogicalHeight()
1061 {
1062     if (gOverrideContentLogicalHeightMap)
1063         gOverrideContentLogicalHeightMap-&gt;remove(this);
1064 }
1065 
1066 void RenderBox::clearOverrideContentLogicalWidth()
1067 {
1068     if (gOverrideContentLogicalWidthMap)
1069         gOverrideContentLogicalWidthMap-&gt;remove(this);
1070 }
1071 
1072 void RenderBox::clearOverrideContentSize()
1073 {
1074     clearOverrideContentLogicalHeight();
1075     clearOverrideContentLogicalWidth();
1076 }
1077 
1078 LayoutUnit RenderBox::overrideContentLogicalWidth() const
1079 {
1080     ASSERT(hasOverrideContentLogicalWidth());
1081     return gOverrideContentLogicalWidthMap-&gt;get(this);
1082 }
1083 
1084 LayoutUnit RenderBox::overrideContentLogicalHeight() const
1085 {
1086     ASSERT(hasOverrideContentLogicalHeight());
1087     return gOverrideContentLogicalHeightMap-&gt;get(this);
1088 }
1089 
1090 Optional&lt;LayoutUnit&gt; RenderBox::overrideContainingBlockContentWidth() const
1091 {
1092     ASSERT(hasOverrideContainingBlockContentWidth());
1093     return containingBlock()-&gt;style().isHorizontalWritingMode()
1094         ? gOverrideContainingBlockContentLogicalWidthMap-&gt;get(this)
1095         : gOverrideContainingBlockContentLogicalHeightMap-&gt;get(this);
1096 }
1097 
1098 Optional&lt;LayoutUnit&gt; RenderBox::overrideContainingBlockContentHeight() const
1099 {
1100     ASSERT(hasOverrideContainingBlockContentHeight());
1101     return containingBlock()-&gt;style().isHorizontalWritingMode()
1102         ? gOverrideContainingBlockContentLogicalHeightMap-&gt;get(this)
1103         : gOverrideContainingBlockContentLogicalWidthMap-&gt;get(this);
1104 }
1105 
1106 bool RenderBox::hasOverrideContainingBlockContentWidth() const
1107 {
1108     RenderBlock* cb = containingBlock();
1109     if (!cb)
1110         return false;
1111 
1112     return cb-&gt;style().isHorizontalWritingMode()
1113         ? gOverrideContainingBlockContentLogicalWidthMap &amp;&amp; gOverrideContainingBlockContentLogicalWidthMap-&gt;contains(this)
1114         : gOverrideContainingBlockContentLogicalHeightMap &amp;&amp; gOverrideContainingBlockContentLogicalHeightMap-&gt;contains(this);
1115 }
1116 
1117 bool RenderBox::hasOverrideContainingBlockContentHeight() const
1118 {
1119     RenderBlock* cb = containingBlock();
1120     if (!cb)
1121         return false;
1122 
1123     return cb-&gt;style().isHorizontalWritingMode()
1124         ? gOverrideContainingBlockContentLogicalHeightMap &amp;&amp; gOverrideContainingBlockContentLogicalHeightMap-&gt;contains(this)
1125         : gOverrideContainingBlockContentLogicalHeightMap &amp;&amp; gOverrideContainingBlockContentLogicalHeightMap-&gt;contains(this);
1126 }
1127 
1128 Optional&lt;LayoutUnit&gt; RenderBox::overrideContainingBlockContentLogicalWidth() const
1129 {
1130     ASSERT(hasOverrideContainingBlockContentLogicalWidth());
1131     return gOverrideContainingBlockContentLogicalWidthMap-&gt;get(this);
1132 }
1133 
1134 Optional&lt;LayoutUnit&gt; RenderBox::overrideContainingBlockContentLogicalHeight() const
1135 {
1136     ASSERT(hasOverrideContainingBlockContentLogicalHeight());
1137     return gOverrideContainingBlockContentLogicalHeightMap-&gt;get(this);
1138 }
1139 
1140 bool RenderBox::hasOverrideContainingBlockContentLogicalWidth() const
1141 {
1142     return gOverrideContainingBlockContentLogicalWidthMap &amp;&amp; gOverrideContainingBlockContentLogicalWidthMap-&gt;contains(this);
1143 }
1144 
1145 bool RenderBox::hasOverrideContainingBlockContentLogicalHeight() const
1146 {
1147     return gOverrideContainingBlockContentLogicalHeightMap &amp;&amp; gOverrideContainingBlockContentLogicalHeightMap-&gt;contains(this);
1148 }
1149 
1150 void RenderBox::setOverrideContainingBlockContentLogicalWidth(Optional&lt;LayoutUnit&gt; logicalWidth)
1151 {
1152     if (!gOverrideContainingBlockContentLogicalWidthMap)
1153         gOverrideContainingBlockContentLogicalWidthMap = new OverrideOptionalSizeMap;
1154     gOverrideContainingBlockContentLogicalWidthMap-&gt;set(this, logicalWidth);
1155 }
1156 
1157 void RenderBox::setOverrideContainingBlockContentLogicalHeight(Optional&lt;LayoutUnit&gt; logicalHeight)
1158 {
1159     if (!gOverrideContainingBlockContentLogicalHeightMap)
1160         gOverrideContainingBlockContentLogicalHeightMap = new OverrideOptionalSizeMap;
1161     gOverrideContainingBlockContentLogicalHeightMap-&gt;set(this, logicalHeight);
1162 }
1163 
1164 void RenderBox::clearOverrideContainingBlockContentSize()
1165 {
1166     if (gOverrideContainingBlockContentLogicalWidthMap)
1167         gOverrideContainingBlockContentLogicalWidthMap-&gt;remove(this);
1168     clearOverrideContainingBlockContentLogicalHeight();
1169 }
1170 
1171 void RenderBox::clearOverrideContainingBlockContentLogicalHeight()
1172 {
1173     if (gOverrideContainingBlockContentLogicalHeightMap)
1174         gOverrideContainingBlockContentLogicalHeightMap-&gt;remove(this);
1175 }
1176 
1177 LayoutUnit RenderBox::adjustBorderBoxLogicalWidthForBoxSizing(LayoutUnit width) const
1178 {
1179     LayoutUnit bordersPlusPadding = borderAndPaddingLogicalWidth();
1180     if (style().boxSizing() == BoxSizing::ContentBox)
1181         return width + bordersPlusPadding;
1182     return std::max(width, bordersPlusPadding);
1183 }
1184 
1185 LayoutUnit RenderBox::adjustBorderBoxLogicalHeightForBoxSizing(LayoutUnit height) const
1186 {
1187     LayoutUnit bordersPlusPadding = borderAndPaddingLogicalHeight();
1188     if (style().boxSizing() == BoxSizing::ContentBox)
1189         return height + bordersPlusPadding;
1190     return std::max(height, bordersPlusPadding);
1191 }
1192 
1193 LayoutUnit RenderBox::adjustContentBoxLogicalWidthForBoxSizing(LayoutUnit width) const
1194 {
1195     if (style().boxSizing() == BoxSizing::BorderBox)
1196         width -= borderAndPaddingLogicalWidth();
1197     return std::max&lt;LayoutUnit&gt;(0, width);
1198 }
1199 
1200 LayoutUnit RenderBox::adjustContentBoxLogicalHeightForBoxSizing(Optional&lt;LayoutUnit&gt; height) const
1201 {
1202     if (!height)
1203         return 0;
1204     LayoutUnit result = height.value();
1205     if (style().boxSizing() == BoxSizing::BorderBox)
1206         result -= borderAndPaddingLogicalHeight();
1207     return std::max(0_lu, result);
1208 }
1209 
1210 // Hit Testing
1211 bool RenderBox::nodeAtPoint(const HitTestRequest&amp; request, HitTestResult&amp; result, const HitTestLocation&amp; locationInContainer, const LayoutPoint&amp; accumulatedOffset, HitTestAction action)
1212 {
1213     LayoutPoint adjustedLocation = accumulatedOffset + location();
1214 
1215     // Check kids first.
1216     for (RenderObject* child = lastChild(); child; child = child-&gt;previousSibling()) {
1217         if (!child-&gt;hasLayer() &amp;&amp; child-&gt;nodeAtPoint(request, result, locationInContainer, adjustedLocation, action)) {
1218             updateHitTestResult(result, locationInContainer.point() - toLayoutSize(adjustedLocation));
1219             return true;
1220         }
1221     }
1222 
1223     // Check our bounds next. For this purpose always assume that we can only be hit in the
1224     // foreground phase (which is true for replaced elements like images).
1225     LayoutRect boundsRect = borderBoxRectInFragment(nullptr);
1226     boundsRect.moveBy(adjustedLocation);
1227     if (visibleToHitTesting() &amp;&amp; action == HitTestForeground &amp;&amp; locationInContainer.intersects(boundsRect)) {
1228         updateHitTestResult(result, locationInContainer.point() - toLayoutSize(adjustedLocation));
1229         if (result.addNodeToListBasedTestResult(element(), request, locationInContainer, boundsRect) == HitTestProgress::Stop)
1230             return true;
1231     }
1232 
1233     return false;
1234 }
1235 
1236 // --------------------- painting stuff -------------------------------
1237 
1238 void RenderBox::paintRootBoxFillLayers(const PaintInfo&amp; paintInfo)
1239 {
1240     ASSERT(isDocumentElementRenderer());
1241     if (paintInfo.skipRootBackground())
1242         return;
1243 
1244     auto* rootBackgroundRenderer = view().rendererForRootBackground();
1245     if (!rootBackgroundRenderer)
1246         return;
1247 
1248     auto&amp; style = rootBackgroundRenderer-&gt;style();
<a name="8" id="anc8"></a><span class="line-removed">1249 </span>
1250     auto color = style.visitedDependentColor(CSSPropertyBackgroundColor);
<a name="9" id="anc9"></a><span class="line-modified">1251 </span>
<span class="line-removed">1252     CompositeOperator compositeOp = CompositeSourceOver;</span>
<span class="line-removed">1253     if (document().settings().punchOutWhiteBackgroundsInDarkMode() &amp;&amp; Color::isWhiteColor(color) &amp;&amp; useDarkAppearance())</span>
<span class="line-removed">1254         compositeOp = CompositeDestinationOut;</span>
1255 
1256     paintFillLayers(paintInfo, style.colorByApplyingColorFilter(color), style.backgroundLayers(), view().backgroundRect(), BackgroundBleedNone, compositeOp, rootBackgroundRenderer);
1257 }
1258 
1259 BackgroundBleedAvoidance RenderBox::determineBackgroundBleedAvoidance(GraphicsContext&amp; context) const
1260 {
1261     if (context.paintingDisabled())
1262         return BackgroundBleedNone;
1263 
1264     const RenderStyle&amp; style = this-&gt;style();
1265 
1266     if (!style.hasBackground() || !style.hasBorder() || !style.hasBorderRadius() || borderImageIsLoadedAndCanBeRendered())
1267         return BackgroundBleedNone;
1268 
1269     AffineTransform ctm = context.getCTM();
1270     FloatSize contextScaling(static_cast&lt;float&gt;(ctm.xScale()), static_cast&lt;float&gt;(ctm.yScale()));
1271 
1272     // Because RoundedRect uses IntRect internally the inset applied by the
1273     // BackgroundBleedShrinkBackground strategy cannot be less than one integer
1274     // layout coordinate, even with subpixel layout enabled. To take that into
1275     // account, we clamp the contextScaling to 1.0 for the following test so
1276     // that borderObscuresBackgroundEdge can only return true if the border
1277     // widths are greater than 2 in both layout coordinates and screen
1278     // coordinates.
1279     // This precaution will become obsolete if RoundedRect is ever promoted to
1280     // a sub-pixel representation.
1281     if (contextScaling.width() &gt; 1)
1282         contextScaling.setWidth(1);
1283     if (contextScaling.height() &gt; 1)
1284         contextScaling.setHeight(1);
1285 
1286     if (borderObscuresBackgroundEdge(contextScaling))
1287         return BackgroundBleedShrinkBackground;
1288     if (!style.hasAppearance() &amp;&amp; borderObscuresBackground() &amp;&amp; backgroundHasOpaqueTopLayer())
1289         return BackgroundBleedBackgroundOverBorder;
1290 
1291     return BackgroundBleedUseTransparencyLayer;
1292 }
1293 
1294 void RenderBox::paintBoxDecorations(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset)
1295 {
1296     if (!paintInfo.shouldPaintWithinRoot(*this))
1297         return;
1298 
1299     LayoutRect paintRect = borderBoxRectInFragment(nullptr);
1300     paintRect.moveBy(paintOffset);
1301     adjustBorderBoxRectForPainting(paintRect);
1302 
1303 #if PLATFORM(IOS_FAMILY)
1304     // Workaround for &lt;rdar://problem/6209763&gt;. Force the painting bounds of checkboxes and radio controls to be square.
<a name="10" id="anc10"></a>
1305     if (style().appearance() == CheckboxPart || style().appearance() == RadioPart) {
1306         int width = std::min(paintRect.width(), paintRect.height());
1307         int height = width;
<a name="11" id="anc11"></a><span class="line-modified">1308         paintRect = IntRect(paintRect.x(), paintRect.y() + (this-&gt;height() - height) / 2, width, height); // Vertically center the checkbox, like on desktop</span>
1309     }
1310 #endif
1311     BackgroundBleedAvoidance bleedAvoidance = determineBackgroundBleedAvoidance(paintInfo.context());
1312 
1313     // FIXME: Should eventually give the theme control over whether the box shadow should paint, since controls could have
1314     // custom shadows of their own.
1315     if (!boxShadowShouldBeAppliedToBackground(paintRect.location(), bleedAvoidance))
1316         paintBoxShadow(paintInfo, paintRect, style(), Normal);
1317 
1318     GraphicsContextStateSaver stateSaver(paintInfo.context(), false);
1319     if (bleedAvoidance == BackgroundBleedUseTransparencyLayer) {
1320         // To avoid the background color bleeding out behind the border, we&#39;ll render background and border
1321         // into a transparency layer, and then clip that in one go (which requires setting up the clip before
1322         // beginning the layer).
1323         stateSaver.save();
1324         paintInfo.context().clipRoundedRect(style().getRoundedBorderFor(paintRect).pixelSnappedRoundedRectForPainting(document().deviceScaleFactor()));
1325         paintInfo.context().beginTransparencyLayer(1);
1326     }
1327 
1328     // If we have a native theme appearance, paint that before painting our background.
1329     // The theme will tell us whether or not we should also paint the CSS background.
1330     bool borderOrBackgroundPaintingIsNeeded = true;
1331     if (style().hasAppearance()) {
1332         ControlStates* controlStates = controlStatesForRenderer(*this);
1333         borderOrBackgroundPaintingIsNeeded = theme().paint(*this, *controlStates, paintInfo, paintRect);
1334         if (controlStates-&gt;needsRepaint())
1335             view().scheduleLazyRepaint(*this);
1336     }
1337 
1338     if (borderOrBackgroundPaintingIsNeeded) {
1339         if (bleedAvoidance == BackgroundBleedBackgroundOverBorder)
1340             paintBorder(paintInfo, paintRect, style(), bleedAvoidance);
1341 
1342         paintBackground(paintInfo, paintRect, bleedAvoidance);
1343 
1344         if (style().hasAppearance())
1345             theme().paintDecorations(*this, paintInfo, paintRect);
1346     }
1347     paintBoxShadow(paintInfo, paintRect, style(), Inset);
1348 
1349     // The theme will tell us whether or not we should also paint the CSS border.
1350     if (bleedAvoidance != BackgroundBleedBackgroundOverBorder &amp;&amp; (!style().hasAppearance() || (borderOrBackgroundPaintingIsNeeded &amp;&amp; theme().paintBorderOnly(*this, paintInfo, paintRect))) &amp;&amp; style().hasVisibleBorderDecoration())
1351         paintBorder(paintInfo, paintRect, style(), bleedAvoidance);
1352 
1353     if (bleedAvoidance == BackgroundBleedUseTransparencyLayer)
1354         paintInfo.context().endTransparencyLayer();
1355 }
1356 
1357 bool RenderBox::paintsOwnBackground() const
1358 {
1359     if (isBody()) {
1360         // The &lt;body&gt; only paints its background if the root element has defined a background independent of the body,
1361         // or if the &lt;body&gt;&#39;s parent is not the document element&#39;s renderer (e.g. inside SVG foreignObject).
1362         auto documentElementRenderer = document().documentElement()-&gt;renderer();
1363         return !documentElementRenderer
1364             || documentElementRenderer-&gt;hasBackground()
1365             || (documentElementRenderer != parent());
1366     }
1367 
1368     return true;
1369 }
1370 
1371 void RenderBox::paintBackground(const PaintInfo&amp; paintInfo, const LayoutRect&amp; paintRect, BackgroundBleedAvoidance bleedAvoidance)
1372 {
1373     if (isDocumentElementRenderer()) {
1374         paintRootBoxFillLayers(paintInfo);
1375         return;
1376     }
1377 
1378     if (!paintsOwnBackground())
1379         return;
1380 
1381     if (backgroundIsKnownToBeObscured(paintRect.location()) &amp;&amp; !boxShadowShouldBeAppliedToBackground(paintRect.location(), bleedAvoidance))
1382         return;
1383 
<a name="12" id="anc12"></a><span class="line-modified">1384     Color backgroundColor = style().visitedDependentColor(CSSPropertyBackgroundColor);</span>
<span class="line-modified">1385 </span>
<span class="line-removed">1386     CompositeOperator compositeOp = CompositeSourceOver;</span>
<span class="line-removed">1387     if (document().settings().punchOutWhiteBackgroundsInDarkMode() &amp;&amp; Color::isWhiteColor(backgroundColor) &amp;&amp; useDarkAppearance())</span>
<span class="line-removed">1388         compositeOp = CompositeDestinationOut;</span>
1389 
1390     paintFillLayers(paintInfo, style().colorByApplyingColorFilter(backgroundColor), style().backgroundLayers(), paintRect, bleedAvoidance, compositeOp);
1391 }
1392 
1393 bool RenderBox::getBackgroundPaintedExtent(const LayoutPoint&amp; paintOffset, LayoutRect&amp; paintedExtent) const
1394 {
1395     ASSERT(hasBackground());
1396     LayoutRect backgroundRect = snappedIntRect(borderBoxRect());
1397 
1398     Color backgroundColor = style().visitedDependentColorWithColorFilter(CSSPropertyBackgroundColor);
1399     if (backgroundColor.isVisible()) {
1400         paintedExtent = backgroundRect;
1401         return true;
1402     }
1403 
1404     auto&amp; layers = style().backgroundLayers();
1405     if (!layers.image() || layers.next()) {
1406         paintedExtent =  backgroundRect;
1407         return true;
1408     }
1409 
1410     auto geometry = calculateBackgroundImageGeometry(nullptr, layers, paintOffset, backgroundRect);
1411     paintedExtent = geometry.destRect();
1412     return !geometry.hasNonLocalGeometry();
1413 }
1414 
1415 bool RenderBox::backgroundIsKnownToBeOpaqueInRect(const LayoutRect&amp; localRect) const
1416 {
1417     if (!paintsOwnBackground())
1418         return false;
1419 
1420     Color backgroundColor = style().visitedDependentColorWithColorFilter(CSSPropertyBackgroundColor);
1421     if (!backgroundColor.isOpaque())
1422         return false;
1423 
1424     // If the element has appearance, it might be painted by theme.
1425     // We cannot be sure if theme paints the background opaque.
1426     // In this case it is safe to not assume opaqueness.
1427     // FIXME: May be ask theme if it paints opaque.
1428     if (style().hasAppearance())
1429         return false;
1430     // FIXME: Check the opaqueness of background images.
1431 
1432     if (hasClip() || hasClipPath())
1433         return false;
1434 
1435     // FIXME: Use rounded rect if border radius is present.
1436     if (style().hasBorderRadius())
1437         return false;
1438 
1439     // FIXME: The background color clip is defined by the last layer.
1440     if (style().backgroundLayers().next())
1441         return false;
1442     LayoutRect backgroundRect;
1443     switch (style().backgroundClip()) {
1444     case FillBox::Border:
1445         backgroundRect = borderBoxRect();
1446         break;
1447     case FillBox::Padding:
1448         backgroundRect = paddingBoxRect();
1449         break;
1450     case FillBox::Content:
1451         backgroundRect = contentBoxRect();
1452         break;
1453     default:
1454         break;
1455     }
1456     return backgroundRect.contains(localRect);
1457 }
1458 
1459 static bool isCandidateForOpaquenessTest(const RenderBox&amp; childBox)
1460 {
1461     const RenderStyle&amp; childStyle = childBox.style();
1462     if (childStyle.position() != PositionType::Static &amp;&amp; childBox.containingBlock() != childBox.parent())
1463         return false;
1464     if (childStyle.visibility() != Visibility::Visible)
1465         return false;
1466     if (childStyle.shapeOutside())
1467         return false;
1468     if (!childBox.width() || !childBox.height())
1469         return false;
1470     if (RenderLayer* childLayer = childBox.layer()) {
1471         if (childLayer-&gt;isComposited())
1472             return false;
1473         // FIXME: Deal with z-index.
1474         if (!childStyle.hasAutoZIndex())
1475             return false;
1476         if (childLayer-&gt;hasTransform() || childLayer-&gt;isTransparent() || childLayer-&gt;hasFilter())
1477             return false;
1478         if (!childBox.scrollPosition().isZero())
1479             return false;
1480     }
1481     return true;
1482 }
1483 
1484 bool RenderBox::foregroundIsKnownToBeOpaqueInRect(const LayoutRect&amp; localRect, unsigned maxDepthToTest) const
1485 {
1486     if (!maxDepthToTest)
1487         return false;
1488 
1489     for (auto&amp; childBox : childrenOfType&lt;RenderBox&gt;(*this)) {
1490         if (!isCandidateForOpaquenessTest(childBox))
1491             continue;
1492         LayoutPoint childLocation = childBox.location();
1493         if (childBox.isRelativelyPositioned())
1494             childLocation.move(childBox.relativePositionOffset());
1495         LayoutRect childLocalRect = localRect;
1496         childLocalRect.moveBy(-childLocation);
1497         if (childLocalRect.y() &lt; 0 || childLocalRect.x() &lt; 0) {
1498             // If there is unobscured area above/left of a static positioned box then the rect is probably not covered.
1499             if (childBox.style().position() == PositionType::Static)
1500                 return false;
1501             continue;
1502         }
1503         if (childLocalRect.maxY() &gt; childBox.height() || childLocalRect.maxX() &gt; childBox.width())
1504             continue;
1505         if (childBox.backgroundIsKnownToBeOpaqueInRect(childLocalRect))
1506             return true;
1507         if (childBox.foregroundIsKnownToBeOpaqueInRect(childLocalRect, maxDepthToTest - 1))
1508             return true;
1509     }
1510     return false;
1511 }
1512 
1513 bool RenderBox::computeBackgroundIsKnownToBeObscured(const LayoutPoint&amp; paintOffset)
1514 {
1515     // Test to see if the children trivially obscure the background.
1516     // FIXME: This test can be much more comprehensive.
1517     if (!hasBackground())
1518         return false;
1519     // Table and root background painting is special.
1520     if (isTable() || isDocumentElementRenderer())
1521         return false;
1522 
1523     LayoutRect backgroundRect;
1524     if (!getBackgroundPaintedExtent(paintOffset, backgroundRect))
1525         return false;
1526 
1527     if (hasLayer() &amp;&amp; layer()-&gt;scrollingMayRevealBackground())
1528         return false;
1529 
1530     return foregroundIsKnownToBeOpaqueInRect(backgroundRect, backgroundObscurationTestMaxDepth);
1531 }
1532 
1533 bool RenderBox::backgroundHasOpaqueTopLayer() const
1534 {
1535     auto&amp; fillLayer = style().backgroundLayers();
1536     if (fillLayer.clip() != FillBox::Border)
1537         return false;
1538 
1539     // Clipped with local scrolling
1540     if (hasOverflowClip() &amp;&amp; fillLayer.attachment() == FillAttachment::LocalBackground)
1541         return false;
1542 
1543     if (fillLayer.hasOpaqueImage(*this) &amp;&amp; fillLayer.hasRepeatXY() &amp;&amp; fillLayer.image()-&gt;canRender(this, style().effectiveZoom()))
1544         return true;
1545 
1546     // If there is only one layer and no image, check whether the background color is opaque.
1547     if (!fillLayer.next() &amp;&amp; !fillLayer.hasImage()) {
1548         Color bgColor = style().visitedDependentColorWithColorFilter(CSSPropertyBackgroundColor);
1549         if (bgColor.isOpaque())
1550             return true;
1551     }
1552 
1553     return false;
1554 }
1555 
1556 void RenderBox::paintMask(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset)
1557 {
1558     if (!paintInfo.shouldPaintWithinRoot(*this) || style().visibility() != Visibility::Visible || paintInfo.phase != PaintPhase::Mask || paintInfo.context().paintingDisabled())
1559         return;
1560 
1561     LayoutRect paintRect = LayoutRect(paintOffset, size());
1562     adjustBorderBoxRectForPainting(paintRect);
1563     paintMaskImages(paintInfo, paintRect);
1564 }
1565 
1566 void RenderBox::paintClippingMask(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset)
1567 {
1568     if (!paintInfo.shouldPaintWithinRoot(*this) || style().visibility() != Visibility::Visible || paintInfo.phase != PaintPhase::ClippingMask || paintInfo.context().paintingDisabled())
1569         return;
1570 
1571     LayoutRect paintRect = LayoutRect(paintOffset, size());
1572     paintInfo.context().fillRect(snappedIntRect(paintRect), Color::black);
1573 }
1574 
1575 void RenderBox::paintMaskImages(const PaintInfo&amp; paintInfo, const LayoutRect&amp; paintRect)
1576 {
1577     // Figure out if we need to push a transparency layer to render our mask.
1578     bool pushTransparencyLayer = false;
1579     bool compositedMask = hasLayer() &amp;&amp; layer()-&gt;hasCompositedMask();
1580     bool flattenCompositingLayers = paintInfo.paintBehavior.contains(PaintBehavior::FlattenCompositingLayers);
1581     CompositeOperator compositeOp = CompositeSourceOver;
1582 
1583     bool allMaskImagesLoaded = true;
1584 
1585     if (!compositedMask || flattenCompositingLayers) {
1586         pushTransparencyLayer = true;
1587 
1588         // Don&#39;t render a masked element until all the mask images have loaded, to prevent a flash of unmasked content.
1589         if (auto* maskBoxImage = style().maskBoxImage().image())
1590             allMaskImagesLoaded &amp;= maskBoxImage-&gt;isLoaded();
1591 
1592         allMaskImagesLoaded &amp;= style().maskLayers().imagesAreLoaded();
1593 
1594         paintInfo.context().setCompositeOperation(CompositeDestinationIn);
1595         paintInfo.context().beginTransparencyLayer(1);
1596         compositeOp = CompositeSourceOver;
1597     }
1598 
1599     if (allMaskImagesLoaded) {
1600         paintFillLayers(paintInfo, Color(), style().maskLayers(), paintRect, BackgroundBleedNone, compositeOp);
1601         paintNinePieceImage(paintInfo.context(), paintRect, style(), style().maskBoxImage(), compositeOp);
1602     }
1603 
1604     if (pushTransparencyLayer)
1605         paintInfo.context().endTransparencyLayer();
1606 }
1607 
1608 LayoutRect RenderBox::maskClipRect(const LayoutPoint&amp; paintOffset)
1609 {
1610     const NinePieceImage&amp; maskBoxImage = style().maskBoxImage();
1611     if (maskBoxImage.image()) {
1612         LayoutRect borderImageRect = borderBoxRect();
1613 
1614         // Apply outsets to the border box.
1615         borderImageRect.expand(style().maskBoxImageOutsets());
1616         return borderImageRect;
1617     }
1618 
1619     LayoutRect result;
1620     LayoutRect borderBox = borderBoxRect();
1621     for (auto* maskLayer = &amp;style().maskLayers(); maskLayer; maskLayer = maskLayer-&gt;next()) {
1622         if (maskLayer-&gt;image()) {
1623             // Masks should never have fixed attachment, so it&#39;s OK for paintContainer to be null.
1624             result.unite(calculateBackgroundImageGeometry(nullptr, *maskLayer, paintOffset, borderBox).destRect());
1625         }
1626     }
1627     return result;
1628 }
1629 
1630 void RenderBox::paintFillLayers(const PaintInfo&amp; paintInfo, const Color&amp; color, const FillLayer&amp; fillLayer, const LayoutRect&amp; rect,
1631     BackgroundBleedAvoidance bleedAvoidance, CompositeOperator op, RenderElement* backgroundObject)
1632 {
1633     Vector&lt;const FillLayer*, 8&gt; layers;
1634     bool shouldDrawBackgroundInSeparateBuffer = false;
1635 
1636     for (auto* layer = &amp;fillLayer; layer; layer = layer-&gt;next()) {
1637         layers.append(layer);
1638 
1639         if (layer-&gt;blendMode() != BlendMode::Normal)
1640             shouldDrawBackgroundInSeparateBuffer = true;
1641 
1642         // Stop traversal when an opaque layer is encountered.
1643         // FIXME: It would be possible for the following occlusion culling test to be more aggressive
1644         // on layers with no repeat by testing whether the image covers the layout rect.
1645         // Testing that here would imply duplicating a lot of calculations that are currently done in
1646         // RenderBoxModelObject::paintFillLayerExtended. A more efficient solution might be to move
1647         // the layer recursion into paintFillLayerExtended, or to compute the layer geometry here
1648         // and pass it down.
1649 
1650         // The clipOccludesNextLayers condition must be evaluated first to avoid short-circuiting.
1651         if (layer-&gt;clipOccludesNextLayers(layer == &amp;fillLayer) &amp;&amp; layer-&gt;hasOpaqueImage(*this) &amp;&amp; layer-&gt;image()-&gt;canRender(this, style().effectiveZoom()) &amp;&amp; layer-&gt;hasRepeatXY() &amp;&amp; layer-&gt;blendMode() == BlendMode::Normal)
1652             break;
1653     }
1654 
1655     auto&amp; context = paintInfo.context();
1656     auto baseBgColorUsage = BaseBackgroundColorUse;
1657 
1658     if (shouldDrawBackgroundInSeparateBuffer) {
1659         paintFillLayer(paintInfo, color, *layers.last(), rect, bleedAvoidance, op, backgroundObject, BaseBackgroundColorOnly);
1660         baseBgColorUsage = BaseBackgroundColorSkip;
1661         context.beginTransparencyLayer(1);
1662     }
1663 
1664     auto topLayer = layers.rend();
1665     for (auto it = layers.rbegin(); it != topLayer; ++it)
1666         paintFillLayer(paintInfo, color, **it, rect, bleedAvoidance, op, backgroundObject, baseBgColorUsage);
1667 
1668     if (shouldDrawBackgroundInSeparateBuffer)
1669         context.endTransparencyLayer();
1670 }
1671 
1672 void RenderBox::paintFillLayer(const PaintInfo&amp; paintInfo, const Color&amp; c, const FillLayer&amp; fillLayer, const LayoutRect&amp; rect,
1673     BackgroundBleedAvoidance bleedAvoidance, CompositeOperator op, RenderElement* backgroundObject, BaseBackgroundColorUsage baseBgColorUsage)
1674 {
1675     paintFillLayerExtended(paintInfo, c, fillLayer, rect, bleedAvoidance, nullptr, LayoutSize(), op, backgroundObject, baseBgColorUsage);
1676 }
1677 
1678 static bool layersUseImage(WrappedImagePtr image, const FillLayer&amp; layers)
1679 {
1680     for (auto* layer = &amp;layers; layer; layer = layer-&gt;next()) {
1681         if (layer-&gt;image() &amp;&amp; image == layer-&gt;image()-&gt;data())
1682             return true;
1683     }
1684     return false;
1685 }
1686 
1687 void RenderBox::imageChanged(WrappedImagePtr image, const IntRect*)
1688 {
1689     if (!parent())
1690         return;
1691 
1692     if ((style().borderImage().image() &amp;&amp; style().borderImage().image()-&gt;data() == image) ||
1693         (style().maskBoxImage().image() &amp;&amp; style().maskBoxImage().image()-&gt;data() == image)) {
1694         repaint();
1695         return;
1696     }
1697 
1698     ShapeValue* shapeOutsideValue = style().shapeOutside();
1699     if (!view().frameView().layoutContext().isInRenderTreeLayout() &amp;&amp; isFloating() &amp;&amp; shapeOutsideValue &amp;&amp; shapeOutsideValue-&gt;image() &amp;&amp; shapeOutsideValue-&gt;image()-&gt;data() == image) {
<a name="13" id="anc13"></a><span class="line-modified">1700         ShapeOutsideInfo&amp; info = ShapeOutsideInfo::ensureInfo(*this);</span>
<span class="line-modified">1701         if (!info.isComputingShape()) {</span>
<span class="line-modified">1702             info.markShapeAsDirty();</span>
<span class="line-removed">1703             markShapeOutsideDependentsForLayout();</span>
<span class="line-removed">1704         }</span>
<span class="line-removed">1705      }</span>
1706 
1707     bool didFullRepaint = repaintLayerRectsForImage(image, style().backgroundLayers(), true);
1708     if (!didFullRepaint)
1709         repaintLayerRectsForImage(image, style().maskLayers(), false);
1710 
1711     if (!isComposited())
1712         return;
1713 
1714     if (layer()-&gt;hasCompositedMask() &amp;&amp; layersUseImage(image, style().maskLayers()))
1715         layer()-&gt;contentChanged(MaskImageChanged);
1716     if (layersUseImage(image, style().backgroundLayers()))
1717         layer()-&gt;contentChanged(BackgroundImageChanged);
1718 }
1719 
1720 bool RenderBox::repaintLayerRectsForImage(WrappedImagePtr image, const FillLayer&amp; layers, bool drawingBackground)
1721 {
1722     LayoutRect rendererRect;
1723     RenderBox* layerRenderer = nullptr;
1724 
1725     for (auto* layer = &amp;layers; layer; layer = layer-&gt;next()) {
1726         if (layer-&gt;image() &amp;&amp; image == layer-&gt;image()-&gt;data() &amp;&amp; layer-&gt;image()-&gt;canRender(this, style().effectiveZoom())) {
1727             // Now that we know this image is being used, compute the renderer and the rect if we haven&#39;t already.
1728             bool drawingRootBackground = drawingBackground &amp;&amp; (isDocumentElementRenderer() || (isBody() &amp;&amp; !document().documentElement()-&gt;renderer()-&gt;hasBackground()));
1729             if (!layerRenderer) {
1730                 if (drawingRootBackground) {
1731                     layerRenderer = &amp;view();
1732 
1733                     LayoutUnit rw = downcast&lt;RenderView&gt;(*layerRenderer).frameView().contentsWidth();
1734                     LayoutUnit rh = downcast&lt;RenderView&gt;(*layerRenderer).frameView().contentsHeight();
1735 
1736                     rendererRect = LayoutRect(-layerRenderer-&gt;marginLeft(),
1737                         -layerRenderer-&gt;marginTop(),
1738                         std::max(layerRenderer-&gt;width() + layerRenderer-&gt;horizontalMarginExtent() + layerRenderer-&gt;borderLeft() + layerRenderer-&gt;borderRight(), rw),
1739                         std::max(layerRenderer-&gt;height() + layerRenderer-&gt;verticalMarginExtent() + layerRenderer-&gt;borderTop() + layerRenderer-&gt;borderBottom(), rh));
1740                 } else {
1741                     layerRenderer = this;
1742                     rendererRect = borderBoxRect();
1743                 }
1744             }
1745             // FIXME: Figure out how to pass absolute position to calculateBackgroundImageGeometry (for pixel snapping)
1746             BackgroundImageGeometry geometry = layerRenderer-&gt;calculateBackgroundImageGeometry(nullptr, *layer, LayoutPoint(), rendererRect);
1747             if (geometry.hasNonLocalGeometry()) {
1748                 // Rather than incur the costs of computing the paintContainer for renderers with fixed backgrounds
1749                 // in order to get the right destRect, just repaint the entire renderer.
1750                 layerRenderer-&gt;repaint();
1751                 return true;
1752             }
1753 
1754             LayoutRect rectToRepaint = geometry.destRect();
1755             bool shouldClipToLayer = true;
1756 
1757             // If this is the root background layer, we may need to extend the repaintRect if the FrameView has an
1758             // extendedBackground. We should only extend the rect if it is already extending the full width or height
1759             // of the rendererRect.
1760             if (drawingRootBackground &amp;&amp; view().frameView().hasExtendedBackgroundRectForPainting()) {
1761                 shouldClipToLayer = false;
1762                 IntRect extendedBackgroundRect = view().frameView().extendedBackgroundRectForPainting();
1763                 if (rectToRepaint.width() == rendererRect.width()) {
1764                     rectToRepaint.move(extendedBackgroundRect.x(), 0);
1765                     rectToRepaint.setWidth(extendedBackgroundRect.width());
1766                 }
1767                 if (rectToRepaint.height() == rendererRect.height()) {
1768                     rectToRepaint.move(0, extendedBackgroundRect.y());
1769                     rectToRepaint.setHeight(extendedBackgroundRect.height());
1770                 }
1771             }
1772 
1773             layerRenderer-&gt;repaintRectangle(rectToRepaint, shouldClipToLayer);
1774             if (geometry.destRect() == rendererRect)
1775                 return true;
1776         }
1777     }
1778     return false;
1779 }
1780 
1781 bool RenderBox::pushContentsClip(PaintInfo&amp; paintInfo, const LayoutPoint&amp; accumulatedOffset)
1782 {
1783     if (paintInfo.phase == PaintPhase::BlockBackground || paintInfo.phase == PaintPhase::SelfOutline || paintInfo.phase == PaintPhase::Mask)
1784         return false;
1785 
1786     bool isControlClip = hasControlClip();
1787     bool isOverflowClip = hasOverflowClip() &amp;&amp; !layer()-&gt;isSelfPaintingLayer();
1788 
1789     if (!isControlClip &amp;&amp; !isOverflowClip)
1790         return false;
1791 
1792     if (paintInfo.phase == PaintPhase::Outline)
1793         paintInfo.phase = PaintPhase::ChildOutlines;
1794     else if (paintInfo.phase == PaintPhase::ChildBlockBackground) {
1795         paintInfo.phase = PaintPhase::BlockBackground;
1796         paintObject(paintInfo, accumulatedOffset);
1797         paintInfo.phase = PaintPhase::ChildBlockBackgrounds;
1798     }
1799     float deviceScaleFactor = document().deviceScaleFactor();
1800     FloatRect clipRect = snapRectToDevicePixels((isControlClip ? controlClipRect(accumulatedOffset) : overflowClipRect(accumulatedOffset, nullptr, IgnoreOverlayScrollbarSize, paintInfo.phase)), deviceScaleFactor);
1801     paintInfo.context().save();
1802     if (style().hasBorderRadius())
1803         paintInfo.context().clipRoundedRect(style().getRoundedInnerBorderFor(LayoutRect(accumulatedOffset, size())).pixelSnappedRoundedRectForPainting(deviceScaleFactor));
1804     paintInfo.context().clip(clipRect);
<a name="14" id="anc14"></a>



1805     return true;
1806 }
1807 
1808 void RenderBox::popContentsClip(PaintInfo&amp; paintInfo, PaintPhase originalPhase, const LayoutPoint&amp; accumulatedOffset)
1809 {
1810     ASSERT(hasControlClip() || (hasOverflowClip() &amp;&amp; !layer()-&gt;isSelfPaintingLayer()));
1811 
<a name="15" id="anc15"></a>


1812     paintInfo.context().restore();
1813     if (originalPhase == PaintPhase::Outline) {
1814         paintInfo.phase = PaintPhase::SelfOutline;
1815         paintObject(paintInfo, accumulatedOffset);
1816         paintInfo.phase = originalPhase;
1817     } else if (originalPhase == PaintPhase::ChildBlockBackground)
1818         paintInfo.phase = originalPhase;
1819 }
1820 
1821 LayoutRect RenderBox::overflowClipRect(const LayoutPoint&amp; location, RenderFragmentContainer* fragment, OverlayScrollbarSizeRelevancy relevancy, PaintPhase)
1822 {
1823     // FIXME: When overflow-clip (CSS3) is implemented, we&#39;ll obtain the property
1824     // here.
1825     LayoutRect clipRect = borderBoxRectInFragment(fragment);
1826     clipRect.setLocation(location + clipRect.location() + LayoutSize(borderLeft(), borderTop()));
1827     clipRect.setSize(clipRect.size() - LayoutSize(borderLeft() + borderRight(), borderTop() + borderBottom()));
1828 
1829     // Subtract out scrollbars if we have them.
1830     if (layer()) {
1831         if (shouldPlaceBlockDirectionScrollbarOnLeft())
1832             clipRect.move(layer()-&gt;verticalScrollbarWidth(relevancy), 0);
1833         clipRect.contract(layer()-&gt;verticalScrollbarWidth(relevancy), layer()-&gt;horizontalScrollbarHeight(relevancy));
1834     }
1835 
1836     return clipRect;
1837 }
1838 
1839 LayoutRect RenderBox::clipRect(const LayoutPoint&amp; location, RenderFragmentContainer* fragment)
1840 {
1841     LayoutRect borderBoxRect = borderBoxRectInFragment(fragment);
1842     LayoutRect clipRect = LayoutRect(borderBoxRect.location() + location, borderBoxRect.size());
1843 
1844     if (!style().clipLeft().isAuto()) {
1845         LayoutUnit c = valueForLength(style().clipLeft(), borderBoxRect.width());
1846         clipRect.move(c, 0_lu);
1847         clipRect.contract(c, 0_lu);
1848     }
1849 
1850     // We don&#39;t use the fragment-specific border box&#39;s width and height since clip offsets are (stupidly) specified
1851     // from the left and top edges. Therefore it&#39;s better to avoid constraining to smaller widths and heights.
1852 
1853     if (!style().clipRight().isAuto())
1854         clipRect.contract(width() - valueForLength(style().clipRight(), width()), 0_lu);
1855 
1856     if (!style().clipTop().isAuto()) {
1857         LayoutUnit c = valueForLength(style().clipTop(), borderBoxRect.height());
1858         clipRect.move(0_lu, c);
1859         clipRect.contract(0_lu, c);
1860     }
1861 
1862     if (!style().clipBottom().isAuto())
1863         clipRect.contract(0_lu, height() - valueForLength(style().clipBottom(), height()));
1864 
1865     return clipRect;
1866 }
1867 
1868 LayoutUnit RenderBox::shrinkLogicalWidthToAvoidFloats(LayoutUnit childMarginStart, LayoutUnit childMarginEnd, const RenderBlock&amp; cb, RenderFragmentContainer* fragment) const
1869 {
1870     RenderFragmentContainer* containingBlockFragment = nullptr;
1871     LayoutUnit logicalTopPosition = logicalTop();
1872     if (fragment) {
1873         LayoutUnit offsetFromLogicalTopOfFragment = fragment ? fragment-&gt;logicalTopForFragmentedFlowContent() - offsetFromLogicalTopOfFirstPage() : 0_lu;
1874         logicalTopPosition = std::max(logicalTopPosition, logicalTopPosition + offsetFromLogicalTopOfFragment);
1875         containingBlockFragment = cb.clampToStartAndEndFragments(fragment);
1876     }
1877 
1878     LayoutUnit logicalHeight = cb.logicalHeightForChild(*this);
1879     LayoutUnit result = cb.availableLogicalWidthForLineInFragment(logicalTopPosition, DoNotIndentText, containingBlockFragment, logicalHeight) - childMarginStart - childMarginEnd;
1880 
1881     // We need to see if margins on either the start side or the end side can contain the floats in question. If they can,
1882     // then just using the line width is inaccurate. In the case where a float completely fits, we don&#39;t need to use the line
1883     // offset at all, but can instead push all the way to the content edge of the containing block. In the case where the float
1884     // doesn&#39;t fit, we can use the line offset, but we need to grow it by the margin to reflect the fact that the margin was
1885     // &quot;consumed&quot; by the float. Negative margins aren&#39;t consumed by the float, and so we ignore them.
1886     if (childMarginStart &gt; 0) {
1887         LayoutUnit startContentSide = cb.startOffsetForContent(containingBlockFragment);
1888         LayoutUnit startContentSideWithMargin = startContentSide + childMarginStart;
1889         LayoutUnit startOffset = cb.startOffsetForLineInFragment(logicalTopPosition, DoNotIndentText, containingBlockFragment, logicalHeight);
1890         if (startOffset &gt; startContentSideWithMargin)
1891             result += childMarginStart;
1892         else
1893             result += startOffset - startContentSide;
1894     }
1895 
1896     if (childMarginEnd &gt; 0) {
1897         LayoutUnit endContentSide = cb.endOffsetForContent(containingBlockFragment);
1898         LayoutUnit endContentSideWithMargin = endContentSide + childMarginEnd;
1899         LayoutUnit endOffset = cb.endOffsetForLineInFragment(logicalTopPosition, DoNotIndentText, containingBlockFragment, logicalHeight);
1900         if (endOffset &gt; endContentSideWithMargin)
1901             result += childMarginEnd;
1902         else
1903             result += endOffset - endContentSide;
1904     }
1905 
1906     return result;
1907 }
1908 
1909 LayoutUnit RenderBox::containingBlockLogicalWidthForContent() const
1910 {
1911     if (hasOverrideContainingBlockContentLogicalWidth()) {
1912         if (auto overrideLogicalWidth = overrideContainingBlockContentLogicalWidth())
1913             return overrideLogicalWidth.value();
1914     }
1915 
1916     if (RenderBlock* cb = containingBlock())
1917         return cb-&gt;availableLogicalWidth();
1918     return 0_lu;
1919 }
1920 
1921 LayoutUnit RenderBox::containingBlockLogicalHeightForContent(AvailableLogicalHeightType heightType) const
1922 {
1923     if (hasOverrideContainingBlockContentLogicalHeight()) {
1924         if (auto overrideLogicalHeight = overrideContainingBlockContentLogicalHeight())
1925             return overrideLogicalHeight.value();
1926     }
1927 
1928     if (RenderBlock* cb = containingBlock())
1929         return cb-&gt;availableLogicalHeight(heightType);
1930     return 0_lu;
1931 }
1932 
1933 LayoutUnit RenderBox::containingBlockLogicalWidthForContentInFragment(RenderFragmentContainer* fragment) const
1934 {
1935     if (!fragment)
1936         return containingBlockLogicalWidthForContent();
1937 
1938     RenderBlock* cb = containingBlock();
1939     RenderFragmentContainer* containingBlockFragment = cb-&gt;clampToStartAndEndFragments(fragment);
1940     // FIXME: It&#39;s unclear if a fragment&#39;s content should use the containing block&#39;s override logical width.
1941     // If it should, the following line should call containingBlockLogicalWidthForContent.
1942     LayoutUnit result = cb-&gt;availableLogicalWidth();
1943     RenderBoxFragmentInfo* boxInfo = cb-&gt;renderBoxFragmentInfo(containingBlockFragment);
1944     if (!boxInfo)
1945         return result;
1946     return std::max&lt;LayoutUnit&gt;(0, result - (cb-&gt;logicalWidth() - boxInfo-&gt;logicalWidth()));
1947 }
1948 
1949 LayoutUnit RenderBox::containingBlockAvailableLineWidthInFragment(RenderFragmentContainer* fragment) const
1950 {
1951     RenderBlock* cb = containingBlock();
1952     RenderFragmentContainer* containingBlockFragment = nullptr;
1953     LayoutUnit logicalTopPosition = logicalTop();
1954     if (fragment) {
1955         LayoutUnit offsetFromLogicalTopOfFragment = fragment ? fragment-&gt;logicalTopForFragmentedFlowContent() - offsetFromLogicalTopOfFirstPage() : 0_lu;
1956         logicalTopPosition = std::max(logicalTopPosition, logicalTopPosition + offsetFromLogicalTopOfFragment);
1957         containingBlockFragment = cb-&gt;clampToStartAndEndFragments(fragment);
1958     }
1959     return cb-&gt;availableLogicalWidthForLineInFragment(logicalTopPosition, DoNotIndentText, containingBlockFragment, availableLogicalHeight(IncludeMarginBorderPadding));
1960 }
1961 
1962 LayoutUnit RenderBox::perpendicularContainingBlockLogicalHeight() const
1963 {
1964     if (hasOverrideContainingBlockContentLogicalHeight()) {
1965         if (auto overrideLogicalHeight = overrideContainingBlockContentLogicalHeight())
1966             return overrideLogicalHeight.value();
1967     }
1968 
1969     RenderBlock* cb = containingBlock();
1970     if (cb-&gt;hasOverrideContentLogicalHeight())
1971         return cb-&gt;overrideContentLogicalHeight();
1972 
1973     const RenderStyle&amp; containingBlockStyle = cb-&gt;style();
1974     Length logicalHeightLength = containingBlockStyle.logicalHeight();
1975 
1976     // FIXME: For now just support fixed heights.  Eventually should support percentage heights as well.
1977     if (!logicalHeightLength.isFixed()) {
1978         LayoutUnit fillFallbackExtent = containingBlockStyle.isHorizontalWritingMode() ? view().frameView().visibleHeight() : view().frameView().visibleWidth();
1979         LayoutUnit fillAvailableExtent = containingBlock()-&gt;availableLogicalHeight(ExcludeMarginBorderPadding);
1980         view().addPercentHeightDescendant(const_cast&lt;RenderBox&amp;&gt;(*this));
1981         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=158286 We also need to perform the same percentHeightDescendant treatment to the element which dictates the return value for containingBlock()-&gt;availableLogicalHeight() above.
1982         return std::min(fillAvailableExtent, fillFallbackExtent);
1983     }
1984 
1985     // Use the content box logical height as specified by the style.
1986     return cb-&gt;adjustContentBoxLogicalHeightForBoxSizing(LayoutUnit(logicalHeightLength.value()));
1987 }
1988 
1989 void RenderBox::mapLocalToContainer(const RenderLayerModelObject* repaintContainer, TransformState&amp; transformState, MapCoordinatesFlags mode, bool* wasFixed) const
1990 {
1991     if (repaintContainer == this)
1992         return;
1993 
1994     if (!repaintContainer &amp;&amp; view().frameView().layoutContext().isPaintOffsetCacheEnabled()) {
1995         auto* layoutState = view().frameView().layoutContext().layoutState();
1996         LayoutSize offset = layoutState-&gt;paintOffset() + locationOffset();
1997         if (style().hasInFlowPosition() &amp;&amp; layer())
1998             offset += layer()-&gt;offsetForInFlowPosition();
1999         transformState.move(offset);
2000         return;
2001     }
2002 
2003     bool containerSkipped;
2004     RenderElement* container = this-&gt;container(repaintContainer, containerSkipped);
2005     if (!container)
2006         return;
2007 
2008     bool isFixedPos = isFixedPositioned();
2009     // If this box has a transform, it acts as a fixed position container for fixed descendants,
2010     // and may itself also be fixed position. So propagate &#39;fixed&#39; up only if this box is fixed position.
2011     if (hasTransform() &amp;&amp; !isFixedPos)
2012         mode &amp;= ~IsFixed;
2013     else if (isFixedPos)
2014         mode |= IsFixed;
2015 
2016     if (wasFixed)
2017         *wasFixed = mode &amp; IsFixed;
2018 
2019     LayoutSize containerOffset = offsetFromContainer(*container, LayoutPoint(transformState.mappedPoint()));
2020 
2021     bool preserve3D = mode &amp; UseTransforms &amp;&amp; (container-&gt;style().preserves3D() || style().preserves3D());
2022     if (mode &amp; UseTransforms &amp;&amp; shouldUseTransformFromContainer(container)) {
2023         TransformationMatrix t;
2024         getTransformFromContainer(container, containerOffset, t);
2025         transformState.applyTransform(t, preserve3D ? TransformState::AccumulateTransform : TransformState::FlattenTransform);
2026     } else
2027         transformState.move(containerOffset.width(), containerOffset.height(), preserve3D ? TransformState::AccumulateTransform : TransformState::FlattenTransform);
2028 
2029     if (containerSkipped) {
2030         // There can&#39;t be a transform between repaintContainer and o, because transforms create containers, so it should be safe
2031         // to just subtract the delta between the repaintContainer and o.
2032         LayoutSize containerOffset = repaintContainer-&gt;offsetFromAncestorContainer(*container);
2033         transformState.move(-containerOffset.width(), -containerOffset.height(), preserve3D ? TransformState::AccumulateTransform : TransformState::FlattenTransform);
2034         return;
2035     }
2036 
2037     mode &amp;= ~ApplyContainerFlip;
2038 
2039     container-&gt;mapLocalToContainer(repaintContainer, transformState, mode, wasFixed);
2040 }
2041 
2042 const RenderObject* RenderBox::pushMappingToContainer(const RenderLayerModelObject* ancestorToStopAt, RenderGeometryMap&amp; geometryMap) const
2043 {
2044     ASSERT(ancestorToStopAt != this);
2045 
2046     bool ancestorSkipped;
2047     RenderElement* container = this-&gt;container(ancestorToStopAt, ancestorSkipped);
2048     if (!container)
2049         return nullptr;
2050 
2051     bool isFixedPos = isFixedPositioned();
2052     LayoutSize adjustmentForSkippedAncestor;
2053     if (ancestorSkipped) {
2054         // There can&#39;t be a transform between repaintContainer and container, because transforms create containers, so it should be safe
2055         // to just subtract the delta between the ancestor and container.
2056         adjustmentForSkippedAncestor = -ancestorToStopAt-&gt;offsetFromAncestorContainer(*container);
2057     }
2058 
2059     bool offsetDependsOnPoint = false;
2060     LayoutSize containerOffset = offsetFromContainer(*container, LayoutPoint(), &amp;offsetDependsOnPoint);
2061 
2062     bool preserve3D = container-&gt;style().preserves3D() || style().preserves3D();
2063     if (shouldUseTransformFromContainer(container) &amp;&amp; (geometryMap.mapCoordinatesFlags() &amp; UseTransforms)) {
2064         TransformationMatrix t;
2065         getTransformFromContainer(container, containerOffset, t);
2066         t.translateRight(adjustmentForSkippedAncestor.width(), adjustmentForSkippedAncestor.height());
2067 
2068         geometryMap.push(this, t, preserve3D, offsetDependsOnPoint, isFixedPos, hasTransform());
2069     } else {
2070         containerOffset += adjustmentForSkippedAncestor;
2071         geometryMap.push(this, containerOffset, preserve3D, offsetDependsOnPoint, isFixedPos, hasTransform());
2072     }
2073 
2074     return ancestorSkipped ? ancestorToStopAt : container;
2075 }
2076 
2077 void RenderBox::mapAbsoluteToLocalPoint(MapCoordinatesFlags mode, TransformState&amp; transformState) const
2078 {
2079     bool isFixedPos = isFixedPositioned();
2080     if (hasTransform() &amp;&amp; !isFixedPos) {
2081         // If this box has a transform, it acts as a fixed position container for fixed descendants,
2082         // and may itself also be fixed position. So propagate &#39;fixed&#39; up only if this box is fixed position.
2083         mode &amp;= ~IsFixed;
2084     } else if (isFixedPos)
2085         mode |= IsFixed;
2086 
2087     RenderBoxModelObject::mapAbsoluteToLocalPoint(mode, transformState);
2088 }
2089 
2090 LayoutSize RenderBox::offsetFromContainer(RenderElement&amp; container, const LayoutPoint&amp;, bool* offsetDependsOnPoint) const
2091 {
2092     // A fragment &quot;has&quot; boxes inside it without being their container.
2093     ASSERT(&amp;container == this-&gt;container() || is&lt;RenderFragmentContainer&gt;(container));
2094 
2095     LayoutSize offset;
2096     if (isInFlowPositioned())
2097         offset += offsetForInFlowPosition();
2098 
2099     if (!isInline() || isReplaced())
2100         offset += topLeftLocationOffset();
2101 
2102     if (is&lt;RenderBox&gt;(container))
2103         offset -= toLayoutSize(downcast&lt;RenderBox&gt;(container).scrollPosition());
2104 
2105     if (isAbsolutelyPositioned() &amp;&amp; container.isInFlowPositioned() &amp;&amp; is&lt;RenderInline&gt;(container))
2106         offset += downcast&lt;RenderInline&gt;(container).offsetForInFlowPositionedInline(this);
2107 
2108     if (offsetDependsOnPoint)
2109         *offsetDependsOnPoint |= is&lt;RenderFragmentedFlow&gt;(container);
2110 
2111     return offset;
2112 }
2113 
2114 std::unique_ptr&lt;InlineElementBox&gt; RenderBox::createInlineBox()
2115 {
<a name="16" id="anc16"></a><span class="line-modified">2116     return std::make_unique&lt;InlineElementBox&gt;(*this);</span>
2117 }
2118 
2119 void RenderBox::dirtyLineBoxes(bool fullLayout)
2120 {
2121     if (!m_inlineBoxWrapper)
2122         return;
2123 
2124     if (fullLayout) {
2125         delete m_inlineBoxWrapper;
2126         m_inlineBoxWrapper = nullptr;
2127     } else
2128         m_inlineBoxWrapper-&gt;dirtyLineBoxes();
2129 }
2130 
2131 void RenderBox::positionLineBox(InlineElementBox&amp; box)
2132 {
2133     if (isOutOfFlowPositioned()) {
2134         // Cache the x position only if we were an DisplayType::Inline type originally.
2135         bool wasInline = style().isOriginalDisplayInlineType();
2136         if (wasInline) {
2137             // The value is cached in the xPos of the box.  We only need this value if
2138             // our object was inline originally, since otherwise it would have ended up underneath
2139             // the inlines.
2140             RootInlineBox&amp; rootBox = box.root();
2141             rootBox.blockFlow().setStaticInlinePositionForChild(*this, rootBox.lineTopWithLeading(), LayoutUnit::fromFloatRound(box.logicalLeft()));
2142             if (style().hasStaticInlinePosition(box.isHorizontal()))
2143                 setChildNeedsLayout(MarkOnlyThis); // Just mark the positioned object as needing layout, so it will update its position properly.
2144         } else {
2145             // Our object was a block originally, so we make our normal flow position be
2146             // just below the line box (as though all the inlines that came before us got
2147             // wrapped in an anonymous block, which is what would have happened had we been
2148             // in flow).  This value was cached in the y() of the box.
<a name="17" id="anc17"></a><span class="line-modified">2149             layer()-&gt;setStaticBlockPosition(box.logicalTop());</span>
2150             if (style().hasStaticBlockPosition(box.isHorizontal()))
2151                 setChildNeedsLayout(MarkOnlyThis); // Just mark the positioned object as needing layout, so it will update its position properly.
2152         }
2153         return;
2154     }
2155 
2156     if (isReplaced()) {
2157         setLocation(LayoutPoint(box.topLeft()));
2158         setInlineBoxWrapper(&amp;box);
2159     }
2160 }
2161 
2162 void RenderBox::deleteLineBoxWrapper()
2163 {
2164     if (!m_inlineBoxWrapper)
2165         return;
2166 
2167     if (!renderTreeBeingDestroyed())
2168         m_inlineBoxWrapper-&gt;removeFromParent();
2169     delete m_inlineBoxWrapper;
2170     m_inlineBoxWrapper = nullptr;
2171 }
2172 
2173 LayoutRect RenderBox::clippedOverflowRectForRepaint(const RenderLayerModelObject* repaintContainer) const
2174 {
2175     if (style().visibility() != Visibility::Visible &amp;&amp; !enclosingLayer()-&gt;hasVisibleContent())
2176         return LayoutRect();
2177     LayoutRect r = visualOverflowRect();
2178     // FIXME: layoutDelta needs to be applied in parts before/after transforms and
2179     // repaint containers. https://bugs.webkit.org/show_bug.cgi?id=23308
2180     r.move(view().frameView().layoutContext().layoutDelta());
2181     return computeRectForRepaint(r, repaintContainer);
2182 }
2183 
2184 LayoutRect RenderBox::computeVisibleRectUsingPaintOffset(const LayoutRect&amp; rect) const
2185 {
2186     LayoutRect adjustedRect = rect;
2187     auto* layoutState = view().frameView().layoutContext().layoutState();
2188 
2189     if (layer() &amp;&amp; layer()-&gt;transform())
2190         adjustedRect = LayoutRect(encloseRectToDevicePixels(layer()-&gt;transform()-&gt;mapRect(adjustedRect), document().deviceScaleFactor()));
2191 
2192     // We can&#39;t trust the bits on RenderObject, because this might be called while re-resolving style.
2193     if (style().hasInFlowPosition() &amp;&amp; layer())
2194         adjustedRect.move(layer()-&gt;offsetForInFlowPosition());
2195 
2196     adjustedRect.moveBy(location());
2197     adjustedRect.move(layoutState-&gt;paintOffset());
2198     if (layoutState-&gt;isClipped())
2199         adjustedRect.intersect(layoutState-&gt;clipRect());
2200     return adjustedRect;
2201 }
2202 
2203 Optional&lt;LayoutRect&gt; RenderBox::computeVisibleRectInContainer(const LayoutRect&amp; rect, const RenderLayerModelObject* container, VisibleRectContext context) const
2204 {
2205     // The rect we compute at each step is shifted by our x/y offset in the parent container&#39;s coordinate space.
2206     // Only when we cross a writing mode boundary will we have to possibly flipForWritingMode (to convert into a more appropriate
2207     // offset corner for the enclosing container).  This allows for a fully RL or BT document to repaint
2208     // properly even during layout, since the rect remains flipped all the way until the end.
2209     //
2210     // RenderView::computeVisibleRectInContainer then converts the rect to physical coordinates. We also convert to
2211     // physical when we hit a repaint container boundary. Therefore the final rect returned is always in the
2212     // physical coordinate space of the container.
2213     const RenderStyle&amp; styleToUse = style();
2214     // Paint offset cache is only valid for root-relative, non-fixed position repainting
2215     if (view().frameView().layoutContext().isPaintOffsetCacheEnabled() &amp;&amp; !container &amp;&amp; styleToUse.position() != PositionType::Fixed &amp;&amp; !context.m_options.contains(VisibleRectContextOption::UseEdgeInclusiveIntersection))
2216         return computeVisibleRectUsingPaintOffset(rect);
2217 
2218     LayoutRect adjustedRect = rect;
2219     if (hasReflection())
2220         adjustedRect.unite(reflectedRect(adjustedRect));
2221 
2222     if (container == this) {
2223         if (container-&gt;style().isFlippedBlocksWritingMode())
2224             flipForWritingMode(adjustedRect);
2225         return adjustedRect;
2226     }
2227 
2228     bool containerIsSkipped;
2229     auto* localContainer = this-&gt;container(container, containerIsSkipped);
2230     if (!localContainer)
2231         return adjustedRect;
2232 
2233     // This code isn&#39;t necessary for in-flow RenderFragmentedFlows.
2234     // Don&#39;t add the location of the fragment in the flow thread for absolute positioned
2235     // elements because their absolute position already pushes them down through
2236     // the fragments so adding this here and then adding the topLeft again would cause
2237     // us to add the height twice.
2238     // The same logic applies for elements flowed directly into the flow thread. Their topLeft member
2239     // will already contain the portion rect of the fragment.
2240     auto position = styleToUse.position();
2241     if (localContainer-&gt;isOutOfFlowRenderFragmentedFlow() &amp;&amp; position != PositionType::Absolute &amp;&amp; containingBlock() != enclosingFragmentedFlow()) {
2242         RenderFragmentContainer* firstFragment = nullptr;
2243         RenderFragmentContainer* lastFragment = nullptr;
2244         if (downcast&lt;RenderFragmentedFlow&gt;(*localContainer).getFragmentRangeForBox(this, firstFragment, lastFragment))
2245             adjustedRect.moveBy(firstFragment-&gt;fragmentedFlowPortionRect().location());
2246     }
2247 
2248     if (isWritingModeRoot()) {
2249         if (!isOutOfFlowPositioned() || !context.m_dirtyRectIsFlipped) {
2250             flipForWritingMode(adjustedRect);
2251             context.m_dirtyRectIsFlipped = true;
2252         }
2253     }
2254 
2255     LayoutSize locationOffset = this-&gt;locationOffset();
2256     // FIXME: This is needed as long as RenderWidget snaps to integral size/position.
2257     if (isRenderReplaced() &amp;&amp; isWidget()) {
2258         LayoutSize flooredLocationOffset = toIntSize(flooredIntPoint(locationOffset));
2259         adjustedRect.expand(locationOffset - flooredLocationOffset);
2260         locationOffset = flooredLocationOffset;
2261     }
2262 
2263     if (is&lt;RenderMultiColumnFlow&gt;(this)) {
2264         // We won&#39;t normally run this code. Only when the container is null (i.e., we&#39;re trying
2265         // to get the rect in view coordinates) will we come in here, since normally container
2266         // will be set and we&#39;ll stop at the flow thread. This case is mainly hit by the check for whether
2267         // or not images should animate.
2268         // FIXME: Just as with offsetFromContainer, we aren&#39;t really handling objects that span
2269         // multiple columns properly.
2270         LayoutPoint physicalPoint(flipForWritingMode(adjustedRect.location()));
2271         if (auto* fragment = downcast&lt;RenderMultiColumnFlow&gt;(*this).physicalTranslationFromFlowToFragment((physicalPoint))) {
2272             adjustedRect.setLocation(fragment-&gt;flipForWritingMode(physicalPoint));
2273             return fragment-&gt;computeVisibleRectInContainer(adjustedRect, container, context);
2274         }
2275     }
2276 
2277     LayoutPoint topLeft = adjustedRect.location();
2278     topLeft.move(locationOffset);
2279 
2280     // We are now in our parent container&#39;s coordinate space. Apply our transform to obtain a bounding box
2281     // in the parent&#39;s coordinate space that encloses us.
2282     if (hasLayer() &amp;&amp; layer()-&gt;transform()) {
2283         context.m_hasPositionFixedDescendant = position == PositionType::Fixed;
2284         adjustedRect = LayoutRect(encloseRectToDevicePixels(layer()-&gt;transform()-&gt;mapRect(adjustedRect), document().deviceScaleFactor()));
2285         topLeft = adjustedRect.location();
2286         topLeft.move(locationOffset);
2287     } else if (position == PositionType::Fixed)
2288         context.m_hasPositionFixedDescendant = true;
2289 
2290     if (position == PositionType::Absolute &amp;&amp; localContainer-&gt;isInFlowPositioned() &amp;&amp; is&lt;RenderInline&gt;(*localContainer))
2291         topLeft += downcast&lt;RenderInline&gt;(*localContainer).offsetForInFlowPositionedInline(this);
2292     else if (styleToUse.hasInFlowPosition() &amp;&amp; layer()) {
2293         // Apply the relative position offset when invalidating a rectangle.  The layer
2294         // is translated, but the render box isn&#39;t, so we need to do this to get the
2295         // right dirty rect.  Since this is called from RenderObject::setStyle, the relative position
2296         // flag on the RenderObject has been cleared, so use the one on the style().
2297         topLeft += layer()-&gt;offsetForInFlowPosition();
2298     }
2299 
2300     // FIXME: We ignore the lightweight clipping rect that controls use, since if |o| is in mid-layout,
2301     // its controlClipRect will be wrong. For overflow clip we use the values cached by the layer.
2302     adjustedRect.setLocation(topLeft);
2303     if (localContainer-&gt;hasOverflowClip()) {
2304         RenderBox&amp; containerBox = downcast&lt;RenderBox&gt;(*localContainer);
2305         bool isEmpty = !containerBox.applyCachedClipAndScrollPosition(adjustedRect, container, context);
2306         if (isEmpty) {
2307             if (context.m_options.contains(VisibleRectContextOption::UseEdgeInclusiveIntersection))
2308                 return WTF::nullopt;
2309             return adjustedRect;
2310         }
2311     }
2312 
2313     if (containerIsSkipped) {
2314         // If the container is below localContainer, then we need to map the rect into container&#39;s coordinates.
2315         LayoutSize containerOffset = container-&gt;offsetFromAncestorContainer(*localContainer);
2316         adjustedRect.move(-containerOffset);
2317         return adjustedRect;
2318     }
2319     return localContainer-&gt;computeVisibleRectInContainer(adjustedRect, container, context);
2320 }
2321 
2322 void RenderBox::repaintDuringLayoutIfMoved(const LayoutRect&amp; oldRect)
2323 {
2324     if (oldRect.location() != m_frameRect.location()) {
2325         LayoutRect newRect = m_frameRect;
2326         // The child moved.  Invalidate the object&#39;s old and new positions.  We have to do this
2327         // since the object may not have gotten a layout.
2328         m_frameRect = oldRect;
2329         repaint();
2330         repaintOverhangingFloats(true);
2331         m_frameRect = newRect;
2332         repaint();
2333         repaintOverhangingFloats(true);
2334     }
2335 }
2336 
2337 void RenderBox::repaintOverhangingFloats(bool)
2338 {
2339 }
2340 
2341 void RenderBox::updateLogicalWidth()
2342 {
2343     LogicalExtentComputedValues computedValues;
2344     computeLogicalWidthInFragment(computedValues);
2345 
2346     setLogicalWidth(computedValues.m_extent);
2347     setLogicalLeft(computedValues.m_position);
2348     setMarginStart(computedValues.m_margins.m_start);
2349     setMarginEnd(computedValues.m_margins.m_end);
2350 }
2351 
2352 void RenderBox::computeLogicalWidthInFragment(LogicalExtentComputedValues&amp; computedValues, RenderFragmentContainer* fragment) const
2353 {
2354     computedValues.m_extent = logicalWidth();
2355     computedValues.m_position = logicalLeft();
2356     computedValues.m_margins.m_start = marginStart();
2357     computedValues.m_margins.m_end = marginEnd();
2358 
2359     if (isOutOfFlowPositioned()) {
2360         // FIXME: This calculation is not patched for block-flow yet.
2361         // https://bugs.webkit.org/show_bug.cgi?id=46500
2362         computePositionedLogicalWidth(computedValues, fragment);
2363         return;
2364     }
2365 
2366     // If layout is limited to a subtree, the subtree root&#39;s logical width does not change.
2367     if (element() &amp;&amp; !view().frameView().layoutContext().isLayoutPending() &amp;&amp; view().frameView().layoutContext().subtreeLayoutRoot() == this)
2368         return;
2369 
2370     // The parent box is flexing us, so it has increased or decreased our
2371     // width.  Use the width from the style context.
2372     // FIXME: Account for block-flow in flexible boxes.
2373     // https://bugs.webkit.org/show_bug.cgi?id=46418
2374     if (hasOverrideContentLogicalWidth() &amp;&amp; (isRubyRun() || style().borderFit() == BorderFit::Lines || (parent()-&gt;isFlexibleBoxIncludingDeprecated()))) {
2375         computedValues.m_extent = overrideContentLogicalWidth() + borderAndPaddingLogicalWidth();
2376         return;
2377     }
2378 
2379     // FIXME: Account for block-flow in flexible boxes.
2380     // https://bugs.webkit.org/show_bug.cgi?id=46418
2381     bool inVerticalBox = parent()-&gt;isDeprecatedFlexibleBox() &amp;&amp; (parent()-&gt;style().boxOrient() == BoxOrient::Vertical);
2382     bool stretching = (parent()-&gt;style().boxAlign() == BoxAlignment::Stretch);
2383     // FIXME: Stretching is the only reason why we don&#39;t want the box to be treated as a replaced element, so we could perhaps
2384     // refactor all this logic, not only for flex and grid since alignment is intended to be applied to any block.
2385     bool treatAsReplaced = shouldComputeSizeAsReplaced() &amp;&amp; (!inVerticalBox || !stretching);
2386     treatAsReplaced = treatAsReplaced &amp;&amp; (!isGridItem() || !hasStretchedLogicalWidth());
2387 
2388     const RenderStyle&amp; styleToUse = style();
2389     Length logicalWidthLength = treatAsReplaced ? Length(computeReplacedLogicalWidth(), Fixed) : styleToUse.logicalWidth();
2390 
2391     RenderBlock&amp; cb = *containingBlock();
2392     LayoutUnit containerLogicalWidth = std::max&lt;LayoutUnit&gt;(0, containingBlockLogicalWidthForContentInFragment(fragment));
2393     bool hasPerpendicularContainingBlock = cb.isHorizontalWritingMode() != isHorizontalWritingMode();
2394 
2395     if (isInline() &amp;&amp; !isInlineBlockOrInlineTable()) {
2396         // just calculate margins
2397         computedValues.m_margins.m_start = minimumValueForLength(styleToUse.marginStart(), containerLogicalWidth);
2398         computedValues.m_margins.m_end = minimumValueForLength(styleToUse.marginEnd(), containerLogicalWidth);
2399         if (treatAsReplaced)
<a name="18" id="anc18"></a><span class="line-modified">2400             computedValues.m_extent = std::max&lt;LayoutUnit&gt;(floatValueForLength(logicalWidthLength, 0) + borderAndPaddingLogicalWidth(), minPreferredLogicalWidth());</span>
2401         return;
2402     }
2403 
2404     LayoutUnit containerWidthInInlineDirection = containerLogicalWidth;
2405     if (hasPerpendicularContainingBlock)
2406         containerWidthInInlineDirection = perpendicularContainingBlockLogicalHeight();
2407 
2408     // Width calculations
2409     if (treatAsReplaced) {
2410         computedValues.m_extent = logicalWidthLength.value() + borderAndPaddingLogicalWidth();
2411     } else {
2412         LayoutUnit preferredWidth = computeLogicalWidthInFragmentUsing(MainOrPreferredSize, styleToUse.logicalWidth(), containerWidthInInlineDirection, cb, fragment);
2413         computedValues.m_extent = constrainLogicalWidthInFragmentByMinMax(preferredWidth, containerWidthInInlineDirection, cb, fragment);
2414     }
2415 
2416     // Margin calculations.
2417     if (hasPerpendicularContainingBlock || isFloating() || isInline()) {
2418         computedValues.m_margins.m_start = minimumValueForLength(styleToUse.marginStart(), containerLogicalWidth);
2419         computedValues.m_margins.m_end = minimumValueForLength(styleToUse.marginEnd(), containerLogicalWidth);
2420     } else {
2421         LayoutUnit containerLogicalWidthForAutoMargins = containerLogicalWidth;
2422         if (avoidsFloats() &amp;&amp; cb.containsFloats())
2423             containerLogicalWidthForAutoMargins = containingBlockAvailableLineWidthInFragment(fragment);
2424         bool hasInvertedDirection = cb.style().isLeftToRightDirection() != style().isLeftToRightDirection();
2425         computeInlineDirectionMargins(cb, containerLogicalWidthForAutoMargins, computedValues.m_extent,
2426             hasInvertedDirection ? computedValues.m_margins.m_end : computedValues.m_margins.m_start,
2427             hasInvertedDirection ? computedValues.m_margins.m_start : computedValues.m_margins.m_end);
2428     }
2429 
2430     if (!hasPerpendicularContainingBlock &amp;&amp; containerLogicalWidth &amp;&amp; containerLogicalWidth != (computedValues.m_extent + computedValues.m_margins.m_start + computedValues.m_margins.m_end)
2431         &amp;&amp; !isFloating() &amp;&amp; !isInline() &amp;&amp; !cb.isFlexibleBoxIncludingDeprecated()
2432 #if ENABLE(MATHML)
2433         // RenderMathMLBlocks take the size of their content so we must not adjust the margin to fill the container size.
2434         &amp;&amp; !cb.isRenderMathMLBlock()
2435 #endif
2436         &amp;&amp; !cb.isRenderGrid()
2437         ) {
2438         LayoutUnit newMarginTotal = containerLogicalWidth - computedValues.m_extent;
2439         bool hasInvertedDirection = cb.style().isLeftToRightDirection() != style().isLeftToRightDirection();
2440         if (hasInvertedDirection)
2441             computedValues.m_margins.m_start = newMarginTotal - computedValues.m_margins.m_end;
2442         else
2443             computedValues.m_margins.m_end = newMarginTotal - computedValues.m_margins.m_start;
2444     }
2445 }
2446 
2447 LayoutUnit RenderBox::fillAvailableMeasure(LayoutUnit availableLogicalWidth) const
2448 {
2449     LayoutUnit marginStart;
2450     LayoutUnit marginEnd;
2451     return fillAvailableMeasure(availableLogicalWidth, marginStart, marginEnd);
2452 }
2453 
2454 LayoutUnit RenderBox::fillAvailableMeasure(LayoutUnit availableLogicalWidth, LayoutUnit&amp; marginStart, LayoutUnit&amp; marginEnd) const
2455 {
2456     marginStart = minimumValueForLength(style().marginStart(), availableLogicalWidth);
2457     marginEnd = minimumValueForLength(style().marginEnd(), availableLogicalWidth);
2458     return availableLogicalWidth - marginStart - marginEnd;
2459 }
2460 
2461 LayoutUnit RenderBox::computeIntrinsicLogicalWidthUsing(Length logicalWidthLength, LayoutUnit availableLogicalWidth, LayoutUnit borderAndPadding) const
2462 {
2463     if (logicalWidthLength.type() == FillAvailable)
2464         return std::max(borderAndPadding, fillAvailableMeasure(availableLogicalWidth));
2465 
2466     LayoutUnit minLogicalWidth;
2467     LayoutUnit maxLogicalWidth;
2468     computeIntrinsicLogicalWidths(minLogicalWidth, maxLogicalWidth);
2469 
2470     if (logicalWidthLength.type() == MinContent)
2471         return minLogicalWidth + borderAndPadding;
2472 
2473     if (logicalWidthLength.type() == MaxContent)
2474         return maxLogicalWidth + borderAndPadding;
2475 
2476     if (logicalWidthLength.type() == FitContent) {
2477         minLogicalWidth += borderAndPadding;
2478         maxLogicalWidth += borderAndPadding;
2479         return std::max(minLogicalWidth, std::min(maxLogicalWidth, fillAvailableMeasure(availableLogicalWidth)));
2480     }
2481 
2482     ASSERT_NOT_REACHED();
2483     return 0;
2484 }
2485 
2486 LayoutUnit RenderBox::computeLogicalWidthInFragmentUsing(SizeType widthType, Length logicalWidth, LayoutUnit availableLogicalWidth,
2487     const RenderBlock&amp; cb, RenderFragmentContainer* fragment) const
2488 {
2489     ASSERT(widthType == MinSize || widthType == MainOrPreferredSize || !logicalWidth.isAuto());
2490     if (widthType == MinSize &amp;&amp; logicalWidth.isAuto())
2491         return adjustBorderBoxLogicalWidthForBoxSizing(0);
2492 
2493     if (!logicalWidth.isIntrinsicOrAuto()) {
2494         // FIXME: If the containing block flow is perpendicular to our direction we need to use the available logical height instead.
2495         return adjustBorderBoxLogicalWidthForBoxSizing(valueForLength(logicalWidth, availableLogicalWidth));
2496     }
2497 
2498     if (logicalWidth.isIntrinsic())
2499         return computeIntrinsicLogicalWidthUsing(logicalWidth, availableLogicalWidth, borderAndPaddingLogicalWidth());
2500 
2501     LayoutUnit marginStart;
2502     LayoutUnit marginEnd;
2503     LayoutUnit logicalWidthResult = fillAvailableMeasure(availableLogicalWidth, marginStart, marginEnd);
2504 
2505     if (shrinkToAvoidFloats() &amp;&amp; cb.containsFloats())
2506         logicalWidthResult = std::min(logicalWidthResult, shrinkLogicalWidthToAvoidFloats(marginStart, marginEnd, cb, fragment));
2507 
2508     if (widthType == MainOrPreferredSize &amp;&amp; sizesLogicalWidthToFitContent(widthType))
2509         return std::max(minPreferredLogicalWidth(), std::min(maxPreferredLogicalWidth(), logicalWidthResult));
2510     return logicalWidthResult;
2511 }
2512 
2513 bool RenderBox::columnFlexItemHasStretchAlignment() const
2514 {
2515     // auto margins mean we don&#39;t stretch. Note that this function will only be
2516     // used for widths, so we don&#39;t have to check marginBefore/marginAfter.
2517     const auto&amp; parentStyle = parent()-&gt;style();
2518     ASSERT(parentStyle.isColumnFlexDirection());
2519     if (style().marginStart().isAuto() || style().marginEnd().isAuto())
2520         return false;
2521     return style().resolvedAlignSelf(&amp;parentStyle, containingBlock()-&gt;selfAlignmentNormalBehavior()).position() == ItemPosition::Stretch;
2522 }
2523 
2524 bool RenderBox::isStretchingColumnFlexItem() const
2525 {
2526     if (parent()-&gt;isDeprecatedFlexibleBox() &amp;&amp; parent()-&gt;style().boxOrient() == BoxOrient::Vertical &amp;&amp; parent()-&gt;style().boxAlign() == BoxAlignment::Stretch)
2527         return true;
2528 
2529     // We don&#39;t stretch multiline flexboxes because they need to apply line spacing (align-content) first.
2530     if (parent()-&gt;isFlexibleBox() &amp;&amp; parent()-&gt;style().flexWrap() == FlexWrap::NoWrap &amp;&amp; parent()-&gt;style().isColumnFlexDirection() &amp;&amp; columnFlexItemHasStretchAlignment())
2531         return true;
2532     return false;
2533 }
2534 
2535 // FIXME: Can/Should we move this inside specific layout classes (flex. grid)? Can we refactor columnFlexItemHasStretchAlignment logic?
2536 bool RenderBox::hasStretchedLogicalWidth() const
2537 {
2538     auto&amp; style = this-&gt;style();
2539     if (!style.logicalWidth().isAuto() || style.marginStart().isAuto() || style.marginEnd().isAuto())
2540         return false;
2541     RenderBlock* containingBlock = this-&gt;containingBlock();
2542     if (!containingBlock) {
2543         // We are evaluating align-self/justify-self, which default to &#39;normal&#39; for the root element.
2544         // The &#39;normal&#39; value behaves like &#39;start&#39; except for Flexbox Items, which obviously should have a container.
2545         return false;
2546     }
2547     if (containingBlock-&gt;isHorizontalWritingMode() != isHorizontalWritingMode())
2548         return style.resolvedAlignSelf(&amp;containingBlock-&gt;style(), containingBlock-&gt;selfAlignmentNormalBehavior(this)).position() == ItemPosition::Stretch;
2549     return style.resolvedJustifySelf(&amp;containingBlock-&gt;style(), containingBlock-&gt;selfAlignmentNormalBehavior(this)).position() == ItemPosition::Stretch;
2550 }
2551 
2552 bool RenderBox::sizesLogicalWidthToFitContent(SizeType widthType) const
2553 {
2554     // Marquees in WinIE are like a mixture of blocks and inline-blocks.  They size as though they&#39;re blocks,
2555     // but they allow text to sit on the same line as the marquee.
2556     if (isFloating() || (isInlineBlockOrInlineTable() &amp;&amp; !isHTMLMarquee()))
2557         return true;
2558 
2559     if (isGridItem())
2560         return !hasStretchedLogicalWidth();
2561 
2562     // This code may look a bit strange.  Basically width:intrinsic should clamp the size when testing both
2563     // min-width and width.  max-width is only clamped if it is also intrinsic.
2564     Length logicalWidth = (widthType == MaxSize) ? style().logicalMaxWidth() : style().logicalWidth();
2565     if (logicalWidth.type() == Intrinsic)
2566         return true;
2567 
2568     // Children of a horizontal marquee do not fill the container by default.
2569     // FIXME: Need to deal with MarqueeDirection::Auto value properly. It could be vertical.
2570     // FIXME: Think about block-flow here.  Need to find out how marquee direction relates to
2571     // block-flow (as well as how marquee overflow should relate to block flow).
2572     // https://bugs.webkit.org/show_bug.cgi?id=46472
2573     if (parent()-&gt;isHTMLMarquee()) {
2574         MarqueeDirection dir = parent()-&gt;style().marqueeDirection();
2575         if (dir == MarqueeDirection::Auto || dir == MarqueeDirection::Forward || dir == MarqueeDirection::Backward || dir == MarqueeDirection::Left || dir == MarqueeDirection::Right)
2576             return true;
2577     }
2578 
2579 #if ENABLE(MATHML)
2580     // RenderMathMLBlocks take the size of their content, not of their container.
2581     if (parent()-&gt;isRenderMathMLBlock())
2582         return true;
2583 #endif
2584 
2585     // Flexible box items should shrink wrap, so we lay them out at their intrinsic widths.
2586     // In the case of columns that have a stretch alignment, we layout at the stretched size
2587     // to avoid an extra layout when applying alignment.
2588     if (parent()-&gt;isFlexibleBox()) {
2589         // For multiline columns, we need to apply align-content first, so we can&#39;t stretch now.
2590         if (!parent()-&gt;style().isColumnFlexDirection() || parent()-&gt;style().flexWrap() != FlexWrap::NoWrap)
2591             return true;
2592         if (!columnFlexItemHasStretchAlignment())
2593             return true;
2594     }
2595 
2596     // Flexible horizontal boxes lay out children at their intrinsic widths.  Also vertical boxes
2597     // that don&#39;t stretch their kids lay out their children at their intrinsic widths.
2598     // FIXME: Think about block-flow here.
2599     // https://bugs.webkit.org/show_bug.cgi?id=46473
2600     if (parent()-&gt;isDeprecatedFlexibleBox() &amp;&amp; (parent()-&gt;style().boxOrient() == BoxOrient::Horizontal || parent()-&gt;style().boxAlign() != BoxAlignment::Stretch))
2601         return true;
2602 
2603     // Button, input, select, textarea, and legend treat width value of &#39;auto&#39; as &#39;intrinsic&#39; unless it&#39;s in a
2604     // stretching column flexbox.
2605     // FIXME: Think about block-flow here.
2606     // https://bugs.webkit.org/show_bug.cgi?id=46473
2607     if (logicalWidth.type() == Auto &amp;&amp; !isStretchingColumnFlexItem() &amp;&amp; element() &amp;&amp; (is&lt;HTMLInputElement&gt;(*element()) || is&lt;HTMLSelectElement&gt;(*element()) || is&lt;HTMLButtonElement&gt;(*element()) || is&lt;HTMLTextAreaElement&gt;(*element()) || is&lt;HTMLLegendElement&gt;(*element())))
2608         return true;
2609 
2610     if (isHorizontalWritingMode() != containingBlock()-&gt;isHorizontalWritingMode())
2611         return true;
2612 
2613     return false;
2614 }
2615 
2616 void RenderBox::computeInlineDirectionMargins(const RenderBlock&amp; containingBlock, LayoutUnit containerWidth, LayoutUnit childWidth, LayoutUnit&amp; marginStart, LayoutUnit&amp; marginEnd) const
2617 {
2618 
2619     const RenderStyle&amp; containingBlockStyle = containingBlock.style();
2620     Length marginStartLength = style().marginStartUsing(&amp;containingBlockStyle);
2621     Length marginEndLength = style().marginEndUsing(&amp;containingBlockStyle);
2622 
2623     if (isFloating() || isInline()) {
2624         // Inline blocks/tables and floats don&#39;t have their margins increased.
2625         marginStart = minimumValueForLength(marginStartLength, containerWidth);
2626         marginEnd = minimumValueForLength(marginEndLength, containerWidth);
2627         return;
2628     }
2629 
2630     if (containingBlock.isFlexibleBox()) {
2631         // We need to let flexbox handle the margin adjustment - otherwise, flexbox
2632         // will think we&#39;re wider than we actually are and calculate line sizes
2633         // wrong. See also http://dev.w3.org/csswg/css-flexbox/#auto-margins
2634         if (marginStartLength.isAuto())
2635             marginStartLength = Length(0, Fixed);
2636         if (marginEndLength.isAuto())
2637             marginEndLength = Length(0, Fixed);
2638     }
2639 
2640     // Case One: The object is being centered in the containing block&#39;s available logical width.
2641     if ((marginStartLength.isAuto() &amp;&amp; marginEndLength.isAuto() &amp;&amp; childWidth &lt; containerWidth)
2642         || (!marginStartLength.isAuto() &amp;&amp; !marginEndLength.isAuto() &amp;&amp; containingBlock.style().textAlign() == TextAlignMode::WebKitCenter)) {
2643         // Other browsers center the margin box for align=center elements so we match them here.
2644         LayoutUnit marginStartWidth = minimumValueForLength(marginStartLength, containerWidth);
2645         LayoutUnit marginEndWidth = minimumValueForLength(marginEndLength, containerWidth);
2646         LayoutUnit centeredMarginBoxStart = std::max&lt;LayoutUnit&gt;(0, (containerWidth - childWidth - marginStartWidth - marginEndWidth) / 2);
2647         marginStart = centeredMarginBoxStart + marginStartWidth;
2648         marginEnd = containerWidth - childWidth - marginStart + marginEndWidth;
2649         return;
2650     }
2651 
2652     // Case Two: The object is being pushed to the start of the containing block&#39;s available logical width.
2653     if (marginEndLength.isAuto() &amp;&amp; childWidth &lt; containerWidth) {
2654         marginStart = valueForLength(marginStartLength, containerWidth);
2655         marginEnd = containerWidth - childWidth - marginStart;
2656         return;
2657     }
2658 
2659     // Case Three: The object is being pushed to the end of the containing block&#39;s available logical width.
2660     bool pushToEndFromTextAlign = !marginEndLength.isAuto() &amp;&amp; ((!containingBlockStyle.isLeftToRightDirection() &amp;&amp; containingBlockStyle.textAlign() == TextAlignMode::WebKitLeft)
2661         || (containingBlockStyle.isLeftToRightDirection() &amp;&amp; containingBlockStyle.textAlign() == TextAlignMode::WebKitRight));
2662     if ((marginStartLength.isAuto() || pushToEndFromTextAlign) &amp;&amp; childWidth &lt; containerWidth) {
2663         marginEnd = valueForLength(marginEndLength, containerWidth);
2664         marginStart = containerWidth - childWidth - marginEnd;
2665         return;
2666     }
2667 
2668     // Case Four: Either no auto margins, or our width is &gt;= the container width (css2.1, 10.3.3).  In that case
2669     // auto margins will just turn into 0.
2670     marginStart = minimumValueForLength(marginStartLength, containerWidth);
2671     marginEnd = minimumValueForLength(marginEndLength, containerWidth);
2672 }
2673 
2674 RenderBoxFragmentInfo* RenderBox::renderBoxFragmentInfo(RenderFragmentContainer* fragment, RenderBoxFragmentInfoFlags cacheFlag) const
2675 {
2676     // Make sure nobody is trying to call this with a null fragment.
2677     if (!fragment)
2678         return nullptr;
2679 
2680     // If we have computed our width in this fragment already, it will be cached, and we can
2681     // just return it.
2682     RenderBoxFragmentInfo* boxInfo = fragment-&gt;renderBoxFragmentInfo(this);
2683     if (boxInfo &amp;&amp; cacheFlag == CacheRenderBoxFragmentInfo)
2684         return boxInfo;
2685 
2686     return nullptr;
2687 }
2688 
2689 static bool shouldFlipBeforeAfterMargins(const RenderStyle&amp; containingBlockStyle, const RenderStyle* childStyle)
2690 {
2691     ASSERT(containingBlockStyle.isHorizontalWritingMode() != childStyle-&gt;isHorizontalWritingMode());
2692     WritingMode childWritingMode = childStyle-&gt;writingMode();
2693     bool shouldFlip = false;
2694     switch (containingBlockStyle.writingMode()) {
2695     case TopToBottomWritingMode:
2696         shouldFlip = (childWritingMode == RightToLeftWritingMode);
2697         break;
2698     case BottomToTopWritingMode:
2699         shouldFlip = (childWritingMode == RightToLeftWritingMode);
2700         break;
2701     case RightToLeftWritingMode:
2702         shouldFlip = (childWritingMode == BottomToTopWritingMode);
2703         break;
2704     case LeftToRightWritingMode:
2705         shouldFlip = (childWritingMode == BottomToTopWritingMode);
2706         break;
2707     }
2708 
2709     if (!containingBlockStyle.isLeftToRightDirection())
2710         shouldFlip = !shouldFlip;
2711 
2712     return shouldFlip;
2713 }
2714 
2715 void RenderBox::cacheIntrinsicContentLogicalHeightForFlexItem(LayoutUnit height) const
2716 {
2717     if (isFloatingOrOutOfFlowPositioned() || !parent() || !parent()-&gt;isFlexibleBox())
2718         return;
2719     downcast&lt;RenderFlexibleBox&gt;(parent())-&gt;setCachedChildIntrinsicContentLogicalHeight(*this, height);
2720 }
2721 
2722 void RenderBox::updateLogicalHeight()
2723 {
2724     cacheIntrinsicContentLogicalHeightForFlexItem(contentLogicalHeight());
2725     auto computedValues = computeLogicalHeight(logicalHeight(), logicalTop());
2726     setLogicalHeight(computedValues.m_extent);
2727     setLogicalTop(computedValues.m_position);
2728     setMarginBefore(computedValues.m_margins.m_before);
2729     setMarginAfter(computedValues.m_margins.m_after);
2730 }
2731 
2732 RenderBox::LogicalExtentComputedValues RenderBox::computeLogicalHeight(LayoutUnit logicalHeight, LayoutUnit logicalTop) const
2733 {
2734     LogicalExtentComputedValues computedValues;
2735     computedValues.m_extent = logicalHeight;
2736     computedValues.m_position = logicalTop;
2737 
2738     // Cell height is managed by the table and inline non-replaced elements do not support a height property.
2739     if (isTableCell() || (isInline() &amp;&amp; !isReplaced()))
2740         return computedValues;
2741 
2742     Length h;
2743     if (isOutOfFlowPositioned())
2744         computePositionedLogicalHeight(computedValues);
2745     else {
2746         RenderBlock&amp; cb = *containingBlock();
2747         bool hasPerpendicularContainingBlock = cb.isHorizontalWritingMode() != isHorizontalWritingMode();
2748 
2749         if (!hasPerpendicularContainingBlock) {
2750             bool shouldFlipBeforeAfter = cb.style().writingMode() != style().writingMode();
2751             computeBlockDirectionMargins(cb,
2752                 shouldFlipBeforeAfter ? computedValues.m_margins.m_after : computedValues.m_margins.m_before,
2753                 shouldFlipBeforeAfter ? computedValues.m_margins.m_before : computedValues.m_margins.m_after);
2754         }
2755 
2756         // For tables, calculate margins only.
2757         if (isTable()) {
2758             if (hasPerpendicularContainingBlock) {
2759                 bool shouldFlipBeforeAfter = shouldFlipBeforeAfterMargins(cb.style(), &amp;style());
2760                 computeInlineDirectionMargins(cb, containingBlockLogicalWidthForContent(), computedValues.m_extent,
2761                     shouldFlipBeforeAfter ? computedValues.m_margins.m_after : computedValues.m_margins.m_before,
2762                     shouldFlipBeforeAfter ? computedValues.m_margins.m_before : computedValues.m_margins.m_after);
2763             }
2764             return computedValues;
2765         }
2766 
2767         // FIXME: Account for block-flow in flexible boxes.
2768         // https://bugs.webkit.org/show_bug.cgi?id=46418
2769         bool inHorizontalBox = parent()-&gt;isDeprecatedFlexibleBox() &amp;&amp; parent()-&gt;style().boxOrient() == BoxOrient::Horizontal;
2770         bool stretching = parent()-&gt;style().boxAlign() == BoxAlignment::Stretch;
2771         bool treatAsReplaced = shouldComputeSizeAsReplaced() &amp;&amp; (!inHorizontalBox || !stretching);
2772         bool checkMinMaxHeight = false;
2773 
2774         // The parent box is flexing us, so it has increased or decreased our height.  We have to
2775         // grab our cached flexible height.
2776         // FIXME: Account for block-flow in flexible boxes.
2777         // https://bugs.webkit.org/show_bug.cgi?id=46418
2778         if (hasOverrideContentLogicalHeight() &amp;&amp; (parent()-&gt;isFlexibleBoxIncludingDeprecated() || parent()-&gt;isRenderGrid())) {
2779             h = Length(overrideContentLogicalHeight(), Fixed);
2780         } else if (treatAsReplaced)
2781             h = Length(computeReplacedLogicalHeight(), Fixed);
2782         else {
2783             h = style().logicalHeight();
2784             checkMinMaxHeight = true;
2785         }
2786 
2787         // Block children of horizontal flexible boxes fill the height of the box.
2788         // FIXME: Account for block-flow in flexible boxes.
2789         // https://bugs.webkit.org/show_bug.cgi?id=46418
2790         if (h.isAuto() &amp;&amp; is&lt;RenderDeprecatedFlexibleBox&gt;(*parent()) &amp;&amp; parent()-&gt;style().boxOrient() == BoxOrient::Horizontal
2791                 &amp;&amp; downcast&lt;RenderDeprecatedFlexibleBox&gt;(*parent()).isStretchingChildren()) {
2792             h = Length(parentBox()-&gt;contentLogicalHeight() - marginBefore() - marginAfter() - borderAndPaddingLogicalHeight(), Fixed);
2793             checkMinMaxHeight = false;
2794         }
2795 
2796         LayoutUnit heightResult;
2797         if (checkMinMaxHeight) {
2798             LayoutUnit intrinsicHeight = computedValues.m_extent - borderAndPaddingLogicalHeight();
2799             heightResult = computeLogicalHeightUsing(MainOrPreferredSize, style().logicalHeight(), intrinsicHeight).valueOr(computedValues.m_extent);
2800             heightResult = constrainLogicalHeightByMinMax(heightResult, intrinsicHeight);
2801         } else {
2802             // The only times we don&#39;t check min/max height are when a fixed length has
2803             // been given as an override.  Just use that.  The value has already been adjusted
2804             // for box-sizing.
2805             ASSERT(h.isFixed());
2806             heightResult = h.value() + borderAndPaddingLogicalHeight();
2807         }
2808 
2809         computedValues.m_extent = heightResult;
2810 
2811         if (hasPerpendicularContainingBlock) {
2812             bool shouldFlipBeforeAfter = shouldFlipBeforeAfterMargins(cb.style(), &amp;style());
2813             computeInlineDirectionMargins(cb, containingBlockLogicalWidthForContent(), heightResult,
2814                     shouldFlipBeforeAfter ? computedValues.m_margins.m_after : computedValues.m_margins.m_before,
2815                     shouldFlipBeforeAfter ? computedValues.m_margins.m_before : computedValues.m_margins.m_after);
2816         }
2817     }
2818 
2819     // WinIE quirk: The &lt;html&gt; block always fills the entire canvas in quirks mode.  The &lt;body&gt; always fills the
2820     // &lt;html&gt; block in quirks mode.  Only apply this quirk if the block is normal flow and no height
2821     // is specified. When we&#39;re printing, we also need this quirk if the body or root has a percentage
2822     // height since we don&#39;t set a height in RenderView when we&#39;re printing. So without this quirk, the
2823     // height has nothing to be a percentage of, and it ends up being 0. That is bad.
2824     bool paginatedContentNeedsBaseHeight = document().printing() &amp;&amp; h.isPercentOrCalculated()
2825         &amp;&amp; (isDocumentElementRenderer() || (isBody() &amp;&amp; document().documentElement()-&gt;renderer()-&gt;style().logicalHeight().isPercentOrCalculated())) &amp;&amp; !isInline();
2826     if (stretchesToViewport() || paginatedContentNeedsBaseHeight) {
2827         LayoutUnit margins = collapsedMarginBefore() + collapsedMarginAfter();
2828         LayoutUnit visibleHeight = view().pageOrViewLogicalHeight();
2829         if (isDocumentElementRenderer())
2830             computedValues.m_extent = std::max(computedValues.m_extent, visibleHeight - margins);
2831         else {
2832             LayoutUnit marginsBordersPadding = margins + parentBox()-&gt;marginBefore() + parentBox()-&gt;marginAfter() + parentBox()-&gt;borderAndPaddingLogicalHeight();
2833             computedValues.m_extent = std::max(computedValues.m_extent, visibleHeight - marginsBordersPadding);
2834         }
2835     }
2836     return computedValues;
2837 }
2838 
2839 LayoutUnit RenderBox::computeLogicalHeightWithoutLayout() const
2840 {
2841     // FIXME:: We should probably return something other than just
2842     // border + padding, but for now we have no good way to do anything else
2843     // without layout, so we just use that.
2844     LogicalExtentComputedValues computedValues = computeLogicalHeight(borderAndPaddingLogicalHeight(), 0_lu);
2845     return computedValues.m_extent;
2846 }
2847 
2848 Optional&lt;LayoutUnit&gt; RenderBox::computeLogicalHeightUsing(SizeType heightType, const Length&amp; height, Optional&lt;LayoutUnit&gt; intrinsicContentHeight) const
2849 {
2850     if (Optional&lt;LayoutUnit&gt; logicalHeight = computeContentAndScrollbarLogicalHeightUsing(heightType, height, intrinsicContentHeight))
2851         return adjustBorderBoxLogicalHeightForBoxSizing(logicalHeight.value());
2852     return WTF::nullopt;
2853 }
2854 
2855 Optional&lt;LayoutUnit&gt; RenderBox::computeContentLogicalHeight(SizeType heightType, const Length&amp; height, Optional&lt;LayoutUnit&gt; intrinsicContentHeight) const
2856 {
2857     if (Optional&lt;LayoutUnit&gt; heightIncludingScrollbar = computeContentAndScrollbarLogicalHeightUsing(heightType, height, intrinsicContentHeight))
2858         return std::max&lt;LayoutUnit&gt;(0, adjustContentBoxLogicalHeightForBoxSizing(heightIncludingScrollbar) - scrollbarLogicalHeight());
2859     return WTF::nullopt;
2860 }
2861 
2862 Optional&lt;LayoutUnit&gt; RenderBox::computeIntrinsicLogicalContentHeightUsing(Length logicalHeightLength, Optional&lt;LayoutUnit&gt; intrinsicContentHeight, LayoutUnit borderAndPadding) const
2863 {
2864     // FIXME: The CSS sizing spec is considering changing what min-content/max-content should resolve to.
2865     // If that happens, this code will have to change.
2866     if (logicalHeightLength.isMinContent() || logicalHeightLength.isMaxContent() || logicalHeightLength.isFitContent()) {
2867         if (!intrinsicContentHeight)
2868             return intrinsicContentHeight;
2869         if (style().boxSizing() == BoxSizing::BorderBox)
2870             return intrinsicContentHeight.value() + borderAndPaddingLogicalHeight();
2871         return intrinsicContentHeight;
2872     }
2873     if (logicalHeightLength.isFillAvailable())
2874         return containingBlock()-&gt;availableLogicalHeight(ExcludeMarginBorderPadding) - borderAndPadding;
2875     ASSERT_NOT_REACHED();
2876     return 0_lu;
2877 }
2878 
2879 Optional&lt;LayoutUnit&gt; RenderBox::computeContentAndScrollbarLogicalHeightUsing(SizeType heightType, const Length&amp; height, Optional&lt;LayoutUnit&gt; intrinsicContentHeight) const
2880 {
2881     if (height.isAuto())
2882         return heightType == MinSize ? Optional&lt;LayoutUnit&gt;(0) : WTF::nullopt;
2883     // FIXME: The CSS sizing spec is considering changing what min-content/max-content should resolve to.
2884     // If that happens, this code will have to change.
2885     if (height.isIntrinsic())
2886         return computeIntrinsicLogicalContentHeightUsing(height, intrinsicContentHeight, borderAndPaddingLogicalHeight());
2887     if (height.isFixed())
2888         return LayoutUnit(height.value());
2889     if (height.isPercentOrCalculated())
2890         return computePercentageLogicalHeight(height);
2891     return WTF::nullopt;
2892 }
2893 
2894 bool RenderBox::skipContainingBlockForPercentHeightCalculation(const RenderBox&amp; containingBlock, bool isPerpendicularWritingMode) const
2895 {
2896     // Flow threads for multicol or paged overflow should be skipped. They are invisible to the DOM,
2897     // and percent heights of children should be resolved against the multicol or paged container.
2898     if (containingBlock.isInFlowRenderFragmentedFlow() &amp;&amp; !isPerpendicularWritingMode)
2899         return true;
2900 
2901     // Render view is not considered auto height.
2902     if (is&lt;RenderView&gt;(containingBlock))
2903         return false;
2904 
2905     // If the writing mode of the containing block is orthogonal to ours, it means
2906     // that we shouldn&#39;t skip anything, since we&#39;re going to resolve the
2907     // percentage height against a containing block *width*.
2908     if (isPerpendicularWritingMode)
2909         return false;
2910 
2911     // Anonymous blocks should not impede percentage resolution on a child.
2912     // Examples of such anonymous blocks are blocks wrapped around inlines that
2913     // have block siblings (from the CSS spec) and multicol flow threads (an
2914     // implementation detail). Another implementation detail, ruby runs, create
2915     // anonymous inline-blocks, so skip those too. All other types of anonymous
2916     // objects, such as table-cells and flexboxes, will be treated as if they were
2917     // non-anonymous.
2918     if (containingBlock.isAnonymous())
2919         return containingBlock.style().display() == DisplayType::Block || containingBlock.style().display() == DisplayType::InlineBlock;
2920 
2921     // For quirks mode, we skip most auto-height containing blocks when computing
2922     // percentages.
2923     return document().inQuirksMode() &amp;&amp; !containingBlock.isTableCell() &amp;&amp; !containingBlock.isOutOfFlowPositioned() &amp;&amp; !containingBlock.isRenderGrid() &amp;&amp; containingBlock.style().logicalHeight().isAuto();
2924 }
2925 
2926 bool RenderBox::shouldTreatChildAsReplacedInTableCells() const
2927 {
2928     if (isReplaced())
2929         return true;
2930     return element() &amp;&amp; (element()-&gt;isFormControlElement() || is&lt;HTMLImageElement&gt;(element()));
2931 }
2932 
2933 static bool tableCellShouldHaveZeroInitialSize(const RenderBlock&amp; block, const RenderBox&amp; child, bool scrollsOverflowY)
2934 {
2935     // Normally we would let the cell size intrinsically, but scrolling overflow has to be
2936     // treated differently, since WinIE lets scrolled overflow fragments shrink as needed.
2937     // While we can&#39;t get all cases right, we can at least detect when the cell has a specified
2938     // height or when the table has a specified height. In these cases we want to initially have
2939     // no size and allow the flexing of the table or the cell to its specified height to cause us
2940     // to grow to fill the space. This could end up being wrong in some cases, but it is
2941     // preferable to the alternative (sizing intrinsically and making the row end up too big).
2942     const RenderTableCell&amp; cell = downcast&lt;RenderTableCell&gt;(block);
2943     return scrollsOverflowY &amp;&amp; !child.shouldTreatChildAsReplacedInTableCells() &amp;&amp; (!cell.style().logicalHeight().isAuto() || !cell.table()-&gt;style().logicalHeight().isAuto());
2944 }
2945 
2946 Optional&lt;LayoutUnit&gt; RenderBox::computePercentageLogicalHeight(const Length&amp; height) const
2947 {
2948     Optional&lt;LayoutUnit&gt; availableHeight;
2949 
2950     bool skippedAutoHeightContainingBlock = false;
2951     RenderBlock* cb = containingBlock();
2952     const RenderBox* containingBlockChild = this;
2953     LayoutUnit rootMarginBorderPaddingHeight;
2954     bool isHorizontal = isHorizontalWritingMode();
2955     while (cb &amp;&amp; !is&lt;RenderView&gt;(*cb) &amp;&amp; skipContainingBlockForPercentHeightCalculation(*cb, isHorizontal != cb-&gt;isHorizontalWritingMode())) {
2956         if (cb-&gt;isBody() || cb-&gt;isDocumentElementRenderer())
2957             rootMarginBorderPaddingHeight += cb-&gt;marginBefore() + cb-&gt;marginAfter() + cb-&gt;borderAndPaddingLogicalHeight();
2958         skippedAutoHeightContainingBlock = true;
2959         containingBlockChild = cb;
2960         cb = cb-&gt;containingBlock();
2961     }
2962     cb-&gt;addPercentHeightDescendant(const_cast&lt;RenderBox&amp;&gt;(*this));
2963 
2964     if (isHorizontal != cb-&gt;isHorizontalWritingMode())
2965         availableHeight = containingBlockChild-&gt;containingBlockLogicalWidthForContent();
2966     else if (hasOverrideContainingBlockContentLogicalHeight())
2967         availableHeight = overrideContainingBlockContentLogicalHeight();
2968     else if (is&lt;RenderTableCell&gt;(*cb)) {
2969         if (!skippedAutoHeightContainingBlock) {
2970             // Table cells violate what the CSS spec says to do with heights. Basically we
2971             // don&#39;t care if the cell specified a height or not. We just always make ourselves
2972             // be a percentage of the cell&#39;s current content height.
2973             if (!cb-&gt;hasOverrideContentLogicalHeight())
2974                 return tableCellShouldHaveZeroInitialSize(*cb, *this, scrollsOverflowY()) ? Optional&lt;LayoutUnit&gt;(0) : WTF::nullopt;
2975 
2976             availableHeight = cb-&gt;overrideContentLogicalHeight();
2977         }
2978     } else
2979         availableHeight = cb-&gt;availableLogicalHeightForPercentageComputation();
2980 
2981     if (!availableHeight)
2982         return availableHeight;
2983 
2984     LayoutUnit result = valueForLength(height, availableHeight.value() - rootMarginBorderPaddingHeight + (isTable() &amp;&amp; isOutOfFlowPositioned() ? cb-&gt;paddingBefore() + cb-&gt;paddingAfter() : 0_lu));
2985 
2986     // |overrideContentLogicalHeight| is the maximum height made available by the
2987     // cell to its percent height children when we decide they can determine the
2988     // height of the cell. If the percent height child is box-sizing:content-box
2989     // then we must subtract the border and padding from the cell&#39;s
2990     // |availableHeight| (given by |overrideContentLogicalHeight|) to arrive
2991     // at the child&#39;s computed height.
2992     bool subtractBorderAndPadding = isTable() || (is&lt;RenderTableCell&gt;(*cb) &amp;&amp; !skippedAutoHeightContainingBlock &amp;&amp; cb-&gt;hasOverrideContentLogicalHeight());
2993     if (subtractBorderAndPadding) {
2994         result -= borderAndPaddingLogicalHeight();
2995         return std::max(0_lu, result);
2996     }
2997     return result;
2998 }
2999 
3000 LayoutUnit RenderBox::computeReplacedLogicalWidth(ShouldComputePreferred shouldComputePreferred) const
3001 {
3002     return computeReplacedLogicalWidthRespectingMinMaxWidth(computeReplacedLogicalWidthUsing(MainOrPreferredSize, style().logicalWidth()), shouldComputePreferred);
3003 }
3004 
3005 LayoutUnit RenderBox::computeReplacedLogicalWidthRespectingMinMaxWidth(LayoutUnit logicalWidth, ShouldComputePreferred shouldComputePreferred) const
3006 {
3007     auto&amp; logicalMinWidth = style().logicalMinWidth();
3008     auto&amp; logicalMaxWidth = style().logicalMaxWidth();
3009     bool useLogicalWidthForMinWidth = (shouldComputePreferred == ComputePreferred &amp;&amp; logicalMinWidth.isPercentOrCalculated()) || logicalMinWidth.isUndefined();
3010     bool useLogicalWidthForMaxWidth = (shouldComputePreferred == ComputePreferred &amp;&amp; logicalMaxWidth.isPercentOrCalculated()) || logicalMaxWidth.isUndefined();
3011     auto minLogicalWidth =  useLogicalWidthForMinWidth ? logicalWidth : computeReplacedLogicalWidthUsing(MinSize, logicalMinWidth);
3012     auto maxLogicalWidth =  useLogicalWidthForMaxWidth ? logicalWidth : computeReplacedLogicalWidthUsing(MaxSize, logicalMaxWidth);
3013     return std::max(minLogicalWidth, std::min(logicalWidth, maxLogicalWidth));
3014 }
3015 
3016 LayoutUnit RenderBox::computeReplacedLogicalWidthUsing(SizeType widthType, Length logicalWidth) const
3017 {
3018     ASSERT(widthType == MinSize || widthType == MainOrPreferredSize || !logicalWidth.isAuto());
3019     if (widthType == MinSize &amp;&amp; logicalWidth.isAuto())
3020         return adjustContentBoxLogicalWidthForBoxSizing(0);
3021 
3022     switch (logicalWidth.type()) {
3023         case Fixed:
3024             return adjustContentBoxLogicalWidthForBoxSizing(logicalWidth.value());
3025         case MinContent:
3026         case MaxContent: {
3027             // MinContent/MaxContent don&#39;t need the availableLogicalWidth argument.
3028             LayoutUnit availableLogicalWidth;
3029             return computeIntrinsicLogicalWidthUsing(logicalWidth, availableLogicalWidth, borderAndPaddingLogicalWidth()) - borderAndPaddingLogicalWidth();
3030         }
3031         case FitContent:
3032         case FillAvailable:
3033         case Percent:
3034         case Calculated: {
3035             // FIXME: containingBlockLogicalWidthForContent() is wrong if the replaced element&#39;s block-flow is perpendicular to the
3036             // containing block&#39;s block-flow.
3037             // https://bugs.webkit.org/show_bug.cgi?id=46496
3038             const LayoutUnit cw = isOutOfFlowPositioned() ? containingBlockLogicalWidthForPositioned(downcast&lt;RenderBoxModelObject&gt;(*container())) : containingBlockLogicalWidthForContent();
3039             Length containerLogicalWidth = containingBlock()-&gt;style().logicalWidth();
3040             // FIXME: Handle cases when containing block width is calculated or viewport percent.
3041             // https://bugs.webkit.org/show_bug.cgi?id=91071
3042             if (logicalWidth.isIntrinsic())
3043                 return computeIntrinsicLogicalWidthUsing(logicalWidth, cw, borderAndPaddingLogicalWidth()) - borderAndPaddingLogicalWidth();
3044             if (cw &gt; 0 || (!cw &amp;&amp; (containerLogicalWidth.isFixed() || containerLogicalWidth.isPercentOrCalculated())))
3045                 return adjustContentBoxLogicalWidthForBoxSizing(minimumValueForLength(logicalWidth, cw));
3046             return 0_lu;
3047         }
3048         case Intrinsic:
3049         case MinIntrinsic:
3050         case Auto:
3051         case Relative:
3052         case Undefined:
3053             return intrinsicLogicalWidth();
3054     }
3055 
3056     ASSERT_NOT_REACHED();
3057     return 0;
3058 }
3059 
3060 LayoutUnit RenderBox::computeReplacedLogicalHeight(Optional&lt;LayoutUnit&gt;) const
3061 {
3062     return computeReplacedLogicalHeightRespectingMinMaxHeight(computeReplacedLogicalHeightUsing(MainOrPreferredSize, style().logicalHeight()));
3063 }
3064 
3065 static bool allowMinMaxPercentagesInAutoHeightBlocksQuirk()
3066 {
3067 #if PLATFORM(MAC)
3068     return MacApplication::isIBooks();
3069 #elif PLATFORM(IOS_FAMILY)
3070     return IOSApplication::isIBooks();
3071 #endif
3072     return false;
3073 }
3074 
3075 bool RenderBox::replacedMinMaxLogicalHeightComputesAsNone(SizeType sizeType) const
3076 {
3077     ASSERT(sizeType == MinSize || sizeType == MaxSize);
3078 
3079     auto logicalHeight = sizeType == MinSize ? style().logicalMinHeight() : style().logicalMaxHeight();
3080     auto initialLogicalHeight = sizeType == MinSize ? RenderStyle::initialMinSize() : RenderStyle::initialMaxSize();
3081 
3082     if (logicalHeight == initialLogicalHeight)
3083         return true;
3084 
3085     // Make sure % min-height and % max-height resolve to none if the containing block has auto height.
3086     // Note that the &quot;height&quot; case for replaced elements was handled by hasReplacedLogicalHeight, which is why
3087     // min and max-height are the only ones handled here.
3088     // FIXME: For now we put in a quirk for iBooks until we can move them to viewport units.
3089     if (auto* cb = containingBlockForAutoHeightDetection(logicalHeight))
3090         return allowMinMaxPercentagesInAutoHeightBlocksQuirk() ? false : cb-&gt;hasAutoHeightOrContainingBlockWithAutoHeight();
3091 
3092     return false;
3093 }
3094 
3095 LayoutUnit RenderBox::computeReplacedLogicalHeightRespectingMinMaxHeight(LayoutUnit logicalHeight) const
3096 {
3097     LayoutUnit minLogicalHeight;
3098     if (!replacedMinMaxLogicalHeightComputesAsNone(MinSize))
3099         minLogicalHeight = computeReplacedLogicalHeightUsing(MinSize, style().logicalMinHeight());
3100     LayoutUnit maxLogicalHeight = logicalHeight;
3101     if (!replacedMinMaxLogicalHeightComputesAsNone(MaxSize))
3102         maxLogicalHeight = computeReplacedLogicalHeightUsing(MaxSize, style().logicalMaxHeight());
3103     return std::max(minLogicalHeight, std::min(logicalHeight, maxLogicalHeight));
3104 }
3105 
3106 LayoutUnit RenderBox::computeReplacedLogicalHeightUsing(SizeType heightType, Length logicalHeight) const
3107 {
3108     ASSERT(heightType == MinSize || heightType == MainOrPreferredSize || !logicalHeight.isAuto());
3109     if (heightType == MinSize &amp;&amp; logicalHeight.isAuto())
3110         return adjustContentBoxLogicalHeightForBoxSizing(Optional&lt;LayoutUnit&gt;(0));
3111 
3112     switch (logicalHeight.type()) {
3113         case Fixed:
3114             return adjustContentBoxLogicalHeightForBoxSizing(LayoutUnit(logicalHeight.value()));
3115         case Percent:
3116         case Calculated:
3117         {
3118             auto* container = isOutOfFlowPositioned() ? this-&gt;container() : containingBlock();
3119             while (container &amp;&amp; container-&gt;isAnonymous()) {
3120                 // Stop at rendering context root.
3121                 if (is&lt;RenderView&gt;(*container))
3122                     break;
3123                 container = container-&gt;containingBlock();
3124             }
3125             Optional&lt;LayoutUnit&gt; stretchedHeight;
3126             if (is&lt;RenderBlock&gt;(container)) {
3127                 auto* block = downcast&lt;RenderBlock&gt;(container);
3128                 block-&gt;addPercentHeightDescendant(*const_cast&lt;RenderBox*&gt;(this));
3129                 if (block-&gt;isFlexItem())
3130                     stretchedHeight = downcast&lt;RenderFlexibleBox&gt;(block-&gt;parent())-&gt;childLogicalHeightForPercentageResolution(*block);
3131                 else if (block-&gt;isGridItem() &amp;&amp; block-&gt;hasOverrideContentLogicalHeight())
3132                     stretchedHeight = block-&gt;overrideContentLogicalHeight();
3133             }
3134 
3135             // FIXME: This calculation is not patched for block-flow yet.
3136             // https://bugs.webkit.org/show_bug.cgi?id=46500
3137             if (container-&gt;isOutOfFlowPositioned()
3138                 &amp;&amp; container-&gt;style().height().isAuto()
3139                 &amp;&amp; !(container-&gt;style().top().isAuto() || container-&gt;style().bottom().isAuto())) {
3140                 ASSERT_WITH_SECURITY_IMPLICATION(container-&gt;isRenderBlock());
3141                 auto&amp; block = downcast&lt;RenderBlock&gt;(*container);
3142                 auto computedValues = block.computeLogicalHeight(block.logicalHeight(), 0);
3143                 LayoutUnit newContentHeight = computedValues.m_extent - block.borderAndPaddingLogicalHeight() - block.scrollbarLogicalHeight();
3144                 return adjustContentBoxLogicalHeightForBoxSizing(valueForLength(logicalHeight, newContentHeight));
3145             }
3146 
3147             // FIXME: availableLogicalHeight() is wrong if the replaced element&#39;s block-flow is perpendicular to the
3148             // containing block&#39;s block-flow.
3149             // https://bugs.webkit.org/show_bug.cgi?id=46496
3150             LayoutUnit availableHeight;
3151             if (isOutOfFlowPositioned())
3152                 availableHeight = containingBlockLogicalHeightForPositioned(downcast&lt;RenderBoxModelObject&gt;(*container));
3153             else if (stretchedHeight)
3154                 availableHeight = stretchedHeight.value();
3155             else {
3156                 availableHeight = containingBlockLogicalHeightForContent(IncludeMarginBorderPadding);
3157                 // It is necessary to use the border-box to match WinIE&#39;s broken
3158                 // box model.  This is essential for sizing inside
3159                 // table cells using percentage heights.
3160                 // FIXME: This needs to be made block-flow-aware.  If the cell and image are perpendicular block-flows, this isn&#39;t right.
3161                 // https://bugs.webkit.org/show_bug.cgi?id=46997
3162                 while (container &amp;&amp; !is&lt;RenderView&gt;(*container)
3163                     &amp;&amp; (container-&gt;style().logicalHeight().isAuto() || container-&gt;style().logicalHeight().isPercentOrCalculated())) {
3164                     if (container-&gt;isTableCell()) {
3165                         // Don&#39;t let table cells squeeze percent-height replaced elements
3166                         // &lt;http://bugs.webkit.org/show_bug.cgi?id=15359&gt;
3167                         availableHeight = std::max(availableHeight, intrinsicLogicalHeight());
3168                         return valueForLength(logicalHeight, availableHeight - borderAndPaddingLogicalHeight());
3169                     }
3170                     downcast&lt;RenderBlock&gt;(*container).addPercentHeightDescendant(const_cast&lt;RenderBox&amp;&gt;(*this));
3171                     container = container-&gt;containingBlock();
3172                 }
3173             }
3174             return adjustContentBoxLogicalHeightForBoxSizing(valueForLength(logicalHeight, availableHeight));
3175         }
3176         case MinContent:
3177         case MaxContent:
3178         case FitContent:
3179         case FillAvailable:
3180             return adjustContentBoxLogicalHeightForBoxSizing(computeIntrinsicLogicalContentHeightUsing(logicalHeight, intrinsicLogicalHeight(), borderAndPaddingLogicalHeight()));
3181         default:
3182             return intrinsicLogicalHeight();
3183     }
3184 }
3185 
3186 LayoutUnit RenderBox::availableLogicalHeight(AvailableLogicalHeightType heightType) const
3187 {
3188     return constrainLogicalHeightByMinMax(availableLogicalHeightUsing(style().logicalHeight(), heightType), WTF::nullopt);
3189 }
3190 
3191 LayoutUnit RenderBox::availableLogicalHeightUsing(const Length&amp; h, AvailableLogicalHeightType heightType) const
3192 {
3193     // We need to stop here, since we don&#39;t want to increase the height of the table
3194     // artificially.  We&#39;re going to rely on this cell getting expanded to some new
3195     // height, and then when we lay out again we&#39;ll use the calculation below.
3196     if (isTableCell() &amp;&amp; (h.isAuto() || h.isPercentOrCalculated())) {
3197         if (hasOverrideContentLogicalHeight())
3198             return overrideContentLogicalHeight();
3199         return logicalHeight() - borderAndPaddingLogicalHeight();
3200     }
3201 
3202     if (isFlexItem()) {
3203         auto&amp; flexBox = downcast&lt;RenderFlexibleBox&gt;(*parent());
3204         auto stretchedHeight = flexBox.childLogicalHeightForPercentageResolution(*this);
3205         if (stretchedHeight)
3206             return stretchedHeight.value();
3207     }
3208 
3209     if (h.isPercentOrCalculated() &amp;&amp; isOutOfFlowPositioned() &amp;&amp; !isRenderFragmentedFlow()) {
3210         // FIXME: This is wrong if the containingBlock has a perpendicular writing mode.
3211         LayoutUnit availableHeight = containingBlockLogicalHeightForPositioned(*containingBlock());
3212         return adjustContentBoxLogicalHeightForBoxSizing(valueForLength(h, availableHeight));
3213     }
3214 
3215     if (Optional&lt;LayoutUnit&gt; heightIncludingScrollbar = computeContentAndScrollbarLogicalHeightUsing(MainOrPreferredSize, h, WTF::nullopt))
3216         return std::max&lt;LayoutUnit&gt;(0, adjustContentBoxLogicalHeightForBoxSizing(heightIncludingScrollbar) - scrollbarLogicalHeight());
3217 
3218     // FIXME: Check logicalTop/logicalBottom here to correctly handle vertical writing-mode.
3219     // https://bugs.webkit.org/show_bug.cgi?id=46500
3220     if (is&lt;RenderBlock&gt;(*this) &amp;&amp; isOutOfFlowPositioned() &amp;&amp; style().height().isAuto() &amp;&amp; !(style().top().isAuto() || style().bottom().isAuto())) {
3221         RenderBlock&amp; block = const_cast&lt;RenderBlock&amp;&gt;(downcast&lt;RenderBlock&gt;(*this));
3222         auto computedValues = block.computeLogicalHeight(block.logicalHeight(), 0);
3223         return computedValues.m_extent - block.borderAndPaddingLogicalHeight() - block.scrollbarLogicalHeight();
3224     }
3225 
3226     // FIXME: This is wrong if the containingBlock has a perpendicular writing mode.
3227     LayoutUnit availableHeight = containingBlockLogicalHeightForContent(heightType);
3228     if (heightType == ExcludeMarginBorderPadding) {
3229         // FIXME: Margin collapsing hasn&#39;t happened yet, so this incorrectly removes collapsed margins.
3230         availableHeight -= marginBefore() + marginAfter() + borderAndPaddingLogicalHeight();
3231     }
3232     return availableHeight;
3233 }
3234 
3235 void RenderBox::computeBlockDirectionMargins(const RenderBlock&amp; containingBlock, LayoutUnit&amp; marginBefore, LayoutUnit&amp; marginAfter) const
3236 {
3237     if (isTableCell()) {
3238         // FIXME: Not right if we allow cells to have different directionality than the table.  If we do allow this, though,
3239         // we may just do it with an extra anonymous block inside the cell.
3240         marginBefore = 0;
3241         marginAfter = 0;
3242         return;
3243     }
3244 
3245     // Margins are calculated with respect to the logical width of
3246     // the containing block (8.3)
3247     LayoutUnit cw = containingBlockLogicalWidthForContent();
3248     const RenderStyle&amp; containingBlockStyle = containingBlock.style();
3249     marginBefore = minimumValueForLength(style().marginBeforeUsing(&amp;containingBlockStyle), cw);
3250     marginAfter = minimumValueForLength(style().marginAfterUsing(&amp;containingBlockStyle), cw);
3251 }
3252 
3253 void RenderBox::computeAndSetBlockDirectionMargins(const RenderBlock&amp; containingBlock)
3254 {
3255     LayoutUnit marginBefore;
3256     LayoutUnit marginAfter;
3257     computeBlockDirectionMargins(containingBlock, marginBefore, marginAfter);
3258     containingBlock.setMarginBeforeForChild(*this, marginBefore);
3259     containingBlock.setMarginAfterForChild(*this, marginAfter);
3260 }
3261 
3262 LayoutUnit RenderBox::containingBlockLogicalWidthForPositioned(const RenderBoxModelObject&amp; containingBlock, RenderFragmentContainer* fragment, bool checkForPerpendicularWritingMode) const
3263 {
3264     if (checkForPerpendicularWritingMode &amp;&amp; containingBlock.isHorizontalWritingMode() != isHorizontalWritingMode())
3265         return containingBlockLogicalHeightForPositioned(containingBlock, false);
3266 
3267     if (hasOverrideContainingBlockContentLogicalWidth()) {
3268         if (auto overrideLogicalWidth = overrideContainingBlockContentLogicalWidth())
3269             return overrideLogicalWidth.value();
3270     }
3271 
3272     if (is&lt;RenderBox&gt;(containingBlock)) {
3273         bool isFixedPosition = isFixedPositioned();
3274 
3275         RenderFragmentedFlow* fragmentedFlow = enclosingFragmentedFlow();
3276         if (!fragmentedFlow) {
3277             if (isFixedPosition &amp;&amp; is&lt;RenderView&gt;(containingBlock))
3278                 return downcast&lt;RenderView&gt;(containingBlock).clientLogicalWidthForFixedPosition();
3279 
3280             return downcast&lt;RenderBox&gt;(containingBlock).clientLogicalWidth();
3281         }
3282 
3283         if (!is&lt;RenderBlock&gt;(containingBlock))
3284             return downcast&lt;RenderBox&gt;(containingBlock).clientLogicalWidth();
3285 
3286         const RenderBlock&amp; cb = downcast&lt;RenderBlock&gt;(containingBlock);
3287         RenderBoxFragmentInfo* boxInfo = nullptr;
3288         if (!fragment) {
3289             if (is&lt;RenderFragmentedFlow&gt;(containingBlock) &amp;&amp; !checkForPerpendicularWritingMode)
3290                 return downcast&lt;RenderFragmentedFlow&gt;(containingBlock).contentLogicalWidthOfFirstFragment();
3291             if (isWritingModeRoot()) {
3292                 LayoutUnit cbPageOffset = cb.offsetFromLogicalTopOfFirstPage();
3293                 RenderFragmentContainer* cbFragment = cb.fragmentAtBlockOffset(cbPageOffset);
3294                 if (cbFragment)
3295                     boxInfo = cb.renderBoxFragmentInfo(cbFragment);
3296             }
3297         } else if (fragmentedFlow-&gt;isHorizontalWritingMode() == containingBlock.isHorizontalWritingMode()) {
3298             RenderFragmentContainer* containingBlockFragment = cb.clampToStartAndEndFragments(fragment);
3299             boxInfo = cb.renderBoxFragmentInfo(containingBlockFragment);
3300         }
3301         return (boxInfo) ? std::max&lt;LayoutUnit&gt;(0, cb.clientLogicalWidth() - (cb.logicalWidth() - boxInfo-&gt;logicalWidth())) : cb.clientLogicalWidth();
3302     }
3303 
3304     ASSERT(containingBlock.isInFlowPositioned());
3305 
3306     const auto&amp; flow = downcast&lt;RenderInline&gt;(containingBlock);
3307     InlineFlowBox* first = flow.firstLineBox();
3308     InlineFlowBox* last = flow.lastLineBox();
3309 
3310     // If the containing block is empty, return a width of 0.
3311     if (!first || !last)
3312         return 0;
3313 
3314     LayoutUnit fromLeft;
3315     LayoutUnit fromRight;
3316     if (containingBlock.style().isLeftToRightDirection()) {
3317         fromLeft = first-&gt;logicalLeft() + first-&gt;borderLogicalLeft();
3318         fromRight = last-&gt;logicalLeft() + last-&gt;logicalWidth() - last-&gt;borderLogicalRight();
3319     } else {
3320         fromRight = first-&gt;logicalLeft() + first-&gt;logicalWidth() - first-&gt;borderLogicalRight();
3321         fromLeft = last-&gt;logicalLeft() + last-&gt;borderLogicalLeft();
3322     }
3323 
3324     return std::max&lt;LayoutUnit&gt;(0, fromRight - fromLeft);
3325 }
3326 
3327 LayoutUnit RenderBox::containingBlockLogicalHeightForPositioned(const RenderBoxModelObject&amp; containingBlock, bool checkForPerpendicularWritingMode) const
3328 {
3329     if (checkForPerpendicularWritingMode &amp;&amp; containingBlock.isHorizontalWritingMode() != isHorizontalWritingMode())
3330         return containingBlockLogicalWidthForPositioned(containingBlock, nullptr, false);
3331 
3332     if (hasOverrideContainingBlockContentLogicalHeight()) {
3333         if (auto overrideLogicalHeight = overrideContainingBlockContentLogicalHeight())
3334             return overrideLogicalHeight.value();
3335     }
3336 
3337     if (containingBlock.isBox()) {
3338         bool isFixedPosition = isFixedPositioned();
3339 
3340         if (isFixedPosition &amp;&amp; is&lt;RenderView&gt;(containingBlock))
3341             return downcast&lt;RenderView&gt;(containingBlock).clientLogicalHeightForFixedPosition();
3342 
3343         const RenderBlock&amp; cb = is&lt;RenderBlock&gt;(containingBlock) ? downcast&lt;RenderBlock&gt;(containingBlock) : *containingBlock.containingBlock();
3344         LayoutUnit result = cb.clientLogicalHeight();
3345         RenderFragmentedFlow* fragmentedFlow = enclosingFragmentedFlow();
3346         if (fragmentedFlow &amp;&amp; is&lt;RenderFragmentedFlow&gt;(containingBlock) &amp;&amp; fragmentedFlow-&gt;isHorizontalWritingMode() == containingBlock.isHorizontalWritingMode())
3347             return downcast&lt;RenderFragmentedFlow&gt;(containingBlock).contentLogicalHeightOfFirstFragment();
3348         return result;
3349     }
3350 
3351     ASSERT(containingBlock.isInFlowPositioned());
3352 
3353     const auto&amp; flow = downcast&lt;RenderInline&gt;(containingBlock);
3354     InlineFlowBox* first = flow.firstLineBox();
3355     InlineFlowBox* last = flow.lastLineBox();
3356 
3357     // If the containing block is empty, return a height of 0.
3358     if (!first || !last)
3359         return 0;
3360 
3361     LayoutUnit heightResult;
3362     LayoutRect boundingBox = flow.linesBoundingBox();
3363     if (containingBlock.isHorizontalWritingMode())
3364         heightResult = boundingBox.height();
3365     else
3366         heightResult = boundingBox.width();
3367     heightResult -= (containingBlock.borderBefore() + containingBlock.borderAfter());
3368     return heightResult;
3369 }
3370 
3371 static void computeInlineStaticDistance(Length&amp; logicalLeft, Length&amp; logicalRight, const RenderBox* child, const RenderBoxModelObject&amp; containerBlock, LayoutUnit containerLogicalWidth, RenderFragmentContainer* fragment)
3372 {
3373     if (!logicalLeft.isAuto() || !logicalRight.isAuto())
3374         return;
3375 
3376     RenderObject* parent = child-&gt;parent();
3377     TextDirection parentDirection = parent-&gt;style().direction();
3378 
3379     // This method is using enclosingBox() which is wrong for absolutely
3380     // positioned grid items, as they rely on the grid area. So for grid items if
3381     // both &quot;left&quot; and &quot;right&quot; properties are &quot;auto&quot;, we can consider that one of
3382     // them (depending on the direction) is simply &quot;0&quot;.
3383     if (parent-&gt;isRenderGrid() &amp;&amp; parent == child-&gt;containingBlock()) {
3384         if (parentDirection == TextDirection::LTR)
3385             logicalLeft.setValue(Fixed, 0);
3386         else
3387             logicalRight.setValue(Fixed, 0);
3388         return;
3389     }
3390 
3391     // FIXME: The static distance computation has not been patched for mixed writing modes yet.
3392     if (parentDirection == TextDirection::LTR) {
3393         LayoutUnit staticPosition = child-&gt;layer()-&gt;staticInlinePosition() - containerBlock.borderLogicalLeft();
3394         for (auto* current = parent; current &amp;&amp; current != &amp;containerBlock; current = current-&gt;container()) {
3395             if (!is&lt;RenderBox&gt;(*current))
3396                 continue;
3397             const auto&amp; renderBox = downcast&lt;RenderBox&gt;(*current);
3398             staticPosition += renderBox.logicalLeft();
3399             if (renderBox.isInFlowPositioned())
3400                 staticPosition += renderBox.isHorizontalWritingMode() ? renderBox.offsetForInFlowPosition().width() : renderBox.offsetForInFlowPosition().height();
3401             if (fragment &amp;&amp; is&lt;RenderBlock&gt;(*current)) {
3402                 const RenderBlock&amp; currentBlock = downcast&lt;RenderBlock&gt;(*current);
3403                 fragment = currentBlock.clampToStartAndEndFragments(fragment);
3404                 RenderBoxFragmentInfo* boxInfo = currentBlock.renderBoxFragmentInfo(fragment);
3405                 if (boxInfo)
3406                     staticPosition += boxInfo-&gt;logicalLeft();
3407             }
3408         }
3409         logicalLeft.setValue(Fixed, staticPosition);
3410     } else {
3411         LayoutUnit staticPosition = child-&gt;layer()-&gt;staticInlinePosition() + containerLogicalWidth + containerBlock.borderLogicalLeft();
3412         auto&amp; enclosingBox = parent-&gt;enclosingBox();
3413         if (&amp;enclosingBox != &amp;containerBlock &amp;&amp; containerBlock.isDescendantOf(&amp;enclosingBox)) {
3414             logicalRight.setValue(Fixed, staticPosition);
3415             return;
3416         }
3417 
3418         staticPosition -= enclosingBox.logicalWidth();
3419         for (const RenderElement* current = &amp;enclosingBox; current; current = current-&gt;container()) {
3420             if (!is&lt;RenderBox&gt;(*current))
3421                 continue;
3422 
3423             if (current != &amp;containerBlock) {
3424                 auto&amp; renderBox = downcast&lt;RenderBox&gt;(*current);
3425                 staticPosition -= renderBox.logicalLeft();
3426                 if (renderBox.isInFlowPositioned())
3427                     staticPosition -= renderBox.isHorizontalWritingMode() ? renderBox.offsetForInFlowPosition().width() : renderBox.offsetForInFlowPosition().height();
3428             }
3429             if (fragment &amp;&amp; is&lt;RenderBlock&gt;(*current)) {
3430                 auto&amp; currentBlock = downcast&lt;RenderBlock&gt;(*current);
3431                 fragment = currentBlock.clampToStartAndEndFragments(fragment);
3432                 RenderBoxFragmentInfo* boxInfo = currentBlock.renderBoxFragmentInfo(fragment);
3433                 if (boxInfo) {
3434                     if (current != &amp;containerBlock)
3435                         staticPosition -= currentBlock.logicalWidth() - (boxInfo-&gt;logicalLeft() + boxInfo-&gt;logicalWidth());
3436                     if (current == &amp;enclosingBox)
3437                         staticPosition += enclosingBox.logicalWidth() - boxInfo-&gt;logicalWidth();
3438                 }
3439             }
3440             if (current == &amp;containerBlock)
3441                 break;
3442         }
3443         logicalRight.setValue(Fixed, staticPosition);
3444     }
3445 }
3446 
3447 void RenderBox::computePositionedLogicalWidth(LogicalExtentComputedValues&amp; computedValues, RenderFragmentContainer* fragment) const
3448 {
3449     if (isReplaced()) {
3450         // FIXME: Positioned replaced elements inside a flow thread are not working properly
3451         // with variable width fragments (see https://bugs.webkit.org/show_bug.cgi?id=69896 ).
3452         computePositionedLogicalWidthReplaced(computedValues);
3453         return;
3454     }
3455 
3456     // QUESTIONS
3457     // FIXME 1: Should we still deal with these the cases of &#39;left&#39; or &#39;right&#39; having
3458     // the type &#39;static&#39; in determining whether to calculate the static distance?
3459     // NOTE: &#39;static&#39; is not a legal value for &#39;left&#39; or &#39;right&#39; as of CSS 2.1.
3460 
3461     // FIXME 2: Can perhaps optimize out cases when max-width/min-width are greater
3462     // than or less than the computed width().  Be careful of box-sizing and
3463     // percentage issues.
3464 
3465     // The following is based off of the W3C Working Draft from April 11, 2006 of
3466     // CSS 2.1: Section 10.3.7 &quot;Absolutely positioned, non-replaced elements&quot;
3467     // &lt;http://www.w3.org/TR/CSS21/visudet.html#abs-non-replaced-width&gt;
3468     // (block-style-comments in this function and in computePositionedLogicalWidthUsing()
3469     // correspond to text from the spec)
3470 
3471 
3472     // We don&#39;t use containingBlock(), since we may be positioned by an enclosing
3473     // relative positioned inline.
3474     const RenderBoxModelObject&amp; containerBlock = downcast&lt;RenderBoxModelObject&gt;(*container());
3475 
3476     const LayoutUnit containerLogicalWidth = containingBlockLogicalWidthForPositioned(containerBlock, fragment);
3477 
3478     // Use the container block&#39;s direction except when calculating the static distance
3479     // This conforms with the reference results for abspos-replaced-width-margin-000.htm
3480     // of the CSS 2.1 test suite
3481     TextDirection containerDirection = containerBlock.style().direction();
3482 
3483     bool isHorizontal = isHorizontalWritingMode();
3484     const LayoutUnit bordersPlusPadding = borderAndPaddingLogicalWidth();
3485     const Length marginLogicalLeft = isHorizontal ? style().marginLeft() : style().marginTop();
3486     const Length marginLogicalRight = isHorizontal ? style().marginRight() : style().marginBottom();
3487 
3488     Length logicalLeftLength = style().logicalLeft();
3489     Length logicalRightLength = style().logicalRight();
3490 
3491     /*---------------------------------------------------------------------------*\
3492      * For the purposes of this section and the next, the term &quot;static position&quot;
3493      * (of an element) refers, roughly, to the position an element would have had
3494      * in the normal flow. More precisely:
3495      *
3496      * * The static position for &#39;left&#39; is the distance from the left edge of the
3497      *   containing block to the left margin edge of a hypothetical box that would
3498      *   have been the first box of the element if its &#39;position&#39; property had
3499      *   been &#39;static&#39; and &#39;float&#39; had been &#39;none&#39;. The value is negative if the
3500      *   hypothetical box is to the left of the containing block.
3501      * * The static position for &#39;right&#39; is the distance from the right edge of the
3502      *   containing block to the right margin edge of the same hypothetical box as
3503      *   above. The value is positive if the hypothetical box is to the left of the
3504      *   containing block&#39;s edge.
3505      *
3506      * But rather than actually calculating the dimensions of that hypothetical box,
3507      * user agents are free to make a guess at its probable position.
3508      *
3509      * For the purposes of calculating the static position, the containing block of
3510      * fixed positioned elements is the initial containing block instead of the
3511      * viewport, and all scrollable boxes should be assumed to be scrolled to their
3512      * origin.
3513     \*---------------------------------------------------------------------------*/
3514 
3515     // see FIXME 1
3516     // Calculate the static distance if needed.
3517     computeInlineStaticDistance(logicalLeftLength, logicalRightLength, this, containerBlock, containerLogicalWidth, fragment);
3518 
3519     // Calculate constraint equation values for &#39;width&#39; case.
3520     computePositionedLogicalWidthUsing(MainOrPreferredSize, style().logicalWidth(), containerBlock, containerDirection,
3521                                        containerLogicalWidth, bordersPlusPadding,
3522                                        logicalLeftLength, logicalRightLength, marginLogicalLeft, marginLogicalRight,
3523                                        computedValues);
3524 
3525     // Calculate constraint equation values for &#39;max-width&#39; case.
3526     if (!style().logicalMaxWidth().isUndefined()) {
3527         LogicalExtentComputedValues maxValues;
3528 
3529         computePositionedLogicalWidthUsing(MaxSize, style().logicalMaxWidth(), containerBlock, containerDirection,
3530                                            containerLogicalWidth, bordersPlusPadding,
3531                                            logicalLeftLength, logicalRightLength, marginLogicalLeft, marginLogicalRight,
3532                                            maxValues);
3533 
3534         if (computedValues.m_extent &gt; maxValues.m_extent) {
3535             computedValues.m_extent = maxValues.m_extent;
3536             computedValues.m_position = maxValues.m_position;
3537             computedValues.m_margins.m_start = maxValues.m_margins.m_start;
3538             computedValues.m_margins.m_end = maxValues.m_margins.m_end;
3539         }
3540     }
3541 
3542     // Calculate constraint equation values for &#39;min-width&#39; case.
3543     if (!style().logicalMinWidth().isZero() || style().logicalMinWidth().isIntrinsic()) {
3544         LogicalExtentComputedValues minValues;
3545 
3546         computePositionedLogicalWidthUsing(MinSize, style().logicalMinWidth(), containerBlock, containerDirection,
3547                                            containerLogicalWidth, bordersPlusPadding,
3548                                            logicalLeftLength, logicalRightLength, marginLogicalLeft, marginLogicalRight,
3549                                            minValues);
3550 
3551         if (computedValues.m_extent &lt; minValues.m_extent) {
3552             computedValues.m_extent = minValues.m_extent;
3553             computedValues.m_position = minValues.m_position;
3554             computedValues.m_margins.m_start = minValues.m_margins.m_start;
3555             computedValues.m_margins.m_end = minValues.m_margins.m_end;
3556         }
3557     }
3558 
3559     computedValues.m_extent += bordersPlusPadding;
3560     if (is&lt;RenderBox&gt;(containerBlock)) {
3561         auto&amp; containingBox = downcast&lt;RenderBox&gt;(containerBlock);
3562         if (containingBox.shouldPlaceBlockDirectionScrollbarOnLeft())
3563             computedValues.m_position += containingBox.verticalScrollbarWidth();
3564     }
3565 
3566     // Adjust logicalLeft if we need to for the flipped version of our writing mode in fragments.
3567     // FIXME: Add support for other types of objects as containerBlock, not only RenderBlock.
3568     RenderFragmentedFlow* fragmentedFlow = enclosingFragmentedFlow();
3569     if (fragmentedFlow &amp;&amp; !fragment &amp;&amp; isWritingModeRoot() &amp;&amp; isHorizontalWritingMode() == containerBlock.isHorizontalWritingMode() &amp;&amp; is&lt;RenderBlock&gt;(containerBlock)) {
3570         ASSERT(containerBlock.canHaveBoxInfoInFragment());
3571         LayoutUnit logicalLeftPos = computedValues.m_position;
3572         const RenderBlock&amp; renderBlock = downcast&lt;RenderBlock&gt;(containerBlock);
3573         LayoutUnit cbPageOffset = renderBlock.offsetFromLogicalTopOfFirstPage();
3574         RenderFragmentContainer* cbFragment = renderBlock.fragmentAtBlockOffset(cbPageOffset);
3575         if (cbFragment) {
3576             RenderBoxFragmentInfo* boxInfo = renderBlock.renderBoxFragmentInfo(cbFragment);
3577             if (boxInfo) {
3578                 logicalLeftPos += boxInfo-&gt;logicalLeft();
3579                 computedValues.m_position = logicalLeftPos;
3580             }
3581         }
3582     }
3583 }
3584 
3585 static void computeLogicalLeftPositionedOffset(LayoutUnit&amp; logicalLeftPos, const RenderBox* child, LayoutUnit logicalWidthValue, const RenderBoxModelObject&amp; containerBlock, LayoutUnit containerLogicalWidth)
3586 {
3587     // Deal with differing writing modes here.  Our offset needs to be in the containing block&#39;s coordinate space. If the containing block is flipped
3588     // along this axis, then we need to flip the coordinate.  This can only happen if the containing block is both a flipped mode and perpendicular to us.
3589     if (containerBlock.isHorizontalWritingMode() != child-&gt;isHorizontalWritingMode() &amp;&amp; containerBlock.style().isFlippedBlocksWritingMode()) {
3590         logicalLeftPos = containerLogicalWidth - logicalWidthValue - logicalLeftPos;
3591         logicalLeftPos += (child-&gt;isHorizontalWritingMode() ? containerBlock.borderRight() : containerBlock.borderBottom());
3592     } else
3593         logicalLeftPos += (child-&gt;isHorizontalWritingMode() ? containerBlock.borderLeft() : containerBlock.borderTop());
3594 }
3595 
3596 void RenderBox::computePositionedLogicalWidthUsing(SizeType widthType, Length logicalWidth, const RenderBoxModelObject&amp; containerBlock, TextDirection containerDirection,
3597                                                    LayoutUnit containerLogicalWidth, LayoutUnit bordersPlusPadding,
3598                                                    Length logicalLeft, Length logicalRight, Length marginLogicalLeft, Length marginLogicalRight,
3599                                                    LogicalExtentComputedValues&amp; computedValues) const
3600 {
3601     ASSERT(widthType == MinSize || widthType == MainOrPreferredSize || !logicalWidth.isAuto());
3602     if (widthType == MinSize &amp;&amp; logicalWidth.isAuto())
3603         logicalWidth = Length(0, Fixed);
3604     else if (logicalWidth.isIntrinsic())
3605         logicalWidth = Length(computeIntrinsicLogicalWidthUsing(logicalWidth, containerLogicalWidth, bordersPlusPadding) - bordersPlusPadding, Fixed);
3606 
3607     // &#39;left&#39; and &#39;right&#39; cannot both be &#39;auto&#39; because one would of been
3608     // converted to the static position already
3609     ASSERT(!(logicalLeft.isAuto() &amp;&amp; logicalRight.isAuto()));
3610 
3611     LayoutUnit logicalLeftValue;
3612 
3613     const LayoutUnit containerRelativeLogicalWidth = containingBlockLogicalWidthForPositioned(containerBlock, nullptr, false);
3614 
3615     bool logicalWidthIsAuto = logicalWidth.isIntrinsicOrAuto();
3616     bool logicalLeftIsAuto = logicalLeft.isAuto();
3617     bool logicalRightIsAuto = logicalRight.isAuto();
3618     LayoutUnit&amp; marginLogicalLeftValue = style().isLeftToRightDirection() ? computedValues.m_margins.m_start : computedValues.m_margins.m_end;
3619     LayoutUnit&amp; marginLogicalRightValue = style().isLeftToRightDirection() ? computedValues.m_margins.m_end : computedValues.m_margins.m_start;
3620 
3621     if (!logicalLeftIsAuto &amp;&amp; !logicalWidthIsAuto &amp;&amp; !logicalRightIsAuto) {
3622         /*-----------------------------------------------------------------------*\
3623          * If none of the three is &#39;auto&#39;: If both &#39;margin-left&#39; and &#39;margin-
3624          * right&#39; are &#39;auto&#39;, solve the equation under the extra constraint that
3625          * the two margins get equal values, unless this would make them negative,
3626          * in which case when direction of the containing block is &#39;ltr&#39; (&#39;rtl&#39;),
3627          * set &#39;margin-left&#39; (&#39;margin-right&#39;) to zero and solve for &#39;margin-right&#39;
3628          * (&#39;margin-left&#39;). If one of &#39;margin-left&#39; or &#39;margin-right&#39; is &#39;auto&#39;,
3629          * solve the equation for that value. If the values are over-constrained,
3630          * ignore the value for &#39;left&#39; (in case the &#39;direction&#39; property of the
3631          * containing block is &#39;rtl&#39;) or &#39;right&#39; (in case &#39;direction&#39; is &#39;ltr&#39;)
3632          * and solve for that value.
3633         \*-----------------------------------------------------------------------*/
3634         // NOTE:  It is not necessary to solve for &#39;right&#39; in the over constrained
3635         // case because the value is not used for any further calculations.
3636 
3637         logicalLeftValue = valueForLength(logicalLeft, containerLogicalWidth);
3638         computedValues.m_extent = adjustContentBoxLogicalWidthForBoxSizing(valueForLength(logicalWidth, containerLogicalWidth));
3639 
3640         const LayoutUnit availableSpace = containerLogicalWidth - (logicalLeftValue + computedValues.m_extent + valueForLength(logicalRight, containerLogicalWidth) + bordersPlusPadding);
3641 
3642         // Margins are now the only unknown
3643         if (marginLogicalLeft.isAuto() &amp;&amp; marginLogicalRight.isAuto()) {
3644             // Both margins auto, solve for equality
3645             if (availableSpace &gt;= 0) {
3646                 marginLogicalLeftValue = availableSpace / 2; // split the difference
3647                 marginLogicalRightValue = availableSpace - marginLogicalLeftValue; // account for odd valued differences
3648             } else {
3649                 // Use the containing block&#39;s direction rather than the parent block&#39;s
3650                 // per CSS 2.1 reference test abspos-non-replaced-width-margin-000.
3651                 if (containerDirection == TextDirection::LTR) {
3652                     marginLogicalLeftValue = 0;
3653                     marginLogicalRightValue = availableSpace; // will be negative
3654                 } else {
3655                     marginLogicalLeftValue = availableSpace; // will be negative
3656                     marginLogicalRightValue = 0;
3657                 }
3658             }
3659         } else if (marginLogicalLeft.isAuto()) {
3660             // Solve for left margin
3661             marginLogicalRightValue = valueForLength(marginLogicalRight, containerRelativeLogicalWidth);
3662             marginLogicalLeftValue = availableSpace - marginLogicalRightValue;
3663         } else if (marginLogicalRight.isAuto()) {
3664             // Solve for right margin
3665             marginLogicalLeftValue = valueForLength(marginLogicalLeft, containerRelativeLogicalWidth);
3666             marginLogicalRightValue = availableSpace - marginLogicalLeftValue;
3667         } else {
3668             // Over-constrained, solve for left if direction is RTL
3669             marginLogicalLeftValue = valueForLength(marginLogicalLeft, containerRelativeLogicalWidth);
3670             marginLogicalRightValue = valueForLength(marginLogicalRight, containerRelativeLogicalWidth);
3671 
3672             // Use the containing block&#39;s direction rather than the parent block&#39;s
3673             // per CSS 2.1 reference test abspos-non-replaced-width-margin-000.
3674             if (containerDirection == TextDirection::RTL)
3675                 logicalLeftValue = (availableSpace + logicalLeftValue) - marginLogicalLeftValue - marginLogicalRightValue;
3676         }
3677     } else {
3678         /*--------------------------------------------------------------------*\
3679          * Otherwise, set &#39;auto&#39; values for &#39;margin-left&#39; and &#39;margin-right&#39;
3680          * to 0, and pick the one of the following six rules that applies.
3681          *
3682          * 1. &#39;left&#39; and &#39;width&#39; are &#39;auto&#39; and &#39;right&#39; is not &#39;auto&#39;, then the
3683          *    width is shrink-to-fit. Then solve for &#39;left&#39;
3684          *
3685          *              OMIT RULE 2 AS IT SHOULD NEVER BE HIT
3686          * ------------------------------------------------------------------
3687          * 2. &#39;left&#39; and &#39;right&#39; are &#39;auto&#39; and &#39;width&#39; is not &#39;auto&#39;, then if
3688          *    the &#39;direction&#39; property of the containing block is &#39;ltr&#39; set
3689          *    &#39;left&#39; to the static position, otherwise set &#39;right&#39; to the
3690          *    static position. Then solve for &#39;left&#39; (if &#39;direction is &#39;rtl&#39;)
3691          *    or &#39;right&#39; (if &#39;direction&#39; is &#39;ltr&#39;).
3692          * ------------------------------------------------------------------
3693          *
3694          * 3. &#39;width&#39; and &#39;right&#39; are &#39;auto&#39; and &#39;left&#39; is not &#39;auto&#39;, then the
3695          *    width is shrink-to-fit . Then solve for &#39;right&#39;
3696          * 4. &#39;left&#39; is &#39;auto&#39;, &#39;width&#39; and &#39;right&#39; are not &#39;auto&#39;, then solve
3697          *    for &#39;left&#39;
3698          * 5. &#39;width&#39; is &#39;auto&#39;, &#39;left&#39; and &#39;right&#39; are not &#39;auto&#39;, then solve
3699          *    for &#39;width&#39;
3700          * 6. &#39;right&#39; is &#39;auto&#39;, &#39;left&#39; and &#39;width&#39; are not &#39;auto&#39;, then solve
3701          *    for &#39;right&#39;
3702          *
3703          * Calculation of the shrink-to-fit width is similar to calculating the
3704          * width of a table cell using the automatic table layout algorithm.
3705          * Roughly: calculate the preferred width by formatting the content
3706          * without breaking lines other than where explicit line breaks occur,
3707          * and also calculate the preferred minimum width, e.g., by trying all
3708          * possible line breaks. CSS 2.1 does not define the exact algorithm.
3709          * Thirdly, calculate the available width: this is found by solving
3710          * for &#39;width&#39; after setting &#39;left&#39; (in case 1) or &#39;right&#39; (in case 3)
3711          * to 0.
3712          *
3713          * Then the shrink-to-fit width is:
3714          * min(max(preferred minimum width, available width), preferred width).
3715         \*--------------------------------------------------------------------*/
3716         // NOTE: For rules 3 and 6 it is not necessary to solve for &#39;right&#39;
3717         // because the value is not used for any further calculations.
3718 
3719         // Calculate margins, &#39;auto&#39; margins are ignored.
3720         marginLogicalLeftValue = minimumValueForLength(marginLogicalLeft, containerRelativeLogicalWidth);
3721         marginLogicalRightValue = minimumValueForLength(marginLogicalRight, containerRelativeLogicalWidth);
3722 
3723         const LayoutUnit availableSpace = containerLogicalWidth - (marginLogicalLeftValue + marginLogicalRightValue + bordersPlusPadding);
3724 
3725         // FIXME: Is there a faster way to find the correct case?
3726         // Use rule/case that applies.
3727         if (logicalLeftIsAuto &amp;&amp; logicalWidthIsAuto &amp;&amp; !logicalRightIsAuto) {
3728             // RULE 1: (use shrink-to-fit for width, and solve of left)
3729             LayoutUnit logicalRightValue = valueForLength(logicalRight, containerLogicalWidth);
3730 
3731             // FIXME: would it be better to have shrink-to-fit in one step?
3732             LayoutUnit preferredWidth = maxPreferredLogicalWidth() - bordersPlusPadding;
3733             LayoutUnit preferredMinWidth = minPreferredLogicalWidth() - bordersPlusPadding;
3734             LayoutUnit availableWidth = availableSpace - logicalRightValue;
3735             computedValues.m_extent = std::min(std::max(preferredMinWidth, availableWidth), preferredWidth);
3736             logicalLeftValue = availableSpace - (computedValues.m_extent + logicalRightValue);
3737         } else if (!logicalLeftIsAuto &amp;&amp; logicalWidthIsAuto &amp;&amp; logicalRightIsAuto) {
3738             // RULE 3: (use shrink-to-fit for width, and no need solve of right)
3739             logicalLeftValue = valueForLength(logicalLeft, containerLogicalWidth);
3740 
3741             // FIXME: would it be better to have shrink-to-fit in one step?
3742             LayoutUnit preferredWidth = maxPreferredLogicalWidth() - bordersPlusPadding;
3743             LayoutUnit preferredMinWidth = minPreferredLogicalWidth() - bordersPlusPadding;
3744             LayoutUnit availableWidth = availableSpace - logicalLeftValue;
3745             computedValues.m_extent = std::min(std::max(preferredMinWidth, availableWidth), preferredWidth);
3746         } else if (logicalLeftIsAuto &amp;&amp; !logicalWidthIsAuto &amp;&amp; !logicalRightIsAuto) {
3747             // RULE 4: (solve for left)
3748             computedValues.m_extent = adjustContentBoxLogicalWidthForBoxSizing(valueForLength(logicalWidth, containerLogicalWidth));
3749             logicalLeftValue = availableSpace - (computedValues.m_extent + valueForLength(logicalRight, containerLogicalWidth));
3750         } else if (!logicalLeftIsAuto &amp;&amp; logicalWidthIsAuto &amp;&amp; !logicalRightIsAuto) {
3751             // RULE 5: (solve for width)
3752             logicalLeftValue = valueForLength(logicalLeft, containerLogicalWidth);
3753             computedValues.m_extent = availableSpace - (logicalLeftValue + valueForLength(logicalRight, containerLogicalWidth));
3754         } else if (!logicalLeftIsAuto &amp;&amp; !logicalWidthIsAuto &amp;&amp; logicalRightIsAuto) {
3755             // RULE 6: (no need solve for right)
3756             logicalLeftValue = valueForLength(logicalLeft, containerLogicalWidth);
3757             computedValues.m_extent = adjustContentBoxLogicalWidthForBoxSizing(valueForLength(logicalWidth, containerLogicalWidth));
3758         }
3759     }
3760 
3761     // Use computed values to calculate the horizontal position.
3762 
3763     // FIXME: This hack is needed to calculate the  logical left position for a &#39;rtl&#39; relatively
3764     // positioned, inline because right now, it is using the logical left position
3765     // of the first line box when really it should use the last line box.  When
3766     // this is fixed elsewhere, this block should be removed.
3767     if (is&lt;RenderInline&gt;(containerBlock) &amp;&amp; !containerBlock.style().isLeftToRightDirection()) {
3768         const auto&amp; flow = downcast&lt;RenderInline&gt;(containerBlock);
3769         InlineFlowBox* firstLine = flow.firstLineBox();
3770         InlineFlowBox* lastLine = flow.lastLineBox();
3771         if (firstLine &amp;&amp; lastLine &amp;&amp; firstLine != lastLine) {
3772             computedValues.m_position = logicalLeftValue + marginLogicalLeftValue + lastLine-&gt;borderLogicalLeft() + (lastLine-&gt;logicalLeft() - firstLine-&gt;logicalLeft());
3773             return;
3774         }
3775     }
3776 
3777     computedValues.m_position = logicalLeftValue + marginLogicalLeftValue;
3778     computeLogicalLeftPositionedOffset(computedValues.m_position, this, computedValues.m_extent, containerBlock, containerLogicalWidth);
3779 }
3780 
3781 static void computeBlockStaticDistance(Length&amp; logicalTop, Length&amp; logicalBottom, const RenderBox* child, const RenderBoxModelObject&amp; containerBlock)
3782 {
3783     if (!logicalTop.isAuto() || !logicalBottom.isAuto())
3784         return;
3785 
3786     // FIXME: The static distance computation has not been patched for mixed writing modes.
3787     LayoutUnit staticLogicalTop = child-&gt;layer()-&gt;staticBlockPosition() - containerBlock.borderBefore();
3788     for (RenderElement* container = child-&gt;parent(); container &amp;&amp; container != &amp;containerBlock; container = container-&gt;container()) {
3789         if (!is&lt;RenderBox&gt;(*container))
3790             continue;
3791         const auto&amp; renderBox = downcast&lt;RenderBox&gt;(*container);
3792         if (!is&lt;RenderTableRow&gt;(renderBox))
3793             staticLogicalTop += renderBox.logicalTop();
3794         if (renderBox.isInFlowPositioned())
3795             staticLogicalTop += renderBox.isHorizontalWritingMode() ? renderBox.offsetForInFlowPosition().height() : renderBox.offsetForInFlowPosition().width();
3796     }
3797     logicalTop.setValue(Fixed, staticLogicalTop);
3798 }
3799 
3800 void RenderBox::computePositionedLogicalHeight(LogicalExtentComputedValues&amp; computedValues) const
3801 {
3802     if (isReplaced()) {
3803         computePositionedLogicalHeightReplaced(computedValues);
3804         return;
3805     }
3806 
3807     // The following is based off of the W3C Working Draft from April 11, 2006 of
3808     // CSS 2.1: Section 10.6.4 &quot;Absolutely positioned, non-replaced elements&quot;
3809     // &lt;http://www.w3.org/TR/2005/WD-CSS21-20050613/visudet.html#abs-non-replaced-height&gt;
3810     // (block-style-comments in this function and in computePositionedLogicalHeightUsing()
3811     // correspond to text from the spec)
3812 
3813 
3814     // We don&#39;t use containingBlock(), since we may be positioned by an enclosing relpositioned inline.
3815     const RenderBoxModelObject&amp; containerBlock = downcast&lt;RenderBoxModelObject&gt;(*container());
3816 
3817     const LayoutUnit containerLogicalHeight = containingBlockLogicalHeightForPositioned(containerBlock);
3818 
3819     const RenderStyle&amp; styleToUse = style();
3820     const LayoutUnit bordersPlusPadding = borderAndPaddingLogicalHeight();
3821     const Length marginBefore = styleToUse.marginBefore();
3822     const Length marginAfter = styleToUse.marginAfter();
3823     Length logicalTopLength = styleToUse.logicalTop();
3824     Length logicalBottomLength = styleToUse.logicalBottom();
3825 
3826     /*---------------------------------------------------------------------------*\
3827      * For the purposes of this section and the next, the term &quot;static position&quot;
3828      * (of an element) refers, roughly, to the position an element would have had
3829      * in the normal flow. More precisely, the static position for &#39;top&#39; is the
3830      * distance from the top edge of the containing block to the top margin edge
3831      * of a hypothetical box that would have been the first box of the element if
3832      * its &#39;position&#39; property had been &#39;static&#39; and &#39;float&#39; had been &#39;none&#39;. The
3833      * value is negative if the hypothetical box is above the containing block.
3834      *
3835      * But rather than actually calculating the dimensions of that hypothetical
3836      * box, user agents are free to make a guess at its probable position.
3837      *
3838      * For the purposes of calculating the static position, the containing block
3839      * of fixed positioned elements is the initial containing block instead of
3840      * the viewport.
3841     \*---------------------------------------------------------------------------*/
3842 
3843     // see FIXME 1
3844     // Calculate the static distance if needed.
3845     computeBlockStaticDistance(logicalTopLength, logicalBottomLength, this, containerBlock);
3846 
3847     // Calculate constraint equation values for &#39;height&#39; case.
3848     LayoutUnit logicalHeight = computedValues.m_extent;
3849     computePositionedLogicalHeightUsing(MainOrPreferredSize, styleToUse.logicalHeight(), containerBlock, containerLogicalHeight, bordersPlusPadding, logicalHeight,
3850                                         logicalTopLength, logicalBottomLength, marginBefore, marginAfter,
3851                                         computedValues);
3852 
3853     // Avoid doing any work in the common case (where the values of min-height and max-height are their defaults).
3854     // see FIXME 2
3855 
3856     // Calculate constraint equation values for &#39;max-height&#39; case.
3857     if (!styleToUse.logicalMaxHeight().isUndefined()) {
3858         LogicalExtentComputedValues maxValues;
3859 
3860         computePositionedLogicalHeightUsing(MaxSize, styleToUse.logicalMaxHeight(), containerBlock, containerLogicalHeight, bordersPlusPadding, logicalHeight,
3861                                             logicalTopLength, logicalBottomLength, marginBefore, marginAfter,
3862                                             maxValues);
3863 
3864         if (computedValues.m_extent &gt; maxValues.m_extent) {
3865             computedValues.m_extent = maxValues.m_extent;
3866             computedValues.m_position = maxValues.m_position;
3867             computedValues.m_margins.m_before = maxValues.m_margins.m_before;
3868             computedValues.m_margins.m_after = maxValues.m_margins.m_after;
3869         }
3870     }
3871 
3872     // Calculate constraint equation values for &#39;min-height&#39; case.
3873     if (!styleToUse.logicalMinHeight().isZero() || styleToUse.logicalMinHeight().isIntrinsic()) {
3874         LogicalExtentComputedValues minValues;
3875 
3876         computePositionedLogicalHeightUsing(MinSize, styleToUse.logicalMinHeight(), containerBlock, containerLogicalHeight, bordersPlusPadding, logicalHeight,
3877                                             logicalTopLength, logicalBottomLength, marginBefore, marginAfter,
3878                                             minValues);
3879 
3880         if (computedValues.m_extent &lt; minValues.m_extent) {
3881             computedValues.m_extent = minValues.m_extent;
3882             computedValues.m_position = minValues.m_position;
3883             computedValues.m_margins.m_before = minValues.m_margins.m_before;
3884             computedValues.m_margins.m_after = minValues.m_margins.m_after;
3885         }
3886     }
3887 
3888     // Set final height value.
3889     computedValues.m_extent += bordersPlusPadding;
3890 
3891     // Adjust logicalTop if we need to for perpendicular writing modes in fragments.
3892     // FIXME: Add support for other types of objects as containerBlock, not only RenderBlock.
3893     RenderFragmentedFlow* fragmentedFlow = enclosingFragmentedFlow();
3894     if (fragmentedFlow &amp;&amp; isHorizontalWritingMode() != containerBlock.isHorizontalWritingMode() &amp;&amp; is&lt;RenderBlock&gt;(containerBlock)) {
3895         ASSERT(containerBlock.canHaveBoxInfoInFragment());
3896         LayoutUnit logicalTopPos = computedValues.m_position;
3897         const RenderBlock&amp; renderBox = downcast&lt;RenderBlock&gt;(containerBlock);
3898         LayoutUnit cbPageOffset = renderBox.offsetFromLogicalTopOfFirstPage() - logicalLeft();
3899         RenderFragmentContainer* cbFragment = renderBox.fragmentAtBlockOffset(cbPageOffset);
3900         if (cbFragment) {
3901             RenderBoxFragmentInfo* boxInfo = renderBox.renderBoxFragmentInfo(cbFragment);
3902             if (boxInfo) {
3903                 logicalTopPos += boxInfo-&gt;logicalLeft();
3904                 computedValues.m_position = logicalTopPos;
3905             }
3906         }
3907     }
3908 }
3909 
3910 static void computeLogicalTopPositionedOffset(LayoutUnit&amp; logicalTopPos, const RenderBox* child, LayoutUnit logicalHeightValue, const RenderBoxModelObject&amp; containerBlock, LayoutUnit containerLogicalHeight)
3911 {
3912     // Deal with differing writing modes here.  Our offset needs to be in the containing block&#39;s coordinate space. If the containing block is flipped
3913     // along this axis, then we need to flip the coordinate.  This can only happen if the containing block is both a flipped mode and perpendicular to us.
3914     if ((child-&gt;style().isFlippedBlocksWritingMode() &amp;&amp; child-&gt;isHorizontalWritingMode() != containerBlock.isHorizontalWritingMode())
3915         || (child-&gt;style().isFlippedBlocksWritingMode() != containerBlock.style().isFlippedBlocksWritingMode() &amp;&amp; child-&gt;isHorizontalWritingMode() == containerBlock.isHorizontalWritingMode()))
3916         logicalTopPos = containerLogicalHeight - logicalHeightValue - logicalTopPos;
3917 
3918     // Our offset is from the logical bottom edge in a flipped environment, e.g., right for vertical-rl and bottom for horizontal-bt.
3919     if (containerBlock.style().isFlippedBlocksWritingMode() &amp;&amp; child-&gt;isHorizontalWritingMode() == containerBlock.isHorizontalWritingMode()) {
3920         if (child-&gt;isHorizontalWritingMode())
3921             logicalTopPos += containerBlock.borderBottom();
3922         else
3923             logicalTopPos += containerBlock.borderRight();
3924     } else {
3925         if (child-&gt;isHorizontalWritingMode())
3926             logicalTopPos += containerBlock.borderTop();
3927         else
3928             logicalTopPos += containerBlock.borderLeft();
3929     }
3930 }
3931 
3932 void RenderBox::computePositionedLogicalHeightUsing(SizeType heightType, Length logicalHeightLength, const RenderBoxModelObject&amp; containerBlock,
3933                                                     LayoutUnit containerLogicalHeight, LayoutUnit bordersPlusPadding, LayoutUnit logicalHeight,
3934                                                     Length logicalTop, Length logicalBottom, Length marginBefore, Length marginAfter,
3935                                                     LogicalExtentComputedValues&amp; computedValues) const
3936 {
3937     ASSERT(heightType == MinSize || heightType == MainOrPreferredSize || !logicalHeightLength.isAuto());
3938     if (heightType == MinSize &amp;&amp; logicalHeightLength.isAuto())
3939         logicalHeightLength = Length(0, Fixed);
3940 
3941     // &#39;top&#39; and &#39;bottom&#39; cannot both be &#39;auto&#39; because &#39;top would of been
3942     // converted to the static position in computePositionedLogicalHeight()
3943     ASSERT(!(logicalTop.isAuto() &amp;&amp; logicalBottom.isAuto()));
3944 
3945     LayoutUnit logicalHeightValue;
3946     LayoutUnit contentLogicalHeight = logicalHeight - bordersPlusPadding;
3947 
3948     const LayoutUnit containerRelativeLogicalWidth = containingBlockLogicalWidthForPositioned(containerBlock, nullptr, false);
3949 
3950     LayoutUnit logicalTopValue;
3951 
3952     bool logicalHeightIsAuto = logicalHeightLength.isAuto();
3953     bool logicalTopIsAuto = logicalTop.isAuto();
3954     bool logicalBottomIsAuto = logicalBottom.isAuto();
3955 
3956     // Height is never unsolved for tables.
3957     LayoutUnit resolvedLogicalHeight;
3958     if (isTable()) {
3959         resolvedLogicalHeight = contentLogicalHeight;
3960         logicalHeightIsAuto = false;
3961     } else {
3962         if (logicalHeightLength.isIntrinsic())
3963             resolvedLogicalHeight = computeIntrinsicLogicalContentHeightUsing(logicalHeightLength, contentLogicalHeight, bordersPlusPadding).value();
3964         else
3965             resolvedLogicalHeight = adjustContentBoxLogicalHeightForBoxSizing(valueForLength(logicalHeightLength, containerLogicalHeight));
3966     }
3967 
3968     if (!logicalTopIsAuto &amp;&amp; !logicalHeightIsAuto &amp;&amp; !logicalBottomIsAuto) {
3969         /*-----------------------------------------------------------------------*\
3970          * If none of the three are &#39;auto&#39;: If both &#39;margin-top&#39; and &#39;margin-
3971          * bottom&#39; are &#39;auto&#39;, solve the equation under the extra constraint that
3972          * the two margins get equal values. If one of &#39;margin-top&#39; or &#39;margin-
3973          * bottom&#39; is &#39;auto&#39;, solve the equation for that value. If the values
3974          * are over-constrained, ignore the value for &#39;bottom&#39; and solve for that
3975          * value.
3976         \*-----------------------------------------------------------------------*/
3977         // NOTE:  It is not necessary to solve for &#39;bottom&#39; in the over constrained
3978         // case because the value is not used for any further calculations.
3979 
3980         logicalHeightValue = resolvedLogicalHeight;
3981         logicalTopValue = valueForLength(logicalTop, containerLogicalHeight);
3982 
3983         const LayoutUnit availableSpace = containerLogicalHeight - (logicalTopValue + logicalHeightValue + valueForLength(logicalBottom, containerLogicalHeight) + bordersPlusPadding);
3984 
3985         // Margins are now the only unknown
3986         if (marginBefore.isAuto() &amp;&amp; marginAfter.isAuto()) {
3987             // Both margins auto, solve for equality
3988             // NOTE: This may result in negative values.
3989             computedValues.m_margins.m_before = availableSpace / 2; // split the difference
3990             computedValues.m_margins.m_after = availableSpace - computedValues.m_margins.m_before; // account for odd valued differences
3991         } else if (marginBefore.isAuto()) {
3992             // Solve for top margin
3993             computedValues.m_margins.m_after = valueForLength(marginAfter, containerRelativeLogicalWidth);
3994             computedValues.m_margins.m_before = availableSpace - computedValues.m_margins.m_after;
3995         } else if (marginAfter.isAuto()) {
3996             // Solve for bottom margin
3997             computedValues.m_margins.m_before = valueForLength(marginBefore, containerRelativeLogicalWidth);
3998             computedValues.m_margins.m_after = availableSpace - computedValues.m_margins.m_before;
3999         } else {
4000             // Over-constrained, (no need solve for bottom)
4001             computedValues.m_margins.m_before = valueForLength(marginBefore, containerRelativeLogicalWidth);
4002             computedValues.m_margins.m_after = valueForLength(marginAfter, containerRelativeLogicalWidth);
4003         }
4004     } else {
4005         /*--------------------------------------------------------------------*\
4006          * Otherwise, set &#39;auto&#39; values for &#39;margin-top&#39; and &#39;margin-bottom&#39;
4007          * to 0, and pick the one of the following six rules that applies.
4008          *
4009          * 1. &#39;top&#39; and &#39;height&#39; are &#39;auto&#39; and &#39;bottom&#39; is not &#39;auto&#39;, then
4010          *    the height is based on the content, and solve for &#39;top&#39;.
4011          *
4012          *              OMIT RULE 2 AS IT SHOULD NEVER BE HIT
4013          * ------------------------------------------------------------------
4014          * 2. &#39;top&#39; and &#39;bottom&#39; are &#39;auto&#39; and &#39;height&#39; is not &#39;auto&#39;, then
4015          *    set &#39;top&#39; to the static position, and solve for &#39;bottom&#39;.
4016          * ------------------------------------------------------------------
4017          *
4018          * 3. &#39;height&#39; and &#39;bottom&#39; are &#39;auto&#39; and &#39;top&#39; is not &#39;auto&#39;, then
4019          *    the height is based on the content, and solve for &#39;bottom&#39;.
4020          * 4. &#39;top&#39; is &#39;auto&#39;, &#39;height&#39; and &#39;bottom&#39; are not &#39;auto&#39;, and
4021          *    solve for &#39;top&#39;.
4022          * 5. &#39;height&#39; is &#39;auto&#39;, &#39;top&#39; and &#39;bottom&#39; are not &#39;auto&#39;, and
4023          *    solve for &#39;height&#39;.
4024          * 6. &#39;bottom&#39; is &#39;auto&#39;, &#39;top&#39; and &#39;height&#39; are not &#39;auto&#39;, and
4025          *    solve for &#39;bottom&#39;.
4026         \*--------------------------------------------------------------------*/
4027         // NOTE: For rules 3 and 6 it is not necessary to solve for &#39;bottom&#39;
4028         // because the value is not used for any further calculations.
4029 
4030         // Calculate margins, &#39;auto&#39; margins are ignored.
4031         computedValues.m_margins.m_before = minimumValueForLength(marginBefore, containerRelativeLogicalWidth);
4032         computedValues.m_margins.m_after = minimumValueForLength(marginAfter, containerRelativeLogicalWidth);
4033 
4034         const LayoutUnit availableSpace = containerLogicalHeight - (computedValues.m_margins.m_before + computedValues.m_margins.m_after + bordersPlusPadding);
4035 
4036         // Use rule/case that applies.
4037         if (logicalTopIsAuto &amp;&amp; logicalHeightIsAuto &amp;&amp; !logicalBottomIsAuto) {
4038             // RULE 1: (height is content based, solve of top)
4039             logicalHeightValue = contentLogicalHeight;
4040             logicalTopValue = availableSpace - (logicalHeightValue + valueForLength(logicalBottom, containerLogicalHeight));
4041         } else if (!logicalTopIsAuto &amp;&amp; logicalHeightIsAuto &amp;&amp; logicalBottomIsAuto) {
4042             // RULE 3: (height is content based, no need solve of bottom)
4043             logicalTopValue = valueForLength(logicalTop, containerLogicalHeight);
4044             logicalHeightValue = contentLogicalHeight;
4045         } else if (logicalTopIsAuto &amp;&amp; !logicalHeightIsAuto &amp;&amp; !logicalBottomIsAuto) {
4046             // RULE 4: (solve of top)
4047             logicalHeightValue = resolvedLogicalHeight;
4048             logicalTopValue = availableSpace - (logicalHeightValue + valueForLength(logicalBottom, containerLogicalHeight));
4049         } else if (!logicalTopIsAuto &amp;&amp; logicalHeightIsAuto &amp;&amp; !logicalBottomIsAuto) {
4050             // RULE 5: (solve of height)
4051             logicalTopValue = valueForLength(logicalTop, containerLogicalHeight);
4052             logicalHeightValue = std::max&lt;LayoutUnit&gt;(0, availableSpace - (logicalTopValue + valueForLength(logicalBottom, containerLogicalHeight)));
4053         } else if (!logicalTopIsAuto &amp;&amp; !logicalHeightIsAuto &amp;&amp; logicalBottomIsAuto) {
4054             // RULE 6: (no need solve of bottom)
4055             logicalHeightValue = resolvedLogicalHeight;
4056             logicalTopValue = valueForLength(logicalTop, containerLogicalHeight);
4057         }
4058     }
4059     computedValues.m_extent = logicalHeightValue;
4060 
4061     // Use computed values to calculate the vertical position.
4062     computedValues.m_position = logicalTopValue + computedValues.m_margins.m_before;
4063     computeLogicalTopPositionedOffset(computedValues.m_position, this, logicalHeightValue, containerBlock, containerLogicalHeight);
4064 }
4065 
4066 void RenderBox::computePositionedLogicalWidthReplaced(LogicalExtentComputedValues&amp; computedValues) const
4067 {
4068     // The following is based off of the W3C Working Draft from April 11, 2006 of
4069     // CSS 2.1: Section 10.3.8 &quot;Absolutely positioned, replaced elements&quot;
4070     // &lt;http://www.w3.org/TR/2005/WD-CSS21-20050613/visudet.html#abs-replaced-width&gt;
4071     // (block-style-comments in this function correspond to text from the spec and
4072     // the numbers correspond to numbers in spec)
4073 
4074     // We don&#39;t use containingBlock(), since we may be positioned by an enclosing
4075     // relative positioned inline.
4076     const RenderBoxModelObject&amp; containerBlock = downcast&lt;RenderBoxModelObject&gt;(*container());
4077 
4078     const LayoutUnit containerLogicalWidth = containingBlockLogicalWidthForPositioned(containerBlock);
4079     const LayoutUnit containerRelativeLogicalWidth = containingBlockLogicalWidthForPositioned(containerBlock, nullptr, false);
4080 
4081     // To match WinIE, in quirks mode use the parent&#39;s &#39;direction&#39; property
4082     // instead of the container block&#39;s.
4083     TextDirection containerDirection = containerBlock.style().direction();
4084 
4085     // Variables to solve.
4086     bool isHorizontal = isHorizontalWritingMode();
4087     Length logicalLeft = style().logicalLeft();
4088     Length logicalRight = style().logicalRight();
4089     Length marginLogicalLeft = isHorizontal ? style().marginLeft() : style().marginTop();
4090     Length marginLogicalRight = isHorizontal ? style().marginRight() : style().marginBottom();
4091     LayoutUnit&amp; marginLogicalLeftAlias = style().isLeftToRightDirection() ? computedValues.m_margins.m_start : computedValues.m_margins.m_end;
4092     LayoutUnit&amp; marginLogicalRightAlias = style().isLeftToRightDirection() ? computedValues.m_margins.m_end : computedValues.m_margins.m_start;
4093 
4094     /*-----------------------------------------------------------------------*\
4095      * 1. The used value of &#39;width&#39; is determined as for inline replaced
4096      *    elements.
4097     \*-----------------------------------------------------------------------*/
4098     // NOTE: This value of width is final in that the min/max width calculations
4099     // are dealt with in computeReplacedWidth().  This means that the steps to produce
4100     // correct max/min in the non-replaced version, are not necessary.
4101     computedValues.m_extent = computeReplacedLogicalWidth() + borderAndPaddingLogicalWidth();
4102 
4103     const LayoutUnit availableSpace = containerLogicalWidth - computedValues.m_extent;
4104 
4105     /*-----------------------------------------------------------------------*\
4106      * 2. If both &#39;left&#39; and &#39;right&#39; have the value &#39;auto&#39;, then if &#39;direction&#39;
4107      *    of the containing block is &#39;ltr&#39;, set &#39;left&#39; to the static position;
4108      *    else if &#39;direction&#39; is &#39;rtl&#39;, set &#39;right&#39; to the static position.
4109     \*-----------------------------------------------------------------------*/
4110     // see FIXME 1
4111     computeInlineStaticDistance(logicalLeft, logicalRight, this, containerBlock, containerLogicalWidth, nullptr); // FIXME: Pass the fragment.
4112 
4113     /*-----------------------------------------------------------------------*\
4114      * 3. If &#39;left&#39; or &#39;right&#39; are &#39;auto&#39;, replace any &#39;auto&#39; on &#39;margin-left&#39;
4115      *    or &#39;margin-right&#39; with &#39;0&#39;.
4116     \*-----------------------------------------------------------------------*/
4117     if (logicalLeft.isAuto() || logicalRight.isAuto()) {
4118         if (marginLogicalLeft.isAuto())
4119             marginLogicalLeft.setValue(Fixed, 0);
4120         if (marginLogicalRight.isAuto())
4121             marginLogicalRight.setValue(Fixed, 0);
4122     }
4123 
4124     /*-----------------------------------------------------------------------*\
4125      * 4. If at this point both &#39;margin-left&#39; and &#39;margin-right&#39; are still
4126      *    &#39;auto&#39;, solve the equation under the extra constraint that the two
4127      *    margins must get equal values, unless this would make them negative,
4128      *    in which case when the direction of the containing block is &#39;ltr&#39;
4129      *    (&#39;rtl&#39;), set &#39;margin-left&#39; (&#39;margin-right&#39;) to zero and solve for
4130      *    &#39;margin-right&#39; (&#39;margin-left&#39;).
4131     \*-----------------------------------------------------------------------*/
4132     LayoutUnit logicalLeftValue;
4133     LayoutUnit logicalRightValue;
4134 
4135     if (marginLogicalLeft.isAuto() &amp;&amp; marginLogicalRight.isAuto()) {
4136         // &#39;left&#39; and &#39;right&#39; cannot be &#39;auto&#39; due to step 3
4137         ASSERT(!(logicalLeft.isAuto() &amp;&amp; logicalRight.isAuto()));
4138 
4139         logicalLeftValue = valueForLength(logicalLeft, containerLogicalWidth);
4140         logicalRightValue = valueForLength(logicalRight, containerLogicalWidth);
4141 
4142         LayoutUnit difference = availableSpace - (logicalLeftValue + logicalRightValue);
4143         if (difference &gt; 0) {
4144             marginLogicalLeftAlias = difference / 2; // split the difference
4145             marginLogicalRightAlias = difference - marginLogicalLeftAlias; // account for odd valued differences
4146         } else {
4147             // Use the containing block&#39;s direction rather than the parent block&#39;s
4148             // per CSS 2.1 reference test abspos-replaced-width-margin-000.
4149             if (containerDirection == TextDirection::LTR) {
4150                 marginLogicalLeftAlias = 0;
4151                 marginLogicalRightAlias = difference; // will be negative
4152             } else {
4153                 marginLogicalLeftAlias = difference; // will be negative
4154                 marginLogicalRightAlias = 0;
4155             }
4156         }
4157 
4158     /*-----------------------------------------------------------------------*\
4159      * 5. If at this point there is an &#39;auto&#39; left, solve the equation for
4160      *    that value.
4161     \*-----------------------------------------------------------------------*/
4162     } else if (logicalLeft.isAuto()) {
4163         marginLogicalLeftAlias = valueForLength(marginLogicalLeft, containerRelativeLogicalWidth);
4164         marginLogicalRightAlias = valueForLength(marginLogicalRight, containerRelativeLogicalWidth);
4165         logicalRightValue = valueForLength(logicalRight, containerLogicalWidth);
4166 
4167         // Solve for &#39;left&#39;
4168         logicalLeftValue = availableSpace - (logicalRightValue + marginLogicalLeftAlias + marginLogicalRightAlias);
4169     } else if (logicalRight.isAuto()) {
4170         marginLogicalLeftAlias = valueForLength(marginLogicalLeft, containerRelativeLogicalWidth);
4171         marginLogicalRightAlias = valueForLength(marginLogicalRight, containerRelativeLogicalWidth);
4172         logicalLeftValue = valueForLength(logicalLeft, containerLogicalWidth);
4173 
4174         // Solve for &#39;right&#39;
4175         logicalRightValue = availableSpace - (logicalLeftValue + marginLogicalLeftAlias + marginLogicalRightAlias);
4176     } else if (marginLogicalLeft.isAuto()) {
4177         marginLogicalRightAlias = valueForLength(marginLogicalRight, containerRelativeLogicalWidth);
4178         logicalLeftValue = valueForLength(logicalLeft, containerLogicalWidth);
4179         logicalRightValue = valueForLength(logicalRight, containerLogicalWidth);
4180 
4181         // Solve for &#39;margin-left&#39;
4182         marginLogicalLeftAlias = availableSpace - (logicalLeftValue + logicalRightValue + marginLogicalRightAlias);
4183     } else if (marginLogicalRight.isAuto()) {
4184         marginLogicalLeftAlias = valueForLength(marginLogicalLeft, containerRelativeLogicalWidth);
4185         logicalLeftValue = valueForLength(logicalLeft, containerLogicalWidth);
4186         logicalRightValue = valueForLength(logicalRight, containerLogicalWidth);
4187 
4188         // Solve for &#39;margin-right&#39;
4189         marginLogicalRightAlias = availableSpace - (logicalLeftValue + logicalRightValue + marginLogicalLeftAlias);
4190     } else {
4191         // Nothing is &#39;auto&#39;, just calculate the values.
4192         marginLogicalLeftAlias = valueForLength(marginLogicalLeft, containerRelativeLogicalWidth);
4193         marginLogicalRightAlias = valueForLength(marginLogicalRight, containerRelativeLogicalWidth);
4194         logicalRightValue = valueForLength(logicalRight, containerLogicalWidth);
4195         logicalLeftValue = valueForLength(logicalLeft, containerLogicalWidth);
4196         // If the containing block is right-to-left, then push the left position as far to the right as possible
4197         if (containerDirection == TextDirection::RTL) {
4198             int totalLogicalWidth = computedValues.m_extent + logicalLeftValue + logicalRightValue +  marginLogicalLeftAlias + marginLogicalRightAlias;
4199             logicalLeftValue = containerLogicalWidth - (totalLogicalWidth - logicalLeftValue);
4200         }
4201     }
4202 
4203     /*-----------------------------------------------------------------------*\
4204      * 6. If at this point the values are over-constrained, ignore the value
4205      *    for either &#39;left&#39; (in case the &#39;direction&#39; property of the
4206      *    containing block is &#39;rtl&#39;) or &#39;right&#39; (in case &#39;direction&#39; is
4207      *    &#39;ltr&#39;) and solve for that value.
4208     \*-----------------------------------------------------------------------*/
4209     // NOTE: Constraints imposed by the width of the containing block and its content have already been accounted for above.
4210 
4211     // FIXME: Deal with differing writing modes here.  Our offset needs to be in the containing block&#39;s coordinate space, so that
4212     // can make the result here rather complicated to compute.
4213 
4214     // Use computed values to calculate the horizontal position.
4215 
4216     // FIXME: This hack is needed to calculate the logical left position for a &#39;rtl&#39; relatively
4217     // positioned, inline containing block because right now, it is using the logical left position
4218     // of the first line box when really it should use the last line box.  When
4219     // this is fixed elsewhere, this block should be removed.
4220     if (is&lt;RenderInline&gt;(containerBlock) &amp;&amp; !containerBlock.style().isLeftToRightDirection()) {
4221         const auto&amp; flow = downcast&lt;RenderInline&gt;(containerBlock);
4222         InlineFlowBox* firstLine = flow.firstLineBox();
4223         InlineFlowBox* lastLine = flow.lastLineBox();
4224         if (firstLine &amp;&amp; lastLine &amp;&amp; firstLine != lastLine) {
4225             computedValues.m_position = logicalLeftValue + marginLogicalLeftAlias + lastLine-&gt;borderLogicalLeft() + (lastLine-&gt;logicalLeft() - firstLine-&gt;logicalLeft());
4226             return;
4227         }
4228     }
4229 
4230     LayoutUnit logicalLeftPos = logicalLeftValue + marginLogicalLeftAlias;
4231     computeLogicalLeftPositionedOffset(logicalLeftPos, this, computedValues.m_extent, containerBlock, containerLogicalWidth);
4232     computedValues.m_position = logicalLeftPos;
4233 }
4234 
4235 void RenderBox::computePositionedLogicalHeightReplaced(LogicalExtentComputedValues&amp; computedValues) const
4236 {
4237     // The following is based off of the W3C Working Draft from April 11, 2006 of
4238     // CSS 2.1: Section 10.6.5 &quot;Absolutely positioned, replaced elements&quot;
4239     // &lt;http://www.w3.org/TR/2005/WD-CSS21-20050613/visudet.html#abs-replaced-height&gt;
4240     // (block-style-comments in this function correspond to text from the spec and
4241     // the numbers correspond to numbers in spec)
4242 
4243     // We don&#39;t use containingBlock(), since we may be positioned by an enclosing relpositioned inline.
4244     const RenderBoxModelObject&amp; containerBlock = downcast&lt;RenderBoxModelObject&gt;(*container());
4245 
4246     const LayoutUnit containerLogicalHeight = containingBlockLogicalHeightForPositioned(containerBlock);
4247     const LayoutUnit containerRelativeLogicalWidth = containingBlockLogicalWidthForPositioned(containerBlock, nullptr, false);
4248 
4249     // Variables to solve.
4250     Length marginBefore = style().marginBefore();
4251     Length marginAfter = style().marginAfter();
4252     LayoutUnit&amp; marginBeforeAlias = computedValues.m_margins.m_before;
4253     LayoutUnit&amp; marginAfterAlias = computedValues.m_margins.m_after;
4254 
4255     Length logicalTop = style().logicalTop();
4256     Length logicalBottom = style().logicalBottom();
4257 
4258     /*-----------------------------------------------------------------------*\
4259      * 1. The used value of &#39;height&#39; is determined as for inline replaced
4260      *    elements.
4261     \*-----------------------------------------------------------------------*/
4262     // NOTE: This value of height is final in that the min/max height calculations
4263     // are dealt with in computeReplacedHeight().  This means that the steps to produce
4264     // correct max/min in the non-replaced version, are not necessary.
4265     computedValues.m_extent = computeReplacedLogicalHeight() + borderAndPaddingLogicalHeight();
4266     const LayoutUnit availableSpace = containerLogicalHeight - computedValues.m_extent;
4267 
4268     /*-----------------------------------------------------------------------*\
4269      * 2. If both &#39;top&#39; and &#39;bottom&#39; have the value &#39;auto&#39;, replace &#39;top&#39;
4270      *    with the element&#39;s static position.
4271     \*-----------------------------------------------------------------------*/
4272     // see FIXME 1
4273     computeBlockStaticDistance(logicalTop, logicalBottom, this, containerBlock);
4274 
4275     /*-----------------------------------------------------------------------*\
4276      * 3. If &#39;bottom&#39; is &#39;auto&#39;, replace any &#39;auto&#39; on &#39;margin-top&#39; or
4277      *    &#39;margin-bottom&#39; with &#39;0&#39;.
4278     \*-----------------------------------------------------------------------*/
4279     // FIXME: The spec. says that this step should only be taken when bottom is
4280     // auto, but if only top is auto, this makes step 4 impossible.
4281     if (logicalTop.isAuto() || logicalBottom.isAuto()) {
4282         if (marginBefore.isAuto())
4283             marginBefore.setValue(Fixed, 0);
4284         if (marginAfter.isAuto())
4285             marginAfter.setValue(Fixed, 0);
4286     }
4287 
4288     /*-----------------------------------------------------------------------*\
4289      * 4. If at this point both &#39;margin-top&#39; and &#39;margin-bottom&#39; are still
4290      *    &#39;auto&#39;, solve the equation under the extra constraint that the two
4291      *    margins must get equal values.
4292     \*-----------------------------------------------------------------------*/
4293     LayoutUnit logicalTopValue;
4294     LayoutUnit logicalBottomValue;
4295 
4296     if (marginBefore.isAuto() &amp;&amp; marginAfter.isAuto()) {
4297         // &#39;top&#39; and &#39;bottom&#39; cannot be &#39;auto&#39; due to step 2 and 3 combined.
4298         ASSERT(!(logicalTop.isAuto() || logicalBottom.isAuto()));
4299 
4300         logicalTopValue = valueForLength(logicalTop, containerLogicalHeight);
4301         logicalBottomValue = valueForLength(logicalBottom, containerLogicalHeight);
4302 
4303         LayoutUnit difference = availableSpace - (logicalTopValue + logicalBottomValue);
4304         // NOTE: This may result in negative values.
4305         marginBeforeAlias =  difference / 2; // split the difference
4306         marginAfterAlias = difference - marginBeforeAlias; // account for odd valued differences
4307 
4308     /*-----------------------------------------------------------------------*\
4309      * 5. If at this point there is only one &#39;auto&#39; left, solve the equation
4310      *    for that value.
4311     \*-----------------------------------------------------------------------*/
4312     } else if (logicalTop.isAuto()) {
4313         marginBeforeAlias = valueForLength(marginBefore, containerRelativeLogicalWidth);
4314         marginAfterAlias = valueForLength(marginAfter, containerRelativeLogicalWidth);
4315         logicalBottomValue = valueForLength(logicalBottom, containerLogicalHeight);
4316 
4317         // Solve for &#39;top&#39;
4318         logicalTopValue = availableSpace - (logicalBottomValue + marginBeforeAlias + marginAfterAlias);
4319     } else if (logicalBottom.isAuto()) {
4320         marginBeforeAlias = valueForLength(marginBefore, containerRelativeLogicalWidth);
4321         marginAfterAlias = valueForLength(marginAfter, containerRelativeLogicalWidth);
4322         logicalTopValue = valueForLength(logicalTop, containerLogicalHeight);
4323 
4324         // Solve for &#39;bottom&#39;
4325         // NOTE: It is not necessary to solve for &#39;bottom&#39; because we don&#39;t ever
4326         // use the value.
4327     } else if (marginBefore.isAuto()) {
4328         marginAfterAlias = valueForLength(marginAfter, containerRelativeLogicalWidth);
4329         logicalTopValue = valueForLength(logicalTop, containerLogicalHeight);
4330         logicalBottomValue = valueForLength(logicalBottom, containerLogicalHeight);
4331 
4332         // Solve for &#39;margin-top&#39;
4333         marginBeforeAlias = availableSpace - (logicalTopValue + logicalBottomValue + marginAfterAlias);
4334     } else if (marginAfter.isAuto()) {
4335         marginBeforeAlias = valueForLength(marginBefore, containerRelativeLogicalWidth);
4336         logicalTopValue = valueForLength(logicalTop, containerLogicalHeight);
4337         logicalBottomValue = valueForLength(logicalBottom, containerLogicalHeight);
4338 
4339         // Solve for &#39;margin-bottom&#39;
4340         marginAfterAlias = availableSpace - (logicalTopValue + logicalBottomValue + marginBeforeAlias);
4341     } else {
4342         // Nothing is &#39;auto&#39;, just calculate the values.
4343         marginBeforeAlias = valueForLength(marginBefore, containerRelativeLogicalWidth);
4344         marginAfterAlias = valueForLength(marginAfter, containerRelativeLogicalWidth);
4345         logicalTopValue = valueForLength(logicalTop, containerLogicalHeight);
4346         // NOTE: It is not necessary to solve for &#39;bottom&#39; because we don&#39;t ever
4347         // use the value.
4348      }
4349 
4350     /*-----------------------------------------------------------------------*\
4351      * 6. If at this point the values are over-constrained, ignore the value
4352      *    for &#39;bottom&#39; and solve for that value.
4353     \*-----------------------------------------------------------------------*/
4354     // NOTE: It is not necessary to do this step because we don&#39;t end up using
4355     // the value of &#39;bottom&#39; regardless of whether the values are over-constrained
4356     // or not.
4357 
4358     // Use computed values to calculate the vertical position.
4359     LayoutUnit logicalTopPos = logicalTopValue + marginBeforeAlias;
4360     computeLogicalTopPositionedOffset(logicalTopPos, this, computedValues.m_extent, containerBlock, containerLogicalHeight);
4361     computedValues.m_position = logicalTopPos;
4362 }
4363 
4364 LayoutRect RenderBox::localCaretRect(InlineBox* box, unsigned caretOffset, LayoutUnit* extraWidthToEndOfLine)
4365 {
4366     // VisiblePositions at offsets inside containers either a) refer to the positions before/after
4367     // those containers (tables and select elements) or b) refer to the position inside an empty block.
4368     // They never refer to children.
4369     // FIXME: Paint the carets inside empty blocks differently than the carets before/after elements.
4370 
4371     LayoutRect rect(location(), LayoutSize(caretWidth, height()));
4372     bool ltr = box ? box-&gt;isLeftToRightDirection() : style().isLeftToRightDirection();
4373 
4374     if ((!caretOffset) ^ ltr)
4375         rect.move(LayoutSize(width() - caretWidth, 0_lu));
4376 
4377     if (box) {
4378         const RootInlineBox&amp; rootBox = box-&gt;root();
4379         LayoutUnit top = rootBox.lineTop();
4380         rect.setY(top);
4381         rect.setHeight(rootBox.lineBottom() - top);
4382     }
4383 
4384     // If height of box is smaller than font height, use the latter one,
4385     // otherwise the caret might become invisible.
4386     //
4387     // Also, if the box is not a replaced element, always use the font height.
4388     // This prevents the &quot;big caret&quot; bug described in:
4389     // &lt;rdar://problem/3777804&gt; Deleting all content in a document can result in giant tall-as-window insertion point
4390     //
4391     // FIXME: ignoring :first-line, missing good reason to take care of
4392     LayoutUnit fontHeight = style().fontMetrics().height();
4393     if (fontHeight &gt; rect.height() || (!isReplaced() &amp;&amp; !isTable()))
4394         rect.setHeight(fontHeight);
4395 
4396     if (extraWidthToEndOfLine)
4397         *extraWidthToEndOfLine = x() + width() - rect.maxX();
4398 
4399     // Move to local coords
4400     rect.moveBy(-location());
4401 
4402     // FIXME: Border/padding should be added for all elements but this workaround
4403     // is needed because we use offsets inside an &quot;atomic&quot; element to represent
4404     // positions before and after the element in deprecated editing offsets.
4405     if (element() &amp;&amp; !(editingIgnoresContent(*element()) || isRenderedTable(element()))) {
4406         rect.setX(rect.x() + borderLeft() + paddingLeft());
4407         rect.setY(rect.y() + paddingTop() + borderTop());
4408     }
4409 
4410     if (!isHorizontalWritingMode())
4411         return rect.transposedRect();
4412 
4413     return rect;
4414 }
4415 
4416 VisiblePosition RenderBox::positionForPoint(const LayoutPoint&amp; point, const RenderFragmentContainer* fragment)
4417 {
4418     // no children...return this render object&#39;s element, if there is one, and offset 0
4419     if (!firstChild())
4420         return createVisiblePosition(nonPseudoElement() ? firstPositionInOrBeforeNode(nonPseudoElement()) : Position());
4421 
4422     if (isTable() &amp;&amp; nonPseudoElement()) {
4423         LayoutUnit right = contentWidth() + horizontalBorderAndPaddingExtent();
4424         LayoutUnit bottom = contentHeight() + verticalBorderAndPaddingExtent();
4425 
4426         if (point.x() &lt; 0 || point.x() &gt; right || point.y() &lt; 0 || point.y() &gt; bottom) {
4427             if (point.x() &lt;= right / 2)
4428                 return createVisiblePosition(firstPositionInOrBeforeNode(nonPseudoElement()));
4429             return createVisiblePosition(lastPositionInOrAfterNode(nonPseudoElement()));
4430         }
4431     }
4432 
4433     // Pass off to the closest child.
4434     LayoutUnit minDist = LayoutUnit::max();
4435     RenderBox* closestRenderer = nullptr;
4436     LayoutPoint adjustedPoint = point;
4437     if (isTableRow())
4438         adjustedPoint.moveBy(location());
4439 
4440     for (auto&amp; renderer : childrenOfType&lt;RenderBox&gt;(*this)) {
4441         if (is&lt;RenderFragmentedFlow&gt;(*this)) {
4442             ASSERT(fragment);
4443             if (!downcast&lt;RenderFragmentedFlow&gt;(*this).objectShouldFragmentInFlowFragment(&amp;renderer, fragment))
4444                 continue;
4445         }
4446 
4447         if ((!renderer.firstChild() &amp;&amp; !renderer.isInline() &amp;&amp; !is&lt;RenderBlockFlow&gt;(renderer))
4448             || renderer.style().visibility() != Visibility::Visible)
4449             continue;
4450 
4451         LayoutUnit top = renderer.borderTop() + renderer.paddingTop() + (is&lt;RenderTableRow&gt;(*this) ? 0_lu : renderer.y());
4452         LayoutUnit bottom = top + renderer.contentHeight();
4453         LayoutUnit left = renderer.borderLeft() + renderer.paddingLeft() + (is&lt;RenderTableRow&gt;(*this) ? 0_lu : renderer.x());
4454         LayoutUnit right = left + renderer.contentWidth();
4455 
4456         if (point.x() &lt;= right &amp;&amp; point.x() &gt;= left &amp;&amp; point.y() &lt;= top &amp;&amp; point.y() &gt;= bottom) {
4457             if (is&lt;RenderTableRow&gt;(renderer))
4458                 return renderer.positionForPoint(point + adjustedPoint - renderer.locationOffset(), fragment);
4459             return renderer.positionForPoint(point - renderer.locationOffset(), fragment);
4460         }
4461 
4462         // Find the distance from (x, y) to the box.  Split the space around the box into 8 pieces
4463         // and use a different compare depending on which piece (x, y) is in.
4464         LayoutPoint cmp;
4465         if (point.x() &gt; right) {
4466             if (point.y() &lt; top)
4467                 cmp = LayoutPoint(right, top);
4468             else if (point.y() &gt; bottom)
4469                 cmp = LayoutPoint(right, bottom);
4470             else
4471                 cmp = LayoutPoint(right, point.y());
4472         } else if (point.x() &lt; left) {
4473             if (point.y() &lt; top)
4474                 cmp = LayoutPoint(left, top);
4475             else if (point.y() &gt; bottom)
4476                 cmp = LayoutPoint(left, bottom);
4477             else
4478                 cmp = LayoutPoint(left, point.y());
4479         } else {
4480             if (point.y() &lt; top)
4481                 cmp = LayoutPoint(point.x(), top);
4482             else
4483                 cmp = LayoutPoint(point.x(), bottom);
4484         }
4485 
4486         LayoutSize difference = cmp - point;
4487 
4488         LayoutUnit dist = difference.width() * difference.width() + difference.height() * difference.height();
4489         if (dist &lt; minDist) {
4490             closestRenderer = &amp;renderer;
4491             minDist = dist;
4492         }
4493     }
4494 
4495     if (closestRenderer)
4496         return closestRenderer-&gt;positionForPoint(adjustedPoint - closestRenderer-&gt;locationOffset(), fragment);
4497 
4498     return createVisiblePosition(firstPositionInOrBeforeNode(nonPseudoElement()));
4499 }
4500 
4501 bool RenderBox::shrinkToAvoidFloats() const
4502 {
4503     // Floating objects don&#39;t shrink.  Objects that don&#39;t avoid floats don&#39;t shrink.  Marquees don&#39;t shrink.
4504     if ((isInline() &amp;&amp; !isHTMLMarquee()) || !avoidsFloats() || isFloating())
4505         return false;
4506 
4507     // Only auto width objects can possibly shrink to avoid floats.
4508     return style().width().isAuto();
4509 }
4510 
4511 bool RenderBox::createsNewFormattingContext() const
4512 {
4513     return isInlineBlockOrInlineTable() || isFloatingOrOutOfFlowPositioned() || hasOverflowClip() || isFlexItemIncludingDeprecated()
4514         || isTableCell() || isTableCaption() || isFieldset() || isWritingModeRoot() || isDocumentElementRenderer() || isRenderFragmentedFlow() || isRenderFragmentContainer()
<a name="19" id="anc19"></a><span class="line-modified">4515         || isGridItem() || style().specifiesColumns() || style().columnSpan() == ColumnSpan::All;</span>
4516 }
4517 
4518 bool RenderBox::avoidsFloats() const
4519 {
4520     return isReplaced() || isHR() || isLegend() || isFieldset() || createsNewFormattingContext();
4521 }
4522 
4523 void RenderBox::addVisualEffectOverflow()
4524 {
4525     if (!style().boxShadow() &amp;&amp; !style().hasBorderImageOutsets() &amp;&amp; !outlineStyleForRepaint().hasOutlineInVisualOverflow())
4526         return;
4527 
4528     addVisualOverflow(applyVisualEffectOverflow(borderBoxRect()));
4529 
4530     RenderFragmentedFlow* fragmentedFlow = enclosingFragmentedFlow();
4531     if (fragmentedFlow)
4532         fragmentedFlow-&gt;addFragmentsVisualEffectOverflow(this);
4533 }
4534 
4535 LayoutRect RenderBox::applyVisualEffectOverflow(const LayoutRect&amp; borderBox) const
4536 {
4537     bool isFlipped = style().isFlippedBlocksWritingMode();
4538     bool isHorizontal = isHorizontalWritingMode();
4539 
4540     LayoutUnit overflowMinX = borderBox.x();
4541     LayoutUnit overflowMaxX = borderBox.maxX();
4542     LayoutUnit overflowMinY = borderBox.y();
4543     LayoutUnit overflowMaxY = borderBox.maxY();
4544 
4545     // Compute box-shadow overflow first.
4546     if (style().boxShadow()) {
4547         LayoutUnit shadowLeft;
4548         LayoutUnit shadowRight;
4549         LayoutUnit shadowTop;
4550         LayoutUnit shadowBottom;
4551         style().getBoxShadowExtent(shadowTop, shadowRight, shadowBottom, shadowLeft);
4552 
4553         // In flipped blocks writing modes such as vertical-rl, the physical right shadow value is actually at the lower x-coordinate.
4554         overflowMinX = borderBox.x() + ((!isFlipped || isHorizontal) ? shadowLeft : -shadowRight);
4555         overflowMaxX = borderBox.maxX() + ((!isFlipped || isHorizontal) ? shadowRight : -shadowLeft);
4556         overflowMinY = borderBox.y() + ((!isFlipped || !isHorizontal) ? shadowTop : -shadowBottom);
4557         overflowMaxY = borderBox.maxY() + ((!isFlipped || !isHorizontal) ? shadowBottom : -shadowTop);
4558     }
4559 
4560     // Now compute border-image-outset overflow.
4561     if (style().hasBorderImageOutsets()) {
4562         LayoutBoxExtent borderOutsets = style().borderImageOutsets();
4563 
4564         // In flipped blocks writing modes, the physical sides are inverted. For example in vertical-rl, the right
4565         // border is at the lower x coordinate value.
4566         overflowMinX = std::min(overflowMinX, borderBox.x() - ((!isFlipped || isHorizontal) ? borderOutsets.left() : borderOutsets.right()));
4567         overflowMaxX = std::max(overflowMaxX, borderBox.maxX() + ((!isFlipped || isHorizontal) ? borderOutsets.right() : borderOutsets.left()));
4568         overflowMinY = std::min(overflowMinY, borderBox.y() - ((!isFlipped || !isHorizontal) ? borderOutsets.top() : borderOutsets.bottom()));
4569         overflowMaxY = std::max(overflowMaxY, borderBox.maxY() + ((!isFlipped || !isHorizontal) ? borderOutsets.bottom() : borderOutsets.top()));
4570     }
4571 
4572     if (outlineStyleForRepaint().hasOutlineInVisualOverflow()) {
<a name="20" id="anc20"></a><span class="line-modified">4573         LayoutUnit outlineSize = outlineStyleForRepaint().outlineSize();</span>
4574         overflowMinX = std::min(overflowMinX, borderBox.x() - outlineSize);
4575         overflowMaxX = std::max(overflowMaxX, borderBox.maxX() + outlineSize);
4576         overflowMinY = std::min(overflowMinY, borderBox.y() - outlineSize);
4577         overflowMaxY = std::max(overflowMaxY, borderBox.maxY() + outlineSize);
4578     }
4579     // Add in the final overflow with shadows and outsets combined.
4580     return LayoutRect(overflowMinX, overflowMinY, overflowMaxX - overflowMinX, overflowMaxY - overflowMinY);
4581 }
4582 
4583 void RenderBox::addOverflowFromChild(const RenderBox* child, const LayoutSize&amp; delta)
4584 {
4585     // Never allow flow threads to propagate overflow up to a parent.
4586     if (child-&gt;isRenderFragmentedFlow())
4587         return;
4588 
4589     RenderFragmentedFlow* fragmentedFlow = enclosingFragmentedFlow();
4590     if (fragmentedFlow)
4591         fragmentedFlow-&gt;addFragmentsOverflowFromChild(this, child, delta);
4592 
4593     // Only propagate layout overflow from the child if the child isn&#39;t clipping its overflow.  If it is, then
4594     // its overflow is internal to it, and we don&#39;t care about it.  layoutOverflowRectForPropagation takes care of this
4595     // and just propagates the border box rect instead.
4596     LayoutRect childLayoutOverflowRect = child-&gt;layoutOverflowRectForPropagation(&amp;style());
4597     childLayoutOverflowRect.move(delta);
4598     addLayoutOverflow(childLayoutOverflowRect);
4599 
4600     // Add in visual overflow from the child.  Even if the child clips its overflow, it may still
4601     // have visual overflow of its own set from box shadows or reflections.  It is unnecessary to propagate this
4602     // overflow if we are clipping our own overflow.
4603     if (child-&gt;hasSelfPaintingLayer() || hasOverflowClip())
4604         return;
4605     LayoutRect childVisualOverflowRect = child-&gt;visualOverflowRectForPropagation(&amp;style());
4606     childVisualOverflowRect.move(delta);
4607     addVisualOverflow(childVisualOverflowRect);
4608 }
4609 
4610 void RenderBox::addLayoutOverflow(const LayoutRect&amp; rect)
4611 {
4612     LayoutRect clientBox = flippedClientBoxRect();
4613     if (clientBox.contains(rect) || rect.isEmpty())
4614         return;
4615 
4616     // For overflow clip objects, we don&#39;t want to propagate overflow into unreachable areas.
4617     LayoutRect overflowRect(rect);
4618     if (hasOverflowClip() || isRenderView()) {
4619         // Overflow is in the block&#39;s coordinate space and thus is flipped for horizontal-bt and vertical-rl
4620         // writing modes.  At this stage that is actually a simplification, since we can treat horizontal-tb/bt as the same
4621         // and vertical-lr/rl as the same.
4622         bool hasTopOverflow = isTopLayoutOverflowAllowed();
4623         bool hasLeftOverflow = isLeftLayoutOverflowAllowed();
4624 
4625         if (!hasTopOverflow)
4626             overflowRect.shiftYEdgeTo(std::max(overflowRect.y(), clientBox.y()));
4627         else
4628             overflowRect.shiftMaxYEdgeTo(std::min(overflowRect.maxY(), clientBox.maxY()));
4629         if (!hasLeftOverflow)
4630             overflowRect.shiftXEdgeTo(std::max(overflowRect.x(), clientBox.x()));
4631         else
4632             overflowRect.shiftMaxXEdgeTo(std::min(overflowRect.maxX(), clientBox.maxX()));
4633 
4634         // Now re-test with the adjusted rectangle and see if it has become unreachable or fully
4635         // contained.
4636         if (clientBox.contains(overflowRect) || overflowRect.isEmpty())
4637             return;
4638     }
4639 
4640     if (!m_overflow)
4641         m_overflow = adoptRef(new RenderOverflow(clientBox, borderBoxRect()));
4642 
4643     m_overflow-&gt;addLayoutOverflow(overflowRect);
4644 }
4645 
4646 void RenderBox::addVisualOverflow(const LayoutRect&amp; rect)
4647 {
4648     LayoutRect borderBox = borderBoxRect();
4649     if (borderBox.contains(rect) || rect.isEmpty())
4650         return;
4651 
4652     if (!m_overflow)
4653         m_overflow = adoptRef(new RenderOverflow(flippedClientBoxRect(), borderBox));
4654 
4655     m_overflow-&gt;addVisualOverflow(rect);
4656 }
4657 
4658 void RenderBox::clearOverflow()
4659 {
4660     m_overflow = nullptr;
4661     RenderFragmentedFlow* fragmentedFlow = enclosingFragmentedFlow();
4662     if (fragmentedFlow)
4663         fragmentedFlow-&gt;clearFragmentsOverflow(this);
4664 }
4665 
4666 bool RenderBox::percentageLogicalHeightIsResolvable() const
4667 {
4668     // Do this to avoid duplicating all the logic that already exists when computing
4669     // an actual percentage height.
4670     Length fakeLength(100, Percent);
4671     return computePercentageLogicalHeight(fakeLength) != WTF::nullopt;
4672 }
4673 
4674 bool RenderBox::hasUnsplittableScrollingOverflow() const
4675 {
4676     // We will paginate as long as we don&#39;t scroll overflow in the pagination direction.
4677     bool isHorizontal = isHorizontalWritingMode();
4678     if ((isHorizontal &amp;&amp; !scrollsOverflowY()) || (!isHorizontal &amp;&amp; !scrollsOverflowX()))
4679         return false;
4680 
4681     // We do have overflow. We&#39;ll still be willing to paginate as long as the block
4682     // has auto logical height, auto or undefined max-logical-height and a zero or auto min-logical-height.
4683     // Note this is just a heuristic, and it&#39;s still possible to have overflow under these
4684     // conditions, but it should work out to be good enough for common cases. Paginating overflow
4685     // with scrollbars present is not the end of the world and is what we used to do in the old model anyway.
4686     return !style().logicalHeight().isIntrinsicOrAuto()
4687         || (!style().logicalMaxHeight().isIntrinsicOrAuto() &amp;&amp; !style().logicalMaxHeight().isUndefined() &amp;&amp; (!style().logicalMaxHeight().isPercentOrCalculated() || percentageLogicalHeightIsResolvable()))
4688         || (!style().logicalMinHeight().isIntrinsicOrAuto() &amp;&amp; style().logicalMinHeight().isPositive() &amp;&amp; (!style().logicalMinHeight().isPercentOrCalculated() || percentageLogicalHeightIsResolvable()));
4689 }
4690 
4691 bool RenderBox::isUnsplittableForPagination() const
4692 {
4693     return isReplaced()
4694         || hasUnsplittableScrollingOverflow()
4695         || (parent() &amp;&amp; isWritingModeRoot())
4696         || (isFloating() &amp;&amp; style().styleType() == PseudoId::FirstLetter &amp;&amp; style().initialLetterDrop() &gt; 0);
4697 }
4698 
4699 LayoutUnit RenderBox::lineHeight(bool /*firstLine*/, LineDirectionMode direction, LinePositionMode /*linePositionMode*/) const
4700 {
4701     if (isReplaced())
4702         return direction == HorizontalLine ? m_marginBox.top() + height() + m_marginBox.bottom() : m_marginBox.right() + width() + m_marginBox.left();
4703     return 0;
4704 }
4705 
4706 int RenderBox::baselinePosition(FontBaseline baselineType, bool /*firstLine*/, LineDirectionMode direction, LinePositionMode /*linePositionMode*/) const
4707 {
4708     if (isReplaced()) {
4709         int result = direction == HorizontalLine ? m_marginBox.top() + height() + m_marginBox.bottom() : m_marginBox.right() + width() + m_marginBox.left();
4710         if (baselineType == AlphabeticBaseline)
4711             return result;
4712         return result - result / 2;
4713     }
4714     return 0;
4715 }
4716 
4717 
4718 RenderLayer* RenderBox::enclosingFloatPaintingLayer() const
4719 {
4720     for (auto&amp; box : lineageOfType&lt;RenderBox&gt;(*this)) {
4721         if (box.layer() &amp;&amp; box.layer()-&gt;isSelfPaintingLayer())
4722             return box.layer();
4723     }
4724     return nullptr;
4725 }
4726 
4727 LayoutRect RenderBox::logicalVisualOverflowRectForPropagation(const RenderStyle* parentStyle) const
4728 {
4729     LayoutRect rect = visualOverflowRectForPropagation(parentStyle);
4730     if (!parentStyle-&gt;isHorizontalWritingMode())
4731         return rect.transposedRect();
4732     return rect;
4733 }
4734 
4735 LayoutRect RenderBox::visualOverflowRectForPropagation(const RenderStyle* parentStyle) const
4736 {
4737     // If the writing modes of the child and parent match, then we don&#39;t have to
4738     // do anything fancy. Just return the result.
4739     LayoutRect rect = visualOverflowRect();
4740     if (parentStyle-&gt;writingMode() == style().writingMode())
4741         return rect;
4742 
4743     // We are putting ourselves into our parent&#39;s coordinate space.  If there is a flipped block mismatch
4744     // in a particular axis, then we have to flip the rect along that axis.
4745     if (style().writingMode() == RightToLeftWritingMode || parentStyle-&gt;writingMode() == RightToLeftWritingMode)
4746         rect.setX(width() - rect.maxX());
4747     else if (style().writingMode() == BottomToTopWritingMode || parentStyle-&gt;writingMode() == BottomToTopWritingMode)
4748         rect.setY(height() - rect.maxY());
4749 
4750     return rect;
4751 }
4752 
4753 LayoutRect RenderBox::logicalLayoutOverflowRectForPropagation(const RenderStyle* parentStyle) const
4754 {
4755     LayoutRect rect = layoutOverflowRectForPropagation(parentStyle);
4756     if (!parentStyle-&gt;isHorizontalWritingMode())
4757         return rect.transposedRect();
4758     return rect;
4759 }
4760 
4761 LayoutRect RenderBox::layoutOverflowRectForPropagation(const RenderStyle* parentStyle) const
4762 {
4763     // Only propagate interior layout overflow if we don&#39;t clip it.
4764     LayoutRect rect = borderBoxRect();
4765     if (!hasOverflowClip())
4766         rect.unite(layoutOverflowRect());
4767 
4768     bool hasTransform = this-&gt;hasTransform();
4769     if (isInFlowPositioned() || hasTransform) {
4770         // If we are relatively positioned or if we have a transform, then we have to convert
4771         // this rectangle into physical coordinates, apply relative positioning and transforms
4772         // to it, and then convert it back.
4773         flipForWritingMode(rect);
4774 
4775         if (hasTransform)
4776             rect = layer()-&gt;currentTransform().mapRect(rect);
4777 
4778         if (isInFlowPositioned())
4779             rect.move(offsetForInFlowPosition());
4780 
4781         // Now we need to flip back.
4782         flipForWritingMode(rect);
4783     }
4784 
4785     // If the writing modes of the child and parent match, then we don&#39;t have to
4786     // do anything fancy. Just return the result.
4787     if (parentStyle-&gt;writingMode() == style().writingMode())
4788         return rect;
4789 
4790     // We are putting ourselves into our parent&#39;s coordinate space.  If there is a flipped block mismatch
4791     // in a particular axis, then we have to flip the rect along that axis.
4792     if (style().writingMode() == RightToLeftWritingMode || parentStyle-&gt;writingMode() == RightToLeftWritingMode)
4793         rect.setX(width() - rect.maxX());
4794     else if (style().writingMode() == BottomToTopWritingMode || parentStyle-&gt;writingMode() == BottomToTopWritingMode)
4795         rect.setY(height() - rect.maxY());
4796 
4797     return rect;
4798 }
4799 
4800 LayoutRect RenderBox::flippedClientBoxRect() const
4801 {
4802     // Because of the special coordinate system used for overflow rectangles (not quite logical, not
4803     // quite physical), we need to flip the block progression coordinate in vertical-rl and
4804     // horizontal-bt writing modes. Apart from that, this method does the same as clientBoxRect().
4805 
4806     LayoutUnit left = borderLeft();
4807     LayoutUnit top = borderTop();
4808     LayoutUnit right = borderRight();
4809     LayoutUnit bottom = borderBottom();
4810     // Calculate physical padding box.
4811     LayoutRect rect(left, top, width() - left - right, height() - top - bottom);
4812     // Flip block progression axis if writing mode is vertical-rl or horizontal-bt.
4813     flipForWritingMode(rect);
4814     // Subtract space occupied by scrollbars. They are at their physical edge in this coordinate
4815     // system, so order is important here: first flip, then subtract scrollbars.
4816     if (shouldPlaceBlockDirectionScrollbarOnLeft())
4817         rect.move(verticalScrollbarWidth(), 0);
4818     rect.contract(verticalScrollbarWidth(), horizontalScrollbarHeight());
4819     return rect;
4820 }
4821 
4822 LayoutRect RenderBox::overflowRectForPaintRejection() const
4823 {
4824     LayoutRect overflowRect = visualOverflowRect();
4825 
4826     if (!m_overflow || !usesCompositedScrolling())
4827         return overflowRect;
4828 
4829     overflowRect.unite(layoutOverflowRect());
4830     overflowRect.moveBy(-scrollPosition());
4831     return overflowRect;
4832 }
4833 
4834 LayoutUnit RenderBox::offsetLeft() const
4835 {
4836     return adjustedPositionRelativeToOffsetParent(topLeftLocation()).x();
4837 }
4838 
4839 LayoutUnit RenderBox::offsetTop() const
4840 {
4841     return adjustedPositionRelativeToOffsetParent(topLeftLocation()).y();
4842 }
4843 
4844 LayoutPoint RenderBox::flipForWritingModeForChild(const RenderBox* child, const LayoutPoint&amp; point) const
4845 {
4846     if (!style().isFlippedBlocksWritingMode())
4847         return point;
4848 
4849     // The child is going to add in its x() and y(), so we have to make sure it ends up in
4850     // the right place.
4851     if (isHorizontalWritingMode())
4852         return LayoutPoint(point.x(), point.y() + height() - child-&gt;height() - (2 * child-&gt;y()));
4853     return LayoutPoint(point.x() + width() - child-&gt;width() - (2 * child-&gt;x()), point.y());
4854 }
4855 
4856 void RenderBox::flipForWritingMode(LayoutRect&amp; rect) const
4857 {
4858     if (!style().isFlippedBlocksWritingMode())
4859         return;
4860 
4861     if (isHorizontalWritingMode())
4862         rect.setY(height() - rect.maxY());
4863     else
4864         rect.setX(width() - rect.maxX());
4865 }
4866 
4867 LayoutUnit RenderBox::flipForWritingMode(LayoutUnit position) const
4868 {
4869     if (!style().isFlippedBlocksWritingMode())
4870         return position;
4871     return logicalHeight() - position;
4872 }
4873 
4874 LayoutPoint RenderBox::flipForWritingMode(const LayoutPoint&amp; position) const
4875 {
4876     if (!style().isFlippedBlocksWritingMode())
4877         return position;
4878     return isHorizontalWritingMode() ? LayoutPoint(position.x(), height() - position.y()) : LayoutPoint(width() - position.x(), position.y());
4879 }
4880 
4881 LayoutSize RenderBox::flipForWritingMode(const LayoutSize&amp; offset) const
4882 {
4883     if (!style().isFlippedBlocksWritingMode())
4884         return offset;
4885     return isHorizontalWritingMode() ? LayoutSize(offset.width(), height() - offset.height()) : LayoutSize(width() - offset.width(), offset.height());
4886 }
4887 
4888 FloatPoint RenderBox::flipForWritingMode(const FloatPoint&amp; position) const
4889 {
4890     if (!style().isFlippedBlocksWritingMode())
4891         return position;
4892     return isHorizontalWritingMode() ? FloatPoint(position.x(), height() - position.y()) : FloatPoint(width() - position.x(), position.y());
4893 }
4894 
4895 void RenderBox::flipForWritingMode(FloatRect&amp; rect) const
4896 {
4897     if (!style().isFlippedBlocksWritingMode())
4898         return;
4899 
4900     if (isHorizontalWritingMode())
4901         rect.setY(height() - rect.maxY());
4902     else
4903         rect.setX(width() - rect.maxX());
4904 }
4905 
4906 LayoutPoint RenderBox::topLeftLocation() const
4907 {
4908     if (!view().frameView().hasFlippedBlockRenderers())
4909         return location();
4910 
4911     RenderBlock* containerBlock = containingBlock();
4912     if (!containerBlock || containerBlock == this)
4913         return location();
4914     return containerBlock-&gt;flipForWritingModeForChild(this, location());
4915 }
4916 
4917 LayoutSize RenderBox::topLeftLocationOffset() const
4918 {
4919     if (!view().frameView().hasFlippedBlockRenderers())
4920         return locationOffset();
4921 
4922     RenderBlock* containerBlock = containingBlock();
4923     if (!containerBlock || containerBlock == this)
4924         return locationOffset();
4925 
4926     LayoutRect rect(frameRect());
4927     containerBlock-&gt;flipForWritingMode(rect); // FIXME: This is wrong if we are an absolutely positioned object enclosed by a relative-positioned inline.
4928     return LayoutSize(rect.x(), rect.y());
4929 }
4930 
4931 void RenderBox::applyTopLeftLocationOffsetWithFlipping(LayoutPoint&amp; point) const
4932 {
4933     RenderBlock* containerBlock = containingBlock();
4934     if (!containerBlock || containerBlock == this) {
4935         point.move(m_frameRect.x(), m_frameRect.y());
4936         return;
4937     }
4938 
4939     LayoutRect rect(frameRect());
4940     containerBlock-&gt;flipForWritingMode(rect); // FIXME: This is wrong if we are an absolutely positioned object  enclosed by a relative-positioned inline.
4941     point.move(rect.x(), rect.y());
4942 }
4943 
4944 bool RenderBox::hasRelativeDimensions() const
4945 {
4946     return style().height().isPercentOrCalculated() || style().width().isPercentOrCalculated()
4947         || style().maxHeight().isPercentOrCalculated() || style().maxWidth().isPercentOrCalculated()
4948         || style().minHeight().isPercentOrCalculated() || style().minWidth().isPercentOrCalculated();
4949 }
4950 
4951 bool RenderBox::hasRelativeLogicalHeight() const
4952 {
4953     return style().logicalHeight().isPercentOrCalculated()
4954         || style().logicalMinHeight().isPercentOrCalculated()
4955         || style().logicalMaxHeight().isPercentOrCalculated();
4956 }
4957 
4958 bool RenderBox::hasRelativeLogicalWidth() const
4959 {
4960     return style().logicalWidth().isPercentOrCalculated()
4961         || style().logicalMinWidth().isPercentOrCalculated()
4962         || style().logicalMaxWidth().isPercentOrCalculated();
4963 }
4964 
4965 LayoutUnit RenderBox::offsetFromLogicalTopOfFirstPage() const
4966 {
4967     auto* layoutState = view().frameView().layoutContext().layoutState();
4968     if ((layoutState &amp;&amp; !layoutState-&gt;isPaginated()) || (!layoutState &amp;&amp; !enclosingFragmentedFlow()))
4969         return 0;
4970 
4971     RenderBlock* containerBlock = containingBlock();
4972     return containerBlock-&gt;offsetFromLogicalTopOfFirstPage() + logicalTop();
4973 }
4974 
4975 const RenderBox* RenderBox::findEnclosingScrollableContainer() const
4976 {
4977     for (auto&amp; candidate : lineageOfType&lt;RenderBox&gt;(*this)) {
4978         if (candidate.hasOverflowClip())
4979             return &amp;candidate;
4980     }
4981     // If all parent elements are not overflow scrollable, check the body.
4982     if (document().body() &amp;&amp; frame().mainFrame().view() &amp;&amp; frame().mainFrame().view()-&gt;isScrollable())
4983         return document().body()-&gt;renderBox();
4984 
4985     return nullptr;
4986 }
4987 
4988 } // namespace WebCore
<a name="21" id="anc21"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="21" type="hidden" />
</body>
</html>