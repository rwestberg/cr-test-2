<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/assembler/MIPSAssembler.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2009-2017 Apple Inc. All rights reserved.
   3  * Copyright (C) 2009 University of Szeged
   4  * All rights reserved.
   5  * Copyright (C) 2010 MIPS Technologies, Inc. All rights reserved.
   6  *
   7  * Redistribution and use in source and binary forms, with or without
   8  * modification, are permitted provided that the following conditions
   9  * are met:
  10  * 1. Redistributions of source code must retain the above copyright
  11  *    notice, this list of conditions and the following disclaimer.
  12  * 2. Redistributions in binary form must reproduce the above copyright
  13  *    notice, this list of conditions and the following disclaimer in the
  14  *    documentation and/or other materials provided with the distribution.
  15  *
  16  * THIS SOFTWARE IS PROVIDED BY MIPS TECHNOLOGIES, INC. ``AS IS&#39;&#39; AND ANY
  17  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  18  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  19  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL MIPS TECHNOLOGIES, INC. OR
  20  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  21  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  22  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  23  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  24  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  25  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  26  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  27  */
  28 
  29 #pragma once
  30 
  31 #if ENABLE(ASSEMBLER) &amp;&amp; CPU(MIPS)
  32 
  33 #include &quot;AssemblerBuffer.h&quot;
  34 #include &quot;JITCompilationEffort.h&quot;
<a name="1" id="anc1"></a>
  35 #include &lt;limits.h&gt;
  36 #include &lt;wtf/Assertions.h&gt;
  37 #include &lt;wtf/SegmentedVector.h&gt;
  38 
  39 namespace JSC {
  40 
  41 typedef uint32_t MIPSWord;
  42 
<a name="2" id="anc2"></a><span class="line-modified">  43 namespace MIPSRegisters {</span>
  44 typedef enum : int8_t {
<a name="3" id="anc3"></a><span class="line-modified">  45     r0 = 0,</span>
<span class="line-modified">  46     r1,</span>
<span class="line-modified">  47     r2,</span>
<span class="line-modified">  48     r3,</span>
<span class="line-modified">  49     r4,</span>
<span class="line-modified">  50     r5,</span>
<span class="line-removed">  51     r6,</span>
<span class="line-removed">  52     r7,</span>
<span class="line-removed">  53     r8,</span>
<span class="line-removed">  54     r9,</span>
<span class="line-removed">  55     r10,</span>
<span class="line-removed">  56     r11,</span>
<span class="line-removed">  57     r12,</span>
<span class="line-removed">  58     r13,</span>
<span class="line-removed">  59     r14,</span>
<span class="line-removed">  60     r15,</span>
<span class="line-removed">  61     r16,</span>
<span class="line-removed">  62     r17,</span>
<span class="line-removed">  63     r18,</span>
<span class="line-removed">  64     r19,</span>
<span class="line-removed">  65     r20,</span>
<span class="line-removed">  66     r21,</span>
<span class="line-removed">  67     r22,</span>
<span class="line-removed">  68     r23,</span>
<span class="line-removed">  69     r24,</span>
<span class="line-removed">  70     r25,</span>
<span class="line-removed">  71     r26,</span>
<span class="line-removed">  72     r27,</span>
<span class="line-removed">  73     r28,</span>
<span class="line-removed">  74     r29,</span>
<span class="line-removed">  75     r30,</span>
<span class="line-removed">  76     r31,</span>
<span class="line-removed">  77     zero = r0,</span>
<span class="line-removed">  78     at = r1,</span>
<span class="line-removed">  79     v0 = r2,</span>
<span class="line-removed">  80     v1 = r3,</span>
<span class="line-removed">  81     a0 = r4,</span>
<span class="line-removed">  82     a1 = r5,</span>
<span class="line-removed">  83     a2 = r6,</span>
<span class="line-removed">  84     a3 = r7,</span>
<span class="line-removed">  85     t0 = r8,</span>
<span class="line-removed">  86     t1 = r9,</span>
<span class="line-removed">  87     t2 = r10,</span>
<span class="line-removed">  88     t3 = r11,</span>
<span class="line-removed">  89     t4 = r12,</span>
<span class="line-removed">  90     t5 = r13,</span>
<span class="line-removed">  91     t6 = r14,</span>
<span class="line-removed">  92     t7 = r15,</span>
<span class="line-removed">  93     s0 = r16,</span>
<span class="line-removed">  94     s1 = r17,</span>
<span class="line-removed">  95     s2 = r18,</span>
<span class="line-removed">  96     s3 = r19,</span>
<span class="line-removed">  97     s4 = r20,</span>
<span class="line-removed">  98     s5 = r21,</span>
<span class="line-removed">  99     s6 = r22,</span>
<span class="line-removed"> 100     s7 = r23,</span>
<span class="line-removed"> 101     t8 = r24,</span>
<span class="line-removed"> 102     t9 = r25,</span>
<span class="line-removed"> 103     k0 = r26,</span>
<span class="line-removed"> 104     k1 = r27,</span>
<span class="line-removed"> 105     gp = r28,</span>
<span class="line-removed"> 106     sp = r29,</span>
<span class="line-removed"> 107     fp = r30,</span>
<span class="line-removed"> 108     ra = r31,</span>
 109     InvalidGPRReg = -1,
 110 } RegisterID;
 111 
 112 typedef enum : int8_t {
<a name="4" id="anc4"></a><span class="line-modified"> 113     fir = 0,</span>
<span class="line-modified"> 114     fccr = 25,</span>
<span class="line-modified"> 115     fexr = 26,</span>
<span class="line-removed"> 116     fenr = 28,</span>
<span class="line-removed"> 117     fcsr = 31,</span>
<span class="line-removed"> 118     pc</span>
 119 } SPRegisterID;
 120 
 121 typedef enum : int8_t {
<a name="5" id="anc5"></a><span class="line-modified"> 122     f0,</span>
<span class="line-modified"> 123     f1,</span>
<span class="line-modified"> 124     f2,</span>
<span class="line-removed"> 125     f3,</span>
<span class="line-removed"> 126     f4,</span>
<span class="line-removed"> 127     f5,</span>
<span class="line-removed"> 128     f6,</span>
<span class="line-removed"> 129     f7,</span>
<span class="line-removed"> 130     f8,</span>
<span class="line-removed"> 131     f9,</span>
<span class="line-removed"> 132     f10,</span>
<span class="line-removed"> 133     f11,</span>
<span class="line-removed"> 134     f12,</span>
<span class="line-removed"> 135     f13,</span>
<span class="line-removed"> 136     f14,</span>
<span class="line-removed"> 137     f15,</span>
<span class="line-removed"> 138     f16,</span>
<span class="line-removed"> 139     f17,</span>
<span class="line-removed"> 140     f18,</span>
<span class="line-removed"> 141     f19,</span>
<span class="line-removed"> 142     f20,</span>
<span class="line-removed"> 143     f21,</span>
<span class="line-removed"> 144     f22,</span>
<span class="line-removed"> 145     f23,</span>
<span class="line-removed"> 146     f24,</span>
<span class="line-removed"> 147     f25,</span>
<span class="line-removed"> 148     f26,</span>
<span class="line-removed"> 149     f27,</span>
<span class="line-removed"> 150     f28,</span>
<span class="line-removed"> 151     f29,</span>
<span class="line-removed"> 152     f30,</span>
<span class="line-removed"> 153     f31,</span>
 154     InvalidFPRReg = -1,
 155 } FPRegisterID;
 156 
 157 } // namespace MIPSRegisters
 158 
 159 class MIPSAssembler {
 160 public:
 161     typedef MIPSRegisters::RegisterID RegisterID;
 162     typedef MIPSRegisters::SPRegisterID SPRegisterID;
 163     typedef MIPSRegisters::FPRegisterID FPRegisterID;
 164     typedef SegmentedVector&lt;AssemblerLabel, 64&gt; Jumps;
 165 
 166     static constexpr RegisterID firstRegister() { return MIPSRegisters::r0; }
 167     static constexpr RegisterID lastRegister() { return MIPSRegisters::r31; }
 168     static constexpr unsigned numberOfRegisters() { return lastRegister() - firstRegister() + 1; }
 169 
 170     static constexpr SPRegisterID firstSPRegister() { return MIPSRegisters::fir; }
 171     static constexpr SPRegisterID lastSPRegister() { return MIPSRegisters::pc; }
 172     static constexpr unsigned numberOfSPRegisters() { return lastSPRegister() - firstSPRegister() + 1; }
 173 
 174     static constexpr FPRegisterID firstFPRegister() { return MIPSRegisters::f0; }
 175     static constexpr FPRegisterID lastFPRegister() { return MIPSRegisters::f31; }
 176     static constexpr unsigned numberOfFPRegisters() { return lastFPRegister() - firstFPRegister() + 1; }
 177 
 178     static const char* gprName(RegisterID id)
 179     {
 180         ASSERT(id &gt;= firstRegister() &amp;&amp; id &lt;= lastRegister());
 181         static const char* const nameForRegister[numberOfRegisters()] = {
<a name="6" id="anc6"></a><span class="line-modified"> 182             &quot;zero&quot;, &quot;at&quot;, &quot;v0&quot;, &quot;v1&quot;,</span>
<span class="line-modified"> 183             &quot;a0&quot;, &quot;a1&quot;, &quot;a2&quot;, &quot;a3&quot;,</span>
<span class="line-modified"> 184             &quot;t0&quot;, &quot;t1&quot;, &quot;t2&quot;, &quot;t3&quot;,</span>
<span class="line-removed"> 185             &quot;t4&quot;, &quot;t5&quot;, &quot;t6&quot;, &quot;t7&quot;</span>
 186         };
 187         return nameForRegister[id];
 188     }
 189 
 190     static const char* sprName(SPRegisterID id)
 191     {
<a name="7" id="anc7"></a><span class="line-modified"> 192         switch (id) {</span>
<span class="line-modified"> 193         case MIPSRegisters::fir:</span>
<span class="line-modified"> 194             return &quot;fir&quot;;</span>
<span class="line-modified"> 195         case MIPSRegisters::fccr:</span>
<span class="line-modified"> 196             return &quot;fccr&quot;;</span>
<span class="line-modified"> 197         case MIPSRegisters::fexr:</span>
<span class="line-modified"> 198             return &quot;fexr&quot;;</span>
<span class="line-removed"> 199         case MIPSRegisters::fenr:</span>
<span class="line-removed"> 200             return &quot;fenr&quot;;</span>
<span class="line-removed"> 201         case MIPSRegisters::fcsr:</span>
<span class="line-removed"> 202             return &quot;fcsr&quot;;</span>
<span class="line-removed"> 203         case MIPSRegisters::pc:</span>
<span class="line-removed"> 204             return &quot;pc&quot;;</span>
<span class="line-removed"> 205         default:</span>
<span class="line-removed"> 206             RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-removed"> 207         }</span>
 208     }
 209 
 210     static const char* fprName(FPRegisterID id)
 211     {
 212         ASSERT(id &gt;= firstFPRegister() &amp;&amp; id &lt;= lastFPRegister());
 213         static const char* const nameForRegister[numberOfFPRegisters()] = {
<a name="8" id="anc8"></a><span class="line-modified"> 214             &quot;f0&quot;, &quot;f1&quot;, &quot;f2&quot;, &quot;f3&quot;,</span>
<span class="line-modified"> 215             &quot;f4&quot;, &quot;f5&quot;, &quot;f6&quot;, &quot;f7&quot;,</span>
<span class="line-modified"> 216             &quot;f8&quot;, &quot;f9&quot;, &quot;f10&quot;, &quot;f11&quot;,</span>
<span class="line-removed"> 217             &quot;f12&quot;, &quot;f13&quot;, &quot;f14&quot;, &quot;f15&quot;</span>
<span class="line-removed"> 218             &quot;f16&quot;, &quot;f17&quot;, &quot;f18&quot;, &quot;f19&quot;</span>
<span class="line-removed"> 219             &quot;f20&quot;, &quot;f21&quot;, &quot;f22&quot;, &quot;f23&quot;</span>
<span class="line-removed"> 220             &quot;f24&quot;, &quot;f25&quot;, &quot;f26&quot;, &quot;f27&quot;</span>
<span class="line-removed"> 221             &quot;f28&quot;, &quot;f29&quot;, &quot;f30&quot;, &quot;f31&quot;</span>
 222         };
 223         return nameForRegister[id];
 224     }
 225 
 226     MIPSAssembler()
 227         : m_indexOfLastWatchpoint(INT_MIN)
 228         , m_indexOfTailOfLastWatchpoint(INT_MIN)
 229     {
 230     }
 231 
 232     AssemblerBuffer&amp; buffer() { return m_buffer; }
 233 
 234     // MIPS instruction opcode field position
 235     enum {
 236         OP_SH_RD = 11,
 237         OP_SH_RT = 16,
 238         OP_SH_RS = 21,
 239         OP_SH_SHAMT = 6,
 240         OP_SH_CODE = 16,
 241         OP_SH_FD = 6,
 242         OP_SH_FS = 11,
 243         OP_SH_FT = 16,
 244         OP_SH_MSB = 11,
 245         OP_SH_LSB = 6
 246     };
 247 
 248     // FCSR Bits
 249     enum {
 250         FP_CAUSE_INVALID_OPERATION = 1 &lt;&lt; 16
 251     };
 252 
 253     void emitInst(MIPSWord op)
 254     {
 255         void* oldBase = m_buffer.data();
 256 
 257         m_buffer.putInt(op);
 258 
 259         void* newBase = m_buffer.data();
 260         if (oldBase != newBase)
 261             relocateJumps(oldBase, newBase);
 262     }
 263 
 264     void nop()
 265     {
 266         emitInst(0x00000000);
 267     }
 268 
 269     template &lt;typename CopyFunction&gt;
 270     static void fillNops(void* base, size_t size, CopyFunction copy)
 271     {
 272         UNUSED_PARAM(copy);
 273         RELEASE_ASSERT(!(size % sizeof(int32_t)));
 274 
 275         int32_t* ptr = static_cast&lt;int32_t*&gt;(base);
 276         const size_t num32s = size / sizeof(int32_t);
 277         const int32_t insn = 0x00000000;
 278         for (size_t i = 0; i &lt; num32s; i++)
 279             *ptr++ = insn;
 280     }
 281 
 282     void sync()
 283     {
 284         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=169984
 285         // We might get a performance improvements by using SYNC_MB in some or
 286         // all cases.
 287         emitInst(0x0000000f);
 288     }
 289 
 290     /* Need to insert one load data delay nop for mips1.  */
 291     void loadDelayNop()
 292     {
 293 #if WTF_MIPS_ISA(1)
 294         nop();
 295 #endif
 296     }
 297 
 298     /* Need to insert one coprocessor access delay nop for mips1.  */
 299     void copDelayNop()
 300     {
 301 #if WTF_MIPS_ISA(1)
 302         nop();
 303 #endif
 304     }
 305 
 306     void move(RegisterID rd, RegisterID rs)
 307     {
 308         /* addu */
 309         emitInst(0x00000021 | (rd &lt;&lt; OP_SH_RD) | (rs &lt;&lt; OP_SH_RS));
 310     }
 311 
 312     /* Set an immediate value to a register.  This may generate 1 or 2
 313        instructions.  */
 314     void li(RegisterID dest, int imm)
 315     {
 316         if (imm &gt;= -32768 &amp;&amp; imm &lt;= 32767)
 317             addiu(dest, MIPSRegisters::zero, imm);
 318         else if (imm &gt;= 0 &amp;&amp; imm &lt; 65536)
 319             ori(dest, MIPSRegisters::zero, imm);
 320         else {
 321             lui(dest, imm &gt;&gt; 16);
 322             if (imm &amp; 0xffff)
 323                 ori(dest, dest, imm);
 324         }
 325     }
 326 
 327     void ext(RegisterID rt, RegisterID rs, int pos, int size)
 328     {
 329         int msb = size - 1;
 330         emitInst(0x7c000000 | (rt &lt;&lt; OP_SH_RT) | (rs &lt;&lt; OP_SH_RS) | (pos &lt;&lt; OP_SH_LSB) | (msb &lt;&lt; OP_SH_MSB));
 331     }
 332 
 333     void mfhc1(RegisterID rt, FPRegisterID fs)
 334     {
 335         emitInst(0x4460000 | (rt &lt;&lt; OP_SH_RT) | (fs &lt;&lt; OP_SH_FS));
 336     }
 337 
 338     void lui(RegisterID rt, int imm)
 339     {
 340         emitInst(0x3c000000 | (rt &lt;&lt; OP_SH_RT) | (imm &amp; 0xffff));
 341     }
 342 
 343     void clz(RegisterID rd, RegisterID rs)
 344     {
 345         emitInst(0x70000020 | (rd &lt;&lt; OP_SH_RD) | (rs &lt;&lt; OP_SH_RS) | (rd &lt;&lt; OP_SH_RT));
 346     }
 347 
 348     void addiu(RegisterID rt, RegisterID rs, int imm)
 349     {
 350         emitInst(0x24000000 | (rt &lt;&lt; OP_SH_RT) | (rs &lt;&lt; OP_SH_RS) | (imm &amp; 0xffff));
 351     }
 352 
 353     void addu(RegisterID rd, RegisterID rs, RegisterID rt)
 354     {
 355         emitInst(0x00000021 | (rd &lt;&lt; OP_SH_RD) | (rs &lt;&lt; OP_SH_RS) | (rt &lt;&lt; OP_SH_RT));
 356     }
 357 
 358     void subu(RegisterID rd, RegisterID rs, RegisterID rt)
 359     {
 360         emitInst(0x00000023 | (rd &lt;&lt; OP_SH_RD) | (rs &lt;&lt; OP_SH_RS) | (rt &lt;&lt; OP_SH_RT));
 361     }
 362 
 363     void mult(RegisterID rs, RegisterID rt)
 364     {
 365         emitInst(0x00000018 | (rs &lt;&lt; OP_SH_RS) | (rt &lt;&lt; OP_SH_RT));
 366     }
 367 
 368     void div(RegisterID rs, RegisterID rt)
 369     {
 370         emitInst(0x0000001a | (rs &lt;&lt; OP_SH_RS) | (rt &lt;&lt; OP_SH_RT));
 371     }
 372 
 373     void mfhi(RegisterID rd)
 374     {
 375         emitInst(0x00000010 | (rd &lt;&lt; OP_SH_RD));
 376     }
 377 
 378     void mflo(RegisterID rd)
 379     {
 380         emitInst(0x00000012 | (rd &lt;&lt; OP_SH_RD));
 381     }
 382 
 383     void mul(RegisterID rd, RegisterID rs, RegisterID rt)
 384     {
 385 #if WTF_MIPS_ISA_AT_LEAST(32)
 386         emitInst(0x70000002 | (rd &lt;&lt; OP_SH_RD) | (rs &lt;&lt; OP_SH_RS) | (rt &lt;&lt; OP_SH_RT));
 387 #else
 388         mult(rs, rt);
 389         mflo(rd);
 390 #endif
 391     }
 392 
 393     void andInsn(RegisterID rd, RegisterID rs, RegisterID rt)
 394     {
 395         emitInst(0x00000024 | (rd &lt;&lt; OP_SH_RD) | (rs &lt;&lt; OP_SH_RS) | (rt &lt;&lt; OP_SH_RT));
 396     }
 397 
 398     void andi(RegisterID rt, RegisterID rs, int imm)
 399     {
 400         emitInst(0x30000000 | (rt &lt;&lt; OP_SH_RT) | (rs &lt;&lt; OP_SH_RS) | (imm &amp; 0xffff));
 401     }
 402 
 403     void nor(RegisterID rd, RegisterID rs, RegisterID rt)
 404     {
 405         emitInst(0x00000027 | (rd &lt;&lt; OP_SH_RD) | (rs &lt;&lt; OP_SH_RS) | (rt &lt;&lt; OP_SH_RT));
 406     }
 407 
 408     void orInsn(RegisterID rd, RegisterID rs, RegisterID rt)
 409     {
 410         emitInst(0x00000025 | (rd &lt;&lt; OP_SH_RD) | (rs &lt;&lt; OP_SH_RS) | (rt &lt;&lt; OP_SH_RT));
 411     }
 412 
 413     void ori(RegisterID rt, RegisterID rs, int imm)
 414     {
 415         emitInst(0x34000000 | (rt &lt;&lt; OP_SH_RT) | (rs &lt;&lt; OP_SH_RS) | (imm &amp; 0xffff));
 416     }
 417 
 418     void xorInsn(RegisterID rd, RegisterID rs, RegisterID rt)
 419     {
 420         emitInst(0x00000026 | (rd &lt;&lt; OP_SH_RD) | (rs &lt;&lt; OP_SH_RS) | (rt &lt;&lt; OP_SH_RT));
 421     }
 422 
 423     void xori(RegisterID rt, RegisterID rs, int imm)
 424     {
 425         emitInst(0x38000000 | (rt &lt;&lt; OP_SH_RT) | (rs &lt;&lt; OP_SH_RS) | (imm &amp; 0xffff));
 426     }
 427 
 428     void slt(RegisterID rd, RegisterID rs, RegisterID rt)
 429     {
 430         emitInst(0x0000002a | (rd &lt;&lt; OP_SH_RD) | (rs &lt;&lt; OP_SH_RS) | (rt &lt;&lt; OP_SH_RT));
 431     }
 432 
 433     void sltu(RegisterID rd, RegisterID rs, RegisterID rt)
 434     {
 435         emitInst(0x0000002b | (rd &lt;&lt; OP_SH_RD) | (rs &lt;&lt; OP_SH_RS) | (rt &lt;&lt; OP_SH_RT));
 436     }
 437 
 438     void slti(RegisterID rt, RegisterID rs, int imm)
 439     {
 440         emitInst(0x28000000 | (rt &lt;&lt; OP_SH_RT) | (rs &lt;&lt; OP_SH_RS) | (imm &amp; 0xffff));
 441     }
 442 
 443     void sltiu(RegisterID rt, RegisterID rs, int imm)
 444     {
 445         emitInst(0x2c000000 | (rt &lt;&lt; OP_SH_RT) | (rs &lt;&lt; OP_SH_RS) | (imm &amp; 0xffff));
 446     }
 447 
 448     void sll(RegisterID rd, RegisterID rt, int shamt)
 449     {
 450         emitInst(0x00000000 | (rd &lt;&lt; OP_SH_RD) | (rt &lt;&lt; OP_SH_RT) | ((shamt &amp; 0x1f) &lt;&lt; OP_SH_SHAMT));
 451     }
 452 
 453     void sllv(RegisterID rd, RegisterID rt, RegisterID rs)
 454     {
 455         emitInst(0x00000004 | (rd &lt;&lt; OP_SH_RD) | (rt &lt;&lt; OP_SH_RT) | (rs &lt;&lt; OP_SH_RS));
 456     }
 457 
 458     void sra(RegisterID rd, RegisterID rt, int shamt)
 459     {
 460         emitInst(0x00000003 | (rd &lt;&lt; OP_SH_RD) | (rt &lt;&lt; OP_SH_RT) | ((shamt &amp; 0x1f) &lt;&lt; OP_SH_SHAMT));
 461     }
 462 
 463     void srav(RegisterID rd, RegisterID rt, RegisterID rs)
 464     {
 465         emitInst(0x00000007 | (rd &lt;&lt; OP_SH_RD) | (rt &lt;&lt; OP_SH_RT) | (rs &lt;&lt; OP_SH_RS));
 466     }
 467 
 468     void srl(RegisterID rd, RegisterID rt, int shamt)
 469     {
 470         emitInst(0x00000002 | (rd &lt;&lt; OP_SH_RD) | (rt &lt;&lt; OP_SH_RT) | ((shamt &amp; 0x1f) &lt;&lt; OP_SH_SHAMT));
 471     }
 472 
 473     void srlv(RegisterID rd, RegisterID rt, RegisterID rs)
 474     {
 475         emitInst(0x00000006 | (rd &lt;&lt; OP_SH_RD) | (rt &lt;&lt; OP_SH_RT) | (rs &lt;&lt; OP_SH_RS));
 476     }
 477 
 478     void lb(RegisterID rt, RegisterID rs, int offset)
 479     {
 480         emitInst(0x80000000 | (rt &lt;&lt; OP_SH_RT) | (rs &lt;&lt; OP_SH_RS) | (offset &amp; 0xffff));
 481         loadDelayNop();
 482     }
 483 
 484     void lbu(RegisterID rt, RegisterID rs, int offset)
 485     {
 486         emitInst(0x90000000 | (rt &lt;&lt; OP_SH_RT) | (rs &lt;&lt; OP_SH_RS) | (offset &amp; 0xffff));
 487         loadDelayNop();
 488     }
 489 
 490     void lw(RegisterID rt, RegisterID rs, int offset)
 491     {
 492         emitInst(0x8c000000 | (rt &lt;&lt; OP_SH_RT) | (rs &lt;&lt; OP_SH_RS) | (offset &amp; 0xffff));
 493         loadDelayNop();
 494     }
 495 
 496     void lwl(RegisterID rt, RegisterID rs, int offset)
 497     {
 498         emitInst(0x88000000 | (rt &lt;&lt; OP_SH_RT) | (rs &lt;&lt; OP_SH_RS) | (offset &amp; 0xffff));
 499         loadDelayNop();
 500     }
 501 
 502     void lwr(RegisterID rt, RegisterID rs, int offset)
 503     {
 504         emitInst(0x98000000 | (rt &lt;&lt; OP_SH_RT) | (rs &lt;&lt; OP_SH_RS) | (offset &amp; 0xffff));
 505         loadDelayNop();
 506     }
 507 
 508     void lh(RegisterID rt, RegisterID rs, int offset)
 509     {
 510         emitInst(0x84000000 | (rt &lt;&lt; OP_SH_RT) | (rs &lt;&lt; OP_SH_RS) | (offset &amp; 0xffff));
 511         loadDelayNop();
 512     }
 513 
 514     void lhu(RegisterID rt, RegisterID rs, int offset)
 515     {
 516         emitInst(0x94000000 | (rt &lt;&lt; OP_SH_RT) | (rs &lt;&lt; OP_SH_RS) | (offset &amp; 0xffff));
 517         loadDelayNop();
 518     }
 519 
 520     void sb(RegisterID rt, RegisterID rs, int offset)
 521     {
 522         emitInst(0xa0000000 | (rt &lt;&lt; OP_SH_RT) | (rs &lt;&lt; OP_SH_RS) | (offset &amp; 0xffff));
 523     }
 524 
 525     void sh(RegisterID rt, RegisterID rs, int offset)
 526     {
 527         emitInst(0xa4000000 | (rt &lt;&lt; OP_SH_RT) | (rs &lt;&lt; OP_SH_RS) | (offset &amp; 0xffff));
 528     }
 529 
 530     void sw(RegisterID rt, RegisterID rs, int offset)
 531     {
 532         emitInst(0xac000000 | (rt &lt;&lt; OP_SH_RT) | (rs &lt;&lt; OP_SH_RS) | (offset &amp; 0xffff));
 533     }
 534 
 535     void jr(RegisterID rs)
 536     {
 537         emitInst(0x00000008 | (rs &lt;&lt; OP_SH_RS));
 538     }
 539 
 540     void jalr(RegisterID rs)
 541     {
 542         emitInst(0x0000f809 | (rs &lt;&lt; OP_SH_RS));
 543     }
 544 
 545     void jal()
 546     {
 547         emitInst(0x0c000000);
 548     }
 549 
 550     void bkpt()
 551     {
 552         int value = 512; /* BRK_BUG */
 553         emitInst(0x0000000d | ((value &amp; 0x3ff) &lt;&lt; OP_SH_CODE));
 554     }
 555 
 556     static bool isBkpt(void* address)
 557     {
 558         int value = 512; /* BRK_BUG */
 559         MIPSWord expected = (0x0000000d | ((value &amp; 0x3ff) &lt;&lt; OP_SH_CODE));
 560         MIPSWord candidateInstruction = *reinterpret_cast&lt;MIPSWord*&gt;(address);
 561         return candidateInstruction == expected;
 562     }
 563 
 564     void bgez(RegisterID rs, int imm)
 565     {
 566         emitInst(0x04010000 | (rs &lt;&lt; OP_SH_RS) | (imm &amp; 0xffff));
 567     }
 568 
 569     void bltz(RegisterID rs, int imm)
 570     {
 571         emitInst(0x04000000 | (rs &lt;&lt; OP_SH_RS) | (imm &amp; 0xffff));
 572     }
 573 
 574     void beq(RegisterID rs, RegisterID rt, int imm)
 575     {
 576         emitInst(0x10000000 | (rs &lt;&lt; OP_SH_RS) | (rt &lt;&lt; OP_SH_RT) | (imm &amp; 0xffff));
 577     }
 578 
 579     void bne(RegisterID rs, RegisterID rt, int imm)
 580     {
 581         emitInst(0x14000000 | (rs &lt;&lt; OP_SH_RS) | (rt &lt;&lt; OP_SH_RT) | (imm &amp; 0xffff));
 582     }
 583 
 584     void bc1t()
 585     {
 586         emitInst(0x45010000);
 587     }
 588 
 589     void bc1f()
 590     {
 591         emitInst(0x45000000);
 592     }
 593 
 594     void appendJump()
 595     {
 596         m_jumps.append(m_buffer.label());
 597     }
 598 
 599     void addd(FPRegisterID fd, FPRegisterID fs, FPRegisterID ft)
 600     {
 601         emitInst(0x46200000 | (fd &lt;&lt; OP_SH_FD) | (fs &lt;&lt; OP_SH_FS) | (ft &lt;&lt; OP_SH_FT));
 602     }
 603 
 604     void subd(FPRegisterID fd, FPRegisterID fs, FPRegisterID ft)
 605     {
 606         emitInst(0x46200001 | (fd &lt;&lt; OP_SH_FD) | (fs &lt;&lt; OP_SH_FS) | (ft &lt;&lt; OP_SH_FT));
 607     }
 608 
 609     void muld(FPRegisterID fd, FPRegisterID fs, FPRegisterID ft)
 610     {
 611         emitInst(0x46200002 | (fd &lt;&lt; OP_SH_FD) | (fs &lt;&lt; OP_SH_FS) | (ft &lt;&lt; OP_SH_FT));
 612     }
 613 
 614     void divd(FPRegisterID fd, FPRegisterID fs, FPRegisterID ft)
 615     {
 616         emitInst(0x46200003 | (fd &lt;&lt; OP_SH_FD) | (fs &lt;&lt; OP_SH_FS) | (ft &lt;&lt; OP_SH_FT));
 617     }
 618 
 619     void lwc1(FPRegisterID ft, RegisterID rs, int offset)
 620     {
 621         emitInst(0xc4000000 | (ft &lt;&lt; OP_SH_FT) | (rs &lt;&lt; OP_SH_RS) | (offset &amp; 0xffff));
 622         copDelayNop();
 623     }
 624 
 625     void ldc1(FPRegisterID ft, RegisterID rs, int offset)
 626     {
 627         emitInst(0xd4000000 | (ft &lt;&lt; OP_SH_FT) | (rs &lt;&lt; OP_SH_RS) | (offset &amp; 0xffff));
 628     }
 629 
 630     void swc1(FPRegisterID ft, RegisterID rs, int offset)
 631     {
 632         emitInst(0xe4000000 | (ft &lt;&lt; OP_SH_FT) | (rs &lt;&lt; OP_SH_RS) | (offset &amp; 0xffff));
 633     }
 634 
 635     void sdc1(FPRegisterID ft, RegisterID rs, int offset)
 636     {
 637         emitInst(0xf4000000 | (ft &lt;&lt; OP_SH_FT) | (rs &lt;&lt; OP_SH_RS) | (offset &amp; 0xffff));
 638     }
 639 
 640     void mtc1(RegisterID rt, FPRegisterID fs)
 641     {
 642         emitInst(0x44800000 | (fs &lt;&lt; OP_SH_FS) | (rt &lt;&lt; OP_SH_RT));
 643         copDelayNop();
 644     }
 645 
 646     void mthc1(RegisterID rt, FPRegisterID fs)
 647     {
 648         emitInst(0x44e00000 | (fs &lt;&lt; OP_SH_FS) | (rt &lt;&lt; OP_SH_RT));
 649         copDelayNop();
 650     }
 651 
 652     void mfc1(RegisterID rt, FPRegisterID fs)
 653     {
 654         emitInst(0x44000000 | (fs &lt;&lt; OP_SH_FS) | (rt &lt;&lt; OP_SH_RT));
 655         copDelayNop();
 656     }
 657 
 658     void sqrtd(FPRegisterID fd, FPRegisterID fs)
 659     {
 660         emitInst(0x46200004 | (fd &lt;&lt; OP_SH_FD) | (fs &lt;&lt; OP_SH_FS));
 661     }
 662 
 663     void absd(FPRegisterID fd, FPRegisterID fs)
 664     {
 665         emitInst(0x46200005 | (fd &lt;&lt; OP_SH_FD) | (fs &lt;&lt; OP_SH_FS));
 666     }
 667 
 668     void movd(FPRegisterID fd, FPRegisterID fs)
 669     {
 670         emitInst(0x46200006 | (fd &lt;&lt; OP_SH_FD) | (fs &lt;&lt; OP_SH_FS));
 671     }
 672 
 673     void negd(FPRegisterID fd, FPRegisterID fs)
 674     {
 675         emitInst(0x46200007 | (fd &lt;&lt; OP_SH_FD) | (fs &lt;&lt; OP_SH_FS));
 676     }
 677 
 678     void truncwd(FPRegisterID fd, FPRegisterID fs)
 679     {
 680         emitInst(0x4620000d | (fd &lt;&lt; OP_SH_FD) | (fs &lt;&lt; OP_SH_FS));
 681     }
 682 
 683     void cvtdw(FPRegisterID fd, FPRegisterID fs)
 684     {
 685         emitInst(0x46800021 | (fd &lt;&lt; OP_SH_FD) | (fs &lt;&lt; OP_SH_FS));
 686     }
 687 
 688     void cvtds(FPRegisterID fd, FPRegisterID fs)
 689     {
 690         emitInst(0x46000021 | (fd &lt;&lt; OP_SH_FD) | (fs &lt;&lt; OP_SH_FS));
 691     }
 692 
 693     void cvtwd(FPRegisterID fd, FPRegisterID fs)
 694     {
 695         emitInst(0x46200024 | (fd &lt;&lt; OP_SH_FD) | (fs &lt;&lt; OP_SH_FS));
 696     }
 697 
 698     void cvtsd(FPRegisterID fd, FPRegisterID fs)
 699     {
 700         emitInst(0x46200020 | (fd &lt;&lt; OP_SH_FD) | (fs &lt;&lt; OP_SH_FS));
 701     }
 702 
 703     void ceqd(FPRegisterID fs, FPRegisterID ft)
 704     {
 705         emitInst(0x46200032 | (fs &lt;&lt; OP_SH_FS) | (ft &lt;&lt; OP_SH_FT));
 706         copDelayNop();
 707     }
 708 
 709     void cngtd(FPRegisterID fs, FPRegisterID ft)
 710     {
 711         emitInst(0x4620003f | (fs &lt;&lt; OP_SH_FS) | (ft &lt;&lt; OP_SH_FT));
 712         copDelayNop();
 713     }
 714 
 715     void cnged(FPRegisterID fs, FPRegisterID ft)
 716     {
 717         emitInst(0x4620003d | (fs &lt;&lt; OP_SH_FS) | (ft &lt;&lt; OP_SH_FT));
 718         copDelayNop();
 719     }
 720 
 721     void cltd(FPRegisterID fs, FPRegisterID ft)
 722     {
 723         emitInst(0x4620003c | (fs &lt;&lt; OP_SH_FS) | (ft &lt;&lt; OP_SH_FT));
 724         copDelayNop();
 725     }
 726 
 727     void cled(FPRegisterID fs, FPRegisterID ft)
 728     {
 729         emitInst(0x4620003e | (fs &lt;&lt; OP_SH_FS) | (ft &lt;&lt; OP_SH_FT));
 730         copDelayNop();
 731     }
 732 
 733     void cueqd(FPRegisterID fs, FPRegisterID ft)
 734     {
 735         emitInst(0x46200033 | (fs &lt;&lt; OP_SH_FS) | (ft &lt;&lt; OP_SH_FT));
 736         copDelayNop();
 737     }
 738 
 739     void coled(FPRegisterID fs, FPRegisterID ft)
 740     {
 741         emitInst(0x46200036 | (fs &lt;&lt; OP_SH_FS) | (ft &lt;&lt; OP_SH_FT));
 742         copDelayNop();
 743     }
 744 
 745     void coltd(FPRegisterID fs, FPRegisterID ft)
 746     {
 747         emitInst(0x46200034 | (fs &lt;&lt; OP_SH_FS) | (ft &lt;&lt; OP_SH_FT));
 748         copDelayNop();
 749     }
 750 
 751     void culed(FPRegisterID fs, FPRegisterID ft)
 752     {
 753         emitInst(0x46200037 | (fs &lt;&lt; OP_SH_FS) | (ft &lt;&lt; OP_SH_FT));
 754         copDelayNop();
 755     }
 756 
 757     void cultd(FPRegisterID fs, FPRegisterID ft)
 758     {
 759         emitInst(0x46200035 | (fs &lt;&lt; OP_SH_FS) | (ft &lt;&lt; OP_SH_FT));
 760         copDelayNop();
 761     }
 762 
 763     void cfc1(RegisterID rt, SPRegisterID fs)
 764     {
 765         emitInst(0x44400000 | (rt &lt;&lt; OP_SH_RT) | (fs &lt;&lt; OP_SH_FS));
 766         copDelayNop();
 767     }
 768 
 769     // General helpers
 770 
 771     AssemblerLabel labelIgnoringWatchpoints()
 772     {
 773         return m_buffer.label();
 774     }
 775 
 776     AssemblerLabel labelForWatchpoint()
 777     {
 778         AssemblerLabel result = m_buffer.label();
 779         if (static_cast&lt;int&gt;(result.m_offset) != m_indexOfLastWatchpoint)
 780             result = label();
 781         m_indexOfLastWatchpoint = result.m_offset;
 782         m_indexOfTailOfLastWatchpoint = result.m_offset + maxJumpReplacementSize();
 783         return result;
 784     }
 785 
 786     AssemblerLabel label()
 787     {
 788         AssemblerLabel result = m_buffer.label();
 789         while (UNLIKELY(static_cast&lt;int&gt;(result.m_offset) &lt; m_indexOfTailOfLastWatchpoint)) {
 790             nop();
 791             result = m_buffer.label();
 792         }
 793         return result;
 794     }
 795 
 796     AssemblerLabel align(int alignment)
 797     {
 798         while (!m_buffer.isAligned(alignment))
 799             bkpt();
 800 
 801         return label();
 802     }
 803 
 804     static void* getRelocatedAddress(void* code, AssemblerLabel label)
 805     {
 806         return reinterpret_cast&lt;void*&gt;(reinterpret_cast&lt;char*&gt;(code) + label.m_offset);
 807     }
 808 
 809     static int getDifferenceBetweenLabels(AssemblerLabel a, AssemblerLabel b)
 810     {
 811         return b.m_offset - a.m_offset;
 812     }
 813 
 814     // Assembler admin methods:
 815 
 816     size_t codeSize() const
 817     {
 818         return m_buffer.codeSize();
 819     }
 820 
 821     unsigned debugOffset() { return m_buffer.debugOffset(); }
 822 
 823     // Assembly helpers for moving data between fp and registers.
 824     void vmov(RegisterID rd1, RegisterID rd2, FPRegisterID rn)
 825     {
 826 #if WTF_MIPS_ISA_REV(2) &amp;&amp; WTF_MIPS_FP64
 827         mfc1(rd1, rn);
 828         mfhc1(rd2, rn);
 829 #else
 830         mfc1(rd1, rn);
 831         mfc1(rd2, FPRegisterID(rn + 1));
 832 #endif
 833     }
 834 
 835     void vmov(FPRegisterID rd, RegisterID rn1, RegisterID rn2)
 836     {
 837 #if WTF_MIPS_ISA_REV(2) &amp;&amp; WTF_MIPS_FP64
 838         mtc1(rn1, rd);
 839         mthc1(rn2, rd);
 840 #else
 841         mtc1(rn1, rd);
 842         mtc1(rn2, FPRegisterID(rd + 1));
 843 #endif
 844     }
 845 
 846     static unsigned getCallReturnOffset(AssemblerLabel call)
 847     {
 848         // The return address is after a call and a delay slot instruction
 849         return call.m_offset;
 850     }
 851 
 852     // Linking &amp; patching:
 853     //
 854     // &#39;link&#39; and &#39;patch&#39; methods are for use on unprotected code - such as the code
 855     // within the AssemblerBuffer, and code being patched by the patch buffer. Once
 856     // code has been finalized it is (platform support permitting) within a non-
 857     // writable region of memory; to modify the code in an execute-only execuable
 858     // pool the &#39;repatch&#39; and &#39;relink&#39; methods should be used.
 859 
 860     static size_t linkDirectJump(void* code, void* to)
 861     {
 862         MIPSWord* insn = reinterpret_cast&lt;MIPSWord*&gt;(reinterpret_cast&lt;intptr_t&gt;(code));
 863         size_t ops = 0;
 864         int32_t slotAddr = reinterpret_cast&lt;int&gt;(insn) + 4;
 865         int32_t toAddr = reinterpret_cast&lt;int&gt;(to);
 866 
 867         if ((slotAddr &amp; 0xf0000000) != (toAddr &amp; 0xf0000000)) {
 868             // lui
 869             *insn = 0x3c000000 | (MIPSRegisters::t9 &lt;&lt; OP_SH_RT) | ((toAddr &gt;&gt; 16) &amp; 0xffff);
 870             ++insn;
 871             // ori
 872             *insn = 0x34000000 | (MIPSRegisters::t9 &lt;&lt; OP_SH_RT) | (MIPSRegisters::t9 &lt;&lt; OP_SH_RS) | (toAddr &amp; 0xffff);
 873             ++insn;
 874             // jr
 875             *insn = 0x00000008 | (MIPSRegisters::t9 &lt;&lt; OP_SH_RS);
 876             ++insn;
 877             ops = 4 * sizeof(MIPSWord);
 878         } else {
 879             // j
 880             *insn = 0x08000000 | ((toAddr &amp; 0x0fffffff) &gt;&gt; 2);
 881             ++insn;
 882             ops = 2 * sizeof(MIPSWord);
 883         }
 884         // nop
 885         *insn = 0x00000000;
 886         return ops;
 887     }
 888 
 889     void linkJump(AssemblerLabel from, AssemblerLabel to)
 890     {
 891         ASSERT(to.isSet());
 892         ASSERT(from.isSet());
 893         MIPSWord* insn = reinterpret_cast&lt;MIPSWord*&gt;(reinterpret_cast&lt;intptr_t&gt;(m_buffer.data()) + from.m_offset);
 894         MIPSWord* toPos = reinterpret_cast&lt;MIPSWord*&gt;(reinterpret_cast&lt;intptr_t&gt;(m_buffer.data()) + to.m_offset);
 895 
 896         ASSERT(!(*(insn - 1)) &amp;&amp; !(*(insn - 2)) &amp;&amp; !(*(insn - 3)) &amp;&amp; !(*(insn - 5)));
 897         insn = insn - 6;
 898         linkWithOffset(insn, toPos);
 899     }
 900 
 901     static void linkJump(void* code, AssemblerLabel from, void* to)
 902     {
 903         ASSERT(from.isSet());
 904         MIPSWord* insn = reinterpret_cast&lt;MIPSWord*&gt;(reinterpret_cast&lt;intptr_t&gt;(code) + from.m_offset);
 905 
 906         ASSERT(!(*(insn - 1)) &amp;&amp; !(*(insn - 2)) &amp;&amp; !(*(insn - 3)) &amp;&amp; !(*(insn - 5)));
 907         insn = insn - 6;
 908         linkWithOffset(insn, to);
 909     }
 910 
 911     static void linkCall(void* code, AssemblerLabel from, void* to)
 912     {
 913         MIPSWord* insn = reinterpret_cast&lt;MIPSWord*&gt;(reinterpret_cast&lt;intptr_t&gt;(code) + from.m_offset);
 914         linkCallInternal(insn, to);
 915     }
 916 
 917     static void linkPointer(void* code, AssemblerLabel from, void* to)
 918     {
 919         MIPSWord* insn = reinterpret_cast&lt;MIPSWord*&gt;(reinterpret_cast&lt;intptr_t&gt;(code) + from.m_offset);
 920         ASSERT((*insn &amp; 0xffe00000) == 0x3c000000); // lui
 921         *insn = (*insn &amp; 0xffff0000) | ((reinterpret_cast&lt;intptr_t&gt;(to) &gt;&gt; 16) &amp; 0xffff);
 922         insn++;
 923         ASSERT((*insn &amp; 0xfc000000) == 0x34000000); // ori
 924         *insn = (*insn &amp; 0xffff0000) | (reinterpret_cast&lt;intptr_t&gt;(to) &amp; 0xffff);
 925     }
 926 
 927     static void relinkJump(void* from, void* to)
 928     {
 929         MIPSWord* insn = reinterpret_cast&lt;MIPSWord*&gt;(from);
 930 
 931         ASSERT(!(*(insn - 1)) &amp;&amp; !(*(insn - 5)));
 932         insn = insn - 6;
 933         int flushSize = linkWithOffset(insn, to);
 934 
 935         cacheFlush(insn, flushSize);
 936     }
 937 
 938     static void relinkJumpToNop(void* from)
 939     {
 940         relinkJump(from, from);
 941     }
 942 
 943     static void relinkCall(void* from, void* to)
 944     {
 945         void* start;
 946         int size = linkCallInternal(from, to);
 947         if (size == sizeof(MIPSWord))
 948             start = reinterpret_cast&lt;void*&gt;(reinterpret_cast&lt;intptr_t&gt;(from) - 2 * sizeof(MIPSWord));
 949         else
 950             start = reinterpret_cast&lt;void*&gt;(reinterpret_cast&lt;intptr_t&gt;(from) - 4 * sizeof(MIPSWord));
 951 
 952         cacheFlush(start, size);
 953     }
 954 
 955     static void repatchInt32(void* from, int32_t to)
 956     {
 957         MIPSWord* insn = reinterpret_cast&lt;MIPSWord*&gt;(from);
 958         ASSERT((*insn &amp; 0xffe00000) == 0x3c000000); // lui
 959         *insn = (*insn &amp; 0xffff0000) | ((to &gt;&gt; 16) &amp; 0xffff);
 960         insn++;
 961         ASSERT((*insn &amp; 0xfc000000) == 0x34000000); // ori
 962         *insn = (*insn &amp; 0xffff0000) | (to &amp; 0xffff);
 963         cacheFlush(from, 2 * sizeof(MIPSWord));
 964     }
 965 
 966     static int32_t readInt32(void* from)
 967     {
 968         MIPSWord* insn = reinterpret_cast&lt;MIPSWord*&gt;(from);
 969         ASSERT((*insn &amp; 0xffe00000) == 0x3c000000); // lui
 970         int32_t result = (*insn &amp; 0x0000ffff) &lt;&lt; 16;
 971         insn++;
 972         ASSERT((*insn &amp; 0xfc000000) == 0x34000000); // ori
 973         result |= *insn &amp; 0x0000ffff;
 974         return result;
 975     }
 976 
 977     static void repatchCompact(void* where, int32_t value)
 978     {
 979         repatchInt32(where, value);
 980     }
 981 
 982     static void repatchPointer(void* from, void* to)
 983     {
 984         repatchInt32(from, reinterpret_cast&lt;int32_t&gt;(to));
 985     }
 986 
 987     static void* readPointer(void* from)
 988     {
 989         return reinterpret_cast&lt;void*&gt;(readInt32(from));
 990     }
 991 
 992     static void* readCallTarget(void* from)
 993     {
 994         MIPSWord* insn = reinterpret_cast&lt;MIPSWord*&gt;(from);
 995         insn -= 4;
 996         ASSERT((*insn &amp; 0xffe00000) == 0x3c000000); // lui
 997         int32_t result = (*insn &amp; 0x0000ffff) &lt;&lt; 16;
 998         insn++;
 999         ASSERT((*insn &amp; 0xfc000000) == 0x34000000); // ori
1000         result |= *insn &amp; 0x0000ffff;
1001         return reinterpret_cast&lt;void*&gt;(result);
1002     }
1003 
1004     static void cacheFlush(void* code, size_t size)
1005     {
1006         intptr_t end = reinterpret_cast&lt;intptr_t&gt;(code) + size;
1007         __builtin___clear_cache(reinterpret_cast&lt;char*&gt;(code), reinterpret_cast&lt;char*&gt;(end));
1008     }
1009 
1010     static ptrdiff_t maxJumpReplacementSize()
1011     {
1012         return sizeof(MIPSWord) * 4;
1013     }
1014 
1015     static constexpr ptrdiff_t patchableJumpSize()
1016     {
1017         return sizeof(MIPSWord) * 8;
1018     }
1019 
1020     static void revertJumpToMove(void* instructionStart, RegisterID rt, int imm)
1021     {
1022         MIPSWord* insn = static_cast&lt;MIPSWord*&gt;(instructionStart);
1023         size_t codeSize = 2 * sizeof(MIPSWord);
1024 
1025         // lui
1026         *insn = 0x3c000000 | (rt &lt;&lt; OP_SH_RT) | ((imm &gt;&gt; 16) &amp; 0xffff);
1027         ++insn;
1028         // ori
1029         *insn = 0x34000000 | (rt &lt;&lt; OP_SH_RS) | (rt &lt;&lt; OP_SH_RT) | (imm &amp; 0xffff);
1030         ++insn;
1031         // if jr $t9
1032         if (*insn == 0x03200008) {
1033             *insn = 0x00000000;
1034             codeSize += sizeof(MIPSWord);
1035         }
1036         cacheFlush(instructionStart, codeSize);
1037     }
1038 
1039     static void replaceWithJump(void* instructionStart, void* to)
1040     {
1041         ASSERT(!(bitwise_cast&lt;uintptr_t&gt;(instructionStart) &amp; 3));
1042         ASSERT(!(bitwise_cast&lt;uintptr_t&gt;(to) &amp; 3));
1043         size_t ops = linkDirectJump(instructionStart, to);
1044         cacheFlush(instructionStart, ops);
1045     }
1046 
1047     static void replaceWithLoad(void* instructionStart)
1048     {
1049         MIPSWord* insn = reinterpret_cast&lt;MIPSWord*&gt;(instructionStart);
1050         ASSERT((*insn &amp; 0xffe00000) == 0x3c000000); // lui
1051         insn++;
1052         ASSERT((*insn &amp; 0xfc0007ff) == 0x00000021); // addu
1053         insn++;
1054         *insn = 0x8c000000 | ((*insn) &amp; 0x3ffffff); // lw
1055         cacheFlush(insn, 4);
1056     }
1057 
1058     static void replaceWithAddressComputation(void* instructionStart)
1059     {
1060         MIPSWord* insn = reinterpret_cast&lt;MIPSWord*&gt;(instructionStart);
1061         ASSERT((*insn &amp; 0xffe00000) == 0x3c000000); // lui
1062         insn++;
1063         ASSERT((*insn &amp; 0xfc0007ff) == 0x00000021); // addu
1064         insn++;
1065         *insn = 0x24000000 | ((*insn) &amp; 0x3ffffff); // addiu
1066         cacheFlush(insn, 4);
1067     }
1068 
1069     /* Update each jump in the buffer of newBase.  */
1070     void relocateJumps(void* oldBase, void* newBase)
1071     {
1072         // Check each jump
1073         for (Jumps::Iterator iter = m_jumps.begin(); iter != m_jumps.end(); ++iter) {
1074             int pos = iter-&gt;m_offset;
1075             MIPSWord* insn = reinterpret_cast&lt;MIPSWord*&gt;(reinterpret_cast&lt;intptr_t&gt;(newBase) + pos);
1076             insn = insn + 2;
1077             // Need to make sure we have 5 valid instructions after pos
1078             if ((unsigned)pos &gt;= m_buffer.codeSize() - 5 * sizeof(MIPSWord))
1079                 continue;
1080 
1081             if ((*insn &amp; 0xfc000000) == 0x08000000) { // j
1082                 int offset = *insn &amp; 0x03ffffff;
1083                 int oldInsnAddress = (int)insn - (int)newBase + (int)oldBase;
1084                 int topFourBits = (oldInsnAddress + 4) &gt;&gt; 28;
1085                 int oldTargetAddress = (topFourBits &lt;&lt; 28) | (offset &lt;&lt; 2);
1086                 int newTargetAddress = oldTargetAddress - (int)oldBase + (int)newBase;
1087                 int newInsnAddress = (int)insn;
1088                 if (((newInsnAddress + 4) &gt;&gt; 28) == (newTargetAddress &gt;&gt; 28))
1089                     *insn = 0x08000000 | ((newTargetAddress &gt;&gt; 2) &amp; 0x3ffffff);
1090                 else {
1091                     /* lui */
1092                     *insn = 0x3c000000 | (MIPSRegisters::t9 &lt;&lt; OP_SH_RT) | ((newTargetAddress &gt;&gt; 16) &amp; 0xffff);
1093                     /* ori */
1094                     *(insn + 1) = 0x34000000 | (MIPSRegisters::t9 &lt;&lt; OP_SH_RT) | (MIPSRegisters::t9 &lt;&lt; OP_SH_RS) | (newTargetAddress &amp; 0xffff);
1095                     /* jr */
1096                     *(insn + 2) = 0x00000008 | (MIPSRegisters::t9 &lt;&lt; OP_SH_RS);
1097                 }
1098             } else if ((*insn &amp; 0xffe00000) == 0x3c000000) { // lui
1099                 int high = (*insn &amp; 0xffff) &lt;&lt; 16;
1100                 int low = *(insn + 1) &amp; 0xffff;
1101                 int oldTargetAddress = high | low;
1102                 int newTargetAddress = oldTargetAddress - (int)oldBase + (int)newBase;
1103                 /* lui */
1104                 *insn = 0x3c000000 | (MIPSRegisters::t9 &lt;&lt; OP_SH_RT) | ((newTargetAddress &gt;&gt; 16) &amp; 0xffff);
1105                 /* ori */
1106                 *(insn + 1) = 0x34000000 | (MIPSRegisters::t9 &lt;&lt; OP_SH_RT) | (MIPSRegisters::t9 &lt;&lt; OP_SH_RS) | (newTargetAddress &amp; 0xffff);
1107             }
1108         }
1109     }
1110 
1111 private:
1112     static int linkWithOffset(MIPSWord* insn, void* to)
1113     {
1114         ASSERT((*insn &amp; 0xfc000000) == 0x10000000 // beq
1115             || (*insn &amp; 0xfc000000) == 0x14000000 // bne
1116             || (*insn &amp; 0xffff0000) == 0x45010000 // bc1t
1117             || (*insn &amp; 0xffff0000) == 0x45000000); // bc1f
1118         intptr_t diff = (reinterpret_cast&lt;intptr_t&gt;(to) - reinterpret_cast&lt;intptr_t&gt;(insn) - 4) &gt;&gt; 2;
1119 
1120         if (diff &lt; -32768 || diff &gt; 32767 || *(insn + 2) != 0x10000003) {
1121             /*
1122                 Convert the sequence:
1123                   beq $2, $3, target
1124                   nop
1125                   b 1f
1126                   nop
1127                   nop
1128                   nop
1129                 1:
1130 
1131                 to the new sequence if possible:
1132                   bne $2, $3, 1f
1133                   nop
1134                   j    target
1135                   nop
1136                   nop
1137                   nop
1138                 1:
1139 
1140                 OR to the new sequence:
1141                   bne $2, $3, 1f
1142                   nop
1143                   lui $25, target &gt;&gt; 16
1144                   ori $25, $25, target &amp; 0xffff
1145                   jr $25
1146                   nop
1147                 1:
1148 
1149                 Note: beq/bne/bc1t/bc1f are converted to bne/beq/bc1f/bc1t.
1150             */
1151 
1152             if (*(insn + 2) == 0x10000003) {
1153                 if ((*insn &amp; 0xfc000000) == 0x10000000) // beq
1154                     *insn = (*insn &amp; 0x03ff0000) | 0x14000005; // bne
1155                 else if ((*insn &amp; 0xfc000000) == 0x14000000) // bne
1156                     *insn = (*insn &amp; 0x03ff0000) | 0x10000005; // beq
1157                 else if ((*insn &amp; 0xffff0000) == 0x45010000) // bc1t
1158                     *insn = 0x45000005; // bc1f
1159                 else if ((*insn &amp; 0xffff0000) == 0x45000000) // bc1f
1160                     *insn = 0x45010005; // bc1t
1161                 else
1162                     ASSERT(0);
1163             }
1164 
1165             insn = insn + 2;
1166             if ((reinterpret_cast&lt;intptr_t&gt;(insn) + 4) &gt;&gt; 28
1167                 == reinterpret_cast&lt;intptr_t&gt;(to) &gt;&gt; 28) {
1168                 *insn = 0x08000000 | ((reinterpret_cast&lt;intptr_t&gt;(to) &gt;&gt; 2) &amp; 0x3ffffff);
1169                 *(insn + 1) = 0;
1170                 return 4 * sizeof(MIPSWord);
1171             }
1172 
1173             intptr_t newTargetAddress = reinterpret_cast&lt;intptr_t&gt;(to);
1174             /* lui */
1175             *insn = 0x3c000000 | (MIPSRegisters::t9 &lt;&lt; OP_SH_RT) | ((newTargetAddress &gt;&gt; 16) &amp; 0xffff);
1176             /* ori */
1177             *(insn + 1) = 0x34000000 | (MIPSRegisters::t9 &lt;&lt; OP_SH_RT) | (MIPSRegisters::t9 &lt;&lt; OP_SH_RS) | (newTargetAddress &amp; 0xffff);
1178             /* jr */
1179             *(insn + 2) = 0x00000008 | (MIPSRegisters::t9 &lt;&lt; OP_SH_RS);
1180             return 5 * sizeof(MIPSWord);
1181         }
1182 
1183         *insn = (*insn &amp; 0xffff0000) | (diff &amp; 0xffff);
1184         return sizeof(MIPSWord);
1185     }
1186 
1187     static int linkCallInternal(void* from, void* to)
1188     {
1189         MIPSWord* insn = reinterpret_cast&lt;MIPSWord*&gt;(from);
1190         insn = insn - 4;
1191 
1192         if ((*(insn + 2) &amp; 0xfc000000) == 0x0c000000) { // jal
1193             if ((reinterpret_cast&lt;intptr_t&gt;(from) - 4) &gt;&gt; 28
1194                 == reinterpret_cast&lt;intptr_t&gt;(to) &gt;&gt; 28) {
1195                 *(insn + 2) = 0x0c000000 | ((reinterpret_cast&lt;intptr_t&gt;(to) &gt;&gt; 2) &amp; 0x3ffffff);
1196                 return sizeof(MIPSWord);
1197             }
1198 
1199             /* lui $25, (to &gt;&gt; 16) &amp; 0xffff */
1200             *insn = 0x3c000000 | (MIPSRegisters::t9 &lt;&lt; OP_SH_RT) | ((reinterpret_cast&lt;intptr_t&gt;(to) &gt;&gt; 16) &amp; 0xffff);
1201             /* ori $25, $25, to &amp; 0xffff */
1202             *(insn + 1) = 0x34000000 | (MIPSRegisters::t9 &lt;&lt; OP_SH_RT) | (MIPSRegisters::t9 &lt;&lt; OP_SH_RS) | (reinterpret_cast&lt;intptr_t&gt;(to) &amp; 0xffff);
1203             /* jalr $25 */
1204             *(insn + 2) = 0x0000f809 | (MIPSRegisters::t9 &lt;&lt; OP_SH_RS);
1205             return 3 * sizeof(MIPSWord);
1206         }
1207 
1208         ASSERT((*insn &amp; 0xffe00000) == 0x3c000000); // lui
1209         ASSERT((*(insn + 1) &amp; 0xfc000000) == 0x34000000); // ori
1210 
1211         /* lui */
1212         *insn = (*insn &amp; 0xffff0000) | ((reinterpret_cast&lt;intptr_t&gt;(to) &gt;&gt; 16) &amp; 0xffff);
1213         /* ori */
1214         *(insn + 1) = (*(insn + 1) &amp; 0xffff0000) | (reinterpret_cast&lt;intptr_t&gt;(to) &amp; 0xffff);
1215         return 2 * sizeof(MIPSWord);
1216     }
1217 
1218     AssemblerBuffer m_buffer;
1219     Jumps m_jumps;
1220     int m_indexOfLastWatchpoint;
1221     int m_indexOfTailOfLastWatchpoint;
1222 };
1223 
1224 } // namespace JSC
1225 
1226 #endif // ENABLE(ASSEMBLER) &amp;&amp; CPU(MIPS)
<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>