<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/css/StyleBuilderConverter.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2013 Google Inc. All rights reserved.
   3  * Copyright (C) 2014 Apple Inc. All rights reserved.
   4  *
   5  * Redistribution and use in source and binary forms, with or without
   6  * modification, are permitted provided that the following conditions
   7  * are met:
   8  * 1. Redistributions of source code must retain the above copyright
   9  *    notice, this list of conditions and the following disclaimer.
  10  * 2. Redistributions in binary form must reproduce the above copyright
  11  *    notice, this list of conditions and the following disclaimer in the
  12  *    documentation and/or other materials provided with the distribution.
  13  *
  14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
  15  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  16  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  17  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
  18  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  19  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  20  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  21  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  22  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  23  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  24  * THE POSSIBILITY OF SUCH DAMAGE.
  25  */
  26 
  27 #pragma once
  28 
  29 #include &quot;BasicShapeFunctions.h&quot;
  30 #include &quot;CSSCalculationValue.h&quot;
  31 #include &quot;CSSContentDistributionValue.h&quot;
  32 #include &quot;CSSFontFeatureValue.h&quot;
  33 #include &quot;CSSFontStyleValue.h&quot;
  34 #include &quot;CSSFontVariationValue.h&quot;
  35 #include &quot;CSSFunctionValue.h&quot;
  36 #include &quot;CSSGridAutoRepeatValue.h&quot;
  37 #include &quot;CSSGridIntegerRepeatValue.h&quot;
  38 #include &quot;CSSGridLineNamesValue.h&quot;
  39 #include &quot;CSSImageGeneratorValue.h&quot;
  40 #include &quot;CSSImageSetValue.h&quot;
  41 #include &quot;CSSImageValue.h&quot;
  42 #include &quot;CSSPrimitiveValue.h&quot;
  43 #include &quot;CSSPrimitiveValueMappings.h&quot;
  44 #include &quot;CSSReflectValue.h&quot;
  45 #include &quot;FontSelectionValueInlines.h&quot;
  46 #include &quot;Frame.h&quot;
  47 #include &quot;GridPositionsResolver.h&quot;
  48 #include &quot;Length.h&quot;
  49 #include &quot;Pair.h&quot;
  50 #include &quot;QuotesData.h&quot;
  51 #include &quot;RuntimeEnabledFeatures.h&quot;
  52 #include &quot;SVGURIReference.h&quot;
  53 #include &quot;Settings.h&quot;
  54 #include &quot;StyleResolver.h&quot;
  55 #include &quot;StyleScrollSnapPoints.h&quot;
  56 #include &quot;TabSize.h&quot;
  57 #include &quot;TouchAction.h&quot;
  58 #include &quot;TransformFunctions.h&quot;
  59 #include &lt;wtf/Optional.h&gt;
  60 
  61 namespace WebCore {
  62 
  63 // Note that we assume the CSS parser only allows valid CSSValue types.
  64 class StyleBuilderConverter {
  65 public:
  66     static Length convertLength(const StyleResolver&amp;, const CSSValue&amp;);
  67     static Length convertLengthOrAuto(const StyleResolver&amp;, const CSSValue&amp;);
  68     static Length convertLengthSizing(const StyleResolver&amp;, const CSSValue&amp;);
  69     static Length convertLengthMaxSizing(const StyleResolver&amp;, const CSSValue&amp;);
  70     static TabSize convertTabSize(const StyleResolver&amp;, const CSSValue&amp;);
  71     template&lt;typename T&gt; static T convertComputedLength(StyleResolver&amp;, const CSSValue&amp;);
  72     template&lt;typename T&gt; static T convertLineWidth(StyleResolver&amp;, const CSSValue&amp;);
  73     static float convertSpacing(StyleResolver&amp;, const CSSValue&amp;);
  74     static LengthSize convertRadius(StyleResolver&amp;, const CSSValue&amp;);
  75     static LengthPoint convertObjectPosition(StyleResolver&amp;, const CSSValue&amp;);
  76     static OptionSet&lt;TextDecoration&gt; convertTextDecoration(StyleResolver&amp;, const CSSValue&amp;);
  77     template&lt;typename T&gt; static T convertNumber(StyleResolver&amp;, const CSSValue&amp;);
  78     template&lt;typename T&gt; static T convertNumberOrAuto(StyleResolver&amp;, const CSSValue&amp;);
  79     static short convertWebkitHyphenateLimitLines(StyleResolver&amp;, const CSSValue&amp;);
  80     template&lt;CSSPropertyID&gt; static NinePieceImage convertBorderImage(StyleResolver&amp;, CSSValue&amp;);
  81     template&lt;CSSPropertyID&gt; static NinePieceImage convertBorderMask(StyleResolver&amp;, CSSValue&amp;);
  82     template&lt;CSSPropertyID&gt; static RefPtr&lt;StyleImage&gt; convertStyleImage(StyleResolver&amp;, CSSValue&amp;);
  83     static TransformOperations convertTransform(StyleResolver&amp;, const CSSValue&amp;);
  84 #if ENABLE(DARK_MODE_CSS)
  85     static StyleColorScheme convertColorScheme(StyleResolver&amp;, const CSSValue&amp;);
  86 #endif
  87     static String convertString(StyleResolver&amp;, const CSSValue&amp;);
  88     static String convertStringOrAuto(StyleResolver&amp;, const CSSValue&amp;);
  89     static String convertStringOrNone(StyleResolver&amp;, const CSSValue&amp;);
  90     static OptionSet&lt;TextEmphasisPosition&gt; convertTextEmphasisPosition(StyleResolver&amp;, const CSSValue&amp;);
  91     static TextAlignMode convertTextAlign(StyleResolver&amp;, const CSSValue&amp;);
  92     static RefPtr&lt;ClipPathOperation&gt; convertClipPath(StyleResolver&amp;, const CSSValue&amp;);
  93     static Resize convertResize(StyleResolver&amp;, const CSSValue&amp;);
  94     static int convertMarqueeRepetition(StyleResolver&amp;, const CSSValue&amp;);
  95     static int convertMarqueeSpeed(StyleResolver&amp;, const CSSValue&amp;);
  96     static Ref&lt;QuotesData&gt; convertQuotes(StyleResolver&amp;, const CSSValue&amp;);
  97     static TextUnderlinePosition convertTextUnderlinePosition(StyleResolver&amp;, const CSSValue&amp;);
  98     static TextUnderlineOffset convertTextUnderlineOffset(StyleResolver&amp;, const CSSValue&amp;);
  99     static TextDecorationThickness convertTextDecorationThickness(StyleResolver&amp;, const CSSValue&amp;);
 100     static RefPtr&lt;StyleReflection&gt; convertReflection(StyleResolver&amp;, const CSSValue&amp;);
 101     static IntSize convertInitialLetter(StyleResolver&amp;, const CSSValue&amp;);
 102     static float convertTextStrokeWidth(StyleResolver&amp;, const CSSValue&amp;);
 103     static LineBoxContain convertLineBoxContain(StyleResolver&amp;, const CSSValue&amp;);
 104     static OptionSet&lt;TextDecorationSkip&gt; convertTextDecorationSkip(StyleResolver&amp;, const CSSValue&amp;);
 105     static RefPtr&lt;ShapeValue&gt; convertShapeValue(StyleResolver&amp;, CSSValue&amp;);
 106 #if ENABLE(CSS_SCROLL_SNAP)
 107     static ScrollSnapType convertScrollSnapType(StyleResolver&amp;, const CSSValue&amp;);
 108     static ScrollSnapAlign convertScrollSnapAlign(StyleResolver&amp;, const CSSValue&amp;);
 109 #endif
 110     static GridTrackSize convertGridTrackSize(StyleResolver&amp;, const CSSValue&amp;);
 111     static Vector&lt;GridTrackSize&gt; convertGridTrackSizeList(StyleResolver&amp;, const CSSValue&amp;);
 112     static Optional&lt;GridPosition&gt; convertGridPosition(StyleResolver&amp;, const CSSValue&amp;);
 113     static GridAutoFlow convertGridAutoFlow(StyleResolver&amp;, const CSSValue&amp;);
 114     static Optional&lt;Length&gt; convertWordSpacing(StyleResolver&amp;, const CSSValue&amp;);
 115     static Optional&lt;float&gt; convertPerspective(StyleResolver&amp;, const CSSValue&amp;);
 116     static Optional&lt;Length&gt; convertMarqueeIncrement(StyleResolver&amp;, const CSSValue&amp;);
 117     static Optional&lt;FilterOperations&gt; convertFilterOperations(StyleResolver&amp;, const CSSValue&amp;);
 118 #if PLATFORM(IOS_FAMILY)
 119     static bool convertTouchCallout(StyleResolver&amp;, const CSSValue&amp;);
 120 #endif
 121 #if ENABLE(TOUCH_EVENTS)
 122     static Color convertTapHighlightColor(StyleResolver&amp;, const CSSValue&amp;);
 123 #endif
 124 #if ENABLE(POINTER_EVENTS)
 125     static OptionSet&lt;TouchAction&gt; convertTouchAction(StyleResolver&amp;, const CSSValue&amp;);
 126 #endif
 127 #if ENABLE(OVERFLOW_SCROLLING_TOUCH)
 128     static bool convertOverflowScrolling(StyleResolver&amp;, const CSSValue&amp;);
 129 #endif
 130     static FontFeatureSettings convertFontFeatureSettings(StyleResolver&amp;, const CSSValue&amp;);
 131     static FontSelectionValue convertFontWeightFromValue(const CSSValue&amp;);
 132     static FontSelectionValue convertFontStretchFromValue(const CSSValue&amp;);
 133     static Optional&lt;FontSelectionValue&gt; convertFontStyleFromValue(const CSSValue&amp;);
 134     static FontSelectionValue convertFontWeight(StyleResolver&amp;, const CSSValue&amp;);
 135     static FontSelectionValue convertFontStretch(StyleResolver&amp;, const CSSValue&amp;);
 136     static FontSelectionValue convertFontStyle(StyleResolver&amp;, const CSSValue&amp;);
 137 #if ENABLE(VARIATION_FONTS)
 138     static FontVariationSettings convertFontVariationSettings(StyleResolver&amp;, const CSSValue&amp;);
 139 #endif
 140     static SVGLengthValue convertSVGLengthValue(StyleResolver&amp;, const CSSValue&amp;);
 141     static Vector&lt;SVGLengthValue&gt; convertSVGLengthVector(StyleResolver&amp;, const CSSValue&amp;);
 142     static Vector&lt;SVGLengthValue&gt; convertStrokeDashArray(StyleResolver&amp;, const CSSValue&amp;);
 143     static PaintOrder convertPaintOrder(StyleResolver&amp;, const CSSValue&amp;);
 144     static float convertOpacity(StyleResolver&amp;, const CSSValue&amp;);
 145     static String convertSVGURIReference(StyleResolver&amp;, const CSSValue&amp;);
 146     static Color convertSVGColor(StyleResolver&amp;, const CSSValue&amp;);
 147     static StyleSelfAlignmentData convertSelfOrDefaultAlignmentData(StyleResolver&amp;, const CSSValue&amp;);
 148     static StyleContentAlignmentData convertContentAlignmentData(StyleResolver&amp;, const CSSValue&amp;);
 149     static GlyphOrientation convertGlyphOrientation(StyleResolver&amp;, const CSSValue&amp;);
 150     static GlyphOrientation convertGlyphOrientationOrAuto(StyleResolver&amp;, const CSSValue&amp;);
 151     static Optional&lt;Length&gt; convertLineHeight(StyleResolver&amp;, const CSSValue&amp;, float multiplier = 1.f);
 152     static FontSynthesis convertFontSynthesis(StyleResolver&amp;, const CSSValue&amp;);
 153 
 154     static BreakBetween convertPageBreakBetween(StyleResolver&amp;, const CSSValue&amp;);
 155     static BreakInside convertPageBreakInside(StyleResolver&amp;, const CSSValue&amp;);
 156     static BreakBetween convertColumnBreakBetween(StyleResolver&amp;, const CSSValue&amp;);
 157     static BreakInside convertColumnBreakInside(StyleResolver&amp;, const CSSValue&amp;);
 158 
 159     static OptionSet&lt;HangingPunctuation&gt; convertHangingPunctuation(StyleResolver&amp;, const CSSValue&amp;);
 160 
 161     static OptionSet&lt;SpeakAs&gt; convertSpeakAs(StyleResolver&amp;, const CSSValue&amp;);
 162 
 163     static Length convertPositionComponentX(StyleResolver&amp;, const CSSValue&amp;);
 164     static Length convertPositionComponentY(StyleResolver&amp;, const CSSValue&amp;);
 165 
 166     static GapLength convertGapLength(StyleResolver&amp;, const CSSValue&amp;);
 167 
 168 private:
 169     friend class StyleBuilderCustom;
 170 
 171     static Length convertToRadiusLength(CSSToLengthConversionData&amp;, const CSSPrimitiveValue&amp;);
 172     static OptionSet&lt;TextEmphasisPosition&gt; valueToEmphasisPosition(const CSSPrimitiveValue&amp;);
 173     static OptionSet&lt;TextDecorationSkip&gt; valueToDecorationSkip(const CSSPrimitiveValue&amp;);
 174 #if ENABLE(CSS_SCROLL_SNAP)
 175     static Length parseSnapCoordinate(StyleResolver&amp;, const CSSValue&amp;);
 176 #endif
 177 
 178 #if ENABLE(DARK_MODE_CSS)
 179     static void updateColorScheme(const CSSPrimitiveValue&amp;, StyleColorScheme&amp;);
 180 #endif
 181 
 182     static Length convertTo100PercentMinusLength(const Length&amp;);
 183     template&lt;CSSValueID, CSSValueID&gt; static Length convertPositionComponent(StyleResolver&amp;, const CSSPrimitiveValue&amp;);
 184 
 185     static GridLength createGridTrackBreadth(const CSSPrimitiveValue&amp;, StyleResolver&amp;);
 186     static GridTrackSize createGridTrackSize(const CSSValue&amp;, StyleResolver&amp;);
 187     struct TracksData;
 188     static bool createGridTrackList(const CSSValue&amp;, TracksData&amp;, StyleResolver&amp;);
 189     static bool createGridPosition(const CSSValue&amp;, GridPosition&amp;);
 190     static void createImplicitNamedGridLinesFromGridArea(const NamedGridAreaMap&amp;, NamedGridLinesMap&amp;, GridTrackSizingDirection);
 191     static CSSToLengthConversionData csstoLengthConversionDataWithTextZoomFactor(StyleResolver&amp;);
 192 };
 193 
 194 inline Length StyleBuilderConverter::convertLength(const StyleResolver&amp; styleResolver, const CSSValue&amp; value)
 195 {
 196     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
 197     CSSToLengthConversionData conversionData = styleResolver.useSVGZoomRulesForLength() ?
 198         styleResolver.state().cssToLengthConversionData().copyWithAdjustedZoom(1.0f)
 199         : styleResolver.state().cssToLengthConversionData();
 200 
 201     if (primitiveValue.isLength()) {
 202         Length length = primitiveValue.computeLength&lt;Length&gt;(conversionData);
 203         length.setHasQuirk(primitiveValue.isQuirkValue());
 204         return length;
 205     }
 206 
 207     if (primitiveValue.isPercentage())
 208         return Length(primitiveValue.doubleValue(), Percent);
 209 
 210     if (primitiveValue.isCalculatedPercentageWithLength())
 211         return Length(primitiveValue.cssCalcValue()-&gt;createCalculationValue(conversionData));
 212 
 213     ASSERT_NOT_REACHED();
 214     return Length(0, Fixed);
 215 }
 216 
 217 inline Length StyleBuilderConverter::convertLengthOrAuto(const StyleResolver&amp; styleResolver, const CSSValue&amp; value)
 218 {
 219     if (downcast&lt;CSSPrimitiveValue&gt;(value).valueID() == CSSValueAuto)
 220         return Length(Auto);
 221     return convertLength(styleResolver, value);
 222 }
 223 
 224 inline Length StyleBuilderConverter::convertLengthSizing(const StyleResolver&amp; styleResolver, const CSSValue&amp; value)
 225 {
 226     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
 227     switch (primitiveValue.valueID()) {
 228     case CSSValueInvalid:
 229         return convertLength(styleResolver, value);
 230     case CSSValueIntrinsic:
 231         return Length(Intrinsic);
 232     case CSSValueMinIntrinsic:
 233         return Length(MinIntrinsic);
 234     case CSSValueMinContent:
 235     case CSSValueWebkitMinContent:
 236         return Length(MinContent);
 237     case CSSValueMaxContent:
 238     case CSSValueWebkitMaxContent:
 239         return Length(MaxContent);
 240     case CSSValueWebkitFillAvailable:
 241         return Length(FillAvailable);
 242     case CSSValueFitContent:
 243     case CSSValueWebkitFitContent:
 244         return Length(FitContent);
 245     case CSSValueAuto:
 246         return Length(Auto);
 247     default:
 248         ASSERT_NOT_REACHED();
 249         return Length();
 250     }
 251 }
 252 
 253 inline Length StyleBuilderConverter::convertLengthMaxSizing(const StyleResolver&amp; styleResolver, const CSSValue&amp; value)
 254 {
 255     if (downcast&lt;CSSPrimitiveValue&gt;(value).valueID() == CSSValueNone)
 256         return Length(Undefined);
 257     return convertLengthSizing(styleResolver, value);
 258 }
 259 
 260 inline TabSize StyleBuilderConverter::convertTabSize(const StyleResolver&amp; styleResolver, const CSSValue&amp; value)
 261 {
 262     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
 263     if (primitiveValue.isNumber())
 264         return TabSize(primitiveValue.floatValue(), SpaceValueType);
 265     return TabSize(primitiveValue.computeLength&lt;float&gt;(styleResolver.state().cssToLengthConversionData()), LengthValueType);
 266 }
 267 
 268 template&lt;typename T&gt;
 269 inline T StyleBuilderConverter::convertComputedLength(StyleResolver&amp; styleResolver, const CSSValue&amp; value)
 270 {
 271     return downcast&lt;CSSPrimitiveValue&gt;(value).computeLength&lt;T&gt;(styleResolver.state().cssToLengthConversionData());
 272 }
 273 
 274 template&lt;typename T&gt;
 275 inline T StyleBuilderConverter::convertLineWidth(StyleResolver&amp; styleResolver, const CSSValue&amp; value)
 276 {
 277     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
 278     switch (primitiveValue.valueID()) {
 279     case CSSValueThin:
 280         return 1;
 281     case CSSValueMedium:
 282         return 3;
 283     case CSSValueThick:
 284         return 5;
 285     case CSSValueInvalid: {
 286         // Any original result that was &gt;= 1 should not be allowed to fall below 1.
 287         // This keeps border lines from vanishing.
 288         T result = convertComputedLength&lt;T&gt;(styleResolver, value);
 289         if (styleResolver.state().style()-&gt;effectiveZoom() &lt; 1.0f &amp;&amp; result &lt; 1.0) {
 290             T originalLength = primitiveValue.computeLength&lt;T&gt;(styleResolver.state().cssToLengthConversionData().copyWithAdjustedZoom(1.0));
 291             if (originalLength &gt;= 1.0)
 292                 return 1;
 293         }
 294         float minimumLineWidth = 1 / styleResolver.document().deviceScaleFactor();
 295         if (result &gt; 0 &amp;&amp; result &lt; minimumLineWidth)
 296             return minimumLineWidth;
 297         return floorToDevicePixel(result, styleResolver.document().deviceScaleFactor());
 298     }
 299     default:
 300         ASSERT_NOT_REACHED();
 301         return 0;
 302     }
 303 }
 304 
 305 inline float StyleBuilderConverter::convertSpacing(StyleResolver&amp; styleResolver, const CSSValue&amp; value)
 306 {
 307     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
 308     if (primitiveValue.valueID() == CSSValueNormal)
 309         return 0.f;
 310 
 311     CSSToLengthConversionData conversionData = styleResolver.useSVGZoomRulesForLength() ?
 312         styleResolver.state().cssToLengthConversionData().copyWithAdjustedZoom(1.0f)
 313         : styleResolver.state().cssToLengthConversionData();
 314     return primitiveValue.computeLength&lt;float&gt;(conversionData);
 315 }
 316 
 317 inline Length StyleBuilderConverter::convertToRadiusLength(CSSToLengthConversionData&amp; conversionData, const CSSPrimitiveValue&amp; value)
 318 {
 319     if (value.isPercentage())
 320         return Length(value.doubleValue(), Percent);
 321     if (value.isCalculatedPercentageWithLength())
 322         return Length(value.cssCalcValue()-&gt;createCalculationValue(conversionData));
 323     return value.computeLength&lt;Length&gt;(conversionData);
 324 }
 325 
 326 inline LengthSize StyleBuilderConverter::convertRadius(StyleResolver&amp; styleResolver, const CSSValue&amp; value)
 327 {
 328     auto* pair = downcast&lt;CSSPrimitiveValue&gt;(value).pairValue();
 329     if (!pair || !pair-&gt;first() || !pair-&gt;second())
 330         return { { 0, Fixed }, { 0, Fixed } };
 331 
 332     CSSToLengthConversionData conversionData = styleResolver.state().cssToLengthConversionData();
 333     LengthSize radius { convertToRadiusLength(conversionData, *pair-&gt;first()), convertToRadiusLength(conversionData, *pair-&gt;second()) };
 334 
 335     ASSERT(!radius.width.isNegative());
 336     ASSERT(!radius.height.isNegative());
 337     if (radius.width.isZero() || radius.height.isZero())
 338         return { { 0, Fixed }, { 0, Fixed } };
 339 
 340     return radius;
 341 }
 342 
 343 inline Length StyleBuilderConverter::convertTo100PercentMinusLength(const Length&amp; length)
 344 {
 345     if (length.isPercent())
 346         return Length(100 - length.value(), Percent);
 347 
 348     // Turn this into a calc expression: calc(100% - length)
 349     Vector&lt;std::unique_ptr&lt;CalcExpressionNode&gt;&gt; lengths;
 350     lengths.reserveInitialCapacity(2);
 351     lengths.uncheckedAppend(makeUnique&lt;CalcExpressionLength&gt;(Length(100, Percent)));
 352     lengths.uncheckedAppend(makeUnique&lt;CalcExpressionLength&gt;(length));
 353     auto op = makeUnique&lt;CalcExpressionOperation&gt;(WTFMove(lengths), CalcOperator::Subtract);
 354     return Length(CalculationValue::create(WTFMove(op), ValueRangeAll));
 355 }
 356 
 357 inline Length StyleBuilderConverter::convertPositionComponentX(StyleResolver&amp; styleResolver, const CSSValue&amp; value)
 358 {
 359     return convertPositionComponent&lt;CSSValueLeft, CSSValueRight&gt;(styleResolver, downcast&lt;CSSPrimitiveValue&gt;(value));
 360 }
 361 
 362 inline Length StyleBuilderConverter::convertPositionComponentY(StyleResolver&amp; styleResolver, const CSSValue&amp; value)
 363 {
 364     return convertPositionComponent&lt;CSSValueTop, CSSValueBottom&gt;(styleResolver, downcast&lt;CSSPrimitiveValue&gt;(value));
 365 }
 366 
 367 template&lt;CSSValueID cssValueFor0, CSSValueID cssValueFor100&gt;
 368 inline Length StyleBuilderConverter::convertPositionComponent(StyleResolver&amp; styleResolver, const CSSPrimitiveValue&amp; value)
 369 {
 370     Length length;
 371 
 372     auto* lengthValue = &amp;value;
 373     bool relativeToTrailingEdge = false;
 374 
 375     if (value.isPair()) {
 376         auto&amp; first = *value.pairValue()-&gt;first();
 377         if (first.valueID() == CSSValueRight || first.valueID() == CSSValueBottom)
 378             relativeToTrailingEdge = true;
 379         lengthValue = value.pairValue()-&gt;second();
 380     }
 381 
 382     if (value.isValueID()) {
 383         switch (value.valueID()) {
 384         case cssValueFor0:
 385             return Length(0, Percent);
 386         case cssValueFor100:
 387             return Length(100, Percent);
 388         case CSSValueCenter:
 389             return Length(50, Percent);
 390         default:
 391             ASSERT_NOT_REACHED();
 392         }
 393     }
 394 
 395     length = convertLength(styleResolver, *lengthValue);
 396 
 397     if (relativeToTrailingEdge)
 398         length = convertTo100PercentMinusLength(length);
 399 
 400     return length;
 401 }
 402 
 403 inline LengthPoint StyleBuilderConverter::convertObjectPosition(StyleResolver&amp; styleResolver, const CSSValue&amp; value)
 404 {
 405     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
 406     Pair* pair = primitiveValue.pairValue();
 407     if (!pair || !pair-&gt;first() || !pair-&gt;second())
 408         return RenderStyle::initialObjectPosition();
 409 
 410     Length lengthX = convertPositionComponent&lt;CSSValueLeft, CSSValueRight&gt;(styleResolver, *pair-&gt;first());
 411     Length lengthY = convertPositionComponent&lt;CSSValueTop, CSSValueBottom&gt;(styleResolver, *pair-&gt;second());
 412 
 413     return LengthPoint(lengthX, lengthY);
 414 }
 415 
 416 inline OptionSet&lt;TextDecoration&gt; StyleBuilderConverter::convertTextDecoration(StyleResolver&amp;, const CSSValue&amp; value)
 417 {
 418     auto result = RenderStyle::initialTextDecoration();
 419     if (is&lt;CSSValueList&gt;(value)) {
 420         for (auto&amp; currentValue : downcast&lt;CSSValueList&gt;(value))
 421             result.add(downcast&lt;CSSPrimitiveValue&gt;(currentValue.get()));
 422     }
 423     return result;
 424 }
 425 
 426 template&lt;typename T&gt;
 427 inline T StyleBuilderConverter::convertNumber(StyleResolver&amp;, const CSSValue&amp; value)
 428 {
 429     return downcast&lt;CSSPrimitiveValue&gt;(value).value&lt;T&gt;(CSSPrimitiveValue::CSS_NUMBER);
 430 }
 431 
 432 template&lt;typename T&gt;
 433 inline T StyleBuilderConverter::convertNumberOrAuto(StyleResolver&amp; styleResolver, const CSSValue&amp; value)
 434 {
 435     if (downcast&lt;CSSPrimitiveValue&gt;(value).valueID() == CSSValueAuto)
 436         return -1;
 437     return convertNumber&lt;T&gt;(styleResolver, value);
 438 }
 439 
 440 inline short StyleBuilderConverter::convertWebkitHyphenateLimitLines(StyleResolver&amp;, const CSSValue&amp; value)
 441 {
 442     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
 443     if (primitiveValue.valueID() == CSSValueNoLimit)
 444         return -1;
 445     return primitiveValue.value&lt;short&gt;(CSSPrimitiveValue::CSS_NUMBER);
 446 }
 447 
 448 template&lt;CSSPropertyID property&gt;
 449 inline NinePieceImage StyleBuilderConverter::convertBorderImage(StyleResolver&amp; styleResolver, CSSValue&amp; value)
 450 {
 451     NinePieceImage image;
 452     styleResolver.styleMap()-&gt;mapNinePieceImage(property, &amp;value, image);
 453     return image;
 454 }
 455 
 456 template&lt;CSSPropertyID property&gt;
 457 inline NinePieceImage StyleBuilderConverter::convertBorderMask(StyleResolver&amp; styleResolver, CSSValue&amp; value)
 458 {
 459     NinePieceImage image;
 460     image.setMaskDefaults();
 461     styleResolver.styleMap()-&gt;mapNinePieceImage(property, &amp;value, image);
 462     return image;
 463 }
 464 
 465 template&lt;CSSPropertyID&gt;
 466 inline RefPtr&lt;StyleImage&gt; StyleBuilderConverter::convertStyleImage(StyleResolver&amp; styleResolver, CSSValue&amp; value)
 467 {
 468     return styleResolver.styleImage(value);
 469 }
 470 
 471 inline TransformOperations StyleBuilderConverter::convertTransform(StyleResolver&amp; styleResolver, const CSSValue&amp; value)
 472 {
 473     TransformOperations operations;
 474     transformsForValue(value, styleResolver.state().cssToLengthConversionData(), operations);
 475     return operations;
 476 }
 477 
 478 #if ENABLE(DARK_MODE_CSS)
 479 inline void StyleBuilderConverter::updateColorScheme(const CSSPrimitiveValue&amp; primitiveValue, StyleColorScheme&amp; colorScheme)
 480 {
 481     ASSERT(primitiveValue.isValueID());
 482 
 483     switch (primitiveValue.valueID()) {
 484     case CSSValueAuto:
 485         colorScheme = StyleColorScheme();
 486         break;
 487     case CSSValueOnly:
 488         colorScheme.setAllowsTransformations(false);
 489         break;
 490     case CSSValueLight:
 491         colorScheme.add(ColorScheme::Light);
 492         break;
 493     case CSSValueDark:
 494         colorScheme.add(ColorScheme::Dark);
 495         break;
 496     default:
 497         // Unknown identifiers are allowed and ignored.
 498         break;
 499     }
 500 }
 501 
 502 inline StyleColorScheme StyleBuilderConverter::convertColorScheme(StyleResolver&amp;, const CSSValue&amp; value)
 503 {
 504     StyleColorScheme colorScheme;
 505 
 506     if (is&lt;CSSValueList&gt;(value)) {
 507         for (auto&amp; currentValue : downcast&lt;CSSValueList&gt;(value))
 508             updateColorScheme(downcast&lt;CSSPrimitiveValue&gt;(currentValue.get()), colorScheme);
 509     } else if (is&lt;CSSPrimitiveValue&gt;(value))
 510         updateColorScheme(downcast&lt;CSSPrimitiveValue&gt;(value), colorScheme);
 511 
 512     // If the value was just &quot;only&quot;, that is synonymous for &quot;only light&quot;.
 513     if (colorScheme.isOnly())
 514         colorScheme.add(ColorScheme::Light);
 515 
 516     return colorScheme;
 517 }
 518 #endif
 519 
 520 inline String StyleBuilderConverter::convertString(StyleResolver&amp;, const CSSValue&amp; value)
 521 {
 522     return downcast&lt;CSSPrimitiveValue&gt;(value).stringValue();
 523 }
 524 
 525 inline String StyleBuilderConverter::convertStringOrAuto(StyleResolver&amp; styleResolver, const CSSValue&amp; value)
 526 {
 527     if (downcast&lt;CSSPrimitiveValue&gt;(value).valueID() == CSSValueAuto)
 528         return nullAtom();
 529     return convertString(styleResolver, value);
 530 }
 531 
 532 inline String StyleBuilderConverter::convertStringOrNone(StyleResolver&amp; styleResolver, const CSSValue&amp; value)
 533 {
 534     if (downcast&lt;CSSPrimitiveValue&gt;(value).valueID() == CSSValueNone)
 535         return nullAtom();
 536     return convertString(styleResolver, value);
 537 }
 538 
 539 inline OptionSet&lt;TextEmphasisPosition&gt; StyleBuilderConverter::valueToEmphasisPosition(const CSSPrimitiveValue&amp; primitiveValue)
 540 {
 541     ASSERT(primitiveValue.isValueID());
 542 
 543     switch (primitiveValue.valueID()) {
 544     case CSSValueOver:
 545         return TextEmphasisPosition::Over;
 546     case CSSValueUnder:
 547         return TextEmphasisPosition::Under;
 548     case CSSValueLeft:
 549         return TextEmphasisPosition::Left;
 550     case CSSValueRight:
 551         return TextEmphasisPosition::Right;
 552     default:
 553         break;
 554     }
 555 
 556     ASSERT_NOT_REACHED();
 557     return RenderStyle::initialTextEmphasisPosition();
 558 }
 559 
 560 inline OptionSet&lt;TextEmphasisPosition&gt; StyleBuilderConverter::convertTextEmphasisPosition(StyleResolver&amp;, const CSSValue&amp; value)
 561 {
 562     if (is&lt;CSSPrimitiveValue&gt;(value))
 563         return valueToEmphasisPosition(downcast&lt;CSSPrimitiveValue&gt;(value));
 564 
 565     OptionSet&lt;TextEmphasisPosition&gt; position;
 566     for (auto&amp; currentValue : downcast&lt;CSSValueList&gt;(value))
 567         position.add(valueToEmphasisPosition(downcast&lt;CSSPrimitiveValue&gt;(currentValue.get())));
 568     return position;
 569 }
 570 
 571 inline TextAlignMode StyleBuilderConverter::convertTextAlign(StyleResolver&amp; styleResolver, const CSSValue&amp; value)
 572 {
 573     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
 574     ASSERT(primitiveValue.isValueID());
 575 
 576     if (primitiveValue.valueID() != CSSValueWebkitMatchParent)
 577         return primitiveValue;
 578 
 579     auto* parentStyle = styleResolver.parentStyle();
 580     if (parentStyle-&gt;textAlign() == TextAlignMode::Start)
 581         return parentStyle-&gt;isLeftToRightDirection() ? TextAlignMode::Left : TextAlignMode::Right;
 582     if (parentStyle-&gt;textAlign() == TextAlignMode::End)
 583         return parentStyle-&gt;isLeftToRightDirection() ? TextAlignMode::Right : TextAlignMode::Left;
 584     return parentStyle-&gt;textAlign();
 585 }
 586 
 587 inline RefPtr&lt;ClipPathOperation&gt; StyleBuilderConverter::convertClipPath(StyleResolver&amp; styleResolver, const CSSValue&amp; value)
 588 {
 589     if (is&lt;CSSPrimitiveValue&gt;(value)) {
 590         auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
 591         if (primitiveValue.primitiveType() == CSSPrimitiveValue::CSS_URI) {
 592             String cssURLValue = primitiveValue.stringValue();
 593             String fragment = SVGURIReference::fragmentIdentifierFromIRIString(cssURLValue, styleResolver.document());
 594             // FIXME: It doesn&#39;t work with external SVG references (see https://bugs.webkit.org/show_bug.cgi?id=126133)
 595             return ReferenceClipPathOperation::create(cssURLValue, fragment);
 596         }
 597         ASSERT(primitiveValue.valueID() == CSSValueNone);
 598         return nullptr;
 599     }
 600 
 601     CSSBoxType referenceBox = CSSBoxType::BoxMissing;
 602     RefPtr&lt;ClipPathOperation&gt; operation;
 603 
 604     for (auto&amp; currentValue : downcast&lt;CSSValueList&gt;(value)) {
 605         auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(currentValue.get());
 606         if (primitiveValue.isShape()) {
 607             ASSERT(!operation);
 608             operation = ShapeClipPathOperation::create(basicShapeForValue(styleResolver.state().cssToLengthConversionData(), *primitiveValue.shapeValue()));
 609         } else {
 610             ASSERT(primitiveValue.valueID() == CSSValueContentBox
 611                 || primitiveValue.valueID() == CSSValueBorderBox
 612                 || primitiveValue.valueID() == CSSValuePaddingBox
 613                 || primitiveValue.valueID() == CSSValueMarginBox
 614                 || primitiveValue.valueID() == CSSValueFillBox
 615                 || primitiveValue.valueID() == CSSValueStrokeBox
 616                 || primitiveValue.valueID() == CSSValueViewBox);
 617             ASSERT(referenceBox == CSSBoxType::BoxMissing);
 618             referenceBox = primitiveValue;
 619         }
 620     }
 621     if (operation)
 622         downcast&lt;ShapeClipPathOperation&gt;(*operation).setReferenceBox(referenceBox);
 623     else {
 624         ASSERT(referenceBox != CSSBoxType::BoxMissing);
 625         operation = BoxClipPathOperation::create(referenceBox);
 626     }
 627 
 628     return operation;
 629 }
 630 
 631 inline Resize StyleBuilderConverter::convertResize(StyleResolver&amp; styleResolver, const CSSValue&amp; value)
 632 {
 633     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
 634 
 635     Resize resize = Resize::None;
 636     if (primitiveValue.valueID() == CSSValueAuto)
 637         resize = styleResolver.settings().textAreasAreResizable() ? Resize::Both : Resize::None;
 638     else
 639         resize = primitiveValue;
 640 
 641     return resize;
 642 }
 643 
 644 inline int StyleBuilderConverter::convertMarqueeRepetition(StyleResolver&amp;, const CSSValue&amp; value)
 645 {
 646     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
 647     if (primitiveValue.valueID() == CSSValueInfinite)
 648         return -1; // -1 means repeat forever.
 649 
 650     ASSERT(primitiveValue.isNumber());
 651     return primitiveValue.intValue();
 652 }
 653 
 654 inline int StyleBuilderConverter::convertMarqueeSpeed(StyleResolver&amp;, const CSSValue&amp; value)
 655 {
 656     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
 657     int speed = 85;
 658     if (CSSValueID ident = primitiveValue.valueID()) {
 659         switch (ident) {
 660         case CSSValueSlow:
 661             speed = 500; // 500 msec.
 662             break;
 663         case CSSValueNormal:
 664             speed = 85; // 85msec. The WinIE default.
 665             break;
 666         case CSSValueFast:
 667             speed = 10; // 10msec. Super fast.
 668             break;
 669         default:
 670             ASSERT_NOT_REACHED();
 671             break;
 672         }
 673     } else if (primitiveValue.isTime())
 674         speed = primitiveValue.computeTime&lt;int, CSSPrimitiveValue::Milliseconds&gt;();
 675     else {
 676         // For scrollamount support.
 677         ASSERT(primitiveValue.isNumber());
 678         speed = primitiveValue.intValue();
 679     }
 680     return speed;
 681 }
 682 
 683 inline Ref&lt;QuotesData&gt; StyleBuilderConverter::convertQuotes(StyleResolver&amp;, const CSSValue&amp; value)
 684 {
 685     if (is&lt;CSSPrimitiveValue&gt;(value)) {
 686         ASSERT(downcast&lt;CSSPrimitiveValue&gt;(value).valueID() == CSSValueNone);
 687         return QuotesData::create(Vector&lt;std::pair&lt;String, String&gt;&gt;());
 688     }
 689 
 690     auto&amp; list = downcast&lt;CSSValueList&gt;(value);
 691     Vector&lt;std::pair&lt;String, String&gt;&gt; quotes;
 692     quotes.reserveInitialCapacity(list.length() / 2);
 693     for (unsigned i = 0; i &lt; list.length(); i += 2) {
 694         const CSSValue* first = list.itemWithoutBoundsCheck(i);
 695         // item() returns null if out of bounds so this is safe.
 696         const CSSValue* second = list.item(i + 1);
 697         if (!second)
 698             break;
 699         String startQuote = downcast&lt;CSSPrimitiveValue&gt;(*first).stringValue();
 700         String endQuote = downcast&lt;CSSPrimitiveValue&gt;(*second).stringValue();
 701         quotes.append(std::make_pair(startQuote, endQuote));
 702     }
 703     return QuotesData::create(quotes);
 704 }
 705 
 706 inline TextUnderlinePosition StyleBuilderConverter::convertTextUnderlinePosition(StyleResolver&amp;, const CSSValue&amp; value)
 707 {
 708     ASSERT(is&lt;CSSPrimitiveValue&gt;(value));
 709     return downcast&lt;CSSPrimitiveValue&gt;(value);
 710 }
 711 
 712 inline TextUnderlineOffset StyleBuilderConverter::convertTextUnderlineOffset(StyleResolver&amp; styleResolver, const CSSValue&amp; value)
 713 {
 714     ASSERT(is&lt;CSSPrimitiveValue&gt;(value));
 715     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
 716     switch (primitiveValue.valueID()) {
 717     case CSSValueAuto:
 718         return TextUnderlineOffset::createWithAuto();
 719     default:
 720         ASSERT(primitiveValue.isLength());
 721         auto computedLength = convertComputedLength&lt;float&gt;(styleResolver, primitiveValue);
 722         return TextUnderlineOffset::createWithLength(computedLength);
 723     }
 724 }
 725 
 726 inline TextDecorationThickness StyleBuilderConverter::convertTextDecorationThickness(StyleResolver&amp; styleResolver, const CSSValue&amp; value)
 727 {
 728     ASSERT(is&lt;CSSPrimitiveValue&gt;(value));
 729     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
 730     switch (primitiveValue.valueID()) {
 731     case CSSValueAuto:
 732         return TextDecorationThickness::createWithAuto();
 733     case CSSValueFromFont:
 734         return TextDecorationThickness::createFromFont();
 735     default:
 736         ASSERT(primitiveValue.isLength());
 737         auto computedLength = convertComputedLength&lt;float&gt;(styleResolver, primitiveValue);
 738         return TextDecorationThickness::createWithLength(computedLength);
 739     }
 740 }
 741 
 742 inline RefPtr&lt;StyleReflection&gt; StyleBuilderConverter::convertReflection(StyleResolver&amp; styleResolver, const CSSValue&amp; value)
 743 {
 744     if (is&lt;CSSPrimitiveValue&gt;(value)) {
 745         ASSERT(downcast&lt;CSSPrimitiveValue&gt;(value).valueID() == CSSValueNone);
 746         return nullptr;
 747     }
 748 
 749     auto&amp; reflectValue = downcast&lt;CSSReflectValue&gt;(value);
 750 
 751     auto reflection = StyleReflection::create();
 752     reflection-&gt;setDirection(reflectValue.direction());
 753     reflection-&gt;setOffset(reflectValue.offset().convertToLength&lt;FixedIntegerConversion | PercentConversion | CalculatedConversion&gt;(styleResolver.state().cssToLengthConversionData()));
 754 
 755     NinePieceImage mask;
 756     mask.setMaskDefaults();
 757     styleResolver.styleMap()-&gt;mapNinePieceImage(CSSPropertyWebkitBoxReflect, reflectValue.mask(), mask);
 758     reflection-&gt;setMask(mask);
 759 
 760     return reflection;
 761 }
 762 
 763 inline IntSize StyleBuilderConverter::convertInitialLetter(StyleResolver&amp;, const CSSValue&amp; value)
 764 {
 765     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
 766 
 767     if (primitiveValue.valueID() == CSSValueNormal)
 768         return IntSize();
 769 
 770     Pair* pair = primitiveValue.pairValue();
 771     ASSERT(pair);
 772     ASSERT(pair-&gt;first());
 773     ASSERT(pair-&gt;second());
 774 
 775     return IntSize(pair-&gt;first()-&gt;intValue(), pair-&gt;second()-&gt;intValue());
 776 }
 777 
 778 inline float StyleBuilderConverter::convertTextStrokeWidth(StyleResolver&amp; styleResolver, const CSSValue&amp; value)
 779 {
 780     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
 781 
 782     float width = 0;
 783     switch (primitiveValue.valueID()) {
 784     case CSSValueThin:
 785     case CSSValueMedium:
 786     case CSSValueThick: {
 787         double result = 1.0 / 48;
 788         if (primitiveValue.valueID() == CSSValueMedium)
 789             result *= 3;
 790         else if (primitiveValue.valueID() == CSSValueThick)
 791             result *= 5;
 792         Ref&lt;CSSPrimitiveValue&gt; emsValue(CSSPrimitiveValue::create(result, CSSPrimitiveValue::CSS_EMS));
 793         width = convertComputedLength&lt;float&gt;(styleResolver, emsValue);
 794         break;
 795     }
 796     case CSSValueInvalid: {
 797         width = convertComputedLength&lt;float&gt;(styleResolver, primitiveValue);
 798         break;
 799     }
 800     default:
 801         ASSERT_NOT_REACHED();
 802         return 0;
 803     }
 804 
 805     return width;
 806 }
 807 
 808 inline LineBoxContain StyleBuilderConverter::convertLineBoxContain(StyleResolver&amp;, const CSSValue&amp; value)
 809 {
 810     if (is&lt;CSSPrimitiveValue&gt;(value)) {
 811         ASSERT(downcast&lt;CSSPrimitiveValue&gt;(value).valueID() == CSSValueNone);
 812         return LineBoxContainNone;
 813     }
 814 
 815     return downcast&lt;CSSLineBoxContainValue&gt;(value).value();
 816 }
 817 
 818 inline OptionSet&lt;TextDecorationSkip&gt; StyleBuilderConverter::valueToDecorationSkip(const CSSPrimitiveValue&amp; primitiveValue)
 819 {
 820     ASSERT(primitiveValue.isValueID());
 821 
 822     switch (primitiveValue.valueID()) {
 823     case CSSValueAuto:
 824         return TextDecorationSkip::Auto;
 825     case CSSValueNone:
 826         return OptionSet&lt;TextDecorationSkip&gt; { };
 827     case CSSValueInk:
 828         return TextDecorationSkip::Ink;
 829     case CSSValueObjects:
 830         return TextDecorationSkip::Objects;
 831     default:
 832         break;
 833     }
 834 
 835     ASSERT_NOT_REACHED();
 836     return OptionSet&lt;TextDecorationSkip&gt; { };
 837 }
 838 
 839 inline OptionSet&lt;TextDecorationSkip&gt; StyleBuilderConverter::convertTextDecorationSkip(StyleResolver&amp;, const CSSValue&amp; value)
 840 {
 841     if (is&lt;CSSPrimitiveValue&gt;(value))
 842         return valueToDecorationSkip(downcast&lt;CSSPrimitiveValue&gt;(value));
 843 
 844     OptionSet&lt;TextDecorationSkip&gt; skip;
 845     for (auto&amp; currentValue : downcast&lt;CSSValueList&gt;(value))
 846         skip.add(valueToDecorationSkip(downcast&lt;CSSPrimitiveValue&gt;(currentValue.get())));
 847     return skip;
 848 }
 849 
 850 static inline bool isImageShape(const CSSValue&amp; value)
 851 {
 852     return is&lt;CSSImageValue&gt;(value) || is&lt;CSSImageSetValue&gt;(value) || is&lt;CSSImageGeneratorValue&gt;(value);
 853 }
 854 
 855 inline RefPtr&lt;ShapeValue&gt; StyleBuilderConverter::convertShapeValue(StyleResolver&amp; styleResolver, CSSValue&amp; value)
 856 {
 857     if (is&lt;CSSPrimitiveValue&gt;(value)) {
 858         ASSERT(downcast&lt;CSSPrimitiveValue&gt;(value).valueID() == CSSValueNone);
 859         return nullptr;
 860     }
 861 
 862     if (isImageShape(value))
 863         return ShapeValue::create(styleResolver.styleImage(value).releaseNonNull());
 864 
 865     RefPtr&lt;BasicShape&gt; shape;
 866     CSSBoxType referenceBox = CSSBoxType::BoxMissing;
 867     for (auto&amp; currentValue : downcast&lt;CSSValueList&gt;(value)) {
 868         auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(currentValue.get());
 869         if (primitiveValue.isShape())
 870             shape = basicShapeForValue(styleResolver.state().cssToLengthConversionData(), *primitiveValue.shapeValue());
 871         else if (primitiveValue.valueID() == CSSValueContentBox
 872             || primitiveValue.valueID() == CSSValueBorderBox
 873             || primitiveValue.valueID() == CSSValuePaddingBox
 874             || primitiveValue.valueID() == CSSValueMarginBox)
 875             referenceBox = primitiveValue;
 876         else {
 877             ASSERT_NOT_REACHED();
 878             return nullptr;
 879         }
 880     }
 881 
 882     if (shape)
 883         return ShapeValue::create(shape.releaseNonNull(), referenceBox);
 884 
 885     if (referenceBox != CSSBoxType::BoxMissing)
 886         return ShapeValue::create(referenceBox);
 887 
 888     ASSERT_NOT_REACHED();
 889     return nullptr;
 890 }
 891 
 892 #if ENABLE(CSS_SCROLL_SNAP)
 893 
 894 inline ScrollSnapType StyleBuilderConverter::convertScrollSnapType(StyleResolver&amp;, const CSSValue&amp; value)
 895 {
 896     ScrollSnapType type;
 897     auto&amp; values = downcast&lt;CSSValueList&gt;(value);
 898     auto&amp; firstValue = downcast&lt;CSSPrimitiveValue&gt;(*values.item(0));
 899     if (values.length() == 2) {
 900         type.axis = firstValue;
 901         type.strictness = downcast&lt;CSSPrimitiveValue&gt;(*values.item(1));
 902         return type;
 903     }
 904 
 905     switch (firstValue.valueID()) {
 906     case CSSValueNone:
 907     case CSSValueMandatory:
 908     case CSSValueProximity:
 909         type.strictness = firstValue;
 910         break;
 911     default:
 912         type.axis = firstValue;
 913         type.strictness = ScrollSnapStrictness::Proximity;
 914         break;
 915     }
 916     return type;
 917 }
 918 
 919 inline ScrollSnapAlign StyleBuilderConverter::convertScrollSnapAlign(StyleResolver&amp;, const CSSValue&amp; value)
 920 {
 921     auto&amp; values = downcast&lt;CSSValueList&gt;(value);
 922     ScrollSnapAlign alignment;
 923     alignment.x = downcast&lt;CSSPrimitiveValue&gt;(*values.item(0));
 924     if (values.length() == 1)
 925         alignment.y = alignment.x;
 926     else
 927         alignment.y = downcast&lt;CSSPrimitiveValue&gt;(*values.item(1));
 928     return alignment;
 929 }
 930 
 931 #endif
 932 
 933 inline GridLength StyleBuilderConverter::createGridTrackBreadth(const CSSPrimitiveValue&amp; primitiveValue, StyleResolver&amp; styleResolver)
 934 {
 935     if (primitiveValue.valueID() == CSSValueMinContent || primitiveValue.valueID() == CSSValueWebkitMinContent)
 936         return Length(MinContent);
 937 
 938     if (primitiveValue.valueID() == CSSValueMaxContent || primitiveValue.valueID() == CSSValueWebkitMaxContent)
 939         return Length(MaxContent);
 940 
 941     // Fractional unit.
 942     if (primitiveValue.isFlex())
 943         return GridLength(primitiveValue.doubleValue());
 944 
 945     return primitiveValue.convertToLength&lt;FixedIntegerConversion | PercentConversion | CalculatedConversion | AutoConversion&gt;(styleResolver.state().cssToLengthConversionData());
 946 }
 947 
 948 inline GridTrackSize StyleBuilderConverter::createGridTrackSize(const CSSValue&amp; value, StyleResolver&amp; styleResolver)
 949 {
 950     if (is&lt;CSSPrimitiveValue&gt;(value))
 951         return GridTrackSize(createGridTrackBreadth(downcast&lt;CSSPrimitiveValue&gt;(value), styleResolver));
 952 
 953     ASSERT(is&lt;CSSFunctionValue&gt;(value));
 954     const auto&amp; function = downcast&lt;CSSFunctionValue&gt;(value);
 955 
 956     if (function.length() == 1)
 957         return GridTrackSize(createGridTrackBreadth(downcast&lt;CSSPrimitiveValue&gt;(*function.itemWithoutBoundsCheck(0)), styleResolver), FitContentTrackSizing);
 958 
 959     ASSERT_WITH_SECURITY_IMPLICATION(function.length() == 2);
 960     GridLength minTrackBreadth(createGridTrackBreadth(downcast&lt;CSSPrimitiveValue&gt;(*function.itemWithoutBoundsCheck(0)), styleResolver));
 961     GridLength maxTrackBreadth(createGridTrackBreadth(downcast&lt;CSSPrimitiveValue&gt;(*function.itemWithoutBoundsCheck(1)), styleResolver));
 962     return GridTrackSize(minTrackBreadth, maxTrackBreadth);
 963 }
 964 
 965 static void createGridLineNamesList(const CSSValue&amp; value, unsigned currentNamedGridLine, NamedGridLinesMap&amp; namedGridLines, OrderedNamedGridLinesMap&amp; orderedNamedGridLines)
 966 {
 967     ASSERT(value.isGridLineNamesValue());
 968 
 969     for (auto&amp; namedGridLineValue : downcast&lt;CSSGridLineNamesValue&gt;(value)) {
 970         String namedGridLine = downcast&lt;CSSPrimitiveValue&gt;(namedGridLineValue.get()).stringValue();
 971         auto result = namedGridLines.add(namedGridLine, Vector&lt;unsigned&gt;());
 972         result.iterator-&gt;value.append(currentNamedGridLine);
 973         auto orderedResult = orderedNamedGridLines.add(currentNamedGridLine, Vector&lt;String&gt;());
 974         orderedResult.iterator-&gt;value.append(namedGridLine);
 975     }
 976 }
 977 
 978 struct StyleBuilderConverter::TracksData {
 979     WTF_MAKE_NONCOPYABLE(TracksData); WTF_MAKE_FAST_ALLOCATED;
 980 public:
 981     TracksData() = default;
 982 
 983     Vector&lt;GridTrackSize&gt; m_trackSizes;
 984     NamedGridLinesMap m_namedGridLines;
 985     OrderedNamedGridLinesMap m_orderedNamedGridLines;
 986     Vector&lt;GridTrackSize&gt; m_autoRepeatTrackSizes;
 987     NamedGridLinesMap m_autoRepeatNamedGridLines;
 988     OrderedNamedGridLinesMap m_autoRepeatOrderedNamedGridLines;
 989     unsigned m_autoRepeatInsertionPoint { RenderStyle::initialGridAutoRepeatInsertionPoint() };
 990     AutoRepeatType m_autoRepeatType { RenderStyle::initialGridAutoRepeatType() };
 991 };
 992 
 993 inline bool StyleBuilderConverter::createGridTrackList(const CSSValue&amp; value, TracksData&amp; tracksData, StyleResolver&amp; styleResolver)
 994 {
 995     // Handle &#39;none&#39;.
 996     if (is&lt;CSSPrimitiveValue&gt;(value))
 997         return downcast&lt;CSSPrimitiveValue&gt;(value).valueID() == CSSValueNone;
 998 
 999     if (!is&lt;CSSValueList&gt;(value))
1000         return false;
1001 
1002     unsigned currentNamedGridLine = 0;
1003     auto handleLineNameOrTrackSize = [&amp;](const CSSValue&amp; currentValue) {
1004         if (is&lt;CSSGridLineNamesValue&gt;(currentValue))
1005             createGridLineNamesList(currentValue, currentNamedGridLine, tracksData.m_namedGridLines, tracksData.m_orderedNamedGridLines);
1006         else {
1007             ++currentNamedGridLine;
1008             tracksData.m_trackSizes.append(createGridTrackSize(currentValue, styleResolver));
1009         }
1010     };
1011 
1012     for (auto&amp; currentValue : downcast&lt;CSSValueList&gt;(value)) {
1013         if (is&lt;CSSGridAutoRepeatValue&gt;(currentValue)) {
1014             ASSERT(tracksData.m_autoRepeatTrackSizes.isEmpty());
1015             unsigned autoRepeatIndex = 0;
1016             CSSValueID autoRepeatID = downcast&lt;CSSGridAutoRepeatValue&gt;(currentValue.get()).autoRepeatID();
1017             ASSERT(autoRepeatID == CSSValueAutoFill || autoRepeatID == CSSValueAutoFit);
1018             tracksData.m_autoRepeatType = autoRepeatID == CSSValueAutoFill ? AutoRepeatType::Fill : AutoRepeatType::Fit;
1019             for (auto&amp; autoRepeatValue : downcast&lt;CSSValueList&gt;(currentValue.get())) {
1020                 if (is&lt;CSSGridLineNamesValue&gt;(autoRepeatValue)) {
1021                     createGridLineNamesList(autoRepeatValue.get(), autoRepeatIndex, tracksData.m_autoRepeatNamedGridLines, tracksData.m_autoRepeatOrderedNamedGridLines);
1022                     continue;
1023                 }
1024                 ++autoRepeatIndex;
1025                 tracksData.m_autoRepeatTrackSizes.append(createGridTrackSize(autoRepeatValue.get(), styleResolver));
1026             }
1027             tracksData.m_autoRepeatInsertionPoint = currentNamedGridLine++;
1028             continue;
1029         }
1030 
1031         if (is&lt;CSSGridIntegerRepeatValue&gt;(currentValue)) {
1032             size_t repetitions = downcast&lt;CSSGridIntegerRepeatValue&gt;(currentValue.get()).repetitions();
1033             for (size_t i = 0; i &lt; repetitions; ++i) {
1034                 for (auto&amp; integerRepeatValue : downcast&lt;CSSValueList&gt;(currentValue.get()))
1035                     handleLineNameOrTrackSize(integerRepeatValue);
1036             }
1037             continue;
1038         }
1039 
1040         handleLineNameOrTrackSize(currentValue);
1041     }
1042 
1043     // The parser should have rejected any &lt;track-list&gt; without any &lt;track-size&gt; as
1044     // this is not conformant to the syntax.
1045     ASSERT(!tracksData.m_trackSizes.isEmpty() || !tracksData.m_autoRepeatTrackSizes.isEmpty());
1046     return true;
1047 }
1048 
1049 inline bool StyleBuilderConverter::createGridPosition(const CSSValue&amp; value, GridPosition&amp; position)
1050 {
1051     // We accept the specification&#39;s grammar:
1052     // auto | &lt;custom-ident&gt; | [ &lt;integer&gt; &amp;&amp; &lt;custom-ident&gt;? ] | [ span &amp;&amp; [ &lt;integer&gt; || &lt;custom-ident&gt; ] ]
1053     if (is&lt;CSSPrimitiveValue&gt;(value)) {
1054         auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
1055         // We translate &lt;ident&gt; to &lt;string&gt; during parsing as it makes handling it simpler.
1056         if (primitiveValue.isString()) {
1057             position.setNamedGridArea(primitiveValue.stringValue());
1058             return true;
1059         }
1060 
1061         ASSERT(primitiveValue.valueID() == CSSValueAuto);
1062         return true;
1063     }
1064 
1065     auto&amp; values = downcast&lt;CSSValueList&gt;(value);
1066     ASSERT(values.length());
1067 
1068     auto it = values.begin();
1069     const CSSPrimitiveValue* currentValue = &amp;downcast&lt;CSSPrimitiveValue&gt;(it-&gt;get());
1070     bool isSpanPosition = false;
1071     if (currentValue-&gt;valueID() == CSSValueSpan) {
1072         isSpanPosition = true;
1073         ++it;
1074         currentValue = it != values.end() ? &amp;downcast&lt;CSSPrimitiveValue&gt;(it-&gt;get()) : nullptr;
1075     }
1076 
1077     int gridLineNumber = 0;
1078     if (currentValue &amp;&amp; currentValue-&gt;isNumber()) {
1079         gridLineNumber = currentValue-&gt;intValue();
1080         ++it;
1081         currentValue = it != values.end() ? &amp;downcast&lt;CSSPrimitiveValue&gt;(it-&gt;get()) : nullptr;
1082     }
1083 
1084     String gridLineName;
1085     if (currentValue &amp;&amp; currentValue-&gt;isString()) {
1086         gridLineName = currentValue-&gt;stringValue();
1087         ++it;
1088     }
1089 
1090     ASSERT(it == values.end());
1091     if (isSpanPosition)
1092         position.setSpanPosition(gridLineNumber ? gridLineNumber : 1, gridLineName);
1093     else
1094         position.setExplicitPosition(gridLineNumber, gridLineName);
1095 
1096     return true;
1097 }
1098 
1099 inline void StyleBuilderConverter::createImplicitNamedGridLinesFromGridArea(const NamedGridAreaMap&amp; namedGridAreas, NamedGridLinesMap&amp; namedGridLines, GridTrackSizingDirection direction)
1100 {
1101     for (auto&amp; area : namedGridAreas) {
1102         GridSpan areaSpan = direction == ForRows ? area.value.rows : area.value.columns;
1103         {
1104             auto&amp; startVector = namedGridLines.add(area.key + &quot;-start&quot;, Vector&lt;unsigned&gt;()).iterator-&gt;value;
1105             startVector.append(areaSpan.startLine());
1106             std::sort(startVector.begin(), startVector.end());
1107         }
1108         {
1109             auto&amp; endVector = namedGridLines.add(area.key + &quot;-end&quot;, Vector&lt;unsigned&gt;()).iterator-&gt;value;
1110             endVector.append(areaSpan.endLine());
1111             std::sort(endVector.begin(), endVector.end());
1112         }
1113     }
1114 }
1115 
1116 inline Vector&lt;GridTrackSize&gt; StyleBuilderConverter::convertGridTrackSizeList(StyleResolver&amp; styleResolver, const CSSValue&amp; value)
1117 {
1118     ASSERT(value.isValueList());
1119     auto&amp; valueList = downcast&lt;CSSValueList&gt;(value);
1120     Vector&lt;GridTrackSize&gt; trackSizes;
1121     trackSizes.reserveInitialCapacity(valueList.length());
1122     for (auto&amp; currValue : valueList) {
1123         ASSERT(!currValue-&gt;isGridLineNamesValue());
1124         ASSERT(!currValue-&gt;isGridAutoRepeatValue());
1125         ASSERT(!currValue-&gt;isGridIntegerRepeatValue());
1126         trackSizes.uncheckedAppend(convertGridTrackSize(styleResolver, currValue));
1127     }
1128     return trackSizes;
1129 }
1130 
1131 inline GridTrackSize StyleBuilderConverter::convertGridTrackSize(StyleResolver&amp; styleResolver, const CSSValue&amp; value)
1132 {
1133     return createGridTrackSize(value, styleResolver);
1134 }
1135 
1136 inline Optional&lt;GridPosition&gt; StyleBuilderConverter::convertGridPosition(StyleResolver&amp;, const CSSValue&amp; value)
1137 {
1138     GridPosition gridPosition;
1139     if (createGridPosition(value, gridPosition))
1140         return gridPosition;
1141     return WTF::nullopt;
1142 }
1143 
1144 inline GridAutoFlow StyleBuilderConverter::convertGridAutoFlow(StyleResolver&amp;, const CSSValue&amp; value)
1145 {
1146     auto&amp; list = downcast&lt;CSSValueList&gt;(value);
1147     if (!list.length())
1148         return RenderStyle::initialGridAutoFlow();
1149 
1150     auto&amp; first = downcast&lt;CSSPrimitiveValue&gt;(*list.item(0));
1151     auto* second = downcast&lt;CSSPrimitiveValue&gt;(list.item(1));
1152 
1153     GridAutoFlow autoFlow;
1154     switch (first.valueID()) {
1155     case CSSValueRow:
1156         if (second &amp;&amp; second-&gt;valueID() == CSSValueDense)
1157             autoFlow = AutoFlowRowDense;
1158         else
1159             autoFlow = AutoFlowRow;
1160         break;
1161     case CSSValueColumn:
1162         if (second &amp;&amp; second-&gt;valueID() == CSSValueDense)
1163             autoFlow = AutoFlowColumnDense;
1164         else
1165             autoFlow = AutoFlowColumn;
1166         break;
1167     case CSSValueDense:
1168         if (second &amp;&amp; second-&gt;valueID() == CSSValueColumn)
1169             autoFlow = AutoFlowColumnDense;
1170         else
1171             autoFlow = AutoFlowRowDense;
1172         break;
1173     default:
1174         ASSERT_NOT_REACHED();
1175         autoFlow = RenderStyle::initialGridAutoFlow();
1176         break;
1177     }
1178 
1179     return autoFlow;
1180 }
1181 
1182 inline CSSToLengthConversionData StyleBuilderConverter::csstoLengthConversionDataWithTextZoomFactor(StyleResolver&amp; styleResolver)
1183 {
1184     if (auto* frame = styleResolver.document().frame()) {
1185         float textZoomFactor = styleResolver.style()-&gt;textZoom() != TextZoom::Reset ? frame-&gt;textZoomFactor() : 1.0f;
1186         return styleResolver.state().cssToLengthConversionData().copyWithAdjustedZoom(styleResolver.style()-&gt;effectiveZoom() * textZoomFactor);
1187     }
1188     return styleResolver.state().cssToLengthConversionData();
1189 }
1190 
1191 inline Optional&lt;Length&gt; StyleBuilderConverter::convertWordSpacing(StyleResolver&amp; styleResolver, const CSSValue&amp; value)
1192 {
1193     Optional&lt;Length&gt; wordSpacing;
1194     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
1195     if (primitiveValue.valueID() == CSSValueNormal)
1196         wordSpacing = RenderStyle::initialWordSpacing();
1197     else if (primitiveValue.isLength())
1198         wordSpacing = primitiveValue.computeLength&lt;Length&gt;(csstoLengthConversionDataWithTextZoomFactor(styleResolver));
1199     else if (primitiveValue.isPercentage())
1200         wordSpacing = Length(clampTo&lt;float&gt;(primitiveValue.doubleValue(), minValueForCssLength, maxValueForCssLength), Percent);
1201     else if (primitiveValue.isNumber())
1202         wordSpacing = Length(primitiveValue.doubleValue(), Fixed);
1203 
1204     return wordSpacing;
1205 }
1206 
1207 inline Optional&lt;float&gt; StyleBuilderConverter::convertPerspective(StyleResolver&amp; styleResolver, const CSSValue&amp; value)
1208 {
1209     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
1210     if (primitiveValue.valueID() == CSSValueNone)
1211         return 0.f;
1212 
1213     float perspective = -1;
1214     if (primitiveValue.isLength())
1215         perspective = primitiveValue.computeLength&lt;float&gt;(styleResolver.state().cssToLengthConversionData());
1216     else if (primitiveValue.isNumber())
1217         perspective = primitiveValue.doubleValue() * styleResolver.state().cssToLengthConversionData().zoom();
1218     else
1219         ASSERT_NOT_REACHED();
1220 
1221     return perspective &lt; 0 ? Optional&lt;float&gt;(WTF::nullopt) : Optional&lt;float&gt;(perspective);
1222 }
1223 
1224 inline Optional&lt;Length&gt; StyleBuilderConverter::convertMarqueeIncrement(StyleResolver&amp; styleResolver, const CSSValue&amp; value)
1225 {
1226     Optional&lt;Length&gt; marqueeLength;
1227     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
1228     switch (primitiveValue.valueID()) {
1229     case CSSValueSmall:
1230         marqueeLength = Length(1, Fixed); // 1px.
1231         break;
1232     case CSSValueNormal:
1233         marqueeLength = Length(6, Fixed); // 6px. The WinIE default.
1234         break;
1235     case CSSValueLarge:
1236         marqueeLength = Length(36, Fixed); // 36px.
1237         break;
1238     case CSSValueInvalid: {
1239         Length length = primitiveValue.convertToLength&lt;FixedIntegerConversion | PercentConversion | CalculatedConversion&gt;(styleResolver.state().cssToLengthConversionData().copyWithAdjustedZoom(1.0f));
1240         if (!length.isUndefined())
1241             marqueeLength = length;
1242         break;
1243     }
1244     default:
1245         break;
1246     }
1247     return marqueeLength;
1248 }
1249 
1250 inline Optional&lt;FilterOperations&gt; StyleBuilderConverter::convertFilterOperations(StyleResolver&amp; styleResolver, const CSSValue&amp; value)
1251 {
1252     FilterOperations operations;
1253     if (styleResolver.createFilterOperations(value, operations))
1254         return operations;
1255     return WTF::nullopt;
1256 }
1257 
1258 inline FontFeatureSettings StyleBuilderConverter::convertFontFeatureSettings(StyleResolver&amp;, const CSSValue&amp; value)
1259 {
1260     if (is&lt;CSSPrimitiveValue&gt;(value)) {
1261         ASSERT(downcast&lt;CSSPrimitiveValue&gt;(value).valueID() == CSSValueNormal);
1262         return { };
1263     }
1264 
1265     FontFeatureSettings settings;
1266     for (auto&amp; item : downcast&lt;CSSValueList&gt;(value)) {
1267         auto&amp; feature = downcast&lt;CSSFontFeatureValue&gt;(item.get());
1268         settings.insert(FontFeature(feature.tag(), feature.value()));
1269     }
1270     return settings;
1271 }
1272 
1273 inline FontSelectionValue StyleBuilderConverter::convertFontWeightFromValue(const CSSValue&amp; value)
1274 {
1275     ASSERT(is&lt;CSSPrimitiveValue&gt;(value));
1276     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
1277 
1278     if (primitiveValue.isNumber())
1279         return FontSelectionValue::clampFloat(primitiveValue.floatValue());
1280 
1281     ASSERT(primitiveValue.isValueID());
1282     switch (primitiveValue.valueID()) {
1283     case CSSValueNormal:
1284         return normalWeightValue();
1285     case CSSValueBold:
1286     case CSSValueBolder:
1287         return boldWeightValue();
1288     case CSSValueLighter:
1289         return lightWeightValue();
1290     default:
1291         ASSERT_NOT_REACHED();
1292         return normalWeightValue();
1293     }
1294 }
1295 
1296 inline FontSelectionValue StyleBuilderConverter::convertFontStretchFromValue(const CSSValue&amp; value)
1297 {
1298     ASSERT(is&lt;CSSPrimitiveValue&gt;(value));
1299     const auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
1300 
1301     if (primitiveValue.isPercentage())
1302         return FontSelectionValue::clampFloat(primitiveValue.floatValue());
1303 
1304     ASSERT(primitiveValue.isValueID());
1305     if (auto value = fontStretchValue(primitiveValue.valueID()))
1306         return value.value();
1307     ASSERT_NOT_REACHED();
1308     return normalStretchValue();
1309 }
1310 
1311 // The input value needs to parsed and valid, this function returns WTF::nullopt if the input was &quot;normal&quot;.
1312 inline Optional&lt;FontSelectionValue&gt; StyleBuilderConverter::convertFontStyleFromValue(const CSSValue&amp; value)
1313 {
1314     ASSERT(is&lt;CSSFontStyleValue&gt;(value));
1315     const auto&amp; fontStyleValue = downcast&lt;CSSFontStyleValue&gt;(value);
1316 
1317     auto valueID = fontStyleValue.fontStyleValue-&gt;valueID();
1318     if (valueID == CSSValueNormal)
1319         return WTF::nullopt;
1320     if (valueID == CSSValueItalic)
1321         return italicValue();
1322     ASSERT(valueID == CSSValueOblique);
1323     if (auto* obliqueValue = fontStyleValue.obliqueValue.get())
1324         return FontSelectionValue(obliqueValue-&gt;value&lt;float&gt;(CSSPrimitiveValue::CSS_DEG));
1325     return italicValue();
1326 }
1327 
1328 inline FontSelectionValue StyleBuilderConverter::convertFontWeight(StyleResolver&amp; styleResolver, const CSSValue&amp; value)
1329 {
1330     ASSERT(is&lt;CSSPrimitiveValue&gt;(value));
1331     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
1332     if (primitiveValue.isValueID()) {
1333         auto valueID = primitiveValue.valueID();
1334         if (valueID == CSSValueBolder)
1335             return FontCascadeDescription::bolderWeight(styleResolver.parentStyle()-&gt;fontDescription().weight());
1336         if (valueID == CSSValueLighter)
1337             return FontCascadeDescription::lighterWeight(styleResolver.parentStyle()-&gt;fontDescription().weight());
1338     }
1339     return convertFontWeightFromValue(value);
1340 }
1341 
1342 inline FontSelectionValue StyleBuilderConverter::convertFontStretch(StyleResolver&amp;, const CSSValue&amp; value)
1343 {
1344     return convertFontStretchFromValue(value);
1345 }
1346 
1347 #if ENABLE(VARIATION_FONTS)
1348 inline FontVariationSettings StyleBuilderConverter::convertFontVariationSettings(StyleResolver&amp;, const CSSValue&amp; value)
1349 {
1350     if (is&lt;CSSPrimitiveValue&gt;(value)) {
1351         ASSERT(downcast&lt;CSSPrimitiveValue&gt;(value).valueID() == CSSValueNormal);
1352         return { };
1353     }
1354 
1355     FontVariationSettings settings;
1356     for (auto&amp; item : downcast&lt;CSSValueList&gt;(value)) {
1357         auto&amp; feature = downcast&lt;CSSFontVariationValue&gt;(item.get());
1358         settings.insert({ feature.tag(), feature.value() });
1359     }
1360     return settings;
1361 }
1362 #endif
1363 
1364 #if PLATFORM(IOS_FAMILY)
1365 inline bool StyleBuilderConverter::convertTouchCallout(StyleResolver&amp;, const CSSValue&amp; value)
1366 {
1367     return !equalLettersIgnoringASCIICase(downcast&lt;CSSPrimitiveValue&gt;(value).stringValue(), &quot;none&quot;);
1368 }
1369 #endif
1370 
1371 #if ENABLE(TOUCH_EVENTS)
1372 inline Color StyleBuilderConverter::convertTapHighlightColor(StyleResolver&amp; styleResolver, const CSSValue&amp; value)
1373 {
1374     return styleResolver.colorFromPrimitiveValue(downcast&lt;CSSPrimitiveValue&gt;(value));
1375 }
1376 #endif
1377 
1378 #if ENABLE(POINTER_EVENTS)
1379 inline OptionSet&lt;TouchAction&gt; StyleBuilderConverter::convertTouchAction(StyleResolver&amp;, const CSSValue&amp; value)
1380 {
1381     if (is&lt;CSSPrimitiveValue&gt;(value))
1382         return downcast&lt;CSSPrimitiveValue&gt;(value);
1383 
1384     if (is&lt;CSSValueList&gt;(value)) {
1385         OptionSet&lt;TouchAction&gt; touchActions;
1386         for (auto&amp; currentValue : downcast&lt;CSSValueList&gt;(value)) {
1387             auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(currentValue.get());
1388             auto primitiveValueID = primitiveValue.valueID();
1389             if (primitiveValueID != CSSValuePanX &amp;&amp; primitiveValueID != CSSValuePanY &amp;&amp; primitiveValueID != CSSValuePinchZoom)
1390                 return RenderStyle::initialTouchActions();
1391             touchActions.add(primitiveValue);
1392         }
1393         return touchActions;
1394     }
1395 
1396     return RenderStyle::initialTouchActions();
1397 }
1398 #endif
1399 
1400 #if ENABLE(OVERFLOW_SCROLLING_TOUCH)
1401 inline bool StyleBuilderConverter::convertOverflowScrolling(StyleResolver&amp;, const CSSValue&amp; value)
1402 {
1403     return downcast&lt;CSSPrimitiveValue&gt;(value).valueID() == CSSValueTouch;
1404 }
1405 #endif
1406 
1407 inline SVGLengthValue StyleBuilderConverter::convertSVGLengthValue(StyleResolver&amp;, const CSSValue&amp; value)
1408 {
1409     return SVGLengthValue::fromCSSPrimitiveValue(downcast&lt;CSSPrimitiveValue&gt;(value));
1410 }
1411 
1412 inline Vector&lt;SVGLengthValue&gt; StyleBuilderConverter::convertSVGLengthVector(StyleResolver&amp; styleResolver, const CSSValue&amp; value)
1413 {
1414     auto&amp; valueList = downcast&lt;CSSValueList&gt;(value);
1415 
1416     Vector&lt;SVGLengthValue&gt; svgLengths;
1417     svgLengths.reserveInitialCapacity(valueList.length());
1418     for (auto&amp; item : valueList)
1419         svgLengths.uncheckedAppend(convertSVGLengthValue(styleResolver, item));
1420 
1421     return svgLengths;
1422 }
1423 
1424 inline Vector&lt;SVGLengthValue&gt; StyleBuilderConverter::convertStrokeDashArray(StyleResolver&amp; styleResolver, const CSSValue&amp; value)
1425 {
1426     if (is&lt;CSSPrimitiveValue&gt;(value)) {
1427         ASSERT(downcast&lt;CSSPrimitiveValue&gt;(value).valueID() == CSSValueNone);
1428         return SVGRenderStyle::initialStrokeDashArray();
1429     }
1430 
1431     return convertSVGLengthVector(styleResolver, value);
1432 }
1433 
1434 inline PaintOrder StyleBuilderConverter::convertPaintOrder(StyleResolver&amp;, const CSSValue&amp; value)
1435 {
1436     if (is&lt;CSSPrimitiveValue&gt;(value)) {
1437         ASSERT(downcast&lt;CSSPrimitiveValue&gt;(value).valueID() == CSSValueNormal);
1438         return PaintOrder::Normal;
1439     }
1440 
1441     auto&amp; orderTypeList = downcast&lt;CSSValueList&gt;(value);
1442     switch (downcast&lt;CSSPrimitiveValue&gt;(*orderTypeList.itemWithoutBoundsCheck(0)).valueID()) {
1443     case CSSValueFill:
1444         return orderTypeList.length() &gt; 1 ? PaintOrder::FillMarkers : PaintOrder::Fill;
1445     case CSSValueStroke:
1446         return orderTypeList.length() &gt; 1 ? PaintOrder::StrokeMarkers : PaintOrder::Stroke;
1447     case CSSValueMarkers:
1448         return orderTypeList.length() &gt; 1 ? PaintOrder::MarkersStroke : PaintOrder::Markers;
1449     default:
1450         ASSERT_NOT_REACHED();
1451         return PaintOrder::Normal;
1452     }
1453 }
1454 
1455 inline float StyleBuilderConverter::convertOpacity(StyleResolver&amp;, const CSSValue&amp; value)
1456 {
1457     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
1458     float opacity = primitiveValue.floatValue();
1459     if (primitiveValue.isPercentage())
1460         opacity /= 100.0f;
1461     return opacity;
1462 }
1463 
1464 inline String StyleBuilderConverter::convertSVGURIReference(StyleResolver&amp; styleResolver, const CSSValue&amp; value)
1465 {
1466     String s;
1467     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
1468     if (primitiveValue.isURI())
1469         s = primitiveValue.stringValue();
1470 
1471     return SVGURIReference::fragmentIdentifierFromIRIString(s, styleResolver.document());
1472 }
1473 
1474 inline Color StyleBuilderConverter::convertSVGColor(StyleResolver&amp; styleResolver, const CSSValue&amp; value)
1475 {
1476     return styleResolver.colorFromPrimitiveValue(downcast&lt;CSSPrimitiveValue&gt;(value));
1477 }
1478 
1479 inline StyleSelfAlignmentData StyleBuilderConverter::convertSelfOrDefaultAlignmentData(StyleResolver&amp;, const CSSValue&amp; value)
1480 {
1481     StyleSelfAlignmentData alignmentData = RenderStyle::initialSelfAlignment();
1482     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
1483     if (Pair* pairValue = primitiveValue.pairValue()) {
1484         if (pairValue-&gt;first()-&gt;valueID() == CSSValueLegacy) {
1485             alignmentData.setPositionType(ItemPositionType::Legacy);
1486             alignmentData.setPosition(*pairValue-&gt;second());
1487         } else if (pairValue-&gt;first()-&gt;valueID() == CSSValueFirst) {
1488             alignmentData.setPosition(ItemPosition::Baseline);
1489         } else if (pairValue-&gt;first()-&gt;valueID() == CSSValueLast) {
1490             alignmentData.setPosition(ItemPosition::LastBaseline);
1491         } else {
1492             alignmentData.setOverflow(*pairValue-&gt;first());
1493             alignmentData.setPosition(*pairValue-&gt;second());
1494         }
1495     } else
1496         alignmentData.setPosition(primitiveValue);
1497     return alignmentData;
1498 }
1499 
1500 inline StyleContentAlignmentData StyleBuilderConverter::convertContentAlignmentData(StyleResolver&amp;, const CSSValue&amp; value)
1501 {
1502     StyleContentAlignmentData alignmentData = RenderStyle::initialContentAlignment();
1503     if (!is&lt;CSSContentDistributionValue&gt;(value))
1504         return alignmentData;
1505     auto&amp; contentValue = downcast&lt;CSSContentDistributionValue&gt;(value);
1506     if (contentValue.distribution()-&gt;valueID() != CSSValueInvalid)
1507         alignmentData.setDistribution(contentValue.distribution().get());
1508     if (contentValue.position()-&gt;valueID() != CSSValueInvalid)
1509         alignmentData.setPosition(contentValue.position().get());
1510     if (contentValue.overflow()-&gt;valueID() != CSSValueInvalid)
1511         alignmentData.setOverflow(contentValue.overflow().get());
1512     return alignmentData;
1513 }
1514 
1515 inline GlyphOrientation StyleBuilderConverter::convertGlyphOrientation(StyleResolver&amp;, const CSSValue&amp; value)
1516 {
1517     float angle = fabsf(fmodf(downcast&lt;CSSPrimitiveValue&gt;(value).floatValue(), 360.0f));
1518     if (angle &lt;= 45.0f || angle &gt; 315.0f)
1519         return GlyphOrientation::Degrees0;
1520     if (angle &gt; 45.0f &amp;&amp; angle &lt;= 135.0f)
1521         return GlyphOrientation::Degrees90;
1522     if (angle &gt; 135.0f &amp;&amp; angle &lt;= 225.0f)
1523         return GlyphOrientation::Degrees180;
1524     return GlyphOrientation::Degrees270;
1525 }
1526 
1527 inline GlyphOrientation StyleBuilderConverter::convertGlyphOrientationOrAuto(StyleResolver&amp; styleResolver, const CSSValue&amp; value)
1528 {
1529     if (downcast&lt;CSSPrimitiveValue&gt;(value).valueID() == CSSValueAuto)
1530         return GlyphOrientation::Auto;
1531     return convertGlyphOrientation(styleResolver, value);
1532 }
1533 
1534 inline Optional&lt;Length&gt; StyleBuilderConverter::convertLineHeight(StyleResolver&amp; styleResolver, const CSSValue&amp; value, float multiplier)
1535 {
1536     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
1537     if (primitiveValue.valueID() == CSSValueNormal)
1538         return RenderStyle::initialLineHeight();
1539 
1540     if (primitiveValue.isLength()) {
1541         Length length = primitiveValue.computeLength&lt;Length&gt;(StyleBuilderConverter::csstoLengthConversionDataWithTextZoomFactor(styleResolver));
1542         if (multiplier != 1.f)
1543             length = Length(length.value() * multiplier, Fixed);
1544         return length;
1545     }
1546 
1547     // Line-height percentages need to inherit as if they were Fixed pixel values. In the example:
1548     // &lt;div style=&quot;font-size: 10px; line-height: 150%;&quot;&gt;&lt;div style=&quot;font-size: 100px;&quot;&gt;&lt;/div&gt;&lt;/div&gt;
1549     // the inner element should have line-height of 15px. However, in this example:
1550     // &lt;div style=&quot;font-size: 10px; line-height: 1.5;&quot;&gt;&lt;div style=&quot;font-size: 100px;&quot;&gt;&lt;/div&gt;&lt;/div&gt;
1551     // the inner element should have a line-height of 150px. Therefore, we map percentages to Fixed
1552     // values and raw numbers to percentages.
1553     if (primitiveValue.isPercentage()) {
1554         // FIXME: percentage should not be restricted to an integer here.
1555         return Length((styleResolver.style()-&gt;computedFontSize() * primitiveValue.intValue()) / 100, Fixed);
1556     }
1557     if (primitiveValue.isNumber())
1558         return Length(primitiveValue.doubleValue() * 100.0, Percent);
1559 
1560     // FIXME: The parser should only emit the above types, so this should never be reached. We should change the
1561     // type of this function to return just a Length (and not an Optional).
1562     return WTF::nullopt;
1563 }
1564 
1565 inline FontSynthesis StyleBuilderConverter::convertFontSynthesis(StyleResolver&amp;, const CSSValue&amp; value)
1566 {
1567     if (is&lt;CSSPrimitiveValue&gt;(value)) {
1568         ASSERT(downcast&lt;CSSPrimitiveValue&gt;(value).valueID() == CSSValueNone);
1569         return FontSynthesisNone;
1570     }
1571 
1572     FontSynthesis result = FontSynthesisNone;
1573     ASSERT(is&lt;CSSValueList&gt;(value));
1574     for (const CSSValue&amp; v : downcast&lt;CSSValueList&gt;(value)) {
1575         switch (downcast&lt;CSSPrimitiveValue&gt;(v).valueID()) {
1576         case CSSValueWeight:
1577             result |= FontSynthesisWeight;
1578             break;
1579         case CSSValueStyle:
1580             result |= FontSynthesisStyle;
1581             break;
1582         case CSSValueSmallCaps:
1583             result |= FontSynthesisSmallCaps;
1584             break;
1585         default:
1586             ASSERT_NOT_REACHED();
1587             break;
1588         }
1589     }
1590 
1591     return result;
1592 }
1593 
1594 inline OptionSet&lt;SpeakAs&gt; StyleBuilderConverter::convertSpeakAs(StyleResolver&amp;, const CSSValue&amp; value)
1595 {
1596     auto result = RenderStyle::initialSpeakAs();
1597     if (is&lt;CSSValueList&gt;(value)) {
1598         for (auto&amp; currentValue : downcast&lt;CSSValueList&gt;(value))
1599             result.add(downcast&lt;CSSPrimitiveValue&gt;(currentValue.get()));
1600     }
1601     return result;
1602 }
1603 
1604 inline OptionSet&lt;HangingPunctuation&gt; StyleBuilderConverter::convertHangingPunctuation(StyleResolver&amp;, const CSSValue&amp; value)
1605 {
1606     auto result = RenderStyle::initialHangingPunctuation();
1607     if (is&lt;CSSValueList&gt;(value)) {
1608         for (auto&amp; currentValue : downcast&lt;CSSValueList&gt;(value))
1609             result.add(downcast&lt;CSSPrimitiveValue&gt;(currentValue.get()));
1610     }
1611     return result;
1612 }
1613 
1614 inline GapLength StyleBuilderConverter::convertGapLength(StyleResolver&amp; styleResolver, const CSSValue&amp; value)
1615 {
1616     return (downcast&lt;CSSPrimitiveValue&gt;(value).valueID() == CSSValueNormal) ? GapLength() : GapLength(convertLength(styleResolver, value));
1617 }
1618 
1619 } // namespace WebCore
    </pre>
  </body>
</html>