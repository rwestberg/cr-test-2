<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderThemeWin.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2006-2017 Apple Inc. All rights reserved.
   3  * Copyright (C) 2009 Kenneth Rohde Christiansen
   4  *
   5  * This library is free software; you can redistribute it and/or
   6  * modify it under the terms of the GNU Library General Public
   7  * License as published by the Free Software Foundation; either
   8  * version 2 of the License, or (at your option) any later version.
   9  *
  10  * This library is distributed in the hope that it will be useful,
  11  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  12  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  13  * Library General Public License for more details.
  14  *
  15  * You should have received a copy of the GNU Library General Public License
  16  * along with this library; see the file COPYING.LIB.  If not, write to
  17  * the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
  18  * Boston, MA 02111-1307, USA.
  19  *
  20  */
  21 
  22 #include &quot;config.h&quot;
  23 #include &quot;RenderThemeWin.h&quot;
  24 
  25 #include &quot;CSSValueKeywords.h&quot;
  26 #include &quot;Element.h&quot;
  27 #include &quot;FontMetrics.h&quot;
  28 #include &quot;Frame.h&quot;
  29 #include &quot;FrameSelection.h&quot;
  30 #include &quot;GraphicsContext.h&quot;
  31 #include &quot;HTMLMeterElement.h&quot;
  32 #include &quot;LocalWindowsContext.h&quot;
  33 #include &quot;PaintInfo.h&quot;
  34 #include &quot;RenderMeter.h&quot;
  35 #include &quot;RenderSlider.h&quot;
  36 #include &quot;Settings.h&quot;
  37 #include &quot;SystemInfo.h&quot;
  38 #include &quot;UserAgentStyleSheets.h&quot;
  39 #include &quot;WebCoreBundleWin.h&quot;
  40 #include &lt;wtf/FileSystem.h&gt;
  41 #include &lt;wtf/SoftLinking.h&gt;
  42 #include &lt;wtf/text/StringBuilder.h&gt;
  43 #include &lt;wtf/win/GDIObject.h&gt;
  44 
  45 #if ENABLE(VIDEO)
  46 #include &quot;RenderMediaControls.h&quot;
  47 #endif
  48 
  49 #include &lt;tchar.h&gt;
  50 
  51 /*
  52  * The following constants are used to determine how a widget is drawn using
  53  * Windows&#39; Theme API. For more information on theme parts and states see
  54  * http://msdn.microsoft.com/library/default.asp?url=/library/en-us/shellcc/platform/commctls/userex/topics/partsandstates.asp
  55  */
  56 
  57 // Generic state constants
  58 #define TS_NORMAL    1
  59 #define TS_HOVER     2
  60 #define TS_ACTIVE    3
  61 #define TS_DISABLED  4
  62 #define TS_FOCUSED   5
  63 
  64 // Button constants
  65 #define BP_BUTTON    1
  66 #define BP_RADIO     2
  67 #define BP_CHECKBOX  3
  68 
  69 // Textfield constants
  70 #define TFP_TEXTFIELD 1
  71 #define EP_EDITBORDER_NOSCROLL 6
  72 #define TFS_READONLY  6
  73 
  74 // ComboBox constants (from vsstyle.h)
  75 #define CP_DROPDOWNBUTTON 1
  76 #define CP_BORDER 4
  77 #define CP_READONLY 5
  78 #define CP_DROPDOWNBUTTONRIGHT 6
  79 
  80 // TrackBar (slider) parts
  81 #define TKP_TRACK       1
  82 #define TKP_TRACKVERT   2
  83 
  84 // TrackBar (slider) thumb parts
  85 #define TKP_THUMBBOTTOM 4
  86 #define TKP_THUMBTOP    5
  87 #define TKP_THUMBLEFT   7
  88 #define TKP_THUMBRIGHT  8
  89 
  90 // Trackbar (slider) thumb states
  91 #define TUS_NORMAL      1
  92 #define TUS_HOT         2
  93 #define TUS_PRESSED     3
  94 #define TUS_FOCUSED     4
  95 #define TUS_DISABLED    5
  96 
  97 // button states
  98 #define PBS_NORMAL      1
  99 #define PBS_HOT         2
 100 #define PBS_PRESSED     3
 101 #define PBS_DISABLED    4
 102 #define PBS_DEFAULTED   5
 103 
 104 // Spin button parts
 105 #define SPNP_UP         1
 106 #define SPNP_DOWN       2
 107 
 108 // Spin button states
 109 #define DNS_NORMAL      1
 110 #define DNS_HOT         2
 111 #define DNS_PRESSED     3
 112 #define DNS_DISABLED    4
 113 #define UPS_NORMAL      1
 114 #define UPS_HOT         2
 115 #define UPS_PRESSED     3
 116 #define UPS_DISABLED    4
 117 
 118 // Progress bar parts
 119 #define PP_BAR          1
 120 #define PP_BARVERT      2
 121 #define PP_CHUNK        3
 122 #define PP_CHUNKVERT    4
 123 #define PP_FILL         5
 124 #define PP_FILLVERT     6
 125 #define PP_PULSEOVERLAY 7
 126 #define PP_MOVEOVERLAY  8
 127 #define PP_PULSEOVERLAYVERT 9
 128 #define PP_MOVEOVERLAYVERT  10
 129 #define PP_TRANSPARENTBAR   11
 130 #define PP_TRANSPARENTBARVERT 12
 131 
 132 // Progress bar states
 133 #define PBBS_NORMAL     1
 134 #define PBBS_PARTIAL    2
 135 #define PBBVS_NORMAL    1 // Vertical
 136 #define PBBVS_PARTIAL   2
 137 
 138 // Progress bar fill states
 139 #define PBFS_NORMAL     1
 140 #define PBFS_ERROR      2
 141 #define PBFS_PAUSED     3
 142 #define PBFS_PARTIAL    4
 143 #define PBFVS_NORMAL    1 // Vertical
 144 #define PBFVS_ERROR     2
 145 #define PBFVS_PAUSED    3
 146 #define PBFVS_PARTIAL   4
 147 
 148 
 149 SOFT_LINK_LIBRARY(uxtheme)
 150 SOFT_LINK(uxtheme, OpenThemeData, HANDLE, WINAPI, (HWND hwnd, LPCWSTR pszClassList), (hwnd, pszClassList))
 151 SOFT_LINK(uxtheme, CloseThemeData, HRESULT, WINAPI, (HANDLE hTheme), (hTheme))
 152 SOFT_LINK(uxtheme, DrawThemeBackground, HRESULT, WINAPI, (HANDLE hTheme, HDC hdc, int iPartId, int iStateId, const RECT* pRect, const RECT* pClipRect), (hTheme, hdc, iPartId, iStateId, pRect, pClipRect))
 153 SOFT_LINK(uxtheme, IsThemeActive, BOOL, WINAPI, (), ())
 154 SOFT_LINK(uxtheme, IsThemeBackgroundPartiallyTransparent, BOOL, WINAPI, (HANDLE hTheme, int iPartId, int iStateId), (hTheme, iPartId, iStateId))
 155 
 156 static bool haveTheme;
 157 
 158 static const unsigned vistaMenuListButtonOutset = 1;
 159 
 160 
 161 namespace WebCore {
 162 
 163 // This is the fixed width IE and Firefox use for buttons on dropdown menus
 164 static const int dropDownButtonWidth = 17;
 165 
 166 // Default font size to match Firefox.
 167 static const float defaultControlFontPixelSize = 13;
 168 
 169 static const float defaultCancelButtonSize = 9;
 170 static const float minCancelButtonSize = 5;
 171 static const float maxCancelButtonSize = 21;
 172 static const float defaultSearchFieldResultsDecorationSize = 13;
 173 static const float minSearchFieldResultsDecorationSize = 9;
 174 static const float maxSearchFieldResultsDecorationSize = 30;
 175 static const float defaultSearchFieldResultsButtonWidth = 18;
 176 
 177 static bool gWebKitIsBeingUnloaded;
 178 
 179 void RenderThemeWin::setWebKitIsBeingUnloaded()
 180 {
 181     gWebKitIsBeingUnloaded = true;
 182 }
 183 
 184 RenderTheme&amp; RenderTheme::singleton()
 185 {
 186     static NeverDestroyed&lt;RenderThemeWin&gt; theme;
 187     return theme;
 188 }
 189 
 190 RenderThemeWin::RenderThemeWin()
 191     : m_buttonTheme(0)
 192     , m_textFieldTheme(0)
 193     , m_menuListTheme(0)
 194     , m_sliderTheme(0)
 195     , m_spinButtonTheme(0)
 196     , m_progressBarTheme(0)
 197 {
 198     haveTheme = uxthemeLibrary() &amp;&amp; IsThemeActive();
 199 }
 200 
 201 RenderThemeWin::~RenderThemeWin()
 202 {
 203     // If WebKit is being unloaded, then uxtheme.dll is no longer available.
 204     if (gWebKitIsBeingUnloaded || !uxthemeLibrary())
 205         return;
 206     close();
 207 }
 208 
 209 HANDLE RenderThemeWin::buttonTheme() const
 210 {
 211     if (haveTheme &amp;&amp; !m_buttonTheme)
 212         m_buttonTheme = OpenThemeData(0, L&quot;Button&quot;);
 213     return m_buttonTheme;
 214 }
 215 
 216 HANDLE RenderThemeWin::textFieldTheme() const
 217 {
 218     if (haveTheme &amp;&amp; !m_textFieldTheme)
 219         m_textFieldTheme = OpenThemeData(0, L&quot;Edit&quot;);
 220     return m_textFieldTheme;
 221 }
 222 
 223 HANDLE RenderThemeWin::menuListTheme() const
 224 {
 225     if (haveTheme &amp;&amp; !m_menuListTheme)
 226         m_menuListTheme = OpenThemeData(0, L&quot;ComboBox&quot;);
 227     return m_menuListTheme;
 228 }
 229 
 230 HANDLE RenderThemeWin::sliderTheme() const
 231 {
 232     if (haveTheme &amp;&amp; !m_sliderTheme)
 233         m_sliderTheme = OpenThemeData(0, L&quot;TrackBar&quot;);
 234     return m_sliderTheme;
 235 }
 236 
 237 HANDLE RenderThemeWin::spinButtonTheme() const
 238 {
 239     if (haveTheme &amp;&amp; !m_spinButtonTheme)
 240         m_spinButtonTheme = OpenThemeData(0, L&quot;Spin&quot;);
 241     return m_spinButtonTheme;
 242 }
 243 
 244 HANDLE RenderThemeWin::progressBarTheme() const
 245 {
 246     if (haveTheme &amp;&amp; !m_progressBarTheme)
 247         m_progressBarTheme = OpenThemeData(0, L&quot;Progress&quot;);
 248     return m_progressBarTheme;
 249 }
 250 
 251 void RenderThemeWin::close()
 252 {
 253     // This method will need to be called when the OS theme changes to flush our cached themes.
 254     if (m_buttonTheme)
 255         CloseThemeData(m_buttonTheme);
 256     if (m_textFieldTheme)
 257         CloseThemeData(m_textFieldTheme);
 258     if (m_menuListTheme)
 259         CloseThemeData(m_menuListTheme);
 260     if (m_sliderTheme)
 261         CloseThemeData(m_sliderTheme);
 262     if (m_spinButtonTheme)
 263         CloseThemeData(m_spinButtonTheme);
 264     if (m_progressBarTheme)
 265         CloseThemeData(m_progressBarTheme);
 266     m_buttonTheme = m_textFieldTheme = m_menuListTheme = m_sliderTheme = m_spinButtonTheme = m_progressBarTheme = 0;
 267 
 268     haveTheme = uxthemeLibrary() &amp;&amp; IsThemeActive();
 269 }
 270 
 271 void RenderThemeWin::themeChanged()
 272 {
 273     close();
 274 }
 275 
 276 String RenderThemeWin::extraDefaultStyleSheet()
 277 {
 278     return String(themeWinUserAgentStyleSheet, sizeof(themeWinUserAgentStyleSheet));
 279 }
 280 
 281 String RenderThemeWin::extraQuirksStyleSheet()
 282 {
 283     return String(themeWinQuirksUserAgentStyleSheet, sizeof(themeWinQuirksUserAgentStyleSheet));
 284 }
 285 
 286 bool RenderThemeWin::supportsHover(const RenderStyle&amp;) const
 287 {
 288     // The Classic/2k look has no hover effects.
 289     return haveTheme;
 290 }
 291 
 292 Color RenderThemeWin::platformActiveSelectionBackgroundColor(OptionSet&lt;StyleColor::Options&gt;) const
 293 {
 294     COLORREF color = GetSysColor(COLOR_HIGHLIGHT);
 295     return Color(GetRValue(color), GetGValue(color), GetBValue(color));
 296 }
 297 
 298 Color RenderThemeWin::platformInactiveSelectionBackgroundColor(OptionSet&lt;StyleColor::Options&gt;) const
 299 {
 300     // This color matches Firefox.
 301     return Color(176, 176, 176);
 302 }
 303 
 304 Color RenderThemeWin::platformActiveSelectionForegroundColor(OptionSet&lt;StyleColor::Options&gt;) const
 305 {
 306     COLORREF color = GetSysColor(COLOR_HIGHLIGHTTEXT);
 307     return Color(GetRValue(color), GetGValue(color), GetBValue(color));
 308 }
 309 
 310 Color RenderThemeWin::platformInactiveSelectionForegroundColor(OptionSet&lt;StyleColor::Options&gt; options) const
 311 {
 312     return platformActiveSelectionForegroundColor(options);
 313 }
 314 
 315 static void fillFontDescription(FontCascadeDescription&amp; fontDescription, LOGFONT&amp; logFont, float fontSize)
 316 {
 317     fontDescription.setIsAbsoluteSize(true);
 318     fontDescription.setOneFamily(logFont.lfFaceName);
 319     fontDescription.setSpecifiedSize(fontSize);
 320     fontDescription.setWeight(logFont.lfWeight &gt;= 700 ? boldWeightValue() : normalWeightValue()); // FIXME: Use real weight.
 321     fontDescription.setIsItalic(logFont.lfItalic);
 322 }
 323 
 324 void RenderThemeWin::updateCachedSystemFontDescription(CSSValueID valueID, FontCascadeDescription&amp; fontDescription) const
 325 {
 326     static bool initialized;
 327     static NONCLIENTMETRICS ncm;
 328 
 329     if (!initialized) {
 330         initialized = true;
 331         ncm.cbSize = sizeof(NONCLIENTMETRICS);
 332         ::SystemParametersInfo(SPI_GETNONCLIENTMETRICS, sizeof(ncm), &amp;ncm, 0);
 333     }
 334 
 335     LOGFONT logFont;
 336     bool shouldUseDefaultControlFontPixelSize = false;
 337     switch (valueID) {
 338     case CSSValueIcon:
 339         ::SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(logFont), &amp;logFont, 0);
 340         break;
 341     case CSSValueMenu:
 342         logFont = ncm.lfMenuFont;
 343         break;
 344     case CSSValueMessageBox:
 345         logFont = ncm.lfMessageFont;
 346         break;
 347     case CSSValueStatusBar:
 348         logFont = ncm.lfStatusFont;
 349         break;
 350     case CSSValueCaption:
 351         logFont = ncm.lfCaptionFont;
 352         break;
 353     case CSSValueSmallCaption:
 354         logFont = ncm.lfSmCaptionFont;
 355         break;
 356     case CSSValueWebkitSmallControl:
 357     case CSSValueWebkitMiniControl: // Just map to small.
 358     case CSSValueWebkitControl: // Just map to small.
 359         shouldUseDefaultControlFontPixelSize = true;
 360         FALLTHROUGH;
 361     default: { // Everything else uses the stock GUI font.
 362         HGDIOBJ hGDI = ::GetStockObject(DEFAULT_GUI_FONT);
 363         if (!hGDI)
 364             return;
 365         if (::GetObject(hGDI, sizeof(logFont), &amp;logFont) &lt;= 0)
 366             return;
 367     }
 368     }
 369     fillFontDescription(fontDescription, logFont, shouldUseDefaultControlFontPixelSize ? defaultControlFontPixelSize : abs(logFont.lfHeight));
 370 }
 371 
 372 bool RenderThemeWin::supportsFocus(ControlPart appearance) const
 373 {
 374     switch (appearance) {
 375         case PushButtonPart:
 376         case ButtonPart:
 377         case DefaultButtonPart:
 378             return true;
 379         default:
 380             return false;
 381     }
 382 }
 383 
 384 bool RenderThemeWin::supportsFocusRing(const RenderStyle&amp; style) const
 385 {
 386     return supportsFocus(style.appearance());
 387 }
 388 
 389 unsigned RenderThemeWin::determineClassicState(const RenderObject&amp; o, ControlSubPart subPart)
 390 {
 391     unsigned state = 0;
 392     switch (o.style().appearance()) {
 393         case PushButtonPart:
 394         case ButtonPart:
 395         case DefaultButtonPart:
 396             state = DFCS_BUTTONPUSH;
 397             if (!isEnabled(o))
 398                 state |= DFCS_INACTIVE;
 399             else if (isPressed(o))
 400                 state |= DFCS_PUSHED;
 401             break;
 402         case RadioPart:
 403         case CheckboxPart:
 404             state = (o.style().appearance() == RadioPart) ? DFCS_BUTTONRADIO : DFCS_BUTTONCHECK;
 405             if (isChecked(o))
 406                 state |= DFCS_CHECKED;
 407             if (!isEnabled(o))
 408                 state |= DFCS_INACTIVE;
 409             else if (isPressed(o))
 410                 state |= DFCS_PUSHED;
 411             break;
 412         case MenulistPart:
 413             state = DFCS_SCROLLCOMBOBOX;
 414             if (!isEnabled(o))
 415                 state |= DFCS_INACTIVE;
 416             else if (isPressed(o))
 417                 state |= DFCS_PUSHED;
 418             break;
 419         case InnerSpinButtonPart: {
 420             bool isUpButton = subPart == SpinButtonUp;
 421             state = isUpButton ? DFCS_SCROLLUP : DFCS_SCROLLDOWN;
 422             if (!isEnabled(o) || isReadOnlyControl(o))
 423                 state |= DFCS_INACTIVE;
 424             else if (isPressed(o) &amp;&amp; isUpButton == isSpinUpButtonPartPressed(o))
 425                 state |= DFCS_PUSHED;
 426             else if (isHovered(o) &amp;&amp; isUpButton == isSpinUpButtonPartHovered(o))
 427                 state |= DFCS_HOT;
 428             break;
 429         }
 430         default:
 431             break;
 432     }
 433     return state;
 434 }
 435 
 436 unsigned RenderThemeWin::determineState(const RenderObject&amp; o)
 437 {
 438     unsigned result = TS_NORMAL;
 439     ControlPart appearance = o.style().appearance();
 440     if (!isEnabled(o))
 441         result = TS_DISABLED;
 442     else if (isReadOnlyControl(o) &amp;&amp; (TextFieldPart == appearance || TextAreaPart == appearance || SearchFieldPart == appearance))
 443         result = TFS_READONLY; // Readonly is supported on textfields.
 444     else if (isPressed(o)) // Active overrides hover and focused.
 445         result = TS_ACTIVE;
 446     else if (supportsFocus(appearance) &amp;&amp; isFocused(o))
 447         result = TS_FOCUSED;
 448     else if (isHovered(o))
 449         result = TS_HOVER;
 450     if (isChecked(o))
 451         result += 4; // 4 unchecked states, 4 checked states.
 452     else if (isIndeterminate(o) &amp;&amp; appearance == CheckboxPart)
 453         result += 8;
 454     return result;
 455 }
 456 
 457 unsigned RenderThemeWin::determineSliderThumbState(const RenderObject&amp; o)
 458 {
 459     unsigned result = TUS_NORMAL;
 460     if (!isEnabled(o))
 461         result = TUS_DISABLED;
 462     else if (supportsFocus(o.style().appearance()) &amp;&amp; isFocused(o))
 463         result = TUS_FOCUSED;
 464     else if (isPressed(o))
 465         result = TUS_PRESSED;
 466     else if (isHovered(o))
 467         result = TUS_HOT;
 468     return result;
 469 }
 470 
 471 unsigned RenderThemeWin::determineButtonState(const RenderObject&amp; o)
 472 {
 473     unsigned result = PBS_NORMAL;
 474     if (!isEnabled(o))
 475         result = PBS_DISABLED;
 476     else if (isPressed(o))
 477         result = PBS_PRESSED;
 478     else if (supportsFocus(o.style().appearance()) &amp;&amp; isFocused(o))
 479         result = PBS_DEFAULTED;
 480     else if (isHovered(o))
 481         result = PBS_HOT;
 482     else if (isDefault(o))
 483         result = PBS_DEFAULTED;
 484     return result;
 485 }
 486 
 487 unsigned RenderThemeWin::determineSpinButtonState(const RenderObject&amp; o, ControlSubPart subPart)
 488 {
 489     bool isUpButton = subPart == SpinButtonUp;
 490     unsigned result = isUpButton ? UPS_NORMAL : DNS_NORMAL;
 491     if (!isEnabled(o) || isReadOnlyControl(o))
 492         result = isUpButton ? UPS_DISABLED : DNS_DISABLED;
 493     else if (isPressed(o) &amp;&amp; isUpButton == isSpinUpButtonPartPressed(o))
 494         result = isUpButton ? UPS_PRESSED : DNS_PRESSED;
 495     else if (isHovered(o) &amp;&amp; isUpButton == isSpinUpButtonPartHovered(o))
 496         result = isUpButton ? UPS_HOT : DNS_HOT;
 497     return result;
 498 }
 499 
 500 ThemeData RenderThemeWin::getClassicThemeData(const RenderObject&amp; o, ControlSubPart subPart)
 501 {
 502     ThemeData result;
 503     switch (o.style().appearance()) {
 504         case PushButtonPart:
 505         case ButtonPart:
 506         case DefaultButtonPart:
 507         case CheckboxPart:
 508         case RadioPart:
 509             result.m_part = DFC_BUTTON;
 510             result.m_state = determineClassicState(o);
 511             break;
 512         case MenulistPart:
 513             result.m_part = DFC_SCROLL;
 514             result.m_state = determineClassicState(o);
 515             break;
 516         case MeterPart:
 517             result.m_part = PP_BAR;
 518             result.m_state = determineState(o);
 519             break;
 520         case SearchFieldPart:
 521         case TextFieldPart:
 522         case TextAreaPart:
 523             result.m_part = TFP_TEXTFIELD;
 524             result.m_state = determineState(o);
 525             break;
 526         case SliderHorizontalPart:
 527             result.m_part = TKP_TRACK;
 528             result.m_state = TS_NORMAL;
 529             break;
 530         case SliderVerticalPart:
 531             result.m_part = TKP_TRACKVERT;
 532             result.m_state = TS_NORMAL;
 533             break;
 534         case SliderThumbHorizontalPart:
 535             result.m_part = TKP_THUMBBOTTOM;
 536             result.m_state = determineSliderThumbState(o);
 537             break;
 538         case SliderThumbVerticalPart:
 539             result.m_part = TKP_THUMBRIGHT;
 540             result.m_state = determineSliderThumbState(o);
 541             break;
 542         case InnerSpinButtonPart:
 543             result.m_part = DFC_SCROLL;
 544             result.m_state = determineClassicState(o, subPart);
 545             break;
 546         default:
 547             break;
 548     }
 549     return result;
 550 }
 551 
 552 ThemeData RenderThemeWin::getThemeData(const RenderObject&amp; o, ControlSubPart subPart)
 553 {
 554     if (!haveTheme)
 555         return getClassicThemeData(o, subPart);
 556 
 557     ThemeData result;
 558     switch (o.style().appearance()) {
 559         case PushButtonPart:
 560         case ButtonPart:
 561         case DefaultButtonPart:
 562             result.m_part = BP_BUTTON;
 563             result.m_state = determineButtonState(o);
 564             break;
 565         case CheckboxPart:
 566             result.m_part = BP_CHECKBOX;
 567             result.m_state = determineState(o);
 568             break;
 569         case MenulistPart:
 570         case MenulistButtonPart: {
 571             const bool isVistaOrLater = (windowsVersion() &gt;= WindowsVista);
 572             result.m_part = isVistaOrLater ? CP_DROPDOWNBUTTONRIGHT : CP_DROPDOWNBUTTON;
 573             if (isVistaOrLater) {
 574                 result.m_state = TS_NORMAL;
 575             } else
 576                 result.m_state = determineState(o);
 577             break;
 578         }
 579         case MeterPart:
 580             result.m_part = PP_BAR;
 581             result.m_state = determineState(o);
 582             break;
 583         case RadioPart:
 584             result.m_part = BP_RADIO;
 585             result.m_state = determineState(o);
 586             break;
 587         case SearchFieldPart:
 588         case TextFieldPart:
 589         case TextAreaPart:
 590             result.m_part = (windowsVersion() &gt;= WindowsVista) ? EP_EDITBORDER_NOSCROLL : TFP_TEXTFIELD;
 591             result.m_state = determineState(o);
 592             break;
 593         case SliderHorizontalPart:
 594             result.m_part = TKP_TRACK;
 595             result.m_state = TS_NORMAL;
 596             break;
 597         case SliderVerticalPart:
 598             result.m_part = TKP_TRACKVERT;
 599             result.m_state = TS_NORMAL;
 600             break;
 601         case SliderThumbHorizontalPart:
 602             result.m_part = TKP_THUMBBOTTOM;
 603             result.m_state = determineSliderThumbState(o);
 604             break;
 605         case SliderThumbVerticalPart:
 606             result.m_part = TKP_THUMBRIGHT;
 607             result.m_state = determineSliderThumbState(o);
 608             break;
 609         case InnerSpinButtonPart:
 610             result.m_part = subPart == SpinButtonUp ? SPNP_UP : SPNP_DOWN;
 611             result.m_state = determineSpinButtonState(o, subPart);
 612             break;
 613         default:
 614             break;
 615     }
 616 
 617     return result;
 618 }
 619 
 620 static void drawControl(GraphicsContext&amp; context, const RenderObject&amp; o, HANDLE theme, const ThemeData&amp; themeData, const IntRect&amp; r)
 621 {
 622     bool alphaBlend = false;
 623     if (theme)
 624         alphaBlend = IsThemeBackgroundPartiallyTransparent(theme, themeData.m_part, themeData.m_state);
 625     LocalWindowsContext windowsContext(context, r, alphaBlend);
 626     RECT widgetRect = r;
 627     if (theme)
 628         DrawThemeBackground(theme, windowsContext.hdc(), themeData.m_part, themeData.m_state, &amp;widgetRect, 0);
 629     else {
 630         HDC hdc = windowsContext.hdc();
 631         if (themeData.m_part == TFP_TEXTFIELD) {
 632             ::DrawEdge(hdc, &amp;widgetRect, EDGE_SUNKEN, BF_RECT | BF_ADJUST);
 633             if (themeData.m_state == TS_DISABLED || themeData.m_state ==  TFS_READONLY)
 634                 ::FillRect(hdc, &amp;widgetRect, (HBRUSH)(COLOR_BTNFACE+1));
 635             else
 636                 ::FillRect(hdc, &amp;widgetRect, (HBRUSH)(COLOR_WINDOW+1));
 637         } else if (themeData.m_part == TKP_TRACK || themeData.m_part == TKP_TRACKVERT) {
 638             ::DrawEdge(hdc, &amp;widgetRect, EDGE_SUNKEN, BF_RECT | BF_ADJUST);
 639             ::FillRect(hdc, &amp;widgetRect, (HBRUSH)GetStockObject(GRAY_BRUSH));
 640         } else if ((o.style().appearance() == SliderThumbHorizontalPart
 641         || o.style().appearance() == SliderThumbVerticalPart)
 642         &amp;&amp; (themeData.m_part == TKP_THUMBBOTTOM || themeData.m_part == TKP_THUMBTOP
 643         || themeData.m_part == TKP_THUMBLEFT || themeData.m_part == TKP_THUMBRIGHT)) {
 644             ::DrawEdge(hdc, &amp;widgetRect, EDGE_RAISED, BF_RECT | BF_SOFT | BF_MIDDLE | BF_ADJUST);
 645             if (themeData.m_state == TUS_DISABLED) {
 646                 static WORD patternBits[8] = {0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55};
 647                 auto patternBmp = adoptGDIObject(::CreateBitmap(8, 8, 1, 1, patternBits));
 648                 if (patternBmp) {
 649                     auto brush = adoptGDIObject(::CreatePatternBrush(patternBmp.get()));
 650                     COLORREF oldForeColor = ::SetTextColor(hdc, ::GetSysColor(COLOR_3DFACE));
 651                     COLORREF oldBackColor = ::SetBkColor(hdc, ::GetSysColor(COLOR_3DHILIGHT));
 652                     POINT p;
 653                     ::GetViewportOrgEx(hdc, &amp;p);
 654                     ::SetBrushOrgEx(hdc, p.x + widgetRect.left, p.y + widgetRect.top, NULL);
 655                     HGDIOBJ oldBrush = ::SelectObject(hdc, brush.get());
 656                     ::FillRect(hdc, &amp;widgetRect, brush.get());
 657                     ::SetTextColor(hdc, oldForeColor);
 658                     ::SetBkColor(hdc, oldBackColor);
 659                     ::SelectObject(hdc, oldBrush);
 660                 } else
 661                     ::FillRect(hdc, &amp;widgetRect, (HBRUSH)COLOR_3DHILIGHT);
 662             }
 663         } else {
 664             // Push buttons, buttons, checkboxes and radios, and the dropdown arrow in menulists.
 665             if (o.style().appearance() == DefaultButtonPart) {
 666                 HBRUSH brush = ::GetSysColorBrush(COLOR_3DDKSHADOW);
 667                 ::FrameRect(hdc, &amp;widgetRect, brush);
 668                 ::InflateRect(&amp;widgetRect, -1, -1);
 669                 ::DrawEdge(hdc, &amp;widgetRect, BDR_RAISEDOUTER, BF_RECT | BF_MIDDLE);
 670             }
 671             ::DrawFrameControl(hdc, &amp;widgetRect, themeData.m_part, themeData.m_state);
 672         }
 673     }
 674 
 675     if (!alphaBlend &amp;&amp; !context.isInTransparencyLayer())
 676         DIBPixelData::setRGBABitmapAlpha(windowsContext.hdc(), r, 255);
 677 }
 678 
 679 bool RenderThemeWin::paintButton(const RenderObject&amp; o, const PaintInfo&amp; i, const IntRect&amp; r)
 680 {
 681     drawControl(i.context(),  o, buttonTheme(), getThemeData(o), r);
 682     return false;
 683 }
 684 
 685 void RenderThemeWin::adjustInnerSpinButtonStyle(StyleResolver&amp; styleResolver, RenderStyle&amp; style, const Element*) const
 686 {
 687     int width = ::GetSystemMetrics(SM_CXVSCROLL);
 688     if (width &lt;= 0)
 689         width = 17; // Vista&#39;s default.
 690     style.setWidth(Length(width, Fixed));
 691     style.setMinWidth(Length(width, Fixed));
 692 }
 693 
 694 bool RenderThemeWin::paintInnerSpinButton(const RenderObject&amp; o, const PaintInfo&amp; i, const IntRect&amp; r)
 695 {
 696     // We split the specified rectangle into two vertically. We can&#39;t draw a
 697     // spin button of which height is less than 2px.
 698     if (r.height() &lt; 2)
 699         return false;
 700     IntRect upRect(r);
 701     upRect.setHeight(r.height() / 2);
 702     IntRect downRect(r);
 703     downRect.setY(upRect.maxY());
 704     downRect.setHeight(r.height() - upRect.height());
 705     drawControl(i.context(), o, spinButtonTheme(), getThemeData(o, SpinButtonUp), upRect);
 706     drawControl(i.context(), o, spinButtonTheme(), getThemeData(o, SpinButtonDown), downRect);
 707     return false;
 708 }
 709 
 710 void RenderThemeWin::setCheckboxSize(RenderStyle&amp; style) const
 711 {
 712     // If the width and height are both specified, then we have nothing to do.
 713     if (!style.width().isIntrinsicOrAuto() &amp;&amp; !style.height().isAuto())
 714         return;
 715 
 716     // FIXME:  A hard-coded size of 13 is used.  This is wrong but necessary for now.  It matches Firefox.
 717     // At different DPI settings on Windows, querying the theme gives you a larger size that accounts for
 718     // the higher DPI.  Until our entire engine honors a DPI setting other than 96, we can&#39;t rely on the theme&#39;s
 719     // metrics.
 720     if (style.width().isIntrinsicOrAuto())
 721         style.setWidth(Length(13, Fixed));
 722     if (style.height().isAuto())
 723         style.setHeight(Length(13, Fixed));
 724 }
 725 
 726 bool RenderThemeWin::paintTextField(const RenderObject&amp; o, const PaintInfo&amp; i, const FloatRect&amp; r)
 727 {
 728     drawControl(i.context(),  o, textFieldTheme(), getThemeData(o), IntRect(r));
 729     return false;
 730 }
 731 
 732 bool RenderThemeWin::paintMenuList(const RenderObject&amp; renderer, const PaintInfo&amp; paintInfo, const FloatRect&amp; rect)
 733 {
 734     HANDLE theme;
 735     int part;
 736     if (haveTheme &amp;&amp; (windowsVersion() &gt;= WindowsVista)) {
 737         theme = menuListTheme();
 738         part = CP_READONLY;
 739     } else {
 740         theme = textFieldTheme();
 741         part = TFP_TEXTFIELD;
 742     }
 743 
 744     drawControl(paintInfo.context(), renderer, theme, ThemeData(part, determineState(renderer)), IntRect(rect));
 745 
 746     return paintMenuListButtonDecorations(downcast&lt;RenderBox&gt;(renderer), paintInfo, FloatRect(rect));
 747 }
 748 
 749 void RenderThemeWin::adjustMenuListStyle(StyleResolver&amp; styleResolver, RenderStyle&amp; style, const Element* e) const
 750 {
 751     style.resetBorder();
 752     adjustMenuListButtonStyle(styleResolver, style, e);
 753 }
 754 
 755 void RenderThemeWin::adjustMenuListButtonStyle(StyleResolver&amp; styleResolver, RenderStyle&amp; style, const Element*) const
 756 {
 757     // These are the paddings needed to place the text correctly in the &lt;select&gt; box
 758     const int dropDownBoxPaddingTop    = 2;
 759     const int dropDownBoxPaddingRight  = style.direction() == TextDirection::LTR ? 4 + dropDownButtonWidth : 4;
 760     const int dropDownBoxPaddingBottom = 2;
 761     const int dropDownBoxPaddingLeft   = style.direction() == TextDirection::LTR ? 4 : 4 + dropDownButtonWidth;
 762     // The &lt;select&gt; box must be at least 12px high for the button to render nicely on Windows
 763     const int dropDownBoxMinHeight = 12;
 764 
 765     // Position the text correctly within the select box and make the box wide enough to fit the dropdown button
 766     style.setPaddingTop(Length(dropDownBoxPaddingTop, Fixed));
 767     style.setPaddingRight(Length(dropDownBoxPaddingRight, Fixed));
 768     style.setPaddingBottom(Length(dropDownBoxPaddingBottom, Fixed));
 769     style.setPaddingLeft(Length(dropDownBoxPaddingLeft, Fixed));
 770 
 771     // Height is locked to auto
 772     style.setHeight(Length(Auto));
 773 
 774     // Calculate our min-height
 775     int minHeight = style.fontMetrics().height();
 776     minHeight = std::max(minHeight, dropDownBoxMinHeight);
 777 
 778     style.setMinHeight(Length(minHeight, Fixed));
 779 
 780     style.setLineHeight(RenderStyle::initialLineHeight());
 781 
 782     // White-space is locked to pre
 783     style.setWhiteSpace(WhiteSpace::Pre);
 784 }
 785 
 786 bool RenderThemeWin::paintMenuListButtonDecorations(const RenderBox&amp; renderer, const PaintInfo&amp; paintInfo, const FloatRect&amp; rect)
 787 {
 788     // FIXME: Don&#39;t make hardcoded assumptions about the thickness of the textfield border.
 789     int borderThickness = haveTheme ? 1 : 2;
 790 
 791     // Paint the dropdown button on the inner edge of the text field,
 792     // leaving space for the text field&#39;s 1px border
 793     IntRect buttonRect(rect);
 794     buttonRect.inflate(-borderThickness);
 795     if (renderer.style().direction() == TextDirection::LTR)
 796         buttonRect.setX(buttonRect.maxX() - dropDownButtonWidth);
 797     buttonRect.setWidth(dropDownButtonWidth);
 798 
 799     if ((windowsVersion() &gt;= WindowsVista)) {
 800         // Outset the top, right, and bottom borders of the button so that they coincide with the &lt;select&gt;&#39;s border.
 801         buttonRect.setY(buttonRect.y() - vistaMenuListButtonOutset);
 802         buttonRect.setHeight(buttonRect.height() + 2 * vistaMenuListButtonOutset);
 803         buttonRect.setWidth(buttonRect.width() + vistaMenuListButtonOutset);
 804     }
 805 
 806     drawControl(paintInfo.context(), renderer, menuListTheme(), getThemeData(renderer), buttonRect);
 807 
 808     return false;
 809 }
 810 
 811 const int trackWidth = 4;
 812 
 813 bool RenderThemeWin::paintSliderTrack(const RenderObject&amp; o, const PaintInfo&amp; i, const IntRect&amp; r)
 814 {
 815     IntRect bounds = r;
 816 
 817     if (o.style().appearance() ==  SliderHorizontalPart) {
 818         bounds.setHeight(trackWidth);
 819         bounds.setY(r.y() + r.height() / 2 - trackWidth / 2);
 820     } else if (o.style().appearance() == SliderVerticalPart) {
 821         bounds.setWidth(trackWidth);
 822         bounds.setX(r.x() + r.width() / 2 - trackWidth / 2);
 823     }
 824 
 825     drawControl(i.context(),  o, sliderTheme(), getThemeData(o), bounds);
 826     return false;
 827 }
 828 
 829 bool RenderThemeWin::paintSliderThumb(const RenderObject&amp; o, const PaintInfo&amp; i, const IntRect&amp; r)
 830 {
 831     drawControl(i.context(),  o, sliderTheme(), getThemeData(o), r);
 832     return false;
 833 }
 834 
 835 const int sliderThumbWidth = 7;
 836 const int sliderThumbHeight = 15;
 837 
 838 void RenderThemeWin::adjustSliderThumbSize(RenderStyle&amp; style, const Element*) const
 839 {
 840     ControlPart part = style.appearance();
 841     if (part == SliderThumbVerticalPart) {
 842         style.setWidth(Length(sliderThumbHeight, Fixed));
 843         style.setHeight(Length(sliderThumbWidth, Fixed));
 844     } else if (part == SliderThumbHorizontalPart) {
 845         style.setWidth(Length(sliderThumbWidth, Fixed));
 846         style.setHeight(Length(sliderThumbHeight, Fixed));
 847     }
 848 #if ENABLE(VIDEO) &amp;&amp; USE(CG)
 849     else if (part == MediaSliderThumbPart || part == MediaVolumeSliderThumbPart)
 850         RenderMediaControls::adjustMediaSliderThumbSize(style);
 851 #endif
 852 }
 853 
 854 bool RenderThemeWin::paintSearchField(const RenderObject&amp; o, const PaintInfo&amp; i, const IntRect&amp; r)
 855 {
 856     return paintTextField(o, i, r);
 857 }
 858 
 859 void RenderThemeWin::adjustSearchFieldStyle(StyleResolver&amp; styleResolver, RenderStyle&amp; style, const Element* e) const
 860 {
 861     // Override paddingSize to match AppKit text positioning.
 862     const int padding = 1;
 863     style.setPaddingLeft(Length(padding, Fixed));
 864     style.setPaddingRight(Length(padding, Fixed));
 865     style.setPaddingTop(Length(padding, Fixed));
 866     style.setPaddingBottom(Length(padding, Fixed));
 867     if (e &amp;&amp; e-&gt;focused() &amp;&amp; e-&gt;document().frame()-&gt;selection().isFocusedAndActive())
 868         style.setOutlineOffset(-2);
 869 }
 870 
 871 bool RenderThemeWin::paintSearchFieldCancelButton(const RenderBox&amp; o, const PaintInfo&amp; paintInfo, const IntRect&amp; r)
 872 {
 873     IntRect bounds = r;
 874     ASSERT(o.parent());
 875     if (!is&lt;RenderBox&gt;(o.parent()))
 876         return false;
 877 
 878     IntRect parentBox = downcast&lt;RenderBox&gt;(*o.parent()).absoluteContentBox();
 879 
 880     // Make sure the scaled button stays square and will fit in its parent&#39;s box
 881     bounds.setHeight(std::min(parentBox.width(), std::min(parentBox.height(), bounds.height())));
 882     bounds.setWidth(bounds.height());
 883 
 884     // Center the button vertically.  Round up though, so if it has to be one pixel off-center, it will
 885     // be one pixel closer to the bottom of the field.  This tends to look better with the text.
 886     bounds.setY(parentBox.y() + (parentBox.height() - bounds.height() + 1) / 2);
 887 
 888     static Image&amp; cancelImage = Image::loadPlatformResource(&quot;searchCancel&quot;).leakRef();
 889     static Image&amp; cancelPressedImage = Image::loadPlatformResource(&quot;searchCancelPressed&quot;).leakRef();
 890     paintInfo.context().drawImage(isPressed(o) ? cancelPressedImage : cancelImage, bounds);
 891     return false;
 892 }
 893 
 894 void RenderThemeWin::adjustSearchFieldCancelButtonStyle(StyleResolver&amp;, RenderStyle&amp; style, const Element*) const
 895 {
 896     // Scale the button size based on the font size
 897     float fontScale = style.computedFontPixelSize() / defaultControlFontPixelSize;
 898     int cancelButtonSize = lroundf(std::min(std::max(minCancelButtonSize, defaultCancelButtonSize * fontScale), maxCancelButtonSize));
 899     style.setWidth(Length(cancelButtonSize, Fixed));
 900     style.setHeight(Length(cancelButtonSize, Fixed));
 901 }
 902 
 903 void RenderThemeWin::adjustSearchFieldDecorationPartStyle(StyleResolver&amp;, RenderStyle&amp; style, const Element*) const
 904 {
 905     IntSize emptySize(1, 11);
 906     style.setWidth(Length(emptySize.width(), Fixed));
 907     style.setHeight(Length(emptySize.height(), Fixed));
 908 }
 909 
 910 void RenderThemeWin::adjustSearchFieldResultsDecorationPartStyle(StyleResolver&amp;, RenderStyle&amp; style, const Element*) const
 911 {
 912     // Scale the decoration size based on the font size
 913     float fontScale = style.computedFontPixelSize() / defaultControlFontPixelSize;
 914     int magnifierSize = lroundf(std::min(std::max(minSearchFieldResultsDecorationSize, defaultSearchFieldResultsDecorationSize * fontScale),
 915                                      maxSearchFieldResultsDecorationSize));
 916     style.setWidth(Length(magnifierSize, Fixed));
 917     style.setHeight(Length(magnifierSize, Fixed));
 918 }
 919 
 920 bool RenderThemeWin::paintSearchFieldResultsDecorationPart(const RenderBox&amp; o, const PaintInfo&amp; paintInfo, const IntRect&amp; r)
 921 {
 922     IntRect bounds = r;
 923     ASSERT(o.parent());
 924     if (!is&lt;RenderBox&gt;(o.parent()))
 925         return false;
 926 
 927     IntRect parentBox = downcast&lt;RenderBox&gt;(*o.parent()).absoluteContentBox();
 928 
 929     // Make sure the scaled decoration stays square and will fit in its parent&#39;s box
 930     bounds.setHeight(std::min(parentBox.width(), std::min(parentBox.height(), bounds.height())));
 931     bounds.setWidth(bounds.height());
 932 
 933     // Center the decoration vertically.  Round up though, so if it has to be one pixel off-center, it will
 934     // be one pixel closer to the bottom of the field.  This tends to look better with the text.
 935     bounds.setY(parentBox.y() + (parentBox.height() - bounds.height() + 1) / 2);
 936 
 937     static Image&amp; magnifierImage = Image::loadPlatformResource(&quot;searchMagnifier&quot;).leakRef();
 938     paintInfo.context().drawImage(magnifierImage, bounds);
 939     return false;
 940 }
 941 
 942 void RenderThemeWin::adjustSearchFieldResultsButtonStyle(StyleResolver&amp;, RenderStyle&amp; style, const Element*) const
 943 {
 944     // Scale the button size based on the font size
 945     float fontScale = style.computedFontPixelSize() / defaultControlFontPixelSize;
 946     int magnifierHeight = lroundf(std::min(std::max(minSearchFieldResultsDecorationSize, defaultSearchFieldResultsDecorationSize * fontScale),
 947                                    maxSearchFieldResultsDecorationSize));
 948     int magnifierWidth = lroundf(magnifierHeight * defaultSearchFieldResultsButtonWidth / defaultSearchFieldResultsDecorationSize);
 949     style.setWidth(Length(magnifierWidth, Fixed));
 950     style.setHeight(Length(magnifierHeight, Fixed));
 951 }
 952 
 953 bool RenderThemeWin::paintSearchFieldResultsButton(const RenderBox&amp; o, const PaintInfo&amp; paintInfo, const IntRect&amp; r)
 954 {
 955     IntRect bounds = r;
 956     ASSERT(o.parent());
 957     if (!o.parent())
 958         return false;
 959     if (!is&lt;RenderBox&gt;(o.parent()))
 960         return false;
 961 
 962     IntRect parentBox = downcast&lt;RenderBox&gt;(*o.parent()).absoluteContentBox();
 963 
 964     // Make sure the scaled decoration will fit in its parent&#39;s box
 965     bounds.setHeight(std::min(parentBox.height(), bounds.height()));
 966     bounds.setWidth(std::min&lt;int&gt;(parentBox.width(), bounds.height() * defaultSearchFieldResultsButtonWidth / defaultSearchFieldResultsDecorationSize));
 967 
 968     // Center the button vertically.  Round up though, so if it has to be one pixel off-center, it will
 969     // be one pixel closer to the bottom of the field.  This tends to look better with the text.
 970     bounds.setY(parentBox.y() + (parentBox.height() - bounds.height() + 1) / 2);
 971 
 972     static Image&amp; magnifierImage = Image::loadPlatformResource(&quot;searchMagnifierResults&quot;).leakRef();
 973     paintInfo.context().drawImage(magnifierImage, bounds);
 974     return false;
 975 }
 976 
 977 // Map a CSSValue* system color to an index understood by GetSysColor
 978 static int cssValueIdToSysColorIndex(CSSValueID cssValueId)
 979 {
 980     switch (cssValueId) {
 981     case CSSValueActiveborder: return COLOR_ACTIVEBORDER;
 982     case CSSValueActivecaption: return COLOR_ACTIVECAPTION;
 983     case CSSValueAppworkspace: return COLOR_APPWORKSPACE;
 984     case CSSValueBackground: return COLOR_BACKGROUND;
 985     case CSSValueButtonface: return COLOR_BTNFACE;
 986     case CSSValueButtonhighlight: return COLOR_BTNHIGHLIGHT;
 987     case CSSValueButtonshadow: return COLOR_BTNSHADOW;
 988     case CSSValueButtontext: return COLOR_BTNTEXT;
 989     case CSSValueCaptiontext: return COLOR_CAPTIONTEXT;
 990     case CSSValueGraytext: return COLOR_GRAYTEXT;
 991     case CSSValueHighlight: return COLOR_HIGHLIGHT;
 992     case CSSValueHighlighttext: return COLOR_HIGHLIGHTTEXT;
 993     case CSSValueInactiveborder: return COLOR_INACTIVEBORDER;
 994     case CSSValueInactivecaption: return COLOR_INACTIVECAPTION;
 995     case CSSValueInactivecaptiontext: return COLOR_INACTIVECAPTIONTEXT;
 996     case CSSValueInfobackground: return COLOR_INFOBK;
 997     case CSSValueInfotext: return COLOR_INFOTEXT;
 998     case CSSValueMenu: return COLOR_MENU;
 999     case CSSValueMenutext: return COLOR_MENUTEXT;
1000     case CSSValueScrollbar: return COLOR_SCROLLBAR;
1001     case CSSValueThreeddarkshadow: return COLOR_3DDKSHADOW;
1002     case CSSValueThreedface: return COLOR_3DFACE;
1003     case CSSValueThreedhighlight: return COLOR_3DHIGHLIGHT;
1004     case CSSValueThreedlightshadow: return COLOR_3DLIGHT;
1005     case CSSValueThreedshadow: return COLOR_3DSHADOW;
1006     case CSSValueWindow: return COLOR_WINDOW;
1007     case CSSValueWindowframe: return COLOR_WINDOWFRAME;
1008     case CSSValueWindowtext: return COLOR_WINDOWTEXT;
1009     default: return -1; // Unsupported CSSValue
1010     }
1011 }
1012 
1013 Color RenderThemeWin::systemColor(CSSValueID cssValueId, OptionSet&lt;StyleColor::Options&gt; options) const
1014 {
1015     int sysColorIndex = cssValueIdToSysColorIndex(cssValueId);
1016     if (sysColorIndex == -1)
1017         return RenderTheme::systemColor(cssValueId, options);
1018 
1019     COLORREF color = GetSysColor(sysColorIndex);
1020     return Color(GetRValue(color), GetGValue(color), GetBValue(color));
1021 }
1022 
1023 #if ENABLE(VIDEO)
1024 static void fillBufferWithContentsOfFile(FileSystem::PlatformFileHandle file, long long filesize, Vector&lt;char&gt;&amp; buffer)
1025 {
1026     // Load the file content into buffer
1027     buffer.resize(filesize + 1);
1028 
1029     int bufferPosition = 0;
1030     int bufferReadSize = 4096;
1031     int bytesRead = 0;
1032     while (filesize &gt; bufferPosition) {
1033         if (filesize - bufferPosition &lt; bufferReadSize)
1034             bufferReadSize = filesize - bufferPosition;
1035 
1036         bytesRead = FileSystem::readFromFile(file, buffer.data() + bufferPosition, bufferReadSize);
1037         if (bytesRead != bufferReadSize) {
1038             buffer.clear();
1039             return;
1040         }
1041 
1042         bufferPosition += bufferReadSize;
1043     }
1044 
1045     buffer[filesize] = 0;
1046 }
1047 
1048 String RenderThemeWin::stringWithContentsOfFile(const String&amp; name, const String&amp; type)
1049 {
1050 #if USE(CF)
1051     RetainPtr&lt;CFURLRef&gt; requestedURLRef = adoptCF(CFBundleCopyResourceURL(webKitBundle(), name.createCFString().get(), type.createCFString().get(), 0));
1052     if (!requestedURLRef)
1053         return String();
1054 
1055     UInt8 requestedFilePath[MAX_PATH];
1056     if (!CFURLGetFileSystemRepresentation(requestedURLRef.get(), false, requestedFilePath, MAX_PATH))
1057         return String();
1058 
1059     FileSystem::PlatformFileHandle requestedFileHandle = FileSystem::openFile(requestedFilePath, FileSystem::FileOpenMode::Read);
1060     if (!FileSystem::isHandleValid(requestedFileHandle))
1061         return String();
1062 
1063     long long filesize = -1;
1064     if (!FileSystem::getFileSize(requestedFileHandle, filesize)) {
1065         FileSystem::closeFile(requestedFileHandle);
1066         return String();
1067     }
1068 
1069     Vector&lt;char&gt; fileContents;
1070     fillBufferWithContentsOfFile(requestedFileHandle, filesize, fileContents);
1071     FileSystem::closeFile(requestedFileHandle);
1072 
1073     return String(fileContents.data(), static_cast&lt;size_t&gt;(filesize));
1074 #else
1075     return emptyString();
1076 #endif
1077 }
1078 
1079 String RenderThemeWin::mediaControlsStyleSheet()
1080 {
1081 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
1082     if (m_mediaControlsStyleSheet.isEmpty())
1083         m_mediaControlsStyleSheet = stringWithContentsOfFile(&quot;mediaControlsApple&quot;_s, &quot;css&quot;_s);
1084     return m_mediaControlsStyleSheet;
1085 #else
1086     return emptyString();
1087 #endif
1088 }
1089 
1090 String RenderThemeWin::mediaControlsScript()
1091 {
1092 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
1093     if (m_mediaControlsScript.isEmpty()) {
1094         StringBuilder scriptBuilder;
1095         scriptBuilder.append(stringWithContentsOfFile(&quot;mediaControlsLocalizedStrings&quot;_s, &quot;js&quot;_s));
1096         scriptBuilder.append(stringWithContentsOfFile(&quot;mediaControlsApple&quot;_s, &quot;js&quot;_s));
1097         m_mediaControlsScript = scriptBuilder.toString();
1098     }
1099     return m_mediaControlsScript;
1100 #else
1101     return emptyString();
1102 #endif
1103 }
1104 #endif
1105 
1106 #if ENABLE(METER_ELEMENT)
1107 void RenderThemeWin::adjustMeterStyle(StyleResolver&amp;, RenderStyle&amp; style, const Element*) const
1108 {
1109     style.setBoxShadow(nullptr);
1110 }
1111 
1112 bool RenderThemeWin::supportsMeter(ControlPart part) const
1113 {
1114     switch (part) {
1115     case MeterPart:
1116         return true;
1117     default:
1118         return false;
1119     }
1120 }
1121 
1122 IntSize RenderThemeWin::meterSizeForBounds(const RenderMeter&amp;, const IntRect&amp; bounds) const
1123 {
1124     return bounds.size();
1125 }
1126 
1127 bool RenderThemeWin::paintMeter(const RenderObject&amp; renderObject, const PaintInfo&amp; paintInfo, const IntRect&amp; rect)
1128 {
1129     if (!is&lt;RenderMeter&gt;(renderObject))
1130         return true;
1131 
1132     HTMLMeterElement* element = downcast&lt;RenderMeter&gt;(renderObject).meterElement();
1133 
1134     ThemeData theme = getThemeData(renderObject);
1135 
1136     int remaining = static_cast&lt;int&gt;((1.0 - element-&gt;valueRatio()) * static_cast&lt;double&gt;(rect.size().width()));
1137 
1138     // Draw the background
1139     drawControl(paintInfo.context(), renderObject, progressBarTheme(), theme, rect);
1140 
1141     // Draw the progress portion
1142     IntRect completedRect(rect);
1143     completedRect.contract(remaining, 0);
1144 
1145     theme.m_part = PP_FILL;
1146     drawControl(paintInfo.context(), renderObject, progressBarTheme(), theme, completedRect);
1147 
1148     return true;
1149 }
1150 
1151 #endif
1152 
1153 
1154 }
    </pre>
  </body>
</html>