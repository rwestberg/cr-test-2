<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/accessibility/AccessibilityNodeObject.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AccessibilityMenuListOption.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AccessibilityNodeObject.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/accessibility/AccessibilityNodeObject.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 176,11 ***</span>
      Node* firstChild = node()-&gt;firstChild();
  
      if (!firstChild)
          return nullptr;
  
<span class="line-modified">!     return axObjectCache()-&gt;getOrCreate(firstChild);</span>
  }
  
  AccessibilityObject* AccessibilityNodeObject::lastChild() const
  {
      if (!node())
<span class="line-new-header">--- 176,12 ---</span>
      Node* firstChild = node()-&gt;firstChild();
  
      if (!firstChild)
          return nullptr;
  
<span class="line-modified">!     auto objectCache = axObjectCache();</span>
<span class="line-added">+     return objectCache ? objectCache-&gt;getOrCreate(firstChild) : nullptr;</span>
  }
  
  AccessibilityObject* AccessibilityNodeObject::lastChild() const
  {
      if (!node())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 188,11 ***</span>
  
      Node* lastChild = node()-&gt;lastChild();
      if (!lastChild)
          return nullptr;
  
<span class="line-modified">!     return axObjectCache()-&gt;getOrCreate(lastChild);</span>
  }
  
  AccessibilityObject* AccessibilityNodeObject::previousSibling() const
  {
      if (!node())
<span class="line-new-header">--- 189,12 ---</span>
  
      Node* lastChild = node()-&gt;lastChild();
      if (!lastChild)
          return nullptr;
  
<span class="line-modified">!     auto objectCache = axObjectCache();</span>
<span class="line-added">+     return objectCache ? objectCache-&gt;getOrCreate(lastChild) : nullptr;</span>
  }
  
  AccessibilityObject* AccessibilityNodeObject::previousSibling() const
  {
      if (!node())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 200,11 ***</span>
  
      Node* previousSibling = node()-&gt;previousSibling();
      if (!previousSibling)
          return nullptr;
  
<span class="line-modified">!     return axObjectCache()-&gt;getOrCreate(previousSibling);</span>
  }
  
  AccessibilityObject* AccessibilityNodeObject::nextSibling() const
  {
      if (!node())
<span class="line-new-header">--- 202,12 ---</span>
  
      Node* previousSibling = node()-&gt;previousSibling();
      if (!previousSibling)
          return nullptr;
  
<span class="line-modified">!     auto objectCache = axObjectCache();</span>
<span class="line-added">+     return objectCache ? objectCache-&gt;getOrCreate(previousSibling) : nullptr;</span>
  }
  
  AccessibilityObject* AccessibilityNodeObject::nextSibling() const
  {
      if (!node())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 212,11 ***</span>
  
      Node* nextSibling = node()-&gt;nextSibling();
      if (!nextSibling)
          return nullptr;
  
<span class="line-modified">!     return axObjectCache()-&gt;getOrCreate(nextSibling);</span>
  }
  
  AccessibilityObject* AccessibilityNodeObject::parentObjectIfExists() const
  {
      return parentObject();
<span class="line-new-header">--- 215,12 ---</span>
  
      Node* nextSibling = node()-&gt;nextSibling();
      if (!nextSibling)
          return nullptr;
  
<span class="line-modified">!     auto objectCache = axObjectCache();</span>
<span class="line-added">+     return objectCache ? objectCache-&gt;getOrCreate(nextSibling) : nullptr;</span>
  }
  
  AccessibilityObject* AccessibilityNodeObject::parentObjectIfExists() const
  {
      return parentObject();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 343,12 ***</span>
  
      // The only time we add children from the DOM tree to a node with a renderer is when it&#39;s a canvas.
      if (renderer() &amp;&amp; !m_node-&gt;hasTagName(canvasTag))
          return;
  
      for (Node* child = m_node-&gt;firstChild(); child; child = child-&gt;nextSibling())
<span class="line-modified">!         addChild(axObjectCache()-&gt;getOrCreate(child));</span>
  
      m_subtreeDirty = false;
  }
  
  bool AccessibilityNodeObject::canHaveChildren() const
<span class="line-new-header">--- 347,16 ---</span>
  
      // The only time we add children from the DOM tree to a node with a renderer is when it&#39;s a canvas.
      if (renderer() &amp;&amp; !m_node-&gt;hasTagName(canvasTag))
          return;
  
<span class="line-added">+     auto objectCache = axObjectCache();</span>
<span class="line-added">+     if (!objectCache)</span>
<span class="line-added">+         return;</span>
<span class="line-added">+ </span>
      for (Node* child = m_node-&gt;firstChild(); child; child = child-&gt;nextSibling())
<span class="line-modified">!         addChild(objectCache-&gt;getOrCreate(child));</span>
  
      m_subtreeDirty = false;
  }
  
  bool AccessibilityNodeObject::canHaveChildren() const
</pre>
<hr />
<pre>
<span class="line-old-header">*** 378,10 ***</span>
<span class="line-new-header">--- 386,11 ---</span>
      case AccessibilityRole::ProgressIndicator:
      case AccessibilityRole::Switch:
      case AccessibilityRole::MenuItemCheckbox:
      case AccessibilityRole::MenuItemRadio:
      case AccessibilityRole::Splitter:
<span class="line-added">+     case AccessibilityRole::Meter:</span>
          return false;
      case AccessibilityRole::DocumentMath:
  #if ENABLE(MATHML)
          return node()-&gt;isMathMLElement();
  #endif
</pre>
<hr />
<pre>
<span class="line-old-header">*** 477,11 ***</span>
      // Some websites don&#39;t label their search fields as such. However, they will
      // use the word &quot;search&quot; in either the form or input type. This won&#39;t catch every case,
      // but it will catch google.com for example.
  
      // Check the node name of the input type, sometimes it&#39;s &quot;search&quot;.
<span class="line-modified">!     const AtomicString&amp; nameAttribute = getAttribute(nameAttr);</span>
      if (nameAttribute.containsIgnoringASCIICase(&quot;search&quot;))
          return true;
  
      // Check the form action and the name, which will sometimes be &quot;search&quot;.
      auto* form = inputElement.form();
<span class="line-new-header">--- 486,11 ---</span>
      // Some websites don&#39;t label their search fields as such. However, they will
      // use the word &quot;search&quot; in either the form or input type. This won&#39;t catch every case,
      // but it will catch google.com for example.
  
      // Check the node name of the input type, sometimes it&#39;s &quot;search&quot;.
<span class="line-modified">!     const AtomString&amp; nameAttribute = getAttribute(nameAttr);</span>
      if (nameAttribute.containsIgnoringASCIICase(&quot;search&quot;))
          return true;
  
      // Check the form action and the name, which will sometimes be &quot;search&quot;.
      auto* form = inputElement.form();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 558,11 ***</span>
      return false;
  }
  
  bool AccessibilityNodeObject::isProgressIndicator() const
  {
<span class="line-modified">!     return roleValue() == AccessibilityRole::ProgressIndicator;</span>
  }
  
  bool AccessibilityNodeObject::isSlider() const
  {
      return roleValue() == AccessibilityRole::Slider;
<span class="line-new-header">--- 567,11 ---</span>
      return false;
  }
  
  bool AccessibilityNodeObject::isProgressIndicator() const
  {
<span class="line-modified">!     return roleValue() == AccessibilityRole::ProgressIndicator || roleValue() == AccessibilityRole::Meter;</span>
  }
  
  bool AccessibilityNodeObject::isSlider() const
  {
      return roleValue() == AccessibilityRole::Slider;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 622,11 ***</span>
  
  bool AccessibilityNodeObject::isEnabled() const
  {
      // ARIA says that the disabled status applies to the current element and all descendant elements.
      for (AccessibilityObject* object = const_cast&lt;AccessibilityNodeObject*&gt;(this); object; object = object-&gt;parentObject()) {
<span class="line-modified">!         const AtomicString&amp; disabledStatus = object-&gt;getAttribute(aria_disabledAttr);</span>
          if (equalLettersIgnoringASCIICase(disabledStatus, &quot;true&quot;))
              return false;
          if (equalLettersIgnoringASCIICase(disabledStatus, &quot;false&quot;))
              break;
      }
<span class="line-new-header">--- 631,11 ---</span>
  
  bool AccessibilityNodeObject::isEnabled() const
  {
      // ARIA says that the disabled status applies to the current element and all descendant elements.
      for (AccessibilityObject* object = const_cast&lt;AccessibilityNodeObject*&gt;(this); object; object = object-&gt;parentObject()) {
<span class="line-modified">!         const AtomString&amp; disabledStatus = object-&gt;getAttribute(aria_disabledAttr);</span>
          if (equalLettersIgnoringASCIICase(disabledStatus, &quot;true&quot;))
              return false;
          if (equalLettersIgnoringASCIICase(disabledStatus, &quot;false&quot;))
              break;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 701,11 ***</span>
      return is&lt;Element&gt;(node) &amp;&amp; downcast&lt;Element&gt;(*node).hovered();
  }
  
  bool AccessibilityNodeObject::isMultiSelectable() const
  {
<span class="line-modified">!     const AtomicString&amp; ariaMultiSelectable = getAttribute(aria_multiselectableAttr);</span>
      if (equalLettersIgnoringASCIICase(ariaMultiSelectable, &quot;true&quot;))
          return true;
      if (equalLettersIgnoringASCIICase(ariaMultiSelectable, &quot;false&quot;))
          return false;
  
<span class="line-new-header">--- 710,11 ---</span>
      return is&lt;Element&gt;(node) &amp;&amp; downcast&lt;Element&gt;(*node).hovered();
  }
  
  bool AccessibilityNodeObject::isMultiSelectable() const
  {
<span class="line-modified">!     const AtomString&amp; ariaMultiSelectable = getAttribute(aria_multiselectableAttr);</span>
      if (equalLettersIgnoringASCIICase(ariaMultiSelectable, &quot;true&quot;))
          return true;
      if (equalLettersIgnoringASCIICase(ariaMultiSelectable, &quot;false&quot;))
          return false;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 713,11 ***</span>
  }
  
  bool AccessibilityNodeObject::isRequired() const
  {
      // Explicit aria-required values should trump native required attributes.
<span class="line-modified">!     const AtomicString&amp; requiredValue = getAttribute(aria_requiredAttr);</span>
      if (equalLettersIgnoringASCIICase(requiredValue, &quot;true&quot;))
          return true;
      if (equalLettersIgnoringASCIICase(requiredValue, &quot;false&quot;))
          return false;
  
<span class="line-new-header">--- 722,11 ---</span>
  }
  
  bool AccessibilityNodeObject::isRequired() const
  {
      // Explicit aria-required values should trump native required attributes.
<span class="line-modified">!     const AtomString&amp; requiredValue = getAttribute(aria_requiredAttr);</span>
      if (equalLettersIgnoringASCIICase(requiredValue, &quot;true&quot;))
          return true;
      if (equalLettersIgnoringASCIICase(requiredValue, &quot;false&quot;))
          return false;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 883,11 ***</span>
  {
      Node* node = this-&gt;node();
      if (!node)
          return false;
  
<span class="line-modified">!     return is&lt;HTMLFormControlElement&gt;(*node) || AccessibilityObject::isARIAControl(ariaRoleAttribute());</span>
  }
  
  bool AccessibilityNodeObject::isFieldset() const
  {
      Node* node = this-&gt;node();
<span class="line-new-header">--- 892,11 ---</span>
  {
      Node* node = this-&gt;node();
      if (!node)
          return false;
  
<span class="line-modified">!     return is&lt;HTMLFormControlElement&gt;(*node) || AccessibilityObject::isARIAControl(ariaRoleAttribute()) || roleValue() == AccessibilityRole::Button;</span>
  }
  
  bool AccessibilityNodeObject::isFieldset() const
  {
      Node* node = this-&gt;node();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 946,10 ***</span>
<span class="line-new-header">--- 955,12 ---</span>
      Node* node = this-&gt;node();
      if (!node)
          return nullptr;
  
      AXObjectCache* cache = axObjectCache();
<span class="line-added">+     if (!cache)</span>
<span class="line-added">+         return nullptr;</span>
  
      // search up the DOM tree for an anchor element
      // NOTE: this assumes that any non-image with an anchor is an HTMLAnchorElement
      for ( ; node; node = node-&gt;parentNode()) {
          if (is&lt;HTMLAnchorElement&gt;(*node) || (node-&gt;renderer() &amp;&amp; cache-&gt;getOrCreate(node-&gt;renderer())-&gt;isLink()))
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1074,20 ***</span>
          changeValueByPercent(increase ? 5 : -5);
  }
  
  void AccessibilityNodeObject::increment()
  {
<span class="line-removed">-     if (dispatchAccessibilityEventWithType(AccessibilityEventType::Increment))</span>
<span class="line-removed">-         return;</span>
      UserGestureIndicator gestureIndicator(ProcessingUserGesture, document());
      alterSliderValue(true);
  }
  
  void AccessibilityNodeObject::decrement()
  {
<span class="line-removed">-     if (dispatchAccessibilityEventWithType(AccessibilityEventType::Decrement))</span>
<span class="line-removed">-         return;</span>
      UserGestureIndicator gestureIndicator(ProcessingUserGesture, document());
      alterSliderValue(false);
  }
  
  void AccessibilityNodeObject::changeValueByStep(bool increase)
<span class="line-new-header">--- 1085,16 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1095,29 ***</span>
      float step = stepValueForRange();
      float value = valueForRange();
  
      value += increase ? step : -step;
  
<span class="line-modified">!     setValue(String::number(value));</span>
  
<span class="line-modified">!     axObjectCache()-&gt;postNotification(node(), AXObjectCache::AXValueChanged);</span>
  }
  
  void AccessibilityNodeObject::changeValueByPercent(float percentChange)
  {
      float range = maxValueForRange() - minValueForRange();
      float step = range * (percentChange / 100);
      float value = valueForRange();
  
      // Make sure the specified percent will cause a change of one integer step or larger.
<span class="line-modified">!     if (fabs(step) &lt; 1)</span>
<span class="line-modified">!         step = fabs(percentChange) * (1 / percentChange);</span>
  
      value += step;
<span class="line-modified">!     setValue(String::number(value));</span>
  
<span class="line-modified">!     axObjectCache()-&gt;postNotification(node(), AXObjectCache::AXValueChanged);</span>
  }
  
  bool AccessibilityNodeObject::isGenericFocusableElement() const
  {
      if (!canSetFocusAttribute())
<span class="line-new-header">--- 1102,33 ---</span>
      float step = stepValueForRange();
      float value = valueForRange();
  
      value += increase ? step : -step;
  
<span class="line-modified">!     setValue(String::numberToStringFixedPrecision(value));</span>
  
<span class="line-modified">!     auto objectCache = axObjectCache();</span>
<span class="line-added">+     if (objectCache)</span>
<span class="line-added">+         objectCache-&gt;postNotification(node(), AXObjectCache::AXValueChanged);</span>
  }
  
  void AccessibilityNodeObject::changeValueByPercent(float percentChange)
  {
      float range = maxValueForRange() - minValueForRange();
      float step = range * (percentChange / 100);
      float value = valueForRange();
  
      // Make sure the specified percent will cause a change of one integer step or larger.
<span class="line-modified">!     if (std::abs(step) &lt; 1)</span>
<span class="line-modified">!         step = std::abs(percentChange) * (1 / percentChange);</span>
  
      value += step;
<span class="line-modified">!     setValue(String::numberToStringFixedPrecision(value));</span>
  
<span class="line-modified">!     auto objectCache = axObjectCache();</span>
<span class="line-added">+     if (objectCache)</span>
<span class="line-added">+         objectCache-&gt;postNotification(node(), AXObjectCache::AXValueChanged);</span>
  }
  
  bool AccessibilityNodeObject::isGenericFocusableElement() const
  {
      if (!canSetFocusAttribute())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1160,11 ***</span>
  HTMLLabelElement* AccessibilityNodeObject::labelForElement(Element* element) const
  {
      if (!is&lt;HTMLElement&gt;(*element) || !downcast&lt;HTMLElement&gt;(*element).isLabelable())
          return nullptr;
  
<span class="line-modified">!     const AtomicString&amp; id = element-&gt;getIdAttribute();</span>
      if (!id.isEmpty()) {
          if (HTMLLabelElement* label = element-&gt;treeScope().labelElementForId(id))
              return label;
      }
  
<span class="line-new-header">--- 1171,11 ---</span>
  HTMLLabelElement* AccessibilityNodeObject::labelForElement(Element* element) const
  {
      if (!is&lt;HTMLElement&gt;(*element) || !downcast&lt;HTMLElement&gt;(*element).isLabelable())
          return nullptr;
  
<span class="line-modified">!     const AtomString&amp; id = element-&gt;getIdAttribute();</span>
      if (!id.isEmpty()) {
          if (HTMLLabelElement* label = element-&gt;treeScope().labelElementForId(id))
              return label;
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1175,11 ***</span>
  {
      String ariaLabeledBy = ariaLabeledByAttribute();
      if (!ariaLabeledBy.isEmpty())
          return ariaLabeledBy;
  
<span class="line-modified">!     const AtomicString&amp; ariaLabel = getAttribute(aria_labelAttr);</span>
      if (!ariaLabel.isEmpty())
          return ariaLabel;
  
      return String();
  }
<span class="line-new-header">--- 1186,11 ---</span>
  {
      String ariaLabeledBy = ariaLabeledByAttribute();
      if (!ariaLabeledBy.isEmpty())
          return ariaLabeledBy;
  
<span class="line-modified">!     const AtomString&amp; ariaLabel = getAttribute(aria_labelAttr);</span>
      if (!ariaLabel.isEmpty())
          return ariaLabel;
  
      return String();
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1275,13 ***</span>
  {
      String result = String();
      if (!is&lt;HTMLLabelElement&gt;(*element))
          return result;
  
      HTMLLabelElement* label = downcast&lt;HTMLLabelElement&gt;(element);
      // Check to see if there&#39;s aria-labelledby attribute on the label element.
<span class="line-modified">!     if (AccessibilityObject* labelObject = axObjectCache()-&gt;getOrCreate(label))</span>
          result = labelObject-&gt;ariaLabeledByAttribute();
  
      return !result.isEmpty() ? result : accessibleNameForNode(label);
  }
  
<span class="line-new-header">--- 1286,17 ---</span>
  {
      String result = String();
      if (!is&lt;HTMLLabelElement&gt;(*element))
          return result;
  
<span class="line-added">+     auto objectCache = axObjectCache();</span>
<span class="line-added">+     if (!objectCache)</span>
<span class="line-added">+         return result;</span>
<span class="line-added">+ </span>
      HTMLLabelElement* label = downcast&lt;HTMLLabelElement&gt;(element);
      // Check to see if there&#39;s aria-labelledby attribute on the label element.
<span class="line-modified">!     if (AccessibilityObject* labelObject = objectCache-&gt;getOrCreate(label))</span>
          result = labelObject-&gt;ariaLabeledByAttribute();
  
      return !result.isEmpty() ? result : accessibleNameForNode(label);
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1293,13 ***</span>
  
      if (isLabelable()) {
          if (HTMLLabelElement* label = labelForElement(downcast&lt;Element&gt;(node))) {
              String innerText = textForLabelElement(label);
  
              // Only use the &lt;label&gt; text if there&#39;s no ARIA override.
<span class="line-modified">!             if (!innerText.isEmpty() &amp;&amp; !ariaAccessibilityDescription())</span>
<span class="line-modified">!                 textOrder.append(AccessibilityText(innerText, isMeter() ? AccessibilityTextSource::Alternative : AccessibilityTextSource::LabelByElement, axObjectCache()-&gt;getOrCreate(label)));</span>
              return;
          }
      }
  
      AccessibilityObject* titleUIElement = this-&gt;titleUIElement();
<span class="line-new-header">--- 1308,14 ---</span>
  
      if (isLabelable()) {
          if (HTMLLabelElement* label = labelForElement(downcast&lt;Element&gt;(node))) {
              String innerText = textForLabelElement(label);
  
<span class="line-added">+             auto objectCache = axObjectCache();</span>
              // Only use the &lt;label&gt; text if there&#39;s no ARIA override.
<span class="line-modified">!             if (objectCache &amp;&amp; !innerText.isEmpty() &amp;&amp; !ariaAccessibilityDescription())</span>
<span class="line-modified">!                 textOrder.append(AccessibilityText(innerText, isMeter() ? AccessibilityTextSource::Alternative : AccessibilityTextSource::LabelByElement, objectCache-&gt;getOrCreate(label)));</span>
              return;
          }
      }
  
      AccessibilityObject* titleUIElement = this-&gt;titleUIElement();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1316,11 ***</span>
          return;
      }
  
      ariaLabeledByText(textOrder);
  
<span class="line-modified">!     const AtomicString&amp; ariaLabel = getAttribute(aria_labelAttr);</span>
      if (!ariaLabel.isEmpty())
          textOrder.append(AccessibilityText(ariaLabel, AccessibilityTextSource::Alternative));
  
      if (usesAltTagForTextComputation()) {
          if (is&lt;RenderImage&gt;(renderer())) {
<span class="line-new-header">--- 1332,11 ---</span>
          return;
      }
  
      ariaLabeledByText(textOrder);
  
<span class="line-modified">!     const AtomString&amp; ariaLabel = getAttribute(aria_labelAttr);</span>
      if (!ariaLabel.isEmpty())
          textOrder.append(AccessibilityText(ariaLabel, AccessibilityTextSource::Alternative));
  
      if (usesAltTagForTextComputation()) {
          if (is&lt;RenderImage&gt;(renderer())) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1332,22 ***</span>
                  return;
              }
          }
          // Images should use alt as long as the attribute is present, even if empty.
          // Otherwise, it should fallback to other methods, like the title attribute.
<span class="line-modified">!         const AtomicString&amp; alt = getAttribute(altAttr);</span>
          if (!alt.isEmpty())
              textOrder.append(AccessibilityText(alt, AccessibilityTextSource::Alternative));
      }
  
      Node* node = this-&gt;node();
      if (!node)
          return;
  
      // The fieldset element derives its alternative text from the first associated legend element if one is available.
<span class="line-modified">!     if (is&lt;HTMLFieldSetElement&gt;(*node)) {</span>
<span class="line-modified">!         AccessibilityObject* object = axObjectCache()-&gt;getOrCreate(downcast&lt;HTMLFieldSetElement&gt;(*node).legend());</span>
          if (object &amp;&amp; !object-&gt;isHidden())
              textOrder.append(AccessibilityText(accessibleNameForNode(object-&gt;node()), AccessibilityTextSource::Alternative));
      }
  
      // The figure element derives its alternative text from the first associated figcaption element if one is available.
<span class="line-new-header">--- 1348,23 ---</span>
                  return;
              }
          }
          // Images should use alt as long as the attribute is present, even if empty.
          // Otherwise, it should fallback to other methods, like the title attribute.
<span class="line-modified">!         const AtomString&amp; alt = getAttribute(altAttr);</span>
          if (!alt.isEmpty())
              textOrder.append(AccessibilityText(alt, AccessibilityTextSource::Alternative));
      }
  
      Node* node = this-&gt;node();
      if (!node)
          return;
  
<span class="line-added">+     auto objectCache = axObjectCache();</span>
      // The fieldset element derives its alternative text from the first associated legend element if one is available.
<span class="line-modified">!     if (objectCache &amp;&amp; is&lt;HTMLFieldSetElement&gt;(*node)) {</span>
<span class="line-modified">!         AccessibilityObject* object = objectCache-&gt;getOrCreate(downcast&lt;HTMLFieldSetElement&gt;(*node).legend());</span>
          if (object &amp;&amp; !object-&gt;isHidden())
              textOrder.append(AccessibilityText(accessibleNameForNode(object-&gt;node()), AccessibilityTextSource::Alternative));
      }
  
      // The figure element derives its alternative text from the first associated figcaption element if one is available.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1436,11 ***</span>
      }
  }
  
  void AccessibilityNodeObject::helpText(Vector&lt;AccessibilityText&gt;&amp; textOrder) const
  {
<span class="line-modified">!     const AtomicString&amp; ariaHelp = getAttribute(aria_helpAttr);</span>
      if (!ariaHelp.isEmpty())
          textOrder.append(AccessibilityText(ariaHelp, AccessibilityTextSource::Help));
  
      String describedBy = ariaDescribedByAttribute();
      if (!describedBy.isEmpty())
<span class="line-new-header">--- 1453,11 ---</span>
      }
  }
  
  void AccessibilityNodeObject::helpText(Vector&lt;AccessibilityText&gt;&amp; textOrder) const
  {
<span class="line-modified">!     const AtomString&amp; ariaHelp = getAttribute(aria_helpAttr);</span>
      if (!ariaHelp.isEmpty())
          textOrder.append(AccessibilityText(ariaHelp, AccessibilityTextSource::Help));
  
      String describedBy = ariaDescribedByAttribute();
      if (!describedBy.isEmpty())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1453,29 ***</span>
          if (const auto* parent = AccessibilityObject::matchedParent(*this, false, WTFMove(matchFunc)))
              textOrder.append(AccessibilityText(parent-&gt;ariaDescribedByAttribute(), AccessibilityTextSource::Summary));
      }
  
      // Summary attribute used as help text on tables.
<span class="line-modified">!     const AtomicString&amp; summary = getAttribute(summaryAttr);</span>
      if (!summary.isEmpty())
          textOrder.append(AccessibilityText(summary, AccessibilityTextSource::Summary));
  
      // The title attribute should be used as help text unless it is already being used as descriptive text.
      // However, when the title attribute is the only text alternative provided, it may be exposed as the
      // descriptive text. This is problematic in the case of meters because the HTML spec suggests authors
      // can expose units through this attribute. Therefore, if the element is a meter, change its source
      // type to AccessibilityTextSource::Help.
<span class="line-modified">!     const AtomicString&amp; title = getAttribute(titleAttr);</span>
      if (!title.isEmpty()) {
          if (!isMeter() &amp;&amp; !roleIgnoresTitle())
              textOrder.append(AccessibilityText(title, AccessibilityTextSource::TitleTag));
          else
              textOrder.append(AccessibilityText(title, AccessibilityTextSource::Help));
      }
  }
  
<span class="line-modified">! void AccessibilityNodeObject::accessibilityText(Vector&lt;AccessibilityText&gt;&amp; textOrder)</span>
  {
      titleElementText(textOrder);
      alternativeText(textOrder);
      visibleText(textOrder);
      helpText(textOrder);
<span class="line-new-header">--- 1470,29 ---</span>
          if (const auto* parent = AccessibilityObject::matchedParent(*this, false, WTFMove(matchFunc)))
              textOrder.append(AccessibilityText(parent-&gt;ariaDescribedByAttribute(), AccessibilityTextSource::Summary));
      }
  
      // Summary attribute used as help text on tables.
<span class="line-modified">!     const AtomString&amp; summary = getAttribute(summaryAttr);</span>
      if (!summary.isEmpty())
          textOrder.append(AccessibilityText(summary, AccessibilityTextSource::Summary));
  
      // The title attribute should be used as help text unless it is already being used as descriptive text.
      // However, when the title attribute is the only text alternative provided, it may be exposed as the
      // descriptive text. This is problematic in the case of meters because the HTML spec suggests authors
      // can expose units through this attribute. Therefore, if the element is a meter, change its source
      // type to AccessibilityTextSource::Help.
<span class="line-modified">!     const AtomString&amp; title = getAttribute(titleAttr);</span>
      if (!title.isEmpty()) {
          if (!isMeter() &amp;&amp; !roleIgnoresTitle())
              textOrder.append(AccessibilityText(title, AccessibilityTextSource::TitleTag));
          else
              textOrder.append(AccessibilityText(title, AccessibilityTextSource::Help));
      }
  }
  
<span class="line-modified">! void AccessibilityNodeObject::accessibilityText(Vector&lt;AccessibilityText&gt;&amp; textOrder) const</span>
  {
      titleElementText(textOrder);
      alternativeText(textOrder);
      visibleText(textOrder);
      helpText(textOrder);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1487,16 ***</span>
  
  void AccessibilityNodeObject::ariaLabeledByText(Vector&lt;AccessibilityText&gt;&amp; textOrder) const
  {
      String ariaLabeledBy = ariaLabeledByAttribute();
      if (!ariaLabeledBy.isEmpty()) {
          Vector&lt;Element*&gt; elements;
          ariaLabeledByElements(elements);
  
          Vector&lt;RefPtr&lt;AccessibilityObject&gt;&gt; axElements;
          for (const auto&amp; element : elements)
<span class="line-modified">!             axElements.append(axObjectCache()-&gt;getOrCreate(element));</span>
  
          textOrder.append(AccessibilityText(ariaLabeledBy, AccessibilityTextSource::Alternative, WTFMove(axElements)));
      }
  }
  
<span class="line-new-header">--- 1504,20 ---</span>
  
  void AccessibilityNodeObject::ariaLabeledByText(Vector&lt;AccessibilityText&gt;&amp; textOrder) const
  {
      String ariaLabeledBy = ariaLabeledByAttribute();
      if (!ariaLabeledBy.isEmpty()) {
<span class="line-added">+         auto objectCache = axObjectCache();</span>
<span class="line-added">+         if (!objectCache)</span>
<span class="line-added">+             return;</span>
<span class="line-added">+ </span>
          Vector&lt;Element*&gt; elements;
          ariaLabeledByElements(elements);
  
          Vector&lt;RefPtr&lt;AccessibilityObject&gt;&gt; axElements;
          for (const auto&amp; element : elements)
<span class="line-modified">!             axElements.append(objectCache-&gt;getOrCreate(element));</span>
  
          textOrder.append(AccessibilityText(ariaLabeledBy, AccessibilityTextSource::Alternative, WTFMove(axElements)));
      }
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1516,18 ***</span>
      if (!document)
          return String();
  
      // Check if the HTML element has an aria-label for the webpage.
      if (Element* documentElement = document-&gt;documentElement()) {
<span class="line-modified">!         const AtomicString&amp; ariaLabel = documentElement-&gt;attributeWithoutSynchronization(aria_labelAttr);</span>
          if (!ariaLabel.isEmpty())
              return ariaLabel;
      }
  
      if (auto* owner = document-&gt;ownerElement()) {
          if (owner-&gt;hasTagName(frameTag) || owner-&gt;hasTagName(iframeTag)) {
<span class="line-modified">!             const AtomicString&amp; title = owner-&gt;attributeWithoutSynchronization(titleAttr);</span>
              if (!title.isEmpty())
                  return title;
          }
          return owner-&gt;getNameAttribute();
      }
<span class="line-new-header">--- 1537,18 ---</span>
      if (!document)
          return String();
  
      // Check if the HTML element has an aria-label for the webpage.
      if (Element* documentElement = document-&gt;documentElement()) {
<span class="line-modified">!         const AtomString&amp; ariaLabel = documentElement-&gt;attributeWithoutSynchronization(aria_labelAttr);</span>
          if (!ariaLabel.isEmpty())
              return ariaLabel;
      }
  
      if (auto* owner = document-&gt;ownerElement()) {
          if (owner-&gt;hasTagName(frameTag) || owner-&gt;hasTagName(iframeTag)) {
<span class="line-modified">!             const AtomString&amp; title = owner-&gt;attributeWithoutSynchronization(titleAttr);</span>
              if (!title.isEmpty())
                  return title;
          }
          return owner-&gt;getNameAttribute();
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1553,11 ***</span>
          return ariaDescription;
  
      if (usesAltTagForTextComputation()) {
          // Images should use alt as long as the attribute is present, even if empty.
          // Otherwise, it should fallback to other methods, like the title attribute.
<span class="line-modified">!         const AtomicString&amp; alt = getAttribute(altAttr);</span>
          if (!alt.isNull())
              return alt;
      }
  
  #if ENABLE(MATHML)
<span class="line-new-header">--- 1574,11 ---</span>
          return ariaDescription;
  
      if (usesAltTagForTextComputation()) {
          // Images should use alt as long as the attribute is present, even if empty.
          // Otherwise, it should fallback to other methods, like the title attribute.
<span class="line-modified">!         const AtomString&amp; alt = getAttribute(altAttr);</span>
          if (!alt.isNull())
              return alt;
      }
  
  #if ENABLE(MATHML)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1596,11 ***</span>
  {
      Node* node = this-&gt;node();
      if (!node)
          return String();
  
<span class="line-modified">!     const AtomicString&amp; ariaHelp = getAttribute(aria_helpAttr);</span>
      if (!ariaHelp.isEmpty())
          return ariaHelp;
  
      String describedBy = ariaDescribedByAttribute();
      if (!describedBy.isEmpty())
<span class="line-new-header">--- 1617,11 ---</span>
  {
      Node* node = this-&gt;node();
      if (!node)
          return String();
  
<span class="line-modified">!     const AtomString&amp; ariaHelp = getAttribute(aria_helpAttr);</span>
      if (!ariaHelp.isEmpty())
          return ariaHelp;
  
      String describedBy = ariaDescribedByAttribute();
      if (!describedBy.isEmpty())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1608,23 ***</span>
  
      String description = accessibilityDescription();
      for (Node* ancestor = node; ancestor; ancestor = ancestor-&gt;parentNode()) {
          if (is&lt;HTMLElement&gt;(*ancestor)) {
              HTMLElement&amp; element = downcast&lt;HTMLElement&gt;(*ancestor);
<span class="line-modified">!             const AtomicString&amp; summary = element.getAttribute(summaryAttr);</span>
              if (!summary.isEmpty())
                  return summary;
  
              // The title attribute should be used as help text unless it is already being used as descriptive text.
<span class="line-modified">!             const AtomicString&amp; title = element.getAttribute(titleAttr);</span>
              if (!title.isEmpty() &amp;&amp; description != title)
                  return title;
          }
  
          // Only take help text from an ancestor element if its a group or an unknown role. If help was
          // added to those kinds of elements, it is likely it was meant for a child element.
<span class="line-modified">!         if (AccessibilityObject* axObj = axObjectCache()-&gt;getOrCreate(ancestor)) {</span>
              if (!axObj-&gt;isGroup() &amp;&amp; axObj-&gt;roleValue() != AccessibilityRole::Unknown)
                  break;
          }
      }
  
<span class="line-new-header">--- 1629,27 ---</span>
  
      String description = accessibilityDescription();
      for (Node* ancestor = node; ancestor; ancestor = ancestor-&gt;parentNode()) {
          if (is&lt;HTMLElement&gt;(*ancestor)) {
              HTMLElement&amp; element = downcast&lt;HTMLElement&gt;(*ancestor);
<span class="line-modified">!             const AtomString&amp; summary = element.getAttribute(summaryAttr);</span>
              if (!summary.isEmpty())
                  return summary;
  
              // The title attribute should be used as help text unless it is already being used as descriptive text.
<span class="line-modified">!             const AtomString&amp; title = element.getAttribute(titleAttr);</span>
              if (!title.isEmpty() &amp;&amp; description != title)
                  return title;
          }
  
<span class="line-added">+         auto objectCache = axObjectCache();</span>
<span class="line-added">+         if (!objectCache)</span>
<span class="line-added">+             return String();</span>
<span class="line-added">+ </span>
          // Only take help text from an ancestor element if its a group or an unknown role. If help was
          // added to those kinds of elements, it is likely it was meant for a child element.
<span class="line-modified">!         if (AccessibilityObject* axObj = objectCache-&gt;getOrCreate(ancestor)) {</span>
              if (!axObj-&gt;isGroup() &amp;&amp; axObj-&gt;roleValue() != AccessibilityRole::Unknown)
                  break;
          }
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1635,11 ***</span>
  {
      Node* node = this-&gt;node();
      if (!is&lt;Element&gt;(node))
          return 0;
      Element&amp; element = downcast&lt;Element&gt;(*node);
<span class="line-modified">!     const AtomicString&amp; ariaLevel = element.attributeWithoutSynchronization(aria_levelAttr);</span>
      if (!ariaLevel.isEmpty())
          return ariaLevel.toInt();
  
      // Only tree item will calculate its level through the DOM currently.
      if (roleValue() != AccessibilityRole::TreeItem)
<span class="line-new-header">--- 1660,11 ---</span>
  {
      Node* node = this-&gt;node();
      if (!is&lt;Element&gt;(node))
          return 0;
      Element&amp; element = downcast&lt;Element&gt;(*node);
<span class="line-modified">!     const AtomString&amp; ariaLevel = element.attributeWithoutSynchronization(aria_levelAttr);</span>
      if (!ariaLevel.isEmpty())
          return ariaLevel.toInt();
  
      // Only tree item will calculate its level through the DOM currently.
      if (roleValue() != AccessibilityRole::TreeItem)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1903,11 ***</span>
      if (node-&gt;hasTagName(selectTag)) {
          HTMLSelectElement&amp; selectElement = downcast&lt;HTMLSelectElement&gt;(*node);
          int selectedIndex = selectElement.selectedIndex();
          const Vector&lt;HTMLElement*&gt;&amp; listItems = selectElement.listItems();
          if (selectedIndex &gt;= 0 &amp;&amp; static_cast&lt;size_t&gt;(selectedIndex) &lt; listItems.size()) {
<span class="line-modified">!             const AtomicString&amp; overriddenDescription = listItems[selectedIndex]-&gt;attributeWithoutSynchronization(aria_labelAttr);</span>
              if (!overriddenDescription.isNull())
                  return overriddenDescription;
          }
          if (!selectElement.multiple())
              return selectElement.value();
<span class="line-new-header">--- 1928,11 ---</span>
      if (node-&gt;hasTagName(selectTag)) {
          HTMLSelectElement&amp; selectElement = downcast&lt;HTMLSelectElement&gt;(*node);
          int selectedIndex = selectElement.selectedIndex();
          const Vector&lt;HTMLElement*&gt;&amp; listItems = selectElement.listItems();
          if (selectedIndex &gt;= 0 &amp;&amp; static_cast&lt;size_t&gt;(selectedIndex) &lt; listItems.size()) {
<span class="line-modified">!             const AtomString&amp; overriddenDescription = listItems[selectedIndex]-&gt;attributeWithoutSynchronization(aria_labelAttr);</span>
              if (!overriddenDescription.isNull())
                  return overriddenDescription;
          }
          if (!selectElement.multiple())
              return selectElement.value();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1951,15 ***</span>
      ASSERT(node);
      if (!is&lt;Element&gt;(node))
          return String();
  
      Element&amp; element = downcast&lt;Element&gt;(*node);
<span class="line-modified">!     const AtomicString&amp; ariaLabel = element.attributeWithoutSynchronization(aria_labelAttr);</span>
      if (!ariaLabel.isEmpty())
          return ariaLabel;
  
<span class="line-modified">!     const AtomicString&amp; alt = element.attributeWithoutSynchronization(altAttr);</span>
      if (!alt.isEmpty())
          return alt;
  
      // If the node can be turned into an AX object, we can use standard name computation rules.
      // If however, the node cannot (because there&#39;s no renderer e.g.) fallback to using the basic text underneath.
<span class="line-new-header">--- 1976,15 ---</span>
      ASSERT(node);
      if (!is&lt;Element&gt;(node))
          return String();
  
      Element&amp; element = downcast&lt;Element&gt;(*node);
<span class="line-modified">!     const AtomString&amp; ariaLabel = element.attributeWithoutSynchronization(aria_labelAttr);</span>
      if (!ariaLabel.isEmpty())
          return ariaLabel;
  
<span class="line-modified">!     const AtomString&amp; alt = element.attributeWithoutSynchronization(altAttr);</span>
      if (!alt.isEmpty())
          return alt;
  
      // If the node can be turned into an AX object, we can use standard name computation rules.
      // If however, the node cannot (because there&#39;s no renderer e.g.) fallback to using the basic text underneath.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2004,11 ***</span>
          text = element.innerText().simplifyWhiteSpace();
  
      if (!text.isEmpty())
          return text;
  
<span class="line-modified">!     const AtomicString&amp; title = element.attributeWithoutSynchronization(titleAttr);</span>
      if (!title.isEmpty())
          return title;
  
      return String();
  }
<span class="line-new-header">--- 2029,11 ---</span>
          text = element.innerText().simplifyWhiteSpace();
  
      if (!text.isEmpty())
          return text;
  
<span class="line-modified">!     const AtomString&amp; title = element.attributeWithoutSynchronization(titleAttr);</span>
      if (!title.isEmpty())
          return title;
  
      return String();
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2134,11 ***</span>
          return false;
  
      if (isProgressIndicator() || isSlider() || isScrollbar())
          return true;
  
<span class="line-modified">! #if PLATFORM(GTK)</span>
      // In ATK, input types which support aria-readonly are treated as having a
      // settable value if the user can modify the widget&#39;s value or its state.
      if (supportsReadOnly())
          return true;
  
<span class="line-new-header">--- 2159,11 ---</span>
          return false;
  
      if (isProgressIndicator() || isSlider() || isScrollbar())
          return true;
  
<span class="line-modified">! #if USE(ATK)</span>
      // In ATK, input types which support aria-readonly are treated as having a
      // settable value if the user can modify the widget&#39;s value or its state.
      if (supportsReadOnly())
          return true;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2164,11 ***</span>
      return node-&gt;hasEditableStyle();
  }
  
  AccessibilityRole AccessibilityNodeObject::determineAriaRoleAttribute() const
  {
<span class="line-modified">!     const AtomicString&amp; ariaRole = getAttribute(roleAttr);</span>
      if (ariaRole.isNull() || ariaRole.isEmpty())
          return AccessibilityRole::Unknown;
  
      AccessibilityRole role = ariaRoleToWebCoreRole(ariaRole);
  
<span class="line-new-header">--- 2189,11 ---</span>
      return node-&gt;hasEditableStyle();
  }
  
  AccessibilityRole AccessibilityNodeObject::determineAriaRoleAttribute() const
  {
<span class="line-modified">!     const AtomString&amp; ariaRole = getAttribute(roleAttr);</span>
      if (ariaRole.isNull() || ariaRole.isEmpty())
          return AccessibilityRole::Unknown;
  
      AccessibilityRole role = ariaRoleToWebCoreRole(ariaRole);
  
</pre>
<center><a href="AccessibilityMenuListOption.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AccessibilityNodeObject.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>