<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/Modules/mediastream/libwebrtc/LibWebRTCMediaEndpoint.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2017-2018 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1.  Redistributions of source code must retain the above copyright
  8  *     notice, this list of conditions and the following disclaimer.
  9  * 2.  Redistributions in binary form must reproduce the above copyright
 10  *     notice, this list of conditions and the following disclaimer in the
 11  *     documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 15  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 16  * DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 17  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 18  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 19  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 20  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 21  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 22  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 23  */
 24 
 25 #include &quot;config.h&quot;
 26 #include &quot;LibWebRTCMediaEndpoint.h&quot;
 27 
 28 #if USE(LIBWEBRTC)
 29 
 30 #include &quot;EventNames.h&quot;
 31 #include &quot;JSRTCStatsReport.h&quot;
 32 #include &quot;LibWebRTCDataChannelHandler.h&quot;
 33 #include &quot;LibWebRTCPeerConnectionBackend.h&quot;
 34 #include &quot;LibWebRTCProvider.h&quot;
 35 #include &quot;LibWebRTCRtpReceiverBackend.h&quot;
 36 #include &quot;LibWebRTCRtpSenderBackend.h&quot;
 37 #include &quot;LibWebRTCRtpTransceiverBackend.h&quot;
 38 #include &quot;LibWebRTCStatsCollector.h&quot;
 39 #include &quot;LibWebRTCUtils.h&quot;
 40 #include &quot;Logging.h&quot;
 41 #include &quot;NotImplemented.h&quot;
 42 #include &quot;Performance.h&quot;
 43 #include &quot;PlatformStrategies.h&quot;
 44 #include &quot;RTCDataChannel.h&quot;
 45 #include &quot;RTCDataChannelEvent.h&quot;
 46 #include &quot;RTCOfferOptions.h&quot;
 47 #include &quot;RTCPeerConnection.h&quot;
 48 #include &quot;RTCSessionDescription.h&quot;
 49 #include &quot;RTCStatsReport.h&quot;
<a name="1" id="anc1"></a><span class="line-removed"> 50 #include &quot;RTCTrackEvent.h&quot;</span>
 51 #include &quot;RealtimeIncomingAudioSource.h&quot;
 52 #include &quot;RealtimeIncomingVideoSource.h&quot;
 53 #include &quot;RealtimeOutgoingAudioSource.h&quot;
 54 #include &quot;RealtimeOutgoingVideoSource.h&quot;
 55 #include &quot;RuntimeEnabledFeatures.h&quot;
 56 #include &lt;webrtc/rtc_base/physicalsocketserver.h&gt;
 57 #include &lt;webrtc/p2p/base/basicpacketsocketfactory.h&gt;
 58 #include &lt;webrtc/p2p/client/basicportallocator.h&gt;
 59 #include &lt;webrtc/pc/peerconnectionfactory.h&gt;
 60 #include &lt;webrtc/system_wrappers/include/field_trial.h&gt;
 61 #include &lt;wtf/MainThread.h&gt;
 62 
 63 namespace WebCore {
 64 
 65 LibWebRTCMediaEndpoint::LibWebRTCMediaEndpoint(LibWebRTCPeerConnectionBackend&amp; peerConnection, LibWebRTCProvider&amp; client)
 66     : m_peerConnectionBackend(peerConnection)
 67     , m_peerConnectionFactory(*client.factory())
 68     , m_createSessionDescriptionObserver(*this)
 69     , m_setLocalSessionDescriptionObserver(*this)
 70     , m_setRemoteSessionDescriptionObserver(*this)
 71     , m_statsLogTimer(*this, &amp;LibWebRTCMediaEndpoint::gatherStatsForLogging)
 72 #if !RELEASE_LOG_DISABLED
 73     , m_logger(peerConnection.logger())
 74     , m_logIdentifier(peerConnection.logIdentifier())
 75 #endif
 76 {
 77     ASSERT(isMainThread());
 78     ASSERT(client.factory());
 79 
 80     if (RuntimeEnabledFeatures::sharedFeatures().webRTCH264SimulcastEnabled())
 81         webrtc::field_trial::InitFieldTrialsFromString(&quot;WebRTC-H264Simulcast/Enabled/&quot;);
 82 }
 83 
 84 bool LibWebRTCMediaEndpoint::setConfiguration(LibWebRTCProvider&amp; client, webrtc::PeerConnectionInterface::RTCConfiguration&amp;&amp; configuration)
 85 {
 86     if (RuntimeEnabledFeatures::sharedFeatures().webRTCUnifiedPlanEnabled())
 87         configuration.sdp_semantics = webrtc::SdpSemantics::kUnifiedPlan;
 88 
 89     if (!m_backend) {
<a name="2" id="anc2"></a><span class="line-modified"> 90         m_backend = client.createPeerConnection(*this, WTFMove(configuration));</span>




 91         return !!m_backend;
 92     }
 93     auto oldConfiguration = m_backend-&gt;GetConfiguration();
 94     configuration.certificates = oldConfiguration.certificates;
 95     return m_backend-&gt;SetConfiguration(WTFMove(configuration));
 96 }
 97 
 98 static inline const char* sessionDescriptionType(RTCSdpType sdpType)
 99 {
100     switch (sdpType) {
101     case RTCSdpType::Offer:
102         return &quot;offer&quot;;
103     case RTCSdpType::Pranswer:
104         return &quot;pranswer&quot;;
105     case RTCSdpType::Answer:
106         return &quot;answer&quot;;
107     case RTCSdpType::Rollback:
108         return &quot;rollback&quot;;
109     }
110 
111     ASSERT_NOT_REACHED();
112     return &quot;&quot;;
113 }
114 
115 static inline RTCSdpType fromSessionDescriptionType(const webrtc::SessionDescriptionInterface&amp; description)
116 {
117     auto type = description.type();
118     if (type == webrtc::SessionDescriptionInterface::kOffer)
119         return RTCSdpType::Offer;
120     if (type == webrtc::SessionDescriptionInterface::kAnswer)
121         return RTCSdpType::Answer;
122     ASSERT(type == webrtc::SessionDescriptionInterface::kPrAnswer);
123     return RTCSdpType::Pranswer;
124 }
125 
126 static inline RefPtr&lt;RTCSessionDescription&gt; fromSessionDescription(const webrtc::SessionDescriptionInterface* description)
127 {
128     if (!description)
129         return nullptr;
130 
131     std::string sdp;
132     description-&gt;ToString(&amp;sdp);
133 
134     return RTCSessionDescription::create(fromSessionDescriptionType(*description), fromStdString(sdp));
135 }
136 
137 // FIXME: We might want to create a new object only if the session actually changed for all description getters.
138 RefPtr&lt;RTCSessionDescription&gt; LibWebRTCMediaEndpoint::currentLocalDescription() const
139 {
140     return m_backend ? fromSessionDescription(m_backend-&gt;current_local_description()) : nullptr;
141 }
142 
143 RefPtr&lt;RTCSessionDescription&gt; LibWebRTCMediaEndpoint::currentRemoteDescription() const
144 {
145     return m_backend ? fromSessionDescription(m_backend-&gt;current_remote_description()) : nullptr;
146 }
147 
148 RefPtr&lt;RTCSessionDescription&gt; LibWebRTCMediaEndpoint::pendingLocalDescription() const
149 {
150     return m_backend ? fromSessionDescription(m_backend-&gt;pending_local_description()) : nullptr;
151 }
152 
153 RefPtr&lt;RTCSessionDescription&gt; LibWebRTCMediaEndpoint::pendingRemoteDescription() const
154 {
155     return m_backend ? fromSessionDescription(m_backend-&gt;pending_remote_description()) : nullptr;
156 }
157 
158 RefPtr&lt;RTCSessionDescription&gt; LibWebRTCMediaEndpoint::localDescription() const
159 {
160     return m_backend ? fromSessionDescription(m_backend-&gt;local_description()) : nullptr;
161 }
162 
163 RefPtr&lt;RTCSessionDescription&gt; LibWebRTCMediaEndpoint::remoteDescription() const
164 {
165     return m_backend ? fromSessionDescription(m_backend-&gt;remote_description()) : nullptr;
166 }
167 
168 void LibWebRTCMediaEndpoint::doSetLocalDescription(RTCSessionDescription&amp; description)
169 {
170     ASSERT(m_backend);
171 
172     webrtc::SdpParseError error;
173     std::unique_ptr&lt;webrtc::SessionDescriptionInterface&gt; sessionDescription(webrtc::CreateSessionDescription(sessionDescriptionType(description.type()), description.sdp().utf8().data(), &amp;error));
174 
175     if (!sessionDescription) {
176         m_peerConnectionBackend.setLocalDescriptionFailed(Exception { OperationError, fromStdString(error.description) });
177         return;
178     }
179 
180     // FIXME: See https://bugs.webkit.org/show_bug.cgi?id=173783. Remove this test once fixed at LibWebRTC level.
181     if (description.type() == RTCSdpType::Answer &amp;&amp; !m_backend-&gt;pending_remote_description()) {
182         m_peerConnectionBackend.setLocalDescriptionFailed(Exception { InvalidStateError, &quot;Failed to set local answer sdp: no pending remote description.&quot;_s });
183         return;
184     }
185 
186     m_backend-&gt;SetLocalDescription(&amp;m_setLocalSessionDescriptionObserver, sessionDescription.release());
187 }
188 
189 void LibWebRTCMediaEndpoint::doSetRemoteDescription(RTCSessionDescription&amp; description)
190 {
191     ASSERT(m_backend);
192 
193     webrtc::SdpParseError error;
194     std::unique_ptr&lt;webrtc::SessionDescriptionInterface&gt; sessionDescription(webrtc::CreateSessionDescription(sessionDescriptionType(description.type()), description.sdp().utf8().data(), &amp;error));
195     if (!sessionDescription) {
196         m_peerConnectionBackend.setRemoteDescriptionFailed(Exception { SyntaxError, fromStdString(error.description) });
197         return;
198     }
199     m_backend-&gt;SetRemoteDescription(&amp;m_setRemoteSessionDescriptionObserver, sessionDescription.release());
200 
201     startLoggingStats();
202 }
203 
204 bool LibWebRTCMediaEndpoint::addTrack(LibWebRTCRtpSenderBackend&amp; sender, MediaStreamTrack&amp; track, const Vector&lt;String&gt;&amp; mediaStreamIds)
205 {
206     ASSERT(m_backend);
207 
208     if (!RuntimeEnabledFeatures::sharedFeatures().webRTCUnifiedPlanEnabled()) {
209         String mediaStreamId = mediaStreamIds.isEmpty() ? createCanonicalUUIDString() : mediaStreamIds[0];
210         m_localStreams.ensure(mediaStreamId, [&amp;] {
211             auto mediaStream = m_peerConnectionFactory.CreateLocalMediaStream(mediaStreamId.utf8().data());
212             m_backend-&gt;AddStream(mediaStream);
213             return mediaStream;
214         });
215     }
216 
217     LibWebRTCRtpSenderBackend::Source source;
218     rtc::scoped_refptr&lt;webrtc::MediaStreamTrackInterface&gt; rtcTrack;
219     switch (track.privateTrack().type()) {
220     case RealtimeMediaSource::Type::Audio: {
221         auto audioSource = RealtimeOutgoingAudioSource::create(track.privateTrack());
<a name="3" id="anc3"></a><span class="line-removed">222 #if !RELEASE_LOG_DISABLED</span>
<span class="line-removed">223         audioSource-&gt;setLogger(m_logger.copyRef());</span>
<span class="line-removed">224 #endif</span>
225         rtcTrack = m_peerConnectionFactory.CreateAudioTrack(track.id().utf8().data(), audioSource.ptr());
226         source = WTFMove(audioSource);
227         break;
228     }
229     case RealtimeMediaSource::Type::Video: {
230         auto videoSource = RealtimeOutgoingVideoSource::create(track.privateTrack());
<a name="4" id="anc4"></a><span class="line-removed">231 #if !RELEASE_LOG_DISABLED</span>
<span class="line-removed">232         videoSource-&gt;setLogger(m_logger.copyRef());</span>
<span class="line-removed">233 #endif</span>
234         rtcTrack = m_peerConnectionFactory.CreateVideoTrack(track.id().utf8().data(), videoSource.ptr());
235         source = WTFMove(videoSource);
236         break;
237     }
238     case RealtimeMediaSource::Type::None:
239         ASSERT_NOT_REACHED();
240         return false;
241     }
242 
243     sender.setSource(WTFMove(source));
244     if (auto rtpSender = sender.rtcSender()) {
245         rtpSender-&gt;SetTrack(rtcTrack.get());
246         return true;
247     }
248 
249     std::vector&lt;std::string&gt; ids;
250     for (auto&amp; id : mediaStreamIds)
251         ids.push_back(id.utf8().data());
252 
253     auto newRTPSender = m_backend-&gt;AddTrack(rtcTrack.get(), WTFMove(ids));
254     if (!newRTPSender.ok())
255         return false;
256     sender.setRTCSender(newRTPSender.MoveValue());
257     return true;
258 }
259 
260 void LibWebRTCMediaEndpoint::removeTrack(LibWebRTCRtpSenderBackend&amp; sender)
261 {
262     ASSERT(m_backend);
263     m_backend-&gt;RemoveTrack(sender.rtcSender());
264     sender.clearSource();
265 }
266 
267 void LibWebRTCMediaEndpoint::doCreateOffer(const RTCOfferOptions&amp; options)
268 {
269     ASSERT(m_backend);
270 
271     m_isInitiator = true;
272     webrtc::PeerConnectionInterface::RTCOfferAnswerOptions rtcOptions;
273     rtcOptions.ice_restart = options.iceRestart;
274     rtcOptions.voice_activity_detection = options.voiceActivityDetection;
275 
276     if (!RuntimeEnabledFeatures::sharedFeatures().webRTCUnifiedPlanEnabled()) {
277         if (m_peerConnectionBackend.shouldOfferAllowToReceive(&quot;audio&quot;_s))
278             rtcOptions.offer_to_receive_audio = webrtc::PeerConnectionInterface::RTCOfferAnswerOptions::kOfferToReceiveMediaTrue;
279         if (m_peerConnectionBackend.shouldOfferAllowToReceive(&quot;video&quot;_s))
280             rtcOptions.offer_to_receive_video = webrtc::PeerConnectionInterface::RTCOfferAnswerOptions::kOfferToReceiveMediaTrue;
281     }
282     m_backend-&gt;CreateOffer(&amp;m_createSessionDescriptionObserver, rtcOptions);
283 }
284 
285 void LibWebRTCMediaEndpoint::doCreateAnswer()
286 {
287     ASSERT(m_backend);
288 
289     m_isInitiator = false;
290     m_backend-&gt;CreateAnswer(&amp;m_createSessionDescriptionObserver, { });
291 }
292 
<a name="5" id="anc5"></a><span class="line-modified">293 void LibWebRTCMediaEndpoint::getStats(Ref&lt;DeferredPromise&gt;&amp;&amp; promise, WTF::Function&lt;void(rtc::scoped_refptr&lt;LibWebRTCStatsCollector&gt;&amp;&amp;)&gt;&amp;&amp; getStatsFunction)</span>
294 {
<a name="6" id="anc6"></a><span class="line-modified">295     auto collector = LibWebRTCStatsCollector::create([promise = WTFMove(promise), protectedThis = makeRef(*this)]() mutable -&gt; RefPtr&lt;RTCStatsReport&gt; {</span>
296         ASSERT(isMainThread());
297         if (protectedThis-&gt;isStopped())
298             return nullptr;
299 
300         auto report = RTCStatsReport::create();
301 
302         promise-&gt;resolve&lt;IDLInterface&lt;RTCStatsReport&gt;&gt;(report.copyRef());
303 
304         // The promise resolution might fail in which case no backing map will be created.
305         if (!report-&gt;backingMap())
306             return nullptr;
<a name="7" id="anc7"></a><span class="line-modified">307         return WTFMove(report);</span>
<span class="line-removed">308     });</span>
<span class="line-removed">309     LibWebRTCProvider::callOnWebRTCSignalingThread([getStatsFunction = WTFMove(getStatsFunction), collector = WTFMove(collector)]() mutable {</span>
<span class="line-removed">310         getStatsFunction(WTFMove(collector));</span>
311     });
312 }
313 
314 void LibWebRTCMediaEndpoint::getStats(Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
315 {
<a name="8" id="anc8"></a><span class="line-modified">316     getStats(WTFMove(promise), [this](auto&amp;&amp; collector) {</span>
<span class="line-modified">317         if (m_backend)</span>
<span class="line-removed">318             m_backend-&gt;GetStats(WTFMove(collector));</span>
<span class="line-removed">319     });</span>
320 }
321 
322 void LibWebRTCMediaEndpoint::getStats(webrtc::RtpReceiverInterface&amp; receiver, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
323 {
<a name="9" id="anc9"></a><span class="line-modified">324     getStats(WTFMove(promise), [this, receiver = rtc::scoped_refptr&lt;webrtc::RtpReceiverInterface&gt;(&amp;receiver)](auto&amp;&amp; collector) mutable {</span>
<span class="line-modified">325         if (m_backend)</span>
<span class="line-removed">326             m_backend-&gt;GetStats(WTFMove(receiver), WTFMove(collector));</span>
<span class="line-removed">327     });</span>
328 }
329 
330 void LibWebRTCMediaEndpoint::getStats(webrtc::RtpSenderInterface&amp; sender, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
331 {
<a name="10" id="anc10"></a><span class="line-modified">332     getStats(WTFMove(promise), [this, sender = rtc::scoped_refptr&lt;webrtc::RtpSenderInterface&gt;(&amp;sender)](auto&amp;&amp; collector)  mutable {</span>
<span class="line-modified">333         if (m_backend)</span>
<span class="line-removed">334             m_backend-&gt;GetStats(WTFMove(sender), WTFMove(collector));</span>
<span class="line-removed">335     });</span>
336 }
337 
338 static RTCSignalingState signalingState(webrtc::PeerConnectionInterface::SignalingState state)
339 {
340     switch (state) {
341     case webrtc::PeerConnectionInterface::kStable:
342         return RTCSignalingState::Stable;
343     case webrtc::PeerConnectionInterface::kHaveLocalOffer:
344         return RTCSignalingState::HaveLocalOffer;
345     case webrtc::PeerConnectionInterface::kHaveLocalPrAnswer:
346         return RTCSignalingState::HaveLocalPranswer;
347     case webrtc::PeerConnectionInterface::kHaveRemoteOffer:
348         return RTCSignalingState::HaveRemoteOffer;
349     case webrtc::PeerConnectionInterface::kHaveRemotePrAnswer:
350         return RTCSignalingState::HaveRemotePranswer;
351     case webrtc::PeerConnectionInterface::kClosed:
352         return RTCSignalingState::Stable;
353     }
354 
355     ASSERT_NOT_REACHED();
356     return RTCSignalingState::Stable;
357 }
358 
359 void LibWebRTCMediaEndpoint::OnSignalingChange(webrtc::PeerConnectionInterface::SignalingState rtcState)
360 {
361     auto state = signalingState(rtcState);
362     callOnMainThread([protectedThis = makeRef(*this), state] {
363         if (protectedThis-&gt;isStopped())
364             return;
365         protectedThis-&gt;m_peerConnectionBackend.updateSignalingState(state);
366     });
367 }
368 
369 MediaStream&amp; LibWebRTCMediaEndpoint::mediaStreamFromRTCStream(webrtc::MediaStreamInterface&amp; rtcStream)
370 {
371     auto label = fromStdString(rtcStream.id());
372     auto mediaStream = m_remoteStreamsById.ensure(label, [label, this]() mutable {
<a name="11" id="anc11"></a><span class="line-modified">373         return MediaStream::create(*m_peerConnectionBackend.connection().scriptExecutionContext(), MediaStreamPrivate::create({ }, WTFMove(label)));</span>

374     });
375     return *mediaStream.iterator-&gt;value;
376 }
377 
378 void LibWebRTCMediaEndpoint::addRemoteStream(webrtc::MediaStreamInterface&amp;)
379 {
380 }
381 
382 void LibWebRTCMediaEndpoint::addRemoteTrack(rtc::scoped_refptr&lt;webrtc::RtpReceiverInterface&gt;&amp;&amp; rtcReceiver, const std::vector&lt;rtc::scoped_refptr&lt;webrtc::MediaStreamInterface&gt;&gt;&amp; rtcStreams)
383 {
384     ASSERT(rtcReceiver);
385     RefPtr&lt;RTCRtpReceiver&gt; receiver;
386     RefPtr&lt;RealtimeMediaSource&gt; remoteSource;
387 
388     auto* rtcTrack = rtcReceiver-&gt;track().get();
389 
390     switch (rtcReceiver-&gt;media_type()) {
391     case cricket::MEDIA_TYPE_DATA:
392         return;
393     case cricket::MEDIA_TYPE_AUDIO: {
394         rtc::scoped_refptr&lt;webrtc::AudioTrackInterface&gt; audioTrack = static_cast&lt;webrtc::AudioTrackInterface*&gt;(rtcTrack);
395         auto audioReceiver = m_peerConnectionBackend.audioReceiver(fromStdString(rtcTrack-&gt;id()));
396 
397         receiver = WTFMove(audioReceiver.receiver);
398         audioReceiver.source-&gt;setSourceTrack(WTFMove(audioTrack));
399         break;
400     }
401     case cricket::MEDIA_TYPE_VIDEO: {
402         rtc::scoped_refptr&lt;webrtc::VideoTrackInterface&gt; videoTrack = static_cast&lt;webrtc::VideoTrackInterface*&gt;(rtcTrack);
403         auto videoReceiver = m_peerConnectionBackend.videoReceiver(fromStdString(rtcTrack-&gt;id()));
404 
405         receiver = WTFMove(videoReceiver.receiver);
406         videoReceiver.source-&gt;setSourceTrack(WTFMove(videoTrack));
407         break;
408     }
409     }
410 
<a name="12" id="anc12"></a><span class="line-modified">411     receiver-&gt;setBackend(std::make_unique&lt;LibWebRTCRtpReceiverBackend&gt;(WTFMove(rtcReceiver)));</span>
412     auto&amp; track = receiver-&gt;track();
<a name="13" id="anc13"></a><span class="line-modified">413     fireTrackEvent(receiver.releaseNonNull(), track, rtcStreams, nullptr);</span>
414 }
415 
<a name="14" id="anc14"></a><span class="line-modified">416 void LibWebRTCMediaEndpoint::fireTrackEvent(Ref&lt;RTCRtpReceiver&gt;&amp;&amp; receiver, MediaStreamTrack&amp; track, const std::vector&lt;rtc::scoped_refptr&lt;webrtc::MediaStreamInterface&gt;&gt;&amp; rtcStreams, RefPtr&lt;RTCRtpTransceiver&gt;&amp;&amp; transceiver)</span>
417 {
418     Vector&lt;RefPtr&lt;MediaStream&gt;&gt; streams;
419     for (auto&amp; rtcStream : rtcStreams) {
420         auto&amp; mediaStream = mediaStreamFromRTCStream(*rtcStream.get());
421         streams.append(&amp;mediaStream);
422         mediaStream.addTrackFromPlatform(track);
423     }
424     auto streamIds = WTF::map(streams, [](auto&amp; stream) -&gt; String {
425         return stream-&gt;id();
426     });
427     m_remoteStreamsFromRemoteTrack.add(&amp;track, WTFMove(streamIds));
428 
<a name="15" id="anc15"></a><span class="line-modified">429     m_peerConnectionBackend.connection().fireEvent(RTCTrackEvent::create(eventNames().trackEvent,</span>
<span class="line-removed">430         Event::CanBubble::No, Event::IsCancelable::No, WTFMove(receiver), &amp;track, WTFMove(streams), WTFMove(transceiver)));</span>
<span class="line-removed">431 </span>
<span class="line-removed">432     // FIXME: As per spec, we should set muted to &#39;false&#39; when starting to receive the content from network.</span>
<span class="line-removed">433     track.source().setMuted(false);</span>
434 }
435 
436 static inline void setExistingReceiverSourceTrack(RealtimeMediaSource&amp; existingSource, webrtc::RtpReceiverInterface&amp; rtcReceiver)
437 {
438     switch (rtcReceiver.media_type()) {
439     case cricket::MEDIA_TYPE_AUDIO: {
440         ASSERT(existingSource.type() == RealtimeMediaSource::Type::Audio);
441         rtc::scoped_refptr&lt;webrtc::AudioTrackInterface&gt; audioTrack = static_cast&lt;webrtc::AudioTrackInterface*&gt;(rtcReceiver.track().get());
442         downcast&lt;RealtimeIncomingAudioSource&gt;(existingSource).setSourceTrack(WTFMove(audioTrack));
443         return;
444     }
445     case cricket::MEDIA_TYPE_VIDEO: {
446         ASSERT(existingSource.type() == RealtimeMediaSource::Type::Video);
447         rtc::scoped_refptr&lt;webrtc::VideoTrackInterface&gt; videoTrack = static_cast&lt;webrtc::VideoTrackInterface*&gt;(rtcReceiver.track().get());
448         downcast&lt;RealtimeIncomingVideoSource&gt;(existingSource).setSourceTrack(WTFMove(videoTrack));
449         return;
450     }
451     case cricket::MEDIA_TYPE_DATA:
452         ASSERT_NOT_REACHED();
453         return;
454     }
455 }
456 
457 RefPtr&lt;RealtimeMediaSource&gt; LibWebRTCMediaEndpoint::sourceFromNewReceiver(webrtc::RtpReceiverInterface&amp; rtcReceiver)
458 {
459     auto rtcTrack = rtcReceiver.track();
460     switch (rtcReceiver.media_type()) {
461     case cricket::MEDIA_TYPE_DATA:
462         return nullptr;
463     case cricket::MEDIA_TYPE_AUDIO: {
464         rtc::scoped_refptr&lt;webrtc::AudioTrackInterface&gt; audioTrack = static_cast&lt;webrtc::AudioTrackInterface*&gt;(rtcTrack.get());
<a name="16" id="anc16"></a><span class="line-modified">465         auto audioSource = RealtimeIncomingAudioSource::create(WTFMove(audioTrack), fromStdString(rtcTrack-&gt;id()));</span>
<span class="line-removed">466 #if !RELEASE_LOG_DISABLED</span>
<span class="line-removed">467         audioSource-&gt;setLogger(m_logger.copyRef());</span>
<span class="line-removed">468 #endif</span>
<span class="line-removed">469         return audioSource;</span>
470     }
471     case cricket::MEDIA_TYPE_VIDEO: {
472         rtc::scoped_refptr&lt;webrtc::VideoTrackInterface&gt; videoTrack = static_cast&lt;webrtc::VideoTrackInterface*&gt;(rtcTrack.get());
<a name="17" id="anc17"></a><span class="line-modified">473         auto videoSource =  RealtimeIncomingVideoSource::create(WTFMove(videoTrack), fromStdString(rtcTrack-&gt;id()));</span>
<span class="line-removed">474 #if !RELEASE_LOG_DISABLED</span>
<span class="line-removed">475         videoSource-&gt;setLogger(m_logger.copyRef());</span>
<span class="line-removed">476 #endif</span>
<span class="line-removed">477         return videoSource;</span>
478     }
479     }
480 
481     RELEASE_ASSERT_NOT_REACHED();
482 }
483 
484 void LibWebRTCMediaEndpoint::collectTransceivers()
485 {
486     if (!m_backend)
487         return;
488 
489     if (!RuntimeEnabledFeatures::sharedFeatures().webRTCUnifiedPlanEnabled())
490         return;
491 
492     for (auto&amp; rtcTransceiver : m_backend-&gt;GetTransceivers()) {
493         auto* existingTransceiver = m_peerConnectionBackend.existingTransceiver([&amp;](auto&amp; transceiverBackend) {
494             return rtcTransceiver.get() == transceiverBackend.rtcTransceiver();
495         });
496         if (existingTransceiver)
497             continue;
498 
499         auto rtcReceiver = rtcTransceiver-&gt;receiver();
500         auto source = sourceFromNewReceiver(*rtcReceiver);
501         if (!source)
502             return;
503 
<a name="18" id="anc18"></a><span class="line-modified">504         m_peerConnectionBackend.newRemoteTransceiver(std::make_unique&lt;LibWebRTCRtpTransceiverBackend&gt;(WTFMove(rtcTransceiver)), source.releaseNonNull());</span>
505     }
506 }
507 
508 void LibWebRTCMediaEndpoint::newTransceiver(rtc::scoped_refptr&lt;webrtc::RtpTransceiverInterface&gt;&amp;&amp; rtcTransceiver)
509 {
510     auto* transceiver = m_peerConnectionBackend.existingTransceiver([&amp;](auto&amp; transceiverBackend) {
511         return rtcTransceiver.get() == transceiverBackend.rtcTransceiver();
512     });
513     if (transceiver) {
514         auto rtcReceiver = rtcTransceiver-&gt;receiver();
515         setExistingReceiverSourceTrack(transceiver-&gt;receiver().track().source(), *rtcReceiver);
<a name="19" id="anc19"></a><span class="line-modified">516         fireTrackEvent(makeRef(transceiver-&gt;receiver()), transceiver-&gt;receiver().track(), rtcReceiver-&gt;streams(), makeRef(*transceiver));</span>
517         return;
518     }
519 
520     auto rtcReceiver = rtcTransceiver-&gt;receiver();
521     auto source = sourceFromNewReceiver(*rtcReceiver);
522     if (!source)
523         return;
524 
<a name="20" id="anc20"></a><span class="line-modified">525     auto&amp; newTransceiver = m_peerConnectionBackend.newRemoteTransceiver(std::make_unique&lt;LibWebRTCRtpTransceiverBackend&gt;(WTFMove(rtcTransceiver)), source.releaseNonNull());</span>
526 
<a name="21" id="anc21"></a><span class="line-modified">527     fireTrackEvent(makeRef(newTransceiver.receiver()), newTransceiver.receiver().track(), rtcReceiver-&gt;streams(), makeRef(newTransceiver));</span>
528 }
529 
530 void LibWebRTCMediaEndpoint::removeRemoteTrack(rtc::scoped_refptr&lt;webrtc::RtpReceiverInterface&gt;&amp;&amp; receiver)
531 {
532     // FIXME: Support plan B code path.
533     if (!RuntimeEnabledFeatures::sharedFeatures().webRTCUnifiedPlanEnabled())
534         return;
535 
536     auto* transceiver = m_peerConnectionBackend.existingTransceiver([&amp;receiver](auto&amp; transceiverBackend) {
537         auto* rtcTransceiver = transceiverBackend.rtcTransceiver();
538         return rtcTransceiver &amp;&amp; receiver.get() == rtcTransceiver-&gt;receiver().get();
539     });
540     if (!transceiver)
541         return;
542 
543     auto&amp; track = transceiver-&gt;receiver().track();
544 
545     for (auto&amp; id : m_remoteStreamsFromRemoteTrack.get(&amp;track)) {
546         if (auto stream = m_remoteStreamsById.get(id))
547             stream-&gt;privateStream().removeTrack(track.privateTrack(), MediaStreamPrivate::NotifyClientOption::Notify);
548     }
549 
550     track.source().setMuted(true);
551 }
552 
553 template&lt;typename T&gt;
554 Optional&lt;LibWebRTCMediaEndpoint::Backends&gt; LibWebRTCMediaEndpoint::createTransceiverBackends(T&amp;&amp; trackOrKind, const RTCRtpTransceiverInit&amp; init, LibWebRTCRtpSenderBackend::Source&amp;&amp; source)
555 {
556     auto result = m_backend-&gt;AddTransceiver(WTFMove(trackOrKind), fromRtpTransceiverInit(init));
557     if (!result.ok())
558         return WTF::nullopt;
559 
<a name="22" id="anc22"></a><span class="line-modified">560     auto transceiver = std::make_unique&lt;LibWebRTCRtpTransceiverBackend&gt;(result.MoveValue());</span>
561     return LibWebRTCMediaEndpoint::Backends { transceiver-&gt;createSenderBackend(m_peerConnectionBackend, WTFMove(source)), transceiver-&gt;createReceiverBackend(), WTFMove(transceiver) };
562 }
563 
564 Optional&lt;LibWebRTCMediaEndpoint::Backends&gt; LibWebRTCMediaEndpoint::addTransceiver(const String&amp; trackKind, const RTCRtpTransceiverInit&amp; init)
565 {
566     auto type = trackKind == &quot;audio&quot; ? cricket::MediaType::MEDIA_TYPE_AUDIO : cricket::MediaType::MEDIA_TYPE_VIDEO;
567     return createTransceiverBackends(type, init, nullptr);
568 }
569 
570 std::pair&lt;LibWebRTCRtpSenderBackend::Source, rtc::scoped_refptr&lt;webrtc::MediaStreamTrackInterface&gt;&gt; LibWebRTCMediaEndpoint::createSourceAndRTCTrack(MediaStreamTrack&amp; track)
571 {
572     LibWebRTCRtpSenderBackend::Source source;
573     rtc::scoped_refptr&lt;webrtc::MediaStreamTrackInterface&gt; rtcTrack;
574     switch (track.privateTrack().type()) {
575     case RealtimeMediaSource::Type::None:
576         ASSERT_NOT_REACHED();
577         break;
578     case RealtimeMediaSource::Type::Audio: {
579         auto audioSource = RealtimeOutgoingAudioSource::create(track.privateTrack());
580         rtcTrack = m_peerConnectionFactory.CreateAudioTrack(track.id().utf8().data(), audioSource.ptr());
581         source = WTFMove(audioSource);
582         break;
583     }
584     case RealtimeMediaSource::Type::Video: {
585         auto videoSource = RealtimeOutgoingVideoSource::create(track.privateTrack());
586         rtcTrack = m_peerConnectionFactory.CreateVideoTrack(track.id().utf8().data(), videoSource.ptr());
587         source = WTFMove(videoSource);
588         break;
589     }
590     }
591     return std::make_pair(WTFMove(source), WTFMove(rtcTrack));
592 }
593 
594 Optional&lt;LibWebRTCMediaEndpoint::Backends&gt; LibWebRTCMediaEndpoint::addTransceiver(MediaStreamTrack&amp; track, const RTCRtpTransceiverInit&amp; init)
595 {
596     auto sourceAndTrack = createSourceAndRTCTrack(track);
597     return createTransceiverBackends(WTFMove(sourceAndTrack.second), init, WTFMove(sourceAndTrack.first));
598 }
599 
600 void LibWebRTCMediaEndpoint::setSenderSourceFromTrack(LibWebRTCRtpSenderBackend&amp; sender, MediaStreamTrack&amp; track)
601 {
602     auto sourceAndTrack = createSourceAndRTCTrack(track);
603     sender.setSource(WTFMove(sourceAndTrack.first));
604     sender.rtcSender()-&gt;SetTrack(WTFMove(sourceAndTrack.second));
605 }
606 
607 std::unique_ptr&lt;LibWebRTCRtpTransceiverBackend&gt; LibWebRTCMediaEndpoint::transceiverBackendFromSender(LibWebRTCRtpSenderBackend&amp; backend)
608 {
609     for (auto&amp; transceiver : m_backend-&gt;GetTransceivers()) {
610         if (transceiver-&gt;sender().get() == backend.rtcSender())
<a name="23" id="anc23"></a><span class="line-modified">611             return std::make_unique&lt;LibWebRTCRtpTransceiverBackend&gt;(rtc::scoped_refptr&lt;webrtc::RtpTransceiverInterface&gt;(transceiver));</span>
612     }
613     return nullptr;
614 }
615 
616 
617 void LibWebRTCMediaEndpoint::removeRemoteStream(webrtc::MediaStreamInterface&amp; rtcStream)
618 {
619     bool removed = m_remoteStreamsById.remove(fromStdString(rtcStream.id()));
620     ASSERT_UNUSED(removed, removed);
621 }
622 
623 void LibWebRTCMediaEndpoint::OnAddStream(rtc::scoped_refptr&lt;webrtc::MediaStreamInterface&gt; stream)
624 {
625     callOnMainThread([protectedThis = makeRef(*this), stream = WTFMove(stream)] {
626         if (protectedThis-&gt;isStopped())
627             return;
628         ASSERT(stream);
629         protectedThis-&gt;addRemoteStream(*stream.get());
630     });
631 }
632 
633 void LibWebRTCMediaEndpoint::OnRemoveStream(rtc::scoped_refptr&lt;webrtc::MediaStreamInterface&gt; stream)
634 {
635     callOnMainThread([protectedThis = makeRef(*this), stream = WTFMove(stream)] {
636         if (protectedThis-&gt;isStopped())
637             return;
638         ASSERT(stream);
639         protectedThis-&gt;removeRemoteStream(*stream.get());
640     });
641 }
642 
643 void LibWebRTCMediaEndpoint::OnAddTrack(rtc::scoped_refptr&lt;webrtc::RtpReceiverInterface&gt; receiver, const std::vector&lt;rtc::scoped_refptr&lt;webrtc::MediaStreamInterface&gt;&gt;&amp; streams)
644 {
645     if (RuntimeEnabledFeatures::sharedFeatures().webRTCUnifiedPlanEnabled())
646         return;
647 
648     callOnMainThread([protectedThis = makeRef(*this), receiver = WTFMove(receiver), streams]() mutable {
649         if (protectedThis-&gt;isStopped())
650             return;
651         protectedThis-&gt;addRemoteTrack(WTFMove(receiver), streams);
652     });
653 }
654 
655 void LibWebRTCMediaEndpoint::OnTrack(rtc::scoped_refptr&lt;webrtc::RtpTransceiverInterface&gt; transceiver)
656 {
657     if (!RuntimeEnabledFeatures::sharedFeatures().webRTCUnifiedPlanEnabled())
658         return;
659 
660     callOnMainThread([protectedThis = makeRef(*this), transceiver = WTFMove(transceiver)]() mutable {
661         if (protectedThis-&gt;isStopped())
662             return;
663         protectedThis-&gt;newTransceiver(WTFMove(transceiver));
664     });
665 }
666 
667 void LibWebRTCMediaEndpoint::OnRemoveTrack(rtc::scoped_refptr&lt;webrtc::RtpReceiverInterface&gt; receiver)
668 {
669     callOnMainThread([protectedThis = makeRef(*this), receiver = WTFMove(receiver)]() mutable {
670         if (protectedThis-&gt;isStopped())
671             return;
672         protectedThis-&gt;removeRemoteTrack(WTFMove(receiver));
673     });
674 }
675 
676 std::unique_ptr&lt;RTCDataChannelHandler&gt; LibWebRTCMediaEndpoint::createDataChannel(const String&amp; label, const RTCDataChannelInit&amp; options)
677 {
678     auto init = LibWebRTCDataChannelHandler::fromRTCDataChannelInit(options);
679     auto channel = m_backend-&gt;CreateDataChannel(label.utf8().data(), &amp;init);
<a name="24" id="anc24"></a><span class="line-modified">680     return channel ? std::make_unique&lt;LibWebRTCDataChannelHandler&gt;(WTFMove(channel)) : nullptr;</span>
681 }
682 
683 void LibWebRTCMediaEndpoint::OnDataChannel(rtc::scoped_refptr&lt;webrtc::DataChannelInterface&gt; dataChannel)
684 {
685     callOnMainThread([protectedThis = makeRef(*this), dataChannel = WTFMove(dataChannel)]() mutable {
686         if (protectedThis-&gt;isStopped())
687             return;
688         auto&amp; connection = protectedThis-&gt;m_peerConnectionBackend.connection();
689         connection.fireEvent(LibWebRTCDataChannelHandler::channelEvent(*connection.scriptExecutionContext(), WTFMove(dataChannel)));
690     });
691 }
692 
693 void LibWebRTCMediaEndpoint::stop()
694 {
695     if (!m_backend)
696         return;
697 
698     stopLoggingStats();
699 
700     m_backend-&gt;Close();
701     m_backend = nullptr;
702     m_remoteStreamsById.clear();
703     m_remoteStreamsFromRemoteTrack.clear();
704 }
705 
706 void LibWebRTCMediaEndpoint::OnRenegotiationNeeded()
707 {
708     callOnMainThread([protectedThis = makeRef(*this)] {
709         if (protectedThis-&gt;isStopped())
710             return;
711         protectedThis-&gt;m_peerConnectionBackend.markAsNeedingNegotiation();
712     });
713 }
714 
715 static inline RTCIceConnectionState toRTCIceConnectionState(webrtc::PeerConnectionInterface::IceConnectionState state)
716 {
717     switch (state) {
718     case webrtc::PeerConnectionInterface::kIceConnectionNew:
719         return RTCIceConnectionState::New;
720     case webrtc::PeerConnectionInterface::kIceConnectionChecking:
721         return RTCIceConnectionState::Checking;
722     case webrtc::PeerConnectionInterface::kIceConnectionConnected:
723         return RTCIceConnectionState::Connected;
724     case webrtc::PeerConnectionInterface::kIceConnectionCompleted:
725         return RTCIceConnectionState::Completed;
726     case webrtc::PeerConnectionInterface::kIceConnectionFailed:
727         return RTCIceConnectionState::Failed;
728     case webrtc::PeerConnectionInterface::kIceConnectionDisconnected:
729         return RTCIceConnectionState::Disconnected;
730     case webrtc::PeerConnectionInterface::kIceConnectionClosed:
731         return RTCIceConnectionState::Closed;
732     case webrtc::PeerConnectionInterface::kIceConnectionMax:
733         break;
734     }
735 
736     ASSERT_NOT_REACHED();
737     return RTCIceConnectionState::New;
738 }
739 
740 void LibWebRTCMediaEndpoint::OnIceConnectionChange(webrtc::PeerConnectionInterface::IceConnectionState state)
741 {
742     auto connectionState = toRTCIceConnectionState(state);
743     callOnMainThread([protectedThis = makeRef(*this), connectionState] {
744         if (protectedThis-&gt;isStopped())
745             return;
746         if (protectedThis-&gt;m_peerConnectionBackend.connection().iceConnectionState() != connectionState)
747             protectedThis-&gt;m_peerConnectionBackend.connection().updateIceConnectionState(connectionState);
748     });
749 }
750 
751 void LibWebRTCMediaEndpoint::OnIceGatheringChange(webrtc::PeerConnectionInterface::IceGatheringState state)
752 {
753     callOnMainThread([protectedThis = makeRef(*this), state] {
754         if (protectedThis-&gt;isStopped())
755             return;
756         if (state == webrtc::PeerConnectionInterface::kIceGatheringComplete)
757             protectedThis-&gt;m_peerConnectionBackend.doneGatheringCandidates();
758         else if (state == webrtc::PeerConnectionInterface::kIceGatheringGathering)
759             protectedThis-&gt;m_peerConnectionBackend.connection().updateIceGatheringState(RTCIceGatheringState::Gathering);
760     });
761 }
762 
763 void LibWebRTCMediaEndpoint::OnIceCandidate(const webrtc::IceCandidateInterface *rtcCandidate)
764 {
765     ASSERT(rtcCandidate);
766 
767     std::string sdp;
768     rtcCandidate-&gt;ToString(&amp;sdp);
769 
770     auto sdpMLineIndex = safeCast&lt;unsigned short&gt;(rtcCandidate-&gt;sdp_mline_index());
771 
772     callOnMainThread([protectedThis = makeRef(*this), mid = fromStdString(rtcCandidate-&gt;sdp_mid()), sdp = fromStdString(sdp), sdpMLineIndex, url = fromStdString(rtcCandidate-&gt;server_url())]() mutable {
773         if (protectedThis-&gt;isStopped())
774             return;
775         protectedThis-&gt;m_peerConnectionBackend.newICECandidate(WTFMove(sdp), WTFMove(mid), sdpMLineIndex, WTFMove(url));
776     });
777 }
778 
779 void LibWebRTCMediaEndpoint::OnIceCandidatesRemoved(const std::vector&lt;cricket::Candidate&gt;&amp;)
780 {
781     ASSERT_NOT_REACHED();
782 }
783 
784 void LibWebRTCMediaEndpoint::createSessionDescriptionSucceeded(std::unique_ptr&lt;webrtc::SessionDescriptionInterface&gt;&amp;&amp; description)
785 {
786     std::string sdp;
787     description-&gt;ToString(&amp;sdp);
788 
789     callOnMainThread([protectedThis = makeRef(*this), sdp = fromStdString(sdp)]() mutable {
790         if (protectedThis-&gt;isStopped())
791             return;
792         if (protectedThis-&gt;m_isInitiator)
793             protectedThis-&gt;m_peerConnectionBackend.createOfferSucceeded(WTFMove(sdp));
794         else
795             protectedThis-&gt;m_peerConnectionBackend.createAnswerSucceeded(WTFMove(sdp));
796     });
797 }
798 
799 void LibWebRTCMediaEndpoint::createSessionDescriptionFailed(ExceptionCode errorCode, const char* errorMessage)
800 {
801     callOnMainThread([protectedThis = makeRef(*this), errorCode, errorMessage = String(errorMessage)] () mutable {
802         if (protectedThis-&gt;isStopped())
803             return;
804         if (protectedThis-&gt;m_isInitiator)
805             protectedThis-&gt;m_peerConnectionBackend.createOfferFailed(Exception { errorCode, WTFMove(errorMessage) });
806         else
807             protectedThis-&gt;m_peerConnectionBackend.createAnswerFailed(Exception { errorCode, WTFMove(errorMessage) });
808     });
809 }
810 
811 void LibWebRTCMediaEndpoint::setLocalSessionDescriptionSucceeded()
812 {
813     callOnMainThread([protectedThis = makeRef(*this)] {
814         if (protectedThis-&gt;isStopped())
815             return;
816         protectedThis-&gt;m_peerConnectionBackend.setLocalDescriptionSucceeded();
817     });
818 }
819 
820 void LibWebRTCMediaEndpoint::setLocalSessionDescriptionFailed(ExceptionCode errorCode, const char* errorMessage)
821 {
822     callOnMainThread([protectedThis = makeRef(*this), errorCode, errorMessage = String(errorMessage)] () mutable {
823         if (protectedThis-&gt;isStopped())
824             return;
825         protectedThis-&gt;m_peerConnectionBackend.setLocalDescriptionFailed(Exception { errorCode, WTFMove(errorMessage) });
826     });
827 }
828 
829 void LibWebRTCMediaEndpoint::setRemoteSessionDescriptionSucceeded()
830 {
831     callOnMainThread([protectedThis = makeRef(*this)] {
832         if (protectedThis-&gt;isStopped())
833             return;
834         protectedThis-&gt;m_peerConnectionBackend.setRemoteDescriptionSucceeded();
835     });
836 }
837 
838 void LibWebRTCMediaEndpoint::setRemoteSessionDescriptionFailed(ExceptionCode errorCode, const char* errorMessage)
839 {
840     callOnMainThread([protectedThis = makeRef(*this), errorCode, errorMessage = String(errorMessage)] () mutable {
841         if (protectedThis-&gt;isStopped())
842             return;
843         protectedThis-&gt;m_peerConnectionBackend.setRemoteDescriptionFailed(Exception { errorCode, WTFMove(errorMessage) });
844     });
845 }
846 
847 void LibWebRTCMediaEndpoint::gatherStatsForLogging()
848 {
<a name="25" id="anc25"></a><span class="line-modified">849     LibWebRTCProvider::callOnWebRTCSignalingThread([protectedThis = makeRef(*this)] {</span>
<span class="line-removed">850         if (protectedThis-&gt;m_backend)</span>
<span class="line-removed">851             protectedThis-&gt;m_backend-&gt;GetStats(protectedThis.ptr());</span>
<span class="line-removed">852     });</span>
853 }
854 
855 class RTCStatsLogger {
856 public:
857     explicit RTCStatsLogger(const webrtc::RTCStats&amp; stats)
858         : m_stats(stats)
859     {
860     }
861 
862     String toJSONString() const { return String(m_stats.ToJson().c_str()); }
863 
864 private:
865     const webrtc::RTCStats&amp; m_stats;
866 };
867 
868 void LibWebRTCMediaEndpoint::OnStatsDelivered(const rtc::scoped_refptr&lt;const webrtc::RTCStatsReport&gt;&amp; report)
869 {
870 #if !RELEASE_LOG_DISABLED
871     int64_t timestamp = report-&gt;timestamp_us();
872     if (!m_statsFirstDeliveredTimestamp)
873         m_statsFirstDeliveredTimestamp = timestamp;
874 
875     callOnMainThread([protectedThis = makeRef(*this), this, timestamp, report] {
<a name="26" id="anc26"></a><span class="line-modified">876         if (m_statsLogTimer.repeatInterval() != statsLogInterval(timestamp)) {</span>
877             m_statsLogTimer.stop();
878             m_statsLogTimer.startRepeating(statsLogInterval(timestamp));
879         }
880 
881         for (auto iterator = report-&gt;begin(); iterator != report-&gt;end(); ++iterator) {
<a name="27" id="anc27"></a><span class="line-modified">882             if (logger().willLog(logChannel(), WTFLogLevelDebug)) {</span>
883                 // Stats are very verbose, let&#39;s only display them in inspector console in verbose mode.
884                 logger().debug(LogWebRTC,
885                     Logger::LogSiteIdentifier(&quot;LibWebRTCMediaEndpoint&quot;, &quot;OnStatsDelivered&quot;, logIdentifier()),
886                     RTCStatsLogger { *iterator });
887             } else {
888                 logger().logAlways(LogWebRTCStats,
889                     Logger::LogSiteIdentifier(&quot;LibWebRTCMediaEndpoint&quot;, &quot;OnStatsDelivered&quot;, logIdentifier()),
890                     RTCStatsLogger { *iterator });
891             }
892         }
893     });
894 #else
895     UNUSED_PARAM(report);
896 #endif
897 }
898 
899 void LibWebRTCMediaEndpoint::startLoggingStats()
900 {
901 #if !RELEASE_LOG_DISABLED
902     if (m_statsLogTimer.isActive())
903         m_statsLogTimer.stop();
904     m_statsLogTimer.startRepeating(statsLogInterval(0));
905 #endif
906 }
907 
908 void LibWebRTCMediaEndpoint::stopLoggingStats()
909 {
910     m_statsLogTimer.stop();
911 }
912 
913 #if !RELEASE_LOG_DISABLED
914 WTFLogChannel&amp; LibWebRTCMediaEndpoint::logChannel() const
915 {
916     return LogWebRTC;
917 }
918 
919 Seconds LibWebRTCMediaEndpoint::statsLogInterval(int64_t reportTimestamp) const
920 {
<a name="28" id="anc28"></a><span class="line-modified">921     if (logger().willLog(logChannel(), WTFLogLevelInfo))</span>
922         return 2_s;
923 
924     if (reportTimestamp - m_statsFirstDeliveredTimestamp &gt; 15000000)
925         return 10_s;
926 
927     return 4_s;
928 }
929 #endif
930 
931 } // namespace WebCore
932 
933 namespace WTF {
934 
935 template&lt;typename Type&gt;
936 struct LogArgument;
937 
938 template &lt;&gt;
939 struct LogArgument&lt;WebCore::RTCStatsLogger&gt; {
940     static String toString(const WebCore::RTCStatsLogger&amp; logger)
941     {
942         return String(logger.toJSONString());
943     }
944 };
945 
946 }; // namespace WTF
947 
948 
949 #endif // USE(LIBWEBRTC)
<a name="29" id="anc29"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="29" type="hidden" />
</body>
</html>