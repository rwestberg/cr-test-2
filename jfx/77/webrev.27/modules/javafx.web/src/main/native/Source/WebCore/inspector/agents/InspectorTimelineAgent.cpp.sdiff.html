<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/inspector/agents/InspectorTimelineAgent.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="InspectorPageAgent.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="InspectorTimelineAgent.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/inspector/agents/InspectorTimelineAgent.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 20 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 21 * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 22 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 23 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 24 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 25 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 26 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 27 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 28 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 29 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 30 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 31 */
 32 
 33 #include &quot;config.h&quot;
 34 #include &quot;InspectorTimelineAgent.h&quot;
 35 
 36 #include &quot;DOMWindow.h&quot;
 37 #include &quot;Event.h&quot;
 38 #include &quot;Frame.h&quot;
 39 #include &quot;InspectorCPUProfilerAgent.h&quot;


 40 #include &quot;InspectorMemoryAgent.h&quot;
 41 #include &quot;InspectorPageAgent.h&quot;
 42 #include &quot;InstrumentingAgents.h&quot;
 43 #include &quot;JSDOMWindow.h&quot;

 44 #include &quot;PageScriptDebugServer.h&quot;
 45 #include &quot;RenderView.h&quot;
 46 #include &quot;ScriptState.h&quot;
 47 #include &quot;TimelineRecordFactory.h&quot;
 48 #include &quot;WebConsoleAgent.h&quot;
 49 #include &lt;JavaScriptCore/ConsoleMessage.h&gt;
 50 #include &lt;JavaScriptCore/InspectorDebuggerAgent.h&gt;
<span class="line-removed"> 51 #include &lt;JavaScriptCore/InspectorHeapAgent.h&gt;</span>
 52 #include &lt;JavaScriptCore/InspectorScriptProfilerAgent.h&gt;
 53 #include &lt;JavaScriptCore/ScriptBreakpoint.h&gt;
 54 #include &lt;wtf/Stopwatch.h&gt;
 55 
 56 #if PLATFORM(IOS_FAMILY)
 57 #include &quot;RuntimeApplicationChecks.h&quot;
 58 #include &quot;WebCoreThreadInternal.h&quot;
 59 #endif
 60 
 61 #if PLATFORM(COCOA)
 62 #include &quot;RunLoopObserver.h&quot;
 63 #endif
 64 
 65 
 66 namespace WebCore {
 67 
 68 using namespace Inspector;
 69 
 70 #if PLATFORM(COCOA)
 71 static CFRunLoopRef currentRunLoop()
 72 {
 73 #if PLATFORM(IOS_FAMILY)
 74     // A race condition during WebView deallocation can lead to a crash if the layer sync run loop
 75     // observer is added to the main run loop &lt;rdar://problem/9798550&gt;. However, for responsiveness,
 76     // we still allow this, see &lt;rdar://problem/7403328&gt;. Since the race condition and subsequent
 77     // crash are especially troublesome for iBooks, we never allow the observer to be added to the
 78     // main run loop in iBooks.
 79     if (IOSApplication::isIBooks())
 80         return WebThreadRunLoop();
 81 #endif
 82     return CFRunLoopGetCurrent();
 83 }
 84 #endif
 85 
<span class="line-modified"> 86 InspectorTimelineAgent::InspectorTimelineAgent(WebAgentContext&amp; context, InspectorScriptProfilerAgent* scriptProfileAgent, InspectorHeapAgent* heapAgent, InspectorPageAgent* pageAgent)</span>
 87     : InspectorAgentBase(&quot;Timeline&quot;_s, context)
<span class="line-modified"> 88     , m_frontendDispatcher(std::make_unique&lt;Inspector::TimelineFrontendDispatcher&gt;(context.frontendRouter))</span>
 89     , m_backendDispatcher(Inspector::TimelineBackendDispatcher::create(context.backendDispatcher, this))
<span class="line-modified"> 90     , m_scriptProfilerAgent(scriptProfileAgent)</span>
<span class="line-removed"> 91     , m_heapAgent(heapAgent)</span>
<span class="line-removed"> 92     , m_pageAgent(pageAgent)</span>
 93 {
 94 }
 95 
 96 InspectorTimelineAgent::~InspectorTimelineAgent() = default;
 97 
 98 void InspectorTimelineAgent::didCreateFrontendAndBackend(Inspector::FrontendRouter*, Inspector::BackendDispatcher*)
 99 {
<span class="line-removed">100     m_instrumentingAgents.setPersistentInspectorTimelineAgent(this);</span>
101 }
102 
103 void InspectorTimelineAgent::willDestroyFrontendAndBackend(Inspector::DisconnectReason)
104 {
<span class="line-modified">105     m_instrumentingAgents.setPersistentInspectorTimelineAgent(nullptr);</span>





















106 
<span class="line-modified">107     ErrorString unused;</span>
<span class="line-modified">108     stop(unused);</span>
109 
110     m_autoCaptureEnabled = false;
111     m_instruments.clear();
112 }
113 
114 void InspectorTimelineAgent::start(ErrorString&amp;, const int* maxCallStackDepth)
115 {
<span class="line-modified">116     m_enabledFromFrontend = true;</span>
117 
118     internalStart(maxCallStackDepth);
119 }
120 
121 void InspectorTimelineAgent::stop(ErrorString&amp;)
122 {
123     internalStop();
124 
<span class="line-modified">125     m_enabledFromFrontend = false;</span>
126 }
127 
128 void InspectorTimelineAgent::setAutoCaptureEnabled(ErrorString&amp;, bool enabled)
129 {
130     m_autoCaptureEnabled = enabled;
131 }
132 
133 void InspectorTimelineAgent::setInstruments(ErrorString&amp; errorString, const JSON::Array&amp; instruments)
134 {
135     Vector&lt;Protocol::Timeline::Instrument&gt; newInstruments;
136     newInstruments.reserveCapacity(instruments.length());
137 
138     for (const auto&amp; instrumentValue : instruments) {
139         String enumValueString;
140         if (!instrumentValue-&gt;asString(enumValueString)) {
<span class="line-modified">141             errorString = &quot;Unexpected type in instruments list, should be string&quot;_s;</span>
142             return;
143         }
144 
145         Optional&lt;Protocol::Timeline::Instrument&gt; instrumentType = Protocol::InspectorHelpers::parseEnumValueFromString&lt;Protocol::Timeline::Instrument&gt;(enumValueString);
146         if (!instrumentType) {
<span class="line-modified">147             errorString = makeString(&quot;Unexpected enum value: &quot;, enumValueString);</span>
148             return;
149         }
150 
151         newInstruments.uncheckedAppend(*instrumentType);
152     }
153 
154     m_instruments.swap(newInstruments);
155 }
156 
157 void InspectorTimelineAgent::internalStart(const int* maxCallStackDepth)
158 {
<span class="line-modified">159     if (m_enabled)</span>
160         return;
161 
162     if (maxCallStackDepth &amp;&amp; *maxCallStackDepth &gt; 0)
163         m_maxCallStackDepth = *maxCallStackDepth;
164     else
165         m_maxCallStackDepth = 5;
166 
<span class="line-modified">167     m_instrumentingAgents.setInspectorTimelineAgent(this);</span>
168 
169     m_environment.scriptDebugServer().addListener(this);
170 
<span class="line-modified">171     m_enabled = true;</span>
172 
173     // FIXME: Abstract away platform-specific code once https://bugs.webkit.org/show_bug.cgi?id=142748 is fixed.
174 
175 #if PLATFORM(COCOA)
<span class="line-modified">176     m_frameStartObserver = std::make_unique&lt;RunLoopObserver&gt;(static_cast&lt;CFIndex&gt;(RunLoopObserver::WellKnownRunLoopOrders::InspectorFrameBegin), [this]() {</span>
<span class="line-modified">177         if (!m_enabled || m_environment.scriptDebugServer().isPaused())</span>
178             return;
179 
180         if (!m_runLoopNestingLevel)
181             pushCurrentRecord(JSON::Object::create(), TimelineRecordType::RenderingFrame, false, nullptr);
182         m_runLoopNestingLevel++;
183     });
184 
<span class="line-modified">185     m_frameStopObserver = std::make_unique&lt;RunLoopObserver&gt;(static_cast&lt;CFIndex&gt;(RunLoopObserver::WellKnownRunLoopOrders::InspectorFrameEnd), [this]() {</span>
<span class="line-modified">186         if (!m_enabled || m_environment.scriptDebugServer().isPaused())</span>
187             return;
188 
189         ASSERT(m_runLoopNestingLevel &gt; 0);
190         m_runLoopNestingLevel--;
191         if (m_runLoopNestingLevel)
192             return;
193 
194         if (m_startedComposite)
195             didComposite();
196 
197         didCompleteCurrentRecord(TimelineRecordType::RenderingFrame);
198     });
199 
200     m_frameStartObserver-&gt;schedule(currentRunLoop(), kCFRunLoopEntry | kCFRunLoopAfterWaiting);
201     m_frameStopObserver-&gt;schedule(currentRunLoop(), kCFRunLoopExit | kCFRunLoopBeforeWaiting);
202 
203     // Create a runloop record and increment the runloop nesting level, to capture the current turn of the main runloop
204     // (which is the outer runloop if recording started while paused in the debugger).
205     pushCurrentRecord(JSON::Object::create(), TimelineRecordType::RenderingFrame, false, nullptr);
206 
207     m_runLoopNestingLevel = 1;
208 #endif
209 
210     m_frontendDispatcher-&gt;recordingStarted(timestamp());



211 }
212 
213 void InspectorTimelineAgent::internalStop()
214 {
<span class="line-modified">215     if (!m_enabled)</span>
216         return;
217 
<span class="line-modified">218     m_instrumentingAgents.setInspectorTimelineAgent(nullptr);</span>
219 
220     m_environment.scriptDebugServer().removeListener(this, true);
221 
222 #if PLATFORM(COCOA)
223     m_frameStartObserver = nullptr;
224     m_frameStopObserver = nullptr;
225     m_runLoopNestingLevel = 0;
226 
227     // Complete all pending records to prevent discarding events that are currently in progress.
228     while (!m_recordStack.isEmpty())
229         didCompleteCurrentRecord(m_recordStack.last().type);
230 #endif
231 
232     clearRecordStack();
233 
<span class="line-modified">234     m_enabled = false;</span>
235     m_startedComposite = false;
236     m_autoCapturePhase = AutoCapturePhase::None;
237 
238     m_frontendDispatcher-&gt;recordingStopped(timestamp());



239 }
240 
241 double InspectorTimelineAgent::timestamp()
242 {
243     return m_environment.executionStopwatch()-&gt;elapsedTime().seconds();
244 }
245 
246 void InspectorTimelineAgent::startFromConsole(JSC::ExecState* exec, const String&amp; title)
247 {
248     // Allow duplicate unnamed profiles. Disallow duplicate named profiles.
249     if (!title.isEmpty()) {
250         for (const TimelineRecordEntry&amp; record : m_pendingConsoleProfileRecords) {
251             String recordTitle;
252             record.data-&gt;getString(&quot;title&quot;_s, recordTitle);
253             if (recordTitle == title) {
254                 if (WebConsoleAgent* consoleAgent = m_instrumentingAgents.webConsoleAgent()) {
255                     // FIXME: Send an enum to the frontend for localization?
256                     String warning = title.isEmpty() ? &quot;Unnamed Profile already exists&quot;_s : makeString(&quot;Profile \&quot;&quot;, title, &quot;\&quot; already exists&quot;);
<span class="line-modified">257                     consoleAgent-&gt;addMessageToConsole(std::make_unique&lt;ConsoleMessage&gt;(MessageSource::ConsoleAPI, MessageType::Profile, MessageLevel::Warning, warning));</span>
258                 }
259                 return;
260             }
261         }
262     }
263 
<span class="line-modified">264     if (!m_enabled &amp;&amp; m_pendingConsoleProfileRecords.isEmpty())</span>
265         startProgrammaticCapture();
266 
267     m_pendingConsoleProfileRecords.append(createRecordEntry(TimelineRecordFactory::createConsoleProfileData(title), TimelineRecordType::ConsoleProfile, true, frameFromExecState(exec)));
268 }
269 
270 void InspectorTimelineAgent::stopFromConsole(JSC::ExecState*, const String&amp; title)
271 {
272     // Stop profiles in reverse order. If the title is empty, then stop the last profile.
273     // Otherwise, match the title of the profile to stop.
274     for (int i = m_pendingConsoleProfileRecords.size() - 1; i &gt;= 0; --i) {
275         const TimelineRecordEntry&amp; record = m_pendingConsoleProfileRecords[i];
276 
277         String recordTitle;
278         record.data-&gt;getString(&quot;title&quot;_s, recordTitle);
279         if (title.isEmpty() || recordTitle == title) {
280             didCompleteRecordEntry(record);
281             m_pendingConsoleProfileRecords.remove(i);
282 
<span class="line-modified">283             if (!m_enabledFromFrontend &amp;&amp; m_pendingConsoleProfileRecords.isEmpty())</span>
284                 stopProgrammaticCapture();
285 
286             return;
287         }
288     }
289 
290     if (WebConsoleAgent* consoleAgent = m_instrumentingAgents.webConsoleAgent()) {
291         // FIXME: Send an enum to the frontend for localization?
292         String warning = title.isEmpty() ? &quot;No profiles exist&quot;_s : makeString(&quot;Profile \&quot;&quot;, title, &quot;\&quot; does not exist&quot;);
<span class="line-modified">293         consoleAgent-&gt;addMessageToConsole(std::make_unique&lt;ConsoleMessage&gt;(MessageSource::ConsoleAPI, MessageType::ProfileEnd, MessageLevel::Warning, warning));</span>
294     }
295 }
296 
297 void InspectorTimelineAgent::willCallFunction(const String&amp; scriptName, int scriptLine, int scriptColumn, Frame* frame)
298 {
299     pushCurrentRecord(TimelineRecordFactory::createFunctionCallData(scriptName, scriptLine, scriptColumn), TimelineRecordType::FunctionCall, true, frame);
300 }
301 
302 void InspectorTimelineAgent::didCallFunction(Frame*)
303 {
304     didCompleteCurrentRecord(TimelineRecordType::FunctionCall);
305 }
306 
307 void InspectorTimelineAgent::willDispatchEvent(const Event&amp; event, Frame* frame)
308 {
309     pushCurrentRecord(TimelineRecordFactory::createEventDispatchData(event), TimelineRecordType::EventDispatch, false, frame);
310 }
311 
<span class="line-modified">312 void InspectorTimelineAgent::didDispatchEvent()</span>
313 {




314     didCompleteCurrentRecord(TimelineRecordType::EventDispatch);
315 }
316 
317 void InspectorTimelineAgent::didInvalidateLayout(Frame&amp; frame)
318 {
319     appendRecord(JSON::Object::create(), TimelineRecordType::InvalidateLayout, true, &amp;frame);
320 }
321 
322 void InspectorTimelineAgent::willLayout(Frame&amp; frame)
323 {
324     pushCurrentRecord(JSON::Object::create(), TimelineRecordType::Layout, true, &amp;frame);
325 }
326 
327 void InspectorTimelineAgent::didLayout(RenderObject&amp; root)
328 {
329     if (m_recordStack.isEmpty())
330         return;
331     TimelineRecordEntry&amp; entry = m_recordStack.last();
332     ASSERT(entry.type == TimelineRecordType::Layout);
333     Vector&lt;FloatQuad&gt; quads;
</pre>
<hr />
<pre>
346 
347 void InspectorTimelineAgent::willRecalculateStyle(Frame* frame)
348 {
349     pushCurrentRecord(JSON::Object::create(), TimelineRecordType::RecalculateStyles, true, frame);
350 }
351 
352 void InspectorTimelineAgent::didRecalculateStyle()
353 {
354     didCompleteCurrentRecord(TimelineRecordType::RecalculateStyles);
355 }
356 
357 void InspectorTimelineAgent::willComposite(Frame&amp; frame)
358 {
359     ASSERT(!m_startedComposite);
360     pushCurrentRecord(JSON::Object::create(), TimelineRecordType::Composite, true, &amp;frame);
361     m_startedComposite = true;
362 }
363 
364 void InspectorTimelineAgent::didComposite()
365 {
<span class="line-modified">366     ASSERT(m_startedComposite);</span>
<span class="line-modified">367     didCompleteCurrentRecord(TimelineRecordType::Composite);</span>
368     m_startedComposite = false;
369 }
370 
371 void InspectorTimelineAgent::willPaint(Frame&amp; frame)
372 {
373     pushCurrentRecord(JSON::Object::create(), TimelineRecordType::Paint, true, &amp;frame);
374 }
375 
376 void InspectorTimelineAgent::didPaint(RenderObject&amp; renderer, const LayoutRect&amp; clipRect)
377 {
378     TimelineRecordEntry&amp; entry = m_recordStack.last();
379     ASSERT(entry.type == TimelineRecordType::Paint);
380     FloatQuad quad;
381     localToPageQuad(renderer, clipRect, &amp;quad);
382     entry.data = TimelineRecordFactory::createPaintData(quad);
383     didCompleteCurrentRecord(TimelineRecordType::Paint);
384 }
385 
386 void InspectorTimelineAgent::didInstallTimer(int timerId, Seconds timeout, bool singleShot, Frame* frame)
387 {
</pre>
<hr />
<pre>
413     didCompleteCurrentRecord(TimelineRecordType::EvaluateScript);
414 }
415 
416 void InspectorTimelineAgent::didTimeStamp(Frame&amp; frame, const String&amp; message)
417 {
418     appendRecord(TimelineRecordFactory::createTimeStampData(message), TimelineRecordType::TimeStamp, true, &amp;frame);
419 }
420 
421 void InspectorTimelineAgent::time(Frame&amp; frame, const String&amp; message)
422 {
423     appendRecord(TimelineRecordFactory::createTimeStampData(message), TimelineRecordType::Time, true, &amp;frame);
424 }
425 
426 void InspectorTimelineAgent::timeEnd(Frame&amp; frame, const String&amp; message)
427 {
428     appendRecord(TimelineRecordFactory::createTimeStampData(message), TimelineRecordType::TimeEnd, true, &amp;frame);
429 }
430 
431 void InspectorTimelineAgent::mainFrameStartedLoading()
432 {
<span class="line-modified">433     if (m_enabled)</span>
434         return;
435 
436     if (!m_autoCaptureEnabled)
437         return;
438 
439     if (m_instruments.isEmpty())
440         return;
441 
442     m_autoCapturePhase = AutoCapturePhase::BeforeLoad;
443 
444     // Pre-emptively disable breakpoints. The frontend must re-enable them.
445     if (InspectorDebuggerAgent* debuggerAgent = m_instrumentingAgents.inspectorDebuggerAgent()) {
<span class="line-modified">446         ErrorString unused;</span>
<span class="line-modified">447         debuggerAgent-&gt;setBreakpointsActive(unused, false);</span>
448     }
449 
450     // Inform the frontend we started an auto capture. The frontend must stop capture.
451     m_frontendDispatcher-&gt;autoCaptureStarted();
452 
453     toggleInstruments(InstrumentState::Start);
454 }
455 
456 void InspectorTimelineAgent::mainFrameNavigated()
457 {
458     if (m_autoCapturePhase == AutoCapturePhase::BeforeLoad) {
459         m_autoCapturePhase = AutoCapturePhase::FirstNavigation;
460         toggleInstruments(InstrumentState::Start);
461         m_autoCapturePhase = AutoCapturePhase::AfterFirstNavigation;
462     }
463 }
464 
465 void InspectorTimelineAgent::startProgrammaticCapture()
466 {
<span class="line-modified">467     ASSERT(!m_enabled);</span>
468 
469     // Disable breakpoints during programmatic capture.
470     if (InspectorDebuggerAgent* debuggerAgent = m_instrumentingAgents.inspectorDebuggerAgent()) {
471         m_programmaticCaptureRestoreBreakpointActiveValue = debuggerAgent-&gt;breakpointsActive();
472         if (m_programmaticCaptureRestoreBreakpointActiveValue) {
<span class="line-modified">473             ErrorString unused;</span>
<span class="line-modified">474             debuggerAgent-&gt;setBreakpointsActive(unused, false);</span>
475         }
476     } else
477         m_programmaticCaptureRestoreBreakpointActiveValue = false;
478 
<span class="line-removed">479     m_frontendDispatcher-&gt;programmaticCaptureStarted();</span>
<span class="line-removed">480 </span>
481     toggleScriptProfilerInstrument(InstrumentState::Start); // Ensure JavaScript samping data.
482     toggleTimelineInstrument(InstrumentState::Start); // Ensure Console Profile event records.
483     toggleInstruments(InstrumentState::Start); // Any other instruments the frontend wants us to record.
484 }
485 
486 void InspectorTimelineAgent::stopProgrammaticCapture()
487 {
<span class="line-modified">488     ASSERT(m_enabled);</span>
<span class="line-modified">489     ASSERT(!m_enabledFromFrontend);</span>
490 
491     toggleInstruments(InstrumentState::Stop);
492     toggleTimelineInstrument(InstrumentState::Stop);
493     toggleScriptProfilerInstrument(InstrumentState::Stop);
494 
495     // Re-enable breakpoints if they were enabled.
496     if (m_programmaticCaptureRestoreBreakpointActiveValue) {
497         if (InspectorDebuggerAgent* debuggerAgent = m_instrumentingAgents.inspectorDebuggerAgent()) {
<span class="line-modified">498             ErrorString unused;</span>
<span class="line-modified">499             debuggerAgent-&gt;setBreakpointsActive(unused, true);</span>
500         }
501     }
<span class="line-removed">502 </span>
<span class="line-removed">503     m_frontendDispatcher-&gt;programmaticCaptureStopped();</span>
504 }
505 
506 void InspectorTimelineAgent::toggleInstruments(InstrumentState state)
507 {
508     for (auto instrumentType : m_instruments) {
509         switch (instrumentType) {
510         case Inspector::Protocol::Timeline::Instrument::ScriptProfiler: {
511             toggleScriptProfilerInstrument(state);
512             break;
513         }
514         case Inspector::Protocol::Timeline::Instrument::Heap: {
515             toggleHeapInstrument(state);
516             break;
517         }
518         case Inspector::Protocol::Timeline::Instrument::CPU: {
519             toggleCPUInstrument(state);
520             break;
521         }
522         case Inspector::Protocol::Timeline::Instrument::Memory: {
523             toggleMemoryInstrument(state);
524             break;
525         }
526         case Inspector::Protocol::Timeline::Instrument::Timeline:
527             toggleTimelineInstrument(state);
528             break;
529         }
530     }
531 }
532 
533 void InspectorTimelineAgent::toggleScriptProfilerInstrument(InstrumentState state)
534 {
<span class="line-modified">535     if (m_scriptProfilerAgent) {</span>
<span class="line-modified">536         ErrorString unused;</span>
537         if (state == InstrumentState::Start) {
538             const bool includeSamples = true;
<span class="line-modified">539             m_scriptProfilerAgent-&gt;startTracking(unused, &amp;includeSamples);</span>
540         } else
<span class="line-modified">541             m_scriptProfilerAgent-&gt;stopTracking(unused);</span>
542     }
543 }
544 
545 void InspectorTimelineAgent::toggleHeapInstrument(InstrumentState state)
546 {
<span class="line-modified">547     if (m_heapAgent) {</span>
<span class="line-modified">548         ErrorString unused;</span>
549         if (state == InstrumentState::Start) {
550             if (m_autoCapturePhase == AutoCapturePhase::None || m_autoCapturePhase == AutoCapturePhase::FirstNavigation)
<span class="line-modified">551                 m_heapAgent-&gt;startTracking(unused);</span>
552         } else
<span class="line-modified">553             m_heapAgent-&gt;stopTracking(unused);</span>
554     }
555 }
556 
557 void InspectorTimelineAgent::toggleCPUInstrument(InstrumentState state)
558 {
559 #if ENABLE(RESOURCE_USAGE)
560     if (InspectorCPUProfilerAgent* cpuProfilerAgent = m_instrumentingAgents.inspectorCPUProfilerAgent()) {
<span class="line-modified">561         ErrorString unused;</span>
562         if (state == InstrumentState::Start)
<span class="line-modified">563             cpuProfilerAgent-&gt;startTracking(unused);</span>
564         else
<span class="line-modified">565             cpuProfilerAgent-&gt;stopTracking(unused);</span>
566     }
567 #else
568     UNUSED_PARAM(state);
569 #endif
570 }
571 
572 void InspectorTimelineAgent::toggleMemoryInstrument(InstrumentState state)
573 {
574 #if ENABLE(RESOURCE_USAGE)
575     if (InspectorMemoryAgent* memoryAgent = m_instrumentingAgents.inspectorMemoryAgent()) {
<span class="line-modified">576         ErrorString unused;</span>
577         if (state == InstrumentState::Start)
<span class="line-modified">578             memoryAgent-&gt;startTracking(unused);</span>
579         else
<span class="line-modified">580             memoryAgent-&gt;stopTracking(unused);</span>
581     }
582 #else
583     UNUSED_PARAM(state);
584 #endif
585 }
586 
587 void InspectorTimelineAgent::toggleTimelineInstrument(InstrumentState state)
588 {
589     if (state == InstrumentState::Start)
590         internalStart();
591     else
592         internalStop();
593 }
594 
<span class="line-removed">595 void InspectorTimelineAgent::didCommitLoad()</span>
<span class="line-removed">596 {</span>
<span class="line-removed">597     clearRecordStack();</span>
<span class="line-removed">598 }</span>
<span class="line-removed">599 </span>
600 void InspectorTimelineAgent::didRequestAnimationFrame(int callbackId, Frame* frame)
601 {
602     appendRecord(TimelineRecordFactory::createAnimationFrameData(callbackId), TimelineRecordType::RequestAnimationFrame, true, frame);
603 }
604 
605 void InspectorTimelineAgent::didCancelAnimationFrame(int callbackId, Frame* frame)
606 {
607     appendRecord(TimelineRecordFactory::createAnimationFrameData(callbackId), TimelineRecordType::CancelAnimationFrame, true, frame);
608 }
609 
610 void InspectorTimelineAgent::willFireAnimationFrame(int callbackId, Frame* frame)
611 {
612     pushCurrentRecord(TimelineRecordFactory::createAnimationFrameData(callbackId), TimelineRecordType::FireAnimationFrame, false, frame);
613 }
614 
615 void InspectorTimelineAgent::didFireAnimationFrame()
616 {
617     didCompleteCurrentRecord(TimelineRecordType::FireAnimationFrame);
618 }
619 
</pre>
<hr />
<pre>
695 void InspectorTimelineAgent::addRecordToTimeline(RefPtr&lt;JSON::Object&gt;&amp;&amp; record, TimelineRecordType type)
696 {
697     ASSERT_ARG(record, record);
698     record-&gt;setString(&quot;type&quot;, Inspector::Protocol::InspectorHelpers::getEnumConstantValue(toProtocol(type)));
699 
700     if (m_recordStack.isEmpty()) {
701         auto recordObject = BindingTraits&lt;Inspector::Protocol::Timeline::TimelineEvent&gt;::runtimeCast(WTFMove(record));
702         sendEvent(WTFMove(recordObject));
703     } else {
704         const TimelineRecordEntry&amp; parent = m_recordStack.last();
705         // Nested paint records are an implementation detail and add no information not already contained in the parent.
706         if (type == TimelineRecordType::Paint &amp;&amp; parent.type == type)
707             return;
708 
709         parent.children-&gt;pushObject(WTFMove(record));
710     }
711 }
712 
713 void InspectorTimelineAgent::setFrameIdentifier(JSON::Object* record, Frame* frame)
714 {
<span class="line-modified">715     if (!frame || !m_pageAgent)</span>
716         return;
<span class="line-modified">717     String frameId;</span>
<span class="line-modified">718     if (frame &amp;&amp; m_pageAgent)</span>
<span class="line-modified">719         frameId = m_pageAgent-&gt;frameId(frame);</span>
<span class="line-modified">720     record-&gt;setString(&quot;frameId&quot;, frameId);</span>


721 }
722 
723 void InspectorTimelineAgent::didCompleteRecordEntry(const TimelineRecordEntry&amp; entry)
724 {
725     entry.record-&gt;setObject(&quot;data&quot;_s, entry.data);
726     entry.record-&gt;setArray(&quot;children&quot;_s, entry.children);
727     entry.record-&gt;setDouble(&quot;endTime&quot;_s, timestamp());
728     addRecordToTimeline(entry.record.copyRef(), entry.type);
729 }
730 
731 void InspectorTimelineAgent::didCompleteCurrentRecord(TimelineRecordType type)
732 {
733     // An empty stack could merely mean that the timeline agent was turned on in the middle of
734     // an event.  Don&#39;t treat as an error.
735     if (!m_recordStack.isEmpty()) {
736         TimelineRecordEntry entry = m_recordStack.last();
737         m_recordStack.removeLast();
738         ASSERT_UNUSED(type, entry.type == type);
739 
740         // Don&#39;t send RenderingFrame records that have no children to reduce noise.
</pre>
</td>
<td>
<hr />
<pre>
 20 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 21 * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 22 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 23 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 24 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 25 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 26 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 27 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 28 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 29 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 30 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 31 */
 32 
 33 #include &quot;config.h&quot;
 34 #include &quot;InspectorTimelineAgent.h&quot;
 35 
 36 #include &quot;DOMWindow.h&quot;
 37 #include &quot;Event.h&quot;
 38 #include &quot;Frame.h&quot;
 39 #include &quot;InspectorCPUProfilerAgent.h&quot;
<span class="line-added"> 40 #include &quot;InspectorClient.h&quot;</span>
<span class="line-added"> 41 #include &quot;InspectorController.h&quot;</span>
 42 #include &quot;InspectorMemoryAgent.h&quot;
 43 #include &quot;InspectorPageAgent.h&quot;
 44 #include &quot;InstrumentingAgents.h&quot;
 45 #include &quot;JSDOMWindow.h&quot;
<span class="line-added"> 46 #include &quot;PageHeapAgent.h&quot;</span>
 47 #include &quot;PageScriptDebugServer.h&quot;
 48 #include &quot;RenderView.h&quot;
 49 #include &quot;ScriptState.h&quot;
 50 #include &quot;TimelineRecordFactory.h&quot;
 51 #include &quot;WebConsoleAgent.h&quot;
 52 #include &lt;JavaScriptCore/ConsoleMessage.h&gt;
 53 #include &lt;JavaScriptCore/InspectorDebuggerAgent.h&gt;

 54 #include &lt;JavaScriptCore/InspectorScriptProfilerAgent.h&gt;
 55 #include &lt;JavaScriptCore/ScriptBreakpoint.h&gt;
 56 #include &lt;wtf/Stopwatch.h&gt;
 57 
 58 #if PLATFORM(IOS_FAMILY)
 59 #include &quot;RuntimeApplicationChecks.h&quot;
 60 #include &quot;WebCoreThreadInternal.h&quot;
 61 #endif
 62 
 63 #if PLATFORM(COCOA)
 64 #include &quot;RunLoopObserver.h&quot;
 65 #endif
 66 
 67 
 68 namespace WebCore {
 69 
 70 using namespace Inspector;
 71 
 72 #if PLATFORM(COCOA)
 73 static CFRunLoopRef currentRunLoop()
 74 {
 75 #if PLATFORM(IOS_FAMILY)
 76     // A race condition during WebView deallocation can lead to a crash if the layer sync run loop
 77     // observer is added to the main run loop &lt;rdar://problem/9798550&gt;. However, for responsiveness,
 78     // we still allow this, see &lt;rdar://problem/7403328&gt;. Since the race condition and subsequent
 79     // crash are especially troublesome for iBooks, we never allow the observer to be added to the
 80     // main run loop in iBooks.
 81     if (IOSApplication::isIBooks())
 82         return WebThreadRunLoop();
 83 #endif
 84     return CFRunLoopGetCurrent();
 85 }
 86 #endif
 87 
<span class="line-modified"> 88 InspectorTimelineAgent::InspectorTimelineAgent(PageAgentContext&amp; context)</span>
 89     : InspectorAgentBase(&quot;Timeline&quot;_s, context)
<span class="line-modified"> 90     , m_frontendDispatcher(makeUnique&lt;Inspector::TimelineFrontendDispatcher&gt;(context.frontendRouter))</span>
 91     , m_backendDispatcher(Inspector::TimelineBackendDispatcher::create(context.backendDispatcher, this))
<span class="line-modified"> 92     , m_inspectedPage(context.inspectedPage)</span>


 93 {
 94 }
 95 
 96 InspectorTimelineAgent::~InspectorTimelineAgent() = default;
 97 
 98 void InspectorTimelineAgent::didCreateFrontendAndBackend(Inspector::FrontendRouter*, Inspector::BackendDispatcher*)
 99 {

100 }
101 
102 void InspectorTimelineAgent::willDestroyFrontendAndBackend(Inspector::DisconnectReason)
103 {
<span class="line-modified">104     ErrorString ignored;</span>
<span class="line-added">105     disable(ignored);</span>
<span class="line-added">106 }</span>
<span class="line-added">107 </span>
<span class="line-added">108 void InspectorTimelineAgent::enable(ErrorString&amp; errorString)</span>
<span class="line-added">109 {</span>
<span class="line-added">110     if (m_instrumentingAgents.inspectorTimelineAgent() == this) {</span>
<span class="line-added">111         errorString = &quot;Timeline domain already enabled&quot;_s;</span>
<span class="line-added">112         return;</span>
<span class="line-added">113     }</span>
<span class="line-added">114 </span>
<span class="line-added">115     m_instrumentingAgents.setInspectorTimelineAgent(this);</span>
<span class="line-added">116 }</span>
<span class="line-added">117 </span>
<span class="line-added">118 void InspectorTimelineAgent::disable(ErrorString&amp; errorString)</span>
<span class="line-added">119 {</span>
<span class="line-added">120     if (m_instrumentingAgents.inspectorTimelineAgent() != this) {</span>
<span class="line-added">121         errorString = &quot;Timeline domain already disabled&quot;_s;</span>
<span class="line-added">122         return;</span>
<span class="line-added">123     }</span>
<span class="line-added">124 </span>
<span class="line-added">125     m_instrumentingAgents.setInspectorTimelineAgent(nullptr);</span>
126 
<span class="line-modified">127     ErrorString ignored;</span>
<span class="line-modified">128     stop(ignored);</span>
129 
130     m_autoCaptureEnabled = false;
131     m_instruments.clear();
132 }
133 
134 void InspectorTimelineAgent::start(ErrorString&amp;, const int* maxCallStackDepth)
135 {
<span class="line-modified">136     m_trackingFromFrontend = true;</span>
137 
138     internalStart(maxCallStackDepth);
139 }
140 
141 void InspectorTimelineAgent::stop(ErrorString&amp;)
142 {
143     internalStop();
144 
<span class="line-modified">145     m_trackingFromFrontend = false;</span>
146 }
147 
148 void InspectorTimelineAgent::setAutoCaptureEnabled(ErrorString&amp;, bool enabled)
149 {
150     m_autoCaptureEnabled = enabled;
151 }
152 
153 void InspectorTimelineAgent::setInstruments(ErrorString&amp; errorString, const JSON::Array&amp; instruments)
154 {
155     Vector&lt;Protocol::Timeline::Instrument&gt; newInstruments;
156     newInstruments.reserveCapacity(instruments.length());
157 
158     for (const auto&amp; instrumentValue : instruments) {
159         String enumValueString;
160         if (!instrumentValue-&gt;asString(enumValueString)) {
<span class="line-modified">161             errorString = &quot;Unexpected non-string value in given instruments&quot;_s;</span>
162             return;
163         }
164 
165         Optional&lt;Protocol::Timeline::Instrument&gt; instrumentType = Protocol::InspectorHelpers::parseEnumValueFromString&lt;Protocol::Timeline::Instrument&gt;(enumValueString);
166         if (!instrumentType) {
<span class="line-modified">167             errorString = makeString(&quot;Unknown item in given instruments: &quot;, enumValueString);</span>
168             return;
169         }
170 
171         newInstruments.uncheckedAppend(*instrumentType);
172     }
173 
174     m_instruments.swap(newInstruments);
175 }
176 
177 void InspectorTimelineAgent::internalStart(const int* maxCallStackDepth)
178 {
<span class="line-modified">179     if (m_tracking)</span>
180         return;
181 
182     if (maxCallStackDepth &amp;&amp; *maxCallStackDepth &gt; 0)
183         m_maxCallStackDepth = *maxCallStackDepth;
184     else
185         m_maxCallStackDepth = 5;
186 
<span class="line-modified">187     m_instrumentingAgents.setTrackingInspectorTimelineAgent(this);</span>
188 
189     m_environment.scriptDebugServer().addListener(this);
190 
<span class="line-modified">191     m_tracking = true;</span>
192 
193     // FIXME: Abstract away platform-specific code once https://bugs.webkit.org/show_bug.cgi?id=142748 is fixed.
194 
195 #if PLATFORM(COCOA)
<span class="line-modified">196     m_frameStartObserver = makeUnique&lt;RunLoopObserver&gt;(static_cast&lt;CFIndex&gt;(RunLoopObserver::WellKnownRunLoopOrders::InspectorFrameBegin), [this]() {</span>
<span class="line-modified">197         if (!m_tracking || m_environment.scriptDebugServer().isPaused())</span>
198             return;
199 
200         if (!m_runLoopNestingLevel)
201             pushCurrentRecord(JSON::Object::create(), TimelineRecordType::RenderingFrame, false, nullptr);
202         m_runLoopNestingLevel++;
203     });
204 
<span class="line-modified">205     m_frameStopObserver = makeUnique&lt;RunLoopObserver&gt;(static_cast&lt;CFIndex&gt;(RunLoopObserver::WellKnownRunLoopOrders::InspectorFrameEnd), [this]() {</span>
<span class="line-modified">206         if (!m_tracking || m_environment.scriptDebugServer().isPaused())</span>
207             return;
208 
209         ASSERT(m_runLoopNestingLevel &gt; 0);
210         m_runLoopNestingLevel--;
211         if (m_runLoopNestingLevel)
212             return;
213 
214         if (m_startedComposite)
215             didComposite();
216 
217         didCompleteCurrentRecord(TimelineRecordType::RenderingFrame);
218     });
219 
220     m_frameStartObserver-&gt;schedule(currentRunLoop(), kCFRunLoopEntry | kCFRunLoopAfterWaiting);
221     m_frameStopObserver-&gt;schedule(currentRunLoop(), kCFRunLoopExit | kCFRunLoopBeforeWaiting);
222 
223     // Create a runloop record and increment the runloop nesting level, to capture the current turn of the main runloop
224     // (which is the outer runloop if recording started while paused in the debugger).
225     pushCurrentRecord(JSON::Object::create(), TimelineRecordType::RenderingFrame, false, nullptr);
226 
227     m_runLoopNestingLevel = 1;
228 #endif
229 
230     m_frontendDispatcher-&gt;recordingStarted(timestamp());
<span class="line-added">231 </span>
<span class="line-added">232     if (auto* client = m_inspectedPage.inspectorController().inspectorClient())</span>
<span class="line-added">233         client-&gt;timelineRecordingChanged(true);</span>
234 }
235 
236 void InspectorTimelineAgent::internalStop()
237 {
<span class="line-modified">238     if (!m_tracking)</span>
239         return;
240 
<span class="line-modified">241     m_instrumentingAgents.setTrackingInspectorTimelineAgent(nullptr);</span>
242 
243     m_environment.scriptDebugServer().removeListener(this, true);
244 
245 #if PLATFORM(COCOA)
246     m_frameStartObserver = nullptr;
247     m_frameStopObserver = nullptr;
248     m_runLoopNestingLevel = 0;
249 
250     // Complete all pending records to prevent discarding events that are currently in progress.
251     while (!m_recordStack.isEmpty())
252         didCompleteCurrentRecord(m_recordStack.last().type);
253 #endif
254 
255     clearRecordStack();
256 
<span class="line-modified">257     m_tracking = false;</span>
258     m_startedComposite = false;
259     m_autoCapturePhase = AutoCapturePhase::None;
260 
261     m_frontendDispatcher-&gt;recordingStopped(timestamp());
<span class="line-added">262 </span>
<span class="line-added">263     if (auto* client = m_inspectedPage.inspectorController().inspectorClient())</span>
<span class="line-added">264         client-&gt;timelineRecordingChanged(false);</span>
265 }
266 
267 double InspectorTimelineAgent::timestamp()
268 {
269     return m_environment.executionStopwatch()-&gt;elapsedTime().seconds();
270 }
271 
272 void InspectorTimelineAgent::startFromConsole(JSC::ExecState* exec, const String&amp; title)
273 {
274     // Allow duplicate unnamed profiles. Disallow duplicate named profiles.
275     if (!title.isEmpty()) {
276         for (const TimelineRecordEntry&amp; record : m_pendingConsoleProfileRecords) {
277             String recordTitle;
278             record.data-&gt;getString(&quot;title&quot;_s, recordTitle);
279             if (recordTitle == title) {
280                 if (WebConsoleAgent* consoleAgent = m_instrumentingAgents.webConsoleAgent()) {
281                     // FIXME: Send an enum to the frontend for localization?
282                     String warning = title.isEmpty() ? &quot;Unnamed Profile already exists&quot;_s : makeString(&quot;Profile \&quot;&quot;, title, &quot;\&quot; already exists&quot;);
<span class="line-modified">283                     consoleAgent-&gt;addMessageToConsole(makeUnique&lt;ConsoleMessage&gt;(MessageSource::ConsoleAPI, MessageType::Profile, MessageLevel::Warning, warning));</span>
284                 }
285                 return;
286             }
287         }
288     }
289 
<span class="line-modified">290     if (!m_tracking &amp;&amp; m_pendingConsoleProfileRecords.isEmpty())</span>
291         startProgrammaticCapture();
292 
293     m_pendingConsoleProfileRecords.append(createRecordEntry(TimelineRecordFactory::createConsoleProfileData(title), TimelineRecordType::ConsoleProfile, true, frameFromExecState(exec)));
294 }
295 
296 void InspectorTimelineAgent::stopFromConsole(JSC::ExecState*, const String&amp; title)
297 {
298     // Stop profiles in reverse order. If the title is empty, then stop the last profile.
299     // Otherwise, match the title of the profile to stop.
300     for (int i = m_pendingConsoleProfileRecords.size() - 1; i &gt;= 0; --i) {
301         const TimelineRecordEntry&amp; record = m_pendingConsoleProfileRecords[i];
302 
303         String recordTitle;
304         record.data-&gt;getString(&quot;title&quot;_s, recordTitle);
305         if (title.isEmpty() || recordTitle == title) {
306             didCompleteRecordEntry(record);
307             m_pendingConsoleProfileRecords.remove(i);
308 
<span class="line-modified">309             if (!m_trackingFromFrontend &amp;&amp; m_pendingConsoleProfileRecords.isEmpty())</span>
310                 stopProgrammaticCapture();
311 
312             return;
313         }
314     }
315 
316     if (WebConsoleAgent* consoleAgent = m_instrumentingAgents.webConsoleAgent()) {
317         // FIXME: Send an enum to the frontend for localization?
318         String warning = title.isEmpty() ? &quot;No profiles exist&quot;_s : makeString(&quot;Profile \&quot;&quot;, title, &quot;\&quot; does not exist&quot;);
<span class="line-modified">319         consoleAgent-&gt;addMessageToConsole(makeUnique&lt;ConsoleMessage&gt;(MessageSource::ConsoleAPI, MessageType::ProfileEnd, MessageLevel::Warning, warning));</span>
320     }
321 }
322 
323 void InspectorTimelineAgent::willCallFunction(const String&amp; scriptName, int scriptLine, int scriptColumn, Frame* frame)
324 {
325     pushCurrentRecord(TimelineRecordFactory::createFunctionCallData(scriptName, scriptLine, scriptColumn), TimelineRecordType::FunctionCall, true, frame);
326 }
327 
328 void InspectorTimelineAgent::didCallFunction(Frame*)
329 {
330     didCompleteCurrentRecord(TimelineRecordType::FunctionCall);
331 }
332 
333 void InspectorTimelineAgent::willDispatchEvent(const Event&amp; event, Frame* frame)
334 {
335     pushCurrentRecord(TimelineRecordFactory::createEventDispatchData(event), TimelineRecordType::EventDispatch, false, frame);
336 }
337 
<span class="line-modified">338 void InspectorTimelineAgent::didDispatchEvent(bool defaultPrevented)</span>
339 {
<span class="line-added">340     auto&amp; entry = m_recordStack.last();</span>
<span class="line-added">341     ASSERT(entry.type == TimelineRecordType::EventDispatch);</span>
<span class="line-added">342     entry.data-&gt;setBoolean(&quot;defaultPrevented&quot;_s, defaultPrevented);</span>
<span class="line-added">343 </span>
344     didCompleteCurrentRecord(TimelineRecordType::EventDispatch);
345 }
346 
347 void InspectorTimelineAgent::didInvalidateLayout(Frame&amp; frame)
348 {
349     appendRecord(JSON::Object::create(), TimelineRecordType::InvalidateLayout, true, &amp;frame);
350 }
351 
352 void InspectorTimelineAgent::willLayout(Frame&amp; frame)
353 {
354     pushCurrentRecord(JSON::Object::create(), TimelineRecordType::Layout, true, &amp;frame);
355 }
356 
357 void InspectorTimelineAgent::didLayout(RenderObject&amp; root)
358 {
359     if (m_recordStack.isEmpty())
360         return;
361     TimelineRecordEntry&amp; entry = m_recordStack.last();
362     ASSERT(entry.type == TimelineRecordType::Layout);
363     Vector&lt;FloatQuad&gt; quads;
</pre>
<hr />
<pre>
376 
377 void InspectorTimelineAgent::willRecalculateStyle(Frame* frame)
378 {
379     pushCurrentRecord(JSON::Object::create(), TimelineRecordType::RecalculateStyles, true, frame);
380 }
381 
382 void InspectorTimelineAgent::didRecalculateStyle()
383 {
384     didCompleteCurrentRecord(TimelineRecordType::RecalculateStyles);
385 }
386 
387 void InspectorTimelineAgent::willComposite(Frame&amp; frame)
388 {
389     ASSERT(!m_startedComposite);
390     pushCurrentRecord(JSON::Object::create(), TimelineRecordType::Composite, true, &amp;frame);
391     m_startedComposite = true;
392 }
393 
394 void InspectorTimelineAgent::didComposite()
395 {
<span class="line-modified">396     if (m_startedComposite)</span>
<span class="line-modified">397         didCompleteCurrentRecord(TimelineRecordType::Composite);</span>
398     m_startedComposite = false;
399 }
400 
401 void InspectorTimelineAgent::willPaint(Frame&amp; frame)
402 {
403     pushCurrentRecord(JSON::Object::create(), TimelineRecordType::Paint, true, &amp;frame);
404 }
405 
406 void InspectorTimelineAgent::didPaint(RenderObject&amp; renderer, const LayoutRect&amp; clipRect)
407 {
408     TimelineRecordEntry&amp; entry = m_recordStack.last();
409     ASSERT(entry.type == TimelineRecordType::Paint);
410     FloatQuad quad;
411     localToPageQuad(renderer, clipRect, &amp;quad);
412     entry.data = TimelineRecordFactory::createPaintData(quad);
413     didCompleteCurrentRecord(TimelineRecordType::Paint);
414 }
415 
416 void InspectorTimelineAgent::didInstallTimer(int timerId, Seconds timeout, bool singleShot, Frame* frame)
417 {
</pre>
<hr />
<pre>
443     didCompleteCurrentRecord(TimelineRecordType::EvaluateScript);
444 }
445 
446 void InspectorTimelineAgent::didTimeStamp(Frame&amp; frame, const String&amp; message)
447 {
448     appendRecord(TimelineRecordFactory::createTimeStampData(message), TimelineRecordType::TimeStamp, true, &amp;frame);
449 }
450 
451 void InspectorTimelineAgent::time(Frame&amp; frame, const String&amp; message)
452 {
453     appendRecord(TimelineRecordFactory::createTimeStampData(message), TimelineRecordType::Time, true, &amp;frame);
454 }
455 
456 void InspectorTimelineAgent::timeEnd(Frame&amp; frame, const String&amp; message)
457 {
458     appendRecord(TimelineRecordFactory::createTimeStampData(message), TimelineRecordType::TimeEnd, true, &amp;frame);
459 }
460 
461 void InspectorTimelineAgent::mainFrameStartedLoading()
462 {
<span class="line-modified">463     if (m_tracking)</span>
464         return;
465 
466     if (!m_autoCaptureEnabled)
467         return;
468 
469     if (m_instruments.isEmpty())
470         return;
471 
472     m_autoCapturePhase = AutoCapturePhase::BeforeLoad;
473 
474     // Pre-emptively disable breakpoints. The frontend must re-enable them.
475     if (InspectorDebuggerAgent* debuggerAgent = m_instrumentingAgents.inspectorDebuggerAgent()) {
<span class="line-modified">476         ErrorString ignored;</span>
<span class="line-modified">477         debuggerAgent-&gt;setBreakpointsActive(ignored, false);</span>
478     }
479 
480     // Inform the frontend we started an auto capture. The frontend must stop capture.
481     m_frontendDispatcher-&gt;autoCaptureStarted();
482 
483     toggleInstruments(InstrumentState::Start);
484 }
485 
486 void InspectorTimelineAgent::mainFrameNavigated()
487 {
488     if (m_autoCapturePhase == AutoCapturePhase::BeforeLoad) {
489         m_autoCapturePhase = AutoCapturePhase::FirstNavigation;
490         toggleInstruments(InstrumentState::Start);
491         m_autoCapturePhase = AutoCapturePhase::AfterFirstNavigation;
492     }
493 }
494 
495 void InspectorTimelineAgent::startProgrammaticCapture()
496 {
<span class="line-modified">497     ASSERT(!m_tracking);</span>
498 
499     // Disable breakpoints during programmatic capture.
500     if (InspectorDebuggerAgent* debuggerAgent = m_instrumentingAgents.inspectorDebuggerAgent()) {
501         m_programmaticCaptureRestoreBreakpointActiveValue = debuggerAgent-&gt;breakpointsActive();
502         if (m_programmaticCaptureRestoreBreakpointActiveValue) {
<span class="line-modified">503             ErrorString ignored;</span>
<span class="line-modified">504             debuggerAgent-&gt;setBreakpointsActive(ignored, false);</span>
505         }
506     } else
507         m_programmaticCaptureRestoreBreakpointActiveValue = false;
508 


509     toggleScriptProfilerInstrument(InstrumentState::Start); // Ensure JavaScript samping data.
510     toggleTimelineInstrument(InstrumentState::Start); // Ensure Console Profile event records.
511     toggleInstruments(InstrumentState::Start); // Any other instruments the frontend wants us to record.
512 }
513 
514 void InspectorTimelineAgent::stopProgrammaticCapture()
515 {
<span class="line-modified">516     ASSERT(m_tracking);</span>
<span class="line-modified">517     ASSERT(!m_trackingFromFrontend);</span>
518 
519     toggleInstruments(InstrumentState::Stop);
520     toggleTimelineInstrument(InstrumentState::Stop);
521     toggleScriptProfilerInstrument(InstrumentState::Stop);
522 
523     // Re-enable breakpoints if they were enabled.
524     if (m_programmaticCaptureRestoreBreakpointActiveValue) {
525         if (InspectorDebuggerAgent* debuggerAgent = m_instrumentingAgents.inspectorDebuggerAgent()) {
<span class="line-modified">526             ErrorString ignored;</span>
<span class="line-modified">527             debuggerAgent-&gt;setBreakpointsActive(ignored, true);</span>
528         }
529     }


530 }
531 
532 void InspectorTimelineAgent::toggleInstruments(InstrumentState state)
533 {
534     for (auto instrumentType : m_instruments) {
535         switch (instrumentType) {
536         case Inspector::Protocol::Timeline::Instrument::ScriptProfiler: {
537             toggleScriptProfilerInstrument(state);
538             break;
539         }
540         case Inspector::Protocol::Timeline::Instrument::Heap: {
541             toggleHeapInstrument(state);
542             break;
543         }
544         case Inspector::Protocol::Timeline::Instrument::CPU: {
545             toggleCPUInstrument(state);
546             break;
547         }
548         case Inspector::Protocol::Timeline::Instrument::Memory: {
549             toggleMemoryInstrument(state);
550             break;
551         }
552         case Inspector::Protocol::Timeline::Instrument::Timeline:
553             toggleTimelineInstrument(state);
554             break;
555         }
556     }
557 }
558 
559 void InspectorTimelineAgent::toggleScriptProfilerInstrument(InstrumentState state)
560 {
<span class="line-modified">561     if (auto* scriptProfilerAgent = m_instrumentingAgents.inspectorScriptProfilerAgent()) {</span>
<span class="line-modified">562         ErrorString ignored;</span>
563         if (state == InstrumentState::Start) {
564             const bool includeSamples = true;
<span class="line-modified">565             scriptProfilerAgent-&gt;startTracking(ignored, &amp;includeSamples);</span>
566         } else
<span class="line-modified">567             scriptProfilerAgent-&gt;stopTracking(ignored);</span>
568     }
569 }
570 
571 void InspectorTimelineAgent::toggleHeapInstrument(InstrumentState state)
572 {
<span class="line-modified">573     if (auto* heapAgent = m_instrumentingAgents.pageHeapAgent()) {</span>
<span class="line-modified">574         ErrorString ignored;</span>
575         if (state == InstrumentState::Start) {
576             if (m_autoCapturePhase == AutoCapturePhase::None || m_autoCapturePhase == AutoCapturePhase::FirstNavigation)
<span class="line-modified">577                 heapAgent-&gt;startTracking(ignored);</span>
578         } else
<span class="line-modified">579             heapAgent-&gt;stopTracking(ignored);</span>
580     }
581 }
582 
583 void InspectorTimelineAgent::toggleCPUInstrument(InstrumentState state)
584 {
585 #if ENABLE(RESOURCE_USAGE)
586     if (InspectorCPUProfilerAgent* cpuProfilerAgent = m_instrumentingAgents.inspectorCPUProfilerAgent()) {
<span class="line-modified">587         ErrorString ignored;</span>
588         if (state == InstrumentState::Start)
<span class="line-modified">589             cpuProfilerAgent-&gt;startTracking(ignored);</span>
590         else
<span class="line-modified">591             cpuProfilerAgent-&gt;stopTracking(ignored);</span>
592     }
593 #else
594     UNUSED_PARAM(state);
595 #endif
596 }
597 
598 void InspectorTimelineAgent::toggleMemoryInstrument(InstrumentState state)
599 {
600 #if ENABLE(RESOURCE_USAGE)
601     if (InspectorMemoryAgent* memoryAgent = m_instrumentingAgents.inspectorMemoryAgent()) {
<span class="line-modified">602         ErrorString ignored;</span>
603         if (state == InstrumentState::Start)
<span class="line-modified">604             memoryAgent-&gt;startTracking(ignored);</span>
605         else
<span class="line-modified">606             memoryAgent-&gt;stopTracking(ignored);</span>
607     }
608 #else
609     UNUSED_PARAM(state);
610 #endif
611 }
612 
613 void InspectorTimelineAgent::toggleTimelineInstrument(InstrumentState state)
614 {
615     if (state == InstrumentState::Start)
616         internalStart();
617     else
618         internalStop();
619 }
620 





621 void InspectorTimelineAgent::didRequestAnimationFrame(int callbackId, Frame* frame)
622 {
623     appendRecord(TimelineRecordFactory::createAnimationFrameData(callbackId), TimelineRecordType::RequestAnimationFrame, true, frame);
624 }
625 
626 void InspectorTimelineAgent::didCancelAnimationFrame(int callbackId, Frame* frame)
627 {
628     appendRecord(TimelineRecordFactory::createAnimationFrameData(callbackId), TimelineRecordType::CancelAnimationFrame, true, frame);
629 }
630 
631 void InspectorTimelineAgent::willFireAnimationFrame(int callbackId, Frame* frame)
632 {
633     pushCurrentRecord(TimelineRecordFactory::createAnimationFrameData(callbackId), TimelineRecordType::FireAnimationFrame, false, frame);
634 }
635 
636 void InspectorTimelineAgent::didFireAnimationFrame()
637 {
638     didCompleteCurrentRecord(TimelineRecordType::FireAnimationFrame);
639 }
640 
</pre>
<hr />
<pre>
716 void InspectorTimelineAgent::addRecordToTimeline(RefPtr&lt;JSON::Object&gt;&amp;&amp; record, TimelineRecordType type)
717 {
718     ASSERT_ARG(record, record);
719     record-&gt;setString(&quot;type&quot;, Inspector::Protocol::InspectorHelpers::getEnumConstantValue(toProtocol(type)));
720 
721     if (m_recordStack.isEmpty()) {
722         auto recordObject = BindingTraits&lt;Inspector::Protocol::Timeline::TimelineEvent&gt;::runtimeCast(WTFMove(record));
723         sendEvent(WTFMove(recordObject));
724     } else {
725         const TimelineRecordEntry&amp; parent = m_recordStack.last();
726         // Nested paint records are an implementation detail and add no information not already contained in the parent.
727         if (type == TimelineRecordType::Paint &amp;&amp; parent.type == type)
728             return;
729 
730         parent.children-&gt;pushObject(WTFMove(record));
731     }
732 }
733 
734 void InspectorTimelineAgent::setFrameIdentifier(JSON::Object* record, Frame* frame)
735 {
<span class="line-modified">736     if (!frame)</span>
737         return;
<span class="line-modified">738 </span>
<span class="line-modified">739     auto* pageAgent = m_instrumentingAgents.inspectorPageAgent();</span>
<span class="line-modified">740     if (!pageAgent)</span>
<span class="line-modified">741         return;</span>
<span class="line-added">742 </span>
<span class="line-added">743     record-&gt;setString(&quot;frameId&quot;_s, pageAgent-&gt;frameId(frame));</span>
744 }
745 
746 void InspectorTimelineAgent::didCompleteRecordEntry(const TimelineRecordEntry&amp; entry)
747 {
748     entry.record-&gt;setObject(&quot;data&quot;_s, entry.data);
749     entry.record-&gt;setArray(&quot;children&quot;_s, entry.children);
750     entry.record-&gt;setDouble(&quot;endTime&quot;_s, timestamp());
751     addRecordToTimeline(entry.record.copyRef(), entry.type);
752 }
753 
754 void InspectorTimelineAgent::didCompleteCurrentRecord(TimelineRecordType type)
755 {
756     // An empty stack could merely mean that the timeline agent was turned on in the middle of
757     // an event.  Don&#39;t treat as an error.
758     if (!m_recordStack.isEmpty()) {
759         TimelineRecordEntry entry = m_recordStack.last();
760         m_recordStack.removeLast();
761         ASSERT_UNUSED(type, entry.type == type);
762 
763         // Don&#39;t send RenderingFrame records that have no children to reduce noise.
</pre>
</td>
</tr>
</table>
<center><a href="InspectorPageAgent.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="InspectorTimelineAgent.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>