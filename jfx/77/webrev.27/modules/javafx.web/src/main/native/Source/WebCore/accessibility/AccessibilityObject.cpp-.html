<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WebCore/accessibility/AccessibilityObject.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2008-2009, 2011, 2017 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  *
   8  * 1.  Redistributions of source code must retain the above copyright
   9  *     notice, this list of conditions and the following disclaimer.
  10  * 2.  Redistributions in binary form must reproduce the above copyright
  11  *     notice, this list of conditions and the following disclaimer in the
  12  *     documentation and/or other materials provided with the distribution.
  13  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
  14  *     its contributors may be used to endorse or promote products derived
  15  *     from this software without specific prior written permission.
  16  *
  17  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
  18  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  19  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  20  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  21  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  22  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  23  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  24  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  25  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  26  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  27  */
  28 
  29 #include &quot;config.h&quot;
  30 #include &quot;AccessibilityObject.h&quot;
  31 
  32 #include &quot;AXObjectCache.h&quot;
  33 #include &quot;AccessibilityRenderObject.h&quot;
  34 #include &quot;AccessibilityScrollView.h&quot;
  35 #include &quot;AccessibilityTable.h&quot;
  36 #include &quot;AccessibleSetValueEvent.h&quot;
  37 #include &quot;DOMTokenList.h&quot;
  38 #include &quot;Editing.h&quot;
  39 #include &quot;Editor.h&quot;
  40 #include &quot;ElementIterator.h&quot;
  41 #include &quot;Event.h&quot;
  42 #include &quot;EventDispatcher.h&quot;
  43 #include &quot;EventHandler.h&quot;
  44 #include &quot;FloatRect.h&quot;
  45 #include &quot;FocusController.h&quot;
  46 #include &quot;Frame.h&quot;
  47 #include &quot;FrameLoader.h&quot;
  48 #include &quot;FrameSelection.h&quot;
  49 #include &quot;HTMLDetailsElement.h&quot;
  50 #include &quot;HTMLFormControlElement.h&quot;
  51 #include &quot;HTMLInputElement.h&quot;
  52 #include &quot;HTMLMediaElement.h&quot;
  53 #include &quot;HTMLNames.h&quot;
  54 #include &quot;HTMLParserIdioms.h&quot;
  55 #include &quot;HitTestResult.h&quot;
  56 #include &quot;LocalizedStrings.h&quot;
  57 #include &quot;MathMLNames.h&quot;
  58 #include &quot;NodeList.h&quot;
  59 #include &quot;NodeTraversal.h&quot;
  60 #include &quot;Page.h&quot;
  61 #include &quot;RenderImage.h&quot;
  62 #include &quot;RenderLayer.h&quot;
  63 #include &quot;RenderListItem.h&quot;
  64 #include &quot;RenderListMarker.h&quot;
  65 #include &quot;RenderMenuList.h&quot;
  66 #include &quot;RenderText.h&quot;
  67 #include &quot;RenderTextControl.h&quot;
  68 #include &quot;RenderTheme.h&quot;
  69 #include &quot;RenderView.h&quot;
  70 #include &quot;RenderWidget.h&quot;
  71 #include &quot;RenderedPosition.h&quot;
  72 #include &quot;RuntimeEnabledFeatures.h&quot;
  73 #include &quot;Settings.h&quot;
  74 #include &quot;TextCheckerClient.h&quot;
  75 #include &quot;TextCheckingHelper.h&quot;
  76 #include &quot;TextIterator.h&quot;
  77 #include &quot;UserGestureIndicator.h&quot;
  78 #include &quot;VisibleUnits.h&quot;
  79 #include &lt;wtf/NeverDestroyed.h&gt;
  80 #include &lt;wtf/StdLibExtras.h&gt;
  81 #include &lt;wtf/text/StringBuilder.h&gt;
  82 #include &lt;wtf/text/StringView.h&gt;
  83 #include &lt;wtf/text/WTFString.h&gt;
  84 #include &lt;wtf/unicode/CharacterNames.h&gt;
  85 
  86 namespace WebCore {
  87 
  88 using namespace HTMLNames;
  89 
  90 AccessibilityObject::~AccessibilityObject()
  91 {
  92     ASSERT(isDetached());
  93 }
  94 
  95 void AccessibilityObject::detach(AccessibilityDetachmentType detachmentType, AXObjectCache* cache)
  96 {
  97     // Menu close events need to notify the platform. No element is used in the notification because it&#39;s a destruction event.
  98     if (detachmentType == AccessibilityDetachmentType::ElementDestroyed &amp;&amp; roleValue() == AccessibilityRole::Menu &amp;&amp; cache)
  99         cache-&gt;postNotification(nullptr, &amp;cache-&gt;document(), AXObjectCache::AXMenuClosed);
 100 
 101     // Clear any children and call detachFromParent on them so that
 102     // no children are left with dangling pointers to their parent.
 103     clearChildren();
 104 
 105 #if HAVE(ACCESSIBILITY)
 106     setWrapper(nullptr);
 107 #endif
 108 }
 109 
 110 bool AccessibilityObject::isDetached() const
 111 {
 112 #if HAVE(ACCESSIBILITY)
 113     return !wrapper();
 114 #else
 115     return true;
 116 #endif
 117 }
 118 
 119 bool AccessibilityObject::isAccessibilityObjectSearchMatchAtIndex(AccessibilityObject* axObject, AccessibilitySearchCriteria* criteria, size_t index)
 120 {
 121     switch (criteria-&gt;searchKeys[index]) {
 122     // The AccessibilitySearchKey::AnyType matches any non-null AccessibilityObject.
 123     case AccessibilitySearchKey::AnyType:
 124         return true;
 125 
 126     case AccessibilitySearchKey::Article:
 127         return axObject-&gt;roleValue() == AccessibilityRole::DocumentArticle;
 128 
 129     case AccessibilitySearchKey::BlockquoteSameLevel:
 130         return criteria-&gt;startObject
 131             &amp;&amp; axObject-&gt;isBlockquote()
 132             &amp;&amp; axObject-&gt;blockquoteLevel() == criteria-&gt;startObject-&gt;blockquoteLevel();
 133 
 134     case AccessibilitySearchKey::Blockquote:
 135         return axObject-&gt;isBlockquote();
 136 
 137     case AccessibilitySearchKey::BoldFont:
 138         return axObject-&gt;hasBoldFont();
 139 
 140     case AccessibilitySearchKey::Button:
 141         return axObject-&gt;isButton();
 142 
 143     case AccessibilitySearchKey::CheckBox:
 144         return axObject-&gt;isCheckbox();
 145 
 146     case AccessibilitySearchKey::Control:
 147         return axObject-&gt;isControl();
 148 
 149     case AccessibilitySearchKey::DifferentType:
 150         return criteria-&gt;startObject
 151             &amp;&amp; axObject-&gt;roleValue() != criteria-&gt;startObject-&gt;roleValue();
 152 
 153     case AccessibilitySearchKey::FontChange:
 154         return criteria-&gt;startObject
 155             &amp;&amp; !axObject-&gt;hasSameFont(criteria-&gt;startObject-&gt;renderer());
 156 
 157     case AccessibilitySearchKey::FontColorChange:
 158         return criteria-&gt;startObject
 159             &amp;&amp; !axObject-&gt;hasSameFontColor(criteria-&gt;startObject-&gt;renderer());
 160 
 161     case AccessibilitySearchKey::Frame:
 162         return axObject-&gt;isWebArea();
 163 
 164     case AccessibilitySearchKey::Graphic:
 165         return axObject-&gt;isImage();
 166 
 167     case AccessibilitySearchKey::HeadingLevel1:
 168         return axObject-&gt;headingLevel() == 1;
 169 
 170     case AccessibilitySearchKey::HeadingLevel2:
 171         return axObject-&gt;headingLevel() == 2;
 172 
 173     case AccessibilitySearchKey::HeadingLevel3:
 174         return axObject-&gt;headingLevel() == 3;
 175 
 176     case AccessibilitySearchKey::HeadingLevel4:
 177         return axObject-&gt;headingLevel() == 4;
 178 
 179     case AccessibilitySearchKey::HeadingLevel5:
 180         return axObject-&gt;headingLevel() == 5;
 181 
 182     case AccessibilitySearchKey::HeadingLevel6:
 183         return axObject-&gt;headingLevel() == 6;
 184 
 185     case AccessibilitySearchKey::HeadingSameLevel:
 186         return criteria-&gt;startObject
 187             &amp;&amp; axObject-&gt;isHeading()
 188             &amp;&amp; axObject-&gt;headingLevel() == criteria-&gt;startObject-&gt;headingLevel();
 189 
 190     case AccessibilitySearchKey::Heading:
 191         return axObject-&gt;isHeading();
 192 
 193     case AccessibilitySearchKey::Highlighted:
 194         return axObject-&gt;hasHighlighting();
 195 
 196     case AccessibilitySearchKey::ItalicFont:
 197         return axObject-&gt;hasItalicFont();
 198 
 199     case AccessibilitySearchKey::Landmark:
 200         return axObject-&gt;isLandmark();
 201 
 202     case AccessibilitySearchKey::Link: {
 203         bool isLink = axObject-&gt;isLink();
 204 #if PLATFORM(IOS_FAMILY)
 205         if (!isLink)
 206             isLink = axObject-&gt;isDescendantOfRole(AccessibilityRole::WebCoreLink);
 207 #endif
 208         return isLink;
 209     }
 210 
 211     case AccessibilitySearchKey::List:
 212         return axObject-&gt;isList();
 213 
 214     case AccessibilitySearchKey::LiveRegion:
 215         return axObject-&gt;supportsLiveRegion();
 216 
 217     case AccessibilitySearchKey::MisspelledWord:
 218         return axObject-&gt;hasMisspelling();
 219 
 220     case AccessibilitySearchKey::Outline:
 221         return axObject-&gt;isTree();
 222 
 223     case AccessibilitySearchKey::PlainText:
 224         return axObject-&gt;hasPlainText();
 225 
 226     case AccessibilitySearchKey::RadioGroup:
 227         return axObject-&gt;isRadioGroup();
 228 
 229     case AccessibilitySearchKey::SameType:
 230         return criteria-&gt;startObject
 231             &amp;&amp; axObject-&gt;roleValue() == criteria-&gt;startObject-&gt;roleValue();
 232 
 233     case AccessibilitySearchKey::StaticText:
 234         return axObject-&gt;isStaticText();
 235 
 236     case AccessibilitySearchKey::StyleChange:
 237         return criteria-&gt;startObject
 238             &amp;&amp; !axObject-&gt;hasSameStyle(criteria-&gt;startObject-&gt;renderer());
 239 
 240     case AccessibilitySearchKey::TableSameLevel:
 241         return criteria-&gt;startObject
 242             &amp;&amp; is&lt;AccessibilityTable&gt;(*axObject) &amp;&amp; downcast&lt;AccessibilityTable&gt;(*axObject).isExposableThroughAccessibility()
 243             &amp;&amp; downcast&lt;AccessibilityTable&gt;(*axObject).tableLevel() == criteria-&gt;startObject-&gt;tableLevel();
 244 
 245     case AccessibilitySearchKey::Table:
 246         return is&lt;AccessibilityTable&gt;(*axObject) &amp;&amp; downcast&lt;AccessibilityTable&gt;(*axObject).isExposableThroughAccessibility();
 247 
 248     case AccessibilitySearchKey::TextField:
 249         return axObject-&gt;isTextControl();
 250 
 251     case AccessibilitySearchKey::Underline:
 252         return axObject-&gt;hasUnderline();
 253 
 254     case AccessibilitySearchKey::UnvisitedLink:
 255         return axObject-&gt;isUnvisited();
 256 
 257     case AccessibilitySearchKey::VisitedLink:
 258         return axObject-&gt;isVisited();
 259 
 260     default:
 261         return false;
 262     }
 263 }
 264 
 265 bool AccessibilityObject::isAccessibilityObjectSearchMatch(AccessibilityObject* axObject, AccessibilitySearchCriteria* criteria)
 266 {
 267     if (!axObject || !criteria)
 268         return false;
 269 
 270     size_t length = criteria-&gt;searchKeys.size();
 271     for (size_t i = 0; i &lt; length; ++i) {
 272         if (isAccessibilityObjectSearchMatchAtIndex(axObject, criteria, i)) {
 273             if (criteria-&gt;visibleOnly &amp;&amp; !axObject-&gt;isOnscreen())
 274                 return false;
 275             return true;
 276         }
 277     }
 278     return false;
 279 }
 280 
 281 bool AccessibilityObject::isAccessibilityTextSearchMatch(AccessibilityObject* axObject, AccessibilitySearchCriteria* criteria)
 282 {
 283     if (!axObject || !criteria)
 284         return false;
 285 
 286     return axObject-&gt;accessibilityObjectContainsText(&amp;criteria-&gt;searchText);
 287 }
 288 
 289 bool AccessibilityObject::accessibilityObjectContainsText(String* text) const
 290 {
 291     // If text is null or empty we return true.
 292     return !text
 293         || text-&gt;isEmpty()
 294         || findPlainText(title(), *text, CaseInsensitive)
 295         || findPlainText(accessibilityDescription(), *text, CaseInsensitive)
 296         || findPlainText(stringValue(), *text, CaseInsensitive);
 297 }
 298 
 299 // ARIA marks elements as having their accessible name derive from either their contents, or their author provide name.
 300 bool AccessibilityObject::accessibleNameDerivesFromContent() const
 301 {
 302     // First check for objects specifically identified by ARIA.
 303     switch (ariaRoleAttribute()) {
 304     case AccessibilityRole::ApplicationAlert:
 305     case AccessibilityRole::ApplicationAlertDialog:
 306     case AccessibilityRole::ApplicationDialog:
 307     case AccessibilityRole::ApplicationGroup:
 308     case AccessibilityRole::ApplicationLog:
 309     case AccessibilityRole::ApplicationMarquee:
 310     case AccessibilityRole::ApplicationStatus:
 311     case AccessibilityRole::ApplicationTimer:
 312     case AccessibilityRole::ComboBox:
 313     case AccessibilityRole::Definition:
 314     case AccessibilityRole::Document:
 315     case AccessibilityRole::DocumentArticle:
 316     case AccessibilityRole::DocumentMath:
 317     case AccessibilityRole::DocumentNote:
 318     case AccessibilityRole::LandmarkRegion:
 319     case AccessibilityRole::LandmarkDocRegion:
 320     case AccessibilityRole::Form:
 321     case AccessibilityRole::Grid:
 322     case AccessibilityRole::Group:
 323     case AccessibilityRole::Image:
 324     case AccessibilityRole::List:
 325     case AccessibilityRole::ListBox:
 326     case AccessibilityRole::LandmarkBanner:
 327     case AccessibilityRole::LandmarkComplementary:
 328     case AccessibilityRole::LandmarkContentInfo:
 329     case AccessibilityRole::LandmarkNavigation:
 330     case AccessibilityRole::LandmarkMain:
 331     case AccessibilityRole::LandmarkSearch:
 332     case AccessibilityRole::Menu:
 333     case AccessibilityRole::MenuBar:
 334     case AccessibilityRole::ProgressIndicator:
 335     case AccessibilityRole::RadioGroup:
 336     case AccessibilityRole::ScrollBar:
 337     case AccessibilityRole::Slider:
 338     case AccessibilityRole::SpinButton:
 339     case AccessibilityRole::Splitter:
 340     case AccessibilityRole::Table:
 341     case AccessibilityRole::TabList:
 342     case AccessibilityRole::TabPanel:
 343     case AccessibilityRole::TextArea:
 344     case AccessibilityRole::TextField:
 345     case AccessibilityRole::Toolbar:
 346     case AccessibilityRole::TreeGrid:
 347     case AccessibilityRole::Tree:
 348     case AccessibilityRole::WebApplication:
 349         return false;
 350     default:
 351         break;
 352     }
 353 
 354     // Now check for generically derived elements now that we know the element does not match a specific ARIA role.
 355     switch (roleValue()) {
 356     case AccessibilityRole::Slider:
 357     case AccessibilityRole::ListBox:
 358         return false;
 359     default:
 360         break;
 361     }
 362 
 363     return true;
 364 }
 365 
 366 String AccessibilityObject::computedLabel()
 367 {
 368     // This method is being called by WebKit inspector, which may happen at any time, so we need to update our backing store now.
 369     // Also hold onto this object in case updateBackingStore deletes this node.
 370     RefPtr&lt;AccessibilityObject&gt; protectedThis(this);
 371     updateBackingStore();
 372     Vector&lt;AccessibilityText&gt; text;
 373     accessibilityText(text);
 374     if (text.size())
 375         return text[0].text;
 376     return String();
 377 }
 378 
 379 bool AccessibilityObject::isBlockquote() const
 380 {
 381     return roleValue() == AccessibilityRole::Blockquote;
 382 }
 383 
 384 bool AccessibilityObject::isTextControl() const
 385 {
 386     switch (roleValue()) {
 387     case AccessibilityRole::ComboBox:
 388     case AccessibilityRole::SearchField:
 389     case AccessibilityRole::TextArea:
 390     case AccessibilityRole::TextField:
 391         return true;
 392     default:
 393         return false;
 394     }
 395 }
 396 
 397 bool AccessibilityObject::isARIATextControl() const
 398 {
 399     return ariaRoleAttribute() == AccessibilityRole::TextArea || ariaRoleAttribute() == AccessibilityRole::TextField || ariaRoleAttribute() == AccessibilityRole::SearchField;
 400 }
 401 
 402 bool AccessibilityObject::isNonNativeTextControl() const
 403 {
 404     return (isARIATextControl() || hasContentEditableAttributeSet()) &amp;&amp; !isNativeTextControl();
 405 }
 406 
 407 bool AccessibilityObject::isLandmark() const
 408 {
 409     AccessibilityRole role = roleValue();
 410 
 411     return role == AccessibilityRole::LandmarkBanner
 412         || role == AccessibilityRole::LandmarkComplementary
 413         || role == AccessibilityRole::LandmarkContentInfo
 414         || role == AccessibilityRole::LandmarkDocRegion
 415         || role == AccessibilityRole::LandmarkMain
 416         || role == AccessibilityRole::LandmarkNavigation
 417         || role == AccessibilityRole::LandmarkRegion
 418         || role == AccessibilityRole::LandmarkSearch;
 419 }
 420 
 421 bool AccessibilityObject::hasMisspelling() const
 422 {
 423     if (!node())
 424         return false;
 425 
 426     Frame* frame = node()-&gt;document().frame();
 427     if (!frame)
 428         return false;
 429 
 430     Editor&amp; editor = frame-&gt;editor();
 431 
 432     TextCheckerClient* textChecker = editor.textChecker();
 433     if (!textChecker)
 434         return false;
 435 
 436     bool isMisspelled = false;
 437 
 438     if (unifiedTextCheckerEnabled(frame)) {
 439         Vector&lt;TextCheckingResult&gt; results;
 440         checkTextOfParagraph(*textChecker, stringValue(), TextCheckingType::Spelling, results, frame-&gt;selection().selection());
 441         if (!results.isEmpty())
 442             isMisspelled = true;
 443         return isMisspelled;
 444     }
 445 
 446     int misspellingLength = 0;
 447     int misspellingLocation = -1;
 448     textChecker-&gt;checkSpellingOfString(stringValue(), &amp;misspellingLocation, &amp;misspellingLength);
 449     if (misspellingLength || misspellingLocation != -1)
 450         isMisspelled = true;
 451 
 452     return isMisspelled;
 453 }
 454 
 455 unsigned AccessibilityObject::blockquoteLevel() const
 456 {
 457     unsigned level = 0;
 458     for (Node* elementNode = node(); elementNode; elementNode = elementNode-&gt;parentNode()) {
 459         if (elementNode-&gt;hasTagName(blockquoteTag))
 460             ++level;
 461     }
 462 
 463     return level;
 464 }
 465 
 466 AccessibilityObject* AccessibilityObject::parentObjectUnignored() const
 467 {
 468     return const_cast&lt;AccessibilityObject*&gt;(AccessibilityObject::matchedParent(*this, false, [] (const AccessibilityObject&amp; object) {
 469         return !object.accessibilityIsIgnored();
 470     }));
 471 }
 472 
 473 AccessibilityObject* AccessibilityObject::previousSiblingUnignored(int limit) const
 474 {
 475     AccessibilityObject* previous;
 476     ASSERT(limit &gt;= 0);
 477     for (previous = previousSibling(); previous &amp;&amp; previous-&gt;accessibilityIsIgnored(); previous = previous-&gt;previousSibling()) {
 478         limit--;
 479         if (limit &lt;= 0)
 480             break;
 481     }
 482     return previous;
 483 }
 484 
 485 AccessibilityObject* AccessibilityObject::nextSiblingUnignored(int limit) const
 486 {
 487     AccessibilityObject* next;
 488     ASSERT(limit &gt;= 0);
 489     for (next = nextSibling(); next &amp;&amp; next-&gt;accessibilityIsIgnored(); next = next-&gt;nextSibling()) {
 490         limit--;
 491         if (limit &lt;= 0)
 492             break;
 493     }
 494     return next;
 495 }
 496 
 497 AccessibilityObject* AccessibilityObject::firstAccessibleObjectFromNode(const Node* node)
 498 {
 499     if (!node)
 500         return nullptr;
 501 
 502     AXObjectCache* cache = node-&gt;document().axObjectCache();
 503     if (!cache)
 504         return nullptr;
 505 
 506     AccessibilityObject* accessibleObject = cache-&gt;getOrCreate(node-&gt;renderer());
 507     while (accessibleObject &amp;&amp; accessibleObject-&gt;accessibilityIsIgnored()) {
 508         node = NodeTraversal::next(*node);
 509 
 510         while (node &amp;&amp; !node-&gt;renderer())
 511             node = NodeTraversal::nextSkippingChildren(*node);
 512 
 513         if (!node)
 514             return nullptr;
 515 
 516         accessibleObject = cache-&gt;getOrCreate(node-&gt;renderer());
 517     }
 518 
 519     return accessibleObject;
 520 }
 521 
 522 bool AccessibilityObject::isDescendantOfRole(AccessibilityRole role) const
 523 {
 524     return AccessibilityObject::matchedParent(*this, false, [&amp;role] (const AccessibilityObject&amp; object) {
 525         return object.roleValue() == role;
 526     }) != nullptr;
 527 }
 528 
 529 static void appendAccessibilityObject(AccessibilityObject* object, AccessibilityObject::AccessibilityChildrenVector&amp; results)
 530 {
 531     // Find the next descendant of this attachment object so search can continue through frames.
 532     if (object-&gt;isAttachment()) {
 533         Widget* widget = object-&gt;widgetForAttachmentView();
 534         if (!is&lt;FrameView&gt;(widget))
 535             return;
 536 
 537         Document* document = downcast&lt;FrameView&gt;(*widget).frame().document();
 538         if (!document || !document-&gt;hasLivingRenderTree())
 539             return;
 540 
 541         object = object-&gt;axObjectCache()-&gt;getOrCreate(document);
 542     }
 543 
 544     if (object)
 545         results.append(object);
 546 }
 547 
 548 void AccessibilityObject::insertChild(AccessibilityObject* child, unsigned index)
 549 {
 550     if (!child)
 551         return;
 552 
 553     // If the parent is asking for this child&#39;s children, then either it&#39;s the first time (and clearing is a no-op),
 554     // or its visibility has changed. In the latter case, this child may have a stale child cached.
 555     // This can prevent aria-hidden changes from working correctly. Hence, whenever a parent is getting children, ensure data is not stale.
 556     // Only clear the child&#39;s children when we know it&#39;s in the updating chain in order to avoid unnecessary work.
 557     if (child-&gt;needsToUpdateChildren() || m_subtreeDirty) {
 558         child-&gt;clearChildren();
 559         // Pass m_subtreeDirty flag down to the child so that children cache gets reset properly.
 560         if (m_subtreeDirty)
 561             child-&gt;setNeedsToUpdateSubtree();
 562     } else {
 563         // For some reason the grand children might be detached so that we need to regenerate the
 564         // children list of this child.
 565         for (const auto&amp; grandChild : child-&gt;children(false)) {
 566             if (grandChild-&gt;isDetachedFromParent()) {
 567                 child-&gt;clearChildren();
 568                 break;
 569             }
 570         }
 571     }
 572 
 573     setIsIgnoredFromParentDataForChild(child);
 574     if (child-&gt;accessibilityIsIgnored()) {
 575         const auto&amp; children = child-&gt;children();
 576         size_t length = children.size();
 577         for (size_t i = 0; i &lt; length; ++i)
 578             m_children.insert(index + i, children[i]);
 579     } else {
 580         ASSERT(child-&gt;parentObject() == this);
 581         m_children.insert(index, child);
 582     }
 583 
 584     // Reset the child&#39;s m_isIgnoredFromParentData since we are done adding that child and its children.
 585     child-&gt;clearIsIgnoredFromParentData();
 586 }
 587 
 588 void AccessibilityObject::addChild(AccessibilityObject* child)
 589 {
 590     insertChild(child, m_children.size());
 591 }
 592 
 593 static void appendChildrenToArray(AccessibilityObject* object, bool isForward, AccessibilityObject* startObject, AccessibilityObject::AccessibilityChildrenVector&amp; results)
 594 {
 595     // A table&#39;s children includes elements whose own children are also the table&#39;s children (due to the way the Mac exposes tables).
 596     // The rows from the table should be queried, since those are direct descendants of the table, and they contain content.
 597     const auto&amp; searchChildren = is&lt;AccessibilityTable&gt;(*object) &amp;&amp; downcast&lt;AccessibilityTable&gt;(*object).isExposableThroughAccessibility() ? downcast&lt;AccessibilityTable&gt;(*object).rows() : object-&gt;children();
 598 
 599     size_t childrenSize = searchChildren.size();
 600 
 601     size_t startIndex = isForward ? childrenSize : 0;
 602     size_t endIndex = isForward ? 0 : childrenSize;
 603 
 604     // If the startObject is ignored, we should use an accessible sibling as a start element instead.
 605     if (startObject &amp;&amp; startObject-&gt;accessibilityIsIgnored() &amp;&amp; startObject-&gt;isDescendantOfObject(object)) {
 606         AccessibilityObject* parentObject = startObject-&gt;parentObject();
 607         // Go up the parent chain to find the highest ancestor that&#39;s also being ignored.
 608         while (parentObject &amp;&amp; parentObject-&gt;accessibilityIsIgnored()) {
 609             if (parentObject == object)
 610                 break;
 611             startObject = parentObject;
 612             parentObject = parentObject-&gt;parentObject();
 613         }
 614         // Get the un-ignored sibling based on the search direction, and update the searchPosition.
 615         while (startObject &amp;&amp; startObject-&gt;accessibilityIsIgnored())
 616             startObject = isForward ? startObject-&gt;previousSibling() : startObject-&gt;nextSibling();
 617     }
 618 
 619     size_t searchPosition = startObject ? searchChildren.find(startObject) : WTF::notFound;
 620 
 621     if (searchPosition != WTF::notFound) {
 622         if (isForward)
 623             endIndex = searchPosition + 1;
 624         else
 625             endIndex = searchPosition;
 626     }
 627 
 628     // This is broken into two statements so that it&#39;s easier read.
 629     if (isForward) {
 630         for (size_t i = startIndex; i &gt; endIndex; i--)
 631             appendAccessibilityObject(searchChildren.at(i - 1).get(), results);
 632     } else {
 633         for (size_t i = startIndex; i &lt; endIndex; i++)
 634             appendAccessibilityObject(searchChildren.at(i).get(), results);
 635     }
 636 }
 637 
 638 // Returns true if the number of results is now &gt;= the number of results desired.
 639 bool AccessibilityObject::objectMatchesSearchCriteriaWithResultLimit(AccessibilityObject* object, AccessibilitySearchCriteria* criteria, AccessibilityChildrenVector&amp; results)
 640 {
 641     if (isAccessibilityObjectSearchMatch(object, criteria) &amp;&amp; isAccessibilityTextSearchMatch(object, criteria)) {
 642         results.append(object);
 643 
 644         // Enough results were found to stop searching.
 645         if (results.size() &gt;= criteria-&gt;resultsLimit)
 646             return true;
 647     }
 648 
 649     return false;
 650 }
 651 
 652 void AccessibilityObject::findMatchingObjects(AccessibilitySearchCriteria* criteria, AccessibilityChildrenVector&amp; results)
 653 {
 654     ASSERT(criteria);
 655 
 656     if (!criteria)
 657         return;
 658 
 659     if (AXObjectCache* cache = axObjectCache())
 660         cache-&gt;startCachingComputedObjectAttributesUntilTreeMutates();
 661 
 662     // This search mechanism only searches the elements before/after the starting object.
 663     // It does this by stepping up the parent chain and at each level doing a DFS.
 664 
 665     // If there&#39;s no start object, it means we want to search everything.
 666     AccessibilityObject* startObject = criteria-&gt;startObject;
 667     if (!startObject)
 668         startObject = this;
 669 
 670     bool isForward = criteria-&gt;searchDirection == AccessibilitySearchDirection::Next;
 671 
 672     // The first iteration of the outer loop will examine the children of the start object for matches. However, when
 673     // iterating backwards, the start object children should not be considered, so the loop is skipped ahead. We make an
 674     // exception when no start object was specified because we want to search everything regardless of search direction.
 675     AccessibilityObject* previousObject = nullptr;
 676     if (!isForward &amp;&amp; startObject != this) {
 677         previousObject = startObject;
 678         startObject = startObject-&gt;parentObjectUnignored();
 679     }
 680 
 681     // The outer loop steps up the parent chain each time (unignored is important here because otherwise elements would be searched twice)
 682     for (AccessibilityObject* stopSearchElement = parentObjectUnignored(); startObject &amp;&amp; startObject != stopSearchElement; startObject = startObject-&gt;parentObjectUnignored()) {
 683 
 684         // Only append the children after/before the previous element, so that the search does not check elements that are
 685         // already behind/ahead of start element.
 686         AccessibilityChildrenVector searchStack;
 687         if (!criteria-&gt;immediateDescendantsOnly || startObject == this)
 688             appendChildrenToArray(startObject, isForward, previousObject, searchStack);
 689 
 690         // This now does a DFS at the current level of the parent.
 691         while (!searchStack.isEmpty()) {
 692             AccessibilityObject* searchObject = searchStack.last().get();
 693             searchStack.removeLast();
 694 
 695             if (objectMatchesSearchCriteriaWithResultLimit(searchObject, criteria, results))
 696                 break;
 697 
 698             if (!criteria-&gt;immediateDescendantsOnly)
 699                 appendChildrenToArray(searchObject, isForward, 0, searchStack);
 700         }
 701 
 702         if (results.size() &gt;= criteria-&gt;resultsLimit)
 703             break;
 704 
 705         // When moving backwards, the parent object needs to be checked, because technically it&#39;s &quot;before&quot; the starting element.
 706         if (!isForward &amp;&amp; startObject != this &amp;&amp; objectMatchesSearchCriteriaWithResultLimit(startObject, criteria, results))
 707             break;
 708 
 709         previousObject = startObject;
 710     }
 711 }
 712 
 713 // Returns the range that is fewer positions away from the reference range.
 714 // NOTE: The after range is expected to ACTUALLY be after the reference range and the before
 715 // range is expected to ACTUALLY be before. These are not checked for performance reasons.
 716 static RefPtr&lt;Range&gt; rangeClosestToRange(Range* referenceRange, RefPtr&lt;Range&gt;&amp;&amp; afterRange, RefPtr&lt;Range&gt;&amp;&amp; beforeRange)
 717 {
 718     if (!referenceRange)
 719         return nullptr;
 720 
 721     // The treeScope for shadow nodes may not be the same scope as another element in a document.
 722     // Comparisons may fail in that case, which are expected behavior and should not assert.
 723     if (afterRange &amp;&amp; (referenceRange-&gt;endPosition().isNull() || ((afterRange-&gt;startPosition().anchorNode()-&gt;compareDocumentPosition(*referenceRange-&gt;endPosition().anchorNode()) &amp; Node::DOCUMENT_POSITION_DISCONNECTED) == Node::DOCUMENT_POSITION_DISCONNECTED)))
 724         return nullptr;
 725     ASSERT(!afterRange || afterRange-&gt;startPosition() &gt;= referenceRange-&gt;endPosition());
 726 
 727     if (beforeRange &amp;&amp; (referenceRange-&gt;startPosition().isNull() || ((beforeRange-&gt;endPosition().anchorNode()-&gt;compareDocumentPosition(*referenceRange-&gt;startPosition().anchorNode()) &amp; Node::DOCUMENT_POSITION_DISCONNECTED) == Node::DOCUMENT_POSITION_DISCONNECTED)))
 728         return nullptr;
 729     ASSERT(!beforeRange || beforeRange-&gt;endPosition() &lt;= referenceRange-&gt;startPosition());
 730 
 731     if (!afterRange &amp;&amp; !beforeRange)
 732         return nullptr;
 733     if (afterRange &amp;&amp; !beforeRange)
 734         return WTFMove(afterRange);
 735     if (!afterRange &amp;&amp; beforeRange)
 736         return WTFMove(beforeRange);
 737 
 738     unsigned positionsToAfterRange = Position::positionCountBetweenPositions(afterRange-&gt;startPosition(), referenceRange-&gt;endPosition());
 739     unsigned positionsToBeforeRange = Position::positionCountBetweenPositions(beforeRange-&gt;endPosition(), referenceRange-&gt;startPosition());
 740 
 741     return positionsToAfterRange &lt; positionsToBeforeRange ? afterRange : beforeRange;
 742 }
 743 
 744 RefPtr&lt;Range&gt; AccessibilityObject::rangeOfStringClosestToRangeInDirection(Range* referenceRange, AccessibilitySearchDirection searchDirection, Vector&lt;String&gt;&amp; searchStrings) const
 745 {
 746     Frame* frame = this-&gt;frame();
 747     if (!frame)
 748         return nullptr;
 749 
 750     if (!referenceRange)
 751         return nullptr;
 752 
 753     bool isBackwardSearch = searchDirection == AccessibilitySearchDirection::Previous;
 754     FindOptions findOptions { AtWordStarts, AtWordEnds, CaseInsensitive, StartInSelection };
 755     if (isBackwardSearch)
 756         findOptions.add(Backwards);
 757 
 758     RefPtr&lt;Range&gt; closestStringRange = nullptr;
 759     for (const auto&amp; searchString : searchStrings) {
 760         if (RefPtr&lt;Range&gt; searchStringRange = frame-&gt;editor().rangeOfString(searchString, referenceRange, findOptions)) {
 761             if (!closestStringRange)
 762                 closestStringRange = searchStringRange;
 763             else {
 764                 // If searching backward, use the trailing range edges to correctly determine which
 765                 // range is closest. Similarly, if searching forward, use the leading range edges.
 766                 Position closestStringPosition = isBackwardSearch ? closestStringRange-&gt;endPosition() : closestStringRange-&gt;startPosition();
 767                 Position searchStringPosition = isBackwardSearch ? searchStringRange-&gt;endPosition() : searchStringRange-&gt;startPosition();
 768 
 769                 int closestPositionOffset = closestStringPosition.computeOffsetInContainerNode();
 770                 int searchPositionOffset = searchStringPosition.computeOffsetInContainerNode();
 771                 Node* closestContainerNode = closestStringPosition.containerNode();
 772                 Node* searchContainerNode = searchStringPosition.containerNode();
 773 
 774                 short result = Range::compareBoundaryPoints(closestContainerNode, closestPositionOffset, searchContainerNode, searchPositionOffset).releaseReturnValue();
 775                 if ((!isBackwardSearch &amp;&amp; result &gt; 0) || (isBackwardSearch &amp;&amp; result &lt; 0))
 776                     closestStringRange = searchStringRange;
 777             }
 778         }
 779     }
 780     return closestStringRange;
 781 }
 782 
 783 // Returns the range of the entire document if there is no selection.
 784 RefPtr&lt;Range&gt; AccessibilityObject::selectionRange() const
 785 {
 786     Frame* frame = this-&gt;frame();
 787     if (!frame)
 788         return nullptr;
 789 
 790     const VisibleSelection&amp; selection = frame-&gt;selection().selection();
 791     if (!selection.isNone())
 792         return selection.firstRange();
 793 
 794     return Range::create(*frame-&gt;document());
 795 }
 796 
 797 RefPtr&lt;Range&gt; AccessibilityObject::elementRange() const
 798 {
 799     return AXObjectCache::rangeForNodeContents(node());
 800 }
 801 
 802 String AccessibilityObject::selectText(AccessibilitySelectTextCriteria* criteria)
 803 {
 804     ASSERT(criteria);
 805 
 806     if (!criteria)
 807         return String();
 808 
 809     Frame* frame = this-&gt;frame();
 810     if (!frame)
 811         return String();
 812 
 813     AccessibilitySelectTextActivity&amp; activity = criteria-&gt;activity;
 814     AccessibilitySelectTextAmbiguityResolution&amp; ambiguityResolution = criteria-&gt;ambiguityResolution;
 815     String&amp; replacementString = criteria-&gt;replacementString;
 816     Vector&lt;String&gt;&amp; searchStrings = criteria-&gt;searchStrings;
 817 
 818     RefPtr&lt;Range&gt; selectedStringRange = selectionRange();
 819     // When starting our search again, make this a zero length range so that search forwards will find this selected range if its appropriate.
 820     selectedStringRange-&gt;setEnd(selectedStringRange-&gt;startContainer(), selectedStringRange-&gt;startOffset());
 821 
 822     RefPtr&lt;Range&gt; closestAfterStringRange = nullptr;
 823     RefPtr&lt;Range&gt; closestBeforeStringRange = nullptr;
 824     // Search forward if necessary.
 825     if (ambiguityResolution == AccessibilitySelectTextAmbiguityResolution::ClosestAfter || ambiguityResolution == AccessibilitySelectTextAmbiguityResolution::ClosestTo)
 826         closestAfterStringRange = rangeOfStringClosestToRangeInDirection(selectedStringRange.get(), AccessibilitySearchDirection::Next, searchStrings);
 827     // Search backward if necessary.
 828     if (ambiguityResolution == AccessibilitySelectTextAmbiguityResolution::ClosestBefore || ambiguityResolution == AccessibilitySelectTextAmbiguityResolution::ClosestTo)
 829         closestBeforeStringRange = rangeOfStringClosestToRangeInDirection(selectedStringRange.get(), AccessibilitySearchDirection::Previous, searchStrings);
 830 
 831     // Determine which candidate is closest to the selection and perform the activity.
 832     if (RefPtr&lt;Range&gt; closestStringRange = rangeClosestToRange(selectedStringRange.get(), WTFMove(closestAfterStringRange), WTFMove(closestBeforeStringRange))) {
 833         // If the search started within a text control, ensure that the result is inside that element.
 834         if (element() &amp;&amp; element()-&gt;isTextField()) {
 835             if (!closestStringRange-&gt;startContainer().isDescendantOrShadowDescendantOf(element()) || !closestStringRange-&gt;endContainer().isDescendantOrShadowDescendantOf(element()))
 836                 return String();
 837         }
 838 
 839         String closestString = closestStringRange-&gt;text();
 840         bool replaceSelection = false;
 841         if (frame-&gt;selection().setSelectedRange(closestStringRange.get(), DOWNSTREAM, FrameSelection::ShouldCloseTyping::Yes)) {
 842             switch (activity) {
 843             case AccessibilitySelectTextActivity::FindAndCapitalize:
 844                 replacementString = capitalize(closestString, &#39; &#39;); // FIXME: Needs to take locale into account to work correctly.
 845                 replaceSelection = true;
 846                 break;
 847             case AccessibilitySelectTextActivity::FindAndUppercase:
 848                 replacementString = closestString.convertToUppercaseWithoutLocale(); // FIXME: Needs locale to work correctly.
 849                 replaceSelection = true;
 850                 break;
 851             case AccessibilitySelectTextActivity::FindAndLowercase:
 852                 replacementString = closestString.convertToLowercaseWithoutLocale(); // FIXME: Needs locale to work correctly.
 853                 replaceSelection = true;
 854                 break;
 855             case AccessibilitySelectTextActivity::FindAndReplace: {
 856                 replaceSelection = true;
 857                 // When applying find and replace activities, we want to match the capitalization of the replaced text,
 858                 // (unless we&#39;re replacing with an abbreviation.)
 859                 if (closestString.length() &gt; 0 &amp;&amp; replacementString.length() &gt; 2 &amp;&amp; replacementString != replacementString.convertToUppercaseWithoutLocale()) {
 860                     if (closestString[0] == u_toupper(closestString[0]))
 861                         replacementString = capitalize(replacementString, &#39; &#39;); // FIXME: Needs to take locale into account to work correctly.
 862                     else
 863                         replacementString = replacementString.convertToLowercaseWithoutLocale(); // FIXME: Needs locale to work correctly.
 864                 }
 865                 break;
 866             }
 867             case AccessibilitySelectTextActivity::FindAndSelect:
 868                 break;
 869             }
 870 
 871             // A bit obvious, but worth noting the API contract for this method is that we should
 872             // return the replacement string when replacing, but the selected string if not.
 873             if (replaceSelection) {
 874                 frame-&gt;editor().replaceSelectionWithText(replacementString, Editor::SelectReplacement::Yes, Editor::SmartReplace::Yes);
 875                 return replacementString;
 876             }
 877 
 878             return closestString;
 879         }
 880     }
 881 
 882     return String();
 883 }
 884 
 885 bool AccessibilityObject::hasAttributesRequiredForInclusion() const
 886 {
 887     // These checks are simplified in the interest of execution speed.
 888     if (!getAttribute(aria_helpAttr).isEmpty()
 889         || !getAttribute(aria_describedbyAttr).isEmpty()
 890         || !getAttribute(altAttr).isEmpty()
 891         || !getAttribute(titleAttr).isEmpty())
 892         return true;
 893 
 894 #if ENABLE(MATHML)
 895     if (!getAttribute(MathMLNames::alttextAttr).isEmpty())
 896         return true;
 897 #endif
 898 
 899     return false;
 900 }
 901 
 902 bool AccessibilityObject::isARIAInput(AccessibilityRole ariaRole)
 903 {
 904     return ariaRole == AccessibilityRole::RadioButton || ariaRole == AccessibilityRole::CheckBox || ariaRole == AccessibilityRole::TextField || ariaRole == AccessibilityRole::Switch || ariaRole == AccessibilityRole::SearchField;
 905 }
 906 
 907 bool AccessibilityObject::isARIAControl(AccessibilityRole ariaRole)
 908 {
 909     return isARIAInput(ariaRole) || ariaRole == AccessibilityRole::TextArea || ariaRole == AccessibilityRole::Button || ariaRole == AccessibilityRole::ComboBox || ariaRole == AccessibilityRole::Slider || ariaRole == AccessibilityRole::ListBox;
 910 }
 911 
 912 bool AccessibilityObject::isRangeControl() const
 913 {
 914     switch (roleValue()) {
 915     case AccessibilityRole::ProgressIndicator:
 916     case AccessibilityRole::Slider:
 917     case AccessibilityRole::ScrollBar:
 918     case AccessibilityRole::SpinButton:
 919         return true;
 920     case AccessibilityRole::Splitter:
 921         return canSetFocusAttribute();
 922     default:
 923         return false;
 924     }
 925 }
 926 
 927 bool AccessibilityObject::isMeter() const
 928 {
 929 #if ENABLE(METER_ELEMENT)
 930     RenderObject* renderer = this-&gt;renderer();
 931     return renderer &amp;&amp; renderer-&gt;isMeter();
 932 #else
 933     return false;
 934 #endif
 935 }
 936 
 937 IntPoint AccessibilityObject::clickPoint()
 938 {
 939     LayoutRect rect = elementRect();
 940     return roundedIntPoint(LayoutPoint(rect.x() + rect.width() / 2, rect.y() + rect.height() / 2));
 941 }
 942 
 943 IntRect AccessibilityObject::boundingBoxForQuads(RenderObject* obj, const Vector&lt;FloatQuad&gt;&amp; quads)
 944 {
 945     ASSERT(obj);
 946     if (!obj)
 947         return IntRect();
 948 
 949     FloatRect result;
 950     for (const auto&amp; quad : quads) {
 951         FloatRect r = quad.enclosingBoundingBox();
 952         if (!r.isEmpty()) {
 953             if (obj-&gt;style().hasAppearance())
 954                 obj-&gt;theme().adjustRepaintRect(*obj, r);
 955             result.unite(r);
 956         }
 957     }
 958     return snappedIntRect(LayoutRect(result));
 959 }
 960 
 961 bool AccessibilityObject::press()
 962 {
 963     // The presence of the actionElement will confirm whether we should even attempt a press.
 964     Element* actionElem = actionElement();
 965     if (!actionElem)
 966         return false;
 967     if (Frame* f = actionElem-&gt;document().frame())
 968         f-&gt;loader().resetMultipleFormSubmissionProtection();
 969 
 970     // Hit test at this location to determine if there is a sub-node element that should act
 971     // as the target of the action.
 972     Element* hitTestElement = nullptr;
 973     Document* document = this-&gt;document();
 974     if (document) {
 975         HitTestRequest request(HitTestRequest::ReadOnly | HitTestRequest::Active | HitTestRequest::AccessibilityHitTest);
 976         HitTestResult hitTestResult(clickPoint());
 977         document-&gt;hitTest(request, hitTestResult);
 978         if (auto* innerNode = hitTestResult.innerNode()) {
 979             if (auto* shadowHost = innerNode-&gt;shadowHost())
 980                 hitTestElement = shadowHost;
 981             else if (is&lt;Element&gt;(*innerNode))
 982                 hitTestElement = &amp;downcast&lt;Element&gt;(*innerNode);
 983             else
 984                 hitTestElement = innerNode-&gt;parentElement();
 985         }
 986     }
 987 
 988     // Prefer the actionElement instead of this node, if the actionElement is inside this node.
 989     Element* pressElement = this-&gt;element();
 990     if (!pressElement || actionElem-&gt;isDescendantOf(*pressElement))
 991         pressElement = actionElem;
 992 
 993     ASSERT(pressElement);
 994     // Prefer the hit test element, if it is inside the target element.
 995     if (hitTestElement &amp;&amp; hitTestElement-&gt;isDescendantOf(*pressElement))
 996         pressElement = hitTestElement;
 997 
 998     // dispatch accessibleclick event
 999     if (auto* cache = axObjectCache()) {
1000         if (auto* pressObject = cache-&gt;getOrCreate(pressElement)) {
1001             if (pressObject-&gt;dispatchAccessibilityEventWithType(AccessibilityEventType::Click))
1002                 return true;
1003         }
1004     }
1005 
1006     UserGestureIndicator gestureIndicator(ProcessingUserGesture, document);
1007 
1008     bool dispatchedTouchEvent = false;
1009 #if PLATFORM(IOS_FAMILY)
1010     if (hasTouchEventListener())
1011         dispatchedTouchEvent = dispatchTouchEvent();
1012 #endif
1013     if (!dispatchedTouchEvent)
1014         pressElement-&gt;accessKeyAction(true);
1015 
1016     return true;
1017 }
1018 
1019 bool AccessibilityObject::dispatchTouchEvent()
1020 {
1021 #if ENABLE(IOS_TOUCH_EVENTS)
1022     if (auto* frame = mainFrame())
1023         return frame-&gt;eventHandler().dispatchSimulatedTouchEvent(clickPoint());
1024 #endif
1025     return false;
1026 }
1027 
1028 Frame* AccessibilityObject::frame() const
1029 {
1030     Node* node = this-&gt;node();
1031     if (!node)
1032         return nullptr;
1033 
1034     return node-&gt;document().frame();
1035 }
1036 
1037 Frame* AccessibilityObject::mainFrame() const
1038 {
1039     Document* document = topDocument();
1040     if (!document)
1041         return nullptr;
1042 
1043     Frame* frame = document-&gt;frame();
1044     if (!frame)
1045         return nullptr;
1046 
1047     return &amp;frame-&gt;mainFrame();
1048 }
1049 
1050 Document* AccessibilityObject::topDocument() const
1051 {
1052     if (!document())
1053         return nullptr;
1054     return &amp;document()-&gt;topDocument();
1055 }
1056 
1057 String AccessibilityObject::language() const
1058 {
1059     const AtomicString&amp; lang = getAttribute(langAttr);
1060     if (!lang.isEmpty())
1061         return lang;
1062 
1063     AccessibilityObject* parent = parentObject();
1064 
1065     // as a last resort, fall back to the content language specified in the meta tag
1066     if (!parent) {
1067         Document* doc = document();
1068         if (doc)
1069             return doc-&gt;contentLanguage();
1070         return nullAtom();
1071     }
1072 
1073     return parent-&gt;language();
1074 }
1075 
1076 VisiblePositionRange AccessibilityObject::visiblePositionRangeForUnorderedPositions(const VisiblePosition&amp; visiblePos1, const VisiblePosition&amp; visiblePos2) const
1077 {
1078     if (visiblePos1.isNull() || visiblePos2.isNull())
1079         return VisiblePositionRange();
1080 
1081     // If there&#39;s no common tree scope between positions, return early.
1082     if (!commonTreeScope(visiblePos1.deepEquivalent().deprecatedNode(), visiblePos2.deepEquivalent().deprecatedNode()))
1083         return VisiblePositionRange();
1084 
1085     VisiblePosition startPos;
1086     VisiblePosition endPos;
1087     bool alreadyInOrder;
1088 
1089     // upstream is ordered before downstream for the same position
1090     if (visiblePos1 == visiblePos2 &amp;&amp; visiblePos2.affinity() == UPSTREAM)
1091         alreadyInOrder = false;
1092 
1093     // use selection order to see if the positions are in order
1094     else
1095         alreadyInOrder = VisibleSelection(visiblePos1, visiblePos2).isBaseFirst();
1096 
1097     if (alreadyInOrder) {
1098         startPos = visiblePos1;
1099         endPos = visiblePos2;
1100     } else {
1101         startPos = visiblePos2;
1102         endPos = visiblePos1;
1103     }
1104 
1105     return VisiblePositionRange(startPos, endPos);
1106 }
1107 
1108 VisiblePositionRange AccessibilityObject::positionOfLeftWord(const VisiblePosition&amp; visiblePos) const
1109 {
1110     VisiblePosition startPosition = startOfWord(visiblePos, LeftWordIfOnBoundary);
1111     VisiblePosition endPosition = endOfWord(startPosition);
1112     return VisiblePositionRange(startPosition, endPosition);
1113 }
1114 
1115 VisiblePositionRange AccessibilityObject::positionOfRightWord(const VisiblePosition&amp; visiblePos) const
1116 {
1117     VisiblePosition startPosition = startOfWord(visiblePos, RightWordIfOnBoundary);
1118     VisiblePosition endPosition = endOfWord(startPosition);
1119     return VisiblePositionRange(startPosition, endPosition);
1120 }
1121 
1122 static VisiblePosition updateAXLineStartForVisiblePosition(const VisiblePosition&amp; visiblePosition)
1123 {
1124     // A line in the accessibility sense should include floating objects, such as aligned image, as part of a line.
1125     // So let&#39;s update the position to include that.
1126     VisiblePosition tempPosition;
1127     VisiblePosition startPosition = visiblePosition;
1128     while (true) {
1129         tempPosition = startPosition.previous();
1130         if (tempPosition.isNull())
1131             break;
1132         Position p = tempPosition.deepEquivalent();
1133         RenderObject* renderer = p.deprecatedNode()-&gt;renderer();
1134         if (!renderer || (renderer-&gt;isRenderBlock() &amp;&amp; !p.deprecatedEditingOffset()))
1135             break;
1136         if (!RenderedPosition(tempPosition).isNull())
1137             break;
1138         startPosition = tempPosition;
1139     }
1140 
1141     return startPosition;
1142 }
1143 
1144 VisiblePositionRange AccessibilityObject::leftLineVisiblePositionRange(const VisiblePosition&amp; visiblePos) const
1145 {
1146     if (visiblePos.isNull())
1147         return VisiblePositionRange();
1148 
1149     // make a caret selection for the position before marker position (to make sure
1150     // we move off of a line start)
1151     VisiblePosition prevVisiblePos = visiblePos.previous();
1152     if (prevVisiblePos.isNull())
1153         return VisiblePositionRange();
1154 
1155     VisiblePosition startPosition = startOfLine(prevVisiblePos);
1156 
1157     // keep searching for a valid line start position.  Unless the VisiblePosition is at the very beginning, there should
1158     // always be a valid line range.  However, startOfLine will return null for position next to a floating object,
1159     // since floating object doesn&#39;t really belong to any line.
1160     // This check will reposition the marker before the floating object, to ensure we get a line start.
1161     if (startPosition.isNull()) {
1162         while (startPosition.isNull() &amp;&amp; prevVisiblePos.isNotNull()) {
1163             prevVisiblePos = prevVisiblePos.previous();
1164             startPosition = startOfLine(prevVisiblePos);
1165         }
1166     } else
1167         startPosition = updateAXLineStartForVisiblePosition(startPosition);
1168 
1169     VisiblePosition endPosition = endOfLine(prevVisiblePos);
1170     return VisiblePositionRange(startPosition, endPosition);
1171 }
1172 
1173 VisiblePositionRange AccessibilityObject::rightLineVisiblePositionRange(const VisiblePosition&amp; visiblePos) const
1174 {
1175     if (visiblePos.isNull())
1176         return VisiblePositionRange();
1177 
1178     // make sure we move off of a line end
1179     VisiblePosition nextVisiblePos = visiblePos.next();
1180     if (nextVisiblePos.isNull())
1181         return VisiblePositionRange();
1182 
1183     VisiblePosition startPosition = startOfLine(nextVisiblePos);
1184 
1185     // fetch for a valid line start position
1186     if (startPosition.isNull()) {
1187         startPosition = visiblePos;
1188         nextVisiblePos = nextVisiblePos.next();
1189     } else
1190         startPosition = updateAXLineStartForVisiblePosition(startPosition);
1191 
1192     VisiblePosition endPosition = endOfLine(nextVisiblePos);
1193 
1194     // as long as the position hasn&#39;t reached the end of the doc,  keep searching for a valid line end position
1195     // Unless the VisiblePosition is at the very end, there should always be a valid line range.  However, endOfLine will
1196     // return null for position by a floating object, since floating object doesn&#39;t really belong to any line.
1197     // This check will reposition the marker after the floating object, to ensure we get a line end.
1198     while (endPosition.isNull() &amp;&amp; nextVisiblePos.isNotNull()) {
1199         nextVisiblePos = nextVisiblePos.next();
1200         endPosition = endOfLine(nextVisiblePos);
1201     }
1202 
1203     return VisiblePositionRange(startPosition, endPosition);
1204 }
1205 
1206 VisiblePositionRange AccessibilityObject::sentenceForPosition(const VisiblePosition&amp; visiblePos) const
1207 {
1208     // FIXME: FO 2 IMPLEMENT (currently returns incorrect answer)
1209     // Related? &lt;rdar://problem/3927736&gt; Text selection broken in 8A336
1210     VisiblePosition startPosition = startOfSentence(visiblePos);
1211     VisiblePosition endPosition = endOfSentence(startPosition);
1212     return VisiblePositionRange(startPosition, endPosition);
1213 }
1214 
1215 VisiblePositionRange AccessibilityObject::paragraphForPosition(const VisiblePosition&amp; visiblePos) const
1216 {
1217     VisiblePosition startPosition = startOfParagraph(visiblePos);
1218     VisiblePosition endPosition = endOfParagraph(startPosition);
1219     return VisiblePositionRange(startPosition, endPosition);
1220 }
1221 
1222 static VisiblePosition startOfStyleRange(const VisiblePosition&amp; visiblePos)
1223 {
1224     RenderObject* renderer = visiblePos.deepEquivalent().deprecatedNode()-&gt;renderer();
1225     RenderObject* startRenderer = renderer;
1226     auto* style = &amp;renderer-&gt;style();
1227 
1228     // traverse backward by renderer to look for style change
1229     for (RenderObject* r = renderer-&gt;previousInPreOrder(); r; r = r-&gt;previousInPreOrder()) {
1230         // skip non-leaf nodes
1231         if (r-&gt;firstChildSlow())
1232             continue;
1233 
1234         // stop at style change
1235         if (&amp;r-&gt;style() != style)
1236             break;
1237 
1238         // remember match
1239         startRenderer = r;
1240     }
1241 
1242     return firstPositionInOrBeforeNode(startRenderer-&gt;node());
1243 }
1244 
1245 static VisiblePosition endOfStyleRange(const VisiblePosition&amp; visiblePos)
1246 {
1247     RenderObject* renderer = visiblePos.deepEquivalent().deprecatedNode()-&gt;renderer();
1248     RenderObject* endRenderer = renderer;
1249     const RenderStyle&amp; style = renderer-&gt;style();
1250 
1251     // traverse forward by renderer to look for style change
1252     for (RenderObject* r = renderer-&gt;nextInPreOrder(); r; r = r-&gt;nextInPreOrder()) {
1253         // skip non-leaf nodes
1254         if (r-&gt;firstChildSlow())
1255             continue;
1256 
1257         // stop at style change
1258         if (&amp;r-&gt;style() != &amp;style)
1259             break;
1260 
1261         // remember match
1262         endRenderer = r;
1263     }
1264 
1265     return lastPositionInOrAfterNode(endRenderer-&gt;node());
1266 }
1267 
1268 VisiblePositionRange AccessibilityObject::styleRangeForPosition(const VisiblePosition&amp; visiblePos) const
1269 {
1270     if (visiblePos.isNull())
1271         return VisiblePositionRange();
1272 
1273     return VisiblePositionRange(startOfStyleRange(visiblePos), endOfStyleRange(visiblePos));
1274 }
1275 
1276 // NOTE: Consider providing this utility method as AX API
1277 VisiblePositionRange AccessibilityObject::visiblePositionRangeForRange(const PlainTextRange&amp; range) const
1278 {
1279     unsigned textLength = getLengthForTextRange();
1280     if (range.start + range.length &gt; textLength)
1281         return VisiblePositionRange();
1282 
1283     VisiblePosition startPosition = visiblePositionForIndex(range.start);
1284     startPosition.setAffinity(DOWNSTREAM);
1285     VisiblePosition endPosition = visiblePositionForIndex(range.start + range.length);
1286     return VisiblePositionRange(startPosition, endPosition);
1287 }
1288 
1289 RefPtr&lt;Range&gt; AccessibilityObject::rangeForPlainTextRange(const PlainTextRange&amp; range) const
1290 {
1291     unsigned textLength = getLengthForTextRange();
1292     if (range.start + range.length &gt; textLength)
1293         return nullptr;
1294 
1295     if (AXObjectCache* cache = axObjectCache()) {
1296         CharacterOffset start = cache-&gt;characterOffsetForIndex(range.start, this);
1297         CharacterOffset end = cache-&gt;characterOffsetForIndex(range.start + range.length, this);
1298         return cache-&gt;rangeForUnorderedCharacterOffsets(start, end);
1299     }
1300     return nullptr;
1301 }
1302 
1303 VisiblePositionRange AccessibilityObject::lineRangeForPosition(const VisiblePosition&amp; visiblePosition) const
1304 {
1305     VisiblePosition startPosition = startOfLine(visiblePosition);
1306     VisiblePosition endPosition = endOfLine(visiblePosition);
1307     return VisiblePositionRange(startPosition, endPosition);
1308 }
1309 
1310 bool AccessibilityObject::replacedNodeNeedsCharacter(Node* replacedNode)
1311 {
1312     // we should always be given a rendered node and a replaced node, but be safe
1313     // replaced nodes are either attachments (widgets) or images
1314     if (!replacedNode || !isRendererReplacedElement(replacedNode-&gt;renderer()) || replacedNode-&gt;isTextNode())
1315         return false;
1316 
1317     // create an AX object, but skip it if it is not supposed to be seen
1318     AccessibilityObject* object = replacedNode-&gt;renderer()-&gt;document().axObjectCache()-&gt;getOrCreate(replacedNode);
1319     if (object-&gt;accessibilityIsIgnored())
1320         return false;
1321 
1322     return true;
1323 }
1324 
1325 // Finds a RenderListItem parent give a node.
1326 static RenderListItem* renderListItemContainerForNode(Node* node)
1327 {
1328     for (; node; node = node-&gt;parentNode()) {
1329         RenderBoxModelObject* renderer = node-&gt;renderBoxModelObject();
1330         if (is&lt;RenderListItem&gt;(renderer))
1331             return downcast&lt;RenderListItem&gt;(renderer);
1332     }
1333     return nullptr;
1334 }
1335 
1336 static String listMarkerTextForNode(Node* node)
1337 {
1338     RenderListItem* listItem = renderListItemContainerForNode(node);
1339     if (!listItem)
1340         return String();
1341 
1342     // If this is in a list item, we need to manually add the text for the list marker
1343     // because a RenderListMarker does not have a Node equivalent and thus does not appear
1344     // when iterating text.
1345     return listItem-&gt;markerTextWithSuffix();
1346 }
1347 
1348 // Returns the text associated with a list marker if this node is contained within a list item.
1349 String AccessibilityObject::listMarkerTextForNodeAndPosition(Node* node, const VisiblePosition&amp; visiblePositionStart)
1350 {
1351     // If the range does not contain the start of the line, the list marker text should not be included.
1352     if (!isStartOfLine(visiblePositionStart))
1353         return String();
1354 
1355     // We should speak the list marker only for the first line.
1356     RenderListItem* listItem = renderListItemContainerForNode(node);
1357     if (!listItem)
1358         return String();
1359     if (!inSameLine(visiblePositionStart, firstPositionInNode(&amp;listItem-&gt;element())))
1360         return String();
1361 
1362     return listMarkerTextForNode(node);
1363 }
1364 
1365 String AccessibilityObject::stringForRange(RefPtr&lt;Range&gt; range) const
1366 {
1367     if (!range)
1368         return String();
1369 
1370     TextIterator it(range.get());
1371     if (it.atEnd())
1372         return String();
1373 
1374     StringBuilder builder;
1375     for (; !it.atEnd(); it.advance()) {
1376         // non-zero length means textual node, zero length means replaced node (AKA &quot;attachments&quot; in AX)
1377         if (it.text().length()) {
1378             // Add a textual representation for list marker text.
1379             // Don&#39;t add list marker text for new line character.
1380             if (it.text().length() != 1 || !isSpaceOrNewline(it.text()[0]))
1381                 builder.append(listMarkerTextForNodeAndPosition(it.node(), VisiblePosition(range-&gt;startPosition())));
1382             it.appendTextToStringBuilder(builder);
1383         } else {
1384             // locate the node and starting offset for this replaced range
1385             Node&amp; node = it.range()-&gt;startContainer();
1386             ASSERT(&amp;node == &amp;it.range()-&gt;endContainer());
1387             int offset = it.range()-&gt;startOffset();
1388             if (replacedNodeNeedsCharacter(node.traverseToChildAt(offset)))
1389                 builder.append(objectReplacementCharacter);
1390         }
1391     }
1392 
1393     return builder.toString();
1394 }
1395 
1396 String AccessibilityObject::stringForVisiblePositionRange(const VisiblePositionRange&amp; visiblePositionRange)
1397 {
1398     if (visiblePositionRange.isNull())
1399         return String();
1400 
1401     StringBuilder builder;
1402     RefPtr&lt;Range&gt; range = makeRange(visiblePositionRange.start, visiblePositionRange.end);
1403     for (TextIterator it(range.get()); !it.atEnd(); it.advance()) {
1404         // non-zero length means textual node, zero length means replaced node (AKA &quot;attachments&quot; in AX)
1405         if (it.text().length()) {
1406             // Add a textual representation for list marker text.
1407             builder.append(listMarkerTextForNodeAndPosition(it.node(), visiblePositionRange.start));
1408             it.appendTextToStringBuilder(builder);
1409         } else {
1410             // locate the node and starting offset for this replaced range
1411             Node&amp; node = it.range()-&gt;startContainer();
1412             ASSERT(&amp;node == &amp;it.range()-&gt;endContainer());
1413             int offset = it.range()-&gt;startOffset();
1414             if (replacedNodeNeedsCharacter(node.traverseToChildAt(offset)))
1415                 builder.append(objectReplacementCharacter);
1416         }
1417     }
1418 
1419     return builder.toString();
1420 }
1421 
1422 int AccessibilityObject::lengthForVisiblePositionRange(const VisiblePositionRange&amp; visiblePositionRange) const
1423 {
1424     // FIXME: Multi-byte support
1425     if (visiblePositionRange.isNull())
1426         return -1;
1427 
1428     int length = 0;
1429     RefPtr&lt;Range&gt; range = makeRange(visiblePositionRange.start, visiblePositionRange.end);
1430     for (TextIterator it(range.get()); !it.atEnd(); it.advance()) {
1431         // non-zero length means textual node, zero length means replaced node (AKA &quot;attachments&quot; in AX)
1432         if (it.text().length())
1433             length += it.text().length();
1434         else {
1435             // locate the node and starting offset for this replaced range
1436             Node&amp; node = it.range()-&gt;startContainer();
1437             ASSERT(&amp;node == &amp;it.range()-&gt;endContainer());
1438             int offset = it.range()-&gt;startOffset();
1439 
1440             if (replacedNodeNeedsCharacter(node.traverseToChildAt(offset)))
1441                 ++length;
1442         }
1443     }
1444 
1445     return length;
1446 }
1447 
1448 VisiblePosition AccessibilityObject::visiblePositionForBounds(const IntRect&amp; rect, AccessibilityVisiblePositionForBounds visiblePositionForBounds) const
1449 {
1450     if (rect.isEmpty())
1451         return VisiblePosition();
1452 
1453     auto* mainFrame = this-&gt;mainFrame();
1454     if (!mainFrame)
1455         return VisiblePosition();
1456 
1457     // FIXME: Add support for right-to-left languages.
1458     IntPoint corner = (visiblePositionForBounds == AccessibilityVisiblePositionForBounds::First) ? rect.minXMinYCorner() : rect.maxXMaxYCorner();
1459     VisiblePosition position = mainFrame-&gt;visiblePositionForPoint(corner);
1460 
1461     if (rect.contains(position.absoluteCaretBounds().center()))
1462         return position;
1463 
1464     // If the initial position is located outside the bounds adjust it incrementally as needed.
1465     VisiblePosition nextPosition = position.next();
1466     VisiblePosition previousPosition = position.previous();
1467     while (nextPosition.isNotNull() || previousPosition.isNotNull()) {
1468         if (rect.contains(nextPosition.absoluteCaretBounds().center()))
1469             return nextPosition;
1470         if (rect.contains(previousPosition.absoluteCaretBounds().center()))
1471             return previousPosition;
1472 
1473         nextPosition = nextPosition.next();
1474         previousPosition = previousPosition.previous();
1475     }
1476 
1477     return VisiblePosition();
1478 }
1479 
1480 VisiblePosition AccessibilityObject::nextWordEnd(const VisiblePosition&amp; visiblePos) const
1481 {
1482     if (visiblePos.isNull())
1483         return VisiblePosition();
1484 
1485     // make sure we move off of a word end
1486     VisiblePosition nextVisiblePos = visiblePos.next();
1487     if (nextVisiblePos.isNull())
1488         return VisiblePosition();
1489 
1490     return endOfWord(nextVisiblePos, LeftWordIfOnBoundary);
1491 }
1492 
1493 VisiblePosition AccessibilityObject::previousWordStart(const VisiblePosition&amp; visiblePos) const
1494 {
1495     if (visiblePos.isNull())
1496         return VisiblePosition();
1497 
1498     // make sure we move off of a word start
1499     VisiblePosition prevVisiblePos = visiblePos.previous();
1500     if (prevVisiblePos.isNull())
1501         return VisiblePosition();
1502 
1503     return startOfWord(prevVisiblePos, RightWordIfOnBoundary);
1504 }
1505 
1506 VisiblePosition AccessibilityObject::nextLineEndPosition(const VisiblePosition&amp; visiblePos) const
1507 {
1508     if (visiblePos.isNull())
1509         return VisiblePosition();
1510 
1511     // to make sure we move off of a line end
1512     VisiblePosition nextVisiblePos = visiblePos.next();
1513     if (nextVisiblePos.isNull())
1514         return VisiblePosition();
1515 
1516     VisiblePosition endPosition = endOfLine(nextVisiblePos);
1517 
1518     // as long as the position hasn&#39;t reached the end of the doc,  keep searching for a valid line end position
1519     // There are cases like when the position is next to a floating object that&#39;ll return null for end of line. This code will avoid returning null.
1520     while (endPosition.isNull() &amp;&amp; nextVisiblePos.isNotNull()) {
1521         nextVisiblePos = nextVisiblePos.next();
1522         endPosition = endOfLine(nextVisiblePos);
1523     }
1524 
1525     return endPosition;
1526 }
1527 
1528 VisiblePosition AccessibilityObject::previousLineStartPosition(const VisiblePosition&amp; visiblePos) const
1529 {
1530     if (visiblePos.isNull())
1531         return VisiblePosition();
1532 
1533     // make sure we move off of a line start
1534     VisiblePosition prevVisiblePos = visiblePos.previous();
1535     if (prevVisiblePos.isNull())
1536         return VisiblePosition();
1537 
1538     VisiblePosition startPosition = startOfLine(prevVisiblePos);
1539 
1540     // as long as the position hasn&#39;t reached the beginning of the doc,  keep searching for a valid line start position
1541     // There are cases like when the position is next to a floating object that&#39;ll return null for start of line. This code will avoid returning null.
1542     if (startPosition.isNull()) {
1543         while (startPosition.isNull() &amp;&amp; prevVisiblePos.isNotNull()) {
1544             prevVisiblePos = prevVisiblePos.previous();
1545             startPosition = startOfLine(prevVisiblePos);
1546         }
1547     } else
1548         startPosition = updateAXLineStartForVisiblePosition(startPosition);
1549 
1550     return startPosition;
1551 }
1552 
1553 VisiblePosition AccessibilityObject::nextSentenceEndPosition(const VisiblePosition&amp; visiblePos) const
1554 {
1555     // FIXME: FO 2 IMPLEMENT (currently returns incorrect answer)
1556     // Related? &lt;rdar://problem/3927736&gt; Text selection broken in 8A336
1557     if (visiblePos.isNull())
1558         return VisiblePosition();
1559 
1560     // make sure we move off of a sentence end
1561     VisiblePosition nextVisiblePos = visiblePos.next();
1562     if (nextVisiblePos.isNull())
1563         return VisiblePosition();
1564 
1565     // an empty line is considered a sentence. If it&#39;s skipped, then the sentence parser will not
1566     // see this empty line.  Instead, return the end position of the empty line.
1567     VisiblePosition endPosition;
1568 
1569     String lineString = plainText(makeRange(startOfLine(nextVisiblePos), endOfLine(nextVisiblePos)).get());
1570     if (lineString.isEmpty())
1571         endPosition = nextVisiblePos;
1572     else
1573         endPosition = endOfSentence(nextVisiblePos);
1574 
1575     return endPosition;
1576 }
1577 
1578 VisiblePosition AccessibilityObject::previousSentenceStartPosition(const VisiblePosition&amp; visiblePos) const
1579 {
1580     // FIXME: FO 2 IMPLEMENT (currently returns incorrect answer)
1581     // Related? &lt;rdar://problem/3927736&gt; Text selection broken in 8A336
1582     if (visiblePos.isNull())
1583         return VisiblePosition();
1584 
1585     // make sure we move off of a sentence start
1586     VisiblePosition previousVisiblePos = visiblePos.previous();
1587     if (previousVisiblePos.isNull())
1588         return VisiblePosition();
1589 
1590     // treat empty line as a separate sentence.
1591     VisiblePosition startPosition;
1592 
1593     String lineString = plainText(makeRange(startOfLine(previousVisiblePos), endOfLine(previousVisiblePos)).get());
1594     if (lineString.isEmpty())
1595         startPosition = previousVisiblePos;
1596     else
1597         startPosition = startOfSentence(previousVisiblePos);
1598 
1599     return startPosition;
1600 }
1601 
1602 VisiblePosition AccessibilityObject::nextParagraphEndPosition(const VisiblePosition&amp; visiblePos) const
1603 {
1604     if (visiblePos.isNull())
1605         return VisiblePosition();
1606 
1607     // make sure we move off of a paragraph end
1608     VisiblePosition nextPos = visiblePos.next();
1609     if (nextPos.isNull())
1610         return VisiblePosition();
1611 
1612     return endOfParagraph(nextPos);
1613 }
1614 
1615 VisiblePosition AccessibilityObject::previousParagraphStartPosition(const VisiblePosition&amp; visiblePos) const
1616 {
1617     if (visiblePos.isNull())
1618         return VisiblePosition();
1619 
1620     // make sure we move off of a paragraph start
1621     VisiblePosition previousPos = visiblePos.previous();
1622     if (previousPos.isNull())
1623         return VisiblePosition();
1624 
1625     return startOfParagraph(previousPos);
1626 }
1627 
1628 AccessibilityObject* AccessibilityObject::accessibilityObjectForPosition(const VisiblePosition&amp; visiblePos) const
1629 {
1630     if (visiblePos.isNull())
1631         return nullptr;
1632 
1633     RenderObject* obj = visiblePos.deepEquivalent().deprecatedNode()-&gt;renderer();
1634     if (!obj)
1635         return nullptr;
1636 
1637     return obj-&gt;document().axObjectCache()-&gt;getOrCreate(obj);
1638 }
1639 
1640 // If you call node-&gt;hasEditableStyle() since that will return true if an ancestor is editable.
1641 // This only returns true if this is the element that actually has the contentEditable attribute set.
1642 bool AccessibilityObject::hasContentEditableAttributeSet() const
1643 {
1644     return contentEditableAttributeIsEnabled(element());
1645 }
1646 
1647 bool AccessibilityObject::supportsReadOnly() const
1648 {
1649     AccessibilityRole role = roleValue();
1650 
1651     return role == AccessibilityRole::CheckBox
1652         || role == AccessibilityRole::ColumnHeader
1653         || role == AccessibilityRole::ComboBox
1654         || role == AccessibilityRole::Grid
1655         || role == AccessibilityRole::GridCell
1656         || role == AccessibilityRole::ListBox
1657         || role == AccessibilityRole::MenuItemCheckbox
1658         || role == AccessibilityRole::MenuItemRadio
1659         || role == AccessibilityRole::RadioGroup
1660         || role == AccessibilityRole::RowHeader
1661         || role == AccessibilityRole::SearchField
1662         || role == AccessibilityRole::Slider
1663         || role == AccessibilityRole::SpinButton
1664         || role == AccessibilityRole::Switch
1665         || role == AccessibilityRole::TextField
1666         || role == AccessibilityRole::TreeGrid
1667         || isPasswordField();
1668 }
1669 
1670 String AccessibilityObject::readOnlyValue() const
1671 {
1672     if (!hasAttribute(aria_readonlyAttr))
1673         return ariaRoleAttribute() != AccessibilityRole::Unknown &amp;&amp; supportsReadOnly() ? &quot;false&quot; : String();
1674 
1675     return getAttribute(aria_readonlyAttr).string().convertToASCIILowercase();
1676 }
1677 
1678 bool AccessibilityObject::supportsAutoComplete() const
1679 {
1680     return (isComboBox() || isARIATextControl()) &amp;&amp; hasAttribute(aria_autocompleteAttr);
1681 }
1682 
1683 String AccessibilityObject::autoCompleteValue() const
1684 {
1685     const AtomicString&amp; autoComplete = getAttribute(aria_autocompleteAttr);
1686     if (equalLettersIgnoringASCIICase(autoComplete, &quot;inline&quot;)
1687         || equalLettersIgnoringASCIICase(autoComplete, &quot;list&quot;)
1688         || equalLettersIgnoringASCIICase(autoComplete, &quot;both&quot;))
1689         return autoComplete;
1690 
1691     return &quot;none&quot;;
1692 }
1693 
1694 bool AccessibilityObject::contentEditableAttributeIsEnabled(Element* element)
1695 {
1696     if (!element)
1697         return false;
1698 
1699     const AtomicString&amp; contentEditableValue = element-&gt;attributeWithoutSynchronization(contenteditableAttr);
1700     if (contentEditableValue.isNull())
1701         return false;
1702 
1703     // Both &quot;true&quot; (case-insensitive) and the empty string count as true.
1704     return contentEditableValue.isEmpty() || equalLettersIgnoringASCIICase(contentEditableValue, &quot;true&quot;);
1705 }
1706 
1707 #if HAVE(ACCESSIBILITY)
1708 int AccessibilityObject::lineForPosition(const VisiblePosition&amp; visiblePos) const
1709 {
1710     if (visiblePos.isNull() || !node())
1711         return -1;
1712 
1713     // If the position is not in the same editable region as this AX object, return -1.
1714     Node* containerNode = visiblePos.deepEquivalent().containerNode();
1715     if (!containerNode-&gt;containsIncludingShadowDOM(node()) &amp;&amp; !node()-&gt;containsIncludingShadowDOM(containerNode))
1716         return -1;
1717 
1718     int lineCount = -1;
1719     VisiblePosition currentVisiblePos = visiblePos;
1720     VisiblePosition savedVisiblePos;
1721 
1722     // move up until we get to the top
1723     // FIXME: This only takes us to the top of the rootEditableElement, not the top of the
1724     // top document.
1725     do {
1726         savedVisiblePos = currentVisiblePos;
1727         VisiblePosition prevVisiblePos = previousLinePosition(currentVisiblePos, 0, HasEditableAXRole);
1728         currentVisiblePos = prevVisiblePos;
1729         ++lineCount;
1730     }  while (currentVisiblePos.isNotNull() &amp;&amp; !(inSameLine(currentVisiblePos, savedVisiblePos)));
1731 
1732     return lineCount;
1733 }
1734 #endif
1735 
1736 // NOTE: Consider providing this utility method as AX API
1737 PlainTextRange AccessibilityObject::plainTextRangeForVisiblePositionRange(const VisiblePositionRange&amp; positionRange) const
1738 {
1739     int index1 = index(positionRange.start);
1740     int index2 = index(positionRange.end);
1741     if (index1 &lt; 0 || index2 &lt; 0 || index1 &gt; index2)
1742         return PlainTextRange();
1743 
1744     return PlainTextRange(index1, index2 - index1);
1745 }
1746 
1747 // The composed character range in the text associated with this accessibility object that
1748 // is specified by the given screen coordinates. This parameterized attribute returns the
1749 // complete range of characters (including surrogate pairs of multi-byte glyphs) at the given
1750 // screen coordinates.
1751 // NOTE: This varies from AppKit when the point is below the last line. AppKit returns an
1752 // an error in that case. We return textControl-&gt;text().length(), 1. Does this matter?
1753 PlainTextRange AccessibilityObject::doAXRangeForPosition(const IntPoint&amp; point) const
1754 {
1755     int i = index(visiblePositionForPoint(point));
1756     if (i &lt; 0)
1757         return PlainTextRange();
1758 
1759     return PlainTextRange(i, 1);
1760 }
1761 
1762 // Given a character index, the range of text associated with this accessibility object
1763 // over which the style in effect at that character index applies.
1764 PlainTextRange AccessibilityObject::doAXStyleRangeForIndex(unsigned index) const
1765 {
1766     VisiblePositionRange range = styleRangeForPosition(visiblePositionForIndex(index, false));
1767     return plainTextRangeForVisiblePositionRange(range);
1768 }
1769 
1770 // Given an indexed character, the line number of the text associated with this accessibility
1771 // object that contains the character.
1772 unsigned AccessibilityObject::doAXLineForIndex(unsigned index)
1773 {
1774     return lineForPosition(visiblePositionForIndex(index, false));
1775 }
1776 
1777 #if HAVE(ACCESSIBILITY)
1778 void AccessibilityObject::updateBackingStore()
1779 {
1780     if (!axObjectCache())
1781         return;
1782 
1783     // Updating the layout may delete this object.
1784     RefPtr&lt;AccessibilityObject&gt; protectedThis(this);
1785     if (auto* document = this-&gt;document()) {
1786         if (!document-&gt;view()-&gt;layoutContext().isInRenderTreeLayout() &amp;&amp; !document-&gt;inRenderTreeUpdate() &amp;&amp; !document-&gt;inStyleRecalc())
1787             document-&gt;updateLayoutIgnorePendingStylesheets();
1788     }
1789 
1790     if (auto cache = axObjectCache())
1791         cache-&gt;performDeferredCacheUpdate();
1792 
1793     updateChildrenIfNecessary();
1794 }
1795 #endif
1796 
1797 ScrollView* AccessibilityObject::scrollViewAncestor() const
1798 {
1799     if (const AccessibilityObject* scrollParent = AccessibilityObject::matchedParent(*this, true, [] (const AccessibilityObject&amp; object) {
1800         return is&lt;AccessibilityScrollView&gt;(object);
1801     }))
1802         return downcast&lt;AccessibilityScrollView&gt;(*scrollParent).scrollView();
1803 
1804     return nullptr;
1805 }
1806 
1807 Document* AccessibilityObject::document() const
1808 {
1809     FrameView* frameView = documentFrameView();
1810     if (!frameView)
1811         return nullptr;
1812 
1813     return frameView-&gt;frame().document();
1814 }
1815 
1816 Page* AccessibilityObject::page() const
1817 {
1818     Document* document = this-&gt;document();
1819     if (!document)
1820         return nullptr;
1821     return document-&gt;page();
1822 }
1823 
1824 FrameView* AccessibilityObject::documentFrameView() const
1825 {
1826     const AccessibilityObject* object = this;
1827     while (object &amp;&amp; !object-&gt;isAccessibilityRenderObject())
1828         object = object-&gt;parentObject();
1829 
1830     if (!object)
1831         return nullptr;
1832 
1833     return object-&gt;documentFrameView();
1834 }
1835 
1836 #if HAVE(ACCESSIBILITY)
1837 const AccessibilityObject::AccessibilityChildrenVector&amp; AccessibilityObject::children(bool updateChildrenIfNeeded)
1838 {
1839     if (updateChildrenIfNeeded)
1840         updateChildrenIfNecessary();
1841 
1842     return m_children;
1843 }
1844 #endif
1845 
1846 void AccessibilityObject::updateChildrenIfNecessary()
1847 {
1848     if (!hasChildren()) {
1849 #if HAVE(ACCESSIBILITY)
1850         // Enable the cache in case we end up adding a lot of children, we don&#39;t want to recompute axIsIgnored each time.
1851         AXAttributeCacheEnabler enableCache(axObjectCache());
1852 #endif
1853         addChildren();
1854     }
1855 }
1856 
1857 void AccessibilityObject::clearChildren()
1858 {
1859     // Some objects have weak pointers to their parents and those associations need to be detached.
1860     for (const auto&amp; child : m_children)
1861         child-&gt;detachFromParent();
1862 
1863     m_children.clear();
1864     m_haveChildren = false;
1865 }
1866 
1867 AccessibilityObject* AccessibilityObject::anchorElementForNode(Node* node)
1868 {
1869     RenderObject* obj = node-&gt;renderer();
1870     if (!obj)
1871         return nullptr;
1872 
1873     RefPtr&lt;AccessibilityObject&gt; axObj = obj-&gt;document().axObjectCache()-&gt;getOrCreate(obj);
1874     Element* anchor = axObj-&gt;anchorElement();
1875     if (!anchor)
1876         return nullptr;
1877 
1878     RenderObject* anchorRenderer = anchor-&gt;renderer();
1879     if (!anchorRenderer)
1880         return nullptr;
1881 
1882     return anchorRenderer-&gt;document().axObjectCache()-&gt;getOrCreate(anchorRenderer);
1883 }
1884 
1885 AccessibilityObject* AccessibilityObject::headingElementForNode(Node* node)
1886 {
1887     if (!node)
1888         return nullptr;
1889 
1890     RenderObject* renderObject = node-&gt;renderer();
1891     if (!renderObject)
1892         return nullptr;
1893 
1894     AccessibilityObject* axObject = renderObject-&gt;document().axObjectCache()-&gt;getOrCreate(renderObject);
1895 
1896     return const_cast&lt;AccessibilityObject*&gt;(AccessibilityObject::matchedParent(*axObject, true, [] (const AccessibilityObject&amp; object) {
1897         return object.roleValue() == AccessibilityRole::Heading;
1898     }));
1899 }
1900 
1901 const AccessibilityObject* AccessibilityObject::matchedParent(const AccessibilityObject&amp; object, bool includeSelf, const WTF::Function&lt;bool(const AccessibilityObject&amp;)&gt;&amp; matches)
1902 {
1903     const AccessibilityObject* parent = includeSelf ? &amp;object : object.parentObject();
1904     for (; parent; parent = parent-&gt;parentObject()) {
1905         if (matches(*parent))
1906             return parent;
1907     }
1908     return nullptr;
1909 }
1910 
1911 void AccessibilityObject::ariaTreeRows(AccessibilityChildrenVector&amp; result)
1912 {
1913     for (const auto&amp; child : children()) {
1914         // Add tree items as the rows.
1915         if (child-&gt;roleValue() == AccessibilityRole::TreeItem)
1916             result.append(child);
1917 
1918         // Now see if this item also has rows hiding inside of it.
1919         child-&gt;ariaTreeRows(result);
1920     }
1921 }
1922 
1923 void AccessibilityObject::ariaTreeItemContent(AccessibilityChildrenVector&amp; result)
1924 {
1925     // The ARIA tree item content are the item that are not other tree items or their containing groups.
1926     for (const auto&amp; child : children()) {
1927         if (!child-&gt;isGroup() &amp;&amp; child-&gt;roleValue() != AccessibilityRole::TreeItem)
1928             result.append(child);
1929     }
1930 }
1931 
1932 void AccessibilityObject::ariaTreeItemDisclosedRows(AccessibilityChildrenVector&amp; result)
1933 {
1934     for (const auto&amp; obj : children()) {
1935         // Add tree items as the rows.
1936         if (obj-&gt;roleValue() == AccessibilityRole::TreeItem)
1937             result.append(obj);
1938         // If it&#39;s not a tree item, then descend into the group to find more tree items.
1939         else
1940             obj-&gt;ariaTreeRows(result);
1941     }
1942 }
1943 
1944 const String AccessibilityObject::defaultLiveRegionStatusForRole(AccessibilityRole role)
1945 {
1946     switch (role) {
1947     case AccessibilityRole::ApplicationAlertDialog:
1948     case AccessibilityRole::ApplicationAlert:
1949         return &quot;assertive&quot;_s;
1950     case AccessibilityRole::ApplicationLog:
1951     case AccessibilityRole::ApplicationStatus:
1952         return &quot;polite&quot;_s;
1953     case AccessibilityRole::ApplicationTimer:
1954     case AccessibilityRole::ApplicationMarquee:
1955         return &quot;off&quot;_s;
1956     default:
1957         return nullAtom();
1958     }
1959 }
1960 
1961 #if HAVE(ACCESSIBILITY)
1962 const String&amp; AccessibilityObject::actionVerb() const
1963 {
1964 #if !PLATFORM(IOS_FAMILY)
1965     // FIXME: Need to add verbs for select elements.
1966     static NeverDestroyed&lt;const String&gt; buttonAction(AXButtonActionVerb());
1967     static NeverDestroyed&lt;const String&gt; textFieldAction(AXTextFieldActionVerb());
1968     static NeverDestroyed&lt;const String&gt; radioButtonAction(AXRadioButtonActionVerb());
1969     static NeverDestroyed&lt;const String&gt; checkedCheckBoxAction(AXCheckedCheckBoxActionVerb());
1970     static NeverDestroyed&lt;const String&gt; uncheckedCheckBoxAction(AXUncheckedCheckBoxActionVerb());
1971     static NeverDestroyed&lt;const String&gt; linkAction(AXLinkActionVerb());
1972     static NeverDestroyed&lt;const String&gt; menuListAction(AXMenuListActionVerb());
1973     static NeverDestroyed&lt;const String&gt; menuListPopupAction(AXMenuListPopupActionVerb());
1974     static NeverDestroyed&lt;const String&gt; listItemAction(AXListItemActionVerb());
1975 
1976     switch (roleValue()) {
1977     case AccessibilityRole::Button:
1978     case AccessibilityRole::ToggleButton:
1979         return buttonAction;
1980     case AccessibilityRole::TextField:
1981     case AccessibilityRole::TextArea:
1982         return textFieldAction;
1983     case AccessibilityRole::RadioButton:
1984         return radioButtonAction;
1985     case AccessibilityRole::CheckBox:
1986     case AccessibilityRole::Switch:
1987         return isChecked() ? checkedCheckBoxAction : uncheckedCheckBoxAction;
1988     case AccessibilityRole::Link:
1989     case AccessibilityRole::WebCoreLink:
1990         return linkAction;
1991     case AccessibilityRole::PopUpButton:
1992         return menuListAction;
1993     case AccessibilityRole::MenuListPopup:
1994         return menuListPopupAction;
1995     case AccessibilityRole::ListItem:
1996         return listItemAction;
1997     default:
1998         return nullAtom();
1999     }
2000 #else
2001     return nullAtom();
2002 #endif
2003 }
2004 #endif
2005 
2006 bool AccessibilityObject::ariaIsMultiline() const
2007 {
2008     return equalLettersIgnoringASCIICase(getAttribute(aria_multilineAttr), &quot;true&quot;);
2009 }
2010 
2011 String AccessibilityObject::invalidStatus() const
2012 {
2013     String grammarValue = &quot;grammar&quot;_s;
2014     String falseValue = &quot;false&quot;_s;
2015     String spellingValue = &quot;spelling&quot;_s;
2016     String trueValue = &quot;true&quot;_s;
2017     String undefinedValue = &quot;undefined&quot;_s;
2018 
2019     // aria-invalid can return false (default), grammar, spelling, or true.
2020     String ariaInvalid = stripLeadingAndTrailingHTMLSpaces(getAttribute(aria_invalidAttr));
2021 
2022     if (ariaInvalid.isEmpty()) {
2023         // We should expose invalid status for input types.
2024         Node* node = this-&gt;node();
2025         if (node &amp;&amp; is&lt;HTMLInputElement&gt;(*node)) {
2026             HTMLInputElement&amp; input = downcast&lt;HTMLInputElement&gt;(*node);
2027             if (input.hasBadInput() || input.typeMismatch())
2028                 return trueValue;
2029         }
2030         return falseValue;
2031     }
2032 
2033     // If &quot;false&quot;, &quot;undefined&quot; [sic, string value], empty, or missing, return &quot;false&quot;.
2034     if (ariaInvalid == falseValue || ariaInvalid == undefinedValue)
2035         return falseValue;
2036     // Besides true/false/undefined, the only tokens defined by WAI-ARIA 1.0...
2037     // ...for @aria-invalid are &quot;grammar&quot; and &quot;spelling&quot;.
2038     if (ariaInvalid == grammarValue)
2039         return grammarValue;
2040     if (ariaInvalid == spellingValue)
2041         return spellingValue;
2042     // Any other non empty string should be treated as &quot;true&quot;.
2043     return trueValue;
2044 }
2045 
2046 bool AccessibilityObject::supportsCurrent() const
2047 {
2048     return hasAttribute(aria_currentAttr);
2049 }
2050 
2051 AccessibilityCurrentState AccessibilityObject::currentState() const
2052 {
2053     // aria-current can return false (default), true, page, step, location, date or time.
2054     String currentStateValue = stripLeadingAndTrailingHTMLSpaces(getAttribute(aria_currentAttr));
2055 
2056     // If &quot;false&quot;, empty, or missing, return false state.
2057     if (currentStateValue.isEmpty() || currentStateValue == &quot;false&quot;)
2058         return AccessibilityCurrentState::False;
2059 
2060     if (currentStateValue == &quot;page&quot;)
2061         return AccessibilityCurrentState::Page;
2062     if (currentStateValue == &quot;step&quot;)
2063         return AccessibilityCurrentState::Step;
2064     if (currentStateValue == &quot;location&quot;)
2065         return AccessibilityCurrentState::Location;
2066     if (currentStateValue == &quot;date&quot;)
2067         return AccessibilityCurrentState::Date;
2068     if (currentStateValue == &quot;time&quot;)
2069         return AccessibilityCurrentState::Time;
2070 
2071     // Any value not included in the list of allowed values should be treated as &quot;true&quot;.
2072     return AccessibilityCurrentState::True;
2073 }
2074 
2075 String AccessibilityObject::currentValue() const
2076 {
2077     switch (currentState()) {
2078     case AccessibilityCurrentState::False:
2079         return &quot;false&quot;;
2080     case AccessibilityCurrentState::Page:
2081         return &quot;page&quot;;
2082     case AccessibilityCurrentState::Step:
2083         return &quot;step&quot;;
2084     case AccessibilityCurrentState::Location:
2085         return &quot;location&quot;;
2086     case AccessibilityCurrentState::Time:
2087         return &quot;time&quot;;
2088     case AccessibilityCurrentState::Date:
2089         return &quot;date&quot;;
2090     default:
2091     case AccessibilityCurrentState::True:
2092         return &quot;true&quot;;
2093     }
2094 }
2095 
2096 bool AccessibilityObject::isModalDescendant(Node* modalNode) const
2097 {
2098     Node* node = this-&gt;node();
2099     if (!modalNode || !node)
2100         return false;
2101 
2102     if (node == modalNode)
2103         return true;
2104 
2105     // ARIA 1.1 aria-modal, indicates whether an element is modal when displayed.
2106     // For the decendants of the modal object, they should also be considered as aria-modal=true.
2107     return node-&gt;isDescendantOf(*modalNode);
2108 }
2109 
2110 bool AccessibilityObject::isModalNode() const
2111 {
2112     if (AXObjectCache* cache = axObjectCache())
2113         return node() &amp;&amp; cache-&gt;modalNode() == node();
2114 
2115     return false;
2116 }
2117 
2118 bool AccessibilityObject::ignoredFromModalPresence() const
2119 {
2120     // We shouldn&#39;t ignore the top node.
2121     if (!node() || !node()-&gt;parentNode())
2122         return false;
2123 
2124     AXObjectCache* cache = axObjectCache();
2125     if (!cache)
2126         return false;
2127 
2128     // modalNode is the current displayed modal dialog.
2129     Node* modalNode = cache-&gt;modalNode();
2130     if (!modalNode)
2131         return false;
2132 
2133     // We only want to ignore the objects within the same frame as the modal dialog.
2134     if (modalNode-&gt;document().frame() != this-&gt;frame())
2135         return false;
2136 
2137     return !isModalDescendant(modalNode);
2138 }
2139 
2140 bool AccessibilityObject::hasTagName(const QualifiedName&amp; tagName) const
2141 {
2142     Node* node = this-&gt;node();
2143     return is&lt;Element&gt;(node) &amp;&amp; downcast&lt;Element&gt;(*node).hasTagName(tagName);
2144 }
2145 
2146 bool AccessibilityObject::hasAttribute(const QualifiedName&amp; attribute) const
2147 {
2148     Node* node = this-&gt;node();
2149     if (!is&lt;Element&gt;(node))
2150         return false;
2151 
2152     return downcast&lt;Element&gt;(*node).hasAttributeWithoutSynchronization(attribute);
2153 }
2154 
2155 const AtomicString&amp; AccessibilityObject::getAttribute(const QualifiedName&amp; attribute) const
2156 {
2157     if (auto* element = this-&gt;element())
2158         return element-&gt;attributeWithoutSynchronization(attribute);
2159     return nullAtom();
2160 }
2161 
2162 bool AccessibilityObject::shouldDispatchAccessibilityEvent() const
2163 {
2164     bool shouldDispatch = RuntimeEnabledFeatures::sharedFeatures().accessibilityObjectModelEnabled();
2165 #if ENABLE(ACCESSIBILITY_EVENTS)
2166     return shouldDispatch &amp;= this-&gt;page()-&gt;settings().accessibilityEventsEnabled();
2167 #endif
2168     return shouldDispatch;
2169 }
2170 
2171 bool AccessibilityObject::dispatchAccessibilityEvent(Event&amp; event) const
2172 {
2173     if (!shouldDispatchAccessibilityEvent())
2174         return false;
2175 
2176     Vector&lt;Element*&gt; eventPath;
2177     for (auto* parentObject = this; parentObject; parentObject = parentObject-&gt;parentObject()) {
2178         if (parentObject-&gt;isWebArea())
2179             break;
2180         if (auto* parentElement = parentObject-&gt;element())
2181             eventPath.append(parentElement);
2182     }
2183 
2184     if (!eventPath.size())
2185         return false;
2186 
2187     EventDispatcher::dispatchEvent(eventPath, event);
2188 
2189     // return true if preventDefault() was called, so that we don&#39;t execute the fallback behavior.
2190     return event.defaultPrevented();
2191 }
2192 
2193 bool AccessibilityObject::dispatchAccessibilityEventWithType(AccessibilityEventType type) const
2194 {
2195     AtomicString eventName;
2196     switch (type) {
2197     case AccessibilityEventType::ContextMenu:
2198         eventName = eventNames().accessiblecontextmenuEvent;
2199         break;
2200     case AccessibilityEventType::Click:
2201         eventName = eventNames().accessibleclickEvent;
2202         break;
2203     case AccessibilityEventType::Decrement:
2204         eventName = eventNames().accessibledecrementEvent;
2205         break;
2206     case AccessibilityEventType::Dismiss:
2207         eventName = eventNames().accessibledismissEvent;
2208         break;
2209     case AccessibilityEventType::Focus:
2210         eventName = eventNames().accessiblefocusEvent;
2211         break;
2212     case AccessibilityEventType::Increment:
2213         eventName = eventNames().accessibleincrementEvent;
2214         break;
2215     case AccessibilityEventType::ScrollIntoView:
2216         eventName = eventNames().accessiblescrollintoviewEvent;
2217         break;
2218     case AccessibilityEventType::Select:
2219         eventName = eventNames().accessibleselectEvent;
2220         break;
2221     default:
2222         return false;
2223     }
2224 
2225     auto event = Event::create(eventName, Event::CanBubble::Yes, Event::IsCancelable::Yes);
2226     return dispatchAccessibilityEvent(event);
2227 }
2228 
2229 bool AccessibilityObject::dispatchAccessibleSetValueEvent(const String&amp; value) const
2230 {
2231     if (!canSetValueAttribute())
2232         return false;
2233     auto event = AccessibleSetValueEvent::create(eventNames().accessiblesetvalueEvent, value);
2234     return dispatchAccessibilityEvent(event);
2235 }
2236 
2237 // Lacking concrete evidence of orientation, horizontal means width &gt; height. vertical is height &gt; width;
2238 AccessibilityOrientation AccessibilityObject::orientation() const
2239 {
2240     LayoutRect bounds = elementRect();
2241     if (bounds.size().width() &gt; bounds.size().height())
2242         return AccessibilityOrientation::Horizontal;
2243     if (bounds.size().height() &gt; bounds.size().width())
2244         return AccessibilityOrientation::Vertical;
2245 
2246     return AccessibilityOrientation::Undefined;
2247 }
2248 
2249 bool AccessibilityObject::isDescendantOfObject(const AccessibilityObject* axObject) const
2250 {
2251     if (!axObject || !axObject-&gt;hasChildren())
2252         return false;
2253 
2254     return AccessibilityObject::matchedParent(*this, false, [axObject] (const AccessibilityObject&amp; object) {
2255         return &amp;object == axObject;
2256     }) != nullptr;
2257 }
2258 
2259 bool AccessibilityObject::isAncestorOfObject(const AccessibilityObject* axObject) const
2260 {
2261     if (!axObject)
2262         return false;
2263 
2264     return this == axObject || axObject-&gt;isDescendantOfObject(this);
2265 }
2266 
2267 AccessibilityObject* AccessibilityObject::firstAnonymousBlockChild() const
2268 {
2269     for (AccessibilityObject* child = firstChild(); child; child = child-&gt;nextSibling()) {
2270         if (child-&gt;renderer() &amp;&amp; child-&gt;renderer()-&gt;isAnonymousBlock())
2271             return child;
2272     }
2273     return nullptr;
2274 }
2275 
2276 using ARIARoleMap = HashMap&lt;String, AccessibilityRole, ASCIICaseInsensitiveHash&gt;;
2277 using ARIAReverseRoleMap = HashMap&lt;AccessibilityRole, String, DefaultHash&lt;int&gt;::Hash, WTF::UnsignedWithZeroKeyHashTraits&lt;int&gt;&gt;;
2278 
2279 static ARIARoleMap* gAriaRoleMap = nullptr;
2280 static ARIAReverseRoleMap* gAriaReverseRoleMap = nullptr;
2281 
2282 struct RoleEntry {
2283     String ariaRole;
2284     AccessibilityRole webcoreRole;
2285 };
2286 
2287 static void initializeRoleMap()
2288 {
2289     if (gAriaRoleMap)
2290         return;
2291     ASSERT(!gAriaReverseRoleMap);
2292 
2293     const RoleEntry roles[] = {
2294         { &quot;alert&quot;, AccessibilityRole::ApplicationAlert },
2295         { &quot;alertdialog&quot;, AccessibilityRole::ApplicationAlertDialog },
2296         { &quot;application&quot;, AccessibilityRole::WebApplication },
2297         { &quot;article&quot;, AccessibilityRole::DocumentArticle },
2298         { &quot;banner&quot;, AccessibilityRole::LandmarkBanner },
2299         { &quot;blockquote&quot;, AccessibilityRole::Blockquote },
2300         { &quot;button&quot;, AccessibilityRole::Button },
2301         { &quot;caption&quot;, AccessibilityRole::Caption },
2302         { &quot;checkbox&quot;, AccessibilityRole::CheckBox },
2303         { &quot;complementary&quot;, AccessibilityRole::LandmarkComplementary },
2304         { &quot;contentinfo&quot;, AccessibilityRole::LandmarkContentInfo },
2305         { &quot;dialog&quot;, AccessibilityRole::ApplicationDialog },
2306         { &quot;directory&quot;, AccessibilityRole::Directory },
2307         // The &#39;doc-*&#39; roles are defined the ARIA DPUB mobile: https://www.w3.org/TR/dpub-aam-1.0/
2308         // Editor&#39;s draft is currently at https://rawgit.com/w3c/aria/master/dpub-aam/dpub-aam.html
2309         { &quot;doc-abstract&quot;, AccessibilityRole::ApplicationTextGroup },
2310         { &quot;doc-acknowledgments&quot;, AccessibilityRole::LandmarkDocRegion },
2311         { &quot;doc-afterword&quot;, AccessibilityRole::LandmarkDocRegion },
2312         { &quot;doc-appendix&quot;, AccessibilityRole::LandmarkDocRegion },
2313         { &quot;doc-backlink&quot;, AccessibilityRole::WebCoreLink },
2314         { &quot;doc-biblioentry&quot;, AccessibilityRole::ListItem },
2315         { &quot;doc-bibliography&quot;, AccessibilityRole::LandmarkDocRegion },
2316         { &quot;doc-biblioref&quot;, AccessibilityRole::WebCoreLink },
2317         { &quot;doc-chapter&quot;, AccessibilityRole::LandmarkDocRegion },
2318         { &quot;doc-colophon&quot;, AccessibilityRole::ApplicationTextGroup },
2319         { &quot;doc-conclusion&quot;, AccessibilityRole::LandmarkDocRegion },
2320         { &quot;doc-cover&quot;, AccessibilityRole::Image },
2321         { &quot;doc-credit&quot;, AccessibilityRole::ApplicationTextGroup },
2322         { &quot;doc-credits&quot;, AccessibilityRole::LandmarkDocRegion },
2323         { &quot;doc-dedication&quot;, AccessibilityRole::ApplicationTextGroup },
2324         { &quot;doc-endnote&quot;, AccessibilityRole::ListItem },
2325         { &quot;doc-endnotes&quot;, AccessibilityRole::LandmarkDocRegion },
2326         { &quot;doc-epigraph&quot;, AccessibilityRole::ApplicationTextGroup },
2327         { &quot;doc-epilogue&quot;, AccessibilityRole::LandmarkDocRegion },
2328         { &quot;doc-errata&quot;, AccessibilityRole::LandmarkDocRegion },
2329         { &quot;doc-example&quot;, AccessibilityRole::ApplicationTextGroup },
2330         { &quot;doc-footnote&quot;, AccessibilityRole::Footnote },
2331         { &quot;doc-foreword&quot;, AccessibilityRole::LandmarkDocRegion },
2332         { &quot;doc-glossary&quot;, AccessibilityRole::LandmarkDocRegion },
2333         { &quot;doc-glossref&quot;, AccessibilityRole::WebCoreLink },
2334         { &quot;doc-index&quot;, AccessibilityRole::LandmarkNavigation },
2335         { &quot;doc-introduction&quot;, AccessibilityRole::LandmarkDocRegion },
2336         { &quot;doc-noteref&quot;, AccessibilityRole::WebCoreLink },
2337         { &quot;doc-notice&quot;, AccessibilityRole::DocumentNote },
2338         { &quot;doc-pagebreak&quot;, AccessibilityRole::Splitter },
2339         { &quot;doc-pagelist&quot;, AccessibilityRole::LandmarkNavigation },
2340         { &quot;doc-part&quot;, AccessibilityRole::LandmarkDocRegion },
2341         { &quot;doc-preface&quot;, AccessibilityRole::LandmarkDocRegion },
2342         { &quot;doc-prologue&quot;, AccessibilityRole::LandmarkDocRegion },
2343         { &quot;doc-pullquote&quot;, AccessibilityRole::ApplicationTextGroup },
2344         { &quot;doc-qna&quot;, AccessibilityRole::ApplicationTextGroup },
2345         { &quot;doc-subtitle&quot;, AccessibilityRole::Heading },
2346         { &quot;doc-tip&quot;, AccessibilityRole::DocumentNote },
2347         { &quot;doc-toc&quot;, AccessibilityRole::LandmarkNavigation },
2348         { &quot;figure&quot;, AccessibilityRole::Figure },
2349         // The mappings for &#39;graphics-*&#39; roles are defined in this spec: https://w3c.github.io/graphics-aam/
2350         { &quot;graphics-document&quot;, AccessibilityRole::GraphicsDocument },
2351         { &quot;graphics-object&quot;, AccessibilityRole::GraphicsObject },
2352         { &quot;graphics-symbol&quot;, AccessibilityRole::GraphicsSymbol },
2353         { &quot;grid&quot;, AccessibilityRole::Grid },
2354         { &quot;gridcell&quot;, AccessibilityRole::GridCell },
2355         { &quot;table&quot;, AccessibilityRole::Table },
2356         { &quot;cell&quot;, AccessibilityRole::Cell },
2357         { &quot;columnheader&quot;, AccessibilityRole::ColumnHeader },
2358         { &quot;combobox&quot;, AccessibilityRole::ComboBox },
2359         { &quot;definition&quot;, AccessibilityRole::Definition },
2360         { &quot;document&quot;, AccessibilityRole::Document },
2361         { &quot;feed&quot;, AccessibilityRole::Feed },
2362         { &quot;form&quot;, AccessibilityRole::Form },
2363         { &quot;rowheader&quot;, AccessibilityRole::RowHeader },
2364         { &quot;group&quot;, AccessibilityRole::ApplicationGroup },
2365         { &quot;heading&quot;, AccessibilityRole::Heading },
2366         { &quot;img&quot;, AccessibilityRole::Image },
2367         { &quot;link&quot;, AccessibilityRole::WebCoreLink },
2368         { &quot;list&quot;, AccessibilityRole::List },
2369         { &quot;listitem&quot;, AccessibilityRole::ListItem },
2370         { &quot;listbox&quot;, AccessibilityRole::ListBox },
2371         { &quot;log&quot;, AccessibilityRole::ApplicationLog },
2372         { &quot;main&quot;, AccessibilityRole::LandmarkMain },
2373         { &quot;marquee&quot;, AccessibilityRole::ApplicationMarquee },
2374         { &quot;math&quot;, AccessibilityRole::DocumentMath },
2375         { &quot;menu&quot;, AccessibilityRole::Menu },
2376         { &quot;menubar&quot;, AccessibilityRole::MenuBar },
2377         { &quot;menuitem&quot;, AccessibilityRole::MenuItem },
2378         { &quot;menuitemcheckbox&quot;, AccessibilityRole::MenuItemCheckbox },
2379         { &quot;menuitemradio&quot;, AccessibilityRole::MenuItemRadio },
2380         { &quot;none&quot;, AccessibilityRole::Presentational },
2381         { &quot;note&quot;, AccessibilityRole::DocumentNote },
2382         { &quot;navigation&quot;, AccessibilityRole::LandmarkNavigation },
2383         { &quot;option&quot;, AccessibilityRole::ListBoxOption },
2384         { &quot;paragraph&quot;, AccessibilityRole::Paragraph },
2385         { &quot;presentation&quot;, AccessibilityRole::Presentational },
2386         { &quot;progressbar&quot;, AccessibilityRole::ProgressIndicator },
2387         { &quot;radio&quot;, AccessibilityRole::RadioButton },
2388         { &quot;radiogroup&quot;, AccessibilityRole::RadioGroup },
2389         { &quot;region&quot;, AccessibilityRole::LandmarkRegion },
2390         { &quot;row&quot;, AccessibilityRole::Row },
2391         { &quot;rowgroup&quot;, AccessibilityRole::RowGroup },
2392         { &quot;scrollbar&quot;, AccessibilityRole::ScrollBar },
2393         { &quot;search&quot;, AccessibilityRole::LandmarkSearch },
2394         { &quot;searchbox&quot;, AccessibilityRole::SearchField },
2395         { &quot;separator&quot;, AccessibilityRole::Splitter },
2396         { &quot;slider&quot;, AccessibilityRole::Slider },
2397         { &quot;spinbutton&quot;, AccessibilityRole::SpinButton },
2398         { &quot;status&quot;, AccessibilityRole::ApplicationStatus },
2399         { &quot;switch&quot;, AccessibilityRole::Switch },
2400         { &quot;tab&quot;, AccessibilityRole::Tab },
2401         { &quot;tablist&quot;, AccessibilityRole::TabList },
2402         { &quot;tabpanel&quot;, AccessibilityRole::TabPanel },
2403         { &quot;text&quot;, AccessibilityRole::StaticText },
2404         { &quot;textbox&quot;, AccessibilityRole::TextArea },
2405         { &quot;term&quot;, AccessibilityRole::Term },
2406         { &quot;timer&quot;, AccessibilityRole::ApplicationTimer },
2407         { &quot;toolbar&quot;, AccessibilityRole::Toolbar },
2408         { &quot;tooltip&quot;, AccessibilityRole::UserInterfaceTooltip },
2409         { &quot;tree&quot;, AccessibilityRole::Tree },
2410         { &quot;treegrid&quot;, AccessibilityRole::TreeGrid },
2411         { &quot;treeitem&quot;, AccessibilityRole::TreeItem }
2412     };
2413 
2414     gAriaRoleMap = new ARIARoleMap;
2415     gAriaReverseRoleMap = new ARIAReverseRoleMap;
2416     size_t roleLength = WTF_ARRAY_LENGTH(roles);
2417     for (size_t i = 0; i &lt; roleLength; ++i) {
2418         gAriaRoleMap-&gt;set(roles[i].ariaRole, roles[i].webcoreRole);
2419         gAriaReverseRoleMap-&gt;set(static_cast&lt;int&gt;(roles[i].webcoreRole), roles[i].ariaRole);
2420     }
2421 }
2422 
2423 static ARIARoleMap&amp; ariaRoleMap()
2424 {
2425     initializeRoleMap();
2426     return *gAriaRoleMap;
2427 }
2428 
2429 static ARIAReverseRoleMap&amp; reverseAriaRoleMap()
2430 {
2431     initializeRoleMap();
2432     return *gAriaReverseRoleMap;
2433 }
2434 
2435 AccessibilityRole AccessibilityObject::ariaRoleToWebCoreRole(const String&amp; value)
2436 {
2437     ASSERT(!value.isEmpty());
2438     for (auto roleName : StringView(value).split(&#39; &#39;)) {
2439         AccessibilityRole role = ariaRoleMap().get&lt;ASCIICaseInsensitiveStringViewHashTranslator&gt;(roleName);
2440         if (static_cast&lt;int&gt;(role))
2441             return role;
2442     }
2443     return AccessibilityRole::Unknown;
2444 }
2445 
2446 String AccessibilityObject::computedRoleString() const
2447 {
2448     // FIXME: Need a few special cases that aren&#39;t in the RoleMap: option, etc. http://webkit.org/b/128296
2449     AccessibilityRole role = roleValue();
2450 
2451     // We do not compute a role string for generic block elements with user-agent assigned roles.
2452     if (role == AccessibilityRole::Group || role == AccessibilityRole::TextGroup)
2453         return &quot;&quot;;
2454 
2455     // We do compute a role string for block elements with author-provided roles.
2456     if (role == AccessibilityRole::ApplicationTextGroup
2457         || role == AccessibilityRole::Footnote
2458         || role == AccessibilityRole::GraphicsObject)
2459         return reverseAriaRoleMap().get(static_cast&lt;int&gt;(AccessibilityRole::ApplicationGroup));
2460 
2461     if (role == AccessibilityRole::GraphicsDocument)
2462         return reverseAriaRoleMap().get(static_cast&lt;int&gt;(AccessibilityRole::Document));
2463 
2464     if (role == AccessibilityRole::GraphicsSymbol)
2465         return reverseAriaRoleMap().get(static_cast&lt;int&gt;(AccessibilityRole::Image));
2466 
2467     if (role == AccessibilityRole::HorizontalRule)
2468         return reverseAriaRoleMap().get(static_cast&lt;int&gt;(AccessibilityRole::Splitter));
2469 
2470     if (role == AccessibilityRole::PopUpButton || role == AccessibilityRole::ToggleButton)
2471         return reverseAriaRoleMap().get(static_cast&lt;int&gt;(AccessibilityRole::Button));
2472 
2473     if (role == AccessibilityRole::LandmarkDocRegion)
2474         return reverseAriaRoleMap().get(static_cast&lt;int&gt;(AccessibilityRole::LandmarkRegion));
2475 
2476     return reverseAriaRoleMap().get(static_cast&lt;int&gt;(role));
2477 }
2478 
2479 bool AccessibilityObject::hasHighlighting() const
2480 {
2481     for (Node* node = this-&gt;node(); node; node = node-&gt;parentNode()) {
2482         if (node-&gt;hasTagName(markTag))
2483             return true;
2484     }
2485 
2486     return false;
2487 }
2488 
2489 String AccessibilityObject::roleDescription() const
2490 {
2491     return stripLeadingAndTrailingHTMLSpaces(getAttribute(aria_roledescriptionAttr));
2492 }
2493 
2494 bool nodeHasPresentationRole(Node* node)
2495 {
2496     return nodeHasRole(node, &quot;presentation&quot;) || nodeHasRole(node, &quot;none&quot;);
2497 }
2498 
2499 bool AccessibilityObject::supportsPressAction() const
2500 {
2501     if (isButton())
2502         return true;
2503     if (roleValue() == AccessibilityRole::Details)
2504         return true;
2505 
2506     Element* actionElement = this-&gt;actionElement();
2507     if (!actionElement)
2508         return false;
2509 
2510     // [Bug: 136247] Heuristic: element handlers that have more than one accessible descendant should not be exposed as supporting press.
2511     if (actionElement != element()) {
2512         if (AccessibilityObject* axObj = axObjectCache()-&gt;getOrCreate(actionElement)) {
2513             AccessibilityChildrenVector results;
2514             // Search within for immediate descendants that are static text. If we find more than one
2515             // then this is an event delegator actionElement and we should expose the press action.
2516             Vector&lt;AccessibilitySearchKey&gt; keys({ AccessibilitySearchKey::StaticText, AccessibilitySearchKey::Control, AccessibilitySearchKey::Graphic, AccessibilitySearchKey::Heading, AccessibilitySearchKey::Link });
2517             AccessibilitySearchCriteria criteria(axObj, AccessibilitySearchDirection::Next, emptyString(), 2, false, false);
2518             criteria.searchKeys = keys;
2519             axObj-&gt;findMatchingObjects(&amp;criteria, results);
2520             if (results.size() &gt; 1)
2521                 return false;
2522         }
2523     }
2524 
2525     // [Bug: 133613] Heuristic: If the action element is presentational, we shouldn&#39;t expose press as a supported action.
2526     return !nodeHasPresentationRole(actionElement);
2527 }
2528 
2529 bool AccessibilityObject::supportsDatetimeAttribute() const
2530 {
2531     return hasTagName(insTag) || hasTagName(delTag) || hasTagName(timeTag);
2532 }
2533 
2534 const AtomicString&amp; AccessibilityObject::datetimeAttributeValue() const
2535 {
2536     return getAttribute(datetimeAttr);
2537 }
2538 
2539 const AtomicString&amp; AccessibilityObject::linkRelValue() const
2540 {
2541     return getAttribute(relAttr);
2542 }
2543 
2544 const String AccessibilityObject::keyShortcutsValue() const
2545 {
2546     return getAttribute(aria_keyshortcutsAttr);
2547 }
2548 
2549 Element* AccessibilityObject::element() const
2550 {
2551     Node* node = this-&gt;node();
2552     if (is&lt;Element&gt;(node))
2553         return downcast&lt;Element&gt;(node);
2554     return nullptr;
2555 }
2556 
2557 bool AccessibilityObject::isValueAutofillAvailable() const
2558 {
2559     if (!isNativeTextControl())
2560         return false;
2561 
2562     Node* node = this-&gt;node();
2563     if (!is&lt;HTMLInputElement&gt;(node))
2564         return false;
2565 
2566     return downcast&lt;HTMLInputElement&gt;(*node).isAutoFillAvailable() || downcast&lt;HTMLInputElement&gt;(*node).autoFillButtonType() != AutoFillButtonType::None;
2567 }
2568 
2569 AutoFillButtonType AccessibilityObject::valueAutofillButtonType() const
2570 {
2571     if (!isValueAutofillAvailable())
2572         return AutoFillButtonType::None;
2573 
2574     return downcast&lt;HTMLInputElement&gt;(*this-&gt;node()).autoFillButtonType();
2575 }
2576 
2577 bool AccessibilityObject::isValueAutofilled() const
2578 {
2579     if (!isNativeTextControl())
2580         return false;
2581 
2582     Node* node = this-&gt;node();
2583     if (!is&lt;HTMLInputElement&gt;(node))
2584         return false;
2585 
2586     return downcast&lt;HTMLInputElement&gt;(*node).isAutoFilled();
2587 }
2588 
2589 const String AccessibilityObject::placeholderValue() const
2590 {
2591     const AtomicString&amp; placeholder = getAttribute(placeholderAttr);
2592     if (!placeholder.isEmpty())
2593         return placeholder;
2594 
2595     const AtomicString&amp; ariaPlaceholder = getAttribute(aria_placeholderAttr);
2596     if (!ariaPlaceholder.isEmpty())
2597         return ariaPlaceholder;
2598 
2599     return nullAtom();
2600 }
2601 
2602 bool AccessibilityObject::isInsideLiveRegion(bool excludeIfOff) const
2603 {
2604     return liveRegionAncestor(excludeIfOff);
2605 }
2606 
2607 AccessibilityObject* AccessibilityObject::liveRegionAncestor(bool excludeIfOff) const
2608 {
2609     return const_cast&lt;AccessibilityObject*&gt;(AccessibilityObject::matchedParent(*this, true, [excludeIfOff] (const AccessibilityObject&amp; object) {
2610         return object.supportsLiveRegion(excludeIfOff);
2611     }));
2612 }
2613 
2614 bool AccessibilityObject::supportsARIAAttributes() const
2615 {
2616     // This returns whether the element supports any global ARIA attributes.
2617     return supportsLiveRegion()
2618         || supportsARIADragging()
2619         || supportsARIADropping()
2620         || supportsARIAOwns()
2621         || hasAttribute(aria_atomicAttr)
2622         || hasAttribute(aria_busyAttr)
2623         || hasAttribute(aria_controlsAttr)
2624         || hasAttribute(aria_currentAttr)
2625         || hasAttribute(aria_describedbyAttr)
2626         || hasAttribute(aria_detailsAttr)
2627         || hasAttribute(aria_disabledAttr)
2628         || hasAttribute(aria_errormessageAttr)
2629         || hasAttribute(aria_flowtoAttr)
2630         || hasAttribute(aria_haspopupAttr)
2631         || hasAttribute(aria_invalidAttr)
2632         || hasAttribute(aria_labelAttr)
2633         || hasAttribute(aria_labelledbyAttr)
2634         || hasAttribute(aria_relevantAttr);
2635 }
2636 
2637 bool AccessibilityObject::liveRegionStatusIsEnabled(const AtomicString&amp; liveRegionStatus)
2638 {
2639     return equalLettersIgnoringASCIICase(liveRegionStatus, &quot;polite&quot;) || equalLettersIgnoringASCIICase(liveRegionStatus, &quot;assertive&quot;);
2640 }
2641 
2642 bool AccessibilityObject::supportsLiveRegion(bool excludeIfOff) const
2643 {
2644     const AtomicString&amp; liveRegionStatusValue = liveRegionStatus();
2645     return excludeIfOff ? liveRegionStatusIsEnabled(liveRegionStatusValue) : !liveRegionStatusValue.isEmpty();
2646 }
2647 
2648 AccessibilityObject* AccessibilityObject::elementAccessibilityHitTest(const IntPoint&amp; point) const
2649 {
2650     // Send the hit test back into the sub-frame if necessary.
2651     if (isAttachment()) {
2652         Widget* widget = widgetForAttachmentView();
2653         // Normalize the point for the widget&#39;s bounds.
2654         if (widget &amp;&amp; widget-&gt;isFrameView()) {
2655             if (AXObjectCache* cache = axObjectCache())
2656                 return cache-&gt;getOrCreate(widget)-&gt;accessibilityHitTest(IntPoint(point - widget-&gt;frameRect().location()));
2657         }
2658     }
2659 
2660     // Check if there are any mock elements that need to be handled.
2661     for (const auto&amp; child : m_children) {
2662         if (child-&gt;isMockObject() &amp;&amp; child-&gt;elementRect().contains(point))
2663             return child-&gt;elementAccessibilityHitTest(point);
2664     }
2665 
2666     return const_cast&lt;AccessibilityObject*&gt;(this);
2667 }
2668 
2669 AXObjectCache* AccessibilityObject::axObjectCache() const
2670 {
2671     auto* document = this-&gt;document();
2672     return document ? document-&gt;axObjectCache() : nullptr;
2673 }
2674 
2675 AccessibilityObject* AccessibilityObject::focusedUIElement() const
2676 {
2677     auto* page = this-&gt;page();
2678     return page ? AXObjectCache::focusedUIElementForPage(page) : nullptr;
2679 }
2680 
2681 AccessibilitySortDirection AccessibilityObject::sortDirection() const
2682 {
2683     AccessibilityRole role = roleValue();
2684     if (role != AccessibilityRole::RowHeader &amp;&amp; role != AccessibilityRole::ColumnHeader)
2685         return AccessibilitySortDirection::Invalid;
2686 
2687     const AtomicString&amp; sortAttribute = getAttribute(aria_sortAttr);
2688     if (equalLettersIgnoringASCIICase(sortAttribute, &quot;ascending&quot;))
2689         return AccessibilitySortDirection::Ascending;
2690     if (equalLettersIgnoringASCIICase(sortAttribute, &quot;descending&quot;))
2691         return AccessibilitySortDirection::Descending;
2692     if (equalLettersIgnoringASCIICase(sortAttribute, &quot;other&quot;))
2693         return AccessibilitySortDirection::Other;
2694 
2695     return AccessibilitySortDirection::None;
2696 }
2697 
2698 bool AccessibilityObject::supportsRangeValue() const
2699 {
2700     return isProgressIndicator()
2701         || isSlider()
2702         || isScrollbar()
2703         || isSpinButton()
2704         || (isSplitter() &amp;&amp; canSetFocusAttribute())
2705         || isAttachmentElement();
2706 }
2707 
2708 bool AccessibilityObject::supportsHasPopup() const
2709 {
2710     return hasAttribute(aria_haspopupAttr) || isComboBox();
2711 }
2712 
2713 String AccessibilityObject::hasPopupValue() const
2714 {
2715     const AtomicString&amp; hasPopup = getAttribute(aria_haspopupAttr);
2716     if (equalLettersIgnoringASCIICase(hasPopup, &quot;true&quot;)
2717         || equalLettersIgnoringASCIICase(hasPopup, &quot;dialog&quot;)
2718         || equalLettersIgnoringASCIICase(hasPopup, &quot;grid&quot;)
2719         || equalLettersIgnoringASCIICase(hasPopup, &quot;listbox&quot;)
2720         || equalLettersIgnoringASCIICase(hasPopup, &quot;menu&quot;)
2721         || equalLettersIgnoringASCIICase(hasPopup, &quot;tree&quot;))
2722         return hasPopup;
2723 
2724     // In ARIA 1.1, the implicit value for combobox became &quot;listbox.&quot;
2725     if (isComboBox() &amp;&amp; hasPopup.isEmpty())
2726         return &quot;listbox&quot;;
2727 
2728     // The spec states that &quot;User agents must treat any value of aria-haspopup that is not
2729     // included in the list of allowed values, including an empty string, as if the value
2730     // false had been provided.&quot;
2731     return &quot;false&quot;;
2732 }
2733 
2734 bool AccessibilityObject::supportsSetSize() const
2735 {
2736     return hasAttribute(aria_setsizeAttr);
2737 }
2738 
2739 bool AccessibilityObject::supportsPosInSet() const
2740 {
2741     return hasAttribute(aria_posinsetAttr);
2742 }
2743 
2744 int AccessibilityObject::setSize() const
2745 {
2746     return getAttribute(aria_setsizeAttr).toInt();
2747 }
2748 
2749 int AccessibilityObject::posInSet() const
2750 {
2751     return getAttribute(aria_posinsetAttr).toInt();
2752 }
2753 
2754 const AtomicString&amp; AccessibilityObject::identifierAttribute() const
2755 {
2756     return getAttribute(idAttr);
2757 }
2758 
2759 void AccessibilityObject::classList(Vector&lt;String&gt;&amp; classList) const
2760 {
2761     Node* node = this-&gt;node();
2762     if (!is&lt;Element&gt;(node))
2763         return;
2764 
2765     Element* element = downcast&lt;Element&gt;(node);
2766     DOMTokenList&amp; list = element-&gt;classList();
2767     unsigned length = list.length();
2768     for (unsigned k = 0; k &lt; length; k++)
2769         classList.append(list.item(k).string());
2770 }
2771 
2772 bool AccessibilityObject::supportsPressed() const
2773 {
2774     const AtomicString&amp; expanded = getAttribute(aria_pressedAttr);
2775     return equalLettersIgnoringASCIICase(expanded, &quot;true&quot;) || equalLettersIgnoringASCIICase(expanded, &quot;false&quot;);
2776 }
2777 
2778 bool AccessibilityObject::supportsExpanded() const
2779 {
2780     // Undefined values should not result in this attribute being exposed to ATs according to ARIA.
2781     const AtomicString&amp; expanded = getAttribute(aria_expandedAttr);
2782     if (equalLettersIgnoringASCIICase(expanded, &quot;true&quot;) || equalLettersIgnoringASCIICase(expanded, &quot;false&quot;))
2783         return true;
2784     switch (roleValue()) {
2785     case AccessibilityRole::ComboBox:
2786     case AccessibilityRole::DisclosureTriangle:
2787     case AccessibilityRole::Details:
2788         return true;
2789     default:
2790         return false;
2791     }
2792 }
2793 
2794 bool AccessibilityObject::isExpanded() const
2795 {
2796     if (equalLettersIgnoringASCIICase(getAttribute(aria_expandedAttr), &quot;true&quot;))
2797         return true;
2798 
2799     if (is&lt;HTMLDetailsElement&gt;(node()))
2800         return downcast&lt;HTMLDetailsElement&gt;(node())-&gt;isOpen();
2801 
2802     // Summary element should use its details parent&#39;s expanded status.
2803     if (isSummary()) {
2804         if (const AccessibilityObject* parent = AccessibilityObject::matchedParent(*this, false, [] (const AccessibilityObject&amp; object) {
2805             return is&lt;HTMLDetailsElement&gt;(object.node());
2806         }))
2807             return parent-&gt;isExpanded();
2808     }
2809 
2810     return false;
2811 }
2812 
2813 bool AccessibilityObject::supportsChecked() const
2814 {
2815     switch (roleValue()) {
2816     case AccessibilityRole::CheckBox:
2817     case AccessibilityRole::MenuItemCheckbox:
2818     case AccessibilityRole::MenuItemRadio:
2819     case AccessibilityRole::RadioButton:
2820     case AccessibilityRole::Switch:
2821         return true;
2822     default:
2823         return false;
2824     }
2825 }
2826 
2827 AccessibilityButtonState AccessibilityObject::checkboxOrRadioValue() const
2828 {
2829     // If this is a real checkbox or radio button, AccessibilityRenderObject will handle.
2830     // If it&#39;s an ARIA checkbox, radio, or switch the aria-checked attribute should be used.
2831     // If it&#39;s a toggle button, the aria-pressed attribute is consulted.
2832 
2833     if (isToggleButton()) {
2834         const AtomicString&amp; ariaPressed = getAttribute(aria_pressedAttr);
2835         if (equalLettersIgnoringASCIICase(ariaPressed, &quot;true&quot;))
2836             return AccessibilityButtonState::On;
2837         if (equalLettersIgnoringASCIICase(ariaPressed, &quot;mixed&quot;))
2838             return AccessibilityButtonState::Mixed;
2839         return AccessibilityButtonState::Off;
2840     }
2841 
2842     const AtomicString&amp; result = getAttribute(aria_checkedAttr);
2843     if (equalLettersIgnoringASCIICase(result, &quot;true&quot;))
2844         return AccessibilityButtonState::On;
2845     if (equalLettersIgnoringASCIICase(result, &quot;mixed&quot;)) {
2846         // ARIA says that radio, menuitemradio, and switch elements must NOT expose button state mixed.
2847         AccessibilityRole ariaRole = ariaRoleAttribute();
2848         if (ariaRole == AccessibilityRole::RadioButton || ariaRole == AccessibilityRole::MenuItemRadio || ariaRole == AccessibilityRole::Switch)
2849             return AccessibilityButtonState::Off;
2850         return AccessibilityButtonState::Mixed;
2851     }
2852 
2853     if (isIndeterminate())
2854         return AccessibilityButtonState::Mixed;
2855 
2856     return AccessibilityButtonState::Off;
2857 }
2858 
2859 // This is a 1-dimensional scroll offset helper function that&#39;s applied
2860 // separately in the horizontal and vertical directions, because the
2861 // logic is the same. The goal is to compute the best scroll offset
2862 // in order to make an object visible within a viewport.
2863 //
2864 // If the object is already fully visible, returns the same scroll
2865 // offset.
2866 //
2867 // In case the whole object cannot fit, you can specify a
2868 // subfocus - a smaller region within the object that should
2869 // be prioritized. If the whole object can fit, the subfocus is
2870 // ignored.
2871 //
2872 // If possible, the object and subfocus are centered within the
2873 // viewport.
2874 //
2875 // Example 1: the object is already visible, so nothing happens.
2876 //   +----------Viewport---------+
2877 //                 +---Object---+
2878 //                 +--SubFocus--+
2879 //
2880 // Example 2: the object is not fully visible, so it&#39;s centered
2881 // within the viewport.
2882 //   Before:
2883 //   +----------Viewport---------+
2884 //                         +---Object---+
2885 //                         +--SubFocus--+
2886 //
2887 //   After:
2888 //                 +----------Viewport---------+
2889 //                         +---Object---+
2890 //                         +--SubFocus--+
2891 //
2892 // Example 3: the object is larger than the viewport, so the
2893 // viewport moves to show as much of the object as possible,
2894 // while also trying to center the subfocus.
2895 //   Before:
2896 //   +----------Viewport---------+
2897 //     +---------------Object--------------+
2898 //                         +-SubFocus-+
2899 //
2900 //   After:
2901 //             +----------Viewport---------+
2902 //     +---------------Object--------------+
2903 //                         +-SubFocus-+
2904 //
2905 // When constraints cannot be fully satisfied, the min
2906 // (left/top) position takes precedence over the max (right/bottom).
2907 //
2908 // Note that the return value represents the ideal new scroll offset.
2909 // This may be out of range - the calling function should clip this
2910 // to the available range.
2911 static int computeBestScrollOffset(int currentScrollOffset, int subfocusMin, int subfocusMax, int objectMin, int objectMax, int viewportMin, int viewportMax)
2912 {
2913     int viewportSize = viewportMax - viewportMin;
2914 
2915     // If the object size is larger than the viewport size, consider
2916     // only a portion that&#39;s as large as the viewport, centering on
2917     // the subfocus as much as possible.
2918     if (objectMax - objectMin &gt; viewportSize) {
2919         // Since it&#39;s impossible to fit the whole object in the
2920         // viewport, exit now if the subfocus is already within the viewport.
2921         if (subfocusMin - currentScrollOffset &gt;= viewportMin &amp;&amp; subfocusMax - currentScrollOffset &lt;= viewportMax)
2922             return currentScrollOffset;
2923 
2924         // Subfocus must be within focus.
2925         subfocusMin = std::max(subfocusMin, objectMin);
2926         subfocusMax = std::min(subfocusMax, objectMax);
2927 
2928         // Subfocus must be no larger than the viewport size; favor top/left.
2929         if (subfocusMax - subfocusMin &gt; viewportSize)
2930             subfocusMax = subfocusMin + viewportSize;
2931 
2932         // Compute the size of an object centered on the subfocus, the size of the viewport.
2933         int centeredObjectMin = (subfocusMin + subfocusMax - viewportSize) / 2;
2934         int centeredObjectMax = centeredObjectMin + viewportSize;
2935 
2936         objectMin = std::max(objectMin, centeredObjectMin);
2937         objectMax = std::min(objectMax, centeredObjectMax);
2938     }
2939 
2940     // Exit now if the focus is already within the viewport.
2941     if (objectMin - currentScrollOffset &gt;= viewportMin
2942         &amp;&amp; objectMax - currentScrollOffset &lt;= viewportMax)
2943         return currentScrollOffset;
2944 
2945     // Center the object in the viewport.
2946     return (objectMin + objectMax - viewportMin - viewportMax) / 2;
2947 }
2948 
2949 bool AccessibilityObject::isOnscreen() const
2950 {
2951     bool isOnscreen = true;
2952 
2953     // To figure out if the element is onscreen, we start by building of a stack starting with the
2954     // element, and then include every scrollable parent in the hierarchy.
2955     Vector&lt;const AccessibilityObject*&gt; objects;
2956 
2957     objects.append(this);
2958     for (AccessibilityObject* parentObject = this-&gt;parentObject(); parentObject; parentObject = parentObject-&gt;parentObject()) {
2959         if (parentObject-&gt;getScrollableAreaIfScrollable())
2960             objects.append(parentObject);
2961     }
2962 
2963     // Now, go back through that chain and make sure each inner object is within the
2964     // visible bounds of the outer object.
2965     size_t levels = objects.size() - 1;
2966 
2967     for (size_t i = levels; i &gt;= 1; i--) {
2968         const AccessibilityObject* outer = objects[i];
2969         const AccessibilityObject* inner = objects[i - 1];
2970         // FIXME: unclear if we need LegacyIOSDocumentVisibleRect.
2971         const IntRect outerRect = i &lt; levels ? snappedIntRect(outer-&gt;boundingBoxRect()) : outer-&gt;getScrollableAreaIfScrollable()-&gt;visibleContentRect(ScrollableArea::LegacyIOSDocumentVisibleRect);
2972         const IntRect innerRect = snappedIntRect(inner-&gt;isAccessibilityScrollView() ? inner-&gt;parentObject()-&gt;boundingBoxRect() : inner-&gt;boundingBoxRect());
2973 
2974         if (!outerRect.intersects(innerRect)) {
2975             isOnscreen = false;
2976             break;
2977         }
2978     }
2979 
2980     return isOnscreen;
2981 }
2982 
2983 void AccessibilityObject::scrollToMakeVisible() const
2984 {
2985     if (dispatchAccessibilityEventWithType(AccessibilityEventType::ScrollIntoView))
2986         return;
2987 
2988     if (isScrollView() &amp;&amp; parentObject())
2989         parentObject()-&gt;scrollToMakeVisible();
2990 
2991     if (auto* renderer = this-&gt;renderer())
2992         renderer-&gt;scrollRectToVisible(boundingBoxRect(), false, { SelectionRevealMode::Reveal, ScrollAlignment::alignCenterIfNeeded, ScrollAlignment::alignCenterIfNeeded, ShouldAllowCrossOriginScrolling::Yes });
2993 }
2994 
2995 void AccessibilityObject::scrollToMakeVisibleWithSubFocus(const IntRect&amp; subfocus) const
2996 {
2997     // Search up the parent chain until we find the first one that&#39;s scrollable.
2998     AccessibilityObject* scrollParent = parentObject();
2999     ScrollableArea* scrollableArea;
3000     for (scrollableArea = nullptr;
3001          scrollParent &amp;&amp; !(scrollableArea = scrollParent-&gt;getScrollableAreaIfScrollable());
3002          scrollParent = scrollParent-&gt;parentObject()) { }
3003     if (!scrollableArea)
3004         return;
3005 
3006     LayoutRect objectRect = boundingBoxRect();
3007     IntPoint scrollPosition = scrollableArea-&gt;scrollPosition();
3008     // FIXME: unclear if we need LegacyIOSDocumentVisibleRect.
3009     IntRect scrollVisibleRect = scrollableArea-&gt;visibleContentRect(ScrollableArea::LegacyIOSDocumentVisibleRect);
3010 
3011     if (!scrollParent-&gt;isScrollView()) {
3012         objectRect.moveBy(scrollPosition);
3013         objectRect.moveBy(-snappedIntRect(scrollParent-&gt;elementRect()).location());
3014     }
3015 
3016     int desiredX = computeBestScrollOffset(
3017         scrollPosition.x(),
3018         objectRect.x() + subfocus.x(), objectRect.x() + subfocus.maxX(),
3019         objectRect.x(), objectRect.maxX(),
3020         0, scrollVisibleRect.width());
3021     int desiredY = computeBestScrollOffset(
3022         scrollPosition.y(),
3023         objectRect.y() + subfocus.y(), objectRect.y() + subfocus.maxY(),
3024         objectRect.y(), objectRect.maxY(),
3025         0, scrollVisibleRect.height());
3026 
3027     scrollParent-&gt;scrollTo(IntPoint(desiredX, desiredY));
3028 
3029     // Convert the subfocus into the coordinates of the scroll parent.
3030     IntRect newSubfocus = subfocus;
3031     IntRect newElementRect = snappedIntRect(elementRect());
3032     IntRect scrollParentRect = snappedIntRect(scrollParent-&gt;elementRect());
3033     newSubfocus.move(newElementRect.x(), newElementRect.y());
3034     newSubfocus.move(-scrollParentRect.x(), -scrollParentRect.y());
3035 
3036     // Recursively make sure the scroll parent itself is visible.
3037     if (scrollParent-&gt;parentObject())
3038         scrollParent-&gt;scrollToMakeVisibleWithSubFocus(newSubfocus);
3039 }
3040 
3041 void AccessibilityObject::scrollToGlobalPoint(const IntPoint&amp; globalPoint) const
3042 {
3043     // Search up the parent chain and create a vector of all scrollable parent objects
3044     // and ending with this object itself.
3045     Vector&lt;const AccessibilityObject*&gt; objects;
3046 
3047     objects.append(this);
3048     for (AccessibilityObject* parentObject = this-&gt;parentObject(); parentObject; parentObject = parentObject-&gt;parentObject()) {
3049         if (parentObject-&gt;getScrollableAreaIfScrollable())
3050             objects.append(parentObject);
3051     }
3052 
3053     objects.reverse();
3054 
3055     // Start with the outermost scrollable (the main window) and try to scroll the
3056     // next innermost object to the given point.
3057     int offsetX = 0, offsetY = 0;
3058     IntPoint point = globalPoint;
3059     size_t levels = objects.size() - 1;
3060     for (size_t i = 0; i &lt; levels; i++) {
3061         const AccessibilityObject* outer = objects[i];
3062         const AccessibilityObject* inner = objects[i + 1];
3063 
3064         ScrollableArea* scrollableArea = outer-&gt;getScrollableAreaIfScrollable();
3065 
3066         LayoutRect innerRect = inner-&gt;isAccessibilityScrollView() ? inner-&gt;parentObject()-&gt;boundingBoxRect() : inner-&gt;boundingBoxRect();
3067         LayoutRect objectRect = innerRect;
3068         IntPoint scrollPosition = scrollableArea-&gt;scrollPosition();
3069 
3070         // Convert the object rect into local coordinates.
3071         objectRect.move(offsetX, offsetY);
3072         if (!outer-&gt;isAccessibilityScrollView())
3073             objectRect.move(scrollPosition.x(), scrollPosition.y());
3074 
3075         int desiredX = computeBestScrollOffset(
3076             0,
3077             objectRect.x(), objectRect.maxX(),
3078             objectRect.x(), objectRect.maxX(),
3079             point.x(), point.x());
3080         int desiredY = computeBestScrollOffset(
3081             0,
3082             objectRect.y(), objectRect.maxY(),
3083             objectRect.y(), objectRect.maxY(),
3084             point.y(), point.y());
3085         outer-&gt;scrollTo(IntPoint(desiredX, desiredY));
3086 
3087         if (outer-&gt;isAccessibilityScrollView() &amp;&amp; !inner-&gt;isAccessibilityScrollView()) {
3088             // If outer object we just scrolled is a scroll view (main window or iframe) but the
3089             // inner object is not, keep track of the coordinate transformation to apply to
3090             // future nested calculations.
3091             scrollPosition = scrollableArea-&gt;scrollPosition();
3092             offsetX -= (scrollPosition.x() + point.x());
3093             offsetY -= (scrollPosition.y() + point.y());
3094             point.move(scrollPosition.x() - innerRect.x(),
3095                        scrollPosition.y() - innerRect.y());
3096         } else if (inner-&gt;isAccessibilityScrollView()) {
3097             // Otherwise, if the inner object is a scroll view, reset the coordinate transformation.
3098             offsetX = 0;
3099             offsetY = 0;
3100         }
3101     }
3102 }
3103 
3104 void AccessibilityObject::scrollAreaAndAncestor(std::pair&lt;ScrollableArea*, AccessibilityObject*&gt;&amp; scrollers) const
3105 {
3106     // Search up the parent chain until we find the first one that&#39;s scrollable.
3107     scrollers.first = nullptr;
3108     for (scrollers.second = parentObject(); scrollers.second; scrollers.second = scrollers.second-&gt;parentObject()) {
3109         if ((scrollers.first = scrollers.second-&gt;getScrollableAreaIfScrollable()))
3110             break;
3111     }
3112 }
3113 
3114 ScrollableArea* AccessibilityObject::scrollableAreaAncestor() const
3115 {
3116     std::pair&lt;ScrollableArea*, AccessibilityObject*&gt; scrollers;
3117     scrollAreaAndAncestor(scrollers);
3118     return scrollers.first;
3119 }
3120 
3121 IntPoint AccessibilityObject::scrollPosition() const
3122 {
3123     if (auto scroller = scrollableAreaAncestor())
3124         return scroller-&gt;scrollPosition();
3125 
3126     return IntPoint();
3127 }
3128 
3129 IntRect AccessibilityObject::scrollVisibleContentRect() const
3130 {
3131     if (auto scroller = scrollableAreaAncestor())
3132         return scroller-&gt;visibleContentRect(ScrollableArea::LegacyIOSDocumentVisibleRect);
3133 
3134     return IntRect();
3135 }
3136 
3137 IntSize AccessibilityObject::scrollContentsSize() const
3138 {
3139     if (auto scroller = scrollableAreaAncestor())
3140         return scroller-&gt;contentsSize();
3141 
3142     return IntSize();
3143 }
3144 
3145 bool AccessibilityObject::scrollByPage(ScrollByPageDirection direction) const
3146 {
3147     std::pair&lt;ScrollableArea*, AccessibilityObject*&gt; scrollers;
3148     scrollAreaAndAncestor(scrollers);
3149     ScrollableArea* scrollableArea = scrollers.first;
3150     AccessibilityObject* scrollParent = scrollers.second;
3151 
3152     if (!scrollableArea)
3153         return false;
3154 
3155     IntPoint scrollPosition = scrollableArea-&gt;scrollPosition();
3156     IntPoint newScrollPosition = scrollPosition;
3157     IntSize scrollSize = scrollableArea-&gt;contentsSize();
3158     IntRect scrollVisibleRect = scrollableArea-&gt;visibleContentRect(ScrollableArea::LegacyIOSDocumentVisibleRect);
3159     switch (direction) {
3160     case ScrollByPageDirection::Right: {
3161         int scrollAmount = scrollVisibleRect.size().width();
3162         int newX = scrollPosition.x() - scrollAmount;
3163         newScrollPosition.setX(std::max(newX, 0));
3164         break;
3165     }
3166     case ScrollByPageDirection::Left: {
3167         int scrollAmount = scrollVisibleRect.size().width();
3168         int newX = scrollAmount + scrollPosition.x();
3169         int maxX = scrollSize.width() - scrollAmount;
3170         newScrollPosition.setX(std::min(newX, maxX));
3171         break;
3172     }
3173     case ScrollByPageDirection::Up: {
3174         int scrollAmount = scrollVisibleRect.size().height();
3175         int newY = scrollPosition.y() - scrollAmount;
3176         newScrollPosition.setY(std::max(newY, 0));
3177         break;
3178     }
3179     case ScrollByPageDirection::Down: {
3180         int scrollAmount = scrollVisibleRect.size().height();
3181         int newY = scrollAmount + scrollPosition.y();
3182         int maxY = scrollSize.height() - scrollAmount;
3183         newScrollPosition.setY(std::min(newY, maxY));
3184         break;
3185     }
3186     }
3187 
3188     if (newScrollPosition != scrollPosition) {
3189         scrollParent-&gt;scrollTo(newScrollPosition);
3190         document()-&gt;updateLayoutIgnorePendingStylesheets();
3191         return true;
3192     }
3193 
3194     return false;
3195 }
3196 
3197 
3198 bool AccessibilityObject::lastKnownIsIgnoredValue()
3199 {
3200     if (m_lastKnownIsIgnoredValue == AccessibilityObjectInclusion::DefaultBehavior)
3201         m_lastKnownIsIgnoredValue = accessibilityIsIgnored() ? AccessibilityObjectInclusion::IgnoreObject : AccessibilityObjectInclusion::IncludeObject;
3202 
3203     return m_lastKnownIsIgnoredValue == AccessibilityObjectInclusion::IgnoreObject;
3204 }
3205 
3206 void AccessibilityObject::setLastKnownIsIgnoredValue(bool isIgnored)
3207 {
3208     m_lastKnownIsIgnoredValue = isIgnored ? AccessibilityObjectInclusion::IgnoreObject : AccessibilityObjectInclusion::IncludeObject;
3209 }
3210 
3211 void AccessibilityObject::notifyIfIgnoredValueChanged()
3212 {
3213     bool isIgnored = accessibilityIsIgnored();
3214     if (lastKnownIsIgnoredValue() != isIgnored) {
3215         if (AXObjectCache* cache = axObjectCache())
3216             cache-&gt;childrenChanged(parentObject());
3217         setLastKnownIsIgnoredValue(isIgnored);
3218     }
3219 }
3220 
3221 bool AccessibilityObject::pressedIsPresent() const
3222 {
3223     return !getAttribute(aria_pressedAttr).isEmpty();
3224 }
3225 
3226 TextIteratorBehavior AccessibilityObject::textIteratorBehaviorForTextRange() const
3227 {
3228     TextIteratorBehavior behavior = TextIteratorIgnoresStyleVisibility;
3229 
3230 #if PLATFORM(GTK)
3231     // We need to emit replaced elements for GTK, and present
3232     // them with the &#39;object replacement character&#39; (0xFFFC).
3233     behavior = static_cast&lt;TextIteratorBehavior&gt;(behavior | TextIteratorEmitsObjectReplacementCharacters);
3234 #endif
3235 
3236     return behavior;
3237 }
3238 
3239 AccessibilityRole AccessibilityObject::buttonRoleType() const
3240 {
3241     // If aria-pressed is present, then it should be exposed as a toggle button.
3242     // http://www.w3.org/TR/wai-aria/states_and_properties#aria-pressed
3243     if (pressedIsPresent())
3244         return AccessibilityRole::ToggleButton;
3245     if (hasPopup())
3246         return AccessibilityRole::PopUpButton;
3247     // We don&#39;t contemplate AccessibilityRole::RadioButton, as it depends on the input
3248     // type.
3249 
3250     return AccessibilityRole::Button;
3251 }
3252 
3253 bool AccessibilityObject::isButton() const
3254 {
3255     AccessibilityRole role = roleValue();
3256 
3257     return role == AccessibilityRole::Button || role == AccessibilityRole::PopUpButton || role == AccessibilityRole::ToggleButton;
3258 }
3259 
3260 bool AccessibilityObject::accessibilityIsIgnoredByDefault() const
3261 {
3262     return defaultObjectInclusion() == AccessibilityObjectInclusion::IgnoreObject;
3263 }
3264 
3265 // ARIA component of hidden definition.
3266 // http://www.w3.org/TR/wai-aria/terms#def_hidden
3267 bool AccessibilityObject::isAXHidden() const
3268 {
3269     return AccessibilityObject::matchedParent(*this, true, [] (const AccessibilityObject&amp; object) {
3270         return equalLettersIgnoringASCIICase(object.getAttribute(aria_hiddenAttr), &quot;true&quot;);
3271     }) != nullptr;
3272 }
3273 
3274 // DOM component of hidden definition.
3275 // http://www.w3.org/TR/wai-aria/terms#def_hidden
3276 bool AccessibilityObject::isDOMHidden() const
3277 {
3278     RenderObject* renderer = this-&gt;renderer();
3279     if (!renderer)
3280         return true;
3281 
3282     const RenderStyle&amp; style = renderer-&gt;style();
3283     return style.display() == DisplayType::None || style.visibility() != Visibility::Visible;
3284 }
3285 
3286 bool AccessibilityObject::isShowingValidationMessage() const
3287 {
3288     if (is&lt;HTMLFormControlElement&gt;(node()))
3289         return downcast&lt;HTMLFormControlElement&gt;(*node()).isShowingValidationMessage();
3290     return false;
3291 }
3292 
3293 String AccessibilityObject::validationMessage() const
3294 {
3295     if (is&lt;HTMLFormControlElement&gt;(node()))
3296         return downcast&lt;HTMLFormControlElement&gt;(*node()).validationMessage();
3297     return String();
3298 }
3299 
3300 AccessibilityObjectInclusion AccessibilityObject::defaultObjectInclusion() const
3301 {
3302     bool useParentData = !m_isIgnoredFromParentData.isNull();
3303 
3304     if (useParentData ? m_isIgnoredFromParentData.isAXHidden : isAXHidden())
3305         return AccessibilityObjectInclusion::IgnoreObject;
3306 
3307     if (ignoredFromModalPresence())
3308         return AccessibilityObjectInclusion::IgnoreObject;
3309 
3310     if (useParentData ? m_isIgnoredFromParentData.isPresentationalChildOfAriaRole : isPresentationalChildOfAriaRole())
3311         return AccessibilityObjectInclusion::IgnoreObject;
3312 
3313     return accessibilityPlatformIncludesObject();
3314 }
3315 
3316 bool AccessibilityObject::accessibilityIsIgnored() const
3317 {
3318     AXComputedObjectAttributeCache* attributeCache = nullptr;
3319     AXObjectCache* cache = axObjectCache();
3320     if (cache)
3321         attributeCache = cache-&gt;computedObjectAttributeCache();
3322 
3323     if (attributeCache) {
3324         AccessibilityObjectInclusion ignored = attributeCache-&gt;getIgnored(axObjectID());
3325         switch (ignored) {
3326         case AccessibilityObjectInclusion::IgnoreObject:
3327             return true;
3328         case AccessibilityObjectInclusion::IncludeObject:
3329             return false;
3330         case AccessibilityObjectInclusion::DefaultBehavior:
3331             break;
3332         }
3333     }
3334 
3335     bool result = computeAccessibilityIsIgnored();
3336 
3337     // In case computing axIsIgnored disables attribute caching, we should refetch the object to see if it exists.
3338     if (cache &amp;&amp; (attributeCache = cache-&gt;computedObjectAttributeCache()))
3339         attributeCache-&gt;setIgnored(axObjectID(), result ? AccessibilityObjectInclusion::IgnoreObject : AccessibilityObjectInclusion::IncludeObject);
3340 
3341     return result;
3342 }
3343 
3344 void AccessibilityObject::elementsFromAttribute(Vector&lt;Element*&gt;&amp; elements, const QualifiedName&amp; attribute) const
3345 {
3346     Node* node = this-&gt;node();
3347     if (!node || !node-&gt;isElementNode())
3348         return;
3349 
3350     TreeScope&amp; treeScope = node-&gt;treeScope();
3351 
3352     const AtomicString&amp; idList = getAttribute(attribute);
3353     if (idList.isEmpty())
3354         return;
3355 
3356     auto spaceSplitString = SpaceSplitString(idList, false);
3357     size_t length = spaceSplitString.size();
3358     for (size_t i = 0; i &lt; length; ++i) {
3359         if (auto* idElement = treeScope.getElementById(spaceSplitString[i]))
3360             elements.append(idElement);
3361     }
3362 }
3363 
3364 #if PLATFORM(COCOA)
3365 bool AccessibilityObject::preventKeyboardDOMEventDispatch() const
3366 {
3367     Frame* frame = this-&gt;frame();
3368     return frame &amp;&amp; frame-&gt;settings().preventKeyboardDOMEventDispatch();
3369 }
3370 
3371 void AccessibilityObject::setPreventKeyboardDOMEventDispatch(bool on)
3372 {
3373     Frame* frame = this-&gt;frame();
3374     if (!frame)
3375         return;
3376     frame-&gt;settings().setPreventKeyboardDOMEventDispatch(on);
3377 }
3378 #endif
3379 
3380 AccessibilityObject* AccessibilityObject::focusableAncestor()
3381 {
3382     return const_cast&lt;AccessibilityObject*&gt;(AccessibilityObject::matchedParent(*this, true, [] (const AccessibilityObject&amp; object) {
3383         return object.canSetFocusAttribute();
3384     }));
3385 }
3386 
3387 AccessibilityObject* AccessibilityObject::editableAncestor()
3388 {
3389     return const_cast&lt;AccessibilityObject*&gt;(AccessibilityObject::matchedParent(*this, true, [] (const AccessibilityObject&amp; object) {
3390         return object.isTextControl();
3391     }));
3392 }
3393 
3394 AccessibilityObject* AccessibilityObject::highestEditableAncestor()
3395 {
3396     AccessibilityObject* editableAncestor = this-&gt;editableAncestor();
3397     AccessibilityObject* previousEditableAncestor = nullptr;
3398     while (editableAncestor) {
3399         if (editableAncestor == previousEditableAncestor) {
3400             if (AccessibilityObject* parent = editableAncestor-&gt;parentObject()) {
3401                 editableAncestor = parent-&gt;editableAncestor();
3402                 continue;
3403             }
3404             break;
3405         }
3406         previousEditableAncestor = editableAncestor;
3407         editableAncestor = editableAncestor-&gt;editableAncestor();
3408     }
3409     return previousEditableAncestor;
3410 }
3411 
3412 AccessibilityObject* AccessibilityObject::radioGroupAncestor() const
3413 {
3414     return const_cast&lt;AccessibilityObject*&gt;(AccessibilityObject::matchedParent(*this, false, [] (const AccessibilityObject&amp; object) {
3415         return object.isRadioGroup();
3416     }));
3417 }
3418 
3419 bool AccessibilityObject::isStyleFormatGroup() const
3420 {
3421     Node* node = this-&gt;node();
3422     if (!node)
3423         return false;
3424 
3425     return node-&gt;hasTagName(kbdTag) || node-&gt;hasTagName(codeTag)
3426     || node-&gt;hasTagName(preTag) || node-&gt;hasTagName(sampTag)
3427     || node-&gt;hasTagName(varTag) || node-&gt;hasTagName(citeTag)
3428     || node-&gt;hasTagName(insTag) || node-&gt;hasTagName(delTag)
3429     || node-&gt;hasTagName(supTag) || node-&gt;hasTagName(subTag);
3430 }
3431 
3432 bool AccessibilityObject::isSubscriptStyleGroup() const
3433 {
3434     Node* node = this-&gt;node();
3435     return node &amp;&amp; node-&gt;hasTagName(subTag);
3436 }
3437 
3438 bool AccessibilityObject::isSuperscriptStyleGroup() const
3439 {
3440     Node* node = this-&gt;node();
3441     return node &amp;&amp; node-&gt;hasTagName(supTag);
3442 }
3443 
3444 bool AccessibilityObject::isFigureElement() const
3445 {
3446     Node* node = this-&gt;node();
3447     return node &amp;&amp; node-&gt;hasTagName(figureTag);
3448 }
3449 
3450 bool AccessibilityObject::isOutput() const
3451 {
3452     Node* node = this-&gt;node();
3453     return node &amp;&amp; node-&gt;hasTagName(outputTag);
3454 }
3455 
3456 bool AccessibilityObject::isContainedByPasswordField() const
3457 {
3458     Node* node = this-&gt;node();
3459     if (!node)
3460         return false;
3461 
3462     if (ariaRoleAttribute() != AccessibilityRole::Unknown)
3463         return false;
3464 
3465     Element* element = node-&gt;shadowHost();
3466     return is&lt;HTMLInputElement&gt;(element) &amp;&amp; downcast&lt;HTMLInputElement&gt;(*element).isPasswordField();
3467 }
3468 
3469 AccessibilityObject* AccessibilityObject::selectedListItem()
3470 {
3471     for (const auto&amp; child : children()) {
3472         if (child-&gt;isListItem() &amp;&amp; (child-&gt;isSelected() || child-&gt;isActiveDescendantOfFocusedContainer()))
3473             return child.get();
3474     }
3475 
3476     return nullptr;
3477 }
3478 
3479 void AccessibilityObject::ariaElementsFromAttribute(AccessibilityChildrenVector&amp; children, const QualifiedName&amp; attributeName) const
3480 {
3481     Vector&lt;Element*&gt; elements;
3482     elementsFromAttribute(elements, attributeName);
3483     AXObjectCache* cache = axObjectCache();
3484     for (const auto&amp; element : elements) {
3485         if (AccessibilityObject* axObject = cache-&gt;getOrCreate(element))
3486             children.append(axObject);
3487     }
3488 }
3489 
3490 void AccessibilityObject::ariaElementsReferencedByAttribute(AccessibilityChildrenVector&amp; elements, const QualifiedName&amp; attribute) const
3491 {
3492     auto id = identifierAttribute();
3493     if (id.isEmpty())
3494         return;
3495 
3496     AXObjectCache* cache = axObjectCache();
3497     if (!cache)
3498         return;
3499 
3500     for (auto&amp; element : descendantsOfType&lt;Element&gt;(node()-&gt;treeScope().rootNode())) {
3501         const AtomicString&amp; idList = element.attributeWithoutSynchronization(attribute);
3502         if (!SpaceSplitString(idList, false).contains(id))
3503             continue;
3504 
3505         if (AccessibilityObject* axObject = cache-&gt;getOrCreate(&amp;element))
3506             elements.append(axObject);
3507     }
3508 }
3509 
3510 bool AccessibilityObject::isActiveDescendantOfFocusedContainer() const
3511 {
3512     AccessibilityChildrenVector containers;
3513     ariaActiveDescendantReferencingElements(containers);
3514     for (auto&amp; container : containers) {
3515         if (container-&gt;isFocused())
3516             return true;
3517     }
3518 
3519     return false;
3520 }
3521 
3522 void AccessibilityObject::ariaActiveDescendantReferencingElements(AccessibilityChildrenVector&amp; containers) const
3523 {
3524     ariaElementsReferencedByAttribute(containers, aria_activedescendantAttr);
3525 }
3526 
3527 void AccessibilityObject::ariaControlsElements(AccessibilityChildrenVector&amp; ariaControls) const
3528 {
3529     ariaElementsFromAttribute(ariaControls, aria_controlsAttr);
3530 }
3531 
3532 void AccessibilityObject::ariaControlsReferencingElements(AccessibilityChildrenVector&amp; controllers) const
3533 {
3534     ariaElementsReferencedByAttribute(controllers, aria_controlsAttr);
3535 }
3536 
3537 void AccessibilityObject::ariaDescribedByElements(AccessibilityChildrenVector&amp; ariaDescribedBy) const
3538 {
3539     ariaElementsFromAttribute(ariaDescribedBy, aria_describedbyAttr);
3540 }
3541 
3542 void AccessibilityObject::ariaDescribedByReferencingElements(AccessibilityChildrenVector&amp; describers) const
3543 {
3544     ariaElementsReferencedByAttribute(describers, aria_describedbyAttr);
3545 }
3546 
3547 void AccessibilityObject::ariaDetailsElements(AccessibilityChildrenVector&amp; ariaDetails) const
3548 {
3549     ariaElementsFromAttribute(ariaDetails, aria_detailsAttr);
3550 }
3551 
3552 void AccessibilityObject::ariaDetailsReferencingElements(AccessibilityChildrenVector&amp; detailsFor) const
3553 {
3554     ariaElementsReferencedByAttribute(detailsFor, aria_detailsAttr);
3555 }
3556 
3557 void AccessibilityObject::ariaErrorMessageElements(AccessibilityChildrenVector&amp; ariaErrorMessage) const
3558 {
3559     ariaElementsFromAttribute(ariaErrorMessage, aria_errormessageAttr);
3560 }
3561 
3562 void AccessibilityObject::ariaErrorMessageReferencingElements(AccessibilityChildrenVector&amp; errorMessageFor) const
3563 {
3564     ariaElementsReferencedByAttribute(errorMessageFor, aria_errormessageAttr);
3565 }
3566 
3567 void AccessibilityObject::ariaFlowToElements(AccessibilityChildrenVector&amp; flowTo) const
3568 {
3569     ariaElementsFromAttribute(flowTo, aria_flowtoAttr);
3570 }
3571 
3572 void AccessibilityObject::ariaFlowToReferencingElements(AccessibilityChildrenVector&amp; flowFrom) const
3573 {
3574     ariaElementsReferencedByAttribute(flowFrom, aria_flowtoAttr);
3575 }
3576 
3577 void AccessibilityObject::ariaLabelledByElements(AccessibilityChildrenVector&amp; ariaLabelledBy) const
3578 {
3579     ariaElementsFromAttribute(ariaLabelledBy, aria_labelledbyAttr);
3580     if (!ariaLabelledBy.size())
3581         ariaElementsFromAttribute(ariaLabelledBy, aria_labeledbyAttr);
3582 }
3583 
3584 void AccessibilityObject::ariaLabelledByReferencingElements(AccessibilityChildrenVector&amp; labels) const
3585 {
3586     ariaElementsReferencedByAttribute(labels, aria_labelledbyAttr);
3587     if (!labels.size())
3588         ariaElementsReferencedByAttribute(labels, aria_labeledbyAttr);
3589 }
3590 
3591 void AccessibilityObject::ariaOwnsElements(AccessibilityChildrenVector&amp; axObjects) const
3592 {
3593     ariaElementsFromAttribute(axObjects, aria_ownsAttr);
3594 }
3595 
3596 void AccessibilityObject::ariaOwnsReferencingElements(AccessibilityChildrenVector&amp; owners) const
3597 {
3598     ariaElementsReferencedByAttribute(owners, aria_ownsAttr);
3599 }
3600 
3601 void AccessibilityObject::setIsIgnoredFromParentDataForChild(AccessibilityObject* child)
3602 {
3603     if (!child)
3604         return;
3605 
3606     if (child-&gt;parentObject() != this) {
3607         child-&gt;clearIsIgnoredFromParentData();
3608         return;
3609     }
3610 
3611     AccessibilityIsIgnoredFromParentData result = AccessibilityIsIgnoredFromParentData(this);
3612     if (!m_isIgnoredFromParentData.isNull()) {
3613         result.isAXHidden = m_isIgnoredFromParentData.isAXHidden || equalLettersIgnoringASCIICase(child-&gt;getAttribute(aria_hiddenAttr), &quot;true&quot;);
3614         result.isPresentationalChildOfAriaRole = m_isIgnoredFromParentData.isPresentationalChildOfAriaRole || ariaRoleHasPresentationalChildren();
3615         result.isDescendantOfBarrenParent = m_isIgnoredFromParentData.isDescendantOfBarrenParent || !canHaveChildren();
3616     } else {
3617         result.isAXHidden = child-&gt;isAXHidden();
3618         result.isPresentationalChildOfAriaRole = child-&gt;isPresentationalChildOfAriaRole();
3619         result.isDescendantOfBarrenParent = child-&gt;isDescendantOfBarrenParent();
3620     }
3621 
3622     child-&gt;setIsIgnoredFromParentData(result);
3623 }
3624 
3625 } // namespace WebCore
    </pre>
  </body>
</html>