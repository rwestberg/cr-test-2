<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WebCore/page/scrolling/AsyncScrollingCoordinator.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2014-2015 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 
 28 #if ENABLE(ASYNC_SCROLLING)
 29 #include &quot;AsyncScrollingCoordinator.h&quot;
 30 
 31 #include &quot;DebugPageOverlays.h&quot;
 32 #include &quot;Document.h&quot;
 33 #include &quot;EditorClient.h&quot;
 34 #include &quot;Frame.h&quot;
 35 #include &quot;FrameView.h&quot;
 36 #include &quot;GraphicsLayer.h&quot;
 37 #include &quot;Logging.h&quot;
 38 #include &quot;Page.h&quot;
 39 #include &quot;PerformanceLoggingClient.h&quot;
 40 #include &quot;ScrollAnimator.h&quot;
 41 #include &quot;ScrollingConstraints.h&quot;
 42 #include &quot;ScrollingStateFixedNode.h&quot;
 43 #include &quot;ScrollingStateFrameHostingNode.h&quot;
 44 #include &quot;ScrollingStateFrameScrollingNode.h&quot;
 45 #include &quot;ScrollingStateOverflowScrollingNode.h&quot;
 46 #include &quot;ScrollingStateStickyNode.h&quot;
 47 #include &quot;ScrollingStateTree.h&quot;
 48 #include &quot;Settings.h&quot;
 49 #include &quot;WheelEventTestTrigger.h&quot;
 50 #include &lt;wtf/ProcessID.h&gt;
 51 #include &lt;wtf/text/TextStream.h&gt;
 52 
 53 namespace WebCore {
 54 
 55 AsyncScrollingCoordinator::AsyncScrollingCoordinator(Page* page)
 56     : ScrollingCoordinator(page)
 57     , m_updateNodeScrollPositionTimer(*this, &amp;AsyncScrollingCoordinator::updateScrollPositionAfterAsyncScrollTimerFired)
 58     , m_scrollingStateTree(std::make_unique&lt;ScrollingStateTree&gt;(this))
 59 {
 60 }
 61 
 62 AsyncScrollingCoordinator::~AsyncScrollingCoordinator() = default;
 63 
 64 void AsyncScrollingCoordinator::scrollingStateTreePropertiesChanged()
 65 {
 66     scheduleTreeStateCommit();
 67 }
 68 
 69 #if ENABLE(CSS_SCROLL_SNAP)
 70 static inline void setStateScrollingNodeSnapOffsetsAsFloat(ScrollingStateScrollingNode&amp; node, ScrollEventAxis axis, const Vector&lt;LayoutUnit&gt;* snapOffsets, const Vector&lt;ScrollOffsetRange&lt;LayoutUnit&gt;&gt;* snapOffsetRanges, float deviceScaleFactor)
 71 {
 72     // FIXME: Incorporate current page scale factor in snapping to device pixel. Perhaps we should just convert to float here and let UI process do the pixel snapping?
 73     Vector&lt;float&gt; snapOffsetsAsFloat;
 74     if (snapOffsets) {
 75         snapOffsetsAsFloat.reserveInitialCapacity(snapOffsets-&gt;size());
 76         for (auto&amp; offset : *snapOffsets)
 77             snapOffsetsAsFloat.uncheckedAppend(roundToDevicePixel(offset, deviceScaleFactor, false));
 78     }
 79 
 80     Vector&lt;ScrollOffsetRange&lt;float&gt;&gt; snapOffsetRangesAsFloat;
 81     if (snapOffsetRanges) {
 82         snapOffsetRangesAsFloat.reserveInitialCapacity(snapOffsetRanges-&gt;size());
 83         for (auto&amp; range : *snapOffsetRanges)
 84             snapOffsetRangesAsFloat.uncheckedAppend({ roundToDevicePixel(range.start, deviceScaleFactor, false), roundToDevicePixel(range.end, deviceScaleFactor, false) });
 85     }
 86     if (axis == ScrollEventAxis::Horizontal) {
 87         node.setHorizontalSnapOffsets(snapOffsetsAsFloat);
 88         node.setHorizontalSnapOffsetRanges(snapOffsetRangesAsFloat);
 89     } else {
 90         node.setVerticalSnapOffsets(snapOffsetsAsFloat);
 91         node.setVerticalSnapOffsetRanges(snapOffsetRangesAsFloat);
 92     }
 93 }
 94 #endif
 95 
 96 void AsyncScrollingCoordinator::setEventTrackingRegionsDirty()
 97 {
 98     m_eventTrackingRegionsDirty = true;
 99     // We have to schedule a commit, but the computed non-fast region may not have actually changed.
100     scheduleTreeStateCommit();
101 }
102 
103 void AsyncScrollingCoordinator::willCommitTree()
104 {
105     updateEventTrackingRegions();
106 }
107 
108 void AsyncScrollingCoordinator::updateEventTrackingRegions()
109 {
110     if (!m_eventTrackingRegionsDirty)
111         return;
112 
113     if (!m_scrollingStateTree-&gt;rootStateNode())
114         return;
115 
116     m_scrollingStateTree-&gt;rootStateNode()-&gt;setEventTrackingRegions(absoluteEventTrackingRegions());
117     m_eventTrackingRegionsDirty = false;
118 }
119 
120 void AsyncScrollingCoordinator::frameViewLayoutUpdated(FrameView&amp; frameView)
121 {
122     ASSERT(isMainThread());
123     ASSERT(m_page);
124 
125     // If there isn&#39;t a root node yet, don&#39;t do anything. We&#39;ll be called again after creating one.
126     if (!m_scrollingStateTree-&gt;rootStateNode())
127         return;
128 
129     setEventTrackingRegionsDirty();
130     if (!coordinatesScrollingForFrameView(frameView))
131         return;
132 
133     auto* node = m_scrollingStateTree-&gt;stateNodeForID(frameView.scrollingNodeID());
134     if (!node || !is&lt;ScrollingStateFrameScrollingNode&gt;(*node))
135         return;
136 
137     auto&amp; frameScrollingNode = downcast&lt;ScrollingStateFrameScrollingNode&gt;(*node);
138 
139     auto* verticalScrollbar = frameView.verticalScrollbar();
140     auto* horizontalScrollbar = frameView.horizontalScrollbar();
141     frameScrollingNode.setScrollerImpsFromScrollbars(verticalScrollbar, horizontalScrollbar);
142 
143     frameScrollingNode.setFrameScaleFactor(frameView.frame().frameScaleFactor());
144     frameScrollingNode.setHeaderHeight(frameView.headerHeight());
145     frameScrollingNode.setFooterHeight(frameView.footerHeight());
146     frameScrollingNode.setTopContentInset(frameView.topContentInset());
147 
148     frameScrollingNode.setVisualViewportEnabled(visualViewportEnabled());
149     frameScrollingNode.setLayoutViewport(frameView.layoutViewportRect());
150     frameScrollingNode.setAsyncFrameOrOverflowScrollingEnabled(asyncFrameOrOverflowScrollingEnabled());
151 
152     frameScrollingNode.setMinLayoutViewportOrigin(frameView.minStableLayoutViewportOrigin());
153     frameScrollingNode.setMaxLayoutViewportOrigin(frameView.maxStableLayoutViewportOrigin());
154 
155     frameScrollingNode.setScrollOrigin(frameView.scrollOrigin());
156     frameScrollingNode.setScrollableAreaSize(frameView.visibleContentRect().size());
157     frameScrollingNode.setTotalContentsSize(frameView.totalContentsSize());
158     frameScrollingNode.setReachableContentsSize(frameView.totalContentsSize());
159     frameScrollingNode.setFixedElementsLayoutRelativeToFrame(frameView.fixedElementsLayoutRelativeToFrame());
160     frameScrollingNode.setScrollBehaviorForFixedElements(frameView.scrollBehaviorForFixedElements());
161 
162 #if ENABLE(CSS_SCROLL_SNAP)
163     frameView.updateSnapOffsets();
164     updateScrollSnapPropertiesWithFrameView(frameView);
165 #endif
166 
167 #if PLATFORM(COCOA)
168     auto* page = frameView.frame().page();
169     if (page &amp;&amp; page-&gt;expectsWheelEventTriggers()) {
170         LOG(WheelEventTestTriggers, &quot;    AsyncScrollingCoordinator::frameViewLayoutUpdated: Expects wheel event test trigger=%d&quot;, page-&gt;expectsWheelEventTriggers());
171         frameScrollingNode.setExpectsWheelEventTestTrigger(page-&gt;expectsWheelEventTriggers());
172     }
173 #endif
174 
175     ScrollableAreaParameters scrollParameters;
176     scrollParameters.horizontalScrollElasticity = frameView.horizontalScrollElasticity();
177     scrollParameters.verticalScrollElasticity = frameView.verticalScrollElasticity();
178     scrollParameters.hasEnabledHorizontalScrollbar = horizontalScrollbar &amp;&amp; horizontalScrollbar-&gt;enabled();
179     scrollParameters.hasEnabledVerticalScrollbar = verticalScrollbar &amp;&amp; verticalScrollbar-&gt;enabled();
180     scrollParameters.horizontalScrollbarMode = frameView.horizontalScrollbarMode();
181     scrollParameters.verticalScrollbarMode = frameView.verticalScrollbarMode();
182     scrollParameters.useDarkAppearanceForScrollbars = frameView.useDarkAppearanceForScrollbars();
183 
184     frameScrollingNode.setScrollableAreaParameters(scrollParameters);
185 }
186 
187 void AsyncScrollingCoordinator::updateExpectsWheelEventTestTriggerWithFrameView(const FrameView&amp; frameView)
188 {
189     auto* page = frameView.frame().page();
190     if (!page)
191         return;
192 
193     auto* node = downcast&lt;ScrollingStateFrameScrollingNode&gt;(m_scrollingStateTree-&gt;stateNodeForID(frameView.scrollingNodeID()));
194     if (!node)
195         return;
196 
197     node-&gt;setExpectsWheelEventTestTrigger(page-&gt;expectsWheelEventTriggers());
198 }
199 
200 void AsyncScrollingCoordinator::frameViewEventTrackingRegionsChanged(FrameView&amp; frameView)
201 {
202     if (!m_scrollingStateTree-&gt;rootStateNode())
203         return;
204 
205     setEventTrackingRegionsDirty();
206     DebugPageOverlays::didChangeEventHandlers(frameView.frame());
207 }
208 
209 void AsyncScrollingCoordinator::frameViewRootLayerDidChange(FrameView&amp; frameView)
210 {
211     ASSERT(isMainThread());
212     ASSERT(m_page);
213 
214     if (!coordinatesScrollingForFrameView(frameView))
215         return;
216 
217     // FIXME: In some navigation scenarios, the FrameView has no RenderView or that RenderView has not been composited.
218     // This needs cleaning up: https://bugs.webkit.org/show_bug.cgi?id=132724
219     if (!frameView.scrollingNodeID())
220         return;
221 
222     // If the root layer does not have a ScrollingStateNode, then we should create one.
223     ensureRootStateNodeForFrameView(frameView);
224     ASSERT(m_scrollingStateTree-&gt;stateNodeForID(frameView.scrollingNodeID()));
225 
226     ScrollingCoordinator::frameViewRootLayerDidChange(frameView);
227 
228     auto* node = downcast&lt;ScrollingStateFrameScrollingNode&gt;(m_scrollingStateTree-&gt;stateNodeForID(frameView.scrollingNodeID()));
229     node-&gt;setScrollContainerLayer(scrollContainerLayerForFrameView(frameView));
230     node-&gt;setScrolledContentsLayer(scrolledContentsLayerForFrameView(frameView));
231     node-&gt;setRootContentsLayer(rootContentsLayerForFrameView(frameView));
232     node-&gt;setCounterScrollingLayer(counterScrollingLayerForFrameView(frameView));
233     node-&gt;setInsetClipLayer(insetClipLayerForFrameView(frameView));
234     node-&gt;setContentShadowLayer(contentShadowLayerForFrameView(frameView));
235     node-&gt;setHeaderLayer(headerLayerForFrameView(frameView));
236     node-&gt;setFooterLayer(footerLayerForFrameView(frameView));
237     node-&gt;setScrollBehaviorForFixedElements(frameView.scrollBehaviorForFixedElements());
238     node-&gt;setVerticalScrollbarLayer(frameView.layerForVerticalScrollbar());
239     node-&gt;setHorizontalScrollbarLayer(frameView.layerForHorizontalScrollbar());
240 }
241 
242 bool AsyncScrollingCoordinator::requestScrollPositionUpdate(FrameView&amp; frameView, const IntPoint&amp; scrollPosition)
243 {
244     ASSERT(isMainThread());
245     ASSERT(m_page);
246 
247     if (!coordinatesScrollingForFrameView(frameView))
248         return false;
249 
250     bool isProgrammaticScroll = frameView.inProgrammaticScroll();
251     if (isProgrammaticScroll || frameView.frame().document()-&gt;pageCacheState() != Document::NotInPageCache)
252         updateScrollPositionAfterAsyncScroll(frameView.scrollingNodeID(), scrollPosition, WTF::nullopt, isProgrammaticScroll, ScrollingLayerPositionAction::Set);
253 
254     // If this frame view&#39;s document is being put into the page cache, we don&#39;t want to update our
255     // main frame scroll position. Just let the FrameView think that we did.
256     if (frameView.frame().document()-&gt;pageCacheState() != Document::NotInPageCache)
257         return true;
258 
259     auto* stateNode = downcast&lt;ScrollingStateScrollingNode&gt;(m_scrollingStateTree-&gt;stateNodeForID(frameView.scrollingNodeID()));
260     if (!stateNode)
261         return false;
262 
263     stateNode-&gt;setRequestedScrollPosition(scrollPosition, isProgrammaticScroll);
264     return true;
265 }
266 
267 void AsyncScrollingCoordinator::scheduleUpdateScrollPositionAfterAsyncScroll(ScrollingNodeID nodeID, const FloatPoint&amp; scrollPosition, const Optional&lt;FloatPoint&gt;&amp; layoutViewportOrigin, bool programmaticScroll, ScrollingLayerPositionAction scrollingLayerPositionAction)
268 {
269     ScheduledScrollUpdate scrollUpdate(nodeID, scrollPosition, layoutViewportOrigin, programmaticScroll, scrollingLayerPositionAction);
270 
271     // For programmatic scrolls, requestScrollPositionUpdate() has already called updateScrollPositionAfterAsyncScroll().
272     if (programmaticScroll)
273         return;
274 
275     if (m_updateNodeScrollPositionTimer.isActive()) {
276         if (m_scheduledScrollUpdate.matchesUpdateType(scrollUpdate)) {
277             m_scheduledScrollUpdate.scrollPosition = scrollPosition;
278             m_scheduledScrollUpdate.layoutViewportOrigin = layoutViewportOrigin;
279             return;
280         }
281 
282         // If the parameters don&#39;t match what was previously scheduled, dispatch immediately.
283         m_updateNodeScrollPositionTimer.stop();
284         updateScrollPositionAfterAsyncScroll(m_scheduledScrollUpdate.nodeID, m_scheduledScrollUpdate.scrollPosition, m_scheduledScrollUpdate.layoutViewportOrigin, m_scheduledScrollUpdate.isProgrammaticScroll, m_scheduledScrollUpdate.updateLayerPositionAction);
285         updateScrollPositionAfterAsyncScroll(nodeID, scrollPosition, layoutViewportOrigin, programmaticScroll, scrollingLayerPositionAction);
286         return;
287     }
288 
289     m_scheduledScrollUpdate = scrollUpdate;
290     m_updateNodeScrollPositionTimer.startOneShot(0_s);
291 }
292 
293 void AsyncScrollingCoordinator::updateScrollPositionAfterAsyncScrollTimerFired()
294 {
295     updateScrollPositionAfterAsyncScroll(m_scheduledScrollUpdate.nodeID, m_scheduledScrollUpdate.scrollPosition, m_scheduledScrollUpdate.layoutViewportOrigin, m_scheduledScrollUpdate.isProgrammaticScroll, m_scheduledScrollUpdate.updateLayerPositionAction);
296 }
297 
298 FrameView* AsyncScrollingCoordinator::frameViewForScrollingNode(ScrollingNodeID scrollingNodeID) const
299 {
300     if (!m_scrollingStateTree-&gt;rootStateNode())
301         return nullptr;
302 
303     if (scrollingNodeID == m_scrollingStateTree-&gt;rootStateNode()-&gt;scrollingNodeID())
304         return m_page-&gt;mainFrame().view();
305 
306     auto* stateNode = m_scrollingStateTree-&gt;stateNodeForID(scrollingNodeID);
307     if (!stateNode)
308         return nullptr;
309 
310     // Find the enclosing frame scrolling node.
311     auto* parentNode = stateNode;
312     while (parentNode &amp;&amp; !parentNode-&gt;isFrameScrollingNode())
313         parentNode = parentNode-&gt;parent();
314 
315     if (!parentNode)
316         return nullptr;
317 
318     // Walk the frame tree to find the matching FrameView. This is not ideal, but avoids back pointers to FrameViews
319     // from ScrollingTreeStateNodes.
320     for (Frame* frame = &amp;m_page-&gt;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
321         if (auto* view = frame-&gt;view()) {
322             if (view-&gt;scrollingNodeID() == parentNode-&gt;scrollingNodeID())
323                 return view;
324         }
325     }
326 
327     return nullptr;
328 }
329 
330 void AsyncScrollingCoordinator::updateScrollPositionAfterAsyncScroll(ScrollingNodeID scrollingNodeID, const FloatPoint&amp; scrollPosition, Optional&lt;FloatPoint&gt; layoutViewportOrigin, bool programmaticScroll, ScrollingLayerPositionAction scrollingLayerPositionAction)
331 {
332     ASSERT(isMainThread());
333 
334     if (!m_page)
335         return;
336 
337     auto* frameViewPtr = frameViewForScrollingNode(scrollingNodeID);
338     if (!frameViewPtr)
339         return;
340 
341     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;AsyncScrollingCoordinator::updateScrollPositionAfterAsyncScroll node &quot; &lt;&lt; scrollingNodeID &lt;&lt; &quot; scrollPosition &quot; &lt;&lt; scrollPosition &lt;&lt; &quot; action &quot; &lt;&lt; scrollingLayerPositionAction);
342 
343     auto&amp; frameView = *frameViewPtr;
344 
345     if (scrollingNodeID == frameView.scrollingNodeID()) {
346         reconcileScrollingState(frameView, scrollPosition, layoutViewportOrigin, programmaticScroll, ViewportRectStability::Stable, scrollingLayerPositionAction);
347 
348 #if PLATFORM(COCOA)
349         if (m_page-&gt;expectsWheelEventTriggers()) {
350             frameView.scrollAnimator().setWheelEventTestTrigger(m_page-&gt;testTrigger());
351             if (const auto&amp; trigger = m_page-&gt;testTrigger())
352                 trigger-&gt;removeTestDeferralForReason(reinterpret_cast&lt;WheelEventTestTrigger::ScrollableAreaIdentifier&gt;(scrollingNodeID), WheelEventTestTrigger::ScrollingThreadSyncNeeded);
353         }
354 #endif
355 
356         return;
357     }
358 
359     // Overflow-scroll area.
360     if (auto* scrollableArea = frameView.scrollableAreaForScrollLayerID(scrollingNodeID)) {
361         scrollableArea-&gt;setIsUserScroll(scrollingLayerPositionAction == ScrollingLayerPositionAction::Sync);
362         scrollableArea-&gt;scrollToOffsetWithoutAnimation(scrollPosition);
363         scrollableArea-&gt;setIsUserScroll(false);
364         if (scrollingLayerPositionAction == ScrollingLayerPositionAction::Set)
365             m_page-&gt;editorClient().overflowScrollPositionChanged();
366 
367 #if PLATFORM(COCOA)
368         if (m_page-&gt;expectsWheelEventTriggers()) {
369             frameView.scrollAnimator().setWheelEventTestTrigger(m_page-&gt;testTrigger());
370             if (const auto&amp; trigger = m_page-&gt;testTrigger())
371                 trigger-&gt;removeTestDeferralForReason(reinterpret_cast&lt;WheelEventTestTrigger::ScrollableAreaIdentifier&gt;(scrollingNodeID), WheelEventTestTrigger::ScrollingThreadSyncNeeded);
372         }
373 #endif
374     }
375 }
376 
377 void AsyncScrollingCoordinator::reconcileScrollingState(FrameView&amp; frameView, const FloatPoint&amp; scrollPosition, const LayoutViewportOriginOrOverrideRect&amp; layoutViewportOriginOrOverrideRect, bool programmaticScroll, ViewportRectStability viewportRectStability, ScrollingLayerPositionAction scrollingLayerPositionAction)
378 {
379     bool oldProgrammaticScroll = frameView.inProgrammaticScroll();
380     frameView.setInProgrammaticScroll(programmaticScroll);
381 
382     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; getCurrentProcessID() &lt;&lt; &quot; AsyncScrollingCoordinator &quot; &lt;&lt; this &lt;&lt; &quot; reconcileScrollingState scrollPosition &quot; &lt;&lt; scrollPosition &lt;&lt; &quot; programmaticScroll &quot; &lt;&lt; programmaticScroll &lt;&lt; &quot; stability &quot; &lt;&lt; viewportRectStability &lt;&lt; &quot; &quot; &lt;&lt; scrollingLayerPositionAction);
383 
384     Optional&lt;FloatRect&gt; layoutViewportRect;
385 
386     WTF::switchOn(layoutViewportOriginOrOverrideRect,
387         [&amp;frameView](Optional&lt;FloatPoint&gt; origin) {
388             if (origin)
389                 frameView.setBaseLayoutViewportOrigin(LayoutPoint(origin.value()), FrameView::TriggerLayoutOrNot::No);
390         }, [&amp;frameView, &amp;layoutViewportRect, viewportRectStability, visualViewportEnabled = visualViewportEnabled()](Optional&lt;FloatRect&gt; overrideRect) {
391             if (!overrideRect)
392                 return;
393 
394             layoutViewportRect = overrideRect;
395             if (visualViewportEnabled &amp;&amp; viewportRectStability != ViewportRectStability::ChangingObscuredInsetsInteractively)
396                 frameView.setLayoutViewportOverrideRect(LayoutRect(overrideRect.value()), viewportRectStability == ViewportRectStability::Stable ? FrameView::TriggerLayoutOrNot::Yes : FrameView::TriggerLayoutOrNot::No);
397 #if PLATFORM(IOS_FAMILY)
398             else if (viewportRectStability == ViewportRectStability::Stable)
399                 frameView.setCustomFixedPositionLayoutRect(enclosingIntRect(overrideRect.value()));
400 #endif
401         }
402     );
403 
404     frameView.setConstrainsScrollingToContentEdge(false);
405     frameView.notifyScrollPositionChanged(roundedIntPoint(scrollPosition));
406     frameView.setConstrainsScrollingToContentEdge(true);
407     frameView.setInProgrammaticScroll(oldProgrammaticScroll);
408 
409     if (!programmaticScroll &amp;&amp; scrollingLayerPositionAction != ScrollingLayerPositionAction::Set) {
410         auto scrollingNodeID = frameView.scrollingNodeID();
411         if (viewportRectStability == ViewportRectStability::Stable)
412             reconcileViewportConstrainedLayerPositions(scrollingNodeID, frameView.rectForFixedPositionLayout(), scrollingLayerPositionAction);
413         else if (layoutViewportRect)
414             reconcileViewportConstrainedLayerPositions(scrollingNodeID, LayoutRect(layoutViewportRect.value()), scrollingLayerPositionAction);
415     }
416 
417     if (!scrolledContentsLayerForFrameView(frameView))
418         return;
419 
420     auto* counterScrollingLayer = counterScrollingLayerForFrameView(frameView);
421     auto* insetClipLayer = insetClipLayerForFrameView(frameView);
422     auto* contentShadowLayer = contentShadowLayerForFrameView(frameView);
423     auto* rootContentsLayer = rootContentsLayerForFrameView(frameView);
424     auto* headerLayer = headerLayerForFrameView(frameView);
425     auto* footerLayer = footerLayerForFrameView(frameView);
426 
427     ASSERT(frameView.scrollPosition() == roundedIntPoint(scrollPosition));
428     LayoutPoint scrollPositionForFixed = frameView.scrollPositionForFixedPosition();
429     float topContentInset = frameView.topContentInset();
430 
431     FloatPoint positionForInsetClipLayer;
432     if (insetClipLayer)
433         positionForInsetClipLayer = FloatPoint(insetClipLayer-&gt;position().x(), FrameView::yPositionForInsetClipLayer(scrollPosition, topContentInset));
434     FloatPoint positionForContentsLayer = frameView.positionForRootContentLayer();
435 
436     FloatPoint positionForHeaderLayer = FloatPoint(scrollPositionForFixed.x(), FrameView::yPositionForHeaderLayer(scrollPosition, topContentInset));
437     FloatPoint positionForFooterLayer = FloatPoint(scrollPositionForFixed.x(),
438         FrameView::yPositionForFooterLayer(scrollPosition, topContentInset, frameView.totalContentsSize().height(), frameView.footerHeight()));
439 
440     if (programmaticScroll || scrollingLayerPositionAction == ScrollingLayerPositionAction::Set) {
441         reconcileScrollPosition(frameView, ScrollingLayerPositionAction::Set);
442 
443         if (counterScrollingLayer)
444             counterScrollingLayer-&gt;setPosition(scrollPositionForFixed);
445         if (insetClipLayer)
446             insetClipLayer-&gt;setPosition(positionForInsetClipLayer);
447         if (contentShadowLayer)
448             contentShadowLayer-&gt;setPosition(positionForContentsLayer);
449         if (rootContentsLayer)
450             rootContentsLayer-&gt;setPosition(positionForContentsLayer);
451         if (headerLayer)
452             headerLayer-&gt;setPosition(positionForHeaderLayer);
453         if (footerLayer)
454             footerLayer-&gt;setPosition(positionForFooterLayer);
455     } else {
456         reconcileScrollPosition(frameView, ScrollingLayerPositionAction::Sync);
457 
458         if (counterScrollingLayer)
459             counterScrollingLayer-&gt;syncPosition(scrollPositionForFixed);
460         if (insetClipLayer)
461             insetClipLayer-&gt;syncPosition(positionForInsetClipLayer);
462         if (contentShadowLayer)
463             contentShadowLayer-&gt;syncPosition(positionForContentsLayer);
464         if (rootContentsLayer)
465             rootContentsLayer-&gt;syncPosition(positionForContentsLayer);
466         if (headerLayer)
467             headerLayer-&gt;syncPosition(positionForHeaderLayer);
468         if (footerLayer)
469             footerLayer-&gt;syncPosition(positionForFooterLayer);
470     }
471 }
472 
473 void AsyncScrollingCoordinator::reconcileScrollPosition(FrameView&amp; frameView, ScrollingLayerPositionAction scrollingLayerPositionAction)
474 {
475 #if PLATFORM(IOS_FAMILY)
476     // Doing all scrolling like this (UIScrollView style) would simplify code.
477     auto* scrollContainerLayer = scrollContainerLayerForFrameView(frameView);
478     if (!scrollContainerLayer)
479         return;
480     if (scrollingLayerPositionAction == ScrollingLayerPositionAction::Set)
481         scrollContainerLayer-&gt;setBoundsOrigin(frameView.scrollPosition());
482     else
483         scrollContainerLayer-&gt;syncBoundsOrigin(frameView.scrollPosition());
484 #else
485     auto* scrolledContentsLayer = scrolledContentsLayerForFrameView(frameView);
486     if (!scrolledContentsLayer)
487         return;
488     if (scrollingLayerPositionAction == ScrollingLayerPositionAction::Set)
489         scrolledContentsLayer-&gt;setPosition(-frameView.scrollPosition());
490     else
491         scrolledContentsLayer-&gt;syncPosition(-frameView.scrollPosition());
492 #endif
493 }
494 
495 void AsyncScrollingCoordinator::scrollableAreaScrollbarLayerDidChange(ScrollableArea&amp; scrollableArea, ScrollbarOrientation orientation)
496 {
497     ASSERT(isMainThread());
498     ASSERT(m_page);
499 
500     auto* node = m_scrollingStateTree-&gt;stateNodeForID(scrollableArea.scrollingNodeID());
501     if (is&lt;ScrollingStateFrameScrollingNode&gt;(node)) {
502         auto&amp; scrollingNode = downcast&lt;ScrollingStateFrameScrollingNode&gt;(*node);
503         if (orientation == VerticalScrollbar)
504             scrollingNode.setVerticalScrollbarLayer(scrollableArea.layerForVerticalScrollbar());
505         else
506             scrollingNode.setHorizontalScrollbarLayer(scrollableArea.layerForHorizontalScrollbar());
507     }
508 
509     if (&amp;scrollableArea == m_page-&gt;mainFrame().view()) {
510         if (orientation == VerticalScrollbar)
511             scrollableArea.verticalScrollbarLayerDidChange();
512         else
513             scrollableArea.horizontalScrollbarLayerDidChange();
514     }
515 }
516 
517 ScrollingNodeID AsyncScrollingCoordinator::createNode(ScrollingNodeType nodeType, ScrollingNodeID newNodeID)
518 {
519     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;AsyncScrollingCoordinator::createNode &quot; &lt;&lt; nodeType &lt;&lt; &quot; node &quot; &lt;&lt; newNodeID);
520     return m_scrollingStateTree-&gt;createUnparentedNode(nodeType, newNodeID);
521 }
522 
523 ScrollingNodeID AsyncScrollingCoordinator::insertNode(ScrollingNodeType nodeType, ScrollingNodeID newNodeID, ScrollingNodeID parentID, size_t childIndex)
524 {
525     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;AsyncScrollingCoordinator::insertNode &quot; &lt;&lt; nodeType &lt;&lt; &quot; node &quot; &lt;&lt; newNodeID &lt;&lt; &quot; parent &quot; &lt;&lt; parentID &lt;&lt; &quot; index &quot; &lt;&lt; childIndex);
526     return m_scrollingStateTree-&gt;insertNode(nodeType, newNodeID, parentID, childIndex);
527 }
528 
529 void AsyncScrollingCoordinator::unparentNode(ScrollingNodeID nodeID)
530 {
531     m_scrollingStateTree-&gt;unparentNode(nodeID);
532 }
533 
534 void AsyncScrollingCoordinator::unparentChildrenAndDestroyNode(ScrollingNodeID nodeID)
535 {
536     m_scrollingStateTree-&gt;unparentChildrenAndDestroyNode(nodeID);
537 }
538 
539 void AsyncScrollingCoordinator::detachAndDestroySubtree(ScrollingNodeID nodeID)
540 {
541     m_scrollingStateTree-&gt;detachAndDestroySubtree(nodeID);
542 }
543 
544 void AsyncScrollingCoordinator::clearAllNodes()
545 {
546     m_scrollingStateTree-&gt;clear();
547 }
548 
549 ScrollingNodeID AsyncScrollingCoordinator::parentOfNode(ScrollingNodeID nodeID) const
550 {
551     auto* scrollingNode = m_scrollingStateTree-&gt;stateNodeForID(nodeID);
552     if (!scrollingNode)
553         return 0;
554 
555     return scrollingNode-&gt;parentNodeID();
556 }
557 
558 Vector&lt;ScrollingNodeID&gt; AsyncScrollingCoordinator::childrenOfNode(ScrollingNodeID nodeID) const
559 {
560     auto* scrollingNode = m_scrollingStateTree-&gt;stateNodeForID(nodeID);
561     if (!scrollingNode)
562         return { };
563 
564     auto* children = scrollingNode-&gt;children();
565     if (!children || children-&gt;isEmpty())
566         return { };
567 
568     Vector&lt;ScrollingNodeID&gt; childNodeIDs;
569     childNodeIDs.reserveInitialCapacity(children-&gt;size());
570     for (const auto&amp; childNode : *children)
571         childNodeIDs.uncheckedAppend(childNode-&gt;scrollingNodeID());
572 
573     return childNodeIDs;
574 }
575 
576 void AsyncScrollingCoordinator::reconcileViewportConstrainedLayerPositions(ScrollingNodeID scrollingNodeID, const LayoutRect&amp; viewportRect, ScrollingLayerPositionAction action)
577 {
578     auto* scrollingNode = m_scrollingStateTree-&gt;stateNodeForID(scrollingNodeID);
579     if (!scrollingNode)
580         return;
581 
582     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; getCurrentProcessID() &lt;&lt; &quot; AsyncScrollingCoordinator::reconcileViewportConstrainedLayerPositions for viewport rect &quot; &lt;&lt; viewportRect &lt;&lt; &quot; and node &quot; &lt;&lt; scrollingNodeID);
583 
584     scrollingNode-&gt;reconcileLayerPositionForViewportRect(viewportRect, action);
585 }
586 
587 void AsyncScrollingCoordinator::ensureRootStateNodeForFrameView(FrameView&amp; frameView)
588 {
589     ASSERT(frameView.scrollingNodeID());
590     if (m_scrollingStateTree-&gt;stateNodeForID(frameView.scrollingNodeID()))
591         return;
592 
593     // For non-main frames, it is only possible to arrive in this function from
594     // RenderLayerCompositor::updateBacking where the node has already been created.
595     ASSERT(frameView.frame().isMainFrame());
596     insertNode(ScrollingNodeType::MainFrame, frameView.scrollingNodeID(), 0, 0);
597 }
598 
599 void AsyncScrollingCoordinator::setNodeLayers(ScrollingNodeID nodeID, const NodeLayers&amp; nodeLayers)
600 {
601     auto* node = m_scrollingStateTree-&gt;stateNodeForID(nodeID);
602     ASSERT(node);
603     if (!node)
604         return;
605 
606     node-&gt;setLayer(nodeLayers.layer);
607 
608     if (is&lt;ScrollingStateScrollingNode&gt;(node)) {
609         auto&amp; scrollingNode = downcast&lt;ScrollingStateScrollingNode&gt;(*node);
610         scrollingNode.setScrollContainerLayer(nodeLayers.scrollContainerLayer);
611         scrollingNode.setScrolledContentsLayer(nodeLayers.scrolledContentsLayer);
612 
613         if (is&lt;ScrollingStateFrameScrollingNode&gt;(node)) {
614             auto&amp; frameScrollingNode = downcast&lt;ScrollingStateFrameScrollingNode&gt;(*node);
615             frameScrollingNode.setInsetClipLayer(nodeLayers.insetClipLayer);
616             frameScrollingNode.setCounterScrollingLayer(nodeLayers.counterScrollingLayer);
617             frameScrollingNode.setRootContentsLayer(nodeLayers.rootContentsLayer);
618         }
619     }
620 }
621 
622 void AsyncScrollingCoordinator::setScrollingNodeGeometry(ScrollingNodeID nodeID, const ScrollingGeometry&amp; scrollingGeometry)
623 {
624     auto* stateNode = m_scrollingStateTree-&gt;stateNodeForID(nodeID);
625     ASSERT(stateNode);
626     if (!stateNode)
627         return;
628 
629     if (stateNode-&gt;nodeType() == ScrollingNodeType::FrameHosting) {
630         auto&amp; frameHostingStateNode = downcast&lt;ScrollingStateFrameHostingNode&gt;(*stateNode);
631         frameHostingStateNode.setParentRelativeScrollableRect(scrollingGeometry.parentRelativeScrollableRect);
632         return;
633     }
634 
635     auto&amp; scrollingNode = downcast&lt;ScrollingStateScrollingNode&gt;(*stateNode);
636 
637     scrollingNode.setParentRelativeScrollableRect(scrollingGeometry.parentRelativeScrollableRect);
638     scrollingNode.setScrollOrigin(scrollingGeometry.scrollOrigin);
639     scrollingNode.setScrollPosition(scrollingGeometry.scrollPosition);
640     scrollingNode.setTotalContentsSize(scrollingGeometry.contentSize);
641     scrollingNode.setReachableContentsSize(scrollingGeometry.reachableContentSize);
642     scrollingNode.setScrollableAreaSize(scrollingGeometry.scrollableAreaSize);
643 
644 #if ENABLE(CSS_SCROLL_SNAP)
645     // updateScrollSnapPropertiesWithFrameView() sets these for frame scrolling nodes. FIXME: Why the difference?
646     if (is&lt;ScrollingStateOverflowScrollingNode&gt;(scrollingNode)) {
647         setStateScrollingNodeSnapOffsetsAsFloat(scrollingNode, ScrollEventAxis::Horizontal, &amp;scrollingGeometry.horizontalSnapOffsets, &amp;scrollingGeometry.horizontalSnapOffsetRanges, m_page-&gt;deviceScaleFactor());
648         setStateScrollingNodeSnapOffsetsAsFloat(scrollingNode, ScrollEventAxis::Vertical, &amp;scrollingGeometry.verticalSnapOffsets, &amp;scrollingGeometry.verticalSnapOffsetRanges, m_page-&gt;deviceScaleFactor());
649         scrollingNode.setCurrentHorizontalSnapPointIndex(scrollingGeometry.currentHorizontalSnapPointIndex);
650         scrollingNode.setCurrentVerticalSnapPointIndex(scrollingGeometry.currentVerticalSnapPointIndex);
651     }
652 #endif
653 }
654 
655 void AsyncScrollingCoordinator::setViewportConstraintedNodeGeometry(ScrollingNodeID nodeID, const ViewportConstraints&amp; constraints)
656 {
657     auto* node = m_scrollingStateTree-&gt;stateNodeForID(nodeID);
658     if (!node)
659         return;
660 
661     switch (constraints.constraintType()) {
662     case ViewportConstraints::FixedPositionConstraint: {
663         auto&amp; fixedNode = downcast&lt;ScrollingStateFixedNode&gt;(*node);
664         fixedNode.updateConstraints((const FixedPositionViewportConstraints&amp;)constraints);
665         break;
666     }
667     case ViewportConstraints::StickyPositionConstraint: {
668         auto&amp; stickyNode = downcast&lt;ScrollingStateStickyNode&gt;(*node);
669         stickyNode.updateConstraints((const StickyPositionViewportConstraints&amp;)constraints);
670         break;
671     }
672     }
673 }
674 
675 void AsyncScrollingCoordinator::setSynchronousScrollingReasons(FrameView&amp; frameView, SynchronousScrollingReasons reasons)
676 {
677     auto* scrollingStateNode = static_cast&lt;ScrollingStateFrameScrollingNode*&gt;(m_scrollingStateTree-&gt;stateNodeForID(frameView.scrollingNodeID()));
678     if (!scrollingStateNode)
679         return;
680 
681     // The FrameView&#39;s GraphicsLayer is likely to be out-of-synch with the PlatformLayer
682     // at this point. So we&#39;ll update it before we switch back to main thread scrolling
683     // in order to avoid layer positioning bugs.
684     if (reasons)
685         reconcileScrollPosition(frameView, ScrollingLayerPositionAction::Set);
686     scrollingStateNode-&gt;setSynchronousScrollingReasons(reasons);
687 }
688 
689 bool AsyncScrollingCoordinator::isRubberBandInProgress() const
690 {
691     return scrollingTree()-&gt;isRubberBandInProgress();
692 }
693 
694 void AsyncScrollingCoordinator::setScrollPinningBehavior(ScrollPinningBehavior pinning)
695 {
696     scrollingTree()-&gt;setScrollPinningBehavior(pinning);
697 }
698 
699 bool AsyncScrollingCoordinator::visualViewportEnabled() const
700 {
701     return m_page-&gt;mainFrame().settings().visualViewportEnabled();
702 }
703 
704 bool AsyncScrollingCoordinator::asyncFrameOrOverflowScrollingEnabled() const
705 {
706     auto&amp; settings = m_page-&gt;mainFrame().settings();
707     return settings.asyncFrameScrollingEnabled() || settings.asyncOverflowScrollingEnabled();
708 }
709 
710 String AsyncScrollingCoordinator::scrollingStateTreeAsText(ScrollingStateTreeAsTextBehavior behavior) const
711 {
712     if (m_scrollingStateTree-&gt;rootStateNode()) {
713         if (m_eventTrackingRegionsDirty)
714             m_scrollingStateTree-&gt;rootStateNode()-&gt;setEventTrackingRegions(absoluteEventTrackingRegions());
715         return m_scrollingStateTree-&gt;rootStateNode()-&gt;scrollingStateTreeAsText(behavior);
716     }
717 
718     return String();
719 }
720 
721 #if PLATFORM(COCOA)
722 void AsyncScrollingCoordinator::setActiveScrollSnapIndices(ScrollingNodeID scrollingNodeID, unsigned horizontalIndex, unsigned verticalIndex)
723 {
724     ASSERT(isMainThread());
725 
726     if (!m_page)
727         return;
728 
729     auto* frameView = frameViewForScrollingNode(scrollingNodeID);
730     if (!frameView)
731         return;
732 
733     if (scrollingNodeID == frameView-&gt;scrollingNodeID()) {
734         frameView-&gt;setCurrentHorizontalSnapPointIndex(horizontalIndex);
735         frameView-&gt;setCurrentVerticalSnapPointIndex(verticalIndex);
736         return;
737     }
738 
739     // Overflow-scroll area.
740     if (auto* scrollableArea = frameView-&gt;scrollableAreaForScrollLayerID(scrollingNodeID)) {
741         scrollableArea-&gt;setCurrentHorizontalSnapPointIndex(horizontalIndex);
742         scrollableArea-&gt;setCurrentVerticalSnapPointIndex(verticalIndex);
743     }
744 }
745 
746 void AsyncScrollingCoordinator::deferTestsForReason(WheelEventTestTrigger::ScrollableAreaIdentifier identifier, WheelEventTestTrigger::DeferTestTriggerReason reason) const
747 {
748     ASSERT(isMainThread());
749     if (!m_page || !m_page-&gt;expectsWheelEventTriggers())
750         return;
751 
752     if (const auto&amp; trigger = m_page-&gt;testTrigger()) {
753         LOG(WheelEventTestTriggers, &quot;    (!) AsyncScrollingCoordinator::deferTestsForReason: Deferring %p for reason %d.&quot;, identifier, reason);
754         trigger-&gt;deferTestsForReason(identifier, reason);
755     }
756 }
757 
758 void AsyncScrollingCoordinator::removeTestDeferralForReason(WheelEventTestTrigger::ScrollableAreaIdentifier identifier, WheelEventTestTrigger::DeferTestTriggerReason reason) const
759 {
760     ASSERT(isMainThread());
761     if (!m_page || !m_page-&gt;expectsWheelEventTriggers())
762         return;
763 
764     if (const auto&amp; trigger = m_page-&gt;testTrigger()) {
765         LOG(WheelEventTestTriggers, &quot;    (!) AsyncScrollingCoordinator::removeTestDeferralForReason: Deferring %p for reason %d.&quot;, identifier, reason);
766         trigger-&gt;removeTestDeferralForReason(identifier, reason);
767     }
768 }
769 #endif
770 
771 #if ENABLE(CSS_SCROLL_SNAP)
772 bool AsyncScrollingCoordinator::isScrollSnapInProgress() const
773 {
774     return scrollingTree()-&gt;isScrollSnapInProgress();
775 }
776 
777 void AsyncScrollingCoordinator::updateScrollSnapPropertiesWithFrameView(const FrameView&amp; frameView)
778 {
779     if (auto node = downcast&lt;ScrollingStateFrameScrollingNode&gt;(m_scrollingStateTree-&gt;stateNodeForID(frameView.scrollingNodeID()))) {
780         setStateScrollingNodeSnapOffsetsAsFloat(*node, ScrollEventAxis::Horizontal, frameView.horizontalSnapOffsets(), frameView.horizontalSnapOffsetRanges(), m_page-&gt;deviceScaleFactor());
781         setStateScrollingNodeSnapOffsetsAsFloat(*node, ScrollEventAxis::Vertical, frameView.verticalSnapOffsets(), frameView.verticalSnapOffsetRanges(), m_page-&gt;deviceScaleFactor());
782         node-&gt;setCurrentHorizontalSnapPointIndex(frameView.currentHorizontalSnapPointIndex());
783         node-&gt;setCurrentVerticalSnapPointIndex(frameView.currentVerticalSnapPointIndex());
784     }
785 }
786 #endif
787 
788 void AsyncScrollingCoordinator::reportExposedUnfilledArea(MonotonicTime timestamp, unsigned unfilledArea)
789 {
790     if (m_page &amp;&amp; m_page-&gt;performanceLoggingClient())
791         m_page-&gt;performanceLoggingClient()-&gt;logScrollingEvent(PerformanceLoggingClient::ScrollingEvent::ExposedTilelessArea, timestamp, unfilledArea);
792 }
793 
794 void AsyncScrollingCoordinator::reportSynchronousScrollingReasonsChanged(MonotonicTime timestamp, SynchronousScrollingReasons reasons)
795 {
796     if (m_page &amp;&amp; m_page-&gt;performanceLoggingClient())
797         m_page-&gt;performanceLoggingClient()-&gt;logScrollingEvent(PerformanceLoggingClient::ScrollingEvent::SwitchedScrollingMode, timestamp, reasons);
798 }
799 
800 } // namespace WebCore
801 
802 #endif // ENABLE(ASYNC_SCROLLING)
    </pre>
  </body>
</html>