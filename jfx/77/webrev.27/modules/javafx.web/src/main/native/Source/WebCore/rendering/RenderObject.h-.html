<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderObject.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2000 Lars Knoll (knoll@kde.org)
   3  *           (C) 2000 Antti Koivisto (koivisto@kde.org)
   4  *           (C) 2000 Dirk Mueller (mueller@kde.org)
   5  *           (C) 2004 Allan Sandfeld Jensen (kde@carewolf.com)
   6  * Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2012 Apple Inc. All rights reserved.
   7  * Copyright (C) 2009 Google Inc. All rights reserved.
   8  *
   9  * This library is free software; you can redistribute it and/or
  10  * modify it under the terms of the GNU Library General Public
  11  * License as published by the Free Software Foundation; either
  12  * version 2 of the License, or (at your option) any later version.
  13  *
  14  * This library is distributed in the hope that it will be useful,
  15  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  16  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  17  * Library General Public License for more details.
  18  *
  19  * You should have received a copy of the GNU Library General Public License
  20  * along with this library; see the file COPYING.LIB.  If not, write to
  21  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  22  * Boston, MA 02110-1301, USA.
  23  *
  24  */
  25 
  26 #pragma once
  27 
  28 #include &quot;CachedImageClient.h&quot;
  29 #include &quot;Element.h&quot;
  30 #include &quot;FloatQuad.h&quot;
  31 #include &quot;Frame.h&quot;
  32 #include &quot;LayoutRect.h&quot;
  33 #include &quot;Page.h&quot;
  34 #include &quot;RenderObjectEnums.h&quot;
  35 #include &quot;RenderStyle.h&quot;
  36 #include &quot;ScrollAlignment.h&quot;
  37 #include &quot;StyleImage.h&quot;
  38 #include &quot;TextAffinity.h&quot;
  39 #include &lt;wtf/IsoMalloc.h&gt;
  40 #include &lt;wtf/WeakPtr.h&gt;
  41 
  42 namespace WebCore {
  43 
  44 class AffineTransform;
  45 class CSSAnimationController;
  46 class Color;
  47 class Cursor;
  48 class Document;
  49 class DocumentTimeline;
  50 class HitTestLocation;
  51 class HitTestRequest;
  52 class HitTestResult;
  53 class InlineBox;
  54 class Path;
  55 class Position;
  56 class PseudoStyleRequest;
  57 class RenderBoxModelObject;
  58 class RenderInline;
  59 class RenderBlock;
  60 class RenderElement;
  61 class RenderFragmentedFlow;
  62 class RenderGeometryMap;
  63 class RenderLayer;
  64 class RenderLayerModelObject;
  65 class RenderFragmentContainer;
  66 class RenderTheme;
  67 class RenderTreeBuilder;
  68 class SelectionRangeData;
  69 class TransformState;
  70 class VisiblePosition;
  71 
  72 #if PLATFORM(IOS_FAMILY)
  73 class SelectionRect;
  74 #endif
  75 
  76 struct PaintInfo;
  77 
  78 #if PLATFORM(IOS_FAMILY)
  79 const int caretWidth = 2; // This value should be kept in sync with UIKit. See &lt;rdar://problem/15580601&gt;.
  80 #else
  81 const int caretWidth = 1;
  82 #endif
  83 
  84 enum class ShouldAllowCrossOriginScrolling { No, Yes };
  85 
  86 struct ScrollRectToVisibleOptions;
  87 
  88 #if ENABLE(DASHBOARD_SUPPORT)
  89 struct AnnotatedRegionValue {
  90     bool operator==(const AnnotatedRegionValue&amp; o) const
  91     {
  92         return type == o.type &amp;&amp; bounds == o.bounds &amp;&amp; clip == o.clip &amp;&amp; label == o.label;
  93     }
  94     bool operator!=(const AnnotatedRegionValue&amp; o) const
  95     {
  96         return !(*this == o);
  97     }
  98 
  99     LayoutRect bounds;
 100     String label;
 101     LayoutRect clip;
 102     int type;
 103 };
 104 #endif
 105 
 106 // Base class for all rendering tree objects.
 107 class RenderObject : public CachedImageClient, public CanMakeWeakPtr&lt;RenderObject&gt; {
 108     WTF_MAKE_ISO_ALLOCATED(RenderObject);
 109     friend class RenderBlock;
 110     friend class RenderBlockFlow;
 111     friend class RenderElement;
 112     friend class RenderLayer;
 113 public:
 114     // Anonymous objects should pass the document as their node, and they will then automatically be
 115     // marked as anonymous in the constructor.
 116     explicit RenderObject(Node&amp;);
 117     virtual ~RenderObject();
 118 
 119     RenderTheme&amp; theme() const;
 120 
 121     virtual const char* renderName() const = 0;
 122 
 123     RenderElement* parent() const { return m_parent; }
 124     bool isDescendantOf(const RenderObject*) const;
 125 
 126     RenderObject* previousSibling() const { return m_previous; }
 127     RenderObject* nextSibling() const { return m_next; }
 128 
 129     // Use RenderElement versions instead.
 130     virtual RenderObject* firstChildSlow() const { return nullptr; }
 131     virtual RenderObject* lastChildSlow() const { return nullptr; }
 132 
 133     RenderObject* nextInPreOrder() const;
 134     RenderObject* nextInPreOrder(const RenderObject* stayWithin) const;
 135     RenderObject* nextInPreOrderAfterChildren() const;
 136     RenderObject* nextInPreOrderAfterChildren(const RenderObject* stayWithin) const;
 137     RenderObject* previousInPreOrder() const;
 138     RenderObject* previousInPreOrder(const RenderObject* stayWithin) const;
 139     WEBCORE_EXPORT RenderObject* childAt(unsigned) const;
 140 
 141     RenderObject* firstLeafChild() const;
 142     RenderObject* lastLeafChild() const;
 143 
 144 #if ENABLE(TEXT_AUTOSIZING)
 145     // Minimal distance between the block with fixed height and overflowing content and the text block to apply text autosizing.
 146     // The greater this constant is the more potential places we have where autosizing is turned off.
 147     // So it should be as low as possible. There are sites that break at 2.
 148     static const int TextAutoSizingFixedHeightDepth = 3;
 149 
 150     enum BlockContentHeightType {
 151         FixedHeight,
 152         FlexibleHeight,
 153         OverflowHeight
 154     };
 155 
 156     typedef BlockContentHeightType (*HeightTypeTraverseNextInclusionFunction)(const RenderObject&amp;);
 157     RenderObject* traverseNext(const RenderObject* stayWithin, HeightTypeTraverseNextInclusionFunction, int&amp; currentDepth,  int&amp; newFixedDepth) const;
 158 #endif
 159 
 160     WEBCORE_EXPORT RenderLayer* enclosingLayer() const;
 161 
 162     // Scrolling is a RenderBox concept, however some code just cares about recursively scrolling our enclosing ScrollableArea(s).
 163     WEBCORE_EXPORT bool scrollRectToVisible(const LayoutRect&amp; absoluteRect, bool insideFixed, const ScrollRectToVisibleOptions&amp;);
 164 
 165     // Convenience function for getting to the nearest enclosing box of a RenderObject.
 166     WEBCORE_EXPORT RenderBox&amp; enclosingBox() const;
 167     RenderBoxModelObject&amp; enclosingBoxModelObject() const;
 168     const RenderBox* enclosingScrollableContainerForSnapping() const;
 169 
 170     // Function to return our enclosing flow thread if we are contained inside one. This
 171     // function follows the containing block chain.
 172     RenderFragmentedFlow* enclosingFragmentedFlow() const
 173     {
 174         if (fragmentedFlowState() == NotInsideFragmentedFlow)
 175             return nullptr;
 176 
 177         return locateEnclosingFragmentedFlow();
 178     }
 179 
 180     WEBCORE_EXPORT bool useDarkAppearance() const;
 181     OptionSet&lt;StyleColor::Options&gt; styleColorOptions() const;
 182 
 183 #ifndef NDEBUG
 184     void setHasAXObject(bool flag) { m_hasAXObject = flag; }
 185     bool hasAXObject() const { return m_hasAXObject; }
 186 
 187     // Helper class forbidding calls to setNeedsLayout() during its lifetime.
 188     class SetLayoutNeededForbiddenScope {
 189     public:
 190         explicit SetLayoutNeededForbiddenScope(RenderObject*, bool isForbidden = true);
 191         ~SetLayoutNeededForbiddenScope();
 192     private:
 193         RenderObject* m_renderObject;
 194         bool m_preexistingForbidden;
 195     };
 196 #endif
 197 
 198     // Obtains the nearest enclosing block (including this block) that contributes a first-line style to our inline
 199     // children.
 200     virtual RenderBlock* firstLineBlock() const;
 201 
 202     // RenderObject tree manipulation
 203     //////////////////////////////////////////
 204     virtual bool canHaveChildren() const = 0;
 205     virtual bool canHaveGeneratedChildren() const;
 206     virtual bool createsAnonymousWrapper() const { return false; }
 207     //////////////////////////////////////////
 208 
 209 #if ENABLE(TREE_DEBUGGING)
 210     void showNodeTreeForThis() const;
 211     void showRenderTreeForThis() const;
 212     void showLineTreeForThis() const;
 213 
 214     void outputRenderObject(WTF::TextStream&amp;, bool mark, int depth) const;
 215     void outputRenderSubTreeAndMark(WTF::TextStream&amp;, const RenderObject* markedObject, int depth) const;
 216     void outputRegionsInformation(WTF::TextStream&amp;) const;
 217 #endif
 218 
 219     bool isPseudoElement() const { return node() &amp;&amp; node()-&gt;isPseudoElement(); }
 220 
 221     bool isRenderElement() const { return !isText(); }
 222     bool isRenderReplaced() const;
 223     bool isBoxModelObject() const;
 224     bool isRenderBlock() const;
 225     bool isRenderBlockFlow() const;
 226     bool isRenderInline() const;
 227     bool isRenderLayerModelObject() const;
 228 
 229     virtual bool isCounter() const { return false; }
 230     virtual bool isQuote() const { return false; }
 231 
 232     virtual bool isDetailsMarker() const { return false; }
 233     virtual bool isEmbeddedObject() const { return false; }
 234     bool isFieldset() const;
 235     virtual bool isFileUploadControl() const { return false; }
 236     virtual bool isFrame() const { return false; }
 237     virtual bool isFrameSet() const { return false; }
 238     virtual bool isImage() const { return false; }
 239     virtual bool isInlineBlockOrInlineTable() const { return false; }
 240     virtual bool isListBox() const { return false; }
 241     virtual bool isListItem() const { return false; }
 242     virtual bool isListMarker() const { return false; }
 243     virtual bool isMedia() const { return false; }
 244     virtual bool isMenuList() const { return false; }
 245 #if ENABLE(METER_ELEMENT)
 246     virtual bool isMeter() const { return false; }
 247 #endif
 248     virtual bool isSnapshottedPlugIn() const { return false; }
 249     virtual bool isProgress() const { return false; }
 250     virtual bool isRenderButton() const { return false; }
 251     virtual bool isRenderIFrame() const { return false; }
 252     virtual bool isRenderImage() const { return false; }
 253     virtual bool isRenderFragmentContainer() const { return false; }
 254     virtual bool isReplica() const { return false; }
 255 
 256     virtual bool isRubyInline() const { return false; }
 257     virtual bool isRubyBlock() const { return false; }
 258     virtual bool isRubyBase() const { return false; }
 259     virtual bool isRubyRun() const { return false; }
 260     virtual bool isRubyText() const { return false; }
 261 
 262     virtual bool isSlider() const { return false; }
 263     virtual bool isSliderThumb() const { return false; }
 264     virtual bool isTable() const { return false; }
 265     virtual bool isTableCell() const { return false; }
 266     virtual bool isRenderTableCol() const { return false; }
 267     virtual bool isTableCaption() const { return false; }
 268     virtual bool isTableRow() const { return false; }
 269     virtual bool isTableSection() const { return false; }
 270     virtual bool isTextControl() const { return false; }
 271     virtual bool isTextArea() const { return false; }
 272     virtual bool isTextField() const { return false; }
 273     virtual bool isSearchField() const { return false; }
 274     virtual bool isTextControlInnerBlock() const { return false; }
 275     virtual bool isVideo() const { return false; }
 276     virtual bool isWidget() const { return false; }
 277     virtual bool isCanvas() const { return false; }
 278 #if ENABLE(ATTACHMENT_ELEMENT)
 279     virtual bool isAttachment() const { return false; }
 280 #endif
 281 #if ENABLE(FULLSCREEN_API)
 282     virtual bool isRenderFullScreen() const { return false; }
 283     virtual bool isRenderFullScreenPlaceholder() const { return false; }
 284 #endif
 285     virtual bool isRenderGrid() const { return false; }
 286     bool isInFlowRenderFragmentedFlow() const { return isRenderFragmentedFlow() &amp;&amp; !isOutOfFlowPositioned(); }
 287     bool isOutOfFlowRenderFragmentedFlow() const { return isRenderFragmentedFlow() &amp;&amp; isOutOfFlowPositioned(); }
 288 
 289     virtual bool isMultiColumnBlockFlow() const { return false; }
 290     virtual bool isRenderMultiColumnSet() const { return false; }
 291     virtual bool isRenderMultiColumnFlow() const { return false; }
 292     virtual bool isRenderMultiColumnSpannerPlaceholder() const { return false; }
 293 
 294     virtual bool isRenderScrollbarPart() const { return false; }
 295 
 296     bool isDocumentElementRenderer() const { return document().documentElement() == &amp;m_node; }
 297     bool isBody() const { return node() &amp;&amp; node()-&gt;hasTagName(HTMLNames::bodyTag); }
 298     bool isHR() const { return node() &amp;&amp; node()-&gt;hasTagName(HTMLNames::hrTag); }
 299     bool isLegend() const;
 300 
 301     bool isHTMLMarquee() const;
 302 
 303     bool isTablePart() const { return isTableCell() || isRenderTableCol() || isTableCaption() || isTableRow() || isTableSection(); }
 304 
 305     inline bool isBeforeContent() const;
 306     inline bool isAfterContent() const;
 307     inline bool isBeforeOrAfterContent() const;
 308     static inline bool isBeforeContent(const RenderObject* obj) { return obj &amp;&amp; obj-&gt;isBeforeContent(); }
 309     static inline bool isAfterContent(const RenderObject* obj) { return obj &amp;&amp; obj-&gt;isAfterContent(); }
 310     static inline bool isBeforeOrAfterContent(const RenderObject* obj) { return obj &amp;&amp; obj-&gt;isBeforeOrAfterContent(); }
 311 
 312     bool beingDestroyed() const { return m_bitfields.beingDestroyed(); }
 313 
 314     bool everHadLayout() const { return m_bitfields.everHadLayout(); }
 315 
 316     bool childrenInline() const { return m_bitfields.childrenInline(); }
 317     void setChildrenInline(bool b) { m_bitfields.setChildrenInline(b); }
 318 
 319     enum FragmentedFlowState {
 320         NotInsideFragmentedFlow = 0,
 321         InsideInFragmentedFlow = 1,
 322     };
 323 
 324     void setFragmentedFlowStateIncludingDescendants(FragmentedFlowState);
 325 
 326     FragmentedFlowState fragmentedFlowState() const { return m_bitfields.fragmentedFlowState(); }
 327     void setFragmentedFlowState(FragmentedFlowState state) { m_bitfields.setFragmentedFlowState(state); }
 328 
 329 #if ENABLE(MATHML)
 330     virtual bool isRenderMathMLBlock() const { return false; }
 331     virtual bool isRenderMathMLTable() const { return false; }
 332     virtual bool isRenderMathMLOperator() const { return false; }
 333     virtual bool isRenderMathMLRow() const { return false; }
 334     virtual bool isRenderMathMLMath() const { return false; }
 335     virtual bool isRenderMathMLMenclose() const { return false; }
 336     virtual bool isRenderMathMLFenced() const { return false; }
 337     virtual bool isRenderMathMLFencedOperator() const { return false; }
 338     virtual bool isRenderMathMLFraction() const { return false; }
 339     virtual bool isRenderMathMLPadded() const { return false; }
 340     virtual bool isRenderMathMLRoot() const { return false; }
 341     virtual bool isRenderMathMLSpace() const { return false; }
 342     virtual bool isRenderMathMLSquareRoot() const { return false; }
 343     virtual bool isRenderMathMLScripts() const { return false; }
 344     virtual bool isRenderMathMLToken() const { return false; }
 345     virtual bool isRenderMathMLUnderOver() const { return false; }
 346 #endif // ENABLE(MATHML)
 347 
 348     // FIXME: Until all SVG renders can be subclasses of RenderSVGModelObject we have
 349     // to add SVG renderer methods to RenderObject with an ASSERT_NOT_REACHED() default implementation.
 350     virtual bool isRenderSVGModelObject() const { return false; }
 351     virtual bool isRenderSVGBlock() const { return false; };
 352     virtual bool isSVGRoot() const { return false; }
 353     virtual bool isSVGContainer() const { return false; }
 354     virtual bool isSVGTransformableContainer() const { return false; }
 355     virtual bool isSVGViewportContainer() const { return false; }
 356     virtual bool isSVGGradientStop() const { return false; }
 357     virtual bool isSVGHiddenContainer() const { return false; }
 358     virtual bool isSVGPath() const { return false; }
 359     virtual bool isSVGShape() const { return false; }
 360     virtual bool isSVGText() const { return false; }
 361     virtual bool isSVGTextPath() const { return false; }
 362     virtual bool isSVGTSpan() const { return false; }
 363     virtual bool isSVGInline() const { return false; }
 364     virtual bool isSVGInlineText() const { return false; }
 365     virtual bool isSVGImage() const { return false; }
 366     virtual bool isSVGForeignObject() const { return false; }
 367     virtual bool isSVGResourceContainer() const { return false; }
 368     virtual bool isSVGResourceFilter() const { return false; }
 369     virtual bool isSVGResourceClipper() const { return false; }
 370     virtual bool isSVGResourceFilterPrimitive() const { return false; }
 371 
 372     // FIXME: Those belong into a SVG specific base-class for all renderers (see above)
 373     // Unfortunately we don&#39;t have such a class yet, because it&#39;s not possible for all renderers
 374     // to inherit from RenderSVGObject -&gt; RenderObject (some need RenderBlock inheritance for instance)
 375     virtual void setNeedsTransformUpdate() { }
 376     virtual void setNeedsBoundariesUpdate();
 377     virtual bool needsBoundariesUpdate() { return false; }
 378 
 379     // Per SVG 1.1 objectBoundingBox ignores clipping, masking, filter effects, opacity and stroke-width.
 380     // This is used for all computation of objectBoundingBox relative units and by SVGLocatable::getBBox().
 381     // NOTE: Markers are not specifically ignored here by SVG 1.1 spec, but we ignore them
 382     // since stroke-width is ignored (and marker size can depend on stroke-width).
 383     // objectBoundingBox is returned local coordinates.
 384     // The name objectBoundingBox is taken from the SVG 1.1 spec.
 385     virtual FloatRect objectBoundingBox() const;
 386     virtual FloatRect strokeBoundingBox() const;
 387 
 388     // Returns the smallest rectangle enclosing all of the painted content
 389     // respecting clipping, masking, filters, opacity, stroke-width and markers
 390     virtual FloatRect repaintRectInLocalCoordinates() const;
 391 
 392     // This only returns the transform=&quot;&quot; value from the element
 393     // most callsites want localToParentTransform() instead.
 394     virtual AffineTransform localTransform() const;
 395 
 396     // Returns the full transform mapping from local coordinates to local coords for the parent SVG renderer
 397     // This includes any viewport transforms and x/y offsets as well as the transform=&quot;&quot; value off the element.
 398     virtual const AffineTransform&amp; localToParentTransform() const;
 399 
 400     // SVG uses FloatPoint precise hit testing, and passes the point in parent
 401     // coordinates instead of in repaint container coordinates.  Eventually the
 402     // rest of the rendering tree will move to a similar model.
 403     virtual bool nodeAtFloatPoint(const HitTestRequest&amp;, HitTestResult&amp;, const FloatPoint&amp; pointInParent, HitTestAction);
 404 
 405     bool hasAspectRatio() const { return isReplaced() &amp;&amp; (isImage() || isVideo() || isCanvas()); }
 406     bool isAnonymous() const { return m_bitfields.isAnonymous(); }
 407     bool isAnonymousBlock() const
 408     {
 409         // This function is kept in sync with anonymous block creation conditions in
 410         // RenderBlock::createAnonymousBlock(). This includes creating an anonymous
 411         // RenderBlock having a DisplayType::Block or DisplayType::Box display. Other classes such as RenderTextFragment
 412         // are not RenderBlocks and will return false. See https://bugs.webkit.org/show_bug.cgi?id=56709.
 413         return isAnonymous() &amp;&amp; (style().display() == DisplayType::Block || style().display() == DisplayType::Box) &amp;&amp; style().styleType() == PseudoId::None &amp;&amp; isRenderBlock() &amp;&amp; !isListMarker() &amp;&amp; !isRenderFragmentedFlow() &amp;&amp; !isRenderMultiColumnSet() &amp;&amp; !isRenderView()
 414 #if ENABLE(FULLSCREEN_API)
 415             &amp;&amp; !isRenderFullScreen()
 416             &amp;&amp; !isRenderFullScreenPlaceholder()
 417 #endif
 418 #if ENABLE(MATHML)
 419             &amp;&amp; !isRenderMathMLBlock()
 420 #endif
 421             ;
 422     }
 423 
 424     bool isFloating() const { return m_bitfields.floating(); }
 425 
 426     bool isPositioned() const { return m_bitfields.isPositioned(); }
 427     bool isInFlowPositioned() const { return m_bitfields.isRelativelyPositioned() || m_bitfields.isStickilyPositioned(); }
 428     bool isOutOfFlowPositioned() const { return m_bitfields.isOutOfFlowPositioned(); } // absolute or fixed positioning
 429     bool isFixedPositioned() const { return isOutOfFlowPositioned() &amp;&amp; style().position() == PositionType::Fixed; }
 430     bool isAbsolutelyPositioned() const { return isOutOfFlowPositioned() &amp;&amp; style().position() == PositionType::Absolute; }
 431     bool isRelativelyPositioned() const { return m_bitfields.isRelativelyPositioned(); }
 432     bool isStickilyPositioned() const { return m_bitfields.isStickilyPositioned(); }
 433 
 434     bool isText() const  { return !m_bitfields.isBox() &amp;&amp; m_bitfields.isTextOrRenderView(); }
 435     bool isLineBreak() const { return m_bitfields.isLineBreak(); }
 436     bool isBR() const { return isLineBreak() &amp;&amp; !isWBR(); }
 437     bool isLineBreakOpportunity() const { return isLineBreak() &amp;&amp; isWBR(); }
 438     bool isTextOrLineBreak() const { return isText() || isLineBreak(); }
 439     bool isBox() const { return m_bitfields.isBox(); }
 440     bool isRenderView() const  { return m_bitfields.isBox() &amp;&amp; m_bitfields.isTextOrRenderView(); }
 441     bool isInline() const { return m_bitfields.isInline(); } // inline object
 442     bool isReplaced() const { return m_bitfields.isReplaced(); } // a &quot;replaced&quot; element (see CSS)
 443     bool isHorizontalWritingMode() const { return m_bitfields.horizontalWritingMode(); }
 444 
 445     bool isDragging() const { return m_bitfields.hasRareData() &amp;&amp; rareData().isDragging(); }
 446     bool hasReflection() const { return m_bitfields.hasRareData() &amp;&amp; rareData().hasReflection(); }
 447     bool isRenderFragmentedFlow() const { return m_bitfields.hasRareData() &amp;&amp; rareData().isRenderFragmentedFlow(); }
 448     bool hasOutlineAutoAncestor() const { return m_bitfields.hasRareData() &amp;&amp; rareData().hasOutlineAutoAncestor(); }
 449 
 450     bool isExcludedFromNormalLayout() const { return m_bitfields.isExcludedFromNormalLayout(); }
 451     void setIsExcludedFromNormalLayout(bool excluded) { m_bitfields.setIsExcludedFromNormalLayout(excluded); }
 452     bool isExcludedAndPlacedInBorder() const { return isExcludedFromNormalLayout() &amp;&amp; isLegend(); }
 453 
 454     bool hasLayer() const { return m_bitfields.hasLayer(); }
 455 
 456     enum BoxDecorationState {
 457         NoBoxDecorations,
 458         HasBoxDecorationsAndBackgroundObscurationStatusInvalid,
 459         HasBoxDecorationsAndBackgroundIsKnownToBeObscured,
 460         HasBoxDecorationsAndBackgroundMayBeVisible,
 461     };
 462     bool hasVisibleBoxDecorations() const { return m_bitfields.boxDecorationState() != NoBoxDecorations; }
 463     bool backgroundIsKnownToBeObscured(const LayoutPoint&amp; paintOffset);
 464 
 465     bool needsLayout() const
 466     {
 467         return m_bitfields.needsLayout() || m_bitfields.normalChildNeedsLayout() || m_bitfields.posChildNeedsLayout()
 468             || m_bitfields.needsSimplifiedNormalFlowLayout() || m_bitfields.needsPositionedMovementLayout();
 469     }
 470 
 471     bool selfNeedsLayout() const { return m_bitfields.needsLayout(); }
 472     bool needsPositionedMovementLayout() const { return m_bitfields.needsPositionedMovementLayout(); }
 473     bool needsPositionedMovementLayoutOnly() const
 474     {
 475         return m_bitfields.needsPositionedMovementLayout() &amp;&amp; !m_bitfields.needsLayout() &amp;&amp; !m_bitfields.normalChildNeedsLayout()
 476             &amp;&amp; !m_bitfields.posChildNeedsLayout() &amp;&amp; !m_bitfields.needsSimplifiedNormalFlowLayout();
 477     }
 478 
 479     bool posChildNeedsLayout() const { return m_bitfields.posChildNeedsLayout(); }
 480     bool needsSimplifiedNormalFlowLayout() const { return m_bitfields.needsSimplifiedNormalFlowLayout(); }
 481     bool needsSimplifiedNormalFlowLayoutOnly() const;
 482     bool normalChildNeedsLayout() const { return m_bitfields.normalChildNeedsLayout(); }
 483 
 484     bool preferredLogicalWidthsDirty() const { return m_bitfields.preferredLogicalWidthsDirty(); }
 485 
 486     bool isSelectionBorder() const;
 487 
 488     bool hasOverflowClip() const { return m_bitfields.hasOverflowClip(); }
 489 
 490     bool hasTransformRelatedProperty() const { return m_bitfields.hasTransformRelatedProperty(); } // Transform, perspective or transform-style: preserve-3d.
 491     bool hasTransform() const { return hasTransformRelatedProperty() &amp;&amp; style().hasTransform(); }
 492 
 493     inline bool preservesNewline() const;
 494 
 495     virtual void updateDragState(bool dragOn);
 496 
 497     RenderView&amp; view() const { return *document().renderView(); };
 498 
 499     // Returns true if this renderer is rooted.
 500     bool isRooted() const;
 501 
 502     Node* node() const { return isAnonymous() ? nullptr : &amp;m_node; }
 503     Node* nonPseudoNode() const { return isPseudoElement() ? nullptr : node(); }
 504 
 505     // Returns the styled node that caused the generation of this renderer.
 506     // This is the same as node() except for renderers of :before and :after
 507     // pseudo elements for which their parent node is returned.
 508     Node* generatingNode() const { return isPseudoElement() ? generatingPseudoHostElement() : node(); }
 509 
 510     Document&amp; document() const { return m_node.document(); }
 511     Frame&amp; frame() const;
 512     Page&amp; page() const;
 513     Settings&amp; settings() const { return page().settings(); }
 514 
 515     // Returns the object containing this one. Can be different from parent for positioned elements.
 516     // If repaintContainer and repaintContainerSkipped are not null, on return *repaintContainerSkipped
 517     // is true if the renderer returned is an ancestor of repaintContainer.
 518     RenderElement* container() const;
 519     RenderElement* container(const RenderLayerModelObject* repaintContainer, bool&amp; repaintContainerSkipped) const;
 520 
 521     RenderBoxModelObject* offsetParent() const;
 522 
 523     void markContainingBlocksForLayout(ScheduleRelayout = ScheduleRelayout::Yes, RenderElement* newRoot = nullptr);
 524     void setNeedsLayout(MarkingBehavior = MarkContainingBlockChain);
 525     void clearNeedsLayout();
 526     void setPreferredLogicalWidthsDirty(bool, MarkingBehavior = MarkContainingBlockChain);
 527     void invalidateContainerPreferredLogicalWidths();
 528 
 529     void setNeedsLayoutAndPrefWidthsRecalc()
 530     {
 531         setNeedsLayout();
 532         setPreferredLogicalWidthsDirty(true);
 533     }
 534 
 535     void setPositionState(PositionType position)
 536     {
 537         ASSERT((position != PositionType::Absolute &amp;&amp; position != PositionType::Fixed) || isBox());
 538         m_bitfields.setPositionedState(static_cast&lt;int&gt;(position));
 539     }
 540     void clearPositionedState() { m_bitfields.clearPositionedState(); }
 541 
 542     void setFloating(bool b = true) { m_bitfields.setFloating(b); }
 543     void setInline(bool b = true) { m_bitfields.setIsInline(b); }
 544 
 545     void setHasVisibleBoxDecorations(bool = true);
 546     void invalidateBackgroundObscurationStatus();
 547     virtual bool computeBackgroundIsKnownToBeObscured(const LayoutPoint&amp;) { return false; }
 548 
 549     void setIsText() { ASSERT(!isBox()); m_bitfields.setIsTextOrRenderView(true); }
 550     void setIsLineBreak() { m_bitfields.setIsLineBreak(true); }
 551     void setIsBox() { m_bitfields.setIsBox(true); }
 552     void setIsRenderView() { ASSERT(isBox()); m_bitfields.setIsTextOrRenderView(true); }
 553     void setReplaced(bool b = true) { m_bitfields.setIsReplaced(b); }
 554     void setHorizontalWritingMode(bool b = true) { m_bitfields.setHorizontalWritingMode(b); }
 555     void setHasOverflowClip(bool b = true) { m_bitfields.setHasOverflowClip(b); }
 556     void setHasLayer(bool b = true) { m_bitfields.setHasLayer(b); }
 557     void setHasTransformRelatedProperty(bool b = true) { m_bitfields.setHasTransformRelatedProperty(b); }
 558 
 559     void setIsDragging(bool);
 560     void setHasReflection(bool = true);
 561     void setIsRenderFragmentedFlow(bool = true);
 562     void setHasOutlineAutoAncestor(bool = true);
 563 
 564     // Hook so that RenderTextControl can return the line height of its inner renderer.
 565     // For other renderers, the value is the same as lineHeight(false).
 566     virtual int innerLineHeight() const;
 567 
 568     // used for element state updates that cannot be fixed with a
 569     // repaint and do not need a relayout
 570     virtual void updateFromElement() { }
 571 
 572 #if ENABLE(DASHBOARD_SUPPORT)
 573     virtual void addAnnotatedRegions(Vector&lt;AnnotatedRegionValue&gt;&amp;);
 574     void collectAnnotatedRegions(Vector&lt;AnnotatedRegionValue&gt;&amp;);
 575 #endif
 576 
 577     bool isComposited() const;
 578 
 579     bool hitTest(const HitTestRequest&amp;, HitTestResult&amp;, const HitTestLocation&amp; locationInContainer, const LayoutPoint&amp; accumulatedOffset, HitTestFilter = HitTestAll);
 580     virtual void updateHitTestResult(HitTestResult&amp;, const LayoutPoint&amp;);
 581     virtual bool nodeAtPoint(const HitTestRequest&amp;, HitTestResult&amp;, const HitTestLocation&amp; locationInContainer, const LayoutPoint&amp; accumulatedOffset, HitTestAction);
 582 
 583     virtual Position positionForPoint(const LayoutPoint&amp;);
 584     virtual VisiblePosition positionForPoint(const LayoutPoint&amp;, const RenderFragmentContainer*);
 585     VisiblePosition createVisiblePosition(int offset, EAffinity) const;
 586     VisiblePosition createVisiblePosition(const Position&amp;) const;
 587 
 588     // returns the containing block level element for this element.
 589     WEBCORE_EXPORT RenderBlock* containingBlock() const;
 590     RenderBlock* containingBlockForObjectInFlow() const;
 591 
 592     // Convert the given local point to absolute coordinates. If MapCoordinatesFlags includes UseTransforms, take transforms into account.
 593     WEBCORE_EXPORT FloatPoint localToAbsolute(const FloatPoint&amp; localPoint = FloatPoint(), MapCoordinatesFlags = 0, bool* wasFixed = nullptr) const;
 594     FloatPoint absoluteToLocal(const FloatPoint&amp;, MapCoordinatesFlags = 0) const;
 595 
 596     // Convert a local quad to absolute coordinates, taking transforms into account.
 597     FloatQuad localToAbsoluteQuad(const FloatQuad&amp; quad, MapCoordinatesFlags mode = UseTransforms, bool* wasFixed = nullptr) const
 598     {
 599         return localToContainerQuad(quad, nullptr, mode, wasFixed);
 600     }
 601     // Convert an absolute quad to local coordinates.
 602     FloatQuad absoluteToLocalQuad(const FloatQuad&amp;, MapCoordinatesFlags mode = UseTransforms) const;
 603 
 604     // Convert a local quad into the coordinate system of container, taking transforms into account.
 605     WEBCORE_EXPORT FloatQuad localToContainerQuad(const FloatQuad&amp;, const RenderLayerModelObject* repaintContainer, MapCoordinatesFlags = UseTransforms, bool* wasFixed = nullptr) const;
 606     WEBCORE_EXPORT FloatPoint localToContainerPoint(const FloatPoint&amp;, const RenderLayerModelObject* repaintContainer, MapCoordinatesFlags = UseTransforms, bool* wasFixed = nullptr) const;
 607 
 608     // Return the offset from the container() renderer (excluding transforms). In multi-column layout,
 609     // different offsets apply at different points, so return the offset that applies to the given point.
 610     virtual LayoutSize offsetFromContainer(RenderElement&amp;, const LayoutPoint&amp;, bool* offsetDependsOnPoint = nullptr) const;
 611     // Return the offset from an object up the container() chain. Asserts that none of the intermediate objects have transforms.
 612     LayoutSize offsetFromAncestorContainer(RenderElement&amp;) const;
 613 
 614 #if PLATFORM(IOS_FAMILY)
 615     virtual void collectSelectionRects(Vector&lt;SelectionRect&gt;&amp;, unsigned startOffset = 0, unsigned endOffset = std::numeric_limits&lt;unsigned&gt;::max());
 616     virtual void absoluteQuadsForSelection(Vector&lt;FloatQuad&gt;&amp; quads) const { absoluteQuads(quads); }
 617 #endif
 618 
 619     virtual void absoluteRects(Vector&lt;IntRect&gt;&amp;, const LayoutPoint&amp;) const { }
 620 
 621     // FIXME: useTransforms should go away eventually
 622     WEBCORE_EXPORT IntRect absoluteBoundingBoxRect(bool useTransform = true, bool* wasFixed = nullptr) const;
 623     IntRect absoluteBoundingBoxRectIgnoringTransforms() const { return absoluteBoundingBoxRect(false); }
 624 
 625     // Build an array of quads in absolute coords for line boxes
 626     virtual void absoluteQuads(Vector&lt;FloatQuad&gt;&amp;, bool* /*wasFixed*/ = nullptr) const { }
 627 
 628     virtual void absoluteFocusRingQuads(Vector&lt;FloatQuad&gt;&amp;);
 629 
 630     static FloatRect absoluteBoundingBoxRectForRange(const Range*);
 631 
 632     // the rect that will be painted if this object is passed as the paintingRoot
 633     WEBCORE_EXPORT LayoutRect paintingRootRect(LayoutRect&amp; topLevelRect);
 634 
 635     virtual LayoutUnit minPreferredLogicalWidth() const { return 0; }
 636     virtual LayoutUnit maxPreferredLogicalWidth() const { return 0; }
 637 
 638     const RenderStyle&amp; style() const;
 639     const RenderStyle&amp; firstLineStyle() const;
 640 
 641     // Anonymous blocks that are part of of a continuation chain will return their inline continuation&#39;s outline style instead.
 642     // This is typically only relevant when repainting.
 643     virtual const RenderStyle&amp; outlineStyleForRepaint() const { return style(); }
 644 
 645     virtual CursorDirective getCursor(const LayoutPoint&amp;, Cursor&amp;) const;
 646 
 647     // Return the RenderLayerModelObject in the container chain which is responsible for painting this object, or nullptr
 648     // if painting is root-relative. This is the container that should be passed to the &#39;forRepaint&#39;
 649     // methods.
 650     RenderLayerModelObject* containerForRepaint() const;
 651     // Actually do the repaint of rect r for this object which has been computed in the coordinate space
 652     // of repaintContainer. If repaintContainer is nullptr, repaint via the view.
 653     void repaintUsingContainer(const RenderLayerModelObject* repaintContainer, const LayoutRect&amp;, bool shouldClipToLayer = true) const;
 654 
 655     // Repaint the entire object.  Called when, e.g., the color of a border changes, or when a border
 656     // style changes.
 657     void repaint() const;
 658 
 659     // Repaint a specific subrectangle within a given object.  The rect |r| is in the object&#39;s coordinate space.
 660     WEBCORE_EXPORT void repaintRectangle(const LayoutRect&amp;, bool shouldClipToLayer = true) const;
 661 
 662     // Repaint a slow repaint object, which, at this time, means we are repainting an object with background-attachment:fixed.
 663     void repaintSlowRepaintObject() const;
 664 
 665     // Returns the rect that should be repainted whenever this object changes.  The rect is in the view&#39;s
 666     // coordinate space.  This method deals with outlines and overflow.
 667     LayoutRect absoluteClippedOverflowRect() const
 668     {
 669         return clippedOverflowRectForRepaint(nullptr);
 670     }
 671     WEBCORE_EXPORT IntRect pixelSnappedAbsoluteClippedOverflowRect() const;
 672     virtual LayoutRect clippedOverflowRectForRepaint(const RenderLayerModelObject* repaintContainer) const;
 673     virtual LayoutRect rectWithOutlineForRepaint(const RenderLayerModelObject* repaintContainer, LayoutUnit outlineWidth) const;
 674     virtual LayoutRect outlineBoundsForRepaint(const RenderLayerModelObject* /*repaintContainer*/, const RenderGeometryMap* = nullptr) const { return LayoutRect(); }
 675 
 676     // Given a rect in the object&#39;s coordinate space, compute a rect suitable for repainting
 677     // that rect in view coordinates.
 678     LayoutRect computeAbsoluteRepaintRect(const LayoutRect&amp; r) const
 679     {
 680         return computeRectForRepaint(r, nullptr);
 681     }
 682     // Given a rect in the object&#39;s coordinate space, compute a rect suitable for repainting
 683     // that rect in the coordinate space of repaintContainer.
 684     LayoutRect computeRectForRepaint(const LayoutRect&amp;, const RenderLayerModelObject* repaintContainer) const;
 685     FloatRect computeFloatRectForRepaint(const FloatRect&amp;, const RenderLayerModelObject* repaintContainer) const;
 686 
 687     // Given a rect in the object&#39;s coordinate space, compute the location in container space where this rect is visible,
 688     // when clipping and scrolling as specified by the context. When using edge-inclusive intersection, return WTF::nullopt
 689     // rather than an empty rect if the rect is completely clipped out in container space.
 690     enum class VisibleRectContextOption {
 691         UseEdgeInclusiveIntersection = 1 &lt;&lt; 0,
 692         ApplyCompositedClips = 1 &lt;&lt; 1,
 693         ApplyCompositedContainerScrolls  = 1 &lt;&lt; 2,
 694     };
 695     struct VisibleRectContext {
 696         VisibleRectContext(bool hasPositionFixedDescendant = false, bool dirtyRectIsFlipped = false, OptionSet&lt;VisibleRectContextOption&gt; options = { })
 697             : m_hasPositionFixedDescendant(hasPositionFixedDescendant)
 698             , m_dirtyRectIsFlipped(dirtyRectIsFlipped)
 699             , m_options(options)
 700             {
 701             }
 702         bool m_hasPositionFixedDescendant;
 703         bool m_dirtyRectIsFlipped;
 704         OptionSet&lt;VisibleRectContextOption&gt; m_options;
 705     };
 706     virtual Optional&lt;LayoutRect&gt; computeVisibleRectInContainer(const LayoutRect&amp;, const RenderLayerModelObject* repaintContainer, VisibleRectContext) const;
 707     virtual Optional&lt;FloatRect&gt; computeFloatVisibleRectInContainer(const FloatRect&amp;, const RenderLayerModelObject* repaintContainer, VisibleRectContext) const;
 708 
 709     virtual unsigned int length() const { return 1; }
 710 
 711     bool isFloatingOrOutOfFlowPositioned() const { return (isFloating() || isOutOfFlowPositioned()); }
 712 
 713     enum SelectionState {
 714         SelectionNone, // The object is not selected.
 715         SelectionStart, // The object either contains the start of a selection run or is the start of a run
 716         SelectionInside, // The object is fully encompassed by a selection run
 717         SelectionEnd, // The object either contains the end of a selection run or is the end of a run
 718         SelectionBoth // The object contains an entire run or is the sole selected object in that run
 719     };
 720 
 721     // The current selection state for an object.  For blocks, the state refers to the state of the leaf
 722     // descendants (as described above in the SelectionState enum declaration).
 723     SelectionState selectionState() const { return m_bitfields.selectionState(); }
 724     virtual void setSelectionState(SelectionState state) { m_bitfields.setSelectionState(state); }
 725     inline void setSelectionStateIfNeeded(SelectionState);
 726     bool canUpdateSelectionOnRootLineBoxes();
 727 
 728     // A single rectangle that encompasses all of the selected objects within this object.  Used to determine the tightest
 729     // possible bounding box for the selection.
 730     LayoutRect selectionRect(bool clipToVisibleContent = true) { return selectionRectForRepaint(nullptr, clipToVisibleContent); }
 731     virtual LayoutRect selectionRectForRepaint(const RenderLayerModelObject* /*repaintContainer*/, bool /*clipToVisibleContent*/ = true) { return LayoutRect(); }
 732 
 733     virtual bool canBeSelectionLeaf() const { return false; }
 734 
 735     // Whether or not a given block needs to paint selection gaps.
 736     virtual bool shouldPaintSelectionGaps() const { return false; }
 737 
 738     /**
 739      * Returns the local coordinates of the caret within this render object.
 740      * @param caretOffset zero-based offset determining position within the render object.
 741      * @param extraWidthToEndOfLine optional out arg to give extra width to end of line -
 742      * useful for character range rect computations
 743      */
 744     virtual LayoutRect localCaretRect(InlineBox*, unsigned caretOffset, LayoutUnit* extraWidthToEndOfLine = nullptr);
 745 
 746     // When performing a global document tear-down, or when going into the page cache, the renderer of the document is cleared.
 747     bool renderTreeBeingDestroyed() const;
 748 
 749     void destroy();
 750 
 751     // Virtual function helpers for the deprecated Flexible Box Layout (display: -webkit-box).
 752     virtual bool isDeprecatedFlexibleBox() const { return false; }
 753 
 754     // Virtual function helper for the new FlexibleBox Layout (display: -webkit-flex).
 755     virtual bool isFlexibleBox() const { return false; }
 756 
 757     bool isFlexibleBoxIncludingDeprecated() const
 758     {
 759         return isFlexibleBox() || isDeprecatedFlexibleBox();
 760     }
 761 
 762     virtual bool isCombineText() const { return false; }
 763 
 764     virtual int caretMinOffset() const;
 765     virtual int caretMaxOffset() const;
 766 
 767     virtual int previousOffset(int current) const;
 768     virtual int previousOffsetForBackwardDeletion(int current) const;
 769     virtual int nextOffset(int current) const;
 770 
 771     void imageChanged(CachedImage*, const IntRect* = nullptr) override;
 772     virtual void imageChanged(WrappedImagePtr, const IntRect* = nullptr) { }
 773 
 774     CSSAnimationController&amp; animation() const;
 775     DocumentTimeline* documentTimeline() const;
 776 
 777     // Map points and quads through elements, potentially via 3d transforms. You should never need to call these directly; use
 778     // localToAbsolute/absoluteToLocal methods instead.
 779     virtual void mapLocalToContainer(const RenderLayerModelObject* repaintContainer, TransformState&amp;, MapCoordinatesFlags, bool* wasFixed = nullptr) const;
 780     virtual void mapAbsoluteToLocalPoint(MapCoordinatesFlags, TransformState&amp;) const;
 781 
 782     // Pushes state onto RenderGeometryMap about how to map coordinates from this renderer to its container, or ancestorToStopAt (whichever is encountered first).
 783     // Returns the renderer which was mapped to (container or ancestorToStopAt).
 784     virtual const RenderObject* pushMappingToContainer(const RenderLayerModelObject* ancestorToStopAt, RenderGeometryMap&amp;) const;
 785 
 786     bool shouldUseTransformFromContainer(const RenderObject* container) const;
 787     void getTransformFromContainer(const RenderObject* container, const LayoutSize&amp; offsetInContainer, TransformationMatrix&amp;) const;
 788 
 789     virtual void addFocusRingRects(Vector&lt;LayoutRect&gt;&amp;, const LayoutPoint&amp; /* additionalOffset */, const RenderLayerModelObject* /* paintContainer */ = nullptr) { };
 790 
 791     LayoutRect absoluteOutlineBounds() const
 792     {
 793         return outlineBoundsForRepaint(nullptr);
 794     }
 795 
 796     virtual void willBeRemovedFromTree();
 797     void resetFragmentedFlowStateOnRemoval();
 798     void initializeFragmentedFlowStateOnInsertion();
 799     virtual void insertedIntoTree();
 800 
 801     WEBCORE_EXPORT bool isTransparentOrFullyClippedRespectingParentFrames() const;
 802 
 803 protected:
 804     //////////////////////////////////////////
 805     // Helper functions. Dangerous to use!
 806     void setPreviousSibling(RenderObject* previous) { m_previous = previous; }
 807     void setNextSibling(RenderObject* next) { m_next = next; }
 808     void setParent(RenderElement*);
 809     //////////////////////////////////////////
 810     void addPDFURLRect(PaintInfo&amp;, const LayoutPoint&amp;);
 811     Node&amp; nodeForNonAnonymous() const { ASSERT(!isAnonymous()); return m_node; }
 812 
 813     void adjustRectForOutlineAndShadow(LayoutRect&amp;) const;
 814 
 815     virtual void willBeDestroyed();
 816 
 817     void setNeedsPositionedMovementLayoutBit(bool b) { m_bitfields.setNeedsPositionedMovementLayout(b); }
 818     void setNormalChildNeedsLayoutBit(bool b) { m_bitfields.setNormalChildNeedsLayout(b); }
 819     void setPosChildNeedsLayoutBit(bool b) { m_bitfields.setPosChildNeedsLayout(b); }
 820     void setNeedsSimplifiedNormalFlowLayoutBit(bool b) { m_bitfields.setNeedsSimplifiedNormalFlowLayout(b); }
 821 
 822     virtual RenderFragmentedFlow* locateEnclosingFragmentedFlow() const;
 823     static void calculateBorderStyleColor(const BorderStyle&amp;, const BoxSide&amp;, Color&amp;);
 824 
 825     static FragmentedFlowState computedFragmentedFlowState(const RenderObject&amp;);
 826 
 827     static bool shouldApplyCompositedContainerScrollsForRepaint();
 828 
 829     static VisibleRectContext visibleRectContextForRepaint();
 830 
 831 private:
 832 #ifndef NDEBUG
 833     bool isSetNeedsLayoutForbidden() const { return m_setNeedsLayoutForbidden; }
 834     void setNeedsLayoutIsForbidden(bool flag) { m_setNeedsLayoutForbidden = flag; }
 835 #endif
 836 
 837     void addAbsoluteRectForLayer(LayoutRect&amp; result);
 838     void setLayerNeedsFullRepaint();
 839     void setLayerNeedsFullRepaintForPositionedMovementLayout();
 840 
 841     Node* generatingPseudoHostElement() const;
 842 
 843     void propagateRepaintToParentWithOutlineAutoIfNeeded(const RenderLayerModelObject&amp; repaintContainer, const LayoutRect&amp; repaintRect) const;
 844 
 845     virtual bool isWBR() const { ASSERT_NOT_REACHED(); return false; }
 846 
 847     void setEverHadLayout(bool b) { m_bitfields.setEverHadLayout(b); }
 848 
 849     bool hasRareData() const { return m_bitfields.hasRareData(); }
 850     void setHasRareData(bool b) { m_bitfields.setHasRareData(b); }
 851 
 852 #ifndef NDEBUG
 853     void checkBlockPositionedObjectsNeedLayout();
 854 #endif
 855 
 856     Node&amp; m_node;
 857 
 858     RenderElement* m_parent;
 859     RenderObject* m_previous;
 860     RenderObject* m_next;
 861 
 862 #ifndef NDEBUG
 863     bool m_hasAXObject             : 1;
 864     bool m_setNeedsLayoutForbidden : 1;
 865 #endif
 866 
 867 #define ADD_BOOLEAN_BITFIELD(name, Name) \
 868     private:\
 869         unsigned m_##name : 1;\
 870     public:\
 871         bool name() const { return m_##name; }\
 872         void set##Name(bool name) { m_##name = name; }\
 873 
 874 #define ADD_ENUM_BITFIELD(name, Name, Type, width) \
 875     private:\
 876         unsigned m_##name : width;\
 877     public:\
 878         Type name() const { return static_cast&lt;Type&gt;(m_##name); }\
 879         void set##Name(Type name) { m_##name = static_cast&lt;unsigned&gt;(name); }\
 880 
 881     class RenderObjectBitfields {
 882         enum PositionedState {
 883             IsStaticallyPositioned = 0,
 884             IsRelativelyPositioned = 1,
 885             IsOutOfFlowPositioned = 2,
 886             IsStickilyPositioned = 3
 887         };
 888 
 889     public:
 890         RenderObjectBitfields(const Node&amp; node)
 891             : m_hasRareData(false)
 892             , m_beingDestroyed(false)
 893             , m_needsLayout(false)
 894             , m_needsPositionedMovementLayout(false)
 895             , m_normalChildNeedsLayout(false)
 896             , m_posChildNeedsLayout(false)
 897             , m_needsSimplifiedNormalFlowLayout(false)
 898             , m_preferredLogicalWidthsDirty(false)
 899             , m_floating(false)
 900             , m_isAnonymous(node.isDocumentNode())
 901             , m_isTextOrRenderView(false)
 902             , m_isBox(false)
 903             , m_isInline(true)
 904             , m_isReplaced(false)
 905             , m_isLineBreak(false)
 906             , m_horizontalWritingMode(true)
 907             , m_hasLayer(false)
 908             , m_hasOverflowClip(false)
 909             , m_hasTransformRelatedProperty(false)
 910             , m_everHadLayout(false)
 911             , m_childrenInline(false)
 912             , m_isExcludedFromNormalLayout(false)
 913             , m_positionedState(IsStaticallyPositioned)
 914             , m_selectionState(SelectionNone)
 915             , m_fragmentedFlowState(NotInsideFragmentedFlow)
 916             , m_boxDecorationState(NoBoxDecorations)
 917         {
 918         }
 919 
 920         ADD_BOOLEAN_BITFIELD(hasRareData, HasRareData);
 921 
 922         ADD_BOOLEAN_BITFIELD(beingDestroyed, BeingDestroyed);
 923         ADD_BOOLEAN_BITFIELD(needsLayout, NeedsLayout);
 924         ADD_BOOLEAN_BITFIELD(needsPositionedMovementLayout, NeedsPositionedMovementLayout);
 925         ADD_BOOLEAN_BITFIELD(normalChildNeedsLayout, NormalChildNeedsLayout);
 926         ADD_BOOLEAN_BITFIELD(posChildNeedsLayout, PosChildNeedsLayout);
 927         ADD_BOOLEAN_BITFIELD(needsSimplifiedNormalFlowLayout, NeedsSimplifiedNormalFlowLayout);
 928         ADD_BOOLEAN_BITFIELD(preferredLogicalWidthsDirty, PreferredLogicalWidthsDirty);
 929         ADD_BOOLEAN_BITFIELD(floating, Floating);
 930 
 931         ADD_BOOLEAN_BITFIELD(isAnonymous, IsAnonymous);
 932         ADD_BOOLEAN_BITFIELD(isTextOrRenderView, IsTextOrRenderView);
 933         ADD_BOOLEAN_BITFIELD(isBox, IsBox);
 934         ADD_BOOLEAN_BITFIELD(isInline, IsInline);
 935         ADD_BOOLEAN_BITFIELD(isReplaced, IsReplaced);
 936         ADD_BOOLEAN_BITFIELD(isLineBreak, IsLineBreak);
 937         ADD_BOOLEAN_BITFIELD(horizontalWritingMode, HorizontalWritingMode);
 938 
 939         ADD_BOOLEAN_BITFIELD(hasLayer, HasLayer);
 940         ADD_BOOLEAN_BITFIELD(hasOverflowClip, HasOverflowClip); // Set in the case of overflow:auto/scroll/hidden
 941         ADD_BOOLEAN_BITFIELD(hasTransformRelatedProperty, HasTransformRelatedProperty);
 942         ADD_BOOLEAN_BITFIELD(unused, Unused);
 943 
 944         ADD_BOOLEAN_BITFIELD(everHadLayout, EverHadLayout);
 945 
 946         // from RenderBlock
 947         ADD_BOOLEAN_BITFIELD(childrenInline, ChildrenInline);
 948 
 949         ADD_BOOLEAN_BITFIELD(isExcludedFromNormalLayout, IsExcludedFromNormalLayout);
 950 
 951     private:
 952         unsigned m_positionedState : 2; // PositionedState
 953         unsigned m_selectionState : 3; // SelectionState
 954         unsigned m_fragmentedFlowState : 2; // FragmentedFlowState
 955         unsigned m_boxDecorationState : 2; // BoxDecorationState
 956 
 957     public:
 958         bool isOutOfFlowPositioned() const { return m_positionedState == IsOutOfFlowPositioned; }
 959         bool isRelativelyPositioned() const { return m_positionedState == IsRelativelyPositioned; }
 960         bool isStickilyPositioned() const { return m_positionedState == IsStickilyPositioned; }
 961         bool isPositioned() const { return m_positionedState != IsStaticallyPositioned; }
 962 
 963         void setPositionedState(int positionState)
 964         {
 965             // This mask maps PositionType::Fixed and PositionType::Absolute to IsOutOfFlowPositioned, saving one bit.
 966             m_positionedState = static_cast&lt;PositionedState&gt;(positionState &amp; 0x3);
 967         }
 968         void clearPositionedState() { m_positionedState = static_cast&lt;unsigned&gt;(PositionType::Static); }
 969 
 970         ALWAYS_INLINE SelectionState selectionState() const { return static_cast&lt;SelectionState&gt;(m_selectionState); }
 971         ALWAYS_INLINE void setSelectionState(SelectionState selectionState) { m_selectionState = selectionState; }
 972 
 973         ALWAYS_INLINE FragmentedFlowState fragmentedFlowState() const { return static_cast&lt;FragmentedFlowState&gt;(m_fragmentedFlowState); }
 974         ALWAYS_INLINE void setFragmentedFlowState(FragmentedFlowState fragmentedFlowState) { m_fragmentedFlowState = fragmentedFlowState; }
 975 
 976         ALWAYS_INLINE BoxDecorationState boxDecorationState() const { return static_cast&lt;BoxDecorationState&gt;(m_boxDecorationState); }
 977         ALWAYS_INLINE void setBoxDecorationState(BoxDecorationState boxDecorationState) { m_boxDecorationState = boxDecorationState; }
 978     };
 979 
 980     RenderObjectBitfields m_bitfields;
 981 
 982     // FIXME: This should be RenderElementRareData.
 983     class RenderObjectRareData {
 984         WTF_MAKE_FAST_ALLOCATED;
 985     public:
 986         RenderObjectRareData()
 987             : m_isDragging(false)
 988             , m_hasReflection(false)
 989             , m_isRenderFragmentedFlow(false)
 990             , m_hasOutlineAutoAncestor(false)
 991         {
 992         }
 993         ADD_BOOLEAN_BITFIELD(isDragging, IsDragging);
 994         ADD_BOOLEAN_BITFIELD(hasReflection, HasReflection);
 995         ADD_BOOLEAN_BITFIELD(isRenderFragmentedFlow, IsRenderFragmentedFlow);
 996         ADD_BOOLEAN_BITFIELD(hasOutlineAutoAncestor, HasOutlineAutoAncestor);
 997 
 998         // From RenderElement
 999         std::unique_ptr&lt;RenderStyle&gt; cachedFirstLineStyle;
1000     };
1001 
1002     const RenderObject::RenderObjectRareData&amp; rareData() const;
1003     RenderObjectRareData&amp; ensureRareData();
1004     void removeRareData();
1005 
1006     typedef HashMap&lt;const RenderObject*, std::unique_ptr&lt;RenderObjectRareData&gt;&gt; RareDataMap;
1007 
1008     static RareDataMap&amp; rareDataMap();
1009 
1010 #undef ADD_BOOLEAN_BITFIELD
1011 };
1012 
1013 inline Frame&amp; RenderObject::frame() const
1014 {
1015     return *document().frame();
1016 }
1017 
1018 inline Page&amp; RenderObject::page() const
1019 {
1020     // The render tree will always be torn down before Frame is disconnected from Page,
1021     // so it&#39;s safe to assume Frame::page() is non-null as long as there are live RenderObjects.
1022     ASSERT(frame().page());
1023     return *frame().page();
1024 }
1025 
1026 inline CSSAnimationController&amp; RenderObject::animation() const
1027 {
1028     return frame().animation();
1029 }
1030 
1031 inline DocumentTimeline* RenderObject::documentTimeline() const
1032 {
1033     return document().existingTimeline();
1034 }
1035 
1036 inline bool RenderObject::renderTreeBeingDestroyed() const
1037 {
1038     return document().renderTreeBeingDestroyed();
1039 }
1040 
1041 inline bool RenderObject::isBeforeContent() const
1042 {
1043     // Text nodes don&#39;t have their own styles, so ignore the style on a text node.
1044     if (isText())
1045         return false;
1046     if (style().styleType() != PseudoId::Before)
1047         return false;
1048     return true;
1049 }
1050 
1051 inline bool RenderObject::isAfterContent() const
1052 {
1053     // Text nodes don&#39;t have their own styles, so ignore the style on a text node.
1054     if (isText())
1055         return false;
1056     if (style().styleType() != PseudoId::After)
1057         return false;
1058     return true;
1059 }
1060 
1061 inline bool RenderObject::isBeforeOrAfterContent() const
1062 {
1063     return isBeforeContent() || isAfterContent();
1064 }
1065 
1066 inline void RenderObject::setNeedsLayout(MarkingBehavior markParents)
1067 {
1068     ASSERT(!isSetNeedsLayoutForbidden());
1069     if (m_bitfields.needsLayout())
1070         return;
1071     m_bitfields.setNeedsLayout(true);
1072     if (markParents == MarkContainingBlockChain)
1073         markContainingBlocksForLayout();
1074     if (hasLayer())
1075         setLayerNeedsFullRepaint();
1076 }
1077 
1078 inline bool RenderObject::preservesNewline() const
1079 {
1080     if (isSVGInlineText())
1081         return false;
1082 
1083     return style().preserveNewline();
1084 }
1085 
1086 inline void RenderObject::setSelectionStateIfNeeded(SelectionState state)
1087 {
1088     if (selectionState() == state)
1089         return;
1090 
1091     setSelectionState(state);
1092 }
1093 
1094 inline void RenderObject::setHasVisibleBoxDecorations(bool b)
1095 {
1096     if (!b) {
1097         m_bitfields.setBoxDecorationState(NoBoxDecorations);
1098         return;
1099     }
1100     if (hasVisibleBoxDecorations())
1101         return;
1102     m_bitfields.setBoxDecorationState(HasBoxDecorationsAndBackgroundObscurationStatusInvalid);
1103 }
1104 
1105 inline void RenderObject::invalidateBackgroundObscurationStatus()
1106 {
1107     if (!hasVisibleBoxDecorations())
1108         return;
1109     m_bitfields.setBoxDecorationState(HasBoxDecorationsAndBackgroundObscurationStatusInvalid);
1110 }
1111 
1112 inline bool RenderObject::backgroundIsKnownToBeObscured(const LayoutPoint&amp; paintOffset)
1113 {
1114     if (m_bitfields.boxDecorationState() == HasBoxDecorationsAndBackgroundObscurationStatusInvalid) {
1115         BoxDecorationState boxDecorationState = computeBackgroundIsKnownToBeObscured(paintOffset) ? HasBoxDecorationsAndBackgroundIsKnownToBeObscured : HasBoxDecorationsAndBackgroundMayBeVisible;
1116         m_bitfields.setBoxDecorationState(boxDecorationState);
1117     }
1118     return m_bitfields.boxDecorationState() == HasBoxDecorationsAndBackgroundIsKnownToBeObscured;
1119 }
1120 
1121 inline bool RenderObject::needsSimplifiedNormalFlowLayoutOnly() const
1122 {
1123     return m_bitfields.needsSimplifiedNormalFlowLayout() &amp;&amp; !m_bitfields.needsLayout() &amp;&amp; !m_bitfields.normalChildNeedsLayout()
1124         &amp;&amp; !m_bitfields.posChildNeedsLayout() &amp;&amp; !m_bitfields.needsPositionedMovementLayout();
1125 }
1126 
1127 #if ENABLE(TREE_DEBUGGING)
1128 void printRenderTreeForLiveDocuments();
1129 void printLayerTreeForLiveDocuments();
1130 void printGraphicsLayerTreeForLiveDocuments();
1131 #endif
1132 
1133 } // namespace WebCore
1134 
1135 #define SPECIALIZE_TYPE_TRAITS_RENDER_OBJECT(ToValueTypeName, predicate) \
1136 SPECIALIZE_TYPE_TRAITS_BEGIN(WebCore::ToValueTypeName) \
1137     static bool isType(const WebCore::RenderObject&amp; renderer) { return renderer.predicate; } \
1138 SPECIALIZE_TYPE_TRAITS_END()
1139 
1140 #if ENABLE(TREE_DEBUGGING)
1141 // Outside the WebCore namespace for ease of invocation from the debugger.
1142 void showNodeTree(const WebCore::RenderObject*);
1143 void showLineTree(const WebCore::RenderObject*);
1144 void showRenderTree(const WebCore::RenderObject*);
1145 #endif
    </pre>
  </body>
</html>