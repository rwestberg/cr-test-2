<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/parser/Lexer.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ASTBuilder.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Lexer.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/parser/Lexer.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,8 ***</span>
  /*
   *  Copyright (C) 1999-2000 Harri Porten (porten@kde.org)
<span class="line-modified">!  *  Copyright (C) 2006-2017 Apple Inc. All Rights Reserved.</span>
   *  Copyright (C) 2007 Cameron Zwarich (cwzwarich@uwaterloo.ca)
   *  Copyright (C) 2010 Zoltan Herczeg (zherczeg@inf.u-szeged.hu)
   *  Copyright (C) 2012 Mathias Bynens (mathias@qiwi.be)
   *
   *  This library is free software; you can redistribute it and/or
<span class="line-new-header">--- 1,8 ---</span>
  /*
   *  Copyright (C) 1999-2000 Harri Porten (porten@kde.org)
<span class="line-modified">!  *  Copyright (C) 2006-2019 Apple Inc. All Rights Reserved.</span>
   *  Copyright (C) 2007 Cameron Zwarich (cwzwarich@uwaterloo.ca)
   *  Copyright (C) 2010 Zoltan Herczeg (zherczeg@inf.u-szeged.hu)
   *  Copyright (C) 2012 Mathias Bynens (mathias@qiwi.be)
   *
   *  This library is free software; you can redistribute it and/or
</pre>
<hr />
<pre>
<span class="line-old-header">*** 93,10 ***</span>
<span class="line-new-header">--- 93,11 ---</span>
      CharacterGreater,
      CharacterEqual,
  
      // Other types (only one so far)
      CharacterWhiteSpace,
<span class="line-added">+     CharacterHash,</span>
      CharacterPrivateIdentifierStart
  };
  
  // 256 Latin-1 codes
  static constexpr const unsigned short typesOfLatin1Characters[256] = {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 133,11 ***</span>
  /*  30 - Record Separator   */ CharacterInvalid,
  /*  31 - Unit Separator     */ CharacterInvalid,
  /*  32 - Space              */ CharacterWhiteSpace,
  /*  33 - !                  */ CharacterExclamationMark,
  /*  34 - &quot;                  */ CharacterQuote,
<span class="line-modified">! /*  35 - #                  */ CharacterInvalid,</span>
  /*  36 - $                  */ CharacterIdentifierStart,
  /*  37 - %                  */ CharacterModulo,
  /*  38 - &amp;                  */ CharacterAnd,
  /*  39 - &#39;                  */ CharacterQuote,
  /*  40 - (                  */ CharacterOpenParen,
<span class="line-new-header">--- 134,11 ---</span>
  /*  30 - Record Separator   */ CharacterInvalid,
  /*  31 - Unit Separator     */ CharacterInvalid,
  /*  32 - Space              */ CharacterWhiteSpace,
  /*  33 - !                  */ CharacterExclamationMark,
  /*  34 - &quot;                  */ CharacterQuote,
<span class="line-modified">! /*  35 - #                  */ CharacterHash,</span>
  /*  36 - $                  */ CharacterIdentifierStart,
  /*  37 - %                  */ CharacterModulo,
  /*  38 - &amp;                  */ CharacterAnd,
  /*  39 - &#39;                  */ CharacterQuote,
  /*  40 - (                  */ CharacterOpenParen,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 490,11 ***</span>
  /* 126 - ~                  */ &#39;~&#39;,
  /* 127 - Delete             */ 0
  };
  
  template &lt;typename T&gt;
<span class="line-modified">! Lexer&lt;T&gt;::Lexer(VM* vm, JSParserBuiltinMode builtinMode, JSParserScriptMode scriptMode)</span>
      : m_isReparsingFunction(false)
      , m_vm(vm)
      , m_parsingBuiltinFunction(builtinMode == JSParserBuiltinMode::Builtin)
      , m_scriptMode(scriptMode)
  {
<span class="line-new-header">--- 491,11 ---</span>
  /* 126 - ~                  */ &#39;~&#39;,
  /* 127 - Delete             */ 0
  };
  
  template &lt;typename T&gt;
<span class="line-modified">! Lexer&lt;T&gt;::Lexer(VM&amp; vm, JSParserBuiltinMode builtinMode, JSParserScriptMode scriptMode)</span>
      : m_isReparsingFunction(false)
      , m_vm(vm)
      , m_parsingBuiltinFunction(builtinMode == JSParserBuiltinMode::Builtin)
      , m_scriptMode(scriptMode)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 811,45 ***</span>
  static ALWAYS_INLINE bool isIdentPartIncludingEscape(const UChar* code, const UChar* codeEnd)
  {
      return isIdentPartIncludingEscapeTemplate(code, codeEnd);
  }
  
<span class="line-modified">! static inline LChar singleEscape(int c)</span>
  {
<span class="line-modified">!     if (c &lt; 128) {</span>
<span class="line-removed">-         ASSERT(static_cast&lt;size_t&gt;(c) &lt; WTF_ARRAY_LENGTH(singleCharacterEscapeValuesForASCII));</span>
<span class="line-removed">-         return singleCharacterEscapeValuesForASCII[c];</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     return 0;</span>
  }
  
<span class="line-modified">! template &lt;typename T&gt;</span>
<span class="line-modified">! inline void Lexer&lt;T&gt;::record8(int c)</span>
  {
<span class="line-modified">!     ASSERT(c &gt;= 0);</span>
<span class="line-removed">-     ASSERT(c &lt;= 0xFF);</span>
<span class="line-removed">-     m_buffer8.append(static_cast&lt;LChar&gt;(c));</span>
  }
  
<span class="line-modified">! template &lt;typename T&gt;</span>
<span class="line-modified">! inline void assertCharIsIn8BitRange(T c)</span>
  {
<span class="line-modified">!     UNUSED_PARAM(c);</span>
<span class="line-removed">-     ASSERT(c &gt;= 0);</span>
<span class="line-removed">-     ASSERT(c &lt;= 0xFF);</span>
  }
  
<span class="line-modified">! template &lt;&gt;</span>
<span class="line-modified">! inline void assertCharIsIn8BitRange(UChar c)</span>
  {
<span class="line-modified">!     UNUSED_PARAM(c);</span>
<span class="line-removed">-     ASSERT(c &lt;= 0xFF);</span>
  }
  
<span class="line-modified">! template &lt;&gt;</span>
<span class="line-modified">! inline void assertCharIsIn8BitRange(LChar)</span>
  {
  }
  
  template &lt;typename T&gt;
  inline void Lexer&lt;T&gt;::append8(const T* p, size_t length)
  {
<span class="line-new-header">--- 812,48 ---</span>
  static ALWAYS_INLINE bool isIdentPartIncludingEscape(const UChar* code, const UChar* codeEnd)
  {
      return isIdentPartIncludingEscapeTemplate(code, codeEnd);
  }
  
<span class="line-modified">! template&lt;typename CharacterType&gt;</span>
<span class="line-added">+ static inline bool isASCIIDigitOrSeparator(CharacterType character)</span>
  {
<span class="line-modified">!     return isASCIIDigit(character) || character == &#39;_&#39;;</span>
  }
  
<span class="line-modified">! template&lt;typename CharacterType&gt;</span>
<span class="line-modified">! static inline bool isASCIIHexDigitOrSeparator(CharacterType character)</span>
  {
<span class="line-modified">!     return isASCIIHexDigit(character) || character == &#39;_&#39;;</span>
  }
  
<span class="line-modified">! template&lt;typename CharacterType&gt;</span>
<span class="line-modified">! static inline bool isASCIIBinaryDigitOrSeparator(CharacterType character)</span>
  {
<span class="line-modified">!     return isASCIIBinaryDigit(character) || character == &#39;_&#39;;</span>
  }
  
<span class="line-modified">! template&lt;typename CharacterType&gt;</span>
<span class="line-modified">! static inline bool isASCIIOctalDigitOrSeparator(CharacterType character)</span>
  {
<span class="line-modified">!     return isASCIIOctalDigit(character) || character == &#39;_&#39;;</span>
  }
  
<span class="line-modified">! static inline LChar singleEscape(int c)</span>
<span class="line-modified">! {</span>
<span class="line-added">+     if (c &lt; 128) {</span>
<span class="line-added">+         ASSERT(static_cast&lt;size_t&gt;(c) &lt; WTF_ARRAY_LENGTH(singleCharacterEscapeValuesForASCII));</span>
<span class="line-added">+         return singleCharacterEscapeValuesForASCII[c];</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return 0;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template &lt;typename T&gt;</span>
<span class="line-added">+ inline void Lexer&lt;T&gt;::record8(int c)</span>
  {
<span class="line-added">+     ASSERT(isLatin1(c));</span>
<span class="line-added">+     m_buffer8.append(static_cast&lt;LChar&gt;(c));</span>
  }
  
  template &lt;typename T&gt;
  inline void Lexer&lt;T&gt;::append8(const T* p, size_t length)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 857,11 ***</span>
      m_buffer8.grow(currentSize + length);
      LChar* rawBuffer = m_buffer8.data() + currentSize;
  
      for (size_t i = 0; i &lt; length; i++) {
          T c = p[i];
<span class="line-modified">!         assertCharIsIn8BitRange(c);</span>
          rawBuffer[i] = c;
      }
  }
  
  template &lt;typename T&gt;
<span class="line-new-header">--- 861,11 ---</span>
      m_buffer8.grow(currentSize + length);
      LChar* rawBuffer = m_buffer8.data() + currentSize;
  
      for (size_t i = 0; i &lt; length; i++) {
          T c = p[i];
<span class="line-modified">!         ASSERT(isLatin1(c));</span>
          rawBuffer[i] = c;
      }
  }
  
  template &lt;typename T&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 954,18 ***</span>
  
      if (shouldCreateIdentifier || m_parsingBuiltinFunction) {
          int identifierLength = currentSourcePtr() - identifierStart;
          ident = makeIdentifier(identifierStart, identifierLength);
          if (m_parsingBuiltinFunction) {
<span class="line-modified">!             if (!isSafeBuiltinIdentifier(*m_vm, ident) &amp;&amp; !isPrivateName) {</span>
                  m_lexErrorMessage = makeString(&quot;The use of &#39;&quot;, ident-&gt;string(), &quot;&#39; is disallowed in builtin functions.&quot;);
                  return ERRORTOK;
              }
              if (isPrivateName)
<span class="line-modified">!                 ident = &amp;m_arena-&gt;makeIdentifier(m_vm, m_vm-&gt;propertyNames-&gt;lookUpPrivateName(*ident));</span>
<span class="line-modified">!             else if (*ident == m_vm-&gt;propertyNames-&gt;undefinedKeyword)</span>
<span class="line-modified">!                 tokenData-&gt;ident = &amp;m_vm-&gt;propertyNames-&gt;undefinedPrivateName;</span>
              if (!ident)
                  return INVALID_PRIVATE_NAME_ERRORTOK;
          }
          tokenData-&gt;ident = ident;
      } else
<span class="line-new-header">--- 958,18 ---</span>
  
      if (shouldCreateIdentifier || m_parsingBuiltinFunction) {
          int identifierLength = currentSourcePtr() - identifierStart;
          ident = makeIdentifier(identifierStart, identifierLength);
          if (m_parsingBuiltinFunction) {
<span class="line-modified">!             if (!isSafeBuiltinIdentifier(m_vm, ident) &amp;&amp; !isPrivateName) {</span>
                  m_lexErrorMessage = makeString(&quot;The use of &#39;&quot;, ident-&gt;string(), &quot;&#39; is disallowed in builtin functions.&quot;);
                  return ERRORTOK;
              }
              if (isPrivateName)
<span class="line-modified">!                 ident = &amp;m_arena-&gt;makeIdentifier(m_vm, m_vm.propertyNames-&gt;lookUpPrivateName(*ident));</span>
<span class="line-modified">!             else if (*ident == m_vm.propertyNames-&gt;undefinedKeyword)</span>
<span class="line-modified">!                 tokenData-&gt;ident = &amp;m_vm.propertyNames-&gt;undefinedPrivateName;</span>
              if (!ident)
                  return INVALID_PRIVATE_NAME_ERRORTOK;
          }
          tokenData-&gt;ident = ident;
      } else
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1032,18 ***</span>
          if (isAll8Bit)
              ident = makeIdentifierLCharFromUChar(identifierStart, identifierLength);
          else
              ident = makeIdentifier(identifierStart, identifierLength);
          if (m_parsingBuiltinFunction) {
<span class="line-modified">!             if (!isSafeBuiltinIdentifier(*m_vm, ident) &amp;&amp; !isPrivateName) {</span>
                  m_lexErrorMessage = makeString(&quot;The use of &#39;&quot;, ident-&gt;string(), &quot;&#39; is disallowed in builtin functions.&quot;);
                  return ERRORTOK;
              }
              if (isPrivateName)
<span class="line-modified">!                 ident = &amp;m_arena-&gt;makeIdentifier(m_vm, m_vm-&gt;propertyNames-&gt;lookUpPrivateName(*ident));</span>
<span class="line-modified">!             else if (*ident == m_vm-&gt;propertyNames-&gt;undefinedKeyword)</span>
<span class="line-modified">!                 tokenData-&gt;ident = &amp;m_vm-&gt;propertyNames-&gt;undefinedPrivateName;</span>
              if (!ident)
                  return INVALID_PRIVATE_NAME_ERRORTOK;
          }
          tokenData-&gt;ident = ident;
      } else
<span class="line-new-header">--- 1036,18 ---</span>
          if (isAll8Bit)
              ident = makeIdentifierLCharFromUChar(identifierStart, identifierLength);
          else
              ident = makeIdentifier(identifierStart, identifierLength);
          if (m_parsingBuiltinFunction) {
<span class="line-modified">!             if (!isSafeBuiltinIdentifier(m_vm, ident) &amp;&amp; !isPrivateName) {</span>
                  m_lexErrorMessage = makeString(&quot;The use of &#39;&quot;, ident-&gt;string(), &quot;&#39; is disallowed in builtin functions.&quot;);
                  return ERRORTOK;
              }
              if (isPrivateName)
<span class="line-modified">!                 ident = &amp;m_arena-&gt;makeIdentifier(m_vm, m_vm.propertyNames-&gt;lookUpPrivateName(*ident));</span>
<span class="line-modified">!             else if (*ident == m_vm.propertyNames-&gt;undefinedKeyword)</span>
<span class="line-modified">!                 tokenData-&gt;ident = &amp;m_vm.propertyNames-&gt;undefinedPrivateName;</span>
              if (!ident)
                  return INVALID_PRIVATE_NAME_ERRORTOK;
          }
          tokenData-&gt;ident = ident;
      } else
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1133,11 ***</span>
      return character &lt; 0xE;
  }
  
  static ALWAYS_INLINE bool characterRequiresParseStringSlowCase(UChar character)
  {
<span class="line-modified">!     return character &lt; 0xE || character &gt; 0xFF;</span>
  }
  
  template &lt;typename T&gt;
  template &lt;bool shouldBuildStrings&gt; ALWAYS_INLINE typename Lexer&lt;T&gt;::StringParseResult Lexer&lt;T&gt;::parseString(JSTokenData* tokenData, bool strictMode)
  {
<span class="line-new-header">--- 1137,11 ---</span>
      return character &lt; 0xE;
  }
  
  static ALWAYS_INLINE bool characterRequiresParseStringSlowCase(UChar character)
  {
<span class="line-modified">!     return character &lt; 0xE || !isLatin1(character);</span>
  }
  
  template &lt;typename T&gt;
  template &lt;bool shouldBuildStrings&gt; ALWAYS_INLINE typename Lexer&lt;T&gt;::StringParseResult Lexer&lt;T&gt;::parseString(JSTokenData* tokenData, bool strictMode)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1488,24 ***</span>
  
      return StringParsedSuccessfully;
  }
  
  template &lt;typename T&gt;
<span class="line-modified">! ALWAYS_INLINE auto Lexer&lt;T&gt;::parseHex() -&gt; NumberParseResult</span>
  {
      // Optimization: most hexadecimal values fit into 4 bytes.
      uint32_t hexValue = 0;
      int maximumDigits = 7;
  
      do {
          hexValue = (hexValue &lt;&lt; 4) + toASCIIHexValue(m_current);
          shift();
          --maximumDigits;
<span class="line-modified">!     } while (isASCIIHexDigit(m_current) &amp;&amp; maximumDigits &gt;= 0);</span>
  
      if (LIKELY(maximumDigits &gt;= 0 &amp;&amp; m_current != &#39;n&#39;))
<span class="line-modified">!         return hexValue;</span>
  
      // No more place in the hexValue buffer.
      // The values are shifted out and placed into the m_buffer8 vector.
      for (int i = 0; i &lt; 8; ++i) {
           int digit = hexValue &gt;&gt; 28;
<span class="line-new-header">--- 1492,33 ---</span>
  
      return StringParsedSuccessfully;
  }
  
  template &lt;typename T&gt;
<span class="line-modified">! ALWAYS_INLINE auto Lexer&lt;T&gt;::parseHex() -&gt; Optional&lt;NumberParseResult&gt;</span>
  {
<span class="line-added">+     ASSERT(isASCIIHexDigit(m_current));</span>
<span class="line-added">+ </span>
      // Optimization: most hexadecimal values fit into 4 bytes.
      uint32_t hexValue = 0;
      int maximumDigits = 7;
  
      do {
<span class="line-added">+         if (m_current == &#39;_&#39;) {</span>
<span class="line-added">+             if (UNLIKELY(!isASCIIHexDigit(peek(1))))</span>
<span class="line-added">+                 return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+             shift();</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          hexValue = (hexValue &lt;&lt; 4) + toASCIIHexValue(m_current);
          shift();
          --maximumDigits;
<span class="line-modified">!     } while (isASCIIHexDigitOrSeparator(m_current) &amp;&amp; maximumDigits &gt;= 0);</span>
  
      if (LIKELY(maximumDigits &gt;= 0 &amp;&amp; m_current != &#39;n&#39;))
<span class="line-modified">!         return NumberParseResult { hexValue };</span>
  
      // No more place in the hexValue buffer.
      // The values are shifted out and placed into the m_buffer8 vector.
      for (int i = 0; i &lt; 8; ++i) {
           int digit = hexValue &gt;&gt; 28;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1514,101 ***</span>
           else
               record8(digit - 10 + &#39;a&#39;);
           hexValue &lt;&lt;= 4;
      }
  
<span class="line-modified">!     while (isASCIIHexDigit(m_current)) {</span>
          record8(m_current);
          shift();
      }
  
      if (UNLIKELY(Options::useBigInt() &amp;&amp; m_current == &#39;n&#39;))
<span class="line-modified">!         return makeIdentifier(m_buffer8.data(), m_buffer8.size());</span>
  
<span class="line-modified">!     return parseIntOverflow(m_buffer8.data(), m_buffer8.size(), 16);</span>
  }
  
  template &lt;typename T&gt;
  ALWAYS_INLINE auto Lexer&lt;T&gt;::parseBinary() -&gt; Optional&lt;NumberParseResult&gt;
  {
      // Optimization: most binary values fit into 4 bytes.
      uint32_t binaryValue = 0;
      const unsigned maximumDigits = 32;
      int digit = maximumDigits - 1;
      // Temporary buffer for the digits. Makes easier
      // to reconstruct the input characters when needed.
      LChar digits[maximumDigits];
  
      do {
          binaryValue = (binaryValue &lt;&lt; 1) + (m_current - &#39;0&#39;);
          digits[digit] = m_current;
          shift();
          --digit;
<span class="line-modified">!     } while (isASCIIBinaryDigit(m_current) &amp;&amp; digit &gt;= 0);</span>
  
<span class="line-modified">!     if (LIKELY(!isASCIIDigit(m_current) &amp;&amp; digit &gt;= 0 &amp;&amp; m_current != &#39;n&#39;))</span>
<span class="line-modified">!         return Variant&lt;double, const Identifier*&gt; { binaryValue };</span>
  
      for (int i = maximumDigits - 1; i &gt; digit; --i)
          record8(digits[i]);
  
<span class="line-modified">!     while (isASCIIBinaryDigit(m_current)) {</span>
          record8(m_current);
          shift();
      }
  
      if (UNLIKELY(Options::useBigInt() &amp;&amp; m_current == &#39;n&#39;))
<span class="line-modified">!         return Variant&lt;double, const Identifier*&gt; { makeIdentifier(m_buffer8.data(), m_buffer8.size()) };</span>
  
      if (isASCIIDigit(m_current))
          return WTF::nullopt;
  
<span class="line-modified">!     return Variant&lt;double, const Identifier*&gt; { parseIntOverflow(m_buffer8.data(), m_buffer8.size(), 2) };</span>
  }
  
  template &lt;typename T&gt;
  ALWAYS_INLINE auto Lexer&lt;T&gt;::parseOctal() -&gt; Optional&lt;NumberParseResult&gt;
  {
      // Optimization: most octal values fit into 4 bytes.
      uint32_t octalValue = 0;
      const unsigned maximumDigits = 10;
      int digit = maximumDigits - 1;
      // Temporary buffer for the digits. Makes easier
      // to reconstruct the input characters when needed.
      LChar digits[maximumDigits];
  
      do {
          octalValue = octalValue * 8 + (m_current - &#39;0&#39;);
          digits[digit] = m_current;
          shift();
          --digit;
<span class="line-modified">!     } while (isASCIIOctalDigit(m_current) &amp;&amp; digit &gt;= 0);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (LIKELY(!isASCIIDigit(m_current) &amp;&amp; digit &gt;= 0 &amp;&amp; m_current != &#39;n&#39;))</span>
<span class="line-removed">-         return Variant&lt;double, const Identifier*&gt; { octalValue };</span>
  
  
      for (int i = maximumDigits - 1; i &gt; digit; --i)
           record8(digits[i]);
  
<span class="line-modified">!     while (isASCIIOctalDigit(m_current)) {</span>
          record8(m_current);
          shift();
      }
  
<span class="line-modified">!     if (UNLIKELY(Options::useBigInt() &amp;&amp; m_current == &#39;n&#39;))</span>
<span class="line-modified">!         return Variant&lt;double, const Identifier*&gt; { makeIdentifier(m_buffer8.data(), m_buffer8.size()) };</span>
  
      if (isASCIIDigit(m_current))
          return WTF::nullopt;
  
<span class="line-modified">!     return Variant&lt;double, const Identifier*&gt; { parseIntOverflow(m_buffer8.data(), m_buffer8.size(), 8) };</span>
  }
  
  template &lt;typename T&gt;
  ALWAYS_INLINE auto Lexer&lt;T&gt;::parseDecimal() -&gt; Optional&lt;NumberParseResult&gt;
  {
      // Optimization: most decimal values fit into 4 bytes.
      uint32_t decimalValue = 0;
  
      // Since parseOctal may be executed before parseDecimal,
      // the m_buffer8 may hold ascii digits.
<span class="line-new-header">--- 1527,144 ---</span>
           else
               record8(digit - 10 + &#39;a&#39;);
           hexValue &lt;&lt;= 4;
      }
  
<span class="line-modified">!     while (isASCIIHexDigitOrSeparator(m_current)) {</span>
<span class="line-added">+         if (m_current == &#39;_&#39;) {</span>
<span class="line-added">+             if (UNLIKELY(!isASCIIHexDigit(peek(1))))</span>
<span class="line-added">+                 return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+             shift();</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          record8(m_current);
          shift();
      }
  
      if (UNLIKELY(Options::useBigInt() &amp;&amp; m_current == &#39;n&#39;))
<span class="line-modified">!         return NumberParseResult { makeIdentifier(m_buffer8.data(), m_buffer8.size()) };</span>
  
<span class="line-modified">!     return NumberParseResult { parseIntOverflow(m_buffer8.data(), m_buffer8.size(), 16) };</span>
  }
  
  template &lt;typename T&gt;
  ALWAYS_INLINE auto Lexer&lt;T&gt;::parseBinary() -&gt; Optional&lt;NumberParseResult&gt;
  {
<span class="line-added">+     ASSERT(isASCIIBinaryDigit(m_current));</span>
<span class="line-added">+ </span>
      // Optimization: most binary values fit into 4 bytes.
      uint32_t binaryValue = 0;
      const unsigned maximumDigits = 32;
      int digit = maximumDigits - 1;
      // Temporary buffer for the digits. Makes easier
      // to reconstruct the input characters when needed.
      LChar digits[maximumDigits];
  
      do {
<span class="line-added">+         if (m_current == &#39;_&#39;) {</span>
<span class="line-added">+             if (UNLIKELY(!isASCIIBinaryDigit(peek(1))))</span>
<span class="line-added">+                 return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+             shift();</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          binaryValue = (binaryValue &lt;&lt; 1) + (m_current - &#39;0&#39;);
          digits[digit] = m_current;
          shift();
          --digit;
<span class="line-modified">!     } while (isASCIIBinaryDigitOrSeparator(m_current) &amp;&amp; digit &gt;= 0);</span>
  
<span class="line-modified">!     if (LIKELY(!isASCIIDigitOrSeparator(m_current) &amp;&amp; digit &gt;= 0 &amp;&amp; m_current != &#39;n&#39;))</span>
<span class="line-modified">!         return NumberParseResult { binaryValue };</span>
  
      for (int i = maximumDigits - 1; i &gt; digit; --i)
          record8(digits[i]);
  
<span class="line-modified">!     while (isASCIIBinaryDigitOrSeparator(m_current)) {</span>
<span class="line-added">+         if (m_current == &#39;_&#39;) {</span>
<span class="line-added">+             if (UNLIKELY(!isASCIIBinaryDigit(peek(1))))</span>
<span class="line-added">+                 return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+             shift();</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          record8(m_current);
          shift();
      }
  
      if (UNLIKELY(Options::useBigInt() &amp;&amp; m_current == &#39;n&#39;))
<span class="line-modified">!         return NumberParseResult { makeIdentifier(m_buffer8.data(), m_buffer8.size()) };</span>
  
      if (isASCIIDigit(m_current))
          return WTF::nullopt;
  
<span class="line-modified">!     return NumberParseResult { parseIntOverflow(m_buffer8.data(), m_buffer8.size(), 2) };</span>
  }
  
  template &lt;typename T&gt;
  ALWAYS_INLINE auto Lexer&lt;T&gt;::parseOctal() -&gt; Optional&lt;NumberParseResult&gt;
  {
<span class="line-added">+     ASSERT(isASCIIOctalDigit(m_current));</span>
<span class="line-added">+     ASSERT(!m_buffer8.size() || (m_buffer8.size() == 1 &amp;&amp; m_buffer8[0] == &#39;0&#39;));</span>
<span class="line-added">+     bool isLegacyLiteral = m_buffer8.size();</span>
<span class="line-added">+ </span>
      // Optimization: most octal values fit into 4 bytes.
      uint32_t octalValue = 0;
      const unsigned maximumDigits = 10;
      int digit = maximumDigits - 1;
      // Temporary buffer for the digits. Makes easier
      // to reconstruct the input characters when needed.
      LChar digits[maximumDigits];
  
      do {
<span class="line-added">+         if (m_current == &#39;_&#39;) {</span>
<span class="line-added">+             if (UNLIKELY(!isASCIIOctalDigit(peek(1)) || isLegacyLiteral))</span>
<span class="line-added">+                 return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+             shift();</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          octalValue = octalValue * 8 + (m_current - &#39;0&#39;);
          digits[digit] = m_current;
          shift();
          --digit;
<span class="line-modified">!     } while (isASCIIOctalDigitOrSeparator(m_current) &amp;&amp; digit &gt;= 0);</span>
  
<span class="line-added">+     if (LIKELY(!isASCIIDigitOrSeparator(m_current) &amp;&amp; digit &gt;= 0 &amp;&amp; m_current != &#39;n&#39;))</span>
<span class="line-added">+         return NumberParseResult { octalValue };</span>
  
      for (int i = maximumDigits - 1; i &gt; digit; --i)
           record8(digits[i]);
  
<span class="line-modified">!     while (isASCIIOctalDigitOrSeparator(m_current)) {</span>
<span class="line-added">+         if (m_current == &#39;_&#39;) {</span>
<span class="line-added">+             if (UNLIKELY(!isASCIIOctalDigit(peek(1)) || isLegacyLiteral))</span>
<span class="line-added">+                 return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+             shift();</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          record8(m_current);
          shift();
      }
  
<span class="line-modified">!     if (UNLIKELY(Options::useBigInt() &amp;&amp; m_current == &#39;n&#39;) &amp;&amp; !isLegacyLiteral)</span>
<span class="line-modified">!         return NumberParseResult { makeIdentifier(m_buffer8.data(), m_buffer8.size()) };</span>
  
      if (isASCIIDigit(m_current))
          return WTF::nullopt;
  
<span class="line-modified">!     return NumberParseResult { parseIntOverflow(m_buffer8.data(), m_buffer8.size(), 8) };</span>
  }
  
  template &lt;typename T&gt;
  ALWAYS_INLINE auto Lexer&lt;T&gt;::parseDecimal() -&gt; Optional&lt;NumberParseResult&gt;
  {
<span class="line-added">+     ASSERT(isASCIIDigit(m_current) || m_buffer8.size());</span>
<span class="line-added">+     bool isLegacyLiteral = m_buffer8.size() &amp;&amp; isASCIIDigitOrSeparator(m_current);</span>
<span class="line-added">+ </span>
      // Optimization: most decimal values fit into 4 bytes.
      uint32_t decimalValue = 0;
  
      // Since parseOctal may be executed before parseDecimal,
      // the m_buffer8 may hold ascii digits.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1618,42 ***</span>
          // Temporary buffer for the digits. Makes easier
          // to reconstruct the input characters when needed.
          LChar digits[maximumDigits];
  
          do {
              decimalValue = decimalValue * 10 + (m_current - &#39;0&#39;);
              digits[digit] = m_current;
              shift();
              --digit;
<span class="line-modified">!         } while (isASCIIDigit(m_current) &amp;&amp; digit &gt;= 0);</span>
  
          if (digit &gt;= 0 &amp;&amp; m_current != &#39;.&#39; &amp;&amp; !isASCIIAlphaCaselessEqual(m_current, &#39;e&#39;) &amp;&amp; m_current != &#39;n&#39;)
<span class="line-modified">!             return Variant&lt;double, const Identifier*&gt; { decimalValue };</span>
  
          for (int i = maximumDigits - 1; i &gt; digit; --i)
              record8(digits[i]);
      }
  
<span class="line-modified">!     while (isASCIIDigit(m_current)) {</span>
          record8(m_current);
          shift();
      }
  
<span class="line-modified">!     if (UNLIKELY(Options::useBigInt() &amp;&amp; m_current == &#39;n&#39;))</span>
<span class="line-modified">!         return Variant&lt;double, const Identifier*&gt; { makeIdentifier(m_buffer8.data(), m_buffer8.size()) };</span>
  
      return WTF::nullopt;
  }
  
  template &lt;typename T&gt;
<span class="line-modified">! ALWAYS_INLINE void Lexer&lt;T&gt;::parseNumberAfterDecimalPoint()</span>
  {
      record8(&#39;.&#39;);
<span class="line-modified">!     while (isASCIIDigit(m_current)) {</span>
          record8(m_current);
          shift();
<span class="line-modified">!     }</span>
  }
  
  template &lt;typename T&gt;
  ALWAYS_INLINE bool Lexer&lt;T&gt;::parseNumberAfterExponentIndicator()
  {
<span class="line-new-header">--- 1674,67 ---</span>
          // Temporary buffer for the digits. Makes easier
          // to reconstruct the input characters when needed.
          LChar digits[maximumDigits];
  
          do {
<span class="line-added">+             if (m_current == &#39;_&#39;) {</span>
<span class="line-added">+                 if (UNLIKELY(!isASCIIDigit(peek(1)) || isLegacyLiteral))</span>
<span class="line-added">+                     return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+                 shift();</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
              decimalValue = decimalValue * 10 + (m_current - &#39;0&#39;);
              digits[digit] = m_current;
              shift();
              --digit;
<span class="line-modified">!         } while (isASCIIDigitOrSeparator(m_current) &amp;&amp; digit &gt;= 0);</span>
  
          if (digit &gt;= 0 &amp;&amp; m_current != &#39;.&#39; &amp;&amp; !isASCIIAlphaCaselessEqual(m_current, &#39;e&#39;) &amp;&amp; m_current != &#39;n&#39;)
<span class="line-modified">!             return NumberParseResult { decimalValue };</span>
  
          for (int i = maximumDigits - 1; i &gt; digit; --i)
              record8(digits[i]);
      }
  
<span class="line-modified">!     while (isASCIIDigitOrSeparator(m_current)) {</span>
<span class="line-added">+         if (m_current == &#39;_&#39;) {</span>
<span class="line-added">+             if (UNLIKELY(!isASCIIDigit(peek(1)) || isLegacyLiteral))</span>
<span class="line-added">+                 return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+             shift();</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          record8(m_current);
          shift();
      }
  
<span class="line-modified">!     if (UNLIKELY(Options::useBigInt() &amp;&amp; m_current == &#39;n&#39; &amp;&amp; !isLegacyLiteral))</span>
<span class="line-modified">!         return NumberParseResult { makeIdentifier(m_buffer8.data(), m_buffer8.size()) };</span>
  
      return WTF::nullopt;
  }
  
  template &lt;typename T&gt;
<span class="line-modified">! ALWAYS_INLINE bool Lexer&lt;T&gt;::parseNumberAfterDecimalPoint()</span>
  {
<span class="line-added">+     ASSERT(isASCIIDigit(m_current));</span>
      record8(&#39;.&#39;);
<span class="line-modified">! </span>
<span class="line-added">+     do {</span>
<span class="line-added">+         if (m_current == &#39;_&#39;) {</span>
<span class="line-added">+             if (UNLIKELY(!isASCIIDigit(peek(1))))</span>
<span class="line-added">+                 return false;</span>
<span class="line-added">+ </span>
<span class="line-added">+             shift();</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          record8(m_current);
          shift();
<span class="line-modified">!     } while (isASCIIDigitOrSeparator(m_current));</span>
<span class="line-added">+ </span>
<span class="line-added">+     return true;</span>
  }
  
  template &lt;typename T&gt;
  ALWAYS_INLINE bool Lexer&lt;T&gt;::parseNumberAfterExponentIndicator()
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1666,13 ***</span>
  
      if (!isASCIIDigit(m_current))
          return false;
  
      do {
          record8(m_current);
          shift();
<span class="line-modified">!     } while (isASCIIDigit(m_current));</span>
      return true;
  }
  
  template &lt;typename T&gt;
  ALWAYS_INLINE bool Lexer&lt;T&gt;::parseMultilineComment()
<span class="line-new-header">--- 1747,21 ---</span>
  
      if (!isASCIIDigit(m_current))
          return false;
  
      do {
<span class="line-added">+         if (m_current == &#39;_&#39;) {</span>
<span class="line-added">+             if (UNLIKELY(!isASCIIDigit(peek(1))))</span>
<span class="line-added">+                 return false;</span>
<span class="line-added">+ </span>
<span class="line-added">+             shift();</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          record8(m_current);
          shift();
<span class="line-modified">!     } while (isASCIIDigitOrSeparator(m_current));</span>
<span class="line-added">+ </span>
      return true;
  }
  
  template &lt;typename T&gt;
  ALWAYS_INLINE bool Lexer&lt;T&gt;::parseMultilineComment()
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2045,12 ***</span>
      case CharacterColon:
          token = COLON;
          shift();
          break;
      case CharacterQuestion:
<span class="line-removed">-         token = QUESTION;</span>
          shift();
          break;
      case CharacterTilde:
          token = TILDE;
          shift();
          break;
<span class="line-new-header">--- 2134,24 ---</span>
      case CharacterColon:
          token = COLON;
          shift();
          break;
      case CharacterQuestion:
          shift();
<span class="line-added">+         if (Options::useNullishAwareOperators()) {</span>
<span class="line-added">+             if (m_current == &#39;?&#39;) {</span>
<span class="line-added">+                 shift();</span>
<span class="line-added">+                 token = COALESCE;</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             }</span>
<span class="line-added">+             if (m_current == &#39;.&#39; &amp;&amp; !isASCIIDigit(peek(1))) {</span>
<span class="line-added">+                 shift();</span>
<span class="line-added">+                 token = QUESTIONDOT;</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+         token = QUESTION;</span>
          break;
      case CharacterTilde:
          token = TILDE;
          shift();
          break;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2088,18 ***</span>
                  break;
              }
              token = DOT;
              break;
          }
<span class="line-modified">!         parseNumberAfterDecimalPoint();</span>
          token = DOUBLE;
<span class="line-modified">!         if (isASCIIAlphaCaselessEqual(m_current, &#39;e&#39;)) {</span>
<span class="line-modified">!             if (!parseNumberAfterExponentIndicator()) {</span>
<span class="line-modified">!                 m_lexErrorMessage = &quot;Non-number found after exponent indicator&quot;_s;</span>
<span class="line-modified">!                 token = atEnd() ? UNTERMINATED_NUMERIC_LITERAL_ERRORTOK : INVALID_NUMERIC_LITERAL_ERRORTOK;</span>
<span class="line-removed">-                 goto returnError;</span>
<span class="line-removed">-             }</span>
          }
          size_t parsedLength;
          tokenData-&gt;doubleValue = parseDouble(m_buffer8.data(), m_buffer8.size(), parsedLength);
          if (token == INTEGER)
              token = tokenTypeForIntegerLikeToken(tokenData-&gt;doubleValue);
<span class="line-new-header">--- 2189,20 ---</span>
                  break;
              }
              token = DOT;
              break;
          }
<span class="line-modified">!         if (UNLIKELY(!parseNumberAfterDecimalPoint())) {</span>
<span class="line-added">+             m_lexErrorMessage = &quot;Non-number found after decimal point&quot;_s;</span>
<span class="line-added">+             token = atEnd() ? UNTERMINATED_NUMERIC_LITERAL_ERRORTOK : INVALID_NUMERIC_LITERAL_ERRORTOK;</span>
<span class="line-added">+             goto returnError;</span>
<span class="line-added">+         }</span>
          token = DOUBLE;
<span class="line-modified">!         if (UNLIKELY(isASCIIAlphaCaselessEqual(m_current, &#39;e&#39;) &amp;&amp; !parseNumberAfterExponentIndicator())) {</span>
<span class="line-modified">!             m_lexErrorMessage = &quot;Non-number found after exponent indicator&quot;_s;</span>
<span class="line-modified">!             token = atEnd() ? UNTERMINATED_NUMERIC_LITERAL_ERRORTOK : INVALID_NUMERIC_LITERAL_ERRORTOK;</span>
<span class="line-modified">!             goto returnError;</span>
          }
          size_t parsedLength;
          tokenData-&gt;doubleValue = parseDouble(m_buffer8.data(), m_buffer8.size(), parsedLength);
          if (token == INTEGER)
              token = tokenTypeForIntegerLikeToken(tokenData-&gt;doubleValue);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2112,41 ***</span>
          m_buffer8.shrink(0);
          break;
      case CharacterZero:
          shift();
          if (isASCIIAlphaCaselessEqual(m_current, &#39;x&#39;)) {
<span class="line-modified">!             if (!isASCIIHexDigit(peek(1))) {</span>
                  m_lexErrorMessage = &quot;No hexadecimal digits after &#39;0x&#39;&quot;_s;
                  token = UNTERMINATED_HEX_NUMBER_ERRORTOK;
                  goto returnError;
              }
  
              // Shift out the &#39;x&#39; prefix.
              shift();
  
              auto parseNumberResult = parseHex();
<span class="line-modified">!             if (WTF::holds_alternative&lt;double&gt;(parseNumberResult))</span>
<span class="line-modified">!                 tokenData-&gt;doubleValue = WTF::get&lt;double&gt;(parseNumberResult);</span>
              else {
                  token = BIGINT;
                  shift();
<span class="line-modified">!                 tokenData-&gt;bigIntString = WTF::get&lt;const Identifier*&gt;(parseNumberResult);</span>
                  tokenData-&gt;radix = 16;
              }
  
<span class="line-modified">!             if (isIdentStart(m_current)) {</span>
                  m_lexErrorMessage = &quot;No space between hexadecimal literal and identifier&quot;_s;
                  token = UNTERMINATED_HEX_NUMBER_ERRORTOK;
                  goto returnError;
              }
              if (LIKELY(token != BIGINT))
                  token = tokenTypeForIntegerLikeToken(tokenData-&gt;doubleValue);
              m_buffer8.shrink(0);
              break;
          }
          if (isASCIIAlphaCaselessEqual(m_current, &#39;b&#39;)) {
<span class="line-modified">!             if (!isASCIIBinaryDigit(peek(1))) {</span>
                  m_lexErrorMessage = &quot;No binary digits after &#39;0b&#39;&quot;_s;
                  token = UNTERMINATED_BINARY_NUMBER_ERRORTOK;
                  goto returnError;
              }
  
<span class="line-new-header">--- 2215,43 ---</span>
          m_buffer8.shrink(0);
          break;
      case CharacterZero:
          shift();
          if (isASCIIAlphaCaselessEqual(m_current, &#39;x&#39;)) {
<span class="line-modified">!             if (UNLIKELY(!isASCIIHexDigit(peek(1)))) {</span>
                  m_lexErrorMessage = &quot;No hexadecimal digits after &#39;0x&#39;&quot;_s;
                  token = UNTERMINATED_HEX_NUMBER_ERRORTOK;
                  goto returnError;
              }
  
              // Shift out the &#39;x&#39; prefix.
              shift();
  
              auto parseNumberResult = parseHex();
<span class="line-modified">!             if (!parseNumberResult)</span>
<span class="line-modified">!                 tokenData-&gt;doubleValue = 0;</span>
<span class="line-added">+             else if (WTF::holds_alternative&lt;double&gt;(*parseNumberResult))</span>
<span class="line-added">+                 tokenData-&gt;doubleValue = WTF::get&lt;double&gt;(*parseNumberResult);</span>
              else {
                  token = BIGINT;
                  shift();
<span class="line-modified">!                 tokenData-&gt;bigIntString = WTF::get&lt;const Identifier*&gt;(*parseNumberResult);</span>
                  tokenData-&gt;radix = 16;
              }
  
<span class="line-modified">!             if (UNLIKELY(isIdentStart(m_current))) {</span>
                  m_lexErrorMessage = &quot;No space between hexadecimal literal and identifier&quot;_s;
                  token = UNTERMINATED_HEX_NUMBER_ERRORTOK;
                  goto returnError;
              }
              if (LIKELY(token != BIGINT))
                  token = tokenTypeForIntegerLikeToken(tokenData-&gt;doubleValue);
              m_buffer8.shrink(0);
              break;
          }
          if (isASCIIAlphaCaselessEqual(m_current, &#39;b&#39;)) {
<span class="line-modified">!             if (UNLIKELY(!isASCIIBinaryDigit(peek(1)))) {</span>
                  m_lexErrorMessage = &quot;No binary digits after &#39;0b&#39;&quot;_s;
                  token = UNTERMINATED_BINARY_NUMBER_ERRORTOK;
                  goto returnError;
              }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2163,11 ***</span>
                  shift();
                  tokenData-&gt;bigIntString = WTF::get&lt;const Identifier*&gt;(*parseNumberResult);
                  tokenData-&gt;radix = 2;
              }
  
<span class="line-modified">!             if (isIdentStart(m_current)) {</span>
                  m_lexErrorMessage = &quot;No space between binary literal and identifier&quot;_s;
                  token = UNTERMINATED_BINARY_NUMBER_ERRORTOK;
                  goto returnError;
              }
              if (LIKELY(token != BIGINT))
<span class="line-new-header">--- 2268,11 ---</span>
                  shift();
                  tokenData-&gt;bigIntString = WTF::get&lt;const Identifier*&gt;(*parseNumberResult);
                  tokenData-&gt;radix = 2;
              }
  
<span class="line-modified">!             if (UNLIKELY(isIdentStart(m_current))) {</span>
                  m_lexErrorMessage = &quot;No space between binary literal and identifier&quot;_s;
                  token = UNTERMINATED_BINARY_NUMBER_ERRORTOK;
                  goto returnError;
              }
              if (LIKELY(token != BIGINT))
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2175,11 ***</span>
              m_buffer8.shrink(0);
              break;
          }
  
          if (isASCIIAlphaCaselessEqual(m_current, &#39;o&#39;)) {
<span class="line-modified">!             if (!isASCIIOctalDigit(peek(1))) {</span>
                  m_lexErrorMessage = &quot;No octal digits after &#39;0o&#39;&quot;_s;
                  token = UNTERMINATED_OCTAL_NUMBER_ERRORTOK;
                  goto returnError;
              }
  
<span class="line-new-header">--- 2280,11 ---</span>
              m_buffer8.shrink(0);
              break;
          }
  
          if (isASCIIAlphaCaselessEqual(m_current, &#39;o&#39;)) {
<span class="line-modified">!             if (UNLIKELY(!isASCIIOctalDigit(peek(1)))) {</span>
                  m_lexErrorMessage = &quot;No octal digits after &#39;0o&#39;&quot;_s;
                  token = UNTERMINATED_OCTAL_NUMBER_ERRORTOK;
                  goto returnError;
              }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2196,23 ***</span>
                  shift();
                  tokenData-&gt;bigIntString = WTF::get&lt;const Identifier*&gt;(*parseNumberResult);
                  tokenData-&gt;radix = 8;
              }
  
<span class="line-modified">!             if (isIdentStart(m_current)) {</span>
                  m_lexErrorMessage = &quot;No space between octal literal and identifier&quot;_s;
                  token = UNTERMINATED_OCTAL_NUMBER_ERRORTOK;
                  goto returnError;
              }
              if (LIKELY(token != BIGINT))
                  token = tokenTypeForIntegerLikeToken(tokenData-&gt;doubleValue);
              m_buffer8.shrink(0);
              break;
          }
  
          record8(&#39;0&#39;);
<span class="line-modified">!         if (strictMode &amp;&amp; isASCIIDigit(m_current)) {</span>
              m_lexErrorMessage = &quot;Decimal integer literals with a leading zero are forbidden in strict mode&quot;_s;
              token = UNTERMINATED_OCTAL_NUMBER_ERRORTOK;
              goto returnError;
          }
          if (isASCIIOctalDigit(m_current)) {
<span class="line-new-header">--- 2301,29 ---</span>
                  shift();
                  tokenData-&gt;bigIntString = WTF::get&lt;const Identifier*&gt;(*parseNumberResult);
                  tokenData-&gt;radix = 8;
              }
  
<span class="line-modified">!             if (UNLIKELY(isIdentStart(m_current))) {</span>
                  m_lexErrorMessage = &quot;No space between octal literal and identifier&quot;_s;
                  token = UNTERMINATED_OCTAL_NUMBER_ERRORTOK;
                  goto returnError;
              }
              if (LIKELY(token != BIGINT))
                  token = tokenTypeForIntegerLikeToken(tokenData-&gt;doubleValue);
              m_buffer8.shrink(0);
              break;
          }
  
<span class="line-added">+         if (UNLIKELY(m_current == &#39;_&#39;)) {</span>
<span class="line-added">+             m_lexErrorMessage = &quot;Numeric literals may not begin with 0_&quot;_s;</span>
<span class="line-added">+             token = UNTERMINATED_OCTAL_NUMBER_ERRORTOK;</span>
<span class="line-added">+             goto returnError;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          record8(&#39;0&#39;);
<span class="line-modified">!         if (UNLIKELY(strictMode &amp;&amp; isASCIIDigit(m_current))) {</span>
              m_lexErrorMessage = &quot;Decimal integer literals with a leading zero are forbidden in strict mode&quot;_s;
              token = UNTERMINATED_OCTAL_NUMBER_ERRORTOK;
              goto returnError;
          }
          if (isASCIIOctalDigit(m_current)) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2224,39 ***</span>
          }
          FALLTHROUGH;
      case CharacterNumber:
          if (LIKELY(token != INTEGER &amp;&amp; token != DOUBLE)) {
              auto parseNumberResult = parseDecimal();
<span class="line-modified">!             if (parseNumberResult &amp;&amp; WTF::holds_alternative&lt;double&gt;(*parseNumberResult)) {</span>
<span class="line-modified">!                 tokenData-&gt;doubleValue = WTF::get&lt;double&gt;(*parseNumberResult);</span>
<span class="line-modified">!                 token = tokenTypeForIntegerLikeToken(tokenData-&gt;doubleValue);</span>
<span class="line-modified">!             } else {</span>
<span class="line-modified">!                 if (parseNumberResult) {</span>
<span class="line-removed">-                     ASSERT(WTF::get&lt;const Identifier*&gt;(*parseNumberResult));</span>
                      token = BIGINT;
                      shift();
                      tokenData-&gt;bigIntString = WTF::get&lt;const Identifier*&gt;(*parseNumberResult);
                      tokenData-&gt;radix = 10;
<span class="line-modified">!                 } else {</span>
<span class="line-modified">!                     token = INTEGER;</span>
<span class="line-modified">!                     if (m_current == &#39;.&#39;) {</span>
<span class="line-modified">!                         shift();</span>
<span class="line-modified">!                         parseNumberAfterDecimalPoint();</span>
<span class="line-modified">!                         token = DOUBLE;</span>
<span class="line-modified">!                     }</span>
<span class="line-modified">!                     if (isASCIIAlphaCaselessEqual(m_current, &#39;e&#39;)) {</span>
<span class="line-modified">!                         if (!parseNumberAfterExponentIndicator()) {</span>
<span class="line-removed">-                             m_lexErrorMessage = &quot;Non-number found after exponent indicator&quot;_s;</span>
<span class="line-removed">-                             token = atEnd() ? UNTERMINATED_NUMERIC_LITERAL_ERRORTOK : INVALID_NUMERIC_LITERAL_ERRORTOK;</span>
<span class="line-removed">-                             goto returnError;</span>
<span class="line-removed">-                         }</span>
                      }
<span class="line-modified">!                     size_t parsedLength;</span>
<span class="line-modified">!                     tokenData-&gt;doubleValue = parseDouble(m_buffer8.data(), m_buffer8.size(), parsedLength);</span>
<span class="line-modified">!                     if (token == INTEGER)</span>
<span class="line-modified">!                         token = tokenTypeForIntegerLikeToken(tokenData-&gt;doubleValue);</span>
                  }
              }
          }
  
          if (UNLIKELY(isIdentStart(m_current))) {
              m_lexErrorMessage = &quot;No identifiers allowed directly after numeric literal&quot;_s;
<span class="line-new-header">--- 2335,40 ---</span>
          }
          FALLTHROUGH;
      case CharacterNumber:
          if (LIKELY(token != INTEGER &amp;&amp; token != DOUBLE)) {
              auto parseNumberResult = parseDecimal();
<span class="line-modified">!             if (parseNumberResult) {</span>
<span class="line-modified">!                 if (WTF::holds_alternative&lt;double&gt;(*parseNumberResult)) {</span>
<span class="line-modified">!                     tokenData-&gt;doubleValue = WTF::get&lt;double&gt;(*parseNumberResult);</span>
<span class="line-modified">!                     token = tokenTypeForIntegerLikeToken(tokenData-&gt;doubleValue);</span>
<span class="line-modified">!                 } else {</span>
                      token = BIGINT;
                      shift();
                      tokenData-&gt;bigIntString = WTF::get&lt;const Identifier*&gt;(*parseNumberResult);
                      tokenData-&gt;radix = 10;
<span class="line-modified">!                 }</span>
<span class="line-modified">!             } else {</span>
<span class="line-modified">!                 token = INTEGER;</span>
<span class="line-modified">!                 if (m_current == &#39;.&#39;) {</span>
<span class="line-modified">!                     shift();</span>
<span class="line-modified">!                     if (UNLIKELY(isASCIIDigit(m_current) &amp;&amp; !parseNumberAfterDecimalPoint())) {</span>
<span class="line-modified">!                         m_lexErrorMessage = &quot;Non-number found after decimal point&quot;_s;</span>
<span class="line-modified">!                         token = atEnd() ? UNTERMINATED_NUMERIC_LITERAL_ERRORTOK : INVALID_NUMERIC_LITERAL_ERRORTOK;</span>
<span class="line-modified">!                         goto returnError;</span>
                      }
<span class="line-modified">!                     token = DOUBLE;</span>
<span class="line-modified">!                 }</span>
<span class="line-modified">!                 if (UNLIKELY(isASCIIAlphaCaselessEqual(m_current, &#39;e&#39;) &amp;&amp; !parseNumberAfterExponentIndicator())) {</span>
<span class="line-modified">!                     m_lexErrorMessage = &quot;Non-number found after exponent indicator&quot;_s;</span>
<span class="line-added">+                     token = atEnd() ? UNTERMINATED_NUMERIC_LITERAL_ERRORTOK : INVALID_NUMERIC_LITERAL_ERRORTOK;</span>
<span class="line-added">+                     goto returnError;</span>
                  }
<span class="line-added">+                 size_t parsedLength;</span>
<span class="line-added">+                 tokenData-&gt;doubleValue = parseDouble(m_buffer8.data(), m_buffer8.size(), parsedLength);</span>
<span class="line-added">+                 if (token == INTEGER)</span>
<span class="line-added">+                     token = tokenTypeForIntegerLikeToken(tokenData-&gt;doubleValue);</span>
              }
          }
  
          if (UNLIKELY(isIdentStart(m_current))) {
              m_lexErrorMessage = &quot;No identifiers allowed directly after numeric literal&quot;_s;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2295,20 ***</span>
          shiftLineTerminator();
          m_atLineStart = true;
          m_hasLineTerminatorBeforeToken = true;
          m_lineStart = m_code;
          goto start;
      case CharacterPrivateIdentifierStart:
          if (m_parsingBuiltinFunction)
              goto parseIdent;
<span class="line-modified">! </span>
<span class="line-removed">-         FALLTHROUGH;</span>
      case CharacterOtherIdentifierPart:
      case CharacterInvalid:
<span class="line-modified">!         m_lexErrorMessage = invalidCharacterMessage();</span>
<span class="line-removed">-         token = ERRORTOK;</span>
<span class="line-removed">-         goto returnError;</span>
      default:
          RELEASE_ASSERT_NOT_REACHED();
          m_lexErrorMessage = &quot;Internal Error&quot;_s;
          token = ERRORTOK;
          goto returnError;
<span class="line-new-header">--- 2407,25 ---</span>
          shiftLineTerminator();
          m_atLineStart = true;
          m_hasLineTerminatorBeforeToken = true;
          m_lineStart = m_code;
          goto start;
<span class="line-added">+     case CharacterHash:</span>
<span class="line-added">+         // Hashbang is only permitted at the start of the source text.</span>
<span class="line-added">+         if (peek(1) == &#39;!&#39; &amp;&amp; !currentOffset()) {</span>
<span class="line-added">+             shift();</span>
<span class="line-added">+             shift();</span>
<span class="line-added">+             goto inSingleLineComment;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         goto invalidCharacter;</span>
      case CharacterPrivateIdentifierStart:
          if (m_parsingBuiltinFunction)
              goto parseIdent;
<span class="line-modified">!         goto invalidCharacter;</span>
      case CharacterOtherIdentifierPart:
      case CharacterInvalid:
<span class="line-modified">!         goto invalidCharacter;</span>
      default:
          RELEASE_ASSERT_NOT_REACHED();
          m_lexErrorMessage = &quot;Internal Error&quot;_s;
          token = ERRORTOK;
          goto returnError;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2355,10 ***</span>
<span class="line-new-header">--- 2472,15 ---</span>
  
  returnToken:
      fillTokenInfo(tokenRecord, token, m_lineNumber, currentOffset(), currentLineStartOffset(), currentPosition());
      return token;
  
<span class="line-added">+ invalidCharacter:</span>
<span class="line-added">+     m_lexErrorMessage = invalidCharacterMessage();</span>
<span class="line-added">+     token = ERRORTOK;</span>
<span class="line-added">+     // Falls through to return error.</span>
<span class="line-added">+ </span>
  returnError:
      m_error = true;
      fillTokenInfo(tokenRecord, token, m_lineNumber, currentOffset(), currentLineStartOffset(), currentPosition());
      RELEASE_ASSERT(token &amp; ErrorTokenFlag);
      return token;
</pre>
<center><a href="ASTBuilder.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Lexer.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>