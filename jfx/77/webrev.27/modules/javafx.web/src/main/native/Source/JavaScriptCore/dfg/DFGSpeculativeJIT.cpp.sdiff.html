<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGSpeculativeJIT.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGSlowPathGenerator.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGSpeculativeJIT.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGSpeculativeJIT.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   24  */
   25 
   26 #include &quot;config.h&quot;
   27 #include &quot;DFGSpeculativeJIT.h&quot;
   28 
   29 #if ENABLE(DFG_JIT)
   30 
   31 #include &quot;BinarySwitch.h&quot;
   32 #include &quot;DFGAbstractInterpreterInlines.h&quot;
   33 #include &quot;DFGArrayifySlowPathGenerator.h&quot;
   34 #include &quot;DFGCallArrayAllocatorSlowPathGenerator.h&quot;
   35 #include &quot;DFGCallCreateDirectArgumentsSlowPathGenerator.h&quot;
   36 #include &quot;DFGCapabilities.h&quot;
   37 #include &quot;DFGMayExit.h&quot;
   38 #include &quot;DFGOSRExitFuzz.h&quot;
   39 #include &quot;DFGSaneStringGetByValSlowPathGenerator.h&quot;
   40 #include &quot;DFGSlowPathGenerator.h&quot;
   41 #include &quot;DFGSnippetParams.h&quot;
   42 #include &quot;DirectArguments.h&quot;

   43 #include &quot;JITAddGenerator.h&quot;
   44 #include &quot;JITBitAndGenerator.h&quot;
   45 #include &quot;JITBitOrGenerator.h&quot;
   46 #include &quot;JITBitXorGenerator.h&quot;
   47 #include &quot;JITDivGenerator.h&quot;
   48 #include &quot;JITLeftShiftGenerator.h&quot;
   49 #include &quot;JITMulGenerator.h&quot;
   50 #include &quot;JITRightShiftGenerator.h&quot;
   51 #include &quot;JITSubGenerator.h&quot;
   52 #include &quot;JSAsyncFunction.h&quot;
   53 #include &quot;JSAsyncGeneratorFunction.h&quot;
   54 #include &quot;JSCInlines.h&quot;
   55 #include &quot;JSFixedArray.h&quot;
   56 #include &quot;JSGeneratorFunction.h&quot;
   57 #include &quot;JSImmutableButterfly.h&quot;
   58 #include &quot;JSLexicalEnvironment.h&quot;
   59 #include &quot;JSPropertyNameEnumerator.h&quot;
   60 #include &quot;LinkBuffer.h&quot;
   61 #include &quot;RegExpObject.h&quot;
   62 #include &quot;ScopedArguments.h&quot;
   63 #include &quot;ScratchRegisterAllocator.h&quot;
   64 #include &quot;SuperSampler.h&quot;
   65 #include &quot;TypeProfilerLog.h&quot;
   66 #include &quot;WeakMapImpl.h&quot;
   67 #include &lt;wtf/BitVector.h&gt;
   68 #include &lt;wtf/Box.h&gt;
   69 #include &lt;wtf/MathExtras.h&gt;
   70 
   71 namespace JSC { namespace DFG {
   72 
   73 SpeculativeJIT::SpeculativeJIT(JITCompiler&amp; jit)
<span class="line-modified">   74     : m_compileOkay(true)</span>
<span class="line-removed">   75     , m_jit(jit)</span>
   76     , m_graph(m_jit.graph())
   77     , m_currentNode(0)
   78     , m_lastGeneratedNode(LastNodeType)
   79     , m_indexInBlock(0)
   80     , m_generationInfo(m_jit.graph().frameRegisterCount())

   81     , m_state(m_jit.graph())
   82     , m_interpreter(m_jit.graph(), m_state)
   83     , m_stream(&amp;jit.jitCode()-&gt;variableEventStream)
   84     , m_minifiedGraph(&amp;jit.jitCode()-&gt;minifiedDFG)
   85 {
   86 }
   87 
   88 SpeculativeJIT::~SpeculativeJIT()
   89 {
   90 }
   91 
   92 void SpeculativeJIT::emitAllocateRawObject(GPRReg resultGPR, RegisteredStructure structure, GPRReg storageGPR, unsigned numElements, unsigned vectorLength)
   93 {
   94     ASSERT(!isCopyOnWrite(structure-&gt;indexingMode()));
   95     IndexingType indexingType = structure-&gt;indexingType();
   96     bool hasIndexingHeader = hasIndexedProperties(indexingType);
   97 
   98     unsigned inlineCapacity = structure-&gt;inlineCapacity();
   99     unsigned outOfLineCapacity = structure-&gt;outOfLineCapacity();
  100 
  101     GPRTemporary scratch(this);
  102     GPRTemporary scratch2(this);
  103     GPRReg scratchGPR = scratch.gpr();
  104     GPRReg scratch2GPR = scratch2.gpr();
  105 
  106     ASSERT(vectorLength &gt;= numElements);
  107     vectorLength = Butterfly::optimalContiguousVectorLength(structure.get(), vectorLength);
  108 
  109     JITCompiler::JumpList slowCases;
  110 
  111     size_t size = 0;
  112     if (hasIndexingHeader)
  113         size += vectorLength * sizeof(JSValue) + sizeof(IndexingHeader);
  114     size += outOfLineCapacity * sizeof(JSValue);
  115 
  116     m_jit.move(TrustedImmPtr(nullptr), storageGPR);
  117 

  118     if (size) {
<span class="line-modified">  119         if (Allocator allocator = m_jit.vm()-&gt;jsValueGigacageAuxiliarySpace.allocatorForNonVirtual(size, AllocatorForMode::AllocatorIfExists)) {</span>
  120             m_jit.emitAllocate(storageGPR, JITAllocator::constant(allocator), scratchGPR, scratch2GPR, slowCases);
  121 
  122             m_jit.addPtr(
  123                 TrustedImm32(outOfLineCapacity * sizeof(JSValue) + sizeof(IndexingHeader)),
  124                 storageGPR);
  125 
  126             if (hasIndexingHeader)
  127                 m_jit.store32(TrustedImm32(vectorLength), MacroAssembler::Address(storageGPR, Butterfly::offsetOfVectorLength()));
  128         } else
  129             slowCases.append(m_jit.jump());
  130     }
  131 
  132     size_t allocationSize = JSFinalObject::allocationSize(inlineCapacity);
<span class="line-modified">  133     Allocator allocator = allocatorForNonVirtualConcurrently&lt;JSFinalObject&gt;(*m_jit.vm(), allocationSize, AllocatorForMode::AllocatorIfExists);</span>
  134     if (allocator) {
  135         emitAllocateJSObject(resultGPR, JITAllocator::constant(allocator), scratchGPR, TrustedImmPtr(structure), storageGPR, scratch2GPR, slowCases);
  136         m_jit.emitInitializeInlineStorage(resultGPR, structure-&gt;inlineCapacity());
  137     } else
  138         slowCases.append(m_jit.jump());
  139 
  140     // I want a slow path that also loads out the storage pointer, and that&#39;s
  141     // what this custom CallArrayAllocatorSlowPathGenerator gives me. It&#39;s a lot
  142     // of work for a very small piece of functionality. :-/
<span class="line-modified">  143     addSlowPathGenerator(std::make_unique&lt;CallArrayAllocatorSlowPathGenerator&gt;(</span>
  144         slowCases, this, operationNewRawObject, resultGPR, storageGPR,
  145         structure, vectorLength));
  146 
  147     if (numElements &lt; vectorLength) {
  148 #if USE(JSVALUE64)
  149         if (hasDouble(structure-&gt;indexingType()))
  150             m_jit.move(TrustedImm64(bitwise_cast&lt;int64_t&gt;(PNaN)), scratchGPR);
  151         else
  152             m_jit.move(TrustedImm64(JSValue::encode(JSValue())), scratchGPR);
  153         for (unsigned i = numElements; i &lt; vectorLength; ++i)
  154             m_jit.store64(scratchGPR, MacroAssembler::Address(storageGPR, sizeof(double) * i));
  155 #else
  156         EncodedValueDescriptor value;
  157         if (hasDouble(structure-&gt;indexingType()))
  158             value.asInt64 = JSValue::encode(JSValue(JSValue::EncodeAsDouble, PNaN));
  159         else
  160             value.asInt64 = JSValue::encode(JSValue());
  161         for (unsigned i = numElements; i &lt; vectorLength; ++i) {
  162             m_jit.store32(TrustedImm32(value.asBits.tag), MacroAssembler::Address(storageGPR, sizeof(double) * i + OBJECT_OFFSETOF(JSValue, u.asBits.tag)));
  163             m_jit.store32(TrustedImm32(value.asBits.payload), MacroAssembler::Address(storageGPR, sizeof(double) * i + OBJECT_OFFSETOF(JSValue, u.asBits.payload)));
  164         }
  165 #endif
  166     }
  167 
  168     if (hasIndexingHeader)
  169         m_jit.store32(TrustedImm32(numElements), MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()));
  170 
  171     m_jit.emitInitializeOutOfLineStorage(storageGPR, structure-&gt;outOfLineCapacity());
  172 
<span class="line-modified">  173     m_jit.mutatorFence(*m_jit.vm());</span>
  174 }
  175 
  176 void SpeculativeJIT::emitGetLength(InlineCallFrame* inlineCallFrame, GPRReg lengthGPR, bool includeThis)
  177 {
  178     if (inlineCallFrame &amp;&amp; !inlineCallFrame-&gt;isVarargs())
  179         m_jit.move(TrustedImm32(inlineCallFrame-&gt;argumentCountIncludingThis - !includeThis), lengthGPR);
  180     else {
  181         VirtualRegister argumentCountRegister = m_jit.argumentCount(inlineCallFrame);
  182         m_jit.load32(JITCompiler::payloadFor(argumentCountRegister), lengthGPR);
  183         if (!includeThis)
  184             m_jit.sub32(TrustedImm32(1), lengthGPR);
  185     }
  186 }
  187 
  188 void SpeculativeJIT::emitGetLength(CodeOrigin origin, GPRReg lengthGPR, bool includeThis)
  189 {
<span class="line-modified">  190     emitGetLength(origin.inlineCallFrame, lengthGPR, includeThis);</span>
  191 }
  192 
  193 void SpeculativeJIT::emitGetCallee(CodeOrigin origin, GPRReg calleeGPR)
  194 {
<span class="line-modified">  195     if (origin.inlineCallFrame) {</span>
<span class="line-modified">  196         if (origin.inlineCallFrame-&gt;isClosureCall) {</span>

  197             m_jit.loadPtr(
<span class="line-modified">  198                 JITCompiler::addressFor(origin.inlineCallFrame-&gt;calleeRecovery.virtualRegister()),</span>
  199                 calleeGPR);
  200         } else {
  201             m_jit.move(
<span class="line-modified">  202                 TrustedImmPtr::weakPointer(m_jit.graph(), origin.inlineCallFrame-&gt;calleeRecovery.constant().asCell()),</span>
  203                 calleeGPR);
  204         }
  205     } else
  206         m_jit.loadPtr(JITCompiler::addressFor(CallFrameSlot::callee), calleeGPR);
  207 }
  208 
  209 void SpeculativeJIT::emitGetArgumentStart(CodeOrigin origin, GPRReg startGPR)
  210 {
  211     m_jit.addPtr(
  212         TrustedImm32(
  213             JITCompiler::argumentsStart(origin).offset() * static_cast&lt;int&gt;(sizeof(Register))),
  214         GPRInfo::callFrameRegister, startGPR);
  215 }
  216 
  217 MacroAssembler::Jump SpeculativeJIT::emitOSRExitFuzzCheck()
  218 {
  219     if (!Options::useOSRExitFuzz()
  220         || !canUseOSRExitFuzzing(m_jit.graph().baselineCodeBlockFor(m_origin.semantic))
  221         || !doOSRExitFuzzing())
  222         return MacroAssembler::Jump();
</pre>
<hr />
<pre>
  880         structureGPR = structure.gpr();
  881     }
  882 
  883     // We can skip all that comes next if we already have array storage.
  884     MacroAssembler::JumpList slowPath;
  885 
  886     if (node-&gt;op() == ArrayifyToStructure) {
  887         ASSERT(!isCopyOnWrite(node-&gt;structure()-&gt;indexingMode()));
  888         ASSERT((node-&gt;structure()-&gt;indexingType() &amp; IndexingShapeMask) == node-&gt;arrayMode().shapeMask());
  889         slowPath.append(m_jit.branchWeakStructure(
  890             JITCompiler::NotEqual,
  891             JITCompiler::Address(baseReg, JSCell::structureIDOffset()),
  892             node-&gt;structure()));
  893     } else {
  894         m_jit.load8(
  895             MacroAssembler::Address(baseReg, JSCell::indexingTypeAndMiscOffset()), tempGPR);
  896 
  897         slowPath.append(jumpSlowForUnwantedArrayMode(tempGPR, node-&gt;arrayMode()));
  898     }
  899 
<span class="line-modified">  900     addSlowPathGenerator(std::make_unique&lt;ArrayifySlowPathGenerator&gt;(</span>
  901         slowPath, this, node, baseReg, propertyReg, tempGPR, structureGPR));
  902 
  903     noResult(m_currentNode);
  904 }
  905 
  906 void SpeculativeJIT::arrayify(Node* node)
  907 {
  908     ASSERT(node-&gt;arrayMode().isSpecific());
  909 
  910     SpeculateCellOperand base(this, node-&gt;child1());
  911 
  912     if (!node-&gt;child2()) {
  913         arrayify(node, base.gpr(), InvalidGPRReg);
  914         return;
  915     }
  916 
  917     SpeculateInt32Operand property(this, node-&gt;child2());
  918 
  919     arrayify(node, base.gpr(), property.gpr());
  920 }
</pre>
<hr />
<pre>
 1529 
 1530 void SpeculativeJIT::compileStringSlice(Node* node)
 1531 {
 1532     SpeculateCellOperand string(this, node-&gt;child1());
 1533 
 1534     GPRReg stringGPR = string.gpr();
 1535 
 1536     speculateString(node-&gt;child1(), stringGPR);
 1537 
 1538     SpeculateInt32Operand start(this, node-&gt;child2());
 1539     GPRReg startGPR = start.gpr();
 1540 
 1541     Optional&lt;SpeculateInt32Operand&gt; end;
 1542     Optional&lt;GPRReg&gt; endGPR;
 1543     if (node-&gt;child3()) {
 1544         end.emplace(this, node-&gt;child3());
 1545         endGPR.emplace(end-&gt;gpr());
 1546     }
 1547 
 1548     GPRTemporary temp(this);
<span class="line-removed"> 1549     GPRReg tempGPR = temp.gpr();</span>
<span class="line-removed"> 1550 </span>
<span class="line-removed"> 1551     m_jit.loadPtr(CCallHelpers::Address(stringGPR, JSString::offsetOfValue()), tempGPR);</span>
<span class="line-removed"> 1552     auto isRope = m_jit.branchIfRopeStringImpl(tempGPR);</span>
<span class="line-removed"> 1553 </span>
 1554     GPRTemporary temp2(this);
 1555     GPRTemporary startIndex(this);
 1556 

 1557     GPRReg temp2GPR = temp2.gpr();
 1558     GPRReg startIndexGPR = startIndex.gpr();



 1559     {
 1560         m_jit.load32(MacroAssembler::Address(tempGPR, StringImpl::lengthMemoryOffset()), temp2GPR);
 1561 
 1562         emitPopulateSliceIndex(node-&gt;child2(), startGPR, temp2GPR, startIndexGPR);
 1563 
 1564         if (node-&gt;child3())
 1565             emitPopulateSliceIndex(node-&gt;child3(), endGPR.value(), temp2GPR, tempGPR);
 1566         else
 1567             m_jit.move(temp2GPR, tempGPR);
 1568     }
 1569 
 1570     CCallHelpers::JumpList doneCases;
 1571     CCallHelpers::JumpList slowCases;
 1572 

 1573     auto nonEmptyCase = m_jit.branch32(MacroAssembler::Below, startIndexGPR, tempGPR);
<span class="line-modified"> 1574     m_jit.move(TrustedImmPtr::weakPointer(m_jit.graph(), jsEmptyString(&amp;vm())), tempGPR);</span>
 1575     doneCases.append(m_jit.jump());
 1576 
 1577     nonEmptyCase.link(&amp;m_jit);
 1578     m_jit.sub32(startIndexGPR, tempGPR); // the size of the sliced string.
 1579     slowCases.append(m_jit.branch32(MacroAssembler::NotEqual, tempGPR, TrustedImm32(1)));
 1580 
 1581     // Refill StringImpl* here.
 1582     m_jit.loadPtr(MacroAssembler::Address(stringGPR, JSString::offsetOfValue()), temp2GPR);
 1583     m_jit.loadPtr(MacroAssembler::Address(temp2GPR, StringImpl::dataOffset()), tempGPR);
 1584 
 1585     // Load the character into scratchReg
 1586     m_jit.zeroExtend32ToPtr(startIndexGPR, startIndexGPR);
 1587     auto is16Bit = m_jit.branchTest32(MacroAssembler::Zero, MacroAssembler::Address(temp2GPR, StringImpl::flagsOffset()), TrustedImm32(StringImpl::flagIs8Bit()));
 1588 
 1589     m_jit.load8(MacroAssembler::BaseIndex(tempGPR, startIndexGPR, MacroAssembler::TimesOne, 0), tempGPR);
 1590     auto cont8Bit = m_jit.jump();
 1591 
 1592     is16Bit.link(&amp;m_jit);
 1593     m_jit.load16(MacroAssembler::BaseIndex(tempGPR, startIndexGPR, MacroAssembler::TimesTwo, 0), tempGPR);
 1594 
 1595     auto bigCharacter = m_jit.branch32(MacroAssembler::Above, tempGPR, TrustedImm32(maxSingleCharacterString));
 1596 
 1597     // 8 bit string values don&#39;t need the isASCII check.
 1598     cont8Bit.link(&amp;m_jit);
 1599 
 1600     m_jit.lshift32(MacroAssembler::TrustedImm32(sizeof(void*) == 4 ? 2 : 3), tempGPR);
<span class="line-modified"> 1601     m_jit.addPtr(TrustedImmPtr(m_jit.vm()-&gt;smallStrings.singleCharacterStrings()), tempGPR);</span>
 1602     m_jit.loadPtr(tempGPR, tempGPR);
 1603 
 1604     addSlowPathGenerator(slowPathCall(bigCharacter, this, operationSingleCharacterString, tempGPR, tempGPR));
 1605 
 1606     addSlowPathGenerator(slowPathCall(slowCases, this, operationStringSubstr, tempGPR, stringGPR, startIndexGPR, tempGPR));
 1607 
 1608     if (endGPR)
 1609         addSlowPathGenerator(slowPathCall(isRope, this, operationStringSlice, tempGPR, stringGPR, startGPR, *endGPR));
 1610     else
 1611         addSlowPathGenerator(slowPathCall(isRope, this, operationStringSlice, tempGPR, stringGPR, startGPR, TrustedImm32(std::numeric_limits&lt;int32_t&gt;::max())));
 1612 
 1613     doneCases.link(&amp;m_jit);
 1614     cellResult(tempGPR, node);
 1615 }
 1616 
 1617 void SpeculativeJIT::compileToLowerCase(Node* node)
 1618 {
 1619     ASSERT(node-&gt;op() == ToLowerCase);
 1620     SpeculateCellOperand string(this, node-&gt;child1());
 1621     GPRTemporary temp(this);
</pre>
<hr />
<pre>
 1846 
 1847         // We may have hit a contradiction that the CFA was aware of but that the JIT
 1848         // didn&#39;t cause directly.
 1849         if (!m_state.isValid()) {
 1850             bail(DFGBailedAtTopOfBlock);
 1851             return;
 1852         }
 1853 
 1854         m_interpreter.startExecuting();
 1855         m_interpreter.executeKnownEdgeTypes(m_currentNode);
 1856         m_jit.setForNode(m_currentNode);
 1857         m_origin = m_currentNode-&gt;origin;
 1858         m_lastGeneratedNode = m_currentNode-&gt;op();
 1859 
 1860         ASSERT(m_currentNode-&gt;shouldGenerate());
 1861 
 1862         if (verboseCompilationEnabled()) {
 1863             dataLogF(
 1864                 &quot;SpeculativeJIT generating Node @%d (bc#%u) at JIT offset 0x%x&quot;,
 1865                 (int)m_currentNode-&gt;index(),
<span class="line-modified"> 1866                 m_currentNode-&gt;origin.semantic.bytecodeIndex, m_jit.debugOffset());</span>
 1867             dataLog(&quot;\n&quot;);
 1868         }
 1869 
 1870         if (Options::validateDFGExceptionHandling() &amp;&amp; (mayExit(m_jit.graph(), m_currentNode) != DoesNotExit || m_currentNode-&gt;isTerminal()))
<span class="line-modified"> 1871             m_jit.jitReleaseAssertNoException(*m_jit.vm());</span>
 1872 
 1873         m_jit.pcToCodeOriginMapBuilder().appendItem(m_jit.labelIgnoringWatchpoints(), m_origin.semantic);
 1874 
 1875         compile(m_currentNode);
 1876 
 1877         if (belongsInMinifiedGraph(m_currentNode-&gt;op()))
 1878             m_minifiedGraph-&gt;append(MinifiedNode::fromNode(m_currentNode));
 1879 
 1880 #if ENABLE(DFG_REGISTER_ALLOCATION_VALIDATION)
 1881         m_jit.clearRegisterAllocationOffsets();
 1882 #endif
 1883 
 1884         if (!m_compileOkay) {
 1885             bail(DFGBailedAtEndOfNode);
 1886             return;
 1887         }
 1888 
 1889         // Make sure that the abstract state is rematerialized for the next node.
 1890         m_interpreter.executeEffects(m_indexInBlock);
 1891     }
</pre>
<hr />
<pre>
 1895         for (auto&amp; info : m_generationInfo)
 1896             RELEASE_ASSERT(!info.alive());
 1897     }
 1898 }
 1899 
 1900 // If we are making type predictions about our arguments then
 1901 // we need to check that they are correct on function entry.
 1902 void SpeculativeJIT::checkArgumentTypes()
 1903 {
 1904     ASSERT(!m_currentNode);
 1905     m_origin = NodeOrigin(CodeOrigin(0), CodeOrigin(0), true);
 1906 
 1907     auto&amp; arguments = m_jit.graph().m_rootToArguments.find(m_jit.graph().block(0))-&gt;value;
 1908     for (int i = 0; i &lt; m_jit.codeBlock()-&gt;numParameters(); ++i) {
 1909         Node* node = arguments[i];
 1910         if (!node) {
 1911             // The argument is dead. We don&#39;t do any checks for such arguments.
 1912             continue;
 1913         }
 1914 
<span class="line-modified"> 1915         ASSERT(node-&gt;op() == SetArgument);</span>
 1916         ASSERT(node-&gt;shouldGenerate());
 1917 
 1918         VariableAccessData* variableAccessData = node-&gt;variableAccessData();
 1919         FlushFormat format = variableAccessData-&gt;flushFormat();
 1920 
 1921         if (format == FlushedJSValue)
 1922             continue;
 1923 
 1924         VirtualRegister virtualRegister = variableAccessData-&gt;local();
 1925 
 1926         JSValueSource valueSource = JSValueSource(JITCompiler::addressFor(virtualRegister));
 1927 
 1928 #if USE(JSVALUE64)
 1929         switch (format) {
 1930         case FlushedInt32: {
 1931             speculationCheck(BadType, valueSource, node, m_jit.branch64(MacroAssembler::Below, JITCompiler::addressFor(virtualRegister), GPRInfo::tagTypeNumberRegister));
 1932             break;
 1933         }
 1934         case FlushedBoolean: {
 1935             GPRTemporary temp(this);
</pre>
<hr />
<pre>
 2031 
 2032     ASSERT(osrEntryIndex == m_osrEntryHeads.size());
 2033 
 2034     if (verboseCompilationEnabled()) {
 2035         DumpContext dumpContext;
 2036         dataLog(&quot;OSR Entries:\n&quot;);
 2037         for (OSREntryData&amp; entryData : m_jit.jitCode()-&gt;osrEntry)
 2038             dataLog(&quot;    &quot;, inContext(entryData, &amp;dumpContext), &quot;\n&quot;);
 2039         if (!dumpContext.isEmpty())
 2040             dumpContext.dump(WTF::dataFile());
 2041     }
 2042 }
 2043 
 2044 void SpeculativeJIT::compileCheckTraps(Node* node)
 2045 {
 2046     ASSERT(Options::usePollingTraps());
 2047     GPRTemporary unused(this);
 2048     GPRReg unusedGPR = unused.gpr();
 2049 
 2050     JITCompiler::Jump needTrapHandling = m_jit.branchTest8(JITCompiler::NonZero,
<span class="line-modified"> 2051         JITCompiler::AbsoluteAddress(m_jit.vm()-&gt;needTrapHandlingAddress()));</span>
 2052 
 2053     addSlowPathGenerator(slowPathCall(needTrapHandling, this, operationHandleTraps, unusedGPR));
 2054     noResult(node);
 2055 }
 2056 
 2057 void SpeculativeJIT::compileDoublePutByVal(Node* node, SpeculateCellOperand&amp; base, SpeculateStrictInt32Operand&amp; property)
 2058 {
 2059     Edge child3 = m_jit.graph().varArgChild(node, 2);
 2060     Edge child4 = m_jit.graph().varArgChild(node, 3);
 2061 
 2062     ArrayMode arrayMode = node-&gt;arrayMode();
 2063 
 2064     GPRReg baseReg = base.gpr();
 2065     GPRReg propertyReg = property.gpr();
 2066 
 2067     SpeculateDoubleOperand value(this, child3);
 2068 
 2069     FPRReg valueReg = value.fpr();
 2070 
 2071     DFG_TYPE_CHECK(
</pre>
<hr />
<pre>
 2105         if (!arrayMode.isOutOfBounds())
 2106             speculationCheck(OutOfBounds, JSValueRegs(), 0, slowCase);
 2107 
 2108         m_jit.add32(TrustedImm32(1), propertyReg, temporaryReg);
 2109         m_jit.store32(temporaryReg, MacroAssembler::Address(storageReg, Butterfly::offsetOfPublicLength()));
 2110 
 2111         inBounds.link(&amp;m_jit);
 2112     }
 2113 
 2114     m_jit.storeDouble(valueReg, MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight));
 2115 
 2116     base.use();
 2117     property.use();
 2118     value.use();
 2119     storage.use();
 2120 
 2121     if (arrayMode.isOutOfBounds()) {
 2122         addSlowPathGenerator(
 2123             slowPathCall(
 2124                 slowCase, this,
<span class="line-modified"> 2125                 m_jit.codeBlock()-&gt;isStrictMode()</span>
 2126                     ? (node-&gt;op() == PutByValDirect ? operationPutDoubleByValDirectBeyondArrayBoundsStrict : operationPutDoubleByValBeyondArrayBoundsStrict)
 2127                     : (node-&gt;op() == PutByValDirect ? operationPutDoubleByValDirectBeyondArrayBoundsNonStrict : operationPutDoubleByValBeyondArrayBoundsNonStrict),
 2128                 NoResult, baseReg, propertyReg, valueReg));
 2129     }
 2130 
 2131     noResult(m_currentNode, UseChildrenCalledExplicitly);
 2132 }
 2133 
 2134 void SpeculativeJIT::compileGetCharCodeAt(Node* node)
 2135 {
 2136     SpeculateCellOperand string(this, node-&gt;child1());
 2137     SpeculateStrictInt32Operand index(this, node-&gt;child2());
 2138     StorageOperand storage(this, node-&gt;child3());
 2139 
 2140     GPRReg stringReg = string.gpr();
 2141     GPRReg indexReg = index.gpr();
 2142     GPRReg storageReg = storage.gpr();
 2143 
 2144     ASSERT(speculationChecked(m_state.forNode(node-&gt;child1()).m_type, SpecString));
 2145 
</pre>
<hr />
<pre>
 2196         MacroAssembler::Address(scratchReg, StringImpl::lengthMemoryOffset()));
 2197     if (node-&gt;arrayMode().isInBounds())
 2198         speculationCheck(OutOfBounds, JSValueRegs(), 0, outOfBounds);
 2199 
 2200     // Load the character into scratchReg
 2201     JITCompiler::Jump is16Bit = m_jit.branchTest32(MacroAssembler::Zero, MacroAssembler::Address(scratchReg, StringImpl::flagsOffset()), TrustedImm32(StringImpl::flagIs8Bit()));
 2202 
 2203     m_jit.load8(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesOne, 0), scratchReg);
 2204     JITCompiler::Jump cont8Bit = m_jit.jump();
 2205 
 2206     is16Bit.link(&amp;m_jit);
 2207 
 2208     m_jit.load16(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesTwo, 0), scratchReg);
 2209 
 2210     JITCompiler::Jump bigCharacter =
 2211         m_jit.branch32(MacroAssembler::Above, scratchReg, TrustedImm32(maxSingleCharacterString));
 2212 
 2213     // 8 bit string values don&#39;t need the isASCII check.
 2214     cont8Bit.link(&amp;m_jit);
 2215 

 2216     m_jit.lshift32(MacroAssembler::TrustedImm32(sizeof(void*) == 4 ? 2 : 3), scratchReg);
<span class="line-modified"> 2217     m_jit.addPtr(TrustedImmPtr(m_jit.vm()-&gt;smallStrings.singleCharacterStrings()), scratchReg);</span>
 2218     m_jit.loadPtr(scratchReg, scratchReg);
 2219 
 2220     addSlowPathGenerator(
 2221         slowPathCall(
 2222             bigCharacter, this, operationSingleCharacterString, scratchReg, scratchReg));
 2223 
 2224     if (node-&gt;arrayMode().isOutOfBounds()) {
 2225 #if USE(JSVALUE32_64)
 2226         m_jit.move(TrustedImm32(JSValue::CellTag), resultTagReg);
 2227 #endif
 2228 
 2229         JSGlobalObject* globalObject = m_jit.globalObjectFor(node-&gt;origin.semantic);
<span class="line-modified"> 2230         bool prototypeChainIsSane = false;</span>



 2231         if (globalObject-&gt;stringPrototypeChainIsSane()) {
 2232             // FIXME: This could be captured using a Speculation mode that means &quot;out-of-bounds
 2233             // loads return a trivial value&quot;. Something like SaneChainOutOfBounds. This should
 2234             // speculate that we don&#39;t take negative out-of-bounds, or better yet, it should rely
 2235             // on a stringPrototypeChainIsSane() guaranteeing that the prototypes have no negative
 2236             // indexed properties either.
 2237             // https://bugs.webkit.org/show_bug.cgi?id=144668
<span class="line-modified"> 2238             m_jit.graph().registerAndWatchStructureTransition(globalObject-&gt;stringPrototype()-&gt;structure(*m_jit.vm()));</span>
<span class="line-modified"> 2239             m_jit.graph().registerAndWatchStructureTransition(globalObject-&gt;objectPrototype()-&gt;structure(*m_jit.vm()));</span>
<span class="line-modified"> 2240             prototypeChainIsSane = globalObject-&gt;stringPrototypeChainIsSane();</span>
<span class="line-removed"> 2241         }</span>
<span class="line-removed"> 2242         if (prototypeChainIsSane) {</span>
 2243 #if USE(JSVALUE64)
<span class="line-modified"> 2244             addSlowPathGenerator(std::make_unique&lt;SaneStringGetByValSlowPathGenerator&gt;(</span>
 2245                 outOfBounds, this, JSValueRegs(scratchReg), baseReg, propertyReg));
 2246 #else
<span class="line-modified"> 2247             addSlowPathGenerator(std::make_unique&lt;SaneStringGetByValSlowPathGenerator&gt;(</span>
 2248                 outOfBounds, this, JSValueRegs(resultTagReg, scratchReg),
 2249                 baseReg, propertyReg));
 2250 #endif
 2251         } else {
 2252 #if USE(JSVALUE64)
 2253             addSlowPathGenerator(
 2254                 slowPathCall(
 2255                     outOfBounds, this, operationGetByValStringInt,
 2256                     scratchReg, baseReg, propertyReg));
 2257 #else
 2258             addSlowPathGenerator(
 2259                 slowPathCall(
 2260                     outOfBounds, this, operationGetByValStringInt,
 2261                     JSValueRegs(resultTagReg, scratchReg), baseReg, propertyReg));
 2262 #endif
 2263         }
 2264 
 2265 #if USE(JSVALUE64)
 2266         jsValueResult(scratchReg, m_currentNode);
 2267 #else
</pre>
<hr />
<pre>
 2279         JSValueRegs oprRegs = opr.jsValueRegs();
 2280 
 2281         flushRegisters();
 2282         JSValueRegsFlushedCallResult result(this);
 2283         JSValueRegs resultRegs = result.regs();
 2284         callOperation(operationStringFromCharCodeUntyped, resultRegs, oprRegs);
 2285         m_jit.exceptionCheck();
 2286 
 2287         jsValueResult(resultRegs, node);
 2288         return;
 2289     }
 2290 
 2291     SpeculateStrictInt32Operand property(this, child);
 2292     GPRReg propertyReg = property.gpr();
 2293     GPRTemporary smallStrings(this);
 2294     GPRTemporary scratch(this);
 2295     GPRReg scratchReg = scratch.gpr();
 2296     GPRReg smallStringsReg = smallStrings.gpr();
 2297 
 2298     JITCompiler::JumpList slowCases;
<span class="line-modified"> 2299     slowCases.append(m_jit.branch32(MacroAssembler::AboveOrEqual, propertyReg, TrustedImm32(maxSingleCharacterString)));</span>
<span class="line-modified"> 2300     m_jit.move(TrustedImmPtr(m_jit.vm()-&gt;smallStrings.singleCharacterStrings()), smallStringsReg);</span>
 2301     m_jit.loadPtr(MacroAssembler::BaseIndex(smallStringsReg, propertyReg, MacroAssembler::ScalePtr, 0), scratchReg);
 2302 
 2303     slowCases.append(m_jit.branchTest32(MacroAssembler::Zero, scratchReg));
 2304     addSlowPathGenerator(slowPathCall(slowCases, this, operationStringFromCharCode, scratchReg, propertyReg));
 2305     cellResult(scratchReg, m_currentNode);
 2306 }
 2307 
 2308 GeneratedOperandType SpeculativeJIT::checkGeneratedTypeForToInt32(Node* node)
 2309 {
 2310     VirtualRegister virtualRegister = node-&gt;virtualRegister();
 2311     GenerationInfo&amp; info = generationInfoFromVirtualRegister(virtualRegister);
 2312 
 2313     switch (info.registerFormat()) {
 2314     case DataFormatStorage:
 2315         RELEASE_ASSERT_NOT_REACHED();
 2316 
 2317     case DataFormatBoolean:
 2318     case DataFormatCell:
 2319         terminateSpeculativeExecution(Uncountable, JSValueRegs(), 0);
 2320         return GeneratedOperandTypeUnknown;
</pre>
<hr />
<pre>
 2854     if (!jump.isSet())
 2855         return;
 2856     speculationCheck(OutOfBounds, JSValueRegs(), 0, jump);
 2857 }
 2858 
 2859 JITCompiler::Jump SpeculativeJIT::jumpForTypedArrayIsNeuteredIfOutOfBounds(Node* node, GPRReg base, JITCompiler::Jump outOfBounds)
 2860 {
 2861     JITCompiler::Jump done;
 2862     if (outOfBounds.isSet()) {
 2863         done = m_jit.jump();
 2864         if (node-&gt;arrayMode().isInBounds())
 2865             speculationCheck(OutOfBounds, JSValueSource(), 0, outOfBounds);
 2866         else {
 2867             outOfBounds.link(&amp;m_jit);
 2868 
 2869             JITCompiler::Jump notWasteful = m_jit.branch32(
 2870                 MacroAssembler::NotEqual,
 2871                 MacroAssembler::Address(base, JSArrayBufferView::offsetOfMode()),
 2872                 TrustedImm32(WastefulTypedArray));
 2873 
<span class="line-modified"> 2874             JITCompiler::Jump hasNullVector = m_jit.branchTestPtr(</span>











 2875                 MacroAssembler::Zero,
 2876                 MacroAssembler::Address(base, JSArrayBufferView::offsetOfVector()));

 2877             speculationCheck(Uncountable, JSValueSource(), node, hasNullVector);
 2878             notWasteful.link(&amp;m_jit);
 2879         }
 2880     }
 2881     return done;
 2882 }
 2883 
 2884 void SpeculativeJIT::loadFromIntTypedArray(GPRReg storageReg, GPRReg propertyReg, GPRReg resultReg, TypedArrayType type)
 2885 {
 2886     switch (elementSize(type)) {
 2887     case 1:
 2888         if (isSigned(type))
 2889             m_jit.load8SignedExtendTo32(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesOne), resultReg);
 2890         else
 2891             m_jit.load8(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesOne), resultReg);
 2892         break;
 2893     case 2:
 2894         if (isSigned(type))
 2895             m_jit.load16SignedExtendTo32(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesTwo), resultReg);
 2896         else
</pre>
<hr />
<pre>
 2902     default:
 2903         CRASH();
 2904     }
 2905 }
 2906 
 2907 void SpeculativeJIT::setIntTypedArrayLoadResult(Node* node, GPRReg resultReg, TypedArrayType type, bool canSpeculate)
 2908 {
 2909     if (elementSize(type) &lt; 4 || isSigned(type)) {
 2910         int32Result(resultReg, node);
 2911         return;
 2912     }
 2913 
 2914     ASSERT(elementSize(type) == 4 &amp;&amp; !isSigned(type));
 2915     if (node-&gt;shouldSpeculateInt32() &amp;&amp; canSpeculate) {
 2916         speculationCheck(Overflow, JSValueRegs(), 0, m_jit.branch32(MacroAssembler::LessThan, resultReg, TrustedImm32(0)));
 2917         int32Result(resultReg, node);
 2918         return;
 2919     }
 2920 
 2921 #if USE(JSVALUE64)
<span class="line-modified"> 2922     if (node-&gt;shouldSpeculateAnyInt()) {</span>

 2923         m_jit.zeroExtend32ToPtr(resultReg, resultReg);
 2924         strictInt52Result(resultReg, node);
 2925         return;
 2926     }
 2927 #endif
 2928 
 2929     FPRTemporary fresult(this);
 2930     m_jit.convertInt32ToDouble(resultReg, fresult.fpr());
 2931     JITCompiler::Jump positive = m_jit.branch32(MacroAssembler::GreaterThanOrEqual, resultReg, TrustedImm32(0));
 2932     m_jit.addDouble(JITCompiler::AbsoluteAddress(&amp;AssemblyHelpers::twoToThe32), fresult.fpr());
 2933     positive.link(&amp;m_jit);
 2934     doubleResult(fresult.fpr(), node);
 2935 }
 2936 
 2937 void SpeculativeJIT::compileGetByValOnIntTypedArray(Node* node, TypedArrayType type)
 2938 {
 2939     ASSERT(isInt(type));
 2940 
 2941     SpeculateCellOperand base(this, m_graph.varArgChild(node, 0));
 2942     SpeculateStrictInt32Operand property(this, m_graph.varArgChild(node, 1));
 2943     StorageOperand storage(this, m_graph.varArgChild(node, 2));
 2944 
 2945     GPRReg baseReg = base.gpr();
 2946     GPRReg propertyReg = property.gpr();
 2947     GPRReg storageReg = storage.gpr();
 2948 
 2949     GPRTemporary result(this);
 2950     GPRReg resultReg = result.gpr();
 2951 
<span class="line-removed"> 2952     ASSERT(node-&gt;arrayMode().alreadyChecked(m_jit.graph(), node, m_state.forNode(m_graph.varArgChild(node, 0))));</span>
<span class="line-removed"> 2953 </span>
 2954     emitTypedArrayBoundsCheck(node, baseReg, propertyReg);
 2955     loadFromIntTypedArray(storageReg, propertyReg, resultReg, type);
 2956     bool canSpeculate = true;
 2957     setIntTypedArrayLoadResult(node, resultReg, type, canSpeculate);
 2958 }
 2959 
 2960 bool SpeculativeJIT::getIntTypedArrayStoreOperand(
 2961     GPRTemporary&amp; value,
 2962     GPRReg property,
 2963 #if USE(JSVALUE32_64)
 2964     GPRTemporary&amp; propertyTag,
 2965     GPRTemporary&amp; valueTag,
 2966 #endif
 2967     Edge valueUse, JITCompiler::JumpList&amp; slowPathCases, bool isClamped)
 2968 {
 2969     bool isAppropriateConstant = false;
 2970     if (valueUse-&gt;isConstant()) {
 2971         JSValue jsValue = valueUse-&gt;asJSValue();
 2972         SpeculatedType expectedType = typeFilterFor(valueUse.useKind());
 2973         SpeculatedType actualType = speculationFromValue(jsValue);
</pre>
<hr />
<pre>
 3136     if (done.isSet())
 3137         done.link(&amp;m_jit);
 3138 
 3139     if (!slowPathCases.empty()) {
 3140 #if USE(JSVALUE64)
 3141         if (node-&gt;op() == PutByValDirect) {
 3142             addSlowPathGenerator(slowPathCall(
 3143                 slowPathCases, this,
 3144                 m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValDirectStrict : operationPutByValDirectNonStrict,
 3145                 NoResult, base, property, valueGPR));
 3146         } else {
 3147             addSlowPathGenerator(slowPathCall(
 3148                 slowPathCases, this,
 3149                 m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValStrict : operationPutByValNonStrict,
 3150                 NoResult, base, property, valueGPR));
 3151         }
 3152 #else // not USE(JSVALUE64)
 3153         if (node-&gt;op() == PutByValDirect) {
 3154             addSlowPathGenerator(slowPathCall(
 3155                 slowPathCases, this,
<span class="line-modified"> 3156                 m_jit.codeBlock()-&gt;isStrictMode() ? operationPutByValDirectCellStrict : operationPutByValDirectCellNonStrict,</span>
 3157                 NoResult, base, JSValueRegs(propertyTagGPR, property), JSValueRegs(valueTagGPR, valueGPR)));
 3158         } else {
 3159             addSlowPathGenerator(slowPathCall(
 3160                 slowPathCases, this,
<span class="line-modified"> 3161                 m_jit.codeBlock()-&gt;isStrictMode() ? operationPutByValCellStrict : operationPutByValCellNonStrict,</span>
 3162                 NoResult, base, JSValueRegs(propertyTagGPR, property), JSValueRegs(valueTagGPR, valueGPR)));
 3163         }
 3164 #endif
 3165     }
 3166 
 3167     noResult(node);
 3168 }
 3169 
 3170 void SpeculativeJIT::compileGetByValOnFloatTypedArray(Node* node, TypedArrayType type)
 3171 {
 3172     ASSERT(isFloat(type));
 3173 
 3174     SpeculateCellOperand base(this, m_graph.varArgChild(node, 0));
 3175     SpeculateStrictInt32Operand property(this, m_graph.varArgChild(node, 1));
 3176     StorageOperand storage(this, m_graph.varArgChild(node, 2));
 3177 
 3178     GPRReg baseReg = base.gpr();
 3179     GPRReg propertyReg = property.gpr();
 3180     GPRReg storageReg = storage.gpr();
 3181 
<span class="line-removed"> 3182     ASSERT(node-&gt;arrayMode().alreadyChecked(m_jit.graph(), node, m_state.forNode(m_graph.varArgChild(node, 0))));</span>
<span class="line-removed"> 3183 </span>
 3184     FPRTemporary result(this);
 3185     FPRReg resultReg = result.fpr();
 3186     emitTypedArrayBoundsCheck(node, baseReg, propertyReg);
 3187     switch (elementSize(type)) {
 3188     case 4:
 3189         m_jit.loadFloat(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesFour), resultReg);
 3190         m_jit.convertFloatToDouble(resultReg, resultReg);
 3191         break;
 3192     case 8: {
 3193         m_jit.loadDouble(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight), resultReg);
 3194         break;
 3195     }
 3196     default:
 3197         RELEASE_ASSERT_NOT_REACHED();
 3198     }
 3199 
 3200     doubleResult(resultReg, node);
 3201 }
 3202 
 3203 void SpeculativeJIT::compilePutByValForFloatTypedArray(GPRReg base, GPRReg property, Node* node, TypedArrayType type)
</pre>
<hr />
<pre>
 3505 
 3506     GPRReg resultGPR = result.gpr();
 3507     GPRReg scratchGPR = scratch.gpr();
 3508 
 3509     JITCompiler::Jump isCell = m_jit.branchIfCell(valueRegs);
 3510     moveFalseTo(resultGPR);
 3511 
 3512     JITCompiler::Jump done = m_jit.jump();
 3513 
 3514     isCell.link(&amp;m_jit);
 3515 
 3516     JITCompiler::Jump slowCase = m_jit.branchIfNotCell(prototypeRegs);
 3517 
 3518     compileInstanceOfForCells(node, valueRegs, prototypeRegs, resultGPR, scratchGPR, InvalidGPRReg, slowCase);
 3519 
 3520     done.link(&amp;m_jit);
 3521     blessedBooleanResult(resultGPR, node);
 3522     return;
 3523 }
 3524 
<span class="line-modified"> 3525 void SpeculativeJIT::compileBitwiseNot(Node* node)</span>
 3526 {
 3527     Edge&amp; child1 = node-&gt;child1();
 3528 
<span class="line-modified"> 3529     if (child1.useKind() == UntypedUse) {</span>
<span class="line-modified"> 3530         JSValueOperand operand(this, child1);</span>
<span class="line-modified"> 3531         JSValueRegs operandRegs = operand.jsValueRegs();</span>


 3532 
 3533         flushRegisters();
<span class="line-modified"> 3534         JSValueRegsFlushedCallResult result(this);</span>
<span class="line-modified"> 3535         JSValueRegs resultRegs = result.regs();</span>
<span class="line-modified"> 3536         callOperation(operationValueBitNot, resultRegs, operandRegs);</span>

 3537         m_jit.exceptionCheck();

 3538 
<span class="line-removed"> 3539         jsValueResult(resultRegs, node);</span>
 3540         return;
 3541     }
 3542 
















 3543     SpeculateInt32Operand operand(this, child1);
 3544     GPRTemporary result(this);
 3545     GPRReg resultGPR = result.gpr();
 3546 
 3547     m_jit.move(operand.gpr(), resultGPR);
 3548 
 3549     m_jit.not32(resultGPR);
 3550 
 3551     int32Result(resultGPR, node);
 3552 }
 3553 
 3554 template&lt;typename SnippetGenerator, J_JITOperation_EJJ snippetSlowPathFunction&gt;
 3555 void SpeculativeJIT::emitUntypedBitOp(Node* node)
 3556 {
 3557     Edge&amp; leftChild = node-&gt;child1();
 3558     Edge&amp; rightChild = node-&gt;child2();
 3559 
 3560     if (isKnownNotNumber(leftChild.node()) || isKnownNotNumber(rightChild.node())) {
 3561         JSValueOperand left(this, leftChild);
 3562         JSValueOperand right(this, rightChild);
</pre>
<hr />
<pre>
 3811     silentSpillAllRegisters(resultRegs);
 3812 
 3813     if (leftOperand.isConst()) {
 3814         leftRegs = resultRegs;
 3815         m_jit.moveValue(leftChild-&gt;asJSValue(), leftRegs);
 3816     } else if (rightOperand.isConst()) {
 3817         rightRegs = resultRegs;
 3818         m_jit.moveValue(rightChild-&gt;asJSValue(), rightRegs);
 3819     }
 3820 
 3821     callOperation(snippetSlowPathFunction, resultRegs, leftRegs, rightRegs);
 3822 
 3823     silentFillAllRegisters();
 3824     m_jit.exceptionCheck();
 3825 
 3826     gen.endJumpList().link(&amp;m_jit);
 3827     jsValueResult(resultRegs, node);
 3828     return;
 3829 }
 3830 




























 3831 void SpeculativeJIT::compileShiftOp(Node* node)
 3832 {
 3833     NodeType op = node-&gt;op();
 3834     Edge&amp; leftChild = node-&gt;child1();
 3835     Edge&amp; rightChild = node-&gt;child2();
 3836 
 3837     if (leftChild.useKind() == UntypedUse || rightChild.useKind() == UntypedUse) {
 3838         switch (op) {
<span class="line-removed"> 3839         case BitLShift:</span>
<span class="line-removed"> 3840             emitUntypedBitOp&lt;JITLeftShiftGenerator, operationValueBitLShift&gt;(node);</span>
<span class="line-removed"> 3841             return;</span>
 3842         case BitRShift:
 3843         case BitURShift:
 3844             emitUntypedRightShiftBitOp(node);
 3845             return;
 3846         default:
 3847             RELEASE_ASSERT_NOT_REACHED();
 3848         }
 3849     }
 3850 
 3851     if (rightChild-&gt;isInt32Constant()) {
 3852         SpeculateInt32Operand op1(this, leftChild);
 3853         GPRTemporary result(this, Reuse, op1);
 3854 
 3855         shiftOp(op, op1.gpr(), rightChild-&gt;asInt32() &amp; 0x1f, result.gpr());
 3856 
 3857         int32Result(result.gpr(), node);
 3858     } else {
 3859         // Do not allow shift amount to be used as the result, MacroAssembler does not permit this.
 3860         SpeculateInt32Operand op1(this, leftChild);
 3861         SpeculateInt32Operand op2(this, rightChild);
</pre>
<hr />
<pre>
 3901 
 3902         flushRegisters();
 3903         JSValueRegsFlushedCallResult result(this);
 3904         JSValueRegs resultRegs = result.regs();
 3905         callOperation(operationValueAddNotNumber, resultRegs, leftRegs, rightRegs);
 3906         m_jit.exceptionCheck();
 3907 
 3908         jsValueResult(resultRegs, node);
 3909         return;
 3910     }
 3911 
 3912 #if USE(JSVALUE64)
 3913     bool needsScratchGPRReg = true;
 3914     bool needsScratchFPRReg = false;
 3915 #else
 3916     bool needsScratchGPRReg = true;
 3917     bool needsScratchFPRReg = true;
 3918 #endif
 3919 
 3920     CodeBlock* baselineCodeBlock = m_jit.graph().baselineCodeBlockFor(node-&gt;origin.semantic);
<span class="line-modified"> 3921     ArithProfile* arithProfile = baselineCodeBlock-&gt;arithProfileForBytecodeOffset(node-&gt;origin.semantic.bytecodeIndex);</span>
<span class="line-modified"> 3922     const Instruction* instruction = baselineCodeBlock-&gt;instructions().at(node-&gt;origin.semantic.bytecodeIndex).ptr();</span>
<span class="line-modified"> 3923     JITAddIC* addIC = m_jit.codeBlock()-&gt;addJITAddIC(arithProfile, instruction);</span>
 3924     auto repatchingFunction = operationValueAddOptimize;
 3925     auto nonRepatchingFunction = operationValueAdd;
 3926 
 3927     compileMathIC(node, addIC, needsScratchGPRReg, needsScratchFPRReg, repatchingFunction, nonRepatchingFunction);
 3928 }
 3929 
 3930 void SpeculativeJIT::compileValueSub(Node* node)
 3931 {
 3932     Edge&amp; leftChild = node-&gt;child1();
 3933     Edge&amp; rightChild = node-&gt;child2();
 3934 
 3935     if (node-&gt;binaryUseKind() == UntypedUse) {
 3936 #if USE(JSVALUE64)
 3937         bool needsScratchGPRReg = true;
 3938         bool needsScratchFPRReg = false;
 3939 #else
 3940         bool needsScratchGPRReg = true;
 3941         bool needsScratchFPRReg = true;
 3942 #endif
 3943 
 3944         CodeBlock* baselineCodeBlock = m_jit.graph().baselineCodeBlockFor(node-&gt;origin.semantic);
<span class="line-modified"> 3945         ArithProfile* arithProfile = baselineCodeBlock-&gt;arithProfileForBytecodeOffset(node-&gt;origin.semantic.bytecodeIndex);</span>
<span class="line-modified"> 3946         const Instruction* instruction = baselineCodeBlock-&gt;instructions().at(node-&gt;origin.semantic.bytecodeIndex).ptr();</span>
<span class="line-modified"> 3947         JITSubIC* subIC = m_jit.codeBlock()-&gt;addJITSubIC(arithProfile, instruction);</span>
 3948         auto repatchingFunction = operationValueSubOptimize;
 3949         auto nonRepatchingFunction = operationValueSub;
 3950 
 3951         compileMathIC(node, subIC, needsScratchGPRReg, needsScratchFPRReg, repatchingFunction, nonRepatchingFunction);
 3952         return;
 3953     }
 3954 
 3955     ASSERT(leftChild.useKind() == BigIntUse &amp;&amp; rightChild.useKind() == BigIntUse);
 3956 
 3957     SpeculateCellOperand left(this, node-&gt;child1());
 3958     SpeculateCellOperand right(this, node-&gt;child2());
 3959     GPRReg leftGPR = left.gpr();
 3960     GPRReg rightGPR = right.gpr();
 3961 
 3962     speculateBigInt(leftChild, leftGPR);
 3963     speculateBigInt(rightChild, rightGPR);
 3964 
 3965     flushRegisters();
 3966     GPRFlushedCallResult result(this);
 3967     GPRReg resultGPR = result.gpr();
</pre>
<hr />
<pre>
 4267             } else
 4268                 speculationCheck(Overflow, JSValueRegs(), 0, check);
 4269 
 4270             int32Result(gprResult, node);
 4271             return;
 4272         }
 4273 
 4274         SpeculateInt32Operand op1(this, node-&gt;child1());
 4275         SpeculateInt32Operand op2(this, node-&gt;child2());
 4276         GPRTemporary result(this, Reuse, op1, op2);
 4277 
 4278         GPRReg gpr1 = op1.gpr();
 4279         GPRReg gpr2 = op2.gpr();
 4280         GPRReg gprResult = result.gpr();
 4281 
 4282         if (!shouldCheckOverflow(node-&gt;arithMode()))
 4283             m_jit.add32(gpr1, gpr2, gprResult);
 4284         else {
 4285             MacroAssembler::Jump check = m_jit.branchAdd32(MacroAssembler::Overflow, gpr1, gpr2, gprResult);
 4286 
<span class="line-modified"> 4287             if (gpr1 == gprResult)</span>


 4288                 speculationCheck(Overflow, JSValueRegs(), 0, check, SpeculationRecovery(SpeculativeAdd, gprResult, gpr2));
 4289             else if (gpr2 == gprResult)
 4290                 speculationCheck(Overflow, JSValueRegs(), 0, check, SpeculationRecovery(SpeculativeAdd, gprResult, gpr1));
 4291             else
 4292                 speculationCheck(Overflow, JSValueRegs(), 0, check);
 4293         }
 4294 
 4295         int32Result(gprResult, node);
 4296         return;
 4297     }
 4298 
 4299 #if USE(JSVALUE64)
 4300     case Int52RepUse: {
 4301         ASSERT(shouldCheckOverflow(node-&gt;arithMode()));
 4302         ASSERT(!shouldCheckNegativeZero(node-&gt;arithMode()));
 4303 
 4304         // Will we need an overflow check? If we can prove that neither input can be
 4305         // Int52 then the overflow check will not be necessary.
<span class="line-modified"> 4306         if (!m_state.forNode(node-&gt;child1()).couldBeType(SpecInt52Only)</span>
<span class="line-modified"> 4307             &amp;&amp; !m_state.forNode(node-&gt;child2()).couldBeType(SpecInt52Only)) {</span>
 4308             SpeculateWhicheverInt52Operand op1(this, node-&gt;child1());
 4309             SpeculateWhicheverInt52Operand op2(this, node-&gt;child2(), op1);
 4310             GPRTemporary result(this, Reuse, op1);
 4311             m_jit.add64(op1.gpr(), op2.gpr(), result.gpr());
 4312             int52Result(result.gpr(), node, op1.format());
 4313             return;
 4314         }
 4315 
 4316         SpeculateInt52Operand op1(this, node-&gt;child1());
 4317         SpeculateInt52Operand op2(this, node-&gt;child2());
 4318         GPRTemporary result(this);
 4319         m_jit.move(op1.gpr(), result.gpr());
 4320         speculationCheck(
 4321             Int52Overflow, JSValueRegs(), 0,
 4322             m_jit.branchAdd64(MacroAssembler::Overflow, op2.gpr(), result.gpr()));
 4323         int52Result(result.gpr(), node);
 4324         return;
 4325     }
 4326 #endif // USE(JSVALUE64)
 4327 
</pre>
<hr />
<pre>
 4472         SpeculateInt32Operand op2(this, node-&gt;child2());
 4473         GPRTemporary result(this);
 4474 
 4475         if (!shouldCheckOverflow(node-&gt;arithMode())) {
 4476             m_jit.move(op1.gpr(), result.gpr());
 4477             m_jit.sub32(op2.gpr(), result.gpr());
 4478         } else
 4479             speculationCheck(Overflow, JSValueRegs(), 0, m_jit.branchSub32(MacroAssembler::Overflow, op1.gpr(), op2.gpr(), result.gpr()));
 4480 
 4481         int32Result(result.gpr(), node);
 4482         return;
 4483     }
 4484 
 4485 #if USE(JSVALUE64)
 4486     case Int52RepUse: {
 4487         ASSERT(shouldCheckOverflow(node-&gt;arithMode()));
 4488         ASSERT(!shouldCheckNegativeZero(node-&gt;arithMode()));
 4489 
 4490         // Will we need an overflow check? If we can prove that neither input can be
 4491         // Int52 then the overflow check will not be necessary.
<span class="line-modified"> 4492         if (!m_state.forNode(node-&gt;child1()).couldBeType(SpecInt52Only)</span>
<span class="line-modified"> 4493             &amp;&amp; !m_state.forNode(node-&gt;child2()).couldBeType(SpecInt52Only)) {</span>
 4494             SpeculateWhicheverInt52Operand op1(this, node-&gt;child1());
 4495             SpeculateWhicheverInt52Operand op2(this, node-&gt;child2(), op1);
 4496             GPRTemporary result(this, Reuse, op1);
 4497             m_jit.move(op1.gpr(), result.gpr());
 4498             m_jit.sub64(op2.gpr(), result.gpr());
 4499             int52Result(result.gpr(), node, op1.format());
 4500             return;
 4501         }
 4502 
 4503         SpeculateInt52Operand op1(this, node-&gt;child1());
 4504         SpeculateInt52Operand op2(this, node-&gt;child2());
 4505         GPRTemporary result(this);
 4506         m_jit.move(op1.gpr(), result.gpr());
 4507         speculationCheck(
 4508             Int52Overflow, JSValueRegs(), 0,
 4509             m_jit.branchSub64(MacroAssembler::Overflow, op2.gpr(), result.gpr()));
 4510         int52Result(result.gpr(), node);
 4511         return;
 4512     }
 4513 #endif // USE(JSVALUE64)
</pre>
<hr />
<pre>
 4517         SpeculateDoubleOperand op2(this, node-&gt;child2());
 4518         FPRTemporary result(this, op1);
 4519 
 4520         FPRReg reg1 = op1.fpr();
 4521         FPRReg reg2 = op2.fpr();
 4522         m_jit.subDouble(reg1, reg2, result.fpr());
 4523 
 4524         doubleResult(result.fpr(), node);
 4525         return;
 4526     }
 4527 
 4528     default:
 4529         RELEASE_ASSERT_NOT_REACHED();
 4530         return;
 4531     }
 4532 }
 4533 
 4534 void SpeculativeJIT::compileValueNegate(Node* node)
 4535 {
 4536     CodeBlock* baselineCodeBlock = m_jit.graph().baselineCodeBlockFor(node-&gt;origin.semantic);
<span class="line-modified"> 4537     ArithProfile* arithProfile = baselineCodeBlock-&gt;arithProfileForBytecodeOffset(node-&gt;origin.semantic.bytecodeIndex);</span>
<span class="line-modified"> 4538     const Instruction* instruction = baselineCodeBlock-&gt;instructions().at(node-&gt;origin.semantic.bytecodeIndex).ptr();</span>
<span class="line-modified"> 4539     JITNegIC* negIC = m_jit.codeBlock()-&gt;addJITNegIC(arithProfile, instruction);</span>
 4540     auto repatchingFunction = operationArithNegateOptimize;
 4541     auto nonRepatchingFunction = operationArithNegate;
 4542     bool needsScratchGPRReg = true;
 4543     compileMathIC(node, negIC, needsScratchGPRReg, repatchingFunction, nonRepatchingFunction);
 4544 }
 4545 
 4546 void SpeculativeJIT::compileArithNegate(Node* node)
 4547 {
 4548     switch (node-&gt;child1().useKind()) {
 4549     case Int32Use: {
 4550         SpeculateInt32Operand op1(this, node-&gt;child1());
 4551         GPRTemporary result(this);
 4552 
 4553         m_jit.move(op1.gpr(), result.gpr());
 4554 
 4555         // Note: there is no notion of being not used as a number, but someone
 4556         // caring about negative zero.
 4557 
 4558         if (!shouldCheckOverflow(node-&gt;arithMode()))
 4559             m_jit.neg32(result.gpr());
 4560         else if (!shouldCheckNegativeZero(node-&gt;arithMode()))
 4561             speculationCheck(Overflow, JSValueRegs(), 0, m_jit.branchNeg32(MacroAssembler::Overflow, result.gpr()));
 4562         else {
 4563             speculationCheck(Overflow, JSValueRegs(), 0, m_jit.branchTest32(MacroAssembler::Zero, result.gpr(), TrustedImm32(0x7fffffff)));
 4564             m_jit.neg32(result.gpr());
 4565         }
 4566 
 4567         int32Result(result.gpr(), node);
 4568         return;
 4569     }
 4570 
 4571 #if USE(JSVALUE64)
 4572     case Int52RepUse: {
 4573         ASSERT(shouldCheckOverflow(node-&gt;arithMode()));
 4574 
<span class="line-modified"> 4575         if (!m_state.forNode(node-&gt;child1()).couldBeType(SpecInt52Only)) {</span>
 4576             SpeculateWhicheverInt52Operand op1(this, node-&gt;child1());
 4577             GPRTemporary result(this);
 4578             GPRReg op1GPR = op1.gpr();
 4579             GPRReg resultGPR = result.gpr();
 4580             m_jit.move(op1GPR, resultGPR);
 4581             m_jit.neg64(resultGPR);
 4582             if (shouldCheckNegativeZero(node-&gt;arithMode())) {
 4583                 speculationCheck(
 4584                     NegativeZero, JSValueRegs(), 0,
 4585                     m_jit.branchTest64(MacroAssembler::Zero, resultGPR));
 4586             }
 4587             int52Result(resultGPR, node, op1.format());
 4588             return;
 4589         }
 4590 
 4591         SpeculateInt52Operand op1(this, node-&gt;child1());
 4592         GPRTemporary result(this);
 4593         GPRReg op1GPR = op1.gpr();
 4594         GPRReg resultGPR = result.gpr();
 4595         m_jit.move(op1GPR, resultGPR);
</pre>
<hr />
<pre>
 4740         JSValueRegs rightRegs = right.jsValueRegs();
 4741 
 4742         flushRegisters();
 4743         JSValueRegsFlushedCallResult result(this);
 4744         JSValueRegs resultRegs = result.regs();
 4745         callOperation(operationValueMul, resultRegs, leftRegs, rightRegs);
 4746         m_jit.exceptionCheck();
 4747 
 4748         jsValueResult(resultRegs, node);
 4749         return;
 4750     }
 4751 
 4752     bool needsScratchGPRReg = true;
 4753 #if USE(JSVALUE64)
 4754     bool needsScratchFPRReg = false;
 4755 #else
 4756     bool needsScratchFPRReg = true;
 4757 #endif
 4758 
 4759     CodeBlock* baselineCodeBlock = m_jit.graph().baselineCodeBlockFor(node-&gt;origin.semantic);
<span class="line-modified"> 4760     ArithProfile* arithProfile = baselineCodeBlock-&gt;arithProfileForBytecodeOffset(node-&gt;origin.semantic.bytecodeIndex);</span>
<span class="line-modified"> 4761     const Instruction* instruction = baselineCodeBlock-&gt;instructions().at(node-&gt;origin.semantic.bytecodeIndex).ptr();</span>
<span class="line-modified"> 4762     JITMulIC* mulIC = m_jit.codeBlock()-&gt;addJITMulIC(arithProfile, instruction);</span>
 4763     auto repatchingFunction = operationValueMulOptimize;
 4764     auto nonRepatchingFunction = operationValueMul;
 4765 
 4766     compileMathIC(node, mulIC, needsScratchGPRReg, needsScratchFPRReg, repatchingFunction, nonRepatchingFunction);
 4767 }
 4768 
 4769 void SpeculativeJIT::compileArithMul(Node* node)
 4770 {
 4771     switch (node-&gt;binaryUseKind()) {
 4772     case Int32Use: {
 4773         if (node-&gt;child2()-&gt;isInt32Constant()) {
 4774             SpeculateInt32Operand op1(this, node-&gt;child1());
 4775             GPRTemporary result(this);
 4776 
 4777             int32_t imm = node-&gt;child2()-&gt;asInt32();
 4778             GPRReg op1GPR = op1.gpr();
 4779             GPRReg resultGPR = result.gpr();
 4780 
 4781             if (!shouldCheckOverflow(node-&gt;arithMode()))
 4782                 m_jit.mul32(Imm32(imm), op1GPR, resultGPR);
</pre>
<hr />
<pre>
 5178 void SpeculativeJIT::compileArithFRound(Node* node)
 5179 {
 5180     if (node-&gt;child1().useKind() == DoubleRepUse) {
 5181         SpeculateDoubleOperand op1(this, node-&gt;child1());
 5182         FPRTemporary result(this, op1);
 5183         m_jit.convertDoubleToFloat(op1.fpr(), result.fpr());
 5184         m_jit.convertFloatToDouble(result.fpr(), result.fpr());
 5185         doubleResult(result.fpr(), node);
 5186         return;
 5187     }
 5188 
 5189     JSValueOperand op1(this, node-&gt;child1());
 5190     JSValueRegs op1Regs = op1.jsValueRegs();
 5191     flushRegisters();
 5192     FPRResult result(this);
 5193     callOperation(operationArithFRound, result.fpr(), op1Regs);
 5194     m_jit.exceptionCheck();
 5195     doubleResult(result.fpr(), node);
 5196 }
 5197 






































 5198 void SpeculativeJIT::compileArithMod(Node* node)
 5199 {
 5200     switch (node-&gt;binaryUseKind()) {
 5201     case Int32Use: {
 5202         // In the fast path, the dividend value could be the final result
 5203         // (in case of |dividend| &lt; |divisor|), so we speculate it as strict int32.
 5204         SpeculateStrictInt32Operand op1(this, node-&gt;child1());
 5205 
 5206         if (node-&gt;child2()-&gt;isInt32Constant()) {
 5207             int32_t divisor = node-&gt;child2()-&gt;asInt32();
 5208             if (divisor &gt; 1 &amp;&amp; hasOneBitSet(divisor)) {
 5209                 unsigned logarithm = WTF::fastLog2(static_cast&lt;uint32_t&gt;(divisor));
 5210                 GPRReg dividendGPR = op1.gpr();
 5211                 GPRTemporary result(this);
 5212                 GPRReg resultGPR = result.gpr();
 5213 
 5214                 // This is what LLVM generates. It&#39;s pretty crazy. Here&#39;s my
 5215                 // attempt at understanding it.
 5216 
 5217                 // First, compute either divisor - 1, or 0, depending on whether
</pre>
<hr />
<pre>
 5706     MacroAssembler::JumpList skipFastPath;
 5707     skipFastPath.append(assembler.branch32(MacroAssembler::Above, yOperand, MacroAssembler::TrustedImm32(maxExponentForIntegerMathPow)));
 5708 
 5709     static const double oneConstant = 1.0;
 5710     assembler.loadDouble(MacroAssembler::TrustedImmPtr(&amp;oneConstant), result);
 5711 
 5712     MacroAssembler::Label startLoop(assembler.label());
 5713     MacroAssembler::Jump exponentIsEven = assembler.branchTest32(MacroAssembler::Zero, yOperand, MacroAssembler::TrustedImm32(1));
 5714     assembler.mulDouble(xOperand, result);
 5715     exponentIsEven.link(&amp;assembler);
 5716     assembler.mulDouble(xOperand, xOperand);
 5717     assembler.rshift32(MacroAssembler::TrustedImm32(1), yOperand);
 5718     assembler.branchTest32(MacroAssembler::NonZero, yOperand).linkTo(startLoop, &amp;assembler);
 5719 
 5720     MacroAssembler::Jump skipSlowPath = assembler.jump();
 5721     skipFastPath.link(&amp;assembler);
 5722 
 5723     return skipSlowPath;
 5724 }
 5725 









































 5726 void SpeculativeJIT::compileArithPow(Node* node)
 5727 {
 5728     if (node-&gt;child2().useKind() == Int32Use) {
 5729         SpeculateDoubleOperand xOperand(this, node-&gt;child1());
 5730         SpeculateInt32Operand yOperand(this, node-&gt;child2());
 5731         FPRReg xOperandfpr = xOperand.fpr();
 5732         GPRReg yOperandGpr = yOperand.gpr();
 5733         FPRTemporary yOperandfpr(this);
 5734 
 5735         flushRegisters();
 5736 
 5737         FPRResult result(this);
 5738         FPRReg resultFpr = result.fpr();
 5739 
 5740         FPRTemporary xOperandCopy(this);
 5741         FPRReg xOperandCopyFpr = xOperandCopy.fpr();
 5742         m_jit.moveDouble(xOperandfpr, xOperandCopyFpr);
 5743 
 5744         GPRTemporary counter(this);
 5745         GPRReg counterGpr = counter.gpr();
</pre>
<hr />
<pre>
 6553 
 6554     GPRFlushedCallResult result(this);
 6555     GPRReg resultGPR = result.gpr();
 6556     callOperation(operationSameValue, resultGPR, arg1Regs, arg2Regs);
 6557     m_jit.exceptionCheck();
 6558 
 6559     unblessedBooleanResult(resultGPR, node, UseChildrenCalledExplicitly);
 6560 }
 6561 
 6562 void SpeculativeJIT::compileStringZeroLength(Node* node)
 6563 {
 6564     SpeculateCellOperand str(this, node-&gt;child1());
 6565     GPRReg strGPR = str.gpr();
 6566 
 6567     // Make sure that this is a string.
 6568     speculateString(node-&gt;child1(), strGPR);
 6569 
 6570     GPRTemporary eq(this);
 6571     GPRReg eqGPR = eq.gpr();
 6572 
<span class="line-modified"> 6573     m_jit.move(TrustedImmPtr::weakPointer(m_jit.graph(), jsEmptyString(m_jit.vm())), eqGPR);</span>
 6574     m_jit.comparePtr(CCallHelpers::Equal, strGPR, eqGPR, eqGPR);
 6575     unblessedBooleanResult(eqGPR, node);
 6576 }
 6577 
 6578 void SpeculativeJIT::compileLogicalNotStringOrOther(Node* node)
 6579 {
 6580     JSValueOperand value(this, node-&gt;child1(), ManualOperandSpeculation);
 6581     GPRTemporary temp(this);
 6582     JSValueRegs valueRegs = value.jsValueRegs();
 6583     GPRReg tempGPR = temp.gpr();
 6584 
 6585     JITCompiler::Jump notCell = m_jit.branchIfNotCell(valueRegs);
 6586     GPRReg cellGPR = valueRegs.payloadGPR();
 6587     DFG_TYPE_CHECK(
 6588         valueRegs, node-&gt;child1(), (~SpecCellCheck) | SpecString, m_jit.branchIfNotString(cellGPR));
 6589 
<span class="line-modified"> 6590     m_jit.move(TrustedImmPtr::weakPointer(m_jit.graph(), jsEmptyString(m_jit.vm())), tempGPR);</span>
 6591     m_jit.comparePtr(CCallHelpers::Equal, cellGPR, tempGPR, tempGPR);
 6592     auto done = m_jit.jump();
 6593 
 6594     notCell.link(&amp;m_jit);
 6595     DFG_TYPE_CHECK(
 6596         valueRegs, node-&gt;child1(), SpecCellCheck | SpecOther, m_jit.branchIfNotOther(valueRegs, tempGPR));
 6597     m_jit.move(TrustedImm32(1), tempGPR);
 6598 
 6599     done.link(&amp;m_jit);
 6600     unblessedBooleanResult(tempGPR, node);
 6601 
 6602 }
 6603 
 6604 void SpeculativeJIT::emitStringBranch(Edge nodeUse, BasicBlock* taken, BasicBlock* notTaken)
 6605 {
 6606     SpeculateCellOperand str(this, nodeUse);
 6607 
 6608     GPRReg strGPR = str.gpr();
 6609 
 6610     speculateString(nodeUse, strGPR);
 6611 
<span class="line-modified"> 6612     branchPtr(CCallHelpers::Equal, strGPR, TrustedImmPtr::weakPointer(m_jit.graph(), jsEmptyString(m_jit.vm())), notTaken);</span>
 6613     jump(taken);
 6614 
 6615     noResult(m_currentNode);
 6616 }
 6617 
 6618 void SpeculativeJIT::emitStringOrOtherBranch(Edge nodeUse, BasicBlock* taken, BasicBlock* notTaken)
 6619 {
 6620     JSValueOperand value(this, nodeUse, ManualOperandSpeculation);
 6621     GPRTemporary temp(this);
 6622     JSValueRegs valueRegs = value.jsValueRegs();
 6623     GPRReg tempGPR = temp.gpr();
 6624 
 6625     JITCompiler::Jump notCell = m_jit.branchIfNotCell(valueRegs);
 6626     GPRReg cellGPR = valueRegs.payloadGPR();
 6627     DFG_TYPE_CHECK(valueRegs, nodeUse, (~SpecCellCheck) | SpecString, m_jit.branchIfNotString(cellGPR));
 6628 
<span class="line-modified"> 6629     branchPtr(CCallHelpers::Equal, cellGPR, TrustedImmPtr::weakPointer(m_jit.graph(), jsEmptyString(m_jit.vm())), notTaken);</span>
 6630     jump(taken, ForceJump);
 6631 
 6632     notCell.link(&amp;m_jit);
 6633     DFG_TYPE_CHECK(
 6634         valueRegs, nodeUse, SpecCellCheck | SpecOther, m_jit.branchIfNotOther(valueRegs, tempGPR));
 6635     jump(notTaken);
 6636     noResult(m_currentNode);
 6637 }
 6638 
 6639 void SpeculativeJIT::compileConstantStoragePointer(Node* node)
 6640 {
 6641     GPRTemporary storage(this);
 6642     GPRReg storageGPR = storage.gpr();
 6643     m_jit.move(TrustedImmPtr(node-&gt;storagePointer()), storageGPR);
 6644     storageResult(storageGPR, node);
 6645 }
 6646 
<span class="line-modified"> 6647 void SpeculativeJIT::cageTypedArrayStorage(GPRReg storageReg)</span>
 6648 {









 6649 #if GIGACAGE_ENABLED
<span class="line-modified"> 6650     if (!Gigacage::shouldBeEnabled())</span>


 6651         return;

 6652 
 6653     if (Gigacage::canPrimitiveGigacageBeDisabled()) {
<span class="line-modified"> 6654         if (m_jit.vm()-&gt;primitiveGigacageEnabled().isStillValid())</span>
<span class="line-modified"> 6655             m_jit.graph().watchpoints().addLazily(m_jit.vm()-&gt;primitiveGigacageEnabled());</span>
<span class="line-modified"> 6656         else</span>


 6657             return;

 6658     }
 6659 
<span class="line-modified"> 6660     m_jit.cage(Gigacage::Primitive, storageReg);</span>
<span class="line-removed"> 6661 #else</span>
<span class="line-removed"> 6662     UNUSED_PARAM(storageReg);</span>
 6663 #endif

 6664 }
 6665 
 6666 void SpeculativeJIT::compileGetIndexedPropertyStorage(Node* node)
 6667 {
 6668     SpeculateCellOperand base(this, node-&gt;child1());
 6669     GPRReg baseReg = base.gpr();
 6670 
 6671     GPRTemporary storage(this);
 6672     GPRReg storageReg = storage.gpr();
 6673 
 6674     switch (node-&gt;arrayMode().type()) {
 6675     case Array::String:
 6676         m_jit.loadPtr(MacroAssembler::Address(baseReg, JSString::offsetOfValue()), storageReg);
 6677 
 6678         addSlowPathGenerator(
 6679             slowPathCall(
 6680                 m_jit.branchIfRopeStringImpl(storageReg),
 6681                 this, operationResolveRope, storageReg, baseReg));
 6682 
 6683         m_jit.loadPtr(MacroAssembler::Address(storageReg, StringImpl::dataOffset()), storageReg);
 6684         break;
 6685 
<span class="line-modified"> 6686     default:</span>
 6687         auto typedArrayType = node-&gt;arrayMode().typedArrayType();
 6688         ASSERT_UNUSED(typedArrayType, isTypedView(typedArrayType));
 6689 
 6690         m_jit.loadPtr(JITCompiler::Address(baseReg, JSArrayBufferView::offsetOfVector()), storageReg);
<span class="line-modified"> 6691         cageTypedArrayStorage(storageReg);</span>
 6692         break;
 6693     }

 6694 
 6695     storageResult(storageReg, node);
 6696 }
 6697 
 6698 void SpeculativeJIT::compileGetTypedArrayByteOffset(Node* node)
 6699 {
 6700     SpeculateCellOperand base(this, node-&gt;child1());
 6701     GPRTemporary vector(this);
 6702     GPRTemporary data(this);
 6703 
 6704     GPRReg baseGPR = base.gpr();
 6705     GPRReg vectorGPR = vector.gpr();
 6706     GPRReg dataGPR = data.gpr();
 6707     ASSERT(baseGPR != vectorGPR);
 6708     ASSERT(baseGPR != dataGPR);
 6709     ASSERT(vectorGPR != dataGPR);
 6710 
 6711     GPRReg arrayBufferGPR = dataGPR;
 6712 
 6713     JITCompiler::Jump emptyByteOffset = m_jit.branch32(
 6714         MacroAssembler::NotEqual,
 6715         MacroAssembler::Address(baseGPR, JSArrayBufferView::offsetOfMode()),
 6716         TrustedImm32(WastefulTypedArray));
 6717 
 6718     m_jit.loadPtr(MacroAssembler::Address(baseGPR, JSArrayBufferView::offsetOfVector()), vectorGPR);



 6719     JITCompiler::Jump nullVector = m_jit.branchTestPtr(JITCompiler::Zero, vectorGPR);
 6720 
 6721     m_jit.loadPtr(MacroAssembler::Address(baseGPR, JSObject::butterflyOffset()), dataGPR);
<span class="line-modified"> 6722     m_jit.cage(Gigacage::JSValue, dataGPR);</span>
 6723 
<span class="line-modified"> 6724     cageTypedArrayStorage(vectorGPR);</span>
 6725 
 6726     m_jit.loadPtr(MacroAssembler::Address(dataGPR, Butterfly::offsetOfArrayBuffer()), arrayBufferGPR);
 6727     // FIXME: This needs caging.
 6728     // https://bugs.webkit.org/show_bug.cgi?id=175515
 6729     m_jit.loadPtr(MacroAssembler::Address(arrayBufferGPR, ArrayBuffer::offsetOfData()), dataGPR);




 6730     m_jit.subPtr(dataGPR, vectorGPR);
 6731 
 6732     JITCompiler::Jump done = m_jit.jump();
 6733 
 6734     emptyByteOffset.link(&amp;m_jit);
 6735     m_jit.move(TrustedImmPtr(nullptr), vectorGPR);
 6736 
 6737     done.link(&amp;m_jit);
 6738     nullVector.link(&amp;m_jit);
 6739 
 6740     int32Result(vectorGPR, node);
 6741 }
 6742 
 6743 void SpeculativeJIT::compileGetByValOnDirectArguments(Node* node)
 6744 {
 6745     SpeculateCellOperand base(this, m_graph.varArgChild(node, 0));
 6746     SpeculateStrictInt32Operand property(this, m_graph.varArgChild(node, 1));
 6747     JSValueRegsTemporary result(this);
 6748     GPRTemporary scratch(this);
 6749 
</pre>
<hr />
<pre>
 6866 {
 6867     SpeculateCellOperand function(this, node-&gt;child1());
 6868     GPRTemporary result(this, Reuse, function);
 6869     m_jit.loadPtr(JITCompiler::Address(function.gpr(), JSFunction::offsetOfScopeChain()), result.gpr());
 6870     cellResult(result.gpr(), node);
 6871 }
 6872 
 6873 void SpeculativeJIT::compileSkipScope(Node* node)
 6874 {
 6875     SpeculateCellOperand scope(this, node-&gt;child1());
 6876     GPRTemporary result(this, Reuse, scope);
 6877     m_jit.loadPtr(JITCompiler::Address(scope.gpr(), JSScope::offsetOfNext()), result.gpr());
 6878     cellResult(result.gpr(), node);
 6879 }
 6880 
 6881 void SpeculativeJIT::compileGetGlobalObject(Node* node)
 6882 {
 6883     SpeculateCellOperand object(this, node-&gt;child1());
 6884     GPRTemporary result(this);
 6885     GPRTemporary scratch(this);
<span class="line-modified"> 6886     m_jit.emitLoadStructure(*m_jit.vm(), object.gpr(), result.gpr(), scratch.gpr());</span>
 6887     m_jit.loadPtr(JITCompiler::Address(result.gpr(), Structure::globalObjectOffset()), result.gpr());
 6888     cellResult(result.gpr(), node);
 6889 }
 6890 
 6891 void SpeculativeJIT::compileGetGlobalThis(Node* node)
 6892 {
 6893     GPRTemporary result(this);
 6894     GPRReg resultGPR = result.gpr();
 6895     auto* globalObject = m_jit.graph().globalObjectFor(node-&gt;origin.semantic);
 6896     m_jit.loadPtr(globalObject-&gt;addressOfGlobalThis(), resultGPR);
 6897     cellResult(resultGPR, node);
 6898 }
 6899 











 6900 void SpeculativeJIT::compileGetArrayLength(Node* node)
 6901 {
 6902     switch (node-&gt;arrayMode().type()) {
 6903     case Array::Undecided:
 6904     case Array::Int32:
 6905     case Array::Double:
 6906     case Array::Contiguous: {
 6907         StorageOperand storage(this, node-&gt;child2());
 6908         GPRTemporary result(this, Reuse, storage);
 6909         GPRReg storageReg = storage.gpr();
 6910         GPRReg resultReg = result.gpr();
 6911         m_jit.load32(MacroAssembler::Address(storageReg, Butterfly::offsetOfPublicLength()), resultReg);
 6912 
 6913         int32Result(resultReg, node);
 6914         break;
 6915     }
 6916     case Array::ArrayStorage:
 6917     case Array::SlowPutArrayStorage: {
 6918         StorageOperand storage(this, node-&gt;child2());
 6919         GPRTemporary result(this, Reuse, storage);
 6920         GPRReg storageReg = storage.gpr();
 6921         GPRReg resultReg = result.gpr();
 6922         m_jit.load32(MacroAssembler::Address(storageReg, Butterfly::offsetOfPublicLength()), resultReg);
 6923 
 6924         speculationCheck(Uncountable, JSValueRegs(), 0, m_jit.branch32(MacroAssembler::LessThan, resultReg, MacroAssembler::TrustedImm32(0)));
 6925 
 6926         int32Result(resultReg, node);
 6927         break;
 6928     }
 6929     case Array::String: {
 6930         SpeculateCellOperand base(this, node-&gt;child1());
 6931         GPRTemporary result(this, Reuse, base);
 6932         GPRTemporary temp(this);
 6933         GPRReg baseGPR = base.gpr();
 6934         GPRReg resultGPR = result.gpr();
 6935         GPRReg tempGPR = temp.gpr();
 6936 


 6937         m_jit.loadPtr(MacroAssembler::Address(baseGPR, JSString::offsetOfValue()), tempGPR);
<span class="line-modified"> 6938         auto isRope = m_jit.branchIfRopeStringImpl(tempGPR);</span>


 6939         m_jit.load32(MacroAssembler::Address(tempGPR, StringImpl::lengthMemoryOffset()), resultGPR);
<span class="line-modified"> 6940         auto done = m_jit.jump();</span>

 6941 
<span class="line-modified"> 6942         isRope.link(&amp;m_jit);</span>
<span class="line-modified"> 6943         m_jit.load32(CCallHelpers::Address(baseGPR, JSRopeString::offsetOfLength()), resultGPR);</span>
 6944 
<span class="line-modified"> 6945         done.link(&amp;m_jit);</span>

 6946         int32Result(resultGPR, node);
 6947         break;
 6948     }
 6949     case Array::DirectArguments: {
 6950         SpeculateCellOperand base(this, node-&gt;child1());
 6951         GPRTemporary result(this, Reuse, base);
 6952 
 6953         GPRReg baseReg = base.gpr();
 6954         GPRReg resultReg = result.gpr();
 6955 
 6956         if (!m_compileOkay)
 6957             return;
 6958 
 6959         ASSERT(ArrayMode(Array::DirectArguments, Array::Read).alreadyChecked(m_jit.graph(), node, m_state.forNode(node-&gt;child1())));
 6960 
 6961         speculationCheck(
 6962             ExoticObjectMode, JSValueSource(), 0,
 6963             m_jit.branchTestPtr(
 6964                 MacroAssembler::NonZero,
 6965                 MacroAssembler::Address(baseReg, DirectArguments::offsetOfMappedArguments())));
</pre>
<hr />
<pre>
 7020     speculateString(node-&gt;child1(), stringGPR);
 7021     speculateStringIdentAndLoadStorage(node-&gt;child1(), stringGPR, storageGPR);
 7022 
 7023     UniquedStringImpl* uid = node-&gt;uidOperand();
 7024     speculationCheck(
 7025         BadIdent, JSValueSource(), nullptr,
 7026         m_jit.branchPtr(JITCompiler::NotEqual, storageGPR, TrustedImmPtr(uid)));
 7027     noResult(node);
 7028 }
 7029 
 7030 template &lt;typename ClassType&gt;
 7031 void SpeculativeJIT::compileNewFunctionCommon(GPRReg resultGPR, RegisteredStructure structure, GPRReg scratch1GPR, GPRReg scratch2GPR, GPRReg scopeGPR, MacroAssembler::JumpList&amp; slowPath, size_t size, FunctionExecutable* executable)
 7032 {
 7033     auto butterfly = TrustedImmPtr(nullptr);
 7034     emitAllocateJSObjectWithKnownSize&lt;ClassType&gt;(resultGPR, TrustedImmPtr(structure), butterfly, scratch1GPR, scratch2GPR, slowPath, size);
 7035 
 7036     m_jit.storePtr(scopeGPR, JITCompiler::Address(resultGPR, JSFunction::offsetOfScopeChain()));
 7037     m_jit.storePtr(TrustedImmPtr::weakPointer(m_jit.graph(), executable), JITCompiler::Address(resultGPR, JSFunction::offsetOfExecutable()));
 7038     m_jit.storePtr(TrustedImmPtr(nullptr), JITCompiler::Address(resultGPR, JSFunction::offsetOfRareData()));
 7039 
<span class="line-modified"> 7040     m_jit.mutatorFence(*m_jit.vm());</span>





















 7041 }
 7042 
 7043 void SpeculativeJIT::compileNewFunction(Node* node)
 7044 {
 7045     NodeType nodeType = node-&gt;op();
 7046     ASSERT(nodeType == NewFunction || nodeType == NewGeneratorFunction || nodeType == NewAsyncFunction || nodeType == NewAsyncGeneratorFunction);
 7047 
 7048     SpeculateCellOperand scope(this, node-&gt;child1());
 7049     GPRReg scopeGPR = scope.gpr();
 7050 
 7051     FunctionExecutable* executable = node-&gt;castOperand&lt;FunctionExecutable*&gt;();
 7052 
<span class="line-modified"> 7053     if (executable-&gt;singletonFunction()-&gt;isStillValid()) {</span>
 7054         GPRFlushedCallResult result(this);
 7055         GPRReg resultGPR = result.gpr();
 7056 
 7057         flushRegisters();
 7058 
 7059         if (nodeType == NewGeneratorFunction)
 7060             callOperation(operationNewGeneratorFunction, resultGPR, scopeGPR, executable);
 7061         else if (nodeType == NewAsyncFunction)
 7062             callOperation(operationNewAsyncFunction, resultGPR, scopeGPR, executable);
 7063         else if (nodeType == NewAsyncGeneratorFunction)
 7064             callOperation(operationNewAsyncGeneratorFunction, resultGPR, scopeGPR, executable);
 7065         else
 7066             callOperation(operationNewFunction, resultGPR, scopeGPR, executable);
 7067         m_jit.exceptionCheck();
 7068         cellResult(resultGPR, node);
 7069         return;
 7070     }
 7071 
 7072     RegisteredStructure structure = m_jit.graph().registerStructure(
 7073         [&amp;] () {
</pre>
<hr />
<pre>
 7178 
 7179     speculationCheck(
 7180         VarargsOverflow, JSValueSource(), Edge(), m_jit.branch32(
 7181             MacroAssembler::Above,
 7182             argCountIncludingThisGPR,
 7183             TrustedImm32(data-&gt;limit)));
 7184 
 7185     m_jit.store32(argCountIncludingThisGPR, JITCompiler::payloadFor(data-&gt;machineCount));
 7186 
 7187     callOperation(operationLoadVarargs, data-&gt;machineStart.offset(), argumentsRegs, data-&gt;offset, GPRInfo::returnValueGPR, data-&gt;mandatoryMinimum);
 7188     m_jit.exceptionCheck();
 7189 
 7190     noResult(node);
 7191 }
 7192 
 7193 void SpeculativeJIT::compileForwardVarargs(Node* node)
 7194 {
 7195     LoadVarargsData* data = node-&gt;loadVarargsData();
 7196     InlineCallFrame* inlineCallFrame;
 7197     if (node-&gt;child1())
<span class="line-modified"> 7198         inlineCallFrame = node-&gt;child1()-&gt;origin.semantic.inlineCallFrame;</span>
 7199     else
<span class="line-modified"> 7200         inlineCallFrame = node-&gt;origin.semantic.inlineCallFrame;</span>
 7201 
 7202     GPRTemporary length(this);
 7203     JSValueRegsTemporary temp(this);
 7204     GPRReg lengthGPR = length.gpr();
 7205     JSValueRegs tempRegs = temp.regs();
 7206 
 7207     emitGetLength(inlineCallFrame, lengthGPR, /* includeThis = */ true);
 7208     if (data-&gt;offset)
 7209         m_jit.sub32(TrustedImm32(data-&gt;offset), lengthGPR);
 7210 
 7211     speculationCheck(
 7212         VarargsOverflow, JSValueSource(), Edge(), m_jit.branch32(
 7213             MacroAssembler::Above,
 7214             lengthGPR, TrustedImm32(data-&gt;limit)));
 7215 
 7216     m_jit.store32(lengthGPR, JITCompiler::payloadFor(data-&gt;machineCount));
 7217 
 7218     VirtualRegister sourceStart = JITCompiler::argumentsStart(inlineCallFrame) + data-&gt;offset;
 7219     VirtualRegister targetStart = data-&gt;machineStart;
 7220 
</pre>
<hr />
<pre>
 7250             GPRInfo::callFrameRegister, lengthGPR, JITCompiler::TimesEight,
 7251             targetStart.offset() * sizeof(EncodedJSValue)));
 7252     m_jit.branchTest32(JITCompiler::NonZero, lengthGPR).linkTo(loop, &amp;m_jit);
 7253 
 7254     done.link(&amp;m_jit);
 7255 
 7256     noResult(node);
 7257 }
 7258 
 7259 void SpeculativeJIT::compileCreateActivation(Node* node)
 7260 {
 7261     SymbolTable* table = node-&gt;castOperand&lt;SymbolTable*&gt;();
 7262     RegisteredStructure structure = m_jit.graph().registerStructure(m_jit.graph().globalObjectFor(
 7263         node-&gt;origin.semantic)-&gt;activationStructure());
 7264 
 7265     SpeculateCellOperand scope(this, node-&gt;child1());
 7266     GPRReg scopeGPR = scope.gpr();
 7267     JSValue initializationValue = node-&gt;initializationValueForActivation();
 7268     ASSERT(initializationValue == jsUndefined() || initializationValue == jsTDZValue());
 7269 
<span class="line-modified"> 7270     if (table-&gt;singletonScope()-&gt;isStillValid()) {</span>
 7271         GPRFlushedCallResult result(this);
 7272         GPRReg resultGPR = result.gpr();
 7273 
 7274 #if USE(JSVALUE32_64)
 7275         JSValueRegsTemporary initialization(this);
 7276         JSValueRegs initializationRegs = initialization.regs();
 7277         m_jit.moveTrustedValue(initializationValue, initializationRegs);
 7278 #endif
 7279 
 7280         flushRegisters();
 7281 
 7282 #if USE(JSVALUE64)
 7283         callOperation(operationCreateActivationDirect,
 7284             resultGPR, structure, scopeGPR, table, TrustedImm64(JSValue::encode(initializationValue)));
 7285 #else
 7286         callOperation(operationCreateActivationDirect,
 7287             resultGPR, structure, scopeGPR, table, initializationRegs);
 7288 #endif
 7289         m_jit.exceptionCheck();
 7290         cellResult(resultGPR, node);
</pre>
<hr />
<pre>
 7308     auto butterfly = TrustedImmPtr(nullptr);
 7309     emitAllocateJSObjectWithKnownSize&lt;JSLexicalEnvironment&gt;(
 7310         resultGPR, TrustedImmPtr(structure), butterfly, scratch1GPR, scratch2GPR,
 7311         slowPath, JSLexicalEnvironment::allocationSize(table));
 7312 
 7313     // Don&#39;t need a memory barriers since we just fast-created the activation, so the
 7314     // activation must be young.
 7315     m_jit.storePtr(scopeGPR, JITCompiler::Address(resultGPR, JSScope::offsetOfNext()));
 7316     m_jit.storePtr(
 7317         TrustedImmPtr(node-&gt;cellOperand()),
 7318         JITCompiler::Address(resultGPR, JSLexicalEnvironment::offsetOfSymbolTable()));
 7319 
 7320     // Must initialize all members to undefined or the TDZ empty value.
 7321     for (unsigned i = 0; i &lt; table-&gt;scopeSize(); ++i) {
 7322         m_jit.storeTrustedValue(
 7323             initializationValue,
 7324             JITCompiler::Address(
 7325                 resultGPR, JSLexicalEnvironment::offsetOfVariable(ScopeOffset(i))));
 7326     }
 7327 
<span class="line-modified"> 7328     m_jit.mutatorFence(*m_jit.vm());</span>
 7329 
 7330 #if USE(JSVALUE64)
 7331     addSlowPathGenerator(
 7332         slowPathCall(
 7333             slowPath, this, operationCreateActivationDirect, resultGPR, structure, scopeGPR, table, TrustedImm64(JSValue::encode(initializationValue))));
 7334 #else
 7335     addSlowPathGenerator(
 7336         slowPathCall(
 7337             slowPath, this, operationCreateActivationDirect, resultGPR, structure, scopeGPR, table, initializationRegs));
 7338 #endif
 7339 
 7340     cellResult(resultGPR, node);
 7341 }
 7342 
 7343 void SpeculativeJIT::compileCreateDirectArguments(Node* node)
 7344 {
 7345     // FIXME: A more effective way of dealing with the argument count and callee is to have
 7346     // them be explicit arguments to this node.
 7347     // https://bugs.webkit.org/show_bug.cgi?id=142207
 7348 
 7349     GPRTemporary result(this);
 7350     GPRTemporary scratch1(this);
 7351     GPRTemporary scratch2(this);
 7352     GPRTemporary length;
 7353     GPRReg resultGPR = result.gpr();
 7354     GPRReg scratch1GPR = scratch1.gpr();
 7355     GPRReg scratch2GPR = scratch2.gpr();
 7356     GPRReg lengthGPR = InvalidGPRReg;
 7357     JSValueRegs valueRegs = JSValueRegs::withTwoAvailableRegs(scratch1GPR, scratch2GPR);
 7358 
 7359     unsigned minCapacity = m_jit.graph().baselineCodeBlockFor(node-&gt;origin.semantic)-&gt;numParameters() - 1;
 7360 
 7361     unsigned knownLength;
 7362     bool lengthIsKnown; // if false, lengthGPR will have the length.
<span class="line-modified"> 7363     if (node-&gt;origin.semantic.inlineCallFrame</span>
<span class="line-modified"> 7364         &amp;&amp; !node-&gt;origin.semantic.inlineCallFrame-&gt;isVarargs()) {</span>
<span class="line-modified"> 7365         knownLength = node-&gt;origin.semantic.inlineCallFrame-&gt;argumentCountIncludingThis - 1;</span>

 7366         lengthIsKnown = true;
 7367     } else {
 7368         knownLength = UINT_MAX;
 7369         lengthIsKnown = false;
 7370 
 7371         GPRTemporary realLength(this);
 7372         length.adopt(realLength);
 7373         lengthGPR = length.gpr();
 7374 
 7375         VirtualRegister argumentCountRegister = m_jit.argumentCount(node-&gt;origin.semantic);
 7376         m_jit.load32(JITCompiler::payloadFor(argumentCountRegister), lengthGPR);
 7377         m_jit.sub32(TrustedImm32(1), lengthGPR);
 7378     }
 7379 
 7380     RegisteredStructure structure =
 7381         m_jit.graph().registerStructure(m_jit.graph().globalObjectFor(node-&gt;origin.semantic)-&gt;directArgumentsStructure());
 7382 
 7383     // Use a different strategy for allocating the object depending on whether we know its
 7384     // size statically.
 7385     JITCompiler::JumpList slowPath;
</pre>
<hr />
<pre>
 7414         m_jit.store32(
 7415             lengthGPR, JITCompiler::Address(resultGPR, DirectArguments::offsetOfLength()));
 7416     }
 7417 
 7418     m_jit.store32(
 7419         TrustedImm32(minCapacity),
 7420         JITCompiler::Address(resultGPR, DirectArguments::offsetOfMinCapacity()));
 7421 
 7422     m_jit.storePtr(
 7423         TrustedImmPtr(nullptr), JITCompiler::Address(resultGPR, DirectArguments::offsetOfMappedArguments()));
 7424 
 7425     m_jit.storePtr(
 7426         TrustedImmPtr(nullptr), JITCompiler::Address(resultGPR, DirectArguments::offsetOfModifiedArgumentsDescriptor()));
 7427 
 7428     if (lengthIsKnown) {
 7429         addSlowPathGenerator(
 7430             slowPathCall(
 7431                 slowPath, this, operationCreateDirectArguments, resultGPR, structure,
 7432                 knownLength, minCapacity));
 7433     } else {
<span class="line-modified"> 7434         auto generator = std::make_unique&lt;CallCreateDirectArgumentsSlowPathGenerator&gt;(</span>
 7435             slowPath, this, resultGPR, structure, lengthGPR, minCapacity);
 7436         addSlowPathGenerator(WTFMove(generator));
 7437     }
 7438 
<span class="line-modified"> 7439     if (node-&gt;origin.semantic.inlineCallFrame) {</span>
<span class="line-modified"> 7440         if (node-&gt;origin.semantic.inlineCallFrame-&gt;isClosureCall) {</span>
 7441             m_jit.loadPtr(
 7442                 JITCompiler::addressFor(
<span class="line-modified"> 7443                     node-&gt;origin.semantic.inlineCallFrame-&gt;calleeRecovery.virtualRegister()),</span>
 7444                 scratch1GPR);
 7445         } else {
 7446             m_jit.move(
 7447                 TrustedImmPtr::weakPointer(
<span class="line-modified"> 7448                     m_jit.graph(), node-&gt;origin.semantic.inlineCallFrame-&gt;calleeRecovery.constant().asCell()),</span>
 7449                 scratch1GPR);
 7450         }
 7451     } else
 7452         m_jit.loadPtr(JITCompiler::addressFor(CallFrameSlot::callee), scratch1GPR);
 7453 
 7454     // Don&#39;t need a memory barriers since we just fast-created the activation, so the
 7455     // activation must be young.
 7456     m_jit.storePtr(
 7457         scratch1GPR, JITCompiler::Address(resultGPR, DirectArguments::offsetOfCallee()));
 7458 
 7459     VirtualRegister start = m_jit.argumentsStart(node-&gt;origin.semantic);
 7460     if (lengthIsKnown) {
 7461         for (unsigned i = 0; i &lt; std::max(knownLength, minCapacity); ++i) {
 7462             m_jit.loadValue(JITCompiler::addressFor(start + i), valueRegs);
 7463             m_jit.storeValue(
 7464                 valueRegs, JITCompiler::Address(resultGPR, DirectArguments::offsetOfSlot(i)));
 7465         }
 7466     } else {
 7467         JITCompiler::Jump done;
 7468         if (minCapacity) {
</pre>
<hr />
<pre>
 7472             startLoop.link(&amp;m_jit);
 7473         } else
 7474             done = m_jit.branchTest32(MacroAssembler::Zero, lengthGPR);
 7475         JITCompiler::Label loop = m_jit.label();
 7476         m_jit.sub32(TrustedImm32(1), lengthGPR);
 7477         m_jit.loadValue(
 7478             JITCompiler::BaseIndex(
 7479                 GPRInfo::callFrameRegister, lengthGPR, JITCompiler::TimesEight,
 7480                 start.offset() * static_cast&lt;int&gt;(sizeof(Register))),
 7481             valueRegs);
 7482         m_jit.storeValue(
 7483             valueRegs,
 7484             JITCompiler::BaseIndex(
 7485                 resultGPR, lengthGPR, JITCompiler::TimesEight,
 7486                 DirectArguments::storageOffset()));
 7487         m_jit.branchTest32(MacroAssembler::NonZero, lengthGPR).linkTo(loop, &amp;m_jit);
 7488         if (done.isSet())
 7489             done.link(&amp;m_jit);
 7490     }
 7491 
<span class="line-modified"> 7492     m_jit.mutatorFence(*m_jit.vm());</span>
 7493 
 7494     cellResult(resultGPR, node);
 7495 }
 7496 
 7497 void SpeculativeJIT::compileGetFromArguments(Node* node)
 7498 {
 7499     SpeculateCellOperand arguments(this, node-&gt;child1());
 7500     JSValueRegsTemporary result(this);
 7501 
 7502     GPRReg argumentsGPR = arguments.gpr();
 7503     JSValueRegs resultRegs = result.regs();
 7504 
 7505     m_jit.loadValue(JITCompiler::Address(argumentsGPR, DirectArguments::offsetOfSlot(node-&gt;capturedArgumentsOffset().offset())), resultRegs);
 7506     jsValueResult(resultRegs, node);
 7507 }
 7508 
 7509 void SpeculativeJIT::compilePutToArguments(Node* node)
 7510 {
 7511     SpeculateCellOperand arguments(this, node-&gt;child1());
 7512     JSValueOperand value(this, node-&gt;child2());
</pre>
<hr />
<pre>
 7692         GPRReg scratch1GPR = scratch1.gpr();
 7693         GPRReg scratch2GPR = scratch2.gpr();
 7694         GPRReg lengthGPR = length.gpr();
 7695         FPRReg doubleFPR = doubleRegister.fpr();
 7696 
 7697         MacroAssembler::JumpList slowPath;
 7698 
 7699         m_jit.load8(MacroAssembler::Address(argument, JSCell::indexingTypeAndMiscOffset()), scratch1GPR);
 7700         m_jit.and32(TrustedImm32(IndexingShapeMask), scratch1GPR);
 7701         m_jit.sub32(TrustedImm32(Int32Shape), scratch1GPR);
 7702 
 7703         slowPath.append(m_jit.branch32(MacroAssembler::Above, scratch1GPR, TrustedImm32(ContiguousShape - Int32Shape)));
 7704 
 7705         m_jit.loadPtr(MacroAssembler::Address(argument, JSObject::butterflyOffset()), lengthGPR);
 7706         m_jit.load32(MacroAssembler::Address(lengthGPR, Butterfly::offsetOfPublicLength()), lengthGPR);
 7707         static_assert(sizeof(JSValue) == 8 &amp;&amp; 1 &lt;&lt; 3 == 8, &quot;This is strongly assumed in the code below.&quot;);
 7708         m_jit.move(lengthGPR, scratch1GPR);
 7709         m_jit.lshift32(TrustedImm32(3), scratch1GPR);
 7710         m_jit.add32(TrustedImm32(JSFixedArray::offsetOfData()), scratch1GPR);
 7711 
<span class="line-modified"> 7712         m_jit.emitAllocateVariableSizedCell&lt;JSFixedArray&gt;(*m_jit.vm(), resultGPR, TrustedImmPtr(m_jit.graph().registerStructure(m_jit.graph().m_vm.fixedArrayStructure.get())), scratch1GPR, scratch1GPR, scratch2GPR, slowPath);</span>
 7713         m_jit.store32(lengthGPR, MacroAssembler::Address(resultGPR, JSFixedArray::offsetOfSize()));
 7714 
 7715         m_jit.loadPtr(MacroAssembler::Address(argument, JSObject::butterflyOffset()), scratch1GPR);
 7716 
 7717         MacroAssembler::JumpList done;
 7718 
 7719         m_jit.load8(MacroAssembler::Address(argument, JSCell::indexingTypeAndMiscOffset()), scratch2GPR);
 7720         m_jit.and32(TrustedImm32(IndexingShapeMask), scratch2GPR);
 7721         auto isDoubleArray = m_jit.branch32(MacroAssembler::Equal, scratch2GPR, TrustedImm32(DoubleShape));
 7722 
 7723         {
 7724             done.append(m_jit.branchTest32(MacroAssembler::Zero, lengthGPR));
 7725             auto loopStart = m_jit.label();
 7726             m_jit.sub32(TrustedImm32(1), lengthGPR);
 7727             m_jit.load64(MacroAssembler::BaseIndex(scratch1GPR, lengthGPR, MacroAssembler::TimesEight), scratch2GPR);
 7728             auto notEmpty = m_jit.branchIfNotEmpty(scratch2GPR);
 7729             m_jit.move(TrustedImm64(JSValue::encode(jsUndefined())), scratch2GPR);
 7730             notEmpty.link(&amp;m_jit);
 7731             m_jit.store64(scratch2GPR, MacroAssembler::BaseIndex(resultGPR, lengthGPR, MacroAssembler::TimesEight, JSFixedArray::offsetOfData()));
 7732             m_jit.branchTest32(MacroAssembler::NonZero, lengthGPR).linkTo(loopStart, &amp;m_jit);
 7733             done.append(m_jit.jump());
 7734         }
 7735 
 7736         isDoubleArray.link(&amp;m_jit);
 7737         {
 7738             done.append(m_jit.branchTest32(MacroAssembler::Zero, lengthGPR));
 7739             auto loopStart = m_jit.label();
 7740             m_jit.sub32(TrustedImm32(1), lengthGPR);
 7741             m_jit.loadDouble(MacroAssembler::BaseIndex(scratch1GPR, lengthGPR, MacroAssembler::TimesEight), doubleFPR);
 7742             auto notEmpty = m_jit.branchIfNotNaN(doubleFPR);
 7743             m_jit.move(TrustedImm64(JSValue::encode(jsUndefined())), scratch2GPR);
 7744             auto doStore = m_jit.jump();
 7745             notEmpty.link(&amp;m_jit);
 7746             m_jit.boxDouble(doubleFPR, scratch2GPR);
 7747             doStore.link(&amp;m_jit);
 7748             m_jit.store64(scratch2GPR, MacroAssembler::BaseIndex(resultGPR, lengthGPR, MacroAssembler::TimesEight, JSFixedArray::offsetOfData()));
 7749             m_jit.branchTest32(MacroAssembler::NonZero, lengthGPR).linkTo(loopStart, &amp;m_jit);
 7750             done.append(m_jit.jump());
 7751         }
 7752 
<span class="line-modified"> 7753         m_jit.mutatorFence(*m_jit.vm());</span>
 7754 
 7755         slowPath.link(&amp;m_jit);
 7756         addSlowPathGenerator(slowPathCall(m_jit.jump(), this, operationSpreadFastArray, resultGPR, argument));
 7757 
 7758         done.link(&amp;m_jit);
 7759         cellResult(resultGPR, node);
 7760 #else
 7761         flushRegisters();
 7762 
 7763         GPRFlushedCallResult result(this);
 7764         GPRReg resultGPR = result.gpr();
 7765         callOperation(operationSpreadFastArray, resultGPR, argument);
 7766         m_jit.exceptionCheck();
 7767         cellResult(resultGPR, node);
 7768 #endif // USE(JSVALUE64)
 7769     } else {
 7770         flushRegisters();
 7771 
 7772         GPRFlushedCallResult result(this);
 7773         GPRReg resultGPR = result.gpr();
</pre>
<hr />
<pre>
 7844         // that&#39;s the least of what&#39;s wrong with this code. We really shouldn&#39;t be
 7845         // allocating the array after having computed - and probably spilled to the
 7846         // stack - all of the things that will go into the array. The solution to that
 7847         // bigger problem will also likely fix the redundancy in reloading the storage
 7848         // pointer that we currently have.
 7849 
 7850         cellResult(resultGPR, node);
 7851         return;
 7852     }
 7853 
 7854     if (!node-&gt;numChildren()) {
 7855         flushRegisters();
 7856         GPRFlushedCallResult result(this);
 7857         callOperation(operationNewEmptyArray, result.gpr(), m_jit.graph().registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(node-&gt;indexingType())));
 7858         m_jit.exceptionCheck();
 7859         cellResult(result.gpr(), node);
 7860         return;
 7861     }
 7862 
 7863     size_t scratchSize = sizeof(EncodedJSValue) * node-&gt;numChildren();
<span class="line-modified"> 7864     ScratchBuffer* scratchBuffer = m_jit.vm()-&gt;scratchBufferForSize(scratchSize);</span>
 7865     EncodedJSValue* buffer = scratchBuffer ? static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer()) : nullptr;
 7866 
 7867     for (unsigned operandIdx = 0; operandIdx &lt; node-&gt;numChildren(); ++operandIdx) {
 7868         // Need to perform the speculations that this node promises to perform. If we&#39;re
 7869         // emitting code here and the indexing type is not array storage then there is
 7870         // probably something hilarious going on and we&#39;re already failing at all the
 7871         // things, but at least we&#39;re going to be sound.
 7872         Edge use = m_jit.graph().m_varArgChildren[node-&gt;firstChild() + operandIdx];
 7873         switch (node-&gt;indexingType()) {
 7874         case ALL_BLANK_INDEXING_TYPES:
 7875         case ALL_UNDECIDED_INDEXING_TYPES:
 7876             CRASH();
 7877             break;
 7878         case ALL_DOUBLE_INDEXING_TYPES: {
 7879             SpeculateDoubleOperand operand(this, use);
 7880             FPRReg opFPR = operand.fpr();
 7881             DFG_TYPE_CHECK(
 7882                 JSValueRegs(), use, SpecDoubleReal,
 7883                 m_jit.branchIfNaN(opFPR));
 7884 #if USE(JSVALUE64)
</pre>
<hr />
<pre>
 8016                 m_jit.addPtr(TrustedImm32(1), fixedIndexGPR);
 8017                 m_jit.addPtr(TrustedImm32(1), indexGPR);
 8018                 m_jit.branchPtr(MacroAssembler::Below, fixedIndexGPR, fixedLengthGPR).linkTo(loopStart, &amp;m_jit);
 8019 
 8020                 done.link(&amp;m_jit);
 8021             } else {
 8022                 JSValueOperand item(this, use);
 8023                 GPRReg itemGPR = item.gpr();
 8024                 m_jit.store64(itemGPR, MacroAssembler::BaseIndex(storageGPR, indexGPR, MacroAssembler::TimesEight));
 8025                 m_jit.addPtr(TrustedImm32(1), indexGPR);
 8026             }
 8027         }
 8028 
 8029         cellResult(resultGPR, node);
 8030         return;
 8031     }
 8032 #endif // USE(JSVALUE64)
 8033 
 8034     ASSERT(node-&gt;numChildren());
 8035     size_t scratchSize = sizeof(EncodedJSValue) * node-&gt;numChildren();
<span class="line-modified"> 8036     ScratchBuffer* scratchBuffer = m_jit.vm()-&gt;scratchBufferForSize(scratchSize);</span>
 8037     EncodedJSValue* buffer = static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer());
 8038 
 8039     BitVector* bitVector = node-&gt;bitVector();
 8040     for (unsigned i = 0; i &lt; node-&gt;numChildren(); ++i) {
 8041         Edge use = m_jit.graph().m_varArgChildren[node-&gt;firstChild() + i];
 8042         if (bitVector-&gt;get(i)) {
 8043             SpeculateCellOperand fixedArray(this, use);
 8044             GPRReg arrayGPR = fixedArray.gpr();
 8045 #if USE(JSVALUE64)
 8046             m_jit.store64(arrayGPR, &amp;buffer[i]);
 8047 #else
 8048             char* pointer = static_cast&lt;char*&gt;(static_cast&lt;void*&gt;(&amp;buffer[i]));
 8049             m_jit.store32(arrayGPR, pointer + PayloadOffset);
 8050             m_jit.store32(TrustedImm32(JSValue::CellTag), pointer + TagOffset);
 8051 #endif
 8052         } else {
 8053             JSValueOperand input(this, use);
 8054             JSValueRegs inputRegs = input.jsValueRegs();
 8055             m_jit.storeValue(inputRegs, &amp;buffer[i]);
 8056         }
</pre>
<hr />
<pre>
 8229 
 8230         isInt32.link(&amp;m_jit);
 8231         m_jit.move(TrustedImmPtr(m_jit.graph().registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithInt32))), tempValue);
 8232         emitMoveEmptyValue(JSValue());
 8233 
 8234         done.link(&amp;m_jit);
 8235 
 8236         MacroAssembler::JumpList slowCases;
 8237         m_jit.move(TrustedImmPtr(nullptr), storageResultGPR);
 8238         // Enable the fast case on 64-bit platforms, where a sufficient amount of GP registers should be available.
 8239         // Other platforms could support the same approach with custom code, but that is not currently worth the extra code maintenance.
 8240         if (is64Bit()) {
 8241             GPRTemporary scratch(this);
 8242             GPRTemporary scratch2(this);
 8243             GPRReg scratchGPR = scratch.gpr();
 8244             GPRReg scratch2GPR = scratch2.gpr();
 8245 
 8246             emitAllocateButterfly(storageResultGPR, sizeGPR, scratchGPR, scratch2GPR, resultGPR, slowCases);
 8247             emitInitializeButterfly(storageResultGPR, sizeGPR, emptyValueRegs, scratchGPR);
 8248             emitAllocateJSObject&lt;JSArray&gt;(resultGPR, tempValue, storageResultGPR, scratchGPR, scratch2GPR, slowCases);
<span class="line-modified"> 8249             m_jit.mutatorFence(*m_jit.vm());</span>
 8250         } else {
 8251             slowCases.append(m_jit.jump());
 8252         }
 8253 
<span class="line-modified"> 8254         addSlowPathGenerator(std::make_unique&lt;CallArrayAllocatorWithVariableStructureVariableSizeSlowPathGenerator&gt;(</span>
 8255             slowCases, this, operationNewArrayWithSize, resultGPR, tempValue, sizeGPR, storageResultGPR));
 8256     }
 8257 
 8258     GPRTemporary temp4(this);
 8259     GPRReg loadIndex = temp4.gpr();
 8260 
 8261     if (node-&gt;numChildren() == 2) {
 8262         m_jit.load32(MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()), tempGPR);
 8263         m_jit.move(TrustedImm32(0), loadIndex);
 8264     } else {
 8265         m_jit.load32(MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()), tempValue);
 8266         if (node-&gt;numChildren() == 4)
 8267             emitPopulateSliceIndex(m_jit.graph().varArgChild(node, 2), WTF::nullopt, tempValue, tempGPR);
 8268         else
 8269             m_jit.move(tempValue, tempGPR);
 8270         emitPopulateSliceIndex(m_jit.graph().varArgChild(node, 1), WTF::nullopt, tempValue, loadIndex);
 8271     }
 8272 
 8273     GPRTemporary temp5(this);
 8274     GPRReg storeIndex = temp5.gpr();
</pre>
<hr />
<pre>
 8527     unsigned elementCount = node-&gt;numChildren() - elementOffset;
 8528 
 8529 #if USE(JSVALUE32_64)
 8530     GPRTemporary tag(this);
 8531     GPRReg tagGPR = tag.gpr();
 8532     JSValueRegs resultRegs { tagGPR, storageLengthGPR };
 8533 #else
 8534     JSValueRegs resultRegs { storageLengthGPR };
 8535 #endif
 8536 
 8537     auto getStorageBufferAddress = [&amp;] (GPRReg storageGPR, GPRReg indexGPR, int32_t offset, GPRReg bufferGPR) {
 8538         static_assert(sizeof(JSValue) == 8 &amp;&amp; 1 &lt;&lt; 3 == 8, &quot;This is strongly assumed in the code below.&quot;);
 8539         m_jit.getEffectiveAddress(MacroAssembler::BaseIndex(storageGPR, indexGPR, MacroAssembler::TimesEight, offset), bufferGPR);
 8540     };
 8541 
 8542     switch (node-&gt;arrayMode().type()) {
 8543     case Array::Int32:
 8544     case Array::Contiguous: {
 8545         if (elementCount == 1) {
 8546             Edge&amp; element = m_jit.graph().varArgChild(node, elementOffset);




 8547             JSValueOperand value(this, element, ManualOperandSpeculation);
 8548             JSValueRegs valueRegs = value.jsValueRegs();
 8549 
<span class="line-removed"> 8550             if (node-&gt;arrayMode().type() == Array::Int32)</span>
<span class="line-removed"> 8551                 DFG_ASSERT(m_jit.graph(), node, !needsTypeCheck(element, SpecInt32Only));</span>
<span class="line-removed"> 8552 </span>
 8553             m_jit.load32(MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()), storageLengthGPR);
 8554             MacroAssembler::Jump slowPath = m_jit.branch32(MacroAssembler::AboveOrEqual, storageLengthGPR, MacroAssembler::Address(storageGPR, Butterfly::offsetOfVectorLength()));
 8555             m_jit.storeValue(valueRegs, MacroAssembler::BaseIndex(storageGPR, storageLengthGPR, MacroAssembler::TimesEight));
 8556             m_jit.add32(TrustedImm32(1), storageLengthGPR);
 8557             m_jit.store32(storageLengthGPR, MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()));
 8558             m_jit.boxInt32(storageLengthGPR, resultRegs);
 8559 
 8560             addSlowPathGenerator(
 8561                 slowPathCall(slowPath, this, operationArrayPush, resultRegs, valueRegs, baseGPR));
 8562 
 8563             jsValueResult(resultRegs, node);
 8564             return;
 8565         }
 8566 








 8567         GPRTemporary buffer(this);
 8568         GPRReg bufferGPR = buffer.gpr();
 8569 
 8570         m_jit.load32(MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()), storageLengthGPR);
 8571         m_jit.move(storageLengthGPR, bufferGPR);
 8572         m_jit.add32(TrustedImm32(elementCount), bufferGPR);
 8573         MacroAssembler::Jump slowPath = m_jit.branch32(MacroAssembler::Above, bufferGPR, MacroAssembler::Address(storageGPR, Butterfly::offsetOfVectorLength()));
 8574 
 8575         m_jit.store32(bufferGPR, MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()));
 8576         getStorageBufferAddress(storageGPR, storageLengthGPR, 0, bufferGPR);
 8577         m_jit.add32(TrustedImm32(elementCount), storageLengthGPR);
 8578         m_jit.boxInt32(storageLengthGPR, resultRegs);
 8579         auto storageDone = m_jit.jump();
 8580 
 8581         slowPath.link(&amp;m_jit);
 8582 
 8583         size_t scratchSize = sizeof(EncodedJSValue) * elementCount;
<span class="line-modified"> 8584         ScratchBuffer* scratchBuffer = m_jit.vm()-&gt;scratchBufferForSize(scratchSize);</span>
 8585         m_jit.move(TrustedImmPtr(static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer())), bufferGPR);
 8586         m_jit.move(TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), storageLengthGPR);
 8587         m_jit.storePtr(TrustedImmPtr(scratchSize), MacroAssembler::Address(storageLengthGPR));
 8588 
 8589         storageDone.link(&amp;m_jit);
 8590         for (unsigned elementIndex = 0; elementIndex &lt; elementCount; ++elementIndex) {
 8591             Edge&amp; element = m_jit.graph().varArgChild(node, elementIndex + elementOffset);
<span class="line-modified"> 8592             JSValueOperand value(this, element, ManualOperandSpeculation);</span>
 8593             JSValueRegs valueRegs = value.jsValueRegs();
 8594 
<span class="line-removed"> 8595             if (node-&gt;arrayMode().type() == Array::Int32)</span>
<span class="line-removed"> 8596                 DFG_ASSERT(m_jit.graph(), node, !needsTypeCheck(element, SpecInt32Only));</span>
<span class="line-removed"> 8597 </span>
 8598             m_jit.storeValue(valueRegs, MacroAssembler::Address(bufferGPR, sizeof(EncodedJSValue) * elementIndex));
 8599             value.use();
 8600         }
 8601 
 8602         MacroAssembler::Jump fastPath = m_jit.branchPtr(MacroAssembler::NotEqual, bufferGPR, TrustedImmPtr(static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer())));
 8603 
 8604         addSlowPathGenerator(slowPathCall(m_jit.jump(), this, operationArrayPushMultiple, resultRegs, baseGPR, bufferGPR, TrustedImm32(elementCount)));
 8605 
 8606         m_jit.move(TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), bufferGPR);
 8607         m_jit.storePtr(TrustedImmPtr(nullptr), MacroAssembler::Address(bufferGPR));
 8608 
 8609         base.use();
 8610         storage.use();
 8611 
 8612         fastPath.link(&amp;m_jit);
 8613         jsValueResult(resultRegs, node, DataFormatJS, UseChildrenCalledExplicitly);
 8614         return;
 8615     }
 8616 
 8617     case Array::Double: {
 8618         if (elementCount == 1) {
 8619             Edge&amp; element = m_jit.graph().varArgChild(node, elementOffset);

 8620             SpeculateDoubleOperand value(this, element);
 8621             FPRReg valueFPR = value.fpr();
 8622 
<span class="line-removed"> 8623             DFG_ASSERT(m_jit.graph(), node, !needsTypeCheck(element, SpecDoubleReal));</span>
<span class="line-removed"> 8624 </span>
 8625             m_jit.load32(MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()), storageLengthGPR);
 8626             MacroAssembler::Jump slowPath = m_jit.branch32(MacroAssembler::AboveOrEqual, storageLengthGPR, MacroAssembler::Address(storageGPR, Butterfly::offsetOfVectorLength()));
 8627             m_jit.storeDouble(valueFPR, MacroAssembler::BaseIndex(storageGPR, storageLengthGPR, MacroAssembler::TimesEight));
 8628             m_jit.add32(TrustedImm32(1), storageLengthGPR);
 8629             m_jit.store32(storageLengthGPR, MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()));
 8630             m_jit.boxInt32(storageLengthGPR, resultRegs);
 8631 
 8632             addSlowPathGenerator(
 8633                 slowPathCall(slowPath, this, operationArrayPushDouble, resultRegs, valueFPR, baseGPR));
 8634 
 8635             jsValueResult(resultRegs, node);
 8636             return;
 8637         }
 8638 






 8639         GPRTemporary buffer(this);
 8640         GPRReg bufferGPR = buffer.gpr();
 8641 
 8642         m_jit.load32(MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()), storageLengthGPR);
 8643         m_jit.move(storageLengthGPR, bufferGPR);
 8644         m_jit.add32(TrustedImm32(elementCount), bufferGPR);
 8645         MacroAssembler::Jump slowPath = m_jit.branch32(MacroAssembler::Above, bufferGPR, MacroAssembler::Address(storageGPR, Butterfly::offsetOfVectorLength()));
 8646 
 8647         m_jit.store32(bufferGPR, MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()));
 8648         getStorageBufferAddress(storageGPR, storageLengthGPR, 0, bufferGPR);
 8649         m_jit.add32(TrustedImm32(elementCount), storageLengthGPR);
 8650         m_jit.boxInt32(storageLengthGPR, resultRegs);
 8651         auto storageDone = m_jit.jump();
 8652 
 8653         slowPath.link(&amp;m_jit);
 8654 
 8655         size_t scratchSize = sizeof(double) * elementCount;
<span class="line-modified"> 8656         ScratchBuffer* scratchBuffer = m_jit.vm()-&gt;scratchBufferForSize(scratchSize);</span>
 8657         m_jit.move(TrustedImmPtr(static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer())), bufferGPR);
 8658         m_jit.move(TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), storageLengthGPR);
 8659         m_jit.storePtr(TrustedImmPtr(scratchSize), MacroAssembler::Address(storageLengthGPR));
 8660 
 8661         storageDone.link(&amp;m_jit);
 8662         for (unsigned elementIndex = 0; elementIndex &lt; elementCount; ++elementIndex) {
 8663             Edge&amp; element = m_jit.graph().varArgChild(node, elementIndex + elementOffset);
 8664             SpeculateDoubleOperand value(this, element);
 8665             FPRReg valueFPR = value.fpr();
 8666 
<span class="line-removed"> 8667             DFG_ASSERT(m_jit.graph(), node, !needsTypeCheck(element, SpecDoubleReal));</span>
<span class="line-removed"> 8668 </span>
 8669             m_jit.storeDouble(valueFPR, MacroAssembler::Address(bufferGPR, sizeof(double) * elementIndex));
 8670             value.use();
 8671         }
 8672 
 8673         MacroAssembler::Jump fastPath = m_jit.branchPtr(MacroAssembler::NotEqual, bufferGPR, TrustedImmPtr(static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer())));
 8674 
 8675         addSlowPathGenerator(slowPathCall(m_jit.jump(), this, operationArrayPushDoubleMultiple, resultRegs, baseGPR, bufferGPR, TrustedImm32(elementCount)));
 8676 
 8677         m_jit.move(TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), bufferGPR);
 8678         m_jit.storePtr(TrustedImmPtr(nullptr), MacroAssembler::Address(bufferGPR));
 8679 
 8680         base.use();
 8681         storage.use();
 8682 
 8683         fastPath.link(&amp;m_jit);
 8684         jsValueResult(resultRegs, node, DataFormatJS, UseChildrenCalledExplicitly);
 8685         return;
 8686     }
 8687 
 8688     case Array::ArrayStorage: {
</pre>
<hr />
<pre>
 8719 
 8720         m_jit.load32(MacroAssembler::Address(storageGPR, ArrayStorage::lengthOffset()), storageLengthGPR);
 8721 
 8722         // Refuse to handle bizarre lengths.
 8723         speculationCheck(Uncountable, JSValueRegs(), 0, m_jit.branch32(MacroAssembler::Above, storageLengthGPR, TrustedImm32(largestPositiveInt32Length)));
 8724 
 8725         m_jit.move(storageLengthGPR, bufferGPR);
 8726         m_jit.add32(TrustedImm32(elementCount), bufferGPR);
 8727         MacroAssembler::Jump slowPath = m_jit.branch32(MacroAssembler::Above, bufferGPR, MacroAssembler::Address(storageGPR, ArrayStorage::vectorLengthOffset()));
 8728 
 8729         m_jit.store32(bufferGPR, MacroAssembler::Address(storageGPR, ArrayStorage::lengthOffset()));
 8730         getStorageBufferAddress(storageGPR, storageLengthGPR, ArrayStorage::vectorOffset(), bufferGPR);
 8731         m_jit.add32(TrustedImm32(elementCount), MacroAssembler::Address(storageGPR, OBJECT_OFFSETOF(ArrayStorage, m_numValuesInVector)));
 8732         m_jit.add32(TrustedImm32(elementCount), storageLengthGPR);
 8733         m_jit.boxInt32(storageLengthGPR, resultRegs);
 8734         auto storageDone = m_jit.jump();
 8735 
 8736         slowPath.link(&amp;m_jit);
 8737 
 8738         size_t scratchSize = sizeof(EncodedJSValue) * elementCount;
<span class="line-modified"> 8739         ScratchBuffer* scratchBuffer = m_jit.vm()-&gt;scratchBufferForSize(scratchSize);</span>
 8740         m_jit.move(TrustedImmPtr(static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer())), bufferGPR);
 8741         m_jit.move(TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), storageLengthGPR);
 8742         m_jit.storePtr(TrustedImmPtr(scratchSize), MacroAssembler::Address(storageLengthGPR));
 8743 
 8744         storageDone.link(&amp;m_jit);
 8745         for (unsigned elementIndex = 0; elementIndex &lt; elementCount; ++elementIndex) {
 8746             Edge&amp; element = m_jit.graph().varArgChild(node, elementIndex + elementOffset);
 8747             JSValueOperand value(this, element);
 8748             JSValueRegs valueRegs = value.jsValueRegs();
 8749 
 8750             m_jit.storeValue(valueRegs, MacroAssembler::Address(bufferGPR, sizeof(EncodedJSValue) * elementIndex));
 8751             value.use();
 8752         }
 8753 
 8754         MacroAssembler::Jump fastPath = m_jit.branchPtr(MacroAssembler::NotEqual, bufferGPR, TrustedImmPtr(static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer())));
 8755 
 8756         addSlowPathGenerator(
 8757             slowPathCall(m_jit.jump(), this, operationArrayPushMultiple, resultRegs, baseGPR, bufferGPR, TrustedImm32(elementCount)));
 8758 
 8759         m_jit.move(TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), bufferGPR);
</pre>
<hr />
<pre>
 8888     done.link(&amp;m_jit);
 8889 
 8890     unblessedBooleanResult(resultGPR, node);
 8891 }
 8892 
 8893 void SpeculativeJIT::compileTypeOf(Node* node)
 8894 {
 8895     JSGlobalObject* globalObject = m_jit.graph().globalObjectFor(node-&gt;origin.semantic);
 8896 
 8897     JSValueOperand value(this, node-&gt;child1());
 8898     JSValueRegs valueRegs = value.jsValueRegs();
 8899 
 8900     GPRTemporary result(this);
 8901     GPRReg resultGPR = result.gpr();
 8902 
 8903     JITCompiler::JumpList done;
 8904     JITCompiler::Jump slowPath;
 8905     m_jit.emitTypeOf(
 8906         valueRegs, resultGPR,
 8907         [&amp;] (TypeofType type, bool fallsThrough) {
<span class="line-modified"> 8908             m_jit.move(TrustedImmPtr::weakPointer(m_jit.graph(), m_jit.vm()-&gt;smallStrings.typeString(type)), resultGPR);</span>
 8909             if (!fallsThrough)
 8910                 done.append(m_jit.jump());
 8911         },
 8912         [&amp;] (JITCompiler::Jump theSlowPath) {
 8913             slowPath = theSlowPath;
 8914         });
 8915     done.link(&amp;m_jit);
 8916 
 8917     addSlowPathGenerator(
 8918         slowPathCall(
 8919             slowPath, this, operationTypeOfObject, resultGPR, globalObject,
 8920             valueRegs.payloadGPR()));
 8921 
 8922     cellResult(resultGPR, node);
 8923 }
 8924 
 8925 void SpeculativeJIT::emitStructureCheck(Node* node, GPRReg cellGPR, GPRReg tempGPR)
 8926 {
 8927     ASSERT(node-&gt;structureSet().size());
 8928 
 8929     if (node-&gt;structureSet().size() == 1) {
 8930         speculationCheck(
 8931             BadCache, JSValueSource::unboxedCell(cellGPR), 0,
 8932             m_jit.branchWeakStructure(
 8933                 JITCompiler::NotEqual,
 8934                 JITCompiler::Address(cellGPR, JSCell::structureIDOffset()),
 8935                 node-&gt;structureSet()[0]));
 8936     } else {
 8937         std::unique_ptr&lt;GPRTemporary&gt; structure;
 8938         GPRReg structureGPR;
 8939 
 8940         if (tempGPR == InvalidGPRReg) {
<span class="line-modified"> 8941             structure = std::make_unique&lt;GPRTemporary&gt;(this);</span>
 8942             structureGPR = structure-&gt;gpr();
 8943         } else
 8944             structureGPR = tempGPR;
 8945 
 8946         m_jit.load32(JITCompiler::Address(cellGPR, JSCell::structureIDOffset()), structureGPR);
 8947 
 8948         JITCompiler::JumpList done;
 8949 
 8950         for (size_t i = 0; i &lt; node-&gt;structureSet().size() - 1; ++i) {
 8951             done.append(
 8952                 m_jit.branchWeakStructure(JITCompiler::Equal, structureGPR, node-&gt;structureSet()[i]));
 8953         }
 8954 
 8955         speculationCheck(
 8956             BadCache, JSValueSource::unboxedCell(cellGPR), 0,
 8957             m_jit.branchWeakStructure(
 8958                 JITCompiler::NotEqual, structureGPR, node-&gt;structureSet().last()));
 8959 
 8960         done.link(&amp;m_jit);
 8961     }
</pre>
<hr />
<pre>
 9002         cell.link(&amp;m_jit);
 9003         emitStructureCheck(node, valueRegs.payloadGPR(), tempGPR);
 9004         done.link(&amp;m_jit);
 9005         noResult(node);
 9006         return;
 9007     }
 9008 
 9009     default:
 9010         DFG_CRASH(m_jit.graph(), node, &quot;Bad use kind&quot;);
 9011         return;
 9012     }
 9013 }
 9014 
 9015 void SpeculativeJIT::compileAllocatePropertyStorage(Node* node)
 9016 {
 9017     ASSERT(!node-&gt;transition()-&gt;previous-&gt;outOfLineCapacity());
 9018     ASSERT(initialOutOfLineCapacity == node-&gt;transition()-&gt;next-&gt;outOfLineCapacity());
 9019 
 9020     size_t size = initialOutOfLineCapacity * sizeof(JSValue);
 9021 
<span class="line-modified"> 9022     Allocator allocator = m_jit.vm()-&gt;jsValueGigacageAuxiliarySpace.allocatorForNonVirtual(size, AllocatorForMode::AllocatorIfExists);</span>
 9023 
 9024     if (!allocator || node-&gt;transition()-&gt;previous-&gt;couldHaveIndexingHeader()) {
 9025         SpeculateCellOperand base(this, node-&gt;child1());
 9026 
 9027         GPRReg baseGPR = base.gpr();
 9028 
 9029         flushRegisters();
 9030 
 9031         GPRFlushedCallResult result(this);
 9032         callOperation(operationAllocateComplexPropertyStorageWithInitialCapacity, result.gpr(), baseGPR);
 9033         m_jit.exceptionCheck();
 9034 
 9035         storageResult(result.gpr(), node);
 9036         return;
 9037     }
 9038 
 9039     GPRTemporary scratch1(this);
 9040     GPRTemporary scratch2(this);
 9041     GPRTemporary scratch3(this);
 9042 
</pre>
<hr />
<pre>
 9046 
 9047     JITCompiler::JumpList slowPath;
 9048     m_jit.emitAllocate(scratchGPR1, JITAllocator::constant(allocator), scratchGPR2, scratchGPR3, slowPath);
 9049     m_jit.addPtr(JITCompiler::TrustedImm32(size + sizeof(IndexingHeader)), scratchGPR1);
 9050 
 9051     addSlowPathGenerator(
 9052         slowPathCall(slowPath, this, operationAllocateSimplePropertyStorageWithInitialCapacity, scratchGPR1));
 9053 
 9054     for (ptrdiff_t offset = 0; offset &lt; static_cast&lt;ptrdiff_t&gt;(size); offset += sizeof(void*))
 9055         m_jit.storePtr(TrustedImmPtr(nullptr), JITCompiler::Address(scratchGPR1, -(offset + sizeof(JSValue) + sizeof(void*))));
 9056 
 9057     storageResult(scratchGPR1, node);
 9058 }
 9059 
 9060 void SpeculativeJIT::compileReallocatePropertyStorage(Node* node)
 9061 {
 9062     size_t oldSize = node-&gt;transition()-&gt;previous-&gt;outOfLineCapacity() * sizeof(JSValue);
 9063     size_t newSize = oldSize * outOfLineGrowthFactor;
 9064     ASSERT(newSize == node-&gt;transition()-&gt;next-&gt;outOfLineCapacity() * sizeof(JSValue));
 9065 
<span class="line-modified"> 9066     Allocator allocator = m_jit.vm()-&gt;jsValueGigacageAuxiliarySpace.allocatorForNonVirtual(newSize, AllocatorForMode::AllocatorIfExists);</span>
 9067 
 9068     if (!allocator || node-&gt;transition()-&gt;previous-&gt;couldHaveIndexingHeader()) {
 9069         SpeculateCellOperand base(this, node-&gt;child1());
 9070 
 9071         GPRReg baseGPR = base.gpr();
 9072 
 9073         flushRegisters();
 9074 
 9075         GPRFlushedCallResult result(this);
 9076         callOperation(operationAllocateComplexPropertyStorage, result.gpr(), baseGPR, newSize / sizeof(JSValue));
 9077         m_jit.exceptionCheck();
 9078 
 9079         storageResult(result.gpr(), node);
 9080         return;
 9081     }
 9082 
 9083     StorageOperand oldStorage(this, node-&gt;child2());
 9084     GPRTemporary scratch1(this);
 9085     GPRTemporary scratch2(this);
 9086     GPRTemporary scratch3(this);
</pre>
<hr />
<pre>
 9101     for (ptrdiff_t offset = oldSize; offset &lt; static_cast&lt;ptrdiff_t&gt;(newSize); offset += sizeof(void*))
 9102         m_jit.storePtr(TrustedImmPtr(nullptr), JITCompiler::Address(scratchGPR1, -(offset + sizeof(JSValue) + sizeof(void*))));
 9103 
 9104     // We have scratchGPR1 = new storage, scratchGPR2 = scratch
 9105     for (ptrdiff_t offset = 0; offset &lt; static_cast&lt;ptrdiff_t&gt;(oldSize); offset += sizeof(void*)) {
 9106         m_jit.loadPtr(JITCompiler::Address(oldStorageGPR, -(offset + sizeof(JSValue) + sizeof(void*))), scratchGPR2);
 9107         m_jit.storePtr(scratchGPR2, JITCompiler::Address(scratchGPR1, -(offset + sizeof(JSValue) + sizeof(void*))));
 9108     }
 9109 
 9110     storageResult(scratchGPR1, node);
 9111 }
 9112 
 9113 void SpeculativeJIT::compileNukeStructureAndSetButterfly(Node* node)
 9114 {
 9115     SpeculateCellOperand base(this, node-&gt;child1());
 9116     StorageOperand storage(this, node-&gt;child2());
 9117 
 9118     GPRReg baseGPR = base.gpr();
 9119     GPRReg storageGPR = storage.gpr();
 9120 
<span class="line-modified"> 9121     m_jit.nukeStructureAndStoreButterfly(*m_jit.vm(), storageGPR, baseGPR);</span>
 9122 
 9123     noResult(node);
 9124 }
 9125 
 9126 void SpeculativeJIT::compileGetButterfly(Node* node)
 9127 {
 9128     SpeculateCellOperand base(this, node-&gt;child1());
 9129     GPRTemporary result(this, Reuse, base);
 9130 
 9131     GPRReg baseGPR = base.gpr();
 9132     GPRReg resultGPR = result.gpr();
 9133 
 9134     m_jit.loadPtr(JITCompiler::Address(baseGPR, JSObject::butterflyOffset()), resultGPR);
 9135 
 9136     storageResult(resultGPR, node);
 9137 }
 9138 
 9139 static void allocateTemporaryRegistersForSnippet(SpeculativeJIT* jit, Vector&lt;GPRTemporary&gt;&amp; gpHolders, Vector&lt;FPRTemporary&gt;&amp; fpHolders, Vector&lt;GPRReg&gt;&amp; gpScratch, Vector&lt;FPRReg&gt;&amp; fpScratch, Snippet&amp; snippet)
 9140 {
 9141     for (unsigned i = 0; i &lt; snippet.numGPScratchRegisters; ++i) {
</pre>
<hr />
<pre>
 9196                 appendString(edge);
 9197                 break;
 9198             case SpecInt32Only:
 9199                 appendInt32(edge);
 9200                 break;
 9201             case SpecBoolean:
 9202                 appendBoolean(edge);
 9203                 break;
 9204             default:
 9205                 RELEASE_ASSERT_NOT_REACHED();
 9206                 break;
 9207             }
 9208         }
 9209         ++index;
 9210     });
 9211 
 9212     JSValueRegsTemporary result(this);
 9213     JSValueRegs resultRegs = result.regs();
 9214 
 9215     flushRegisters();
<span class="line-modified"> 9216     assertIsTaggedWith(reinterpret_cast&lt;void*&gt;(signature-&gt;unsafeFunction), CFunctionPtrTag);</span>

 9217     unsigned argumentCountIncludingThis = signature-&gt;argumentCount + 1;
 9218     switch (argumentCountIncludingThis) {
 9219     case 1:
<span class="line-modified"> 9220         callOperation(reinterpret_cast&lt;J_JITOperation_EP&gt;(signature-&gt;unsafeFunction), extractResult(resultRegs), regs[0]);</span>
 9221         break;
 9222     case 2:
<span class="line-modified"> 9223         callOperation(reinterpret_cast&lt;J_JITOperation_EPP&gt;(signature-&gt;unsafeFunction), extractResult(resultRegs), regs[0], regs[1]);</span>
 9224         break;
 9225     case 3:
<span class="line-modified"> 9226         callOperation(reinterpret_cast&lt;J_JITOperation_EPPP&gt;(signature-&gt;unsafeFunction), extractResult(resultRegs), regs[0], regs[1], regs[2]);</span>
 9227         break;
 9228     default:
 9229         RELEASE_ASSERT_NOT_REACHED();
 9230         break;
 9231     }
 9232 
 9233     m_jit.exceptionCheck();
 9234     jsValueResult(resultRegs, node);
 9235 }
 9236 
 9237 void SpeculativeJIT::compileCallDOMGetter(Node* node)
 9238 {
 9239     DOMJIT::CallDOMGetterSnippet* snippet = node-&gt;callDOMGetterData()-&gt;snippet;
 9240     if (!snippet) {
 9241         FunctionPtr&lt;OperationPtrTag&gt; getter = node-&gt;callDOMGetterData()-&gt;customAccessorGetter;
 9242         SpeculateCellOperand base(this, node-&gt;child1());
 9243         JSValueRegsTemporary result(this);
 9244 
 9245         JSValueRegs resultRegs = result.regs();
 9246         GPRReg baseGPR = base.gpr();
 9247 
 9248         flushRegisters();
 9249         m_jit.setupArguments&lt;J_JITOperation_EJI&gt;(CCallHelpers::CellValue(baseGPR), identifierUID(node-&gt;callDOMGetterData()-&gt;identifierNumber));
<span class="line-modified"> 9250         m_jit.storePtr(GPRInfo::callFrameRegister, &amp;m_jit.vm()-&gt;topCallFrame);</span>
 9251         m_jit.emitStoreCodeOrigin(m_currentNode-&gt;origin.semantic);
 9252         m_jit.appendCall(getter.retagged&lt;CFunctionPtrTag&gt;());
 9253         m_jit.setupResults(resultRegs);
 9254 
 9255         m_jit.exceptionCheck();
 9256         jsValueResult(resultRegs, node);
 9257         return;
 9258     }
 9259 
 9260     Vector&lt;GPRReg&gt; gpScratch;
 9261     Vector&lt;FPRReg&gt; fpScratch;
 9262     Vector&lt;SnippetParams::Value&gt; regs;
 9263 
 9264     JSValueRegsTemporary result(this);
 9265     regs.append(result.regs());
 9266 
 9267     Edge&amp; baseEdge = node-&gt;child1();
 9268     SpeculateCellOperand base(this, baseEdge);
 9269     regs.append(SnippetParams::Value(base.gpr(), m_state.forNode(baseEdge).value()));
 9270 
</pre>
<hr />
<pre>
 9278     Vector&lt;GPRTemporary&gt; gpTempraries;
 9279     Vector&lt;FPRTemporary&gt; fpTempraries;
 9280     allocateTemporaryRegistersForSnippet(this, gpTempraries, fpTempraries, gpScratch, fpScratch, *snippet);
 9281     SnippetParams params(this, WTFMove(regs), WTFMove(gpScratch), WTFMove(fpScratch));
 9282     snippet-&gt;generator()-&gt;run(m_jit, params);
 9283     jsValueResult(result.regs(), node);
 9284 }
 9285 
 9286 void SpeculativeJIT::compileCheckSubClass(Node* node)
 9287 {
 9288     const ClassInfo* classInfo = node-&gt;classInfo();
 9289     if (!classInfo-&gt;checkSubClassSnippet) {
 9290         SpeculateCellOperand base(this, node-&gt;child1());
 9291         GPRTemporary other(this);
 9292         GPRTemporary specified(this);
 9293 
 9294         GPRReg baseGPR = base.gpr();
 9295         GPRReg otherGPR = other.gpr();
 9296         GPRReg specifiedGPR = specified.gpr();
 9297 
<span class="line-modified"> 9298         m_jit.emitLoadStructure(*m_jit.vm(), baseGPR, otherGPR, specifiedGPR);</span>
 9299         m_jit.loadPtr(CCallHelpers::Address(otherGPR, Structure::classInfoOffset()), otherGPR);
 9300         m_jit.move(CCallHelpers::TrustedImmPtr(node-&gt;classInfo()), specifiedGPR);
 9301 
 9302         CCallHelpers::Label loop = m_jit.label();
 9303         auto done = m_jit.branchPtr(CCallHelpers::Equal, otherGPR, specifiedGPR);
 9304         m_jit.loadPtr(CCallHelpers::Address(otherGPR, ClassInfo::offsetOfParentClass()), otherGPR);
 9305         m_jit.branchTestPtr(CCallHelpers::NonZero, otherGPR).linkTo(loop, &amp;m_jit);
 9306         speculationCheck(BadType, JSValueSource::unboxedCell(baseGPR), node-&gt;child1(), m_jit.jump());
 9307         done.link(&amp;m_jit);
 9308         noResult(node);
 9309         return;
 9310     }
 9311 
 9312     Ref&lt;Snippet&gt; snippet = classInfo-&gt;checkSubClassSnippet();
 9313 
 9314     Vector&lt;GPRReg&gt; gpScratch;
 9315     Vector&lt;FPRReg&gt; fpScratch;
 9316     Vector&lt;SnippetParams::Value&gt; regs;
 9317 
 9318     SpeculateCellOperand base(this, node-&gt;child1());
</pre>
<hr />
<pre>
 9587     auto butterfly = TrustedImmPtr(nullptr);
 9588     emitAllocateJSObject&lt;StringObject&gt;(
 9589         resultGPR, TrustedImmPtr(node-&gt;structure()), butterfly, scratch1GPR, scratch2GPR,
 9590         slowPath);
 9591 
 9592     m_jit.storePtr(
 9593         TrustedImmPtr(StringObject::info()),
 9594         JITCompiler::Address(resultGPR, JSDestructibleObject::classInfoOffset()));
 9595 #if USE(JSVALUE64)
 9596     m_jit.store64(
 9597         operandGPR, JITCompiler::Address(resultGPR, JSWrapperObject::internalValueOffset()));
 9598 #else
 9599     m_jit.store32(
 9600         TrustedImm32(JSValue::CellTag),
 9601         JITCompiler::Address(resultGPR, JSWrapperObject::internalValueOffset() + OBJECT_OFFSETOF(JSValue, u.asBits.tag)));
 9602     m_jit.store32(
 9603         operandGPR,
 9604         JITCompiler::Address(resultGPR, JSWrapperObject::internalValueOffset() + OBJECT_OFFSETOF(JSValue, u.asBits.payload)));
 9605 #endif
 9606 
<span class="line-modified"> 9607     m_jit.mutatorFence(*m_jit.vm());</span>
 9608 
 9609     addSlowPathGenerator(slowPathCall(
 9610         slowPath, this, operationNewStringObject, resultGPR, operandGPR, node-&gt;structure()));
 9611 
 9612     cellResult(resultGPR, node);
 9613 }
 9614 
 9615 void SpeculativeJIT::compileNewSymbol(Node* node)
 9616 {
 9617     if (!node-&gt;child1()) {
 9618         flushRegisters();
 9619         GPRFlushedCallResult result(this);
 9620         GPRReg resultGPR = result.gpr();
 9621         callOperation(operationNewSymbol, resultGPR);
 9622         m_jit.exceptionCheck();
 9623         cellResult(resultGPR, node);
 9624         return;
 9625     }
 9626 
 9627 
</pre>
<hr />
<pre>
 9654     GPRTemporary scratch2(this);
 9655     GPRReg resultGPR = result.gpr();
 9656     GPRReg storageGPR = storage.gpr();
 9657     GPRReg scratchGPR = scratch.gpr();
 9658     GPRReg scratchGPR2 = scratch2.gpr();
 9659 
 9660     JITCompiler::JumpList slowCases;
 9661 
 9662     m_jit.move(TrustedImmPtr(nullptr), storageGPR);
 9663 
 9664     slowCases.append(m_jit.branch32(
 9665         MacroAssembler::Above, sizeGPR, TrustedImm32(JSArrayBufferView::fastSizeLimit)));
 9666 
 9667     m_jit.move(sizeGPR, scratchGPR);
 9668     m_jit.lshift32(TrustedImm32(logElementSize(typedArrayType)), scratchGPR);
 9669     if (elementSize(typedArrayType) &lt; 8) {
 9670         m_jit.add32(TrustedImm32(7), scratchGPR);
 9671         m_jit.and32(TrustedImm32(~7), scratchGPR);
 9672     }
 9673     m_jit.emitAllocateVariableSized(
<span class="line-modified"> 9674         storageGPR, m_jit.vm()-&gt;primitiveGigacageAuxiliarySpace, scratchGPR, scratchGPR,</span>
 9675         scratchGPR2, slowCases);
 9676 
 9677     MacroAssembler::Jump done = m_jit.branchTest32(MacroAssembler::Zero, sizeGPR);
 9678     m_jit.move(sizeGPR, scratchGPR);
 9679     if (elementSize(typedArrayType) != 4) {
 9680         if (elementSize(typedArrayType) &gt; 4)
 9681             m_jit.lshift32(TrustedImm32(logElementSize(typedArrayType) - 2), scratchGPR);
 9682         else {
 9683             if (elementSize(typedArrayType) &gt; 1)
 9684                 m_jit.lshift32(TrustedImm32(logElementSize(typedArrayType)), scratchGPR);
 9685             m_jit.add32(TrustedImm32(3), scratchGPR);
 9686             m_jit.urshift32(TrustedImm32(2), scratchGPR);
 9687         }
 9688     }
 9689     MacroAssembler::Label loop = m_jit.label();
 9690     m_jit.sub32(TrustedImm32(1), scratchGPR);
 9691     m_jit.store32(
 9692         TrustedImm32(0),
 9693         MacroAssembler::BaseIndex(storageGPR, scratchGPR, MacroAssembler::TimesFour));
 9694     m_jit.branchTest32(MacroAssembler::NonZero, scratchGPR).linkTo(loop, &amp;m_jit);
 9695     done.link(&amp;m_jit);





 9696 
 9697     auto butterfly = TrustedImmPtr(nullptr);
 9698     emitAllocateJSObject&lt;JSArrayBufferView&gt;(
 9699         resultGPR, TrustedImmPtr(structure), butterfly, scratchGPR, scratchGPR2,
 9700         slowCases);
 9701 
 9702     m_jit.storePtr(
 9703         storageGPR,
 9704         MacroAssembler::Address(resultGPR, JSArrayBufferView::offsetOfVector()));
 9705     m_jit.store32(
 9706         sizeGPR,
 9707         MacroAssembler::Address(resultGPR, JSArrayBufferView::offsetOfLength()));
 9708     m_jit.store32(
 9709         TrustedImm32(FastTypedArray),
 9710         MacroAssembler::Address(resultGPR, JSArrayBufferView::offsetOfMode()));
 9711 
<span class="line-modified"> 9712     m_jit.mutatorFence(*m_jit.vm());</span>
 9713 
 9714     addSlowPathGenerator(slowPathCall(
 9715         slowCases, this, operationNewTypedArrayWithSizeForType(typedArrayType),
 9716         resultGPR, structure, sizeGPR, storageGPR));
 9717 
 9718     cellResult(resultGPR, node);
 9719 }
 9720 
 9721 void SpeculativeJIT::compileNewRegexp(Node* node)
 9722 {
 9723     RegExp* regexp = node-&gt;castOperand&lt;RegExp*&gt;();
<span class="line-removed"> 9724     ASSERT(regexp-&gt;isValid());</span>
 9725 
 9726     GPRTemporary result(this);
 9727     GPRTemporary scratch1(this);
 9728     GPRTemporary scratch2(this);
 9729     JSValueOperand lastIndex(this, node-&gt;child1());
 9730 
 9731     GPRReg resultGPR = result.gpr();
 9732     GPRReg scratch1GPR = scratch1.gpr();
 9733     GPRReg scratch2GPR = scratch2.gpr();
 9734     JSValueRegs lastIndexRegs = lastIndex.jsValueRegs();
 9735 
 9736     JITCompiler::JumpList slowPath;
 9737 
 9738     auto structure = m_jit.graph().registerStructure(m_jit.graph().globalObjectFor(node-&gt;origin.semantic)-&gt;regExpStructure());
 9739     auto butterfly = TrustedImmPtr(nullptr);
 9740     emitAllocateJSObject&lt;RegExpObject&gt;(resultGPR, TrustedImmPtr(structure), butterfly, scratch1GPR, scratch2GPR, slowPath);
 9741 
 9742     m_jit.storePtr(
 9743         TrustedImmPtr(node-&gt;cellOperand()),
<span class="line-modified"> 9744         CCallHelpers::Address(resultGPR, RegExpObject::offsetOfRegExp()));</span>
 9745     m_jit.storeValue(lastIndexRegs, CCallHelpers::Address(resultGPR, RegExpObject::offsetOfLastIndex()));
<span class="line-modified"> 9746     m_jit.store8(TrustedImm32(true), CCallHelpers::Address(resultGPR, RegExpObject::offsetOfLastIndexIsWritable()));</span>
<span class="line-removed"> 9747     m_jit.mutatorFence(*m_jit.vm());</span>
 9748 
 9749     addSlowPathGenerator(slowPathCall(slowPath, this, operationNewRegexpWithLastIndex, resultGPR, regexp, lastIndexRegs));
 9750 
 9751     cellResult(resultGPR, node);
 9752 }
 9753 
 9754 void SpeculativeJIT::speculateCellTypeWithoutTypeFiltering(
 9755     Edge edge, GPRReg cellGPR, JSType jsType)
 9756 {
 9757     speculationCheck(
 9758         BadType, JSValueSource::unboxedCell(cellGPR), edge,
 9759         m_jit.branchIfNotType(cellGPR, jsType));
 9760 }
 9761 
 9762 void SpeculativeJIT::speculateCellType(
 9763     Edge edge, GPRReg cellGPR, SpeculatedType specType, JSType jsType)
 9764 {
 9765     DFG_TYPE_CHECK(
 9766         JSValueSource::unboxedCell(cellGPR), edge, specType,
 9767         m_jit.branchIfNotType(cellGPR, jsType));
</pre>
<hr />
<pre>
10086     GPRTemporary temp(this);
10087     JSValueRegs regs = operand.jsValueRegs();
10088     GPRReg tempGPR = temp.gpr();
10089     speculateStringOrOther(edge, regs, tempGPR);
10090 }
10091 
10092 void SpeculativeJIT::speculateStringIdentAndLoadStorage(Edge edge, GPRReg string, GPRReg storage)
10093 {
10094     m_jit.loadPtr(MacroAssembler::Address(string, JSString::offsetOfValue()), storage);
10095 
10096     if (!needsTypeCheck(edge, SpecStringIdent | ~SpecString))
10097         return;
10098 
10099     speculationCheck(
10100         BadType, JSValueSource::unboxedCell(string), edge,
10101         m_jit.branchIfRopeStringImpl(storage));
10102     speculationCheck(
10103         BadType, JSValueSource::unboxedCell(string), edge, m_jit.branchTest32(
10104             MacroAssembler::Zero,
10105             MacroAssembler::Address(storage, StringImpl::flagsOffset()),
<span class="line-modified">10106             MacroAssembler::TrustedImm32(StringImpl::flagIsAtomic())));</span>
10107 
10108     m_interpreter.filter(edge, SpecStringIdent | ~SpecString);
10109 }
10110 
10111 void SpeculativeJIT::speculateStringIdent(Edge edge, GPRReg string)
10112 {
10113     if (!needsTypeCheck(edge, SpecStringIdent))
10114         return;
10115 
10116     GPRTemporary temp(this);
10117     speculateStringIdentAndLoadStorage(edge, string, temp.gpr());
10118 }
10119 
10120 void SpeculativeJIT::speculateStringIdent(Edge edge)
10121 {
10122     if (!needsTypeCheck(edge, SpecStringIdent))
10123         return;
10124 
10125     SpeculateCellOperand operand(this, edge);
10126     GPRReg gpr = operand.gpr();
</pre>
<hr />
<pre>
10427         speculateMisc(edge);
10428         break;
10429     default:
10430         RELEASE_ASSERT_NOT_REACHED();
10431         break;
10432     }
10433 }
10434 
10435 void SpeculativeJIT::emitSwitchIntJump(
10436     SwitchData* data, GPRReg value, GPRReg scratch)
10437 {
10438     SimpleJumpTable&amp; table = m_jit.codeBlock()-&gt;switchJumpTable(data-&gt;switchTableIndex);
10439     table.ensureCTITable();
10440     m_jit.sub32(Imm32(table.min), value);
10441     addBranch(
10442         m_jit.branch32(JITCompiler::AboveOrEqual, value, Imm32(table.ctiOffsets.size())),
10443         data-&gt;fallThrough.block);
10444     m_jit.move(TrustedImmPtr(table.ctiOffsets.begin()), scratch);
10445     m_jit.loadPtr(JITCompiler::BaseIndex(scratch, value, JITCompiler::timesPtr()), scratch);
10446 
<span class="line-modified">10447     m_jit.jump(scratch, JSSwitchPtrTag);</span>
10448     data-&gt;didUseJumpTable = true;
10449 }
10450 
10451 void SpeculativeJIT::emitSwitchImm(Node* node, SwitchData* data)
10452 {
10453     switch (node-&gt;child1().useKind()) {
10454     case Int32Use: {
10455         SpeculateInt32Operand value(this, node-&gt;child1());
10456         GPRTemporary temp(this);
10457         emitSwitchIntJump(data, value.gpr(), temp.gpr());
10458         noResult(node);
10459         break;
10460     }
10461 
10462     case UntypedUse: {
10463         JSValueOperand value(this, node-&gt;child1());
10464         GPRTemporary temp(this);
10465         JSValueRegs valueRegs = value.jsValueRegs();
10466         GPRReg scratch = temp.gpr();
10467 
10468         value.use();
10469 
10470         auto notInt32 = m_jit.branchIfNotInt32(valueRegs);
10471         emitSwitchIntJump(data, valueRegs.payloadGPR(), scratch);
10472         notInt32.link(&amp;m_jit);
10473         addBranch(m_jit.branchIfNotNumber(valueRegs, scratch), data-&gt;fallThrough.block);
10474         silentSpillAllRegisters(scratch);
10475         callOperation(operationFindSwitchImmTargetForDouble, scratch, valueRegs, data-&gt;switchTableIndex);
10476         silentFillAllRegisters();
10477 
<span class="line-modified">10478         m_jit.jump(scratch, JSSwitchPtrTag);</span>
10479         noResult(node, UseChildrenCalledExplicitly);
10480         break;
10481     }
10482 
10483     default:
10484         RELEASE_ASSERT_NOT_REACHED();
10485         break;
10486     }
10487 }
10488 
10489 void SpeculativeJIT::emitSwitchCharStringJump(
10490     SwitchData* data, GPRReg value, GPRReg scratch)
10491 {
10492     m_jit.loadPtr(MacroAssembler::Address(value, JSString::offsetOfValue()), scratch);
10493     auto isRope = m_jit.branchIfRopeStringImpl(scratch);
10494 
10495     addBranch(
10496         m_jit.branch32(
10497             MacroAssembler::NotEqual,
10498             MacroAssembler::Address(scratch, StringImpl::lengthMemoryOffset()),
</pre>
<hr />
<pre>
10715     unsigned totalLength = 0;
10716 
10717     for (unsigned i = data-&gt;cases.size(); i--;) {
10718         StringImpl* string = data-&gt;cases[i].value.stringImpl();
10719         if (!string-&gt;is8Bit()) {
10720             canDoBinarySwitch = false;
10721             break;
10722         }
10723         if (string-&gt;length() &gt; Options::maximumBinaryStringSwitchCaseLength()) {
10724             canDoBinarySwitch = false;
10725             break;
10726         }
10727         totalLength += string-&gt;length();
10728     }
10729 
10730     if (!canDoBinarySwitch || totalLength &gt; Options::maximumBinaryStringSwitchTotalLength()) {
10731         flushRegisters();
10732         callOperation(
10733             operationSwitchString, string, static_cast&lt;size_t&gt;(data-&gt;switchTableIndex), string);
10734         m_jit.exceptionCheck();
<span class="line-modified">10735         m_jit.jump(string, JSSwitchPtrTag);</span>
10736         return;
10737     }
10738 
10739     GPRTemporary length(this);
10740     GPRTemporary temp(this);
10741 
10742     GPRReg lengthGPR = length.gpr();
10743     GPRReg tempGPR = temp.gpr();
10744 
10745     MacroAssembler::JumpList slowCases;
10746     m_jit.loadPtr(MacroAssembler::Address(string, JSString::offsetOfValue()), tempGPR);
10747     slowCases.append(m_jit.branchIfRopeStringImpl(tempGPR));
10748     m_jit.load32(MacroAssembler::Address(tempGPR, StringImpl::lengthMemoryOffset()), lengthGPR);
10749 
10750     slowCases.append(m_jit.branchTest32(
10751         MacroAssembler::Zero,
10752         MacroAssembler::Address(tempGPR, StringImpl::flagsOffset()),
10753         TrustedImm32(StringImpl::flagIs8Bit())));
10754 
10755     m_jit.loadPtr(MacroAssembler::Address(tempGPR, StringImpl::dataOffset()), string);
10756 
10757     Vector&lt;StringSwitchCase&gt; cases;
10758     for (unsigned i = 0; i &lt; data-&gt;cases.size(); ++i) {
10759         cases.append(
10760             StringSwitchCase(data-&gt;cases[i].value.stringImpl(), data-&gt;cases[i].target.block));
10761     }
10762 
10763     std::sort(cases.begin(), cases.end());
10764 
10765     emitBinarySwitchStringRecurse(
10766         data, cases, 0, 0, cases.size(), string, lengthGPR, tempGPR, 0, false);
10767 
10768     slowCases.link(&amp;m_jit);
10769     silentSpillAllRegisters(string);
10770     callOperation(operationSwitchString, string, static_cast&lt;size_t&gt;(data-&gt;switchTableIndex), string);
10771     silentFillAllRegisters();
10772     m_jit.exceptionCheck();
<span class="line-modified">10773     m_jit.jump(string, JSSwitchPtrTag);</span>
10774 }
10775 
10776 void SpeculativeJIT::emitSwitchString(Node* node, SwitchData* data)
10777 {
10778     switch (node-&gt;child1().useKind()) {
10779     case StringIdentUse: {
10780         SpeculateCellOperand op1(this, node-&gt;child1());
10781         GPRTemporary temp(this);
10782 
10783         GPRReg op1GPR = op1.gpr();
10784         GPRReg tempGPR = temp.gpr();
10785 
10786         speculateString(node-&gt;child1(), op1GPR);
10787         speculateStringIdentAndLoadStorage(node-&gt;child1(), op1GPR, tempGPR);
10788 
10789         Vector&lt;int64_t&gt; identifierCaseValues;
10790         for (unsigned i = 0; i &lt; data-&gt;cases.size(); ++i) {
10791             identifierCaseValues.append(
10792                 static_cast&lt;int64_t&gt;(bitwise_cast&lt;intptr_t&gt;(data-&gt;cases[i].value.stringImpl())));
10793         }
</pre>
<hr />
<pre>
10869 {
10870     for (auto&amp; branch : m_branches)
10871         branch.jump.linkTo(m_jit.blockHeads()[branch.destination-&gt;index], &amp;m_jit);
10872 }
10873 
10874 void SpeculativeJIT::compileStoreBarrier(Node* node)
10875 {
10876     ASSERT(node-&gt;op() == StoreBarrier || node-&gt;op() == FencedStoreBarrier);
10877 
10878     bool isFenced = node-&gt;op() == FencedStoreBarrier;
10879 
10880     SpeculateCellOperand base(this, node-&gt;child1());
10881     GPRTemporary scratch1(this);
10882 
10883     GPRReg baseGPR = base.gpr();
10884     GPRReg scratch1GPR = scratch1.gpr();
10885 
10886     JITCompiler::JumpList ok;
10887 
10888     if (isFenced) {
<span class="line-modified">10889         ok.append(m_jit.barrierBranch(*m_jit.vm(), baseGPR, scratch1GPR));</span>
10890 
<span class="line-modified">10891         JITCompiler::Jump noFence = m_jit.jumpIfMutatorFenceNotNeeded(*m_jit.vm());</span>
10892         m_jit.memoryFence();
10893         ok.append(m_jit.barrierBranchWithoutFence(baseGPR));
10894         noFence.link(&amp;m_jit);
10895     } else
10896         ok.append(m_jit.barrierBranchWithoutFence(baseGPR));
10897 
10898     silentSpillAllRegisters(InvalidGPRReg);
10899     callOperation(operationWriteBarrierSlowPath, baseGPR);
10900     silentFillAllRegisters();
10901 
10902     ok.link(&amp;m_jit);
10903 
10904     noResult(node);
10905 }
10906 
10907 void SpeculativeJIT::compilePutAccessorById(Node* node)
10908 {
10909     SpeculateCellOperand base(this, node-&gt;child1());
10910     SpeculateCellOperand accessor(this, node-&gt;child2());
10911 
</pre>
<hr />
<pre>
10994 {
10995     SpeculateCellOperand scope(this, node-&gt;child1());
10996     GPRReg scopeGPR = scope.gpr();
10997     flushRegisters();
10998     JSValueRegsFlushedCallResult result(this);
10999     JSValueRegs resultRegs = result.regs();
11000     callOperation(operationGetDynamicVar, resultRegs, scopeGPR, identifierUID(node-&gt;identifierNumber()), node-&gt;getPutInfo());
11001     m_jit.exceptionCheck();
11002     jsValueResult(resultRegs, node);
11003 }
11004 
11005 void SpeculativeJIT::compilePutDynamicVar(Node* node)
11006 {
11007     SpeculateCellOperand scope(this, node-&gt;child1());
11008     JSValueOperand value(this, node-&gt;child2());
11009 
11010     GPRReg scopeGPR = scope.gpr();
11011     JSValueRegs valueRegs = value.jsValueRegs();
11012 
11013     flushRegisters();
<span class="line-modified">11014     callOperation(operationPutDynamicVar, NoResult, scopeGPR, valueRegs, identifierUID(node-&gt;identifierNumber()), node-&gt;getPutInfo());</span>
11015     m_jit.exceptionCheck();
11016     noResult(node);
11017 }
11018 
11019 void SpeculativeJIT::compileGetClosureVar(Node* node)
11020 {
11021     SpeculateCellOperand base(this, node-&gt;child1());
11022     JSValueRegsTemporary result(this);
11023 
11024     GPRReg baseGPR = base.gpr();
11025     JSValueRegs resultRegs = result.regs();
11026 
11027     m_jit.loadValue(JITCompiler::Address(baseGPR, JSLexicalEnvironment::offsetOfVariable(node-&gt;scopeOffset())), resultRegs);
11028     jsValueResult(resultRegs, node);
11029 }
11030 
11031 void SpeculativeJIT::compilePutClosureVar(Node* node)
11032 {
11033     SpeculateCellOperand base(this, node-&gt;child1());
11034     JSValueOperand value(this, node-&gt;child2());
</pre>
<hr />
<pre>
11064     SpeculateCellOperand regExp(this, node-&gt;child1());
11065     JSValueRegsTemporary result(this);
11066     GPRReg regExpGPR = regExp.gpr();
11067     JSValueRegs resultRegs = result.regs();
11068     speculateRegExpObject(node-&gt;child1(), regExpGPR);
11069     m_jit.loadValue(JITCompiler::Address(regExpGPR, RegExpObject::offsetOfLastIndex()), resultRegs);
11070     jsValueResult(resultRegs, node);
11071 }
11072 
11073 void SpeculativeJIT::compileSetRegExpObjectLastIndex(Node* node)
11074 {
11075     SpeculateCellOperand regExp(this, node-&gt;child1());
11076     JSValueOperand value(this, node-&gt;child2());
11077     GPRReg regExpGPR = regExp.gpr();
11078     JSValueRegs valueRegs = value.jsValueRegs();
11079 
11080     if (!node-&gt;ignoreLastIndexIsWritable()) {
11081         speculateRegExpObject(node-&gt;child1(), regExpGPR);
11082         speculationCheck(
11083             ExoticObjectMode, JSValueRegs(), nullptr,
<span class="line-modified">11084             m_jit.branchTest8(</span>
<span class="line-modified">11085                 JITCompiler::Zero,</span>
<span class="line-modified">11086                 JITCompiler::Address(regExpGPR, RegExpObject::offsetOfLastIndexIsWritable())));</span>

11087     }
11088 
11089     m_jit.storeValue(valueRegs, JITCompiler::Address(regExpGPR, RegExpObject::offsetOfLastIndex()));
11090     noResult(node);
11091 }
11092 
11093 void SpeculativeJIT::compileRegExpExec(Node* node)
11094 {
11095     bool sample = false;
11096     if (sample)
11097         m_jit.incrementSuperSamplerCount();
11098 
11099     SpeculateCellOperand globalObject(this, node-&gt;child1());
11100     GPRReg globalObjectGPR = globalObject.gpr();
11101 
11102     if (node-&gt;child2().useKind() == RegExpObjectUse) {
11103         if (node-&gt;child3().useKind() == StringUse) {
11104             SpeculateCellOperand base(this, node-&gt;child2());
11105             SpeculateCellOperand argument(this, node-&gt;child3());
11106             GPRReg baseGPR = base.gpr();
</pre>
<hr />
<pre>
11201     JSValueRegs argumentRegs = argument.jsValueRegs();
11202 
11203     flushRegisters();
11204     GPRFlushedCallResult result(this);
11205     callOperation(operationRegExpTestGeneric, result.gpr(), globalObjectGPR, baseRegs, argumentRegs);
11206     m_jit.exceptionCheck();
11207 
11208     unblessedBooleanResult(result.gpr(), node);
11209 }
11210 
11211 void SpeculativeJIT::compileStringReplace(Node* node)
11212 {
11213     ASSERT(node-&gt;op() == StringReplace || node-&gt;op() == StringReplaceRegExp);
11214     bool sample = false;
11215     if (sample)
11216         m_jit.incrementSuperSamplerCount();
11217 
11218     if (node-&gt;child1().useKind() == StringUse
11219         &amp;&amp; node-&gt;child2().useKind() == RegExpObjectUse
11220         &amp;&amp; node-&gt;child3().useKind() == StringUse) {
<span class="line-modified">11221         if (JSString* replace = node-&gt;child3()-&gt;dynamicCastConstant&lt;JSString*&gt;(*m_jit.vm())) {</span>
11222             if (!replace-&gt;length()) {
11223                 SpeculateCellOperand string(this, node-&gt;child1());
11224                 SpeculateCellOperand regExp(this, node-&gt;child2());
11225                 GPRReg stringGPR = string.gpr();
11226                 GPRReg regExpGPR = regExp.gpr();
11227                 speculateString(node-&gt;child1(), stringGPR);
11228                 speculateRegExpObject(node-&gt;child2(), regExpGPR);
11229 
11230                 flushRegisters();
11231                 GPRFlushedCallResult result(this);
11232                 callOperation(operationStringProtoFuncReplaceRegExpEmptyStr, result.gpr(), stringGPR, regExpGPR);
11233                 m_jit.exceptionCheck();
11234                 cellResult(result.gpr(), node);
11235                 if (sample)
11236                     m_jit.decrementSuperSamplerCount();
11237                 return;
11238             }
11239         }
11240 
11241         SpeculateCellOperand string(this, node-&gt;child1());
</pre>
<hr />
<pre>
11335     JSValueRegs resultRegs = result.regs();
11336     callOperation(
11337         operationRegExpMatchFastString, resultRegs,
11338         globalObjectGPR, baseGPR, argumentGPR);
11339     m_jit.exceptionCheck();
11340 
11341     jsValueResult(resultRegs, node);
11342 }
11343 
11344 void SpeculativeJIT::compileLazyJSConstant(Node* node)
11345 {
11346     JSValueRegsTemporary result(this);
11347     JSValueRegs resultRegs = result.regs();
11348     node-&gt;lazyJSValue().emit(m_jit, resultRegs);
11349     jsValueResult(resultRegs, node);
11350 }
11351 
11352 void SpeculativeJIT::compileMaterializeNewObject(Node* node)
11353 {
11354     RegisteredStructure structure = node-&gt;structureSet().at(0);
<span class="line-modified">11355     ASSERT(m_jit.graph().varArgChild(node, 0)-&gt;dynamicCastConstant&lt;Structure*&gt;(*m_jit.vm()) == structure.get());</span>
11356 
11357     ObjectMaterializationData&amp; data = node-&gt;objectMaterializationData();
11358 
11359     IndexingType indexingType = structure-&gt;indexingType();
11360     bool hasIndexingHeader = hasIndexedProperties(indexingType);
11361     int32_t publicLength = 0;
11362     int32_t vectorLength = 0;
11363 
11364     if (hasIndexingHeader) {
11365         for (unsigned i = data.m_properties.size(); i--;) {
11366             Edge edge = m_jit.graph().varArgChild(node, 1 + i);
11367             switch (data.m_properties[i].kind()) {
11368             case PublicLengthPLoc:
11369                 publicLength = edge-&gt;asInt32();
11370                 break;
11371             case VectorLengthPLoc:
11372                 vectorLength = edge-&gt;asInt32();
11373                 break;
11374             default:
11375                 break;
</pre>
<hr />
<pre>
11623     default:
11624         RELEASE_ASSERT_NOT_REACHED();
11625     }
11626 
11627     noResult(node, UseChildrenCalledExplicitly);
11628 }
11629 
11630 void SpeculativeJIT::emitAllocateButterfly(GPRReg storageResultGPR, GPRReg sizeGPR, GPRReg scratch1, GPRReg scratch2, GPRReg scratch3, MacroAssembler::JumpList&amp; slowCases)
11631 {
11632     RELEASE_ASSERT(RegisterSet(storageResultGPR, sizeGPR, scratch1, scratch2, scratch3).numberOfSetGPRs() == 5);
11633     ASSERT((1 &lt;&lt; 3) == sizeof(JSValue));
11634     m_jit.zeroExtend32ToPtr(sizeGPR, scratch1);
11635     m_jit.lshift32(TrustedImm32(3), scratch1);
11636     m_jit.add32(TrustedImm32(sizeof(IndexingHeader)), scratch1, scratch2);
11637 #if !ASSERT_DISABLED
11638     MacroAssembler::Jump didNotOverflow = m_jit.branch32(MacroAssembler::AboveOrEqual, scratch2, sizeGPR);
11639     m_jit.abortWithReason(UncheckedOverflow);
11640     didNotOverflow.link(&amp;m_jit);
11641 #endif
11642     m_jit.emitAllocateVariableSized(
<span class="line-modified">11643         storageResultGPR, m_jit.vm()-&gt;jsValueGigacageAuxiliarySpace, scratch2, scratch1, scratch3, slowCases);</span>
11644     m_jit.addPtr(TrustedImm32(sizeof(IndexingHeader)), storageResultGPR);
11645 
11646     m_jit.store32(sizeGPR, MacroAssembler::Address(storageResultGPR, Butterfly::offsetOfPublicLength()));
11647     m_jit.store32(sizeGPR, MacroAssembler::Address(storageResultGPR, Butterfly::offsetOfVectorLength()));
11648 }
11649 
11650 void SpeculativeJIT::compileNormalizeMapKey(Node* node)
11651 {
11652     ASSERT(node-&gt;child1().useKind() == UntypedUse);
11653     JSValueOperand key(this, node-&gt;child1());
11654     JSValueRegsTemporary result(this, Reuse, key);
11655     GPRTemporary scratch(this);
11656     FPRTemporary doubleValue(this);
11657     FPRTemporary temp(this);
11658 
11659     JSValueRegs keyRegs = key.jsValueRegs();
11660     JSValueRegs resultRegs = result.regs();
11661     GPRReg scratchGPR = scratch.gpr();
11662     FPRReg doubleValueFPR = doubleValue.fpr();
11663     FPRReg tempFPR = temp.fpr();
11664 
11665     CCallHelpers::JumpList passThroughCases;

11666 
11667     passThroughCases.append(m_jit.branchIfNotNumber(keyRegs, scratchGPR));
11668     passThroughCases.append(m_jit.branchIfInt32(keyRegs));
11669 
11670 #if USE(JSVALUE64)
11671     m_jit.unboxDoubleWithoutAssertions(keyRegs.gpr(), scratchGPR, doubleValueFPR);
11672 #else
11673     unboxDouble(keyRegs.tagGPR(), keyRegs.payloadGPR(), doubleValueFPR, tempFPR);
11674 #endif
<span class="line-modified">11675     passThroughCases.append(m_jit.branchIfNaN(doubleValueFPR));</span>


11676 

11677     m_jit.truncateDoubleToInt32(doubleValueFPR, scratchGPR);
11678     m_jit.convertInt32ToDouble(scratchGPR, tempFPR);
11679     passThroughCases.append(m_jit.branchDouble(JITCompiler::DoubleNotEqual, doubleValueFPR, tempFPR));
11680 
11681     m_jit.boxInt32(scratchGPR, resultRegs);
<span class="line-modified">11682     auto done = m_jit.jump();</span>
11683 
11684     passThroughCases.link(&amp;m_jit);
11685     m_jit.moveValueRegs(keyRegs, resultRegs);
11686 
<span class="line-modified">11687     done.link(&amp;m_jit);</span>
11688     jsValueResult(resultRegs, node);
11689 }
11690 
11691 void SpeculativeJIT::compileGetMapBucketHead(Node* node)
11692 {
11693     SpeculateCellOperand map(this, node-&gt;child1());
11694     GPRTemporary bucket(this);
11695 
11696     GPRReg mapGPR = map.gpr();
11697     GPRReg bucketGPR = bucket.gpr();
11698 
11699     if (node-&gt;child1().useKind() == MapObjectUse)
11700         speculateMapObject(node-&gt;child1(), mapGPR);
11701     else if (node-&gt;child1().useKind() == SetObjectUse)
11702         speculateSetObject(node-&gt;child1(), mapGPR);
11703     else
11704         RELEASE_ASSERT_NOT_REACHED();
11705 
11706     ASSERT(HashMapImpl&lt;HashMapBucket&lt;HashMapBucketDataKey&gt;&gt;::offsetOfHead() == HashMapImpl&lt;HashMapBucket&lt;HashMapBucketDataKeyValue&gt;&gt;::offsetOfHead());
11707     m_jit.loadPtr(MacroAssembler::Address(mapGPR, HashMapImpl&lt;HashMapBucket&lt;HashMapBucketDataKey&gt;&gt;::offsetOfHead()), bucketGPR);
</pre>
<hr />
<pre>
11716     GPRReg bucketGPR = bucket.gpr();
11717     GPRReg resultGPR = result.gpr();
11718 
11719     ASSERT(HashMapBucket&lt;HashMapBucketDataKey&gt;::offsetOfNext() == HashMapBucket&lt;HashMapBucketDataKeyValue&gt;::offsetOfNext());
11720     ASSERT(HashMapBucket&lt;HashMapBucketDataKey&gt;::offsetOfKey() == HashMapBucket&lt;HashMapBucketDataKeyValue&gt;::offsetOfKey());
11721     m_jit.loadPtr(MacroAssembler::Address(bucketGPR, HashMapBucket&lt;HashMapBucketDataKeyValue&gt;::offsetOfNext()), resultGPR);
11722 
11723     MacroAssembler::Label loop = m_jit.label();
11724     auto notBucket = m_jit.branchTestPtr(MacroAssembler::Zero, resultGPR);
11725 #if USE(JSVALUE32_64)
11726     auto done = m_jit.branch32(MacroAssembler::NotEqual, MacroAssembler::Address(resultGPR, HashMapBucket&lt;HashMapBucketDataKeyValue&gt;::offsetOfKey() + TagOffset), TrustedImm32(JSValue::EmptyValueTag));
11727 #else
11728     auto done = m_jit.branchTest64(MacroAssembler::NonZero, MacroAssembler::Address(resultGPR, HashMapBucket&lt;HashMapBucketDataKeyValue&gt;::offsetOfKey()));
11729 #endif
11730     m_jit.loadPtr(MacroAssembler::Address(resultGPR, HashMapBucket&lt;HashMapBucketDataKeyValue&gt;::offsetOfNext()), resultGPR);
11731     m_jit.jump().linkTo(loop, &amp;m_jit);
11732 
11733     notBucket.link(&amp;m_jit);
11734     JSCell* sentinel = nullptr;
11735     if (node-&gt;bucketOwnerType() == BucketOwnerType::Map)
<span class="line-modified">11736         sentinel = m_jit.vm()-&gt;sentinelMapBucket();</span>
11737     else {
11738         ASSERT(node-&gt;bucketOwnerType() == BucketOwnerType::Set);
<span class="line-modified">11739         sentinel = m_jit.vm()-&gt;sentinelSetBucket();</span>
11740     }
11741     m_jit.move(TrustedImmPtr::weakPointer(m_jit.graph(), sentinel), resultGPR);
11742     done.link(&amp;m_jit);
11743 
11744     cellResult(resultGPR, node);
11745 }
11746 
11747 void SpeculativeJIT::compileLoadKeyFromMapBucket(Node* node)
11748 {
11749     SpeculateCellOperand bucket(this, node-&gt;child1());
11750     JSValueRegsTemporary result(this);
11751 
11752     GPRReg bucketGPR = bucket.gpr();
11753     JSValueRegs resultRegs = result.regs();
11754 
11755     m_jit.loadValue(MacroAssembler::Address(bucketGPR, HashMapBucket&lt;HashMapBucketDataKeyValue&gt;::offsetOfKey()), resultRegs);
11756     jsValueResult(resultRegs, node);
11757 }
11758 
11759 void SpeculativeJIT::compileLoadValueFromMapBucket(Node* node)
</pre>
<hr />
<pre>
12262 
12263 void SpeculativeJIT::compileToThis(Node* node)
12264 {
12265     ASSERT(node-&gt;child1().useKind() == UntypedUse);
12266     JSValueOperand thisValue(this, node-&gt;child1());
12267     JSValueRegsTemporary temp(this);
12268 
12269     JSValueRegs thisValueRegs = thisValue.jsValueRegs();
12270     JSValueRegs tempRegs = temp.regs();
12271 
12272     MacroAssembler::JumpList slowCases;
12273     slowCases.append(m_jit.branchIfNotCell(thisValueRegs));
12274     slowCases.append(
12275         m_jit.branchTest8(
12276             MacroAssembler::NonZero,
12277             MacroAssembler::Address(thisValueRegs.payloadGPR(), JSCell::typeInfoFlagsOffset()),
12278             MacroAssembler::TrustedImm32(OverridesToThis)));
12279     m_jit.moveValueRegs(thisValueRegs, tempRegs);
12280 
12281     J_JITOperation_EJ function;
<span class="line-modified">12282     if (m_jit.graph().executableFor(node-&gt;origin.semantic)-&gt;isStrictMode())</span>
12283         function = operationToThisStrict;
12284     else
12285         function = operationToThis;
12286     addSlowPathGenerator(slowPathCall(slowCases, this, function, tempRegs, thisValueRegs));
12287 
12288     jsValueResult(tempRegs, node);
12289 }
12290 
12291 void SpeculativeJIT::compileObjectKeys(Node* node)
12292 {
12293     switch (node-&gt;child1().useKind()) {
12294     case ObjectUse: {
12295         if (m_graph.isWatchingHavingABadTimeWatchpoint(node)) {
12296             SpeculateCellOperand object(this, node-&gt;child1());
12297             GPRTemporary structure(this);
12298             GPRTemporary scratch(this);
12299             GPRTemporary scratch2(this);
12300             GPRTemporary scratch3(this);
12301             GPRTemporary result(this);
12302 
12303             GPRReg objectGPR = object.gpr();
12304             GPRReg structureGPR = structure.gpr();
12305             GPRReg scratchGPR = scratch.gpr();
12306             GPRReg scratch2GPR = scratch2.gpr();
12307             GPRReg scratch3GPR = scratch3.gpr();
12308             GPRReg resultGPR = result.gpr();
12309 
12310             speculateObject(node-&gt;child1(), objectGPR);
12311 
12312             CCallHelpers::JumpList slowCases;
<span class="line-modified">12313             m_jit.emitLoadStructure(*m_jit.vm(), objectGPR, structureGPR, scratchGPR);</span>
12314             m_jit.loadPtr(CCallHelpers::Address(structureGPR, Structure::previousOrRareDataOffset()), scratchGPR);
12315 
12316             slowCases.append(m_jit.branchTestPtr(CCallHelpers::Zero, scratchGPR));
<span class="line-modified">12317             slowCases.append(m_jit.branch32(CCallHelpers::Equal, CCallHelpers::Address(scratchGPR, JSCell::structureIDOffset()), TrustedImm32(bitwise_cast&lt;int32_t&gt;(m_jit.vm()-&gt;structureStructure-&gt;structureID()))));</span>
12318 
12319             m_jit.loadPtr(CCallHelpers::Address(scratchGPR, StructureRareData::offsetOfCachedOwnKeys()), scratchGPR);
12320 
12321             ASSERT(bitwise_cast&lt;uintptr_t&gt;(StructureRareData::cachedOwnKeysSentinel()) == 1);
12322             slowCases.append(m_jit.branchPtr(CCallHelpers::BelowOrEqual, scratchGPR, TrustedImmPtr(bitwise_cast&lt;void*&gt;(StructureRareData::cachedOwnKeysSentinel()))));
12323 
12324             MacroAssembler::JumpList slowButArrayBufferCases;
12325 
12326             JSGlobalObject* globalObject = m_jit.graph().globalObjectFor(node-&gt;origin.semantic);
12327             RegisteredStructure arrayStructure = m_jit.graph().registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(CopyOnWriteArrayWithContiguous));
12328 
12329             m_jit.move(scratchGPR, scratch3GPR);
12330             m_jit.addPtr(TrustedImmPtr(JSImmutableButterfly::offsetOfData()), scratchGPR);
12331 
12332             emitAllocateJSObject&lt;JSArray&gt;(resultGPR, TrustedImmPtr(arrayStructure), scratchGPR, structureGPR, scratch2GPR, slowButArrayBufferCases);
12333 
12334             addSlowPathGenerator(slowPathCall(slowButArrayBufferCases, this, operationNewArrayBuffer, resultGPR, arrayStructure, scratch3GPR));
12335 
12336             addSlowPathGenerator(slowPathCall(slowCases, this, operationObjectKeysObject, resultGPR, objectGPR));
12337 
</pre>
<hr />
<pre>
12429     GPRTemporary result(this);
12430     GPRTemporary allocator(this);
12431     GPRTemporary structure(this);
12432     GPRTemporary scratch(this);
12433 
12434     GPRReg calleeGPR = callee.gpr();
12435     GPRReg resultGPR = result.gpr();
12436     GPRReg allocatorGPR = allocator.gpr();
12437     GPRReg structureGPR = structure.gpr();
12438     GPRReg scratchGPR = scratch.gpr();
12439     // Rare data is only used to access the allocator &amp; structure
12440     // We can avoid using an additional GPR this way
12441     GPRReg rareDataGPR = structureGPR;
12442     GPRReg inlineCapacityGPR = rareDataGPR;
12443 
12444     MacroAssembler::JumpList slowPath;
12445 
12446     slowPath.append(m_jit.branchIfNotFunction(calleeGPR));
12447     m_jit.loadPtr(JITCompiler::Address(calleeGPR, JSFunction::offsetOfRareData()), rareDataGPR);
12448     slowPath.append(m_jit.branchTestPtr(MacroAssembler::Zero, rareDataGPR));
<span class="line-modified">12449     m_jit.loadPtr(JITCompiler::Address(rareDataGPR, FunctionRareData::offsetOfObjectAllocationProfile() + ObjectAllocationProfile::offsetOfAllocator()), allocatorGPR);</span>
<span class="line-modified">12450     m_jit.loadPtr(JITCompiler::Address(rareDataGPR, FunctionRareData::offsetOfObjectAllocationProfile() + ObjectAllocationProfile::offsetOfStructure()), structureGPR);</span>
12451 
12452     auto butterfly = TrustedImmPtr(nullptr);
12453     emitAllocateJSObject(resultGPR, JITAllocator::variable(), allocatorGPR, structureGPR, butterfly, scratchGPR, slowPath);
12454 
<span class="line-modified">12455     m_jit.loadPtr(JITCompiler::Address(calleeGPR, JSFunction::offsetOfRareData()), rareDataGPR);</span>
<span class="line-removed">12456     m_jit.load32(JITCompiler::Address(rareDataGPR, FunctionRareData::offsetOfObjectAllocationProfile() + ObjectAllocationProfile::offsetOfInlineCapacity()), inlineCapacityGPR);</span>
12457     m_jit.emitInitializeInlineStorage(resultGPR, inlineCapacityGPR);
<span class="line-modified">12458     m_jit.mutatorFence(*m_jit.vm());</span>
12459 
12460     addSlowPathGenerator(slowPathCall(slowPath, this, operationCreateThis, resultGPR, calleeGPR, node-&gt;inlineCapacity()));
12461 
12462     cellResult(resultGPR, node);
12463 }
12464 
12465 void SpeculativeJIT::compileNewObject(Node* node)
12466 {
12467     GPRTemporary result(this);
12468     GPRTemporary allocator(this);
12469     GPRTemporary scratch(this);
12470 
12471     GPRReg resultGPR = result.gpr();
12472     GPRReg allocatorGPR = allocator.gpr();
12473     GPRReg scratchGPR = scratch.gpr();
12474 
12475     MacroAssembler::JumpList slowPath;
12476 
12477     RegisteredStructure structure = node-&gt;structure();
12478     size_t allocationSize = JSFinalObject::allocationSize(structure-&gt;inlineCapacity());
<span class="line-modified">12479     Allocator allocatorValue = allocatorForNonVirtualConcurrently&lt;JSFinalObject&gt;(*m_jit.vm(), allocationSize, AllocatorForMode::AllocatorIfExists);</span>
12480     if (!allocatorValue)
12481         slowPath.append(m_jit.jump());
12482     else {
12483         auto butterfly = TrustedImmPtr(nullptr);
12484         emitAllocateJSObject(resultGPR, JITAllocator::constant(allocatorValue), allocatorGPR, TrustedImmPtr(structure), butterfly, scratchGPR, slowPath);
12485         m_jit.emitInitializeInlineStorage(resultGPR, structure-&gt;inlineCapacity());
<span class="line-modified">12486         m_jit.mutatorFence(*m_jit.vm());</span>
12487     }
12488 
12489     addSlowPathGenerator(slowPathCall(slowPath, this, operationNewObject, resultGPR, structure));
12490 
12491     cellResult(resultGPR, node);
12492 }
12493 
12494 void SpeculativeJIT::compileToPrimitive(Node* node)
12495 {
12496     DFG_ASSERT(m_jit.graph(), node, node-&gt;child1().useKind() == UntypedUse, node-&gt;child1().useKind());
12497     JSValueOperand argument(this, node-&gt;child1());
12498     JSValueRegsTemporary result(this, Reuse, argument);
12499 
12500     JSValueRegs argumentRegs = argument.jsValueRegs();
12501     JSValueRegs resultRegs = result.regs();
12502 
12503     argument.use();
12504 
12505     MacroAssembler::Jump alreadyPrimitive = m_jit.branchIfNotCell(argumentRegs);
12506     MacroAssembler::Jump notPrimitive = m_jit.branchIfObject(argumentRegs.payloadGPR());
</pre>
<hr />
<pre>
12509     m_jit.moveValueRegs(argumentRegs, resultRegs);
12510 
12511     addSlowPathGenerator(slowPathCall(notPrimitive, this, operationToPrimitive, resultRegs, argumentRegs));
12512 
12513     jsValueResult(resultRegs, node, DataFormatJS, UseChildrenCalledExplicitly);
12514 }
12515 
12516 void SpeculativeJIT::compileLogShadowChickenPrologue(Node* node)
12517 {
12518     flushRegisters();
12519     prepareForExternalCall();
12520     m_jit.emitStoreCodeOrigin(node-&gt;origin.semantic);
12521 
12522     GPRTemporary scratch1(this, GPRInfo::nonArgGPR0); // This must be a non-argument GPR.
12523     GPRReg scratch1Reg = scratch1.gpr();
12524     GPRTemporary scratch2(this);
12525     GPRReg scratch2Reg = scratch2.gpr();
12526     GPRTemporary shadowPacket(this);
12527     GPRReg shadowPacketReg = shadowPacket.gpr();
12528 
<span class="line-modified">12529     m_jit.ensureShadowChickenPacket(*m_jit.vm(), shadowPacketReg, scratch1Reg, scratch2Reg);</span>
12530 
12531     SpeculateCellOperand scope(this, node-&gt;child1());
12532     GPRReg scopeReg = scope.gpr();
12533 
12534     m_jit.logShadowChickenProloguePacket(shadowPacketReg, scratch1Reg, scopeReg);
12535     noResult(node);
12536 }
12537 
12538 void SpeculativeJIT::compileLogShadowChickenTail(Node* node)
12539 {
12540     flushRegisters();
12541     prepareForExternalCall();
12542     CallSiteIndex callSiteIndex = m_jit.emitStoreCodeOrigin(node-&gt;origin.semantic);
12543 
12544     GPRTemporary scratch1(this, GPRInfo::nonArgGPR0); // This must be a non-argument GPR.
12545     GPRReg scratch1Reg = scratch1.gpr();
12546     GPRTemporary scratch2(this);
12547     GPRReg scratch2Reg = scratch2.gpr();
12548     GPRTemporary shadowPacket(this);
12549     GPRReg shadowPacketReg = shadowPacket.gpr();
12550 
<span class="line-modified">12551     m_jit.ensureShadowChickenPacket(*m_jit.vm(), shadowPacketReg, scratch1Reg, scratch2Reg);</span>
12552 
12553     JSValueOperand thisValue(this, node-&gt;child1());
12554     JSValueRegs thisRegs = thisValue.jsValueRegs();
12555     SpeculateCellOperand scope(this, node-&gt;child2());
12556     GPRReg scopeReg = scope.gpr();
12557 
12558     m_jit.logShadowChickenTailPacket(shadowPacketReg, thisRegs, scopeReg, m_jit.codeBlock(), callSiteIndex);
12559     noResult(node);
12560 }
12561 
12562 void SpeculativeJIT::compileSetAdd(Node* node)
12563 {
12564     SpeculateCellOperand set(this, node-&gt;child1());
12565     JSValueOperand key(this, node-&gt;child2());
12566     SpeculateInt32Operand hash(this, node-&gt;child3());
12567 
12568     GPRReg setGPR = set.gpr();
12569     JSValueRegs keyRegs = key.jsValueRegs();
12570     GPRReg hashGPR = hash.gpr();
12571 
</pre>
<hr />
<pre>
12751 
12752         GPRReg objectGPR = object.gpr();
12753         GPRReg tempGPR = temp.gpr();
12754         GPRReg temp2GPR = temp2.gpr();
12755 
12756         switch (node-&gt;child1().useKind()) {
12757         case ArrayUse:
12758             speculateArray(node-&gt;child1(), objectGPR);
12759             break;
12760         case FunctionUse:
12761             speculateFunction(node-&gt;child1(), objectGPR);
12762             break;
12763         case FinalObjectUse:
12764             speculateFinalObject(node-&gt;child1(), objectGPR);
12765             break;
12766         default:
12767             RELEASE_ASSERT_NOT_REACHED();
12768             break;
12769         }
12770 
<span class="line-modified">12771         m_jit.emitLoadStructure(*m_jit.vm(), objectGPR, tempGPR, temp2GPR);</span>
12772 
12773         AbstractValue&amp; value = m_state.forNode(node-&gt;child1());
12774         if ((value.m_type &amp;&amp; !(value.m_type &amp; ~SpecObject)) &amp;&amp; value.m_structure.isFinite()) {
12775             bool hasPolyProto = false;
12776             bool hasMonoProto = false;
12777             value.m_structure.forEach([&amp;] (RegisteredStructure structure) {
12778                 if (structure-&gt;hasPolyProto())
12779                     hasPolyProto = true;
12780                 else
12781                     hasMonoProto = true;
12782             });
12783 
12784             if (hasMonoProto &amp;&amp; !hasPolyProto) {
12785 #if USE(JSVALUE64)
12786                 m_jit.load64(MacroAssembler::Address(tempGPR, Structure::prototypeOffset()), tempGPR);
12787                 jsValueResult(tempGPR, node);
12788 #else
12789                 m_jit.load32(MacroAssembler::Address(tempGPR, Structure::prototypeOffset() + TagOffset), temp2GPR);
12790                 m_jit.load32(MacroAssembler::Address(tempGPR, Structure::prototypeOffset() + PayloadOffset), tempGPR);
12791                 jsValueResult(temp2GPR, tempGPR, node);
</pre>
<hr />
<pre>
12952 
12953 #if USE(JSVALUE64)
12954     JSValueRegs emptyValueRegs(scratchGPR);
12955     if (hasDouble(indexingType))
12956         m_jit.move(TrustedImm64(bitwise_cast&lt;int64_t&gt;(PNaN)), emptyValueRegs.gpr());
12957     else
12958         m_jit.move(TrustedImm64(JSValue::encode(JSValue())), emptyValueRegs.gpr());
12959 #else
12960     JSValueRegs emptyValueRegs(scratchGPR, scratch2GPR);
12961     if (hasDouble(indexingType))
12962         m_jit.moveValue(JSValue(JSValue::EncodeAsDouble, PNaN), emptyValueRegs);
12963     else
12964         m_jit.moveValue(JSValue(), emptyValueRegs);
12965 #endif
12966     emitInitializeButterfly(storageGPR, sizeGPR, emptyValueRegs, resultGPR);
12967 
12968     RegisteredStructure structure = m_jit.graph().registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(indexingType));
12969 
12970     emitAllocateJSObject&lt;JSArray&gt;(resultGPR, TrustedImmPtr(structure), storageGPR, scratchGPR, scratch2GPR, slowCases);
12971 
<span class="line-modified">12972     m_jit.mutatorFence(*m_jit.vm());</span>
12973 
<span class="line-modified">12974     addSlowPathGenerator(std::make_unique&lt;CallArrayAllocatorWithVariableSizeSlowPathGenerator&gt;(</span>
12975         slowCases, this, operationNewArrayWithSize, resultGPR,
12976         structure,
12977         shouldConvertLargeSizeToArrayStorage ? m_jit.graph().registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithArrayStorage)) : structure,
12978         sizeGPR, storageGPR));
12979 }
12980 
12981 void SpeculativeJIT::compileHasIndexedProperty(Node* node)
12982 {
12983     SpeculateCellOperand base(this, m_graph.varArgChild(node, 0));
12984     SpeculateStrictInt32Operand index(this, m_graph.varArgChild(node, 1));
12985     GPRTemporary result(this);
12986 
12987     GPRReg baseGPR = base.gpr();
12988     GPRReg indexGPR = index.gpr();
12989     GPRReg resultGPR = result.gpr();
12990 
12991     MacroAssembler::JumpList slowCases;
12992     ArrayMode mode = node-&gt;arrayMode();
12993     switch (mode.type()) {
12994     case Array::Int32:
</pre>
<hr />
<pre>
13056         slowCases.append(m_jit.branchIfEmpty(scratchGPR));
13057 #endif
13058         m_jit.move(TrustedImm32(1), resultGPR);
13059         break;
13060     }
13061     default: {
13062         slowCases.append(m_jit.jump());
13063         break;
13064     }
13065     }
13066 
13067     addSlowPathGenerator(slowPathCall(slowCases, this, operationHasIndexedPropertyByInt, resultGPR, baseGPR, indexGPR, static_cast&lt;int32_t&gt;(node-&gt;internalMethodType())));
13068 
13069     unblessedBooleanResult(resultGPR, node);
13070 }
13071 
13072 void SpeculativeJIT::compileGetDirectPname(Node* node)
13073 {
13074     Edge&amp; baseEdge = m_jit.graph().varArgChild(node, 0);
13075     Edge&amp; propertyEdge = m_jit.graph().varArgChild(node, 1);

13076 
13077     SpeculateCellOperand base(this, baseEdge);
13078     SpeculateCellOperand property(this, propertyEdge);
13079     GPRReg baseGPR = base.gpr();
13080     GPRReg propertyGPR = property.gpr();
13081 
13082 #if CPU(X86)
13083     // Not enough registers on X86 for this code, so always use the slow path.

13084     flushRegisters();
13085     JSValueRegsFlushedCallResult result(this);
13086     JSValueRegs resultRegs = result.regs();
13087     callOperation(operationGetByValCell, resultRegs, baseGPR, CCallHelpers::CellValue(propertyGPR));
13088     m_jit.exceptionCheck();
13089     jsValueResult(resultRegs, node);
13090 #else
<span class="line-removed">13091     Edge&amp; indexEdge = m_jit.graph().varArgChild(node, 2);</span>
13092     Edge&amp; enumeratorEdge = m_jit.graph().varArgChild(node, 3);
13093     SpeculateStrictInt32Operand index(this, indexEdge);
13094     SpeculateCellOperand enumerator(this, enumeratorEdge);
13095     GPRTemporary scratch(this);
13096     JSValueRegsTemporary result(this);
13097 
13098     GPRReg indexGPR = index.gpr();
13099     GPRReg enumeratorGPR = enumerator.gpr();
13100     GPRReg scratchGPR = scratch.gpr();
13101     JSValueRegs resultRegs = result.regs();
13102 
13103     MacroAssembler::JumpList slowPath;
13104 
13105     // Check the structure
13106     m_jit.load32(MacroAssembler::Address(baseGPR, JSCell::structureIDOffset()), scratchGPR);
13107     slowPath.append(
13108         m_jit.branch32(
13109             MacroAssembler::NotEqual,
13110             scratchGPR,
13111             MacroAssembler::Address(
</pre>
<hr />
<pre>
13178     TypeLocation* cachedTypeLocation = node-&gt;typeLocation();
13179     // Compile in a predictive type check, if possible, to see if we can skip writing to the log.
13180     // These typechecks are inlined to match those of the 64-bit JSValue type checks.
13181     if (cachedTypeLocation-&gt;m_lastSeenType == TypeUndefined)
13182         jumpToEnd.append(m_jit.branchIfUndefined(valueRegs));
13183     else if (cachedTypeLocation-&gt;m_lastSeenType == TypeNull)
13184         jumpToEnd.append(m_jit.branchIfNull(valueRegs));
13185     else if (cachedTypeLocation-&gt;m_lastSeenType == TypeBoolean)
13186         jumpToEnd.append(m_jit.branchIfBoolean(valueRegs, scratch1GPR));
13187     else if (cachedTypeLocation-&gt;m_lastSeenType == TypeAnyInt)
13188         jumpToEnd.append(m_jit.branchIfInt32(valueRegs));
13189     else if (cachedTypeLocation-&gt;m_lastSeenType == TypeNumber)
13190         jumpToEnd.append(m_jit.branchIfNumber(valueRegs, scratch1GPR));
13191     else if (cachedTypeLocation-&gt;m_lastSeenType == TypeString) {
13192         MacroAssembler::Jump isNotCell = m_jit.branchIfNotCell(valueRegs);
13193         jumpToEnd.append(m_jit.branchIfString(valueRegs.payloadGPR()));
13194         isNotCell.link(&amp;m_jit);
13195     }
13196 
13197     // Load the TypeProfilerLog into Scratch2.
<span class="line-modified">13198     TypeProfilerLog* cachedTypeProfilerLog = m_jit.vm()-&gt;typeProfilerLog();</span>
13199     m_jit.move(TrustedImmPtr(cachedTypeProfilerLog), scratch2GPR);
13200 
13201     // Load the next LogEntry into Scratch1.
13202     m_jit.loadPtr(MacroAssembler::Address(scratch2GPR, TypeProfilerLog::currentLogEntryOffset()), scratch1GPR);
13203 
13204     // Store the JSValue onto the log entry.
13205     m_jit.storeValue(valueRegs, MacroAssembler::Address(scratch1GPR, TypeProfilerLog::LogEntry::valueOffset()));
13206 
13207     // Store the structureID of the cell if valueRegs is a cell, otherwise, store 0 on the log entry.
13208     MacroAssembler::Jump isNotCell = m_jit.branchIfNotCell(valueRegs);
13209     m_jit.load32(MacroAssembler::Address(valueRegs.payloadGPR(), JSCell::structureIDOffset()), scratch3GPR);
13210     m_jit.store32(scratch3GPR, MacroAssembler::Address(scratch1GPR, TypeProfilerLog::LogEntry::structureIDOffset()));
13211     MacroAssembler::Jump skipIsCell = m_jit.jump();
13212     isNotCell.link(&amp;m_jit);
13213     m_jit.store32(TrustedImm32(0), MacroAssembler::Address(scratch1GPR, TypeProfilerLog::LogEntry::structureIDOffset()));
13214     skipIsCell.link(&amp;m_jit);
13215 
13216     // Store the typeLocation on the log entry.
13217     m_jit.move(TrustedImmPtr(cachedTypeLocation), scratch3GPR);
13218     m_jit.storePtr(scratch3GPR, MacroAssembler::Address(scratch1GPR, TypeProfilerLog::LogEntry::locationOffset()));
</pre>
<hr />
<pre>
13428         numOpGPRs = 2;
13429     }
13430 
13431 #if CPU(ADDRESS64)
13432     Edge edges[3] = {
13433         node-&gt;child1(),
13434         node-&gt;child2(),
13435         node-&gt;child3()
13436     };
13437 
13438     GPRTemporary result(this);
13439     GPRTemporary allocator(this);
13440     GPRTemporary scratch(this);
13441     GPRTemporary scratch2(this);
13442     GPRReg resultGPR = result.gpr();
13443     GPRReg allocatorGPR = allocator.gpr();
13444     GPRReg scratchGPR = scratch.gpr();
13445     GPRReg scratch2GPR = scratch2.gpr();
13446 
13447     CCallHelpers::JumpList slowPath;
<span class="line-modified">13448     Allocator allocatorValue = allocatorForNonVirtualConcurrently&lt;JSRopeString&gt;(*m_jit.vm(), sizeof(JSRopeString), AllocatorForMode::AllocatorIfExists);</span>
<span class="line-modified">13449     emitAllocateJSCell(resultGPR, JITAllocator::constant(allocatorValue), allocatorGPR, TrustedImmPtr(m_jit.graph().registerStructure(m_jit.vm()-&gt;stringStructure.get())), scratchGPR, slowPath);</span>
<span class="line-removed">13450 </span>
<span class="line-removed">13451     m_jit.orPtr(TrustedImm32(JSString::isRopeInPointer), opGPRs[0], allocatorGPR);</span>
<span class="line-removed">13452     m_jit.storePtr(allocatorGPR, CCallHelpers::Address(resultGPR, JSRopeString::offsetOfFiber0()));</span>
13453 
<span class="line-modified">13454     m_jit.move(opGPRs[1], scratchGPR);</span>
<span class="line-modified">13455     m_jit.store32(scratchGPR, CCallHelpers::Address(resultGPR, JSRopeString::offsetOfFiber1Lower()));</span>
<span class="line-removed">13456     m_jit.rshiftPtr(TrustedImm32(32), scratchGPR);</span>
<span class="line-removed">13457     m_jit.store16(scratchGPR, CCallHelpers::Address(resultGPR, JSRopeString::offsetOfFiber1Upper()));</span>
<span class="line-removed">13458 </span>
<span class="line-removed">13459     if (numOpGPRs == 3) {</span>
<span class="line-removed">13460         m_jit.move(opGPRs[2], scratchGPR);</span>
<span class="line-removed">13461         m_jit.store32(scratchGPR, CCallHelpers::Address(resultGPR, JSRopeString::offsetOfFiber2Lower()));</span>
<span class="line-removed">13462         m_jit.rshiftPtr(TrustedImm32(32), scratchGPR);</span>
<span class="line-removed">13463         m_jit.store16(scratchGPR, CCallHelpers::Address(resultGPR, JSRopeString::offsetOfFiber2Upper()));</span>
<span class="line-removed">13464     } else {</span>
<span class="line-removed">13465         m_jit.storeZero32(CCallHelpers::Address(resultGPR, JSRopeString::offsetOfFiber2Lower()));</span>
<span class="line-removed">13466         m_jit.storeZero16(CCallHelpers::Address(resultGPR, JSRopeString::offsetOfFiber2Upper()));</span>
<span class="line-removed">13467     }</span>
13468 
13469     {
<span class="line-modified">13470         if (JSString* string = edges[0]-&gt;dynamicCastConstant&lt;JSString*&gt;(*m_jit.vm())) {</span>
13471             m_jit.move(TrustedImm32(string-&gt;is8Bit() ? StringImpl::flagIs8Bit() : 0), scratchGPR);
13472             m_jit.move(TrustedImm32(string-&gt;length()), allocatorGPR);
13473         } else {
<span class="line-modified">13474             bool canBeRope = !m_state.forNode(edges[0]).isType(SpecStringIdent);</span>
13475             m_jit.loadPtr(CCallHelpers::Address(opGPRs[0], JSString::offsetOfValue()), scratch2GPR);
13476             CCallHelpers::Jump isRope;
<span class="line-modified">13477             if (canBeRope)</span>
13478                 isRope = m_jit.branchIfRopeStringImpl(scratch2GPR);
13479 
13480             m_jit.load32(CCallHelpers::Address(scratch2GPR, StringImpl::flagsOffset()), scratchGPR);
13481             m_jit.load32(CCallHelpers::Address(scratch2GPR, StringImpl::lengthMemoryOffset()), allocatorGPR);
13482 
<span class="line-modified">13483             if (canBeRope) {</span>
13484                 auto done = m_jit.jump();
13485 
13486                 isRope.link(&amp;m_jit);
<span class="line-modified">13487                 m_jit.load16(CCallHelpers::Address(opGPRs[0], JSRopeString::offsetOfFlags()), scratchGPR);</span>
13488                 m_jit.load32(CCallHelpers::Address(opGPRs[0], JSRopeString::offsetOfLength()), allocatorGPR);
13489                 done.link(&amp;m_jit);
13490             }
13491         }
13492 
13493         if (!ASSERT_DISABLED) {
13494             CCallHelpers::Jump ok = m_jit.branch32(
13495                 CCallHelpers::GreaterThanOrEqual, allocatorGPR, TrustedImm32(0));
13496             m_jit.abortWithReason(DFGNegativeStringLength);
13497             ok.link(&amp;m_jit);
13498         }
13499     }
13500 
13501     for (unsigned i = 1; i &lt; numOpGPRs; ++i) {
<span class="line-modified">13502         if (JSString* string = edges[i]-&gt;dynamicCastConstant&lt;JSString*&gt;(*m_jit.vm())) {</span>
13503             m_jit.and32(TrustedImm32(string-&gt;is8Bit() ? StringImpl::flagIs8Bit() : 0), scratchGPR);
13504             speculationCheck(
13505                 Uncountable, JSValueSource(), nullptr,
13506                 m_jit.branchAdd32(
13507                     CCallHelpers::Overflow,
13508                     TrustedImm32(string-&gt;length()), allocatorGPR));
13509         } else {
<span class="line-modified">13510             bool canBeRope = !m_state.forNode(edges[i]).isType(SpecStringIdent);</span>
13511             m_jit.loadPtr(CCallHelpers::Address(opGPRs[i], JSString::offsetOfValue()), scratch2GPR);
13512             CCallHelpers::Jump isRope;
<span class="line-modified">13513             if (canBeRope)</span>
13514                 isRope = m_jit.branchIfRopeStringImpl(scratch2GPR);
13515 
<span class="line-modified">13516             m_jit.and16(CCallHelpers::Address(scratch2GPR, StringImpl::flagsOffset()), scratchGPR);</span>
13517             speculationCheck(
13518                 Uncountable, JSValueSource(), nullptr,
13519                 m_jit.branchAdd32(
13520                     CCallHelpers::Overflow,
13521                     CCallHelpers::Address(scratch2GPR, StringImpl::lengthMemoryOffset()), allocatorGPR));
<span class="line-modified">13522             if (canBeRope) {</span>
13523                 auto done = m_jit.jump();
13524 
13525                 isRope.link(&amp;m_jit);
<span class="line-modified">13526                 m_jit.and16(CCallHelpers::Address(opGPRs[i], JSRopeString::offsetOfFlags()), scratchGPR);</span>
13527                 m_jit.load32(CCallHelpers::Address(opGPRs[i], JSRopeString::offsetOfLength()), scratch2GPR);
13528                 speculationCheck(
13529                     Uncountable, JSValueSource(), nullptr,
13530                     m_jit.branchAdd32(
13531                         CCallHelpers::Overflow, scratch2GPR, allocatorGPR));
13532                 done.link(&amp;m_jit);
13533             }
13534         }
13535     }
<span class="line-modified">13536     m_jit.store16(scratchGPR, CCallHelpers::Address(resultGPR, JSRopeString::offsetOfFlags()));</span>
13537     if (!ASSERT_DISABLED) {
13538         CCallHelpers::Jump ok = m_jit.branch32(
13539             CCallHelpers::GreaterThanOrEqual, allocatorGPR, TrustedImm32(0));
13540         m_jit.abortWithReason(DFGNegativeStringLength);
13541         ok.link(&amp;m_jit);
13542     }
<span class="line-modified">13543     m_jit.store32(allocatorGPR, CCallHelpers::Address(resultGPR, JSRopeString::offsetOfLength()));</span>
























13544     auto isNonEmptyString = m_jit.branchTest32(CCallHelpers::NonZero, allocatorGPR);
13545 
<span class="line-modified">13546     m_jit.move(TrustedImmPtr::weakPointer(m_jit.graph(), jsEmptyString(&amp;m_jit.graph().m_vm)), resultGPR);</span>
13547 
13548     isNonEmptyString.link(&amp;m_jit);
<span class="line-modified">13549     m_jit.mutatorFence(*m_jit.vm());</span>
13550 
13551     switch (numOpGPRs) {
13552     case 2:
13553         addSlowPathGenerator(slowPathCall(
13554             slowPath, this, operationMakeRope2, resultGPR, opGPRs[0], opGPRs[1]));
13555         break;
13556     case 3:
13557         addSlowPathGenerator(slowPathCall(
13558             slowPath, this, operationMakeRope3, resultGPR, opGPRs[0], opGPRs[1], opGPRs[2]));
13559         break;
13560     default:
13561         RELEASE_ASSERT_NOT_REACHED();
13562         break;
13563     }
13564 
13565     cellResult(resultGPR, node);
13566 #else
13567     flushRegisters();
13568     GPRFlushedCallResult result(this);
13569     GPRReg resultGPR = result.gpr();
</pre>
</td>
<td>
<hr />
<pre>
   23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   24  */
   25 
   26 #include &quot;config.h&quot;
   27 #include &quot;DFGSpeculativeJIT.h&quot;
   28 
   29 #if ENABLE(DFG_JIT)
   30 
   31 #include &quot;BinarySwitch.h&quot;
   32 #include &quot;DFGAbstractInterpreterInlines.h&quot;
   33 #include &quot;DFGArrayifySlowPathGenerator.h&quot;
   34 #include &quot;DFGCallArrayAllocatorSlowPathGenerator.h&quot;
   35 #include &quot;DFGCallCreateDirectArgumentsSlowPathGenerator.h&quot;
   36 #include &quot;DFGCapabilities.h&quot;
   37 #include &quot;DFGMayExit.h&quot;
   38 #include &quot;DFGOSRExitFuzz.h&quot;
   39 #include &quot;DFGSaneStringGetByValSlowPathGenerator.h&quot;
   40 #include &quot;DFGSlowPathGenerator.h&quot;
   41 #include &quot;DFGSnippetParams.h&quot;
   42 #include &quot;DirectArguments.h&quot;
<span class="line-added">   43 #include &quot;DisallowMacroScratchRegisterUsage.h&quot;</span>
   44 #include &quot;JITAddGenerator.h&quot;
   45 #include &quot;JITBitAndGenerator.h&quot;
   46 #include &quot;JITBitOrGenerator.h&quot;
   47 #include &quot;JITBitXorGenerator.h&quot;
   48 #include &quot;JITDivGenerator.h&quot;
   49 #include &quot;JITLeftShiftGenerator.h&quot;
   50 #include &quot;JITMulGenerator.h&quot;
   51 #include &quot;JITRightShiftGenerator.h&quot;
   52 #include &quot;JITSubGenerator.h&quot;
   53 #include &quot;JSAsyncFunction.h&quot;
   54 #include &quot;JSAsyncGeneratorFunction.h&quot;
   55 #include &quot;JSCInlines.h&quot;
   56 #include &quot;JSFixedArray.h&quot;
   57 #include &quot;JSGeneratorFunction.h&quot;
   58 #include &quot;JSImmutableButterfly.h&quot;
   59 #include &quot;JSLexicalEnvironment.h&quot;
   60 #include &quot;JSPropertyNameEnumerator.h&quot;
   61 #include &quot;LinkBuffer.h&quot;
   62 #include &quot;RegExpObject.h&quot;
   63 #include &quot;ScopedArguments.h&quot;
   64 #include &quot;ScratchRegisterAllocator.h&quot;
   65 #include &quot;SuperSampler.h&quot;
   66 #include &quot;TypeProfilerLog.h&quot;
   67 #include &quot;WeakMapImpl.h&quot;
   68 #include &lt;wtf/BitVector.h&gt;
   69 #include &lt;wtf/Box.h&gt;
   70 #include &lt;wtf/MathExtras.h&gt;
   71 
   72 namespace JSC { namespace DFG {
   73 
   74 SpeculativeJIT::SpeculativeJIT(JITCompiler&amp; jit)
<span class="line-modified">   75     : m_jit(jit)</span>

   76     , m_graph(m_jit.graph())
   77     , m_currentNode(0)
   78     , m_lastGeneratedNode(LastNodeType)
   79     , m_indexInBlock(0)
   80     , m_generationInfo(m_jit.graph().frameRegisterCount())
<span class="line-added">   81     , m_compileOkay(true)</span>
   82     , m_state(m_jit.graph())
   83     , m_interpreter(m_jit.graph(), m_state)
   84     , m_stream(&amp;jit.jitCode()-&gt;variableEventStream)
   85     , m_minifiedGraph(&amp;jit.jitCode()-&gt;minifiedDFG)
   86 {
   87 }
   88 
   89 SpeculativeJIT::~SpeculativeJIT()
   90 {
   91 }
   92 
   93 void SpeculativeJIT::emitAllocateRawObject(GPRReg resultGPR, RegisteredStructure structure, GPRReg storageGPR, unsigned numElements, unsigned vectorLength)
   94 {
   95     ASSERT(!isCopyOnWrite(structure-&gt;indexingMode()));
   96     IndexingType indexingType = structure-&gt;indexingType();
   97     bool hasIndexingHeader = hasIndexedProperties(indexingType);
   98 
   99     unsigned inlineCapacity = structure-&gt;inlineCapacity();
  100     unsigned outOfLineCapacity = structure-&gt;outOfLineCapacity();
  101 
  102     GPRTemporary scratch(this);
  103     GPRTemporary scratch2(this);
  104     GPRReg scratchGPR = scratch.gpr();
  105     GPRReg scratch2GPR = scratch2.gpr();
  106 
  107     ASSERT(vectorLength &gt;= numElements);
  108     vectorLength = Butterfly::optimalContiguousVectorLength(structure.get(), vectorLength);
  109 
  110     JITCompiler::JumpList slowCases;
  111 
  112     size_t size = 0;
  113     if (hasIndexingHeader)
  114         size += vectorLength * sizeof(JSValue) + sizeof(IndexingHeader);
  115     size += outOfLineCapacity * sizeof(JSValue);
  116 
  117     m_jit.move(TrustedImmPtr(nullptr), storageGPR);
  118 
<span class="line-added">  119     VM&amp; vm = this-&gt;vm();</span>
  120     if (size) {
<span class="line-modified">  121         if (Allocator allocator = vm.jsValueGigacageAuxiliarySpace.allocatorForNonVirtual(size, AllocatorForMode::AllocatorIfExists)) {</span>
  122             m_jit.emitAllocate(storageGPR, JITAllocator::constant(allocator), scratchGPR, scratch2GPR, slowCases);
  123 
  124             m_jit.addPtr(
  125                 TrustedImm32(outOfLineCapacity * sizeof(JSValue) + sizeof(IndexingHeader)),
  126                 storageGPR);
  127 
  128             if (hasIndexingHeader)
  129                 m_jit.store32(TrustedImm32(vectorLength), MacroAssembler::Address(storageGPR, Butterfly::offsetOfVectorLength()));
  130         } else
  131             slowCases.append(m_jit.jump());
  132     }
  133 
  134     size_t allocationSize = JSFinalObject::allocationSize(inlineCapacity);
<span class="line-modified">  135     Allocator allocator = allocatorForNonVirtualConcurrently&lt;JSFinalObject&gt;(vm, allocationSize, AllocatorForMode::AllocatorIfExists);</span>
  136     if (allocator) {
  137         emitAllocateJSObject(resultGPR, JITAllocator::constant(allocator), scratchGPR, TrustedImmPtr(structure), storageGPR, scratch2GPR, slowCases);
  138         m_jit.emitInitializeInlineStorage(resultGPR, structure-&gt;inlineCapacity());
  139     } else
  140         slowCases.append(m_jit.jump());
  141 
  142     // I want a slow path that also loads out the storage pointer, and that&#39;s
  143     // what this custom CallArrayAllocatorSlowPathGenerator gives me. It&#39;s a lot
  144     // of work for a very small piece of functionality. :-/
<span class="line-modified">  145     addSlowPathGenerator(makeUnique&lt;CallArrayAllocatorSlowPathGenerator&gt;(</span>
  146         slowCases, this, operationNewRawObject, resultGPR, storageGPR,
  147         structure, vectorLength));
  148 
  149     if (numElements &lt; vectorLength) {
  150 #if USE(JSVALUE64)
  151         if (hasDouble(structure-&gt;indexingType()))
  152             m_jit.move(TrustedImm64(bitwise_cast&lt;int64_t&gt;(PNaN)), scratchGPR);
  153         else
  154             m_jit.move(TrustedImm64(JSValue::encode(JSValue())), scratchGPR);
  155         for (unsigned i = numElements; i &lt; vectorLength; ++i)
  156             m_jit.store64(scratchGPR, MacroAssembler::Address(storageGPR, sizeof(double) * i));
  157 #else
  158         EncodedValueDescriptor value;
  159         if (hasDouble(structure-&gt;indexingType()))
  160             value.asInt64 = JSValue::encode(JSValue(JSValue::EncodeAsDouble, PNaN));
  161         else
  162             value.asInt64 = JSValue::encode(JSValue());
  163         for (unsigned i = numElements; i &lt; vectorLength; ++i) {
  164             m_jit.store32(TrustedImm32(value.asBits.tag), MacroAssembler::Address(storageGPR, sizeof(double) * i + OBJECT_OFFSETOF(JSValue, u.asBits.tag)));
  165             m_jit.store32(TrustedImm32(value.asBits.payload), MacroAssembler::Address(storageGPR, sizeof(double) * i + OBJECT_OFFSETOF(JSValue, u.asBits.payload)));
  166         }
  167 #endif
  168     }
  169 
  170     if (hasIndexingHeader)
  171         m_jit.store32(TrustedImm32(numElements), MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()));
  172 
  173     m_jit.emitInitializeOutOfLineStorage(storageGPR, structure-&gt;outOfLineCapacity());
  174 
<span class="line-modified">  175     m_jit.mutatorFence(vm);</span>
  176 }
  177 
  178 void SpeculativeJIT::emitGetLength(InlineCallFrame* inlineCallFrame, GPRReg lengthGPR, bool includeThis)
  179 {
  180     if (inlineCallFrame &amp;&amp; !inlineCallFrame-&gt;isVarargs())
  181         m_jit.move(TrustedImm32(inlineCallFrame-&gt;argumentCountIncludingThis - !includeThis), lengthGPR);
  182     else {
  183         VirtualRegister argumentCountRegister = m_jit.argumentCount(inlineCallFrame);
  184         m_jit.load32(JITCompiler::payloadFor(argumentCountRegister), lengthGPR);
  185         if (!includeThis)
  186             m_jit.sub32(TrustedImm32(1), lengthGPR);
  187     }
  188 }
  189 
  190 void SpeculativeJIT::emitGetLength(CodeOrigin origin, GPRReg lengthGPR, bool includeThis)
  191 {
<span class="line-modified">  192     emitGetLength(origin.inlineCallFrame(), lengthGPR, includeThis);</span>
  193 }
  194 
  195 void SpeculativeJIT::emitGetCallee(CodeOrigin origin, GPRReg calleeGPR)
  196 {
<span class="line-modified">  197     auto* inlineCallFrame = origin.inlineCallFrame();</span>
<span class="line-modified">  198     if (inlineCallFrame) {</span>
<span class="line-added">  199         if (inlineCallFrame-&gt;isClosureCall) {</span>
  200             m_jit.loadPtr(
<span class="line-modified">  201                 JITCompiler::addressFor(inlineCallFrame-&gt;calleeRecovery.virtualRegister()),</span>
  202                 calleeGPR);
  203         } else {
  204             m_jit.move(
<span class="line-modified">  205                 TrustedImmPtr::weakPointer(m_jit.graph(), inlineCallFrame-&gt;calleeRecovery.constant().asCell()),</span>
  206                 calleeGPR);
  207         }
  208     } else
  209         m_jit.loadPtr(JITCompiler::addressFor(CallFrameSlot::callee), calleeGPR);
  210 }
  211 
  212 void SpeculativeJIT::emitGetArgumentStart(CodeOrigin origin, GPRReg startGPR)
  213 {
  214     m_jit.addPtr(
  215         TrustedImm32(
  216             JITCompiler::argumentsStart(origin).offset() * static_cast&lt;int&gt;(sizeof(Register))),
  217         GPRInfo::callFrameRegister, startGPR);
  218 }
  219 
  220 MacroAssembler::Jump SpeculativeJIT::emitOSRExitFuzzCheck()
  221 {
  222     if (!Options::useOSRExitFuzz()
  223         || !canUseOSRExitFuzzing(m_jit.graph().baselineCodeBlockFor(m_origin.semantic))
  224         || !doOSRExitFuzzing())
  225         return MacroAssembler::Jump();
</pre>
<hr />
<pre>
  883         structureGPR = structure.gpr();
  884     }
  885 
  886     // We can skip all that comes next if we already have array storage.
  887     MacroAssembler::JumpList slowPath;
  888 
  889     if (node-&gt;op() == ArrayifyToStructure) {
  890         ASSERT(!isCopyOnWrite(node-&gt;structure()-&gt;indexingMode()));
  891         ASSERT((node-&gt;structure()-&gt;indexingType() &amp; IndexingShapeMask) == node-&gt;arrayMode().shapeMask());
  892         slowPath.append(m_jit.branchWeakStructure(
  893             JITCompiler::NotEqual,
  894             JITCompiler::Address(baseReg, JSCell::structureIDOffset()),
  895             node-&gt;structure()));
  896     } else {
  897         m_jit.load8(
  898             MacroAssembler::Address(baseReg, JSCell::indexingTypeAndMiscOffset()), tempGPR);
  899 
  900         slowPath.append(jumpSlowForUnwantedArrayMode(tempGPR, node-&gt;arrayMode()));
  901     }
  902 
<span class="line-modified">  903     addSlowPathGenerator(makeUnique&lt;ArrayifySlowPathGenerator&gt;(</span>
  904         slowPath, this, node, baseReg, propertyReg, tempGPR, structureGPR));
  905 
  906     noResult(m_currentNode);
  907 }
  908 
  909 void SpeculativeJIT::arrayify(Node* node)
  910 {
  911     ASSERT(node-&gt;arrayMode().isSpecific());
  912 
  913     SpeculateCellOperand base(this, node-&gt;child1());
  914 
  915     if (!node-&gt;child2()) {
  916         arrayify(node, base.gpr(), InvalidGPRReg);
  917         return;
  918     }
  919 
  920     SpeculateInt32Operand property(this, node-&gt;child2());
  921 
  922     arrayify(node, base.gpr(), property.gpr());
  923 }
</pre>
<hr />
<pre>
 1532 
 1533 void SpeculativeJIT::compileStringSlice(Node* node)
 1534 {
 1535     SpeculateCellOperand string(this, node-&gt;child1());
 1536 
 1537     GPRReg stringGPR = string.gpr();
 1538 
 1539     speculateString(node-&gt;child1(), stringGPR);
 1540 
 1541     SpeculateInt32Operand start(this, node-&gt;child2());
 1542     GPRReg startGPR = start.gpr();
 1543 
 1544     Optional&lt;SpeculateInt32Operand&gt; end;
 1545     Optional&lt;GPRReg&gt; endGPR;
 1546     if (node-&gt;child3()) {
 1547         end.emplace(this, node-&gt;child3());
 1548         endGPR.emplace(end-&gt;gpr());
 1549     }
 1550 
 1551     GPRTemporary temp(this);





 1552     GPRTemporary temp2(this);
 1553     GPRTemporary startIndex(this);
 1554 
<span class="line-added"> 1555     GPRReg tempGPR = temp.gpr();</span>
 1556     GPRReg temp2GPR = temp2.gpr();
 1557     GPRReg startIndexGPR = startIndex.gpr();
<span class="line-added"> 1558 </span>
<span class="line-added"> 1559     m_jit.loadPtr(CCallHelpers::Address(stringGPR, JSString::offsetOfValue()), tempGPR);</span>
<span class="line-added"> 1560     auto isRope = m_jit.branchIfRopeStringImpl(tempGPR);</span>
 1561     {
 1562         m_jit.load32(MacroAssembler::Address(tempGPR, StringImpl::lengthMemoryOffset()), temp2GPR);
 1563 
 1564         emitPopulateSliceIndex(node-&gt;child2(), startGPR, temp2GPR, startIndexGPR);
 1565 
 1566         if (node-&gt;child3())
 1567             emitPopulateSliceIndex(node-&gt;child3(), endGPR.value(), temp2GPR, tempGPR);
 1568         else
 1569             m_jit.move(temp2GPR, tempGPR);
 1570     }
 1571 
 1572     CCallHelpers::JumpList doneCases;
 1573     CCallHelpers::JumpList slowCases;
 1574 
<span class="line-added"> 1575     VM&amp; vm = this-&gt;vm();</span>
 1576     auto nonEmptyCase = m_jit.branch32(MacroAssembler::Below, startIndexGPR, tempGPR);
<span class="line-modified"> 1577     m_jit.move(TrustedImmPtr::weakPointer(m_jit.graph(), jsEmptyString(vm)), tempGPR);</span>
 1578     doneCases.append(m_jit.jump());
 1579 
 1580     nonEmptyCase.link(&amp;m_jit);
 1581     m_jit.sub32(startIndexGPR, tempGPR); // the size of the sliced string.
 1582     slowCases.append(m_jit.branch32(MacroAssembler::NotEqual, tempGPR, TrustedImm32(1)));
 1583 
 1584     // Refill StringImpl* here.
 1585     m_jit.loadPtr(MacroAssembler::Address(stringGPR, JSString::offsetOfValue()), temp2GPR);
 1586     m_jit.loadPtr(MacroAssembler::Address(temp2GPR, StringImpl::dataOffset()), tempGPR);
 1587 
 1588     // Load the character into scratchReg
 1589     m_jit.zeroExtend32ToPtr(startIndexGPR, startIndexGPR);
 1590     auto is16Bit = m_jit.branchTest32(MacroAssembler::Zero, MacroAssembler::Address(temp2GPR, StringImpl::flagsOffset()), TrustedImm32(StringImpl::flagIs8Bit()));
 1591 
 1592     m_jit.load8(MacroAssembler::BaseIndex(tempGPR, startIndexGPR, MacroAssembler::TimesOne, 0), tempGPR);
 1593     auto cont8Bit = m_jit.jump();
 1594 
 1595     is16Bit.link(&amp;m_jit);
 1596     m_jit.load16(MacroAssembler::BaseIndex(tempGPR, startIndexGPR, MacroAssembler::TimesTwo, 0), tempGPR);
 1597 
 1598     auto bigCharacter = m_jit.branch32(MacroAssembler::Above, tempGPR, TrustedImm32(maxSingleCharacterString));
 1599 
 1600     // 8 bit string values don&#39;t need the isASCII check.
 1601     cont8Bit.link(&amp;m_jit);
 1602 
 1603     m_jit.lshift32(MacroAssembler::TrustedImm32(sizeof(void*) == 4 ? 2 : 3), tempGPR);
<span class="line-modified"> 1604     m_jit.addPtr(TrustedImmPtr(vm.smallStrings.singleCharacterStrings()), tempGPR);</span>
 1605     m_jit.loadPtr(tempGPR, tempGPR);
 1606 
 1607     addSlowPathGenerator(slowPathCall(bigCharacter, this, operationSingleCharacterString, tempGPR, tempGPR));
 1608 
 1609     addSlowPathGenerator(slowPathCall(slowCases, this, operationStringSubstr, tempGPR, stringGPR, startIndexGPR, tempGPR));
 1610 
 1611     if (endGPR)
 1612         addSlowPathGenerator(slowPathCall(isRope, this, operationStringSlice, tempGPR, stringGPR, startGPR, *endGPR));
 1613     else
 1614         addSlowPathGenerator(slowPathCall(isRope, this, operationStringSlice, tempGPR, stringGPR, startGPR, TrustedImm32(std::numeric_limits&lt;int32_t&gt;::max())));
 1615 
 1616     doneCases.link(&amp;m_jit);
 1617     cellResult(tempGPR, node);
 1618 }
 1619 
 1620 void SpeculativeJIT::compileToLowerCase(Node* node)
 1621 {
 1622     ASSERT(node-&gt;op() == ToLowerCase);
 1623     SpeculateCellOperand string(this, node-&gt;child1());
 1624     GPRTemporary temp(this);
</pre>
<hr />
<pre>
 1849 
 1850         // We may have hit a contradiction that the CFA was aware of but that the JIT
 1851         // didn&#39;t cause directly.
 1852         if (!m_state.isValid()) {
 1853             bail(DFGBailedAtTopOfBlock);
 1854             return;
 1855         }
 1856 
 1857         m_interpreter.startExecuting();
 1858         m_interpreter.executeKnownEdgeTypes(m_currentNode);
 1859         m_jit.setForNode(m_currentNode);
 1860         m_origin = m_currentNode-&gt;origin;
 1861         m_lastGeneratedNode = m_currentNode-&gt;op();
 1862 
 1863         ASSERT(m_currentNode-&gt;shouldGenerate());
 1864 
 1865         if (verboseCompilationEnabled()) {
 1866             dataLogF(
 1867                 &quot;SpeculativeJIT generating Node @%d (bc#%u) at JIT offset 0x%x&quot;,
 1868                 (int)m_currentNode-&gt;index(),
<span class="line-modified"> 1869                 m_currentNode-&gt;origin.semantic.bytecodeIndex(), m_jit.debugOffset());</span>
 1870             dataLog(&quot;\n&quot;);
 1871         }
 1872 
 1873         if (Options::validateDFGExceptionHandling() &amp;&amp; (mayExit(m_jit.graph(), m_currentNode) != DoesNotExit || m_currentNode-&gt;isTerminal()))
<span class="line-modified"> 1874             m_jit.jitReleaseAssertNoException(m_jit.vm());</span>
 1875 
 1876         m_jit.pcToCodeOriginMapBuilder().appendItem(m_jit.labelIgnoringWatchpoints(), m_origin.semantic);
 1877 
 1878         compile(m_currentNode);
 1879 
 1880         if (belongsInMinifiedGraph(m_currentNode-&gt;op()))
 1881             m_minifiedGraph-&gt;append(MinifiedNode::fromNode(m_currentNode));
 1882 
 1883 #if ENABLE(DFG_REGISTER_ALLOCATION_VALIDATION)
 1884         m_jit.clearRegisterAllocationOffsets();
 1885 #endif
 1886 
 1887         if (!m_compileOkay) {
 1888             bail(DFGBailedAtEndOfNode);
 1889             return;
 1890         }
 1891 
 1892         // Make sure that the abstract state is rematerialized for the next node.
 1893         m_interpreter.executeEffects(m_indexInBlock);
 1894     }
</pre>
<hr />
<pre>
 1898         for (auto&amp; info : m_generationInfo)
 1899             RELEASE_ASSERT(!info.alive());
 1900     }
 1901 }
 1902 
 1903 // If we are making type predictions about our arguments then
 1904 // we need to check that they are correct on function entry.
 1905 void SpeculativeJIT::checkArgumentTypes()
 1906 {
 1907     ASSERT(!m_currentNode);
 1908     m_origin = NodeOrigin(CodeOrigin(0), CodeOrigin(0), true);
 1909 
 1910     auto&amp; arguments = m_jit.graph().m_rootToArguments.find(m_jit.graph().block(0))-&gt;value;
 1911     for (int i = 0; i &lt; m_jit.codeBlock()-&gt;numParameters(); ++i) {
 1912         Node* node = arguments[i];
 1913         if (!node) {
 1914             // The argument is dead. We don&#39;t do any checks for such arguments.
 1915             continue;
 1916         }
 1917 
<span class="line-modified"> 1918         ASSERT(node-&gt;op() == SetArgumentDefinitely);</span>
 1919         ASSERT(node-&gt;shouldGenerate());
 1920 
 1921         VariableAccessData* variableAccessData = node-&gt;variableAccessData();
 1922         FlushFormat format = variableAccessData-&gt;flushFormat();
 1923 
 1924         if (format == FlushedJSValue)
 1925             continue;
 1926 
 1927         VirtualRegister virtualRegister = variableAccessData-&gt;local();
 1928 
 1929         JSValueSource valueSource = JSValueSource(JITCompiler::addressFor(virtualRegister));
 1930 
 1931 #if USE(JSVALUE64)
 1932         switch (format) {
 1933         case FlushedInt32: {
 1934             speculationCheck(BadType, valueSource, node, m_jit.branch64(MacroAssembler::Below, JITCompiler::addressFor(virtualRegister), GPRInfo::tagTypeNumberRegister));
 1935             break;
 1936         }
 1937         case FlushedBoolean: {
 1938             GPRTemporary temp(this);
</pre>
<hr />
<pre>
 2034 
 2035     ASSERT(osrEntryIndex == m_osrEntryHeads.size());
 2036 
 2037     if (verboseCompilationEnabled()) {
 2038         DumpContext dumpContext;
 2039         dataLog(&quot;OSR Entries:\n&quot;);
 2040         for (OSREntryData&amp; entryData : m_jit.jitCode()-&gt;osrEntry)
 2041             dataLog(&quot;    &quot;, inContext(entryData, &amp;dumpContext), &quot;\n&quot;);
 2042         if (!dumpContext.isEmpty())
 2043             dumpContext.dump(WTF::dataFile());
 2044     }
 2045 }
 2046 
 2047 void SpeculativeJIT::compileCheckTraps(Node* node)
 2048 {
 2049     ASSERT(Options::usePollingTraps());
 2050     GPRTemporary unused(this);
 2051     GPRReg unusedGPR = unused.gpr();
 2052 
 2053     JITCompiler::Jump needTrapHandling = m_jit.branchTest8(JITCompiler::NonZero,
<span class="line-modified"> 2054         JITCompiler::AbsoluteAddress(m_jit.vm().needTrapHandlingAddress()));</span>
 2055 
 2056     addSlowPathGenerator(slowPathCall(needTrapHandling, this, operationHandleTraps, unusedGPR));
 2057     noResult(node);
 2058 }
 2059 
 2060 void SpeculativeJIT::compileDoublePutByVal(Node* node, SpeculateCellOperand&amp; base, SpeculateStrictInt32Operand&amp; property)
 2061 {
 2062     Edge child3 = m_jit.graph().varArgChild(node, 2);
 2063     Edge child4 = m_jit.graph().varArgChild(node, 3);
 2064 
 2065     ArrayMode arrayMode = node-&gt;arrayMode();
 2066 
 2067     GPRReg baseReg = base.gpr();
 2068     GPRReg propertyReg = property.gpr();
 2069 
 2070     SpeculateDoubleOperand value(this, child3);
 2071 
 2072     FPRReg valueReg = value.fpr();
 2073 
 2074     DFG_TYPE_CHECK(
</pre>
<hr />
<pre>
 2108         if (!arrayMode.isOutOfBounds())
 2109             speculationCheck(OutOfBounds, JSValueRegs(), 0, slowCase);
 2110 
 2111         m_jit.add32(TrustedImm32(1), propertyReg, temporaryReg);
 2112         m_jit.store32(temporaryReg, MacroAssembler::Address(storageReg, Butterfly::offsetOfPublicLength()));
 2113 
 2114         inBounds.link(&amp;m_jit);
 2115     }
 2116 
 2117     m_jit.storeDouble(valueReg, MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight));
 2118 
 2119     base.use();
 2120     property.use();
 2121     value.use();
 2122     storage.use();
 2123 
 2124     if (arrayMode.isOutOfBounds()) {
 2125         addSlowPathGenerator(
 2126             slowPathCall(
 2127                 slowCase, this,
<span class="line-modified"> 2128                 m_jit.isStrictModeFor(node-&gt;origin.semantic)</span>
 2129                     ? (node-&gt;op() == PutByValDirect ? operationPutDoubleByValDirectBeyondArrayBoundsStrict : operationPutDoubleByValBeyondArrayBoundsStrict)
 2130                     : (node-&gt;op() == PutByValDirect ? operationPutDoubleByValDirectBeyondArrayBoundsNonStrict : operationPutDoubleByValBeyondArrayBoundsNonStrict),
 2131                 NoResult, baseReg, propertyReg, valueReg));
 2132     }
 2133 
 2134     noResult(m_currentNode, UseChildrenCalledExplicitly);
 2135 }
 2136 
 2137 void SpeculativeJIT::compileGetCharCodeAt(Node* node)
 2138 {
 2139     SpeculateCellOperand string(this, node-&gt;child1());
 2140     SpeculateStrictInt32Operand index(this, node-&gt;child2());
 2141     StorageOperand storage(this, node-&gt;child3());
 2142 
 2143     GPRReg stringReg = string.gpr();
 2144     GPRReg indexReg = index.gpr();
 2145     GPRReg storageReg = storage.gpr();
 2146 
 2147     ASSERT(speculationChecked(m_state.forNode(node-&gt;child1()).m_type, SpecString));
 2148 
</pre>
<hr />
<pre>
 2199         MacroAssembler::Address(scratchReg, StringImpl::lengthMemoryOffset()));
 2200     if (node-&gt;arrayMode().isInBounds())
 2201         speculationCheck(OutOfBounds, JSValueRegs(), 0, outOfBounds);
 2202 
 2203     // Load the character into scratchReg
 2204     JITCompiler::Jump is16Bit = m_jit.branchTest32(MacroAssembler::Zero, MacroAssembler::Address(scratchReg, StringImpl::flagsOffset()), TrustedImm32(StringImpl::flagIs8Bit()));
 2205 
 2206     m_jit.load8(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesOne, 0), scratchReg);
 2207     JITCompiler::Jump cont8Bit = m_jit.jump();
 2208 
 2209     is16Bit.link(&amp;m_jit);
 2210 
 2211     m_jit.load16(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesTwo, 0), scratchReg);
 2212 
 2213     JITCompiler::Jump bigCharacter =
 2214         m_jit.branch32(MacroAssembler::Above, scratchReg, TrustedImm32(maxSingleCharacterString));
 2215 
 2216     // 8 bit string values don&#39;t need the isASCII check.
 2217     cont8Bit.link(&amp;m_jit);
 2218 
<span class="line-added"> 2219     VM&amp; vm = this-&gt;vm();</span>
 2220     m_jit.lshift32(MacroAssembler::TrustedImm32(sizeof(void*) == 4 ? 2 : 3), scratchReg);
<span class="line-modified"> 2221     m_jit.addPtr(TrustedImmPtr(vm.smallStrings.singleCharacterStrings()), scratchReg);</span>
 2222     m_jit.loadPtr(scratchReg, scratchReg);
 2223 
 2224     addSlowPathGenerator(
 2225         slowPathCall(
 2226             bigCharacter, this, operationSingleCharacterString, scratchReg, scratchReg));
 2227 
 2228     if (node-&gt;arrayMode().isOutOfBounds()) {
 2229 #if USE(JSVALUE32_64)
 2230         m_jit.move(TrustedImm32(JSValue::CellTag), resultTagReg);
 2231 #endif
 2232 
 2233         JSGlobalObject* globalObject = m_jit.globalObjectFor(node-&gt;origin.semantic);
<span class="line-modified"> 2234         Structure* stringPrototypeStructure = globalObject-&gt;stringPrototype()-&gt;structure(vm);</span>
<span class="line-added"> 2235         Structure* objectPrototypeStructure = globalObject-&gt;objectPrototype()-&gt;structure(vm);</span>
<span class="line-added"> 2236         WTF::loadLoadFence();</span>
<span class="line-added"> 2237 </span>
 2238         if (globalObject-&gt;stringPrototypeChainIsSane()) {
 2239             // FIXME: This could be captured using a Speculation mode that means &quot;out-of-bounds
 2240             // loads return a trivial value&quot;. Something like SaneChainOutOfBounds. This should
 2241             // speculate that we don&#39;t take negative out-of-bounds, or better yet, it should rely
 2242             // on a stringPrototypeChainIsSane() guaranteeing that the prototypes have no negative
 2243             // indexed properties either.
 2244             // https://bugs.webkit.org/show_bug.cgi?id=144668
<span class="line-modified"> 2245             m_jit.graph().registerAndWatchStructureTransition(stringPrototypeStructure);</span>
<span class="line-modified"> 2246             m_jit.graph().registerAndWatchStructureTransition(objectPrototypeStructure);</span>
<span class="line-modified"> 2247 </span>


 2248 #if USE(JSVALUE64)
<span class="line-modified"> 2249             addSlowPathGenerator(makeUnique&lt;SaneStringGetByValSlowPathGenerator&gt;(</span>
 2250                 outOfBounds, this, JSValueRegs(scratchReg), baseReg, propertyReg));
 2251 #else
<span class="line-modified"> 2252             addSlowPathGenerator(makeUnique&lt;SaneStringGetByValSlowPathGenerator&gt;(</span>
 2253                 outOfBounds, this, JSValueRegs(resultTagReg, scratchReg),
 2254                 baseReg, propertyReg));
 2255 #endif
 2256         } else {
 2257 #if USE(JSVALUE64)
 2258             addSlowPathGenerator(
 2259                 slowPathCall(
 2260                     outOfBounds, this, operationGetByValStringInt,
 2261                     scratchReg, baseReg, propertyReg));
 2262 #else
 2263             addSlowPathGenerator(
 2264                 slowPathCall(
 2265                     outOfBounds, this, operationGetByValStringInt,
 2266                     JSValueRegs(resultTagReg, scratchReg), baseReg, propertyReg));
 2267 #endif
 2268         }
 2269 
 2270 #if USE(JSVALUE64)
 2271         jsValueResult(scratchReg, m_currentNode);
 2272 #else
</pre>
<hr />
<pre>
 2284         JSValueRegs oprRegs = opr.jsValueRegs();
 2285 
 2286         flushRegisters();
 2287         JSValueRegsFlushedCallResult result(this);
 2288         JSValueRegs resultRegs = result.regs();
 2289         callOperation(operationStringFromCharCodeUntyped, resultRegs, oprRegs);
 2290         m_jit.exceptionCheck();
 2291 
 2292         jsValueResult(resultRegs, node);
 2293         return;
 2294     }
 2295 
 2296     SpeculateStrictInt32Operand property(this, child);
 2297     GPRReg propertyReg = property.gpr();
 2298     GPRTemporary smallStrings(this);
 2299     GPRTemporary scratch(this);
 2300     GPRReg scratchReg = scratch.gpr();
 2301     GPRReg smallStringsReg = smallStrings.gpr();
 2302 
 2303     JITCompiler::JumpList slowCases;
<span class="line-modified"> 2304     slowCases.append(m_jit.branch32(MacroAssembler::Above, propertyReg, TrustedImm32(maxSingleCharacterString)));</span>
<span class="line-modified"> 2305     m_jit.move(TrustedImmPtr(vm().smallStrings.singleCharacterStrings()), smallStringsReg);</span>
 2306     m_jit.loadPtr(MacroAssembler::BaseIndex(smallStringsReg, propertyReg, MacroAssembler::ScalePtr, 0), scratchReg);
 2307 
 2308     slowCases.append(m_jit.branchTest32(MacroAssembler::Zero, scratchReg));
 2309     addSlowPathGenerator(slowPathCall(slowCases, this, operationStringFromCharCode, scratchReg, propertyReg));
 2310     cellResult(scratchReg, m_currentNode);
 2311 }
 2312 
 2313 GeneratedOperandType SpeculativeJIT::checkGeneratedTypeForToInt32(Node* node)
 2314 {
 2315     VirtualRegister virtualRegister = node-&gt;virtualRegister();
 2316     GenerationInfo&amp; info = generationInfoFromVirtualRegister(virtualRegister);
 2317 
 2318     switch (info.registerFormat()) {
 2319     case DataFormatStorage:
 2320         RELEASE_ASSERT_NOT_REACHED();
 2321 
 2322     case DataFormatBoolean:
 2323     case DataFormatCell:
 2324         terminateSpeculativeExecution(Uncountable, JSValueRegs(), 0);
 2325         return GeneratedOperandTypeUnknown;
</pre>
<hr />
<pre>
 2859     if (!jump.isSet())
 2860         return;
 2861     speculationCheck(OutOfBounds, JSValueRegs(), 0, jump);
 2862 }
 2863 
 2864 JITCompiler::Jump SpeculativeJIT::jumpForTypedArrayIsNeuteredIfOutOfBounds(Node* node, GPRReg base, JITCompiler::Jump outOfBounds)
 2865 {
 2866     JITCompiler::Jump done;
 2867     if (outOfBounds.isSet()) {
 2868         done = m_jit.jump();
 2869         if (node-&gt;arrayMode().isInBounds())
 2870             speculationCheck(OutOfBounds, JSValueSource(), 0, outOfBounds);
 2871         else {
 2872             outOfBounds.link(&amp;m_jit);
 2873 
 2874             JITCompiler::Jump notWasteful = m_jit.branch32(
 2875                 MacroAssembler::NotEqual,
 2876                 MacroAssembler::Address(base, JSArrayBufferView::offsetOfMode()),
 2877                 TrustedImm32(WastefulTypedArray));
 2878 
<span class="line-modified"> 2879             JITCompiler::Jump hasNullVector;</span>
<span class="line-added"> 2880 #if CPU(ARM64E)</span>
<span class="line-added"> 2881             {</span>
<span class="line-added"> 2882                 GPRReg scratch = m_jit.scratchRegister();</span>
<span class="line-added"> 2883                 DisallowMacroScratchRegisterUsage disallowScratch(m_jit);</span>
<span class="line-added"> 2884 </span>
<span class="line-added"> 2885                 m_jit.loadPtr(MacroAssembler::Address(base, JSArrayBufferView::offsetOfVector()), scratch);</span>
<span class="line-added"> 2886                 m_jit.removeArrayPtrTag(scratch);</span>
<span class="line-added"> 2887                 hasNullVector = m_jit.branchTestPtr(MacroAssembler::Zero, scratch);</span>
<span class="line-added"> 2888             }</span>
<span class="line-added"> 2889 #else // CPU(ARM64E)</span>
<span class="line-added"> 2890             hasNullVector = m_jit.branchTestPtr(</span>
 2891                 MacroAssembler::Zero,
 2892                 MacroAssembler::Address(base, JSArrayBufferView::offsetOfVector()));
<span class="line-added"> 2893 #endif</span>
 2894             speculationCheck(Uncountable, JSValueSource(), node, hasNullVector);
 2895             notWasteful.link(&amp;m_jit);
 2896         }
 2897     }
 2898     return done;
 2899 }
 2900 
 2901 void SpeculativeJIT::loadFromIntTypedArray(GPRReg storageReg, GPRReg propertyReg, GPRReg resultReg, TypedArrayType type)
 2902 {
 2903     switch (elementSize(type)) {
 2904     case 1:
 2905         if (isSigned(type))
 2906             m_jit.load8SignedExtendTo32(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesOne), resultReg);
 2907         else
 2908             m_jit.load8(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesOne), resultReg);
 2909         break;
 2910     case 2:
 2911         if (isSigned(type))
 2912             m_jit.load16SignedExtendTo32(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesTwo), resultReg);
 2913         else
</pre>
<hr />
<pre>
 2919     default:
 2920         CRASH();
 2921     }
 2922 }
 2923 
 2924 void SpeculativeJIT::setIntTypedArrayLoadResult(Node* node, GPRReg resultReg, TypedArrayType type, bool canSpeculate)
 2925 {
 2926     if (elementSize(type) &lt; 4 || isSigned(type)) {
 2927         int32Result(resultReg, node);
 2928         return;
 2929     }
 2930 
 2931     ASSERT(elementSize(type) == 4 &amp;&amp; !isSigned(type));
 2932     if (node-&gt;shouldSpeculateInt32() &amp;&amp; canSpeculate) {
 2933         speculationCheck(Overflow, JSValueRegs(), 0, m_jit.branch32(MacroAssembler::LessThan, resultReg, TrustedImm32(0)));
 2934         int32Result(resultReg, node);
 2935         return;
 2936     }
 2937 
 2938 #if USE(JSVALUE64)
<span class="line-modified"> 2939     if (node-&gt;shouldSpeculateInt52()) {</span>
<span class="line-added"> 2940         ASSERT(enableInt52());</span>
 2941         m_jit.zeroExtend32ToPtr(resultReg, resultReg);
 2942         strictInt52Result(resultReg, node);
 2943         return;
 2944     }
 2945 #endif
 2946 
 2947     FPRTemporary fresult(this);
 2948     m_jit.convertInt32ToDouble(resultReg, fresult.fpr());
 2949     JITCompiler::Jump positive = m_jit.branch32(MacroAssembler::GreaterThanOrEqual, resultReg, TrustedImm32(0));
 2950     m_jit.addDouble(JITCompiler::AbsoluteAddress(&amp;AssemblyHelpers::twoToThe32), fresult.fpr());
 2951     positive.link(&amp;m_jit);
 2952     doubleResult(fresult.fpr(), node);
 2953 }
 2954 
 2955 void SpeculativeJIT::compileGetByValOnIntTypedArray(Node* node, TypedArrayType type)
 2956 {
 2957     ASSERT(isInt(type));
 2958 
 2959     SpeculateCellOperand base(this, m_graph.varArgChild(node, 0));
 2960     SpeculateStrictInt32Operand property(this, m_graph.varArgChild(node, 1));
 2961     StorageOperand storage(this, m_graph.varArgChild(node, 2));
 2962 
 2963     GPRReg baseReg = base.gpr();
 2964     GPRReg propertyReg = property.gpr();
 2965     GPRReg storageReg = storage.gpr();
 2966 
 2967     GPRTemporary result(this);
 2968     GPRReg resultReg = result.gpr();
 2969 


 2970     emitTypedArrayBoundsCheck(node, baseReg, propertyReg);
 2971     loadFromIntTypedArray(storageReg, propertyReg, resultReg, type);
 2972     bool canSpeculate = true;
 2973     setIntTypedArrayLoadResult(node, resultReg, type, canSpeculate);
 2974 }
 2975 
 2976 bool SpeculativeJIT::getIntTypedArrayStoreOperand(
 2977     GPRTemporary&amp; value,
 2978     GPRReg property,
 2979 #if USE(JSVALUE32_64)
 2980     GPRTemporary&amp; propertyTag,
 2981     GPRTemporary&amp; valueTag,
 2982 #endif
 2983     Edge valueUse, JITCompiler::JumpList&amp; slowPathCases, bool isClamped)
 2984 {
 2985     bool isAppropriateConstant = false;
 2986     if (valueUse-&gt;isConstant()) {
 2987         JSValue jsValue = valueUse-&gt;asJSValue();
 2988         SpeculatedType expectedType = typeFilterFor(valueUse.useKind());
 2989         SpeculatedType actualType = speculationFromValue(jsValue);
</pre>
<hr />
<pre>
 3152     if (done.isSet())
 3153         done.link(&amp;m_jit);
 3154 
 3155     if (!slowPathCases.empty()) {
 3156 #if USE(JSVALUE64)
 3157         if (node-&gt;op() == PutByValDirect) {
 3158             addSlowPathGenerator(slowPathCall(
 3159                 slowPathCases, this,
 3160                 m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValDirectStrict : operationPutByValDirectNonStrict,
 3161                 NoResult, base, property, valueGPR));
 3162         } else {
 3163             addSlowPathGenerator(slowPathCall(
 3164                 slowPathCases, this,
 3165                 m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValStrict : operationPutByValNonStrict,
 3166                 NoResult, base, property, valueGPR));
 3167         }
 3168 #else // not USE(JSVALUE64)
 3169         if (node-&gt;op() == PutByValDirect) {
 3170             addSlowPathGenerator(slowPathCall(
 3171                 slowPathCases, this,
<span class="line-modified"> 3172                 m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValDirectCellStrict : operationPutByValDirectCellNonStrict,</span>
 3173                 NoResult, base, JSValueRegs(propertyTagGPR, property), JSValueRegs(valueTagGPR, valueGPR)));
 3174         } else {
 3175             addSlowPathGenerator(slowPathCall(
 3176                 slowPathCases, this,
<span class="line-modified"> 3177                 m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValCellStrict : operationPutByValCellNonStrict,</span>
 3178                 NoResult, base, JSValueRegs(propertyTagGPR, property), JSValueRegs(valueTagGPR, valueGPR)));
 3179         }
 3180 #endif
 3181     }
 3182 
 3183     noResult(node);
 3184 }
 3185 
 3186 void SpeculativeJIT::compileGetByValOnFloatTypedArray(Node* node, TypedArrayType type)
 3187 {
 3188     ASSERT(isFloat(type));
 3189 
 3190     SpeculateCellOperand base(this, m_graph.varArgChild(node, 0));
 3191     SpeculateStrictInt32Operand property(this, m_graph.varArgChild(node, 1));
 3192     StorageOperand storage(this, m_graph.varArgChild(node, 2));
 3193 
 3194     GPRReg baseReg = base.gpr();
 3195     GPRReg propertyReg = property.gpr();
 3196     GPRReg storageReg = storage.gpr();
 3197 


 3198     FPRTemporary result(this);
 3199     FPRReg resultReg = result.fpr();
 3200     emitTypedArrayBoundsCheck(node, baseReg, propertyReg);
 3201     switch (elementSize(type)) {
 3202     case 4:
 3203         m_jit.loadFloat(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesFour), resultReg);
 3204         m_jit.convertFloatToDouble(resultReg, resultReg);
 3205         break;
 3206     case 8: {
 3207         m_jit.loadDouble(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight), resultReg);
 3208         break;
 3209     }
 3210     default:
 3211         RELEASE_ASSERT_NOT_REACHED();
 3212     }
 3213 
 3214     doubleResult(resultReg, node);
 3215 }
 3216 
 3217 void SpeculativeJIT::compilePutByValForFloatTypedArray(GPRReg base, GPRReg property, Node* node, TypedArrayType type)
</pre>
<hr />
<pre>
 3519 
 3520     GPRReg resultGPR = result.gpr();
 3521     GPRReg scratchGPR = scratch.gpr();
 3522 
 3523     JITCompiler::Jump isCell = m_jit.branchIfCell(valueRegs);
 3524     moveFalseTo(resultGPR);
 3525 
 3526     JITCompiler::Jump done = m_jit.jump();
 3527 
 3528     isCell.link(&amp;m_jit);
 3529 
 3530     JITCompiler::Jump slowCase = m_jit.branchIfNotCell(prototypeRegs);
 3531 
 3532     compileInstanceOfForCells(node, valueRegs, prototypeRegs, resultGPR, scratchGPR, InvalidGPRReg, slowCase);
 3533 
 3534     done.link(&amp;m_jit);
 3535     blessedBooleanResult(resultGPR, node);
 3536     return;
 3537 }
 3538 
<span class="line-modified"> 3539 void SpeculativeJIT::compileValueBitNot(Node* node)</span>
 3540 {
 3541     Edge&amp; child1 = node-&gt;child1();
 3542 
<span class="line-modified"> 3543     if (child1.useKind() == BigIntUse) {</span>
<span class="line-modified"> 3544         SpeculateCellOperand operand(this, child1);</span>
<span class="line-modified"> 3545         GPRReg operandGPR = operand.gpr();</span>
<span class="line-added"> 3546 </span>
<span class="line-added"> 3547         speculateBigInt(child1, operandGPR);</span>
 3548 
 3549         flushRegisters();
<span class="line-modified"> 3550         GPRFlushedCallResult result(this);</span>
<span class="line-modified"> 3551         GPRReg resultGPR = result.gpr();</span>
<span class="line-modified"> 3552 </span>
<span class="line-added"> 3553         callOperation(operationBitNotBigInt, resultGPR, operandGPR);</span>
 3554         m_jit.exceptionCheck();
<span class="line-added"> 3555         cellResult(resultGPR, node);</span>
 3556 

 3557         return;
 3558     }
 3559 
<span class="line-added"> 3560     JSValueOperand operand(this, child1);</span>
<span class="line-added"> 3561     JSValueRegs operandRegs = operand.jsValueRegs();</span>
<span class="line-added"> 3562 </span>
<span class="line-added"> 3563     flushRegisters();</span>
<span class="line-added"> 3564     JSValueRegsFlushedCallResult result(this);</span>
<span class="line-added"> 3565     JSValueRegs resultRegs = result.regs();</span>
<span class="line-added"> 3566     callOperation(operationValueBitNot, resultRegs, operandRegs);</span>
<span class="line-added"> 3567     m_jit.exceptionCheck();</span>
<span class="line-added"> 3568 </span>
<span class="line-added"> 3569     jsValueResult(resultRegs, node);</span>
<span class="line-added"> 3570 }</span>
<span class="line-added"> 3571 </span>
<span class="line-added"> 3572 void SpeculativeJIT::compileBitwiseNot(Node* node)</span>
<span class="line-added"> 3573 {</span>
<span class="line-added"> 3574     Edge&amp; child1 = node-&gt;child1();</span>
<span class="line-added"> 3575 </span>
 3576     SpeculateInt32Operand operand(this, child1);
 3577     GPRTemporary result(this);
 3578     GPRReg resultGPR = result.gpr();
 3579 
 3580     m_jit.move(operand.gpr(), resultGPR);
 3581 
 3582     m_jit.not32(resultGPR);
 3583 
 3584     int32Result(resultGPR, node);
 3585 }
 3586 
 3587 template&lt;typename SnippetGenerator, J_JITOperation_EJJ snippetSlowPathFunction&gt;
 3588 void SpeculativeJIT::emitUntypedBitOp(Node* node)
 3589 {
 3590     Edge&amp; leftChild = node-&gt;child1();
 3591     Edge&amp; rightChild = node-&gt;child2();
 3592 
 3593     if (isKnownNotNumber(leftChild.node()) || isKnownNotNumber(rightChild.node())) {
 3594         JSValueOperand left(this, leftChild);
 3595         JSValueOperand right(this, rightChild);
</pre>
<hr />
<pre>
 3844     silentSpillAllRegisters(resultRegs);
 3845 
 3846     if (leftOperand.isConst()) {
 3847         leftRegs = resultRegs;
 3848         m_jit.moveValue(leftChild-&gt;asJSValue(), leftRegs);
 3849     } else if (rightOperand.isConst()) {
 3850         rightRegs = resultRegs;
 3851         m_jit.moveValue(rightChild-&gt;asJSValue(), rightRegs);
 3852     }
 3853 
 3854     callOperation(snippetSlowPathFunction, resultRegs, leftRegs, rightRegs);
 3855 
 3856     silentFillAllRegisters();
 3857     m_jit.exceptionCheck();
 3858 
 3859     gen.endJumpList().link(&amp;m_jit);
 3860     jsValueResult(resultRegs, node);
 3861     return;
 3862 }
 3863 
<span class="line-added"> 3864 void SpeculativeJIT::compileValueLShiftOp(Node* node)</span>
<span class="line-added"> 3865 {</span>
<span class="line-added"> 3866     Edge&amp; leftChild = node-&gt;child1();</span>
<span class="line-added"> 3867     Edge&amp; rightChild = node-&gt;child2();</span>
<span class="line-added"> 3868 </span>
<span class="line-added"> 3869     if (node-&gt;binaryUseKind() == BigIntUse) {</span>
<span class="line-added"> 3870         SpeculateCellOperand left(this, leftChild);</span>
<span class="line-added"> 3871         SpeculateCellOperand right(this, rightChild);</span>
<span class="line-added"> 3872         GPRReg leftGPR = left.gpr();</span>
<span class="line-added"> 3873         GPRReg rightGPR = right.gpr();</span>
<span class="line-added"> 3874 </span>
<span class="line-added"> 3875         speculateBigInt(leftChild, leftGPR);</span>
<span class="line-added"> 3876         speculateBigInt(rightChild, rightGPR);</span>
<span class="line-added"> 3877 </span>
<span class="line-added"> 3878         flushRegisters();</span>
<span class="line-added"> 3879         GPRFlushedCallResult result(this);</span>
<span class="line-added"> 3880         GPRReg resultGPR = result.gpr();</span>
<span class="line-added"> 3881 </span>
<span class="line-added"> 3882         callOperation(operationBitLShiftBigInt, resultGPR, leftGPR, rightGPR);</span>
<span class="line-added"> 3883         m_jit.exceptionCheck();</span>
<span class="line-added"> 3884         cellResult(resultGPR, node);</span>
<span class="line-added"> 3885         return;</span>
<span class="line-added"> 3886     }</span>
<span class="line-added"> 3887 </span>
<span class="line-added"> 3888     ASSERT(leftChild.useKind() == UntypedUse &amp;&amp; rightChild.useKind() == UntypedUse);</span>
<span class="line-added"> 3889     emitUntypedBitOp&lt;JITLeftShiftGenerator, operationValueBitLShift&gt;(node);</span>
<span class="line-added"> 3890 }</span>
<span class="line-added"> 3891 </span>
 3892 void SpeculativeJIT::compileShiftOp(Node* node)
 3893 {
 3894     NodeType op = node-&gt;op();
 3895     Edge&amp; leftChild = node-&gt;child1();
 3896     Edge&amp; rightChild = node-&gt;child2();
 3897 
 3898     if (leftChild.useKind() == UntypedUse || rightChild.useKind() == UntypedUse) {
 3899         switch (op) {



 3900         case BitRShift:
 3901         case BitURShift:
 3902             emitUntypedRightShiftBitOp(node);
 3903             return;
 3904         default:
 3905             RELEASE_ASSERT_NOT_REACHED();
 3906         }
 3907     }
 3908 
 3909     if (rightChild-&gt;isInt32Constant()) {
 3910         SpeculateInt32Operand op1(this, leftChild);
 3911         GPRTemporary result(this, Reuse, op1);
 3912 
 3913         shiftOp(op, op1.gpr(), rightChild-&gt;asInt32() &amp; 0x1f, result.gpr());
 3914 
 3915         int32Result(result.gpr(), node);
 3916     } else {
 3917         // Do not allow shift amount to be used as the result, MacroAssembler does not permit this.
 3918         SpeculateInt32Operand op1(this, leftChild);
 3919         SpeculateInt32Operand op2(this, rightChild);
</pre>
<hr />
<pre>
 3959 
 3960         flushRegisters();
 3961         JSValueRegsFlushedCallResult result(this);
 3962         JSValueRegs resultRegs = result.regs();
 3963         callOperation(operationValueAddNotNumber, resultRegs, leftRegs, rightRegs);
 3964         m_jit.exceptionCheck();
 3965 
 3966         jsValueResult(resultRegs, node);
 3967         return;
 3968     }
 3969 
 3970 #if USE(JSVALUE64)
 3971     bool needsScratchGPRReg = true;
 3972     bool needsScratchFPRReg = false;
 3973 #else
 3974     bool needsScratchGPRReg = true;
 3975     bool needsScratchFPRReg = true;
 3976 #endif
 3977 
 3978     CodeBlock* baselineCodeBlock = m_jit.graph().baselineCodeBlockFor(node-&gt;origin.semantic);
<span class="line-modified"> 3979     unsigned bytecodeIndex = node-&gt;origin.semantic.bytecodeIndex();</span>
<span class="line-modified"> 3980     ArithProfile* arithProfile = baselineCodeBlock-&gt;arithProfileForBytecodeOffset(bytecodeIndex);</span>
<span class="line-modified"> 3981     JITAddIC* addIC = m_jit.codeBlock()-&gt;addJITAddIC(arithProfile);</span>
 3982     auto repatchingFunction = operationValueAddOptimize;
 3983     auto nonRepatchingFunction = operationValueAdd;
 3984 
 3985     compileMathIC(node, addIC, needsScratchGPRReg, needsScratchFPRReg, repatchingFunction, nonRepatchingFunction);
 3986 }
 3987 
 3988 void SpeculativeJIT::compileValueSub(Node* node)
 3989 {
 3990     Edge&amp; leftChild = node-&gt;child1();
 3991     Edge&amp; rightChild = node-&gt;child2();
 3992 
 3993     if (node-&gt;binaryUseKind() == UntypedUse) {
 3994 #if USE(JSVALUE64)
 3995         bool needsScratchGPRReg = true;
 3996         bool needsScratchFPRReg = false;
 3997 #else
 3998         bool needsScratchGPRReg = true;
 3999         bool needsScratchFPRReg = true;
 4000 #endif
 4001 
 4002         CodeBlock* baselineCodeBlock = m_jit.graph().baselineCodeBlockFor(node-&gt;origin.semantic);
<span class="line-modified"> 4003         unsigned bytecodeIndex = node-&gt;origin.semantic.bytecodeIndex();</span>
<span class="line-modified"> 4004         ArithProfile* arithProfile = baselineCodeBlock-&gt;arithProfileForBytecodeOffset(bytecodeIndex);</span>
<span class="line-modified"> 4005         JITSubIC* subIC = m_jit.codeBlock()-&gt;addJITSubIC(arithProfile);</span>
 4006         auto repatchingFunction = operationValueSubOptimize;
 4007         auto nonRepatchingFunction = operationValueSub;
 4008 
 4009         compileMathIC(node, subIC, needsScratchGPRReg, needsScratchFPRReg, repatchingFunction, nonRepatchingFunction);
 4010         return;
 4011     }
 4012 
 4013     ASSERT(leftChild.useKind() == BigIntUse &amp;&amp; rightChild.useKind() == BigIntUse);
 4014 
 4015     SpeculateCellOperand left(this, node-&gt;child1());
 4016     SpeculateCellOperand right(this, node-&gt;child2());
 4017     GPRReg leftGPR = left.gpr();
 4018     GPRReg rightGPR = right.gpr();
 4019 
 4020     speculateBigInt(leftChild, leftGPR);
 4021     speculateBigInt(rightChild, rightGPR);
 4022 
 4023     flushRegisters();
 4024     GPRFlushedCallResult result(this);
 4025     GPRReg resultGPR = result.gpr();
</pre>
<hr />
<pre>
 4325             } else
 4326                 speculationCheck(Overflow, JSValueRegs(), 0, check);
 4327 
 4328             int32Result(gprResult, node);
 4329             return;
 4330         }
 4331 
 4332         SpeculateInt32Operand op1(this, node-&gt;child1());
 4333         SpeculateInt32Operand op2(this, node-&gt;child2());
 4334         GPRTemporary result(this, Reuse, op1, op2);
 4335 
 4336         GPRReg gpr1 = op1.gpr();
 4337         GPRReg gpr2 = op2.gpr();
 4338         GPRReg gprResult = result.gpr();
 4339 
 4340         if (!shouldCheckOverflow(node-&gt;arithMode()))
 4341             m_jit.add32(gpr1, gpr2, gprResult);
 4342         else {
 4343             MacroAssembler::Jump check = m_jit.branchAdd32(MacroAssembler::Overflow, gpr1, gpr2, gprResult);
 4344 
<span class="line-modified"> 4345             if (gpr1 == gprResult &amp;&amp; gpr2 == gprResult)</span>
<span class="line-added"> 4346                 speculationCheck(Overflow, JSValueRegs(), 0, check, SpeculationRecovery(SpeculativeAddSelf, gprResult, gpr2));</span>
<span class="line-added"> 4347             else if (gpr1 == gprResult)</span>
 4348                 speculationCheck(Overflow, JSValueRegs(), 0, check, SpeculationRecovery(SpeculativeAdd, gprResult, gpr2));
 4349             else if (gpr2 == gprResult)
 4350                 speculationCheck(Overflow, JSValueRegs(), 0, check, SpeculationRecovery(SpeculativeAdd, gprResult, gpr1));
 4351             else
 4352                 speculationCheck(Overflow, JSValueRegs(), 0, check);
 4353         }
 4354 
 4355         int32Result(gprResult, node);
 4356         return;
 4357     }
 4358 
 4359 #if USE(JSVALUE64)
 4360     case Int52RepUse: {
 4361         ASSERT(shouldCheckOverflow(node-&gt;arithMode()));
 4362         ASSERT(!shouldCheckNegativeZero(node-&gt;arithMode()));
 4363 
 4364         // Will we need an overflow check? If we can prove that neither input can be
 4365         // Int52 then the overflow check will not be necessary.
<span class="line-modified"> 4366         if (!m_state.forNode(node-&gt;child1()).couldBeType(SpecNonInt32AsInt52)</span>
<span class="line-modified"> 4367             &amp;&amp; !m_state.forNode(node-&gt;child2()).couldBeType(SpecNonInt32AsInt52)) {</span>
 4368             SpeculateWhicheverInt52Operand op1(this, node-&gt;child1());
 4369             SpeculateWhicheverInt52Operand op2(this, node-&gt;child2(), op1);
 4370             GPRTemporary result(this, Reuse, op1);
 4371             m_jit.add64(op1.gpr(), op2.gpr(), result.gpr());
 4372             int52Result(result.gpr(), node, op1.format());
 4373             return;
 4374         }
 4375 
 4376         SpeculateInt52Operand op1(this, node-&gt;child1());
 4377         SpeculateInt52Operand op2(this, node-&gt;child2());
 4378         GPRTemporary result(this);
 4379         m_jit.move(op1.gpr(), result.gpr());
 4380         speculationCheck(
 4381             Int52Overflow, JSValueRegs(), 0,
 4382             m_jit.branchAdd64(MacroAssembler::Overflow, op2.gpr(), result.gpr()));
 4383         int52Result(result.gpr(), node);
 4384         return;
 4385     }
 4386 #endif // USE(JSVALUE64)
 4387 
</pre>
<hr />
<pre>
 4532         SpeculateInt32Operand op2(this, node-&gt;child2());
 4533         GPRTemporary result(this);
 4534 
 4535         if (!shouldCheckOverflow(node-&gt;arithMode())) {
 4536             m_jit.move(op1.gpr(), result.gpr());
 4537             m_jit.sub32(op2.gpr(), result.gpr());
 4538         } else
 4539             speculationCheck(Overflow, JSValueRegs(), 0, m_jit.branchSub32(MacroAssembler::Overflow, op1.gpr(), op2.gpr(), result.gpr()));
 4540 
 4541         int32Result(result.gpr(), node);
 4542         return;
 4543     }
 4544 
 4545 #if USE(JSVALUE64)
 4546     case Int52RepUse: {
 4547         ASSERT(shouldCheckOverflow(node-&gt;arithMode()));
 4548         ASSERT(!shouldCheckNegativeZero(node-&gt;arithMode()));
 4549 
 4550         // Will we need an overflow check? If we can prove that neither input can be
 4551         // Int52 then the overflow check will not be necessary.
<span class="line-modified"> 4552         if (!m_state.forNode(node-&gt;child1()).couldBeType(SpecNonInt32AsInt52)</span>
<span class="line-modified"> 4553             &amp;&amp; !m_state.forNode(node-&gt;child2()).couldBeType(SpecNonInt32AsInt52)) {</span>
 4554             SpeculateWhicheverInt52Operand op1(this, node-&gt;child1());
 4555             SpeculateWhicheverInt52Operand op2(this, node-&gt;child2(), op1);
 4556             GPRTemporary result(this, Reuse, op1);
 4557             m_jit.move(op1.gpr(), result.gpr());
 4558             m_jit.sub64(op2.gpr(), result.gpr());
 4559             int52Result(result.gpr(), node, op1.format());
 4560             return;
 4561         }
 4562 
 4563         SpeculateInt52Operand op1(this, node-&gt;child1());
 4564         SpeculateInt52Operand op2(this, node-&gt;child2());
 4565         GPRTemporary result(this);
 4566         m_jit.move(op1.gpr(), result.gpr());
 4567         speculationCheck(
 4568             Int52Overflow, JSValueRegs(), 0,
 4569             m_jit.branchSub64(MacroAssembler::Overflow, op2.gpr(), result.gpr()));
 4570         int52Result(result.gpr(), node);
 4571         return;
 4572     }
 4573 #endif // USE(JSVALUE64)
</pre>
<hr />
<pre>
 4577         SpeculateDoubleOperand op2(this, node-&gt;child2());
 4578         FPRTemporary result(this, op1);
 4579 
 4580         FPRReg reg1 = op1.fpr();
 4581         FPRReg reg2 = op2.fpr();
 4582         m_jit.subDouble(reg1, reg2, result.fpr());
 4583 
 4584         doubleResult(result.fpr(), node);
 4585         return;
 4586     }
 4587 
 4588     default:
 4589         RELEASE_ASSERT_NOT_REACHED();
 4590         return;
 4591     }
 4592 }
 4593 
 4594 void SpeculativeJIT::compileValueNegate(Node* node)
 4595 {
 4596     CodeBlock* baselineCodeBlock = m_jit.graph().baselineCodeBlockFor(node-&gt;origin.semantic);
<span class="line-modified"> 4597     unsigned bytecodeIndex = node-&gt;origin.semantic.bytecodeIndex();</span>
<span class="line-modified"> 4598     ArithProfile* arithProfile = baselineCodeBlock-&gt;arithProfileForBytecodeOffset(bytecodeIndex);</span>
<span class="line-modified"> 4599     JITNegIC* negIC = m_jit.codeBlock()-&gt;addJITNegIC(arithProfile);</span>
 4600     auto repatchingFunction = operationArithNegateOptimize;
 4601     auto nonRepatchingFunction = operationArithNegate;
 4602     bool needsScratchGPRReg = true;
 4603     compileMathIC(node, negIC, needsScratchGPRReg, repatchingFunction, nonRepatchingFunction);
 4604 }
 4605 
 4606 void SpeculativeJIT::compileArithNegate(Node* node)
 4607 {
 4608     switch (node-&gt;child1().useKind()) {
 4609     case Int32Use: {
 4610         SpeculateInt32Operand op1(this, node-&gt;child1());
 4611         GPRTemporary result(this);
 4612 
 4613         m_jit.move(op1.gpr(), result.gpr());
 4614 
 4615         // Note: there is no notion of being not used as a number, but someone
 4616         // caring about negative zero.
 4617 
 4618         if (!shouldCheckOverflow(node-&gt;arithMode()))
 4619             m_jit.neg32(result.gpr());
 4620         else if (!shouldCheckNegativeZero(node-&gt;arithMode()))
 4621             speculationCheck(Overflow, JSValueRegs(), 0, m_jit.branchNeg32(MacroAssembler::Overflow, result.gpr()));
 4622         else {
 4623             speculationCheck(Overflow, JSValueRegs(), 0, m_jit.branchTest32(MacroAssembler::Zero, result.gpr(), TrustedImm32(0x7fffffff)));
 4624             m_jit.neg32(result.gpr());
 4625         }
 4626 
 4627         int32Result(result.gpr(), node);
 4628         return;
 4629     }
 4630 
 4631 #if USE(JSVALUE64)
 4632     case Int52RepUse: {
 4633         ASSERT(shouldCheckOverflow(node-&gt;arithMode()));
 4634 
<span class="line-modified"> 4635         if (!m_state.forNode(node-&gt;child1()).couldBeType(SpecNonInt32AsInt52)) {</span>
 4636             SpeculateWhicheverInt52Operand op1(this, node-&gt;child1());
 4637             GPRTemporary result(this);
 4638             GPRReg op1GPR = op1.gpr();
 4639             GPRReg resultGPR = result.gpr();
 4640             m_jit.move(op1GPR, resultGPR);
 4641             m_jit.neg64(resultGPR);
 4642             if (shouldCheckNegativeZero(node-&gt;arithMode())) {
 4643                 speculationCheck(
 4644                     NegativeZero, JSValueRegs(), 0,
 4645                     m_jit.branchTest64(MacroAssembler::Zero, resultGPR));
 4646             }
 4647             int52Result(resultGPR, node, op1.format());
 4648             return;
 4649         }
 4650 
 4651         SpeculateInt52Operand op1(this, node-&gt;child1());
 4652         GPRTemporary result(this);
 4653         GPRReg op1GPR = op1.gpr();
 4654         GPRReg resultGPR = result.gpr();
 4655         m_jit.move(op1GPR, resultGPR);
</pre>
<hr />
<pre>
 4800         JSValueRegs rightRegs = right.jsValueRegs();
 4801 
 4802         flushRegisters();
 4803         JSValueRegsFlushedCallResult result(this);
 4804         JSValueRegs resultRegs = result.regs();
 4805         callOperation(operationValueMul, resultRegs, leftRegs, rightRegs);
 4806         m_jit.exceptionCheck();
 4807 
 4808         jsValueResult(resultRegs, node);
 4809         return;
 4810     }
 4811 
 4812     bool needsScratchGPRReg = true;
 4813 #if USE(JSVALUE64)
 4814     bool needsScratchFPRReg = false;
 4815 #else
 4816     bool needsScratchFPRReg = true;
 4817 #endif
 4818 
 4819     CodeBlock* baselineCodeBlock = m_jit.graph().baselineCodeBlockFor(node-&gt;origin.semantic);
<span class="line-modified"> 4820     unsigned bytecodeIndex = node-&gt;origin.semantic.bytecodeIndex();</span>
<span class="line-modified"> 4821     ArithProfile* arithProfile = baselineCodeBlock-&gt;arithProfileForBytecodeOffset(bytecodeIndex);</span>
<span class="line-modified"> 4822     JITMulIC* mulIC = m_jit.codeBlock()-&gt;addJITMulIC(arithProfile);</span>
 4823     auto repatchingFunction = operationValueMulOptimize;
 4824     auto nonRepatchingFunction = operationValueMul;
 4825 
 4826     compileMathIC(node, mulIC, needsScratchGPRReg, needsScratchFPRReg, repatchingFunction, nonRepatchingFunction);
 4827 }
 4828 
 4829 void SpeculativeJIT::compileArithMul(Node* node)
 4830 {
 4831     switch (node-&gt;binaryUseKind()) {
 4832     case Int32Use: {
 4833         if (node-&gt;child2()-&gt;isInt32Constant()) {
 4834             SpeculateInt32Operand op1(this, node-&gt;child1());
 4835             GPRTemporary result(this);
 4836 
 4837             int32_t imm = node-&gt;child2()-&gt;asInt32();
 4838             GPRReg op1GPR = op1.gpr();
 4839             GPRReg resultGPR = result.gpr();
 4840 
 4841             if (!shouldCheckOverflow(node-&gt;arithMode()))
 4842                 m_jit.mul32(Imm32(imm), op1GPR, resultGPR);
</pre>
<hr />
<pre>
 5238 void SpeculativeJIT::compileArithFRound(Node* node)
 5239 {
 5240     if (node-&gt;child1().useKind() == DoubleRepUse) {
 5241         SpeculateDoubleOperand op1(this, node-&gt;child1());
 5242         FPRTemporary result(this, op1);
 5243         m_jit.convertDoubleToFloat(op1.fpr(), result.fpr());
 5244         m_jit.convertFloatToDouble(result.fpr(), result.fpr());
 5245         doubleResult(result.fpr(), node);
 5246         return;
 5247     }
 5248 
 5249     JSValueOperand op1(this, node-&gt;child1());
 5250     JSValueRegs op1Regs = op1.jsValueRegs();
 5251     flushRegisters();
 5252     FPRResult result(this);
 5253     callOperation(operationArithFRound, result.fpr(), op1Regs);
 5254     m_jit.exceptionCheck();
 5255     doubleResult(result.fpr(), node);
 5256 }
 5257 
<span class="line-added"> 5258 void SpeculativeJIT::compileValueMod(Node* node)</span>
<span class="line-added"> 5259 {</span>
<span class="line-added"> 5260     Edge&amp; leftChild = node-&gt;child1();</span>
<span class="line-added"> 5261     Edge&amp; rightChild = node-&gt;child2();</span>
<span class="line-added"> 5262 </span>
<span class="line-added"> 5263     if (node-&gt;binaryUseKind() == BigIntUse) {</span>
<span class="line-added"> 5264         SpeculateCellOperand left(this, leftChild);</span>
<span class="line-added"> 5265         SpeculateCellOperand right(this, rightChild);</span>
<span class="line-added"> 5266         GPRReg leftGPR = left.gpr();</span>
<span class="line-added"> 5267         GPRReg rightGPR = right.gpr();</span>
<span class="line-added"> 5268 </span>
<span class="line-added"> 5269         speculateBigInt(leftChild, leftGPR);</span>
<span class="line-added"> 5270         speculateBigInt(rightChild, rightGPR);</span>
<span class="line-added"> 5271 </span>
<span class="line-added"> 5272         flushRegisters();</span>
<span class="line-added"> 5273         GPRFlushedCallResult result(this);</span>
<span class="line-added"> 5274         GPRReg resultGPR = result.gpr();</span>
<span class="line-added"> 5275 </span>
<span class="line-added"> 5276         callOperation(operationModBigInt, resultGPR, leftGPR, rightGPR);</span>
<span class="line-added"> 5277 </span>
<span class="line-added"> 5278         m_jit.exceptionCheck();</span>
<span class="line-added"> 5279         cellResult(resultGPR, node);</span>
<span class="line-added"> 5280         return;</span>
<span class="line-added"> 5281     }</span>
<span class="line-added"> 5282 </span>
<span class="line-added"> 5283     DFG_ASSERT(m_jit.graph(), node, node-&gt;binaryUseKind() == UntypedUse, node-&gt;binaryUseKind());</span>
<span class="line-added"> 5284     JSValueOperand op1(this, leftChild);</span>
<span class="line-added"> 5285     JSValueOperand op2(this, rightChild);</span>
<span class="line-added"> 5286     JSValueRegs op1Regs = op1.jsValueRegs();</span>
<span class="line-added"> 5287     JSValueRegs op2Regs = op2.jsValueRegs();</span>
<span class="line-added"> 5288     flushRegisters();</span>
<span class="line-added"> 5289     JSValueRegsFlushedCallResult result(this);</span>
<span class="line-added"> 5290     JSValueRegs resultRegs = result.regs();</span>
<span class="line-added"> 5291     callOperation(operationValueMod, resultRegs, op1Regs, op2Regs);</span>
<span class="line-added"> 5292     m_jit.exceptionCheck();</span>
<span class="line-added"> 5293     jsValueResult(resultRegs, node);</span>
<span class="line-added"> 5294 }</span>
<span class="line-added"> 5295 </span>
 5296 void SpeculativeJIT::compileArithMod(Node* node)
 5297 {
 5298     switch (node-&gt;binaryUseKind()) {
 5299     case Int32Use: {
 5300         // In the fast path, the dividend value could be the final result
 5301         // (in case of |dividend| &lt; |divisor|), so we speculate it as strict int32.
 5302         SpeculateStrictInt32Operand op1(this, node-&gt;child1());
 5303 
 5304         if (node-&gt;child2()-&gt;isInt32Constant()) {
 5305             int32_t divisor = node-&gt;child2()-&gt;asInt32();
 5306             if (divisor &gt; 1 &amp;&amp; hasOneBitSet(divisor)) {
 5307                 unsigned logarithm = WTF::fastLog2(static_cast&lt;uint32_t&gt;(divisor));
 5308                 GPRReg dividendGPR = op1.gpr();
 5309                 GPRTemporary result(this);
 5310                 GPRReg resultGPR = result.gpr();
 5311 
 5312                 // This is what LLVM generates. It&#39;s pretty crazy. Here&#39;s my
 5313                 // attempt at understanding it.
 5314 
 5315                 // First, compute either divisor - 1, or 0, depending on whether
</pre>
<hr />
<pre>
 5804     MacroAssembler::JumpList skipFastPath;
 5805     skipFastPath.append(assembler.branch32(MacroAssembler::Above, yOperand, MacroAssembler::TrustedImm32(maxExponentForIntegerMathPow)));
 5806 
 5807     static const double oneConstant = 1.0;
 5808     assembler.loadDouble(MacroAssembler::TrustedImmPtr(&amp;oneConstant), result);
 5809 
 5810     MacroAssembler::Label startLoop(assembler.label());
 5811     MacroAssembler::Jump exponentIsEven = assembler.branchTest32(MacroAssembler::Zero, yOperand, MacroAssembler::TrustedImm32(1));
 5812     assembler.mulDouble(xOperand, result);
 5813     exponentIsEven.link(&amp;assembler);
 5814     assembler.mulDouble(xOperand, xOperand);
 5815     assembler.rshift32(MacroAssembler::TrustedImm32(1), yOperand);
 5816     assembler.branchTest32(MacroAssembler::NonZero, yOperand).linkTo(startLoop, &amp;assembler);
 5817 
 5818     MacroAssembler::Jump skipSlowPath = assembler.jump();
 5819     skipFastPath.link(&amp;assembler);
 5820 
 5821     return skipSlowPath;
 5822 }
 5823 
<span class="line-added"> 5824 void SpeculativeJIT::compileValuePow(Node* node)</span>
<span class="line-added"> 5825 {</span>
<span class="line-added"> 5826     Edge&amp; leftChild = node-&gt;child1();</span>
<span class="line-added"> 5827     Edge&amp; rightChild = node-&gt;child2();</span>
<span class="line-added"> 5828 </span>
<span class="line-added"> 5829     if (node-&gt;binaryUseKind() == BigIntUse) {</span>
<span class="line-added"> 5830         SpeculateCellOperand left(this, leftChild);</span>
<span class="line-added"> 5831         SpeculateCellOperand right(this, rightChild);</span>
<span class="line-added"> 5832         GPRReg leftGPR = left.gpr();</span>
<span class="line-added"> 5833         GPRReg rightGPR = right.gpr();</span>
<span class="line-added"> 5834 </span>
<span class="line-added"> 5835         speculateBigInt(leftChild, leftGPR);</span>
<span class="line-added"> 5836         speculateBigInt(rightChild, rightGPR);</span>
<span class="line-added"> 5837 </span>
<span class="line-added"> 5838         flushRegisters();</span>
<span class="line-added"> 5839         GPRFlushedCallResult result(this);</span>
<span class="line-added"> 5840         GPRReg resultGPR = result.gpr();</span>
<span class="line-added"> 5841 </span>
<span class="line-added"> 5842         callOperation(operationPowBigInt, resultGPR, leftGPR, rightGPR);</span>
<span class="line-added"> 5843 </span>
<span class="line-added"> 5844         m_jit.exceptionCheck();</span>
<span class="line-added"> 5845         cellResult(resultGPR, node);</span>
<span class="line-added"> 5846         return;</span>
<span class="line-added"> 5847     }</span>
<span class="line-added"> 5848 </span>
<span class="line-added"> 5849     DFG_ASSERT(m_jit.graph(), node, node-&gt;binaryUseKind() == UntypedUse, node-&gt;binaryUseKind());</span>
<span class="line-added"> 5850 </span>
<span class="line-added"> 5851     JSValueOperand left(this, leftChild);</span>
<span class="line-added"> 5852     JSValueOperand right(this, rightChild);</span>
<span class="line-added"> 5853     JSValueRegs leftRegs = left.jsValueRegs();</span>
<span class="line-added"> 5854     JSValueRegs rightRegs = right.jsValueRegs();</span>
<span class="line-added"> 5855 </span>
<span class="line-added"> 5856     flushRegisters();</span>
<span class="line-added"> 5857     JSValueRegsFlushedCallResult result(this);</span>
<span class="line-added"> 5858     JSValueRegs resultRegs = result.regs();</span>
<span class="line-added"> 5859     callOperation(operationValuePow, resultRegs, leftRegs, rightRegs);</span>
<span class="line-added"> 5860     m_jit.exceptionCheck();</span>
<span class="line-added"> 5861 </span>
<span class="line-added"> 5862     jsValueResult(resultRegs, node);</span>
<span class="line-added"> 5863 }</span>
<span class="line-added"> 5864 </span>
 5865 void SpeculativeJIT::compileArithPow(Node* node)
 5866 {
 5867     if (node-&gt;child2().useKind() == Int32Use) {
 5868         SpeculateDoubleOperand xOperand(this, node-&gt;child1());
 5869         SpeculateInt32Operand yOperand(this, node-&gt;child2());
 5870         FPRReg xOperandfpr = xOperand.fpr();
 5871         GPRReg yOperandGpr = yOperand.gpr();
 5872         FPRTemporary yOperandfpr(this);
 5873 
 5874         flushRegisters();
 5875 
 5876         FPRResult result(this);
 5877         FPRReg resultFpr = result.fpr();
 5878 
 5879         FPRTemporary xOperandCopy(this);
 5880         FPRReg xOperandCopyFpr = xOperandCopy.fpr();
 5881         m_jit.moveDouble(xOperandfpr, xOperandCopyFpr);
 5882 
 5883         GPRTemporary counter(this);
 5884         GPRReg counterGpr = counter.gpr();
</pre>
<hr />
<pre>
 6692 
 6693     GPRFlushedCallResult result(this);
 6694     GPRReg resultGPR = result.gpr();
 6695     callOperation(operationSameValue, resultGPR, arg1Regs, arg2Regs);
 6696     m_jit.exceptionCheck();
 6697 
 6698     unblessedBooleanResult(resultGPR, node, UseChildrenCalledExplicitly);
 6699 }
 6700 
 6701 void SpeculativeJIT::compileStringZeroLength(Node* node)
 6702 {
 6703     SpeculateCellOperand str(this, node-&gt;child1());
 6704     GPRReg strGPR = str.gpr();
 6705 
 6706     // Make sure that this is a string.
 6707     speculateString(node-&gt;child1(), strGPR);
 6708 
 6709     GPRTemporary eq(this);
 6710     GPRReg eqGPR = eq.gpr();
 6711 
<span class="line-modified"> 6712     m_jit.move(TrustedImmPtr::weakPointer(m_jit.graph(), jsEmptyString(vm())), eqGPR);</span>
 6713     m_jit.comparePtr(CCallHelpers::Equal, strGPR, eqGPR, eqGPR);
 6714     unblessedBooleanResult(eqGPR, node);
 6715 }
 6716 
 6717 void SpeculativeJIT::compileLogicalNotStringOrOther(Node* node)
 6718 {
 6719     JSValueOperand value(this, node-&gt;child1(), ManualOperandSpeculation);
 6720     GPRTemporary temp(this);
 6721     JSValueRegs valueRegs = value.jsValueRegs();
 6722     GPRReg tempGPR = temp.gpr();
 6723 
 6724     JITCompiler::Jump notCell = m_jit.branchIfNotCell(valueRegs);
 6725     GPRReg cellGPR = valueRegs.payloadGPR();
 6726     DFG_TYPE_CHECK(
 6727         valueRegs, node-&gt;child1(), (~SpecCellCheck) | SpecString, m_jit.branchIfNotString(cellGPR));
 6728 
<span class="line-modified"> 6729     m_jit.move(TrustedImmPtr::weakPointer(m_jit.graph(), jsEmptyString(vm())), tempGPR);</span>
 6730     m_jit.comparePtr(CCallHelpers::Equal, cellGPR, tempGPR, tempGPR);
 6731     auto done = m_jit.jump();
 6732 
 6733     notCell.link(&amp;m_jit);
 6734     DFG_TYPE_CHECK(
 6735         valueRegs, node-&gt;child1(), SpecCellCheck | SpecOther, m_jit.branchIfNotOther(valueRegs, tempGPR));
 6736     m_jit.move(TrustedImm32(1), tempGPR);
 6737 
 6738     done.link(&amp;m_jit);
 6739     unblessedBooleanResult(tempGPR, node);
 6740 
 6741 }
 6742 
 6743 void SpeculativeJIT::emitStringBranch(Edge nodeUse, BasicBlock* taken, BasicBlock* notTaken)
 6744 {
 6745     SpeculateCellOperand str(this, nodeUse);
 6746 
 6747     GPRReg strGPR = str.gpr();
 6748 
 6749     speculateString(nodeUse, strGPR);
 6750 
<span class="line-modified"> 6751     branchPtr(CCallHelpers::Equal, strGPR, TrustedImmPtr::weakPointer(m_jit.graph(), jsEmptyString(vm())), notTaken);</span>
 6752     jump(taken);
 6753 
 6754     noResult(m_currentNode);
 6755 }
 6756 
 6757 void SpeculativeJIT::emitStringOrOtherBranch(Edge nodeUse, BasicBlock* taken, BasicBlock* notTaken)
 6758 {
 6759     JSValueOperand value(this, nodeUse, ManualOperandSpeculation);
 6760     GPRTemporary temp(this);
 6761     JSValueRegs valueRegs = value.jsValueRegs();
 6762     GPRReg tempGPR = temp.gpr();
 6763 
 6764     JITCompiler::Jump notCell = m_jit.branchIfNotCell(valueRegs);
 6765     GPRReg cellGPR = valueRegs.payloadGPR();
 6766     DFG_TYPE_CHECK(valueRegs, nodeUse, (~SpecCellCheck) | SpecString, m_jit.branchIfNotString(cellGPR));
 6767 
<span class="line-modified"> 6768     branchPtr(CCallHelpers::Equal, cellGPR, TrustedImmPtr::weakPointer(m_jit.graph(), jsEmptyString(vm())), notTaken);</span>
 6769     jump(taken, ForceJump);
 6770 
 6771     notCell.link(&amp;m_jit);
 6772     DFG_TYPE_CHECK(
 6773         valueRegs, nodeUse, SpecCellCheck | SpecOther, m_jit.branchIfNotOther(valueRegs, tempGPR));
 6774     jump(notTaken);
 6775     noResult(m_currentNode);
 6776 }
 6777 
 6778 void SpeculativeJIT::compileConstantStoragePointer(Node* node)
 6779 {
 6780     GPRTemporary storage(this);
 6781     GPRReg storageGPR = storage.gpr();
 6782     m_jit.move(TrustedImmPtr(node-&gt;storagePointer()), storageGPR);
 6783     storageResult(storageGPR, node);
 6784 }
 6785 
<span class="line-modified"> 6786 void SpeculativeJIT::cageTypedArrayStorage(GPRReg baseReg, GPRReg storageReg)</span>
 6787 {
<span class="line-added"> 6788     auto untagArrayPtr = [&amp;]() {</span>
<span class="line-added"> 6789 #if CPU(ARM64E)</span>
<span class="line-added"> 6790         m_jit.untagArrayPtr(MacroAssembler::Address(baseReg, JSArrayBufferView::offsetOfLength()), storageReg);</span>
<span class="line-added"> 6791 #else</span>
<span class="line-added"> 6792         UNUSED_PARAM(baseReg);</span>
<span class="line-added"> 6793         UNUSED_PARAM(storageReg);</span>
<span class="line-added"> 6794 #endif</span>
<span class="line-added"> 6795     };</span>
<span class="line-added"> 6796 </span>
 6797 #if GIGACAGE_ENABLED
<span class="line-modified"> 6798     UNUSED_PARAM(baseReg);</span>
<span class="line-added"> 6799     if (!Gigacage::shouldBeEnabled()) {</span>
<span class="line-added"> 6800         untagArrayPtr();</span>
 6801         return;
<span class="line-added"> 6802     }</span>
 6803 
 6804     if (Gigacage::canPrimitiveGigacageBeDisabled()) {
<span class="line-modified"> 6805         VM&amp; vm = this-&gt;vm();</span>
<span class="line-modified"> 6806         if (vm.primitiveGigacageEnabled().isStillValid())</span>
<span class="line-modified"> 6807             m_jit.graph().watchpoints().addLazily(vm.primitiveGigacageEnabled());</span>
<span class="line-added"> 6808         else {</span>
<span class="line-added"> 6809             untagArrayPtr();</span>
 6810             return;
<span class="line-added"> 6811         }</span>
 6812     }
 6813 
<span class="line-modified"> 6814     m_jit.cageWithoutUntagging(Gigacage::Primitive, storageReg);</span>


 6815 #endif
<span class="line-added"> 6816     untagArrayPtr();</span>
 6817 }
 6818 
 6819 void SpeculativeJIT::compileGetIndexedPropertyStorage(Node* node)
 6820 {
 6821     SpeculateCellOperand base(this, node-&gt;child1());
 6822     GPRReg baseReg = base.gpr();
 6823 
 6824     GPRTemporary storage(this);
 6825     GPRReg storageReg = storage.gpr();
 6826 
 6827     switch (node-&gt;arrayMode().type()) {
 6828     case Array::String:
 6829         m_jit.loadPtr(MacroAssembler::Address(baseReg, JSString::offsetOfValue()), storageReg);
 6830 
 6831         addSlowPathGenerator(
 6832             slowPathCall(
 6833                 m_jit.branchIfRopeStringImpl(storageReg),
 6834                 this, operationResolveRope, storageReg, baseReg));
 6835 
 6836         m_jit.loadPtr(MacroAssembler::Address(storageReg, StringImpl::dataOffset()), storageReg);
 6837         break;
 6838 
<span class="line-modified"> 6839     default: {</span>
 6840         auto typedArrayType = node-&gt;arrayMode().typedArrayType();
 6841         ASSERT_UNUSED(typedArrayType, isTypedView(typedArrayType));
 6842 
 6843         m_jit.loadPtr(JITCompiler::Address(baseReg, JSArrayBufferView::offsetOfVector()), storageReg);
<span class="line-modified"> 6844         cageTypedArrayStorage(baseReg, storageReg);</span>
 6845         break;
 6846     }
<span class="line-added"> 6847     }</span>
 6848 
 6849     storageResult(storageReg, node);
 6850 }
 6851 
 6852 void SpeculativeJIT::compileGetTypedArrayByteOffset(Node* node)
 6853 {
 6854     SpeculateCellOperand base(this, node-&gt;child1());
 6855     GPRTemporary vector(this);
 6856     GPRTemporary data(this);
 6857 
 6858     GPRReg baseGPR = base.gpr();
 6859     GPRReg vectorGPR = vector.gpr();
 6860     GPRReg dataGPR = data.gpr();
 6861     ASSERT(baseGPR != vectorGPR);
 6862     ASSERT(baseGPR != dataGPR);
 6863     ASSERT(vectorGPR != dataGPR);
 6864 
 6865     GPRReg arrayBufferGPR = dataGPR;
 6866 
 6867     JITCompiler::Jump emptyByteOffset = m_jit.branch32(
 6868         MacroAssembler::NotEqual,
 6869         MacroAssembler::Address(baseGPR, JSArrayBufferView::offsetOfMode()),
 6870         TrustedImm32(WastefulTypedArray));
 6871 
 6872     m_jit.loadPtr(MacroAssembler::Address(baseGPR, JSArrayBufferView::offsetOfVector()), vectorGPR);
<span class="line-added"> 6873 </span>
<span class="line-added"> 6874     // FIXME: This should mask the PAC bits</span>
<span class="line-added"> 6875     // https://bugs.webkit.org/show_bug.cgi?id=197701</span>
 6876     JITCompiler::Jump nullVector = m_jit.branchTestPtr(JITCompiler::Zero, vectorGPR);
 6877 
 6878     m_jit.loadPtr(MacroAssembler::Address(baseGPR, JSObject::butterflyOffset()), dataGPR);
<span class="line-modified"> 6879     m_jit.cageWithoutUntagging(Gigacage::JSValue, dataGPR);</span>
 6880 
<span class="line-modified"> 6881     cageTypedArrayStorage(baseGPR, vectorGPR);</span>
 6882 
 6883     m_jit.loadPtr(MacroAssembler::Address(dataGPR, Butterfly::offsetOfArrayBuffer()), arrayBufferGPR);
 6884     // FIXME: This needs caging.
 6885     // https://bugs.webkit.org/show_bug.cgi?id=175515
 6886     m_jit.loadPtr(MacroAssembler::Address(arrayBufferGPR, ArrayBuffer::offsetOfData()), dataGPR);
<span class="line-added"> 6887 #if CPU(ARM64E)</span>
<span class="line-added"> 6888     m_jit.removeArrayPtrTag(dataGPR);</span>
<span class="line-added"> 6889 #endif</span>
<span class="line-added"> 6890 </span>
 6891     m_jit.subPtr(dataGPR, vectorGPR);
 6892 
 6893     JITCompiler::Jump done = m_jit.jump();
 6894 
 6895     emptyByteOffset.link(&amp;m_jit);
 6896     m_jit.move(TrustedImmPtr(nullptr), vectorGPR);
 6897 
 6898     done.link(&amp;m_jit);
 6899     nullVector.link(&amp;m_jit);
 6900 
 6901     int32Result(vectorGPR, node);
 6902 }
 6903 
 6904 void SpeculativeJIT::compileGetByValOnDirectArguments(Node* node)
 6905 {
 6906     SpeculateCellOperand base(this, m_graph.varArgChild(node, 0));
 6907     SpeculateStrictInt32Operand property(this, m_graph.varArgChild(node, 1));
 6908     JSValueRegsTemporary result(this);
 6909     GPRTemporary scratch(this);
 6910 
</pre>
<hr />
<pre>
 7027 {
 7028     SpeculateCellOperand function(this, node-&gt;child1());
 7029     GPRTemporary result(this, Reuse, function);
 7030     m_jit.loadPtr(JITCompiler::Address(function.gpr(), JSFunction::offsetOfScopeChain()), result.gpr());
 7031     cellResult(result.gpr(), node);
 7032 }
 7033 
 7034 void SpeculativeJIT::compileSkipScope(Node* node)
 7035 {
 7036     SpeculateCellOperand scope(this, node-&gt;child1());
 7037     GPRTemporary result(this, Reuse, scope);
 7038     m_jit.loadPtr(JITCompiler::Address(scope.gpr(), JSScope::offsetOfNext()), result.gpr());
 7039     cellResult(result.gpr(), node);
 7040 }
 7041 
 7042 void SpeculativeJIT::compileGetGlobalObject(Node* node)
 7043 {
 7044     SpeculateCellOperand object(this, node-&gt;child1());
 7045     GPRTemporary result(this);
 7046     GPRTemporary scratch(this);
<span class="line-modified"> 7047     m_jit.emitLoadStructure(vm(), object.gpr(), result.gpr(), scratch.gpr());</span>
 7048     m_jit.loadPtr(JITCompiler::Address(result.gpr(), Structure::globalObjectOffset()), result.gpr());
 7049     cellResult(result.gpr(), node);
 7050 }
 7051 
 7052 void SpeculativeJIT::compileGetGlobalThis(Node* node)
 7053 {
 7054     GPRTemporary result(this);
 7055     GPRReg resultGPR = result.gpr();
 7056     auto* globalObject = m_jit.graph().globalObjectFor(node-&gt;origin.semantic);
 7057     m_jit.loadPtr(globalObject-&gt;addressOfGlobalThis(), resultGPR);
 7058     cellResult(resultGPR, node);
 7059 }
 7060 
<span class="line-added"> 7061 bool SpeculativeJIT::canBeRope(Edge&amp; edge)</span>
<span class="line-added"> 7062 {</span>
<span class="line-added"> 7063     if (m_state.forNode(edge).isType(SpecStringIdent))</span>
<span class="line-added"> 7064         return false;</span>
<span class="line-added"> 7065     // If this value is LazyValue, it will be converted to JSString, and the result must be non-rope string.</span>
<span class="line-added"> 7066     String string = edge-&gt;tryGetString(m_graph);</span>
<span class="line-added"> 7067     if (!string.isNull())</span>
<span class="line-added"> 7068         return false;</span>
<span class="line-added"> 7069     return true;</span>
<span class="line-added"> 7070 }</span>
<span class="line-added"> 7071 </span>
 7072 void SpeculativeJIT::compileGetArrayLength(Node* node)
 7073 {
 7074     switch (node-&gt;arrayMode().type()) {
 7075     case Array::Undecided:
 7076     case Array::Int32:
 7077     case Array::Double:
 7078     case Array::Contiguous: {
 7079         StorageOperand storage(this, node-&gt;child2());
 7080         GPRTemporary result(this, Reuse, storage);
 7081         GPRReg storageReg = storage.gpr();
 7082         GPRReg resultReg = result.gpr();
 7083         m_jit.load32(MacroAssembler::Address(storageReg, Butterfly::offsetOfPublicLength()), resultReg);
 7084 
 7085         int32Result(resultReg, node);
 7086         break;
 7087     }
 7088     case Array::ArrayStorage:
 7089     case Array::SlowPutArrayStorage: {
 7090         StorageOperand storage(this, node-&gt;child2());
 7091         GPRTemporary result(this, Reuse, storage);
 7092         GPRReg storageReg = storage.gpr();
 7093         GPRReg resultReg = result.gpr();
 7094         m_jit.load32(MacroAssembler::Address(storageReg, Butterfly::offsetOfPublicLength()), resultReg);
 7095 
 7096         speculationCheck(Uncountable, JSValueRegs(), 0, m_jit.branch32(MacroAssembler::LessThan, resultReg, MacroAssembler::TrustedImm32(0)));
 7097 
 7098         int32Result(resultReg, node);
 7099         break;
 7100     }
 7101     case Array::String: {
 7102         SpeculateCellOperand base(this, node-&gt;child1());
 7103         GPRTemporary result(this, Reuse, base);
 7104         GPRTemporary temp(this);
 7105         GPRReg baseGPR = base.gpr();
 7106         GPRReg resultGPR = result.gpr();
 7107         GPRReg tempGPR = temp.gpr();
 7108 
<span class="line-added"> 7109         bool needsRopeCase = canBeRope(node-&gt;child1());</span>
<span class="line-added"> 7110 </span>
 7111         m_jit.loadPtr(MacroAssembler::Address(baseGPR, JSString::offsetOfValue()), tempGPR);
<span class="line-modified"> 7112         CCallHelpers::Jump isRope;</span>
<span class="line-added"> 7113         if (needsRopeCase)</span>
<span class="line-added"> 7114             isRope = m_jit.branchIfRopeStringImpl(tempGPR);</span>
 7115         m_jit.load32(MacroAssembler::Address(tempGPR, StringImpl::lengthMemoryOffset()), resultGPR);
<span class="line-modified"> 7116         if (needsRopeCase) {</span>
<span class="line-added"> 7117             auto done = m_jit.jump();</span>
 7118 
<span class="line-modified"> 7119             isRope.link(&amp;m_jit);</span>
<span class="line-modified"> 7120             m_jit.load32(CCallHelpers::Address(baseGPR, JSRopeString::offsetOfLength()), resultGPR);</span>
 7121 
<span class="line-modified"> 7122             done.link(&amp;m_jit);</span>
<span class="line-added"> 7123         }</span>
 7124         int32Result(resultGPR, node);
 7125         break;
 7126     }
 7127     case Array::DirectArguments: {
 7128         SpeculateCellOperand base(this, node-&gt;child1());
 7129         GPRTemporary result(this, Reuse, base);
 7130 
 7131         GPRReg baseReg = base.gpr();
 7132         GPRReg resultReg = result.gpr();
 7133 
 7134         if (!m_compileOkay)
 7135             return;
 7136 
 7137         ASSERT(ArrayMode(Array::DirectArguments, Array::Read).alreadyChecked(m_jit.graph(), node, m_state.forNode(node-&gt;child1())));
 7138 
 7139         speculationCheck(
 7140             ExoticObjectMode, JSValueSource(), 0,
 7141             m_jit.branchTestPtr(
 7142                 MacroAssembler::NonZero,
 7143                 MacroAssembler::Address(baseReg, DirectArguments::offsetOfMappedArguments())));
</pre>
<hr />
<pre>
 7198     speculateString(node-&gt;child1(), stringGPR);
 7199     speculateStringIdentAndLoadStorage(node-&gt;child1(), stringGPR, storageGPR);
 7200 
 7201     UniquedStringImpl* uid = node-&gt;uidOperand();
 7202     speculationCheck(
 7203         BadIdent, JSValueSource(), nullptr,
 7204         m_jit.branchPtr(JITCompiler::NotEqual, storageGPR, TrustedImmPtr(uid)));
 7205     noResult(node);
 7206 }
 7207 
 7208 template &lt;typename ClassType&gt;
 7209 void SpeculativeJIT::compileNewFunctionCommon(GPRReg resultGPR, RegisteredStructure structure, GPRReg scratch1GPR, GPRReg scratch2GPR, GPRReg scopeGPR, MacroAssembler::JumpList&amp; slowPath, size_t size, FunctionExecutable* executable)
 7210 {
 7211     auto butterfly = TrustedImmPtr(nullptr);
 7212     emitAllocateJSObjectWithKnownSize&lt;ClassType&gt;(resultGPR, TrustedImmPtr(structure), butterfly, scratch1GPR, scratch2GPR, slowPath, size);
 7213 
 7214     m_jit.storePtr(scopeGPR, JITCompiler::Address(resultGPR, JSFunction::offsetOfScopeChain()));
 7215     m_jit.storePtr(TrustedImmPtr::weakPointer(m_jit.graph(), executable), JITCompiler::Address(resultGPR, JSFunction::offsetOfExecutable()));
 7216     m_jit.storePtr(TrustedImmPtr(nullptr), JITCompiler::Address(resultGPR, JSFunction::offsetOfRareData()));
 7217 
<span class="line-modified"> 7218     if (executable-&gt;isAnonymousBuiltinFunction()) {</span>
<span class="line-added"> 7219         VM&amp; vm = this-&gt;vm();</span>
<span class="line-added"> 7220         m_jit.mutatorFence(vm);</span>
<span class="line-added"> 7221         GPRTemporary allocator(this);</span>
<span class="line-added"> 7222         Allocator allocatorValue = allocatorForNonVirtualConcurrently&lt;FunctionRareData&gt;(vm, sizeof(FunctionRareData), AllocatorForMode::AllocatorIfExists);</span>
<span class="line-added"> 7223         emitAllocateJSCell(scratch1GPR, JITAllocator::constant(allocatorValue), allocator.gpr(), TrustedImmPtr(m_jit.graph().registerStructure(vm.functionRareDataStructure.get())), scratch2GPR, slowPath);</span>
<span class="line-added"> 7224 </span>
<span class="line-added"> 7225         ptrdiff_t objectAllocationProfileOffset = FunctionRareData::offsetOfObjectAllocationProfile();</span>
<span class="line-added"> 7226         m_jit.storePtr(TrustedImmPtr(nullptr), JITCompiler::Address(scratch1GPR, objectAllocationProfileOffset + ObjectAllocationProfileWithPrototype::offsetOfAllocator()));</span>
<span class="line-added"> 7227         m_jit.storePtr(TrustedImmPtr(nullptr), JITCompiler::Address(scratch1GPR, objectAllocationProfileOffset + ObjectAllocationProfileWithPrototype::offsetOfStructure()));</span>
<span class="line-added"> 7228         m_jit.storePtr(TrustedImmPtr(nullptr), JITCompiler::Address(scratch1GPR, objectAllocationProfileOffset + ObjectAllocationProfileWithPrototype::offsetOfPrototype()));</span>
<span class="line-added"> 7229         m_jit.storePtr(TrustedImmPtr(0x1), JITCompiler::Address(scratch1GPR, FunctionRareData::offsetOfObjectAllocationProfileWatchpoint()));</span>
<span class="line-added"> 7230         m_jit.storePtr(TrustedImmPtr(nullptr), JITCompiler::Address(scratch1GPR, FunctionRareData::offsetOfInternalFunctionAllocationProfile() + InternalFunctionAllocationProfile::offsetOfStructure()));</span>
<span class="line-added"> 7231         m_jit.storePtr(TrustedImmPtr(nullptr), JITCompiler::Address(scratch1GPR, FunctionRareData::offsetOfBoundFunctionStructure()));</span>
<span class="line-added"> 7232         m_jit.storePtr(TrustedImmPtr(nullptr), JITCompiler::Address(scratch1GPR, FunctionRareData::offsetOfAllocationProfileClearingWatchpoint()));</span>
<span class="line-added"> 7233         m_jit.store8(TrustedImm32(0), JITCompiler::Address(scratch1GPR, FunctionRareData::offsetOfHasReifiedLength()));</span>
<span class="line-added"> 7234         m_jit.store8(TrustedImm32(1), JITCompiler::Address(scratch1GPR, FunctionRareData::offsetOfHasReifiedName()));</span>
<span class="line-added"> 7235         m_jit.mutatorFence(vm);</span>
<span class="line-added"> 7236         m_jit.storePtr(scratch1GPR, JITCompiler::Address(resultGPR, JSFunction::offsetOfRareData()));</span>
<span class="line-added"> 7237     } else</span>
<span class="line-added"> 7238         m_jit.mutatorFence(vm());</span>
<span class="line-added"> 7239 </span>
 7240 }
 7241 
 7242 void SpeculativeJIT::compileNewFunction(Node* node)
 7243 {
 7244     NodeType nodeType = node-&gt;op();
 7245     ASSERT(nodeType == NewFunction || nodeType == NewGeneratorFunction || nodeType == NewAsyncFunction || nodeType == NewAsyncGeneratorFunction);
 7246 
 7247     SpeculateCellOperand scope(this, node-&gt;child1());
 7248     GPRReg scopeGPR = scope.gpr();
 7249 
 7250     FunctionExecutable* executable = node-&gt;castOperand&lt;FunctionExecutable*&gt;();
 7251 
<span class="line-modified"> 7252     if (executable-&gt;singleton().isStillValid()) {</span>
 7253         GPRFlushedCallResult result(this);
 7254         GPRReg resultGPR = result.gpr();
 7255 
 7256         flushRegisters();
 7257 
 7258         if (nodeType == NewGeneratorFunction)
 7259             callOperation(operationNewGeneratorFunction, resultGPR, scopeGPR, executable);
 7260         else if (nodeType == NewAsyncFunction)
 7261             callOperation(operationNewAsyncFunction, resultGPR, scopeGPR, executable);
 7262         else if (nodeType == NewAsyncGeneratorFunction)
 7263             callOperation(operationNewAsyncGeneratorFunction, resultGPR, scopeGPR, executable);
 7264         else
 7265             callOperation(operationNewFunction, resultGPR, scopeGPR, executable);
 7266         m_jit.exceptionCheck();
 7267         cellResult(resultGPR, node);
 7268         return;
 7269     }
 7270 
 7271     RegisteredStructure structure = m_jit.graph().registerStructure(
 7272         [&amp;] () {
</pre>
<hr />
<pre>
 7377 
 7378     speculationCheck(
 7379         VarargsOverflow, JSValueSource(), Edge(), m_jit.branch32(
 7380             MacroAssembler::Above,
 7381             argCountIncludingThisGPR,
 7382             TrustedImm32(data-&gt;limit)));
 7383 
 7384     m_jit.store32(argCountIncludingThisGPR, JITCompiler::payloadFor(data-&gt;machineCount));
 7385 
 7386     callOperation(operationLoadVarargs, data-&gt;machineStart.offset(), argumentsRegs, data-&gt;offset, GPRInfo::returnValueGPR, data-&gt;mandatoryMinimum);
 7387     m_jit.exceptionCheck();
 7388 
 7389     noResult(node);
 7390 }
 7391 
 7392 void SpeculativeJIT::compileForwardVarargs(Node* node)
 7393 {
 7394     LoadVarargsData* data = node-&gt;loadVarargsData();
 7395     InlineCallFrame* inlineCallFrame;
 7396     if (node-&gt;child1())
<span class="line-modified"> 7397         inlineCallFrame = node-&gt;child1()-&gt;origin.semantic.inlineCallFrame();</span>
 7398     else
<span class="line-modified"> 7399         inlineCallFrame = node-&gt;origin.semantic.inlineCallFrame();</span>
 7400 
 7401     GPRTemporary length(this);
 7402     JSValueRegsTemporary temp(this);
 7403     GPRReg lengthGPR = length.gpr();
 7404     JSValueRegs tempRegs = temp.regs();
 7405 
 7406     emitGetLength(inlineCallFrame, lengthGPR, /* includeThis = */ true);
 7407     if (data-&gt;offset)
 7408         m_jit.sub32(TrustedImm32(data-&gt;offset), lengthGPR);
 7409 
 7410     speculationCheck(
 7411         VarargsOverflow, JSValueSource(), Edge(), m_jit.branch32(
 7412             MacroAssembler::Above,
 7413             lengthGPR, TrustedImm32(data-&gt;limit)));
 7414 
 7415     m_jit.store32(lengthGPR, JITCompiler::payloadFor(data-&gt;machineCount));
 7416 
 7417     VirtualRegister sourceStart = JITCompiler::argumentsStart(inlineCallFrame) + data-&gt;offset;
 7418     VirtualRegister targetStart = data-&gt;machineStart;
 7419 
</pre>
<hr />
<pre>
 7449             GPRInfo::callFrameRegister, lengthGPR, JITCompiler::TimesEight,
 7450             targetStart.offset() * sizeof(EncodedJSValue)));
 7451     m_jit.branchTest32(JITCompiler::NonZero, lengthGPR).linkTo(loop, &amp;m_jit);
 7452 
 7453     done.link(&amp;m_jit);
 7454 
 7455     noResult(node);
 7456 }
 7457 
 7458 void SpeculativeJIT::compileCreateActivation(Node* node)
 7459 {
 7460     SymbolTable* table = node-&gt;castOperand&lt;SymbolTable*&gt;();
 7461     RegisteredStructure structure = m_jit.graph().registerStructure(m_jit.graph().globalObjectFor(
 7462         node-&gt;origin.semantic)-&gt;activationStructure());
 7463 
 7464     SpeculateCellOperand scope(this, node-&gt;child1());
 7465     GPRReg scopeGPR = scope.gpr();
 7466     JSValue initializationValue = node-&gt;initializationValueForActivation();
 7467     ASSERT(initializationValue == jsUndefined() || initializationValue == jsTDZValue());
 7468 
<span class="line-modified"> 7469     if (table-&gt;singleton().isStillValid()) {</span>
 7470         GPRFlushedCallResult result(this);
 7471         GPRReg resultGPR = result.gpr();
 7472 
 7473 #if USE(JSVALUE32_64)
 7474         JSValueRegsTemporary initialization(this);
 7475         JSValueRegs initializationRegs = initialization.regs();
 7476         m_jit.moveTrustedValue(initializationValue, initializationRegs);
 7477 #endif
 7478 
 7479         flushRegisters();
 7480 
 7481 #if USE(JSVALUE64)
 7482         callOperation(operationCreateActivationDirect,
 7483             resultGPR, structure, scopeGPR, table, TrustedImm64(JSValue::encode(initializationValue)));
 7484 #else
 7485         callOperation(operationCreateActivationDirect,
 7486             resultGPR, structure, scopeGPR, table, initializationRegs);
 7487 #endif
 7488         m_jit.exceptionCheck();
 7489         cellResult(resultGPR, node);
</pre>
<hr />
<pre>
 7507     auto butterfly = TrustedImmPtr(nullptr);
 7508     emitAllocateJSObjectWithKnownSize&lt;JSLexicalEnvironment&gt;(
 7509         resultGPR, TrustedImmPtr(structure), butterfly, scratch1GPR, scratch2GPR,
 7510         slowPath, JSLexicalEnvironment::allocationSize(table));
 7511 
 7512     // Don&#39;t need a memory barriers since we just fast-created the activation, so the
 7513     // activation must be young.
 7514     m_jit.storePtr(scopeGPR, JITCompiler::Address(resultGPR, JSScope::offsetOfNext()));
 7515     m_jit.storePtr(
 7516         TrustedImmPtr(node-&gt;cellOperand()),
 7517         JITCompiler::Address(resultGPR, JSLexicalEnvironment::offsetOfSymbolTable()));
 7518 
 7519     // Must initialize all members to undefined or the TDZ empty value.
 7520     for (unsigned i = 0; i &lt; table-&gt;scopeSize(); ++i) {
 7521         m_jit.storeTrustedValue(
 7522             initializationValue,
 7523             JITCompiler::Address(
 7524                 resultGPR, JSLexicalEnvironment::offsetOfVariable(ScopeOffset(i))));
 7525     }
 7526 
<span class="line-modified"> 7527     m_jit.mutatorFence(vm());</span>
 7528 
 7529 #if USE(JSVALUE64)
 7530     addSlowPathGenerator(
 7531         slowPathCall(
 7532             slowPath, this, operationCreateActivationDirect, resultGPR, structure, scopeGPR, table, TrustedImm64(JSValue::encode(initializationValue))));
 7533 #else
 7534     addSlowPathGenerator(
 7535         slowPathCall(
 7536             slowPath, this, operationCreateActivationDirect, resultGPR, structure, scopeGPR, table, initializationRegs));
 7537 #endif
 7538 
 7539     cellResult(resultGPR, node);
 7540 }
 7541 
 7542 void SpeculativeJIT::compileCreateDirectArguments(Node* node)
 7543 {
 7544     // FIXME: A more effective way of dealing with the argument count and callee is to have
 7545     // them be explicit arguments to this node.
 7546     // https://bugs.webkit.org/show_bug.cgi?id=142207
 7547 
 7548     GPRTemporary result(this);
 7549     GPRTemporary scratch1(this);
 7550     GPRTemporary scratch2(this);
 7551     GPRTemporary length;
 7552     GPRReg resultGPR = result.gpr();
 7553     GPRReg scratch1GPR = scratch1.gpr();
 7554     GPRReg scratch2GPR = scratch2.gpr();
 7555     GPRReg lengthGPR = InvalidGPRReg;
 7556     JSValueRegs valueRegs = JSValueRegs::withTwoAvailableRegs(scratch1GPR, scratch2GPR);
 7557 
 7558     unsigned minCapacity = m_jit.graph().baselineCodeBlockFor(node-&gt;origin.semantic)-&gt;numParameters() - 1;
 7559 
 7560     unsigned knownLength;
 7561     bool lengthIsKnown; // if false, lengthGPR will have the length.
<span class="line-modified"> 7562     auto* inlineCallFrame = node-&gt;origin.semantic.inlineCallFrame();</span>
<span class="line-modified"> 7563     if (inlineCallFrame</span>
<span class="line-modified"> 7564         &amp;&amp; !inlineCallFrame-&gt;isVarargs()) {</span>
<span class="line-added"> 7565         knownLength = inlineCallFrame-&gt;argumentCountIncludingThis - 1;</span>
 7566         lengthIsKnown = true;
 7567     } else {
 7568         knownLength = UINT_MAX;
 7569         lengthIsKnown = false;
 7570 
 7571         GPRTemporary realLength(this);
 7572         length.adopt(realLength);
 7573         lengthGPR = length.gpr();
 7574 
 7575         VirtualRegister argumentCountRegister = m_jit.argumentCount(node-&gt;origin.semantic);
 7576         m_jit.load32(JITCompiler::payloadFor(argumentCountRegister), lengthGPR);
 7577         m_jit.sub32(TrustedImm32(1), lengthGPR);
 7578     }
 7579 
 7580     RegisteredStructure structure =
 7581         m_jit.graph().registerStructure(m_jit.graph().globalObjectFor(node-&gt;origin.semantic)-&gt;directArgumentsStructure());
 7582 
 7583     // Use a different strategy for allocating the object depending on whether we know its
 7584     // size statically.
 7585     JITCompiler::JumpList slowPath;
</pre>
<hr />
<pre>
 7614         m_jit.store32(
 7615             lengthGPR, JITCompiler::Address(resultGPR, DirectArguments::offsetOfLength()));
 7616     }
 7617 
 7618     m_jit.store32(
 7619         TrustedImm32(minCapacity),
 7620         JITCompiler::Address(resultGPR, DirectArguments::offsetOfMinCapacity()));
 7621 
 7622     m_jit.storePtr(
 7623         TrustedImmPtr(nullptr), JITCompiler::Address(resultGPR, DirectArguments::offsetOfMappedArguments()));
 7624 
 7625     m_jit.storePtr(
 7626         TrustedImmPtr(nullptr), JITCompiler::Address(resultGPR, DirectArguments::offsetOfModifiedArgumentsDescriptor()));
 7627 
 7628     if (lengthIsKnown) {
 7629         addSlowPathGenerator(
 7630             slowPathCall(
 7631                 slowPath, this, operationCreateDirectArguments, resultGPR, structure,
 7632                 knownLength, minCapacity));
 7633     } else {
<span class="line-modified"> 7634         auto generator = makeUnique&lt;CallCreateDirectArgumentsSlowPathGenerator&gt;(</span>
 7635             slowPath, this, resultGPR, structure, lengthGPR, minCapacity);
 7636         addSlowPathGenerator(WTFMove(generator));
 7637     }
 7638 
<span class="line-modified"> 7639     if (inlineCallFrame) {</span>
<span class="line-modified"> 7640         if (inlineCallFrame-&gt;isClosureCall) {</span>
 7641             m_jit.loadPtr(
 7642                 JITCompiler::addressFor(
<span class="line-modified"> 7643                     inlineCallFrame-&gt;calleeRecovery.virtualRegister()),</span>
 7644                 scratch1GPR);
 7645         } else {
 7646             m_jit.move(
 7647                 TrustedImmPtr::weakPointer(
<span class="line-modified"> 7648                     m_jit.graph(), inlineCallFrame-&gt;calleeRecovery.constant().asCell()),</span>
 7649                 scratch1GPR);
 7650         }
 7651     } else
 7652         m_jit.loadPtr(JITCompiler::addressFor(CallFrameSlot::callee), scratch1GPR);
 7653 
 7654     // Don&#39;t need a memory barriers since we just fast-created the activation, so the
 7655     // activation must be young.
 7656     m_jit.storePtr(
 7657         scratch1GPR, JITCompiler::Address(resultGPR, DirectArguments::offsetOfCallee()));
 7658 
 7659     VirtualRegister start = m_jit.argumentsStart(node-&gt;origin.semantic);
 7660     if (lengthIsKnown) {
 7661         for (unsigned i = 0; i &lt; std::max(knownLength, minCapacity); ++i) {
 7662             m_jit.loadValue(JITCompiler::addressFor(start + i), valueRegs);
 7663             m_jit.storeValue(
 7664                 valueRegs, JITCompiler::Address(resultGPR, DirectArguments::offsetOfSlot(i)));
 7665         }
 7666     } else {
 7667         JITCompiler::Jump done;
 7668         if (minCapacity) {
</pre>
<hr />
<pre>
 7672             startLoop.link(&amp;m_jit);
 7673         } else
 7674             done = m_jit.branchTest32(MacroAssembler::Zero, lengthGPR);
 7675         JITCompiler::Label loop = m_jit.label();
 7676         m_jit.sub32(TrustedImm32(1), lengthGPR);
 7677         m_jit.loadValue(
 7678             JITCompiler::BaseIndex(
 7679                 GPRInfo::callFrameRegister, lengthGPR, JITCompiler::TimesEight,
 7680                 start.offset() * static_cast&lt;int&gt;(sizeof(Register))),
 7681             valueRegs);
 7682         m_jit.storeValue(
 7683             valueRegs,
 7684             JITCompiler::BaseIndex(
 7685                 resultGPR, lengthGPR, JITCompiler::TimesEight,
 7686                 DirectArguments::storageOffset()));
 7687         m_jit.branchTest32(MacroAssembler::NonZero, lengthGPR).linkTo(loop, &amp;m_jit);
 7688         if (done.isSet())
 7689             done.link(&amp;m_jit);
 7690     }
 7691 
<span class="line-modified"> 7692     m_jit.mutatorFence(vm());</span>
 7693 
 7694     cellResult(resultGPR, node);
 7695 }
 7696 
 7697 void SpeculativeJIT::compileGetFromArguments(Node* node)
 7698 {
 7699     SpeculateCellOperand arguments(this, node-&gt;child1());
 7700     JSValueRegsTemporary result(this);
 7701 
 7702     GPRReg argumentsGPR = arguments.gpr();
 7703     JSValueRegs resultRegs = result.regs();
 7704 
 7705     m_jit.loadValue(JITCompiler::Address(argumentsGPR, DirectArguments::offsetOfSlot(node-&gt;capturedArgumentsOffset().offset())), resultRegs);
 7706     jsValueResult(resultRegs, node);
 7707 }
 7708 
 7709 void SpeculativeJIT::compilePutToArguments(Node* node)
 7710 {
 7711     SpeculateCellOperand arguments(this, node-&gt;child1());
 7712     JSValueOperand value(this, node-&gt;child2());
</pre>
<hr />
<pre>
 7892         GPRReg scratch1GPR = scratch1.gpr();
 7893         GPRReg scratch2GPR = scratch2.gpr();
 7894         GPRReg lengthGPR = length.gpr();
 7895         FPRReg doubleFPR = doubleRegister.fpr();
 7896 
 7897         MacroAssembler::JumpList slowPath;
 7898 
 7899         m_jit.load8(MacroAssembler::Address(argument, JSCell::indexingTypeAndMiscOffset()), scratch1GPR);
 7900         m_jit.and32(TrustedImm32(IndexingShapeMask), scratch1GPR);
 7901         m_jit.sub32(TrustedImm32(Int32Shape), scratch1GPR);
 7902 
 7903         slowPath.append(m_jit.branch32(MacroAssembler::Above, scratch1GPR, TrustedImm32(ContiguousShape - Int32Shape)));
 7904 
 7905         m_jit.loadPtr(MacroAssembler::Address(argument, JSObject::butterflyOffset()), lengthGPR);
 7906         m_jit.load32(MacroAssembler::Address(lengthGPR, Butterfly::offsetOfPublicLength()), lengthGPR);
 7907         static_assert(sizeof(JSValue) == 8 &amp;&amp; 1 &lt;&lt; 3 == 8, &quot;This is strongly assumed in the code below.&quot;);
 7908         m_jit.move(lengthGPR, scratch1GPR);
 7909         m_jit.lshift32(TrustedImm32(3), scratch1GPR);
 7910         m_jit.add32(TrustedImm32(JSFixedArray::offsetOfData()), scratch1GPR);
 7911 
<span class="line-modified"> 7912         m_jit.emitAllocateVariableSizedCell&lt;JSFixedArray&gt;(vm(), resultGPR, TrustedImmPtr(m_jit.graph().registerStructure(m_jit.graph().m_vm.fixedArrayStructure.get())), scratch1GPR, scratch1GPR, scratch2GPR, slowPath);</span>
 7913         m_jit.store32(lengthGPR, MacroAssembler::Address(resultGPR, JSFixedArray::offsetOfSize()));
 7914 
 7915         m_jit.loadPtr(MacroAssembler::Address(argument, JSObject::butterflyOffset()), scratch1GPR);
 7916 
 7917         MacroAssembler::JumpList done;
 7918 
 7919         m_jit.load8(MacroAssembler::Address(argument, JSCell::indexingTypeAndMiscOffset()), scratch2GPR);
 7920         m_jit.and32(TrustedImm32(IndexingShapeMask), scratch2GPR);
 7921         auto isDoubleArray = m_jit.branch32(MacroAssembler::Equal, scratch2GPR, TrustedImm32(DoubleShape));
 7922 
 7923         {
 7924             done.append(m_jit.branchTest32(MacroAssembler::Zero, lengthGPR));
 7925             auto loopStart = m_jit.label();
 7926             m_jit.sub32(TrustedImm32(1), lengthGPR);
 7927             m_jit.load64(MacroAssembler::BaseIndex(scratch1GPR, lengthGPR, MacroAssembler::TimesEight), scratch2GPR);
 7928             auto notEmpty = m_jit.branchIfNotEmpty(scratch2GPR);
 7929             m_jit.move(TrustedImm64(JSValue::encode(jsUndefined())), scratch2GPR);
 7930             notEmpty.link(&amp;m_jit);
 7931             m_jit.store64(scratch2GPR, MacroAssembler::BaseIndex(resultGPR, lengthGPR, MacroAssembler::TimesEight, JSFixedArray::offsetOfData()));
 7932             m_jit.branchTest32(MacroAssembler::NonZero, lengthGPR).linkTo(loopStart, &amp;m_jit);
 7933             done.append(m_jit.jump());
 7934         }
 7935 
 7936         isDoubleArray.link(&amp;m_jit);
 7937         {
 7938             done.append(m_jit.branchTest32(MacroAssembler::Zero, lengthGPR));
 7939             auto loopStart = m_jit.label();
 7940             m_jit.sub32(TrustedImm32(1), lengthGPR);
 7941             m_jit.loadDouble(MacroAssembler::BaseIndex(scratch1GPR, lengthGPR, MacroAssembler::TimesEight), doubleFPR);
 7942             auto notEmpty = m_jit.branchIfNotNaN(doubleFPR);
 7943             m_jit.move(TrustedImm64(JSValue::encode(jsUndefined())), scratch2GPR);
 7944             auto doStore = m_jit.jump();
 7945             notEmpty.link(&amp;m_jit);
 7946             m_jit.boxDouble(doubleFPR, scratch2GPR);
 7947             doStore.link(&amp;m_jit);
 7948             m_jit.store64(scratch2GPR, MacroAssembler::BaseIndex(resultGPR, lengthGPR, MacroAssembler::TimesEight, JSFixedArray::offsetOfData()));
 7949             m_jit.branchTest32(MacroAssembler::NonZero, lengthGPR).linkTo(loopStart, &amp;m_jit);
 7950             done.append(m_jit.jump());
 7951         }
 7952 
<span class="line-modified"> 7953         m_jit.mutatorFence(vm());</span>
 7954 
 7955         slowPath.link(&amp;m_jit);
 7956         addSlowPathGenerator(slowPathCall(m_jit.jump(), this, operationSpreadFastArray, resultGPR, argument));
 7957 
 7958         done.link(&amp;m_jit);
 7959         cellResult(resultGPR, node);
 7960 #else
 7961         flushRegisters();
 7962 
 7963         GPRFlushedCallResult result(this);
 7964         GPRReg resultGPR = result.gpr();
 7965         callOperation(operationSpreadFastArray, resultGPR, argument);
 7966         m_jit.exceptionCheck();
 7967         cellResult(resultGPR, node);
 7968 #endif // USE(JSVALUE64)
 7969     } else {
 7970         flushRegisters();
 7971 
 7972         GPRFlushedCallResult result(this);
 7973         GPRReg resultGPR = result.gpr();
</pre>
<hr />
<pre>
 8044         // that&#39;s the least of what&#39;s wrong with this code. We really shouldn&#39;t be
 8045         // allocating the array after having computed - and probably spilled to the
 8046         // stack - all of the things that will go into the array. The solution to that
 8047         // bigger problem will also likely fix the redundancy in reloading the storage
 8048         // pointer that we currently have.
 8049 
 8050         cellResult(resultGPR, node);
 8051         return;
 8052     }
 8053 
 8054     if (!node-&gt;numChildren()) {
 8055         flushRegisters();
 8056         GPRFlushedCallResult result(this);
 8057         callOperation(operationNewEmptyArray, result.gpr(), m_jit.graph().registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(node-&gt;indexingType())));
 8058         m_jit.exceptionCheck();
 8059         cellResult(result.gpr(), node);
 8060         return;
 8061     }
 8062 
 8063     size_t scratchSize = sizeof(EncodedJSValue) * node-&gt;numChildren();
<span class="line-modified"> 8064     ScratchBuffer* scratchBuffer = vm().scratchBufferForSize(scratchSize);</span>
 8065     EncodedJSValue* buffer = scratchBuffer ? static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer()) : nullptr;
 8066 
 8067     for (unsigned operandIdx = 0; operandIdx &lt; node-&gt;numChildren(); ++operandIdx) {
 8068         // Need to perform the speculations that this node promises to perform. If we&#39;re
 8069         // emitting code here and the indexing type is not array storage then there is
 8070         // probably something hilarious going on and we&#39;re already failing at all the
 8071         // things, but at least we&#39;re going to be sound.
 8072         Edge use = m_jit.graph().m_varArgChildren[node-&gt;firstChild() + operandIdx];
 8073         switch (node-&gt;indexingType()) {
 8074         case ALL_BLANK_INDEXING_TYPES:
 8075         case ALL_UNDECIDED_INDEXING_TYPES:
 8076             CRASH();
 8077             break;
 8078         case ALL_DOUBLE_INDEXING_TYPES: {
 8079             SpeculateDoubleOperand operand(this, use);
 8080             FPRReg opFPR = operand.fpr();
 8081             DFG_TYPE_CHECK(
 8082                 JSValueRegs(), use, SpecDoubleReal,
 8083                 m_jit.branchIfNaN(opFPR));
 8084 #if USE(JSVALUE64)
</pre>
<hr />
<pre>
 8216                 m_jit.addPtr(TrustedImm32(1), fixedIndexGPR);
 8217                 m_jit.addPtr(TrustedImm32(1), indexGPR);
 8218                 m_jit.branchPtr(MacroAssembler::Below, fixedIndexGPR, fixedLengthGPR).linkTo(loopStart, &amp;m_jit);
 8219 
 8220                 done.link(&amp;m_jit);
 8221             } else {
 8222                 JSValueOperand item(this, use);
 8223                 GPRReg itemGPR = item.gpr();
 8224                 m_jit.store64(itemGPR, MacroAssembler::BaseIndex(storageGPR, indexGPR, MacroAssembler::TimesEight));
 8225                 m_jit.addPtr(TrustedImm32(1), indexGPR);
 8226             }
 8227         }
 8228 
 8229         cellResult(resultGPR, node);
 8230         return;
 8231     }
 8232 #endif // USE(JSVALUE64)
 8233 
 8234     ASSERT(node-&gt;numChildren());
 8235     size_t scratchSize = sizeof(EncodedJSValue) * node-&gt;numChildren();
<span class="line-modified"> 8236     ScratchBuffer* scratchBuffer = vm().scratchBufferForSize(scratchSize);</span>
 8237     EncodedJSValue* buffer = static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer());
 8238 
 8239     BitVector* bitVector = node-&gt;bitVector();
 8240     for (unsigned i = 0; i &lt; node-&gt;numChildren(); ++i) {
 8241         Edge use = m_jit.graph().m_varArgChildren[node-&gt;firstChild() + i];
 8242         if (bitVector-&gt;get(i)) {
 8243             SpeculateCellOperand fixedArray(this, use);
 8244             GPRReg arrayGPR = fixedArray.gpr();
 8245 #if USE(JSVALUE64)
 8246             m_jit.store64(arrayGPR, &amp;buffer[i]);
 8247 #else
 8248             char* pointer = static_cast&lt;char*&gt;(static_cast&lt;void*&gt;(&amp;buffer[i]));
 8249             m_jit.store32(arrayGPR, pointer + PayloadOffset);
 8250             m_jit.store32(TrustedImm32(JSValue::CellTag), pointer + TagOffset);
 8251 #endif
 8252         } else {
 8253             JSValueOperand input(this, use);
 8254             JSValueRegs inputRegs = input.jsValueRegs();
 8255             m_jit.storeValue(inputRegs, &amp;buffer[i]);
 8256         }
</pre>
<hr />
<pre>
 8429 
 8430         isInt32.link(&amp;m_jit);
 8431         m_jit.move(TrustedImmPtr(m_jit.graph().registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithInt32))), tempValue);
 8432         emitMoveEmptyValue(JSValue());
 8433 
 8434         done.link(&amp;m_jit);
 8435 
 8436         MacroAssembler::JumpList slowCases;
 8437         m_jit.move(TrustedImmPtr(nullptr), storageResultGPR);
 8438         // Enable the fast case on 64-bit platforms, where a sufficient amount of GP registers should be available.
 8439         // Other platforms could support the same approach with custom code, but that is not currently worth the extra code maintenance.
 8440         if (is64Bit()) {
 8441             GPRTemporary scratch(this);
 8442             GPRTemporary scratch2(this);
 8443             GPRReg scratchGPR = scratch.gpr();
 8444             GPRReg scratch2GPR = scratch2.gpr();
 8445 
 8446             emitAllocateButterfly(storageResultGPR, sizeGPR, scratchGPR, scratch2GPR, resultGPR, slowCases);
 8447             emitInitializeButterfly(storageResultGPR, sizeGPR, emptyValueRegs, scratchGPR);
 8448             emitAllocateJSObject&lt;JSArray&gt;(resultGPR, tempValue, storageResultGPR, scratchGPR, scratch2GPR, slowCases);
<span class="line-modified"> 8449             m_jit.mutatorFence(vm());</span>
 8450         } else {
 8451             slowCases.append(m_jit.jump());
 8452         }
 8453 
<span class="line-modified"> 8454         addSlowPathGenerator(makeUnique&lt;CallArrayAllocatorWithVariableStructureVariableSizeSlowPathGenerator&gt;(</span>
 8455             slowCases, this, operationNewArrayWithSize, resultGPR, tempValue, sizeGPR, storageResultGPR));
 8456     }
 8457 
 8458     GPRTemporary temp4(this);
 8459     GPRReg loadIndex = temp4.gpr();
 8460 
 8461     if (node-&gt;numChildren() == 2) {
 8462         m_jit.load32(MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()), tempGPR);
 8463         m_jit.move(TrustedImm32(0), loadIndex);
 8464     } else {
 8465         m_jit.load32(MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()), tempValue);
 8466         if (node-&gt;numChildren() == 4)
 8467             emitPopulateSliceIndex(m_jit.graph().varArgChild(node, 2), WTF::nullopt, tempValue, tempGPR);
 8468         else
 8469             m_jit.move(tempValue, tempGPR);
 8470         emitPopulateSliceIndex(m_jit.graph().varArgChild(node, 1), WTF::nullopt, tempValue, loadIndex);
 8471     }
 8472 
 8473     GPRTemporary temp5(this);
 8474     GPRReg storeIndex = temp5.gpr();
</pre>
<hr />
<pre>
 8727     unsigned elementCount = node-&gt;numChildren() - elementOffset;
 8728 
 8729 #if USE(JSVALUE32_64)
 8730     GPRTemporary tag(this);
 8731     GPRReg tagGPR = tag.gpr();
 8732     JSValueRegs resultRegs { tagGPR, storageLengthGPR };
 8733 #else
 8734     JSValueRegs resultRegs { storageLengthGPR };
 8735 #endif
 8736 
 8737     auto getStorageBufferAddress = [&amp;] (GPRReg storageGPR, GPRReg indexGPR, int32_t offset, GPRReg bufferGPR) {
 8738         static_assert(sizeof(JSValue) == 8 &amp;&amp; 1 &lt;&lt; 3 == 8, &quot;This is strongly assumed in the code below.&quot;);
 8739         m_jit.getEffectiveAddress(MacroAssembler::BaseIndex(storageGPR, indexGPR, MacroAssembler::TimesEight, offset), bufferGPR);
 8740     };
 8741 
 8742     switch (node-&gt;arrayMode().type()) {
 8743     case Array::Int32:
 8744     case Array::Contiguous: {
 8745         if (elementCount == 1) {
 8746             Edge&amp; element = m_jit.graph().varArgChild(node, elementOffset);
<span class="line-added"> 8747             if (node-&gt;arrayMode().type() == Array::Int32) {</span>
<span class="line-added"> 8748                 ASSERT(element.useKind() == Int32Use);</span>
<span class="line-added"> 8749                 speculateInt32(element);</span>
<span class="line-added"> 8750             }</span>
 8751             JSValueOperand value(this, element, ManualOperandSpeculation);
 8752             JSValueRegs valueRegs = value.jsValueRegs();
 8753 



 8754             m_jit.load32(MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()), storageLengthGPR);
 8755             MacroAssembler::Jump slowPath = m_jit.branch32(MacroAssembler::AboveOrEqual, storageLengthGPR, MacroAssembler::Address(storageGPR, Butterfly::offsetOfVectorLength()));
 8756             m_jit.storeValue(valueRegs, MacroAssembler::BaseIndex(storageGPR, storageLengthGPR, MacroAssembler::TimesEight));
 8757             m_jit.add32(TrustedImm32(1), storageLengthGPR);
 8758             m_jit.store32(storageLengthGPR, MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()));
 8759             m_jit.boxInt32(storageLengthGPR, resultRegs);
 8760 
 8761             addSlowPathGenerator(
 8762                 slowPathCall(slowPath, this, operationArrayPush, resultRegs, valueRegs, baseGPR));
 8763 
 8764             jsValueResult(resultRegs, node);
 8765             return;
 8766         }
 8767 
<span class="line-added"> 8768         if (node-&gt;arrayMode().type() == Array::Int32) {</span>
<span class="line-added"> 8769             for (unsigned elementIndex = 0; elementIndex &lt; elementCount; ++elementIndex) {</span>
<span class="line-added"> 8770                 Edge element = m_jit.graph().varArgChild(node, elementIndex + elementOffset);</span>
<span class="line-added"> 8771                 ASSERT(element.useKind() == Int32Use);</span>
<span class="line-added"> 8772                 speculateInt32(element);</span>
<span class="line-added"> 8773             }</span>
<span class="line-added"> 8774         }</span>
<span class="line-added"> 8775 </span>
 8776         GPRTemporary buffer(this);
 8777         GPRReg bufferGPR = buffer.gpr();
 8778 
 8779         m_jit.load32(MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()), storageLengthGPR);
 8780         m_jit.move(storageLengthGPR, bufferGPR);
 8781         m_jit.add32(TrustedImm32(elementCount), bufferGPR);
 8782         MacroAssembler::Jump slowPath = m_jit.branch32(MacroAssembler::Above, bufferGPR, MacroAssembler::Address(storageGPR, Butterfly::offsetOfVectorLength()));
 8783 
 8784         m_jit.store32(bufferGPR, MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()));
 8785         getStorageBufferAddress(storageGPR, storageLengthGPR, 0, bufferGPR);
 8786         m_jit.add32(TrustedImm32(elementCount), storageLengthGPR);
 8787         m_jit.boxInt32(storageLengthGPR, resultRegs);
 8788         auto storageDone = m_jit.jump();
 8789 
 8790         slowPath.link(&amp;m_jit);
 8791 
 8792         size_t scratchSize = sizeof(EncodedJSValue) * elementCount;
<span class="line-modified"> 8793         ScratchBuffer* scratchBuffer = vm().scratchBufferForSize(scratchSize);</span>
 8794         m_jit.move(TrustedImmPtr(static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer())), bufferGPR);
 8795         m_jit.move(TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), storageLengthGPR);
 8796         m_jit.storePtr(TrustedImmPtr(scratchSize), MacroAssembler::Address(storageLengthGPR));
 8797 
 8798         storageDone.link(&amp;m_jit);
 8799         for (unsigned elementIndex = 0; elementIndex &lt; elementCount; ++elementIndex) {
 8800             Edge&amp; element = m_jit.graph().varArgChild(node, elementIndex + elementOffset);
<span class="line-modified"> 8801             JSValueOperand value(this, element, ManualOperandSpeculation); // We did type checks above.</span>
 8802             JSValueRegs valueRegs = value.jsValueRegs();
 8803 



 8804             m_jit.storeValue(valueRegs, MacroAssembler::Address(bufferGPR, sizeof(EncodedJSValue) * elementIndex));
 8805             value.use();
 8806         }
 8807 
 8808         MacroAssembler::Jump fastPath = m_jit.branchPtr(MacroAssembler::NotEqual, bufferGPR, TrustedImmPtr(static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer())));
 8809 
 8810         addSlowPathGenerator(slowPathCall(m_jit.jump(), this, operationArrayPushMultiple, resultRegs, baseGPR, bufferGPR, TrustedImm32(elementCount)));
 8811 
 8812         m_jit.move(TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), bufferGPR);
 8813         m_jit.storePtr(TrustedImmPtr(nullptr), MacroAssembler::Address(bufferGPR));
 8814 
 8815         base.use();
 8816         storage.use();
 8817 
 8818         fastPath.link(&amp;m_jit);
 8819         jsValueResult(resultRegs, node, DataFormatJS, UseChildrenCalledExplicitly);
 8820         return;
 8821     }
 8822 
 8823     case Array::Double: {
 8824         if (elementCount == 1) {
 8825             Edge&amp; element = m_jit.graph().varArgChild(node, elementOffset);
<span class="line-added"> 8826             speculate(node, element);</span>
 8827             SpeculateDoubleOperand value(this, element);
 8828             FPRReg valueFPR = value.fpr();
 8829 


 8830             m_jit.load32(MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()), storageLengthGPR);
 8831             MacroAssembler::Jump slowPath = m_jit.branch32(MacroAssembler::AboveOrEqual, storageLengthGPR, MacroAssembler::Address(storageGPR, Butterfly::offsetOfVectorLength()));
 8832             m_jit.storeDouble(valueFPR, MacroAssembler::BaseIndex(storageGPR, storageLengthGPR, MacroAssembler::TimesEight));
 8833             m_jit.add32(TrustedImm32(1), storageLengthGPR);
 8834             m_jit.store32(storageLengthGPR, MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()));
 8835             m_jit.boxInt32(storageLengthGPR, resultRegs);
 8836 
 8837             addSlowPathGenerator(
 8838                 slowPathCall(slowPath, this, operationArrayPushDouble, resultRegs, valueFPR, baseGPR));
 8839 
 8840             jsValueResult(resultRegs, node);
 8841             return;
 8842         }
 8843 
<span class="line-added"> 8844         for (unsigned elementIndex = 0; elementIndex &lt; elementCount; ++elementIndex) {</span>
<span class="line-added"> 8845             Edge element = m_jit.graph().varArgChild(node, elementIndex + elementOffset);</span>
<span class="line-added"> 8846             ASSERT(element.useKind() == DoubleRepRealUse);</span>
<span class="line-added"> 8847             speculate(node, element);</span>
<span class="line-added"> 8848         }</span>
<span class="line-added"> 8849 </span>
 8850         GPRTemporary buffer(this);
 8851         GPRReg bufferGPR = buffer.gpr();
 8852 
 8853         m_jit.load32(MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()), storageLengthGPR);
 8854         m_jit.move(storageLengthGPR, bufferGPR);
 8855         m_jit.add32(TrustedImm32(elementCount), bufferGPR);
 8856         MacroAssembler::Jump slowPath = m_jit.branch32(MacroAssembler::Above, bufferGPR, MacroAssembler::Address(storageGPR, Butterfly::offsetOfVectorLength()));
 8857 
 8858         m_jit.store32(bufferGPR, MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()));
 8859         getStorageBufferAddress(storageGPR, storageLengthGPR, 0, bufferGPR);
 8860         m_jit.add32(TrustedImm32(elementCount), storageLengthGPR);
 8861         m_jit.boxInt32(storageLengthGPR, resultRegs);
 8862         auto storageDone = m_jit.jump();
 8863 
 8864         slowPath.link(&amp;m_jit);
 8865 
 8866         size_t scratchSize = sizeof(double) * elementCount;
<span class="line-modified"> 8867         ScratchBuffer* scratchBuffer = vm().scratchBufferForSize(scratchSize);</span>
 8868         m_jit.move(TrustedImmPtr(static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer())), bufferGPR);
 8869         m_jit.move(TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), storageLengthGPR);
 8870         m_jit.storePtr(TrustedImmPtr(scratchSize), MacroAssembler::Address(storageLengthGPR));
 8871 
 8872         storageDone.link(&amp;m_jit);
 8873         for (unsigned elementIndex = 0; elementIndex &lt; elementCount; ++elementIndex) {
 8874             Edge&amp; element = m_jit.graph().varArgChild(node, elementIndex + elementOffset);
 8875             SpeculateDoubleOperand value(this, element);
 8876             FPRReg valueFPR = value.fpr();
 8877 


 8878             m_jit.storeDouble(valueFPR, MacroAssembler::Address(bufferGPR, sizeof(double) * elementIndex));
 8879             value.use();
 8880         }
 8881 
 8882         MacroAssembler::Jump fastPath = m_jit.branchPtr(MacroAssembler::NotEqual, bufferGPR, TrustedImmPtr(static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer())));
 8883 
 8884         addSlowPathGenerator(slowPathCall(m_jit.jump(), this, operationArrayPushDoubleMultiple, resultRegs, baseGPR, bufferGPR, TrustedImm32(elementCount)));
 8885 
 8886         m_jit.move(TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), bufferGPR);
 8887         m_jit.storePtr(TrustedImmPtr(nullptr), MacroAssembler::Address(bufferGPR));
 8888 
 8889         base.use();
 8890         storage.use();
 8891 
 8892         fastPath.link(&amp;m_jit);
 8893         jsValueResult(resultRegs, node, DataFormatJS, UseChildrenCalledExplicitly);
 8894         return;
 8895     }
 8896 
 8897     case Array::ArrayStorage: {
</pre>
<hr />
<pre>
 8928 
 8929         m_jit.load32(MacroAssembler::Address(storageGPR, ArrayStorage::lengthOffset()), storageLengthGPR);
 8930 
 8931         // Refuse to handle bizarre lengths.
 8932         speculationCheck(Uncountable, JSValueRegs(), 0, m_jit.branch32(MacroAssembler::Above, storageLengthGPR, TrustedImm32(largestPositiveInt32Length)));
 8933 
 8934         m_jit.move(storageLengthGPR, bufferGPR);
 8935         m_jit.add32(TrustedImm32(elementCount), bufferGPR);
 8936         MacroAssembler::Jump slowPath = m_jit.branch32(MacroAssembler::Above, bufferGPR, MacroAssembler::Address(storageGPR, ArrayStorage::vectorLengthOffset()));
 8937 
 8938         m_jit.store32(bufferGPR, MacroAssembler::Address(storageGPR, ArrayStorage::lengthOffset()));
 8939         getStorageBufferAddress(storageGPR, storageLengthGPR, ArrayStorage::vectorOffset(), bufferGPR);
 8940         m_jit.add32(TrustedImm32(elementCount), MacroAssembler::Address(storageGPR, OBJECT_OFFSETOF(ArrayStorage, m_numValuesInVector)));
 8941         m_jit.add32(TrustedImm32(elementCount), storageLengthGPR);
 8942         m_jit.boxInt32(storageLengthGPR, resultRegs);
 8943         auto storageDone = m_jit.jump();
 8944 
 8945         slowPath.link(&amp;m_jit);
 8946 
 8947         size_t scratchSize = sizeof(EncodedJSValue) * elementCount;
<span class="line-modified"> 8948         ScratchBuffer* scratchBuffer = vm().scratchBufferForSize(scratchSize);</span>
 8949         m_jit.move(TrustedImmPtr(static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer())), bufferGPR);
 8950         m_jit.move(TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), storageLengthGPR);
 8951         m_jit.storePtr(TrustedImmPtr(scratchSize), MacroAssembler::Address(storageLengthGPR));
 8952 
 8953         storageDone.link(&amp;m_jit);
 8954         for (unsigned elementIndex = 0; elementIndex &lt; elementCount; ++elementIndex) {
 8955             Edge&amp; element = m_jit.graph().varArgChild(node, elementIndex + elementOffset);
 8956             JSValueOperand value(this, element);
 8957             JSValueRegs valueRegs = value.jsValueRegs();
 8958 
 8959             m_jit.storeValue(valueRegs, MacroAssembler::Address(bufferGPR, sizeof(EncodedJSValue) * elementIndex));
 8960             value.use();
 8961         }
 8962 
 8963         MacroAssembler::Jump fastPath = m_jit.branchPtr(MacroAssembler::NotEqual, bufferGPR, TrustedImmPtr(static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer())));
 8964 
 8965         addSlowPathGenerator(
 8966             slowPathCall(m_jit.jump(), this, operationArrayPushMultiple, resultRegs, baseGPR, bufferGPR, TrustedImm32(elementCount)));
 8967 
 8968         m_jit.move(TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), bufferGPR);
</pre>
<hr />
<pre>
 9097     done.link(&amp;m_jit);
 9098 
 9099     unblessedBooleanResult(resultGPR, node);
 9100 }
 9101 
 9102 void SpeculativeJIT::compileTypeOf(Node* node)
 9103 {
 9104     JSGlobalObject* globalObject = m_jit.graph().globalObjectFor(node-&gt;origin.semantic);
 9105 
 9106     JSValueOperand value(this, node-&gt;child1());
 9107     JSValueRegs valueRegs = value.jsValueRegs();
 9108 
 9109     GPRTemporary result(this);
 9110     GPRReg resultGPR = result.gpr();
 9111 
 9112     JITCompiler::JumpList done;
 9113     JITCompiler::Jump slowPath;
 9114     m_jit.emitTypeOf(
 9115         valueRegs, resultGPR,
 9116         [&amp;] (TypeofType type, bool fallsThrough) {
<span class="line-modified"> 9117             m_jit.move(TrustedImmPtr::weakPointer(m_jit.graph(), vm().smallStrings.typeString(type)), resultGPR);</span>
 9118             if (!fallsThrough)
 9119                 done.append(m_jit.jump());
 9120         },
 9121         [&amp;] (JITCompiler::Jump theSlowPath) {
 9122             slowPath = theSlowPath;
 9123         });
 9124     done.link(&amp;m_jit);
 9125 
 9126     addSlowPathGenerator(
 9127         slowPathCall(
 9128             slowPath, this, operationTypeOfObject, resultGPR, globalObject,
 9129             valueRegs.payloadGPR()));
 9130 
 9131     cellResult(resultGPR, node);
 9132 }
 9133 
 9134 void SpeculativeJIT::emitStructureCheck(Node* node, GPRReg cellGPR, GPRReg tempGPR)
 9135 {
 9136     ASSERT(node-&gt;structureSet().size());
 9137 
 9138     if (node-&gt;structureSet().size() == 1) {
 9139         speculationCheck(
 9140             BadCache, JSValueSource::unboxedCell(cellGPR), 0,
 9141             m_jit.branchWeakStructure(
 9142                 JITCompiler::NotEqual,
 9143                 JITCompiler::Address(cellGPR, JSCell::structureIDOffset()),
 9144                 node-&gt;structureSet()[0]));
 9145     } else {
 9146         std::unique_ptr&lt;GPRTemporary&gt; structure;
 9147         GPRReg structureGPR;
 9148 
 9149         if (tempGPR == InvalidGPRReg) {
<span class="line-modified"> 9150             structure = makeUnique&lt;GPRTemporary&gt;(this);</span>
 9151             structureGPR = structure-&gt;gpr();
 9152         } else
 9153             structureGPR = tempGPR;
 9154 
 9155         m_jit.load32(JITCompiler::Address(cellGPR, JSCell::structureIDOffset()), structureGPR);
 9156 
 9157         JITCompiler::JumpList done;
 9158 
 9159         for (size_t i = 0; i &lt; node-&gt;structureSet().size() - 1; ++i) {
 9160             done.append(
 9161                 m_jit.branchWeakStructure(JITCompiler::Equal, structureGPR, node-&gt;structureSet()[i]));
 9162         }
 9163 
 9164         speculationCheck(
 9165             BadCache, JSValueSource::unboxedCell(cellGPR), 0,
 9166             m_jit.branchWeakStructure(
 9167                 JITCompiler::NotEqual, structureGPR, node-&gt;structureSet().last()));
 9168 
 9169         done.link(&amp;m_jit);
 9170     }
</pre>
<hr />
<pre>
 9211         cell.link(&amp;m_jit);
 9212         emitStructureCheck(node, valueRegs.payloadGPR(), tempGPR);
 9213         done.link(&amp;m_jit);
 9214         noResult(node);
 9215         return;
 9216     }
 9217 
 9218     default:
 9219         DFG_CRASH(m_jit.graph(), node, &quot;Bad use kind&quot;);
 9220         return;
 9221     }
 9222 }
 9223 
 9224 void SpeculativeJIT::compileAllocatePropertyStorage(Node* node)
 9225 {
 9226     ASSERT(!node-&gt;transition()-&gt;previous-&gt;outOfLineCapacity());
 9227     ASSERT(initialOutOfLineCapacity == node-&gt;transition()-&gt;next-&gt;outOfLineCapacity());
 9228 
 9229     size_t size = initialOutOfLineCapacity * sizeof(JSValue);
 9230 
<span class="line-modified"> 9231     Allocator allocator = vm().jsValueGigacageAuxiliarySpace.allocatorForNonVirtual(size, AllocatorForMode::AllocatorIfExists);</span>
 9232 
 9233     if (!allocator || node-&gt;transition()-&gt;previous-&gt;couldHaveIndexingHeader()) {
 9234         SpeculateCellOperand base(this, node-&gt;child1());
 9235 
 9236         GPRReg baseGPR = base.gpr();
 9237 
 9238         flushRegisters();
 9239 
 9240         GPRFlushedCallResult result(this);
 9241         callOperation(operationAllocateComplexPropertyStorageWithInitialCapacity, result.gpr(), baseGPR);
 9242         m_jit.exceptionCheck();
 9243 
 9244         storageResult(result.gpr(), node);
 9245         return;
 9246     }
 9247 
 9248     GPRTemporary scratch1(this);
 9249     GPRTemporary scratch2(this);
 9250     GPRTemporary scratch3(this);
 9251 
</pre>
<hr />
<pre>
 9255 
 9256     JITCompiler::JumpList slowPath;
 9257     m_jit.emitAllocate(scratchGPR1, JITAllocator::constant(allocator), scratchGPR2, scratchGPR3, slowPath);
 9258     m_jit.addPtr(JITCompiler::TrustedImm32(size + sizeof(IndexingHeader)), scratchGPR1);
 9259 
 9260     addSlowPathGenerator(
 9261         slowPathCall(slowPath, this, operationAllocateSimplePropertyStorageWithInitialCapacity, scratchGPR1));
 9262 
 9263     for (ptrdiff_t offset = 0; offset &lt; static_cast&lt;ptrdiff_t&gt;(size); offset += sizeof(void*))
 9264         m_jit.storePtr(TrustedImmPtr(nullptr), JITCompiler::Address(scratchGPR1, -(offset + sizeof(JSValue) + sizeof(void*))));
 9265 
 9266     storageResult(scratchGPR1, node);
 9267 }
 9268 
 9269 void SpeculativeJIT::compileReallocatePropertyStorage(Node* node)
 9270 {
 9271     size_t oldSize = node-&gt;transition()-&gt;previous-&gt;outOfLineCapacity() * sizeof(JSValue);
 9272     size_t newSize = oldSize * outOfLineGrowthFactor;
 9273     ASSERT(newSize == node-&gt;transition()-&gt;next-&gt;outOfLineCapacity() * sizeof(JSValue));
 9274 
<span class="line-modified"> 9275     Allocator allocator = vm().jsValueGigacageAuxiliarySpace.allocatorForNonVirtual(newSize, AllocatorForMode::AllocatorIfExists);</span>
 9276 
 9277     if (!allocator || node-&gt;transition()-&gt;previous-&gt;couldHaveIndexingHeader()) {
 9278         SpeculateCellOperand base(this, node-&gt;child1());
 9279 
 9280         GPRReg baseGPR = base.gpr();
 9281 
 9282         flushRegisters();
 9283 
 9284         GPRFlushedCallResult result(this);
 9285         callOperation(operationAllocateComplexPropertyStorage, result.gpr(), baseGPR, newSize / sizeof(JSValue));
 9286         m_jit.exceptionCheck();
 9287 
 9288         storageResult(result.gpr(), node);
 9289         return;
 9290     }
 9291 
 9292     StorageOperand oldStorage(this, node-&gt;child2());
 9293     GPRTemporary scratch1(this);
 9294     GPRTemporary scratch2(this);
 9295     GPRTemporary scratch3(this);
</pre>
<hr />
<pre>
 9310     for (ptrdiff_t offset = oldSize; offset &lt; static_cast&lt;ptrdiff_t&gt;(newSize); offset += sizeof(void*))
 9311         m_jit.storePtr(TrustedImmPtr(nullptr), JITCompiler::Address(scratchGPR1, -(offset + sizeof(JSValue) + sizeof(void*))));
 9312 
 9313     // We have scratchGPR1 = new storage, scratchGPR2 = scratch
 9314     for (ptrdiff_t offset = 0; offset &lt; static_cast&lt;ptrdiff_t&gt;(oldSize); offset += sizeof(void*)) {
 9315         m_jit.loadPtr(JITCompiler::Address(oldStorageGPR, -(offset + sizeof(JSValue) + sizeof(void*))), scratchGPR2);
 9316         m_jit.storePtr(scratchGPR2, JITCompiler::Address(scratchGPR1, -(offset + sizeof(JSValue) + sizeof(void*))));
 9317     }
 9318 
 9319     storageResult(scratchGPR1, node);
 9320 }
 9321 
 9322 void SpeculativeJIT::compileNukeStructureAndSetButterfly(Node* node)
 9323 {
 9324     SpeculateCellOperand base(this, node-&gt;child1());
 9325     StorageOperand storage(this, node-&gt;child2());
 9326 
 9327     GPRReg baseGPR = base.gpr();
 9328     GPRReg storageGPR = storage.gpr();
 9329 
<span class="line-modified"> 9330     m_jit.nukeStructureAndStoreButterfly(vm(), storageGPR, baseGPR);</span>
 9331 
 9332     noResult(node);
 9333 }
 9334 
 9335 void SpeculativeJIT::compileGetButterfly(Node* node)
 9336 {
 9337     SpeculateCellOperand base(this, node-&gt;child1());
 9338     GPRTemporary result(this, Reuse, base);
 9339 
 9340     GPRReg baseGPR = base.gpr();
 9341     GPRReg resultGPR = result.gpr();
 9342 
 9343     m_jit.loadPtr(JITCompiler::Address(baseGPR, JSObject::butterflyOffset()), resultGPR);
 9344 
 9345     storageResult(resultGPR, node);
 9346 }
 9347 
 9348 static void allocateTemporaryRegistersForSnippet(SpeculativeJIT* jit, Vector&lt;GPRTemporary&gt;&amp; gpHolders, Vector&lt;FPRTemporary&gt;&amp; fpHolders, Vector&lt;GPRReg&gt;&amp; gpScratch, Vector&lt;FPRReg&gt;&amp; fpScratch, Snippet&amp; snippet)
 9349 {
 9350     for (unsigned i = 0; i &lt; snippet.numGPScratchRegisters; ++i) {
</pre>
<hr />
<pre>
 9405                 appendString(edge);
 9406                 break;
 9407             case SpecInt32Only:
 9408                 appendInt32(edge);
 9409                 break;
 9410             case SpecBoolean:
 9411                 appendBoolean(edge);
 9412                 break;
 9413             default:
 9414                 RELEASE_ASSERT_NOT_REACHED();
 9415                 break;
 9416             }
 9417         }
 9418         ++index;
 9419     });
 9420 
 9421     JSValueRegsTemporary result(this);
 9422     JSValueRegs resultRegs = result.regs();
 9423 
 9424     flushRegisters();
<span class="line-modified"> 9425 </span>
<span class="line-added"> 9426     auto function = CFunctionPtr(signature-&gt;functionWithoutTypeCheck);</span>
 9427     unsigned argumentCountIncludingThis = signature-&gt;argumentCount + 1;
 9428     switch (argumentCountIncludingThis) {
 9429     case 1:
<span class="line-modified"> 9430         callOperation(reinterpret_cast&lt;J_JITOperation_EP&gt;(function.get()), extractResult(resultRegs), regs[0]);</span>
 9431         break;
 9432     case 2:
<span class="line-modified"> 9433         callOperation(reinterpret_cast&lt;J_JITOperation_EPP&gt;(function.get()), extractResult(resultRegs), regs[0], regs[1]);</span>
 9434         break;
 9435     case 3:
<span class="line-modified"> 9436         callOperation(reinterpret_cast&lt;J_JITOperation_EPPP&gt;(function.get()), extractResult(resultRegs), regs[0], regs[1], regs[2]);</span>
 9437         break;
 9438     default:
 9439         RELEASE_ASSERT_NOT_REACHED();
 9440         break;
 9441     }
 9442 
 9443     m_jit.exceptionCheck();
 9444     jsValueResult(resultRegs, node);
 9445 }
 9446 
 9447 void SpeculativeJIT::compileCallDOMGetter(Node* node)
 9448 {
 9449     DOMJIT::CallDOMGetterSnippet* snippet = node-&gt;callDOMGetterData()-&gt;snippet;
 9450     if (!snippet) {
 9451         FunctionPtr&lt;OperationPtrTag&gt; getter = node-&gt;callDOMGetterData()-&gt;customAccessorGetter;
 9452         SpeculateCellOperand base(this, node-&gt;child1());
 9453         JSValueRegsTemporary result(this);
 9454 
 9455         JSValueRegs resultRegs = result.regs();
 9456         GPRReg baseGPR = base.gpr();
 9457 
 9458         flushRegisters();
 9459         m_jit.setupArguments&lt;J_JITOperation_EJI&gt;(CCallHelpers::CellValue(baseGPR), identifierUID(node-&gt;callDOMGetterData()-&gt;identifierNumber));
<span class="line-modified"> 9460         m_jit.storePtr(GPRInfo::callFrameRegister, &amp;vm().topCallFrame);</span>
 9461         m_jit.emitStoreCodeOrigin(m_currentNode-&gt;origin.semantic);
 9462         m_jit.appendCall(getter.retagged&lt;CFunctionPtrTag&gt;());
 9463         m_jit.setupResults(resultRegs);
 9464 
 9465         m_jit.exceptionCheck();
 9466         jsValueResult(resultRegs, node);
 9467         return;
 9468     }
 9469 
 9470     Vector&lt;GPRReg&gt; gpScratch;
 9471     Vector&lt;FPRReg&gt; fpScratch;
 9472     Vector&lt;SnippetParams::Value&gt; regs;
 9473 
 9474     JSValueRegsTemporary result(this);
 9475     regs.append(result.regs());
 9476 
 9477     Edge&amp; baseEdge = node-&gt;child1();
 9478     SpeculateCellOperand base(this, baseEdge);
 9479     regs.append(SnippetParams::Value(base.gpr(), m_state.forNode(baseEdge).value()));
 9480 
</pre>
<hr />
<pre>
 9488     Vector&lt;GPRTemporary&gt; gpTempraries;
 9489     Vector&lt;FPRTemporary&gt; fpTempraries;
 9490     allocateTemporaryRegistersForSnippet(this, gpTempraries, fpTempraries, gpScratch, fpScratch, *snippet);
 9491     SnippetParams params(this, WTFMove(regs), WTFMove(gpScratch), WTFMove(fpScratch));
 9492     snippet-&gt;generator()-&gt;run(m_jit, params);
 9493     jsValueResult(result.regs(), node);
 9494 }
 9495 
 9496 void SpeculativeJIT::compileCheckSubClass(Node* node)
 9497 {
 9498     const ClassInfo* classInfo = node-&gt;classInfo();
 9499     if (!classInfo-&gt;checkSubClassSnippet) {
 9500         SpeculateCellOperand base(this, node-&gt;child1());
 9501         GPRTemporary other(this);
 9502         GPRTemporary specified(this);
 9503 
 9504         GPRReg baseGPR = base.gpr();
 9505         GPRReg otherGPR = other.gpr();
 9506         GPRReg specifiedGPR = specified.gpr();
 9507 
<span class="line-modified"> 9508         m_jit.emitLoadStructure(vm(), baseGPR, otherGPR, specifiedGPR);</span>
 9509         m_jit.loadPtr(CCallHelpers::Address(otherGPR, Structure::classInfoOffset()), otherGPR);
 9510         m_jit.move(CCallHelpers::TrustedImmPtr(node-&gt;classInfo()), specifiedGPR);
 9511 
 9512         CCallHelpers::Label loop = m_jit.label();
 9513         auto done = m_jit.branchPtr(CCallHelpers::Equal, otherGPR, specifiedGPR);
 9514         m_jit.loadPtr(CCallHelpers::Address(otherGPR, ClassInfo::offsetOfParentClass()), otherGPR);
 9515         m_jit.branchTestPtr(CCallHelpers::NonZero, otherGPR).linkTo(loop, &amp;m_jit);
 9516         speculationCheck(BadType, JSValueSource::unboxedCell(baseGPR), node-&gt;child1(), m_jit.jump());
 9517         done.link(&amp;m_jit);
 9518         noResult(node);
 9519         return;
 9520     }
 9521 
 9522     Ref&lt;Snippet&gt; snippet = classInfo-&gt;checkSubClassSnippet();
 9523 
 9524     Vector&lt;GPRReg&gt; gpScratch;
 9525     Vector&lt;FPRReg&gt; fpScratch;
 9526     Vector&lt;SnippetParams::Value&gt; regs;
 9527 
 9528     SpeculateCellOperand base(this, node-&gt;child1());
</pre>
<hr />
<pre>
 9797     auto butterfly = TrustedImmPtr(nullptr);
 9798     emitAllocateJSObject&lt;StringObject&gt;(
 9799         resultGPR, TrustedImmPtr(node-&gt;structure()), butterfly, scratch1GPR, scratch2GPR,
 9800         slowPath);
 9801 
 9802     m_jit.storePtr(
 9803         TrustedImmPtr(StringObject::info()),
 9804         JITCompiler::Address(resultGPR, JSDestructibleObject::classInfoOffset()));
 9805 #if USE(JSVALUE64)
 9806     m_jit.store64(
 9807         operandGPR, JITCompiler::Address(resultGPR, JSWrapperObject::internalValueOffset()));
 9808 #else
 9809     m_jit.store32(
 9810         TrustedImm32(JSValue::CellTag),
 9811         JITCompiler::Address(resultGPR, JSWrapperObject::internalValueOffset() + OBJECT_OFFSETOF(JSValue, u.asBits.tag)));
 9812     m_jit.store32(
 9813         operandGPR,
 9814         JITCompiler::Address(resultGPR, JSWrapperObject::internalValueOffset() + OBJECT_OFFSETOF(JSValue, u.asBits.payload)));
 9815 #endif
 9816 
<span class="line-modified"> 9817     m_jit.mutatorFence(vm());</span>
 9818 
 9819     addSlowPathGenerator(slowPathCall(
 9820         slowPath, this, operationNewStringObject, resultGPR, operandGPR, node-&gt;structure()));
 9821 
 9822     cellResult(resultGPR, node);
 9823 }
 9824 
 9825 void SpeculativeJIT::compileNewSymbol(Node* node)
 9826 {
 9827     if (!node-&gt;child1()) {
 9828         flushRegisters();
 9829         GPRFlushedCallResult result(this);
 9830         GPRReg resultGPR = result.gpr();
 9831         callOperation(operationNewSymbol, resultGPR);
 9832         m_jit.exceptionCheck();
 9833         cellResult(resultGPR, node);
 9834         return;
 9835     }
 9836 
 9837 
</pre>
<hr />
<pre>
 9864     GPRTemporary scratch2(this);
 9865     GPRReg resultGPR = result.gpr();
 9866     GPRReg storageGPR = storage.gpr();
 9867     GPRReg scratchGPR = scratch.gpr();
 9868     GPRReg scratchGPR2 = scratch2.gpr();
 9869 
 9870     JITCompiler::JumpList slowCases;
 9871 
 9872     m_jit.move(TrustedImmPtr(nullptr), storageGPR);
 9873 
 9874     slowCases.append(m_jit.branch32(
 9875         MacroAssembler::Above, sizeGPR, TrustedImm32(JSArrayBufferView::fastSizeLimit)));
 9876 
 9877     m_jit.move(sizeGPR, scratchGPR);
 9878     m_jit.lshift32(TrustedImm32(logElementSize(typedArrayType)), scratchGPR);
 9879     if (elementSize(typedArrayType) &lt; 8) {
 9880         m_jit.add32(TrustedImm32(7), scratchGPR);
 9881         m_jit.and32(TrustedImm32(~7), scratchGPR);
 9882     }
 9883     m_jit.emitAllocateVariableSized(
<span class="line-modified"> 9884         storageGPR, vm().primitiveGigacageAuxiliarySpace, scratchGPR, scratchGPR,</span>
 9885         scratchGPR2, slowCases);
 9886 
 9887     MacroAssembler::Jump done = m_jit.branchTest32(MacroAssembler::Zero, sizeGPR);
 9888     m_jit.move(sizeGPR, scratchGPR);
 9889     if (elementSize(typedArrayType) != 4) {
 9890         if (elementSize(typedArrayType) &gt; 4)
 9891             m_jit.lshift32(TrustedImm32(logElementSize(typedArrayType) - 2), scratchGPR);
 9892         else {
 9893             if (elementSize(typedArrayType) &gt; 1)
 9894                 m_jit.lshift32(TrustedImm32(logElementSize(typedArrayType)), scratchGPR);
 9895             m_jit.add32(TrustedImm32(3), scratchGPR);
 9896             m_jit.urshift32(TrustedImm32(2), scratchGPR);
 9897         }
 9898     }
 9899     MacroAssembler::Label loop = m_jit.label();
 9900     m_jit.sub32(TrustedImm32(1), scratchGPR);
 9901     m_jit.store32(
 9902         TrustedImm32(0),
 9903         MacroAssembler::BaseIndex(storageGPR, scratchGPR, MacroAssembler::TimesFour));
 9904     m_jit.branchTest32(MacroAssembler::NonZero, scratchGPR).linkTo(loop, &amp;m_jit);
 9905     done.link(&amp;m_jit);
<span class="line-added"> 9906 #if CPU(ARM64E)</span>
<span class="line-added"> 9907     // sizeGPR is still boxed as a number and there is no 32-bit variant of the PAC instructions.</span>
<span class="line-added"> 9908     m_jit.zeroExtend32ToPtr(sizeGPR, scratchGPR);</span>
<span class="line-added"> 9909     m_jit.tagArrayPtr(scratchGPR, storageGPR);</span>
<span class="line-added"> 9910 #endif</span>
 9911 
 9912     auto butterfly = TrustedImmPtr(nullptr);
 9913     emitAllocateJSObject&lt;JSArrayBufferView&gt;(
 9914         resultGPR, TrustedImmPtr(structure), butterfly, scratchGPR, scratchGPR2,
 9915         slowCases);
 9916 
 9917     m_jit.storePtr(
 9918         storageGPR,
 9919         MacroAssembler::Address(resultGPR, JSArrayBufferView::offsetOfVector()));
 9920     m_jit.store32(
 9921         sizeGPR,
 9922         MacroAssembler::Address(resultGPR, JSArrayBufferView::offsetOfLength()));
 9923     m_jit.store32(
 9924         TrustedImm32(FastTypedArray),
 9925         MacroAssembler::Address(resultGPR, JSArrayBufferView::offsetOfMode()));
 9926 
<span class="line-modified"> 9927     m_jit.mutatorFence(vm());</span>
 9928 
 9929     addSlowPathGenerator(slowPathCall(
 9930         slowCases, this, operationNewTypedArrayWithSizeForType(typedArrayType),
 9931         resultGPR, structure, sizeGPR, storageGPR));
 9932 
 9933     cellResult(resultGPR, node);
 9934 }
 9935 
 9936 void SpeculativeJIT::compileNewRegexp(Node* node)
 9937 {
 9938     RegExp* regexp = node-&gt;castOperand&lt;RegExp*&gt;();

 9939 
 9940     GPRTemporary result(this);
 9941     GPRTemporary scratch1(this);
 9942     GPRTemporary scratch2(this);
 9943     JSValueOperand lastIndex(this, node-&gt;child1());
 9944 
 9945     GPRReg resultGPR = result.gpr();
 9946     GPRReg scratch1GPR = scratch1.gpr();
 9947     GPRReg scratch2GPR = scratch2.gpr();
 9948     JSValueRegs lastIndexRegs = lastIndex.jsValueRegs();
 9949 
 9950     JITCompiler::JumpList slowPath;
 9951 
 9952     auto structure = m_jit.graph().registerStructure(m_jit.graph().globalObjectFor(node-&gt;origin.semantic)-&gt;regExpStructure());
 9953     auto butterfly = TrustedImmPtr(nullptr);
 9954     emitAllocateJSObject&lt;RegExpObject&gt;(resultGPR, TrustedImmPtr(structure), butterfly, scratch1GPR, scratch2GPR, slowPath);
 9955 
 9956     m_jit.storePtr(
 9957         TrustedImmPtr(node-&gt;cellOperand()),
<span class="line-modified"> 9958         CCallHelpers::Address(resultGPR, RegExpObject::offsetOfRegExpAndLastIndexIsNotWritableFlag()));</span>
 9959     m_jit.storeValue(lastIndexRegs, CCallHelpers::Address(resultGPR, RegExpObject::offsetOfLastIndex()));
<span class="line-modified"> 9960     m_jit.mutatorFence(vm());</span>

 9961 
 9962     addSlowPathGenerator(slowPathCall(slowPath, this, operationNewRegexpWithLastIndex, resultGPR, regexp, lastIndexRegs));
 9963 
 9964     cellResult(resultGPR, node);
 9965 }
 9966 
 9967 void SpeculativeJIT::speculateCellTypeWithoutTypeFiltering(
 9968     Edge edge, GPRReg cellGPR, JSType jsType)
 9969 {
 9970     speculationCheck(
 9971         BadType, JSValueSource::unboxedCell(cellGPR), edge,
 9972         m_jit.branchIfNotType(cellGPR, jsType));
 9973 }
 9974 
 9975 void SpeculativeJIT::speculateCellType(
 9976     Edge edge, GPRReg cellGPR, SpeculatedType specType, JSType jsType)
 9977 {
 9978     DFG_TYPE_CHECK(
 9979         JSValueSource::unboxedCell(cellGPR), edge, specType,
 9980         m_jit.branchIfNotType(cellGPR, jsType));
</pre>
<hr />
<pre>
10299     GPRTemporary temp(this);
10300     JSValueRegs regs = operand.jsValueRegs();
10301     GPRReg tempGPR = temp.gpr();
10302     speculateStringOrOther(edge, regs, tempGPR);
10303 }
10304 
10305 void SpeculativeJIT::speculateStringIdentAndLoadStorage(Edge edge, GPRReg string, GPRReg storage)
10306 {
10307     m_jit.loadPtr(MacroAssembler::Address(string, JSString::offsetOfValue()), storage);
10308 
10309     if (!needsTypeCheck(edge, SpecStringIdent | ~SpecString))
10310         return;
10311 
10312     speculationCheck(
10313         BadType, JSValueSource::unboxedCell(string), edge,
10314         m_jit.branchIfRopeStringImpl(storage));
10315     speculationCheck(
10316         BadType, JSValueSource::unboxedCell(string), edge, m_jit.branchTest32(
10317             MacroAssembler::Zero,
10318             MacroAssembler::Address(storage, StringImpl::flagsOffset()),
<span class="line-modified">10319             MacroAssembler::TrustedImm32(StringImpl::flagIsAtom())));</span>
10320 
10321     m_interpreter.filter(edge, SpecStringIdent | ~SpecString);
10322 }
10323 
10324 void SpeculativeJIT::speculateStringIdent(Edge edge, GPRReg string)
10325 {
10326     if (!needsTypeCheck(edge, SpecStringIdent))
10327         return;
10328 
10329     GPRTemporary temp(this);
10330     speculateStringIdentAndLoadStorage(edge, string, temp.gpr());
10331 }
10332 
10333 void SpeculativeJIT::speculateStringIdent(Edge edge)
10334 {
10335     if (!needsTypeCheck(edge, SpecStringIdent))
10336         return;
10337 
10338     SpeculateCellOperand operand(this, edge);
10339     GPRReg gpr = operand.gpr();
</pre>
<hr />
<pre>
10640         speculateMisc(edge);
10641         break;
10642     default:
10643         RELEASE_ASSERT_NOT_REACHED();
10644         break;
10645     }
10646 }
10647 
10648 void SpeculativeJIT::emitSwitchIntJump(
10649     SwitchData* data, GPRReg value, GPRReg scratch)
10650 {
10651     SimpleJumpTable&amp; table = m_jit.codeBlock()-&gt;switchJumpTable(data-&gt;switchTableIndex);
10652     table.ensureCTITable();
10653     m_jit.sub32(Imm32(table.min), value);
10654     addBranch(
10655         m_jit.branch32(JITCompiler::AboveOrEqual, value, Imm32(table.ctiOffsets.size())),
10656         data-&gt;fallThrough.block);
10657     m_jit.move(TrustedImmPtr(table.ctiOffsets.begin()), scratch);
10658     m_jit.loadPtr(JITCompiler::BaseIndex(scratch, value, JITCompiler::timesPtr()), scratch);
10659 
<span class="line-modified">10660     m_jit.farJump(scratch, JSSwitchPtrTag);</span>
10661     data-&gt;didUseJumpTable = true;
10662 }
10663 
10664 void SpeculativeJIT::emitSwitchImm(Node* node, SwitchData* data)
10665 {
10666     switch (node-&gt;child1().useKind()) {
10667     case Int32Use: {
10668         SpeculateInt32Operand value(this, node-&gt;child1());
10669         GPRTemporary temp(this);
10670         emitSwitchIntJump(data, value.gpr(), temp.gpr());
10671         noResult(node);
10672         break;
10673     }
10674 
10675     case UntypedUse: {
10676         JSValueOperand value(this, node-&gt;child1());
10677         GPRTemporary temp(this);
10678         JSValueRegs valueRegs = value.jsValueRegs();
10679         GPRReg scratch = temp.gpr();
10680 
10681         value.use();
10682 
10683         auto notInt32 = m_jit.branchIfNotInt32(valueRegs);
10684         emitSwitchIntJump(data, valueRegs.payloadGPR(), scratch);
10685         notInt32.link(&amp;m_jit);
10686         addBranch(m_jit.branchIfNotNumber(valueRegs, scratch), data-&gt;fallThrough.block);
10687         silentSpillAllRegisters(scratch);
10688         callOperation(operationFindSwitchImmTargetForDouble, scratch, valueRegs, data-&gt;switchTableIndex);
10689         silentFillAllRegisters();
10690 
<span class="line-modified">10691         m_jit.farJump(scratch, JSSwitchPtrTag);</span>
10692         noResult(node, UseChildrenCalledExplicitly);
10693         break;
10694     }
10695 
10696     default:
10697         RELEASE_ASSERT_NOT_REACHED();
10698         break;
10699     }
10700 }
10701 
10702 void SpeculativeJIT::emitSwitchCharStringJump(
10703     SwitchData* data, GPRReg value, GPRReg scratch)
10704 {
10705     m_jit.loadPtr(MacroAssembler::Address(value, JSString::offsetOfValue()), scratch);
10706     auto isRope = m_jit.branchIfRopeStringImpl(scratch);
10707 
10708     addBranch(
10709         m_jit.branch32(
10710             MacroAssembler::NotEqual,
10711             MacroAssembler::Address(scratch, StringImpl::lengthMemoryOffset()),
</pre>
<hr />
<pre>
10928     unsigned totalLength = 0;
10929 
10930     for (unsigned i = data-&gt;cases.size(); i--;) {
10931         StringImpl* string = data-&gt;cases[i].value.stringImpl();
10932         if (!string-&gt;is8Bit()) {
10933             canDoBinarySwitch = false;
10934             break;
10935         }
10936         if (string-&gt;length() &gt; Options::maximumBinaryStringSwitchCaseLength()) {
10937             canDoBinarySwitch = false;
10938             break;
10939         }
10940         totalLength += string-&gt;length();
10941     }
10942 
10943     if (!canDoBinarySwitch || totalLength &gt; Options::maximumBinaryStringSwitchTotalLength()) {
10944         flushRegisters();
10945         callOperation(
10946             operationSwitchString, string, static_cast&lt;size_t&gt;(data-&gt;switchTableIndex), string);
10947         m_jit.exceptionCheck();
<span class="line-modified">10948         m_jit.farJump(string, JSSwitchPtrTag);</span>
10949         return;
10950     }
10951 
10952     GPRTemporary length(this);
10953     GPRTemporary temp(this);
10954 
10955     GPRReg lengthGPR = length.gpr();
10956     GPRReg tempGPR = temp.gpr();
10957 
10958     MacroAssembler::JumpList slowCases;
10959     m_jit.loadPtr(MacroAssembler::Address(string, JSString::offsetOfValue()), tempGPR);
10960     slowCases.append(m_jit.branchIfRopeStringImpl(tempGPR));
10961     m_jit.load32(MacroAssembler::Address(tempGPR, StringImpl::lengthMemoryOffset()), lengthGPR);
10962 
10963     slowCases.append(m_jit.branchTest32(
10964         MacroAssembler::Zero,
10965         MacroAssembler::Address(tempGPR, StringImpl::flagsOffset()),
10966         TrustedImm32(StringImpl::flagIs8Bit())));
10967 
10968     m_jit.loadPtr(MacroAssembler::Address(tempGPR, StringImpl::dataOffset()), string);
10969 
10970     Vector&lt;StringSwitchCase&gt; cases;
10971     for (unsigned i = 0; i &lt; data-&gt;cases.size(); ++i) {
10972         cases.append(
10973             StringSwitchCase(data-&gt;cases[i].value.stringImpl(), data-&gt;cases[i].target.block));
10974     }
10975 
10976     std::sort(cases.begin(), cases.end());
10977 
10978     emitBinarySwitchStringRecurse(
10979         data, cases, 0, 0, cases.size(), string, lengthGPR, tempGPR, 0, false);
10980 
10981     slowCases.link(&amp;m_jit);
10982     silentSpillAllRegisters(string);
10983     callOperation(operationSwitchString, string, static_cast&lt;size_t&gt;(data-&gt;switchTableIndex), string);
10984     silentFillAllRegisters();
10985     m_jit.exceptionCheck();
<span class="line-modified">10986     m_jit.farJump(string, JSSwitchPtrTag);</span>
10987 }
10988 
10989 void SpeculativeJIT::emitSwitchString(Node* node, SwitchData* data)
10990 {
10991     switch (node-&gt;child1().useKind()) {
10992     case StringIdentUse: {
10993         SpeculateCellOperand op1(this, node-&gt;child1());
10994         GPRTemporary temp(this);
10995 
10996         GPRReg op1GPR = op1.gpr();
10997         GPRReg tempGPR = temp.gpr();
10998 
10999         speculateString(node-&gt;child1(), op1GPR);
11000         speculateStringIdentAndLoadStorage(node-&gt;child1(), op1GPR, tempGPR);
11001 
11002         Vector&lt;int64_t&gt; identifierCaseValues;
11003         for (unsigned i = 0; i &lt; data-&gt;cases.size(); ++i) {
11004             identifierCaseValues.append(
11005                 static_cast&lt;int64_t&gt;(bitwise_cast&lt;intptr_t&gt;(data-&gt;cases[i].value.stringImpl())));
11006         }
</pre>
<hr />
<pre>
11082 {
11083     for (auto&amp; branch : m_branches)
11084         branch.jump.linkTo(m_jit.blockHeads()[branch.destination-&gt;index], &amp;m_jit);
11085 }
11086 
11087 void SpeculativeJIT::compileStoreBarrier(Node* node)
11088 {
11089     ASSERT(node-&gt;op() == StoreBarrier || node-&gt;op() == FencedStoreBarrier);
11090 
11091     bool isFenced = node-&gt;op() == FencedStoreBarrier;
11092 
11093     SpeculateCellOperand base(this, node-&gt;child1());
11094     GPRTemporary scratch1(this);
11095 
11096     GPRReg baseGPR = base.gpr();
11097     GPRReg scratch1GPR = scratch1.gpr();
11098 
11099     JITCompiler::JumpList ok;
11100 
11101     if (isFenced) {
<span class="line-modified">11102         ok.append(m_jit.barrierBranch(vm(), baseGPR, scratch1GPR));</span>
11103 
<span class="line-modified">11104         JITCompiler::Jump noFence = m_jit.jumpIfMutatorFenceNotNeeded(vm());</span>
11105         m_jit.memoryFence();
11106         ok.append(m_jit.barrierBranchWithoutFence(baseGPR));
11107         noFence.link(&amp;m_jit);
11108     } else
11109         ok.append(m_jit.barrierBranchWithoutFence(baseGPR));
11110 
11111     silentSpillAllRegisters(InvalidGPRReg);
11112     callOperation(operationWriteBarrierSlowPath, baseGPR);
11113     silentFillAllRegisters();
11114 
11115     ok.link(&amp;m_jit);
11116 
11117     noResult(node);
11118 }
11119 
11120 void SpeculativeJIT::compilePutAccessorById(Node* node)
11121 {
11122     SpeculateCellOperand base(this, node-&gt;child1());
11123     SpeculateCellOperand accessor(this, node-&gt;child2());
11124 
</pre>
<hr />
<pre>
11207 {
11208     SpeculateCellOperand scope(this, node-&gt;child1());
11209     GPRReg scopeGPR = scope.gpr();
11210     flushRegisters();
11211     JSValueRegsFlushedCallResult result(this);
11212     JSValueRegs resultRegs = result.regs();
11213     callOperation(operationGetDynamicVar, resultRegs, scopeGPR, identifierUID(node-&gt;identifierNumber()), node-&gt;getPutInfo());
11214     m_jit.exceptionCheck();
11215     jsValueResult(resultRegs, node);
11216 }
11217 
11218 void SpeculativeJIT::compilePutDynamicVar(Node* node)
11219 {
11220     SpeculateCellOperand scope(this, node-&gt;child1());
11221     JSValueOperand value(this, node-&gt;child2());
11222 
11223     GPRReg scopeGPR = scope.gpr();
11224     JSValueRegs valueRegs = value.jsValueRegs();
11225 
11226     flushRegisters();
<span class="line-modified">11227     callOperation(m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutDynamicVarStrict : operationPutDynamicVarNonStrict, NoResult, scopeGPR, valueRegs, identifierUID(node-&gt;identifierNumber()), node-&gt;getPutInfo());</span>
11228     m_jit.exceptionCheck();
11229     noResult(node);
11230 }
11231 
11232 void SpeculativeJIT::compileGetClosureVar(Node* node)
11233 {
11234     SpeculateCellOperand base(this, node-&gt;child1());
11235     JSValueRegsTemporary result(this);
11236 
11237     GPRReg baseGPR = base.gpr();
11238     JSValueRegs resultRegs = result.regs();
11239 
11240     m_jit.loadValue(JITCompiler::Address(baseGPR, JSLexicalEnvironment::offsetOfVariable(node-&gt;scopeOffset())), resultRegs);
11241     jsValueResult(resultRegs, node);
11242 }
11243 
11244 void SpeculativeJIT::compilePutClosureVar(Node* node)
11245 {
11246     SpeculateCellOperand base(this, node-&gt;child1());
11247     JSValueOperand value(this, node-&gt;child2());
</pre>
<hr />
<pre>
11277     SpeculateCellOperand regExp(this, node-&gt;child1());
11278     JSValueRegsTemporary result(this);
11279     GPRReg regExpGPR = regExp.gpr();
11280     JSValueRegs resultRegs = result.regs();
11281     speculateRegExpObject(node-&gt;child1(), regExpGPR);
11282     m_jit.loadValue(JITCompiler::Address(regExpGPR, RegExpObject::offsetOfLastIndex()), resultRegs);
11283     jsValueResult(resultRegs, node);
11284 }
11285 
11286 void SpeculativeJIT::compileSetRegExpObjectLastIndex(Node* node)
11287 {
11288     SpeculateCellOperand regExp(this, node-&gt;child1());
11289     JSValueOperand value(this, node-&gt;child2());
11290     GPRReg regExpGPR = regExp.gpr();
11291     JSValueRegs valueRegs = value.jsValueRegs();
11292 
11293     if (!node-&gt;ignoreLastIndexIsWritable()) {
11294         speculateRegExpObject(node-&gt;child1(), regExpGPR);
11295         speculationCheck(
11296             ExoticObjectMode, JSValueRegs(), nullptr,
<span class="line-modified">11297             m_jit.branchTestPtr(</span>
<span class="line-modified">11298                 JITCompiler::NonZero,</span>
<span class="line-modified">11299                 JITCompiler::Address(regExpGPR, RegExpObject::offsetOfRegExpAndLastIndexIsNotWritableFlag()),</span>
<span class="line-added">11300                 JITCompiler::TrustedImm32(RegExpObject::lastIndexIsNotWritableFlag)));</span>
11301     }
11302 
11303     m_jit.storeValue(valueRegs, JITCompiler::Address(regExpGPR, RegExpObject::offsetOfLastIndex()));
11304     noResult(node);
11305 }
11306 
11307 void SpeculativeJIT::compileRegExpExec(Node* node)
11308 {
11309     bool sample = false;
11310     if (sample)
11311         m_jit.incrementSuperSamplerCount();
11312 
11313     SpeculateCellOperand globalObject(this, node-&gt;child1());
11314     GPRReg globalObjectGPR = globalObject.gpr();
11315 
11316     if (node-&gt;child2().useKind() == RegExpObjectUse) {
11317         if (node-&gt;child3().useKind() == StringUse) {
11318             SpeculateCellOperand base(this, node-&gt;child2());
11319             SpeculateCellOperand argument(this, node-&gt;child3());
11320             GPRReg baseGPR = base.gpr();
</pre>
<hr />
<pre>
11415     JSValueRegs argumentRegs = argument.jsValueRegs();
11416 
11417     flushRegisters();
11418     GPRFlushedCallResult result(this);
11419     callOperation(operationRegExpTestGeneric, result.gpr(), globalObjectGPR, baseRegs, argumentRegs);
11420     m_jit.exceptionCheck();
11421 
11422     unblessedBooleanResult(result.gpr(), node);
11423 }
11424 
11425 void SpeculativeJIT::compileStringReplace(Node* node)
11426 {
11427     ASSERT(node-&gt;op() == StringReplace || node-&gt;op() == StringReplaceRegExp);
11428     bool sample = false;
11429     if (sample)
11430         m_jit.incrementSuperSamplerCount();
11431 
11432     if (node-&gt;child1().useKind() == StringUse
11433         &amp;&amp; node-&gt;child2().useKind() == RegExpObjectUse
11434         &amp;&amp; node-&gt;child3().useKind() == StringUse) {
<span class="line-modified">11435         if (JSString* replace = node-&gt;child3()-&gt;dynamicCastConstant&lt;JSString*&gt;(vm())) {</span>
11436             if (!replace-&gt;length()) {
11437                 SpeculateCellOperand string(this, node-&gt;child1());
11438                 SpeculateCellOperand regExp(this, node-&gt;child2());
11439                 GPRReg stringGPR = string.gpr();
11440                 GPRReg regExpGPR = regExp.gpr();
11441                 speculateString(node-&gt;child1(), stringGPR);
11442                 speculateRegExpObject(node-&gt;child2(), regExpGPR);
11443 
11444                 flushRegisters();
11445                 GPRFlushedCallResult result(this);
11446                 callOperation(operationStringProtoFuncReplaceRegExpEmptyStr, result.gpr(), stringGPR, regExpGPR);
11447                 m_jit.exceptionCheck();
11448                 cellResult(result.gpr(), node);
11449                 if (sample)
11450                     m_jit.decrementSuperSamplerCount();
11451                 return;
11452             }
11453         }
11454 
11455         SpeculateCellOperand string(this, node-&gt;child1());
</pre>
<hr />
<pre>
11549     JSValueRegs resultRegs = result.regs();
11550     callOperation(
11551         operationRegExpMatchFastString, resultRegs,
11552         globalObjectGPR, baseGPR, argumentGPR);
11553     m_jit.exceptionCheck();
11554 
11555     jsValueResult(resultRegs, node);
11556 }
11557 
11558 void SpeculativeJIT::compileLazyJSConstant(Node* node)
11559 {
11560     JSValueRegsTemporary result(this);
11561     JSValueRegs resultRegs = result.regs();
11562     node-&gt;lazyJSValue().emit(m_jit, resultRegs);
11563     jsValueResult(resultRegs, node);
11564 }
11565 
11566 void SpeculativeJIT::compileMaterializeNewObject(Node* node)
11567 {
11568     RegisteredStructure structure = node-&gt;structureSet().at(0);
<span class="line-modified">11569     ASSERT(m_jit.graph().varArgChild(node, 0)-&gt;dynamicCastConstant&lt;Structure*&gt;(vm()) == structure.get());</span>
11570 
11571     ObjectMaterializationData&amp; data = node-&gt;objectMaterializationData();
11572 
11573     IndexingType indexingType = structure-&gt;indexingType();
11574     bool hasIndexingHeader = hasIndexedProperties(indexingType);
11575     int32_t publicLength = 0;
11576     int32_t vectorLength = 0;
11577 
11578     if (hasIndexingHeader) {
11579         for (unsigned i = data.m_properties.size(); i--;) {
11580             Edge edge = m_jit.graph().varArgChild(node, 1 + i);
11581             switch (data.m_properties[i].kind()) {
11582             case PublicLengthPLoc:
11583                 publicLength = edge-&gt;asInt32();
11584                 break;
11585             case VectorLengthPLoc:
11586                 vectorLength = edge-&gt;asInt32();
11587                 break;
11588             default:
11589                 break;
</pre>
<hr />
<pre>
11837     default:
11838         RELEASE_ASSERT_NOT_REACHED();
11839     }
11840 
11841     noResult(node, UseChildrenCalledExplicitly);
11842 }
11843 
11844 void SpeculativeJIT::emitAllocateButterfly(GPRReg storageResultGPR, GPRReg sizeGPR, GPRReg scratch1, GPRReg scratch2, GPRReg scratch3, MacroAssembler::JumpList&amp; slowCases)
11845 {
11846     RELEASE_ASSERT(RegisterSet(storageResultGPR, sizeGPR, scratch1, scratch2, scratch3).numberOfSetGPRs() == 5);
11847     ASSERT((1 &lt;&lt; 3) == sizeof(JSValue));
11848     m_jit.zeroExtend32ToPtr(sizeGPR, scratch1);
11849     m_jit.lshift32(TrustedImm32(3), scratch1);
11850     m_jit.add32(TrustedImm32(sizeof(IndexingHeader)), scratch1, scratch2);
11851 #if !ASSERT_DISABLED
11852     MacroAssembler::Jump didNotOverflow = m_jit.branch32(MacroAssembler::AboveOrEqual, scratch2, sizeGPR);
11853     m_jit.abortWithReason(UncheckedOverflow);
11854     didNotOverflow.link(&amp;m_jit);
11855 #endif
11856     m_jit.emitAllocateVariableSized(
<span class="line-modified">11857         storageResultGPR, vm().jsValueGigacageAuxiliarySpace, scratch2, scratch1, scratch3, slowCases);</span>
11858     m_jit.addPtr(TrustedImm32(sizeof(IndexingHeader)), storageResultGPR);
11859 
11860     m_jit.store32(sizeGPR, MacroAssembler::Address(storageResultGPR, Butterfly::offsetOfPublicLength()));
11861     m_jit.store32(sizeGPR, MacroAssembler::Address(storageResultGPR, Butterfly::offsetOfVectorLength()));
11862 }
11863 
11864 void SpeculativeJIT::compileNormalizeMapKey(Node* node)
11865 {
11866     ASSERT(node-&gt;child1().useKind() == UntypedUse);
11867     JSValueOperand key(this, node-&gt;child1());
11868     JSValueRegsTemporary result(this, Reuse, key);
11869     GPRTemporary scratch(this);
11870     FPRTemporary doubleValue(this);
11871     FPRTemporary temp(this);
11872 
11873     JSValueRegs keyRegs = key.jsValueRegs();
11874     JSValueRegs resultRegs = result.regs();
11875     GPRReg scratchGPR = scratch.gpr();
11876     FPRReg doubleValueFPR = doubleValue.fpr();
11877     FPRReg tempFPR = temp.fpr();
11878 
11879     CCallHelpers::JumpList passThroughCases;
<span class="line-added">11880     CCallHelpers::JumpList doneCases;</span>
11881 
11882     passThroughCases.append(m_jit.branchIfNotNumber(keyRegs, scratchGPR));
11883     passThroughCases.append(m_jit.branchIfInt32(keyRegs));
11884 
11885 #if USE(JSVALUE64)
11886     m_jit.unboxDoubleWithoutAssertions(keyRegs.gpr(), scratchGPR, doubleValueFPR);
11887 #else
11888     unboxDouble(keyRegs.tagGPR(), keyRegs.payloadGPR(), doubleValueFPR, tempFPR);
11889 #endif
<span class="line-modified">11890     auto notNaN = m_jit.branchIfNotNaN(doubleValueFPR);</span>
<span class="line-added">11891     m_jit.moveTrustedValue(jsNaN(), resultRegs);</span>
<span class="line-added">11892     doneCases.append(m_jit.jump());</span>
11893 
<span class="line-added">11894     notNaN.link(&amp;m_jit);</span>
11895     m_jit.truncateDoubleToInt32(doubleValueFPR, scratchGPR);
11896     m_jit.convertInt32ToDouble(scratchGPR, tempFPR);
11897     passThroughCases.append(m_jit.branchDouble(JITCompiler::DoubleNotEqual, doubleValueFPR, tempFPR));
11898 
11899     m_jit.boxInt32(scratchGPR, resultRegs);
<span class="line-modified">11900     doneCases.append(m_jit.jump());</span>
11901 
11902     passThroughCases.link(&amp;m_jit);
11903     m_jit.moveValueRegs(keyRegs, resultRegs);
11904 
<span class="line-modified">11905     doneCases.link(&amp;m_jit);</span>
11906     jsValueResult(resultRegs, node);
11907 }
11908 
11909 void SpeculativeJIT::compileGetMapBucketHead(Node* node)
11910 {
11911     SpeculateCellOperand map(this, node-&gt;child1());
11912     GPRTemporary bucket(this);
11913 
11914     GPRReg mapGPR = map.gpr();
11915     GPRReg bucketGPR = bucket.gpr();
11916 
11917     if (node-&gt;child1().useKind() == MapObjectUse)
11918         speculateMapObject(node-&gt;child1(), mapGPR);
11919     else if (node-&gt;child1().useKind() == SetObjectUse)
11920         speculateSetObject(node-&gt;child1(), mapGPR);
11921     else
11922         RELEASE_ASSERT_NOT_REACHED();
11923 
11924     ASSERT(HashMapImpl&lt;HashMapBucket&lt;HashMapBucketDataKey&gt;&gt;::offsetOfHead() == HashMapImpl&lt;HashMapBucket&lt;HashMapBucketDataKeyValue&gt;&gt;::offsetOfHead());
11925     m_jit.loadPtr(MacroAssembler::Address(mapGPR, HashMapImpl&lt;HashMapBucket&lt;HashMapBucketDataKey&gt;&gt;::offsetOfHead()), bucketGPR);
</pre>
<hr />
<pre>
11934     GPRReg bucketGPR = bucket.gpr();
11935     GPRReg resultGPR = result.gpr();
11936 
11937     ASSERT(HashMapBucket&lt;HashMapBucketDataKey&gt;::offsetOfNext() == HashMapBucket&lt;HashMapBucketDataKeyValue&gt;::offsetOfNext());
11938     ASSERT(HashMapBucket&lt;HashMapBucketDataKey&gt;::offsetOfKey() == HashMapBucket&lt;HashMapBucketDataKeyValue&gt;::offsetOfKey());
11939     m_jit.loadPtr(MacroAssembler::Address(bucketGPR, HashMapBucket&lt;HashMapBucketDataKeyValue&gt;::offsetOfNext()), resultGPR);
11940 
11941     MacroAssembler::Label loop = m_jit.label();
11942     auto notBucket = m_jit.branchTestPtr(MacroAssembler::Zero, resultGPR);
11943 #if USE(JSVALUE32_64)
11944     auto done = m_jit.branch32(MacroAssembler::NotEqual, MacroAssembler::Address(resultGPR, HashMapBucket&lt;HashMapBucketDataKeyValue&gt;::offsetOfKey() + TagOffset), TrustedImm32(JSValue::EmptyValueTag));
11945 #else
11946     auto done = m_jit.branchTest64(MacroAssembler::NonZero, MacroAssembler::Address(resultGPR, HashMapBucket&lt;HashMapBucketDataKeyValue&gt;::offsetOfKey()));
11947 #endif
11948     m_jit.loadPtr(MacroAssembler::Address(resultGPR, HashMapBucket&lt;HashMapBucketDataKeyValue&gt;::offsetOfNext()), resultGPR);
11949     m_jit.jump().linkTo(loop, &amp;m_jit);
11950 
11951     notBucket.link(&amp;m_jit);
11952     JSCell* sentinel = nullptr;
11953     if (node-&gt;bucketOwnerType() == BucketOwnerType::Map)
<span class="line-modified">11954         sentinel = vm().sentinelMapBucket();</span>
11955     else {
11956         ASSERT(node-&gt;bucketOwnerType() == BucketOwnerType::Set);
<span class="line-modified">11957         sentinel = vm().sentinelSetBucket();</span>
11958     }
11959     m_jit.move(TrustedImmPtr::weakPointer(m_jit.graph(), sentinel), resultGPR);
11960     done.link(&amp;m_jit);
11961 
11962     cellResult(resultGPR, node);
11963 }
11964 
11965 void SpeculativeJIT::compileLoadKeyFromMapBucket(Node* node)
11966 {
11967     SpeculateCellOperand bucket(this, node-&gt;child1());
11968     JSValueRegsTemporary result(this);
11969 
11970     GPRReg bucketGPR = bucket.gpr();
11971     JSValueRegs resultRegs = result.regs();
11972 
11973     m_jit.loadValue(MacroAssembler::Address(bucketGPR, HashMapBucket&lt;HashMapBucketDataKeyValue&gt;::offsetOfKey()), resultRegs);
11974     jsValueResult(resultRegs, node);
11975 }
11976 
11977 void SpeculativeJIT::compileLoadValueFromMapBucket(Node* node)
</pre>
<hr />
<pre>
12480 
12481 void SpeculativeJIT::compileToThis(Node* node)
12482 {
12483     ASSERT(node-&gt;child1().useKind() == UntypedUse);
12484     JSValueOperand thisValue(this, node-&gt;child1());
12485     JSValueRegsTemporary temp(this);
12486 
12487     JSValueRegs thisValueRegs = thisValue.jsValueRegs();
12488     JSValueRegs tempRegs = temp.regs();
12489 
12490     MacroAssembler::JumpList slowCases;
12491     slowCases.append(m_jit.branchIfNotCell(thisValueRegs));
12492     slowCases.append(
12493         m_jit.branchTest8(
12494             MacroAssembler::NonZero,
12495             MacroAssembler::Address(thisValueRegs.payloadGPR(), JSCell::typeInfoFlagsOffset()),
12496             MacroAssembler::TrustedImm32(OverridesToThis)));
12497     m_jit.moveValueRegs(thisValueRegs, tempRegs);
12498 
12499     J_JITOperation_EJ function;
<span class="line-modified">12500     if (m_jit.isStrictModeFor(node-&gt;origin.semantic))</span>
12501         function = operationToThisStrict;
12502     else
12503         function = operationToThis;
12504     addSlowPathGenerator(slowPathCall(slowCases, this, function, tempRegs, thisValueRegs));
12505 
12506     jsValueResult(tempRegs, node);
12507 }
12508 
12509 void SpeculativeJIT::compileObjectKeys(Node* node)
12510 {
12511     switch (node-&gt;child1().useKind()) {
12512     case ObjectUse: {
12513         if (m_graph.isWatchingHavingABadTimeWatchpoint(node)) {
12514             SpeculateCellOperand object(this, node-&gt;child1());
12515             GPRTemporary structure(this);
12516             GPRTemporary scratch(this);
12517             GPRTemporary scratch2(this);
12518             GPRTemporary scratch3(this);
12519             GPRTemporary result(this);
12520 
12521             GPRReg objectGPR = object.gpr();
12522             GPRReg structureGPR = structure.gpr();
12523             GPRReg scratchGPR = scratch.gpr();
12524             GPRReg scratch2GPR = scratch2.gpr();
12525             GPRReg scratch3GPR = scratch3.gpr();
12526             GPRReg resultGPR = result.gpr();
12527 
12528             speculateObject(node-&gt;child1(), objectGPR);
12529 
12530             CCallHelpers::JumpList slowCases;
<span class="line-modified">12531             m_jit.emitLoadStructure(vm(), objectGPR, structureGPR, scratchGPR);</span>
12532             m_jit.loadPtr(CCallHelpers::Address(structureGPR, Structure::previousOrRareDataOffset()), scratchGPR);
12533 
12534             slowCases.append(m_jit.branchTestPtr(CCallHelpers::Zero, scratchGPR));
<span class="line-modified">12535             slowCases.append(m_jit.branch32(CCallHelpers::Equal, CCallHelpers::Address(scratchGPR, JSCell::structureIDOffset()), TrustedImm32(bitwise_cast&lt;int32_t&gt;(vm().structureStructure-&gt;structureID()))));</span>
12536 
12537             m_jit.loadPtr(CCallHelpers::Address(scratchGPR, StructureRareData::offsetOfCachedOwnKeys()), scratchGPR);
12538 
12539             ASSERT(bitwise_cast&lt;uintptr_t&gt;(StructureRareData::cachedOwnKeysSentinel()) == 1);
12540             slowCases.append(m_jit.branchPtr(CCallHelpers::BelowOrEqual, scratchGPR, TrustedImmPtr(bitwise_cast&lt;void*&gt;(StructureRareData::cachedOwnKeysSentinel()))));
12541 
12542             MacroAssembler::JumpList slowButArrayBufferCases;
12543 
12544             JSGlobalObject* globalObject = m_jit.graph().globalObjectFor(node-&gt;origin.semantic);
12545             RegisteredStructure arrayStructure = m_jit.graph().registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(CopyOnWriteArrayWithContiguous));
12546 
12547             m_jit.move(scratchGPR, scratch3GPR);
12548             m_jit.addPtr(TrustedImmPtr(JSImmutableButterfly::offsetOfData()), scratchGPR);
12549 
12550             emitAllocateJSObject&lt;JSArray&gt;(resultGPR, TrustedImmPtr(arrayStructure), scratchGPR, structureGPR, scratch2GPR, slowButArrayBufferCases);
12551 
12552             addSlowPathGenerator(slowPathCall(slowButArrayBufferCases, this, operationNewArrayBuffer, resultGPR, arrayStructure, scratch3GPR));
12553 
12554             addSlowPathGenerator(slowPathCall(slowCases, this, operationObjectKeysObject, resultGPR, objectGPR));
12555 
</pre>
<hr />
<pre>
12647     GPRTemporary result(this);
12648     GPRTemporary allocator(this);
12649     GPRTemporary structure(this);
12650     GPRTemporary scratch(this);
12651 
12652     GPRReg calleeGPR = callee.gpr();
12653     GPRReg resultGPR = result.gpr();
12654     GPRReg allocatorGPR = allocator.gpr();
12655     GPRReg structureGPR = structure.gpr();
12656     GPRReg scratchGPR = scratch.gpr();
12657     // Rare data is only used to access the allocator &amp; structure
12658     // We can avoid using an additional GPR this way
12659     GPRReg rareDataGPR = structureGPR;
12660     GPRReg inlineCapacityGPR = rareDataGPR;
12661 
12662     MacroAssembler::JumpList slowPath;
12663 
12664     slowPath.append(m_jit.branchIfNotFunction(calleeGPR));
12665     m_jit.loadPtr(JITCompiler::Address(calleeGPR, JSFunction::offsetOfRareData()), rareDataGPR);
12666     slowPath.append(m_jit.branchTestPtr(MacroAssembler::Zero, rareDataGPR));
<span class="line-modified">12667     m_jit.loadPtr(JITCompiler::Address(rareDataGPR, FunctionRareData::offsetOfObjectAllocationProfile() + ObjectAllocationProfileWithPrototype::offsetOfAllocator()), allocatorGPR);</span>
<span class="line-modified">12668     m_jit.loadPtr(JITCompiler::Address(rareDataGPR, FunctionRareData::offsetOfObjectAllocationProfile() + ObjectAllocationProfileWithPrototype::offsetOfStructure()), structureGPR);</span>
12669 
12670     auto butterfly = TrustedImmPtr(nullptr);
12671     emitAllocateJSObject(resultGPR, JITAllocator::variable(), allocatorGPR, structureGPR, butterfly, scratchGPR, slowPath);
12672 
<span class="line-modified">12673     m_jit.load8(JITCompiler::Address(structureGPR, Structure::inlineCapacityOffset()), inlineCapacityGPR);</span>

12674     m_jit.emitInitializeInlineStorage(resultGPR, inlineCapacityGPR);
<span class="line-modified">12675     m_jit.mutatorFence(vm());</span>
12676 
12677     addSlowPathGenerator(slowPathCall(slowPath, this, operationCreateThis, resultGPR, calleeGPR, node-&gt;inlineCapacity()));
12678 
12679     cellResult(resultGPR, node);
12680 }
12681 
12682 void SpeculativeJIT::compileNewObject(Node* node)
12683 {
12684     GPRTemporary result(this);
12685     GPRTemporary allocator(this);
12686     GPRTemporary scratch(this);
12687 
12688     GPRReg resultGPR = result.gpr();
12689     GPRReg allocatorGPR = allocator.gpr();
12690     GPRReg scratchGPR = scratch.gpr();
12691 
12692     MacroAssembler::JumpList slowPath;
12693 
12694     RegisteredStructure structure = node-&gt;structure();
12695     size_t allocationSize = JSFinalObject::allocationSize(structure-&gt;inlineCapacity());
<span class="line-modified">12696     Allocator allocatorValue = allocatorForNonVirtualConcurrently&lt;JSFinalObject&gt;(vm(), allocationSize, AllocatorForMode::AllocatorIfExists);</span>
12697     if (!allocatorValue)
12698         slowPath.append(m_jit.jump());
12699     else {
12700         auto butterfly = TrustedImmPtr(nullptr);
12701         emitAllocateJSObject(resultGPR, JITAllocator::constant(allocatorValue), allocatorGPR, TrustedImmPtr(structure), butterfly, scratchGPR, slowPath);
12702         m_jit.emitInitializeInlineStorage(resultGPR, structure-&gt;inlineCapacity());
<span class="line-modified">12703         m_jit.mutatorFence(vm());</span>
12704     }
12705 
12706     addSlowPathGenerator(slowPathCall(slowPath, this, operationNewObject, resultGPR, structure));
12707 
12708     cellResult(resultGPR, node);
12709 }
12710 
12711 void SpeculativeJIT::compileToPrimitive(Node* node)
12712 {
12713     DFG_ASSERT(m_jit.graph(), node, node-&gt;child1().useKind() == UntypedUse, node-&gt;child1().useKind());
12714     JSValueOperand argument(this, node-&gt;child1());
12715     JSValueRegsTemporary result(this, Reuse, argument);
12716 
12717     JSValueRegs argumentRegs = argument.jsValueRegs();
12718     JSValueRegs resultRegs = result.regs();
12719 
12720     argument.use();
12721 
12722     MacroAssembler::Jump alreadyPrimitive = m_jit.branchIfNotCell(argumentRegs);
12723     MacroAssembler::Jump notPrimitive = m_jit.branchIfObject(argumentRegs.payloadGPR());
</pre>
<hr />
<pre>
12726     m_jit.moveValueRegs(argumentRegs, resultRegs);
12727 
12728     addSlowPathGenerator(slowPathCall(notPrimitive, this, operationToPrimitive, resultRegs, argumentRegs));
12729 
12730     jsValueResult(resultRegs, node, DataFormatJS, UseChildrenCalledExplicitly);
12731 }
12732 
12733 void SpeculativeJIT::compileLogShadowChickenPrologue(Node* node)
12734 {
12735     flushRegisters();
12736     prepareForExternalCall();
12737     m_jit.emitStoreCodeOrigin(node-&gt;origin.semantic);
12738 
12739     GPRTemporary scratch1(this, GPRInfo::nonArgGPR0); // This must be a non-argument GPR.
12740     GPRReg scratch1Reg = scratch1.gpr();
12741     GPRTemporary scratch2(this);
12742     GPRReg scratch2Reg = scratch2.gpr();
12743     GPRTemporary shadowPacket(this);
12744     GPRReg shadowPacketReg = shadowPacket.gpr();
12745 
<span class="line-modified">12746     m_jit.ensureShadowChickenPacket(vm(), shadowPacketReg, scratch1Reg, scratch2Reg);</span>
12747 
12748     SpeculateCellOperand scope(this, node-&gt;child1());
12749     GPRReg scopeReg = scope.gpr();
12750 
12751     m_jit.logShadowChickenProloguePacket(shadowPacketReg, scratch1Reg, scopeReg);
12752     noResult(node);
12753 }
12754 
12755 void SpeculativeJIT::compileLogShadowChickenTail(Node* node)
12756 {
12757     flushRegisters();
12758     prepareForExternalCall();
12759     CallSiteIndex callSiteIndex = m_jit.emitStoreCodeOrigin(node-&gt;origin.semantic);
12760 
12761     GPRTemporary scratch1(this, GPRInfo::nonArgGPR0); // This must be a non-argument GPR.
12762     GPRReg scratch1Reg = scratch1.gpr();
12763     GPRTemporary scratch2(this);
12764     GPRReg scratch2Reg = scratch2.gpr();
12765     GPRTemporary shadowPacket(this);
12766     GPRReg shadowPacketReg = shadowPacket.gpr();
12767 
<span class="line-modified">12768     m_jit.ensureShadowChickenPacket(vm(), shadowPacketReg, scratch1Reg, scratch2Reg);</span>
12769 
12770     JSValueOperand thisValue(this, node-&gt;child1());
12771     JSValueRegs thisRegs = thisValue.jsValueRegs();
12772     SpeculateCellOperand scope(this, node-&gt;child2());
12773     GPRReg scopeReg = scope.gpr();
12774 
12775     m_jit.logShadowChickenTailPacket(shadowPacketReg, thisRegs, scopeReg, m_jit.codeBlock(), callSiteIndex);
12776     noResult(node);
12777 }
12778 
12779 void SpeculativeJIT::compileSetAdd(Node* node)
12780 {
12781     SpeculateCellOperand set(this, node-&gt;child1());
12782     JSValueOperand key(this, node-&gt;child2());
12783     SpeculateInt32Operand hash(this, node-&gt;child3());
12784 
12785     GPRReg setGPR = set.gpr();
12786     JSValueRegs keyRegs = key.jsValueRegs();
12787     GPRReg hashGPR = hash.gpr();
12788 
</pre>
<hr />
<pre>
12968 
12969         GPRReg objectGPR = object.gpr();
12970         GPRReg tempGPR = temp.gpr();
12971         GPRReg temp2GPR = temp2.gpr();
12972 
12973         switch (node-&gt;child1().useKind()) {
12974         case ArrayUse:
12975             speculateArray(node-&gt;child1(), objectGPR);
12976             break;
12977         case FunctionUse:
12978             speculateFunction(node-&gt;child1(), objectGPR);
12979             break;
12980         case FinalObjectUse:
12981             speculateFinalObject(node-&gt;child1(), objectGPR);
12982             break;
12983         default:
12984             RELEASE_ASSERT_NOT_REACHED();
12985             break;
12986         }
12987 
<span class="line-modified">12988         m_jit.emitLoadStructure(vm(), objectGPR, tempGPR, temp2GPR);</span>
12989 
12990         AbstractValue&amp; value = m_state.forNode(node-&gt;child1());
12991         if ((value.m_type &amp;&amp; !(value.m_type &amp; ~SpecObject)) &amp;&amp; value.m_structure.isFinite()) {
12992             bool hasPolyProto = false;
12993             bool hasMonoProto = false;
12994             value.m_structure.forEach([&amp;] (RegisteredStructure structure) {
12995                 if (structure-&gt;hasPolyProto())
12996                     hasPolyProto = true;
12997                 else
12998                     hasMonoProto = true;
12999             });
13000 
13001             if (hasMonoProto &amp;&amp; !hasPolyProto) {
13002 #if USE(JSVALUE64)
13003                 m_jit.load64(MacroAssembler::Address(tempGPR, Structure::prototypeOffset()), tempGPR);
13004                 jsValueResult(tempGPR, node);
13005 #else
13006                 m_jit.load32(MacroAssembler::Address(tempGPR, Structure::prototypeOffset() + TagOffset), temp2GPR);
13007                 m_jit.load32(MacroAssembler::Address(tempGPR, Structure::prototypeOffset() + PayloadOffset), tempGPR);
13008                 jsValueResult(temp2GPR, tempGPR, node);
</pre>
<hr />
<pre>
13169 
13170 #if USE(JSVALUE64)
13171     JSValueRegs emptyValueRegs(scratchGPR);
13172     if (hasDouble(indexingType))
13173         m_jit.move(TrustedImm64(bitwise_cast&lt;int64_t&gt;(PNaN)), emptyValueRegs.gpr());
13174     else
13175         m_jit.move(TrustedImm64(JSValue::encode(JSValue())), emptyValueRegs.gpr());
13176 #else
13177     JSValueRegs emptyValueRegs(scratchGPR, scratch2GPR);
13178     if (hasDouble(indexingType))
13179         m_jit.moveValue(JSValue(JSValue::EncodeAsDouble, PNaN), emptyValueRegs);
13180     else
13181         m_jit.moveValue(JSValue(), emptyValueRegs);
13182 #endif
13183     emitInitializeButterfly(storageGPR, sizeGPR, emptyValueRegs, resultGPR);
13184 
13185     RegisteredStructure structure = m_jit.graph().registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(indexingType));
13186 
13187     emitAllocateJSObject&lt;JSArray&gt;(resultGPR, TrustedImmPtr(structure), storageGPR, scratchGPR, scratch2GPR, slowCases);
13188 
<span class="line-modified">13189     m_jit.mutatorFence(vm());</span>
13190 
<span class="line-modified">13191     addSlowPathGenerator(makeUnique&lt;CallArrayAllocatorWithVariableSizeSlowPathGenerator&gt;(</span>
13192         slowCases, this, operationNewArrayWithSize, resultGPR,
13193         structure,
13194         shouldConvertLargeSizeToArrayStorage ? m_jit.graph().registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithArrayStorage)) : structure,
13195         sizeGPR, storageGPR));
13196 }
13197 
13198 void SpeculativeJIT::compileHasIndexedProperty(Node* node)
13199 {
13200     SpeculateCellOperand base(this, m_graph.varArgChild(node, 0));
13201     SpeculateStrictInt32Operand index(this, m_graph.varArgChild(node, 1));
13202     GPRTemporary result(this);
13203 
13204     GPRReg baseGPR = base.gpr();
13205     GPRReg indexGPR = index.gpr();
13206     GPRReg resultGPR = result.gpr();
13207 
13208     MacroAssembler::JumpList slowCases;
13209     ArrayMode mode = node-&gt;arrayMode();
13210     switch (mode.type()) {
13211     case Array::Int32:
</pre>
<hr />
<pre>
13273         slowCases.append(m_jit.branchIfEmpty(scratchGPR));
13274 #endif
13275         m_jit.move(TrustedImm32(1), resultGPR);
13276         break;
13277     }
13278     default: {
13279         slowCases.append(m_jit.jump());
13280         break;
13281     }
13282     }
13283 
13284     addSlowPathGenerator(slowPathCall(slowCases, this, operationHasIndexedPropertyByInt, resultGPR, baseGPR, indexGPR, static_cast&lt;int32_t&gt;(node-&gt;internalMethodType())));
13285 
13286     unblessedBooleanResult(resultGPR, node);
13287 }
13288 
13289 void SpeculativeJIT::compileGetDirectPname(Node* node)
13290 {
13291     Edge&amp; baseEdge = m_jit.graph().varArgChild(node, 0);
13292     Edge&amp; propertyEdge = m_jit.graph().varArgChild(node, 1);
<span class="line-added">13293     Edge&amp; indexEdge = m_jit.graph().varArgChild(node, 2);</span>
13294 
13295     SpeculateCellOperand base(this, baseEdge);
13296     SpeculateCellOperand property(this, propertyEdge);
13297     GPRReg baseGPR = base.gpr();
13298     GPRReg propertyGPR = property.gpr();
13299 
13300 #if CPU(X86)
13301     // Not enough registers on X86 for this code, so always use the slow path.
<span class="line-added">13302     speculate(node, indexEdge);</span>
13303     flushRegisters();
13304     JSValueRegsFlushedCallResult result(this);
13305     JSValueRegs resultRegs = result.regs();
13306     callOperation(operationGetByValCell, resultRegs, baseGPR, CCallHelpers::CellValue(propertyGPR));
13307     m_jit.exceptionCheck();
13308     jsValueResult(resultRegs, node);
13309 #else

13310     Edge&amp; enumeratorEdge = m_jit.graph().varArgChild(node, 3);
13311     SpeculateStrictInt32Operand index(this, indexEdge);
13312     SpeculateCellOperand enumerator(this, enumeratorEdge);
13313     GPRTemporary scratch(this);
13314     JSValueRegsTemporary result(this);
13315 
13316     GPRReg indexGPR = index.gpr();
13317     GPRReg enumeratorGPR = enumerator.gpr();
13318     GPRReg scratchGPR = scratch.gpr();
13319     JSValueRegs resultRegs = result.regs();
13320 
13321     MacroAssembler::JumpList slowPath;
13322 
13323     // Check the structure
13324     m_jit.load32(MacroAssembler::Address(baseGPR, JSCell::structureIDOffset()), scratchGPR);
13325     slowPath.append(
13326         m_jit.branch32(
13327             MacroAssembler::NotEqual,
13328             scratchGPR,
13329             MacroAssembler::Address(
</pre>
<hr />
<pre>
13396     TypeLocation* cachedTypeLocation = node-&gt;typeLocation();
13397     // Compile in a predictive type check, if possible, to see if we can skip writing to the log.
13398     // These typechecks are inlined to match those of the 64-bit JSValue type checks.
13399     if (cachedTypeLocation-&gt;m_lastSeenType == TypeUndefined)
13400         jumpToEnd.append(m_jit.branchIfUndefined(valueRegs));
13401     else if (cachedTypeLocation-&gt;m_lastSeenType == TypeNull)
13402         jumpToEnd.append(m_jit.branchIfNull(valueRegs));
13403     else if (cachedTypeLocation-&gt;m_lastSeenType == TypeBoolean)
13404         jumpToEnd.append(m_jit.branchIfBoolean(valueRegs, scratch1GPR));
13405     else if (cachedTypeLocation-&gt;m_lastSeenType == TypeAnyInt)
13406         jumpToEnd.append(m_jit.branchIfInt32(valueRegs));
13407     else if (cachedTypeLocation-&gt;m_lastSeenType == TypeNumber)
13408         jumpToEnd.append(m_jit.branchIfNumber(valueRegs, scratch1GPR));
13409     else if (cachedTypeLocation-&gt;m_lastSeenType == TypeString) {
13410         MacroAssembler::Jump isNotCell = m_jit.branchIfNotCell(valueRegs);
13411         jumpToEnd.append(m_jit.branchIfString(valueRegs.payloadGPR()));
13412         isNotCell.link(&amp;m_jit);
13413     }
13414 
13415     // Load the TypeProfilerLog into Scratch2.
<span class="line-modified">13416     TypeProfilerLog* cachedTypeProfilerLog = vm().typeProfilerLog();</span>
13417     m_jit.move(TrustedImmPtr(cachedTypeProfilerLog), scratch2GPR);
13418 
13419     // Load the next LogEntry into Scratch1.
13420     m_jit.loadPtr(MacroAssembler::Address(scratch2GPR, TypeProfilerLog::currentLogEntryOffset()), scratch1GPR);
13421 
13422     // Store the JSValue onto the log entry.
13423     m_jit.storeValue(valueRegs, MacroAssembler::Address(scratch1GPR, TypeProfilerLog::LogEntry::valueOffset()));
13424 
13425     // Store the structureID of the cell if valueRegs is a cell, otherwise, store 0 on the log entry.
13426     MacroAssembler::Jump isNotCell = m_jit.branchIfNotCell(valueRegs);
13427     m_jit.load32(MacroAssembler::Address(valueRegs.payloadGPR(), JSCell::structureIDOffset()), scratch3GPR);
13428     m_jit.store32(scratch3GPR, MacroAssembler::Address(scratch1GPR, TypeProfilerLog::LogEntry::structureIDOffset()));
13429     MacroAssembler::Jump skipIsCell = m_jit.jump();
13430     isNotCell.link(&amp;m_jit);
13431     m_jit.store32(TrustedImm32(0), MacroAssembler::Address(scratch1GPR, TypeProfilerLog::LogEntry::structureIDOffset()));
13432     skipIsCell.link(&amp;m_jit);
13433 
13434     // Store the typeLocation on the log entry.
13435     m_jit.move(TrustedImmPtr(cachedTypeLocation), scratch3GPR);
13436     m_jit.storePtr(scratch3GPR, MacroAssembler::Address(scratch1GPR, TypeProfilerLog::LogEntry::locationOffset()));
</pre>
<hr />
<pre>
13646         numOpGPRs = 2;
13647     }
13648 
13649 #if CPU(ADDRESS64)
13650     Edge edges[3] = {
13651         node-&gt;child1(),
13652         node-&gt;child2(),
13653         node-&gt;child3()
13654     };
13655 
13656     GPRTemporary result(this);
13657     GPRTemporary allocator(this);
13658     GPRTemporary scratch(this);
13659     GPRTemporary scratch2(this);
13660     GPRReg resultGPR = result.gpr();
13661     GPRReg allocatorGPR = allocator.gpr();
13662     GPRReg scratchGPR = scratch.gpr();
13663     GPRReg scratch2GPR = scratch2.gpr();
13664 
13665     CCallHelpers::JumpList slowPath;
<span class="line-modified">13666     Allocator allocatorValue = allocatorForNonVirtualConcurrently&lt;JSRopeString&gt;(vm(), sizeof(JSRopeString), AllocatorForMode::AllocatorIfExists);</span>
<span class="line-modified">13667     emitAllocateJSCell(resultGPR, JITAllocator::constant(allocatorValue), allocatorGPR, TrustedImmPtr(m_jit.graph().registerStructure(vm().stringStructure.get())), scratchGPR, slowPath);</span>



13668 
<span class="line-modified">13669     // This puts nullptr for the first fiber. It makes visitChildren safe even if this JSRopeString is discarded due to the speculation failure in the following path.</span>
<span class="line-modified">13670     m_jit.storePtr(TrustedImmPtr(JSString::isRopeInPointer), CCallHelpers::Address(resultGPR, JSRopeString::offsetOfFiber0()));</span>












13671 
13672     {
<span class="line-modified">13673         if (JSString* string = edges[0]-&gt;dynamicCastConstant&lt;JSString*&gt;(vm())) {</span>
13674             m_jit.move(TrustedImm32(string-&gt;is8Bit() ? StringImpl::flagIs8Bit() : 0), scratchGPR);
13675             m_jit.move(TrustedImm32(string-&gt;length()), allocatorGPR);
13676         } else {
<span class="line-modified">13677             bool needsRopeCase = canBeRope(edges[0]);</span>
13678             m_jit.loadPtr(CCallHelpers::Address(opGPRs[0], JSString::offsetOfValue()), scratch2GPR);
13679             CCallHelpers::Jump isRope;
<span class="line-modified">13680             if (needsRopeCase)</span>
13681                 isRope = m_jit.branchIfRopeStringImpl(scratch2GPR);
13682 
13683             m_jit.load32(CCallHelpers::Address(scratch2GPR, StringImpl::flagsOffset()), scratchGPR);
13684             m_jit.load32(CCallHelpers::Address(scratch2GPR, StringImpl::lengthMemoryOffset()), allocatorGPR);
13685 
<span class="line-modified">13686             if (needsRopeCase) {</span>
13687                 auto done = m_jit.jump();
13688 
13689                 isRope.link(&amp;m_jit);
<span class="line-modified">13690                 m_jit.load32(CCallHelpers::Address(opGPRs[0], JSRopeString::offsetOfFlags()), scratchGPR);</span>
13691                 m_jit.load32(CCallHelpers::Address(opGPRs[0], JSRopeString::offsetOfLength()), allocatorGPR);
13692                 done.link(&amp;m_jit);
13693             }
13694         }
13695 
13696         if (!ASSERT_DISABLED) {
13697             CCallHelpers::Jump ok = m_jit.branch32(
13698                 CCallHelpers::GreaterThanOrEqual, allocatorGPR, TrustedImm32(0));
13699             m_jit.abortWithReason(DFGNegativeStringLength);
13700             ok.link(&amp;m_jit);
13701         }
13702     }
13703 
13704     for (unsigned i = 1; i &lt; numOpGPRs; ++i) {
<span class="line-modified">13705         if (JSString* string = edges[i]-&gt;dynamicCastConstant&lt;JSString*&gt;(vm())) {</span>
13706             m_jit.and32(TrustedImm32(string-&gt;is8Bit() ? StringImpl::flagIs8Bit() : 0), scratchGPR);
13707             speculationCheck(
13708                 Uncountable, JSValueSource(), nullptr,
13709                 m_jit.branchAdd32(
13710                     CCallHelpers::Overflow,
13711                     TrustedImm32(string-&gt;length()), allocatorGPR));
13712         } else {
<span class="line-modified">13713             bool needsRopeCase = canBeRope(edges[i]);</span>
13714             m_jit.loadPtr(CCallHelpers::Address(opGPRs[i], JSString::offsetOfValue()), scratch2GPR);
13715             CCallHelpers::Jump isRope;
<span class="line-modified">13716             if (needsRopeCase)</span>
13717                 isRope = m_jit.branchIfRopeStringImpl(scratch2GPR);
13718 
<span class="line-modified">13719             m_jit.and32(CCallHelpers::Address(scratch2GPR, StringImpl::flagsOffset()), scratchGPR);</span>
13720             speculationCheck(
13721                 Uncountable, JSValueSource(), nullptr,
13722                 m_jit.branchAdd32(
13723                     CCallHelpers::Overflow,
13724                     CCallHelpers::Address(scratch2GPR, StringImpl::lengthMemoryOffset()), allocatorGPR));
<span class="line-modified">13725             if (needsRopeCase) {</span>
13726                 auto done = m_jit.jump();
13727 
13728                 isRope.link(&amp;m_jit);
<span class="line-modified">13729                 m_jit.and32(CCallHelpers::Address(opGPRs[i], JSRopeString::offsetOfFlags()), scratchGPR);</span>
13730                 m_jit.load32(CCallHelpers::Address(opGPRs[i], JSRopeString::offsetOfLength()), scratch2GPR);
13731                 speculationCheck(
13732                     Uncountable, JSValueSource(), nullptr,
13733                     m_jit.branchAdd32(
13734                         CCallHelpers::Overflow, scratch2GPR, allocatorGPR));
13735                 done.link(&amp;m_jit);
13736             }
13737         }
13738     }
<span class="line-modified">13739 </span>
13740     if (!ASSERT_DISABLED) {
13741         CCallHelpers::Jump ok = m_jit.branch32(
13742             CCallHelpers::GreaterThanOrEqual, allocatorGPR, TrustedImm32(0));
13743         m_jit.abortWithReason(DFGNegativeStringLength);
13744         ok.link(&amp;m_jit);
13745     }
<span class="line-modified">13746 </span>
<span class="line-added">13747     static_assert(StringImpl::flagIs8Bit() == JSRopeString::is8BitInPointer, &quot;&quot;);</span>
<span class="line-added">13748     m_jit.and32(TrustedImm32(StringImpl::flagIs8Bit()), scratchGPR);</span>
<span class="line-added">13749     m_jit.orPtr(opGPRs[0], scratchGPR);</span>
<span class="line-added">13750     m_jit.orPtr(TrustedImmPtr(JSString::isRopeInPointer), scratchGPR);</span>
<span class="line-added">13751     m_jit.storePtr(scratchGPR, CCallHelpers::Address(resultGPR, JSRopeString::offsetOfFiber0()));</span>
<span class="line-added">13752 </span>
<span class="line-added">13753     m_jit.move(opGPRs[1], scratchGPR);</span>
<span class="line-added">13754     m_jit.lshiftPtr(TrustedImm32(32), scratchGPR);</span>
<span class="line-added">13755     m_jit.orPtr(allocatorGPR, scratchGPR);</span>
<span class="line-added">13756     m_jit.storePtr(scratchGPR, CCallHelpers::Address(resultGPR, JSRopeString::offsetOfFiber1()));</span>
<span class="line-added">13757 </span>
<span class="line-added">13758     if (numOpGPRs == 2) {</span>
<span class="line-added">13759         m_jit.move(opGPRs[1], scratchGPR);</span>
<span class="line-added">13760         m_jit.rshiftPtr(TrustedImm32(32), scratchGPR);</span>
<span class="line-added">13761         m_jit.storePtr(scratchGPR, CCallHelpers::Address(resultGPR, JSRopeString::offsetOfFiber2()));</span>
<span class="line-added">13762     } else {</span>
<span class="line-added">13763         m_jit.move(opGPRs[1], scratchGPR);</span>
<span class="line-added">13764         m_jit.rshiftPtr(TrustedImm32(32), scratchGPR);</span>
<span class="line-added">13765         m_jit.move(opGPRs[2], scratch2GPR);</span>
<span class="line-added">13766         m_jit.lshiftPtr(TrustedImm32(16), scratch2GPR);</span>
<span class="line-added">13767         m_jit.orPtr(scratch2GPR, scratchGPR);</span>
<span class="line-added">13768         m_jit.storePtr(scratchGPR, CCallHelpers::Address(resultGPR, JSRopeString::offsetOfFiber2()));</span>
<span class="line-added">13769     }</span>
<span class="line-added">13770 </span>
13771     auto isNonEmptyString = m_jit.branchTest32(CCallHelpers::NonZero, allocatorGPR);
13772 
<span class="line-modified">13773     m_jit.move(TrustedImmPtr::weakPointer(m_jit.graph(), jsEmptyString(m_jit.graph().m_vm)), resultGPR);</span>
13774 
13775     isNonEmptyString.link(&amp;m_jit);
<span class="line-modified">13776     m_jit.mutatorFence(vm());</span>
13777 
13778     switch (numOpGPRs) {
13779     case 2:
13780         addSlowPathGenerator(slowPathCall(
13781             slowPath, this, operationMakeRope2, resultGPR, opGPRs[0], opGPRs[1]));
13782         break;
13783     case 3:
13784         addSlowPathGenerator(slowPathCall(
13785             slowPath, this, operationMakeRope3, resultGPR, opGPRs[0], opGPRs[1], opGPRs[2]));
13786         break;
13787     default:
13788         RELEASE_ASSERT_NOT_REACHED();
13789         break;
13790     }
13791 
13792     cellResult(resultGPR, node);
13793 #else
13794     flushRegisters();
13795     GPRFlushedCallResult result(this);
13796     GPRReg resultGPR = result.gpr();
</pre>
</td>
</tr>
</table>
<center><a href="DFGSlowPathGenerator.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGSpeculativeJIT.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>