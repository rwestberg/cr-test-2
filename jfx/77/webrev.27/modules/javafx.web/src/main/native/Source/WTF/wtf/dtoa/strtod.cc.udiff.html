<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/WTF/wtf/dtoa/strtod.cc</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="fixed-dtoa.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="strtod.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WTF/wtf/dtoa/strtod.cc</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -53,85 +53,85 @@</span>
  // Any x &lt;= 10^-324 is interpreted as 0.
  // Note that 2.5e-324 (despite being smaller than the min double) will be read
  // as non-zero (equal to the min non-zero double).
  static const int kMaxDecimalPower = 309;
  static const int kMinDecimalPower = -324;
<span class="udiff-line-modified-removed">-     </span>
<span class="udiff-line-modified-added">+ </span>
  // 2^64 = 18446744073709551616
  static const uint64_t kMaxUint64 = UINT64_2PART_C(0xFFFFFFFF, FFFFFFFF);
<span class="udiff-line-modified-removed">-     </span>
<span class="udiff-line-modified-removed">-     </span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+ </span>
  #if defined(DOUBLE_CONVERSION_CORRECT_DOUBLE_OPERATIONS)
  static const double exact_powers_of_ten[] = {
<span class="udiff-line-modified-removed">-         1.0,  // 10^0</span>
<span class="udiff-line-modified-removed">-         10.0,</span>
<span class="udiff-line-modified-removed">-         100.0,</span>
<span class="udiff-line-modified-removed">-         1000.0,</span>
<span class="udiff-line-modified-removed">-         10000.0,</span>
<span class="udiff-line-modified-removed">-         100000.0,</span>
<span class="udiff-line-modified-removed">-         1000000.0,</span>
<span class="udiff-line-modified-removed">-         10000000.0,</span>
<span class="udiff-line-modified-removed">-         100000000.0,</span>
<span class="udiff-line-modified-removed">-         1000000000.0,</span>
<span class="udiff-line-modified-removed">-         10000000000.0,  // 10^10</span>
<span class="udiff-line-modified-removed">-         100000000000.0,</span>
<span class="udiff-line-modified-removed">-         1000000000000.0,</span>
<span class="udiff-line-modified-removed">-         10000000000000.0,</span>
<span class="udiff-line-modified-removed">-         100000000000000.0,</span>
<span class="udiff-line-modified-removed">-         1000000000000000.0,</span>
<span class="udiff-line-modified-removed">-         10000000000000000.0,</span>
<span class="udiff-line-modified-removed">-         100000000000000000.0,</span>
<span class="udiff-line-modified-removed">-         1000000000000000000.0,</span>
<span class="udiff-line-modified-removed">-         10000000000000000000.0,</span>
<span class="udiff-line-modified-removed">-         100000000000000000000.0,  // 10^20</span>
<span class="udiff-line-modified-removed">-         1000000000000000000000.0,</span>
<span class="udiff-line-modified-removed">-         // 10^22 = 0x21e19e0c9bab2400000 = 0x878678326eac9 * 2^22</span>
<span class="udiff-line-modified-removed">-         10000000000000000000000.0</span>
<span class="udiff-line-modified-added">+   1.0,  // 10^0</span>
<span class="udiff-line-modified-added">+   10.0,</span>
<span class="udiff-line-modified-added">+   100.0,</span>
<span class="udiff-line-modified-added">+   1000.0,</span>
<span class="udiff-line-modified-added">+   10000.0,</span>
<span class="udiff-line-modified-added">+   100000.0,</span>
<span class="udiff-line-modified-added">+   1000000.0,</span>
<span class="udiff-line-modified-added">+   10000000.0,</span>
<span class="udiff-line-modified-added">+   100000000.0,</span>
<span class="udiff-line-modified-added">+   1000000000.0,</span>
<span class="udiff-line-modified-added">+   10000000000.0,  // 10^10</span>
<span class="udiff-line-modified-added">+   100000000000.0,</span>
<span class="udiff-line-modified-added">+   1000000000000.0,</span>
<span class="udiff-line-modified-added">+   10000000000000.0,</span>
<span class="udiff-line-modified-added">+   100000000000000.0,</span>
<span class="udiff-line-modified-added">+   1000000000000000.0,</span>
<span class="udiff-line-modified-added">+   10000000000000000.0,</span>
<span class="udiff-line-modified-added">+   100000000000000000.0,</span>
<span class="udiff-line-modified-added">+   1000000000000000000.0,</span>
<span class="udiff-line-modified-added">+   10000000000000000000.0,</span>
<span class="udiff-line-modified-added">+   100000000000000000000.0,  // 10^20</span>
<span class="udiff-line-modified-added">+   1000000000000000000000.0,</span>
<span class="udiff-line-modified-added">+   // 10^22 = 0x21e19e0c9bab2400000 = 0x878678326eac9 * 2^22</span>
<span class="udiff-line-modified-added">+   10000000000000000000000.0</span>
  };
  static const int kExactPowersOfTenSize = ARRAY_SIZE(exact_powers_of_ten);
  #endif
<span class="udiff-line-modified-removed">-     </span>
<span class="udiff-line-modified-added">+ </span>
  // Maximum number of significant digits in the decimal representation.
  // In fact the value is 772 (see conversions.cc), but to give us some margin
  // we round up to 780.
  static const int kMaxSignificantDecimalDigits = 780;
<span class="udiff-line-modified-removed">-     </span>
<span class="udiff-line-modified-added">+ </span>
  static BufferReference&lt;const char&gt; TrimLeadingZeros(BufferReference&lt;const char&gt; buffer) {
<span class="udiff-line-modified-removed">-         for (int i = 0; i &lt; buffer.length(); i++) {</span>
<span class="udiff-line-modified-removed">-             if (buffer[i] != &#39;0&#39;) {</span>
<span class="udiff-line-modified-removed">-                 return buffer.SubBufferReference(i, buffer.length());</span>
<span class="udiff-line-modified-removed">-             }</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-removed">-         return BufferReference&lt;const char&gt;(buffer.start(), 0);</span>
<span class="udiff-line-modified-added">+   for (int i = 0; i &lt; buffer.length(); i++) {</span>
<span class="udiff-line-modified-added">+     if (buffer[i] != &#39;0&#39;) {</span>
<span class="udiff-line-modified-added">+       return buffer.SubBufferReference(i, buffer.length());</span>
<span class="udiff-line-modified-added">+     }</span>
<span class="udiff-line-modified-added">+   }</span>
<span class="udiff-line-modified-added">+   return BufferReference&lt;const char&gt;(buffer.start(), 0);</span>
  }
<span class="udiff-line-modified-removed">-     </span>
<span class="udiff-line-modified-removed">-     </span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+ </span>
  static BufferReference&lt;const char&gt; TrimTrailingZeros(BufferReference&lt;const char&gt; buffer) {
<span class="udiff-line-modified-removed">-         for (int i = buffer.length() - 1; i &gt;= 0; --i) {</span>
<span class="udiff-line-modified-removed">-             if (buffer[i] != &#39;0&#39;) {</span>
<span class="udiff-line-modified-removed">-                 return buffer.SubBufferReference(0, i + 1);</span>
<span class="udiff-line-modified-removed">-             }</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-removed">-         return BufferReference&lt;const char&gt;(buffer.start(), 0);</span>
<span class="udiff-line-modified-added">+   for (int i = buffer.length() - 1; i &gt;= 0; --i) {</span>
<span class="udiff-line-modified-added">+     if (buffer[i] != &#39;0&#39;) {</span>
<span class="udiff-line-modified-added">+       return buffer.SubBufferReference(0, i + 1);</span>
<span class="udiff-line-modified-added">+     }</span>
<span class="udiff-line-modified-added">+   }</span>
<span class="udiff-line-modified-added">+   return BufferReference&lt;const char&gt;(buffer.start(), 0);</span>
  }
<span class="udiff-line-modified-removed">-     </span>
<span class="udiff-line-modified-removed">-     </span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+ </span>
  static void CutToMaxSignificantDigits(BufferReference&lt;const char&gt; buffer,
<span class="udiff-line-modified-removed">-                                            int exponent,</span>
<span class="udiff-line-modified-removed">-                                            char* significant_buffer,</span>
<span class="udiff-line-modified-removed">-                                            int* significant_exponent) {</span>
<span class="udiff-line-modified-removed">-         for (int i = 0; i &lt; kMaxSignificantDecimalDigits - 1; ++i) {</span>
<span class="udiff-line-modified-removed">-             significant_buffer[i] = buffer[i];</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-removed">-         // The input buffer has been trimmed. Therefore the last digit must be</span>
<span class="udiff-line-modified-removed">-         // different from &#39;0&#39;.</span>
<span class="udiff-line-modified-removed">-         ASSERT(buffer[buffer.length() - 1] != &#39;0&#39;);</span>
<span class="udiff-line-modified-removed">-         // Set the last digit to be non-zero. This is sufficient to guarantee</span>
<span class="udiff-line-modified-removed">-         // correct rounding.</span>
<span class="udiff-line-modified-removed">-         significant_buffer[kMaxSignificantDecimalDigits - 1] = &#39;1&#39;;</span>
<span class="udiff-line-modified-removed">-         *significant_exponent =</span>
<span class="udiff-line-modified-removed">-         exponent + (buffer.length() - kMaxSignificantDecimalDigits);</span>
<span class="udiff-line-modified-added">+                                        int exponent,</span>
<span class="udiff-line-modified-added">+                                        char* significant_buffer,</span>
<span class="udiff-line-modified-added">+                                        int* significant_exponent) {</span>
<span class="udiff-line-modified-added">+   for (int i = 0; i &lt; kMaxSignificantDecimalDigits - 1; ++i) {</span>
<span class="udiff-line-modified-added">+     significant_buffer[i] = buffer[i];</span>
<span class="udiff-line-modified-added">+   }</span>
<span class="udiff-line-modified-added">+   // The input buffer has been trimmed. Therefore the last digit must be</span>
<span class="udiff-line-modified-added">+   // different from &#39;0&#39;.</span>
<span class="udiff-line-modified-added">+   ASSERT(buffer[buffer.length() - 1] != &#39;0&#39;);</span>
<span class="udiff-line-modified-added">+   // Set the last digit to be non-zero. This is sufficient to guarantee</span>
<span class="udiff-line-modified-added">+   // correct rounding.</span>
<span class="udiff-line-modified-added">+   significant_buffer[kMaxSignificantDecimalDigits - 1] = &#39;1&#39;;</span>
<span class="udiff-line-modified-added">+   *significant_exponent =</span>
<span class="udiff-line-modified-added">+       exponent + (buffer.length() - kMaxSignificantDecimalDigits);</span>
  }
  
  
  // Trims the buffer and cuts it to at most kMaxSignificantDecimalDigits.
  // If possible the input-buffer is reused, but if the buffer needs to be
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -151,280 +151,280 @@</span>
      *trimmed = BufferReference&lt;const char&gt;(buffer_copy_space,
                                   kMaxSignificantDecimalDigits);
    } else {
      *trimmed = right_trimmed;
      *updated_exponent = exponent;
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+   }</span>
  }
<span class="udiff-line-modified-removed">-     </span>
<span class="udiff-line-modified-added">+ </span>
  
  // Reads digits from the buffer and converts them to a uint64.
  // Reads in as many digits as fit into a uint64.
  // When the string starts with &quot;1844674407370955161&quot; no further digit is read.
  // Since 2^64 = 18446744073709551616 it would still be possible read another
  // digit if it was less or equal than 6, but this would complicate the code.
  static uint64_t ReadUint64(BufferReference&lt;const char&gt; buffer,
<span class="udiff-line-modified-removed">-                                int* number_of_read_digits) {</span>
<span class="udiff-line-modified-removed">-         uint64_t result = 0;</span>
<span class="udiff-line-modified-removed">-         int i = 0;</span>
<span class="udiff-line-modified-removed">-         while (i &lt; buffer.length() &amp;&amp; result &lt;= (kMaxUint64 / 10 - 1)) {</span>
<span class="udiff-line-modified-removed">-             int digit = buffer[i++] - &#39;0&#39;;</span>
<span class="udiff-line-modified-removed">-             ASSERT(0 &lt;= digit &amp;&amp; digit &lt;= 9);</span>
<span class="udiff-line-modified-removed">-             result = 10 * result + digit;</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-removed">-         *number_of_read_digits = i;</span>
<span class="udiff-line-modified-removed">-         return result;</span>
<span class="udiff-line-modified-added">+                            int* number_of_read_digits) {</span>
<span class="udiff-line-modified-added">+   uint64_t result = 0;</span>
<span class="udiff-line-modified-added">+   int i = 0;</span>
<span class="udiff-line-modified-added">+   while (i &lt; buffer.length() &amp;&amp; result &lt;= (kMaxUint64 / 10 - 1)) {</span>
<span class="udiff-line-modified-added">+     int digit = buffer[i++] - &#39;0&#39;;</span>
<span class="udiff-line-modified-added">+     ASSERT(0 &lt;= digit &amp;&amp; digit &lt;= 9);</span>
<span class="udiff-line-modified-added">+     result = 10 * result + digit;</span>
<span class="udiff-line-modified-added">+   }</span>
<span class="udiff-line-modified-added">+   *number_of_read_digits = i;</span>
<span class="udiff-line-modified-added">+   return result;</span>
  }
<span class="udiff-line-modified-removed">-     </span>
<span class="udiff-line-modified-removed">-     </span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+ </span>
  // Reads a DiyFp from the buffer.
  // The returned DiyFp is not necessarily normalized.
  // If remaining_decimals is zero then the returned DiyFp is accurate.
  // Otherwise it has been rounded and has error of at most 1/2 ulp.
  static void ReadDiyFp(BufferReference&lt;const char&gt; buffer,
<span class="udiff-line-modified-removed">-                           DiyFp* result,</span>
<span class="udiff-line-modified-removed">-                           int* remaining_decimals) {</span>
<span class="udiff-line-modified-removed">-         int read_digits;</span>
<span class="udiff-line-modified-removed">-         uint64_t significand = ReadUint64(buffer, &amp;read_digits);</span>
<span class="udiff-line-modified-removed">-         if (buffer.length() == read_digits) {</span>
<span class="udiff-line-modified-removed">-             *result = DiyFp(significand, 0);</span>
<span class="udiff-line-modified-removed">-             *remaining_decimals = 0;</span>
<span class="udiff-line-modified-removed">-         } else {</span>
<span class="udiff-line-modified-removed">-             // Round the significand.</span>
<span class="udiff-line-modified-removed">-             if (buffer[read_digits] &gt;= &#39;5&#39;) {</span>
<span class="udiff-line-modified-removed">-                 significand++;</span>
<span class="udiff-line-modified-removed">-             }</span>
<span class="udiff-line-modified-removed">-             // Compute the binary exponent.</span>
<span class="udiff-line-modified-removed">-             int exponent = 0;</span>
<span class="udiff-line-modified-removed">-             *result = DiyFp(significand, exponent);</span>
<span class="udiff-line-modified-removed">-             *remaining_decimals = buffer.length() - read_digits;</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-added">+                       DiyFp* result,</span>
<span class="udiff-line-modified-added">+                       int* remaining_decimals) {</span>
<span class="udiff-line-modified-added">+   int read_digits;</span>
<span class="udiff-line-modified-added">+   uint64_t significand = ReadUint64(buffer, &amp;read_digits);</span>
<span class="udiff-line-modified-added">+   if (buffer.length() == read_digits) {</span>
<span class="udiff-line-modified-added">+     *result = DiyFp(significand, 0);</span>
<span class="udiff-line-modified-added">+     *remaining_decimals = 0;</span>
<span class="udiff-line-modified-added">+   } else {</span>
<span class="udiff-line-modified-added">+     // Round the significand.</span>
<span class="udiff-line-modified-added">+     if (buffer[read_digits] &gt;= &#39;5&#39;) {</span>
<span class="udiff-line-modified-added">+       significand++;</span>
<span class="udiff-line-modified-added">+     }</span>
<span class="udiff-line-modified-added">+     // Compute the binary exponent.</span>
<span class="udiff-line-modified-added">+     int exponent = 0;</span>
<span class="udiff-line-modified-added">+     *result = DiyFp(significand, exponent);</span>
<span class="udiff-line-modified-added">+     *remaining_decimals = buffer.length() - read_digits;</span>
<span class="udiff-line-modified-added">+   }</span>
  }
<span class="udiff-line-modified-removed">-     </span>
<span class="udiff-line-modified-removed">-     </span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+ </span>
  static bool DoubleStrtod(BufferReference&lt;const char&gt; trimmed,
<span class="udiff-line-modified-removed">-                              int exponent,</span>
<span class="udiff-line-modified-removed">-                              double* result) {</span>
<span class="udiff-line-modified-added">+                          int exponent,</span>
<span class="udiff-line-modified-added">+                          double* result) {</span>
  #if !defined(DOUBLE_CONVERSION_CORRECT_DOUBLE_OPERATIONS)
<span class="udiff-line-modified-removed">-         UNUSED_PARAM(trimmed);</span>
<span class="udiff-line-modified-removed">-         UNUSED_PARAM(exponent);</span>
<span class="udiff-line-modified-removed">-         UNUSED_PARAM(result);</span>
<span class="udiff-line-modified-removed">-         // On x86 the floating-point stack can be 64 or 80 bits wide. If it is</span>
<span class="udiff-line-modified-removed">-         // 80 bits wide (as is the case on Linux) then double-rounding occurs and the</span>
<span class="udiff-line-modified-removed">-         // result is not accurate.</span>
<span class="udiff-line-modified-removed">-         // We know that Windows32 uses 64 bits and is therefore accurate.</span>
<span class="udiff-line-modified-removed">-         // Note that the ARM simulator is compiled for 32bits. It therefore exhibits</span>
<span class="udiff-line-modified-removed">-         // the same problem.</span>
<span class="udiff-line-modified-removed">-         return false;</span>
<span class="udiff-line-modified-added">+   UNUSED_PARAM(trimmed);</span>
<span class="udiff-line-modified-added">+   UNUSED_PARAM(exponent);</span>
<span class="udiff-line-modified-added">+   UNUSED_PARAM(result);</span>
<span class="udiff-line-modified-added">+   // On x86 the floating-point stack can be 64 or 80 bits wide. If it is</span>
<span class="udiff-line-modified-added">+   // 80 bits wide (as is the case on Linux) then double-rounding occurs and the</span>
<span class="udiff-line-modified-added">+   // result is not accurate.</span>
<span class="udiff-line-modified-added">+   // We know that Windows32 uses 64 bits and is therefore accurate.</span>
<span class="udiff-line-modified-added">+   // Note that the ARM simulator is compiled for 32bits. It therefore exhibits</span>
<span class="udiff-line-modified-added">+   // the same problem.</span>
<span class="udiff-line-modified-added">+   return false;</span>
  #else
<span class="udiff-line-modified-removed">-         if (trimmed.length() &lt;= kMaxExactDoubleIntegerDecimalDigits) {</span>
<span class="udiff-line-modified-removed">-             int read_digits;</span>
<span class="udiff-line-modified-removed">-             // The trimmed input fits into a double.</span>
<span class="udiff-line-modified-removed">-             // If the 10^exponent (resp. 10^-exponent) fits into a double too then we</span>
<span class="udiff-line-modified-removed">-             // can compute the result-double simply by multiplying (resp. dividing) the</span>
<span class="udiff-line-modified-removed">-             // two numbers.</span>
<span class="udiff-line-modified-removed">-             // This is possible because IEEE guarantees that floating-point operations</span>
<span class="udiff-line-modified-removed">-             // return the best possible approximation.</span>
<span class="udiff-line-modified-removed">-             if (exponent &lt; 0 &amp;&amp; -exponent &lt; kExactPowersOfTenSize) {</span>
<span class="udiff-line-modified-removed">-                 // 10^-exponent fits into a double.</span>
<span class="udiff-line-modified-removed">-                 *result = static_cast&lt;double&gt;(ReadUint64(trimmed, &amp;read_digits));</span>
<span class="udiff-line-modified-removed">-                 ASSERT(read_digits == trimmed.length());</span>
<span class="udiff-line-modified-removed">-                 *result /= exact_powers_of_ten[-exponent];</span>
<span class="udiff-line-modified-removed">-                 return true;</span>
<span class="udiff-line-modified-removed">-             }</span>
<span class="udiff-line-modified-removed">-             if (0 &lt;= exponent &amp;&amp; exponent &lt; kExactPowersOfTenSize) {</span>
<span class="udiff-line-modified-removed">-                 // 10^exponent fits into a double.</span>
<span class="udiff-line-modified-removed">-                 *result = static_cast&lt;double&gt;(ReadUint64(trimmed, &amp;read_digits));</span>
<span class="udiff-line-modified-removed">-                 ASSERT(read_digits == trimmed.length());</span>
<span class="udiff-line-modified-removed">-                 *result *= exact_powers_of_ten[exponent];</span>
<span class="udiff-line-modified-removed">-                 return true;</span>
<span class="udiff-line-modified-removed">-             }</span>
<span class="udiff-line-modified-removed">-             int remaining_digits =</span>
<span class="udiff-line-modified-removed">-             kMaxExactDoubleIntegerDecimalDigits - trimmed.length();</span>
<span class="udiff-line-modified-removed">-             if ((0 &lt;= exponent) &amp;&amp;</span>
<span class="udiff-line-modified-removed">-                 (exponent - remaining_digits &lt; kExactPowersOfTenSize)) {</span>
<span class="udiff-line-modified-removed">-                 // The trimmed string was short and we can multiply it with</span>
<span class="udiff-line-modified-removed">-                 // 10^remaining_digits. As a result the remaining exponent now fits</span>
<span class="udiff-line-modified-removed">-                 // into a double too.</span>
<span class="udiff-line-modified-removed">-                 *result = static_cast&lt;double&gt;(ReadUint64(trimmed, &amp;read_digits));</span>
<span class="udiff-line-modified-removed">-                 ASSERT(read_digits == trimmed.length());</span>
<span class="udiff-line-modified-removed">-                 *result *= exact_powers_of_ten[remaining_digits];</span>
<span class="udiff-line-modified-removed">-                 *result *= exact_powers_of_ten[exponent - remaining_digits];</span>
<span class="udiff-line-modified-removed">-                 return true;</span>
<span class="udiff-line-modified-removed">-             }</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-removed">-         return false;</span>
<span class="udiff-line-modified-added">+   if (trimmed.length() &lt;= kMaxExactDoubleIntegerDecimalDigits) {</span>
<span class="udiff-line-modified-added">+     int read_digits;</span>
<span class="udiff-line-modified-added">+     // The trimmed input fits into a double.</span>
<span class="udiff-line-modified-added">+     // If the 10^exponent (resp. 10^-exponent) fits into a double too then we</span>
<span class="udiff-line-modified-added">+     // can compute the result-double simply by multiplying (resp. dividing) the</span>
<span class="udiff-line-modified-added">+     // two numbers.</span>
<span class="udiff-line-modified-added">+     // This is possible because IEEE guarantees that floating-point operations</span>
<span class="udiff-line-modified-added">+     // return the best possible approximation.</span>
<span class="udiff-line-modified-added">+     if (exponent &lt; 0 &amp;&amp; -exponent &lt; kExactPowersOfTenSize) {</span>
<span class="udiff-line-modified-added">+       // 10^-exponent fits into a double.</span>
<span class="udiff-line-modified-added">+       *result = static_cast&lt;double&gt;(ReadUint64(trimmed, &amp;read_digits));</span>
<span class="udiff-line-modified-added">+       ASSERT(read_digits == trimmed.length());</span>
<span class="udiff-line-modified-added">+       *result /= exact_powers_of_ten[-exponent];</span>
<span class="udiff-line-modified-added">+       return true;</span>
<span class="udiff-line-modified-added">+     }</span>
<span class="udiff-line-modified-added">+     if (0 &lt;= exponent &amp;&amp; exponent &lt; kExactPowersOfTenSize) {</span>
<span class="udiff-line-modified-added">+       // 10^exponent fits into a double.</span>
<span class="udiff-line-modified-added">+       *result = static_cast&lt;double&gt;(ReadUint64(trimmed, &amp;read_digits));</span>
<span class="udiff-line-modified-added">+       ASSERT(read_digits == trimmed.length());</span>
<span class="udiff-line-modified-added">+       *result *= exact_powers_of_ten[exponent];</span>
<span class="udiff-line-modified-added">+       return true;</span>
<span class="udiff-line-modified-added">+     }</span>
<span class="udiff-line-modified-added">+     int remaining_digits =</span>
<span class="udiff-line-modified-added">+         kMaxExactDoubleIntegerDecimalDigits - trimmed.length();</span>
<span class="udiff-line-modified-added">+     if ((0 &lt;= exponent) &amp;&amp;</span>
<span class="udiff-line-modified-added">+         (exponent - remaining_digits &lt; kExactPowersOfTenSize)) {</span>
<span class="udiff-line-modified-added">+       // The trimmed string was short and we can multiply it with</span>
<span class="udiff-line-modified-added">+       // 10^remaining_digits. As a result the remaining exponent now fits</span>
<span class="udiff-line-modified-added">+       // into a double too.</span>
<span class="udiff-line-modified-added">+       *result = static_cast&lt;double&gt;(ReadUint64(trimmed, &amp;read_digits));</span>
<span class="udiff-line-modified-added">+       ASSERT(read_digits == trimmed.length());</span>
<span class="udiff-line-modified-added">+       *result *= exact_powers_of_ten[remaining_digits];</span>
<span class="udiff-line-modified-added">+       *result *= exact_powers_of_ten[exponent - remaining_digits];</span>
<span class="udiff-line-modified-added">+       return true;</span>
<span class="udiff-line-modified-added">+     }</span>
<span class="udiff-line-modified-added">+   }</span>
<span class="udiff-line-modified-added">+   return false;</span>
  #endif
  }
<span class="udiff-line-modified-removed">-     </span>
<span class="udiff-line-modified-removed">-     </span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+ </span>
  // Returns 10^exponent as an exact DiyFp.
  // The given exponent must be in the range [1; kDecimalExponentDistance[.
  static DiyFp AdjustmentPowerOfTen(int exponent) {
<span class="udiff-line-modified-removed">-         ASSERT(0 &lt; exponent);</span>
<span class="udiff-line-modified-removed">-         ASSERT(exponent &lt; PowersOfTenCache::kDecimalExponentDistance);</span>
<span class="udiff-line-modified-removed">-         // Simply hardcode the remaining powers for the given decimal exponent</span>
<span class="udiff-line-modified-removed">-         // distance.</span>
<span class="udiff-line-modified-removed">-         ASSERT(PowersOfTenCache::kDecimalExponentDistance == 8);</span>
<span class="udiff-line-modified-removed">-         switch (exponent) {</span>
<span class="udiff-line-modified-removed">-             case 1: return DiyFp(UINT64_2PART_C(0xa0000000, 00000000), -60);</span>
<span class="udiff-line-modified-removed">-             case 2: return DiyFp(UINT64_2PART_C(0xc8000000, 00000000), -57);</span>
<span class="udiff-line-modified-removed">-             case 3: return DiyFp(UINT64_2PART_C(0xfa000000, 00000000), -54);</span>
<span class="udiff-line-modified-removed">-             case 4: return DiyFp(UINT64_2PART_C(0x9c400000, 00000000), -50);</span>
<span class="udiff-line-modified-removed">-             case 5: return DiyFp(UINT64_2PART_C(0xc3500000, 00000000), -47);</span>
<span class="udiff-line-modified-removed">-             case 6: return DiyFp(UINT64_2PART_C(0xf4240000, 00000000), -44);</span>
<span class="udiff-line-modified-removed">-             case 7: return DiyFp(UINT64_2PART_C(0x98968000, 00000000), -40);</span>
<span class="udiff-line-modified-removed">-             default:</span>
<span class="udiff-line-modified-removed">-                 UNREACHABLE();</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+   ASSERT(0 &lt; exponent);</span>
<span class="udiff-line-modified-added">+   ASSERT(exponent &lt; PowersOfTenCache::kDecimalExponentDistance);</span>
<span class="udiff-line-modified-added">+   // Simply hardcode the remaining powers for the given decimal exponent</span>
<span class="udiff-line-modified-added">+   // distance.</span>
<span class="udiff-line-modified-added">+   ASSERT(PowersOfTenCache::kDecimalExponentDistance == 8);</span>
<span class="udiff-line-modified-added">+   switch (exponent) {</span>
<span class="udiff-line-modified-added">+     case 1: return DiyFp(UINT64_2PART_C(0xa0000000, 00000000), -60);</span>
<span class="udiff-line-modified-added">+     case 2: return DiyFp(UINT64_2PART_C(0xc8000000, 00000000), -57);</span>
<span class="udiff-line-modified-added">+     case 3: return DiyFp(UINT64_2PART_C(0xfa000000, 00000000), -54);</span>
<span class="udiff-line-modified-added">+     case 4: return DiyFp(UINT64_2PART_C(0x9c400000, 00000000), -50);</span>
<span class="udiff-line-modified-added">+     case 5: return DiyFp(UINT64_2PART_C(0xc3500000, 00000000), -47);</span>
<span class="udiff-line-modified-added">+     case 6: return DiyFp(UINT64_2PART_C(0xf4240000, 00000000), -44);</span>
<span class="udiff-line-modified-added">+     case 7: return DiyFp(UINT64_2PART_C(0x98968000, 00000000), -40);</span>
<span class="udiff-line-modified-added">+     default:</span>
<span class="udiff-line-modified-added">+       UNREACHABLE();</span>
<span class="udiff-line-modified-added">+   }</span>
  }
<span class="udiff-line-modified-removed">-     </span>
<span class="udiff-line-modified-removed">-     </span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+ </span>
  // If the function returns true then the result is the correct double.
  // Otherwise it is either the correct double or the double that is just below
  // the correct double.
  static bool DiyFpStrtod(BufferReference&lt;const char&gt; buffer,
<span class="udiff-line-modified-removed">-                             int exponent,</span>
<span class="udiff-line-modified-removed">-                             double* result) {</span>
<span class="udiff-line-modified-removed">-         DiyFp input;</span>
<span class="udiff-line-modified-removed">-         int remaining_decimals;</span>
<span class="udiff-line-modified-removed">-         ReadDiyFp(buffer, &amp;input, &amp;remaining_decimals);</span>
<span class="udiff-line-modified-removed">-         // Since we may have dropped some digits the input is not accurate.</span>
<span class="udiff-line-modified-removed">-         // If remaining_decimals is different than 0 than the error is at most</span>
<span class="udiff-line-modified-removed">-         // .5 ulp (unit in the last place).</span>
<span class="udiff-line-modified-removed">-         // We don&#39;t want to deal with fractions and therefore keep a common</span>
<span class="udiff-line-modified-removed">-         // denominator.</span>
<span class="udiff-line-modified-removed">-         const int kDenominatorLog = 3;</span>
<span class="udiff-line-modified-removed">-         const int kDenominator = 1 &lt;&lt; kDenominatorLog;</span>
<span class="udiff-line-modified-removed">-         // Move the remaining decimals into the exponent.</span>
<span class="udiff-line-modified-removed">-         exponent += remaining_decimals;</span>
<span class="udiff-line-modified-added">+                         int exponent,</span>
<span class="udiff-line-modified-added">+                         double* result) {</span>
<span class="udiff-line-modified-added">+   DiyFp input;</span>
<span class="udiff-line-modified-added">+   int remaining_decimals;</span>
<span class="udiff-line-modified-added">+   ReadDiyFp(buffer, &amp;input, &amp;remaining_decimals);</span>
<span class="udiff-line-modified-added">+   // Since we may have dropped some digits the input is not accurate.</span>
<span class="udiff-line-modified-added">+   // If remaining_decimals is different than 0 than the error is at most</span>
<span class="udiff-line-modified-added">+   // .5 ulp (unit in the last place).</span>
<span class="udiff-line-modified-added">+   // We don&#39;t want to deal with fractions and therefore keep a common</span>
<span class="udiff-line-modified-added">+   // denominator.</span>
<span class="udiff-line-modified-added">+   const int kDenominatorLog = 3;</span>
<span class="udiff-line-modified-added">+   const int kDenominator = 1 &lt;&lt; kDenominatorLog;</span>
<span class="udiff-line-modified-added">+   // Move the remaining decimals into the exponent.</span>
<span class="udiff-line-modified-added">+   exponent += remaining_decimals;</span>
    uint64_t error = (remaining_decimals == 0 ? 0 : kDenominator / 2);
<span class="udiff-line-modified-removed">-         </span>
<span class="udiff-line-modified-removed">-         int old_e = input.e();</span>
<span class="udiff-line-modified-removed">-         input.Normalize();</span>
<span class="udiff-line-modified-removed">-         error &lt;&lt;= old_e - input.e();</span>
<span class="udiff-line-modified-removed">-         </span>
<span class="udiff-line-modified-removed">-         ASSERT(exponent &lt;= PowersOfTenCache::kMaxDecimalExponent);</span>
<span class="udiff-line-modified-removed">-         if (exponent &lt; PowersOfTenCache::kMinDecimalExponent) {</span>
<span class="udiff-line-modified-removed">-             *result = 0.0;</span>
<span class="udiff-line-modified-removed">-             return true;</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-removed">-         DiyFp cached_power;</span>
<span class="udiff-line-modified-removed">-         int cached_decimal_exponent;</span>
<span class="udiff-line-modified-removed">-         PowersOfTenCache::GetCachedPowerForDecimalExponent(exponent,</span>
<span class="udiff-line-modified-removed">-                                                            &amp;cached_power,</span>
<span class="udiff-line-modified-removed">-                                                            &amp;cached_decimal_exponent);</span>
<span class="udiff-line-modified-removed">-         </span>
<span class="udiff-line-modified-removed">-         if (cached_decimal_exponent != exponent) {</span>
<span class="udiff-line-modified-removed">-             int adjustment_exponent = exponent - cached_decimal_exponent;</span>
<span class="udiff-line-modified-removed">-             DiyFp adjustment_power = AdjustmentPowerOfTen(adjustment_exponent);</span>
<span class="udiff-line-modified-removed">-             input.Multiply(adjustment_power);</span>
<span class="udiff-line-modified-removed">-             if (kMaxUint64DecimalDigits - buffer.length() &gt;= adjustment_exponent) {</span>
<span class="udiff-line-modified-removed">-                 // The product of input with the adjustment power fits into a 64 bit</span>
<span class="udiff-line-modified-removed">-                 // integer.</span>
<span class="udiff-line-modified-removed">-                 ASSERT(DiyFp::kSignificandSize == 64);</span>
<span class="udiff-line-modified-removed">-             } else {</span>
<span class="udiff-line-modified-removed">-                 // The adjustment power is exact. There is hence only an error of 0.5.</span>
<span class="udiff-line-modified-removed">-                 error += kDenominator / 2;</span>
<span class="udiff-line-modified-removed">-             }</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-removed">-         </span>
<span class="udiff-line-modified-removed">-         input.Multiply(cached_power);</span>
<span class="udiff-line-modified-removed">-         // The error introduced by a multiplication of a*b equals</span>
<span class="udiff-line-modified-removed">-         //   error_a + error_b + error_a*error_b/2^64 + 0.5</span>
<span class="udiff-line-modified-removed">-         // Substituting a with &#39;input&#39; and b with &#39;cached_power&#39; we have</span>
<span class="udiff-line-modified-removed">-         //   error_b = 0.5  (all cached powers have an error of less than 0.5 ulp),</span>
<span class="udiff-line-modified-removed">-         //   error_ab = 0 or 1 / kDenominator &gt; error_a*error_b/ 2^64</span>
<span class="udiff-line-modified-removed">-         int error_b = kDenominator / 2;</span>
<span class="udiff-line-modified-removed">-         int error_ab = (error == 0 ? 0 : 1);  // We round up to 1.</span>
<span class="udiff-line-modified-removed">-         int fixed_error = kDenominator / 2;</span>
<span class="udiff-line-modified-removed">-         error += error_b + error_ab + fixed_error;</span>
<span class="udiff-line-modified-removed">-         </span>
<span class="udiff-line-modified-removed">-         old_e = input.e();</span>
<span class="udiff-line-modified-removed">-         input.Normalize();</span>
<span class="udiff-line-modified-removed">-         error &lt;&lt;= old_e - input.e();</span>
<span class="udiff-line-modified-removed">-         </span>
<span class="udiff-line-modified-removed">-         // See if the double&#39;s significand changes if we add/subtract the error.</span>
<span class="udiff-line-modified-removed">-         int order_of_magnitude = DiyFp::kSignificandSize + input.e();</span>
<span class="udiff-line-modified-removed">-         int effective_significand_size =</span>
<span class="udiff-line-modified-removed">-         Double::SignificandSizeForOrderOfMagnitude(order_of_magnitude);</span>
<span class="udiff-line-modified-removed">-         int precision_digits_count =</span>
<span class="udiff-line-modified-removed">-         DiyFp::kSignificandSize - effective_significand_size;</span>
<span class="udiff-line-modified-removed">-         if (precision_digits_count + kDenominatorLog &gt;= DiyFp::kSignificandSize) {</span>
<span class="udiff-line-modified-removed">-             // This can only happen for very small denormals. In this case the</span>
<span class="udiff-line-modified-removed">-             // half-way multiplied by the denominator exceeds the range of an uint64.</span>
<span class="udiff-line-modified-removed">-             // Simply shift everything to the right.</span>
<span class="udiff-line-modified-removed">-             int shift_amount = (precision_digits_count + kDenominatorLog) -</span>
<span class="udiff-line-modified-removed">-             DiyFp::kSignificandSize + 1;</span>
<span class="udiff-line-modified-removed">-             input.set_f(input.f() &gt;&gt; shift_amount);</span>
<span class="udiff-line-modified-removed">-             input.set_e(input.e() + shift_amount);</span>
<span class="udiff-line-modified-removed">-             // We add 1 for the lost precision of error, and kDenominator for</span>
<span class="udiff-line-modified-removed">-             // the lost precision of input.f().</span>
<span class="udiff-line-modified-removed">-             error = (error &gt;&gt; shift_amount) + 1 + kDenominator;</span>
<span class="udiff-line-modified-removed">-             precision_digits_count -= shift_amount;</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-removed">-         // We use uint64_ts now. This only works if the DiyFp uses uint64_ts too.</span>
<span class="udiff-line-modified-removed">-         ASSERT(DiyFp::kSignificandSize == 64);</span>
<span class="udiff-line-modified-removed">-         ASSERT(precision_digits_count &lt; 64);</span>
<span class="udiff-line-modified-removed">-         uint64_t one64 = 1;</span>
<span class="udiff-line-modified-removed">-         uint64_t precision_bits_mask = (one64 &lt;&lt; precision_digits_count) - 1;</span>
<span class="udiff-line-modified-removed">-         uint64_t precision_bits = input.f() &amp; precision_bits_mask;</span>
<span class="udiff-line-modified-removed">-         uint64_t half_way = one64 &lt;&lt; (precision_digits_count - 1);</span>
<span class="udiff-line-modified-removed">-         precision_bits *= kDenominator;</span>
<span class="udiff-line-modified-removed">-         half_way *= kDenominator;</span>
<span class="udiff-line-modified-removed">-         DiyFp rounded_input(input.f() &gt;&gt; precision_digits_count,</span>
<span class="udiff-line-modified-removed">-                             input.e() + precision_digits_count);</span>
<span class="udiff-line-modified-removed">-         if (precision_bits &gt;= half_way + error) {</span>
<span class="udiff-line-modified-removed">-             rounded_input.set_f(rounded_input.f() + 1);</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-removed">-         // If the last_bits are too close to the half-way case than we are too</span>
<span class="udiff-line-modified-removed">-         // inaccurate and round down. In this case we return false so that we can</span>
<span class="udiff-line-modified-removed">-         // fall back to a more precise algorithm.</span>
<span class="udiff-line-modified-removed">-         </span>
<span class="udiff-line-modified-removed">-         *result = Double(rounded_input).value();</span>
<span class="udiff-line-modified-removed">-         if (half_way - error &lt; precision_bits &amp;&amp; precision_bits &lt; half_way + error) {</span>
<span class="udiff-line-modified-removed">-             // Too imprecise. The caller will have to fall back to a slower version.</span>
<span class="udiff-line-modified-removed">-             // However the returned number is guaranteed to be either the correct</span>
<span class="udiff-line-modified-removed">-             // double, or the next-lower double.</span>
<span class="udiff-line-modified-removed">-             return false;</span>
<span class="udiff-line-modified-removed">-         } else {</span>
<span class="udiff-line-modified-removed">-             return true;</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   int old_e = input.e();</span>
<span class="udiff-line-modified-added">+   input.Normalize();</span>
<span class="udiff-line-modified-added">+   error &lt;&lt;= old_e - input.e();</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   ASSERT(exponent &lt;= PowersOfTenCache::kMaxDecimalExponent);</span>
<span class="udiff-line-modified-added">+   if (exponent &lt; PowersOfTenCache::kMinDecimalExponent) {</span>
<span class="udiff-line-modified-added">+     *result = 0.0;</span>
<span class="udiff-line-modified-added">+     return true;</span>
<span class="udiff-line-modified-added">+   }</span>
<span class="udiff-line-modified-added">+   DiyFp cached_power;</span>
<span class="udiff-line-modified-added">+   int cached_decimal_exponent;</span>
<span class="udiff-line-modified-added">+   PowersOfTenCache::GetCachedPowerForDecimalExponent(exponent,</span>
<span class="udiff-line-modified-added">+                                                      &amp;cached_power,</span>
<span class="udiff-line-modified-added">+                                                      &amp;cached_decimal_exponent);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   if (cached_decimal_exponent != exponent) {</span>
<span class="udiff-line-modified-added">+     int adjustment_exponent = exponent - cached_decimal_exponent;</span>
<span class="udiff-line-modified-added">+     DiyFp adjustment_power = AdjustmentPowerOfTen(adjustment_exponent);</span>
<span class="udiff-line-modified-added">+     input.Multiply(adjustment_power);</span>
<span class="udiff-line-modified-added">+     if (kMaxUint64DecimalDigits - buffer.length() &gt;= adjustment_exponent) {</span>
<span class="udiff-line-modified-added">+       // The product of input with the adjustment power fits into a 64 bit</span>
<span class="udiff-line-modified-added">+       // integer.</span>
<span class="udiff-line-modified-added">+       ASSERT(DiyFp::kSignificandSize == 64);</span>
<span class="udiff-line-modified-added">+     } else {</span>
<span class="udiff-line-modified-added">+       // The adjustment power is exact. There is hence only an error of 0.5.</span>
<span class="udiff-line-modified-added">+       error += kDenominator / 2;</span>
<span class="udiff-line-modified-added">+     }</span>
<span class="udiff-line-modified-added">+   }</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   input.Multiply(cached_power);</span>
<span class="udiff-line-modified-added">+   // The error introduced by a multiplication of a*b equals</span>
<span class="udiff-line-modified-added">+   //   error_a + error_b + error_a*error_b/2^64 + 0.5</span>
<span class="udiff-line-modified-added">+   // Substituting a with &#39;input&#39; and b with &#39;cached_power&#39; we have</span>
<span class="udiff-line-modified-added">+   //   error_b = 0.5  (all cached powers have an error of less than 0.5 ulp),</span>
<span class="udiff-line-modified-added">+   //   error_ab = 0 or 1 / kDenominator &gt; error_a*error_b/ 2^64</span>
<span class="udiff-line-modified-added">+   int error_b = kDenominator / 2;</span>
<span class="udiff-line-modified-added">+   int error_ab = (error == 0 ? 0 : 1);  // We round up to 1.</span>
<span class="udiff-line-modified-added">+   int fixed_error = kDenominator / 2;</span>
<span class="udiff-line-modified-added">+   error += error_b + error_ab + fixed_error;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   old_e = input.e();</span>
<span class="udiff-line-modified-added">+   input.Normalize();</span>
<span class="udiff-line-modified-added">+   error &lt;&lt;= old_e - input.e();</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   // See if the double&#39;s significand changes if we add/subtract the error.</span>
<span class="udiff-line-modified-added">+   int order_of_magnitude = DiyFp::kSignificandSize + input.e();</span>
<span class="udiff-line-modified-added">+   int effective_significand_size =</span>
<span class="udiff-line-modified-added">+       Double::SignificandSizeForOrderOfMagnitude(order_of_magnitude);</span>
<span class="udiff-line-modified-added">+   int precision_digits_count =</span>
<span class="udiff-line-modified-added">+       DiyFp::kSignificandSize - effective_significand_size;</span>
<span class="udiff-line-modified-added">+   if (precision_digits_count + kDenominatorLog &gt;= DiyFp::kSignificandSize) {</span>
<span class="udiff-line-modified-added">+     // This can only happen for very small denormals. In this case the</span>
<span class="udiff-line-modified-added">+     // half-way multiplied by the denominator exceeds the range of an uint64.</span>
<span class="udiff-line-modified-added">+     // Simply shift everything to the right.</span>
<span class="udiff-line-modified-added">+     int shift_amount = (precision_digits_count + kDenominatorLog) -</span>
<span class="udiff-line-modified-added">+         DiyFp::kSignificandSize + 1;</span>
<span class="udiff-line-modified-added">+     input.set_f(input.f() &gt;&gt; shift_amount);</span>
<span class="udiff-line-modified-added">+     input.set_e(input.e() + shift_amount);</span>
<span class="udiff-line-modified-added">+     // We add 1 for the lost precision of error, and kDenominator for</span>
<span class="udiff-line-modified-added">+     // the lost precision of input.f().</span>
<span class="udiff-line-modified-added">+     error = (error &gt;&gt; shift_amount) + 1 + kDenominator;</span>
<span class="udiff-line-modified-added">+     precision_digits_count -= shift_amount;</span>
<span class="udiff-line-modified-added">+   }</span>
<span class="udiff-line-modified-added">+   // We use uint64_ts now. This only works if the DiyFp uses uint64_ts too.</span>
<span class="udiff-line-modified-added">+   ASSERT(DiyFp::kSignificandSize == 64);</span>
<span class="udiff-line-modified-added">+   ASSERT(precision_digits_count &lt; 64);</span>
<span class="udiff-line-modified-added">+   uint64_t one64 = 1;</span>
<span class="udiff-line-modified-added">+   uint64_t precision_bits_mask = (one64 &lt;&lt; precision_digits_count) - 1;</span>
<span class="udiff-line-modified-added">+   uint64_t precision_bits = input.f() &amp; precision_bits_mask;</span>
<span class="udiff-line-modified-added">+   uint64_t half_way = one64 &lt;&lt; (precision_digits_count - 1);</span>
<span class="udiff-line-modified-added">+   precision_bits *= kDenominator;</span>
<span class="udiff-line-modified-added">+   half_way *= kDenominator;</span>
<span class="udiff-line-modified-added">+   DiyFp rounded_input(input.f() &gt;&gt; precision_digits_count,</span>
<span class="udiff-line-modified-added">+                       input.e() + precision_digits_count);</span>
<span class="udiff-line-modified-added">+   if (precision_bits &gt;= half_way + error) {</span>
<span class="udiff-line-modified-added">+     rounded_input.set_f(rounded_input.f() + 1);</span>
<span class="udiff-line-modified-added">+   }</span>
<span class="udiff-line-modified-added">+   // If the last_bits are too close to the half-way case than we are too</span>
<span class="udiff-line-modified-added">+   // inaccurate and round down. In this case we return false so that we can</span>
<span class="udiff-line-modified-added">+   // fall back to a more precise algorithm.</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   *result = Double(rounded_input).value();</span>
<span class="udiff-line-modified-added">+   if (half_way - error &lt; precision_bits &amp;&amp; precision_bits &lt; half_way + error) {</span>
<span class="udiff-line-modified-added">+     // Too imprecise. The caller will have to fall back to a slower version.</span>
<span class="udiff-line-modified-added">+     // However the returned number is guaranteed to be either the correct</span>
<span class="udiff-line-modified-added">+     // double, or the next-lower double.</span>
<span class="udiff-line-modified-added">+     return false;</span>
<span class="udiff-line-modified-added">+   } else {</span>
<span class="udiff-line-modified-added">+     return true;</span>
<span class="udiff-line-modified-added">+   }</span>
  }
<span class="udiff-line-modified-removed">-     </span>
<span class="udiff-line-modified-removed">-     </span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+ </span>
  // Returns
  //   - -1 if buffer*10^exponent &lt; diy_fp.
  //   -  0 if buffer*10^exponent == diy_fp.
  //   - +1 if buffer*10^exponent &gt; diy_fp.
  // Preconditions:
  //   buffer.length() + exponent &lt;= kMaxDecimalPower + 1
  //   buffer.length() + exponent &gt; kMinDecimalPower
  //   buffer.length() &lt;= kMaxDecimalSignificantDigits
  static int CompareBufferWithDiyFp(BufferReference&lt;const char&gt; buffer,
<span class="udiff-line-modified-removed">-                                int exponent,</span>
<span class="udiff-line-modified-added">+                                   int exponent,</span>
                                    DiyFp diy_fp) {
<span class="udiff-line-modified-removed">-         ASSERT(buffer.length() + exponent &lt;= kMaxDecimalPower + 1);</span>
<span class="udiff-line-modified-removed">-         ASSERT(buffer.length() + exponent &gt; kMinDecimalPower);</span>
<span class="udiff-line-modified-removed">-         ASSERT(buffer.length() &lt;= kMaxSignificantDecimalDigits);</span>
<span class="udiff-line-modified-removed">-         // Make sure that the Bignum will be able to hold all our numbers.</span>
<span class="udiff-line-modified-removed">-         // Our Bignum implementation has a separate field for exponents. Shifts will</span>
<span class="udiff-line-modified-removed">-         // consume at most one bigit (&lt; 64 bits).</span>
<span class="udiff-line-modified-removed">-         // ln(10) == 3.3219...</span>
<span class="udiff-line-modified-removed">-         ASSERT(((kMaxDecimalPower + 1) * 333 / 100) &lt; Bignum::kMaxSignificantBits);</span>
<span class="udiff-line-modified-added">+   ASSERT(buffer.length() + exponent &lt;= kMaxDecimalPower + 1);</span>
<span class="udiff-line-modified-added">+   ASSERT(buffer.length() + exponent &gt; kMinDecimalPower);</span>
<span class="udiff-line-modified-added">+   ASSERT(buffer.length() &lt;= kMaxSignificantDecimalDigits);</span>
<span class="udiff-line-modified-added">+   // Make sure that the Bignum will be able to hold all our numbers.</span>
<span class="udiff-line-modified-added">+   // Our Bignum implementation has a separate field for exponents. Shifts will</span>
<span class="udiff-line-modified-added">+   // consume at most one bigit (&lt; 64 bits).</span>
<span class="udiff-line-modified-added">+   // ln(10) == 3.3219...</span>
<span class="udiff-line-modified-added">+   ASSERT(((kMaxDecimalPower + 1) * 333 / 100) &lt; Bignum::kMaxSignificantBits);</span>
    Bignum buffer_bignum;
    Bignum diy_fp_bignum;
    buffer_bignum.AssignDecimalString(buffer);
    diy_fp_bignum.AssignUInt64(diy_fp.f());
<span class="udiff-line-modified-removed">-         if (exponent &gt;= 0) {</span>
<span class="udiff-line-modified-added">+   if (exponent &gt;= 0) {</span>
      buffer_bignum.MultiplyByPowerOfTen(exponent);
<span class="udiff-line-modified-removed">-         } else {</span>
<span class="udiff-line-modified-added">+   } else {</span>
      diy_fp_bignum.MultiplyByPowerOfTen(-exponent);
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-added">+   }</span>
    if (diy_fp.e() &gt; 0) {
      diy_fp_bignum.ShiftLeft(diy_fp.e());
<span class="udiff-line-modified-removed">-         } else {</span>
<span class="udiff-line-modified-added">+   } else {</span>
      buffer_bignum.ShiftLeft(-diy_fp.e());
    }
    return Bignum::Compare(buffer_bignum, diy_fp_bignum);
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -434,11 +434,11 @@</span>
  static bool ComputeGuess(BufferReference&lt;const char&gt; trimmed, int exponent,
                           double* guess) {
    if (trimmed.length() == 0) {
      *guess = 0.0;
      return true;
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-added">+   }</span>
    if (exponent + trimmed.length() - 1 &gt;= kMaxDecimalPower) {
      *guess = Double::Infinity();
      return true;
    }
    if (exponent + trimmed.length() &lt;= kMinDecimalPower) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -468,22 +468,22 @@</span>
    bool is_correct = ComputeGuess(trimmed, exponent, &amp;guess);
    if (is_correct) return guess;
  
    DiyFp upper_boundary = Double(guess).UpperBoundary();
    int comparison = CompareBufferWithDiyFp(trimmed, exponent, upper_boundary);
<span class="udiff-line-modified-removed">-         if (comparison &lt; 0) {</span>
<span class="udiff-line-modified-removed">-             return guess;</span>
<span class="udiff-line-modified-removed">-         } else if (comparison &gt; 0) {</span>
<span class="udiff-line-modified-removed">-             return Double(guess).NextDouble();</span>
<span class="udiff-line-modified-removed">-         } else if ((Double(guess).Significand() &amp; 1) == 0) {</span>
<span class="udiff-line-modified-removed">-             // Round towards even.</span>
<span class="udiff-line-modified-removed">-             return guess;</span>
<span class="udiff-line-modified-removed">-         } else {</span>
<span class="udiff-line-modified-removed">-             return Double(guess).NextDouble();</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-added">+   if (comparison &lt; 0) {</span>
<span class="udiff-line-modified-added">+     return guess;</span>
<span class="udiff-line-modified-added">+   } else if (comparison &gt; 0) {</span>
<span class="udiff-line-modified-added">+     return Double(guess).NextDouble();</span>
<span class="udiff-line-modified-added">+   } else if ((Double(guess).Significand() &amp; 1) == 0) {</span>
<span class="udiff-line-modified-added">+     // Round towards even.</span>
<span class="udiff-line-modified-added">+     return guess;</span>
<span class="udiff-line-modified-added">+   } else {</span>
<span class="udiff-line-modified-added">+     return Double(guess).NextDouble();</span>
<span class="udiff-line-modified-added">+   }</span>
  }
<span class="udiff-line-modified-removed">-     </span>
<span class="udiff-line-modified-added">+ </span>
  static float SanitizedDoubletof(double d) {
    ASSERT(d &gt;= 0.0);
    // ASAN has a sanitize check that disallows casting doubles to floats if
    // they are too big.
    // https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html#available-checks
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -498,14 +498,14 @@</span>
    if (d &gt;= max_finite) {
      if (d &gt;= half_max_finite_infinity) {
        return Single::Infinity();
      } else {
        return max_finite;
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-added">+     }</span>
    } else {
      return static_cast&lt;float&gt;(d);
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-added">+   }</span>
  }
  
  float Strtof(BufferReference&lt;const char&gt; buffer, int exponent) {
    char copy_buffer[kMaxSignificantDecimalDigits];
    BufferReference&lt;const char&gt; trimmed;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -547,14 +547,14 @@</span>
    if (is_correct) {
      f4 = f3;
    } else {
      double double_next2 = Double(double_next).NextDouble();
      f4 = SanitizedDoubletof(double_next2);
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-added">+   }</span>
    (void) f2;  // Mark variable as used.
    ASSERT(f1 &lt;= f2 &amp;&amp; f2 &lt;= f3 &amp;&amp; f3 &lt;= f4);
<span class="udiff-line-modified-removed">-         </span>
<span class="udiff-line-modified-added">+ </span>
    // If the guess doesn&#39;t lie near a single-precision boundary we can simply
    // return its float-value.
    if (f1 == f4) {
      return float_guess;
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -571,21 +571,21 @@</span>
    if (guess == 0.0f) {
      float min_float = 1e-45f;
      upper_boundary = Double(static_cast&lt;double&gt;(min_float) / 2).AsDiyFp();
    } else {
      upper_boundary = Single(guess).UpperBoundary();
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-added">+   }</span>
    int comparison = CompareBufferWithDiyFp(trimmed, exponent, upper_boundary);
    if (comparison &lt; 0) {
      return guess;
    } else if (comparison &gt; 0) {
      return next;
    } else if ((Single(guess).Significand() &amp; 1) == 0) {
      // Round towards even.
      return guess;
    } else {
      return next;
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+   }</span>
  }
<span class="udiff-line-modified-removed">-     </span>
<span class="udiff-line-modified-added">+ </span>
  }  // namespace double_conversion
<span class="udiff-line-modified-removed">- } // namespace WTF</span>
<span class="udiff-line-modified-added">+ }  // namespace WTF</span>
</pre>
<center><a href="fixed-dtoa.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="strtod.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>