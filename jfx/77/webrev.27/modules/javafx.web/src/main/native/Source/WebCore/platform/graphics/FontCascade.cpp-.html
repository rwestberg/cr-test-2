<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/FontCascade.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
   3  *           (C) 1999 Antti Koivisto (koivisto@kde.org)
   4  *           (C) 2000 Dirk Mueller (mueller@kde.org)
   5  * Copyright (C) 2003-2017 Apple Inc. All rights reserved.
   6  *
   7  * This library is free software; you can redistribute it and/or
   8  * modify it under the terms of the GNU Library General Public
   9  * License as published by the Free Software Foundation; either
  10  * version 2 of the License, or (at your option) any later version.
  11  *
  12  * This library is distributed in the hope that it will be useful,
  13  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  14  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  15  * Library General Public License for more details.
  16  *
  17  * You should have received a copy of the GNU Library General Public License
  18  * along with this library; see the file COPYING.LIB.  If not, write to
  19  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  20  * Boston, MA 02110-1301, USA.
  21  *
  22  */
  23 
  24 #include &quot;config.h&quot;
  25 #include &quot;FontCascade.h&quot;
  26 
  27 #include &quot;CharacterProperties.h&quot;
  28 #include &quot;ComplexTextController.h&quot;
  29 #include &quot;DisplayListRecorder.h&quot;
  30 #include &quot;FloatRect.h&quot;
  31 #include &quot;FontCache.h&quot;
  32 #include &quot;GlyphBuffer.h&quot;
  33 #include &quot;GraphicsContext.h&quot;
  34 #include &quot;LayoutRect.h&quot;
  35 #include &quot;SurrogatePairAwareTextIterator.h&quot;
  36 #include &quot;TextRun.h&quot;
  37 #include &quot;WidthIterator.h&quot;
  38 #include &lt;wtf/MainThread.h&gt;
  39 #include &lt;wtf/MathExtras.h&gt;
  40 #include &lt;wtf/NeverDestroyed.h&gt;
  41 #include &lt;wtf/text/AtomicStringHash.h&gt;
  42 #include &lt;wtf/text/StringBuilder.h&gt;
  43 
  44 #if PLATFORM(WIN)
  45 #include &quot;UniscribeController.h&quot;
  46 #endif
  47 
  48 namespace WebCore {
  49 
  50 using namespace WTF::Unicode;
  51 
  52 static bool useBackslashAsYenSignForFamily(const AtomicString&amp; family)
  53 {
  54     if (family.isEmpty())
  55         return false;
  56     static const auto set = makeNeverDestroyed([] {
  57         HashSet&lt;AtomicString&gt; set;
  58         auto add = [&amp;set] (const char* name, std::initializer_list&lt;UChar&gt; unicodeName) {
  59             unsigned nameLength = strlen(name);
  60             set.add(AtomicString { name, nameLength, AtomicString::ConstructFromLiteral });
  61             unsigned unicodeNameLength = unicodeName.size();
  62             set.add(AtomicString { unicodeName.begin(), unicodeNameLength });
  63         };
  64         add(&quot;MS PGothic&quot;, { 0xFF2D, 0xFF33, 0x0020, 0xFF30, 0x30B4, 0x30B7, 0x30C3, 0x30AF });
  65         add(&quot;MS PMincho&quot;, { 0xFF2D, 0xFF33, 0x0020, 0xFF30, 0x660E, 0x671D });
  66         add(&quot;MS Gothic&quot;, { 0xFF2D, 0xFF33, 0x0020, 0x30B4, 0x30B7, 0x30C3, 0x30AF });
  67         add(&quot;MS Mincho&quot;, { 0xFF2D, 0xFF33, 0x0020, 0x660E, 0x671D });
  68         add(&quot;Meiryo&quot;, { 0x30E1, 0x30A4, 0x30EA, 0x30AA });
  69         return set;
  70     }());
  71     return set.get().contains(family);
  72 }
  73 
  74 FontCascade::CodePath FontCascade::s_codePath = Auto;
  75 
  76 // ============================================================================================
  77 // FontCascade Implementation (Cross-Platform Portion)
  78 // ============================================================================================
  79 
  80 FontCascade::FontCascade()
  81 {
  82 }
  83 
  84 FontCascade::FontCascade(FontCascadeDescription&amp;&amp; fd, float letterSpacing, float wordSpacing)
  85     : m_fontDescription(WTFMove(fd))
  86     , m_letterSpacing(letterSpacing)
  87     , m_wordSpacing(wordSpacing)
  88     , m_useBackslashAsYenSymbol(useBackslashAsYenSignForFamily(m_fontDescription.firstFamily()))
  89     , m_enableKerning(computeEnableKerning())
  90     , m_requiresShaping(computeRequiresShaping())
  91 {
  92 }
  93 
  94 // FIXME: We should make this constructor platform-independent.
  95 FontCascade::FontCascade(const FontPlatformData&amp; fontData, FontSmoothingMode fontSmoothingMode)
  96     : m_fonts(FontCascadeFonts::createForPlatformFont(fontData))
  97     , m_enableKerning(computeEnableKerning())
  98     , m_requiresShaping(computeRequiresShaping())
  99 {
 100     m_fontDescription.setFontSmoothing(fontSmoothingMode);
 101 #if PLATFORM(IOS_FAMILY)
 102     m_fontDescription.setSpecifiedSize(CTFontGetSize(fontData.font()));
 103     m_fontDescription.setComputedSize(CTFontGetSize(fontData.font()));
 104     m_fontDescription.setIsItalic(CTFontGetSymbolicTraits(fontData.font()) &amp; kCTFontTraitItalic);
 105     m_fontDescription.setWeight((CTFontGetSymbolicTraits(fontData.font()) &amp; kCTFontTraitBold) ? boldWeightValue() : normalWeightValue());
 106 #endif
 107 }
 108 
 109 FontCascade::FontCascade(const FontCascade&amp; other)
 110     : m_fontDescription(other.m_fontDescription)
 111     , m_fonts(other.m_fonts)
 112     , m_letterSpacing(other.m_letterSpacing)
 113     , m_wordSpacing(other.m_wordSpacing)
 114     , m_useBackslashAsYenSymbol(other.m_useBackslashAsYenSymbol)
 115     , m_enableKerning(computeEnableKerning())
 116     , m_requiresShaping(computeRequiresShaping())
 117 {
 118 }
 119 
 120 FontCascade&amp; FontCascade::operator=(const FontCascade&amp; other)
 121 {
 122     m_fontDescription = other.m_fontDescription;
 123     m_fonts = other.m_fonts;
 124     m_letterSpacing = other.m_letterSpacing;
 125     m_wordSpacing = other.m_wordSpacing;
 126     m_useBackslashAsYenSymbol = other.m_useBackslashAsYenSymbol;
 127     m_enableKerning = other.m_enableKerning;
 128     m_requiresShaping = other.m_requiresShaping;
 129     return *this;
 130 }
 131 
 132 bool FontCascade::operator==(const FontCascade&amp; other) const
 133 {
 134     if (isLoadingCustomFonts() || other.isLoadingCustomFonts())
 135         return false;
 136 
 137     if (m_fontDescription != other.m_fontDescription || m_letterSpacing != other.m_letterSpacing || m_wordSpacing != other.m_wordSpacing)
 138         return false;
 139     if (m_fonts == other.m_fonts)
 140         return true;
 141     if (!m_fonts || !other.m_fonts)
 142         return false;
 143     if (m_fonts-&gt;fontSelector() != other.m_fonts-&gt;fontSelector())
 144         return false;
 145     // Can these cases actually somehow occur? All fonts should get wiped out by full style recalc.
 146     if (m_fonts-&gt;fontSelectorVersion() != other.m_fonts-&gt;fontSelectorVersion())
 147         return false;
 148     if (m_fonts-&gt;generation() != other.m_fonts-&gt;generation())
 149         return false;
 150     return true;
 151 }
 152 
 153 struct FontCascadeCacheKey {
 154     FontDescriptionKey fontDescriptionKey; // Shared with the lower level FontCache (caching Font objects)
 155     Vector&lt;AtomicString, 3&gt; families;
 156     unsigned fontSelectorId;
 157     unsigned fontSelectorVersion;
 158 };
 159 
 160 struct FontCascadeCacheEntry {
 161     WTF_MAKE_FAST_ALLOCATED;
 162 public:
 163     FontCascadeCacheEntry(FontCascadeCacheKey&amp;&amp; key, Ref&lt;FontCascadeFonts&gt;&amp;&amp; fonts)
 164         : key(WTFMove(key))
 165         , fonts(WTFMove(fonts))
 166     { }
 167     FontCascadeCacheKey key;
 168     Ref&lt;FontCascadeFonts&gt; fonts;
 169 };
 170 
 171 // FIXME: Should make hash traits for FontCascadeCacheKey instead of using a hash as the key (so we hash a hash).
 172 typedef HashMap&lt;unsigned, std::unique_ptr&lt;FontCascadeCacheEntry&gt;, AlreadyHashed&gt; FontCascadeCache;
 173 
 174 static bool keysMatch(const FontCascadeCacheKey&amp; a, const FontCascadeCacheKey&amp; b)
 175 {
 176     if (a.fontDescriptionKey != b.fontDescriptionKey)
 177         return false;
 178     if (a.fontSelectorId != b.fontSelectorId || a.fontSelectorVersion != b.fontSelectorVersion)
 179         return false;
 180     unsigned size = a.families.size();
 181     if (size != b.families.size())
 182         return false;
 183     for (unsigned i = 0; i &lt; size; ++i) {
 184         if (!FontCascadeDescription::familyNamesAreEqual(a.families[i], b.families[i]))
 185             return false;
 186     }
 187     return true;
 188 }
 189 
 190 static FontCascadeCache&amp; fontCascadeCache()
 191 {
 192     static NeverDestroyed&lt;FontCascadeCache&gt; cache;
 193     return cache.get();
 194 }
 195 
 196 void invalidateFontCascadeCache()
 197 {
 198     fontCascadeCache().clear();
 199 }
 200 
 201 void clearWidthCaches()
 202 {
 203     for (auto&amp; value : fontCascadeCache().values())
 204         value-&gt;fonts.get().widthCache().clear();
 205 }
 206 
 207 static FontCascadeCacheKey makeFontCascadeCacheKey(const FontCascadeDescription&amp; description, FontSelector* fontSelector)
 208 {
 209     FontCascadeCacheKey key;
 210     key.fontDescriptionKey = FontDescriptionKey(description);
 211     unsigned familyCount = description.familyCount();
 212     key.families.reserveInitialCapacity(familyCount);
 213     for (unsigned i = 0; i &lt; familyCount; ++i)
 214         key.families.uncheckedAppend(description.familyAt(i));
 215     key.fontSelectorId = fontSelector ? fontSelector-&gt;uniqueId() : 0;
 216     key.fontSelectorVersion = fontSelector ? fontSelector-&gt;version() : 0;
 217     return key;
 218 }
 219 
 220 static unsigned computeFontCascadeCacheHash(const FontCascadeCacheKey&amp; key)
 221 {
 222     // FIXME: Should hash the key and the family name characters rather than making a hash out of other hashes.
 223     IntegerHasher hasher;
 224     hasher.add(key.fontDescriptionKey.computeHash());
 225     hasher.add(key.fontSelectorId);
 226     hasher.add(key.fontSelectorVersion);
 227     for (unsigned i = 0; i &lt; key.families.size(); ++i) {
 228         auto&amp; family = key.families[i];
 229         hasher.add(family.isNull() ? 0 : FontCascadeDescription::familyNameHash(family));
 230     }
 231     return hasher.hash();
 232 }
 233 
 234 void pruneUnreferencedEntriesFromFontCascadeCache()
 235 {
 236     fontCascadeCache().removeIf([](auto&amp; entry) {
 237         return entry.value-&gt;fonts.get().hasOneRef();
 238     });
 239 }
 240 
 241 void pruneSystemFallbackFonts()
 242 {
 243     for (auto&amp; entry : fontCascadeCache().values())
 244         entry-&gt;fonts-&gt;pruneSystemFallbacks();
 245 }
 246 
 247 static Ref&lt;FontCascadeFonts&gt; retrieveOrAddCachedFonts(const FontCascadeDescription&amp; fontDescription, RefPtr&lt;FontSelector&gt;&amp;&amp; fontSelector)
 248 {
 249     auto key = makeFontCascadeCacheKey(fontDescription, fontSelector.get());
 250 
 251     unsigned hash = computeFontCascadeCacheHash(key);
 252     auto addResult = fontCascadeCache().add(hash, nullptr);
 253     if (!addResult.isNewEntry &amp;&amp; keysMatch(addResult.iterator-&gt;value-&gt;key, key))
 254         return addResult.iterator-&gt;value-&gt;fonts.get();
 255 
 256     auto&amp; newEntry = addResult.iterator-&gt;value;
 257     newEntry = std::make_unique&lt;FontCascadeCacheEntry&gt;(WTFMove(key), FontCascadeFonts::create(WTFMove(fontSelector)));
 258     Ref&lt;FontCascadeFonts&gt; glyphs = newEntry-&gt;fonts.get();
 259 
 260     static const unsigned unreferencedPruneInterval = 50;
 261     static const int maximumEntries = 400;
 262     static unsigned pruneCounter;
 263     // Referenced FontCascadeFonts would exist anyway so pruning them saves little memory.
 264     if (!(++pruneCounter % unreferencedPruneInterval))
 265         pruneUnreferencedEntriesFromFontCascadeCache();
 266     // Prevent pathological growth.
 267     if (fontCascadeCache().size() &gt; maximumEntries)
 268         fontCascadeCache().remove(fontCascadeCache().random());
 269     return glyphs;
 270 }
 271 
 272 void FontCascade::update(RefPtr&lt;FontSelector&gt;&amp;&amp; fontSelector) const
 273 {
 274     m_fonts = retrieveOrAddCachedFonts(m_fontDescription, WTFMove(fontSelector));
 275     m_useBackslashAsYenSymbol = useBackslashAsYenSignForFamily(firstFamily());
 276     m_enableKerning = computeEnableKerning();
 277     m_requiresShaping = computeRequiresShaping();
 278 }
 279 
 280 float FontCascade::glyphBufferForTextRun(CodePath codePathToUse, const TextRun&amp; run, unsigned from, unsigned to, GlyphBuffer&amp; glyphBuffer) const
 281 {
 282     if (codePathToUse != Complex)
 283         return getGlyphsAndAdvancesForSimpleText(run, from, to, glyphBuffer);
 284     return getGlyphsAndAdvancesForComplexText(run, from, to, glyphBuffer);
 285 }
 286 
 287 float FontCascade::drawText(GraphicsContext&amp; context, const TextRun&amp; run, const FloatPoint&amp; point, unsigned from, Optional&lt;unsigned&gt; to, CustomFontNotReadyAction customFontNotReadyAction) const
 288 {
 289     unsigned destination = to.valueOr(run.length());
 290     GlyphBuffer glyphBuffer;
 291     float startX = point.x() + glyphBufferForTextRun(codePath(run, from, to), run, from, destination, glyphBuffer);
 292     // We couldn&#39;t generate any glyphs for the run. Give up.
 293     if (glyphBuffer.isEmpty())
 294         return 0;
 295     // Draw the glyph buffer now at the starting point returned in startX.
 296     FloatPoint startPoint(startX, point.y());
 297     drawGlyphBuffer(context, glyphBuffer, startPoint, customFontNotReadyAction);
 298     return startPoint.x() - startX;
 299 }
 300 
 301 void FontCascade::drawEmphasisMarks(GraphicsContext&amp; context, const TextRun&amp; run, const AtomicString&amp; mark, const FloatPoint&amp; point, unsigned from, Optional&lt;unsigned&gt; to) const
 302 {
 303     if (isLoadingCustomFonts())
 304         return;
 305 
 306     unsigned destination = to.valueOr(run.length());
 307     if (codePath(run, from, to) != Complex)
 308         drawEmphasisMarksForSimpleText(context, run, mark, point, from, destination);
 309     else
 310         drawEmphasisMarksForComplexText(context, run, mark, point, from, destination);
 311 }
 312 
 313 std::unique_ptr&lt;DisplayList::DisplayList&gt; FontCascade::displayListForTextRun(GraphicsContext&amp; context, const TextRun&amp; run, unsigned from, Optional&lt;unsigned&gt; to, CustomFontNotReadyAction customFontNotReadyAction) const
 314 {
 315     ASSERT(!context.paintingDisabled());
 316     unsigned destination = to.valueOr(run.length());
 317 
 318     // FIXME: Use the fast code path once it handles partial runs with kerning and ligatures. See http://webkit.org/b/100050
 319     CodePath codePathToUse = codePath(run);
 320     if (codePathToUse != Complex &amp;&amp; (enableKerning() || requiresShaping()) &amp;&amp; (from || destination != run.length()))
 321         codePathToUse = Complex;
 322 
 323     GlyphBuffer glyphBuffer;
 324     float startX = glyphBufferForTextRun(codePathToUse, run, from, destination, glyphBuffer);
 325     // We couldn&#39;t generate any glyphs for the run. Give up.
 326     if (glyphBuffer.isEmpty())
 327         return nullptr;
 328 
 329     std::unique_ptr&lt;DisplayList::DisplayList&gt; displayList = std::make_unique&lt;DisplayList::DisplayList&gt;();
 330     GraphicsContext recordingContext([&amp;](GraphicsContext&amp; displayListContext) {
 331         return std::make_unique&lt;DisplayList::Recorder&gt;(displayListContext, *displayList, context.state(), FloatRect(), AffineTransform());
 332     });
 333 
 334     FloatPoint startPoint(startX, 0);
 335     drawGlyphBuffer(recordingContext, glyphBuffer, startPoint, customFontNotReadyAction);
 336     return displayList;
 337 }
 338 
 339 float FontCascade::widthOfTextRange(const TextRun&amp; run, unsigned from, unsigned to, HashSet&lt;const Font*&gt;* fallbackFonts, float* outWidthBeforeRange, float* outWidthAfterRange) const
 340 {
 341     ASSERT(from &lt;= to);
 342     ASSERT(to &lt;= run.length());
 343 
 344     if (!run.length())
 345         return 0;
 346 
 347     float offsetBeforeRange = 0;
 348     float offsetAfterRange = 0;
 349     float totalWidth = 0;
 350 
 351     auto codePathToUse = codePath(run);
 352     if (codePathToUse == Complex) {
 353 #if PLATFORM(WIN)
 354         UniscribeController it(this, run);
 355         it.advance(from);
 356         offsetBeforeRange = it.runWidthSoFar();
 357         it.advance(to);
 358         offsetAfterRange = it.runWidthSoFar();
 359         it.advance(to);
 360         totalWidth = it.runWidthSoFar();
 361 #else
 362         ComplexTextController complexIterator(*this, run, false, fallbackFonts);
 363         complexIterator.advance(from, nullptr, IncludePartialGlyphs, fallbackFonts);
 364         offsetBeforeRange = complexIterator.runWidthSoFar();
 365         complexIterator.advance(to, nullptr, IncludePartialGlyphs, fallbackFonts);
 366         offsetAfterRange = complexIterator.runWidthSoFar();
 367         complexIterator.advance(run.length(), nullptr, IncludePartialGlyphs, fallbackFonts);
 368         totalWidth = complexIterator.runWidthSoFar();
 369         fprintf(stderr, &quot;totalWidth:%f\n&quot;, totalWidth);
 370 #endif
 371     } else {
 372         WidthIterator simpleIterator(this, run, fallbackFonts);
 373         simpleIterator.advance(from, nullptr);
 374         offsetBeforeRange = simpleIterator.runWidthSoFar();
 375         simpleIterator.advance(to, nullptr);
 376         offsetAfterRange = simpleIterator.runWidthSoFar();
 377         simpleIterator.advance(run.length(), nullptr);
 378         totalWidth = simpleIterator.runWidthSoFar();
 379     }
 380 
 381     if (outWidthBeforeRange)
 382         *outWidthBeforeRange = offsetBeforeRange;
 383 
 384     if (outWidthAfterRange)
 385         *outWidthAfterRange = totalWidth - offsetAfterRange;
 386 
 387     return offsetAfterRange - offsetBeforeRange;
 388 }
 389 
 390 float FontCascade::width(const TextRun&amp; run, HashSet&lt;const Font*&gt;* fallbackFonts, GlyphOverflow* glyphOverflow) const
 391 {
 392     if (!run.length())
 393         return 0;
 394 
 395     CodePath codePathToUse = codePath(run);
 396     if (codePathToUse != Complex) {
 397         // The complex path is more restrictive about returning fallback fonts than the simple path, so we need an explicit test to make their behaviors match.
 398         if (!canReturnFallbackFontsForComplexText())
 399             fallbackFonts = nullptr;
 400         // The simple path can optimize the case where glyph overflow is not observable.
 401         if (codePathToUse != SimpleWithGlyphOverflow &amp;&amp; (glyphOverflow &amp;&amp; !glyphOverflow-&gt;computeBounds))
 402             glyphOverflow = nullptr;
 403     }
 404 
 405     bool hasWordSpacingOrLetterSpacing = wordSpacing() || letterSpacing();
 406     float* cacheEntry = m_fonts-&gt;widthCache().add(run, std::numeric_limits&lt;float&gt;::quiet_NaN(), enableKerning() || requiresShaping(), hasWordSpacingOrLetterSpacing, glyphOverflow);
 407     if (cacheEntry &amp;&amp; !std::isnan(*cacheEntry))
 408         return *cacheEntry;
 409 
 410     HashSet&lt;const Font*&gt; localFallbackFonts;
 411     if (!fallbackFonts)
 412         fallbackFonts = &amp;localFallbackFonts;
 413 
 414     float result;
 415     if (codePathToUse == Complex)
 416         result = floatWidthForComplexText(run, fallbackFonts, glyphOverflow);
 417     else
 418         result = floatWidthForSimpleText(run, fallbackFonts, glyphOverflow);
 419 
 420     if (cacheEntry &amp;&amp; fallbackFonts-&gt;isEmpty())
 421         *cacheEntry = result;
 422     return result;
 423 }
 424 
 425 float FontCascade::widthForSimpleText(StringView text) const
 426 {
 427     if (text.isNull() || text.isEmpty())
 428         return 0;
 429     ASSERT(codePath(TextRun(text)) != FontCascade::Complex);
 430     float* cacheEntry = m_fonts-&gt;widthCache().add(text, std::numeric_limits&lt;float&gt;::quiet_NaN());
 431     if (cacheEntry &amp;&amp; !std::isnan(*cacheEntry))
 432         return *cacheEntry;
 433 
 434     Vector&lt;GlyphBufferGlyph, 16&gt; glyphs;
 435     Vector&lt;GlyphBufferAdvance, 16&gt; advances;
 436     bool hasKerningOrLigatures = enableKerning() || requiresShaping();
 437     float runWidth = 0;
 438     auto&amp; font = primaryFont();
 439     for (unsigned i = 0; i &lt; text.length(); ++i) {
 440         auto glyph = glyphDataForCharacter(text[i], false).glyph;
 441         auto glyphWidth = font.widthForGlyph(glyph);
 442         runWidth += glyphWidth;
 443         if (!hasKerningOrLigatures)
 444             continue;
 445         glyphs.append(glyph);
 446         advances.append(FloatSize(glyphWidth, 0));
 447     }
 448     if (hasKerningOrLigatures) {
 449         font.applyTransforms(&amp;glyphs[0], &amp;advances[0], glyphs.size(), enableKerning(), requiresShaping());
 450         // This is needed only to match the result of the slow path. Same glyph widths but different floating point arithmentics can
 451         // produce different run width.
 452         float runWidthDifferenceWithTransformApplied = -runWidth;
 453         for (auto&amp; advance : advances)
 454             runWidthDifferenceWithTransformApplied += advance.width();
 455         runWidth += runWidthDifferenceWithTransformApplied;
 456     }
 457 
 458     if (cacheEntry)
 459         *cacheEntry = runWidth;
 460     return runWidth;
 461 }
 462 
 463 GlyphData FontCascade::glyphDataForCharacter(UChar32 c, bool mirror, FontVariant variant) const
 464 {
 465     if (variant == AutoVariant) {
 466         if (m_fontDescription.variantCaps() == FontVariantCaps::Small) {
 467             UChar32 upperC = u_toupper(c);
 468             if (upperC != c) {
 469                 c = upperC;
 470                 variant = SmallCapsVariant;
 471             } else
 472                 variant = NormalVariant;
 473         } else
 474             variant = NormalVariant;
 475     }
 476 
 477     if (mirror)
 478         c = u_charMirror(c);
 479 
 480     return m_fonts-&gt;glyphDataForCharacter(c, m_fontDescription, variant);
 481 }
 482 
 483 // For font families where any of the fonts don&#39;t have a valid entry in the OS/2 table
 484 // for avgCharWidth, fallback to the legacy webkit behavior of getting the avgCharWidth
 485 // from the width of a &#39;0&#39;. This only seems to apply to a fixed number of Mac fonts,
 486 // but, in order to get similar rendering across platforms, we do this check for
 487 // all platforms.
 488 bool FontCascade::hasValidAverageCharWidth() const
 489 {
 490     const AtomicString&amp; family = firstFamily();
 491     if (family.isEmpty())
 492         return false;
 493 
 494 #if PLATFORM(COCOA)
 495     // Internal fonts on macOS and iOS also have an invalid entry in the table for avgCharWidth.
 496     if (primaryFontIsSystemFont())
 497         return false;
 498 #endif
 499 
 500     static const auto map = makeNeverDestroyed(HashSet&lt;AtomicString&gt; {
 501         &quot;American Typewriter&quot;,
 502         &quot;Arial Hebrew&quot;,
 503         &quot;Chalkboard&quot;,
 504         &quot;Cochin&quot;,
 505         &quot;Corsiva Hebrew&quot;,
 506         &quot;Courier&quot;,
 507         &quot;Euphemia UCAS&quot;,
 508         &quot;Geneva&quot;,
 509         &quot;Gill Sans&quot;,
 510         &quot;Hei&quot;,
 511         &quot;Helvetica&quot;,
 512         &quot;Hoefler Text&quot;,
 513         &quot;InaiMathi&quot;,
 514         &quot;Kai&quot;,
 515         &quot;Lucida Grande&quot;,
 516         &quot;Marker Felt&quot;,
 517         &quot;Monaco&quot;,
 518         &quot;Mshtakan&quot;,
 519         &quot;New Peninim MT&quot;,
 520         &quot;Osaka&quot;,
 521         &quot;Raanana&quot;,
 522         &quot;STHeiti&quot;,
 523         &quot;Symbol&quot;,
 524         &quot;Times&quot;,
 525         &quot;Apple Braille&quot;,
 526         &quot;Apple LiGothic&quot;,
 527         &quot;Apple LiSung&quot;,
 528         &quot;Apple Symbols&quot;,
 529         &quot;AppleGothic&quot;,
 530         &quot;AppleMyungjo&quot;,
 531         &quot;#GungSeo&quot;,
 532         &quot;#HeadLineA&quot;,
 533         &quot;#PCMyungjo&quot;,
 534         &quot;#PilGi&quot;,
 535     });
 536     return !map.get().contains(family);
 537 }
 538 
 539 bool FontCascade::fastAverageCharWidthIfAvailable(float&amp; width) const
 540 {
 541     bool success = hasValidAverageCharWidth();
 542     if (success)
 543         width = roundf(primaryFont().avgCharWidth()); // FIXME: primaryFont() might not correspond to firstFamily().
 544     return success;
 545 }
 546 
 547 void FontCascade::adjustSelectionRectForText(const TextRun&amp; run, LayoutRect&amp; selectionRect, unsigned from, Optional&lt;unsigned&gt; to) const
 548 {
 549     unsigned destination = to.valueOr(run.length());
 550     if (codePath(run, from, to) != Complex)
 551         return adjustSelectionRectForSimpleText(run, selectionRect, from, destination);
 552 
 553     return adjustSelectionRectForComplexText(run, selectionRect, from, destination);
 554 }
 555 
 556 int FontCascade::offsetForPosition(const TextRun&amp; run, float x, bool includePartialGlyphs) const
 557 {
 558     if (codePath(run, x) != Complex)
 559         return offsetForPositionForSimpleText(run, x, includePartialGlyphs);
 560 
 561     return offsetForPositionForComplexText(run, x, includePartialGlyphs);
 562 }
 563 
 564 template &lt;typename CharacterType&gt;
 565 static inline String normalizeSpacesInternal(const CharacterType* characters, unsigned length)
 566 {
 567     StringBuilder normalized;
 568     normalized.reserveCapacity(length);
 569 
 570     for (unsigned i = 0; i &lt; length; ++i)
 571         normalized.append(FontCascade::normalizeSpaces(characters[i]));
 572 
 573     return normalized.toString();
 574 }
 575 
 576 String FontCascade::normalizeSpaces(const LChar* characters, unsigned length)
 577 {
 578     return normalizeSpacesInternal(characters, length);
 579 }
 580 
 581 String FontCascade::normalizeSpaces(const UChar* characters, unsigned length)
 582 {
 583     return normalizeSpacesInternal(characters, length);
 584 }
 585 
 586 static bool shouldUseFontSmoothing = true;
 587 
 588 void FontCascade::setShouldUseSmoothing(bool shouldUseSmoothing)
 589 {
 590     ASSERT(isMainThread());
 591     shouldUseFontSmoothing = shouldUseSmoothing;
 592 }
 593 
 594 bool FontCascade::shouldUseSmoothing()
 595 {
 596     return shouldUseFontSmoothing;
 597 }
 598 
 599 #if !PLATFORM(COCOA)
 600 bool FontCascade::isSubpixelAntialiasingAvailable()
 601 {
 602     return false;
 603 }
 604 #endif
 605 
 606 void FontCascade::setCodePath(CodePath p)
 607 {
 608     s_codePath = p;
 609 }
 610 
 611 FontCascade::CodePath FontCascade::codePath()
 612 {
 613     return s_codePath;
 614 }
 615 
 616 FontCascade::CodePath FontCascade::codePath(const TextRun&amp; run, Optional&lt;unsigned&gt; from, Optional&lt;unsigned&gt; to) const
 617 {
 618     if (s_codePath != Auto)
 619         return s_codePath;
 620 
 621 #if !USE(FREETYPE)
 622     // FIXME: Use the fast code path once it handles partial runs with kerning and ligatures. See http://webkit.org/b/100050
 623     if ((enableKerning() || requiresShaping()) &amp;&amp; (from.valueOr(0) || to.valueOr(run.length()) != run.length()))
 624         return Complex;
 625 #else
 626     UNUSED_PARAM(from);
 627     UNUSED_PARAM(to);
 628 #endif
 629 
 630 #if PLATFORM(COCOA) || USE(FREETYPE)
 631     // Because Font::applyTransforms() doesn&#39;t know which features to enable/disable in the simple code path, it can&#39;t properly handle feature or variant settings.
 632     // FIXME: https://bugs.webkit.org/show_bug.cgi?id=150791: @font-face features should also cause this to be complex.
 633     if (m_fontDescription.featureSettings().size() &gt; 0 || !m_fontDescription.variantSettings().isAllNormal())
 634         return Complex;
 635 
 636 #else
 637 
 638     if (run.length() &gt; 1 &amp;&amp; (enableKerning() || requiresShaping()))
 639         return Complex;
 640 #endif
 641 
 642     if (!run.characterScanForCodePath())
 643         return Simple;
 644 
 645     if (run.is8Bit())
 646         return Simple;
 647 
 648     // Start from 0 since drawing and highlighting also measure the characters before run-&gt;from.
 649     return characterRangeCodePath(run.characters16(), run.length());
 650 }
 651 
 652 FontCascade::CodePath FontCascade::characterRangeCodePath(const UChar* characters, unsigned len)
 653 {
 654     // FIXME: Should use a UnicodeSet in ports where ICU is used. Note that we
 655     // can&#39;t simply use UnicodeCharacter Property/class because some characters
 656     // are not &#39;combining&#39;, but still need to go to the complex path.
 657     // Alternatively, we may as well consider binary search over a sorted
 658     // list of ranges.
 659     CodePath result = Simple;
 660     bool previousCharacterIsEmojiGroupCandidate = false;
 661     for (unsigned i = 0; i &lt; len; i++) {
 662         const UChar c = characters[i];
 663         if (c == zeroWidthJoiner &amp;&amp; previousCharacterIsEmojiGroupCandidate)
 664             return Complex;
 665 
 666         previousCharacterIsEmojiGroupCandidate = false;
 667         if (c &lt; 0x2E5) // U+02E5 through U+02E9 (Modifier Letters : Tone letters)
 668             continue;
 669         if (c &lt;= 0x2E9)
 670             return Complex;
 671 
 672         if (c &lt; 0x300) // U+0300 through U+036F Combining diacritical marks
 673             continue;
 674         if (c &lt;= 0x36F)
 675             return Complex;
 676 
 677         if (c &lt; 0x0591 || c == 0x05BE) // U+0591 through U+05CF excluding U+05BE Hebrew combining marks, Hebrew punctuation Paseq, Sof Pasuq and Nun Hafukha
 678             continue;
 679         if (c &lt;= 0x05CF)
 680             return Complex;
 681 
 682         // U+0600 through U+109F Arabic, Syriac, Thaana, NKo, Samaritan, Mandaic,
 683         // Devanagari, Bengali, Gurmukhi, Gujarati, Oriya, Tamil, Telugu, Kannada,
 684         // Malayalam, Sinhala, Thai, Lao, Tibetan, Myanmar
 685         if (c &lt; 0x0600)
 686             continue;
 687         if (c &lt;= 0x109F)
 688             return Complex;
 689 
 690         // U+1100 through U+11FF Hangul Jamo (only Ancient Korean should be left here if you precompose;
 691         // Modern Korean will be precomposed as a result of step A)
 692         if (c &lt; 0x1100)
 693             continue;
 694         if (c &lt;= 0x11FF)
 695             return Complex;
 696 
 697         if (c &lt; 0x135D) // U+135D through U+135F Ethiopic combining marks
 698             continue;
 699         if (c &lt;= 0x135F)
 700             return Complex;
 701 
 702         if (c &lt; 0x1700) // U+1780 through U+18AF Tagalog, Hanunoo, Buhid, Taghanwa,Khmer, Mongolian
 703             continue;
 704         if (c &lt;= 0x18AF)
 705             return Complex;
 706 
 707         if (c &lt; 0x1900) // U+1900 through U+194F Limbu (Unicode 4.0)
 708             continue;
 709         if (c &lt;= 0x194F)
 710             return Complex;
 711 
 712         if (c &lt; 0x1980) // U+1980 through U+19DF New Tai Lue
 713             continue;
 714         if (c &lt;= 0x19DF)
 715             return Complex;
 716 
 717         if (c &lt; 0x1A00) // U+1A00 through U+1CFF Buginese, Tai Tham, Balinese, Batak, Lepcha, Vedic
 718             continue;
 719         if (c &lt;= 0x1CFF)
 720             return Complex;
 721 
 722         if (c &lt; 0x1DC0) // U+1DC0 through U+1DFF Comining diacritical mark supplement
 723             continue;
 724         if (c &lt;= 0x1DFF)
 725             return Complex;
 726 
 727         // U+1E00 through U+2000 characters with diacritics and stacked diacritics
 728         if (c &lt;= 0x2000) {
 729             result = SimpleWithGlyphOverflow;
 730             continue;
 731         }
 732 
 733         if (c &lt; 0x20D0) // U+20D0 through U+20FF Combining marks for symbols
 734             continue;
 735         if (c &lt;= 0x20FF)
 736             return Complex;
 737 
 738         if (c &lt; 0x26F9)
 739             continue;
 740         if (c &lt; 0x26FA)
 741             return Complex;
 742 
 743         if (c &lt; 0x2CEF) // U+2CEF through U+2CF1 Combining marks for Coptic
 744             continue;
 745         if (c &lt;= 0x2CF1)
 746             return Complex;
 747 
 748         if (c &lt; 0x302A) // U+302A through U+302F Ideographic and Hangul Tone marks
 749             continue;
 750         if (c &lt;= 0x302F)
 751             return Complex;
 752 
 753         if (c &lt; 0xA67C) // U+A67C through U+A67D Combining marks for old Cyrillic
 754             continue;
 755         if (c &lt;= 0xA67D)
 756             return Complex;
 757 
 758         if (c &lt; 0xA6F0) // U+A6F0 through U+A6F1 Combining mark for Bamum
 759             continue;
 760         if (c &lt;= 0xA6F1)
 761             return Complex;
 762 
 763         // U+A800 through U+ABFF Nagri, Phags-pa, Saurashtra, Devanagari Extended,
 764         // Hangul Jamo Ext. A, Javanese, Myanmar Extended A, Tai Viet, Meetei Mayek,
 765         if (c &lt; 0xA800)
 766             continue;
 767         if (c &lt;= 0xABFF)
 768             return Complex;
 769 
 770         if (c &lt; 0xD7B0) // U+D7B0 through U+D7FF Hangul Jamo Ext. B
 771             continue;
 772         if (c &lt;= 0xD7FF)
 773             return Complex;
 774 
 775         if (c &lt;= 0xDBFF) {
 776             // High surrogate
 777 
 778             if (i == len - 1)
 779                 continue;
 780 
 781             UChar next = characters[++i];
 782             if (!U16_IS_TRAIL(next))
 783                 continue;
 784 
 785             UChar32 supplementaryCharacter = U16_GET_SUPPLEMENTARY(c, next);
 786 
 787             if (supplementaryCharacter &lt; 0x10A00)
 788                 continue;
 789             if (supplementaryCharacter &lt; 0x10A60) // Kharoshthi
 790                 return Complex;
 791             if (supplementaryCharacter &lt; 0x11000)
 792                 continue;
 793             if (supplementaryCharacter &lt; 0x11080) // Brahmi
 794                 return Complex;
 795             if (supplementaryCharacter &lt; 0x110D0) // Kaithi
 796                 return Complex;
 797             if (supplementaryCharacter &lt; 0x11100)
 798                 continue;
 799             if (supplementaryCharacter &lt; 0x11150) // Chakma
 800                 return Complex;
 801             if (supplementaryCharacter &lt; 0x11180) // Mahajani
 802                 return Complex;
 803             if (supplementaryCharacter &lt; 0x111E0) // Sharada
 804                 return Complex;
 805             if (supplementaryCharacter &lt; 0x11200)
 806                 continue;
 807             if (supplementaryCharacter &lt; 0x11250) // Khojki
 808                 return Complex;
 809             if (supplementaryCharacter &lt; 0x112B0)
 810                 continue;
 811             if (supplementaryCharacter &lt; 0x11300) // Khudawadi
 812                 return Complex;
 813             if (supplementaryCharacter &lt; 0x11380) // Grantha
 814                 return Complex;
 815             if (supplementaryCharacter &lt; 0x11400)
 816                 continue;
 817             if (supplementaryCharacter &lt; 0x11480) // Newa
 818                 return Complex;
 819             if (supplementaryCharacter &lt; 0x114E0) // Tirhuta
 820                 return Complex;
 821             if (supplementaryCharacter &lt; 0x11580)
 822                 continue;
 823             if (supplementaryCharacter &lt; 0x11600) // Siddham
 824                 return Complex;
 825             if (supplementaryCharacter &lt; 0x11660) // Modi
 826                 return Complex;
 827             if (supplementaryCharacter &lt; 0x11680)
 828                 continue;
 829             if (supplementaryCharacter &lt; 0x116D0) // Takri
 830                 return Complex;
 831             if (supplementaryCharacter &lt; 0x11C00)
 832                 continue;
 833             if (supplementaryCharacter &lt; 0x11C70) // Bhaiksuki
 834                 return Complex;
 835             if (supplementaryCharacter &lt; 0x11CC0) // Marchen
 836                 return Complex;
 837             if (supplementaryCharacter &lt; 0x1E900)
 838                 continue;
 839             if (supplementaryCharacter &lt; 0x1E960) // Adlam
 840                 return Complex;
 841             if (supplementaryCharacter &lt; 0x1F1E6) // U+1F1E6 through U+1F1FF Regional Indicator Symbols
 842                 continue;
 843             if (supplementaryCharacter &lt;= 0x1F1FF)
 844                 return Complex;
 845 
 846             if (isEmojiFitzpatrickModifier(supplementaryCharacter))
 847                 return Complex;
 848             if (isEmojiGroupCandidate(supplementaryCharacter)) {
 849                 previousCharacterIsEmojiGroupCandidate = true;
 850                 continue;
 851             }
 852 
 853             if (supplementaryCharacter &lt; 0xE0000)
 854                 continue;
 855             if (supplementaryCharacter &lt; 0xE0080) // Tags
 856                 return Complex;
 857             if (supplementaryCharacter &lt; 0xE0100) // U+E0100 through U+E01EF Unicode variation selectors.
 858                 continue;
 859             if (supplementaryCharacter &lt;= 0xE01EF)
 860                 return Complex;
 861 
 862             // FIXME: Check for Brahmi (U+11000 block), Kaithi (U+11080 block) and other complex scripts
 863             // in plane 1 or higher.
 864 
 865             continue;
 866         }
 867 
 868         if (c &lt; 0xFE00) // U+FE00 through U+FE0F Unicode variation selectors
 869             continue;
 870         if (c &lt;= 0xFE0F)
 871             return Complex;
 872 
 873         if (c &lt; 0xFE20) // U+FE20 through U+FE2F Combining half marks
 874             continue;
 875         if (c &lt;= 0xFE2F)
 876             return Complex;
 877     }
 878     return result;
 879 }
 880 
 881 bool FontCascade::isCJKIdeograph(UChar32 c)
 882 {
 883     // The basic CJK Unified Ideographs block.
 884     if (c &gt;= 0x4E00 &amp;&amp; c &lt;= 0x9FFF)
 885         return true;
 886 
 887     // CJK Unified Ideographs Extension A.
 888     if (c &gt;= 0x3400 &amp;&amp; c &lt;= 0x4DBF)
 889         return true;
 890 
 891     // CJK Radicals Supplement.
 892     if (c &gt;= 0x2E80 &amp;&amp; c &lt;= 0x2EFF)
 893         return true;
 894 
 895     // Kangxi Radicals.
 896     if (c &gt;= 0x2F00 &amp;&amp; c &lt;= 0x2FDF)
 897         return true;
 898 
 899     // CJK Strokes.
 900     if (c &gt;= 0x31C0 &amp;&amp; c &lt;= 0x31EF)
 901         return true;
 902 
 903     // CJK Compatibility Ideographs.
 904     if (c &gt;= 0xF900 &amp;&amp; c &lt;= 0xFAFF)
 905         return true;
 906 
 907     // CJK Unified Ideographs Extension B.
 908     if (c &gt;= 0x20000 &amp;&amp; c &lt;= 0x2A6DF)
 909         return true;
 910 
 911     // CJK Unified Ideographs Extension C.
 912     if (c &gt;= 0x2A700 &amp;&amp; c &lt;= 0x2B73F)
 913         return true;
 914 
 915     // CJK Unified Ideographs Extension D.
 916     if (c &gt;= 0x2B740 &amp;&amp; c &lt;= 0x2B81F)
 917         return true;
 918 
 919     // CJK Compatibility Ideographs Supplement.
 920     if (c &gt;= 0x2F800 &amp;&amp; c &lt;= 0x2FA1F)
 921         return true;
 922 
 923     return false;
 924 }
 925 
 926 bool FontCascade::isCJKIdeographOrSymbol(UChar32 c)
 927 {
 928     // 0x2C7 Caron, Mandarin Chinese 3rd Tone
 929     // 0x2CA Modifier Letter Acute Accent, Mandarin Chinese 2nd Tone
 930     // 0x2CB Modifier Letter Grave Access, Mandarin Chinese 4th Tone
 931     // 0x2D9 Dot Above, Mandarin Chinese 5th Tone
 932     if ((c == 0x2C7) || (c == 0x2CA) || (c == 0x2CB) || (c == 0x2D9))
 933         return true;
 934 
 935     if ((c == 0x2020) || (c == 0x2021) || (c == 0x2030) || (c == 0x203B) || (c == 0x203C)
 936         || (c == 0x2042) || (c == 0x2047) || (c == 0x2048) || (c == 0x2049) || (c == 0x2051)
 937         || (c == 0x20DD) || (c == 0x20DE) || (c == 0x2100) || (c == 0x2103) || (c == 0x2105)
 938         || (c == 0x2109) || (c == 0x210A) || (c == 0x2113) || (c == 0x2116) || (c == 0x2121)
 939         || (c == 0x212B) || (c == 0x213B) || (c == 0x2150) || (c == 0x2151) || (c == 0x2152))
 940         return true;
 941 
 942     if (c &gt;= 0x2156 &amp;&amp; c &lt;= 0x215A)
 943         return true;
 944 
 945     if (c &gt;= 0x2160 &amp;&amp; c &lt;= 0x216B)
 946         return true;
 947 
 948     if (c &gt;= 0x2170 &amp;&amp; c &lt;= 0x217B)
 949         return true;
 950 
 951     if ((c == 0x217F) || (c == 0x2189) || (c == 0x2307) || (c == 0x2312) || (c == 0x23BE) || (c == 0x23BF))
 952         return true;
 953 
 954     if (c &gt;= 0x23C0 &amp;&amp; c &lt;= 0x23CC)
 955         return true;
 956 
 957     if ((c == 0x23CE) || (c == 0x2423))
 958         return true;
 959 
 960     if (c &gt;= 0x2460 &amp;&amp; c &lt;= 0x2492)
 961         return true;
 962 
 963     if (c &gt;= 0x249C &amp;&amp; c &lt;= 0x24FF)
 964         return true;
 965 
 966     if ((c == 0x25A0) || (c == 0x25A1) || (c == 0x25A2) || (c == 0x25AA) || (c == 0x25AB))
 967         return true;
 968 
 969     if ((c == 0x25B1) || (c == 0x25B2) || (c == 0x25B3) || (c == 0x25B6) || (c == 0x25B7) || (c == 0x25BC) || (c == 0x25BD))
 970         return true;
 971 
 972     if ((c == 0x25C0) || (c == 0x25C1) || (c == 0x25C6) || (c == 0x25C7) || (c == 0x25C9) || (c == 0x25CB) || (c == 0x25CC))
 973         return true;
 974 
 975     if (c &gt;= 0x25CE &amp;&amp; c &lt;= 0x25D3)
 976         return true;
 977 
 978     if (c &gt;= 0x25E2 &amp;&amp; c &lt;= 0x25E6)
 979         return true;
 980 
 981     if (c == 0x25EF)
 982         return true;
 983 
 984     if (c &gt;= 0x2600 &amp;&amp; c &lt;= 0x2603)
 985         return true;
 986 
 987     if ((c == 0x2605) || (c == 0x2606) || (c == 0x260E) || (c == 0x2616) || (c == 0x2617) || (c == 0x2640) || (c == 0x2642))
 988         return true;
 989 
 990     if (c &gt;= 0x2660 &amp;&amp; c &lt;= 0x266F)
 991         return true;
 992 
 993     if (c &gt;= 0x2672 &amp;&amp; c &lt;= 0x267D)
 994         return true;
 995 
 996     if ((c == 0x26A0) || (c == 0x26BD) || (c == 0x26BE) || (c == 0x2713) || (c == 0x271A) || (c == 0x273F) || (c == 0x2740) || (c == 0x2756))
 997         return true;
 998 
 999     if (c &gt;= 0x2776 &amp;&amp; c &lt;= 0x277F)
1000         return true;
1001 
1002     if (c == 0x2B1A)
1003         return true;
1004 
1005     // Ideographic Description Characters.
1006     if (c &gt;= 0x2FF0 &amp;&amp; c &lt;= 0x2FFF)
1007         return true;
1008 
1009     // CJK Symbols and Punctuation, excluding 0x3030.
1010     if (c &gt;= 0x3000 &amp;&amp; c &lt; 0x3030)
1011         return true;
1012 
1013     if (c &gt; 0x3030 &amp;&amp; c &lt;= 0x303F)
1014         return true;
1015 
1016     // Hiragana
1017     if (c &gt;= 0x3040 &amp;&amp; c &lt;= 0x309F)
1018         return true;
1019 
1020     // Katakana
1021     if (c &gt;= 0x30A0 &amp;&amp; c &lt;= 0x30FF)
1022         return true;
1023 
1024     // Bopomofo
1025     if (c &gt;= 0x3100 &amp;&amp; c &lt;= 0x312F)
1026         return true;
1027 
1028     if (c &gt;= 0x3190 &amp;&amp; c &lt;= 0x319F)
1029         return true;
1030 
1031     // Bopomofo Extended
1032     if (c &gt;= 0x31A0 &amp;&amp; c &lt;= 0x31BF)
1033         return true;
1034 
1035     // Enclosed CJK Letters and Months.
1036     if (c &gt;= 0x3200 &amp;&amp; c &lt;= 0x32FF)
1037         return true;
1038 
1039     // CJK Compatibility.
1040     if (c &gt;= 0x3300 &amp;&amp; c &lt;= 0x33FF)
1041         return true;
1042 
1043     if (c &gt;= 0xF860 &amp;&amp; c &lt;= 0xF862)
1044         return true;
1045 
1046     // CJK Compatibility Forms.
1047     if (c &gt;= 0xFE30 &amp;&amp; c &lt;= 0xFE4F)
1048         return true;
1049 
1050     if ((c == 0xFE10) || (c == 0xFE11) || (c == 0xFE12) || (c == 0xFE19))
1051         return true;
1052 
1053     if ((c == 0xFF0D) || (c == 0xFF1B) || (c == 0xFF1C) || (c == 0xFF1E))
1054         return false;
1055 
1056     // Halfwidth and Fullwidth Forms
1057     // Usually only used in CJK
1058     if (c &gt;= 0xFF00 &amp;&amp; c &lt;= 0xFFEF)
1059         return true;
1060 
1061     // Emoji.
1062     if (c == 0x1F100)
1063         return true;
1064 
1065     if (c &gt;= 0x1F110 &amp;&amp; c &lt;= 0x1F129)
1066         return true;
1067 
1068     if (c &gt;= 0x1F130 &amp;&amp; c &lt;= 0x1F149)
1069         return true;
1070 
1071     if (c &gt;= 0x1F150 &amp;&amp; c &lt;= 0x1F169)
1072         return true;
1073 
1074     if (c &gt;= 0x1F170 &amp;&amp; c &lt;= 0x1F189)
1075         return true;
1076 
1077     if (c &gt;= 0x1F200 &amp;&amp; c &lt;= 0x1F6C5)
1078         return true;
1079 
1080     return isCJKIdeograph(c);
1081 }
1082 
1083 std::pair&lt;unsigned, bool&gt; FontCascade::expansionOpportunityCountInternal(const LChar* characters, unsigned length, TextDirection direction, ExpansionBehavior expansionBehavior)
1084 {
1085     unsigned count = 0;
1086     bool isAfterExpansion = (expansionBehavior &amp; LeadingExpansionMask) == ForbidLeadingExpansion;
1087     if ((expansionBehavior &amp; LeadingExpansionMask) == ForceLeadingExpansion) {
1088         ++count;
1089         isAfterExpansion = true;
1090     }
1091     if (direction == TextDirection::LTR) {
1092         for (unsigned i = 0; i &lt; length; ++i) {
1093             if (treatAsSpace(characters[i])) {
1094                 count++;
1095                 isAfterExpansion = true;
1096             } else
1097                 isAfterExpansion = false;
1098         }
1099     } else {
1100         for (unsigned i = length; i &gt; 0; --i) {
1101             if (treatAsSpace(characters[i - 1])) {
1102                 count++;
1103                 isAfterExpansion = true;
1104             } else
1105                 isAfterExpansion = false;
1106         }
1107     }
1108     if (!isAfterExpansion &amp;&amp; (expansionBehavior &amp; TrailingExpansionMask) == ForceTrailingExpansion) {
1109         ++count;
1110         isAfterExpansion = true;
1111     } else if (isAfterExpansion &amp;&amp; (expansionBehavior &amp; TrailingExpansionMask) == ForbidTrailingExpansion) {
1112         ASSERT(count);
1113         --count;
1114         isAfterExpansion = false;
1115     }
1116     return std::make_pair(count, isAfterExpansion);
1117 }
1118 
1119 std::pair&lt;unsigned, bool&gt; FontCascade::expansionOpportunityCountInternal(const UChar* characters, unsigned length, TextDirection direction, ExpansionBehavior expansionBehavior)
1120 {
1121     static bool expandAroundIdeographs = canExpandAroundIdeographsInComplexText();
1122     unsigned count = 0;
1123     bool isAfterExpansion = (expansionBehavior &amp; LeadingExpansionMask) == ForbidLeadingExpansion;
1124     if ((expansionBehavior &amp; LeadingExpansionMask) == ForceLeadingExpansion) {
1125         ++count;
1126         isAfterExpansion = true;
1127     }
1128     if (direction == TextDirection::LTR) {
1129         for (unsigned i = 0; i &lt; length; ++i) {
1130             UChar32 character = characters[i];
1131             if (treatAsSpace(character)) {
1132                 count++;
1133                 isAfterExpansion = true;
1134                 continue;
1135             }
1136             if (U16_IS_LEAD(character) &amp;&amp; i + 1 &lt; length &amp;&amp; U16_IS_TRAIL(characters[i + 1])) {
1137                 character = U16_GET_SUPPLEMENTARY(character, characters[i + 1]);
1138                 i++;
1139             }
1140             if (expandAroundIdeographs &amp;&amp; isCJKIdeographOrSymbol(character)) {
1141                 if (!isAfterExpansion)
1142                     count++;
1143                 count++;
1144                 isAfterExpansion = true;
1145                 continue;
1146             }
1147             isAfterExpansion = false;
1148         }
1149     } else {
1150         for (unsigned i = length; i &gt; 0; --i) {
1151             UChar32 character = characters[i - 1];
1152             if (treatAsSpace(character)) {
1153                 count++;
1154                 isAfterExpansion = true;
1155                 continue;
1156             }
1157             if (U16_IS_TRAIL(character) &amp;&amp; i &gt; 1 &amp;&amp; U16_IS_LEAD(characters[i - 2])) {
1158                 character = U16_GET_SUPPLEMENTARY(characters[i - 2], character);
1159                 i--;
1160             }
1161             if (expandAroundIdeographs &amp;&amp; isCJKIdeographOrSymbol(character)) {
1162                 if (!isAfterExpansion)
1163                     count++;
1164                 count++;
1165                 isAfterExpansion = true;
1166                 continue;
1167             }
1168             isAfterExpansion = false;
1169         }
1170     }
1171     if (!isAfterExpansion &amp;&amp; (expansionBehavior &amp; TrailingExpansionMask) == ForceTrailingExpansion) {
1172         ++count;
1173         isAfterExpansion = true;
1174     } else if (isAfterExpansion &amp;&amp; (expansionBehavior &amp; TrailingExpansionMask) == ForbidTrailingExpansion) {
1175         ASSERT(count);
1176         --count;
1177         isAfterExpansion = false;
1178     }
1179     return std::make_pair(count, isAfterExpansion);
1180 }
1181 
1182 std::pair&lt;unsigned, bool&gt; FontCascade::expansionOpportunityCount(const StringView&amp; stringView, TextDirection direction, ExpansionBehavior expansionBehavior)
1183 {
1184     // For each character, iterating from left to right:
1185     //   If it is recognized as a space, insert an opportunity after it
1186     //   If it is an ideograph, insert one opportunity before it and one opportunity after it
1187     // Do this such a way so that there are not two opportunities next to each other.
1188     if (stringView.is8Bit())
1189         return expansionOpportunityCountInternal(stringView.characters8(), stringView.length(), direction, expansionBehavior);
1190     return expansionOpportunityCountInternal(stringView.characters16(), stringView.length(), direction, expansionBehavior);
1191 }
1192 
1193 bool FontCascade::leadingExpansionOpportunity(const StringView&amp; stringView, TextDirection direction)
1194 {
1195     if (!stringView.length())
1196         return false;
1197 
1198     UChar32 initialCharacter;
1199     if (direction == TextDirection::LTR) {
1200         initialCharacter = stringView[0];
1201         if (U16_IS_LEAD(initialCharacter) &amp;&amp; stringView.length() &gt; 1 &amp;&amp; U16_IS_TRAIL(stringView[1]))
1202             initialCharacter = U16_GET_SUPPLEMENTARY(initialCharacter, stringView[1]);
1203     } else {
1204         initialCharacter = stringView[stringView.length() - 1];
1205         if (U16_IS_TRAIL(initialCharacter) &amp;&amp; stringView.length() &gt; 1 &amp;&amp; U16_IS_LEAD(stringView[stringView.length() - 2]))
1206             initialCharacter = U16_GET_SUPPLEMENTARY(stringView[stringView.length() - 2], initialCharacter);
1207     }
1208 
1209     return canExpandAroundIdeographsInComplexText() &amp;&amp; isCJKIdeographOrSymbol(initialCharacter);
1210 }
1211 
1212 bool FontCascade::trailingExpansionOpportunity(const StringView&amp; stringView, TextDirection direction)
1213 {
1214     if (!stringView.length())
1215         return false;
1216 
1217     UChar32 finalCharacter;
1218     if (direction == TextDirection::LTR) {
1219         finalCharacter = stringView[stringView.length() - 1];
1220         if (U16_IS_TRAIL(finalCharacter) &amp;&amp; stringView.length() &gt; 1 &amp;&amp; U16_IS_LEAD(stringView[stringView.length() - 2]))
1221             finalCharacter = U16_GET_SUPPLEMENTARY(stringView[stringView.length() - 2], finalCharacter);
1222     } else {
1223         finalCharacter = stringView[0];
1224         if (U16_IS_LEAD(finalCharacter) &amp;&amp; stringView.length() &gt; 1 &amp;&amp; U16_IS_TRAIL(stringView[1]))
1225             finalCharacter = U16_GET_SUPPLEMENTARY(finalCharacter, stringView[1]);
1226     }
1227 
1228     return treatAsSpace(finalCharacter) || (canExpandAroundIdeographsInComplexText() &amp;&amp; isCJKIdeographOrSymbol(finalCharacter));
1229 }
1230 
1231 bool FontCascade::canReceiveTextEmphasis(UChar32 c)
1232 {
1233     if (U_GET_GC_MASK(c) &amp; (U_GC_Z_MASK | U_GC_CN_MASK | U_GC_CC_MASK | U_GC_CF_MASK))
1234         return false;
1235 
1236     // Additional word-separator characters listed in CSS Text Level 3 Editor&#39;s Draft 3 November 2010.
1237     if (c == ethiopicWordspace || c == aegeanWordSeparatorLine || c == aegeanWordSeparatorDot
1238         || c == ugariticWordDivider || c == tibetanMarkIntersyllabicTsheg || c == tibetanMarkDelimiterTshegBstar)
1239         return false;
1240 
1241     return true;
1242 }
1243 
1244 bool FontCascade::isLoadingCustomFonts() const
1245 {
1246     return m_fonts &amp;&amp; m_fonts-&gt;isLoadingCustomFonts();
1247 }
1248 
1249 enum class GlyphUnderlineType : uint8_t {
1250     SkipDescenders,
1251     SkipGlyph,
1252     DrawOverGlyph
1253 };
1254 
1255 static GlyphUnderlineType computeUnderlineType(const TextRun&amp; textRun, const GlyphBuffer&amp; glyphBuffer, unsigned index)
1256 {
1257     // In general, we want to skip descenders. However, skipping descenders on CJK characters leads to undesirable renderings,
1258     // so we want to draw through CJK characters (on a character-by-character basis).
1259     // FIXME: The CSS spec says this should instead be done by the user-agent stylesheet using the lang= attribute.
1260     UChar32 baseCharacter;
1261     unsigned offsetInString = glyphBuffer.offsetInString(index);
1262 
1263     if (offsetInString == GlyphBuffer::noOffset || offsetInString &gt;= textRun.length()) {
1264         // We have no idea which character spawned this glyph. Bail.
1265         ASSERT_WITH_SECURITY_IMPLICATION(offsetInString &lt; textRun.length());
1266         return GlyphUnderlineType::DrawOverGlyph;
1267     }
1268 
1269     if (textRun.is8Bit())
1270         baseCharacter = textRun.characters8()[offsetInString];
1271     else
1272         U16_NEXT(textRun.characters16(), offsetInString, textRun.length(), baseCharacter);
1273 
1274     // u_getIntPropertyValue with UCHAR_IDEOGRAPHIC doesn&#39;t return true for Japanese or Korean codepoints.
1275     // Instead, we can use the &quot;Unicode allocation block&quot; for the character.
1276     UBlockCode blockCode = ublock_getCode(baseCharacter);
1277     switch (blockCode) {
1278     case UBLOCK_CJK_RADICALS_SUPPLEMENT:
1279     case UBLOCK_CJK_SYMBOLS_AND_PUNCTUATION:
1280     case UBLOCK_ENCLOSED_CJK_LETTERS_AND_MONTHS:
1281     case UBLOCK_CJK_COMPATIBILITY:
1282     case UBLOCK_CJK_UNIFIED_IDEOGRAPHS_EXTENSION_A:
1283     case UBLOCK_CJK_UNIFIED_IDEOGRAPHS:
1284     case UBLOCK_CJK_COMPATIBILITY_IDEOGRAPHS:
1285     case UBLOCK_CJK_COMPATIBILITY_FORMS:
1286     case UBLOCK_CJK_UNIFIED_IDEOGRAPHS_EXTENSION_B:
1287     case UBLOCK_CJK_COMPATIBILITY_IDEOGRAPHS_SUPPLEMENT:
1288     case UBLOCK_CJK_STROKES:
1289     case UBLOCK_CJK_UNIFIED_IDEOGRAPHS_EXTENSION_C:
1290     case UBLOCK_CJK_UNIFIED_IDEOGRAPHS_EXTENSION_D:
1291     case UBLOCK_IDEOGRAPHIC_DESCRIPTION_CHARACTERS:
1292     case UBLOCK_LINEAR_B_IDEOGRAMS:
1293     case UBLOCK_ENCLOSED_IDEOGRAPHIC_SUPPLEMENT:
1294     case UBLOCK_HIRAGANA:
1295     case UBLOCK_KATAKANA:
1296     case UBLOCK_BOPOMOFO:
1297     case UBLOCK_BOPOMOFO_EXTENDED:
1298     case UBLOCK_HANGUL_JAMO:
1299     case UBLOCK_HANGUL_COMPATIBILITY_JAMO:
1300     case UBLOCK_HANGUL_SYLLABLES:
1301     case UBLOCK_HANGUL_JAMO_EXTENDED_A:
1302     case UBLOCK_HANGUL_JAMO_EXTENDED_B:
1303         return GlyphUnderlineType::DrawOverGlyph;
1304     default:
1305         return GlyphUnderlineType::SkipDescenders;
1306     }
1307 }
1308 
1309 // FIXME: This function may not work if the emphasis mark uses a complex script, but none of the
1310 // standard emphasis marks do so.
1311 Optional&lt;GlyphData&gt; FontCascade::getEmphasisMarkGlyphData(const AtomicString&amp; mark) const
1312 {
1313     if (mark.isEmpty())
1314         return WTF::nullopt;
1315 
1316     UChar32 character;
1317     if (!mark.is8Bit()) {
1318         SurrogatePairAwareTextIterator iterator(mark.characters16(), 0, mark.length(), mark.length());
1319         unsigned clusterLength;
1320         if (!iterator.consume(character, clusterLength))
1321             return WTF::nullopt;
1322     } else
1323         character = mark[0];
1324 
1325     Optional&lt;GlyphData&gt; glyphData(glyphDataForCharacter(character, false, EmphasisMarkVariant));
1326     return glyphData.value().isValid() ? glyphData : WTF::nullopt;
1327 }
1328 
1329 int FontCascade::emphasisMarkAscent(const AtomicString&amp; mark) const
1330 {
1331     Optional&lt;GlyphData&gt; markGlyphData = getEmphasisMarkGlyphData(mark);
1332     if (!markGlyphData)
1333         return 0;
1334 
1335     const Font* markFontData = markGlyphData.value().font;
1336     ASSERT(markFontData);
1337     if (!markFontData)
1338         return 0;
1339 
1340     return markFontData-&gt;fontMetrics().ascent();
1341 }
1342 
1343 int FontCascade::emphasisMarkDescent(const AtomicString&amp; mark) const
1344 {
1345     Optional&lt;GlyphData&gt; markGlyphData = getEmphasisMarkGlyphData(mark);
1346     if (!markGlyphData)
1347         return 0;
1348 
1349     const Font* markFontData = markGlyphData.value().font;
1350     ASSERT(markFontData);
1351     if (!markFontData)
1352         return 0;
1353 
1354     return markFontData-&gt;fontMetrics().descent();
1355 }
1356 
1357 int FontCascade::emphasisMarkHeight(const AtomicString&amp; mark) const
1358 {
1359     Optional&lt;GlyphData&gt; markGlyphData = getEmphasisMarkGlyphData(mark);
1360     if (!markGlyphData)
1361         return 0;
1362 
1363     const Font* markFontData = markGlyphData.value().font;
1364     ASSERT(markFontData);
1365     if (!markFontData)
1366         return 0;
1367 
1368     return markFontData-&gt;fontMetrics().height();
1369 }
1370 
1371 float FontCascade::getGlyphsAndAdvancesForSimpleText(const TextRun&amp; run, unsigned from, unsigned to, GlyphBuffer&amp; glyphBuffer, ForTextEmphasisOrNot forTextEmphasis) const
1372 {
1373     float initialAdvance;
1374 
1375     WidthIterator it(this, run, 0, false, forTextEmphasis);
1376     // FIXME: Using separate glyph buffers for the prefix and the suffix is incorrect when kerning or
1377     // ligatures are enabled.
1378     GlyphBuffer localGlyphBuffer;
1379     it.advance(from, &amp;localGlyphBuffer);
1380     float beforeWidth = it.m_runWidthSoFar;
1381     it.advance(to, &amp;glyphBuffer);
1382 
1383     if (glyphBuffer.isEmpty())
1384         return 0;
1385 
1386     float afterWidth = it.m_runWidthSoFar;
1387 
1388     if (run.rtl()) {
1389         float finalRoundingWidth = it.m_finalRoundingWidth;
1390         it.advance(run.length(), &amp;localGlyphBuffer);
1391         initialAdvance = finalRoundingWidth + it.m_runWidthSoFar - afterWidth;
1392     } else
1393         initialAdvance = beforeWidth;
1394 
1395     if (run.rtl())
1396         glyphBuffer.reverse(0, glyphBuffer.size());
1397 
1398     return initialAdvance;
1399 }
1400 
1401 #if !PLATFORM(WIN)
1402 float FontCascade::getGlyphsAndAdvancesForComplexText(const TextRun&amp; run, unsigned from, unsigned to, GlyphBuffer&amp; glyphBuffer, ForTextEmphasisOrNot forTextEmphasis) const
1403 {
1404     float initialAdvance;
1405 
1406     ComplexTextController controller(*this, run, false, 0, forTextEmphasis);
1407     GlyphBuffer dummyGlyphBuffer;
1408     controller.advance(from, &amp;dummyGlyphBuffer);
1409     controller.advance(to, &amp;glyphBuffer);
1410 
1411     if (glyphBuffer.isEmpty())
1412         return 0;
1413 
1414     if (run.rtl()) {
1415         // Exploit the fact that the sum of the paint advances is equal to
1416         // the sum of the layout advances.
1417         initialAdvance = controller.totalWidth();
1418         for (unsigned i = 0; i &lt; dummyGlyphBuffer.size(); ++i)
1419             initialAdvance -= dummyGlyphBuffer.advanceAt(i).width();
1420         for (unsigned i = 0; i &lt; glyphBuffer.size(); ++i)
1421             initialAdvance -= glyphBuffer.advanceAt(i).width();
1422         glyphBuffer.reverse(0, glyphBuffer.size());
1423     } else {
1424         initialAdvance = dummyGlyphBuffer.initialAdvance().width();
1425         for (unsigned i = 0; i &lt; dummyGlyphBuffer.size(); ++i)
1426             initialAdvance += dummyGlyphBuffer.advanceAt(i).width();
1427     }
1428 
1429     return initialAdvance;
1430 }
1431 #endif
1432 
1433 void FontCascade::drawEmphasisMarksForSimpleText(GraphicsContext&amp; context, const TextRun&amp; run, const AtomicString&amp; mark, const FloatPoint&amp; point, unsigned from, unsigned to) const
1434 {
1435     GlyphBuffer glyphBuffer;
1436     float initialAdvance = getGlyphsAndAdvancesForSimpleText(run, from, to, glyphBuffer, ForTextEmphasis);
1437 
1438     if (glyphBuffer.isEmpty())
1439         return;
1440 
1441     drawEmphasisMarks(context, glyphBuffer, mark, FloatPoint(point.x() + initialAdvance, point.y()));
1442 }
1443 
1444 inline bool shouldDrawIfLoading(const Font&amp; font, FontCascade::CustomFontNotReadyAction customFontNotReadyAction)
1445 {
1446     // Don&#39;t draw anything while we are using custom fonts that are in the process of loading,
1447     // except if the &#39;customFontNotReadyAction&#39; argument is set to UseFallbackIfFontNotReady
1448     // (in which case &quot;font&quot; will be a fallback font).
1449     return !font.isInterstitial() || font.visibility() == Font::Visibility::Visible || customFontNotReadyAction == FontCascade::CustomFontNotReadyAction::UseFallbackIfFontNotReady;
1450 }
1451 
1452 void FontCascade::drawGlyphBuffer(GraphicsContext&amp; context, const GlyphBuffer&amp; glyphBuffer, FloatPoint&amp; point, CustomFontNotReadyAction customFontNotReadyAction) const
1453 {
1454     // Draw each contiguous run of glyphs that use the same font data.
1455     const Font* fontData = glyphBuffer.fontAt(0);
1456 #if PLATFORM(WIN)
1457     FloatPoint startPoint(point.x() + glyphBuffer.initialAdvance().width(), point.y() + glyphBuffer.initialAdvance().height());
1458 #else
1459     // FIXME: Why do we subtract the initial advance&#39;s height but not its width???
1460     // We should use the line above from Windows instead.
1461     FloatPoint startPoint(point.x(), point.y() - glyphBuffer.initialAdvance().height());
1462 #endif
1463     float nextX = startPoint.x() + glyphBuffer.advanceAt(0).width();
1464     float nextY = startPoint.y() + glyphBuffer.advanceAt(0).height();
1465     unsigned lastFrom = 0;
1466     unsigned nextGlyph = 1;
1467     while (nextGlyph &lt; glyphBuffer.size()) {
1468         const Font* nextFontData = glyphBuffer.fontAt(nextGlyph);
1469 
1470         if (nextFontData != fontData) {
1471             if (shouldDrawIfLoading(*fontData, customFontNotReadyAction))
1472                 context.drawGlyphs(*fontData, glyphBuffer, lastFrom, nextGlyph - lastFrom, startPoint, m_fontDescription.fontSmoothing());
1473 
1474             lastFrom = nextGlyph;
1475             fontData = nextFontData;
1476             startPoint.setX(nextX);
1477             startPoint.setY(nextY);
1478         }
1479         nextX += glyphBuffer.advanceAt(nextGlyph).width();
1480         nextY += glyphBuffer.advanceAt(nextGlyph).height();
1481         nextGlyph++;
1482     }
1483 
1484     if (shouldDrawIfLoading(*fontData, customFontNotReadyAction))
1485         context.drawGlyphs(*fontData, glyphBuffer, lastFrom, nextGlyph - lastFrom, startPoint, m_fontDescription.fontSmoothing());
1486     point.setX(nextX);
1487 }
1488 
1489 inline static float offsetToMiddleOfGlyph(const Font* fontData, Glyph glyph)
1490 {
1491     if (fontData-&gt;platformData().orientation() == FontOrientation::Horizontal) {
1492         FloatRect bounds = fontData-&gt;boundsForGlyph(glyph);
1493         return bounds.x() + bounds.width() / 2;
1494     }
1495     // FIXME: Use glyph bounds once they make sense for vertical fonts.
1496     return fontData-&gt;widthForGlyph(glyph) / 2;
1497 }
1498 
1499 inline static float offsetToMiddleOfGlyphAtIndex(const GlyphBuffer&amp; glyphBuffer, unsigned i)
1500 {
1501     return offsetToMiddleOfGlyph(glyphBuffer.fontAt(i), glyphBuffer.glyphAt(i));
1502 }
1503 
1504 void FontCascade::drawEmphasisMarks(GraphicsContext&amp; context, const GlyphBuffer&amp; glyphBuffer, const AtomicString&amp; mark, const FloatPoint&amp; point) const
1505 {
1506     Optional&lt;GlyphData&gt; markGlyphData = getEmphasisMarkGlyphData(mark);
1507     if (!markGlyphData)
1508         return;
1509 
1510     const Font* markFontData = markGlyphData.value().font;
1511     ASSERT(markFontData);
1512     if (!markFontData)
1513         return;
1514 
1515     Glyph markGlyph = markGlyphData.value().glyph;
1516     Glyph spaceGlyph = markFontData-&gt;spaceGlyph();
1517 
1518     float middleOfLastGlyph = offsetToMiddleOfGlyphAtIndex(glyphBuffer, 0);
1519     FloatPoint startPoint(point.x() + middleOfLastGlyph - offsetToMiddleOfGlyph(markFontData, markGlyph), point.y());
1520 
1521     GlyphBuffer markBuffer;
1522     for (unsigned i = 0; i + 1 &lt; glyphBuffer.size(); ++i) {
1523         float middleOfNextGlyph = offsetToMiddleOfGlyphAtIndex(glyphBuffer, i + 1);
1524         float advance = glyphBuffer.advanceAt(i).width() - middleOfLastGlyph + middleOfNextGlyph;
1525         markBuffer.add(glyphBuffer.glyphAt(i) ? markGlyph : spaceGlyph, markFontData, advance);
1526         middleOfLastGlyph = middleOfNextGlyph;
1527     }
1528     markBuffer.add(glyphBuffer.glyphAt(glyphBuffer.size() - 1) ? markGlyph : spaceGlyph, markFontData, 0);
1529 
1530     drawGlyphBuffer(context, markBuffer, startPoint, CustomFontNotReadyAction::DoNotPaintIfFontNotReady);
1531 }
1532 
1533 float FontCascade::floatWidthForSimpleText(const TextRun&amp; run, HashSet&lt;const Font*&gt;* fallbackFonts, GlyphOverflow* glyphOverflow) const
1534 {
1535     WidthIterator it(this, run, fallbackFonts, glyphOverflow);
1536     GlyphBuffer glyphBuffer;
1537     it.advance(run.length(), (enableKerning() || requiresShaping()) ? &amp;glyphBuffer : nullptr);
1538 
1539     if (glyphOverflow) {
1540         glyphOverflow-&gt;top = std::max&lt;int&gt;(glyphOverflow-&gt;top, ceilf(-it.minGlyphBoundingBoxY()) - (glyphOverflow-&gt;computeBounds ? 0 : fontMetrics().ascent()));
1541         glyphOverflow-&gt;bottom = std::max&lt;int&gt;(glyphOverflow-&gt;bottom, ceilf(it.maxGlyphBoundingBoxY()) - (glyphOverflow-&gt;computeBounds ? 0 : fontMetrics().descent()));
1542         glyphOverflow-&gt;left = ceilf(it.firstGlyphOverflow());
1543         glyphOverflow-&gt;right = ceilf(it.lastGlyphOverflow());
1544     }
1545 
1546     return it.m_runWidthSoFar;
1547 }
1548 
1549 #if !PLATFORM(WIN)
1550 float FontCascade::floatWidthForComplexText(const TextRun&amp; run, HashSet&lt;const Font*&gt;* fallbackFonts, GlyphOverflow* glyphOverflow) const
1551 {
1552     ComplexTextController controller(*this, run, true, fallbackFonts);
1553     if (glyphOverflow) {
1554         glyphOverflow-&gt;top = std::max&lt;int&gt;(glyphOverflow-&gt;top, ceilf(-controller.minGlyphBoundingBoxY()) - (glyphOverflow-&gt;computeBounds ? 0 : fontMetrics().ascent()));
1555         glyphOverflow-&gt;bottom = std::max&lt;int&gt;(glyphOverflow-&gt;bottom, ceilf(controller.maxGlyphBoundingBoxY()) - (glyphOverflow-&gt;computeBounds ? 0 : fontMetrics().descent()));
1556         glyphOverflow-&gt;left = std::max&lt;int&gt;(0, ceilf(-controller.minGlyphBoundingBoxX()));
1557         glyphOverflow-&gt;right = std::max&lt;int&gt;(0, ceilf(controller.maxGlyphBoundingBoxX() - controller.totalWidth()));
1558     }
1559     return controller.totalWidth();
1560 }
1561 #endif
1562 
1563 void FontCascade::adjustSelectionRectForSimpleText(const TextRun&amp; run, LayoutRect&amp; selectionRect, unsigned from, unsigned to) const
1564 {
1565     GlyphBuffer glyphBuffer;
1566     WidthIterator it(this, run);
1567     it.advance(from, &amp;glyphBuffer);
1568     float beforeWidth = it.m_runWidthSoFar;
1569     it.advance(to, &amp;glyphBuffer);
1570     float afterWidth = it.m_runWidthSoFar;
1571     float totalWidth = -1;
1572 
1573     if (run.rtl()) {
1574         it.advance(run.length(), &amp;glyphBuffer);
1575         totalWidth = it.m_runWidthSoFar;
1576         selectionRect.move(totalWidth - afterWidth, 0);
1577     } else
1578         selectionRect.move(beforeWidth, 0);
1579     selectionRect.setWidth(LayoutUnit::fromFloatCeil(afterWidth - beforeWidth));
1580 }
1581 
1582 #if !PLATFORM(WIN)
1583 void FontCascade::adjustSelectionRectForComplexText(const TextRun&amp; run, LayoutRect&amp; selectionRect, unsigned from, unsigned to) const
1584 {
1585     ComplexTextController controller(*this, run);
1586     controller.advance(from);
1587     float beforeWidth = controller.runWidthSoFar();
1588     controller.advance(to);
1589     float afterWidth = controller.runWidthSoFar();
1590 
1591     if (run.rtl())
1592         selectionRect.move(controller.totalWidth() - afterWidth, 0);
1593     else
1594         selectionRect.move(beforeWidth, 0);
1595     selectionRect.setWidth(LayoutUnit::fromFloatCeil(afterWidth - beforeWidth));
1596 }
1597 #endif
1598 
1599 int FontCascade::offsetForPositionForSimpleText(const TextRun&amp; run, float x, bool includePartialGlyphs) const
1600 {
1601     float delta = x;
1602 
1603     WidthIterator it(this, run);
1604     GlyphBuffer localGlyphBuffer;
1605     unsigned offset;
1606     if (run.rtl()) {
1607         delta -= floatWidthForSimpleText(run);
1608         while (1) {
1609             offset = it.m_currentCharacter;
1610             float w;
1611             if (!it.advanceOneCharacter(w, localGlyphBuffer))
1612                 break;
1613             delta += w;
1614             if (includePartialGlyphs) {
1615                 if (delta - w / 2 &gt;= 0)
1616                     break;
1617             } else {
1618                 if (delta &gt;= 0)
1619                     break;
1620             }
1621         }
1622     } else {
1623         while (1) {
1624             offset = it.m_currentCharacter;
1625             float w;
1626             if (!it.advanceOneCharacter(w, localGlyphBuffer))
1627                 break;
1628             delta -= w;
1629             if (includePartialGlyphs) {
1630                 if (delta + w / 2 &lt;= 0)
1631                     break;
1632             } else {
1633                 if (delta &lt;= 0)
1634                     break;
1635             }
1636         }
1637     }
1638 
1639     return offset;
1640 }
1641 
1642 #if !PLATFORM(WIN)
1643 int FontCascade::offsetForPositionForComplexText(const TextRun&amp; run, float x, bool includePartialGlyphs) const
1644 {
1645     ComplexTextController controller(*this, run);
1646     return controller.offsetForPosition(x, includePartialGlyphs);
1647 }
1648 #endif
1649 
1650 #if !PLATFORM(COCOA) &amp;&amp; !USE(HARFBUZZ)
1651 // FIXME: Unify this with the macOS and iOS implementation.
1652 const Font* FontCascade::fontForCombiningCharacterSequence(const UChar* characters, size_t length) const
1653 {
1654     UChar32 baseCharacter;
1655     size_t baseCharacterLength = 0;
1656     U16_NEXT(characters, baseCharacterLength, length, baseCharacter);
1657     GlyphData baseCharacterGlyphData = glyphDataForCharacter(baseCharacter, false, NormalVariant);
1658 
1659     if (!baseCharacterGlyphData.glyph)
1660         return nullptr;
1661     return baseCharacterGlyphData.font;
1662 }
1663 #endif
1664 
1665 void FontCascade::drawEmphasisMarksForComplexText(GraphicsContext&amp; context, const TextRun&amp; run, const AtomicString&amp; mark, const FloatPoint&amp; point, unsigned from, unsigned to) const
1666 {
1667     GlyphBuffer glyphBuffer;
1668     float initialAdvance = getGlyphsAndAdvancesForComplexText(run, from, to, glyphBuffer, ForTextEmphasis);
1669 
1670     if (glyphBuffer.isEmpty())
1671         return;
1672 
1673     drawEmphasisMarks(context, glyphBuffer, mark, FloatPoint(point.x() + initialAdvance, point.y()));
1674 }
1675 
1676 struct GlyphIterationState {
1677     FloatPoint startingPoint;
1678     FloatPoint currentPoint;
1679     float y1;
1680     float y2;
1681     float minX;
1682     float maxX;
1683 };
1684 
1685 static Optional&lt;float&gt; findIntersectionPoint(float y, FloatPoint p1, FloatPoint p2)
1686 {
1687     if ((p1.y() &lt; y &amp;&amp; p2.y() &gt; y) || (p1.y() &gt; y &amp;&amp; p2.y() &lt; y))
1688         return p1.x() + (y - p1.y()) * (p2.x() - p1.x()) / (p2.y() - p1.y());
1689     return WTF::nullopt;
1690 }
1691 
1692 static void updateX(GlyphIterationState&amp; state, float x)
1693 {
1694     state.minX = std::min(state.minX, x);
1695     state.maxX = std::max(state.maxX, x);
1696 }
1697 
1698 // This function is called by CGPathApply and is therefore invoked for each
1699 // contour in a glyph. This function models each contours as a straight line
1700 // and calculates the intersections between each pseudo-contour and
1701 // two horizontal lines (the upper and lower bounds of an underline) found in
1702 // GlyphIterationState::y1 and GlyphIterationState::y2. It keeps track of the
1703 // leftmost and rightmost intersection in GlyphIterationState::minX and
1704 // GlyphIterationState::maxX.
1705 static void findPathIntersections(GlyphIterationState&amp; state, const PathElement&amp; element)
1706 {
1707     bool doIntersection = false;
1708     FloatPoint point = FloatPoint();
1709     switch (element.type) {
1710     case PathElementMoveToPoint:
1711         state.startingPoint = element.points[0];
1712         state.currentPoint = element.points[0];
1713         break;
1714     case PathElementAddLineToPoint:
1715         doIntersection = true;
1716         point = element.points[0];
1717         break;
1718     case PathElementAddQuadCurveToPoint:
1719         doIntersection = true;
1720         point = element.points[1];
1721         break;
1722     case PathElementAddCurveToPoint:
1723         doIntersection = true;
1724         point = element.points[2];
1725         break;
1726     case PathElementCloseSubpath:
1727         doIntersection = true;
1728         point = state.startingPoint;
1729         break;
1730     }
1731     if (!doIntersection)
1732         return;
1733     if (auto intersectionPoint = findIntersectionPoint(state.y1, state.currentPoint, point))
1734         updateX(state, *intersectionPoint);
1735     if (auto intersectionPoint = findIntersectionPoint(state.y2, state.currentPoint, point))
1736         updateX(state, *intersectionPoint);
1737     if ((state.currentPoint.y() &gt;= state.y1 &amp;&amp; state.currentPoint.y() &lt;= state.y2)
1738         || (state.currentPoint.y() &lt;= state.y1 &amp;&amp; state.currentPoint.y() &gt;= state.y2))
1739         updateX(state, state.currentPoint.x());
1740     state.currentPoint = point;
1741 }
1742 
1743 class GlyphToPathTranslator {
1744 public:
1745     GlyphToPathTranslator(const TextRun&amp; textRun, const GlyphBuffer&amp; glyphBuffer, const FloatPoint&amp; textOrigin)
1746         : m_index(0)
1747         , m_textRun(textRun)
1748         , m_glyphBuffer(glyphBuffer)
1749         , m_fontData(glyphBuffer.fontAt(m_index))
1750         , m_translation(AffineTransform::translation(textOrigin.x(), textOrigin.y()))
1751     {
1752 #if USE(CG)
1753         m_translation.flipY();
1754 #endif
1755     }
1756 
1757     bool containsMorePaths() { return m_index != m_glyphBuffer.size(); }
1758     Path path();
1759     std::pair&lt;float, float&gt; extents();
1760     GlyphUnderlineType underlineType();
1761     void advance();
1762 
1763 private:
1764     unsigned m_index;
1765     const TextRun&amp; m_textRun;
1766     const GlyphBuffer&amp; m_glyphBuffer;
1767     const Font* m_fontData;
1768     AffineTransform m_translation;
1769 };
1770 
1771 Path GlyphToPathTranslator::path()
1772 {
1773     Path path = m_fontData-&gt;pathForGlyph(m_glyphBuffer.glyphAt(m_index));
1774     path.transform(m_translation);
1775     return path;
1776 }
1777 
1778 std::pair&lt;float, float&gt; GlyphToPathTranslator::extents()
1779 {
1780     auto beginning = m_translation.mapPoint(FloatPoint(0, 0));
1781     auto advance = m_glyphBuffer.advanceAt(m_index);
1782     auto end = m_translation.mapSize(FloatSize(advance.width(), advance.height()));
1783     return std::make_pair(beginning.x(), beginning.x() + end.width());
1784 }
1785 
1786 auto GlyphToPathTranslator::underlineType() -&gt; GlyphUnderlineType
1787 {
1788     return computeUnderlineType(m_textRun, m_glyphBuffer, m_index);
1789 }
1790 
1791 void GlyphToPathTranslator::advance()
1792 {
1793     GlyphBufferAdvance advance = m_glyphBuffer.advanceAt(m_index);
1794     m_translation.translate(FloatSize(advance.width(), advance.height()));
1795     ++m_index;
1796     if (m_index &lt; m_glyphBuffer.size())
1797         m_fontData = m_glyphBuffer.fontAt(m_index);
1798 }
1799 
1800 DashArray FontCascade::dashesForIntersectionsWithRect(const TextRun&amp; run, const FloatPoint&amp; textOrigin, const FloatRect&amp; lineExtents) const
1801 {
1802     if (isLoadingCustomFonts())
1803         return DashArray();
1804 
1805     GlyphBuffer glyphBuffer;
1806     glyphBuffer.saveOffsetsInString();
1807     float deltaX;
1808     if (codePath(run) != FontCascade::Complex)
1809         deltaX = getGlyphsAndAdvancesForSimpleText(run, 0, run.length(), glyphBuffer);
1810     else
1811         deltaX = getGlyphsAndAdvancesForComplexText(run, 0, run.length(), glyphBuffer);
1812 
1813     if (!glyphBuffer.size())
1814         return DashArray();
1815 
1816     FloatPoint origin = FloatPoint(textOrigin.x() + deltaX, textOrigin.y());
1817     GlyphToPathTranslator translator(run, glyphBuffer, origin);
1818     DashArray result;
1819     for (unsigned index = 0; translator.containsMorePaths(); ++index, translator.advance()) {
1820         GlyphIterationState info = { FloatPoint(0, 0), FloatPoint(0, 0), lineExtents.y(), lineExtents.y() + lineExtents.height(), lineExtents.x() + lineExtents.width(), lineExtents.x() };
1821         const Font* localFont = glyphBuffer.fontAt(index);
1822         if (!localFont) {
1823             // The advances will get all messed up if we do anything other than bail here.
1824             result.clear();
1825             break;
1826         }
1827         switch (translator.underlineType()) {
1828         case GlyphUnderlineType::SkipDescenders: {
1829             Path path = translator.path();
1830             path.apply([&amp;](const PathElement&amp; element) {
1831                 findPathIntersections(info, element);
1832             });
1833             if (info.minX &lt; info.maxX) {
1834                 result.append(info.minX - lineExtents.x());
1835                 result.append(info.maxX - lineExtents.x());
1836             }
1837             break;
1838         }
1839         case GlyphUnderlineType::SkipGlyph: {
1840             std::pair&lt;float, float&gt; extents = translator.extents();
1841             result.append(extents.first - lineExtents.x());
1842             result.append(extents.second - lineExtents.x());
1843             break;
1844         }
1845         case GlyphUnderlineType::DrawOverGlyph:
1846             // Nothing to do
1847             break;
1848         }
1849     }
1850     return result;
1851 }
1852 
1853 }
    </pre>
  </body>
</html>