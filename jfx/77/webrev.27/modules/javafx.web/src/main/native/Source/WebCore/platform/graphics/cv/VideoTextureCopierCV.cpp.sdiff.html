<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/cv/VideoTextureCopierCV.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="TextureCacheCV.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="VideoTextureCopierCV.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/cv/VideoTextureCopierCV.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 44 
 45 namespace WebCore {
 46 
 47 #if HAVE(IOSURFACE)
 48 enum class PixelRange {
 49     Unknown,
 50     Video,
 51     Full,
 52 };
 53 
 54 enum class TransferFunction {
 55     Unknown,
 56     kITU_R_709_2,
 57     kITU_R_601_4,
 58     kSMPTE_240M_1995,
 59     kDCI_P3,
 60     kP3_D65,
 61     kITU_R_2020,
 62 };
 63 
<span class="line-removed"> 64 #if PLATFORM(MAC) &amp;&amp; __MAC_OS_X_VERSION_MIN_REQUIRED &lt; 101300</span>
<span class="line-removed"> 65 enum {</span>
<span class="line-removed"> 66     kCVPixelFormatType_ARGB2101010LEPacked = &#39;l10r&#39;,</span>
<span class="line-removed"> 67     kCVPixelFormatType_420YpCbCr10BiPlanarVideoRange = &#39;x420&#39;,</span>
<span class="line-removed"> 68     kCVPixelFormatType_422YpCbCr10BiPlanarVideoRange = &#39;x422&#39;,</span>
<span class="line-removed"> 69     kCVPixelFormatType_444YpCbCr10BiPlanarVideoRange = &#39;x444&#39;,</span>
<span class="line-removed"> 70     kCVPixelFormatType_420YpCbCr10BiPlanarFullRange  = &#39;xf20&#39;,</span>
<span class="line-removed"> 71     kCVPixelFormatType_422YpCbCr10BiPlanarFullRange  = &#39;xf22&#39;,</span>
<span class="line-removed"> 72     kCVPixelFormatType_444YpCbCr10BiPlanarFullRange  = &#39;xf44&#39;,</span>
<span class="line-removed"> 73 };</span>
<span class="line-removed"> 74 #endif</span>
<span class="line-removed"> 75 </span>
 76 static PixelRange pixelRangeFromPixelFormat(OSType pixelFormat)
 77 {
 78     switch (pixelFormat) {
 79     case kCVPixelFormatType_4444AYpCbCr8:
 80     case kCVPixelFormatType_4444AYpCbCr16:
 81     case kCVPixelFormatType_422YpCbCr_4A_8BiPlanar:
 82     case kCVPixelFormatType_420YpCbCr8BiPlanarVideoRange:
 83     case kCVPixelFormatType_420YpCbCr10BiPlanarVideoRange:
 84     case kCVPixelFormatType_422YpCbCr10BiPlanarVideoRange:
 85     case kCVPixelFormatType_444YpCbCr10BiPlanarVideoRange:
 86         return PixelRange::Video;
 87     case kCVPixelFormatType_420YpCbCr8PlanarFullRange:
 88     case kCVPixelFormatType_420YpCbCr8BiPlanarFullRange:
 89     case kCVPixelFormatType_422YpCbCr8FullRange:
 90     case kCVPixelFormatType_ARGB2101010LEPacked:
 91     case kCVPixelFormatType_420YpCbCr10BiPlanarFullRange:
 92     case kCVPixelFormatType_422YpCbCr10BiPlanarFullRange:
 93     case kCVPixelFormatType_444YpCbCr10BiPlanarFullRange:
 94         return PixelRange::Full;
 95     default:
 96         return PixelRange::Unknown;
 97     }
 98 }
 99 
100 static TransferFunction transferFunctionFromString(CFStringRef string)
101 {


102     if (CFEqual(string, kCVImageBufferYCbCrMatrix_ITU_R_709_2))
103         return TransferFunction::kITU_R_709_2;
104     if (CFEqual(string, kCVImageBufferYCbCrMatrix_ITU_R_601_4))
105         return TransferFunction::kITU_R_601_4;
106     if (CFEqual(string, kCVImageBufferYCbCrMatrix_SMPTE_240M_1995))
107         return TransferFunction::kSMPTE_240M_1995;
108     if (canLoad_CoreVideo_kCVImageBufferYCbCrMatrix_DCI_P3() &amp;&amp; CFEqual(string, kCVImageBufferYCbCrMatrix_DCI_P3))
109         return TransferFunction::kDCI_P3;
110     if (canLoad_CoreVideo_kCVImageBufferYCbCrMatrix_P3_D65() &amp;&amp; CFEqual(string, kCVImageBufferYCbCrMatrix_P3_D65))
111         return TransferFunction::kP3_D65;
112     if (canLoad_CoreVideo_kCVImageBufferYCbCrMatrix_ITU_R_2020() &amp;&amp; CFEqual(string, kCVImageBufferYCbCrMatrix_ITU_R_2020))
113         return TransferFunction::kITU_R_2020;
114     return TransferFunction::Unknown;
115 }
116 
117 struct GLfloatColor {
118     union {
119         struct {
120             GLfloat r;
121             GLfloat g;
</pre>
<hr />
<pre>
384 {
385     if (m_vertexBuffer)
386         m_context-&gt;deleteProgram(m_vertexBuffer);
387     if (m_program)
388         m_context-&gt;deleteProgram(m_program);
389     if (m_yuvVertexBuffer)
390         m_context-&gt;deleteProgram(m_yuvVertexBuffer);
391     if (m_yuvProgram)
392         m_context-&gt;deleteProgram(m_yuvProgram);
393     m_context-&gt;deleteFramebuffer(m_framebuffer);
394 }
395 
396 #if !LOG_DISABLED
397 using StringMap = StdMap&lt;uint32_t, const char*&gt;;
398 #define STRINGIFY_PAIR(e) e, #e
399 static StringMap&amp; enumToStringMap()
400 {
401     static NeverDestroyed&lt;StringMap&gt; map;
402     if (map.get().empty()) {
403         StringMap stringMap;
<span class="line-modified">404         map.get().emplace(STRINGIFY_PAIR(GL_RGB));</span>
<span class="line-modified">405         map.get().emplace(STRINGIFY_PAIR(GL_RGBA));</span>
<span class="line-modified">406         map.get().emplace(STRINGIFY_PAIR(GL_LUMINANCE_ALPHA));</span>
<span class="line-modified">407         map.get().emplace(STRINGIFY_PAIR(GL_LUMINANCE));</span>
<span class="line-modified">408         map.get().emplace(STRINGIFY_PAIR(GL_ALPHA));</span>
<span class="line-modified">409         map.get().emplace(STRINGIFY_PAIR(GL_R8));</span>
<span class="line-modified">410         map.get().emplace(STRINGIFY_PAIR(GL_R16F));</span>
<span class="line-modified">411         map.get().emplace(STRINGIFY_PAIR(GL_R32F));</span>
<span class="line-modified">412         map.get().emplace(STRINGIFY_PAIR(GL_R8UI));</span>
<span class="line-modified">413         map.get().emplace(STRINGIFY_PAIR(GL_R8I));</span>
<span class="line-modified">414         map.get().emplace(STRINGIFY_PAIR(GL_R16UI));</span>
<span class="line-modified">415         map.get().emplace(STRINGIFY_PAIR(GL_R16I));</span>
<span class="line-modified">416         map.get().emplace(STRINGIFY_PAIR(GL_R32UI));</span>
<span class="line-modified">417         map.get().emplace(STRINGIFY_PAIR(GL_R32I));</span>
<span class="line-modified">418         map.get().emplace(STRINGIFY_PAIR(GL_RG8));</span>
<span class="line-modified">419         map.get().emplace(STRINGIFY_PAIR(GL_RG16F));</span>
<span class="line-modified">420         map.get().emplace(STRINGIFY_PAIR(GL_RG32F));</span>
<span class="line-modified">421         map.get().emplace(STRINGIFY_PAIR(GL_RG8UI));</span>
<span class="line-modified">422         map.get().emplace(STRINGIFY_PAIR(GL_RG8I));</span>
<span class="line-modified">423         map.get().emplace(STRINGIFY_PAIR(GL_RG16UI));</span>
<span class="line-modified">424         map.get().emplace(STRINGIFY_PAIR(GL_RG16I));</span>
<span class="line-modified">425         map.get().emplace(STRINGIFY_PAIR(GL_RG32UI));</span>
<span class="line-modified">426         map.get().emplace(STRINGIFY_PAIR(GL_RG32I));</span>
<span class="line-modified">427         map.get().emplace(STRINGIFY_PAIR(GL_RGB8));</span>
<span class="line-modified">428         map.get().emplace(STRINGIFY_PAIR(GL_SRGB8));</span>
<span class="line-modified">429         map.get().emplace(STRINGIFY_PAIR(GL_RGBA8));</span>
<span class="line-modified">430         map.get().emplace(STRINGIFY_PAIR(GL_SRGB8_ALPHA8));</span>
<span class="line-modified">431         map.get().emplace(STRINGIFY_PAIR(GL_RGBA4));</span>
<span class="line-modified">432         map.get().emplace(STRINGIFY_PAIR(GL_RGB10_A2));</span>
<span class="line-modified">433         map.get().emplace(STRINGIFY_PAIR(GL_DEPTH_COMPONENT16));</span>
<span class="line-modified">434         map.get().emplace(STRINGIFY_PAIR(GL_DEPTH_COMPONENT24));</span>
<span class="line-modified">435         map.get().emplace(STRINGIFY_PAIR(GL_DEPTH_COMPONENT32F));</span>
<span class="line-modified">436         map.get().emplace(STRINGIFY_PAIR(GL_DEPTH24_STENCIL8));</span>
<span class="line-modified">437         map.get().emplace(STRINGIFY_PAIR(GL_DEPTH32F_STENCIL8));</span>
<span class="line-modified">438         map.get().emplace(STRINGIFY_PAIR(GL_RGB));</span>
<span class="line-modified">439         map.get().emplace(STRINGIFY_PAIR(GL_RGBA));</span>
<span class="line-modified">440         map.get().emplace(STRINGIFY_PAIR(GL_LUMINANCE_ALPHA));</span>
<span class="line-modified">441         map.get().emplace(STRINGIFY_PAIR(GL_LUMINANCE));</span>
<span class="line-modified">442         map.get().emplace(STRINGIFY_PAIR(GL_ALPHA));</span>
<span class="line-modified">443         map.get().emplace(STRINGIFY_PAIR(GL_RED));</span>
<span class="line-modified">444         map.get().emplace(STRINGIFY_PAIR(GL_RG_INTEGER));</span>
<span class="line-modified">445         map.get().emplace(STRINGIFY_PAIR(GL_DEPTH_STENCIL));</span>
<span class="line-modified">446         map.get().emplace(STRINGIFY_PAIR(GL_UNSIGNED_BYTE));</span>
<span class="line-modified">447         map.get().emplace(STRINGIFY_PAIR(GL_UNSIGNED_SHORT_5_6_5));</span>
<span class="line-modified">448         map.get().emplace(STRINGIFY_PAIR(GL_UNSIGNED_SHORT_4_4_4_4));</span>
<span class="line-modified">449         map.get().emplace(STRINGIFY_PAIR(GL_UNSIGNED_SHORT_5_5_5_1));</span>
<span class="line-modified">450         map.get().emplace(STRINGIFY_PAIR(GL_BYTE));</span>
<span class="line-modified">451         map.get().emplace(STRINGIFY_PAIR(GL_HALF_FLOAT));</span>
<span class="line-modified">452         map.get().emplace(STRINGIFY_PAIR(GL_FLOAT));</span>
<span class="line-modified">453         map.get().emplace(STRINGIFY_PAIR(GL_UNSIGNED_SHORT));</span>
<span class="line-modified">454         map.get().emplace(STRINGIFY_PAIR(GL_SHORT));</span>
<span class="line-modified">455         map.get().emplace(STRINGIFY_PAIR(GL_UNSIGNED_INT));</span>
<span class="line-modified">456         map.get().emplace(STRINGIFY_PAIR(GL_INT));</span>
<span class="line-modified">457         map.get().emplace(STRINGIFY_PAIR(GL_UNSIGNED_INT_2_10_10_10_REV));</span>
<span class="line-modified">458         map.get().emplace(STRINGIFY_PAIR(GL_UNSIGNED_INT_24_8));</span>
<span class="line-modified">459         map.get().emplace(STRINGIFY_PAIR(GL_FLOAT_32_UNSIGNED_INT_24_8_REV));</span>
460 
461 #if USE(OPENGL_ES)
462         map.get().emplace(STRINGIFY_PAIR(GL_RED_INTEGER));
463         map.get().emplace(STRINGIFY_PAIR(GL_RGB_INTEGER));
464         map.get().emplace(STRINGIFY_PAIR(GL_RG8_SNORM));
465         map.get().emplace(STRINGIFY_PAIR(GL_RGB565));
466         map.get().emplace(STRINGIFY_PAIR(GL_RGB8_SNORM));
467         map.get().emplace(STRINGIFY_PAIR(GL_R11F_G11F_B10F));
468         map.get().emplace(STRINGIFY_PAIR(GL_RGB9_E5));
469         map.get().emplace(STRINGIFY_PAIR(GL_RGB16F));
470         map.get().emplace(STRINGIFY_PAIR(GL_RGB32F));
471         map.get().emplace(STRINGIFY_PAIR(GL_RGB8UI));
472         map.get().emplace(STRINGIFY_PAIR(GL_RGB8I));
473         map.get().emplace(STRINGIFY_PAIR(GL_RGB16UI));
474         map.get().emplace(STRINGIFY_PAIR(GL_RGB16I));
475         map.get().emplace(STRINGIFY_PAIR(GL_RGB32UI));
476         map.get().emplace(STRINGIFY_PAIR(GL_RGB32I));
477         map.get().emplace(STRINGIFY_PAIR(GL_RGBA8_SNORM));
478         map.get().emplace(STRINGIFY_PAIR(GL_RGBA16F));
479         map.get().emplace(STRINGIFY_PAIR(GL_RGBA32F));
</pre>
<hr />
<pre>
511     vertexShaderSource.appendLiteral(&quot;    gl_Position = a_position;\n&quot;);
512     vertexShaderSource.appendLiteral(&quot;}\n&quot;);
513 
514     Platform3DObject vertexShader = m_context-&gt;createShader(GraphicsContext3D::VERTEX_SHADER);
515     m_context-&gt;shaderSource(vertexShader, vertexShaderSource.toString());
516     m_context-&gt;compileShaderDirect(vertexShader);
517 
518     GC3Dint value = 0;
519     m_context-&gt;getShaderiv(vertexShader, GraphicsContext3D::COMPILE_STATUS, &amp;value);
520     if (!value) {
521         LOG(WebGL, &quot;VideoTextureCopierCV::copyVideoTextureToPlatformTexture(%p) - Vertex shader failed to compile.&quot;, this);
522         m_context-&gt;deleteShader(vertexShader);
523         return false;
524     }
525 
526     StringBuilder fragmentShaderSource;
527 
528 #if USE(OPENGL_ES)
529     fragmentShaderSource.appendLiteral(&quot;precision mediump float;\n&quot;);
530     fragmentShaderSource.appendLiteral(&quot;uniform sampler2D u_texture;\n&quot;);
<span class="line-modified">531 #else</span>
532     fragmentShaderSource.appendLiteral(&quot;uniform sampler2DRect u_texture;\n&quot;);





533 #endif
534     fragmentShaderSource.appendLiteral(&quot;varying vec2 v_texturePosition;\n&quot;);
535     fragmentShaderSource.appendLiteral(&quot;uniform int u_premultiply;\n&quot;);
536     fragmentShaderSource.appendLiteral(&quot;uniform vec2 u_textureDimensions;\n&quot;);
537     fragmentShaderSource.appendLiteral(&quot;uniform int u_swapColorChannels;\n&quot;);
538     fragmentShaderSource.appendLiteral(&quot;void main() {\n&quot;);
539     fragmentShaderSource.appendLiteral(&quot;    vec2 texPos = vec2(v_texturePosition.x * u_textureDimensions.x, v_texturePosition.y * u_textureDimensions.y);\n&quot;);
540 #if USE(OPENGL_ES)
541     fragmentShaderSource.appendLiteral(&quot;    vec4 color = texture2D(u_texture, texPos);\n&quot;);
<span class="line-modified">542 #else</span>
543     fragmentShaderSource.appendLiteral(&quot;    vec4 color = texture2DRect(u_texture, texPos);\n&quot;);





544 #endif
545     fragmentShaderSource.appendLiteral(&quot;    if (u_swapColorChannels == 1) {\n&quot;);
546     fragmentShaderSource.appendLiteral(&quot;        color.rgba = color.bgra;\n&quot;);
547     fragmentShaderSource.appendLiteral(&quot;    }\n&quot;);
548     fragmentShaderSource.appendLiteral(&quot;    if (u_premultiply == 1) {\n&quot;);
549     fragmentShaderSource.appendLiteral(&quot;        gl_FragColor = vec4(color.r * color.a, color.g * color.a, color.b * color.a, color.a);\n&quot;);
550     fragmentShaderSource.appendLiteral(&quot;    } else {\n&quot;);
551     fragmentShaderSource.appendLiteral(&quot;        gl_FragColor = color;\n&quot;);
552     fragmentShaderSource.appendLiteral(&quot;    }\n&quot;);
553     fragmentShaderSource.appendLiteral(&quot;}\n&quot;);
554 
555     Platform3DObject fragmentShader = m_context-&gt;createShader(GraphicsContext3D::FRAGMENT_SHADER);
556     m_context-&gt;shaderSource(fragmentShader, fragmentShaderSource.toString());
557     m_context-&gt;compileShaderDirect(fragmentShader);
558 
559     m_context-&gt;getShaderiv(fragmentShader, GraphicsContext3D::COMPILE_STATUS, &amp;value);
560     if (!value) {
561         LOG(WebGL, &quot;VideoTextureCopierCV::copyVideoTextureToPlatformTexture(%p) - Fragment shader failed to compile.&quot;, this);
562         m_context-&gt;deleteShader(vertexShader);
563         m_context-&gt;deleteShader(fragmentShader);
</pre>
<hr />
<pre>
604 }
605 
606 bool VideoTextureCopierCV::initializeUVContextObjects()
607 {
608     String vertexShaderSource {
609         &quot;attribute vec2 a_position;\n&quot;
610         &quot;uniform vec2 u_yTextureSize;\n&quot;
611         &quot;uniform vec2 u_uvTextureSize;\n&quot;
612         &quot;uniform int u_flipY;\n&quot;
613         &quot;varying vec2 v_yTextureCoordinate;\n&quot;
614         &quot;varying vec2 v_uvTextureCoordinate;\n&quot;
615         &quot;void main() {\n&quot;
616         &quot;   gl_Position = vec4(a_position, 0, 1.0);\n&quot;
617         &quot;   vec2 normalizedPosition = a_position * .5 + .5;\n&quot;
618         &quot;   if (u_flipY == 1) {\n&quot;
619         &quot;       normalizedPosition.y = 1.0 - normalizedPosition.y;\n&quot;
620         &quot;   }\n&quot;
621 #if USE(OPENGL_ES)
622         &quot;   v_yTextureCoordinate = normalizedPosition;\n&quot;
623         &quot;   v_uvTextureCoordinate = normalizedPosition;\n&quot;
<span class="line-modified">624 #else</span>
625         &quot;   v_yTextureCoordinate = normalizedPosition * u_yTextureSize;\n&quot;
626         &quot;   v_uvTextureCoordinate = normalizedPosition * u_uvTextureSize;\n&quot;




627 #endif
628         &quot;}\n&quot;_s
629     };
630 
631     Platform3DObject vertexShader = m_context-&gt;createShader(GraphicsContext3D::VERTEX_SHADER);
632     m_context-&gt;shaderSource(vertexShader, vertexShaderSource);
633     m_context-&gt;compileShaderDirect(vertexShader);
634 
635     GC3Dint status = 0;
636     m_context-&gt;getShaderiv(vertexShader, GraphicsContext3D::COMPILE_STATUS, &amp;status);
637     if (!status) {
638         LOG(WebGL, &quot;VideoTextureCopierCV::initializeUVContextObjects(%p) - Vertex shader failed to compile.&quot;, this);
639         m_context-&gt;deleteShader(vertexShader);
640         return false;
641     }
642 
643     String fragmentShaderSource {
644 #if USE(OPENGL_ES)
645         &quot;precision mediump float;\n&quot;
646         &quot;#define SAMPLERTYPE sampler2D\n&quot;
647         &quot;#define TEXTUREFUNC texture2D\n&quot;
<span class="line-modified">648 #else</span>
649         &quot;#define SAMPLERTYPE sampler2DRect\n&quot;
650         &quot;#define TEXTUREFUNC texture2DRect\n&quot;




651 #endif
652         &quot;uniform SAMPLERTYPE u_yTexture;\n&quot;
653         &quot;uniform SAMPLERTYPE u_uvTexture;\n&quot;
654         &quot;uniform mat4 u_colorMatrix;\n&quot;
655         &quot;varying vec2 v_yTextureCoordinate;\n&quot;
656         &quot;varying vec2 v_uvTextureCoordinate;\n&quot;
657         &quot;void main() {\n&quot;
658         &quot;    vec4 yuv;\n&quot;
659         &quot;    yuv.r = TEXTUREFUNC(u_yTexture, v_yTextureCoordinate).r;\n&quot;
660         &quot;    yuv.gb = TEXTUREFUNC(u_uvTexture, v_uvTextureCoordinate).rg;\n&quot;
661         &quot;    yuv.a = 1.0;\n&quot;
662         &quot;    gl_FragColor = yuv * u_colorMatrix;\n&quot;
663         &quot;}\n&quot;_s
664     };
665 
666     Platform3DObject fragmentShader = m_context-&gt;createShader(GraphicsContext3D::FRAGMENT_SHADER);
667     m_context-&gt;shaderSource(fragmentShader, fragmentShaderSource);
668     m_context-&gt;compileShaderDirect(fragmentShader);
669 
670     m_context-&gt;getShaderiv(fragmentShader, GraphicsContext3D::COMPILE_STATUS, &amp;status);
</pre>
<hr />
<pre>
771     m_context-&gt;texImage2DDirect(GraphicsContext3D::TEXTURE_2D, level, internalFormat, width, height, 0, format, type, nullptr);
772 
773     m_context-&gt;framebufferTexture2D(GraphicsContext3D::FRAMEBUFFER, GraphicsContext3D::COLOR_ATTACHMENT0, GraphicsContext3D::TEXTURE_2D, outputTexture, level);
774     GC3Denum status = m_context-&gt;checkFramebufferStatus(GraphicsContext3D::FRAMEBUFFER);
775     if (status != GraphicsContext3D::FRAMEBUFFER_COMPLETE) {
776         LOG(WebGL, &quot;VideoTextureCopierCV::copyVideoTextureToPlatformTexture(%p) - Unable to create framebuffer for outputTexture.&quot;, this);
777         return false;
778     }
779 
780     m_context-&gt;useProgram(m_yuvProgram);
781     m_context-&gt;viewport(0, 0, width, height);
782 
783     // Bind and set up the textures for the video source.
784     auto yPlaneWidth = IOSurfaceGetWidthOfPlane(surface, 0);
785     auto yPlaneHeight = IOSurfaceGetHeightOfPlane(surface, 0);
786     auto uvPlaneWidth = IOSurfaceGetWidthOfPlane(surface, 1);
787     auto uvPlaneHeight = IOSurfaceGetHeightOfPlane(surface, 1);
788 
789 #if USE(OPENGL_ES)
790     GC3Denum videoTextureTarget = GraphicsContext3D::TEXTURE_2D;
<span class="line-modified">791 #else</span>
792     GC3Denum videoTextureTarget = GL_TEXTURE_RECTANGLE_ARB;





793 #endif
794     auto uvTexture = m_context-&gt;createTexture();
795     m_context-&gt;activeTexture(GraphicsContext3D::TEXTURE1);
796     m_context-&gt;bindTexture(videoTextureTarget, uvTexture);
797     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContext3D::TEXTURE_MAG_FILTER, GraphicsContext3D::LINEAR);
798     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContext3D::TEXTURE_MIN_FILTER, GraphicsContext3D::LINEAR);
799     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContext3D::TEXTURE_WRAP_S, GraphicsContext3D::CLAMP_TO_EDGE);
800     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContext3D::TEXTURE_WRAP_T, GraphicsContext3D::CLAMP_TO_EDGE);
<span class="line-modified">801     if (!m_context-&gt;texImageIOSurface2D(videoTextureTarget, GL_RG, uvPlaneWidth, uvPlaneHeight, GL_RG, GL_UNSIGNED_BYTE, surface, 1)) {</span>
802         m_context-&gt;deleteTexture(uvTexture);
803         return false;
804     }
805 
806     auto yTexture = m_context-&gt;createTexture();
807     m_context-&gt;activeTexture(GraphicsContext3D::TEXTURE0);
808     m_context-&gt;bindTexture(videoTextureTarget, yTexture);
809     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContext3D::TEXTURE_MAG_FILTER, GraphicsContext3D::LINEAR);
810     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContext3D::TEXTURE_MIN_FILTER, GraphicsContext3D::LINEAR);
811     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContext3D::TEXTURE_WRAP_S, GraphicsContext3D::CLAMP_TO_EDGE);
812     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContext3D::TEXTURE_WRAP_T, GraphicsContext3D::CLAMP_TO_EDGE);
<span class="line-modified">813     if (!m_context-&gt;texImageIOSurface2D(videoTextureTarget, GL_LUMINANCE, yPlaneWidth, yPlaneHeight, GL_LUMINANCE, GL_UNSIGNED_BYTE, surface, 0)) {</span>
814         m_context-&gt;deleteTexture(yTexture);
815         m_context-&gt;deleteTexture(uvTexture);
816         return false;
817     }
818 
819     // Configure the drawing parameters.
820     m_context-&gt;uniform1i(m_yTextureUniformLocation, 0);
821     m_context-&gt;uniform1i(m_uvTextureUniformLocation, 1);
822     m_context-&gt;uniform1i(m_yuvFlipYUniformLocation, flipY);
823     m_context-&gt;uniform2f(m_yTextureSizeUniformLocation, yPlaneWidth, yPlaneHeight);
824     m_context-&gt;uniform2f(m_uvTextureSizeUniformLocation, uvPlaneWidth, uvPlaneHeight);
825 
826     auto range = pixelRangeFromPixelFormat(pixelFormat);
827     auto transferFunction = transferFunctionFromString((CFStringRef)CVBufferGetAttachment(image, kCVImageBufferYCbCrMatrixKey, nil));
828     auto&amp; colorMatrix = YCbCrToRGBMatrixForRangeAndTransferFunction(range, transferFunction);
829     m_context-&gt;uniformMatrix4fv(m_colorMatrixUniformLocation, 1, GL_FALSE, colorMatrix.data());
830 
831     // Do the actual drawing.
832     m_context-&gt;drawArrays(GraphicsContext3D::TRIANGLES, 0, 6);
833 
</pre>
<hr />
<pre>
848 
849     return true;
850 #else
851     return false;
852 #endif // HAVE(IOSURFACE)
853 }
854 
855 bool VideoTextureCopierCV::copyVideoTextureToPlatformTexture(TextureType inputVideoTexture, size_t width, size_t height, Platform3DObject outputTexture, GC3Denum outputTarget, GC3Dint level, GC3Denum internalFormat, GC3Denum format, GC3Denum type, bool premultiplyAlpha, bool flipY, bool swapColorChannels)
856 {
857     if (!inputVideoTexture)
858         return false;
859 
860     GLfloat lowerLeft[2] = { 0, 0 };
861     GLfloat lowerRight[2] = { 0, 0 };
862     GLfloat upperRight[2] = { 0, 0 };
863     GLfloat upperLeft[2] = { 0, 0 };
864 #if USE(OPENGL_ES)
865     Platform3DObject videoTextureName = CVOpenGLESTextureGetName(inputVideoTexture);
866     GC3Denum videoTextureTarget = CVOpenGLESTextureGetTarget(inputVideoTexture);
867     CVOpenGLESTextureGetCleanTexCoords(inputVideoTexture, lowerLeft, lowerRight, upperRight, upperLeft);
<span class="line-modified">868 #else</span>




869     Platform3DObject videoTextureName = CVOpenGLTextureGetName(inputVideoTexture);
870     GC3Denum videoTextureTarget = CVOpenGLTextureGetTarget(inputVideoTexture);
871     CVOpenGLTextureGetCleanTexCoords(inputVideoTexture, lowerLeft, lowerRight, upperRight, upperLeft);


872 #endif
873 
874     if (lowerLeft[1] &lt; upperRight[1])
875         flipY = !flipY;
876 
877     return copyVideoTextureToPlatformTexture(videoTextureName, videoTextureTarget, width, height, outputTexture, outputTarget, level, internalFormat, format, type, premultiplyAlpha, flipY, swapColorChannels);
878 }
879 
880 bool VideoTextureCopierCV::copyVideoTextureToPlatformTexture(Platform3DObject videoTextureName, GC3Denum videoTextureTarget, size_t width, size_t height, Platform3DObject outputTexture, GC3Denum outputTarget, GC3Dint level, GC3Denum internalFormat, GC3Denum format, GC3Denum type, bool premultiplyAlpha, bool flipY, bool swapColorChannels)
881 {
882     LOG(WebGL, &quot;VideoTextureCopierCV::copyVideoTextureToPlatformTexture(%p) - internalFormat: %s, format: %s, type: %s flipY: %s, premultiplyAlpha: %s&quot;, this, enumToStringMap()[internalFormat], enumToStringMap()[format], enumToStringMap()[type], flipY ? &quot;true&quot; : &quot;false&quot;, premultiplyAlpha ? &quot;true&quot; : &quot;false&quot;);
883 
884     if (!m_program) {
885         if (!initializeContextObjects()) {
886             LOG(WebGL, &quot;VideoTextureCopierCV::copyVideoTextureToPlatformTexture(%p) - Unable to initialize OpenGL context objects.&quot;, this);
887             return false;
888         }
889     }
890 
891     m_context-&gt;bindFramebuffer(GraphicsContext3D::FRAMEBUFFER, m_framebuffer);
</pre>
</td>
<td>
<hr />
<pre>
 44 
 45 namespace WebCore {
 46 
 47 #if HAVE(IOSURFACE)
 48 enum class PixelRange {
 49     Unknown,
 50     Video,
 51     Full,
 52 };
 53 
 54 enum class TransferFunction {
 55     Unknown,
 56     kITU_R_709_2,
 57     kITU_R_601_4,
 58     kSMPTE_240M_1995,
 59     kDCI_P3,
 60     kP3_D65,
 61     kITU_R_2020,
 62 };
 63 












 64 static PixelRange pixelRangeFromPixelFormat(OSType pixelFormat)
 65 {
 66     switch (pixelFormat) {
 67     case kCVPixelFormatType_4444AYpCbCr8:
 68     case kCVPixelFormatType_4444AYpCbCr16:
 69     case kCVPixelFormatType_422YpCbCr_4A_8BiPlanar:
 70     case kCVPixelFormatType_420YpCbCr8BiPlanarVideoRange:
 71     case kCVPixelFormatType_420YpCbCr10BiPlanarVideoRange:
 72     case kCVPixelFormatType_422YpCbCr10BiPlanarVideoRange:
 73     case kCVPixelFormatType_444YpCbCr10BiPlanarVideoRange:
 74         return PixelRange::Video;
 75     case kCVPixelFormatType_420YpCbCr8PlanarFullRange:
 76     case kCVPixelFormatType_420YpCbCr8BiPlanarFullRange:
 77     case kCVPixelFormatType_422YpCbCr8FullRange:
 78     case kCVPixelFormatType_ARGB2101010LEPacked:
 79     case kCVPixelFormatType_420YpCbCr10BiPlanarFullRange:
 80     case kCVPixelFormatType_422YpCbCr10BiPlanarFullRange:
 81     case kCVPixelFormatType_444YpCbCr10BiPlanarFullRange:
 82         return PixelRange::Full;
 83     default:
 84         return PixelRange::Unknown;
 85     }
 86 }
 87 
 88 static TransferFunction transferFunctionFromString(CFStringRef string)
 89 {
<span class="line-added"> 90     if (!string || CFGetTypeID(string) != CFStringGetTypeID())</span>
<span class="line-added"> 91         return TransferFunction::Unknown;</span>
 92     if (CFEqual(string, kCVImageBufferYCbCrMatrix_ITU_R_709_2))
 93         return TransferFunction::kITU_R_709_2;
 94     if (CFEqual(string, kCVImageBufferYCbCrMatrix_ITU_R_601_4))
 95         return TransferFunction::kITU_R_601_4;
 96     if (CFEqual(string, kCVImageBufferYCbCrMatrix_SMPTE_240M_1995))
 97         return TransferFunction::kSMPTE_240M_1995;
 98     if (canLoad_CoreVideo_kCVImageBufferYCbCrMatrix_DCI_P3() &amp;&amp; CFEqual(string, kCVImageBufferYCbCrMatrix_DCI_P3))
 99         return TransferFunction::kDCI_P3;
100     if (canLoad_CoreVideo_kCVImageBufferYCbCrMatrix_P3_D65() &amp;&amp; CFEqual(string, kCVImageBufferYCbCrMatrix_P3_D65))
101         return TransferFunction::kP3_D65;
102     if (canLoad_CoreVideo_kCVImageBufferYCbCrMatrix_ITU_R_2020() &amp;&amp; CFEqual(string, kCVImageBufferYCbCrMatrix_ITU_R_2020))
103         return TransferFunction::kITU_R_2020;
104     return TransferFunction::Unknown;
105 }
106 
107 struct GLfloatColor {
108     union {
109         struct {
110             GLfloat r;
111             GLfloat g;
</pre>
<hr />
<pre>
374 {
375     if (m_vertexBuffer)
376         m_context-&gt;deleteProgram(m_vertexBuffer);
377     if (m_program)
378         m_context-&gt;deleteProgram(m_program);
379     if (m_yuvVertexBuffer)
380         m_context-&gt;deleteProgram(m_yuvVertexBuffer);
381     if (m_yuvProgram)
382         m_context-&gt;deleteProgram(m_yuvProgram);
383     m_context-&gt;deleteFramebuffer(m_framebuffer);
384 }
385 
386 #if !LOG_DISABLED
387 using StringMap = StdMap&lt;uint32_t, const char*&gt;;
388 #define STRINGIFY_PAIR(e) e, #e
389 static StringMap&amp; enumToStringMap()
390 {
391     static NeverDestroyed&lt;StringMap&gt; map;
392     if (map.get().empty()) {
393         StringMap stringMap;
<span class="line-modified">394         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::RGB));</span>
<span class="line-modified">395         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::RGBA));</span>
<span class="line-modified">396         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::LUMINANCE_ALPHA));</span>
<span class="line-modified">397         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::LUMINANCE));</span>
<span class="line-modified">398         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::ALPHA));</span>
<span class="line-modified">399         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::R8));</span>
<span class="line-modified">400         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::R16F));</span>
<span class="line-modified">401         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::R32F));</span>
<span class="line-modified">402         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::R8UI));</span>
<span class="line-modified">403         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::R8I));</span>
<span class="line-modified">404         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::R16UI));</span>
<span class="line-modified">405         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::R16I));</span>
<span class="line-modified">406         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::R32UI));</span>
<span class="line-modified">407         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::R32I));</span>
<span class="line-modified">408         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::RG8));</span>
<span class="line-modified">409         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::RG16F));</span>
<span class="line-modified">410         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::RG32F));</span>
<span class="line-modified">411         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::RG8UI));</span>
<span class="line-modified">412         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::RG8I));</span>
<span class="line-modified">413         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::RG16UI));</span>
<span class="line-modified">414         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::RG16I));</span>
<span class="line-modified">415         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::RG32UI));</span>
<span class="line-modified">416         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::RG32I));</span>
<span class="line-modified">417         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::RGB8));</span>
<span class="line-modified">418         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::SRGB8));</span>
<span class="line-modified">419         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::RGBA8));</span>
<span class="line-modified">420         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::SRGB8_ALPHA8));</span>
<span class="line-modified">421         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::RGBA4));</span>
<span class="line-modified">422         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::RGB10_A2));</span>
<span class="line-modified">423         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::DEPTH_COMPONENT16));</span>
<span class="line-modified">424         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::DEPTH_COMPONENT24));</span>
<span class="line-modified">425         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::DEPTH_COMPONENT32F));</span>
<span class="line-modified">426         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::DEPTH24_STENCIL8));</span>
<span class="line-modified">427         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::DEPTH32F_STENCIL8));</span>
<span class="line-modified">428         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::RGB));</span>
<span class="line-modified">429         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::RGBA));</span>
<span class="line-modified">430         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::LUMINANCE_ALPHA));</span>
<span class="line-modified">431         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::LUMINANCE));</span>
<span class="line-modified">432         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::ALPHA));</span>
<span class="line-modified">433         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::RED));</span>
<span class="line-modified">434         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::RG_INTEGER));</span>
<span class="line-modified">435         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::DEPTH_STENCIL));</span>
<span class="line-modified">436         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::UNSIGNED_BYTE));</span>
<span class="line-modified">437         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::UNSIGNED_SHORT_5_6_5));</span>
<span class="line-modified">438         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::UNSIGNED_SHORT_4_4_4_4));</span>
<span class="line-modified">439         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::UNSIGNED_SHORT_5_5_5_1));</span>
<span class="line-modified">440         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::BYTE));</span>
<span class="line-modified">441         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::HALF_FLOAT));</span>
<span class="line-modified">442         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::FLOAT));</span>
<span class="line-modified">443         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::UNSIGNED_SHORT));</span>
<span class="line-modified">444         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::SHORT));</span>
<span class="line-modified">445         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::UNSIGNED_INT));</span>
<span class="line-modified">446         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::INT));</span>
<span class="line-modified">447         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::UNSIGNED_INT_2_10_10_10_REV));</span>
<span class="line-modified">448         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::UNSIGNED_INT_24_8));</span>
<span class="line-modified">449         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::FLOAT_32_UNSIGNED_INT_24_8_REV));</span>
450 
451 #if USE(OPENGL_ES)
452         map.get().emplace(STRINGIFY_PAIR(GL_RED_INTEGER));
453         map.get().emplace(STRINGIFY_PAIR(GL_RGB_INTEGER));
454         map.get().emplace(STRINGIFY_PAIR(GL_RG8_SNORM));
455         map.get().emplace(STRINGIFY_PAIR(GL_RGB565));
456         map.get().emplace(STRINGIFY_PAIR(GL_RGB8_SNORM));
457         map.get().emplace(STRINGIFY_PAIR(GL_R11F_G11F_B10F));
458         map.get().emplace(STRINGIFY_PAIR(GL_RGB9_E5));
459         map.get().emplace(STRINGIFY_PAIR(GL_RGB16F));
460         map.get().emplace(STRINGIFY_PAIR(GL_RGB32F));
461         map.get().emplace(STRINGIFY_PAIR(GL_RGB8UI));
462         map.get().emplace(STRINGIFY_PAIR(GL_RGB8I));
463         map.get().emplace(STRINGIFY_PAIR(GL_RGB16UI));
464         map.get().emplace(STRINGIFY_PAIR(GL_RGB16I));
465         map.get().emplace(STRINGIFY_PAIR(GL_RGB32UI));
466         map.get().emplace(STRINGIFY_PAIR(GL_RGB32I));
467         map.get().emplace(STRINGIFY_PAIR(GL_RGBA8_SNORM));
468         map.get().emplace(STRINGIFY_PAIR(GL_RGBA16F));
469         map.get().emplace(STRINGIFY_PAIR(GL_RGBA32F));
</pre>
<hr />
<pre>
501     vertexShaderSource.appendLiteral(&quot;    gl_Position = a_position;\n&quot;);
502     vertexShaderSource.appendLiteral(&quot;}\n&quot;);
503 
504     Platform3DObject vertexShader = m_context-&gt;createShader(GraphicsContext3D::VERTEX_SHADER);
505     m_context-&gt;shaderSource(vertexShader, vertexShaderSource.toString());
506     m_context-&gt;compileShaderDirect(vertexShader);
507 
508     GC3Dint value = 0;
509     m_context-&gt;getShaderiv(vertexShader, GraphicsContext3D::COMPILE_STATUS, &amp;value);
510     if (!value) {
511         LOG(WebGL, &quot;VideoTextureCopierCV::copyVideoTextureToPlatformTexture(%p) - Vertex shader failed to compile.&quot;, this);
512         m_context-&gt;deleteShader(vertexShader);
513         return false;
514     }
515 
516     StringBuilder fragmentShaderSource;
517 
518 #if USE(OPENGL_ES)
519     fragmentShaderSource.appendLiteral(&quot;precision mediump float;\n&quot;);
520     fragmentShaderSource.appendLiteral(&quot;uniform sampler2D u_texture;\n&quot;);
<span class="line-modified">521 #elif USE(OPENGL)</span>
522     fragmentShaderSource.appendLiteral(&quot;uniform sampler2DRect u_texture;\n&quot;);
<span class="line-added">523 #elif USE(ANGLE)</span>
<span class="line-added">524     // FIXME: determine how to access rectangular textures via ANGLE.</span>
<span class="line-added">525     ASSERT_NOT_REACHED();</span>
<span class="line-added">526 #else</span>
<span class="line-added">527 #error Unsupported configuration</span>
528 #endif
529     fragmentShaderSource.appendLiteral(&quot;varying vec2 v_texturePosition;\n&quot;);
530     fragmentShaderSource.appendLiteral(&quot;uniform int u_premultiply;\n&quot;);
531     fragmentShaderSource.appendLiteral(&quot;uniform vec2 u_textureDimensions;\n&quot;);
532     fragmentShaderSource.appendLiteral(&quot;uniform int u_swapColorChannels;\n&quot;);
533     fragmentShaderSource.appendLiteral(&quot;void main() {\n&quot;);
534     fragmentShaderSource.appendLiteral(&quot;    vec2 texPos = vec2(v_texturePosition.x * u_textureDimensions.x, v_texturePosition.y * u_textureDimensions.y);\n&quot;);
535 #if USE(OPENGL_ES)
536     fragmentShaderSource.appendLiteral(&quot;    vec4 color = texture2D(u_texture, texPos);\n&quot;);
<span class="line-modified">537 #elif USE(OPENGL)</span>
538     fragmentShaderSource.appendLiteral(&quot;    vec4 color = texture2DRect(u_texture, texPos);\n&quot;);
<span class="line-added">539 #elif USE(ANGLE)</span>
<span class="line-added">540     // FIXME: determine how to access rectangular textures via ANGLE.</span>
<span class="line-added">541     ASSERT_NOT_REACHED();</span>
<span class="line-added">542 #else</span>
<span class="line-added">543 #error Unsupported configuration</span>
544 #endif
545     fragmentShaderSource.appendLiteral(&quot;    if (u_swapColorChannels == 1) {\n&quot;);
546     fragmentShaderSource.appendLiteral(&quot;        color.rgba = color.bgra;\n&quot;);
547     fragmentShaderSource.appendLiteral(&quot;    }\n&quot;);
548     fragmentShaderSource.appendLiteral(&quot;    if (u_premultiply == 1) {\n&quot;);
549     fragmentShaderSource.appendLiteral(&quot;        gl_FragColor = vec4(color.r * color.a, color.g * color.a, color.b * color.a, color.a);\n&quot;);
550     fragmentShaderSource.appendLiteral(&quot;    } else {\n&quot;);
551     fragmentShaderSource.appendLiteral(&quot;        gl_FragColor = color;\n&quot;);
552     fragmentShaderSource.appendLiteral(&quot;    }\n&quot;);
553     fragmentShaderSource.appendLiteral(&quot;}\n&quot;);
554 
555     Platform3DObject fragmentShader = m_context-&gt;createShader(GraphicsContext3D::FRAGMENT_SHADER);
556     m_context-&gt;shaderSource(fragmentShader, fragmentShaderSource.toString());
557     m_context-&gt;compileShaderDirect(fragmentShader);
558 
559     m_context-&gt;getShaderiv(fragmentShader, GraphicsContext3D::COMPILE_STATUS, &amp;value);
560     if (!value) {
561         LOG(WebGL, &quot;VideoTextureCopierCV::copyVideoTextureToPlatformTexture(%p) - Fragment shader failed to compile.&quot;, this);
562         m_context-&gt;deleteShader(vertexShader);
563         m_context-&gt;deleteShader(fragmentShader);
</pre>
<hr />
<pre>
604 }
605 
606 bool VideoTextureCopierCV::initializeUVContextObjects()
607 {
608     String vertexShaderSource {
609         &quot;attribute vec2 a_position;\n&quot;
610         &quot;uniform vec2 u_yTextureSize;\n&quot;
611         &quot;uniform vec2 u_uvTextureSize;\n&quot;
612         &quot;uniform int u_flipY;\n&quot;
613         &quot;varying vec2 v_yTextureCoordinate;\n&quot;
614         &quot;varying vec2 v_uvTextureCoordinate;\n&quot;
615         &quot;void main() {\n&quot;
616         &quot;   gl_Position = vec4(a_position, 0, 1.0);\n&quot;
617         &quot;   vec2 normalizedPosition = a_position * .5 + .5;\n&quot;
618         &quot;   if (u_flipY == 1) {\n&quot;
619         &quot;       normalizedPosition.y = 1.0 - normalizedPosition.y;\n&quot;
620         &quot;   }\n&quot;
621 #if USE(OPENGL_ES)
622         &quot;   v_yTextureCoordinate = normalizedPosition;\n&quot;
623         &quot;   v_uvTextureCoordinate = normalizedPosition;\n&quot;
<span class="line-modified">624 #elif USE(OPENGL)</span>
625         &quot;   v_yTextureCoordinate = normalizedPosition * u_yTextureSize;\n&quot;
626         &quot;   v_uvTextureCoordinate = normalizedPosition * u_uvTextureSize;\n&quot;
<span class="line-added">627 #elif USE(ANGLE)</span>
<span class="line-added">628         // FIXME: determine how to access rectangular textures via ANGLE.</span>
<span class="line-added">629 #else</span>
<span class="line-added">630 #error Unsupported configuration</span>
631 #endif
632         &quot;}\n&quot;_s
633     };
634 
635     Platform3DObject vertexShader = m_context-&gt;createShader(GraphicsContext3D::VERTEX_SHADER);
636     m_context-&gt;shaderSource(vertexShader, vertexShaderSource);
637     m_context-&gt;compileShaderDirect(vertexShader);
638 
639     GC3Dint status = 0;
640     m_context-&gt;getShaderiv(vertexShader, GraphicsContext3D::COMPILE_STATUS, &amp;status);
641     if (!status) {
642         LOG(WebGL, &quot;VideoTextureCopierCV::initializeUVContextObjects(%p) - Vertex shader failed to compile.&quot;, this);
643         m_context-&gt;deleteShader(vertexShader);
644         return false;
645     }
646 
647     String fragmentShaderSource {
648 #if USE(OPENGL_ES)
649         &quot;precision mediump float;\n&quot;
650         &quot;#define SAMPLERTYPE sampler2D\n&quot;
651         &quot;#define TEXTUREFUNC texture2D\n&quot;
<span class="line-modified">652 #elif USE(OPENGL)</span>
653         &quot;#define SAMPLERTYPE sampler2DRect\n&quot;
654         &quot;#define TEXTUREFUNC texture2DRect\n&quot;
<span class="line-added">655 #elif USE(ANGLE)</span>
<span class="line-added">656         // FIXME: determine how to access rectangular textures via ANGLE.</span>
<span class="line-added">657 #else</span>
<span class="line-added">658 #error Unsupported configuration</span>
659 #endif
660         &quot;uniform SAMPLERTYPE u_yTexture;\n&quot;
661         &quot;uniform SAMPLERTYPE u_uvTexture;\n&quot;
662         &quot;uniform mat4 u_colorMatrix;\n&quot;
663         &quot;varying vec2 v_yTextureCoordinate;\n&quot;
664         &quot;varying vec2 v_uvTextureCoordinate;\n&quot;
665         &quot;void main() {\n&quot;
666         &quot;    vec4 yuv;\n&quot;
667         &quot;    yuv.r = TEXTUREFUNC(u_yTexture, v_yTextureCoordinate).r;\n&quot;
668         &quot;    yuv.gb = TEXTUREFUNC(u_uvTexture, v_uvTextureCoordinate).rg;\n&quot;
669         &quot;    yuv.a = 1.0;\n&quot;
670         &quot;    gl_FragColor = yuv * u_colorMatrix;\n&quot;
671         &quot;}\n&quot;_s
672     };
673 
674     Platform3DObject fragmentShader = m_context-&gt;createShader(GraphicsContext3D::FRAGMENT_SHADER);
675     m_context-&gt;shaderSource(fragmentShader, fragmentShaderSource);
676     m_context-&gt;compileShaderDirect(fragmentShader);
677 
678     m_context-&gt;getShaderiv(fragmentShader, GraphicsContext3D::COMPILE_STATUS, &amp;status);
</pre>
<hr />
<pre>
779     m_context-&gt;texImage2DDirect(GraphicsContext3D::TEXTURE_2D, level, internalFormat, width, height, 0, format, type, nullptr);
780 
781     m_context-&gt;framebufferTexture2D(GraphicsContext3D::FRAMEBUFFER, GraphicsContext3D::COLOR_ATTACHMENT0, GraphicsContext3D::TEXTURE_2D, outputTexture, level);
782     GC3Denum status = m_context-&gt;checkFramebufferStatus(GraphicsContext3D::FRAMEBUFFER);
783     if (status != GraphicsContext3D::FRAMEBUFFER_COMPLETE) {
784         LOG(WebGL, &quot;VideoTextureCopierCV::copyVideoTextureToPlatformTexture(%p) - Unable to create framebuffer for outputTexture.&quot;, this);
785         return false;
786     }
787 
788     m_context-&gt;useProgram(m_yuvProgram);
789     m_context-&gt;viewport(0, 0, width, height);
790 
791     // Bind and set up the textures for the video source.
792     auto yPlaneWidth = IOSurfaceGetWidthOfPlane(surface, 0);
793     auto yPlaneHeight = IOSurfaceGetHeightOfPlane(surface, 0);
794     auto uvPlaneWidth = IOSurfaceGetWidthOfPlane(surface, 1);
795     auto uvPlaneHeight = IOSurfaceGetHeightOfPlane(surface, 1);
796 
797 #if USE(OPENGL_ES)
798     GC3Denum videoTextureTarget = GraphicsContext3D::TEXTURE_2D;
<span class="line-modified">799 #elif USE(OPENGL)</span>
800     GC3Denum videoTextureTarget = GL_TEXTURE_RECTANGLE_ARB;
<span class="line-added">801 #elif USE(ANGLE)</span>
<span class="line-added">802     // FIXME: determine how to access rectangular textures via ANGLE.</span>
<span class="line-added">803     GC3Denum videoTextureTarget = GraphicsContext3D::TEXTURE_2D;</span>
<span class="line-added">804 #else</span>
<span class="line-added">805 #error Unsupported configuration</span>
806 #endif
807     auto uvTexture = m_context-&gt;createTexture();
808     m_context-&gt;activeTexture(GraphicsContext3D::TEXTURE1);
809     m_context-&gt;bindTexture(videoTextureTarget, uvTexture);
810     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContext3D::TEXTURE_MAG_FILTER, GraphicsContext3D::LINEAR);
811     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContext3D::TEXTURE_MIN_FILTER, GraphicsContext3D::LINEAR);
812     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContext3D::TEXTURE_WRAP_S, GraphicsContext3D::CLAMP_TO_EDGE);
813     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContext3D::TEXTURE_WRAP_T, GraphicsContext3D::CLAMP_TO_EDGE);
<span class="line-modified">814     if (!m_context-&gt;texImageIOSurface2D(videoTextureTarget, GraphicsContext3D::RG, uvPlaneWidth, uvPlaneHeight, GraphicsContext3D::RG, GraphicsContext3D::UNSIGNED_BYTE, surface, 1)) {</span>
815         m_context-&gt;deleteTexture(uvTexture);
816         return false;
817     }
818 
819     auto yTexture = m_context-&gt;createTexture();
820     m_context-&gt;activeTexture(GraphicsContext3D::TEXTURE0);
821     m_context-&gt;bindTexture(videoTextureTarget, yTexture);
822     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContext3D::TEXTURE_MAG_FILTER, GraphicsContext3D::LINEAR);
823     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContext3D::TEXTURE_MIN_FILTER, GraphicsContext3D::LINEAR);
824     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContext3D::TEXTURE_WRAP_S, GraphicsContext3D::CLAMP_TO_EDGE);
825     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContext3D::TEXTURE_WRAP_T, GraphicsContext3D::CLAMP_TO_EDGE);
<span class="line-modified">826     if (!m_context-&gt;texImageIOSurface2D(videoTextureTarget, GraphicsContext3D::LUMINANCE, yPlaneWidth, yPlaneHeight, GraphicsContext3D::LUMINANCE, GraphicsContext3D::UNSIGNED_BYTE, surface, 0)) {</span>
827         m_context-&gt;deleteTexture(yTexture);
828         m_context-&gt;deleteTexture(uvTexture);
829         return false;
830     }
831 
832     // Configure the drawing parameters.
833     m_context-&gt;uniform1i(m_yTextureUniformLocation, 0);
834     m_context-&gt;uniform1i(m_uvTextureUniformLocation, 1);
835     m_context-&gt;uniform1i(m_yuvFlipYUniformLocation, flipY);
836     m_context-&gt;uniform2f(m_yTextureSizeUniformLocation, yPlaneWidth, yPlaneHeight);
837     m_context-&gt;uniform2f(m_uvTextureSizeUniformLocation, uvPlaneWidth, uvPlaneHeight);
838 
839     auto range = pixelRangeFromPixelFormat(pixelFormat);
840     auto transferFunction = transferFunctionFromString((CFStringRef)CVBufferGetAttachment(image, kCVImageBufferYCbCrMatrixKey, nil));
841     auto&amp; colorMatrix = YCbCrToRGBMatrixForRangeAndTransferFunction(range, transferFunction);
842     m_context-&gt;uniformMatrix4fv(m_colorMatrixUniformLocation, 1, GL_FALSE, colorMatrix.data());
843 
844     // Do the actual drawing.
845     m_context-&gt;drawArrays(GraphicsContext3D::TRIANGLES, 0, 6);
846 
</pre>
<hr />
<pre>
861 
862     return true;
863 #else
864     return false;
865 #endif // HAVE(IOSURFACE)
866 }
867 
868 bool VideoTextureCopierCV::copyVideoTextureToPlatformTexture(TextureType inputVideoTexture, size_t width, size_t height, Platform3DObject outputTexture, GC3Denum outputTarget, GC3Dint level, GC3Denum internalFormat, GC3Denum format, GC3Denum type, bool premultiplyAlpha, bool flipY, bool swapColorChannels)
869 {
870     if (!inputVideoTexture)
871         return false;
872 
873     GLfloat lowerLeft[2] = { 0, 0 };
874     GLfloat lowerRight[2] = { 0, 0 };
875     GLfloat upperRight[2] = { 0, 0 };
876     GLfloat upperLeft[2] = { 0, 0 };
877 #if USE(OPENGL_ES)
878     Platform3DObject videoTextureName = CVOpenGLESTextureGetName(inputVideoTexture);
879     GC3Denum videoTextureTarget = CVOpenGLESTextureGetTarget(inputVideoTexture);
880     CVOpenGLESTextureGetCleanTexCoords(inputVideoTexture, lowerLeft, lowerRight, upperRight, upperLeft);
<span class="line-modified">881 #elif USE(OPENGL)</span>
<span class="line-added">882     Platform3DObject videoTextureName = CVOpenGLTextureGetName(inputVideoTexture);</span>
<span class="line-added">883     GC3Denum videoTextureTarget = CVOpenGLTextureGetTarget(inputVideoTexture);</span>
<span class="line-added">884     CVOpenGLTextureGetCleanTexCoords(inputVideoTexture, lowerLeft, lowerRight, upperRight, upperLeft);</span>
<span class="line-added">885 #elif USE(ANGLE)</span>
886     Platform3DObject videoTextureName = CVOpenGLTextureGetName(inputVideoTexture);
887     GC3Denum videoTextureTarget = CVOpenGLTextureGetTarget(inputVideoTexture);
888     CVOpenGLTextureGetCleanTexCoords(inputVideoTexture, lowerLeft, lowerRight, upperRight, upperLeft);
<span class="line-added">889     // FIXME: determine how to access rectangular textures via ANGLE.</span>
<span class="line-added">890     ASSERT_NOT_REACHED();</span>
891 #endif
892 
893     if (lowerLeft[1] &lt; upperRight[1])
894         flipY = !flipY;
895 
896     return copyVideoTextureToPlatformTexture(videoTextureName, videoTextureTarget, width, height, outputTexture, outputTarget, level, internalFormat, format, type, premultiplyAlpha, flipY, swapColorChannels);
897 }
898 
899 bool VideoTextureCopierCV::copyVideoTextureToPlatformTexture(Platform3DObject videoTextureName, GC3Denum videoTextureTarget, size_t width, size_t height, Platform3DObject outputTexture, GC3Denum outputTarget, GC3Dint level, GC3Denum internalFormat, GC3Denum format, GC3Denum type, bool premultiplyAlpha, bool flipY, bool swapColorChannels)
900 {
901     LOG(WebGL, &quot;VideoTextureCopierCV::copyVideoTextureToPlatformTexture(%p) - internalFormat: %s, format: %s, type: %s flipY: %s, premultiplyAlpha: %s&quot;, this, enumToStringMap()[internalFormat], enumToStringMap()[format], enumToStringMap()[type], flipY ? &quot;true&quot; : &quot;false&quot;, premultiplyAlpha ? &quot;true&quot; : &quot;false&quot;);
902 
903     if (!m_program) {
904         if (!initializeContextObjects()) {
905             LOG(WebGL, &quot;VideoTextureCopierCV::copyVideoTextureToPlatformTexture(%p) - Unable to initialize OpenGL context objects.&quot;, this);
906             return false;
907         }
908     }
909 
910     m_context-&gt;bindFramebuffer(GraphicsContext3D::FRAMEBUFFER, m_framebuffer);
</pre>
</td>
</tr>
</table>
<center><a href="TextureCacheCV.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="VideoTextureCopierCV.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>