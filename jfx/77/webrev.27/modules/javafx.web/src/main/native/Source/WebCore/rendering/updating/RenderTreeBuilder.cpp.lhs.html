<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/rendering/updating/RenderTreeBuilder.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2017 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;RenderTreeBuilder.h&quot;
 28 
 29 #include &quot;AXObjectCache.h&quot;
 30 #include &quot;Frame.h&quot;
 31 #include &quot;FrameSelection.h&quot;
 32 #include &quot;RenderButton.h&quot;
 33 #include &quot;RenderCounter.h&quot;
 34 #include &quot;RenderElement.h&quot;
 35 #include &quot;RenderFullScreen.h&quot;
 36 #include &quot;RenderGrid.h&quot;
 37 #include &quot;RenderLineBreak.h&quot;
 38 #include &quot;RenderMathMLFenced.h&quot;
 39 #include &quot;RenderMenuList.h&quot;
 40 #include &quot;RenderMultiColumnFlow.h&quot;
 41 #include &quot;RenderRuby.h&quot;
 42 #include &quot;RenderRubyBase.h&quot;
 43 #include &quot;RenderRubyRun.h&quot;
 44 #include &quot;RenderSVGContainer.h&quot;
 45 #include &quot;RenderSVGInline.h&quot;
 46 #include &quot;RenderSVGRoot.h&quot;
<a name="1" id="anc1"></a>
 47 #include &quot;RenderTable.h&quot;
 48 #include &quot;RenderTableRow.h&quot;
 49 #include &quot;RenderTableSection.h&quot;
 50 #include &quot;RenderText.h&quot;
 51 #include &quot;RenderTextFragment.h&quot;
 52 #include &quot;RenderTreeBuilderBlock.h&quot;
 53 #include &quot;RenderTreeBuilderBlockFlow.h&quot;
 54 #include &quot;RenderTreeBuilderContinuation.h&quot;
 55 #include &quot;RenderTreeBuilderFirstLetter.h&quot;
 56 #include &quot;RenderTreeBuilderFormControls.h&quot;
 57 #include &quot;RenderTreeBuilderFullScreen.h&quot;
 58 #include &quot;RenderTreeBuilderInline.h&quot;
 59 #include &quot;RenderTreeBuilderList.h&quot;
 60 #include &quot;RenderTreeBuilderMathML.h&quot;
 61 #include &quot;RenderTreeBuilderMultiColumn.h&quot;
 62 #include &quot;RenderTreeBuilderRuby.h&quot;
 63 #include &quot;RenderTreeBuilderSVG.h&quot;
 64 #include &quot;RenderTreeBuilderTable.h&quot;
 65 
 66 namespace WebCore {
 67 
 68 RenderTreeBuilder* RenderTreeBuilder::s_current;
 69 
 70 static void markBoxForRelayoutAfterSplit(RenderBox&amp; box)
 71 {
 72     // FIXME: The table code should handle that automatically. If not,
 73     // we should fix it and remove the table part checks.
 74     if (is&lt;RenderTable&gt;(box)) {
 75         // Because we may have added some sections with already computed column structures, we need to
 76         // sync the table structure with them now. This avoids crashes when adding new cells to the table.
 77         downcast&lt;RenderTable&gt;(box).forceSectionsRecalc();
 78     } else if (is&lt;RenderTableSection&gt;(box))
 79         downcast&lt;RenderTableSection&gt;(box).setNeedsCellRecalc();
 80 
 81     box.setNeedsLayoutAndPrefWidthsRecalc();
 82 }
 83 
 84 static void getInlineRun(RenderObject* start, RenderObject* boundary, RenderObject*&amp; inlineRunStart, RenderObject*&amp; inlineRunEnd)
 85 {
 86     // Beginning at |start| we find the largest contiguous run of inlines that
 87     // we can. We denote the run with start and end points, |inlineRunStart|
 88     // and |inlineRunEnd|. Note that these two values may be the same if
 89     // we encounter only one inline.
 90     //
 91     // We skip any non-inlines we encounter as long as we haven&#39;t found any
 92     // inlines yet.
 93     //
 94     // |boundary| indicates a non-inclusive boundary point. Regardless of whether |boundary|
 95     // is inline or not, we will not include it in a run with inlines before it. It&#39;s as though we encountered
 96     // a non-inline.
 97 
 98     // Start by skipping as many non-inlines as we can.
 99     auto* curr = start;
100     bool sawInline;
101     do {
102         while (curr &amp;&amp; !(curr-&gt;isInline() || curr-&gt;isFloatingOrOutOfFlowPositioned()))
103             curr = curr-&gt;nextSibling();
104 
105         inlineRunStart = inlineRunEnd = curr;
106 
107         if (!curr)
108             return; // No more inline children to be found.
109 
110         sawInline = curr-&gt;isInline();
111 
112         curr = curr-&gt;nextSibling();
113         while (curr &amp;&amp; (curr-&gt;isInline() || curr-&gt;isFloatingOrOutOfFlowPositioned()) &amp;&amp; (curr != boundary)) {
114             inlineRunEnd = curr;
115             if (curr-&gt;isInline())
116                 sawInline = true;
117             curr = curr-&gt;nextSibling();
118         }
119     } while (!sawInline);
120 }
121 
122 RenderTreeBuilder::RenderTreeBuilder(RenderView&amp; view)
123     : m_view(view)
<a name="2" id="anc2"></a><span class="line-modified">124     , m_firstLetterBuilder(std::make_unique&lt;FirstLetter&gt;(*this))</span>
<span class="line-modified">125     , m_listBuilder(std::make_unique&lt;List&gt;(*this))</span>
<span class="line-modified">126     , m_multiColumnBuilder(std::make_unique&lt;MultiColumn&gt;(*this))</span>
<span class="line-modified">127     , m_tableBuilder(std::make_unique&lt;Table&gt;(*this))</span>
<span class="line-modified">128     , m_rubyBuilder(std::make_unique&lt;Ruby&gt;(*this))</span>
<span class="line-modified">129     , m_formControlsBuilder(std::make_unique&lt;FormControls&gt;(*this))</span>
<span class="line-modified">130     , m_blockBuilder(std::make_unique&lt;Block&gt;(*this))</span>
<span class="line-modified">131     , m_blockFlowBuilder(std::make_unique&lt;BlockFlow&gt;(*this))</span>
<span class="line-modified">132     , m_inlineBuilder(std::make_unique&lt;Inline&gt;(*this))</span>
<span class="line-modified">133     , m_svgBuilder(std::make_unique&lt;SVG&gt;(*this))</span>
134 #if ENABLE(MATHML)
<a name="3" id="anc3"></a><span class="line-modified">135     , m_mathMLBuilder(std::make_unique&lt;MathML&gt;(*this))</span>
136 #endif
<a name="4" id="anc4"></a><span class="line-modified">137     , m_continuationBuilder(std::make_unique&lt;Continuation&gt;(*this))</span>
138 #if ENABLE(FULLSCREEN_API)
<a name="5" id="anc5"></a><span class="line-modified">139     , m_fullScreenBuilder(std::make_unique&lt;FullScreen&gt;(*this))</span>
140 #endif
141 {
142     RELEASE_ASSERT(!s_current || &amp;m_view != &amp;s_current-&gt;m_view);
143     m_previous = s_current;
144     s_current = this;
145 }
146 
147 RenderTreeBuilder::~RenderTreeBuilder()
148 {
149     s_current = m_previous;
150 }
151 
152 void RenderTreeBuilder::destroy(RenderObject&amp; renderer)
153 {
154     ASSERT(renderer.parent());
155     auto toDestroy = detach(*renderer.parent(), renderer);
156 
157 #if ENABLE(FULLSCREEN_API)
158     if (is&lt;RenderFullScreen&gt;(renderer))
159         fullScreenBuilder().cleanupOnDestroy(downcast&lt;RenderFullScreen&gt;(renderer));
160 #endif
161 
162     if (is&lt;RenderTextFragment&gt;(renderer))
163         firstLetterBuilder().cleanupOnDestroy(downcast&lt;RenderTextFragment&gt;(renderer));
164 
165     if (is&lt;RenderBoxModelObject&gt;(renderer))
166         continuationBuilder().cleanupOnDestroy(downcast&lt;RenderBoxModelObject&gt;(renderer));
167 
168     // We need to detach the subtree first so that the descendants don&#39;t have
169     // access to previous/next sublings at detach().
170     // FIXME: webkit.org/b/182909.
171     if (!is&lt;RenderElement&gt;(toDestroy.get()))
172         return;
173 
174     auto&amp; childToDestroy = downcast&lt;RenderElement&gt;(*toDestroy.get());
175     while (childToDestroy.firstChild()) {
176         auto&amp; firstChild = *childToDestroy.firstChild();
177         if (auto* node = firstChild.node())
178             node-&gt;setRenderer(nullptr);
179         destroy(firstChild);
180     }
181 }
182 
183 void RenderTreeBuilder::attach(RenderElement&amp; parent, RenderPtr&lt;RenderObject&gt; child, RenderObject* beforeChild)
184 {
185     auto insertRecursiveIfNeeded = [&amp;](RenderElement&amp; parentCandidate) {
186         if (&amp;parent == &amp;parentCandidate) {
187             attachToRenderElement(parent, WTFMove(child), beforeChild);
188             return;
189         }
190         attach(parentCandidate, WTFMove(child), beforeChild);
191     };
192 
193     ASSERT(&amp;parent.view() == &amp;m_view);
194 
195     if (is&lt;RenderText&gt;(beforeChild)) {
196         if (auto* wrapperInline = downcast&lt;RenderText&gt;(*beforeChild).inlineWrapperForDisplayContents())
197             beforeChild = wrapperInline;
198     }
199 
200     if (is&lt;RenderTableRow&gt;(parent)) {
201         auto&amp; parentCandidate = tableBuilder().findOrCreateParentForChild(downcast&lt;RenderTableRow&gt;(parent), *child, beforeChild);
202         if (&amp;parentCandidate == &amp;parent) {
203             tableBuilder().attach(downcast&lt;RenderTableRow&gt;(parentCandidate), WTFMove(child), beforeChild);
204             return;
205         }
206         insertRecursiveIfNeeded(parentCandidate);
207         return;
208     }
209 
210     if (is&lt;RenderTableSection&gt;(parent)) {
211         auto&amp; parentCandidate = tableBuilder().findOrCreateParentForChild(downcast&lt;RenderTableSection&gt;(parent), *child, beforeChild);
212         if (&amp;parent == &amp;parentCandidate) {
213             tableBuilder().attach(downcast&lt;RenderTableSection&gt;(parent), WTFMove(child), beforeChild);
214             return;
215         }
216         insertRecursiveIfNeeded(parentCandidate);
217         return;
218     }
219 
220     if (is&lt;RenderTable&gt;(parent)) {
221         auto&amp; parentCandidate = tableBuilder().findOrCreateParentForChild(downcast&lt;RenderTable&gt;(parent), *child, beforeChild);
222         if (&amp;parentCandidate == &amp;parent) {
223             tableBuilder().attach(downcast&lt;RenderTable&gt;(parentCandidate), WTFMove(child), beforeChild);
224             return;
225         }
226         insertRecursiveIfNeeded(parentCandidate);
227         return;
228     }
229 
230     if (is&lt;RenderRubyAsBlock&gt;(parent)) {
231         insertRecursiveIfNeeded(rubyBuilder().findOrCreateParentForChild(downcast&lt;RenderRubyAsBlock&gt;(parent), *child, beforeChild));
232         return;
233     }
234 
235     if (is&lt;RenderRubyAsInline&gt;(parent)) {
236         insertRecursiveIfNeeded(rubyBuilder().findOrCreateParentForChild(downcast&lt;RenderRubyAsInline&gt;(parent), *child, beforeChild));
237         return;
238     }
239 
240     if (is&lt;RenderRubyRun&gt;(parent)) {
241         rubyBuilder().attach(downcast&lt;RenderRubyRun&gt;(parent), WTFMove(child), beforeChild);
242         return;
243     }
244 
245     if (is&lt;RenderButton&gt;(parent)) {
246         formControlsBuilder().attach(downcast&lt;RenderButton&gt;(parent), WTFMove(child), beforeChild);
247         return;
248     }
249 
250     if (is&lt;RenderMenuList&gt;(parent)) {
251         formControlsBuilder().attach(downcast&lt;RenderMenuList&gt;(parent), WTFMove(child), beforeChild);
252         return;
253     }
254 
255     if (is&lt;RenderSVGContainer&gt;(parent)) {
256         svgBuilder().attach(downcast&lt;RenderSVGContainer&gt;(parent), WTFMove(child), beforeChild);
257         return;
258     }
259 
260     if (is&lt;RenderSVGInline&gt;(parent)) {
261         svgBuilder().attach(downcast&lt;RenderSVGInline&gt;(parent), WTFMove(child), beforeChild);
262         return;
263     }
264 
265     if (is&lt;RenderSVGRoot&gt;(parent)) {
266         svgBuilder().attach(downcast&lt;RenderSVGRoot&gt;(parent), WTFMove(child), beforeChild);
267         return;
268     }
269 
270     if (is&lt;RenderSVGText&gt;(parent)) {
271         svgBuilder().attach(downcast&lt;RenderSVGText&gt;(parent), WTFMove(child), beforeChild);
272         return;
273     }
274 
275 #if ENABLE(MATHML)
276     if (is&lt;RenderMathMLFenced&gt;(parent)) {
277         mathMLBuilder().attach(downcast&lt;RenderMathMLFenced&gt;(parent), WTFMove(child), beforeChild);
278         return;
279     }
280 #endif
281 
282     if (is&lt;RenderGrid&gt;(parent)) {
283         attachToRenderGrid(downcast&lt;RenderGrid&gt;(parent), WTFMove(child), beforeChild);
284         return;
285     }
286 
287     if (is&lt;RenderBlockFlow&gt;(parent)) {
288         blockFlowBuilder().attach(downcast&lt;RenderBlockFlow&gt;(parent), WTFMove(child), beforeChild);
289         return;
290     }
291 
292     if (is&lt;RenderBlock&gt;(parent)) {
293         blockBuilder().attach(downcast&lt;RenderBlock&gt;(parent), WTFMove(child), beforeChild);
294         return;
295     }
296 
297     if (is&lt;RenderInline&gt;(parent)) {
298         inlineBuilder().attach(downcast&lt;RenderInline&gt;(parent), WTFMove(child), beforeChild);
299         return;
300     }
301 
302     attachToRenderElement(parent, WTFMove(child), beforeChild);
303 }
304 
305 void RenderTreeBuilder::attachIgnoringContinuation(RenderElement&amp; parent, RenderPtr&lt;RenderObject&gt; child, RenderObject* beforeChild)
306 {
307     if (is&lt;RenderInline&gt;(parent)) {
308         inlineBuilder().attachIgnoringContinuation(downcast&lt;RenderInline&gt;(parent), WTFMove(child), beforeChild);
309         return;
310     }
311 
312     if (is&lt;RenderBlock&gt;(parent)) {
313         blockBuilder().attachIgnoringContinuation(downcast&lt;RenderBlock&gt;(parent), WTFMove(child), beforeChild);
314         return;
315     }
316 
317     attach(parent, WTFMove(child), beforeChild);
318 }
319 
320 RenderPtr&lt;RenderObject&gt; RenderTreeBuilder::detach(RenderElement&amp; parent, RenderObject&amp; child, CanCollapseAnonymousBlock canCollapseAnonymousBlock)
321 {
322     if (is&lt;RenderRubyAsInline&gt;(parent))
323         return rubyBuilder().detach(downcast&lt;RenderRubyAsInline&gt;(parent), child);
324 
325     if (is&lt;RenderRubyAsBlock&gt;(parent))
326         return rubyBuilder().detach(downcast&lt;RenderRubyAsBlock&gt;(parent), child);
327 
328     if (is&lt;RenderRubyRun&gt;(parent))
329         return rubyBuilder().detach(downcast&lt;RenderRubyRun&gt;(parent), child);
330 
331     if (is&lt;RenderMenuList&gt;(parent))
332         return formControlsBuilder().detach(downcast&lt;RenderMenuList&gt;(parent), child);
333 
334     if (is&lt;RenderButton&gt;(parent))
335         return formControlsBuilder().detach(downcast&lt;RenderButton&gt;(parent), child);
336 
337     if (is&lt;RenderGrid&gt;(parent))
338         return detachFromRenderGrid(downcast&lt;RenderGrid&gt;(parent), child);
339 
340     if (is&lt;RenderSVGText&gt;(parent))
341         return svgBuilder().detach(downcast&lt;RenderSVGText&gt;(parent), child);
342 
343     if (is&lt;RenderSVGInline&gt;(parent))
344         return svgBuilder().detach(downcast&lt;RenderSVGInline&gt;(parent), child);
345 
346     if (is&lt;RenderSVGContainer&gt;(parent))
347         return svgBuilder().detach(downcast&lt;RenderSVGContainer&gt;(parent), child);
348 
349     if (is&lt;RenderSVGRoot&gt;(parent))
350         return svgBuilder().detach(downcast&lt;RenderSVGRoot&gt;(parent), child);
351 
352     if (is&lt;RenderBlockFlow&gt;(parent))
353         return blockBuilder().detach(downcast&lt;RenderBlockFlow&gt;(parent), child, canCollapseAnonymousBlock);
354 
355     if (is&lt;RenderBlock&gt;(parent))
356         return blockBuilder().detach(downcast&lt;RenderBlock&gt;(parent), child, canCollapseAnonymousBlock);
357 
358     return detachFromRenderElement(parent, child);
359 }
360 
361 void RenderTreeBuilder::attach(RenderTreePosition&amp; position, RenderPtr&lt;RenderObject&gt; child)
362 {
363     attach(position.parent(), WTFMove(child), position.nextSibling());
364 }
365 
366 #if ENABLE(FULLSCREEN_API)
367 void RenderTreeBuilder::createPlaceholderForFullScreen(RenderFullScreen&amp; renderer, std::unique_ptr&lt;RenderStyle&gt; style, const LayoutRect&amp; frameRect)
368 {
369     fullScreenBuilder().createPlaceholder(renderer, WTFMove(style), frameRect);
370 }
371 #endif
372 
373 void RenderTreeBuilder::attachToRenderElement(RenderElement&amp; parent, RenderPtr&lt;RenderObject&gt; child, RenderObject* beforeChild)
374 {
375     if (tableBuilder().childRequiresTable(parent, *child)) {
376         RenderTable* table;
377         RenderObject* afterChild = beforeChild ? beforeChild-&gt;previousSibling() : parent.lastChild();
378         if (afterChild &amp;&amp; afterChild-&gt;isAnonymous() &amp;&amp; is&lt;RenderTable&gt;(*afterChild) &amp;&amp; !afterChild-&gt;isBeforeContent())
379             table = downcast&lt;RenderTable&gt;(afterChild);
380         else {
381             auto newTable = RenderTable::createAnonymousWithParentRenderer(parent);
382             table = newTable.get();
383             attach(parent, WTFMove(newTable), beforeChild);
384         }
385 
386         attach(*table, WTFMove(child));
387         return;
388     }
389     auto&amp; newChild = *child.get();
390     attachToRenderElementInternal(parent, WTFMove(child), beforeChild);
391     parent.didAttachChild(newChild, beforeChild);
392 }
393 
394 void RenderTreeBuilder::attachToRenderElementInternal(RenderElement&amp; parent, RenderPtr&lt;RenderObject&gt; child, RenderObject* beforeChild)
395 {
396     RELEASE_ASSERT_WITH_MESSAGE(!parent.view().frameView().layoutContext().layoutState(), &quot;Layout must not mutate render tree&quot;);
397     ASSERT(parent.canHaveChildren() || parent.canHaveGeneratedChildren());
398     ASSERT(!child-&gt;parent());
399     ASSERT(!parent.isRenderBlockFlow() || (!child-&gt;isTableSection() &amp;&amp; !child-&gt;isTableRow() &amp;&amp; !child-&gt;isTableCell()));
400 
401     while (beforeChild &amp;&amp; beforeChild-&gt;parent() &amp;&amp; beforeChild-&gt;parent() != &amp;parent)
402         beforeChild = beforeChild-&gt;parent();
403 
404     ASSERT(!beforeChild || beforeChild-&gt;parent() == &amp;parent);
405     ASSERT(!is&lt;RenderText&gt;(beforeChild) || !downcast&lt;RenderText&gt;(*beforeChild).inlineWrapperForDisplayContents());
406 
407     // Take the ownership.
408     auto* newChild = parent.attachRendererInternal(WTFMove(child), beforeChild);
409 
410     newChild-&gt;initializeFragmentedFlowStateOnInsertion();
411     if (!parent.renderTreeBeingDestroyed()) {
412         newChild-&gt;insertedIntoTree();
413 
414         auto* fragmentedFlow = newChild-&gt;enclosingFragmentedFlow();
415         if (is&lt;RenderMultiColumnFlow&gt;(fragmentedFlow))
416             multiColumnBuilder().multiColumnDescendantInserted(downcast&lt;RenderMultiColumnFlow&gt;(*fragmentedFlow), *newChild);
417 
418         if (is&lt;RenderElement&gt;(*newChild))
419             RenderCounter::rendererSubtreeAttached(downcast&lt;RenderElement&gt;(*newChild));
420     }
421 
422     newChild-&gt;setNeedsLayoutAndPrefWidthsRecalc();
423     parent.setPreferredLogicalWidthsDirty(true);
424     if (!parent.normalChildNeedsLayout())
425         parent.setChildNeedsLayout(); // We may supply the static position for an absolute positioned child.
426 
427     if (AXObjectCache* cache = parent.document().axObjectCache())
428         cache-&gt;childrenChanged(&amp;parent, newChild);
429     if (is&lt;RenderBlockFlow&gt;(parent))
430         downcast&lt;RenderBlockFlow&gt;(parent).invalidateLineLayoutPath();
431     if (parent.hasOutlineAutoAncestor() || parent.outlineStyleForRepaint().outlineStyleIsAuto() == OutlineIsAuto::On)
432         newChild-&gt;setHasOutlineAutoAncestor();
433 }
434 
435 void RenderTreeBuilder::move(RenderBoxModelObject&amp; from, RenderBoxModelObject&amp; to, RenderObject&amp; child, RenderObject* beforeChild, NormalizeAfterInsertion normalizeAfterInsertion)
436 {
437     // We assume that callers have cleared their positioned objects list for child moves so the
438     // positioned renderer maps don&#39;t become stale. It would be too slow to do the map lookup on each call.
439     ASSERT(normalizeAfterInsertion == NormalizeAfterInsertion::No || !is&lt;RenderBlock&gt;(from) || !downcast&lt;RenderBlock&gt;(from).hasPositionedObjects());
440 
441     ASSERT(&amp;from == child.parent());
442     ASSERT(!beforeChild || &amp;to == beforeChild-&gt;parent());
443     if (normalizeAfterInsertion == NormalizeAfterInsertion::Yes &amp;&amp; (to.isRenderBlock() || to.isRenderInline())) {
444         // Takes care of adding the new child correctly if toBlock and fromBlock
445         // have different kind of children (block vs inline).
446         auto childToMove = detachFromRenderElement(from, child);
447         attach(to, WTFMove(childToMove), beforeChild);
448     } else {
449         auto childToMove = detachFromRenderElement(from, child);
450         attachToRenderElementInternal(to, WTFMove(childToMove), beforeChild);
451     }
452 }
453 
454 void RenderTreeBuilder::move(RenderBoxModelObject&amp; from, RenderBoxModelObject&amp; to, RenderObject&amp; child, NormalizeAfterInsertion normalizeAfterInsertion)
455 {
456     move(from, to, child, nullptr, normalizeAfterInsertion);
457 }
458 
459 void RenderTreeBuilder::moveAllChildren(RenderBoxModelObject&amp; from, RenderBoxModelObject&amp; to, NormalizeAfterInsertion normalizeAfterInsertion)
460 {
461     moveAllChildren(from, to, nullptr, normalizeAfterInsertion);
462 }
463 
464 void RenderTreeBuilder::moveAllChildren(RenderBoxModelObject&amp; from, RenderBoxModelObject&amp; to, RenderObject* beforeChild, NormalizeAfterInsertion normalizeAfterInsertion)
465 {
466     moveChildren(from, to, from.firstChild(), nullptr, beforeChild, normalizeAfterInsertion);
467 }
468 
469 void RenderTreeBuilder::moveChildren(RenderBoxModelObject&amp; from, RenderBoxModelObject&amp; to, RenderObject* startChild, RenderObject* endChild, NormalizeAfterInsertion normalizeAfterInsertion)
470 {
471     moveChildren(from, to, startChild, endChild, nullptr, normalizeAfterInsertion);
472 }
473 
474 void RenderTreeBuilder::moveChildren(RenderBoxModelObject&amp; from, RenderBoxModelObject&amp; to, RenderObject* startChild, RenderObject* endChild, RenderObject* beforeChild, NormalizeAfterInsertion normalizeAfterInsertion)
475 {
476     // This condition is rarely hit since this function is usually called on
477     // anonymous blocks which can no longer carry positioned objects (see r120761)
478     // or when fullRemoveInsert is false.
479     if (normalizeAfterInsertion == NormalizeAfterInsertion::Yes &amp;&amp; is&lt;RenderBlock&gt;(from)) {
480         downcast&lt;RenderBlock&gt;(from).removePositionedObjects(nullptr);
481         if (is&lt;RenderBlockFlow&gt;(from))
482             downcast&lt;RenderBlockFlow&gt;(from).removeFloatingObjects();
483     }
484 
485     ASSERT(!beforeChild || &amp;to == beforeChild-&gt;parent());
486     for (RenderObject* child = startChild; child &amp;&amp; child != endChild; ) {
487         // Save our next sibling as moveChildTo will clear it.
488         RenderObject* nextSibling = child-&gt;nextSibling();
489 
490         // FIXME: This logic here fails to detect the first letter in certain cases
491         // and skips a valid sibling renderer (see webkit.org/b/163737).
492         // Check to make sure we&#39;re not saving the firstLetter as the nextSibling.
493         // When the |child| object will be moved, its firstLetter will be recreated,
494         // so saving it now in nextSibling would leave us with a stale object.
495         if (is&lt;RenderTextFragment&gt;(*child) &amp;&amp; is&lt;RenderText&gt;(nextSibling)) {
496             RenderObject* firstLetterObj = nullptr;
497             if (RenderBlock* block = downcast&lt;RenderTextFragment&gt;(*child).blockForAccompanyingFirstLetter()) {
498                 RenderElement* firstLetterContainer = nullptr;
499                 block-&gt;getFirstLetter(firstLetterObj, firstLetterContainer, child);
500             }
501 
502             // This is the first letter, skip it.
503             if (firstLetterObj == nextSibling)
504                 nextSibling = nextSibling-&gt;nextSibling();
505         }
506 
507         move(from, to, *child, beforeChild, normalizeAfterInsertion);
508         child = nextSibling;
509     }
510 }
511 
512 void RenderTreeBuilder::moveAllChildrenIncludingFloats(RenderBlock&amp; from, RenderBlock&amp; to, RenderTreeBuilder::NormalizeAfterInsertion normalizeAfterInsertion)
513 {
514     if (is&lt;RenderBlockFlow&gt;(from)) {
515         blockFlowBuilder().moveAllChildrenIncludingFloats(downcast&lt;RenderBlockFlow&gt;(from), to, normalizeAfterInsertion);
516         return;
517     }
518     moveAllChildren(from, to, normalizeAfterInsertion);
519 }
520 
521 void RenderTreeBuilder::normalizeTreeAfterStyleChange(RenderElement&amp; renderer, RenderStyle&amp; oldStyle)
522 {
523     if (!renderer.parent())
524         return;
525 
526     auto&amp; parent = *renderer.parent();
527 
528     bool wasFloating = oldStyle.isFloating();
529     bool wasOufOfFlowPositioned = oldStyle.hasOutOfFlowPosition();
530     bool isFloating = renderer.style().isFloating();
531     bool isOutOfFlowPositioned = renderer.style().hasOutOfFlowPosition();
532     bool startsAffectingParent = false;
533     bool noLongerAffectsParent = false;
534 
535     if (is&lt;RenderBlock&gt;(parent))
536         noLongerAffectsParent = (!wasFloating &amp;&amp; isFloating) || (!wasOufOfFlowPositioned &amp;&amp; isOutOfFlowPositioned);
537 
538     if (is&lt;RenderBlockFlow&gt;(parent) || is&lt;RenderInline&gt;(parent)) {
539         startsAffectingParent = (wasFloating || wasOufOfFlowPositioned) &amp;&amp; !isFloating &amp;&amp; !isOutOfFlowPositioned;
540         ASSERT(!startsAffectingParent || !noLongerAffectsParent);
541     }
542 
543     if (startsAffectingParent) {
544         // We have gone from not affecting the inline status of the parent flow to suddenly
545         // having an impact. See if there is a mismatch between the parent flow&#39;s
546         // childrenInline() state and our state.
547         // FIXME(186894): startsAffectingParent has clearly nothing to do with resetting the inline state.
548         if (!is&lt;RenderSVGInline&gt;(renderer))
549             renderer.setInline(renderer.style().isDisplayInlineType());
550         if (renderer.isInline() != renderer.parent()-&gt;childrenInline())
551             childFlowStateChangesAndAffectsParentBlock(renderer);
552         return;
553     }
554 
555     if (noLongerAffectsParent) {
556         childFlowStateChangesAndNoLongerAffectsParentBlock(renderer);
557 
558         if (is&lt;RenderBlockFlow&gt;(renderer)) {
559             // Fresh floats need to be reparented if they actually belong to the previous anonymous block.
560             // It copies the logic of RenderBlock::addChildIgnoringContinuation
561             if (isFloating &amp;&amp; renderer.previousSibling() &amp;&amp; renderer.previousSibling()-&gt;isAnonymousBlock())
562                 move(downcast&lt;RenderBoxModelObject&gt;(parent), downcast&lt;RenderBoxModelObject&gt;(*renderer.previousSibling()), renderer, RenderTreeBuilder::NormalizeAfterInsertion::No);
563         }
564     }
565 }
566 
567 void RenderTreeBuilder::makeChildrenNonInline(RenderBlock&amp; parent, RenderObject* insertionPoint)
568 {
569     // makeChildrenNonInline takes a block whose children are *all* inline and it
570     // makes sure that inline children are coalesced under anonymous
571     // blocks. If |insertionPoint| is defined, then it represents the insertion point for
572     // the new block child that is causing us to have to wrap all the inlines. This
573     // means that we cannot coalesce inlines before |insertionPoint| with inlines following
574     // |insertionPoint|, because the new child is going to be inserted in between the inlines,
575     // splitting them.
576     ASSERT(parent.isInlineBlockOrInlineTable() || !parent.isInline());
577     ASSERT(!insertionPoint || insertionPoint-&gt;parent() == &amp;parent);
578 
579     parent.setChildrenInline(false);
580 
581     auto* child = parent.firstChild();
582     if (!child)
583         return;
584 
585     parent.deleteLines();
586 
587     while (child) {
588         RenderObject* inlineRunStart = nullptr;
589         RenderObject* inlineRunEnd = nullptr;
590         getInlineRun(child, insertionPoint, inlineRunStart, inlineRunEnd);
591 
592         if (!inlineRunStart)
593             break;
594 
595         child = inlineRunEnd-&gt;nextSibling();
596 
597         auto newBlock = parent.createAnonymousBlock();
598         auto&amp; block = *newBlock;
599         attachToRenderElementInternal(parent, WTFMove(newBlock), inlineRunStart);
600         moveChildren(parent, block, inlineRunStart, child, RenderTreeBuilder::NormalizeAfterInsertion::No);
601     }
602 #ifndef NDEBUG
603     for (RenderObject* c = parent.firstChild(); c; c = c-&gt;nextSibling())
604         ASSERT(!c-&gt;isInline());
605 #endif
606     parent.repaint();
607 }
608 
609 RenderObject* RenderTreeBuilder::splitAnonymousBoxesAroundChild(RenderBox&amp; parent, RenderObject&amp; originalBeforeChild)
610 {
611     // Adjust beforeChild if it is a column spanner and has been moved out of its original position.
612     auto* beforeChild = RenderTreeBuilder::MultiColumn::adjustBeforeChildForMultiColumnSpannerIfNeeded(originalBeforeChild);
613     bool didSplitParentAnonymousBoxes = false;
614 
615     while (beforeChild-&gt;parent() != &amp;parent) {
616         auto&amp; boxToSplit = downcast&lt;RenderBox&gt;(*beforeChild-&gt;parent());
617         if (boxToSplit.firstChild() != beforeChild &amp;&amp; boxToSplit.isAnonymous()) {
618             didSplitParentAnonymousBoxes = true;
619 
620             // We have to split the parent box into two boxes and move children
621             // from |beforeChild| to end into the new post box.
622             auto newPostBox = boxToSplit.createAnonymousBoxWithSameTypeAs(parent);
623             auto&amp; postBox = *newPostBox;
624             postBox.setChildrenInline(boxToSplit.childrenInline());
625             RenderBox* parentBox = downcast&lt;RenderBox&gt;(boxToSplit.parent());
626             // We need to invalidate the |parentBox| before inserting the new node
627             // so that the table repainting logic knows the structure is dirty.
628             // See for example RenderTableCell:clippedOverflowRectForRepaint.
629             markBoxForRelayoutAfterSplit(*parentBox);
630             attachToRenderElementInternal(*parentBox, WTFMove(newPostBox), boxToSplit.nextSibling());
631             moveChildren(boxToSplit, postBox, beforeChild, nullptr, RenderTreeBuilder::NormalizeAfterInsertion::Yes);
632 
633             markBoxForRelayoutAfterSplit(boxToSplit);
634             markBoxForRelayoutAfterSplit(postBox);
635 
636             beforeChild = &amp;postBox;
637         } else
638             beforeChild = &amp;boxToSplit;
639     }
640 
641     if (didSplitParentAnonymousBoxes)
642         markBoxForRelayoutAfterSplit(parent);
643 
644     ASSERT(beforeChild-&gt;parent() == &amp;parent);
645     return beforeChild;
646 }
647 
648 void RenderTreeBuilder::childFlowStateChangesAndAffectsParentBlock(RenderElement&amp; child)
649 {
650     auto* parent = child.parent();
651     if (!child.isInline()) {
652         if (is&lt;RenderBlock&gt;(parent))
653             blockBuilder().childBecameNonInline(downcast&lt;RenderBlock&gt;(*parent), child);
654         else if (is&lt;RenderInline&gt;(*parent))
655             inlineBuilder().childBecameNonInline(downcast&lt;RenderInline&gt;(*parent), child);
656 
657         // childBecameNonInline might have re-parented us.
658         if (auto* newParent = child.parent()) {
659             // We need to re-run the grid items placement if it had gained a new item.
660             if (newParent != parent &amp;&amp; is&lt;RenderGrid&gt;(*newParent))
661                 downcast&lt;RenderGrid&gt;(*newParent).dirtyGrid();
662         }
663     } else {
664         // An anonymous block must be made to wrap this inline.
665         auto newBlock = downcast&lt;RenderBlock&gt;(*parent).createAnonymousBlock();
666         auto&amp; block = *newBlock;
667         attachToRenderElementInternal(*parent, WTFMove(newBlock), &amp;child);
668         auto thisToMove = detachFromRenderElement(*parent, child);
669         attachToRenderElementInternal(block, WTFMove(thisToMove));
670     }
671 }
672 
673 void RenderTreeBuilder::removeAnonymousWrappersForInlineChildrenIfNeeded(RenderElement&amp; parent)
674 {
675     if (!is&lt;RenderBlock&gt;(parent))
676         return;
677     auto&amp; blockParent = downcast&lt;RenderBlock&gt;(parent);
678     if (!blockParent.canDropAnonymousBlockChild())
679         return;
680 
681     // We have changed to floated or out-of-flow positioning so maybe all our parent&#39;s
682     // children can be inline now. Bail if there are any block children left on the line,
683     // otherwise we can proceed to stripping solitary anonymous wrappers from the inlines.
684     // FIXME: We should also handle split inlines here - we exclude them at the moment by returning
685     // if we find a continuation.
<a name="6" id="anc6"></a><span class="line-modified">686     auto* current = blockParent.firstChild();</span>
<span class="line-modified">687     while (current &amp;&amp; ((current-&gt;isAnonymousBlock() &amp;&amp; !downcast&lt;RenderBlock&gt;(*current).isContinuation()) || current-&gt;style().isFloating() || current-&gt;style().hasOutOfFlowPosition()))</span>
<span class="line-modified">688         current = current-&gt;nextSibling();</span>
<span class="line-modified">689 </span>
<span class="line-modified">690     if (current)</span>
<span class="line-modified">691         return;</span>













692 
<a name="7" id="anc7"></a><span class="line-modified">693     RenderObject* next;</span>
<span class="line-modified">694     for (current = blockParent.firstChild(); current; current = next) {</span>
695         next = current-&gt;nextSibling();
696         if (current-&gt;isAnonymousBlock())
697             blockBuilder().dropAnonymousBoxChild(blockParent, downcast&lt;RenderBlock&gt;(*current));
698     }
699 }
700 
701 void RenderTreeBuilder::childFlowStateChangesAndNoLongerAffectsParentBlock(RenderElement&amp; child)
702 {
703     ASSERT(child.parent());
704     removeAnonymousWrappersForInlineChildrenIfNeeded(*child.parent());
705 }
706 
707 static bool isAnonymousAndSafeToDelete(RenderElement&amp; element)
708 {
709     if (!element.isAnonymous())
710         return false;
711     if (element.isRenderView() || element.isRenderFragmentedFlow())
712         return false;
713     return true;
714 }
715 
716 static RenderObject&amp; findDestroyRootIncludingAnonymous(RenderObject&amp; renderer)
717 {
718     auto* destroyRoot = &amp;renderer;
719     while (true) {
720         auto&amp; destroyRootParent = *destroyRoot-&gt;parent();
721         if (!isAnonymousAndSafeToDelete(destroyRootParent))
722             break;
723         bool destroyingOnlyChild = destroyRootParent.firstChild() == destroyRoot &amp;&amp; destroyRootParent.lastChild() == destroyRoot;
724         if (!destroyingOnlyChild)
725             break;
726         destroyRoot = &amp;destroyRootParent;
727     }
728     return *destroyRoot;
729 }
730 
731 void RenderTreeBuilder::destroyAndCleanUpAnonymousWrappers(RenderObject&amp; child)
732 {
733     // If the tree is destroyed, there is no need for a clean-up phase.
734     if (child.renderTreeBeingDestroyed()) {
735         destroy(child);
736         return;
737     }
738 
739     // Remove intruding floats from sibling blocks before detaching.
740     if (is&lt;RenderBox&gt;(child) &amp;&amp; child.isFloatingOrOutOfFlowPositioned())
741         downcast&lt;RenderBox&gt;(child).removeFloatingOrPositionedChildFromBlockLists();
742     auto&amp; destroyRoot = findDestroyRootIncludingAnonymous(child);
743     if (is&lt;RenderTableRow&gt;(destroyRoot))
744         tableBuilder().collapseAndDestroyAnonymousSiblingRows(downcast&lt;RenderTableRow&gt;(destroyRoot));
745 
746     // FIXME: Do not try to collapse/cleanup the anonymous wrappers inside destroy (see webkit.org/b/186746).
747     auto destroyRootParent = makeWeakPtr(*destroyRoot.parent());
748     destroy(destroyRoot);
749     if (!destroyRootParent)
750         return;
751     removeAnonymousWrappersForInlineChildrenIfNeeded(*destroyRootParent);
752 
753     // Anonymous parent might have become empty, try to delete it too.
754     if (isAnonymousAndSafeToDelete(*destroyRootParent) &amp;&amp; !destroyRootParent-&gt;firstChild())
755         destroyAndCleanUpAnonymousWrappers(*destroyRootParent);
756     // WARNING: child is deleted here.
757 }
758 
759 void RenderTreeBuilder::updateAfterDescendants(RenderElement&amp; renderer)
760 {
761     if (is&lt;RenderBlock&gt;(renderer))
762         firstLetterBuilder().updateAfterDescendants(downcast&lt;RenderBlock&gt;(renderer));
763     if (is&lt;RenderListItem&gt;(renderer))
764         listBuilder().updateItemMarker(downcast&lt;RenderListItem&gt;(renderer));
765     if (is&lt;RenderBlockFlow&gt;(renderer))
766         multiColumnBuilder().updateAfterDescendants(downcast&lt;RenderBlockFlow&gt;(renderer));
767 }
768 
769 RenderPtr&lt;RenderObject&gt; RenderTreeBuilder::detachFromRenderGrid(RenderGrid&amp; parent, RenderObject&amp; child)
770 {
771     auto takenChild = blockBuilder().detach(parent, child);
772     // Positioned grid items do not take up space or otherwise participate in the layout of the grid,
773     // for that reason we don&#39;t need to mark the grid as dirty when they are removed.
774     if (child.isOutOfFlowPositioned())
775         return takenChild;
776 
777     // The grid needs to be recomputed as it might contain auto-placed items that will change their position.
778     parent.dirtyGrid();
779     return takenChild;
780 }
781 
782 RenderPtr&lt;RenderObject&gt; RenderTreeBuilder::detachFromRenderElement(RenderElement&amp; parent, RenderObject&amp; child)
783 {
784     RELEASE_ASSERT_WITH_MESSAGE(!parent.view().frameView().layoutContext().layoutState(), &quot;Layout must not mutate render tree&quot;);
785 
786     ASSERT(parent.canHaveChildren() || parent.canHaveGeneratedChildren());
787     ASSERT(child.parent() == &amp;parent);
788 
789     if (child.isFloatingOrOutOfFlowPositioned())
790         downcast&lt;RenderBox&gt;(child).removeFloatingOrPositionedChildFromBlockLists();
791 
792     // So that we&#39;ll get the appropriate dirty bit set (either that a normal flow child got yanked or
793     // that a positioned child got yanked). We also repaint, so that the area exposed when the child
794     // disappears gets repainted properly.
795     if (!parent.renderTreeBeingDestroyed() &amp;&amp; child.everHadLayout()) {
796         child.setNeedsLayoutAndPrefWidthsRecalc();
797         // We only repaint |child| if we have a RenderLayer as its visual overflow may not be tracked by its parent.
798         if (child.isBody())
799             parent.view().repaintRootContents();
800         else
801             child.repaint();
802     }
803 
804     // If we have a line box wrapper, delete it.
805     if (is&lt;RenderBox&gt;(child))
806         downcast&lt;RenderBox&gt;(child).deleteLineBoxWrapper();
807     else if (is&lt;RenderLineBreak&gt;(child))
808         downcast&lt;RenderLineBreak&gt;(child).deleteInlineBoxWrapper();
809 
810     if (!parent.renderTreeBeingDestroyed() &amp;&amp; is&lt;RenderFlexibleBox&gt;(parent) &amp;&amp; !child.isFloatingOrOutOfFlowPositioned() &amp;&amp; child.isBox())
811         downcast&lt;RenderFlexibleBox&gt;(parent).clearCachedChildIntrinsicContentLogicalHeight(downcast&lt;RenderBox&gt;(child));
812 
813     // If child is the start or end of the selection, then clear the selection to
814     // avoid problems of invalid pointers.
815     if (!parent.renderTreeBeingDestroyed() &amp;&amp; child.isSelectionBorder())
816         parent.frame().selection().setNeedsSelectionUpdate();
817 
818     if (!parent.renderTreeBeingDestroyed())
819         child.willBeRemovedFromTree();
820 
821     child.resetFragmentedFlowStateOnRemoval();
822 
823     // WARNING: There should be no code running between willBeRemovedFromTree() and the actual removal below.
824     // This is needed to avoid race conditions where willBeRemovedFromTree() would dirty the tree&#39;s structure
825     // and the code running here would force an untimely rebuilding, leaving |child| dangling.
826     auto childToTake = parent.detachRendererInternal(child);
827 
828     // rendererRemovedFromTree() walks the whole subtree. We can improve performance
829     // by skipping this step when destroying the entire tree.
830     if (!parent.renderTreeBeingDestroyed() &amp;&amp; is&lt;RenderElement&gt;(*childToTake))
831         RenderCounter::rendererRemovedFromTree(downcast&lt;RenderElement&gt;(*childToTake));
832 
833     if (!parent.renderTreeBeingDestroyed()) {
834         if (AXObjectCache* cache = parent.document().existingAXObjectCache())
835             cache-&gt;childrenChanged(&amp;parent);
836     }
837 
838     return childToTake;
839 }
840 
841 void RenderTreeBuilder::attachToRenderGrid(RenderGrid&amp; parent, RenderPtr&lt;RenderObject&gt; child, RenderObject* beforeChild)
842 {
843     auto&amp; newChild = *child;
844     blockBuilder().attach(parent, WTFMove(child), beforeChild);
845 
846     // Positioned grid items do not take up space or otherwise participate in the layout of the grid,
847     // for that reason we don&#39;t need to mark the grid as dirty when they are added.
848     if (newChild.isOutOfFlowPositioned())
849         return;
850 
851     // The grid needs to be recomputed as it might contain auto-placed items that
852     // will change their position.
853     parent.dirtyGrid();
854 }
855 
856 }
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>