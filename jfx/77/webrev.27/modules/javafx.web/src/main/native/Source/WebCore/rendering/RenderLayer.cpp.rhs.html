<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLayer.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2006-2017 Apple Inc. All rights reserved.
   3  *
   4  * Portions are Copyright (C) 1998 Netscape Communications Corporation.
   5  *
   6  * Other contributors:
   7  *   Robert O&#39;Callahan &lt;roc+@cs.cmu.edu&gt;
   8  *   David Baron &lt;dbaron@fas.harvard.edu&gt;
   9  *   Christian Biesinger &lt;cbiesinger@web.de&gt;
  10  *   Randall Jesup &lt;rjesup@wgate.com&gt;
  11  *   Roland Mainz &lt;roland.mainz@informatik.med.uni-giessen.de&gt;
  12  *   Josh Soref &lt;timeless@mac.com&gt;
  13  *   Boris Zbarsky &lt;bzbarsky@mit.edu&gt;
  14  *
  15  * This library is free software; you can redistribute it and/or
  16  * modify it under the terms of the GNU Lesser General Public
  17  * License as published by the Free Software Foundation; either
  18  * version 2.1 of the License, or (at your option) any later version.
  19  *
  20  * This library is distributed in the hope that it will be useful,
  21  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  22  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  23  * Lesser General Public License for more details.
  24  *
  25  * You should have received a copy of the GNU Lesser General Public
  26  * License along with this library; if not, write to the Free Software
  27  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
  28  *
  29  * Alternatively, the contents of this file may be used under the terms
  30  * of either the Mozilla Public License Version 1.1, found at
  31  * http://www.mozilla.org/MPL/ (the &quot;MPL&quot;) or the GNU General Public
  32  * License Version 2.0, found at http://www.fsf.org/copyleft/gpl.html
  33  * (the &quot;GPL&quot;), in which case the provisions of the MPL or the GPL are
  34  * applicable instead of those above.  If you wish to allow use of your
  35  * version of this file only under the terms of one of those two
  36  * licenses (the MPL or the GPL) and not to allow others to use your
  37  * version of this file under the LGPL, indicate your decision by
  38  * deletingthe provisions above and replace them with the notice and
  39  * other provisions required by the MPL or the GPL, as the case may be.
  40  * If you do not delete the provisions above, a recipient may use your
  41  * version of this file under any of the LGPL, the MPL or the GPL.
  42  */
  43 
  44 #include &quot;config.h&quot;
  45 #include &quot;RenderLayer.h&quot;
  46 
  47 #include &quot;BoxShape.h&quot;
  48 #include &quot;CSSAnimationController.h&quot;
  49 #include &quot;CSSFilter.h&quot;
  50 #include &quot;CSSPropertyNames.h&quot;
  51 #include &quot;Chrome.h&quot;
  52 #include &quot;DebugPageOverlays.h&quot;
  53 #include &quot;DeprecatedGlobalSettings.h&quot;
  54 #include &quot;Document.h&quot;
  55 #include &quot;DocumentEventQueue.h&quot;
  56 #include &quot;DocumentMarkerController.h&quot;
  57 #include &quot;DocumentTimeline.h&quot;
  58 #include &quot;Element.h&quot;
  59 #include &quot;EventHandler.h&quot;
  60 #include &quot;FEColorMatrix.h&quot;
  61 #include &quot;FEMerge.h&quot;
  62 #include &quot;FloatConversion.h&quot;
  63 #include &quot;FloatPoint3D.h&quot;
  64 #include &quot;FloatRect.h&quot;
  65 #include &quot;FloatRoundedRect.h&quot;
  66 #include &quot;FocusController.h&quot;
  67 #include &quot;Frame.h&quot;
  68 #include &quot;FrameLoader.h&quot;
  69 #include &quot;FrameLoaderClient.h&quot;
  70 #include &quot;FrameSelection.h&quot;
  71 #include &quot;FrameTree.h&quot;
  72 #include &quot;FrameView.h&quot;
  73 #include &quot;Gradient.h&quot;
  74 #include &quot;GraphicsContext.h&quot;
  75 #include &quot;HTMLFormControlElement.h&quot;
  76 #include &quot;HTMLFrameElement.h&quot;
  77 #include &quot;HTMLFrameOwnerElement.h&quot;
  78 #include &quot;HTMLIFrameElement.h&quot;
  79 #include &quot;HTMLNames.h&quot;
  80 #include &quot;HTMLParserIdioms.h&quot;
  81 #include &quot;HitTestRequest.h&quot;
  82 #include &quot;HitTestResult.h&quot;
  83 #include &quot;HitTestingTransformState.h&quot;
  84 #include &quot;Logging.h&quot;
  85 #include &quot;OverflowEvent.h&quot;
  86 #include &quot;OverlapTestRequestClient.h&quot;
  87 #include &quot;Page.h&quot;
  88 #include &quot;PlatformMouseEvent.h&quot;
  89 #include &quot;RenderFlexibleBox.h&quot;
  90 #include &quot;RenderFragmentContainer.h&quot;
  91 #include &quot;RenderFragmentedFlow.h&quot;
  92 #include &quot;RenderGeometryMap.h&quot;
  93 #include &quot;RenderImage.h&quot;
  94 #include &quot;RenderInline.h&quot;
  95 #include &quot;RenderIterator.h&quot;
  96 #include &quot;RenderLayerBacking.h&quot;
  97 #include &quot;RenderLayerCompositor.h&quot;
  98 #include &quot;RenderLayerFilters.h&quot;
  99 #include &quot;RenderMarquee.h&quot;
 100 #include &quot;RenderMultiColumnFlow.h&quot;
 101 #include &quot;RenderReplica.h&quot;
 102 #include &quot;RenderSVGResourceClipper.h&quot;
 103 #include &quot;RenderSVGRoot.h&quot;
 104 #include &quot;RenderScrollbar.h&quot;
 105 #include &quot;RenderScrollbarPart.h&quot;
 106 #include &quot;RenderTableCell.h&quot;
 107 #include &quot;RenderTableRow.h&quot;
 108 #include &quot;RenderText.h&quot;
 109 #include &quot;RenderTheme.h&quot;
 110 #include &quot;RenderTreeAsText.h&quot;
 111 #include &quot;RenderView.h&quot;
 112 #include &quot;RuntimeEnabledFeatures.h&quot;
 113 #include &quot;SVGNames.h&quot;
 114 #include &quot;ScaleTransformOperation.h&quot;
 115 #include &quot;ScriptDisallowedScope.h&quot;
 116 #include &quot;ScrollAnimator.h&quot;
 117 #include &quot;Scrollbar.h&quot;
 118 #include &quot;ScrollbarTheme.h&quot;
 119 #include &quot;ScrollingCoordinator.h&quot;
 120 #include &quot;Settings.h&quot;
 121 #include &quot;ShadowRoot.h&quot;
 122 #include &quot;SourceGraphic.h&quot;
 123 #include &quot;StyleProperties.h&quot;
 124 #include &quot;StyleResolver.h&quot;
 125 #include &quot;TransformationMatrix.h&quot;
 126 #include &quot;TranslateTransformOperation.h&quot;
 127 #include &quot;WheelEventTestTrigger.h&quot;
 128 #include &lt;stdio.h&gt;
 129 #include &lt;wtf/MonotonicTime.h&gt;
 130 #include &lt;wtf/StdLibExtras.h&gt;
 131 #include &lt;wtf/text/CString.h&gt;
 132 #include &lt;wtf/text/TextStream.h&gt;
 133 
 134 #if ENABLE(CSS_SCROLL_SNAP)
 135 #include &quot;AxisScrollSnapOffsets.h&quot;
 136 #endif
 137 
 138 #define MIN_INTERSECT_FOR_REVEAL 32
 139 
 140 namespace WebCore {
 141 
 142 using namespace HTMLNames;
 143 
 144 class ClipRects : public RefCounted&lt;ClipRects&gt; {
 145     WTF_MAKE_FAST_ALLOCATED;
 146 public:
 147     static Ref&lt;ClipRects&gt; create()
 148     {
 149         return adoptRef(*new ClipRects);
 150     }
 151 
 152     static Ref&lt;ClipRects&gt; create(const ClipRects&amp; other)
 153     {
 154         return adoptRef(*new ClipRects(other));
 155     }
 156 
 157     void reset()
 158     {
 159         m_overflowClipRect.reset();
 160         m_fixedClipRect.reset();
 161         m_posClipRect.reset();
 162         m_fixed = false;
 163     }
 164 
 165     const ClipRect&amp; overflowClipRect() const { return m_overflowClipRect; }
 166     void setOverflowClipRect(const ClipRect&amp; clipRect) { m_overflowClipRect = clipRect; }
 167 
 168     const ClipRect&amp; fixedClipRect() const { return m_fixedClipRect; }
 169     void setFixedClipRect(const ClipRect&amp; clipRect) { m_fixedClipRect = clipRect; }
 170 
 171     const ClipRect&amp; posClipRect() const { return m_posClipRect; }
 172     void setPosClipRect(const ClipRect&amp; clipRect) { m_posClipRect = clipRect; }
 173 
 174     bool fixed() const { return m_fixed; }
 175     void setFixed(bool fixed) { m_fixed = fixed; }
 176 
 177     bool operator==(const ClipRects&amp; other) const
 178     {
 179         return m_overflowClipRect == other.overflowClipRect()
 180             &amp;&amp; m_fixedClipRect == other.fixedClipRect()
 181             &amp;&amp; m_posClipRect == other.posClipRect()
 182             &amp;&amp; m_fixed == other.fixed();
 183     }
 184 
 185     ClipRects&amp; operator=(const ClipRects&amp; other)
 186     {
 187         m_overflowClipRect = other.overflowClipRect();
 188         m_fixedClipRect = other.fixedClipRect();
 189         m_posClipRect = other.posClipRect();
 190         m_fixed = other.fixed();
 191         return *this;
 192     }
 193 
 194 private:
 195     ClipRects() = default;
 196 
 197     ClipRects(const LayoutRect&amp; clipRect)
 198         : m_overflowClipRect(clipRect)
 199         , m_fixedClipRect(clipRect)
 200         , m_posClipRect(clipRect)
 201     {
 202     }
 203 
 204     ClipRects(const ClipRects&amp; other)
 205         : RefCounted()
 206         , m_fixed(other.fixed())
 207         , m_overflowClipRect(other.overflowClipRect())
 208         , m_fixedClipRect(other.fixedClipRect())
 209         , m_posClipRect(other.posClipRect())
 210     {
 211     }
 212 
 213     bool m_fixed { false };
 214     ClipRect m_overflowClipRect;
 215     ClipRect m_fixedClipRect;
 216     ClipRect m_posClipRect;
 217 };
 218 
 219 class ClipRectsCache {
 220     WTF_MAKE_FAST_ALLOCATED;
 221 public:
 222     ClipRectsCache()
 223     {
 224 #ifndef NDEBUG
 225         for (int i = 0; i &lt; NumCachedClipRectsTypes; ++i) {
 226             m_clipRectsRoot[i] = 0;
 227             m_scrollbarRelevancy[i] = IgnoreOverlayScrollbarSize;
 228         }
 229 #endif
 230     }
 231 
 232     ClipRects* getClipRects(ClipRectsType clipRectsType, ShouldRespectOverflowClip respectOverflow) const
 233     {
 234         return m_clipRects[getIndex(clipRectsType, respectOverflow)].get();
 235     }
 236 
 237     void setClipRects(ClipRectsType clipRectsType, ShouldRespectOverflowClip respectOverflow, RefPtr&lt;ClipRects&gt;&amp;&amp; clipRects)
 238     {
 239         m_clipRects[getIndex(clipRectsType, respectOverflow)] = WTFMove(clipRects);
 240     }
 241 
 242 #ifndef NDEBUG
 243     const RenderLayer* m_clipRectsRoot[NumCachedClipRectsTypes];
 244     OverlayScrollbarSizeRelevancy m_scrollbarRelevancy[NumCachedClipRectsTypes];
 245 #endif
 246 
 247 private:
 248     unsigned getIndex(ClipRectsType clipRectsType, ShouldRespectOverflowClip respectOverflow) const
 249     {
 250         unsigned index = static_cast&lt;unsigned&gt;(clipRectsType);
 251         if (respectOverflow == RespectOverflowClip)
 252             index += static_cast&lt;unsigned&gt;(NumCachedClipRectsTypes);
 253         ASSERT_WITH_SECURITY_IMPLICATION(index &lt; NumCachedClipRectsTypes * 2);
 254         return index;
 255     }
 256 
 257     RefPtr&lt;ClipRects&gt; m_clipRects[NumCachedClipRectsTypes * 2];
 258 };
 259 
 260 void makeMatrixRenderable(TransformationMatrix&amp; matrix, bool has3DRendering)
 261 {
 262 #if !ENABLE(3D_TRANSFORMS)
 263     UNUSED_PARAM(has3DRendering);
 264     matrix.makeAffine();
 265 #else
 266     if (!has3DRendering)
 267         matrix.makeAffine();
 268 #endif
 269 }
 270 
<a name="1" id="anc1"></a><span class="line-added"> 271 #if !LOG_DISABLED</span>
<span class="line-added"> 272 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const ClipRects&amp; clipRects)</span>
<span class="line-added"> 273 {</span>
<span class="line-added"> 274     TextStream::GroupScope scope(ts);</span>
<span class="line-added"> 275     ts &lt;&lt; indent &lt;&lt; &quot;ClipRects\n&quot;;</span>
<span class="line-added"> 276     ts &lt;&lt; indent &lt;&lt; &quot;  overflow  : &quot; &lt;&lt; clipRects.overflowClipRect() &lt;&lt; &quot;\n&quot;;</span>
<span class="line-added"> 277     ts &lt;&lt; indent &lt;&lt; &quot;  fixed     : &quot; &lt;&lt; clipRects.fixedClipRect() &lt;&lt; &quot;\n&quot;;</span>
<span class="line-added"> 278     ts &lt;&lt; indent &lt;&lt; &quot;  positioned: &quot; &lt;&lt; clipRects.posClipRect() &lt;&lt; &quot;\n&quot;;</span>
<span class="line-added"> 279 </span>
<span class="line-added"> 280     return ts;</span>
<span class="line-added"> 281 }</span>
<span class="line-added"> 282 </span>
<span class="line-added"> 283 #endif</span>
<span class="line-added"> 284 </span>
 285 RenderLayer::RenderLayer(RenderLayerModelObject&amp; rendererLayerModelObject)
 286     : m_isRenderViewLayer(rendererLayerModelObject.isRenderView())
 287     , m_forcedStackingContext(rendererLayerModelObject.isMedia())
<a name="2" id="anc2"></a><span class="line-added"> 288     , m_isOpportunisticStackingContext(false)</span>
 289     , m_zOrderListsDirty(false)
 290     , m_normalFlowListDirty(true)
 291     , m_hadNegativeZOrderList(false)
 292     , m_inResizeMode(false)
 293     , m_scrollDimensionsDirty(true)
 294     , m_hasSelfPaintingLayerDescendant(false)
 295     , m_hasSelfPaintingLayerDescendantDirty(false)
 296     , m_usedTransparency(false)
 297     , m_paintingInsideReflection(false)
 298     , m_inOverflowRelayout(false)
 299     , m_repaintStatus(NeedsNormalRepaint)
 300     , m_visibleContentStatusDirty(true)
 301     , m_hasVisibleContent(false)
 302     , m_visibleDescendantStatusDirty(false)
 303     , m_hasVisibleDescendant(false)
 304     , m_registeredScrollableArea(false)
 305     , m_isFixedIntersectingViewport(false)
<a name="3" id="anc3"></a><span class="line-added"> 306     , m_behavesAsFixed(false)</span>
 307     , m_3DTransformedDescendantStatusDirty(true)
 308     , m_has3DTransformedDescendant(false)
 309     , m_hasCompositingDescendant(false)
<a name="4" id="anc4"></a><span class="line-added"> 310     , m_hasCompositedScrollingAncestor(false)</span>
<span class="line-added"> 311     , m_hasCompositedScrollableOverflow(false)</span>
 312     , m_hasTransformedAncestor(false)
 313     , m_has3DTransformedAncestor(false)
 314     , m_indirectCompositingReason(static_cast&lt;unsigned&gt;(IndirectCompositingReason::None))
 315     , m_viewportConstrainedNotCompositedReason(NoNotCompositedReason)
 316 #if PLATFORM(IOS_FAMILY)
 317 #if ENABLE(IOS_TOUCH_EVENTS)
 318     , m_registeredAsTouchEventListenerForScrolling(false)
 319 #endif
 320     , m_adjustForIOSCaretWhenScrolling(false)
 321 #endif
<a name="5" id="anc5"></a>
 322     , m_requiresScrollPositionReconciliation(false)
 323     , m_containsDirtyOverlayScrollbars(false)
 324     , m_updatingMarqueePosition(false)
 325 #if !ASSERT_DISABLED
 326     , m_layerListMutationAllowed(true)
 327 #endif
 328 #if ENABLE(CSS_COMPOSITING)
 329     , m_blendMode(static_cast&lt;unsigned&gt;(BlendMode::Normal))
 330     , m_hasNotIsolatedCompositedBlendingDescendants(false)
 331     , m_hasNotIsolatedBlendingDescendants(false)
 332     , m_hasNotIsolatedBlendingDescendantsStatusDirty(false)
 333 #endif
 334     , m_renderer(rendererLayerModelObject)
 335 {
 336     setIsNormalFlowOnly(shouldBeNormalFlowOnly());
<a name="6" id="anc6"></a><span class="line-modified"> 337     setIsCSSStackingContext(shouldBeCSSStackingContext());</span>
 338 
 339     m_isSelfPaintingLayer = shouldBeSelfPaintingLayer();
 340 
 341     if (!renderer().firstChild()) {
 342         m_visibleContentStatusDirty = false;
 343         m_hasVisibleContent = renderer().style().visibility() == Visibility::Visible;
 344     }
 345 
 346     if (Element* element = renderer().element()) {
 347         // We save and restore only the scrollOffset as the other scroll values are recalculated.
 348         m_scrollPosition = element-&gt;savedLayerScrollPosition();
 349         if (!m_scrollPosition.isZero())
 350             scrollAnimator().setCurrentPosition(m_scrollPosition);
 351         element-&gt;setSavedLayerScrollPosition(IntPoint());
 352     }
 353 }
 354 
 355 RenderLayer::~RenderLayer()
 356 {
 357     if (inResizeMode())
 358         renderer().frame().eventHandler().resizeLayerDestroyed();
 359 
 360     ASSERT(m_registeredScrollableArea == renderer().view().frameView().containsScrollableArea(this));
 361 
 362     if (m_registeredScrollableArea)
 363         renderer().view().frameView().removeScrollableArea(this);
 364 
 365 #if ENABLE(IOS_TOUCH_EVENTS)
 366     unregisterAsTouchEventListenerForScrolling();
 367 #endif
 368     if (Element* element = renderer().element())
 369         element-&gt;setSavedLayerScrollPosition(m_scrollPosition);
 370 
 371     destroyScrollbar(HorizontalScrollbar);
 372     destroyScrollbar(VerticalScrollbar);
 373 
 374     if (auto* scrollingCoordinator = renderer().page().scrollingCoordinator())
 375         scrollingCoordinator-&gt;willDestroyScrollableArea(*this);
 376 
 377     if (m_reflection)
 378         removeReflection();
 379 
 380     clearScrollCorner();
 381     clearResizer();
 382 
 383     clearLayerFilters();
 384 
<a name="7" id="anc7"></a><span class="line-added"> 385     if (paintsIntoProvidedBacking()) {</span>
<span class="line-added"> 386         auto* backingProviderLayer = this-&gt;backingProviderLayer();</span>
<span class="line-added"> 387         if (backingProviderLayer-&gt;backing())</span>
<span class="line-added"> 388             backingProviderLayer-&gt;backing()-&gt;removeBackingSharingLayer(*this);</span>
<span class="line-added"> 389     }</span>
<span class="line-added"> 390 </span>
 391     // Child layers will be deleted by their corresponding render objects, so
 392     // we don&#39;t need to delete them ourselves.
 393 
 394     clearBacking(true);
 395 
 396     // Layer and all its children should be removed from the tree before destruction.
 397     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(renderer().renderTreeBeingDestroyed() || !parent());
 398     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(renderer().renderTreeBeingDestroyed() || !firstChild());
 399 }
 400 
 401 void RenderLayer::addChild(RenderLayer&amp; child, RenderLayer* beforeChild)
 402 {
 403     RenderLayer* prevSibling = beforeChild ? beforeChild-&gt;previousSibling() : lastChild();
 404     if (prevSibling) {
 405         child.setPreviousSibling(prevSibling);
 406         prevSibling-&gt;setNextSibling(&amp;child);
 407         ASSERT(prevSibling != &amp;child);
 408     } else
 409         setFirstChild(&amp;child);
 410 
 411     if (beforeChild) {
 412         beforeChild-&gt;setPreviousSibling(&amp;child);
 413         child.setNextSibling(beforeChild);
 414         ASSERT(beforeChild != &amp;child);
 415     } else
 416         setLastChild(&amp;child);
 417 
 418     child.setParent(this);
 419 
 420     dirtyPaintOrderListsOnChildChange(child);
 421 
 422     child.updateDescendantDependentFlags();
 423     if (child.m_hasVisibleContent || child.m_hasVisibleDescendant)
 424         setAncestorChainHasVisibleDescendant();
 425 
 426     if (child.isSelfPaintingLayer() || child.hasSelfPaintingLayerDescendant())
 427         setAncestorChainHasSelfPaintingLayerDescendant();
 428 
 429     if (compositor().hasContentCompositingLayers())
 430         setDescendantsNeedCompositingRequirementsTraversal();
 431 
 432     if (child.hasDescendantNeedingCompositingRequirementsTraversal() || child.needsCompositingRequirementsTraversal())
 433         child.setAncestorsHaveCompositingDirtyFlag(Compositing::HasDescendantNeedingRequirementsTraversal);
 434 
 435     if (child.hasDescendantNeedingUpdateBackingOrHierarchyTraversal() || child.needsUpdateBackingOrHierarchyTraversal())
 436         child.setAncestorsHaveCompositingDirtyFlag(Compositing::HasDescendantNeedingBackingOrHierarchyTraversal);
 437 
 438 #if ENABLE(CSS_COMPOSITING)
 439     if (child.hasBlendMode() || (child.hasNotIsolatedBlendingDescendants() &amp;&amp; !child.isolatesBlending()))
 440         updateAncestorChainHasBlendingDescendants(); // Why not just dirty?
 441 #endif
 442 
 443     compositor().layerWasAdded(*this, child);
 444 }
 445 
 446 void RenderLayer::removeChild(RenderLayer&amp; oldChild)
 447 {
 448     if (!renderer().renderTreeBeingDestroyed())
 449         compositor().layerWillBeRemoved(*this, oldChild);
 450 
 451     // remove the child
 452     if (oldChild.previousSibling())
 453         oldChild.previousSibling()-&gt;setNextSibling(oldChild.nextSibling());
 454     if (oldChild.nextSibling())
 455         oldChild.nextSibling()-&gt;setPreviousSibling(oldChild.previousSibling());
 456 
 457     if (m_first == &amp;oldChild)
 458         m_first = oldChild.nextSibling();
 459     if (m_last == &amp;oldChild)
 460         m_last = oldChild.previousSibling();
 461 
 462     dirtyPaintOrderListsOnChildChange(oldChild);
 463 
 464     oldChild.setPreviousSibling(nullptr);
 465     oldChild.setNextSibling(nullptr);
 466     oldChild.setParent(nullptr);
 467 
 468     oldChild.updateDescendantDependentFlags();
 469     if (oldChild.m_hasVisibleContent || oldChild.m_hasVisibleDescendant)
 470         dirtyAncestorChainVisibleDescendantStatus();
 471 
 472     if (oldChild.isSelfPaintingLayer() || oldChild.hasSelfPaintingLayerDescendant())
 473         dirtyAncestorChainHasSelfPaintingLayerDescendantStatus();
 474 
 475     if (compositor().hasContentCompositingLayers())
 476         setDescendantsNeedCompositingRequirementsTraversal();
 477 
 478 #if ENABLE(CSS_COMPOSITING)
 479     if (oldChild.hasBlendMode() || (oldChild.hasNotIsolatedBlendingDescendants() &amp;&amp; !oldChild.isolatesBlending()))
 480         dirtyAncestorChainHasBlendingDescendants();
 481 #endif
 482 }
 483 
 484 void RenderLayer::dirtyPaintOrderListsOnChildChange(RenderLayer&amp; child)
 485 {
 486     if (child.isNormalFlowOnly())
 487         dirtyNormalFlowList();
 488 
 489     if (!child.isNormalFlowOnly() || child.firstChild()) {
 490         // Dirty the z-order list in which we are contained. The stackingContext() can be null in the
 491         // case where we&#39;re building up generated content layers. This is ok, since the lists will start
 492         // off dirty in that case anyway.
 493         child.dirtyStackingContextZOrderLists();
 494     }
 495 }
 496 
 497 void RenderLayer::insertOnlyThisLayer()
 498 {
 499     if (!m_parent &amp;&amp; renderer().parent()) {
 500         // We need to connect ourselves when our renderer() has a parent.
 501         // Find our enclosingLayer and add ourselves.
 502         RenderLayer* parentLayer = renderer().parent()-&gt;enclosingLayer();
 503         ASSERT(parentLayer);
 504         RenderLayer* beforeChild = parentLayer-&gt;reflectionLayer() != this ? renderer().parent()-&gt;findNextLayer(parentLayer, &amp;renderer()) : nullptr;
 505         parentLayer-&gt;addChild(*this, beforeChild);
 506     }
 507 
 508     // Remove all descendant layers from the hierarchy and add them to the new position.
 509     for (auto&amp; child : childrenOfType&lt;RenderElement&gt;(renderer()))
 510         child.moveLayers(m_parent, this);
 511 
 512     // Clear out all the clip rects.
 513     clearClipRectsIncludingDescendants();
 514 }
 515 
 516 void RenderLayer::removeOnlyThisLayer()
 517 {
 518     if (!m_parent)
 519         return;
 520 
 521     // Mark that we are about to lose our layer. This makes render tree
 522     // walks ignore this layer while we&#39;re removing it.
 523     renderer().setHasLayer(false);
 524 
 525     compositor().layerWillBeRemoved(*m_parent, *this);
 526 
 527     // Dirty the clip rects.
 528     clearClipRectsIncludingDescendants();
 529 
 530     RenderLayer* nextSib = nextSibling();
 531 
 532     // Remove the child reflection layer before moving other child layers.
 533     // The reflection layer should not be moved to the parent.
 534     if (reflection())
 535         removeChild(*reflectionLayer());
 536 
 537     // Now walk our kids and reattach them to our parent.
 538     RenderLayer* current = m_first;
 539     while (current) {
 540         RenderLayer* next = current-&gt;nextSibling();
 541         removeChild(*current);
 542         m_parent-&gt;addChild(*current, nextSib);
 543         current-&gt;setRepaintStatus(NeedsFullRepaint);
 544         current = next;
 545     }
 546 
 547     // Remove us from the parent.
 548     m_parent-&gt;removeChild(*this);
 549     renderer().destroyLayer();
 550 }
 551 
 552 static bool canCreateStackingContext(const RenderLayer&amp; layer)
 553 {
 554     auto&amp; renderer = layer.renderer();
 555     return renderer.hasTransformRelatedProperty()
 556         || renderer.hasClipPath()
 557         || renderer.hasFilter()
 558         || renderer.hasMask()
 559         || renderer.hasBackdropFilter()
 560 #if ENABLE(CSS_COMPOSITING)
 561         || renderer.hasBlendMode()
 562 #endif
 563         || renderer.isTransparent()
 564         || renderer.isPositioned() // Note that this only creates stacking context in conjunction with explicit z-index.
 565         || renderer.hasReflection()
 566         || renderer.style().hasIsolation()
 567         || !renderer.style().hasAutoZIndex()
 568         || (renderer.style().willChange() &amp;&amp; renderer.style().willChange()-&gt;canCreateStackingContext());
 569 }
 570 
 571 bool RenderLayer::shouldBeNormalFlowOnly() const
 572 {
 573     if (canCreateStackingContext(*this))
 574         return false;
 575 
 576     return renderer().hasOverflowClip()
 577         || renderer().isCanvas()
 578         || renderer().isVideo()
 579         || renderer().isEmbeddedObject()
 580         || renderer().isRenderIFrame()
 581         || (renderer().isRenderImage() &amp;&amp; downcast&lt;RenderImage&gt;(renderer()).isEditableImage())
 582         || (renderer().style().specifiesColumns() &amp;&amp; !isRenderViewLayer())
 583         || renderer().isInFlowRenderFragmentedFlow();
 584 }
 585 
<a name="8" id="anc8"></a><span class="line-modified"> 586 bool RenderLayer::shouldBeCSSStackingContext() const</span>
 587 {
<a name="9" id="anc9"></a><span class="line-modified"> 588     return !renderer().style().hasAutoZIndex() || isRenderViewLayer();</span>
 589 }
 590 
 591 bool RenderLayer::setIsNormalFlowOnly(bool isNormalFlowOnly)
 592 {
 593     if (isNormalFlowOnly == m_isNormalFlowOnly)
 594         return false;
 595 
 596     m_isNormalFlowOnly = isNormalFlowOnly;
 597 
 598     if (auto* p = parent())
 599         p-&gt;dirtyNormalFlowList();
 600     dirtyStackingContextZOrderLists();
 601     return true;
 602 }
 603 
<a name="10" id="anc10"></a><span class="line-modified"> 604 void RenderLayer::isStackingContextChanged()</span>
 605 {
<a name="11" id="anc11"></a>




 606     dirtyStackingContextZOrderLists();
<a name="12" id="anc12"></a><span class="line-modified"> 607     if (isStackingContext())</span>
 608         dirtyZOrderLists();
 609     else
 610         clearZOrderLists();
<a name="13" id="anc13"></a><span class="line-added"> 611 }</span>
 612 
<a name="14" id="anc14"></a><span class="line-added"> 613 bool RenderLayer::setIsOpportunisticStackingContext(bool isStacking)</span>
<span class="line-added"> 614 {</span>
<span class="line-added"> 615     bool wasStacking = isStackingContext();</span>
<span class="line-added"> 616     m_isOpportunisticStackingContext = isStacking;</span>
<span class="line-added"> 617     if (wasStacking == isStackingContext())</span>
<span class="line-added"> 618         return false;</span>
<span class="line-added"> 619 </span>
<span class="line-added"> 620     isStackingContextChanged();</span>
<span class="line-added"> 621     return true;</span>
<span class="line-added"> 622 }</span>
<span class="line-added"> 623 </span>
<span class="line-added"> 624 bool RenderLayer::setIsCSSStackingContext(bool isCSSStackingContext)</span>
<span class="line-added"> 625 {</span>
<span class="line-added"> 626     bool wasStacking = isStackingContext();</span>
<span class="line-added"> 627     m_isCSSStackingContext = isCSSStackingContext;</span>
<span class="line-added"> 628     if (wasStacking == isStackingContext())</span>
<span class="line-added"> 629         return false;</span>
<span class="line-added"> 630 </span>
<span class="line-added"> 631     isStackingContextChanged();</span>
 632     return true;
 633 }
 634 
 635 void RenderLayer::setParent(RenderLayer* parent)
 636 {
 637     if (parent == m_parent)
 638         return;
 639 
 640     if (m_parent &amp;&amp; !renderer().renderTreeBeingDestroyed())
 641         compositor().layerWillBeRemoved(*m_parent, *this);
 642 
 643     m_parent = parent;
 644 
 645     if (m_parent &amp;&amp; !renderer().renderTreeBeingDestroyed())
 646         compositor().layerWasAdded(*m_parent, *this);
 647 }
 648 
 649 RenderLayer* RenderLayer::stackingContext() const
 650 {
 651     auto* layer = parent();
 652     while (layer &amp;&amp; !layer-&gt;isStackingContext())
 653         layer = layer-&gt;parent();
 654 
 655     ASSERT(!layer || layer-&gt;isStackingContext());
 656     return layer;
 657 }
 658 
 659 void RenderLayer::dirtyZOrderLists()
 660 {
 661     ASSERT(layerListMutationAllowed());
 662     ASSERT(isStackingContext());
 663 
 664     if (m_posZOrderList)
 665         m_posZOrderList-&gt;clear();
 666     if (m_negZOrderList)
 667         m_negZOrderList-&gt;clear();
 668     m_zOrderListsDirty = true;
 669 
 670     // FIXME: Ideally, we&#39;d only dirty if the lists changed.
 671     if (hasCompositingDescendant())
 672         setNeedsCompositingPaintOrderChildrenUpdate();
 673 }
 674 
 675 void RenderLayer::dirtyStackingContextZOrderLists()
 676 {
 677     if (auto* sc = stackingContext())
 678         sc-&gt;dirtyZOrderLists();
 679 }
 680 
 681 void RenderLayer::dirtyNormalFlowList()
 682 {
 683     ASSERT(layerListMutationAllowed());
 684 
 685     if (m_normalFlowList)
 686         m_normalFlowList-&gt;clear();
 687     m_normalFlowListDirty = true;
 688 
 689     if (hasCompositingDescendant())
 690         setNeedsCompositingPaintOrderChildrenUpdate();
 691 }
 692 
 693 void RenderLayer::updateNormalFlowList()
 694 {
 695     if (!m_normalFlowListDirty)
 696         return;
 697 
 698     ASSERT(layerListMutationAllowed());
 699 
 700     for (RenderLayer* child = firstChild(); child; child = child-&gt;nextSibling()) {
 701         // Ignore non-overflow layers and reflections.
 702         if (child-&gt;isNormalFlowOnly() &amp;&amp; !isReflectionLayer(*child)) {
 703             if (!m_normalFlowList)
<a name="15" id="anc15"></a><span class="line-modified"> 704                 m_normalFlowList = makeUnique&lt;Vector&lt;RenderLayer*&gt;&gt;();</span>
 705             m_normalFlowList-&gt;append(child);
 706         }
 707     }
 708 
 709     m_normalFlowListDirty = false;
 710 }
 711 
 712 void RenderLayer::rebuildZOrderLists()
 713 {
 714     ASSERT(layerListMutationAllowed());
 715     ASSERT(isDirtyStackingContext());
 716     rebuildZOrderLists(m_posZOrderList, m_negZOrderList);
 717     m_zOrderListsDirty = false;
 718 
 719     bool hasNegativeZOrderList = m_negZOrderList &amp;&amp; m_negZOrderList-&gt;size();
 720     // Having negative z-order lists affect whether a compositing layer needs a foreground layer.
 721     // Ideally we&#39;d only trigger this when having z-order children changes, but we blow away the old z-order
 722     // lists on dirtying so we don&#39;t know the old state.
 723     if (hasNegativeZOrderList != m_hadNegativeZOrderList) {
 724         m_hadNegativeZOrderList = hasNegativeZOrderList;
 725         if (isComposited())
 726             setNeedsCompositingConfigurationUpdate();
 727     }
 728 }
 729 
 730 void RenderLayer::rebuildZOrderLists(std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt;&amp; posZOrderList, std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt;&amp; negZOrderList)
 731 {
 732     bool includeHiddenLayers = compositor().usesCompositing();
 733     for (RenderLayer* child = firstChild(); child; child = child-&gt;nextSibling()) {
 734         if (!isReflectionLayer(*child))
 735             child-&gt;collectLayers(includeHiddenLayers, posZOrderList, negZOrderList);
 736     }
 737 
 738     auto compareZIndex = [] (const RenderLayer* first, const RenderLayer* second) -&gt; bool {
 739         return first-&gt;zIndex() &lt; second-&gt;zIndex();
 740     };
 741 
 742     // Sort the two lists.
 743     if (posZOrderList)
 744         std::stable_sort(posZOrderList-&gt;begin(), posZOrderList-&gt;end(), compareZIndex);
 745 
 746     if (negZOrderList)
 747         std::stable_sort(negZOrderList-&gt;begin(), negZOrderList-&gt;end(), compareZIndex);
 748 }
 749 
 750 void RenderLayer::collectLayers(bool includeHiddenLayers, std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt;&amp; positiveZOrderList, std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt;&amp; negativeZOrderList)
 751 {
 752     updateDescendantDependentFlags();
 753 
 754     bool isStacking = isStackingContext();
 755     // Overflow layers are just painted by their enclosing layers, so they don&#39;t get put in zorder lists.
 756     bool includeHiddenLayer = includeHiddenLayers || (m_hasVisibleContent || (m_hasVisibleDescendant &amp;&amp; isStacking));
 757     if (includeHiddenLayer &amp;&amp; !isNormalFlowOnly()) {
 758         auto&amp; layerList = (zIndex() &gt;= 0) ? positiveZOrderList : negativeZOrderList;
 759         if (!layerList)
<a name="16" id="anc16"></a><span class="line-modified"> 760             layerList = makeUnique&lt;Vector&lt;RenderLayer*&gt;&gt;();</span>
 761         layerList-&gt;append(this);
 762     }
 763 
 764     // Recur into our children to collect more layers, but only if we don&#39;t establish
 765     // a stacking context/container.
 766     if ((includeHiddenLayers || m_hasVisibleDescendant) &amp;&amp; !isStacking) {
 767         for (RenderLayer* child = firstChild(); child; child = child-&gt;nextSibling()) {
 768             // Ignore reflections.
 769             if (!isReflectionLayer(*child))
 770                 child-&gt;collectLayers(includeHiddenLayers, positiveZOrderList, negativeZOrderList);
 771         }
 772     }
 773 }
 774 
 775 void RenderLayer::setAncestorsHaveCompositingDirtyFlag(Compositing flag)
 776 {
 777     for (auto* layer = paintOrderParent(); layer; layer = layer-&gt;paintOrderParent()) {
 778         if (layer-&gt;m_compositingDirtyBits.contains(flag))
 779             break;
 780         layer-&gt;m_compositingDirtyBits.add(flag);
 781     }
 782 }
 783 
 784 void RenderLayer::updateLayerListsIfNeeded()
 785 {
 786     updateZOrderLists();
 787     updateNormalFlowList();
 788 
 789     if (RenderLayer* reflectionLayer = this-&gt;reflectionLayer()) {
 790         reflectionLayer-&gt;updateZOrderLists();
 791         reflectionLayer-&gt;updateNormalFlowList();
 792     }
 793 }
 794 
 795 String RenderLayer::name() const
 796 {
 797     StringBuilder name;
 798 
 799     if (Element* element = renderer().element()) {
 800         name.append(&quot; &lt;&quot;);
 801         name.append(element-&gt;tagName().convertToLowercaseWithoutLocale());
 802         name.append(&#39;&gt;&#39;);
 803 
 804         if (element-&gt;hasID()) {
 805             name.appendLiteral(&quot; id=\&#39;&quot;);
 806             name.append(element-&gt;getIdAttribute());
 807             name.append(&#39;\&#39;&#39;);
 808         }
 809 
 810         if (element-&gt;hasClass()) {
 811             name.appendLiteral(&quot; class=\&#39;&quot;);
 812             size_t classNamesToDump = element-&gt;classNames().size();
 813             const size_t maxNumClassNames = 7;
 814             bool addEllipsis = false;
 815             if (classNamesToDump &gt; maxNumClassNames) {
 816                 classNamesToDump = maxNumClassNames;
 817                 addEllipsis = true;
 818             }
 819 
 820             for (size_t i = 0; i &lt; classNamesToDump; ++i) {
 821                 if (i &gt; 0)
 822                     name.append(&#39; &#39;);
 823                 name.append(element-&gt;classNames()[i]);
 824             }
 825             if (addEllipsis)
 826                 name.append(&quot;...&quot;);
 827             name.append(&#39;\&#39;&#39;);
 828         }
 829     } else
 830         name.append(renderer().renderName());
 831 
 832     if (isReflection())
 833         name.appendLiteral(&quot; (reflection)&quot;);
 834 
 835     return name.toString();
 836 }
 837 
 838 RenderLayerCompositor&amp; RenderLayer::compositor() const
 839 {
 840     return renderer().view().compositor();
 841 }
 842 
 843 void RenderLayer::contentChanged(ContentChangeType changeType)
 844 {
 845     if (changeType == CanvasChanged || changeType == VideoChanged || changeType == FullScreenChanged || (isComposited() &amp;&amp; changeType == ImageChanged)) {
 846         setNeedsPostLayoutCompositingUpdate();
 847         setNeedsCompositingConfigurationUpdate();
 848     }
 849 
 850     if (auto* backing = this-&gt;backing())
 851         backing-&gt;contentChanged(changeType);
 852 }
 853 
 854 bool RenderLayer::canRender3DTransforms() const
 855 {
 856     return compositor().canRender3DTransforms();
 857 }
 858 
 859 bool RenderLayer::paintsWithFilters() const
 860 {
 861     if (!renderer().hasFilter())
 862         return false;
 863 
 864     if (!isComposited())
 865         return true;
 866 
 867     return !m_backing-&gt;canCompositeFilters();
 868 }
 869 
 870 bool RenderLayer::requiresFullLayerImageForFilters() const
 871 {
 872     if (!paintsWithFilters())
 873         return false;
 874 
 875     return m_filters &amp;&amp; m_filters-&gt;hasFilterThatMovesPixels();
 876 }
 877 
<a name="17" id="anc17"></a><span class="line-modified"> 878 OptionSet&lt;RenderLayer::UpdateLayerPositionsFlag&gt; RenderLayer::flagsForUpdateLayerPositions(RenderLayer&amp; startingLayer)</span>
<span class="line-added"> 879 {</span>
<span class="line-added"> 880     OptionSet&lt;UpdateLayerPositionsFlag&gt; flags = { CheckForRepaint };</span>
<span class="line-added"> 881 </span>
<span class="line-added"> 882     if (auto* parent = startingLayer.parent()) {</span>
<span class="line-added"> 883         if (parent-&gt;hasTransformedAncestor() || parent-&gt;transform())</span>
<span class="line-added"> 884             flags.add(SeenTransformedLayer);</span>
<span class="line-added"> 885 </span>
<span class="line-added"> 886         if (parent-&gt;has3DTransformedAncestor() || (parent-&gt;transform() &amp;&amp; !parent-&gt;transform()-&gt;isAffine()))</span>
<span class="line-added"> 887             flags.add(Seen3DTransformedLayer);</span>
<span class="line-added"> 888 </span>
<span class="line-added"> 889         if (parent-&gt;behavesAsFixed() || (parent-&gt;renderer().isFixedPositioned() &amp;&amp; !parent-&gt;hasTransformedAncestor()))</span>
<span class="line-added"> 890             flags.add(SeenFixedLayer);</span>
<span class="line-added"> 891 </span>
<span class="line-added"> 892         if (parent-&gt;hasCompositedScrollingAncestor() || parent-&gt;hasCompositedScrollableOverflow())</span>
<span class="line-added"> 893             flags.add(SeenCompositedScrollingLayer);</span>
<span class="line-added"> 894     }</span>
<span class="line-added"> 895 </span>
<span class="line-added"> 896     return flags;</span>
<span class="line-added"> 897 }</span>
<span class="line-added"> 898 </span>
<span class="line-added"> 899 void RenderLayer::updateLayerPositionsAfterStyleChange()</span>
 900 {
<a name="18" id="anc18"></a><span class="line-added"> 901     updateLayerPositions(nullptr, flagsForUpdateLayerPositions(*this));</span>
<span class="line-added"> 902 }</span>
<span class="line-added"> 903 </span>
<span class="line-added"> 904 void RenderLayer::updateLayerPositionsAfterLayout(bool isRelayoutingSubtree, bool didFullRepaint)</span>
<span class="line-added"> 905 {</span>
<span class="line-added"> 906     auto updateLayerPositionFlags = [&amp;](bool isRelayoutingSubtree, bool didFullRepaint) {</span>
<span class="line-added"> 907         auto flags = flagsForUpdateLayerPositions(*this);</span>
<span class="line-added"> 908         if (didFullRepaint) {</span>
<span class="line-added"> 909             flags.remove(RenderLayer::CheckForRepaint);</span>
<span class="line-added"> 910             flags.add(RenderLayer::NeedsFullRepaintInBacking);</span>
<span class="line-added"> 911         }</span>
<span class="line-added"> 912         if (isRelayoutingSubtree &amp;&amp; enclosingPaginationLayer(RenderLayer::IncludeCompositedPaginatedLayers))</span>
<span class="line-added"> 913             flags.add(RenderLayer::UpdatePagination);</span>
<span class="line-added"> 914         return flags;</span>
<span class="line-added"> 915     };</span>
<span class="line-added"> 916 </span>
 917     LOG(Compositing, &quot;RenderLayer %p updateLayerPositionsAfterLayout&quot;, this);
 918     RenderGeometryMap geometryMap(UseTransforms);
<a name="19" id="anc19"></a><span class="line-modified"> 919     if (!isRenderViewLayer())</span>
 920         geometryMap.pushMappingsToAncestor(parent(), nullptr);
<a name="20" id="anc20"></a><span class="line-modified"> 921 </span>
<span class="line-added"> 922     updateLayerPositions(&amp;geometryMap, updateLayerPositionFlags(isRelayoutingSubtree, didFullRepaint));</span>
 923 }
 924 
 925 void RenderLayer::updateLayerPositions(RenderGeometryMap* geometryMap, OptionSet&lt;UpdateLayerPositionsFlag&gt; flags)
 926 {
<a name="21" id="anc21"></a><span class="line-modified"> 927     updateLayerPosition(&amp;flags);</span>



 928     applyPostLayoutScrollPositionIfNeeded();
 929 
 930     if (geometryMap)
 931         geometryMap-&gt;pushMappingsToAncestor(this, parent());
 932 
 933     // Clear our cached clip rect information.
 934     clearClipRects();
 935 
 936     if (hasOverflowControls()) {
 937         LayoutSize offsetFromRoot;
 938         if (geometryMap)
 939             offsetFromRoot = LayoutSize(toFloatSize(geometryMap-&gt;absolutePoint(FloatPoint())));
 940         else {
 941             // FIXME: It looks suspicious to call convertToLayerCoords here
<a name="22" id="anc22"></a><span class="line-modified"> 942             // as canUseOffsetFromAncestor may be true for an ancestor layer.</span>
 943             offsetFromRoot = offsetFromAncestor(root());
 944         }
 945         positionOverflowControls(roundedIntSize(offsetFromRoot));
 946     }
 947 
 948     updateDescendantDependentFlags();
 949 
 950     if (flags &amp; UpdatePagination)
 951         updatePagination();
 952     else
 953         m_enclosingPaginationLayer = nullptr;
 954 
 955     if (m_hasVisibleContent) {
 956         // FIXME: Paint offset cache does not work with RenderLayers as there is not a 1-to-1
 957         // mapping between them and the RenderObjects. It would be neat to enable
 958         // LayoutState outside the layout() phase and use it here.
 959         ASSERT(!renderer().view().frameView().layoutContext().isPaintOffsetCacheEnabled());
 960 
 961         RenderLayerModelObject* repaintContainer = renderer().containerForRepaint();
 962 
 963         auto hadRepaintLayoutRects = renderer().hasRepaintLayoutRects();
 964         RepaintLayoutRects oldRects = hadRepaintLayoutRects ? renderer().repaintLayoutRects() : RepaintLayoutRects();
 965         computeRepaintRects(repaintContainer, geometryMap);
 966 
 967         auto hasRepaintLayoutRects = renderer().hasRepaintLayoutRects();
 968         RepaintLayoutRects newRects = hasRepaintLayoutRects ? renderer().repaintLayoutRects() : RepaintLayoutRects();
 969         // FIXME: Should ASSERT that value calculated for m_outlineBox using the cached offset is the same
 970         // as the value not using the cached offset, but we can&#39;t due to https://bugs.webkit.org/show_bug.cgi?id=37048
 971         if ((flags &amp; CheckForRepaint) &amp;&amp; hasRepaintLayoutRects) {
 972             if (!renderer().view().printing()) {
 973                 if (m_repaintStatus &amp; NeedsFullRepaint) {
 974                     if (hadRepaintLayoutRects)
 975                         renderer().repaintUsingContainer(repaintContainer, oldRects.m_repaintRect);
 976                     if (!hadRepaintLayoutRects || newRects.m_repaintRect != oldRects.m_repaintRect)
 977                         renderer().repaintUsingContainer(repaintContainer, newRects.m_repaintRect);
 978                 } else if (shouldRepaintAfterLayout()) {
 979                     // FIXME: We will convert this to just take the old and new RepaintLayoutRects once
 980                     // we change other callers to use RepaintLayoutRects.
 981                     renderer().repaintAfterLayoutIfNeeded(repaintContainer, oldRects.m_repaintRect, oldRects.m_outlineBox, &amp;newRects.m_repaintRect, &amp;newRects.m_outlineBox);
 982                 }
 983             }
 984         }
 985     } else
 986         clearRepaintRects();
 987 
 988     m_repaintStatus = NeedsNormalRepaint;
 989     m_hasTransformedAncestor = flags.contains(SeenTransformedLayer);
 990     m_has3DTransformedAncestor = flags.contains(Seen3DTransformedLayer);
<a name="23" id="anc23"></a><span class="line-added"> 991     m_behavesAsFixed = flags.contains(SeenFixedLayer);</span>
<span class="line-added"> 992     setHasCompositedScrollingAncestor(flags.contains(SeenCompositedScrollingLayer));</span>
 993 
 994     // Update the reflection&#39;s position and size.
 995     if (m_reflection)
 996         m_reflection-&gt;layout();
 997 
 998     if (renderer().isInFlowRenderFragmentedFlow()) {
 999         updatePagination();
1000         flags.add(UpdatePagination);
1001     }
1002 
1003     if (transform()) {
1004         flags.add(SeenTransformedLayer);
1005         if (!transform()-&gt;isAffine())
1006             flags.add(Seen3DTransformedLayer);
1007     }
1008 
<a name="24" id="anc24"></a><span class="line-added">1009     // Fixed inside transform behaves like absolute (per spec).</span>
<span class="line-added">1010     if (renderer().isFixedPositioned() &amp;&amp; !m_hasTransformedAncestor) {</span>
<span class="line-added">1011         m_behavesAsFixed = true;</span>
<span class="line-added">1012         flags.add(SeenFixedLayer);</span>
<span class="line-added">1013     }</span>
<span class="line-added">1014 </span>
<span class="line-added">1015     if (hasCompositedScrollableOverflow())</span>
<span class="line-added">1016         flags.add(SeenCompositedScrollingLayer);</span>
<span class="line-added">1017 </span>
1018     for (RenderLayer* child = firstChild(); child; child = child-&gt;nextSibling())
1019         child-&gt;updateLayerPositions(geometryMap, flags);
1020 
1021     // With all our children positioned, now update our marquee if we need to.
1022     if (m_marquee) {
1023         // FIXME: would like to use SetForScope&lt;&gt; but it doesn&#39;t work with bitfields.
1024         bool oldUpdatingMarqueePosition = m_updatingMarqueePosition;
1025         m_updatingMarqueePosition = true;
1026         m_marquee-&gt;updateMarqueePosition();
1027         m_updatingMarqueePosition = oldUpdatingMarqueePosition;
1028     }
1029 
<a name="25" id="anc25"></a><span class="line-modified">1030     if (renderer().isFixedPositioned() &amp;&amp; renderer().settings().acceleratedCompositingForFixedPositionEnabled()) {</span>
1031         bool intersectsViewport = compositor().fixedLayerIntersectsViewport(*this);
1032         if (intersectsViewport != m_isFixedIntersectingViewport) {
1033             m_isFixedIntersectingViewport = intersectsViewport;
1034             setNeedsPostLayoutCompositingUpdate();
1035         }
1036     }
1037 
1038     if (isComposited())
<a name="26" id="anc26"></a><span class="line-modified">1039         backing()-&gt;updateAfterLayout(flags.contains(ContainingClippingLayerChangedSize), flags.contains(NeedsFullRepaintInBacking));</span>
1040 
1041     if (geometryMap)
1042         geometryMap-&gt;popMappingsToAncestor(parent());
1043 
1044     renderer().document().markers().invalidateRectsForAllMarkers();
1045 }
1046 
1047 LayoutRect RenderLayer::repaintRectIncludingNonCompositingDescendants() const
1048 {
1049     LayoutRect repaintRect = renderer().repaintLayoutRects().m_repaintRect;
1050     for (RenderLayer* child = firstChild(); child; child = child-&gt;nextSibling()) {
1051         // Don&#39;t include repaint rects for composited child layers; they will paint themselves and have a different origin.
1052         if (child-&gt;isComposited())
1053             continue;
1054 
1055         repaintRect.uniteIfNonZero(child-&gt;repaintRectIncludingNonCompositingDescendants());
1056     }
1057     return repaintRect;
1058 }
1059 
1060 void RenderLayer::setAncestorChainHasSelfPaintingLayerDescendant()
1061 {
1062     for (RenderLayer* layer = this; layer; layer = layer-&gt;parent()) {
1063         if (!layer-&gt;m_hasSelfPaintingLayerDescendantDirty &amp;&amp; layer-&gt;hasSelfPaintingLayerDescendant())
1064             break;
1065 
1066         layer-&gt;m_hasSelfPaintingLayerDescendantDirty = false;
1067         layer-&gt;m_hasSelfPaintingLayerDescendant = true;
1068     }
1069 }
1070 
1071 void RenderLayer::dirtyAncestorChainHasSelfPaintingLayerDescendantStatus()
1072 {
1073     for (RenderLayer* layer = this; layer; layer = layer-&gt;parent()) {
1074         layer-&gt;m_hasSelfPaintingLayerDescendantDirty = true;
1075         // If we have reached a self-painting layer, we know our parent should have a self-painting descendant
1076         // in this case, there is no need to dirty our ancestors further.
1077         if (layer-&gt;isSelfPaintingLayer()) {
1078             ASSERT(!parent() || parent()-&gt;m_hasSelfPaintingLayerDescendantDirty || parent()-&gt;hasSelfPaintingLayerDescendant());
1079             break;
1080         }
1081     }
1082 }
1083 
1084 void RenderLayer::computeRepaintRects(const RenderLayerModelObject* repaintContainer, const RenderGeometryMap* geometryMap)
1085 {
1086     ASSERT(!m_visibleContentStatusDirty);
1087     renderer().computeRepaintLayoutRects(repaintContainer, geometryMap);
1088 }
1089 
1090 void RenderLayer::computeRepaintRectsIncludingDescendants()
1091 {
1092     // FIXME: computeRepaintRects() has to walk up the parent chain for every layer to compute the rects.
1093     // We should make this more efficient.
1094     // FIXME: it&#39;s wrong to call this when layout is not up-to-date, which we do.
1095     computeRepaintRects(renderer().containerForRepaint());
1096 
1097     for (RenderLayer* layer = firstChild(); layer; layer = layer-&gt;nextSibling())
1098         layer-&gt;computeRepaintRectsIncludingDescendants();
1099 }
1100 
1101 void RenderLayer::clearRepaintRects()
1102 {
1103     ASSERT(!m_visibleContentStatusDirty);
1104 
1105     renderer().clearRepaintLayoutRects();
1106 }
1107 
1108 void RenderLayer::updateLayerPositionsAfterDocumentScroll()
1109 {
1110     ASSERT(this == renderer().view().layer());
1111 
1112     LOG(Scrolling, &quot;RenderLayer::updateLayerPositionsAfterDocumentScroll&quot;);
1113 
1114     RenderGeometryMap geometryMap(UseTransforms);
1115     updateLayerPositionsAfterScroll(&amp;geometryMap);
1116 }
1117 
1118 void RenderLayer::updateLayerPositionsAfterOverflowScroll()
1119 {
1120     RenderGeometryMap geometryMap(UseTransforms);
1121     if (this != renderer().view().layer())
1122         geometryMap.pushMappingsToAncestor(parent(), nullptr);
1123 
1124     // FIXME: why is it OK to not check the ancestors of this layer in order to
1125     // initialize the HasSeenViewportConstrainedAncestor and HasSeenAncestorWithOverflowClip flags?
1126     updateLayerPositionsAfterScroll(&amp;geometryMap, IsOverflowScroll);
1127 }
1128 
1129 void RenderLayer::updateLayerPositionsAfterScroll(RenderGeometryMap* geometryMap, OptionSet&lt;UpdateLayerPositionsAfterScrollFlag&gt; flags)
1130 {
1131     // FIXME: This shouldn&#39;t be needed, but there are some corner cases where
1132     // these flags are still dirty. Update so that the check below is valid.
1133     updateDescendantDependentFlags();
1134 
1135     // If we have no visible content and no visible descendants, there is no point recomputing
1136     // our rectangles as they will be empty. If our visibility changes, we are expected to
1137     // recompute all our positions anyway.
1138     if (!m_hasVisibleDescendant &amp;&amp; !m_hasVisibleContent)
1139         return;
1140 
1141     bool positionChanged = updateLayerPosition();
1142     if (positionChanged)
1143         flags.add(HasChangedAncestor);
1144 
1145     if (flags.containsAny({ HasChangedAncestor, HasSeenViewportConstrainedAncestor, IsOverflowScroll }))
1146         clearClipRects();
1147 
1148     if (renderer().style().hasViewportConstrainedPosition())
1149         flags.add(HasSeenViewportConstrainedAncestor);
1150 
1151     if (renderer().hasOverflowClip())
1152         flags.add(HasSeenAncestorWithOverflowClip);
1153 
1154     bool shouldComputeRepaintRects = (flags.contains(HasSeenViewportConstrainedAncestor) || flags.containsAll({ IsOverflowScroll, HasSeenAncestorWithOverflowClip })) &amp;&amp; isSelfPaintingLayer();
1155     bool isVisuallyEmpty = !isVisuallyNonEmpty();
1156     bool shouldPushAndPopMappings = geometryMap &amp;&amp; ((shouldComputeRepaintRects &amp;&amp; !isVisuallyEmpty) || firstChild());
1157     if (shouldPushAndPopMappings)
1158         geometryMap-&gt;pushMappingsToAncestor(this, parent());
1159 
1160     if (shouldComputeRepaintRects) {
1161         // When scrolling, we don&#39;t compute repaint rects for visually non-empty layers.
1162         if (isVisuallyEmpty)
1163             clearRepaintRects();
1164         else // FIXME: We could track the repaint container as we walk down the tree.
1165             computeRepaintRects(renderer().containerForRepaint(), geometryMap);
1166     } else if (!renderer().view().frameView().platformWidget()) {
1167         // When ScrollView&#39;s m_paintsEntireContents flag flips due to layer backing changes, the repaint area transitions from
1168         // visual to layout overflow. When this happens the cached repaint rects become invalid and they need to be recomputed (see webkit.org/b/188121).
1169         // Check that our cached rects are correct.
1170         ASSERT(!renderer().hasRepaintLayoutRects() || renderer().repaintLayoutRects().m_repaintRect == renderer().clippedOverflowRectForRepaint(renderer().containerForRepaint()));
1171         ASSERT(!renderer().hasRepaintLayoutRects() || renderer().repaintLayoutRects().m_outlineBox == renderer().outlineBoundsForRepaint(renderer().containerForRepaint()));
1172     }
1173 
1174     for (RenderLayer* child = firstChild(); child; child = child-&gt;nextSibling())
1175         child-&gt;updateLayerPositionsAfterScroll(geometryMap, flags);
1176 
1177     // We don&#39;t update our reflection as scrolling is a translation which does not change the size()
1178     // of an object, thus RenderReplica will still repaint itself properly as the layer position was
1179     // updated above.
1180 
1181     if (m_marquee) {
1182         bool oldUpdatingMarqueePosition = m_updatingMarqueePosition;
1183         m_updatingMarqueePosition = true;
1184         m_marquee-&gt;updateMarqueePosition();
1185         m_updatingMarqueePosition = oldUpdatingMarqueePosition;
1186     }
1187 
1188     if (shouldPushAndPopMappings)
1189         geometryMap-&gt;popMappingsToAncestor(parent());
1190 
1191     renderer().document().markers().invalidateRectsForAllMarkers();
1192 }
1193 
1194 #if ENABLE(CSS_COMPOSITING)
1195 
1196 void RenderLayer::updateBlendMode()
1197 {
1198     bool hadBlendMode = static_cast&lt;BlendMode&gt;(m_blendMode) != BlendMode::Normal;
1199     if (parent() &amp;&amp; hadBlendMode != hasBlendMode()) {
1200         if (hasBlendMode())
1201             parent()-&gt;updateAncestorChainHasBlendingDescendants();
1202         else
1203             parent()-&gt;dirtyAncestorChainHasBlendingDescendants();
1204     }
1205 
1206     BlendMode newBlendMode = renderer().style().blendMode();
1207     if (newBlendMode != static_cast&lt;BlendMode&gt;(m_blendMode))
1208         m_blendMode = static_cast&lt;unsigned&gt;(newBlendMode);
1209 }
1210 
<a name="27" id="anc27"></a><span class="line-added">1211 void RenderLayer::willRemoveChildWithBlendMode()</span>
<span class="line-added">1212 {</span>
<span class="line-added">1213     parent()-&gt;dirtyAncestorChainHasBlendingDescendants();</span>
<span class="line-added">1214 }</span>
<span class="line-added">1215 </span>
1216 void RenderLayer::updateAncestorChainHasBlendingDescendants()
1217 {
1218     for (auto* layer = this; layer; layer = layer-&gt;parent()) {
1219         if (!layer-&gt;hasNotIsolatedBlendingDescendantsStatusDirty() &amp;&amp; layer-&gt;hasNotIsolatedBlendingDescendants())
1220             break;
1221         layer-&gt;m_hasNotIsolatedBlendingDescendants = true;
1222         layer-&gt;m_hasNotIsolatedBlendingDescendantsStatusDirty = false;
1223 
1224         layer-&gt;updateSelfPaintingLayer();
1225 
<a name="28" id="anc28"></a><span class="line-modified">1226         if (layer-&gt;isCSSStackingContext())</span>
1227             break;
1228     }
1229 }
1230 
1231 void RenderLayer::dirtyAncestorChainHasBlendingDescendants()
1232 {
1233     for (auto* layer = this; layer; layer = layer-&gt;parent()) {
1234         if (layer-&gt;hasNotIsolatedBlendingDescendantsStatusDirty())
1235             break;
1236 
1237         layer-&gt;m_hasNotIsolatedBlendingDescendantsStatusDirty = true;
1238 
<a name="29" id="anc29"></a><span class="line-modified">1239         if (layer-&gt;isCSSStackingContext())</span>
1240             break;
1241     }
1242 }
1243 #endif
1244 
1245 void RenderLayer::updateTransform()
1246 {
1247     bool hasTransform = renderer().hasTransform();
1248     bool had3DTransform = has3DTransform();
1249 
1250     bool hadTransform = !!m_transform;
1251     if (hasTransform != hadTransform) {
1252         if (hasTransform)
<a name="30" id="anc30"></a><span class="line-modified">1253             m_transform = makeUnique&lt;TransformationMatrix&gt;();</span>
1254         else
1255             m_transform = nullptr;
1256 
1257         // Layers with transforms act as clip rects roots, so clear the cached clip rects here.
1258         clearClipRectsIncludingDescendants();
1259     }
1260 
1261     if (hasTransform) {
1262         RenderBox* box = renderBox();
1263         ASSERT(box);
1264         m_transform-&gt;makeIdentity();
1265         box-&gt;style().applyTransform(*m_transform, snapRectToDevicePixels(box-&gt;borderBoxRect(), box-&gt;document().deviceScaleFactor()), RenderStyle::IncludeTransformOrigin);
1266         makeMatrixRenderable(*m_transform, canRender3DTransforms());
1267     }
1268 
1269     if (had3DTransform != has3DTransform()) {
1270         dirty3DTransformedDescendantStatus();
1271         // Having a 3D transform affects whether enclosing perspective and preserve-3d layers composite, so trigger an update.
1272         setNeedsPostLayoutCompositingUpdateOnAncestors();
1273     }
1274 }
1275 
1276 TransformationMatrix RenderLayer::currentTransform(RenderStyle::ApplyTransformOrigin applyOrigin) const
1277 {
1278     if (!m_transform)
1279         return TransformationMatrix();
1280 
1281     RenderBox* box = renderBox();
1282 
1283     if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled()) {
1284         if (auto* timeline = renderer().documentTimeline()) {
1285             if (timeline-&gt;isRunningAcceleratedAnimationOnRenderer(renderer(), CSSPropertyTransform)) {
1286                 TransformationMatrix currTransform;
1287                 FloatRect pixelSnappedBorderRect = snapRectToDevicePixels(box-&gt;borderBoxRect(), box-&gt;document().deviceScaleFactor());
1288                 std::unique_ptr&lt;RenderStyle&gt; style = timeline-&gt;animatedStyleForRenderer(renderer());
1289                 style-&gt;applyTransform(currTransform, pixelSnappedBorderRect, applyOrigin);
1290                 makeMatrixRenderable(currTransform, canRender3DTransforms());
1291                 return currTransform;
1292             }
1293         }
1294     } else {
1295         if (renderer().animation().isRunningAcceleratedAnimationOnRenderer(renderer(), CSSPropertyTransform)) {
1296             TransformationMatrix currTransform;
1297             FloatRect pixelSnappedBorderRect = snapRectToDevicePixels(box-&gt;borderBoxRect(), box-&gt;document().deviceScaleFactor());
1298             std::unique_ptr&lt;RenderStyle&gt; style = renderer().animation().animatedStyleForRenderer(renderer());
1299             style-&gt;applyTransform(currTransform, pixelSnappedBorderRect, applyOrigin);
1300             makeMatrixRenderable(currTransform, canRender3DTransforms());
1301             return currTransform;
1302         }
1303     }
1304 
1305 
1306     // m_transform includes transform-origin, so we need to recompute the transform here.
1307     if (applyOrigin == RenderStyle::ExcludeTransformOrigin) {
1308         TransformationMatrix currTransform;
1309         FloatRect pixelSnappedBorderRect = snapRectToDevicePixels(box-&gt;borderBoxRect(), box-&gt;document().deviceScaleFactor());
1310         box-&gt;style().applyTransform(currTransform, pixelSnappedBorderRect, RenderStyle::ExcludeTransformOrigin);
1311         makeMatrixRenderable(currTransform, canRender3DTransforms());
1312         return currTransform;
1313     }
1314 
1315     return *m_transform;
1316 }
1317 
1318 TransformationMatrix RenderLayer::renderableTransform(OptionSet&lt;PaintBehavior&gt; paintBehavior) const
1319 {
1320     if (!m_transform)
1321         return TransformationMatrix();
1322 
1323     if (paintBehavior &amp; PaintBehavior::FlattenCompositingLayers) {
1324         TransformationMatrix matrix = *m_transform;
1325         makeMatrixRenderable(matrix, false /* flatten 3d */);
1326         return matrix;
1327     }
1328 
1329     return *m_transform;
1330 }
1331 
1332 RenderLayer* RenderLayer::enclosingOverflowClipLayer(IncludeSelfOrNot includeSelf) const
1333 {
1334     const RenderLayer* layer = (includeSelf == IncludeSelf) ? this : parent();
1335     while (layer) {
1336         if (layer-&gt;renderer().hasOverflowClip())
1337             return const_cast&lt;RenderLayer*&gt;(layer);
1338 
1339         layer = layer-&gt;parent();
1340     }
1341     return nullptr;
1342 }
1343 
1344 // FIXME: This is terrible. Bring back a cached bit for this someday. This crawl is going to slow down all
1345 // painting of content inside paginated layers.
1346 bool RenderLayer::hasCompositedLayerInEnclosingPaginationChain() const
1347 {
1348     // No enclosing layer means no compositing in the chain.
1349     if (!m_enclosingPaginationLayer)
1350         return false;
1351 
1352     // If the enclosing layer is composited, we don&#39;t have to check anything in between us and that
1353     // layer.
1354     if (m_enclosingPaginationLayer-&gt;isComposited())
1355         return true;
1356 
1357     // If we are the enclosing pagination layer, then we can&#39;t be composited or we&#39;d have passed the
1358     // previous check.
1359     if (m_enclosingPaginationLayer == this)
1360         return false;
1361 
1362     // The enclosing paginated layer is our ancestor and is not composited, so we have to check
1363     // intermediate layers between us and the enclosing pagination layer. Start with our own layer.
1364     if (isComposited())
1365         return true;
1366 
1367     // For normal flow layers, we can recur up the layer tree.
1368     if (isNormalFlowOnly())
1369         return parent()-&gt;hasCompositedLayerInEnclosingPaginationChain();
1370 
1371     // Otherwise we have to go up the containing block chain. Find the first enclosing
1372     // containing block layer ancestor, and check that.
1373     for (const auto* containingBlock = renderer().containingBlock(); containingBlock &amp;&amp; !is&lt;RenderView&gt;(*containingBlock); containingBlock = containingBlock-&gt;containingBlock()) {
1374         if (containingBlock-&gt;hasLayer())
1375             return containingBlock-&gt;layer()-&gt;hasCompositedLayerInEnclosingPaginationChain();
1376     }
1377     return false;
1378 }
1379 
1380 void RenderLayer::updatePagination()
1381 {
1382     m_enclosingPaginationLayer = nullptr;
1383 
1384     if (!parent())
1385         return;
1386 
1387     // Each layer that is inside a multicolumn flow thread has to be checked individually and
1388     // genuinely know if it is going to have to split itself up when painting only its contents (and not any other descendant
1389     // layers). We track an enclosingPaginationLayer instead of using a simple bit, since we want to be able to get back
1390     // to that layer easily.
1391     if (renderer().isInFlowRenderFragmentedFlow()) {
1392         m_enclosingPaginationLayer = makeWeakPtr(*this);
1393         return;
1394     }
1395 
1396     if (isNormalFlowOnly()) {
1397         // Content inside a transform is not considered to be paginated, since we simply
1398         // paint the transform multiple times in each column, so we don&#39;t have to use
1399         // fragments for the transformed content.
1400         if (parent()-&gt;hasTransform())
1401             m_enclosingPaginationLayer = nullptr;
1402         else
1403             m_enclosingPaginationLayer = makeWeakPtr(parent()-&gt;enclosingPaginationLayer(IncludeCompositedPaginatedLayers));
1404         return;
1405     }
1406 
1407     // For the new columns code, we want to walk up our containing block chain looking for an enclosing layer. Once
1408     // we find one, then we just check its pagination status.
1409     for (const auto* containingBlock = renderer().containingBlock(); containingBlock &amp;&amp; !is&lt;RenderView&gt;(*containingBlock); containingBlock = containingBlock-&gt;containingBlock()) {
1410         if (containingBlock-&gt;hasLayer()) {
1411             // Content inside a transform is not considered to be paginated, since we simply
1412             // paint the transform multiple times in each column, so we don&#39;t have to use
1413             // fragments for the transformed content.
1414             if (containingBlock-&gt;layer()-&gt;hasTransform())
1415                 m_enclosingPaginationLayer = nullptr;
1416             else
1417                 m_enclosingPaginationLayer = makeWeakPtr(containingBlock-&gt;layer()-&gt;enclosingPaginationLayer(IncludeCompositedPaginatedLayers));
1418             return;
1419         }
1420     }
1421 }
1422 
1423 void RenderLayer::setHasVisibleContent()
1424 {
1425     if (m_hasVisibleContent &amp;&amp; !m_visibleContentStatusDirty) {
1426         ASSERT(!parent() || parent()-&gt;hasVisibleDescendant());
1427         return;
1428     }
1429 
1430     m_visibleContentStatusDirty = false;
1431     m_hasVisibleContent = true;
1432     computeRepaintRects(renderer().containerForRepaint());
1433     if (!isNormalFlowOnly()) {
1434         // We don&#39;t collect invisible layers in z-order lists if we are not in compositing mode.
1435         // As we became visible, we need to dirty our stacking containers ancestors to be properly
1436         // collected. FIXME: When compositing, we could skip this dirtying phase.
1437         for (RenderLayer* sc = stackingContext(); sc; sc = sc-&gt;stackingContext()) {
1438             sc-&gt;dirtyZOrderLists();
1439             if (sc-&gt;hasVisibleContent())
1440                 break;
1441         }
1442     }
1443 
1444     if (parent())
1445         parent()-&gt;setAncestorChainHasVisibleDescendant();
1446 }
1447 
1448 void RenderLayer::dirtyVisibleContentStatus()
1449 {
1450     m_visibleContentStatusDirty = true;
1451     if (parent())
1452         parent()-&gt;dirtyAncestorChainVisibleDescendantStatus();
1453 }
1454 
1455 void RenderLayer::dirtyAncestorChainVisibleDescendantStatus()
1456 {
1457     for (RenderLayer* layer = this; layer; layer = layer-&gt;parent()) {
1458         if (layer-&gt;m_visibleDescendantStatusDirty)
1459             break;
1460 
1461         layer-&gt;m_visibleDescendantStatusDirty = true;
1462     }
1463 }
1464 
1465 void RenderLayer::setAncestorChainHasVisibleDescendant()
1466 {
1467     for (RenderLayer* layer = this; layer; layer = layer-&gt;parent()) {
1468         if (!layer-&gt;m_visibleDescendantStatusDirty &amp;&amp; layer-&gt;hasVisibleDescendant())
1469             break;
1470 
1471         layer-&gt;m_hasVisibleDescendant = true;
1472         layer-&gt;m_visibleDescendantStatusDirty = false;
1473     }
1474 }
1475 
1476 void RenderLayer::updateDescendantDependentFlags()
1477 {
1478     if (m_visibleDescendantStatusDirty || m_hasSelfPaintingLayerDescendantDirty || hasNotIsolatedBlendingDescendantsStatusDirty()) {
1479         bool hasVisibleDescendant = false;
1480         bool hasSelfPaintingLayerDescendant = false;
1481 #if ENABLE(CSS_COMPOSITING)
1482         bool hasNotIsolatedBlendingDescendants = false;
1483 #endif
1484 
1485         for (RenderLayer* child = firstChild(); child; child = child-&gt;nextSibling()) {
1486             child-&gt;updateDescendantDependentFlags();
1487 
1488             hasVisibleDescendant |= child-&gt;m_hasVisibleContent || child-&gt;m_hasVisibleDescendant;
1489             hasSelfPaintingLayerDescendant |= child-&gt;isSelfPaintingLayer() || child-&gt;hasSelfPaintingLayerDescendant();
1490 #if ENABLE(CSS_COMPOSITING)
1491             hasNotIsolatedBlendingDescendants |= child-&gt;hasBlendMode() || (child-&gt;hasNotIsolatedBlendingDescendants() &amp;&amp; !child-&gt;isolatesBlending());
1492 #endif
1493 
1494             bool allFlagsSet = hasVisibleDescendant &amp;&amp; hasSelfPaintingLayerDescendant;
1495 #if ENABLE(CSS_COMPOSITING)
1496             allFlagsSet &amp;= hasNotIsolatedBlendingDescendants;
1497 #endif
1498             if (allFlagsSet)
1499                 break;
1500         }
1501 
1502         m_hasVisibleDescendant = hasVisibleDescendant;
1503         m_visibleDescendantStatusDirty = false;
1504         m_hasSelfPaintingLayerDescendant = hasSelfPaintingLayerDescendant;
1505         m_hasSelfPaintingLayerDescendantDirty = false;
1506 
1507 #if ENABLE(CSS_COMPOSITING)
1508         m_hasNotIsolatedBlendingDescendants = hasNotIsolatedBlendingDescendants;
1509         if (m_hasNotIsolatedBlendingDescendantsStatusDirty) {
1510             m_hasNotIsolatedBlendingDescendantsStatusDirty = false;
1511             updateSelfPaintingLayer();
1512         }
1513 #endif
1514     }
1515 
1516     if (m_visibleContentStatusDirty) {
1517         if (renderer().style().visibility() == Visibility::Visible)
1518             m_hasVisibleContent = true;
1519         else {
1520             // layer may be hidden but still have some visible content, check for this
1521             m_hasVisibleContent = false;
1522             RenderObject* r = renderer().firstChild();
1523             while (r) {
1524                 if (r-&gt;style().visibility() == Visibility::Visible &amp;&amp; !r-&gt;hasLayer()) {
1525                     m_hasVisibleContent = true;
1526                     break;
1527                 }
1528                 RenderObject* child = nullptr;
1529                 if (!r-&gt;hasLayer() &amp;&amp; (child = r-&gt;firstChildSlow()))
1530                     r = child;
1531                 else if (r-&gt;nextSibling())
1532                     r = r-&gt;nextSibling();
1533                 else {
1534                     do {
1535                         r = r-&gt;parent();
1536                         if (r == &amp;renderer())
1537                             r = nullptr;
1538                     } while (r &amp;&amp; !r-&gt;nextSibling());
1539                     if (r)
1540                         r = r-&gt;nextSibling();
1541                 }
1542             }
1543         }
1544         m_visibleContentStatusDirty = false;
1545     }
1546 }
1547 
1548 void RenderLayer::dirty3DTransformedDescendantStatus()
1549 {
1550     RenderLayer* curr = stackingContext();
1551     if (curr)
1552         curr-&gt;m_3DTransformedDescendantStatusDirty = true;
1553 
1554     // This propagates up through preserve-3d hierarchies to the enclosing flattening layer.
1555     // Note that preserves3D() creates stacking context, so we can just run up the stacking containers.
1556     while (curr &amp;&amp; curr-&gt;preserves3D()) {
1557         curr-&gt;m_3DTransformedDescendantStatusDirty = true;
1558         curr = curr-&gt;stackingContext();
1559     }
1560 }
1561 
1562 // Return true if this layer or any preserve-3d descendants have 3d.
1563 bool RenderLayer::update3DTransformedDescendantStatus()
1564 {
1565     if (m_3DTransformedDescendantStatusDirty) {
1566         m_has3DTransformedDescendant = false;
1567 
1568         updateZOrderLists();
1569 
1570         // Transformed or preserve-3d descendants can only be in the z-order lists, not
1571         // in the normal flow list, so we only need to check those.
1572         for (auto* layer : positiveZOrderLayers())
1573             m_has3DTransformedDescendant |= layer-&gt;update3DTransformedDescendantStatus();
1574 
1575         // Now check our negative z-index children.
1576         for (auto* layer : negativeZOrderLayers())
1577             m_has3DTransformedDescendant |= layer-&gt;update3DTransformedDescendantStatus();
1578 
1579         m_3DTransformedDescendantStatusDirty = false;
1580     }
1581 
1582     // If we live in a 3d hierarchy, then the layer at the root of that hierarchy needs
1583     // the m_has3DTransformedDescendant set.
1584     if (preserves3D())
1585         return has3DTransform() || m_has3DTransformedDescendant;
1586 
1587     return has3DTransform();
1588 }
1589 
<a name="31" id="anc31"></a><span class="line-modified">1590 bool RenderLayer::updateLayerPosition(OptionSet&lt;UpdateLayerPositionsFlag&gt;* flags)</span>
1591 {
1592     LayoutPoint localPoint;
1593     LayoutSize inlineBoundingBoxOffset; // We don&#39;t put this into the RenderLayer x/y for inlines, so we need to subtract it out when done.
1594     if (renderer().isInline() &amp;&amp; is&lt;RenderInline&gt;(renderer())) {
1595         auto&amp; inlineFlow = downcast&lt;RenderInline&gt;(renderer());
1596         IntRect lineBox = inlineFlow.linesBoundingBox();
1597         setSize(lineBox.size());
1598         inlineBoundingBoxOffset = toLayoutSize(lineBox.location());
1599         localPoint += inlineBoundingBoxOffset;
1600     } else if (RenderBox* box = renderBox()) {
1601         // FIXME: Is snapping the size really needed here for the RenderBox case?
1602         auto newSize = snappedIntRect(box-&gt;frameRect()).size();
1603         if (newSize != size()) {
1604             if (is&lt;RenderWidget&gt;(*box) &amp;&amp; downcast&lt;RenderWidget&gt;(*box).requiresAcceleratedCompositing()) {
1605                 // Trigger RenderLayerCompositor::requiresCompositingForFrame() which depends on the contentBoxRect size.
1606                 setNeedsPostLayoutCompositingUpdate();
1607             }
<a name="32" id="anc32"></a><span class="line-added">1608 </span>
<span class="line-added">1609             if (flags &amp;&amp; renderer().hasOverflowClip())</span>
<span class="line-added">1610                 flags-&gt;add(ContainingClippingLayerChangedSize);</span>
<span class="line-added">1611 </span>
1612             setSize(newSize);
1613         }
1614 
1615         box-&gt;applyTopLeftLocationOffset(localPoint);
1616     }
1617 
1618     if (!renderer().isOutOfFlowPositioned()) {
1619         auto* ancestor = renderer().parent();
1620         // We must adjust our position by walking up the render tree looking for the
1621         // nearest enclosing object with a layer.
1622         while (ancestor &amp;&amp; !ancestor-&gt;hasLayer()) {
1623             if (is&lt;RenderBox&gt;(*ancestor) &amp;&amp; !is&lt;RenderTableRow&gt;(*ancestor)) {
1624                 // Rows and cells share the same coordinate space (that of the section).
1625                 // Omit them when computing our xpos/ypos.
1626                 localPoint += downcast&lt;RenderBox&gt;(*ancestor).topLeftLocationOffset();
1627             }
1628             ancestor = ancestor-&gt;parent();
1629         }
1630         if (is&lt;RenderTableRow&gt;(ancestor)) {
1631             // Put ourselves into the row coordinate space.
1632             localPoint -= downcast&lt;RenderTableRow&gt;(*ancestor).topLeftLocationOffset();
1633         }
1634     }
1635 
1636     // Subtract our parent&#39;s scroll offset.
1637     RenderLayer* positionedParent;
1638     if (renderer().isOutOfFlowPositioned() &amp;&amp; (positionedParent = enclosingAncestorForPosition(renderer().style().position()))) {
1639         // For positioned layers, we subtract out the enclosing positioned layer&#39;s scroll offset.
1640         if (positionedParent-&gt;renderer().hasOverflowClip())
1641             localPoint -= toLayoutSize(positionedParent-&gt;scrollPosition());
1642 
1643         if (renderer().isOutOfFlowPositioned() &amp;&amp; positionedParent-&gt;renderer().isInFlowPositioned() &amp;&amp; is&lt;RenderInline&gt;(positionedParent-&gt;renderer())) {
1644             LayoutSize offset = downcast&lt;RenderInline&gt;(positionedParent-&gt;renderer()).offsetForInFlowPositionedInline(&amp;downcast&lt;RenderBox&gt;(renderer()));
1645             localPoint += offset;
1646         }
1647     } else if (parent()) {
1648         if (parent()-&gt;renderer().hasOverflowClip())
1649             localPoint -= toLayoutSize(parent()-&gt;scrollPosition());
1650     }
1651 
1652     bool positionOrOffsetChanged = false;
1653     if (renderer().isInFlowPositioned()) {
1654         LayoutSize newOffset = downcast&lt;RenderBoxModelObject&gt;(renderer()).offsetForInFlowPosition();
1655         positionOrOffsetChanged = newOffset != m_offsetForInFlowPosition;
1656         m_offsetForInFlowPosition = newOffset;
1657         localPoint.move(m_offsetForInFlowPosition);
1658     } else {
1659         m_offsetForInFlowPosition = LayoutSize();
1660     }
1661 
1662     // FIXME: We&#39;d really like to just get rid of the concept of a layer rectangle and rely on the renderers.
1663     localPoint -= inlineBoundingBoxOffset;
1664 
1665     positionOrOffsetChanged |= location() != localPoint;
1666     setLocation(localPoint);
1667 
1668     if (positionOrOffsetChanged &amp;&amp; compositor().hasContentCompositingLayers()) {
1669         if (isComposited())
1670             setNeedsCompositingGeometryUpdate();
1671         // This layer&#39;s position can affect the location of a composited descendant (which may be a sibling in z-order),
1672         // so trigger a descendant walk from the paint-order parent.
1673         if (auto* paintParent = paintOrderParent())
1674             paintParent-&gt;setDescendantsNeedUpdateBackingAndHierarchyTraversal();
1675     }
1676 
1677     return positionOrOffsetChanged;
1678 }
1679 
1680 TransformationMatrix RenderLayer::perspectiveTransform() const
1681 {
1682     RenderBox* box = renderBox();
1683     if (!box)
1684         return TransformationMatrix();
1685 
1686     if (!box-&gt;hasTransformRelatedProperty())
1687         return TransformationMatrix();
1688 
1689     const RenderStyle&amp; style = box-&gt;style();
1690     if (!style.hasPerspective())
1691         return TransformationMatrix();
1692 
1693     // Maybe fetch the perspective from the backing?
1694     const FloatRect borderBox = snapRectToDevicePixels(box-&gt;borderBoxRect(), box-&gt;document().deviceScaleFactor());
1695     float perspectiveOriginX = floatValueForLength(style.perspectiveOriginX(), borderBox.width());
1696     float perspectiveOriginY = floatValueForLength(style.perspectiveOriginY(), borderBox.height());
1697 
1698     // A perspective origin of 0,0 makes the vanishing point in the center of the element.
1699     // We want it to be in the top-left, so subtract half the height and width.
1700     perspectiveOriginX -= borderBox.width() / 2.0f;
1701     perspectiveOriginY -= borderBox.height() / 2.0f;
1702 
1703     TransformationMatrix t;
1704     t.translate(perspectiveOriginX, perspectiveOriginY);
1705     t.applyPerspective(style.perspective());
1706     t.translate(-perspectiveOriginX, -perspectiveOriginY);
1707 
1708     return t;
1709 }
1710 
1711 FloatPoint RenderLayer::perspectiveOrigin() const
1712 {
1713     if (!renderer().hasTransformRelatedProperty())
1714         return FloatPoint();
1715 
1716     const LayoutRect borderBox = downcast&lt;RenderBox&gt;(renderer()).borderBoxRect();
1717     const RenderStyle&amp; style = renderer().style();
1718 
1719     return FloatPoint(floatValueForLength(style.perspectiveOriginX(), borderBox.width()),
1720                       floatValueForLength(style.perspectiveOriginY(), borderBox.height()));
1721 }
1722 
1723 static inline bool isContainerForPositioned(RenderLayer&amp; layer, PositionType position)
1724 {
1725     switch (position) {
1726     case PositionType::Fixed:
1727         return layer.renderer().canContainFixedPositionObjects();
1728 
1729     case PositionType::Absolute:
1730         return layer.renderer().canContainAbsolutelyPositionedObjects();
1731 
1732     default:
1733         ASSERT_NOT_REACHED();
1734         return false;
1735     }
1736 }
1737 
<a name="33" id="anc33"></a><span class="line-added">1738 bool RenderLayer::ancestorLayerIsInContainingBlockChain(const RenderLayer&amp; ancestor, const RenderLayer* checkLimit) const</span>
<span class="line-added">1739 {</span>
<span class="line-added">1740     if (&amp;ancestor == this)</span>
<span class="line-added">1741         return true;</span>
<span class="line-added">1742 </span>
<span class="line-added">1743     for (const auto* currentBlock = renderer().containingBlock(); currentBlock &amp;&amp; !is&lt;RenderView&gt;(*currentBlock); currentBlock = currentBlock-&gt;containingBlock()) {</span>
<span class="line-added">1744         auto* currLayer = currentBlock-&gt;layer();</span>
<span class="line-added">1745         if (currLayer == &amp;ancestor)</span>
<span class="line-added">1746             return true;</span>
<span class="line-added">1747 </span>
<span class="line-added">1748         if (currLayer &amp;&amp; currLayer == checkLimit)</span>
<span class="line-added">1749             return false;</span>
<span class="line-added">1750     }</span>
<span class="line-added">1751 </span>
<span class="line-added">1752     return false;</span>
<span class="line-added">1753 }</span>
<span class="line-added">1754 </span>
1755 RenderLayer* RenderLayer::enclosingAncestorForPosition(PositionType position) const
1756 {
1757     RenderLayer* curr = parent();
1758     while (curr &amp;&amp; !isContainerForPositioned(*curr, position))
1759         curr = curr-&gt;parent();
1760 
1761     return curr;
1762 }
1763 
<a name="34" id="anc34"></a><span class="line-modified">1764 static RenderLayer* enclosingFrameRenderLayer(const RenderLayer&amp; layer)</span>
1765 {
<a name="35" id="anc35"></a><span class="line-modified">1766     auto* ownerElement = layer.renderer().document().ownerElement();</span>



1767     if (!ownerElement)
1768         return nullptr;
1769 
<a name="36" id="anc36"></a><span class="line-modified">1770     auto* ownerRenderer = ownerElement-&gt;renderer();</span>
1771     if (!ownerRenderer)
1772         return nullptr;
1773 
1774     return ownerRenderer-&gt;enclosingLayer();
1775 }
1776 
<a name="37" id="anc37"></a><span class="line-added">1777 static RenderLayer* parentLayerCrossFrame(const RenderLayer&amp; layer)</span>
<span class="line-added">1778 {</span>
<span class="line-added">1779     if (auto* parent = layer.parent())</span>
<span class="line-added">1780         return parent;</span>
<span class="line-added">1781 </span>
<span class="line-added">1782     return enclosingFrameRenderLayer(layer);</span>
<span class="line-added">1783 }</span>
<span class="line-added">1784 </span>
1785 RenderLayer* RenderLayer::enclosingScrollableLayer() const
1786 {
1787     for (RenderLayer* nextLayer = parentLayerCrossFrame(*this); nextLayer; nextLayer = parentLayerCrossFrame(*nextLayer)) {
1788         if (is&lt;RenderBox&gt;(nextLayer-&gt;renderer()) &amp;&amp; downcast&lt;RenderBox&gt;(nextLayer-&gt;renderer()).canBeScrolledAndHasScrollableArea())
1789             return nextLayer;
1790     }
1791 
1792     return nullptr;
1793 }
1794 
1795 IntRect RenderLayer::scrollableAreaBoundingBox(bool* isInsideFixed) const
1796 {
1797     return renderer().absoluteBoundingBoxRect(/* useTransforms */ true, isInsideFixed);
1798 }
1799 
1800 bool RenderLayer::isRubberBandInProgress() const
1801 {
1802 #if ENABLE(RUBBER_BANDING)
1803     if (!scrollsOverflow())
1804         return false;
1805 
1806     if (ScrollAnimator* scrollAnimator = existingScrollAnimator())
1807         return scrollAnimator-&gt;isRubberBandInProgress();
1808 #endif
1809 
1810     return false;
1811 }
1812 
1813 bool RenderLayer::forceUpdateScrollbarsOnMainThreadForPerformanceTesting() const
1814 {
1815     return renderer().settings().forceUpdateScrollbarsOnMainThreadForPerformanceTesting();
1816 }
1817 
1818 RenderLayer* RenderLayer::enclosingTransformedAncestor() const
1819 {
1820     RenderLayer* curr = parent();
1821     while (curr &amp;&amp; !curr-&gt;isRenderViewLayer() &amp;&amp; !curr-&gt;transform())
1822         curr = curr-&gt;parent();
1823 
1824     return curr;
1825 }
1826 
1827 inline bool RenderLayer::shouldRepaintAfterLayout() const
1828 {
1829     if (m_repaintStatus == NeedsNormalRepaint)
1830         return true;
1831 
1832     // Composited layers that were moved during a positioned movement only
1833     // layout, don&#39;t need to be repainted. They just need to be recomposited.
1834     ASSERT(m_repaintStatus == NeedsFullRepaintForPositionedMovementLayout);
1835     return !isComposited() || backing()-&gt;paintsIntoCompositedAncestor();
1836 }
1837 
<a name="38" id="anc38"></a><span class="line-added">1838 void RenderLayer::setBackingProviderLayer(RenderLayer* backingProvider)</span>
<span class="line-added">1839 {</span>
<span class="line-added">1840     if (backingProvider == m_backingProviderLayer)</span>
<span class="line-added">1841         return;</span>
<span class="line-added">1842 </span>
<span class="line-added">1843     if (!renderer().renderTreeBeingDestroyed())</span>
<span class="line-added">1844         clearClipRectsIncludingDescendants();</span>
<span class="line-added">1845 </span>
<span class="line-added">1846     m_backingProviderLayer = makeWeakPtr(backingProvider);</span>
<span class="line-added">1847 }</span>
<span class="line-added">1848 </span>
<span class="line-added">1849 void RenderLayer::disconnectFromBackingProviderLayer()</span>
<span class="line-added">1850 {</span>
<span class="line-added">1851     if (!m_backingProviderLayer)</span>
<span class="line-added">1852         return;</span>
<span class="line-added">1853 </span>
<span class="line-added">1854     ASSERT(m_backingProviderLayer-&gt;isComposited());</span>
<span class="line-added">1855     if (m_backingProviderLayer-&gt;isComposited())</span>
<span class="line-added">1856         m_backingProviderLayer-&gt;backing()-&gt;removeBackingSharingLayer(*this);</span>
<span class="line-added">1857 }</span>
<span class="line-added">1858 </span>
1859 bool compositedWithOwnBackingStore(const RenderLayer&amp; layer)
1860 {
1861     return layer.isComposited() &amp;&amp; !layer.backing()-&gt;paintsIntoCompositedAncestor();
1862 }
1863 
1864 RenderLayer* RenderLayer::enclosingCompositingLayer(IncludeSelfOrNot includeSelf) const
1865 {
1866     if (includeSelf == IncludeSelf &amp;&amp; isComposited())
1867         return const_cast&lt;RenderLayer*&gt;(this);
1868 
1869     for (const RenderLayer* curr = paintOrderParent(); curr; curr = curr-&gt;paintOrderParent()) {
1870         if (curr-&gt;isComposited())
1871             return const_cast&lt;RenderLayer*&gt;(curr);
1872     }
1873 
1874     return nullptr;
1875 }
1876 
1877 RenderLayer* RenderLayer::enclosingCompositingLayerForRepaint(IncludeSelfOrNot includeSelf) const
1878 {
<a name="39" id="anc39"></a><span class="line-modified">1879     auto repaintTargetForLayer = [](const RenderLayer&amp; layer) -&gt; RenderLayer* {</span>
<span class="line-modified">1880         if (compositedWithOwnBackingStore(layer))</span>
<span class="line-added">1881             return const_cast&lt;RenderLayer*&gt;(&amp;layer);</span>
<span class="line-added">1882 </span>
<span class="line-added">1883         if (layer.paintsIntoProvidedBacking())</span>
<span class="line-added">1884             return layer.backingProviderLayer();</span>
<span class="line-added">1885 </span>
<span class="line-added">1886         return nullptr;</span>
<span class="line-added">1887     };</span>
<span class="line-added">1888 </span>
<span class="line-added">1889     RenderLayer* repaintTarget = nullptr;</span>
<span class="line-added">1890     if (includeSelf == IncludeSelf &amp;&amp; (repaintTarget = repaintTargetForLayer(*this)))</span>
<span class="line-added">1891         return repaintTarget;</span>
1892 
1893     for (const RenderLayer* curr = paintOrderParent(); curr; curr = curr-&gt;paintOrderParent()) {
<a name="40" id="anc40"></a><span class="line-modified">1894         if ((repaintTarget = repaintTargetForLayer(*curr)))</span>
<span class="line-modified">1895             return repaintTarget;</span>
1896     }
1897 
1898     return nullptr;
1899 }
1900 
1901 RenderLayer* RenderLayer::enclosingFilterLayer(IncludeSelfOrNot includeSelf) const
1902 {
1903     const RenderLayer* curr = (includeSelf == IncludeSelf) ? this : parent();
1904     for (; curr; curr = curr-&gt;parent()) {
1905         if (curr-&gt;requiresFullLayerImageForFilters())
1906             return const_cast&lt;RenderLayer*&gt;(curr);
1907     }
1908 
1909     return nullptr;
1910 }
1911 
1912 RenderLayer* RenderLayer::enclosingFilterRepaintLayer() const
1913 {
1914     for (const RenderLayer* curr = this; curr; curr = curr-&gt;parent()) {
1915         if ((curr != this &amp;&amp; curr-&gt;requiresFullLayerImageForFilters()) || compositedWithOwnBackingStore(*curr) || curr-&gt;isRenderViewLayer())
1916             return const_cast&lt;RenderLayer*&gt;(curr);
1917     }
1918     return nullptr;
1919 }
1920 
1921 // FIXME: This neeeds a better name.
1922 void RenderLayer::setFilterBackendNeedsRepaintingInRect(const LayoutRect&amp; rect)
1923 {
1924     ASSERT(requiresFullLayerImageForFilters());
1925     ASSERT(m_filters);
1926 
1927     if (rect.isEmpty())
1928         return;
1929 
1930     LayoutRect rectForRepaint = rect;
1931     renderer().style().filterOutsets().expandRect(rectForRepaint);
1932 
1933     m_filters-&gt;expandDirtySourceRect(rectForRepaint);
1934 
1935     RenderLayer* parentLayer = enclosingFilterRepaintLayer();
1936     ASSERT(parentLayer);
1937     FloatQuad repaintQuad(rectForRepaint);
1938     LayoutRect parentLayerRect = renderer().localToContainerQuad(repaintQuad, &amp;parentLayer-&gt;renderer()).enclosingBoundingBox();
1939 
1940     if (parentLayer-&gt;isComposited()) {
1941         if (!parentLayer-&gt;backing()-&gt;paintsIntoWindow()) {
1942             parentLayer-&gt;setBackingNeedsRepaintInRect(parentLayerRect);
1943             return;
1944         }
1945         // If the painting goes to window, redirect the painting to the parent RenderView.
1946         parentLayer = renderer().view().layer();
1947         parentLayerRect = renderer().localToContainerQuad(repaintQuad, &amp;parentLayer-&gt;renderer()).enclosingBoundingBox();
1948     }
1949 
1950     if (parentLayer-&gt;paintsWithFilters()) {
1951         parentLayer-&gt;setFilterBackendNeedsRepaintingInRect(parentLayerRect);
1952         return;
1953     }
1954 
1955     if (parentLayer-&gt;isRenderViewLayer()) {
1956         downcast&lt;RenderView&gt;(parentLayer-&gt;renderer()).repaintViewRectangle(parentLayerRect);
1957         return;
1958     }
1959 
1960     ASSERT_NOT_REACHED();
1961 }
1962 
1963 bool RenderLayer::hasAncestorWithFilterOutsets() const
1964 {
1965     for (const RenderLayer* curr = this; curr; curr = curr-&gt;parent()) {
1966         if (curr-&gt;renderer().style().hasFilterOutsets())
1967             return true;
1968     }
1969     return false;
1970 }
1971 
1972 RenderLayer* RenderLayer::clippingRootForPainting() const
1973 {
1974     if (isComposited())
1975         return const_cast&lt;RenderLayer*&gt;(this);
1976 
<a name="41" id="anc41"></a><span class="line-added">1977     if (paintsIntoProvidedBacking())</span>
<span class="line-added">1978         return backingProviderLayer();</span>
<span class="line-added">1979 </span>
1980     const RenderLayer* current = this;
1981     while (current) {
1982         if (current-&gt;isRenderViewLayer())
1983             return const_cast&lt;RenderLayer*&gt;(current);
1984 
1985         current = current-&gt;paintOrderParent();
1986         ASSERT(current);
1987         if (current-&gt;transform() || compositedWithOwnBackingStore(*current))
1988             return const_cast&lt;RenderLayer*&gt;(current);
<a name="42" id="anc42"></a><span class="line-added">1989 </span>
<span class="line-added">1990         if (current-&gt;paintsIntoProvidedBacking())</span>
<span class="line-added">1991             return current-&gt;backingProviderLayer();</span>
1992     }
1993 
1994     ASSERT_NOT_REACHED();
1995     return nullptr;
1996 }
1997 
1998 LayoutPoint RenderLayer::absoluteToContents(const LayoutPoint&amp; absolutePoint) const
1999 {
2000     // We don&#39;t use convertToLayerCoords because it doesn&#39;t know about transforms
2001     return LayoutPoint(renderer().absoluteToLocal(absolutePoint, UseTransforms));
2002 }
2003 
2004 bool RenderLayer::cannotBlitToWindow() const
2005 {
2006     if (isTransparent() || hasReflection() || hasTransform())
2007         return true;
2008     if (!parent())
2009         return false;
2010     return parent()-&gt;cannotBlitToWindow();
2011 }
2012 
2013 RenderLayer* RenderLayer::transparentPaintingAncestor()
2014 {
2015     if (isComposited())
2016         return nullptr;
2017 
2018     for (RenderLayer* curr = parent(); curr; curr = curr-&gt;parent()) {
2019         if (curr-&gt;isComposited())
2020             return nullptr;
2021         if (curr-&gt;isTransparent())
2022             return curr;
2023     }
2024     return nullptr;
2025 }
2026 
2027 enum TransparencyClipBoxBehavior {
2028     PaintingTransparencyClipBox,
2029     HitTestingTransparencyClipBox
2030 };
2031 
2032 enum TransparencyClipBoxMode {
2033     DescendantsOfTransparencyClipBox,
2034     RootOfTransparencyClipBox
2035 };
2036 
2037 static LayoutRect transparencyClipBox(const RenderLayer&amp;, const RenderLayer* rootLayer, TransparencyClipBoxBehavior, TransparencyClipBoxMode, OptionSet&lt;PaintBehavior&gt; = { });
2038 
2039 static void expandClipRectForDescendantsAndReflection(LayoutRect&amp; clipRect, const RenderLayer&amp; layer, const RenderLayer* rootLayer,
2040     TransparencyClipBoxBehavior transparencyBehavior, OptionSet&lt;PaintBehavior&gt; paintBehavior)
2041 {
2042     // If we have a mask, then the clip is limited to the border box area (and there is
2043     // no need to examine child layers).
2044     if (!layer.renderer().hasMask()) {
2045         // Note: we don&#39;t have to walk z-order lists since transparent elements always establish
2046         // a stacking container. This means we can just walk the layer tree directly.
2047         for (RenderLayer* curr = layer.firstChild(); curr; curr = curr-&gt;nextSibling()) {
2048             if (!layer.isReflectionLayer(*curr))
2049                 clipRect.unite(transparencyClipBox(*curr, rootLayer, transparencyBehavior, DescendantsOfTransparencyClipBox, paintBehavior));
2050         }
2051     }
2052 
2053     // If we have a reflection, then we need to account for that when we push the clip.  Reflect our entire
2054     // current transparencyClipBox to catch all child layers.
2055     // FIXME: Accelerated compositing will eventually want to do something smart here to avoid incorporating this
2056     // size into the parent layer.
2057     if (layer.renderer().hasReflection()) {
2058         LayoutSize delta = layer.offsetFromAncestor(rootLayer);
2059         clipRect.move(-delta);
2060         clipRect.unite(layer.renderBox()-&gt;reflectedRect(clipRect));
2061         clipRect.move(delta);
2062     }
2063 }
2064 
2065 static LayoutRect transparencyClipBox(const RenderLayer&amp; layer, const RenderLayer* rootLayer, TransparencyClipBoxBehavior transparencyBehavior,
2066     TransparencyClipBoxMode transparencyMode, OptionSet&lt;PaintBehavior&gt; paintBehavior)
2067 {
2068     // FIXME: Although this function completely ignores CSS-imposed clipping, we did already intersect with the
2069     // paintDirtyRect, and that should cut down on the amount we have to paint.  Still it
2070     // would be better to respect clips.
2071 
2072     if (rootLayer != &amp;layer &amp;&amp; ((transparencyBehavior == PaintingTransparencyClipBox &amp;&amp; layer.paintsWithTransform(paintBehavior))
2073         || (transparencyBehavior == HitTestingTransparencyClipBox &amp;&amp; layer.hasTransform()))) {
2074         // The best we can do here is to use enclosed bounding boxes to establish a &quot;fuzzy&quot; enough clip to encompass
2075         // the transformed layer and all of its children.
2076         RenderLayer::PaginationInclusionMode mode = transparencyBehavior == HitTestingTransparencyClipBox ? RenderLayer::IncludeCompositedPaginatedLayers : RenderLayer::ExcludeCompositedPaginatedLayers;
2077         const RenderLayer* paginationLayer = transparencyMode == DescendantsOfTransparencyClipBox ? layer.enclosingPaginationLayer(mode) : nullptr;
2078         const RenderLayer* rootLayerForTransform = paginationLayer ? paginationLayer : rootLayer;
2079         LayoutSize delta = layer.offsetFromAncestor(rootLayerForTransform);
2080 
2081         TransformationMatrix transform;
2082         transform.translate(delta.width(), delta.height());
2083         transform.multiply(*layer.transform());
2084 
2085         // We don&#39;t use fragment boxes when collecting a transformed layer&#39;s bounding box, since it always
2086         // paints unfragmented.
2087         LayoutRect clipRect = layer.boundingBox(&amp;layer);
2088         expandClipRectForDescendantsAndReflection(clipRect, layer, &amp;layer, transparencyBehavior, paintBehavior);
2089         layer.renderer().style().filterOutsets().expandRect(clipRect);
2090         LayoutRect result = transform.mapRect(clipRect);
2091         if (!paginationLayer)
2092             return result;
2093 
2094         // We have to break up the transformed extent across our columns.
2095         // Split our box up into the actual fragment boxes that render in the columns/pages and unite those together to
2096         // get our true bounding box.
2097         auto&amp; enclosingFragmentedFlow = downcast&lt;RenderFragmentedFlow&gt;(paginationLayer-&gt;renderer());
2098         result = enclosingFragmentedFlow.fragmentsBoundingBox(result);
2099         result.move(paginationLayer-&gt;offsetFromAncestor(rootLayer));
2100         return result;
2101     }
2102 
2103     LayoutRect clipRect = layer.boundingBox(rootLayer, layer.offsetFromAncestor(rootLayer), transparencyBehavior == HitTestingTransparencyClipBox ? RenderLayer::UseFragmentBoxesIncludingCompositing : RenderLayer::UseFragmentBoxesExcludingCompositing);
2104     expandClipRectForDescendantsAndReflection(clipRect, layer, rootLayer, transparencyBehavior, paintBehavior);
2105     layer.renderer().style().filterOutsets().expandRect(clipRect);
2106 
2107     return clipRect;
2108 }
2109 
2110 static LayoutRect paintingExtent(const RenderLayer&amp; currentLayer, const RenderLayer* rootLayer, const LayoutRect&amp; paintDirtyRect, OptionSet&lt;PaintBehavior&gt; paintBehavior)
2111 {
2112     return intersection(transparencyClipBox(currentLayer, rootLayer, PaintingTransparencyClipBox, RootOfTransparencyClipBox, paintBehavior), paintDirtyRect);
2113 }
2114 
2115 void RenderLayer::beginTransparencyLayers(GraphicsContext&amp; context, const LayerPaintingInfo&amp; paintingInfo, const LayoutRect&amp; dirtyRect)
2116 {
2117     if (context.paintingDisabled() || (paintsWithTransparency(paintingInfo.paintBehavior) &amp;&amp; m_usedTransparency))
2118         return;
2119 
2120     RenderLayer* ancestor = transparentPaintingAncestor();
2121     if (ancestor)
2122         ancestor-&gt;beginTransparencyLayers(context, paintingInfo, dirtyRect);
2123 
2124     if (paintsWithTransparency(paintingInfo.paintBehavior)) {
<a name="43" id="anc43"></a><span class="line-modified">2125         ASSERT(isCSSStackingContext());</span>
2126         m_usedTransparency = true;
2127         context.save();
2128         LayoutRect adjustedClipRect = paintingExtent(*this, paintingInfo.rootLayer, dirtyRect, paintingInfo.paintBehavior);
2129         adjustedClipRect.move(paintingInfo.subpixelOffset);
2130         FloatRect pixelSnappedClipRect = snapRectToDevicePixels(adjustedClipRect, renderer().document().deviceScaleFactor());
2131         context.clip(pixelSnappedClipRect);
2132 
2133 #if ENABLE(CSS_COMPOSITING)
2134         bool usesCompositeOperation = hasBlendMode() &amp;&amp; !(renderer().isSVGRoot() &amp;&amp; parent() &amp;&amp; parent()-&gt;isRenderViewLayer());
2135         if (usesCompositeOperation)
2136             context.setCompositeOperation(context.compositeOperation(), blendMode());
2137 #endif
2138 
2139         context.beginTransparencyLayer(renderer().opacity());
2140 
2141 #if ENABLE(CSS_COMPOSITING)
2142         if (usesCompositeOperation)
2143             context.setCompositeOperation(context.compositeOperation(), BlendMode::Normal);
2144 #endif
2145 
2146 #ifdef REVEAL_TRANSPARENCY_LAYERS
2147         context.setFillColor(Color(0.0f, 0.0f, 0.5f, 0.2f));
2148         context.fillRect(pixelSnappedClipRect);
2149 #endif
2150     }
2151 }
2152 
2153 #if PLATFORM(IOS_FAMILY)
2154 void RenderLayer::willBeDestroyed()
2155 {
2156     if (RenderLayerBacking* layerBacking = backing())
2157         layerBacking-&gt;layerWillBeDestroyed();
2158 }
2159 #endif
2160 
2161 bool RenderLayer::isDescendantOf(const RenderLayer&amp; layer) const
2162 {
2163     for (auto* ancestor = this; ancestor; ancestor = ancestor-&gt;parent()) {
2164         if (&amp;layer == ancestor)
2165             return true;
2166     }
2167     return false;
2168 }
2169 
2170 void RenderLayer::convertToPixelSnappedLayerCoords(const RenderLayer* ancestorLayer, IntPoint&amp; roundedLocation, ColumnOffsetAdjustment adjustForColumns) const
2171 {
2172     LayoutPoint location = convertToLayerCoords(ancestorLayer, roundedLocation, adjustForColumns);
2173     roundedLocation = roundedIntPoint(location);
2174 }
2175 
2176 // Returns the layer reached on the walk up towards the ancestor.
2177 static inline const RenderLayer* accumulateOffsetTowardsAncestor(const RenderLayer* layer, const RenderLayer* ancestorLayer, LayoutPoint&amp; location, RenderLayer::ColumnOffsetAdjustment adjustForColumns)
2178 {
2179     ASSERT(ancestorLayer != layer);
2180 
2181     const RenderLayerModelObject&amp; renderer = layer-&gt;renderer();
2182     auto position = renderer.style().position();
2183 
2184     // FIXME: Special casing RenderFragmentedFlow so much for fixed positioning here is not great.
2185     RenderFragmentedFlow* fixedFragmentedFlowContainer = position == PositionType::Fixed ? renderer.enclosingFragmentedFlow() : nullptr;
2186     if (fixedFragmentedFlowContainer &amp;&amp; !fixedFragmentedFlowContainer-&gt;isOutOfFlowPositioned())
2187         fixedFragmentedFlowContainer = nullptr;
2188 
2189     // FIXME: Positioning of out-of-flow(fixed, absolute) elements collected in a RenderFragmentedFlow
2190     // may need to be revisited in a future patch.
2191     // If the fixed renderer is inside a RenderFragmentedFlow, we should not compute location using localToAbsolute,
2192     // since localToAbsolute maps the coordinates from named flow to regions coordinates and regions can be
2193     // positioned in a completely different place in the viewport (RenderView).
2194     if (position == PositionType::Fixed &amp;&amp; !fixedFragmentedFlowContainer &amp;&amp; (!ancestorLayer || ancestorLayer == renderer.view().layer())) {
2195         // If the fixed layer&#39;s container is the root, just add in the offset of the view. We can obtain this by calling
2196         // localToAbsolute() on the RenderView.
2197         FloatPoint absPos = renderer.localToAbsolute(FloatPoint(), IsFixed);
2198         location += LayoutSize(absPos.x(), absPos.y());
2199         return ancestorLayer;
2200     }
2201 
2202     // For the fixed positioned elements inside a render flow thread, we should also skip the code path below
2203     // Otherwise, for the case of ancestorLayer == rootLayer and fixed positioned element child of a transformed
2204     // element in render flow thread, we will hit the fixed positioned container before hitting the ancestor layer.
2205     if (position == PositionType::Fixed &amp;&amp; !fixedFragmentedFlowContainer) {
2206         // For a fixed layers, we need to walk up to the root to see if there&#39;s a fixed position container
2207         // (e.g. a transformed layer). It&#39;s an error to call offsetFromAncestor() across a layer with a transform,
2208         // so we should always find the ancestor at or before we find the fixed position container.
2209         RenderLayer* fixedPositionContainerLayer = nullptr;
2210         bool foundAncestor = false;
2211         for (RenderLayer* currLayer = layer-&gt;parent(); currLayer; currLayer = currLayer-&gt;parent()) {
2212             if (currLayer == ancestorLayer)
2213                 foundAncestor = true;
2214 
2215             if (isContainerForPositioned(*currLayer, PositionType::Fixed)) {
2216                 fixedPositionContainerLayer = currLayer;
2217                 ASSERT_UNUSED(foundAncestor, foundAncestor);
2218                 break;
2219             }
2220         }
2221 
2222         ASSERT(fixedPositionContainerLayer); // We should have hit the RenderView&#39;s layer at least.
2223 
2224         if (fixedPositionContainerLayer != ancestorLayer) {
2225             LayoutSize fixedContainerCoords = layer-&gt;offsetFromAncestor(fixedPositionContainerLayer);
2226             LayoutSize ancestorCoords = ancestorLayer-&gt;offsetFromAncestor(fixedPositionContainerLayer);
2227             location += (fixedContainerCoords - ancestorCoords);
2228             return ancestorLayer;
2229         }
2230     }
2231 
2232     if (position == PositionType::Fixed &amp;&amp; fixedFragmentedFlowContainer) {
2233         ASSERT(ancestorLayer);
2234         if (ancestorLayer-&gt;isOutOfFlowRenderFragmentedFlow()) {
2235             location += toLayoutSize(layer-&gt;location());
2236             return ancestorLayer;
2237         }
2238 
2239         if (ancestorLayer == renderer.view().layer()) {
2240             // Add location in flow thread coordinates.
2241             location += toLayoutSize(layer-&gt;location());
2242 
2243             // Add flow thread offset in view coordinates since the view may be scrolled.
2244             FloatPoint absPos = renderer.view().localToAbsolute(FloatPoint(), IsFixed);
2245             location += LayoutSize(absPos.x(), absPos.y());
2246             return ancestorLayer;
2247         }
2248     }
2249 
2250     RenderLayer* parentLayer;
2251     if (position == PositionType::Absolute || position == PositionType::Fixed) {
2252         // Do what enclosingAncestorForPosition() does, but check for ancestorLayer along the way.
2253         parentLayer = layer-&gt;parent();
2254         bool foundAncestorFirst = false;
2255         while (parentLayer) {
2256             // RenderFragmentedFlow is a positioned container, child of RenderView, positioned at (0,0).
2257             // This implies that, for out-of-flow positioned elements inside a RenderFragmentedFlow,
2258             // we are bailing out before reaching root layer.
2259             if (isContainerForPositioned(*parentLayer, position))
2260                 break;
2261 
2262             if (parentLayer == ancestorLayer) {
2263                 foundAncestorFirst = true;
2264                 break;
2265             }
2266 
2267             parentLayer = parentLayer-&gt;parent();
2268         }
2269 
2270         // We should not reach RenderView layer past the RenderFragmentedFlow layer for any
2271         // children of the RenderFragmentedFlow.
2272         if (renderer.enclosingFragmentedFlow() &amp;&amp; !layer-&gt;isOutOfFlowRenderFragmentedFlow())
2273             ASSERT(parentLayer != renderer.view().layer());
2274 
2275         if (foundAncestorFirst) {
2276             // Found ancestorLayer before the abs. positioned container, so compute offset of both relative
2277             // to enclosingAncestorForPosition and subtract.
2278             RenderLayer* positionedAncestor = parentLayer-&gt;enclosingAncestorForPosition(position);
2279             LayoutSize thisCoords = layer-&gt;offsetFromAncestor(positionedAncestor);
2280             LayoutSize ancestorCoords = ancestorLayer-&gt;offsetFromAncestor(positionedAncestor);
2281             location += (thisCoords - ancestorCoords);
2282             return ancestorLayer;
2283         }
2284     } else
2285         parentLayer = layer-&gt;parent();
2286 
2287     if (!parentLayer)
2288         return nullptr;
2289 
2290     location += toLayoutSize(layer-&gt;location());
2291 
2292     if (adjustForColumns == RenderLayer::AdjustForColumns) {
2293         if (RenderLayer* parentLayer = layer-&gt;parent()) {
2294             if (is&lt;RenderMultiColumnFlow&gt;(parentLayer-&gt;renderer())) {
2295                 RenderFragmentContainer* fragment = downcast&lt;RenderMultiColumnFlow&gt;(parentLayer-&gt;renderer()).physicalTranslationFromFlowToFragment(location);
2296                 if (fragment)
2297                     location.moveBy(fragment-&gt;topLeftLocation() + -parentLayer-&gt;renderBox()-&gt;topLeftLocation());
2298             }
2299         }
2300     }
2301 
2302     return parentLayer;
2303 }
2304 
2305 LayoutPoint RenderLayer::convertToLayerCoords(const RenderLayer* ancestorLayer, const LayoutPoint&amp; location, ColumnOffsetAdjustment adjustForColumns) const
2306 {
2307     if (ancestorLayer == this)
2308         return location;
2309 
2310     const RenderLayer* currLayer = this;
2311     LayoutPoint locationInLayerCoords = location;
2312     while (currLayer &amp;&amp; currLayer != ancestorLayer)
2313         currLayer = accumulateOffsetTowardsAncestor(currLayer, ancestorLayer, locationInLayerCoords, adjustForColumns);
2314     return locationInLayerCoords;
2315 }
2316 
2317 LayoutSize RenderLayer::offsetFromAncestor(const RenderLayer* ancestorLayer, ColumnOffsetAdjustment adjustForColumns) const
2318 {
2319     return toLayoutSize(convertToLayerCoords(ancestorLayer, LayoutPoint(), adjustForColumns));
2320 }
2321 
2322 bool RenderLayer::canUseCompositedScrolling() const
2323 {
<a name="44" id="anc44"></a><span class="line-added">2324     bool isVisible = renderer().style().visibility() == Visibility::Visible;</span>
2325     if (renderer().settings().asyncOverflowScrollingEnabled())
<a name="45" id="anc45"></a><span class="line-modified">2326         return isVisible &amp;&amp; scrollsOverflow();</span>
2327 
<a name="46" id="anc46"></a><span class="line-modified">2328 #if PLATFORM(IOS_FAMILY) &amp;&amp; ENABLE(OVERFLOW_SCROLLING_TOUCH)</span>
<span class="line-modified">2329     return isVisible &amp;&amp; scrollsOverflow() &amp;&amp; (renderer().style().useTouchOverflowScrolling() || renderer().settings().alwaysUseAcceleratedOverflowScroll());</span>
2330 #else
2331     return false;
2332 #endif
2333 }
2334 
<a name="47" id="anc47"></a>




2335 #if ENABLE(IOS_TOUCH_EVENTS)
2336 bool RenderLayer::handleTouchEvent(const PlatformTouchEvent&amp; touchEvent)
2337 {
2338     // If we have accelerated scrolling, let the scrolling be handled outside of WebKit.
2339     if (hasCompositedScrollableOverflow())
2340         return false;
2341 
2342     return ScrollableArea::handleTouchEvent(touchEvent);
2343 }
2344 
2345 void RenderLayer::registerAsTouchEventListenerForScrolling()
2346 {
2347     if (!renderer().element() || m_registeredAsTouchEventListenerForScrolling)
2348         return;
2349 
2350     renderer().document().addTouchEventHandler(*renderer().element());
2351     m_registeredAsTouchEventListenerForScrolling = true;
2352 }
2353 
2354 void RenderLayer::unregisterAsTouchEventListenerForScrolling()
2355 {
2356     if (!renderer().element() || !m_registeredAsTouchEventListenerForScrolling)
2357         return;
2358 
2359     renderer().document().removeTouchEventHandler(*renderer().element());
2360     m_registeredAsTouchEventListenerForScrolling = false;
2361 }
2362 #endif // ENABLE(IOS_TOUCH_EVENTS)
2363 
2364 // FIXME: this is only valid after we&#39;ve made layers.
2365 bool RenderLayer::usesCompositedScrolling() const
2366 {
2367     return isComposited() &amp;&amp; backing()-&gt;hasScrollingLayer();
2368 }
2369 
2370 // FIXME: this is only valid after we&#39;ve made layers.
2371 bool RenderLayer::usesAsyncScrolling() const
2372 {
2373     return compositor().useCoordinatedScrollingForLayer(*this);
2374 }
2375 
2376 static inline int adjustedScrollDelta(int beginningDelta)
2377 {
2378     // This implemention matches Firefox&#39;s.
2379     // http://mxr.mozilla.org/firefox/source/toolkit/content/widgets/browser.xml#856.
2380     const int speedReducer = 12;
2381 
2382     int adjustedDelta = beginningDelta / speedReducer;
2383     if (adjustedDelta &gt; 1)
2384         adjustedDelta = static_cast&lt;int&gt;(adjustedDelta * sqrt(static_cast&lt;double&gt;(adjustedDelta))) - 1;
2385     else if (adjustedDelta &lt; -1)
2386         adjustedDelta = static_cast&lt;int&gt;(adjustedDelta * sqrt(static_cast&lt;double&gt;(-adjustedDelta))) + 1;
2387 
2388     return adjustedDelta;
2389 }
2390 
2391 static inline IntSize adjustedScrollDelta(const IntSize&amp; delta)
2392 {
2393     return IntSize(adjustedScrollDelta(delta.width()), adjustedScrollDelta(delta.height()));
2394 }
2395 
2396 void RenderLayer::panScrollFromPoint(const IntPoint&amp; sourcePoint)
2397 {
2398     IntPoint lastKnownMousePosition = renderer().frame().eventHandler().lastKnownMousePosition();
2399 
2400     // We need to check if the last known mouse position is out of the window. When the mouse is out of the window, the position is incoherent
2401     static IntPoint previousMousePosition;
2402     if (lastKnownMousePosition.x() &lt; 0 || lastKnownMousePosition.y() &lt; 0)
2403         lastKnownMousePosition = previousMousePosition;
2404     else
2405         previousMousePosition = lastKnownMousePosition;
2406 
2407     IntSize delta = lastKnownMousePosition - sourcePoint;
2408 
2409     if (abs(delta.width()) &lt;= ScrollView::noPanScrollRadius) // at the center we let the space for the icon
2410         delta.setWidth(0);
2411     if (abs(delta.height()) &lt;= ScrollView::noPanScrollRadius)
2412         delta.setHeight(0);
2413 
2414     scrollByRecursively(adjustedScrollDelta(delta));
2415 }
2416 
2417 // FIXME: unify with the scrollRectToVisible() code below.
2418 void RenderLayer::scrollByRecursively(const IntSize&amp; delta, ScrollableArea** scrolledArea)
2419 {
2420     if (delta.isZero())
2421         return;
2422 
2423     bool restrictedByLineClamp = false;
2424     if (renderer().parent())
2425         restrictedByLineClamp = !renderer().parent()-&gt;style().lineClamp().isNone();
2426 
2427     if (renderer().hasOverflowClip() &amp;&amp; !restrictedByLineClamp) {
2428         ScrollOffset newScrollOffset = scrollOffset() + delta;
2429         scrollToOffset(newScrollOffset);
2430         if (scrolledArea)
2431             *scrolledArea = this;
2432 
2433         // If this layer can&#39;t do the scroll we ask the next layer up that can scroll to try
2434         IntSize remainingScrollOffset = newScrollOffset - scrollOffset();
2435         if (!remainingScrollOffset.isZero() &amp;&amp; renderer().parent()) {
2436             if (RenderLayer* scrollableLayer = enclosingScrollableLayer())
2437                 scrollableLayer-&gt;scrollByRecursively(remainingScrollOffset, scrolledArea);
2438 
2439             renderer().frame().eventHandler().updateAutoscrollRenderer();
2440         }
2441     } else {
2442         // If we are here, we were called on a renderer that can be programmatically scrolled, but doesn&#39;t
2443         // have an overflow clip. Which means that it is a document node that can be scrolled.
2444         renderer().view().frameView().scrollBy(delta);
2445         if (scrolledArea)
2446             *scrolledArea = &amp;renderer().view().frameView();
2447 
2448         // FIXME: If we didn&#39;t scroll the whole way, do we want to try looking at the frames ownerElement?
2449         // https://bugs.webkit.org/show_bug.cgi?id=28237
2450     }
2451 }
2452 
2453 void RenderLayer::setPostLayoutScrollPosition(Optional&lt;ScrollPosition&gt; position)
2454 {
2455     m_postLayoutScrollPosition = position;
2456 }
2457 
2458 void RenderLayer::applyPostLayoutScrollPositionIfNeeded()
2459 {
2460     if (!m_postLayoutScrollPosition)
2461         return;
2462 
2463     scrollToOffset(scrollOffsetFromPosition(m_postLayoutScrollPosition.value()));
2464     m_postLayoutScrollPosition = WTF::nullopt;
2465 }
2466 
<a name="48" id="anc48"></a><span class="line-modified">2467 void RenderLayer::scrollToXPosition(int x, ScrollType scrollType, ScrollClamping clamping)</span>
2468 {
2469     ScrollPosition position(x, m_scrollPosition.y());
<a name="49" id="anc49"></a><span class="line-modified">2470     scrollToOffset(scrollOffsetFromPosition(position), scrollType, clamping);</span>
2471 }
2472 
<a name="50" id="anc50"></a><span class="line-modified">2473 void RenderLayer::scrollToYPosition(int y, ScrollType scrollType, ScrollClamping clamping)</span>
2474 {
2475     ScrollPosition position(m_scrollPosition.x(), y);
<a name="51" id="anc51"></a><span class="line-modified">2476     scrollToOffset(scrollOffsetFromPosition(position), scrollType, clamping);</span>
2477 }
2478 
2479 ScrollOffset RenderLayer::clampScrollOffset(const ScrollOffset&amp; scrollOffset) const
2480 {
2481     return scrollOffset.constrainedBetween(IntPoint(), maximumScrollOffset());
2482 }
2483 
<a name="52" id="anc52"></a><span class="line-modified">2484 void RenderLayer::scrollToOffset(const ScrollOffset&amp; scrollOffset, ScrollType scrollType, ScrollClamping clamping)</span>
2485 {
<a name="53" id="anc53"></a><span class="line-modified">2486     ScrollOffset clampedScrollOffset = clamping == ScrollClamping::Clamped ? clampScrollOffset(scrollOffset) : scrollOffset;</span>
<span class="line-modified">2487     if (clampedScrollOffset == this-&gt;scrollOffset())</span>
<span class="line-modified">2488         return;</span>
<span class="line-added">2489 </span>
<span class="line-added">2490     auto previousScrollType = currentScrollType();</span>
<span class="line-added">2491     setCurrentScrollType(scrollType);</span>
<span class="line-added">2492 </span>
<span class="line-added">2493     bool handled = false;</span>
<span class="line-added">2494 #if ENABLE(ASYNC_SCROLLING)</span>
<span class="line-added">2495     if (ScrollingCoordinator* scrollingCoordinator = page().scrollingCoordinator())</span>
<span class="line-added">2496         handled = scrollingCoordinator-&gt;requestScrollPositionUpdate(*this, scrollPositionFromOffset(clampedScrollOffset));</span>
<span class="line-added">2497 #endif</span>
<span class="line-added">2498 </span>
<span class="line-added">2499     if (!handled)</span>
<span class="line-added">2500         scrollToOffsetWithoutAnimation(clampedScrollOffset, clamping);</span>
<span class="line-added">2501 </span>
<span class="line-added">2502     setCurrentScrollType(previousScrollType);</span>
2503 }
2504 
2505 void RenderLayer::scrollTo(const ScrollPosition&amp; position)
2506 {
2507     RenderBox* box = renderBox();
2508     if (!box)
2509         return;
2510 
<a name="54" id="anc54"></a><span class="line-modified">2511     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;RenderLayer::scrollTo &quot; &lt;&lt; position &lt;&lt; &quot; from &quot; &lt;&lt; m_scrollPosition &lt;&lt; &quot; (is user scroll &quot; &lt;&lt; (currentScrollType() == ScrollType::User) &lt;&lt; &quot;)&quot;);</span>
2512 
2513     ScrollPosition newPosition = position;
2514     if (!box-&gt;isHTMLMarquee()) {
2515         // Ensure that the dimensions will be computed if they need to be (for overflow:hidden blocks).
2516         if (m_scrollDimensionsDirty)
2517             computeScrollDimensions();
2518 #if PLATFORM(IOS_FAMILY)
2519         if (adjustForIOSCaretWhenScrolling()) {
2520             // FIXME: It&#39;s not clear what this code is trying to do. Behavior seems reasonable with it removed.
2521             int maxOffset = scrollWidth() - roundToInt(box-&gt;clientWidth());
2522             ScrollOffset newOffset = scrollOffsetFromPosition(newPosition);
2523             int scrollXOffset = newOffset.x();
2524             if (scrollXOffset &gt; maxOffset - caretWidth) {
2525                 scrollXOffset += caretWidth;
2526                 if (scrollXOffset &lt;= caretWidth)
2527                     scrollXOffset = 0;
2528             } else if (scrollXOffset &lt; m_scrollPosition.x() - caretWidth)
2529                 scrollXOffset -= caretWidth;
2530 
2531             newOffset.setX(scrollXOffset);
2532             newPosition = scrollPositionFromOffset(newOffset);
2533         }
2534 #endif
2535     }
2536 
2537     if (m_scrollPosition == newPosition) {
2538         // FIXME: Nothing guarantees we get a scrollTo() with an unchanged position at the end of a user gesture.
2539         // The ScrollingCoordinator probably needs to message the main thread when a gesture ends.
2540         if (requiresScrollPositionReconciliation()) {
2541             setNeedsCompositingGeometryUpdate();
2542             updateCompositingLayersAfterScroll();
2543         }
2544         return;
2545     }
2546 
2547     m_scrollPosition = newPosition;
2548 
2549     RenderView&amp; view = renderer().view();
2550 
2551     // Update the positions of our child layers (if needed as only fixed layers should be impacted by a scroll).
2552     // We don&#39;t update compositing layers, because we need to do a deep update from the compositing ancestor.
2553     if (!view.frameView().layoutContext().isInRenderTreeLayout()) {
2554         // If we&#39;re in the middle of layout, we&#39;ll just update layers once layout has finished.
2555         updateLayerPositionsAfterOverflowScroll();
2556 
2557         view.frameView().scheduleUpdateWidgetPositions();
2558 
2559         if (!m_updatingMarqueePosition) {
2560             // Avoid updating compositing layers if, higher on the stack, we&#39;re already updating layer
2561             // positions. Updating layer positions requires a full walk of up-to-date RenderLayers, and
2562             // in this case we&#39;re still updating their positions; we&#39;ll update compositing layers later
2563             // when that completes.
2564             if (usesCompositedScrolling()) {
2565                 setNeedsCompositingGeometryUpdate();
<a name="55" id="anc55"></a><span class="line-modified">2566 </span>
<span class="line-added">2567                 // Scroll position can affect the location of a composited descendant (which may be a sibling in z-order),</span>
<span class="line-added">2568                 // so trigger a descendant walk from the paint-order parent.</span>
<span class="line-added">2569                 if (auto* paintParent = paintOrderParent())</span>
<span class="line-added">2570                     paintParent-&gt;setDescendantsNeedUpdateBackingAndHierarchyTraversal();</span>
2571             }
2572 
2573             updateCompositingLayersAfterScroll();
2574         }
2575 
2576         // Update regions, scrolling may change the clip of a particular region.
<a name="56" id="anc56"></a><span class="line-modified">2577         renderer().document().invalidateRenderingDependentRegions();</span>
2578         DebugPageOverlays::didLayout(renderer().frame());
2579     }
2580 
2581     Frame&amp; frame = renderer().frame();
2582     RenderLayerModelObject* repaintContainer = renderer().containerForRepaint();
2583     // The caret rect needs to be invalidated after scrolling
2584     frame.selection().setCaretRectNeedsUpdate();
2585 
2586     LayoutRect rectForRepaint = renderer().hasRepaintLayoutRects() ? renderer().repaintLayoutRects().m_repaintRect : renderer().clippedOverflowRectForRepaint(repaintContainer);
2587 
2588     FloatQuad quadForFakeMouseMoveEvent = FloatQuad(rectForRepaint);
2589     if (repaintContainer)
2590         quadForFakeMouseMoveEvent = repaintContainer-&gt;localToAbsoluteQuad(quadForFakeMouseMoveEvent);
2591     frame.eventHandler().dispatchFakeMouseMoveEventSoonInQuad(quadForFakeMouseMoveEvent);
2592 
2593     bool requiresRepaint = true;
2594     if (usesCompositedScrolling()) {
2595         setNeedsCompositingGeometryUpdate();
2596         setDescendantsNeedUpdateBackingAndHierarchyTraversal();
2597         requiresRepaint = false;
2598     }
2599 
2600     // Just schedule a full repaint of our object.
2601     if (requiresRepaint)
2602         renderer().repaintUsingContainer(repaintContainer, rectForRepaint);
2603 
2604     // Schedule the scroll and scroll-related DOM events.
2605     if (Element* element = renderer().element())
2606         element-&gt;document().eventQueue().enqueueOrDispatchScrollEvent(*element);
2607 
2608     if (scrollsOverflow())
2609         view.frameView().didChangeScrollOffset();
2610 
2611     view.frameView().viewportContentsChanged();
2612 }
2613 
2614 static inline bool frameElementAndViewPermitScroll(HTMLFrameElementBase* frameElementBase, FrameView&amp; frameView)
2615 {
2616     // If scrollbars aren&#39;t explicitly forbidden, permit scrolling.
2617     if (frameElementBase &amp;&amp; frameElementBase-&gt;scrollingMode() != ScrollbarAlwaysOff)
2618         return true;
2619 
2620     // If scrollbars are forbidden, user initiated scrolls should obviously be ignored.
2621     if (frameView.wasScrolledByUser())
2622         return false;
2623 
2624     // Forbid autoscrolls when scrollbars are off, but permits other programmatic scrolls,
2625     // like navigation to an anchor.
2626     return !frameView.frame().eventHandler().autoscrollInProgress();
2627 }
2628 
2629 bool RenderLayer::allowsCurrentScroll() const
2630 {
2631     if (!renderer().hasOverflowClip())
2632         return false;
2633 
2634     // Don&#39;t scroll to reveal an overflow layer that is restricted by the -webkit-line-clamp property.
2635     // FIXME: Is this still needed? It used to be relevant for Safari RSS.
2636     if (renderer().parent() &amp;&amp; !renderer().parent()-&gt;style().lineClamp().isNone())
2637         return false;
2638 
2639     RenderBox* box = renderBox();
2640     ASSERT(box); // Only boxes can have overflowClip set.
2641 
2642     if (renderer().frame().eventHandler().autoscrollInProgress()) {
2643         // The &quot;programmatically&quot; here is misleading; this asks whether the box has scrollable overflow,
2644         // or is a special case like a form control.
2645         return box-&gt;canBeProgramaticallyScrolled();
2646     }
2647 
2648     // Programmatic scrolls can scroll overflow:hidden.
2649     return box-&gt;hasHorizontalOverflow() || box-&gt;hasVerticalOverflow();
2650 }
2651 
2652 void RenderLayer::scrollRectToVisible(const LayoutRect&amp; absoluteRect, bool insideFixed, const ScrollRectToVisibleOptions&amp; options)
2653 {
2654     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;Layer &quot; &lt;&lt; this &lt;&lt; &quot; scrollRectToVisible &quot; &lt;&lt; absoluteRect);
2655 
2656     RenderLayer* parentLayer = nullptr;
2657     LayoutRect newRect = absoluteRect;
2658 
2659     // We may end up propagating a scroll event. It is important that we suspend events until
2660     // the end of the function since they could delete the layer or the layer&#39;s renderer().
2661     FrameView&amp; frameView = renderer().view().frameView();
2662 
2663     if (renderer().parent())
2664         parentLayer = renderer().parent()-&gt;enclosingLayer();
2665 
2666     if (allowsCurrentScroll()) {
2667         // Don&#39;t scroll to reveal an overflow layer that is restricted by the -webkit-line-clamp property.
2668         // This will prevent us from revealing text hidden by the slider in Safari RSS.
2669         RenderBox* box = renderBox();
2670         ASSERT(box);
2671         LayoutRect localExposeRect(box-&gt;absoluteToLocalQuad(FloatQuad(FloatRect(absoluteRect))).boundingBox());
<a name="57" id="anc57"></a><span class="line-added">2672         if (shouldPlaceBlockDirectionScrollbarOnLeft()) {</span>
<span class="line-added">2673             // For direction: rtl; writing-mode: horizontal-tb box, the scroll bar is on the left side. The visible rect</span>
<span class="line-added">2674             // starts from the right side of scroll bar. So the x of localExposeRect should start from the same position too.</span>
<span class="line-added">2675             localExposeRect.moveBy(LayoutPoint(-verticalScrollbarWidth(), 0));</span>
<span class="line-added">2676         }</span>
2677         LayoutRect layerBounds(0_lu, 0_lu, box-&gt;clientWidth(), box-&gt;clientHeight());
2678         LayoutRect revealRect = getRectToExpose(layerBounds, localExposeRect, insideFixed, options.alignX, options.alignY);
2679 
2680         ScrollOffset clampedScrollOffset = clampScrollOffset(scrollOffset() + toIntSize(roundedIntRect(revealRect).location()));
2681         if (clampedScrollOffset != scrollOffset()) {
2682             ScrollOffset oldScrollOffset = scrollOffset();
2683             scrollToOffset(clampedScrollOffset);
2684             IntSize scrollOffsetDifference = scrollOffset() - oldScrollOffset;
2685             localExposeRect.move(-scrollOffsetDifference);
2686             newRect = LayoutRect(box-&gt;localToAbsoluteQuad(FloatQuad(FloatRect(localExposeRect)), UseTransforms).boundingBox());
2687         }
2688     } else if (!parentLayer &amp;&amp; renderer().isRenderView()) {
2689         HTMLFrameOwnerElement* ownerElement = renderer().document().ownerElement();
2690 
2691         if (ownerElement &amp;&amp; ownerElement-&gt;renderer()) {
2692             HTMLFrameElementBase* frameElementBase = nullptr;
2693 
2694             if (is&lt;HTMLFrameElementBase&gt;(*ownerElement))
2695                 frameElementBase = downcast&lt;HTMLFrameElementBase&gt;(ownerElement);
2696 
2697             if (frameElementAndViewPermitScroll(frameElementBase, frameView)) {
2698                 // If this assertion fires we need to protect the ownerElement from being destroyed.
2699                 ScriptDisallowedScope::InMainThread scriptDisallowedScope;
2700 
2701                 LayoutRect viewRect = frameView.visibleContentRect(LegacyIOSDocumentVisibleRect);
2702                 LayoutRect exposeRect = getRectToExpose(viewRect, absoluteRect, insideFixed, options.alignX, options.alignY);
2703 
2704                 IntPoint scrollOffset(roundedIntPoint(exposeRect.location()));
2705                 // Adjust offsets if they&#39;re outside of the allowable range.
2706                 scrollOffset = scrollOffset.constrainedBetween(IntPoint(), IntPoint(frameView.contentsSize()));
2707                 frameView.setScrollPosition(scrollOffset);
2708 
2709                 if (options.shouldAllowCrossOriginScrolling == ShouldAllowCrossOriginScrolling::Yes || frameView.safeToPropagateScrollToParent()) {
2710                     parentLayer = ownerElement-&gt;renderer()-&gt;enclosingLayer();
2711                     // Convert the rect into the coordinate space of the parent frame&#39;s document.
2712                     newRect = frameView.contentsToContainingViewContents(enclosingIntRect(newRect));
2713                     insideFixed = false; // FIXME: ideally need to determine if this &lt;iframe&gt; is inside position:fixed.
2714                 } else
2715                     parentLayer = nullptr;
2716             }
2717         } else {
2718             if (options.revealMode == SelectionRevealMode::RevealUpToMainFrame &amp;&amp; frameView.frame().isMainFrame())
2719                 return;
2720 
<a name="58" id="anc58"></a><span class="line-added">2721             auto minScrollPosition = frameView.minimumScrollPosition();</span>
<span class="line-added">2722             auto maxScrollPosition = frameView.maximumScrollPosition();</span>
<span class="line-added">2723 </span>
2724 #if !PLATFORM(IOS_FAMILY)
2725             LayoutRect viewRect = frameView.visibleContentRect();
2726 #else
<a name="59" id="anc59"></a><span class="line-modified">2727             // FIXME: ContentInsets should be taken care of in UI process side. webkit.org/b/199682</span>
<span class="line-added">2728             // To do that, getRectToExpose needs to return the additional scrolling to do beyond content rect.</span>
<span class="line-added">2729             LayoutRect viewRect = frameView.viewRectExpandedByContentInsets();</span>
<span class="line-added">2730 </span>
<span class="line-added">2731             // FIXME: webkit.org/b/199683 FrameView::visibleContentRect is wrong when content insets are present</span>
<span class="line-added">2732             maxScrollPosition = frameView.scrollPositionFromOffset(ScrollPosition(frameView.totalContentsSize() - flooredIntSize(viewRect.size())));</span>
<span class="line-added">2733 </span>
<span class="line-added">2734             auto contentInsets = page().contentInsets();</span>
<span class="line-added">2735             minScrollPosition.move(-contentInsets.left(), -contentInsets.top());</span>
<span class="line-added">2736             maxScrollPosition.move(contentInsets.right(), contentInsets.bottom());</span>
2737 #endif
2738             // Move the target rect into &quot;scrollView contents&quot; coordinates.
2739             LayoutRect targetRect = absoluteRect;
2740             targetRect.move(0, frameView.headerHeight());
2741 
2742             LayoutRect revealRect = getRectToExpose(viewRect, targetRect, insideFixed, options.alignX, options.alignY);
<a name="60" id="anc60"></a><span class="line-modified">2743             // Avoid scrolling to the rounded value of revealRect.location() if we don&#39;t actually need to scroll</span>
<span class="line-modified">2744             if (revealRect != viewRect) {</span>
<span class="line-added">2745                 ScrollOffset clampedScrollPosition = roundedIntPoint(revealRect.location()).constrainedBetween(minScrollPosition, maxScrollPosition);</span>
<span class="line-added">2746                 frameView.setScrollPosition(clampedScrollPosition);</span>
<span class="line-added">2747             }</span>
2748 
2749             // This is the outermost view of a web page, so after scrolling this view we
2750             // scroll its container by calling Page::scrollRectIntoView.
2751             // This only has an effect on the Mac platform in applications
2752             // that put web views into scrolling containers, such as Mac OS X Mail.
2753             // The canAutoscroll function in EventHandler also knows about this.
2754             page().chrome().scrollRectIntoView(snappedIntRect(absoluteRect));
2755         }
2756     }
2757 
2758     if (parentLayer)
2759         parentLayer-&gt;scrollRectToVisible(newRect, insideFixed, options);
2760 }
2761 
2762 void RenderLayer::updateCompositingLayersAfterScroll()
2763 {
2764     if (compositor().hasContentCompositingLayers()) {
2765         // Our stacking container is guaranteed to contain all of our descendants that may need
2766         // repositioning, so update compositing layers from there.
2767         if (RenderLayer* compositingAncestor = stackingContext()-&gt;enclosingCompositingLayer()) {
2768             if (usesCompositedScrolling())
2769                 compositor().updateCompositingLayers(CompositingUpdateType::OnCompositedScroll, compositingAncestor);
2770             else {
2771                 // FIXME: would be nice to only dirty layers whose positions were affected by scrolling.
2772                 compositingAncestor-&gt;setDescendantsNeedUpdateBackingAndHierarchyTraversal();
2773                 compositor().updateCompositingLayers(CompositingUpdateType::OnScroll, compositingAncestor);
2774             }
2775         }
2776     }
2777 }
2778 
2779 LayoutRect RenderLayer::getRectToExpose(const LayoutRect&amp; visibleRect, const LayoutRect&amp; exposeRect, bool insideFixed, const ScrollAlignment&amp; alignX, const ScrollAlignment&amp; alignY) const
2780 {
2781     FrameView&amp; frameView = renderer().view().frameView();
2782     if (renderer().isRenderView() &amp;&amp; insideFixed) {
2783         // If the element is inside position:fixed and we&#39;re not scaled, no amount of scrolling is going to move things around.
2784         if (frameView.frameScaleFactor() == 1)
2785             return visibleRect;
2786 
2787         if (renderer().settings().visualViewportEnabled()) {
2788             // exposeRect is in absolute coords, affected by page scale. Unscale it.
2789             LayoutRect unscaledExposeRect = exposeRect;
2790             unscaledExposeRect.scale(1 / frameView.frameScaleFactor());
2791             unscaledExposeRect.move(0, -frameView.headerHeight());
2792 
2793             // These are both in unscaled coordinates.
2794             LayoutRect layoutViewport = frameView.layoutViewportRect();
2795             LayoutRect visualViewport = frameView.visualViewportRect();
2796 
2797             // The rect to expose may be partially offscreen, which we can&#39;t do anything about with position:fixed.
2798             unscaledExposeRect.intersect(layoutViewport);
2799             // Make sure it&#39;s not larger than the visual viewport; if so, we&#39;ll just move to the top left.
2800             unscaledExposeRect.setSize(unscaledExposeRect.size().shrunkTo(visualViewport.size()));
2801 
2802             // Compute how much we have to move the visualViewport to reveal the part of the layoutViewport that contains exposeRect.
2803             LayoutRect requiredVisualViewport = getRectToExpose(visualViewport, unscaledExposeRect, false, alignX, alignY);
2804             // Scale it back up.
2805             requiredVisualViewport.scale(frameView.frameScaleFactor());
2806             requiredVisualViewport.move(0, frameView.headerHeight());
2807             return requiredVisualViewport;
2808         }
2809     }
2810 
2811     // Determine the appropriate X behavior.
2812     ScrollAlignment::Behavior scrollX;
2813     LayoutRect exposeRectX(exposeRect.x(), visibleRect.y(), exposeRect.width(), visibleRect.height());
2814     LayoutUnit intersectWidth = intersection(visibleRect, exposeRectX).width();
2815     if (intersectWidth == exposeRect.width() || intersectWidth &gt;= MIN_INTERSECT_FOR_REVEAL)
2816         // If the rectangle is fully visible, use the specified visible behavior.
2817         // If the rectangle is partially visible, but over a certain threshold,
2818         // then treat it as fully visible to avoid unnecessary horizontal scrolling
2819         scrollX = ScrollAlignment::getVisibleBehavior(alignX);
2820     else if (intersectWidth == visibleRect.width()) {
2821         // If the rect is bigger than the visible area, don&#39;t bother trying to center. Other alignments will work.
2822         scrollX = ScrollAlignment::getVisibleBehavior(alignX);
2823         if (scrollX == ScrollAlignment::Behavior::AlignCenter)
2824             scrollX = ScrollAlignment::Behavior::NoScroll;
2825     } else if (intersectWidth &gt; 0)
2826         // If the rectangle is partially visible, but not above the minimum threshold, use the specified partial behavior
2827         scrollX = ScrollAlignment::getPartialBehavior(alignX);
2828     else
2829         scrollX = ScrollAlignment::getHiddenBehavior(alignX);
2830     // If we&#39;re trying to align to the closest edge, and the exposeRect is further right
2831     // than the visibleRect, and not bigger than the visible area, then align with the right.
2832     if (scrollX == ScrollAlignment::Behavior::AlignToClosestEdge &amp;&amp; exposeRect.maxX() &gt; visibleRect.maxX() &amp;&amp; exposeRect.width() &lt; visibleRect.width())
2833         scrollX = ScrollAlignment::Behavior::AlignRight;
2834 
2835     // Given the X behavior, compute the X coordinate.
2836     LayoutUnit x;
2837     if (scrollX == ScrollAlignment::Behavior::NoScroll)
2838         x = visibleRect.x();
2839     else if (scrollX == ScrollAlignment::Behavior::AlignRight)
2840         x = exposeRect.maxX() - visibleRect.width();
2841     else if (scrollX == ScrollAlignment::Behavior::AlignCenter)
2842         x = exposeRect.x() + (exposeRect.width() - visibleRect.width()) / 2;
2843     else
2844         x = exposeRect.x();
2845 
2846     // Determine the appropriate Y behavior.
2847     ScrollAlignment::Behavior scrollY;
2848     LayoutRect exposeRectY(visibleRect.x(), exposeRect.y(), visibleRect.width(), exposeRect.height());
2849     LayoutUnit intersectHeight = intersection(visibleRect, exposeRectY).height();
2850     if (intersectHeight == exposeRect.height())
2851         // If the rectangle is fully visible, use the specified visible behavior.
2852         scrollY = ScrollAlignment::getVisibleBehavior(alignY);
2853     else if (intersectHeight == visibleRect.height()) {
2854         // If the rect is bigger than the visible area, don&#39;t bother trying to center. Other alignments will work.
2855         scrollY = ScrollAlignment::getVisibleBehavior(alignY);
2856         if (scrollY == ScrollAlignment::Behavior::AlignCenter)
2857             scrollY = ScrollAlignment::Behavior::NoScroll;
2858     } else if (intersectHeight &gt; 0)
2859         // If the rectangle is partially visible, use the specified partial behavior
2860         scrollY = ScrollAlignment::getPartialBehavior(alignY);
2861     else
2862         scrollY = ScrollAlignment::getHiddenBehavior(alignY);
2863     // If we&#39;re trying to align to the closest edge, and the exposeRect is further down
2864     // than the visibleRect, and not bigger than the visible area, then align with the bottom.
2865     if (scrollY == ScrollAlignment::Behavior::AlignToClosestEdge &amp;&amp; exposeRect.maxY() &gt; visibleRect.maxY() &amp;&amp; exposeRect.height() &lt; visibleRect.height())
2866         scrollY = ScrollAlignment::Behavior::AlignBottom;
2867 
2868     // Given the Y behavior, compute the Y coordinate.
2869     LayoutUnit y;
2870     if (scrollY == ScrollAlignment::Behavior::NoScroll)
2871         y = visibleRect.y();
2872     else if (scrollY == ScrollAlignment::Behavior::AlignBottom)
2873         y = exposeRect.maxY() - visibleRect.height();
2874     else if (scrollY == ScrollAlignment::Behavior::AlignCenter)
2875         y = exposeRect.y() + (exposeRect.height() - visibleRect.height()) / 2;
2876     else
2877         y = exposeRect.y();
2878 
2879     return LayoutRect(LayoutPoint(x, y), visibleRect.size());
2880 }
2881 
2882 void RenderLayer::autoscroll(const IntPoint&amp; positionInWindow)
2883 {
2884     IntPoint currentDocumentPosition = renderer().view().frameView().windowToContents(positionInWindow);
2885     scrollRectToVisible(LayoutRect(currentDocumentPosition, LayoutSize(1, 1)), false, { SelectionRevealMode::Reveal, ScrollAlignment::alignToEdgeIfNeeded, ScrollAlignment::alignToEdgeIfNeeded, ShouldAllowCrossOriginScrolling::Yes });
2886 }
2887 
2888 bool RenderLayer::canResize() const
2889 {
2890     // We need a special case for &lt;iframe&gt; because they never have
2891     // hasOverflowClip(). However, they do &quot;implicitly&quot; clip their contents, so
2892     // we want to allow resizing them also.
2893     return (renderer().hasOverflowClip() || renderer().isRenderIFrame()) &amp;&amp; renderer().style().resize() != Resize::None;
2894 }
2895 
2896 void RenderLayer::resize(const PlatformMouseEvent&amp; evt, const LayoutSize&amp; oldOffset)
2897 {
2898     // FIXME: This should be possible on generated content but is not right now.
2899     if (!inResizeMode() || !canResize() || !renderer().element())
2900         return;
2901 
2902     // FIXME: The only case where renderer-&gt;element()-&gt;renderer() != renderer is with continuations. Do they matter here?
2903     // If they do it would still be better to deal with them explicitly.
2904     Element* element = renderer().element();
2905     auto* renderer = downcast&lt;RenderBox&gt;(element-&gt;renderer());
2906 
2907     Document&amp; document = element-&gt;document();
2908     if (!document.frame()-&gt;eventHandler().mousePressed())
2909         return;
2910 
2911     float zoomFactor = renderer-&gt;style().effectiveZoom();
2912 
2913     LayoutSize newOffset = offsetFromResizeCorner(document.view()-&gt;windowToContents(evt.position()));
2914     newOffset.setWidth(newOffset.width() / zoomFactor);
2915     newOffset.setHeight(newOffset.height() / zoomFactor);
2916 
2917     LayoutSize currentSize = LayoutSize(renderer-&gt;width() / zoomFactor, renderer-&gt;height() / zoomFactor);
2918     LayoutSize minimumSize = element-&gt;minimumSizeForResizing().shrunkTo(currentSize);
2919     element-&gt;setMinimumSizeForResizing(minimumSize);
2920 
2921     LayoutSize adjustedOldOffset = LayoutSize(oldOffset.width() / zoomFactor, oldOffset.height() / zoomFactor);
2922     if (shouldPlaceBlockDirectionScrollbarOnLeft()) {
2923         newOffset.setWidth(-newOffset.width());
2924         adjustedOldOffset.setWidth(-adjustedOldOffset.width());
2925     }
2926 
2927     LayoutSize difference = (currentSize + newOffset - adjustedOldOffset).expandedTo(minimumSize) - currentSize;
2928 
2929     StyledElement* styledElement = downcast&lt;StyledElement&gt;(element);
2930     bool isBoxSizingBorder = renderer-&gt;style().boxSizing() == BoxSizing::BorderBox;
2931 
2932     Resize resize = renderer-&gt;style().resize();
2933     if (resize != Resize::Vertical &amp;&amp; difference.width()) {
2934         if (is&lt;HTMLFormControlElement&gt;(*element)) {
2935             // Make implicit margins from the theme explicit (see &lt;http://bugs.webkit.org/show_bug.cgi?id=9547&gt;).
2936             styledElement-&gt;setInlineStyleProperty(CSSPropertyMarginLeft, renderer-&gt;marginLeft() / zoomFactor, CSSPrimitiveValue::CSS_PX);
2937             styledElement-&gt;setInlineStyleProperty(CSSPropertyMarginRight, renderer-&gt;marginRight() / zoomFactor, CSSPrimitiveValue::CSS_PX);
2938         }
2939         LayoutUnit baseWidth = renderer-&gt;width() - (isBoxSizingBorder ? 0_lu : renderer-&gt;horizontalBorderAndPaddingExtent());
2940         baseWidth = baseWidth / zoomFactor;
2941         styledElement-&gt;setInlineStyleProperty(CSSPropertyWidth, roundToInt(baseWidth + difference.width()), CSSPrimitiveValue::CSS_PX);
2942     }
2943 
2944     if (resize != Resize::Horizontal &amp;&amp; difference.height()) {
2945         if (is&lt;HTMLFormControlElement&gt;(*element)) {
2946             // Make implicit margins from the theme explicit (see &lt;http://bugs.webkit.org/show_bug.cgi?id=9547&gt;).
2947             styledElement-&gt;setInlineStyleProperty(CSSPropertyMarginTop, renderer-&gt;marginTop() / zoomFactor, CSSPrimitiveValue::CSS_PX);
2948             styledElement-&gt;setInlineStyleProperty(CSSPropertyMarginBottom, renderer-&gt;marginBottom() / zoomFactor, CSSPrimitiveValue::CSS_PX);
2949         }
2950         LayoutUnit baseHeight = renderer-&gt;height() - (isBoxSizingBorder ? 0_lu : renderer-&gt;verticalBorderAndPaddingExtent());
2951         baseHeight = baseHeight / zoomFactor;
2952         styledElement-&gt;setInlineStyleProperty(CSSPropertyHeight, roundToInt(baseHeight + difference.height()), CSSPrimitiveValue::CSS_PX);
2953     }
2954 
2955     document.updateLayout();
2956 
2957     // FIXME (Radar 4118564): We should also autoscroll the window as necessary to keep the point under the cursor in view.
2958 }
2959 
<a name="61" id="anc61"></a>





2960 void RenderLayer::setScrollOffset(const ScrollOffset&amp; offset)
2961 {
2962     scrollTo(scrollPositionFromOffset(offset));
2963 }
2964 
<a name="62" id="anc62"></a><span class="line-modified">2965 ScrollingNodeID RenderLayer::scrollingNodeID() const</span>
2966 {
<a name="63" id="anc63"></a><span class="line-modified">2967     if (!isComposited())</span>
<span class="line-modified">2968         return 0;</span>



2969 
<a name="64" id="anc64"></a><span class="line-modified">2970     return backing()-&gt;scrollingNodeIDForRole(ScrollCoordinationRole::Scrolling);</span>
2971 }
2972 
2973 IntRect RenderLayer::visibleContentRectInternal(VisibleContentRectIncludesScrollbars scrollbarInclusion, VisibleContentRectBehavior) const
2974 {
2975     IntSize scrollbarSpace;
2976     if (showsOverflowControls() &amp;&amp; scrollbarInclusion == IncludeScrollbars)
2977         scrollbarSpace = scrollbarIntrusion();
2978 
2979     auto visibleSize = this-&gt;visibleSize();
2980     return { scrollPosition(), { std::max(0, visibleSize.width() - scrollbarSpace.width()), std::max(0, visibleSize.height() - scrollbarSpace.height()) } };
2981 }
2982 
2983 IntSize RenderLayer::overhangAmount() const
2984 {
2985 #if ENABLE(RUBBER_BANDING)
2986     if (!renderer().settings().rubberBandingForSubScrollableRegionsEnabled())
2987         return IntSize();
2988 
2989     IntSize stretch;
2990 
2991     // FIXME: use maximumScrollOffset(), or just move this to ScrollableArea.
2992     ScrollOffset scrollOffset = scrollOffsetFromPosition(scrollPosition());
<a name="65" id="anc65"></a><span class="line-added">2993     auto reachableSize = reachableTotalContentsSize();</span>
2994     if (scrollOffset.y() &lt; 0)
2995         stretch.setHeight(scrollOffset.y());
<a name="66" id="anc66"></a><span class="line-modified">2996     else if (reachableSize.height() &amp;&amp; scrollOffset.y() &gt; reachableSize.height() - visibleHeight())</span>
<span class="line-modified">2997         stretch.setHeight(scrollOffset.y() - (reachableSize.height() - visibleHeight()));</span>
2998 
2999     if (scrollOffset.x() &lt; 0)
3000         stretch.setWidth(scrollOffset.x());
<a name="67" id="anc67"></a><span class="line-modified">3001     else if (reachableSize.width() &amp;&amp; scrollOffset.x() &gt; reachableSize.width() - visibleWidth())</span>
<span class="line-modified">3002         stretch.setWidth(scrollOffset.x() - (reachableSize.width() - visibleWidth()));</span>
3003 
3004     return stretch;
3005 #else
3006     return IntSize();
3007 #endif
3008 }
3009 
3010 bool RenderLayer::isActive() const
3011 {
3012     return page().focusController().isActive();
3013 }
3014 
3015 static int cornerStart(const RenderLayer&amp; layer, int minX, int maxX, int thickness)
3016 {
3017     if (layer.shouldPlaceBlockDirectionScrollbarOnLeft())
3018         return minX + layer.renderer().style().borderLeftWidth();
3019     return maxX - thickness - layer.renderer().style().borderRightWidth();
3020 }
3021 
3022 static LayoutRect cornerRect(const RenderLayer&amp; layer, const LayoutRect&amp; bounds)
3023 {
3024     int horizontalThickness;
3025     int verticalThickness;
3026     if (!layer.verticalScrollbar() &amp;&amp; !layer.horizontalScrollbar()) {
3027         // FIXME: This isn&#39;t right.  We need to know the thickness of custom scrollbars
3028         // even when they don&#39;t exist in order to set the resizer square size properly.
3029         horizontalThickness = ScrollbarTheme::theme().scrollbarThickness();
3030         verticalThickness = horizontalThickness;
3031     } else if (layer.verticalScrollbar() &amp;&amp; !layer.horizontalScrollbar()) {
3032         horizontalThickness = layer.verticalScrollbar()-&gt;width();
3033         verticalThickness = horizontalThickness;
3034     } else if (layer.horizontalScrollbar() &amp;&amp; !layer.verticalScrollbar()) {
3035         verticalThickness = layer.horizontalScrollbar()-&gt;height();
3036         horizontalThickness = verticalThickness;
3037     } else {
3038         horizontalThickness = layer.verticalScrollbar()-&gt;width();
3039         verticalThickness = layer.horizontalScrollbar()-&gt;height();
3040     }
3041     return LayoutRect(cornerStart(layer, bounds.x(), bounds.maxX(), horizontalThickness),
3042         bounds.maxY() - verticalThickness - layer.renderer().style().borderBottomWidth(),
3043         horizontalThickness, verticalThickness);
3044 }
3045 
3046 IntRect RenderLayer::scrollCornerRect() const
3047 {
3048     // We have a scrollbar corner when a non overlay scrollbar is visible and not filling the entire length of the box.
3049     // This happens when:
3050     // (a) A resizer is present and at least one non overlay scrollbar is present
3051     // (b) Both non overlay scrollbars are present.
3052     // Overlay scrollbars always fill the entire length of the box so we never have scroll corner in that case.
3053     bool hasHorizontalBar = m_hBar &amp;&amp; !m_hBar-&gt;isOverlayScrollbar();
3054     bool hasVerticalBar = m_vBar &amp;&amp; !m_vBar-&gt;isOverlayScrollbar();
3055     bool hasResizer = renderer().style().resize() != Resize::None;
3056     if ((hasHorizontalBar &amp;&amp; hasVerticalBar) || (hasResizer &amp;&amp; (hasHorizontalBar || hasVerticalBar)))
3057         return snappedIntRect(cornerRect(*this, renderBox()-&gt;borderBoxRect()));
3058     return IntRect();
3059 }
3060 
3061 static LayoutRect resizerCornerRect(const RenderLayer&amp; layer, const LayoutRect&amp; bounds)
3062 {
3063     ASSERT(layer.renderer().isBox());
3064     if (layer.renderer().style().resize() == Resize::None)
3065         return LayoutRect();
3066     return cornerRect(layer, bounds);
3067 }
3068 
3069 LayoutRect RenderLayer::scrollCornerAndResizerRect() const
3070 {
3071     RenderBox* box = renderBox();
3072     if (!box)
3073         return LayoutRect();
3074     LayoutRect scrollCornerAndResizer = scrollCornerRect();
3075     if (scrollCornerAndResizer.isEmpty())
3076         scrollCornerAndResizer = resizerCornerRect(*this, box-&gt;borderBoxRect());
3077     return scrollCornerAndResizer;
3078 }
3079 
3080 bool RenderLayer::isScrollCornerVisible() const
3081 {
3082     ASSERT(renderer().isBox());
3083     return !scrollCornerRect().isEmpty();
3084 }
3085 
3086 IntRect RenderLayer::convertFromScrollbarToContainingView(const Scrollbar&amp; scrollbar, const IntRect&amp; scrollbarRect) const
3087 {
3088     IntRect rect = scrollbarRect;
3089     rect.move(scrollbarOffset(scrollbar));
3090 
3091     return renderer().view().frameView().convertFromRendererToContainingView(&amp;renderer(), rect);
3092 }
3093 
3094 IntRect RenderLayer::convertFromContainingViewToScrollbar(const Scrollbar&amp; scrollbar, const IntRect&amp; parentRect) const
3095 {
3096     IntRect rect = renderer().view().frameView().convertFromContainingViewToRenderer(&amp;renderer(), parentRect);
3097     rect.move(-scrollbarOffset(scrollbar));
3098     return rect;
3099 }
3100 
3101 IntPoint RenderLayer::convertFromScrollbarToContainingView(const Scrollbar&amp; scrollbar, const IntPoint&amp; scrollbarPoint) const
3102 {
3103     IntPoint point = scrollbarPoint;
3104     point.move(scrollbarOffset(scrollbar));
3105     return renderer().view().frameView().convertFromRendererToContainingView(&amp;renderer(), point);
3106 }
3107 
3108 IntPoint RenderLayer::convertFromContainingViewToScrollbar(const Scrollbar&amp; scrollbar, const IntPoint&amp; parentPoint) const
3109 {
3110     IntPoint point = renderer().view().frameView().convertFromContainingViewToRenderer(&amp;renderer(), parentPoint);
3111     point.move(-scrollbarOffset(scrollbar));
3112     return point;
3113 }
3114 
3115 IntSize RenderLayer::visibleSize() const
3116 {
3117     RenderBox* box = renderBox();
3118     if (!box)
3119         return IntSize();
3120 
3121     return IntSize(roundToInt(box-&gt;clientWidth()), roundToInt(box-&gt;clientHeight()));
3122 }
3123 
3124 IntSize RenderLayer::contentsSize() const
3125 {
3126     return IntSize(scrollWidth(), scrollHeight());
3127 }
3128 
<a name="68" id="anc68"></a><span class="line-modified">3129 IntSize RenderLayer::reachableTotalContentsSize() const</span>
3130 {
3131     IntSize contentsSize = this-&gt;contentsSize();
3132 
3133     if (!hasScrollableHorizontalOverflow())
3134         contentsSize.setWidth(std::min(contentsSize.width(), visibleSize().width()));
3135 
3136     if (!hasScrollableVerticalOverflow())
3137         contentsSize.setHeight(std::min(contentsSize.height(), visibleSize().height()));
3138 
3139     return contentsSize;
3140 }
3141 
3142 void RenderLayer::availableContentSizeChanged(AvailableSizeChangeReason reason)
3143 {
3144     ScrollableArea::availableContentSizeChanged(reason);
3145 
3146     if (reason == AvailableSizeChangeReason::ScrollbarsChanged) {
3147         if (is&lt;RenderBlock&gt;(renderer()))
3148             downcast&lt;RenderBlock&gt;(renderer()).setShouldForceRelayoutChildren(true);
3149         renderer().setNeedsLayout();
3150     }
3151 }
3152 
3153 bool RenderLayer::shouldSuspendScrollAnimations() const
3154 {
3155     return renderer().view().frameView().shouldSuspendScrollAnimations();
3156 }
3157 
3158 #if PLATFORM(IOS_FAMILY)
3159 void RenderLayer::didStartScroll()
3160 {
3161     page().chrome().client().didStartOverflowScroll();
3162 }
3163 
3164 void RenderLayer::didEndScroll()
3165 {
3166     page().chrome().client().didEndOverflowScroll();
3167 }
3168 
3169 void RenderLayer::didUpdateScroll()
3170 {
3171     // Send this notification when we scroll, since this is how we keep selection updated.
3172     page().chrome().client().didLayout(ChromeClient::Scroll);
3173 }
3174 #endif
3175 
3176 IntPoint RenderLayer::lastKnownMousePosition() const
3177 {
3178     return renderer().frame().eventHandler().lastKnownMousePosition();
3179 }
3180 
3181 bool RenderLayer::isHandlingWheelEvent() const
3182 {
3183     return renderer().frame().eventHandler().isHandlingWheelEvent();
3184 }
3185 
3186 IntRect RenderLayer::rectForHorizontalScrollbar(const IntRect&amp; borderBoxRect) const
3187 {
3188     if (!m_hBar)
3189         return IntRect();
3190 
3191     const RenderBox* box = renderBox();
3192     const IntRect&amp; scrollCorner = scrollCornerRect();
3193 
3194     return IntRect(horizontalScrollbarStart(borderBoxRect.x()),
3195         borderBoxRect.maxY() - box-&gt;borderBottom() - m_hBar-&gt;height(),
3196         borderBoxRect.width() - (box-&gt;borderLeft() + box-&gt;borderRight()) - scrollCorner.width(),
3197         m_hBar-&gt;height());
3198 }
3199 
3200 IntRect RenderLayer::rectForVerticalScrollbar(const IntRect&amp; borderBoxRect) const
3201 {
3202     if (!m_vBar)
3203         return IntRect();
3204 
3205     const RenderBox* box = renderBox();
3206     const IntRect&amp; scrollCorner = scrollCornerRect();
3207 
3208     return IntRect(verticalScrollbarStart(borderBoxRect.x(), borderBoxRect.maxX()),
3209         borderBoxRect.y() + box-&gt;borderTop(),
3210         m_vBar-&gt;width(),
3211         borderBoxRect.height() - (box-&gt;borderTop() + box-&gt;borderBottom()) - scrollCorner.height());
3212 }
3213 
3214 LayoutUnit RenderLayer::verticalScrollbarStart(int minX, int maxX) const
3215 {
3216     const RenderBox* box = renderBox();
3217     if (shouldPlaceBlockDirectionScrollbarOnLeft())
3218         return minX + box-&gt;borderLeft();
3219     return maxX - box-&gt;borderRight() - m_vBar-&gt;width();
3220 }
3221 
3222 LayoutUnit RenderLayer::horizontalScrollbarStart(int minX) const
3223 {
3224     const RenderBox* box = renderBox();
3225     int x = minX + box-&gt;borderLeft();
3226     if (shouldPlaceBlockDirectionScrollbarOnLeft())
3227         x += m_vBar ? m_vBar-&gt;width() : roundToInt(resizerCornerRect(*this, box-&gt;borderBoxRect()).width());
3228     return x;
3229 }
3230 
3231 IntSize RenderLayer::scrollbarOffset(const Scrollbar&amp; scrollbar) const
3232 {
3233     RenderBox* box = renderBox();
3234 
3235     if (&amp;scrollbar == m_vBar.get())
3236         return IntSize(verticalScrollbarStart(0, box-&gt;width()), box-&gt;borderTop());
3237 
3238     if (&amp;scrollbar == m_hBar.get())
3239         return IntSize(horizontalScrollbarStart(0), box-&gt;height() - box-&gt;borderBottom() - scrollbar.height());
3240 
3241     ASSERT_NOT_REACHED();
3242     return IntSize();
3243 }
3244 
3245 void RenderLayer::invalidateScrollbarRect(Scrollbar&amp; scrollbar, const IntRect&amp; rect)
3246 {
3247     if (!showsOverflowControls())
3248         return;
3249 
3250     if (&amp;scrollbar == m_vBar.get()) {
3251         if (GraphicsLayer* layer = layerForVerticalScrollbar()) {
3252             layer-&gt;setNeedsDisplayInRect(rect);
3253             return;
3254         }
3255     } else {
3256         if (GraphicsLayer* layer = layerForHorizontalScrollbar()) {
3257             layer-&gt;setNeedsDisplayInRect(rect);
3258             return;
3259         }
3260     }
3261 
3262     IntRect scrollRect = rect;
3263     RenderBox* box = renderBox();
3264     ASSERT(box);
3265     // If we are not yet inserted into the tree, there is no need to repaint.
3266     if (!box-&gt;parent())
3267         return;
3268 
3269     if (&amp;scrollbar == m_vBar.get())
3270         scrollRect.move(verticalScrollbarStart(0, box-&gt;width()), box-&gt;borderTop());
3271     else
3272         scrollRect.move(horizontalScrollbarStart(0), box-&gt;height() - box-&gt;borderBottom() - scrollbar.height());
3273     LayoutRect repaintRect = scrollRect;
3274     renderBox()-&gt;flipForWritingMode(repaintRect);
3275     renderer().repaintRectangle(repaintRect);
3276 }
3277 
3278 void RenderLayer::invalidateScrollCornerRect(const IntRect&amp; rect)
3279 {
3280     if (!showsOverflowControls())
3281         return;
3282 
3283     if (GraphicsLayer* layer = layerForScrollCorner()) {
3284         layer-&gt;setNeedsDisplayInRect(rect);
3285         return;
3286     }
3287 
3288     if (m_scrollCorner)
3289         m_scrollCorner-&gt;repaintRectangle(rect);
3290     if (m_resizer)
3291         m_resizer-&gt;repaintRectangle(rect);
3292 }
3293 
<a name="69" id="anc69"></a><span class="line-added">3294 static bool scrollbarHiddenByStyle(Scrollbar* scrollbar)</span>
<span class="line-added">3295 {</span>
<span class="line-added">3296     if (!scrollbar || !scrollbar-&gt;isCustomScrollbar())</span>
<span class="line-added">3297         return false;</span>
<span class="line-added">3298 </span>
<span class="line-added">3299     std::unique_ptr&lt;RenderStyle&gt; scrollbarStyle = static_cast&lt;RenderScrollbar*&gt;(scrollbar)-&gt;getScrollbarPseudoStyle(ScrollbarBGPart, PseudoId::Scrollbar);</span>
<span class="line-added">3300 </span>
<span class="line-added">3301     return scrollbarStyle &amp;&amp; scrollbarStyle-&gt;display() == DisplayType::None;</span>
<span class="line-added">3302 }</span>
<span class="line-added">3303 </span>
<span class="line-added">3304 bool RenderLayer::horizontalScrollbarHiddenByStyle() const</span>
<span class="line-added">3305 {</span>
<span class="line-added">3306     return scrollbarHiddenByStyle(horizontalScrollbar());</span>
<span class="line-added">3307 }</span>
<span class="line-added">3308 </span>
<span class="line-added">3309 bool RenderLayer::verticalScrollbarHiddenByStyle() const</span>
<span class="line-added">3310 {</span>
<span class="line-added">3311     return scrollbarHiddenByStyle(verticalScrollbar());</span>
<span class="line-added">3312 }</span>
<span class="line-added">3313 </span>
3314 static inline RenderElement* rendererForScrollbar(RenderLayerModelObject&amp; renderer)
3315 {
3316     if (Element* element = renderer.element()) {
3317         if (ShadowRoot* shadowRoot = element-&gt;containingShadowRoot()) {
3318             if (shadowRoot-&gt;mode() == ShadowRootMode::UserAgent)
3319                 return shadowRoot-&gt;host()-&gt;renderer();
3320         }
3321     }
3322 
3323     return &amp;renderer;
3324 }
3325 
3326 Ref&lt;Scrollbar&gt; RenderLayer::createScrollbar(ScrollbarOrientation orientation)
3327 {
3328     RefPtr&lt;Scrollbar&gt; widget;
3329     ASSERT(rendererForScrollbar(renderer()));
3330     auto&amp; actualRenderer = *rendererForScrollbar(renderer());
3331     bool hasCustomScrollbarStyle = is&lt;RenderBox&gt;(actualRenderer) &amp;&amp; downcast&lt;RenderBox&gt;(actualRenderer).style().hasPseudoStyle(PseudoId::Scrollbar);
3332     if (hasCustomScrollbarStyle)
3333         widget = RenderScrollbar::createCustomScrollbar(*this, orientation, downcast&lt;RenderBox&gt;(actualRenderer).element());
3334     else {
3335         widget = Scrollbar::createNativeScrollbar(*this, orientation, RegularScrollbar);
3336         didAddScrollbar(widget.get(), orientation);
3337         if (page().expectsWheelEventTriggers())
3338             scrollAnimator().setWheelEventTestTrigger(page().testTrigger());
3339     }
3340     renderer().view().frameView().addChild(*widget);
3341     return widget.releaseNonNull();
3342 }
3343 
3344 void RenderLayer::destroyScrollbar(ScrollbarOrientation orientation)
3345 {
3346     RefPtr&lt;Scrollbar&gt;&amp; scrollbar = orientation == HorizontalScrollbar ? m_hBar : m_vBar;
3347     if (!scrollbar)
3348         return;
3349 
3350     if (!scrollbar-&gt;isCustomScrollbar())
3351         willRemoveScrollbar(scrollbar.get(), orientation);
3352 
3353     scrollbar-&gt;removeFromParent();
3354     scrollbar = nullptr;
3355 }
3356 
3357 bool RenderLayer::scrollsOverflow() const
3358 {
3359     if (!is&lt;RenderBox&gt;(renderer()))
3360         return false;
3361 
3362     return downcast&lt;RenderBox&gt;(renderer()).scrollsOverflow();
3363 }
3364 
3365 void RenderLayer::setHasHorizontalScrollbar(bool hasScrollbar)
3366 {
3367     if (hasScrollbar == hasHorizontalScrollbar())
3368         return;
3369 
3370     if (hasScrollbar) {
3371         m_hBar = createScrollbar(HorizontalScrollbar);
3372 #if ENABLE(RUBBER_BANDING)
3373         ScrollElasticity elasticity = scrollsOverflow() &amp;&amp; renderer().settings().rubberBandingForSubScrollableRegionsEnabled() ? ScrollElasticityAutomatic : ScrollElasticityNone;
3374         ScrollableArea::setHorizontalScrollElasticity(elasticity);
3375 #endif
3376     } else {
3377         destroyScrollbar(HorizontalScrollbar);
3378 #if ENABLE(RUBBER_BANDING)
3379         ScrollableArea::setHorizontalScrollElasticity(ScrollElasticityNone);
3380 #endif
3381     }
3382 
3383     // Destroying or creating one bar can cause our scrollbar corner to come and go.  We need to update the opposite scrollbar&#39;s style.
3384     if (m_hBar)
3385         m_hBar-&gt;styleChanged();
3386     if (m_vBar)
3387         m_vBar-&gt;styleChanged();
<a name="70" id="anc70"></a>

3388 }
3389 
3390 void RenderLayer::setHasVerticalScrollbar(bool hasScrollbar)
3391 {
3392     if (hasScrollbar == hasVerticalScrollbar())
3393         return;
3394 
3395     if (hasScrollbar) {
3396         m_vBar = createScrollbar(VerticalScrollbar);
3397 #if ENABLE(RUBBER_BANDING)
3398         ScrollElasticity elasticity = scrollsOverflow() &amp;&amp; renderer().settings().rubberBandingForSubScrollableRegionsEnabled() ? ScrollElasticityAutomatic : ScrollElasticityNone;
3399         ScrollableArea::setVerticalScrollElasticity(elasticity);
3400 #endif
3401     } else {
3402         destroyScrollbar(VerticalScrollbar);
3403 #if ENABLE(RUBBER_BANDING)
3404         ScrollableArea::setVerticalScrollElasticity(ScrollElasticityNone);
3405 #endif
3406     }
3407 
3408      // Destroying or creating one bar can cause our scrollbar corner to come and go.  We need to update the opposite scrollbar&#39;s style.
3409     if (m_hBar)
3410         m_hBar-&gt;styleChanged();
3411     if (m_vBar)
3412         m_vBar-&gt;styleChanged();
<a name="71" id="anc71"></a>

3413 }
3414 
3415 ScrollableArea* RenderLayer::enclosingScrollableArea() const
3416 {
3417     if (RenderLayer* scrollableLayer = enclosingScrollableLayer())
3418         return scrollableLayer;
3419 
3420     // FIXME: We should return the frame view here (or possibly an ancestor frame view,
3421     // if the frame view isn&#39;t scrollable.
3422     return nullptr;
3423 }
3424 
3425 bool RenderLayer::isScrollableOrRubberbandable()
3426 {
3427     return renderer().isScrollableOrRubberbandableBox();
3428 }
3429 
3430 bool RenderLayer::hasScrollableOrRubberbandableAncestor()
3431 {
3432     for (RenderLayer* nextLayer = parentLayerCrossFrame(*this); nextLayer; nextLayer = parentLayerCrossFrame(*nextLayer)) {
3433         if (nextLayer-&gt;isScrollableOrRubberbandable())
3434             return true;
3435     }
3436 
3437     return false;
3438 }
3439 
3440 bool RenderLayer::useDarkAppearance() const
3441 {
3442     return renderer().useDarkAppearance();
3443 }
3444 
3445 #if ENABLE(CSS_SCROLL_SNAP)
3446 void RenderLayer::updateSnapOffsets()
3447 {
3448     // FIXME: Extend support beyond HTMLElements.
3449     if (!is&lt;HTMLElement&gt;(enclosingElement()) || !enclosingElement()-&gt;renderBox())
3450         return;
3451 
3452     RenderBox* box = enclosingElement()-&gt;renderBox();
3453     updateSnapOffsetsForScrollableArea(*this, *downcast&lt;HTMLElement&gt;(enclosingElement()), *box, box-&gt;style());
3454 }
3455 
3456 bool RenderLayer::isScrollSnapInProgress() const
3457 {
3458     if (!scrollsOverflow())
3459         return false;
3460 
3461     if (ScrollAnimator* scrollAnimator = existingScrollAnimator())
3462         return scrollAnimator-&gt;isScrollSnapInProgress();
3463 
3464     return false;
3465 }
3466 #endif
3467 
3468 bool RenderLayer::usesMockScrollAnimator() const
3469 {
3470     return DeprecatedGlobalSettings::usesMockScrollAnimator();
3471 }
3472 
3473 void RenderLayer::logMockScrollAnimatorMessage(const String&amp; message) const
3474 {
3475     renderer().document().addConsoleMessage(MessageSource::Other, MessageLevel::Debug, &quot;RenderLayer: &quot; + message);
3476 }
3477 
3478 int RenderLayer::verticalScrollbarWidth(OverlayScrollbarSizeRelevancy relevancy) const
3479 {
3480     if (!m_vBar
3481         || !showsOverflowControls()
3482         || (m_vBar-&gt;isOverlayScrollbar() &amp;&amp; (relevancy == IgnoreOverlayScrollbarSize || !m_vBar-&gt;shouldParticipateInHitTesting())))
3483         return 0;
3484 
3485     return m_vBar-&gt;width();
3486 }
3487 
3488 int RenderLayer::horizontalScrollbarHeight(OverlayScrollbarSizeRelevancy relevancy) const
3489 {
3490     if (!m_hBar
3491         || !showsOverflowControls()
3492         || (m_hBar-&gt;isOverlayScrollbar() &amp;&amp; (relevancy == IgnoreOverlayScrollbarSize || !m_hBar-&gt;shouldParticipateInHitTesting())))
3493         return 0;
3494 
3495     return m_hBar-&gt;height();
3496 }
3497 
3498 IntSize RenderLayer::offsetFromResizeCorner(const IntPoint&amp; absolutePoint) const
3499 {
3500     // Currently the resize corner is either the bottom right corner or the bottom left corner.
3501     // FIXME: This assumes the location is 0, 0. Is this guaranteed to always be the case?
3502     IntSize elementSize = size();
3503     if (shouldPlaceBlockDirectionScrollbarOnLeft())
3504         elementSize.setWidth(0);
3505     IntPoint resizerPoint = IntPoint(elementSize);
3506     IntPoint localPoint = roundedIntPoint(absoluteToContents(absolutePoint));
3507     return localPoint - resizerPoint;
3508 }
3509 
3510 bool RenderLayer::hasOverflowControls() const
3511 {
3512     return m_hBar || m_vBar || m_scrollCorner || renderer().style().resize() != Resize::None;
3513 }
3514 
3515 void RenderLayer::positionOverflowControls(const IntSize&amp; offsetFromRoot)
3516 {
3517     if (!m_hBar &amp;&amp; !m_vBar &amp;&amp; !canResize())
3518         return;
3519 
3520     RenderBox* box = renderBox();
3521     if (!box)
3522         return;
3523 
3524     const IntRect borderBox = snappedIntRect(box-&gt;borderBoxRect());
3525     const IntRect&amp; scrollCorner = scrollCornerRect();
3526     IntRect absBounds(borderBox.location() + offsetFromRoot, borderBox.size());
3527     if (m_vBar) {
3528         IntRect vBarRect = rectForVerticalScrollbar(borderBox);
3529         vBarRect.move(offsetFromRoot);
3530         m_vBar-&gt;setFrameRect(vBarRect);
3531     }
3532 
3533     if (m_hBar) {
3534         IntRect hBarRect = rectForHorizontalScrollbar(borderBox);
3535         hBarRect.move(offsetFromRoot);
3536         m_hBar-&gt;setFrameRect(hBarRect);
3537     }
3538 
3539     if (m_scrollCorner)
3540         m_scrollCorner-&gt;setFrameRect(scrollCorner);
3541     if (m_resizer)
3542         m_resizer-&gt;setFrameRect(resizerCornerRect(*this, borderBox));
3543 
3544     if (isComposited())
3545         backing()-&gt;positionOverflowControlsLayers();
3546 }
3547 
3548 int RenderLayer::scrollWidth() const
3549 {
3550     ASSERT(renderBox());
3551     if (m_scrollDimensionsDirty)
3552         const_cast&lt;RenderLayer*&gt;(this)-&gt;computeScrollDimensions();
3553     // FIXME: This should use snappedIntSize() instead with absolute coordinates.
3554     return m_scrollSize.width();
3555 }
3556 
3557 int RenderLayer::scrollHeight() const
3558 {
3559     ASSERT(renderBox());
3560     if (m_scrollDimensionsDirty)
3561         const_cast&lt;RenderLayer*&gt;(this)-&gt;computeScrollDimensions();
3562     // FIXME: This should use snappedIntSize() instead with absolute coordinates.
3563     return m_scrollSize.height();
3564 }
3565 
3566 LayoutUnit RenderLayer::overflowTop() const
3567 {
3568     RenderBox* box = renderBox();
3569     LayoutRect overflowRect(box-&gt;layoutOverflowRect());
3570     box-&gt;flipForWritingMode(overflowRect);
3571     return overflowRect.y();
3572 }
3573 
3574 LayoutUnit RenderLayer::overflowBottom() const
3575 {
3576     RenderBox* box = renderBox();
3577     LayoutRect overflowRect(box-&gt;layoutOverflowRect());
3578     box-&gt;flipForWritingMode(overflowRect);
3579     return overflowRect.maxY();
3580 }
3581 
3582 LayoutUnit RenderLayer::overflowLeft() const
3583 {
3584     RenderBox* box = renderBox();
3585     LayoutRect overflowRect(box-&gt;layoutOverflowRect());
3586     box-&gt;flipForWritingMode(overflowRect);
3587     return overflowRect.x();
3588 }
3589 
3590 LayoutUnit RenderLayer::overflowRight() const
3591 {
3592     RenderBox* box = renderBox();
3593     LayoutRect overflowRect(box-&gt;layoutOverflowRect());
3594     box-&gt;flipForWritingMode(overflowRect);
3595     return overflowRect.maxX();
3596 }
3597 
3598 void RenderLayer::computeScrollDimensions()
3599 {
3600     RenderBox* box = renderBox();
3601     ASSERT(box);
3602 
3603     m_scrollDimensionsDirty = false;
3604 
3605     m_scrollSize.setWidth(roundToInt(overflowRight() - overflowLeft()));
3606     m_scrollSize.setHeight(roundToInt(overflowBottom() - overflowTop()));
3607 
3608     int scrollableLeftOverflow = roundToInt(overflowLeft() - box-&gt;borderLeft());
3609     if (shouldPlaceBlockDirectionScrollbarOnLeft())
3610         scrollableLeftOverflow -= verticalScrollbarWidth();
3611     int scrollableTopOverflow = roundToInt(overflowTop() - box-&gt;borderTop());
3612     setScrollOrigin(IntPoint(-scrollableLeftOverflow, -scrollableTopOverflow));
<a name="72" id="anc72"></a><span class="line-added">3613 </span>
<span class="line-added">3614     m_hasCompositedScrollableOverflow = canUseCompositedScrolling() &amp;&amp; (hasScrollableHorizontalOverflow() || hasScrollableVerticalOverflow());</span>
3615 }
3616 
3617 bool RenderLayer::hasScrollableHorizontalOverflow() const
3618 {
3619     return hasHorizontalOverflow() &amp;&amp; renderBox()-&gt;scrollsOverflowX();
3620 }
3621 
3622 bool RenderLayer::hasScrollableVerticalOverflow() const
3623 {
3624     return hasVerticalOverflow() &amp;&amp; renderBox()-&gt;scrollsOverflowY();
3625 }
3626 
3627 bool RenderLayer::hasHorizontalOverflow() const
3628 {
3629     ASSERT(!m_scrollDimensionsDirty);
3630 
3631     return scrollWidth() &gt; roundToInt(renderBox()-&gt;clientWidth());
3632 }
3633 
3634 bool RenderLayer::hasVerticalOverflow() const
3635 {
3636     ASSERT(!m_scrollDimensionsDirty);
3637 
3638     return scrollHeight() &gt; roundToInt(renderBox()-&gt;clientHeight());
3639 }
3640 
3641 static bool styleRequiresScrollbar(const RenderStyle&amp; style, ScrollbarOrientation axis)
3642 {
3643     Overflow overflow = axis == ScrollbarOrientation::HorizontalScrollbar ? style.overflowX() : style.overflowY();
3644     bool overflowScrollActsLikeAuto = overflow == Overflow::Scroll &amp;&amp; !style.hasPseudoStyle(PseudoId::Scrollbar) &amp;&amp; ScrollbarTheme::theme().usesOverlayScrollbars();
3645     return overflow == Overflow::Scroll &amp;&amp; !overflowScrollActsLikeAuto;
3646 }
3647 
3648 static bool styleDefinesAutomaticScrollbar(const RenderStyle&amp; style, ScrollbarOrientation axis)
3649 {
3650     Overflow overflow = axis == ScrollbarOrientation::HorizontalScrollbar ? style.overflowX() : style.overflowY();
3651     bool overflowScrollActsLikeAuto = overflow == Overflow::Scroll &amp;&amp; !style.hasPseudoStyle(PseudoId::Scrollbar) &amp;&amp; ScrollbarTheme::theme().usesOverlayScrollbars();
3652     return overflow == Overflow::Auto || overflowScrollActsLikeAuto;
3653 }
3654 
3655 void RenderLayer::updateScrollbarsAfterLayout()
3656 {
3657     RenderBox* box = renderBox();
3658     ASSERT(box);
3659 
3660     // List box parts handle the scrollbars by themselves so we have nothing to do.
3661     if (box-&gt;style().appearance() == ListboxPart)
3662         return;
3663 
3664     bool hasHorizontalOverflow = this-&gt;hasHorizontalOverflow();
3665     bool hasVerticalOverflow = this-&gt;hasVerticalOverflow();
3666 
3667     // If overflow requires a scrollbar, then we just need to enable or disable.
3668     if (m_hBar &amp;&amp; styleRequiresScrollbar(renderer().style(), HorizontalScrollbar))
3669         m_hBar-&gt;setEnabled(hasHorizontalOverflow);
3670     if (m_vBar &amp;&amp; styleRequiresScrollbar(renderer().style(), VerticalScrollbar))
3671         m_vBar-&gt;setEnabled(hasVerticalOverflow);
3672 
3673     // Scrollbars with auto behavior may need to lay out again if scrollbars got added or removed.
3674     bool autoHorizontalScrollBarChanged = box-&gt;hasHorizontalScrollbarWithAutoBehavior() &amp;&amp; (hasHorizontalScrollbar() != hasHorizontalOverflow);
3675     bool autoVerticalScrollBarChanged = box-&gt;hasVerticalScrollbarWithAutoBehavior() &amp;&amp; (hasVerticalScrollbar() != hasVerticalOverflow);
3676 
3677     if (autoHorizontalScrollBarChanged || autoVerticalScrollBarChanged) {
3678         if (box-&gt;hasHorizontalScrollbarWithAutoBehavior())
3679             setHasHorizontalScrollbar(hasHorizontalOverflow);
3680         if (box-&gt;hasVerticalScrollbarWithAutoBehavior())
3681             setHasVerticalScrollbar(hasVerticalOverflow);
3682 
3683         updateSelfPaintingLayer();
3684 
<a name="73" id="anc73"></a>
3685         renderer().repaint();
3686 
3687         if (renderer().style().overflowX() == Overflow::Auto || renderer().style().overflowY() == Overflow::Auto) {
3688             if (!m_inOverflowRelayout) {
3689                 m_inOverflowRelayout = true;
3690                 renderer().setNeedsLayout(MarkOnlyThis);
3691                 if (is&lt;RenderBlock&gt;(renderer())) {
3692                     RenderBlock&amp; block = downcast&lt;RenderBlock&gt;(renderer());
3693                     block.scrollbarsChanged(autoHorizontalScrollBarChanged, autoVerticalScrollBarChanged);
3694                     block.layoutBlock(true);
3695                 } else
3696                     renderer().layout();
3697                 m_inOverflowRelayout = false;
3698             }
3699         }
3700 
3701         RenderObject* parent = renderer().parent();
3702         if (parent &amp;&amp; parent-&gt;isFlexibleBox() &amp;&amp; renderer().isBox())
3703             downcast&lt;RenderFlexibleBox&gt;(parent)-&gt;clearCachedMainSizeForChild(*renderBox());
3704     }
3705 
3706     // Set up the range (and page step/line step).
3707     if (m_hBar) {
3708         int clientWidth = roundToInt(box-&gt;clientWidth());
3709         int pageStep = Scrollbar::pageStep(clientWidth);
3710         m_hBar-&gt;setSteps(Scrollbar::pixelsPerLineStep(), pageStep);
3711         m_hBar-&gt;setProportion(clientWidth, m_scrollSize.width());
3712     }
3713     if (m_vBar) {
3714         int clientHeight = roundToInt(box-&gt;clientHeight());
3715         int pageStep = Scrollbar::pageStep(clientHeight);
3716         m_vBar-&gt;setSteps(Scrollbar::pixelsPerLineStep(), pageStep);
3717         m_vBar-&gt;setProportion(clientHeight, m_scrollSize.height());
3718     }
3719 
3720     updateScrollableAreaSet(hasScrollableHorizontalOverflow() || hasScrollableVerticalOverflow());
3721 }
3722 
3723 // This is called from layout code (before updateLayerPositions).
3724 void RenderLayer::updateScrollInfoAfterLayout()
3725 {
3726     RenderBox* box = renderBox();
3727     if (!box)
3728         return;
3729 
3730     m_scrollDimensionsDirty = true;
3731     ScrollOffset originalScrollOffset = scrollOffset();
3732 
3733     computeScrollDimensions();
3734 
3735 #if ENABLE(CSS_SCROLL_SNAP)
3736     // FIXME: Ensure that offsets are also updated in case of programmatic style changes.
3737     // https://bugs.webkit.org/show_bug.cgi?id=135964
3738     updateSnapOffsets();
3739 #endif
3740 
3741     if (!box-&gt;isHTMLMarquee() &amp;&amp; !isRubberBandInProgress()) {
3742         // Layout may cause us to be at an invalid scroll position. In this case we need
3743         // to pull our scroll offsets back to the max (or push them up to the min).
3744         ScrollOffset clampedScrollOffset = clampScrollOffset(scrollOffset());
3745 #if PLATFORM(IOS_FAMILY)
3746         // FIXME: This looks wrong. The caret adjust mode should only be enabled on editing related entry points.
3747         // This code was added to fix an issue where the text insertion point would always be drawn on the right edge
3748         // of a text field whose content overflowed its bounds. See &lt;rdar://problem/15579797&gt; for more details.
3749         setAdjustForIOSCaretWhenScrolling(true);
3750 #endif
3751         if (clampedScrollOffset != scrollOffset())
3752             scrollToOffset(clampedScrollOffset);
3753 
3754 #if PLATFORM(IOS_FAMILY)
3755         setAdjustForIOSCaretWhenScrolling(false);
3756 #endif
3757     }
3758 
3759     updateScrollbarsAfterLayout();
3760 
3761     if (originalScrollOffset != scrollOffset())
3762         scrollToOffsetWithoutAnimation(IntPoint(scrollOffset()));
3763 
3764     if (isComposited()) {
3765         setNeedsCompositingGeometryUpdate();
3766         setNeedsCompositingConfigurationUpdate();
3767     }
3768 
<a name="74" id="anc74"></a>
3769     if (canUseCompositedScrolling())
3770         setNeedsPostLayoutCompositingUpdate();
<a name="75" id="anc75"></a>
3771 
3772     updateScrollSnapState();
3773 }
3774 
3775 bool RenderLayer::overflowControlsIntersectRect(const IntRect&amp; localRect) const
3776 {
3777     const IntRect borderBox = snappedIntRect(renderBox()-&gt;borderBoxRect());
3778 
3779     if (rectForHorizontalScrollbar(borderBox).intersects(localRect))
3780         return true;
3781 
3782     if (rectForVerticalScrollbar(borderBox).intersects(localRect))
3783         return true;
3784 
3785     if (scrollCornerRect().intersects(localRect))
3786         return true;
3787 
3788     if (resizerCornerRect(*this, borderBox).intersects(localRect))
3789         return true;
3790 
3791     return false;
3792 }
3793 
3794 bool RenderLayer::showsOverflowControls() const
3795 {
3796 #if PLATFORM(IOS_FAMILY)
3797     // On iOS, the scrollbars are made in the UI process.
3798     return !canUseCompositedScrolling();
3799 #endif
3800 
3801     return true;
3802 }
3803 
3804 void RenderLayer::paintOverflowControls(GraphicsContext&amp; context, const IntPoint&amp; paintOffset, const IntRect&amp; damageRect, bool paintingOverlayControls)
3805 {
3806     // Don&#39;t do anything if we have no overflow.
3807     if (!renderer().hasOverflowClip())
3808         return;
3809 
3810     if (!showsOverflowControls())
3811         return;
3812 
3813     // Overlay scrollbars paint in a second pass through the layer tree so that they will paint
3814     // on top of everything else. If this is the normal painting pass, paintingOverlayControls
3815     // will be false, and we should just tell the root layer that there are overlay scrollbars
3816     // that need to be painted. That will cause the second pass through the layer tree to run,
3817     // and we&#39;ll paint the scrollbars then. In the meantime, cache tx and ty so that the
3818     // second pass doesn&#39;t need to re-enter the RenderTree to get it right.
3819     if (hasOverlayScrollbars() &amp;&amp; !paintingOverlayControls) {
3820         m_cachedOverlayScrollbarOffset = paintOffset;
3821 
3822         // It&#39;s not necessary to do the second pass if the scrollbars paint into layers.
3823         if ((m_hBar &amp;&amp; layerForHorizontalScrollbar()) || (m_vBar &amp;&amp; layerForVerticalScrollbar()))
3824             return;
3825         IntRect localDamgeRect = damageRect;
3826         localDamgeRect.moveBy(-paintOffset);
3827         if (!overflowControlsIntersectRect(localDamgeRect))
3828             return;
3829 
3830         RenderLayer* paintingRoot = enclosingCompositingLayer();
3831         if (!paintingRoot)
3832             paintingRoot = renderer().view().layer();
3833 
3834         paintingRoot-&gt;setContainsDirtyOverlayScrollbars(true);
3835         return;
3836     }
3837 
3838     // This check is required to avoid painting custom CSS scrollbars twice.
3839     if (paintingOverlayControls &amp;&amp; !hasOverlayScrollbars())
3840         return;
3841 
3842     IntPoint adjustedPaintOffset = paintOffset;
3843     if (paintingOverlayControls)
3844         adjustedPaintOffset = m_cachedOverlayScrollbarOffset;
3845 
3846     // Move the scrollbar widgets if necessary.  We normally move and resize widgets during layout, but sometimes
3847     // widgets can move without layout occurring (most notably when you scroll a document that
3848     // contains fixed positioned elements).
3849     positionOverflowControls(toIntSize(adjustedPaintOffset));
3850 
3851     // Now that we&#39;re sure the scrollbars are in the right place, paint them.
3852     if (m_hBar &amp;&amp; !layerForHorizontalScrollbar())
3853         m_hBar-&gt;paint(context, damageRect);
3854     if (m_vBar &amp;&amp; !layerForVerticalScrollbar())
3855         m_vBar-&gt;paint(context, damageRect);
3856 
3857     if (layerForScrollCorner())
3858         return;
3859 
3860     // We fill our scroll corner with white if we have a scrollbar that doesn&#39;t run all the way up to the
3861     // edge of the box.
3862     paintScrollCorner(context, adjustedPaintOffset, damageRect);
3863 
3864     // Paint our resizer last, since it sits on top of the scroll corner.
3865     paintResizer(context, adjustedPaintOffset, damageRect);
3866 }
3867 
3868 void RenderLayer::paintScrollCorner(GraphicsContext&amp; context, const IntPoint&amp; paintOffset, const IntRect&amp; damageRect)
3869 {
3870     IntRect absRect = scrollCornerRect();
3871     absRect.moveBy(paintOffset);
3872     if (!absRect.intersects(damageRect))
3873         return;
3874 
3875     if (context.invalidatingControlTints()) {
3876         updateScrollCornerStyle();
3877         return;
3878     }
3879 
3880     if (m_scrollCorner) {
3881         m_scrollCorner-&gt;paintIntoRect(context, paintOffset, absRect);
3882         return;
3883     }
3884 
3885     // We don&#39;t want to paint a corner if we have overlay scrollbars, since we need
3886     // to see what is behind it.
3887     if (!hasOverlayScrollbars())
3888         ScrollbarTheme::theme().paintScrollCorner(context, absRect);
3889 }
3890 
3891 void RenderLayer::drawPlatformResizerImage(GraphicsContext&amp; context, const LayoutRect&amp; resizerCornerRect)
3892 {
3893     RefPtr&lt;Image&gt; resizeCornerImage;
3894     FloatSize cornerResizerSize;
3895     if (renderer().document().deviceScaleFactor() &gt;= 2) {
3896         static NeverDestroyed&lt;Image*&gt; resizeCornerImageHiRes(&amp;Image::loadPlatformResource(&quot;textAreaResizeCorner@2x&quot;).leakRef());
3897         resizeCornerImage = resizeCornerImageHiRes;
3898         cornerResizerSize = resizeCornerImage-&gt;size();
3899         cornerResizerSize.scale(0.5f);
3900     } else {
3901         static NeverDestroyed&lt;Image*&gt; resizeCornerImageLoRes(&amp;Image::loadPlatformResource(&quot;textAreaResizeCorner&quot;).leakRef());
3902         resizeCornerImage = resizeCornerImageLoRes;
3903         cornerResizerSize = resizeCornerImage-&gt;size();
3904     }
3905 
3906     if (shouldPlaceBlockDirectionScrollbarOnLeft()) {
3907         context.save();
3908         context.translate(resizerCornerRect.x() + cornerResizerSize.width(), resizerCornerRect.y() + resizerCornerRect.height() - cornerResizerSize.height());
3909         context.scale(FloatSize(-1.0, 1.0));
3910         if (resizeCornerImage)
3911             context.drawImage(*resizeCornerImage, FloatRect(FloatPoint(), cornerResizerSize));
3912         context.restore();
3913         return;
3914     }
3915 
3916     if (!resizeCornerImage)
3917         return;
3918     FloatRect imageRect = snapRectToDevicePixels(LayoutRect(resizerCornerRect.maxXMaxYCorner() - cornerResizerSize, cornerResizerSize), renderer().document().deviceScaleFactor());
3919     context.drawImage(*resizeCornerImage, imageRect);
3920 }
3921 
3922 void RenderLayer::paintResizer(GraphicsContext&amp; context, const LayoutPoint&amp; paintOffset, const LayoutRect&amp; damageRect)
3923 {
3924     if (renderer().style().resize() == Resize::None)
3925         return;
3926 
3927     RenderBox* box = renderBox();
3928     ASSERT(box);
3929 
3930     LayoutRect absRect = resizerCornerRect(*this, box-&gt;borderBoxRect());
3931     absRect.moveBy(paintOffset);
3932     if (!absRect.intersects(damageRect))
3933         return;
3934 
3935     if (context.invalidatingControlTints()) {
3936         updateResizerStyle();
3937         return;
3938     }
3939 
3940     if (m_resizer) {
3941         m_resizer-&gt;paintIntoRect(context, paintOffset, absRect);
3942         return;
3943     }
3944 
3945     drawPlatformResizerImage(context, absRect);
3946 
3947     // Draw a frame around the resizer (1px grey line) if there are any scrollbars present.
3948     // Clipping will exclude the right and bottom edges of this frame.
3949     if (!hasOverlayScrollbars() &amp;&amp; (m_vBar || m_hBar)) {
3950         GraphicsContextStateSaver stateSaver(context);
3951         context.clip(absRect);
3952         LayoutRect largerCorner = absRect;
3953         largerCorner.setSize(LayoutSize(largerCorner.width() + 1_lu, largerCorner.height() + 1_lu));
3954         context.setStrokeColor(Color(makeRGB(217, 217, 217)));
3955         context.setStrokeThickness(1.0f);
3956         context.setFillColor(Color::transparent);
3957         context.drawRect(snappedIntRect(largerCorner));
3958     }
3959 }
3960 
3961 bool RenderLayer::isPointInResizeControl(const IntPoint&amp; absolutePoint) const
3962 {
3963     if (!canResize())
3964         return false;
3965 
3966     RenderBox* box = renderBox();
3967     ASSERT(box);
3968 
3969     IntPoint localPoint = roundedIntPoint(absoluteToContents(absolutePoint));
3970 
3971     IntRect localBounds(IntPoint(), snappedIntRect(box-&gt;frameRect()).size());
3972     return resizerCornerRect(*this, localBounds).contains(localPoint);
3973 }
3974 
3975 bool RenderLayer::hitTestOverflowControls(HitTestResult&amp; result, const IntPoint&amp; localPoint)
3976 {
3977     if (!m_hBar &amp;&amp; !m_vBar &amp;&amp; !canResize())
3978         return false;
3979 
3980     RenderBox* box = renderBox();
3981     ASSERT(box);
3982 
3983     IntRect resizeControlRect;
3984     if (renderer().style().resize() != Resize::None) {
3985         resizeControlRect = snappedIntRect(resizerCornerRect(*this, box-&gt;borderBoxRect()));
3986         if (resizeControlRect.contains(localPoint))
3987             return true;
3988     }
3989 
3990     int resizeControlSize = std::max(resizeControlRect.height(), 0);
3991 
3992     // FIXME: We should hit test the m_scrollCorner and pass it back through the result.
3993 
3994     if (m_vBar &amp;&amp; m_vBar-&gt;shouldParticipateInHitTesting()) {
3995         LayoutRect vBarRect(verticalScrollbarStart(0, box-&gt;width()),
3996                             box-&gt;borderTop(),
3997                             m_vBar-&gt;width(),
3998                             box-&gt;height() - (box-&gt;borderTop() + box-&gt;borderBottom()) - (m_hBar ? m_hBar-&gt;height() : resizeControlSize));
3999         if (vBarRect.contains(localPoint)) {
4000             result.setScrollbar(m_vBar.get());
4001             return true;
4002         }
4003     }
4004 
4005     resizeControlSize = std::max(resizeControlRect.width(), 0);
4006     if (m_hBar &amp;&amp; m_hBar-&gt;shouldParticipateInHitTesting()) {
4007         LayoutRect hBarRect(horizontalScrollbarStart(0),
4008                             box-&gt;height() - box-&gt;borderBottom() - m_hBar-&gt;height(),
4009                             box-&gt;width() - (box-&gt;borderLeft() + box-&gt;borderRight()) - (m_vBar ? m_vBar-&gt;width() : resizeControlSize),
4010                             m_hBar-&gt;height());
4011         if (hBarRect.contains(localPoint)) {
4012             result.setScrollbar(m_hBar.get());
4013             return true;
4014         }
4015     }
4016 
4017     return false;
4018 }
4019 
4020 bool RenderLayer::scroll(ScrollDirection direction, ScrollGranularity granularity, float multiplier)
4021 {
4022     return ScrollableArea::scroll(direction, granularity, multiplier);
4023 }
4024 
4025 void RenderLayer::paint(GraphicsContext&amp; context, const LayoutRect&amp; damageRect, const LayoutSize&amp; subpixelOffset, OptionSet&lt;PaintBehavior&gt; paintBehavior, RenderObject* subtreePaintRoot, OptionSet&lt;PaintLayerFlag&gt; paintFlags, SecurityOriginPaintPolicy paintPolicy)
4026 {
4027     OverlapTestRequestMap overlapTestRequests;
4028 
4029     LayerPaintingInfo paintingInfo(this, enclosingIntRect(damageRect), paintBehavior, subpixelOffset, subtreePaintRoot, &amp;overlapTestRequests, paintPolicy == SecurityOriginPaintPolicy::AccessibleOriginOnly);
4030     paintLayer(context, paintingInfo, paintFlags);
4031 
4032     for (auto&amp; widget : overlapTestRequests.keys())
4033         widget-&gt;setOverlapTestResult(false);
4034 }
4035 
4036 void RenderLayer::paintOverlayScrollbars(GraphicsContext&amp; context, const LayoutRect&amp; damageRect, OptionSet&lt;PaintBehavior&gt; paintBehavior, RenderObject* subtreePaintRoot)
4037 {
4038     if (!m_containsDirtyOverlayScrollbars)
4039         return;
4040 
4041     LayerPaintingInfo paintingInfo(this, enclosingIntRect(damageRect), paintBehavior, LayoutSize(), subtreePaintRoot);
4042     paintLayer(context, paintingInfo, PaintLayerPaintingOverlayScrollbars);
4043 
4044     m_containsDirtyOverlayScrollbars = false;
4045 }
4046 
<a name="76" id="anc76"></a>











4047 void RenderLayer::clipToRect(GraphicsContext&amp; context, const LayerPaintingInfo&amp; paintingInfo, const ClipRect&amp; clipRect, BorderRadiusClippingRule rule)
4048 {
4049     float deviceScaleFactor = renderer().document().deviceScaleFactor();
4050     bool needsClipping = !clipRect.isInfinite() &amp;&amp; clipRect.rect() != paintingInfo.paintDirtyRect;
4051     if (needsClipping || clipRect.affectedByRadius())
4052         context.save();
4053 
4054     if (needsClipping) {
4055         LayoutRect adjustedClipRect = clipRect.rect();
4056         adjustedClipRect.move(paintingInfo.subpixelOffset);
<a name="77" id="anc77"></a><span class="line-modified">4057         auto snappedClipRect = snapRectToDevicePixels(adjustedClipRect, deviceScaleFactor);</span>
<span class="line-added">4058         context.clip(snappedClipRect);</span>
<span class="line-added">4059 </span>
<span class="line-added">4060         if (paintingInfo.eventRegionContext)</span>
<span class="line-added">4061             paintingInfo.eventRegionContext-&gt;pushClip(enclosingIntRect(snappedClipRect));</span>
4062     }
4063 
4064     if (clipRect.affectedByRadius()) {
4065         // If the clip rect has been tainted by a border radius, then we have to walk up our layer chain applying the clips from
4066         // any layers with overflow. The condition for being able to apply these clips is that the overflow object be in our
4067         // containing block chain so we check that also.
4068         for (RenderLayer* layer = rule == IncludeSelfForBorderRadius ? this : parent(); layer; layer = layer-&gt;parent()) {
<a name="78" id="anc78"></a><span class="line-modified">4069             if (layer-&gt;renderer().hasOverflowClip() &amp;&amp; layer-&gt;renderer().style().hasBorderRadius() &amp;&amp; ancestorLayerIsInContainingBlockChain(*layer)) {</span>
4070                 LayoutRect adjustedClipRect = LayoutRect(toLayoutPoint(layer-&gt;offsetFromAncestor(paintingInfo.rootLayer, AdjustForColumns)), layer-&gt;size());
4071                 adjustedClipRect.move(paintingInfo.subpixelOffset);
4072                 FloatRoundedRect roundedRect = layer-&gt;renderer().style().getRoundedInnerBorderFor(adjustedClipRect).pixelSnappedRoundedRectForPainting(deviceScaleFactor);
4073                 if (roundedRect.intersectionIsRectangular(paintingInfo.paintDirtyRect))
4074                     context.clip(snapRectToDevicePixels(intersection(paintingInfo.paintDirtyRect, adjustedClipRect), deviceScaleFactor));
4075                 else
4076                     context.clipRoundedRect(roundedRect);
4077             }
4078 
4079             if (layer == paintingInfo.rootLayer)
4080                 break;
4081         }
4082     }
4083 }
4084 
4085 void RenderLayer::restoreClip(GraphicsContext&amp; context, const LayerPaintingInfo&amp; paintingInfo, const ClipRect&amp; clipRect)
4086 {
<a name="79" id="anc79"></a><span class="line-modified">4087     if ((!clipRect.isInfinite() &amp;&amp; clipRect.rect() != paintingInfo.paintDirtyRect) || clipRect.affectedByRadius()) {</span>
4088         context.restore();
<a name="80" id="anc80"></a><span class="line-added">4089 </span>
<span class="line-added">4090         if (paintingInfo.eventRegionContext)</span>
<span class="line-added">4091             paintingInfo.eventRegionContext-&gt;popClip();</span>
<span class="line-added">4092     }</span>
4093 }
4094 
4095 static void performOverlapTests(OverlapTestRequestMap&amp; overlapTestRequests, const RenderLayer* rootLayer, const RenderLayer* layer)
4096 {
<a name="81" id="anc81"></a><span class="line-added">4097     if (overlapTestRequests.isEmpty())</span>
<span class="line-added">4098         return;</span>
<span class="line-added">4099 </span>
4100     Vector&lt;OverlapTestRequestClient*&gt; overlappedRequestClients;
4101     LayoutRect boundingBox = layer-&gt;boundingBox(rootLayer, layer-&gt;offsetFromAncestor(rootLayer));
4102     for (auto&amp; request : overlapTestRequests) {
4103         if (!boundingBox.intersects(request.value))
4104             continue;
4105 
4106         request.key-&gt;setOverlapTestResult(true);
4107         overlappedRequestClients.append(request.key);
4108     }
4109     for (auto* client : overlappedRequestClients)
4110         overlapTestRequests.remove(client);
4111 }
4112 
4113 static inline bool shouldDoSoftwarePaint(const RenderLayer* layer, bool paintingReflection)
4114 {
4115     return paintingReflection &amp;&amp; !layer-&gt;has3DTransform();
4116 }
4117 
4118 static inline bool shouldSuppressPaintingLayer(RenderLayer* layer)
4119 {
4120     if (layer-&gt;renderer().style().isNotFinal() &amp;&amp; !layer-&gt;isRenderViewLayer() &amp;&amp; !layer-&gt;renderer().isDocumentElementRenderer())
4121         return true;
4122 
4123     // Avoid painting all layers if the document is in a state where visual updates aren&#39;t allowed.
4124     // A full repaint will occur in Document::setVisualUpdatesAllowed(bool) if painting is suppressed here.
4125     if (!layer-&gt;renderer().document().visualUpdatesAllowed())
4126         return true;
4127 
4128     return false;
4129 }
4130 
4131 static inline bool paintForFixedRootBackground(const RenderLayer* layer, OptionSet&lt;RenderLayer::PaintLayerFlag&gt; paintFlags)
4132 {
4133     return layer-&gt;renderer().isDocumentElementRenderer() &amp;&amp; (paintFlags &amp; RenderLayer::PaintLayerPaintingRootBackgroundOnly);
4134 }
4135 
4136 void RenderLayer::paintLayer(GraphicsContext&amp; context, const LayerPaintingInfo&amp; paintingInfo, OptionSet&lt;PaintLayerFlag&gt; paintFlags)
4137 {
<a name="82" id="anc82"></a><span class="line-modified">4138     auto shouldContinuePaint = [&amp;] () {</span>
<span class="line-modified">4139         return backing()-&gt;paintsIntoWindow()</span>
<span class="line-modified">4140             || backing()-&gt;paintsIntoCompositedAncestor()</span>
<span class="line-modified">4141             || shouldDoSoftwarePaint(this, paintFlags.contains(PaintLayerPaintingReflection))</span>
<span class="line-modified">4142             || paintForFixedRootBackground(this, paintFlags);</span>
<span class="line-modified">4143     };</span>
<span class="line-modified">4144 </span>
<span class="line-modified">4145     auto paintsIntoDifferentCompositedDestination = [&amp;]() {</span>
<span class="line-modified">4146         if (paintsIntoProvidedBacking())</span>
<span class="line-modified">4147             return true;</span>
<span class="line-added">4148 </span>
<span class="line-added">4149         if (isComposited() &amp;&amp; !shouldContinuePaint())</span>
<span class="line-added">4150             return true;</span>
<span class="line-added">4151 </span>
<span class="line-added">4152         return false;</span>
<span class="line-added">4153     };</span>
<span class="line-added">4154 </span>
<span class="line-added">4155     if (paintsIntoDifferentCompositedDestination()) {</span>
<span class="line-added">4156         if (!context.performingPaintInvalidation() &amp;&amp; !(paintingInfo.paintBehavior &amp; PaintBehavior::FlattenCompositingLayers))</span>
4157             return;
<a name="83" id="anc83"></a><span class="line-modified">4158 </span>
<span class="line-modified">4159         paintFlags.add(PaintLayerTemporaryClipRects);</span>
<span class="line-added">4160     }</span>
<span class="line-added">4161 </span>
<span class="line-added">4162     if (viewportConstrainedNotCompositedReason() == NotCompositedForBoundsOutOfView) {</span>
4163         // Don&#39;t paint out-of-view viewport constrained layers (when doing prepainting) because they will never be visible
4164         // unless their position or viewport size is changed.
4165         ASSERT(renderer().isFixedPositioned());
4166         return;
4167     }
4168 
<a name="84" id="anc84"></a><span class="line-added">4169     paintLayerWithEffects(context, paintingInfo, paintFlags);</span>
<span class="line-added">4170 }</span>
<span class="line-added">4171 </span>
<span class="line-added">4172 void RenderLayer::paintLayerWithEffects(GraphicsContext&amp; context, const LayerPaintingInfo&amp; paintingInfo, OptionSet&lt;PaintLayerFlag&gt; paintFlags)</span>
<span class="line-added">4173 {</span>
4174     // Non self-painting leaf layers don&#39;t need to be painted as their renderer() should properly paint itself.
4175     if (!isSelfPaintingLayer() &amp;&amp; !hasSelfPaintingLayerDescendant())
4176         return;
4177 
4178     if (shouldSuppressPaintingLayer(this))
4179         return;
4180 
4181     // If this layer is totally invisible then there is nothing to paint.
4182     if (!renderer().opacity())
4183         return;
4184 
4185     if (paintsWithTransparency(paintingInfo.paintBehavior))
4186         paintFlags.add(PaintLayerHaveTransparency);
4187 
4188     // PaintLayerAppliedTransform is used in RenderReplica, to avoid applying the transform twice.
4189     if (paintsWithTransform(paintingInfo.paintBehavior) &amp;&amp; !(paintFlags &amp; PaintLayerAppliedTransform)) {
4190         TransformationMatrix layerTransform = renderableTransform(paintingInfo.paintBehavior);
4191         // If the transform can&#39;t be inverted, then don&#39;t paint anything.
4192         if (!layerTransform.isInvertible())
4193             return;
4194 
4195         // If we have a transparency layer enclosing us and we are the root of a transform, then we need to establish the transparency
4196         // layer from the parent now, assuming there is a parent
4197         if (paintFlags &amp; PaintLayerHaveTransparency) {
4198             if (parent())
4199                 parent()-&gt;beginTransparencyLayers(context, paintingInfo, paintingInfo.paintDirtyRect);
4200             else
4201                 beginTransparencyLayers(context, paintingInfo, paintingInfo.paintDirtyRect);
4202         }
4203 
4204         if (enclosingPaginationLayer(ExcludeCompositedPaginatedLayers)) {
4205             paintTransformedLayerIntoFragments(context, paintingInfo, paintFlags);
4206             return;
4207         }
4208 
4209         // Make sure the parent&#39;s clip rects have been calculated.
4210         ClipRect clipRect = paintingInfo.paintDirtyRect;
4211         if (parent()) {
4212             ClipRectsContext clipRectsContext(paintingInfo.rootLayer, (paintFlags &amp; PaintLayerTemporaryClipRects) ? TemporaryClipRects : PaintingClipRects,
4213                 IgnoreOverlayScrollbarSize, (paintFlags &amp; PaintLayerPaintingOverflowContents) ? IgnoreOverflowClip : RespectOverflowClip);
4214             clipRect = backgroundClipRect(clipRectsContext);
4215             clipRect.intersect(paintingInfo.paintDirtyRect);
4216 
4217             // Push the parent coordinate space&#39;s clip.
4218             parent()-&gt;clipToRect(context, paintingInfo, clipRect);
4219         }
4220 
4221         paintLayerByApplyingTransform(context, paintingInfo, paintFlags);
4222 
4223         // Restore the clip.
4224         if (parent())
4225             parent()-&gt;restoreClip(context, paintingInfo, clipRect);
4226 
4227         return;
4228     }
4229 
4230     paintLayerContentsAndReflection(context, paintingInfo, paintFlags);
4231 }
4232 
4233 void RenderLayer::paintLayerContentsAndReflection(GraphicsContext&amp; context, const LayerPaintingInfo&amp; paintingInfo, OptionSet&lt;PaintLayerFlag&gt; paintFlags)
4234 {
4235     ASSERT(isSelfPaintingLayer() || hasSelfPaintingLayerDescendant());
4236 
4237     auto localPaintFlags = paintFlags - PaintLayerAppliedTransform;
4238 
4239     // Paint the reflection first if we have one.
4240     if (m_reflection &amp;&amp; !m_paintingInsideReflection) {
4241         // Mark that we are now inside replica painting.
4242         m_paintingInsideReflection = true;
4243         reflectionLayer()-&gt;paintLayer(context, paintingInfo, localPaintFlags | PaintLayerPaintingReflection);
4244         m_paintingInsideReflection = false;
4245     }
4246 
4247     localPaintFlags.add(paintLayerPaintingCompositingAllPhasesFlags());
4248     paintLayerContents(context, paintingInfo, localPaintFlags);
4249 }
4250 
4251 bool RenderLayer::setupFontSubpixelQuantization(GraphicsContext&amp; context, bool&amp; didQuantizeFonts)
4252 {
4253     if (context.paintingDisabled())
4254         return false;
4255 
4256     bool scrollingOnMainThread = true;
4257 #if ENABLE(ASYNC_SCROLLING)
4258     if (ScrollingCoordinator* scrollingCoordinator = page().scrollingCoordinator())
4259         scrollingOnMainThread = scrollingCoordinator-&gt;shouldUpdateScrollLayerPositionSynchronously(renderer().view().frameView());
4260 #endif
4261 
4262     // FIXME: We shouldn&#39;t have to disable subpixel quantization for overflow clips or subframes once we scroll those
4263     // things on the scrolling thread.
4264     bool contentsScrollByPainting = (renderer().hasOverflowClip() &amp;&amp; !usesCompositedScrolling()) || (renderer().frame().ownerElement());
4265     bool isZooming = !page().chrome().client().hasStablePageScaleFactor();
4266     if (scrollingOnMainThread || contentsScrollByPainting || isZooming) {
4267         didQuantizeFonts = context.shouldSubpixelQuantizeFonts();
4268         context.setShouldSubpixelQuantizeFonts(false);
4269         return true;
4270     }
4271     return false;
4272 }
4273 
4274 static inline LayoutRect computeReferenceBox(const RenderObject&amp; renderer, const CSSBoxType&amp; boxType, const LayoutSize&amp; offsetFromRoot, const LayoutRect&amp; rootRelativeBounds)
4275 {
4276     // FIXME: Support different reference boxes for inline content.
4277     // https://bugs.webkit.org/show_bug.cgi?id=129047
4278     if (!renderer.isBox())
4279         return rootRelativeBounds;
4280 
4281     LayoutRect referenceBox;
4282     const auto&amp; box = downcast&lt;RenderBox&gt;(renderer);
4283     switch (boxType) {
4284     case CSSBoxType::ContentBox:
4285     case CSSBoxType::FillBox:
4286         referenceBox = box.contentBoxRect();
4287         referenceBox.move(offsetFromRoot);
4288         break;
4289     case CSSBoxType::PaddingBox:
4290         referenceBox = box.paddingBoxRect();
4291         referenceBox.move(offsetFromRoot);
4292         break;
4293     case CSSBoxType::MarginBox:
4294         referenceBox = box.marginBoxRect();
4295         referenceBox.move(offsetFromRoot);
4296         break;
4297     // stroke-box, view-box compute to border-box for HTML elements.
4298     case CSSBoxType::StrokeBox:
4299     case CSSBoxType::ViewBox:
4300     case CSSBoxType::BorderBox:
4301     case CSSBoxType::BoxMissing:
4302         referenceBox = box.borderBoxRect();
4303         referenceBox.move(offsetFromRoot);
4304         break;
4305     }
4306 
4307     return referenceBox;
4308 }
4309 
4310 Path RenderLayer::computeClipPath(const LayoutSize&amp; offsetFromRoot, LayoutRect&amp; rootRelativeBounds, WindRule&amp; windRule) const
4311 {
4312     const RenderStyle&amp; style = renderer().style();
4313     float deviceSaleFactor = renderer().document().deviceScaleFactor();
4314 
4315     if (is&lt;ShapeClipPathOperation&gt;(*style.clipPath())) {
4316         auto&amp; clipPath = downcast&lt;ShapeClipPathOperation&gt;(*style.clipPath());
4317         FloatRect referenceBox = snapRectToDevicePixels(computeReferenceBox(renderer(), clipPath.referenceBox(), offsetFromRoot, rootRelativeBounds), deviceSaleFactor);
4318 
4319         windRule = clipPath.windRule();
4320         return clipPath.pathForReferenceRect(referenceBox);
4321     }
4322 
4323     if (is&lt;BoxClipPathOperation&gt;(*style.clipPath()) &amp;&amp; is&lt;RenderBox&gt;(renderer())) {
4324 
4325         auto&amp; clipPath = downcast&lt;BoxClipPathOperation&gt;(*style.clipPath());
4326 
4327         FloatRoundedRect shapeRect = computeRoundedRectForBoxShape(clipPath.referenceBox(), downcast&lt;RenderBox&gt;(renderer())).pixelSnappedRoundedRectForPainting(deviceSaleFactor);
4328         shapeRect.move(offsetFromRoot);
4329 
4330         windRule = WindRule::NonZero;
4331         return clipPath.pathForReferenceRect(shapeRect);
4332     }
4333 
4334     return Path();
4335 }
4336 
4337 bool RenderLayer::setupClipPath(GraphicsContext&amp; context, const LayerPaintingInfo&amp; paintingInfo, const LayoutSize&amp; offsetFromRoot, LayoutRect&amp; rootRelativeBounds, bool&amp; rootRelativeBoundsComputed)
4338 {
4339     if (!renderer().hasClipPath() || context.paintingDisabled())
4340         return false;
4341 
4342     if (!rootRelativeBoundsComputed) {
4343         rootRelativeBounds = calculateLayerBounds(paintingInfo.rootLayer, offsetFromRoot, { });
4344         rootRelativeBoundsComputed = true;
4345     }
4346 
4347     // SVG elements get clipped in SVG code.
4348     if (is&lt;RenderSVGRoot&gt;(renderer()))
4349         return false;
4350 
4351     auto&amp; style = renderer().style();
4352     LayoutSize paintingOffsetFromRoot = LayoutSize(snapSizeToDevicePixel(offsetFromRoot + paintingInfo.subpixelOffset, LayoutPoint(), renderer().document().deviceScaleFactor()));
4353     ASSERT(style.clipPath());
4354     if (is&lt;ShapeClipPathOperation&gt;(*style.clipPath()) || (is&lt;BoxClipPathOperation&gt;(*style.clipPath()) &amp;&amp; is&lt;RenderBox&gt;(renderer()))) {
4355         WindRule windRule;
4356         Path path = computeClipPath(paintingOffsetFromRoot, rootRelativeBounds, windRule);
4357         context.save();
4358         context.clipPath(path, windRule);
4359         return true;
4360     }
4361 
4362     if (style.clipPath()-&gt;type() == ClipPathOperation::Reference) {
4363         ReferenceClipPathOperation* referenceClipPathOperation = static_cast&lt;ReferenceClipPathOperation*&gt;(style.clipPath());
4364         Element* element = renderer().document().getElementById(referenceClipPathOperation-&gt;fragment());
4365         if (element &amp;&amp; element-&gt;renderer() &amp;&amp; is&lt;RenderSVGResourceClipper&gt;(element-&gt;renderer())) {
4366             context.save();
4367             float deviceSaleFactor = renderer().document().deviceScaleFactor();
4368             FloatRect referenceBox = snapRectToDevicePixels(computeReferenceBox(renderer(), CSSBoxType::ContentBox, paintingOffsetFromRoot, rootRelativeBounds), deviceSaleFactor);
4369             FloatPoint offset {referenceBox.location()};
4370             context.translate(offset);
4371             FloatRect svgReferenceBox {FloatPoint(), referenceBox.size()};
4372             downcast&lt;RenderSVGResourceClipper&gt;(*element-&gt;renderer()).applyClippingToContext(renderer(), svgReferenceBox, paintingInfo.paintDirtyRect, context);
4373             context.translate(FloatPoint(-offset.x(), -offset.y()));
4374             return true;
4375         }
4376     }
4377 
4378     return false;
4379 }
4380 
4381 RenderLayerFilters* RenderLayer::filtersForPainting(GraphicsContext&amp; context, OptionSet&lt;PaintLayerFlag&gt; paintFlags) const
4382 {
4383     if (context.paintingDisabled())
4384         return nullptr;
4385 
4386     if (paintFlags &amp; PaintLayerPaintingOverlayScrollbars)
4387         return nullptr;
4388 
4389     if (!paintsWithFilters())
4390         return nullptr;
4391 
4392     if (m_filters &amp;&amp; m_filters-&gt;filter())
4393         return m_filters.get();
4394 
4395     return nullptr;
4396 }
4397 
4398 GraphicsContext* RenderLayer::setupFilters(GraphicsContext&amp; destinationContext, LayerPaintingInfo&amp; paintingInfo, OptionSet&lt;PaintLayerFlag&gt; paintFlags, const LayoutSize&amp; offsetFromRoot, LayoutRect&amp; rootRelativeBounds, bool&amp; rootRelativeBoundsComputed)
4399 {
4400     auto* paintingFilters = filtersForPainting(destinationContext, paintFlags);
4401     if (!paintingFilters)
4402         return nullptr;
4403 
4404     LayoutRect filterRepaintRect = paintingFilters-&gt;dirtySourceRect();
4405     filterRepaintRect.move(offsetFromRoot);
4406 
4407     if (!rootRelativeBoundsComputed) {
4408         rootRelativeBounds = calculateLayerBounds(paintingInfo.rootLayer, offsetFromRoot, { });
4409         rootRelativeBoundsComputed = true;
4410     }
4411 
4412     GraphicsContext* filterContext = paintingFilters-&gt;beginFilterEffect(destinationContext, enclosingIntRect(rootRelativeBounds), enclosingIntRect(paintingInfo.paintDirtyRect), enclosingIntRect(filterRepaintRect));
4413     if (!filterContext)
4414         return nullptr;
4415 
4416     paintingInfo.paintDirtyRect = paintingFilters-&gt;repaintRect();
4417 
4418     // If the filter needs the full source image, we need to avoid using the clip rectangles.
4419     // Otherwise, if for example this layer has overflow:hidden, a drop shadow will not compute correctly.
4420     // Note that we will still apply the clipping on the final rendering of the filter.
4421     paintingInfo.clipToDirtyRect = !paintingFilters-&gt;hasFilterThatMovesPixels();
4422 
4423     paintingInfo.requireSecurityOriginAccessForWidgets = paintingFilters-&gt;hasFilterThatShouldBeRestrictedBySecurityOrigin();
4424 
4425     return filterContext;
4426 }
4427 
4428 void RenderLayer::applyFilters(GraphicsContext&amp; originalContext, const LayerPaintingInfo&amp; paintingInfo, const LayerFragments&amp; layerFragments)
4429 {
4430     // FIXME: Handle more than one fragment.
4431     ClipRect backgroundRect = layerFragments.isEmpty() ? ClipRect() : layerFragments[0].backgroundRect;
4432     clipToRect(originalContext, paintingInfo, backgroundRect);
4433     m_filters-&gt;applyFilterEffect(originalContext);
4434     restoreClip(originalContext, paintingInfo, backgroundRect);
4435 }
4436 
4437 void RenderLayer::paintLayerContents(GraphicsContext&amp; context, const LayerPaintingInfo&amp; paintingInfo, OptionSet&lt;PaintLayerFlag&gt; paintFlags)
4438 {
4439     ASSERT(isSelfPaintingLayer() || hasSelfPaintingLayerDescendant());
4440 
4441     auto localPaintFlags = paintFlags - PaintLayerAppliedTransform;
4442     bool haveTransparency = localPaintFlags.contains(PaintLayerHaveTransparency);
4443     bool isSelfPaintingLayer = this-&gt;isSelfPaintingLayer();
4444     bool isPaintingOverlayScrollbars = paintFlags.contains(PaintLayerPaintingOverlayScrollbars);
4445     bool isPaintingScrollingContent = paintFlags.contains(PaintLayerPaintingCompositingScrollingPhase);
4446     bool isPaintingCompositedForeground = paintFlags.contains(PaintLayerPaintingCompositingForegroundPhase);
4447     bool isPaintingCompositedBackground = paintFlags.contains(PaintLayerPaintingCompositingBackgroundPhase);
4448     bool isPaintingOverflowContents = paintFlags.contains(PaintLayerPaintingOverflowContents);
<a name="85" id="anc85"></a><span class="line-added">4449     bool isCollectingEventRegion = paintFlags.contains(PaintLayerCollectingEventRegion);</span>
4450     // Outline always needs to be painted even if we have no visible content. Also,
4451     // the outline is painted in the background phase during composited scrolling.
4452     // If it were painted in the foreground phase, it would move with the scrolled
4453     // content. When not composited scrolling, the outline is painted in the
4454     // foreground phase. Since scrolled contents are moved by repainting in this
4455     // case, the outline won&#39;t get &#39;dragged along&#39;.
<a name="86" id="anc86"></a><span class="line-modified">4456     bool shouldPaintOutline = isSelfPaintingLayer &amp;&amp; !isPaintingOverlayScrollbars &amp;&amp; !isCollectingEventRegion</span>
<span class="line-added">4457         &amp;&amp; (renderer().view().printing() || renderer().view().hasRenderersWithOutline())</span>
4458         &amp;&amp; ((isPaintingScrollingContent &amp;&amp; isPaintingCompositedBackground)
4459         || (!isPaintingScrollingContent &amp;&amp; isPaintingCompositedForeground));
<a name="87" id="anc87"></a><span class="line-modified">4460     bool shouldPaintContent = m_hasVisibleContent &amp;&amp; isSelfPaintingLayer &amp;&amp; !isPaintingOverlayScrollbars &amp;&amp; !isCollectingEventRegion;</span>
4461 
4462     if (localPaintFlags &amp; PaintLayerPaintingRootBackgroundOnly &amp;&amp; !renderer().isRenderView() &amp;&amp; !renderer().isDocumentElementRenderer())
4463         return;
4464 
4465     updateLayerListsIfNeeded();
4466 
4467     LayoutSize offsetFromRoot = offsetFromAncestor(paintingInfo.rootLayer);
4468     LayoutRect rootRelativeBounds;
4469     bool rootRelativeBoundsComputed = false;
4470 
4471     // FIXME: We shouldn&#39;t have to disable subpixel quantization for overflow clips or subframes once we scroll those
4472     // things on the scrolling thread.
4473     bool didQuantizeFonts = true;
4474     bool needToAdjustSubpixelQuantization = setupFontSubpixelQuantization(context, didQuantizeFonts);
4475 
4476     // Apply clip-path to context.
4477     LayoutSize columnAwareOffsetFromRoot = offsetFromRoot;
4478     if (renderer().enclosingFragmentedFlow() &amp;&amp; (renderer().hasClipPath() || filtersForPainting(context, paintFlags)))
4479         columnAwareOffsetFromRoot = toLayoutSize(convertToLayerCoords(paintingInfo.rootLayer, LayoutPoint(), AdjustForColumns));
4480 
4481     bool hasClipPath = false;
4482     if (shouldApplyClipPath(paintingInfo.paintBehavior, localPaintFlags))
4483         hasClipPath = setupClipPath(context, paintingInfo, columnAwareOffsetFromRoot, rootRelativeBounds, rootRelativeBoundsComputed);
4484 
4485     bool selectionAndBackgroundsOnly = paintingInfo.paintBehavior.contains(PaintBehavior::SelectionAndBackgroundsOnly);
4486     bool selectionOnly = paintingInfo.paintBehavior.contains(PaintBehavior::SelectionOnly);
4487 
4488     SinglePaintFrequencyTracking singlePaintFrequencyTracking(m_paintFrequencyTracker, shouldPaintContent);
4489 
4490     LayerFragments layerFragments;
4491     RenderObject* subtreePaintRootForRenderer = nullptr;
4492 
4493     { // Scope for filter-related state changes.
4494         LayerPaintingInfo localPaintingInfo(paintingInfo);
4495         GraphicsContext* filterContext = setupFilters(context, localPaintingInfo, paintFlags, columnAwareOffsetFromRoot, rootRelativeBounds, rootRelativeBoundsComputed);
4496         if (filterContext &amp;&amp; haveTransparency) {
4497             // If we have a filter and transparency, we have to eagerly start a transparency layer here, rather than risk a child layer lazily starts one with the wrong context.
4498             beginTransparencyLayers(context, localPaintingInfo, paintingInfo.paintDirtyRect);
4499         }
4500         GraphicsContext&amp; currentContext = filterContext ? *filterContext : context;
4501 
4502         // If this layer&#39;s renderer is a child of the subtreePaintRoot, we render unconditionally, which
4503         // is done by passing a nil subtreePaintRoot down to our renderer (as if no subtreePaintRoot was ever set).
4504         // Otherwise, our renderer tree may or may not contain the subtreePaintRoot root, so we pass that root along
4505         // so it will be tested against as we descend through the renderers.
4506         if (localPaintingInfo.subtreePaintRoot &amp;&amp; !renderer().isDescendantOf(localPaintingInfo.subtreePaintRoot))
4507             subtreePaintRootForRenderer = localPaintingInfo.subtreePaintRoot;
4508 
4509         if (localPaintingInfo.overlapTestRequests &amp;&amp; isSelfPaintingLayer)
4510             performOverlapTests(*localPaintingInfo.overlapTestRequests, localPaintingInfo.rootLayer, this);
4511 
4512         OptionSet&lt;PaintBehavior&gt; paintBehavior = PaintBehavior::Normal;
4513         if (localPaintFlags &amp; PaintLayerPaintingSkipRootBackground)
4514             paintBehavior.add(PaintBehavior::SkipRootBackground);
4515         else if (localPaintFlags &amp; PaintLayerPaintingRootBackgroundOnly)
4516             paintBehavior.add(PaintBehavior::RootBackgroundOnly);
4517 
4518         if (paintingInfo.paintBehavior &amp; PaintBehavior::FlattenCompositingLayers)
4519             paintBehavior.add(PaintBehavior::FlattenCompositingLayers);
4520 
4521         if (paintingInfo.paintBehavior &amp; PaintBehavior::Snapshotting)
4522             paintBehavior.add(PaintBehavior::Snapshotting);
4523 
4524         if ((paintingInfo.paintBehavior &amp; PaintBehavior::TileFirstPaint) &amp;&amp; isRenderViewLayer())
4525             paintBehavior.add(PaintBehavior::TileFirstPaint);
4526 
4527         if (paintingInfo.paintBehavior &amp; PaintBehavior::ExcludeSelection)
4528             paintBehavior.add(PaintBehavior::ExcludeSelection);
4529 
4530         LayoutRect paintDirtyRect = localPaintingInfo.paintDirtyRect;
<a name="88" id="anc88"></a><span class="line-modified">4531         if (shouldPaintContent || shouldPaintOutline || isPaintingOverlayScrollbars || isCollectingEventRegion) {</span>
4532             // Collect the fragments. This will compute the clip rectangles and paint offsets for each layer fragment, as well as whether or not the content of each
4533             // fragment should paint. If the parent&#39;s filter dictates full repaint to ensure proper filter effect,
4534             // use the overflow clip as dirty rect, instead of no clipping. It maintains proper clipping for overflow::scroll.
4535             if (!localPaintingInfo.clipToDirtyRect &amp;&amp; renderer().hasOverflowClip()) {
4536                 // We can turn clipping back by requesting full repaint for the overflow area.
4537                 localPaintingInfo.clipToDirtyRect = true;
4538                 paintDirtyRect = clipRectRelativeToAncestor(localPaintingInfo.rootLayer, offsetFromRoot, LayoutRect::infiniteRect());
4539             }
4540             collectFragments(layerFragments, localPaintingInfo.rootLayer, paintDirtyRect, ExcludeCompositedPaginatedLayers,
4541                 (localPaintFlags &amp; PaintLayerTemporaryClipRects) ? TemporaryClipRects : PaintingClipRects, IgnoreOverlayScrollbarSize,
4542                 (isPaintingOverflowContents) ? IgnoreOverflowClip : RespectOverflowClip, offsetFromRoot);
4543             updatePaintingInfoForFragments(layerFragments, localPaintingInfo, localPaintFlags, shouldPaintContent, offsetFromRoot);
4544         }
4545 
4546         if (isPaintingCompositedBackground) {
4547             // Paint only the backgrounds for all of the fragments of the layer.
4548             if (shouldPaintContent &amp;&amp; !selectionOnly) {
4549                 paintBackgroundForFragments(layerFragments, currentContext, context, paintingInfo.paintDirtyRect, haveTransparency,
4550                     localPaintingInfo, paintBehavior, subtreePaintRootForRenderer);
4551             }
4552         }
4553 
4554         // Now walk the sorted list of children with negative z-indices.
4555         if ((isPaintingScrollingContent &amp;&amp; isPaintingOverflowContents) || (!isPaintingScrollingContent &amp;&amp; isPaintingCompositedBackground))
4556             paintList(negativeZOrderLayers(), currentContext, localPaintingInfo, localPaintFlags);
4557 
4558         if (isPaintingCompositedForeground) {
4559             if (shouldPaintContent) {
4560                 paintForegroundForFragments(layerFragments, currentContext, context, paintingInfo.paintDirtyRect, haveTransparency,
4561                     localPaintingInfo, paintBehavior, subtreePaintRootForRenderer);
4562             }
4563         }
4564 
<a name="89" id="anc89"></a><span class="line-added">4565         if (isCollectingEventRegion)</span>
<span class="line-added">4566             collectEventRegionForFragments(layerFragments, currentContext, localPaintingInfo);</span>
<span class="line-added">4567 </span>
4568         if (shouldPaintOutline)
4569             paintOutlineForFragments(layerFragments, currentContext, localPaintingInfo, paintBehavior, subtreePaintRootForRenderer);
4570 
4571         if (isPaintingCompositedForeground) {
4572             // Paint any child layers that have overflow.
4573             paintList(normalFlowLayers(), currentContext, localPaintingInfo, localPaintFlags);
4574 
4575             // Now walk the sorted list of children with positive z-indices.
4576             paintList(positiveZOrderLayers(), currentContext, localPaintingInfo, localPaintFlags);
4577         }
4578 
4579         if (isPaintingOverlayScrollbars &amp;&amp; hasScrollbars())
4580             paintOverflowControlsForFragments(layerFragments, currentContext, localPaintingInfo);
4581 
4582         if (filterContext) {
4583             // When we called collectFragments() last time, paintDirtyRect was reset to represent the filter bounds.
4584             // Now we need to compute the backgroundRect uncontaminated by filters, in order to clip the filtered result.
4585             // Note that we also use paintingInfo here, not localPaintingInfo which filters also contaminated.
4586             LayerFragments layerFragments;
4587             collectFragments(layerFragments, paintingInfo.rootLayer, paintingInfo.paintDirtyRect, ExcludeCompositedPaginatedLayers,
4588                 (localPaintFlags &amp; PaintLayerTemporaryClipRects) ? TemporaryClipRects : PaintingClipRects, IgnoreOverlayScrollbarSize,
4589                 (isPaintingOverflowContents) ? IgnoreOverflowClip : RespectOverflowClip, offsetFromRoot);
4590             updatePaintingInfoForFragments(layerFragments, paintingInfo, localPaintFlags, shouldPaintContent, offsetFromRoot);
4591 
4592             applyFilters(context, paintingInfo, layerFragments);
4593         }
4594     }
4595 
4596     if (shouldPaintContent &amp;&amp; !(selectionOnly || selectionAndBackgroundsOnly)) {
4597         OptionSet&lt;PaintBehavior&gt; paintBehavior = PaintBehavior::Normal;
4598         if (paintingInfo.paintBehavior &amp; PaintBehavior::FlattenCompositingLayers)
4599             paintBehavior.add(PaintBehavior::FlattenCompositingLayers);
4600 
4601         if (paintingInfo.paintBehavior &amp; PaintBehavior::Snapshotting)
4602             paintBehavior.add(PaintBehavior::Snapshotting);
4603 
4604         if (paintingInfo.paintBehavior &amp; PaintBehavior::TileFirstPaint)
4605             paintBehavior.add(PaintBehavior::TileFirstPaint);
4606 
4607         if (shouldPaintMask(paintingInfo.paintBehavior, localPaintFlags)) {
4608             // Paint the mask for the fragments.
4609             paintMaskForFragments(layerFragments, context, paintingInfo, paintBehavior, subtreePaintRootForRenderer);
4610         }
4611 
4612         if (!(paintFlags &amp; PaintLayerPaintingCompositingMaskPhase) &amp;&amp; (paintFlags &amp; PaintLayerPaintingCompositingClipPathPhase)) {
4613             // Re-use paintChildClippingMaskForFragments to paint black for the compositing clipping mask.
4614             paintChildClippingMaskForFragments(layerFragments, context, paintingInfo, paintBehavior, subtreePaintRootForRenderer);
4615         }
4616 
4617         if (localPaintFlags &amp; PaintLayerPaintingChildClippingMaskPhase) {
4618             // Paint the border radius mask for the fragments.
4619             paintChildClippingMaskForFragments(layerFragments, context, paintingInfo, paintBehavior, subtreePaintRootForRenderer);
4620         }
4621     }
4622 
4623     // End our transparency layer
4624     if (haveTransparency &amp;&amp; m_usedTransparency &amp;&amp; !m_paintingInsideReflection) {
4625         context.endTransparencyLayer();
4626         context.restore();
4627         m_usedTransparency = false;
4628     }
4629 
4630     // Re-set this to whatever it was before we painted the layer.
4631     if (needToAdjustSubpixelQuantization)
4632         context.setShouldSubpixelQuantizeFonts(didQuantizeFonts);
4633 
4634     if (hasClipPath)
4635         context.restore();
4636 }
4637 
4638 void RenderLayer::paintLayerByApplyingTransform(GraphicsContext&amp; context, const LayerPaintingInfo&amp; paintingInfo, OptionSet&lt;PaintLayerFlag&gt; paintFlags, const LayoutSize&amp; translationOffset)
4639 {
4640     // This involves subtracting out the position of the layer in our current coordinate space, but preserving
4641     // the accumulated error for sub-pixel layout.
4642     float deviceScaleFactor = renderer().document().deviceScaleFactor();
4643     LayoutSize offsetFromParent = offsetFromAncestor(paintingInfo.rootLayer);
4644     offsetFromParent += translationOffset;
4645     TransformationMatrix transform(renderableTransform(paintingInfo.paintBehavior));
4646     // Add the subpixel accumulation to the current layer&#39;s offset so that we can always snap the translateRight value to where the renderer() is supposed to be painting.
4647     LayoutSize offsetForThisLayer = offsetFromParent + paintingInfo.subpixelOffset;
4648     FloatSize devicePixelSnappedOffsetForThisLayer = toFloatSize(roundPointToDevicePixels(toLayoutPoint(offsetForThisLayer), deviceScaleFactor));
4649     // We handle accumulated subpixels through nested layers here. Since the context gets translated to device pixels,
4650     // all we need to do is add the delta to the accumulated pixels coming from ancestor layers.
4651     // Translate the graphics context to the snapping position to avoid off-device-pixel positing.
4652     transform.translateRight(devicePixelSnappedOffsetForThisLayer.width(), devicePixelSnappedOffsetForThisLayer.height());
4653     // Apply the transform.
<a name="90" id="anc90"></a><span class="line-modified">4654     auto oldTransform = context.getCTM();</span>
<span class="line-modified">4655     auto affineTransform = transform.toAffineTransform();</span>
<span class="line-added">4656     context.concatCTM(affineTransform);</span>
<span class="line-added">4657 </span>
<span class="line-added">4658     if (paintingInfo.eventRegionContext)</span>
<span class="line-added">4659         paintingInfo.eventRegionContext-&gt;pushTransform(affineTransform);</span>
4660 
4661     // Now do a paint with the root layer shifted to be us.
4662     LayoutSize adjustedSubpixelOffset = offsetForThisLayer - LayoutSize(devicePixelSnappedOffsetForThisLayer);
4663     LayerPaintingInfo transformedPaintingInfo(paintingInfo);
4664     transformedPaintingInfo.rootLayer = this;
4665     transformedPaintingInfo.paintDirtyRect = LayoutRect(encloseRectToDevicePixels(transform.inverse().valueOr(AffineTransform()).mapRect(paintingInfo.paintDirtyRect), deviceScaleFactor));
4666     transformedPaintingInfo.subpixelOffset = adjustedSubpixelOffset;
4667     paintLayerContentsAndReflection(context, transformedPaintingInfo, paintFlags);
<a name="91" id="anc91"></a><span class="line-modified">4668 </span>
<span class="line-added">4669     if (paintingInfo.eventRegionContext)</span>
<span class="line-added">4670         paintingInfo.eventRegionContext-&gt;popTransform();</span>
<span class="line-added">4671 </span>
<span class="line-added">4672     context.setCTM(oldTransform);</span>
4673 }
4674 
4675 void RenderLayer::paintList(LayerList layerIterator, GraphicsContext&amp; context, const LayerPaintingInfo&amp; paintingInfo, OptionSet&lt;PaintLayerFlag&gt; paintFlags)
4676 {
4677     if (layerIterator.begin() == layerIterator.end())
4678         return;
4679 
4680     if (!hasSelfPaintingLayerDescendant())
4681         return;
4682 
4683 #if !ASSERT_DISABLED
4684     LayerListMutationDetector mutationChecker(*this);
4685 #endif
4686 
4687     for (auto* childLayer : layerIterator)
4688         childLayer-&gt;paintLayer(context, paintingInfo, paintFlags);
4689 }
4690 
4691 RenderLayer* RenderLayer::enclosingPaginationLayerInSubtree(const RenderLayer* rootLayer, PaginationInclusionMode mode) const
4692 {
4693     // If we don&#39;t have an enclosing layer, or if the root layer is the same as the enclosing layer,
4694     // then just return the enclosing pagination layer (it will be 0 in the former case and the rootLayer in the latter case).
4695     RenderLayer* paginationLayer = enclosingPaginationLayer(mode);
4696     if (!paginationLayer || rootLayer == paginationLayer)
4697         return paginationLayer;
4698 
4699     // Walk up the layer tree and see which layer we hit first. If it&#39;s the root, then the enclosing pagination
4700     // layer isn&#39;t in our subtree and we return nullptr. If we hit the enclosing pagination layer first, then
4701     // we can return it.
4702     for (const RenderLayer* layer = this; layer; layer = layer-&gt;parent()) {
4703         if (layer == rootLayer)
4704             return nullptr;
4705         if (layer == paginationLayer)
4706             return paginationLayer;
4707     }
4708 
4709     // This should never be reached, since an enclosing layer should always either be the rootLayer or be
4710     // our enclosing pagination layer.
4711     ASSERT_NOT_REACHED();
4712     return nullptr;
4713 }
4714 
4715 void RenderLayer::collectFragments(LayerFragments&amp; fragments, const RenderLayer* rootLayer, const LayoutRect&amp; dirtyRect, PaginationInclusionMode inclusionMode,
4716     ClipRectsType clipRectsType, OverlayScrollbarSizeRelevancy inOverlayScrollbarSizeRelevancy, ShouldRespectOverflowClip respectOverflowClip, const LayoutSize&amp; offsetFromRoot,
4717     const LayoutRect* layerBoundingBox, ShouldApplyRootOffsetToFragments applyRootOffsetToFragments)
4718 {
4719     RenderLayer* paginationLayer = enclosingPaginationLayerInSubtree(rootLayer, inclusionMode);
4720     if (!paginationLayer || hasTransform()) {
4721         // For unpaginated layers, there is only one fragment.
4722         LayerFragment fragment;
4723         ClipRectsContext clipRectsContext(rootLayer, clipRectsType, inOverlayScrollbarSizeRelevancy, respectOverflowClip);
4724         calculateRects(clipRectsContext, dirtyRect, fragment.layerBounds, fragment.backgroundRect, fragment.foregroundRect, offsetFromRoot);
4725         fragments.append(fragment);
4726         return;
4727     }
4728 
4729     // Compute our offset within the enclosing pagination layer.
4730     LayoutSize offsetWithinPaginatedLayer = offsetFromAncestor(paginationLayer);
4731 
4732     // Calculate clip rects relative to the enclosingPaginationLayer. The purpose of this call is to determine our bounds clipped to intermediate
4733     // layers between us and the pagination context. It&#39;s important to minimize the number of fragments we need to create and this helps with that.
4734     ClipRectsContext paginationClipRectsContext(paginationLayer, clipRectsType, inOverlayScrollbarSizeRelevancy, respectOverflowClip);
4735     LayoutRect layerBoundsInFragmentedFlow;
4736     ClipRect backgroundRectInFragmentedFlow;
4737     ClipRect foregroundRectInFragmentedFlow;
4738     calculateRects(paginationClipRectsContext, LayoutRect::infiniteRect(), layerBoundsInFragmentedFlow, backgroundRectInFragmentedFlow, foregroundRectInFragmentedFlow,
4739         offsetWithinPaginatedLayer);
4740 
4741     // Take our bounding box within the flow thread and clip it.
4742     LayoutRect layerBoundingBoxInFragmentedFlow = layerBoundingBox ? *layerBoundingBox : boundingBox(paginationLayer, offsetWithinPaginatedLayer);
4743     layerBoundingBoxInFragmentedFlow.intersect(backgroundRectInFragmentedFlow.rect());
4744 
4745     auto&amp; enclosingFragmentedFlow = downcast&lt;RenderFragmentedFlow&gt;(paginationLayer-&gt;renderer());
4746     RenderLayer* parentPaginationLayer = paginationLayer-&gt;parent()-&gt;enclosingPaginationLayerInSubtree(rootLayer, inclusionMode);
4747     LayerFragments ancestorFragments;
4748     if (parentPaginationLayer) {
4749         // Compute a bounding box accounting for fragments.
4750         LayoutRect layerFragmentBoundingBoxInParentPaginationLayer = enclosingFragmentedFlow.fragmentsBoundingBox(layerBoundingBoxInFragmentedFlow);
4751 
4752         // Convert to be in the ancestor pagination context&#39;s coordinate space.
4753         LayoutSize offsetWithinParentPaginatedLayer = paginationLayer-&gt;offsetFromAncestor(parentPaginationLayer);
4754         layerFragmentBoundingBoxInParentPaginationLayer.move(offsetWithinParentPaginatedLayer);
4755 
4756         // Now collect ancestor fragments.
4757         parentPaginationLayer-&gt;collectFragments(ancestorFragments, rootLayer, dirtyRect, inclusionMode, clipRectsType, inOverlayScrollbarSizeRelevancy, respectOverflowClip,
4758             offsetFromAncestor(rootLayer), &amp;layerFragmentBoundingBoxInParentPaginationLayer, ApplyRootOffsetToFragments);
4759 
4760         if (ancestorFragments.isEmpty())
4761             return;
4762 
4763         for (auto&amp; ancestorFragment : ancestorFragments) {
4764             // Shift the dirty rect into flow thread coordinates.
4765             LayoutRect dirtyRectInFragmentedFlow(dirtyRect);
4766             dirtyRectInFragmentedFlow.move(-offsetWithinParentPaginatedLayer - ancestorFragment.paginationOffset);
4767 
4768             size_t oldSize = fragments.size();
4769 
4770             // Tell the flow thread to collect the fragments. We pass enough information to create a minimal number of fragments based off the pages/columns
4771             // that intersect the actual dirtyRect as well as the pages/columns that intersect our layer&#39;s bounding box.
4772             enclosingFragmentedFlow.collectLayerFragments(fragments, layerBoundingBoxInFragmentedFlow, dirtyRectInFragmentedFlow);
4773 
4774             size_t newSize = fragments.size();
4775 
4776             if (oldSize == newSize)
4777                 continue;
4778 
4779             for (size_t i = oldSize; i &lt; newSize; ++i) {
4780                 LayerFragment&amp; fragment = fragments.at(i);
4781 
4782                 // Set our four rects with all clipping applied that was internal to the flow thread.
4783                 fragment.setRects(layerBoundsInFragmentedFlow, backgroundRectInFragmentedFlow, foregroundRectInFragmentedFlow, &amp;layerBoundingBoxInFragmentedFlow);
4784 
4785                 // Shift to the root-relative physical position used when painting the flow thread in this fragment.
4786                 fragment.moveBy(toLayoutPoint(ancestorFragment.paginationOffset + fragment.paginationOffset + offsetWithinParentPaginatedLayer));
4787 
4788                 // Intersect the fragment with our ancestor&#39;s background clip so that e.g., columns in an overflow:hidden block are
4789                 // properly clipped by the overflow.
4790                 fragment.intersect(ancestorFragment.paginationClip);
4791 
4792                 // Now intersect with our pagination clip. This will typically mean we&#39;re just intersecting the dirty rect with the column
4793                 // clip, so the column clip ends up being all we apply.
4794                 fragment.intersect(fragment.paginationClip);
4795 
4796                 if (applyRootOffsetToFragments == ApplyRootOffsetToFragments)
4797                     fragment.paginationOffset = fragment.paginationOffset + offsetWithinParentPaginatedLayer;
4798             }
4799         }
4800 
4801         return;
4802     }
4803 
4804     // Shift the dirty rect into flow thread coordinates.
4805     LayoutSize offsetOfPaginationLayerFromRoot = enclosingPaginationLayer(inclusionMode)-&gt;offsetFromAncestor(rootLayer);
4806     LayoutRect dirtyRectInFragmentedFlow(dirtyRect);
4807     dirtyRectInFragmentedFlow.move(-offsetOfPaginationLayerFromRoot);
4808 
4809     // Tell the flow thread to collect the fragments. We pass enough information to create a minimal number of fragments based off the pages/columns
4810     // that intersect the actual dirtyRect as well as the pages/columns that intersect our layer&#39;s bounding box.
4811     enclosingFragmentedFlow.collectLayerFragments(fragments, layerBoundingBoxInFragmentedFlow, dirtyRectInFragmentedFlow);
4812 
4813     if (fragments.isEmpty())
4814         return;
4815 
4816     // Get the parent clip rects of the pagination layer, since we need to intersect with that when painting column contents.
4817     ClipRect ancestorClipRect = dirtyRect;
4818     if (paginationLayer-&gt;parent()) {
4819         ClipRectsContext clipRectsContext(rootLayer, clipRectsType, inOverlayScrollbarSizeRelevancy, respectOverflowClip);
4820         ancestorClipRect = paginationLayer-&gt;backgroundClipRect(clipRectsContext);
4821         ancestorClipRect.intersect(dirtyRect);
4822     }
4823 
4824     for (auto&amp; fragment : fragments) {
4825         // Set our four rects with all clipping applied that was internal to the flow thread.
4826         fragment.setRects(layerBoundsInFragmentedFlow, backgroundRectInFragmentedFlow, foregroundRectInFragmentedFlow, &amp;layerBoundingBoxInFragmentedFlow);
4827 
4828         // Shift to the root-relative physical position used when painting the flow thread in this fragment.
4829         fragment.moveBy(toLayoutPoint(fragment.paginationOffset + offsetOfPaginationLayerFromRoot));
4830 
4831         // Intersect the fragment with our ancestor&#39;s background clip so that e.g., columns in an overflow:hidden block are
4832         // properly clipped by the overflow.
4833         fragment.intersect(ancestorClipRect);
4834 
4835         // Now intersect with our pagination clip. This will typically mean we&#39;re just intersecting the dirty rect with the column
4836         // clip, so the column clip ends up being all we apply.
4837         fragment.intersect(fragment.paginationClip);
4838 
4839         if (applyRootOffsetToFragments == ApplyRootOffsetToFragments)
4840             fragment.paginationOffset = fragment.paginationOffset + offsetOfPaginationLayerFromRoot;
4841     }
4842 }
4843 
4844 void RenderLayer::updatePaintingInfoForFragments(LayerFragments&amp; fragments, const LayerPaintingInfo&amp; localPaintingInfo, OptionSet&lt;PaintLayerFlag&gt; localPaintFlags,
4845     bool shouldPaintContent, const LayoutSize&amp; offsetFromRoot)
4846 {
4847     for (auto&amp; fragment : fragments) {
4848         fragment.shouldPaintContent = shouldPaintContent;
4849         if (this != localPaintingInfo.rootLayer || !(localPaintFlags &amp; PaintLayerPaintingOverflowContents)) {
4850             LayoutSize newOffsetFromRoot = offsetFromRoot + fragment.paginationOffset;
4851             fragment.shouldPaintContent &amp;= intersectsDamageRect(fragment.layerBounds, fragment.backgroundRect.rect(), localPaintingInfo.rootLayer, newOffsetFromRoot, fragment.hasBoundingBox ? &amp;fragment.boundingBox : 0);
4852         }
4853     }
4854 }
4855 
4856 void RenderLayer::paintTransformedLayerIntoFragments(GraphicsContext&amp; context, const LayerPaintingInfo&amp; paintingInfo, OptionSet&lt;PaintLayerFlag&gt; paintFlags)
4857 {
4858     LayerFragments enclosingPaginationFragments;
4859     LayoutSize offsetOfPaginationLayerFromRoot;
4860     RenderLayer* paginatedLayer = enclosingPaginationLayer(ExcludeCompositedPaginatedLayers);
4861     LayoutRect transformedExtent = transparencyClipBox(*this, paginatedLayer, PaintingTransparencyClipBox, RootOfTransparencyClipBox, paintingInfo.paintBehavior);
4862     paginatedLayer-&gt;collectFragments(enclosingPaginationFragments, paintingInfo.rootLayer, paintingInfo.paintDirtyRect, ExcludeCompositedPaginatedLayers,
4863         (paintFlags &amp; PaintLayerTemporaryClipRects) ? TemporaryClipRects : PaintingClipRects, IgnoreOverlayScrollbarSize,
4864         (paintFlags &amp; PaintLayerPaintingOverflowContents) ? IgnoreOverflowClip : RespectOverflowClip, offsetOfPaginationLayerFromRoot, &amp;transformedExtent);
4865 
4866     for (const auto&amp; fragment : enclosingPaginationFragments) {
4867         // Apply the page/column clip for this fragment, as well as any clips established by layers in between us and
4868         // the enclosing pagination layer.
4869         LayoutRect clipRect = fragment.backgroundRect.rect();
4870 
4871         // Now compute the clips within a given fragment
4872         if (parent() != paginatedLayer) {
4873             offsetOfPaginationLayerFromRoot = toLayoutSize(paginatedLayer-&gt;convertToLayerCoords(paintingInfo.rootLayer, toLayoutPoint(offsetOfPaginationLayerFromRoot)));
4874 
4875             ClipRectsContext clipRectsContext(paginatedLayer, (paintFlags &amp; PaintLayerTemporaryClipRects) ? TemporaryClipRects : PaintingClipRects,
4876                 IgnoreOverlayScrollbarSize, (paintFlags &amp; PaintLayerPaintingOverflowContents) ? IgnoreOverflowClip : RespectOverflowClip);
4877             LayoutRect parentClipRect = backgroundClipRect(clipRectsContext).rect();
4878             parentClipRect.move(fragment.paginationOffset + offsetOfPaginationLayerFromRoot);
4879             clipRect.intersect(parentClipRect);
4880         }
4881 
4882         parent()-&gt;clipToRect(context, paintingInfo, clipRect);
4883         paintLayerByApplyingTransform(context, paintingInfo, paintFlags, fragment.paginationOffset);
4884         parent()-&gt;restoreClip(context, paintingInfo, clipRect);
4885     }
4886 }
4887 
4888 void RenderLayer::paintBackgroundForFragments(const LayerFragments&amp; layerFragments, GraphicsContext&amp; context, GraphicsContext&amp; contextForTransparencyLayer,
4889     const LayoutRect&amp; transparencyPaintDirtyRect, bool haveTransparency, const LayerPaintingInfo&amp; localPaintingInfo, OptionSet&lt;PaintBehavior&gt; paintBehavior,
4890     RenderObject* subtreePaintRootForRenderer)
4891 {
4892     for (const auto&amp; fragment : layerFragments) {
4893         if (!fragment.shouldPaintContent)
4894             continue;
4895 
4896         // Begin transparency layers lazily now that we know we have to paint something.
4897         if (haveTransparency)
4898             beginTransparencyLayers(contextForTransparencyLayer, localPaintingInfo, transparencyPaintDirtyRect);
4899 
4900         if (localPaintingInfo.clipToDirtyRect) {
4901             // Paint our background first, before painting any child layers.
4902             // Establish the clip used to paint our background.
4903             clipToRect(context, localPaintingInfo, fragment.backgroundRect, DoNotIncludeSelfForBorderRadius); // Background painting will handle clipping to self.
4904         }
4905 
4906         // Paint the background.
4907         // FIXME: Eventually we will collect the region from the fragment itself instead of just from the paint info.
4908         PaintInfo paintInfo(context, fragment.backgroundRect.rect(), PaintPhase::BlockBackground, paintBehavior, subtreePaintRootForRenderer, nullptr, nullptr, &amp;localPaintingInfo.rootLayer-&gt;renderer(), this);
4909         renderer().paint(paintInfo, toLayoutPoint(fragment.layerBounds.location() - renderBoxLocation() + localPaintingInfo.subpixelOffset));
4910 
4911         if (localPaintingInfo.clipToDirtyRect)
4912             restoreClip(context, localPaintingInfo, fragment.backgroundRect);
4913     }
4914 }
4915 
4916 void RenderLayer::paintForegroundForFragments(const LayerFragments&amp; layerFragments, GraphicsContext&amp; context, GraphicsContext&amp; contextForTransparencyLayer,
4917     const LayoutRect&amp; transparencyPaintDirtyRect, bool haveTransparency, const LayerPaintingInfo&amp; localPaintingInfo, OptionSet&lt;PaintBehavior&gt; paintBehavior,
4918     RenderObject* subtreePaintRootForRenderer)
4919 {
4920     // Begin transparency if we have something to paint.
4921     if (haveTransparency) {
4922         for (const auto&amp; fragment : layerFragments) {
4923             if (fragment.shouldPaintContent &amp;&amp; !fragment.foregroundRect.isEmpty()) {
4924                 beginTransparencyLayers(contextForTransparencyLayer, localPaintingInfo, transparencyPaintDirtyRect);
4925                 break;
4926             }
4927         }
4928     }
4929 
4930     OptionSet&lt;PaintBehavior&gt; localPaintBehavior;
4931     if (localPaintingInfo.paintBehavior &amp; PaintBehavior::ForceBlackText)
4932         localPaintBehavior = PaintBehavior::ForceBlackText;
4933     else if (localPaintingInfo.paintBehavior &amp; PaintBehavior::ForceWhiteText)
4934         localPaintBehavior = PaintBehavior::ForceWhiteText;
4935     else
4936         localPaintBehavior = paintBehavior;
4937 
4938     if (localPaintingInfo.paintBehavior &amp; PaintBehavior::ExcludeSelection)
4939         localPaintBehavior.add(PaintBehavior::ExcludeSelection);
4940 
4941     if (localPaintingInfo.paintBehavior &amp; PaintBehavior::Snapshotting)
4942         localPaintBehavior.add(PaintBehavior::Snapshotting);
4943 
4944     if (localPaintingInfo.paintBehavior &amp; PaintBehavior::TileFirstPaint)
4945         localPaintBehavior.add(PaintBehavior::TileFirstPaint);
4946 
4947     // Optimize clipping for the single fragment case.
4948     bool shouldClip = localPaintingInfo.clipToDirtyRect &amp;&amp; layerFragments.size() == 1 &amp;&amp; layerFragments[0].shouldPaintContent &amp;&amp; !layerFragments[0].foregroundRect.isEmpty();
4949     ClipRect clippedRect;
4950     if (shouldClip) {
4951         clippedRect = layerFragments[0].foregroundRect;
4952         clipToRect(context, localPaintingInfo, clippedRect);
4953     }
4954 
4955     // We have to loop through every fragment multiple times, since we have to repaint in each specific phase in order for
4956     // interleaving of the fragments to work properly.
<a name="92" id="anc92"></a><span class="line-modified">4957     bool selectionOnly = localPaintingInfo.paintBehavior.contains(PaintBehavior::SelectionOnly);</span>
<span class="line-modified">4958     bool selectionAndBackgroundsOnly = localPaintingInfo.paintBehavior.contains(PaintBehavior::SelectionAndBackgroundsOnly);</span>
<span class="line-modified">4959 </span>
<span class="line-added">4960     if (!selectionOnly)</span>
<span class="line-added">4961         paintForegroundForFragmentsWithPhase(PaintPhase::ChildBlockBackgrounds, layerFragments, context, localPaintingInfo, localPaintBehavior, subtreePaintRootForRenderer);</span>
4962 
<a name="93" id="anc93"></a><span class="line-modified">4963     if (selectionOnly || selectionAndBackgroundsOnly)</span>
<span class="line-added">4964         paintForegroundForFragmentsWithPhase(PaintPhase::Selection, layerFragments, context, localPaintingInfo, localPaintBehavior, subtreePaintRootForRenderer);</span>
<span class="line-added">4965     else {</span>
4966         paintForegroundForFragmentsWithPhase(PaintPhase::Float, layerFragments, context, localPaintingInfo, localPaintBehavior, subtreePaintRootForRenderer);
4967         paintForegroundForFragmentsWithPhase(PaintPhase::Foreground, layerFragments, context, localPaintingInfo, localPaintBehavior, subtreePaintRootForRenderer);
4968         paintForegroundForFragmentsWithPhase(PaintPhase::ChildOutlines, layerFragments, context, localPaintingInfo, localPaintBehavior, subtreePaintRootForRenderer);
4969     }
4970 
4971     if (shouldClip)
4972         restoreClip(context, localPaintingInfo, clippedRect);
4973 }
4974 
4975 void RenderLayer::paintForegroundForFragmentsWithPhase(PaintPhase phase, const LayerFragments&amp; layerFragments, GraphicsContext&amp; context,
4976     const LayerPaintingInfo&amp; localPaintingInfo, OptionSet&lt;PaintBehavior&gt; paintBehavior, RenderObject* subtreePaintRootForRenderer)
4977 {
4978     bool shouldClip = localPaintingInfo.clipToDirtyRect &amp;&amp; layerFragments.size() &gt; 1;
4979 
4980     for (const auto&amp; fragment : layerFragments) {
4981         if (!fragment.shouldPaintContent || fragment.foregroundRect.isEmpty())
4982             continue;
4983 
4984         if (shouldClip)
4985             clipToRect(context, localPaintingInfo, fragment.foregroundRect);
4986 
4987         PaintInfo paintInfo(context, fragment.foregroundRect.rect(), phase, paintBehavior, subtreePaintRootForRenderer, nullptr, nullptr, &amp;localPaintingInfo.rootLayer-&gt;renderer(), this, localPaintingInfo.requireSecurityOriginAccessForWidgets);
4988         if (phase == PaintPhase::Foreground)
4989             paintInfo.overlapTestRequests = localPaintingInfo.overlapTestRequests;
4990         renderer().paint(paintInfo, toLayoutPoint(fragment.layerBounds.location() - renderBoxLocation() + localPaintingInfo.subpixelOffset));
4991 
4992         if (shouldClip)
4993             restoreClip(context, localPaintingInfo, fragment.foregroundRect);
4994     }
4995 }
4996 
4997 void RenderLayer::paintOutlineForFragments(const LayerFragments&amp; layerFragments, GraphicsContext&amp; context, const LayerPaintingInfo&amp; localPaintingInfo,
4998     OptionSet&lt;PaintBehavior&gt; paintBehavior, RenderObject* subtreePaintRootForRenderer)
4999 {
5000     for (const auto&amp; fragment : layerFragments) {
5001         if (fragment.backgroundRect.isEmpty())
5002             continue;
5003 
5004         // Paint our own outline
5005         PaintInfo paintInfo(context, fragment.backgroundRect.rect(), PaintPhase::SelfOutline, paintBehavior, subtreePaintRootForRenderer, nullptr, nullptr, &amp;localPaintingInfo.rootLayer-&gt;renderer(), this);
5006         clipToRect(context, localPaintingInfo, fragment.backgroundRect, DoNotIncludeSelfForBorderRadius);
5007         renderer().paint(paintInfo, toLayoutPoint(fragment.layerBounds.location() - renderBoxLocation() + localPaintingInfo.subpixelOffset));
5008         restoreClip(context, localPaintingInfo, fragment.backgroundRect);
5009     }
5010 }
5011 
5012 void RenderLayer::paintMaskForFragments(const LayerFragments&amp; layerFragments, GraphicsContext&amp; context, const LayerPaintingInfo&amp; localPaintingInfo,
5013     OptionSet&lt;PaintBehavior&gt; paintBehavior, RenderObject* subtreePaintRootForRenderer)
5014 {
5015     for (const auto&amp; fragment : layerFragments) {
5016         if (!fragment.shouldPaintContent)
5017             continue;
5018 
5019         if (localPaintingInfo.clipToDirtyRect)
5020             clipToRect(context, localPaintingInfo, fragment.backgroundRect, DoNotIncludeSelfForBorderRadius); // Mask painting will handle clipping to self.
5021 
5022         // Paint the mask.
5023         // FIXME: Eventually we will collect the region from the fragment itself instead of just from the paint info.
5024         PaintInfo paintInfo(context, fragment.backgroundRect.rect(), PaintPhase::Mask, paintBehavior, subtreePaintRootForRenderer, nullptr, nullptr, &amp;localPaintingInfo.rootLayer-&gt;renderer(), this);
5025         renderer().paint(paintInfo, toLayoutPoint(fragment.layerBounds.location() - renderBoxLocation() + localPaintingInfo.subpixelOffset));
5026 
5027         if (localPaintingInfo.clipToDirtyRect)
5028             restoreClip(context, localPaintingInfo, fragment.backgroundRect);
5029     }
5030 }
5031 
5032 void RenderLayer::paintChildClippingMaskForFragments(const LayerFragments&amp; layerFragments, GraphicsContext&amp; context, const LayerPaintingInfo&amp; localPaintingInfo, OptionSet&lt;PaintBehavior&gt; paintBehavior, RenderObject* subtreePaintRootForRenderer)
5033 {
5034     for (const auto&amp; fragment : layerFragments) {
5035         if (!fragment.shouldPaintContent)
5036             continue;
5037 
5038         if (localPaintingInfo.clipToDirtyRect)
5039             clipToRect(context, localPaintingInfo, fragment.foregroundRect, IncludeSelfForBorderRadius); // Child clipping mask painting will handle clipping to self.
5040 
5041         // Paint the clipped mask.
5042         PaintInfo paintInfo(context, fragment.backgroundRect.rect(), PaintPhase::ClippingMask, paintBehavior, subtreePaintRootForRenderer, nullptr, nullptr, &amp;localPaintingInfo.rootLayer-&gt;renderer(), this);
5043         renderer().paint(paintInfo, toLayoutPoint(fragment.layerBounds.location() - renderBoxLocation() + localPaintingInfo.subpixelOffset));
5044 
5045         if (localPaintingInfo.clipToDirtyRect)
5046             restoreClip(context, localPaintingInfo, fragment.foregroundRect);
5047     }
5048 }
5049 
5050 void RenderLayer::paintOverflowControlsForFragments(const LayerFragments&amp; layerFragments, GraphicsContext&amp; context, const LayerPaintingInfo&amp; localPaintingInfo)
5051 {
5052     for (const auto&amp; fragment : layerFragments) {
5053         if (fragment.backgroundRect.isEmpty())
5054             continue;
5055         clipToRect(context, localPaintingInfo, fragment.backgroundRect);
5056         paintOverflowControls(context, roundedIntPoint(toLayoutPoint(fragment.layerBounds.location() - renderBoxLocation() + localPaintingInfo.subpixelOffset)),
5057             snappedIntRect(fragment.backgroundRect.rect()), true);
5058         restoreClip(context, localPaintingInfo, fragment.backgroundRect);
5059     }
5060 }
5061 
<a name="94" id="anc94"></a><span class="line-added">5062 void RenderLayer::collectEventRegionForFragments(const LayerFragments&amp; layerFragments, GraphicsContext&amp; context, const LayerPaintingInfo&amp; localPaintingInfo)</span>
<span class="line-added">5063 {</span>
<span class="line-added">5064     ASSERT(localPaintingInfo.eventRegionContext);</span>
<span class="line-added">5065 </span>
<span class="line-added">5066     for (const auto&amp; fragment : layerFragments) {</span>
<span class="line-added">5067         PaintInfo paintInfo(context, fragment.foregroundRect.rect(), PaintPhase::EventRegion, { });</span>
<span class="line-added">5068         paintInfo.eventRegionContext = localPaintingInfo.eventRegionContext;</span>
<span class="line-added">5069         renderer().paint(paintInfo, toLayoutPoint(fragment.layerBounds.location() - renderBoxLocation() + localPaintingInfo.subpixelOffset));</span>
<span class="line-added">5070     }</span>
<span class="line-added">5071 }</span>
<span class="line-added">5072 </span>
5073 bool RenderLayer::hitTest(const HitTestRequest&amp; request, HitTestResult&amp; result)
5074 {
5075     return hitTest(request, result.hitTestLocation(), result);
5076 }
5077 
5078 bool RenderLayer::hitTest(const HitTestRequest&amp; request, const HitTestLocation&amp; hitTestLocation, HitTestResult&amp; result)
5079 {
5080     ASSERT(isSelfPaintingLayer() || hasSelfPaintingLayerDescendant());
5081     ASSERT(!renderer().view().needsLayout());
5082 
5083     ASSERT(!isRenderFragmentedFlow());
5084     LayoutRect hitTestArea = renderer().view().documentRect();
5085     if (!request.ignoreClipping()) {
5086         const auto&amp; settings = renderer().settings();
5087         if (settings.visualViewportEnabled() &amp;&amp; settings.clientCoordinatesRelativeToLayoutViewport()) {
5088             auto&amp; frameView = renderer().view().frameView();
5089             LayoutRect absoluteLayoutViewportRect = frameView.layoutViewportRect();
5090             auto scaleFactor = frameView.frame().frameScaleFactor();
5091             if (scaleFactor &gt; 1)
5092                 absoluteLayoutViewportRect.scale(scaleFactor);
5093             hitTestArea.intersect(absoluteLayoutViewportRect);
5094         } else
5095             hitTestArea.intersect(renderer().view().frameView().visibleContentRect(LegacyIOSDocumentVisibleRect));
5096     }
5097 
5098     RenderLayer* insideLayer = hitTestLayer(this, nullptr, request, result, hitTestArea, hitTestLocation, false);
5099     if (!insideLayer) {
5100         // We didn&#39;t hit any layer. If we are the root layer and the mouse is -- or just was -- down,
5101         // return ourselves. We do this so mouse events continue getting delivered after a drag has
5102         // exited the WebView, and so hit testing over a scrollbar hits the content document.
5103         if (!request.isChildFrameHitTest() &amp;&amp; (request.active() || request.release()) &amp;&amp; isRenderViewLayer()) {
5104             renderer().updateHitTestResult(result, downcast&lt;RenderView&gt;(renderer()).flipForWritingMode(hitTestLocation.point()));
5105             insideLayer = this;
5106         }
5107     }
5108 
5109     // Now determine if the result is inside an anchor - if the urlElement isn&#39;t already set.
5110     Node* node = result.innerNode();
5111     if (node &amp;&amp; !result.URLElement())
5112         result.setURLElement(node-&gt;enclosingLinkEventParentOrSelf());
5113 
5114     // Now return whether we were inside this layer (this will always be true for the root
5115     // layer).
5116     return insideLayer;
5117 }
5118 
5119 Element* RenderLayer::enclosingElement() const
5120 {
5121     for (RenderElement* r = &amp;renderer(); r; r = r-&gt;parent()) {
5122         if (Element* e = r-&gt;element())
5123             return e;
5124     }
5125     return nullptr;
5126 }
5127 
5128 RenderLayer* RenderLayer::enclosingFragmentedFlowAncestor() const
5129 {
5130     RenderLayer* curr = parent();
5131     for (; curr &amp;&amp; !curr-&gt;isRenderFragmentedFlow(); curr = curr-&gt;parent()) {
5132         if (curr-&gt;isStackingContext() &amp;&amp; curr-&gt;isComposited()) {
5133             // We only adjust the position of the first level of layers.
5134             return nullptr;
5135         }
5136     }
5137     return curr;
5138 }
5139 
5140 // Compute the z-offset of the point in the transformState.
5141 // This is effectively projecting a ray normal to the plane of ancestor, finding where that
5142 // ray intersects target, and computing the z delta between those two points.
5143 static double computeZOffset(const HitTestingTransformState&amp; transformState)
5144 {
5145     // We got an affine transform, so no z-offset
5146     if (transformState.m_accumulatedTransform.isAffine())
5147         return 0;
5148 
5149     // Flatten the point into the target plane
5150     FloatPoint targetPoint = transformState.mappedPoint();
5151 
5152     // Now map the point back through the transform, which computes Z.
5153     FloatPoint3D backmappedPoint = transformState.m_accumulatedTransform.mapPoint(FloatPoint3D(targetPoint));
5154     return backmappedPoint.z();
5155 }
5156 
5157 Ref&lt;HitTestingTransformState&gt; RenderLayer::createLocalTransformState(RenderLayer* rootLayer, RenderLayer* containerLayer,
5158                                         const LayoutRect&amp; hitTestRect, const HitTestLocation&amp; hitTestLocation,
5159                                         const HitTestingTransformState* containerTransformState,
5160                                         const LayoutSize&amp; translationOffset) const
5161 {
5162     RefPtr&lt;HitTestingTransformState&gt; transformState;
5163     LayoutSize offset;
5164     if (containerTransformState) {
5165         // If we&#39;re already computing transform state, then it&#39;s relative to the container (which we know is non-null).
5166         transformState = HitTestingTransformState::create(*containerTransformState);
5167         offset = offsetFromAncestor(containerLayer);
5168     } else {
5169         // If this is the first time we need to make transform state, then base it off of hitTestLocation,
5170         // which is relative to rootLayer.
5171         transformState = HitTestingTransformState::create(hitTestLocation.transformedPoint(), hitTestLocation.transformedRect(), FloatQuad(hitTestRect));
5172         offset = offsetFromAncestor(rootLayer);
5173     }
5174     offset += translationOffset;
5175 
5176     RenderObject* containerRenderer = containerLayer ? &amp;containerLayer-&gt;renderer() : nullptr;
5177     if (renderer().shouldUseTransformFromContainer(containerRenderer)) {
5178         TransformationMatrix containerTransform;
5179         renderer().getTransformFromContainer(containerRenderer, offset, containerTransform);
5180         transformState-&gt;applyTransform(containerTransform, HitTestingTransformState::AccumulateTransform);
5181     } else {
5182         transformState-&gt;translate(offset.width(), offset.height(), HitTestingTransformState::AccumulateTransform);
5183     }
5184 
5185     return transformState.releaseNonNull();
5186 }
5187 
5188 
5189 static bool isHitCandidate(const RenderLayer* hitLayer, bool canDepthSort, double* zOffset, const HitTestingTransformState* transformState)
5190 {
5191     if (!hitLayer)
5192         return false;
5193 
5194     // The hit layer is depth-sorting with other layers, so just say that it was hit.
5195     if (canDepthSort)
5196         return true;
5197 
5198     // We need to look at z-depth to decide if this layer was hit.
5199     if (zOffset) {
5200         ASSERT(transformState);
5201         // This is actually computing our z, but that&#39;s OK because the hitLayer is coplanar with us.
5202         double childZOffset = computeZOffset(*transformState);
5203         if (childZOffset &gt; *zOffset) {
5204             *zOffset = childZOffset;
5205             return true;
5206         }
5207         return false;
5208     }
5209 
5210     return true;
5211 }
5212 
5213 // hitTestLocation and hitTestRect are relative to rootLayer.
5214 // A &#39;flattening&#39; layer is one preserves3D() == false.
5215 // transformState.m_accumulatedTransform holds the transform from the containing flattening layer.
5216 // transformState.m_lastPlanarPoint is the hitTestLocation in the plane of the containing flattening layer.
5217 // transformState.m_lastPlanarQuad is the hitTestRect as a quad in the plane of the containing flattening layer.
5218 //
5219 // If zOffset is non-null (which indicates that the caller wants z offset information),
5220 //  *zOffset on return is the z offset of the hit point relative to the containing flattening layer.
5221 RenderLayer* RenderLayer::hitTestLayer(RenderLayer* rootLayer, RenderLayer* containerLayer, const HitTestRequest&amp; request, HitTestResult&amp; result,
5222                                        const LayoutRect&amp; hitTestRect, const HitTestLocation&amp; hitTestLocation, bool appliedTransform,
5223                                        const HitTestingTransformState* transformState, double* zOffset)
5224 {
5225     updateLayerListsIfNeeded();
5226 
5227     if (!isSelfPaintingLayer() &amp;&amp; !hasSelfPaintingLayerDescendant())
5228         return nullptr;
5229 
5230     // The natural thing would be to keep HitTestingTransformState on the stack, but it&#39;s big, so we heap-allocate.
5231 
5232     // Apply a transform if we have one.
5233     if (transform() &amp;&amp; !appliedTransform) {
5234         if (enclosingPaginationLayer(IncludeCompositedPaginatedLayers))
5235             return hitTestTransformedLayerInFragments(rootLayer, containerLayer, request, result, hitTestRect, hitTestLocation, transformState, zOffset);
5236 
5237         // Make sure the parent&#39;s clip rects have been calculated.
5238         if (parent()) {
5239             ClipRectsContext clipRectsContext(rootLayer, RootRelativeClipRects, IncludeOverlayScrollbarSize);
5240             ClipRect clipRect = backgroundClipRect(clipRectsContext);
5241             // Test the enclosing clip now.
5242             if (!clipRect.intersects(hitTestLocation))
5243                 return nullptr;
5244         }
5245 
5246         return hitTestLayerByApplyingTransform(rootLayer, containerLayer, request, result, hitTestRect, hitTestLocation, transformState, zOffset);
5247     }
5248 
5249     // Ensure our lists and 3d status are up-to-date.
5250     update3DTransformedDescendantStatus();
5251 
5252     RefPtr&lt;HitTestingTransformState&gt; localTransformState;
5253     if (appliedTransform) {
5254         // We computed the correct state in the caller (above code), so just reference it.
5255         ASSERT(transformState);
5256         localTransformState = const_cast&lt;HitTestingTransformState*&gt;(transformState);
5257     } else if (transformState || has3DTransformedDescendant() || preserves3D()) {
5258         // We need transform state for the first time, or to offset the container state, so create it here.
5259         localTransformState = createLocalTransformState(rootLayer, containerLayer, hitTestRect, hitTestLocation, transformState);
5260     }
5261 
5262     // Check for hit test on backface if backface-visibility is &#39;hidden&#39;
5263     if (localTransformState &amp;&amp; renderer().style().backfaceVisibility() == BackfaceVisibility::Hidden) {
5264         Optional&lt;TransformationMatrix&gt; invertedMatrix = localTransformState-&gt;m_accumulatedTransform.inverse();
5265         // If the z-vector of the matrix is negative, the back is facing towards the viewer.
5266         if (invertedMatrix &amp;&amp; invertedMatrix.value().m33() &lt; 0)
5267             return nullptr;
5268     }
5269 
5270     RefPtr&lt;HitTestingTransformState&gt; unflattenedTransformState = localTransformState;
5271     if (localTransformState &amp;&amp; !preserves3D()) {
5272         // Keep a copy of the pre-flattening state, for computing z-offsets for the container
5273         unflattenedTransformState = HitTestingTransformState::create(*localTransformState);
5274         // This layer is flattening, so flatten the state passed to descendants.
5275         localTransformState-&gt;flatten();
5276     }
5277 
5278     // The following are used for keeping track of the z-depth of the hit point of 3d-transformed
5279     // descendants.
5280     double localZOffset = -std::numeric_limits&lt;double&gt;::infinity();
5281     double* zOffsetForDescendantsPtr = nullptr;
5282     double* zOffsetForContentsPtr = nullptr;
5283 
5284     bool depthSortDescendants = false;
5285     if (preserves3D()) {
5286         depthSortDescendants = true;
5287         // Our layers can depth-test with our container, so share the z depth pointer with the container, if it passed one down.
5288         zOffsetForDescendantsPtr = zOffset ? zOffset : &amp;localZOffset;
5289         zOffsetForContentsPtr = zOffset ? zOffset : &amp;localZOffset;
5290     } else if (zOffset) {
5291         zOffsetForDescendantsPtr = nullptr;
5292         // Container needs us to give back a z offset for the hit layer.
5293         zOffsetForContentsPtr = zOffset;
5294     }
5295 
5296     // This variable tracks which layer the mouse ends up being inside.
5297     RenderLayer* candidateLayer = nullptr;
5298 #if !ASSERT_DISABLED
5299     LayerListMutationDetector mutationChecker(*this);
5300 #endif
5301 
5302     // Begin by walking our list of positive layers from highest z-index down to the lowest z-index.
5303     auto* hitLayer = hitTestList(positiveZOrderLayers(), rootLayer, request, result, hitTestRect, hitTestLocation,
5304                                         localTransformState.get(), zOffsetForDescendantsPtr, zOffset, unflattenedTransformState.get(), depthSortDescendants);
5305     if (hitLayer) {
5306         if (!depthSortDescendants)
5307             return hitLayer;
5308         candidateLayer = hitLayer;
5309     }
5310 
5311     // Now check our overflow objects.
5312     hitLayer = hitTestList(normalFlowLayers(), rootLayer, request, result, hitTestRect, hitTestLocation,
5313                            localTransformState.get(), zOffsetForDescendantsPtr, zOffset, unflattenedTransformState.get(), depthSortDescendants);
5314     if (hitLayer) {
5315         if (!depthSortDescendants)
5316             return hitLayer;
5317         candidateLayer = hitLayer;
5318     }
5319 
5320     // Collect the fragments. This will compute the clip rectangles for each layer fragment.
5321     LayerFragments layerFragments;
5322     collectFragments(layerFragments, rootLayer, hitTestRect, IncludeCompositedPaginatedLayers, RootRelativeClipRects, IncludeOverlayScrollbarSize, RespectOverflowClip,
5323         offsetFromAncestor(rootLayer));
5324 
5325     if (canResize() &amp;&amp; hitTestResizerInFragments(layerFragments, hitTestLocation)) {
5326         renderer().updateHitTestResult(result, hitTestLocation.point());
5327         return this;
5328     }
5329 
5330     // Next we want to see if the mouse pos is inside the child RenderObjects of the layer. Check
5331     // every fragment in reverse order.
5332     if (isSelfPaintingLayer()) {
5333         // Hit test with a temporary HitTestResult, because we only want to commit to &#39;result&#39; if we know we&#39;re frontmost.
5334         HitTestResult tempResult(result.hitTestLocation());
5335         bool insideFragmentForegroundRect = false;
5336         if (hitTestContentsForFragments(layerFragments, request, tempResult, hitTestLocation, HitTestDescendants, insideFragmentForegroundRect)
5337             &amp;&amp; isHitCandidate(this, false, zOffsetForContentsPtr, unflattenedTransformState.get())) {
5338             if (request.resultIsElementList())
5339                 result.append(tempResult, request);
5340             else
5341                 result = tempResult;
5342             if (!depthSortDescendants)
5343                 return this;
5344             // Foreground can depth-sort with descendant layers, so keep this as a candidate.
5345             candidateLayer = this;
5346         } else if (insideFragmentForegroundRect &amp;&amp; request.resultIsElementList())
5347             result.append(tempResult, request);
5348     }
5349 
5350     // Now check our negative z-index children.
5351     hitLayer = hitTestList(negativeZOrderLayers(), rootLayer, request, result, hitTestRect, hitTestLocation,
5352         localTransformState.get(), zOffsetForDescendantsPtr, zOffset, unflattenedTransformState.get(), depthSortDescendants);
5353     if (hitLayer) {
5354         if (!depthSortDescendants)
5355             return hitLayer;
5356         candidateLayer = hitLayer;
5357     }
5358 
5359     // If we found a layer, return. Child layers, and foreground always render in front of background.
5360     if (candidateLayer)
5361         return candidateLayer;
5362 
5363     if (isSelfPaintingLayer()) {
5364         HitTestResult tempResult(result.hitTestLocation());
5365         bool insideFragmentBackgroundRect = false;
5366         if (hitTestContentsForFragments(layerFragments, request, tempResult, hitTestLocation, HitTestSelf, insideFragmentBackgroundRect)
5367             &amp;&amp; isHitCandidate(this, false, zOffsetForContentsPtr, unflattenedTransformState.get())) {
5368             if (request.resultIsElementList())
5369                 result.append(tempResult, request);
5370             else
5371                 result = tempResult;
5372             return this;
5373         }
5374         if (insideFragmentBackgroundRect &amp;&amp; request.resultIsElementList())
5375             result.append(tempResult, request);
5376     }
5377 
5378     return nullptr;
5379 }
5380 
5381 bool RenderLayer::hitTestContentsForFragments(const LayerFragments&amp; layerFragments, const HitTestRequest&amp; request, HitTestResult&amp; result,
5382     const HitTestLocation&amp; hitTestLocation, HitTestFilter hitTestFilter, bool&amp; insideClipRect) const
5383 {
5384     if (layerFragments.isEmpty())
5385         return false;
5386 
5387     for (int i = layerFragments.size() - 1; i &gt;= 0; --i) {
5388         const LayerFragment&amp; fragment = layerFragments.at(i);
5389         if ((hitTestFilter == HitTestSelf &amp;&amp; !fragment.backgroundRect.intersects(hitTestLocation))
5390             || (hitTestFilter == HitTestDescendants &amp;&amp; !fragment.foregroundRect.intersects(hitTestLocation)))
5391             continue;
5392         insideClipRect = true;
5393         if (hitTestContents(request, result, fragment.layerBounds, hitTestLocation, hitTestFilter))
5394             return true;
5395     }
5396 
5397     return false;
5398 }
5399 
5400 bool RenderLayer::hitTestResizerInFragments(const LayerFragments&amp; layerFragments, const HitTestLocation&amp; hitTestLocation) const
5401 {
5402     if (layerFragments.isEmpty())
5403         return false;
5404 
5405     for (int i = layerFragments.size() - 1; i &gt;= 0; --i) {
5406         const LayerFragment&amp; fragment = layerFragments.at(i);
5407         if (fragment.backgroundRect.intersects(hitTestLocation) &amp;&amp; resizerCornerRect(*this, snappedIntRect(fragment.layerBounds)).contains(hitTestLocation.roundedPoint()))
5408             return true;
5409     }
5410 
5411     return false;
5412 }
5413 
5414 RenderLayer* RenderLayer::hitTestTransformedLayerInFragments(RenderLayer* rootLayer, RenderLayer* containerLayer, const HitTestRequest&amp; request, HitTestResult&amp; result,
5415     const LayoutRect&amp; hitTestRect, const HitTestLocation&amp; hitTestLocation, const HitTestingTransformState* transformState, double* zOffset)
5416 {
5417     LayerFragments enclosingPaginationFragments;
5418     LayoutSize offsetOfPaginationLayerFromRoot;
5419     RenderLayer* paginatedLayer = enclosingPaginationLayer(IncludeCompositedPaginatedLayers);
5420     LayoutRect transformedExtent = transparencyClipBox(*this, paginatedLayer, HitTestingTransparencyClipBox, RootOfTransparencyClipBox);
5421     paginatedLayer-&gt;collectFragments(enclosingPaginationFragments, rootLayer, hitTestRect, IncludeCompositedPaginatedLayers,
5422         RootRelativeClipRects, IncludeOverlayScrollbarSize, RespectOverflowClip, offsetOfPaginationLayerFromRoot, &amp;transformedExtent);
5423 
5424     for (int i = enclosingPaginationFragments.size() - 1; i &gt;= 0; --i) {
5425         const LayerFragment&amp; fragment = enclosingPaginationFragments.at(i);
5426 
5427         // Apply the page/column clip for this fragment, as well as any clips established by layers in between us and
5428         // the enclosing pagination layer.
5429         LayoutRect clipRect = fragment.backgroundRect.rect();
5430 
5431         // Now compute the clips within a given fragment
5432         if (parent() != paginatedLayer) {
5433             offsetOfPaginationLayerFromRoot = toLayoutSize(paginatedLayer-&gt;convertToLayerCoords(rootLayer, toLayoutPoint(offsetOfPaginationLayerFromRoot)));
5434 
5435             ClipRectsContext clipRectsContext(paginatedLayer, RootRelativeClipRects, IncludeOverlayScrollbarSize);
5436             LayoutRect parentClipRect = backgroundClipRect(clipRectsContext).rect();
5437             parentClipRect.move(fragment.paginationOffset + offsetOfPaginationLayerFromRoot);
5438             clipRect.intersect(parentClipRect);
5439         }
5440 
5441         if (!hitTestLocation.intersects(clipRect))
5442             continue;
5443 
5444         RenderLayer* hitLayer = hitTestLayerByApplyingTransform(rootLayer, containerLayer, request, result, hitTestRect, hitTestLocation,
5445             transformState, zOffset, fragment.paginationOffset);
5446         if (hitLayer)
5447             return hitLayer;
5448     }
5449 
5450     return nullptr;
5451 }
5452 
5453 RenderLayer* RenderLayer::hitTestLayerByApplyingTransform(RenderLayer* rootLayer, RenderLayer* containerLayer, const HitTestRequest&amp; request, HitTestResult&amp; result,
5454     const LayoutRect&amp; hitTestRect, const HitTestLocation&amp; hitTestLocation, const HitTestingTransformState* transformState, double* zOffset,
5455     const LayoutSize&amp; translationOffset)
5456 {
5457     // Create a transform state to accumulate this transform.
5458     Ref&lt;HitTestingTransformState&gt; newTransformState = createLocalTransformState(rootLayer, containerLayer, hitTestRect, hitTestLocation, transformState, translationOffset);
5459 
5460     // If the transform can&#39;t be inverted, then don&#39;t hit test this layer at all.
5461     if (!newTransformState-&gt;m_accumulatedTransform.isInvertible())
5462         return nullptr;
5463 
5464     // Compute the point and the hit test rect in the coords of this layer by using the values
5465     // from the transformState, which store the point and quad in the coords of the last flattened
5466     // layer, and the accumulated transform which lets up map through preserve-3d layers.
5467     //
5468     // We can&#39;t just map hitTestLocation and hitTestRect because they may have been flattened (losing z)
5469     // by our container.
5470     FloatPoint localPoint = newTransformState-&gt;mappedPoint();
5471     FloatQuad localPointQuad = newTransformState-&gt;mappedQuad();
5472     LayoutRect localHitTestRect = newTransformState-&gt;boundsOfMappedArea();
5473     HitTestLocation newHitTestLocation;
5474     if (hitTestLocation.isRectBasedTest())
5475         newHitTestLocation = HitTestLocation(localPoint, localPointQuad);
5476     else
5477         newHitTestLocation = HitTestLocation(localPoint);
5478 
5479     // Now do a hit test with the root layer shifted to be us.
5480     return hitTestLayer(this, containerLayer, request, result, localHitTestRect, newHitTestLocation, true, newTransformState.ptr(), zOffset);
5481 }
5482 
5483 bool RenderLayer::hitTestContents(const HitTestRequest&amp; request, HitTestResult&amp; result, const LayoutRect&amp; layerBounds, const HitTestLocation&amp; hitTestLocation, HitTestFilter hitTestFilter) const
5484 {
5485     ASSERT(isSelfPaintingLayer() || hasSelfPaintingLayerDescendant());
5486 
5487     if (!renderer().hitTest(request, result, hitTestLocation, toLayoutPoint(layerBounds.location() - renderBoxLocation()), hitTestFilter)) {
5488         // It&#39;s wrong to set innerNode, but then claim that you didn&#39;t hit anything, unless it is
5489         // a rect-based test.
5490         ASSERT(!result.innerNode() || (request.resultIsElementList() &amp;&amp; result.listBasedTestResult().size()));
5491         return false;
5492     }
5493 
5494     // For positioned generated content, we might still not have a
5495     // node by the time we get to the layer level, since none of
5496     // the content in the layer has an element. So just walk up
5497     // the tree.
5498     if (!result.innerNode() || !result.innerNonSharedNode()) {
5499         if (isOutOfFlowRenderFragmentedFlow()) {
5500             // The flowthread doesn&#39;t have an enclosing element, so when hitting the layer of the
5501             // flowthread (e.g. the descent area of the RootInlineBox for the image flowed alone
5502             // inside the flow thread) we&#39;re letting the hit testing continue so it will hit the region.
5503             return false;
5504         }
5505 
5506         Element* e = enclosingElement();
5507         if (!result.innerNode())
5508             result.setInnerNode(e);
5509         if (!result.innerNonSharedNode())
5510             result.setInnerNonSharedNode(e);
5511     }
5512 
5513     return true;
5514 }
5515 
5516 RenderLayer* RenderLayer::hitTestList(LayerList layerIterator, RenderLayer* rootLayer,
5517                                       const HitTestRequest&amp; request, HitTestResult&amp; result,
5518                                       const LayoutRect&amp; hitTestRect, const HitTestLocation&amp; hitTestLocation,
5519                                       const HitTestingTransformState* transformState,
5520                                       double* zOffsetForDescendants, double* zOffset,
5521                                       const HitTestingTransformState* unflattenedTransformState,
5522                                       bool depthSortDescendants)
5523 {
5524     if (layerIterator.begin() == layerIterator.end())
5525         return nullptr;
5526 
5527     if (!hasSelfPaintingLayerDescendant())
5528         return nullptr;
5529 
5530     RenderLayer* resultLayer = nullptr;
5531 
5532     for (auto iter = layerIterator.rbegin(); iter != layerIterator.rend(); ++iter) {
5533         auto* childLayer = *iter;
5534 
5535         HitTestResult tempResult(result.hitTestLocation());
5536         auto* hitLayer = childLayer-&gt;hitTestLayer(rootLayer, this, request, tempResult, hitTestRect, hitTestLocation, false, transformState, zOffsetForDescendants);
5537 
5538         // If it is a list-based test, we can safely append the temporary result since it might had hit
5539         // nodes but not necesserily had hitLayer set.
5540         ASSERT(!result.isRectBasedTest() || request.resultIsElementList());
5541         if (request.resultIsElementList())
5542             result.append(tempResult, request);
5543 
5544         if (isHitCandidate(hitLayer, depthSortDescendants, zOffset, unflattenedTransformState)) {
5545             resultLayer = hitLayer;
5546             if (!request.resultIsElementList())
5547                 result = tempResult;
5548             if (!depthSortDescendants)
5549                 break;
5550         }
5551     }
5552 
5553     return resultLayer;
5554 }
5555 
5556 Ref&lt;ClipRects&gt; RenderLayer::updateClipRects(const ClipRectsContext&amp; clipRectsContext)
5557 {
5558     ClipRectsType clipRectsType = clipRectsContext.clipRectsType;
5559     ASSERT(clipRectsType &lt; NumCachedClipRectsTypes);
5560     if (m_clipRectsCache) {
5561         if (auto* clipRects = m_clipRectsCache-&gt;getClipRects(clipRectsType, clipRectsContext.respectOverflowClip)) {
5562             ASSERT(clipRectsContext.rootLayer == m_clipRectsCache-&gt;m_clipRectsRoot[clipRectsType]);
5563             ASSERT(m_clipRectsCache-&gt;m_scrollbarRelevancy[clipRectsType] == clipRectsContext.overlayScrollbarSizeRelevancy);
5564 
5565 #ifdef CHECK_CACHED_CLIP_RECTS
5566             // This code is useful to check cached clip rects, but is too expensive to leave enabled in debug builds by default.
5567             ClipRectsContext tempContext(clipRectsContext);
5568             tempContext.clipRectsType = TemporaryClipRects;
5569             Ref&lt;ClipRects&gt; tempClipRects = ClipRects::create();
5570             calculateClipRects(tempContext, tempClipRects);
5571             ASSERT(tempClipRects.get() == *clipRects);
5572 #endif
5573             return *clipRects; // We have the correct cached value.
5574         }
5575     }
5576 
5577     if (!m_clipRectsCache)
<a name="95" id="anc95"></a><span class="line-modified">5578         m_clipRectsCache = makeUnique&lt;ClipRectsCache&gt;();</span>
5579 #ifndef NDEBUG
5580     m_clipRectsCache-&gt;m_clipRectsRoot[clipRectsType] = clipRectsContext.rootLayer;
5581     m_clipRectsCache-&gt;m_scrollbarRelevancy[clipRectsType] = clipRectsContext.overlayScrollbarSizeRelevancy;
5582 #endif
5583 
5584     RefPtr&lt;ClipRects&gt; parentClipRects;
5585     // For transformed layers, the root layer was shifted to be us, so there is no need to
5586     // examine the parent. We want to cache clip rects with us as the root.
<a name="96" id="anc96"></a><span class="line-modified">5587     if (clipRectsContext.rootLayer != this &amp;&amp; parent())</span>
<span class="line-modified">5588         parentClipRects = this-&gt;parentClipRects(clipRectsContext);</span>
5589 
5590     auto clipRects = ClipRects::create();
5591     calculateClipRects(clipRectsContext, clipRects);
5592 
5593     if (parentClipRects &amp;&amp; *parentClipRects == clipRects) {
5594         m_clipRectsCache-&gt;setClipRects(clipRectsType, clipRectsContext.respectOverflowClip, parentClipRects.copyRef());
5595         return parentClipRects.releaseNonNull();
5596     }
5597     m_clipRectsCache-&gt;setClipRects(clipRectsType, clipRectsContext.respectOverflowClip, clipRects.copyRef());
5598     return clipRects;
5599 }
5600 
5601 ClipRects* RenderLayer::clipRects(const ClipRectsContext&amp; context) const
5602 {
5603     ASSERT(context.clipRectsType &lt; NumCachedClipRectsTypes);
5604     if (!m_clipRectsCache)
5605         return nullptr;
5606     return m_clipRectsCache-&gt;getClipRects(context.clipRectsType, context.respectOverflowClip);
5607 }
5608 
<a name="97" id="anc97"></a><span class="line-added">5609 bool RenderLayer::clipCrossesPaintingBoundary() const</span>
<span class="line-added">5610 {</span>
<span class="line-added">5611     return parent()-&gt;enclosingPaginationLayer(IncludeCompositedPaginatedLayers) != enclosingPaginationLayer(IncludeCompositedPaginatedLayers)</span>
<span class="line-added">5612         || parent()-&gt;enclosingCompositingLayerForRepaint() != enclosingCompositingLayerForRepaint();</span>
<span class="line-added">5613 }</span>
<span class="line-added">5614 </span>
5615 void RenderLayer::calculateClipRects(const ClipRectsContext&amp; clipRectsContext, ClipRects&amp; clipRects) const
5616 {
5617     if (!parent()) {
5618         // The root layer&#39;s clip rect is always infinite.
5619         clipRects.reset();
5620         return;
5621     }
5622 
5623     ClipRectsType clipRectsType = clipRectsContext.clipRectsType;
5624     bool useCached = clipRectsType != TemporaryClipRects;
5625 
5626     // For transformed layers, the root layer was shifted to be us, so there is no need to
5627     // examine the parent. We want to cache clip rects with us as the root.
5628     RenderLayer* parentLayer = clipRectsContext.rootLayer != this ? parent() : nullptr;
5629 
5630     // Ensure that our parent&#39;s clip has been calculated so that we can examine the values.
5631     if (parentLayer) {
5632         if (useCached &amp;&amp; parentLayer-&gt;clipRects(clipRectsContext))
5633             clipRects = *parentLayer-&gt;clipRects(clipRectsContext);
5634         else {
5635             ClipRectsContext parentContext(clipRectsContext);
5636             parentContext.overlayScrollbarSizeRelevancy = IgnoreOverlayScrollbarSize; // FIXME: why?
<a name="98" id="anc98"></a><span class="line-added">5637 </span>
<span class="line-added">5638             if ((parentContext.clipRectsType != TemporaryClipRects &amp;&amp; parentContext.clipRectsType != AbsoluteClipRects) &amp;&amp; clipCrossesPaintingBoundary())</span>
<span class="line-added">5639                 parentContext.clipRectsType = TemporaryClipRects;</span>
<span class="line-added">5640 </span>
5641             parentLayer-&gt;calculateClipRects(parentContext, clipRects);
5642         }
5643     } else
5644         clipRects.reset();
5645 
5646     // A fixed object is essentially the root of its containing block hierarchy, so when
5647     // we encounter such an object, we reset our clip rects to the fixedClipRect.
5648     if (renderer().isFixedPositioned()) {
5649         clipRects.setPosClipRect(clipRects.fixedClipRect());
5650         clipRects.setOverflowClipRect(clipRects.fixedClipRect());
5651         clipRects.setFixed(true);
5652     } else if (renderer().isInFlowPositioned())
5653         clipRects.setPosClipRect(clipRects.overflowClipRect());
5654     else if (renderer().isAbsolutelyPositioned())
5655         clipRects.setOverflowClipRect(clipRects.posClipRect());
5656 
5657     // Update the clip rects that will be passed to child layers.
5658 #if PLATFORM(IOS_FAMILY)
5659     if (renderer().hasClipOrOverflowClip() &amp;&amp; (clipRectsContext.respectOverflowClip == RespectOverflowClip || this != clipRectsContext.rootLayer)) {
5660 #else
5661     if ((renderer().hasOverflowClip() &amp;&amp; (clipRectsContext.respectOverflowClip == RespectOverflowClip || this != clipRectsContext.rootLayer)) || renderer().hasClip()) {
5662 #endif
5663         // This layer establishes a clip of some kind.
<a name="99" id="anc99"></a><span class="line-added">5664         LayoutPoint offset;</span>
<span class="line-added">5665         if (!m_hasTransformedAncestor &amp;&amp; canUseOffsetFromAncestor())</span>
<span class="line-added">5666             offset = toLayoutPoint(offsetFromAncestor(clipRectsContext.rootLayer, AdjustForColumns));</span>
<span class="line-added">5667         else</span>
<span class="line-added">5668             offset = LayoutPoint(renderer().localToContainerPoint(FloatPoint(), &amp;clipRectsContext.rootLayer-&gt;renderer()));</span>
5669 
<a name="100" id="anc100"></a>



5670         if (clipRects.fixed() &amp;&amp; &amp;clipRectsContext.rootLayer-&gt;renderer() == &amp;renderer().view())
5671             offset -= toLayoutSize(renderer().view().frameView().scrollPositionForFixedPosition());
5672 
5673         if (renderer().hasOverflowClip()) {
5674             ClipRect newOverflowClip = downcast&lt;RenderBox&gt;(renderer()).overflowClipRectForChildLayers(offset, nullptr, clipRectsContext.overlayScrollbarSizeRelevancy);
5675             newOverflowClip.setAffectedByRadius(renderer().style().hasBorderRadius());
5676             clipRects.setOverflowClipRect(intersection(newOverflowClip, clipRects.overflowClipRect()));
5677             if (renderer().isPositioned())
5678                 clipRects.setPosClipRect(intersection(newOverflowClip, clipRects.posClipRect()));
5679         }
5680         if (renderer().hasClip()) {
5681             LayoutRect newPosClip = downcast&lt;RenderBox&gt;(renderer()).clipRect(offset, nullptr);
5682             clipRects.setPosClipRect(intersection(newPosClip, clipRects.posClipRect()));
5683             clipRects.setOverflowClipRect(intersection(newPosClip, clipRects.overflowClipRect()));
5684             clipRects.setFixedClipRect(intersection(newPosClip, clipRects.fixedClipRect()));
5685         }
5686     }
<a name="101" id="anc101"></a><span class="line-added">5687 </span>
<span class="line-added">5688     LOG_WITH_STREAM(ClipRects, stream &lt;&lt; &quot;RenderLayer &quot; &lt;&lt; this &lt;&lt; &quot; calculateClipRects &quot; &lt;&lt; clipRects);</span>
5689 }
5690 
5691 Ref&lt;ClipRects&gt; RenderLayer::parentClipRects(const ClipRectsContext&amp; clipRectsContext) const
5692 {
5693     ASSERT(parent());
5694 
<a name="102" id="anc102"></a><span class="line-modified">5695     auto temporaryParentClipRects = [&amp;](const ClipRectsContext&amp; clipContext) {</span>
5696         auto parentClipRects = ClipRects::create();
<a name="103" id="anc103"></a><span class="line-modified">5697         parent()-&gt;calculateClipRects(clipContext, parentClipRects);</span>
5698         return parentClipRects;
<a name="104" id="anc104"></a><span class="line-added">5699     };</span>
<span class="line-added">5700 </span>
<span class="line-added">5701     if (clipRectsContext.clipRectsType == TemporaryClipRects)</span>
<span class="line-added">5702         return temporaryParentClipRects(clipRectsContext);</span>
<span class="line-added">5703 </span>
<span class="line-added">5704     if (clipRectsContext.clipRectsType != AbsoluteClipRects &amp;&amp; clipCrossesPaintingBoundary()) {</span>
<span class="line-added">5705         ClipRectsContext tempClipRectsContext(clipRectsContext);</span>
<span class="line-added">5706         tempClipRectsContext.clipRectsType = TemporaryClipRects;</span>
<span class="line-added">5707         return temporaryParentClipRects(tempClipRectsContext);</span>
5708     }
5709 
5710     return parent()-&gt;updateClipRects(clipRectsContext);
5711 }
5712 
5713 static inline ClipRect backgroundClipRectForPosition(const ClipRects&amp; parentRects, PositionType position)
5714 {
5715     if (position == PositionType::Fixed)
5716         return parentRects.fixedClipRect();
5717 
5718     if (position == PositionType::Absolute)
5719         return parentRects.posClipRect();
5720 
5721     return parentRects.overflowClipRect();
5722 }
5723 
5724 ClipRect RenderLayer::backgroundClipRect(const ClipRectsContext&amp; clipRectsContext) const
5725 {
5726     ASSERT(parent());
<a name="105" id="anc105"></a><span class="line-modified">5727     auto parentRects = parentClipRects(clipRectsContext);</span>














5728     ClipRect backgroundClipRect = backgroundClipRectForPosition(parentRects, renderer().style().position());
5729     RenderView&amp; view = renderer().view();
5730     // Note: infinite clipRects should not be scrolled here, otherwise they will accidentally no longer be considered infinite.
5731     if (parentRects-&gt;fixed() &amp;&amp; &amp;clipRectsContext.rootLayer-&gt;renderer() == &amp;view &amp;&amp; !backgroundClipRect.isInfinite())
5732         backgroundClipRect.moveBy(view.frameView().scrollPositionForFixedPosition());
<a name="106" id="anc106"></a><span class="line-added">5733 </span>
<span class="line-added">5734     LOG_WITH_STREAM(ClipRects, stream &lt;&lt; &quot;RenderLayer &quot; &lt;&lt; this &lt;&lt; &quot; backgroundClipRect with context &quot; &lt;&lt; clipRectsContext &lt;&lt; &quot; returning &quot; &lt;&lt; backgroundClipRect);</span>
5735     return backgroundClipRect;
5736 }
5737 
5738 void RenderLayer::calculateRects(const ClipRectsContext&amp; clipRectsContext, const LayoutRect&amp; paintDirtyRect, LayoutRect&amp; layerBounds,
5739     ClipRect&amp; backgroundRect, ClipRect&amp; foregroundRect, const LayoutSize&amp; offsetFromRoot) const
5740 {
5741     if (clipRectsContext.rootLayer != this &amp;&amp; parent()) {
5742         backgroundRect = backgroundClipRect(clipRectsContext);
5743         backgroundRect.intersect(paintDirtyRect);
5744     } else
5745         backgroundRect = paintDirtyRect;
5746 
5747     LayoutSize offsetFromRootLocal = offsetFromRoot;
5748 
5749     if (clipRectsContext.rootLayer-&gt;isOutOfFlowRenderFragmentedFlow()) {
5750         LayoutPoint absPos = LayoutPoint(renderer().view().localToAbsolute(FloatPoint(), IsFixed));
5751         offsetFromRootLocal += toLayoutSize(absPos);
5752     }
5753 
5754     layerBounds = LayoutRect(toLayoutPoint(offsetFromRootLocal), size());
5755 
5756     foregroundRect = backgroundRect;
5757 
5758     // Update the clip rects that will be passed to child layers.
5759     if (renderer().hasClipOrOverflowClip()) {
5760         // This layer establishes a clip of some kind.
5761         if (renderer().hasOverflowClip() &amp;&amp; (this != clipRectsContext.rootLayer || clipRectsContext.respectOverflowClip == RespectOverflowClip)) {
5762             foregroundRect.intersect(downcast&lt;RenderBox&gt;(renderer()).overflowClipRect(toLayoutPoint(offsetFromRootLocal), nullptr, clipRectsContext.overlayScrollbarSizeRelevancy));
5763             if (renderer().style().hasBorderRadius())
5764                 foregroundRect.setAffectedByRadius(true);
5765         }
5766 
5767         if (renderer().hasClip()) {
5768             // Clip applies to *us* as well, so update the damageRect.
5769             LayoutRect newPosClip = downcast&lt;RenderBox&gt;(renderer()).clipRect(toLayoutPoint(offsetFromRootLocal), nullptr);
5770             backgroundRect.intersect(newPosClip);
5771             foregroundRect.intersect(newPosClip);
5772         }
5773 
5774         // If we establish a clip at all, then make sure our background rect is intersected with our layer&#39;s bounds including our visual overflow,
5775         // since any visual overflow like box-shadow or border-outset is not clipped by overflow:auto/hidden.
5776         if (renderBox()-&gt;hasVisualOverflow()) {
5777             // FIXME: Does not do the right thing with CSS regions yet, since we don&#39;t yet factor in the
5778             // individual region boxes as overflow.
5779             LayoutRect layerBoundsWithVisualOverflow = renderBox()-&gt;visualOverflowRect();
5780             renderBox()-&gt;flipForWritingMode(layerBoundsWithVisualOverflow); // Layers are in physical coordinates, so the overflow has to be flipped.
5781             layerBoundsWithVisualOverflow.move(offsetFromRootLocal);
5782             if (this != clipRectsContext.rootLayer || clipRectsContext.respectOverflowClip == RespectOverflowClip)
5783                 backgroundRect.intersect(layerBoundsWithVisualOverflow);
5784         } else {
5785             // Shift the bounds to be for our region only.
5786             LayoutRect bounds = renderBox()-&gt;borderBoxRectInFragment(nullptr);
5787 
5788             bounds.move(offsetFromRootLocal);
5789             if (this != clipRectsContext.rootLayer || clipRectsContext.respectOverflowClip == RespectOverflowClip)
5790                 backgroundRect.intersect(bounds);
5791         }
5792     }
5793 }
5794 
5795 LayoutRect RenderLayer::childrenClipRect() const
5796 {
5797     // FIXME: border-radius not accounted for.
5798     // FIXME: Regions not accounted for.
5799     RenderLayer* clippingRootLayer = clippingRootForPainting();
5800     LayoutRect layerBounds;
5801     ClipRect backgroundRect;
5802     ClipRect foregroundRect;
5803     ClipRectsContext clipRectsContext(clippingRootLayer, TemporaryClipRects);
5804     // Need to use temporary clip rects, because the value of &#39;dontClipToOverflow&#39; may be different from the painting path (&lt;rdar://problem/11844909&gt;).
5805     calculateRects(clipRectsContext, LayoutRect::infiniteRect(), layerBounds, backgroundRect, foregroundRect, offsetFromAncestor(clipRectsContext.rootLayer));
5806     if (foregroundRect.rect().isInfinite())
5807         return renderer().view().unscaledDocumentRect();
5808 
5809     auto absoluteClippingRect = clippingRootLayer-&gt;renderer().localToAbsoluteQuad(FloatQuad(foregroundRect.rect())).enclosingBoundingBox();
5810     return intersection(absoluteClippingRect, renderer().view().unscaledDocumentRect());
5811 }
5812 
5813 LayoutRect RenderLayer::clipRectRelativeToAncestor(RenderLayer* ancestor, LayoutSize offsetFromAncestor, const LayoutRect&amp; constrainingRect) const
5814 {
5815     LayoutRect layerBounds;
5816     ClipRect backgroundRect;
5817     ClipRect foregroundRect;
5818     auto clipRectType = !m_enclosingPaginationLayer || m_enclosingPaginationLayer == ancestor ? PaintingClipRects : TemporaryClipRects;
5819     ClipRectsContext clipRectsContext(ancestor, clipRectType);
5820     calculateRects(clipRectsContext, constrainingRect, layerBounds, backgroundRect, foregroundRect, offsetFromAncestor);
5821     return backgroundRect.rect();
5822 }
5823 
5824 LayoutRect RenderLayer::selfClipRect() const
5825 {
5826     // FIXME: border-radius not accounted for.
5827     // FIXME: Regions not accounted for.
5828     RenderLayer* clippingRootLayer = clippingRootForPainting();
5829     LayoutRect clipRect = clipRectRelativeToAncestor(clippingRootLayer, offsetFromAncestor(clippingRootLayer), renderer().view().documentRect());
5830     return clippingRootLayer-&gt;renderer().localToAbsoluteQuad(FloatQuad(clipRect)).enclosingBoundingBox();
5831 }
5832 
5833 LayoutRect RenderLayer::localClipRect(bool&amp; clipExceedsBounds) const
5834 {
5835     clipExceedsBounds = false;
5836     // FIXME: border-radius not accounted for.
5837     // FIXME: Regions not accounted for.
5838     RenderLayer* clippingRootLayer = clippingRootForPainting();
5839     LayoutSize offsetFromRoot = offsetFromAncestor(clippingRootLayer);
5840     LayoutRect clipRect = clipRectRelativeToAncestor(clippingRootLayer, offsetFromRoot, LayoutRect::infiniteRect());
5841     if (clipRect.isInfinite())
5842         return clipRect;
5843 
5844     if (renderer().hasClip()) {
5845         // CSS clip may be larger than our border box.
5846         LayoutRect cssClipRect = downcast&lt;RenderBox&gt;(renderer()).clipRect(toLayoutPoint(offsetFromRoot), nullptr);
5847         clipExceedsBounds = !clipRect.contains(cssClipRect);
5848     }
5849 
5850     clipRect.move(-offsetFromRoot);
5851     return clipRect;
5852 }
5853 
5854 void RenderLayer::addBlockSelectionGapsBounds(const LayoutRect&amp; bounds)
5855 {
5856     m_blockSelectionGapsBounds.unite(enclosingIntRect(bounds));
5857 }
5858 
5859 void RenderLayer::clearBlockSelectionGapsBounds()
5860 {
5861     m_blockSelectionGapsBounds = IntRect();
5862     for (RenderLayer* child = firstChild(); child; child = child-&gt;nextSibling())
5863         child-&gt;clearBlockSelectionGapsBounds();
5864 }
5865 
5866 void RenderLayer::repaintBlockSelectionGaps()
5867 {
5868     for (RenderLayer* child = firstChild(); child; child = child-&gt;nextSibling())
5869         child-&gt;repaintBlockSelectionGaps();
5870 
5871     if (m_blockSelectionGapsBounds.isEmpty())
5872         return;
5873 
5874     LayoutRect rect = m_blockSelectionGapsBounds;
5875     rect.moveBy(-scrollPosition());
5876     if (renderer().hasOverflowClip() &amp;&amp; !usesCompositedScrolling())
5877         rect.intersect(downcast&lt;RenderBox&gt;(renderer()).overflowClipRect(LayoutPoint(), nullptr)); // FIXME: Regions not accounted for.
5878     if (renderer().hasClip())
5879         rect.intersect(downcast&lt;RenderBox&gt;(renderer()).clipRect(LayoutPoint(), nullptr)); // FIXME: Regions not accounted for.
5880     if (!rect.isEmpty())
5881         renderer().repaintRectangle(rect);
5882 }
5883 
5884 bool RenderLayer::intersectsDamageRect(const LayoutRect&amp; layerBounds, const LayoutRect&amp; damageRect, const RenderLayer* rootLayer, const LayoutSize&amp; offsetFromRoot, const LayoutRect* cachedBoundingBox) const
5885 {
5886     // Always examine the canvas and the root.
5887     // FIXME: Could eliminate the isDocumentElementRenderer() check if we fix background painting so that the RenderView
5888     // paints the root&#39;s background.
5889     if (isRenderViewLayer() || renderer().isDocumentElementRenderer())
5890         return true;
5891 
5892     if (damageRect.isInfinite())
5893         return true;
5894 
5895     if (damageRect.isEmpty())
5896         return false;
5897 
5898     // If we aren&#39;t an inline flow, and our layer bounds do intersect the damage rect, then we can return true.
5899     if (!renderer().isRenderInline() &amp;&amp; layerBounds.intersects(damageRect))
5900         return true;
5901 
5902     // Otherwise we need to compute the bounding box of this single layer and see if it intersects
5903     // the damage rect. It&#39;s possible the fragment computed the bounding box already, in which case we
5904     // can use the cached value.
5905     if (cachedBoundingBox)
5906         return cachedBoundingBox-&gt;intersects(damageRect);
5907 
5908     return boundingBox(rootLayer, offsetFromRoot).intersects(damageRect);
5909 }
5910 
5911 LayoutRect RenderLayer::localBoundingBox(OptionSet&lt;CalculateLayerBoundsFlag&gt; flags) const
5912 {
5913     // There are three special cases we need to consider.
5914     // (1) Inline Flows.  For inline flows we will create a bounding box that fully encompasses all of the lines occupied by the
5915     // inline.  In other words, if some &lt;span&gt; wraps to three lines, we&#39;ll create a bounding box that fully encloses the
5916     // line boxes of all three lines (including overflow on those lines).
5917     // (2) Left/Top Overflow.  The width/height of layers already includes right/bottom overflow.  However, in the case of left/top
5918     // overflow, we have to create a bounding box that will extend to include this overflow.
5919     // (3) Floats.  When a layer has overhanging floats that it paints, we need to make sure to include these overhanging floats
5920     // as part of our bounding box.  We do this because we are the responsible layer for both hit testing and painting those
5921     // floats.
5922     LayoutRect result;
5923     if (renderer().isInline() &amp;&amp; is&lt;RenderInline&gt;(renderer()))
5924         result = downcast&lt;RenderInline&gt;(renderer()).linesVisualOverflowBoundingBox();
5925     else if (is&lt;RenderTableRow&gt;(renderer())) {
5926         auto&amp; tableRow = downcast&lt;RenderTableRow&gt;(renderer());
5927         // Our bounding box is just the union of all of our cells&#39; border/overflow rects.
5928         for (RenderTableCell* cell = tableRow.firstCell(); cell; cell = cell-&gt;nextCell()) {
5929             LayoutRect bbox = cell-&gt;borderBoxRect();
5930             result.unite(bbox);
5931             LayoutRect overflowRect = tableRow.visualOverflowRect();
5932             if (bbox != overflowRect)
5933                 result.unite(overflowRect);
5934         }
5935     } else {
5936         RenderBox* box = renderBox();
5937         ASSERT(box);
5938         if (!(flags &amp; DontConstrainForMask) &amp;&amp; box-&gt;hasMask()) {
5939             result = box-&gt;maskClipRect(LayoutPoint());
5940             box-&gt;flipForWritingMode(result); // The mask clip rect is in physical coordinates, so we have to flip, since localBoundingBox is not.
<a name="107" id="anc107"></a><span class="line-modified">5941         } else</span>
<span class="line-modified">5942             result = box-&gt;visualOverflowRect();</span>





5943     }
5944     return result;
5945 }
5946 
5947 LayoutRect RenderLayer::boundingBox(const RenderLayer* ancestorLayer, const LayoutSize&amp; offsetFromRoot, OptionSet&lt;CalculateLayerBoundsFlag&gt; flags) const
5948 {
5949     LayoutRect result = localBoundingBox(flags);
5950     if (renderer().view().frameView().hasFlippedBlockRenderers()) {
5951         if (renderer().isBox())
5952             renderBox()-&gt;flipForWritingMode(result);
5953         else
5954             renderer().containingBlock()-&gt;flipForWritingMode(result);
5955     }
5956 
5957     PaginationInclusionMode inclusionMode = ExcludeCompositedPaginatedLayers;
5958     if (flags &amp; UseFragmentBoxesIncludingCompositing)
5959         inclusionMode = IncludeCompositedPaginatedLayers;
5960 
5961     const RenderLayer* paginationLayer = nullptr;
5962     if (flags.containsAny({ UseFragmentBoxesExcludingCompositing, UseFragmentBoxesIncludingCompositing }))
5963         paginationLayer = enclosingPaginationLayerInSubtree(ancestorLayer, inclusionMode);
5964 
5965     const RenderLayer* childLayer = this;
5966     bool isPaginated = paginationLayer;
5967     while (paginationLayer) {
5968         // Split our box up into the actual fragment boxes that render in the columns/pages and unite those together to
5969         // get our true bounding box.
5970         result.move(childLayer-&gt;offsetFromAncestor(paginationLayer));
5971 
5972         auto&amp; enclosingFragmentedFlow = downcast&lt;RenderFragmentedFlow&gt;(paginationLayer-&gt;renderer());
5973         result = enclosingFragmentedFlow.fragmentsBoundingBox(result);
5974 
5975         childLayer = paginationLayer;
5976         paginationLayer = paginationLayer-&gt;parent()-&gt;enclosingPaginationLayerInSubtree(ancestorLayer, inclusionMode);
5977     }
5978 
5979     if (isPaginated) {
5980         result.move(childLayer-&gt;offsetFromAncestor(ancestorLayer));
5981         return result;
5982     }
5983 
5984     result.move(offsetFromRoot);
5985     return result;
5986 }
5987 
5988 bool RenderLayer::getOverlapBoundsIncludingChildrenAccountingForTransformAnimations(LayoutRect&amp; bounds, OptionSet&lt;CalculateLayerBoundsFlag&gt; additionalFlags) const
5989 {
5990     // The animation will override the display transform, so don&#39;t include it.
5991     auto boundsFlags = additionalFlags | (defaultCalculateLayerBoundsFlags() - IncludeSelfTransform);
5992 
5993     bounds = calculateLayerBounds(this, LayoutSize(), boundsFlags);
5994 
5995     LayoutRect animatedBounds = bounds;
5996     if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled()) {
5997         if (auto* timeline = renderer().documentTimeline()) {
5998             if (timeline-&gt;computeExtentOfAnimation(renderer(), animatedBounds)) {
5999                 bounds = animatedBounds;
6000                 return true;
6001             }
6002         }
6003     } else {
6004         if (renderer().animation().computeExtentOfAnimation(renderer(), animatedBounds)) {
6005             bounds = animatedBounds;
6006             return true;
6007         }
6008     }
6009 
6010     return false;
6011 }
6012 
6013 IntRect RenderLayer::absoluteBoundingBox() const
6014 {
6015     const RenderLayer* rootLayer = root();
6016     return snappedIntRect(boundingBox(rootLayer, offsetFromAncestor(rootLayer)));
6017 }
6018 
6019 FloatRect RenderLayer::absoluteBoundingBoxForPainting() const
6020 {
6021     const RenderLayer* rootLayer = root();
6022     return snapRectToDevicePixels(boundingBox(rootLayer, offsetFromAncestor(rootLayer)), renderer().document().deviceScaleFactor());
6023 }
6024 
6025 LayoutRect RenderLayer::overlapBounds() const
6026 {
6027     if (overlapBoundsIncludeChildren())
6028         return calculateLayerBounds(this, { }, defaultCalculateLayerBoundsFlags() | IncludeFilterOutsets);
6029 
6030     return localBoundingBox();
6031 }
6032 
6033 LayoutRect RenderLayer::calculateLayerBounds(const RenderLayer* ancestorLayer, const LayoutSize&amp; offsetFromRoot, OptionSet&lt;CalculateLayerBoundsFlag&gt; flags) const
6034 {
6035     if (!isSelfPaintingLayer())
6036         return LayoutRect();
6037 
6038     // FIXME: This could be improved to do a check like hasVisibleNonCompositingDescendantLayers() (bug 92580).
6039     if ((flags &amp; ExcludeHiddenDescendants) &amp;&amp; this != ancestorLayer &amp;&amp; !hasVisibleContent() &amp;&amp; !hasVisibleDescendant())
6040         return LayoutRect();
6041 
6042     if (isRenderViewLayer()) {
6043         // The root layer is always just the size of the document.
6044         return renderer().view().unscaledDocumentRect();
6045     }
6046 
6047     LayoutRect boundingBoxRect = localBoundingBox(flags);
6048     if (renderer().view().frameView().hasFlippedBlockRenderers()) {
6049         if (is&lt;RenderBox&gt;(renderer()))
6050             downcast&lt;RenderBox&gt;(renderer()).flipForWritingMode(boundingBoxRect);
6051         else
6052             renderer().containingBlock()-&gt;flipForWritingMode(boundingBoxRect);
6053     }
6054 
6055     if (renderer().isDocumentElementRenderer()) {
6056         // If the root layer becomes composited (e.g. because some descendant with negative z-index is composited),
6057         // then it has to be big enough to cover the viewport in order to display the background. This is akin
6058         // to the code in RenderBox::paintRootBoxFillLayers().
6059         const FrameView&amp; frameView = renderer().view().frameView();
6060         boundingBoxRect.setWidth(std::max(boundingBoxRect.width(), frameView.contentsWidth() - boundingBoxRect.x()));
6061         boundingBoxRect.setHeight(std::max(boundingBoxRect.height(), frameView.contentsHeight() - boundingBoxRect.y()));
6062     }
6063 
6064     LayoutRect unionBounds = boundingBoxRect;
6065 
6066     if (flags &amp; UseLocalClipRectIfPossible) {
6067         bool clipExceedsBounds = false;
6068         LayoutRect localClipRect = this-&gt;localClipRect(clipExceedsBounds);
6069         if (!localClipRect.isInfinite() &amp;&amp; !clipExceedsBounds) {
6070             if ((flags &amp; IncludeSelfTransform) &amp;&amp; paintsWithTransform(PaintBehavior::Normal))
6071                 localClipRect = transform()-&gt;mapRect(localClipRect);
6072 
6073             localClipRect.move(offsetFromAncestor(ancestorLayer));
6074             return localClipRect;
6075         }
6076     }
6077 
6078     // FIXME: should probably just pass &#39;flags&#39; down to descendants.
6079     auto descendantFlags = defaultCalculateLayerBoundsFlags() | (flags &amp; ExcludeHiddenDescendants) | (flags &amp; IncludeCompositedDescendants);
6080 
6081     const_cast&lt;RenderLayer*&gt;(this)-&gt;updateLayerListsIfNeeded();
6082 
6083     if (RenderLayer* reflection = reflectionLayer()) {
6084         if (!reflection-&gt;isComposited()) {
6085             LayoutRect childUnionBounds = reflection-&gt;calculateLayerBounds(this, reflection-&gt;offsetFromAncestor(this), descendantFlags);
6086             unionBounds.unite(childUnionBounds);
6087         }
6088     }
6089 
6090     ASSERT(isStackingContext() || !positiveZOrderLayers().size());
6091 
6092 #if !ASSERT_DISABLED
6093     LayerListMutationDetector mutationChecker(const_cast&lt;RenderLayer&amp;&gt;(*this));
6094 #endif
6095 
6096     auto computeLayersUnion = [this, &amp;unionBounds, flags, descendantFlags] (const RenderLayer&amp; childLayer) {
<a name="108" id="anc108"></a><span class="line-modified">6097         if (!(flags &amp; IncludeCompositedDescendants) &amp;&amp; (childLayer.isComposited() || childLayer.paintsIntoProvidedBacking()))</span>
6098             return;
6099         LayoutRect childBounds = childLayer.calculateLayerBounds(this, childLayer.offsetFromAncestor(this), descendantFlags);
6100         // Ignore child layer (and behave as if we had overflow: hidden) when it is positioned off the parent layer so much
6101         // that we hit the max LayoutUnit value.
6102         unionBounds.checkedUnite(childBounds);
6103     };
6104 
6105     for (auto* childLayer : negativeZOrderLayers())
6106         computeLayersUnion(*childLayer);
6107 
6108     for (auto* childLayer : positiveZOrderLayers())
6109         computeLayersUnion(*childLayer);
6110 
6111     for (auto* childLayer : normalFlowLayers())
6112         computeLayersUnion(*childLayer);
6113 
6114     if (flags.contains(IncludeFilterOutsets) || (flags.contains(IncludePaintedFilterOutsets) &amp;&amp; paintsWithFilters()))
6115         renderer().style().filterOutsets().expandRect(unionBounds);
6116 
6117     if ((flags &amp; IncludeSelfTransform) &amp;&amp; paintsWithTransform(PaintBehavior::Normal)) {
6118         TransformationMatrix* affineTrans = transform();
6119         boundingBoxRect = affineTrans-&gt;mapRect(boundingBoxRect);
6120         unionBounds = affineTrans-&gt;mapRect(unionBounds);
6121     }
6122     unionBounds.move(offsetFromRoot);
6123     return unionBounds;
6124 }
6125 
6126 void RenderLayer::clearClipRectsIncludingDescendants(ClipRectsType typeToClear)
6127 {
6128     // FIXME: it&#39;s not clear how this layer not having clip rects guarantees that no descendants have any.
6129     if (!m_clipRectsCache)
6130         return;
6131 
6132     clearClipRects(typeToClear);
6133 
6134     for (RenderLayer* l = firstChild(); l; l = l-&gt;nextSibling())
6135         l-&gt;clearClipRectsIncludingDescendants(typeToClear);
6136 }
6137 
6138 void RenderLayer::clearClipRects(ClipRectsType typeToClear)
6139 {
6140     if (typeToClear == AllClipRectTypes)
6141         m_clipRectsCache = nullptr;
6142     else {
6143         ASSERT(typeToClear &lt; NumCachedClipRectsTypes);
6144         m_clipRectsCache-&gt;setClipRects(typeToClear, RespectOverflowClip, nullptr);
6145         m_clipRectsCache-&gt;setClipRects(typeToClear, IgnoreOverflowClip, nullptr);
6146     }
6147 }
6148 
6149 RenderLayerBacking* RenderLayer::ensureBacking()
6150 {
6151     if (!m_backing) {
<a name="109" id="anc109"></a><span class="line-modified">6152         m_backing = makeUnique&lt;RenderLayerBacking&gt;(*this);</span>
6153         compositor().layerBecameComposited(*this);
6154 
6155         updateFilterPaintingStrategy();
6156     }
6157     return m_backing.get();
6158 }
6159 
6160 void RenderLayer::clearBacking(bool layerBeingDestroyed)
6161 {
6162     if (!m_backing)
6163         return;
6164 
6165     if (!renderer().renderTreeBeingDestroyed())
6166         compositor().layerBecameNonComposited(*this);
6167 
6168     m_backing-&gt;willBeDestroyed();
6169     m_backing = nullptr;
6170 
6171     if (!layerBeingDestroyed)
6172         updateFilterPaintingStrategy();
6173 }
6174 
6175 bool RenderLayer::hasCompositedMask() const
6176 {
6177     return m_backing &amp;&amp; m_backing-&gt;hasMaskLayer();
6178 }
6179 
6180 GraphicsLayer* RenderLayer::layerForHorizontalScrollbar() const
6181 {
6182     return m_backing ? m_backing-&gt;layerForHorizontalScrollbar() : nullptr;
6183 }
6184 
6185 GraphicsLayer* RenderLayer::layerForVerticalScrollbar() const
6186 {
6187     return m_backing ? m_backing-&gt;layerForVerticalScrollbar() : nullptr;
6188 }
6189 
6190 GraphicsLayer* RenderLayer::layerForScrollCorner() const
6191 {
6192     return m_backing ? m_backing-&gt;layerForScrollCorner() : nullptr;
6193 }
6194 
6195 bool RenderLayer::paintsWithTransform(OptionSet&lt;PaintBehavior&gt; paintBehavior) const
6196 {
6197     bool paintsToWindow = !isComposited() || backing()-&gt;paintsIntoWindow();
6198     return transform() &amp;&amp; ((paintBehavior &amp; PaintBehavior::FlattenCompositingLayers) || paintsToWindow);
6199 }
6200 
6201 bool RenderLayer::shouldPaintMask(OptionSet&lt;PaintBehavior&gt; paintBehavior, OptionSet&lt;PaintLayerFlag&gt; paintFlags) const
6202 {
6203     if (!renderer().hasMask())
6204         return false;
6205 
6206     bool paintsToWindow = !isComposited() || backing()-&gt;paintsIntoWindow();
6207     if (paintsToWindow || (paintBehavior &amp; PaintBehavior::FlattenCompositingLayers))
6208         return true;
6209 
6210     return paintFlags.contains(PaintLayerPaintingCompositingMaskPhase);
6211 }
6212 
6213 bool RenderLayer::shouldApplyClipPath(OptionSet&lt;PaintBehavior&gt; paintBehavior, OptionSet&lt;PaintLayerFlag&gt; paintFlags) const
6214 {
6215     if (!renderer().hasClipPath())
6216         return false;
6217 
6218     bool paintsToWindow = !isComposited() || backing()-&gt;paintsIntoWindow();
6219     if (paintsToWindow || (paintBehavior &amp; PaintBehavior::FlattenCompositingLayers))
6220         return true;
6221 
6222     return paintFlags.contains(PaintLayerPaintingCompositingClipPathPhase);
6223 }
6224 
6225 bool RenderLayer::scrollingMayRevealBackground() const
6226 {
6227     return scrollsOverflow() || usesCompositedScrolling();
6228 }
6229 
6230 bool RenderLayer::backgroundIsKnownToBeOpaqueInRect(const LayoutRect&amp; localRect) const
6231 {
6232     if (!isSelfPaintingLayer() &amp;&amp; !hasSelfPaintingLayerDescendant())
6233         return false;
6234 
6235     if (paintsWithTransparency(PaintBehavior::Normal))
6236         return false;
6237 
6238     if (renderer().isDocumentElementRenderer()) {
6239         // Normally the document element doens&#39;t have a layer.  If it does have a layer, its background propagates to the RenderView
6240         // so this layer doesn&#39;t draw it.
6241         return false;
6242     }
6243 
6244     // We can&#39;t use hasVisibleContent(), because that will be true if our renderer is hidden, but some child
6245     // is visible and that child doesn&#39;t cover the entire rect.
6246     if (renderer().style().visibility() != Visibility::Visible)
6247         return false;
6248 
6249     if (paintsWithFilters() &amp;&amp; renderer().style().filter().hasFilterThatAffectsOpacity())
6250         return false;
6251 
6252     // FIXME: Handle simple transforms.
6253     if (paintsWithTransform(PaintBehavior::Normal))
6254         return false;
6255 
6256     // FIXME: Remove this check.
6257     // This function should not be called when layer-lists are dirty.
6258     // It is somehow getting triggered during style update.
6259     if (zOrderListsDirty() || normalFlowListDirty())
6260         return false;
6261 
6262     // Table painting is special; a table paints its sections.
6263     if (renderer().isTablePart())
6264         return false;
6265 
6266     // FIXME: We currently only check the immediate renderer,
6267     // which will miss many cases.
6268     if (renderer().backgroundIsKnownToBeOpaqueInRect(localRect))
6269         return true;
6270 
6271     // We can&#39;t consult child layers if we clip, since they might cover
6272     // parts of the rect that are clipped out.
6273     if (renderer().hasOverflowClip())
6274         return false;
6275 
6276     return listBackgroundIsKnownToBeOpaqueInRect(positiveZOrderLayers(), localRect)
6277         || listBackgroundIsKnownToBeOpaqueInRect(negativeZOrderLayers(), localRect)
6278         || listBackgroundIsKnownToBeOpaqueInRect(normalFlowLayers(), localRect);
6279 }
6280 
6281 bool RenderLayer::listBackgroundIsKnownToBeOpaqueInRect(const LayerList&amp; list, const LayoutRect&amp; localRect) const
6282 {
6283     if (list.begin() == list.end())
6284         return false;
6285 
6286     for (auto iter = list.rbegin(); iter != list.rend(); ++iter) {
6287         const auto* childLayer = *iter;
6288         if (childLayer-&gt;isComposited())
6289             continue;
6290 
<a name="110" id="anc110"></a><span class="line-modified">6291         if (!childLayer-&gt;canUseOffsetFromAncestor())</span>
6292             continue;
6293 
6294         LayoutRect childLocalRect(localRect);
6295         childLocalRect.move(-childLayer-&gt;offsetFromAncestor(this));
6296 
6297         if (childLayer-&gt;backgroundIsKnownToBeOpaqueInRect(childLocalRect))
6298             return true;
6299     }
6300     return false;
6301 }
6302 
6303 void RenderLayer::repaintIncludingDescendants()
6304 {
6305     renderer().repaint();
6306     for (RenderLayer* current = firstChild(); current; current = current-&gt;nextSibling())
6307         current-&gt;repaintIncludingDescendants();
6308 }
6309 
6310 void RenderLayer::setBackingNeedsRepaint(GraphicsLayer::ShouldClipToLayer shouldClip)
6311 {
6312     ASSERT(isComposited());
6313     if (backing()-&gt;paintsIntoWindow()) {
6314         // If we&#39;re trying to repaint the placeholder document layer, propagate the
6315         // repaint to the native view system.
6316         renderer().view().repaintViewRectangle(absoluteBoundingBox());
6317     } else
6318         backing()-&gt;setContentsNeedDisplay(shouldClip);
6319 }
6320 
6321 void RenderLayer::setBackingNeedsRepaintInRect(const LayoutRect&amp; r, GraphicsLayer::ShouldClipToLayer shouldClip)
6322 {
6323     // https://bugs.webkit.org/show_bug.cgi?id=61159 describes an unreproducible crash here,
6324     // so assert but check that the layer is composited.
6325     ASSERT(isComposited());
6326     if (!isComposited() || backing()-&gt;paintsIntoWindow()) {
6327         // If we&#39;re trying to repaint the placeholder document layer, propagate the
6328         // repaint to the native view system.
6329         LayoutRect absRect(r);
6330         absRect.move(offsetFromAncestor(root()));
6331 
6332         renderer().view().repaintViewRectangle(absRect);
6333     } else
6334         backing()-&gt;setContentsNeedDisplayInRect(r, shouldClip);
6335 }
6336 
6337 // Since we&#39;re only painting non-composited layers, we know that they all share the same repaintContainer.
6338 void RenderLayer::repaintIncludingNonCompositingDescendants(RenderLayerModelObject* repaintContainer)
6339 {
6340     renderer().repaintUsingContainer(repaintContainer, renderer().clippedOverflowRectForRepaint(repaintContainer));
6341 
6342     for (RenderLayer* curr = firstChild(); curr; curr = curr-&gt;nextSibling()) {
6343         if (!curr-&gt;isComposited())
6344             curr-&gt;repaintIncludingNonCompositingDescendants(repaintContainer);
6345     }
6346 }
6347 
6348 bool RenderLayer::shouldBeSelfPaintingLayer() const
6349 {
6350     if (!isNormalFlowOnly())
6351         return true;
6352 
6353     return hasOverlayScrollbars()
6354         || canUseCompositedScrolling()
6355         || renderer().isTableRow()
6356         || renderer().isCanvas()
6357         || renderer().isVideo()
6358         || renderer().isEmbeddedObject()
6359         || (renderer().isRenderImage() &amp;&amp; downcast&lt;RenderImage&gt;(renderer()).isEditableImage())
6360         || renderer().isRenderIFrame()
6361         || renderer().isInFlowRenderFragmentedFlow();
6362 }
6363 
6364 void RenderLayer::updateSelfPaintingLayer()
6365 {
6366     bool isSelfPaintingLayer = shouldBeSelfPaintingLayer();
6367     if (m_isSelfPaintingLayer == isSelfPaintingLayer)
6368         return;
6369 
6370     m_isSelfPaintingLayer = isSelfPaintingLayer;
6371     if (!parent())
6372         return;
6373     if (isSelfPaintingLayer)
6374         parent()-&gt;setAncestorChainHasSelfPaintingLayerDescendant();
6375     else
6376         parent()-&gt;dirtyAncestorChainHasSelfPaintingLayerDescendantStatus();
6377 }
6378 
6379 static bool hasVisibleBoxDecorationsOrBackground(const RenderElement&amp; renderer)
6380 {
6381     return renderer.hasVisibleBoxDecorations() || renderer.style().hasOutline();
6382 }
6383 
6384 static bool styleHasSmoothingTextMode(const RenderStyle&amp; style)
6385 {
6386     FontSmoothingMode smoothingMode = style.fontDescription().fontSmoothing();
6387     return smoothingMode == FontSmoothingMode::AutoSmoothing || smoothingMode == FontSmoothingMode::SubpixelAntialiased;
6388 }
6389 
6390 // Constrain the depth and breadth of the search for performance.
6391 static const unsigned maxRendererTraversalCount = 200;
6392 
6393 static void determineNonLayerDescendantsPaintedContent(const RenderElement&amp; renderer, unsigned&amp; renderersTraversed, RenderLayer::PaintedContentRequest&amp; request)
6394 {
6395     for (const auto&amp; child : childrenOfType&lt;RenderObject&gt;(renderer)) {
6396         if (++renderersTraversed &gt; maxRendererTraversalCount) {
6397             request.makeStatesUndetermined();
6398             return;
6399         }
6400 
6401         if (is&lt;RenderText&gt;(child)) {
6402             const auto&amp; renderText = downcast&lt;RenderText&gt;(child);
<a name="111" id="anc111"></a><span class="line-modified">6403             if (!renderText.hasRenderedText())</span>
6404                 continue;
6405 
6406             if (renderer.style().userSelect() != UserSelect::None)
6407                 request.setHasPaintedContent();
6408 
6409             if (!renderText.text().isAllSpecialCharacters&lt;isHTMLSpace&gt;()) {
6410                 request.setHasPaintedContent();
6411 
6412                 if (request.needToDetermineSubpixelAntialiasedTextState() &amp;&amp; styleHasSmoothingTextMode(child.style()))
6413                     request.setHasSubpixelAntialiasedText();
6414             }
6415 
6416             if (request.isSatisfied())
6417                 return;
6418         }
6419 
6420         if (!is&lt;RenderElement&gt;(child))
6421             continue;
6422 
6423         const RenderElement&amp; renderElementChild = downcast&lt;RenderElement&gt;(child);
6424 
6425         if (is&lt;RenderLayerModelObject&gt;(renderElementChild) &amp;&amp; downcast&lt;RenderLayerModelObject&gt;(renderElementChild).hasSelfPaintingLayer())
6426             continue;
6427 
6428         if (hasVisibleBoxDecorationsOrBackground(renderElementChild)) {
6429             request.setHasPaintedContent();
6430             if (request.isSatisfied())
6431                 return;
6432         }
6433 
6434         if (is&lt;RenderReplaced&gt;(renderElementChild)) {
6435             request.setHasPaintedContent();
6436 
6437             if (is&lt;RenderImage&gt;(renderElementChild) &amp;&amp; request.needToDetermineSubpixelAntialiasedTextState()) {
6438                 auto&amp; imageRenderer = downcast&lt;RenderImage&gt;(renderElementChild);
6439                 // May draw text if showing alt text, or image is an SVG image or PDF image.
6440                 if ((imageRenderer.isShowingAltText() || imageRenderer.hasNonBitmapImage()) &amp;&amp; styleHasSmoothingTextMode(child.style()))
6441                     request.setHasSubpixelAntialiasedText();
6442             }
6443 
6444             if (request.isSatisfied())
6445                 return;
6446         }
6447 
6448         determineNonLayerDescendantsPaintedContent(renderElementChild, renderersTraversed, request);
6449         if (request.isSatisfied())
6450             return;
6451     }
6452 }
6453 
6454 bool RenderLayer::hasNonEmptyChildRenderers(PaintedContentRequest&amp; request) const
6455 {
6456     unsigned renderersTraversed = 0;
6457     determineNonLayerDescendantsPaintedContent(renderer(), renderersTraversed, request);
6458     return request.probablyHasPaintedContent();
6459 }
6460 
6461 bool RenderLayer::hasVisibleBoxDecorationsOrBackground() const
6462 {
6463     return WebCore::hasVisibleBoxDecorationsOrBackground(renderer());
6464 }
6465 
6466 bool RenderLayer::hasVisibleBoxDecorations() const
6467 {
6468     if (!hasVisibleContent())
6469         return false;
6470 
6471     return hasVisibleBoxDecorationsOrBackground() || hasOverflowControls();
6472 }
6473 
6474 bool RenderLayer::isVisuallyNonEmpty(PaintedContentRequest* request) const
6475 {
6476     ASSERT(!m_visibleDescendantStatusDirty);
6477 
6478     if (!hasVisibleContent() || !renderer().style().opacity())
6479         return false;
6480 
6481     if (renderer().isRenderReplaced() || hasOverflowControls()) {
6482         if (!request)
6483             return true;
6484 
6485         request-&gt;setHasPaintedContent();
6486         if (request-&gt;isSatisfied())
6487             return true;
6488     }
6489 
6490     if (hasVisibleBoxDecorationsOrBackground()) {
6491         if (!request)
6492             return true;
6493 
6494         request-&gt;setHasPaintedContent();
6495         if (request-&gt;isSatisfied())
6496             return true;
6497     }
6498 
6499     PaintedContentRequest localRequest;
6500     if (!request)
6501         request = &amp;localRequest;
6502 
6503     return hasNonEmptyChildRenderers(*request);
6504 }
6505 
6506 void RenderLayer::updateScrollbarsAfterStyleChange(const RenderStyle* oldStyle)
6507 {
6508     // Overflow are a box concept.
6509     RenderBox* box = renderBox();
6510     if (!box)
6511         return;
6512 
6513     // List box parts handle the scrollbars by themselves so we have nothing to do.
6514     if (box-&gt;style().appearance() == ListboxPart)
6515         return;
6516 
6517     Overflow overflowX = box-&gt;style().overflowX();
6518     Overflow overflowY = box-&gt;style().overflowY();
6519 
6520     // To avoid doing a relayout in updateScrollbarsAfterLayout, we try to keep any automatic scrollbar that was already present.
6521     bool needsHorizontalScrollbar = box-&gt;hasOverflowClip() &amp;&amp; ((hasHorizontalScrollbar() &amp;&amp; styleDefinesAutomaticScrollbar(box-&gt;style(), HorizontalScrollbar)) || styleRequiresScrollbar(box-&gt;style(), HorizontalScrollbar));
6522     bool needsVerticalScrollbar = box-&gt;hasOverflowClip() &amp;&amp; ((hasVerticalScrollbar() &amp;&amp; styleDefinesAutomaticScrollbar(box-&gt;style(), VerticalScrollbar)) || styleRequiresScrollbar(box-&gt;style(), VerticalScrollbar));
6523     setHasHorizontalScrollbar(needsHorizontalScrollbar);
6524     setHasVerticalScrollbar(needsVerticalScrollbar);
6525 
6526     // With non-overlay overflow:scroll, scrollbars are always visible but may be disabled.
6527     // When switching to another value, we need to re-enable them (see bug 11985).
6528     if (m_hBar &amp;&amp; needsHorizontalScrollbar &amp;&amp; oldStyle &amp;&amp; oldStyle-&gt;overflowX() == Overflow::Scroll &amp;&amp; overflowX != Overflow::Scroll)
6529         m_hBar-&gt;setEnabled(true);
6530 
6531     if (m_vBar &amp;&amp; needsVerticalScrollbar &amp;&amp; oldStyle &amp;&amp; oldStyle-&gt;overflowY() == Overflow::Scroll &amp;&amp; overflowY != Overflow::Scroll)
6532         m_vBar-&gt;setEnabled(true);
6533 
6534     if (!m_scrollDimensionsDirty)
6535         updateScrollableAreaSet(hasScrollableHorizontalOverflow() || hasScrollableVerticalOverflow());
6536 }
6537 
6538 void RenderLayer::styleChanged(StyleDifference diff, const RenderStyle* oldStyle)
6539 {
6540     setIsNormalFlowOnly(shouldBeNormalFlowOnly());
6541 
<a name="112" id="anc112"></a><span class="line-modified">6542     if (setIsCSSStackingContext(shouldBeCSSStackingContext())) {</span>
6543 #if ENABLE(CSS_COMPOSITING)
6544         if (parent()) {
<a name="113" id="anc113"></a><span class="line-modified">6545             if (isCSSStackingContext()) {</span>
6546                 if (!hasNotIsolatedBlendingDescendantsStatusDirty() &amp;&amp; hasNotIsolatedBlendingDescendants())
6547                     parent()-&gt;dirtyAncestorChainHasBlendingDescendants();
6548             } else {
6549                 if (hasNotIsolatedBlendingDescendantsStatusDirty())
6550                     parent()-&gt;dirtyAncestorChainHasBlendingDescendants();
6551                 else if (hasNotIsolatedBlendingDescendants())
6552                     parent()-&gt;updateAncestorChainHasBlendingDescendants();
6553             }
6554         }
6555 #endif
6556     }
6557 
6558     // FIXME: RenderLayer already handles visibility changes through our visiblity dirty bits. This logic could
6559     // likely be folded along with the rest.
6560     if (oldStyle) {
6561         if (oldStyle-&gt;zIndex() != renderer().style().zIndex() || oldStyle-&gt;visibility() != renderer().style().visibility()) {
6562             dirtyStackingContextZOrderLists();
6563             if (isStackingContext())
6564                 dirtyZOrderLists();
6565         }
6566     }
6567 
6568     if (renderer().isHTMLMarquee() &amp;&amp; renderer().style().marqueeBehavior() != MarqueeBehavior::None &amp;&amp; renderer().isBox()) {
6569         if (!m_marquee)
<a name="114" id="anc114"></a><span class="line-modified">6570             m_marquee = makeUnique&lt;RenderMarquee&gt;(this);</span>
6571         m_marquee-&gt;updateMarqueeStyle();
6572     } else if (m_marquee)
6573         m_marquee = nullptr;
6574 
6575     updateScrollbarsAfterStyleChange(oldStyle);
6576     // Overlay scrollbars can make this layer self-painting so we need
6577     // to recompute the bit once scrollbars have been updated.
6578     updateSelfPaintingLayer();
6579 
6580     if (!hasReflection() &amp;&amp; m_reflection)
6581         removeReflection();
6582     else if (hasReflection()) {
6583         if (!m_reflection)
6584             createReflection();
6585         else
6586             m_reflection-&gt;setStyle(createReflectionStyle());
6587     }
6588 
6589     // FIXME: Need to detect a swap from custom to native scrollbars (and vice versa).
6590     if (m_hBar)
6591         m_hBar-&gt;styleChanged();
6592     if (m_vBar)
6593         m_vBar-&gt;styleChanged();
6594 
6595     updateScrollCornerStyle();
6596     updateResizerStyle();
6597 
6598     updateDescendantDependentFlags();
6599     updateTransform();
6600 #if ENABLE(CSS_COMPOSITING)
6601     updateBlendMode();
6602 #endif
6603     updateFiltersAfterStyleChange();
6604 
6605     compositor().layerStyleChanged(diff, *this, oldStyle);
6606 
6607     updateFilterPaintingStrategy();
6608 
6609 #if PLATFORM(IOS_FAMILY) &amp;&amp; ENABLE(TOUCH_EVENTS)
6610     if (diff == StyleDifference::RecompositeLayer || diff &gt;= StyleDifference::LayoutPositionedMovementOnly)
6611         renderer().document().invalidateRenderingDependentRegions();
6612 #else
6613     UNUSED_PARAM(diff);
6614 #endif
6615 }
6616 
6617 void RenderLayer::updateScrollableAreaSet(bool hasOverflow)
6618 {
6619     FrameView&amp; frameView = renderer().view().frameView();
6620 
6621     bool isVisibleToHitTest = renderer().visibleToHitTesting();
6622     if (HTMLFrameOwnerElement* owner = frameView.frame().ownerElement())
6623         isVisibleToHitTest &amp;= owner-&gt;renderer() &amp;&amp; owner-&gt;renderer()-&gt;visibleToHitTesting();
6624 
6625     bool isScrollable = hasOverflow &amp;&amp; isVisibleToHitTest;
6626     bool addedOrRemoved = false;
6627 
6628     ASSERT(m_registeredScrollableArea == frameView.containsScrollableArea(this));
6629 
6630     if (isScrollable) {
6631         if (!m_registeredScrollableArea) {
6632             addedOrRemoved = frameView.addScrollableArea(this);
6633             m_registeredScrollableArea = true;
6634         }
6635     } else if (m_registeredScrollableArea) {
6636         addedOrRemoved = frameView.removeScrollableArea(this);
6637         m_registeredScrollableArea = false;
6638     }
6639 
6640 #if ENABLE(IOS_TOUCH_EVENTS)
6641     if (addedOrRemoved) {
6642         if (isScrollable &amp;&amp; !canUseCompositedScrolling())
6643             registerAsTouchEventListenerForScrolling();
6644         else {
6645             // We only need the touch listener for unaccelerated overflow scrolling, so if we became
6646             // accelerated, remove ourselves as a touch event listener.
6647             unregisterAsTouchEventListenerForScrolling();
6648         }
6649     }
6650 #else
6651     UNUSED_VARIABLE(addedOrRemoved);
6652 #endif
6653 }
6654 
6655 void RenderLayer::updateScrollCornerStyle()
6656 {
6657     RenderElement* actualRenderer = rendererForScrollbar(renderer());
6658     auto corner = renderer().hasOverflowClip() ? actualRenderer-&gt;getUncachedPseudoStyle(PseudoStyleRequest(PseudoId::ScrollbarCorner), &amp;actualRenderer-&gt;style()) : nullptr;
6659 
6660     if (!corner) {
6661         clearScrollCorner();
6662         return;
6663     }
6664 
6665     if (!m_scrollCorner) {
6666         m_scrollCorner = createRenderer&lt;RenderScrollbarPart&gt;(renderer().document(), WTFMove(*corner));
6667         // FIXME: A renderer should be a child of its parent!
6668         m_scrollCorner-&gt;setParent(&amp;renderer());
6669         m_scrollCorner-&gt;initializeStyle();
6670     } else
6671         m_scrollCorner-&gt;setStyle(WTFMove(*corner));
6672 }
6673 
6674 void RenderLayer::clearScrollCorner()
6675 {
6676     if (!m_scrollCorner)
6677         return;
6678     m_scrollCorner-&gt;setParent(nullptr);
6679     m_scrollCorner = nullptr;
6680 }
6681 
6682 void RenderLayer::updateResizerStyle()
6683 {
6684     RenderElement* actualRenderer = rendererForScrollbar(renderer());
6685     auto resizer = renderer().hasOverflowClip() ? actualRenderer-&gt;getUncachedPseudoStyle(PseudoStyleRequest(PseudoId::Resizer), &amp;actualRenderer-&gt;style()) : nullptr;
6686 
6687     if (!resizer) {
6688         clearResizer();
6689         return;
6690     }
6691 
6692     if (!m_resizer) {
6693         m_resizer = createRenderer&lt;RenderScrollbarPart&gt;(renderer().document(), WTFMove(*resizer));
6694         // FIXME: A renderer should be a child of its parent!
6695         m_resizer-&gt;setParent(&amp;renderer());
6696         m_resizer-&gt;initializeStyle();
6697     } else
6698         m_resizer-&gt;setStyle(WTFMove(*resizer));
6699 }
6700 
6701 void RenderLayer::clearResizer()
6702 {
6703     if (!m_resizer)
6704         return;
6705     m_resizer-&gt;setParent(nullptr);
6706     m_resizer = nullptr;
6707 }
6708 
6709 RenderLayer* RenderLayer::reflectionLayer() const
6710 {
6711     return m_reflection ? m_reflection-&gt;layer() : nullptr;
6712 }
6713 
6714 bool RenderLayer::isReflectionLayer(const RenderLayer&amp; layer) const
6715 {
6716     return m_reflection ? &amp;layer == m_reflection-&gt;layer() : false;
6717 }
6718 
6719 void RenderLayer::createReflection()
6720 {
6721     ASSERT(!m_reflection);
6722     m_reflection = createRenderer&lt;RenderReplica&gt;(renderer().document(), createReflectionStyle());
6723     // FIXME: A renderer should be a child of its parent!
6724     m_reflection-&gt;setParent(&amp;renderer()); // We create a 1-way connection.
6725     m_reflection-&gt;initializeStyle();
6726 }
6727 
6728 void RenderLayer::removeReflection()
6729 {
6730     if (!m_reflection-&gt;renderTreeBeingDestroyed())
6731         m_reflection-&gt;removeLayers(this);
6732 
6733     m_reflection-&gt;setParent(nullptr);
6734     m_reflection = nullptr;
6735 }
6736 
6737 RenderStyle RenderLayer::createReflectionStyle()
6738 {
6739     auto newStyle = RenderStyle::create();
6740     newStyle.inheritFrom(renderer().style());
6741 
6742     // Map in our transform.
6743     TransformOperations transform;
6744     switch (renderer().style().boxReflect()-&gt;direction()) {
6745         case ReflectionBelow:
6746             transform.operations().append(TranslateTransformOperation::create(Length(0, Fixed), Length(100., Percent), TransformOperation::TRANSLATE));
6747             transform.operations().append(TranslateTransformOperation::create(Length(0, Fixed), renderer().style().boxReflect()-&gt;offset(), TransformOperation::TRANSLATE));
6748             transform.operations().append(ScaleTransformOperation::create(1.0, -1.0, ScaleTransformOperation::SCALE));
6749             break;
6750         case ReflectionAbove:
6751             transform.operations().append(ScaleTransformOperation::create(1.0, -1.0, ScaleTransformOperation::SCALE));
6752             transform.operations().append(TranslateTransformOperation::create(Length(0, Fixed), Length(100., Percent), TransformOperation::TRANSLATE));
6753             transform.operations().append(TranslateTransformOperation::create(Length(0, Fixed), renderer().style().boxReflect()-&gt;offset(), TransformOperation::TRANSLATE));
6754             break;
6755         case ReflectionRight:
6756             transform.operations().append(TranslateTransformOperation::create(Length(100., Percent), Length(0, Fixed), TransformOperation::TRANSLATE));
6757             transform.operations().append(TranslateTransformOperation::create(renderer().style().boxReflect()-&gt;offset(), Length(0, Fixed), TransformOperation::TRANSLATE));
6758             transform.operations().append(ScaleTransformOperation::create(-1.0, 1.0, ScaleTransformOperation::SCALE));
6759             break;
6760         case ReflectionLeft:
6761             transform.operations().append(ScaleTransformOperation::create(-1.0, 1.0, ScaleTransformOperation::SCALE));
6762             transform.operations().append(TranslateTransformOperation::create(Length(100., Percent), Length(0, Fixed), TransformOperation::TRANSLATE));
6763             transform.operations().append(TranslateTransformOperation::create(renderer().style().boxReflect()-&gt;offset(), Length(0, Fixed), TransformOperation::TRANSLATE));
6764             break;
6765     }
6766     newStyle.setTransform(transform);
6767 
6768     // Map in our mask.
6769     newStyle.setMaskBoxImage(renderer().style().boxReflect()-&gt;mask());
6770 
6771     // Style has transform and mask, so needs to be stacking context.
6772     newStyle.setZIndex(0);
6773 
6774     return newStyle;
6775 }
6776 
6777 void RenderLayer::ensureLayerFilters()
6778 {
6779     if (m_filters)
6780         return;
6781 
<a name="115" id="anc115"></a><span class="line-modified">6782     m_filters = makeUnique&lt;RenderLayerFilters&gt;(*this);</span>
6783 }
6784 
6785 void RenderLayer::clearLayerFilters()
6786 {
6787     m_filters = nullptr;
6788 }
6789 
6790 void RenderLayer::updateFiltersAfterStyleChange()
6791 {
6792     if (!hasFilter()) {
6793         clearLayerFilters();
6794         return;
6795     }
6796 
6797     // Add the filter as a client to this renderer, unless we are a RenderLayer accommodating
6798     // an SVG. In that case it takes care of its own resource management for filters.
6799     if (renderer().style().filter().hasReferenceFilter() &amp;&amp; !renderer().isSVGRoot()) {
6800         ensureLayerFilters();
6801         m_filters-&gt;updateReferenceFilterClients(renderer().style().filter());
6802     } else if (m_filters)
6803         m_filters-&gt;removeReferenceFilterClients();
6804 }
6805 
6806 void RenderLayer::updateFilterPaintingStrategy()
6807 {
6808     // RenderLayerFilters is only used to render the filters in software mode,
6809     // so we always need to run updateFilterPaintingStrategy() after the composited
6810     // mode might have changed for this layer.
6811     if (!paintsWithFilters()) {
6812         // Don&#39;t delete the whole filter info here, because we might use it
6813         // for loading SVG reference filter files.
6814         if (m_filters)
6815             m_filters-&gt;setFilter(nullptr);
6816 
6817         // Early-return only if we *don&#39;t* have reference filters.
6818         // For reference filters, we still want the FilterEffect graph built
6819         // for us, even if we&#39;re composited.
6820         if (!renderer().style().filter().hasReferenceFilter())
6821             return;
6822     }
6823 
6824     ensureLayerFilters();
6825     m_filters-&gt;buildFilter(renderer(), page().deviceScaleFactor(), renderer().settings().acceleratedFiltersEnabled() ? Accelerated : Unaccelerated);
6826 }
6827 
6828 void RenderLayer::filterNeedsRepaint()
6829 {
6830     // We use the enclosing element so that we recalculate style for the ancestor of an anonymous object.
6831     if (Element* element = enclosingElement()) {
6832         // FIXME: This really shouldn&#39;t have to invalidate layer composition, but tests like css3/filters/effect-reference-delete.html fail if that doesn&#39;t happen.
6833         element-&gt;invalidateStyleAndLayerComposition();
6834     }
6835     renderer().repaint();
6836 }
6837 
<a name="116" id="anc116"></a><span class="line-added">6838 bool RenderLayer::isTransparentOrFullyClippedRespectingParentFrames() const</span>
<span class="line-added">6839 {</span>
<span class="line-added">6840     static const double minimumVisibleOpacity = 0.01;</span>
<span class="line-added">6841 </span>
<span class="line-added">6842     float currentOpacity = 1;</span>
<span class="line-added">6843     for (auto* layer = this; layer; layer = parentLayerCrossFrame(*layer)) {</span>
<span class="line-added">6844         currentOpacity *= layer-&gt;renderer().style().opacity();</span>
<span class="line-added">6845         if (currentOpacity &lt; minimumVisibleOpacity)</span>
<span class="line-added">6846             return true;</span>
<span class="line-added">6847     }</span>
<span class="line-added">6848 </span>
<span class="line-added">6849     auto hasEmptyClipRect = [] (const RenderLayer&amp; layer) -&gt; bool {</span>
<span class="line-added">6850         auto* frameView = layer.renderer().document().view();</span>
<span class="line-added">6851         if (!frameView)</span>
<span class="line-added">6852             return false;</span>
<span class="line-added">6853 </span>
<span class="line-added">6854         auto* renderView = frameView-&gt;renderView();</span>
<span class="line-added">6855         if (!renderView)</span>
<span class="line-added">6856             return false;</span>
<span class="line-added">6857 </span>
<span class="line-added">6858         auto* renderViewLayer = renderView-&gt;layer();</span>
<span class="line-added">6859         if (!renderViewLayer)</span>
<span class="line-added">6860             return false;</span>
<span class="line-added">6861 </span>
<span class="line-added">6862         if (is&lt;HTMLFrameOwnerElement&gt;(layer.renderer().element()) &amp;&amp; layer.visibleSize().isEmpty())</span>
<span class="line-added">6863             return true;</span>
<span class="line-added">6864 </span>
<span class="line-added">6865         LayoutRect layerBounds;</span>
<span class="line-added">6866         ClipRect backgroundRect;</span>
<span class="line-added">6867         ClipRect foregroundRect;</span>
<span class="line-added">6868         layer.calculateRects({ renderViewLayer, TemporaryClipRects }, LayoutRect::infiniteRect(), layerBounds, backgroundRect, foregroundRect, layer.offsetFromAncestor(renderViewLayer));</span>
<span class="line-added">6869         return backgroundRect.isEmpty();</span>
<span class="line-added">6870     };</span>
<span class="line-added">6871 </span>
<span class="line-added">6872     for (auto* layer = this; layer; layer = enclosingFrameRenderLayer(*layer)) {</span>
<span class="line-added">6873         if (hasEmptyClipRect(*layer))</span>
<span class="line-added">6874             return true;</span>
<span class="line-added">6875     }</span>
<span class="line-added">6876 </span>
<span class="line-added">6877     return false;</span>
<span class="line-added">6878 }</span>
<span class="line-added">6879 </span>
<span class="line-added">6880 void RenderLayer::invalidateEventRegion()</span>
<span class="line-added">6881 {</span>
<span class="line-added">6882 #if PLATFORM(IOS_FAMILY)</span>
<span class="line-added">6883     auto* compositingLayer = enclosingCompositingLayerForRepaint();</span>
<span class="line-added">6884     if (!compositingLayer)</span>
<span class="line-added">6885         return;</span>
<span class="line-added">6886 </span>
<span class="line-added">6887     auto maintainsEventRegion = [&amp;] {</span>
<span class="line-added">6888         // UI side scroll overlap testing.</span>
<span class="line-added">6889         if (!compositingLayer-&gt;isRenderViewLayer())</span>
<span class="line-added">6890             return true;</span>
<span class="line-added">6891 #if ENABLE(POINTER_EVENTS)</span>
<span class="line-added">6892         // UI side touch-action resolution.</span>
<span class="line-added">6893         if (renderer().document().mayHaveElementsWithNonAutoTouchAction())</span>
<span class="line-added">6894             return true;</span>
<span class="line-added">6895 #endif</span>
<span class="line-added">6896         return false;</span>
<span class="line-added">6897     };</span>
<span class="line-added">6898 </span>
<span class="line-added">6899     if (!maintainsEventRegion())</span>
<span class="line-added">6900         return;</span>
<span class="line-added">6901 </span>
<span class="line-added">6902     compositingLayer-&gt;setNeedsCompositingConfigurationUpdate();</span>
<span class="line-added">6903 #endif</span>
<span class="line-added">6904 }</span>
<span class="line-added">6905 </span>
<span class="line-added">6906 TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp; ts, ClipRectsType clipRectsType)</span>
<span class="line-added">6907 {</span>
<span class="line-added">6908     switch (clipRectsType) {</span>
<span class="line-added">6909     case PaintingClipRects: ts &lt;&lt; &quot;painting&quot;; break;</span>
<span class="line-added">6910     case RootRelativeClipRects: ts &lt;&lt; &quot;root-relative&quot;; break;</span>
<span class="line-added">6911     case AbsoluteClipRects: ts &lt;&lt; &quot;absolute&quot;; break;</span>
<span class="line-added">6912     case TemporaryClipRects: ts &lt;&lt; &quot;temporary&quot;; break;</span>
<span class="line-added">6913     case NumCachedClipRectsTypes:</span>
<span class="line-added">6914     case AllClipRectTypes:</span>
<span class="line-added">6915         ts &lt;&lt; &quot;?&quot;;</span>
<span class="line-added">6916         break;</span>
<span class="line-added">6917     }</span>
<span class="line-added">6918     return ts;</span>
<span class="line-added">6919 }</span>
<span class="line-added">6920 </span>
6921 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const RenderLayer&amp; layer)
6922 {
6923     ts &lt;&lt; &quot;RenderLayer &quot; &lt;&lt; &amp;layer &lt;&lt; &quot; &quot; &lt;&lt; layer.size();
6924     if (layer.transform())
6925         ts &lt;&lt; &quot; has transform&quot;;
6926     if (layer.hasFilter())
6927         ts &lt;&lt; &quot; has filter&quot;;
6928     if (layer.hasBackdropFilter())
6929         ts &lt;&lt; &quot; has backdrop filter&quot;;
6930     if (layer.hasBlendMode())
6931         ts &lt;&lt; &quot; has blend mode&quot;;
6932     if (layer.isolatesBlending())
6933         ts &lt;&lt; &quot; isolates blending&quot;;
6934     if (layer.isComposited())
6935         ts &lt;&lt; &quot; &quot; &lt;&lt; *layer.backing();
6936     return ts;
6937 }
6938 
<a name="117" id="anc117"></a><span class="line-added">6939 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const RenderLayer::ClipRectsContext&amp; context)</span>
<span class="line-added">6940 {</span>
<span class="line-added">6941     ts.dumpProperty(&quot;root layer:&quot;, context.rootLayer);</span>
<span class="line-added">6942     ts.dumpProperty(&quot;type:&quot;, context.clipRectsType);</span>
<span class="line-added">6943     ts.dumpProperty(&quot;overflow-clip:&quot;, context.respectOverflowClip == IgnoreOverflowClip ? &quot;ignore&quot; : &quot;respect&quot;);</span>
<span class="line-added">6944 </span>
<span class="line-added">6945     return ts;</span>
<span class="line-added">6946 }</span>
<span class="line-added">6947 </span>
<span class="line-added">6948 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, IndirectCompositingReason reason)</span>
<span class="line-added">6949 {</span>
<span class="line-added">6950     switch (reason) {</span>
<span class="line-added">6951     case IndirectCompositingReason::None: ts &lt;&lt; &quot;none&quot;; break;</span>
<span class="line-added">6952     case IndirectCompositingReason::Stacking: ts &lt;&lt; &quot;stacking&quot;; break;</span>
<span class="line-added">6953     case IndirectCompositingReason::OverflowScrollPositioning: ts &lt;&lt; &quot;overflow positioning&quot;; break;</span>
<span class="line-added">6954     case IndirectCompositingReason::Overlap: ts &lt;&lt; &quot;overlap&quot;; break;</span>
<span class="line-added">6955     case IndirectCompositingReason::BackgroundLayer: ts &lt;&lt; &quot;background layer&quot;; break;</span>
<span class="line-added">6956     case IndirectCompositingReason::GraphicalEffect: ts &lt;&lt; &quot;graphical effect&quot;; break;</span>
<span class="line-added">6957     case IndirectCompositingReason::Perspective: ts &lt;&lt; &quot;perspective&quot;; break;</span>
<span class="line-added">6958     case IndirectCompositingReason::Preserve3D: ts &lt;&lt; &quot;preserve-3d&quot;; break;</span>
<span class="line-added">6959     }</span>
<span class="line-added">6960 </span>
<span class="line-added">6961     return ts;</span>
<span class="line-added">6962 }</span>
<span class="line-added">6963 </span>
6964 } // namespace WebCore
6965 
6966 #if ENABLE(TREE_DEBUGGING)
6967 
6968 void showLayerTree(const WebCore::RenderLayer* layer)
6969 {
6970     if (!layer)
6971         return;
6972 
<a name="118" id="anc118"></a><span class="line-modified">6973     WTF::String output = externalRepresentation(&amp;layer-&gt;renderer().frame(), {</span>
<span class="line-added">6974         WebCore::RenderAsTextFlag::ShowAllLayers,</span>
<span class="line-added">6975         WebCore::RenderAsTextFlag::ShowLayerNesting,</span>
<span class="line-added">6976         WebCore::RenderAsTextFlag::ShowCompositedLayers,</span>
<span class="line-added">6977         WebCore::RenderAsTextFlag::ShowOverflow,</span>
<span class="line-added">6978         WebCore::RenderAsTextFlag::ShowSVGGeometry,</span>
<span class="line-added">6979         WebCore::RenderAsTextFlag::ShowLayerFragments,</span>
<span class="line-added">6980         WebCore::RenderAsTextFlag::ShowAddresses,</span>
<span class="line-added">6981         WebCore::RenderAsTextFlag::ShowIDAndClass,</span>
<span class="line-added">6982         WebCore::RenderAsTextFlag::DontUpdateLayout,</span>
<span class="line-added">6983         WebCore::RenderAsTextFlag::ShowLayoutState,</span>
<span class="line-added">6984     });</span>
6985     fprintf(stderr, &quot;\n%s\n&quot;, output.utf8().data());
6986 }
6987 
6988 void showLayerTree(const WebCore::RenderObject* renderer)
6989 {
6990     if (!renderer)
6991         return;
6992     showLayerTree(renderer-&gt;enclosingLayer());
6993 }
6994 
6995 static void outputPaintOrderTreeLegend(TextStream&amp; stream)
6996 {
6997     stream.nextLine();
<a name="119" id="anc119"></a><span class="line-modified">6998     stream &lt;&lt; &quot;(S)tacking Context/(F)orced SC/O(P)portunistic SC, (N)ormal flow only, (O)verflow clip, (A)lpha (opacity or mask), has (B)lend mode, (I)solates blending, (T)ransform-ish, (F)ilter, Fi(X)ed position, Behaves as fi(x)ed, (C)omposited, (P)rovides backing/uses (p)rovided backing/paints to (a)ncestor, (c)omposited descendant, (s)scrolling ancestor, (t)transformed ancestor\n&quot;</span>
6999         &quot;Dirty (z)-lists, Dirty (n)ormal flow lists\n&quot;
7000         &quot;Traversal needs: requirements (t)raversal on descendants, (b)acking or hierarchy traversal on descendants, (r)equirements traversal on all descendants, requirements traversal on all (s)ubsequent layers, (h)ierarchy traversal on all descendants, update of paint (o)rder children\n&quot;
7001         &quot;Update needs:    post-(l)ayout requirements, (g)eometry, (k)ids geometry, (c)onfig, layer conne(x)ion, (s)crolling tree\n&quot;;
7002     stream.nextLine();
7003 }
7004 
7005 static void outputIdent(TextStream&amp; stream, unsigned depth)
7006 {
7007     unsigned i = 0;
7008     while (++i &lt;= depth * 2)
7009         stream &lt;&lt; &quot; &quot;;
7010 }
7011 
7012 static void outputPaintOrderTreeRecursive(TextStream&amp; stream, const WebCore::RenderLayer&amp; layer, const char* prefix, unsigned depth = 0)
7013 {
<a name="120" id="anc120"></a><span class="line-modified">7014     stream &lt;&lt; (layer.isCSSStackingContext() ? &quot;S&quot; : (layer.isForcedStackingContext() ? &quot;F&quot; : (layer.isOpportunisticStackingContext() ? &quot;P&quot; : &quot;-&quot;)));</span>
7015     stream &lt;&lt; (layer.isNormalFlowOnly() ? &quot;N&quot; : &quot;-&quot;);
7016     stream &lt;&lt; (layer.renderer().hasOverflowClip() ? &quot;O&quot; : &quot;-&quot;);
7017     stream &lt;&lt; (layer.isTransparent() ? &quot;A&quot; : &quot;-&quot;);
7018     stream &lt;&lt; (layer.hasBlendMode() ? &quot;B&quot; : &quot;-&quot;);
7019     stream &lt;&lt; (layer.isolatesBlending() ? &quot;I&quot; : &quot;-&quot;);
7020     stream &lt;&lt; (layer.renderer().hasTransformRelatedProperty() ? &quot;T&quot; : &quot;-&quot;);
7021     stream &lt;&lt; (layer.hasFilter() ? &quot;F&quot; : &quot;-&quot;);
7022     stream &lt;&lt; (layer.renderer().isFixedPositioned() ? &quot;X&quot; : &quot;-&quot;);
<a name="121" id="anc121"></a><span class="line-added">7023     stream &lt;&lt; (layer.behavesAsFixed() ? &quot;x&quot; : &quot;-&quot;);</span>
7024     stream &lt;&lt; (layer.isComposited() ? &quot;C&quot; : &quot;-&quot;);
<a name="122" id="anc122"></a><span class="line-added">7025 </span>
<span class="line-added">7026     auto compositedPaintingDestinationString = [&amp;layer]() {</span>
<span class="line-added">7027         if (layer.paintsIntoProvidedBacking())</span>
<span class="line-added">7028             return &quot;p&quot;;</span>
<span class="line-added">7029 </span>
<span class="line-added">7030         if (!layer.isComposited())</span>
<span class="line-added">7031             return &quot;-&quot;;</span>
<span class="line-added">7032 </span>
<span class="line-added">7033         if (layer.backing()-&gt;hasBackingSharingLayers())</span>
<span class="line-added">7034             return &quot;P&quot;;</span>
<span class="line-added">7035 </span>
<span class="line-added">7036         if (layer.backing()-&gt;paintsIntoCompositedAncestor())</span>
<span class="line-added">7037             return &quot;a&quot;;</span>
<span class="line-added">7038 </span>
<span class="line-added">7039         return &quot;-&quot;;</span>
<span class="line-added">7040     };</span>
<span class="line-added">7041 </span>
<span class="line-added">7042     stream &lt;&lt; compositedPaintingDestinationString();</span>
7043     stream &lt;&lt; (layer.hasCompositingDescendant() ? &quot;c&quot; : &quot;-&quot;);
<a name="123" id="anc123"></a><span class="line-added">7044     stream &lt;&lt; (layer.hasCompositedScrollingAncestor() ? &quot;s&quot; : &quot;-&quot;);</span>
<span class="line-added">7045     stream &lt;&lt; (layer.hasTransformedAncestor() ? &quot;t&quot; : &quot;-&quot;);</span>
7046 
7047     stream &lt;&lt; &quot; &quot;;
7048 
7049     stream &lt;&lt; (layer.zOrderListsDirty() ? &quot;z&quot; : &quot;-&quot;);
7050     stream &lt;&lt; (layer.normalFlowListDirty() ? &quot;n&quot; : &quot;-&quot;);
7051 
7052     stream &lt;&lt; &quot; &quot;;
7053 
7054     stream &lt;&lt; (layer.hasDescendantNeedingCompositingRequirementsTraversal() ? &quot;t&quot; : &quot;-&quot;);
7055     stream &lt;&lt; (layer.hasDescendantNeedingUpdateBackingOrHierarchyTraversal() ? &quot;b&quot; : &quot;-&quot;);
7056     stream &lt;&lt; (layer.descendantsNeedCompositingRequirementsTraversal() ? &quot;r&quot; : &quot;-&quot;);
7057     stream &lt;&lt; (layer.subsequentLayersNeedCompositingRequirementsTraversal() ? &quot;s&quot; : &quot;-&quot;);
7058     stream &lt;&lt; (layer.descendantsNeedUpdateBackingAndHierarchyTraversal() ? &quot;h&quot; : &quot;-&quot;);
7059     stream &lt;&lt; (layer.needsCompositingPaintOrderChildrenUpdate() ? &quot;o&quot; : &quot;-&quot;);
7060 
7061     stream &lt;&lt; &quot; &quot;;
7062 
7063     stream &lt;&lt; (layer.needsPostLayoutCompositingUpdate() ? &quot;l&quot; : &quot;-&quot;);
7064     stream &lt;&lt; (layer.needsCompositingGeometryUpdate() ? &quot;g&quot; : &quot;-&quot;);
7065     stream &lt;&lt; (layer.childrenNeedCompositingGeometryUpdate() ? &quot;k&quot; : &quot;-&quot;);
7066     stream &lt;&lt; (layer.needsCompositingConfigurationUpdate() ? &quot;c&quot; : &quot;-&quot;);
7067     stream &lt;&lt; (layer.needsCompositingLayerConnection() ? &quot;x&quot; : &quot;-&quot;);
7068     stream &lt;&lt; (layer.needsScrollingTreeUpdate() ? &quot;s&quot; : &quot;-&quot;);
7069 
7070     stream &lt;&lt; &quot; &quot;;
7071 
7072     outputIdent(stream, depth);
7073 
7074     stream &lt;&lt; prefix;
7075 
7076     auto layerRect = layer.rect();
7077 
7078     stream &lt;&lt; &amp;layer &lt;&lt; &quot; &quot; &lt;&lt; layerRect;
7079     if (layer.isComposited()) {
7080         auto&amp; backing = *layer.backing();
7081         stream &lt;&lt; &quot; (layerID &quot; &lt;&lt; backing.graphicsLayer()-&gt;primaryLayerID() &lt;&lt; &quot;)&quot;;
7082 
<a name="124" id="anc124"></a><span class="line-added">7083         if (layer.indirectCompositingReason() != WebCore::IndirectCompositingReason::None)</span>
<span class="line-added">7084             stream &lt;&lt; &quot; &quot; &lt;&lt; layer.indirectCompositingReason();</span>
<span class="line-added">7085 </span>
7086         auto scrollingNodeID = backing.scrollingNodeIDForRole(WebCore::ScrollCoordinationRole::Scrolling);
7087         auto frameHostingNodeID = backing.scrollingNodeIDForRole(WebCore::ScrollCoordinationRole::FrameHosting);
7088         auto viewportConstrainedNodeID = backing.scrollingNodeIDForRole(WebCore::ScrollCoordinationRole::ViewportConstrained);
<a name="125" id="anc125"></a><span class="line-added">7089         auto positionedNodeID = backing.scrollingNodeIDForRole(WebCore::ScrollCoordinationRole::Positioning);</span>
7090 
<a name="126" id="anc126"></a><span class="line-modified">7091         if (scrollingNodeID || frameHostingNodeID || viewportConstrainedNodeID || positionedNodeID) {</span>
7092             stream &lt;&lt; &quot; {&quot;;
7093             bool first = true;
7094             if (scrollingNodeID) {
7095                 stream &lt;&lt; &quot;sc &quot; &lt;&lt; scrollingNodeID;
7096                 first = false;
7097             }
7098 
7099             if (frameHostingNodeID) {
7100                 if (!first)
7101                     stream &lt;&lt; &quot;, &quot;;
7102                 stream &lt;&lt; &quot;fh &quot; &lt;&lt; frameHostingNodeID;
7103                 first = false;
7104             }
7105 
7106             if (viewportConstrainedNodeID) {
7107                 if (!first)
7108                     stream &lt;&lt; &quot;, &quot;;
7109                 stream &lt;&lt; &quot;vc &quot; &lt;&lt; viewportConstrainedNodeID;
<a name="127" id="anc127"></a><span class="line-added">7110                 first = false;</span>
<span class="line-added">7111             }</span>
<span class="line-added">7112 </span>
<span class="line-added">7113             if (positionedNodeID) {</span>
<span class="line-added">7114                 if (!first)</span>
<span class="line-added">7115                     stream &lt;&lt; &quot;, &quot;;</span>
<span class="line-added">7116                 stream &lt;&lt; &quot;pos &quot; &lt;&lt; positionedNodeID;</span>
7117             }
7118 
7119             stream &lt;&lt; &quot;}&quot;;
7120         }
7121     }
7122     stream &lt;&lt; &quot; &quot; &lt;&lt; layer.name();
7123     stream.nextLine();
7124 
7125     const_cast&lt;WebCore::RenderLayer&amp;&gt;(layer).updateLayerListsIfNeeded();
7126 
7127     for (auto* child : layer.negativeZOrderLayers())
7128         outputPaintOrderTreeRecursive(stream, *child, &quot;- &quot;, depth + 1);
7129 
7130     for (auto* child : layer.normalFlowLayers())
7131         outputPaintOrderTreeRecursive(stream, *child, &quot;n &quot;, depth + 1);
7132 
7133     for (auto* child : layer.positiveZOrderLayers())
7134         outputPaintOrderTreeRecursive(stream, *child, &quot;+ &quot;, depth + 1);
7135 }
7136 
7137 void showPaintOrderTree(const WebCore::RenderLayer* layer)
7138 {
7139     TextStream stream;
7140     outputPaintOrderTreeLegend(stream);
7141     if (layer)
7142         outputPaintOrderTreeRecursive(stream, *layer, &quot;&quot;);
7143 
7144     WTFLogAlways(&quot;%s&quot;, stream.release().utf8().data());
7145 }
7146 
7147 #endif
<a name="128" id="anc128"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="128" type="hidden" />
</body>
</html>