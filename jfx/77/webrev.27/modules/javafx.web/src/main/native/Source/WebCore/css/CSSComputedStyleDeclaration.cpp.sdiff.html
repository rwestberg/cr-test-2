<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/css/CSSComputedStyleDeclaration.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CSSCalculationValue.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CSSComputedStyleDeclaration.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/css/CSSComputedStyleDeclaration.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  59 #include &quot;NodeRenderStyle.h&quot;
  60 #include &quot;Pair.h&quot;
  61 #include &quot;Rect.h&quot;
  62 #include &quot;RenderBlock.h&quot;
  63 #include &quot;RenderBox.h&quot;
  64 #include &quot;RenderInline.h&quot;
  65 #include &quot;RenderStyle.h&quot;
  66 #include &quot;RuntimeEnabledFeatures.h&quot;
  67 #include &quot;SVGElement.h&quot;
  68 #include &quot;Settings.h&quot;
  69 #include &quot;ShapeValue.h&quot;
  70 #include &quot;StyleProperties.h&quot;
  71 #include &quot;StylePropertyShorthand.h&quot;
  72 #include &quot;StylePropertyShorthandFunctions.h&quot;
  73 #include &quot;StyleResolver.h&quot;
  74 #include &quot;StyleScope.h&quot;
  75 #include &quot;StyleScrollSnapPoints.h&quot;
  76 #include &quot;TouchAction.h&quot;
  77 #include &quot;WebKitFontFamilyNames.h&quot;
  78 #include &quot;WillChangeData.h&quot;

  79 #include &lt;wtf/NeverDestroyed.h&gt;
  80 #include &lt;wtf/text/StringBuilder.h&gt;
  81 
  82 #include &quot;CSSGridLineNamesValue.h&quot;
  83 #include &quot;CSSGridTemplateAreasValue.h&quot;
  84 #include &quot;RenderGrid.h&quot;
  85 
<span class="line-removed">  86 #if ENABLE(DASHBOARD_SUPPORT)</span>
<span class="line-removed">  87 #include &quot;DashboardRegion.h&quot;</span>
<span class="line-removed">  88 #endif</span>
<span class="line-removed">  89 </span>
  90 namespace WebCore {
  91 


  92 // List of all properties we know how to compute, omitting shorthands.
  93 static const CSSPropertyID computedProperties[] = {




  94     CSSPropertyAlt,
  95     CSSPropertyAnimationDelay,
  96     CSSPropertyAnimationDirection,
  97     CSSPropertyAnimationDuration,
  98     CSSPropertyAnimationFillMode,
  99     CSSPropertyAnimationIterationCount,
 100     CSSPropertyAnimationName,
 101     CSSPropertyAnimationPlayState,
 102     CSSPropertyAnimationTimingFunction,
 103     CSSPropertyBackgroundAttachment,
 104     CSSPropertyBackgroundBlendMode,
 105     CSSPropertyBackgroundClip,
 106     CSSPropertyBackgroundColor,
 107     CSSPropertyBackgroundImage,
 108     CSSPropertyBackgroundOrigin,
 109     CSSPropertyBackgroundPosition, // more-specific background-position-x/y are non-standard
 110     CSSPropertyBackgroundRepeat,
 111     CSSPropertyBackgroundSize,

 112     CSSPropertyBorderBottomColor,
 113     CSSPropertyBorderBottomLeftRadius,
 114     CSSPropertyBorderBottomRightRadius,
 115     CSSPropertyBorderBottomStyle,
 116     CSSPropertyBorderBottomWidth,
 117     CSSPropertyBorderCollapse,
 118     CSSPropertyBorderImageOutset,
 119     CSSPropertyBorderImageRepeat,
 120     CSSPropertyBorderImageSlice,
 121     CSSPropertyBorderImageSource,
 122     CSSPropertyBorderImageWidth,
 123     CSSPropertyBorderLeftColor,
 124     CSSPropertyBorderLeftStyle,
 125     CSSPropertyBorderLeftWidth,
 126     CSSPropertyBorderRightColor,
 127     CSSPropertyBorderRightStyle,
 128     CSSPropertyBorderRightWidth,
 129     CSSPropertyBorderTopColor,
 130     CSSPropertyBorderTopLeftRadius,
 131     CSSPropertyBorderTopRightRadius,
 132     CSSPropertyBorderTopStyle,
 133     CSSPropertyBorderTopWidth,
 134     CSSPropertyBottom,
 135     CSSPropertyBoxShadow,
 136     CSSPropertyBoxSizing,

 137     CSSPropertyCaptionSide,
 138     CSSPropertyCaretColor,
 139     CSSPropertyClear,
 140     CSSPropertyClip,


 141     CSSPropertyColor,
<span class="line-modified"> 142     CSSPropertyAppleColorFilter,</span>














 143     CSSPropertyCounterIncrement,
 144     CSSPropertyCounterReset,
<span class="line-removed"> 145     CSSPropertyContent,</span>
 146     CSSPropertyCursor,


 147     CSSPropertyDirection,
 148     CSSPropertyDisplay,

 149     CSSPropertyEmptyCells,










 150     CSSPropertyFloat,


 151     CSSPropertyFontFamily,



 152     CSSPropertyFontSize,
 153     CSSPropertyFontStretch,
 154     CSSPropertyFontStyle,
 155     CSSPropertyFontSynthesis,
 156     CSSPropertyFontVariant,
<span class="line-modified"> 157     CSSPropertyFontWeight,</span>





 158 #if ENABLE(VARIATION_FONTS)
<span class="line-modified"> 159     CSSPropertyFontOpticalSizing,</span>
 160 #endif













 161     CSSPropertyHangingPunctuation,
 162     CSSPropertyHeight,
 163 #if ENABLE(CSS_IMAGE_ORIENTATION)
 164     CSSPropertyImageOrientation,
 165 #endif
 166     CSSPropertyImageRendering,
 167 #if ENABLE(CSS_IMAGE_RESOLUTION)
 168     CSSPropertyImageResolution,
 169 #endif







 170     CSSPropertyLeft,
 171     CSSPropertyLetterSpacing,


 172     CSSPropertyLineHeight,
 173     CSSPropertyListStyleImage,
 174     CSSPropertyListStylePosition,
 175     CSSPropertyListStyleType,
 176     CSSPropertyMarginBottom,
 177     CSSPropertyMarginLeft,
 178     CSSPropertyMarginRight,
 179     CSSPropertyMarginTop,





 180     CSSPropertyMaxHeight,
 181     CSSPropertyMaxWidth,
 182     CSSPropertyMinHeight,
 183     CSSPropertyMinWidth,



 184     CSSPropertyObjectFit,
 185     CSSPropertyObjectPosition,
 186     CSSPropertyOpacity,

 187     CSSPropertyOrphans,
 188     CSSPropertyOutlineColor,
 189     CSSPropertyOutlineOffset,
 190     CSSPropertyOutlineStyle,
 191     CSSPropertyOutlineWidth,
 192     CSSPropertyOverflowWrap,
 193     CSSPropertyOverflowX,
 194     CSSPropertyOverflowY,
 195     CSSPropertyPaddingBottom,
 196     CSSPropertyPaddingLeft,
 197     CSSPropertyPaddingRight,
 198     CSSPropertyPaddingTop,
 199     CSSPropertyPageBreakAfter,
 200     CSSPropertyPageBreakBefore,
 201     CSSPropertyPageBreakInside,






 202     CSSPropertyPointerEvents,
 203     CSSPropertyPosition,

 204     CSSPropertyResize,
 205     CSSPropertyRight,





















 206     CSSPropertySpeakAs,
<span class="line-modified"> 207     CSSPropertyTableLayout,</span>










 208     CSSPropertyTabSize,

 209     CSSPropertyTextAlign,

 210     CSSPropertyTextDecoration,
<span class="line-removed"> 211 #if ENABLE(CSS3_TEXT)</span>
<span class="line-removed"> 212     CSSPropertyWebkitTextAlignLast,</span>
<span class="line-removed"> 213     CSSPropertyWebkitTextJustify,</span>
<span class="line-removed"> 214 #endif // CSS3_TEXT</span>
<span class="line-removed"> 215     CSSPropertyTextDecorationLine,</span>
<span class="line-removed"> 216     CSSPropertyTextDecorationStyle,</span>
 217     CSSPropertyTextDecorationColor,

 218     CSSPropertyTextDecorationSkip,
<span class="line-modified"> 219     CSSPropertyTextUnderlinePosition,</span>
 220     CSSPropertyTextIndent,

 221     CSSPropertyTextRendering,
 222     CSSPropertyTextShadow,
<span class="line-removed"> 223     CSSPropertyTextOverflow,</span>
 224     CSSPropertyTextTransform,

 225     CSSPropertyTop,



 226     CSSPropertyTransform,
 227     CSSPropertyTransformBox,
 228     CSSPropertyTransformOrigin,
 229     CSSPropertyTransformStyle,
 230     CSSPropertyTransitionDelay,
 231     CSSPropertyTransitionDuration,
 232     CSSPropertyTransitionProperty,
 233     CSSPropertyTransitionTimingFunction,
 234     CSSPropertyUnicodeBidi,

 235     CSSPropertyVerticalAlign,
 236     CSSPropertyVisibility,
 237     CSSPropertyWhiteSpace,
 238     CSSPropertyWidows,
 239     CSSPropertyWidth,
 240     CSSPropertyWillChange,
 241     CSSPropertyWordBreak,
 242     CSSPropertyWordSpacing,
 243     CSSPropertyWordWrap,
<span class="line-modified"> 244 #if ENABLE(CSS_SCROLL_SNAP)</span>
<span class="line-modified"> 245     CSSPropertyScrollSnapMargin,</span>
<span class="line-modified"> 246     CSSPropertyScrollSnapMarginLeft,</span>
<span class="line-removed"> 247     CSSPropertyScrollSnapMarginTop,</span>
<span class="line-removed"> 248     CSSPropertyScrollSnapMarginRight,</span>
<span class="line-removed"> 249     CSSPropertyScrollSnapMarginBottom,</span>
<span class="line-removed"> 250     CSSPropertyScrollPadding,</span>
<span class="line-removed"> 251     CSSPropertyScrollPaddingLeft,</span>
<span class="line-removed"> 252     CSSPropertyScrollPaddingTop,</span>
<span class="line-removed"> 253     CSSPropertyScrollPaddingRight,</span>
<span class="line-removed"> 254     CSSPropertyScrollPaddingBottom,</span>
<span class="line-removed"> 255     CSSPropertyScrollSnapType,</span>
<span class="line-removed"> 256     CSSPropertyScrollSnapAlign,</span>
<span class="line-removed"> 257 #endif</span>
 258     CSSPropertyZIndex,
 259     CSSPropertyZoom,

 260     CSSPropertyWebkitAppearance,



 261     CSSPropertyWebkitBackfaceVisibility,
 262     CSSPropertyWebkitBackgroundClip,
 263     CSSPropertyWebkitBackgroundComposite,
 264     CSSPropertyWebkitBackgroundOrigin,
 265     CSSPropertyWebkitBackgroundSize,
<span class="line-removed"> 266 #if ENABLE(CSS_COMPOSITING)</span>
<span class="line-removed"> 267     CSSPropertyMixBlendMode,</span>
<span class="line-removed"> 268     CSSPropertyIsolation,</span>
<span class="line-removed"> 269 #endif</span>
 270     CSSPropertyWebkitBorderFit,
 271     CSSPropertyWebkitBorderHorizontalSpacing,
 272     CSSPropertyWebkitBorderImage,
 273     CSSPropertyWebkitBorderVerticalSpacing,
 274     CSSPropertyWebkitBoxAlign,
 275 #if ENABLE(CSS_BOX_DECORATION_BREAK)
 276     CSSPropertyWebkitBoxDecorationBreak,
 277 #endif
 278     CSSPropertyWebkitBoxDirection,
 279     CSSPropertyWebkitBoxFlex,
 280     CSSPropertyWebkitBoxFlexGroup,
 281     CSSPropertyWebkitBoxLines,
 282     CSSPropertyWebkitBoxOrdinalGroup,
 283     CSSPropertyWebkitBoxOrient,
 284     CSSPropertyWebkitBoxPack,
 285     CSSPropertyWebkitBoxReflect,
 286     CSSPropertyWebkitBoxShadow,
 287     CSSPropertyWebkitClipPath,

 288     CSSPropertyWebkitColumnBreakAfter,
 289     CSSPropertyWebkitColumnBreakBefore,
 290     CSSPropertyWebkitColumnBreakInside,
<span class="line-removed"> 291     CSSPropertyWebkitColumnAxis,</span>
<span class="line-removed"> 292     CSSPropertyColumnCount,</span>
<span class="line-removed"> 293     CSSPropertyColumnFill,</span>
<span class="line-removed"> 294     CSSPropertyColumnGap,</span>
<span class="line-removed"> 295     CSSPropertyRowGap,</span>
 296     CSSPropertyWebkitColumnProgression,
<span class="line-removed"> 297     CSSPropertyColumnRuleColor,</span>
<span class="line-removed"> 298     CSSPropertyColumnRuleStyle,</span>
<span class="line-removed"> 299     CSSPropertyColumnRuleWidth,</span>
<span class="line-removed"> 300     CSSPropertyColumnSpan,</span>
<span class="line-removed"> 301     CSSPropertyColumnWidth,</span>
 302 #if ENABLE(CURSOR_VISIBILITY)
 303     CSSPropertyWebkitCursorVisibility,
<span class="line-removed"> 304 #endif</span>
<span class="line-removed"> 305 #if ENABLE(DASHBOARD_SUPPORT)</span>
<span class="line-removed"> 306     CSSPropertyWebkitDashboardRegion,</span>
<span class="line-removed"> 307 #endif</span>
<span class="line-removed"> 308     CSSPropertyAlignContent,</span>
<span class="line-removed"> 309     CSSPropertyAlignItems,</span>
<span class="line-removed"> 310     CSSPropertyAlignSelf,</span>
<span class="line-removed"> 311     CSSPropertyFilter,</span>
<span class="line-removed"> 312     CSSPropertyFlexBasis,</span>
<span class="line-removed"> 313     CSSPropertyFlexDirection,</span>
<span class="line-removed"> 314     CSSPropertyFlexFlow,</span>
<span class="line-removed"> 315     CSSPropertyFlexGrow,</span>
<span class="line-removed"> 316     CSSPropertyFlexShrink,</span>
<span class="line-removed"> 317     CSSPropertyFlexWrap,</span>
<span class="line-removed"> 318     CSSPropertyJustifyContent,</span>
<span class="line-removed"> 319     CSSPropertyJustifySelf,</span>
<span class="line-removed"> 320     CSSPropertyJustifyItems,</span>
<span class="line-removed"> 321     CSSPropertyPlaceContent,</span>
<span class="line-removed"> 322     CSSPropertyPlaceItems,</span>
<span class="line-removed"> 323     CSSPropertyPlaceSelf,</span>
<span class="line-removed"> 324 #if ENABLE(FILTERS_LEVEL_2)</span>
<span class="line-removed"> 325     CSSPropertyWebkitBackdropFilter,</span>
 326 #endif
 327     CSSPropertyWebkitFontKerning,
 328     CSSPropertyWebkitFontSmoothing,
<span class="line-removed"> 329     CSSPropertyFontVariantLigatures,</span>
<span class="line-removed"> 330     CSSPropertyFontVariantPosition,</span>
<span class="line-removed"> 331     CSSPropertyFontVariantCaps,</span>
<span class="line-removed"> 332     CSSPropertyFontVariantNumeric,</span>
<span class="line-removed"> 333     CSSPropertyFontVariantAlternates,</span>
<span class="line-removed"> 334     CSSPropertyFontVariantEastAsian,</span>
<span class="line-removed"> 335 #if ENABLE(VARIATION_FONTS)</span>
<span class="line-removed"> 336     CSSPropertyFontVariationSettings,</span>
<span class="line-removed"> 337 #endif</span>
<span class="line-removed"> 338     CSSPropertyGridAutoColumns,</span>
<span class="line-removed"> 339     CSSPropertyGridAutoFlow,</span>
<span class="line-removed"> 340     CSSPropertyGridAutoRows,</span>
<span class="line-removed"> 341     CSSPropertyGridColumnEnd,</span>
<span class="line-removed"> 342     CSSPropertyGridColumnStart,</span>
<span class="line-removed"> 343     CSSPropertyGridTemplateAreas,</span>
<span class="line-removed"> 344     CSSPropertyGridTemplateColumns,</span>
<span class="line-removed"> 345     CSSPropertyGridTemplateRows,</span>
<span class="line-removed"> 346     CSSPropertyGridRowEnd,</span>
<span class="line-removed"> 347     CSSPropertyGridRowStart,</span>
 348     CSSPropertyWebkitHyphenateCharacter,
 349     CSSPropertyWebkitHyphenateLimitAfter,
 350     CSSPropertyWebkitHyphenateLimitBefore,
 351     CSSPropertyWebkitHyphenateLimitLines,
 352     CSSPropertyWebkitHyphens,
 353     CSSPropertyWebkitInitialLetter,
 354     CSSPropertyWebkitLineAlign,
 355     CSSPropertyWebkitLineBoxContain,
<span class="line-removed"> 356     CSSPropertyLineBreak,</span>
 357     CSSPropertyWebkitLineClamp,
 358     CSSPropertyWebkitLineGrid,
 359     CSSPropertyWebkitLineSnap,
 360     CSSPropertyWebkitLocale,
<span class="line-removed"> 361     CSSPropertyWebkitMarginBeforeCollapse,</span>
 362     CSSPropertyWebkitMarginAfterCollapse,

 363     CSSPropertyWebkitMarqueeDirection,
 364     CSSPropertyWebkitMarqueeIncrement,
 365     CSSPropertyWebkitMarqueeRepetition,
 366     CSSPropertyWebkitMarqueeStyle,
 367     CSSPropertyWebkitMaskBoxImage,
 368     CSSPropertyWebkitMaskBoxImageOutset,
 369     CSSPropertyWebkitMaskBoxImageRepeat,
 370     CSSPropertyWebkitMaskBoxImageSlice,
 371     CSSPropertyWebkitMaskBoxImageSource,
 372     CSSPropertyWebkitMaskBoxImageWidth,
 373     CSSPropertyWebkitMaskClip,
 374     CSSPropertyWebkitMaskComposite,
 375     CSSPropertyWebkitMaskImage,
 376     CSSPropertyWebkitMaskOrigin,
 377     CSSPropertyWebkitMaskPosition,
 378     CSSPropertyWebkitMaskRepeat,
 379     CSSPropertyWebkitMaskSize,
 380     CSSPropertyWebkitMaskSourceType,
 381     CSSPropertyWebkitNbspMode,
<span class="line-modified"> 382     CSSPropertyOrder,</span>
<span class="line-removed"> 383 #if ENABLE(ACCELERATED_OVERFLOW_SCROLLING)</span>
 384     CSSPropertyWebkitOverflowScrolling,
 385 #endif
<span class="line-removed"> 386     CSSPropertyPerspective,</span>
<span class="line-removed"> 387     CSSPropertyPerspectiveOrigin,</span>
 388     CSSPropertyWebkitPrintColorAdjust,
 389     CSSPropertyWebkitRtlOrdering,
<span class="line-removed"> 390 #if PLATFORM(IOS_FAMILY)</span>
<span class="line-removed"> 391     CSSPropertyWebkitTouchCallout,</span>
<span class="line-removed"> 392 #endif</span>
 393 #if ENABLE(TOUCH_EVENTS)
 394     CSSPropertyWebkitTapHighlightColor,



 395 #endif
 396     CSSPropertyWebkitTextCombine,
 397     CSSPropertyWebkitTextDecorationsInEffect,
 398     CSSPropertyWebkitTextEmphasisColor,
 399     CSSPropertyWebkitTextEmphasisPosition,
 400     CSSPropertyWebkitTextEmphasisStyle,
 401     CSSPropertyWebkitTextFillColor,



 402     CSSPropertyWebkitTextOrientation,
 403     CSSPropertyWebkitTextSecurity,
 404 #if ENABLE(TEXT_AUTOSIZING)
 405     CSSPropertyWebkitTextSizeAdjust,
 406 #endif
 407     CSSPropertyWebkitTextStrokeColor,
 408     CSSPropertyWebkitTextStrokeWidth,
 409     CSSPropertyWebkitTextZoom,



 410     CSSPropertyWebkitTransformStyle,
 411     CSSPropertyWebkitUserDrag,
 412     CSSPropertyWebkitUserModify,
 413     CSSPropertyWebkitUserSelect,
<span class="line-removed"> 414     CSSPropertyShapeImageThreshold,</span>
<span class="line-removed"> 415     CSSPropertyShapeMargin,</span>
<span class="line-removed"> 416     CSSPropertyShapeOutside,</span>
<span class="line-removed"> 417     CSSPropertyShapeRendering,</span>
<span class="line-removed"> 418     CSSPropertyBufferedRendering,</span>
<span class="line-removed"> 419     CSSPropertyClipPath,</span>
<span class="line-removed"> 420     CSSPropertyClipRule,</span>
<span class="line-removed"> 421     CSSPropertyCx,</span>
<span class="line-removed"> 422     CSSPropertyCy,</span>
<span class="line-removed"> 423     CSSPropertyMask,</span>
<span class="line-removed"> 424     CSSPropertyMaskType,</span>
<span class="line-removed"> 425     CSSPropertyFloodColor,</span>
<span class="line-removed"> 426     CSSPropertyFloodOpacity,</span>
<span class="line-removed"> 427     CSSPropertyLightingColor,</span>
<span class="line-removed"> 428     CSSPropertyStopColor,</span>
<span class="line-removed"> 429     CSSPropertyStopOpacity,</span>
<span class="line-removed"> 430     CSSPropertyColorInterpolation,</span>
<span class="line-removed"> 431     CSSPropertyColorInterpolationFilters,</span>
<span class="line-removed"> 432     CSSPropertyColorRendering,</span>
<span class="line-removed"> 433     CSSPropertyFill,</span>
<span class="line-removed"> 434     CSSPropertyFillOpacity,</span>
<span class="line-removed"> 435     CSSPropertyFillRule,</span>
<span class="line-removed"> 436     CSSPropertyMarkerEnd,</span>
<span class="line-removed"> 437     CSSPropertyMarkerMid,</span>
<span class="line-removed"> 438     CSSPropertyMarkerStart,</span>
<span class="line-removed"> 439     CSSPropertyPaintOrder,</span>
<span class="line-removed"> 440     CSSPropertyR,</span>
<span class="line-removed"> 441     CSSPropertyRx,</span>
<span class="line-removed"> 442     CSSPropertyRy,</span>
<span class="line-removed"> 443     CSSPropertyStroke,</span>
<span class="line-removed"> 444     CSSPropertyStrokeColor,</span>
<span class="line-removed"> 445     CSSPropertyStrokeDasharray,</span>
<span class="line-removed"> 446     CSSPropertyStrokeDashoffset,</span>
<span class="line-removed"> 447     CSSPropertyStrokeLinecap,</span>
<span class="line-removed"> 448     CSSPropertyStrokeLinejoin,</span>
<span class="line-removed"> 449     CSSPropertyStrokeMiterlimit,</span>
<span class="line-removed"> 450     CSSPropertyStrokeOpacity,</span>
<span class="line-removed"> 451     CSSPropertyStrokeWidth,</span>
<span class="line-removed"> 452 #if ENABLE(DARK_MODE_CSS)</span>
<span class="line-removed"> 453     CSSPropertySupportedColorSchemes,</span>
<span class="line-removed"> 454 #endif</span>
<span class="line-removed"> 455     CSSPropertyAlignmentBaseline,</span>
<span class="line-removed"> 456     CSSPropertyBaselineShift,</span>
<span class="line-removed"> 457     CSSPropertyDominantBaseline,</span>
<span class="line-removed"> 458     CSSPropertyKerning,</span>
<span class="line-removed"> 459     CSSPropertyTextAnchor,</span>
<span class="line-removed"> 460     CSSPropertyWritingMode,</span>
<span class="line-removed"> 461     CSSPropertyGlyphOrientationHorizontal,</span>
<span class="line-removed"> 462     CSSPropertyGlyphOrientationVertical,</span>
<span class="line-removed"> 463     CSSPropertyVectorEffect,</span>
<span class="line-removed"> 464     CSSPropertyX,</span>
<span class="line-removed"> 465     CSSPropertyY</span>
 466 };
 467 
 468 const unsigned numComputedProperties = WTF_ARRAY_LENGTH(computedProperties);
 469 
 470 static CSSValueID valueForRepeatRule(int rule)
 471 {
 472     switch (rule) {
 473         case RepeatImageRule:
 474             return CSSValueRepeat;
 475         case RoundImageRule:
 476             return CSSValueRound;
 477         case SpaceImageRule:
 478             return CSSValueSpace;
 479         default:
 480             return CSSValueStretch;
 481     }
 482 }
 483 
 484 static Ref&lt;CSSPrimitiveValue&gt; valueForImageSliceSide(const Length&amp; length)
 485 {
</pre>
<hr />
<pre>
 760         return container.clientWidth() - (box.offsetLeft() + box.offsetWidth()) - box.marginRight();
 761     default:
 762         ASSERT_NOT_REACHED();
 763     }
 764 
 765     return 0;
 766 }
 767 
 768 static RefPtr&lt;CSSValue&gt; positionOffsetValue(const RenderStyle&amp; style, CSSPropertyID propertyID, RenderObject* renderer)
 769 {
 770     auto offset = getOffsetComputedLength(style, propertyID);
 771 
 772     // If the element is not displayed; return the &quot;computed value&quot;.
 773     if (!renderer || !renderer-&gt;isBox())
 774         return zoomAdjustedPixelValueForLength(offset, style);
 775 
 776     auto&amp; box = downcast&lt;RenderBox&gt;(*renderer);
 777     auto* containingBlock = box.containingBlock();
 778 
 779     // Resolve a &quot;computed value&quot; percentage if the element is positioned.
<span class="line-modified"> 780     // TODO: percentages for sticky positioning should be handled here (bug 189549).</span>
<span class="line-removed"> 781     if (containingBlock &amp;&amp; offset.isPercentOrCalculated() &amp;&amp; box.isPositioned() &amp;&amp; !box.isStickilyPositioned()) {</span>
 782         bool isVerticalProperty;
 783         if (propertyID == CSSPropertyTop || propertyID == CSSPropertyBottom)
 784             isVerticalProperty = true;
 785         else {
 786             ASSERT(propertyID == CSSPropertyLeft || propertyID == CSSPropertyRight);
 787             isVerticalProperty = false;
 788         }
 789         LayoutUnit containingBlockSize;
<span class="line-modified"> 790         if (isVerticalProperty == containingBlock-&gt;isHorizontalWritingMode()) {</span>
<span class="line-modified"> 791             containingBlockSize = box.isOutOfFlowPositioned()</span>
<span class="line-modified"> 792                 ? box.containingBlockLogicalHeightForPositioned(*containingBlock, false)</span>
<span class="line-modified"> 793                 : box.containingBlockLogicalHeightForContent(ExcludeMarginBorderPadding);</span>


 794         } else {
<span class="line-modified"> 795             containingBlockSize = box.isOutOfFlowPositioned()</span>
<span class="line-modified"> 796                 ? box.containingBlockLogicalWidthForPositioned(*containingBlock, nullptr, false)</span>
<span class="line-modified"> 797                 : box.containingBlockLogicalWidthForContent();</span>






 798         }
 799         return zoomAdjustedPixelValue(floatValueForLength(offset, containingBlockSize), style);
 800     }
 801 
 802     // Return a &quot;computed value&quot; length.
 803     if (!offset.isAuto())
 804         return zoomAdjustedPixelValueForLength(offset, style);
 805 
 806     // The property won&#39;t be overconstrained if its computed value is &quot;auto&quot;, so the &quot;used value&quot; can be returned.
 807     if (box.isRelativelyPositioned())
 808         return zoomAdjustedPixelValue(getOffsetUsedStyleRelative(box, propertyID), style);
 809 
 810     if (containingBlock &amp;&amp; box.isOutOfFlowPositioned())
 811         return zoomAdjustedPixelValue(getOffsetUsedStyleOutOfFlowPositioned(*containingBlock, box, propertyID), style);
 812 
 813     return CSSValuePool::singleton().createIdentifierValue(CSSValueAuto);
 814 }
 815 
 816 Ref&lt;CSSPrimitiveValue&gt; ComputedStyleExtractor::currentColorOrValidColor(const RenderStyle* style, const Color&amp; color) const
 817 {
</pre>
<hr />
<pre>
 943     return transformValue.releaseNonNull();
 944 }
 945 
 946 static Ref&lt;CSSValue&gt; computedTransform(RenderObject* renderer, const RenderStyle&amp; style)
 947 {
 948     // Inline renderers do not support transforms.
 949     if (!renderer || is&lt;RenderInline&gt;(*renderer) || !style.hasTransform())
 950         return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
 951 
 952     FloatRect pixelSnappedRect;
 953     if (is&lt;RenderBox&gt;(*renderer))
 954         pixelSnappedRect = snapRectToDevicePixels(downcast&lt;RenderBox&gt;(*renderer).borderBoxRect(), renderer-&gt;document().deviceScaleFactor());
 955 
 956     TransformationMatrix transform;
 957     style.applyTransform(transform, pixelSnappedRect, RenderStyle::ExcludeTransformOrigin);
 958     // Note that this does not flatten to an affine transform if ENABLE(3D_TRANSFORMS) is off, by design.
 959 
 960     // FIXME: Need to print out individual functions (https://bugs.webkit.org/show_bug.cgi?id=23924)
 961     auto list = CSSValueList::createSpaceSeparated();
 962     list-&gt;append(matrixTransformValue(transform, style));
<span class="line-modified"> 963     return WTFMove(list);</span>
 964 }
 965 
 966 static inline Ref&lt;CSSPrimitiveValue&gt; adjustLengthForZoom(double length, const RenderStyle&amp; style, AdjustPixelValuesForComputedStyle adjust)
 967 {
 968     return adjust == AdjustPixelValues ? zoomAdjustedPixelValue(length, style) : CSSValuePool::singleton().createValue(length, CSSPrimitiveValue::CSS_PX);
 969 }
 970 
 971 static inline Ref&lt;CSSPrimitiveValue&gt; adjustLengthForZoom(const Length&amp; length, const RenderStyle&amp; style, AdjustPixelValuesForComputedStyle adjust)
 972 {
 973     return adjust == AdjustPixelValues ? zoomAdjustedPixelValue(length.value(), style) : CSSValuePool::singleton().createValue(length);
 974 }
 975 
 976 Ref&lt;CSSValue&gt; ComputedStyleExtractor::valueForShadow(const ShadowData* shadow, CSSPropertyID propertyID, const RenderStyle&amp; style, AdjustPixelValuesForComputedStyle adjust)
 977 {
 978     auto&amp; cssValuePool = CSSValuePool::singleton();
 979     if (!shadow)
 980         return cssValuePool.createIdentifierValue(CSSValueNone);
 981 
 982     auto list = CSSValueList::createCommaSeparated();
 983     for (const ShadowData* currShadowData = shadow; currShadowData; currShadowData = currShadowData-&gt;next()) {
 984         auto x = adjustLengthForZoom(currShadowData-&gt;x(), style, adjust);
 985         auto y = adjustLengthForZoom(currShadowData-&gt;y(), style, adjust);
 986         auto blur = adjustLengthForZoom(currShadowData-&gt;radius(), style, adjust);
 987         auto spread = propertyID == CSSPropertyTextShadow ? RefPtr&lt;CSSPrimitiveValue&gt;() : adjustLengthForZoom(currShadowData-&gt;spread(), style, adjust);
 988         auto style = propertyID == CSSPropertyTextShadow || currShadowData-&gt;style() == Normal ? RefPtr&lt;CSSPrimitiveValue&gt;() : cssValuePool.createIdentifierValue(CSSValueInset);
 989         auto color = cssValuePool.createColorValue(currShadowData-&gt;color());
 990         list-&gt;prepend(CSSShadowValue::create(WTFMove(x), WTFMove(y), WTFMove(blur), WTFMove(spread), WTFMove(style), WTFMove(color)));
 991     }
<span class="line-modified"> 992     return WTFMove(list);</span>
 993 }
 994 
 995 Ref&lt;CSSValue&gt; ComputedStyleExtractor::valueForFilter(const RenderStyle&amp; style, const FilterOperations&amp; filterOperations, AdjustPixelValuesForComputedStyle adjust)
 996 {
 997     auto&amp; cssValuePool = CSSValuePool::singleton();
 998     if (filterOperations.operations().isEmpty())
 999         return cssValuePool.createIdentifierValue(CSSValueNone);
1000 
1001     auto list = CSSValueList::createSpaceSeparated();
1002 
1003     Vector&lt;RefPtr&lt;FilterOperation&gt;&gt;::const_iterator end = filterOperations.operations().end();
1004     for (Vector&lt;RefPtr&lt;FilterOperation&gt;&gt;::const_iterator it = filterOperations.operations().begin(); it != end; ++it) {
1005         FilterOperation&amp; filterOperation = **it;
1006 
1007         if (filterOperation.type() == FilterOperation::REFERENCE) {
1008             ReferenceFilterOperation&amp; referenceOperation = downcast&lt;ReferenceFilterOperation&gt;(filterOperation);
1009             list-&gt;append(cssValuePool.createValue(referenceOperation.url(), CSSPrimitiveValue::CSS_URI));
1010         } else {
1011             RefPtr&lt;CSSFunctionValue&gt; filterValue;
1012             switch (filterOperation.type()) {
</pre>
<hr />
<pre>
1058                 filterValue = CSSFunctionValue::create(CSSValueBlur);
1059                 filterValue-&gt;append(adjustLengthForZoom(downcast&lt;BlurFilterOperation&gt;(filterOperation).stdDeviation(), style, adjust));
1060                 break;
1061             }
1062             case FilterOperation::DROP_SHADOW: {
1063                 DropShadowFilterOperation&amp; dropShadowOperation = downcast&lt;DropShadowFilterOperation&gt;(filterOperation);
1064                 filterValue = CSSFunctionValue::create(CSSValueDropShadow);
1065                 // We want our computed style to look like that of a text shadow (has neither spread nor inset style).
1066                 ShadowData shadowData = ShadowData(dropShadowOperation.location(), dropShadowOperation.stdDeviation(), 0, Normal, false, dropShadowOperation.color());
1067                 filterValue-&gt;append(valueForShadow(&amp;shadowData, CSSPropertyTextShadow, style, adjust));
1068                 break;
1069             }
1070             default:
1071                 ASSERT_NOT_REACHED();
1072                 filterValue = CSSFunctionValue::create(CSSValueInvalid);
1073                 break;
1074             }
1075             list-&gt;append(filterValue.releaseNonNull());
1076         }
1077     }
<span class="line-modified">1078     return WTFMove(list);</span>
1079 }
1080 
1081 static Ref&lt;CSSValue&gt; specifiedValueForGridTrackBreadth(const GridLength&amp; trackBreadth, const RenderStyle&amp; style)
1082 {
1083     if (!trackBreadth.isLength())
1084         return CSSValuePool::singleton().createValue(trackBreadth.flex(), CSSPrimitiveValue::CSS_FR);
1085 
1086     const Length&amp; trackBreadthLength = trackBreadth.length();
1087     if (trackBreadthLength.isAuto())
1088         return CSSValuePool::singleton().createIdentifierValue(CSSValueAuto);
1089     return zoomAdjustedPixelValueForLength(trackBreadthLength, style);
1090 }
1091 
1092 static Ref&lt;CSSValue&gt; specifiedValueForGridTrackSize(const GridTrackSize&amp; trackSize, const RenderStyle&amp; style)
1093 {
1094     switch (trackSize.type()) {
1095     case LengthTrackSizing:
1096         return specifiedValueForGridTrackBreadth(trackSize.minTrackBreadth(), style);
1097     case FitContentTrackSizing: {
1098         auto fitContentTrackSize = CSSFunctionValue::create(CSSValueFitContent);
1099         fitContentTrackSize-&gt;append(zoomAdjustedPixelValueForLength(trackSize.fitContentTrackBreadth().length(), style));
<span class="line-modified">1100         return WTFMove(fitContentTrackSize);</span>
1101     }
1102     default:
1103         ASSERT(trackSize.type() == MinMaxTrackSizing);
1104         if (trackSize.minTrackBreadth().isAuto() &amp;&amp; trackSize.maxTrackBreadth().isFlex())
1105             return CSSValuePool::singleton().createValue(trackSize.maxTrackBreadth().flex(), CSSPrimitiveValue::CSS_FR);
1106 
1107         auto minMaxTrackBreadths = CSSFunctionValue::create(CSSValueMinmax);
1108         minMaxTrackBreadths-&gt;append(specifiedValueForGridTrackBreadth(trackSize.minTrackBreadth(), style));
1109         minMaxTrackBreadths-&gt;append(specifiedValueForGridTrackBreadth(trackSize.maxTrackBreadth(), style));
<span class="line-modified">1110         return WTFMove(minMaxTrackBreadths);</span>
1111     }
1112 }
1113 
1114 class OrderedNamedLinesCollector {
1115     WTF_MAKE_NONCOPYABLE(OrderedNamedLinesCollector);
1116 public:
1117     OrderedNamedLinesCollector(const RenderStyle&amp; style, bool isRowAxis, unsigned autoRepeatTracksCount)
1118         : m_orderedNamedGridLines(isRowAxis ? style.orderedNamedGridColumnLines() : style.orderedNamedGridRowLines())
1119         , m_orderedNamedAutoRepeatGridLines(isRowAxis ? style.autoRepeatOrderedNamedGridColumnLines() : style.autoRepeatOrderedNamedGridRowLines())
1120         , m_insertionPoint(isRowAxis ? style.gridAutoRepeatColumnsInsertionPoint() : style.gridAutoRepeatRowsInsertionPoint())
1121         , m_autoRepeatTotalTracks(autoRepeatTracksCount)
1122         , m_autoRepeatTrackListLength(isRowAxis ? style.gridAutoRepeatColumns().size() : style.gridAutoRepeatRows().size())
1123     {
1124     }
1125 
1126     bool isEmpty() const { return m_orderedNamedGridLines.isEmpty() &amp;&amp; m_orderedNamedAutoRepeatGridLines.isEmpty(); }
1127     void collectLineNamesForIndex(CSSGridLineNamesValue&amp;, unsigned index) const;
1128 
1129 private:
1130 
</pre>
<hr />
<pre>
1231     if (isRenderGrid) {
1232         auto computedTrackSizes = downcast&lt;RenderGrid&gt;(*renderer).trackSizesForComputedStyle(direction);
1233         unsigned numTracks = computedTrackSizes.size();
1234 
1235         for (unsigned i = 0; i &lt; numTracks; ++i) {
1236             addValuesForNamedGridLinesAtIndex(collector, i, list.get());
1237             list-&gt;append(zoomAdjustedPixelValue(computedTrackSizes[i], style));
1238         }
1239         addValuesForNamedGridLinesAtIndex(collector, numTracks + 1, list.get());
1240         insertionIndex = numTracks;
1241     } else {
1242         for (unsigned i = 0; i &lt; trackSizes.size(); ++i) {
1243             addValuesForNamedGridLinesAtIndex(collector, i, list.get());
1244             list-&gt;append(specifiedValueForGridTrackSize(trackSizes[i], style));
1245         }
1246         insertionIndex = trackSizes.size();
1247     }
1248 
1249     // Those are the trailing &lt;ident&gt;* allowed in the syntax.
1250     addValuesForNamedGridLinesAtIndex(collector, insertionIndex, list.get());
<span class="line-modified">1251     return WTFMove(list);</span>
1252 }
1253 
1254 static Ref&lt;CSSValue&gt; valueForGridPosition(const GridPosition&amp; position)
1255 {
1256     auto&amp; cssValuePool = CSSValuePool::singleton();
1257     if (position.isAuto())
1258         return cssValuePool.createIdentifierValue(CSSValueAuto);
1259 
1260     if (position.isNamedGridArea())
1261         return cssValuePool.createValue(position.namedGridLine(), CSSPrimitiveValue::CSS_STRING);
1262 
1263     auto list = CSSValueList::createSpaceSeparated();
1264     if (position.isSpan()) {
1265         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueSpan));
1266         list-&gt;append(cssValuePool.createValue(position.spanPosition(), CSSPrimitiveValue::CSS_NUMBER));
1267     } else
1268         list-&gt;append(cssValuePool.createValue(position.integerPosition(), CSSPrimitiveValue::CSS_NUMBER));
1269 
1270     if (!position.namedGridLine().isNull())
1271         list-&gt;append(cssValuePool.createValue(position.namedGridLine(), CSSPrimitiveValue::CSS_STRING));
<span class="line-modified">1272     return WTFMove(list);</span>
1273 }
1274 
1275 static Ref&lt;CSSValue&gt; createTransitionPropertyValue(const Animation&amp; animation)
1276 {
1277     switch (animation.animationMode()) {
1278     case Animation::AnimateNone:
1279         return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
1280     case Animation::AnimateAll:
1281         return CSSValuePool::singleton().createIdentifierValue(CSSValueAll);
1282     case Animation::AnimateSingleProperty:
1283         return CSSValuePool::singleton().createValue(getPropertyNameString(animation.property()), CSSPrimitiveValue::CSS_STRING);
1284     case Animation::AnimateUnknownProperty:
1285         return CSSValuePool::singleton().createValue(animation.unknownProperty(), CSSPrimitiveValue::CSS_STRING);
1286     }
1287     ASSERT_NOT_REACHED();
1288     return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
1289 }
1290 
1291 static Ref&lt;CSSValueList&gt; transitionPropertyValue(const AnimationList* animationList)
1292 {
</pre>
<hr />
<pre>
1331 
1332     auto list = CSSValueList::createCommaSeparated();
1333     for (size_t i = 0; i &lt; willChangeData-&gt;numFeatures(); ++i) {
1334         WillChangeData::FeaturePropertyPair feature = willChangeData-&gt;featureAt(i);
1335         switch (feature.first) {
1336         case WillChangeData::ScrollPosition:
1337             list-&gt;append(cssValuePool.createIdentifierValue(CSSValueScrollPosition));
1338             break;
1339         case WillChangeData::Contents:
1340             list-&gt;append(cssValuePool.createIdentifierValue(CSSValueContents));
1341             break;
1342         case WillChangeData::Property:
1343             list-&gt;append(cssValuePool.createIdentifierValue(feature.second));
1344             break;
1345         case WillChangeData::Invalid:
1346             ASSERT_NOT_REACHED();
1347             break;
1348         }
1349     }
1350 
<span class="line-modified">1351     return WTFMove(list);</span>
1352 }
1353 
1354 static inline void appendLigaturesValue(CSSValueList&amp; list, FontVariantLigatures value, CSSValueID yesValue, CSSValueID noValue)
1355 {
1356     switch (value) {
1357     case FontVariantLigatures::Normal:
1358         return;
1359     case FontVariantLigatures::No:
1360         list.append(CSSValuePool::singleton().createIdentifierValue(noValue));
1361         return;
1362     case FontVariantLigatures::Yes:
1363         list.append(CSSValuePool::singleton().createIdentifierValue(yesValue));
1364         return;
1365     }
1366     ASSERT_NOT_REACHED();
1367 }
1368 
1369 static Ref&lt;CSSValue&gt; fontVariantLigaturesPropertyValue(FontVariantLigatures common, FontVariantLigatures discretionary, FontVariantLigatures historical, FontVariantLigatures contextualAlternates)
1370 {
1371     auto&amp; cssValuePool = CSSValuePool::singleton();
1372     if (common == FontVariantLigatures::No &amp;&amp; discretionary == FontVariantLigatures::No &amp;&amp; historical == FontVariantLigatures::No &amp;&amp; contextualAlternates == FontVariantLigatures::No)
1373         return cssValuePool.createIdentifierValue(CSSValueNone);
1374     if (common == FontVariantLigatures::Normal &amp;&amp; discretionary == FontVariantLigatures::Normal &amp;&amp; historical == FontVariantLigatures::Normal &amp;&amp; contextualAlternates == FontVariantLigatures::Normal)
1375         return cssValuePool.createIdentifierValue(CSSValueNormal);
1376 
1377     auto valueList = CSSValueList::createSpaceSeparated();
1378     appendLigaturesValue(valueList, common, CSSValueCommonLigatures, CSSValueNoCommonLigatures);
1379     appendLigaturesValue(valueList, discretionary, CSSValueDiscretionaryLigatures, CSSValueNoDiscretionaryLigatures);
1380     appendLigaturesValue(valueList, historical, CSSValueHistoricalLigatures, CSSValueNoHistoricalLigatures);
1381     appendLigaturesValue(valueList, contextualAlternates, CSSValueContextual, CSSValueNoContextual);
<span class="line-modified">1382     return WTFMove(valueList);</span>
1383 }
1384 
1385 static Ref&lt;CSSValue&gt; fontVariantPositionPropertyValue(FontVariantPosition position)
1386 {
1387     auto&amp; cssValuePool = CSSValuePool::singleton();
1388     CSSValueID valueID = CSSValueNormal;
1389     switch (position) {
1390     case FontVariantPosition::Normal:
1391         break;
1392     case FontVariantPosition::Subscript:
1393         valueID = CSSValueSub;
1394         break;
1395     case FontVariantPosition::Superscript:
1396         valueID = CSSValueSuper;
1397         break;
1398     }
1399     return cssValuePool.createIdentifierValue(valueID);
1400 }
1401 
1402 static Ref&lt;CSSValue&gt; fontVariantCapsPropertyValue(FontVariantCaps caps)
</pre>
<hr />
<pre>
1456         valueList-&gt;append(cssValuePool.createIdentifierValue(CSSValueTabularNums));
1457         break;
1458     }
1459 
1460     switch (fraction) {
1461     case FontVariantNumericFraction::Normal:
1462         break;
1463     case FontVariantNumericFraction::DiagonalFractions:
1464         valueList-&gt;append(cssValuePool.createIdentifierValue(CSSValueDiagonalFractions));
1465         break;
1466     case FontVariantNumericFraction::StackedFractions:
1467         valueList-&gt;append(cssValuePool.createIdentifierValue(CSSValueStackedFractions));
1468         break;
1469     }
1470 
1471     if (ordinal == FontVariantNumericOrdinal::Yes)
1472         valueList-&gt;append(cssValuePool.createIdentifierValue(CSSValueOrdinal));
1473     if (slashedZero == FontVariantNumericSlashedZero::Yes)
1474         valueList-&gt;append(cssValuePool.createIdentifierValue(CSSValueSlashedZero));
1475 
<span class="line-modified">1476     return WTFMove(valueList);</span>
1477 }
1478 
1479 static Ref&lt;CSSValue&gt; fontVariantAlternatesPropertyValue(FontVariantAlternates alternates)
1480 {
1481     auto&amp; cssValuePool = CSSValuePool::singleton();
1482     CSSValueID valueID = CSSValueNormal;
1483     switch (alternates) {
1484     case FontVariantAlternates::Normal:
1485         break;
1486     case FontVariantAlternates::HistoricalForms:
1487         valueID = CSSValueHistoricalForms;
1488         break;
1489     }
1490     return cssValuePool.createIdentifierValue(valueID);
1491 }
1492 
1493 static Ref&lt;CSSValue&gt; fontVariantEastAsianPropertyValue(FontVariantEastAsianVariant variant, FontVariantEastAsianWidth width, FontVariantEastAsianRuby ruby)
1494 {
1495     auto&amp; cssValuePool = CSSValuePool::singleton();
1496     if (variant == FontVariantEastAsianVariant::Normal &amp;&amp; width == FontVariantEastAsianWidth::Normal &amp;&amp; ruby == FontVariantEastAsianRuby::Normal)
</pre>
<hr />
<pre>
1517         break;
1518     case FontVariantEastAsianVariant::Traditional:
1519         valueList-&gt;append(cssValuePool.createIdentifierValue(CSSValueTraditional));
1520         break;
1521     }
1522 
1523     switch (width) {
1524     case FontVariantEastAsianWidth::Normal:
1525         break;
1526     case FontVariantEastAsianWidth::Full:
1527         valueList-&gt;append(cssValuePool.createIdentifierValue(CSSValueFullWidth));
1528         break;
1529     case FontVariantEastAsianWidth::Proportional:
1530         valueList-&gt;append(cssValuePool.createIdentifierValue(CSSValueProportionalWidth));
1531         break;
1532     }
1533 
1534     if (ruby == FontVariantEastAsianRuby::Yes)
1535         valueList-&gt;append(cssValuePool.createIdentifierValue(CSSValueRuby));
1536 
<span class="line-modified">1537     return WTFMove(valueList);</span>
1538 }
1539 
1540 static Ref&lt;CSSValueList&gt; delayValue(const AnimationList* animationList)
1541 {
1542     auto&amp; cssValuePool = CSSValuePool::singleton();
1543     auto list = CSSValueList::createCommaSeparated();
1544     if (animationList) {
1545         for (size_t i = 0; i &lt; animationList-&gt;size(); ++i)
1546             list-&gt;append(cssValuePool.createValue(animationList-&gt;animation(i).delay(), CSSPrimitiveValue::CSS_S));
1547     } else {
1548         // Note that initialAnimationDelay() is used for both transitions and animations
1549         list-&gt;append(cssValuePool.createValue(Animation::initialDelay(), CSSPrimitiveValue::CSS_S));
1550     }
1551     return list;
1552 }
1553 
1554 static Ref&lt;CSSValueList&gt; durationValue(const AnimationList* animationList)
1555 {
1556     auto&amp; cssValuePool = CSSValuePool::singleton();
1557     auto list = CSSValueList::createCommaSeparated();
</pre>
<hr />
<pre>
1630         return nullptr;
1631     if (is&lt;Element&gt;(*node))
1632         return downcast&lt;Element&gt;(node);
1633     return composedTreeAncestors(*node).first();
1634 }
1635 
1636 ComputedStyleExtractor::ComputedStyleExtractor(Node* node, bool allowVisitedStyle, PseudoId pseudoElementSpecifier)
1637     : m_element(styleElementForNode(node))
1638     , m_pseudoElementSpecifier(pseudoElementSpecifier)
1639     , m_allowVisitedStyle(allowVisitedStyle)
1640 {
1641 }
1642 
1643 ComputedStyleExtractor::ComputedStyleExtractor(Element* element, bool allowVisitedStyle, PseudoId pseudoElementSpecifier)
1644     : m_element(element)
1645     , m_pseudoElementSpecifier(pseudoElementSpecifier)
1646     , m_allowVisitedStyle(allowVisitedStyle)
1647 {
1648 }
1649 
<span class="line-modified">1650 CSSComputedStyleDeclaration::CSSComputedStyleDeclaration(Element&amp; element, bool allowVisitedStyle, const String&amp; pseudoElementName)</span>
1651     : m_element(element)
1652     , m_allowVisitedStyle(allowVisitedStyle)
<span class="line-removed">1653     , m_refCount(1)</span>
1654 {
<span class="line-modified">1655     unsigned nameWithoutColonsStart = pseudoElementName[0] == &#39;:&#39; ? (pseudoElementName[1] == &#39;:&#39; ? 2 : 1) : 0;</span>
<span class="line-modified">1656     m_pseudoElementSpecifier = CSSSelector::pseudoId(CSSSelector::parsePseudoElementType(</span>
<span class="line-modified">1657     (pseudoElementName.substringSharingImpl(nameWithoutColonsStart))));</span>



1658 }
1659 
1660 CSSComputedStyleDeclaration::~CSSComputedStyleDeclaration() = default;
1661 





1662 void CSSComputedStyleDeclaration::ref()
1663 {
1664     ++m_refCount;
1665 }
1666 
1667 void CSSComputedStyleDeclaration::deref()
1668 {
1669     ASSERT(m_refCount);
1670     if (!--m_refCount)
1671         delete this;
1672 }
1673 
1674 String CSSComputedStyleDeclaration::cssText() const
1675 {
1676     StringBuilder result;
<span class="line-removed">1677 </span>
1678     for (unsigned i = 0; i &lt; numComputedProperties; i++) {
1679         if (i)
1680             result.append(&#39; &#39;);
<span class="line-modified">1681         result.append(getPropertyName(computedProperties[i]));</span>
<span class="line-removed">1682         result.appendLiteral(&quot;: &quot;);</span>
<span class="line-removed">1683         result.append(getPropertyValue(computedProperties[i]));</span>
<span class="line-removed">1684         result.append(&#39;;&#39;);</span>
1685     }
<span class="line-removed">1686 </span>
1687     return result.toString();
1688 }
1689 
1690 ExceptionOr&lt;void&gt; CSSComputedStyleDeclaration::setCssText(const String&amp;)
1691 {
1692     return Exception { NoModificationAllowedError };
1693 }
1694 
1695 RefPtr&lt;CSSPrimitiveValue&gt; ComputedStyleExtractor::getFontSizeCSSValuePreferringKeyword()
1696 {
1697     if (!m_element)
1698         return nullptr;
1699 
1700     m_element-&gt;document().updateLayoutIgnorePendingStylesheets();
1701 
1702     auto* style = m_element-&gt;computedStyle(m_pseudoElementSpecifier);
1703     if (!style)
1704         return nullptr;
1705 
1706     if (CSSValueID sizeIdentifier = style-&gt;fontDescription().keywordSizeAsIdentifier())
1707         return CSSValuePool::singleton().createIdentifierValue(sizeIdentifier);
1708 
1709     return zoomAdjustedPixelValue(style-&gt;fontDescription().computedSize(), *style);
1710 }
1711 
1712 bool ComputedStyleExtractor::useFixedFontDefaultSize()
1713 {
1714     if (!m_element)
1715         return false;
1716     auto* style = m_element-&gt;computedStyle(m_pseudoElementSpecifier);
1717     if (!style)
1718         return false;
1719 
1720     return style-&gt;fontDescription().useFixedDefaultSize();
1721 }
1722 
<span class="line-modified">1723 static CSSValueID identifierForFamily(const AtomicString&amp; family)</span>
1724 {
1725     if (family == cursiveFamily)
1726         return CSSValueCursive;
1727     if (family == fantasyFamily)
1728         return CSSValueFantasy;
1729     if (family == monospaceFamily)
1730         return CSSValueMonospace;
1731     if (family == pictographFamily)
1732         return CSSValueWebkitPictograph;
1733     if (family == sansSerifFamily)
1734         return CSSValueSansSerif;
1735     if (family == serifFamily)
1736         return CSSValueSerif;
1737     if (family == systemUiFamily)
1738         return CSSValueSystemUi;
1739     return CSSValueInvalid;
1740 }
1741 
<span class="line-modified">1742 static Ref&lt;CSSPrimitiveValue&gt; valueForFamily(const AtomicString&amp; family)</span>
1743 {
1744     if (CSSValueID familyIdentifier = identifierForFamily(family))
1745         return CSSValuePool::singleton().createIdentifierValue(familyIdentifier);
1746     return CSSValuePool::singleton().createFontFamilyValue(family);
1747 }
1748 
1749 #if ENABLE(POINTER_EVENTS)
1750 static Ref&lt;CSSValue&gt; touchActionFlagsToCSSValue(OptionSet&lt;TouchAction&gt; touchActions)
1751 {
1752     auto&amp; cssValuePool = CSSValuePool::singleton();
1753 
1754     if (touchActions &amp; TouchAction::Auto)
1755         return cssValuePool.createIdentifierValue(CSSValueAuto);
1756     if (touchActions &amp; TouchAction::None)
1757         return cssValuePool.createIdentifierValue(CSSValueNone);
1758     if (touchActions &amp; TouchAction::Manipulation)
1759         return cssValuePool.createIdentifierValue(CSSValueManipulation);
1760 
1761     auto list = CSSValueList::createSpaceSeparated();
1762     if (touchActions &amp; TouchAction::PanX)
1763         list-&gt;append(cssValuePool.createIdentifierValue(CSSValuePanX));
1764     if (touchActions &amp; TouchAction::PanY)
1765         list-&gt;append(cssValuePool.createIdentifierValue(CSSValuePanY));
1766     if (touchActions &amp; TouchAction::PinchZoom)
1767         list-&gt;append(cssValuePool.createIdentifierValue(CSSValuePinchZoom));
1768 
1769     if (!list-&gt;length())
1770         return cssValuePool.createIdentifierValue(CSSValueAuto);
<span class="line-modified">1771     return WTFMove(list);</span>
1772 }
1773 #endif
1774 
1775 static Ref&lt;CSSValue&gt; renderTextDecorationFlagsToCSSValue(OptionSet&lt;TextDecoration&gt; textDecoration)
1776 {
1777     auto&amp; cssValuePool = CSSValuePool::singleton();
1778     // Blink value is ignored.
1779     auto list = CSSValueList::createSpaceSeparated();
1780     if (textDecoration &amp; TextDecoration::Underline)
1781         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueUnderline));
1782     if (textDecoration &amp; TextDecoration::Overline)
1783         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueOverline));
1784     if (textDecoration &amp; TextDecoration::LineThrough)
1785         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueLineThrough));
1786 #if ENABLE(LETTERPRESS)
1787     if (textDecoration &amp; TextDecoration::Letterpress)
1788         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueWebkitLetterpress));
1789 #endif
1790 
1791     if (!list-&gt;length())
1792         return cssValuePool.createIdentifierValue(CSSValueNone);
<span class="line-modified">1793     return WTFMove(list);</span>
1794 }
1795 
1796 static Ref&lt;CSSValue&gt; renderTextDecorationStyleFlagsToCSSValue(TextDecorationStyle textDecorationStyle)
1797 {
1798     switch (textDecorationStyle) {
1799     case TextDecorationStyle::Solid:
1800         return CSSValuePool::singleton().createIdentifierValue(CSSValueSolid);
1801     case TextDecorationStyle::Double:
1802         return CSSValuePool::singleton().createIdentifierValue(CSSValueDouble);
1803     case TextDecorationStyle::Dotted:
1804         return CSSValuePool::singleton().createIdentifierValue(CSSValueDotted);
1805     case TextDecorationStyle::Dashed:
1806         return CSSValuePool::singleton().createIdentifierValue(CSSValueDashed);
1807     case TextDecorationStyle::Wavy:
1808         return CSSValuePool::singleton().createIdentifierValue(CSSValueWavy);
1809     }
1810 
1811     ASSERT_NOT_REACHED();
1812     return CSSValuePool::singleton().createExplicitInitialValue();
1813 }
</pre>
<hr />
<pre>
1847     ASSERT(textDecorationThickness.isLength());
1848     return CSSValuePool::singleton().createValue(textDecorationThickness.lengthValue(), CSSPrimitiveValue::CSS_PX);
1849 }
1850 
1851 static Ref&lt;CSSValue&gt; renderEmphasisPositionFlagsToCSSValue(OptionSet&lt;TextEmphasisPosition&gt; textEmphasisPosition)
1852 {
1853     ASSERT(!((textEmphasisPosition &amp; TextEmphasisPosition::Over) &amp;&amp; (textEmphasisPosition &amp; TextEmphasisPosition::Under)));
1854     ASSERT(!((textEmphasisPosition &amp; TextEmphasisPosition::Left) &amp;&amp; (textEmphasisPosition &amp; TextEmphasisPosition::Right)));
1855     auto&amp; cssValuePool = CSSValuePool::singleton();
1856     auto list = CSSValueList::createSpaceSeparated();
1857     if (textEmphasisPosition &amp; TextEmphasisPosition::Over)
1858         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueOver));
1859     if (textEmphasisPosition &amp; TextEmphasisPosition::Under)
1860         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueUnder));
1861     if (textEmphasisPosition &amp; TextEmphasisPosition::Left)
1862         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueLeft));
1863     if (textEmphasisPosition &amp; TextEmphasisPosition::Right)
1864         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueRight));
1865     if (!list-&gt;length())
1866         return cssValuePool.createIdentifierValue(CSSValueNone);
<span class="line-modified">1867     return WTFMove(list);</span>
1868 }
1869 
1870 static Ref&lt;CSSValue&gt; speakAsToCSSValue(OptionSet&lt;SpeakAs&gt; speakAs)
1871 {
1872     auto&amp; cssValuePool = CSSValuePool::singleton();
1873     auto list = CSSValueList::createSpaceSeparated();
1874     if (speakAs &amp; SpeakAs::SpellOut)
1875         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueSpellOut));
1876     if (speakAs &amp; SpeakAs::Digits)
1877         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueDigits));
1878     if (speakAs &amp; SpeakAs::LiteralPunctuation)
1879         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueLiteralPunctuation));
1880     if (speakAs &amp; SpeakAs::NoPunctuation)
1881         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueNoPunctuation));
1882     if (!list-&gt;length())
1883         return cssValuePool.createIdentifierValue(CSSValueNormal);
<span class="line-modified">1884     return WTFMove(list);</span>
1885 }
1886 
1887 static Ref&lt;CSSValue&gt; hangingPunctuationToCSSValue(OptionSet&lt;HangingPunctuation&gt; hangingPunctuation)
1888 {
1889     auto&amp; cssValuePool = CSSValuePool::singleton();
1890     auto list = CSSValueList::createSpaceSeparated();
1891     if (hangingPunctuation &amp; HangingPunctuation::First)
1892         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueFirst));
1893     if (hangingPunctuation &amp; HangingPunctuation::AllowEnd)
1894         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueAllowEnd));
1895     if (hangingPunctuation &amp; HangingPunctuation::ForceEnd)
1896         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueForceEnd));
1897     if (hangingPunctuation &amp; HangingPunctuation::Last)
1898         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueLast));
1899     if (!list-&gt;length())
1900         return cssValuePool.createIdentifierValue(CSSValueNone);
<span class="line-modified">1901     return WTFMove(list);</span>
1902 }
1903 
1904 static Ref&lt;CSSValue&gt; fillRepeatToCSSValue(FillRepeat xRepeat, FillRepeat yRepeat)
1905 {
1906     // For backwards compatibility, if both values are equal, just return one of them. And
1907     // if the two values are equivalent to repeat-x or repeat-y, just return the shorthand.
1908     auto&amp; cssValuePool = CSSValuePool::singleton();
1909     if (xRepeat == yRepeat)
1910         return cssValuePool.createValue(xRepeat);
1911     if (xRepeat == FillRepeat::Repeat &amp;&amp; yRepeat == FillRepeat::NoRepeat)
1912         return cssValuePool.createIdentifierValue(CSSValueRepeatX);
1913     if (xRepeat == FillRepeat::NoRepeat &amp;&amp; yRepeat == FillRepeat::Repeat)
1914         return cssValuePool.createIdentifierValue(CSSValueRepeatY);
1915 
1916     auto list = CSSValueList::createSpaceSeparated();
1917     list-&gt;append(cssValuePool.createValue(xRepeat));
1918     list-&gt;append(cssValuePool.createValue(yRepeat));
<span class="line-modified">1919     return WTFMove(list);</span>
1920 }
1921 
1922 static Ref&lt;CSSValue&gt; fillSourceTypeToCSSValue(MaskSourceType type)
1923 {
1924     switch (type) {
1925     case MaskSourceType::Alpha:
1926         return CSSValuePool::singleton().createValue(CSSValueAlpha);
1927     default:
1928         ASSERT(type == MaskSourceType::Luminance);
1929         return CSSValuePool::singleton().createValue(CSSValueLuminance);
1930     }
1931 }
1932 
1933 static Ref&lt;CSSValue&gt; fillSizeToCSSValue(const FillSize&amp; fillSize, const RenderStyle&amp; style)
1934 {
1935     if (fillSize.type == FillSizeType::Contain)
1936         return CSSValuePool::singleton().createIdentifierValue(CSSValueContain);
1937 
1938     if (fillSize.type == FillSizeType::Cover)
1939         return CSSValuePool::singleton().createIdentifierValue(CSSValueCover);
1940 
1941     if (fillSize.size.height.isAuto())
1942         return zoomAdjustedPixelValueForLength(fillSize.size.width, style);
1943 
1944     auto list = CSSValueList::createSpaceSeparated();
1945     list-&gt;append(zoomAdjustedPixelValueForLength(fillSize.size.width, style));
1946     list-&gt;append(zoomAdjustedPixelValueForLength(fillSize.size.height, style));
<span class="line-modified">1947     return WTFMove(list);</span>
1948 }
1949 
1950 static Ref&lt;CSSValue&gt; altTextToCSSValue(const RenderStyle&amp; style)
1951 {
1952     return CSSValuePool::singleton().createValue(style.contentAltText(), CSSPrimitiveValue::CSS_STRING);
1953 }
1954 
1955 static Ref&lt;CSSValueList&gt; contentToCSSValue(const RenderStyle&amp; style)
1956 {
1957     auto&amp; cssValuePool = CSSValuePool::singleton();
1958     auto list = CSSValueList::createSpaceSeparated();
1959     for (auto* contentData = style.contentData(); contentData; contentData = contentData-&gt;next()) {
1960         if (is&lt;CounterContentData&gt;(*contentData))
1961             list-&gt;append(cssValuePool.createValue(downcast&lt;CounterContentData&gt;(*contentData).counter().identifier(), CSSPrimitiveValue::CSS_COUNTER_NAME));
1962         else if (is&lt;ImageContentData&gt;(*contentData))
1963             list-&gt;append(downcast&lt;ImageContentData&gt;(*contentData).image().cssValue());
1964         else if (is&lt;TextContentData&gt;(*contentData))
1965             list-&gt;append(cssValuePool.createValue(downcast&lt;TextContentData&gt;(*contentData).text(), CSSPrimitiveValue::CSS_STRING));
1966     }
1967     return list;
1968 }
1969 
1970 static Ref&lt;CSSValue&gt; counterToCSSValue(const RenderStyle&amp; style, CSSPropertyID propertyID)
1971 {
1972     auto* map = style.counterDirectives();
1973     if (!map)
1974         return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
1975 
1976     auto&amp; cssValuePool = CSSValuePool::singleton();
1977     auto list = CSSValueList::createSpaceSeparated();
1978     for (auto&amp; keyValue : *map) {
1979         list-&gt;append(cssValuePool.createValue(keyValue.key, CSSPrimitiveValue::CSS_STRING));
1980         double number = (propertyID == CSSPropertyCounterIncrement ? keyValue.value.incrementValue : keyValue.value.resetValue).valueOr(0);
1981         list-&gt;append(cssValuePool.createValue(number, CSSPrimitiveValue::CSS_NUMBER));
1982     }
<span class="line-modified">1983     return WTFMove(list);</span>
1984 }
1985 
1986 static void logUnimplementedPropertyID(CSSPropertyID propertyID)
1987 {
1988     static NeverDestroyed&lt;HashSet&lt;CSSPropertyID&gt;&gt; propertyIDSet;
1989     if (!propertyIDSet.get().add(propertyID).isNewEntry)
1990         return;
1991 
1992     LOG_ERROR(&quot;WebKit does not yet implement getComputedStyle for &#39;%s&#39;.&quot;, getPropertyName(propertyID));
1993 }
1994 
1995 static Ref&lt;CSSValueList&gt; fontFamilyListFromStyle(const RenderStyle&amp; style)
1996 {
1997     auto list = CSSValueList::createCommaSeparated();
1998     for (unsigned i = 0; i &lt; style.fontCascade().familyCount(); ++i)
1999         list-&gt;append(valueForFamily(style.fontCascade().familyAt(i)));
2000     return list;
2001 }
2002 
2003 static Ref&lt;CSSValue&gt; fontFamilyFromStyle(const RenderStyle&amp; style)
</pre>
<hr />
<pre>
2245 
2246     switch (style.fontDescription().variantEastAsianWidth()) {
2247     case FontVariantEastAsianWidth::Normal:
2248         break;
2249     case FontVariantEastAsianWidth::Full:
2250         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueFullWidth));
2251         break;
2252     case FontVariantEastAsianWidth::Proportional:
2253         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueProportionalWidth));
2254         break;
2255     }
2256 
2257     switch (style.fontDescription().variantEastAsianRuby()) {
2258     case FontVariantEastAsianRuby::Normal:
2259         break;
2260     case FontVariantEastAsianRuby::Yes:
2261         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueRuby));
2262         break;
2263     }
2264 
<span class="line-modified">2265     return WTFMove(list);</span>
2266 }
2267 
2268 static Ref&lt;CSSValue&gt; fontSynthesisFromStyle(const RenderStyle&amp; style)
2269 {
2270     if (style.fontDescription().fontSynthesis() == FontSynthesisNone)
2271         return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
2272 
2273     auto list = CSSValueList::createSpaceSeparated();
2274     if (style.fontDescription().fontSynthesis() &amp; FontSynthesisStyle)
2275         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueStyle));
2276     if (style.fontDescription().fontSynthesis() &amp; FontSynthesisWeight)
2277         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueWeight));
2278     if (style.fontDescription().fontSynthesis() &amp; FontSynthesisSmallCaps)
2279         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueSmallCaps));
<span class="line-modified">2280     return WTFMove(list);</span>
2281 }
2282 
2283 typedef const Length&amp; (RenderStyle::*RenderStyleLengthGetter)() const;
2284 typedef LayoutUnit (RenderBoxModelObject::*RenderBoxComputedCSSValueGetter)() const;
2285 
2286 template&lt;RenderStyleLengthGetter lengthGetter, RenderBoxComputedCSSValueGetter computedCSSValueGetter&gt;
2287 static RefPtr&lt;CSSValue&gt; zoomAdjustedPaddingOrMarginPixelValue(const RenderStyle&amp; style, RenderObject* renderer)
2288 {
2289     Length unzoomzedLength = (style.*lengthGetter)();
2290     if (!is&lt;RenderBox&gt;(renderer) || unzoomzedLength.isFixed())
2291         return zoomAdjustedPixelValueForLength(unzoomzedLength, style);
2292     return zoomAdjustedPixelValue((downcast&lt;RenderBox&gt;(*renderer).*computedCSSValueGetter)(), style);
2293 }
2294 
2295 template&lt;RenderStyleLengthGetter lengthGetter&gt;
2296 static bool paddingOrMarginIsRendererDependent(const RenderStyle* style, RenderObject* renderer)
2297 {
2298     return renderer &amp;&amp; style &amp;&amp; renderer-&gt;isBox() &amp;&amp; !(style-&gt;*lengthGetter)().isFixed();
2299 }
2300 
</pre>
<hr />
<pre>
2529 static Ref&lt;CSSValue&gt; shapePropertyValue(const RenderStyle&amp; style, const ShapeValue* shapeValue)
2530 {
2531     if (!shapeValue)
2532         return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
2533 
2534     if (shapeValue-&gt;type() == ShapeValue::Type::Box)
2535         return CSSValuePool::singleton().createValue(shapeValue-&gt;cssBox());
2536 
2537     if (shapeValue-&gt;type() == ShapeValue::Type::Image) {
2538         if (shapeValue-&gt;image())
2539             return shapeValue-&gt;image()-&gt;cssValue();
2540         return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
2541     }
2542 
2543     ASSERT(shapeValue-&gt;type() == ShapeValue::Type::Shape);
2544 
2545     auto list = CSSValueList::createSpaceSeparated();
2546     list-&gt;append(valueForBasicShape(style, *shapeValue-&gt;shape()));
2547     if (shapeValue-&gt;cssBox() != CSSBoxType::BoxMissing)
2548         list-&gt;append(CSSValuePool::singleton().createValue(shapeValue-&gt;cssBox()));
<span class="line-modified">2549     return WTFMove(list);</span>
2550 }
2551 
2552 static Ref&lt;CSSValueList&gt; valueForItemPositionWithOverflowAlignment(const StyleSelfAlignmentData&amp; data)
2553 {
2554     auto&amp; cssValuePool = CSSValuePool::singleton();
2555     auto result = CSSValueList::createSpaceSeparated();
2556     if (data.positionType() == ItemPositionType::Legacy)
2557         result-&gt;append(cssValuePool.createIdentifierValue(CSSValueLegacy));
2558     if (data.position() == ItemPosition::Baseline)
2559         result-&gt;append(cssValuePool.createIdentifierValue(CSSValueBaseline));
2560     else if (data.position() == ItemPosition::LastBaseline) {
2561         result-&gt;append(cssValuePool.createIdentifierValue(CSSValueLast));
2562         result-&gt;append(cssValuePool.createIdentifierValue(CSSValueBaseline));
2563     } else {
2564         if (data.position() &gt;= ItemPosition::Center &amp;&amp; data.overflow() != OverflowAlignment::Default)
2565             result-&gt;append(cssValuePool.createValue(data.overflow()));
2566         if (data.position() == ItemPosition::Legacy)
2567             result-&gt;append(cssValuePool.createIdentifierValue(CSSValueNormal));
2568         else
2569             result-&gt;append(cssValuePool.createValue(data.position()));
</pre>
<hr />
<pre>
2618         break;
2619     case PaintOrder::FillMarkers:
2620         paintOrderList-&gt;append(CSSPrimitiveValue::createIdentifier(CSSValueFill));
2621         paintOrderList-&gt;append(CSSPrimitiveValue::createIdentifier(CSSValueMarkers));
2622         break;
2623     case PaintOrder::Stroke:
2624         paintOrderList-&gt;append(CSSPrimitiveValue::createIdentifier(CSSValueStroke));
2625         break;
2626     case PaintOrder::StrokeMarkers:
2627         paintOrderList-&gt;append(CSSPrimitiveValue::createIdentifier(CSSValueStroke));
2628         paintOrderList-&gt;append(CSSPrimitiveValue::createIdentifier(CSSValueMarkers));
2629         break;
2630     case PaintOrder::Markers:
2631         paintOrderList-&gt;append(CSSPrimitiveValue::createIdentifier(CSSValueMarkers));
2632         break;
2633     case PaintOrder::MarkersStroke:
2634         paintOrderList-&gt;append(CSSPrimitiveValue::createIdentifier(CSSValueMarkers));
2635         paintOrderList-&gt;append(CSSPrimitiveValue::createIdentifier(CSSValueStroke));
2636         break;
2637     }
<span class="line-modified">2638     return WTFMove(paintOrderList);</span>
2639 }
2640 
2641 inline static bool isFlexOrGrid(ContainerNode* element)
2642 {
2643     return element &amp;&amp; element-&gt;computedStyle() &amp;&amp; element-&gt;computedStyle()-&gt;isDisplayFlexibleOrGridBox();
2644 }
2645 
2646 RefPtr&lt;CSSValue&gt; ComputedStyleExtractor::customPropertyValue(const String&amp; propertyName)
2647 {
2648     Element* styledElement = this-&gt;styledElement();
2649     if (!styledElement)
2650         return nullptr;
2651 
2652     if (updateStyleIfNeededForProperty(*styledElement, CSSPropertyCustom)) {
2653         // Style update may change styledElement() to PseudoElement or back.
2654         styledElement = this-&gt;styledElement();
2655     }
2656 
2657     std::unique_ptr&lt;RenderStyle&gt; ownedStyle;
2658     auto* style = computeRenderStyleForProperty(*styledElement, m_pseudoElementSpecifier, CSSPropertyCustom, ownedStyle);
</pre>
<hr />
<pre>
2747 
2748         // FIXME: Some of these cases could be narrowed down or optimized better.
2749         forceFullLayout = isLayoutDependent(propertyID, style, renderer)
2750             || styledElement-&gt;isInShadowTree()
2751             || (document.styleScope().resolverIfExists() &amp;&amp; document.styleScope().resolverIfExists()-&gt;hasViewportDependentMediaQueries() &amp;&amp; document.ownerElement());
2752 
2753         if (forceFullLayout) {
2754             document.updateLayoutIgnorePendingStylesheets();
2755             styledElement = this-&gt;styledElement();
2756         }
2757     }
2758 
2759     if (!updateLayout || forceFullLayout) {
2760         style = computeRenderStyleForProperty(*styledElement, m_pseudoElementSpecifier, propertyID, ownedStyle);
2761         renderer = styledRenderer();
2762     }
2763 
2764     if (!style)
2765         return nullptr;
2766 
<span class="line-modified">2767     return valueForPropertyinStyle(*style, propertyID, renderer);</span>
2768 }
2769 
<span class="line-modified">2770 RefPtr&lt;CSSValue&gt; ComputedStyleExtractor::valueForPropertyinStyle(const RenderStyle&amp; style, CSSPropertyID propertyID, RenderElement* renderer)</span>
2771 {
2772     auto&amp; cssValuePool = CSSValuePool::singleton();
2773     propertyID = CSSProperty::resolveDirectionAwareProperty(propertyID, style.direction(), style.writingMode());
2774 
2775     switch (propertyID) {
2776         case CSSPropertyInvalid:



2777             break;
2778 
2779         case CSSPropertyBackgroundColor:
2780             return cssValuePool.createColorValue(m_allowVisitedStyle? style.visitedDependentColor(CSSPropertyBackgroundColor) : style.backgroundColor());
2781         case CSSPropertyBackgroundImage:
2782         case CSSPropertyWebkitMaskImage: {
2783             auto&amp; layers = propertyID == CSSPropertyWebkitMaskImage ? style.maskLayers() : style.backgroundLayers();
2784             if (!layers.next()) {
2785                 if (layers.image())
2786                     return layers.image()-&gt;cssValue();
2787                 return cssValuePool.createIdentifierValue(CSSValueNone);
2788             }
2789             auto list = CSSValueList::createCommaSeparated();
2790             for (auto* currLayer = &amp;layers; currLayer; currLayer = currLayer-&gt;next()) {
2791                 if (currLayer-&gt;image())
2792                     list-&gt;append(currLayer-&gt;image()-&gt;cssValue());
2793                 else
2794                     list-&gt;append(cssValuePool.createIdentifierValue(CSSValueNone));
2795             }
<span class="line-modified">2796             return WTFMove(list);</span>
2797         }
2798         case CSSPropertyBackgroundSize:
2799         case CSSPropertyWebkitBackgroundSize:
2800         case CSSPropertyWebkitMaskSize: {
2801             auto&amp; layers = propertyID == CSSPropertyWebkitMaskSize ? style.maskLayers() : style.backgroundLayers();
2802             if (!layers.next())
2803                 return fillSizeToCSSValue(layers.size(), style);
2804             auto list = CSSValueList::createCommaSeparated();
2805             for (auto* currLayer = &amp;layers; currLayer; currLayer = currLayer-&gt;next())
2806                 list-&gt;append(fillSizeToCSSValue(currLayer-&gt;size(), style));
<span class="line-modified">2807             return WTFMove(list);</span>
2808         }
2809         case CSSPropertyBackgroundRepeat:
2810         case CSSPropertyWebkitMaskRepeat: {
2811             auto&amp; layers = propertyID == CSSPropertyWebkitMaskRepeat ? style.maskLayers() : style.backgroundLayers();
2812             if (!layers.next())
2813                 return fillRepeatToCSSValue(layers.repeatX(), layers.repeatY());
2814             auto list = CSSValueList::createCommaSeparated();
2815             for (auto* currLayer = &amp;layers; currLayer; currLayer = currLayer-&gt;next())
2816                 list-&gt;append(fillRepeatToCSSValue(currLayer-&gt;repeatX(), currLayer-&gt;repeatY()));
<span class="line-modified">2817             return WTFMove(list);</span>
2818         }
2819         case CSSPropertyWebkitMaskSourceType: {
2820             auto&amp; layers = style.maskLayers();
2821             if (!layers.next())
2822                 return fillSourceTypeToCSSValue(layers.maskSourceType());
2823             auto list = CSSValueList::createCommaSeparated();
2824             for (auto* currLayer = &amp;layers; currLayer; currLayer = currLayer-&gt;next())
2825                 list-&gt;append(fillSourceTypeToCSSValue(currLayer-&gt;maskSourceType()));
<span class="line-modified">2826             return WTFMove(list);</span>
2827         }
2828         case CSSPropertyWebkitBackgroundComposite:
2829         case CSSPropertyWebkitMaskComposite: {
2830             auto&amp; layers = propertyID == CSSPropertyWebkitMaskComposite ? style.maskLayers() : style.backgroundLayers();
2831             if (!layers.next())
2832                 return cssValuePool.createValue(layers.composite());
2833             auto list = CSSValueList::createCommaSeparated();
2834             for (auto* currLayer = &amp;layers; currLayer; currLayer = currLayer-&gt;next())
2835                 list-&gt;append(cssValuePool.createValue(currLayer-&gt;composite()));
<span class="line-modified">2836             return WTFMove(list);</span>
2837         }
2838         case CSSPropertyBackgroundAttachment: {
2839             auto&amp; layers = style.backgroundLayers();
2840             if (!layers.next())
2841                 return cssValuePool.createValue(layers.attachment());
2842             auto list = CSSValueList::createCommaSeparated();
2843             for (auto* currLayer = &amp;layers; currLayer; currLayer = currLayer-&gt;next())
2844                 list-&gt;append(cssValuePool.createValue(currLayer-&gt;attachment()));
<span class="line-modified">2845             return WTFMove(list);</span>
2846         }
2847         case CSSPropertyBackgroundClip:
2848         case CSSPropertyBackgroundOrigin:
2849         case CSSPropertyWebkitBackgroundClip:
2850         case CSSPropertyWebkitBackgroundOrigin:
2851         case CSSPropertyWebkitMaskClip:
2852         case CSSPropertyWebkitMaskOrigin: {
2853             auto&amp; layers = (propertyID == CSSPropertyWebkitMaskClip || propertyID == CSSPropertyWebkitMaskOrigin) ? style.maskLayers() : style.backgroundLayers();
2854             bool isClip = propertyID == CSSPropertyBackgroundClip || propertyID == CSSPropertyWebkitBackgroundClip || propertyID == CSSPropertyWebkitMaskClip;
2855             if (!layers.next())
2856                 return cssValuePool.createValue(isClip ? layers.clip() : layers.origin());
2857             auto list = CSSValueList::createCommaSeparated();
2858             for (auto* currLayer = &amp;layers; currLayer; currLayer = currLayer-&gt;next())
2859                 list-&gt;append(cssValuePool.createValue(isClip ? currLayer-&gt;clip() : currLayer-&gt;origin()));
<span class="line-modified">2860             return WTFMove(list);</span>
2861         }
2862         case CSSPropertyBackgroundPosition:
2863         case CSSPropertyWebkitMaskPosition: {
2864             auto&amp; layers = propertyID == CSSPropertyWebkitMaskPosition ? style.maskLayers() : style.backgroundLayers();
2865             if (!layers.next())
2866                 return createPositionListForLayer(propertyID, layers, style);
2867 
2868             auto list = CSSValueList::createCommaSeparated();
2869             for (auto* currLayer = &amp;layers; currLayer; currLayer = currLayer-&gt;next())
2870                 list-&gt;append(createPositionListForLayer(propertyID, *currLayer, style));
<span class="line-modified">2871             return WTFMove(list);</span>
2872         }
2873         case CSSPropertyBackgroundPositionX:
2874         case CSSPropertyWebkitMaskPositionX: {
2875             auto&amp; layers = propertyID == CSSPropertyWebkitMaskPositionX ? style.maskLayers() : style.backgroundLayers();
2876             if (!layers.next())
2877                 return cssValuePool.createValue(layers.xPosition());
2878 
2879             auto list = CSSValueList::createCommaSeparated();
2880             for (auto* currLayer = &amp;layers; currLayer; currLayer = currLayer-&gt;next())
2881                 list-&gt;append(cssValuePool.createValue(currLayer-&gt;xPosition()));
2882 
<span class="line-modified">2883             return WTFMove(list);</span>
2884         }
2885         case CSSPropertyBackgroundPositionY:
2886         case CSSPropertyWebkitMaskPositionY: {
2887             auto&amp; layers = propertyID == CSSPropertyWebkitMaskPositionY ? style.maskLayers() : style.backgroundLayers();
2888             if (!layers.next())
2889                 return cssValuePool.createValue(layers.yPosition());
2890 
2891             auto list = CSSValueList::createCommaSeparated();
2892             for (auto* currLayer = &amp;layers; currLayer; currLayer = currLayer-&gt;next())
2893                 list-&gt;append(cssValuePool.createValue(currLayer-&gt;yPosition()));
2894 
<span class="line-modified">2895             return WTFMove(list);</span>
2896         }
2897         case CSSPropertyBorderCollapse:
2898             if (style.borderCollapse() == BorderCollapse::Collapse)
2899                 return cssValuePool.createIdentifierValue(CSSValueCollapse);
2900             return cssValuePool.createIdentifierValue(CSSValueSeparate);
2901         case CSSPropertyBorderSpacing: {
2902             auto list = CSSValueList::createSpaceSeparated();
2903             list-&gt;append(zoomAdjustedPixelValue(style.horizontalBorderSpacing(), style));
2904             list-&gt;append(zoomAdjustedPixelValue(style.verticalBorderSpacing(), style));
<span class="line-modified">2905             return WTFMove(list);</span>
2906         }
2907         case CSSPropertyWebkitBorderHorizontalSpacing:
2908             return zoomAdjustedPixelValue(style.horizontalBorderSpacing(), style);
2909         case CSSPropertyWebkitBorderVerticalSpacing:
2910             return zoomAdjustedPixelValue(style.verticalBorderSpacing(), style);
2911         case CSSPropertyBorderImageSource:
2912             if (style.borderImageSource())
2913                 return style.borderImageSource()-&gt;cssValue();
2914             return cssValuePool.createIdentifierValue(CSSValueNone);
2915         case CSSPropertyBorderTopColor:
2916             return m_allowVisitedStyle ? cssValuePool.createColorValue(style.visitedDependentColor(CSSPropertyBorderTopColor)) : currentColorOrValidColor(&amp;style, style.borderTopColor());
2917         case CSSPropertyBorderRightColor:
2918             return m_allowVisitedStyle ? cssValuePool.createColorValue(style.visitedDependentColor(CSSPropertyBorderRightColor)) : currentColorOrValidColor(&amp;style, style.borderRightColor());
2919         case CSSPropertyBorderBottomColor:
2920             return m_allowVisitedStyle ? cssValuePool.createColorValue(style.visitedDependentColor(CSSPropertyBorderBottomColor)) : currentColorOrValidColor(&amp;style, style.borderBottomColor());
2921         case CSSPropertyBorderLeftColor:
2922             return m_allowVisitedStyle ? cssValuePool.createColorValue(style.visitedDependentColor(CSSPropertyBorderLeftColor)) : currentColorOrValidColor(&amp;style, style.borderLeftColor());
2923         case CSSPropertyBorderTopStyle:
2924             return cssValuePool.createValue(style.borderTopStyle());
2925         case CSSPropertyBorderRightStyle:
</pre>
<hr />
<pre>
2995             return cssValuePool.createValue(style.columnProgression());
2996         case CSSPropertyColumnRuleColor:
2997             return m_allowVisitedStyle ? cssValuePool.createColorValue(style.visitedDependentColor(CSSPropertyOutlineColor)) : currentColorOrValidColor(&amp;style, style.columnRuleColor());
2998         case CSSPropertyColumnRuleStyle:
2999             return cssValuePool.createValue(style.columnRuleStyle());
3000         case CSSPropertyColumnRuleWidth:
3001             return zoomAdjustedPixelValue(style.columnRuleWidth(), style);
3002         case CSSPropertyColumnSpan:
3003             return cssValuePool.createIdentifierValue(style.columnSpan() == ColumnSpan::All ? CSSValueAll : CSSValueNone);
3004         case CSSPropertyWebkitColumnBreakAfter:
3005             return cssValuePool.createValue(convertToColumnBreak(style.breakAfter()));
3006         case CSSPropertyWebkitColumnBreakBefore:
3007             return cssValuePool.createValue(convertToColumnBreak(style.breakBefore()));
3008         case CSSPropertyWebkitColumnBreakInside:
3009             return cssValuePool.createValue(convertToColumnBreak(style.breakInside()));
3010         case CSSPropertyColumnWidth:
3011             if (style.hasAutoColumnWidth())
3012                 return cssValuePool.createIdentifierValue(CSSValueAuto);
3013             return zoomAdjustedPixelValue(style.columnWidth(), style);
3014         case CSSPropertyTabSize:
<span class="line-modified">3015             return cssValuePool.createValue(style.tabSize(), CSSPrimitiveValue::CSS_NUMBER);</span>
3016         case CSSPropertyCursor: {
3017             RefPtr&lt;CSSValueList&gt; list;
3018             auto* cursors = style.cursors();
3019             if (cursors &amp;&amp; cursors-&gt;size() &gt; 0) {
3020                 list = CSSValueList::createCommaSeparated();
3021                 for (unsigned i = 0; i &lt; cursors-&gt;size(); ++i)
3022                     if (StyleImage* image = cursors-&gt;at(i).image())
3023                         list-&gt;append(image-&gt;cssValue());
3024             }
3025             auto value = cssValuePool.createValue(style.cursor());
3026             if (list) {
3027                 list-&gt;append(WTFMove(value));
3028                 return list;
3029             }
<span class="line-modified">3030             return WTFMove(value);</span>
3031         }
3032 #if ENABLE(CURSOR_VISIBILITY)
3033         case CSSPropertyWebkitCursorVisibility:
3034             return cssValuePool.createValue(style.cursorVisibility());
3035 #endif
3036         case CSSPropertyDirection:
3037             return cssValuePool.createValue(style.direction());
3038         case CSSPropertyDisplay:
3039             return cssValuePool.createValue(style.display());
3040         case CSSPropertyEmptyCells:
3041             return cssValuePool.createValue(style.emptyCells());
3042         case CSSPropertyAlignContent:
3043             return valueForContentPositionAndDistributionWithOverflowAlignment(style.alignContent());
3044         case CSSPropertyAlignItems:
3045             return valueForItemPositionWithOverflowAlignment(style.alignItems());
3046         case CSSPropertyAlignSelf:
3047             return valueForItemPositionWithOverflowAlignment(style.alignSelf());
3048         case CSSPropertyFlex:
3049             return getCSSPropertyValuesForShorthandProperties(flexShorthand());
3050         case CSSPropertyFlexBasis:
</pre>
<hr />
<pre>
3065             return valueForItemPositionWithOverflowAlignment(style.justifyItems());
3066         case CSSPropertyJustifySelf:
3067             return valueForItemPositionWithOverflowAlignment(style.justifySelf());
3068         case CSSPropertyPlaceContent:
3069             return getCSSPropertyValuesForShorthandProperties(placeContentShorthand());
3070         case CSSPropertyPlaceItems:
3071             return getCSSPropertyValuesForShorthandProperties(placeItemsShorthand());
3072         case CSSPropertyPlaceSelf:
3073             return getCSSPropertyValuesForShorthandProperties(placeSelfShorthand());
3074         case CSSPropertyOrder:
3075             return cssValuePool.createValue(style.order(), CSSPrimitiveValue::CSS_NUMBER);
3076         case CSSPropertyFloat:
3077             if (style.display() != DisplayType::None &amp;&amp; style.hasOutOfFlowPosition())
3078                 return cssValuePool.createIdentifierValue(CSSValueNone);
3079             return cssValuePool.createValue(style.floating());
3080         case CSSPropertyFont: {
3081             auto computedFont = fontShorthandValueForSelectionProperties(style.fontDescription());
3082             computedFont-&gt;size = fontSizeFromStyle(style);
3083             computedFont-&gt;lineHeight = lineHeightFromStyle(style);
3084             computedFont-&gt;family = fontFamilyListFromStyle(style);
<span class="line-modified">3085             return WTFMove(computedFont);</span>
3086         }
3087         case CSSPropertyFontFamily:
3088             return fontFamilyFromStyle(style);
3089         case CSSPropertyFontSize:
3090             return fontSizeFromStyle(style);
3091         case CSSPropertyFontStyle:
3092             return fontStyleFromStyle(style);
3093         case CSSPropertyFontStretch:
3094             return fontStretchFromStyle(style);
3095         case CSSPropertyFontVariant:
3096             return fontVariantFromStyle(style);
3097         case CSSPropertyFontWeight:
3098             return fontWeightFromStyle(style);
3099         case CSSPropertyFontSynthesis:
3100             return fontSynthesisFromStyle(style);
3101         case CSSPropertyFontFeatureSettings: {
3102             const FontFeatureSettings&amp; featureSettings = style.fontDescription().featureSettings();
3103             if (!featureSettings.size())
3104                 return cssValuePool.createIdentifierValue(CSSValueNormal);
3105             auto list = CSSValueList::createCommaSeparated();
3106             for (auto&amp; feature : featureSettings)
3107                 list-&gt;append(CSSFontFeatureValue::create(FontTag(feature.tag()), feature.value()));
<span class="line-modified">3108             return WTFMove(list);</span>
3109         }
3110 #if ENABLE(VARIATION_FONTS)
3111         case CSSPropertyFontVariationSettings: {
3112             const FontVariationSettings&amp; variationSettings = style.fontDescription().variationSettings();
3113             if (variationSettings.isEmpty())
3114                 return cssValuePool.createIdentifierValue(CSSValueNormal);
3115             auto list = CSSValueList::createCommaSeparated();
3116             for (auto&amp; feature : variationSettings)
3117                 list-&gt;append(CSSFontVariationValue::create(feature.tag(), feature.value()));
<span class="line-modified">3118             return WTFMove(list);</span>
3119         }
3120         case CSSPropertyFontOpticalSizing:
3121             return cssValuePool.createValue(style.fontDescription().opticalSizing());
3122 #endif
3123         case CSSPropertyGridAutoFlow: {
3124             auto list = CSSValueList::createSpaceSeparated();
3125             ASSERT(style.isGridAutoFlowDirectionRow() || style.isGridAutoFlowDirectionColumn());
3126             if (style.isGridAutoFlowDirectionRow())
3127                 list-&gt;append(cssValuePool.createIdentifierValue(CSSValueRow));
3128             else
3129                 list-&gt;append(cssValuePool.createIdentifierValue(CSSValueColumn));
3130 
3131             if (style.isGridAutoFlowAlgorithmDense())
3132                 list-&gt;append(cssValuePool.createIdentifierValue(CSSValueDense));
3133 
<span class="line-modified">3134             return WTFMove(list);</span>
3135         }
3136 
3137         // Specs mention that getComputedStyle() should return the used value of the property instead of the computed
3138         // one for grid-template-{rows|columns} but not for the grid-auto-{rows|columns} as things like
3139         // grid-auto-columns: 2fr; cannot be resolved to a value in pixels as the &#39;2fr&#39; means very different things
3140         // depending on the size of the explicit grid or the number of implicit tracks added to the grid. See
3141         // http://lists.w3.org/Archives/Public/www-style/2013Nov/0014.html
3142         case CSSPropertyGridAutoColumns:
3143             return valueForGridTrackSizeList(ForColumns, style);
3144         case CSSPropertyGridAutoRows:
3145             return valueForGridTrackSizeList(ForRows, style);
3146 
3147         case CSSPropertyGridTemplateColumns:
3148             return valueForGridTrackList(ForColumns, renderer, style);
3149         case CSSPropertyGridTemplateRows:
3150             return valueForGridTrackList(ForRows, renderer, style);
3151 
3152         case CSSPropertyGridColumnStart:
3153             return valueForGridPosition(style.gridItemColumnStart());
3154         case CSSPropertyGridColumnEnd:
</pre>
<hr />
<pre>
3162         case CSSPropertyGridTemplate:
3163             return getCSSPropertyValuesForGridShorthand(gridTemplateShorthand());
3164         case CSSPropertyGrid:
3165             return getCSSPropertyValuesForGridShorthand(gridShorthand());
3166         case CSSPropertyGridColumn:
3167             return getCSSPropertyValuesForGridShorthand(gridColumnShorthand());
3168         case CSSPropertyGridRow:
3169             return getCSSPropertyValuesForGridShorthand(gridRowShorthand());
3170         case CSSPropertyGridTemplateAreas:
3171             if (!style.namedGridAreaRowCount()) {
3172                 ASSERT(!style.namedGridAreaColumnCount());
3173                 return cssValuePool.createIdentifierValue(CSSValueNone);
3174             }
3175             return CSSGridTemplateAreasValue::create(style.namedGridArea(), style.namedGridAreaRowCount(), style.namedGridAreaColumnCount());
3176         case CSSPropertyGap:
3177             return getCSSPropertyValuesForShorthandProperties(gapShorthand());
3178         case CSSPropertyHeight:
3179             if (renderer &amp;&amp; !renderer-&gt;isRenderSVGModelObject()) {
3180                 // According to http://www.w3.org/TR/CSS2/visudet.html#the-height-property,
3181                 // the &quot;height&quot; property does not apply for non-replaced inline elements.
<span class="line-modified">3182                 if (isNonReplacedInline(*renderer))</span>
<span class="line-modified">3183                     return cssValuePool.createIdentifierValue(CSSValueAuto);</span>
<span class="line-removed">3184                 return zoomAdjustedPixelValue(sizingBox(*renderer).height(), style);</span>
3185             }
3186             return zoomAdjustedPixelValueForLength(style.height(), style);
3187         case CSSPropertyWebkitHyphens:
3188             return cssValuePool.createValue(style.hyphens());
3189         case CSSPropertyWebkitHyphenateCharacter:
3190             if (style.hyphenationString().isNull())
3191                 return cssValuePool.createIdentifierValue(CSSValueAuto);
3192             return cssValuePool.createValue(style.hyphenationString(), CSSPrimitiveValue::CSS_STRING);
3193         case CSSPropertyWebkitHyphenateLimitAfter:
3194             if (style.hyphenationLimitAfter() &lt; 0)
3195                 return CSSPrimitiveValue::createIdentifier(CSSValueAuto);
3196             return CSSPrimitiveValue::create(style.hyphenationLimitAfter(), CSSPrimitiveValue::CSS_NUMBER);
3197         case CSSPropertyWebkitHyphenateLimitBefore:
3198             if (style.hyphenationLimitBefore() &lt; 0)
3199                 return CSSPrimitiveValue::createIdentifier(CSSValueAuto);
3200             return CSSPrimitiveValue::create(style.hyphenationLimitBefore(), CSSPrimitiveValue::CSS_NUMBER);
3201         case CSSPropertyWebkitHyphenateLimitLines:
3202             if (style.hyphenationLimitLines() &lt; 0)
3203                 return CSSPrimitiveValue::createIdentifier(CSSValueNoLimit);
3204             return CSSPrimitiveValue::create(style.hyphenationLimitLines(), CSSPrimitiveValue::CSS_NUMBER);
</pre>
<hr />
<pre>
3289                 auto* styledElement = this-&gt;styledElement();
3290                 if (styledElement &amp;&amp; isFlexOrGrid(styledElement-&gt;parentNode()))
3291                     return cssValuePool.createIdentifierValue(CSSValueAuto);
3292                 return zoomAdjustedPixelValue(0, style);
3293             }
3294             return zoomAdjustedPixelValueForLength(style.minHeight(), style);
3295         case CSSPropertyMinWidth:
3296             if (style.minWidth().isAuto()) {
3297                 auto* styledElement = this-&gt;styledElement();
3298                 if (styledElement &amp;&amp; isFlexOrGrid(styledElement-&gt;parentNode()))
3299                     return cssValuePool.createIdentifierValue(CSSValueAuto);
3300                 return zoomAdjustedPixelValue(0, style);
3301             }
3302             return zoomAdjustedPixelValueForLength(style.minWidth(), style);
3303         case CSSPropertyObjectFit:
3304             return cssValuePool.createValue(style.objectFit());
3305         case CSSPropertyObjectPosition: {
3306             auto list = CSSValueList::createSpaceSeparated();
3307             list-&gt;append(zoomAdjustedPixelValueForLength(style.objectPosition().x(), style));
3308             list-&gt;append(zoomAdjustedPixelValueForLength(style.objectPosition().y(), style));
<span class="line-modified">3309             return WTFMove(list);</span>
3310         }
3311         case CSSPropertyOpacity:
3312             return cssValuePool.createValue(style.opacity(), CSSPrimitiveValue::CSS_NUMBER);
3313         case CSSPropertyOrphans:
3314             if (style.hasAutoOrphans())
3315                 return cssValuePool.createIdentifierValue(CSSValueAuto);
3316             return cssValuePool.createValue(style.orphans(), CSSPrimitiveValue::CSS_NUMBER);
3317         case CSSPropertyOutlineColor:
3318             return m_allowVisitedStyle ? cssValuePool.createColorValue(style.visitedDependentColor(CSSPropertyOutlineColor)) : currentColorOrValidColor(&amp;style, style.outlineColor());
3319         case CSSPropertyOutlineOffset:
3320             return zoomAdjustedPixelValue(style.outlineOffset(), style);
3321         case CSSPropertyOutlineStyle:
3322             if (style.outlineStyleIsAuto() == OutlineIsAuto::On)
3323                 return cssValuePool.createIdentifierValue(CSSValueAuto);
3324             return cssValuePool.createValue(style.outlineStyle());
3325         case CSSPropertyOutlineWidth:
3326             return zoomAdjustedPixelValue(style.outlineWidth(), style);
3327         case CSSPropertyOverflow:
3328             return cssValuePool.createValue(std::max(style.overflowX(), style.overflowY()));
3329         case CSSPropertyOverflowWrap:
</pre>
<hr />
<pre>
3398             return renderEmphasisPositionFlagsToCSSValue(style.textEmphasisPosition());
3399         case CSSPropertyWebkitTextEmphasisStyle:
3400             switch (style.textEmphasisMark()) {
3401             case TextEmphasisMark::None:
3402                 return cssValuePool.createIdentifierValue(CSSValueNone);
3403             case TextEmphasisMark::Custom:
3404                 return cssValuePool.createValue(style.textEmphasisCustomMark(), CSSPrimitiveValue::CSS_STRING);
3405             case TextEmphasisMark::Auto:
3406                 ASSERT_NOT_REACHED();
3407 #if ASSERT_DISABLED
3408                 FALLTHROUGH;
3409 #endif
3410             case TextEmphasisMark::Dot:
3411             case TextEmphasisMark::Circle:
3412             case TextEmphasisMark::DoubleCircle:
3413             case TextEmphasisMark::Triangle:
3414             case TextEmphasisMark::Sesame:
3415                 auto list = CSSValueList::createSpaceSeparated();
3416                 list-&gt;append(cssValuePool.createValue(style.textEmphasisFill()));
3417                 list-&gt;append(cssValuePool.createValue(style.textEmphasisMark()));
<span class="line-modified">3418                 return WTFMove(list);</span>
3419             }
3420             RELEASE_ASSERT_NOT_REACHED();
3421         case CSSPropertyTextIndent: {
3422             // If CSS3_TEXT is disabled or text-indent has only one value(&lt;length&gt; | &lt;percentage&gt;),
3423             // getPropertyCSSValue() returns CSSValue.
3424             auto textIndent = zoomAdjustedPixelValueForLength(style.textIndent(), style);
3425 #if ENABLE(CSS3_TEXT)
3426             // If CSS3_TEXT is enabled and text-indent has -webkit-each-line or -webkit-hanging,
3427             // getPropertyCSSValue() returns CSSValueList.
3428             if (style.textIndentLine() == TextIndentLine::EachLine || style.textIndentType() == TextIndentType::Hanging) {
3429                 auto list = CSSValueList::createSpaceSeparated();
3430                 list-&gt;append(WTFMove(textIndent));
3431                 if (style.textIndentLine() == TextIndentLine::EachLine)
3432                     list-&gt;append(cssValuePool.createIdentifierValue(CSSValueWebkitEachLine));
3433                 if (style.textIndentType() == TextIndentType::Hanging)
3434                     list-&gt;append(cssValuePool.createIdentifierValue(CSSValueWebkitHanging));
<span class="line-modified">3435                 return WTFMove(list);</span>
3436             }
3437 #endif
<span class="line-modified">3438             return WTFMove(textIndent);</span>
3439         }
3440         case CSSPropertyTextShadow:
3441             return valueForShadow(style.textShadow(), propertyID, style);
3442         case CSSPropertyTextRendering:
3443             return cssValuePool.createValue(style.fontDescription().textRenderingMode());
3444         case CSSPropertyTextOverflow:
3445             if (style.textOverflow() == TextOverflow::Ellipsis)
3446                 return cssValuePool.createIdentifierValue(CSSValueEllipsis);
3447             return cssValuePool.createIdentifierValue(CSSValueClip);
3448         case CSSPropertyWebkitTextSecurity:
3449             return cssValuePool.createValue(style.textSecurity());
3450 #if ENABLE(TEXT_AUTOSIZING)
3451         case CSSPropertyWebkitTextSizeAdjust:
3452             if (style.textSizeAdjust().isAuto())
3453                 return cssValuePool.createIdentifierValue(CSSValueAuto);
3454             if (style.textSizeAdjust().isNone())
3455                 return cssValuePool.createIdentifierValue(CSSValueNone);
3456             return CSSPrimitiveValue::create(style.textSizeAdjust().percentage(), CSSPrimitiveValue::CSS_PERCENTAGE);
3457 #endif
3458         case CSSPropertyWebkitTextStrokeColor:
</pre>
<hr />
<pre>
3485                 return cssValuePool.createIdentifierValue(CSSValueBottom);
3486             case VerticalAlign::BaselineMiddle:
3487                 return cssValuePool.createIdentifierValue(CSSValueWebkitBaselineMiddle);
3488             case VerticalAlign::Length:
3489                 return cssValuePool.createValue(style.verticalAlignLength());
3490             }
3491             ASSERT_NOT_REACHED();
3492             return nullptr;
3493         case CSSPropertyVisibility:
3494             return cssValuePool.createValue(style.visibility());
3495         case CSSPropertyWhiteSpace:
3496             return cssValuePool.createValue(style.whiteSpace());
3497         case CSSPropertyWidows:
3498             if (style.hasAutoWidows())
3499                 return cssValuePool.createIdentifierValue(CSSValueAuto);
3500             return cssValuePool.createValue(style.widows(), CSSPrimitiveValue::CSS_NUMBER);
3501         case CSSPropertyWidth:
3502             if (renderer &amp;&amp; !renderer-&gt;isRenderSVGModelObject()) {
3503                 // According to http://www.w3.org/TR/CSS2/visudet.html#the-width-property,
3504                 // the &quot;width&quot; property does not apply for non-replaced inline elements.
<span class="line-modified">3505                 if (isNonReplacedInline(*renderer))</span>
<span class="line-modified">3506                     return cssValuePool.createIdentifierValue(CSSValueAuto);</span>
<span class="line-removed">3507                 return zoomAdjustedPixelValue(sizingBox(*renderer).width(), style);</span>
3508             }
3509             return zoomAdjustedPixelValueForLength(style.width(), style);
3510         case CSSPropertyWillChange:
3511             return willChangePropertyValue(style.willChange());
3512         case CSSPropertyWordBreak:
3513             return cssValuePool.createValue(style.wordBreak());
3514         case CSSPropertyWordSpacing:
3515             return zoomAdjustedPixelValue(style.fontCascade().wordSpacing(), style);
3516         case CSSPropertyWordWrap:
3517             return cssValuePool.createValue(style.overflowWrap());
3518         case CSSPropertyLineBreak:
3519             return cssValuePool.createValue(style.lineBreak());
3520         case CSSPropertyWebkitNbspMode:
3521             return cssValuePool.createValue(style.nbspMode());
3522         case CSSPropertyResize:
3523             return cssValuePool.createValue(style.resize());
3524         case CSSPropertyWebkitFontKerning:
3525             return cssValuePool.createValue(style.fontDescription().kerning());
3526         case CSSPropertyWebkitFontSmoothing:
3527             return cssValuePool.createValue(style.fontDescription().fontSmoothing());
</pre>
<hr />
<pre>
3530         case CSSPropertyFontVariantPosition:
3531             return fontVariantPositionPropertyValue(style.fontDescription().variantPosition());
3532         case CSSPropertyFontVariantCaps:
3533             return fontVariantCapsPropertyValue(style.fontDescription().variantCaps());
3534         case CSSPropertyFontVariantNumeric:
3535             return fontVariantNumericPropertyValue(style.fontDescription().variantNumericFigure(), style.fontDescription().variantNumericSpacing(), style.fontDescription().variantNumericFraction(), style.fontDescription().variantNumericOrdinal(), style.fontDescription().variantNumericSlashedZero());
3536         case CSSPropertyFontVariantAlternates:
3537             return fontVariantAlternatesPropertyValue(style.fontDescription().variantAlternates());
3538         case CSSPropertyFontVariantEastAsian:
3539             return fontVariantEastAsianPropertyValue(style.fontDescription().variantEastAsianVariant(), style.fontDescription().variantEastAsianWidth(), style.fontDescription().variantEastAsianRuby());
3540         case CSSPropertyZIndex:
3541             if (style.hasAutoZIndex())
3542                 return cssValuePool.createIdentifierValue(CSSValueAuto);
3543             return cssValuePool.createValue(style.zIndex(), CSSPrimitiveValue::CSS_NUMBER);
3544         case CSSPropertyZoom:
3545             return cssValuePool.createValue(style.zoom(), CSSPrimitiveValue::CSS_NUMBER);
3546         case CSSPropertyBoxSizing:
3547             if (style.boxSizing() == BoxSizing::ContentBox)
3548                 return cssValuePool.createIdentifierValue(CSSValueContentBox);
3549             return cssValuePool.createIdentifierValue(CSSValueBorderBox);
<span class="line-removed">3550 #if ENABLE(DASHBOARD_SUPPORT)</span>
<span class="line-removed">3551         case CSSPropertyWebkitDashboardRegion:</span>
<span class="line-removed">3552         {</span>
<span class="line-removed">3553             const Vector&lt;StyleDashboardRegion&gt;&amp; regions = style.dashboardRegions();</span>
<span class="line-removed">3554             unsigned count = regions.size();</span>
<span class="line-removed">3555             if (count == 1 &amp;&amp; regions[0].type == StyleDashboardRegion::None)</span>
<span class="line-removed">3556                 return cssValuePool.createIdentifierValue(CSSValueNone);</span>
<span class="line-removed">3557 </span>
<span class="line-removed">3558             RefPtr&lt;DashboardRegion&gt; firstRegion;</span>
<span class="line-removed">3559             DashboardRegion* previousRegion = nullptr;</span>
<span class="line-removed">3560             for (unsigned i = 0; i &lt; count; i++) {</span>
<span class="line-removed">3561                 auto region = DashboardRegion::create();</span>
<span class="line-removed">3562                 StyleDashboardRegion styleRegion = regions[i];</span>
<span class="line-removed">3563 </span>
<span class="line-removed">3564                 region-&gt;m_label = styleRegion.label;</span>
<span class="line-removed">3565                 LengthBox offset = styleRegion.offset;</span>
<span class="line-removed">3566                 region-&gt;setTop(zoomAdjustedPixelValue(offset.top().value(), style));</span>
<span class="line-removed">3567                 region-&gt;setRight(zoomAdjustedPixelValue(offset.right().value(), style));</span>
<span class="line-removed">3568                 region-&gt;setBottom(zoomAdjustedPixelValue(offset.bottom().value(), style));</span>
<span class="line-removed">3569                 region-&gt;setLeft(zoomAdjustedPixelValue(offset.left().value(), style));</span>
<span class="line-removed">3570                 region-&gt;m_isRectangle = (styleRegion.type == StyleDashboardRegion::Rectangle);</span>
<span class="line-removed">3571                 region-&gt;m_isCircle = (styleRegion.type == StyleDashboardRegion::Circle);</span>
<span class="line-removed">3572 </span>
<span class="line-removed">3573                 if (previousRegion)</span>
<span class="line-removed">3574                     previousRegion-&gt;m_next = region.copyRef();</span>
<span class="line-removed">3575                 else</span>
<span class="line-removed">3576                     firstRegion = region.copyRef();</span>
<span class="line-removed">3577                 previousRegion = region.ptr();</span>
<span class="line-removed">3578             }</span>
<span class="line-removed">3579             return cssValuePool.createValue(WTFMove(firstRegion));</span>
<span class="line-removed">3580         }</span>
<span class="line-removed">3581 #endif</span>
3582         case CSSPropertyAnimationDelay:
3583             return delayValue(style.animations());
3584         case CSSPropertyAnimationDirection: {
3585             auto list = CSSValueList::createCommaSeparated();
3586             const AnimationList* t = style.animations();
3587             if (t) {
3588                 for (size_t i = 0; i &lt; t-&gt;size(); ++i) {
3589                     switch (t-&gt;animation(i).direction()) {
3590                     case Animation::AnimationDirectionNormal:
3591                         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueNormal));
3592                         break;
3593                     case Animation::AnimationDirectionAlternate:
3594                         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueAlternate));
3595                         break;
3596                     case Animation::AnimationDirectionReverse:
3597                         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueReverse));
3598                         break;
3599                     case Animation::AnimationDirectionAlternateReverse:
3600                         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueAlternateReverse));
3601                         break;
3602                     }
3603                 }
3604             } else
3605                 list-&gt;append(cssValuePool.createIdentifierValue(CSSValueNormal));
<span class="line-modified">3606             return WTFMove(list);</span>
3607         }
3608         case CSSPropertyAnimationDuration:
3609             return durationValue(style.animations());
3610         case CSSPropertyAnimationFillMode: {
3611             auto list = CSSValueList::createCommaSeparated();
3612             const AnimationList* t = style.animations();
3613             if (t) {
3614                 for (size_t i = 0; i &lt; t-&gt;size(); ++i) {
3615                     switch (t-&gt;animation(i).fillMode()) {
3616                     case AnimationFillMode::None:
3617                         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueNone));
3618                         break;
3619                     case AnimationFillMode::Forwards:
3620                         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueForwards));
3621                         break;
3622                     case AnimationFillMode::Backwards:
3623                         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueBackwards));
3624                         break;
3625                     case AnimationFillMode::Both:
3626                         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueBoth));
3627                         break;
3628                     }
3629                 }
3630             } else
3631                 list-&gt;append(cssValuePool.createIdentifierValue(CSSValueNone));
<span class="line-modified">3632             return WTFMove(list);</span>
3633         }
3634         case CSSPropertyAnimationIterationCount: {
3635             auto list = CSSValueList::createCommaSeparated();
3636             const AnimationList* t = style.animations();
3637             if (t) {
3638                 for (size_t i = 0; i &lt; t-&gt;size(); ++i) {
3639                     double iterationCount = t-&gt;animation(i).iterationCount();
3640                     if (iterationCount == Animation::IterationCountInfinite)
3641                         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueInfinite));
3642                     else
3643                         list-&gt;append(cssValuePool.createValue(iterationCount, CSSPrimitiveValue::CSS_NUMBER));
3644                 }
3645             } else
3646                 list-&gt;append(cssValuePool.createValue(Animation::initialIterationCount(), CSSPrimitiveValue::CSS_NUMBER));
<span class="line-modified">3647             return WTFMove(list);</span>
3648         }
3649         case CSSPropertyAnimationName: {
3650             auto list = CSSValueList::createCommaSeparated();
3651             const AnimationList* t = style.animations();
3652             if (t) {
3653                 for (size_t i = 0; i &lt; t-&gt;size(); ++i)
3654                     list-&gt;append(cssValuePool.createValue(t-&gt;animation(i).name(), CSSPrimitiveValue::CSS_STRING));
3655             } else
3656                 list-&gt;append(cssValuePool.createIdentifierValue(CSSValueNone));
<span class="line-modified">3657             return WTFMove(list);</span>
3658         }
3659         case CSSPropertyAnimationPlayState: {
3660             auto list = CSSValueList::createCommaSeparated();
3661             const AnimationList* t = style.animations();
3662             if (t) {
3663                 for (size_t i = 0; i &lt; t-&gt;size(); ++i) {
3664                     switch (t-&gt;animation(i).playState()) {
3665                     case AnimationPlayState::Playing:
3666                         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueRunning));
3667                         break;
3668                     case AnimationPlayState::Paused:
3669                         list-&gt;append(cssValuePool.createIdentifierValue(CSSValuePaused));
3670                         break;
3671                     }
3672                 }
3673             } else
3674                 list-&gt;append(cssValuePool.createIdentifierValue(CSSValueRunning));
<span class="line-modified">3675             return WTFMove(list);</span>
3676         }
3677         case CSSPropertyAnimationTimingFunction:
3678             return timingFunctionValue(style.animations());
3679         case CSSPropertyWebkitAppearance:
3680             return cssValuePool.createValue(style.appearance());
3681         case CSSPropertyWebkitAspectRatio:
3682             switch (style.aspectRatioType()) {
3683             case AspectRatioType::Auto:
3684                 return cssValuePool.createIdentifierValue(CSSValueAuto);
3685             case AspectRatioType::FromDimensions:
3686                 return cssValuePool.createIdentifierValue(CSSValueFromDimensions);
3687             case AspectRatioType::FromIntrinsic:
3688                 return cssValuePool.createIdentifierValue(CSSValueFromIntrinsic);
3689             case AspectRatioType::Specified:
3690                 return CSSAspectRatioValue::create(style.aspectRatioNumerator(), style.aspectRatioDenominator());
3691             }
3692             ASSERT_NOT_REACHED();
3693             return nullptr;
3694         case CSSPropertyWebkitBackfaceVisibility:
3695             return cssValuePool.createIdentifierValue((style.backfaceVisibility() == BackfaceVisibility::Hidden) ? CSSValueHidden : CSSValueVisible);
</pre>
<hr />
<pre>
3714         case CSSPropertyWebkitMaskBoxImageWidth:
3715             return valueForNinePieceImageQuad(style.maskBoxImage().borderSlices());
3716         case CSSPropertyWebkitMaskBoxImageSource:
3717             if (style.maskBoxImageSource())
3718                 return style.maskBoxImageSource()-&gt;cssValue();
3719             return cssValuePool.createIdentifierValue(CSSValueNone);
3720         case CSSPropertyWebkitFontSizeDelta:
3721             // Not a real style property -- used by the editing engine -- so has no computed value.
3722             break;
3723         case CSSPropertyWebkitInitialLetter: {
3724             auto drop = !style.initialLetterDrop() ? cssValuePool.createIdentifierValue(CSSValueNormal) : cssValuePool.createValue(style.initialLetterDrop(), CSSPrimitiveValue::CSS_NUMBER);
3725             auto size = !style.initialLetterHeight() ? cssValuePool.createIdentifierValue(CSSValueNormal) : cssValuePool.createValue(style.initialLetterHeight(), CSSPrimitiveValue::CSS_NUMBER);
3726             return cssValuePool.createValue(Pair::create(WTFMove(drop), WTFMove(size)));
3727         }
3728         case CSSPropertyWebkitMarginBottomCollapse:
3729         case CSSPropertyWebkitMarginAfterCollapse:
3730             return cssValuePool.createValue(style.marginAfterCollapse());
3731         case CSSPropertyWebkitMarginTopCollapse:
3732         case CSSPropertyWebkitMarginBeforeCollapse:
3733             return cssValuePool.createValue(style.marginBeforeCollapse());
<span class="line-modified">3734 #if ENABLE(ACCELERATED_OVERFLOW_SCROLLING)</span>
3735         case CSSPropertyWebkitOverflowScrolling:
3736             if (!style.useTouchOverflowScrolling())
3737                 return cssValuePool.createIdentifierValue(CSSValueAuto);
3738             return cssValuePool.createIdentifierValue(CSSValueTouch);
3739 #endif
3740         case CSSPropertyPerspective:
3741             if (!style.hasPerspective())
3742                 return cssValuePool.createIdentifierValue(CSSValueNone);
3743             return zoomAdjustedPixelValue(style.perspective(), style);
3744         case CSSPropertyPerspectiveOrigin: {
3745             auto list = CSSValueList::createSpaceSeparated();
3746             if (renderer) {
3747                 LayoutRect box;
3748                 if (is&lt;RenderBox&gt;(*renderer))
3749                     box = downcast&lt;RenderBox&gt;(*renderer).borderBoxRect();
3750 
3751                 list-&gt;append(zoomAdjustedPixelValue(minimumValueForLength(style.perspectiveOriginX(), box.width()), style));
3752                 list-&gt;append(zoomAdjustedPixelValue(minimumValueForLength(style.perspectiveOriginY(), box.height()), style));
3753             } else {
3754                 list-&gt;append(zoomAdjustedPixelValueForLength(style.perspectiveOriginX(), style));
3755                 list-&gt;append(zoomAdjustedPixelValueForLength(style.perspectiveOriginY(), style));
3756             }
<span class="line-modified">3757             return WTFMove(list);</span>
3758         }
3759         case CSSPropertyWebkitRtlOrdering:
3760             return cssValuePool.createIdentifierValue(style.rtlOrdering() == Order::Visual ? CSSValueVisual : CSSValueLogical);
3761 #if ENABLE(TOUCH_EVENTS)
3762         case CSSPropertyWebkitTapHighlightColor:
3763             return currentColorOrValidColor(&amp;style, style.tapHighlightColor());
3764 #endif
3765 #if ENABLE(POINTER_EVENTS)
3766         case CSSPropertyTouchAction:
3767             return touchActionFlagsToCSSValue(style.touchActions());
3768 #endif
3769 #if PLATFORM(IOS_FAMILY)
3770         case CSSPropertyWebkitTouchCallout:
3771             return cssValuePool.createIdentifierValue(style.touchCalloutEnabled() ? CSSValueDefault : CSSValueNone);
3772 #endif
3773         case CSSPropertyWebkitUserDrag:
3774             return cssValuePool.createValue(style.userDrag());
3775         case CSSPropertyWebkitUserSelect:
3776             return cssValuePool.createValue(style.userSelect());
3777         case CSSPropertyBorderBottomLeftRadius:
</pre>
<hr />
<pre>
3798             return computedTransform(renderer, style);
3799         case CSSPropertyTransformBox:
3800             return CSSPrimitiveValue::create(style.transformBox());
3801         case CSSPropertyTransformOrigin: {
3802             auto list = CSSValueList::createSpaceSeparated();
3803             if (renderer) {
3804                 LayoutRect box;
3805                 if (is&lt;RenderBox&gt;(*renderer))
3806                     box = downcast&lt;RenderBox&gt;(*renderer).borderBoxRect();
3807 
3808                 list-&gt;append(zoomAdjustedPixelValue(minimumValueForLength(style.transformOriginX(), box.width()), style));
3809                 list-&gt;append(zoomAdjustedPixelValue(minimumValueForLength(style.transformOriginY(), box.height()), style));
3810                 if (style.transformOriginZ())
3811                     list-&gt;append(zoomAdjustedPixelValue(style.transformOriginZ(), style));
3812             } else {
3813                 list-&gt;append(zoomAdjustedPixelValueForLength(style.transformOriginX(), style));
3814                 list-&gt;append(zoomAdjustedPixelValueForLength(style.transformOriginY(), style));
3815                 if (style.transformOriginZ())
3816                     list-&gt;append(zoomAdjustedPixelValue(style.transformOriginZ(), style));
3817             }
<span class="line-modified">3818             return WTFMove(list);</span>
3819         }
3820         case CSSPropertyTransformStyle:
3821         case CSSPropertyWebkitTransformStyle:
3822             return cssValuePool.createIdentifierValue((style.transformStyle3D() == TransformStyle3D::Preserve3D) ? CSSValuePreserve3d : CSSValueFlat);
3823         case CSSPropertyTransitionDelay:
3824             return delayValue(style.transitions());
3825         case CSSPropertyTransitionDuration:
3826             return durationValue(style.transitions());
3827         case CSSPropertyTransitionProperty:
3828             return transitionPropertyValue(style.transitions());
3829         case CSSPropertyTransitionTimingFunction:
3830             return timingFunctionValue(style.transitions());
3831         case CSSPropertyTransition: {
3832             if (auto* animationList = style.transitions()) {
3833                 auto transitionsList = CSSValueList::createCommaSeparated();
3834                 for (size_t i = 0; i &lt; animationList-&gt;size(); ++i) {
3835                     auto list = CSSValueList::createSpaceSeparated();
3836                     auto&amp; animation = animationList-&gt;animation(i);
3837                     list-&gt;append(createTransitionPropertyValue(animation));
3838                     list-&gt;append(cssValuePool.createValue(animation.duration(), CSSPrimitiveValue::CSS_S));
3839                     list-&gt;append(createTimingFunctionValue(*animation.timingFunction()));
3840                     list-&gt;append(cssValuePool.createValue(animation.delay(), CSSPrimitiveValue::CSS_S));
3841                     transitionsList-&gt;append(WTFMove(list));
3842                 }
<span class="line-modified">3843                 return WTFMove(transitionsList);</span>
3844             }
3845 
3846             auto list = CSSValueList::createSpaceSeparated();
3847             // transition-property default value.
3848             list-&gt;append(cssValuePool.createIdentifierValue(CSSValueAll));
3849             list-&gt;append(cssValuePool.createValue(Animation::initialDuration(), CSSPrimitiveValue::CSS_S));
3850             list-&gt;append(createTimingFunctionValue(Animation::initialTimingFunction()));
3851             list-&gt;append(cssValuePool.createValue(Animation::initialDelay(), CSSPrimitiveValue::CSS_S));
<span class="line-modified">3852             return WTFMove(list);</span>
3853         }
3854         case CSSPropertyPointerEvents:
3855             return cssValuePool.createValue(style.pointerEvents());
3856         case CSSPropertyWebkitLineGrid:
3857             if (style.lineGrid().isNull())
3858                 return cssValuePool.createIdentifierValue(CSSValueNone);
3859             return cssValuePool.createValue(style.lineGrid(), CSSPrimitiveValue::CSS_STRING);
3860         case CSSPropertyWebkitLineSnap:
3861             return CSSPrimitiveValue::create(style.lineSnap());
3862         case CSSPropertyWebkitLineAlign:
3863             return CSSPrimitiveValue::create(style.lineAlign());
3864         case CSSPropertyWritingMode:
3865             return cssValuePool.createValue(style.writingMode());
3866         case CSSPropertyWebkitTextCombine:
3867             return cssValuePool.createValue(style.textCombine());
3868         case CSSPropertyWebkitTextOrientation:
3869             return CSSPrimitiveValue::create(style.textOrientation());
3870         case CSSPropertyWebkitLineBoxContain:
3871             return createLineBoxContainValue(style.lineBoxContain());
3872         case CSSPropertyAlt:
</pre>
<hr />
<pre>
3875             return contentToCSSValue(style);
3876         case CSSPropertyCounterIncrement:
3877             return counterToCSSValue(style, propertyID);
3878         case CSSPropertyCounterReset:
3879             return counterToCSSValue(style, propertyID);
3880         case CSSPropertyWebkitClipPath: {
3881             auto* operation = style.clipPath();
3882             if (!operation)
3883                 return cssValuePool.createIdentifierValue(CSSValueNone);
3884             if (is&lt;ReferenceClipPathOperation&gt;(*operation))
3885                 return CSSPrimitiveValue::create(downcast&lt;ReferenceClipPathOperation&gt;(*operation).url(), CSSPrimitiveValue::CSS_URI);
3886             auto list = CSSValueList::createSpaceSeparated();
3887             if (is&lt;ShapeClipPathOperation&gt;(*operation)) {
3888                 auto&amp; shapeOperation = downcast&lt;ShapeClipPathOperation&gt;(*operation);
3889                 list-&gt;append(valueForBasicShape(style, shapeOperation.basicShape()));
3890                 if (shapeOperation.referenceBox() != CSSBoxType::BoxMissing)
3891                     list-&gt;append(cssValuePool.createValue(shapeOperation.referenceBox()));
3892             }
3893             if (is&lt;BoxClipPathOperation&gt;(*operation))
3894                 list-&gt;append(cssValuePool.createValue(downcast&lt;BoxClipPathOperation&gt;(*operation).referenceBox()));
<span class="line-modified">3895             return WTFMove(list);</span>
3896         }
3897         case CSSPropertyShapeMargin:
3898             return cssValuePool.createValue(style.shapeMargin(), style);
3899         case CSSPropertyShapeImageThreshold:
3900             return cssValuePool.createValue(style.shapeImageThreshold(), CSSPrimitiveValue::CSS_NUMBER);
3901         case CSSPropertyShapeOutside:
3902             return shapePropertyValue(style, style.shapeOutside());
3903         case CSSPropertyFilter:
3904             return valueForFilter(style, style.filter());
3905         case CSSPropertyAppleColorFilter:
3906             return valueForFilter(style, style.appleColorFilter());
3907 #if ENABLE(FILTERS_LEVEL_2)
3908         case CSSPropertyWebkitBackdropFilter:
3909             return valueForFilter(style, style.backdropFilter());
3910 #endif
3911 #if ENABLE(CSS_COMPOSITING)
3912         case CSSPropertyMixBlendMode:
3913             return cssValuePool.createValue(style.blendMode());
3914         case CSSPropertyIsolation:
3915             return cssValuePool.createValue(style.isolation());
3916 #endif
3917         case CSSPropertyBackgroundBlendMode: {
3918             auto&amp; layers = style.backgroundLayers();
3919             if (!layers.next())
3920                 return cssValuePool.createValue(layers.blendMode());
3921             auto list = CSSValueList::createCommaSeparated();
3922             for (auto* currLayer = &amp;layers; currLayer; currLayer = currLayer-&gt;next())
3923                 list-&gt;append(cssValuePool.createValue(currLayer-&gt;blendMode()));
<span class="line-modified">3924             return WTFMove(list);</span>
3925         }
3926         case CSSPropertyBackground:
3927             return getBackgroundShorthandValue();
3928         case CSSPropertyBorder: {
3929             auto value = propertyValue(CSSPropertyBorderTop, DoNotUpdateLayout);
3930             const CSSPropertyID properties[3] = { CSSPropertyBorderRight, CSSPropertyBorderBottom, CSSPropertyBorderLeft };
3931             for (auto&amp; property : properties) {
3932                 if (!compareCSSValuePtr&lt;CSSValue&gt;(value, propertyValue(property, DoNotUpdateLayout)))
3933                     return nullptr;
3934             }
3935             return value;
3936         }
3937         case CSSPropertyBorderBlock: {
3938             auto value = propertyValue(CSSPropertyBorderBlockStart, DoNotUpdateLayout);
3939             if (!compareCSSValuePtr&lt;CSSValue&gt;(value, propertyValue(CSSPropertyBorderBlockEnd, DoNotUpdateLayout)))
3940                 return nullptr;
3941             return value;
3942         }
3943         case CSSPropertyBorderBlockColor:
3944             return getCSSPropertyValuesFor2SidesShorthand(borderBlockColorShorthand());
</pre>
<hr />
<pre>
4025             return zoomAdjustedPixelValueForLength(style.scrollPaddingLeft(), style);
4026         case CSSPropertyScrollSnapType:
4027             return valueForScrollSnapType(style.scrollSnapType());
4028         case CSSPropertyScrollSnapAlign:
4029             return valueForScrollSnapAlignment(style.scrollSnapAlign());
4030 #endif
4031 
4032 #if ENABLE(CSS_TRAILING_WORD)
4033         case CSSPropertyAppleTrailingWord:
4034             return cssValuePool.createValue(style.trailingWord());
4035 #endif
4036 
4037 #if ENABLE(APPLE_PAY)
4038         case CSSPropertyApplePayButtonStyle:
4039             return cssValuePool.createValue(style.applePayButtonStyle());
4040         case CSSPropertyApplePayButtonType:
4041             return cssValuePool.createValue(style.applePayButtonType());
4042 #endif
4043 
4044 #if ENABLE(DARK_MODE_CSS)
<span class="line-modified">4045         case CSSPropertySupportedColorSchemes: {</span>
<span class="line-modified">4046             if (!RuntimeEnabledFeatures::sharedFeatures().darkModeCSSEnabled())</span>
<span class="line-modified">4047                 return nullptr;</span>
<span class="line-removed">4048 </span>
<span class="line-removed">4049             auto supportedColorSchemes = style.supportedColorSchemes();</span>
<span class="line-removed">4050             if (supportedColorSchemes.isAuto())</span>
4051                 return cssValuePool.createIdentifierValue(CSSValueAuto);
4052 
4053             auto list = CSSValueList::createSpaceSeparated();
<span class="line-modified">4054             if (supportedColorSchemes.contains(ColorSchemes::Light))</span>
4055                 list-&gt;append(cssValuePool.createIdentifierValue(CSSValueLight));
<span class="line-modified">4056             if (supportedColorSchemes.contains(ColorSchemes::Dark))</span>
4057                 list-&gt;append(cssValuePool.createIdentifierValue(CSSValueDark));
<span class="line-modified">4058             if (!supportedColorSchemes.allowsTransformations())</span>
4059                 list-&gt;append(cssValuePool.createIdentifierValue(CSSValueOnly));
4060             ASSERT(list-&gt;length());
<span class="line-modified">4061             return WTFMove(list);</span>
4062         }
4063 #endif
4064 
4065         /* Individual properties not part of the spec */
4066         case CSSPropertyBackgroundRepeatX:
4067         case CSSPropertyBackgroundRepeatY:
4068             break;
4069 
4070         // Length properties for SVG.
4071         case CSSPropertyCx:
4072             return zoomAdjustedPixelValueForLength(style.svgStyle().cx(), style);
4073         case CSSPropertyCy:
4074             return zoomAdjustedPixelValueForLength(style.svgStyle().cy(), style);
4075         case CSSPropertyR:
4076             return zoomAdjustedPixelValueForLength(style.svgStyle().r(), style);
4077         case CSSPropertyRx:
4078             return zoomAdjustedPixelValueForLength(style.svgStyle().rx(), style);
4079         case CSSPropertyRy:
4080             return zoomAdjustedPixelValueForLength(style.svgStyle().ry(), style);
4081         case CSSPropertyStrokeDashoffset:
</pre>
<hr />
<pre>
4299 }
4300 
4301 RefPtr&lt;CSSValueList&gt; ComputedStyleExtractor::getCSSPropertyValuesFor2SidesShorthand(const StylePropertyShorthand&amp; shorthand)
4302 {
4303     auto list = CSSValueList::createSpaceSeparated();
4304 
4305     // Assume the properties are in the usual order start, end.
4306     auto startValue = propertyValue(shorthand.properties()[0], DoNotUpdateLayout);
4307     auto endValue = propertyValue(shorthand.properties()[1], DoNotUpdateLayout);
4308 
4309     // All 2 properties must be specified.
4310     if (!startValue || !endValue)
4311         return nullptr;
4312 
4313     bool showEnd = !compareCSSValuePtr(startValue, endValue);
4314 
4315     list-&gt;append(startValue.releaseNonNull());
4316     if (showEnd)
4317         list-&gt;append(endValue.releaseNonNull());
4318 
<span class="line-modified">4319     return WTFMove(list);</span>
4320 }
4321 
4322 RefPtr&lt;CSSValueList&gt; ComputedStyleExtractor::getCSSPropertyValuesFor4SidesShorthand(const StylePropertyShorthand&amp; shorthand)
4323 {
4324     auto list = CSSValueList::createSpaceSeparated();
4325 
4326     // Assume the properties are in the usual order top, right, bottom, left.
4327     auto topValue = propertyValue(shorthand.properties()[0], DoNotUpdateLayout);
4328     auto rightValue = propertyValue(shorthand.properties()[1], DoNotUpdateLayout);
4329     auto bottomValue = propertyValue(shorthand.properties()[2], DoNotUpdateLayout);
4330     auto leftValue = propertyValue(shorthand.properties()[3], DoNotUpdateLayout);
4331 
4332     // All 4 properties must be specified.
4333     if (!topValue || !rightValue || !bottomValue || !leftValue)
4334         return nullptr;
4335 
4336     bool showLeft = !compareCSSValuePtr(rightValue, leftValue);
4337     bool showBottom = !compareCSSValuePtr(topValue, bottomValue) || showLeft;
4338     bool showRight = !compareCSSValuePtr(topValue, rightValue) || showBottom;
4339 
4340     list-&gt;append(topValue.releaseNonNull());
4341     if (showRight)
4342         list-&gt;append(rightValue.releaseNonNull());
4343     if (showBottom)
4344         list-&gt;append(bottomValue.releaseNonNull());
4345     if (showLeft)
4346         list-&gt;append(leftValue.releaseNonNull());
4347 
<span class="line-modified">4348     return WTFMove(list);</span>
4349 }
4350 
4351 Ref&lt;CSSValueList&gt; ComputedStyleExtractor::getCSSPropertyValuesForGridShorthand(const StylePropertyShorthand&amp; shorthand)
4352 {
4353     auto list = CSSValueList::createSlashSeparated();
4354     for (size_t i = 0; i &lt; shorthand.length(); ++i)
4355         list-&gt;append(propertyValue(shorthand.properties()[i], DoNotUpdateLayout).releaseNonNull());
4356     return list;
4357 }
4358 
4359 Ref&lt;MutableStyleProperties&gt; ComputedStyleExtractor::copyPropertiesInSet(const CSSPropertyID* set, unsigned length)
4360 {
4361     Vector&lt;CSSProperty, 256&gt; list;
4362     list.reserveInitialCapacity(length);
4363     for (unsigned i = 0; i &lt; length; ++i) {
4364         if (auto value = propertyValue(set[i]))
4365             list.append(CSSProperty(set[i], WTFMove(value), false));
4366     }
4367     return MutableStyleProperties::create(list.data(), list.size());
4368 }
</pre>
</td>
<td>
<hr />
<pre>
  59 #include &quot;NodeRenderStyle.h&quot;
  60 #include &quot;Pair.h&quot;
  61 #include &quot;Rect.h&quot;
  62 #include &quot;RenderBlock.h&quot;
  63 #include &quot;RenderBox.h&quot;
  64 #include &quot;RenderInline.h&quot;
  65 #include &quot;RenderStyle.h&quot;
  66 #include &quot;RuntimeEnabledFeatures.h&quot;
  67 #include &quot;SVGElement.h&quot;
  68 #include &quot;Settings.h&quot;
  69 #include &quot;ShapeValue.h&quot;
  70 #include &quot;StyleProperties.h&quot;
  71 #include &quot;StylePropertyShorthand.h&quot;
  72 #include &quot;StylePropertyShorthandFunctions.h&quot;
  73 #include &quot;StyleResolver.h&quot;
  74 #include &quot;StyleScope.h&quot;
  75 #include &quot;StyleScrollSnapPoints.h&quot;
  76 #include &quot;TouchAction.h&quot;
  77 #include &quot;WebKitFontFamilyNames.h&quot;
  78 #include &quot;WillChangeData.h&quot;
<span class="line-added">  79 #include &lt;wtf/IsoMallocInlines.h&gt;</span>
  80 #include &lt;wtf/NeverDestroyed.h&gt;
  81 #include &lt;wtf/text/StringBuilder.h&gt;
  82 
  83 #include &quot;CSSGridLineNamesValue.h&quot;
  84 #include &quot;CSSGridTemplateAreasValue.h&quot;
  85 #include &quot;RenderGrid.h&quot;
  86 




  87 namespace WebCore {
  88 
<span class="line-added">  89 WTF_MAKE_ISO_ALLOCATED_IMPL(CSSComputedStyleDeclaration);</span>
<span class="line-added">  90 </span>
  91 // List of all properties we know how to compute, omitting shorthands.
  92 static const CSSPropertyID computedProperties[] = {
<span class="line-added">  93     CSSPropertyAlignContent,</span>
<span class="line-added">  94     CSSPropertyAlignItems,</span>
<span class="line-added">  95     CSSPropertyAlignSelf,</span>
<span class="line-added">  96     CSSPropertyAlignmentBaseline,</span>
  97     CSSPropertyAlt,
  98     CSSPropertyAnimationDelay,
  99     CSSPropertyAnimationDirection,
 100     CSSPropertyAnimationDuration,
 101     CSSPropertyAnimationFillMode,
 102     CSSPropertyAnimationIterationCount,
 103     CSSPropertyAnimationName,
 104     CSSPropertyAnimationPlayState,
 105     CSSPropertyAnimationTimingFunction,
 106     CSSPropertyBackgroundAttachment,
 107     CSSPropertyBackgroundBlendMode,
 108     CSSPropertyBackgroundClip,
 109     CSSPropertyBackgroundColor,
 110     CSSPropertyBackgroundImage,
 111     CSSPropertyBackgroundOrigin,
 112     CSSPropertyBackgroundPosition, // more-specific background-position-x/y are non-standard
 113     CSSPropertyBackgroundRepeat,
 114     CSSPropertyBackgroundSize,
<span class="line-added"> 115     CSSPropertyBaselineShift,</span>
 116     CSSPropertyBorderBottomColor,
 117     CSSPropertyBorderBottomLeftRadius,
 118     CSSPropertyBorderBottomRightRadius,
 119     CSSPropertyBorderBottomStyle,
 120     CSSPropertyBorderBottomWidth,
 121     CSSPropertyBorderCollapse,
 122     CSSPropertyBorderImageOutset,
 123     CSSPropertyBorderImageRepeat,
 124     CSSPropertyBorderImageSlice,
 125     CSSPropertyBorderImageSource,
 126     CSSPropertyBorderImageWidth,
 127     CSSPropertyBorderLeftColor,
 128     CSSPropertyBorderLeftStyle,
 129     CSSPropertyBorderLeftWidth,
 130     CSSPropertyBorderRightColor,
 131     CSSPropertyBorderRightStyle,
 132     CSSPropertyBorderRightWidth,
 133     CSSPropertyBorderTopColor,
 134     CSSPropertyBorderTopLeftRadius,
 135     CSSPropertyBorderTopRightRadius,
 136     CSSPropertyBorderTopStyle,
 137     CSSPropertyBorderTopWidth,
 138     CSSPropertyBottom,
 139     CSSPropertyBoxShadow,
 140     CSSPropertyBoxSizing,
<span class="line-added"> 141     CSSPropertyBufferedRendering,</span>
 142     CSSPropertyCaptionSide,
 143     CSSPropertyCaretColor,
 144     CSSPropertyClear,
 145     CSSPropertyClip,
<span class="line-added"> 146     CSSPropertyClipPath,</span>
<span class="line-added"> 147     CSSPropertyClipRule,</span>
 148     CSSPropertyColor,
<span class="line-modified"> 149     CSSPropertyColorInterpolation,</span>
<span class="line-added"> 150     CSSPropertyColorInterpolationFilters,</span>
<span class="line-added"> 151     CSSPropertyColorRendering,</span>
<span class="line-added"> 152 #if ENABLE(DARK_MODE_CSS)</span>
<span class="line-added"> 153     CSSPropertyColorScheme,</span>
<span class="line-added"> 154 #endif</span>
<span class="line-added"> 155     CSSPropertyColumnCount,</span>
<span class="line-added"> 156     CSSPropertyColumnFill,</span>
<span class="line-added"> 157     CSSPropertyColumnGap,</span>
<span class="line-added"> 158     CSSPropertyColumnRuleColor,</span>
<span class="line-added"> 159     CSSPropertyColumnRuleStyle,</span>
<span class="line-added"> 160     CSSPropertyColumnRuleWidth,</span>
<span class="line-added"> 161     CSSPropertyColumnSpan,</span>
<span class="line-added"> 162     CSSPropertyColumnWidth,</span>
<span class="line-added"> 163     CSSPropertyContent,</span>
 164     CSSPropertyCounterIncrement,
 165     CSSPropertyCounterReset,

 166     CSSPropertyCursor,
<span class="line-added"> 167     CSSPropertyCx,</span>
<span class="line-added"> 168     CSSPropertyCy,</span>
 169     CSSPropertyDirection,
 170     CSSPropertyDisplay,
<span class="line-added"> 171     CSSPropertyDominantBaseline,</span>
 172     CSSPropertyEmptyCells,
<span class="line-added"> 173     CSSPropertyFill,</span>
<span class="line-added"> 174     CSSPropertyFillOpacity,</span>
<span class="line-added"> 175     CSSPropertyFillRule,</span>
<span class="line-added"> 176     CSSPropertyFilter,</span>
<span class="line-added"> 177     CSSPropertyFlexBasis,</span>
<span class="line-added"> 178     CSSPropertyFlexDirection,</span>
<span class="line-added"> 179     CSSPropertyFlexFlow,</span>
<span class="line-added"> 180     CSSPropertyFlexGrow,</span>
<span class="line-added"> 181     CSSPropertyFlexShrink,</span>
<span class="line-added"> 182     CSSPropertyFlexWrap,</span>
 183     CSSPropertyFloat,
<span class="line-added"> 184     CSSPropertyFloodColor,</span>
<span class="line-added"> 185     CSSPropertyFloodOpacity,</span>
 186     CSSPropertyFontFamily,
<span class="line-added"> 187 #if ENABLE(VARIATION_FONTS)</span>
<span class="line-added"> 188     CSSPropertyFontOpticalSizing,</span>
<span class="line-added"> 189 #endif</span>
 190     CSSPropertyFontSize,
 191     CSSPropertyFontStretch,
 192     CSSPropertyFontStyle,
 193     CSSPropertyFontSynthesis,
 194     CSSPropertyFontVariant,
<span class="line-modified"> 195     CSSPropertyFontVariantAlternates,</span>
<span class="line-added"> 196     CSSPropertyFontVariantCaps,</span>
<span class="line-added"> 197     CSSPropertyFontVariantEastAsian,</span>
<span class="line-added"> 198     CSSPropertyFontVariantLigatures,</span>
<span class="line-added"> 199     CSSPropertyFontVariantNumeric,</span>
<span class="line-added"> 200     CSSPropertyFontVariantPosition,</span>
 201 #if ENABLE(VARIATION_FONTS)
<span class="line-modified"> 202     CSSPropertyFontVariationSettings,</span>
 203 #endif
<span class="line-added"> 204     CSSPropertyFontWeight,</span>
<span class="line-added"> 205     CSSPropertyGlyphOrientationHorizontal,</span>
<span class="line-added"> 206     CSSPropertyGlyphOrientationVertical,</span>
<span class="line-added"> 207     CSSPropertyGridAutoColumns,</span>
<span class="line-added"> 208     CSSPropertyGridAutoFlow,</span>
<span class="line-added"> 209     CSSPropertyGridAutoRows,</span>
<span class="line-added"> 210     CSSPropertyGridColumnEnd,</span>
<span class="line-added"> 211     CSSPropertyGridColumnStart,</span>
<span class="line-added"> 212     CSSPropertyGridRowEnd,</span>
<span class="line-added"> 213     CSSPropertyGridRowStart,</span>
<span class="line-added"> 214     CSSPropertyGridTemplateAreas,</span>
<span class="line-added"> 215     CSSPropertyGridTemplateColumns,</span>
<span class="line-added"> 216     CSSPropertyGridTemplateRows,</span>
 217     CSSPropertyHangingPunctuation,
 218     CSSPropertyHeight,
 219 #if ENABLE(CSS_IMAGE_ORIENTATION)
 220     CSSPropertyImageOrientation,
 221 #endif
 222     CSSPropertyImageRendering,
 223 #if ENABLE(CSS_IMAGE_RESOLUTION)
 224     CSSPropertyImageResolution,
 225 #endif
<span class="line-added"> 226 #if ENABLE(CSS_COMPOSITING)</span>
<span class="line-added"> 227     CSSPropertyIsolation,</span>
<span class="line-added"> 228 #endif</span>
<span class="line-added"> 229     CSSPropertyJustifyContent,</span>
<span class="line-added"> 230     CSSPropertyJustifyItems,</span>
<span class="line-added"> 231     CSSPropertyJustifySelf,</span>
<span class="line-added"> 232     CSSPropertyKerning,</span>
 233     CSSPropertyLeft,
 234     CSSPropertyLetterSpacing,
<span class="line-added"> 235     CSSPropertyLightingColor,</span>
<span class="line-added"> 236     CSSPropertyLineBreak,</span>
 237     CSSPropertyLineHeight,
 238     CSSPropertyListStyleImage,
 239     CSSPropertyListStylePosition,
 240     CSSPropertyListStyleType,
 241     CSSPropertyMarginBottom,
 242     CSSPropertyMarginLeft,
 243     CSSPropertyMarginRight,
 244     CSSPropertyMarginTop,
<span class="line-added"> 245     CSSPropertyMarkerEnd,</span>
<span class="line-added"> 246     CSSPropertyMarkerMid,</span>
<span class="line-added"> 247     CSSPropertyMarkerStart,</span>
<span class="line-added"> 248     CSSPropertyMask,</span>
<span class="line-added"> 249     CSSPropertyMaskType,</span>
 250     CSSPropertyMaxHeight,
 251     CSSPropertyMaxWidth,
 252     CSSPropertyMinHeight,
 253     CSSPropertyMinWidth,
<span class="line-added"> 254 #if ENABLE(CSS_COMPOSITING)</span>
<span class="line-added"> 255     CSSPropertyMixBlendMode,</span>
<span class="line-added"> 256 #endif</span>
 257     CSSPropertyObjectFit,
 258     CSSPropertyObjectPosition,
 259     CSSPropertyOpacity,
<span class="line-added"> 260     CSSPropertyOrder,</span>
 261     CSSPropertyOrphans,
 262     CSSPropertyOutlineColor,
 263     CSSPropertyOutlineOffset,
 264     CSSPropertyOutlineStyle,
 265     CSSPropertyOutlineWidth,
 266     CSSPropertyOverflowWrap,
 267     CSSPropertyOverflowX,
 268     CSSPropertyOverflowY,
 269     CSSPropertyPaddingBottom,
 270     CSSPropertyPaddingLeft,
 271     CSSPropertyPaddingRight,
 272     CSSPropertyPaddingTop,
 273     CSSPropertyPageBreakAfter,
 274     CSSPropertyPageBreakBefore,
 275     CSSPropertyPageBreakInside,
<span class="line-added"> 276     CSSPropertyPaintOrder,</span>
<span class="line-added"> 277     CSSPropertyPerspective,</span>
<span class="line-added"> 278     CSSPropertyPerspectiveOrigin,</span>
<span class="line-added"> 279     CSSPropertyPlaceContent,</span>
<span class="line-added"> 280     CSSPropertyPlaceItems,</span>
<span class="line-added"> 281     CSSPropertyPlaceSelf,</span>
 282     CSSPropertyPointerEvents,
 283     CSSPropertyPosition,
<span class="line-added"> 284     CSSPropertyR,</span>
 285     CSSPropertyResize,
 286     CSSPropertyRight,
<span class="line-added"> 287     CSSPropertyRowGap,</span>
<span class="line-added"> 288     CSSPropertyRx,</span>
<span class="line-added"> 289     CSSPropertyRy,</span>
<span class="line-added"> 290 #if ENABLE(CSS_SCROLL_SNAP)</span>
<span class="line-added"> 291     CSSPropertyScrollPadding,</span>
<span class="line-added"> 292     CSSPropertyScrollPaddingBottom,</span>
<span class="line-added"> 293     CSSPropertyScrollPaddingLeft,</span>
<span class="line-added"> 294     CSSPropertyScrollPaddingRight,</span>
<span class="line-added"> 295     CSSPropertyScrollPaddingTop,</span>
<span class="line-added"> 296     CSSPropertyScrollSnapAlign,</span>
<span class="line-added"> 297     CSSPropertyScrollSnapMargin,</span>
<span class="line-added"> 298     CSSPropertyScrollSnapMarginBottom,</span>
<span class="line-added"> 299     CSSPropertyScrollSnapMarginLeft,</span>
<span class="line-added"> 300     CSSPropertyScrollSnapMarginRight,</span>
<span class="line-added"> 301     CSSPropertyScrollSnapMarginTop,</span>
<span class="line-added"> 302     CSSPropertyScrollSnapType,</span>
<span class="line-added"> 303 #endif</span>
<span class="line-added"> 304     CSSPropertyShapeImageThreshold,</span>
<span class="line-added"> 305     CSSPropertyShapeMargin,</span>
<span class="line-added"> 306     CSSPropertyShapeOutside,</span>
<span class="line-added"> 307     CSSPropertyShapeRendering,</span>
 308     CSSPropertySpeakAs,
<span class="line-modified"> 309     CSSPropertyStopColor,</span>
<span class="line-added"> 310     CSSPropertyStopOpacity,</span>
<span class="line-added"> 311     CSSPropertyStroke,</span>
<span class="line-added"> 312     CSSPropertyStrokeColor,</span>
<span class="line-added"> 313     CSSPropertyStrokeDasharray,</span>
<span class="line-added"> 314     CSSPropertyStrokeDashoffset,</span>
<span class="line-added"> 315     CSSPropertyStrokeLinecap,</span>
<span class="line-added"> 316     CSSPropertyStrokeLinejoin,</span>
<span class="line-added"> 317     CSSPropertyStrokeMiterlimit,</span>
<span class="line-added"> 318     CSSPropertyStrokeOpacity,</span>
<span class="line-added"> 319     CSSPropertyStrokeWidth,</span>
 320     CSSPropertyTabSize,
<span class="line-added"> 321     CSSPropertyTableLayout,</span>
 322     CSSPropertyTextAlign,
<span class="line-added"> 323     CSSPropertyTextAnchor,</span>
 324     CSSPropertyTextDecoration,






 325     CSSPropertyTextDecorationColor,
<span class="line-added"> 326     CSSPropertyTextDecorationLine,</span>
 327     CSSPropertyTextDecorationSkip,
<span class="line-modified"> 328     CSSPropertyTextDecorationStyle,</span>
 329     CSSPropertyTextIndent,
<span class="line-added"> 330     CSSPropertyTextOverflow,</span>
 331     CSSPropertyTextRendering,
 332     CSSPropertyTextShadow,

 333     CSSPropertyTextTransform,
<span class="line-added"> 334     CSSPropertyTextUnderlinePosition,</span>
 335     CSSPropertyTop,
<span class="line-added"> 336 #if ENABLE(POINTER_EVENTS)</span>
<span class="line-added"> 337     CSSPropertyTouchAction,</span>
<span class="line-added"> 338 #endif</span>
 339     CSSPropertyTransform,
 340     CSSPropertyTransformBox,
 341     CSSPropertyTransformOrigin,
 342     CSSPropertyTransformStyle,
 343     CSSPropertyTransitionDelay,
 344     CSSPropertyTransitionDuration,
 345     CSSPropertyTransitionProperty,
 346     CSSPropertyTransitionTimingFunction,
 347     CSSPropertyUnicodeBidi,
<span class="line-added"> 348     CSSPropertyVectorEffect,</span>
 349     CSSPropertyVerticalAlign,
 350     CSSPropertyVisibility,
 351     CSSPropertyWhiteSpace,
 352     CSSPropertyWidows,
 353     CSSPropertyWidth,
 354     CSSPropertyWillChange,
 355     CSSPropertyWordBreak,
 356     CSSPropertyWordSpacing,
 357     CSSPropertyWordWrap,
<span class="line-modified"> 358     CSSPropertyWritingMode,</span>
<span class="line-modified"> 359     CSSPropertyX,</span>
<span class="line-modified"> 360     CSSPropertyY,</span>











 361     CSSPropertyZIndex,
 362     CSSPropertyZoom,
<span class="line-added"> 363     CSSPropertyAppleColorFilter,</span>
 364     CSSPropertyWebkitAppearance,
<span class="line-added"> 365 #if ENABLE(FILTERS_LEVEL_2)</span>
<span class="line-added"> 366     CSSPropertyWebkitBackdropFilter,</span>
<span class="line-added"> 367 #endif</span>
 368     CSSPropertyWebkitBackfaceVisibility,
 369     CSSPropertyWebkitBackgroundClip,
 370     CSSPropertyWebkitBackgroundComposite,
 371     CSSPropertyWebkitBackgroundOrigin,
 372     CSSPropertyWebkitBackgroundSize,




 373     CSSPropertyWebkitBorderFit,
 374     CSSPropertyWebkitBorderHorizontalSpacing,
 375     CSSPropertyWebkitBorderImage,
 376     CSSPropertyWebkitBorderVerticalSpacing,
 377     CSSPropertyWebkitBoxAlign,
 378 #if ENABLE(CSS_BOX_DECORATION_BREAK)
 379     CSSPropertyWebkitBoxDecorationBreak,
 380 #endif
 381     CSSPropertyWebkitBoxDirection,
 382     CSSPropertyWebkitBoxFlex,
 383     CSSPropertyWebkitBoxFlexGroup,
 384     CSSPropertyWebkitBoxLines,
 385     CSSPropertyWebkitBoxOrdinalGroup,
 386     CSSPropertyWebkitBoxOrient,
 387     CSSPropertyWebkitBoxPack,
 388     CSSPropertyWebkitBoxReflect,
 389     CSSPropertyWebkitBoxShadow,
 390     CSSPropertyWebkitClipPath,
<span class="line-added"> 391     CSSPropertyWebkitColumnAxis,</span>
 392     CSSPropertyWebkitColumnBreakAfter,
 393     CSSPropertyWebkitColumnBreakBefore,
 394     CSSPropertyWebkitColumnBreakInside,





 395     CSSPropertyWebkitColumnProgression,





 396 #if ENABLE(CURSOR_VISIBILITY)
 397     CSSPropertyWebkitCursorVisibility,






















 398 #endif
 399     CSSPropertyWebkitFontKerning,
 400     CSSPropertyWebkitFontSmoothing,



















 401     CSSPropertyWebkitHyphenateCharacter,
 402     CSSPropertyWebkitHyphenateLimitAfter,
 403     CSSPropertyWebkitHyphenateLimitBefore,
 404     CSSPropertyWebkitHyphenateLimitLines,
 405     CSSPropertyWebkitHyphens,
 406     CSSPropertyWebkitInitialLetter,
 407     CSSPropertyWebkitLineAlign,
 408     CSSPropertyWebkitLineBoxContain,

 409     CSSPropertyWebkitLineClamp,
 410     CSSPropertyWebkitLineGrid,
 411     CSSPropertyWebkitLineSnap,
 412     CSSPropertyWebkitLocale,

 413     CSSPropertyWebkitMarginAfterCollapse,
<span class="line-added"> 414     CSSPropertyWebkitMarginBeforeCollapse,</span>
 415     CSSPropertyWebkitMarqueeDirection,
 416     CSSPropertyWebkitMarqueeIncrement,
 417     CSSPropertyWebkitMarqueeRepetition,
 418     CSSPropertyWebkitMarqueeStyle,
 419     CSSPropertyWebkitMaskBoxImage,
 420     CSSPropertyWebkitMaskBoxImageOutset,
 421     CSSPropertyWebkitMaskBoxImageRepeat,
 422     CSSPropertyWebkitMaskBoxImageSlice,
 423     CSSPropertyWebkitMaskBoxImageSource,
 424     CSSPropertyWebkitMaskBoxImageWidth,
 425     CSSPropertyWebkitMaskClip,
 426     CSSPropertyWebkitMaskComposite,
 427     CSSPropertyWebkitMaskImage,
 428     CSSPropertyWebkitMaskOrigin,
 429     CSSPropertyWebkitMaskPosition,
 430     CSSPropertyWebkitMaskRepeat,
 431     CSSPropertyWebkitMaskSize,
 432     CSSPropertyWebkitMaskSourceType,
 433     CSSPropertyWebkitNbspMode,
<span class="line-modified"> 434 #if ENABLE(OVERFLOW_SCROLLING_TOUCH)</span>

 435     CSSPropertyWebkitOverflowScrolling,
 436 #endif


 437     CSSPropertyWebkitPrintColorAdjust,
 438     CSSPropertyWebkitRtlOrdering,



 439 #if ENABLE(TOUCH_EVENTS)
 440     CSSPropertyWebkitTapHighlightColor,
<span class="line-added"> 441 #endif</span>
<span class="line-added"> 442 #if ENABLE(CSS3_TEXT)</span>
<span class="line-added"> 443     CSSPropertyWebkitTextAlignLast,</span>
 444 #endif
 445     CSSPropertyWebkitTextCombine,
 446     CSSPropertyWebkitTextDecorationsInEffect,
 447     CSSPropertyWebkitTextEmphasisColor,
 448     CSSPropertyWebkitTextEmphasisPosition,
 449     CSSPropertyWebkitTextEmphasisStyle,
 450     CSSPropertyWebkitTextFillColor,
<span class="line-added"> 451 #if ENABLE(CSS3_TEXT)</span>
<span class="line-added"> 452     CSSPropertyWebkitTextJustify,</span>
<span class="line-added"> 453 #endif</span>
 454     CSSPropertyWebkitTextOrientation,
 455     CSSPropertyWebkitTextSecurity,
 456 #if ENABLE(TEXT_AUTOSIZING)
 457     CSSPropertyWebkitTextSizeAdjust,
 458 #endif
 459     CSSPropertyWebkitTextStrokeColor,
 460     CSSPropertyWebkitTextStrokeWidth,
 461     CSSPropertyWebkitTextZoom,
<span class="line-added"> 462 #if PLATFORM(IOS_FAMILY)</span>
<span class="line-added"> 463     CSSPropertyWebkitTouchCallout,</span>
<span class="line-added"> 464 #endif</span>
 465     CSSPropertyWebkitTransformStyle,
 466     CSSPropertyWebkitUserDrag,
 467     CSSPropertyWebkitUserModify,
 468     CSSPropertyWebkitUserSelect,




















































 469 };
 470 
 471 const unsigned numComputedProperties = WTF_ARRAY_LENGTH(computedProperties);
 472 
 473 static CSSValueID valueForRepeatRule(int rule)
 474 {
 475     switch (rule) {
 476         case RepeatImageRule:
 477             return CSSValueRepeat;
 478         case RoundImageRule:
 479             return CSSValueRound;
 480         case SpaceImageRule:
 481             return CSSValueSpace;
 482         default:
 483             return CSSValueStretch;
 484     }
 485 }
 486 
 487 static Ref&lt;CSSPrimitiveValue&gt; valueForImageSliceSide(const Length&amp; length)
 488 {
</pre>
<hr />
<pre>
 763         return container.clientWidth() - (box.offsetLeft() + box.offsetWidth()) - box.marginRight();
 764     default:
 765         ASSERT_NOT_REACHED();
 766     }
 767 
 768     return 0;
 769 }
 770 
 771 static RefPtr&lt;CSSValue&gt; positionOffsetValue(const RenderStyle&amp; style, CSSPropertyID propertyID, RenderObject* renderer)
 772 {
 773     auto offset = getOffsetComputedLength(style, propertyID);
 774 
 775     // If the element is not displayed; return the &quot;computed value&quot;.
 776     if (!renderer || !renderer-&gt;isBox())
 777         return zoomAdjustedPixelValueForLength(offset, style);
 778 
 779     auto&amp; box = downcast&lt;RenderBox&gt;(*renderer);
 780     auto* containingBlock = box.containingBlock();
 781 
 782     // Resolve a &quot;computed value&quot; percentage if the element is positioned.
<span class="line-modified"> 783     if (containingBlock &amp;&amp; offset.isPercentOrCalculated() &amp;&amp; box.isPositioned()) {</span>

 784         bool isVerticalProperty;
 785         if (propertyID == CSSPropertyTop || propertyID == CSSPropertyBottom)
 786             isVerticalProperty = true;
 787         else {
 788             ASSERT(propertyID == CSSPropertyLeft || propertyID == CSSPropertyRight);
 789             isVerticalProperty = false;
 790         }
 791         LayoutUnit containingBlockSize;
<span class="line-modified"> 792         if (box.isStickilyPositioned()) {</span>
<span class="line-modified"> 793             auto&amp; enclosingClippingBox = box.enclosingClippingBoxForStickyPosition();</span>
<span class="line-modified"> 794             if (isVerticalProperty == enclosingClippingBox.isHorizontalWritingMode())</span>
<span class="line-modified"> 795                 containingBlockSize = enclosingClippingBox.contentLogicalHeight();</span>
<span class="line-added"> 796             else</span>
<span class="line-added"> 797                 containingBlockSize = enclosingClippingBox.contentLogicalWidth();</span>
 798         } else {
<span class="line-modified"> 799             if (isVerticalProperty == containingBlock-&gt;isHorizontalWritingMode()) {</span>
<span class="line-modified"> 800                 containingBlockSize = box.isOutOfFlowPositioned()</span>
<span class="line-modified"> 801                     ? box.containingBlockLogicalHeightForPositioned(*containingBlock, false)</span>
<span class="line-added"> 802                     : box.containingBlockLogicalHeightForContent(ExcludeMarginBorderPadding);</span>
<span class="line-added"> 803             } else {</span>
<span class="line-added"> 804                 containingBlockSize = box.isOutOfFlowPositioned()</span>
<span class="line-added"> 805                     ? box.containingBlockLogicalWidthForPositioned(*containingBlock, nullptr, false)</span>
<span class="line-added"> 806                     : box.containingBlockLogicalWidthForContent();</span>
<span class="line-added"> 807             }</span>
 808         }
 809         return zoomAdjustedPixelValue(floatValueForLength(offset, containingBlockSize), style);
 810     }
 811 
 812     // Return a &quot;computed value&quot; length.
 813     if (!offset.isAuto())
 814         return zoomAdjustedPixelValueForLength(offset, style);
 815 
 816     // The property won&#39;t be overconstrained if its computed value is &quot;auto&quot;, so the &quot;used value&quot; can be returned.
 817     if (box.isRelativelyPositioned())
 818         return zoomAdjustedPixelValue(getOffsetUsedStyleRelative(box, propertyID), style);
 819 
 820     if (containingBlock &amp;&amp; box.isOutOfFlowPositioned())
 821         return zoomAdjustedPixelValue(getOffsetUsedStyleOutOfFlowPositioned(*containingBlock, box, propertyID), style);
 822 
 823     return CSSValuePool::singleton().createIdentifierValue(CSSValueAuto);
 824 }
 825 
 826 Ref&lt;CSSPrimitiveValue&gt; ComputedStyleExtractor::currentColorOrValidColor(const RenderStyle* style, const Color&amp; color) const
 827 {
</pre>
<hr />
<pre>
 953     return transformValue.releaseNonNull();
 954 }
 955 
 956 static Ref&lt;CSSValue&gt; computedTransform(RenderObject* renderer, const RenderStyle&amp; style)
 957 {
 958     // Inline renderers do not support transforms.
 959     if (!renderer || is&lt;RenderInline&gt;(*renderer) || !style.hasTransform())
 960         return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
 961 
 962     FloatRect pixelSnappedRect;
 963     if (is&lt;RenderBox&gt;(*renderer))
 964         pixelSnappedRect = snapRectToDevicePixels(downcast&lt;RenderBox&gt;(*renderer).borderBoxRect(), renderer-&gt;document().deviceScaleFactor());
 965 
 966     TransformationMatrix transform;
 967     style.applyTransform(transform, pixelSnappedRect, RenderStyle::ExcludeTransformOrigin);
 968     // Note that this does not flatten to an affine transform if ENABLE(3D_TRANSFORMS) is off, by design.
 969 
 970     // FIXME: Need to print out individual functions (https://bugs.webkit.org/show_bug.cgi?id=23924)
 971     auto list = CSSValueList::createSpaceSeparated();
 972     list-&gt;append(matrixTransformValue(transform, style));
<span class="line-modified"> 973     return list;</span>
 974 }
 975 
 976 static inline Ref&lt;CSSPrimitiveValue&gt; adjustLengthForZoom(double length, const RenderStyle&amp; style, AdjustPixelValuesForComputedStyle adjust)
 977 {
 978     return adjust == AdjustPixelValues ? zoomAdjustedPixelValue(length, style) : CSSValuePool::singleton().createValue(length, CSSPrimitiveValue::CSS_PX);
 979 }
 980 
 981 static inline Ref&lt;CSSPrimitiveValue&gt; adjustLengthForZoom(const Length&amp; length, const RenderStyle&amp; style, AdjustPixelValuesForComputedStyle adjust)
 982 {
 983     return adjust == AdjustPixelValues ? zoomAdjustedPixelValue(length.value(), style) : CSSValuePool::singleton().createValue(length);
 984 }
 985 
 986 Ref&lt;CSSValue&gt; ComputedStyleExtractor::valueForShadow(const ShadowData* shadow, CSSPropertyID propertyID, const RenderStyle&amp; style, AdjustPixelValuesForComputedStyle adjust)
 987 {
 988     auto&amp; cssValuePool = CSSValuePool::singleton();
 989     if (!shadow)
 990         return cssValuePool.createIdentifierValue(CSSValueNone);
 991 
 992     auto list = CSSValueList::createCommaSeparated();
 993     for (const ShadowData* currShadowData = shadow; currShadowData; currShadowData = currShadowData-&gt;next()) {
 994         auto x = adjustLengthForZoom(currShadowData-&gt;x(), style, adjust);
 995         auto y = adjustLengthForZoom(currShadowData-&gt;y(), style, adjust);
 996         auto blur = adjustLengthForZoom(currShadowData-&gt;radius(), style, adjust);
 997         auto spread = propertyID == CSSPropertyTextShadow ? RefPtr&lt;CSSPrimitiveValue&gt;() : adjustLengthForZoom(currShadowData-&gt;spread(), style, adjust);
 998         auto style = propertyID == CSSPropertyTextShadow || currShadowData-&gt;style() == Normal ? RefPtr&lt;CSSPrimitiveValue&gt;() : cssValuePool.createIdentifierValue(CSSValueInset);
 999         auto color = cssValuePool.createColorValue(currShadowData-&gt;color());
1000         list-&gt;prepend(CSSShadowValue::create(WTFMove(x), WTFMove(y), WTFMove(blur), WTFMove(spread), WTFMove(style), WTFMove(color)));
1001     }
<span class="line-modified">1002     return list;</span>
1003 }
1004 
1005 Ref&lt;CSSValue&gt; ComputedStyleExtractor::valueForFilter(const RenderStyle&amp; style, const FilterOperations&amp; filterOperations, AdjustPixelValuesForComputedStyle adjust)
1006 {
1007     auto&amp; cssValuePool = CSSValuePool::singleton();
1008     if (filterOperations.operations().isEmpty())
1009         return cssValuePool.createIdentifierValue(CSSValueNone);
1010 
1011     auto list = CSSValueList::createSpaceSeparated();
1012 
1013     Vector&lt;RefPtr&lt;FilterOperation&gt;&gt;::const_iterator end = filterOperations.operations().end();
1014     for (Vector&lt;RefPtr&lt;FilterOperation&gt;&gt;::const_iterator it = filterOperations.operations().begin(); it != end; ++it) {
1015         FilterOperation&amp; filterOperation = **it;
1016 
1017         if (filterOperation.type() == FilterOperation::REFERENCE) {
1018             ReferenceFilterOperation&amp; referenceOperation = downcast&lt;ReferenceFilterOperation&gt;(filterOperation);
1019             list-&gt;append(cssValuePool.createValue(referenceOperation.url(), CSSPrimitiveValue::CSS_URI));
1020         } else {
1021             RefPtr&lt;CSSFunctionValue&gt; filterValue;
1022             switch (filterOperation.type()) {
</pre>
<hr />
<pre>
1068                 filterValue = CSSFunctionValue::create(CSSValueBlur);
1069                 filterValue-&gt;append(adjustLengthForZoom(downcast&lt;BlurFilterOperation&gt;(filterOperation).stdDeviation(), style, adjust));
1070                 break;
1071             }
1072             case FilterOperation::DROP_SHADOW: {
1073                 DropShadowFilterOperation&amp; dropShadowOperation = downcast&lt;DropShadowFilterOperation&gt;(filterOperation);
1074                 filterValue = CSSFunctionValue::create(CSSValueDropShadow);
1075                 // We want our computed style to look like that of a text shadow (has neither spread nor inset style).
1076                 ShadowData shadowData = ShadowData(dropShadowOperation.location(), dropShadowOperation.stdDeviation(), 0, Normal, false, dropShadowOperation.color());
1077                 filterValue-&gt;append(valueForShadow(&amp;shadowData, CSSPropertyTextShadow, style, adjust));
1078                 break;
1079             }
1080             default:
1081                 ASSERT_NOT_REACHED();
1082                 filterValue = CSSFunctionValue::create(CSSValueInvalid);
1083                 break;
1084             }
1085             list-&gt;append(filterValue.releaseNonNull());
1086         }
1087     }
<span class="line-modified">1088     return list;</span>
1089 }
1090 
1091 static Ref&lt;CSSValue&gt; specifiedValueForGridTrackBreadth(const GridLength&amp; trackBreadth, const RenderStyle&amp; style)
1092 {
1093     if (!trackBreadth.isLength())
1094         return CSSValuePool::singleton().createValue(trackBreadth.flex(), CSSPrimitiveValue::CSS_FR);
1095 
1096     const Length&amp; trackBreadthLength = trackBreadth.length();
1097     if (trackBreadthLength.isAuto())
1098         return CSSValuePool::singleton().createIdentifierValue(CSSValueAuto);
1099     return zoomAdjustedPixelValueForLength(trackBreadthLength, style);
1100 }
1101 
1102 static Ref&lt;CSSValue&gt; specifiedValueForGridTrackSize(const GridTrackSize&amp; trackSize, const RenderStyle&amp; style)
1103 {
1104     switch (trackSize.type()) {
1105     case LengthTrackSizing:
1106         return specifiedValueForGridTrackBreadth(trackSize.minTrackBreadth(), style);
1107     case FitContentTrackSizing: {
1108         auto fitContentTrackSize = CSSFunctionValue::create(CSSValueFitContent);
1109         fitContentTrackSize-&gt;append(zoomAdjustedPixelValueForLength(trackSize.fitContentTrackBreadth().length(), style));
<span class="line-modified">1110         return fitContentTrackSize;</span>
1111     }
1112     default:
1113         ASSERT(trackSize.type() == MinMaxTrackSizing);
1114         if (trackSize.minTrackBreadth().isAuto() &amp;&amp; trackSize.maxTrackBreadth().isFlex())
1115             return CSSValuePool::singleton().createValue(trackSize.maxTrackBreadth().flex(), CSSPrimitiveValue::CSS_FR);
1116 
1117         auto minMaxTrackBreadths = CSSFunctionValue::create(CSSValueMinmax);
1118         minMaxTrackBreadths-&gt;append(specifiedValueForGridTrackBreadth(trackSize.minTrackBreadth(), style));
1119         minMaxTrackBreadths-&gt;append(specifiedValueForGridTrackBreadth(trackSize.maxTrackBreadth(), style));
<span class="line-modified">1120         return minMaxTrackBreadths;</span>
1121     }
1122 }
1123 
1124 class OrderedNamedLinesCollector {
1125     WTF_MAKE_NONCOPYABLE(OrderedNamedLinesCollector);
1126 public:
1127     OrderedNamedLinesCollector(const RenderStyle&amp; style, bool isRowAxis, unsigned autoRepeatTracksCount)
1128         : m_orderedNamedGridLines(isRowAxis ? style.orderedNamedGridColumnLines() : style.orderedNamedGridRowLines())
1129         , m_orderedNamedAutoRepeatGridLines(isRowAxis ? style.autoRepeatOrderedNamedGridColumnLines() : style.autoRepeatOrderedNamedGridRowLines())
1130         , m_insertionPoint(isRowAxis ? style.gridAutoRepeatColumnsInsertionPoint() : style.gridAutoRepeatRowsInsertionPoint())
1131         , m_autoRepeatTotalTracks(autoRepeatTracksCount)
1132         , m_autoRepeatTrackListLength(isRowAxis ? style.gridAutoRepeatColumns().size() : style.gridAutoRepeatRows().size())
1133     {
1134     }
1135 
1136     bool isEmpty() const { return m_orderedNamedGridLines.isEmpty() &amp;&amp; m_orderedNamedAutoRepeatGridLines.isEmpty(); }
1137     void collectLineNamesForIndex(CSSGridLineNamesValue&amp;, unsigned index) const;
1138 
1139 private:
1140 
</pre>
<hr />
<pre>
1241     if (isRenderGrid) {
1242         auto computedTrackSizes = downcast&lt;RenderGrid&gt;(*renderer).trackSizesForComputedStyle(direction);
1243         unsigned numTracks = computedTrackSizes.size();
1244 
1245         for (unsigned i = 0; i &lt; numTracks; ++i) {
1246             addValuesForNamedGridLinesAtIndex(collector, i, list.get());
1247             list-&gt;append(zoomAdjustedPixelValue(computedTrackSizes[i], style));
1248         }
1249         addValuesForNamedGridLinesAtIndex(collector, numTracks + 1, list.get());
1250         insertionIndex = numTracks;
1251     } else {
1252         for (unsigned i = 0; i &lt; trackSizes.size(); ++i) {
1253             addValuesForNamedGridLinesAtIndex(collector, i, list.get());
1254             list-&gt;append(specifiedValueForGridTrackSize(trackSizes[i], style));
1255         }
1256         insertionIndex = trackSizes.size();
1257     }
1258 
1259     // Those are the trailing &lt;ident&gt;* allowed in the syntax.
1260     addValuesForNamedGridLinesAtIndex(collector, insertionIndex, list.get());
<span class="line-modified">1261     return list;</span>
1262 }
1263 
1264 static Ref&lt;CSSValue&gt; valueForGridPosition(const GridPosition&amp; position)
1265 {
1266     auto&amp; cssValuePool = CSSValuePool::singleton();
1267     if (position.isAuto())
1268         return cssValuePool.createIdentifierValue(CSSValueAuto);
1269 
1270     if (position.isNamedGridArea())
1271         return cssValuePool.createValue(position.namedGridLine(), CSSPrimitiveValue::CSS_STRING);
1272 
1273     auto list = CSSValueList::createSpaceSeparated();
1274     if (position.isSpan()) {
1275         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueSpan));
1276         list-&gt;append(cssValuePool.createValue(position.spanPosition(), CSSPrimitiveValue::CSS_NUMBER));
1277     } else
1278         list-&gt;append(cssValuePool.createValue(position.integerPosition(), CSSPrimitiveValue::CSS_NUMBER));
1279 
1280     if (!position.namedGridLine().isNull())
1281         list-&gt;append(cssValuePool.createValue(position.namedGridLine(), CSSPrimitiveValue::CSS_STRING));
<span class="line-modified">1282     return list;</span>
1283 }
1284 
1285 static Ref&lt;CSSValue&gt; createTransitionPropertyValue(const Animation&amp; animation)
1286 {
1287     switch (animation.animationMode()) {
1288     case Animation::AnimateNone:
1289         return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
1290     case Animation::AnimateAll:
1291         return CSSValuePool::singleton().createIdentifierValue(CSSValueAll);
1292     case Animation::AnimateSingleProperty:
1293         return CSSValuePool::singleton().createValue(getPropertyNameString(animation.property()), CSSPrimitiveValue::CSS_STRING);
1294     case Animation::AnimateUnknownProperty:
1295         return CSSValuePool::singleton().createValue(animation.unknownProperty(), CSSPrimitiveValue::CSS_STRING);
1296     }
1297     ASSERT_NOT_REACHED();
1298     return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
1299 }
1300 
1301 static Ref&lt;CSSValueList&gt; transitionPropertyValue(const AnimationList* animationList)
1302 {
</pre>
<hr />
<pre>
1341 
1342     auto list = CSSValueList::createCommaSeparated();
1343     for (size_t i = 0; i &lt; willChangeData-&gt;numFeatures(); ++i) {
1344         WillChangeData::FeaturePropertyPair feature = willChangeData-&gt;featureAt(i);
1345         switch (feature.first) {
1346         case WillChangeData::ScrollPosition:
1347             list-&gt;append(cssValuePool.createIdentifierValue(CSSValueScrollPosition));
1348             break;
1349         case WillChangeData::Contents:
1350             list-&gt;append(cssValuePool.createIdentifierValue(CSSValueContents));
1351             break;
1352         case WillChangeData::Property:
1353             list-&gt;append(cssValuePool.createIdentifierValue(feature.second));
1354             break;
1355         case WillChangeData::Invalid:
1356             ASSERT_NOT_REACHED();
1357             break;
1358         }
1359     }
1360 
<span class="line-modified">1361     return list;</span>
1362 }
1363 
1364 static inline void appendLigaturesValue(CSSValueList&amp; list, FontVariantLigatures value, CSSValueID yesValue, CSSValueID noValue)
1365 {
1366     switch (value) {
1367     case FontVariantLigatures::Normal:
1368         return;
1369     case FontVariantLigatures::No:
1370         list.append(CSSValuePool::singleton().createIdentifierValue(noValue));
1371         return;
1372     case FontVariantLigatures::Yes:
1373         list.append(CSSValuePool::singleton().createIdentifierValue(yesValue));
1374         return;
1375     }
1376     ASSERT_NOT_REACHED();
1377 }
1378 
1379 static Ref&lt;CSSValue&gt; fontVariantLigaturesPropertyValue(FontVariantLigatures common, FontVariantLigatures discretionary, FontVariantLigatures historical, FontVariantLigatures contextualAlternates)
1380 {
1381     auto&amp; cssValuePool = CSSValuePool::singleton();
1382     if (common == FontVariantLigatures::No &amp;&amp; discretionary == FontVariantLigatures::No &amp;&amp; historical == FontVariantLigatures::No &amp;&amp; contextualAlternates == FontVariantLigatures::No)
1383         return cssValuePool.createIdentifierValue(CSSValueNone);
1384     if (common == FontVariantLigatures::Normal &amp;&amp; discretionary == FontVariantLigatures::Normal &amp;&amp; historical == FontVariantLigatures::Normal &amp;&amp; contextualAlternates == FontVariantLigatures::Normal)
1385         return cssValuePool.createIdentifierValue(CSSValueNormal);
1386 
1387     auto valueList = CSSValueList::createSpaceSeparated();
1388     appendLigaturesValue(valueList, common, CSSValueCommonLigatures, CSSValueNoCommonLigatures);
1389     appendLigaturesValue(valueList, discretionary, CSSValueDiscretionaryLigatures, CSSValueNoDiscretionaryLigatures);
1390     appendLigaturesValue(valueList, historical, CSSValueHistoricalLigatures, CSSValueNoHistoricalLigatures);
1391     appendLigaturesValue(valueList, contextualAlternates, CSSValueContextual, CSSValueNoContextual);
<span class="line-modified">1392     return valueList;</span>
1393 }
1394 
1395 static Ref&lt;CSSValue&gt; fontVariantPositionPropertyValue(FontVariantPosition position)
1396 {
1397     auto&amp; cssValuePool = CSSValuePool::singleton();
1398     CSSValueID valueID = CSSValueNormal;
1399     switch (position) {
1400     case FontVariantPosition::Normal:
1401         break;
1402     case FontVariantPosition::Subscript:
1403         valueID = CSSValueSub;
1404         break;
1405     case FontVariantPosition::Superscript:
1406         valueID = CSSValueSuper;
1407         break;
1408     }
1409     return cssValuePool.createIdentifierValue(valueID);
1410 }
1411 
1412 static Ref&lt;CSSValue&gt; fontVariantCapsPropertyValue(FontVariantCaps caps)
</pre>
<hr />
<pre>
1466         valueList-&gt;append(cssValuePool.createIdentifierValue(CSSValueTabularNums));
1467         break;
1468     }
1469 
1470     switch (fraction) {
1471     case FontVariantNumericFraction::Normal:
1472         break;
1473     case FontVariantNumericFraction::DiagonalFractions:
1474         valueList-&gt;append(cssValuePool.createIdentifierValue(CSSValueDiagonalFractions));
1475         break;
1476     case FontVariantNumericFraction::StackedFractions:
1477         valueList-&gt;append(cssValuePool.createIdentifierValue(CSSValueStackedFractions));
1478         break;
1479     }
1480 
1481     if (ordinal == FontVariantNumericOrdinal::Yes)
1482         valueList-&gt;append(cssValuePool.createIdentifierValue(CSSValueOrdinal));
1483     if (slashedZero == FontVariantNumericSlashedZero::Yes)
1484         valueList-&gt;append(cssValuePool.createIdentifierValue(CSSValueSlashedZero));
1485 
<span class="line-modified">1486     return valueList;</span>
1487 }
1488 
1489 static Ref&lt;CSSValue&gt; fontVariantAlternatesPropertyValue(FontVariantAlternates alternates)
1490 {
1491     auto&amp; cssValuePool = CSSValuePool::singleton();
1492     CSSValueID valueID = CSSValueNormal;
1493     switch (alternates) {
1494     case FontVariantAlternates::Normal:
1495         break;
1496     case FontVariantAlternates::HistoricalForms:
1497         valueID = CSSValueHistoricalForms;
1498         break;
1499     }
1500     return cssValuePool.createIdentifierValue(valueID);
1501 }
1502 
1503 static Ref&lt;CSSValue&gt; fontVariantEastAsianPropertyValue(FontVariantEastAsianVariant variant, FontVariantEastAsianWidth width, FontVariantEastAsianRuby ruby)
1504 {
1505     auto&amp; cssValuePool = CSSValuePool::singleton();
1506     if (variant == FontVariantEastAsianVariant::Normal &amp;&amp; width == FontVariantEastAsianWidth::Normal &amp;&amp; ruby == FontVariantEastAsianRuby::Normal)
</pre>
<hr />
<pre>
1527         break;
1528     case FontVariantEastAsianVariant::Traditional:
1529         valueList-&gt;append(cssValuePool.createIdentifierValue(CSSValueTraditional));
1530         break;
1531     }
1532 
1533     switch (width) {
1534     case FontVariantEastAsianWidth::Normal:
1535         break;
1536     case FontVariantEastAsianWidth::Full:
1537         valueList-&gt;append(cssValuePool.createIdentifierValue(CSSValueFullWidth));
1538         break;
1539     case FontVariantEastAsianWidth::Proportional:
1540         valueList-&gt;append(cssValuePool.createIdentifierValue(CSSValueProportionalWidth));
1541         break;
1542     }
1543 
1544     if (ruby == FontVariantEastAsianRuby::Yes)
1545         valueList-&gt;append(cssValuePool.createIdentifierValue(CSSValueRuby));
1546 
<span class="line-modified">1547     return valueList;</span>
1548 }
1549 
1550 static Ref&lt;CSSValueList&gt; delayValue(const AnimationList* animationList)
1551 {
1552     auto&amp; cssValuePool = CSSValuePool::singleton();
1553     auto list = CSSValueList::createCommaSeparated();
1554     if (animationList) {
1555         for (size_t i = 0; i &lt; animationList-&gt;size(); ++i)
1556             list-&gt;append(cssValuePool.createValue(animationList-&gt;animation(i).delay(), CSSPrimitiveValue::CSS_S));
1557     } else {
1558         // Note that initialAnimationDelay() is used for both transitions and animations
1559         list-&gt;append(cssValuePool.createValue(Animation::initialDelay(), CSSPrimitiveValue::CSS_S));
1560     }
1561     return list;
1562 }
1563 
1564 static Ref&lt;CSSValueList&gt; durationValue(const AnimationList* animationList)
1565 {
1566     auto&amp; cssValuePool = CSSValuePool::singleton();
1567     auto list = CSSValueList::createCommaSeparated();
</pre>
<hr />
<pre>
1640         return nullptr;
1641     if (is&lt;Element&gt;(*node))
1642         return downcast&lt;Element&gt;(node);
1643     return composedTreeAncestors(*node).first();
1644 }
1645 
1646 ComputedStyleExtractor::ComputedStyleExtractor(Node* node, bool allowVisitedStyle, PseudoId pseudoElementSpecifier)
1647     : m_element(styleElementForNode(node))
1648     , m_pseudoElementSpecifier(pseudoElementSpecifier)
1649     , m_allowVisitedStyle(allowVisitedStyle)
1650 {
1651 }
1652 
1653 ComputedStyleExtractor::ComputedStyleExtractor(Element* element, bool allowVisitedStyle, PseudoId pseudoElementSpecifier)
1654     : m_element(element)
1655     , m_pseudoElementSpecifier(pseudoElementSpecifier)
1656     , m_allowVisitedStyle(allowVisitedStyle)
1657 {
1658 }
1659 
<span class="line-modified">1660 CSSComputedStyleDeclaration::CSSComputedStyleDeclaration(Element&amp; element, bool allowVisitedStyle, StringView pseudoElementName)</span>
1661     : m_element(element)
1662     , m_allowVisitedStyle(allowVisitedStyle)

1663 {
<span class="line-modified">1664     StringView name = pseudoElementName;</span>
<span class="line-modified">1665     if (name.startsWith(&#39;:&#39;))</span>
<span class="line-modified">1666         name = name.substring(1);</span>
<span class="line-added">1667     if (name.startsWith(&#39;:&#39;))</span>
<span class="line-added">1668         name = name.substring(1);</span>
<span class="line-added">1669     m_pseudoElementSpecifier = CSSSelector::pseudoId(CSSSelector::parsePseudoElementType(name));</span>
1670 }
1671 
1672 CSSComputedStyleDeclaration::~CSSComputedStyleDeclaration() = default;
1673 
<span class="line-added">1674 Ref&lt;CSSComputedStyleDeclaration&gt; CSSComputedStyleDeclaration::create(Element&amp; element, bool allowVisitedStyle, StringView pseudoElementName)</span>
<span class="line-added">1675 {</span>
<span class="line-added">1676     return adoptRef(*new CSSComputedStyleDeclaration(element, allowVisitedStyle, pseudoElementName));</span>
<span class="line-added">1677 }</span>
<span class="line-added">1678 </span>
1679 void CSSComputedStyleDeclaration::ref()
1680 {
1681     ++m_refCount;
1682 }
1683 
1684 void CSSComputedStyleDeclaration::deref()
1685 {
1686     ASSERT(m_refCount);
1687     if (!--m_refCount)
1688         delete this;
1689 }
1690 
1691 String CSSComputedStyleDeclaration::cssText() const
1692 {
1693     StringBuilder result;

1694     for (unsigned i = 0; i &lt; numComputedProperties; i++) {
1695         if (i)
1696             result.append(&#39; &#39;);
<span class="line-modified">1697         result.append(getPropertyName(computedProperties[i]), &quot;: &quot;, getPropertyValue(computedProperties[i]), &#39;;&#39;);</span>



1698     }

1699     return result.toString();
1700 }
1701 
1702 ExceptionOr&lt;void&gt; CSSComputedStyleDeclaration::setCssText(const String&amp;)
1703 {
1704     return Exception { NoModificationAllowedError };
1705 }
1706 
1707 RefPtr&lt;CSSPrimitiveValue&gt; ComputedStyleExtractor::getFontSizeCSSValuePreferringKeyword()
1708 {
1709     if (!m_element)
1710         return nullptr;
1711 
1712     m_element-&gt;document().updateLayoutIgnorePendingStylesheets();
1713 
1714     auto* style = m_element-&gt;computedStyle(m_pseudoElementSpecifier);
1715     if (!style)
1716         return nullptr;
1717 
1718     if (CSSValueID sizeIdentifier = style-&gt;fontDescription().keywordSizeAsIdentifier())
1719         return CSSValuePool::singleton().createIdentifierValue(sizeIdentifier);
1720 
1721     return zoomAdjustedPixelValue(style-&gt;fontDescription().computedSize(), *style);
1722 }
1723 
1724 bool ComputedStyleExtractor::useFixedFontDefaultSize()
1725 {
1726     if (!m_element)
1727         return false;
1728     auto* style = m_element-&gt;computedStyle(m_pseudoElementSpecifier);
1729     if (!style)
1730         return false;
1731 
1732     return style-&gt;fontDescription().useFixedDefaultSize();
1733 }
1734 
<span class="line-modified">1735 static CSSValueID identifierForFamily(const AtomString&amp; family)</span>
1736 {
1737     if (family == cursiveFamily)
1738         return CSSValueCursive;
1739     if (family == fantasyFamily)
1740         return CSSValueFantasy;
1741     if (family == monospaceFamily)
1742         return CSSValueMonospace;
1743     if (family == pictographFamily)
1744         return CSSValueWebkitPictograph;
1745     if (family == sansSerifFamily)
1746         return CSSValueSansSerif;
1747     if (family == serifFamily)
1748         return CSSValueSerif;
1749     if (family == systemUiFamily)
1750         return CSSValueSystemUi;
1751     return CSSValueInvalid;
1752 }
1753 
<span class="line-modified">1754 static Ref&lt;CSSPrimitiveValue&gt; valueForFamily(const AtomString&amp; family)</span>
1755 {
1756     if (CSSValueID familyIdentifier = identifierForFamily(family))
1757         return CSSValuePool::singleton().createIdentifierValue(familyIdentifier);
1758     return CSSValuePool::singleton().createFontFamilyValue(family);
1759 }
1760 
1761 #if ENABLE(POINTER_EVENTS)
1762 static Ref&lt;CSSValue&gt; touchActionFlagsToCSSValue(OptionSet&lt;TouchAction&gt; touchActions)
1763 {
1764     auto&amp; cssValuePool = CSSValuePool::singleton();
1765 
1766     if (touchActions &amp; TouchAction::Auto)
1767         return cssValuePool.createIdentifierValue(CSSValueAuto);
1768     if (touchActions &amp; TouchAction::None)
1769         return cssValuePool.createIdentifierValue(CSSValueNone);
1770     if (touchActions &amp; TouchAction::Manipulation)
1771         return cssValuePool.createIdentifierValue(CSSValueManipulation);
1772 
1773     auto list = CSSValueList::createSpaceSeparated();
1774     if (touchActions &amp; TouchAction::PanX)
1775         list-&gt;append(cssValuePool.createIdentifierValue(CSSValuePanX));
1776     if (touchActions &amp; TouchAction::PanY)
1777         list-&gt;append(cssValuePool.createIdentifierValue(CSSValuePanY));
1778     if (touchActions &amp; TouchAction::PinchZoom)
1779         list-&gt;append(cssValuePool.createIdentifierValue(CSSValuePinchZoom));
1780 
1781     if (!list-&gt;length())
1782         return cssValuePool.createIdentifierValue(CSSValueAuto);
<span class="line-modified">1783     return list;</span>
1784 }
1785 #endif
1786 
1787 static Ref&lt;CSSValue&gt; renderTextDecorationFlagsToCSSValue(OptionSet&lt;TextDecoration&gt; textDecoration)
1788 {
1789     auto&amp; cssValuePool = CSSValuePool::singleton();
1790     // Blink value is ignored.
1791     auto list = CSSValueList::createSpaceSeparated();
1792     if (textDecoration &amp; TextDecoration::Underline)
1793         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueUnderline));
1794     if (textDecoration &amp; TextDecoration::Overline)
1795         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueOverline));
1796     if (textDecoration &amp; TextDecoration::LineThrough)
1797         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueLineThrough));
1798 #if ENABLE(LETTERPRESS)
1799     if (textDecoration &amp; TextDecoration::Letterpress)
1800         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueWebkitLetterpress));
1801 #endif
1802 
1803     if (!list-&gt;length())
1804         return cssValuePool.createIdentifierValue(CSSValueNone);
<span class="line-modified">1805     return list;</span>
1806 }
1807 
1808 static Ref&lt;CSSValue&gt; renderTextDecorationStyleFlagsToCSSValue(TextDecorationStyle textDecorationStyle)
1809 {
1810     switch (textDecorationStyle) {
1811     case TextDecorationStyle::Solid:
1812         return CSSValuePool::singleton().createIdentifierValue(CSSValueSolid);
1813     case TextDecorationStyle::Double:
1814         return CSSValuePool::singleton().createIdentifierValue(CSSValueDouble);
1815     case TextDecorationStyle::Dotted:
1816         return CSSValuePool::singleton().createIdentifierValue(CSSValueDotted);
1817     case TextDecorationStyle::Dashed:
1818         return CSSValuePool::singleton().createIdentifierValue(CSSValueDashed);
1819     case TextDecorationStyle::Wavy:
1820         return CSSValuePool::singleton().createIdentifierValue(CSSValueWavy);
1821     }
1822 
1823     ASSERT_NOT_REACHED();
1824     return CSSValuePool::singleton().createExplicitInitialValue();
1825 }
</pre>
<hr />
<pre>
1859     ASSERT(textDecorationThickness.isLength());
1860     return CSSValuePool::singleton().createValue(textDecorationThickness.lengthValue(), CSSPrimitiveValue::CSS_PX);
1861 }
1862 
1863 static Ref&lt;CSSValue&gt; renderEmphasisPositionFlagsToCSSValue(OptionSet&lt;TextEmphasisPosition&gt; textEmphasisPosition)
1864 {
1865     ASSERT(!((textEmphasisPosition &amp; TextEmphasisPosition::Over) &amp;&amp; (textEmphasisPosition &amp; TextEmphasisPosition::Under)));
1866     ASSERT(!((textEmphasisPosition &amp; TextEmphasisPosition::Left) &amp;&amp; (textEmphasisPosition &amp; TextEmphasisPosition::Right)));
1867     auto&amp; cssValuePool = CSSValuePool::singleton();
1868     auto list = CSSValueList::createSpaceSeparated();
1869     if (textEmphasisPosition &amp; TextEmphasisPosition::Over)
1870         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueOver));
1871     if (textEmphasisPosition &amp; TextEmphasisPosition::Under)
1872         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueUnder));
1873     if (textEmphasisPosition &amp; TextEmphasisPosition::Left)
1874         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueLeft));
1875     if (textEmphasisPosition &amp; TextEmphasisPosition::Right)
1876         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueRight));
1877     if (!list-&gt;length())
1878         return cssValuePool.createIdentifierValue(CSSValueNone);
<span class="line-modified">1879     return list;</span>
1880 }
1881 
1882 static Ref&lt;CSSValue&gt; speakAsToCSSValue(OptionSet&lt;SpeakAs&gt; speakAs)
1883 {
1884     auto&amp; cssValuePool = CSSValuePool::singleton();
1885     auto list = CSSValueList::createSpaceSeparated();
1886     if (speakAs &amp; SpeakAs::SpellOut)
1887         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueSpellOut));
1888     if (speakAs &amp; SpeakAs::Digits)
1889         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueDigits));
1890     if (speakAs &amp; SpeakAs::LiteralPunctuation)
1891         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueLiteralPunctuation));
1892     if (speakAs &amp; SpeakAs::NoPunctuation)
1893         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueNoPunctuation));
1894     if (!list-&gt;length())
1895         return cssValuePool.createIdentifierValue(CSSValueNormal);
<span class="line-modified">1896     return list;</span>
1897 }
1898 
1899 static Ref&lt;CSSValue&gt; hangingPunctuationToCSSValue(OptionSet&lt;HangingPunctuation&gt; hangingPunctuation)
1900 {
1901     auto&amp; cssValuePool = CSSValuePool::singleton();
1902     auto list = CSSValueList::createSpaceSeparated();
1903     if (hangingPunctuation &amp; HangingPunctuation::First)
1904         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueFirst));
1905     if (hangingPunctuation &amp; HangingPunctuation::AllowEnd)
1906         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueAllowEnd));
1907     if (hangingPunctuation &amp; HangingPunctuation::ForceEnd)
1908         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueForceEnd));
1909     if (hangingPunctuation &amp; HangingPunctuation::Last)
1910         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueLast));
1911     if (!list-&gt;length())
1912         return cssValuePool.createIdentifierValue(CSSValueNone);
<span class="line-modified">1913     return list;</span>
1914 }
1915 
1916 static Ref&lt;CSSValue&gt; fillRepeatToCSSValue(FillRepeat xRepeat, FillRepeat yRepeat)
1917 {
1918     // For backwards compatibility, if both values are equal, just return one of them. And
1919     // if the two values are equivalent to repeat-x or repeat-y, just return the shorthand.
1920     auto&amp; cssValuePool = CSSValuePool::singleton();
1921     if (xRepeat == yRepeat)
1922         return cssValuePool.createValue(xRepeat);
1923     if (xRepeat == FillRepeat::Repeat &amp;&amp; yRepeat == FillRepeat::NoRepeat)
1924         return cssValuePool.createIdentifierValue(CSSValueRepeatX);
1925     if (xRepeat == FillRepeat::NoRepeat &amp;&amp; yRepeat == FillRepeat::Repeat)
1926         return cssValuePool.createIdentifierValue(CSSValueRepeatY);
1927 
1928     auto list = CSSValueList::createSpaceSeparated();
1929     list-&gt;append(cssValuePool.createValue(xRepeat));
1930     list-&gt;append(cssValuePool.createValue(yRepeat));
<span class="line-modified">1931     return list;</span>
1932 }
1933 
1934 static Ref&lt;CSSValue&gt; fillSourceTypeToCSSValue(MaskSourceType type)
1935 {
1936     switch (type) {
1937     case MaskSourceType::Alpha:
1938         return CSSValuePool::singleton().createValue(CSSValueAlpha);
1939     default:
1940         ASSERT(type == MaskSourceType::Luminance);
1941         return CSSValuePool::singleton().createValue(CSSValueLuminance);
1942     }
1943 }
1944 
1945 static Ref&lt;CSSValue&gt; fillSizeToCSSValue(const FillSize&amp; fillSize, const RenderStyle&amp; style)
1946 {
1947     if (fillSize.type == FillSizeType::Contain)
1948         return CSSValuePool::singleton().createIdentifierValue(CSSValueContain);
1949 
1950     if (fillSize.type == FillSizeType::Cover)
1951         return CSSValuePool::singleton().createIdentifierValue(CSSValueCover);
1952 
1953     if (fillSize.size.height.isAuto())
1954         return zoomAdjustedPixelValueForLength(fillSize.size.width, style);
1955 
1956     auto list = CSSValueList::createSpaceSeparated();
1957     list-&gt;append(zoomAdjustedPixelValueForLength(fillSize.size.width, style));
1958     list-&gt;append(zoomAdjustedPixelValueForLength(fillSize.size.height, style));
<span class="line-modified">1959     return list;</span>
1960 }
1961 
1962 static Ref&lt;CSSValue&gt; altTextToCSSValue(const RenderStyle&amp; style)
1963 {
1964     return CSSValuePool::singleton().createValue(style.contentAltText(), CSSPrimitiveValue::CSS_STRING);
1965 }
1966 
1967 static Ref&lt;CSSValueList&gt; contentToCSSValue(const RenderStyle&amp; style)
1968 {
1969     auto&amp; cssValuePool = CSSValuePool::singleton();
1970     auto list = CSSValueList::createSpaceSeparated();
1971     for (auto* contentData = style.contentData(); contentData; contentData = contentData-&gt;next()) {
1972         if (is&lt;CounterContentData&gt;(*contentData))
1973             list-&gt;append(cssValuePool.createValue(downcast&lt;CounterContentData&gt;(*contentData).counter().identifier(), CSSPrimitiveValue::CSS_COUNTER_NAME));
1974         else if (is&lt;ImageContentData&gt;(*contentData))
1975             list-&gt;append(downcast&lt;ImageContentData&gt;(*contentData).image().cssValue());
1976         else if (is&lt;TextContentData&gt;(*contentData))
1977             list-&gt;append(cssValuePool.createValue(downcast&lt;TextContentData&gt;(*contentData).text(), CSSPrimitiveValue::CSS_STRING));
1978     }
1979     return list;
1980 }
1981 
1982 static Ref&lt;CSSValue&gt; counterToCSSValue(const RenderStyle&amp; style, CSSPropertyID propertyID)
1983 {
1984     auto* map = style.counterDirectives();
1985     if (!map)
1986         return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
1987 
1988     auto&amp; cssValuePool = CSSValuePool::singleton();
1989     auto list = CSSValueList::createSpaceSeparated();
1990     for (auto&amp; keyValue : *map) {
1991         list-&gt;append(cssValuePool.createValue(keyValue.key, CSSPrimitiveValue::CSS_STRING));
1992         double number = (propertyID == CSSPropertyCounterIncrement ? keyValue.value.incrementValue : keyValue.value.resetValue).valueOr(0);
1993         list-&gt;append(cssValuePool.createValue(number, CSSPrimitiveValue::CSS_NUMBER));
1994     }
<span class="line-modified">1995     return list;</span>
1996 }
1997 
1998 static void logUnimplementedPropertyID(CSSPropertyID propertyID)
1999 {
2000     static NeverDestroyed&lt;HashSet&lt;CSSPropertyID&gt;&gt; propertyIDSet;
2001     if (!propertyIDSet.get().add(propertyID).isNewEntry)
2002         return;
2003 
2004     LOG_ERROR(&quot;WebKit does not yet implement getComputedStyle for &#39;%s&#39;.&quot;, getPropertyName(propertyID));
2005 }
2006 
2007 static Ref&lt;CSSValueList&gt; fontFamilyListFromStyle(const RenderStyle&amp; style)
2008 {
2009     auto list = CSSValueList::createCommaSeparated();
2010     for (unsigned i = 0; i &lt; style.fontCascade().familyCount(); ++i)
2011         list-&gt;append(valueForFamily(style.fontCascade().familyAt(i)));
2012     return list;
2013 }
2014 
2015 static Ref&lt;CSSValue&gt; fontFamilyFromStyle(const RenderStyle&amp; style)
</pre>
<hr />
<pre>
2257 
2258     switch (style.fontDescription().variantEastAsianWidth()) {
2259     case FontVariantEastAsianWidth::Normal:
2260         break;
2261     case FontVariantEastAsianWidth::Full:
2262         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueFullWidth));
2263         break;
2264     case FontVariantEastAsianWidth::Proportional:
2265         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueProportionalWidth));
2266         break;
2267     }
2268 
2269     switch (style.fontDescription().variantEastAsianRuby()) {
2270     case FontVariantEastAsianRuby::Normal:
2271         break;
2272     case FontVariantEastAsianRuby::Yes:
2273         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueRuby));
2274         break;
2275     }
2276 
<span class="line-modified">2277     return list;</span>
2278 }
2279 
2280 static Ref&lt;CSSValue&gt; fontSynthesisFromStyle(const RenderStyle&amp; style)
2281 {
2282     if (style.fontDescription().fontSynthesis() == FontSynthesisNone)
2283         return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
2284 
2285     auto list = CSSValueList::createSpaceSeparated();
2286     if (style.fontDescription().fontSynthesis() &amp; FontSynthesisStyle)
2287         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueStyle));
2288     if (style.fontDescription().fontSynthesis() &amp; FontSynthesisWeight)
2289         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueWeight));
2290     if (style.fontDescription().fontSynthesis() &amp; FontSynthesisSmallCaps)
2291         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueSmallCaps));
<span class="line-modified">2292     return list;</span>
2293 }
2294 
2295 typedef const Length&amp; (RenderStyle::*RenderStyleLengthGetter)() const;
2296 typedef LayoutUnit (RenderBoxModelObject::*RenderBoxComputedCSSValueGetter)() const;
2297 
2298 template&lt;RenderStyleLengthGetter lengthGetter, RenderBoxComputedCSSValueGetter computedCSSValueGetter&gt;
2299 static RefPtr&lt;CSSValue&gt; zoomAdjustedPaddingOrMarginPixelValue(const RenderStyle&amp; style, RenderObject* renderer)
2300 {
2301     Length unzoomzedLength = (style.*lengthGetter)();
2302     if (!is&lt;RenderBox&gt;(renderer) || unzoomzedLength.isFixed())
2303         return zoomAdjustedPixelValueForLength(unzoomzedLength, style);
2304     return zoomAdjustedPixelValue((downcast&lt;RenderBox&gt;(*renderer).*computedCSSValueGetter)(), style);
2305 }
2306 
2307 template&lt;RenderStyleLengthGetter lengthGetter&gt;
2308 static bool paddingOrMarginIsRendererDependent(const RenderStyle* style, RenderObject* renderer)
2309 {
2310     return renderer &amp;&amp; style &amp;&amp; renderer-&gt;isBox() &amp;&amp; !(style-&gt;*lengthGetter)().isFixed();
2311 }
2312 
</pre>
<hr />
<pre>
2541 static Ref&lt;CSSValue&gt; shapePropertyValue(const RenderStyle&amp; style, const ShapeValue* shapeValue)
2542 {
2543     if (!shapeValue)
2544         return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
2545 
2546     if (shapeValue-&gt;type() == ShapeValue::Type::Box)
2547         return CSSValuePool::singleton().createValue(shapeValue-&gt;cssBox());
2548 
2549     if (shapeValue-&gt;type() == ShapeValue::Type::Image) {
2550         if (shapeValue-&gt;image())
2551             return shapeValue-&gt;image()-&gt;cssValue();
2552         return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
2553     }
2554 
2555     ASSERT(shapeValue-&gt;type() == ShapeValue::Type::Shape);
2556 
2557     auto list = CSSValueList::createSpaceSeparated();
2558     list-&gt;append(valueForBasicShape(style, *shapeValue-&gt;shape()));
2559     if (shapeValue-&gt;cssBox() != CSSBoxType::BoxMissing)
2560         list-&gt;append(CSSValuePool::singleton().createValue(shapeValue-&gt;cssBox()));
<span class="line-modified">2561     return list;</span>
2562 }
2563 
2564 static Ref&lt;CSSValueList&gt; valueForItemPositionWithOverflowAlignment(const StyleSelfAlignmentData&amp; data)
2565 {
2566     auto&amp; cssValuePool = CSSValuePool::singleton();
2567     auto result = CSSValueList::createSpaceSeparated();
2568     if (data.positionType() == ItemPositionType::Legacy)
2569         result-&gt;append(cssValuePool.createIdentifierValue(CSSValueLegacy));
2570     if (data.position() == ItemPosition::Baseline)
2571         result-&gt;append(cssValuePool.createIdentifierValue(CSSValueBaseline));
2572     else if (data.position() == ItemPosition::LastBaseline) {
2573         result-&gt;append(cssValuePool.createIdentifierValue(CSSValueLast));
2574         result-&gt;append(cssValuePool.createIdentifierValue(CSSValueBaseline));
2575     } else {
2576         if (data.position() &gt;= ItemPosition::Center &amp;&amp; data.overflow() != OverflowAlignment::Default)
2577             result-&gt;append(cssValuePool.createValue(data.overflow()));
2578         if (data.position() == ItemPosition::Legacy)
2579             result-&gt;append(cssValuePool.createIdentifierValue(CSSValueNormal));
2580         else
2581             result-&gt;append(cssValuePool.createValue(data.position()));
</pre>
<hr />
<pre>
2630         break;
2631     case PaintOrder::FillMarkers:
2632         paintOrderList-&gt;append(CSSPrimitiveValue::createIdentifier(CSSValueFill));
2633         paintOrderList-&gt;append(CSSPrimitiveValue::createIdentifier(CSSValueMarkers));
2634         break;
2635     case PaintOrder::Stroke:
2636         paintOrderList-&gt;append(CSSPrimitiveValue::createIdentifier(CSSValueStroke));
2637         break;
2638     case PaintOrder::StrokeMarkers:
2639         paintOrderList-&gt;append(CSSPrimitiveValue::createIdentifier(CSSValueStroke));
2640         paintOrderList-&gt;append(CSSPrimitiveValue::createIdentifier(CSSValueMarkers));
2641         break;
2642     case PaintOrder::Markers:
2643         paintOrderList-&gt;append(CSSPrimitiveValue::createIdentifier(CSSValueMarkers));
2644         break;
2645     case PaintOrder::MarkersStroke:
2646         paintOrderList-&gt;append(CSSPrimitiveValue::createIdentifier(CSSValueMarkers));
2647         paintOrderList-&gt;append(CSSPrimitiveValue::createIdentifier(CSSValueStroke));
2648         break;
2649     }
<span class="line-modified">2650     return paintOrderList;</span>
2651 }
2652 
2653 inline static bool isFlexOrGrid(ContainerNode* element)
2654 {
2655     return element &amp;&amp; element-&gt;computedStyle() &amp;&amp; element-&gt;computedStyle()-&gt;isDisplayFlexibleOrGridBox();
2656 }
2657 
2658 RefPtr&lt;CSSValue&gt; ComputedStyleExtractor::customPropertyValue(const String&amp; propertyName)
2659 {
2660     Element* styledElement = this-&gt;styledElement();
2661     if (!styledElement)
2662         return nullptr;
2663 
2664     if (updateStyleIfNeededForProperty(*styledElement, CSSPropertyCustom)) {
2665         // Style update may change styledElement() to PseudoElement or back.
2666         styledElement = this-&gt;styledElement();
2667     }
2668 
2669     std::unique_ptr&lt;RenderStyle&gt; ownedStyle;
2670     auto* style = computeRenderStyleForProperty(*styledElement, m_pseudoElementSpecifier, CSSPropertyCustom, ownedStyle);
</pre>
<hr />
<pre>
2759 
2760         // FIXME: Some of these cases could be narrowed down or optimized better.
2761         forceFullLayout = isLayoutDependent(propertyID, style, renderer)
2762             || styledElement-&gt;isInShadowTree()
2763             || (document.styleScope().resolverIfExists() &amp;&amp; document.styleScope().resolverIfExists()-&gt;hasViewportDependentMediaQueries() &amp;&amp; document.ownerElement());
2764 
2765         if (forceFullLayout) {
2766             document.updateLayoutIgnorePendingStylesheets();
2767             styledElement = this-&gt;styledElement();
2768         }
2769     }
2770 
2771     if (!updateLayout || forceFullLayout) {
2772         style = computeRenderStyleForProperty(*styledElement, m_pseudoElementSpecifier, propertyID, ownedStyle);
2773         renderer = styledRenderer();
2774     }
2775 
2776     if (!style)
2777         return nullptr;
2778 
<span class="line-modified">2779     return valueForPropertyInStyle(*style, propertyID, renderer);</span>
2780 }
2781 
<span class="line-modified">2782 RefPtr&lt;CSSValue&gt; ComputedStyleExtractor::valueForPropertyInStyle(const RenderStyle&amp; style, CSSPropertyID propertyID, RenderElement* renderer)</span>
2783 {
2784     auto&amp; cssValuePool = CSSValuePool::singleton();
2785     propertyID = CSSProperty::resolveDirectionAwareProperty(propertyID, style.direction(), style.writingMode());
2786 
2787     switch (propertyID) {
2788         case CSSPropertyInvalid:
<span class="line-added">2789 #if ENABLE(TEXT_AUTOSIZING)</span>
<span class="line-added">2790         case CSSPropertyInternalTextAutosizingStatus:</span>
<span class="line-added">2791 #endif</span>
2792             break;
2793 
2794         case CSSPropertyBackgroundColor:
2795             return cssValuePool.createColorValue(m_allowVisitedStyle? style.visitedDependentColor(CSSPropertyBackgroundColor) : style.backgroundColor());
2796         case CSSPropertyBackgroundImage:
2797         case CSSPropertyWebkitMaskImage: {
2798             auto&amp; layers = propertyID == CSSPropertyWebkitMaskImage ? style.maskLayers() : style.backgroundLayers();
2799             if (!layers.next()) {
2800                 if (layers.image())
2801                     return layers.image()-&gt;cssValue();
2802                 return cssValuePool.createIdentifierValue(CSSValueNone);
2803             }
2804             auto list = CSSValueList::createCommaSeparated();
2805             for (auto* currLayer = &amp;layers; currLayer; currLayer = currLayer-&gt;next()) {
2806                 if (currLayer-&gt;image())
2807                     list-&gt;append(currLayer-&gt;image()-&gt;cssValue());
2808                 else
2809                     list-&gt;append(cssValuePool.createIdentifierValue(CSSValueNone));
2810             }
<span class="line-modified">2811             return list;</span>
2812         }
2813         case CSSPropertyBackgroundSize:
2814         case CSSPropertyWebkitBackgroundSize:
2815         case CSSPropertyWebkitMaskSize: {
2816             auto&amp; layers = propertyID == CSSPropertyWebkitMaskSize ? style.maskLayers() : style.backgroundLayers();
2817             if (!layers.next())
2818                 return fillSizeToCSSValue(layers.size(), style);
2819             auto list = CSSValueList::createCommaSeparated();
2820             for (auto* currLayer = &amp;layers; currLayer; currLayer = currLayer-&gt;next())
2821                 list-&gt;append(fillSizeToCSSValue(currLayer-&gt;size(), style));
<span class="line-modified">2822             return list;</span>
2823         }
2824         case CSSPropertyBackgroundRepeat:
2825         case CSSPropertyWebkitMaskRepeat: {
2826             auto&amp; layers = propertyID == CSSPropertyWebkitMaskRepeat ? style.maskLayers() : style.backgroundLayers();
2827             if (!layers.next())
2828                 return fillRepeatToCSSValue(layers.repeatX(), layers.repeatY());
2829             auto list = CSSValueList::createCommaSeparated();
2830             for (auto* currLayer = &amp;layers; currLayer; currLayer = currLayer-&gt;next())
2831                 list-&gt;append(fillRepeatToCSSValue(currLayer-&gt;repeatX(), currLayer-&gt;repeatY()));
<span class="line-modified">2832             return list;</span>
2833         }
2834         case CSSPropertyWebkitMaskSourceType: {
2835             auto&amp; layers = style.maskLayers();
2836             if (!layers.next())
2837                 return fillSourceTypeToCSSValue(layers.maskSourceType());
2838             auto list = CSSValueList::createCommaSeparated();
2839             for (auto* currLayer = &amp;layers; currLayer; currLayer = currLayer-&gt;next())
2840                 list-&gt;append(fillSourceTypeToCSSValue(currLayer-&gt;maskSourceType()));
<span class="line-modified">2841             return list;</span>
2842         }
2843         case CSSPropertyWebkitBackgroundComposite:
2844         case CSSPropertyWebkitMaskComposite: {
2845             auto&amp; layers = propertyID == CSSPropertyWebkitMaskComposite ? style.maskLayers() : style.backgroundLayers();
2846             if (!layers.next())
2847                 return cssValuePool.createValue(layers.composite());
2848             auto list = CSSValueList::createCommaSeparated();
2849             for (auto* currLayer = &amp;layers; currLayer; currLayer = currLayer-&gt;next())
2850                 list-&gt;append(cssValuePool.createValue(currLayer-&gt;composite()));
<span class="line-modified">2851             return list;</span>
2852         }
2853         case CSSPropertyBackgroundAttachment: {
2854             auto&amp; layers = style.backgroundLayers();
2855             if (!layers.next())
2856                 return cssValuePool.createValue(layers.attachment());
2857             auto list = CSSValueList::createCommaSeparated();
2858             for (auto* currLayer = &amp;layers; currLayer; currLayer = currLayer-&gt;next())
2859                 list-&gt;append(cssValuePool.createValue(currLayer-&gt;attachment()));
<span class="line-modified">2860             return list;</span>
2861         }
2862         case CSSPropertyBackgroundClip:
2863         case CSSPropertyBackgroundOrigin:
2864         case CSSPropertyWebkitBackgroundClip:
2865         case CSSPropertyWebkitBackgroundOrigin:
2866         case CSSPropertyWebkitMaskClip:
2867         case CSSPropertyWebkitMaskOrigin: {
2868             auto&amp; layers = (propertyID == CSSPropertyWebkitMaskClip || propertyID == CSSPropertyWebkitMaskOrigin) ? style.maskLayers() : style.backgroundLayers();
2869             bool isClip = propertyID == CSSPropertyBackgroundClip || propertyID == CSSPropertyWebkitBackgroundClip || propertyID == CSSPropertyWebkitMaskClip;
2870             if (!layers.next())
2871                 return cssValuePool.createValue(isClip ? layers.clip() : layers.origin());
2872             auto list = CSSValueList::createCommaSeparated();
2873             for (auto* currLayer = &amp;layers; currLayer; currLayer = currLayer-&gt;next())
2874                 list-&gt;append(cssValuePool.createValue(isClip ? currLayer-&gt;clip() : currLayer-&gt;origin()));
<span class="line-modified">2875             return list;</span>
2876         }
2877         case CSSPropertyBackgroundPosition:
2878         case CSSPropertyWebkitMaskPosition: {
2879             auto&amp; layers = propertyID == CSSPropertyWebkitMaskPosition ? style.maskLayers() : style.backgroundLayers();
2880             if (!layers.next())
2881                 return createPositionListForLayer(propertyID, layers, style);
2882 
2883             auto list = CSSValueList::createCommaSeparated();
2884             for (auto* currLayer = &amp;layers; currLayer; currLayer = currLayer-&gt;next())
2885                 list-&gt;append(createPositionListForLayer(propertyID, *currLayer, style));
<span class="line-modified">2886             return list;</span>
2887         }
2888         case CSSPropertyBackgroundPositionX:
2889         case CSSPropertyWebkitMaskPositionX: {
2890             auto&amp; layers = propertyID == CSSPropertyWebkitMaskPositionX ? style.maskLayers() : style.backgroundLayers();
2891             if (!layers.next())
2892                 return cssValuePool.createValue(layers.xPosition());
2893 
2894             auto list = CSSValueList::createCommaSeparated();
2895             for (auto* currLayer = &amp;layers; currLayer; currLayer = currLayer-&gt;next())
2896                 list-&gt;append(cssValuePool.createValue(currLayer-&gt;xPosition()));
2897 
<span class="line-modified">2898             return list;</span>
2899         }
2900         case CSSPropertyBackgroundPositionY:
2901         case CSSPropertyWebkitMaskPositionY: {
2902             auto&amp; layers = propertyID == CSSPropertyWebkitMaskPositionY ? style.maskLayers() : style.backgroundLayers();
2903             if (!layers.next())
2904                 return cssValuePool.createValue(layers.yPosition());
2905 
2906             auto list = CSSValueList::createCommaSeparated();
2907             for (auto* currLayer = &amp;layers; currLayer; currLayer = currLayer-&gt;next())
2908                 list-&gt;append(cssValuePool.createValue(currLayer-&gt;yPosition()));
2909 
<span class="line-modified">2910             return list;</span>
2911         }
2912         case CSSPropertyBorderCollapse:
2913             if (style.borderCollapse() == BorderCollapse::Collapse)
2914                 return cssValuePool.createIdentifierValue(CSSValueCollapse);
2915             return cssValuePool.createIdentifierValue(CSSValueSeparate);
2916         case CSSPropertyBorderSpacing: {
2917             auto list = CSSValueList::createSpaceSeparated();
2918             list-&gt;append(zoomAdjustedPixelValue(style.horizontalBorderSpacing(), style));
2919             list-&gt;append(zoomAdjustedPixelValue(style.verticalBorderSpacing(), style));
<span class="line-modified">2920             return list;</span>
2921         }
2922         case CSSPropertyWebkitBorderHorizontalSpacing:
2923             return zoomAdjustedPixelValue(style.horizontalBorderSpacing(), style);
2924         case CSSPropertyWebkitBorderVerticalSpacing:
2925             return zoomAdjustedPixelValue(style.verticalBorderSpacing(), style);
2926         case CSSPropertyBorderImageSource:
2927             if (style.borderImageSource())
2928                 return style.borderImageSource()-&gt;cssValue();
2929             return cssValuePool.createIdentifierValue(CSSValueNone);
2930         case CSSPropertyBorderTopColor:
2931             return m_allowVisitedStyle ? cssValuePool.createColorValue(style.visitedDependentColor(CSSPropertyBorderTopColor)) : currentColorOrValidColor(&amp;style, style.borderTopColor());
2932         case CSSPropertyBorderRightColor:
2933             return m_allowVisitedStyle ? cssValuePool.createColorValue(style.visitedDependentColor(CSSPropertyBorderRightColor)) : currentColorOrValidColor(&amp;style, style.borderRightColor());
2934         case CSSPropertyBorderBottomColor:
2935             return m_allowVisitedStyle ? cssValuePool.createColorValue(style.visitedDependentColor(CSSPropertyBorderBottomColor)) : currentColorOrValidColor(&amp;style, style.borderBottomColor());
2936         case CSSPropertyBorderLeftColor:
2937             return m_allowVisitedStyle ? cssValuePool.createColorValue(style.visitedDependentColor(CSSPropertyBorderLeftColor)) : currentColorOrValidColor(&amp;style, style.borderLeftColor());
2938         case CSSPropertyBorderTopStyle:
2939             return cssValuePool.createValue(style.borderTopStyle());
2940         case CSSPropertyBorderRightStyle:
</pre>
<hr />
<pre>
3010             return cssValuePool.createValue(style.columnProgression());
3011         case CSSPropertyColumnRuleColor:
3012             return m_allowVisitedStyle ? cssValuePool.createColorValue(style.visitedDependentColor(CSSPropertyOutlineColor)) : currentColorOrValidColor(&amp;style, style.columnRuleColor());
3013         case CSSPropertyColumnRuleStyle:
3014             return cssValuePool.createValue(style.columnRuleStyle());
3015         case CSSPropertyColumnRuleWidth:
3016             return zoomAdjustedPixelValue(style.columnRuleWidth(), style);
3017         case CSSPropertyColumnSpan:
3018             return cssValuePool.createIdentifierValue(style.columnSpan() == ColumnSpan::All ? CSSValueAll : CSSValueNone);
3019         case CSSPropertyWebkitColumnBreakAfter:
3020             return cssValuePool.createValue(convertToColumnBreak(style.breakAfter()));
3021         case CSSPropertyWebkitColumnBreakBefore:
3022             return cssValuePool.createValue(convertToColumnBreak(style.breakBefore()));
3023         case CSSPropertyWebkitColumnBreakInside:
3024             return cssValuePool.createValue(convertToColumnBreak(style.breakInside()));
3025         case CSSPropertyColumnWidth:
3026             if (style.hasAutoColumnWidth())
3027                 return cssValuePool.createIdentifierValue(CSSValueAuto);
3028             return zoomAdjustedPixelValue(style.columnWidth(), style);
3029         case CSSPropertyTabSize:
<span class="line-modified">3030             return cssValuePool.createValue(style.tabSize().widthInPixels(1.0), style.tabSize().isSpaces() ? CSSPrimitiveValue::CSS_NUMBER : CSSPrimitiveValue::CSS_PX);</span>
3031         case CSSPropertyCursor: {
3032             RefPtr&lt;CSSValueList&gt; list;
3033             auto* cursors = style.cursors();
3034             if (cursors &amp;&amp; cursors-&gt;size() &gt; 0) {
3035                 list = CSSValueList::createCommaSeparated();
3036                 for (unsigned i = 0; i &lt; cursors-&gt;size(); ++i)
3037                     if (StyleImage* image = cursors-&gt;at(i).image())
3038                         list-&gt;append(image-&gt;cssValue());
3039             }
3040             auto value = cssValuePool.createValue(style.cursor());
3041             if (list) {
3042                 list-&gt;append(WTFMove(value));
3043                 return list;
3044             }
<span class="line-modified">3045             return value;</span>
3046         }
3047 #if ENABLE(CURSOR_VISIBILITY)
3048         case CSSPropertyWebkitCursorVisibility:
3049             return cssValuePool.createValue(style.cursorVisibility());
3050 #endif
3051         case CSSPropertyDirection:
3052             return cssValuePool.createValue(style.direction());
3053         case CSSPropertyDisplay:
3054             return cssValuePool.createValue(style.display());
3055         case CSSPropertyEmptyCells:
3056             return cssValuePool.createValue(style.emptyCells());
3057         case CSSPropertyAlignContent:
3058             return valueForContentPositionAndDistributionWithOverflowAlignment(style.alignContent());
3059         case CSSPropertyAlignItems:
3060             return valueForItemPositionWithOverflowAlignment(style.alignItems());
3061         case CSSPropertyAlignSelf:
3062             return valueForItemPositionWithOverflowAlignment(style.alignSelf());
3063         case CSSPropertyFlex:
3064             return getCSSPropertyValuesForShorthandProperties(flexShorthand());
3065         case CSSPropertyFlexBasis:
</pre>
<hr />
<pre>
3080             return valueForItemPositionWithOverflowAlignment(style.justifyItems());
3081         case CSSPropertyJustifySelf:
3082             return valueForItemPositionWithOverflowAlignment(style.justifySelf());
3083         case CSSPropertyPlaceContent:
3084             return getCSSPropertyValuesForShorthandProperties(placeContentShorthand());
3085         case CSSPropertyPlaceItems:
3086             return getCSSPropertyValuesForShorthandProperties(placeItemsShorthand());
3087         case CSSPropertyPlaceSelf:
3088             return getCSSPropertyValuesForShorthandProperties(placeSelfShorthand());
3089         case CSSPropertyOrder:
3090             return cssValuePool.createValue(style.order(), CSSPrimitiveValue::CSS_NUMBER);
3091         case CSSPropertyFloat:
3092             if (style.display() != DisplayType::None &amp;&amp; style.hasOutOfFlowPosition())
3093                 return cssValuePool.createIdentifierValue(CSSValueNone);
3094             return cssValuePool.createValue(style.floating());
3095         case CSSPropertyFont: {
3096             auto computedFont = fontShorthandValueForSelectionProperties(style.fontDescription());
3097             computedFont-&gt;size = fontSizeFromStyle(style);
3098             computedFont-&gt;lineHeight = lineHeightFromStyle(style);
3099             computedFont-&gt;family = fontFamilyListFromStyle(style);
<span class="line-modified">3100             return computedFont;</span>
3101         }
3102         case CSSPropertyFontFamily:
3103             return fontFamilyFromStyle(style);
3104         case CSSPropertyFontSize:
3105             return fontSizeFromStyle(style);
3106         case CSSPropertyFontStyle:
3107             return fontStyleFromStyle(style);
3108         case CSSPropertyFontStretch:
3109             return fontStretchFromStyle(style);
3110         case CSSPropertyFontVariant:
3111             return fontVariantFromStyle(style);
3112         case CSSPropertyFontWeight:
3113             return fontWeightFromStyle(style);
3114         case CSSPropertyFontSynthesis:
3115             return fontSynthesisFromStyle(style);
3116         case CSSPropertyFontFeatureSettings: {
3117             const FontFeatureSettings&amp; featureSettings = style.fontDescription().featureSettings();
3118             if (!featureSettings.size())
3119                 return cssValuePool.createIdentifierValue(CSSValueNormal);
3120             auto list = CSSValueList::createCommaSeparated();
3121             for (auto&amp; feature : featureSettings)
3122                 list-&gt;append(CSSFontFeatureValue::create(FontTag(feature.tag()), feature.value()));
<span class="line-modified">3123             return list;</span>
3124         }
3125 #if ENABLE(VARIATION_FONTS)
3126         case CSSPropertyFontVariationSettings: {
3127             const FontVariationSettings&amp; variationSettings = style.fontDescription().variationSettings();
3128             if (variationSettings.isEmpty())
3129                 return cssValuePool.createIdentifierValue(CSSValueNormal);
3130             auto list = CSSValueList::createCommaSeparated();
3131             for (auto&amp; feature : variationSettings)
3132                 list-&gt;append(CSSFontVariationValue::create(feature.tag(), feature.value()));
<span class="line-modified">3133             return list;</span>
3134         }
3135         case CSSPropertyFontOpticalSizing:
3136             return cssValuePool.createValue(style.fontDescription().opticalSizing());
3137 #endif
3138         case CSSPropertyGridAutoFlow: {
3139             auto list = CSSValueList::createSpaceSeparated();
3140             ASSERT(style.isGridAutoFlowDirectionRow() || style.isGridAutoFlowDirectionColumn());
3141             if (style.isGridAutoFlowDirectionRow())
3142                 list-&gt;append(cssValuePool.createIdentifierValue(CSSValueRow));
3143             else
3144                 list-&gt;append(cssValuePool.createIdentifierValue(CSSValueColumn));
3145 
3146             if (style.isGridAutoFlowAlgorithmDense())
3147                 list-&gt;append(cssValuePool.createIdentifierValue(CSSValueDense));
3148 
<span class="line-modified">3149             return list;</span>
3150         }
3151 
3152         // Specs mention that getComputedStyle() should return the used value of the property instead of the computed
3153         // one for grid-template-{rows|columns} but not for the grid-auto-{rows|columns} as things like
3154         // grid-auto-columns: 2fr; cannot be resolved to a value in pixels as the &#39;2fr&#39; means very different things
3155         // depending on the size of the explicit grid or the number of implicit tracks added to the grid. See
3156         // http://lists.w3.org/Archives/Public/www-style/2013Nov/0014.html
3157         case CSSPropertyGridAutoColumns:
3158             return valueForGridTrackSizeList(ForColumns, style);
3159         case CSSPropertyGridAutoRows:
3160             return valueForGridTrackSizeList(ForRows, style);
3161 
3162         case CSSPropertyGridTemplateColumns:
3163             return valueForGridTrackList(ForColumns, renderer, style);
3164         case CSSPropertyGridTemplateRows:
3165             return valueForGridTrackList(ForRows, renderer, style);
3166 
3167         case CSSPropertyGridColumnStart:
3168             return valueForGridPosition(style.gridItemColumnStart());
3169         case CSSPropertyGridColumnEnd:
</pre>
<hr />
<pre>
3177         case CSSPropertyGridTemplate:
3178             return getCSSPropertyValuesForGridShorthand(gridTemplateShorthand());
3179         case CSSPropertyGrid:
3180             return getCSSPropertyValuesForGridShorthand(gridShorthand());
3181         case CSSPropertyGridColumn:
3182             return getCSSPropertyValuesForGridShorthand(gridColumnShorthand());
3183         case CSSPropertyGridRow:
3184             return getCSSPropertyValuesForGridShorthand(gridRowShorthand());
3185         case CSSPropertyGridTemplateAreas:
3186             if (!style.namedGridAreaRowCount()) {
3187                 ASSERT(!style.namedGridAreaColumnCount());
3188                 return cssValuePool.createIdentifierValue(CSSValueNone);
3189             }
3190             return CSSGridTemplateAreasValue::create(style.namedGridArea(), style.namedGridAreaRowCount(), style.namedGridAreaColumnCount());
3191         case CSSPropertyGap:
3192             return getCSSPropertyValuesForShorthandProperties(gapShorthand());
3193         case CSSPropertyHeight:
3194             if (renderer &amp;&amp; !renderer-&gt;isRenderSVGModelObject()) {
3195                 // According to http://www.w3.org/TR/CSS2/visudet.html#the-height-property,
3196                 // the &quot;height&quot; property does not apply for non-replaced inline elements.
<span class="line-modified">3197                 if (!isNonReplacedInline(*renderer))</span>
<span class="line-modified">3198                     return zoomAdjustedPixelValue(sizingBox(*renderer).height(), style);</span>

3199             }
3200             return zoomAdjustedPixelValueForLength(style.height(), style);
3201         case CSSPropertyWebkitHyphens:
3202             return cssValuePool.createValue(style.hyphens());
3203         case CSSPropertyWebkitHyphenateCharacter:
3204             if (style.hyphenationString().isNull())
3205                 return cssValuePool.createIdentifierValue(CSSValueAuto);
3206             return cssValuePool.createValue(style.hyphenationString(), CSSPrimitiveValue::CSS_STRING);
3207         case CSSPropertyWebkitHyphenateLimitAfter:
3208             if (style.hyphenationLimitAfter() &lt; 0)
3209                 return CSSPrimitiveValue::createIdentifier(CSSValueAuto);
3210             return CSSPrimitiveValue::create(style.hyphenationLimitAfter(), CSSPrimitiveValue::CSS_NUMBER);
3211         case CSSPropertyWebkitHyphenateLimitBefore:
3212             if (style.hyphenationLimitBefore() &lt; 0)
3213                 return CSSPrimitiveValue::createIdentifier(CSSValueAuto);
3214             return CSSPrimitiveValue::create(style.hyphenationLimitBefore(), CSSPrimitiveValue::CSS_NUMBER);
3215         case CSSPropertyWebkitHyphenateLimitLines:
3216             if (style.hyphenationLimitLines() &lt; 0)
3217                 return CSSPrimitiveValue::createIdentifier(CSSValueNoLimit);
3218             return CSSPrimitiveValue::create(style.hyphenationLimitLines(), CSSPrimitiveValue::CSS_NUMBER);
</pre>
<hr />
<pre>
3303                 auto* styledElement = this-&gt;styledElement();
3304                 if (styledElement &amp;&amp; isFlexOrGrid(styledElement-&gt;parentNode()))
3305                     return cssValuePool.createIdentifierValue(CSSValueAuto);
3306                 return zoomAdjustedPixelValue(0, style);
3307             }
3308             return zoomAdjustedPixelValueForLength(style.minHeight(), style);
3309         case CSSPropertyMinWidth:
3310             if (style.minWidth().isAuto()) {
3311                 auto* styledElement = this-&gt;styledElement();
3312                 if (styledElement &amp;&amp; isFlexOrGrid(styledElement-&gt;parentNode()))
3313                     return cssValuePool.createIdentifierValue(CSSValueAuto);
3314                 return zoomAdjustedPixelValue(0, style);
3315             }
3316             return zoomAdjustedPixelValueForLength(style.minWidth(), style);
3317         case CSSPropertyObjectFit:
3318             return cssValuePool.createValue(style.objectFit());
3319         case CSSPropertyObjectPosition: {
3320             auto list = CSSValueList::createSpaceSeparated();
3321             list-&gt;append(zoomAdjustedPixelValueForLength(style.objectPosition().x(), style));
3322             list-&gt;append(zoomAdjustedPixelValueForLength(style.objectPosition().y(), style));
<span class="line-modified">3323             return list;</span>
3324         }
3325         case CSSPropertyOpacity:
3326             return cssValuePool.createValue(style.opacity(), CSSPrimitiveValue::CSS_NUMBER);
3327         case CSSPropertyOrphans:
3328             if (style.hasAutoOrphans())
3329                 return cssValuePool.createIdentifierValue(CSSValueAuto);
3330             return cssValuePool.createValue(style.orphans(), CSSPrimitiveValue::CSS_NUMBER);
3331         case CSSPropertyOutlineColor:
3332             return m_allowVisitedStyle ? cssValuePool.createColorValue(style.visitedDependentColor(CSSPropertyOutlineColor)) : currentColorOrValidColor(&amp;style, style.outlineColor());
3333         case CSSPropertyOutlineOffset:
3334             return zoomAdjustedPixelValue(style.outlineOffset(), style);
3335         case CSSPropertyOutlineStyle:
3336             if (style.outlineStyleIsAuto() == OutlineIsAuto::On)
3337                 return cssValuePool.createIdentifierValue(CSSValueAuto);
3338             return cssValuePool.createValue(style.outlineStyle());
3339         case CSSPropertyOutlineWidth:
3340             return zoomAdjustedPixelValue(style.outlineWidth(), style);
3341         case CSSPropertyOverflow:
3342             return cssValuePool.createValue(std::max(style.overflowX(), style.overflowY()));
3343         case CSSPropertyOverflowWrap:
</pre>
<hr />
<pre>
3412             return renderEmphasisPositionFlagsToCSSValue(style.textEmphasisPosition());
3413         case CSSPropertyWebkitTextEmphasisStyle:
3414             switch (style.textEmphasisMark()) {
3415             case TextEmphasisMark::None:
3416                 return cssValuePool.createIdentifierValue(CSSValueNone);
3417             case TextEmphasisMark::Custom:
3418                 return cssValuePool.createValue(style.textEmphasisCustomMark(), CSSPrimitiveValue::CSS_STRING);
3419             case TextEmphasisMark::Auto:
3420                 ASSERT_NOT_REACHED();
3421 #if ASSERT_DISABLED
3422                 FALLTHROUGH;
3423 #endif
3424             case TextEmphasisMark::Dot:
3425             case TextEmphasisMark::Circle:
3426             case TextEmphasisMark::DoubleCircle:
3427             case TextEmphasisMark::Triangle:
3428             case TextEmphasisMark::Sesame:
3429                 auto list = CSSValueList::createSpaceSeparated();
3430                 list-&gt;append(cssValuePool.createValue(style.textEmphasisFill()));
3431                 list-&gt;append(cssValuePool.createValue(style.textEmphasisMark()));
<span class="line-modified">3432                 return list;</span>
3433             }
3434             RELEASE_ASSERT_NOT_REACHED();
3435         case CSSPropertyTextIndent: {
3436             // If CSS3_TEXT is disabled or text-indent has only one value(&lt;length&gt; | &lt;percentage&gt;),
3437             // getPropertyCSSValue() returns CSSValue.
3438             auto textIndent = zoomAdjustedPixelValueForLength(style.textIndent(), style);
3439 #if ENABLE(CSS3_TEXT)
3440             // If CSS3_TEXT is enabled and text-indent has -webkit-each-line or -webkit-hanging,
3441             // getPropertyCSSValue() returns CSSValueList.
3442             if (style.textIndentLine() == TextIndentLine::EachLine || style.textIndentType() == TextIndentType::Hanging) {
3443                 auto list = CSSValueList::createSpaceSeparated();
3444                 list-&gt;append(WTFMove(textIndent));
3445                 if (style.textIndentLine() == TextIndentLine::EachLine)
3446                     list-&gt;append(cssValuePool.createIdentifierValue(CSSValueWebkitEachLine));
3447                 if (style.textIndentType() == TextIndentType::Hanging)
3448                     list-&gt;append(cssValuePool.createIdentifierValue(CSSValueWebkitHanging));
<span class="line-modified">3449                 return list;</span>
3450             }
3451 #endif
<span class="line-modified">3452             return textIndent;</span>
3453         }
3454         case CSSPropertyTextShadow:
3455             return valueForShadow(style.textShadow(), propertyID, style);
3456         case CSSPropertyTextRendering:
3457             return cssValuePool.createValue(style.fontDescription().textRenderingMode());
3458         case CSSPropertyTextOverflow:
3459             if (style.textOverflow() == TextOverflow::Ellipsis)
3460                 return cssValuePool.createIdentifierValue(CSSValueEllipsis);
3461             return cssValuePool.createIdentifierValue(CSSValueClip);
3462         case CSSPropertyWebkitTextSecurity:
3463             return cssValuePool.createValue(style.textSecurity());
3464 #if ENABLE(TEXT_AUTOSIZING)
3465         case CSSPropertyWebkitTextSizeAdjust:
3466             if (style.textSizeAdjust().isAuto())
3467                 return cssValuePool.createIdentifierValue(CSSValueAuto);
3468             if (style.textSizeAdjust().isNone())
3469                 return cssValuePool.createIdentifierValue(CSSValueNone);
3470             return CSSPrimitiveValue::create(style.textSizeAdjust().percentage(), CSSPrimitiveValue::CSS_PERCENTAGE);
3471 #endif
3472         case CSSPropertyWebkitTextStrokeColor:
</pre>
<hr />
<pre>
3499                 return cssValuePool.createIdentifierValue(CSSValueBottom);
3500             case VerticalAlign::BaselineMiddle:
3501                 return cssValuePool.createIdentifierValue(CSSValueWebkitBaselineMiddle);
3502             case VerticalAlign::Length:
3503                 return cssValuePool.createValue(style.verticalAlignLength());
3504             }
3505             ASSERT_NOT_REACHED();
3506             return nullptr;
3507         case CSSPropertyVisibility:
3508             return cssValuePool.createValue(style.visibility());
3509         case CSSPropertyWhiteSpace:
3510             return cssValuePool.createValue(style.whiteSpace());
3511         case CSSPropertyWidows:
3512             if (style.hasAutoWidows())
3513                 return cssValuePool.createIdentifierValue(CSSValueAuto);
3514             return cssValuePool.createValue(style.widows(), CSSPrimitiveValue::CSS_NUMBER);
3515         case CSSPropertyWidth:
3516             if (renderer &amp;&amp; !renderer-&gt;isRenderSVGModelObject()) {
3517                 // According to http://www.w3.org/TR/CSS2/visudet.html#the-width-property,
3518                 // the &quot;width&quot; property does not apply for non-replaced inline elements.
<span class="line-modified">3519                 if (!isNonReplacedInline(*renderer))</span>
<span class="line-modified">3520                     return zoomAdjustedPixelValue(sizingBox(*renderer).width(), style);</span>

3521             }
3522             return zoomAdjustedPixelValueForLength(style.width(), style);
3523         case CSSPropertyWillChange:
3524             return willChangePropertyValue(style.willChange());
3525         case CSSPropertyWordBreak:
3526             return cssValuePool.createValue(style.wordBreak());
3527         case CSSPropertyWordSpacing:
3528             return zoomAdjustedPixelValue(style.fontCascade().wordSpacing(), style);
3529         case CSSPropertyWordWrap:
3530             return cssValuePool.createValue(style.overflowWrap());
3531         case CSSPropertyLineBreak:
3532             return cssValuePool.createValue(style.lineBreak());
3533         case CSSPropertyWebkitNbspMode:
3534             return cssValuePool.createValue(style.nbspMode());
3535         case CSSPropertyResize:
3536             return cssValuePool.createValue(style.resize());
3537         case CSSPropertyWebkitFontKerning:
3538             return cssValuePool.createValue(style.fontDescription().kerning());
3539         case CSSPropertyWebkitFontSmoothing:
3540             return cssValuePool.createValue(style.fontDescription().fontSmoothing());
</pre>
<hr />
<pre>
3543         case CSSPropertyFontVariantPosition:
3544             return fontVariantPositionPropertyValue(style.fontDescription().variantPosition());
3545         case CSSPropertyFontVariantCaps:
3546             return fontVariantCapsPropertyValue(style.fontDescription().variantCaps());
3547         case CSSPropertyFontVariantNumeric:
3548             return fontVariantNumericPropertyValue(style.fontDescription().variantNumericFigure(), style.fontDescription().variantNumericSpacing(), style.fontDescription().variantNumericFraction(), style.fontDescription().variantNumericOrdinal(), style.fontDescription().variantNumericSlashedZero());
3549         case CSSPropertyFontVariantAlternates:
3550             return fontVariantAlternatesPropertyValue(style.fontDescription().variantAlternates());
3551         case CSSPropertyFontVariantEastAsian:
3552             return fontVariantEastAsianPropertyValue(style.fontDescription().variantEastAsianVariant(), style.fontDescription().variantEastAsianWidth(), style.fontDescription().variantEastAsianRuby());
3553         case CSSPropertyZIndex:
3554             if (style.hasAutoZIndex())
3555                 return cssValuePool.createIdentifierValue(CSSValueAuto);
3556             return cssValuePool.createValue(style.zIndex(), CSSPrimitiveValue::CSS_NUMBER);
3557         case CSSPropertyZoom:
3558             return cssValuePool.createValue(style.zoom(), CSSPrimitiveValue::CSS_NUMBER);
3559         case CSSPropertyBoxSizing:
3560             if (style.boxSizing() == BoxSizing::ContentBox)
3561                 return cssValuePool.createIdentifierValue(CSSValueContentBox);
3562             return cssValuePool.createIdentifierValue(CSSValueBorderBox);
































3563         case CSSPropertyAnimationDelay:
3564             return delayValue(style.animations());
3565         case CSSPropertyAnimationDirection: {
3566             auto list = CSSValueList::createCommaSeparated();
3567             const AnimationList* t = style.animations();
3568             if (t) {
3569                 for (size_t i = 0; i &lt; t-&gt;size(); ++i) {
3570                     switch (t-&gt;animation(i).direction()) {
3571                     case Animation::AnimationDirectionNormal:
3572                         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueNormal));
3573                         break;
3574                     case Animation::AnimationDirectionAlternate:
3575                         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueAlternate));
3576                         break;
3577                     case Animation::AnimationDirectionReverse:
3578                         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueReverse));
3579                         break;
3580                     case Animation::AnimationDirectionAlternateReverse:
3581                         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueAlternateReverse));
3582                         break;
3583                     }
3584                 }
3585             } else
3586                 list-&gt;append(cssValuePool.createIdentifierValue(CSSValueNormal));
<span class="line-modified">3587             return list;</span>
3588         }
3589         case CSSPropertyAnimationDuration:
3590             return durationValue(style.animations());
3591         case CSSPropertyAnimationFillMode: {
3592             auto list = CSSValueList::createCommaSeparated();
3593             const AnimationList* t = style.animations();
3594             if (t) {
3595                 for (size_t i = 0; i &lt; t-&gt;size(); ++i) {
3596                     switch (t-&gt;animation(i).fillMode()) {
3597                     case AnimationFillMode::None:
3598                         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueNone));
3599                         break;
3600                     case AnimationFillMode::Forwards:
3601                         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueForwards));
3602                         break;
3603                     case AnimationFillMode::Backwards:
3604                         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueBackwards));
3605                         break;
3606                     case AnimationFillMode::Both:
3607                         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueBoth));
3608                         break;
3609                     }
3610                 }
3611             } else
3612                 list-&gt;append(cssValuePool.createIdentifierValue(CSSValueNone));
<span class="line-modified">3613             return list;</span>
3614         }
3615         case CSSPropertyAnimationIterationCount: {
3616             auto list = CSSValueList::createCommaSeparated();
3617             const AnimationList* t = style.animations();
3618             if (t) {
3619                 for (size_t i = 0; i &lt; t-&gt;size(); ++i) {
3620                     double iterationCount = t-&gt;animation(i).iterationCount();
3621                     if (iterationCount == Animation::IterationCountInfinite)
3622                         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueInfinite));
3623                     else
3624                         list-&gt;append(cssValuePool.createValue(iterationCount, CSSPrimitiveValue::CSS_NUMBER));
3625                 }
3626             } else
3627                 list-&gt;append(cssValuePool.createValue(Animation::initialIterationCount(), CSSPrimitiveValue::CSS_NUMBER));
<span class="line-modified">3628             return list;</span>
3629         }
3630         case CSSPropertyAnimationName: {
3631             auto list = CSSValueList::createCommaSeparated();
3632             const AnimationList* t = style.animations();
3633             if (t) {
3634                 for (size_t i = 0; i &lt; t-&gt;size(); ++i)
3635                     list-&gt;append(cssValuePool.createValue(t-&gt;animation(i).name(), CSSPrimitiveValue::CSS_STRING));
3636             } else
3637                 list-&gt;append(cssValuePool.createIdentifierValue(CSSValueNone));
<span class="line-modified">3638             return list;</span>
3639         }
3640         case CSSPropertyAnimationPlayState: {
3641             auto list = CSSValueList::createCommaSeparated();
3642             const AnimationList* t = style.animations();
3643             if (t) {
3644                 for (size_t i = 0; i &lt; t-&gt;size(); ++i) {
3645                     switch (t-&gt;animation(i).playState()) {
3646                     case AnimationPlayState::Playing:
3647                         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueRunning));
3648                         break;
3649                     case AnimationPlayState::Paused:
3650                         list-&gt;append(cssValuePool.createIdentifierValue(CSSValuePaused));
3651                         break;
3652                     }
3653                 }
3654             } else
3655                 list-&gt;append(cssValuePool.createIdentifierValue(CSSValueRunning));
<span class="line-modified">3656             return list;</span>
3657         }
3658         case CSSPropertyAnimationTimingFunction:
3659             return timingFunctionValue(style.animations());
3660         case CSSPropertyWebkitAppearance:
3661             return cssValuePool.createValue(style.appearance());
3662         case CSSPropertyWebkitAspectRatio:
3663             switch (style.aspectRatioType()) {
3664             case AspectRatioType::Auto:
3665                 return cssValuePool.createIdentifierValue(CSSValueAuto);
3666             case AspectRatioType::FromDimensions:
3667                 return cssValuePool.createIdentifierValue(CSSValueFromDimensions);
3668             case AspectRatioType::FromIntrinsic:
3669                 return cssValuePool.createIdentifierValue(CSSValueFromIntrinsic);
3670             case AspectRatioType::Specified:
3671                 return CSSAspectRatioValue::create(style.aspectRatioNumerator(), style.aspectRatioDenominator());
3672             }
3673             ASSERT_NOT_REACHED();
3674             return nullptr;
3675         case CSSPropertyWebkitBackfaceVisibility:
3676             return cssValuePool.createIdentifierValue((style.backfaceVisibility() == BackfaceVisibility::Hidden) ? CSSValueHidden : CSSValueVisible);
</pre>
<hr />
<pre>
3695         case CSSPropertyWebkitMaskBoxImageWidth:
3696             return valueForNinePieceImageQuad(style.maskBoxImage().borderSlices());
3697         case CSSPropertyWebkitMaskBoxImageSource:
3698             if (style.maskBoxImageSource())
3699                 return style.maskBoxImageSource()-&gt;cssValue();
3700             return cssValuePool.createIdentifierValue(CSSValueNone);
3701         case CSSPropertyWebkitFontSizeDelta:
3702             // Not a real style property -- used by the editing engine -- so has no computed value.
3703             break;
3704         case CSSPropertyWebkitInitialLetter: {
3705             auto drop = !style.initialLetterDrop() ? cssValuePool.createIdentifierValue(CSSValueNormal) : cssValuePool.createValue(style.initialLetterDrop(), CSSPrimitiveValue::CSS_NUMBER);
3706             auto size = !style.initialLetterHeight() ? cssValuePool.createIdentifierValue(CSSValueNormal) : cssValuePool.createValue(style.initialLetterHeight(), CSSPrimitiveValue::CSS_NUMBER);
3707             return cssValuePool.createValue(Pair::create(WTFMove(drop), WTFMove(size)));
3708         }
3709         case CSSPropertyWebkitMarginBottomCollapse:
3710         case CSSPropertyWebkitMarginAfterCollapse:
3711             return cssValuePool.createValue(style.marginAfterCollapse());
3712         case CSSPropertyWebkitMarginTopCollapse:
3713         case CSSPropertyWebkitMarginBeforeCollapse:
3714             return cssValuePool.createValue(style.marginBeforeCollapse());
<span class="line-modified">3715 #if ENABLE(OVERFLOW_SCROLLING_TOUCH)</span>
3716         case CSSPropertyWebkitOverflowScrolling:
3717             if (!style.useTouchOverflowScrolling())
3718                 return cssValuePool.createIdentifierValue(CSSValueAuto);
3719             return cssValuePool.createIdentifierValue(CSSValueTouch);
3720 #endif
3721         case CSSPropertyPerspective:
3722             if (!style.hasPerspective())
3723                 return cssValuePool.createIdentifierValue(CSSValueNone);
3724             return zoomAdjustedPixelValue(style.perspective(), style);
3725         case CSSPropertyPerspectiveOrigin: {
3726             auto list = CSSValueList::createSpaceSeparated();
3727             if (renderer) {
3728                 LayoutRect box;
3729                 if (is&lt;RenderBox&gt;(*renderer))
3730                     box = downcast&lt;RenderBox&gt;(*renderer).borderBoxRect();
3731 
3732                 list-&gt;append(zoomAdjustedPixelValue(minimumValueForLength(style.perspectiveOriginX(), box.width()), style));
3733                 list-&gt;append(zoomAdjustedPixelValue(minimumValueForLength(style.perspectiveOriginY(), box.height()), style));
3734             } else {
3735                 list-&gt;append(zoomAdjustedPixelValueForLength(style.perspectiveOriginX(), style));
3736                 list-&gt;append(zoomAdjustedPixelValueForLength(style.perspectiveOriginY(), style));
3737             }
<span class="line-modified">3738             return list;</span>
3739         }
3740         case CSSPropertyWebkitRtlOrdering:
3741             return cssValuePool.createIdentifierValue(style.rtlOrdering() == Order::Visual ? CSSValueVisual : CSSValueLogical);
3742 #if ENABLE(TOUCH_EVENTS)
3743         case CSSPropertyWebkitTapHighlightColor:
3744             return currentColorOrValidColor(&amp;style, style.tapHighlightColor());
3745 #endif
3746 #if ENABLE(POINTER_EVENTS)
3747         case CSSPropertyTouchAction:
3748             return touchActionFlagsToCSSValue(style.touchActions());
3749 #endif
3750 #if PLATFORM(IOS_FAMILY)
3751         case CSSPropertyWebkitTouchCallout:
3752             return cssValuePool.createIdentifierValue(style.touchCalloutEnabled() ? CSSValueDefault : CSSValueNone);
3753 #endif
3754         case CSSPropertyWebkitUserDrag:
3755             return cssValuePool.createValue(style.userDrag());
3756         case CSSPropertyWebkitUserSelect:
3757             return cssValuePool.createValue(style.userSelect());
3758         case CSSPropertyBorderBottomLeftRadius:
</pre>
<hr />
<pre>
3779             return computedTransform(renderer, style);
3780         case CSSPropertyTransformBox:
3781             return CSSPrimitiveValue::create(style.transformBox());
3782         case CSSPropertyTransformOrigin: {
3783             auto list = CSSValueList::createSpaceSeparated();
3784             if (renderer) {
3785                 LayoutRect box;
3786                 if (is&lt;RenderBox&gt;(*renderer))
3787                     box = downcast&lt;RenderBox&gt;(*renderer).borderBoxRect();
3788 
3789                 list-&gt;append(zoomAdjustedPixelValue(minimumValueForLength(style.transformOriginX(), box.width()), style));
3790                 list-&gt;append(zoomAdjustedPixelValue(minimumValueForLength(style.transformOriginY(), box.height()), style));
3791                 if (style.transformOriginZ())
3792                     list-&gt;append(zoomAdjustedPixelValue(style.transformOriginZ(), style));
3793             } else {
3794                 list-&gt;append(zoomAdjustedPixelValueForLength(style.transformOriginX(), style));
3795                 list-&gt;append(zoomAdjustedPixelValueForLength(style.transformOriginY(), style));
3796                 if (style.transformOriginZ())
3797                     list-&gt;append(zoomAdjustedPixelValue(style.transformOriginZ(), style));
3798             }
<span class="line-modified">3799             return list;</span>
3800         }
3801         case CSSPropertyTransformStyle:
3802         case CSSPropertyWebkitTransformStyle:
3803             return cssValuePool.createIdentifierValue((style.transformStyle3D() == TransformStyle3D::Preserve3D) ? CSSValuePreserve3d : CSSValueFlat);
3804         case CSSPropertyTransitionDelay:
3805             return delayValue(style.transitions());
3806         case CSSPropertyTransitionDuration:
3807             return durationValue(style.transitions());
3808         case CSSPropertyTransitionProperty:
3809             return transitionPropertyValue(style.transitions());
3810         case CSSPropertyTransitionTimingFunction:
3811             return timingFunctionValue(style.transitions());
3812         case CSSPropertyTransition: {
3813             if (auto* animationList = style.transitions()) {
3814                 auto transitionsList = CSSValueList::createCommaSeparated();
3815                 for (size_t i = 0; i &lt; animationList-&gt;size(); ++i) {
3816                     auto list = CSSValueList::createSpaceSeparated();
3817                     auto&amp; animation = animationList-&gt;animation(i);
3818                     list-&gt;append(createTransitionPropertyValue(animation));
3819                     list-&gt;append(cssValuePool.createValue(animation.duration(), CSSPrimitiveValue::CSS_S));
3820                     list-&gt;append(createTimingFunctionValue(*animation.timingFunction()));
3821                     list-&gt;append(cssValuePool.createValue(animation.delay(), CSSPrimitiveValue::CSS_S));
3822                     transitionsList-&gt;append(WTFMove(list));
3823                 }
<span class="line-modified">3824                 return transitionsList;</span>
3825             }
3826 
3827             auto list = CSSValueList::createSpaceSeparated();
3828             // transition-property default value.
3829             list-&gt;append(cssValuePool.createIdentifierValue(CSSValueAll));
3830             list-&gt;append(cssValuePool.createValue(Animation::initialDuration(), CSSPrimitiveValue::CSS_S));
3831             list-&gt;append(createTimingFunctionValue(Animation::initialTimingFunction()));
3832             list-&gt;append(cssValuePool.createValue(Animation::initialDelay(), CSSPrimitiveValue::CSS_S));
<span class="line-modified">3833             return list;</span>
3834         }
3835         case CSSPropertyPointerEvents:
3836             return cssValuePool.createValue(style.pointerEvents());
3837         case CSSPropertyWebkitLineGrid:
3838             if (style.lineGrid().isNull())
3839                 return cssValuePool.createIdentifierValue(CSSValueNone);
3840             return cssValuePool.createValue(style.lineGrid(), CSSPrimitiveValue::CSS_STRING);
3841         case CSSPropertyWebkitLineSnap:
3842             return CSSPrimitiveValue::create(style.lineSnap());
3843         case CSSPropertyWebkitLineAlign:
3844             return CSSPrimitiveValue::create(style.lineAlign());
3845         case CSSPropertyWritingMode:
3846             return cssValuePool.createValue(style.writingMode());
3847         case CSSPropertyWebkitTextCombine:
3848             return cssValuePool.createValue(style.textCombine());
3849         case CSSPropertyWebkitTextOrientation:
3850             return CSSPrimitiveValue::create(style.textOrientation());
3851         case CSSPropertyWebkitLineBoxContain:
3852             return createLineBoxContainValue(style.lineBoxContain());
3853         case CSSPropertyAlt:
</pre>
<hr />
<pre>
3856             return contentToCSSValue(style);
3857         case CSSPropertyCounterIncrement:
3858             return counterToCSSValue(style, propertyID);
3859         case CSSPropertyCounterReset:
3860             return counterToCSSValue(style, propertyID);
3861         case CSSPropertyWebkitClipPath: {
3862             auto* operation = style.clipPath();
3863             if (!operation)
3864                 return cssValuePool.createIdentifierValue(CSSValueNone);
3865             if (is&lt;ReferenceClipPathOperation&gt;(*operation))
3866                 return CSSPrimitiveValue::create(downcast&lt;ReferenceClipPathOperation&gt;(*operation).url(), CSSPrimitiveValue::CSS_URI);
3867             auto list = CSSValueList::createSpaceSeparated();
3868             if (is&lt;ShapeClipPathOperation&gt;(*operation)) {
3869                 auto&amp; shapeOperation = downcast&lt;ShapeClipPathOperation&gt;(*operation);
3870                 list-&gt;append(valueForBasicShape(style, shapeOperation.basicShape()));
3871                 if (shapeOperation.referenceBox() != CSSBoxType::BoxMissing)
3872                     list-&gt;append(cssValuePool.createValue(shapeOperation.referenceBox()));
3873             }
3874             if (is&lt;BoxClipPathOperation&gt;(*operation))
3875                 list-&gt;append(cssValuePool.createValue(downcast&lt;BoxClipPathOperation&gt;(*operation).referenceBox()));
<span class="line-modified">3876             return list;</span>
3877         }
3878         case CSSPropertyShapeMargin:
3879             return cssValuePool.createValue(style.shapeMargin(), style);
3880         case CSSPropertyShapeImageThreshold:
3881             return cssValuePool.createValue(style.shapeImageThreshold(), CSSPrimitiveValue::CSS_NUMBER);
3882         case CSSPropertyShapeOutside:
3883             return shapePropertyValue(style, style.shapeOutside());
3884         case CSSPropertyFilter:
3885             return valueForFilter(style, style.filter());
3886         case CSSPropertyAppleColorFilter:
3887             return valueForFilter(style, style.appleColorFilter());
3888 #if ENABLE(FILTERS_LEVEL_2)
3889         case CSSPropertyWebkitBackdropFilter:
3890             return valueForFilter(style, style.backdropFilter());
3891 #endif
3892 #if ENABLE(CSS_COMPOSITING)
3893         case CSSPropertyMixBlendMode:
3894             return cssValuePool.createValue(style.blendMode());
3895         case CSSPropertyIsolation:
3896             return cssValuePool.createValue(style.isolation());
3897 #endif
3898         case CSSPropertyBackgroundBlendMode: {
3899             auto&amp; layers = style.backgroundLayers();
3900             if (!layers.next())
3901                 return cssValuePool.createValue(layers.blendMode());
3902             auto list = CSSValueList::createCommaSeparated();
3903             for (auto* currLayer = &amp;layers; currLayer; currLayer = currLayer-&gt;next())
3904                 list-&gt;append(cssValuePool.createValue(currLayer-&gt;blendMode()));
<span class="line-modified">3905             return list;</span>
3906         }
3907         case CSSPropertyBackground:
3908             return getBackgroundShorthandValue();
3909         case CSSPropertyBorder: {
3910             auto value = propertyValue(CSSPropertyBorderTop, DoNotUpdateLayout);
3911             const CSSPropertyID properties[3] = { CSSPropertyBorderRight, CSSPropertyBorderBottom, CSSPropertyBorderLeft };
3912             for (auto&amp; property : properties) {
3913                 if (!compareCSSValuePtr&lt;CSSValue&gt;(value, propertyValue(property, DoNotUpdateLayout)))
3914                     return nullptr;
3915             }
3916             return value;
3917         }
3918         case CSSPropertyBorderBlock: {
3919             auto value = propertyValue(CSSPropertyBorderBlockStart, DoNotUpdateLayout);
3920             if (!compareCSSValuePtr&lt;CSSValue&gt;(value, propertyValue(CSSPropertyBorderBlockEnd, DoNotUpdateLayout)))
3921                 return nullptr;
3922             return value;
3923         }
3924         case CSSPropertyBorderBlockColor:
3925             return getCSSPropertyValuesFor2SidesShorthand(borderBlockColorShorthand());
</pre>
<hr />
<pre>
4006             return zoomAdjustedPixelValueForLength(style.scrollPaddingLeft(), style);
4007         case CSSPropertyScrollSnapType:
4008             return valueForScrollSnapType(style.scrollSnapType());
4009         case CSSPropertyScrollSnapAlign:
4010             return valueForScrollSnapAlignment(style.scrollSnapAlign());
4011 #endif
4012 
4013 #if ENABLE(CSS_TRAILING_WORD)
4014         case CSSPropertyAppleTrailingWord:
4015             return cssValuePool.createValue(style.trailingWord());
4016 #endif
4017 
4018 #if ENABLE(APPLE_PAY)
4019         case CSSPropertyApplePayButtonStyle:
4020             return cssValuePool.createValue(style.applePayButtonStyle());
4021         case CSSPropertyApplePayButtonType:
4022             return cssValuePool.createValue(style.applePayButtonType());
4023 #endif
4024 
4025 #if ENABLE(DARK_MODE_CSS)
<span class="line-modified">4026         case CSSPropertyColorScheme: {</span>
<span class="line-modified">4027             auto colorScheme = style.colorScheme();</span>
<span class="line-modified">4028             if (colorScheme.isAuto())</span>



4029                 return cssValuePool.createIdentifierValue(CSSValueAuto);
4030 
4031             auto list = CSSValueList::createSpaceSeparated();
<span class="line-modified">4032             if (colorScheme.contains(ColorScheme::Light))</span>
4033                 list-&gt;append(cssValuePool.createIdentifierValue(CSSValueLight));
<span class="line-modified">4034             if (colorScheme.contains(ColorScheme::Dark))</span>
4035                 list-&gt;append(cssValuePool.createIdentifierValue(CSSValueDark));
<span class="line-modified">4036             if (!colorScheme.allowsTransformations())</span>
4037                 list-&gt;append(cssValuePool.createIdentifierValue(CSSValueOnly));
4038             ASSERT(list-&gt;length());
<span class="line-modified">4039             return list;</span>
4040         }
4041 #endif
4042 
4043         /* Individual properties not part of the spec */
4044         case CSSPropertyBackgroundRepeatX:
4045         case CSSPropertyBackgroundRepeatY:
4046             break;
4047 
4048         // Length properties for SVG.
4049         case CSSPropertyCx:
4050             return zoomAdjustedPixelValueForLength(style.svgStyle().cx(), style);
4051         case CSSPropertyCy:
4052             return zoomAdjustedPixelValueForLength(style.svgStyle().cy(), style);
4053         case CSSPropertyR:
4054             return zoomAdjustedPixelValueForLength(style.svgStyle().r(), style);
4055         case CSSPropertyRx:
4056             return zoomAdjustedPixelValueForLength(style.svgStyle().rx(), style);
4057         case CSSPropertyRy:
4058             return zoomAdjustedPixelValueForLength(style.svgStyle().ry(), style);
4059         case CSSPropertyStrokeDashoffset:
</pre>
<hr />
<pre>
4277 }
4278 
4279 RefPtr&lt;CSSValueList&gt; ComputedStyleExtractor::getCSSPropertyValuesFor2SidesShorthand(const StylePropertyShorthand&amp; shorthand)
4280 {
4281     auto list = CSSValueList::createSpaceSeparated();
4282 
4283     // Assume the properties are in the usual order start, end.
4284     auto startValue = propertyValue(shorthand.properties()[0], DoNotUpdateLayout);
4285     auto endValue = propertyValue(shorthand.properties()[1], DoNotUpdateLayout);
4286 
4287     // All 2 properties must be specified.
4288     if (!startValue || !endValue)
4289         return nullptr;
4290 
4291     bool showEnd = !compareCSSValuePtr(startValue, endValue);
4292 
4293     list-&gt;append(startValue.releaseNonNull());
4294     if (showEnd)
4295         list-&gt;append(endValue.releaseNonNull());
4296 
<span class="line-modified">4297     return list;</span>
4298 }
4299 
4300 RefPtr&lt;CSSValueList&gt; ComputedStyleExtractor::getCSSPropertyValuesFor4SidesShorthand(const StylePropertyShorthand&amp; shorthand)
4301 {
4302     auto list = CSSValueList::createSpaceSeparated();
4303 
4304     // Assume the properties are in the usual order top, right, bottom, left.
4305     auto topValue = propertyValue(shorthand.properties()[0], DoNotUpdateLayout);
4306     auto rightValue = propertyValue(shorthand.properties()[1], DoNotUpdateLayout);
4307     auto bottomValue = propertyValue(shorthand.properties()[2], DoNotUpdateLayout);
4308     auto leftValue = propertyValue(shorthand.properties()[3], DoNotUpdateLayout);
4309 
4310     // All 4 properties must be specified.
4311     if (!topValue || !rightValue || !bottomValue || !leftValue)
4312         return nullptr;
4313 
4314     bool showLeft = !compareCSSValuePtr(rightValue, leftValue);
4315     bool showBottom = !compareCSSValuePtr(topValue, bottomValue) || showLeft;
4316     bool showRight = !compareCSSValuePtr(topValue, rightValue) || showBottom;
4317 
4318     list-&gt;append(topValue.releaseNonNull());
4319     if (showRight)
4320         list-&gt;append(rightValue.releaseNonNull());
4321     if (showBottom)
4322         list-&gt;append(bottomValue.releaseNonNull());
4323     if (showLeft)
4324         list-&gt;append(leftValue.releaseNonNull());
4325 
<span class="line-modified">4326     return list;</span>
4327 }
4328 
4329 Ref&lt;CSSValueList&gt; ComputedStyleExtractor::getCSSPropertyValuesForGridShorthand(const StylePropertyShorthand&amp; shorthand)
4330 {
4331     auto list = CSSValueList::createSlashSeparated();
4332     for (size_t i = 0; i &lt; shorthand.length(); ++i)
4333         list-&gt;append(propertyValue(shorthand.properties()[i], DoNotUpdateLayout).releaseNonNull());
4334     return list;
4335 }
4336 
4337 Ref&lt;MutableStyleProperties&gt; ComputedStyleExtractor::copyPropertiesInSet(const CSSPropertyID* set, unsigned length)
4338 {
4339     Vector&lt;CSSProperty, 256&gt; list;
4340     list.reserveInitialCapacity(length);
4341     for (unsigned i = 0; i &lt; length; ++i) {
4342         if (auto value = propertyValue(set[i]))
4343             list.append(CSSProperty(set[i], WTFMove(value), false));
4344     }
4345     return MutableStyleProperties::create(list.data(), list.size());
4346 }
</pre>
</td>
</tr>
</table>
<center><a href="CSSCalculationValue.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CSSComputedStyleDeclaration.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>