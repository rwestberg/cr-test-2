<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/GraphicsContext3D.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2009, 2014 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #pragma once
  27 
  28 #if ENABLE(WEBGL)
  29 
  30 #include &quot;ANGLEWebKitBridge.h&quot;
  31 #include &quot;GraphicsContext3DAttributes.h&quot;
  32 #include &quot;GraphicsTypes3D.h&quot;
  33 #include &quot;Image.h&quot;
  34 #include &quot;IntRect.h&quot;
  35 #include &quot;PlatformLayer.h&quot;
  36 #include &lt;memory&gt;
  37 #include &lt;wtf/HashCountedSet.h&gt;
  38 #include &lt;wtf/HashMap.h&gt;
  39 #include &lt;wtf/ListHashSet.h&gt;
  40 #include &lt;wtf/RefCounted.h&gt;
  41 #include &lt;wtf/RetainPtr.h&gt;
  42 #include &lt;wtf/UniqueArray.h&gt;
  43 #include &lt;wtf/text/WTFString.h&gt;
  44 
  45 #if USE(CA)
  46 #include &quot;PlatformCALayer.h&quot;
  47 #endif
  48 
  49 // FIXME: Find a better way to avoid the name confliction for NO_ERROR.
  50 #if PLATFORM(WIN)
  51 #undef NO_ERROR
  52 #elif PLATFORM(GTK)
  53 // This define is from the X11 headers, but it&#39;s used below, so we must undefine it.
  54 #undef VERSION
  55 #endif
  56 
  57 #if PLATFORM(COCOA)
  58 
  59 #if USE(OPENGL_ES)
  60 #include &lt;OpenGLES/ES2/gl.h&gt;
  61 #ifdef __OBJC__
  62 #import &lt;OpenGLES/EAGL.h&gt;
  63 typedef EAGLContext* PlatformGraphicsContext3D;
  64 #else
  65 typedef void* PlatformGraphicsContext3D;
  66 #endif // __OBJC__
  67 #endif // USE(OPENGL_ES)
  68 
  69 #if USE(OPENGL)
  70 typedef struct _CGLContextObject *CGLContextObj;
  71 typedef CGLContextObj PlatformGraphicsContext3D;
  72 #endif // USE(OPENGL)
  73 
  74 #if USE(ANGLE)
  75 typedef void* PlatformGraphicsContext3D;
  76 typedef void* PlatformGraphicsContext3DDisplay;
  77 typedef void* PlatformGraphicsContext3DSurface;
  78 typedef void* PlatformGraphicsContext3DConfig;
  79 #endif // USE(ANGLE)
  80 
  81 OBJC_CLASS CALayer;
  82 OBJC_CLASS WebGLLayer;
  83 typedef struct __IOSurface* IOSurfaceRef;
  84 #endif // PLATFORM(COCOA)
  85 
  86 #if USE(NICOSIA)
  87 namespace Nicosia {
  88 class GC3DLayer;
  89 }
  90 #endif
  91 
  92 #if !PLATFORM(COCOA)
  93 typedef unsigned GLuint;
  94 typedef void* PlatformGraphicsContext3D;
  95 typedef void* PlatformGraphicsSurface3D;
  96 #endif // !PLATFORM(COCOA)
  97 
  98 // These are currently the same among all implementations.
  99 const PlatformGraphicsContext3D NullPlatformGraphicsContext3D = 0;
 100 const Platform3DObject NullPlatform3DObject = 0;
 101 
 102 namespace WebCore {
 103 class Extensions3D;
 104 #if !PLATFORM(COCOA) &amp;&amp; USE(OPENGL_ES)
 105 class Extensions3DOpenGLES;
 106 #elif USE(OPENGL) || (PLATFORM(COCOA) &amp;&amp; USE(OPENGL_ES))
 107 class Extensions3DOpenGL;
 108 #elif USE(ANGLE)
 109 class Extensions3DANGLE;
 110 #endif
 111 class HostWindow;
 112 class Image;
 113 class ImageBuffer;
 114 class ImageData;
 115 class IntRect;
 116 class IntSize;
 117 class WebGLRenderingContextBase;
 118 #if USE(TEXTURE_MAPPER)
 119 class TextureMapperGC3DPlatformLayer;
 120 #endif
 121 
 122 typedef WTF::HashMap&lt;CString, uint64_t&gt; ShaderNameHash;
 123 
 124 struct ActiveInfo {
 125     String name;
 126     GC3Denum type;
 127     GC3Dint size;
 128 };
 129 
 130 class GraphicsContext3DPrivate;
 131 
 132 class GraphicsContext3D : public RefCounted&lt;GraphicsContext3D&gt; {
 133 public:
 134     class Client {
 135     public:
 136         virtual ~Client() { }
 137         virtual void didComposite() = 0;
 138         virtual void forceContextLost() = 0;
 139         virtual void recycleContext() = 0;
 140         virtual void dispatchContextChangedNotification() = 0;
 141     };
 142 
 143     enum {
 144         // WebGL 1 constants
 145         DEPTH_BUFFER_BIT = 0x00000100,
 146         STENCIL_BUFFER_BIT = 0x00000400,
 147         COLOR_BUFFER_BIT = 0x00004000,
 148         POINTS = 0x0000,
 149         LINES = 0x0001,
 150         LINE_LOOP = 0x0002,
 151         LINE_STRIP = 0x0003,
 152         TRIANGLES = 0x0004,
 153         TRIANGLE_STRIP = 0x0005,
 154         TRIANGLE_FAN = 0x0006,
 155         ZERO = 0,
 156         ONE = 1,
 157         SRC_COLOR = 0x0300,
 158         ONE_MINUS_SRC_COLOR = 0x0301,
 159         SRC_ALPHA = 0x0302,
 160         ONE_MINUS_SRC_ALPHA = 0x0303,
 161         DST_ALPHA = 0x0304,
 162         ONE_MINUS_DST_ALPHA = 0x0305,
 163         DST_COLOR = 0x0306,
 164         ONE_MINUS_DST_COLOR = 0x0307,
 165         SRC_ALPHA_SATURATE = 0x0308,
 166         FUNC_ADD = 0x8006,
 167         BLEND_EQUATION = 0x8009,
 168         BLEND_EQUATION_RGB = 0x8009,
 169         BLEND_EQUATION_ALPHA = 0x883D,
 170         FUNC_SUBTRACT = 0x800A,
 171         FUNC_REVERSE_SUBTRACT = 0x800B,
 172         BLEND_DST_RGB = 0x80C8,
 173         BLEND_SRC_RGB = 0x80C9,
 174         BLEND_DST_ALPHA = 0x80CA,
 175         BLEND_SRC_ALPHA = 0x80CB,
 176         CONSTANT_COLOR = 0x8001,
 177         ONE_MINUS_CONSTANT_COLOR = 0x8002,
 178         CONSTANT_ALPHA = 0x8003,
 179         ONE_MINUS_CONSTANT_ALPHA = 0x8004,
 180         BLEND_COLOR = 0x8005,
 181         ARRAY_BUFFER = 0x8892,
 182         ELEMENT_ARRAY_BUFFER = 0x8893,
 183         ARRAY_BUFFER_BINDING = 0x8894,
 184         ELEMENT_ARRAY_BUFFER_BINDING = 0x8895,
 185         STREAM_DRAW = 0x88E0,
 186         STATIC_DRAW = 0x88E4,
 187         DYNAMIC_DRAW = 0x88E8,
 188         BUFFER_SIZE = 0x8764,
 189         BUFFER_USAGE = 0x8765,
 190         CURRENT_VERTEX_ATTRIB = 0x8626,
 191         FRONT = 0x0404,
 192         BACK = 0x0405,
 193         FRONT_AND_BACK = 0x0408,
 194         TEXTURE_2D = 0x0DE1,
 195         CULL_FACE = 0x0B44,
 196         BLEND = 0x0BE2,
 197         DITHER = 0x0BD0,
 198         STENCIL_TEST = 0x0B90,
 199         DEPTH_TEST = 0x0B71,
 200         SCISSOR_TEST = 0x0C11,
 201         POLYGON_OFFSET_FILL = 0x8037,
 202         SAMPLE_ALPHA_TO_COVERAGE = 0x809E,
 203         SAMPLE_COVERAGE = 0x80A0,
 204         NO_ERROR = 0,
 205         INVALID_ENUM = 0x0500,
 206         INVALID_VALUE = 0x0501,
 207         INVALID_OPERATION = 0x0502,
 208         OUT_OF_MEMORY = 0x0505,
 209         CW = 0x0900,
 210         CCW = 0x0901,
 211         LINE_WIDTH = 0x0B21,
 212         ALIASED_POINT_SIZE_RANGE = 0x846D,
 213         ALIASED_LINE_WIDTH_RANGE = 0x846E,
 214         CULL_FACE_MODE = 0x0B45,
 215         FRONT_FACE = 0x0B46,
 216         DEPTH_RANGE = 0x0B70,
 217         DEPTH_WRITEMASK = 0x0B72,
 218         DEPTH_CLEAR_VALUE = 0x0B73,
 219         DEPTH_FUNC = 0x0B74,
 220         STENCIL_CLEAR_VALUE = 0x0B91,
 221         STENCIL_FUNC = 0x0B92,
 222         STENCIL_FAIL = 0x0B94,
 223         STENCIL_PASS_DEPTH_FAIL = 0x0B95,
 224         STENCIL_PASS_DEPTH_PASS = 0x0B96,
 225         STENCIL_REF = 0x0B97,
 226         STENCIL_VALUE_MASK = 0x0B93,
 227         STENCIL_WRITEMASK = 0x0B98,
 228         STENCIL_BACK_FUNC = 0x8800,
 229         STENCIL_BACK_FAIL = 0x8801,
 230         STENCIL_BACK_PASS_DEPTH_FAIL = 0x8802,
 231         STENCIL_BACK_PASS_DEPTH_PASS = 0x8803,
 232         STENCIL_BACK_REF = 0x8CA3,
 233         STENCIL_BACK_VALUE_MASK = 0x8CA4,
 234         STENCIL_BACK_WRITEMASK = 0x8CA5,
 235         VIEWPORT = 0x0BA2,
 236         SCISSOR_BOX = 0x0C10,
 237         COLOR_CLEAR_VALUE = 0x0C22,
 238         COLOR_WRITEMASK = 0x0C23,
 239         UNPACK_ALIGNMENT = 0x0CF5,
 240         PACK_ALIGNMENT = 0x0D05,
 241         MAX_TEXTURE_SIZE = 0x0D33,
 242         MAX_VIEWPORT_DIMS = 0x0D3A,
 243         SUBPIXEL_BITS = 0x0D50,
 244         RED_BITS = 0x0D52,
 245         GREEN_BITS = 0x0D53,
 246         BLUE_BITS = 0x0D54,
 247         ALPHA_BITS = 0x0D55,
 248         DEPTH_BITS = 0x0D56,
 249         STENCIL_BITS = 0x0D57,
 250         POLYGON_OFFSET_UNITS = 0x2A00,
 251         POLYGON_OFFSET_FACTOR = 0x8038,
 252         TEXTURE_BINDING_2D = 0x8069,
 253         SAMPLE_BUFFERS = 0x80A8,
 254         SAMPLES = 0x80A9,
 255         SAMPLE_COVERAGE_VALUE = 0x80AA,
 256         SAMPLE_COVERAGE_INVERT = 0x80AB,
 257         NUM_COMPRESSED_TEXTURE_FORMATS = 0x86A2,
 258         COMPRESSED_TEXTURE_FORMATS = 0x86A3,
 259         DONT_CARE = 0x1100,
 260         FASTEST = 0x1101,
 261         NICEST = 0x1102,
 262         GENERATE_MIPMAP_HINT = 0x8192,
 263         BYTE = 0x1400,
 264         UNSIGNED_BYTE = 0x1401,
 265         SHORT = 0x1402,
 266         UNSIGNED_SHORT = 0x1403,
 267         INT = 0x1404,
 268         UNSIGNED_INT = 0x1405,
 269         FLOAT = 0x1406,
 270         HALF_FLOAT_OES = 0x8D61,
 271         FIXED = 0x140C,
 272         DEPTH_COMPONENT = 0x1902,
 273         ALPHA = 0x1906,
 274         RGB = 0x1907,
 275         RGBA = 0x1908,
 276         BGRA = 0x80E1,
 277         LUMINANCE = 0x1909,
 278         LUMINANCE_ALPHA = 0x190A,
 279         UNSIGNED_SHORT_4_4_4_4 = 0x8033,
 280         UNSIGNED_SHORT_5_5_5_1 = 0x8034,
 281         UNSIGNED_SHORT_5_6_5 = 0x8363,
 282         FRAGMENT_SHADER = 0x8B30,
 283         VERTEX_SHADER = 0x8B31,
 284         MAX_VERTEX_ATTRIBS = 0x8869,
 285         MAX_VERTEX_UNIFORM_VECTORS = 0x8DFB,
 286         MAX_VARYING_VECTORS = 0x8DFC,
 287         MAX_COMBINED_TEXTURE_IMAGE_UNITS = 0x8B4D,
 288         MAX_VERTEX_TEXTURE_IMAGE_UNITS = 0x8B4C,
 289         MAX_TEXTURE_IMAGE_UNITS = 0x8872,
 290         MAX_FRAGMENT_UNIFORM_VECTORS = 0x8DFD,
 291         SHADER_TYPE = 0x8B4F,
 292         DELETE_STATUS = 0x8B80,
 293         LINK_STATUS = 0x8B82,
 294         VALIDATE_STATUS = 0x8B83,
 295         ATTACHED_SHADERS = 0x8B85,
 296         ACTIVE_UNIFORMS = 0x8B86,
 297         ACTIVE_UNIFORM_MAX_LENGTH = 0x8B87,
 298         ACTIVE_ATTRIBUTES = 0x8B89,
 299         ACTIVE_ATTRIBUTE_MAX_LENGTH = 0x8B8A,
 300         SHADING_LANGUAGE_VERSION = 0x8B8C,
 301         CURRENT_PROGRAM = 0x8B8D,
 302         NEVER = 0x0200,
 303         LESS = 0x0201,
 304         EQUAL = 0x0202,
 305         LEQUAL = 0x0203,
 306         GREATER = 0x0204,
 307         NOTEQUAL = 0x0205,
 308         GEQUAL = 0x0206,
 309         ALWAYS = 0x0207,
 310         KEEP = 0x1E00,
 311         REPLACE = 0x1E01,
 312         INCR = 0x1E02,
 313         DECR = 0x1E03,
 314         INVERT = 0x150A,
 315         INCR_WRAP = 0x8507,
 316         DECR_WRAP = 0x8508,
 317         VENDOR = 0x1F00,
 318         RENDERER = 0x1F01,
 319         VERSION = 0x1F02,
 320         EXTENSIONS = 0x1F03,
 321         NEAREST = 0x2600,
 322         LINEAR = 0x2601,
 323         NEAREST_MIPMAP_NEAREST = 0x2700,
 324         LINEAR_MIPMAP_NEAREST = 0x2701,
 325         NEAREST_MIPMAP_LINEAR = 0x2702,
 326         LINEAR_MIPMAP_LINEAR = 0x2703,
 327         TEXTURE_MAG_FILTER = 0x2800,
 328         TEXTURE_MIN_FILTER = 0x2801,
 329         TEXTURE_WRAP_S = 0x2802,
 330         TEXTURE_WRAP_T = 0x2803,
 331         TEXTURE = 0x1702,
 332         TEXTURE_CUBE_MAP = 0x8513,
 333         TEXTURE_BINDING_CUBE_MAP = 0x8514,
 334         TEXTURE_CUBE_MAP_POSITIVE_X = 0x8515,
 335         TEXTURE_CUBE_MAP_NEGATIVE_X = 0x8516,
 336         TEXTURE_CUBE_MAP_POSITIVE_Y = 0x8517,
 337         TEXTURE_CUBE_MAP_NEGATIVE_Y = 0x8518,
 338         TEXTURE_CUBE_MAP_POSITIVE_Z = 0x8519,
 339         TEXTURE_CUBE_MAP_NEGATIVE_Z = 0x851A,
 340         MAX_CUBE_MAP_TEXTURE_SIZE = 0x851C,
 341         TEXTURE0 = 0x84C0,
 342         TEXTURE1 = 0x84C1,
 343         TEXTURE2 = 0x84C2,
 344         TEXTURE3 = 0x84C3,
 345         TEXTURE4 = 0x84C4,
 346         TEXTURE5 = 0x84C5,
 347         TEXTURE6 = 0x84C6,
 348         TEXTURE7 = 0x84C7,
 349         TEXTURE8 = 0x84C8,
 350         TEXTURE9 = 0x84C9,
 351         TEXTURE10 = 0x84CA,
 352         TEXTURE11 = 0x84CB,
 353         TEXTURE12 = 0x84CC,
 354         TEXTURE13 = 0x84CD,
 355         TEXTURE14 = 0x84CE,
 356         TEXTURE15 = 0x84CF,
 357         TEXTURE16 = 0x84D0,
 358         TEXTURE17 = 0x84D1,
 359         TEXTURE18 = 0x84D2,
 360         TEXTURE19 = 0x84D3,
 361         TEXTURE20 = 0x84D4,
 362         TEXTURE21 = 0x84D5,
 363         TEXTURE22 = 0x84D6,
 364         TEXTURE23 = 0x84D7,
 365         TEXTURE24 = 0x84D8,
 366         TEXTURE25 = 0x84D9,
 367         TEXTURE26 = 0x84DA,
 368         TEXTURE27 = 0x84DB,
 369         TEXTURE28 = 0x84DC,
 370         TEXTURE29 = 0x84DD,
 371         TEXTURE30 = 0x84DE,
 372         TEXTURE31 = 0x84DF,
 373         ACTIVE_TEXTURE = 0x84E0,
 374         REPEAT = 0x2901,
 375         CLAMP_TO_EDGE = 0x812F,
 376         MIRRORED_REPEAT = 0x8370,
 377         FLOAT_VEC2 = 0x8B50,
 378         FLOAT_VEC3 = 0x8B51,
 379         FLOAT_VEC4 = 0x8B52,
 380         INT_VEC2 = 0x8B53,
 381         INT_VEC3 = 0x8B54,
 382         INT_VEC4 = 0x8B55,
 383         BOOL = 0x8B56,
 384         BOOL_VEC2 = 0x8B57,
 385         BOOL_VEC3 = 0x8B58,
 386         BOOL_VEC4 = 0x8B59,
 387         FLOAT_MAT2 = 0x8B5A,
 388         FLOAT_MAT3 = 0x8B5B,
 389         FLOAT_MAT4 = 0x8B5C,
 390         SAMPLER_2D = 0x8B5E,
 391         SAMPLER_CUBE = 0x8B60,
 392         VERTEX_ATTRIB_ARRAY_ENABLED = 0x8622,
 393         VERTEX_ATTRIB_ARRAY_SIZE = 0x8623,
 394         VERTEX_ATTRIB_ARRAY_STRIDE = 0x8624,
 395         VERTEX_ATTRIB_ARRAY_TYPE = 0x8625,
 396         VERTEX_ATTRIB_ARRAY_NORMALIZED = 0x886A,
 397         VERTEX_ATTRIB_ARRAY_POINTER = 0x8645,
 398         VERTEX_ATTRIB_ARRAY_BUFFER_BINDING = 0x889F,
 399         IMPLEMENTATION_COLOR_READ_TYPE = 0x8B9A,
 400         IMPLEMENTATION_COLOR_READ_FORMAT = 0x8B9B,
 401         COMPILE_STATUS = 0x8B81,
 402         INFO_LOG_LENGTH = 0x8B84,
 403         SHADER_SOURCE_LENGTH = 0x8B88,
 404         SHADER_COMPILER = 0x8DFA,
 405         SHADER_BINARY_FORMATS = 0x8DF8,
 406         NUM_SHADER_BINARY_FORMATS = 0x8DF9,
 407         LOW_FLOAT = 0x8DF0,
 408         MEDIUM_FLOAT = 0x8DF1,
 409         HIGH_FLOAT = 0x8DF2,
 410         LOW_INT = 0x8DF3,
 411         MEDIUM_INT = 0x8DF4,
 412         HIGH_INT = 0x8DF5,
 413         FRAMEBUFFER = 0x8D40,
 414         RENDERBUFFER = 0x8D41,
 415         RGBA4 = 0x8056,
 416         RGB5_A1 = 0x8057,
 417         RGB565 = 0x8D62,
 418         DEPTH_COMPONENT16 = 0x81A5,
 419         STENCIL_INDEX = 0x1901,
 420         STENCIL_INDEX8 = 0x8D48,
 421         RENDERBUFFER_WIDTH = 0x8D42,
 422         RENDERBUFFER_HEIGHT = 0x8D43,
 423         RENDERBUFFER_INTERNAL_FORMAT = 0x8D44,
 424         RENDERBUFFER_RED_SIZE = 0x8D50,
 425         RENDERBUFFER_GREEN_SIZE = 0x8D51,
 426         RENDERBUFFER_BLUE_SIZE = 0x8D52,
 427         RENDERBUFFER_ALPHA_SIZE = 0x8D53,
 428         RENDERBUFFER_DEPTH_SIZE = 0x8D54,
 429         RENDERBUFFER_STENCIL_SIZE = 0x8D55,
 430         FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE = 0x8CD0,
 431         FRAMEBUFFER_ATTACHMENT_OBJECT_NAME = 0x8CD1,
 432         FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL = 0x8CD2,
 433         FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE = 0x8CD3,
 434         COLOR_ATTACHMENT0 = 0x8CE0,
 435         DEPTH_ATTACHMENT = 0x8D00,
 436         STENCIL_ATTACHMENT = 0x8D20,
 437         NONE = 0,
 438         FRAMEBUFFER_COMPLETE = 0x8CD5,
 439         FRAMEBUFFER_INCOMPLETE_ATTACHMENT = 0x8CD6,
 440         FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = 0x8CD7,
 441         FRAMEBUFFER_INCOMPLETE_DIMENSIONS = 0x8CD9,
 442         FRAMEBUFFER_UNSUPPORTED = 0x8CDD,
 443         FRAMEBUFFER_BINDING = 0x8CA6,
 444         RENDERBUFFER_BINDING = 0x8CA7,
 445         MAX_RENDERBUFFER_SIZE = 0x84E8,
 446         INVALID_FRAMEBUFFER_OPERATION = 0x0506,
 447 
 448         // WebGL-specific enums
 449         UNPACK_FLIP_Y_WEBGL = 0x9240,
 450         UNPACK_PREMULTIPLY_ALPHA_WEBGL = 0x9241,
 451         CONTEXT_LOST_WEBGL = 0x9242,
 452         UNPACK_COLORSPACE_CONVERSION_WEBGL = 0x9243,
 453         BROWSER_DEFAULT_WEBGL = 0x9244,
 454         VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE = 0x88FE,
 455 
 456         // WebGL2 constants
 457         READ_BUFFER = 0x0C02,
 458         UNPACK_ROW_LENGTH = 0x0CF2,
 459         UNPACK_SKIP_ROWS = 0x0CF3,
 460         UNPACK_SKIP_PIXELS = 0x0CF4,
 461         PACK_ROW_LENGTH = 0x0D02,
 462         PACK_SKIP_ROWS = 0x0D03,
 463         PACK_SKIP_PIXELS = 0x0D04,
 464         COLOR = 0x1800,
 465         DEPTH = 0x1801,
 466         STENCIL = 0x1802,
 467         RED = 0x1903,
 468         RGB8 = 0x8051,
 469         RGBA8 = 0x8058,
 470         RGB10_A2 = 0x8059,
 471         TEXTURE_BINDING_3D = 0x806A,
 472         UNPACK_SKIP_IMAGES = 0x806D,
 473         UNPACK_IMAGE_HEIGHT = 0x806E,
 474         TEXTURE_3D = 0x806F,
 475         TEXTURE_WRAP_R = 0x8072,
 476         MAX_3D_TEXTURE_SIZE = 0x8073,
 477         UNSIGNED_INT_2_10_10_10_REV = 0x8368,
 478         MAX_ELEMENTS_VERTICES = 0x80E8,
 479         MAX_ELEMENTS_INDICES = 0x80E9,
 480         TEXTURE_MIN_LOD = 0x813A,
 481         TEXTURE_MAX_LOD = 0x813B,
 482         TEXTURE_BASE_LEVEL = 0x813C,
 483         TEXTURE_MAX_LEVEL = 0x813D,
 484         MIN = 0x8007,
 485         MAX = 0x8008,
 486         DEPTH_COMPONENT24 = 0x81A6,
 487         MAX_TEXTURE_LOD_BIAS = 0x84FD,
 488         TEXTURE_COMPARE_MODE = 0x884C,
 489         TEXTURE_COMPARE_FUNC = 0x884D,
 490         CURRENT_QUERY = 0x8865,
 491         QUERY_RESULT = 0x8866,
 492         QUERY_RESULT_AVAILABLE = 0x8867,
 493         STREAM_READ = 0x88E1,
 494         STREAM_COPY = 0x88E2,
 495         STATIC_READ = 0x88E5,
 496         STATIC_COPY = 0x88E6,
 497         DYNAMIC_READ = 0x88E9,
 498         DYNAMIC_COPY = 0x88EA,
 499         MAX_DRAW_BUFFERS = 0x8824,
 500         DRAW_BUFFER0 = 0x8825,
 501         DRAW_BUFFER1 = 0x8826,
 502         DRAW_BUFFER2 = 0x8827,
 503         DRAW_BUFFER3 = 0x8828,
 504         DRAW_BUFFER4 = 0x8829,
 505         DRAW_BUFFER5 = 0x882A,
 506         DRAW_BUFFER6 = 0x882B,
 507         DRAW_BUFFER7 = 0x882C,
 508         DRAW_BUFFER8 = 0x882D,
 509         DRAW_BUFFER9 = 0x882E,
 510         DRAW_BUFFER10 = 0x882F,
 511         DRAW_BUFFER11 = 0x8830,
 512         DRAW_BUFFER12 = 0x8831,
 513         DRAW_BUFFER13 = 0x8832,
 514         DRAW_BUFFER14 = 0x8833,
 515         DRAW_BUFFER15 = 0x8834,
 516         MAX_FRAGMENT_UNIFORM_COMPONENTS = 0x8B49,
 517         MAX_VERTEX_UNIFORM_COMPONENTS = 0x8B4A,
 518         SAMPLER_3D = 0x8B5F,
 519         SAMPLER_2D_SHADOW = 0x8B62,
 520         FRAGMENT_SHADER_DERIVATIVE_HINT = 0x8B8B,
 521         PIXEL_PACK_BUFFER = 0x88EB,
 522         PIXEL_UNPACK_BUFFER = 0x88EC,
 523         PIXEL_PACK_BUFFER_BINDING = 0x88ED,
 524         PIXEL_UNPACK_BUFFER_BINDING = 0x88EF,
 525         FLOAT_MAT2x3 = 0x8B65,
 526         FLOAT_MAT2x4 = 0x8B66,
 527         FLOAT_MAT3x2 = 0x8B67,
 528         FLOAT_MAT3x4 = 0x8B68,
 529         FLOAT_MAT4x2 = 0x8B69,
 530         FLOAT_MAT4x3 = 0x8B6A,
 531         SRGB = 0x8C40,
 532         SRGB8 = 0x8C41,
 533         SRGB_ALPHA = 0x8C42,
 534         SRGB8_ALPHA8 = 0x8C43,
 535         COMPARE_REF_TO_TEXTURE = 0x884E,
 536         RGBA32F = 0x8814,
 537         RGB32F = 0x8815,
 538         RGBA16F = 0x881A,
 539         RGB16F = 0x881B,
 540         VERTEX_ATTRIB_ARRAY_INTEGER = 0x88FD,
 541         MAX_ARRAY_TEXTURE_LAYERS = 0x88FF,
 542         MIN_PROGRAM_TEXEL_OFFSET = 0x8904,
 543         MAX_PROGRAM_TEXEL_OFFSET = 0x8905,
 544         MAX_VARYING_COMPONENTS = 0x8B4B,
 545         TEXTURE_2D_ARRAY = 0x8C1A,
 546         TEXTURE_BINDING_2D_ARRAY = 0x8C1D,
 547         R11F_G11F_B10F = 0x8C3A,
 548         UNSIGNED_INT_10F_11F_11F_REV = 0x8C3B,
 549         RGB9_E5 = 0x8C3D,
 550         UNSIGNED_INT_5_9_9_9_REV = 0x8C3E,
 551         TRANSFORM_FEEDBACK_BUFFER_MODE = 0x8C7F,
 552         MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS = 0x8C80,
 553         TRANSFORM_FEEDBACK_VARYINGS = 0x8C83,
 554         TRANSFORM_FEEDBACK_BUFFER_START = 0x8C84,
 555         TRANSFORM_FEEDBACK_BUFFER_SIZE = 0x8C85,
 556         TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN = 0x8C88,
 557         RASTERIZER_DISCARD = 0x8C89,
 558         MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS = 0x8C8A,
 559         MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS = 0x8C8B,
 560         INTERLEAVED_ATTRIBS = 0x8C8C,
 561         SEPARATE_ATTRIBS = 0x8C8D,
 562         TRANSFORM_FEEDBACK_BUFFER = 0x8C8E,
 563         TRANSFORM_FEEDBACK_BUFFER_BINDING = 0x8C8F,
 564         RGBA32UI = 0x8D70,
 565         RGB32UI = 0x8D71,
 566         RGBA16UI = 0x8D76,
 567         RGB16UI = 0x8D77,
 568         RGBA8UI = 0x8D7C,
 569         RGB8UI = 0x8D7D,
 570         RGBA32I = 0x8D82,
 571         RGB32I = 0x8D83,
 572         RGBA16I = 0x8D88,
 573         RGB16I = 0x8D89,
 574         RGBA8I = 0x8D8E,
 575         RGB8I = 0x8D8F,
 576         RED_INTEGER = 0x8D94,
 577         RGB_INTEGER = 0x8D98,
 578         RGBA_INTEGER = 0x8D99,
 579         SAMPLER_2D_ARRAY = 0x8DC1,
 580         SAMPLER_2D_ARRAY_SHADOW = 0x8DC4,
 581         SAMPLER_CUBE_SHADOW = 0x8DC5,
 582         UNSIGNED_INT_VEC2 = 0x8DC6,
 583         UNSIGNED_INT_VEC3 = 0x8DC7,
 584         UNSIGNED_INT_VEC4 = 0x8DC8,
 585         INT_SAMPLER_2D = 0x8DCA,
 586         INT_SAMPLER_3D = 0x8DCB,
 587         INT_SAMPLER_CUBE = 0x8DCC,
 588         INT_SAMPLER_2D_ARRAY = 0x8DCF,
 589         UNSIGNED_INT_SAMPLER_2D = 0x8DD2,
 590         UNSIGNED_INT_SAMPLER_3D = 0x8DD3,
 591         UNSIGNED_INT_SAMPLER_CUBE = 0x8DD4,
 592         UNSIGNED_INT_SAMPLER_2D_ARRAY = 0x8DD7,
 593         DEPTH_COMPONENT32F = 0x8CAC,
 594         DEPTH32F_STENCIL8 = 0x8CAD,
 595         FLOAT_32_UNSIGNED_INT_24_8_REV = 0x8DAD,
 596         FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING = 0x8210,
 597         FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE = 0x8211,
 598         FRAMEBUFFER_ATTACHMENT_RED_SIZE = 0x8212,
 599         FRAMEBUFFER_ATTACHMENT_GREEN_SIZE = 0x8213,
 600         FRAMEBUFFER_ATTACHMENT_BLUE_SIZE = 0x8214,
 601         FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE = 0x8215,
 602         FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE = 0x8216,
 603         FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE = 0x8217,
 604         FRAMEBUFFER_DEFAULT = 0x8218,
 605         DEPTH_STENCIL_ATTACHMENT = 0x821A,
 606         DEPTH_STENCIL = 0x84F9,
 607         UNSIGNED_INT_24_8 = 0x84FA,
 608         DEPTH24_STENCIL8 = 0x88F0,
 609         UNSIGNED_NORMALIZED = 0x8C17,
 610         DRAW_FRAMEBUFFER_BINDING = 0x8CA6, /* Same as FRAMEBUFFER_BINDING */
 611         READ_FRAMEBUFFER = 0x8CA8,
 612         DRAW_FRAMEBUFFER = 0x8CA9,
 613         READ_FRAMEBUFFER_BINDING = 0x8CAA,
 614         RENDERBUFFER_SAMPLES = 0x8CAB,
 615         FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER = 0x8CD4,
 616         MAX_COLOR_ATTACHMENTS = 0x8CDF,
 617         COLOR_ATTACHMENT1 = 0x8CE1,
 618         COLOR_ATTACHMENT2 = 0x8CE2,
 619         COLOR_ATTACHMENT3 = 0x8CE3,
 620         COLOR_ATTACHMENT4 = 0x8CE4,
 621         COLOR_ATTACHMENT5 = 0x8CE5,
 622         COLOR_ATTACHMENT6 = 0x8CE6,
 623         COLOR_ATTACHMENT7 = 0x8CE7,
 624         COLOR_ATTACHMENT8 = 0x8CE8,
 625         COLOR_ATTACHMENT9 = 0x8CE9,
 626         COLOR_ATTACHMENT10 = 0x8CEA,
 627         COLOR_ATTACHMENT11 = 0x8CEB,
 628         COLOR_ATTACHMENT12 = 0x8CEC,
 629         COLOR_ATTACHMENT13 = 0x8CED,
 630         COLOR_ATTACHMENT14 = 0x8CEE,
 631         COLOR_ATTACHMENT15 = 0x8CEF,
 632         FRAMEBUFFER_INCOMPLETE_MULTISAMPLE = 0x8D56,
 633         MAX_SAMPLES = 0x8D57,
 634         HALF_FLOAT = 0x140B,
 635         RG = 0x8227,
 636         RG_INTEGER = 0x8228,
 637         R8 = 0x8229,
 638         RG8 = 0x822B,
 639         R16F = 0x822D,
 640         R32F = 0x822E,
 641         RG16F = 0x822F,
 642         RG32F = 0x8230,
 643         R8I = 0x8231,
 644         R8UI = 0x8232,
 645         R16I = 0x8233,
 646         R16UI = 0x8234,
 647         R32I = 0x8235,
 648         R32UI = 0x8236,
 649         RG8I = 0x8237,
 650         RG8UI = 0x8238,
 651         RG16I = 0x8239,
 652         RG16UI = 0x823A,
 653         RG32I = 0x823B,
 654         RG32UI = 0x823C,
 655         VERTEX_ARRAY_BINDING = 0x85B5,
 656         R8_SNORM = 0x8F94,
 657         RG8_SNORM = 0x8F95,
 658         RGB8_SNORM = 0x8F96,
 659         RGBA8_SNORM = 0x8F97,
 660         SIGNED_NORMALIZED = 0x8F9C,
 661         COPY_READ_BUFFER = 0x8F36,
 662         COPY_WRITE_BUFFER = 0x8F37,
 663         COPY_READ_BUFFER_BINDING = 0x8F36, /* Same as COPY_READ_BUFFER */
 664         COPY_WRITE_BUFFER_BINDING = 0x8F37, /* Same as COPY_WRITE_BUFFER */
 665         UNIFORM_BUFFER = 0x8A11,
 666         UNIFORM_BUFFER_BINDING = 0x8A28,
 667         UNIFORM_BUFFER_START = 0x8A29,
 668         UNIFORM_BUFFER_SIZE = 0x8A2A,
 669         MAX_VERTEX_UNIFORM_BLOCKS = 0x8A2B,
 670         MAX_FRAGMENT_UNIFORM_BLOCKS = 0x8A2D,
 671         MAX_COMBINED_UNIFORM_BLOCKS = 0x8A2E,
 672         MAX_UNIFORM_BUFFER_BINDINGS = 0x8A2F,
 673         MAX_UNIFORM_BLOCK_SIZE = 0x8A30,
 674         MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS = 0x8A31,
 675         MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS = 0x8A33,
 676         UNIFORM_BUFFER_OFFSET_ALIGNMENT = 0x8A34,
 677         ACTIVE_UNIFORM_BLOCKS = 0x8A36,
 678         UNIFORM_TYPE = 0x8A37,
 679         UNIFORM_SIZE = 0x8A38,
 680         UNIFORM_BLOCK_INDEX = 0x8A3A,
 681         UNIFORM_OFFSET = 0x8A3B,
 682         UNIFORM_ARRAY_STRIDE = 0x8A3C,
 683         UNIFORM_MATRIX_STRIDE = 0x8A3D,
 684         UNIFORM_IS_ROW_MAJOR = 0x8A3E,
 685         UNIFORM_BLOCK_BINDING = 0x8A3F,
 686         UNIFORM_BLOCK_DATA_SIZE = 0x8A40,
 687         UNIFORM_BLOCK_ACTIVE_UNIFORMS = 0x8A42,
 688         UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES = 0x8A43,
 689         UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER = 0x8A44,
 690         UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER = 0x8A46,
 691         INVALID_INDEX = 0xFFFFFFFF,
 692         MAX_VERTEX_OUTPUT_COMPONENTS = 0x9122,
 693         MAX_FRAGMENT_INPUT_COMPONENTS = 0x9125,
 694         MAX_SERVER_WAIT_TIMEOUT = 0x9111,
 695         OBJECT_TYPE = 0x9112,
 696         SYNC_CONDITION = 0x9113,
 697         SYNC_STATUS = 0x9114,
 698         SYNC_FLAGS = 0x9115,
 699         SYNC_FENCE = 0x9116,
 700         SYNC_GPU_COMMANDS_COMPLETE = 0x9117,
 701         UNSIGNALED = 0x9118,
 702         SIGNALED = 0x9119,
 703         ALREADY_SIGNALED = 0x911A,
 704         TIMEOUT_EXPIRED = 0x911B,
 705         CONDITION_SATISFIED = 0x911C,
 706 #if PLATFORM(WIN)
 707         WAIT_FAILED_WIN = 0x911D,
 708 #else
 709         WAIT_FAILED = 0x911D,
 710 #endif
 711         SYNC_FLUSH_COMMANDS_BIT = 0x00000001,
 712         VERTEX_ATTRIB_ARRAY_DIVISOR = 0x88FE,
 713         ANY_SAMPLES_PASSED = 0x8C2F,
 714         ANY_SAMPLES_PASSED_CONSERVATIVE = 0x8D6A,
 715         SAMPLER_BINDING = 0x8919,
 716         RGB10_A2UI = 0x906F,
 717         TEXTURE_SWIZZLE_R = 0x8E42,
 718         TEXTURE_SWIZZLE_G = 0x8E43,
 719         TEXTURE_SWIZZLE_B = 0x8E44,
 720         TEXTURE_SWIZZLE_A = 0x8E45,
 721         GREEN = 0x1904,
 722         BLUE = 0x1905,
 723         INT_2_10_10_10_REV = 0x8D9F,
 724         TRANSFORM_FEEDBACK = 0x8E22,
 725         TRANSFORM_FEEDBACK_PAUSED = 0x8E23,
 726         TRANSFORM_FEEDBACK_ACTIVE = 0x8E24,
 727         TRANSFORM_FEEDBACK_BINDING = 0x8E25,
 728         COMPRESSED_R11_EAC = 0x9270,
 729         COMPRESSED_SIGNED_R11_EAC = 0x9271,
 730         COMPRESSED_RG11_EAC = 0x9272,
 731         COMPRESSED_SIGNED_RG11_EAC = 0x9273,
 732         COMPRESSED_RGB8_ETC2 = 0x9274,
 733         COMPRESSED_SRGB8_ETC2 = 0x9275,
 734         COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 0x9276,
 735         COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 0x9277,
 736         COMPRESSED_RGBA8_ETC2_EAC = 0x9278,
 737         COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 0x9279,
 738         TEXTURE_IMMUTABLE_FORMAT = 0x912F,
 739         MAX_ELEMENT_INDEX = 0x8D6B,
 740         NUM_SAMPLE_COUNTS = 0x9380,
 741         TEXTURE_IMMUTABLE_LEVELS = 0x82DF,
 742         PRIMITIVE_RESTART_FIXED_INDEX = 0x8D69,
 743         PRIMITIVE_RESTART = 0x8F9D,
 744 
 745         // OpenGL ES 3 constants
 746         MAP_READ_BIT = 0x0001
 747     };
 748 
 749     enum RenderStyle {
 750         RenderOffscreen,
 751         RenderDirectlyToHostWindow,
 752     };
 753 
 754     class ContextLostCallback {
 755     public:
 756         virtual void onContextLost() = 0;
 757         virtual ~ContextLostCallback() = default;
 758     };
 759 
 760     class ErrorMessageCallback {
 761     public:
 762         virtual void onErrorMessage(const String&amp; message, GC3Dint id) = 0;
 763         virtual ~ErrorMessageCallback() = default;
 764     };
 765 
 766     void setContextLostCallback(std::unique_ptr&lt;ContextLostCallback&gt;);
 767     void setErrorMessageCallback(std::unique_ptr&lt;ErrorMessageCallback&gt;);
 768 
 769     static RefPtr&lt;GraphicsContext3D&gt; create(GraphicsContext3DAttributes, HostWindow*, RenderStyle = RenderOffscreen);
 770     ~GraphicsContext3D();
 771 
 772 #if PLATFORM(COCOA)
 773     static Ref&lt;GraphicsContext3D&gt; createShared(GraphicsContext3D&amp; sharedContext);
 774 #endif
 775 
 776 #if PLATFORM(COCOA)
 777     PlatformGraphicsContext3D platformGraphicsContext3D() const { return m_contextObj; }
 778     Platform3DObject platformTexture() const { return m_texture; }
 779     CALayer* platformLayer() const { return reinterpret_cast&lt;CALayer*&gt;(m_webGLLayer.get()); }
 780 #else
 781     PlatformGraphicsContext3D platformGraphicsContext3D();
 782     Platform3DObject platformTexture() const;
 783     PlatformLayer* platformLayer() const;
 784 #endif
 785 
 786     bool makeContextCurrent();
 787 
 788     void addClient(Client&amp; client) { m_clients.add(&amp;client); }
 789     void removeClient(Client&amp; client) { m_clients.remove(&amp;client); }
 790 
 791     // With multisampling on, blit from multisampleFBO to regular FBO.
 792     void prepareTexture();
 793 
 794     // Equivalent to ::glTexImage2D(). Allows pixels==0 with no allocation.
 795     void texImage2DDirect(GC3Denum target, GC3Dint level, GC3Denum internalformat, GC3Dsizei width, GC3Dsizei height, GC3Dint border, GC3Denum format, GC3Denum type, const void* pixels);
 796 
 797     // Get an attribute location without checking the name -&gt; mangledname mapping.
 798     int getAttribLocationDirect(Platform3DObject program, const String&amp; name);
 799 
 800     // Compile a shader without going through ANGLE.
 801     void compileShaderDirect(Platform3DObject);
 802 
 803     // Helper to texImage2D with pixel==0 case: pixels are initialized to 0.
 804     // Return true if no GL error is synthesized.
 805     // By default, alignment is 4, the OpenGL default setting.
 806     bool texImage2DResourceSafe(GC3Denum target, GC3Dint level, GC3Denum internalformat, GC3Dsizei width, GC3Dsizei height, GC3Dint border, GC3Denum format, GC3Denum type, GC3Dint alignment = 4);
 807 
 808     bool isGLES2Compliant() const;
 809 
 810     //----------------------------------------------------------------------
 811     // Helpers for texture uploading and pixel readback.
 812     //
 813 
 814     // Computes the components per pixel and bytes per component
 815     // for the given format and type combination. Returns false if
 816     // either was an invalid enum.
 817     static bool computeFormatAndTypeParameters(GC3Denum format,
 818                                                GC3Denum type,
 819                                                unsigned int* componentsPerPixel,
 820                                                unsigned int* bytesPerComponent);
 821 
 822     // Computes the image size in bytes. If paddingInBytes is not null, padding
 823     // is also calculated in return. Returns NO_ERROR if succeed, otherwise
 824     // return the suggested GL error indicating the cause of the failure:
 825     //   INVALID_VALUE if width/height is negative or overflow happens.
 826     //   INVALID_ENUM if format/type is illegal.
 827     static GC3Denum computeImageSizeInBytes(GC3Denum format,
 828                                      GC3Denum type,
 829                                      GC3Dsizei width,
 830                                      GC3Dsizei height,
 831                                      GC3Dint alignment,
 832                                      unsigned int* imageSizeInBytes,
 833                                      unsigned int* paddingInBytes);
 834 
 835     static bool possibleFormatAndTypeForInternalFormat(GC3Denum internalFormat, GC3Denum&amp; format, GC3Denum&amp; type);
 836 
 837     // Extracts the contents of the given ImageData into the passed Vector,
 838     // packing the pixel data according to the given format and type,
 839     // and obeying the flipY and premultiplyAlpha flags. Returns true
 840     // upon success.
 841     static bool extractImageData(ImageData*,
 842                           GC3Denum format,
 843                           GC3Denum type,
 844                           bool flipY,
 845                           bool premultiplyAlpha,
 846                           Vector&lt;uint8_t&gt;&amp; data);
 847 
 848     // Helper function which extracts the user-supplied texture
 849     // data, applying the flipY and premultiplyAlpha parameters.
 850     // If the data is not tightly packed according to the passed
 851     // unpackAlignment, the output data will be tightly packed.
 852     // Returns true if successful, false if any error occurred.
 853     static bool extractTextureData(unsigned int width, unsigned int height,
 854                             GC3Denum format, GC3Denum type,
 855                             unsigned int unpackAlignment,
 856                             bool flipY, bool premultiplyAlpha,
 857                             const void* pixels,
 858                             Vector&lt;uint8_t&gt;&amp; data);
 859 
 860 
 861     // Attempt to enumerate all possible native image formats to
 862     // reduce the amount of temporary allocations during texture
 863     // uploading. This enum must be public because it is accessed
 864     // by non-member functions.
 865     enum DataFormat {
 866         DataFormatRGBA8 = 0,
 867         DataFormatRGBA16Little,
 868         DataFormatRGBA16Big,
 869         DataFormatRGBA16F,
 870         DataFormatRGBA32F,
 871         DataFormatRGB8,
 872         DataFormatRGB16Little,
 873         DataFormatRGB16Big,
 874         DataFormatRGB16F,
 875         DataFormatRGB32F,
 876         DataFormatBGR8,
 877         DataFormatBGRA8,
 878         DataFormatBGRA16Little,
 879         DataFormatBGRA16Big,
 880         DataFormatARGB8,
 881         DataFormatARGB16Little,
 882         DataFormatARGB16Big,
 883         DataFormatABGR8,
 884         DataFormatRGBA5551,
 885         DataFormatRGBA4444,
 886         DataFormatRGB565,
 887         DataFormatR8,
 888         DataFormatR16Little,
 889         DataFormatR16Big,
 890         DataFormatR16F,
 891         DataFormatR32F,
 892         DataFormatRA8,
 893         DataFormatRA16Little,
 894         DataFormatRA16Big,
 895         DataFormatRA16F,
 896         DataFormatRA32F,
 897         DataFormatAR8,
 898         DataFormatAR16Little,
 899         DataFormatAR16Big,
 900         DataFormatA8,
 901         DataFormatA16Little,
 902         DataFormatA16Big,
 903         DataFormatA16F,
 904         DataFormatA32F,
 905         DataFormatNumFormats
 906     };
 907 
 908     ALWAYS_INLINE static bool hasAlpha(DataFormat format)
 909     {
 910         switch (format) {
 911         case GraphicsContext3D::DataFormatA8:
 912         case GraphicsContext3D::DataFormatA16F:
 913         case GraphicsContext3D::DataFormatA32F:
 914         case GraphicsContext3D::DataFormatRA8:
 915         case GraphicsContext3D::DataFormatAR8:
 916         case GraphicsContext3D::DataFormatRA16F:
 917         case GraphicsContext3D::DataFormatRA32F:
 918         case GraphicsContext3D::DataFormatRGBA8:
 919         case GraphicsContext3D::DataFormatBGRA8:
 920         case GraphicsContext3D::DataFormatARGB8:
 921         case GraphicsContext3D::DataFormatABGR8:
 922         case GraphicsContext3D::DataFormatRGBA16F:
 923         case GraphicsContext3D::DataFormatRGBA32F:
 924         case GraphicsContext3D::DataFormatRGBA4444:
 925         case GraphicsContext3D::DataFormatRGBA5551:
 926             return true;
 927         default:
 928             return false;
 929         }
 930     }
 931 
 932     ALWAYS_INLINE static bool hasColor(DataFormat format)
 933     {
 934         switch (format) {
 935         case GraphicsContext3D::DataFormatRGBA8:
 936         case GraphicsContext3D::DataFormatRGBA16F:
 937         case GraphicsContext3D::DataFormatRGBA32F:
 938         case GraphicsContext3D::DataFormatRGB8:
 939         case GraphicsContext3D::DataFormatRGB16F:
 940         case GraphicsContext3D::DataFormatRGB32F:
 941         case GraphicsContext3D::DataFormatBGR8:
 942         case GraphicsContext3D::DataFormatBGRA8:
 943         case GraphicsContext3D::DataFormatARGB8:
 944         case GraphicsContext3D::DataFormatABGR8:
 945         case GraphicsContext3D::DataFormatRGBA5551:
 946         case GraphicsContext3D::DataFormatRGBA4444:
 947         case GraphicsContext3D::DataFormatRGB565:
 948         case GraphicsContext3D::DataFormatR8:
 949         case GraphicsContext3D::DataFormatR16F:
 950         case GraphicsContext3D::DataFormatR32F:
 951         case GraphicsContext3D::DataFormatRA8:
 952         case GraphicsContext3D::DataFormatRA16F:
 953         case GraphicsContext3D::DataFormatRA32F:
 954         case GraphicsContext3D::DataFormatAR8:
 955             return true;
 956         default:
 957             return false;
 958         }
 959     }
 960 
 961     // Check if the format is one of the formats from the ImageData or DOM elements.
 962     // The formats from ImageData is always RGBA8.
 963     // The formats from DOM elements vary with Graphics ports. It can only be RGBA8 or BGRA8 for non-CG port while a little more for CG port.
 964     static ALWAYS_INLINE bool srcFormatComesFromDOMElementOrImageData(DataFormat SrcFormat)
 965     {
 966 #if USE(CG)
 967 #if CPU(BIG_ENDIAN)
 968     return SrcFormat == DataFormatRGBA8 || SrcFormat == DataFormatARGB8 || SrcFormat == DataFormatRGB8
 969         || SrcFormat == DataFormatRA8 || SrcFormat == DataFormatAR8 || SrcFormat == DataFormatR8 || SrcFormat == DataFormatA8;
 970 #else
 971     // That LITTLE_ENDIAN case has more possible formats than BIG_ENDIAN case is because some decoded image data is actually big endian
 972     // even on little endian architectures.
 973     return SrcFormat == DataFormatBGRA8 || SrcFormat == DataFormatABGR8 || SrcFormat == DataFormatBGR8
 974         || SrcFormat == DataFormatRGBA8 || SrcFormat == DataFormatARGB8 || SrcFormat == DataFormatRGB8
 975         || SrcFormat == DataFormatR8 || SrcFormat == DataFormatA8
 976         || SrcFormat == DataFormatRA8 || SrcFormat == DataFormatAR8;
 977 #endif
 978 #else
 979     return SrcFormat == DataFormatBGRA8 || SrcFormat == DataFormatRGBA8;
 980 #endif
 981     }
 982 
 983     //----------------------------------------------------------------------
 984     // Entry points for WebGL.
 985     //
 986 
 987     void activeTexture(GC3Denum texture);
 988     void attachShader(Platform3DObject program, Platform3DObject shader);
 989     void bindAttribLocation(Platform3DObject, GC3Duint index, const String&amp; name);
 990     void bindBuffer(GC3Denum target, Platform3DObject);
 991     void bindFramebuffer(GC3Denum target, Platform3DObject);
 992     void bindRenderbuffer(GC3Denum target, Platform3DObject);
 993     void bindTexture(GC3Denum target, Platform3DObject);
 994     void blendColor(GC3Dclampf red, GC3Dclampf green, GC3Dclampf blue, GC3Dclampf alpha);
 995     void blendEquation(GC3Denum mode);
 996     void blendEquationSeparate(GC3Denum modeRGB, GC3Denum modeAlpha);
 997     void blendFunc(GC3Denum sfactor, GC3Denum dfactor);
 998     void blendFuncSeparate(GC3Denum srcRGB, GC3Denum dstRGB, GC3Denum srcAlpha, GC3Denum dstAlpha);
 999 
1000     void bufferData(GC3Denum target, GC3Dsizeiptr size, GC3Denum usage);
1001     void bufferData(GC3Denum target, GC3Dsizeiptr size, const void* data, GC3Denum usage);
1002     void bufferSubData(GC3Denum target, GC3Dintptr offset, GC3Dsizeiptr size, const void* data);
1003 
1004     void* mapBufferRange(GC3Denum target, GC3Dintptr offset, GC3Dsizeiptr length, GC3Dbitfield access);
1005     GC3Dboolean unmapBuffer(GC3Denum target);
1006     void copyBufferSubData(GC3Denum readTarget, GC3Denum writeTarget, GC3Dintptr readOffset, GC3Dintptr writeOffset, GC3Dsizeiptr);
1007 
1008     void getInternalformativ(GC3Denum target, GC3Denum internalformat, GC3Denum pname, GC3Dsizei bufSize, GC3Dint* params);
1009     void renderbufferStorageMultisample(GC3Denum target, GC3Dsizei samples, GC3Denum internalformat, GC3Dsizei width, GC3Dsizei height);
1010 
1011     void texStorage2D(GC3Denum target, GC3Dsizei levels, GC3Denum internalformat, GC3Dsizei width, GC3Dsizei height);
1012     void texStorage3D(GC3Denum target, GC3Dsizei levels, GC3Denum internalformat, GC3Dsizei width, GC3Dsizei height, GC3Dsizei depth);
1013 
1014     void getActiveUniforms(Platform3DObject program, const Vector&lt;GC3Duint&gt;&amp; uniformIndices, GC3Denum pname, Vector&lt;GC3Dint&gt;&amp; params);
1015 
1016     GC3Denum checkFramebufferStatus(GC3Denum target);
1017     void clear(GC3Dbitfield mask);
1018     void clearColor(GC3Dclampf red, GC3Dclampf green, GC3Dclampf blue, GC3Dclampf alpha);
1019     void clearDepth(GC3Dclampf depth);
1020     void clearStencil(GC3Dint s);
1021     void colorMask(GC3Dboolean red, GC3Dboolean green, GC3Dboolean blue, GC3Dboolean alpha);
1022     void compileShader(Platform3DObject);
1023 
1024     void compressedTexImage2D(GC3Denum target, GC3Dint level, GC3Denum internalformat, GC3Dsizei width, GC3Dsizei height, GC3Dint border, GC3Dsizei imageSize, const void* data);
1025     void compressedTexSubImage2D(GC3Denum target, GC3Dint level, GC3Dint xoffset, GC3Dint yoffset, GC3Dsizei width, GC3Dsizei height, GC3Denum format, GC3Dsizei imageSize, const void* data);
1026     void copyTexImage2D(GC3Denum target, GC3Dint level, GC3Denum internalformat, GC3Dint x, GC3Dint y, GC3Dsizei width, GC3Dsizei height, GC3Dint border);
1027     void copyTexSubImage2D(GC3Denum target, GC3Dint level, GC3Dint xoffset, GC3Dint yoffset, GC3Dint x, GC3Dint y, GC3Dsizei width, GC3Dsizei height);
1028     void cullFace(GC3Denum mode);
1029     void depthFunc(GC3Denum func);
1030     void depthMask(GC3Dboolean flag);
1031     void depthRange(GC3Dclampf zNear, GC3Dclampf zFar);
1032     void detachShader(Platform3DObject, Platform3DObject);
1033     void disable(GC3Denum cap);
1034     void disableVertexAttribArray(GC3Duint index);
1035     void drawArrays(GC3Denum mode, GC3Dint first, GC3Dsizei count);
1036     void drawElements(GC3Denum mode, GC3Dsizei count, GC3Denum type, GC3Dintptr offset);
1037 
1038     void enable(GC3Denum cap);
1039     void enableVertexAttribArray(GC3Duint index);
1040     void finish();
1041     void flush();
1042     void framebufferRenderbuffer(GC3Denum target, GC3Denum attachment, GC3Denum renderbuffertarget, Platform3DObject);
1043     void framebufferTexture2D(GC3Denum target, GC3Denum attachment, GC3Denum textarget, Platform3DObject, GC3Dint level);
1044     void frontFace(GC3Denum mode);
1045     void generateMipmap(GC3Denum target);
1046 
1047     bool getActiveAttrib(Platform3DObject program, GC3Duint index, ActiveInfo&amp;);
1048     bool getActiveAttribImpl(Platform3DObject program, GC3Duint index, ActiveInfo&amp;);
1049     bool getActiveUniform(Platform3DObject program, GC3Duint index, ActiveInfo&amp;);
1050     bool getActiveUniformImpl(Platform3DObject program, GC3Duint index, ActiveInfo&amp;);
1051     void getAttachedShaders(Platform3DObject program, GC3Dsizei maxCount, GC3Dsizei* count, Platform3DObject* shaders);
1052     GC3Dint getAttribLocation(Platform3DObject, const String&amp; name);
1053     void getBooleanv(GC3Denum pname, GC3Dboolean* value);
1054     void getBufferParameteriv(GC3Denum target, GC3Denum pname, GC3Dint* value);
1055     GraphicsContext3DAttributes getContextAttributes();
1056     GC3Denum getError();
1057     void getFloatv(GC3Denum pname, GC3Dfloat* value);
1058     void getFramebufferAttachmentParameteriv(GC3Denum target, GC3Denum attachment, GC3Denum pname, GC3Dint* value);
1059     void getIntegerv(GC3Denum pname, GC3Dint* value);
1060     void getInteger64v(GC3Denum pname, GC3Dint64* value);
1061     void getProgramiv(Platform3DObject program, GC3Denum pname, GC3Dint* value);
1062 #if !USE(ANGLE)
1063     void getNonBuiltInActiveSymbolCount(Platform3DObject program, GC3Denum pname, GC3Dint* value);
1064 #endif // !USE(ANGLE)
1065     String getProgramInfoLog(Platform3DObject);
1066     String getUnmangledInfoLog(Platform3DObject[2], GC3Dsizei, const String&amp;);
1067     void getRenderbufferParameteriv(GC3Denum target, GC3Denum pname, GC3Dint* value);
1068     void getShaderiv(Platform3DObject, GC3Denum pname, GC3Dint* value);
1069     String getShaderInfoLog(Platform3DObject);
1070     void getShaderPrecisionFormat(GC3Denum shaderType, GC3Denum precisionType, GC3Dint* range, GC3Dint* precision);
1071 #if !USE(ANGLE)
1072     String getShaderSource(Platform3DObject);
1073 #endif // !USE(ANGLE)
1074     String getString(GC3Denum name);
1075     void getTexParameterfv(GC3Denum target, GC3Denum pname, GC3Dfloat* value);
1076     void getTexParameteriv(GC3Denum target, GC3Denum pname, GC3Dint* value);
1077     void getUniformfv(Platform3DObject program, GC3Dint location, GC3Dfloat* value);
1078     void getUniformiv(Platform3DObject program, GC3Dint location, GC3Dint* value);
1079     GC3Dint getUniformLocation(Platform3DObject, const String&amp; name);
1080     void getVertexAttribfv(GC3Duint index, GC3Denum pname, GC3Dfloat* value);
1081     void getVertexAttribiv(GC3Duint index, GC3Denum pname, GC3Dint* value);
1082     GC3Dsizeiptr getVertexAttribOffset(GC3Duint index, GC3Denum pname);
1083 
1084     void hint(GC3Denum target, GC3Denum mode);
1085     GC3Dboolean isBuffer(Platform3DObject);
1086     GC3Dboolean isEnabled(GC3Denum cap);
1087     GC3Dboolean isFramebuffer(Platform3DObject);
1088     GC3Dboolean isProgram(Platform3DObject);
1089     GC3Dboolean isRenderbuffer(Platform3DObject);
1090     GC3Dboolean isShader(Platform3DObject);
1091     GC3Dboolean isTexture(Platform3DObject);
1092     void lineWidth(GC3Dfloat);
1093     void linkProgram(Platform3DObject);
1094     void pixelStorei(GC3Denum pname, GC3Dint param);
1095     void polygonOffset(GC3Dfloat factor, GC3Dfloat units);
1096 
1097     void readPixels(GC3Dint x, GC3Dint y, GC3Dsizei width, GC3Dsizei height, GC3Denum format, GC3Denum type, void* data);
1098 
1099     void releaseShaderCompiler();
1100 
1101     void renderbufferStorage(GC3Denum target, GC3Denum internalformat, GC3Dsizei width, GC3Dsizei height);
1102     void sampleCoverage(GC3Dclampf value, GC3Dboolean invert);
1103     void scissor(GC3Dint x, GC3Dint y, GC3Dsizei width, GC3Dsizei height);
1104     void shaderSource(Platform3DObject, const String&amp; string);
1105     void stencilFunc(GC3Denum func, GC3Dint ref, GC3Duint mask);
1106     void stencilFuncSeparate(GC3Denum face, GC3Denum func, GC3Dint ref, GC3Duint mask);
1107     void stencilMask(GC3Duint mask);
1108     void stencilMaskSeparate(GC3Denum face, GC3Duint mask);
1109     void stencilOp(GC3Denum fail, GC3Denum zfail, GC3Denum zpass);
1110     void stencilOpSeparate(GC3Denum face, GC3Denum fail, GC3Denum zfail, GC3Denum zpass);
1111 
1112     bool texImage2D(GC3Denum target, GC3Dint level, GC3Denum internalformat, GC3Dsizei width, GC3Dsizei height, GC3Dint border, GC3Denum format, GC3Denum type, const void* pixels);
1113     void texParameterf(GC3Denum target, GC3Denum pname, GC3Dfloat param);
1114     void texParameteri(GC3Denum target, GC3Denum pname, GC3Dint param);
1115     void texSubImage2D(GC3Denum target, GC3Dint level, GC3Dint xoffset, GC3Dint yoffset, GC3Dsizei width, GC3Dsizei height, GC3Denum format, GC3Denum type, const void* pixels);
1116 
1117     void uniform1f(GC3Dint location, GC3Dfloat x);
1118     void uniform1fv(GC3Dint location, GC3Dsizei, const GC3Dfloat* v);
1119     void uniform1i(GC3Dint location, GC3Dint x);
1120     void uniform1iv(GC3Dint location, GC3Dsizei, const GC3Dint* v);
1121     void uniform2f(GC3Dint location, GC3Dfloat x, GC3Dfloat y);
1122     void uniform2fv(GC3Dint location, GC3Dsizei, const GC3Dfloat* v);
1123     void uniform2i(GC3Dint location, GC3Dint x, GC3Dint y);
1124     void uniform2iv(GC3Dint location, GC3Dsizei, const GC3Dint* v);
1125     void uniform3f(GC3Dint location, GC3Dfloat x, GC3Dfloat y, GC3Dfloat z);
1126     void uniform3fv(GC3Dint location, GC3Dsizei, const GC3Dfloat* v);
1127     void uniform3i(GC3Dint location, GC3Dint x, GC3Dint y, GC3Dint z);
1128     void uniform3iv(GC3Dint location, GC3Dsizei, const GC3Dint* v);
1129     void uniform4f(GC3Dint location, GC3Dfloat x, GC3Dfloat y, GC3Dfloat z, GC3Dfloat w);
1130     void uniform4fv(GC3Dint location, GC3Dsizei, const GC3Dfloat* v);
1131     void uniform4i(GC3Dint location, GC3Dint x, GC3Dint y, GC3Dint z, GC3Dint w);
1132     void uniform4iv(GC3Dint location, GC3Dsizei, const GC3Dint* v);
1133     void uniformMatrix2fv(GC3Dint location, GC3Dsizei, GC3Dboolean transpose, const GC3Dfloat* value);
1134     void uniformMatrix3fv(GC3Dint location, GC3Dsizei, GC3Dboolean transpose, const GC3Dfloat* value);
1135     void uniformMatrix4fv(GC3Dint location, GC3Dsizei, GC3Dboolean transpose, const GC3Dfloat* value);
1136 
1137     void useProgram(Platform3DObject);
1138     void validateProgram(Platform3DObject);
1139 #if !USE(ANGLE)
1140     bool checkVaryingsPacking(Platform3DObject vertexShader, Platform3DObject fragmentShader) const;
1141     bool precisionsMatch(Platform3DObject vertexShader, Platform3DObject fragmentShader) const;
1142 #endif
1143 
1144     void vertexAttrib1f(GC3Duint index, GC3Dfloat x);
1145     void vertexAttrib1fv(GC3Duint index, const GC3Dfloat* values);
1146     void vertexAttrib2f(GC3Duint index, GC3Dfloat x, GC3Dfloat y);
1147     void vertexAttrib2fv(GC3Duint index, const GC3Dfloat* values);
1148     void vertexAttrib3f(GC3Duint index, GC3Dfloat x, GC3Dfloat y, GC3Dfloat z);
1149     void vertexAttrib3fv(GC3Duint index, const GC3Dfloat* values);
1150     void vertexAttrib4f(GC3Duint index, GC3Dfloat x, GC3Dfloat y, GC3Dfloat z, GC3Dfloat w);
1151     void vertexAttrib4fv(GC3Duint index, const GC3Dfloat* values);
1152     void vertexAttribPointer(GC3Duint index, GC3Dint size, GC3Denum type, GC3Dboolean normalized,
1153                              GC3Dsizei stride, GC3Dintptr offset);
1154 
1155     void viewport(GC3Dint x, GC3Dint y, GC3Dsizei width, GC3Dsizei height);
1156 
1157     void reshape(int width, int height);
1158 
1159     void drawArraysInstanced(GC3Denum mode, GC3Dint first, GC3Dsizei count, GC3Dsizei primcount);
1160     void drawElementsInstanced(GC3Denum mode, GC3Dsizei count, GC3Denum type, GC3Dintptr offset, GC3Dsizei primcount);
1161     void vertexAttribDivisor(GC3Duint index, GC3Duint divisor);
1162 
1163     // VertexArrayOject calls
1164     Platform3DObject createVertexArray();
1165     void deleteVertexArray(Platform3DObject);
1166     GC3Dboolean isVertexArray(Platform3DObject);
1167     void bindVertexArray(Platform3DObject);
1168 
1169     void paintToCanvas(const unsigned char* imagePixels, const IntSize&amp; imageSize, const IntSize&amp; canvasSize, GraphicsContext&amp;);
1170 
1171     void markContextChanged();
1172     void markLayerComposited();
1173     bool layerComposited() const;
1174     void forceContextLost();
1175     void recycleContext();
1176 
1177     void dispatchContextChangedNotification();
1178     void simulateContextChanged();
1179 
1180     void paintRenderingResultsToCanvas(ImageBuffer*);
1181     RefPtr&lt;ImageData&gt; paintRenderingResultsToImageData();
1182     bool paintCompositedResultsToCanvas(ImageBuffer*);
1183 
1184 #if USE(OPENGL) &amp;&amp; ENABLE(WEBGL2)
1185     void primitiveRestartIndex(GC3Duint);
1186 #endif
1187 
1188 #if PLATFORM(COCOA)
1189     bool texImageIOSurface2D(GC3Denum target, GC3Denum internalFormat, GC3Dsizei width, GC3Dsizei height, GC3Denum format, GC3Denum type, IOSurfaceRef, GC3Duint plane);
1190 
1191 #if USE(OPENGL_ES)
1192     void presentRenderbuffer();
1193 #endif
1194 
1195 #if USE(OPENGL)
1196     void allocateIOSurfaceBackingStore(IntSize);
1197     void updateFramebufferTextureBackingStoreFromLayer();
1198     void updateCGLContext();
1199 #endif
1200 
1201 #if USE(ANGLE) &amp;&amp; PLATFORM(MAC)
1202     void allocateIOSurfaceBackingStore(IntSize);
1203     void updateFramebufferTextureBackingStoreFromLayer();
1204 #endif
1205 #endif // PLATFORM(COCOA)
1206 
1207     void setContextVisibility(bool);
1208 
1209     GraphicsContext3DPowerPreference powerPreferenceUsedForCreation() const { return m_powerPreferenceUsedForCreation; }
1210 
1211     // Support for buffer creation and deletion
1212     Platform3DObject createBuffer();
1213     Platform3DObject createFramebuffer();
1214     Platform3DObject createProgram();
1215     Platform3DObject createRenderbuffer();
1216     Platform3DObject createShader(GC3Denum);
1217     Platform3DObject createTexture();
1218 
1219     void deleteBuffer(Platform3DObject);
1220     void deleteFramebuffer(Platform3DObject);
1221     void deleteProgram(Platform3DObject);
1222     void deleteRenderbuffer(Platform3DObject);
1223     void deleteShader(Platform3DObject);
1224     void deleteTexture(Platform3DObject);
1225 
1226     // Synthesizes an OpenGL error which will be returned from a
1227     // later call to getError. This is used to emulate OpenGL ES
1228     // 2.0 behavior on the desktop and to enforce additional error
1229     // checking mandated by WebGL.
1230     //
1231     // Per the behavior of glGetError, this stores at most one
1232     // instance of any given error, and returns them from calls to
1233     // getError in the order they were added.
1234     void synthesizeGLError(GC3Denum error);
1235 
1236     // Read real OpenGL errors, and move them to the synthetic
1237     // error list. Return true if at least one error is moved.
1238     bool moveErrorsToSyntheticErrorList();
1239 
1240     // Support for extensions. Returns a non-null object, though not
1241     // all methods it contains may necessarily be supported on the
1242     // current hardware. Must call Extensions3D::supports() to
1243     // determine this.
1244     Extensions3D&amp; getExtensions();
1245 
1246     IntSize getInternalFramebufferSize() const;
1247 
1248     static unsigned getClearBitsByAttachmentType(GC3Denum);
1249     static unsigned getClearBitsByFormat(GC3Denum);
1250 
1251     enum ChannelBits {
1252         ChannelRed = 1,
1253         ChannelGreen = 2,
1254         ChannelBlue = 4,
1255         ChannelAlpha = 8,
1256         ChannelDepth = 16,
1257         ChannelStencil = 32,
1258         ChannelRGB = ChannelRed | ChannelGreen | ChannelBlue,
1259         ChannelRGBA = ChannelRGB | ChannelAlpha,
1260     };
1261 
1262     static unsigned getChannelBitsByFormat(GC3Denum);
1263 
1264     // Possible alpha operations that may need to occur during
1265     // pixel packing. FIXME: kAlphaDoUnmultiply is lossy and must
1266     // be removed.
1267     enum AlphaOp {
1268         AlphaDoNothing = 0,
1269         AlphaDoPremultiply = 1,
1270         AlphaDoUnmultiply = 2
1271     };
1272 
1273     enum ImageHtmlDomSource {
1274         HtmlDomImage = 0,
1275         HtmlDomCanvas = 1,
1276         HtmlDomVideo = 2,
1277         HtmlDomNone = 3
1278     };
1279 
1280     // Packs the contents of the given Image which is passed in |pixels| into the passed Vector
1281     // according to the given format and type, and obeying the flipY and AlphaOp flags.
1282     // Returns true upon success.
1283     static bool packImageData(Image*, const void* pixels, GC3Denum format, GC3Denum type, bool flipY, AlphaOp, DataFormat sourceFormat, unsigned width, unsigned height, unsigned sourceUnpackAlignment, Vector&lt;uint8_t&gt;&amp; data);
1284 
1285     class ImageExtractor {
1286     public:
1287         ImageExtractor(Image*, ImageHtmlDomSource, bool premultiplyAlpha, bool ignoreGammaAndColorProfile);
1288 
1289         // Each platform must provide an implementation of this method to deallocate or release resources
1290         // associated with the image if needed.
1291         ~ImageExtractor();
1292 
1293         bool extractSucceeded() { return m_extractSucceeded; }
1294         const void* imagePixelData() { return m_imagePixelData; }
1295         unsigned imageWidth() { return m_imageWidth; }
1296         unsigned imageHeight() { return m_imageHeight; }
1297         DataFormat imageSourceFormat() { return m_imageSourceFormat; }
1298         AlphaOp imageAlphaOp() { return m_alphaOp; }
1299         unsigned imageSourceUnpackAlignment() { return m_imageSourceUnpackAlignment; }
1300         ImageHtmlDomSource imageHtmlDomSource() { return m_imageHtmlDomSource; }
1301     private:
1302         // Each platform must provide an implementation of this method.
1303         // Extracts the image and keeps track of its status, such as width, height, Source Alignment, format and AlphaOp etc,
1304         // needs to lock the resources or relevant data if needed and returns true upon success
1305         bool extractImage(bool premultiplyAlpha, bool ignoreGammaAndColorProfile);
1306 
1307 #if USE(CAIRO)
1308         RefPtr&lt;cairo_surface_t&gt; m_imageSurface;
1309 #elif USE(CG)
1310         RetainPtr&lt;CGImageRef&gt; m_cgImage;
1311         RetainPtr&lt;CGImageRef&gt; m_decodedImage;
1312         RetainPtr&lt;CFDataRef&gt; m_pixelData;
1313         UniqueArray&lt;uint8_t&gt; m_formalizedRGBA8Data;
1314 #endif
1315         Image* m_image;
1316         ImageHtmlDomSource m_imageHtmlDomSource;
1317         bool m_extractSucceeded;
1318         const void* m_imagePixelData;
1319         unsigned m_imageWidth;
1320         unsigned m_imageHeight;
1321         DataFormat m_imageSourceFormat;
1322         AlphaOp m_alphaOp;
1323         unsigned m_imageSourceUnpackAlignment;
1324     };
1325 
1326     void setFailNextGPUStatusCheck() { m_failNextStatusCheck = true; }
1327 
1328     GC3Denum activeTextureUnit() const { return m_state.activeTextureUnit; }
1329     GC3Denum currentBoundTexture() const { return m_state.currentBoundTexture(); }
1330     GC3Denum currentBoundTarget() const { return m_state.currentBoundTarget(); }
1331     unsigned textureSeed(GC3Duint texture) { return m_state.textureSeedCount.count(texture); }
1332 
1333 #if PLATFORM(MAC)
1334     using PlatformDisplayID = uint32_t;
1335     void screenDidChange(PlatformDisplayID);
1336 #endif
1337 
1338 private:
1339     GraphicsContext3D(GraphicsContext3DAttributes, HostWindow*, RenderStyle = RenderOffscreen, GraphicsContext3D* sharedContext = nullptr);
1340 
1341     // Helper for packImageData/extractImageData/extractTextureData which implement packing of pixel
1342     // data into the specified OpenGL destination format and type.
1343     // A sourceUnpackAlignment of zero indicates that the source
1344     // data is tightly packed. Non-zero values may take a slow path.
1345     // Destination data will have no gaps between rows.
1346     static bool packPixels(const uint8_t* sourceData, DataFormat sourceDataFormat, unsigned width, unsigned height, unsigned sourceUnpackAlignment, unsigned destinationFormat, unsigned destinationType, AlphaOp, void* destinationData, bool flipY);
1347 
1348     // Take into account the user&#39;s requested context creation attributes,
1349     // in particular stencil and antialias, and determine which could or
1350     // could not be honored based on the capabilities of the OpenGL
1351     // implementation.
1352     void validateDepthStencil(const char* packedDepthStencilExtension);
1353     void validateAttributes();
1354 
1355     // Did the most recent drawing operation leave the GPU in an acceptable state?
1356     void checkGPUStatus();
1357 
1358     // Read rendering results into a pixel array with the same format as the
1359     // backbuffer.
1360     void readRenderingResults(unsigned char* pixels, int pixelsSize);
1361     void readPixelsAndConvertToBGRAIfNecessary(int x, int y, int width, int height, unsigned char* pixels);
1362 
1363 #if PLATFORM(IOS_FAMILY)
1364     void setRenderbufferStorageFromDrawable(GC3Dsizei width, GC3Dsizei height);
1365 #endif
1366 
1367     bool reshapeFBOs(const IntSize&amp;);
1368     void resolveMultisamplingIfNecessary(const IntRect&amp; = IntRect());
1369     void attachDepthAndStencilBufferIfNeeded(GLuint internalDepthStencilFormat, int width, int height);
1370 
1371 #if PLATFORM(COCOA)
1372     bool allowOfflineRenderers() const;
1373 #endif
1374 
1375     int m_currentWidth { 0 };
1376     int m_currentHeight { 0 };
1377 
1378 #if PLATFORM(COCOA)
1379     RetainPtr&lt;WebGLLayer&gt; m_webGLLayer;
1380     PlatformGraphicsContext3D m_contextObj { nullptr };
1381 #if USE(ANGLE)
1382     PlatformGraphicsContext3DDisplay m_displayObj { nullptr };
1383 #endif // USE(ANGLE)
1384 #endif // PLATFORM(COCOA)
1385 
1386 #if PLATFORM(WIN) &amp;&amp; USE(CA)
1387     RefPtr&lt;PlatformCALayer&gt; m_webGLLayer;
1388 #endif
1389 
1390     typedef HashMap&lt;String, sh::ShaderVariable&gt; ShaderSymbolMap;
1391 
1392     struct ShaderSourceEntry {
1393         GC3Denum type;
1394         String source;
1395         String translatedSource;
1396         String log;
1397         bool isValid;
1398         ShaderSymbolMap attributeMap;
1399         ShaderSymbolMap uniformMap;
1400         ShaderSymbolMap varyingMap;
1401         ShaderSourceEntry()
1402             : type(VERTEX_SHADER)
1403             , isValid(false)
1404         {
1405         }
1406 
1407         ShaderSymbolMap&amp; symbolMap(enum ANGLEShaderSymbolType symbolType)
1408         {
1409             ASSERT(symbolType == SHADER_SYMBOL_TYPE_ATTRIBUTE || symbolType == SHADER_SYMBOL_TYPE_UNIFORM || symbolType == SHADER_SYMBOL_TYPE_VARYING);
1410             if (symbolType == SHADER_SYMBOL_TYPE_ATTRIBUTE)
1411                 return attributeMap;
1412             if (symbolType == SHADER_SYMBOL_TYPE_VARYING)
1413                 return varyingMap;
1414             return uniformMap;
1415         }
1416     };
1417 
1418 #if !USE(ANGLE)
1419     // FIXME: Shaders are never removed from this map, even if they and their program are deleted.
1420     // This is bad, and it also relies on the fact we never reuse Platform3DObject numbers.
1421     typedef HashMap&lt;Platform3DObject, ShaderSourceEntry&gt; ShaderSourceMap;
1422     ShaderSourceMap m_shaderSourceMap;
1423 
1424     typedef HashMap&lt;Platform3DObject, std::pair&lt;Platform3DObject, Platform3DObject&gt;&gt; LinkedShaderMap;
1425     LinkedShaderMap m_linkedShaderMap;
1426 
1427     struct ActiveShaderSymbolCounts {
1428         Vector&lt;GC3Dint&gt; filteredToActualAttributeIndexMap;
1429         Vector&lt;GC3Dint&gt; filteredToActualUniformIndexMap;
1430 
1431         ActiveShaderSymbolCounts()
1432         {
1433         }
1434 
1435         GC3Dint countForType(GC3Denum activeType)
1436         {
1437             ASSERT(activeType == ACTIVE_ATTRIBUTES || activeType == ACTIVE_UNIFORMS);
1438             if (activeType == ACTIVE_ATTRIBUTES)
1439                 return filteredToActualAttributeIndexMap.size();
1440 
1441             return filteredToActualUniformIndexMap.size();
1442         }
1443     };
1444     typedef HashMap&lt;Platform3DObject, ActiveShaderSymbolCounts&gt; ShaderProgramSymbolCountMap;
1445     ShaderProgramSymbolCountMap m_shaderProgramSymbolCountMap;
1446 
1447     typedef HashMap&lt;String, String&gt; HashedSymbolMap;
1448     HashedSymbolMap m_possiblyUnusedAttributeMap;
1449 
1450     String mappedSymbolName(Platform3DObject program, ANGLEShaderSymbolType, const String&amp; name);
1451     String mappedSymbolName(Platform3DObject shaders[2], size_t count, const String&amp; name);
1452     String originalSymbolName(Platform3DObject program, ANGLEShaderSymbolType, const String&amp; name);
1453     Optional&lt;String&gt; mappedSymbolInShaderSourceMap(Platform3DObject shader, ANGLEShaderSymbolType, const String&amp; name);
1454     Optional&lt;String&gt; originalSymbolInShaderSourceMap(Platform3DObject shader, ANGLEShaderSymbolType, const String&amp; name);
1455 
1456     std::unique_ptr&lt;ShaderNameHash&gt; nameHashMapForShaders;
1457 #endif // !USE(ANGLE)
1458 
1459 #if !PLATFORM(COCOA) &amp;&amp; USE(OPENGL_ES)
1460     friend class Extensions3DOpenGLES;
1461     friend class Extensions3DOpenGLCommon;
1462     std::unique_ptr&lt;Extensions3DOpenGLES&gt; m_extensions;
1463 #elif USE(OPENGL) || (PLATFORM(COCOA) &amp;&amp; USE(OPENGL_ES))
1464     friend class Extensions3DOpenGL;
1465     friend class Extensions3DOpenGLCommon;
1466     std::unique_ptr&lt;Extensions3DOpenGL&gt; m_extensions;
1467 #elif USE(ANGLE)
1468     friend class Extensions3DANGLE;
1469     std::unique_ptr&lt;Extensions3DANGLE&gt; m_extensions;
1470 #endif
1471 
1472     GraphicsContext3DAttributes m_attrs;
1473     GraphicsContext3DPowerPreference m_powerPreferenceUsedForCreation { GraphicsContext3DPowerPreference::Default };
1474     RenderStyle m_renderStyle;
1475     Vector&lt;Vector&lt;float&gt;&gt; m_vertexArray;
1476 
1477 #if !USE(ANGLE)
1478     ANGLEWebKitBridge m_compiler;
1479 #endif
1480 
1481     GC3Duint m_texture { 0 };
1482     GC3Duint m_fbo { 0 };
1483 #if USE(COORDINATED_GRAPHICS)
1484     GC3Duint m_compositorTexture { 0 };
1485     GC3Duint m_intermediateTexture { 0 };
1486 #endif
1487 
1488     GC3Duint m_depthBuffer { 0 };
1489     GC3Duint m_stencilBuffer { 0 };
1490     GC3Duint m_depthStencilBuffer { 0 };
1491 
1492     bool m_layerComposited { false };
1493     GC3Duint m_internalColorFormat { 0 };
1494 
1495 #if USE(ANGLE)
1496     PlatformGraphicsContext3DSurface m_pbuffer;
1497 #endif
1498 
1499     struct GraphicsContext3DState {
1500         GC3Duint boundFBO { 0 };
1501         GC3Denum activeTextureUnit { GraphicsContext3D::TEXTURE0 };
1502 
1503         using BoundTextureMap = HashMap&lt;GC3Denum,
1504             std::pair&lt;GC3Duint, GC3Denum&gt;,
1505             WTF::IntHash&lt;GC3Denum&gt;,
1506             WTF::UnsignedWithZeroKeyHashTraits&lt;GC3Duint&gt;,
1507             WTF::PairHashTraits&lt;WTF::UnsignedWithZeroKeyHashTraits&lt;GC3Duint&gt;, WTF::UnsignedWithZeroKeyHashTraits&lt;GC3Duint&gt;&gt;
1508         &gt;;
1509         BoundTextureMap boundTextureMap;
1510         GC3Duint currentBoundTexture() const { return boundTexture(activeTextureUnit); }
1511         GC3Duint boundTexture(GC3Denum textureUnit) const
1512         {
1513             auto iterator = boundTextureMap.find(textureUnit);
1514             if (iterator != boundTextureMap.end())
1515                 return iterator-&gt;value.first;
1516             return 0;
1517         }
1518 
1519         GC3Duint currentBoundTarget() const { return boundTarget(activeTextureUnit); }
1520         GC3Denum boundTarget(GC3Denum textureUnit) const
1521         {
1522             auto iterator = boundTextureMap.find(textureUnit);
1523             if (iterator != boundTextureMap.end())
1524                 return iterator-&gt;value.second;
1525             return 0;
1526         }
1527 
1528         void setBoundTexture(GC3Denum textureUnit, GC3Duint texture, GC3Denum target)
1529         {
1530             boundTextureMap.set(textureUnit, std::make_pair(texture, target));
1531         }
1532 
1533         using TextureSeedCount = HashCountedSet&lt;GC3Duint, WTF::IntHash&lt;GC3Duint&gt;, WTF::UnsignedWithZeroKeyHashTraits&lt;GC3Duint&gt;&gt;;
1534         TextureSeedCount textureSeedCount;
1535     };
1536 
1537     GraphicsContext3DState m_state;
1538 
1539     // For multisampling
1540     GC3Duint m_multisampleFBO { 0 };
1541     GC3Duint m_multisampleDepthStencilBuffer { 0 };
1542     GC3Duint m_multisampleColorBuffer { 0 };
1543 
1544     // Errors raised by synthesizeGLError().
1545     ListHashSet&lt;GC3Denum&gt; m_syntheticErrors;
1546 
1547 #if USE(NICOSIA) &amp;&amp; USE(TEXTURE_MAPPER)
1548     friend class Nicosia::GC3DLayer;
1549     std::unique_ptr&lt;Nicosia::GC3DLayer&gt; m_nicosiaLayer;
1550 #elif USE(TEXTURE_MAPPER)
1551     friend class TextureMapperGC3DPlatformLayer;
1552     std::unique_ptr&lt;TextureMapperGC3DPlatformLayer&gt; m_texmapLayer;
1553 #else
1554     friend class GraphicsContext3DPrivate;
1555     std::unique_ptr&lt;GraphicsContext3DPrivate&gt; m_private;
1556 #endif
1557 
1558     HashSet&lt;Client*&gt; m_clients;
1559 
1560     bool m_isForWebGL2 { false };
1561     bool m_usingCoreProfile { false };
1562 
1563     unsigned m_statusCheckCount { 0 };
1564     bool m_failNextStatusCheck { false };
1565 
1566 #if USE(CAIRO)
1567     Platform3DObject m_vao { 0 };
1568 #endif
1569 
1570 #if PLATFORM(COCOA) &amp;&amp; USE(OPENGL)
1571     bool m_hasSwitchedToHighPerformanceGPU { false };
1572 #endif
1573 };
1574 
1575 } // namespace WebCore
1576 
1577 #endif
    </pre>
  </body>
</html>