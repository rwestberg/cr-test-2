<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WebCore/editing/EditorCommand.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2006-2008, 2014, 2016 Apple Inc. All rights reserved.
   3  * Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies)
   4  * Copyright (C) 2009 Igalia S.L.
   5  *
   6  * Redistribution and use in source and binary forms, with or without
   7  * modification, are permitted provided that the following conditions
   8  * are met:
   9  * 1. Redistributions of source code must retain the above copyright
  10  *    notice, this list of conditions and the following disclaimer.
  11  * 2. Redistributions in binary form must reproduce the above copyright
  12  *    notice, this list of conditions and the following disclaimer in the
  13  *    documentation and/or other materials provided with the distribution.
  14  *
  15  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  16  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  17  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  18  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  19  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  20  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  21  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  22  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  23  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  24  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  25  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  26  */
  27 
  28 #include &quot;config.h&quot;
  29 #include &quot;Editor.h&quot;
  30 
  31 #include &quot;CSSComputedStyleDeclaration.h&quot;
  32 #include &quot;CSSValueList.h&quot;
  33 #include &quot;Chrome.h&quot;
  34 #include &quot;CreateLinkCommand.h&quot;
  35 #include &quot;DocumentFragment.h&quot;
  36 #include &quot;Editing.h&quot;
  37 #include &quot;EditorClient.h&quot;
  38 #include &quot;Event.h&quot;
  39 #include &quot;EventHandler.h&quot;
  40 #include &quot;FormatBlockCommand.h&quot;
  41 #include &quot;Frame.h&quot;
  42 #include &quot;FrameLoader.h&quot;
  43 #include &quot;FrameView.h&quot;
  44 #include &quot;HTMLFontElement.h&quot;
  45 #include &quot;HTMLHRElement.h&quot;
  46 #include &quot;HTMLImageElement.h&quot;
  47 #include &quot;HTMLNames.h&quot;
  48 #include &quot;IndentOutdentCommand.h&quot;
  49 #include &quot;InsertEditableImageCommand.h&quot;
  50 #include &quot;InsertListCommand.h&quot;
  51 #include &quot;InsertNestedListCommand.h&quot;
  52 #include &quot;Page.h&quot;
  53 #include &quot;Pasteboard.h&quot;
  54 #include &quot;RenderBox.h&quot;
  55 #include &quot;ReplaceSelectionCommand.h&quot;
  56 #include &quot;Scrollbar.h&quot;
  57 #include &quot;Settings.h&quot;
  58 #include &quot;StyleProperties.h&quot;
  59 #include &quot;TypingCommand.h&quot;
  60 #include &quot;UnlinkCommand.h&quot;
  61 #include &quot;UserGestureIndicator.h&quot;
  62 #include &quot;UserTypingGestureIndicator.h&quot;
  63 #include &quot;markup.h&quot;
  64 #include &lt;pal/system/Sound.h&gt;
  65 #include &lt;pal/text/KillRing.h&gt;
  66 #include &lt;wtf/text/AtomicString.h&gt;
  67 
  68 namespace WebCore {
  69 
  70 using namespace HTMLNames;
  71 
  72 class EditorInternalCommand {
  73 public:
  74     bool (*execute)(Frame&amp;, Event*, EditorCommandSource, const String&amp;);
  75     bool (*isSupportedFromDOM)(Frame*);
  76     bool (*isEnabled)(Frame&amp;, Event*, EditorCommandSource);
  77     TriState (*state)(Frame&amp;, Event*);
  78     String (*value)(Frame&amp;, Event*);
  79     bool isTextInsertion;
  80     bool (*allowExecutionWhenDisabled)(Frame&amp;, EditorCommandSource);
  81 };
  82 
  83 typedef HashMap&lt;String, const EditorInternalCommand*, ASCIICaseInsensitiveHash&gt; CommandMap;
  84 
  85 static const bool notTextInsertion = false;
  86 static const bool isTextInsertion = true;
  87 
  88 // Related to Editor::selectionForCommand.
  89 // Certain operations continue to use the target control&#39;s selection even if the event handler
  90 // already moved the selection outside of the text control.
  91 static Frame* targetFrame(Frame&amp; frame, Event* event)
  92 {
  93     if (!event)
  94         return &amp;frame;
  95     if (!is&lt;Node&gt;(event-&gt;target()))
  96         return &amp;frame;
  97     return downcast&lt;Node&gt;(*event-&gt;target()).document().frame();
  98 }
  99 
 100 static bool applyCommandToFrame(Frame&amp; frame, EditorCommandSource source, EditAction action, Ref&lt;EditingStyle&gt;&amp;&amp; style)
 101 {
 102     // FIXME: We don&#39;t call shouldApplyStyle when the source is DOM; is there a good reason for that?
 103     switch (source) {
 104     case CommandFromMenuOrKeyBinding:
 105         // Use InvertColor for testing purposes. foreColor and backColor are never triggered with CommandFromMenuOrKeyBinding outside DRT/WTR.
 106         frame.editor().applyStyleToSelection(WTFMove(style), action, Editor::ColorFilterMode::InvertColor);
 107         return true;
 108     case CommandFromDOM:
 109     case CommandFromDOMWithUserInterface:
 110         frame.editor().applyStyle(WTFMove(style), EditAction::Unspecified, Editor::ColorFilterMode::UseOriginalColor);
 111         return true;
 112     }
 113     ASSERT_NOT_REACHED();
 114     return false;
 115 }
 116 
 117 static bool isStylePresent(Editor&amp; editor, CSSPropertyID propertyID, const char* onValue)
 118 {
 119     // Style is considered present when
 120     // Mac: present at the beginning of selection
 121     // Windows: present throughout the selection
 122     if (editor.behavior().shouldToggleStyleBasedOnStartOfSelection())
 123         return editor.selectionStartHasStyle(propertyID, onValue);
 124     return editor.selectionHasStyle(propertyID, onValue) == TrueTriState;
 125 }
 126 
 127 static bool executeApplyStyle(Frame&amp; frame, EditorCommandSource source, EditAction action, CSSPropertyID propertyID, const String&amp; propertyValue)
 128 {
 129     return applyCommandToFrame(frame, source, action, EditingStyle::create(propertyID, propertyValue));
 130 }
 131 
 132 static bool executeApplyStyle(Frame&amp; frame, EditorCommandSource source, EditAction action, CSSPropertyID propertyID, CSSValueID propertyValue)
 133 {
 134     return applyCommandToFrame(frame, source, action, EditingStyle::create(propertyID, propertyValue));
 135 }
 136 
 137 static bool executeToggleStyle(Frame&amp; frame, EditorCommandSource source, EditAction action, CSSPropertyID propertyID, const char* offValue, const char* onValue)
 138 {
 139     bool styleIsPresent = isStylePresent(frame.editor(), propertyID, onValue);
 140     return applyCommandToFrame(frame, source, action, EditingStyle::create(propertyID, styleIsPresent ? offValue : onValue));
 141 }
 142 
 143 static bool executeApplyParagraphStyle(Frame&amp; frame, EditorCommandSource source, EditAction action, CSSPropertyID propertyID, const String&amp; propertyValue)
 144 {
 145     auto style = MutableStyleProperties::create();
 146     style-&gt;setProperty(propertyID, propertyValue);
 147     // FIXME: We don&#39;t call shouldApplyStyle when the source is DOM; is there a good reason for that?
 148     switch (source) {
 149     case CommandFromMenuOrKeyBinding:
 150         frame.editor().applyParagraphStyleToSelection(style.ptr(), action);
 151         return true;
 152     case CommandFromDOM:
 153     case CommandFromDOMWithUserInterface:
 154         frame.editor().applyParagraphStyle(style.ptr());
 155         return true;
 156     }
 157     ASSERT_NOT_REACHED();
 158     return false;
 159 }
 160 
 161 static bool executeInsertFragment(Frame&amp; frame, Ref&lt;DocumentFragment&gt;&amp;&amp; fragment)
 162 {
 163     ASSERT(frame.document());
 164     ReplaceSelectionCommand::create(*frame.document(), WTFMove(fragment), ReplaceSelectionCommand::PreventNesting, EditAction::Insert)-&gt;apply();
 165     return true;
 166 }
 167 
 168 static bool executeInsertNode(Frame&amp; frame, Ref&lt;Node&gt;&amp;&amp; content)
 169 {
 170     auto fragment = DocumentFragment::create(*frame.document());
 171     if (fragment-&gt;appendChild(content).hasException())
 172         return false;
 173     return executeInsertFragment(frame, WTFMove(fragment));
 174 }
 175 
 176 static bool expandSelectionToGranularity(Frame&amp; frame, TextGranularity granularity)
 177 {
 178     VisibleSelection selection = frame.selection().selection();
 179     selection.expandUsingGranularity(granularity);
 180     RefPtr&lt;Range&gt; newRange = selection.toNormalizedRange();
 181     if (!newRange)
 182         return false;
 183     if (newRange-&gt;collapsed())
 184         return false;
 185     RefPtr&lt;Range&gt; oldRange = selection.toNormalizedRange();
 186     EAffinity affinity = selection.affinity();
 187     if (!frame.editor().client()-&gt;shouldChangeSelectedRange(oldRange.get(), newRange.get(), affinity, false))
 188         return false;
 189     frame.selection().setSelectedRange(newRange.get(), affinity, FrameSelection::ShouldCloseTyping::Yes);
 190     return true;
 191 }
 192 
 193 static TriState stateStyle(Frame&amp; frame, CSSPropertyID propertyID, const char* desiredValue)
 194 {
 195     if (frame.editor().behavior().shouldToggleStyleBasedOnStartOfSelection())
 196         return frame.editor().selectionStartHasStyle(propertyID, desiredValue) ? TrueTriState : FalseTriState;
 197     return frame.editor().selectionHasStyle(propertyID, desiredValue);
 198 }
 199 
 200 static String valueStyle(Frame&amp; frame, CSSPropertyID propertyID)
 201 {
 202     // FIXME: Rather than retrieving the style at the start of the current selection,
 203     // we should retrieve the style present throughout the selection for non-Mac platforms.
 204     return frame.editor().selectionStartCSSPropertyValue(propertyID);
 205 }
 206 
 207 static TriState stateTextWritingDirection(Frame&amp; frame, WritingDirection direction)
 208 {
 209     bool hasNestedOrMultipleEmbeddings;
 210     WritingDirection selectionDirection = EditingStyle::textDirectionForSelection(frame.selection().selection(),
 211         frame.selection().typingStyle(), hasNestedOrMultipleEmbeddings);
 212     // FXIME: We should be returning MixedTriState when selectionDirection == direction &amp;&amp; hasNestedOrMultipleEmbeddings
 213     return (selectionDirection == direction &amp;&amp; !hasNestedOrMultipleEmbeddings) ? TrueTriState : FalseTriState;
 214 }
 215 
 216 static unsigned verticalScrollDistance(Frame&amp; frame)
 217 {
 218     Element* focusedElement = frame.document()-&gt;focusedElement();
 219     if (!focusedElement)
 220         return 0;
 221     auto* renderer = focusedElement-&gt;renderer();
 222     if (!is&lt;RenderBox&gt;(renderer))
 223         return 0;
 224     const RenderStyle&amp; style = renderer-&gt;style();
 225     if (!(style.overflowY() == Overflow::Scroll || style.overflowY() == Overflow::Auto || focusedElement-&gt;hasEditableStyle()))
 226         return 0;
 227     int height = std::min&lt;int&gt;(downcast&lt;RenderBox&gt;(*renderer).clientHeight(), frame.view()-&gt;visibleHeight());
 228     return static_cast&lt;unsigned&gt;(Scrollbar::pageStep(height));
 229 }
 230 
 231 static RefPtr&lt;Range&gt; unionDOMRanges(Range&amp; a, Range&amp; b)
 232 {
 233     Range&amp; start = a.compareBoundaryPoints(Range::START_TO_START, b).releaseReturnValue() &lt;= 0 ? a : b;
 234     Range&amp; end = a.compareBoundaryPoints(Range::END_TO_END, b).releaseReturnValue() &lt;= 0 ? b : a;
 235     return Range::create(a.ownerDocument(), &amp;start.startContainer(), start.startOffset(), &amp;end.endContainer(), end.endOffset());
 236 }
 237 
 238 // Execute command functions
 239 
 240 static bool executeBackColor(Frame&amp; frame, Event*, EditorCommandSource source, const String&amp; value)
 241 {
 242     return executeApplyStyle(frame, source, EditAction::SetBackgroundColor, CSSPropertyBackgroundColor, value);
 243 }
 244 
 245 static bool executeCopy(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 246 {
 247     frame.editor().copy();
 248     return true;
 249 }
 250 
 251 static bool executeCreateLink(Frame&amp; frame, Event*, EditorCommandSource, const String&amp; value)
 252 {
 253     // FIXME: If userInterface is true, we should display a dialog box to let the user enter a URL.
 254     if (value.isEmpty())
 255         return false;
 256     ASSERT(frame.document());
 257     CreateLinkCommand::create(*frame.document(), value)-&gt;apply();
 258     return true;
 259 }
 260 
 261 static bool executeCut(Frame&amp; frame, Event*, EditorCommandSource source, const String&amp;)
 262 {
 263     if (source == CommandFromMenuOrKeyBinding) {
 264         UserTypingGestureIndicator typingGestureIndicator(frame);
 265         frame.editor().cut();
 266     } else
 267         frame.editor().cut();
 268     return true;
 269 }
 270 
 271 static bool executeClearText(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 272 {
 273     frame.editor().clearText();
 274     return true;
 275 }
 276 
 277 static bool executeDefaultParagraphSeparator(Frame&amp; frame, Event*, EditorCommandSource, const String&amp; value)
 278 {
 279     if (equalLettersIgnoringASCIICase(value, &quot;div&quot;))
 280         frame.editor().setDefaultParagraphSeparator(EditorParagraphSeparatorIsDiv);
 281     else if (equalLettersIgnoringASCIICase(value, &quot;p&quot;))
 282         frame.editor().setDefaultParagraphSeparator(EditorParagraphSeparatorIsP);
 283 
 284     return true;
 285 }
 286 
 287 static bool executeDelete(Frame&amp; frame, Event*, EditorCommandSource source, const String&amp;)
 288 {
 289     switch (source) {
 290     case CommandFromMenuOrKeyBinding: {
 291         // Doesn&#39;t modify the text if the current selection isn&#39;t a range.
 292         UserTypingGestureIndicator typingGestureIndicator(frame);
 293         frame.editor().performDelete();
 294         return true;
 295     }
 296     case CommandFromDOM:
 297     case CommandFromDOMWithUserInterface:
 298         // If the current selection is a caret, delete the preceding character. IE performs forwardDelete, but we currently side with Firefox.
 299         // Doesn&#39;t scroll to make the selection visible, or modify the kill ring (this time, siding with IE, not Firefox).
 300         TypingCommand::deleteKeyPressed(*frame.document(), frame.selection().granularity() == WordGranularity ? TypingCommand::SmartDelete : 0);
 301         return true;
 302     }
 303     ASSERT_NOT_REACHED();
 304     return false;
 305 }
 306 
 307 static bool executeDeleteBackward(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 308 {
 309     frame.editor().deleteWithDirection(DirectionBackward, CharacterGranularity, false, true);
 310     return true;
 311 }
 312 
 313 static bool executeDeleteBackwardByDecomposingPreviousCharacter(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 314 {
 315     LOG_ERROR(&quot;DeleteBackwardByDecomposingPreviousCharacter is not implemented, doing DeleteBackward instead&quot;);
 316     frame.editor().deleteWithDirection(DirectionBackward, CharacterGranularity, false, true);
 317     return true;
 318 }
 319 
 320 static bool executeDeleteForward(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 321 {
 322     frame.editor().deleteWithDirection(DirectionForward, CharacterGranularity, false, true);
 323     return true;
 324 }
 325 
 326 static bool executeDeleteToBeginningOfLine(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 327 {
 328     frame.editor().deleteWithDirection(DirectionBackward, LineBoundary, true, false);
 329     return true;
 330 }
 331 
 332 static bool executeDeleteToBeginningOfParagraph(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 333 {
 334     frame.editor().deleteWithDirection(DirectionBackward, ParagraphBoundary, true, false);
 335     return true;
 336 }
 337 
 338 static bool executeDeleteToEndOfLine(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 339 {
 340     // Despite its name, this command should delete the newline at the end of
 341     // a paragraph if you are at the end of a paragraph (like DeleteToEndOfParagraph).
 342     frame.editor().deleteWithDirection(DirectionForward, LineBoundary, true, false);
 343     return true;
 344 }
 345 
 346 static bool executeDeleteToEndOfParagraph(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 347 {
 348     // Despite its name, this command should delete the newline at the end of
 349     // a paragraph if you are at the end of a paragraph.
 350     frame.editor().deleteWithDirection(DirectionForward, ParagraphBoundary, true, false);
 351     return true;
 352 }
 353 
 354 static bool executeDeleteToMark(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 355 {
 356     RefPtr&lt;Range&gt; mark = frame.editor().mark().toNormalizedRange();
 357     FrameSelection&amp; selection = frame.selection();
 358     if (mark &amp;&amp; frame.editor().selectedRange()) {
 359         bool selected = selection.setSelectedRange(unionDOMRanges(*mark, *frame.editor().selectedRange()).get(), DOWNSTREAM, FrameSelection::ShouldCloseTyping::Yes);
 360         ASSERT(selected);
 361         if (!selected)
 362             return false;
 363     }
 364     frame.editor().performDelete();
 365     frame.editor().setMark(selection.selection());
 366     return true;
 367 }
 368 
 369 static bool executeDeleteWordBackward(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 370 {
 371     frame.editor().deleteWithDirection(DirectionBackward, WordGranularity, true, false);
 372     return true;
 373 }
 374 
 375 static bool executeDeleteWordForward(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 376 {
 377     frame.editor().deleteWithDirection(DirectionForward, WordGranularity, true, false);
 378     return true;
 379 }
 380 
 381 static bool executeFindString(Frame&amp; frame, Event*, EditorCommandSource, const String&amp; value)
 382 {
 383     return frame.editor().findString(value, { CaseInsensitive, WrapAround, DoNotTraverseFlatTree });
 384 }
 385 
 386 static bool executeFontName(Frame&amp; frame, Event*, EditorCommandSource source, const String&amp; value)
 387 {
 388     return executeApplyStyle(frame, source, EditAction::SetFont, CSSPropertyFontFamily, value);
 389 }
 390 
 391 static bool executeFontSize(Frame&amp; frame, Event*, EditorCommandSource source, const String&amp; value)
 392 {
 393     CSSValueID size;
 394     if (!HTMLFontElement::cssValueFromFontSizeNumber(value, size))
 395         return false;
 396     return executeApplyStyle(frame, source, EditAction::ChangeAttributes, CSSPropertyFontSize, size);
 397 }
 398 
 399 static bool executeFontSizeDelta(Frame&amp; frame, Event*, EditorCommandSource source, const String&amp; value)
 400 {
 401     return executeApplyStyle(frame, source, EditAction::ChangeAttributes, CSSPropertyWebkitFontSizeDelta, value);
 402 }
 403 
 404 static bool executeForeColor(Frame&amp; frame, Event*, EditorCommandSource source, const String&amp; value)
 405 {
 406     return executeApplyStyle(frame, source, EditAction::SetColor, CSSPropertyColor, value);
 407 }
 408 
 409 static bool executeFormatBlock(Frame&amp; frame, Event*, EditorCommandSource, const String&amp; value)
 410 {
 411     String tagName = value.convertToASCIILowercase();
 412     if (tagName[0] == &#39;&lt;&#39; &amp;&amp; tagName[tagName.length() - 1] == &#39;&gt;&#39;)
 413         tagName = tagName.substring(1, tagName.length() - 2);
 414 
 415     auto qualifiedTagName = Document::parseQualifiedName(xhtmlNamespaceURI, tagName);
 416     if (qualifiedTagName.hasException())
 417         return false;
 418 
 419     ASSERT(frame.document());
 420     auto command = FormatBlockCommand::create(*frame.document(), qualifiedTagName.releaseReturnValue());
 421     command-&gt;apply();
 422     return command-&gt;didApply();
 423 }
 424 
 425 static bool executeForwardDelete(Frame&amp; frame, Event*, EditorCommandSource source, const String&amp;)
 426 {
 427     switch (source) {
 428     case CommandFromMenuOrKeyBinding:
 429         frame.editor().deleteWithDirection(DirectionForward, CharacterGranularity, false, true);
 430         return true;
 431     case CommandFromDOM:
 432     case CommandFromDOMWithUserInterface:
 433         // Doesn&#39;t scroll to make the selection visible, or modify the kill ring.
 434         // ForwardDelete is not implemented in IE or Firefox, so this behavior is only needed for
 435         // backward compatibility with ourselves, and for consistency with Delete.
 436         TypingCommand::forwardDeleteKeyPressed(*frame.document());
 437         return true;
 438     }
 439     ASSERT_NOT_REACHED();
 440     return false;
 441 }
 442 
 443 static bool executeIgnoreSpelling(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 444 {
 445     frame.editor().ignoreSpelling();
 446     return true;
 447 }
 448 
 449 static bool executeIndent(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 450 {
 451     ASSERT(frame.document());
 452     IndentOutdentCommand::create(*frame.document(), IndentOutdentCommand::Indent)-&gt;apply();
 453     return true;
 454 }
 455 
 456 static bool executeInsertBacktab(Frame&amp; frame, Event* event, EditorCommandSource, const String&amp;)
 457 {
 458     return targetFrame(frame, event)-&gt;eventHandler().handleTextInputEvent(&quot;\t&quot;_s, event, TextEventInputBackTab);
 459 }
 460 
 461 static bool executeInsertHorizontalRule(Frame&amp; frame, Event*, EditorCommandSource, const String&amp; value)
 462 {
 463     Ref&lt;HTMLHRElement&gt; rule = HTMLHRElement::create(*frame.document());
 464     if (!value.isEmpty())
 465         rule-&gt;setIdAttribute(value);
 466     return executeInsertNode(frame, WTFMove(rule));
 467 }
 468 
 469 static bool executeInsertHTML(Frame&amp; frame, Event*, EditorCommandSource, const String&amp; value)
 470 {
 471     return executeInsertFragment(frame, createFragmentFromMarkup(*frame.document(), value, emptyString()));
 472 }
 473 
 474 static bool executeInsertImage(Frame&amp; frame, Event*, EditorCommandSource, const String&amp; value)
 475 {
 476     // FIXME: If userInterface is true, we should display a dialog box and let the user choose a local image.
 477     Ref&lt;HTMLImageElement&gt; image = HTMLImageElement::create(*frame.document());
 478     image-&gt;setSrc(value);
 479     return executeInsertNode(frame, WTFMove(image));
 480 }
 481 
 482 static bool executeInsertEditableImage(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 483 {
 484     ASSERT(frame.document());
 485     InsertEditableImageCommand::create(*frame.document())-&gt;apply();
 486     return true;
 487 }
 488 
 489 static bool executeInsertLineBreak(Frame&amp; frame, Event* event, EditorCommandSource source, const String&amp;)
 490 {
 491     switch (source) {
 492     case CommandFromMenuOrKeyBinding:
 493         return targetFrame(frame, event)-&gt;eventHandler().handleTextInputEvent(&quot;\n&quot;_s, event, TextEventInputLineBreak);
 494     case CommandFromDOM:
 495     case CommandFromDOMWithUserInterface:
 496         // Doesn&#39;t scroll to make the selection visible, or modify the kill ring.
 497         // InsertLineBreak is not implemented in IE or Firefox, so this behavior is only needed for
 498         // backward compatibility with ourselves, and for consistency with other commands.
 499         TypingCommand::insertLineBreak(*frame.document(), 0);
 500         return true;
 501     }
 502     ASSERT_NOT_REACHED();
 503     return false;
 504 }
 505 
 506 static bool executeInsertNewline(Frame&amp; frame, Event* event, EditorCommandSource, const String&amp;)
 507 {
 508     Frame* targetFrame = WebCore::targetFrame(frame, event);
 509     return targetFrame-&gt;eventHandler().handleTextInputEvent(&quot;\n&quot;_s, event, targetFrame-&gt;editor().canEditRichly() ? TextEventInputKeyboard : TextEventInputLineBreak);
 510 }
 511 
 512 static bool executeInsertNewlineInQuotedContent(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 513 {
 514     TypingCommand::insertParagraphSeparatorInQuotedContent(*frame.document());
 515     return true;
 516 }
 517 
 518 static bool executeInsertOrderedList(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 519 {
 520     ASSERT(frame.document());
 521     InsertListCommand::create(*frame.document(), InsertListCommand::Type::OrderedList)-&gt;apply();
 522     return true;
 523 }
 524 
 525 static bool executeInsertParagraph(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 526 {
 527     TypingCommand::insertParagraphSeparator(*frame.document(), 0);
 528     return true;
 529 }
 530 
 531 static bool executeInsertTab(Frame&amp; frame, Event* event, EditorCommandSource, const String&amp;)
 532 {
 533     return targetFrame(frame, event)-&gt;eventHandler().handleTextInputEvent(&quot;\t&quot;_s, event);
 534 }
 535 
 536 static bool executeInsertText(Frame&amp; frame, Event*, EditorCommandSource, const String&amp; value)
 537 {
 538     TypingCommand::insertText(*frame.document(), value, 0);
 539     return true;
 540 }
 541 
 542 static bool executeInsertUnorderedList(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 543 {
 544     ASSERT(frame.document());
 545     InsertListCommand::create(*frame.document(), InsertListCommand::Type::UnorderedList)-&gt;apply();
 546     return true;
 547 }
 548 
 549 static bool executeInsertNestedUnorderedList(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 550 {
 551     ASSERT(frame.document());
 552     InsertNestedListCommand::insertUnorderedList(*frame.document());
 553     return true;
 554 }
 555 
 556 static bool executeInsertNestedOrderedList(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 557 {
 558     ASSERT(frame.document());
 559     InsertNestedListCommand::insertOrderedList(*frame.document());
 560     return true;
 561 }
 562 
 563 static bool executeJustifyCenter(Frame&amp; frame, Event*, EditorCommandSource source, const String&amp;)
 564 {
 565     return executeApplyParagraphStyle(frame, source, EditAction::Center, CSSPropertyTextAlign, &quot;center&quot;_s);
 566 }
 567 
 568 static bool executeJustifyFull(Frame&amp; frame, Event*, EditorCommandSource source, const String&amp;)
 569 {
 570     return executeApplyParagraphStyle(frame, source, EditAction::Justify, CSSPropertyTextAlign, &quot;justify&quot;_s);
 571 }
 572 
 573 static bool executeJustifyLeft(Frame&amp; frame, Event*, EditorCommandSource source, const String&amp;)
 574 {
 575     return executeApplyParagraphStyle(frame, source, EditAction::AlignLeft, CSSPropertyTextAlign, &quot;left&quot;_s);
 576 }
 577 
 578 static bool executeJustifyRight(Frame&amp; frame, Event*, EditorCommandSource source, const String&amp;)
 579 {
 580     return executeApplyParagraphStyle(frame, source, EditAction::AlignRight, CSSPropertyTextAlign, &quot;right&quot;_s);
 581 }
 582 
 583 static bool executeMakeTextWritingDirectionLeftToRight(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 584 {
 585     auto style = MutableStyleProperties::create();
 586     style-&gt;setProperty(CSSPropertyUnicodeBidi, CSSValueEmbed);
 587     style-&gt;setProperty(CSSPropertyDirection, CSSValueLtr);
 588     frame.editor().applyStyle(style.ptr(), EditAction::SetWritingDirection);
 589     return true;
 590 }
 591 
 592 static bool executeMakeTextWritingDirectionNatural(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 593 {
 594     auto style = MutableStyleProperties::create();
 595     style-&gt;setProperty(CSSPropertyUnicodeBidi, CSSValueNormal);
 596     frame.editor().applyStyle(style.ptr(), EditAction::SetWritingDirection);
 597     return true;
 598 }
 599 
 600 static bool executeMakeTextWritingDirectionRightToLeft(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 601 {
 602     auto style = MutableStyleProperties::create();
 603     style-&gt;setProperty(CSSPropertyUnicodeBidi, CSSValueEmbed);
 604     style-&gt;setProperty(CSSPropertyDirection, CSSValueRtl);
 605     frame.editor().applyStyle(style.ptr(), EditAction::SetWritingDirection);
 606     return true;
 607 }
 608 
 609 static bool executeMoveBackward(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 610 {
 611     frame.selection().modify(FrameSelection::AlterationMove, DirectionBackward, CharacterGranularity, UserTriggered);
 612     return true;
 613 }
 614 
 615 static bool executeMoveBackwardAndModifySelection(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 616 {
 617     frame.selection().modify(FrameSelection::AlterationExtend, DirectionBackward, CharacterGranularity, UserTriggered);
 618     return true;
 619 }
 620 
 621 static bool executeMoveDown(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 622 {
 623     return frame.selection().modify(FrameSelection::AlterationMove, DirectionForward, LineGranularity, UserTriggered);
 624 }
 625 
 626 static bool executeMoveDownAndModifySelection(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 627 {
 628     frame.selection().modify(FrameSelection::AlterationExtend, DirectionForward, LineGranularity, UserTriggered);
 629     return true;
 630 }
 631 
 632 static bool executeMoveForward(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 633 {
 634     frame.selection().modify(FrameSelection::AlterationMove, DirectionForward, CharacterGranularity, UserTriggered);
 635     return true;
 636 }
 637 
 638 static bool executeMoveForwardAndModifySelection(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 639 {
 640     frame.selection().modify(FrameSelection::AlterationExtend, DirectionForward, CharacterGranularity, UserTriggered);
 641     return true;
 642 }
 643 
 644 static bool executeMoveLeft(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 645 {
 646     return frame.selection().modify(FrameSelection::AlterationMove, DirectionLeft, CharacterGranularity, UserTriggered);
 647 }
 648 
 649 static bool executeMoveLeftAndModifySelection(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 650 {
 651     frame.selection().modify(FrameSelection::AlterationExtend, DirectionLeft, CharacterGranularity, UserTriggered);
 652     return true;
 653 }
 654 
 655 static bool executeMovePageDown(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 656 {
 657     unsigned distance = verticalScrollDistance(frame);
 658     if (!distance)
 659         return false;
 660     return frame.selection().modify(FrameSelection::AlterationMove, distance, FrameSelection::DirectionDown,
 661         UserTriggered, FrameSelection::AlignCursorOnScrollAlways);
 662 }
 663 
 664 static bool executeMovePageDownAndModifySelection(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 665 {
 666     unsigned distance = verticalScrollDistance(frame);
 667     if (!distance)
 668         return false;
 669     return frame.selection().modify(FrameSelection::AlterationExtend, distance, FrameSelection::DirectionDown,
 670         UserTriggered, FrameSelection::AlignCursorOnScrollAlways);
 671 }
 672 
 673 static bool executeMovePageUp(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 674 {
 675     unsigned distance = verticalScrollDistance(frame);
 676     if (!distance)
 677         return false;
 678     return frame.selection().modify(FrameSelection::AlterationMove, distance, FrameSelection::DirectionUp,
 679         UserTriggered, FrameSelection::AlignCursorOnScrollAlways);
 680 }
 681 
 682 static bool executeMovePageUpAndModifySelection(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 683 {
 684     unsigned distance = verticalScrollDistance(frame);
 685     if (!distance)
 686         return false;
 687     return frame.selection().modify(FrameSelection::AlterationExtend, distance, FrameSelection::DirectionUp,
 688         UserTriggered, FrameSelection::AlignCursorOnScrollAlways);
 689 }
 690 
 691 static bool executeMoveRight(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 692 {
 693     return frame.selection().modify(FrameSelection::AlterationMove, DirectionRight, CharacterGranularity, UserTriggered);
 694 }
 695 
 696 static bool executeMoveRightAndModifySelection(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 697 {
 698     frame.selection().modify(FrameSelection::AlterationExtend, DirectionRight, CharacterGranularity, UserTriggered);
 699     return true;
 700 }
 701 
 702 static bool executeMoveToBeginningOfDocument(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 703 {
 704     frame.selection().modify(FrameSelection::AlterationMove, DirectionBackward, DocumentBoundary, UserTriggered);
 705     return true;
 706 }
 707 
 708 static bool executeMoveToBeginningOfDocumentAndModifySelection(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 709 {
 710     frame.selection().modify(FrameSelection::AlterationExtend, DirectionBackward, DocumentBoundary, UserTriggered);
 711     return true;
 712 }
 713 
 714 static bool executeMoveToBeginningOfLine(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 715 {
 716     frame.selection().modify(FrameSelection::AlterationMove, DirectionBackward, LineBoundary, UserTriggered);
 717     return true;
 718 }
 719 
 720 static bool executeMoveToBeginningOfLineAndModifySelection(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 721 {
 722     frame.selection().modify(FrameSelection::AlterationExtend, DirectionBackward, LineBoundary, UserTriggered);
 723     return true;
 724 }
 725 
 726 static bool executeMoveToBeginningOfParagraph(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 727 {
 728     frame.selection().modify(FrameSelection::AlterationMove, DirectionBackward, ParagraphBoundary, UserTriggered);
 729     return true;
 730 }
 731 
 732 static bool executeMoveToBeginningOfParagraphAndModifySelection(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 733 {
 734     frame.selection().modify(FrameSelection::AlterationExtend, DirectionBackward, ParagraphBoundary, UserTriggered);
 735     return true;
 736 }
 737 
 738 static bool executeMoveToBeginningOfSentence(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 739 {
 740     frame.selection().modify(FrameSelection::AlterationMove, DirectionBackward, SentenceBoundary, UserTriggered);
 741     return true;
 742 }
 743 
 744 static bool executeMoveToBeginningOfSentenceAndModifySelection(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 745 {
 746     frame.selection().modify(FrameSelection::AlterationExtend, DirectionBackward, SentenceBoundary, UserTriggered);
 747     return true;
 748 }
 749 
 750 static bool executeMoveToEndOfDocument(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 751 {
 752     frame.selection().modify(FrameSelection::AlterationMove, DirectionForward, DocumentBoundary, UserTriggered);
 753     return true;
 754 }
 755 
 756 static bool executeMoveToEndOfDocumentAndModifySelection(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 757 {
 758     frame.selection().modify(FrameSelection::AlterationExtend, DirectionForward, DocumentBoundary, UserTriggered);
 759     return true;
 760 }
 761 
 762 static bool executeMoveToEndOfSentence(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 763 {
 764     frame.selection().modify(FrameSelection::AlterationMove, DirectionForward, SentenceBoundary, UserTriggered);
 765     return true;
 766 }
 767 
 768 static bool executeMoveToEndOfSentenceAndModifySelection(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 769 {
 770     frame.selection().modify(FrameSelection::AlterationExtend, DirectionForward, SentenceBoundary, UserTriggered);
 771     return true;
 772 }
 773 
 774 static bool executeMoveToEndOfLine(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 775 {
 776     frame.selection().modify(FrameSelection::AlterationMove, DirectionForward, LineBoundary, UserTriggered);
 777     return true;
 778 }
 779 
 780 static bool executeMoveToEndOfLineAndModifySelection(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 781 {
 782     frame.selection().modify(FrameSelection::AlterationExtend, DirectionForward, LineBoundary, UserTriggered);
 783     return true;
 784 }
 785 
 786 static bool executeMoveToEndOfParagraph(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 787 {
 788     frame.selection().modify(FrameSelection::AlterationMove, DirectionForward, ParagraphBoundary, UserTriggered);
 789     return true;
 790 }
 791 
 792 static bool executeMoveToEndOfParagraphAndModifySelection(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 793 {
 794     frame.selection().modify(FrameSelection::AlterationExtend, DirectionForward, ParagraphBoundary, UserTriggered);
 795     return true;
 796 }
 797 
 798 static bool executeMoveParagraphBackwardAndModifySelection(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 799 {
 800     frame.selection().modify(FrameSelection::AlterationExtend, DirectionBackward, ParagraphGranularity, UserTriggered);
 801     return true;
 802 }
 803 
 804 static bool executeMoveParagraphForwardAndModifySelection(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 805 {
 806     frame.selection().modify(FrameSelection::AlterationExtend, DirectionForward, ParagraphGranularity, UserTriggered);
 807     return true;
 808 }
 809 
 810 static bool executeMoveUp(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 811 {
 812     return frame.selection().modify(FrameSelection::AlterationMove, DirectionBackward, LineGranularity, UserTriggered);
 813 }
 814 
 815 static bool executeMoveUpAndModifySelection(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 816 {
 817     frame.selection().modify(FrameSelection::AlterationExtend, DirectionBackward, LineGranularity, UserTriggered);
 818     return true;
 819 }
 820 
 821 static bool executeMoveWordBackward(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 822 {
 823     frame.selection().modify(FrameSelection::AlterationMove, DirectionBackward, WordGranularity, UserTriggered);
 824     return true;
 825 }
 826 
 827 static bool executeMoveWordBackwardAndModifySelection(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 828 {
 829     frame.selection().modify(FrameSelection::AlterationExtend, DirectionBackward, WordGranularity, UserTriggered);
 830     return true;
 831 }
 832 
 833 static bool executeMoveWordForward(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 834 {
 835     frame.selection().modify(FrameSelection::AlterationMove, DirectionForward, WordGranularity, UserTriggered);
 836     return true;
 837 }
 838 
 839 static bool executeMoveWordForwardAndModifySelection(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 840 {
 841     frame.selection().modify(FrameSelection::AlterationExtend, DirectionForward, WordGranularity, UserTriggered);
 842     return true;
 843 }
 844 
 845 static bool executeMoveWordLeft(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 846 {
 847     frame.selection().modify(FrameSelection::AlterationMove, DirectionLeft, WordGranularity, UserTriggered);
 848     return true;
 849 }
 850 
 851 static bool executeMoveWordLeftAndModifySelection(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 852 {
 853     frame.selection().modify(FrameSelection::AlterationExtend, DirectionLeft, WordGranularity, UserTriggered);
 854     return true;
 855 }
 856 
 857 static bool executeMoveWordRight(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 858 {
 859     frame.selection().modify(FrameSelection::AlterationMove, DirectionRight, WordGranularity, UserTriggered);
 860     return true;
 861 }
 862 
 863 static bool executeMoveWordRightAndModifySelection(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 864 {
 865     frame.selection().modify(FrameSelection::AlterationExtend, DirectionRight, WordGranularity, UserTriggered);
 866     return true;
 867 }
 868 
 869 static bool executeMoveToLeftEndOfLine(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 870 {
 871     frame.selection().modify(FrameSelection::AlterationMove, DirectionLeft, LineBoundary, UserTriggered);
 872     return true;
 873 }
 874 
 875 static bool executeMoveToLeftEndOfLineAndModifySelection(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 876 {
 877     frame.selection().modify(FrameSelection::AlterationExtend, DirectionLeft, LineBoundary, UserTriggered);
 878     return true;
 879 }
 880 
 881 static bool executeMoveToRightEndOfLine(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 882 {
 883     frame.selection().modify(FrameSelection::AlterationMove, DirectionRight, LineBoundary, UserTriggered);
 884     return true;
 885 }
 886 
 887 static bool executeMoveToRightEndOfLineAndModifySelection(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 888 {
 889     frame.selection().modify(FrameSelection::AlterationExtend, DirectionRight, LineBoundary, UserTriggered);
 890     return true;
 891 }
 892 
 893 static bool executeOutdent(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 894 {
 895     ASSERT(frame.document());
 896     IndentOutdentCommand::create(*frame.document(), IndentOutdentCommand::Outdent)-&gt;apply();
 897     return true;
 898 }
 899 
 900 static bool executeToggleOverwrite(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 901 {
 902     frame.editor().toggleOverwriteModeEnabled();
 903     return true;
 904 }
 905 
 906 static bool executePaste(Frame&amp; frame, Event*, EditorCommandSource source, const String&amp;)
 907 {
 908     if (source == CommandFromMenuOrKeyBinding) {
 909         UserTypingGestureIndicator typingGestureIndicator(frame);
 910         frame.editor().paste();
 911     } else
 912         frame.editor().paste();
 913     return true;
 914 }
 915 
 916 #if PLATFORM(GTK)
 917 
 918 static bool executePasteGlobalSelection(Frame&amp; frame, Event*, EditorCommandSource source, const String&amp;)
 919 {
 920     // FIXME: This check should be in an enable function, not here.
 921     if (!frame.editor().client()-&gt;supportsGlobalSelection())
 922         return false;
 923 
 924     ASSERT_UNUSED(source, source == CommandFromMenuOrKeyBinding);
 925     UserTypingGestureIndicator typingGestureIndicator(frame);
 926     frame.editor().paste(*Pasteboard::createForGlobalSelection());
 927     return true;
 928 }
 929 
 930 #endif
 931 
 932 static bool executePasteAndMatchStyle(Frame&amp; frame, Event*, EditorCommandSource source, const String&amp;)
 933 {
 934     if (source == CommandFromMenuOrKeyBinding) {
 935         UserTypingGestureIndicator typingGestureIndicator(frame);
 936         frame.editor().pasteAsPlainText();
 937     } else
 938         frame.editor().pasteAsPlainText();
 939     return true;
 940 }
 941 
 942 static bool executePasteAsPlainText(Frame&amp; frame, Event*, EditorCommandSource source, const String&amp;)
 943 {
 944     if (source == CommandFromMenuOrKeyBinding) {
 945         UserTypingGestureIndicator typingGestureIndicator(frame);
 946         frame.editor().pasteAsPlainText();
 947     } else
 948         frame.editor().pasteAsPlainText();
 949     return true;
 950 }
 951 
 952 static bool executePasteAsQuotation(Frame&amp; frame, Event*, EditorCommandSource source, const String&amp;)
 953 {
 954     if (source == CommandFromMenuOrKeyBinding) {
 955         UserTypingGestureIndicator typingGestureIndicator(frame);
 956         frame.editor().pasteAsQuotation();
 957     } else
 958         frame.editor().pasteAsQuotation();
 959     return true;
 960 }
 961 
 962 static bool executePrint(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 963 {
 964     Page* page = frame.page();
 965     if (!page)
 966         return false;
 967     return page-&gt;chrome().print(frame);
 968 }
 969 
 970 static bool executeRedo(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 971 {
 972     frame.editor().redo();
 973     return true;
 974 }
 975 
 976 static bool executeRemoveFormat(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 977 {
 978     frame.editor().removeFormattingAndStyle();
 979     return true;
 980 }
 981 
 982 static bool executeScrollPageBackward(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 983 {
 984     return frame.eventHandler().logicalScrollRecursively(ScrollBlockDirectionBackward, ScrollByPage);
 985 }
 986 
 987 static bool executeScrollPageForward(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 988 {
 989     return frame.eventHandler().logicalScrollRecursively(ScrollBlockDirectionForward, ScrollByPage);
 990 }
 991 
 992 static bool executeScrollLineUp(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 993 {
 994     return frame.eventHandler().scrollRecursively(ScrollUp, ScrollByLine);
 995 }
 996 
 997 static bool executeScrollLineDown(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 998 {
 999     return frame.eventHandler().scrollRecursively(ScrollDown, ScrollByLine);
1000 }
1001 
1002 static bool executeScrollToBeginningOfDocument(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
1003 {
1004     return frame.eventHandler().logicalScrollRecursively(ScrollBlockDirectionBackward, ScrollByDocument);
1005 }
1006 
1007 static bool executeScrollToEndOfDocument(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
1008 {
1009     return frame.eventHandler().logicalScrollRecursively(ScrollBlockDirectionForward, ScrollByDocument);
1010 }
1011 
1012 static bool executeSelectAll(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
1013 {
1014     frame.selection().selectAll();
1015     return true;
1016 }
1017 
1018 static bool executeSelectLine(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
1019 {
1020     return expandSelectionToGranularity(frame, LineGranularity);
1021 }
1022 
1023 static bool executeSelectParagraph(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
1024 {
1025     return expandSelectionToGranularity(frame, ParagraphGranularity);
1026 }
1027 
1028 static bool executeSelectSentence(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
1029 {
1030     return expandSelectionToGranularity(frame, SentenceGranularity);
1031 }
1032 
1033 static bool executeSelectToMark(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
1034 {
1035     RefPtr&lt;Range&gt; mark = frame.editor().mark().toNormalizedRange();
1036     RefPtr&lt;Range&gt; selection = frame.editor().selectedRange();
1037     if (!mark || !selection) {
1038         PAL::systemBeep();
1039         return false;
1040     }
1041     frame.selection().setSelectedRange(unionDOMRanges(*mark, *selection).get(), DOWNSTREAM, FrameSelection::ShouldCloseTyping::Yes);
1042     return true;
1043 }
1044 
1045 static bool executeSelectWord(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
1046 {
1047     return expandSelectionToGranularity(frame, WordGranularity);
1048 }
1049 
1050 static bool executeSetMark(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
1051 {
1052     frame.editor().setMark(frame.selection().selection());
1053     return true;
1054 }
1055 
1056 static TextDecorationChange textDecorationChangeForToggling(Editor&amp; editor, CSSPropertyID propertyID, const char* onValue)
1057 {
1058     return isStylePresent(editor, propertyID, onValue) ? TextDecorationChange::Remove : TextDecorationChange::Add;
1059 }
1060 
1061 static bool executeStrikethrough(Frame&amp; frame, Event*, EditorCommandSource source, const String&amp;)
1062 {
1063     Ref&lt;EditingStyle&gt; style = EditingStyle::create();
1064     style-&gt;setStrikeThroughChange(textDecorationChangeForToggling(frame.editor(), CSSPropertyWebkitTextDecorationsInEffect, &quot;line-through&quot;_s));
1065     // FIXME: Needs a new EditAction!
1066     return applyCommandToFrame(frame, source, EditAction::Underline, WTFMove(style));
1067 }
1068 
1069 static bool executeStyleWithCSS(Frame&amp; frame, Event*, EditorCommandSource, const String&amp; value)
1070 {
1071     frame.editor().setShouldStyleWithCSS(!equalLettersIgnoringASCIICase(value, &quot;false&quot;));
1072     return true;
1073 }
1074 
1075 static bool executeUseCSS(Frame&amp; frame, Event*, EditorCommandSource, const String&amp; value)
1076 {
1077     frame.editor().setShouldStyleWithCSS(equalLettersIgnoringASCIICase(value, &quot;false&quot;));
1078     return true;
1079 }
1080 
1081 static bool executeSubscript(Frame&amp; frame, Event*, EditorCommandSource source, const String&amp;)
1082 {
1083     return executeToggleStyle(frame, source, EditAction::Subscript, CSSPropertyVerticalAlign, &quot;baseline&quot;_s, &quot;sub&quot;_s);
1084 }
1085 
1086 static bool executeSuperscript(Frame&amp; frame, Event*, EditorCommandSource source, const String&amp;)
1087 {
1088     return executeToggleStyle(frame, source, EditAction::Superscript, CSSPropertyVerticalAlign, &quot;baseline&quot;_s, &quot;super&quot;_s);
1089 }
1090 
1091 static bool executeSwapWithMark(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
1092 {
1093     Ref&lt;Frame&gt; protector(frame);
1094     const VisibleSelection&amp; mark = frame.editor().mark();
1095     const VisibleSelection&amp; selection = frame.selection().selection();
1096     if (mark.isNone() || selection.isNone()) {
1097         PAL::systemBeep();
1098         return false;
1099     }
1100     frame.selection().setSelection(mark);
1101     frame.editor().setMark(selection);
1102     return true;
1103 }
1104 
1105 #if PLATFORM(COCOA)
1106 
1107 static bool executeTakeFindStringFromSelection(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
1108 {
1109     frame.editor().takeFindStringFromSelection();
1110     return true;
1111 }
1112 
1113 #endif // PLATFORM(COCOA)
1114 
1115 static bool executeToggleBold(Frame&amp; frame, Event*, EditorCommandSource source, const String&amp;)
1116 {
1117     return executeToggleStyle(frame, source, EditAction::Bold, CSSPropertyFontWeight, &quot;normal&quot;_s, &quot;bold&quot;_s);
1118 }
1119 
1120 static bool executeToggleItalic(Frame&amp; frame, Event*, EditorCommandSource source, const String&amp;)
1121 {
1122     return executeToggleStyle(frame, source, EditAction::Italics, CSSPropertyFontStyle, &quot;normal&quot;_s, &quot;italic&quot;_s);
1123 }
1124 
1125 static bool executeTranspose(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
1126 {
1127     frame.editor().transpose();
1128     return true;
1129 }
1130 
1131 static bool executeUnderline(Frame&amp; frame, Event*, EditorCommandSource source, const String&amp;)
1132 {
1133     Ref&lt;EditingStyle&gt; style = EditingStyle::create();
1134     TextDecorationChange change = textDecorationChangeForToggling(frame.editor(), CSSPropertyWebkitTextDecorationsInEffect, &quot;underline&quot;_s);
1135     style-&gt;setUnderlineChange(change);
1136     return applyCommandToFrame(frame, source, EditAction::Underline, WTFMove(style));
1137 }
1138 
1139 static bool executeUndo(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
1140 {
1141     frame.editor().undo();
1142     return true;
1143 }
1144 
1145 static bool executeUnlink(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
1146 {
1147     ASSERT(frame.document());
1148     UnlinkCommand::create(*frame.document())-&gt;apply();
1149     return true;
1150 }
1151 
1152 static bool executeUnscript(Frame&amp; frame, Event*, EditorCommandSource source, const String&amp;)
1153 {
1154     return executeApplyStyle(frame, source, EditAction::Unscript, CSSPropertyVerticalAlign, &quot;baseline&quot;_s);
1155 }
1156 
1157 static bool executeUnselect(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
1158 {
1159     frame.selection().clear();
1160     return true;
1161 }
1162 
1163 static bool executeYank(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
1164 {
1165     frame.editor().insertTextWithoutSendingTextEvent(frame.editor().killRing().yank(), false, 0);
1166     frame.editor().killRing().setToYankedState();
1167     return true;
1168 }
1169 
1170 static bool executeYankAndSelect(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
1171 {
1172     frame.editor().insertTextWithoutSendingTextEvent(frame.editor().killRing().yank(), true, 0);
1173     frame.editor().killRing().setToYankedState();
1174     return true;
1175 }
1176 
1177 // Supported functions
1178 
1179 static bool supported(Frame*)
1180 {
1181     return true;
1182 }
1183 
1184 static bool supportedFromMenuOrKeyBinding(Frame*)
1185 {
1186     return false;
1187 }
1188 
1189 static bool defaultValueForSupportedCopyCut(Frame&amp; frame)
1190 {
1191     auto&amp; settings = frame.settings();
1192     if (settings.javaScriptCanAccessClipboard())
1193         return true;
1194 
1195     switch (settings.clipboardAccessPolicy()) {
1196     case ClipboardAccessPolicy::Allow:
1197     case ClipboardAccessPolicy::RequiresUserGesture:
1198         return true;
1199     case ClipboardAccessPolicy::Deny:
1200         return false;
1201     }
1202 
1203     ASSERT_NOT_REACHED();
1204     return false;
1205 }
1206 
1207 static bool supportedCopyCut(Frame* frame)
1208 {
1209     if (!frame)
1210         return false;
1211 
1212     bool defaultValue = defaultValueForSupportedCopyCut(*frame);
1213 
1214     EditorClient* client = frame-&gt;editor().client();
1215     return client ? client-&gt;canCopyCut(frame, defaultValue) : defaultValue;
1216 }
1217 
1218 static bool supportedPaste(Frame* frame)
1219 {
1220     if (!frame)
1221         return false;
1222 
1223     bool defaultValue = frame-&gt;settings().javaScriptCanAccessClipboard() &amp;&amp; frame-&gt;settings().DOMPasteAllowed();
1224 
1225     EditorClient* client = frame-&gt;editor().client();
1226     return client ? client-&gt;canPaste(frame, defaultValue) : defaultValue;
1227 }
1228 
1229 // Enabled functions
1230 
1231 static bool enabled(Frame&amp;, Event*, EditorCommandSource)
1232 {
1233     return true;
1234 }
1235 
1236 static bool enabledVisibleSelection(Frame&amp; frame, Event* event, EditorCommandSource)
1237 {
1238     // The term &quot;visible&quot; here includes a caret in editable text or a range in any text.
1239     const VisibleSelection&amp; selection = frame.editor().selectionForCommand(event);
1240     return (selection.isCaret() &amp;&amp; selection.isContentEditable()) || selection.isRange();
1241 }
1242 
1243 static bool caretBrowsingEnabled(Frame&amp; frame)
1244 {
1245     return frame.settings().caretBrowsingEnabled();
1246 }
1247 
1248 static EditorCommandSource dummyEditorCommandSource = static_cast&lt;EditorCommandSource&gt;(0);
1249 
1250 static bool enabledVisibleSelectionOrCaretBrowsing(Frame&amp; frame, Event* event, EditorCommandSource)
1251 {
1252     // The EditorCommandSource parameter is unused in enabledVisibleSelection, so just pass a dummy variable
1253     return caretBrowsingEnabled(frame) || enabledVisibleSelection(frame, event, dummyEditorCommandSource);
1254 }
1255 
1256 static bool enabledVisibleSelectionAndMark(Frame&amp; frame, Event* event, EditorCommandSource)
1257 {
1258     const VisibleSelection&amp; selection = frame.editor().selectionForCommand(event);
1259     return ((selection.isCaret() &amp;&amp; selection.isContentEditable()) || selection.isRange())
1260         &amp;&amp; frame.editor().mark().isCaretOrRange();
1261 }
1262 
1263 static bool enableCaretInEditableText(Frame&amp; frame, Event* event, EditorCommandSource)
1264 {
1265     const VisibleSelection&amp; selection = frame.editor().selectionForCommand(event);
1266     return selection.isCaret() &amp;&amp; selection.isContentEditable();
1267 }
1268 
1269 static bool allowCopyCutFromDOM(Frame&amp; frame)
1270 {
1271     auto&amp; settings = frame.settings();
1272     if (settings.javaScriptCanAccessClipboard())
1273         return true;
1274 
1275     switch (settings.clipboardAccessPolicy()) {
1276     case ClipboardAccessPolicy::Allow:
1277         return true;
1278     case ClipboardAccessPolicy::Deny:
1279         return false;
1280     case ClipboardAccessPolicy::RequiresUserGesture:
1281         return UserGestureIndicator::processingUserGesture();
1282     }
1283 
1284     ASSERT_NOT_REACHED();
1285     return false;
1286 }
1287 
1288 static bool enabledCopy(Frame&amp; frame, Event*, EditorCommandSource source)
1289 {
1290     switch (source) {
1291     case CommandFromMenuOrKeyBinding:
1292         return frame.editor().canDHTMLCopy() || frame.editor().canCopy();
1293     case CommandFromDOM:
1294     case CommandFromDOMWithUserInterface:
1295         return allowCopyCutFromDOM(frame) &amp;&amp; (frame.editor().canDHTMLCopy() || frame.editor().canCopy());
1296     }
1297     ASSERT_NOT_REACHED();
1298     return false;
1299 }
1300 
1301 static bool enabledCut(Frame&amp; frame, Event*, EditorCommandSource source)
1302 {
1303     switch (source) {
1304     case CommandFromMenuOrKeyBinding:
1305         return frame.editor().canDHTMLCut() || frame.editor().canCut();
1306     case CommandFromDOM:
1307     case CommandFromDOMWithUserInterface:
1308         return allowCopyCutFromDOM(frame) &amp;&amp; (frame.editor().canDHTMLCut() || frame.editor().canCut());
1309     }
1310     ASSERT_NOT_REACHED();
1311     return false;
1312 }
1313 
1314 static bool enabledClearText(Frame&amp; frame, Event*, EditorCommandSource)
1315 {
1316     UNUSED_PARAM(frame);
1317     return false;
1318 }
1319 
1320 static bool enabledInEditableText(Frame&amp; frame, Event* event, EditorCommandSource)
1321 {
1322     return frame.editor().selectionForCommand(event).rootEditableElement();
1323 }
1324 
1325 static bool enabledDelete(Frame&amp; frame, Event* event, EditorCommandSource source)
1326 {
1327     switch (source) {
1328     case CommandFromMenuOrKeyBinding:
1329         return frame.editor().canDelete();
1330     case CommandFromDOM:
1331     case CommandFromDOMWithUserInterface:
1332         // &quot;Delete&quot; from DOM is like delete/backspace keypress, affects selected range if non-empty,
1333         // otherwise removes a character
1334         return enabledInEditableText(frame, event, source);
1335     }
1336     ASSERT_NOT_REACHED();
1337     return false;
1338 }
1339 
1340 static bool enabledInEditableTextOrCaretBrowsing(Frame&amp; frame, Event* event, EditorCommandSource)
1341 {
1342     // The EditorCommandSource parameter is unused in enabledInEditableText, so just pass a dummy variable
1343     return caretBrowsingEnabled(frame) || enabledInEditableText(frame, event, dummyEditorCommandSource);
1344 }
1345 
1346 static bool enabledInRichlyEditableText(Frame&amp; frame, Event*, EditorCommandSource)
1347 {
1348     const VisibleSelection&amp; selection = frame.selection().selection();
1349     return selection.isCaretOrRange() &amp;&amp; selection.isContentRichlyEditable() &amp;&amp; selection.rootEditableElement();
1350 }
1351 
1352 static bool enabledPaste(Frame&amp; frame, Event*, EditorCommandSource)
1353 {
1354     return frame.editor().canPaste();
1355 }
1356 
1357 static bool enabledRangeInEditableText(Frame&amp; frame, Event*, EditorCommandSource)
1358 {
1359     return frame.selection().isRange() &amp;&amp; frame.selection().selection().isContentEditable();
1360 }
1361 
1362 static bool enabledRangeInRichlyEditableText(Frame&amp; frame, Event*, EditorCommandSource)
1363 {
1364     return frame.selection().isRange() &amp;&amp; frame.selection().selection().isContentRichlyEditable();
1365 }
1366 
1367 static bool enabledRedo(Frame&amp; frame, Event*, EditorCommandSource)
1368 {
1369     return frame.editor().canRedo();
1370 }
1371 
1372 #if PLATFORM(COCOA)
1373 
1374 static bool enabledTakeFindStringFromSelection(Frame&amp; frame, Event*, EditorCommandSource)
1375 {
1376     return frame.editor().canCopyExcludingStandaloneImages();
1377 }
1378 
1379 #endif // PLATFORM(COCOA)
1380 
1381 static bool enabledUndo(Frame&amp; frame, Event*, EditorCommandSource)
1382 {
1383     return frame.editor().canUndo();
1384 }
1385 
1386 static bool enabledInRichlyEditableTextWithEditableImagesEnabled(Frame&amp; frame, Event* event, EditorCommandSource source)
1387 {
1388     if (!frame.settings().editableImagesEnabled())
1389         return false;
1390     return enabledInRichlyEditableText(frame, event, source);
1391 }
1392 
1393 // State functions
1394 
1395 static TriState stateNone(Frame&amp;, Event*)
1396 {
1397     return FalseTriState;
1398 }
1399 
1400 static TriState stateBold(Frame&amp; frame, Event*)
1401 {
1402     return stateStyle(frame, CSSPropertyFontWeight, &quot;bold&quot;_s);
1403 }
1404 
1405 static TriState stateItalic(Frame&amp; frame, Event*)
1406 {
1407     return stateStyle(frame, CSSPropertyFontStyle, &quot;italic&quot;_s);
1408 }
1409 
1410 static TriState stateOrderedList(Frame&amp; frame, Event*)
1411 {
1412     return frame.editor().selectionOrderedListState();
1413 }
1414 
1415 static TriState stateStrikethrough(Frame&amp; frame, Event*)
1416 {
1417     return stateStyle(frame, CSSPropertyWebkitTextDecorationsInEffect, &quot;line-through&quot;_s);
1418 }
1419 
1420 static TriState stateStyleWithCSS(Frame&amp; frame, Event*)
1421 {
1422     return frame.editor().shouldStyleWithCSS() ? TrueTriState : FalseTriState;
1423 }
1424 
1425 static TriState stateSubscript(Frame&amp; frame, Event*)
1426 {
1427     return stateStyle(frame, CSSPropertyVerticalAlign, &quot;sub&quot;_s);
1428 }
1429 
1430 static TriState stateSuperscript(Frame&amp; frame, Event*)
1431 {
1432     return stateStyle(frame, CSSPropertyVerticalAlign, &quot;super&quot;_s);
1433 }
1434 
1435 static TriState stateTextWritingDirectionLeftToRight(Frame&amp; frame, Event*)
1436 {
1437     return stateTextWritingDirection(frame, WritingDirection::LeftToRight);
1438 }
1439 
1440 static TriState stateTextWritingDirectionNatural(Frame&amp; frame, Event*)
1441 {
1442     return stateTextWritingDirection(frame, WritingDirection::Natural);
1443 }
1444 
1445 static TriState stateTextWritingDirectionRightToLeft(Frame&amp; frame, Event*)
1446 {
1447     return stateTextWritingDirection(frame, WritingDirection::RightToLeft);
1448 }
1449 
1450 static TriState stateUnderline(Frame&amp; frame, Event*)
1451 {
1452     return stateStyle(frame, CSSPropertyWebkitTextDecorationsInEffect, &quot;underline&quot;_s);
1453 }
1454 
1455 static TriState stateUnorderedList(Frame&amp; frame, Event*)
1456 {
1457     return frame.editor().selectionUnorderedListState();
1458 }
1459 
1460 static TriState stateJustifyCenter(Frame&amp; frame, Event*)
1461 {
1462     return stateStyle(frame, CSSPropertyTextAlign, &quot;center&quot;_s);
1463 }
1464 
1465 static TriState stateJustifyFull(Frame&amp; frame, Event*)
1466 {
1467     return stateStyle(frame, CSSPropertyTextAlign, &quot;justify&quot;_s);
1468 }
1469 
1470 static TriState stateJustifyLeft(Frame&amp; frame, Event*)
1471 {
1472     return stateStyle(frame, CSSPropertyTextAlign, &quot;left&quot;_s);
1473 }
1474 
1475 static TriState stateJustifyRight(Frame&amp; frame, Event*)
1476 {
1477     return stateStyle(frame, CSSPropertyTextAlign, &quot;right&quot;_s);
1478 }
1479 
1480 // Value functions
1481 
1482 static String valueNull(Frame&amp;, Event*)
1483 {
1484     return String();
1485 }
1486 
1487 static String valueBackColor(Frame&amp; frame, Event*)
1488 {
1489     return valueStyle(frame, CSSPropertyBackgroundColor);
1490 }
1491 
1492 static String valueDefaultParagraphSeparator(Frame&amp; frame, Event*)
1493 {
1494     switch (frame.editor().defaultParagraphSeparator()) {
1495     case EditorParagraphSeparatorIsDiv:
1496         return divTag-&gt;localName();
1497     case EditorParagraphSeparatorIsP:
1498         return pTag-&gt;localName();
1499     }
1500 
1501     ASSERT_NOT_REACHED();
1502     return String();
1503 }
1504 
1505 static String valueFontName(Frame&amp; frame, Event*)
1506 {
1507     return valueStyle(frame, CSSPropertyFontFamily);
1508 }
1509 
1510 static String valueFontSize(Frame&amp; frame, Event*)
1511 {
1512     return valueStyle(frame, CSSPropertyFontSize);
1513 }
1514 
1515 static String valueFontSizeDelta(Frame&amp; frame, Event*)
1516 {
1517     return valueStyle(frame, CSSPropertyWebkitFontSizeDelta);
1518 }
1519 
1520 static String valueForeColor(Frame&amp; frame, Event*)
1521 {
1522     return valueStyle(frame, CSSPropertyColor);
1523 }
1524 
1525 static String valueFormatBlock(Frame&amp; frame, Event*)
1526 {
1527     const VisibleSelection&amp; selection = frame.selection().selection();
1528     if (selection.isNoneOrOrphaned() || !selection.isContentEditable())
1529         return emptyString();
1530     Element* formatBlockElement = FormatBlockCommand::elementForFormatBlockCommand(selection.firstRange().get());
1531     if (!formatBlockElement)
1532         return emptyString();
1533     return formatBlockElement-&gt;localName();
1534 }
1535 
1536 // allowExecutionWhenDisabled functions
1537 
1538 static bool allowExecutionWhenDisabled(Frame&amp;, EditorCommandSource)
1539 {
1540     return true;
1541 }
1542 
1543 static bool doNotAllowExecutionWhenDisabled(Frame&amp;, EditorCommandSource)
1544 {
1545     return false;
1546 }
1547 
1548 static bool allowExecutionWhenDisabledCopyCut(Frame&amp;, EditorCommandSource source)
1549 {
1550     switch (source) {
1551     case CommandFromMenuOrKeyBinding:
1552         return true;
1553     case CommandFromDOM:
1554     case CommandFromDOMWithUserInterface:
1555         return false;
1556     }
1557 
1558     ASSERT_NOT_REACHED();
1559     return false;
1560 }
1561 
1562 static bool allowExecutionWhenDisabledPaste(Frame&amp; frame, EditorCommandSource)
1563 {
1564     if (frame.mainFrame().loader().shouldSuppressTextInputFromEditing())
1565         return false;
1566     return true;
1567 }
1568 
1569 // Map of functions
1570 
1571 struct CommandEntry {
1572     const char* name;
1573     EditorInternalCommand command;
1574 };
1575 
1576 static const CommandMap&amp; createCommandMap()
1577 {
1578     static const CommandEntry commands[] = {
1579         { &quot;AlignCenter&quot;, { executeJustifyCenter, supportedFromMenuOrKeyBinding, enabledInRichlyEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1580         { &quot;AlignJustified&quot;, { executeJustifyFull, supportedFromMenuOrKeyBinding, enabledInRichlyEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1581         { &quot;AlignLeft&quot;, { executeJustifyLeft, supportedFromMenuOrKeyBinding, enabledInRichlyEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1582         { &quot;AlignRight&quot;, { executeJustifyRight, supportedFromMenuOrKeyBinding, enabledInRichlyEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1583         { &quot;BackColor&quot;, { executeBackColor, supported, enabledInRichlyEditableText, stateNone, valueBackColor, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1584         { &quot;Bold&quot;, { executeToggleBold, supported, enabledInRichlyEditableText, stateBold, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1585         { &quot;ClearText&quot;, { executeClearText, supported, enabledClearText, stateNone, valueNull, notTextInsertion, allowExecutionWhenDisabled } },
1586         { &quot;Copy&quot;, { executeCopy, supportedCopyCut, enabledCopy, stateNone, valueNull, notTextInsertion, allowExecutionWhenDisabledCopyCut } },
1587         { &quot;CreateLink&quot;, { executeCreateLink, supported, enabledInRichlyEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1588         { &quot;Cut&quot;, { executeCut, supportedCopyCut, enabledCut, stateNone, valueNull, notTextInsertion, allowExecutionWhenDisabledCopyCut } },
1589         { &quot;DefaultParagraphSeparator&quot;, { executeDefaultParagraphSeparator, supported, enabled, stateNone, valueDefaultParagraphSeparator, notTextInsertion, doNotAllowExecutionWhenDisabled} },
1590         { &quot;Delete&quot;, { executeDelete, supported, enabledDelete, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1591         { &quot;DeleteBackward&quot;, { executeDeleteBackward, supportedFromMenuOrKeyBinding, enabledInEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1592         { &quot;DeleteBackwardByDecomposingPreviousCharacter&quot;, { executeDeleteBackwardByDecomposingPreviousCharacter, supportedFromMenuOrKeyBinding, enabledInEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1593         { &quot;DeleteForward&quot;, { executeDeleteForward, supportedFromMenuOrKeyBinding, enabledInEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1594         { &quot;DeleteToBeginningOfLine&quot;, { executeDeleteToBeginningOfLine, supportedFromMenuOrKeyBinding, enabledInEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1595         { &quot;DeleteToBeginningOfParagraph&quot;, { executeDeleteToBeginningOfParagraph, supportedFromMenuOrKeyBinding, enabledInEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1596         { &quot;DeleteToEndOfLine&quot;, { executeDeleteToEndOfLine, supportedFromMenuOrKeyBinding, enabledInEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1597         { &quot;DeleteToEndOfParagraph&quot;, { executeDeleteToEndOfParagraph, supportedFromMenuOrKeyBinding, enabledInEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1598         { &quot;DeleteToMark&quot;, { executeDeleteToMark, supportedFromMenuOrKeyBinding, enabledInEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1599         { &quot;DeleteWordBackward&quot;, { executeDeleteWordBackward, supportedFromMenuOrKeyBinding, enabledInEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1600         { &quot;DeleteWordForward&quot;, { executeDeleteWordForward, supportedFromMenuOrKeyBinding, enabledInEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1601         { &quot;FindString&quot;, { executeFindString, supported, enabled, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1602         { &quot;FontName&quot;, { executeFontName, supported, enabledInEditableText, stateNone, valueFontName, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1603         { &quot;FontSize&quot;, { executeFontSize, supported, enabledInEditableText, stateNone, valueFontSize, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1604         { &quot;FontSizeDelta&quot;, { executeFontSizeDelta, supported, enabledInEditableText, stateNone, valueFontSizeDelta, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1605         { &quot;ForeColor&quot;, { executeForeColor, supported, enabledInRichlyEditableText, stateNone, valueForeColor, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1606         { &quot;FormatBlock&quot;, { executeFormatBlock, supported, enabledInRichlyEditableText, stateNone, valueFormatBlock, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1607         { &quot;ForwardDelete&quot;, { executeForwardDelete, supported, enabledInEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1608         { &quot;HiliteColor&quot;, { executeBackColor, supported, enabledInRichlyEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1609         { &quot;IgnoreSpelling&quot;, { executeIgnoreSpelling, supportedFromMenuOrKeyBinding, enabledInEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1610         { &quot;Indent&quot;, { executeIndent, supported, enabledInRichlyEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1611         { &quot;InsertBacktab&quot;, { executeInsertBacktab, supportedFromMenuOrKeyBinding, enabledInEditableText, stateNone, valueNull, isTextInsertion, doNotAllowExecutionWhenDisabled } },
1612         { &quot;InsertEditableImage&quot;, { executeInsertEditableImage, supported, enabledInRichlyEditableTextWithEditableImagesEnabled, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1613         { &quot;InsertHTML&quot;, { executeInsertHTML, supported, enabledInEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1614         { &quot;InsertHorizontalRule&quot;, { executeInsertHorizontalRule, supported, enabledInRichlyEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1615         { &quot;InsertImage&quot;, { executeInsertImage, supported, enabledInRichlyEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1616         { &quot;InsertLineBreak&quot;, { executeInsertLineBreak, supported, enabledInEditableText, stateNone, valueNull, isTextInsertion, doNotAllowExecutionWhenDisabled } },
1617         { &quot;InsertNewline&quot;, { executeInsertNewline, supportedFromMenuOrKeyBinding, enabledInEditableText, stateNone, valueNull, isTextInsertion, doNotAllowExecutionWhenDisabled } },
1618         { &quot;InsertNewlineInQuotedContent&quot;, { executeInsertNewlineInQuotedContent, supported, enabledInRichlyEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1619         { &quot;InsertOrderedList&quot;, { executeInsertOrderedList, supported, enabledInRichlyEditableText, stateOrderedList, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1620         { &quot;InsertNestedOrderedList&quot;, { executeInsertNestedOrderedList, supported, enabledInRichlyEditableText, stateOrderedList, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1621         { &quot;InsertParagraph&quot;, { executeInsertParagraph, supported, enabledInEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1622         { &quot;InsertTab&quot;, { executeInsertTab, supportedFromMenuOrKeyBinding, enabledInEditableText, stateNone, valueNull, isTextInsertion, doNotAllowExecutionWhenDisabled } },
1623         { &quot;InsertText&quot;, { executeInsertText, supported, enabledInEditableText, stateNone, valueNull, isTextInsertion, doNotAllowExecutionWhenDisabled } },
1624         { &quot;InsertUnorderedList&quot;, { executeInsertUnorderedList, supported, enabledInRichlyEditableText, stateUnorderedList, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1625         { &quot;InsertNestedUnorderedList&quot;, { executeInsertNestedUnorderedList, supported, enabledInRichlyEditableText, stateUnorderedList, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1626         { &quot;Italic&quot;, { executeToggleItalic, supported, enabledInRichlyEditableText, stateItalic, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1627         { &quot;JustifyCenter&quot;, { executeJustifyCenter, supported, enabledInRichlyEditableText, stateJustifyCenter, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1628         { &quot;JustifyFull&quot;, { executeJustifyFull, supported, enabledInRichlyEditableText, stateJustifyFull, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1629         { &quot;JustifyLeft&quot;, { executeJustifyLeft, supported, enabledInRichlyEditableText, stateJustifyLeft, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1630         { &quot;JustifyNone&quot;, { executeJustifyLeft, supported, enabledInRichlyEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1631         { &quot;JustifyRight&quot;, { executeJustifyRight, supported, enabledInRichlyEditableText, stateJustifyRight, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1632         { &quot;MakeTextWritingDirectionLeftToRight&quot;, { executeMakeTextWritingDirectionLeftToRight, supportedFromMenuOrKeyBinding, enabledInRichlyEditableText, stateTextWritingDirectionLeftToRight, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1633         { &quot;MakeTextWritingDirectionNatural&quot;, { executeMakeTextWritingDirectionNatural, supportedFromMenuOrKeyBinding, enabledInRichlyEditableText, stateTextWritingDirectionNatural, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1634         { &quot;MakeTextWritingDirectionRightToLeft&quot;, { executeMakeTextWritingDirectionRightToLeft, supportedFromMenuOrKeyBinding, enabledInRichlyEditableText, stateTextWritingDirectionRightToLeft, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1635         { &quot;MoveBackward&quot;, { executeMoveBackward, supportedFromMenuOrKeyBinding, enabledInEditableTextOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1636         { &quot;MoveBackwardAndModifySelection&quot;, { executeMoveBackwardAndModifySelection, supportedFromMenuOrKeyBinding, enabledVisibleSelectionOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1637         { &quot;MoveDown&quot;, { executeMoveDown, supportedFromMenuOrKeyBinding, enabledInEditableTextOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1638         { &quot;MoveDownAndModifySelection&quot;, { executeMoveDownAndModifySelection, supportedFromMenuOrKeyBinding, enabledVisibleSelectionOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1639         { &quot;MoveForward&quot;, { executeMoveForward, supportedFromMenuOrKeyBinding, enabledInEditableTextOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1640         { &quot;MoveForwardAndModifySelection&quot;, { executeMoveForwardAndModifySelection, supportedFromMenuOrKeyBinding, enabledVisibleSelectionOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1641         { &quot;MoveLeft&quot;, { executeMoveLeft, supportedFromMenuOrKeyBinding, enabledInEditableTextOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1642         { &quot;MoveLeftAndModifySelection&quot;, { executeMoveLeftAndModifySelection, supportedFromMenuOrKeyBinding, enabledVisibleSelectionOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1643         { &quot;MovePageDown&quot;, { executeMovePageDown, supportedFromMenuOrKeyBinding, enabledInEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1644         { &quot;MovePageDownAndModifySelection&quot;, { executeMovePageDownAndModifySelection, supportedFromMenuOrKeyBinding, enabledVisibleSelection, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1645         { &quot;MovePageUp&quot;, { executeMovePageUp, supportedFromMenuOrKeyBinding, enabledInEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1646         { &quot;MovePageUpAndModifySelection&quot;, { executeMovePageUpAndModifySelection, supportedFromMenuOrKeyBinding, enabledVisibleSelection, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1647         { &quot;MoveParagraphBackwardAndModifySelection&quot;, { executeMoveParagraphBackwardAndModifySelection, supportedFromMenuOrKeyBinding, enabledVisibleSelectionOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1648         { &quot;MoveParagraphForwardAndModifySelection&quot;, { executeMoveParagraphForwardAndModifySelection, supportedFromMenuOrKeyBinding, enabledVisibleSelectionOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1649         { &quot;MoveRight&quot;, { executeMoveRight, supportedFromMenuOrKeyBinding, enabledInEditableTextOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1650         { &quot;MoveRightAndModifySelection&quot;, { executeMoveRightAndModifySelection, supportedFromMenuOrKeyBinding, enabledVisibleSelectionOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1651         { &quot;MoveToBeginningOfDocument&quot;, { executeMoveToBeginningOfDocument, supportedFromMenuOrKeyBinding, enabledInEditableTextOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1652         { &quot;MoveToBeginningOfDocumentAndModifySelection&quot;, { executeMoveToBeginningOfDocumentAndModifySelection, supportedFromMenuOrKeyBinding, enabledVisibleSelectionOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1653         { &quot;MoveToBeginningOfLine&quot;, { executeMoveToBeginningOfLine, supportedFromMenuOrKeyBinding, enabledInEditableTextOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1654         { &quot;MoveToBeginningOfLineAndModifySelection&quot;, { executeMoveToBeginningOfLineAndModifySelection, supportedFromMenuOrKeyBinding, enabledVisibleSelectionOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1655         { &quot;MoveToBeginningOfParagraph&quot;, { executeMoveToBeginningOfParagraph, supportedFromMenuOrKeyBinding, enabledInEditableTextOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1656         { &quot;MoveToBeginningOfParagraphAndModifySelection&quot;, { executeMoveToBeginningOfParagraphAndModifySelection, supportedFromMenuOrKeyBinding, enabledVisibleSelectionOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1657         { &quot;MoveToBeginningOfSentence&quot;, { executeMoveToBeginningOfSentence, supportedFromMenuOrKeyBinding, enabledInEditableTextOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1658         { &quot;MoveToBeginningOfSentenceAndModifySelection&quot;, { executeMoveToBeginningOfSentenceAndModifySelection, supportedFromMenuOrKeyBinding, enabledVisibleSelectionOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1659         { &quot;MoveToEndOfDocument&quot;, { executeMoveToEndOfDocument, supportedFromMenuOrKeyBinding, enabledInEditableTextOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1660         { &quot;MoveToEndOfDocumentAndModifySelection&quot;, { executeMoveToEndOfDocumentAndModifySelection, supportedFromMenuOrKeyBinding, enabledVisibleSelectionOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1661         { &quot;MoveToEndOfLine&quot;, { executeMoveToEndOfLine, supportedFromMenuOrKeyBinding, enabledInEditableTextOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1662         { &quot;MoveToEndOfLineAndModifySelection&quot;, { executeMoveToEndOfLineAndModifySelection, supportedFromMenuOrKeyBinding, enabledVisibleSelectionOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1663         { &quot;MoveToEndOfParagraph&quot;, { executeMoveToEndOfParagraph, supportedFromMenuOrKeyBinding, enabledInEditableTextOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1664         { &quot;MoveToEndOfParagraphAndModifySelection&quot;, { executeMoveToEndOfParagraphAndModifySelection, supportedFromMenuOrKeyBinding, enabledVisibleSelectionOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1665         { &quot;MoveToEndOfSentence&quot;, { executeMoveToEndOfSentence, supportedFromMenuOrKeyBinding, enabledInEditableTextOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1666         { &quot;MoveToEndOfSentenceAndModifySelection&quot;, { executeMoveToEndOfSentenceAndModifySelection, supportedFromMenuOrKeyBinding, enabledVisibleSelectionOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1667         { &quot;MoveToLeftEndOfLine&quot;, { executeMoveToLeftEndOfLine, supportedFromMenuOrKeyBinding, enabledInEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1668         { &quot;MoveToLeftEndOfLineAndModifySelection&quot;, { executeMoveToLeftEndOfLineAndModifySelection, supportedFromMenuOrKeyBinding, enabledInEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1669         { &quot;MoveToRightEndOfLine&quot;, { executeMoveToRightEndOfLine, supportedFromMenuOrKeyBinding, enabledInEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1670         { &quot;MoveToRightEndOfLineAndModifySelection&quot;, { executeMoveToRightEndOfLineAndModifySelection, supportedFromMenuOrKeyBinding, enabledInEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1671         { &quot;MoveUp&quot;, { executeMoveUp, supportedFromMenuOrKeyBinding, enabledInEditableTextOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1672         { &quot;MoveUpAndModifySelection&quot;, { executeMoveUpAndModifySelection, supportedFromMenuOrKeyBinding, enabledVisibleSelectionOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1673         { &quot;MoveWordBackward&quot;, { executeMoveWordBackward, supportedFromMenuOrKeyBinding, enabledInEditableTextOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1674         { &quot;MoveWordBackwardAndModifySelection&quot;, { executeMoveWordBackwardAndModifySelection, supportedFromMenuOrKeyBinding, enabledVisibleSelectionOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1675         { &quot;MoveWordForward&quot;, { executeMoveWordForward, supportedFromMenuOrKeyBinding, enabledInEditableTextOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1676         { &quot;MoveWordForwardAndModifySelection&quot;, { executeMoveWordForwardAndModifySelection, supportedFromMenuOrKeyBinding, enabledVisibleSelectionOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1677         { &quot;MoveWordLeft&quot;, { executeMoveWordLeft, supportedFromMenuOrKeyBinding, enabledInEditableTextOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1678         { &quot;MoveWordLeftAndModifySelection&quot;, { executeMoveWordLeftAndModifySelection, supportedFromMenuOrKeyBinding, enabledVisibleSelectionOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1679         { &quot;MoveWordRight&quot;, { executeMoveWordRight, supportedFromMenuOrKeyBinding, enabledInEditableTextOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1680         { &quot;MoveWordRightAndModifySelection&quot;, { executeMoveWordRightAndModifySelection, supportedFromMenuOrKeyBinding, enabledVisibleSelectionOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1681         { &quot;Outdent&quot;, { executeOutdent, supported, enabledInRichlyEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1682         { &quot;OverWrite&quot;, { executeToggleOverwrite, supportedFromMenuOrKeyBinding, enabledInRichlyEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1683         { &quot;Paste&quot;, { executePaste, supportedPaste, enabledPaste, stateNone, valueNull, notTextInsertion, allowExecutionWhenDisabledPaste } },
1684         { &quot;PasteAndMatchStyle&quot;, { executePasteAndMatchStyle, supportedPaste, enabledPaste, stateNone, valueNull, notTextInsertion, allowExecutionWhenDisabledPaste } },
1685         { &quot;PasteAsPlainText&quot;, { executePasteAsPlainText, supportedPaste, enabledPaste, stateNone, valueNull, notTextInsertion, allowExecutionWhenDisabledPaste } },
1686         { &quot;PasteAsQuotation&quot;, { executePasteAsQuotation, supportedPaste, enabledPaste, stateNone, valueNull, notTextInsertion, allowExecutionWhenDisabledPaste } },
1687         { &quot;Print&quot;, { executePrint, supported, enabled, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1688         { &quot;Redo&quot;, { executeRedo, supported, enabledRedo, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1689         { &quot;RemoveFormat&quot;, { executeRemoveFormat, supported, enabledRangeInEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1690         { &quot;ScrollPageBackward&quot;, { executeScrollPageBackward, supportedFromMenuOrKeyBinding, enabled, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1691         { &quot;ScrollPageForward&quot;, { executeScrollPageForward, supportedFromMenuOrKeyBinding, enabled, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1692         { &quot;ScrollLineUp&quot;, { executeScrollLineUp, supportedFromMenuOrKeyBinding, enabled, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1693         { &quot;ScrollLineDown&quot;, { executeScrollLineDown, supportedFromMenuOrKeyBinding, enabled, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1694         { &quot;ScrollToBeginningOfDocument&quot;, { executeScrollToBeginningOfDocument, supportedFromMenuOrKeyBinding, enabled, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1695         { &quot;ScrollToEndOfDocument&quot;, { executeScrollToEndOfDocument, supportedFromMenuOrKeyBinding, enabled, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1696         { &quot;SelectAll&quot;, { executeSelectAll, supported, enabled, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1697         { &quot;SelectLine&quot;, { executeSelectLine, supportedFromMenuOrKeyBinding, enabledVisibleSelection, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1698         { &quot;SelectParagraph&quot;, { executeSelectParagraph, supportedFromMenuOrKeyBinding, enabledVisibleSelection, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1699         { &quot;SelectSentence&quot;, { executeSelectSentence, supportedFromMenuOrKeyBinding, enabledVisibleSelection, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1700         { &quot;SelectToMark&quot;, { executeSelectToMark, supportedFromMenuOrKeyBinding, enabledVisibleSelectionAndMark, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1701         { &quot;SelectWord&quot;, { executeSelectWord, supportedFromMenuOrKeyBinding, enabledVisibleSelection, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1702         { &quot;SetMark&quot;, { executeSetMark, supportedFromMenuOrKeyBinding, enabledVisibleSelection, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1703         { &quot;Strikethrough&quot;, { executeStrikethrough, supported, enabledInRichlyEditableText, stateStrikethrough, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1704         { &quot;StyleWithCSS&quot;, { executeStyleWithCSS, supported, enabled, stateStyleWithCSS, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1705         { &quot;Subscript&quot;, { executeSubscript, supported, enabledInRichlyEditableText, stateSubscript, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1706         { &quot;Superscript&quot;, { executeSuperscript, supported, enabledInRichlyEditableText, stateSuperscript, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1707         { &quot;SwapWithMark&quot;, { executeSwapWithMark, supportedFromMenuOrKeyBinding, enabledVisibleSelectionAndMark, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1708         { &quot;ToggleBold&quot;, { executeToggleBold, supportedFromMenuOrKeyBinding, enabledInRichlyEditableText, stateBold, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1709         { &quot;ToggleItalic&quot;, { executeToggleItalic, supportedFromMenuOrKeyBinding, enabledInRichlyEditableText, stateItalic, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1710         { &quot;ToggleUnderline&quot;, { executeUnderline, supportedFromMenuOrKeyBinding, enabledInRichlyEditableText, stateUnderline, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1711         { &quot;Transpose&quot;, { executeTranspose, supported, enableCaretInEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1712         { &quot;Underline&quot;, { executeUnderline, supported, enabledInRichlyEditableText, stateUnderline, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1713         { &quot;Undo&quot;, { executeUndo, supported, enabledUndo, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1714         { &quot;Unlink&quot;, { executeUnlink, supported, enabledRangeInRichlyEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1715         { &quot;Unscript&quot;, { executeUnscript, supportedFromMenuOrKeyBinding, enabledInRichlyEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1716         { &quot;Unselect&quot;, { executeUnselect, supported, enabledVisibleSelection, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1717         { &quot;UseCSS&quot;, { executeUseCSS, supported, enabled, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1718         { &quot;Yank&quot;, { executeYank, supportedFromMenuOrKeyBinding, enabledInEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1719         { &quot;YankAndSelect&quot;, { executeYankAndSelect, supportedFromMenuOrKeyBinding, enabledInEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1720 
1721 #if PLATFORM(GTK)
1722         { &quot;PasteGlobalSelection&quot;, { executePasteGlobalSelection, supportedFromMenuOrKeyBinding, enabledPaste, stateNone, valueNull, notTextInsertion, allowExecutionWhenDisabled } },
1723 #endif
1724 
1725 #if PLATFORM(COCOA)
1726         { &quot;TakeFindStringFromSelection&quot;, { executeTakeFindStringFromSelection, supportedFromMenuOrKeyBinding, enabledTakeFindStringFromSelection, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1727 #endif
1728     };
1729 
1730     // These unsupported commands are listed here since they appear in the Microsoft
1731     // documentation used as the starting point for our DOM executeCommand support.
1732     //
1733     // 2D-Position (not supported)
1734     // AbsolutePosition (not supported)
1735     // BlockDirLTR (not supported)
1736     // BlockDirRTL (not supported)
1737     // BrowseMode (not supported)
1738     // ClearAuthenticationCache (not supported)
1739     // CreateBookmark (not supported)
1740     // DirLTR (not supported)
1741     // DirRTL (not supported)
1742     // EditMode (not supported)
1743     // InlineDirLTR (not supported)
1744     // InlineDirRTL (not supported)
1745     // InsertButton (not supported)
1746     // InsertFieldSet (not supported)
1747     // InsertIFrame (not supported)
1748     // InsertInputButton (not supported)
1749     // InsertInputCheckbox (not supported)
1750     // InsertInputFileUpload (not supported)
1751     // InsertInputHidden (not supported)
1752     // InsertInputImage (not supported)
1753     // InsertInputPassword (not supported)
1754     // InsertInputRadio (not supported)
1755     // InsertInputReset (not supported)
1756     // InsertInputSubmit (not supported)
1757     // InsertInputText (not supported)
1758     // InsertMarquee (not supported)
1759     // InsertSelectDropDown (not supported)
1760     // InsertSelectListBox (not supported)
1761     // InsertTextArea (not supported)
1762     // LiveResize (not supported)
1763     // MultipleSelection (not supported)
1764     // Open (not supported)
1765     // PlayImage (not supported)
1766     // Refresh (not supported)
1767     // RemoveParaFormat (not supported)
1768     // SaveAs (not supported)
1769     // SizeToControl (not supported)
1770     // SizeToControlHeight (not supported)
1771     // SizeToControlWidth (not supported)
1772     // Stop (not supported)
1773     // StopImage (not supported)
1774     // Unbookmark (not supported)
1775 
1776     CommandMap&amp; commandMap = *new CommandMap;
1777 
1778     for (auto&amp; command : commands) {
1779         ASSERT(!commandMap.get(command.name));
1780         commandMap.set(command.name, &amp;command.command);
1781     }
1782 
1783     return commandMap;
1784 }
1785 
1786 static const EditorInternalCommand* internalCommand(const String&amp; commandName)
1787 {
1788     static const CommandMap&amp; commandMap = createCommandMap();
1789     return commandName.isEmpty() ? 0 : commandMap.get(commandName);
1790 }
1791 
1792 Editor::Command Editor::command(const String&amp; commandName)
1793 {
1794     return Command(internalCommand(commandName), CommandFromMenuOrKeyBinding, m_frame);
1795 }
1796 
1797 Editor::Command Editor::command(const String&amp; commandName, EditorCommandSource source)
1798 {
1799     return Command(internalCommand(commandName), source, m_frame);
1800 }
1801 
1802 bool Editor::commandIsSupportedFromMenuOrKeyBinding(const String&amp; commandName)
1803 {
1804     return internalCommand(commandName);
1805 }
1806 
1807 Editor::Command::Command()
1808 {
1809 }
1810 
1811 Editor::Command::Command(const EditorInternalCommand* command, EditorCommandSource source, Frame&amp; frame)
1812     : m_command(command)
1813     , m_source(source)
1814     , m_frame(command ? &amp;frame : nullptr)
1815 {
1816     ASSERT(command || !m_frame);
1817 }
1818 
1819 bool Editor::Command::execute(const String&amp; parameter, Event* triggeringEvent) const
1820 {
1821     if (!isEnabled(triggeringEvent)) {
1822         // Let certain commands be executed when performed explicitly even if they are disabled.
1823         if (!allowExecutionWhenDisabled())
1824             return false;
1825     }
1826     auto document = m_frame-&gt;document();
1827     document-&gt;updateLayoutIgnorePendingStylesheets();
1828     if (m_frame-&gt;document() != document)
1829         return false;
1830 
1831     return m_command-&gt;execute(*m_frame, triggeringEvent, m_source, parameter);
1832 }
1833 
1834 bool Editor::Command::execute(Event* triggeringEvent) const
1835 {
1836     return execute(String(), triggeringEvent);
1837 }
1838 
1839 bool Editor::Command::isSupported() const
1840 {
1841     if (!m_command)
1842         return false;
1843     switch (m_source) {
1844     case CommandFromMenuOrKeyBinding:
1845         return true;
1846     case CommandFromDOM:
1847     case CommandFromDOMWithUserInterface:
1848         return m_command-&gt;isSupportedFromDOM(m_frame.get());
1849     }
1850     ASSERT_NOT_REACHED();
1851     return false;
1852 }
1853 
1854 bool Editor::Command::isEnabled(Event* triggeringEvent) const
1855 {
1856     if (!isSupported() || !m_frame)
1857         return false;
1858     return m_command-&gt;isEnabled(*m_frame, triggeringEvent, m_source);
1859 }
1860 
1861 TriState Editor::Command::state(Event* triggeringEvent) const
1862 {
1863     if (!isSupported() || !m_frame)
1864         return FalseTriState;
1865     return m_command-&gt;state(*m_frame, triggeringEvent);
1866 }
1867 
1868 String Editor::Command::value(Event* triggeringEvent) const
1869 {
1870     if (!isSupported() || !m_frame)
1871         return String();
1872     if (m_command-&gt;value == valueNull &amp;&amp; m_command-&gt;state != stateNone)
1873         return m_command-&gt;state(*m_frame, triggeringEvent) == TrueTriState ? &quot;true&quot;_s : &quot;false&quot;_s;
1874     return m_command-&gt;value(*m_frame, triggeringEvent);
1875 }
1876 
1877 bool Editor::Command::isTextInsertion() const
1878 {
1879     return m_command &amp;&amp; m_command-&gt;isTextInsertion;
1880 }
1881 
1882 bool Editor::Command::allowExecutionWhenDisabled() const
1883 {
1884     if (!isSupported() || !m_frame)
1885         return false;
1886     return m_command-&gt;allowExecutionWhenDisabled(*m_frame, m_source);
1887 }
1888 
1889 } // namespace WebCore
    </pre>
  </body>
</html>