<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/WTF/wtf/dtoa/bignum-dtoa.cc</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../dtoa.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="bignum-dtoa.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WTF/wtf/dtoa/bignum-dtoa.cc</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -34,67 +34,67 @@</span>
  #include &lt;wtf/dtoa/bignum.h&gt;
  #include &lt;wtf/dtoa/ieee.h&gt;
  
  namespace WTF {
  namespace double_conversion {
<span class="udiff-line-modified-removed">-     </span>
<span class="udiff-line-modified-added">+ </span>
  static int NormalizedExponent(uint64_t significand, int exponent) {
<span class="udiff-line-modified-removed">-         ASSERT(significand != 0);</span>
<span class="udiff-line-modified-removed">-         while ((significand &amp; Double::kHiddenBit) == 0) {</span>
<span class="udiff-line-modified-removed">-             significand = significand &lt;&lt; 1;</span>
<span class="udiff-line-modified-removed">-             exponent = exponent - 1;</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-removed">-         return exponent;</span>
<span class="udiff-line-modified-added">+   ASSERT(significand != 0);</span>
<span class="udiff-line-modified-added">+   while ((significand &amp; Double::kHiddenBit) == 0) {</span>
<span class="udiff-line-modified-added">+     significand = significand &lt;&lt; 1;</span>
<span class="udiff-line-modified-added">+     exponent = exponent - 1;</span>
<span class="udiff-line-modified-added">+   }</span>
<span class="udiff-line-modified-added">+   return exponent;</span>
  }
<span class="udiff-line-modified-removed">-     </span>
<span class="udiff-line-modified-removed">-     </span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+ </span>
  // Forward declarations:
  // Returns an estimation of k such that 10^(k-1) &lt;= v &lt; 10^k.
  static int EstimatePower(int exponent);
  // Computes v / 10^estimated_power exactly, as a ratio of two bignums, numerator
  // and denominator.
  static void InitialScaledStartValues(uint64_t significand,
                                       int exponent,
                                       bool lower_boundary_is_closer,
<span class="udiff-line-modified-removed">-                                          int estimated_power,</span>
<span class="udiff-line-modified-removed">-                                          bool need_boundary_deltas,</span>
<span class="udiff-line-modified-removed">-                                          Bignum* numerator,</span>
<span class="udiff-line-modified-removed">-                                          Bignum* denominator,</span>
<span class="udiff-line-modified-removed">-                                          Bignum* delta_minus,</span>
<span class="udiff-line-modified-removed">-                                          Bignum* delta_plus);</span>
<span class="udiff-line-modified-added">+                                      int estimated_power,</span>
<span class="udiff-line-modified-added">+                                      bool need_boundary_deltas,</span>
<span class="udiff-line-modified-added">+                                      Bignum* numerator,</span>
<span class="udiff-line-modified-added">+                                      Bignum* denominator,</span>
<span class="udiff-line-modified-added">+                                      Bignum* delta_minus,</span>
<span class="udiff-line-modified-added">+                                      Bignum* delta_plus);</span>
  // Multiplies numerator/denominator so that its values lies in the range 1-10.
  // Returns decimal_point s.t.
  //  v = numerator&#39;/denominator&#39; * 10^(decimal_point-1)
  //     where numerator&#39; and denominator&#39; are the values of numerator and
  //     denominator after the call to this function.
  static void FixupMultiply10(int estimated_power, bool is_even,
<span class="udiff-line-modified-removed">-                                 int* decimal_point,</span>
<span class="udiff-line-modified-removed">-                                 Bignum* numerator, Bignum* denominator,</span>
<span class="udiff-line-modified-removed">-                                 Bignum* delta_minus, Bignum* delta_plus);</span>
<span class="udiff-line-modified-added">+                             int* decimal_point,</span>
<span class="udiff-line-modified-added">+                             Bignum* numerator, Bignum* denominator,</span>
<span class="udiff-line-modified-added">+                             Bignum* delta_minus, Bignum* delta_plus);</span>
  // Generates digits from the left to the right and stops when the generated
  // digits yield the shortest decimal representation of v.
  static void GenerateShortestDigits(Bignum* numerator, Bignum* denominator,
<span class="udiff-line-modified-removed">-                                        Bignum* delta_minus, Bignum* delta_plus,</span>
<span class="udiff-line-modified-removed">-                                        bool is_even,</span>
<span class="udiff-line-modified-removed">-                                        BufferReference&lt;char&gt; buffer, int* length);</span>
<span class="udiff-line-modified-added">+                                    Bignum* delta_minus, Bignum* delta_plus,</span>
<span class="udiff-line-modified-added">+                                    bool is_even,</span>
<span class="udiff-line-modified-added">+                                    BufferReference&lt;char&gt; buffer, int* length);</span>
  // Generates &#39;requested_digits&#39; after the decimal point.
  static void BignumToFixed(int requested_digits, int* decimal_point,
<span class="udiff-line-modified-removed">-                               Bignum* numerator, Bignum* denominator,</span>
<span class="udiff-line-modified-removed">-                               BufferReference&lt;char&gt;(buffer), int* length);</span>
<span class="udiff-line-modified-added">+                           Bignum* numerator, Bignum* denominator,</span>
<span class="udiff-line-modified-added">+                           BufferReference&lt;char&gt;(buffer), int* length);</span>
  // Generates &#39;count&#39; digits of numerator/denominator.
  // Once &#39;count&#39; digits have been produced rounds the result depending on the
  // remainder (remainders of exactly .5 round upwards). Might update the
  // decimal_point when rounding up (for example for 0.9999).
  static void GenerateCountedDigits(int count, int* decimal_point,
<span class="udiff-line-modified-removed">-                                       Bignum* numerator, Bignum* denominator,</span>
<span class="udiff-line-modified-removed">-                                       BufferReference&lt;char&gt;(buffer), int* length);</span>
<span class="udiff-line-modified-removed">-     </span>
<span class="udiff-line-modified-removed">-     </span>
<span class="udiff-line-modified-added">+                                   Bignum* numerator, Bignum* denominator,</span>
<span class="udiff-line-modified-added">+                                   BufferReference&lt;char&gt;(buffer), int* length);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+ </span>
  void BignumDtoa(double v, BignumDtoaMode mode, int requested_digits,
<span class="udiff-line-modified-removed">-                     BufferReference&lt;char&gt; buffer, int* length, int* decimal_point) {</span>
<span class="udiff-line-modified-removed">-         ASSERT(v &gt; 0);</span>
<span class="udiff-line-modified-removed">-         ASSERT(!Double(v).IsSpecial());</span>
<span class="udiff-line-modified-added">+                 BufferReference&lt;char&gt; buffer, int* length, int* decimal_point) {</span>
<span class="udiff-line-modified-added">+   ASSERT(v &gt; 0);</span>
<span class="udiff-line-modified-added">+   ASSERT(!Double(v).IsSpecial());</span>
    uint64_t significand;
    int exponent;
    bool lower_boundary_is_closer;
    if (mode == BIGNUM_DTOA_SHORTEST_SINGLE) {
      float f = static_cast&lt;float&gt;(v);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -108,72 +108,72 @@</span>
      lower_boundary_is_closer = Double(v).LowerBoundaryIsCloser();
    }
    bool need_boundary_deltas =
        (mode == BIGNUM_DTOA_SHORTEST || mode == BIGNUM_DTOA_SHORTEST_SINGLE);
  
<span class="udiff-line-modified-removed">-         bool is_even = (significand &amp; 1) == 0;</span>
<span class="udiff-line-modified-removed">-         int normalized_exponent = NormalizedExponent(significand, exponent);</span>
<span class="udiff-line-modified-removed">-         // estimated_power might be too low by 1.</span>
<span class="udiff-line-modified-removed">-         int estimated_power = EstimatePower(normalized_exponent);</span>
<span class="udiff-line-modified-removed">-         </span>
<span class="udiff-line-modified-removed">-         // Shortcut for Fixed.</span>
<span class="udiff-line-modified-removed">-         // The requested digits correspond to the digits after the point. If the</span>
<span class="udiff-line-modified-removed">-         // number is much too small, then there is no need in trying to get any</span>
<span class="udiff-line-modified-removed">-         // digits.</span>
<span class="udiff-line-modified-removed">-         if (mode == BIGNUM_DTOA_FIXED &amp;&amp; -estimated_power - 1 &gt; requested_digits) {</span>
<span class="udiff-line-modified-removed">-             buffer[0] = &#39;\0&#39;;</span>
<span class="udiff-line-modified-removed">-             *length = 0;</span>
<span class="udiff-line-modified-removed">-             // Set decimal-point to -requested_digits. This is what Gay does.</span>
<span class="udiff-line-modified-removed">-             // Note that it should not have any effect anyways since the string is</span>
<span class="udiff-line-modified-removed">-             // empty.</span>
<span class="udiff-line-modified-removed">-             *decimal_point = -requested_digits;</span>
<span class="udiff-line-modified-removed">-             return;</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-removed">-         </span>
<span class="udiff-line-modified-removed">-         Bignum numerator;</span>
<span class="udiff-line-modified-removed">-         Bignum denominator;</span>
<span class="udiff-line-modified-removed">-         Bignum delta_minus;</span>
<span class="udiff-line-modified-removed">-         Bignum delta_plus;</span>
<span class="udiff-line-modified-removed">-         // Make sure the bignum can grow large enough. The smallest double equals</span>
<span class="udiff-line-modified-removed">-         // 4e-324. In this case the denominator needs fewer than 324*4 binary digits.</span>
<span class="udiff-line-modified-removed">-         // The maximum double is 1.7976931348623157e308 which needs fewer than</span>
<span class="udiff-line-modified-removed">-         // 308*4 binary digits.</span>
<span class="udiff-line-modified-removed">-         ASSERT(Bignum::kMaxSignificantBits &gt;= 324*4);</span>
<span class="udiff-line-modified-added">+   bool is_even = (significand &amp; 1) == 0;</span>
<span class="udiff-line-modified-added">+   int normalized_exponent = NormalizedExponent(significand, exponent);</span>
<span class="udiff-line-modified-added">+   // estimated_power might be too low by 1.</span>
<span class="udiff-line-modified-added">+   int estimated_power = EstimatePower(normalized_exponent);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   // Shortcut for Fixed.</span>
<span class="udiff-line-modified-added">+   // The requested digits correspond to the digits after the point. If the</span>
<span class="udiff-line-modified-added">+   // number is much too small, then there is no need in trying to get any</span>
<span class="udiff-line-modified-added">+   // digits.</span>
<span class="udiff-line-modified-added">+   if (mode == BIGNUM_DTOA_FIXED &amp;&amp; -estimated_power - 1 &gt; requested_digits) {</span>
<span class="udiff-line-modified-added">+     buffer[0] = &#39;\0&#39;;</span>
<span class="udiff-line-modified-added">+     *length = 0;</span>
<span class="udiff-line-modified-added">+     // Set decimal-point to -requested_digits. This is what Gay does.</span>
<span class="udiff-line-modified-added">+     // Note that it should not have any effect anyways since the string is</span>
<span class="udiff-line-modified-added">+     // empty.</span>
<span class="udiff-line-modified-added">+     *decimal_point = -requested_digits;</span>
<span class="udiff-line-modified-added">+     return;</span>
<span class="udiff-line-modified-added">+   }</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   Bignum numerator;</span>
<span class="udiff-line-modified-added">+   Bignum denominator;</span>
<span class="udiff-line-modified-added">+   Bignum delta_minus;</span>
<span class="udiff-line-modified-added">+   Bignum delta_plus;</span>
<span class="udiff-line-modified-added">+   // Make sure the bignum can grow large enough. The smallest double equals</span>
<span class="udiff-line-modified-added">+   // 4e-324. In this case the denominator needs fewer than 324*4 binary digits.</span>
<span class="udiff-line-modified-added">+   // The maximum double is 1.7976931348623157e308 which needs fewer than</span>
<span class="udiff-line-modified-added">+   // 308*4 binary digits.</span>
<span class="udiff-line-modified-added">+   ASSERT(Bignum::kMaxSignificantBits &gt;= 324*4);</span>
    InitialScaledStartValues(significand, exponent, lower_boundary_is_closer,
                             estimated_power, need_boundary_deltas,
<span class="udiff-line-modified-removed">-                                  &amp;numerator, &amp;denominator,</span>
<span class="udiff-line-modified-removed">-                                  &amp;delta_minus, &amp;delta_plus);</span>
<span class="udiff-line-modified-removed">-         // We now have v = (numerator / denominator) * 10^estimated_power.</span>
<span class="udiff-line-modified-removed">-         FixupMultiply10(estimated_power, is_even, decimal_point,</span>
<span class="udiff-line-modified-removed">-                         &amp;numerator, &amp;denominator,</span>
<span class="udiff-line-modified-removed">-                         &amp;delta_minus, &amp;delta_plus);</span>
<span class="udiff-line-modified-removed">-         // We now have v = (numerator / denominator) * 10^(decimal_point-1), and</span>
<span class="udiff-line-modified-removed">-         //  1 &lt;= (numerator + delta_plus) / denominator &lt; 10</span>
<span class="udiff-line-modified-removed">-         switch (mode) {</span>
<span class="udiff-line-modified-removed">-             case BIGNUM_DTOA_SHORTEST:</span>
<span class="udiff-line-modified-added">+                            &amp;numerator, &amp;denominator,</span>
<span class="udiff-line-modified-added">+                            &amp;delta_minus, &amp;delta_plus);</span>
<span class="udiff-line-modified-added">+   // We now have v = (numerator / denominator) * 10^estimated_power.</span>
<span class="udiff-line-modified-added">+   FixupMultiply10(estimated_power, is_even, decimal_point,</span>
<span class="udiff-line-modified-added">+                   &amp;numerator, &amp;denominator,</span>
<span class="udiff-line-modified-added">+                   &amp;delta_minus, &amp;delta_plus);</span>
<span class="udiff-line-modified-added">+   // We now have v = (numerator / denominator) * 10^(decimal_point-1), and</span>
<span class="udiff-line-modified-added">+   //  1 &lt;= (numerator + delta_plus) / denominator &lt; 10</span>
<span class="udiff-line-modified-added">+   switch (mode) {</span>
<span class="udiff-line-modified-added">+     case BIGNUM_DTOA_SHORTEST:</span>
      case BIGNUM_DTOA_SHORTEST_SINGLE:
<span class="udiff-line-modified-removed">-                 GenerateShortestDigits(&amp;numerator, &amp;denominator,</span>
<span class="udiff-line-modified-removed">-                                        &amp;delta_minus, &amp;delta_plus,</span>
<span class="udiff-line-modified-removed">-                                        is_even, buffer, length);</span>
<span class="udiff-line-modified-removed">-                 break;</span>
<span class="udiff-line-modified-removed">-             case BIGNUM_DTOA_FIXED:</span>
<span class="udiff-line-modified-removed">-                 BignumToFixed(requested_digits, decimal_point,</span>
<span class="udiff-line-modified-removed">-                               &amp;numerator, &amp;denominator,</span>
<span class="udiff-line-modified-removed">-                               buffer, length);</span>
<span class="udiff-line-modified-removed">-                 break;</span>
<span class="udiff-line-modified-removed">-             case BIGNUM_DTOA_PRECISION:</span>
<span class="udiff-line-modified-removed">-                 GenerateCountedDigits(requested_digits, decimal_point,</span>
<span class="udiff-line-modified-removed">-                                       &amp;numerator, &amp;denominator,</span>
<span class="udiff-line-modified-removed">-                                       buffer, length);</span>
<span class="udiff-line-modified-removed">-                 break;</span>
<span class="udiff-line-modified-removed">-             default:</span>
<span class="udiff-line-modified-removed">-                 UNREACHABLE();</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-removed">-         buffer[*length] = &#39;\0&#39;;</span>
<span class="udiff-line-modified-added">+       GenerateShortestDigits(&amp;numerator, &amp;denominator,</span>
<span class="udiff-line-modified-added">+                              &amp;delta_minus, &amp;delta_plus,</span>
<span class="udiff-line-modified-added">+                              is_even, buffer, length);</span>
<span class="udiff-line-modified-added">+       break;</span>
<span class="udiff-line-modified-added">+     case BIGNUM_DTOA_FIXED:</span>
<span class="udiff-line-modified-added">+       BignumToFixed(requested_digits, decimal_point,</span>
<span class="udiff-line-modified-added">+                     &amp;numerator, &amp;denominator,</span>
<span class="udiff-line-modified-added">+                     buffer, length);</span>
<span class="udiff-line-modified-added">+       break;</span>
<span class="udiff-line-modified-added">+     case BIGNUM_DTOA_PRECISION:</span>
<span class="udiff-line-modified-added">+       GenerateCountedDigits(requested_digits, decimal_point,</span>
<span class="udiff-line-modified-added">+                             &amp;numerator, &amp;denominator,</span>
<span class="udiff-line-modified-added">+                             buffer, length);</span>
<span class="udiff-line-modified-added">+       break;</span>
<span class="udiff-line-modified-added">+     default:</span>
<span class="udiff-line-modified-added">+       UNREACHABLE();</span>
<span class="udiff-line-modified-added">+   }</span>
<span class="udiff-line-modified-added">+   buffer[*length] = &#39;\0&#39;;</span>
  }
<span class="udiff-line-modified-removed">-     </span>
<span class="udiff-line-modified-removed">-     </span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+ </span>
  // The procedure starts generating digits from the left to the right and stops
  // when the generated digits yield the shortest decimal representation of v. A
  // decimal representation of v is a number lying closer to v than to any other
  // double, so it converts to v when read.
  //
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -184,194 +184,194 @@</span>
  //
  // Precondition: 0 &lt;= (numerator+delta_plus) / denominator &lt; 10.
  //   If 1 &lt;= (numerator+delta_plus) / denominator &lt; 10 then no leading 0 digit
  //   will be produced. This should be the standard precondition.
  static void GenerateShortestDigits(Bignum* numerator, Bignum* denominator,
<span class="udiff-line-modified-removed">-                                        Bignum* delta_minus, Bignum* delta_plus,</span>
<span class="udiff-line-modified-removed">-                                        bool is_even,</span>
<span class="udiff-line-modified-removed">-                                        BufferReference&lt;char&gt; buffer, int* length) {</span>
<span class="udiff-line-modified-removed">-         // Small optimization: if delta_minus and delta_plus are the same just reuse</span>
<span class="udiff-line-modified-removed">-         // one of the two bignums.</span>
<span class="udiff-line-modified-removed">-         if (Bignum::Equal(*delta_minus, *delta_plus)) {</span>
<span class="udiff-line-modified-removed">-             delta_plus = delta_minus;</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-removed">-         *length = 0;</span>
<span class="udiff-line-modified-added">+                                    Bignum* delta_minus, Bignum* delta_plus,</span>
<span class="udiff-line-modified-added">+                                    bool is_even,</span>
<span class="udiff-line-modified-added">+                                    BufferReference&lt;char&gt; buffer, int* length) {</span>
<span class="udiff-line-modified-added">+   // Small optimization: if delta_minus and delta_plus are the same just reuse</span>
<span class="udiff-line-modified-added">+   // one of the two bignums.</span>
<span class="udiff-line-modified-added">+   if (Bignum::Equal(*delta_minus, *delta_plus)) {</span>
<span class="udiff-line-modified-added">+     delta_plus = delta_minus;</span>
<span class="udiff-line-modified-added">+   }</span>
<span class="udiff-line-modified-added">+   *length = 0;</span>
    for (;;) {
<span class="udiff-line-modified-removed">-             uint16_t digit;</span>
<span class="udiff-line-modified-removed">-             digit = numerator-&gt;DivideModuloIntBignum(*denominator);</span>
<span class="udiff-line-modified-removed">-             ASSERT(digit &lt;= 9);  // digit is a uint16_t and therefore always positive.</span>
<span class="udiff-line-modified-removed">-             // digit = numerator / denominator (integer division).</span>
<span class="udiff-line-modified-removed">-             // numerator = numerator % denominator.</span>
<span class="udiff-line-modified-added">+     uint16_t digit;</span>
<span class="udiff-line-modified-added">+     digit = numerator-&gt;DivideModuloIntBignum(*denominator);</span>
<span class="udiff-line-modified-added">+     ASSERT(digit &lt;= 9);  // digit is a uint16_t and therefore always positive.</span>
<span class="udiff-line-modified-added">+     // digit = numerator / denominator (integer division).</span>
<span class="udiff-line-modified-added">+     // numerator = numerator % denominator.</span>
      buffer[(*length)++] = static_cast&lt;char&gt;(digit + &#39;0&#39;);
<span class="udiff-line-modified-removed">-             </span>
<span class="udiff-line-modified-removed">-             // Can we stop already?</span>
<span class="udiff-line-modified-removed">-             // If the remainder of the division is less than the distance to the lower</span>
<span class="udiff-line-modified-removed">-             // boundary we can stop. In this case we simply round down (discarding the</span>
<span class="udiff-line-modified-removed">-             // remainder).</span>
<span class="udiff-line-modified-removed">-             // Similarly we test if we can round up (using the upper boundary).</span>
<span class="udiff-line-modified-removed">-             bool in_delta_room_minus;</span>
<span class="udiff-line-modified-removed">-             bool in_delta_room_plus;</span>
<span class="udiff-line-modified-removed">-             if (is_even) {</span>
<span class="udiff-line-modified-removed">-                 in_delta_room_minus = Bignum::LessEqual(*numerator, *delta_minus);</span>
<span class="udiff-line-modified-removed">-             } else {</span>
<span class="udiff-line-modified-removed">-                 in_delta_room_minus = Bignum::Less(*numerator, *delta_minus);</span>
<span class="udiff-line-modified-removed">-             }</span>
<span class="udiff-line-modified-removed">-             if (is_even) {</span>
<span class="udiff-line-modified-removed">-                 in_delta_room_plus =</span>
<span class="udiff-line-modified-removed">-                 Bignum::PlusCompare(*numerator, *delta_plus, *denominator) &gt;= 0;</span>
<span class="udiff-line-modified-removed">-             } else {</span>
<span class="udiff-line-modified-removed">-                 in_delta_room_plus =</span>
<span class="udiff-line-modified-removed">-                 Bignum::PlusCompare(*numerator, *delta_plus, *denominator) &gt; 0;</span>
<span class="udiff-line-modified-removed">-             }</span>
<span class="udiff-line-modified-removed">-             if (!in_delta_room_minus &amp;&amp; !in_delta_room_plus) {</span>
<span class="udiff-line-modified-removed">-                 // Prepare for next iteration.</span>
<span class="udiff-line-modified-removed">-                 numerator-&gt;Times10();</span>
<span class="udiff-line-modified-removed">-                 delta_minus-&gt;Times10();</span>
<span class="udiff-line-modified-removed">-                 // We optimized delta_plus to be equal to delta_minus (if they share the</span>
<span class="udiff-line-modified-removed">-                 // same value). So don&#39;t multiply delta_plus if they point to the same</span>
<span class="udiff-line-modified-removed">-                 // object.</span>
<span class="udiff-line-modified-removed">-                 if (delta_minus != delta_plus) {</span>
<span class="udiff-line-modified-removed">-                     delta_plus-&gt;Times10();</span>
<span class="udiff-line-modified-removed">-                 }</span>
<span class="udiff-line-modified-removed">-             } else if (in_delta_room_minus &amp;&amp; in_delta_room_plus) {</span>
<span class="udiff-line-modified-removed">-                 // Let&#39;s see if 2*numerator &lt; denominator.</span>
<span class="udiff-line-modified-removed">-                 // If yes, then the next digit would be &lt; 5 and we can round down.</span>
<span class="udiff-line-modified-removed">-                 int compare = Bignum::PlusCompare(*numerator, *numerator, *denominator);</span>
<span class="udiff-line-modified-removed">-                 if (compare &lt; 0) {</span>
<span class="udiff-line-modified-removed">-                     // Remaining digits are less than .5. -&gt; Round down (== do nothing).</span>
<span class="udiff-line-modified-removed">-                 } else if (compare &gt; 0) {</span>
<span class="udiff-line-modified-removed">-                     // Remaining digits are more than .5 of denominator. -&gt; Round up.</span>
<span class="udiff-line-modified-removed">-                     // Note that the last digit could not be a &#39;9&#39; as otherwise the whole</span>
<span class="udiff-line-modified-removed">-                     // loop would have stopped earlier.</span>
<span class="udiff-line-modified-removed">-                     // We still have an assert here in case the preconditions were not</span>
<span class="udiff-line-modified-removed">-                     // satisfied.</span>
<span class="udiff-line-modified-removed">-                     ASSERT(buffer[(*length) - 1] != &#39;9&#39;);</span>
<span class="udiff-line-modified-removed">-                     buffer[(*length) - 1]++;</span>
<span class="udiff-line-modified-removed">-                 } else {</span>
<span class="udiff-line-modified-removed">-                     // Halfway case.</span>
<span class="udiff-line-modified-removed">-                     // TODO(floitsch): need a way to solve half-way cases.</span>
<span class="udiff-line-modified-removed">-                     //   For now let&#39;s round towards even (since this is what Gay seems to</span>
<span class="udiff-line-modified-removed">-                     //   do).</span>
<span class="udiff-line-modified-removed">-                     </span>
<span class="udiff-line-modified-removed">-                     if ((buffer[(*length) - 1] - &#39;0&#39;) % 2 == 0) {</span>
<span class="udiff-line-modified-removed">-                         // Round down =&gt; Do nothing.</span>
<span class="udiff-line-modified-removed">-                     } else {</span>
<span class="udiff-line-modified-removed">-                         ASSERT(buffer[(*length) - 1] != &#39;9&#39;);</span>
<span class="udiff-line-modified-removed">-                         buffer[(*length) - 1]++;</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-                 return;</span>
<span class="udiff-line-removed">-             } else if (in_delta_room_minus) {</span>
<span class="udiff-line-removed">-                 // Round down (== do nothing).</span>
<span class="udiff-line-removed">-                 return;</span>
<span class="udiff-line-removed">-             } else {  // in_delta_room_plus</span>
<span class="udiff-line-removed">-                 // Round up.</span>
<span class="udiff-line-removed">-                 // Note again that the last digit could not be &#39;9&#39; since this would have</span>
<span class="udiff-line-removed">-                 // stopped the loop earlier.</span>
<span class="udiff-line-removed">-                 // We still have an ASSERT here, in case the preconditions were not</span>
<span class="udiff-line-removed">-                 // satisfied.</span>
<span class="udiff-line-removed">-                 ASSERT(buffer[(*length) -1] != &#39;9&#39;);</span>
<span class="udiff-line-removed">-                 buffer[(*length) - 1]++;</span>
<span class="udiff-line-removed">-                 return;</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+     // Can we stop already?</span>
<span class="udiff-line-modified-added">+     // If the remainder of the division is less than the distance to the lower</span>
<span class="udiff-line-modified-added">+     // boundary we can stop. In this case we simply round down (discarding the</span>
<span class="udiff-line-modified-added">+     // remainder).</span>
<span class="udiff-line-modified-added">+     // Similarly we test if we can round up (using the upper boundary).</span>
<span class="udiff-line-modified-added">+     bool in_delta_room_minus;</span>
<span class="udiff-line-modified-added">+     bool in_delta_room_plus;</span>
<span class="udiff-line-modified-added">+     if (is_even) {</span>
<span class="udiff-line-modified-added">+       in_delta_room_minus = Bignum::LessEqual(*numerator, *delta_minus);</span>
<span class="udiff-line-modified-added">+     } else {</span>
<span class="udiff-line-modified-added">+       in_delta_room_minus = Bignum::Less(*numerator, *delta_minus);</span>
<span class="udiff-line-modified-added">+     }</span>
<span class="udiff-line-modified-added">+     if (is_even) {</span>
<span class="udiff-line-modified-added">+       in_delta_room_plus =</span>
<span class="udiff-line-modified-added">+           Bignum::PlusCompare(*numerator, *delta_plus, *denominator) &gt;= 0;</span>
<span class="udiff-line-modified-added">+     } else {</span>
<span class="udiff-line-modified-added">+       in_delta_room_plus =</span>
<span class="udiff-line-modified-added">+           Bignum::PlusCompare(*numerator, *delta_plus, *denominator) &gt; 0;</span>
<span class="udiff-line-modified-added">+     }</span>
<span class="udiff-line-modified-added">+     if (!in_delta_room_minus &amp;&amp; !in_delta_room_plus) {</span>
<span class="udiff-line-modified-added">+       // Prepare for next iteration.</span>
<span class="udiff-line-modified-added">+       numerator-&gt;Times10();</span>
<span class="udiff-line-modified-added">+       delta_minus-&gt;Times10();</span>
<span class="udiff-line-modified-added">+       // We optimized delta_plus to be equal to delta_minus (if they share the</span>
<span class="udiff-line-modified-added">+       // same value). So don&#39;t multiply delta_plus if they point to the same</span>
<span class="udiff-line-modified-added">+       // object.</span>
<span class="udiff-line-modified-added">+       if (delta_minus != delta_plus) {</span>
<span class="udiff-line-modified-added">+         delta_plus-&gt;Times10();</span>
<span class="udiff-line-modified-added">+       }</span>
<span class="udiff-line-modified-added">+     } else if (in_delta_room_minus &amp;&amp; in_delta_room_plus) {</span>
<span class="udiff-line-modified-added">+       // Let&#39;s see if 2*numerator &lt; denominator.</span>
<span class="udiff-line-modified-added">+       // If yes, then the next digit would be &lt; 5 and we can round down.</span>
<span class="udiff-line-modified-added">+       int compare = Bignum::PlusCompare(*numerator, *numerator, *denominator);</span>
<span class="udiff-line-modified-added">+       if (compare &lt; 0) {</span>
<span class="udiff-line-modified-added">+         // Remaining digits are less than .5. -&gt; Round down (== do nothing).</span>
<span class="udiff-line-modified-added">+       } else if (compare &gt; 0) {</span>
<span class="udiff-line-modified-added">+         // Remaining digits are more than .5 of denominator. -&gt; Round up.</span>
<span class="udiff-line-modified-added">+         // Note that the last digit could not be a &#39;9&#39; as otherwise the whole</span>
<span class="udiff-line-modified-added">+         // loop would have stopped earlier.</span>
<span class="udiff-line-modified-added">+         // We still have an assert here in case the preconditions were not</span>
<span class="udiff-line-modified-added">+         // satisfied.</span>
<span class="udiff-line-modified-added">+         ASSERT(buffer[(*length) - 1] != &#39;9&#39;);</span>
<span class="udiff-line-modified-added">+         buffer[(*length) - 1]++;</span>
<span class="udiff-line-modified-added">+       } else {</span>
<span class="udiff-line-modified-added">+         // Halfway case.</span>
<span class="udiff-line-modified-added">+         // TODO(floitsch): need a way to solve half-way cases.</span>
<span class="udiff-line-modified-added">+         //   For now let&#39;s round towards even (since this is what Gay seems to</span>
<span class="udiff-line-modified-added">+         //   do).</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+         if ((buffer[(*length) - 1] - &#39;0&#39;) % 2 == 0) {</span>
<span class="udiff-line-modified-added">+           // Round down =&gt; Do nothing.</span>
<span class="udiff-line-modified-added">+         } else {</span>
<span class="udiff-line-modified-added">+           ASSERT(buffer[(*length) - 1] != &#39;9&#39;);</span>
<span class="udiff-line-modified-added">+           buffer[(*length) - 1]++;</span>
          }
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       return;</span>
<span class="udiff-line-added">+     } else if (in_delta_room_minus) {</span>
<span class="udiff-line-added">+       // Round down (== do nothing).</span>
<span class="udiff-line-added">+       return;</span>
<span class="udiff-line-added">+     } else {  // in_delta_room_plus</span>
<span class="udiff-line-added">+       // Round up.</span>
<span class="udiff-line-added">+       // Note again that the last digit could not be &#39;9&#39; since this would have</span>
<span class="udiff-line-added">+       // stopped the loop earlier.</span>
<span class="udiff-line-added">+       // We still have an ASSERT here, in case the preconditions were not</span>
<span class="udiff-line-added">+       // satisfied.</span>
<span class="udiff-line-added">+       ASSERT(buffer[(*length) -1] != &#39;9&#39;);</span>
<span class="udiff-line-added">+       buffer[(*length) - 1]++;</span>
<span class="udiff-line-added">+       return;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
  }
<span class="udiff-line-modified-removed">-     </span>
<span class="udiff-line-modified-removed">-     </span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+ </span>
  // Let v = numerator / denominator &lt; 10.
  // Then we generate &#39;count&#39; digits of d = x.xxxxx... (without the decimal point)
  // from left to right. Once &#39;count&#39; digits have been produced we decide wether
  // to round up or down. Remainders of exactly .5 round upwards. Numbers such
  // as 9.999999 propagate a carry all the way, and change the
  // exponent (decimal_point), when rounding upwards.
  static void GenerateCountedDigits(int count, int* decimal_point,
<span class="udiff-line-modified-removed">-                                       Bignum* numerator, Bignum* denominator,</span>
<span class="udiff-line-modified-added">+                                   Bignum* numerator, Bignum* denominator,</span>
                                    BufferReference&lt;char&gt; buffer, int* length) {
<span class="udiff-line-modified-removed">-         ASSERT(count &gt;= 0);</span>
<span class="udiff-line-modified-removed">-         for (int i = 0; i &lt; count - 1; ++i) {</span>
<span class="udiff-line-modified-removed">-             uint16_t digit;</span>
<span class="udiff-line-modified-removed">-             digit = numerator-&gt;DivideModuloIntBignum(*denominator);</span>
<span class="udiff-line-modified-removed">-             ASSERT(digit &lt;= 9);  // digit is a uint16_t and therefore always positive.</span>
<span class="udiff-line-modified-removed">-             // digit = numerator / denominator (integer division).</span>
<span class="udiff-line-modified-removed">-             // numerator = numerator % denominator.</span>
<span class="udiff-line-modified-added">+   ASSERT(count &gt;= 0);</span>
<span class="udiff-line-modified-added">+   for (int i = 0; i &lt; count - 1; ++i) {</span>
<span class="udiff-line-modified-added">+     uint16_t digit;</span>
<span class="udiff-line-modified-added">+     digit = numerator-&gt;DivideModuloIntBignum(*denominator);</span>
<span class="udiff-line-modified-added">+     ASSERT(digit &lt;= 9);  // digit is a uint16_t and therefore always positive.</span>
<span class="udiff-line-modified-added">+     // digit = numerator / denominator (integer division).</span>
<span class="udiff-line-modified-added">+     // numerator = numerator % denominator.</span>
      buffer[i] = static_cast&lt;char&gt;(digit + &#39;0&#39;);
<span class="udiff-line-modified-removed">-             // Prepare for next iteration.</span>
<span class="udiff-line-modified-removed">-             numerator-&gt;Times10();</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-removed">-         // Generate the last digit.</span>
<span class="udiff-line-modified-removed">-         uint16_t digit;</span>
<span class="udiff-line-modified-removed">-         digit = numerator-&gt;DivideModuloIntBignum(*denominator);</span>
<span class="udiff-line-modified-removed">-         if (Bignum::PlusCompare(*numerator, *numerator, *denominator) &gt;= 0) {</span>
<span class="udiff-line-modified-removed">-             digit++;</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-added">+     // Prepare for next iteration.</span>
<span class="udiff-line-modified-added">+     numerator-&gt;Times10();</span>
<span class="udiff-line-modified-added">+   }</span>
<span class="udiff-line-modified-added">+   // Generate the last digit.</span>
<span class="udiff-line-modified-added">+   uint16_t digit;</span>
<span class="udiff-line-modified-added">+   digit = numerator-&gt;DivideModuloIntBignum(*denominator);</span>
<span class="udiff-line-modified-added">+   if (Bignum::PlusCompare(*numerator, *numerator, *denominator) &gt;= 0) {</span>
<span class="udiff-line-modified-added">+     digit++;</span>
<span class="udiff-line-modified-added">+   }</span>
    ASSERT(digit &lt;= 10);
    buffer[count - 1] = static_cast&lt;char&gt;(digit + &#39;0&#39;);
<span class="udiff-line-modified-removed">-         // Correct bad digits (in case we had a sequence of &#39;9&#39;s). Propagate the</span>
<span class="udiff-line-modified-removed">-         // carry until we hat a non-&#39;9&#39; or til we reach the first digit.</span>
<span class="udiff-line-modified-removed">-         for (int i = count - 1; i &gt; 0; --i) {</span>
<span class="udiff-line-modified-removed">-             if (buffer[i] != &#39;0&#39; + 10) break;</span>
<span class="udiff-line-modified-removed">-             buffer[i] = &#39;0&#39;;</span>
<span class="udiff-line-modified-removed">-             buffer[i - 1]++;</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-removed">-         if (buffer[0] == &#39;0&#39; + 10) {</span>
<span class="udiff-line-modified-removed">-             // Propagate a carry past the top place.</span>
<span class="udiff-line-modified-removed">-             buffer[0] = &#39;1&#39;;</span>
<span class="udiff-line-modified-removed">-             (*decimal_point)++;</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-removed">-         *length = count;</span>
<span class="udiff-line-modified-added">+   // Correct bad digits (in case we had a sequence of &#39;9&#39;s). Propagate the</span>
<span class="udiff-line-modified-added">+   // carry until we hat a non-&#39;9&#39; or til we reach the first digit.</span>
<span class="udiff-line-modified-added">+   for (int i = count - 1; i &gt; 0; --i) {</span>
<span class="udiff-line-modified-added">+     if (buffer[i] != &#39;0&#39; + 10) break;</span>
<span class="udiff-line-modified-added">+     buffer[i] = &#39;0&#39;;</span>
<span class="udiff-line-modified-added">+     buffer[i - 1]++;</span>
<span class="udiff-line-modified-added">+   }</span>
<span class="udiff-line-modified-added">+   if (buffer[0] == &#39;0&#39; + 10) {</span>
<span class="udiff-line-modified-added">+     // Propagate a carry past the top place.</span>
<span class="udiff-line-modified-added">+     buffer[0] = &#39;1&#39;;</span>
<span class="udiff-line-modified-added">+     (*decimal_point)++;</span>
<span class="udiff-line-modified-added">+   }</span>
<span class="udiff-line-modified-added">+   *length = count;</span>
  }
<span class="udiff-line-modified-removed">-     </span>
<span class="udiff-line-modified-removed">-     </span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+ </span>
  // Generates &#39;requested_digits&#39; after the decimal point. It might omit
  // trailing &#39;0&#39;s. If the input number is too small then no digits at all are
  // generated (ex.: 2 fixed digits for 0.00001).
  //
  // Input verifies:  1 &lt;= (numerator + delta) / denominator &lt; 10.
  static void BignumToFixed(int requested_digits, int* decimal_point,
<span class="udiff-line-modified-removed">-                               Bignum* numerator, Bignum* denominator,</span>
<span class="udiff-line-modified-removed">-                               BufferReference&lt;char&gt;(buffer), int* length) {</span>
<span class="udiff-line-modified-removed">-         // Note that we have to look at more than just the requested_digits, since</span>
<span class="udiff-line-modified-removed">-         // a number could be rounded up. Example: v=0.5 with requested_digits=0.</span>
<span class="udiff-line-modified-removed">-         // Even though the power of v equals 0 we can&#39;t just stop here.</span>
<span class="udiff-line-modified-removed">-         if (-(*decimal_point) &gt; requested_digits) {</span>
<span class="udiff-line-modified-removed">-             // The number is definitively too small.</span>
<span class="udiff-line-modified-removed">-             // Ex: 0.001 with requested_digits == 1.</span>
<span class="udiff-line-modified-removed">-             // Set decimal-point to -requested_digits. This is what Gay does.</span>
<span class="udiff-line-modified-removed">-             // Note that it should not have any effect anyways since the string is</span>
<span class="udiff-line-modified-removed">-             // empty.</span>
<span class="udiff-line-modified-removed">-             *decimal_point = -requested_digits;</span>
<span class="udiff-line-modified-removed">-             *length = 0;</span>
<span class="udiff-line-modified-removed">-             return;</span>
<span class="udiff-line-modified-removed">-         } else if (-(*decimal_point) == requested_digits) {</span>
<span class="udiff-line-modified-removed">-             // We only need to verify if the number rounds down or up.</span>
<span class="udiff-line-modified-removed">-             // Ex: 0.04 and 0.06 with requested_digits == 1.</span>
<span class="udiff-line-modified-removed">-             ASSERT(*decimal_point == -requested_digits);</span>
<span class="udiff-line-modified-removed">-             // Initially the fraction lies in range (1, 10]. Multiply the denominator</span>
<span class="udiff-line-modified-removed">-             // by 10 so that we can compare more easily.</span>
<span class="udiff-line-modified-removed">-             denominator-&gt;Times10();</span>
<span class="udiff-line-modified-removed">-             if (Bignum::PlusCompare(*numerator, *numerator, *denominator) &gt;= 0) {</span>
<span class="udiff-line-modified-removed">-                 // If the fraction is &gt;= 0.5 then we have to include the rounded</span>
<span class="udiff-line-modified-removed">-                 // digit.</span>
<span class="udiff-line-modified-removed">-                 buffer[0] = &#39;1&#39;;</span>
<span class="udiff-line-modified-removed">-                 *length = 1;</span>
<span class="udiff-line-modified-removed">-                 (*decimal_point)++;</span>
<span class="udiff-line-modified-removed">-             } else {</span>
<span class="udiff-line-modified-removed">-                 // Note that we caught most of similar cases earlier.</span>
<span class="udiff-line-modified-removed">-                 *length = 0;</span>
<span class="udiff-line-modified-removed">-             }</span>
<span class="udiff-line-modified-removed">-             return;</span>
<span class="udiff-line-modified-removed">-         } else {</span>
<span class="udiff-line-modified-removed">-             // The requested digits correspond to the digits after the point.</span>
<span class="udiff-line-modified-removed">-             // The variable &#39;needed_digits&#39; includes the digits before the point.</span>
<span class="udiff-line-modified-removed">-             int needed_digits = (*decimal_point) + requested_digits;</span>
<span class="udiff-line-modified-removed">-             GenerateCountedDigits(needed_digits, decimal_point,</span>
<span class="udiff-line-modified-removed">-                                   numerator, denominator,</span>
<span class="udiff-line-modified-removed">-                                   buffer, length);</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-added">+                           Bignum* numerator, Bignum* denominator,</span>
<span class="udiff-line-modified-added">+                           BufferReference&lt;char&gt;(buffer), int* length) {</span>
<span class="udiff-line-modified-added">+   // Note that we have to look at more than just the requested_digits, since</span>
<span class="udiff-line-modified-added">+   // a number could be rounded up. Example: v=0.5 with requested_digits=0.</span>
<span class="udiff-line-modified-added">+   // Even though the power of v equals 0 we can&#39;t just stop here.</span>
<span class="udiff-line-modified-added">+   if (-(*decimal_point) &gt; requested_digits) {</span>
<span class="udiff-line-modified-added">+     // The number is definitively too small.</span>
<span class="udiff-line-modified-added">+     // Ex: 0.001 with requested_digits == 1.</span>
<span class="udiff-line-modified-added">+     // Set decimal-point to -requested_digits. This is what Gay does.</span>
<span class="udiff-line-modified-added">+     // Note that it should not have any effect anyways since the string is</span>
<span class="udiff-line-modified-added">+     // empty.</span>
<span class="udiff-line-modified-added">+     *decimal_point = -requested_digits;</span>
<span class="udiff-line-modified-added">+     *length = 0;</span>
<span class="udiff-line-modified-added">+     return;</span>
<span class="udiff-line-modified-added">+   } else if (-(*decimal_point) == requested_digits) {</span>
<span class="udiff-line-modified-added">+     // We only need to verify if the number rounds down or up.</span>
<span class="udiff-line-modified-added">+     // Ex: 0.04 and 0.06 with requested_digits == 1.</span>
<span class="udiff-line-modified-added">+     ASSERT(*decimal_point == -requested_digits);</span>
<span class="udiff-line-modified-added">+     // Initially the fraction lies in range (1, 10]. Multiply the denominator</span>
<span class="udiff-line-modified-added">+     // by 10 so that we can compare more easily.</span>
<span class="udiff-line-modified-added">+     denominator-&gt;Times10();</span>
<span class="udiff-line-modified-added">+     if (Bignum::PlusCompare(*numerator, *numerator, *denominator) &gt;= 0) {</span>
<span class="udiff-line-modified-added">+       // If the fraction is &gt;= 0.5 then we have to include the rounded</span>
<span class="udiff-line-modified-added">+       // digit.</span>
<span class="udiff-line-modified-added">+       buffer[0] = &#39;1&#39;;</span>
<span class="udiff-line-modified-added">+       *length = 1;</span>
<span class="udiff-line-modified-added">+       (*decimal_point)++;</span>
<span class="udiff-line-modified-added">+     } else {</span>
<span class="udiff-line-modified-added">+       // Note that we caught most of similar cases earlier.</span>
<span class="udiff-line-modified-added">+       *length = 0;</span>
<span class="udiff-line-modified-added">+     }</span>
<span class="udiff-line-modified-added">+     return;</span>
<span class="udiff-line-modified-added">+   } else {</span>
<span class="udiff-line-modified-added">+     // The requested digits correspond to the digits after the point.</span>
<span class="udiff-line-modified-added">+     // The variable &#39;needed_digits&#39; includes the digits before the point.</span>
<span class="udiff-line-modified-added">+     int needed_digits = (*decimal_point) + requested_digits;</span>
<span class="udiff-line-modified-added">+     GenerateCountedDigits(needed_digits, decimal_point,</span>
<span class="udiff-line-modified-added">+                           numerator, denominator,</span>
<span class="udiff-line-modified-added">+                           buffer, length);</span>
<span class="udiff-line-modified-added">+   }</span>
  }
<span class="udiff-line-modified-removed">-     </span>
<span class="udiff-line-modified-removed">-     </span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+ </span>
  // Returns an estimation of k such that 10^(k-1) &lt;= v &lt; 10^k where
  // v = f * 2^exponent and 2^52 &lt;= f &lt; 2^53.
  // v is hence a normalized double with the given exponent. The output is an
  // approximation for the exponent of the decimal approimation .digits * 10^k.
  //
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -384,154 +384,154 @@</span>
  //  EstimatePower(0)   =&gt; 16
  //  EstimatePower(-52) =&gt; 0
  //
  // Note: e &gt;= 0 =&gt; EstimatedPower(e) &gt; 0. No similar claim can be made for e&lt;0.
  static int EstimatePower(int exponent) {
<span class="udiff-line-modified-removed">-         // This function estimates log10 of v where v = f*2^e (with e == exponent).</span>
<span class="udiff-line-modified-removed">-         // Note that 10^floor(log10(v)) &lt;= v, but v &lt;= 10^ceil(log10(v)).</span>
<span class="udiff-line-modified-removed">-         // Note that f is bounded by its container size. Let p = 53 (the double&#39;s</span>
<span class="udiff-line-modified-removed">-         // significand size). Then 2^(p-1) &lt;= f &lt; 2^p.</span>
<span class="udiff-line-modified-removed">-         //</span>
<span class="udiff-line-modified-removed">-         // Given that log10(v) == log2(v)/log2(10) and e+(len(f)-1) is quite close</span>
<span class="udiff-line-modified-removed">-         // to log2(v) the function is simplified to (e+(len(f)-1)/log2(10)).</span>
<span class="udiff-line-modified-removed">-         // The computed number undershoots by less than 0.631 (when we compute log3</span>
<span class="udiff-line-modified-removed">-         // and not log10).</span>
<span class="udiff-line-modified-removed">-         //</span>
<span class="udiff-line-modified-removed">-         // Optimization: since we only need an approximated result this computation</span>
<span class="udiff-line-modified-removed">-         // can be performed on 64 bit integers. On x86/x64 architecture the speedup is</span>
<span class="udiff-line-modified-removed">-         // not really measurable, though.</span>
<span class="udiff-line-modified-removed">-         //</span>
<span class="udiff-line-modified-removed">-         // Since we want to avoid overshooting we decrement by 1e10 so that</span>
<span class="udiff-line-modified-removed">-         // floating-point imprecisions don&#39;t affect us.</span>
<span class="udiff-line-modified-removed">-         //</span>
<span class="udiff-line-modified-removed">-         // Explanation for v&#39;s boundary m+: the computation takes advantage of</span>
<span class="udiff-line-modified-removed">-         // the fact that 2^(p-1) &lt;= f &lt; 2^p. Boundaries still satisfy this requirement</span>
<span class="udiff-line-modified-removed">-         // (even for denormals where the delta can be much more important).</span>
<span class="udiff-line-modified-removed">-         </span>
<span class="udiff-line-modified-removed">-         const double k1Log10 = 0.30102999566398114;  // 1/lg(10)</span>
<span class="udiff-line-modified-removed">-         </span>
<span class="udiff-line-modified-removed">-         // For doubles len(f) == 53 (don&#39;t forget the hidden bit).</span>
<span class="udiff-line-modified-added">+   // This function estimates log10 of v where v = f*2^e (with e == exponent).</span>
<span class="udiff-line-modified-added">+   // Note that 10^floor(log10(v)) &lt;= v, but v &lt;= 10^ceil(log10(v)).</span>
<span class="udiff-line-modified-added">+   // Note that f is bounded by its container size. Let p = 53 (the double&#39;s</span>
<span class="udiff-line-modified-added">+   // significand size). Then 2^(p-1) &lt;= f &lt; 2^p.</span>
<span class="udiff-line-modified-added">+   //</span>
<span class="udiff-line-modified-added">+   // Given that log10(v) == log2(v)/log2(10) and e+(len(f)-1) is quite close</span>
<span class="udiff-line-modified-added">+   // to log2(v) the function is simplified to (e+(len(f)-1)/log2(10)).</span>
<span class="udiff-line-modified-added">+   // The computed number undershoots by less than 0.631 (when we compute log3</span>
<span class="udiff-line-modified-added">+   // and not log10).</span>
<span class="udiff-line-modified-added">+   //</span>
<span class="udiff-line-modified-added">+   // Optimization: since we only need an approximated result this computation</span>
<span class="udiff-line-modified-added">+   // can be performed on 64 bit integers. On x86/x64 architecture the speedup is</span>
<span class="udiff-line-modified-added">+   // not really measurable, though.</span>
<span class="udiff-line-modified-added">+   //</span>
<span class="udiff-line-modified-added">+   // Since we want to avoid overshooting we decrement by 1e10 so that</span>
<span class="udiff-line-modified-added">+   // floating-point imprecisions don&#39;t affect us.</span>
<span class="udiff-line-modified-added">+   //</span>
<span class="udiff-line-modified-added">+   // Explanation for v&#39;s boundary m+: the computation takes advantage of</span>
<span class="udiff-line-modified-added">+   // the fact that 2^(p-1) &lt;= f &lt; 2^p. Boundaries still satisfy this requirement</span>
<span class="udiff-line-modified-added">+   // (even for denormals where the delta can be much more important).</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   const double k1Log10 = 0.30102999566398114;  // 1/lg(10)</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   // For doubles len(f) == 53 (don&#39;t forget the hidden bit).</span>
    const int kSignificandSize = Double::kSignificandSize;
<span class="udiff-line-modified-removed">-         double estimate = ceil((exponent + kSignificandSize - 1) * k1Log10 - 1e-10);</span>
<span class="udiff-line-modified-removed">-         return static_cast&lt;int&gt;(estimate);</span>
<span class="udiff-line-modified-added">+   double estimate = ceil((exponent + kSignificandSize - 1) * k1Log10 - 1e-10);</span>
<span class="udiff-line-modified-added">+   return static_cast&lt;int&gt;(estimate);</span>
  }
<span class="udiff-line-modified-removed">-     </span>
<span class="udiff-line-modified-removed">-     </span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+ </span>
  // See comments for InitialScaledStartValues.
  static void InitialScaledStartValuesPositiveExponent(
      uint64_t significand, int exponent,
      int estimated_power, bool need_boundary_deltas,
<span class="udiff-line-modified-removed">-                                                          Bignum* numerator, Bignum* denominator,</span>
<span class="udiff-line-modified-removed">-                                                          Bignum* delta_minus, Bignum* delta_plus) {</span>
<span class="udiff-line-modified-removed">-         // A positive exponent implies a positive power.</span>
<span class="udiff-line-modified-removed">-         ASSERT(estimated_power &gt;= 0);</span>
<span class="udiff-line-modified-removed">-         // Since the estimated_power is positive we simply multiply the denominator</span>
<span class="udiff-line-modified-removed">-         // by 10^estimated_power.</span>
<span class="udiff-line-modified-removed">-         </span>
<span class="udiff-line-modified-removed">-         // numerator = v.</span>
<span class="udiff-line-modified-added">+     Bignum* numerator, Bignum* denominator,</span>
<span class="udiff-line-modified-added">+     Bignum* delta_minus, Bignum* delta_plus) {</span>
<span class="udiff-line-modified-added">+   // A positive exponent implies a positive power.</span>
<span class="udiff-line-modified-added">+   ASSERT(estimated_power &gt;= 0);</span>
<span class="udiff-line-modified-added">+   // Since the estimated_power is positive we simply multiply the denominator</span>
<span class="udiff-line-modified-added">+   // by 10^estimated_power.</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   // numerator = v.</span>
    numerator-&gt;AssignUInt64(significand);
    numerator-&gt;ShiftLeft(exponent);
<span class="udiff-line-modified-removed">-         // denominator = 10^estimated_power.</span>
<span class="udiff-line-modified-removed">-         denominator-&gt;AssignPowerUInt16(10, estimated_power);</span>
<span class="udiff-line-modified-removed">-         </span>
<span class="udiff-line-modified-removed">-         if (need_boundary_deltas) {</span>
<span class="udiff-line-modified-removed">-             // Introduce a common denominator so that the deltas to the boundaries are</span>
<span class="udiff-line-modified-removed">-             // integers.</span>
<span class="udiff-line-modified-removed">-             denominator-&gt;ShiftLeft(1);</span>
<span class="udiff-line-modified-removed">-             numerator-&gt;ShiftLeft(1);</span>
<span class="udiff-line-modified-removed">-             // Let v = f * 2^e, then m+ - v = 1/2 * 2^e; With the common</span>
<span class="udiff-line-modified-removed">-             // denominator (of 2) delta_plus equals 2^e.</span>
<span class="udiff-line-modified-removed">-             delta_plus-&gt;AssignUInt16(1);</span>
<span class="udiff-line-modified-added">+   // denominator = 10^estimated_power.</span>
<span class="udiff-line-modified-added">+   denominator-&gt;AssignPowerUInt16(10, estimated_power);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   if (need_boundary_deltas) {</span>
<span class="udiff-line-modified-added">+     // Introduce a common denominator so that the deltas to the boundaries are</span>
<span class="udiff-line-modified-added">+     // integers.</span>
<span class="udiff-line-modified-added">+     denominator-&gt;ShiftLeft(1);</span>
<span class="udiff-line-modified-added">+     numerator-&gt;ShiftLeft(1);</span>
<span class="udiff-line-modified-added">+     // Let v = f * 2^e, then m+ - v = 1/2 * 2^e; With the common</span>
<span class="udiff-line-modified-added">+     // denominator (of 2) delta_plus equals 2^e.</span>
<span class="udiff-line-modified-added">+     delta_plus-&gt;AssignUInt16(1);</span>
      delta_plus-&gt;ShiftLeft(exponent);
      // Same for delta_minus. The adjustments if f == 2^p-1 are done later.
<span class="udiff-line-modified-removed">-             delta_minus-&gt;AssignUInt16(1);</span>
<span class="udiff-line-modified-added">+     delta_minus-&gt;AssignUInt16(1);</span>
      delta_minus-&gt;ShiftLeft(exponent);
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+   }</span>
  }
<span class="udiff-line-modified-removed">-     </span>
<span class="udiff-line-modified-removed">-     </span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+ </span>
  // See comments for InitialScaledStartValues
  static void InitialScaledStartValuesNegativeExponentPositivePower(
      uint64_t significand, int exponent,
      int estimated_power, bool need_boundary_deltas,
<span class="udiff-line-modified-removed">-                                                                       Bignum* numerator, Bignum* denominator,</span>
<span class="udiff-line-modified-removed">-                                                                       Bignum* delta_minus, Bignum* delta_plus) {</span>
<span class="udiff-line-modified-removed">-         // v = f * 2^e with e &lt; 0, and with estimated_power &gt;= 0.</span>
<span class="udiff-line-modified-removed">-         // This means that e is close to 0 (have a look at how estimated_power is</span>
<span class="udiff-line-modified-removed">-         // computed).</span>
<span class="udiff-line-modified-removed">-         </span>
<span class="udiff-line-modified-removed">-         // numerator = significand</span>
<span class="udiff-line-modified-removed">-         //  since v = significand * 2^exponent this is equivalent to</span>
<span class="udiff-line-modified-removed">-         //  numerator = v * / 2^-exponent</span>
<span class="udiff-line-modified-removed">-         numerator-&gt;AssignUInt64(significand);</span>
<span class="udiff-line-modified-removed">-         // denominator = 10^estimated_power * 2^-exponent (with exponent &lt; 0)</span>
<span class="udiff-line-modified-removed">-         denominator-&gt;AssignPowerUInt16(10, estimated_power);</span>
<span class="udiff-line-modified-removed">-         denominator-&gt;ShiftLeft(-exponent);</span>
<span class="udiff-line-modified-removed">-         </span>
<span class="udiff-line-modified-removed">-         if (need_boundary_deltas) {</span>
<span class="udiff-line-modified-removed">-             // Introduce a common denominator so that the deltas to the boundaries are</span>
<span class="udiff-line-modified-removed">-             // integers.</span>
<span class="udiff-line-modified-removed">-             denominator-&gt;ShiftLeft(1);</span>
<span class="udiff-line-modified-removed">-             numerator-&gt;ShiftLeft(1);</span>
<span class="udiff-line-modified-removed">-             // Let v = f * 2^e, then m+ - v = 1/2 * 2^e; With the common</span>
<span class="udiff-line-modified-removed">-             // denominator (of 2) delta_plus equals 2^e.</span>
<span class="udiff-line-modified-removed">-             // Given that the denominator already includes v&#39;s exponent the distance</span>
<span class="udiff-line-modified-removed">-             // to the boundaries is simply 1.</span>
<span class="udiff-line-modified-removed">-             delta_plus-&gt;AssignUInt16(1);</span>
<span class="udiff-line-modified-added">+     Bignum* numerator, Bignum* denominator,</span>
<span class="udiff-line-modified-added">+     Bignum* delta_minus, Bignum* delta_plus) {</span>
<span class="udiff-line-modified-added">+   // v = f * 2^e with e &lt; 0, and with estimated_power &gt;= 0.</span>
<span class="udiff-line-modified-added">+   // This means that e is close to 0 (have a look at how estimated_power is</span>
<span class="udiff-line-modified-added">+   // computed).</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   // numerator = significand</span>
<span class="udiff-line-modified-added">+   //  since v = significand * 2^exponent this is equivalent to</span>
<span class="udiff-line-modified-added">+   //  numerator = v * / 2^-exponent</span>
<span class="udiff-line-modified-added">+   numerator-&gt;AssignUInt64(significand);</span>
<span class="udiff-line-modified-added">+   // denominator = 10^estimated_power * 2^-exponent (with exponent &lt; 0)</span>
<span class="udiff-line-modified-added">+   denominator-&gt;AssignPowerUInt16(10, estimated_power);</span>
<span class="udiff-line-modified-added">+   denominator-&gt;ShiftLeft(-exponent);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   if (need_boundary_deltas) {</span>
<span class="udiff-line-modified-added">+     // Introduce a common denominator so that the deltas to the boundaries are</span>
<span class="udiff-line-modified-added">+     // integers.</span>
<span class="udiff-line-modified-added">+     denominator-&gt;ShiftLeft(1);</span>
<span class="udiff-line-modified-added">+     numerator-&gt;ShiftLeft(1);</span>
<span class="udiff-line-modified-added">+     // Let v = f * 2^e, then m+ - v = 1/2 * 2^e; With the common</span>
<span class="udiff-line-modified-added">+     // denominator (of 2) delta_plus equals 2^e.</span>
<span class="udiff-line-modified-added">+     // Given that the denominator already includes v&#39;s exponent the distance</span>
<span class="udiff-line-modified-added">+     // to the boundaries is simply 1.</span>
<span class="udiff-line-modified-added">+     delta_plus-&gt;AssignUInt16(1);</span>
      // Same for delta_minus. The adjustments if f == 2^p-1 are done later.
<span class="udiff-line-modified-removed">-             delta_minus-&gt;AssignUInt16(1);</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+     delta_minus-&gt;AssignUInt16(1);</span>
<span class="udiff-line-modified-added">+   }</span>
  }
<span class="udiff-line-modified-removed">-     </span>
<span class="udiff-line-modified-removed">-     </span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+ </span>
  // See comments for InitialScaledStartValues
  static void InitialScaledStartValuesNegativeExponentNegativePower(
      uint64_t significand, int exponent,
      int estimated_power, bool need_boundary_deltas,
<span class="udiff-line-modified-removed">-                                                                       Bignum* numerator, Bignum* denominator,</span>
<span class="udiff-line-modified-removed">-                                                                       Bignum* delta_minus, Bignum* delta_plus) {</span>
<span class="udiff-line-modified-removed">-         // Instead of multiplying the denominator with 10^estimated_power we</span>
<span class="udiff-line-modified-removed">-         // multiply all values (numerator and deltas) by 10^-estimated_power.</span>
<span class="udiff-line-modified-removed">-         </span>
<span class="udiff-line-modified-removed">-         // Use numerator as temporary container for power_ten.</span>
<span class="udiff-line-modified-removed">-         Bignum* power_ten = numerator;</span>
<span class="udiff-line-modified-removed">-         power_ten-&gt;AssignPowerUInt16(10, -estimated_power);</span>
<span class="udiff-line-modified-removed">-         </span>
<span class="udiff-line-modified-removed">-         if (need_boundary_deltas) {</span>
<span class="udiff-line-modified-removed">-             // Since power_ten == numerator we must make a copy of 10^estimated_power</span>
<span class="udiff-line-modified-removed">-             // before we complete the computation of the numerator.</span>
<span class="udiff-line-modified-removed">-             // delta_plus = delta_minus = 10^estimated_power</span>
<span class="udiff-line-modified-removed">-             delta_plus-&gt;AssignBignum(*power_ten);</span>
<span class="udiff-line-modified-removed">-             delta_minus-&gt;AssignBignum(*power_ten);</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-removed">-         </span>
<span class="udiff-line-modified-removed">-         // numerator = significand * 2 * 10^-estimated_power</span>
<span class="udiff-line-modified-removed">-         //  since v = significand * 2^exponent this is equivalent to</span>
<span class="udiff-line-modified-removed">-         // numerator = v * 10^-estimated_power * 2 * 2^-exponent.</span>
<span class="udiff-line-modified-removed">-         // Remember: numerator has been abused as power_ten. So no need to assign it</span>
<span class="udiff-line-modified-removed">-         //  to itself.</span>
<span class="udiff-line-modified-removed">-         ASSERT(numerator == power_ten);</span>
<span class="udiff-line-modified-removed">-         numerator-&gt;MultiplyByUInt64(significand);</span>
<span class="udiff-line-modified-removed">-         </span>
<span class="udiff-line-modified-removed">-         // denominator = 2 * 2^-exponent with exponent &lt; 0.</span>
<span class="udiff-line-modified-removed">-         denominator-&gt;AssignUInt16(1);</span>
<span class="udiff-line-modified-removed">-         denominator-&gt;ShiftLeft(-exponent);</span>
<span class="udiff-line-modified-removed">-         </span>
<span class="udiff-line-modified-removed">-         if (need_boundary_deltas) {</span>
<span class="udiff-line-modified-removed">-             // Introduce a common denominator so that the deltas to the boundaries are</span>
<span class="udiff-line-modified-removed">-             // integers.</span>
<span class="udiff-line-modified-removed">-             numerator-&gt;ShiftLeft(1);</span>
<span class="udiff-line-modified-removed">-             denominator-&gt;ShiftLeft(1);</span>
<span class="udiff-line-modified-removed">-             // With this shift the boundaries have their correct value, since</span>
<span class="udiff-line-modified-removed">-             // delta_plus = 10^-estimated_power, and</span>
<span class="udiff-line-modified-removed">-             // delta_minus = 10^-estimated_power.</span>
<span class="udiff-line-modified-removed">-             // These assignments have been done earlier.</span>
<span class="udiff-line-modified-added">+     Bignum* numerator, Bignum* denominator,</span>
<span class="udiff-line-modified-added">+     Bignum* delta_minus, Bignum* delta_plus) {</span>
<span class="udiff-line-modified-added">+   // Instead of multiplying the denominator with 10^estimated_power we</span>
<span class="udiff-line-modified-added">+   // multiply all values (numerator and deltas) by 10^-estimated_power.</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   // Use numerator as temporary container for power_ten.</span>
<span class="udiff-line-modified-added">+   Bignum* power_ten = numerator;</span>
<span class="udiff-line-modified-added">+   power_ten-&gt;AssignPowerUInt16(10, -estimated_power);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   if (need_boundary_deltas) {</span>
<span class="udiff-line-modified-added">+     // Since power_ten == numerator we must make a copy of 10^estimated_power</span>
<span class="udiff-line-modified-added">+     // before we complete the computation of the numerator.</span>
<span class="udiff-line-modified-added">+     // delta_plus = delta_minus = 10^estimated_power</span>
<span class="udiff-line-modified-added">+     delta_plus-&gt;AssignBignum(*power_ten);</span>
<span class="udiff-line-modified-added">+     delta_minus-&gt;AssignBignum(*power_ten);</span>
<span class="udiff-line-modified-added">+   }</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   // numerator = significand * 2 * 10^-estimated_power</span>
<span class="udiff-line-modified-added">+   //  since v = significand * 2^exponent this is equivalent to</span>
<span class="udiff-line-modified-added">+   // numerator = v * 10^-estimated_power * 2 * 2^-exponent.</span>
<span class="udiff-line-modified-added">+   // Remember: numerator has been abused as power_ten. So no need to assign it</span>
<span class="udiff-line-modified-added">+   //  to itself.</span>
<span class="udiff-line-modified-added">+   ASSERT(numerator == power_ten);</span>
<span class="udiff-line-modified-added">+   numerator-&gt;MultiplyByUInt64(significand);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   // denominator = 2 * 2^-exponent with exponent &lt; 0.</span>
<span class="udiff-line-modified-added">+   denominator-&gt;AssignUInt16(1);</span>
<span class="udiff-line-modified-added">+   denominator-&gt;ShiftLeft(-exponent);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   if (need_boundary_deltas) {</span>
<span class="udiff-line-modified-added">+     // Introduce a common denominator so that the deltas to the boundaries are</span>
<span class="udiff-line-modified-added">+     // integers.</span>
<span class="udiff-line-modified-added">+     numerator-&gt;ShiftLeft(1);</span>
<span class="udiff-line-modified-added">+     denominator-&gt;ShiftLeft(1);</span>
<span class="udiff-line-modified-added">+     // With this shift the boundaries have their correct value, since</span>
<span class="udiff-line-modified-added">+     // delta_plus = 10^-estimated_power, and</span>
<span class="udiff-line-modified-added">+     // delta_minus = 10^-estimated_power.</span>
<span class="udiff-line-modified-added">+     // These assignments have been done earlier.</span>
      // The adjustments if f == 2^p-1 (lower boundary is closer) are done later.
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+   }</span>
  }
<span class="udiff-line-modified-removed">-     </span>
<span class="udiff-line-modified-removed">-     </span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+ </span>
  // Let v = significand * 2^exponent.
  // Computes v / 10^estimated_power exactly, as a ratio of two bignums, numerator
  // and denominator. The functions GenerateShortestDigits and
  // GenerateCountedDigits will then convert this ratio to its decimal
  // representation d, with the required accuracy.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -569,40 +569,40 @@</span>
  // or BIGNUM_DTOA_SHORTEST_SINGLE.
  
  static void InitialScaledStartValues(uint64_t significand,
                                       int exponent,
                                       bool lower_boundary_is_closer,
<span class="udiff-line-modified-removed">-                                          int estimated_power,</span>
<span class="udiff-line-modified-removed">-                                          bool need_boundary_deltas,</span>
<span class="udiff-line-modified-removed">-                                          Bignum* numerator,</span>
<span class="udiff-line-modified-removed">-                                          Bignum* denominator,</span>
<span class="udiff-line-modified-removed">-                                          Bignum* delta_minus,</span>
<span class="udiff-line-modified-removed">-                                          Bignum* delta_plus) {</span>
<span class="udiff-line-modified-added">+                                      int estimated_power,</span>
<span class="udiff-line-modified-added">+                                      bool need_boundary_deltas,</span>
<span class="udiff-line-modified-added">+                                      Bignum* numerator,</span>
<span class="udiff-line-modified-added">+                                      Bignum* denominator,</span>
<span class="udiff-line-modified-added">+                                      Bignum* delta_minus,</span>
<span class="udiff-line-modified-added">+                                      Bignum* delta_plus) {</span>
    if (exponent &gt;= 0) {
<span class="udiff-line-modified-removed">-             InitialScaledStartValuesPositiveExponent(</span>
<span class="udiff-line-modified-added">+     InitialScaledStartValuesPositiveExponent(</span>
          significand, exponent, estimated_power, need_boundary_deltas,
<span class="udiff-line-modified-removed">-                                                      numerator, denominator, delta_minus, delta_plus);</span>
<span class="udiff-line-modified-removed">-         } else if (estimated_power &gt;= 0) {</span>
<span class="udiff-line-modified-removed">-             InitialScaledStartValuesNegativeExponentPositivePower(</span>
<span class="udiff-line-modified-added">+         numerator, denominator, delta_minus, delta_plus);</span>
<span class="udiff-line-modified-added">+   } else if (estimated_power &gt;= 0) {</span>
<span class="udiff-line-modified-added">+     InitialScaledStartValuesNegativeExponentPositivePower(</span>
          significand, exponent, estimated_power, need_boundary_deltas,
<span class="udiff-line-modified-removed">-                                                                   numerator, denominator, delta_minus, delta_plus);</span>
<span class="udiff-line-modified-removed">-         } else {</span>
<span class="udiff-line-modified-removed">-             InitialScaledStartValuesNegativeExponentNegativePower(</span>
<span class="udiff-line-modified-added">+         numerator, denominator, delta_minus, delta_plus);</span>
<span class="udiff-line-modified-added">+   } else {</span>
<span class="udiff-line-modified-added">+     InitialScaledStartValuesNegativeExponentNegativePower(</span>
          significand, exponent, estimated_power, need_boundary_deltas,
<span class="udiff-line-modified-removed">-                                                                   numerator, denominator, delta_minus, delta_plus);</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-added">+         numerator, denominator, delta_minus, delta_plus);</span>
<span class="udiff-line-modified-added">+   }</span>
  
    if (need_boundary_deltas &amp;&amp; lower_boundary_is_closer) {
      // The lower boundary is closer at half the distance of &quot;normal&quot; numbers.
      // Increase the common denominator and adapt all but the delta_minus.
      denominator-&gt;ShiftLeft(1);  // *2
      numerator-&gt;ShiftLeft(1);    // *2
      delta_plus-&gt;ShiftLeft(1);   // *2
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+   }</span>
  }
<span class="udiff-line-modified-removed">-     </span>
<span class="udiff-line-modified-removed">-     </span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+ </span>
  // This routine multiplies numerator/denominator so that its values lies in the
  // range 1-10. That is after a call to this function we have:
  //    1 &lt;= (numerator + delta_plus) /denominator &lt; 10.
  // Let numerator the input before modification and numerator&#39; the argument
  // after modification, then the output-parameter decimal_point is such that
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -611,35 +611,35 @@</span>
  // In some cases estimated_power was too low, and this is already the case. We
  // then simply adjust the power so that 10^(k-1) &lt;= v &lt; 10^k (with k ==
  // estimated_power) but do not touch the numerator or denominator.
  // Otherwise the routine multiplies the numerator and the deltas by 10.
  static void FixupMultiply10(int estimated_power, bool is_even,
<span class="udiff-line-modified-removed">-                                 int* decimal_point,</span>
<span class="udiff-line-modified-removed">-                                 Bignum* numerator, Bignum* denominator,</span>
<span class="udiff-line-modified-removed">-                                 Bignum* delta_minus, Bignum* delta_plus) {</span>
<span class="udiff-line-modified-removed">-         bool in_range;</span>
<span class="udiff-line-modified-removed">-         if (is_even) {</span>
<span class="udiff-line-modified-removed">-             // For IEEE doubles half-way cases (in decimal system numbers ending with 5)</span>
<span class="udiff-line-modified-removed">-             // are rounded to the closest floating-point number with even significand.</span>
<span class="udiff-line-modified-removed">-             in_range = Bignum::PlusCompare(*numerator, *delta_plus, *denominator) &gt;= 0;</span>
<span class="udiff-line-modified-removed">-         } else {</span>
<span class="udiff-line-modified-removed">-             in_range = Bignum::PlusCompare(*numerator, *delta_plus, *denominator) &gt; 0;</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-removed">-         if (in_range) {</span>
<span class="udiff-line-modified-removed">-             // Since numerator + delta_plus &gt;= denominator we already have</span>
<span class="udiff-line-modified-removed">-             // 1 &lt;= numerator/denominator &lt; 10. Simply update the estimated_power.</span>
<span class="udiff-line-modified-removed">-             *decimal_point = estimated_power + 1;</span>
<span class="udiff-line-modified-removed">-         } else {</span>
<span class="udiff-line-modified-removed">-             *decimal_point = estimated_power;</span>
<span class="udiff-line-modified-removed">-             numerator-&gt;Times10();</span>
<span class="udiff-line-modified-removed">-             if (Bignum::Equal(*delta_minus, *delta_plus)) {</span>
<span class="udiff-line-modified-removed">-                 delta_minus-&gt;Times10();</span>
<span class="udiff-line-modified-removed">-                 delta_plus-&gt;AssignBignum(*delta_minus);</span>
<span class="udiff-line-modified-removed">-             } else {</span>
<span class="udiff-line-modified-removed">-                 delta_minus-&gt;Times10();</span>
<span class="udiff-line-modified-removed">-                 delta_plus-&gt;Times10();</span>
<span class="udiff-line-modified-removed">-             }</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-added">+                             int* decimal_point,</span>
<span class="udiff-line-modified-added">+                             Bignum* numerator, Bignum* denominator,</span>
<span class="udiff-line-modified-added">+                             Bignum* delta_minus, Bignum* delta_plus) {</span>
<span class="udiff-line-modified-added">+   bool in_range;</span>
<span class="udiff-line-modified-added">+   if (is_even) {</span>
<span class="udiff-line-modified-added">+     // For IEEE doubles half-way cases (in decimal system numbers ending with 5)</span>
<span class="udiff-line-modified-added">+     // are rounded to the closest floating-point number with even significand.</span>
<span class="udiff-line-modified-added">+     in_range = Bignum::PlusCompare(*numerator, *delta_plus, *denominator) &gt;= 0;</span>
<span class="udiff-line-modified-added">+   } else {</span>
<span class="udiff-line-modified-added">+     in_range = Bignum::PlusCompare(*numerator, *delta_plus, *denominator) &gt; 0;</span>
<span class="udiff-line-modified-added">+   }</span>
<span class="udiff-line-modified-added">+   if (in_range) {</span>
<span class="udiff-line-modified-added">+     // Since numerator + delta_plus &gt;= denominator we already have</span>
<span class="udiff-line-modified-added">+     // 1 &lt;= numerator/denominator &lt; 10. Simply update the estimated_power.</span>
<span class="udiff-line-modified-added">+     *decimal_point = estimated_power + 1;</span>
<span class="udiff-line-modified-added">+   } else {</span>
<span class="udiff-line-modified-added">+     *decimal_point = estimated_power;</span>
<span class="udiff-line-modified-added">+     numerator-&gt;Times10();</span>
<span class="udiff-line-modified-added">+     if (Bignum::Equal(*delta_minus, *delta_plus)) {</span>
<span class="udiff-line-modified-added">+       delta_minus-&gt;Times10();</span>
<span class="udiff-line-modified-added">+       delta_plus-&gt;AssignBignum(*delta_minus);</span>
<span class="udiff-line-modified-added">+     } else {</span>
<span class="udiff-line-modified-added">+       delta_minus-&gt;Times10();</span>
<span class="udiff-line-modified-added">+       delta_plus-&gt;Times10();</span>
<span class="udiff-line-modified-added">+     }</span>
<span class="udiff-line-modified-added">+   }</span>
  }
<span class="udiff-line-modified-removed">-     </span>
<span class="udiff-line-modified-added">+ </span>
  }  // namespace double_conversion
<span class="udiff-line-modified-removed">- } // namespace WTF</span>
<span class="udiff-line-modified-added">+ }  // namespace WTF</span>
</pre>
<center><a href="../dtoa.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="bignum-dtoa.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>