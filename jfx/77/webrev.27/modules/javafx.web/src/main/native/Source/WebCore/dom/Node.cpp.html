<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/dom/Node.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
   3  *           (C) 1999 Antti Koivisto (koivisto@kde.org)
   4  *           (C) 2001 Dirk Mueller (mueller@kde.org)
   5  * Copyright (C) 2004-2017 Apple Inc. All rights reserved.
   6  * Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies)
   7  * Copyright (C) 2009 Torch Mobile Inc. All rights reserved. (http://www.torchmobile.com/)
   8  *
   9  * This library is free software; you can redistribute it and/or
  10  * modify it under the terms of the GNU Library General Public
  11  * License as published by the Free Software Foundation; either
  12  * version 2 of the License, or (at your option) any later version.
  13  *
  14  * This library is distributed in the hope that it will be useful,
  15  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  16  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  17  * Library General Public License for more details.
  18  *
  19  * You should have received a copy of the GNU Library General Public License
  20  * along with this library; see the file COPYING.LIB.  If not, write to
  21  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  22  * Boston, MA 02110-1301, USA.
  23  */
  24 
  25 #include &quot;config.h&quot;
  26 #include &quot;Node.h&quot;
  27 
  28 #include &quot;AXObjectCache.h&quot;
  29 #include &quot;Attr.h&quot;
  30 #include &quot;BeforeLoadEvent.h&quot;
  31 #include &quot;ChildListMutationScope.h&quot;
  32 #include &quot;CommonVM.h&quot;
  33 #include &quot;ComposedTreeAncestorIterator.h&quot;
  34 #include &quot;ContainerNodeAlgorithms.h&quot;
  35 #if PLATFORM(IOS_FAMILY)
  36 #include &quot;ContentChangeObserver.h&quot;
  37 #endif
  38 #include &quot;ContextMenuController.h&quot;
  39 #include &quot;DOMWindow.h&quot;
  40 #include &quot;DataTransfer.h&quot;
  41 #include &quot;DocumentType.h&quot;
  42 #include &quot;ElementIterator.h&quot;
  43 #include &quot;ElementRareData.h&quot;
  44 #include &quot;ElementTraversal.h&quot;
  45 #include &quot;EventDispatcher.h&quot;
  46 #include &quot;EventHandler.h&quot;
  47 #include &quot;FrameView.h&quot;
  48 #include &quot;HTMLAreaElement.h&quot;
  49 #include &quot;HTMLBodyElement.h&quot;
  50 #include &quot;HTMLCollection.h&quot;
  51 #include &quot;HTMLElement.h&quot;
  52 #include &quot;HTMLImageElement.h&quot;
  53 #include &quot;HTMLSlotElement.h&quot;
  54 #include &quot;HTMLStyleElement.h&quot;
  55 #include &quot;InputEvent.h&quot;
  56 #include &quot;InspectorController.h&quot;
  57 #include &quot;KeyboardEvent.h&quot;
  58 #include &quot;Logging.h&quot;
  59 #include &quot;MutationEvent.h&quot;
  60 #include &quot;NodeRenderStyle.h&quot;
  61 #include &quot;ProcessingInstruction.h&quot;
  62 #include &quot;ProgressEvent.h&quot;
  63 #include &quot;Range.h&quot;
  64 #include &quot;RenderBlock.h&quot;
  65 #include &quot;RenderBox.h&quot;
  66 #include &quot;RenderTextControl.h&quot;
  67 #include &quot;RenderView.h&quot;
  68 #include &quot;SVGElement.h&quot;
  69 #include &quot;ScopedEventQueue.h&quot;
  70 #include &quot;ScriptDisallowedScope.h&quot;
  71 #include &quot;StorageEvent.h&quot;
  72 #include &quot;StyleResolver.h&quot;
  73 #include &quot;StyleSheetContents.h&quot;
  74 #include &quot;TemplateContentDocumentFragment.h&quot;
  75 #include &quot;TextEvent.h&quot;
  76 #include &quot;TouchEvent.h&quot;
  77 #include &quot;WheelEvent.h&quot;
  78 #include &quot;XMLNSNames.h&quot;
  79 #include &quot;XMLNames.h&quot;
  80 #include &lt;wtf/IsoMallocInlines.h&gt;
  81 #include &lt;wtf/RefCountedLeakCounter.h&gt;
  82 #include &lt;wtf/SHA1.h&gt;
  83 #include &lt;wtf/Variant.h&gt;
  84 #include &lt;wtf/text/CString.h&gt;
  85 #include &lt;wtf/text/StringBuilder.h&gt;
  86 
  87 namespace WebCore {
  88 
  89 WTF_MAKE_ISO_ALLOCATED_IMPL(Node);
  90 
  91 using namespace HTMLNames;
  92 
  93 #if DUMP_NODE_STATISTICS
  94 static HashSet&lt;Node*&gt;&amp; liveNodeSet()
  95 {
  96     static NeverDestroyed&lt;HashSet&lt;Node*&gt;&gt; liveNodes;
  97     return liveNodes;
  98 }
  99 
 100 static const char* stringForRareDataUseType(NodeRareData::UseType useType)
 101 {
 102     switch (useType) {
 103     case NodeRareData::UseType::ConnectedFrameCount:
 104         return &quot;ConnectedFrameCount&quot;;
 105     case NodeRareData::UseType::NodeList:
 106         return &quot;NodeList&quot;;
 107     case NodeRareData::UseType::MutationObserver:
 108         return &quot;MutationObserver&quot;;
 109     case NodeRareData::UseType::TabIndex:
 110         return &quot;TabIndex&quot;;
 111     case NodeRareData::UseType::MinimumSize:
 112         return &quot;MinimumSize&quot;;
 113     case NodeRareData::UseType::ScrollingPosition:
 114         return &quot;ScrollingPosition&quot;;
 115     case NodeRareData::UseType::ComputedStyle:
 116         return &quot;ComputedStyle&quot;;
 117     case NodeRareData::UseType::Dataset:
 118         return &quot;Dataset&quot;;
 119     case NodeRareData::UseType::ClassList:
 120         return &quot;ClassList&quot;;
 121     case NodeRareData::UseType::ShadowRoot:
 122         return &quot;ShadowRoot&quot;;
 123     case NodeRareData::UseType::CustomElementQueue:
 124         return &quot;CustomElementQueue&quot;;
 125     case NodeRareData::UseType::AttributeMap:
 126         return &quot;AttributeMap&quot;;
 127     case NodeRareData::UseType::InteractionObserver:
 128         return &quot;InteractionObserver&quot;;
 129     case NodeRareData::UseType::PseudoElements:
 130         return &quot;PseudoElements&quot;;
 131     }
 132     return nullptr;
 133 }
 134 
 135 #endif
 136 
 137 void Node::dumpStatistics()
 138 {
 139 #if DUMP_NODE_STATISTICS
 140     size_t nodesWithRareData = 0;
 141 
 142     size_t elementNodes = 0;
 143     size_t attrNodes = 0;
 144     size_t textNodes = 0;
 145     size_t cdataNodes = 0;
 146     size_t commentNodes = 0;
 147     size_t piNodes = 0;
 148     size_t documentNodes = 0;
 149     size_t docTypeNodes = 0;
 150     size_t fragmentNodes = 0;
 151     size_t shadowRootNodes = 0;
 152 
 153     HashMap&lt;String, size_t&gt; perTagCount;
 154 
 155     size_t attributes = 0;
 156     size_t attributesWithAttr = 0;
 157     size_t elementsWithAttributeStorage = 0;
 158     size_t elementsWithRareData = 0;
 159     size_t elementsWithNamedNodeMap = 0;
 160 
 161     HashMap&lt;uint16_t, size_t&gt; rareDataSingleUseTypeCounts;
 162     size_t mixedRareDataUseCount = 0;
 163 
 164     for (auto* node : liveNodeSet()) {
 165         if (node-&gt;hasRareData()) {
 166             ++nodesWithRareData;
 167             if (is&lt;Element&gt;(*node)) {
 168                 ++elementsWithRareData;
 169                 if (downcast&lt;Element&gt;(*node).hasNamedNodeMap())
 170                     ++elementsWithNamedNodeMap;
 171             }
 172             auto* rareData = node-&gt;rareData();
 173             auto useTypes = is&lt;Element&gt;(node) ? static_cast&lt;ElementRareData*&gt;(rareData)-&gt;useTypes() : rareData-&gt;useTypes();
 174             unsigned useTypeCount = 0;
 175             for (auto type : useTypes) {
 176                 UNUSED_PARAM(type);
 177                 useTypeCount++;
 178             }
 179             if (useTypeCount == 1) {
 180                 auto result = rareDataSingleUseTypeCounts.add(static_cast&lt;uint16_t&gt;(*useTypes.begin()), 0);
 181                 result.iterator-&gt;value++;
 182             } else
 183                 mixedRareDataUseCount++;
 184         }
 185 
 186         switch (node-&gt;nodeType()) {
 187             case ELEMENT_NODE: {
 188                 ++elementNodes;
 189 
 190                 // Tag stats
 191                 Element&amp; element = downcast&lt;Element&gt;(*node);
 192                 HashMap&lt;String, size_t&gt;::AddResult result = perTagCount.add(element.tagName(), 1);
 193                 if (!result.isNewEntry)
 194                     result.iterator-&gt;value++;
 195 
 196                 if (const ElementData* elementData = element.elementData()) {
 197                     unsigned length = elementData-&gt;length();
 198                     attributes += length;
 199                     ++elementsWithAttributeStorage;
 200                     for (unsigned i = 0; i &lt; length; ++i) {
 201                         const Attribute&amp; attr = elementData-&gt;attributeAt(i);
 202                         if (element.attrIfExists(attr.name()))
 203                             ++attributesWithAttr;
 204                     }
 205                 }
 206                 break;
 207             }
 208             case ATTRIBUTE_NODE: {
 209                 ++attrNodes;
 210                 break;
 211             }
 212             case TEXT_NODE: {
 213                 ++textNodes;
 214                 break;
 215             }
 216             case CDATA_SECTION_NODE: {
 217                 ++cdataNodes;
 218                 break;
 219             }
 220             case PROCESSING_INSTRUCTION_NODE: {
 221                 ++piNodes;
 222                 break;
 223             }
 224             case COMMENT_NODE: {
 225                 ++commentNodes;
 226                 break;
 227             }
 228             case DOCUMENT_NODE: {
 229                 ++documentNodes;
 230                 break;
 231             }
 232             case DOCUMENT_TYPE_NODE: {
 233                 ++docTypeNodes;
 234                 break;
 235             }
 236             case DOCUMENT_FRAGMENT_NODE: {
 237                 if (node-&gt;isShadowRoot())
 238                     ++shadowRootNodes;
 239                 else
 240                     ++fragmentNodes;
 241                 break;
 242             }
 243         }
 244     }
 245 
 246     printf(&quot;Number of Nodes: %d\n\n&quot;, liveNodeSet().size());
 247     printf(&quot;Number of Nodes with RareData: %zu\n&quot;, nodesWithRareData);
 248     printf(&quot;  Mixed use: %zu\n&quot;, mixedRareDataUseCount);
 249     for (auto it : rareDataSingleUseTypeCounts)
 250         printf(&quot;  %s: %zu\n&quot;, stringForRareDataUseType(static_cast&lt;NodeRareData::UseType&gt;(it.key)), it.value);
 251     printf(&quot;\n&quot;);
 252 
 253 
 254     printf(&quot;NodeType distribution:\n&quot;);
 255     printf(&quot;  Number of Element nodes: %zu\n&quot;, elementNodes);
 256     printf(&quot;  Number of Attribute nodes: %zu\n&quot;, attrNodes);
 257     printf(&quot;  Number of Text nodes: %zu\n&quot;, textNodes);
 258     printf(&quot;  Number of CDATASection nodes: %zu\n&quot;, cdataNodes);
 259     printf(&quot;  Number of Comment nodes: %zu\n&quot;, commentNodes);
 260     printf(&quot;  Number of ProcessingInstruction nodes: %zu\n&quot;, piNodes);
 261     printf(&quot;  Number of Document nodes: %zu\n&quot;, documentNodes);
 262     printf(&quot;  Number of DocumentType nodes: %zu\n&quot;, docTypeNodes);
 263     printf(&quot;  Number of DocumentFragment nodes: %zu\n&quot;, fragmentNodes);
 264     printf(&quot;  Number of ShadowRoot nodes: %zu\n&quot;, shadowRootNodes);
 265 
 266     printf(&quot;Element tag name distibution:\n&quot;);
 267     for (auto&amp; stringSizePair : perTagCount)
 268         printf(&quot;  Number of &lt;%s&gt; tags: %zu\n&quot;, stringSizePair.key.utf8().data(), stringSizePair.value);
 269 
 270     printf(&quot;Attributes:\n&quot;);
 271     printf(&quot;  Number of Attributes (non-Node and Node): %zu [%zu]\n&quot;, attributes, sizeof(Attribute));
 272     printf(&quot;  Number of Attributes with an Attr: %zu\n&quot;, attributesWithAttr);
 273     printf(&quot;  Number of Elements with attribute storage: %zu [%zu]\n&quot;, elementsWithAttributeStorage, sizeof(ElementData));
 274     printf(&quot;  Number of Elements with RareData: %zu\n&quot;, elementsWithRareData);
 275     printf(&quot;  Number of Elements with NamedNodeMap: %zu [%zu]\n&quot;, elementsWithNamedNodeMap, sizeof(NamedNodeMap));
 276 #endif
 277 }
 278 
 279 DEFINE_DEBUG_ONLY_GLOBAL(WTF::RefCountedLeakCounter, nodeCounter, (&quot;WebCoreNode&quot;));
 280 
 281 #ifndef NDEBUG
 282 static bool shouldIgnoreLeaks = false;
 283 
 284 static HashSet&lt;Node*&gt;&amp; ignoreSet()
 285 {
 286     static NeverDestroyed&lt;HashSet&lt;Node*&gt;&gt; ignore;
 287 
 288     return ignore;
 289 }
 290 
 291 #endif
 292 
 293 void Node::startIgnoringLeaks()
 294 {
 295 #ifndef NDEBUG
 296     shouldIgnoreLeaks = true;
 297 #endif
 298 }
 299 
 300 void Node::stopIgnoringLeaks()
 301 {
 302 #ifndef NDEBUG
 303     shouldIgnoreLeaks = false;
 304 #endif
 305 }
 306 
 307 void Node::trackForDebugging()
 308 {
 309 #ifndef NDEBUG
 310     if (shouldIgnoreLeaks)
 311         ignoreSet().add(this);
 312     else
 313         nodeCounter.increment();
 314 #endif
 315 
 316 #if DUMP_NODE_STATISTICS
 317     liveNodeSet().add(this);
 318 #endif
 319 }
 320 
 321 Node::Node(Document&amp; document, ConstructionType type)
 322     : m_nodeFlags(type)
 323     , m_treeScope(&amp;document)
 324 {
 325     ASSERT(isMainThread());
 326 
 327     document.incrementReferencingNodeCount();
 328 
 329 #if !defined(NDEBUG) || (defined(DUMP_NODE_STATISTICS) &amp;&amp; DUMP_NODE_STATISTICS)
 330     trackForDebugging();
 331 #endif
 332 }
 333 
 334 Node::~Node()
 335 {
 336     ASSERT(isMainThread());
 337     ASSERT(m_refCountAndParentBit == s_refCountIncrement);
 338     ASSERT(m_deletionHasBegun);
 339     ASSERT(!m_adoptionIsRequired);
 340 
 341 #ifndef NDEBUG
 342     if (!ignoreSet().remove(this))
 343         nodeCounter.decrement();
 344 #endif
 345 
 346 #if DUMP_NODE_STATISTICS
 347     liveNodeSet().remove(this);
 348 #endif
 349 
 350     RELEASE_ASSERT(!renderer());
 351     ASSERT(!parentNode());
 352     ASSERT(!m_previous);
 353     ASSERT(!m_next);
 354 
 355     if (hasRareData())
 356         clearRareData();
 357 
 358     if (!isContainerNode())
 359         willBeDeletedFrom(document());
 360 
 361     if (hasEventTargetData())
 362         clearEventTargetData();
 363 
 364     document().decrementReferencingNodeCount();
 365 
 366 #if ENABLE(TOUCH_EVENTS) &amp;&amp; PLATFORM(IOS_FAMILY) &amp;&amp; (!ASSERT_DISABLED || ENABLE(SECURITY_ASSERTIONS))
 367     for (auto* document : Document::allDocuments()) {
 368         ASSERT_WITH_SECURITY_IMPLICATION(!document-&gt;touchEventListenersContain(*this));
 369         ASSERT_WITH_SECURITY_IMPLICATION(!document-&gt;touchEventHandlersContain(*this));
 370         ASSERT_WITH_SECURITY_IMPLICATION(!document-&gt;touchEventTargetsContain(*this));
 371     }
 372 #endif
 373 }
 374 
 375 void Node::willBeDeletedFrom(Document&amp; document)
 376 {
 377     if (hasEventTargetData()) {
 378         document.didRemoveWheelEventHandler(*this, EventHandlerRemoval::All);
 379 #if ENABLE(TOUCH_EVENTS)
 380 #if PLATFORM(IOS_FAMILY)
 381         document.removeTouchEventListener(*this, EventHandlerRemoval::All);
 382 #endif
 383         document.didRemoveTouchEventHandler(*this, EventHandlerRemoval::All);
 384 #endif
 385     }
 386 
 387 #if ENABLE(TOUCH_EVENTS) &amp;&amp; PLATFORM(IOS_FAMILY)
 388     document.removeTouchEventHandler(*this, EventHandlerRemoval::All);
 389 #endif
 390 
 391     if (auto* cache = document.existingAXObjectCache())
 392         cache-&gt;remove(*this);
 393 }
 394 
 395 void Node::materializeRareData()
 396 {
 397     if (is&lt;Element&gt;(*this))
 398         m_rareData = std::unique_ptr&lt;NodeRareData, NodeRareDataDeleter&gt;(new ElementRareData);
 399     else
 400         m_rareData = std::unique_ptr&lt;NodeRareData, NodeRareDataDeleter&gt;(new NodeRareData);
 401 }
 402 
 403 inline void Node::NodeRareDataDeleter::operator()(NodeRareData* rareData) const
 404 {
 405     if (rareData-&gt;isElementRareData())
 406         delete static_cast&lt;ElementRareData*&gt;(rareData);
 407     else
 408         delete static_cast&lt;NodeRareData*&gt;(rareData);
 409 }
 410 
 411 void Node::clearRareData()
 412 {
 413     ASSERT(hasRareData());
 414     ASSERT(!transientMutationObserverRegistry() || transientMutationObserverRegistry()-&gt;isEmpty());
 415 
 416     m_rareData = nullptr;
 417 }
 418 
 419 bool Node::isNode() const
 420 {
 421     return true;
 422 }
 423 
 424 String Node::nodeValue() const
 425 {
 426     return String();
 427 }
 428 
 429 ExceptionOr&lt;void&gt; Node::setNodeValue(const String&amp;)
 430 {
 431     // By default, setting nodeValue has no effect.
 432     return { };
 433 }
 434 
 435 RefPtr&lt;NodeList&gt; Node::childNodes()
 436 {
 437     if (is&lt;ContainerNode&gt;(*this))
 438         return ensureRareData().ensureNodeLists().ensureChildNodeList(downcast&lt;ContainerNode&gt;(*this));
 439     return ensureRareData().ensureNodeLists().ensureEmptyChildNodeList(*this);
 440 }
 441 
 442 Node *Node::lastDescendant() const
 443 {
 444     Node *n = const_cast&lt;Node *&gt;(this);
 445     while (n &amp;&amp; n-&gt;lastChild())
 446         n = n-&gt;lastChild();
 447     return n;
 448 }
 449 
 450 Node* Node::firstDescendant() const
 451 {
 452     Node *n = const_cast&lt;Node *&gt;(this);
 453     while (n &amp;&amp; n-&gt;firstChild())
 454         n = n-&gt;firstChild();
 455     return n;
 456 }
 457 
 458 Element* Node::previousElementSibling() const
 459 {
 460     return ElementTraversal::previousSibling(*this);
 461 }
 462 
 463 Element* Node::nextElementSibling() const
 464 {
 465     return ElementTraversal::nextSibling(*this);
 466 }
 467 
 468 ExceptionOr&lt;void&gt; Node::insertBefore(Node&amp; newChild, Node* refChild)
 469 {
 470     if (!is&lt;ContainerNode&gt;(*this))
 471         return Exception { HierarchyRequestError };
 472     return downcast&lt;ContainerNode&gt;(*this).insertBefore(newChild, refChild);
 473 }
 474 
 475 ExceptionOr&lt;void&gt; Node::replaceChild(Node&amp; newChild, Node&amp; oldChild)
 476 {
 477     if (!is&lt;ContainerNode&gt;(*this))
 478         return Exception { HierarchyRequestError };
 479     return downcast&lt;ContainerNode&gt;(*this).replaceChild(newChild, oldChild);
 480 }
 481 
 482 ExceptionOr&lt;void&gt; Node::removeChild(Node&amp; oldChild)
 483 {
 484     if (!is&lt;ContainerNode&gt;(*this))
 485         return Exception { NotFoundError };
 486     return downcast&lt;ContainerNode&gt;(*this).removeChild(oldChild);
 487 }
 488 
 489 ExceptionOr&lt;void&gt; Node::appendChild(Node&amp; newChild)
 490 {
 491     if (!is&lt;ContainerNode&gt;(*this))
 492         return Exception { HierarchyRequestError };
 493     return downcast&lt;ContainerNode&gt;(*this).appendChild(newChild);
 494 }
 495 
 496 static HashSet&lt;RefPtr&lt;Node&gt;&gt; nodeSetPreTransformedFromNodeOrStringVector(const Vector&lt;NodeOrString&gt;&amp; vector)
 497 {
 498     HashSet&lt;RefPtr&lt;Node&gt;&gt; nodeSet;
 499     for (const auto&amp; variant : vector) {
 500         WTF::switchOn(variant,
 501             [&amp;] (const RefPtr&lt;Node&gt;&amp; node) { nodeSet.add(const_cast&lt;Node*&gt;(node.get())); },
 502             [] (const String&amp;) { }
 503         );
 504     }
 505     return nodeSet;
 506 }
 507 
 508 static RefPtr&lt;Node&gt; firstPrecedingSiblingNotInNodeSet(Node&amp; context, const HashSet&lt;RefPtr&lt;Node&gt;&gt;&amp; nodeSet)
 509 {
 510     for (auto* sibling = context.previousSibling(); sibling; sibling = sibling-&gt;previousSibling()) {
 511         if (!nodeSet.contains(sibling))
 512             return sibling;
 513     }
 514     return nullptr;
 515 }
 516 
 517 static RefPtr&lt;Node&gt; firstFollowingSiblingNotInNodeSet(Node&amp; context, const HashSet&lt;RefPtr&lt;Node&gt;&gt;&amp; nodeSet)
 518 {
 519     for (auto* sibling = context.nextSibling(); sibling; sibling = sibling-&gt;nextSibling()) {
 520         if (!nodeSet.contains(sibling))
 521             return sibling;
 522     }
 523     return nullptr;
 524 }
 525 
 526 ExceptionOr&lt;RefPtr&lt;Node&gt;&gt; Node::convertNodesOrStringsIntoNode(Vector&lt;NodeOrString&gt;&amp;&amp; nodeOrStringVector)
 527 {
 528     if (nodeOrStringVector.isEmpty())
 529         return nullptr;
 530 
 531     Vector&lt;Ref&lt;Node&gt;&gt; nodes;
 532     nodes.reserveInitialCapacity(nodeOrStringVector.size());
 533     for (auto&amp; variant : nodeOrStringVector) {
 534         WTF::switchOn(variant,
 535             [&amp;](RefPtr&lt;Node&gt;&amp; node) { nodes.uncheckedAppend(*node.get()); },
 536             [&amp;](String&amp; string) { nodes.uncheckedAppend(Text::create(document(), string)); }
 537         );
 538     }
 539 
 540     if (nodes.size() == 1)
 541         return RefPtr&lt;Node&gt; { WTFMove(nodes.first()) };
 542 
 543     auto nodeToReturn = DocumentFragment::create(document());
 544     for (auto&amp; node : nodes) {
 545         auto appendResult = nodeToReturn-&gt;appendChild(node);
 546         if (appendResult.hasException())
 547             return appendResult.releaseException();
 548     }
 549     return RefPtr&lt;Node&gt; { WTFMove(nodeToReturn) };
 550 }
 551 
 552 ExceptionOr&lt;void&gt; Node::before(Vector&lt;NodeOrString&gt;&amp;&amp; nodeOrStringVector)
 553 {
 554     RefPtr&lt;ContainerNode&gt; parent = parentNode();
 555     if (!parent)
 556         return { };
 557 
 558     auto nodeSet = nodeSetPreTransformedFromNodeOrStringVector(nodeOrStringVector);
 559     auto viablePreviousSibling = firstPrecedingSiblingNotInNodeSet(*this, nodeSet);
 560 
 561     auto result = convertNodesOrStringsIntoNode(WTFMove(nodeOrStringVector));
 562     if (result.hasException())
 563         return result.releaseException();
 564     auto node = result.releaseReturnValue();
 565     if (!node)
 566         return { };
 567 
 568     if (viablePreviousSibling)
 569         viablePreviousSibling = viablePreviousSibling-&gt;nextSibling();
 570     else
 571         viablePreviousSibling = parent-&gt;firstChild();
 572 
 573     return parent-&gt;insertBefore(*node, viablePreviousSibling.get());
 574 }
 575 
 576 ExceptionOr&lt;void&gt; Node::after(Vector&lt;NodeOrString&gt;&amp;&amp; nodeOrStringVector)
 577 {
 578     RefPtr&lt;ContainerNode&gt; parent = parentNode();
 579     if (!parent)
 580         return { };
 581 
 582     auto nodeSet = nodeSetPreTransformedFromNodeOrStringVector(nodeOrStringVector);
 583     auto viableNextSibling = firstFollowingSiblingNotInNodeSet(*this, nodeSet);
 584 
 585     auto result = convertNodesOrStringsIntoNode(WTFMove(nodeOrStringVector));
 586     if (result.hasException())
 587         return result.releaseException();
 588     auto node = result.releaseReturnValue();
 589     if (!node)
 590         return { };
 591 
 592     return parent-&gt;insertBefore(*node, viableNextSibling.get());
 593 }
 594 
 595 ExceptionOr&lt;void&gt; Node::replaceWith(Vector&lt;NodeOrString&gt;&amp;&amp; nodeOrStringVector)
 596 {
 597     RefPtr&lt;ContainerNode&gt; parent = parentNode();
 598     if (!parent)
 599         return { };
 600 
 601     auto nodeSet = nodeSetPreTransformedFromNodeOrStringVector(nodeOrStringVector);
 602     auto viableNextSibling = firstFollowingSiblingNotInNodeSet(*this, nodeSet);
 603 
 604     auto result = convertNodesOrStringsIntoNode(WTFMove(nodeOrStringVector));
 605     if (result.hasException())
 606         return result.releaseException();
 607 
 608     if (parentNode() == parent) {
 609         if (auto node = result.releaseReturnValue())
 610             return parent-&gt;replaceChild(*node, *this);
 611         return parent-&gt;removeChild(*this);
 612     }
 613 
 614     if (auto node = result.releaseReturnValue())
 615         return parent-&gt;insertBefore(*node, viableNextSibling.get());
 616     return { };
 617 }
 618 
 619 ExceptionOr&lt;void&gt; Node::remove()
 620 {
 621     auto* parent = parentNode();
 622     if (!parent)
 623         return { };
 624     return parent-&gt;removeChild(*this);
 625 }
 626 
 627 void Node::normalize()
 628 {
 629     // Go through the subtree beneath us, normalizing all nodes. This means that
 630     // any two adjacent text nodes are merged and any empty text nodes are removed.
 631 
 632     RefPtr&lt;Node&gt; node = this;
 633     while (Node* firstChild = node-&gt;firstChild())
 634         node = firstChild;
 635     while (node) {
 636         NodeType type = node-&gt;nodeType();
 637         if (type == ELEMENT_NODE)
 638             downcast&lt;Element&gt;(*node).normalizeAttributes();
 639 
 640         if (node == this)
 641             break;
 642 
 643         if (type != TEXT_NODE) {
 644             node = NodeTraversal::nextPostOrder(*node);
 645             continue;
 646         }
 647 
 648         RefPtr&lt;Text&gt; text = downcast&lt;Text&gt;(node.get());
 649 
 650         // Remove empty text nodes.
 651         if (!text-&gt;length()) {
 652             // Care must be taken to get the next node before removing the current node.
 653             node = NodeTraversal::nextPostOrder(*node);
 654             text-&gt;remove();
 655             continue;
 656         }
 657 
 658         // Merge text nodes.
 659         while (Node* nextSibling = node-&gt;nextSibling()) {
 660             if (nextSibling-&gt;nodeType() != TEXT_NODE)
 661                 break;
 662             Ref&lt;Text&gt; nextText = downcast&lt;Text&gt;(*nextSibling);
 663 
 664             // Remove empty text nodes.
 665             if (!nextText-&gt;length()) {
 666                 nextText-&gt;remove();
 667                 continue;
 668             }
 669 
 670             // Both non-empty text nodes. Merge them.
 671             unsigned offset = text-&gt;length();
 672             text-&gt;appendData(nextText-&gt;data());
 673             document().textNodesMerged(nextText, offset);
 674             nextText-&gt;remove();
 675         }
 676 
 677         node = NodeTraversal::nextPostOrder(*node);
 678     }
 679 }
 680 
 681 ExceptionOr&lt;Ref&lt;Node&gt;&gt; Node::cloneNodeForBindings(bool deep)
 682 {
 683     if (UNLIKELY(isShadowRoot()))
 684         return Exception { NotSupportedError };
 685     return cloneNode(deep);
 686 }
 687 
 688 const AtomString&amp; Node::prefix() const
 689 {
 690     // For nodes other than elements and attributes, the prefix is always null
 691     return nullAtom();
 692 }
 693 
 694 ExceptionOr&lt;void&gt; Node::setPrefix(const AtomString&amp;)
 695 {
 696     // The spec says that for nodes other than elements and attributes, prefix is always null.
 697     // It does not say what to do when the user tries to set the prefix on another type of
 698     // node, however Mozilla throws a NamespaceError exception.
 699     return Exception { NamespaceError };
 700 }
 701 
 702 const AtomString&amp; Node::localName() const
 703 {
 704     return nullAtom();
 705 }
 706 
 707 const AtomString&amp; Node::namespaceURI() const
 708 {
 709     return nullAtom();
 710 }
 711 
 712 bool Node::isContentEditable()
 713 {
 714     return computeEditability(UserSelectAllDoesNotAffectEditability, ShouldUpdateStyle::Update) != Editability::ReadOnly;
 715 }
 716 
 717 bool Node::isContentRichlyEditable()
 718 {
 719     return computeEditability(UserSelectAllIsAlwaysNonEditable, ShouldUpdateStyle::Update) == Editability::CanEditRichly;
 720 }
 721 
 722 void Node::inspect()
 723 {
 724     if (document().page())
 725         document().page()-&gt;inspectorController().inspect(this);
 726 }
 727 
 728 static Node::Editability computeEditabilityFromComputedStyle(const Node&amp; startNode, Node::UserSelectAllTreatment treatment)
 729 {
 730     // Ideally we&#39;d call ASSERT(!needsStyleRecalc()) here, but
 731     // ContainerNode::setFocus() calls invalidateStyleForSubtree(), so the assertion
 732     // would fire in the middle of Document::setFocusedElement().
 733 
 734     for (const Node* node = &amp;startNode; node; node = node-&gt;parentNode()) {
 735         auto* style = node-&gt;isDocumentNode() ? node-&gt;renderStyle() : const_cast&lt;Node*&gt;(node)-&gt;computedStyle();
 736         if (!style)
 737             continue;
 738         if (style-&gt;display() == DisplayType::None)
 739             continue;
 740 #if ENABLE(USERSELECT_ALL)
 741         // Elements with user-select: all style are considered atomic
 742         // therefore non editable.
 743         if (treatment == Node::UserSelectAllIsAlwaysNonEditable &amp;&amp; style-&gt;userSelect() == UserSelect::All)
 744             return Node::Editability::ReadOnly;
 745 #else
 746         UNUSED_PARAM(treatment);
 747 #endif
 748         switch (style-&gt;userModify()) {
 749         case UserModify::ReadOnly:
 750             return Node::Editability::ReadOnly;
 751         case UserModify::ReadWrite:
 752             return Node::Editability::CanEditRichly;
 753         case UserModify::ReadWritePlaintextOnly:
 754             return Node::Editability::CanEditPlainText;
 755         }
 756         ASSERT_NOT_REACHED();
 757         return Node::Editability::ReadOnly;
 758     }
 759     return Node::Editability::ReadOnly;
 760 }
 761 
 762 Node::Editability Node::computeEditability(UserSelectAllTreatment treatment, ShouldUpdateStyle shouldUpdateStyle) const
 763 {
 764     if (!document().hasLivingRenderTree() || isPseudoElement())
 765         return Editability::ReadOnly;
 766 
 767     if (isInShadowTree())
 768         return HTMLElement::editabilityFromContentEditableAttr(*this);
 769 
 770     if (document().frame() &amp;&amp; document().frame()-&gt;page() &amp;&amp; document().frame()-&gt;page()-&gt;isEditable())
 771         return Editability::CanEditRichly;
 772 
 773     if (shouldUpdateStyle == ShouldUpdateStyle::Update &amp;&amp; document().needsStyleRecalc()) {
 774         if (!document().usesStyleBasedEditability())
 775             return HTMLElement::editabilityFromContentEditableAttr(*this);
 776         document().updateStyleIfNeeded();
 777     }
 778     return computeEditabilityFromComputedStyle(*this, treatment);
 779 }
 780 
 781 RenderBox* Node::renderBox() const
 782 {
 783     RenderObject* renderer = this-&gt;renderer();
 784     return is&lt;RenderBox&gt;(renderer) ? downcast&lt;RenderBox&gt;(renderer) : nullptr;
 785 }
 786 
 787 RenderBoxModelObject* Node::renderBoxModelObject() const
 788 {
 789     RenderObject* renderer = this-&gt;renderer();
 790     return is&lt;RenderBoxModelObject&gt;(renderer) ? downcast&lt;RenderBoxModelObject&gt;(renderer) : nullptr;
 791 }
 792 
 793 LayoutRect Node::renderRect(bool* isReplaced)
 794 {
 795     RenderObject* hitRenderer = this-&gt;renderer();
 796     if (!hitRenderer &amp;&amp; is&lt;HTMLAreaElement&gt;(*this)) {
 797         auto&amp; area = downcast&lt;HTMLAreaElement&gt;(*this);
 798         if (auto* imageElement = area.imageElement())
 799             hitRenderer = imageElement-&gt;renderer();
 800     }
 801     RenderObject* renderer = hitRenderer;
 802     while (renderer &amp;&amp; !renderer-&gt;isBody() &amp;&amp; !renderer-&gt;isDocumentElementRenderer()) {
 803         if (renderer-&gt;isRenderBlock() || renderer-&gt;isInlineBlockOrInlineTable() || renderer-&gt;isReplaced()) {
 804             *isReplaced = renderer-&gt;isReplaced();
 805             return renderer-&gt;absoluteBoundingBoxRect();
 806         }
 807         renderer = renderer-&gt;parent();
 808     }
 809     return LayoutRect();
 810 }
 811 
 812 void Node::refEventTarget()
 813 {
 814     ref();
 815 }
 816 
 817 void Node::derefEventTarget()
 818 {
 819     deref();
 820 }
 821 
 822 void Node::adjustStyleValidity(Style::Validity validity, Style::InvalidationMode mode)
 823 {
 824     if (validity &gt; styleValidity()) {
 825         m_nodeFlags &amp;= ~StyleValidityMask;
 826         m_nodeFlags |= static_cast&lt;unsigned&gt;(validity) &lt;&lt; StyleValidityShift;
 827     }
 828     if (mode == Style::InvalidationMode::RecompositeLayer)
 829         setFlag(StyleResolutionShouldRecompositeLayerFlag);
 830 }
 831 
 832 inline void Node::updateAncestorsForStyleRecalc()
 833 {
 834     auto composedAncestors = composedTreeAncestors(*this);
 835     auto it = composedAncestors.begin();
 836     auto end = composedAncestors.end();
 837     if (it != end) {
 838         it-&gt;setDirectChildNeedsStyleRecalc();
 839 
 840         for (; it != end; ++it) {
 841             // Iterator skips over shadow roots.
 842             if (auto* shadowRoot = it-&gt;shadowRoot())
 843                 shadowRoot-&gt;setChildNeedsStyleRecalc();
 844             if (it-&gt;childNeedsStyleRecalc())
 845                 break;
 846             it-&gt;setChildNeedsStyleRecalc();
 847         }
 848     }
 849 
 850     auto* documentElement = document().documentElement();
 851     if (!documentElement)
 852         return;
 853     if (!documentElement-&gt;childNeedsStyleRecalc() &amp;&amp; !documentElement-&gt;needsStyleRecalc())
 854         return;
 855     document().setChildNeedsStyleRecalc();
 856     document().scheduleStyleRecalc();
 857 }
 858 
 859 void Node::invalidateStyle(Style::Validity validity, Style::InvalidationMode mode)
 860 {
 861     ASSERT(validity != Style::Validity::Valid);
 862     if (!inRenderedDocument())
 863         return;
 864 
 865     // FIXME: This should eventually be an ASSERT.
 866     if (document().inRenderTreeUpdate())
 867         return;
 868 
 869     // FIXME: Why the second condition?
 870     bool markAncestors = styleValidity() == Style::Validity::Valid || validity == Style::Validity::SubtreeAndRenderersInvalid;
 871 
 872     adjustStyleValidity(validity, mode);
 873 
 874     if (markAncestors)
 875         updateAncestorsForStyleRecalc();
 876 }
 877 
 878 unsigned Node::computeNodeIndex() const
 879 {
 880     unsigned count = 0;
 881     for (Node* sibling = previousSibling(); sibling; sibling = sibling-&gt;previousSibling())
 882         ++count;
 883     return count;
 884 }
 885 
 886 template&lt;unsigned type&gt;
 887 bool shouldInvalidateNodeListCachesForAttr(const unsigned nodeListCounts[], const QualifiedName&amp; attrName)
 888 {
 889     if (nodeListCounts[type] &amp;&amp; shouldInvalidateTypeOnAttributeChange(static_cast&lt;NodeListInvalidationType&gt;(type), attrName))
 890         return true;
 891     return shouldInvalidateNodeListCachesForAttr&lt;type + 1&gt;(nodeListCounts, attrName);
 892 }
 893 
 894 template&lt;&gt;
 895 bool shouldInvalidateNodeListCachesForAttr&lt;numNodeListInvalidationTypes&gt;(const unsigned[], const QualifiedName&amp;)
 896 {
 897     return false;
 898 }
 899 
 900 inline bool Document::shouldInvalidateNodeListAndCollectionCaches() const
 901 {
 902     for (int type = 0; type &lt; numNodeListInvalidationTypes; ++type) {
 903         if (m_nodeListAndCollectionCounts[type])
 904             return true;
 905     }
 906     return false;
 907 }
 908 
 909 inline bool Document::shouldInvalidateNodeListAndCollectionCachesForAttribute(const QualifiedName&amp; attrName) const
 910 {
 911     return shouldInvalidateNodeListCachesForAttr&lt;DoNotInvalidateOnAttributeChanges + 1&gt;(m_nodeListAndCollectionCounts, attrName);
 912 }
 913 
 914 template &lt;typename InvalidationFunction&gt;
 915 void Document::invalidateNodeListAndCollectionCaches(InvalidationFunction invalidate)
 916 {
 917     for (auto* list : copyToVectorSpecialization&lt;Vector&lt;LiveNodeList*, 8&gt;&gt;(m_listsInvalidatedAtDocument))
 918         invalidate(*list);
 919 
 920     for (auto* collection : copyToVectorSpecialization&lt;Vector&lt;HTMLCollection*, 8&gt;&gt;(m_collectionsInvalidatedAtDocument))
 921         invalidate(*collection);
 922 }
 923 
 924 void Node::invalidateNodeListAndCollectionCachesInAncestors()
 925 {
 926     if (hasRareData()) {
 927         if (auto* lists = rareData()-&gt;nodeLists())
 928             lists-&gt;clearChildNodeListCache();
 929     }
 930 
 931     if (!document().shouldInvalidateNodeListAndCollectionCaches())
 932         return;
 933 
 934     document().invalidateNodeListAndCollectionCaches([](auto&amp; list) {
 935         list.invalidateCache();
 936     });
 937 
 938     for (auto* node = this; node; node = node-&gt;parentNode()) {
 939         if (!node-&gt;hasRareData())
 940             continue;
 941 
 942         if (auto* lists = node-&gt;rareData()-&gt;nodeLists())
 943             lists-&gt;invalidateCaches();
 944     }
 945 }
 946 
 947 void Node::invalidateNodeListAndCollectionCachesInAncestorsForAttribute(const QualifiedName&amp; attrName)
 948 {
 949     ASSERT(is&lt;Element&gt;(*this));
 950 
 951     if (!document().shouldInvalidateNodeListAndCollectionCachesForAttribute(attrName))
 952         return;
 953 
 954     document().invalidateNodeListAndCollectionCaches([&amp;attrName](auto&amp; list) {
 955         list.invalidateCacheForAttribute(attrName);
 956     });
 957 
 958     for (auto* node = this; node; node = node-&gt;parentNode()) {
 959         if (!node-&gt;hasRareData())
 960             continue;
 961 
 962         if (auto* lists = node-&gt;rareData()-&gt;nodeLists())
 963             lists-&gt;invalidateCachesForAttribute(attrName);
 964     }
 965 }
 966 
 967 NodeListsNodeData* Node::nodeLists()
 968 {
 969     return hasRareData() ? rareData()-&gt;nodeLists() : nullptr;
 970 }
 971 
 972 void Node::clearNodeLists()
 973 {
 974     rareData()-&gt;clearNodeLists();
 975 }
 976 
 977 ExceptionOr&lt;void&gt; Node::checkSetPrefix(const AtomString&amp; prefix)
 978 {
 979     // Perform error checking as required by spec for setting Node.prefix. Used by
 980     // Element::setPrefix() and Attr::setPrefix()
 981 
 982     if (!prefix.isEmpty() &amp;&amp; !Document::isValidName(prefix))
 983         return Exception { InvalidCharacterError };
 984 
 985     // FIXME: Raise NamespaceError if prefix is malformed per the Namespaces in XML specification.
 986 
 987     auto&amp; namespaceURI = this-&gt;namespaceURI();
 988     if (namespaceURI.isEmpty() &amp;&amp; !prefix.isEmpty())
 989         return Exception { NamespaceError };
 990     if (prefix == xmlAtom() &amp;&amp; namespaceURI != XMLNames::xmlNamespaceURI)
 991         return Exception { NamespaceError };
 992 
 993     // Attribute-specific checks are in Attr::setPrefix().
 994 
 995     return { };
 996 }
 997 
 998 bool Node::isDescendantOf(const Node&amp; other) const
 999 {
1000     // Return true if other is an ancestor of this, otherwise false
1001     if (!other.hasChildNodes() || isConnected() != other.isConnected())
1002         return false;
1003     if (other.isDocumentNode())
1004         return &amp;document() == &amp;other &amp;&amp; !isDocumentNode() &amp;&amp; isConnected();
1005     for (const auto* ancestor = parentNode(); ancestor; ancestor = ancestor-&gt;parentNode()) {
1006         if (ancestor == &amp;other)
1007             return true;
1008     }
1009     return false;
1010 }
1011 
1012 bool Node::isDescendantOrShadowDescendantOf(const Node* other) const
1013 {
1014     // FIXME: This element&#39;s shadow tree&#39;s host could be inside another shadow tree.
1015     // This function doesn&#39;t handle that case correctly. Maybe share code with
1016     // the containsIncludingShadowDOM function?
1017     return other &amp;&amp; (isDescendantOf(*other) || other-&gt;contains(shadowHost()));
1018 }
1019 
1020 bool Node::contains(const Node* node) const
1021 {
1022     return this == node || (node &amp;&amp; node-&gt;isDescendantOf(*this));
1023 }
1024 
1025 bool Node::containsIncludingShadowDOM(const Node* node) const
1026 {
1027     for (; node; node = node-&gt;parentOrShadowHostNode()) {
1028         if (node == this)
1029             return true;
1030     }
1031     return false;
1032 }
1033 
1034 Node* Node::pseudoAwarePreviousSibling() const
1035 {
1036     Element* parentOrHost = is&lt;PseudoElement&gt;(*this) ? downcast&lt;PseudoElement&gt;(*this).hostElement() : parentElement();
1037     if (parentOrHost &amp;&amp; !previousSibling()) {
1038         if (isAfterPseudoElement() &amp;&amp; parentOrHost-&gt;lastChild())
1039             return parentOrHost-&gt;lastChild();
1040         if (!isBeforePseudoElement())
1041             return parentOrHost-&gt;beforePseudoElement();
1042     }
1043     return previousSibling();
1044 }
1045 
1046 Node* Node::pseudoAwareNextSibling() const
1047 {
1048     Element* parentOrHost = is&lt;PseudoElement&gt;(*this) ? downcast&lt;PseudoElement&gt;(*this).hostElement() : parentElement();
1049     if (parentOrHost &amp;&amp; !nextSibling()) {
1050         if (isBeforePseudoElement() &amp;&amp; parentOrHost-&gt;firstChild())
1051             return parentOrHost-&gt;firstChild();
1052         if (!isAfterPseudoElement())
1053             return parentOrHost-&gt;afterPseudoElement();
1054     }
1055     return nextSibling();
1056 }
1057 
1058 Node* Node::pseudoAwareFirstChild() const
1059 {
1060     if (is&lt;Element&gt;(*this)) {
1061         const Element&amp; currentElement = downcast&lt;Element&gt;(*this);
1062         Node* first = currentElement.beforePseudoElement();
1063         if (first)
1064             return first;
1065         first = currentElement.firstChild();
1066         if (!first)
1067             first = currentElement.afterPseudoElement();
1068         return first;
1069     }
1070     return firstChild();
1071 }
1072 
1073 Node* Node::pseudoAwareLastChild() const
1074 {
1075     if (is&lt;Element&gt;(*this)) {
1076         const Element&amp; currentElement = downcast&lt;Element&gt;(*this);
1077         Node* last = currentElement.afterPseudoElement();
1078         if (last)
1079             return last;
1080         last = currentElement.lastChild();
1081         if (!last)
1082             last = currentElement.beforePseudoElement();
1083         return last;
1084     }
1085     return lastChild();
1086 }
1087 
1088 const RenderStyle* Node::computedStyle(PseudoId pseudoElementSpecifier)
1089 {
1090     auto* composedParent = composedTreeAncestors(*this).first();
1091     if (!composedParent)
1092         return nullptr;
1093     return composedParent-&gt;computedStyle(pseudoElementSpecifier);
1094 }
1095 
1096 int Node::maxCharacterOffset() const
1097 {
1098     ASSERT_NOT_REACHED();
1099     return 0;
1100 }
1101 
1102 // FIXME: Shouldn&#39;t these functions be in the editing code?  Code that asks questions about HTML in the core DOM class
1103 // is obviously misplaced.
1104 bool Node::canStartSelection() const
1105 {
1106     if (hasEditableStyle())
1107         return true;
1108 
1109     if (renderer()) {
1110         const RenderStyle&amp; style = renderer()-&gt;style();
1111         // We allow selections to begin within an element that has -webkit-user-select: none set,
1112         // but if the element is draggable then dragging should take priority over selection.
1113         if (style.userDrag() == UserDrag::Element &amp;&amp; style.userSelect() == UserSelect::None)
1114             return false;
1115     }
1116     return parentOrShadowHostNode() ? parentOrShadowHostNode()-&gt;canStartSelection() : true;
1117 }
1118 
1119 Element* Node::shadowHost() const
1120 {
1121     if (ShadowRoot* root = containingShadowRoot())
1122         return root-&gt;host();
1123     return nullptr;
1124 }
1125 
1126 ShadowRoot* Node::containingShadowRoot() const
1127 {
1128     ContainerNode&amp; root = treeScope().rootNode();
1129     return is&lt;ShadowRoot&gt;(root) ? downcast&lt;ShadowRoot&gt;(&amp;root) : nullptr;
1130 }
1131 
1132 #if !ASSERT_DISABLED
1133 // https://dom.spec.whatwg.org/#concept-closed-shadow-hidden
1134 static bool isClosedShadowHiddenUsingSpecDefinition(const Node&amp; A, const Node&amp; B)
1135 {
1136     return A.isInShadowTree()
1137         &amp;&amp; !A.rootNode().containsIncludingShadowDOM(&amp;B)
1138         &amp;&amp; (A.containingShadowRoot()-&gt;mode() != ShadowRootMode::Open || isClosedShadowHiddenUsingSpecDefinition(*A.shadowHost(), B));
1139 }
1140 #endif
1141 
1142 // http://w3c.github.io/webcomponents/spec/shadow/#dfn-unclosed-node
1143 bool Node::isClosedShadowHidden(const Node&amp; otherNode) const
1144 {
1145     // Use Vector instead of HashSet since we expect the number of ancestor tree scopes to be small.
1146     Vector&lt;TreeScope*, 8&gt; ancestorScopesOfThisNode;
1147 
1148     for (auto* scope = &amp;treeScope(); scope; scope = scope-&gt;parentTreeScope())
1149         ancestorScopesOfThisNode.append(scope);
1150 
1151     for (auto* treeScopeThatCanAccessOtherNode = &amp;otherNode.treeScope(); treeScopeThatCanAccessOtherNode; treeScopeThatCanAccessOtherNode = treeScopeThatCanAccessOtherNode-&gt;parentTreeScope()) {
1152         for (auto* scope : ancestorScopesOfThisNode) {
1153             if (scope == treeScopeThatCanAccessOtherNode) {
1154                 ASSERT(!isClosedShadowHiddenUsingSpecDefinition(otherNode, *this));
1155                 return false; // treeScopeThatCanAccessOtherNode is a shadow-including inclusive ancestor of this node.
1156             }
1157         }
1158         auto&amp; root = treeScopeThatCanAccessOtherNode-&gt;rootNode();
1159         if (is&lt;ShadowRoot&gt;(root) &amp;&amp; downcast&lt;ShadowRoot&gt;(root).mode() != ShadowRootMode::Open)
1160             break;
1161     }
1162 
1163     ASSERT(isClosedShadowHiddenUsingSpecDefinition(otherNode, *this));
1164     return true;
1165 }
1166 
1167 static inline ShadowRoot* parentShadowRoot(const Node&amp; node)
1168 {
1169     if (auto* parent = node.parentElement())
1170         return parent-&gt;shadowRoot();
1171     return nullptr;
1172 }
1173 
1174 HTMLSlotElement* Node::assignedSlot() const
1175 {
1176     if (auto* shadowRoot = parentShadowRoot(*this))
1177         return shadowRoot-&gt;findAssignedSlot(*this);
1178     return nullptr;
1179 }
1180 
1181 HTMLSlotElement* Node::assignedSlotForBindings() const
1182 {
1183     auto* shadowRoot = parentShadowRoot(*this);
1184     if (shadowRoot &amp;&amp; shadowRoot-&gt;mode() == ShadowRootMode::Open)
1185         return shadowRoot-&gt;findAssignedSlot(*this);
1186     return nullptr;
1187 }
1188 
1189 ContainerNode* Node::parentInComposedTree() const
1190 {
1191     ASSERT(isMainThreadOrGCThread());
1192     if (auto* slot = assignedSlot())
1193         return slot;
1194     if (is&lt;ShadowRoot&gt;(*this))
1195         return downcast&lt;ShadowRoot&gt;(*this).host();
1196     return parentNode();
1197 }
1198 
1199 Element* Node::parentElementInComposedTree() const
1200 {
1201     if (auto* slot = assignedSlot())
1202         return slot;
1203     if (is&lt;PseudoElement&gt;(*this))
1204         return downcast&lt;PseudoElement&gt;(*this).hostElement();
1205     if (auto* parent = parentNode()) {
1206         if (is&lt;ShadowRoot&gt;(*parent))
1207             return downcast&lt;ShadowRoot&gt;(*parent).host();
1208         if (is&lt;Element&gt;(*parent))
1209             return downcast&lt;Element&gt;(parent);
1210     }
1211     return nullptr;
1212 }
1213 
1214 bool Node::isInUserAgentShadowTree() const
1215 {
1216     auto* shadowRoot = containingShadowRoot();
1217     return shadowRoot &amp;&amp; shadowRoot-&gt;mode() == ShadowRootMode::UserAgent;
1218 }
1219 
1220 Node* Node::nonBoundaryShadowTreeRootNode()
1221 {
1222     ASSERT(!isShadowRoot());
1223     Node* root = this;
1224     while (root) {
1225         if (root-&gt;isShadowRoot())
1226             return root;
1227         Node* parent = root-&gt;parentNodeGuaranteedHostFree();
1228         if (parent &amp;&amp; parent-&gt;isShadowRoot())
1229             return root;
1230         root = parent;
1231     }
1232     return 0;
1233 }
1234 
1235 ContainerNode* Node::nonShadowBoundaryParentNode() const
1236 {
1237     ContainerNode* parent = parentNode();
1238     return parent &amp;&amp; !parent-&gt;isShadowRoot() ? parent : nullptr;
1239 }
1240 
1241 Element* Node::parentOrShadowHostElement() const
1242 {
1243     ContainerNode* parent = parentOrShadowHostNode();
1244     if (!parent)
1245         return nullptr;
1246 
1247     if (is&lt;ShadowRoot&gt;(*parent))
1248         return downcast&lt;ShadowRoot&gt;(*parent).host();
1249 
1250     if (!is&lt;Element&gt;(*parent))
1251         return nullptr;
1252 
1253     return downcast&lt;Element&gt;(parent);
1254 }
1255 
1256 Node&amp; Node::traverseToRootNode() const
1257 {
1258     Node* node = const_cast&lt;Node*&gt;(this);
1259     Node* highest = node;
1260     for (; node; node = node-&gt;parentNode())
1261         highest = node;
1262     return *highest;
1263 }
1264 
1265 // https://dom.spec.whatwg.org/#concept-shadow-including-root
1266 Node&amp; Node::shadowIncludingRoot() const
1267 {
1268     auto&amp; root = rootNode();
1269     if (!is&lt;ShadowRoot&gt;(root))
1270         return root;
1271     auto* host = downcast&lt;ShadowRoot&gt;(root).host();
1272     return host ? host-&gt;shadowIncludingRoot() : root;
1273 }
1274 
1275 Node&amp; Node::getRootNode(const GetRootNodeOptions&amp; options) const
1276 {
1277     return options.composed ? shadowIncludingRoot() : rootNode();
1278 }
1279 
1280 Node::InsertedIntoAncestorResult Node::insertedIntoAncestor(InsertionType insertionType, ContainerNode&amp; parentOfInsertedTree)
1281 {
1282     if (insertionType.connectedToDocument)
1283         setFlag(IsConnectedFlag);
1284     if (parentOfInsertedTree.isInShadowTree())
1285         setFlag(IsInShadowTreeFlag);
1286 
1287     invalidateStyle(Style::Validity::SubtreeAndRenderersInvalid);
1288 
1289     return InsertedIntoAncestorResult::Done;
1290 }
1291 
1292 void Node::removedFromAncestor(RemovalType removalType, ContainerNode&amp;)
1293 {
1294     if (removalType.disconnectedFromDocument)
1295         clearFlag(IsConnectedFlag);
1296     if (isInShadowTree() &amp;&amp; !treeScope().rootNode().isShadowRoot())
1297         clearFlag(IsInShadowTreeFlag);
1298 }
1299 
1300 bool Node::isRootEditableElement() const
1301 {
1302     return hasEditableStyle() &amp;&amp; isElementNode() &amp;&amp; (!parentNode() || !parentNode()-&gt;hasEditableStyle()
1303         || !parentNode()-&gt;isElementNode() || hasTagName(bodyTag));
1304 }
1305 
1306 Element* Node::rootEditableElement() const
1307 {
1308     Element* result = nullptr;
1309     for (Node* node = const_cast&lt;Node*&gt;(this); node &amp;&amp; node-&gt;hasEditableStyle(); node = node-&gt;parentNode()) {
1310         if (is&lt;Element&gt;(*node))
1311             result = downcast&lt;Element&gt;(node);
1312         if (is&lt;HTMLBodyElement&gt;(*node))
1313             break;
1314     }
1315     return result;
1316 }
1317 
1318 // FIXME: End of obviously misplaced HTML editing functions.  Try to move these out of Node.
1319 
1320 Document* Node::ownerDocument() const
1321 {
1322     Document* document = &amp;this-&gt;document();
1323     return document == this ? nullptr : document;
1324 }
1325 
1326 const URL&amp; Node::baseURI() const
1327 {
1328     auto&amp; url = document().baseURL();
1329     return url.isNull() ? WTF::blankURL() : url;
1330 }
1331 
1332 bool Node::isEqualNode(Node* other) const
1333 {
1334     if (!other)
1335         return false;
1336 
1337     NodeType nodeType = this-&gt;nodeType();
1338     if (nodeType != other-&gt;nodeType())
1339         return false;
1340 
1341     switch (nodeType) {
1342     case Node::DOCUMENT_TYPE_NODE: {
1343         auto&amp; thisDocType = downcast&lt;DocumentType&gt;(*this);
1344         auto&amp; otherDocType = downcast&lt;DocumentType&gt;(*other);
1345         if (thisDocType.name() != otherDocType.name())
1346             return false;
1347         if (thisDocType.publicId() != otherDocType.publicId())
1348             return false;
1349         if (thisDocType.systemId() != otherDocType.systemId())
1350             return false;
1351         break;
1352         }
1353     case Node::ELEMENT_NODE: {
1354         auto&amp; thisElement = downcast&lt;Element&gt;(*this);
1355         auto&amp; otherElement = downcast&lt;Element&gt;(*other);
1356         if (thisElement.tagQName() != otherElement.tagQName())
1357             return false;
1358         if (!thisElement.hasEquivalentAttributes(otherElement))
1359             return false;
1360         break;
1361         }
1362     case Node::PROCESSING_INSTRUCTION_NODE: {
1363         auto&amp; thisProcessingInstruction = downcast&lt;ProcessingInstruction&gt;(*this);
1364         auto&amp; otherProcessingInstruction = downcast&lt;ProcessingInstruction&gt;(*other);
1365         if (thisProcessingInstruction.target() != otherProcessingInstruction.target())
1366             return false;
1367         if (thisProcessingInstruction.data() != otherProcessingInstruction.data())
1368             return false;
1369         break;
1370         }
1371     case Node::CDATA_SECTION_NODE:
1372     case Node::TEXT_NODE:
1373     case Node::COMMENT_NODE: {
1374         auto&amp; thisCharacterData = downcast&lt;CharacterData&gt;(*this);
1375         auto&amp; otherCharacterData = downcast&lt;CharacterData&gt;(*other);
1376         if (thisCharacterData.data() != otherCharacterData.data())
1377             return false;
1378         break;
1379         }
1380     case Node::ATTRIBUTE_NODE: {
1381         auto&amp; thisAttribute = downcast&lt;Attr&gt;(*this);
1382         auto&amp; otherAttribute = downcast&lt;Attr&gt;(*other);
1383         if (thisAttribute.qualifiedName() != otherAttribute.qualifiedName())
1384             return false;
1385         if (thisAttribute.value() != otherAttribute.value())
1386             return false;
1387         break;
1388         }
1389     case Node::DOCUMENT_NODE:
1390     case Node::DOCUMENT_FRAGMENT_NODE:
1391         break;
1392     }
1393 
1394     Node* child = firstChild();
1395     Node* otherChild = other-&gt;firstChild();
1396 
1397     while (child) {
1398         if (!child-&gt;isEqualNode(otherChild))
1399             return false;
1400 
1401         child = child-&gt;nextSibling();
1402         otherChild = otherChild-&gt;nextSibling();
1403     }
1404 
1405     if (otherChild)
1406         return false;
1407 
1408     return true;
1409 }
1410 
1411 // https://dom.spec.whatwg.org/#locate-a-namespace
1412 static const AtomString&amp; locateDefaultNamespace(const Node&amp; node, const AtomString&amp; prefix)
1413 {
1414     switch (node.nodeType()) {
1415     case Node::ELEMENT_NODE: {
1416         auto&amp; element = downcast&lt;Element&gt;(node);
1417         auto&amp; namespaceURI = element.namespaceURI();
1418         if (!namespaceURI.isNull() &amp;&amp; element.prefix() == prefix)
1419             return namespaceURI;
1420 
1421         if (element.hasAttributes()) {
1422             for (auto&amp; attribute : element.attributesIterator()) {
1423                 if (attribute.namespaceURI() != XMLNSNames::xmlnsNamespaceURI)
1424                     continue;
1425 
1426                 if ((prefix.isNull() &amp;&amp; attribute.prefix().isNull() &amp;&amp; attribute.localName() == xmlnsAtom()) || (attribute.prefix() == xmlnsAtom() &amp;&amp; attribute.localName() == prefix)) {
1427                     auto&amp; result = attribute.value();
1428                     return result.isEmpty() ? nullAtom() : result;
1429                 }
1430             }
1431         }
1432         auto* parent = node.parentElement();
1433         return parent ? locateDefaultNamespace(*parent, prefix) : nullAtom();
1434     }
1435     case Node::DOCUMENT_NODE:
1436         if (auto* documentElement = downcast&lt;Document&gt;(node).documentElement())
1437             return locateDefaultNamespace(*documentElement, prefix);
1438         return nullAtom();
1439     case Node::DOCUMENT_TYPE_NODE:
1440     case Node::DOCUMENT_FRAGMENT_NODE:
1441         return nullAtom();
1442     case Node::ATTRIBUTE_NODE:
1443         if (auto* ownerElement = downcast&lt;Attr&gt;(node).ownerElement())
1444             return locateDefaultNamespace(*ownerElement, prefix);
1445         return nullAtom();
1446     default:
1447         if (auto* parent = node.parentElement())
1448             return locateDefaultNamespace(*parent, prefix);
1449         return nullAtom();
1450     }
1451 }
1452 
1453 // https://dom.spec.whatwg.org/#dom-node-isdefaultnamespace
1454 bool Node::isDefaultNamespace(const AtomString&amp; potentiallyEmptyNamespace) const
1455 {
1456     const AtomString&amp; namespaceURI = potentiallyEmptyNamespace.isEmpty() ? nullAtom() : potentiallyEmptyNamespace;
1457     return locateDefaultNamespace(*this, nullAtom()) == namespaceURI;
1458 }
1459 
1460 // https://dom.spec.whatwg.org/#dom-node-lookupnamespaceuri
1461 const AtomString&amp; Node::lookupNamespaceURI(const AtomString&amp; potentiallyEmptyPrefix) const
1462 {
1463     const AtomString&amp; prefix = potentiallyEmptyPrefix.isEmpty() ? nullAtom() : potentiallyEmptyPrefix;
1464     return locateDefaultNamespace(*this, prefix);
1465 }
1466 
1467 // https://dom.spec.whatwg.org/#locate-a-namespace-prefix
1468 static const AtomString&amp; locateNamespacePrefix(const Element&amp; element, const AtomString&amp; namespaceURI)
1469 {
1470     if (element.namespaceURI() == namespaceURI)
1471         return element.prefix();
1472 
1473     if (element.hasAttributes()) {
1474         for (auto&amp; attribute : element.attributesIterator()) {
1475             if (attribute.prefix() == xmlnsAtom() &amp;&amp; attribute.value() == namespaceURI)
1476                 return attribute.localName();
1477         }
1478     }
1479     auto* parent = element.parentElement();
1480     return parent ? locateNamespacePrefix(*parent, namespaceURI) : nullAtom();
1481 }
1482 
1483 // https://dom.spec.whatwg.org/#dom-node-lookupprefix
1484 const AtomString&amp; Node::lookupPrefix(const AtomString&amp; namespaceURI) const
1485 {
1486     if (namespaceURI.isEmpty())
1487         return nullAtom();
1488 
1489     switch (nodeType()) {
1490     case ELEMENT_NODE:
1491         return locateNamespacePrefix(downcast&lt;Element&gt;(*this), namespaceURI);
1492     case DOCUMENT_NODE:
1493         if (auto* documentElement = downcast&lt;Document&gt;(*this).documentElement())
1494             return locateNamespacePrefix(*documentElement, namespaceURI);
1495         return nullAtom();
1496     case DOCUMENT_FRAGMENT_NODE:
1497     case DOCUMENT_TYPE_NODE:
1498         return nullAtom();
1499     case ATTRIBUTE_NODE:
1500         if (auto* ownerElement = downcast&lt;Attr&gt;(*this).ownerElement())
1501             return locateNamespacePrefix(*ownerElement, namespaceURI);
1502         return nullAtom();
1503     default:
1504         if (auto* parent = parentElement())
1505             return locateNamespacePrefix(*parent, namespaceURI);
1506         return nullAtom();
1507     }
1508 }
1509 
1510 static void appendTextContent(const Node* node, bool convertBRsToNewlines, bool&amp; isNullString, StringBuilder&amp; content)
1511 {
1512     switch (node-&gt;nodeType()) {
1513     case Node::TEXT_NODE:
1514     case Node::CDATA_SECTION_NODE:
1515     case Node::COMMENT_NODE:
1516         isNullString = false;
1517         content.append(downcast&lt;CharacterData&gt;(*node).data());
1518         break;
1519 
1520     case Node::PROCESSING_INSTRUCTION_NODE:
1521         isNullString = false;
1522         content.append(downcast&lt;ProcessingInstruction&gt;(*node).data());
1523         break;
1524 
1525     case Node::ATTRIBUTE_NODE:
1526         isNullString = false;
1527         content.append(downcast&lt;Attr&gt;(*node).value());
1528         break;
1529 
1530     case Node::ELEMENT_NODE:
1531         if (node-&gt;hasTagName(brTag) &amp;&amp; convertBRsToNewlines) {
1532             isNullString = false;
1533             content.append(&#39;\n&#39;);
1534             break;
1535         }
1536         FALLTHROUGH;
1537     case Node::DOCUMENT_FRAGMENT_NODE:
1538         isNullString = false;
1539         for (Node* child = node-&gt;firstChild(); child; child = child-&gt;nextSibling()) {
1540             if (child-&gt;nodeType() == Node::COMMENT_NODE || child-&gt;nodeType() == Node::PROCESSING_INSTRUCTION_NODE)
1541                 continue;
1542             appendTextContent(child, convertBRsToNewlines, isNullString, content);
1543         }
1544         break;
1545 
1546     case Node::DOCUMENT_NODE:
1547     case Node::DOCUMENT_TYPE_NODE:
1548         break;
1549     }
1550 }
1551 
1552 String Node::textContent(bool convertBRsToNewlines) const
1553 {
1554     StringBuilder content;
1555     bool isNullString = true;
1556     appendTextContent(this, convertBRsToNewlines, isNullString, content);
1557     return isNullString ? String() : content.toString();
1558 }
1559 
1560 ExceptionOr&lt;void&gt; Node::setTextContent(const String&amp; text)
1561 {
1562     switch (nodeType()) {
1563     case ATTRIBUTE_NODE:
1564     case TEXT_NODE:
1565     case CDATA_SECTION_NODE:
1566     case COMMENT_NODE:
1567     case PROCESSING_INSTRUCTION_NODE:
1568         return setNodeValue(text);
1569     case ELEMENT_NODE:
1570     case DOCUMENT_FRAGMENT_NODE: {
1571         auto&amp; container = downcast&lt;ContainerNode&gt;(*this);
1572         if (text.isEmpty())
1573             container.replaceAllChildren(nullptr);
1574         else
1575             container.replaceAllChildren(document().createTextNode(text));
1576         return { };
1577     }
1578     case DOCUMENT_NODE:
1579     case DOCUMENT_TYPE_NODE:
1580         // Do nothing.
1581         return { };
1582     }
1583     ASSERT_NOT_REACHED();
1584     return { };
1585 }
1586 
1587 static SHA1::Digest hashPointer(void* pointer)
1588 {
1589     SHA1 sha1;
1590     sha1.addBytes(reinterpret_cast&lt;const uint8_t*&gt;(&amp;pointer), sizeof(pointer));
1591     SHA1::Digest digest;
1592     sha1.computeHash(digest);
1593     return digest;
1594 }
1595 
1596 static inline unsigned short compareDetachedElementsPosition(Node&amp; firstNode, Node&amp; secondNode)
1597 {
1598     // If the 2 nodes are not in the same tree, return the result of adding DOCUMENT_POSITION_DISCONNECTED,
1599     // DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC, and either DOCUMENT_POSITION_PRECEDING or
1600     // DOCUMENT_POSITION_FOLLOWING, with the constraint that this is to be consistent. Whether to return
1601     // DOCUMENT_POSITION_PRECEDING or DOCUMENT_POSITION_FOLLOWING is implemented by comparing cryptographic
1602     // hashes of Node pointers.
1603     // See step 3 in https://dom.spec.whatwg.org/#dom-node-comparedocumentposition
1604     SHA1::Digest firstHash = hashPointer(&amp;firstNode);
1605     SHA1::Digest secondHash = hashPointer(&amp;secondNode);
1606 
1607     unsigned short direction = memcmp(firstHash.data(), secondHash.data(), SHA1::hashSize) &gt; 0 ? Node::DOCUMENT_POSITION_PRECEDING : Node::DOCUMENT_POSITION_FOLLOWING;
1608 
1609     return Node::DOCUMENT_POSITION_DISCONNECTED | Node::DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC | direction;
1610 }
1611 
1612 unsigned short Node::compareDocumentPosition(Node&amp; otherNode)
1613 {
1614     if (&amp;otherNode == this)
1615         return DOCUMENT_POSITION_EQUIVALENT;
1616 
1617     Attr* attr1 = is&lt;Attr&gt;(*this) ? downcast&lt;Attr&gt;(this) : nullptr;
1618     Attr* attr2 = is&lt;Attr&gt;(otherNode) ? &amp;downcast&lt;Attr&gt;(otherNode) : nullptr;
1619 
1620     Node* start1 = attr1 ? attr1-&gt;ownerElement() : this;
1621     Node* start2 = attr2 ? attr2-&gt;ownerElement() : &amp;otherNode;
1622 
1623     // If either of start1 or start2 is null, then we are disconnected, since one of the nodes is
1624     // an orphaned attribute node.
1625     if (!start1 || !start2)
1626         return compareDetachedElementsPosition(*this, otherNode);
1627 
1628     Vector&lt;Node*, 16&gt; chain1;
1629     Vector&lt;Node*, 16&gt; chain2;
1630     if (attr1)
1631         chain1.append(attr1);
1632     if (attr2)
1633         chain2.append(attr2);
1634 
1635     if (attr1 &amp;&amp; attr2 &amp;&amp; start1 == start2 &amp;&amp; start1) {
1636         // We are comparing two attributes on the same node. Crawl our attribute map and see which one we hit first.
1637         Element* owner1 = attr1-&gt;ownerElement();
1638         owner1-&gt;synchronizeAllAttributes();
1639         for (const Attribute&amp; attribute : owner1-&gt;attributesIterator()) {
1640             // If neither of the two determining nodes is a child node and nodeType is the same for both determining nodes, then an
1641             // implementation-dependent order between the determining nodes is returned. This order is stable as long as no nodes of
1642             // the same nodeType are inserted into or removed from the direct container. This would be the case, for example,
1643             // when comparing two attributes of the same element, and inserting or removing additional attributes might change
1644             // the order between existing attributes.
1645             if (attr1-&gt;qualifiedName() == attribute.name())
1646                 return DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC | DOCUMENT_POSITION_FOLLOWING;
1647             if (attr2-&gt;qualifiedName() == attribute.name())
1648                 return DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC | DOCUMENT_POSITION_PRECEDING;
1649         }
1650 
1651         ASSERT_NOT_REACHED();
1652         return DOCUMENT_POSITION_DISCONNECTED;
1653     }
1654 
1655     // If one node is in the document and the other is not, we must be disconnected.
1656     // If the nodes have different owning documents, they must be disconnected.  Note that we avoid
1657     // comparing Attr nodes here, since they return false from isConnected() all the time (which seems like a bug).
1658     if (start1-&gt;isConnected() != start2-&gt;isConnected() || &amp;start1-&gt;treeScope() != &amp;start2-&gt;treeScope())
1659         return compareDetachedElementsPosition(*this, otherNode);
1660 
1661     // We need to find a common ancestor container, and then compare the indices of the two immediate children.
1662     Node* current;
1663     for (current = start1; current; current = current-&gt;parentNode())
1664         chain1.append(current);
1665     for (current = start2; current; current = current-&gt;parentNode())
1666         chain2.append(current);
1667 
1668     unsigned index1 = chain1.size();
1669     unsigned index2 = chain2.size();
1670 
1671     // If the two elements don&#39;t have a common root, they&#39;re not in the same tree.
1672     if (chain1[index1 - 1] != chain2[index2 - 1])
1673         return compareDetachedElementsPosition(*this, otherNode);
1674 
1675     // Walk the two chains backwards and look for the first difference.
1676     for (unsigned i = std::min(index1, index2); i; --i) {
1677         Node* child1 = chain1[--index1];
1678         Node* child2 = chain2[--index2];
1679         if (child1 != child2) {
1680             // If one of the children is an attribute, it wins.
1681             if (child1-&gt;nodeType() == ATTRIBUTE_NODE)
1682                 return DOCUMENT_POSITION_FOLLOWING;
1683             if (child2-&gt;nodeType() == ATTRIBUTE_NODE)
1684                 return DOCUMENT_POSITION_PRECEDING;
1685 
1686             if (!child2-&gt;nextSibling())
1687                 return DOCUMENT_POSITION_FOLLOWING;
1688             if (!child1-&gt;nextSibling())
1689                 return DOCUMENT_POSITION_PRECEDING;
1690 
1691             // Otherwise we need to see which node occurs first.  Crawl backwards from child2 looking for child1.
1692             for (Node* child = child2-&gt;previousSibling(); child; child = child-&gt;previousSibling()) {
1693                 if (child == child1)
1694                     return DOCUMENT_POSITION_FOLLOWING;
1695             }
1696             return DOCUMENT_POSITION_PRECEDING;
1697         }
1698     }
1699 
1700     // There was no difference between the two parent chains, i.e., one was a subset of the other.  The shorter
1701     // chain is the ancestor.
1702     return index1 &lt; index2 ?
1703                DOCUMENT_POSITION_FOLLOWING | DOCUMENT_POSITION_CONTAINED_BY :
1704                DOCUMENT_POSITION_PRECEDING | DOCUMENT_POSITION_CONTAINS;
1705 }
1706 
1707 FloatPoint Node::convertToPage(const FloatPoint&amp; p) const
1708 {
1709     // If there is a renderer, just ask it to do the conversion
1710     if (renderer())
1711         return renderer()-&gt;localToAbsolute(p, UseTransforms);
1712 
1713     // Otherwise go up the tree looking for a renderer
1714     if (auto* parent = parentElement())
1715         return parent-&gt;convertToPage(p);
1716 
1717     // No parent - no conversion needed
1718     return p;
1719 }
1720 
1721 FloatPoint Node::convertFromPage(const FloatPoint&amp; p) const
1722 {
1723     // If there is a renderer, just ask it to do the conversion
1724     if (renderer())
1725         return renderer()-&gt;absoluteToLocal(p, UseTransforms);
1726 
1727     // Otherwise go up the tree looking for a renderer
1728     if (auto* parent = parentElement())
1729         return parent-&gt;convertFromPage(p);
1730 
1731     // No parent - no conversion needed
1732     return p;
1733 }
1734 
1735 #if ENABLE(TREE_DEBUGGING)
1736 
1737 static void appendAttributeDesc(const Node* node, StringBuilder&amp; stringBuilder, const QualifiedName&amp; name, const char* attrDesc)
1738 {
1739     if (!is&lt;Element&gt;(*node))
1740         return;
1741 
1742     const AtomString&amp; attr = downcast&lt;Element&gt;(*node).getAttribute(name);
1743     if (attr.isEmpty())
1744         return;
1745 
1746     stringBuilder.append(attrDesc);
1747     stringBuilder.append(attr);
1748 }
1749 
1750 void Node::showNode(const char* prefix) const
1751 {
1752     if (!prefix)
1753         prefix = &quot;&quot;;
1754     if (isTextNode()) {
1755         String value = nodeValue();
1756         value.replaceWithLiteral(&#39;\\&#39;, &quot;\\\\&quot;);
1757         value.replaceWithLiteral(&#39;\n&#39;, &quot;\\n&quot;);
1758         fprintf(stderr, &quot;%s%s\t%p \&quot;%s\&quot;\n&quot;, prefix, nodeName().utf8().data(), this, value.utf8().data());
1759     } else {
1760         StringBuilder attrs;
1761         appendAttributeDesc(this, attrs, classAttr, &quot; CLASS=&quot;);
1762         appendAttributeDesc(this, attrs, styleAttr, &quot; STYLE=&quot;);
1763         fprintf(stderr, &quot;%s%s\t%p (renderer %p) %s%s%s\n&quot;, prefix, nodeName().utf8().data(), this, renderer(), attrs.toString().utf8().data(), needsStyleRecalc() ? &quot; (needs style recalc)&quot; : &quot;&quot;, childNeedsStyleRecalc() ? &quot; (child needs style recalc)&quot; : &quot;&quot;);
1764     }
1765 }
1766 
1767 void Node::showTreeForThis() const
1768 {
1769     showTreeAndMark(this, &quot;*&quot;);
1770 }
1771 
1772 void Node::showNodePathForThis() const
1773 {
1774     Vector&lt;const Node*, 16&gt; chain;
1775     const Node* node = this;
1776     while (node-&gt;parentOrShadowHostNode()) {
1777         chain.append(node);
1778         node = node-&gt;parentOrShadowHostNode();
1779     }
1780     for (unsigned index = chain.size(); index &gt; 0; --index) {
1781         const Node* node = chain[index - 1];
1782         if (is&lt;ShadowRoot&gt;(*node)) {
1783             int count = 0;
1784             for (const ShadowRoot* shadowRoot = downcast&lt;ShadowRoot&gt;(node); shadowRoot &amp;&amp; shadowRoot != node; shadowRoot = shadowRoot-&gt;shadowRoot())
1785                 ++count;
1786             fprintf(stderr, &quot;/#shadow-root[%d]&quot;, count);
1787             continue;
1788         }
1789 
1790         switch (node-&gt;nodeType()) {
1791         case ELEMENT_NODE: {
1792             fprintf(stderr, &quot;/%s&quot;, node-&gt;nodeName().utf8().data());
1793 
1794             const Element&amp; element = downcast&lt;Element&gt;(*node);
1795             const AtomString&amp; idattr = element.getIdAttribute();
1796             bool hasIdAttr = !idattr.isNull() &amp;&amp; !idattr.isEmpty();
1797             if (node-&gt;previousSibling() || node-&gt;nextSibling()) {
1798                 int count = 0;
1799                 for (Node* previous = node-&gt;previousSibling(); previous; previous = previous-&gt;previousSibling())
1800                     if (previous-&gt;nodeName() == node-&gt;nodeName())
1801                         ++count;
1802                 if (hasIdAttr)
1803                     fprintf(stderr, &quot;[@id=\&quot;%s\&quot; and position()=%d]&quot;, idattr.string().utf8().data(), count);
1804                 else
1805                     fprintf(stderr, &quot;[%d]&quot;, count);
1806             } else if (hasIdAttr)
1807                 fprintf(stderr, &quot;[@id=\&quot;%s\&quot;]&quot;, idattr.string().utf8().data());
1808             break;
1809         }
1810         case TEXT_NODE:
1811             fprintf(stderr, &quot;/text()&quot;);
1812             break;
1813         case ATTRIBUTE_NODE:
1814             fprintf(stderr, &quot;/@%s&quot;, node-&gt;nodeName().utf8().data());
1815             break;
1816         default:
1817             break;
1818         }
1819     }
1820     fprintf(stderr, &quot;\n&quot;);
1821 }
1822 
1823 static void traverseTreeAndMark(const String&amp; baseIndent, const Node* rootNode, const Node* markedNode1, const char* markedLabel1, const Node* markedNode2, const char* markedLabel2)
1824 {
1825     for (const Node* node = rootNode; node; node = NodeTraversal::next(*node)) {
1826         if (node == markedNode1)
1827             fprintf(stderr, &quot;%s&quot;, markedLabel1);
1828         if (node == markedNode2)
1829             fprintf(stderr, &quot;%s&quot;, markedLabel2);
1830 
1831         StringBuilder indent;
1832         indent.append(baseIndent);
1833         for (const Node* tmpNode = node; tmpNode &amp;&amp; tmpNode != rootNode; tmpNode = tmpNode-&gt;parentOrShadowHostNode())
1834             indent.append(&#39;\t&#39;);
1835         fprintf(stderr, &quot;%s&quot;, indent.toString().utf8().data());
1836         node-&gt;showNode();
1837         indent.append(&#39;\t&#39;);
1838         if (!node-&gt;isShadowRoot()) {
1839             if (ShadowRoot* shadowRoot = node-&gt;shadowRoot())
1840                 traverseTreeAndMark(indent.toString(), shadowRoot, markedNode1, markedLabel1, markedNode2, markedLabel2);
1841         }
1842     }
1843 }
1844 
1845 void Node::showTreeAndMark(const Node* markedNode1, const char* markedLabel1, const Node* markedNode2, const char* markedLabel2) const
1846 {
1847     const Node* rootNode;
1848     const Node* node = this;
1849     while (node-&gt;parentOrShadowHostNode() &amp;&amp; !node-&gt;hasTagName(bodyTag))
1850         node = node-&gt;parentOrShadowHostNode();
1851     rootNode = node;
1852 
1853     String startingIndent;
1854     traverseTreeAndMark(startingIndent, rootNode, markedNode1, markedLabel1, markedNode2, markedLabel2);
1855 }
1856 
1857 void Node::formatForDebugger(char* buffer, unsigned length) const
1858 {
1859     String result;
1860     String s;
1861 
1862     s = nodeName();
1863     if (s.isEmpty())
1864         result = &quot;&lt;none&gt;&quot;;
1865     else
1866         result = s;
1867 
1868     strncpy(buffer, result.utf8().data(), length - 1);
1869 }
1870 
1871 static ContainerNode* parentOrShadowHostOrFrameOwner(const Node* node)
1872 {
1873     ContainerNode* parent = node-&gt;parentOrShadowHostNode();
1874     if (!parent &amp;&amp; node-&gt;document().frame())
1875         parent = node-&gt;document().frame()-&gt;ownerElement();
1876     return parent;
1877 }
1878 
1879 static void showSubTreeAcrossFrame(const Node* node, const Node* markedNode, const String&amp; indent)
1880 {
1881     if (node == markedNode)
1882         fputs(&quot;*&quot;, stderr);
1883     fputs(indent.utf8().data(), stderr);
1884     node-&gt;showNode();
1885     if (!node-&gt;isShadowRoot()) {
1886         if (node-&gt;isFrameOwnerElement())
1887             showSubTreeAcrossFrame(static_cast&lt;const HTMLFrameOwnerElement*&gt;(node)-&gt;contentDocument(), markedNode, indent + &quot;\t&quot;);
1888         if (ShadowRoot* shadowRoot = node-&gt;shadowRoot())
1889             showSubTreeAcrossFrame(shadowRoot, markedNode, indent + &quot;\t&quot;);
1890     }
1891     for (Node* child = node-&gt;firstChild(); child; child = child-&gt;nextSibling())
1892         showSubTreeAcrossFrame(child, markedNode, indent + &quot;\t&quot;);
1893 }
1894 
1895 void Node::showTreeForThisAcrossFrame() const
1896 {
1897     Node* rootNode = const_cast&lt;Node*&gt;(this);
1898     while (parentOrShadowHostOrFrameOwner(rootNode))
1899         rootNode = parentOrShadowHostOrFrameOwner(rootNode);
1900     showSubTreeAcrossFrame(rootNode, this, &quot;&quot;);
1901 }
1902 
1903 #endif // ENABLE(TREE_DEBUGGING)
1904 
1905 // --------
1906 
1907 void NodeListsNodeData::invalidateCaches()
1908 {
1909     for (auto&amp; atomicName : m_atomicNameCaches)
1910         atomicName.value-&gt;invalidateCache();
1911 
1912     for (auto&amp; collection : m_cachedCollections)
1913         collection.value-&gt;invalidateCache();
1914 
1915     for (auto&amp; tagCollection : m_tagCollectionNSCache)
1916         tagCollection.value-&gt;invalidateCache();
1917 }
1918 
1919 void NodeListsNodeData::invalidateCachesForAttribute(const QualifiedName&amp; attrName)
1920 {
1921     for (auto&amp; atomicName : m_atomicNameCaches)
1922         atomicName.value-&gt;invalidateCacheForAttribute(attrName);
1923 
1924     for (auto&amp; collection : m_cachedCollections)
1925         collection.value-&gt;invalidateCacheForAttribute(attrName);
1926 }
1927 
1928 void Node::getSubresourceURLs(ListHashSet&lt;URL&gt;&amp; urls) const
1929 {
1930     addSubresourceAttributeURLs(urls);
1931 }
1932 
1933 Element* Node::enclosingLinkEventParentOrSelf()
1934 {
1935     for (Node* node = this; node; node = node-&gt;parentInComposedTree()) {
1936         // For imagemaps, the enclosing link element is the associated area element not the image itself.
1937         // So we don&#39;t let images be the enclosing link element, even though isLink sometimes returns
1938         // true for them.
1939         if (node-&gt;isLink() &amp;&amp; !is&lt;HTMLImageElement&gt;(*node))
1940             return downcast&lt;Element&gt;(node);
1941     }
1942 
1943     return nullptr;
1944 }
1945 
1946 EventTargetInterface Node::eventTargetInterface() const
1947 {
1948     return NodeEventTargetInterfaceType;
1949 }
1950 
1951 template &lt;typename MoveNodeFunction, typename MoveShadowRootFunction&gt;
1952 static void traverseSubtreeToUpdateTreeScope(Node&amp; root, MoveNodeFunction moveNode, MoveShadowRootFunction moveShadowRoot)
1953 {
1954     for (Node* node = &amp;root; node; node = NodeTraversal::next(*node, &amp;root)) {
1955         moveNode(*node);
1956 
1957         if (!is&lt;Element&gt;(*node))
1958             continue;
1959         Element&amp; element = downcast&lt;Element&gt;(*node);
1960 
1961         if (element.hasSyntheticAttrChildNodes()) {
1962             for (auto&amp; attr : element.attrNodeList())
1963                 moveNode(*attr);
1964         }
1965 
1966         if (auto* shadow = element.shadowRoot())
1967             moveShadowRoot(*shadow);
1968     }
1969 }
1970 
1971 inline void Node::moveShadowTreeToNewDocument(ShadowRoot&amp; shadowRoot, Document&amp; oldDocument, Document&amp; newDocument)
1972 {
1973     traverseSubtreeToUpdateTreeScope(shadowRoot, [&amp;oldDocument, &amp;newDocument](Node&amp; node) {
1974         node.moveNodeToNewDocument(oldDocument, newDocument);
1975     }, [&amp;oldDocument, &amp;newDocument](ShadowRoot&amp; innerShadowRoot) {
1976         RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(&amp;innerShadowRoot.document() == &amp;oldDocument);
1977         innerShadowRoot.moveShadowRootToNewDocument(newDocument);
1978         moveShadowTreeToNewDocument(innerShadowRoot, oldDocument, newDocument);
1979     });
1980 }
1981 
1982 void Node::moveTreeToNewScope(Node&amp; root, TreeScope&amp; oldScope, TreeScope&amp; newScope)
1983 {
1984     ASSERT(&amp;oldScope != &amp;newScope);
1985 
1986     Document&amp; oldDocument = oldScope.documentScope();
1987     Document&amp; newDocument = newScope.documentScope();
1988     if (&amp;oldDocument != &amp;newDocument) {
1989         oldDocument.incrementReferencingNodeCount();
1990         traverseSubtreeToUpdateTreeScope(root, [&amp;](Node&amp; node) {
1991             ASSERT(!node.isTreeScope());
1992             RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(&amp;node.treeScope() == &amp;oldScope);
1993             node.setTreeScope(newScope);
1994             node.moveNodeToNewDocument(oldDocument, newDocument);
1995         }, [&amp;](ShadowRoot&amp; shadowRoot) {
1996             ASSERT_WITH_SECURITY_IMPLICATION(&amp;shadowRoot.document() == &amp;oldDocument);
1997             shadowRoot.moveShadowRootToNewParentScope(newScope, newDocument);
1998             moveShadowTreeToNewDocument(shadowRoot, oldDocument, newDocument);
1999         });
2000         RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(&amp;oldScope.documentScope() == &amp;oldDocument &amp;&amp; &amp;newScope.documentScope() == &amp;newDocument);
2001         oldDocument.decrementReferencingNodeCount();
2002     } else {
2003         traverseSubtreeToUpdateTreeScope(root, [&amp;](Node&amp; node) {
2004             ASSERT(!node.isTreeScope());
2005             RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(&amp;node.treeScope() == &amp;oldScope);
2006             node.setTreeScope(newScope);
2007             if (UNLIKELY(!node.hasRareData()))
2008                 return;
2009             if (auto* nodeLists = node.rareData()-&gt;nodeLists())
2010                 nodeLists-&gt;adoptTreeScope();
2011         }, [&amp;newScope](ShadowRoot&amp; shadowRoot) {
2012             shadowRoot.setParentTreeScope(newScope);
2013         });
2014     }
2015 }
2016 
2017 void Node::moveNodeToNewDocument(Document&amp; oldDocument, Document&amp; newDocument)
2018 {
2019     newDocument.incrementReferencingNodeCount();
2020     oldDocument.decrementReferencingNodeCount();
2021 
2022     if (hasRareData()) {
2023         if (auto* nodeLists = rareData()-&gt;nodeLists())
2024             nodeLists-&gt;adoptDocument(oldDocument, newDocument);
2025         if (auto* registry = mutationObserverRegistry()) {
2026             for (auto&amp; registration : *registry)
2027                 newDocument.addMutationObserverTypes(registration-&gt;mutationTypes());
2028         }
2029         if (auto* transientRegistry = transientMutationObserverRegistry()) {
2030             for (auto&amp; registration : *transientRegistry)
2031                 newDocument.addMutationObserverTypes(registration-&gt;mutationTypes());
2032         }
2033     } else {
2034         ASSERT(!mutationObserverRegistry());
2035         ASSERT(!transientMutationObserverRegistry());
2036     }
2037 
2038     oldDocument.moveNodeIteratorsToNewDocument(*this, newDocument);
2039 
2040     if (AXObjectCache::accessibilityEnabled()) {
2041         if (auto* cache = oldDocument.existingAXObjectCache())
2042             cache-&gt;remove(*this);
2043     }
2044 
2045     if (auto* eventTargetData = this-&gt;eventTargetData()) {
2046         if (!eventTargetData-&gt;eventListenerMap.isEmpty()) {
2047             for (auto&amp; type : eventTargetData-&gt;eventListenerMap.eventTypes())
2048                 newDocument.addListenerTypeIfNeeded(type);
2049         }
2050 
2051         unsigned numWheelEventHandlers = eventListeners(eventNames().mousewheelEvent).size() + eventListeners(eventNames().wheelEvent).size();
2052         for (unsigned i = 0; i &lt; numWheelEventHandlers; ++i) {
2053             oldDocument.didRemoveWheelEventHandler(*this);
2054             newDocument.didAddWheelEventHandler(*this);
2055         }
2056 
2057         unsigned numTouchEventListeners = 0;
2058 #if ENABLE(TOUCH_EVENTS)
2059         if (newDocument.quirks().shouldDispatchSimulatedMouseEvents()) {
2060             for (auto&amp; name : eventNames().extendedTouchRelatedEventNames())
2061                 numTouchEventListeners += eventListeners(name).size();
2062         } else {
2063 #endif
2064             for (auto&amp; name : eventNames().touchRelatedEventNames())
2065                 numTouchEventListeners += eventListeners(name).size();
2066 #if ENABLE(TOUCH_EVENTS)
2067         }
2068 #endif
2069 
2070         for (unsigned i = 0; i &lt; numTouchEventListeners; ++i) {
2071             oldDocument.didRemoveTouchEventHandler(*this);
2072             newDocument.didAddTouchEventHandler(*this);
2073 #if ENABLE(TOUCH_EVENTS) &amp;&amp; PLATFORM(IOS_FAMILY)
2074             oldDocument.removeTouchEventListener(*this);
2075             newDocument.addTouchEventListener(*this);
2076 #endif
2077         }
2078 
2079 #if ENABLE(TOUCH_EVENTS) &amp;&amp; ENABLE(IOS_GESTURE_EVENTS)
2080         unsigned numGestureEventListeners = 0;
2081         for (auto&amp; name : eventNames().gestureEventNames())
2082             numGestureEventListeners += eventListeners(name).size();
2083 
2084         for (unsigned i = 0; i &lt; numGestureEventListeners; ++i) {
2085             oldDocument.removeTouchEventHandler(*this);
2086             newDocument.addTouchEventHandler(*this);
2087         }
2088 #endif
2089     }
2090 
2091 #if !ASSERT_DISABLED || ENABLE(SECURITY_ASSERTIONS)
2092 #if ENABLE(TOUCH_EVENTS) &amp;&amp; PLATFORM(IOS_FAMILY)
2093     ASSERT_WITH_SECURITY_IMPLICATION(!oldDocument.touchEventListenersContain(*this));
2094     ASSERT_WITH_SECURITY_IMPLICATION(!oldDocument.touchEventHandlersContain(*this));
2095 #endif
2096 #if ENABLE(TOUCH_EVENTS) &amp;&amp; ENABLE(IOS_GESTURE_EVENTS)
2097     ASSERT_WITH_SECURITY_IMPLICATION(!oldDocument.touchEventTargetsContain(*this));
2098 #endif
2099 #endif
2100 
2101     if (is&lt;Element&gt;(*this))
2102         downcast&lt;Element&gt;(*this).didMoveToNewDocument(oldDocument, newDocument);
2103 }
2104 
2105 static inline bool tryAddEventListener(Node* targetNode, const AtomString&amp; eventType, Ref&lt;EventListener&gt;&amp;&amp; listener, const EventTarget::AddEventListenerOptions&amp; options)
2106 {
2107     if (!targetNode-&gt;EventTarget::addEventListener(eventType, listener.copyRef(), options))
2108         return false;
2109 
2110     targetNode-&gt;document().addListenerTypeIfNeeded(eventType);
2111     if (eventNames().isWheelEventType(eventType))
2112         targetNode-&gt;document().didAddWheelEventHandler(*targetNode);
2113     else if (eventNames().isTouchRelatedEventType(targetNode-&gt;document(), eventType))
2114         targetNode-&gt;document().didAddTouchEventHandler(*targetNode);
2115 
2116 #if PLATFORM(IOS_FAMILY)
2117     if (targetNode == &amp;targetNode-&gt;document() &amp;&amp; eventType == eventNames().scrollEvent)
2118         targetNode-&gt;document().domWindow()-&gt;incrementScrollEventListenersCount();
2119 
2120 #if ENABLE(TOUCH_EVENTS)
2121     if (eventNames().isTouchRelatedEventType(targetNode-&gt;document(), eventType))
2122         targetNode-&gt;document().addTouchEventListener(*targetNode);
2123 #endif
2124 #endif // PLATFORM(IOS_FAMILY)
2125 
2126 #if ENABLE(IOS_GESTURE_EVENTS) &amp;&amp; ENABLE(TOUCH_EVENTS)
2127     if (eventNames().isGestureEventType(eventType))
2128         targetNode-&gt;document().addTouchEventHandler(*targetNode);
2129 #endif
2130 
2131     return true;
2132 }
2133 
2134 bool Node::addEventListener(const AtomString&amp; eventType, Ref&lt;EventListener&gt;&amp;&amp; listener, const AddEventListenerOptions&amp; options)
2135 {
2136     return tryAddEventListener(this, eventType, WTFMove(listener), options);
2137 }
2138 
2139 static inline bool tryRemoveEventListener(Node* targetNode, const AtomString&amp; eventType, EventListener&amp; listener, const EventTarget::ListenerOptions&amp; options)
2140 {
2141     if (!targetNode-&gt;EventTarget::removeEventListener(eventType, listener, options))
2142         return false;
2143 
2144     // FIXME: Notify Document that the listener has vanished. We need to keep track of a number of
2145     // listeners for each type, not just a bool - see https://bugs.webkit.org/show_bug.cgi?id=33861
2146     if (eventNames().isWheelEventType(eventType))
2147         targetNode-&gt;document().didRemoveWheelEventHandler(*targetNode);
2148     else if (eventNames().isTouchRelatedEventType(targetNode-&gt;document(), eventType))
2149         targetNode-&gt;document().didRemoveTouchEventHandler(*targetNode);
2150 
2151 #if PLATFORM(IOS_FAMILY)
2152     if (targetNode == &amp;targetNode-&gt;document() &amp;&amp; eventType == eventNames().scrollEvent)
2153         targetNode-&gt;document().domWindow()-&gt;decrementScrollEventListenersCount();
2154 
2155 #if ENABLE(TOUCH_EVENTS)
2156     if (eventNames().isTouchRelatedEventType(targetNode-&gt;document(), eventType))
2157         targetNode-&gt;document().removeTouchEventListener(*targetNode);
2158 #endif
2159 #endif // PLATFORM(IOS_FAMILY)
2160 
2161 #if ENABLE(IOS_GESTURE_EVENTS) &amp;&amp; ENABLE(TOUCH_EVENTS)
2162     if (eventNames().isGestureEventType(eventType))
2163         targetNode-&gt;document().removeTouchEventHandler(*targetNode);
2164 #endif
2165 
2166     return true;
2167 }
2168 
2169 bool Node::removeEventListener(const AtomString&amp; eventType, EventListener&amp; listener, const ListenerOptions&amp; options)
2170 {
2171     return tryRemoveEventListener(this, eventType, listener, options);
2172 }
2173 
2174 typedef HashMap&lt;Node*, std::unique_ptr&lt;EventTargetData&gt;&gt; EventTargetDataMap;
2175 
2176 static EventTargetDataMap&amp; eventTargetDataMap()
2177 {
2178     static NeverDestroyed&lt;EventTargetDataMap&gt; map;
2179 
2180     return map;
2181 }
2182 
2183 static Lock s_eventTargetDataMapLock;
2184 
2185 EventTargetData* Node::eventTargetData()
2186 {
2187     return hasEventTargetData() ? eventTargetDataMap().get(this) : nullptr;
2188 }
2189 
2190 EventTargetData* Node::eventTargetDataConcurrently()
2191 {
2192     // Not holding the lock when the world is stopped accelerates parallel constraint solving, which
2193     // calls this function from many threads. Parallel constraint solving can happen with the world
2194     // running or stopped, but if we do it with a running world, then we&#39;re usually mixing constraint
2195     // solving with other work. Therefore, the most likely time for contention on this lock is when the
2196     // world is stopped. We don&#39;t have to hold the lock when the world is stopped, because a stopped world
2197     // means that we will never mutate the event target data map.
2198     JSC::VM* vm = commonVMOrNull();
2199     auto locker = holdLockIf(s_eventTargetDataMapLock, vm &amp;&amp; vm-&gt;heap.worldIsRunning());
2200     return hasEventTargetData() ? eventTargetDataMap().get(this) : nullptr;
2201 }
2202 
2203 EventTargetData&amp; Node::ensureEventTargetData()
2204 {
2205     if (hasEventTargetData())
2206         return *eventTargetDataMap().get(this);
2207 
2208     JSC::VM* vm = commonVMOrNull();
2209     RELEASE_ASSERT(!vm || vm-&gt;heap.worldIsRunning());
2210 
2211     auto locker = holdLock(s_eventTargetDataMapLock);
2212     setHasEventTargetData(true);
2213     return *eventTargetDataMap().add(this, makeUnique&lt;EventTargetData&gt;()).iterator-&gt;value;
2214 }
2215 
2216 void Node::clearEventTargetData()
2217 {
2218     JSC::VM* vm = commonVMOrNull();
2219     RELEASE_ASSERT(!vm || vm-&gt;heap.worldIsRunning());
2220     auto locker = holdLock(s_eventTargetDataMapLock);
2221     eventTargetDataMap().remove(this);
2222 }
2223 
2224 Vector&lt;std::unique_ptr&lt;MutationObserverRegistration&gt;&gt;* Node::mutationObserverRegistry()
2225 {
2226     if (!hasRareData())
2227         return nullptr;
2228     auto* data = rareData()-&gt;mutationObserverData();
2229     if (!data)
2230         return nullptr;
2231     return &amp;data-&gt;registry;
2232 }
2233 
2234 HashSet&lt;MutationObserverRegistration*&gt;* Node::transientMutationObserverRegistry()
2235 {
2236     if (!hasRareData())
2237         return nullptr;
2238     auto* data = rareData()-&gt;mutationObserverData();
2239     if (!data)
2240         return nullptr;
2241     return &amp;data-&gt;transientRegistry;
2242 }
2243 
2244 template&lt;typename Registry&gt; static inline void collectMatchingObserversForMutation(HashMap&lt;Ref&lt;MutationObserver&gt;, MutationRecordDeliveryOptions&gt;&amp; observers, Registry* registry, Node&amp; target, MutationObserver::MutationType type, const QualifiedName* attributeName)
2245 {
2246     if (!registry)
2247         return;
2248 
2249     for (auto&amp; registration : *registry) {
2250         if (registration-&gt;shouldReceiveMutationFrom(target, type, attributeName)) {
2251             auto deliveryOptions = registration-&gt;deliveryOptions();
2252             auto result = observers.add(registration-&gt;observer(), deliveryOptions);
2253             if (!result.isNewEntry)
2254                 result.iterator-&gt;value |= deliveryOptions;
2255         }
2256     }
2257 }
2258 
2259 HashMap&lt;Ref&lt;MutationObserver&gt;, MutationRecordDeliveryOptions&gt; Node::registeredMutationObservers(MutationObserver::MutationType type, const QualifiedName* attributeName)
2260 {
2261     HashMap&lt;Ref&lt;MutationObserver&gt;, MutationRecordDeliveryOptions&gt; result;
2262     ASSERT((type == MutationObserver::Attributes &amp;&amp; attributeName) || !attributeName);
2263     collectMatchingObserversForMutation(result, mutationObserverRegistry(), *this, type, attributeName);
2264     collectMatchingObserversForMutation(result, transientMutationObserverRegistry(), *this, type, attributeName);
2265     for (Node* node = parentNode(); node; node = node-&gt;parentNode()) {
2266         collectMatchingObserversForMutation(result, node-&gt;mutationObserverRegistry(), *this, type, attributeName);
2267         collectMatchingObserversForMutation(result, node-&gt;transientMutationObserverRegistry(), *this, type, attributeName);
2268     }
2269     return result;
2270 }
2271 
2272 void Node::registerMutationObserver(MutationObserver&amp; observer, MutationObserverOptions options, const HashSet&lt;AtomString&gt;&amp; attributeFilter)
2273 {
2274     MutationObserverRegistration* registration = nullptr;
2275     auto&amp; registry = ensureRareData().ensureMutationObserverData().registry;
2276 
2277     for (auto&amp; candidateRegistration : registry) {
2278         if (&amp;candidateRegistration-&gt;observer() == &amp;observer) {
2279             registration = candidateRegistration.get();
2280             registration-&gt;resetObservation(options, attributeFilter);
2281         }
2282     }
2283 
2284     if (!registration) {
2285         registry.append(makeUnique&lt;MutationObserverRegistration&gt;(observer, *this, options, attributeFilter));
2286         registration = registry.last().get();
2287     }
2288 
2289     document().addMutationObserverTypes(registration-&gt;mutationTypes());
2290 }
2291 
2292 void Node::unregisterMutationObserver(MutationObserverRegistration&amp; registration)
2293 {
2294     auto* registry = mutationObserverRegistry();
2295     ASSERT(registry);
2296     if (!registry)
2297         return;
2298 
2299     registry-&gt;removeFirstMatching([&amp;registration] (auto&amp; current) {
2300         return current.get() == &amp;registration;
2301     });
2302 }
2303 
2304 void Node::registerTransientMutationObserver(MutationObserverRegistration&amp; registration)
2305 {
2306     ensureRareData().ensureMutationObserverData().transientRegistry.add(&amp;registration);
2307 }
2308 
2309 void Node::unregisterTransientMutationObserver(MutationObserverRegistration&amp; registration)
2310 {
2311     auto* transientRegistry = transientMutationObserverRegistry();
2312     ASSERT(transientRegistry);
2313     if (!transientRegistry)
2314         return;
2315 
2316     ASSERT(transientRegistry-&gt;contains(&amp;registration));
2317     transientRegistry-&gt;remove(&amp;registration);
2318 }
2319 
2320 void Node::notifyMutationObserversNodeWillDetach()
2321 {
2322     if (!document().hasMutationObservers())
2323         return;
2324 
2325     for (Node* node = parentNode(); node; node = node-&gt;parentNode()) {
2326         if (auto* registry = node-&gt;mutationObserverRegistry()) {
2327             for (auto&amp; registration : *registry)
2328                 registration-&gt;observedSubtreeNodeWillDetach(*this);
2329         }
2330         if (auto* transientRegistry = node-&gt;transientMutationObserverRegistry()) {
2331             for (auto* registration : *transientRegistry)
2332                 registration-&gt;observedSubtreeNodeWillDetach(*this);
2333         }
2334     }
2335 }
2336 
2337 void Node::handleLocalEvents(Event&amp; event, EventInvokePhase phase)
2338 {
2339     if (!hasEventTargetData())
2340         return;
2341 
2342     // FIXME: Should we deliver wheel events to disabled form controls or not?
2343     if (is&lt;Element&gt;(*this) &amp;&amp; downcast&lt;Element&gt;(*this).isDisabledFormControl() &amp;&amp; event.isMouseEvent() &amp;&amp; !event.isWheelEvent())
2344         return;
2345 
2346     fireEventListeners(event, phase);
2347 }
2348 
2349 void Node::dispatchScopedEvent(Event&amp; event)
2350 {
2351     EventDispatcher::dispatchScopedEvent(*this, event);
2352 }
2353 
2354 void Node::dispatchEvent(Event&amp; event)
2355 {
2356     EventDispatcher::dispatchEvent(*this, event);
2357 }
2358 
2359 void Node::dispatchSubtreeModifiedEvent()
2360 {
2361     if (isInShadowTree())
2362         return;
2363 
2364     ASSERT_WITH_SECURITY_IMPLICATION(ScriptDisallowedScope::InMainThread::isEventDispatchAllowedInSubtree(*this));
2365 
2366     if (!document().hasListenerType(Document::DOMSUBTREEMODIFIED_LISTENER))
2367         return;
2368     const AtomString&amp; subtreeModifiedEventName = eventNames().DOMSubtreeModifiedEvent;
2369     if (!parentNode() &amp;&amp; !hasEventListeners(subtreeModifiedEventName))
2370         return;
2371 
2372     dispatchScopedEvent(MutationEvent::create(subtreeModifiedEventName, Event::CanBubble::Yes));
2373 }
2374 
2375 void Node::dispatchDOMActivateEvent(Event&amp; underlyingClickEvent)
2376 {
2377     ASSERT_WITH_SECURITY_IMPLICATION(ScriptDisallowedScope::InMainThread::isScriptAllowed());
2378     int detail = is&lt;UIEvent&gt;(underlyingClickEvent) ? downcast&lt;UIEvent&gt;(underlyingClickEvent).detail() : 0;
2379     auto event = UIEvent::create(eventNames().DOMActivateEvent, Event::CanBubble::Yes, Event::IsCancelable::Yes, Event::IsComposed::Yes, document().windowProxy(), detail);
2380     event-&gt;setUnderlyingEvent(&amp;underlyingClickEvent);
2381     dispatchScopedEvent(event);
2382     if (event-&gt;defaultHandled())
2383         underlyingClickEvent.setDefaultHandled();
2384 }
2385 
2386 bool Node::dispatchBeforeLoadEvent(const String&amp; sourceURL)
2387 {
2388     if (!document().hasListenerType(Document::BEFORELOAD_LISTENER))
2389         return true;
2390 
2391     Ref&lt;Node&gt; protectedThis(*this);
2392     auto event = BeforeLoadEvent::create(sourceURL);
2393     dispatchEvent(event);
2394     return !event-&gt;defaultPrevented();
2395 }
2396 
2397 void Node::dispatchInputEvent()
2398 {
2399     dispatchScopedEvent(Event::create(eventNames().inputEvent, Event::CanBubble::Yes, Event::IsCancelable::No, Event::IsComposed::Yes));
2400 }
2401 
2402 void Node::defaultEventHandler(Event&amp; event)
2403 {
2404     if (event.target() != this)
2405         return;
2406     const AtomString&amp; eventType = event.type();
2407     if (eventType == eventNames().keydownEvent || eventType == eventNames().keypressEvent) {
2408         if (is&lt;KeyboardEvent&gt;(event)) {
2409             if (Frame* frame = document().frame())
2410                 frame-&gt;eventHandler().defaultKeyboardEventHandler(downcast&lt;KeyboardEvent&gt;(event));
2411         }
2412     } else if (eventType == eventNames().clickEvent) {
2413         dispatchDOMActivateEvent(event);
2414 #if ENABLE(CONTEXT_MENUS)
2415     } else if (eventType == eventNames().contextmenuEvent) {
2416         if (Frame* frame = document().frame())
2417             if (Page* page = frame-&gt;page())
2418                 page-&gt;contextMenuController().handleContextMenuEvent(event);
2419 #endif
2420     } else if (eventType == eventNames().textInputEvent) {
2421         if (is&lt;TextEvent&gt;(event)) {
2422             if (Frame* frame = document().frame())
2423                 frame-&gt;eventHandler().defaultTextInputEventHandler(downcast&lt;TextEvent&gt;(event));
2424         }
2425 #if ENABLE(PAN_SCROLLING)
2426     } else if (eventType == eventNames().mousedownEvent &amp;&amp; is&lt;MouseEvent&gt;(event)) {
2427         if (downcast&lt;MouseEvent&gt;(event).button() == MiddleButton) {
2428             if (enclosingLinkEventParentOrSelf())
2429                 return;
2430 
2431             RenderObject* renderer = this-&gt;renderer();
2432             while (renderer &amp;&amp; (!is&lt;RenderBox&gt;(*renderer) || !downcast&lt;RenderBox&gt;(*renderer).canBeScrolledAndHasScrollableArea()))
2433                 renderer = renderer-&gt;parent();
2434 
2435             if (renderer) {
2436                 if (Frame* frame = document().frame())
2437                     frame-&gt;eventHandler().startPanScrolling(downcast&lt;RenderBox&gt;(*renderer));
2438             }
2439         }
2440 #endif
2441     } else if (eventNames().isWheelEventType(eventType) &amp;&amp; is&lt;WheelEvent&gt;(event)) {
2442         // If we don&#39;t have a renderer, send the wheel event to the first node we find with a renderer.
2443         // This is needed for &lt;option&gt; and &lt;optgroup&gt; elements so that &lt;select&gt;s get a wheel scroll.
2444         Node* startNode = this;
2445         while (startNode &amp;&amp; !startNode-&gt;renderer())
2446             startNode = startNode-&gt;parentOrShadowHostNode();
2447 
2448         if (startNode &amp;&amp; startNode-&gt;renderer())
2449             if (Frame* frame = document().frame())
2450                 frame-&gt;eventHandler().defaultWheelEventHandler(startNode, downcast&lt;WheelEvent&gt;(event));
2451 #if ENABLE(TOUCH_EVENTS) &amp;&amp; PLATFORM(IOS_FAMILY)
2452     } else if (is&lt;TouchEvent&gt;(event) &amp;&amp; eventNames().isTouchRelatedEventType(document(), eventType)) {
2453         // Capture the target node&#39;s visibility state before dispatching touchStart.
2454         if (is&lt;Element&gt;(*this) &amp;&amp; eventType == eventNames().touchstartEvent) {
2455             auto&amp; contentChangeObserver = document().contentChangeObserver();
2456             if (ContentChangeObserver::isVisuallyHidden(*this))
2457                 contentChangeObserver.setHiddenTouchTarget(downcast&lt;Element&gt;(*this));
2458             else
2459                 contentChangeObserver.resetHiddenTouchTarget();
2460         }
2461 
2462         RenderObject* renderer = this-&gt;renderer();
2463         while (renderer &amp;&amp; (!is&lt;RenderBox&gt;(*renderer) || !downcast&lt;RenderBox&gt;(*renderer).canBeScrolledAndHasScrollableArea()))
2464             renderer = renderer-&gt;parent();
2465 
2466         if (renderer &amp;&amp; renderer-&gt;node()) {
2467             if (Frame* frame = document().frame())
2468                 frame-&gt;eventHandler().defaultTouchEventHandler(*renderer-&gt;node(), downcast&lt;TouchEvent&gt;(event));
2469         }
2470 #endif
2471     }
2472 }
2473 
2474 bool Node::willRespondToMouseMoveEvents()
2475 {
2476     // FIXME: Why is the iOS code path different from the non-iOS code path?
2477 #if !PLATFORM(IOS_FAMILY)
2478     if (!is&lt;Element&gt;(*this))
2479         return false;
2480     if (downcast&lt;Element&gt;(*this).isDisabledFormControl())
2481         return false;
2482 #endif
2483     return hasEventListeners(eventNames().mousemoveEvent) || hasEventListeners(eventNames().mouseoverEvent) || hasEventListeners(eventNames().mouseoutEvent);
2484 }
2485 
2486 bool Node::willRespondToMouseClickEvents()
2487 {
2488     // FIXME: Why is the iOS code path different from the non-iOS code path?
2489 #if PLATFORM(IOS_FAMILY)
2490     return isContentEditable() || hasEventListeners(eventNames().mouseupEvent) || hasEventListeners(eventNames().mousedownEvent) || hasEventListeners(eventNames().clickEvent);
2491 #else
2492     if (!is&lt;Element&gt;(*this))
2493         return false;
2494     if (downcast&lt;Element&gt;(*this).isDisabledFormControl())
2495         return false;
2496     return computeEditability(UserSelectAllIsAlwaysNonEditable, ShouldUpdateStyle::Update) != Editability::ReadOnly
2497         || hasEventListeners(eventNames().mouseupEvent) || hasEventListeners(eventNames().mousedownEvent) || hasEventListeners(eventNames().clickEvent) || hasEventListeners(eventNames().DOMActivateEvent);
2498 #endif
2499 }
2500 
2501 bool Node::willRespondToMouseWheelEvents()
2502 {
2503     return hasEventListeners(eventNames().mousewheelEvent);
2504 }
2505 
2506 // It&#39;s important not to inline removedLastRef, because we don&#39;t want to inline the code to
2507 // delete a Node at each deref call site.
2508 void Node::removedLastRef()
2509 {
2510     ASSERT(m_refCountAndParentBit == s_refCountIncrement);
2511 
2512     // An explicit check for Document here is better than a virtual function since it is
2513     // faster for non-Document nodes, and because the call to removedLastRef that is inlined
2514     // at all deref call sites is smaller if it&#39;s a non-virtual function.
2515     if (is&lt;Document&gt;(*this)) {
2516         downcast&lt;Document&gt;(*this).removedLastRef();
2517         return;
2518     }
2519 
2520     // Now it is time to detach the SVGElement from all its properties. These properties
2521     // may outlive the SVGElement. The only difference after the detach is no commit will
2522     // be carried out unless these properties are attached to another owner.
2523     if (is&lt;SVGElement&gt;(*this))
2524         downcast&lt;SVGElement&gt;(*this).detachAllProperties();
2525 
2526 #ifndef NDEBUG
2527     m_deletionHasBegun = true;
2528 #endif
2529     delete this;
2530 }
2531 
2532 void Node::textRects(Vector&lt;IntRect&gt;&amp; rects) const
2533 {
2534     auto range = Range::create(document());
2535     range-&gt;selectNodeContents(const_cast&lt;Node&amp;&gt;(*this));
2536     range-&gt;absoluteTextRects(rects);
2537 }
2538 
2539 unsigned Node::connectedSubframeCount() const
2540 {
2541     return hasRareData() ? rareData()-&gt;connectedSubframeCount() : 0;
2542 }
2543 
2544 void Node::incrementConnectedSubframeCount(unsigned amount)
2545 {
2546     ASSERT(isContainerNode());
2547     ensureRareData().incrementConnectedSubframeCount(amount);
2548 }
2549 
2550 void Node::decrementConnectedSubframeCount(unsigned amount)
2551 {
2552     ASSERT(rareData());
2553     if (!hasRareData())
2554         return; // Defend against type confusion when the above assertion fails. See webkit.org/b/200300.
2555     rareData()-&gt;decrementConnectedSubframeCount(amount);
2556 }
2557 
2558 void Node::updateAncestorConnectedSubframeCountForRemoval() const
2559 {
2560     unsigned count = connectedSubframeCount();
2561 
2562     if (!count)
2563         return;
2564 
2565     for (Node* node = parentOrShadowHostNode(); node; node = node-&gt;parentOrShadowHostNode())
2566         node-&gt;decrementConnectedSubframeCount(count);
2567 }
2568 
2569 void Node::updateAncestorConnectedSubframeCountForInsertion() const
2570 {
2571     unsigned count = connectedSubframeCount();
2572 
2573     if (!count)
2574         return;
2575 
2576     for (Node* node = parentOrShadowHostNode(); node; node = node-&gt;parentOrShadowHostNode())
2577         node-&gt;incrementConnectedSubframeCount(count);
2578 }
2579 
2580 bool Node::inRenderedDocument() const
2581 {
2582     return isConnected() &amp;&amp; document().hasLivingRenderTree();
2583 }
2584 
2585 void* Node::opaqueRootSlow() const
2586 {
2587     const Node* node = this;
2588     for (;;) {
2589         const Node* nextNode = node-&gt;parentOrShadowHostNode();
2590         if (!nextNode)
2591             break;
2592         node = nextNode;
2593     }
2594     return const_cast&lt;void*&gt;(static_cast&lt;const void*&gt;(node));
2595 }
2596 
2597 } // namespace WebCore
2598 
2599 #if ENABLE(TREE_DEBUGGING)
2600 
2601 void showTree(const WebCore::Node* node)
2602 {
2603     if (node)
2604         node-&gt;showTreeForThis();
2605 }
2606 
2607 void showNodePath(const WebCore::Node* node)
2608 {
2609     if (node)
2610         node-&gt;showNodePathForThis();
2611 }
2612 
2613 #endif // ENABLE(TREE_DEBUGGING)
    </pre>
  </body>
</html>