<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/html/shadow/MediaControlElements.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="MediaControlElementTypes.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="MediaControlElements.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/html/shadow/MediaControlElements.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  20  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  21  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  22  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  23  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  24  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  25  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  26  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  27  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  28  */
  29 
  30 #include &quot;config.h&quot;
  31 #include &quot;MediaControlElements.h&quot;
  32 
  33 #if ENABLE(VIDEO)
  34 
  35 #include &quot;DOMTokenList.h&quot;
  36 #include &quot;ElementChildIterator.h&quot;
  37 #include &quot;EventHandler.h&quot;
  38 #include &quot;EventNames.h&quot;
  39 #include &quot;Frame.h&quot;

  40 #include &quot;GraphicsContext.h&quot;
  41 #include &quot;HTMLHeadingElement.h&quot;
  42 #include &quot;HTMLLIElement.h&quot;
  43 #include &quot;HTMLUListElement.h&quot;
  44 #include &quot;HTMLVideoElement.h&quot;
  45 #include &quot;ImageBuffer.h&quot;
  46 #include &quot;LocalizedStrings.h&quot;
  47 #include &quot;Logging.h&quot;
  48 #include &quot;MediaControls.h&quot;
  49 #include &quot;MouseEvent.h&quot;
  50 #include &quot;Page.h&quot;
  51 #include &quot;PageGroup.h&quot;
  52 #include &quot;RenderLayer.h&quot;
  53 #include &quot;RenderMediaControlElements.h&quot;
  54 #include &quot;RenderSlider.h&quot;
  55 #include &quot;RenderTheme.h&quot;
  56 #include &quot;RenderVideo.h&quot;
  57 #include &quot;RenderView.h&quot;
  58 #include &quot;Settings.h&quot;
  59 #include &quot;ShadowRoot.h&quot;
</pre>
<hr />
<pre>
  76 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlOverlayPlayButtonElement);
  77 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlSeekForwardButtonElement);
  78 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlSeekBackButtonElement);
  79 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlRewindButtonElement);
  80 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlReturnToRealtimeButtonElement);
  81 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlToggleClosedCaptionsButtonElement);
  82 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlClosedCaptionsContainerElement);
  83 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlClosedCaptionsTrackListElement);
  84 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlTimelineElement);
  85 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlFullscreenButtonElement);
  86 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlPanelVolumeSliderElement);
  87 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlFullscreenVolumeSliderElement);
  88 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlFullscreenVolumeMinButtonElement);
  89 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlFullscreenVolumeMaxButtonElement);
  90 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlTimeRemainingDisplayElement);
  91 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlCurrentTimeDisplayElement);
  92 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlTextTrackContainerElement);
  93 
  94 using namespace HTMLNames;
  95 
<span class="line-modified">  96 static const AtomicString&amp; getMediaControlCurrentTimeDisplayElementShadowPseudoId();</span>
<span class="line-modified">  97 static const AtomicString&amp; getMediaControlTimeRemainingDisplayElementShadowPseudoId();</span>
  98 
  99 MediaControlPanelElement::MediaControlPanelElement(Document&amp; document)
 100     : MediaControlDivElement(document, MediaControlsPanel)
 101     , m_canBeDragged(false)
 102     , m_isBeingDragged(false)
 103     , m_isDisplayed(false)
 104     , m_opaque(true)
 105     , m_transitionTimer(*this, &amp;MediaControlPanelElement::transitionTimerFired)
 106 {
<span class="line-modified"> 107     setPseudo(AtomicString(&quot;-webkit-media-controls-panel&quot;, AtomicString::ConstructFromLiteral));</span>
 108 }
 109 
 110 Ref&lt;MediaControlPanelElement&gt; MediaControlPanelElement::create(Document&amp; document)
 111 {
 112     return adoptRef(*new MediaControlPanelElement(document));
 113 }
 114 
 115 void MediaControlPanelElement::startDrag(const LayoutPoint&amp; eventLocation)
 116 {
 117     if (!m_canBeDragged)
 118         return;
 119 
 120     if (m_isBeingDragged)
 121         return;
 122 
 123     auto renderer = this-&gt;renderer();
 124     if (!renderer || !renderer-&gt;isBox())
 125         return;
 126 
 127     RefPtr&lt;Frame&gt; frame = document().frame();
</pre>
<hr />
<pre>
 269     if (m_canBeDragged == canBeDragged)
 270         return;
 271 
 272     m_canBeDragged = canBeDragged;
 273 
 274     if (!canBeDragged)
 275         endDrag();
 276 }
 277 
 278 void MediaControlPanelElement::setIsDisplayed(bool isDisplayed)
 279 {
 280     m_isDisplayed = isDisplayed;
 281 }
 282 
 283 // ----------------------------
 284 
 285 MediaControlPanelEnclosureElement::MediaControlPanelEnclosureElement(Document&amp; document)
 286     // Mapping onto same MediaControlElementType as panel element, since it has similar properties.
 287     : MediaControlDivElement(document, MediaControlsPanel)
 288 {
<span class="line-modified"> 289     setPseudo(AtomicString(&quot;-webkit-media-controls-enclosure&quot;, AtomicString::ConstructFromLiteral));</span>
 290 }
 291 
 292 Ref&lt;MediaControlPanelEnclosureElement&gt; MediaControlPanelEnclosureElement::create(Document&amp; document)
 293 {
 294     return adoptRef(*new MediaControlPanelEnclosureElement(document));
 295 }
 296 
 297 // ----------------------------
 298 
 299 MediaControlOverlayEnclosureElement::MediaControlOverlayEnclosureElement(Document&amp; document)
 300     // Mapping onto same MediaControlElementType as panel element, since it has similar properties.
 301     : MediaControlDivElement(document, MediaControlsPanel)
 302 {
<span class="line-modified"> 303     setPseudo(AtomicString(&quot;-webkit-media-controls-overlay-enclosure&quot;, AtomicString::ConstructFromLiteral));</span>
 304 }
 305 
 306 Ref&lt;MediaControlOverlayEnclosureElement&gt; MediaControlOverlayEnclosureElement::create(Document&amp; document)
 307 {
 308     return adoptRef(*new MediaControlOverlayEnclosureElement(document));
 309 }
 310 
 311 // ----------------------------
 312 
 313 MediaControlTimelineContainerElement::MediaControlTimelineContainerElement(Document&amp; document)
 314     : MediaControlDivElement(document, MediaTimelineContainer)
 315 {
<span class="line-modified"> 316     setPseudo(AtomicString(&quot;-webkit-media-controls-timeline-container&quot;, AtomicString::ConstructFromLiteral));</span>
 317 }
 318 
 319 Ref&lt;MediaControlTimelineContainerElement&gt; MediaControlTimelineContainerElement::create(Document&amp; document)
 320 {
 321     Ref&lt;MediaControlTimelineContainerElement&gt; element = adoptRef(*new MediaControlTimelineContainerElement(document));
 322     element-&gt;hide();
 323     return element;
 324 }
 325 
 326 void MediaControlTimelineContainerElement::setTimeDisplaysHidden(bool hidden)
 327 {
 328     for (auto&amp; element : childrenOfType&lt;Element&gt;(*this)) {
 329         if (element.shadowPseudoId() != getMediaControlTimeRemainingDisplayElementShadowPseudoId()
 330             &amp;&amp; element.shadowPseudoId() != getMediaControlCurrentTimeDisplayElementShadowPseudoId())
 331             continue;
 332 
 333         MediaControlTimeDisplayElement&amp; timeDisplay = static_cast&lt;MediaControlTimeDisplayElement&amp;&gt;(element);
 334         if (hidden)
 335             timeDisplay.hide();
 336         else
 337             timeDisplay.show();
 338     }
 339 }
 340 
 341 RenderPtr&lt;RenderElement&gt; MediaControlTimelineContainerElement::createElementRenderer(RenderStyle&amp;&amp; style, const RenderTreePosition&amp;)
 342 {
 343     return createRenderer&lt;RenderMediaControlTimelineContainer&gt;(*this, WTFMove(style));
 344 }
 345 
 346 // ----------------------------
 347 
 348 MediaControlVolumeSliderContainerElement::MediaControlVolumeSliderContainerElement(Document&amp; document)
 349     : MediaControlDivElement(document, MediaVolumeSliderContainer)
 350 {
<span class="line-modified"> 351     setPseudo(AtomicString(&quot;-webkit-media-controls-volume-slider-container&quot;, AtomicString::ConstructFromLiteral));</span>
 352 }
 353 
 354 Ref&lt;MediaControlVolumeSliderContainerElement&gt; MediaControlVolumeSliderContainerElement::create(Document&amp; document)
 355 {
 356     Ref&lt;MediaControlVolumeSliderContainerElement&gt; element = adoptRef(*new MediaControlVolumeSliderContainerElement(document));
 357     element-&gt;hide();
 358     return element;
 359 }
 360 
 361 RenderPtr&lt;RenderElement&gt; MediaControlVolumeSliderContainerElement::createElementRenderer(RenderStyle&amp;&amp; style, const RenderTreePosition&amp;)
 362 {
 363     return createRenderer&lt;RenderMediaVolumeSliderContainer&gt;(*this, WTFMove(style));
 364 }
 365 
 366 void MediaControlVolumeSliderContainerElement::defaultEventHandler(Event&amp; event)
 367 {
 368     // Poor man&#39;s mouseleave event detection.
 369 
 370     if (!is&lt;MouseEvent&gt;(event) || event.type() != eventNames().mouseoutEvent)
 371         return;
 372 
 373     if (!is&lt;Node&gt;(downcast&lt;MouseEvent&gt;(event).relatedTarget()))
 374         return;
 375 
 376     if (containsIncludingShadowDOM(&amp;downcast&lt;Node&gt;(*downcast&lt;MouseEvent&gt;(event).relatedTarget())))
 377         return;
 378 
 379     hide();
 380 }
 381 
 382 // ----------------------------
 383 
 384 MediaControlStatusDisplayElement::MediaControlStatusDisplayElement(Document&amp; document)
 385     : MediaControlDivElement(document, MediaStatusDisplay)
 386     , m_stateBeingDisplayed(Nothing)
 387 {
<span class="line-modified"> 388     setPseudo(AtomicString(&quot;-webkit-media-controls-status-display&quot;, AtomicString::ConstructFromLiteral));</span>
 389 }
 390 
 391 Ref&lt;MediaControlStatusDisplayElement&gt; MediaControlStatusDisplayElement::create(Document&amp; document)
 392 {
 393     Ref&lt;MediaControlStatusDisplayElement&gt; element = adoptRef(*new MediaControlStatusDisplayElement(document));
 394     element-&gt;hide();
 395     return element;
 396 }
 397 
 398 void MediaControlStatusDisplayElement::update()
 399 {
 400     // Get the new state that we&#39;ll have to display.
 401     StateBeingDisplayed newStateToDisplay = Nothing;
 402 
 403     if (mediaController()-&gt;readyState() &lt;= MediaControllerInterface::HAVE_METADATA &amp;&amp; mediaController()-&gt;hasCurrentSrc())
 404         newStateToDisplay = Loading;
 405     else if (mediaController()-&gt;isLiveStream())
 406         newStateToDisplay = LiveBroadcast;
 407 
 408     if (newStateToDisplay == m_stateBeingDisplayed)
</pre>
<hr />
<pre>
 417 
 418     switch (m_stateBeingDisplayed) {
 419     case Nothing:
 420         setInnerText(emptyString());
 421         break;
 422     case Loading:
 423         setInnerText(mediaElementLoadingStateText());
 424         break;
 425     case LiveBroadcast:
 426         setInnerText(mediaElementLiveBroadcastStateText());
 427         break;
 428     }
 429 }
 430 
 431 // ----------------------------
 432 
 433 MediaControlPanelMuteButtonElement::MediaControlPanelMuteButtonElement(Document&amp; document, MediaControls* controls)
 434     : MediaControlMuteButtonElement(document, MediaMuteButton)
 435     , m_controls(controls)
 436 {
<span class="line-modified"> 437     setPseudo(AtomicString(&quot;-webkit-media-controls-mute-button&quot;, AtomicString::ConstructFromLiteral));</span>
 438 }
 439 
 440 Ref&lt;MediaControlPanelMuteButtonElement&gt; MediaControlPanelMuteButtonElement::create(Document&amp; document, MediaControls* controls)
 441 {
 442     ASSERT(controls);
 443 
 444     Ref&lt;MediaControlPanelMuteButtonElement&gt; button = adoptRef(*new MediaControlPanelMuteButtonElement(document, controls));
 445     button-&gt;ensureUserAgentShadowRoot();
 446     button-&gt;setType(&quot;button&quot;);
 447     return button;
 448 }
 449 
 450 void MediaControlPanelMuteButtonElement::defaultEventHandler(Event&amp; event)
 451 {
 452     if (event.type() == eventNames().mouseoverEvent)
 453         m_controls-&gt;showVolumeSlider();
 454 
 455     MediaControlMuteButtonElement::defaultEventHandler(event);
 456 }
 457 
 458 // ----------------------------
 459 
 460 MediaControlVolumeSliderMuteButtonElement::MediaControlVolumeSliderMuteButtonElement(Document&amp; document)
 461     : MediaControlMuteButtonElement(document, MediaMuteButton)
 462 {
<span class="line-modified"> 463     setPseudo(AtomicString(&quot;-webkit-media-controls-volume-slider-mute-button&quot;, AtomicString::ConstructFromLiteral));</span>
 464 }
 465 
 466 Ref&lt;MediaControlVolumeSliderMuteButtonElement&gt; MediaControlVolumeSliderMuteButtonElement::create(Document&amp; document)
 467 {
 468     Ref&lt;MediaControlVolumeSliderMuteButtonElement&gt; button = adoptRef(*new MediaControlVolumeSliderMuteButtonElement(document));
 469     button-&gt;ensureUserAgentShadowRoot();
 470     button-&gt;setType(&quot;button&quot;);
 471     return button;
 472 }
 473 
 474 // ----------------------------
 475 
 476 MediaControlPlayButtonElement::MediaControlPlayButtonElement(Document&amp; document)
 477     : MediaControlInputElement(document, MediaPlayButton)
 478 {
<span class="line-modified"> 479     setPseudo(AtomicString(&quot;-webkit-media-controls-play-button&quot;, AtomicString::ConstructFromLiteral));</span>
 480 }
 481 
 482 Ref&lt;MediaControlPlayButtonElement&gt; MediaControlPlayButtonElement::create(Document&amp; document)
 483 {
 484     Ref&lt;MediaControlPlayButtonElement&gt; button = adoptRef(*new MediaControlPlayButtonElement(document));
 485     button-&gt;ensureUserAgentShadowRoot();
 486     button-&gt;setType(&quot;button&quot;);
 487     return button;
 488 }
 489 
 490 void MediaControlPlayButtonElement::defaultEventHandler(Event&amp; event)
 491 {
 492     if (event.type() == eventNames().clickEvent) {
 493         if (mediaController()-&gt;canPlay())
 494             mediaController()-&gt;play();
 495         else
 496             mediaController()-&gt;pause();
 497         updateDisplayType();
 498         event.setDefaultHandled();
 499     }
 500     HTMLInputElement::defaultEventHandler(event);
 501 }
 502 
 503 void MediaControlPlayButtonElement::updateDisplayType()
 504 {
 505     setDisplayType(mediaController()-&gt;canPlay() ? MediaPlayButton : MediaPauseButton);
 506 }
 507 
 508 // ----------------------------
 509 
 510 MediaControlOverlayPlayButtonElement::MediaControlOverlayPlayButtonElement(Document&amp; document)
 511     : MediaControlInputElement(document, MediaOverlayPlayButton)
 512 {
<span class="line-modified"> 513     setPseudo(AtomicString(&quot;-webkit-media-controls-overlay-play-button&quot;, AtomicString::ConstructFromLiteral));</span>
 514 }
 515 
 516 Ref&lt;MediaControlOverlayPlayButtonElement&gt; MediaControlOverlayPlayButtonElement::create(Document&amp; document)
 517 {
 518     Ref&lt;MediaControlOverlayPlayButtonElement&gt; button = adoptRef(*new MediaControlOverlayPlayButtonElement(document));
 519     button-&gt;ensureUserAgentShadowRoot();
 520     button-&gt;setType(&quot;button&quot;);
 521     return button;
 522 }
 523 
 524 void MediaControlOverlayPlayButtonElement::defaultEventHandler(Event&amp; event)
 525 {
 526     if (event.type() == eventNames().clickEvent &amp;&amp; mediaController()-&gt;canPlay()) {
 527         mediaController()-&gt;play();
 528         updateDisplayType();
 529         event.setDefaultHandled();
 530     }
 531     HTMLInputElement::defaultEventHandler(event);
 532 }
 533 
 534 void MediaControlOverlayPlayButtonElement::updateDisplayType()
 535 {
 536     if (mediaController()-&gt;canPlay()) {
 537         show();
 538     } else
 539         hide();
 540 }
 541 
 542 // ----------------------------
 543 
 544 MediaControlSeekForwardButtonElement::MediaControlSeekForwardButtonElement(Document&amp; document)
 545     : MediaControlSeekButtonElement(document, MediaSeekForwardButton)
 546 {
<span class="line-modified"> 547     setPseudo(AtomicString(&quot;-webkit-media-controls-seek-forward-button&quot;, AtomicString::ConstructFromLiteral));</span>
 548 }
 549 
 550 Ref&lt;MediaControlSeekForwardButtonElement&gt; MediaControlSeekForwardButtonElement::create(Document&amp; document)
 551 {
 552     Ref&lt;MediaControlSeekForwardButtonElement&gt; button = adoptRef(*new MediaControlSeekForwardButtonElement(document));
 553     button-&gt;ensureUserAgentShadowRoot();
 554     button-&gt;setType(&quot;button&quot;);
 555     return button;
 556 }
 557 
 558 // ----------------------------
 559 
 560 MediaControlSeekBackButtonElement::MediaControlSeekBackButtonElement(Document&amp; document)
 561     : MediaControlSeekButtonElement(document, MediaSeekBackButton)
 562 {
<span class="line-modified"> 563     setPseudo(AtomicString(&quot;-webkit-media-controls-seek-back-button&quot;, AtomicString::ConstructFromLiteral));</span>
 564 }
 565 
 566 Ref&lt;MediaControlSeekBackButtonElement&gt; MediaControlSeekBackButtonElement::create(Document&amp; document)
 567 {
 568     Ref&lt;MediaControlSeekBackButtonElement&gt; button = adoptRef(*new MediaControlSeekBackButtonElement(document));
 569     button-&gt;ensureUserAgentShadowRoot();
 570     button-&gt;setType(&quot;button&quot;);
 571     return button;
 572 }
 573 
 574 // ----------------------------
 575 
 576 MediaControlRewindButtonElement::MediaControlRewindButtonElement(Document&amp; document)
 577     : MediaControlInputElement(document, MediaRewindButton)
 578 {
<span class="line-modified"> 579     setPseudo(AtomicString(&quot;-webkit-media-controls-rewind-button&quot;, AtomicString::ConstructFromLiteral));</span>
 580 }
 581 
 582 Ref&lt;MediaControlRewindButtonElement&gt; MediaControlRewindButtonElement::create(Document&amp; document)
 583 {
 584     Ref&lt;MediaControlRewindButtonElement&gt; button = adoptRef(*new MediaControlRewindButtonElement(document));
 585     button-&gt;ensureUserAgentShadowRoot();
 586     button-&gt;setType(&quot;button&quot;);
 587     return button;
 588 }
 589 
 590 void MediaControlRewindButtonElement::defaultEventHandler(Event&amp; event)
 591 {
 592     if (event.type() == eventNames().clickEvent) {
 593         mediaController()-&gt;setCurrentTime(std::max&lt;double&gt;(0, mediaController()-&gt;currentTime() - 30));
 594         event.setDefaultHandled();
 595     }
 596     HTMLInputElement::defaultEventHandler(event);
 597 }
 598 
 599 // ----------------------------
 600 
 601 MediaControlReturnToRealtimeButtonElement::MediaControlReturnToRealtimeButtonElement(Document&amp; document)
 602     : MediaControlInputElement(document, MediaReturnToRealtimeButton)
 603 {
<span class="line-modified"> 604     setPseudo(AtomicString(&quot;-webkit-media-controls-return-to-realtime-button&quot;, AtomicString::ConstructFromLiteral));</span>
 605 }
 606 
 607 Ref&lt;MediaControlReturnToRealtimeButtonElement&gt; MediaControlReturnToRealtimeButtonElement::create(Document&amp; document)
 608 {
 609     Ref&lt;MediaControlReturnToRealtimeButtonElement&gt; button = adoptRef(*new MediaControlReturnToRealtimeButtonElement(document));
 610     button-&gt;ensureUserAgentShadowRoot();
 611     button-&gt;setType(&quot;button&quot;);
 612     button-&gt;hide();
 613     return button;
 614 }
 615 
 616 void MediaControlReturnToRealtimeButtonElement::defaultEventHandler(Event&amp; event)
 617 {
 618     if (event.type() == eventNames().clickEvent) {
 619         mediaController()-&gt;returnToRealtime();
 620         event.setDefaultHandled();
 621     }
 622     HTMLInputElement::defaultEventHandler(event);
 623 }
 624 
 625 // ----------------------------
 626 
 627 MediaControlToggleClosedCaptionsButtonElement::MediaControlToggleClosedCaptionsButtonElement(Document&amp; document, MediaControls* controls)
 628     : MediaControlInputElement(document, MediaShowClosedCaptionsButton)
 629 #if PLATFORM(COCOA) || PLATFORM(WIN) || PLATFORM(GTK)
 630     , m_controls(controls)
 631 #endif
 632 {
 633 #if !PLATFORM(COCOA) &amp;&amp; !PLATFORM(WIN) || !PLATFORM(GTK)
 634     UNUSED_PARAM(controls);
 635 #endif
<span class="line-modified"> 636     setPseudo(AtomicString(&quot;-webkit-media-controls-toggle-closed-captions-button&quot;, AtomicString::ConstructFromLiteral));</span>
 637 }
 638 
 639 Ref&lt;MediaControlToggleClosedCaptionsButtonElement&gt; MediaControlToggleClosedCaptionsButtonElement::create(Document&amp; document, MediaControls* controls)
 640 {
 641     ASSERT(controls);
 642 
 643     Ref&lt;MediaControlToggleClosedCaptionsButtonElement&gt; button = adoptRef(*new MediaControlToggleClosedCaptionsButtonElement(document, controls));
 644     button-&gt;ensureUserAgentShadowRoot();
 645     button-&gt;setType(&quot;button&quot;);
 646     button-&gt;hide();
 647     return button;
 648 }
 649 
 650 void MediaControlToggleClosedCaptionsButtonElement::updateDisplayType()
 651 {
 652     bool captionsVisible = mediaController()-&gt;closedCaptionsVisible();
 653     setDisplayType(captionsVisible ? MediaHideClosedCaptionsButton : MediaShowClosedCaptionsButton);
 654     setChecked(captionsVisible);
 655 }
 656 
</pre>
<hr />
<pre>
 662         // we have to use #if.
 663         // https://bugs.webkit.org/show_bug.cgi?id=101877
 664 #if !PLATFORM(COCOA) &amp;&amp; !PLATFORM(WIN) &amp;&amp; !PLATFORM(GTK)
 665         mediaController()-&gt;setClosedCaptionsVisible(!mediaController()-&gt;closedCaptionsVisible());
 666         setChecked(mediaController()-&gt;closedCaptionsVisible());
 667         updateDisplayType();
 668 #else
 669         m_controls-&gt;toggleClosedCaptionTrackList();
 670 #endif
 671         event.setDefaultHandled();
 672     }
 673 
 674     HTMLInputElement::defaultEventHandler(event);
 675 }
 676 
 677 // ----------------------------
 678 
 679 MediaControlClosedCaptionsContainerElement::MediaControlClosedCaptionsContainerElement(Document&amp; document)
 680     : MediaControlDivElement(document, MediaClosedCaptionsContainer)
 681 {
<span class="line-modified"> 682     setPseudo(AtomicString(&quot;-webkit-media-controls-closed-captions-container&quot;, AtomicString::ConstructFromLiteral));</span>
 683 }
 684 
 685 Ref&lt;MediaControlClosedCaptionsContainerElement&gt; MediaControlClosedCaptionsContainerElement::create(Document&amp; document)
 686 {
 687     Ref&lt;MediaControlClosedCaptionsContainerElement&gt; element = adoptRef(*new MediaControlClosedCaptionsContainerElement(document));
<span class="line-modified"> 688     element-&gt;setAttributeWithoutSynchronization(dirAttr, AtomicString(&quot;auto&quot;, AtomicString::ConstructFromLiteral));</span>
 689     element-&gt;hide();
 690     return element;
 691 }
 692 
 693 // ----------------------------
 694 
 695 MediaControlClosedCaptionsTrackListElement::MediaControlClosedCaptionsTrackListElement(Document&amp; document, MediaControls* controls)
 696     : MediaControlDivElement(document, MediaClosedCaptionsTrackList)
 697 #if ENABLE(VIDEO_TRACK)
 698     , m_controls(controls)
 699 #endif
 700 {
 701 #if !ENABLE(VIDEO_TRACK)
 702     UNUSED_PARAM(controls);
 703 #endif
<span class="line-modified"> 704     setPseudo(AtomicString(&quot;-webkit-media-controls-closed-captions-track-list&quot;, AtomicString::ConstructFromLiteral));</span>
 705 }
 706 
 707 Ref&lt;MediaControlClosedCaptionsTrackListElement&gt; MediaControlClosedCaptionsTrackListElement::create(Document&amp; document, MediaControls* controls)
 708 {
 709     ASSERT(controls);
 710     Ref&lt;MediaControlClosedCaptionsTrackListElement&gt; element = adoptRef(*new MediaControlClosedCaptionsTrackListElement(document, controls));
 711     return element;
 712 }
 713 
 714 void MediaControlClosedCaptionsTrackListElement::defaultEventHandler(Event&amp; event)
 715 {
 716 #if ENABLE(VIDEO_TRACK)
 717     if (event.type() == eventNames().clickEvent) {
 718         if (!is&lt;Element&gt;(event.target()))
 719             return;
 720 
 721         // When we created the elements in the track list, we gave them a custom
 722         // attribute representing the index in the HTMLMediaElement&#39;s list of tracks.
 723         // Check if the event target has such a custom element and, if so,
 724         // tell the HTMLMediaElement to enable that track.
</pre>
<hr />
<pre>
 730             return;
 731 
 732         auto mediaElement = parentMediaElement(this);
 733         if (!mediaElement)
 734             return;
 735 
 736         mediaElement-&gt;setSelectedTextTrack(textTrack.get());
 737 
 738         updateDisplay();
 739     }
 740 
 741     MediaControlDivElement::defaultEventHandler(event);
 742 #else
 743     UNUSED_PARAM(event);
 744 #endif
 745 }
 746 
 747 void MediaControlClosedCaptionsTrackListElement::updateDisplay()
 748 {
 749 #if ENABLE(VIDEO_TRACK)
<span class="line-modified"> 750     static NeverDestroyed&lt;AtomicString&gt; selectedClassValue(&quot;selected&quot;, AtomicString::ConstructFromLiteral);</span>
 751 
 752     if (!mediaController()-&gt;hasClosedCaptions())
 753         return;
 754 
 755     if (!document().page())
 756         return;
 757     CaptionUserPreferences::CaptionDisplayMode displayMode = document().page()-&gt;group().captionPreferences().captionDisplayMode();
 758 
 759     auto mediaElement = parentMediaElement(this);
 760     if (!mediaElement)
 761         return;
 762 
 763     if (!mediaElement-&gt;textTracks() || !mediaElement-&gt;textTracks()-&gt;length())
 764         return;
 765 
 766     rebuildTrackListMenu();
 767 
 768     RefPtr&lt;Element&gt; offMenuItem;
 769     bool trackMenuItemSelected = false;
 770 
</pre>
<hr />
<pre>
 836     auto captionsMenuList = HTMLUListElement::create(document());
 837 
 838     for (auto&amp; textTrack : tracksForMenu) {
 839         auto menuItem = HTMLLIElement::create(document());
 840         menuItem-&gt;appendChild(document().createTextNode(captionPreferences.displayNameForTrack(textTrack.get())));
 841         captionsMenuList-&gt;appendChild(menuItem);
 842         m_menuItems.append(menuItem.ptr());
 843         m_menuToTrackMap.add(menuItem.ptr(), textTrack);
 844     }
 845 
 846     appendChild(captionsMenuList);
 847 #endif
 848 }
 849 
 850 // ----------------------------
 851 
 852 MediaControlTimelineElement::MediaControlTimelineElement(Document&amp; document, MediaControls* controls)
 853     : MediaControlInputElement(document, MediaSlider)
 854     , m_controls(controls)
 855 {
<span class="line-modified"> 856     setPseudo(AtomicString(&quot;-webkit-media-controls-timeline&quot;, AtomicString::ConstructFromLiteral));</span>
 857 }
 858 
 859 Ref&lt;MediaControlTimelineElement&gt; MediaControlTimelineElement::create(Document&amp; document, MediaControls* controls)
 860 {
 861     ASSERT(controls);
 862 
 863     Ref&lt;MediaControlTimelineElement&gt; timeline = adoptRef(*new MediaControlTimelineElement(document, controls));
 864     timeline-&gt;ensureUserAgentShadowRoot();
 865     timeline-&gt;setType(&quot;range&quot;);
<span class="line-modified"> 866     timeline-&gt;setAttributeWithoutSynchronization(precisionAttr, AtomicString(&quot;float&quot;, AtomicString::ConstructFromLiteral));</span>
 867     return timeline;
 868 }
 869 
 870 void MediaControlTimelineElement::defaultEventHandler(Event&amp; event)
 871 {
 872     // Left button is 0. Rejects mouse events not from left button.
 873     if (is&lt;MouseEvent&gt;(event) &amp;&amp; downcast&lt;MouseEvent&gt;(event).button())
 874         return;
 875 
 876     if (!renderer())
 877         return;
 878 
 879     if (event.type() == eventNames().mousedownEvent)
 880         mediaController()-&gt;beginScrubbing();
 881 
 882     if (event.type() == eventNames().mouseupEvent)
 883         mediaController()-&gt;endScrubbing();
 884 
 885     MediaControlInputElement::defaultEventHandler(event);
 886 
</pre>
<hr />
<pre>
 891     if ((event.isInputEvent() || event.type() == eventNames().inputEvent) &amp;&amp; time != mediaController()-&gt;currentTime())
 892         mediaController()-&gt;setCurrentTime(time);
 893 
 894     RenderSlider&amp; slider = downcast&lt;RenderSlider&gt;(*renderer());
 895     if (slider.inDragMode())
 896         m_controls-&gt;updateCurrentTimeDisplay();
 897 }
 898 
 899 #if !PLATFORM(IOS_FAMILY)
 900 bool MediaControlTimelineElement::willRespondToMouseClickEvents()
 901 {
 902     if (!renderer())
 903         return false;
 904 
 905     return true;
 906 }
 907 #endif // !PLATFORM(IOS_FAMILY)
 908 
 909 void MediaControlTimelineElement::setPosition(double currentTime)
 910 {
<span class="line-modified"> 911     setValue(String::numberToStringECMAScript(currentTime));</span>
 912 }
 913 
 914 void MediaControlTimelineElement::setDuration(double duration)
 915 {
<span class="line-modified"> 916     setAttribute(maxAttr, AtomicString::number(duration));</span>
 917 }
 918 
 919 // ----------------------------
 920 
 921 MediaControlPanelVolumeSliderElement::MediaControlPanelVolumeSliderElement(Document&amp; document)
 922     : MediaControlVolumeSliderElement(document)
 923 {
<span class="line-modified"> 924     setPseudo(AtomicString(&quot;-webkit-media-controls-volume-slider&quot;, AtomicString::ConstructFromLiteral));</span>
 925 }
 926 
 927 Ref&lt;MediaControlPanelVolumeSliderElement&gt; MediaControlPanelVolumeSliderElement::create(Document&amp; document)
 928 {
 929     Ref&lt;MediaControlPanelVolumeSliderElement&gt; slider = adoptRef(*new MediaControlPanelVolumeSliderElement(document));
 930     slider-&gt;ensureUserAgentShadowRoot();
 931     slider-&gt;setType(&quot;range&quot;);
<span class="line-modified"> 932     slider-&gt;setAttributeWithoutSynchronization(precisionAttr, AtomicString(&quot;float&quot;, AtomicString::ConstructFromLiteral));</span>
<span class="line-modified"> 933     slider-&gt;setAttributeWithoutSynchronization(maxAttr, AtomicString(&quot;1&quot;, AtomicString::ConstructFromLiteral));</span>
 934     return slider;
 935 }
 936 
 937 // ----------------------------
 938 
 939 MediaControlFullscreenVolumeSliderElement::MediaControlFullscreenVolumeSliderElement(Document&amp; document)
 940     : MediaControlVolumeSliderElement(document)
 941 {
<span class="line-modified"> 942     setPseudo(AtomicString(&quot;-webkit-media-controls-fullscreen-volume-slider&quot;, AtomicString::ConstructFromLiteral));</span>
 943 }
 944 
 945 Ref&lt;MediaControlFullscreenVolumeSliderElement&gt; MediaControlFullscreenVolumeSliderElement::create(Document&amp; document)
 946 {
 947     Ref&lt;MediaControlFullscreenVolumeSliderElement&gt; slider = adoptRef(*new MediaControlFullscreenVolumeSliderElement(document));
 948     slider-&gt;ensureUserAgentShadowRoot();
 949     slider-&gt;setType(&quot;range&quot;);
<span class="line-modified"> 950     slider-&gt;setAttributeWithoutSynchronization(precisionAttr, AtomicString(&quot;float&quot;, AtomicString::ConstructFromLiteral));</span>
<span class="line-modified"> 951     slider-&gt;setAttributeWithoutSynchronization(maxAttr, AtomicString(&quot;1&quot;, AtomicString::ConstructFromLiteral));</span>
 952     return slider;
 953 }
 954 
 955 // ----------------------------
 956 
 957 MediaControlFullscreenButtonElement::MediaControlFullscreenButtonElement(Document&amp; document)
 958     : MediaControlInputElement(document, MediaEnterFullscreenButton)
 959 {
<span class="line-modified"> 960     setPseudo(AtomicString(&quot;-webkit-media-controls-fullscreen-button&quot;, AtomicString::ConstructFromLiteral));</span>
 961 }
 962 
 963 Ref&lt;MediaControlFullscreenButtonElement&gt; MediaControlFullscreenButtonElement::create(Document&amp; document)
 964 {
 965     Ref&lt;MediaControlFullscreenButtonElement&gt; button = adoptRef(*new MediaControlFullscreenButtonElement(document));
 966     button-&gt;ensureUserAgentShadowRoot();
 967     button-&gt;setType(&quot;button&quot;);
 968     button-&gt;hide();
 969     return button;
 970 }
 971 
 972 void MediaControlFullscreenButtonElement::defaultEventHandler(Event&amp; event)
 973 {
 974     if (event.type() == eventNames().clickEvent) {
 975 #if ENABLE(FULLSCREEN_API)
 976         // Only use the new full screen API if the fullScreenEnabled setting has
 977         // been explicitly enabled. Otherwise, use the old fullscreen API. This
 978         // allows apps which embed a WebView to retain the existing full screen
 979         // video implementation without requiring them to implement their own full
 980         // screen behavior.
 981         if (document().settings().fullScreenEnabled()) {
<span class="line-modified"> 982             if (document().webkitIsFullScreen() &amp;&amp; document().webkitCurrentFullScreenElement() == parentMediaElement(this))</span>
<span class="line-modified"> 983                 document().webkitCancelFullScreen();</span>
 984             else
<span class="line-modified"> 985                 document().requestFullScreenForElement(parentMediaElement(this).get(), Document::ExemptIFrameAllowFullScreenRequirement);</span>
 986         } else
 987 #endif
 988             mediaController()-&gt;enterFullscreen();
 989         event.setDefaultHandled();
 990     }
 991     HTMLInputElement::defaultEventHandler(event);
 992 }
 993 
 994 void MediaControlFullscreenButtonElement::setIsFullscreen(bool isFullscreen)
 995 {
 996     setDisplayType(isFullscreen ? MediaExitFullscreenButton : MediaEnterFullscreenButton);
 997 }
 998 
 999 // ----------------------------
1000 
1001 MediaControlFullscreenVolumeMinButtonElement::MediaControlFullscreenVolumeMinButtonElement(Document&amp; document)
1002     : MediaControlInputElement(document, MediaUnMuteButton)
1003 {
<span class="line-modified">1004     setPseudo(AtomicString(&quot;-webkit-media-controls-fullscreen-volume-min-button&quot;, AtomicString::ConstructFromLiteral));</span>
1005 }
1006 
1007 Ref&lt;MediaControlFullscreenVolumeMinButtonElement&gt; MediaControlFullscreenVolumeMinButtonElement::create(Document&amp; document)
1008 {
1009     Ref&lt;MediaControlFullscreenVolumeMinButtonElement&gt; button = adoptRef(*new MediaControlFullscreenVolumeMinButtonElement(document));
1010     button-&gt;ensureUserAgentShadowRoot();
1011     button-&gt;setType(&quot;button&quot;);
1012     return button;
1013 }
1014 
1015 void MediaControlFullscreenVolumeMinButtonElement::defaultEventHandler(Event&amp; event)
1016 {
1017     if (event.type() == eventNames().clickEvent) {
1018         mediaController()-&gt;setVolume(0);
1019         event.setDefaultHandled();
1020     }
1021     HTMLInputElement::defaultEventHandler(event);
1022 }
1023 
1024 // ----------------------------
1025 
1026 MediaControlFullscreenVolumeMaxButtonElement::MediaControlFullscreenVolumeMaxButtonElement(Document&amp; document)
1027 : MediaControlInputElement(document, MediaMuteButton)
1028 {
<span class="line-modified">1029     setPseudo(AtomicString(&quot;-webkit-media-controls-fullscreen-volume-max-button&quot;, AtomicString::ConstructFromLiteral));</span>
1030 }
1031 
1032 Ref&lt;MediaControlFullscreenVolumeMaxButtonElement&gt; MediaControlFullscreenVolumeMaxButtonElement::create(Document&amp; document)
1033 {
1034     Ref&lt;MediaControlFullscreenVolumeMaxButtonElement&gt; button = adoptRef(*new MediaControlFullscreenVolumeMaxButtonElement(document));
1035     button-&gt;ensureUserAgentShadowRoot();
1036     button-&gt;setType(&quot;button&quot;);
1037     return button;
1038 }
1039 
1040 void MediaControlFullscreenVolumeMaxButtonElement::defaultEventHandler(Event&amp; event)
1041 {
1042     if (event.type() == eventNames().clickEvent) {
1043         mediaController()-&gt;setVolume(1);
1044         event.setDefaultHandled();
1045     }
1046     HTMLInputElement::defaultEventHandler(event);
1047 }
1048 
1049 // ----------------------------
1050 
1051 MediaControlTimeRemainingDisplayElement::MediaControlTimeRemainingDisplayElement(Document&amp; document)
1052     : MediaControlTimeDisplayElement(document, MediaTimeRemainingDisplay)
1053 {
1054     setPseudo(getMediaControlTimeRemainingDisplayElementShadowPseudoId());
1055 }
1056 
1057 Ref&lt;MediaControlTimeRemainingDisplayElement&gt; MediaControlTimeRemainingDisplayElement::create(Document&amp; document)
1058 {
1059     return adoptRef(*new MediaControlTimeRemainingDisplayElement(document));
1060 }
1061 
<span class="line-modified">1062 static const AtomicString&amp; getMediaControlTimeRemainingDisplayElementShadowPseudoId()</span>
1063 {
<span class="line-modified">1064     static NeverDestroyed&lt;AtomicString&gt; id(&quot;-webkit-media-controls-time-remaining-display&quot;, AtomicString::ConstructFromLiteral);</span>
1065     return id;
1066 }
1067 
1068 // ----------------------------
1069 
1070 MediaControlCurrentTimeDisplayElement::MediaControlCurrentTimeDisplayElement(Document&amp; document)
1071     : MediaControlTimeDisplayElement(document, MediaCurrentTimeDisplay)
1072 {
1073     setPseudo(getMediaControlCurrentTimeDisplayElementShadowPseudoId());
1074 }
1075 
1076 Ref&lt;MediaControlCurrentTimeDisplayElement&gt; MediaControlCurrentTimeDisplayElement::create(Document&amp; document)
1077 {
1078     return adoptRef(*new MediaControlCurrentTimeDisplayElement(document));
1079 }
1080 
<span class="line-modified">1081 static const AtomicString&amp; getMediaControlCurrentTimeDisplayElementShadowPseudoId()</span>
1082 {
<span class="line-modified">1083     static NeverDestroyed&lt;AtomicString&gt; id(&quot;-webkit-media-controls-current-time-display&quot;, AtomicString::ConstructFromLiteral);</span>
1084     return id;
1085 }
1086 
1087 // ----------------------------
1088 
1089 #if ENABLE(VIDEO_TRACK)
1090 
1091 MediaControlTextTrackContainerElement::MediaControlTextTrackContainerElement(Document&amp; document)
1092     : MediaControlDivElement(document, MediaTextTrackDisplayContainer)
1093     , m_updateTimer(*this, &amp;MediaControlTextTrackContainerElement::updateTimerFired)
1094     , m_fontSize(0)
1095     , m_fontSizeIsImportant(false)
1096     , m_updateTextTrackRepresentationStyle(false)
1097 {
<span class="line-modified">1098     setPseudo(AtomicString(&quot;-webkit-media-text-track-container&quot;, AtomicString::ConstructFromLiteral));</span>
1099 }
1100 
1101 Ref&lt;MediaControlTextTrackContainerElement&gt; MediaControlTextTrackContainerElement::create(Document&amp; document)
1102 {
1103     auto element = adoptRef(*new MediaControlTextTrackContainerElement(document));
1104     element-&gt;hide();
1105     return element;
1106 }
1107 
1108 RenderPtr&lt;RenderElement&gt; MediaControlTextTrackContainerElement::createElementRenderer(RenderStyle&amp;&amp; style, const RenderTreePosition&amp;)
1109 {
1110     return createRenderer&lt;RenderTextTrackContainerElement&gt;(*this, WTFMove(style));
1111 }
1112 
1113 static bool compareCueIntervalForDisplay(const CueInterval&amp; one, const CueInterval&amp; two)
1114 {
1115     return one.data()-&gt;isPositionedAbove(two.data());
1116 };
1117 
1118 void MediaControlTextTrackContainerElement::updateDisplay()
</pre>
<hr />
<pre>
1155     CueList activeCues = video.currentlyActiveCues();
1156 
1157     // 9. If reset is false, then, for each text track cue cue in cues: if cue&#39;s
1158     // text track cue display state has a set of CSS boxes, then add those boxes
1159     // to output, and remove cue from cues.
1160 
1161     // There is nothing explicitly to be done here, as all the caching occurs
1162     // within the TextTrackCue instance itself. If parameters of the cue change,
1163     // the display tree is cleared.
1164 
1165     // If the number of CSS boxes in the output is less than the number of cues
1166     // we wish to render (e.g., we are adding another cue in a set of roll-up
1167     // cues), remove all the existing CSS boxes representing the cues and re-add
1168     // them so that the new cue is at the bottom.
1169     // FIXME: Calling countChildNodes() here is inefficient. We don&#39;t need to
1170     // traverse all children just to check if there are less children than cues.
1171     if (countChildNodes() &lt; activeCues.size())
1172         removeChildren();
1173 
1174     activeCues.removeAllMatching([] (CueInterval&amp; cueInterval) {
<span class="line-modified">1175         if (!cueInterval.data() || !cueInterval.data()-&gt;isRenderable())</span>
1176             return true;
1177 
<span class="line-modified">1178         RefPtr&lt;VTTCue&gt; cue = toVTTCue(cueInterval.data());</span>
1179 
1180         return !cue-&gt;isRenderable()
1181             || !cue-&gt;track()
1182             || !cue-&gt;track()-&gt;isRendered()
1183             || cue-&gt;track()-&gt;mode() == TextTrack::Mode::Disabled
1184             || !cue-&gt;isActive()
1185             || cue-&gt;text().isEmpty();
1186     });
1187 
1188     // Sort the active cues for the appropriate display order. For example, for roll-up
1189     // or paint-on captions, we need to add the cues in reverse chronological order,
1190     // so that the newest captions appear at the bottom.
1191     std::sort(activeCues.begin(), activeCues.end(), &amp;compareCueIntervalForDisplay);
1192 
1193     // 10. For each text track cue cue in cues that has not yet had
1194     // corresponding CSS boxes added to output, in text track cue order, run the
1195     // following substeps:
1196     for (size_t i = 0; i &lt; activeCues.size(); ++i) {
1197         if (!mediaController()-&gt;closedCaptionsVisible())
1198             continue;
1199 
<span class="line-modified">1200         RefPtr&lt;VTTCue&gt; cue = toVTTCue(activeCues[i].data());</span>
<span class="line-removed">1201         ASSERT(cue);</span>
<span class="line-removed">1202         if (!cue)</span>
<span class="line-removed">1203             continue;</span>
1204 
<span class="line-modified">1205         LOG(Media, &quot;MediaControlTextTrackContainerElement::updateDisplay(%p) - adding and positioning cue #%zu: \&quot;%s\&quot;, start=%.2f, end=%.2f, line=%.2f&quot;, this, i, cue-&gt;text().utf8().data(), cue-&gt;startTime(), cue-&gt;endTime(), cue-&gt;line());</span>
1206         Ref&lt;VTTCueBox&gt; displayBox = cue-&gt;getDisplayTree(m_videoDisplaySize.size(), m_fontSize);
1207         RefPtr&lt;VTTRegion&gt; region = cue-&gt;track()-&gt;regions()-&gt;getRegionById(cue-&gt;regionId());
1208         if (!region) {
1209             // If cue has an empty text track cue region identifier or there is no
1210             // WebVTT region whose region identifier is identical to cue&#39;s text
1211             // track cue region identifier, run the following substeps:
1212             if (displayBox-&gt;hasChildNodes() &amp;&amp; !contains(displayBox.ptr())) {
1213                 // Note: the display tree of a cue is removed when the active flag of the cue is unset.
1214                 appendChild(displayBox);
1215                 cue-&gt;setFontSize(m_fontSize, m_videoDisplaySize.size(), m_fontSizeIsImportant);
1216             }
1217         } else {
1218             // Let region be the WebVTT region whose region identifier
1219             // matches the text track cue region identifier of cue.
1220             Ref&lt;HTMLDivElement&gt; regionNode = region-&gt;getDisplayTree();
1221 
1222             // Append the region to the viewport, if it was not already.
1223             if (!contains(regionNode.ptr()))
1224                 appendChild(region-&gt;getDisplayTree());
1225 
</pre>
<hr />
<pre>
1437 
1438     IntRect paintingRect = IntRect(IntPoint(), layer-&gt;size());
1439 
1440     // FIXME (149422): This buffer should not be unconditionally unaccelerated.
1441     std::unique_ptr&lt;ImageBuffer&gt; buffer(ImageBuffer::create(paintingRect.size(), Unaccelerated, deviceScaleFactor));
1442     if (!buffer)
1443         return nullptr;
1444 
1445     layer-&gt;paint(buffer-&gt;context(), paintingRect, LayoutSize(), { PaintBehavior::FlattenCompositingLayers, PaintBehavior::Snapshotting }, nullptr, RenderLayer::paintLayerPaintingCompositingAllPhasesFlags());
1446 
1447     return ImageBuffer::sinkIntoImage(WTFMove(buffer));
1448 }
1449 
1450 void MediaControlTextTrackContainerElement::textTrackRepresentationBoundsChanged(const IntRect&amp;)
1451 {
1452     if (hasChildNodes())
1453         updateTextTrackRepresentation();
1454     updateSizes();
1455 }
1456 



















1457 #endif // ENABLE(VIDEO_TRACK)
1458 
1459 // ----------------------------
1460 
1461 } // namespace WebCore
1462 
1463 #endif // ENABLE(VIDEO)
</pre>
</td>
<td>
<hr />
<pre>
  20  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  21  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  22  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  23  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  24  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  25  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  26  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  27  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  28  */
  29 
  30 #include &quot;config.h&quot;
  31 #include &quot;MediaControlElements.h&quot;
  32 
  33 #if ENABLE(VIDEO)
  34 
  35 #include &quot;DOMTokenList.h&quot;
  36 #include &quot;ElementChildIterator.h&quot;
  37 #include &quot;EventHandler.h&quot;
  38 #include &quot;EventNames.h&quot;
  39 #include &quot;Frame.h&quot;
<span class="line-added">  40 #include &quot;FullscreenManager.h&quot;</span>
  41 #include &quot;GraphicsContext.h&quot;
  42 #include &quot;HTMLHeadingElement.h&quot;
  43 #include &quot;HTMLLIElement.h&quot;
  44 #include &quot;HTMLUListElement.h&quot;
  45 #include &quot;HTMLVideoElement.h&quot;
  46 #include &quot;ImageBuffer.h&quot;
  47 #include &quot;LocalizedStrings.h&quot;
  48 #include &quot;Logging.h&quot;
  49 #include &quot;MediaControls.h&quot;
  50 #include &quot;MouseEvent.h&quot;
  51 #include &quot;Page.h&quot;
  52 #include &quot;PageGroup.h&quot;
  53 #include &quot;RenderLayer.h&quot;
  54 #include &quot;RenderMediaControlElements.h&quot;
  55 #include &quot;RenderSlider.h&quot;
  56 #include &quot;RenderTheme.h&quot;
  57 #include &quot;RenderVideo.h&quot;
  58 #include &quot;RenderView.h&quot;
  59 #include &quot;Settings.h&quot;
  60 #include &quot;ShadowRoot.h&quot;
</pre>
<hr />
<pre>
  77 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlOverlayPlayButtonElement);
  78 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlSeekForwardButtonElement);
  79 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlSeekBackButtonElement);
  80 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlRewindButtonElement);
  81 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlReturnToRealtimeButtonElement);
  82 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlToggleClosedCaptionsButtonElement);
  83 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlClosedCaptionsContainerElement);
  84 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlClosedCaptionsTrackListElement);
  85 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlTimelineElement);
  86 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlFullscreenButtonElement);
  87 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlPanelVolumeSliderElement);
  88 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlFullscreenVolumeSliderElement);
  89 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlFullscreenVolumeMinButtonElement);
  90 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlFullscreenVolumeMaxButtonElement);
  91 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlTimeRemainingDisplayElement);
  92 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlCurrentTimeDisplayElement);
  93 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlTextTrackContainerElement);
  94 
  95 using namespace HTMLNames;
  96 
<span class="line-modified">  97 static const AtomString&amp; getMediaControlCurrentTimeDisplayElementShadowPseudoId();</span>
<span class="line-modified">  98 static const AtomString&amp; getMediaControlTimeRemainingDisplayElementShadowPseudoId();</span>
  99 
 100 MediaControlPanelElement::MediaControlPanelElement(Document&amp; document)
 101     : MediaControlDivElement(document, MediaControlsPanel)
 102     , m_canBeDragged(false)
 103     , m_isBeingDragged(false)
 104     , m_isDisplayed(false)
 105     , m_opaque(true)
 106     , m_transitionTimer(*this, &amp;MediaControlPanelElement::transitionTimerFired)
 107 {
<span class="line-modified"> 108     setPseudo(AtomString(&quot;-webkit-media-controls-panel&quot;, AtomString::ConstructFromLiteral));</span>
 109 }
 110 
 111 Ref&lt;MediaControlPanelElement&gt; MediaControlPanelElement::create(Document&amp; document)
 112 {
 113     return adoptRef(*new MediaControlPanelElement(document));
 114 }
 115 
 116 void MediaControlPanelElement::startDrag(const LayoutPoint&amp; eventLocation)
 117 {
 118     if (!m_canBeDragged)
 119         return;
 120 
 121     if (m_isBeingDragged)
 122         return;
 123 
 124     auto renderer = this-&gt;renderer();
 125     if (!renderer || !renderer-&gt;isBox())
 126         return;
 127 
 128     RefPtr&lt;Frame&gt; frame = document().frame();
</pre>
<hr />
<pre>
 270     if (m_canBeDragged == canBeDragged)
 271         return;
 272 
 273     m_canBeDragged = canBeDragged;
 274 
 275     if (!canBeDragged)
 276         endDrag();
 277 }
 278 
 279 void MediaControlPanelElement::setIsDisplayed(bool isDisplayed)
 280 {
 281     m_isDisplayed = isDisplayed;
 282 }
 283 
 284 // ----------------------------
 285 
 286 MediaControlPanelEnclosureElement::MediaControlPanelEnclosureElement(Document&amp; document)
 287     // Mapping onto same MediaControlElementType as panel element, since it has similar properties.
 288     : MediaControlDivElement(document, MediaControlsPanel)
 289 {
<span class="line-modified"> 290     setPseudo(AtomString(&quot;-webkit-media-controls-enclosure&quot;, AtomString::ConstructFromLiteral));</span>
 291 }
 292 
 293 Ref&lt;MediaControlPanelEnclosureElement&gt; MediaControlPanelEnclosureElement::create(Document&amp; document)
 294 {
 295     return adoptRef(*new MediaControlPanelEnclosureElement(document));
 296 }
 297 
 298 // ----------------------------
 299 
 300 MediaControlOverlayEnclosureElement::MediaControlOverlayEnclosureElement(Document&amp; document)
 301     // Mapping onto same MediaControlElementType as panel element, since it has similar properties.
 302     : MediaControlDivElement(document, MediaControlsPanel)
 303 {
<span class="line-modified"> 304     setPseudo(AtomString(&quot;-webkit-media-controls-overlay-enclosure&quot;, AtomString::ConstructFromLiteral));</span>
 305 }
 306 
 307 Ref&lt;MediaControlOverlayEnclosureElement&gt; MediaControlOverlayEnclosureElement::create(Document&amp; document)
 308 {
 309     return adoptRef(*new MediaControlOverlayEnclosureElement(document));
 310 }
 311 
 312 // ----------------------------
 313 
 314 MediaControlTimelineContainerElement::MediaControlTimelineContainerElement(Document&amp; document)
 315     : MediaControlDivElement(document, MediaTimelineContainer)
 316 {
<span class="line-modified"> 317     setPseudo(AtomString(&quot;-webkit-media-controls-timeline-container&quot;, AtomString::ConstructFromLiteral));</span>
 318 }
 319 
 320 Ref&lt;MediaControlTimelineContainerElement&gt; MediaControlTimelineContainerElement::create(Document&amp; document)
 321 {
 322     Ref&lt;MediaControlTimelineContainerElement&gt; element = adoptRef(*new MediaControlTimelineContainerElement(document));
 323     element-&gt;hide();
 324     return element;
 325 }
 326 
 327 void MediaControlTimelineContainerElement::setTimeDisplaysHidden(bool hidden)
 328 {
 329     for (auto&amp; element : childrenOfType&lt;Element&gt;(*this)) {
 330         if (element.shadowPseudoId() != getMediaControlTimeRemainingDisplayElementShadowPseudoId()
 331             &amp;&amp; element.shadowPseudoId() != getMediaControlCurrentTimeDisplayElementShadowPseudoId())
 332             continue;
 333 
 334         MediaControlTimeDisplayElement&amp; timeDisplay = static_cast&lt;MediaControlTimeDisplayElement&amp;&gt;(element);
 335         if (hidden)
 336             timeDisplay.hide();
 337         else
 338             timeDisplay.show();
 339     }
 340 }
 341 
 342 RenderPtr&lt;RenderElement&gt; MediaControlTimelineContainerElement::createElementRenderer(RenderStyle&amp;&amp; style, const RenderTreePosition&amp;)
 343 {
 344     return createRenderer&lt;RenderMediaControlTimelineContainer&gt;(*this, WTFMove(style));
 345 }
 346 
 347 // ----------------------------
 348 
 349 MediaControlVolumeSliderContainerElement::MediaControlVolumeSliderContainerElement(Document&amp; document)
 350     : MediaControlDivElement(document, MediaVolumeSliderContainer)
 351 {
<span class="line-modified"> 352     setPseudo(AtomString(&quot;-webkit-media-controls-volume-slider-container&quot;, AtomString::ConstructFromLiteral));</span>
 353 }
 354 
 355 Ref&lt;MediaControlVolumeSliderContainerElement&gt; MediaControlVolumeSliderContainerElement::create(Document&amp; document)
 356 {
 357     Ref&lt;MediaControlVolumeSliderContainerElement&gt; element = adoptRef(*new MediaControlVolumeSliderContainerElement(document));
 358     element-&gt;hide();
 359     return element;
 360 }
 361 
 362 RenderPtr&lt;RenderElement&gt; MediaControlVolumeSliderContainerElement::createElementRenderer(RenderStyle&amp;&amp; style, const RenderTreePosition&amp;)
 363 {
 364     return createRenderer&lt;RenderMediaVolumeSliderContainer&gt;(*this, WTFMove(style));
 365 }
 366 
 367 void MediaControlVolumeSliderContainerElement::defaultEventHandler(Event&amp; event)
 368 {
 369     // Poor man&#39;s mouseleave event detection.
 370 
 371     if (!is&lt;MouseEvent&gt;(event) || event.type() != eventNames().mouseoutEvent)
 372         return;
 373 
 374     if (!is&lt;Node&gt;(downcast&lt;MouseEvent&gt;(event).relatedTarget()))
 375         return;
 376 
 377     if (containsIncludingShadowDOM(&amp;downcast&lt;Node&gt;(*downcast&lt;MouseEvent&gt;(event).relatedTarget())))
 378         return;
 379 
 380     hide();
 381 }
 382 
 383 // ----------------------------
 384 
 385 MediaControlStatusDisplayElement::MediaControlStatusDisplayElement(Document&amp; document)
 386     : MediaControlDivElement(document, MediaStatusDisplay)
 387     , m_stateBeingDisplayed(Nothing)
 388 {
<span class="line-modified"> 389     setPseudo(AtomString(&quot;-webkit-media-controls-status-display&quot;, AtomString::ConstructFromLiteral));</span>
 390 }
 391 
 392 Ref&lt;MediaControlStatusDisplayElement&gt; MediaControlStatusDisplayElement::create(Document&amp; document)
 393 {
 394     Ref&lt;MediaControlStatusDisplayElement&gt; element = adoptRef(*new MediaControlStatusDisplayElement(document));
 395     element-&gt;hide();
 396     return element;
 397 }
 398 
 399 void MediaControlStatusDisplayElement::update()
 400 {
 401     // Get the new state that we&#39;ll have to display.
 402     StateBeingDisplayed newStateToDisplay = Nothing;
 403 
 404     if (mediaController()-&gt;readyState() &lt;= MediaControllerInterface::HAVE_METADATA &amp;&amp; mediaController()-&gt;hasCurrentSrc())
 405         newStateToDisplay = Loading;
 406     else if (mediaController()-&gt;isLiveStream())
 407         newStateToDisplay = LiveBroadcast;
 408 
 409     if (newStateToDisplay == m_stateBeingDisplayed)
</pre>
<hr />
<pre>
 418 
 419     switch (m_stateBeingDisplayed) {
 420     case Nothing:
 421         setInnerText(emptyString());
 422         break;
 423     case Loading:
 424         setInnerText(mediaElementLoadingStateText());
 425         break;
 426     case LiveBroadcast:
 427         setInnerText(mediaElementLiveBroadcastStateText());
 428         break;
 429     }
 430 }
 431 
 432 // ----------------------------
 433 
 434 MediaControlPanelMuteButtonElement::MediaControlPanelMuteButtonElement(Document&amp; document, MediaControls* controls)
 435     : MediaControlMuteButtonElement(document, MediaMuteButton)
 436     , m_controls(controls)
 437 {
<span class="line-modified"> 438     setPseudo(AtomString(&quot;-webkit-media-controls-mute-button&quot;, AtomString::ConstructFromLiteral));</span>
 439 }
 440 
 441 Ref&lt;MediaControlPanelMuteButtonElement&gt; MediaControlPanelMuteButtonElement::create(Document&amp; document, MediaControls* controls)
 442 {
 443     ASSERT(controls);
 444 
 445     Ref&lt;MediaControlPanelMuteButtonElement&gt; button = adoptRef(*new MediaControlPanelMuteButtonElement(document, controls));
 446     button-&gt;ensureUserAgentShadowRoot();
 447     button-&gt;setType(&quot;button&quot;);
 448     return button;
 449 }
 450 
 451 void MediaControlPanelMuteButtonElement::defaultEventHandler(Event&amp; event)
 452 {
 453     if (event.type() == eventNames().mouseoverEvent)
 454         m_controls-&gt;showVolumeSlider();
 455 
 456     MediaControlMuteButtonElement::defaultEventHandler(event);
 457 }
 458 
 459 // ----------------------------
 460 
 461 MediaControlVolumeSliderMuteButtonElement::MediaControlVolumeSliderMuteButtonElement(Document&amp; document)
 462     : MediaControlMuteButtonElement(document, MediaMuteButton)
 463 {
<span class="line-modified"> 464     setPseudo(AtomString(&quot;-webkit-media-controls-volume-slider-mute-button&quot;, AtomString::ConstructFromLiteral));</span>
 465 }
 466 
 467 Ref&lt;MediaControlVolumeSliderMuteButtonElement&gt; MediaControlVolumeSliderMuteButtonElement::create(Document&amp; document)
 468 {
 469     Ref&lt;MediaControlVolumeSliderMuteButtonElement&gt; button = adoptRef(*new MediaControlVolumeSliderMuteButtonElement(document));
 470     button-&gt;ensureUserAgentShadowRoot();
 471     button-&gt;setType(&quot;button&quot;);
 472     return button;
 473 }
 474 
 475 // ----------------------------
 476 
 477 MediaControlPlayButtonElement::MediaControlPlayButtonElement(Document&amp; document)
 478     : MediaControlInputElement(document, MediaPlayButton)
 479 {
<span class="line-modified"> 480     setPseudo(AtomString(&quot;-webkit-media-controls-play-button&quot;, AtomString::ConstructFromLiteral));</span>
 481 }
 482 
 483 Ref&lt;MediaControlPlayButtonElement&gt; MediaControlPlayButtonElement::create(Document&amp; document)
 484 {
 485     Ref&lt;MediaControlPlayButtonElement&gt; button = adoptRef(*new MediaControlPlayButtonElement(document));
 486     button-&gt;ensureUserAgentShadowRoot();
 487     button-&gt;setType(&quot;button&quot;);
 488     return button;
 489 }
 490 
 491 void MediaControlPlayButtonElement::defaultEventHandler(Event&amp; event)
 492 {
 493     if (event.type() == eventNames().clickEvent) {
 494         if (mediaController()-&gt;canPlay())
 495             mediaController()-&gt;play();
 496         else
 497             mediaController()-&gt;pause();
 498         updateDisplayType();
 499         event.setDefaultHandled();
 500     }
 501     HTMLInputElement::defaultEventHandler(event);
 502 }
 503 
 504 void MediaControlPlayButtonElement::updateDisplayType()
 505 {
 506     setDisplayType(mediaController()-&gt;canPlay() ? MediaPlayButton : MediaPauseButton);
 507 }
 508 
 509 // ----------------------------
 510 
 511 MediaControlOverlayPlayButtonElement::MediaControlOverlayPlayButtonElement(Document&amp; document)
 512     : MediaControlInputElement(document, MediaOverlayPlayButton)
 513 {
<span class="line-modified"> 514     setPseudo(AtomString(&quot;-webkit-media-controls-overlay-play-button&quot;, AtomString::ConstructFromLiteral));</span>
 515 }
 516 
 517 Ref&lt;MediaControlOverlayPlayButtonElement&gt; MediaControlOverlayPlayButtonElement::create(Document&amp; document)
 518 {
 519     Ref&lt;MediaControlOverlayPlayButtonElement&gt; button = adoptRef(*new MediaControlOverlayPlayButtonElement(document));
 520     button-&gt;ensureUserAgentShadowRoot();
 521     button-&gt;setType(&quot;button&quot;);
 522     return button;
 523 }
 524 
 525 void MediaControlOverlayPlayButtonElement::defaultEventHandler(Event&amp; event)
 526 {
 527     if (event.type() == eventNames().clickEvent &amp;&amp; mediaController()-&gt;canPlay()) {
 528         mediaController()-&gt;play();
 529         updateDisplayType();
 530         event.setDefaultHandled();
 531     }
 532     HTMLInputElement::defaultEventHandler(event);
 533 }
 534 
 535 void MediaControlOverlayPlayButtonElement::updateDisplayType()
 536 {
 537     if (mediaController()-&gt;canPlay()) {
 538         show();
 539     } else
 540         hide();
 541 }
 542 
 543 // ----------------------------
 544 
 545 MediaControlSeekForwardButtonElement::MediaControlSeekForwardButtonElement(Document&amp; document)
 546     : MediaControlSeekButtonElement(document, MediaSeekForwardButton)
 547 {
<span class="line-modified"> 548     setPseudo(AtomString(&quot;-webkit-media-controls-seek-forward-button&quot;, AtomString::ConstructFromLiteral));</span>
 549 }
 550 
 551 Ref&lt;MediaControlSeekForwardButtonElement&gt; MediaControlSeekForwardButtonElement::create(Document&amp; document)
 552 {
 553     Ref&lt;MediaControlSeekForwardButtonElement&gt; button = adoptRef(*new MediaControlSeekForwardButtonElement(document));
 554     button-&gt;ensureUserAgentShadowRoot();
 555     button-&gt;setType(&quot;button&quot;);
 556     return button;
 557 }
 558 
 559 // ----------------------------
 560 
 561 MediaControlSeekBackButtonElement::MediaControlSeekBackButtonElement(Document&amp; document)
 562     : MediaControlSeekButtonElement(document, MediaSeekBackButton)
 563 {
<span class="line-modified"> 564     setPseudo(AtomString(&quot;-webkit-media-controls-seek-back-button&quot;, AtomString::ConstructFromLiteral));</span>
 565 }
 566 
 567 Ref&lt;MediaControlSeekBackButtonElement&gt; MediaControlSeekBackButtonElement::create(Document&amp; document)
 568 {
 569     Ref&lt;MediaControlSeekBackButtonElement&gt; button = adoptRef(*new MediaControlSeekBackButtonElement(document));
 570     button-&gt;ensureUserAgentShadowRoot();
 571     button-&gt;setType(&quot;button&quot;);
 572     return button;
 573 }
 574 
 575 // ----------------------------
 576 
 577 MediaControlRewindButtonElement::MediaControlRewindButtonElement(Document&amp; document)
 578     : MediaControlInputElement(document, MediaRewindButton)
 579 {
<span class="line-modified"> 580     setPseudo(AtomString(&quot;-webkit-media-controls-rewind-button&quot;, AtomString::ConstructFromLiteral));</span>
 581 }
 582 
 583 Ref&lt;MediaControlRewindButtonElement&gt; MediaControlRewindButtonElement::create(Document&amp; document)
 584 {
 585     Ref&lt;MediaControlRewindButtonElement&gt; button = adoptRef(*new MediaControlRewindButtonElement(document));
 586     button-&gt;ensureUserAgentShadowRoot();
 587     button-&gt;setType(&quot;button&quot;);
 588     return button;
 589 }
 590 
 591 void MediaControlRewindButtonElement::defaultEventHandler(Event&amp; event)
 592 {
 593     if (event.type() == eventNames().clickEvent) {
 594         mediaController()-&gt;setCurrentTime(std::max&lt;double&gt;(0, mediaController()-&gt;currentTime() - 30));
 595         event.setDefaultHandled();
 596     }
 597     HTMLInputElement::defaultEventHandler(event);
 598 }
 599 
 600 // ----------------------------
 601 
 602 MediaControlReturnToRealtimeButtonElement::MediaControlReturnToRealtimeButtonElement(Document&amp; document)
 603     : MediaControlInputElement(document, MediaReturnToRealtimeButton)
 604 {
<span class="line-modified"> 605     setPseudo(AtomString(&quot;-webkit-media-controls-return-to-realtime-button&quot;, AtomString::ConstructFromLiteral));</span>
 606 }
 607 
 608 Ref&lt;MediaControlReturnToRealtimeButtonElement&gt; MediaControlReturnToRealtimeButtonElement::create(Document&amp; document)
 609 {
 610     Ref&lt;MediaControlReturnToRealtimeButtonElement&gt; button = adoptRef(*new MediaControlReturnToRealtimeButtonElement(document));
 611     button-&gt;ensureUserAgentShadowRoot();
 612     button-&gt;setType(&quot;button&quot;);
 613     button-&gt;hide();
 614     return button;
 615 }
 616 
 617 void MediaControlReturnToRealtimeButtonElement::defaultEventHandler(Event&amp; event)
 618 {
 619     if (event.type() == eventNames().clickEvent) {
 620         mediaController()-&gt;returnToRealtime();
 621         event.setDefaultHandled();
 622     }
 623     HTMLInputElement::defaultEventHandler(event);
 624 }
 625 
 626 // ----------------------------
 627 
 628 MediaControlToggleClosedCaptionsButtonElement::MediaControlToggleClosedCaptionsButtonElement(Document&amp; document, MediaControls* controls)
 629     : MediaControlInputElement(document, MediaShowClosedCaptionsButton)
 630 #if PLATFORM(COCOA) || PLATFORM(WIN) || PLATFORM(GTK)
 631     , m_controls(controls)
 632 #endif
 633 {
 634 #if !PLATFORM(COCOA) &amp;&amp; !PLATFORM(WIN) || !PLATFORM(GTK)
 635     UNUSED_PARAM(controls);
 636 #endif
<span class="line-modified"> 637     setPseudo(AtomString(&quot;-webkit-media-controls-toggle-closed-captions-button&quot;, AtomString::ConstructFromLiteral));</span>
 638 }
 639 
 640 Ref&lt;MediaControlToggleClosedCaptionsButtonElement&gt; MediaControlToggleClosedCaptionsButtonElement::create(Document&amp; document, MediaControls* controls)
 641 {
 642     ASSERT(controls);
 643 
 644     Ref&lt;MediaControlToggleClosedCaptionsButtonElement&gt; button = adoptRef(*new MediaControlToggleClosedCaptionsButtonElement(document, controls));
 645     button-&gt;ensureUserAgentShadowRoot();
 646     button-&gt;setType(&quot;button&quot;);
 647     button-&gt;hide();
 648     return button;
 649 }
 650 
 651 void MediaControlToggleClosedCaptionsButtonElement::updateDisplayType()
 652 {
 653     bool captionsVisible = mediaController()-&gt;closedCaptionsVisible();
 654     setDisplayType(captionsVisible ? MediaHideClosedCaptionsButton : MediaShowClosedCaptionsButton);
 655     setChecked(captionsVisible);
 656 }
 657 
</pre>
<hr />
<pre>
 663         // we have to use #if.
 664         // https://bugs.webkit.org/show_bug.cgi?id=101877
 665 #if !PLATFORM(COCOA) &amp;&amp; !PLATFORM(WIN) &amp;&amp; !PLATFORM(GTK)
 666         mediaController()-&gt;setClosedCaptionsVisible(!mediaController()-&gt;closedCaptionsVisible());
 667         setChecked(mediaController()-&gt;closedCaptionsVisible());
 668         updateDisplayType();
 669 #else
 670         m_controls-&gt;toggleClosedCaptionTrackList();
 671 #endif
 672         event.setDefaultHandled();
 673     }
 674 
 675     HTMLInputElement::defaultEventHandler(event);
 676 }
 677 
 678 // ----------------------------
 679 
 680 MediaControlClosedCaptionsContainerElement::MediaControlClosedCaptionsContainerElement(Document&amp; document)
 681     : MediaControlDivElement(document, MediaClosedCaptionsContainer)
 682 {
<span class="line-modified"> 683     setPseudo(AtomString(&quot;-webkit-media-controls-closed-captions-container&quot;, AtomString::ConstructFromLiteral));</span>
 684 }
 685 
 686 Ref&lt;MediaControlClosedCaptionsContainerElement&gt; MediaControlClosedCaptionsContainerElement::create(Document&amp; document)
 687 {
 688     Ref&lt;MediaControlClosedCaptionsContainerElement&gt; element = adoptRef(*new MediaControlClosedCaptionsContainerElement(document));
<span class="line-modified"> 689     element-&gt;setAttributeWithoutSynchronization(dirAttr, AtomString(&quot;auto&quot;, AtomString::ConstructFromLiteral));</span>
 690     element-&gt;hide();
 691     return element;
 692 }
 693 
 694 // ----------------------------
 695 
 696 MediaControlClosedCaptionsTrackListElement::MediaControlClosedCaptionsTrackListElement(Document&amp; document, MediaControls* controls)
 697     : MediaControlDivElement(document, MediaClosedCaptionsTrackList)
 698 #if ENABLE(VIDEO_TRACK)
 699     , m_controls(controls)
 700 #endif
 701 {
 702 #if !ENABLE(VIDEO_TRACK)
 703     UNUSED_PARAM(controls);
 704 #endif
<span class="line-modified"> 705     setPseudo(AtomString(&quot;-webkit-media-controls-closed-captions-track-list&quot;, AtomString::ConstructFromLiteral));</span>
 706 }
 707 
 708 Ref&lt;MediaControlClosedCaptionsTrackListElement&gt; MediaControlClosedCaptionsTrackListElement::create(Document&amp; document, MediaControls* controls)
 709 {
 710     ASSERT(controls);
 711     Ref&lt;MediaControlClosedCaptionsTrackListElement&gt; element = adoptRef(*new MediaControlClosedCaptionsTrackListElement(document, controls));
 712     return element;
 713 }
 714 
 715 void MediaControlClosedCaptionsTrackListElement::defaultEventHandler(Event&amp; event)
 716 {
 717 #if ENABLE(VIDEO_TRACK)
 718     if (event.type() == eventNames().clickEvent) {
 719         if (!is&lt;Element&gt;(event.target()))
 720             return;
 721 
 722         // When we created the elements in the track list, we gave them a custom
 723         // attribute representing the index in the HTMLMediaElement&#39;s list of tracks.
 724         // Check if the event target has such a custom element and, if so,
 725         // tell the HTMLMediaElement to enable that track.
</pre>
<hr />
<pre>
 731             return;
 732 
 733         auto mediaElement = parentMediaElement(this);
 734         if (!mediaElement)
 735             return;
 736 
 737         mediaElement-&gt;setSelectedTextTrack(textTrack.get());
 738 
 739         updateDisplay();
 740     }
 741 
 742     MediaControlDivElement::defaultEventHandler(event);
 743 #else
 744     UNUSED_PARAM(event);
 745 #endif
 746 }
 747 
 748 void MediaControlClosedCaptionsTrackListElement::updateDisplay()
 749 {
 750 #if ENABLE(VIDEO_TRACK)
<span class="line-modified"> 751     static NeverDestroyed&lt;AtomString&gt; selectedClassValue(&quot;selected&quot;, AtomString::ConstructFromLiteral);</span>
 752 
 753     if (!mediaController()-&gt;hasClosedCaptions())
 754         return;
 755 
 756     if (!document().page())
 757         return;
 758     CaptionUserPreferences::CaptionDisplayMode displayMode = document().page()-&gt;group().captionPreferences().captionDisplayMode();
 759 
 760     auto mediaElement = parentMediaElement(this);
 761     if (!mediaElement)
 762         return;
 763 
 764     if (!mediaElement-&gt;textTracks() || !mediaElement-&gt;textTracks()-&gt;length())
 765         return;
 766 
 767     rebuildTrackListMenu();
 768 
 769     RefPtr&lt;Element&gt; offMenuItem;
 770     bool trackMenuItemSelected = false;
 771 
</pre>
<hr />
<pre>
 837     auto captionsMenuList = HTMLUListElement::create(document());
 838 
 839     for (auto&amp; textTrack : tracksForMenu) {
 840         auto menuItem = HTMLLIElement::create(document());
 841         menuItem-&gt;appendChild(document().createTextNode(captionPreferences.displayNameForTrack(textTrack.get())));
 842         captionsMenuList-&gt;appendChild(menuItem);
 843         m_menuItems.append(menuItem.ptr());
 844         m_menuToTrackMap.add(menuItem.ptr(), textTrack);
 845     }
 846 
 847     appendChild(captionsMenuList);
 848 #endif
 849 }
 850 
 851 // ----------------------------
 852 
 853 MediaControlTimelineElement::MediaControlTimelineElement(Document&amp; document, MediaControls* controls)
 854     : MediaControlInputElement(document, MediaSlider)
 855     , m_controls(controls)
 856 {
<span class="line-modified"> 857     setPseudo(AtomString(&quot;-webkit-media-controls-timeline&quot;, AtomString::ConstructFromLiteral));</span>
 858 }
 859 
 860 Ref&lt;MediaControlTimelineElement&gt; MediaControlTimelineElement::create(Document&amp; document, MediaControls* controls)
 861 {
 862     ASSERT(controls);
 863 
 864     Ref&lt;MediaControlTimelineElement&gt; timeline = adoptRef(*new MediaControlTimelineElement(document, controls));
 865     timeline-&gt;ensureUserAgentShadowRoot();
 866     timeline-&gt;setType(&quot;range&quot;);
<span class="line-modified"> 867     timeline-&gt;setAttributeWithoutSynchronization(precisionAttr, AtomString(&quot;float&quot;, AtomString::ConstructFromLiteral));</span>
 868     return timeline;
 869 }
 870 
 871 void MediaControlTimelineElement::defaultEventHandler(Event&amp; event)
 872 {
 873     // Left button is 0. Rejects mouse events not from left button.
 874     if (is&lt;MouseEvent&gt;(event) &amp;&amp; downcast&lt;MouseEvent&gt;(event).button())
 875         return;
 876 
 877     if (!renderer())
 878         return;
 879 
 880     if (event.type() == eventNames().mousedownEvent)
 881         mediaController()-&gt;beginScrubbing();
 882 
 883     if (event.type() == eventNames().mouseupEvent)
 884         mediaController()-&gt;endScrubbing();
 885 
 886     MediaControlInputElement::defaultEventHandler(event);
 887 
</pre>
<hr />
<pre>
 892     if ((event.isInputEvent() || event.type() == eventNames().inputEvent) &amp;&amp; time != mediaController()-&gt;currentTime())
 893         mediaController()-&gt;setCurrentTime(time);
 894 
 895     RenderSlider&amp; slider = downcast&lt;RenderSlider&gt;(*renderer());
 896     if (slider.inDragMode())
 897         m_controls-&gt;updateCurrentTimeDisplay();
 898 }
 899 
 900 #if !PLATFORM(IOS_FAMILY)
 901 bool MediaControlTimelineElement::willRespondToMouseClickEvents()
 902 {
 903     if (!renderer())
 904         return false;
 905 
 906     return true;
 907 }
 908 #endif // !PLATFORM(IOS_FAMILY)
 909 
 910 void MediaControlTimelineElement::setPosition(double currentTime)
 911 {
<span class="line-modified"> 912     setValue(String::number(currentTime));</span>
 913 }
 914 
 915 void MediaControlTimelineElement::setDuration(double duration)
 916 {
<span class="line-modified"> 917     setAttribute(maxAttr, AtomString::number(duration));</span>
 918 }
 919 
 920 // ----------------------------
 921 
 922 MediaControlPanelVolumeSliderElement::MediaControlPanelVolumeSliderElement(Document&amp; document)
 923     : MediaControlVolumeSliderElement(document)
 924 {
<span class="line-modified"> 925     setPseudo(AtomString(&quot;-webkit-media-controls-volume-slider&quot;, AtomString::ConstructFromLiteral));</span>
 926 }
 927 
 928 Ref&lt;MediaControlPanelVolumeSliderElement&gt; MediaControlPanelVolumeSliderElement::create(Document&amp; document)
 929 {
 930     Ref&lt;MediaControlPanelVolumeSliderElement&gt; slider = adoptRef(*new MediaControlPanelVolumeSliderElement(document));
 931     slider-&gt;ensureUserAgentShadowRoot();
 932     slider-&gt;setType(&quot;range&quot;);
<span class="line-modified"> 933     slider-&gt;setAttributeWithoutSynchronization(precisionAttr, AtomString(&quot;float&quot;, AtomString::ConstructFromLiteral));</span>
<span class="line-modified"> 934     slider-&gt;setAttributeWithoutSynchronization(maxAttr, AtomString(&quot;1&quot;, AtomString::ConstructFromLiteral));</span>
 935     return slider;
 936 }
 937 
 938 // ----------------------------
 939 
 940 MediaControlFullscreenVolumeSliderElement::MediaControlFullscreenVolumeSliderElement(Document&amp; document)
 941     : MediaControlVolumeSliderElement(document)
 942 {
<span class="line-modified"> 943     setPseudo(AtomString(&quot;-webkit-media-controls-fullscreen-volume-slider&quot;, AtomString::ConstructFromLiteral));</span>
 944 }
 945 
 946 Ref&lt;MediaControlFullscreenVolumeSliderElement&gt; MediaControlFullscreenVolumeSliderElement::create(Document&amp; document)
 947 {
 948     Ref&lt;MediaControlFullscreenVolumeSliderElement&gt; slider = adoptRef(*new MediaControlFullscreenVolumeSliderElement(document));
 949     slider-&gt;ensureUserAgentShadowRoot();
 950     slider-&gt;setType(&quot;range&quot;);
<span class="line-modified"> 951     slider-&gt;setAttributeWithoutSynchronization(precisionAttr, AtomString(&quot;float&quot;, AtomString::ConstructFromLiteral));</span>
<span class="line-modified"> 952     slider-&gt;setAttributeWithoutSynchronization(maxAttr, AtomString(&quot;1&quot;, AtomString::ConstructFromLiteral));</span>
 953     return slider;
 954 }
 955 
 956 // ----------------------------
 957 
 958 MediaControlFullscreenButtonElement::MediaControlFullscreenButtonElement(Document&amp; document)
 959     : MediaControlInputElement(document, MediaEnterFullscreenButton)
 960 {
<span class="line-modified"> 961     setPseudo(AtomString(&quot;-webkit-media-controls-fullscreen-button&quot;, AtomString::ConstructFromLiteral));</span>
 962 }
 963 
 964 Ref&lt;MediaControlFullscreenButtonElement&gt; MediaControlFullscreenButtonElement::create(Document&amp; document)
 965 {
 966     Ref&lt;MediaControlFullscreenButtonElement&gt; button = adoptRef(*new MediaControlFullscreenButtonElement(document));
 967     button-&gt;ensureUserAgentShadowRoot();
 968     button-&gt;setType(&quot;button&quot;);
 969     button-&gt;hide();
 970     return button;
 971 }
 972 
 973 void MediaControlFullscreenButtonElement::defaultEventHandler(Event&amp; event)
 974 {
 975     if (event.type() == eventNames().clickEvent) {
 976 #if ENABLE(FULLSCREEN_API)
 977         // Only use the new full screen API if the fullScreenEnabled setting has
 978         // been explicitly enabled. Otherwise, use the old fullscreen API. This
 979         // allows apps which embed a WebView to retain the existing full screen
 980         // video implementation without requiring them to implement their own full
 981         // screen behavior.
 982         if (document().settings().fullScreenEnabled()) {
<span class="line-modified"> 983             if (document().fullscreenManager().isFullscreen() &amp;&amp; document().fullscreenManager().currentFullscreenElement() == parentMediaElement(this))</span>
<span class="line-modified"> 984                 document().fullscreenManager().cancelFullscreen();</span>
 985             else
<span class="line-modified"> 986                 document().fullscreenManager().requestFullscreenForElement(parentMediaElement(this).get(), FullscreenManager::ExemptIFrameAllowFullscreenRequirement);</span>
 987         } else
 988 #endif
 989             mediaController()-&gt;enterFullscreen();
 990         event.setDefaultHandled();
 991     }
 992     HTMLInputElement::defaultEventHandler(event);
 993 }
 994 
 995 void MediaControlFullscreenButtonElement::setIsFullscreen(bool isFullscreen)
 996 {
 997     setDisplayType(isFullscreen ? MediaExitFullscreenButton : MediaEnterFullscreenButton);
 998 }
 999 
1000 // ----------------------------
1001 
1002 MediaControlFullscreenVolumeMinButtonElement::MediaControlFullscreenVolumeMinButtonElement(Document&amp; document)
1003     : MediaControlInputElement(document, MediaUnMuteButton)
1004 {
<span class="line-modified">1005     setPseudo(AtomString(&quot;-webkit-media-controls-fullscreen-volume-min-button&quot;, AtomString::ConstructFromLiteral));</span>
1006 }
1007 
1008 Ref&lt;MediaControlFullscreenVolumeMinButtonElement&gt; MediaControlFullscreenVolumeMinButtonElement::create(Document&amp; document)
1009 {
1010     Ref&lt;MediaControlFullscreenVolumeMinButtonElement&gt; button = adoptRef(*new MediaControlFullscreenVolumeMinButtonElement(document));
1011     button-&gt;ensureUserAgentShadowRoot();
1012     button-&gt;setType(&quot;button&quot;);
1013     return button;
1014 }
1015 
1016 void MediaControlFullscreenVolumeMinButtonElement::defaultEventHandler(Event&amp; event)
1017 {
1018     if (event.type() == eventNames().clickEvent) {
1019         mediaController()-&gt;setVolume(0);
1020         event.setDefaultHandled();
1021     }
1022     HTMLInputElement::defaultEventHandler(event);
1023 }
1024 
1025 // ----------------------------
1026 
1027 MediaControlFullscreenVolumeMaxButtonElement::MediaControlFullscreenVolumeMaxButtonElement(Document&amp; document)
1028 : MediaControlInputElement(document, MediaMuteButton)
1029 {
<span class="line-modified">1030     setPseudo(AtomString(&quot;-webkit-media-controls-fullscreen-volume-max-button&quot;, AtomString::ConstructFromLiteral));</span>
1031 }
1032 
1033 Ref&lt;MediaControlFullscreenVolumeMaxButtonElement&gt; MediaControlFullscreenVolumeMaxButtonElement::create(Document&amp; document)
1034 {
1035     Ref&lt;MediaControlFullscreenVolumeMaxButtonElement&gt; button = adoptRef(*new MediaControlFullscreenVolumeMaxButtonElement(document));
1036     button-&gt;ensureUserAgentShadowRoot();
1037     button-&gt;setType(&quot;button&quot;);
1038     return button;
1039 }
1040 
1041 void MediaControlFullscreenVolumeMaxButtonElement::defaultEventHandler(Event&amp; event)
1042 {
1043     if (event.type() == eventNames().clickEvent) {
1044         mediaController()-&gt;setVolume(1);
1045         event.setDefaultHandled();
1046     }
1047     HTMLInputElement::defaultEventHandler(event);
1048 }
1049 
1050 // ----------------------------
1051 
1052 MediaControlTimeRemainingDisplayElement::MediaControlTimeRemainingDisplayElement(Document&amp; document)
1053     : MediaControlTimeDisplayElement(document, MediaTimeRemainingDisplay)
1054 {
1055     setPseudo(getMediaControlTimeRemainingDisplayElementShadowPseudoId());
1056 }
1057 
1058 Ref&lt;MediaControlTimeRemainingDisplayElement&gt; MediaControlTimeRemainingDisplayElement::create(Document&amp; document)
1059 {
1060     return adoptRef(*new MediaControlTimeRemainingDisplayElement(document));
1061 }
1062 
<span class="line-modified">1063 static const AtomString&amp; getMediaControlTimeRemainingDisplayElementShadowPseudoId()</span>
1064 {
<span class="line-modified">1065     static NeverDestroyed&lt;AtomString&gt; id(&quot;-webkit-media-controls-time-remaining-display&quot;, AtomString::ConstructFromLiteral);</span>
1066     return id;
1067 }
1068 
1069 // ----------------------------
1070 
1071 MediaControlCurrentTimeDisplayElement::MediaControlCurrentTimeDisplayElement(Document&amp; document)
1072     : MediaControlTimeDisplayElement(document, MediaCurrentTimeDisplay)
1073 {
1074     setPseudo(getMediaControlCurrentTimeDisplayElementShadowPseudoId());
1075 }
1076 
1077 Ref&lt;MediaControlCurrentTimeDisplayElement&gt; MediaControlCurrentTimeDisplayElement::create(Document&amp; document)
1078 {
1079     return adoptRef(*new MediaControlCurrentTimeDisplayElement(document));
1080 }
1081 
<span class="line-modified">1082 static const AtomString&amp; getMediaControlCurrentTimeDisplayElementShadowPseudoId()</span>
1083 {
<span class="line-modified">1084     static NeverDestroyed&lt;AtomString&gt; id(&quot;-webkit-media-controls-current-time-display&quot;, AtomString::ConstructFromLiteral);</span>
1085     return id;
1086 }
1087 
1088 // ----------------------------
1089 
1090 #if ENABLE(VIDEO_TRACK)
1091 
1092 MediaControlTextTrackContainerElement::MediaControlTextTrackContainerElement(Document&amp; document)
1093     : MediaControlDivElement(document, MediaTextTrackDisplayContainer)
1094     , m_updateTimer(*this, &amp;MediaControlTextTrackContainerElement::updateTimerFired)
1095     , m_fontSize(0)
1096     , m_fontSizeIsImportant(false)
1097     , m_updateTextTrackRepresentationStyle(false)
1098 {
<span class="line-modified">1099     setPseudo(AtomString(&quot;-webkit-media-text-track-container&quot;, AtomString::ConstructFromLiteral));</span>
1100 }
1101 
1102 Ref&lt;MediaControlTextTrackContainerElement&gt; MediaControlTextTrackContainerElement::create(Document&amp; document)
1103 {
1104     auto element = adoptRef(*new MediaControlTextTrackContainerElement(document));
1105     element-&gt;hide();
1106     return element;
1107 }
1108 
1109 RenderPtr&lt;RenderElement&gt; MediaControlTextTrackContainerElement::createElementRenderer(RenderStyle&amp;&amp; style, const RenderTreePosition&amp;)
1110 {
1111     return createRenderer&lt;RenderTextTrackContainerElement&gt;(*this, WTFMove(style));
1112 }
1113 
1114 static bool compareCueIntervalForDisplay(const CueInterval&amp; one, const CueInterval&amp; two)
1115 {
1116     return one.data()-&gt;isPositionedAbove(two.data());
1117 };
1118 
1119 void MediaControlTextTrackContainerElement::updateDisplay()
</pre>
<hr />
<pre>
1156     CueList activeCues = video.currentlyActiveCues();
1157 
1158     // 9. If reset is false, then, for each text track cue cue in cues: if cue&#39;s
1159     // text track cue display state has a set of CSS boxes, then add those boxes
1160     // to output, and remove cue from cues.
1161 
1162     // There is nothing explicitly to be done here, as all the caching occurs
1163     // within the TextTrackCue instance itself. If parameters of the cue change,
1164     // the display tree is cleared.
1165 
1166     // If the number of CSS boxes in the output is less than the number of cues
1167     // we wish to render (e.g., we are adding another cue in a set of roll-up
1168     // cues), remove all the existing CSS boxes representing the cues and re-add
1169     // them so that the new cue is at the bottom.
1170     // FIXME: Calling countChildNodes() here is inefficient. We don&#39;t need to
1171     // traverse all children just to check if there are less children than cues.
1172     if (countChildNodes() &lt; activeCues.size())
1173         removeChildren();
1174 
1175     activeCues.removeAllMatching([] (CueInterval&amp; cueInterval) {
<span class="line-modified">1176         if (!is&lt;VTTCue&gt;(cueInterval.data()))</span>
1177             return true;
1178 
<span class="line-modified">1179         Ref&lt;VTTCue&gt; cue = downcast&lt;VTTCue&gt;(*cueInterval.data());</span>
1180 
1181         return !cue-&gt;isRenderable()
1182             || !cue-&gt;track()
1183             || !cue-&gt;track()-&gt;isRendered()
1184             || cue-&gt;track()-&gt;mode() == TextTrack::Mode::Disabled
1185             || !cue-&gt;isActive()
1186             || cue-&gt;text().isEmpty();
1187     });
1188 
1189     // Sort the active cues for the appropriate display order. For example, for roll-up
1190     // or paint-on captions, we need to add the cues in reverse chronological order,
1191     // so that the newest captions appear at the bottom.
1192     std::sort(activeCues.begin(), activeCues.end(), &amp;compareCueIntervalForDisplay);
1193 
1194     // 10. For each text track cue cue in cues that has not yet had
1195     // corresponding CSS boxes added to output, in text track cue order, run the
1196     // following substeps:
1197     for (size_t i = 0; i &lt; activeCues.size(); ++i) {
1198         if (!mediaController()-&gt;closedCaptionsVisible())
1199             continue;
1200 
<span class="line-modified">1201         RefPtr&lt;VTTCue&gt; cue = downcast&lt;VTTCue&gt;(activeCues[i].data());</span>



1202 
<span class="line-modified">1203         DEBUG_LOG(LOGIDENTIFIER, &quot;adding and positioning cue &quot;, i, &quot;: \&quot;&quot;, cue-&gt;text(), &quot;\&quot;, start=&quot;, cue-&gt;startTime(), &quot;, end=&quot;, cue-&gt;endTime(), &quot;, line=&quot;, cue-&gt;line());</span>
1204         Ref&lt;VTTCueBox&gt; displayBox = cue-&gt;getDisplayTree(m_videoDisplaySize.size(), m_fontSize);
1205         RefPtr&lt;VTTRegion&gt; region = cue-&gt;track()-&gt;regions()-&gt;getRegionById(cue-&gt;regionId());
1206         if (!region) {
1207             // If cue has an empty text track cue region identifier or there is no
1208             // WebVTT region whose region identifier is identical to cue&#39;s text
1209             // track cue region identifier, run the following substeps:
1210             if (displayBox-&gt;hasChildNodes() &amp;&amp; !contains(displayBox.ptr())) {
1211                 // Note: the display tree of a cue is removed when the active flag of the cue is unset.
1212                 appendChild(displayBox);
1213                 cue-&gt;setFontSize(m_fontSize, m_videoDisplaySize.size(), m_fontSizeIsImportant);
1214             }
1215         } else {
1216             // Let region be the WebVTT region whose region identifier
1217             // matches the text track cue region identifier of cue.
1218             Ref&lt;HTMLDivElement&gt; regionNode = region-&gt;getDisplayTree();
1219 
1220             // Append the region to the viewport, if it was not already.
1221             if (!contains(regionNode.ptr()))
1222                 appendChild(region-&gt;getDisplayTree());
1223 
</pre>
<hr />
<pre>
1435 
1436     IntRect paintingRect = IntRect(IntPoint(), layer-&gt;size());
1437 
1438     // FIXME (149422): This buffer should not be unconditionally unaccelerated.
1439     std::unique_ptr&lt;ImageBuffer&gt; buffer(ImageBuffer::create(paintingRect.size(), Unaccelerated, deviceScaleFactor));
1440     if (!buffer)
1441         return nullptr;
1442 
1443     layer-&gt;paint(buffer-&gt;context(), paintingRect, LayoutSize(), { PaintBehavior::FlattenCompositingLayers, PaintBehavior::Snapshotting }, nullptr, RenderLayer::paintLayerPaintingCompositingAllPhasesFlags());
1444 
1445     return ImageBuffer::sinkIntoImage(WTFMove(buffer));
1446 }
1447 
1448 void MediaControlTextTrackContainerElement::textTrackRepresentationBoundsChanged(const IntRect&amp;)
1449 {
1450     if (hasChildNodes())
1451         updateTextTrackRepresentation();
1452     updateSizes();
1453 }
1454 
<span class="line-added">1455 #if !RELEASE_LOG_DISABLED</span>
<span class="line-added">1456 const Logger&amp; MediaControlTextTrackContainerElement::logger() const</span>
<span class="line-added">1457 {</span>
<span class="line-added">1458     return document().logger();</span>
<span class="line-added">1459 }</span>
<span class="line-added">1460 </span>
<span class="line-added">1461 const void* MediaControlTextTrackContainerElement::logIdentifier() const</span>
<span class="line-added">1462 {</span>
<span class="line-added">1463     if (auto mediaElement = parentMediaElement(this))</span>
<span class="line-added">1464         return mediaElement-&gt;logIdentifier();</span>
<span class="line-added">1465     return nullptr;</span>
<span class="line-added">1466 }</span>
<span class="line-added">1467 </span>
<span class="line-added">1468 WTFLogChannel&amp; MediaControlTextTrackContainerElement::logChannel() const</span>
<span class="line-added">1469 {</span>
<span class="line-added">1470     return LogMedia;</span>
<span class="line-added">1471 }</span>
<span class="line-added">1472 #endif // !RELEASE_LOG_DISABLED</span>
<span class="line-added">1473 </span>
1474 #endif // ENABLE(VIDEO_TRACK)
1475 
1476 // ----------------------------
1477 
1478 } // namespace WebCore
1479 
1480 #endif // ENABLE(VIDEO)
</pre>
</td>
</tr>
</table>
<center><a href="MediaControlElementTypes.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="MediaControlElements.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>