<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/JITOpcodes32_64.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JITOpcodes.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JITOperations.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/JITOpcodes32_64.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 378,11 ***</span>
  
      JSValueRegs value(regT1, regT0);
      GPRReg scratch1 = regT2;
      GPRReg scratch2 = regT3;
      bool shouldCheckMasqueradesAsUndefined = true;
<span class="line-modified">!     addJump(branchIfFalsey(*vm(), value, scratch1, scratch2, fpRegT0, fpRegT1, shouldCheckMasqueradesAsUndefined, m_codeBlock-&gt;globalObject()), target);</span>
  }
  
  void JIT::emit_op_jtrue(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpJtrue&gt;();
<span class="line-new-header">--- 378,11 ---</span>
  
      JSValueRegs value(regT1, regT0);
      GPRReg scratch1 = regT2;
      GPRReg scratch2 = regT3;
      bool shouldCheckMasqueradesAsUndefined = true;
<span class="line-modified">!     addJump(branchIfFalsey(vm(), value, scratch1, scratch2, fpRegT0, fpRegT1, shouldCheckMasqueradesAsUndefined, m_codeBlock-&gt;globalObject()), target);</span>
  }
  
  void JIT::emit_op_jtrue(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpJtrue&gt;();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 392,11 ***</span>
      emitLoad(cond, regT1, regT0);
      bool shouldCheckMasqueradesAsUndefined = true;
      JSValueRegs value(regT1, regT0);
      GPRReg scratch1 = regT2;
      GPRReg scratch2 = regT3;
<span class="line-modified">!     addJump(branchIfTruthy(*vm(), value, scratch1, scratch2, fpRegT0, fpRegT1, shouldCheckMasqueradesAsUndefined, m_codeBlock-&gt;globalObject()), target);</span>
  }
  
  void JIT::emit_op_jeq_null(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpJeqNull&gt;();
<span class="line-new-header">--- 392,11 ---</span>
      emitLoad(cond, regT1, regT0);
      bool shouldCheckMasqueradesAsUndefined = true;
      JSValueRegs value(regT1, regT0);
      GPRReg scratch1 = regT2;
      GPRReg scratch2 = regT3;
<span class="line-modified">!     addJump(branchIfTruthy(vm(), value, scratch1, scratch2, fpRegT0, fpRegT1, shouldCheckMasqueradesAsUndefined, m_codeBlock-&gt;globalObject()), target);</span>
  }
  
  void JIT::emit_op_jeq_null(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpJeqNull&gt;();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 447,10 ***</span>
<span class="line-new-header">--- 447,34 ---</span>
      addJump(branchIfNotNull(regT1), target);
  
      wasNotImmediate.link(this);
  }
  
<span class="line-added">+ void JIT::emit_op_jundefined_or_null(const Instruction* currentInstruction)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     auto bytecode = currentInstruction-&gt;as&lt;OpJundefinedOrNull&gt;();</span>
<span class="line-added">+     int value = bytecode.m_value.offset();</span>
<span class="line-added">+     unsigned target = jumpTarget(currentInstruction, bytecode.m_targetLabel);</span>
<span class="line-added">+ </span>
<span class="line-added">+     emitLoadTag(value, regT0);</span>
<span class="line-added">+     static_assert((JSValue::UndefinedTag + 1 == JSValue::NullTag) &amp;&amp; (JSValue::NullTag &amp; 0x1), &quot;&quot;);</span>
<span class="line-added">+     or32(TrustedImm32(1), regT0);</span>
<span class="line-added">+     addJump(branchIfNull(regT0), target);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void JIT::emit_op_jnundefined_or_null(const Instruction* currentInstruction)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     auto bytecode = currentInstruction-&gt;as&lt;OpJnundefinedOrNull&gt;();</span>
<span class="line-added">+     int value = bytecode.m_value.offset();</span>
<span class="line-added">+     unsigned target = jumpTarget(currentInstruction, bytecode.m_targetLabel);</span>
<span class="line-added">+ </span>
<span class="line-added">+     emitLoadTag(value, regT0);</span>
<span class="line-added">+     static_assert((JSValue::UndefinedTag + 1 == JSValue::NullTag) &amp;&amp; (JSValue::NullTag &amp; 0x1), &quot;&quot;);</span>
<span class="line-added">+     or32(TrustedImm32(1), regT0);</span>
<span class="line-added">+     addJump(branchIfNotNull(regT0), target);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void JIT::emit_op_jneq_ptr(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpJneqPtr&gt;();
      auto&amp; metadata = bytecode.metadata(m_codeBlock);
      int src = bytecode.m_value.offset();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 789,14 ***</span>
  
  void JIT::emit_op_throw(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpThrow&gt;();
      ASSERT(regT0 == returnValueGPR);
<span class="line-modified">!     copyCalleeSavesToEntryFrameCalleeSavesBuffer(vm()-&gt;topEntryFrame);</span>
      emitLoad(bytecode.m_value.offset(), regT1, regT0);
      callOperationNoExceptionCheck(operationThrow, JSValueRegs(regT1, regT0));
<span class="line-modified">!     jumpToExceptionHandler(*vm());</span>
  }
  
  void JIT::emit_op_to_number(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpToNumber&gt;();
<span class="line-new-header">--- 813,14 ---</span>
  
  void JIT::emit_op_throw(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpThrow&gt;();
      ASSERT(regT0 == returnValueGPR);
<span class="line-modified">!     copyCalleeSavesToEntryFrameCalleeSavesBuffer(vm().topEntryFrame);</span>
      emitLoad(bytecode.m_value.offset(), regT1, regT0);
      callOperationNoExceptionCheck(operationThrow, JSValueRegs(regT1, regT0));
<span class="line-modified">!     jumpToExceptionHandler(vm());</span>
  }
  
  void JIT::emit_op_to_number(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpToNumber&gt;();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 847,22 ***</span>
  
  void JIT::emit_op_catch(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpCatch&gt;();
  
<span class="line-modified">!     restoreCalleeSavesFromEntryFrameCalleeSavesBuffer(vm()-&gt;topEntryFrame);</span>
  
      move(TrustedImmPtr(m_vm), regT3);
      // operationThrow returns the callFrame for the handler.
      load32(Address(regT3, VM::callFrameForCatchOffset()), callFrameRegister);
      storePtr(TrustedImmPtr(nullptr), Address(regT3, VM::callFrameForCatchOffset()));
  
      addPtr(TrustedImm32(stackPointerOffsetFor(codeBlock()) * sizeof(Register)), callFrameRegister, stackPointerRegister);
  
      callOperationNoExceptionCheck(operationCheckIfExceptionIsUncatchableAndNotifyProfiler);
      Jump isCatchableException = branchTest32(Zero, returnValueGPR);
<span class="line-modified">!     jumpToExceptionHandler(*vm());</span>
      isCatchableException.link(this);
  
      move(TrustedImmPtr(m_vm), regT3);
  
      // Now store the exception returned by operationThrow.
<span class="line-new-header">--- 871,22 ---</span>
  
  void JIT::emit_op_catch(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpCatch&gt;();
  
<span class="line-modified">!     restoreCalleeSavesFromEntryFrameCalleeSavesBuffer(vm().topEntryFrame);</span>
  
      move(TrustedImmPtr(m_vm), regT3);
      // operationThrow returns the callFrame for the handler.
      load32(Address(regT3, VM::callFrameForCatchOffset()), callFrameRegister);
      storePtr(TrustedImmPtr(nullptr), Address(regT3, VM::callFrameForCatchOffset()));
  
      addPtr(TrustedImm32(stackPointerOffsetFor(codeBlock()) * sizeof(Register)), callFrameRegister, stackPointerRegister);
  
      callOperationNoExceptionCheck(operationCheckIfExceptionIsUncatchableAndNotifyProfiler);
      Jump isCatchableException = branchTest32(Zero, returnValueGPR);
<span class="line-modified">!     jumpToExceptionHandler(vm());</span>
      isCatchableException.link(this);
  
      move(TrustedImmPtr(m_vm), regT3);
  
      // Now store the exception returned by operationThrow.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 891,17 ***</span>
          callOperation(operationTryOSREnterAtCatch, m_bytecodeOffset);
      else
          callOperation(operationTryOSREnterAtCatchAndValueProfile, m_bytecodeOffset);
      auto skipOSREntry = branchTestPtr(Zero, returnValueGPR);
      emitRestoreCalleeSaves();
<span class="line-modified">!     jump(returnValueGPR, NoPtrTag);</span>
      skipOSREntry.link(this);
      if (buffer &amp;&amp; shouldEmitProfiling()) {
          buffer-&gt;forEach([&amp;] (ValueProfileAndOperand&amp; profile) {
              JSValueRegs regs(regT1, regT0);
              emitGetVirtualRegister(profile.m_operand, regs);
<span class="line-modified">!             emitValueProfilingSite(profile.m_profile);</span>
          });
      }
  #endif // ENABLE(DFG_JIT)
  }
  
<span class="line-new-header">--- 915,17 ---</span>
          callOperation(operationTryOSREnterAtCatch, m_bytecodeOffset);
      else
          callOperation(operationTryOSREnterAtCatchAndValueProfile, m_bytecodeOffset);
      auto skipOSREntry = branchTestPtr(Zero, returnValueGPR);
      emitRestoreCalleeSaves();
<span class="line-modified">!     farJump(returnValueGPR, NoPtrTag);</span>
      skipOSREntry.link(this);
      if (buffer &amp;&amp; shouldEmitProfiling()) {
          buffer-&gt;forEach([&amp;] (ValueProfileAndOperand&amp; profile) {
              JSValueRegs regs(regT1, regT0);
              emitGetVirtualRegister(profile.m_operand, regs);
<span class="line-modified">!             emitValueProfilingSite(static_cast&lt;ValueProfile&amp;&gt;(profile));</span>
          });
      }
  #endif // ENABLE(DFG_JIT)
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 931,11 ***</span>
      m_switches.append(SwitchRecord(jumpTable, m_bytecodeOffset, defaultOffset, SwitchRecord::Immediate));
      jumpTable-&gt;ensureCTITable();
  
      emitLoad(scrutinee, regT1, regT0);
      callOperation(operationSwitchImmWithUnknownKeyType, JSValueRegs(regT1, regT0), tableIndex);
<span class="line-modified">!     jump(returnValueGPR, NoPtrTag);</span>
  }
  
  void JIT::emit_op_switch_char(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpSwitchChar&gt;();
<span class="line-new-header">--- 955,11 ---</span>
      m_switches.append(SwitchRecord(jumpTable, m_bytecodeOffset, defaultOffset, SwitchRecord::Immediate));
      jumpTable-&gt;ensureCTITable();
  
      emitLoad(scrutinee, regT1, regT0);
      callOperation(operationSwitchImmWithUnknownKeyType, JSValueRegs(regT1, regT0), tableIndex);
<span class="line-modified">!     farJump(returnValueGPR, NoPtrTag);</span>
  }
  
  void JIT::emit_op_switch_char(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpSwitchChar&gt;();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 948,11 ***</span>
      m_switches.append(SwitchRecord(jumpTable, m_bytecodeOffset, defaultOffset, SwitchRecord::Character));
      jumpTable-&gt;ensureCTITable();
  
      emitLoad(scrutinee, regT1, regT0);
      callOperation(operationSwitchCharWithUnknownKeyType, JSValueRegs(regT1, regT0), tableIndex);
<span class="line-modified">!     jump(returnValueGPR, NoPtrTag);</span>
  }
  
  void JIT::emit_op_switch_string(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpSwitchString&gt;();
<span class="line-new-header">--- 972,11 ---</span>
      m_switches.append(SwitchRecord(jumpTable, m_bytecodeOffset, defaultOffset, SwitchRecord::Character));
      jumpTable-&gt;ensureCTITable();
  
      emitLoad(scrutinee, regT1, regT0);
      callOperation(operationSwitchCharWithUnknownKeyType, JSValueRegs(regT1, regT0), tableIndex);
<span class="line-modified">!     farJump(returnValueGPR, NoPtrTag);</span>
  }
  
  void JIT::emit_op_switch_string(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpSwitchString&gt;();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 964,11 ***</span>
      StringJumpTable* jumpTable = &amp;m_codeBlock-&gt;stringSwitchJumpTable(tableIndex);
      m_switches.append(SwitchRecord(jumpTable, m_bytecodeOffset, defaultOffset));
  
      emitLoad(scrutinee, regT1, regT0);
      callOperation(operationSwitchStringWithUnknownKeyType, JSValueRegs(regT1, regT0), tableIndex);
<span class="line-modified">!     jump(returnValueGPR, NoPtrTag);</span>
  }
  
  void JIT::emit_op_debug(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpDebug&gt;();
<span class="line-new-header">--- 988,11 ---</span>
      StringJumpTable* jumpTable = &amp;m_codeBlock-&gt;stringSwitchJumpTable(tableIndex);
      m_switches.append(SwitchRecord(jumpTable, m_bytecodeOffset, defaultOffset));
  
      emitLoad(scrutinee, regT1, regT0);
      callOperation(operationSwitchStringWithUnknownKeyType, JSValueRegs(regT1, regT0), tableIndex);
<span class="line-modified">!     farJump(returnValueGPR, NoPtrTag);</span>
  }
  
  void JIT::emit_op_debug(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpDebug&gt;();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 976,25 ***</span>
      Jump noDebuggerRequests = branchTest32(Zero, regT0);
      callOperation(operationDebug, static_cast&lt;int&gt;(bytecode.m_debugHookType));
      noDebuggerRequests.link(this);
  }
  
<span class="line-removed">- </span>
<span class="line-removed">- void JIT::emit_op_enter(const Instruction* currentInstruction)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     emitEnterOptimizationCheck();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // Even though JIT code doesn&#39;t use them, we initialize our constant</span>
<span class="line-removed">-     // registers to zap stale pointers, to avoid unnecessarily prolonging</span>
<span class="line-removed">-     // object lifetime and increasing GC pressure.</span>
<span class="line-removed">-     for (int i = CodeBlock::llintBaselineCalleeSaveSpaceAsVirtualRegisters(); i &lt; m_codeBlock-&gt;numVars(); ++i)</span>
<span class="line-removed">-         emitStore(virtualRegisterForLocal(i).offset(), jsUndefined());</span>
<span class="line-removed">- </span>
<span class="line-removed">-     JITSlowPathCall slowPathCall(this, currentInstruction, slow_path_enter);</span>
<span class="line-removed">-     slowPathCall.call();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  void JIT::emit_op_get_scope(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpGetScope&gt;();
      int dst = bytecode.m_dst.offset();
      emitGetFromCallFrameHeaderPtr(CallFrameSlot::callee, regT0);
<span class="line-new-header">--- 1000,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1018,42 ***</span>
  
      emitLoadPayload(callee, calleeReg);
      addSlowCase(branchIfNotFunction(calleeReg));
      loadPtr(Address(calleeReg, JSFunction::offsetOfRareData()), rareDataReg);
      addSlowCase(branchTestPtr(Zero, rareDataReg));
<span class="line-modified">!     load32(Address(rareDataReg, FunctionRareData::offsetOfObjectAllocationProfile() + ObjectAllocationProfile::offsetOfAllocator()), allocatorReg);</span>
<span class="line-modified">!     loadPtr(Address(rareDataReg, FunctionRareData::offsetOfObjectAllocationProfile() + ObjectAllocationProfile::offsetOfStructure()), structureReg);</span>
  
      loadPtr(cachedFunction, cachedFunctionReg);
      Jump hasSeenMultipleCallees = branchPtr(Equal, cachedFunctionReg, TrustedImmPtr(JSCell::seenMultipleCalleeObjects()));
      addSlowCase(branchPtr(NotEqual, calleeReg, cachedFunctionReg));
      hasSeenMultipleCallees.link(this);
  
      JumpList slowCases;
      auto butterfly = TrustedImmPtr(nullptr);
      emitAllocateJSObject(resultReg, JITAllocator::variable(), allocatorReg, structureReg, butterfly, scratchReg, slowCases);
<span class="line-modified">!     emitLoadPayload(callee, scratchReg);</span>
<span class="line-removed">-     loadPtr(Address(scratchReg, JSFunction::offsetOfRareData()), scratchReg);</span>
<span class="line-removed">-     load32(Address(scratchReg, FunctionRareData::offsetOfObjectAllocationProfile() + ObjectAllocationProfile::offsetOfInlineCapacity()), scratchReg);</span>
      emitInitializeInlineStorage(resultReg, scratchReg);
      addSlowCase(slowCases);
      emitStoreCell(bytecode.m_dst.offset(), resultReg);
  }
  
  void JIT::emit_op_to_this(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpToThis&gt;();
      auto&amp; metadata = bytecode.metadata(m_codeBlock);
<span class="line-modified">!     WriteBarrierBase&lt;Structure&gt;* cachedStructure = &amp;metadata.m_cachedStructure;</span>
      int thisRegister = bytecode.m_srcDst.offset();
  
      emitLoad(thisRegister, regT3, regT2);
  
      addSlowCase(branchIfNotCell(regT3));
      addSlowCase(branchIfNotType(regT2, FinalObjectType));
      loadPtr(Address(regT2, JSCell::structureIDOffset()), regT0);
<span class="line-modified">!     loadPtr(cachedStructure, regT2);</span>
      addSlowCase(branchPtr(NotEqual, regT0, regT2));
  }
  
  void JIT::emit_op_check_tdz(const Instruction* currentInstruction)
  {
<span class="line-new-header">--- 1027,40 ---</span>
  
      emitLoadPayload(callee, calleeReg);
      addSlowCase(branchIfNotFunction(calleeReg));
      loadPtr(Address(calleeReg, JSFunction::offsetOfRareData()), rareDataReg);
      addSlowCase(branchTestPtr(Zero, rareDataReg));
<span class="line-modified">!     load32(Address(rareDataReg, FunctionRareData::offsetOfObjectAllocationProfile() + ObjectAllocationProfileWithPrototype::offsetOfAllocator()), allocatorReg);</span>
<span class="line-modified">!     loadPtr(Address(rareDataReg, FunctionRareData::offsetOfObjectAllocationProfile() + ObjectAllocationProfileWithPrototype::offsetOfStructure()), structureReg);</span>
  
      loadPtr(cachedFunction, cachedFunctionReg);
      Jump hasSeenMultipleCallees = branchPtr(Equal, cachedFunctionReg, TrustedImmPtr(JSCell::seenMultipleCalleeObjects()));
      addSlowCase(branchPtr(NotEqual, calleeReg, cachedFunctionReg));
      hasSeenMultipleCallees.link(this);
  
      JumpList slowCases;
      auto butterfly = TrustedImmPtr(nullptr);
      emitAllocateJSObject(resultReg, JITAllocator::variable(), allocatorReg, structureReg, butterfly, scratchReg, slowCases);
<span class="line-modified">!     load8(Address(structureReg, Structure::inlineCapacityOffset()), scratchReg);</span>
      emitInitializeInlineStorage(resultReg, scratchReg);
      addSlowCase(slowCases);
      emitStoreCell(bytecode.m_dst.offset(), resultReg);
  }
  
  void JIT::emit_op_to_this(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpToThis&gt;();
      auto&amp; metadata = bytecode.metadata(m_codeBlock);
<span class="line-modified">!     StructureID* cachedStructureID = &amp;metadata.m_cachedStructureID;</span>
      int thisRegister = bytecode.m_srcDst.offset();
  
      emitLoad(thisRegister, regT3, regT2);
  
      addSlowCase(branchIfNotCell(regT3));
      addSlowCase(branchIfNotType(regT2, FinalObjectType));
      loadPtr(Address(regT2, JSCell::structureIDOffset()), regT0);
<span class="line-modified">!     load32(cachedStructureID, regT2);</span>
      addSlowCase(branchPtr(NotEqual, regT0, regT2));
  }
  
  void JIT::emit_op_check_tdz(const Instruction* currentInstruction)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1119,11 ***</span>
      ByValInfo* byValInfo = m_codeBlock-&gt;addByValInfo();
  
      emitLoadPayload(base, regT0);
      emitJumpSlowCaseIfNotJSCell(base);
  
<span class="line-modified">!     emitLoadPayload(property, regT1);</span>
  
      // This is technically incorrect - we&#39;re zero-extending an int32. On the hot path this doesn&#39;t matter.
      // We check the value as if it was a uint32 against the m_vectorLength - which will always fail if
      // number was signed since m_vectorLength is always less than intmax (since the total allocation
      // size is always less than 4Gb). As such zero extending will have been correct (and extending the value
<span class="line-new-header">--- 1126,12 ---</span>
      ByValInfo* byValInfo = m_codeBlock-&gt;addByValInfo();
  
      emitLoadPayload(base, regT0);
      emitJumpSlowCaseIfNotJSCell(base);
  
<span class="line-modified">!     emitLoad(property, regT3, regT1);</span>
<span class="line-added">+     addSlowCase(branchIfNotInt32(regT3));</span>
  
      // This is technically incorrect - we&#39;re zero-extending an int32. On the hot path this doesn&#39;t matter.
      // We check the value as if it was a uint32 against the m_vectorLength - which will always fail if
      // number was signed since m_vectorLength is always less than intmax (since the total allocation
      // size is always less than 4Gb). As such zero extending will have been correct (and extending the value
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1333,34 ***</span>
      jumpToEnd.link(this);
  }
  
  void JIT::emit_op_log_shadow_chicken_prologue(const Instruction* currentInstruction)
  {
<span class="line-modified">!     RELEASE_ASSERT(vm()-&gt;shadowChicken());</span>
      updateTopCallFrame();
      static_assert(nonArgGPR0 != regT0 &amp;&amp; nonArgGPR0 != regT2, &quot;we will have problems if this is true.&quot;);
      auto bytecode = currentInstruction-&gt;as&lt;OpLogShadowChickenPrologue&gt;();
      GPRReg shadowPacketReg = regT0;
      GPRReg scratch1Reg = nonArgGPR0; // This must be a non-argument register.
      GPRReg scratch2Reg = regT2;
<span class="line-modified">!     ensureShadowChickenPacket(*vm(), shadowPacketReg, scratch1Reg, scratch2Reg);</span>
  
      scratch1Reg = regT4;
      emitLoadPayload(bytecode.m_scope.offset(), regT3);
      logShadowChickenProloguePacket(shadowPacketReg, scratch1Reg, regT3);
  }
  
  void JIT::emit_op_log_shadow_chicken_tail(const Instruction* currentInstruction)
  {
<span class="line-modified">!     RELEASE_ASSERT(vm()-&gt;shadowChicken());</span>
      updateTopCallFrame();
      static_assert(nonArgGPR0 != regT0 &amp;&amp; nonArgGPR0 != regT2, &quot;we will have problems if this is true.&quot;);
      auto bytecode = currentInstruction-&gt;as&lt;OpLogShadowChickenTail&gt;();
      GPRReg shadowPacketReg = regT0;
      GPRReg scratch1Reg = nonArgGPR0; // This must be a non-argument register.
      GPRReg scratch2Reg = regT2;
<span class="line-modified">!     ensureShadowChickenPacket(*vm(), shadowPacketReg, scratch1Reg, scratch2Reg);</span>
      emitLoadPayload(bytecode.m_thisValue.offset(), regT2);
      emitLoadTag(bytecode.m_thisValue.offset(), regT1);
      JSValueRegs thisRegs(regT1, regT2);
      emitLoadPayload(bytecode.m_scope.offset(), regT3);
      logShadowChickenTailPacket(shadowPacketReg, thisRegs, regT3, m_codeBlock, CallSiteIndex(currentInstruction));
<span class="line-new-header">--- 1341,34 ---</span>
      jumpToEnd.link(this);
  }
  
  void JIT::emit_op_log_shadow_chicken_prologue(const Instruction* currentInstruction)
  {
<span class="line-modified">!     RELEASE_ASSERT(vm().shadowChicken());</span>
      updateTopCallFrame();
      static_assert(nonArgGPR0 != regT0 &amp;&amp; nonArgGPR0 != regT2, &quot;we will have problems if this is true.&quot;);
      auto bytecode = currentInstruction-&gt;as&lt;OpLogShadowChickenPrologue&gt;();
      GPRReg shadowPacketReg = regT0;
      GPRReg scratch1Reg = nonArgGPR0; // This must be a non-argument register.
      GPRReg scratch2Reg = regT2;
<span class="line-modified">!     ensureShadowChickenPacket(vm(), shadowPacketReg, scratch1Reg, scratch2Reg);</span>
  
      scratch1Reg = regT4;
      emitLoadPayload(bytecode.m_scope.offset(), regT3);
      logShadowChickenProloguePacket(shadowPacketReg, scratch1Reg, regT3);
  }
  
  void JIT::emit_op_log_shadow_chicken_tail(const Instruction* currentInstruction)
  {
<span class="line-modified">!     RELEASE_ASSERT(vm().shadowChicken());</span>
      updateTopCallFrame();
      static_assert(nonArgGPR0 != regT0 &amp;&amp; nonArgGPR0 != regT2, &quot;we will have problems if this is true.&quot;);
      auto bytecode = currentInstruction-&gt;as&lt;OpLogShadowChickenTail&gt;();
      GPRReg shadowPacketReg = regT0;
      GPRReg scratch1Reg = nonArgGPR0; // This must be a non-argument register.
      GPRReg scratch2Reg = regT2;
<span class="line-modified">!     ensureShadowChickenPacket(vm(), shadowPacketReg, scratch1Reg, scratch2Reg);</span>
      emitLoadPayload(bytecode.m_thisValue.offset(), regT2);
      emitLoadTag(bytecode.m_thisValue.offset(), regT1);
      JSValueRegs thisRegs(regT1, regT2);
      emitLoadPayload(bytecode.m_scope.offset(), regT3);
      logShadowChickenTailPacket(shadowPacketReg, thisRegs, regT3, m_codeBlock, CallSiteIndex(currentInstruction));
</pre>
<center><a href="JITOpcodes.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JITOperations.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>