<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/editing/Editing.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Editing.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="EditingBehavior.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/editing/Editing.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
139 
140 VisiblePosition visiblePositionBeforeNode(Node&amp;);
141 VisiblePosition visiblePositionAfterNode(Node&amp;);
142 
143 bool lineBreakExistsAtVisiblePosition(const VisiblePosition&amp;);
144 
145 WEBCORE_EXPORT int comparePositions(const VisiblePosition&amp;, const VisiblePosition&amp;);
146 
147 WEBCORE_EXPORT int indexForVisiblePosition(const VisiblePosition&amp;, RefPtr&lt;ContainerNode&gt;&amp; scope);
148 int indexForVisiblePosition(Node&amp;, const VisiblePosition&amp;, bool forSelectionPreservation);
149 WEBCORE_EXPORT VisiblePosition visiblePositionForPositionWithOffset(const VisiblePosition&amp;, int offset);
150 WEBCORE_EXPORT VisiblePosition visiblePositionForIndex(int index, ContainerNode* scope);
151 VisiblePosition visiblePositionForIndexUsingCharacterIterator(Node&amp;, int index); // FIXME: Why do we need this version?
152 
153 // -------------------------------------------------------------------------
154 // HTMLElement
155 // -------------------------------------------------------------------------
156 
157 WEBCORE_EXPORT Ref&lt;HTMLElement&gt; createDefaultParagraphElement(Document&amp;);
158 Ref&lt;HTMLElement&gt; createHTMLElement(Document&amp;, const QualifiedName&amp;);
<span class="line-modified">159 Ref&lt;HTMLElement&gt; createHTMLElement(Document&amp;, const AtomicString&amp;);</span>
160 
161 WEBCORE_EXPORT HTMLElement* enclosingList(Node*);
162 HTMLElement* outermostEnclosingList(Node*, Node* rootList = nullptr);
163 Node* enclosingListChild(Node*);
164 
165 // -------------------------------------------------------------------------
166 // Element
167 // -------------------------------------------------------------------------
168 
169 Ref&lt;Element&gt; createTabSpanElement(Document&amp;);
170 Ref&lt;Element&gt; createTabSpanElement(Document&amp;, const String&amp; tabText);
171 Ref&lt;Element&gt; createBlockPlaceholderElement(Document&amp;);
172 
173 Element* editableRootForPosition(const Position&amp;, EditableType = ContentIsEditable);
174 Element* unsplittableElementForPosition(const Position&amp;);
175 
176 bool canMergeLists(Element* firstList, Element* secondList);
177 
178 // -------------------------------------------------------------------------
179 // VisibleSelection
</pre>
</td>
<td>
<hr />
<pre>
139 
140 VisiblePosition visiblePositionBeforeNode(Node&amp;);
141 VisiblePosition visiblePositionAfterNode(Node&amp;);
142 
143 bool lineBreakExistsAtVisiblePosition(const VisiblePosition&amp;);
144 
145 WEBCORE_EXPORT int comparePositions(const VisiblePosition&amp;, const VisiblePosition&amp;);
146 
147 WEBCORE_EXPORT int indexForVisiblePosition(const VisiblePosition&amp;, RefPtr&lt;ContainerNode&gt;&amp; scope);
148 int indexForVisiblePosition(Node&amp;, const VisiblePosition&amp;, bool forSelectionPreservation);
149 WEBCORE_EXPORT VisiblePosition visiblePositionForPositionWithOffset(const VisiblePosition&amp;, int offset);
150 WEBCORE_EXPORT VisiblePosition visiblePositionForIndex(int index, ContainerNode* scope);
151 VisiblePosition visiblePositionForIndexUsingCharacterIterator(Node&amp;, int index); // FIXME: Why do we need this version?
152 
153 // -------------------------------------------------------------------------
154 // HTMLElement
155 // -------------------------------------------------------------------------
156 
157 WEBCORE_EXPORT Ref&lt;HTMLElement&gt; createDefaultParagraphElement(Document&amp;);
158 Ref&lt;HTMLElement&gt; createHTMLElement(Document&amp;, const QualifiedName&amp;);
<span class="line-modified">159 Ref&lt;HTMLElement&gt; createHTMLElement(Document&amp;, const AtomString&amp;);</span>
160 
161 WEBCORE_EXPORT HTMLElement* enclosingList(Node*);
162 HTMLElement* outermostEnclosingList(Node*, Node* rootList = nullptr);
163 Node* enclosingListChild(Node*);
164 
165 // -------------------------------------------------------------------------
166 // Element
167 // -------------------------------------------------------------------------
168 
169 Ref&lt;Element&gt; createTabSpanElement(Document&amp;);
170 Ref&lt;Element&gt; createTabSpanElement(Document&amp;, const String&amp; tabText);
171 Ref&lt;Element&gt; createBlockPlaceholderElement(Document&amp;);
172 
173 Element* editableRootForPosition(const Position&amp;, EditableType = ContentIsEditable);
174 Element* unsplittableElementForPosition(const Position&amp;);
175 
176 bool canMergeLists(Element* firstList, Element* secondList);
177 
178 // -------------------------------------------------------------------------
179 // VisibleSelection
</pre>
</td>
</tr>
</table>
<center><a href="Editing.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="EditingBehavior.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>