<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/CachedTypes.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2019 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;CachedTypes.h&quot;
  28 
<a name="1" id="anc1"></a><span class="line-added">  29 #include &quot;BytecodeCacheError.h&quot;</span>
  30 #include &quot;BytecodeCacheVersion.h&quot;
  31 #include &quot;BytecodeLivenessAnalysis.h&quot;
<a name="2" id="anc2"></a><span class="line-modified">  32 #include &quot;JSCInlines.h&quot;</span>
  33 #include &quot;JSImmutableButterfly.h&quot;
  34 #include &quot;JSTemplateObjectDescriptor.h&quot;
  35 #include &quot;ScopedArgumentsTable.h&quot;
  36 #include &quot;SourceCodeKey.h&quot;
<a name="3" id="anc3"></a><span class="line-added">  37 #include &quot;SourceProvider.h&quot;</span>
  38 #include &quot;UnlinkedEvalCodeBlock.h&quot;
  39 #include &quot;UnlinkedFunctionCodeBlock.h&quot;
  40 #include &quot;UnlinkedMetadataTableInlines.h&quot;
  41 #include &quot;UnlinkedModuleProgramCodeBlock.h&quot;
  42 #include &quot;UnlinkedProgramCodeBlock.h&quot;
  43 #include &lt;wtf/FastMalloc.h&gt;
<a name="4" id="anc4"></a>
  44 #include &lt;wtf/Optional.h&gt;
  45 #include &lt;wtf/UUID.h&gt;
<a name="5" id="anc5"></a><span class="line-modified">  46 #include &lt;wtf/text/AtomStringImpl.h&gt;</span>
  47 
  48 namespace JSC {
  49 
<a name="6" id="anc6"></a><span class="line-added">  50 namespace Yarr {</span>
<span class="line-added">  51 enum class Flags : uint8_t;</span>
<span class="line-added">  52 }</span>
<span class="line-added">  53 </span>
  54 template &lt;typename T, typename = void&gt;
  55 struct SourceTypeImpl {
  56     using type = T;
  57 };
  58 
  59 template&lt;typename T&gt;
  60 struct SourceTypeImpl&lt;T, std::enable_if_t&lt;!std::is_fundamental&lt;T&gt;::value &amp;&amp; !std::is_same&lt;typename T::SourceType_, void&gt;::value&gt;&gt; {
  61     using type = typename T::SourceType_;
  62 
  63 };
  64 
  65 template&lt;typename T&gt;
  66 using SourceType = typename SourceTypeImpl&lt;T&gt;::type;
  67 
  68 class Encoder {
  69     WTF_MAKE_NONCOPYABLE(Encoder);
  70     WTF_FORBID_HEAP_ALLOCATION;
  71 
  72 public:
  73     class Allocation {
  74         friend class Encoder;
  75 
  76     public:
  77         uint8_t* buffer() const { return m_buffer; }
  78         ptrdiff_t offset() const { return m_offset; }
  79 
  80     private:
  81         Allocation(uint8_t* buffer, ptrdiff_t offset)
  82             : m_buffer(buffer)
  83             , m_offset(offset)
  84         {
  85         }
  86 
  87         uint8_t* m_buffer;
  88         ptrdiff_t m_offset;
  89     };
  90 
<a name="7" id="anc7"></a><span class="line-modified">  91     Encoder(VM&amp; vm, FileSystem::PlatformFileHandle fd = FileSystem::invalidPlatformFileHandle)</span>
  92         : m_vm(vm)
<a name="8" id="anc8"></a><span class="line-added">  93         , m_fd(fd)</span>
  94         , m_baseOffset(0)
  95         , m_currentPage(nullptr)
  96     {
  97         allocateNewPage();
  98     }
  99 
 100     VM&amp; vm() { return m_vm; }
 101 
 102     Allocation malloc(unsigned size)
 103     {
<a name="9" id="anc9"></a><span class="line-modified"> 104         RELEASE_ASSERT(size);</span>
 105         ptrdiff_t offset;
 106         if (m_currentPage-&gt;malloc(size, offset))
 107             return Allocation { m_currentPage-&gt;buffer() + offset, m_baseOffset + offset };
 108         allocateNewPage(size);
 109         return malloc(size);
 110     }
 111 
 112     template&lt;typename T, typename... Args&gt;
 113     T* malloc(Args&amp;&amp;... args)
 114     {
 115         return new (malloc(sizeof(T)).buffer()) T(std::forward&lt;Args&gt;(args)...);
 116     }
 117 
 118     ptrdiff_t offsetOf(const void* address)
 119     {
 120         ptrdiff_t offset;
 121         ptrdiff_t baseOffset = 0;
 122         for (const auto&amp; page : m_pages) {
 123             if (page.getOffset(address, offset))
 124                 return baseOffset + offset;
 125             baseOffset += page.size();
 126         }
 127         RELEASE_ASSERT_NOT_REACHED();
 128         return 0;
 129     }
 130 
 131     void cachePtr(const void* ptr, ptrdiff_t offset)
 132     {
 133         m_ptrToOffsetMap.add(ptr, offset);
 134     }
 135 
<a name="10" id="anc10"></a><span class="line-modified"> 136     Optional&lt;ptrdiff_t&gt; cachedOffsetForPtr(const void* ptr)</span>
 137     {
 138         auto it = m_ptrToOffsetMap.find(ptr);
 139         if (it == m_ptrToOffsetMap.end())
 140             return WTF::nullopt;
 141         return { it-&gt;value };
 142     }
 143 
<a name="11" id="anc11"></a><span class="line-modified"> 144     void addLeafExecutable(const UnlinkedFunctionExecutable* executable, ptrdiff_t offset)</span>
<span class="line-added"> 145     {</span>
<span class="line-added"> 146         m_leafExecutables.add(executable, offset);</span>
<span class="line-added"> 147     }</span>
<span class="line-added"> 148 </span>
<span class="line-added"> 149     RefPtr&lt;CachedBytecode&gt; release(BytecodeCacheError&amp; error)</span>
 150     {
<a name="12" id="anc12"></a><span class="line-added"> 151         if (!m_currentPage)</span>
<span class="line-added"> 152             return nullptr;</span>
<span class="line-added"> 153         m_currentPage-&gt;alignEnd();</span>
<span class="line-added"> 154 </span>
<span class="line-added"> 155         if (FileSystem::isHandleValid(m_fd)) {</span>
<span class="line-added"> 156             return releaseMapped(error);</span>
<span class="line-added"> 157         }</span>
<span class="line-added"> 158 </span>
 159         size_t size = m_baseOffset + m_currentPage-&gt;size();
 160         MallocPtr&lt;uint8_t&gt; buffer = MallocPtr&lt;uint8_t&gt;::malloc(size);
 161         unsigned offset = 0;
 162         for (const auto&amp; page : m_pages) {
 163             memcpy(buffer.get() + offset, page.buffer(), page.size());
 164             offset += page.size();
 165         }
 166         RELEASE_ASSERT(offset == size);
<a name="13" id="anc13"></a><span class="line-modified"> 167         return CachedBytecode::create(WTFMove(buffer), size, WTFMove(m_leafExecutables));</span>
 168     }
 169 
 170 private:
<a name="14" id="anc14"></a><span class="line-added"> 171     RefPtr&lt;CachedBytecode&gt; releaseMapped(BytecodeCacheError&amp; error)</span>
<span class="line-added"> 172     {</span>
<span class="line-added"> 173         size_t size = m_baseOffset + m_currentPage-&gt;size();</span>
<span class="line-added"> 174         if (!FileSystem::truncateFile(m_fd, size)) {</span>
<span class="line-added"> 175             error = BytecodeCacheError::StandardError(errno);</span>
<span class="line-added"> 176             return nullptr;</span>
<span class="line-added"> 177         }</span>
<span class="line-added"> 178 </span>
<span class="line-added"> 179         for (const auto&amp; page : m_pages) {</span>
<span class="line-added"> 180             int bytesWritten = FileSystem::writeToFile(m_fd, reinterpret_cast&lt;char*&gt;(page.buffer()), page.size());</span>
<span class="line-added"> 181             if (bytesWritten == -1) {</span>
<span class="line-added"> 182                 error = BytecodeCacheError::StandardError(errno);</span>
<span class="line-added"> 183                 return nullptr;</span>
<span class="line-added"> 184             }</span>
<span class="line-added"> 185 </span>
<span class="line-added"> 186             if (static_cast&lt;size_t&gt;(bytesWritten) != page.size()) {</span>
<span class="line-added"> 187                 error = BytecodeCacheError::WriteError(bytesWritten, page.size());</span>
<span class="line-added"> 188                 return nullptr;</span>
<span class="line-added"> 189             }</span>
<span class="line-added"> 190         }</span>
<span class="line-added"> 191 </span>
<span class="line-added"> 192         bool success;</span>
<span class="line-added"> 193         FileSystem::MappedFileData mappedFileData(m_fd, FileSystem::MappedFileMode::Private, success);</span>
<span class="line-added"> 194         if (!success) {</span>
<span class="line-added"> 195             error = BytecodeCacheError::StandardError(errno);</span>
<span class="line-added"> 196             return nullptr;</span>
<span class="line-added"> 197         }</span>
<span class="line-added"> 198 </span>
<span class="line-added"> 199         return CachedBytecode::create(WTFMove(mappedFileData), WTFMove(m_leafExecutables));</span>
<span class="line-added"> 200     }</span>
<span class="line-added"> 201 </span>
 202     class Page {
 203     public:
 204         Page(size_t size)
 205             : m_offset(0)
 206             , m_capacity(size)
 207         {
 208             m_buffer = MallocPtr&lt;uint8_t&gt;::malloc(size);
 209         }
 210 
 211         bool malloc(size_t size, ptrdiff_t&amp; result)
 212         {
 213             size_t alignment = std::min(alignof(std::max_align_t), static_cast&lt;size_t&gt;(WTF::roundUpToPowerOfTwo(size)));
<a name="15" id="anc15"></a><span class="line-modified"> 214             ptrdiff_t offset = roundUpToMultipleOf(alignment, m_offset);</span>
<span class="line-modified"> 215             size = roundUpToMultipleOf(alignment, size);</span>
 216             if (static_cast&lt;size_t&gt;(offset + size) &gt; m_capacity)
 217                 return false;
 218 
 219             result = offset;
 220             m_offset = offset + size;
 221             return true;
 222         }
 223 
 224         uint8_t* buffer() const { return m_buffer.get(); }
 225         size_t size() const { return static_cast&lt;size_t&gt;(m_offset); }
 226 
 227         bool getOffset(const void* address, ptrdiff_t&amp; result) const
 228         {
 229             const uint8_t* addr = static_cast&lt;const uint8_t*&gt;(address);
 230             if (addr &gt;= m_buffer.get() &amp;&amp; addr &lt; m_buffer.get() + m_offset) {
 231                 result = addr - m_buffer.get();
 232                 return true;
 233             }
 234             return false;
 235         }
 236 
<a name="16" id="anc16"></a><span class="line-added"> 237         void alignEnd()</span>
<span class="line-added"> 238         {</span>
<span class="line-added"> 239             ptrdiff_t size = roundUpToMultipleOf(alignof(std::max_align_t), m_offset);</span>
<span class="line-added"> 240             if (size == m_offset)</span>
<span class="line-added"> 241                 return;</span>
<span class="line-added"> 242             RELEASE_ASSERT(static_cast&lt;size_t&gt;(size) &lt;= m_capacity);</span>
<span class="line-added"> 243             m_offset = size;</span>
<span class="line-added"> 244         }</span>
<span class="line-added"> 245 </span>
 246     private:
 247         MallocPtr&lt;uint8_t&gt; m_buffer;
 248         ptrdiff_t m_offset;
 249         size_t m_capacity;
 250     };
 251 
 252     void allocateNewPage(size_t size = 0)
 253     {
<a name="17" id="anc17"></a><span class="line-modified"> 254         static size_t minPageSize = pageSize();</span>
<span class="line-modified"> 255         if (m_currentPage) {</span>
<span class="line-added"> 256             m_currentPage-&gt;alignEnd();</span>
 257             m_baseOffset += m_currentPage-&gt;size();
<a name="18" id="anc18"></a><span class="line-added"> 258         }</span>
 259         if (size &lt; minPageSize)
 260             size = minPageSize;
 261         else
<a name="19" id="anc19"></a><span class="line-modified"> 262             size = roundUpToMultipleOf(minPageSize, size);</span>
 263         m_pages.append(Page { size });
 264         m_currentPage = &amp;m_pages.last();
 265     }
 266 
 267     VM&amp; m_vm;
<a name="20" id="anc20"></a><span class="line-added"> 268     FileSystem::PlatformFileHandle m_fd;</span>
 269     ptrdiff_t m_baseOffset;
 270     Page* m_currentPage;
 271     Vector&lt;Page&gt; m_pages;
 272     HashMap&lt;const void*, ptrdiff_t&gt; m_ptrToOffsetMap;
<a name="21" id="anc21"></a><span class="line-added"> 273     LeafExecutableMap m_leafExecutables;</span>
 274 };
 275 
<a name="22" id="anc22"></a><span class="line-modified"> 276 Decoder::Decoder(VM&amp; vm, Ref&lt;CachedBytecode&gt; cachedBytecode, RefPtr&lt;SourceProvider&gt; provider)</span>
<span class="line-modified"> 277     : m_vm(vm)</span>
<span class="line-modified"> 278     , m_cachedBytecode(WTFMove(cachedBytecode))</span>
<span class="line-added"> 279     , m_provider(provider)</span>
<span class="line-added"> 280 {</span>
<span class="line-added"> 281 }</span>
 282 
<a name="23" id="anc23"></a><span class="line-modified"> 283 Decoder::~Decoder()</span>
<span class="line-modified"> 284 {</span>
<span class="line-modified"> 285     for (auto&amp; finalizer : m_finalizers)</span>
<span class="line-modified"> 286         finalizer();</span>
<span class="line-modified"> 287 }</span>





 288 
<a name="24" id="anc24"></a><span class="line-modified"> 289 Ref&lt;Decoder&gt; Decoder::create(VM&amp; vm, Ref&lt;CachedBytecode&gt; cachedBytecode, RefPtr&lt;SourceProvider&gt; provider)</span>
<span class="line-modified"> 290 {</span>
<span class="line-modified"> 291     return adoptRef(*new Decoder(vm, WTFMove(cachedBytecode), WTFMove(provider)));</span>
<span class="line-modified"> 292 }</span>

 293 
<a name="25" id="anc25"></a><span class="line-modified"> 294 size_t Decoder::size() const</span>
<span class="line-added"> 295 {</span>
<span class="line-added"> 296     return m_cachedBytecode-&gt;size();</span>
<span class="line-added"> 297 }</span>
 298 
<a name="26" id="anc26"></a><span class="line-modified"> 299 ptrdiff_t Decoder::offsetOf(const void* ptr)</span>
<span class="line-modified"> 300 {</span>
<span class="line-modified"> 301     const uint8_t* addr = static_cast&lt;const uint8_t*&gt;(ptr);</span>
<span class="line-modified"> 302     ASSERT(addr &gt;= m_cachedBytecode-&gt;data() &amp;&amp; addr &lt; m_cachedBytecode-&gt;data() + m_cachedBytecode-&gt;size());</span>
<span class="line-modified"> 303     return addr - m_cachedBytecode-&gt;data();</span>
<span class="line-modified"> 304 }</span>
 305 
<a name="27" id="anc27"></a><span class="line-modified"> 306 void Decoder::cacheOffset(ptrdiff_t offset, void* ptr)</span>
<span class="line-modified"> 307 {</span>
<span class="line-modified"> 308     m_offsetToPtrMap.add(offset, ptr);</span>
<span class="line-modified"> 309 }</span>
 310 
<a name="28" id="anc28"></a><span class="line-modified"> 311 WTF::Optional&lt;void*&gt; Decoder::cachedPtrForOffset(ptrdiff_t offset)</span>
<span class="line-modified"> 312 {</span>
<span class="line-modified"> 313     auto it = m_offsetToPtrMap.find(offset);</span>
<span class="line-modified"> 314     if (it == m_offsetToPtrMap.end())</span>
<span class="line-modified"> 315         return WTF::nullopt;</span>
<span class="line-modified"> 316     return { it-&gt;value };</span>
<span class="line-modified"> 317 }</span>
 318 
<a name="29" id="anc29"></a><span class="line-modified"> 319 const void* Decoder::ptrForOffsetFromBase(ptrdiff_t offset)</span>
<span class="line-modified"> 320 {</span>
<span class="line-modified"> 321     ASSERT(offset &gt; 0 &amp;&amp; static_cast&lt;size_t&gt;(offset) &lt; m_cachedBytecode-&gt;size());</span>
<span class="line-modified"> 322     return m_cachedBytecode-&gt;data() + offset;</span>
<span class="line-modified"> 323 }</span>
 324 
<a name="30" id="anc30"></a><span class="line-modified"> 325 CompactVariableMap::Handle Decoder::handleForEnvironment(CompactVariableEnvironment* environment) const</span>
<span class="line-modified"> 326 {</span>
<span class="line-modified"> 327     auto it = m_environmentToHandleMap.find(environment);</span>
<span class="line-modified"> 328     RELEASE_ASSERT(it != m_environmentToHandleMap.end());</span>
<span class="line-modified"> 329     return it-&gt;value;</span>
<span class="line-modified"> 330 }</span>
<span class="line-modified"> 331 </span>
<span class="line-modified"> 332 void Decoder::setHandleForEnvironment(CompactVariableEnvironment* environment, const CompactVariableMap::Handle&amp; handle)</span>
<span class="line-modified"> 333 {</span>
<span class="line-added"> 334     auto addResult = m_environmentToHandleMap.add(environment, handle);</span>
<span class="line-added"> 335     RELEASE_ASSERT(addResult.isNewEntry);</span>
<span class="line-added"> 336 }</span>
<span class="line-added"> 337 </span>
<span class="line-added"> 338 void Decoder::addLeafExecutable(const UnlinkedFunctionExecutable* executable, ptrdiff_t offset)</span>
<span class="line-added"> 339 {</span>
<span class="line-added"> 340     m_cachedBytecode-&gt;leafExecutables().add(executable, offset);</span>
<span class="line-added"> 341 }</span>
<span class="line-added"> 342 </span>
<span class="line-added"> 343 template&lt;typename Functor&gt;</span>
<span class="line-added"> 344 void Decoder::addFinalizer(const Functor&amp; fn)</span>
<span class="line-added"> 345 {</span>
<span class="line-added"> 346     m_finalizers.append(fn);</span>
<span class="line-added"> 347 }</span>
<span class="line-added"> 348 </span>
<span class="line-added"> 349 RefPtr&lt;SourceProvider&gt; Decoder::provider() const</span>
<span class="line-added"> 350 {</span>
<span class="line-added"> 351     return m_provider;</span>
<span class="line-added"> 352 }</span>
 353 
 354 template&lt;typename T&gt;
 355 static std::enable_if_t&lt;std::is_same&lt;T, SourceType&lt;T&gt;&gt;::value&gt; encode(Encoder&amp;, T&amp; dst, const SourceType&lt;T&gt;&amp; src)
 356 {
 357     dst = src;
 358 }
 359 
 360 template&lt;typename T&gt;
 361 static std::enable_if_t&lt;!std::is_same&lt;T, SourceType&lt;T&gt;&gt;::value&gt; encode(Encoder&amp; encoder, T&amp; dst, const SourceType&lt;T&gt;&amp; src)
 362 {
 363     dst.encode(encoder, src);
 364 }
 365 
 366 template&lt;typename T, typename... Args&gt;
 367 static std::enable_if_t&lt;std::is_same&lt;T, SourceType&lt;T&gt;&gt;::value&gt; decode(Decoder&amp;, const T&amp; src, SourceType&lt;T&gt;&amp; dst, Args...)
 368 {
 369     dst = src;
 370 }
 371 
 372 template&lt;typename T, typename... Args&gt;
 373 static std::enable_if_t&lt;!std::is_same&lt;T, SourceType&lt;T&gt;&gt;::value&gt; decode(Decoder&amp; decoder, const T&amp; src, SourceType&lt;T&gt;&amp; dst, Args... args)
 374 {
 375     src.decode(decoder, dst, args...);
 376 }
 377 
 378 template&lt;typename T&gt;
 379 static std::enable_if_t&lt;std::is_same&lt;T, SourceType&lt;T&gt;&gt;::value, T&gt; decode(Decoder&amp;, T src)
 380 {
 381     return src;
 382 }
 383 
 384 template&lt;typename T&gt;
 385 static std::enable_if_t&lt;!std::is_same&lt;T, SourceType&lt;T&gt;&gt;::value, SourceType&lt;T&gt;&gt;&amp;&amp; decode(Decoder&amp; decoder, const T&amp; src)
 386 {
 387     return src.decode(decoder);
 388 }
 389 
 390 template&lt;typename Source&gt;
 391 class CachedObject {
 392     WTF_MAKE_NONCOPYABLE(CachedObject&lt;Source&gt;);
 393 
 394 public:
 395     using SourceType_ = Source;
 396 
 397     CachedObject() = default;
 398 
 399     inline void* operator new(size_t, void* where) { return where; }
<a name="31" id="anc31"></a><span class="line-added"> 400     void* operator new[](size_t, void* where) { return where; }</span>
 401 
 402     // Copied from WTF_FORBID_HEAP_ALLOCATION, since we only want to allow placement new
<a name="32" id="anc32"></a>
 403     void* operator new(size_t) = delete;
 404     void operator delete(void*) = delete;
 405     void* operator new[](size_t size) = delete;
 406     void operator delete[](void*) = delete;
 407     void* operator new(size_t, NotNullTag, void* location) = delete;
 408 };
 409 
 410 template&lt;typename Source&gt;
<a name="33" id="anc33"></a><span class="line-modified"> 411 class VariableLengthObject : public CachedObject&lt;Source&gt;, VariableLengthObjectBase {</span>
 412     template&lt;typename, typename&gt;
<a name="34" id="anc34"></a><span class="line-modified"> 413     friend class CachedPtr;</span>
<span class="line-added"> 414     friend struct CachedPtrOffsets;</span>
<span class="line-added"> 415 </span>
<span class="line-added"> 416 public:</span>
<span class="line-added"> 417     VariableLengthObject()</span>
<span class="line-added"> 418         : VariableLengthObjectBase(s_invalidOffset)</span>
<span class="line-added"> 419     {</span>
<span class="line-added"> 420     }</span>
<span class="line-added"> 421 </span>
<span class="line-added"> 422     bool isEmpty() const</span>
<span class="line-added"> 423     {</span>
<span class="line-added"> 424         return m_offset == s_invalidOffset;</span>
<span class="line-added"> 425     }</span>
 426 
 427 protected:
 428     const uint8_t* buffer() const
 429     {
<a name="35" id="anc35"></a><span class="line-modified"> 430         ASSERT(!isEmpty());</span>
<span class="line-modified"> 431         return bitwise_cast&lt;const uint8_t*&gt;(this) + m_offset;</span>
 432     }
 433 
 434     template&lt;typename T&gt;
 435     const T* buffer() const
 436     {
<a name="36" id="anc36"></a><span class="line-added"> 437         ASSERT(!(bitwise_cast&lt;uintptr_t&gt;(buffer()) % alignof(T)));</span>
 438         return bitwise_cast&lt;const T*&gt;(buffer());
 439     }
 440 
 441     uint8_t* allocate(Encoder&amp; encoder, size_t size)
 442     {
 443         ptrdiff_t offsetOffset = encoder.offsetOf(&amp;m_offset);
 444         auto result = encoder.malloc(size);
 445         m_offset = result.offset() - offsetOffset;
 446         return result.buffer();
 447     }
 448 
 449     template&lt;typename T&gt;
<a name="37" id="anc37"></a><span class="line-added"> 450 #if CPU(ARM64) &amp;&amp; CPU(ADDRESS32)</span>
<span class="line-added"> 451     // FIXME: Remove this once it&#39;s no longer needed and LLVM doesn&#39;t miscompile us:</span>
<span class="line-added"> 452     // &lt;rdar://problem/49792205&gt;</span>
<span class="line-added"> 453     __attribute__((optnone))</span>
<span class="line-added"> 454 #endif</span>
 455     T* allocate(Encoder&amp; encoder, unsigned size = 1)
 456     {
 457         uint8_t* result = allocate(encoder, sizeof(T) * size);
<a name="38" id="anc38"></a><span class="line-modified"> 458         ASSERT(!(bitwise_cast&lt;uintptr_t&gt;(result) % alignof(T)));</span>
<span class="line-added"> 459         return new (result) T[size];</span>
 460     }
 461 
 462 private:
 463     constexpr static ptrdiff_t s_invalidOffset = std::numeric_limits&lt;ptrdiff_t&gt;::max();
<a name="39" id="anc39"></a>


 464 };
 465 
 466 template&lt;typename T, typename Source = SourceType&lt;T&gt;&gt;
 467 class CachedPtr : public VariableLengthObject&lt;Source*&gt; {
 468     template&lt;typename, typename&gt;
<a name="40" id="anc40"></a><span class="line-modified"> 469     friend class CachedRefPtr;</span>
<span class="line-added"> 470 </span>
<span class="line-added"> 471     friend struct CachedPtrOffsets;</span>
 472 
 473 public:
 474     void encode(Encoder&amp; encoder, const Source* src)
 475     {
<a name="41" id="anc41"></a><span class="line-modified"> 476         if (!src)</span>

 477             return;
 478 
<a name="42" id="anc42"></a><span class="line-modified"> 479         if (Optional&lt;ptrdiff_t&gt; offset = encoder.cachedOffsetForPtr(src)) {</span>
 480             this-&gt;m_offset = *offset - encoder.offsetOf(&amp;this-&gt;m_offset);
 481             return;
 482         }
 483 
 484         T* cachedObject = this-&gt;template allocate&lt;T&gt;(encoder);
 485         cachedObject-&gt;encode(encoder, *src);
 486         encoder.cachePtr(src, encoder.offsetOf(cachedObject));
 487     }
 488 
 489     template&lt;typename... Args&gt;
<a name="43" id="anc43"></a><span class="line-modified"> 490     Source* decode(Decoder&amp; decoder, bool&amp; isNewAllocation, Args&amp;&amp;... args) const</span>
 491     {
<a name="44" id="anc44"></a><span class="line-modified"> 492         if (this-&gt;isEmpty()) {</span>
<span class="line-added"> 493             isNewAllocation = false;</span>
 494             return nullptr;
<a name="45" id="anc45"></a><span class="line-added"> 495         }</span>
 496 
 497         ptrdiff_t bufferOffset = decoder.offsetOf(this-&gt;buffer());
<a name="46" id="anc46"></a><span class="line-modified"> 498         if (Optional&lt;void*&gt; ptr = decoder.cachedPtrForOffset(bufferOffset)) {</span>
<span class="line-modified"> 499             isNewAllocation = false;</span>
<span class="line-added"> 500             return static_cast&lt;Source*&gt;(*ptr);</span>
<span class="line-added"> 501         }</span>
 502 
<a name="47" id="anc47"></a><span class="line-modified"> 503         isNewAllocation = true;</span>
<span class="line-added"> 504         Source* ptr = get()-&gt;decode(decoder, std::forward&lt;Args&gt;(args)...);</span>
 505         decoder.cacheOffset(bufferOffset, ptr);
 506         return ptr;
 507     }
 508 
<a name="48" id="anc48"></a><span class="line-added"> 509     template&lt;typename... Args&gt;</span>
<span class="line-added"> 510     Source* decode(Decoder&amp; decoder, Args&amp;&amp;... args) const</span>
<span class="line-added"> 511     {</span>
<span class="line-added"> 512         bool unusedIsNewAllocation;</span>
<span class="line-added"> 513         return decode(decoder, unusedIsNewAllocation, std::forward&lt;Args&gt;(args)...);</span>
<span class="line-added"> 514     }</span>
<span class="line-added"> 515 </span>
 516     const T* operator-&gt;() const { return get(); }
 517 
 518 private:
 519     const T* get() const
 520     {
<a name="49" id="anc49"></a><span class="line-modified"> 521         RELEASE_ASSERT(!this-&gt;isEmpty());</span>

 522         return this-&gt;template buffer&lt;T&gt;();
 523     }
<a name="50" id="anc50"></a>


 524 };
 525 
<a name="51" id="anc51"></a><span class="line-added"> 526 ptrdiff_t CachedPtrOffsets::offsetOffset()</span>
<span class="line-added"> 527 {</span>
<span class="line-added"> 528     return OBJECT_OFFSETOF(CachedPtr&lt;void&gt;, m_offset);</span>
<span class="line-added"> 529 }</span>
<span class="line-added"> 530 </span>
 531 template&lt;typename T, typename Source = SourceType&lt;T&gt;&gt;
 532 class CachedRefPtr : public CachedObject&lt;RefPtr&lt;Source&gt;&gt; {
 533 public:
 534     void encode(Encoder&amp; encoder, const Source* src)
 535     {
 536         m_ptr.encode(encoder, src);
 537     }
 538 
 539     void encode(Encoder&amp; encoder, const RefPtr&lt;Source&gt; src)
 540     {
 541         encode(encoder, src.get());
 542     }
 543 
 544     RefPtr&lt;Source&gt; decode(Decoder&amp; decoder) const
 545     {
<a name="52" id="anc52"></a><span class="line-modified"> 546         bool isNewAllocation;</span>
<span class="line-added"> 547         Source* decodedPtr = m_ptr.decode(decoder, isNewAllocation);</span>
 548         if (!decodedPtr)
 549             return nullptr;
<a name="53" id="anc53"></a><span class="line-modified"> 550         if (isNewAllocation) {</span>
<span class="line-added"> 551             decoder.addFinalizer([=] {</span>
<span class="line-added"> 552                 derefIfNotNull(decodedPtr);</span>
<span class="line-added"> 553             });</span>
<span class="line-added"> 554         }</span>
 555         refIfNotNull(decodedPtr);
 556         return adoptRef(decodedPtr);
 557     }
 558 
 559     void decode(Decoder&amp; decoder, RefPtr&lt;Source&gt;&amp; src) const
 560     {
 561         src = decode(decoder);
 562     }
 563 
 564 private:
 565     CachedPtr&lt;T, Source&gt; m_ptr;
 566 };
 567 
 568 template&lt;typename T, typename Source = SourceType&lt;T&gt;&gt;
 569 class CachedWriteBarrier : public CachedObject&lt;WriteBarrier&lt;Source&gt;&gt; {
<a name="54" id="anc54"></a><span class="line-added"> 570     friend struct CachedWriteBarrierOffsets;</span>
<span class="line-added"> 571 </span>
 572 public:
<a name="55" id="anc55"></a><span class="line-added"> 573     bool isEmpty() const { return m_ptr.isEmpty(); }</span>
<span class="line-added"> 574 </span>
 575     void encode(Encoder&amp; encoder, const WriteBarrier&lt;Source&gt; src)
 576     {
 577         m_ptr.encode(encoder, src.get());
 578     }
 579 
 580     void decode(Decoder&amp; decoder, WriteBarrier&lt;Source&gt;&amp; src, const JSCell* owner) const
 581     {
 582         Source* decodedPtr = m_ptr.decode(decoder);
 583         if (decodedPtr)
 584             src.set(decoder.vm(), owner, decodedPtr);
 585     }
 586 
 587 private:
 588     CachedPtr&lt;T, Source&gt; m_ptr;
 589 };
 590 
<a name="56" id="anc56"></a><span class="line-added"> 591 ptrdiff_t CachedWriteBarrierOffsets::ptrOffset()</span>
<span class="line-added"> 592 {</span>
<span class="line-added"> 593     return OBJECT_OFFSETOF(CachedWriteBarrier&lt;void&gt;, m_ptr);</span>
<span class="line-added"> 594 }</span>
<span class="line-added"> 595 </span>
 596 template&lt;typename T, size_t InlineCapacity = 0, typename OverflowHandler = CrashOnOverflow&gt;
 597 class CachedVector : public VariableLengthObject&lt;Vector&lt;SourceType&lt;T&gt;, InlineCapacity, OverflowHandler&gt;&gt; {
 598 public:
 599     void encode(Encoder&amp; encoder, const Vector&lt;SourceType&lt;T&gt;, InlineCapacity, OverflowHandler&gt;&amp; vector)
 600     {
 601         m_size = vector.size();
 602         if (!m_size)
 603             return;
 604         T* buffer = this-&gt;template allocate&lt;T&gt;(encoder, m_size);
 605         for (unsigned i = 0; i &lt; m_size; ++i)
 606             ::JSC::encode(encoder, buffer[i], vector[i]);
 607     }
 608 
 609     template&lt;typename... Args&gt;
 610     void decode(Decoder&amp; decoder, Vector&lt;SourceType&lt;T&gt;, InlineCapacity, OverflowHandler&gt;&amp; vector, Args... args) const
 611     {
 612         if (!m_size)
 613             return;
 614         vector.resizeToFit(m_size);
 615         const T* buffer = this-&gt;template buffer&lt;T&gt;();
 616         for (unsigned i = 0; i &lt; m_size; ++i)
 617             ::JSC::decode(decoder, buffer[i], vector[i], args...);
 618     }
 619 
 620 private:
 621     unsigned m_size;
 622 };
 623 
 624 template&lt;typename First, typename Second&gt;
 625 class CachedPair : public CachedObject&lt;std::pair&lt;SourceType&lt;First&gt;, SourceType&lt;Second&gt;&gt;&gt; {
 626 public:
 627     void encode(Encoder&amp; encoder, const std::pair&lt;SourceType&lt;First&gt;, SourceType&lt;Second&gt;&gt;&amp; pair)
 628     {
 629         ::JSC::encode(encoder, m_first, pair.first);
 630         ::JSC::encode(encoder, m_second, pair.second);
 631     }
 632 
 633     void decode(Decoder&amp; decoder, std::pair&lt;SourceType&lt;First&gt;, SourceType&lt;Second&gt;&gt;&amp; pair) const
 634     {
 635         ::JSC::decode(decoder, m_first, pair.first);
 636         ::JSC::decode(decoder, m_second, pair.second);
 637     }
 638 
 639 private:
 640     First m_first;
 641     Second m_second;
 642 };
 643 
 644 template&lt;typename Key, typename Value, typename HashArg = typename DefaultHash&lt;SourceType&lt;Key&gt;&gt;::Hash, typename KeyTraitsArg = HashTraits&lt;SourceType&lt;Key&gt;&gt;, typename MappedTraitsArg = HashTraits&lt;SourceType&lt;Value&gt;&gt;&gt;
 645 class CachedHashMap : public VariableLengthObject&lt;HashMap&lt;SourceType&lt;Key&gt;, SourceType&lt;Value&gt;, HashArg, KeyTraitsArg, MappedTraitsArg&gt;&gt; {
 646     template&lt;typename K, typename V&gt;
 647     using Map = HashMap&lt;K, V, HashArg, KeyTraitsArg, MappedTraitsArg&gt;;
 648 
 649 public:
 650     void encode(Encoder&amp; encoder, const Map&lt;SourceType&lt;Key&gt;, SourceType&lt;Value&gt;&gt;&amp; map)
 651     {
 652         SourceType&lt;decltype(m_entries)&gt; entriesVector(map.size());
 653         unsigned i = 0;
 654         for (const auto&amp; it : map)
 655             entriesVector[i++] = { it.key, it.value };
 656         m_entries.encode(encoder, entriesVector);
 657     }
 658 
 659     void decode(Decoder&amp; decoder, Map&lt;SourceType&lt;Key&gt;, SourceType&lt;Value&gt;&gt;&amp; map) const
 660     {
 661         SourceType&lt;decltype(m_entries)&gt; decodedEntries;
 662         m_entries.decode(decoder, decodedEntries);
 663         for (const auto&amp; pair : decodedEntries)
 664             map.set(pair.first, pair.second);
 665     }
 666 
 667 private:
 668     CachedVector&lt;CachedPair&lt;Key, Value&gt;&gt; m_entries;
 669 };
 670 
<a name="57" id="anc57"></a><span class="line-modified"> 671 template&lt;typename T&gt;</span>
<span class="line-added"> 672 class CachedUniquedStringImplBase : public VariableLengthObject&lt;T&gt; {</span>
 673 public:
 674     void encode(Encoder&amp; encoder, const StringImpl&amp; string)
 675     {
<a name="58" id="anc58"></a><span class="line-modified"> 676         m_isAtomic = string.isAtom();</span>
 677         m_isSymbol = string.isSymbol();
 678         RefPtr&lt;StringImpl&gt; impl = const_cast&lt;StringImpl*&gt;(&amp;string);
 679 
 680         if (m_isSymbol) {
 681             SymbolImpl* symbol = static_cast&lt;SymbolImpl*&gt;(impl.get());
 682             if (!symbol-&gt;isNullSymbol()) {
 683                 // We have special handling for well-known symbols.
 684                 if (!symbol-&gt;isPrivate())
 685                     impl = encoder.vm().propertyNames-&gt;getPublicName(encoder.vm(), symbol).impl();
 686             }
 687         }
 688 
 689         m_is8Bit = impl-&gt;is8Bit();
 690         m_length = impl-&gt;length();
 691 
 692         if (!m_length)
 693             return;
 694 
 695         unsigned size = m_length;
 696         const void* payload;
 697         if (m_is8Bit)
 698             payload = impl-&gt;characters8();
 699         else {
 700             payload = impl-&gt;characters16();
 701             size *= 2;
 702         }
 703 
 704         uint8_t* buffer = this-&gt;allocate(encoder, size);
 705         memcpy(buffer, payload, size);
 706     }
 707 
 708     UniquedStringImpl* decode(Decoder&amp; decoder) const
 709     {
 710         auto create = [&amp;](const auto* buffer) -&gt; UniquedStringImpl* {
 711             if (!m_isSymbol)
<a name="59" id="anc59"></a><span class="line-modified"> 712                 return AtomStringImpl::add(buffer, m_length).leakRef();</span>
 713 
<a name="60" id="anc60"></a><span class="line-modified"> 714             Identifier ident = Identifier::fromString(decoder.vm(), buffer, m_length);</span>
 715             String str = decoder.vm().propertyNames-&gt;lookUpPrivateName(ident);
 716             StringImpl* impl = str.releaseImpl().get();
 717             ASSERT(impl-&gt;isSymbol());
 718             return static_cast&lt;UniquedStringImpl*&gt;(impl);
 719         };
 720 
 721         if (!m_length) {
 722             if (m_isSymbol)
 723                 return &amp;SymbolImpl::createNullSymbol().leakRef();
<a name="61" id="anc61"></a><span class="line-modified"> 724             return AtomStringImpl::add(&quot;&quot;).leakRef();</span>
 725         }
 726 
 727         if (m_is8Bit)
<a name="62" id="anc62"></a><span class="line-modified"> 728             return create(this-&gt;template buffer&lt;LChar&gt;());</span>
<span class="line-modified"> 729         return create(this-&gt;template buffer&lt;UChar&gt;());</span>
 730     }
 731 
 732 private:
 733     bool m_is8Bit : 1;
 734     bool m_isSymbol : 1;
 735     bool m_isAtomic : 1;
 736     unsigned m_length;
 737 };
 738 
<a name="63" id="anc63"></a><span class="line-modified"> 739 class CachedUniquedStringImpl : public CachedUniquedStringImplBase&lt;UniquedStringImpl&gt; { };</span>
<span class="line-modified"> 740 class CachedStringImpl : public CachedUniquedStringImplBase&lt;StringImpl&gt; { };</span>













 741 
 742 class CachedString : public VariableLengthObject&lt;String&gt; {
 743 public:
 744     void encode(Encoder&amp; encoder, const String&amp; string)
 745     {
 746         m_impl.encode(encoder, static_cast&lt;UniquedStringImpl*&gt;(string.impl()));
 747     }
 748 
 749     String decode(Decoder&amp; decoder) const
 750     {
 751         return String(static_cast&lt;RefPtr&lt;StringImpl&gt;&gt;(m_impl.decode(decoder)));
 752     }
 753 
 754     void decode(Decoder&amp; decoder, String&amp; dst) const
 755     {
 756         dst = decode(decoder);
 757     }
 758 
 759 private:
 760     CachedRefPtr&lt;CachedUniquedStringImpl&gt; m_impl;
 761 };
 762 
 763 class CachedIdentifier : public VariableLengthObject&lt;Identifier&gt; {
 764 public:
 765     void encode(Encoder&amp; encoder, const Identifier&amp; identifier)
 766     {
 767         m_string.encode(encoder, identifier.string());
 768     }
 769 
 770     Identifier decode(Decoder&amp; decoder) const
 771     {
 772         String str = m_string.decode(decoder);
 773         if (str.isNull())
 774             return Identifier();
 775 
<a name="64" id="anc64"></a><span class="line-modified"> 776         return Identifier::fromUid(decoder.vm(), (UniquedStringImpl*)str.impl());</span>
 777     }
 778 
 779     void decode(Decoder&amp; decoder, Identifier&amp; ident) const
 780     {
 781         ident = decode(decoder);
 782     }
 783 
 784 private:
 785     CachedString m_string;
 786 };
 787 
 788 template&lt;typename T&gt;
<a name="65" id="anc65"></a><span class="line-modified"> 789 class CachedOptional : public VariableLengthObject&lt;Optional&lt;SourceType&lt;T&gt;&gt;&gt; {</span>
 790 public:
<a name="66" id="anc66"></a><span class="line-modified"> 791     void encode(Encoder&amp; encoder, const Optional&lt;SourceType&lt;T&gt;&gt;&amp; source)</span>
 792     {
<a name="67" id="anc67"></a><span class="line-modified"> 793         if (!source)</span>


 794             return;
 795 
 796         this-&gt;template allocate&lt;T&gt;(encoder)-&gt;encode(encoder, *source);
 797     }
 798 
<a name="68" id="anc68"></a><span class="line-modified"> 799     Optional&lt;SourceType&lt;T&gt;&gt; decode(Decoder&amp; decoder) const</span>
 800     {
<a name="69" id="anc69"></a><span class="line-modified"> 801         if (this-&gt;isEmpty())</span>
 802             return WTF::nullopt;
 803 
 804         return { this-&gt;template buffer&lt;T&gt;()-&gt;decode(decoder) };
 805     }
 806 
<a name="70" id="anc70"></a><span class="line-modified"> 807     void decode(Decoder&amp; decoder, Optional&lt;SourceType&lt;T&gt;&gt;&amp; dst) const</span>
 808     {
 809         dst = decode(decoder);
 810     }
 811 
 812     void encode(Encoder&amp; encoder, const std::unique_ptr&lt;SourceType&lt;T&gt;&gt;&amp; source)
 813     {
 814         if (!source)
 815             encode(encoder, WTF::nullopt);
 816         else
 817             encode(encoder, { *source });
 818     }
<a name="71" id="anc71"></a>










 819 };
 820 
 821 class CachedSimpleJumpTable : public CachedObject&lt;UnlinkedSimpleJumpTable&gt; {
 822 public:
 823     void encode(Encoder&amp; encoder, const UnlinkedSimpleJumpTable&amp; jumpTable)
 824     {
 825         m_min = jumpTable.min;
 826         m_branchOffsets.encode(encoder, jumpTable.branchOffsets);
 827     }
 828 
 829     void decode(Decoder&amp; decoder, UnlinkedSimpleJumpTable&amp; jumpTable) const
 830     {
 831         jumpTable.min = m_min;
 832         m_branchOffsets.decode(decoder, jumpTable.branchOffsets);
 833     }
 834 
 835 private:
 836     int32_t m_min;
 837     CachedVector&lt;int32_t&gt; m_branchOffsets;
 838 };
 839 
 840 class CachedStringJumpTable : public CachedObject&lt;UnlinkedStringJumpTable&gt; {
 841 public:
 842     void encode(Encoder&amp; encoder, const UnlinkedStringJumpTable&amp; jumpTable)
 843     {
 844         m_offsetTable.encode(encoder, jumpTable.offsetTable);
 845     }
 846 
 847     void decode(Decoder&amp; decoder, UnlinkedStringJumpTable&amp; jumpTable) const
 848     {
 849         m_offsetTable.decode(decoder, jumpTable.offsetTable);
 850     }
 851 
 852 private:
 853     CachedHashMap&lt;CachedRefPtr&lt;CachedStringImpl&gt;, UnlinkedStringJumpTable:: OffsetLocation&gt; m_offsetTable;
 854 };
 855 
 856 class CachedBitVector : public VariableLengthObject&lt;BitVector&gt; {
 857 public:
 858     void encode(Encoder&amp; encoder, const BitVector&amp; bitVector)
 859     {
 860         m_numBits = bitVector.size();
 861         if (!m_numBits)
 862             return;
 863         size_t sizeInBytes = BitVector::byteCount(m_numBits);
 864         uint8_t* buffer = this-&gt;allocate(encoder, sizeInBytes);
 865         memcpy(buffer, bitVector.bits(), sizeInBytes);
 866     }
 867 
 868     void decode(Decoder&amp;, BitVector&amp; bitVector) const
 869     {
 870         if (!m_numBits)
 871             return;
 872         bitVector.ensureSize(m_numBits);
 873         size_t sizeInBytes = BitVector::byteCount(m_numBits);
 874         memcpy(bitVector.bits(), this-&gt;buffer(), sizeInBytes);
 875     }
 876 
 877 private:
 878     size_t m_numBits;
 879 };
 880 
 881 template&lt;typename T, typename HashArg = typename DefaultHash&lt;T&gt;::Hash&gt;
 882 class CachedHashSet : public CachedObject&lt;HashSet&lt;SourceType&lt;T&gt;, HashArg&gt;&gt; {
 883 public:
 884     void encode(Encoder&amp; encoder, const HashSet&lt;SourceType&lt;T&gt;, HashArg&gt;&amp; set)
 885     {
 886         SourceType&lt;decltype(m_entries)&gt; entriesVector(set.size());
 887         unsigned i = 0;
 888         for (const auto&amp; item : set)
 889             entriesVector[i++] = item;
 890         m_entries.encode(encoder, entriesVector);
 891     }
 892 
 893     void decode(Decoder&amp; decoder, HashSet&lt;SourceType&lt;T&gt;, HashArg&gt;&amp; set) const
 894     {
 895         SourceType&lt;decltype(m_entries)&gt; entriesVector;
 896         m_entries.decode(decoder, entriesVector);
 897         for (const auto&amp; item : entriesVector)
 898             set.add(item);
 899     }
 900 
 901 private:
 902     CachedVector&lt;T&gt; m_entries;
 903 };
 904 
 905 class CachedConstantIdentifierSetEntry : public VariableLengthObject&lt;ConstantIdentifierSetEntry&gt; {
 906 public:
 907     void encode(Encoder&amp; encoder, const ConstantIdentifierSetEntry&amp; entry)
 908     {
 909         m_constant = entry.second;
 910         m_set.encode(encoder, entry.first);
 911     }
 912 
 913     void decode(Decoder&amp; decoder, ConstantIdentifierSetEntry&amp; entry) const
 914     {
 915         entry.second = m_constant;
 916         m_set.decode(decoder, entry.first);
 917     }
 918 
 919 private:
 920     unsigned m_constant;
 921     CachedHashSet&lt;CachedRefPtr&lt;CachedUniquedStringImpl&gt;, IdentifierRepHash&gt; m_set;
 922 };
 923 
 924 class CachedCodeBlockRareData : public CachedObject&lt;UnlinkedCodeBlock::RareData&gt; {
 925 public:
 926     void encode(Encoder&amp; encoder, const UnlinkedCodeBlock::RareData&amp; rareData)
 927     {
 928         m_exceptionHandlers.encode(encoder, rareData.m_exceptionHandlers);
 929         m_switchJumpTables.encode(encoder, rareData.m_switchJumpTables);
 930         m_stringSwitchJumpTables.encode(encoder, rareData.m_stringSwitchJumpTables);
 931         m_expressionInfoFatPositions.encode(encoder, rareData.m_expressionInfoFatPositions);
 932         m_typeProfilerInfoMap.encode(encoder, rareData.m_typeProfilerInfoMap);
 933         m_opProfileControlFlowBytecodeOffsets.encode(encoder, rareData.m_opProfileControlFlowBytecodeOffsets);
 934         m_bitVectors.encode(encoder, rareData.m_bitVectors);
 935         m_constantIdentifierSets.encode(encoder, rareData.m_constantIdentifierSets);
 936     }
 937 
 938     UnlinkedCodeBlock::RareData* decode(Decoder&amp; decoder) const
 939     {
 940         UnlinkedCodeBlock::RareData* rareData = new UnlinkedCodeBlock::RareData { };
 941         m_exceptionHandlers.decode(decoder, rareData-&gt;m_exceptionHandlers);
 942         m_switchJumpTables.decode(decoder, rareData-&gt;m_switchJumpTables);
 943         m_stringSwitchJumpTables.decode(decoder, rareData-&gt;m_stringSwitchJumpTables);
 944         m_expressionInfoFatPositions.decode(decoder, rareData-&gt;m_expressionInfoFatPositions);
 945         m_typeProfilerInfoMap.decode(decoder, rareData-&gt;m_typeProfilerInfoMap);
 946         m_opProfileControlFlowBytecodeOffsets.decode(decoder, rareData-&gt;m_opProfileControlFlowBytecodeOffsets);
 947         m_bitVectors.decode(decoder, rareData-&gt;m_bitVectors);
 948         m_constantIdentifierSets.decode(decoder, rareData-&gt;m_constantIdentifierSets);
 949         return rareData;
 950     }
 951 
 952 private:
 953     CachedVector&lt;UnlinkedHandlerInfo&gt; m_exceptionHandlers;
 954     CachedVector&lt;CachedSimpleJumpTable&gt; m_switchJumpTables;
 955     CachedVector&lt;CachedStringJumpTable&gt; m_stringSwitchJumpTables;
 956     CachedVector&lt;ExpressionRangeInfo::FatPosition&gt; m_expressionInfoFatPositions;
 957     CachedHashMap&lt;unsigned, UnlinkedCodeBlock::RareData::TypeProfilerExpressionRange&gt; m_typeProfilerInfoMap;
 958     CachedVector&lt;InstructionStream::Offset&gt; m_opProfileControlFlowBytecodeOffsets;
 959     CachedVector&lt;CachedBitVector&gt; m_bitVectors;
 960     CachedVector&lt;CachedConstantIdentifierSetEntry&gt; m_constantIdentifierSets;
 961 };
 962 
 963 class CachedVariableEnvironment : public CachedObject&lt;VariableEnvironment&gt; {
 964 public:
 965     void encode(Encoder&amp; encoder, const VariableEnvironment&amp; env)
 966     {
 967         m_isEverythingCaptured = env.m_isEverythingCaptured;
 968         m_map.encode(encoder, env.m_map);
 969     }
 970 
 971     void decode(Decoder&amp; decoder, VariableEnvironment&amp; env) const
 972     {
 973         env.m_isEverythingCaptured = m_isEverythingCaptured;
 974         m_map.decode(decoder, env.m_map);
 975     }
 976 
 977 private:
 978     bool m_isEverythingCaptured;
 979     CachedHashMap&lt;CachedRefPtr&lt;CachedUniquedStringImpl&gt;, VariableEnvironmentEntry, IdentifierRepHash, HashTraits&lt;RefPtr&lt;UniquedStringImpl&gt;&gt;, VariableEnvironmentEntryHashTraits&gt; m_map;
 980 };
 981 
<a name="72" id="anc72"></a><span class="line-added"> 982 class CachedCompactVariableEnvironment : public CachedObject&lt;CompactVariableEnvironment&gt; {</span>
<span class="line-added"> 983 public:</span>
<span class="line-added"> 984     void encode(Encoder&amp; encoder, const CompactVariableEnvironment&amp; env)</span>
<span class="line-added"> 985     {</span>
<span class="line-added"> 986         m_variables.encode(encoder, env.m_variables);</span>
<span class="line-added"> 987         m_variableMetadata.encode(encoder, env.m_variableMetadata);</span>
<span class="line-added"> 988         m_hash = env.m_hash;</span>
<span class="line-added"> 989         m_isEverythingCaptured = env.m_isEverythingCaptured;</span>
<span class="line-added"> 990     }</span>
<span class="line-added"> 991 </span>
<span class="line-added"> 992     void decode(Decoder&amp; decoder, CompactVariableEnvironment&amp; env) const</span>
<span class="line-added"> 993     {</span>
<span class="line-added"> 994         m_variables.decode(decoder, env.m_variables);</span>
<span class="line-added"> 995         m_variableMetadata.decode(decoder, env.m_variableMetadata);</span>
<span class="line-added"> 996         env.m_hash = m_hash;</span>
<span class="line-added"> 997         env.m_isEverythingCaptured = m_isEverythingCaptured;</span>
<span class="line-added"> 998     }</span>
<span class="line-added"> 999 </span>
<span class="line-added">1000     CompactVariableEnvironment* decode(Decoder&amp; decoder) const</span>
<span class="line-added">1001     {</span>
<span class="line-added">1002         CompactVariableEnvironment* env = new CompactVariableEnvironment;</span>
<span class="line-added">1003         decode(decoder, *env);</span>
<span class="line-added">1004         return env;</span>
<span class="line-added">1005     }</span>
<span class="line-added">1006 </span>
<span class="line-added">1007 private:</span>
<span class="line-added">1008     CachedVector&lt;CachedRefPtr&lt;CachedUniquedStringImpl&gt;&gt; m_variables;</span>
<span class="line-added">1009     CachedVector&lt;VariableEnvironmentEntry&gt; m_variableMetadata;</span>
<span class="line-added">1010     unsigned m_hash;</span>
<span class="line-added">1011     bool m_isEverythingCaptured;</span>
<span class="line-added">1012 };</span>
<span class="line-added">1013 </span>
<span class="line-added">1014 class CachedCompactVariableMapHandle : public CachedObject&lt;CompactVariableMap::Handle&gt; {</span>
<span class="line-added">1015 public:</span>
<span class="line-added">1016     void encode(Encoder&amp; encoder, const CompactVariableMap::Handle&amp; handle)</span>
<span class="line-added">1017     {</span>
<span class="line-added">1018         m_environment.encode(encoder, handle.m_environment);</span>
<span class="line-added">1019     }</span>
<span class="line-added">1020 </span>
<span class="line-added">1021     CompactVariableMap::Handle decode(Decoder&amp; decoder) const</span>
<span class="line-added">1022     {</span>
<span class="line-added">1023         bool isNewAllocation;</span>
<span class="line-added">1024         CompactVariableEnvironment* environment = m_environment.decode(decoder, isNewAllocation);</span>
<span class="line-added">1025         if (!environment) {</span>
<span class="line-added">1026             ASSERT(!isNewAllocation);</span>
<span class="line-added">1027             return CompactVariableMap::Handle();</span>
<span class="line-added">1028         }</span>
<span class="line-added">1029 </span>
<span class="line-added">1030         if (!isNewAllocation)</span>
<span class="line-added">1031             return decoder.handleForEnvironment(environment);</span>
<span class="line-added">1032         bool isNewEntry;</span>
<span class="line-added">1033         CompactVariableMap::Handle handle = decoder.vm().m_compactVariableMap-&gt;get(environment, isNewEntry);</span>
<span class="line-added">1034         if (!isNewEntry) {</span>
<span class="line-added">1035             decoder.addFinalizer([=] {</span>
<span class="line-added">1036                 delete environment;</span>
<span class="line-added">1037             });</span>
<span class="line-added">1038         }</span>
<span class="line-added">1039         decoder.setHandleForEnvironment(environment, handle);</span>
<span class="line-added">1040         return handle;</span>
<span class="line-added">1041     }</span>
<span class="line-added">1042 </span>
<span class="line-added">1043 private:</span>
<span class="line-added">1044     CachedPtr&lt;CachedCompactVariableEnvironment&gt; m_environment;</span>
<span class="line-added">1045 };</span>
<span class="line-added">1046 </span>
1047 template&lt;typename T, typename Source = SourceType&lt;T&gt;&gt;
1048 class CachedArray : public VariableLengthObject&lt;Source*&gt; {
1049 public:
1050     void encode(Encoder&amp; encoder, const Source* array, unsigned size)
1051     {
1052         if (!size)
1053             return;
1054         T* dst = this-&gt;template allocate&lt;T&gt;(encoder, size);
1055         for (unsigned i = 0; i &lt; size; ++i)
1056             ::JSC::encode(encoder, dst[i], array[i]);
1057     }
1058 
1059     template&lt;typename... Args&gt;
1060     void decode(Decoder&amp; decoder, Source* array, unsigned size, Args... args) const
1061     {
1062         if (!size)
1063             return;
1064         const T* buffer = this-&gt;template buffer&lt;T&gt;();
1065         for (unsigned i = 0; i &lt; size; ++i)
1066             ::JSC::decode(decoder, buffer[i], array[i], args...);
1067     }
1068 };
1069 
1070 class CachedScopedArgumentsTable : public CachedObject&lt;ScopedArgumentsTable&gt; {
1071 public:
1072     void encode(Encoder&amp; encoder, const ScopedArgumentsTable&amp; scopedArgumentsTable)
1073     {
1074         m_length = scopedArgumentsTable.m_length;
<a name="73" id="anc73"></a><span class="line-modified">1075         m_arguments.encode(encoder, scopedArgumentsTable.m_arguments.get(m_length), m_length);</span>
1076     }
1077 
1078     ScopedArgumentsTable* decode(Decoder&amp; decoder) const
1079     {
1080         ScopedArgumentsTable* scopedArgumentsTable = ScopedArgumentsTable::create(decoder.vm(), m_length);
<a name="74" id="anc74"></a><span class="line-modified">1081         m_arguments.decode(decoder, scopedArgumentsTable-&gt;m_arguments.get(m_length), m_length);</span>
1082         return scopedArgumentsTable;
1083     }
1084 
1085 private:
1086     uint32_t m_length;
1087     CachedArray&lt;ScopeOffset&gt; m_arguments;
1088 };
1089 
1090 class CachedSymbolTableEntry : public CachedObject&lt;SymbolTableEntry&gt; {
1091 public:
1092     void encode(Encoder&amp;, const SymbolTableEntry&amp; symbolTableEntry)
1093     {
1094         m_bits = symbolTableEntry.m_bits | SymbolTableEntry::SlimFlag;
1095     }
1096 
1097     void decode(Decoder&amp;, SymbolTableEntry&amp; symbolTableEntry) const
1098     {
1099         symbolTableEntry.m_bits = m_bits;
1100     }
1101 
1102 private:
1103     intptr_t m_bits;
1104 };
1105 
1106 class CachedSymbolTable : public CachedObject&lt;SymbolTable&gt; {
1107 public:
1108     void encode(Encoder&amp; encoder, const SymbolTable&amp; symbolTable)
1109     {
1110         m_map.encode(encoder, symbolTable.m_map);
1111         m_maxScopeOffset = symbolTable.m_maxScopeOffset;
1112         m_usesNonStrictEval = symbolTable.m_usesNonStrictEval;
1113         m_nestedLexicalScope = symbolTable.m_nestedLexicalScope;
1114         m_scopeType = symbolTable.m_scopeType;
1115         m_arguments.encode(encoder, symbolTable.m_arguments.get());
1116     }
1117 
1118     SymbolTable* decode(Decoder&amp; decoder) const
1119     {
1120         SymbolTable* symbolTable = SymbolTable::create(decoder.vm());
1121         m_map.decode(decoder, symbolTable-&gt;m_map);
1122         symbolTable-&gt;m_maxScopeOffset = m_maxScopeOffset;
1123         symbolTable-&gt;m_usesNonStrictEval = m_usesNonStrictEval;
1124         symbolTable-&gt;m_nestedLexicalScope = m_nestedLexicalScope;
1125         symbolTable-&gt;m_scopeType = m_scopeType;
1126         ScopedArgumentsTable* scopedArgumentsTable = m_arguments.decode(decoder);
1127         if (scopedArgumentsTable)
1128             symbolTable-&gt;m_arguments.set(decoder.vm(), symbolTable, scopedArgumentsTable);
1129         return symbolTable;
1130     }
1131 
1132 private:
1133     CachedHashMap&lt;CachedRefPtr&lt;CachedUniquedStringImpl&gt;, CachedSymbolTableEntry, IdentifierRepHash, HashTraits&lt;RefPtr&lt;UniquedStringImpl&gt;&gt;, SymbolTableIndexHashTraits&gt; m_map;
1134     ScopeOffset m_maxScopeOffset;
1135     unsigned m_usesNonStrictEval : 1;
1136     unsigned m_nestedLexicalScope : 1;
1137     unsigned m_scopeType : 3;
1138     CachedPtr&lt;CachedScopedArgumentsTable&gt; m_arguments;
1139 };
1140 
1141 class CachedJSValue;
1142 class CachedImmutableButterfly : public CachedObject&lt;JSImmutableButterfly&gt; {
1143 public:
1144     CachedImmutableButterfly()
1145         : m_cachedDoubles()
1146     {
1147     }
1148 
1149     void encode(Encoder&amp; encoder, JSImmutableButterfly&amp; immutableButterfly)
1150     {
1151         m_length = immutableButterfly.length();
1152         m_indexingType = immutableButterfly.indexingTypeAndMisc();
1153         if (hasDouble(m_indexingType))
1154             m_cachedDoubles.encode(encoder, immutableButterfly.toButterfly()-&gt;contiguousDouble().data(), m_length);
1155         else
1156             m_cachedValues.encode(encoder, immutableButterfly.toButterfly()-&gt;contiguous().data(), m_length);
1157     }
1158 
1159     JSImmutableButterfly* decode(Decoder&amp; decoder) const
1160     {
1161         JSImmutableButterfly* immutableButterfly = JSImmutableButterfly::create(decoder.vm(), m_indexingType, m_length);
1162         if (hasDouble(m_indexingType))
1163             m_cachedDoubles.decode(decoder, immutableButterfly-&gt;toButterfly()-&gt;contiguousDouble().data(), m_length, immutableButterfly);
1164         else
1165             m_cachedValues.decode(decoder, immutableButterfly-&gt;toButterfly()-&gt;contiguous().data(), m_length, immutableButterfly);
1166         return immutableButterfly;
1167     }
1168 
1169 private:
1170     IndexingType m_indexingType;
1171     unsigned m_length;
1172     union {
1173         CachedArray&lt;double&gt; m_cachedDoubles;
1174         CachedArray&lt;CachedJSValue, WriteBarrier&lt;Unknown&gt;&gt; m_cachedValues;
1175     };
1176 };
1177 
1178 class CachedRegExp : public CachedObject&lt;RegExp&gt; {
1179 public:
1180     void encode(Encoder&amp; encoder, const RegExp&amp; regExp)
1181     {
1182         m_patternString.encode(encoder, regExp.m_patternString);
1183         m_flags = regExp.m_flags;
1184     }
1185 
1186     RegExp* decode(Decoder&amp; decoder) const
1187     {
1188         String pattern { m_patternString.decode(decoder) };
1189         return RegExp::create(decoder.vm(), pattern, m_flags);
1190     }
1191 
1192 private:
1193     CachedString m_patternString;
<a name="75" id="anc75"></a><span class="line-modified">1194     OptionSet&lt;Yarr::Flags&gt; m_flags;</span>
1195 };
1196 
1197 class CachedTemplateObjectDescriptor : public CachedObject&lt;TemplateObjectDescriptor&gt; {
1198 public:
<a name="76" id="anc76"></a><span class="line-modified">1199     void encode(Encoder&amp; encoder, const JSTemplateObjectDescriptor&amp; descriptor)</span>
1200     {
<a name="77" id="anc77"></a><span class="line-modified">1201         m_rawStrings.encode(encoder, descriptor.descriptor().rawStrings());</span>
<span class="line-modified">1202         m_cookedStrings.encode(encoder, descriptor.descriptor().cookedStrings());</span>
<span class="line-added">1203         m_endOffset = descriptor.endOffset();</span>
1204     }
1205 
<a name="78" id="anc78"></a><span class="line-modified">1206     JSTemplateObjectDescriptor* decode(Decoder&amp; decoder) const</span>
1207     {
1208         TemplateObjectDescriptor::StringVector decodedRawStrings;
1209         TemplateObjectDescriptor::OptionalStringVector decodedCookedStrings;
1210         m_rawStrings.decode(decoder, decodedRawStrings);
1211         m_cookedStrings.decode(decoder, decodedCookedStrings);
<a name="79" id="anc79"></a><span class="line-modified">1212         return JSTemplateObjectDescriptor::create(decoder.vm(), TemplateObjectDescriptor::create(WTFMove(decodedRawStrings), WTFMove(decodedCookedStrings)), m_endOffset);</span>
1213     }
1214 
1215 private:
1216     CachedVector&lt;CachedString, 4&gt; m_rawStrings;
1217     CachedVector&lt;CachedOptional&lt;CachedString&gt;, 4&gt; m_cookedStrings;
<a name="80" id="anc80"></a><span class="line-added">1218     int m_endOffset;</span>
1219 };
1220 
1221 class CachedBigInt : public VariableLengthObject&lt;JSBigInt&gt; {
1222 public:
1223     void encode(Encoder&amp; encoder, JSBigInt&amp; bigInt)
1224     {
1225         m_length = bigInt.length();
1226         m_sign = bigInt.sign();
1227 
1228         if (!m_length)
1229             return;
1230 
1231         unsigned size = sizeof(JSBigInt::Digit) * m_length;
1232         uint8_t* buffer = this-&gt;allocate(encoder, size);
1233         memcpy(buffer, bigInt.dataStorage(), size);
1234     }
1235 
1236     JSBigInt* decode(Decoder&amp; decoder) const
1237     {
1238         JSBigInt* bigInt = JSBigInt::createWithLengthUnchecked(decoder.vm(), m_length);
1239         bigInt-&gt;setSign(m_sign);
1240         if (m_length)
1241             memcpy(bigInt-&gt;dataStorage(), this-&gt;buffer(), sizeof(JSBigInt::Digit) * m_length);
1242         return bigInt;
1243     }
1244 
1245 private:
1246     unsigned m_length;
1247     bool m_sign;
1248 };
1249 
1250 class CachedJSValue : public VariableLengthObject&lt;WriteBarrier&lt;Unknown&gt;&gt; {
1251 public:
1252     void encode(Encoder&amp; encoder, const WriteBarrier&lt;Unknown&gt; value)
1253     {
1254         JSValue v = value.get();
1255 
1256         if (!v.isCell() || v.isEmpty()) {
1257             m_type = EncodedType::JSValue;
1258             *this-&gt;allocate&lt;EncodedJSValue&gt;(encoder) = JSValue::encode(v);
1259             return;
1260         }
1261 
1262         JSCell* cell = v.asCell();
1263         VM&amp; vm = encoder.vm();
1264 
1265         if (auto* symbolTable = jsDynamicCast&lt;SymbolTable*&gt;(vm, cell)) {
1266             m_type = EncodedType::SymbolTable;
1267             this-&gt;allocate&lt;CachedSymbolTable&gt;(encoder)-&gt;encode(encoder, *symbolTable);
1268             return;
1269         }
1270 
1271         if (auto* string = jsDynamicCast&lt;JSString*&gt;(vm, cell)) {
1272             m_type = EncodedType::String;
1273             StringImpl* impl = string-&gt;tryGetValue().impl();
1274             this-&gt;allocate&lt;CachedUniquedStringImpl&gt;(encoder)-&gt;encode(encoder, *impl);
1275             return;
1276         }
1277 
1278         if (auto* immutableButterfly = jsDynamicCast&lt;JSImmutableButterfly*&gt;(vm, cell)) {
1279             m_type = EncodedType::ImmutableButterfly;
1280             this-&gt;allocate&lt;CachedImmutableButterfly&gt;(encoder)-&gt;encode(encoder, *immutableButterfly);
1281             return;
1282         }
1283 
1284         if (auto* regexp = jsDynamicCast&lt;RegExp*&gt;(vm, cell)) {
1285             m_type = EncodedType::RegExp;
1286             this-&gt;allocate&lt;CachedRegExp&gt;(encoder)-&gt;encode(encoder, *regexp);
1287             return;
1288         }
1289 
1290         if (auto* templateObjectDescriptor = jsDynamicCast&lt;JSTemplateObjectDescriptor*&gt;(vm, cell)) {
1291             m_type = EncodedType::TemplateObjectDescriptor;
<a name="81" id="anc81"></a><span class="line-modified">1292             this-&gt;allocate&lt;CachedTemplateObjectDescriptor&gt;(encoder)-&gt;encode(encoder, *templateObjectDescriptor);</span>
1293             return;
1294         }
1295 
1296         if (auto* bigInt = jsDynamicCast&lt;JSBigInt*&gt;(vm, cell)) {
1297             m_type = EncodedType::BigInt;
1298             this-&gt;allocate&lt;CachedBigInt&gt;(encoder)-&gt;encode(encoder, *bigInt);
1299             return;
1300         }
1301 
1302         RELEASE_ASSERT_NOT_REACHED();
1303     }
1304 
1305     void decode(Decoder&amp; decoder, WriteBarrier&lt;Unknown&gt;&amp; value, const JSCell* owner) const
1306     {
1307         JSValue v;
1308         switch (m_type) {
1309         case EncodedType::JSValue:
1310             v = JSValue::decode(*this-&gt;buffer&lt;EncodedJSValue&gt;());
1311             break;
1312         case EncodedType::SymbolTable:
1313             v = this-&gt;buffer&lt;CachedSymbolTable&gt;()-&gt;decode(decoder);
1314             break;
1315         case EncodedType::String: {
1316             StringImpl* impl = this-&gt;buffer&lt;CachedUniquedStringImpl&gt;()-&gt;decode(decoder);
<a name="82" id="anc82"></a><span class="line-modified">1317             v = jsString(decoder.vm(), adoptRef(*impl));</span>
1318             break;
1319         }
1320         case EncodedType::ImmutableButterfly:
1321             v = this-&gt;buffer&lt;CachedImmutableButterfly&gt;()-&gt;decode(decoder);
1322             break;
1323         case EncodedType::RegExp:
1324             v = this-&gt;buffer&lt;CachedRegExp&gt;()-&gt;decode(decoder);
1325             break;
1326         case EncodedType::TemplateObjectDescriptor:
<a name="83" id="anc83"></a><span class="line-modified">1327             v = this-&gt;buffer&lt;CachedTemplateObjectDescriptor&gt;()-&gt;decode(decoder);</span>
1328             break;
1329         case EncodedType::BigInt:
1330             v = this-&gt;buffer&lt;CachedBigInt&gt;()-&gt;decode(decoder);
1331             break;
1332         default:
1333             RELEASE_ASSERT_NOT_REACHED();
1334         }
1335         value.set(decoder.vm(), owner, v);
1336     }
1337 
1338 private:
1339     enum class EncodedType : uint8_t {
1340         JSValue,
1341         SymbolTable,
1342         String,
1343         ImmutableButterfly,
1344         RegExp,
1345         TemplateObjectDescriptor,
1346         BigInt,
1347     };
1348 
1349     EncodedType m_type;
1350 };
1351 
1352 class CachedInstructionStream : public CachedObject&lt;InstructionStream&gt; {
1353 public:
1354     void encode(Encoder&amp; encoder, const InstructionStream&amp; stream)
1355     {
1356         m_instructions.encode(encoder, stream.m_instructions);
1357     }
1358 
1359     InstructionStream* decode(Decoder&amp; decoder) const
1360     {
1361         Vector&lt;uint8_t, 0, UnsafeVectorOverflow&gt; instructionsVector;
1362         m_instructions.decode(decoder, instructionsVector);
1363         return new InstructionStream(WTFMove(instructionsVector));
1364     }
1365 
1366 private:
1367     CachedVector&lt;uint8_t, 0, UnsafeVectorOverflow&gt; m_instructions;
1368 };
1369 
1370 class CachedMetadataTable : public CachedObject&lt;UnlinkedMetadataTable&gt; {
1371 public:
1372     void encode(Encoder&amp;, const UnlinkedMetadataTable&amp; metadataTable)
1373     {
1374         ASSERT(metadataTable.m_isFinalized);
1375         m_hasMetadata = metadataTable.m_hasMetadata;
1376         if (!m_hasMetadata)
1377             return;
<a name="84" id="anc84"></a><span class="line-modified">1378         m_is32Bit = metadataTable.m_is32Bit;</span>
<span class="line-modified">1379         if (m_is32Bit) {</span>
<span class="line-added">1380             for (unsigned i = UnlinkedMetadataTable::s_offsetTableEntries; i--;)</span>
<span class="line-added">1381                 m_metadata[i] = metadataTable.offsetTable32()[i];</span>
<span class="line-added">1382         } else {</span>
<span class="line-added">1383             for (unsigned i = UnlinkedMetadataTable::s_offsetTableEntries; i--;)</span>
<span class="line-added">1384                 m_metadata[i] = metadataTable.offsetTable16()[i];</span>
<span class="line-added">1385         }</span>
1386     }
1387 
1388     Ref&lt;UnlinkedMetadataTable&gt; decode(Decoder&amp;) const
1389     {
<a name="85" id="anc85"></a><span class="line-modified">1390         if (!m_hasMetadata)</span>
<span class="line-added">1391             return UnlinkedMetadataTable::empty();</span>
<span class="line-added">1392 </span>
<span class="line-added">1393         Ref&lt;UnlinkedMetadataTable&gt; metadataTable = UnlinkedMetadataTable::create(m_is32Bit);</span>
1394         metadataTable-&gt;m_isFinalized = true;
1395         metadataTable-&gt;m_isLinked = false;
1396         metadataTable-&gt;m_hasMetadata = m_hasMetadata;
<a name="86" id="anc86"></a><span class="line-modified">1397         if (m_is32Bit) {</span>
<span class="line-modified">1398             for (unsigned i = UnlinkedMetadataTable::s_offsetTableEntries; i--;)</span>
<span class="line-added">1399                 metadataTable-&gt;offsetTable32()[i] = m_metadata[i];</span>
<span class="line-added">1400         } else {</span>
<span class="line-added">1401             for (unsigned i = UnlinkedMetadataTable::s_offsetTableEntries; i--;)</span>
<span class="line-added">1402                 metadataTable-&gt;offsetTable16()[i] = m_metadata[i];</span>
<span class="line-added">1403         }</span>
1404         return metadataTable;
1405     }
1406 
1407 private:
1408     bool m_hasMetadata;
<a name="87" id="anc87"></a><span class="line-added">1409     bool m_is32Bit;</span>
1410     std::array&lt;unsigned, UnlinkedMetadataTable::s_offsetTableEntries&gt; m_metadata;
1411 };
1412 
1413 class CachedSourceOrigin : public CachedObject&lt;SourceOrigin&gt; {
1414 public:
1415     void encode(Encoder&amp; encoder, const SourceOrigin&amp; sourceOrigin)
1416     {
1417         m_string.encode(encoder, sourceOrigin.string());
1418     }
1419 
1420     SourceOrigin decode(Decoder&amp; decoder) const
1421     {
1422         return SourceOrigin { m_string.decode(decoder) };
1423     }
1424 
1425 private:
1426     CachedString m_string;
1427 };
1428 
1429 class CachedTextPosition : public CachedObject&lt;TextPosition&gt; {
1430 public:
1431     void encode(Encoder&amp;, TextPosition textPosition)
1432     {
1433         m_line = textPosition.m_line.zeroBasedInt();
1434         m_column = textPosition.m_column.zeroBasedInt();
1435     }
1436 
1437     TextPosition decode(Decoder&amp;) const
1438     {
1439         return TextPosition { OrdinalNumber::fromZeroBasedInt(m_line), OrdinalNumber::fromZeroBasedInt(m_column) };
1440     }
1441 
1442 private:
1443     int m_line;
1444     int m_column;
1445 };
1446 
1447 template &lt;typename Source, typename CachedType&gt;
1448 class CachedSourceProviderShape : public CachedObject&lt;Source&gt; {
1449 public:
1450     void encode(Encoder&amp; encoder, const SourceProvider&amp; sourceProvider)
1451     {
1452         m_sourceOrigin.encode(encoder, sourceProvider.sourceOrigin());
1453         m_url.encode(encoder, sourceProvider.url());
1454         m_sourceURLDirective.encode(encoder, sourceProvider.sourceURLDirective());
1455         m_sourceMappingURLDirective.encode(encoder, sourceProvider.sourceMappingURLDirective());
1456         m_startPosition.encode(encoder, sourceProvider.startPosition());
1457     }
1458 
1459     void decode(Decoder&amp; decoder, SourceProvider&amp; sourceProvider) const
1460     {
1461         sourceProvider.setSourceURLDirective(m_sourceURLDirective.decode(decoder));
1462         sourceProvider.setSourceMappingURLDirective(m_sourceMappingURLDirective.decode(decoder));
1463     }
1464 
1465 protected:
1466     CachedSourceOrigin m_sourceOrigin;
1467     CachedString m_url;
1468     CachedString m_sourceURLDirective;
1469     CachedString m_sourceMappingURLDirective;
1470     CachedTextPosition m_startPosition;
1471 };
1472 
1473 class CachedStringSourceProvider : public CachedSourceProviderShape&lt;StringSourceProvider, CachedStringSourceProvider&gt; {
1474     using Base = CachedSourceProviderShape&lt;StringSourceProvider, CachedStringSourceProvider&gt;;
1475 
1476 public:
1477     void encode(Encoder&amp; encoder, const StringSourceProvider&amp; sourceProvider)
1478     {
1479         Base::encode(encoder, sourceProvider);
1480         m_source.encode(encoder, sourceProvider.source().toString());
1481     }
1482 
1483     StringSourceProvider* decode(Decoder&amp; decoder, SourceProviderSourceType sourceType) const
1484     {
1485         String decodedSource = m_source.decode(decoder);
1486         SourceOrigin decodedSourceOrigin = m_sourceOrigin.decode(decoder);
1487         String decodedURL = m_url.decode(decoder);
1488         TextPosition decodedStartPosition = m_startPosition.decode(decoder);
1489 
1490         Ref&lt;StringSourceProvider&gt; sourceProvider = StringSourceProvider::create(decodedSource, decodedSourceOrigin, URL(URL(), decodedURL), decodedStartPosition, sourceType);
1491         Base::decode(decoder, sourceProvider.get());
1492         return &amp;sourceProvider.leakRef();
1493     }
1494 
1495 private:
1496     CachedString m_source;
1497 };
1498 
1499 #if ENABLE(WEBASSEMBLY)
1500 class CachedWebAssemblySourceProvider : public CachedSourceProviderShape&lt;WebAssemblySourceProvider, CachedWebAssemblySourceProvider&gt; {
1501     using Base = CachedSourceProviderShape&lt;WebAssemblySourceProvider, CachedWebAssemblySourceProvider&gt;;
1502 
1503 public:
1504     void encode(Encoder&amp; encoder, const WebAssemblySourceProvider&amp; sourceProvider)
1505     {
1506         Base::encode(encoder, sourceProvider);
1507         m_data.encode(encoder, sourceProvider.data());
1508     }
1509 
1510     WebAssemblySourceProvider* decode(Decoder&amp; decoder) const
1511     {
1512         Vector&lt;uint8_t&gt; decodedData;
1513         SourceOrigin decodedSourceOrigin = m_sourceOrigin.decode(decoder);
1514         String decodedURL = m_url.decode(decoder);
1515 
1516         m_data.decode(decoder, decodedData);
1517 
1518         Ref&lt;WebAssemblySourceProvider&gt; sourceProvider = WebAssemblySourceProvider::create(WTFMove(decodedData), decodedSourceOrigin, URL(URL(), decodedURL));
1519         Base::decode(decoder, sourceProvider.get());
1520 
1521         return &amp;sourceProvider.leakRef();
1522     }
1523 
1524 private:
1525     CachedVector&lt;uint8_t&gt; m_data;
1526 };
1527 #endif
1528 
1529 class CachedSourceProvider : public VariableLengthObject&lt;SourceProvider&gt; {
1530 public:
1531     void encode(Encoder&amp; encoder, const SourceProvider&amp; sourceProvider)
1532     {
1533         m_sourceType = sourceProvider.sourceType();
1534         switch (m_sourceType) {
1535         case SourceProviderSourceType::Program:
1536         case SourceProviderSourceType::Module:
1537             this-&gt;allocate&lt;CachedStringSourceProvider&gt;(encoder)-&gt;encode(encoder, reinterpret_cast&lt;const StringSourceProvider&amp;&gt;(sourceProvider));
1538             break;
1539 #if ENABLE(WEBASSEMBLY)
1540         case SourceProviderSourceType::WebAssembly:
1541             this-&gt;allocate&lt;CachedWebAssemblySourceProvider&gt;(encoder)-&gt;encode(encoder, reinterpret_cast&lt;const WebAssemblySourceProvider&amp;&gt;(sourceProvider));
1542             break;
1543 #endif
1544         default:
1545             RELEASE_ASSERT_NOT_REACHED();
1546         }
1547     }
1548 
1549     SourceProvider* decode(Decoder&amp; decoder) const
1550     {
1551         switch (m_sourceType) {
1552         case SourceProviderSourceType::Program:
1553         case SourceProviderSourceType::Module:
1554             return this-&gt;buffer&lt;CachedStringSourceProvider&gt;()-&gt;decode(decoder, m_sourceType);
1555 #if ENABLE(WEBASSEMBLY)
1556         case SourceProviderSourceType::WebAssembly:
1557             return this-&gt;buffer&lt;CachedWebAssemblySourceProvider&gt;()-&gt;decode(decoder);
1558 #endif
1559         default:
1560             RELEASE_ASSERT_NOT_REACHED();
1561         }
1562     }
1563 
1564 private:
1565     SourceProviderSourceType m_sourceType;
1566 };
1567 
1568 template&lt;typename Source&gt;
1569 class CachedUnlinkedSourceCodeShape : public CachedObject&lt;Source&gt; {
1570 public:
1571     void encode(Encoder&amp; encoder, const UnlinkedSourceCode&amp; sourceCode)
1572     {
<a name="88" id="anc88"></a><span class="line-modified">1573         m_provider.encode(encoder, sourceCode.m_provider);</span>
1574         m_startOffset = sourceCode.startOffset();
1575         m_endOffset = sourceCode.endOffset();
1576     }
1577 
1578     void decode(Decoder&amp; decoder, UnlinkedSourceCode&amp; sourceCode) const
1579     {
1580         sourceCode.m_provider = m_provider.decode(decoder);
1581         sourceCode.m_startOffset = m_startOffset;
1582         sourceCode.m_endOffset = m_endOffset;
1583     }
1584 
1585 private:
<a name="89" id="anc89"></a><span class="line-modified">1586     CachedRefPtr&lt;CachedSourceProvider&gt; m_provider;</span>
1587     int m_startOffset;
1588     int m_endOffset;
1589 };
1590 
1591 
1592 class CachedUnlinkedSourceCode : public CachedUnlinkedSourceCodeShape&lt;UnlinkedSourceCode&gt; { };
1593 
1594 class CachedSourceCode : public CachedUnlinkedSourceCodeShape&lt;SourceCode&gt; {
1595     using Base = CachedUnlinkedSourceCodeShape&lt;SourceCode&gt;;
1596 
1597 public:
1598     void encode(Encoder&amp; encoder, const SourceCode&amp; sourceCode)
1599     {
1600         Base::encode(encoder, sourceCode);
1601         m_firstLine = sourceCode.firstLine().zeroBasedInt();
1602         m_startColumn = sourceCode.startColumn().zeroBasedInt();
1603     }
1604 
1605     void decode(Decoder&amp; decoder, SourceCode&amp; sourceCode) const
1606     {
1607         Base::decode(decoder, sourceCode);
1608         sourceCode.m_firstLine = OrdinalNumber::fromZeroBasedInt(m_firstLine);
1609         sourceCode.m_startColumn = OrdinalNumber::fromZeroBasedInt(m_startColumn);
1610     }
1611 
1612 private:
1613     int m_firstLine;
1614     int m_startColumn;
1615 };
1616 
<a name="90" id="anc90"></a><span class="line-added">1617 class CachedSourceCodeWithoutProvider : public CachedObject&lt;SourceCode&gt; {</span>
<span class="line-added">1618 public:</span>
<span class="line-added">1619     void encode(Encoder&amp;, const SourceCode&amp; sourceCode)</span>
<span class="line-added">1620     {</span>
<span class="line-added">1621         m_hasProvider = !!sourceCode.provider();</span>
<span class="line-added">1622         m_startOffset = sourceCode.startOffset();</span>
<span class="line-added">1623         m_endOffset = sourceCode.endOffset();</span>
<span class="line-added">1624         m_firstLine = sourceCode.firstLine().zeroBasedInt();</span>
<span class="line-added">1625         m_startColumn = sourceCode.startColumn().zeroBasedInt();</span>
<span class="line-added">1626     }</span>
<span class="line-added">1627 </span>
<span class="line-added">1628     void decode(Decoder&amp; decoder, SourceCode&amp; sourceCode) const</span>
<span class="line-added">1629     {</span>
<span class="line-added">1630         if (m_hasProvider)</span>
<span class="line-added">1631             sourceCode.m_provider = decoder.provider();</span>
<span class="line-added">1632         sourceCode.m_startOffset = m_startOffset;</span>
<span class="line-added">1633         sourceCode.m_endOffset = m_endOffset;</span>
<span class="line-added">1634         sourceCode.m_firstLine = OrdinalNumber::fromZeroBasedInt(m_firstLine);</span>
<span class="line-added">1635         sourceCode.m_startColumn = OrdinalNumber::fromZeroBasedInt(m_startColumn);</span>
<span class="line-added">1636     }</span>
<span class="line-added">1637 </span>
<span class="line-added">1638 private:</span>
<span class="line-added">1639     bool m_hasProvider;</span>
<span class="line-added">1640     int m_startOffset;</span>
<span class="line-added">1641     int m_endOffset;</span>
<span class="line-added">1642     int m_firstLine;</span>
<span class="line-added">1643     int m_startColumn;</span>
<span class="line-added">1644 };</span>
<span class="line-added">1645 </span>
1646 class CachedFunctionExecutableRareData : public CachedObject&lt;UnlinkedFunctionExecutable::RareData&gt; {
1647 public:
1648     void encode(Encoder&amp; encoder, const UnlinkedFunctionExecutable::RareData&amp; rareData)
1649     {
1650         m_classSource.encode(encoder, rareData.m_classSource);
<a name="91" id="anc91"></a><span class="line-added">1651         m_parentScopeTDZVariables.encode(encoder, rareData.m_parentScopeTDZVariables);</span>
1652     }
1653 
1654     UnlinkedFunctionExecutable::RareData* decode(Decoder&amp; decoder) const
1655     {
1656         UnlinkedFunctionExecutable::RareData* rareData = new UnlinkedFunctionExecutable::RareData { };
1657         m_classSource.decode(decoder, rareData-&gt;m_classSource);
<a name="92" id="anc92"></a><span class="line-added">1658         auto parentScopeTDZVariables = m_parentScopeTDZVariables.decode(decoder);</span>
<span class="line-added">1659         rareData-&gt;m_parentScopeTDZVariables = WTFMove(parentScopeTDZVariables);</span>
1660         return rareData;
1661     }
1662 
1663 private:
<a name="93" id="anc93"></a><span class="line-modified">1664     CachedSourceCodeWithoutProvider m_classSource;</span>
<span class="line-added">1665     CachedCompactVariableMapHandle m_parentScopeTDZVariables;</span>
1666 };
1667 
1668 class CachedFunctionExecutable : public CachedObject&lt;UnlinkedFunctionExecutable&gt; {
<a name="94" id="anc94"></a><span class="line-added">1669     friend struct CachedFunctionExecutableOffsets;</span>
<span class="line-added">1670 </span>
1671 public:
1672     void encode(Encoder&amp;, const UnlinkedFunctionExecutable&amp;);
1673     UnlinkedFunctionExecutable* decode(Decoder&amp;) const;
1674 
1675     unsigned firstLineOffset() const { return m_firstLineOffset; }
1676     unsigned lineCount() const { return m_lineCount; }
1677     unsigned unlinkedFunctionNameStart() const { return m_unlinkedFunctionNameStart; }
1678     unsigned unlinkedBodyStartColumn() const { return m_unlinkedBodyStartColumn; }
1679     unsigned unlinkedBodyEndColumn() const { return m_unlinkedBodyEndColumn; }
1680     unsigned startOffset() const { return m_startOffset; }
1681     unsigned sourceLength() const { return m_sourceLength; }
1682     unsigned parametersStartOffset() const { return m_parametersStartOffset; }
1683     unsigned typeProfilingStartOffset() const { return m_typeProfilingStartOffset; }
1684     unsigned typeProfilingEndOffset() const { return m_typeProfilingEndOffset; }
1685     unsigned parameterCount() const { return m_parameterCount; }
1686 
<a name="95" id="anc95"></a><span class="line-modified">1687     CodeFeatures features() const { return m_mutableMetadata.m_features; }</span>
1688     SourceParseMode sourceParseMode() const { return m_sourceParseMode; }
1689 
1690     unsigned isInStrictContext() const { return m_isInStrictContext; }
<a name="96" id="anc96"></a><span class="line-modified">1691     unsigned hasCapturedVariables() const { return m_mutableMetadata.m_hasCapturedVariables; }</span>
1692     unsigned isBuiltinFunction() const { return m_isBuiltinFunction; }
1693     unsigned isBuiltinDefaultClassConstructor() const { return m_isBuiltinDefaultClassConstructor; }
1694     unsigned constructAbility() const { return m_constructAbility; }
1695     unsigned constructorKind() const { return m_constructorKind; }
1696     unsigned functionMode() const { return m_functionMode; }
1697     unsigned scriptMode() const { return m_scriptMode; }
1698     unsigned superBinding() const { return m_superBinding; }
1699     unsigned derivedContextType() const { return m_derivedContextType; }
1700 
1701     Identifier name(Decoder&amp; decoder) const { return m_name.decode(decoder); }
1702     Identifier ecmaName(Decoder&amp; decoder) const { return m_ecmaName.decode(decoder); }
<a name="97" id="anc97"></a>
1703 
<a name="98" id="anc98"></a><span class="line-modified">1704     UnlinkedFunctionExecutable::RareData* rareData(Decoder&amp; decoder) const { return m_rareData.decode(decoder); }</span>
<span class="line-added">1705 </span>
<span class="line-added">1706     const CachedWriteBarrier&lt;CachedFunctionCodeBlock, UnlinkedFunctionCodeBlock&gt;&amp; unlinkedCodeBlockForCall() const { return m_unlinkedCodeBlockForCall; }</span>
<span class="line-added">1707     const CachedWriteBarrier&lt;CachedFunctionCodeBlock, UnlinkedFunctionCodeBlock&gt;&amp; unlinkedCodeBlockForConstruct() const { return m_unlinkedCodeBlockForConstruct; }</span>
1708 
1709 private:
<a name="99" id="anc99"></a><span class="line-modified">1710     CachedFunctionExecutableMetadata m_mutableMetadata;</span>
<span class="line-modified">1711 </span>
<span class="line-modified">1712     unsigned m_firstLineOffset : 31;</span>










1713     unsigned m_isInStrictContext : 1;
<a name="100" id="anc100"></a><span class="line-modified">1714     unsigned m_lineCount : 31;</span>
1715     unsigned m_isBuiltinFunction : 1;
<a name="101" id="anc101"></a><span class="line-added">1716     unsigned m_unlinkedFunctionNameStart : 31;</span>
1717     unsigned m_isBuiltinDefaultClassConstructor : 1;
<a name="102" id="anc102"></a><span class="line-added">1718     unsigned m_unlinkedBodyStartColumn : 31;</span>
1719     unsigned m_constructAbility: 1;
<a name="103" id="anc103"></a><span class="line-modified">1720     unsigned m_unlinkedBodyEndColumn : 31;</span>
<span class="line-modified">1721     unsigned m_startOffset : 31;</span>
1722     unsigned m_scriptMode: 1; // JSParserScriptMode
<a name="104" id="anc104"></a><span class="line-added">1723     unsigned m_sourceLength : 31;</span>
1724     unsigned m_superBinding : 1;
<a name="105" id="anc105"></a><span class="line-added">1725     unsigned m_parametersStartOffset : 31;</span>
<span class="line-added">1726     unsigned m_typeProfilingStartOffset;</span>
<span class="line-added">1727     unsigned m_typeProfilingEndOffset;</span>
<span class="line-added">1728     unsigned m_parameterCount;</span>
<span class="line-added">1729     SourceParseMode m_sourceParseMode;</span>
<span class="line-added">1730     unsigned m_constructorKind : 2;</span>
<span class="line-added">1731     unsigned m_functionMode : 2; // FunctionMode</span>
1732     unsigned m_derivedContextType: 2;
1733 
<a name="106" id="anc106"></a><span class="line-modified">1734     CachedPtr&lt;CachedFunctionExecutableRareData&gt; m_rareData;</span>
1735 
1736     CachedIdentifier m_name;
1737     CachedIdentifier m_ecmaName;
<a name="107" id="anc107"></a>


1738 
1739     CachedWriteBarrier&lt;CachedFunctionCodeBlock, UnlinkedFunctionCodeBlock&gt; m_unlinkedCodeBlockForCall;
1740     CachedWriteBarrier&lt;CachedFunctionCodeBlock, UnlinkedFunctionCodeBlock&gt; m_unlinkedCodeBlockForConstruct;
1741 };
1742 
<a name="108" id="anc108"></a><span class="line-added">1743 ptrdiff_t CachedFunctionExecutableOffsets::codeBlockForCallOffset()</span>
<span class="line-added">1744 {</span>
<span class="line-added">1745     return OBJECT_OFFSETOF(CachedFunctionExecutable, m_unlinkedCodeBlockForCall);</span>
<span class="line-added">1746 }</span>
<span class="line-added">1747 </span>
<span class="line-added">1748 ptrdiff_t CachedFunctionExecutableOffsets::codeBlockForConstructOffset()</span>
<span class="line-added">1749 {</span>
<span class="line-added">1750     return OBJECT_OFFSETOF(CachedFunctionExecutable, m_unlinkedCodeBlockForConstruct);</span>
<span class="line-added">1751 }</span>
<span class="line-added">1752 </span>
<span class="line-added">1753 ptrdiff_t CachedFunctionExecutableOffsets::metadataOffset()</span>
<span class="line-added">1754 {</span>
<span class="line-added">1755     return OBJECT_OFFSETOF(CachedFunctionExecutable, m_mutableMetadata);</span>
<span class="line-added">1756 }</span>
<span class="line-added">1757 </span>
1758 template&lt;typename CodeBlockType&gt;
1759 class CachedCodeBlock : public CachedObject&lt;CodeBlockType&gt; {
1760 public:
1761     void encode(Encoder&amp;, const UnlinkedCodeBlock&amp;);
1762     void decode(Decoder&amp;, UnlinkedCodeBlock&amp;) const;
1763 
1764     InstructionStream* instructions(Decoder&amp; decoder) const { return m_instructions.decode(decoder); }
1765 
1766     VirtualRegister thisRegister() const { return m_thisRegister; }
1767     VirtualRegister scopeRegister() const { return m_scopeRegister; }
1768 
1769     String sourceURLDirective(Decoder&amp; decoder) const { return m_sourceURLDirective.decode(decoder); }
1770     String sourceMappingURLDirective(Decoder&amp; decoder) const { return m_sourceMappingURLDirective.decode(decoder); }
1771 
1772     Ref&lt;UnlinkedMetadataTable&gt; metadata(Decoder&amp; decoder) const { return m_metadata.decode(decoder); }
1773 
1774     unsigned usesEval() const { return m_usesEval; }
1775     unsigned isStrictMode() const { return m_isStrictMode; }
1776     unsigned isConstructor() const { return m_isConstructor; }
1777     unsigned hasCapturedVariables() const { return m_hasCapturedVariables; }
1778     unsigned isBuiltinFunction() const { return m_isBuiltinFunction; }
1779     unsigned superBinding() const { return m_superBinding; }
1780     unsigned scriptMode() const { return m_scriptMode; }
1781     unsigned isArrowFunctionContext() const { return m_isArrowFunctionContext; }
1782     unsigned isClassContext() const { return m_isClassContext; }
<a name="109" id="anc109"></a>
1783     unsigned constructorKind() const { return m_constructorKind; }
1784     unsigned derivedContextType() const { return m_derivedContextType; }
1785     unsigned evalContextType() const { return m_evalContextType; }
1786     unsigned hasTailCalls() const { return m_hasTailCalls; }
1787     unsigned lineCount() const { return m_lineCount; }
1788     unsigned endColumn() const { return m_endColumn; }
1789 
1790     int numVars() const { return m_numVars; }
1791     int numCalleeLocals() const { return m_numCalleeLocals; }
1792     int numParameters() const { return m_numParameters; }
1793 
1794     CodeFeatures features() const { return m_features; }
1795     SourceParseMode parseMode() const { return m_parseMode; }
<a name="110" id="anc110"></a><span class="line-added">1796     OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode() const { return m_codeGenerationMode; }</span>
1797     unsigned codeType() const { return m_codeType; }
1798 
<a name="111" id="anc111"></a><span class="line-modified">1799     UnlinkedCodeBlock::RareData* rareData(Decoder&amp; decoder) const { return m_rareData.decode(decoder); }</span>
1800 
1801 private:
1802     VirtualRegister m_thisRegister;
1803     VirtualRegister m_scopeRegister;
1804     std::array&lt;unsigned, LinkTimeConstantCount&gt; m_linkTimeConstants;
1805 
1806     unsigned m_usesEval : 1;
1807     unsigned m_isStrictMode : 1;
1808     unsigned m_isConstructor : 1;
1809     unsigned m_hasCapturedVariables : 1;
1810     unsigned m_isBuiltinFunction : 1;
1811     unsigned m_superBinding : 1;
1812     unsigned m_scriptMode: 1;
1813     unsigned m_isArrowFunctionContext : 1;
1814     unsigned m_isClassContext : 1;
<a name="112" id="anc112"></a>
1815     unsigned m_constructorKind : 2;
1816     unsigned m_derivedContextType : 2;
1817     unsigned m_evalContextType : 2;
1818     unsigned m_hasTailCalls : 1;
1819     unsigned m_codeType : 2;
1820 
1821     CodeFeatures m_features;
1822     SourceParseMode m_parseMode;
<a name="113" id="anc113"></a><span class="line-added">1823     OptionSet&lt;CodeGenerationMode&gt; m_codeGenerationMode;</span>
1824 
1825     unsigned m_lineCount;
1826     unsigned m_endColumn;
1827 
1828     int m_numVars;
1829     int m_numCalleeLocals;
1830     int m_numParameters;
1831 
1832     CachedMetadataTable m_metadata;
1833 
<a name="114" id="anc114"></a><span class="line-modified">1834     CachedPtr&lt;CachedCodeBlockRareData&gt; m_rareData;</span>
1835 
1836     CachedString m_sourceURLDirective;
1837     CachedString m_sourceMappingURLDirective;
1838 
1839     CachedPtr&lt;CachedInstructionStream&gt; m_instructions;
1840     CachedVector&lt;InstructionStream::Offset&gt; m_jumpTargets;
1841     CachedVector&lt;InstructionStream::Offset&gt; m_propertyAccessInstructions;
1842     CachedVector&lt;CachedJSValue&gt; m_constantRegisters;
1843     CachedVector&lt;SourceCodeRepresentation&gt; m_constantsSourceCodeRepresentation;
1844     CachedVector&lt;ExpressionRangeInfo&gt; m_expressionInfo;
1845     CachedHashMap&lt;InstructionStream::Offset, int&gt; m_outOfLineJumpTargets;
1846 
1847     CachedVector&lt;CachedIdentifier&gt; m_identifiers;
1848     CachedVector&lt;CachedWriteBarrier&lt;CachedFunctionExecutable&gt;&gt; m_functionDecls;
1849     CachedVector&lt;CachedWriteBarrier&lt;CachedFunctionExecutable&gt;&gt; m_functionExprs;
1850 };
1851 
1852 class CachedProgramCodeBlock : public CachedCodeBlock&lt;UnlinkedProgramCodeBlock&gt; {
1853     using Base = CachedCodeBlock&lt;UnlinkedProgramCodeBlock&gt;;
1854 
1855 public:
1856     void encode(Encoder&amp; encoder, const UnlinkedProgramCodeBlock&amp; codeBlock)
1857     {
1858         Base::encode(encoder, codeBlock);
1859         m_varDeclarations.encode(encoder, codeBlock.m_varDeclarations);
1860         m_lexicalDeclarations.encode(encoder, codeBlock.m_lexicalDeclarations);
1861     }
1862 
1863     UnlinkedProgramCodeBlock* decode(Decoder&amp; decoder) const
1864     {
1865         UnlinkedProgramCodeBlock* codeBlock = new (NotNull, allocateCell&lt;UnlinkedProgramCodeBlock&gt;(decoder.vm().heap)) UnlinkedProgramCodeBlock(decoder, *this);
1866         codeBlock-&gt;finishCreation(decoder.vm());
1867         Base::decode(decoder, *codeBlock);
1868         m_varDeclarations.decode(decoder, codeBlock-&gt;m_varDeclarations);
1869         m_lexicalDeclarations.decode(decoder, codeBlock-&gt;m_lexicalDeclarations);
1870         return codeBlock;
1871     }
1872 
1873 private:
1874     CachedVariableEnvironment m_varDeclarations;
1875     CachedVariableEnvironment m_lexicalDeclarations;
1876 };
1877 
1878 class CachedModuleCodeBlock : public CachedCodeBlock&lt;UnlinkedModuleProgramCodeBlock&gt; {
1879     using Base = CachedCodeBlock&lt;UnlinkedModuleProgramCodeBlock&gt;;
1880 
1881 public:
1882     void encode(Encoder&amp; encoder, const UnlinkedModuleProgramCodeBlock&amp; codeBlock)
1883     {
1884         Base::encode(encoder, codeBlock);
1885         m_moduleEnvironmentSymbolTableConstantRegisterOffset = codeBlock.m_moduleEnvironmentSymbolTableConstantRegisterOffset;
1886     }
1887 
1888     UnlinkedModuleProgramCodeBlock* decode(Decoder&amp; decoder) const
1889     {
1890         UnlinkedModuleProgramCodeBlock* codeBlock = new (NotNull, allocateCell&lt;UnlinkedModuleProgramCodeBlock&gt;(decoder.vm().heap)) UnlinkedModuleProgramCodeBlock(decoder, *this);
1891         codeBlock-&gt;finishCreation(decoder.vm());
1892         Base::decode(decoder, *codeBlock);
1893         codeBlock-&gt;m_moduleEnvironmentSymbolTableConstantRegisterOffset = m_moduleEnvironmentSymbolTableConstantRegisterOffset;
1894         return codeBlock;
1895     }
1896 
1897 private:
1898     int m_moduleEnvironmentSymbolTableConstantRegisterOffset;
1899 };
1900 
1901 class CachedEvalCodeBlock : public CachedCodeBlock&lt;UnlinkedEvalCodeBlock&gt; {
1902     using Base = CachedCodeBlock&lt;UnlinkedEvalCodeBlock&gt;;
1903 
1904 public:
1905     void encode(Encoder&amp; encoder, const UnlinkedEvalCodeBlock&amp; codeBlock)
1906     {
1907         Base::encode(encoder, codeBlock);
1908         m_variables.encode(encoder, codeBlock.m_variables);
1909         m_functionHoistingCandidates.encode(encoder, codeBlock.m_functionHoistingCandidates);
1910     }
1911 
1912     UnlinkedEvalCodeBlock* decode(Decoder&amp; decoder) const
1913     {
1914         UnlinkedEvalCodeBlock* codeBlock = new (NotNull, allocateCell&lt;UnlinkedEvalCodeBlock&gt;(decoder.vm().heap)) UnlinkedEvalCodeBlock(decoder, *this);
1915         codeBlock-&gt;finishCreation(decoder.vm());
1916         Base::decode(decoder, *codeBlock);
1917         m_variables.decode(decoder, codeBlock-&gt;m_variables);
1918         m_functionHoistingCandidates.decode(decoder, codeBlock-&gt;m_functionHoistingCandidates);
1919         return codeBlock;
1920     }
1921 
1922 private:
1923     CachedVector&lt;CachedIdentifier, 0, UnsafeVectorOverflow&gt; m_variables;
1924     CachedVector&lt;CachedIdentifier, 0, UnsafeVectorOverflow&gt; m_functionHoistingCandidates;
1925 };
1926 
1927 class CachedFunctionCodeBlock : public CachedCodeBlock&lt;UnlinkedFunctionCodeBlock&gt; {
1928     using Base = CachedCodeBlock&lt;UnlinkedFunctionCodeBlock&gt;;
1929 
1930 public:
1931     void encode(Encoder&amp; encoder, const UnlinkedFunctionCodeBlock&amp; codeBlock)
1932     {
1933         Base::encode(encoder, codeBlock);
1934     }
1935 
1936     UnlinkedFunctionCodeBlock* decode(Decoder&amp; decoder) const
1937     {
1938         UnlinkedFunctionCodeBlock* codeBlock = new (NotNull, allocateCell&lt;UnlinkedFunctionCodeBlock&gt;(decoder.vm().heap)) UnlinkedFunctionCodeBlock(decoder, *this);
1939         codeBlock-&gt;finishCreation(decoder.vm());
1940         Base::decode(decoder, *codeBlock);
1941         return codeBlock;
1942     }
1943 };
1944 
1945 ALWAYS_INLINE UnlinkedFunctionCodeBlock::UnlinkedFunctionCodeBlock(Decoder&amp; decoder, const CachedFunctionCodeBlock&amp; cachedCodeBlock)
1946     : Base(decoder, decoder.vm().unlinkedFunctionCodeBlockStructure.get(), cachedCodeBlock)
1947 {
1948 }
1949 
1950 template&lt;typename T&gt;
1951 struct CachedCodeBlockTypeImpl;
1952 
1953 enum CachedCodeBlockTag {
1954     CachedProgramCodeBlockTag,
1955     CachedModuleCodeBlockTag,
1956     CachedEvalCodeBlockTag,
1957 };
1958 
<a name="115" id="anc115"></a><span class="line-added">1959 static CachedCodeBlockTag tagFromSourceCodeType(SourceCodeType type)</span>
<span class="line-added">1960 {</span>
<span class="line-added">1961     switch (type) {</span>
<span class="line-added">1962     case SourceCodeType::ProgramType:</span>
<span class="line-added">1963         return CachedProgramCodeBlockTag;</span>
<span class="line-added">1964     case SourceCodeType::EvalType:</span>
<span class="line-added">1965         return CachedEvalCodeBlockTag;</span>
<span class="line-added">1966     case SourceCodeType::ModuleType:</span>
<span class="line-added">1967         return CachedModuleCodeBlockTag;</span>
<span class="line-added">1968     case SourceCodeType::FunctionType:</span>
<span class="line-added">1969         break;</span>
<span class="line-added">1970     }</span>
<span class="line-added">1971     ASSERT_NOT_REACHED();</span>
<span class="line-added">1972     return static_cast&lt;CachedCodeBlockTag&gt;(-1);</span>
<span class="line-added">1973 }</span>
<span class="line-added">1974 </span>
1975 template&lt;&gt;
1976 struct CachedCodeBlockTypeImpl&lt;UnlinkedProgramCodeBlock&gt; {
1977     using type = CachedProgramCodeBlock;
1978     static constexpr CachedCodeBlockTag tag = CachedProgramCodeBlockTag;
1979 };
1980 
1981 template&lt;&gt;
1982 struct CachedCodeBlockTypeImpl&lt;UnlinkedModuleProgramCodeBlock&gt; {
1983     using type = CachedModuleCodeBlock;
1984     static constexpr CachedCodeBlockTag tag = CachedModuleCodeBlockTag;
1985 };
1986 
1987 template&lt;&gt;
1988 struct CachedCodeBlockTypeImpl&lt;UnlinkedEvalCodeBlock&gt; {
1989     using type = CachedEvalCodeBlock;
1990     static constexpr CachedCodeBlockTag tag = CachedEvalCodeBlockTag;
1991 };
1992 
1993 template&lt;typename T&gt;
1994 using CachedCodeBlockType = typename CachedCodeBlockTypeImpl&lt;T&gt;::type;
1995 
1996 template&lt;typename CodeBlockType&gt;
1997 ALWAYS_INLINE UnlinkedCodeBlock::UnlinkedCodeBlock(Decoder&amp; decoder, Structure* structure, const CachedCodeBlock&lt;CodeBlockType&gt;&amp; cachedCodeBlock)
1998     : Base(decoder.vm(), structure)
1999     , m_thisRegister(cachedCodeBlock.thisRegister())
2000     , m_scopeRegister(cachedCodeBlock.scopeRegister())
2001 
2002     , m_usesEval(cachedCodeBlock.usesEval())
2003     , m_isStrictMode(cachedCodeBlock.isStrictMode())
2004     , m_isConstructor(cachedCodeBlock.isConstructor())
2005     , m_hasCapturedVariables(cachedCodeBlock.hasCapturedVariables())
2006     , m_isBuiltinFunction(cachedCodeBlock.isBuiltinFunction())
2007     , m_superBinding(cachedCodeBlock.superBinding())
2008     , m_scriptMode(cachedCodeBlock.scriptMode())
2009     , m_isArrowFunctionContext(cachedCodeBlock.isArrowFunctionContext())
2010     , m_isClassContext(cachedCodeBlock.isClassContext())
<a name="116" id="anc116"></a><span class="line-modified">2011     , m_hasTailCalls(cachedCodeBlock.hasTailCalls())</span>
2012     , m_constructorKind(cachedCodeBlock.constructorKind())
2013     , m_derivedContextType(cachedCodeBlock.derivedContextType())
2014     , m_evalContextType(cachedCodeBlock.evalContextType())
<a name="117" id="anc117"></a>
2015     , m_codeType(cachedCodeBlock.codeType())
2016 
<a name="118" id="anc118"></a><span class="line-added">2017     , m_didOptimize(static_cast&lt;unsigned&gt;(MixedTriState))</span>
<span class="line-added">2018     , m_age(0)</span>
<span class="line-added">2019 </span>
2020     , m_features(cachedCodeBlock.features())
2021     , m_parseMode(cachedCodeBlock.parseMode())
<a name="119" id="anc119"></a><span class="line-added">2022     , m_codeGenerationMode(cachedCodeBlock.codeGenerationMode())</span>
2023 
2024     , m_lineCount(cachedCodeBlock.lineCount())
2025     , m_endColumn(cachedCodeBlock.endColumn())
2026     , m_numVars(cachedCodeBlock.numVars())
2027     , m_numCalleeLocals(cachedCodeBlock.numCalleeLocals())
2028     , m_numParameters(cachedCodeBlock.numParameters())
2029 
2030     , m_sourceURLDirective(cachedCodeBlock.sourceURLDirective(decoder))
2031     , m_sourceMappingURLDirective(cachedCodeBlock.sourceMappingURLDirective(decoder))
2032 
2033     , m_metadata(cachedCodeBlock.metadata(decoder))
2034     , m_instructions(cachedCodeBlock.instructions(decoder))
2035 
2036     , m_rareData(cachedCodeBlock.rareData(decoder))
2037 {
2038 }
2039 
2040 template&lt;typename CodeBlockType&gt;
2041 ALWAYS_INLINE void CachedCodeBlock&lt;CodeBlockType&gt;::decode(Decoder&amp; decoder, UnlinkedCodeBlock&amp; codeBlock) const
2042 {
2043     for (unsigned i = LinkTimeConstantCount; i--;)
2044         codeBlock.m_linkTimeConstants[i] = m_linkTimeConstants[i];
2045 
2046     m_propertyAccessInstructions.decode(decoder, codeBlock.m_propertyAccessInstructions);
2047     m_constantRegisters.decode(decoder, codeBlock.m_constantRegisters, &amp;codeBlock);
2048     m_constantsSourceCodeRepresentation.decode(decoder, codeBlock.m_constantsSourceCodeRepresentation);
2049     m_expressionInfo.decode(decoder, codeBlock.m_expressionInfo);
2050     m_outOfLineJumpTargets.decode(decoder, codeBlock.m_outOfLineJumpTargets);
2051     m_jumpTargets.decode(decoder, codeBlock.m_jumpTargets);
2052     m_identifiers.decode(decoder, codeBlock.m_identifiers);
2053     m_functionDecls.decode(decoder, codeBlock.m_functionDecls, &amp;codeBlock);
2054     m_functionExprs.decode(decoder, codeBlock.m_functionExprs, &amp;codeBlock);
2055 }
2056 
2057 ALWAYS_INLINE UnlinkedProgramCodeBlock::UnlinkedProgramCodeBlock(Decoder&amp; decoder, const CachedProgramCodeBlock&amp; cachedCodeBlock)
2058     : Base(decoder, decoder.vm().unlinkedProgramCodeBlockStructure.get(), cachedCodeBlock)
2059 {
2060 }
2061 
2062 ALWAYS_INLINE UnlinkedModuleProgramCodeBlock::UnlinkedModuleProgramCodeBlock(Decoder&amp; decoder, const CachedModuleCodeBlock&amp; cachedCodeBlock)
2063     : Base(decoder, decoder.vm().unlinkedModuleProgramCodeBlockStructure.get(), cachedCodeBlock)
2064 {
2065 }
2066 
2067 ALWAYS_INLINE UnlinkedEvalCodeBlock::UnlinkedEvalCodeBlock(Decoder&amp; decoder, const CachedEvalCodeBlock&amp; cachedCodeBlock)
2068     : Base(decoder, decoder.vm().unlinkedEvalCodeBlockStructure.get(), cachedCodeBlock)
2069 {
2070 }
2071 
2072 ALWAYS_INLINE void CachedFunctionExecutable::encode(Encoder&amp; encoder, const UnlinkedFunctionExecutable&amp; executable)
2073 {
<a name="120" id="anc120"></a><span class="line-added">2074     m_mutableMetadata.m_features = executable.m_features;</span>
<span class="line-added">2075     m_mutableMetadata.m_hasCapturedVariables = executable.m_hasCapturedVariables;</span>
<span class="line-added">2076 </span>
2077     m_firstLineOffset = executable.m_firstLineOffset;
2078     m_lineCount = executable.m_lineCount;
2079     m_unlinkedFunctionNameStart = executable.m_unlinkedFunctionNameStart;
2080     m_unlinkedBodyStartColumn = executable.m_unlinkedBodyStartColumn;
2081     m_unlinkedBodyEndColumn = executable.m_unlinkedBodyEndColumn;
2082     m_startOffset = executable.m_startOffset;
2083     m_sourceLength = executable.m_sourceLength;
2084     m_parametersStartOffset = executable.m_parametersStartOffset;
2085     m_typeProfilingStartOffset = executable.m_typeProfilingStartOffset;
2086     m_typeProfilingEndOffset = executable.m_typeProfilingEndOffset;
2087     m_parameterCount = executable.m_parameterCount;
2088 
<a name="121" id="anc121"></a>
2089     m_sourceParseMode = executable.m_sourceParseMode;
2090 
2091     m_isInStrictContext = executable.m_isInStrictContext;
<a name="122" id="anc122"></a>
2092     m_isBuiltinFunction = executable.m_isBuiltinFunction;
2093     m_isBuiltinDefaultClassConstructor = executable.m_isBuiltinDefaultClassConstructor;
2094     m_constructAbility = executable.m_constructAbility;
2095     m_constructorKind = executable.m_constructorKind;
2096     m_functionMode = executable.m_functionMode;
2097     m_scriptMode = executable.m_scriptMode;
2098     m_superBinding = executable.m_superBinding;
2099     m_derivedContextType = executable.m_derivedContextType;
2100 
<a name="123" id="anc123"></a><span class="line-modified">2101     m_rareData.encode(encoder, executable.m_rareData.get());</span>
2102 
2103     m_name.encode(encoder, executable.name());
2104     m_ecmaName.encode(encoder, executable.ecmaName());
<a name="124" id="anc124"></a>


2105 
2106     m_unlinkedCodeBlockForCall.encode(encoder, executable.m_unlinkedCodeBlockForCall);
2107     m_unlinkedCodeBlockForConstruct.encode(encoder, executable.m_unlinkedCodeBlockForConstruct);
<a name="125" id="anc125"></a><span class="line-added">2108 </span>
<span class="line-added">2109     if (!executable.m_unlinkedCodeBlockForCall || !executable.m_unlinkedCodeBlockForConstruct)</span>
<span class="line-added">2110         encoder.addLeafExecutable(&amp;executable, encoder.offsetOf(this));</span>
2111 }
2112 
2113 ALWAYS_INLINE UnlinkedFunctionExecutable* CachedFunctionExecutable::decode(Decoder&amp; decoder) const
2114 {
<a name="126" id="anc126"></a><span class="line-modified">2115     UnlinkedFunctionExecutable* executable = new (NotNull, allocateCell&lt;UnlinkedFunctionExecutable&gt;(decoder.vm().heap)) UnlinkedFunctionExecutable(decoder, *this);</span>



2116     executable-&gt;finishCreation(decoder.vm());
<a name="127" id="anc127"></a>



2117     return executable;
2118 }
2119 
<a name="128" id="anc128"></a><span class="line-modified">2120 ALWAYS_INLINE UnlinkedFunctionExecutable::UnlinkedFunctionExecutable(Decoder&amp; decoder, const CachedFunctionExecutable&amp; cachedExecutable)</span>
2121     : Base(decoder.vm(), decoder.vm().unlinkedFunctionExecutableStructure.get())
2122     , m_firstLineOffset(cachedExecutable.firstLineOffset())
<a name="129" id="anc129"></a><span class="line-added">2123     , m_isInStrictContext(cachedExecutable.isInStrictContext())</span>
2124     , m_lineCount(cachedExecutable.lineCount())
<a name="130" id="anc130"></a><span class="line-added">2125     , m_hasCapturedVariables(cachedExecutable.hasCapturedVariables())</span>
2126     , m_unlinkedFunctionNameStart(cachedExecutable.unlinkedFunctionNameStart())
<a name="131" id="anc131"></a><span class="line-added">2127     , m_isBuiltinFunction(cachedExecutable.isBuiltinFunction())</span>
2128     , m_unlinkedBodyStartColumn(cachedExecutable.unlinkedBodyStartColumn())
<a name="132" id="anc132"></a><span class="line-added">2129     , m_isBuiltinDefaultClassConstructor(cachedExecutable.isBuiltinDefaultClassConstructor())</span>
2130     , m_unlinkedBodyEndColumn(cachedExecutable.unlinkedBodyEndColumn())
<a name="133" id="anc133"></a><span class="line-added">2131     , m_constructAbility(cachedExecutable.constructAbility())</span>
2132     , m_startOffset(cachedExecutable.startOffset())
<a name="134" id="anc134"></a><span class="line-added">2133     , m_scriptMode(cachedExecutable.scriptMode())</span>
2134     , m_sourceLength(cachedExecutable.sourceLength())
<a name="135" id="anc135"></a><span class="line-added">2135     , m_superBinding(cachedExecutable.superBinding())</span>
2136     , m_parametersStartOffset(cachedExecutable.parametersStartOffset())
<a name="136" id="anc136"></a><span class="line-added">2137     , m_isCached(false)</span>
2138     , m_typeProfilingStartOffset(cachedExecutable.typeProfilingStartOffset())
2139     , m_typeProfilingEndOffset(cachedExecutable.typeProfilingEndOffset())
2140     , m_parameterCount(cachedExecutable.parameterCount())
2141     , m_features(cachedExecutable.features())
2142     , m_sourceParseMode(cachedExecutable.sourceParseMode())
<a name="137" id="anc137"></a>




2143     , m_constructorKind(cachedExecutable.constructorKind())
2144     , m_functionMode(cachedExecutable.functionMode())
<a name="138" id="anc138"></a>

2145     , m_derivedContextType(cachedExecutable.derivedContextType())
<a name="139" id="anc139"></a><span class="line-added">2146     , m_isGeneratedFromCache(true)</span>
<span class="line-added">2147     , m_unlinkedCodeBlockForCall()</span>
<span class="line-added">2148     , m_unlinkedCodeBlockForConstruct()</span>
2149 
2150     , m_name(cachedExecutable.name(decoder))
2151     , m_ecmaName(cachedExecutable.ecmaName(decoder))
<a name="140" id="anc140"></a>


2152 
2153     , m_rareData(cachedExecutable.rareData(decoder))
2154 {
<a name="141" id="anc141"></a><span class="line-added">2155 </span>
<span class="line-added">2156     uint32_t leafExecutables = 2;</span>
<span class="line-added">2157     auto checkBounds = [&amp;](int32_t&amp; codeBlockOffset, auto&amp; cachedPtr) {</span>
<span class="line-added">2158         if (!cachedPtr.isEmpty()) {</span>
<span class="line-added">2159             ptrdiff_t offset = decoder.offsetOf(&amp;cachedPtr);</span>
<span class="line-added">2160             if (static_cast&lt;size_t&gt;(offset) &lt; decoder.size()) {</span>
<span class="line-added">2161                 codeBlockOffset = offset;</span>
<span class="line-added">2162                 m_isCached = true;</span>
<span class="line-added">2163                 leafExecutables--;</span>
<span class="line-added">2164                 return;</span>
<span class="line-added">2165             }</span>
<span class="line-added">2166         }</span>
<span class="line-added">2167 </span>
<span class="line-added">2168         codeBlockOffset = 0;</span>
<span class="line-added">2169     };</span>
<span class="line-added">2170 </span>
<span class="line-added">2171     if (!cachedExecutable.unlinkedCodeBlockForCall().isEmpty() || !cachedExecutable.unlinkedCodeBlockForConstruct().isEmpty()) {</span>
<span class="line-added">2172         checkBounds(m_cachedCodeBlockForCallOffset, cachedExecutable.unlinkedCodeBlockForCall());</span>
<span class="line-added">2173         checkBounds(m_cachedCodeBlockForConstructOffset, cachedExecutable.unlinkedCodeBlockForConstruct());</span>
<span class="line-added">2174         if (m_isCached)</span>
<span class="line-added">2175             m_decoder = &amp;decoder;</span>
<span class="line-added">2176         else</span>
<span class="line-added">2177             m_decoder = nullptr;</span>
<span class="line-added">2178     }</span>
<span class="line-added">2179 </span>
<span class="line-added">2180     if (leafExecutables)</span>
<span class="line-added">2181         decoder.addLeafExecutable(this, decoder.offsetOf(&amp;cachedExecutable));</span>
2182 }
2183 
2184 template&lt;typename CodeBlockType&gt;
2185 ALWAYS_INLINE void CachedCodeBlock&lt;CodeBlockType&gt;::encode(Encoder&amp; encoder, const UnlinkedCodeBlock&amp; codeBlock)
2186 {
2187     m_thisRegister = codeBlock.m_thisRegister;
2188     m_scopeRegister = codeBlock.m_scopeRegister;
2189     m_usesEval = codeBlock.m_usesEval;
2190     m_isStrictMode = codeBlock.m_isStrictMode;
2191     m_isConstructor = codeBlock.m_isConstructor;
2192     m_hasCapturedVariables = codeBlock.m_hasCapturedVariables;
2193     m_isBuiltinFunction = codeBlock.m_isBuiltinFunction;
2194     m_superBinding = codeBlock.m_superBinding;
2195     m_scriptMode = codeBlock.m_scriptMode;
2196     m_isArrowFunctionContext = codeBlock.m_isArrowFunctionContext;
2197     m_isClassContext = codeBlock.m_isClassContext;
<a name="142" id="anc142"></a><span class="line-modified">2198     m_hasTailCalls = codeBlock.m_hasTailCalls;</span>
2199     m_constructorKind = codeBlock.m_constructorKind;
2200     m_derivedContextType = codeBlock.m_derivedContextType;
2201     m_evalContextType = codeBlock.m_evalContextType;
<a name="143" id="anc143"></a>
2202     m_lineCount = codeBlock.m_lineCount;
2203     m_endColumn = codeBlock.m_endColumn;
2204     m_numVars = codeBlock.m_numVars;
2205     m_numCalleeLocals = codeBlock.m_numCalleeLocals;
2206     m_numParameters = codeBlock.m_numParameters;
2207     m_features = codeBlock.m_features;
2208     m_parseMode = codeBlock.m_parseMode;
<a name="144" id="anc144"></a><span class="line-added">2209     m_codeGenerationMode = codeBlock.m_codeGenerationMode;</span>
2210     m_codeType = codeBlock.m_codeType;
2211 
2212     for (unsigned i = LinkTimeConstantCount; i--;)
2213         m_linkTimeConstants[i] = codeBlock.m_linkTimeConstants[i];
2214 
2215     m_metadata.encode(encoder, codeBlock.m_metadata.get());
<a name="145" id="anc145"></a><span class="line-modified">2216     m_rareData.encode(encoder, codeBlock.m_rareData.get());</span>
2217 
2218     m_sourceURLDirective.encode(encoder, codeBlock.m_sourceURLDirective.impl());
2219     m_sourceMappingURLDirective.encode(encoder, codeBlock.m_sourceURLDirective.impl());
2220 
2221     m_instructions.encode(encoder, codeBlock.m_instructions.get());
2222     m_propertyAccessInstructions.encode(encoder, codeBlock.m_propertyAccessInstructions);
2223     m_constantRegisters.encode(encoder, codeBlock.m_constantRegisters);
2224     m_constantsSourceCodeRepresentation.encode(encoder, codeBlock.m_constantsSourceCodeRepresentation);
2225     m_expressionInfo.encode(encoder, codeBlock.m_expressionInfo);
2226     m_jumpTargets.encode(encoder, codeBlock.m_jumpTargets);
2227     m_outOfLineJumpTargets.encode(encoder, codeBlock.m_outOfLineJumpTargets);
2228 
2229     m_identifiers.encode(encoder, codeBlock.m_identifiers);
2230     m_functionDecls.encode(encoder, codeBlock.m_functionDecls);
2231     m_functionExprs.encode(encoder, codeBlock.m_functionExprs);
2232 }
2233 
2234 class CachedSourceCodeKey : public CachedObject&lt;SourceCodeKey&gt; {
2235 public:
2236     void encode(Encoder&amp; encoder, const SourceCodeKey&amp; key)
2237     {
2238         m_sourceCode.encode(encoder, key.m_sourceCode);
2239         m_name.encode(encoder, key.m_name);
2240         m_flags = key.m_flags.m_flags;
2241         m_hash = key.hash();
2242         m_functionConstructorParametersEndPosition = key.m_functionConstructorParametersEndPosition;
2243     }
2244 
2245     void decode(Decoder&amp; decoder, SourceCodeKey&amp; key) const
2246     {
2247         m_sourceCode.decode(decoder, key.m_sourceCode);
2248         m_name.decode(decoder, key.m_name);
2249         key.m_flags.m_flags = m_flags;
2250         key.m_hash = m_hash;
2251         key.m_functionConstructorParametersEndPosition = m_functionConstructorParametersEndPosition;
2252     }
2253 
2254 private:
2255     CachedUnlinkedSourceCode m_sourceCode;
2256     CachedString m_name;
2257     unsigned m_flags;
2258     unsigned m_hash;
2259     int m_functionConstructorParametersEndPosition;
2260 };
2261 
2262 class GenericCacheEntry {
2263 public:
2264     bool decode(Decoder&amp;, std::pair&lt;SourceCodeKey, UnlinkedCodeBlock*&gt;&amp;) const;
<a name="146" id="anc146"></a><span class="line-added">2265     bool isStillValid(Decoder&amp;, const SourceCodeKey&amp;, CachedCodeBlockTag) const;</span>
2266 
2267 protected:
2268     GenericCacheEntry(Encoder&amp; encoder, CachedCodeBlockTag tag)
2269         : m_tag(tag)
2270     {
2271         m_bootSessionUUID.encode(encoder, bootSessionUUIDString());
2272     }
2273 
2274     CachedCodeBlockTag tag() const { return m_tag; }
2275 
<a name="147" id="anc147"></a><span class="line-added">2276     bool isUpToDate(Decoder&amp; decoder) const</span>
<span class="line-added">2277     {</span>
<span class="line-added">2278         if (m_cacheVersion != JSC_BYTECODE_CACHE_VERSION)</span>
<span class="line-added">2279             return false;</span>
<span class="line-added">2280         if (m_bootSessionUUID.decode(decoder) != bootSessionUUIDString())</span>
<span class="line-added">2281             return false;</span>
<span class="line-added">2282         return true;</span>
<span class="line-added">2283     }</span>
<span class="line-added">2284 </span>
2285 private:
2286     uint32_t m_cacheVersion { JSC_BYTECODE_CACHE_VERSION };
2287     CachedString m_bootSessionUUID;
2288     CachedCodeBlockTag m_tag;
2289 };
2290 
2291 template&lt;typename UnlinkedCodeBlockType&gt;
2292 class CacheEntry : public GenericCacheEntry {
2293 public:
2294     CacheEntry(Encoder&amp; encoder)
2295         : GenericCacheEntry(encoder, CachedCodeBlockTypeImpl&lt;UnlinkedCodeBlockType&gt;::tag)
2296     {
2297     }
2298 
2299     void encode(Encoder&amp; encoder, std::pair&lt;SourceCodeKey, const UnlinkedCodeBlockType*&gt; pair)
2300     {
2301         m_key.encode(encoder, pair.first);
2302         m_codeBlock.encode(encoder, pair.second);
2303     }
2304 
2305 private:
2306     friend GenericCacheEntry;
2307 
<a name="148" id="anc148"></a><span class="line-added">2308     bool isStillValid(Decoder&amp; decoder, const SourceCodeKey&amp; key) const</span>
<span class="line-added">2309     {</span>
<span class="line-added">2310         SourceCodeKey decodedKey;</span>
<span class="line-added">2311         m_key.decode(decoder, decodedKey);</span>
<span class="line-added">2312         return decodedKey == key;</span>
<span class="line-added">2313     }</span>
<span class="line-added">2314 </span>
2315     bool decode(Decoder&amp; decoder, std::pair&lt;SourceCodeKey, UnlinkedCodeBlockType*&gt;&amp; result) const
2316     {
2317         ASSERT(tag() == CachedCodeBlockTypeImpl&lt;UnlinkedCodeBlockType&gt;::tag);
2318         SourceCodeKey decodedKey;
2319         m_key.decode(decoder, decodedKey);
2320         result = { WTFMove(decodedKey), m_codeBlock.decode(decoder) };
2321         return true;
2322     }
2323 
2324     CachedSourceCodeKey m_key;
2325     CachedPtr&lt;CachedCodeBlockType&lt;UnlinkedCodeBlockType&gt;&gt; m_codeBlock;
2326 };
2327 
2328 bool GenericCacheEntry::decode(Decoder&amp; decoder, std::pair&lt;SourceCodeKey, UnlinkedCodeBlock*&gt;&amp; result) const
2329 {
<a name="149" id="anc149"></a><span class="line-modified">2330     if (!isUpToDate(decoder))</span>


2331         return false;
2332 
2333     switch (m_tag) {
2334     case CachedProgramCodeBlockTag:
<a name="150" id="anc150"></a><span class="line-modified">2335         return bitwise_cast&lt;const CacheEntry&lt;UnlinkedProgramCodeBlock&gt;*&gt;(this)-&gt;decode(decoder, reinterpret_cast&lt;std::pair&lt;SourceCodeKey, UnlinkedProgramCodeBlock*&gt;&amp;&gt;(result));</span>
2336     case CachedModuleCodeBlockTag:
<a name="151" id="anc151"></a><span class="line-modified">2337         return bitwise_cast&lt;const CacheEntry&lt;UnlinkedModuleProgramCodeBlock&gt;*&gt;(this)-&gt;decode(decoder, reinterpret_cast&lt;std::pair&lt;SourceCodeKey, UnlinkedModuleProgramCodeBlock*&gt;&amp;&gt;(result));</span>
2338     case CachedEvalCodeBlockTag:
2339         // We do not cache eval code blocks
2340         RELEASE_ASSERT_NOT_REACHED();
2341     }
2342     RELEASE_ASSERT_NOT_REACHED();
2343 #if COMPILER(MSVC)
2344     // Without this, MSVC will complain that this path does not return a value.
2345     return false;
2346 #endif
2347 }
2348 
<a name="152" id="anc152"></a><span class="line-added">2349 bool GenericCacheEntry::isStillValid(Decoder&amp; decoder, const SourceCodeKey&amp; key, CachedCodeBlockTag tag) const</span>
<span class="line-added">2350 {</span>
<span class="line-added">2351     if (!isUpToDate(decoder))</span>
<span class="line-added">2352         return false;</span>
<span class="line-added">2353 </span>
<span class="line-added">2354     switch (tag) {</span>
<span class="line-added">2355     case CachedProgramCodeBlockTag:</span>
<span class="line-added">2356         return bitwise_cast&lt;const CacheEntry&lt;UnlinkedProgramCodeBlock&gt;*&gt;(this)-&gt;isStillValid(decoder, key);</span>
<span class="line-added">2357     case CachedModuleCodeBlockTag:</span>
<span class="line-added">2358         return bitwise_cast&lt;const CacheEntry&lt;UnlinkedModuleProgramCodeBlock&gt;*&gt;(this)-&gt;isStillValid(decoder, key);</span>
<span class="line-added">2359     case CachedEvalCodeBlockTag:</span>
<span class="line-added">2360         // We do not cache eval code blocks</span>
<span class="line-added">2361         RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added">2362     }</span>
<span class="line-added">2363     RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added">2364     return false;</span>
<span class="line-added">2365 }</span>
<span class="line-added">2366 </span>
2367 template&lt;typename UnlinkedCodeBlockType&gt;
2368 void encodeCodeBlock(Encoder&amp; encoder, const SourceCodeKey&amp; key, const UnlinkedCodeBlock* codeBlock)
2369 {
2370     auto* entry = encoder.template malloc&lt;CacheEntry&lt;UnlinkedCodeBlockType&gt;&gt;(encoder);
<a name="153" id="anc153"></a><span class="line-modified">2371     entry-&gt;encode(encoder, { key, jsCast&lt;const UnlinkedCodeBlockType*&gt;(codeBlock) });</span>
2372 }
2373 
<a name="154" id="anc154"></a><span class="line-modified">2374 RefPtr&lt;CachedBytecode&gt; encodeCodeBlock(VM&amp; vm, const SourceCodeKey&amp; key, const UnlinkedCodeBlock* codeBlock, FileSystem::PlatformFileHandle fd, BytecodeCacheError&amp; error)</span>
2375 {
2376     const ClassInfo* classInfo = codeBlock-&gt;classInfo(vm);
2377 
<a name="155" id="anc155"></a><span class="line-modified">2378     Encoder encoder(vm, fd);</span>
2379     if (classInfo == UnlinkedProgramCodeBlock::info())
2380         encodeCodeBlock&lt;UnlinkedProgramCodeBlock&gt;(encoder, key, codeBlock);
2381     else if (classInfo == UnlinkedModuleProgramCodeBlock::info())
2382         encodeCodeBlock&lt;UnlinkedModuleProgramCodeBlock&gt;(encoder, key, codeBlock);
2383     else
2384         ASSERT(classInfo == UnlinkedEvalCodeBlock::info());
2385 
<a name="156" id="anc156"></a><span class="line-modified">2386     return encoder.release(error);</span>
<span class="line-added">2387 }</span>
<span class="line-added">2388 </span>
<span class="line-added">2389 RefPtr&lt;CachedBytecode&gt; encodeCodeBlock(VM&amp; vm, const SourceCodeKey&amp; key, const UnlinkedCodeBlock* codeBlock)</span>
<span class="line-added">2390 {</span>
<span class="line-added">2391     BytecodeCacheError error;</span>
<span class="line-added">2392     return encodeCodeBlock(vm, key, codeBlock, FileSystem::invalidPlatformFileHandle, error);</span>
<span class="line-added">2393 }</span>
<span class="line-added">2394 </span>
<span class="line-added">2395 RefPtr&lt;CachedBytecode&gt; encodeFunctionCodeBlock(VM&amp; vm, const UnlinkedFunctionCodeBlock* codeBlock, BytecodeCacheError&amp; error)</span>
<span class="line-added">2396 {</span>
<span class="line-added">2397     Encoder encoder(vm);</span>
<span class="line-added">2398     encoder.malloc&lt;CachedFunctionCodeBlock&gt;()-&gt;encode(encoder, *codeBlock);</span>
<span class="line-added">2399     return encoder.release(error);</span>
2400 }
2401 
<a name="157" id="anc157"></a><span class="line-modified">2402 UnlinkedCodeBlock* decodeCodeBlockImpl(VM&amp; vm, const SourceCodeKey&amp; key, Ref&lt;CachedBytecode&gt; cachedBytecode)</span>
2403 {
<a name="158" id="anc158"></a><span class="line-modified">2404     const auto* cachedEntry = bitwise_cast&lt;const GenericCacheEntry*&gt;(cachedBytecode-&gt;data());</span>
<span class="line-modified">2405     Ref&lt;Decoder&gt; decoder = Decoder::create(vm, WTFMove(cachedBytecode), &amp;key.source().provider());</span>
2406     std::pair&lt;SourceCodeKey, UnlinkedCodeBlock*&gt; entry;
2407     {
2408         DeferGC deferGC(vm.heap);
<a name="159" id="anc159"></a><span class="line-modified">2409         if (!cachedEntry-&gt;decode(decoder.get(), entry))</span>
2410             return nullptr;
2411     }
2412 
2413     if (entry.first != key)
2414         return nullptr;
2415     return entry.second;
2416 }
2417 
<a name="160" id="anc160"></a><span class="line-added">2418 bool isCachedBytecodeStillValid(VM&amp; vm, Ref&lt;CachedBytecode&gt; cachedBytecode, const SourceCodeKey&amp; key, SourceCodeType type)</span>
<span class="line-added">2419 {</span>
<span class="line-added">2420     const void* buffer = cachedBytecode-&gt;data();</span>
<span class="line-added">2421     size_t size = cachedBytecode-&gt;size();</span>
<span class="line-added">2422     if (!size)</span>
<span class="line-added">2423         return false;</span>
<span class="line-added">2424     const auto* cachedEntry = bitwise_cast&lt;const GenericCacheEntry*&gt;(buffer);</span>
<span class="line-added">2425     Ref&lt;Decoder&gt; decoder = Decoder::create(vm, WTFMove(cachedBytecode));</span>
<span class="line-added">2426     return cachedEntry-&gt;isStillValid(decoder.get(), key, tagFromSourceCodeType(type));</span>
<span class="line-added">2427 }</span>
<span class="line-added">2428 </span>
<span class="line-added">2429 void decodeFunctionCodeBlock(Decoder&amp; decoder, int32_t cachedFunctionCodeBlockOffset, WriteBarrier&lt;UnlinkedFunctionCodeBlock&gt;&amp; codeBlock, const JSCell* owner)</span>
<span class="line-added">2430 {</span>
<span class="line-added">2431     ASSERT(decoder.vm().heap.isDeferred());</span>
<span class="line-added">2432     auto* cachedCodeBlock = static_cast&lt;const CachedWriteBarrier&lt;CachedFunctionCodeBlock, UnlinkedFunctionCodeBlock&gt;*&gt;(decoder.ptrForOffsetFromBase(cachedFunctionCodeBlockOffset));</span>
<span class="line-added">2433     cachedCodeBlock-&gt;decode(decoder, codeBlock, owner);</span>
<span class="line-added">2434 }</span>
<span class="line-added">2435 </span>
2436 } // namespace JSC
<a name="161" id="anc161"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="161" type="hidden" />
</body>
</html>