<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/MediaPlayer.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2007-2018 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;MediaPlayer.h&quot;
  28 
  29 #if ENABLE(VIDEO)
  30 
  31 #include &quot;ContentType.h&quot;
  32 #include &quot;DeprecatedGlobalSettings.h&quot;
  33 #include &quot;Document.h&quot;
  34 #include &quot;IntRect.h&quot;
  35 #include &quot;Logging.h&quot;
  36 #include &quot;MIMETypeRegistry.h&quot;
  37 #include &quot;MediaPlayerPrivate.h&quot;
  38 #include &quot;PlatformTimeRanges.h&quot;
  39 #include &lt;wtf/NeverDestroyed.h&gt;
  40 #include &lt;wtf/text/CString.h&gt;
  41 
  42 #if ENABLE(VIDEO_TRACK)
  43 #include &quot;InbandTextTrackPrivate.h&quot;
  44 #endif
  45 
  46 #if ENABLE(MEDIA_SOURCE)
  47 #include &quot;MediaSourcePrivateClient.h&quot;
  48 #endif
  49 
  50 #if ENABLE(MEDIA_STREAM)
  51 #include &quot;MediaStreamPrivate.h&quot;
  52 #endif
  53 
  54 #if USE(GSTREAMER)
  55 #include &quot;MediaPlayerPrivateGStreamer.h&quot;
  56 #define PlatformMediaEngineClassName MediaPlayerPrivateGStreamer
  57 #if ENABLE(MEDIA_SOURCE) &amp;&amp; ENABLE(VIDEO_TRACK)
  58 #include &quot;MediaPlayerPrivateGStreamerMSE.h&quot;
  59 #endif
  60 #endif // USE(GSTREAMER)
  61 
  62 #if USE(MEDIA_FOUNDATION)
  63 #include &quot;MediaPlayerPrivateMediaFoundation.h&quot;
  64 #define PlatformMediaEngineClassName MediaPlayerPrivateMediaFoundation
  65 #endif
  66 
  67 #if PLATFORM(COCOA)
  68 
  69 #if USE(AVFOUNDATION)
  70 #include &quot;MediaPlayerPrivateAVFoundationObjC.h&quot;
  71 #endif
  72 
  73 #if ENABLE(MEDIA_SOURCE) &amp;&amp; USE(AVFOUNDATION)
  74 #include &quot;MediaPlayerPrivateMediaSourceAVFObjC.h&quot;
  75 #endif
  76 
  77 #if ENABLE(MEDIA_STREAM) &amp;&amp; USE(AVFOUNDATION)
  78 #include &quot;MediaPlayerPrivateMediaStreamAVFObjC.h&quot;
  79 #endif
  80 
  81 #endif // PLATFORM(COCOA)
  82 
  83 #if PLATFORM(WIN) &amp;&amp; USE(AVFOUNDATION) &amp;&amp; !USE(GSTREAMER)
  84 #include &quot;MediaPlayerPrivateAVFoundationCF.h&quot;
  85 #endif // USE(AVFOUNDATION)
  86 
  87 #if PLATFORM(JAVA)
  88 #include &quot;MediaPlayerPrivateJava.h&quot;
  89 #define PlatformMediaEngineClassName MediaPlayerPrivate
  90 #endif  // PLATFORM(JAVA)
  91 
  92 #if USE(EXTERNAL_HOLEPUNCH)
  93 #include &quot;MediaPlayerPrivateHolePunch.h&quot;
  94 #endif
  95 
  96 namespace WebCore {
  97 
  98 #if !RELEASE_LOG_DISABLED
  99 static RefPtr&lt;Logger&gt;&amp; nullLogger()
 100 {
 101     static NeverDestroyed&lt;RefPtr&lt;Logger&gt;&gt; logger;
 102     return logger;
 103 }
 104 #endif
 105 
 106 // a null player to make MediaPlayer logic simpler
 107 
 108 class NullMediaPlayerPrivate final : public MediaPlayerPrivateInterface {
 109 public:
 110     explicit NullMediaPlayerPrivate(MediaPlayer*) { }
 111 
 112     void load(const String&amp;) final { }
 113 #if ENABLE(MEDIA_SOURCE)
 114     void load(const String&amp;, MediaSourcePrivateClient*) final { }
 115 #endif
 116 #if ENABLE(MEDIA_STREAM)
 117     void load(MediaStreamPrivate&amp;) final { }
 118 #endif
 119     void cancelLoad() final { }
 120 
 121     void prepareToPlay() final { }
 122     void play() final { }
 123     void pause() final { }
 124 
 125     PlatformLayer* platformLayer() const final { return 0; }
 126 
 127     FloatSize naturalSize() const final { return FloatSize(); }
 128 
 129     bool hasVideo() const final { return false; }
 130     bool hasAudio() const final { return false; }
 131 
 132     void setVisible(bool) final { }
 133 
 134     double durationDouble() const final { return 0; }
 135 
 136     double currentTimeDouble() const final { return 0; }
 137     void seekDouble(double) final { }
 138     bool seeking() const final { return false; }
 139 
 140     void setRateDouble(double) final { }
 141     void setPreservesPitch(bool) final { }
 142     bool paused() const final { return true; }
 143 
 144     void setVolumeDouble(double) final { }
 145 
 146     void setMuted(bool) final { }
 147 
 148     bool hasClosedCaptions() const final { return false; }
 149     void setClosedCaptionsVisible(bool) final { };
 150 
 151     MediaPlayer::NetworkState networkState() const final { return MediaPlayer::Empty; }
 152     MediaPlayer::ReadyState readyState() const final { return MediaPlayer::HaveNothing; }
 153 
 154     float maxTimeSeekable() const final { return 0; }
 155     double minTimeSeekable() const final { return 0; }
 156     std::unique_ptr&lt;PlatformTimeRanges&gt; buffered() const final { return makeUnique&lt;PlatformTimeRanges&gt;(); }
 157 
 158     double seekableTimeRangesLastModifiedTime() const final { return 0; }
 159     double liveUpdateInterval() const final { return 0; }
 160 
 161     unsigned long long totalBytes() const final { return 0; }
 162     bool didLoadingProgress() const final { return false; }
 163 
 164     void setSize(const IntSize&amp;) final { }
 165 
 166     void paint(GraphicsContext&amp;, const FloatRect&amp;) final { }
 167 
 168     bool canLoadPoster() const final { return false; }
 169     void setPoster(const String&amp;) final { }
 170 
 171     bool hasSingleSecurityOrigin() const final { return true; }
 172 };
 173 
 174 class NullMediaPlayerClient : public MediaPlayerClient {
 175 public:
 176 #if !RELEASE_LOG_DISABLED
 177     const Logger&amp; mediaPlayerLogger() final
 178     {
 179         if (!nullLogger().get()) {
 180             nullLogger() = Logger::create(this);
 181             nullLogger()-&gt;setEnabled(this, false);
 182         }
 183 
 184         return *nullLogger().get();
 185     }
 186 #endif
 187 };
 188 
 189 const Vector&lt;ContentType&gt;&amp; MediaPlayerClient::mediaContentTypesRequiringHardwareSupport() const
 190 {
 191     static NeverDestroyed&lt;Vector&lt;ContentType&gt;&gt; contentTypes;
 192     return contentTypes;
 193 }
 194 
 195 static MediaPlayerClient&amp; nullMediaPlayerClient()
 196 {
 197     static NeverDestroyed&lt;NullMediaPlayerClient&gt; client;
 198     return client.get();
 199 }
 200 
 201 // engine support
 202 
 203 struct MediaPlayerFactory {
 204     CreateMediaEnginePlayer constructor;
 205     MediaEngineSupportedTypes getSupportedTypes;
 206     MediaEngineSupportsType supportsTypeAndCodecs;
 207     MediaEngineOriginsInMediaCache originsInMediaCache;
 208     MediaEngineClearMediaCache clearMediaCache;
 209     MediaEngineClearMediaCacheForOrigins clearMediaCacheForOrigins;
 210     MediaEngineSupportsKeySystem supportsKeySystem;
 211 };
 212 
 213 static void addMediaEngine(CreateMediaEnginePlayer&amp;&amp;, MediaEngineSupportedTypes, MediaEngineSupportsType, MediaEngineOriginsInMediaCache, MediaEngineClearMediaCache, MediaEngineClearMediaCacheForOrigins, MediaEngineSupportsKeySystem);
 214 
 215 static Lock mediaEngineVectorLock;
 216 
 217 static bool&amp; haveMediaEnginesVector()
 218 {
 219     static bool haveVector;
 220     return haveVector;
 221 }
 222 
 223 static Vector&lt;MediaPlayerFactory&gt;&amp; mutableInstalledMediaEnginesVector()
 224 {
 225     static NeverDestroyed&lt;Vector&lt;MediaPlayerFactory&gt;&gt; installedEngines;
 226     return installedEngines;
 227 }
 228 
 229 static void buildMediaEnginesVector()
 230 {
 231     ASSERT(mediaEngineVectorLock.isLocked());
 232 
 233 #if USE(AVFOUNDATION)
 234     if (DeprecatedGlobalSettings::isAVFoundationEnabled()) {
 235 
 236 #if PLATFORM(COCOA)
 237         MediaPlayerPrivateAVFoundationObjC::registerMediaEngine(addMediaEngine);
 238 #endif
 239 
 240 #if ENABLE(MEDIA_SOURCE)
 241         MediaPlayerPrivateMediaSourceAVFObjC::registerMediaEngine(addMediaEngine);
 242 #endif
 243 
 244 #if ENABLE(MEDIA_STREAM)
 245         MediaPlayerPrivateMediaStreamAVFObjC::registerMediaEngine(addMediaEngine);
 246 #endif
 247 
 248 #if PLATFORM(WIN)
 249         MediaPlayerPrivateAVFoundationCF::registerMediaEngine(addMediaEngine);
 250 #endif
 251     }
 252 #endif // USE(AVFOUNDATION)
 253 
 254 #if defined(PlatformMediaEngineClassName)
 255 #if USE(GSTREAMER)
 256     if (DeprecatedGlobalSettings::isGStreamerEnabled())
 257 #endif
 258         PlatformMediaEngineClassName::registerMediaEngine(addMediaEngine);
 259 #endif
 260 
 261 #if USE(GSTREAMER) &amp;&amp; ENABLE(MEDIA_SOURCE) &amp;&amp; ENABLE(VIDEO_TRACK)
 262     if (DeprecatedGlobalSettings::isGStreamerEnabled())
 263         MediaPlayerPrivateGStreamerMSE::registerMediaEngine(addMediaEngine);
 264 #endif
 265 
 266 #if USE(EXTERNAL_HOLEPUNCH)
 267     MediaPlayerPrivateHolePunch::registerMediaEngine(addMediaEngine);
 268 #endif
 269 
 270     haveMediaEnginesVector() = true;
 271 }
 272 
 273 static const Vector&lt;MediaPlayerFactory&gt;&amp; installedMediaEngines()
 274 {
 275     {
 276         auto locker = holdLock(mediaEngineVectorLock);
 277         if (!haveMediaEnginesVector())
 278             buildMediaEnginesVector();
 279     }
 280 
 281     return mutableInstalledMediaEnginesVector();
 282 }
 283 
 284 static void addMediaEngine(CreateMediaEnginePlayer&amp;&amp; constructor, MediaEngineSupportedTypes getSupportedTypes, MediaEngineSupportsType supportsType,
 285     MediaEngineOriginsInMediaCache originsInMediaCache, MediaEngineClearMediaCache clearMediaCache, MediaEngineClearMediaCacheForOrigins clearMediaCacheForOrigins, MediaEngineSupportsKeySystem supportsKeySystem)
 286 {
 287     ASSERT(constructor);
 288     ASSERT(getSupportedTypes);
 289     ASSERT(supportsType);
 290 
 291     mutableInstalledMediaEnginesVector().append(MediaPlayerFactory { WTFMove(constructor), getSupportedTypes, supportsType, originsInMediaCache, clearMediaCache, clearMediaCacheForOrigins, supportsKeySystem });
 292 }
 293 
 294 static const AtomString&amp; applicationOctetStream()
 295 {
 296     static NeverDestroyed&lt;const AtomString&gt; applicationOctetStream(&quot;application/octet-stream&quot;, AtomString::ConstructFromLiteral);
 297     return applicationOctetStream;
 298 }
 299 
 300 static const AtomString&amp; textPlain()
 301 {
 302     static NeverDestroyed&lt;const AtomString&gt; textPlain(&quot;text/plain&quot;, AtomString::ConstructFromLiteral);
 303     return textPlain;
 304 }
 305 
 306 static const MediaPlayerFactory* bestMediaEngineForSupportParameters(const MediaEngineSupportParameters&amp; parameters, const MediaPlayerFactory* current = nullptr)
 307 {
 308     if (parameters.type.isEmpty() &amp;&amp; !parameters.isMediaSource &amp;&amp; !parameters.isMediaStream)
 309         return nullptr;
 310 
 311     // 4.8.10.3 MIME types - In the absence of a specification to the contrary, the MIME type &quot;application/octet-stream&quot;
 312     // when used with parameters, e.g. &quot;application/octet-stream;codecs=theora&quot;, is a type that the user agent knows
 313     // it cannot render.
 314     if (parameters.type.containerType() == applicationOctetStream()) {
 315         if (!parameters.type.codecs().isEmpty())
 316             return nullptr;
 317     }
 318 
 319     const MediaPlayerFactory* foundEngine = nullptr;
 320     MediaPlayer::SupportsType supported = MediaPlayer::IsNotSupported;
 321     for (auto&amp; engine : installedMediaEngines()) {
 322         if (current) {
 323             if (current == &amp;engine)
 324                 current = nullptr;
 325             continue;
 326         }
 327         MediaPlayer::SupportsType engineSupport = engine.supportsTypeAndCodecs(parameters);
 328         if (engineSupport &gt; supported) {
 329             supported = engineSupport;
 330             foundEngine = &amp;engine;
 331         }
 332     }
 333 
 334     return foundEngine;
 335 }
 336 
 337 static const MediaPlayerFactory* nextMediaEngine(const MediaPlayerFactory* current)
 338 {
 339     auto&amp; engines = installedMediaEngines();
 340     if (engines.isEmpty())
 341         return nullptr;
 342 
 343     if (!current)
 344         return &amp;engines.first();
 345 
 346     size_t currentIndex = current - &amp;engines.first();
 347     if (currentIndex + 1 &gt;= engines.size())
 348         return nullptr;
 349 
 350     return &amp;engines[currentIndex + 1];
 351 }
 352 
 353 // media player
 354 
 355 Ref&lt;MediaPlayer&gt; MediaPlayer::create(MediaPlayerClient&amp; client)
 356 {
 357     return adoptRef(*new MediaPlayer(client));
 358 }
 359 
 360 MediaPlayer::MediaPlayer(MediaPlayerClient&amp; client)
 361     : m_client(&amp;client)
 362     , m_reloadTimer(*this, &amp;MediaPlayer::reloadTimerFired)
 363     , m_private(makeUnique&lt;NullMediaPlayerPrivate&gt;(this))
 364 {
 365 }
 366 
 367 MediaPlayer::~MediaPlayer()
 368 {
 369     ASSERT(!m_initializingMediaEngine);
 370 }
 371 
 372 void MediaPlayer::invalidate()
 373 {
 374     m_client = &amp;nullMediaPlayerClient();
 375 }
 376 
 377 bool MediaPlayer::load(const URL&amp; url, const ContentType&amp; contentType, const String&amp; keySystem)
 378 {
 379     ASSERT(!m_reloadTimer.isActive());
 380 
 381     // Protect against MediaPlayer being destroyed during a MediaPlayerClient callback.
 382     Ref&lt;MediaPlayer&gt; protectedThis(*this);
 383 
 384     m_contentType = contentType;
 385     m_url = url;
 386     m_keySystem = keySystem.convertToASCIILowercase();
 387     m_contentMIMETypeWasInferredFromExtension = false;
 388 
 389 #if ENABLE(MEDIA_SOURCE)
 390     m_mediaSource = nullptr;
 391 #endif
 392 #if ENABLE(MEDIA_STREAM)
 393     m_mediaStream = nullptr;
 394 #endif
 395 
 396     // If the MIME type is missing or is not meaningful, try to figure it out from the URL.
 397     AtomString containerType = m_contentType.containerType();
 398     if (containerType.isEmpty() || containerType == applicationOctetStream() || containerType == textPlain()) {
 399         if (m_url.protocolIsData())
 400             m_contentType = ContentType(mimeTypeFromDataURL(m_url.string()));
 401         else {
 402             String lastPathComponent = url.lastPathComponent();
 403             size_t pos = lastPathComponent.reverseFind(&#39;.&#39;);
 404             if (pos != notFound) {
 405                 String extension = lastPathComponent.substring(pos + 1);
 406                 String mediaType = MIMETypeRegistry::getMediaMIMETypeForExtension(extension);
 407                 if (!mediaType.isEmpty()) {
 408                     m_contentType = ContentType { WTFMove(mediaType) };
 409                     m_contentMIMETypeWasInferredFromExtension = true;
 410                 }
 411             }
 412         }
 413     }
 414 
 415     loadWithNextMediaEngine(nullptr);
 416     return m_currentMediaEngine;
 417 }
 418 
 419 #if ENABLE(MEDIA_SOURCE)
 420 bool MediaPlayer::load(const URL&amp; url, const ContentType&amp; contentType, MediaSourcePrivateClient* mediaSource)
 421 {
 422     ASSERT(!m_reloadTimer.isActive());
 423     ASSERT(mediaSource);
 424 
 425     m_mediaSource = mediaSource;
 426     m_contentType = contentType;
 427     m_url = url;
 428     m_keySystem = emptyString();
 429     m_contentMIMETypeWasInferredFromExtension = false;
 430     loadWithNextMediaEngine(nullptr);
 431     return m_currentMediaEngine;
 432 }
 433 #endif
 434 
 435 #if ENABLE(MEDIA_STREAM)
 436 bool MediaPlayer::load(MediaStreamPrivate&amp; mediaStream)
 437 {
 438     ASSERT(!m_reloadTimer.isActive());
 439 
 440     m_mediaStream = &amp;mediaStream;
 441     m_keySystem = emptyString();
 442     m_contentType = { };
 443     m_contentMIMETypeWasInferredFromExtension = false;
 444     loadWithNextMediaEngine(nullptr);
 445     return m_currentMediaEngine;
 446 }
 447 #endif
 448 
 449 const MediaPlayerFactory* MediaPlayer::nextBestMediaEngine(const MediaPlayerFactory* current) const
 450 {
 451     MediaEngineSupportParameters parameters;
 452     parameters.type = m_contentType;
 453     parameters.url = m_url;
 454 #if ENABLE(MEDIA_SOURCE)
 455     parameters.isMediaSource = !!m_mediaSource;
 456 #endif
 457 #if ENABLE(MEDIA_STREAM)
 458     parameters.isMediaStream = !!m_mediaStream;
 459 #endif
 460 
 461     return bestMediaEngineForSupportParameters(parameters, current);
 462 }
 463 
 464 void MediaPlayer::loadWithNextMediaEngine(const MediaPlayerFactory* current)
 465 {
 466 #if ENABLE(MEDIA_SOURCE)
 467 #define MEDIASOURCE m_mediaSource
 468 #else
 469 #define MEDIASOURCE 0
 470 #endif
 471 
 472 #if ENABLE(MEDIA_STREAM)
 473 #define MEDIASTREAM m_mediaStream
 474 #else
 475 #define MEDIASTREAM 0
 476 #endif
 477 
 478     ASSERT(!m_initializingMediaEngine);
 479     m_initializingMediaEngine = true;
 480 
 481     const MediaPlayerFactory* engine = nullptr;
 482 
 483     if (!m_contentType.isEmpty() || MEDIASTREAM || MEDIASOURCE)
 484         engine = nextBestMediaEngine(current);
 485 
 486     // If no MIME type is specified or the type was inferred from the file extension, just use the next engine.
 487     if (!engine &amp;&amp; (m_contentType.isEmpty() || m_contentMIMETypeWasInferredFromExtension))
 488         engine = nextMediaEngine(current);
 489 
 490     // Don&#39;t delete and recreate the player unless it comes from a different engine.
 491     if (!engine) {
 492         LOG(Media, &quot;MediaPlayer::loadWithNextMediaEngine - no media engine found for type \&quot;%s\&quot;&quot;, m_contentType.raw().utf8().data());
 493         m_currentMediaEngine = engine;
 494         m_private = nullptr;
 495     } else if (m_currentMediaEngine != engine) {
 496         m_currentMediaEngine = engine;
 497         m_private = engine-&gt;constructor(this);
 498         client().mediaPlayerEngineUpdated(this);
 499         m_private-&gt;setPrivateBrowsingMode(m_privateBrowsing);
 500         m_private-&gt;setPreload(m_preload);
 501         m_private-&gt;setPreservesPitch(preservesPitch());
 502         if (m_shouldPrepareToRender)
 503             m_private-&gt;prepareForRendering();
 504     }
 505 
 506     if (m_private) {
 507 #if ENABLE(MEDIA_SOURCE)
 508         if (m_mediaSource)
 509             m_private-&gt;load(m_url.string(), m_mediaSource.get());
 510         else
 511 #endif
 512 #if ENABLE(MEDIA_STREAM)
 513         if (m_mediaStream)
 514             m_private-&gt;load(*m_mediaStream);
 515         else
 516 #endif
 517         m_private-&gt;load(m_url.string());
 518     } else {
 519         m_private = makeUnique&lt;NullMediaPlayerPrivate&gt;(this);
 520         client().mediaPlayerEngineUpdated(this);
 521         client().mediaPlayerResourceNotSupported(this);
 522     }
 523 
 524     m_initializingMediaEngine = false;
 525 }
 526 
 527 bool MediaPlayer::hasAvailableVideoFrame() const
 528 {
 529     return m_private-&gt;hasAvailableVideoFrame();
 530 }
 531 
 532 void MediaPlayer::prepareForRendering()
 533 {
 534     m_shouldPrepareToRender = true;
 535     m_private-&gt;prepareForRendering();
 536 }
 537 
 538 bool MediaPlayer::canLoadPoster() const
 539 {
 540     return m_private-&gt;canLoadPoster();
 541 }
 542 
 543 void MediaPlayer::setPoster(const String&amp; url)
 544 {
 545     m_private-&gt;setPoster(url);
 546 }
 547 
 548 void MediaPlayer::cancelLoad()
 549 {
 550     m_private-&gt;cancelLoad();
 551 }
 552 
 553 void MediaPlayer::prepareToPlay()
 554 {
 555     Ref&lt;MediaPlayer&gt; protectedThis(*this);
 556 
 557     m_private-&gt;prepareToPlay();
 558 }
 559 
 560 void MediaPlayer::play()
 561 {
 562     m_private-&gt;play();
 563 }
 564 
 565 void MediaPlayer::pause()
 566 {
 567     m_private-&gt;pause();
 568 }
 569 
 570 void MediaPlayer::setBufferingPolicy(BufferingPolicy policy)
 571 {
 572     m_private-&gt;setBufferingPolicy(policy);
 573 }
 574 
 575 #if ENABLE(LEGACY_ENCRYPTED_MEDIA)
 576 
 577 std::unique_ptr&lt;LegacyCDMSession&gt; MediaPlayer::createSession(const String&amp; keySystem, LegacyCDMSessionClient* client)
 578 {
 579     return m_private-&gt;createSession(keySystem, client);
 580 }
 581 
 582 void MediaPlayer::setCDMSession(LegacyCDMSession* session)
 583 {
 584     m_private-&gt;setCDMSession(session);
 585 }
 586 
 587 void MediaPlayer::keyAdded()
 588 {
 589     m_private-&gt;keyAdded();
 590 }
 591 
 592 #endif
 593 
 594 #if ENABLE(ENCRYPTED_MEDIA)
 595 
 596 void MediaPlayer::cdmInstanceAttached(CDMInstance&amp; instance)
 597 {
 598     m_private-&gt;cdmInstanceAttached(instance);
 599 }
 600 
 601 void MediaPlayer::cdmInstanceDetached(CDMInstance&amp; instance)
 602 {
 603     m_private-&gt;cdmInstanceDetached(instance);
 604 }
 605 
 606 void MediaPlayer::attemptToDecryptWithInstance(CDMInstance&amp; instance)
 607 {
 608     m_private-&gt;attemptToDecryptWithInstance(instance);
 609 }
 610 
 611 #endif
 612 
 613 MediaTime MediaPlayer::duration() const
 614 {
 615     return m_private-&gt;durationMediaTime();
 616 }
 617 
 618 MediaTime MediaPlayer::startTime() const
 619 {
 620     return m_private-&gt;startTime();
 621 }
 622 
 623 MediaTime MediaPlayer::initialTime() const
 624 {
 625     return m_private-&gt;initialTime();
 626 }
 627 
 628 MediaTime MediaPlayer::currentTime() const
 629 {
 630     return m_private-&gt;currentMediaTime();
 631 }
 632 
 633 MediaTime MediaPlayer::getStartDate() const
 634 {
 635     return m_private-&gt;getStartDate();
 636 }
 637 
 638 void MediaPlayer::seekWithTolerance(const MediaTime&amp; time, const MediaTime&amp; negativeTolerance, const MediaTime&amp; positiveTolerance)
 639 {
 640     m_private-&gt;seekWithTolerance(time, negativeTolerance, positiveTolerance);
 641 }
 642 
 643 void MediaPlayer::seek(const MediaTime&amp; time)
 644 {
 645     m_private-&gt;seek(time);
 646 }
 647 
 648 bool MediaPlayer::paused() const
 649 {
 650     return m_private-&gt;paused();
 651 }
 652 
 653 bool MediaPlayer::seeking() const
 654 {
 655     return m_private-&gt;seeking();
 656 }
 657 
 658 bool MediaPlayer::supportsFullscreen() const
 659 {
 660     return m_private-&gt;supportsFullscreen();
 661 }
 662 
 663 bool MediaPlayer::canSaveMediaData() const
 664 {
 665     return m_private-&gt;canSaveMediaData();
 666 }
 667 
 668 bool MediaPlayer::supportsScanning() const
 669 {
 670     return m_private-&gt;supportsScanning();
 671 }
 672 
 673 bool MediaPlayer::requiresImmediateCompositing() const
 674 {
 675     return m_private-&gt;requiresImmediateCompositing();
 676 }
 677 
 678 FloatSize MediaPlayer::naturalSize()
 679 {
 680     return m_private-&gt;naturalSize();
 681 }
 682 
 683 bool MediaPlayer::hasVideo() const
 684 {
 685     return m_private-&gt;hasVideo();
 686 }
 687 
 688 bool MediaPlayer::hasAudio() const
 689 {
 690     return m_private-&gt;hasAudio();
 691 }
 692 
 693 bool MediaPlayer::inMediaDocument() const
 694 {
 695     return m_visible &amp;&amp; client().mediaPlayerIsInMediaDocument();
 696 }
 697 
 698 PlatformLayer* MediaPlayer::platformLayer() const
 699 {
 700     return m_private-&gt;platformLayer();
 701 }
 702 
 703 #if PLATFORM(IOS_FAMILY) || (PLATFORM(MAC) &amp;&amp; ENABLE(VIDEO_PRESENTATION_MODE))
 704 
 705 void MediaPlayer::setVideoFullscreenLayer(PlatformLayer* layer, WTF::Function&lt;void()&gt;&amp;&amp; completionHandler)
 706 {
 707     m_private-&gt;setVideoFullscreenLayer(layer, WTFMove(completionHandler));
 708 }
 709 
 710 void MediaPlayer::updateVideoFullscreenInlineImage()
 711 {
 712     m_private-&gt;updateVideoFullscreenInlineImage();
 713 }
 714 
 715 void MediaPlayer::setVideoFullscreenFrame(FloatRect frame)
 716 {
 717     m_private-&gt;setVideoFullscreenFrame(frame);
 718 }
 719 
 720 void MediaPlayer::setVideoFullscreenGravity(MediaPlayer::VideoGravity gravity)
 721 {
 722     m_private-&gt;setVideoFullscreenGravity(gravity);
 723 }
 724 
 725 void MediaPlayer::setVideoFullscreenMode(MediaPlayer::VideoFullscreenMode mode)
 726 {
 727     m_private-&gt;setVideoFullscreenMode(mode);
 728 }
 729 
 730 MediaPlayer::VideoFullscreenMode MediaPlayer::fullscreenMode() const
 731 {
 732     return client().mediaPlayerFullscreenMode();
 733 }
 734 
 735 void MediaPlayer::videoFullscreenStandbyChanged()
 736 {
 737     m_private-&gt;videoFullscreenStandbyChanged();
 738 }
 739 
 740 bool MediaPlayer::isVideoFullscreenStandby() const
 741 {
 742     return client().mediaPlayerIsVideoFullscreenStandby();
 743 }
 744 
 745 #endif
 746 
 747 #if PLATFORM(IOS_FAMILY)
 748 
 749 NSArray* MediaPlayer::timedMetadata() const
 750 {
 751     return m_private-&gt;timedMetadata();
 752 }
 753 
 754 String MediaPlayer::accessLog() const
 755 {
 756     return m_private-&gt;accessLog();
 757 }
 758 
 759 String MediaPlayer::errorLog() const
 760 {
 761     return m_private-&gt;errorLog();
 762 }
 763 
 764 #endif
 765 
 766 MediaPlayer::NetworkState MediaPlayer::networkState()
 767 {
 768     return m_private-&gt;networkState();
 769 }
 770 
 771 MediaPlayer::ReadyState MediaPlayer::readyState()
 772 {
 773     return m_private-&gt;readyState();
 774 }
 775 
 776 double MediaPlayer::volume() const
 777 {
 778     return m_volume;
 779 }
 780 
 781 void MediaPlayer::setVolume(double volume)
 782 {
 783     m_volume = volume;
 784     m_private-&gt;setVolumeDouble(volume);
 785 }
 786 
 787 bool MediaPlayer::muted() const
 788 {
 789     return m_muted;
 790 }
 791 
 792 void MediaPlayer::setMuted(bool muted)
 793 {
 794     m_muted = muted;
 795 
 796     m_private-&gt;setMuted(muted);
 797 }
 798 
 799 bool MediaPlayer::hasClosedCaptions() const
 800 {
 801     return m_private-&gt;hasClosedCaptions();
 802 }
 803 
 804 void MediaPlayer::setClosedCaptionsVisible(bool closedCaptionsVisible)
 805 {
 806     m_private-&gt;setClosedCaptionsVisible(closedCaptionsVisible);
 807 }
 808 
 809 double MediaPlayer::rate() const
 810 {
 811     return m_private-&gt;rate();
 812 }
 813 
 814 void MediaPlayer::setRate(double rate)
 815 {
 816     m_private-&gt;setRateDouble(rate);
 817 }
 818 
 819 double MediaPlayer::requestedRate() const
 820 {
 821     return client().mediaPlayerRequestedPlaybackRate();
 822 }
 823 
 824 bool MediaPlayer::preservesPitch() const
 825 {
 826     return m_preservesPitch;
 827 }
 828 
 829 void MediaPlayer::setPreservesPitch(bool preservesPitch)
 830 {
 831     m_preservesPitch = preservesPitch;
 832     m_private-&gt;setPreservesPitch(preservesPitch);
 833 }
 834 
 835 std::unique_ptr&lt;PlatformTimeRanges&gt; MediaPlayer::buffered()
 836 {
 837     return m_private-&gt;buffered();
 838 }
 839 
 840 std::unique_ptr&lt;PlatformTimeRanges&gt; MediaPlayer::seekable()
 841 {
 842     return m_private-&gt;seekable();
 843 }
 844 
 845 MediaTime MediaPlayer::maxTimeSeekable()
 846 {
 847     return m_private-&gt;maxMediaTimeSeekable();
 848 }
 849 
 850 MediaTime MediaPlayer::minTimeSeekable()
 851 {
 852     return m_private-&gt;minMediaTimeSeekable();
 853 }
 854 
 855 double MediaPlayer::seekableTimeRangesLastModifiedTime()
 856 {
 857     return m_private-&gt;seekableTimeRangesLastModifiedTime();
 858 }
 859 
 860 double MediaPlayer::liveUpdateInterval()
 861 {
 862     return m_private-&gt;liveUpdateInterval();
 863 }
 864 
 865 bool MediaPlayer::didLoadingProgress()
 866 {
 867     return m_private-&gt;didLoadingProgress();
 868 }
 869 
 870 void MediaPlayer::setSize(const IntSize&amp; size)
 871 {
 872     m_size = size;
 873     m_private-&gt;setSize(size);
 874 }
 875 
 876 bool MediaPlayer::visible() const
 877 {
 878     return m_visible;
 879 }
 880 
 881 void MediaPlayer::setVisible(bool b)
 882 {
 883     m_visible = b;
 884     m_private-&gt;setVisible(b);
 885 }
 886 
 887 MediaPlayer::Preload MediaPlayer::preload() const
 888 {
 889     return m_preload;
 890 }
 891 
 892 void MediaPlayer::setPreload(MediaPlayer::Preload preload)
 893 {
 894     m_preload = preload;
 895     m_private-&gt;setPreload(preload);
 896 }
 897 
 898 void MediaPlayer::paint(GraphicsContext&amp; p, const FloatRect&amp; r)
 899 {
 900     m_private-&gt;paint(p, r);
 901 }
 902 
 903 void MediaPlayer::paintCurrentFrameInContext(GraphicsContext&amp; p, const FloatRect&amp; r)
 904 {
 905     m_private-&gt;paintCurrentFrameInContext(p, r);
 906 }
 907 
 908 bool MediaPlayer::copyVideoTextureToPlatformTexture(GraphicsContext3D* context, Platform3DObject texture, GC3Denum target, GC3Dint level, GC3Denum internalFormat, GC3Denum format, GC3Denum type, bool premultiplyAlpha, bool flipY)
 909 {
 910     return m_private-&gt;copyVideoTextureToPlatformTexture(context, texture, target, level, internalFormat, format, type, premultiplyAlpha, flipY);
 911 }
 912 
 913 NativeImagePtr MediaPlayer::nativeImageForCurrentTime()
 914 {
 915     return m_private-&gt;nativeImageForCurrentTime();
 916 }
 917 
 918 MediaPlayer::SupportsType MediaPlayer::supportsType(const MediaEngineSupportParameters&amp; parameters)
 919 {
 920     // 4.8.10.3 MIME types - The canPlayType(type) method must return the empty string if type is a type that the
 921     // user agent knows it cannot render or is the type &quot;application/octet-stream&quot;
 922     AtomString containerType = parameters.type.containerType();
 923     if (containerType == applicationOctetStream())
 924         return IsNotSupported;
 925 
 926     const MediaPlayerFactory* engine = bestMediaEngineForSupportParameters(parameters);
 927     if (!engine)
 928         return IsNotSupported;
 929 
 930     return engine-&gt;supportsTypeAndCodecs(parameters);
 931 }
 932 
 933 void MediaPlayer::getSupportedTypes(HashSet&lt;String, ASCIICaseInsensitiveHash&gt;&amp; types)
 934 {
 935     for (auto&amp; engine : installedMediaEngines()) {
 936         HashSet&lt;String, ASCIICaseInsensitiveHash&gt; engineTypes;
 937         engine.getSupportedTypes(engineTypes);
 938         types.add(engineTypes.begin(), engineTypes.end());
 939     }
 940 }
 941 
 942 bool MediaPlayer::isAvailable()
 943 {
 944 #if PLATFORM(IOS_FAMILY)
 945     if (DeprecatedGlobalSettings::isAVFoundationEnabled())
 946         return true;
 947 #endif
 948     return !installedMediaEngines().isEmpty();
 949 }
 950 
 951 bool MediaPlayer::supportsPictureInPicture() const
 952 {
 953     return m_private-&gt;supportsPictureInPicture();
 954 }
 955 
 956 #if USE(NATIVE_FULLSCREEN_VIDEO)
 957 
 958 void MediaPlayer::enterFullscreen()
 959 {
 960     m_private-&gt;enterFullscreen();
 961 }
 962 
 963 void MediaPlayer::exitFullscreen()
 964 {
 965     m_private-&gt;exitFullscreen();
 966 }
 967 
 968 #endif
 969 
 970 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 971 
 972 bool MediaPlayer::isCurrentPlaybackTargetWireless() const
 973 {
 974     return m_private-&gt;isCurrentPlaybackTargetWireless();
 975 }
 976 
 977 String MediaPlayer::wirelessPlaybackTargetName() const
 978 {
 979     return m_private-&gt;wirelessPlaybackTargetName();
 980 }
 981 
 982 MediaPlayer::WirelessPlaybackTargetType MediaPlayer::wirelessPlaybackTargetType() const
 983 {
 984     return m_private-&gt;wirelessPlaybackTargetType();
 985 }
 986 
 987 bool MediaPlayer::wirelessVideoPlaybackDisabled() const
 988 {
 989     return m_private-&gt;wirelessVideoPlaybackDisabled();
 990 }
 991 
 992 void MediaPlayer::setWirelessVideoPlaybackDisabled(bool disabled)
 993 {
 994     m_private-&gt;setWirelessVideoPlaybackDisabled(disabled);
 995 }
 996 
 997 void MediaPlayer::currentPlaybackTargetIsWirelessChanged()
 998 {
 999     client().mediaPlayerCurrentPlaybackTargetIsWirelessChanged(this);
1000 }
1001 
1002 bool MediaPlayer::canPlayToWirelessPlaybackTarget() const
1003 {
1004     return m_private-&gt;canPlayToWirelessPlaybackTarget();
1005 }
1006 
1007 void MediaPlayer::setWirelessPlaybackTarget(Ref&lt;MediaPlaybackTarget&gt;&amp;&amp; device)
1008 {
1009     m_private-&gt;setWirelessPlaybackTarget(WTFMove(device));
1010 }
1011 
1012 void MediaPlayer::setShouldPlayToPlaybackTarget(bool shouldPlay)
1013 {
1014     m_private-&gt;setShouldPlayToPlaybackTarget(shouldPlay);
1015 }
1016 
1017 #endif
1018 
1019 double MediaPlayer::maxFastForwardRate() const
1020 {
1021     return m_private-&gt;maxFastForwardRate();
1022 }
1023 
1024 double MediaPlayer::minFastReverseRate() const
1025 {
1026     return m_private-&gt;minFastReverseRate();
1027 }
1028 
1029 #if USE(NATIVE_FULLSCREEN_VIDEO)
1030 
1031 bool MediaPlayer::canEnterFullscreen() const
1032 {
1033     return m_private-&gt;canEnterFullscreen();
1034 }
1035 
1036 #endif
1037 
1038 void MediaPlayer::acceleratedRenderingStateChanged()
1039 {
1040     m_private-&gt;acceleratedRenderingStateChanged();
1041 }
1042 
1043 bool MediaPlayer::supportsAcceleratedRendering() const
1044 {
1045     return m_private-&gt;supportsAcceleratedRendering();
1046 }
1047 
1048 bool MediaPlayer::shouldMaintainAspectRatio() const
1049 {
1050     return m_private-&gt;shouldMaintainAspectRatio();
1051 }
1052 
1053 void MediaPlayer::setShouldMaintainAspectRatio(bool maintainAspectRatio)
1054 {
1055     m_private-&gt;setShouldMaintainAspectRatio(maintainAspectRatio);
1056 }
1057 
1058 bool MediaPlayer::hasSingleSecurityOrigin() const
1059 {
1060     return m_private-&gt;hasSingleSecurityOrigin();
1061 }
1062 
1063 bool MediaPlayer::didPassCORSAccessCheck() const
1064 {
1065     return m_private-&gt;didPassCORSAccessCheck();
1066 }
1067 
1068 bool MediaPlayer::wouldTaintOrigin(const SecurityOrigin&amp; origin) const
1069 {
1070     auto wouldTaint = m_private-&gt;wouldTaintOrigin(origin);
1071     if (wouldTaint.hasValue())
1072         return wouldTaint.value();
1073 
1074     if (m_url.protocolIsData())
1075         return false;
1076 
1077     return !origin.canRequest(m_url);
1078 }
1079 
1080 MediaPlayer::MovieLoadType MediaPlayer::movieLoadType() const
1081 {
1082     return m_private-&gt;movieLoadType();
1083 }
1084 
1085 MediaTime MediaPlayer::mediaTimeForTimeValue(const MediaTime&amp; timeValue) const
1086 {
1087     return m_private-&gt;mediaTimeForTimeValue(timeValue);
1088 }
1089 
1090 double MediaPlayer::maximumDurationToCacheMediaTime() const
1091 {
1092     return m_private-&gt;maximumDurationToCacheMediaTime();
1093 }
1094 
1095 unsigned MediaPlayer::decodedFrameCount() const
1096 {
1097     return m_private-&gt;decodedFrameCount();
1098 }
1099 
1100 unsigned MediaPlayer::droppedFrameCount() const
1101 {
1102     return m_private-&gt;droppedFrameCount();
1103 }
1104 
1105 unsigned MediaPlayer::audioDecodedByteCount() const
1106 {
1107     return m_private-&gt;audioDecodedByteCount();
1108 }
1109 
1110 unsigned MediaPlayer::videoDecodedByteCount() const
1111 {
1112     return m_private-&gt;videoDecodedByteCount();
1113 }
1114 
1115 void MediaPlayer::reloadTimerFired()
1116 {
1117     m_private-&gt;cancelLoad();
1118     loadWithNextMediaEngine(m_currentMediaEngine);
1119 }
1120 
1121 template&lt;typename T&gt;
1122 static void addToHash(HashSet&lt;T&gt;&amp; toHash, HashSet&lt;T&gt;&amp;&amp; fromHash)
1123 {
1124     if (toHash.isEmpty())
1125         toHash = WTFMove(fromHash);
1126     else
1127         toHash.add(fromHash.begin(), fromHash.end());
1128 }
1129 
1130 HashSet&lt;RefPtr&lt;SecurityOrigin&gt;&gt; MediaPlayer::originsInMediaCache(const String&amp; path)
1131 {
1132     HashSet&lt;RefPtr&lt;SecurityOrigin&gt;&gt; origins;
1133     for (auto&amp; engine : installedMediaEngines()) {
1134         if (!engine.originsInMediaCache)
1135             continue;
1136         addToHash(origins, engine.originsInMediaCache(path));
1137     }
1138     return origins;
1139 }
1140 
1141 void MediaPlayer::clearMediaCache(const String&amp; path, WallTime modifiedSince)
1142 {
1143     for (auto&amp; engine : installedMediaEngines()) {
1144         if (engine.clearMediaCache)
1145             engine.clearMediaCache(path, modifiedSince);
1146     }
1147 }
1148 
1149 void MediaPlayer::clearMediaCacheForOrigins(const String&amp; path, const HashSet&lt;RefPtr&lt;SecurityOrigin&gt;&gt;&amp; origins)
1150 {
1151     for (auto&amp; engine : installedMediaEngines()) {
1152         if (engine.clearMediaCacheForOrigins)
1153             engine.clearMediaCacheForOrigins(path, origins);
1154     }
1155 }
1156 
1157 bool MediaPlayer::supportsKeySystem(const String&amp; keySystem, const String&amp; mimeType)
1158 {
1159     for (auto&amp; engine : installedMediaEngines()) {
1160         if (engine.supportsKeySystem &amp;&amp; engine.supportsKeySystem(keySystem, mimeType))
1161             return true;
1162     }
1163     return false;
1164 }
1165 
1166 void MediaPlayer::setPrivateBrowsingMode(bool privateBrowsingMode)
1167 {
1168     m_privateBrowsing = privateBrowsingMode;
1169     if (m_private)
1170         m_private-&gt;setPrivateBrowsingMode(m_privateBrowsing);
1171 }
1172 
1173 // Client callbacks.
1174 void MediaPlayer::networkStateChanged()
1175 {
1176     // If more than one media engine is installed and this one failed before finding metadata,
1177     // let the next engine try.
1178     if (m_private-&gt;networkState() &gt;= FormatError &amp;&amp; m_private-&gt;readyState() &lt; HaveMetadata) {
1179         client().mediaPlayerEngineFailedToLoad();
1180         if (installedMediaEngines().size() &gt; 1 &amp;&amp; (m_contentType.isEmpty() || nextBestMediaEngine(m_currentMediaEngine))) {
1181             m_reloadTimer.startOneShot(0_s);
1182             return;
1183         }
1184     }
1185     client().mediaPlayerNetworkStateChanged(this);
1186 }
1187 
1188 void MediaPlayer::readyStateChanged()
1189 {
1190     client().mediaPlayerReadyStateChanged(this);
1191 }
1192 
1193 void MediaPlayer::volumeChanged(double newVolume)
1194 {
1195 #if PLATFORM(IOS_FAMILY)
1196     UNUSED_PARAM(newVolume);
1197     m_volume = m_private-&gt;volume();
1198 #else
1199     m_volume = newVolume;
1200 #endif
1201     client().mediaPlayerVolumeChanged(this);
1202 }
1203 
1204 void MediaPlayer::muteChanged(bool newMuted)
1205 {
1206     if (newMuted == m_muted)
1207         return;
1208 
1209     m_muted = newMuted;
1210     client().mediaPlayerMuteChanged(this);
1211 }
1212 
1213 void MediaPlayer::timeChanged()
1214 {
1215     client().mediaPlayerTimeChanged(this);
1216 }
1217 
1218 void MediaPlayer::sizeChanged()
1219 {
1220     client().mediaPlayerSizeChanged(this);
1221 }
1222 
1223 void MediaPlayer::repaint()
1224 {
1225     client().mediaPlayerRepaint(this);
1226 }
1227 
1228 void MediaPlayer::durationChanged()
1229 {
1230     client().mediaPlayerDurationChanged(this);
1231 }
1232 
1233 void MediaPlayer::rateChanged()
1234 {
1235     client().mediaPlayerRateChanged(this);
1236 }
1237 
1238 void MediaPlayer::playbackStateChanged()
1239 {
1240     client().mediaPlayerPlaybackStateChanged(this);
1241 }
1242 
1243 void MediaPlayer::firstVideoFrameAvailable()
1244 {
1245     client().mediaPlayerFirstVideoFrameAvailable(this);
1246 }
1247 
1248 void MediaPlayer::characteristicChanged()
1249 {
1250     client().mediaPlayerCharacteristicChanged(this);
1251 }
1252 
1253 #if ENABLE(WEB_AUDIO)
1254 
1255 AudioSourceProvider* MediaPlayer::audioSourceProvider()
1256 {
1257     return m_private-&gt;audioSourceProvider();
1258 }
1259 
1260 #endif
1261 
1262 #if ENABLE(LEGACY_ENCRYPTED_MEDIA)
1263 
1264 RefPtr&lt;ArrayBuffer&gt; MediaPlayer::cachedKeyForKeyId(const String&amp; keyId) const
1265 {
1266     return client().mediaPlayerCachedKeyForKeyId(keyId);
1267 }
1268 
1269 bool MediaPlayer::keyNeeded(Uint8Array* initData)
1270 {
1271     return client().mediaPlayerKeyNeeded(this, initData);
1272 }
1273 
1274 String MediaPlayer::mediaKeysStorageDirectory() const
1275 {
1276     return client().mediaPlayerMediaKeysStorageDirectory();
1277 }
1278 
1279 #endif
1280 
1281 #if ENABLE(ENCRYPTED_MEDIA)
1282 
1283 void MediaPlayer::initializationDataEncountered(const String&amp; initDataType, RefPtr&lt;ArrayBuffer&gt;&amp;&amp; initData)
1284 {
1285     client().mediaPlayerInitializationDataEncountered(initDataType, WTFMove(initData));
1286 }
1287 
1288 void MediaPlayer::waitingForKeyChanged()
1289 {
1290     client().mediaPlayerWaitingForKeyChanged();
1291 }
1292 
1293 bool MediaPlayer::waitingForKey() const
1294 {
1295     if (!m_private)
1296         return false;
1297     return m_private-&gt;waitingForKey();
1298 }
1299 #endif
1300 
1301 String MediaPlayer::referrer() const
1302 {
1303     return client().mediaPlayerReferrer();
1304 }
1305 
1306 String MediaPlayer::userAgent() const
1307 {
1308     return client().mediaPlayerUserAgent();
1309 }
1310 
1311 String MediaPlayer::engineDescription() const
1312 {
1313     if (!m_private)
1314         return String();
1315 
1316     return m_private-&gt;engineDescription();
1317 }
1318 
1319 long MediaPlayer::platformErrorCode() const
1320 {
1321     if (!m_private)
1322         return 0;
1323 
1324     return m_private-&gt;platformErrorCode();
1325 }
1326 
1327 #if PLATFORM(WIN) &amp;&amp; USE(AVFOUNDATION)
1328 GraphicsDeviceAdapter* MediaPlayer::graphicsDeviceAdapter() const
1329 {
1330     return client().mediaPlayerGraphicsDeviceAdapter(this);
1331 }
1332 #endif
1333 
1334 CachedResourceLoader* MediaPlayer::cachedResourceLoader()
1335 {
1336     return client().mediaPlayerCachedResourceLoader();
1337 }
1338 
1339 RefPtr&lt;PlatformMediaResourceLoader&gt; MediaPlayer::createResourceLoader()
1340 {
1341     return client().mediaPlayerCreateResourceLoader();
1342 }
1343 
1344 #if ENABLE(VIDEO_TRACK)
1345 
1346 void MediaPlayer::addAudioTrack(AudioTrackPrivate&amp; track)
1347 {
1348     client().mediaPlayerDidAddAudioTrack(track);
1349 }
1350 
1351 void MediaPlayer::removeAudioTrack(AudioTrackPrivate&amp; track)
1352 {
1353     client().mediaPlayerDidRemoveAudioTrack(track);
1354 }
1355 
1356 void MediaPlayer::addTextTrack(InbandTextTrackPrivate&amp; track)
1357 {
1358     client().mediaPlayerDidAddTextTrack(track);
1359 }
1360 
1361 void MediaPlayer::removeTextTrack(InbandTextTrackPrivate&amp; track)
1362 {
1363     client().mediaPlayerDidRemoveTextTrack(track);
1364 }
1365 
1366 void MediaPlayer::addVideoTrack(VideoTrackPrivate&amp; track)
1367 {
1368     client().mediaPlayerDidAddVideoTrack(track);
1369 }
1370 
1371 void MediaPlayer::removeVideoTrack(VideoTrackPrivate&amp; track)
1372 {
1373     client().mediaPlayerDidRemoveVideoTrack(track);
1374 }
1375 
1376 bool MediaPlayer::requiresTextTrackRepresentation() const
1377 {
1378     return m_private-&gt;requiresTextTrackRepresentation();
1379 }
1380 
1381 void MediaPlayer::setTextTrackRepresentation(TextTrackRepresentation* representation)
1382 {
1383     m_private-&gt;setTextTrackRepresentation(representation);
1384 }
1385 
1386 void MediaPlayer::syncTextTrackBounds()
1387 {
1388     m_private-&gt;syncTextTrackBounds();
1389 }
1390 
1391 void MediaPlayer::tracksChanged()
1392 {
1393     m_private-&gt;tracksChanged();
1394 }
1395 
1396 #if ENABLE(AVF_CAPTIONS)
1397 
1398 void MediaPlayer::notifyTrackModeChanged()
1399 {
1400     if (m_private)
1401         m_private-&gt;notifyTrackModeChanged();
1402 }
1403 
1404 Vector&lt;RefPtr&lt;PlatformTextTrack&gt;&gt; MediaPlayer::outOfBandTrackSources()
1405 {
1406     return client().outOfBandTrackSources();
1407 }
1408 
1409 #endif
1410 
1411 #endif // ENABLE(VIDEO_TRACK)
1412 
1413 void MediaPlayer::resetMediaEngines()
1414 {
1415     auto locker = holdLock(mediaEngineVectorLock);
1416 
1417     mutableInstalledMediaEnginesVector().clear();
1418     haveMediaEnginesVector() = false;
1419 }
1420 
1421 #if USE(GSTREAMER)
1422 void MediaPlayer::simulateAudioInterruption()
1423 {
1424     if (!m_private)
1425         return;
1426 
1427     m_private-&gt;simulateAudioInterruption();
1428 }
1429 #endif
1430 
1431 void MediaPlayer::beginSimulatedHDCPError()
1432 {
1433     if (m_private)
1434         m_private-&gt;beginSimulatedHDCPError();
1435 }
1436 
1437 void MediaPlayer::endSimulatedHDCPError()
1438 {
1439     if (m_private)
1440         m_private-&gt;endSimulatedHDCPError();
1441 }
1442 
1443 String MediaPlayer::languageOfPrimaryAudioTrack() const
1444 {
1445     if (!m_private)
1446         return emptyString();
1447 
1448     return m_private-&gt;languageOfPrimaryAudioTrack();
1449 }
1450 
1451 size_t MediaPlayer::extraMemoryCost() const
1452 {
1453     if (!m_private)
1454         return 0;
1455 
1456     return m_private-&gt;extraMemoryCost();
1457 }
1458 
1459 unsigned long long MediaPlayer::fileSize() const
1460 {
1461     if (!m_private)
1462         return 0;
1463 
1464     return m_private-&gt;fileSize();
1465 }
1466 
1467 bool MediaPlayer::ended() const
1468 {
1469     return m_private-&gt;ended();
1470 }
1471 
1472 Optional&lt;VideoPlaybackQualityMetrics&gt; MediaPlayer::videoPlaybackQualityMetrics()
1473 {
1474     if (!m_private)
1475         return WTF::nullopt;
1476 
1477     return m_private-&gt;videoPlaybackQualityMetrics();
1478 }
1479 
1480 void MediaPlayer::handlePlaybackCommand(PlatformMediaSession::RemoteControlCommandType command)
1481 {
1482     client().mediaPlayerHandlePlaybackCommand(command);
1483 }
1484 
1485 String MediaPlayer::sourceApplicationIdentifier() const
1486 {
1487     return client().mediaPlayerSourceApplicationIdentifier();
1488 }
1489 
1490 Vector&lt;String&gt; MediaPlayer::preferredAudioCharacteristics() const
1491 {
1492     return client().mediaPlayerPreferredAudioCharacteristics();
1493 }
1494 
1495 void MediaPlayerFactorySupport::callRegisterMediaEngine(MediaEngineRegister registerMediaEngine)
1496 {
1497     registerMediaEngine(addMediaEngine);
1498 }
1499 
1500 bool MediaPlayer::doesHaveAttribute(const AtomString&amp; attribute, AtomString* value) const
1501 {
1502     return client().doesHaveAttribute(attribute, value);
1503 }
1504 
1505 #if PLATFORM(IOS_FAMILY)
1506 String MediaPlayer::mediaPlayerNetworkInterfaceName() const
1507 {
1508     return client().mediaPlayerNetworkInterfaceName();
1509 }
1510 
1511 bool MediaPlayer::getRawCookies(const URL&amp; url, Vector&lt;Cookie&gt;&amp; cookies) const
1512 {
1513     return client().mediaPlayerGetRawCookies(url, cookies);
1514 }
1515 #endif
1516 
1517 void MediaPlayer::setShouldDisableSleep(bool flag)
1518 {
1519     if (m_private)
1520         m_private-&gt;setShouldDisableSleep(flag);
1521 }
1522 
1523 bool MediaPlayer::shouldDisableSleep() const
1524 {
1525     return client().mediaPlayerShouldDisableSleep();
1526 }
1527 
1528 const Vector&lt;ContentType&gt;&amp; MediaPlayer::mediaContentTypesRequiringHardwareSupport() const
1529 {
1530     return client().mediaContentTypesRequiringHardwareSupport();
1531 }
1532 
1533 bool MediaPlayer::shouldCheckHardwareSupport() const
1534 {
1535     return client().mediaPlayerShouldCheckHardwareSupport();
1536 }
1537 
1538 void MediaPlayer::applicationWillResignActive()
1539 {
1540     m_private-&gt;applicationWillResignActive();
1541 }
1542 
1543 void MediaPlayer::applicationDidBecomeActive()
1544 {
1545     m_private-&gt;applicationDidBecomeActive();
1546 }
1547 
1548 #if USE(AVFOUNDATION)
1549 
1550 AVPlayer* MediaPlayer::objCAVFoundationAVPlayer() const
1551 {
1552     return m_private-&gt;objCAVFoundationAVPlayer();
1553 }
1554 
1555 #endif
1556 
1557 bool MediaPlayer::performTaskAtMediaTime(WTF::Function&lt;void()&gt;&amp;&amp; task, MediaTime time)
1558 {
1559     return m_private-&gt;performTaskAtMediaTime(WTFMove(task), time);
1560 }
1561 
1562 bool MediaPlayer::shouldIgnoreIntrinsicSize()
1563 {
1564     return m_private-&gt;shouldIgnoreIntrinsicSize();
1565 }
1566 
1567 #if !RELEASE_LOG_DISABLED
1568 const Logger&amp; MediaPlayer::mediaPlayerLogger()
1569 {
1570     return client().mediaPlayerLogger();
1571 }
1572 #endif
1573 
1574 String convertEnumerationToString(MediaPlayerEnums::ReadyState enumerationValue)
1575 {
1576     static const NeverDestroyed&lt;String&gt; values[] = {
1577         MAKE_STATIC_STRING_IMPL(&quot;HaveNothing&quot;),
1578         MAKE_STATIC_STRING_IMPL(&quot;HaveMetadata&quot;),
1579         MAKE_STATIC_STRING_IMPL(&quot;HaveCurrentData&quot;),
1580         MAKE_STATIC_STRING_IMPL(&quot;HaveFutureData&quot;),
1581         MAKE_STATIC_STRING_IMPL(&quot;HaveEnoughData&quot;),
1582     };
1583     static_assert(static_cast&lt;size_t&gt;(MediaPlayerEnums::HaveNothing) == 0, &quot;MediaPlayerEnums::HaveNothing is not 0 as expected&quot;);
1584     static_assert(static_cast&lt;size_t&gt;(MediaPlayerEnums::HaveMetadata) == 1, &quot;MediaPlayerEnums::HaveMetadata is not 1 as expected&quot;);
1585     static_assert(static_cast&lt;size_t&gt;(MediaPlayerEnums::HaveCurrentData) == 2, &quot;MediaPlayerEnums::HaveCurrentData is not 2 as expected&quot;);
1586     static_assert(static_cast&lt;size_t&gt;(MediaPlayerEnums::HaveFutureData) == 3, &quot;MediaPlayerEnums::HaveFutureData is not 3 as expected&quot;);
1587     static_assert(static_cast&lt;size_t&gt;(MediaPlayerEnums::HaveEnoughData) == 4, &quot;MediaPlayerEnums::HaveEnoughData is not 4 as expected&quot;);
1588     ASSERT(static_cast&lt;size_t&gt;(enumerationValue) &lt; WTF_ARRAY_LENGTH(values));
1589     return values[static_cast&lt;size_t&gt;(enumerationValue)];
1590 }
1591 
1592 String convertEnumerationToString(MediaPlayerEnums::NetworkState enumerationValue)
1593 {
1594     static const NeverDestroyed&lt;String&gt; values[] = {
1595         MAKE_STATIC_STRING_IMPL(&quot;Empty&quot;),
1596         MAKE_STATIC_STRING_IMPL(&quot;Idle&quot;),
1597         MAKE_STATIC_STRING_IMPL(&quot;Loading&quot;),
1598         MAKE_STATIC_STRING_IMPL(&quot;Loaded&quot;),
1599         MAKE_STATIC_STRING_IMPL(&quot;FormatError&quot;),
1600         MAKE_STATIC_STRING_IMPL(&quot;NetworkError&quot;),
1601         MAKE_STATIC_STRING_IMPL(&quot;DecodeError&quot;),
1602     };
1603     static_assert(static_cast&lt;size_t&gt;(MediaPlayerEnums::Empty) == 0, &quot;MediaPlayerEnums::Empty is not 0 as expected&quot;);
1604     static_assert(static_cast&lt;size_t&gt;(MediaPlayerEnums::Idle) == 1, &quot;MediaPlayerEnums::Idle is not 1 as expected&quot;);
1605     static_assert(static_cast&lt;size_t&gt;(MediaPlayerEnums::Loading) == 2, &quot;MediaPlayerEnums::Loading is not 2 as expected&quot;);
1606     static_assert(static_cast&lt;size_t&gt;(MediaPlayerEnums::Loaded) == 3, &quot;MediaPlayerEnums::Loaded is not 3 as expected&quot;);
1607     static_assert(static_cast&lt;size_t&gt;(MediaPlayerEnums::FormatError) == 4, &quot;MediaPlayerEnums::FormatError is not 4 as expected&quot;);
1608     static_assert(static_cast&lt;size_t&gt;(MediaPlayerEnums::NetworkError) == 5, &quot;MediaPlayerEnums::NetworkError is not 5 as expected&quot;);
1609     static_assert(static_cast&lt;size_t&gt;(MediaPlayerEnums::DecodeError) == 6, &quot;MediaPlayerEnums::DecodeError is not 6 as expected&quot;);
1610     ASSERT(static_cast&lt;size_t&gt;(enumerationValue) &lt; WTF_ARRAY_LENGTH(values));
1611     return values[static_cast&lt;size_t&gt;(enumerationValue)];
1612 }
1613 
1614 String convertEnumerationToString(MediaPlayerEnums::Preload enumerationValue)
1615 {
1616     static const NeverDestroyed&lt;String&gt; values[] = {
1617         MAKE_STATIC_STRING_IMPL(&quot;None&quot;),
1618         MAKE_STATIC_STRING_IMPL(&quot;MetaData&quot;),
1619         MAKE_STATIC_STRING_IMPL(&quot;Auto&quot;),
1620     };
1621     static_assert(!static_cast&lt;size_t&gt;(MediaPlayerEnums::None), &quot;MediaPlayerEnums::None is not 0 as expected&quot;);
1622     static_assert(static_cast&lt;size_t&gt;(MediaPlayerEnums::MetaData) == 1, &quot;MediaPlayerEnums::MetaData is not 1 as expected&quot;);
1623     static_assert(static_cast&lt;size_t&gt;(MediaPlayerEnums::Auto) == 2, &quot;MediaPlayerEnums::Auto is not 2 as expected&quot;);
1624     ASSERT(static_cast&lt;size_t&gt;(enumerationValue) &lt; WTF_ARRAY_LENGTH(values));
1625     return values[static_cast&lt;size_t&gt;(enumerationValue)];
1626 }
1627 
1628 String convertEnumerationToString(MediaPlayerEnums::SupportsType enumerationValue)
1629 {
1630     static const NeverDestroyed&lt;String&gt; values[] = {
1631         MAKE_STATIC_STRING_IMPL(&quot;IsNotSupported&quot;),
1632         MAKE_STATIC_STRING_IMPL(&quot;IsSupported&quot;),
1633         MAKE_STATIC_STRING_IMPL(&quot;MayBeSupported&quot;),
1634     };
1635     static_assert(!static_cast&lt;size_t&gt;(MediaPlayerEnums::IsNotSupported), &quot;MediaPlayerEnums::IsNotSupported is not 0 as expected&quot;);
1636     static_assert(static_cast&lt;size_t&gt;(MediaPlayerEnums::IsSupported) == 1, &quot;MediaPlayerEnums::IsSupported is not 1 as expected&quot;);
1637     static_assert(static_cast&lt;size_t&gt;(MediaPlayerEnums::MayBeSupported) == 2, &quot;MediaPlayerEnums::MayBeSupported is not 2 as expected&quot;);
1638     ASSERT(static_cast&lt;size_t&gt;(enumerationValue) &lt; WTF_ARRAY_LENGTH(values));
1639     return values[static_cast&lt;size_t&gt;(enumerationValue)];
1640 }
1641 
1642 String convertEnumerationToString(MediaPlayerEnums::BufferingPolicy enumerationValue)
1643 {
1644     static const NeverDestroyed&lt;String&gt; values[] = {
1645         MAKE_STATIC_STRING_IMPL(&quot;Default&quot;),
1646         MAKE_STATIC_STRING_IMPL(&quot;LimitReadAhead&quot;),
1647         MAKE_STATIC_STRING_IMPL(&quot;MakeResourcesPurgeable&quot;),
1648         MAKE_STATIC_STRING_IMPL(&quot;PurgeResources&quot;),
1649     };
1650     static_assert(!static_cast&lt;size_t&gt;(MediaPlayerEnums::BufferingPolicy::Default), &quot;MediaPlayerEnums::Default is not 0 as expected&quot;);
1651     static_assert(static_cast&lt;size_t&gt;(MediaPlayerEnums::BufferingPolicy::LimitReadAhead) == 1, &quot;MediaPlayerEnums::LimitReadAhead is not 1 as expected&quot;);
1652     static_assert(static_cast&lt;size_t&gt;(MediaPlayerEnums::BufferingPolicy::MakeResourcesPurgeable) == 2, &quot;MediaPlayerEnums::MakeResourcesPurgeable is not 2 as expected&quot;);
1653     static_assert(static_cast&lt;size_t&gt;(MediaPlayerEnums::BufferingPolicy::PurgeResources) == 3, &quot;MediaPlayerEnums::PurgeResources is not 3 as expected&quot;);
1654     ASSERT(static_cast&lt;size_t&gt;(enumerationValue) &lt; WTF_ARRAY_LENGTH(values));
1655     return values[static_cast&lt;size_t&gt;(enumerationValue)];
1656 }
1657 
1658 }
1659 
1660 #endif
    </pre>
  </body>
</html>