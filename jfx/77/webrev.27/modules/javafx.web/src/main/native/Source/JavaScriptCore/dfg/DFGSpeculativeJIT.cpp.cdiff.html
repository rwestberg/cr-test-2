<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGSpeculativeJIT.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGSlowPathGenerator.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGSpeculativeJIT.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGSpeculativeJIT.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 38,10 ***</span>
<span class="line-new-header">--- 38,11 ---</span>
  #include &quot;DFGOSRExitFuzz.h&quot;
  #include &quot;DFGSaneStringGetByValSlowPathGenerator.h&quot;
  #include &quot;DFGSlowPathGenerator.h&quot;
  #include &quot;DFGSnippetParams.h&quot;
  #include &quot;DirectArguments.h&quot;
<span class="line-added">+ #include &quot;DisallowMacroScratchRegisterUsage.h&quot;</span>
  #include &quot;JITAddGenerator.h&quot;
  #include &quot;JITBitAndGenerator.h&quot;
  #include &quot;JITBitOrGenerator.h&quot;
  #include &quot;JITBitXorGenerator.h&quot;
  #include &quot;JITDivGenerator.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 69,17 ***</span>
  #include &lt;wtf/MathExtras.h&gt;
  
  namespace JSC { namespace DFG {
  
  SpeculativeJIT::SpeculativeJIT(JITCompiler&amp; jit)
<span class="line-modified">!     : m_compileOkay(true)</span>
<span class="line-removed">-     , m_jit(jit)</span>
      , m_graph(m_jit.graph())
      , m_currentNode(0)
      , m_lastGeneratedNode(LastNodeType)
      , m_indexInBlock(0)
      , m_generationInfo(m_jit.graph().frameRegisterCount())
      , m_state(m_jit.graph())
      , m_interpreter(m_jit.graph(), m_state)
      , m_stream(&amp;jit.jitCode()-&gt;variableEventStream)
      , m_minifiedGraph(&amp;jit.jitCode()-&gt;minifiedDFG)
  {
<span class="line-new-header">--- 70,17 ---</span>
  #include &lt;wtf/MathExtras.h&gt;
  
  namespace JSC { namespace DFG {
  
  SpeculativeJIT::SpeculativeJIT(JITCompiler&amp; jit)
<span class="line-modified">!     : m_jit(jit)</span>
      , m_graph(m_jit.graph())
      , m_currentNode(0)
      , m_lastGeneratedNode(LastNodeType)
      , m_indexInBlock(0)
      , m_generationInfo(m_jit.graph().frameRegisterCount())
<span class="line-added">+     , m_compileOkay(true)</span>
      , m_state(m_jit.graph())
      , m_interpreter(m_jit.graph(), m_state)
      , m_stream(&amp;jit.jitCode()-&gt;variableEventStream)
      , m_minifiedGraph(&amp;jit.jitCode()-&gt;minifiedDFG)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 113,12 ***</span>
          size += vectorLength * sizeof(JSValue) + sizeof(IndexingHeader);
      size += outOfLineCapacity * sizeof(JSValue);
  
      m_jit.move(TrustedImmPtr(nullptr), storageGPR);
  
      if (size) {
<span class="line-modified">!         if (Allocator allocator = m_jit.vm()-&gt;jsValueGigacageAuxiliarySpace.allocatorForNonVirtual(size, AllocatorForMode::AllocatorIfExists)) {</span>
              m_jit.emitAllocate(storageGPR, JITAllocator::constant(allocator), scratchGPR, scratch2GPR, slowCases);
  
              m_jit.addPtr(
                  TrustedImm32(outOfLineCapacity * sizeof(JSValue) + sizeof(IndexingHeader)),
                  storageGPR);
<span class="line-new-header">--- 114,13 ---</span>
          size += vectorLength * sizeof(JSValue) + sizeof(IndexingHeader);
      size += outOfLineCapacity * sizeof(JSValue);
  
      m_jit.move(TrustedImmPtr(nullptr), storageGPR);
  
<span class="line-added">+     VM&amp; vm = this-&gt;vm();</span>
      if (size) {
<span class="line-modified">!         if (Allocator allocator = vm.jsValueGigacageAuxiliarySpace.allocatorForNonVirtual(size, AllocatorForMode::AllocatorIfExists)) {</span>
              m_jit.emitAllocate(storageGPR, JITAllocator::constant(allocator), scratchGPR, scratch2GPR, slowCases);
  
              m_jit.addPtr(
                  TrustedImm32(outOfLineCapacity * sizeof(JSValue) + sizeof(IndexingHeader)),
                  storageGPR);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 128,21 ***</span>
          } else
              slowCases.append(m_jit.jump());
      }
  
      size_t allocationSize = JSFinalObject::allocationSize(inlineCapacity);
<span class="line-modified">!     Allocator allocator = allocatorForNonVirtualConcurrently&lt;JSFinalObject&gt;(*m_jit.vm(), allocationSize, AllocatorForMode::AllocatorIfExists);</span>
      if (allocator) {
          emitAllocateJSObject(resultGPR, JITAllocator::constant(allocator), scratchGPR, TrustedImmPtr(structure), storageGPR, scratch2GPR, slowCases);
          m_jit.emitInitializeInlineStorage(resultGPR, structure-&gt;inlineCapacity());
      } else
          slowCases.append(m_jit.jump());
  
      // I want a slow path that also loads out the storage pointer, and that&#39;s
      // what this custom CallArrayAllocatorSlowPathGenerator gives me. It&#39;s a lot
      // of work for a very small piece of functionality. :-/
<span class="line-modified">!     addSlowPathGenerator(std::make_unique&lt;CallArrayAllocatorSlowPathGenerator&gt;(</span>
          slowCases, this, operationNewRawObject, resultGPR, storageGPR,
          structure, vectorLength));
  
      if (numElements &lt; vectorLength) {
  #if USE(JSVALUE64)
<span class="line-new-header">--- 130,21 ---</span>
          } else
              slowCases.append(m_jit.jump());
      }
  
      size_t allocationSize = JSFinalObject::allocationSize(inlineCapacity);
<span class="line-modified">!     Allocator allocator = allocatorForNonVirtualConcurrently&lt;JSFinalObject&gt;(vm, allocationSize, AllocatorForMode::AllocatorIfExists);</span>
      if (allocator) {
          emitAllocateJSObject(resultGPR, JITAllocator::constant(allocator), scratchGPR, TrustedImmPtr(structure), storageGPR, scratch2GPR, slowCases);
          m_jit.emitInitializeInlineStorage(resultGPR, structure-&gt;inlineCapacity());
      } else
          slowCases.append(m_jit.jump());
  
      // I want a slow path that also loads out the storage pointer, and that&#39;s
      // what this custom CallArrayAllocatorSlowPathGenerator gives me. It&#39;s a lot
      // of work for a very small piece of functionality. :-/
<span class="line-modified">!     addSlowPathGenerator(makeUnique&lt;CallArrayAllocatorSlowPathGenerator&gt;(</span>
          slowCases, this, operationNewRawObject, resultGPR, storageGPR,
          structure, vectorLength));
  
      if (numElements &lt; vectorLength) {
  #if USE(JSVALUE64)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 168,11 ***</span>
      if (hasIndexingHeader)
          m_jit.store32(TrustedImm32(numElements), MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()));
  
      m_jit.emitInitializeOutOfLineStorage(storageGPR, structure-&gt;outOfLineCapacity());
  
<span class="line-modified">!     m_jit.mutatorFence(*m_jit.vm());</span>
  }
  
  void SpeculativeJIT::emitGetLength(InlineCallFrame* inlineCallFrame, GPRReg lengthGPR, bool includeThis)
  {
      if (inlineCallFrame &amp;&amp; !inlineCallFrame-&gt;isVarargs())
<span class="line-new-header">--- 170,11 ---</span>
      if (hasIndexingHeader)
          m_jit.store32(TrustedImm32(numElements), MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()));
  
      m_jit.emitInitializeOutOfLineStorage(storageGPR, structure-&gt;outOfLineCapacity());
  
<span class="line-modified">!     m_jit.mutatorFence(vm);</span>
  }
  
  void SpeculativeJIT::emitGetLength(InlineCallFrame* inlineCallFrame, GPRReg lengthGPR, bool includeThis)
  {
      if (inlineCallFrame &amp;&amp; !inlineCallFrame-&gt;isVarargs())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 185,23 ***</span>
      }
  }
  
  void SpeculativeJIT::emitGetLength(CodeOrigin origin, GPRReg lengthGPR, bool includeThis)
  {
<span class="line-modified">!     emitGetLength(origin.inlineCallFrame, lengthGPR, includeThis);</span>
  }
  
  void SpeculativeJIT::emitGetCallee(CodeOrigin origin, GPRReg calleeGPR)
  {
<span class="line-modified">!     if (origin.inlineCallFrame) {</span>
<span class="line-modified">!         if (origin.inlineCallFrame-&gt;isClosureCall) {</span>
              m_jit.loadPtr(
<span class="line-modified">!                 JITCompiler::addressFor(origin.inlineCallFrame-&gt;calleeRecovery.virtualRegister()),</span>
                  calleeGPR);
          } else {
              m_jit.move(
<span class="line-modified">!                 TrustedImmPtr::weakPointer(m_jit.graph(), origin.inlineCallFrame-&gt;calleeRecovery.constant().asCell()),</span>
                  calleeGPR);
          }
      } else
          m_jit.loadPtr(JITCompiler::addressFor(CallFrameSlot::callee), calleeGPR);
  }
<span class="line-new-header">--- 187,24 ---</span>
      }
  }
  
  void SpeculativeJIT::emitGetLength(CodeOrigin origin, GPRReg lengthGPR, bool includeThis)
  {
<span class="line-modified">!     emitGetLength(origin.inlineCallFrame(), lengthGPR, includeThis);</span>
  }
  
  void SpeculativeJIT::emitGetCallee(CodeOrigin origin, GPRReg calleeGPR)
  {
<span class="line-modified">!     auto* inlineCallFrame = origin.inlineCallFrame();</span>
<span class="line-modified">!     if (inlineCallFrame) {</span>
<span class="line-added">+         if (inlineCallFrame-&gt;isClosureCall) {</span>
              m_jit.loadPtr(
<span class="line-modified">!                 JITCompiler::addressFor(inlineCallFrame-&gt;calleeRecovery.virtualRegister()),</span>
                  calleeGPR);
          } else {
              m_jit.move(
<span class="line-modified">!                 TrustedImmPtr::weakPointer(m_jit.graph(), inlineCallFrame-&gt;calleeRecovery.constant().asCell()),</span>
                  calleeGPR);
          }
      } else
          m_jit.loadPtr(JITCompiler::addressFor(CallFrameSlot::callee), calleeGPR);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 895,11 ***</span>
              MacroAssembler::Address(baseReg, JSCell::indexingTypeAndMiscOffset()), tempGPR);
  
          slowPath.append(jumpSlowForUnwantedArrayMode(tempGPR, node-&gt;arrayMode()));
      }
  
<span class="line-modified">!     addSlowPathGenerator(std::make_unique&lt;ArrayifySlowPathGenerator&gt;(</span>
          slowPath, this, node, baseReg, propertyReg, tempGPR, structureGPR));
  
      noResult(m_currentNode);
  }
  
<span class="line-new-header">--- 898,11 ---</span>
              MacroAssembler::Address(baseReg, JSCell::indexingTypeAndMiscOffset()), tempGPR);
  
          slowPath.append(jumpSlowForUnwantedArrayMode(tempGPR, node-&gt;arrayMode()));
      }
  
<span class="line-modified">!     addSlowPathGenerator(makeUnique&lt;ArrayifySlowPathGenerator&gt;(</span>
          slowPath, this, node, baseReg, propertyReg, tempGPR, structureGPR));
  
      noResult(m_currentNode);
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1544,20 ***</span>
          end.emplace(this, node-&gt;child3());
          endGPR.emplace(end-&gt;gpr());
      }
  
      GPRTemporary temp(this);
<span class="line-removed">-     GPRReg tempGPR = temp.gpr();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     m_jit.loadPtr(CCallHelpers::Address(stringGPR, JSString::offsetOfValue()), tempGPR);</span>
<span class="line-removed">-     auto isRope = m_jit.branchIfRopeStringImpl(tempGPR);</span>
<span class="line-removed">- </span>
      GPRTemporary temp2(this);
      GPRTemporary startIndex(this);
  
      GPRReg temp2GPR = temp2.gpr();
      GPRReg startIndexGPR = startIndex.gpr();
      {
          m_jit.load32(MacroAssembler::Address(tempGPR, StringImpl::lengthMemoryOffset()), temp2GPR);
  
          emitPopulateSliceIndex(node-&gt;child2(), startGPR, temp2GPR, startIndexGPR);
  
<span class="line-new-header">--- 1547,19 ---</span>
          end.emplace(this, node-&gt;child3());
          endGPR.emplace(end-&gt;gpr());
      }
  
      GPRTemporary temp(this);
      GPRTemporary temp2(this);
      GPRTemporary startIndex(this);
  
<span class="line-added">+     GPRReg tempGPR = temp.gpr();</span>
      GPRReg temp2GPR = temp2.gpr();
      GPRReg startIndexGPR = startIndex.gpr();
<span class="line-added">+ </span>
<span class="line-added">+     m_jit.loadPtr(CCallHelpers::Address(stringGPR, JSString::offsetOfValue()), tempGPR);</span>
<span class="line-added">+     auto isRope = m_jit.branchIfRopeStringImpl(tempGPR);</span>
      {
          m_jit.load32(MacroAssembler::Address(tempGPR, StringImpl::lengthMemoryOffset()), temp2GPR);
  
          emitPopulateSliceIndex(node-&gt;child2(), startGPR, temp2GPR, startIndexGPR);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1568,12 ***</span>
      }
  
      CCallHelpers::JumpList doneCases;
      CCallHelpers::JumpList slowCases;
  
      auto nonEmptyCase = m_jit.branch32(MacroAssembler::Below, startIndexGPR, tempGPR);
<span class="line-modified">!     m_jit.move(TrustedImmPtr::weakPointer(m_jit.graph(), jsEmptyString(&amp;vm())), tempGPR);</span>
      doneCases.append(m_jit.jump());
  
      nonEmptyCase.link(&amp;m_jit);
      m_jit.sub32(startIndexGPR, tempGPR); // the size of the sliced string.
      slowCases.append(m_jit.branch32(MacroAssembler::NotEqual, tempGPR, TrustedImm32(1)));
<span class="line-new-header">--- 1570,13 ---</span>
      }
  
      CCallHelpers::JumpList doneCases;
      CCallHelpers::JumpList slowCases;
  
<span class="line-added">+     VM&amp; vm = this-&gt;vm();</span>
      auto nonEmptyCase = m_jit.branch32(MacroAssembler::Below, startIndexGPR, tempGPR);
<span class="line-modified">!     m_jit.move(TrustedImmPtr::weakPointer(m_jit.graph(), jsEmptyString(vm)), tempGPR);</span>
      doneCases.append(m_jit.jump());
  
      nonEmptyCase.link(&amp;m_jit);
      m_jit.sub32(startIndexGPR, tempGPR); // the size of the sliced string.
      slowCases.append(m_jit.branch32(MacroAssembler::NotEqual, tempGPR, TrustedImm32(1)));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1596,11 ***</span>
  
      // 8 bit string values don&#39;t need the isASCII check.
      cont8Bit.link(&amp;m_jit);
  
      m_jit.lshift32(MacroAssembler::TrustedImm32(sizeof(void*) == 4 ? 2 : 3), tempGPR);
<span class="line-modified">!     m_jit.addPtr(TrustedImmPtr(m_jit.vm()-&gt;smallStrings.singleCharacterStrings()), tempGPR);</span>
      m_jit.loadPtr(tempGPR, tempGPR);
  
      addSlowPathGenerator(slowPathCall(bigCharacter, this, operationSingleCharacterString, tempGPR, tempGPR));
  
      addSlowPathGenerator(slowPathCall(slowCases, this, operationStringSubstr, tempGPR, stringGPR, startIndexGPR, tempGPR));
<span class="line-new-header">--- 1599,11 ---</span>
  
      // 8 bit string values don&#39;t need the isASCII check.
      cont8Bit.link(&amp;m_jit);
  
      m_jit.lshift32(MacroAssembler::TrustedImm32(sizeof(void*) == 4 ? 2 : 3), tempGPR);
<span class="line-modified">!     m_jit.addPtr(TrustedImmPtr(vm.smallStrings.singleCharacterStrings()), tempGPR);</span>
      m_jit.loadPtr(tempGPR, tempGPR);
  
      addSlowPathGenerator(slowPathCall(bigCharacter, this, operationSingleCharacterString, tempGPR, tempGPR));
  
      addSlowPathGenerator(slowPathCall(slowCases, this, operationStringSubstr, tempGPR, stringGPR, startIndexGPR, tempGPR));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1861,16 ***</span>
  
          if (verboseCompilationEnabled()) {
              dataLogF(
                  &quot;SpeculativeJIT generating Node @%d (bc#%u) at JIT offset 0x%x&quot;,
                  (int)m_currentNode-&gt;index(),
<span class="line-modified">!                 m_currentNode-&gt;origin.semantic.bytecodeIndex, m_jit.debugOffset());</span>
              dataLog(&quot;\n&quot;);
          }
  
          if (Options::validateDFGExceptionHandling() &amp;&amp; (mayExit(m_jit.graph(), m_currentNode) != DoesNotExit || m_currentNode-&gt;isTerminal()))
<span class="line-modified">!             m_jit.jitReleaseAssertNoException(*m_jit.vm());</span>
  
          m_jit.pcToCodeOriginMapBuilder().appendItem(m_jit.labelIgnoringWatchpoints(), m_origin.semantic);
  
          compile(m_currentNode);
  
<span class="line-new-header">--- 1864,16 ---</span>
  
          if (verboseCompilationEnabled()) {
              dataLogF(
                  &quot;SpeculativeJIT generating Node @%d (bc#%u) at JIT offset 0x%x&quot;,
                  (int)m_currentNode-&gt;index(),
<span class="line-modified">!                 m_currentNode-&gt;origin.semantic.bytecodeIndex(), m_jit.debugOffset());</span>
              dataLog(&quot;\n&quot;);
          }
  
          if (Options::validateDFGExceptionHandling() &amp;&amp; (mayExit(m_jit.graph(), m_currentNode) != DoesNotExit || m_currentNode-&gt;isTerminal()))
<span class="line-modified">!             m_jit.jitReleaseAssertNoException(m_jit.vm());</span>
  
          m_jit.pcToCodeOriginMapBuilder().appendItem(m_jit.labelIgnoringWatchpoints(), m_origin.semantic);
  
          compile(m_currentNode);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1910,11 ***</span>
          if (!node) {
              // The argument is dead. We don&#39;t do any checks for such arguments.
              continue;
          }
  
<span class="line-modified">!         ASSERT(node-&gt;op() == SetArgument);</span>
          ASSERT(node-&gt;shouldGenerate());
  
          VariableAccessData* variableAccessData = node-&gt;variableAccessData();
          FlushFormat format = variableAccessData-&gt;flushFormat();
  
<span class="line-new-header">--- 1913,11 ---</span>
          if (!node) {
              // The argument is dead. We don&#39;t do any checks for such arguments.
              continue;
          }
  
<span class="line-modified">!         ASSERT(node-&gt;op() == SetArgumentDefinitely);</span>
          ASSERT(node-&gt;shouldGenerate());
  
          VariableAccessData* variableAccessData = node-&gt;variableAccessData();
          FlushFormat format = variableAccessData-&gt;flushFormat();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2046,11 ***</span>
      ASSERT(Options::usePollingTraps());
      GPRTemporary unused(this);
      GPRReg unusedGPR = unused.gpr();
  
      JITCompiler::Jump needTrapHandling = m_jit.branchTest8(JITCompiler::NonZero,
<span class="line-modified">!         JITCompiler::AbsoluteAddress(m_jit.vm()-&gt;needTrapHandlingAddress()));</span>
  
      addSlowPathGenerator(slowPathCall(needTrapHandling, this, operationHandleTraps, unusedGPR));
      noResult(node);
  }
  
<span class="line-new-header">--- 2049,11 ---</span>
      ASSERT(Options::usePollingTraps());
      GPRTemporary unused(this);
      GPRReg unusedGPR = unused.gpr();
  
      JITCompiler::Jump needTrapHandling = m_jit.branchTest8(JITCompiler::NonZero,
<span class="line-modified">!         JITCompiler::AbsoluteAddress(m_jit.vm().needTrapHandlingAddress()));</span>
  
      addSlowPathGenerator(slowPathCall(needTrapHandling, this, operationHandleTraps, unusedGPR));
      noResult(node);
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2120,11 ***</span>
  
      if (arrayMode.isOutOfBounds()) {
          addSlowPathGenerator(
              slowPathCall(
                  slowCase, this,
<span class="line-modified">!                 m_jit.codeBlock()-&gt;isStrictMode()</span>
                      ? (node-&gt;op() == PutByValDirect ? operationPutDoubleByValDirectBeyondArrayBoundsStrict : operationPutDoubleByValBeyondArrayBoundsStrict)
                      : (node-&gt;op() == PutByValDirect ? operationPutDoubleByValDirectBeyondArrayBoundsNonStrict : operationPutDoubleByValBeyondArrayBoundsNonStrict),
                  NoResult, baseReg, propertyReg, valueReg));
      }
  
<span class="line-new-header">--- 2123,11 ---</span>
  
      if (arrayMode.isOutOfBounds()) {
          addSlowPathGenerator(
              slowPathCall(
                  slowCase, this,
<span class="line-modified">!                 m_jit.isStrictModeFor(node-&gt;origin.semantic)</span>
                      ? (node-&gt;op() == PutByValDirect ? operationPutDoubleByValDirectBeyondArrayBoundsStrict : operationPutDoubleByValBeyondArrayBoundsStrict)
                      : (node-&gt;op() == PutByValDirect ? operationPutDoubleByValDirectBeyondArrayBoundsNonStrict : operationPutDoubleByValBeyondArrayBoundsNonStrict),
                  NoResult, baseReg, propertyReg, valueReg));
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2211,12 ***</span>
          m_jit.branch32(MacroAssembler::Above, scratchReg, TrustedImm32(maxSingleCharacterString));
  
      // 8 bit string values don&#39;t need the isASCII check.
      cont8Bit.link(&amp;m_jit);
  
      m_jit.lshift32(MacroAssembler::TrustedImm32(sizeof(void*) == 4 ? 2 : 3), scratchReg);
<span class="line-modified">!     m_jit.addPtr(TrustedImmPtr(m_jit.vm()-&gt;smallStrings.singleCharacterStrings()), scratchReg);</span>
      m_jit.loadPtr(scratchReg, scratchReg);
  
      addSlowPathGenerator(
          slowPathCall(
              bigCharacter, this, operationSingleCharacterString, scratchReg, scratchReg));
<span class="line-new-header">--- 2214,13 ---</span>
          m_jit.branch32(MacroAssembler::Above, scratchReg, TrustedImm32(maxSingleCharacterString));
  
      // 8 bit string values don&#39;t need the isASCII check.
      cont8Bit.link(&amp;m_jit);
  
<span class="line-added">+     VM&amp; vm = this-&gt;vm();</span>
      m_jit.lshift32(MacroAssembler::TrustedImm32(sizeof(void*) == 4 ? 2 : 3), scratchReg);
<span class="line-modified">!     m_jit.addPtr(TrustedImmPtr(vm.smallStrings.singleCharacterStrings()), scratchReg);</span>
      m_jit.loadPtr(scratchReg, scratchReg);
  
      addSlowPathGenerator(
          slowPathCall(
              bigCharacter, this, operationSingleCharacterString, scratchReg, scratchReg));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2225,28 ***</span>
  #if USE(JSVALUE32_64)
          m_jit.move(TrustedImm32(JSValue::CellTag), resultTagReg);
  #endif
  
          JSGlobalObject* globalObject = m_jit.globalObjectFor(node-&gt;origin.semantic);
<span class="line-modified">!         bool prototypeChainIsSane = false;</span>
          if (globalObject-&gt;stringPrototypeChainIsSane()) {
              // FIXME: This could be captured using a Speculation mode that means &quot;out-of-bounds
              // loads return a trivial value&quot;. Something like SaneChainOutOfBounds. This should
              // speculate that we don&#39;t take negative out-of-bounds, or better yet, it should rely
              // on a stringPrototypeChainIsSane() guaranteeing that the prototypes have no negative
              // indexed properties either.
              // https://bugs.webkit.org/show_bug.cgi?id=144668
<span class="line-modified">!             m_jit.graph().registerAndWatchStructureTransition(globalObject-&gt;stringPrototype()-&gt;structure(*m_jit.vm()));</span>
<span class="line-modified">!             m_jit.graph().registerAndWatchStructureTransition(globalObject-&gt;objectPrototype()-&gt;structure(*m_jit.vm()));</span>
<span class="line-modified">!             prototypeChainIsSane = globalObject-&gt;stringPrototypeChainIsSane();</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         if (prototypeChainIsSane) {</span>
  #if USE(JSVALUE64)
<span class="line-modified">!             addSlowPathGenerator(std::make_unique&lt;SaneStringGetByValSlowPathGenerator&gt;(</span>
                  outOfBounds, this, JSValueRegs(scratchReg), baseReg, propertyReg));
  #else
<span class="line-modified">!             addSlowPathGenerator(std::make_unique&lt;SaneStringGetByValSlowPathGenerator&gt;(</span>
                  outOfBounds, this, JSValueRegs(resultTagReg, scratchReg),
                  baseReg, propertyReg));
  #endif
          } else {
  #if USE(JSVALUE64)
<span class="line-new-header">--- 2229,29 ---</span>
  #if USE(JSVALUE32_64)
          m_jit.move(TrustedImm32(JSValue::CellTag), resultTagReg);
  #endif
  
          JSGlobalObject* globalObject = m_jit.globalObjectFor(node-&gt;origin.semantic);
<span class="line-modified">!         Structure* stringPrototypeStructure = globalObject-&gt;stringPrototype()-&gt;structure(vm);</span>
<span class="line-added">+         Structure* objectPrototypeStructure = globalObject-&gt;objectPrototype()-&gt;structure(vm);</span>
<span class="line-added">+         WTF::loadLoadFence();</span>
<span class="line-added">+ </span>
          if (globalObject-&gt;stringPrototypeChainIsSane()) {
              // FIXME: This could be captured using a Speculation mode that means &quot;out-of-bounds
              // loads return a trivial value&quot;. Something like SaneChainOutOfBounds. This should
              // speculate that we don&#39;t take negative out-of-bounds, or better yet, it should rely
              // on a stringPrototypeChainIsSane() guaranteeing that the prototypes have no negative
              // indexed properties either.
              // https://bugs.webkit.org/show_bug.cgi?id=144668
<span class="line-modified">!             m_jit.graph().registerAndWatchStructureTransition(stringPrototypeStructure);</span>
<span class="line-modified">!             m_jit.graph().registerAndWatchStructureTransition(objectPrototypeStructure);</span>
<span class="line-modified">! </span>
  #if USE(JSVALUE64)
<span class="line-modified">!             addSlowPathGenerator(makeUnique&lt;SaneStringGetByValSlowPathGenerator&gt;(</span>
                  outOfBounds, this, JSValueRegs(scratchReg), baseReg, propertyReg));
  #else
<span class="line-modified">!             addSlowPathGenerator(makeUnique&lt;SaneStringGetByValSlowPathGenerator&gt;(</span>
                  outOfBounds, this, JSValueRegs(resultTagReg, scratchReg),
                  baseReg, propertyReg));
  #endif
          } else {
  #if USE(JSVALUE64)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2294,12 ***</span>
      GPRTemporary scratch(this);
      GPRReg scratchReg = scratch.gpr();
      GPRReg smallStringsReg = smallStrings.gpr();
  
      JITCompiler::JumpList slowCases;
<span class="line-modified">!     slowCases.append(m_jit.branch32(MacroAssembler::AboveOrEqual, propertyReg, TrustedImm32(maxSingleCharacterString)));</span>
<span class="line-modified">!     m_jit.move(TrustedImmPtr(m_jit.vm()-&gt;smallStrings.singleCharacterStrings()), smallStringsReg);</span>
      m_jit.loadPtr(MacroAssembler::BaseIndex(smallStringsReg, propertyReg, MacroAssembler::ScalePtr, 0), scratchReg);
  
      slowCases.append(m_jit.branchTest32(MacroAssembler::Zero, scratchReg));
      addSlowPathGenerator(slowPathCall(slowCases, this, operationStringFromCharCode, scratchReg, propertyReg));
      cellResult(scratchReg, m_currentNode);
<span class="line-new-header">--- 2299,12 ---</span>
      GPRTemporary scratch(this);
      GPRReg scratchReg = scratch.gpr();
      GPRReg smallStringsReg = smallStrings.gpr();
  
      JITCompiler::JumpList slowCases;
<span class="line-modified">!     slowCases.append(m_jit.branch32(MacroAssembler::Above, propertyReg, TrustedImm32(maxSingleCharacterString)));</span>
<span class="line-modified">!     m_jit.move(TrustedImmPtr(vm().smallStrings.singleCharacterStrings()), smallStringsReg);</span>
      m_jit.loadPtr(MacroAssembler::BaseIndex(smallStringsReg, propertyReg, MacroAssembler::ScalePtr, 0), scratchReg);
  
      slowCases.append(m_jit.branchTest32(MacroAssembler::Zero, scratchReg));
      addSlowPathGenerator(slowPathCall(slowCases, this, operationStringFromCharCode, scratchReg, propertyReg));
      cellResult(scratchReg, m_currentNode);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2869,13 ***</span>
              JITCompiler::Jump notWasteful = m_jit.branch32(
                  MacroAssembler::NotEqual,
                  MacroAssembler::Address(base, JSArrayBufferView::offsetOfMode()),
                  TrustedImm32(WastefulTypedArray));
  
<span class="line-modified">!             JITCompiler::Jump hasNullVector = m_jit.branchTestPtr(</span>
                  MacroAssembler::Zero,
                  MacroAssembler::Address(base, JSArrayBufferView::offsetOfVector()));
              speculationCheck(Uncountable, JSValueSource(), node, hasNullVector);
              notWasteful.link(&amp;m_jit);
          }
      }
      return done;
<span class="line-new-header">--- 2874,25 ---</span>
              JITCompiler::Jump notWasteful = m_jit.branch32(
                  MacroAssembler::NotEqual,
                  MacroAssembler::Address(base, JSArrayBufferView::offsetOfMode()),
                  TrustedImm32(WastefulTypedArray));
  
<span class="line-modified">!             JITCompiler::Jump hasNullVector;</span>
<span class="line-added">+ #if CPU(ARM64E)</span>
<span class="line-added">+             {</span>
<span class="line-added">+                 GPRReg scratch = m_jit.scratchRegister();</span>
<span class="line-added">+                 DisallowMacroScratchRegisterUsage disallowScratch(m_jit);</span>
<span class="line-added">+ </span>
<span class="line-added">+                 m_jit.loadPtr(MacroAssembler::Address(base, JSArrayBufferView::offsetOfVector()), scratch);</span>
<span class="line-added">+                 m_jit.removeArrayPtrTag(scratch);</span>
<span class="line-added">+                 hasNullVector = m_jit.branchTestPtr(MacroAssembler::Zero, scratch);</span>
<span class="line-added">+             }</span>
<span class="line-added">+ #else // CPU(ARM64E)</span>
<span class="line-added">+             hasNullVector = m_jit.branchTestPtr(</span>
                  MacroAssembler::Zero,
                  MacroAssembler::Address(base, JSArrayBufferView::offsetOfVector()));
<span class="line-added">+ #endif</span>
              speculationCheck(Uncountable, JSValueSource(), node, hasNullVector);
              notWasteful.link(&amp;m_jit);
          }
      }
      return done;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2917,11 ***</span>
          int32Result(resultReg, node);
          return;
      }
  
  #if USE(JSVALUE64)
<span class="line-modified">!     if (node-&gt;shouldSpeculateAnyInt()) {</span>
          m_jit.zeroExtend32ToPtr(resultReg, resultReg);
          strictInt52Result(resultReg, node);
          return;
      }
  #endif
<span class="line-new-header">--- 2934,12 ---</span>
          int32Result(resultReg, node);
          return;
      }
  
  #if USE(JSVALUE64)
<span class="line-modified">!     if (node-&gt;shouldSpeculateInt52()) {</span>
<span class="line-added">+         ASSERT(enableInt52());</span>
          m_jit.zeroExtend32ToPtr(resultReg, resultReg);
          strictInt52Result(resultReg, node);
          return;
      }
  #endif
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2947,12 ***</span>
      GPRReg storageReg = storage.gpr();
  
      GPRTemporary result(this);
      GPRReg resultReg = result.gpr();
  
<span class="line-removed">-     ASSERT(node-&gt;arrayMode().alreadyChecked(m_jit.graph(), node, m_state.forNode(m_graph.varArgChild(node, 0))));</span>
<span class="line-removed">- </span>
      emitTypedArrayBoundsCheck(node, baseReg, propertyReg);
      loadFromIntTypedArray(storageReg, propertyReg, resultReg, type);
      bool canSpeculate = true;
      setIntTypedArrayLoadResult(node, resultReg, type, canSpeculate);
  }
<span class="line-new-header">--- 2965,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3151,16 ***</span>
          }
  #else // not USE(JSVALUE64)
          if (node-&gt;op() == PutByValDirect) {
              addSlowPathGenerator(slowPathCall(
                  slowPathCases, this,
<span class="line-modified">!                 m_jit.codeBlock()-&gt;isStrictMode() ? operationPutByValDirectCellStrict : operationPutByValDirectCellNonStrict,</span>
                  NoResult, base, JSValueRegs(propertyTagGPR, property), JSValueRegs(valueTagGPR, valueGPR)));
          } else {
              addSlowPathGenerator(slowPathCall(
                  slowPathCases, this,
<span class="line-modified">!                 m_jit.codeBlock()-&gt;isStrictMode() ? operationPutByValCellStrict : operationPutByValCellNonStrict,</span>
                  NoResult, base, JSValueRegs(propertyTagGPR, property), JSValueRegs(valueTagGPR, valueGPR)));
          }
  #endif
      }
  
<span class="line-new-header">--- 3167,16 ---</span>
          }
  #else // not USE(JSVALUE64)
          if (node-&gt;op() == PutByValDirect) {
              addSlowPathGenerator(slowPathCall(
                  slowPathCases, this,
<span class="line-modified">!                 m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValDirectCellStrict : operationPutByValDirectCellNonStrict,</span>
                  NoResult, base, JSValueRegs(propertyTagGPR, property), JSValueRegs(valueTagGPR, valueGPR)));
          } else {
              addSlowPathGenerator(slowPathCall(
                  slowPathCases, this,
<span class="line-modified">!                 m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValCellStrict : operationPutByValCellNonStrict,</span>
                  NoResult, base, JSValueRegs(propertyTagGPR, property), JSValueRegs(valueTagGPR, valueGPR)));
          }
  #endif
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3177,12 ***</span>
  
      GPRReg baseReg = base.gpr();
      GPRReg propertyReg = property.gpr();
      GPRReg storageReg = storage.gpr();
  
<span class="line-removed">-     ASSERT(node-&gt;arrayMode().alreadyChecked(m_jit.graph(), node, m_state.forNode(m_graph.varArgChild(node, 0))));</span>
<span class="line-removed">- </span>
      FPRTemporary result(this);
      FPRReg resultReg = result.fpr();
      emitTypedArrayBoundsCheck(node, baseReg, propertyReg);
      switch (elementSize(type)) {
      case 4:
<span class="line-new-header">--- 3193,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3520,28 ***</span>
      done.link(&amp;m_jit);
      blessedBooleanResult(resultGPR, node);
      return;
  }
  
<span class="line-modified">! void SpeculativeJIT::compileBitwiseNot(Node* node)</span>
  {
      Edge&amp; child1 = node-&gt;child1();
  
<span class="line-modified">!     if (child1.useKind() == UntypedUse) {</span>
<span class="line-modified">!         JSValueOperand operand(this, child1);</span>
<span class="line-modified">!         JSValueRegs operandRegs = operand.jsValueRegs();</span>
  
          flushRegisters();
<span class="line-modified">!         JSValueRegsFlushedCallResult result(this);</span>
<span class="line-modified">!         JSValueRegs resultRegs = result.regs();</span>
<span class="line-modified">!         callOperation(operationValueBitNot, resultRegs, operandRegs);</span>
          m_jit.exceptionCheck();
  
<span class="line-removed">-         jsValueResult(resultRegs, node);</span>
          return;
      }
  
      SpeculateInt32Operand operand(this, child1);
      GPRTemporary result(this);
      GPRReg resultGPR = result.gpr();
  
      m_jit.move(operand.gpr(), resultGPR);
<span class="line-new-header">--- 3534,47 ---</span>
      done.link(&amp;m_jit);
      blessedBooleanResult(resultGPR, node);
      return;
  }
  
<span class="line-modified">! void SpeculativeJIT::compileValueBitNot(Node* node)</span>
  {
      Edge&amp; child1 = node-&gt;child1();
  
<span class="line-modified">!     if (child1.useKind() == BigIntUse) {</span>
<span class="line-modified">!         SpeculateCellOperand operand(this, child1);</span>
<span class="line-modified">!         GPRReg operandGPR = operand.gpr();</span>
<span class="line-added">+ </span>
<span class="line-added">+         speculateBigInt(child1, operandGPR);</span>
  
          flushRegisters();
<span class="line-modified">!         GPRFlushedCallResult result(this);</span>
<span class="line-modified">!         GPRReg resultGPR = result.gpr();</span>
<span class="line-modified">! </span>
<span class="line-added">+         callOperation(operationBitNotBigInt, resultGPR, operandGPR);</span>
          m_jit.exceptionCheck();
<span class="line-added">+         cellResult(resultGPR, node);</span>
  
          return;
      }
  
<span class="line-added">+     JSValueOperand operand(this, child1);</span>
<span class="line-added">+     JSValueRegs operandRegs = operand.jsValueRegs();</span>
<span class="line-added">+ </span>
<span class="line-added">+     flushRegisters();</span>
<span class="line-added">+     JSValueRegsFlushedCallResult result(this);</span>
<span class="line-added">+     JSValueRegs resultRegs = result.regs();</span>
<span class="line-added">+     callOperation(operationValueBitNot, resultRegs, operandRegs);</span>
<span class="line-added">+     m_jit.exceptionCheck();</span>
<span class="line-added">+ </span>
<span class="line-added">+     jsValueResult(resultRegs, node);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void SpeculativeJIT::compileBitwiseNot(Node* node)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     Edge&amp; child1 = node-&gt;child1();</span>
<span class="line-added">+ </span>
      SpeculateInt32Operand operand(this, child1);
      GPRTemporary result(this);
      GPRReg resultGPR = result.gpr();
  
      m_jit.move(operand.gpr(), resultGPR);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3826,21 ***</span>
      gen.endJumpList().link(&amp;m_jit);
      jsValueResult(resultRegs, node);
      return;
  }
  
  void SpeculativeJIT::compileShiftOp(Node* node)
  {
      NodeType op = node-&gt;op();
      Edge&amp; leftChild = node-&gt;child1();
      Edge&amp; rightChild = node-&gt;child2();
  
      if (leftChild.useKind() == UntypedUse || rightChild.useKind() == UntypedUse) {
          switch (op) {
<span class="line-removed">-         case BitLShift:</span>
<span class="line-removed">-             emitUntypedBitOp&lt;JITLeftShiftGenerator, operationValueBitLShift&gt;(node);</span>
<span class="line-removed">-             return;</span>
          case BitRShift:
          case BitURShift:
              emitUntypedRightShiftBitOp(node);
              return;
          default:
<span class="line-new-header">--- 3859,46 ---</span>
      gen.endJumpList().link(&amp;m_jit);
      jsValueResult(resultRegs, node);
      return;
  }
  
<span class="line-added">+ void SpeculativeJIT::compileValueLShiftOp(Node* node)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     Edge&amp; leftChild = node-&gt;child1();</span>
<span class="line-added">+     Edge&amp; rightChild = node-&gt;child2();</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (node-&gt;binaryUseKind() == BigIntUse) {</span>
<span class="line-added">+         SpeculateCellOperand left(this, leftChild);</span>
<span class="line-added">+         SpeculateCellOperand right(this, rightChild);</span>
<span class="line-added">+         GPRReg leftGPR = left.gpr();</span>
<span class="line-added">+         GPRReg rightGPR = right.gpr();</span>
<span class="line-added">+ </span>
<span class="line-added">+         speculateBigInt(leftChild, leftGPR);</span>
<span class="line-added">+         speculateBigInt(rightChild, rightGPR);</span>
<span class="line-added">+ </span>
<span class="line-added">+         flushRegisters();</span>
<span class="line-added">+         GPRFlushedCallResult result(this);</span>
<span class="line-added">+         GPRReg resultGPR = result.gpr();</span>
<span class="line-added">+ </span>
<span class="line-added">+         callOperation(operationBitLShiftBigInt, resultGPR, leftGPR, rightGPR);</span>
<span class="line-added">+         m_jit.exceptionCheck();</span>
<span class="line-added">+         cellResult(resultGPR, node);</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     ASSERT(leftChild.useKind() == UntypedUse &amp;&amp; rightChild.useKind() == UntypedUse);</span>
<span class="line-added">+     emitUntypedBitOp&lt;JITLeftShiftGenerator, operationValueBitLShift&gt;(node);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void SpeculativeJIT::compileShiftOp(Node* node)
  {
      NodeType op = node-&gt;op();
      Edge&amp; leftChild = node-&gt;child1();
      Edge&amp; rightChild = node-&gt;child2();
  
      if (leftChild.useKind() == UntypedUse || rightChild.useKind() == UntypedUse) {
          switch (op) {
          case BitRShift:
          case BitURShift:
              emitUntypedRightShiftBitOp(node);
              return;
          default:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3916,13 ***</span>
      bool needsScratchGPRReg = true;
      bool needsScratchFPRReg = true;
  #endif
  
      CodeBlock* baselineCodeBlock = m_jit.graph().baselineCodeBlockFor(node-&gt;origin.semantic);
<span class="line-modified">!     ArithProfile* arithProfile = baselineCodeBlock-&gt;arithProfileForBytecodeOffset(node-&gt;origin.semantic.bytecodeIndex);</span>
<span class="line-modified">!     const Instruction* instruction = baselineCodeBlock-&gt;instructions().at(node-&gt;origin.semantic.bytecodeIndex).ptr();</span>
<span class="line-modified">!     JITAddIC* addIC = m_jit.codeBlock()-&gt;addJITAddIC(arithProfile, instruction);</span>
      auto repatchingFunction = operationValueAddOptimize;
      auto nonRepatchingFunction = operationValueAdd;
  
      compileMathIC(node, addIC, needsScratchGPRReg, needsScratchFPRReg, repatchingFunction, nonRepatchingFunction);
  }
<span class="line-new-header">--- 3974,13 ---</span>
      bool needsScratchGPRReg = true;
      bool needsScratchFPRReg = true;
  #endif
  
      CodeBlock* baselineCodeBlock = m_jit.graph().baselineCodeBlockFor(node-&gt;origin.semantic);
<span class="line-modified">!     unsigned bytecodeIndex = node-&gt;origin.semantic.bytecodeIndex();</span>
<span class="line-modified">!     ArithProfile* arithProfile = baselineCodeBlock-&gt;arithProfileForBytecodeOffset(bytecodeIndex);</span>
<span class="line-modified">!     JITAddIC* addIC = m_jit.codeBlock()-&gt;addJITAddIC(arithProfile);</span>
      auto repatchingFunction = operationValueAddOptimize;
      auto nonRepatchingFunction = operationValueAdd;
  
      compileMathIC(node, addIC, needsScratchGPRReg, needsScratchFPRReg, repatchingFunction, nonRepatchingFunction);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3940,13 ***</span>
          bool needsScratchGPRReg = true;
          bool needsScratchFPRReg = true;
  #endif
  
          CodeBlock* baselineCodeBlock = m_jit.graph().baselineCodeBlockFor(node-&gt;origin.semantic);
<span class="line-modified">!         ArithProfile* arithProfile = baselineCodeBlock-&gt;arithProfileForBytecodeOffset(node-&gt;origin.semantic.bytecodeIndex);</span>
<span class="line-modified">!         const Instruction* instruction = baselineCodeBlock-&gt;instructions().at(node-&gt;origin.semantic.bytecodeIndex).ptr();</span>
<span class="line-modified">!         JITSubIC* subIC = m_jit.codeBlock()-&gt;addJITSubIC(arithProfile, instruction);</span>
          auto repatchingFunction = operationValueSubOptimize;
          auto nonRepatchingFunction = operationValueSub;
  
          compileMathIC(node, subIC, needsScratchGPRReg, needsScratchFPRReg, repatchingFunction, nonRepatchingFunction);
          return;
<span class="line-new-header">--- 3998,13 ---</span>
          bool needsScratchGPRReg = true;
          bool needsScratchFPRReg = true;
  #endif
  
          CodeBlock* baselineCodeBlock = m_jit.graph().baselineCodeBlockFor(node-&gt;origin.semantic);
<span class="line-modified">!         unsigned bytecodeIndex = node-&gt;origin.semantic.bytecodeIndex();</span>
<span class="line-modified">!         ArithProfile* arithProfile = baselineCodeBlock-&gt;arithProfileForBytecodeOffset(bytecodeIndex);</span>
<span class="line-modified">!         JITSubIC* subIC = m_jit.codeBlock()-&gt;addJITSubIC(arithProfile);</span>
          auto repatchingFunction = operationValueSubOptimize;
          auto nonRepatchingFunction = operationValueSub;
  
          compileMathIC(node, subIC, needsScratchGPRReg, needsScratchFPRReg, repatchingFunction, nonRepatchingFunction);
          return;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4282,11 ***</span>
          if (!shouldCheckOverflow(node-&gt;arithMode()))
              m_jit.add32(gpr1, gpr2, gprResult);
          else {
              MacroAssembler::Jump check = m_jit.branchAdd32(MacroAssembler::Overflow, gpr1, gpr2, gprResult);
  
<span class="line-modified">!             if (gpr1 == gprResult)</span>
                  speculationCheck(Overflow, JSValueRegs(), 0, check, SpeculationRecovery(SpeculativeAdd, gprResult, gpr2));
              else if (gpr2 == gprResult)
                  speculationCheck(Overflow, JSValueRegs(), 0, check, SpeculationRecovery(SpeculativeAdd, gprResult, gpr1));
              else
                  speculationCheck(Overflow, JSValueRegs(), 0, check);
<span class="line-new-header">--- 4340,13 ---</span>
          if (!shouldCheckOverflow(node-&gt;arithMode()))
              m_jit.add32(gpr1, gpr2, gprResult);
          else {
              MacroAssembler::Jump check = m_jit.branchAdd32(MacroAssembler::Overflow, gpr1, gpr2, gprResult);
  
<span class="line-modified">!             if (gpr1 == gprResult &amp;&amp; gpr2 == gprResult)</span>
<span class="line-added">+                 speculationCheck(Overflow, JSValueRegs(), 0, check, SpeculationRecovery(SpeculativeAddSelf, gprResult, gpr2));</span>
<span class="line-added">+             else if (gpr1 == gprResult)</span>
                  speculationCheck(Overflow, JSValueRegs(), 0, check, SpeculationRecovery(SpeculativeAdd, gprResult, gpr2));
              else if (gpr2 == gprResult)
                  speculationCheck(Overflow, JSValueRegs(), 0, check, SpeculationRecovery(SpeculativeAdd, gprResult, gpr1));
              else
                  speculationCheck(Overflow, JSValueRegs(), 0, check);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4301,12 ***</span>
          ASSERT(shouldCheckOverflow(node-&gt;arithMode()));
          ASSERT(!shouldCheckNegativeZero(node-&gt;arithMode()));
  
          // Will we need an overflow check? If we can prove that neither input can be
          // Int52 then the overflow check will not be necessary.
<span class="line-modified">!         if (!m_state.forNode(node-&gt;child1()).couldBeType(SpecInt52Only)</span>
<span class="line-modified">!             &amp;&amp; !m_state.forNode(node-&gt;child2()).couldBeType(SpecInt52Only)) {</span>
              SpeculateWhicheverInt52Operand op1(this, node-&gt;child1());
              SpeculateWhicheverInt52Operand op2(this, node-&gt;child2(), op1);
              GPRTemporary result(this, Reuse, op1);
              m_jit.add64(op1.gpr(), op2.gpr(), result.gpr());
              int52Result(result.gpr(), node, op1.format());
<span class="line-new-header">--- 4361,12 ---</span>
          ASSERT(shouldCheckOverflow(node-&gt;arithMode()));
          ASSERT(!shouldCheckNegativeZero(node-&gt;arithMode()));
  
          // Will we need an overflow check? If we can prove that neither input can be
          // Int52 then the overflow check will not be necessary.
<span class="line-modified">!         if (!m_state.forNode(node-&gt;child1()).couldBeType(SpecNonInt32AsInt52)</span>
<span class="line-modified">!             &amp;&amp; !m_state.forNode(node-&gt;child2()).couldBeType(SpecNonInt32AsInt52)) {</span>
              SpeculateWhicheverInt52Operand op1(this, node-&gt;child1());
              SpeculateWhicheverInt52Operand op2(this, node-&gt;child2(), op1);
              GPRTemporary result(this, Reuse, op1);
              m_jit.add64(op1.gpr(), op2.gpr(), result.gpr());
              int52Result(result.gpr(), node, op1.format());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4487,12 ***</span>
          ASSERT(shouldCheckOverflow(node-&gt;arithMode()));
          ASSERT(!shouldCheckNegativeZero(node-&gt;arithMode()));
  
          // Will we need an overflow check? If we can prove that neither input can be
          // Int52 then the overflow check will not be necessary.
<span class="line-modified">!         if (!m_state.forNode(node-&gt;child1()).couldBeType(SpecInt52Only)</span>
<span class="line-modified">!             &amp;&amp; !m_state.forNode(node-&gt;child2()).couldBeType(SpecInt52Only)) {</span>
              SpeculateWhicheverInt52Operand op1(this, node-&gt;child1());
              SpeculateWhicheverInt52Operand op2(this, node-&gt;child2(), op1);
              GPRTemporary result(this, Reuse, op1);
              m_jit.move(op1.gpr(), result.gpr());
              m_jit.sub64(op2.gpr(), result.gpr());
<span class="line-new-header">--- 4547,12 ---</span>
          ASSERT(shouldCheckOverflow(node-&gt;arithMode()));
          ASSERT(!shouldCheckNegativeZero(node-&gt;arithMode()));
  
          // Will we need an overflow check? If we can prove that neither input can be
          // Int52 then the overflow check will not be necessary.
<span class="line-modified">!         if (!m_state.forNode(node-&gt;child1()).couldBeType(SpecNonInt32AsInt52)</span>
<span class="line-modified">!             &amp;&amp; !m_state.forNode(node-&gt;child2()).couldBeType(SpecNonInt32AsInt52)) {</span>
              SpeculateWhicheverInt52Operand op1(this, node-&gt;child1());
              SpeculateWhicheverInt52Operand op2(this, node-&gt;child2(), op1);
              GPRTemporary result(this, Reuse, op1);
              m_jit.move(op1.gpr(), result.gpr());
              m_jit.sub64(op2.gpr(), result.gpr());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4532,13 ***</span>
  }
  
  void SpeculativeJIT::compileValueNegate(Node* node)
  {
      CodeBlock* baselineCodeBlock = m_jit.graph().baselineCodeBlockFor(node-&gt;origin.semantic);
<span class="line-modified">!     ArithProfile* arithProfile = baselineCodeBlock-&gt;arithProfileForBytecodeOffset(node-&gt;origin.semantic.bytecodeIndex);</span>
<span class="line-modified">!     const Instruction* instruction = baselineCodeBlock-&gt;instructions().at(node-&gt;origin.semantic.bytecodeIndex).ptr();</span>
<span class="line-modified">!     JITNegIC* negIC = m_jit.codeBlock()-&gt;addJITNegIC(arithProfile, instruction);</span>
      auto repatchingFunction = operationArithNegateOptimize;
      auto nonRepatchingFunction = operationArithNegate;
      bool needsScratchGPRReg = true;
      compileMathIC(node, negIC, needsScratchGPRReg, repatchingFunction, nonRepatchingFunction);
  }
<span class="line-new-header">--- 4592,13 ---</span>
  }
  
  void SpeculativeJIT::compileValueNegate(Node* node)
  {
      CodeBlock* baselineCodeBlock = m_jit.graph().baselineCodeBlockFor(node-&gt;origin.semantic);
<span class="line-modified">!     unsigned bytecodeIndex = node-&gt;origin.semantic.bytecodeIndex();</span>
<span class="line-modified">!     ArithProfile* arithProfile = baselineCodeBlock-&gt;arithProfileForBytecodeOffset(bytecodeIndex);</span>
<span class="line-modified">!     JITNegIC* negIC = m_jit.codeBlock()-&gt;addJITNegIC(arithProfile);</span>
      auto repatchingFunction = operationArithNegateOptimize;
      auto nonRepatchingFunction = operationArithNegate;
      bool needsScratchGPRReg = true;
      compileMathIC(node, negIC, needsScratchGPRReg, repatchingFunction, nonRepatchingFunction);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4570,11 ***</span>
  
  #if USE(JSVALUE64)
      case Int52RepUse: {
          ASSERT(shouldCheckOverflow(node-&gt;arithMode()));
  
<span class="line-modified">!         if (!m_state.forNode(node-&gt;child1()).couldBeType(SpecInt52Only)) {</span>
              SpeculateWhicheverInt52Operand op1(this, node-&gt;child1());
              GPRTemporary result(this);
              GPRReg op1GPR = op1.gpr();
              GPRReg resultGPR = result.gpr();
              m_jit.move(op1GPR, resultGPR);
<span class="line-new-header">--- 4630,11 ---</span>
  
  #if USE(JSVALUE64)
      case Int52RepUse: {
          ASSERT(shouldCheckOverflow(node-&gt;arithMode()));
  
<span class="line-modified">!         if (!m_state.forNode(node-&gt;child1()).couldBeType(SpecNonInt32AsInt52)) {</span>
              SpeculateWhicheverInt52Operand op1(this, node-&gt;child1());
              GPRTemporary result(this);
              GPRReg op1GPR = op1.gpr();
              GPRReg resultGPR = result.gpr();
              m_jit.move(op1GPR, resultGPR);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4755,13 ***</span>
  #else
      bool needsScratchFPRReg = true;
  #endif
  
      CodeBlock* baselineCodeBlock = m_jit.graph().baselineCodeBlockFor(node-&gt;origin.semantic);
<span class="line-modified">!     ArithProfile* arithProfile = baselineCodeBlock-&gt;arithProfileForBytecodeOffset(node-&gt;origin.semantic.bytecodeIndex);</span>
<span class="line-modified">!     const Instruction* instruction = baselineCodeBlock-&gt;instructions().at(node-&gt;origin.semantic.bytecodeIndex).ptr();</span>
<span class="line-modified">!     JITMulIC* mulIC = m_jit.codeBlock()-&gt;addJITMulIC(arithProfile, instruction);</span>
      auto repatchingFunction = operationValueMulOptimize;
      auto nonRepatchingFunction = operationValueMul;
  
      compileMathIC(node, mulIC, needsScratchGPRReg, needsScratchFPRReg, repatchingFunction, nonRepatchingFunction);
  }
<span class="line-new-header">--- 4815,13 ---</span>
  #else
      bool needsScratchFPRReg = true;
  #endif
  
      CodeBlock* baselineCodeBlock = m_jit.graph().baselineCodeBlockFor(node-&gt;origin.semantic);
<span class="line-modified">!     unsigned bytecodeIndex = node-&gt;origin.semantic.bytecodeIndex();</span>
<span class="line-modified">!     ArithProfile* arithProfile = baselineCodeBlock-&gt;arithProfileForBytecodeOffset(bytecodeIndex);</span>
<span class="line-modified">!     JITMulIC* mulIC = m_jit.codeBlock()-&gt;addJITMulIC(arithProfile);</span>
      auto repatchingFunction = operationValueMulOptimize;
      auto nonRepatchingFunction = operationValueMul;
  
      compileMathIC(node, mulIC, needsScratchGPRReg, needsScratchFPRReg, repatchingFunction, nonRepatchingFunction);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5193,10 ***</span>
<span class="line-new-header">--- 5253,48 ---</span>
      callOperation(operationArithFRound, result.fpr(), op1Regs);
      m_jit.exceptionCheck();
      doubleResult(result.fpr(), node);
  }
  
<span class="line-added">+ void SpeculativeJIT::compileValueMod(Node* node)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     Edge&amp; leftChild = node-&gt;child1();</span>
<span class="line-added">+     Edge&amp; rightChild = node-&gt;child2();</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (node-&gt;binaryUseKind() == BigIntUse) {</span>
<span class="line-added">+         SpeculateCellOperand left(this, leftChild);</span>
<span class="line-added">+         SpeculateCellOperand right(this, rightChild);</span>
<span class="line-added">+         GPRReg leftGPR = left.gpr();</span>
<span class="line-added">+         GPRReg rightGPR = right.gpr();</span>
<span class="line-added">+ </span>
<span class="line-added">+         speculateBigInt(leftChild, leftGPR);</span>
<span class="line-added">+         speculateBigInt(rightChild, rightGPR);</span>
<span class="line-added">+ </span>
<span class="line-added">+         flushRegisters();</span>
<span class="line-added">+         GPRFlushedCallResult result(this);</span>
<span class="line-added">+         GPRReg resultGPR = result.gpr();</span>
<span class="line-added">+ </span>
<span class="line-added">+         callOperation(operationModBigInt, resultGPR, leftGPR, rightGPR);</span>
<span class="line-added">+ </span>
<span class="line-added">+         m_jit.exceptionCheck();</span>
<span class="line-added">+         cellResult(resultGPR, node);</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     DFG_ASSERT(m_jit.graph(), node, node-&gt;binaryUseKind() == UntypedUse, node-&gt;binaryUseKind());</span>
<span class="line-added">+     JSValueOperand op1(this, leftChild);</span>
<span class="line-added">+     JSValueOperand op2(this, rightChild);</span>
<span class="line-added">+     JSValueRegs op1Regs = op1.jsValueRegs();</span>
<span class="line-added">+     JSValueRegs op2Regs = op2.jsValueRegs();</span>
<span class="line-added">+     flushRegisters();</span>
<span class="line-added">+     JSValueRegsFlushedCallResult result(this);</span>
<span class="line-added">+     JSValueRegs resultRegs = result.regs();</span>
<span class="line-added">+     callOperation(operationValueMod, resultRegs, op1Regs, op2Regs);</span>
<span class="line-added">+     m_jit.exceptionCheck();</span>
<span class="line-added">+     jsValueResult(resultRegs, node);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void SpeculativeJIT::compileArithMod(Node* node)
  {
      switch (node-&gt;binaryUseKind()) {
      case Int32Use: {
          // In the fast path, the dividend value could be the final result
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5721,10 ***</span>
<span class="line-new-header">--- 5819,51 ---</span>
      skipFastPath.link(&amp;assembler);
  
      return skipSlowPath;
  }
  
<span class="line-added">+ void SpeculativeJIT::compileValuePow(Node* node)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     Edge&amp; leftChild = node-&gt;child1();</span>
<span class="line-added">+     Edge&amp; rightChild = node-&gt;child2();</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (node-&gt;binaryUseKind() == BigIntUse) {</span>
<span class="line-added">+         SpeculateCellOperand left(this, leftChild);</span>
<span class="line-added">+         SpeculateCellOperand right(this, rightChild);</span>
<span class="line-added">+         GPRReg leftGPR = left.gpr();</span>
<span class="line-added">+         GPRReg rightGPR = right.gpr();</span>
<span class="line-added">+ </span>
<span class="line-added">+         speculateBigInt(leftChild, leftGPR);</span>
<span class="line-added">+         speculateBigInt(rightChild, rightGPR);</span>
<span class="line-added">+ </span>
<span class="line-added">+         flushRegisters();</span>
<span class="line-added">+         GPRFlushedCallResult result(this);</span>
<span class="line-added">+         GPRReg resultGPR = result.gpr();</span>
<span class="line-added">+ </span>
<span class="line-added">+         callOperation(operationPowBigInt, resultGPR, leftGPR, rightGPR);</span>
<span class="line-added">+ </span>
<span class="line-added">+         m_jit.exceptionCheck();</span>
<span class="line-added">+         cellResult(resultGPR, node);</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     DFG_ASSERT(m_jit.graph(), node, node-&gt;binaryUseKind() == UntypedUse, node-&gt;binaryUseKind());</span>
<span class="line-added">+ </span>
<span class="line-added">+     JSValueOperand left(this, leftChild);</span>
<span class="line-added">+     JSValueOperand right(this, rightChild);</span>
<span class="line-added">+     JSValueRegs leftRegs = left.jsValueRegs();</span>
<span class="line-added">+     JSValueRegs rightRegs = right.jsValueRegs();</span>
<span class="line-added">+ </span>
<span class="line-added">+     flushRegisters();</span>
<span class="line-added">+     JSValueRegsFlushedCallResult result(this);</span>
<span class="line-added">+     JSValueRegs resultRegs = result.regs();</span>
<span class="line-added">+     callOperation(operationValuePow, resultRegs, leftRegs, rightRegs);</span>
<span class="line-added">+     m_jit.exceptionCheck();</span>
<span class="line-added">+ </span>
<span class="line-added">+     jsValueResult(resultRegs, node);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void SpeculativeJIT::compileArithPow(Node* node)
  {
      if (node-&gt;child2().useKind() == Int32Use) {
          SpeculateDoubleOperand xOperand(this, node-&gt;child1());
          SpeculateInt32Operand yOperand(this, node-&gt;child2());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6568,11 ***</span>
      speculateString(node-&gt;child1(), strGPR);
  
      GPRTemporary eq(this);
      GPRReg eqGPR = eq.gpr();
  
<span class="line-modified">!     m_jit.move(TrustedImmPtr::weakPointer(m_jit.graph(), jsEmptyString(m_jit.vm())), eqGPR);</span>
      m_jit.comparePtr(CCallHelpers::Equal, strGPR, eqGPR, eqGPR);
      unblessedBooleanResult(eqGPR, node);
  }
  
  void SpeculativeJIT::compileLogicalNotStringOrOther(Node* node)
<span class="line-new-header">--- 6707,11 ---</span>
      speculateString(node-&gt;child1(), strGPR);
  
      GPRTemporary eq(this);
      GPRReg eqGPR = eq.gpr();
  
<span class="line-modified">!     m_jit.move(TrustedImmPtr::weakPointer(m_jit.graph(), jsEmptyString(vm())), eqGPR);</span>
      m_jit.comparePtr(CCallHelpers::Equal, strGPR, eqGPR, eqGPR);
      unblessedBooleanResult(eqGPR, node);
  }
  
  void SpeculativeJIT::compileLogicalNotStringOrOther(Node* node)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6585,11 ***</span>
      JITCompiler::Jump notCell = m_jit.branchIfNotCell(valueRegs);
      GPRReg cellGPR = valueRegs.payloadGPR();
      DFG_TYPE_CHECK(
          valueRegs, node-&gt;child1(), (~SpecCellCheck) | SpecString, m_jit.branchIfNotString(cellGPR));
  
<span class="line-modified">!     m_jit.move(TrustedImmPtr::weakPointer(m_jit.graph(), jsEmptyString(m_jit.vm())), tempGPR);</span>
      m_jit.comparePtr(CCallHelpers::Equal, cellGPR, tempGPR, tempGPR);
      auto done = m_jit.jump();
  
      notCell.link(&amp;m_jit);
      DFG_TYPE_CHECK(
<span class="line-new-header">--- 6724,11 ---</span>
      JITCompiler::Jump notCell = m_jit.branchIfNotCell(valueRegs);
      GPRReg cellGPR = valueRegs.payloadGPR();
      DFG_TYPE_CHECK(
          valueRegs, node-&gt;child1(), (~SpecCellCheck) | SpecString, m_jit.branchIfNotString(cellGPR));
  
<span class="line-modified">!     m_jit.move(TrustedImmPtr::weakPointer(m_jit.graph(), jsEmptyString(vm())), tempGPR);</span>
      m_jit.comparePtr(CCallHelpers::Equal, cellGPR, tempGPR, tempGPR);
      auto done = m_jit.jump();
  
      notCell.link(&amp;m_jit);
      DFG_TYPE_CHECK(
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6607,11 ***</span>
  
      GPRReg strGPR = str.gpr();
  
      speculateString(nodeUse, strGPR);
  
<span class="line-modified">!     branchPtr(CCallHelpers::Equal, strGPR, TrustedImmPtr::weakPointer(m_jit.graph(), jsEmptyString(m_jit.vm())), notTaken);</span>
      jump(taken);
  
      noResult(m_currentNode);
  }
  
<span class="line-new-header">--- 6746,11 ---</span>
  
      GPRReg strGPR = str.gpr();
  
      speculateString(nodeUse, strGPR);
  
<span class="line-modified">!     branchPtr(CCallHelpers::Equal, strGPR, TrustedImmPtr::weakPointer(m_jit.graph(), jsEmptyString(vm())), notTaken);</span>
      jump(taken);
  
      noResult(m_currentNode);
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6624,11 ***</span>
  
      JITCompiler::Jump notCell = m_jit.branchIfNotCell(valueRegs);
      GPRReg cellGPR = valueRegs.payloadGPR();
      DFG_TYPE_CHECK(valueRegs, nodeUse, (~SpecCellCheck) | SpecString, m_jit.branchIfNotString(cellGPR));
  
<span class="line-modified">!     branchPtr(CCallHelpers::Equal, cellGPR, TrustedImmPtr::weakPointer(m_jit.graph(), jsEmptyString(m_jit.vm())), notTaken);</span>
      jump(taken, ForceJump);
  
      notCell.link(&amp;m_jit);
      DFG_TYPE_CHECK(
          valueRegs, nodeUse, SpecCellCheck | SpecOther, m_jit.branchIfNotOther(valueRegs, tempGPR));
<span class="line-new-header">--- 6763,11 ---</span>
  
      JITCompiler::Jump notCell = m_jit.branchIfNotCell(valueRegs);
      GPRReg cellGPR = valueRegs.payloadGPR();
      DFG_TYPE_CHECK(valueRegs, nodeUse, (~SpecCellCheck) | SpecString, m_jit.branchIfNotString(cellGPR));
  
<span class="line-modified">!     branchPtr(CCallHelpers::Equal, cellGPR, TrustedImmPtr::weakPointer(m_jit.graph(), jsEmptyString(vm())), notTaken);</span>
      jump(taken, ForceJump);
  
      notCell.link(&amp;m_jit);
      DFG_TYPE_CHECK(
          valueRegs, nodeUse, SpecCellCheck | SpecOther, m_jit.branchIfNotOther(valueRegs, tempGPR));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6642,27 ***</span>
      GPRReg storageGPR = storage.gpr();
      m_jit.move(TrustedImmPtr(node-&gt;storagePointer()), storageGPR);
      storageResult(storageGPR, node);
  }
  
<span class="line-modified">! void SpeculativeJIT::cageTypedArrayStorage(GPRReg storageReg)</span>
  {
  #if GIGACAGE_ENABLED
<span class="line-modified">!     if (!Gigacage::shouldBeEnabled())</span>
          return;
  
      if (Gigacage::canPrimitiveGigacageBeDisabled()) {
<span class="line-modified">!         if (m_jit.vm()-&gt;primitiveGigacageEnabled().isStillValid())</span>
<span class="line-modified">!             m_jit.graph().watchpoints().addLazily(m_jit.vm()-&gt;primitiveGigacageEnabled());</span>
<span class="line-modified">!         else</span>
              return;
      }
  
<span class="line-modified">!     m_jit.cage(Gigacage::Primitive, storageReg);</span>
<span class="line-removed">- #else</span>
<span class="line-removed">-     UNUSED_PARAM(storageReg);</span>
  #endif
  }
  
  void SpeculativeJIT::compileGetIndexedPropertyStorage(Node* node)
  {
      SpeculateCellOperand base(this, node-&gt;child1());
<span class="line-new-header">--- 6781,41 ---</span>
      GPRReg storageGPR = storage.gpr();
      m_jit.move(TrustedImmPtr(node-&gt;storagePointer()), storageGPR);
      storageResult(storageGPR, node);
  }
  
<span class="line-modified">! void SpeculativeJIT::cageTypedArrayStorage(GPRReg baseReg, GPRReg storageReg)</span>
  {
<span class="line-added">+     auto untagArrayPtr = [&amp;]() {</span>
<span class="line-added">+ #if CPU(ARM64E)</span>
<span class="line-added">+         m_jit.untagArrayPtr(MacroAssembler::Address(baseReg, JSArrayBufferView::offsetOfLength()), storageReg);</span>
<span class="line-added">+ #else</span>
<span class="line-added">+         UNUSED_PARAM(baseReg);</span>
<span class="line-added">+         UNUSED_PARAM(storageReg);</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+     };</span>
<span class="line-added">+ </span>
  #if GIGACAGE_ENABLED
<span class="line-modified">!     UNUSED_PARAM(baseReg);</span>
<span class="line-added">+     if (!Gigacage::shouldBeEnabled()) {</span>
<span class="line-added">+         untagArrayPtr();</span>
          return;
<span class="line-added">+     }</span>
  
      if (Gigacage::canPrimitiveGigacageBeDisabled()) {
<span class="line-modified">!         VM&amp; vm = this-&gt;vm();</span>
<span class="line-modified">!         if (vm.primitiveGigacageEnabled().isStillValid())</span>
<span class="line-modified">!             m_jit.graph().watchpoints().addLazily(vm.primitiveGigacageEnabled());</span>
<span class="line-added">+         else {</span>
<span class="line-added">+             untagArrayPtr();</span>
              return;
<span class="line-added">+         }</span>
      }
  
<span class="line-modified">!     m_jit.cageWithoutUntagging(Gigacage::Primitive, storageReg);</span>
  #endif
<span class="line-added">+     untagArrayPtr();</span>
  }
  
  void SpeculativeJIT::compileGetIndexedPropertyStorage(Node* node)
  {
      SpeculateCellOperand base(this, node-&gt;child1());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6681,18 ***</span>
                  this, operationResolveRope, storageReg, baseReg));
  
          m_jit.loadPtr(MacroAssembler::Address(storageReg, StringImpl::dataOffset()), storageReg);
          break;
  
<span class="line-modified">!     default:</span>
          auto typedArrayType = node-&gt;arrayMode().typedArrayType();
          ASSERT_UNUSED(typedArrayType, isTypedView(typedArrayType));
  
          m_jit.loadPtr(JITCompiler::Address(baseReg, JSArrayBufferView::offsetOfVector()), storageReg);
<span class="line-modified">!         cageTypedArrayStorage(storageReg);</span>
          break;
      }
  
      storageResult(storageReg, node);
  }
  
  void SpeculativeJIT::compileGetTypedArrayByteOffset(Node* node)
<span class="line-new-header">--- 6834,19 ---</span>
                  this, operationResolveRope, storageReg, baseReg));
  
          m_jit.loadPtr(MacroAssembler::Address(storageReg, StringImpl::dataOffset()), storageReg);
          break;
  
<span class="line-modified">!     default: {</span>
          auto typedArrayType = node-&gt;arrayMode().typedArrayType();
          ASSERT_UNUSED(typedArrayType, isTypedView(typedArrayType));
  
          m_jit.loadPtr(JITCompiler::Address(baseReg, JSArrayBufferView::offsetOfVector()), storageReg);
<span class="line-modified">!         cageTypedArrayStorage(baseReg, storageReg);</span>
          break;
      }
<span class="line-added">+     }</span>
  
      storageResult(storageReg, node);
  }
  
  void SpeculativeJIT::compileGetTypedArrayByteOffset(Node* node)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6714,21 ***</span>
          MacroAssembler::NotEqual,
          MacroAssembler::Address(baseGPR, JSArrayBufferView::offsetOfMode()),
          TrustedImm32(WastefulTypedArray));
  
      m_jit.loadPtr(MacroAssembler::Address(baseGPR, JSArrayBufferView::offsetOfVector()), vectorGPR);
      JITCompiler::Jump nullVector = m_jit.branchTestPtr(JITCompiler::Zero, vectorGPR);
  
      m_jit.loadPtr(MacroAssembler::Address(baseGPR, JSObject::butterflyOffset()), dataGPR);
<span class="line-modified">!     m_jit.cage(Gigacage::JSValue, dataGPR);</span>
  
<span class="line-modified">!     cageTypedArrayStorage(vectorGPR);</span>
  
      m_jit.loadPtr(MacroAssembler::Address(dataGPR, Butterfly::offsetOfArrayBuffer()), arrayBufferGPR);
      // FIXME: This needs caging.
      // https://bugs.webkit.org/show_bug.cgi?id=175515
      m_jit.loadPtr(MacroAssembler::Address(arrayBufferGPR, ArrayBuffer::offsetOfData()), dataGPR);
      m_jit.subPtr(dataGPR, vectorGPR);
  
      JITCompiler::Jump done = m_jit.jump();
  
      emptyByteOffset.link(&amp;m_jit);
<span class="line-new-header">--- 6868,28 ---</span>
          MacroAssembler::NotEqual,
          MacroAssembler::Address(baseGPR, JSArrayBufferView::offsetOfMode()),
          TrustedImm32(WastefulTypedArray));
  
      m_jit.loadPtr(MacroAssembler::Address(baseGPR, JSArrayBufferView::offsetOfVector()), vectorGPR);
<span class="line-added">+ </span>
<span class="line-added">+     // FIXME: This should mask the PAC bits</span>
<span class="line-added">+     // https://bugs.webkit.org/show_bug.cgi?id=197701</span>
      JITCompiler::Jump nullVector = m_jit.branchTestPtr(JITCompiler::Zero, vectorGPR);
  
      m_jit.loadPtr(MacroAssembler::Address(baseGPR, JSObject::butterflyOffset()), dataGPR);
<span class="line-modified">!     m_jit.cageWithoutUntagging(Gigacage::JSValue, dataGPR);</span>
  
<span class="line-modified">!     cageTypedArrayStorage(baseGPR, vectorGPR);</span>
  
      m_jit.loadPtr(MacroAssembler::Address(dataGPR, Butterfly::offsetOfArrayBuffer()), arrayBufferGPR);
      // FIXME: This needs caging.
      // https://bugs.webkit.org/show_bug.cgi?id=175515
      m_jit.loadPtr(MacroAssembler::Address(arrayBufferGPR, ArrayBuffer::offsetOfData()), dataGPR);
<span class="line-added">+ #if CPU(ARM64E)</span>
<span class="line-added">+     m_jit.removeArrayPtrTag(dataGPR);</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
      m_jit.subPtr(dataGPR, vectorGPR);
  
      JITCompiler::Jump done = m_jit.jump();
  
      emptyByteOffset.link(&amp;m_jit);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6881,11 ***</span>
  void SpeculativeJIT::compileGetGlobalObject(Node* node)
  {
      SpeculateCellOperand object(this, node-&gt;child1());
      GPRTemporary result(this);
      GPRTemporary scratch(this);
<span class="line-modified">!     m_jit.emitLoadStructure(*m_jit.vm(), object.gpr(), result.gpr(), scratch.gpr());</span>
      m_jit.loadPtr(JITCompiler::Address(result.gpr(), Structure::globalObjectOffset()), result.gpr());
      cellResult(result.gpr(), node);
  }
  
  void SpeculativeJIT::compileGetGlobalThis(Node* node)
<span class="line-new-header">--- 7042,11 ---</span>
  void SpeculativeJIT::compileGetGlobalObject(Node* node)
  {
      SpeculateCellOperand object(this, node-&gt;child1());
      GPRTemporary result(this);
      GPRTemporary scratch(this);
<span class="line-modified">!     m_jit.emitLoadStructure(vm(), object.gpr(), result.gpr(), scratch.gpr());</span>
      m_jit.loadPtr(JITCompiler::Address(result.gpr(), Structure::globalObjectOffset()), result.gpr());
      cellResult(result.gpr(), node);
  }
  
  void SpeculativeJIT::compileGetGlobalThis(Node* node)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6895,10 ***</span>
<span class="line-new-header">--- 7056,21 ---</span>
      auto* globalObject = m_jit.graph().globalObjectFor(node-&gt;origin.semantic);
      m_jit.loadPtr(globalObject-&gt;addressOfGlobalThis(), resultGPR);
      cellResult(resultGPR, node);
  }
  
<span class="line-added">+ bool SpeculativeJIT::canBeRope(Edge&amp; edge)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (m_state.forNode(edge).isType(SpecStringIdent))</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+     // If this value is LazyValue, it will be converted to JSString, and the result must be non-rope string.</span>
<span class="line-added">+     String string = edge-&gt;tryGetString(m_graph);</span>
<span class="line-added">+     if (!string.isNull())</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+     return true;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void SpeculativeJIT::compileGetArrayLength(Node* node)
  {
      switch (node-&gt;arrayMode().type()) {
      case Array::Undecided:
      case Array::Int32:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6932,19 ***</span>
          GPRTemporary temp(this);
          GPRReg baseGPR = base.gpr();
          GPRReg resultGPR = result.gpr();
          GPRReg tempGPR = temp.gpr();
  
          m_jit.loadPtr(MacroAssembler::Address(baseGPR, JSString::offsetOfValue()), tempGPR);
<span class="line-modified">!         auto isRope = m_jit.branchIfRopeStringImpl(tempGPR);</span>
          m_jit.load32(MacroAssembler::Address(tempGPR, StringImpl::lengthMemoryOffset()), resultGPR);
<span class="line-modified">!         auto done = m_jit.jump();</span>
  
<span class="line-modified">!         isRope.link(&amp;m_jit);</span>
<span class="line-modified">!         m_jit.load32(CCallHelpers::Address(baseGPR, JSRopeString::offsetOfLength()), resultGPR);</span>
  
<span class="line-modified">!         done.link(&amp;m_jit);</span>
          int32Result(resultGPR, node);
          break;
      }
      case Array::DirectArguments: {
          SpeculateCellOperand base(this, node-&gt;child1());
<span class="line-new-header">--- 7104,25 ---</span>
          GPRTemporary temp(this);
          GPRReg baseGPR = base.gpr();
          GPRReg resultGPR = result.gpr();
          GPRReg tempGPR = temp.gpr();
  
<span class="line-added">+         bool needsRopeCase = canBeRope(node-&gt;child1());</span>
<span class="line-added">+ </span>
          m_jit.loadPtr(MacroAssembler::Address(baseGPR, JSString::offsetOfValue()), tempGPR);
<span class="line-modified">!         CCallHelpers::Jump isRope;</span>
<span class="line-added">+         if (needsRopeCase)</span>
<span class="line-added">+             isRope = m_jit.branchIfRopeStringImpl(tempGPR);</span>
          m_jit.load32(MacroAssembler::Address(tempGPR, StringImpl::lengthMemoryOffset()), resultGPR);
<span class="line-modified">!         if (needsRopeCase) {</span>
<span class="line-added">+             auto done = m_jit.jump();</span>
  
<span class="line-modified">!             isRope.link(&amp;m_jit);</span>
<span class="line-modified">!             m_jit.load32(CCallHelpers::Address(baseGPR, JSRopeString::offsetOfLength()), resultGPR);</span>
  
<span class="line-modified">!             done.link(&amp;m_jit);</span>
<span class="line-added">+         }</span>
          int32Result(resultGPR, node);
          break;
      }
      case Array::DirectArguments: {
          SpeculateCellOperand base(this, node-&gt;child1());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7035,11 ***</span>
  
      m_jit.storePtr(scopeGPR, JITCompiler::Address(resultGPR, JSFunction::offsetOfScopeChain()));
      m_jit.storePtr(TrustedImmPtr::weakPointer(m_jit.graph(), executable), JITCompiler::Address(resultGPR, JSFunction::offsetOfExecutable()));
      m_jit.storePtr(TrustedImmPtr(nullptr), JITCompiler::Address(resultGPR, JSFunction::offsetOfRareData()));
  
<span class="line-modified">!     m_jit.mutatorFence(*m_jit.vm());</span>
  }
  
  void SpeculativeJIT::compileNewFunction(Node* node)
  {
      NodeType nodeType = node-&gt;op();
<span class="line-new-header">--- 7213,32 ---</span>
  
      m_jit.storePtr(scopeGPR, JITCompiler::Address(resultGPR, JSFunction::offsetOfScopeChain()));
      m_jit.storePtr(TrustedImmPtr::weakPointer(m_jit.graph(), executable), JITCompiler::Address(resultGPR, JSFunction::offsetOfExecutable()));
      m_jit.storePtr(TrustedImmPtr(nullptr), JITCompiler::Address(resultGPR, JSFunction::offsetOfRareData()));
  
<span class="line-modified">!     if (executable-&gt;isAnonymousBuiltinFunction()) {</span>
<span class="line-added">+         VM&amp; vm = this-&gt;vm();</span>
<span class="line-added">+         m_jit.mutatorFence(vm);</span>
<span class="line-added">+         GPRTemporary allocator(this);</span>
<span class="line-added">+         Allocator allocatorValue = allocatorForNonVirtualConcurrently&lt;FunctionRareData&gt;(vm, sizeof(FunctionRareData), AllocatorForMode::AllocatorIfExists);</span>
<span class="line-added">+         emitAllocateJSCell(scratch1GPR, JITAllocator::constant(allocatorValue), allocator.gpr(), TrustedImmPtr(m_jit.graph().registerStructure(vm.functionRareDataStructure.get())), scratch2GPR, slowPath);</span>
<span class="line-added">+ </span>
<span class="line-added">+         ptrdiff_t objectAllocationProfileOffset = FunctionRareData::offsetOfObjectAllocationProfile();</span>
<span class="line-added">+         m_jit.storePtr(TrustedImmPtr(nullptr), JITCompiler::Address(scratch1GPR, objectAllocationProfileOffset + ObjectAllocationProfileWithPrototype::offsetOfAllocator()));</span>
<span class="line-added">+         m_jit.storePtr(TrustedImmPtr(nullptr), JITCompiler::Address(scratch1GPR, objectAllocationProfileOffset + ObjectAllocationProfileWithPrototype::offsetOfStructure()));</span>
<span class="line-added">+         m_jit.storePtr(TrustedImmPtr(nullptr), JITCompiler::Address(scratch1GPR, objectAllocationProfileOffset + ObjectAllocationProfileWithPrototype::offsetOfPrototype()));</span>
<span class="line-added">+         m_jit.storePtr(TrustedImmPtr(0x1), JITCompiler::Address(scratch1GPR, FunctionRareData::offsetOfObjectAllocationProfileWatchpoint()));</span>
<span class="line-added">+         m_jit.storePtr(TrustedImmPtr(nullptr), JITCompiler::Address(scratch1GPR, FunctionRareData::offsetOfInternalFunctionAllocationProfile() + InternalFunctionAllocationProfile::offsetOfStructure()));</span>
<span class="line-added">+         m_jit.storePtr(TrustedImmPtr(nullptr), JITCompiler::Address(scratch1GPR, FunctionRareData::offsetOfBoundFunctionStructure()));</span>
<span class="line-added">+         m_jit.storePtr(TrustedImmPtr(nullptr), JITCompiler::Address(scratch1GPR, FunctionRareData::offsetOfAllocationProfileClearingWatchpoint()));</span>
<span class="line-added">+         m_jit.store8(TrustedImm32(0), JITCompiler::Address(scratch1GPR, FunctionRareData::offsetOfHasReifiedLength()));</span>
<span class="line-added">+         m_jit.store8(TrustedImm32(1), JITCompiler::Address(scratch1GPR, FunctionRareData::offsetOfHasReifiedName()));</span>
<span class="line-added">+         m_jit.mutatorFence(vm);</span>
<span class="line-added">+         m_jit.storePtr(scratch1GPR, JITCompiler::Address(resultGPR, JSFunction::offsetOfRareData()));</span>
<span class="line-added">+     } else</span>
<span class="line-added">+         m_jit.mutatorFence(vm());</span>
<span class="line-added">+ </span>
  }
  
  void SpeculativeJIT::compileNewFunction(Node* node)
  {
      NodeType nodeType = node-&gt;op();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7048,11 ***</span>
      SpeculateCellOperand scope(this, node-&gt;child1());
      GPRReg scopeGPR = scope.gpr();
  
      FunctionExecutable* executable = node-&gt;castOperand&lt;FunctionExecutable*&gt;();
  
<span class="line-modified">!     if (executable-&gt;singletonFunction()-&gt;isStillValid()) {</span>
          GPRFlushedCallResult result(this);
          GPRReg resultGPR = result.gpr();
  
          flushRegisters();
  
<span class="line-new-header">--- 7247,11 ---</span>
      SpeculateCellOperand scope(this, node-&gt;child1());
      GPRReg scopeGPR = scope.gpr();
  
      FunctionExecutable* executable = node-&gt;castOperand&lt;FunctionExecutable*&gt;();
  
<span class="line-modified">!     if (executable-&gt;singleton().isStillValid()) {</span>
          GPRFlushedCallResult result(this);
          GPRReg resultGPR = result.gpr();
  
          flushRegisters();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7193,13 ***</span>
  void SpeculativeJIT::compileForwardVarargs(Node* node)
  {
      LoadVarargsData* data = node-&gt;loadVarargsData();
      InlineCallFrame* inlineCallFrame;
      if (node-&gt;child1())
<span class="line-modified">!         inlineCallFrame = node-&gt;child1()-&gt;origin.semantic.inlineCallFrame;</span>
      else
<span class="line-modified">!         inlineCallFrame = node-&gt;origin.semantic.inlineCallFrame;</span>
  
      GPRTemporary length(this);
      JSValueRegsTemporary temp(this);
      GPRReg lengthGPR = length.gpr();
      JSValueRegs tempRegs = temp.regs();
<span class="line-new-header">--- 7392,13 ---</span>
  void SpeculativeJIT::compileForwardVarargs(Node* node)
  {
      LoadVarargsData* data = node-&gt;loadVarargsData();
      InlineCallFrame* inlineCallFrame;
      if (node-&gt;child1())
<span class="line-modified">!         inlineCallFrame = node-&gt;child1()-&gt;origin.semantic.inlineCallFrame();</span>
      else
<span class="line-modified">!         inlineCallFrame = node-&gt;origin.semantic.inlineCallFrame();</span>
  
      GPRTemporary length(this);
      JSValueRegsTemporary temp(this);
      GPRReg lengthGPR = length.gpr();
      JSValueRegs tempRegs = temp.regs();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7265,11 ***</span>
      SpeculateCellOperand scope(this, node-&gt;child1());
      GPRReg scopeGPR = scope.gpr();
      JSValue initializationValue = node-&gt;initializationValueForActivation();
      ASSERT(initializationValue == jsUndefined() || initializationValue == jsTDZValue());
  
<span class="line-modified">!     if (table-&gt;singletonScope()-&gt;isStillValid()) {</span>
          GPRFlushedCallResult result(this);
          GPRReg resultGPR = result.gpr();
  
  #if USE(JSVALUE32_64)
          JSValueRegsTemporary initialization(this);
<span class="line-new-header">--- 7464,11 ---</span>
      SpeculateCellOperand scope(this, node-&gt;child1());
      GPRReg scopeGPR = scope.gpr();
      JSValue initializationValue = node-&gt;initializationValueForActivation();
      ASSERT(initializationValue == jsUndefined() || initializationValue == jsTDZValue());
  
<span class="line-modified">!     if (table-&gt;singleton().isStillValid()) {</span>
          GPRFlushedCallResult result(this);
          GPRReg resultGPR = result.gpr();
  
  #if USE(JSVALUE32_64)
          JSValueRegsTemporary initialization(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7323,11 ***</span>
              initializationValue,
              JITCompiler::Address(
                  resultGPR, JSLexicalEnvironment::offsetOfVariable(ScopeOffset(i))));
      }
  
<span class="line-modified">!     m_jit.mutatorFence(*m_jit.vm());</span>
  
  #if USE(JSVALUE64)
      addSlowPathGenerator(
          slowPathCall(
              slowPath, this, operationCreateActivationDirect, resultGPR, structure, scopeGPR, table, TrustedImm64(JSValue::encode(initializationValue))));
<span class="line-new-header">--- 7522,11 ---</span>
              initializationValue,
              JITCompiler::Address(
                  resultGPR, JSLexicalEnvironment::offsetOfVariable(ScopeOffset(i))));
      }
  
<span class="line-modified">!     m_jit.mutatorFence(vm());</span>
  
  #if USE(JSVALUE64)
      addSlowPathGenerator(
          slowPathCall(
              slowPath, this, operationCreateActivationDirect, resultGPR, structure, scopeGPR, table, TrustedImm64(JSValue::encode(initializationValue))));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7358,13 ***</span>
  
      unsigned minCapacity = m_jit.graph().baselineCodeBlockFor(node-&gt;origin.semantic)-&gt;numParameters() - 1;
  
      unsigned knownLength;
      bool lengthIsKnown; // if false, lengthGPR will have the length.
<span class="line-modified">!     if (node-&gt;origin.semantic.inlineCallFrame</span>
<span class="line-modified">!         &amp;&amp; !node-&gt;origin.semantic.inlineCallFrame-&gt;isVarargs()) {</span>
<span class="line-modified">!         knownLength = node-&gt;origin.semantic.inlineCallFrame-&gt;argumentCountIncludingThis - 1;</span>
          lengthIsKnown = true;
      } else {
          knownLength = UINT_MAX;
          lengthIsKnown = false;
  
<span class="line-new-header">--- 7557,14 ---</span>
  
      unsigned minCapacity = m_jit.graph().baselineCodeBlockFor(node-&gt;origin.semantic)-&gt;numParameters() - 1;
  
      unsigned knownLength;
      bool lengthIsKnown; // if false, lengthGPR will have the length.
<span class="line-modified">!     auto* inlineCallFrame = node-&gt;origin.semantic.inlineCallFrame();</span>
<span class="line-modified">!     if (inlineCallFrame</span>
<span class="line-modified">!         &amp;&amp; !inlineCallFrame-&gt;isVarargs()) {</span>
<span class="line-added">+         knownLength = inlineCallFrame-&gt;argumentCountIncludingThis - 1;</span>
          lengthIsKnown = true;
      } else {
          knownLength = UINT_MAX;
          lengthIsKnown = false;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7429,25 ***</span>
          addSlowPathGenerator(
              slowPathCall(
                  slowPath, this, operationCreateDirectArguments, resultGPR, structure,
                  knownLength, minCapacity));
      } else {
<span class="line-modified">!         auto generator = std::make_unique&lt;CallCreateDirectArgumentsSlowPathGenerator&gt;(</span>
              slowPath, this, resultGPR, structure, lengthGPR, minCapacity);
          addSlowPathGenerator(WTFMove(generator));
      }
  
<span class="line-modified">!     if (node-&gt;origin.semantic.inlineCallFrame) {</span>
<span class="line-modified">!         if (node-&gt;origin.semantic.inlineCallFrame-&gt;isClosureCall) {</span>
              m_jit.loadPtr(
                  JITCompiler::addressFor(
<span class="line-modified">!                     node-&gt;origin.semantic.inlineCallFrame-&gt;calleeRecovery.virtualRegister()),</span>
                  scratch1GPR);
          } else {
              m_jit.move(
                  TrustedImmPtr::weakPointer(
<span class="line-modified">!                     m_jit.graph(), node-&gt;origin.semantic.inlineCallFrame-&gt;calleeRecovery.constant().asCell()),</span>
                  scratch1GPR);
          }
      } else
          m_jit.loadPtr(JITCompiler::addressFor(CallFrameSlot::callee), scratch1GPR);
  
<span class="line-new-header">--- 7629,25 ---</span>
          addSlowPathGenerator(
              slowPathCall(
                  slowPath, this, operationCreateDirectArguments, resultGPR, structure,
                  knownLength, minCapacity));
      } else {
<span class="line-modified">!         auto generator = makeUnique&lt;CallCreateDirectArgumentsSlowPathGenerator&gt;(</span>
              slowPath, this, resultGPR, structure, lengthGPR, minCapacity);
          addSlowPathGenerator(WTFMove(generator));
      }
  
<span class="line-modified">!     if (inlineCallFrame) {</span>
<span class="line-modified">!         if (inlineCallFrame-&gt;isClosureCall) {</span>
              m_jit.loadPtr(
                  JITCompiler::addressFor(
<span class="line-modified">!                     inlineCallFrame-&gt;calleeRecovery.virtualRegister()),</span>
                  scratch1GPR);
          } else {
              m_jit.move(
                  TrustedImmPtr::weakPointer(
<span class="line-modified">!                     m_jit.graph(), inlineCallFrame-&gt;calleeRecovery.constant().asCell()),</span>
                  scratch1GPR);
          }
      } else
          m_jit.loadPtr(JITCompiler::addressFor(CallFrameSlot::callee), scratch1GPR);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7487,11 ***</span>
          m_jit.branchTest32(MacroAssembler::NonZero, lengthGPR).linkTo(loop, &amp;m_jit);
          if (done.isSet())
              done.link(&amp;m_jit);
      }
  
<span class="line-modified">!     m_jit.mutatorFence(*m_jit.vm());</span>
  
      cellResult(resultGPR, node);
  }
  
  void SpeculativeJIT::compileGetFromArguments(Node* node)
<span class="line-new-header">--- 7687,11 ---</span>
          m_jit.branchTest32(MacroAssembler::NonZero, lengthGPR).linkTo(loop, &amp;m_jit);
          if (done.isSet())
              done.link(&amp;m_jit);
      }
  
<span class="line-modified">!     m_jit.mutatorFence(vm());</span>
  
      cellResult(resultGPR, node);
  }
  
  void SpeculativeJIT::compileGetFromArguments(Node* node)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7707,11 ***</span>
          static_assert(sizeof(JSValue) == 8 &amp;&amp; 1 &lt;&lt; 3 == 8, &quot;This is strongly assumed in the code below.&quot;);
          m_jit.move(lengthGPR, scratch1GPR);
          m_jit.lshift32(TrustedImm32(3), scratch1GPR);
          m_jit.add32(TrustedImm32(JSFixedArray::offsetOfData()), scratch1GPR);
  
<span class="line-modified">!         m_jit.emitAllocateVariableSizedCell&lt;JSFixedArray&gt;(*m_jit.vm(), resultGPR, TrustedImmPtr(m_jit.graph().registerStructure(m_jit.graph().m_vm.fixedArrayStructure.get())), scratch1GPR, scratch1GPR, scratch2GPR, slowPath);</span>
          m_jit.store32(lengthGPR, MacroAssembler::Address(resultGPR, JSFixedArray::offsetOfSize()));
  
          m_jit.loadPtr(MacroAssembler::Address(argument, JSObject::butterflyOffset()), scratch1GPR);
  
          MacroAssembler::JumpList done;
<span class="line-new-header">--- 7907,11 ---</span>
          static_assert(sizeof(JSValue) == 8 &amp;&amp; 1 &lt;&lt; 3 == 8, &quot;This is strongly assumed in the code below.&quot;);
          m_jit.move(lengthGPR, scratch1GPR);
          m_jit.lshift32(TrustedImm32(3), scratch1GPR);
          m_jit.add32(TrustedImm32(JSFixedArray::offsetOfData()), scratch1GPR);
  
<span class="line-modified">!         m_jit.emitAllocateVariableSizedCell&lt;JSFixedArray&gt;(vm(), resultGPR, TrustedImmPtr(m_jit.graph().registerStructure(m_jit.graph().m_vm.fixedArrayStructure.get())), scratch1GPR, scratch1GPR, scratch2GPR, slowPath);</span>
          m_jit.store32(lengthGPR, MacroAssembler::Address(resultGPR, JSFixedArray::offsetOfSize()));
  
          m_jit.loadPtr(MacroAssembler::Address(argument, JSObject::butterflyOffset()), scratch1GPR);
  
          MacroAssembler::JumpList done;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7748,11 ***</span>
              m_jit.store64(scratch2GPR, MacroAssembler::BaseIndex(resultGPR, lengthGPR, MacroAssembler::TimesEight, JSFixedArray::offsetOfData()));
              m_jit.branchTest32(MacroAssembler::NonZero, lengthGPR).linkTo(loopStart, &amp;m_jit);
              done.append(m_jit.jump());
          }
  
<span class="line-modified">!         m_jit.mutatorFence(*m_jit.vm());</span>
  
          slowPath.link(&amp;m_jit);
          addSlowPathGenerator(slowPathCall(m_jit.jump(), this, operationSpreadFastArray, resultGPR, argument));
  
          done.link(&amp;m_jit);
<span class="line-new-header">--- 7948,11 ---</span>
              m_jit.store64(scratch2GPR, MacroAssembler::BaseIndex(resultGPR, lengthGPR, MacroAssembler::TimesEight, JSFixedArray::offsetOfData()));
              m_jit.branchTest32(MacroAssembler::NonZero, lengthGPR).linkTo(loopStart, &amp;m_jit);
              done.append(m_jit.jump());
          }
  
<span class="line-modified">!         m_jit.mutatorFence(vm());</span>
  
          slowPath.link(&amp;m_jit);
          addSlowPathGenerator(slowPathCall(m_jit.jump(), this, operationSpreadFastArray, resultGPR, argument));
  
          done.link(&amp;m_jit);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7859,11 ***</span>
          cellResult(result.gpr(), node);
          return;
      }
  
      size_t scratchSize = sizeof(EncodedJSValue) * node-&gt;numChildren();
<span class="line-modified">!     ScratchBuffer* scratchBuffer = m_jit.vm()-&gt;scratchBufferForSize(scratchSize);</span>
      EncodedJSValue* buffer = scratchBuffer ? static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer()) : nullptr;
  
      for (unsigned operandIdx = 0; operandIdx &lt; node-&gt;numChildren(); ++operandIdx) {
          // Need to perform the speculations that this node promises to perform. If we&#39;re
          // emitting code here and the indexing type is not array storage then there is
<span class="line-new-header">--- 8059,11 ---</span>
          cellResult(result.gpr(), node);
          return;
      }
  
      size_t scratchSize = sizeof(EncodedJSValue) * node-&gt;numChildren();
<span class="line-modified">!     ScratchBuffer* scratchBuffer = vm().scratchBufferForSize(scratchSize);</span>
      EncodedJSValue* buffer = scratchBuffer ? static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer()) : nullptr;
  
      for (unsigned operandIdx = 0; operandIdx &lt; node-&gt;numChildren(); ++operandIdx) {
          // Need to perform the speculations that this node promises to perform. If we&#39;re
          // emitting code here and the indexing type is not array storage then there is
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8031,11 ***</span>
      }
  #endif // USE(JSVALUE64)
  
      ASSERT(node-&gt;numChildren());
      size_t scratchSize = sizeof(EncodedJSValue) * node-&gt;numChildren();
<span class="line-modified">!     ScratchBuffer* scratchBuffer = m_jit.vm()-&gt;scratchBufferForSize(scratchSize);</span>
      EncodedJSValue* buffer = static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer());
  
      BitVector* bitVector = node-&gt;bitVector();
      for (unsigned i = 0; i &lt; node-&gt;numChildren(); ++i) {
          Edge use = m_jit.graph().m_varArgChildren[node-&gt;firstChild() + i];
<span class="line-new-header">--- 8231,11 ---</span>
      }
  #endif // USE(JSVALUE64)
  
      ASSERT(node-&gt;numChildren());
      size_t scratchSize = sizeof(EncodedJSValue) * node-&gt;numChildren();
<span class="line-modified">!     ScratchBuffer* scratchBuffer = vm().scratchBufferForSize(scratchSize);</span>
      EncodedJSValue* buffer = static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer());
  
      BitVector* bitVector = node-&gt;bitVector();
      for (unsigned i = 0; i &lt; node-&gt;numChildren(); ++i) {
          Edge use = m_jit.graph().m_varArgChildren[node-&gt;firstChild() + i];
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8244,16 ***</span>
              GPRReg scratch2GPR = scratch2.gpr();
  
              emitAllocateButterfly(storageResultGPR, sizeGPR, scratchGPR, scratch2GPR, resultGPR, slowCases);
              emitInitializeButterfly(storageResultGPR, sizeGPR, emptyValueRegs, scratchGPR);
              emitAllocateJSObject&lt;JSArray&gt;(resultGPR, tempValue, storageResultGPR, scratchGPR, scratch2GPR, slowCases);
<span class="line-modified">!             m_jit.mutatorFence(*m_jit.vm());</span>
          } else {
              slowCases.append(m_jit.jump());
          }
  
<span class="line-modified">!         addSlowPathGenerator(std::make_unique&lt;CallArrayAllocatorWithVariableStructureVariableSizeSlowPathGenerator&gt;(</span>
              slowCases, this, operationNewArrayWithSize, resultGPR, tempValue, sizeGPR, storageResultGPR));
      }
  
      GPRTemporary temp4(this);
      GPRReg loadIndex = temp4.gpr();
<span class="line-new-header">--- 8444,16 ---</span>
              GPRReg scratch2GPR = scratch2.gpr();
  
              emitAllocateButterfly(storageResultGPR, sizeGPR, scratchGPR, scratch2GPR, resultGPR, slowCases);
              emitInitializeButterfly(storageResultGPR, sizeGPR, emptyValueRegs, scratchGPR);
              emitAllocateJSObject&lt;JSArray&gt;(resultGPR, tempValue, storageResultGPR, scratchGPR, scratch2GPR, slowCases);
<span class="line-modified">!             m_jit.mutatorFence(vm());</span>
          } else {
              slowCases.append(m_jit.jump());
          }
  
<span class="line-modified">!         addSlowPathGenerator(makeUnique&lt;CallArrayAllocatorWithVariableStructureVariableSizeSlowPathGenerator&gt;(</span>
              slowCases, this, operationNewArrayWithSize, resultGPR, tempValue, sizeGPR, storageResultGPR));
      }
  
      GPRTemporary temp4(this);
      GPRReg loadIndex = temp4.gpr();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8542,16 ***</span>
      switch (node-&gt;arrayMode().type()) {
      case Array::Int32:
      case Array::Contiguous: {
          if (elementCount == 1) {
              Edge&amp; element = m_jit.graph().varArgChild(node, elementOffset);
              JSValueOperand value(this, element, ManualOperandSpeculation);
              JSValueRegs valueRegs = value.jsValueRegs();
  
<span class="line-removed">-             if (node-&gt;arrayMode().type() == Array::Int32)</span>
<span class="line-removed">-                 DFG_ASSERT(m_jit.graph(), node, !needsTypeCheck(element, SpecInt32Only));</span>
<span class="line-removed">- </span>
              m_jit.load32(MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()), storageLengthGPR);
              MacroAssembler::Jump slowPath = m_jit.branch32(MacroAssembler::AboveOrEqual, storageLengthGPR, MacroAssembler::Address(storageGPR, Butterfly::offsetOfVectorLength()));
              m_jit.storeValue(valueRegs, MacroAssembler::BaseIndex(storageGPR, storageLengthGPR, MacroAssembler::TimesEight));
              m_jit.add32(TrustedImm32(1), storageLengthGPR);
              m_jit.store32(storageLengthGPR, MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()));
<span class="line-new-header">--- 8742,17 ---</span>
      switch (node-&gt;arrayMode().type()) {
      case Array::Int32:
      case Array::Contiguous: {
          if (elementCount == 1) {
              Edge&amp; element = m_jit.graph().varArgChild(node, elementOffset);
<span class="line-added">+             if (node-&gt;arrayMode().type() == Array::Int32) {</span>
<span class="line-added">+                 ASSERT(element.useKind() == Int32Use);</span>
<span class="line-added">+                 speculateInt32(element);</span>
<span class="line-added">+             }</span>
              JSValueOperand value(this, element, ManualOperandSpeculation);
              JSValueRegs valueRegs = value.jsValueRegs();
  
              m_jit.load32(MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()), storageLengthGPR);
              MacroAssembler::Jump slowPath = m_jit.branch32(MacroAssembler::AboveOrEqual, storageLengthGPR, MacroAssembler::Address(storageGPR, Butterfly::offsetOfVectorLength()));
              m_jit.storeValue(valueRegs, MacroAssembler::BaseIndex(storageGPR, storageLengthGPR, MacroAssembler::TimesEight));
              m_jit.add32(TrustedImm32(1), storageLengthGPR);
              m_jit.store32(storageLengthGPR, MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8562,10 ***</span>
<span class="line-new-header">--- 8763,18 ---</span>
  
              jsValueResult(resultRegs, node);
              return;
          }
  
<span class="line-added">+         if (node-&gt;arrayMode().type() == Array::Int32) {</span>
<span class="line-added">+             for (unsigned elementIndex = 0; elementIndex &lt; elementCount; ++elementIndex) {</span>
<span class="line-added">+                 Edge element = m_jit.graph().varArgChild(node, elementIndex + elementOffset);</span>
<span class="line-added">+                 ASSERT(element.useKind() == Int32Use);</span>
<span class="line-added">+                 speculateInt32(element);</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          GPRTemporary buffer(this);
          GPRReg bufferGPR = buffer.gpr();
  
          m_jit.load32(MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()), storageLengthGPR);
          m_jit.move(storageLengthGPR, bufferGPR);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8579,24 ***</span>
          auto storageDone = m_jit.jump();
  
          slowPath.link(&amp;m_jit);
  
          size_t scratchSize = sizeof(EncodedJSValue) * elementCount;
<span class="line-modified">!         ScratchBuffer* scratchBuffer = m_jit.vm()-&gt;scratchBufferForSize(scratchSize);</span>
          m_jit.move(TrustedImmPtr(static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer())), bufferGPR);
          m_jit.move(TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), storageLengthGPR);
          m_jit.storePtr(TrustedImmPtr(scratchSize), MacroAssembler::Address(storageLengthGPR));
  
          storageDone.link(&amp;m_jit);
          for (unsigned elementIndex = 0; elementIndex &lt; elementCount; ++elementIndex) {
              Edge&amp; element = m_jit.graph().varArgChild(node, elementIndex + elementOffset);
<span class="line-modified">!             JSValueOperand value(this, element, ManualOperandSpeculation);</span>
              JSValueRegs valueRegs = value.jsValueRegs();
  
<span class="line-removed">-             if (node-&gt;arrayMode().type() == Array::Int32)</span>
<span class="line-removed">-                 DFG_ASSERT(m_jit.graph(), node, !needsTypeCheck(element, SpecInt32Only));</span>
<span class="line-removed">- </span>
              m_jit.storeValue(valueRegs, MacroAssembler::Address(bufferGPR, sizeof(EncodedJSValue) * elementIndex));
              value.use();
          }
  
          MacroAssembler::Jump fastPath = m_jit.branchPtr(MacroAssembler::NotEqual, bufferGPR, TrustedImmPtr(static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer())));
<span class="line-new-header">--- 8788,21 ---</span>
          auto storageDone = m_jit.jump();
  
          slowPath.link(&amp;m_jit);
  
          size_t scratchSize = sizeof(EncodedJSValue) * elementCount;
<span class="line-modified">!         ScratchBuffer* scratchBuffer = vm().scratchBufferForSize(scratchSize);</span>
          m_jit.move(TrustedImmPtr(static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer())), bufferGPR);
          m_jit.move(TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), storageLengthGPR);
          m_jit.storePtr(TrustedImmPtr(scratchSize), MacroAssembler::Address(storageLengthGPR));
  
          storageDone.link(&amp;m_jit);
          for (unsigned elementIndex = 0; elementIndex &lt; elementCount; ++elementIndex) {
              Edge&amp; element = m_jit.graph().varArgChild(node, elementIndex + elementOffset);
<span class="line-modified">!             JSValueOperand value(this, element, ManualOperandSpeculation); // We did type checks above.</span>
              JSValueRegs valueRegs = value.jsValueRegs();
  
              m_jit.storeValue(valueRegs, MacroAssembler::Address(bufferGPR, sizeof(EncodedJSValue) * elementIndex));
              value.use();
          }
  
          MacroAssembler::Jump fastPath = m_jit.branchPtr(MacroAssembler::NotEqual, bufferGPR, TrustedImmPtr(static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer())));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8615,15 ***</span>
      }
  
      case Array::Double: {
          if (elementCount == 1) {
              Edge&amp; element = m_jit.graph().varArgChild(node, elementOffset);
              SpeculateDoubleOperand value(this, element);
              FPRReg valueFPR = value.fpr();
  
<span class="line-removed">-             DFG_ASSERT(m_jit.graph(), node, !needsTypeCheck(element, SpecDoubleReal));</span>
<span class="line-removed">- </span>
              m_jit.load32(MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()), storageLengthGPR);
              MacroAssembler::Jump slowPath = m_jit.branch32(MacroAssembler::AboveOrEqual, storageLengthGPR, MacroAssembler::Address(storageGPR, Butterfly::offsetOfVectorLength()));
              m_jit.storeDouble(valueFPR, MacroAssembler::BaseIndex(storageGPR, storageLengthGPR, MacroAssembler::TimesEight));
              m_jit.add32(TrustedImm32(1), storageLengthGPR);
              m_jit.store32(storageLengthGPR, MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()));
<span class="line-new-header">--- 8821,14 ---</span>
      }
  
      case Array::Double: {
          if (elementCount == 1) {
              Edge&amp; element = m_jit.graph().varArgChild(node, elementOffset);
<span class="line-added">+             speculate(node, element);</span>
              SpeculateDoubleOperand value(this, element);
              FPRReg valueFPR = value.fpr();
  
              m_jit.load32(MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()), storageLengthGPR);
              MacroAssembler::Jump slowPath = m_jit.branch32(MacroAssembler::AboveOrEqual, storageLengthGPR, MacroAssembler::Address(storageGPR, Butterfly::offsetOfVectorLength()));
              m_jit.storeDouble(valueFPR, MacroAssembler::BaseIndex(storageGPR, storageLengthGPR, MacroAssembler::TimesEight));
              m_jit.add32(TrustedImm32(1), storageLengthGPR);
              m_jit.store32(storageLengthGPR, MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8634,10 ***</span>
<span class="line-new-header">--- 8839,16 ---</span>
  
              jsValueResult(resultRegs, node);
              return;
          }
  
<span class="line-added">+         for (unsigned elementIndex = 0; elementIndex &lt; elementCount; ++elementIndex) {</span>
<span class="line-added">+             Edge element = m_jit.graph().varArgChild(node, elementIndex + elementOffset);</span>
<span class="line-added">+             ASSERT(element.useKind() == DoubleRepRealUse);</span>
<span class="line-added">+             speculate(node, element);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          GPRTemporary buffer(this);
          GPRReg bufferGPR = buffer.gpr();
  
          m_jit.load32(MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()), storageLengthGPR);
          m_jit.move(storageLengthGPR, bufferGPR);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8651,23 ***</span>
          auto storageDone = m_jit.jump();
  
          slowPath.link(&amp;m_jit);
  
          size_t scratchSize = sizeof(double) * elementCount;
<span class="line-modified">!         ScratchBuffer* scratchBuffer = m_jit.vm()-&gt;scratchBufferForSize(scratchSize);</span>
          m_jit.move(TrustedImmPtr(static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer())), bufferGPR);
          m_jit.move(TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), storageLengthGPR);
          m_jit.storePtr(TrustedImmPtr(scratchSize), MacroAssembler::Address(storageLengthGPR));
  
          storageDone.link(&amp;m_jit);
          for (unsigned elementIndex = 0; elementIndex &lt; elementCount; ++elementIndex) {
              Edge&amp; element = m_jit.graph().varArgChild(node, elementIndex + elementOffset);
              SpeculateDoubleOperand value(this, element);
              FPRReg valueFPR = value.fpr();
  
<span class="line-removed">-             DFG_ASSERT(m_jit.graph(), node, !needsTypeCheck(element, SpecDoubleReal));</span>
<span class="line-removed">- </span>
              m_jit.storeDouble(valueFPR, MacroAssembler::Address(bufferGPR, sizeof(double) * elementIndex));
              value.use();
          }
  
          MacroAssembler::Jump fastPath = m_jit.branchPtr(MacroAssembler::NotEqual, bufferGPR, TrustedImmPtr(static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer())));
<span class="line-new-header">--- 8862,21 ---</span>
          auto storageDone = m_jit.jump();
  
          slowPath.link(&amp;m_jit);
  
          size_t scratchSize = sizeof(double) * elementCount;
<span class="line-modified">!         ScratchBuffer* scratchBuffer = vm().scratchBufferForSize(scratchSize);</span>
          m_jit.move(TrustedImmPtr(static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer())), bufferGPR);
          m_jit.move(TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), storageLengthGPR);
          m_jit.storePtr(TrustedImmPtr(scratchSize), MacroAssembler::Address(storageLengthGPR));
  
          storageDone.link(&amp;m_jit);
          for (unsigned elementIndex = 0; elementIndex &lt; elementCount; ++elementIndex) {
              Edge&amp; element = m_jit.graph().varArgChild(node, elementIndex + elementOffset);
              SpeculateDoubleOperand value(this, element);
              FPRReg valueFPR = value.fpr();
  
              m_jit.storeDouble(valueFPR, MacroAssembler::Address(bufferGPR, sizeof(double) * elementIndex));
              value.use();
          }
  
          MacroAssembler::Jump fastPath = m_jit.branchPtr(MacroAssembler::NotEqual, bufferGPR, TrustedImmPtr(static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer())));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8734,11 ***</span>
          auto storageDone = m_jit.jump();
  
          slowPath.link(&amp;m_jit);
  
          size_t scratchSize = sizeof(EncodedJSValue) * elementCount;
<span class="line-modified">!         ScratchBuffer* scratchBuffer = m_jit.vm()-&gt;scratchBufferForSize(scratchSize);</span>
          m_jit.move(TrustedImmPtr(static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer())), bufferGPR);
          m_jit.move(TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), storageLengthGPR);
          m_jit.storePtr(TrustedImmPtr(scratchSize), MacroAssembler::Address(storageLengthGPR));
  
          storageDone.link(&amp;m_jit);
<span class="line-new-header">--- 8943,11 ---</span>
          auto storageDone = m_jit.jump();
  
          slowPath.link(&amp;m_jit);
  
          size_t scratchSize = sizeof(EncodedJSValue) * elementCount;
<span class="line-modified">!         ScratchBuffer* scratchBuffer = vm().scratchBufferForSize(scratchSize);</span>
          m_jit.move(TrustedImmPtr(static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer())), bufferGPR);
          m_jit.move(TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), storageLengthGPR);
          m_jit.storePtr(TrustedImmPtr(scratchSize), MacroAssembler::Address(storageLengthGPR));
  
          storageDone.link(&amp;m_jit);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8903,11 ***</span>
      JITCompiler::JumpList done;
      JITCompiler::Jump slowPath;
      m_jit.emitTypeOf(
          valueRegs, resultGPR,
          [&amp;] (TypeofType type, bool fallsThrough) {
<span class="line-modified">!             m_jit.move(TrustedImmPtr::weakPointer(m_jit.graph(), m_jit.vm()-&gt;smallStrings.typeString(type)), resultGPR);</span>
              if (!fallsThrough)
                  done.append(m_jit.jump());
          },
          [&amp;] (JITCompiler::Jump theSlowPath) {
              slowPath = theSlowPath;
<span class="line-new-header">--- 9112,11 ---</span>
      JITCompiler::JumpList done;
      JITCompiler::Jump slowPath;
      m_jit.emitTypeOf(
          valueRegs, resultGPR,
          [&amp;] (TypeofType type, bool fallsThrough) {
<span class="line-modified">!             m_jit.move(TrustedImmPtr::weakPointer(m_jit.graph(), vm().smallStrings.typeString(type)), resultGPR);</span>
              if (!fallsThrough)
                  done.append(m_jit.jump());
          },
          [&amp;] (JITCompiler::Jump theSlowPath) {
              slowPath = theSlowPath;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8936,11 ***</span>
      } else {
          std::unique_ptr&lt;GPRTemporary&gt; structure;
          GPRReg structureGPR;
  
          if (tempGPR == InvalidGPRReg) {
<span class="line-modified">!             structure = std::make_unique&lt;GPRTemporary&gt;(this);</span>
              structureGPR = structure-&gt;gpr();
          } else
              structureGPR = tempGPR;
  
          m_jit.load32(JITCompiler::Address(cellGPR, JSCell::structureIDOffset()), structureGPR);
<span class="line-new-header">--- 9145,11 ---</span>
      } else {
          std::unique_ptr&lt;GPRTemporary&gt; structure;
          GPRReg structureGPR;
  
          if (tempGPR == InvalidGPRReg) {
<span class="line-modified">!             structure = makeUnique&lt;GPRTemporary&gt;(this);</span>
              structureGPR = structure-&gt;gpr();
          } else
              structureGPR = tempGPR;
  
          m_jit.load32(JITCompiler::Address(cellGPR, JSCell::structureIDOffset()), structureGPR);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 9017,11 ***</span>
      ASSERT(!node-&gt;transition()-&gt;previous-&gt;outOfLineCapacity());
      ASSERT(initialOutOfLineCapacity == node-&gt;transition()-&gt;next-&gt;outOfLineCapacity());
  
      size_t size = initialOutOfLineCapacity * sizeof(JSValue);
  
<span class="line-modified">!     Allocator allocator = m_jit.vm()-&gt;jsValueGigacageAuxiliarySpace.allocatorForNonVirtual(size, AllocatorForMode::AllocatorIfExists);</span>
  
      if (!allocator || node-&gt;transition()-&gt;previous-&gt;couldHaveIndexingHeader()) {
          SpeculateCellOperand base(this, node-&gt;child1());
  
          GPRReg baseGPR = base.gpr();
<span class="line-new-header">--- 9226,11 ---</span>
      ASSERT(!node-&gt;transition()-&gt;previous-&gt;outOfLineCapacity());
      ASSERT(initialOutOfLineCapacity == node-&gt;transition()-&gt;next-&gt;outOfLineCapacity());
  
      size_t size = initialOutOfLineCapacity * sizeof(JSValue);
  
<span class="line-modified">!     Allocator allocator = vm().jsValueGigacageAuxiliarySpace.allocatorForNonVirtual(size, AllocatorForMode::AllocatorIfExists);</span>
  
      if (!allocator || node-&gt;transition()-&gt;previous-&gt;couldHaveIndexingHeader()) {
          SpeculateCellOperand base(this, node-&gt;child1());
  
          GPRReg baseGPR = base.gpr();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 9061,11 ***</span>
  {
      size_t oldSize = node-&gt;transition()-&gt;previous-&gt;outOfLineCapacity() * sizeof(JSValue);
      size_t newSize = oldSize * outOfLineGrowthFactor;
      ASSERT(newSize == node-&gt;transition()-&gt;next-&gt;outOfLineCapacity() * sizeof(JSValue));
  
<span class="line-modified">!     Allocator allocator = m_jit.vm()-&gt;jsValueGigacageAuxiliarySpace.allocatorForNonVirtual(newSize, AllocatorForMode::AllocatorIfExists);</span>
  
      if (!allocator || node-&gt;transition()-&gt;previous-&gt;couldHaveIndexingHeader()) {
          SpeculateCellOperand base(this, node-&gt;child1());
  
          GPRReg baseGPR = base.gpr();
<span class="line-new-header">--- 9270,11 ---</span>
  {
      size_t oldSize = node-&gt;transition()-&gt;previous-&gt;outOfLineCapacity() * sizeof(JSValue);
      size_t newSize = oldSize * outOfLineGrowthFactor;
      ASSERT(newSize == node-&gt;transition()-&gt;next-&gt;outOfLineCapacity() * sizeof(JSValue));
  
<span class="line-modified">!     Allocator allocator = vm().jsValueGigacageAuxiliarySpace.allocatorForNonVirtual(newSize, AllocatorForMode::AllocatorIfExists);</span>
  
      if (!allocator || node-&gt;transition()-&gt;previous-&gt;couldHaveIndexingHeader()) {
          SpeculateCellOperand base(this, node-&gt;child1());
  
          GPRReg baseGPR = base.gpr();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 9116,11 ***</span>
      StorageOperand storage(this, node-&gt;child2());
  
      GPRReg baseGPR = base.gpr();
      GPRReg storageGPR = storage.gpr();
  
<span class="line-modified">!     m_jit.nukeStructureAndStoreButterfly(*m_jit.vm(), storageGPR, baseGPR);</span>
  
      noResult(node);
  }
  
  void SpeculativeJIT::compileGetButterfly(Node* node)
<span class="line-new-header">--- 9325,11 ---</span>
      StorageOperand storage(this, node-&gt;child2());
  
      GPRReg baseGPR = base.gpr();
      GPRReg storageGPR = storage.gpr();
  
<span class="line-modified">!     m_jit.nukeStructureAndStoreButterfly(vm(), storageGPR, baseGPR);</span>
  
      noResult(node);
  }
  
  void SpeculativeJIT::compileGetButterfly(Node* node)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 9211,21 ***</span>
  
      JSValueRegsTemporary result(this);
      JSValueRegs resultRegs = result.regs();
  
      flushRegisters();
<span class="line-modified">!     assertIsTaggedWith(reinterpret_cast&lt;void*&gt;(signature-&gt;unsafeFunction), CFunctionPtrTag);</span>
      unsigned argumentCountIncludingThis = signature-&gt;argumentCount + 1;
      switch (argumentCountIncludingThis) {
      case 1:
<span class="line-modified">!         callOperation(reinterpret_cast&lt;J_JITOperation_EP&gt;(signature-&gt;unsafeFunction), extractResult(resultRegs), regs[0]);</span>
          break;
      case 2:
<span class="line-modified">!         callOperation(reinterpret_cast&lt;J_JITOperation_EPP&gt;(signature-&gt;unsafeFunction), extractResult(resultRegs), regs[0], regs[1]);</span>
          break;
      case 3:
<span class="line-modified">!         callOperation(reinterpret_cast&lt;J_JITOperation_EPPP&gt;(signature-&gt;unsafeFunction), extractResult(resultRegs), regs[0], regs[1], regs[2]);</span>
          break;
      default:
          RELEASE_ASSERT_NOT_REACHED();
          break;
      }
<span class="line-new-header">--- 9420,22 ---</span>
  
      JSValueRegsTemporary result(this);
      JSValueRegs resultRegs = result.regs();
  
      flushRegisters();
<span class="line-modified">! </span>
<span class="line-added">+     auto function = CFunctionPtr(signature-&gt;functionWithoutTypeCheck);</span>
      unsigned argumentCountIncludingThis = signature-&gt;argumentCount + 1;
      switch (argumentCountIncludingThis) {
      case 1:
<span class="line-modified">!         callOperation(reinterpret_cast&lt;J_JITOperation_EP&gt;(function.get()), extractResult(resultRegs), regs[0]);</span>
          break;
      case 2:
<span class="line-modified">!         callOperation(reinterpret_cast&lt;J_JITOperation_EPP&gt;(function.get()), extractResult(resultRegs), regs[0], regs[1]);</span>
          break;
      case 3:
<span class="line-modified">!         callOperation(reinterpret_cast&lt;J_JITOperation_EPPP&gt;(function.get()), extractResult(resultRegs), regs[0], regs[1], regs[2]);</span>
          break;
      default:
          RELEASE_ASSERT_NOT_REACHED();
          break;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 9245,11 ***</span>
          JSValueRegs resultRegs = result.regs();
          GPRReg baseGPR = base.gpr();
  
          flushRegisters();
          m_jit.setupArguments&lt;J_JITOperation_EJI&gt;(CCallHelpers::CellValue(baseGPR), identifierUID(node-&gt;callDOMGetterData()-&gt;identifierNumber));
<span class="line-modified">!         m_jit.storePtr(GPRInfo::callFrameRegister, &amp;m_jit.vm()-&gt;topCallFrame);</span>
          m_jit.emitStoreCodeOrigin(m_currentNode-&gt;origin.semantic);
          m_jit.appendCall(getter.retagged&lt;CFunctionPtrTag&gt;());
          m_jit.setupResults(resultRegs);
  
          m_jit.exceptionCheck();
<span class="line-new-header">--- 9455,11 ---</span>
          JSValueRegs resultRegs = result.regs();
          GPRReg baseGPR = base.gpr();
  
          flushRegisters();
          m_jit.setupArguments&lt;J_JITOperation_EJI&gt;(CCallHelpers::CellValue(baseGPR), identifierUID(node-&gt;callDOMGetterData()-&gt;identifierNumber));
<span class="line-modified">!         m_jit.storePtr(GPRInfo::callFrameRegister, &amp;vm().topCallFrame);</span>
          m_jit.emitStoreCodeOrigin(m_currentNode-&gt;origin.semantic);
          m_jit.appendCall(getter.retagged&lt;CFunctionPtrTag&gt;());
          m_jit.setupResults(resultRegs);
  
          m_jit.exceptionCheck();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 9293,11 ***</span>
  
          GPRReg baseGPR = base.gpr();
          GPRReg otherGPR = other.gpr();
          GPRReg specifiedGPR = specified.gpr();
  
<span class="line-modified">!         m_jit.emitLoadStructure(*m_jit.vm(), baseGPR, otherGPR, specifiedGPR);</span>
          m_jit.loadPtr(CCallHelpers::Address(otherGPR, Structure::classInfoOffset()), otherGPR);
          m_jit.move(CCallHelpers::TrustedImmPtr(node-&gt;classInfo()), specifiedGPR);
  
          CCallHelpers::Label loop = m_jit.label();
          auto done = m_jit.branchPtr(CCallHelpers::Equal, otherGPR, specifiedGPR);
<span class="line-new-header">--- 9503,11 ---</span>
  
          GPRReg baseGPR = base.gpr();
          GPRReg otherGPR = other.gpr();
          GPRReg specifiedGPR = specified.gpr();
  
<span class="line-modified">!         m_jit.emitLoadStructure(vm(), baseGPR, otherGPR, specifiedGPR);</span>
          m_jit.loadPtr(CCallHelpers::Address(otherGPR, Structure::classInfoOffset()), otherGPR);
          m_jit.move(CCallHelpers::TrustedImmPtr(node-&gt;classInfo()), specifiedGPR);
  
          CCallHelpers::Label loop = m_jit.label();
          auto done = m_jit.branchPtr(CCallHelpers::Equal, otherGPR, specifiedGPR);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 9602,11 ***</span>
      m_jit.store32(
          operandGPR,
          JITCompiler::Address(resultGPR, JSWrapperObject::internalValueOffset() + OBJECT_OFFSETOF(JSValue, u.asBits.payload)));
  #endif
  
<span class="line-modified">!     m_jit.mutatorFence(*m_jit.vm());</span>
  
      addSlowPathGenerator(slowPathCall(
          slowPath, this, operationNewStringObject, resultGPR, operandGPR, node-&gt;structure()));
  
      cellResult(resultGPR, node);
<span class="line-new-header">--- 9812,11 ---</span>
      m_jit.store32(
          operandGPR,
          JITCompiler::Address(resultGPR, JSWrapperObject::internalValueOffset() + OBJECT_OFFSETOF(JSValue, u.asBits.payload)));
  #endif
  
<span class="line-modified">!     m_jit.mutatorFence(vm());</span>
  
      addSlowPathGenerator(slowPathCall(
          slowPath, this, operationNewStringObject, resultGPR, operandGPR, node-&gt;structure()));
  
      cellResult(resultGPR, node);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 9669,11 ***</span>
      if (elementSize(typedArrayType) &lt; 8) {
          m_jit.add32(TrustedImm32(7), scratchGPR);
          m_jit.and32(TrustedImm32(~7), scratchGPR);
      }
      m_jit.emitAllocateVariableSized(
<span class="line-modified">!         storageGPR, m_jit.vm()-&gt;primitiveGigacageAuxiliarySpace, scratchGPR, scratchGPR,</span>
          scratchGPR2, slowCases);
  
      MacroAssembler::Jump done = m_jit.branchTest32(MacroAssembler::Zero, sizeGPR);
      m_jit.move(sizeGPR, scratchGPR);
      if (elementSize(typedArrayType) != 4) {
<span class="line-new-header">--- 9879,11 ---</span>
      if (elementSize(typedArrayType) &lt; 8) {
          m_jit.add32(TrustedImm32(7), scratchGPR);
          m_jit.and32(TrustedImm32(~7), scratchGPR);
      }
      m_jit.emitAllocateVariableSized(
<span class="line-modified">!         storageGPR, vm().primitiveGigacageAuxiliarySpace, scratchGPR, scratchGPR,</span>
          scratchGPR2, slowCases);
  
      MacroAssembler::Jump done = m_jit.branchTest32(MacroAssembler::Zero, sizeGPR);
      m_jit.move(sizeGPR, scratchGPR);
      if (elementSize(typedArrayType) != 4) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 9691,10 ***</span>
<span class="line-new-header">--- 9901,15 ---</span>
      m_jit.store32(
          TrustedImm32(0),
          MacroAssembler::BaseIndex(storageGPR, scratchGPR, MacroAssembler::TimesFour));
      m_jit.branchTest32(MacroAssembler::NonZero, scratchGPR).linkTo(loop, &amp;m_jit);
      done.link(&amp;m_jit);
<span class="line-added">+ #if CPU(ARM64E)</span>
<span class="line-added">+     // sizeGPR is still boxed as a number and there is no 32-bit variant of the PAC instructions.</span>
<span class="line-added">+     m_jit.zeroExtend32ToPtr(sizeGPR, scratchGPR);</span>
<span class="line-added">+     m_jit.tagArrayPtr(scratchGPR, storageGPR);</span>
<span class="line-added">+ #endif</span>
  
      auto butterfly = TrustedImmPtr(nullptr);
      emitAllocateJSObject&lt;JSArrayBufferView&gt;(
          resultGPR, TrustedImmPtr(structure), butterfly, scratchGPR, scratchGPR2,
          slowCases);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 9707,11 ***</span>
          MacroAssembler::Address(resultGPR, JSArrayBufferView::offsetOfLength()));
      m_jit.store32(
          TrustedImm32(FastTypedArray),
          MacroAssembler::Address(resultGPR, JSArrayBufferView::offsetOfMode()));
  
<span class="line-modified">!     m_jit.mutatorFence(*m_jit.vm());</span>
  
      addSlowPathGenerator(slowPathCall(
          slowCases, this, operationNewTypedArrayWithSizeForType(typedArrayType),
          resultGPR, structure, sizeGPR, storageGPR));
  
<span class="line-new-header">--- 9922,11 ---</span>
          MacroAssembler::Address(resultGPR, JSArrayBufferView::offsetOfLength()));
      m_jit.store32(
          TrustedImm32(FastTypedArray),
          MacroAssembler::Address(resultGPR, JSArrayBufferView::offsetOfMode()));
  
<span class="line-modified">!     m_jit.mutatorFence(vm());</span>
  
      addSlowPathGenerator(slowPathCall(
          slowCases, this, operationNewTypedArrayWithSizeForType(typedArrayType),
          resultGPR, structure, sizeGPR, storageGPR));
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 9719,11 ***</span>
  }
  
  void SpeculativeJIT::compileNewRegexp(Node* node)
  {
      RegExp* regexp = node-&gt;castOperand&lt;RegExp*&gt;();
<span class="line-removed">-     ASSERT(regexp-&gt;isValid());</span>
  
      GPRTemporary result(this);
      GPRTemporary scratch1(this);
      GPRTemporary scratch2(this);
      JSValueOperand lastIndex(this, node-&gt;child1());
<span class="line-new-header">--- 9934,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 9739,14 ***</span>
      auto butterfly = TrustedImmPtr(nullptr);
      emitAllocateJSObject&lt;RegExpObject&gt;(resultGPR, TrustedImmPtr(structure), butterfly, scratch1GPR, scratch2GPR, slowPath);
  
      m_jit.storePtr(
          TrustedImmPtr(node-&gt;cellOperand()),
<span class="line-modified">!         CCallHelpers::Address(resultGPR, RegExpObject::offsetOfRegExp()));</span>
      m_jit.storeValue(lastIndexRegs, CCallHelpers::Address(resultGPR, RegExpObject::offsetOfLastIndex()));
<span class="line-modified">!     m_jit.store8(TrustedImm32(true), CCallHelpers::Address(resultGPR, RegExpObject::offsetOfLastIndexIsWritable()));</span>
<span class="line-removed">-     m_jit.mutatorFence(*m_jit.vm());</span>
  
      addSlowPathGenerator(slowPathCall(slowPath, this, operationNewRegexpWithLastIndex, resultGPR, regexp, lastIndexRegs));
  
      cellResult(resultGPR, node);
  }
<span class="line-new-header">--- 9953,13 ---</span>
      auto butterfly = TrustedImmPtr(nullptr);
      emitAllocateJSObject&lt;RegExpObject&gt;(resultGPR, TrustedImmPtr(structure), butterfly, scratch1GPR, scratch2GPR, slowPath);
  
      m_jit.storePtr(
          TrustedImmPtr(node-&gt;cellOperand()),
<span class="line-modified">!         CCallHelpers::Address(resultGPR, RegExpObject::offsetOfRegExpAndLastIndexIsNotWritableFlag()));</span>
      m_jit.storeValue(lastIndexRegs, CCallHelpers::Address(resultGPR, RegExpObject::offsetOfLastIndex()));
<span class="line-modified">!     m_jit.mutatorFence(vm());</span>
  
      addSlowPathGenerator(slowPathCall(slowPath, this, operationNewRegexpWithLastIndex, resultGPR, regexp, lastIndexRegs));
  
      cellResult(resultGPR, node);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 10101,11 ***</span>
          m_jit.branchIfRopeStringImpl(storage));
      speculationCheck(
          BadType, JSValueSource::unboxedCell(string), edge, m_jit.branchTest32(
              MacroAssembler::Zero,
              MacroAssembler::Address(storage, StringImpl::flagsOffset()),
<span class="line-modified">!             MacroAssembler::TrustedImm32(StringImpl::flagIsAtomic())));</span>
  
      m_interpreter.filter(edge, SpecStringIdent | ~SpecString);
  }
  
  void SpeculativeJIT::speculateStringIdent(Edge edge, GPRReg string)
<span class="line-new-header">--- 10314,11 ---</span>
          m_jit.branchIfRopeStringImpl(storage));
      speculationCheck(
          BadType, JSValueSource::unboxedCell(string), edge, m_jit.branchTest32(
              MacroAssembler::Zero,
              MacroAssembler::Address(storage, StringImpl::flagsOffset()),
<span class="line-modified">!             MacroAssembler::TrustedImm32(StringImpl::flagIsAtom())));</span>
  
      m_interpreter.filter(edge, SpecStringIdent | ~SpecString);
  }
  
  void SpeculativeJIT::speculateStringIdent(Edge edge, GPRReg string)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 10442,11 ***</span>
          m_jit.branch32(JITCompiler::AboveOrEqual, value, Imm32(table.ctiOffsets.size())),
          data-&gt;fallThrough.block);
      m_jit.move(TrustedImmPtr(table.ctiOffsets.begin()), scratch);
      m_jit.loadPtr(JITCompiler::BaseIndex(scratch, value, JITCompiler::timesPtr()), scratch);
  
<span class="line-modified">!     m_jit.jump(scratch, JSSwitchPtrTag);</span>
      data-&gt;didUseJumpTable = true;
  }
  
  void SpeculativeJIT::emitSwitchImm(Node* node, SwitchData* data)
  {
<span class="line-new-header">--- 10655,11 ---</span>
          m_jit.branch32(JITCompiler::AboveOrEqual, value, Imm32(table.ctiOffsets.size())),
          data-&gt;fallThrough.block);
      m_jit.move(TrustedImmPtr(table.ctiOffsets.begin()), scratch);
      m_jit.loadPtr(JITCompiler::BaseIndex(scratch, value, JITCompiler::timesPtr()), scratch);
  
<span class="line-modified">!     m_jit.farJump(scratch, JSSwitchPtrTag);</span>
      data-&gt;didUseJumpTable = true;
  }
  
  void SpeculativeJIT::emitSwitchImm(Node* node, SwitchData* data)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 10473,11 ***</span>
          addBranch(m_jit.branchIfNotNumber(valueRegs, scratch), data-&gt;fallThrough.block);
          silentSpillAllRegisters(scratch);
          callOperation(operationFindSwitchImmTargetForDouble, scratch, valueRegs, data-&gt;switchTableIndex);
          silentFillAllRegisters();
  
<span class="line-modified">!         m_jit.jump(scratch, JSSwitchPtrTag);</span>
          noResult(node, UseChildrenCalledExplicitly);
          break;
      }
  
      default:
<span class="line-new-header">--- 10686,11 ---</span>
          addBranch(m_jit.branchIfNotNumber(valueRegs, scratch), data-&gt;fallThrough.block);
          silentSpillAllRegisters(scratch);
          callOperation(operationFindSwitchImmTargetForDouble, scratch, valueRegs, data-&gt;switchTableIndex);
          silentFillAllRegisters();
  
<span class="line-modified">!         m_jit.farJump(scratch, JSSwitchPtrTag);</span>
          noResult(node, UseChildrenCalledExplicitly);
          break;
      }
  
      default:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 10730,11 ***</span>
      if (!canDoBinarySwitch || totalLength &gt; Options::maximumBinaryStringSwitchTotalLength()) {
          flushRegisters();
          callOperation(
              operationSwitchString, string, static_cast&lt;size_t&gt;(data-&gt;switchTableIndex), string);
          m_jit.exceptionCheck();
<span class="line-modified">!         m_jit.jump(string, JSSwitchPtrTag);</span>
          return;
      }
  
      GPRTemporary length(this);
      GPRTemporary temp(this);
<span class="line-new-header">--- 10943,11 ---</span>
      if (!canDoBinarySwitch || totalLength &gt; Options::maximumBinaryStringSwitchTotalLength()) {
          flushRegisters();
          callOperation(
              operationSwitchString, string, static_cast&lt;size_t&gt;(data-&gt;switchTableIndex), string);
          m_jit.exceptionCheck();
<span class="line-modified">!         m_jit.farJump(string, JSSwitchPtrTag);</span>
          return;
      }
  
      GPRTemporary length(this);
      GPRTemporary temp(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 10768,11 ***</span>
      slowCases.link(&amp;m_jit);
      silentSpillAllRegisters(string);
      callOperation(operationSwitchString, string, static_cast&lt;size_t&gt;(data-&gt;switchTableIndex), string);
      silentFillAllRegisters();
      m_jit.exceptionCheck();
<span class="line-modified">!     m_jit.jump(string, JSSwitchPtrTag);</span>
  }
  
  void SpeculativeJIT::emitSwitchString(Node* node, SwitchData* data)
  {
      switch (node-&gt;child1().useKind()) {
<span class="line-new-header">--- 10981,11 ---</span>
      slowCases.link(&amp;m_jit);
      silentSpillAllRegisters(string);
      callOperation(operationSwitchString, string, static_cast&lt;size_t&gt;(data-&gt;switchTableIndex), string);
      silentFillAllRegisters();
      m_jit.exceptionCheck();
<span class="line-modified">!     m_jit.farJump(string, JSSwitchPtrTag);</span>
  }
  
  void SpeculativeJIT::emitSwitchString(Node* node, SwitchData* data)
  {
      switch (node-&gt;child1().useKind()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 10884,13 ***</span>
      GPRReg scratch1GPR = scratch1.gpr();
  
      JITCompiler::JumpList ok;
  
      if (isFenced) {
<span class="line-modified">!         ok.append(m_jit.barrierBranch(*m_jit.vm(), baseGPR, scratch1GPR));</span>
  
<span class="line-modified">!         JITCompiler::Jump noFence = m_jit.jumpIfMutatorFenceNotNeeded(*m_jit.vm());</span>
          m_jit.memoryFence();
          ok.append(m_jit.barrierBranchWithoutFence(baseGPR));
          noFence.link(&amp;m_jit);
      } else
          ok.append(m_jit.barrierBranchWithoutFence(baseGPR));
<span class="line-new-header">--- 11097,13 ---</span>
      GPRReg scratch1GPR = scratch1.gpr();
  
      JITCompiler::JumpList ok;
  
      if (isFenced) {
<span class="line-modified">!         ok.append(m_jit.barrierBranch(vm(), baseGPR, scratch1GPR));</span>
  
<span class="line-modified">!         JITCompiler::Jump noFence = m_jit.jumpIfMutatorFenceNotNeeded(vm());</span>
          m_jit.memoryFence();
          ok.append(m_jit.barrierBranchWithoutFence(baseGPR));
          noFence.link(&amp;m_jit);
      } else
          ok.append(m_jit.barrierBranchWithoutFence(baseGPR));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 11009,11 ***</span>
  
      GPRReg scopeGPR = scope.gpr();
      JSValueRegs valueRegs = value.jsValueRegs();
  
      flushRegisters();
<span class="line-modified">!     callOperation(operationPutDynamicVar, NoResult, scopeGPR, valueRegs, identifierUID(node-&gt;identifierNumber()), node-&gt;getPutInfo());</span>
      m_jit.exceptionCheck();
      noResult(node);
  }
  
  void SpeculativeJIT::compileGetClosureVar(Node* node)
<span class="line-new-header">--- 11222,11 ---</span>
  
      GPRReg scopeGPR = scope.gpr();
      JSValueRegs valueRegs = value.jsValueRegs();
  
      flushRegisters();
<span class="line-modified">!     callOperation(m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutDynamicVarStrict : operationPutDynamicVarNonStrict, NoResult, scopeGPR, valueRegs, identifierUID(node-&gt;identifierNumber()), node-&gt;getPutInfo());</span>
      m_jit.exceptionCheck();
      noResult(node);
  }
  
  void SpeculativeJIT::compileGetClosureVar(Node* node)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 11079,13 ***</span>
  
      if (!node-&gt;ignoreLastIndexIsWritable()) {
          speculateRegExpObject(node-&gt;child1(), regExpGPR);
          speculationCheck(
              ExoticObjectMode, JSValueRegs(), nullptr,
<span class="line-modified">!             m_jit.branchTest8(</span>
<span class="line-modified">!                 JITCompiler::Zero,</span>
<span class="line-modified">!                 JITCompiler::Address(regExpGPR, RegExpObject::offsetOfLastIndexIsWritable())));</span>
      }
  
      m_jit.storeValue(valueRegs, JITCompiler::Address(regExpGPR, RegExpObject::offsetOfLastIndex()));
      noResult(node);
  }
<span class="line-new-header">--- 11292,14 ---</span>
  
      if (!node-&gt;ignoreLastIndexIsWritable()) {
          speculateRegExpObject(node-&gt;child1(), regExpGPR);
          speculationCheck(
              ExoticObjectMode, JSValueRegs(), nullptr,
<span class="line-modified">!             m_jit.branchTestPtr(</span>
<span class="line-modified">!                 JITCompiler::NonZero,</span>
<span class="line-modified">!                 JITCompiler::Address(regExpGPR, RegExpObject::offsetOfRegExpAndLastIndexIsNotWritableFlag()),</span>
<span class="line-added">+                 JITCompiler::TrustedImm32(RegExpObject::lastIndexIsNotWritableFlag)));</span>
      }
  
      m_jit.storeValue(valueRegs, JITCompiler::Address(regExpGPR, RegExpObject::offsetOfLastIndex()));
      noResult(node);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 11216,11 ***</span>
          m_jit.incrementSuperSamplerCount();
  
      if (node-&gt;child1().useKind() == StringUse
          &amp;&amp; node-&gt;child2().useKind() == RegExpObjectUse
          &amp;&amp; node-&gt;child3().useKind() == StringUse) {
<span class="line-modified">!         if (JSString* replace = node-&gt;child3()-&gt;dynamicCastConstant&lt;JSString*&gt;(*m_jit.vm())) {</span>
              if (!replace-&gt;length()) {
                  SpeculateCellOperand string(this, node-&gt;child1());
                  SpeculateCellOperand regExp(this, node-&gt;child2());
                  GPRReg stringGPR = string.gpr();
                  GPRReg regExpGPR = regExp.gpr();
<span class="line-new-header">--- 11430,11 ---</span>
          m_jit.incrementSuperSamplerCount();
  
      if (node-&gt;child1().useKind() == StringUse
          &amp;&amp; node-&gt;child2().useKind() == RegExpObjectUse
          &amp;&amp; node-&gt;child3().useKind() == StringUse) {
<span class="line-modified">!         if (JSString* replace = node-&gt;child3()-&gt;dynamicCastConstant&lt;JSString*&gt;(vm())) {</span>
              if (!replace-&gt;length()) {
                  SpeculateCellOperand string(this, node-&gt;child1());
                  SpeculateCellOperand regExp(this, node-&gt;child2());
                  GPRReg stringGPR = string.gpr();
                  GPRReg regExpGPR = regExp.gpr();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 11350,11 ***</span>
  }
  
  void SpeculativeJIT::compileMaterializeNewObject(Node* node)
  {
      RegisteredStructure structure = node-&gt;structureSet().at(0);
<span class="line-modified">!     ASSERT(m_jit.graph().varArgChild(node, 0)-&gt;dynamicCastConstant&lt;Structure*&gt;(*m_jit.vm()) == structure.get());</span>
  
      ObjectMaterializationData&amp; data = node-&gt;objectMaterializationData();
  
      IndexingType indexingType = structure-&gt;indexingType();
      bool hasIndexingHeader = hasIndexedProperties(indexingType);
<span class="line-new-header">--- 11564,11 ---</span>
  }
  
  void SpeculativeJIT::compileMaterializeNewObject(Node* node)
  {
      RegisteredStructure structure = node-&gt;structureSet().at(0);
<span class="line-modified">!     ASSERT(m_jit.graph().varArgChild(node, 0)-&gt;dynamicCastConstant&lt;Structure*&gt;(vm()) == structure.get());</span>
  
      ObjectMaterializationData&amp; data = node-&gt;objectMaterializationData();
  
      IndexingType indexingType = structure-&gt;indexingType();
      bool hasIndexingHeader = hasIndexedProperties(indexingType);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 11638,11 ***</span>
      MacroAssembler::Jump didNotOverflow = m_jit.branch32(MacroAssembler::AboveOrEqual, scratch2, sizeGPR);
      m_jit.abortWithReason(UncheckedOverflow);
      didNotOverflow.link(&amp;m_jit);
  #endif
      m_jit.emitAllocateVariableSized(
<span class="line-modified">!         storageResultGPR, m_jit.vm()-&gt;jsValueGigacageAuxiliarySpace, scratch2, scratch1, scratch3, slowCases);</span>
      m_jit.addPtr(TrustedImm32(sizeof(IndexingHeader)), storageResultGPR);
  
      m_jit.store32(sizeGPR, MacroAssembler::Address(storageResultGPR, Butterfly::offsetOfPublicLength()));
      m_jit.store32(sizeGPR, MacroAssembler::Address(storageResultGPR, Butterfly::offsetOfVectorLength()));
  }
<span class="line-new-header">--- 11852,11 ---</span>
      MacroAssembler::Jump didNotOverflow = m_jit.branch32(MacroAssembler::AboveOrEqual, scratch2, sizeGPR);
      m_jit.abortWithReason(UncheckedOverflow);
      didNotOverflow.link(&amp;m_jit);
  #endif
      m_jit.emitAllocateVariableSized(
<span class="line-modified">!         storageResultGPR, vm().jsValueGigacageAuxiliarySpace, scratch2, scratch1, scratch3, slowCases);</span>
      m_jit.addPtr(TrustedImm32(sizeof(IndexingHeader)), storageResultGPR);
  
      m_jit.store32(sizeGPR, MacroAssembler::Address(storageResultGPR, Butterfly::offsetOfPublicLength()));
      m_jit.store32(sizeGPR, MacroAssembler::Address(storageResultGPR, Butterfly::offsetOfVectorLength()));
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 11661,32 ***</span>
      GPRReg scratchGPR = scratch.gpr();
      FPRReg doubleValueFPR = doubleValue.fpr();
      FPRReg tempFPR = temp.fpr();
  
      CCallHelpers::JumpList passThroughCases;
  
      passThroughCases.append(m_jit.branchIfNotNumber(keyRegs, scratchGPR));
      passThroughCases.append(m_jit.branchIfInt32(keyRegs));
  
  #if USE(JSVALUE64)
      m_jit.unboxDoubleWithoutAssertions(keyRegs.gpr(), scratchGPR, doubleValueFPR);
  #else
      unboxDouble(keyRegs.tagGPR(), keyRegs.payloadGPR(), doubleValueFPR, tempFPR);
  #endif
<span class="line-modified">!     passThroughCases.append(m_jit.branchIfNaN(doubleValueFPR));</span>
  
      m_jit.truncateDoubleToInt32(doubleValueFPR, scratchGPR);
      m_jit.convertInt32ToDouble(scratchGPR, tempFPR);
      passThroughCases.append(m_jit.branchDouble(JITCompiler::DoubleNotEqual, doubleValueFPR, tempFPR));
  
      m_jit.boxInt32(scratchGPR, resultRegs);
<span class="line-modified">!     auto done = m_jit.jump();</span>
  
      passThroughCases.link(&amp;m_jit);
      m_jit.moveValueRegs(keyRegs, resultRegs);
  
<span class="line-modified">!     done.link(&amp;m_jit);</span>
      jsValueResult(resultRegs, node);
  }
  
  void SpeculativeJIT::compileGetMapBucketHead(Node* node)
  {
<span class="line-new-header">--- 11875,36 ---</span>
      GPRReg scratchGPR = scratch.gpr();
      FPRReg doubleValueFPR = doubleValue.fpr();
      FPRReg tempFPR = temp.fpr();
  
      CCallHelpers::JumpList passThroughCases;
<span class="line-added">+     CCallHelpers::JumpList doneCases;</span>
  
      passThroughCases.append(m_jit.branchIfNotNumber(keyRegs, scratchGPR));
      passThroughCases.append(m_jit.branchIfInt32(keyRegs));
  
  #if USE(JSVALUE64)
      m_jit.unboxDoubleWithoutAssertions(keyRegs.gpr(), scratchGPR, doubleValueFPR);
  #else
      unboxDouble(keyRegs.tagGPR(), keyRegs.payloadGPR(), doubleValueFPR, tempFPR);
  #endif
<span class="line-modified">!     auto notNaN = m_jit.branchIfNotNaN(doubleValueFPR);</span>
<span class="line-added">+     m_jit.moveTrustedValue(jsNaN(), resultRegs);</span>
<span class="line-added">+     doneCases.append(m_jit.jump());</span>
  
<span class="line-added">+     notNaN.link(&amp;m_jit);</span>
      m_jit.truncateDoubleToInt32(doubleValueFPR, scratchGPR);
      m_jit.convertInt32ToDouble(scratchGPR, tempFPR);
      passThroughCases.append(m_jit.branchDouble(JITCompiler::DoubleNotEqual, doubleValueFPR, tempFPR));
  
      m_jit.boxInt32(scratchGPR, resultRegs);
<span class="line-modified">!     doneCases.append(m_jit.jump());</span>
  
      passThroughCases.link(&amp;m_jit);
      m_jit.moveValueRegs(keyRegs, resultRegs);
  
<span class="line-modified">!     doneCases.link(&amp;m_jit);</span>
      jsValueResult(resultRegs, node);
  }
  
  void SpeculativeJIT::compileGetMapBucketHead(Node* node)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 11731,14 ***</span>
      m_jit.jump().linkTo(loop, &amp;m_jit);
  
      notBucket.link(&amp;m_jit);
      JSCell* sentinel = nullptr;
      if (node-&gt;bucketOwnerType() == BucketOwnerType::Map)
<span class="line-modified">!         sentinel = m_jit.vm()-&gt;sentinelMapBucket();</span>
      else {
          ASSERT(node-&gt;bucketOwnerType() == BucketOwnerType::Set);
<span class="line-modified">!         sentinel = m_jit.vm()-&gt;sentinelSetBucket();</span>
      }
      m_jit.move(TrustedImmPtr::weakPointer(m_jit.graph(), sentinel), resultGPR);
      done.link(&amp;m_jit);
  
      cellResult(resultGPR, node);
<span class="line-new-header">--- 11949,14 ---</span>
      m_jit.jump().linkTo(loop, &amp;m_jit);
  
      notBucket.link(&amp;m_jit);
      JSCell* sentinel = nullptr;
      if (node-&gt;bucketOwnerType() == BucketOwnerType::Map)
<span class="line-modified">!         sentinel = vm().sentinelMapBucket();</span>
      else {
          ASSERT(node-&gt;bucketOwnerType() == BucketOwnerType::Set);
<span class="line-modified">!         sentinel = vm().sentinelSetBucket();</span>
      }
      m_jit.move(TrustedImmPtr::weakPointer(m_jit.graph(), sentinel), resultGPR);
      done.link(&amp;m_jit);
  
      cellResult(resultGPR, node);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 12277,11 ***</span>
              MacroAssembler::Address(thisValueRegs.payloadGPR(), JSCell::typeInfoFlagsOffset()),
              MacroAssembler::TrustedImm32(OverridesToThis)));
      m_jit.moveValueRegs(thisValueRegs, tempRegs);
  
      J_JITOperation_EJ function;
<span class="line-modified">!     if (m_jit.graph().executableFor(node-&gt;origin.semantic)-&gt;isStrictMode())</span>
          function = operationToThisStrict;
      else
          function = operationToThis;
      addSlowPathGenerator(slowPathCall(slowCases, this, function, tempRegs, thisValueRegs));
  
<span class="line-new-header">--- 12495,11 ---</span>
              MacroAssembler::Address(thisValueRegs.payloadGPR(), JSCell::typeInfoFlagsOffset()),
              MacroAssembler::TrustedImm32(OverridesToThis)));
      m_jit.moveValueRegs(thisValueRegs, tempRegs);
  
      J_JITOperation_EJ function;
<span class="line-modified">!     if (m_jit.isStrictModeFor(node-&gt;origin.semantic))</span>
          function = operationToThisStrict;
      else
          function = operationToThis;
      addSlowPathGenerator(slowPathCall(slowCases, this, function, tempRegs, thisValueRegs));
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 12308,15 ***</span>
              GPRReg resultGPR = result.gpr();
  
              speculateObject(node-&gt;child1(), objectGPR);
  
              CCallHelpers::JumpList slowCases;
<span class="line-modified">!             m_jit.emitLoadStructure(*m_jit.vm(), objectGPR, structureGPR, scratchGPR);</span>
              m_jit.loadPtr(CCallHelpers::Address(structureGPR, Structure::previousOrRareDataOffset()), scratchGPR);
  
              slowCases.append(m_jit.branchTestPtr(CCallHelpers::Zero, scratchGPR));
<span class="line-modified">!             slowCases.append(m_jit.branch32(CCallHelpers::Equal, CCallHelpers::Address(scratchGPR, JSCell::structureIDOffset()), TrustedImm32(bitwise_cast&lt;int32_t&gt;(m_jit.vm()-&gt;structureStructure-&gt;structureID()))));</span>
  
              m_jit.loadPtr(CCallHelpers::Address(scratchGPR, StructureRareData::offsetOfCachedOwnKeys()), scratchGPR);
  
              ASSERT(bitwise_cast&lt;uintptr_t&gt;(StructureRareData::cachedOwnKeysSentinel()) == 1);
              slowCases.append(m_jit.branchPtr(CCallHelpers::BelowOrEqual, scratchGPR, TrustedImmPtr(bitwise_cast&lt;void*&gt;(StructureRareData::cachedOwnKeysSentinel()))));
<span class="line-new-header">--- 12526,15 ---</span>
              GPRReg resultGPR = result.gpr();
  
              speculateObject(node-&gt;child1(), objectGPR);
  
              CCallHelpers::JumpList slowCases;
<span class="line-modified">!             m_jit.emitLoadStructure(vm(), objectGPR, structureGPR, scratchGPR);</span>
              m_jit.loadPtr(CCallHelpers::Address(structureGPR, Structure::previousOrRareDataOffset()), scratchGPR);
  
              slowCases.append(m_jit.branchTestPtr(CCallHelpers::Zero, scratchGPR));
<span class="line-modified">!             slowCases.append(m_jit.branch32(CCallHelpers::Equal, CCallHelpers::Address(scratchGPR, JSCell::structureIDOffset()), TrustedImm32(bitwise_cast&lt;int32_t&gt;(vm().structureStructure-&gt;structureID()))));</span>
  
              m_jit.loadPtr(CCallHelpers::Address(scratchGPR, StructureRareData::offsetOfCachedOwnKeys()), scratchGPR);
  
              ASSERT(bitwise_cast&lt;uintptr_t&gt;(StructureRareData::cachedOwnKeysSentinel()) == 1);
              slowCases.append(m_jit.branchPtr(CCallHelpers::BelowOrEqual, scratchGPR, TrustedImmPtr(bitwise_cast&lt;void*&gt;(StructureRareData::cachedOwnKeysSentinel()))));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 12444,20 ***</span>
      MacroAssembler::JumpList slowPath;
  
      slowPath.append(m_jit.branchIfNotFunction(calleeGPR));
      m_jit.loadPtr(JITCompiler::Address(calleeGPR, JSFunction::offsetOfRareData()), rareDataGPR);
      slowPath.append(m_jit.branchTestPtr(MacroAssembler::Zero, rareDataGPR));
<span class="line-modified">!     m_jit.loadPtr(JITCompiler::Address(rareDataGPR, FunctionRareData::offsetOfObjectAllocationProfile() + ObjectAllocationProfile::offsetOfAllocator()), allocatorGPR);</span>
<span class="line-modified">!     m_jit.loadPtr(JITCompiler::Address(rareDataGPR, FunctionRareData::offsetOfObjectAllocationProfile() + ObjectAllocationProfile::offsetOfStructure()), structureGPR);</span>
  
      auto butterfly = TrustedImmPtr(nullptr);
      emitAllocateJSObject(resultGPR, JITAllocator::variable(), allocatorGPR, structureGPR, butterfly, scratchGPR, slowPath);
  
<span class="line-modified">!     m_jit.loadPtr(JITCompiler::Address(calleeGPR, JSFunction::offsetOfRareData()), rareDataGPR);</span>
<span class="line-removed">-     m_jit.load32(JITCompiler::Address(rareDataGPR, FunctionRareData::offsetOfObjectAllocationProfile() + ObjectAllocationProfile::offsetOfInlineCapacity()), inlineCapacityGPR);</span>
      m_jit.emitInitializeInlineStorage(resultGPR, inlineCapacityGPR);
<span class="line-modified">!     m_jit.mutatorFence(*m_jit.vm());</span>
  
      addSlowPathGenerator(slowPathCall(slowPath, this, operationCreateThis, resultGPR, calleeGPR, node-&gt;inlineCapacity()));
  
      cellResult(resultGPR, node);
  }
<span class="line-new-header">--- 12662,19 ---</span>
      MacroAssembler::JumpList slowPath;
  
      slowPath.append(m_jit.branchIfNotFunction(calleeGPR));
      m_jit.loadPtr(JITCompiler::Address(calleeGPR, JSFunction::offsetOfRareData()), rareDataGPR);
      slowPath.append(m_jit.branchTestPtr(MacroAssembler::Zero, rareDataGPR));
<span class="line-modified">!     m_jit.loadPtr(JITCompiler::Address(rareDataGPR, FunctionRareData::offsetOfObjectAllocationProfile() + ObjectAllocationProfileWithPrototype::offsetOfAllocator()), allocatorGPR);</span>
<span class="line-modified">!     m_jit.loadPtr(JITCompiler::Address(rareDataGPR, FunctionRareData::offsetOfObjectAllocationProfile() + ObjectAllocationProfileWithPrototype::offsetOfStructure()), structureGPR);</span>
  
      auto butterfly = TrustedImmPtr(nullptr);
      emitAllocateJSObject(resultGPR, JITAllocator::variable(), allocatorGPR, structureGPR, butterfly, scratchGPR, slowPath);
  
<span class="line-modified">!     m_jit.load8(JITCompiler::Address(structureGPR, Structure::inlineCapacityOffset()), inlineCapacityGPR);</span>
      m_jit.emitInitializeInlineStorage(resultGPR, inlineCapacityGPR);
<span class="line-modified">!     m_jit.mutatorFence(vm());</span>
  
      addSlowPathGenerator(slowPathCall(slowPath, this, operationCreateThis, resultGPR, calleeGPR, node-&gt;inlineCapacity()));
  
      cellResult(resultGPR, node);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 12474,18 ***</span>
  
      MacroAssembler::JumpList slowPath;
  
      RegisteredStructure structure = node-&gt;structure();
      size_t allocationSize = JSFinalObject::allocationSize(structure-&gt;inlineCapacity());
<span class="line-modified">!     Allocator allocatorValue = allocatorForNonVirtualConcurrently&lt;JSFinalObject&gt;(*m_jit.vm(), allocationSize, AllocatorForMode::AllocatorIfExists);</span>
      if (!allocatorValue)
          slowPath.append(m_jit.jump());
      else {
          auto butterfly = TrustedImmPtr(nullptr);
          emitAllocateJSObject(resultGPR, JITAllocator::constant(allocatorValue), allocatorGPR, TrustedImmPtr(structure), butterfly, scratchGPR, slowPath);
          m_jit.emitInitializeInlineStorage(resultGPR, structure-&gt;inlineCapacity());
<span class="line-modified">!         m_jit.mutatorFence(*m_jit.vm());</span>
      }
  
      addSlowPathGenerator(slowPathCall(slowPath, this, operationNewObject, resultGPR, structure));
  
      cellResult(resultGPR, node);
<span class="line-new-header">--- 12691,18 ---</span>
  
      MacroAssembler::JumpList slowPath;
  
      RegisteredStructure structure = node-&gt;structure();
      size_t allocationSize = JSFinalObject::allocationSize(structure-&gt;inlineCapacity());
<span class="line-modified">!     Allocator allocatorValue = allocatorForNonVirtualConcurrently&lt;JSFinalObject&gt;(vm(), allocationSize, AllocatorForMode::AllocatorIfExists);</span>
      if (!allocatorValue)
          slowPath.append(m_jit.jump());
      else {
          auto butterfly = TrustedImmPtr(nullptr);
          emitAllocateJSObject(resultGPR, JITAllocator::constant(allocatorValue), allocatorGPR, TrustedImmPtr(structure), butterfly, scratchGPR, slowPath);
          m_jit.emitInitializeInlineStorage(resultGPR, structure-&gt;inlineCapacity());
<span class="line-modified">!         m_jit.mutatorFence(vm());</span>
      }
  
      addSlowPathGenerator(slowPathCall(slowPath, this, operationNewObject, resultGPR, structure));
  
      cellResult(resultGPR, node);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 12524,11 ***</span>
      GPRTemporary scratch2(this);
      GPRReg scratch2Reg = scratch2.gpr();
      GPRTemporary shadowPacket(this);
      GPRReg shadowPacketReg = shadowPacket.gpr();
  
<span class="line-modified">!     m_jit.ensureShadowChickenPacket(*m_jit.vm(), shadowPacketReg, scratch1Reg, scratch2Reg);</span>
  
      SpeculateCellOperand scope(this, node-&gt;child1());
      GPRReg scopeReg = scope.gpr();
  
      m_jit.logShadowChickenProloguePacket(shadowPacketReg, scratch1Reg, scopeReg);
<span class="line-new-header">--- 12741,11 ---</span>
      GPRTemporary scratch2(this);
      GPRReg scratch2Reg = scratch2.gpr();
      GPRTemporary shadowPacket(this);
      GPRReg shadowPacketReg = shadowPacket.gpr();
  
<span class="line-modified">!     m_jit.ensureShadowChickenPacket(vm(), shadowPacketReg, scratch1Reg, scratch2Reg);</span>
  
      SpeculateCellOperand scope(this, node-&gt;child1());
      GPRReg scopeReg = scope.gpr();
  
      m_jit.logShadowChickenProloguePacket(shadowPacketReg, scratch1Reg, scopeReg);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 12546,11 ***</span>
      GPRTemporary scratch2(this);
      GPRReg scratch2Reg = scratch2.gpr();
      GPRTemporary shadowPacket(this);
      GPRReg shadowPacketReg = shadowPacket.gpr();
  
<span class="line-modified">!     m_jit.ensureShadowChickenPacket(*m_jit.vm(), shadowPacketReg, scratch1Reg, scratch2Reg);</span>
  
      JSValueOperand thisValue(this, node-&gt;child1());
      JSValueRegs thisRegs = thisValue.jsValueRegs();
      SpeculateCellOperand scope(this, node-&gt;child2());
      GPRReg scopeReg = scope.gpr();
<span class="line-new-header">--- 12763,11 ---</span>
      GPRTemporary scratch2(this);
      GPRReg scratch2Reg = scratch2.gpr();
      GPRTemporary shadowPacket(this);
      GPRReg shadowPacketReg = shadowPacket.gpr();
  
<span class="line-modified">!     m_jit.ensureShadowChickenPacket(vm(), shadowPacketReg, scratch1Reg, scratch2Reg);</span>
  
      JSValueOperand thisValue(this, node-&gt;child1());
      JSValueRegs thisRegs = thisValue.jsValueRegs();
      SpeculateCellOperand scope(this, node-&gt;child2());
      GPRReg scopeReg = scope.gpr();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 12766,11 ***</span>
          default:
              RELEASE_ASSERT_NOT_REACHED();
              break;
          }
  
<span class="line-modified">!         m_jit.emitLoadStructure(*m_jit.vm(), objectGPR, tempGPR, temp2GPR);</span>
  
          AbstractValue&amp; value = m_state.forNode(node-&gt;child1());
          if ((value.m_type &amp;&amp; !(value.m_type &amp; ~SpecObject)) &amp;&amp; value.m_structure.isFinite()) {
              bool hasPolyProto = false;
              bool hasMonoProto = false;
<span class="line-new-header">--- 12983,11 ---</span>
          default:
              RELEASE_ASSERT_NOT_REACHED();
              break;
          }
  
<span class="line-modified">!         m_jit.emitLoadStructure(vm(), objectGPR, tempGPR, temp2GPR);</span>
  
          AbstractValue&amp; value = m_state.forNode(node-&gt;child1());
          if ((value.m_type &amp;&amp; !(value.m_type &amp; ~SpecObject)) &amp;&amp; value.m_structure.isFinite()) {
              bool hasPolyProto = false;
              bool hasMonoProto = false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 12967,13 ***</span>
  
      RegisteredStructure structure = m_jit.graph().registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(indexingType));
  
      emitAllocateJSObject&lt;JSArray&gt;(resultGPR, TrustedImmPtr(structure), storageGPR, scratchGPR, scratch2GPR, slowCases);
  
<span class="line-modified">!     m_jit.mutatorFence(*m_jit.vm());</span>
  
<span class="line-modified">!     addSlowPathGenerator(std::make_unique&lt;CallArrayAllocatorWithVariableSizeSlowPathGenerator&gt;(</span>
          slowCases, this, operationNewArrayWithSize, resultGPR,
          structure,
          shouldConvertLargeSizeToArrayStorage ? m_jit.graph().registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithArrayStorage)) : structure,
          sizeGPR, storageGPR));
  }
<span class="line-new-header">--- 13184,13 ---</span>
  
      RegisteredStructure structure = m_jit.graph().registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(indexingType));
  
      emitAllocateJSObject&lt;JSArray&gt;(resultGPR, TrustedImmPtr(structure), storageGPR, scratchGPR, scratch2GPR, slowCases);
  
<span class="line-modified">!     m_jit.mutatorFence(vm());</span>
  
<span class="line-modified">!     addSlowPathGenerator(makeUnique&lt;CallArrayAllocatorWithVariableSizeSlowPathGenerator&gt;(</span>
          slowCases, this, operationNewArrayWithSize, resultGPR,
          structure,
          shouldConvertLargeSizeToArrayStorage ? m_jit.graph().registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithArrayStorage)) : structure,
          sizeGPR, storageGPR));
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 13071,26 ***</span>
  
  void SpeculativeJIT::compileGetDirectPname(Node* node)
  {
      Edge&amp; baseEdge = m_jit.graph().varArgChild(node, 0);
      Edge&amp; propertyEdge = m_jit.graph().varArgChild(node, 1);
  
      SpeculateCellOperand base(this, baseEdge);
      SpeculateCellOperand property(this, propertyEdge);
      GPRReg baseGPR = base.gpr();
      GPRReg propertyGPR = property.gpr();
  
  #if CPU(X86)
      // Not enough registers on X86 for this code, so always use the slow path.
      flushRegisters();
      JSValueRegsFlushedCallResult result(this);
      JSValueRegs resultRegs = result.regs();
      callOperation(operationGetByValCell, resultRegs, baseGPR, CCallHelpers::CellValue(propertyGPR));
      m_jit.exceptionCheck();
      jsValueResult(resultRegs, node);
  #else
<span class="line-removed">-     Edge&amp; indexEdge = m_jit.graph().varArgChild(node, 2);</span>
      Edge&amp; enumeratorEdge = m_jit.graph().varArgChild(node, 3);
      SpeculateStrictInt32Operand index(this, indexEdge);
      SpeculateCellOperand enumerator(this, enumeratorEdge);
      GPRTemporary scratch(this);
      JSValueRegsTemporary result(this);
<span class="line-new-header">--- 13288,27 ---</span>
  
  void SpeculativeJIT::compileGetDirectPname(Node* node)
  {
      Edge&amp; baseEdge = m_jit.graph().varArgChild(node, 0);
      Edge&amp; propertyEdge = m_jit.graph().varArgChild(node, 1);
<span class="line-added">+     Edge&amp; indexEdge = m_jit.graph().varArgChild(node, 2);</span>
  
      SpeculateCellOperand base(this, baseEdge);
      SpeculateCellOperand property(this, propertyEdge);
      GPRReg baseGPR = base.gpr();
      GPRReg propertyGPR = property.gpr();
  
  #if CPU(X86)
      // Not enough registers on X86 for this code, so always use the slow path.
<span class="line-added">+     speculate(node, indexEdge);</span>
      flushRegisters();
      JSValueRegsFlushedCallResult result(this);
      JSValueRegs resultRegs = result.regs();
      callOperation(operationGetByValCell, resultRegs, baseGPR, CCallHelpers::CellValue(propertyGPR));
      m_jit.exceptionCheck();
      jsValueResult(resultRegs, node);
  #else
      Edge&amp; enumeratorEdge = m_jit.graph().varArgChild(node, 3);
      SpeculateStrictInt32Operand index(this, indexEdge);
      SpeculateCellOperand enumerator(this, enumeratorEdge);
      GPRTemporary scratch(this);
      JSValueRegsTemporary result(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 13193,11 ***</span>
          jumpToEnd.append(m_jit.branchIfString(valueRegs.payloadGPR()));
          isNotCell.link(&amp;m_jit);
      }
  
      // Load the TypeProfilerLog into Scratch2.
<span class="line-modified">!     TypeProfilerLog* cachedTypeProfilerLog = m_jit.vm()-&gt;typeProfilerLog();</span>
      m_jit.move(TrustedImmPtr(cachedTypeProfilerLog), scratch2GPR);
  
      // Load the next LogEntry into Scratch1.
      m_jit.loadPtr(MacroAssembler::Address(scratch2GPR, TypeProfilerLog::currentLogEntryOffset()), scratch1GPR);
  
<span class="line-new-header">--- 13411,11 ---</span>
          jumpToEnd.append(m_jit.branchIfString(valueRegs.payloadGPR()));
          isNotCell.link(&amp;m_jit);
      }
  
      // Load the TypeProfilerLog into Scratch2.
<span class="line-modified">!     TypeProfilerLog* cachedTypeProfilerLog = vm().typeProfilerLog();</span>
      m_jit.move(TrustedImmPtr(cachedTypeProfilerLog), scratch2GPR);
  
      // Load the next LogEntry into Scratch1.
      m_jit.loadPtr(MacroAssembler::Address(scratch2GPR, TypeProfilerLog::currentLogEntryOffset()), scratch1GPR);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 13443,50 ***</span>
      GPRReg allocatorGPR = allocator.gpr();
      GPRReg scratchGPR = scratch.gpr();
      GPRReg scratch2GPR = scratch2.gpr();
  
      CCallHelpers::JumpList slowPath;
<span class="line-modified">!     Allocator allocatorValue = allocatorForNonVirtualConcurrently&lt;JSRopeString&gt;(*m_jit.vm(), sizeof(JSRopeString), AllocatorForMode::AllocatorIfExists);</span>
<span class="line-modified">!     emitAllocateJSCell(resultGPR, JITAllocator::constant(allocatorValue), allocatorGPR, TrustedImmPtr(m_jit.graph().registerStructure(m_jit.vm()-&gt;stringStructure.get())), scratchGPR, slowPath);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     m_jit.orPtr(TrustedImm32(JSString::isRopeInPointer), opGPRs[0], allocatorGPR);</span>
<span class="line-removed">-     m_jit.storePtr(allocatorGPR, CCallHelpers::Address(resultGPR, JSRopeString::offsetOfFiber0()));</span>
  
<span class="line-modified">!     m_jit.move(opGPRs[1], scratchGPR);</span>
<span class="line-modified">!     m_jit.store32(scratchGPR, CCallHelpers::Address(resultGPR, JSRopeString::offsetOfFiber1Lower()));</span>
<span class="line-removed">-     m_jit.rshiftPtr(TrustedImm32(32), scratchGPR);</span>
<span class="line-removed">-     m_jit.store16(scratchGPR, CCallHelpers::Address(resultGPR, JSRopeString::offsetOfFiber1Upper()));</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (numOpGPRs == 3) {</span>
<span class="line-removed">-         m_jit.move(opGPRs[2], scratchGPR);</span>
<span class="line-removed">-         m_jit.store32(scratchGPR, CCallHelpers::Address(resultGPR, JSRopeString::offsetOfFiber2Lower()));</span>
<span class="line-removed">-         m_jit.rshiftPtr(TrustedImm32(32), scratchGPR);</span>
<span class="line-removed">-         m_jit.store16(scratchGPR, CCallHelpers::Address(resultGPR, JSRopeString::offsetOfFiber2Upper()));</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-         m_jit.storeZero32(CCallHelpers::Address(resultGPR, JSRopeString::offsetOfFiber2Lower()));</span>
<span class="line-removed">-         m_jit.storeZero16(CCallHelpers::Address(resultGPR, JSRopeString::offsetOfFiber2Upper()));</span>
<span class="line-removed">-     }</span>
  
      {
<span class="line-modified">!         if (JSString* string = edges[0]-&gt;dynamicCastConstant&lt;JSString*&gt;(*m_jit.vm())) {</span>
              m_jit.move(TrustedImm32(string-&gt;is8Bit() ? StringImpl::flagIs8Bit() : 0), scratchGPR);
              m_jit.move(TrustedImm32(string-&gt;length()), allocatorGPR);
          } else {
<span class="line-modified">!             bool canBeRope = !m_state.forNode(edges[0]).isType(SpecStringIdent);</span>
              m_jit.loadPtr(CCallHelpers::Address(opGPRs[0], JSString::offsetOfValue()), scratch2GPR);
              CCallHelpers::Jump isRope;
<span class="line-modified">!             if (canBeRope)</span>
                  isRope = m_jit.branchIfRopeStringImpl(scratch2GPR);
  
              m_jit.load32(CCallHelpers::Address(scratch2GPR, StringImpl::flagsOffset()), scratchGPR);
              m_jit.load32(CCallHelpers::Address(scratch2GPR, StringImpl::lengthMemoryOffset()), allocatorGPR);
  
<span class="line-modified">!             if (canBeRope) {</span>
                  auto done = m_jit.jump();
  
                  isRope.link(&amp;m_jit);
<span class="line-modified">!                 m_jit.load16(CCallHelpers::Address(opGPRs[0], JSRopeString::offsetOfFlags()), scratchGPR);</span>
                  m_jit.load32(CCallHelpers::Address(opGPRs[0], JSRopeString::offsetOfLength()), allocatorGPR);
                  done.link(&amp;m_jit);
              }
          }
  
<span class="line-new-header">--- 13661,35 ---</span>
      GPRReg allocatorGPR = allocator.gpr();
      GPRReg scratchGPR = scratch.gpr();
      GPRReg scratch2GPR = scratch2.gpr();
  
      CCallHelpers::JumpList slowPath;
<span class="line-modified">!     Allocator allocatorValue = allocatorForNonVirtualConcurrently&lt;JSRopeString&gt;(vm(), sizeof(JSRopeString), AllocatorForMode::AllocatorIfExists);</span>
<span class="line-modified">!     emitAllocateJSCell(resultGPR, JITAllocator::constant(allocatorValue), allocatorGPR, TrustedImmPtr(m_jit.graph().registerStructure(vm().stringStructure.get())), scratchGPR, slowPath);</span>
  
<span class="line-modified">!     // This puts nullptr for the first fiber. It makes visitChildren safe even if this JSRopeString is discarded due to the speculation failure in the following path.</span>
<span class="line-modified">!     m_jit.storePtr(TrustedImmPtr(JSString::isRopeInPointer), CCallHelpers::Address(resultGPR, JSRopeString::offsetOfFiber0()));</span>
  
      {
<span class="line-modified">!         if (JSString* string = edges[0]-&gt;dynamicCastConstant&lt;JSString*&gt;(vm())) {</span>
              m_jit.move(TrustedImm32(string-&gt;is8Bit() ? StringImpl::flagIs8Bit() : 0), scratchGPR);
              m_jit.move(TrustedImm32(string-&gt;length()), allocatorGPR);
          } else {
<span class="line-modified">!             bool needsRopeCase = canBeRope(edges[0]);</span>
              m_jit.loadPtr(CCallHelpers::Address(opGPRs[0], JSString::offsetOfValue()), scratch2GPR);
              CCallHelpers::Jump isRope;
<span class="line-modified">!             if (needsRopeCase)</span>
                  isRope = m_jit.branchIfRopeStringImpl(scratch2GPR);
  
              m_jit.load32(CCallHelpers::Address(scratch2GPR, StringImpl::flagsOffset()), scratchGPR);
              m_jit.load32(CCallHelpers::Address(scratch2GPR, StringImpl::lengthMemoryOffset()), allocatorGPR);
  
<span class="line-modified">!             if (needsRopeCase) {</span>
                  auto done = m_jit.jump();
  
                  isRope.link(&amp;m_jit);
<span class="line-modified">!                 m_jit.load32(CCallHelpers::Address(opGPRs[0], JSRopeString::offsetOfFlags()), scratchGPR);</span>
                  m_jit.load32(CCallHelpers::Address(opGPRs[0], JSRopeString::offsetOfLength()), allocatorGPR);
                  done.link(&amp;m_jit);
              }
          }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 13497,58 ***</span>
              ok.link(&amp;m_jit);
          }
      }
  
      for (unsigned i = 1; i &lt; numOpGPRs; ++i) {
<span class="line-modified">!         if (JSString* string = edges[i]-&gt;dynamicCastConstant&lt;JSString*&gt;(*m_jit.vm())) {</span>
              m_jit.and32(TrustedImm32(string-&gt;is8Bit() ? StringImpl::flagIs8Bit() : 0), scratchGPR);
              speculationCheck(
                  Uncountable, JSValueSource(), nullptr,
                  m_jit.branchAdd32(
                      CCallHelpers::Overflow,
                      TrustedImm32(string-&gt;length()), allocatorGPR));
          } else {
<span class="line-modified">!             bool canBeRope = !m_state.forNode(edges[i]).isType(SpecStringIdent);</span>
              m_jit.loadPtr(CCallHelpers::Address(opGPRs[i], JSString::offsetOfValue()), scratch2GPR);
              CCallHelpers::Jump isRope;
<span class="line-modified">!             if (canBeRope)</span>
                  isRope = m_jit.branchIfRopeStringImpl(scratch2GPR);
  
<span class="line-modified">!             m_jit.and16(CCallHelpers::Address(scratch2GPR, StringImpl::flagsOffset()), scratchGPR);</span>
              speculationCheck(
                  Uncountable, JSValueSource(), nullptr,
                  m_jit.branchAdd32(
                      CCallHelpers::Overflow,
                      CCallHelpers::Address(scratch2GPR, StringImpl::lengthMemoryOffset()), allocatorGPR));
<span class="line-modified">!             if (canBeRope) {</span>
                  auto done = m_jit.jump();
  
                  isRope.link(&amp;m_jit);
<span class="line-modified">!                 m_jit.and16(CCallHelpers::Address(opGPRs[i], JSRopeString::offsetOfFlags()), scratchGPR);</span>
                  m_jit.load32(CCallHelpers::Address(opGPRs[i], JSRopeString::offsetOfLength()), scratch2GPR);
                  speculationCheck(
                      Uncountable, JSValueSource(), nullptr,
                      m_jit.branchAdd32(
                          CCallHelpers::Overflow, scratch2GPR, allocatorGPR));
                  done.link(&amp;m_jit);
              }
          }
      }
<span class="line-modified">!     m_jit.store16(scratchGPR, CCallHelpers::Address(resultGPR, JSRopeString::offsetOfFlags()));</span>
      if (!ASSERT_DISABLED) {
          CCallHelpers::Jump ok = m_jit.branch32(
              CCallHelpers::GreaterThanOrEqual, allocatorGPR, TrustedImm32(0));
          m_jit.abortWithReason(DFGNegativeStringLength);
          ok.link(&amp;m_jit);
      }
<span class="line-modified">!     m_jit.store32(allocatorGPR, CCallHelpers::Address(resultGPR, JSRopeString::offsetOfLength()));</span>
      auto isNonEmptyString = m_jit.branchTest32(CCallHelpers::NonZero, allocatorGPR);
  
<span class="line-modified">!     m_jit.move(TrustedImmPtr::weakPointer(m_jit.graph(), jsEmptyString(&amp;m_jit.graph().m_vm)), resultGPR);</span>
  
      isNonEmptyString.link(&amp;m_jit);
<span class="line-modified">!     m_jit.mutatorFence(*m_jit.vm());</span>
  
      switch (numOpGPRs) {
      case 2:
          addSlowPathGenerator(slowPathCall(
              slowPath, this, operationMakeRope2, resultGPR, opGPRs[0], opGPRs[1]));
<span class="line-new-header">--- 13700,82 ---</span>
              ok.link(&amp;m_jit);
          }
      }
  
      for (unsigned i = 1; i &lt; numOpGPRs; ++i) {
<span class="line-modified">!         if (JSString* string = edges[i]-&gt;dynamicCastConstant&lt;JSString*&gt;(vm())) {</span>
              m_jit.and32(TrustedImm32(string-&gt;is8Bit() ? StringImpl::flagIs8Bit() : 0), scratchGPR);
              speculationCheck(
                  Uncountable, JSValueSource(), nullptr,
                  m_jit.branchAdd32(
                      CCallHelpers::Overflow,
                      TrustedImm32(string-&gt;length()), allocatorGPR));
          } else {
<span class="line-modified">!             bool needsRopeCase = canBeRope(edges[i]);</span>
              m_jit.loadPtr(CCallHelpers::Address(opGPRs[i], JSString::offsetOfValue()), scratch2GPR);
              CCallHelpers::Jump isRope;
<span class="line-modified">!             if (needsRopeCase)</span>
                  isRope = m_jit.branchIfRopeStringImpl(scratch2GPR);
  
<span class="line-modified">!             m_jit.and32(CCallHelpers::Address(scratch2GPR, StringImpl::flagsOffset()), scratchGPR);</span>
              speculationCheck(
                  Uncountable, JSValueSource(), nullptr,
                  m_jit.branchAdd32(
                      CCallHelpers::Overflow,
                      CCallHelpers::Address(scratch2GPR, StringImpl::lengthMemoryOffset()), allocatorGPR));
<span class="line-modified">!             if (needsRopeCase) {</span>
                  auto done = m_jit.jump();
  
                  isRope.link(&amp;m_jit);
<span class="line-modified">!                 m_jit.and32(CCallHelpers::Address(opGPRs[i], JSRopeString::offsetOfFlags()), scratchGPR);</span>
                  m_jit.load32(CCallHelpers::Address(opGPRs[i], JSRopeString::offsetOfLength()), scratch2GPR);
                  speculationCheck(
                      Uncountable, JSValueSource(), nullptr,
                      m_jit.branchAdd32(
                          CCallHelpers::Overflow, scratch2GPR, allocatorGPR));
                  done.link(&amp;m_jit);
              }
          }
      }
<span class="line-modified">! </span>
      if (!ASSERT_DISABLED) {
          CCallHelpers::Jump ok = m_jit.branch32(
              CCallHelpers::GreaterThanOrEqual, allocatorGPR, TrustedImm32(0));
          m_jit.abortWithReason(DFGNegativeStringLength);
          ok.link(&amp;m_jit);
      }
<span class="line-modified">! </span>
<span class="line-added">+     static_assert(StringImpl::flagIs8Bit() == JSRopeString::is8BitInPointer, &quot;&quot;);</span>
<span class="line-added">+     m_jit.and32(TrustedImm32(StringImpl::flagIs8Bit()), scratchGPR);</span>
<span class="line-added">+     m_jit.orPtr(opGPRs[0], scratchGPR);</span>
<span class="line-added">+     m_jit.orPtr(TrustedImmPtr(JSString::isRopeInPointer), scratchGPR);</span>
<span class="line-added">+     m_jit.storePtr(scratchGPR, CCallHelpers::Address(resultGPR, JSRopeString::offsetOfFiber0()));</span>
<span class="line-added">+ </span>
<span class="line-added">+     m_jit.move(opGPRs[1], scratchGPR);</span>
<span class="line-added">+     m_jit.lshiftPtr(TrustedImm32(32), scratchGPR);</span>
<span class="line-added">+     m_jit.orPtr(allocatorGPR, scratchGPR);</span>
<span class="line-added">+     m_jit.storePtr(scratchGPR, CCallHelpers::Address(resultGPR, JSRopeString::offsetOfFiber1()));</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (numOpGPRs == 2) {</span>
<span class="line-added">+         m_jit.move(opGPRs[1], scratchGPR);</span>
<span class="line-added">+         m_jit.rshiftPtr(TrustedImm32(32), scratchGPR);</span>
<span class="line-added">+         m_jit.storePtr(scratchGPR, CCallHelpers::Address(resultGPR, JSRopeString::offsetOfFiber2()));</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+         m_jit.move(opGPRs[1], scratchGPR);</span>
<span class="line-added">+         m_jit.rshiftPtr(TrustedImm32(32), scratchGPR);</span>
<span class="line-added">+         m_jit.move(opGPRs[2], scratch2GPR);</span>
<span class="line-added">+         m_jit.lshiftPtr(TrustedImm32(16), scratch2GPR);</span>
<span class="line-added">+         m_jit.orPtr(scratch2GPR, scratchGPR);</span>
<span class="line-added">+         m_jit.storePtr(scratchGPR, CCallHelpers::Address(resultGPR, JSRopeString::offsetOfFiber2()));</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      auto isNonEmptyString = m_jit.branchTest32(CCallHelpers::NonZero, allocatorGPR);
  
<span class="line-modified">!     m_jit.move(TrustedImmPtr::weakPointer(m_jit.graph(), jsEmptyString(m_jit.graph().m_vm)), resultGPR);</span>
  
      isNonEmptyString.link(&amp;m_jit);
<span class="line-modified">!     m_jit.mutatorFence(vm());</span>
  
      switch (numOpGPRs) {
      case 2:
          addSlowPathGenerator(slowPathCall(
              slowPath, this, operationMakeRope2, resultGPR, opGPRs[0], opGPRs[1]));
</pre>
<center><a href="DFGSlowPathGenerator.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGSpeculativeJIT.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>