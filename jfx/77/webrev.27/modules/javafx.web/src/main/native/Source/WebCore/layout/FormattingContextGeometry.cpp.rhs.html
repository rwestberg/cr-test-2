<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/layout/FormattingContextGeometry.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2018 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
  14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
  17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  23  * THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;FormattingContext.h&quot;
  28 
  29 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
  30 
  31 #include &quot;FloatingState.h&quot;
  32 #include &quot;FormattingState.h&quot;
  33 #include &quot;InlineFormattingState.h&quot;
<a name="1" id="anc1"></a><span class="line-added">  34 #include &quot;TableFormattingState.h&quot;</span>
<span class="line-added">  35 #include &quot;TableGrid.h&quot;</span>
  36 
  37 namespace WebCore {
  38 namespace Layout {
  39 
  40 static inline bool isHeightAuto(const Box&amp; layoutBox)
  41 {
  42     // 10.5 Content height: the &#39;height&#39; property
  43     //
  44     // The percentage is calculated with respect to the height of the generated box&#39;s containing block.
  45     // If the height of the containing block is not specified explicitly (i.e., it depends on content height),
  46     // and this element is not absolutely positioned, the used height is calculated as if &#39;auto&#39; was specified.
  47 
  48     auto height = layoutBox.style().logicalHeight();
  49     if (height.isAuto())
  50         return true;
  51 
  52     if (height.isPercent()) {
  53         if (layoutBox.isOutOfFlowPositioned())
  54             return false;
  55 
  56         return !layoutBox.containingBlock()-&gt;style().logicalHeight().isFixed();
  57     }
  58 
  59     return false;
  60 }
  61 
  62 Optional&lt;LayoutUnit&gt; FormattingContext::Geometry::computedHeightValue(const LayoutState&amp; layoutState, const Box&amp; layoutBox, HeightType heightType)
  63 {
  64     auto&amp; style = layoutBox.style();
  65     auto height = heightType == HeightType::Normal ? style.logicalHeight() : heightType == HeightType::Min ? style.logicalMinHeight() : style.logicalMaxHeight();
  66     if (height.isUndefined() || height.isAuto())
  67         return { };
  68 
  69     if (height.isFixed())
<a name="2" id="anc2"></a><span class="line-modified">  70         return LayoutUnit(height.value());</span>
  71 
  72     Optional&lt;LayoutUnit&gt; containingBlockHeightValue;
  73     if (layoutBox.isOutOfFlowPositioned()) {
  74         // Containing block&#39;s height is already computed since we layout the out-of-flow boxes as the last step.
  75         containingBlockHeightValue = layoutState.displayBoxForLayoutBox(*layoutBox.containingBlock()).height();
  76     } else {
  77         if (layoutState.inQuirksMode())
  78             containingBlockHeightValue = FormattingContext::Quirks::heightValueOfNearestContainingBlockWithFixedHeight(layoutState, layoutBox);
  79         else {
  80             auto containingBlockHeight = layoutBox.containingBlock()-&gt;style().logicalHeight();
  81             if (containingBlockHeight.isFixed())
<a name="3" id="anc3"></a><span class="line-modified">  82                 containingBlockHeightValue = LayoutUnit(containingBlockHeight.value());</span>
  83         }
  84     }
  85 
  86     if (!containingBlockHeightValue)
  87         return { };
  88 
  89     return valueForLength(height, *containingBlockHeightValue);
  90 }
  91 
<a name="4" id="anc4"></a><span class="line-modified">  92 LayoutUnit FormattingContext::Geometry::contentHeightForFormattingContextRoot(const LayoutState&amp; layoutState, const Box&amp; layoutBox)</span>
  93 {
  94     ASSERT(isHeightAuto(layoutBox) &amp;&amp; (layoutBox.establishesFormattingContext() || layoutBox.isDocumentBox()));
  95 
  96     // 10.6.7 &#39;Auto&#39; heights for block formatting context roots
  97 
  98     // If it only has inline-level children, the height is the distance between the top of the topmost line box and the bottom of the bottommost line box.
  99     // If it has block-level children, the height is the distance between the top margin-edge of the topmost block-level
 100     // child box and the bottom margin-edge of the bottommost block-level child box.
 101 
 102     // In addition, if the element has any floating descendants whose bottom margin edge is below the element&#39;s bottom content edge,
 103     // then the height is increased to include those edges. Only floats that participate in this block formatting context are taken
 104     // into account, e.g., floats inside absolutely positioned descendants or other floats are not.
 105     if (!is&lt;Container&gt;(layoutBox) || !downcast&lt;Container&gt;(layoutBox).hasInFlowOrFloatingChild())
<a name="5" id="anc5"></a><span class="line-modified"> 106         return { };</span>
 107 
 108     auto&amp; displayBox = layoutState.displayBoxForLayoutBox(layoutBox);
 109     auto borderAndPaddingTop = displayBox.borderTop() + displayBox.paddingTop().valueOr(0);
 110     auto top = borderAndPaddingTop;
 111     auto bottom = borderAndPaddingTop;
 112     auto&amp; formattingRootContainer = downcast&lt;Container&gt;(layoutBox);
 113     if (formattingRootContainer.establishesInlineFormattingContext()) {
<a name="6" id="anc6"></a><span class="line-modified"> 114         auto&amp; lineBoxes = downcast&lt;InlineFormattingState&gt;(layoutState.establishedFormattingState(layoutBox)).lineBoxes();</span>
<span class="line-modified"> 115         // Even empty containers generate one line.</span>
<span class="line-modified"> 116         ASSERT(!lineBoxes.isEmpty());</span>
<span class="line-modified"> 117         top = lineBoxes.first().logicalTop();</span>
<span class="line-modified"> 118         bottom = lineBoxes.last().logicalBottom();</span>

 119     } else if (formattingRootContainer.establishesBlockFormattingContext() || layoutBox.isDocumentBox()) {
 120         if (formattingRootContainer.hasInFlowChild()) {
 121             auto&amp; firstDisplayBox = layoutState.displayBoxForLayoutBox(*formattingRootContainer.firstInFlowChild());
 122             auto&amp; lastDisplayBox = layoutState.displayBoxForLayoutBox(*formattingRootContainer.lastInFlowChild());
 123             top = firstDisplayBox.rectWithMargin().top();
 124             bottom = lastDisplayBox.rectWithMargin().bottom();
 125         }
<a name="7" id="anc7"></a><span class="line-modified"> 126     } else if (formattingRootContainer.establishesTableFormattingContext()) {</span>
<span class="line-added"> 127         auto&amp; rowList = downcast&lt;TableFormattingState&gt;(layoutState.establishedFormattingState(formattingRootContainer)).tableGrid().rows();</span>
<span class="line-added"> 128         ASSERT(!rowList.isEmpty());</span>
<span class="line-added"> 129         top += rowList.first().logicalTop();</span>
<span class="line-added"> 130         auto&amp; lastRow = rowList.last();</span>
<span class="line-added"> 131         bottom += lastRow.logicalBottom();</span>
<span class="line-added"> 132     } else</span>
<span class="line-added"> 133         ASSERT_NOT_REACHED();</span>
 134 
 135     auto* formattingContextRoot = &amp;layoutBox;
 136     // TODO: The document renderer is not a formatting context root by default at all. Need to find out what it is.
 137     if (!layoutBox.establishesFormattingContext()) {
 138         ASSERT(layoutBox.isDocumentBox());
 139         formattingContextRoot = &amp;layoutBox.formattingContextRoot();
 140     }
 141 
 142     auto&amp; floatingState = layoutState.establishedFormattingState(*formattingContextRoot).floatingState();
 143     auto floatBottom = floatingState.bottom(*formattingContextRoot);
 144     if (floatBottom) {
 145         bottom = std::max&lt;LayoutUnit&gt;(*floatBottom, bottom);
 146         auto floatTop = floatingState.top(*formattingContextRoot);
 147         ASSERT(floatTop);
 148         top = std::min&lt;LayoutUnit&gt;(*floatTop, top);
 149     }
 150 
 151     auto computedHeight = bottom - top;
 152     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Height] -&gt; content height for formatting context root -&gt; height(&quot; &lt;&lt; computedHeight &lt;&lt; &quot;px) layoutBox(&quot;&lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;);
 153     return computedHeight;
 154 }
 155 
 156 Optional&lt;LayoutUnit&gt; FormattingContext::Geometry::computedValueIfNotAuto(const Length&amp; geometryProperty, LayoutUnit containingBlockWidth)
 157 {
 158     if (geometryProperty.isUndefined())
 159         return WTF::nullopt;
 160 
 161     if (geometryProperty.isAuto())
 162         return WTF::nullopt;
 163 
 164     return valueForLength(geometryProperty, containingBlockWidth);
 165 }
 166 
 167 Optional&lt;LayoutUnit&gt; FormattingContext::Geometry::fixedValue(const Length&amp; geometryProperty)
 168 {
 169     if (!geometryProperty.isFixed())
 170         return WTF::nullopt;
<a name="8" id="anc8"></a><span class="line-modified"> 171     return LayoutUnit(geometryProperty.value());</span>
 172 }
 173 
 174 // https://www.w3.org/TR/CSS22/visudet.html#min-max-heights
 175 // Specifies a percentage for determining the used value. The percentage is calculated with respect to the height of the generated box&#39;s containing block.
 176 // If the height of the containing block is not specified explicitly (i.e., it depends on content height), and this element is not absolutely positioned,
 177 // the percentage value is treated as &#39;0&#39; (for &#39;min-height&#39;) or &#39;none&#39; (for &#39;max-height&#39;).
 178 Optional&lt;LayoutUnit&gt; FormattingContext::Geometry::computedMaxHeight(const LayoutState&amp; layoutState, const Box&amp; layoutBox)
 179 {
 180     return computedHeightValue(layoutState, layoutBox, HeightType::Max);
 181 }
 182 
 183 Optional&lt;LayoutUnit&gt; FormattingContext::Geometry::computedMinHeight(const LayoutState&amp; layoutState, const Box&amp; layoutBox)
 184 {
 185     if (auto minHeightValue = computedHeightValue(layoutState, layoutBox, HeightType::Min))
 186         return minHeightValue;
 187 
 188     return { 0 };
 189 }
 190 
 191 static LayoutUnit staticVerticalPositionForOutOfFlowPositioned(const LayoutState&amp; layoutState, const Box&amp; layoutBox)
 192 {
 193     ASSERT(layoutBox.isOutOfFlowPositioned());
 194 
 195     // For the purposes of this section and the next, the term &quot;static position&quot; (of an element) refers, roughly, to the position an element would have
 196     // had in the normal flow. More precisely, the static position for &#39;top&#39; is the distance from the top edge of the containing block to the top margin
 197     // edge of a hypothetical box that would have been the first box of the element if its specified &#39;position&#39; value had been &#39;static&#39; and its specified
 198     // &#39;float&#39; had been &#39;none&#39; and its specified &#39;clear&#39; had been &#39;none&#39;. (Note that due to the rules in section 9.7 this might require also assuming a different
 199     // computed value for &#39;display&#39;.) The value is negative if the hypothetical box is above the containing block.
 200 
 201     // Start with this box&#39;s border box offset from the parent&#39;s border box.
 202     LayoutUnit top;
 203     if (auto* previousInFlowSibling = layoutBox.previousInFlowSibling()) {
 204         // Add sibling offset
 205         auto&amp; previousInFlowDisplayBox = layoutState.displayBoxForLayoutBox(*previousInFlowSibling);
 206         top += previousInFlowDisplayBox.bottom() + previousInFlowDisplayBox.nonCollapsedMarginAfter();
 207     } else {
 208         ASSERT(layoutBox.parent());
 209         top = layoutState.displayBoxForLayoutBox(*layoutBox.parent()).contentBoxTop();
 210     }
 211 
 212     // Resolve top all the way up to the containing block.
<a name="9" id="anc9"></a><span class="line-modified"> 213     auto&amp; containingBlock = *layoutBox.containingBlock();</span>
 214     // Start with the parent since we pretend that this box is normal flow.
<a name="10" id="anc10"></a><span class="line-modified"> 215     for (auto* container = layoutBox.parent(); container != &amp;containingBlock; container = container-&gt;containingBlock()) {</span>
 216         auto&amp; displayBox = layoutState.displayBoxForLayoutBox(*container);
 217         // Display::Box::top is the border box top position in its containing block&#39;s coordinate system.
 218         top += displayBox.top();
 219         ASSERT(!container-&gt;isPositioned() || layoutBox.isFixedPositioned());
 220     }
<a name="11" id="anc11"></a><span class="line-modified"> 221     // Move the static position relative to the padding box. This is very specific to abolutely positioned boxes.</span>
<span class="line-added"> 222     auto paddingBoxTop = layoutState.displayBoxForLayoutBox(containingBlock).paddingBoxTop();</span>
<span class="line-added"> 223     return top - paddingBoxTop;</span>
 224 }
 225 
 226 static LayoutUnit staticHorizontalPositionForOutOfFlowPositioned(const LayoutState&amp; layoutState, const Box&amp; layoutBox)
 227 {
 228     ASSERT(layoutBox.isOutOfFlowPositioned());
 229     // See staticVerticalPositionForOutOfFlowPositioned for the definition of the static position.
 230 
 231     // Start with this box&#39;s border box offset from the parent&#39;s border box.
 232     ASSERT(layoutBox.parent());
 233     auto left = layoutState.displayBoxForLayoutBox(*layoutBox.parent()).contentBoxLeft();
 234 
 235     // Resolve left all the way up to the containing block.
<a name="12" id="anc12"></a><span class="line-modified"> 236     auto&amp; containingBlock = *layoutBox.containingBlock();</span>
 237     // Start with the parent since we pretend that this box is normal flow.
<a name="13" id="anc13"></a><span class="line-modified"> 238     for (auto* container = layoutBox.parent(); container != &amp;containingBlock; container = container-&gt;containingBlock()) {</span>
 239         auto&amp; displayBox = layoutState.displayBoxForLayoutBox(*container);
 240         // Display::Box::left is the border box left position in its containing block&#39;s coordinate system.
 241         left += displayBox.left();
 242         ASSERT(!container-&gt;isPositioned() || layoutBox.isFixedPositioned());
 243     }
<a name="14" id="anc14"></a><span class="line-modified"> 244     // Move the static position relative to the padding box. This is very specific to abolutely positioned boxes.</span>
<span class="line-added"> 245     auto paddingBoxLeft = layoutState.displayBoxForLayoutBox(containingBlock).paddingBoxLeft();</span>
<span class="line-added"> 246     return left - paddingBoxLeft;</span>
 247 }
 248 
 249 LayoutUnit FormattingContext::Geometry::shrinkToFitWidth(LayoutState&amp; layoutState, const Box&amp; formattingRoot, UsedHorizontalValues usedValues)
 250 {
 251     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Width] -&gt; shrink to fit -&gt; unsupported -&gt; width(&quot; &lt;&lt; LayoutUnit { } &lt;&lt; &quot;px) layoutBox: &quot; &lt;&lt; &amp;formattingRoot &lt;&lt; &quot;)&quot;);
 252     ASSERT(formattingRoot.establishesFormattingContext());
 253     ASSERT(usedValues.containingBlockWidth.hasValue());
 254 
 255     // Calculation of the shrink-to-fit width is similar to calculating the width of a table cell using the automatic table layout algorithm.
 256     // Roughly: calculate the preferred width by formatting the content without breaking lines other than where explicit line breaks occur,
 257     // and also calculate the preferred minimum width, e.g., by trying all possible line breaks. CSS 2.2 does not define the exact algorithm.
 258     // Thirdly, find the available width: in this case, this is the width of the containing block minus the used values of &#39;margin-left&#39;, &#39;border-left-width&#39;,
 259     // &#39;padding-left&#39;, &#39;padding-right&#39;, &#39;border-right-width&#39;, &#39;margin-right&#39;, and the widths of any relevant scroll bars.
 260 
 261     // Then the shrink-to-fit width is: min(max(preferred minimum width, available width), preferred width).
<a name="15" id="anc15"></a><span class="line-modified"> 262     auto&amp; formattingStateForRoot = layoutState.createFormattingStateForFormattingRootIfNeeded(formattingRoot);</span>
<span class="line-modified"> 263     auto intrinsicWidthConstraints = formattingStateForRoot.intrinsicWidthConstraints();</span>
<span class="line-modified"> 264     if (!intrinsicWidthConstraints)</span>
<span class="line-modified"> 265         intrinsicWidthConstraints = layoutState.createFormattingContext(formattingRoot)-&gt;computedIntrinsicWidthConstraints();</span>


 266     auto availableWidth = *usedValues.containingBlockWidth;
 267     return std::min(std::max(intrinsicWidthConstraints-&gt;minimum, availableWidth), intrinsicWidthConstraints-&gt;maximum);
 268 }
 269 
 270 VerticalGeometry FormattingContext::Geometry::outOfFlowNonReplacedVerticalGeometry(const LayoutState&amp; layoutState, const Box&amp; layoutBox, UsedVerticalValues usedValues)
 271 {
 272     ASSERT(layoutBox.isOutOfFlowPositioned() &amp;&amp; !layoutBox.replaced());
 273 
 274     // 10.6.4 Absolutely positioned, non-replaced elements
 275     //
 276     // For absolutely positioned elements, the used values of the vertical dimensions must satisfy this constraint:
 277     // &#39;top&#39; + &#39;margin-top&#39; + &#39;border-top-width&#39; + &#39;padding-top&#39; + &#39;height&#39; + &#39;padding-bottom&#39; + &#39;border-bottom-width&#39; + &#39;margin-bottom&#39; + &#39;bottom&#39;
 278     // = height of containing block
 279 
 280     // If all three of &#39;top&#39;, &#39;height&#39;, and &#39;bottom&#39; are auto, set &#39;top&#39; to the static position and apply rule number three below.
 281 
 282     // If none of the three are &#39;auto&#39;: If both &#39;margin-top&#39; and &#39;margin-bottom&#39; are &#39;auto&#39;, solve the equation under the extra
 283     // constraint that the two margins get equal values. If one of &#39;margin-top&#39; or &#39;margin-bottom&#39; is &#39;auto&#39;, solve the equation for that value.
 284     // If the values are over-constrained, ignore the value for &#39;bottom&#39; and solve for that value.
 285 
 286     // Otherwise, pick the one of the following six rules that applies.
 287 
 288     // 1. &#39;top&#39; and &#39;height&#39; are &#39;auto&#39; and &#39;bottom&#39; is not &#39;auto&#39;, then the height is based on the content per 10.6.7,
 289     //     set &#39;auto&#39; values for &#39;margin-top&#39; and &#39;margin-bottom&#39; to 0, and solve for &#39;top&#39;
 290     // 2. &#39;top&#39; and &#39;bottom&#39; are &#39;auto&#39; and &#39;height&#39; is not &#39;auto&#39;, then set &#39;top&#39; to the static position, set &#39;auto&#39; values for
 291     //    &#39;margin-top&#39; and &#39;margin-bottom&#39; to 0, and solve for &#39;bottom&#39;
 292     // 3. &#39;height&#39; and &#39;bottom&#39; are &#39;auto&#39; and &#39;top&#39; is not &#39;auto&#39;, then the height is based on the content per 10.6.7, set &#39;auto&#39;
 293     //     values for &#39;margin-top&#39; and &#39;margin-bottom&#39; to 0, and solve for &#39;bottom&#39;
 294     // 4. &#39;top&#39; is &#39;auto&#39;, &#39;height&#39; and &#39;bottom&#39; are not &#39;auto&#39;, then set &#39;auto&#39; values for &#39;margin-top&#39; and &#39;margin-bottom&#39; to 0, and solve for &#39;top&#39;
 295     // 5. &#39;height&#39; is &#39;auto&#39;, &#39;top&#39; and &#39;bottom&#39; are not &#39;auto&#39;, then &#39;auto&#39; values for &#39;margin-top&#39; and &#39;margin-bottom&#39; are set to 0 and solve for &#39;height&#39;
 296     // 6. &#39;bottom&#39; is &#39;auto&#39;, &#39;top&#39; and &#39;height&#39; are not &#39;auto&#39;, then set &#39;auto&#39; values for &#39;margin-top&#39; and &#39;margin-bottom&#39; to 0 and solve for &#39;bottom&#39;
 297 
 298     auto&amp; style = layoutBox.style();
 299     auto&amp; displayBox = layoutState.displayBoxForLayoutBox(layoutBox);
 300     auto&amp; containingBlockDisplayBox = layoutState.displayBoxForLayoutBox(*layoutBox.containingBlock());
 301     auto containingBlockHeight = containingBlockDisplayBox.paddingBoxHeight();
 302     auto containingBlockWidth = containingBlockDisplayBox.paddingBoxWidth();
 303 
 304     auto top = computedValueIfNotAuto(style.logicalTop(), containingBlockWidth);
 305     auto bottom = computedValueIfNotAuto(style.logicalBottom(), containingBlockWidth);
<a name="16" id="anc16"></a>
 306     auto height = usedValues.height ? usedValues.height.value() : computedHeightValue(layoutState, layoutBox, HeightType::Normal);
 307     auto computedVerticalMargin = Geometry::computedVerticalMargin(layoutBox, UsedHorizontalValues { containingBlockWidth });
 308     UsedVerticalMargin::NonCollapsedValues usedVerticalMargin;
 309     auto paddingTop = displayBox.paddingTop().valueOr(0);
 310     auto paddingBottom = displayBox.paddingBottom().valueOr(0);
 311     auto borderTop = displayBox.borderTop();
 312     auto borderBottom = displayBox.borderBottom();
 313     auto contentHeight = [&amp;] {
 314         ASSERT(height);
 315         return style.boxSizing() == BoxSizing::ContentBox ? *height : *height - (borderTop + paddingTop + paddingBottom + borderBottom);
 316     };
 317 
 318     if (!top &amp;&amp; !height &amp;&amp; !bottom)
 319         top = staticVerticalPositionForOutOfFlowPositioned(layoutState, layoutBox);
 320 
 321     if (top &amp;&amp; height &amp;&amp; bottom) {
 322         if (!computedVerticalMargin.before &amp;&amp; !computedVerticalMargin.after) {
 323             auto marginBeforeAndAfter = containingBlockHeight - (*top + borderTop + paddingTop + contentHeight() + paddingBottom + borderBottom + *bottom);
 324             usedVerticalMargin = { marginBeforeAndAfter / 2, marginBeforeAndAfter / 2 };
 325         } else if (!computedVerticalMargin.before) {
 326             usedVerticalMargin.after = *computedVerticalMargin.after;
 327             usedVerticalMargin.before = containingBlockHeight - (*top + borderTop + paddingTop + contentHeight() + paddingBottom + borderBottom + usedVerticalMargin.after + *bottom);
 328         } else if (!computedVerticalMargin.after) {
 329             usedVerticalMargin.before = *computedVerticalMargin.before;
 330             usedVerticalMargin.after = containingBlockHeight - (*top + usedVerticalMargin.before + borderTop + paddingTop + contentHeight() + paddingBottom + borderBottom + *bottom);
 331         } else
 332             usedVerticalMargin = { *computedVerticalMargin.before, *computedVerticalMargin.after };
 333         // Over-constrained?
 334         auto boxHeight = *top + usedVerticalMargin.before + borderTop + paddingTop + contentHeight() + paddingBottom + borderBottom + usedVerticalMargin.after + *bottom;
 335         if (boxHeight != containingBlockHeight)
 336             bottom = containingBlockHeight - (*top + usedVerticalMargin.before + borderTop + paddingTop + contentHeight() + paddingBottom + borderBottom + usedVerticalMargin.after);
 337     }
 338 
 339     if (!top &amp;&amp; !height &amp;&amp; bottom) {
 340         // #1
 341         height = contentHeightForFormattingContextRoot(layoutState, layoutBox);
 342         usedVerticalMargin = { computedVerticalMargin.before.valueOr(0), computedVerticalMargin.after.valueOr(0) };
 343         top = containingBlockHeight - (usedVerticalMargin.before + borderTop + paddingTop + *height + paddingBottom + borderBottom + usedVerticalMargin.after + *bottom);
 344     }
 345 
 346     if (!top &amp;&amp; !bottom &amp;&amp; height) {
 347         // #2
 348         top = staticVerticalPositionForOutOfFlowPositioned(layoutState, layoutBox);
 349         usedVerticalMargin = { computedVerticalMargin.before.valueOr(0), computedVerticalMargin.after.valueOr(0) };
 350         bottom = containingBlockHeight - (*top + usedVerticalMargin.before + borderTop + paddingTop + contentHeight() + paddingBottom + borderBottom + usedVerticalMargin.after);
 351     }
 352 
 353     if (!height &amp;&amp; !bottom &amp;&amp; top) {
 354         // #3
 355         height = contentHeightForFormattingContextRoot(layoutState, layoutBox);
 356         usedVerticalMargin = { computedVerticalMargin.before.valueOr(0), computedVerticalMargin.after.valueOr(0) };
 357         bottom = containingBlockHeight - (*top + usedVerticalMargin.before + borderTop + paddingTop + *height + paddingBottom + borderBottom + usedVerticalMargin.after);
 358     }
 359 
 360     if (!top &amp;&amp; height &amp;&amp; bottom) {
 361         // #4
 362         usedVerticalMargin = { computedVerticalMargin.before.valueOr(0), computedVerticalMargin.after.valueOr(0) };
 363         top = containingBlockHeight - (usedVerticalMargin.before + borderTop + paddingTop + contentHeight() + paddingBottom + borderBottom + usedVerticalMargin.after + *bottom);
 364     }
 365 
 366     if (!height &amp;&amp; top &amp;&amp; bottom) {
 367         // #5
 368         usedVerticalMargin = { computedVerticalMargin.before.valueOr(0), computedVerticalMargin.after.valueOr(0) };
 369         height = containingBlockHeight - (*top + usedVerticalMargin.before + borderTop + paddingTop + paddingBottom + borderBottom + usedVerticalMargin.after + *bottom);
 370     }
 371 
 372     if (!bottom &amp;&amp; top &amp;&amp; height) {
 373         // #6
 374         usedVerticalMargin = { computedVerticalMargin.before.valueOr(0), computedVerticalMargin.after.valueOr(0) };
 375         bottom = containingBlockHeight - (*top + usedVerticalMargin.before + borderTop + paddingTop + contentHeight() + paddingBottom + borderBottom + usedVerticalMargin.after);
 376     }
 377 
 378     ASSERT(top);
 379     ASSERT(bottom);
 380     ASSERT(height);
 381 
 382     // For out-of-flow elements the containing block is formed by the padding edge of the ancestor.
<a name="17" id="anc17"></a><span class="line-modified"> 383     // At this point the positioned value is in the coordinate system of the padding box. Let&#39;s convert it to border box coordinate system.</span>
<span class="line-modified"> 384     auto containingBlockPaddingVerticalEdge = containingBlockDisplayBox.paddingBoxTop();</span>
<span class="line-modified"> 385     *top += containingBlockPaddingVerticalEdge;</span>
<span class="line-modified"> 386     *bottom += containingBlockPaddingVerticalEdge;</span>


 387 
 388     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Position][Height][Margin] -&gt; out-of-flow non-replaced -&gt; top(&quot; &lt;&lt; *top &lt;&lt; &quot;px) bottom(&quot;  &lt;&lt; *bottom &lt;&lt; &quot;px) height(&quot; &lt;&lt; *height &lt;&lt; &quot;px) margin(&quot; &lt;&lt; usedVerticalMargin.before &lt;&lt; &quot;px, &quot;  &lt;&lt; usedVerticalMargin.after &lt;&lt; &quot;px) layoutBox(&quot; &lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;);
 389     return { *top, *bottom, { contentHeight(), usedVerticalMargin } };
 390 }
 391 
 392 HorizontalGeometry FormattingContext::Geometry::outOfFlowNonReplacedHorizontalGeometry(LayoutState&amp; layoutState, const Box&amp; layoutBox, UsedHorizontalValues usedValues)
 393 {
 394     ASSERT(layoutBox.isOutOfFlowPositioned() &amp;&amp; !layoutBox.replaced());
 395 
 396     // 10.3.7 Absolutely positioned, non-replaced elements
 397     //
 398     // &#39;left&#39; + &#39;margin-left&#39; + &#39;border-left-width&#39; + &#39;padding-left&#39; + &#39;width&#39; + &#39;padding-right&#39; + &#39;border-right-width&#39; + &#39;margin-right&#39; + &#39;right&#39;
 399     // = width of containing block
 400 
 401     // If all three of &#39;left&#39;, &#39;width&#39;, and &#39;right&#39; are &#39;auto&#39;: First set any &#39;auto&#39; values for &#39;margin-left&#39; and &#39;margin-right&#39; to 0.
 402     // Then, if the &#39;direction&#39; property of the element establishing the static-position containing block is &#39;ltr&#39; set &#39;left&#39; to the static
 403     // position and apply rule number three below; otherwise, set &#39;right&#39; to the static position and apply rule number one below.
 404     //
 405     // If none of the three is &#39;auto&#39;: If both &#39;margin-left&#39; and &#39;margin-right&#39; are &#39;auto&#39;, solve the equation under the extra constraint that the two margins get equal values,
 406     // unless this would make them negative, in which case when direction of the containing block is &#39;ltr&#39; (&#39;rtl&#39;), set &#39;margin-left&#39; (&#39;margin-right&#39;) to zero and
 407     // solve for &#39;margin-right&#39; (&#39;margin-left&#39;). If one of &#39;margin-left&#39; or &#39;margin-right&#39; is &#39;auto&#39;, solve the equation for that value.
 408     // If the values are over-constrained, ignore the value for &#39;left&#39; (in case the &#39;direction&#39; property of the containing block is &#39;rtl&#39;) or &#39;right&#39;
 409     // (in case &#39;direction&#39; is &#39;ltr&#39;) and solve for that value.
 410     //
 411     // Otherwise, set &#39;auto&#39; values for &#39;margin-left&#39; and &#39;margin-right&#39; to 0, and pick the one of the following six rules that applies.
 412     //
 413     // 1. &#39;left&#39; and &#39;width&#39; are &#39;auto&#39; and &#39;right&#39; is not &#39;auto&#39;, then the width is shrink-to-fit. Then solve for &#39;left&#39;
 414     // 2. &#39;left&#39; and &#39;right&#39; are &#39;auto&#39; and &#39;width&#39; is not &#39;auto&#39;, then if the &#39;direction&#39; property of the element establishing the static-position
 415     //    containing block is &#39;ltr&#39; set &#39;left&#39; to the static position, otherwise set &#39;right&#39; to the static position.
 416     //    Then solve for &#39;left&#39; (if &#39;direction is &#39;rtl&#39;) or &#39;right&#39; (if &#39;direction&#39; is &#39;ltr&#39;).
 417     // 3. &#39;width&#39; and &#39;right&#39; are &#39;auto&#39; and &#39;left&#39; is not &#39;auto&#39;, then the width is shrink-to-fit . Then solve for &#39;right&#39;
 418     // 4. &#39;left&#39; is &#39;auto&#39;, &#39;width&#39; and &#39;right&#39; are not &#39;auto&#39;, then solve for &#39;left&#39;
 419     // 5. &#39;width&#39; is &#39;auto&#39;, &#39;left&#39; and &#39;right&#39; are not &#39;auto&#39;, then solve for &#39;width&#39;
 420     // 6. &#39;right&#39; is &#39;auto&#39;, &#39;left&#39; and &#39;width&#39; are not &#39;auto&#39;, then solve for &#39;right&#39;
 421 
 422     auto&amp; style = layoutBox.style();
 423     auto&amp; displayBox = layoutState.displayBoxForLayoutBox(layoutBox);
 424     auto&amp; containingBlock = *layoutBox.containingBlock();
 425     auto&amp; containingBlockDisplayBox = layoutState.displayBoxForLayoutBox(containingBlock);
 426     auto containingBlockWidth = usedValues.containingBlockWidth.valueOr(0);
 427     auto isLeftToRightDirection = containingBlock.style().isLeftToRightDirection();
 428 
 429     auto left = computedValueIfNotAuto(style.logicalLeft(), containingBlockWidth);
 430     auto right = computedValueIfNotAuto(style.logicalRight(), containingBlockWidth);
<a name="18" id="anc18"></a>
 431     auto width = computedValueIfNotAuto(usedValues.width ? Length { usedValues.width.value(), Fixed } : style.logicalWidth(), containingBlockWidth);
 432     auto computedHorizontalMargin = Geometry::computedHorizontalMargin(layoutBox, usedValues);
 433     UsedHorizontalMargin usedHorizontalMargin;
 434     auto paddingLeft = displayBox.paddingLeft().valueOr(0);
 435     auto paddingRight = displayBox.paddingRight().valueOr(0);
 436     auto borderLeft = displayBox.borderLeft();
 437     auto borderRight = displayBox.borderRight();
 438     auto contentWidth = [&amp;] {
 439         ASSERT(width);
 440         return style.boxSizing() == BoxSizing::ContentBox ? *width : *width - (borderLeft + paddingLeft + paddingRight + borderRight);
 441     };
 442 
 443     if (!left &amp;&amp; !width &amp;&amp; !right) {
 444         // If all three of &#39;left&#39;, &#39;width&#39;, and &#39;right&#39; are &#39;auto&#39;: First set any &#39;auto&#39; values for &#39;margin-left&#39; and &#39;margin-right&#39; to 0.
 445         // Then, if the &#39;direction&#39; property of the element establishing the static-position containing block is &#39;ltr&#39; set &#39;left&#39; to the static
 446         // position and apply rule number three below; otherwise, set &#39;right&#39; to the static position and apply rule number one below.
 447         usedHorizontalMargin = { computedHorizontalMargin.start.valueOr(0), computedHorizontalMargin.end.valueOr(0) };
 448 
 449         auto staticHorizontalPosition = staticHorizontalPositionForOutOfFlowPositioned(layoutState, layoutBox);
 450         if (isLeftToRightDirection)
 451             left = staticHorizontalPosition;
 452         else
 453             right = staticHorizontalPosition;
 454     } else if (left &amp;&amp; width &amp;&amp; right) {
 455         // If none of the three is &#39;auto&#39;: If both &#39;margin-left&#39; and &#39;margin-right&#39; are &#39;auto&#39;, solve the equation under the extra constraint that the two margins get equal values,
 456         // unless this would make them negative, in which case when direction of the containing block is &#39;ltr&#39; (&#39;rtl&#39;), set &#39;margin-left&#39; (&#39;margin-right&#39;) to zero and
 457         // solve for &#39;margin-right&#39; (&#39;margin-left&#39;). If one of &#39;margin-left&#39; or &#39;margin-right&#39; is &#39;auto&#39;, solve the equation for that value.
 458         // If the values are over-constrained, ignore the value for &#39;left&#39; (in case the &#39;direction&#39; property of the containing block is &#39;rtl&#39;) or &#39;right&#39;
 459         // (in case &#39;direction&#39; is &#39;ltr&#39;) and solve for that value.
 460         if (!computedHorizontalMargin.start &amp;&amp; !computedHorizontalMargin.end) {
 461             auto marginStartAndEnd = containingBlockWidth - (*left + borderLeft + paddingLeft + contentWidth() + paddingRight + borderRight + *right);
 462             if (marginStartAndEnd &gt;= 0)
 463                 usedHorizontalMargin = { marginStartAndEnd / 2, marginStartAndEnd / 2 };
 464             else {
 465                 if (isLeftToRightDirection) {
 466                     usedHorizontalMargin.start = 0_lu;
 467                     usedHorizontalMargin.end = containingBlockWidth - (*left + usedHorizontalMargin.start + borderLeft + paddingLeft + contentWidth() + paddingRight + borderRight + *right);
 468                 } else {
 469                     usedHorizontalMargin.end = 0_lu;
 470                     usedHorizontalMargin.start = containingBlockWidth - (*left + borderLeft + paddingLeft + contentWidth() + paddingRight + borderRight + usedHorizontalMargin.end + *right);
 471                 }
 472             }
 473         } else if (!computedHorizontalMargin.start) {
 474             usedHorizontalMargin.end = *computedHorizontalMargin.end;
 475             usedHorizontalMargin.start = containingBlockWidth - (*left + borderLeft + paddingLeft + contentWidth() + paddingRight + borderRight + usedHorizontalMargin.end + *right);
<a name="19" id="anc19"></a>






 476         } else if (!computedHorizontalMargin.end) {
 477             usedHorizontalMargin.start = *computedHorizontalMargin.start;
 478             usedHorizontalMargin.end = containingBlockWidth - (*left + usedHorizontalMargin.start + borderLeft + paddingLeft + contentWidth() + paddingRight + borderRight + *right);
<a name="20" id="anc20"></a><span class="line-modified"> 479         } else {</span>







 480             usedHorizontalMargin = { *computedHorizontalMargin.start, *computedHorizontalMargin.end };
<a name="21" id="anc21"></a><span class="line-added"> 481             // Overconstrained? Ignore right (left).</span>
<span class="line-added"> 482             if (isLeftToRightDirection)</span>
<span class="line-added"> 483                 right = containingBlockWidth - (usedHorizontalMargin.start + *left + borderLeft + paddingLeft + contentWidth() + paddingRight + borderRight + usedHorizontalMargin.end);</span>
<span class="line-added"> 484             else</span>
<span class="line-added"> 485                 left = containingBlockWidth - (usedHorizontalMargin.start + borderLeft + paddingLeft + contentWidth() + paddingRight + borderRight + usedHorizontalMargin.end + *right);</span>
<span class="line-added"> 486         }</span>
 487     } else {
 488         // Otherwise, set &#39;auto&#39; values for &#39;margin-left&#39; and &#39;margin-right&#39; to 0, and pick the one of the following six rules that applies.
 489         usedHorizontalMargin = { computedHorizontalMargin.start.valueOr(0), computedHorizontalMargin.end.valueOr(0) };
 490     }
 491 
 492     if (!left &amp;&amp; !width &amp;&amp; right) {
 493         // #1
<a name="22" id="anc22"></a><span class="line-modified"> 494         // Calculate the available width by solving for &#39;width&#39; after setting &#39;left&#39; (in case 1) to 0</span>
<span class="line-added"> 495         left = LayoutUnit { 0 };</span>
<span class="line-added"> 496         auto availableWidth = containingBlockWidth - (*left + usedHorizontalMargin.start + borderLeft + paddingLeft + paddingRight + borderRight + usedHorizontalMargin.end + *right);</span>
<span class="line-added"> 497         width = shrinkToFitWidth(layoutState, layoutBox, UsedHorizontalValues { availableWidth, usedValues.width, usedValues.margin });</span>
 498         left = containingBlockWidth - (usedHorizontalMargin.start + borderLeft + paddingLeft + *width + paddingRight  + borderRight + usedHorizontalMargin.end + *right);
 499     } else if (!left &amp;&amp; !right &amp;&amp; width) {
 500         // #2
 501         auto staticHorizontalPosition = staticHorizontalPositionForOutOfFlowPositioned(layoutState, layoutBox);
 502         if (isLeftToRightDirection) {
 503             left = staticHorizontalPosition;
 504             right = containingBlockWidth - (*left + usedHorizontalMargin.start + borderLeft + paddingLeft + contentWidth() + paddingRight + borderRight + usedHorizontalMargin.end);
 505         } else {
 506             right = staticHorizontalPosition;
 507             left = containingBlockWidth - (usedHorizontalMargin.start + borderLeft + paddingLeft + contentWidth() + paddingRight + borderRight + usedHorizontalMargin.end + *right);
 508         }
 509     } else if (!width &amp;&amp; !right &amp;&amp; left) {
 510         // #3
<a name="23" id="anc23"></a><span class="line-modified"> 511         // Calculate the available width by solving for &#39;width&#39; after setting &#39;right&#39; (in case 3) to 0</span>
<span class="line-added"> 512         right = LayoutUnit { 0 };</span>
<span class="line-added"> 513         auto availableWidth = containingBlockWidth - (*left + usedHorizontalMargin.start + borderLeft + paddingLeft + paddingRight + borderRight + usedHorizontalMargin.end + *right);</span>
<span class="line-added"> 514         width = shrinkToFitWidth(layoutState, layoutBox, UsedHorizontalValues { availableWidth, usedValues.width, usedValues.margin });</span>
 515         right = containingBlockWidth - (*left + usedHorizontalMargin.start + borderLeft + paddingLeft + *width + paddingRight + borderRight + usedHorizontalMargin.end);
 516     } else if (!left &amp;&amp; width &amp;&amp; right) {
 517         // #4
 518         left = containingBlockWidth - (usedHorizontalMargin.start + borderLeft + paddingLeft + contentWidth() + paddingRight + borderRight + usedHorizontalMargin.end + *right);
 519     } else if (!width &amp;&amp; left &amp;&amp; right) {
 520         // #5
 521         width = containingBlockWidth - (*left + usedHorizontalMargin.start + borderLeft + paddingLeft + paddingRight + borderRight + usedHorizontalMargin.end + *right);
 522     } else if (!right &amp;&amp; left &amp;&amp; width) {
 523         // #6
 524         right = containingBlockWidth - (*left + usedHorizontalMargin.start + borderLeft + paddingLeft + contentWidth() + paddingRight + borderRight + usedHorizontalMargin.end);
 525     }
 526 
 527     ASSERT(left);
 528     ASSERT(right);
 529     ASSERT(width);
 530 
 531     // For out-of-flow elements the containing block is formed by the padding edge of the ancestor.
<a name="24" id="anc24"></a><span class="line-modified"> 532     // At this point the positioned value is in the coordinate system of the padding box. Let&#39;s convert it to border box coordinate system.</span>
<span class="line-modified"> 533     auto containingBlockPaddingVerticalEdge = containingBlockDisplayBox.paddingBoxLeft();</span>
<span class="line-modified"> 534     *left += containingBlockPaddingVerticalEdge;</span>
<span class="line-modified"> 535     *right += containingBlockPaddingVerticalEdge;</span>


 536 
 537     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Position][Width][Margin] -&gt; out-of-flow non-replaced -&gt; left(&quot; &lt;&lt; *left &lt;&lt; &quot;px) right(&quot;  &lt;&lt; *right &lt;&lt; &quot;px) width(&quot; &lt;&lt; *width &lt;&lt; &quot;px) margin(&quot; &lt;&lt; usedHorizontalMargin.start &lt;&lt; &quot;px, &quot;  &lt;&lt; usedHorizontalMargin.end &lt;&lt; &quot;px) layoutBox(&quot; &lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;);
 538     return { *left, *right, { contentWidth(), usedHorizontalMargin, computedHorizontalMargin } };
 539 }
 540 
 541 VerticalGeometry FormattingContext::Geometry::outOfFlowReplacedVerticalGeometry(const LayoutState&amp; layoutState, const Box&amp; layoutBox, UsedVerticalValues usedValues)
 542 {
 543     ASSERT(layoutBox.isOutOfFlowPositioned() &amp;&amp; layoutBox.replaced());
 544 
 545     // 10.6.5 Absolutely positioned, replaced elements
 546     //
 547     // The used value of &#39;height&#39; is determined as for inline replaced elements.
 548     // If &#39;margin-top&#39; or &#39;margin-bottom&#39; is specified as &#39;auto&#39; its used value is determined by the rules below.
 549     // 1. If both &#39;top&#39; and &#39;bottom&#39; have the value &#39;auto&#39;, replace &#39;top&#39; with the element&#39;s static position.
 550     // 2. If &#39;bottom&#39; is &#39;auto&#39;, replace any &#39;auto&#39; on &#39;margin-top&#39; or &#39;margin-bottom&#39; with &#39;0&#39;.
 551     // 3. If at this point both &#39;margin-top&#39; and &#39;margin-bottom&#39; are still &#39;auto&#39;, solve the equation under the extra constraint that the two margins must get equal values.
 552     // 4. If at this point there is only one &#39;auto&#39; left, solve the equation for that value.
 553     // 5. If at this point the values are over-constrained, ignore the value for &#39;bottom&#39; and solve for that value.
 554 
 555     auto&amp; style = layoutBox.style();
 556     auto&amp; displayBox = layoutState.displayBoxForLayoutBox(layoutBox);
 557     auto&amp; containingBlockDisplayBox = layoutState.displayBoxForLayoutBox(*layoutBox.containingBlock());
 558     auto containingBlockHeight = containingBlockDisplayBox.paddingBoxHeight();
 559     auto containingBlockWidth = containingBlockDisplayBox.paddingBoxWidth();
 560 
 561     auto top = computedValueIfNotAuto(style.logicalTop(), containingBlockWidth);
 562     auto bottom = computedValueIfNotAuto(style.logicalBottom(), containingBlockWidth);
<a name="25" id="anc25"></a>
 563     auto height = inlineReplacedHeightAndMargin(layoutState, layoutBox, usedValues).height;
 564     auto computedVerticalMargin = Geometry::computedVerticalMargin(layoutBox, UsedHorizontalValues { containingBlockWidth });
 565     Optional&lt;LayoutUnit&gt; usedMarginBefore = computedVerticalMargin.before;
 566     Optional&lt;LayoutUnit&gt; usedMarginAfter = computedVerticalMargin.after;
 567     auto paddingTop = displayBox.paddingTop().valueOr(0);
 568     auto paddingBottom = displayBox.paddingBottom().valueOr(0);
 569     auto borderTop = displayBox.borderTop();
 570     auto borderBottom = displayBox.borderBottom();
 571 
 572     if (!top &amp;&amp; !bottom) {
 573         // #1
 574         top = staticVerticalPositionForOutOfFlowPositioned(layoutState, layoutBox);
 575     }
 576 
 577     if (!bottom) {
 578         // #2
 579         usedMarginBefore = computedVerticalMargin.before.valueOr(0);
 580         usedMarginAfter = usedMarginBefore;
 581     }
 582 
 583     if (!usedMarginBefore &amp;&amp; !usedMarginAfter) {
 584         // #3
 585         auto marginBeforeAndAfter = containingBlockHeight - (*top + borderTop + paddingTop + height + paddingBottom + borderBottom + *bottom);
 586         usedMarginBefore = marginBeforeAndAfter / 2;
 587         usedMarginAfter = usedMarginBefore;
 588     }
 589 
 590     // #4
 591     if (!top)
 592         top = containingBlockHeight - (*usedMarginBefore + borderTop + paddingTop + height + paddingBottom + borderBottom + *usedMarginAfter + *bottom);
 593 
 594     if (!bottom)
 595         bottom = containingBlockHeight - (*top + *usedMarginBefore + borderTop + paddingTop + height + paddingBottom + borderBottom + *usedMarginAfter);
 596 
 597     if (!usedMarginBefore)
 598         usedMarginBefore = containingBlockHeight - (*top + borderTop + paddingTop + height + paddingBottom + borderBottom + *usedMarginAfter + *bottom);
 599 
 600     if (!usedMarginAfter)
 601         usedMarginAfter = containingBlockHeight - (*top + *usedMarginBefore + borderTop + paddingTop + height + paddingBottom + borderBottom + *bottom);
 602 
 603     // #5
 604     auto boxHeight = *top + *usedMarginBefore + borderTop + paddingTop + height + paddingBottom + borderBottom + *usedMarginAfter + *bottom;
 605     if (boxHeight &gt; containingBlockHeight)
 606         bottom = containingBlockHeight - (*top + *usedMarginBefore + borderTop + paddingTop + height + paddingBottom + borderBottom + *usedMarginAfter);
 607 
 608     // For out-of-flow elements the containing block is formed by the padding edge of the ancestor.
<a name="26" id="anc26"></a><span class="line-modified"> 609     // At this point the positioned value is in the coordinate system of the padding box. Let&#39;s convert it to border box coordinate system.</span>
<span class="line-modified"> 610     auto containingBlockPaddingVerticalEdge = containingBlockDisplayBox.paddingBoxTop();</span>
<span class="line-modified"> 611     *top += containingBlockPaddingVerticalEdge;</span>
<span class="line-modified"> 612     *bottom += containingBlockPaddingVerticalEdge;</span>


 613 
 614     ASSERT(top);
 615     ASSERT(bottom);
 616     ASSERT(usedMarginBefore);
 617     ASSERT(usedMarginAfter);
 618     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Position][Height][Margin] -&gt; out-of-flow replaced -&gt; top(&quot; &lt;&lt; *top &lt;&lt; &quot;px) bottom(&quot;  &lt;&lt; *bottom &lt;&lt; &quot;px) height(&quot; &lt;&lt; height &lt;&lt; &quot;px) margin(&quot; &lt;&lt; *usedMarginBefore &lt;&lt; &quot;px, &quot;  &lt;&lt; *usedMarginAfter &lt;&lt; &quot;px) layoutBox(&quot; &lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;);
 619     return { *top, *bottom, { height, { *usedMarginBefore, *usedMarginAfter } } };
 620 }
 621 
 622 HorizontalGeometry FormattingContext::Geometry::outOfFlowReplacedHorizontalGeometry(const LayoutState&amp; layoutState, const Box&amp; layoutBox, UsedHorizontalValues usedValues)
 623 {
 624     ASSERT(layoutBox.isOutOfFlowPositioned() &amp;&amp; layoutBox.replaced());
 625 
 626     // 10.3.8 Absolutely positioned, replaced elements
 627     // In this case, section 10.3.7 applies up through and including the constraint equation, but the rest of section 10.3.7 is replaced by the following rules:
 628     //
 629     // The used value of &#39;width&#39; is determined as for inline replaced elements. If &#39;margin-left&#39; or &#39;margin-right&#39; is specified as &#39;auto&#39; its used value is determined by the rules below.
 630     // 1. If both &#39;left&#39; and &#39;right&#39; have the value &#39;auto&#39;, then if the &#39;direction&#39; property of the element establishing the static-position containing block is &#39;ltr&#39;,
 631     //   set &#39;left&#39; to the static position; else if &#39;direction&#39; is &#39;rtl&#39;, set &#39;right&#39; to the static position.
 632     // 2. If &#39;left&#39; or &#39;right&#39; are &#39;auto&#39;, replace any &#39;auto&#39; on &#39;margin-left&#39; or &#39;margin-right&#39; with &#39;0&#39;.
 633     // 3. If at this point both &#39;margin-left&#39; and &#39;margin-right&#39; are still &#39;auto&#39;, solve the equation under the extra constraint that the two margins must get equal values,
 634     //   unless this would make them negative, in which case when the direction of the containing block is &#39;ltr&#39; (&#39;rtl&#39;), set &#39;margin-left&#39; (&#39;margin-right&#39;) to zero and
 635     //   solve for &#39;margin-right&#39; (&#39;margin-left&#39;).
 636     // 4. If at this point there is an &#39;auto&#39; left, solve the equation for that value.
 637     // 5. If at this point the values are over-constrained, ignore the value for either &#39;left&#39; (in case the &#39;direction&#39; property of the containing block is &#39;rtl&#39;) or
 638     //   &#39;right&#39; (in case &#39;direction&#39; is &#39;ltr&#39;) and solve for that value.
 639 
 640     auto&amp; style = layoutBox.style();
 641     auto&amp; displayBox = layoutState.displayBoxForLayoutBox(layoutBox);
 642     auto&amp; containingBlock = *layoutBox.containingBlock();
 643     auto containingBlockWidth = usedValues.containingBlockWidth.valueOr(0);
 644     auto isLeftToRightDirection = containingBlock.style().isLeftToRightDirection();
 645 
 646     auto left = computedValueIfNotAuto(style.logicalLeft(), containingBlockWidth);
 647     auto right = computedValueIfNotAuto(style.logicalRight(), containingBlockWidth);
<a name="27" id="anc27"></a>
 648     auto computedHorizontalMargin = Geometry::computedHorizontalMargin(layoutBox, usedValues);
 649     Optional&lt;LayoutUnit&gt; usedMarginStart = computedHorizontalMargin.start;
 650     Optional&lt;LayoutUnit&gt; usedMarginEnd = computedHorizontalMargin.end;
 651     auto width = inlineReplacedWidthAndMargin(layoutState, layoutBox, usedValues).width;
 652     auto paddingLeft = displayBox.paddingLeft().valueOr(0);
 653     auto paddingRight = displayBox.paddingRight().valueOr(0);
 654     auto borderLeft = displayBox.borderLeft();
 655     auto borderRight = displayBox.borderRight();
 656 
 657     if (!left &amp;&amp; !right) {
 658         // #1
 659         auto staticHorizontalPosition = staticHorizontalPositionForOutOfFlowPositioned(layoutState, layoutBox);
 660         if (isLeftToRightDirection)
 661             left = staticHorizontalPosition;
 662         else
 663             right = staticHorizontalPosition;
 664     }
 665 
 666     if (!left || !right) {
 667         // #2
 668         usedMarginStart = computedHorizontalMargin.start.valueOr(0);
 669         usedMarginEnd = computedHorizontalMargin.end.valueOr(0);
 670     }
 671 
 672     if (!usedMarginStart &amp;&amp; !usedMarginEnd) {
 673         // #3
 674         auto marginStartAndEnd = containingBlockWidth - (*left + borderLeft + paddingLeft + width + paddingRight + borderRight + *right);
 675         if (marginStartAndEnd &gt;= 0) {
 676             usedMarginStart = marginStartAndEnd / 2;
 677             usedMarginEnd = usedMarginStart;
 678         } else {
 679             if (isLeftToRightDirection) {
 680                 usedMarginStart = 0_lu;
 681                 usedMarginEnd = containingBlockWidth - (*left + *usedMarginStart + borderLeft + paddingLeft + width + paddingRight + borderRight + *right);
 682             } else {
 683                 usedMarginEnd = 0_lu;
 684                 usedMarginStart = containingBlockWidth - (*left + borderLeft + paddingLeft + width + paddingRight + borderRight + *usedMarginEnd + *right);
 685             }
 686         }
 687     }
 688 
 689     // #4
 690     if (!left)
 691         left = containingBlockWidth - (*usedMarginStart + borderLeft + paddingLeft + width + paddingRight + borderRight + *usedMarginEnd + *right);
 692 
 693     if (!right)
 694         right = containingBlockWidth - (*left + *usedMarginStart + borderLeft + paddingLeft + width + paddingRight + borderRight + *usedMarginEnd);
 695 
 696     if (!usedMarginStart)
 697         usedMarginStart = containingBlockWidth - (*left + borderLeft + paddingLeft + width + paddingRight + borderRight + *usedMarginEnd + *right);
 698 
 699     if (!usedMarginEnd)
 700         usedMarginEnd = containingBlockWidth - (*left + *usedMarginStart + borderLeft + paddingLeft + width + paddingRight + borderRight + *right);
 701 
 702     auto boxWidth = (*left + *usedMarginStart + borderLeft + paddingLeft + width + paddingRight + borderRight + *usedMarginEnd + *right);
 703     if (boxWidth &gt; containingBlockWidth) {
 704         // #5 Over-constrained?
 705         if (isLeftToRightDirection)
 706             right = containingBlockWidth - (*left + *usedMarginStart + borderLeft + paddingLeft + width + paddingRight + borderRight + *usedMarginEnd);
 707         else
 708             left = containingBlockWidth - (*usedMarginStart + borderLeft + paddingLeft + width + paddingRight + borderRight + *usedMarginEnd + *right);
 709     }
 710 
 711     ASSERT(left);
 712     ASSERT(right);
 713     ASSERT(usedMarginStart);
 714     ASSERT(usedMarginEnd);
 715 
 716     // For out-of-flow elements the containing block is formed by the padding edge of the ancestor.
<a name="28" id="anc28"></a><span class="line-modified"> 717     // At this point the positioned value is in the coordinate system of the padding box. Let&#39;s convert it to border box coordinate system.</span>
<span class="line-modified"> 718     auto containingBlockPaddingVerticalEdge = layoutState.displayBoxForLayoutBox(containingBlock).paddingBoxLeft();</span>
<span class="line-modified"> 719     *left += containingBlockPaddingVerticalEdge;</span>
<span class="line-modified"> 720     *right += containingBlockPaddingVerticalEdge;</span>


 721 
 722     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Position][Width][Margin] -&gt; out-of-flow replaced -&gt; left(&quot; &lt;&lt; *left &lt;&lt; &quot;px) right(&quot;  &lt;&lt; *right &lt;&lt; &quot;px) width(&quot; &lt;&lt; width &lt;&lt; &quot;px) margin(&quot; &lt;&lt; *usedMarginStart &lt;&lt; &quot;px, &quot;  &lt;&lt; *usedMarginEnd &lt;&lt; &quot;px) layoutBox(&quot; &lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;);
 723     return { *left, *right, { width, { *usedMarginStart, *usedMarginEnd }, computedHorizontalMargin } };
 724 }
 725 
 726 HeightAndMargin FormattingContext::Geometry::complicatedCases(const LayoutState&amp; layoutState, const Box&amp; layoutBox, UsedVerticalValues usedValues, UsedHorizontalValues usedHorizontalValues)
 727 {
 728     ASSERT(!layoutBox.replaced());
 729     // TODO: Use complicated-case for document renderer for now (see BlockFormattingContext::Geometry::inFlowHeightAndMargin).
 730     ASSERT((layoutBox.isBlockLevelBox() &amp;&amp; layoutBox.isInFlow() &amp;&amp; !layoutBox.isOverflowVisible()) || layoutBox.isInlineBlockBox() || layoutBox.isFloatingPositioned() || layoutBox.isDocumentBox());
 731 
 732     // 10.6.6 Complicated cases
 733     //
 734     // Block-level, non-replaced elements in normal flow when &#39;overflow&#39; does not compute to &#39;visible&#39; (except if the &#39;overflow&#39; property&#39;s value has been propagated to the viewport).
 735     // &#39;Inline-block&#39;, non-replaced elements.
 736     // Floating, non-replaced elements.
 737     //
 738     // 1. If &#39;margin-top&#39;, or &#39;margin-bottom&#39; are &#39;auto&#39;, their used value is 0.
 739     // 2. If &#39;height&#39; is &#39;auto&#39;, the height depends on the element&#39;s descendants per 10.6.7.
 740 
 741     auto height = usedValues.height ? usedValues.height.value() : computedHeightValue(layoutState, layoutBox, HeightType::Normal);
 742     auto computedVerticalMargin = Geometry::computedVerticalMargin(layoutBox, usedHorizontalValues);
 743     // #1
 744     auto usedVerticalMargin = UsedVerticalMargin::NonCollapsedValues { computedVerticalMargin.before.valueOr(0), computedVerticalMargin.after.valueOr(0) };
 745     // #2
 746     if (!height) {
 747         ASSERT(isHeightAuto(layoutBox));
 748         height = contentHeightForFormattingContextRoot(layoutState, layoutBox);
 749     }
 750 
 751     ASSERT(height);
 752 
 753     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Height][Margin] -&gt; floating non-replaced -&gt; height(&quot; &lt;&lt; *height &lt;&lt; &quot;px) margin(&quot; &lt;&lt; usedVerticalMargin.before &lt;&lt; &quot;px, &quot; &lt;&lt; usedVerticalMargin.after &lt;&lt; &quot;px) -&gt; layoutBox(&quot; &lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;);
 754     return HeightAndMargin { *height, usedVerticalMargin };
 755 }
 756 
 757 WidthAndMargin FormattingContext::Geometry::floatingNonReplacedWidthAndMargin(LayoutState&amp; layoutState, const Box&amp; layoutBox, UsedHorizontalValues usedValues)
 758 {
 759     ASSERT(layoutBox.isFloatingPositioned() &amp;&amp; !layoutBox.replaced());
 760 
 761     // 10.3.5 Floating, non-replaced elements
 762     //
 763     // 1. If &#39;margin-left&#39;, or &#39;margin-right&#39; are computed as &#39;auto&#39;, their used value is &#39;0&#39;.
 764     // 2. If &#39;width&#39; is computed as &#39;auto&#39;, the used value is the &quot;shrink-to-fit&quot; width.
 765 
 766     auto computedHorizontalMargin = Geometry::computedHorizontalMargin(layoutBox, usedValues);
 767 
 768     // #1
 769     auto usedHorizontallMargin = UsedHorizontalMargin { computedHorizontalMargin.start.valueOr(0), computedHorizontalMargin.end.valueOr(0) };
 770     // #2
 771     auto width = computedValueIfNotAuto(usedValues.width ? Length { usedValues.width.value(), Fixed } : layoutBox.style().logicalWidth(), usedValues.containingBlockWidth.valueOr(0));
 772     if (!width)
 773         width = shrinkToFitWidth(layoutState, layoutBox, usedValues);
 774 
 775     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Width][Margin] -&gt; floating non-replaced -&gt; width(&quot; &lt;&lt; *width &lt;&lt; &quot;px) margin(&quot; &lt;&lt; usedHorizontallMargin.start &lt;&lt; &quot;px, &quot; &lt;&lt; usedHorizontallMargin.end &lt;&lt; &quot;px) -&gt; layoutBox(&quot; &lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;);
 776     return WidthAndMargin { *width, usedHorizontallMargin, computedHorizontalMargin };
 777 }
 778 
 779 HeightAndMargin FormattingContext::Geometry::floatingReplacedHeightAndMargin(const LayoutState&amp; layoutState, const Box&amp; layoutBox, UsedVerticalValues usedValues)
 780 {
 781     ASSERT(layoutBox.isFloatingPositioned() &amp;&amp; layoutBox.replaced());
 782 
 783     // 10.6.2 Inline replaced elements, block-level replaced elements in normal flow, &#39;inline-block&#39;
 784     // replaced elements in normal flow and floating replaced elements
 785     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Height][Margin] -&gt; floating replaced -&gt; redirected to inline replaced&quot;);
 786     return inlineReplacedHeightAndMargin(layoutState, layoutBox, usedValues);
 787 }
 788 
 789 WidthAndMargin FormattingContext::Geometry::floatingReplacedWidthAndMargin(const LayoutState&amp; layoutState, const Box&amp; layoutBox, UsedHorizontalValues usedValues)
 790 {
 791     ASSERT(layoutBox.isFloatingPositioned() &amp;&amp; layoutBox.replaced());
 792 
 793     // 10.3.6 Floating, replaced elements
 794     //
 795     // 1. If &#39;margin-left&#39; or &#39;margin-right&#39; are computed as &#39;auto&#39;, their used value is &#39;0&#39;.
 796     // 2. The used value of &#39;width&#39; is determined as for inline replaced elements.
 797     auto computedHorizontalMargin = Geometry::computedHorizontalMargin(layoutBox, usedValues);
 798 
 799     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Height][Margin] -&gt; floating replaced -&gt; redirected to inline replaced&quot;);
 800     return inlineReplacedWidthAndMargin(layoutState, layoutBox, UsedHorizontalValues { usedValues.containingBlockWidth.valueOr(0),
 801         usedValues.width, UsedHorizontalMargin { computedHorizontalMargin.start.valueOr(0), computedHorizontalMargin.end.valueOr(0) } });
 802 }
 803 
 804 VerticalGeometry FormattingContext::Geometry::outOfFlowVerticalGeometry(const LayoutState&amp; layoutState, const Box&amp; layoutBox, UsedVerticalValues usedValues)
 805 {
 806     ASSERT(layoutBox.isOutOfFlowPositioned());
 807 
 808     if (!layoutBox.replaced())
 809         return outOfFlowNonReplacedVerticalGeometry(layoutState, layoutBox, usedValues);
 810     return outOfFlowReplacedVerticalGeometry(layoutState, layoutBox, usedValues);
 811 }
 812 
 813 HorizontalGeometry FormattingContext::Geometry::outOfFlowHorizontalGeometry(LayoutState&amp; layoutState, const Box&amp; layoutBox, UsedHorizontalValues usedValues)
 814 {
 815     ASSERT(layoutBox.isOutOfFlowPositioned());
 816 
 817     if (!layoutBox.replaced())
 818         return outOfFlowNonReplacedHorizontalGeometry(layoutState, layoutBox, usedValues);
 819     return outOfFlowReplacedHorizontalGeometry(layoutState, layoutBox, usedValues);
 820 }
 821 
 822 HeightAndMargin FormattingContext::Geometry::floatingHeightAndMargin(const LayoutState&amp; layoutState, const Box&amp; layoutBox, UsedVerticalValues usedVerticalValues, UsedHorizontalValues usedHorizontalValues)
 823 {
 824     ASSERT(layoutBox.isFloatingPositioned());
 825 
 826     if (!layoutBox.replaced())
 827         return complicatedCases(layoutState, layoutBox, usedVerticalValues, usedHorizontalValues);
 828     return floatingReplacedHeightAndMargin(layoutState, layoutBox, usedVerticalValues);
 829 }
 830 
 831 WidthAndMargin FormattingContext::Geometry::floatingWidthAndMargin(LayoutState&amp; layoutState, const Box&amp; layoutBox, UsedHorizontalValues usedValues)
 832 {
 833     ASSERT(layoutBox.isFloatingPositioned());
 834 
 835     if (!layoutBox.replaced())
 836         return floatingNonReplacedWidthAndMargin(layoutState, layoutBox, usedValues);
 837     return floatingReplacedWidthAndMargin(layoutState, layoutBox, usedValues);
 838 }
 839 
 840 HeightAndMargin FormattingContext::Geometry::inlineReplacedHeightAndMargin(const LayoutState&amp; layoutState, const Box&amp; layoutBox, UsedVerticalValues usedValues)
 841 {
 842     ASSERT((layoutBox.isOutOfFlowPositioned() || layoutBox.isFloatingPositioned() || layoutBox.isInFlow()) &amp;&amp; layoutBox.replaced());
 843 
 844     // 10.6.2 Inline replaced elements, block-level replaced elements in normal flow, &#39;inline-block&#39; replaced elements in normal flow and floating replaced elements
 845     //
 846     // 1. If &#39;margin-top&#39;, or &#39;margin-bottom&#39; are &#39;auto&#39;, their used value is 0.
 847     // 2. If &#39;height&#39; and &#39;width&#39; both have computed values of &#39;auto&#39; and the element also has an intrinsic height, then that intrinsic height is the used value of &#39;height&#39;.
 848     // 3. Otherwise, if &#39;height&#39; has a computed value of &#39;auto&#39;, and the element has an intrinsic ratio then the used value of &#39;height&#39; is:
 849     //    (used width) / (intrinsic ratio)
 850     // 4. Otherwise, if &#39;height&#39; has a computed value of &#39;auto&#39;, and the element has an intrinsic height, then that intrinsic height is the used value of &#39;height&#39;.
 851     // 5. Otherwise, if &#39;height&#39; has a computed value of &#39;auto&#39;, but none of the conditions above are met, then the used value of &#39;height&#39; must be set to
 852     //    the height of the largest rectangle that has a 2:1 ratio, has a height not greater than 150px, and has a width not greater than the device width.
 853 
 854     // #1
 855     auto containingBlockWidth = layoutState.displayBoxForLayoutBox(*layoutBox.containingBlock()).contentBoxWidth();
 856     auto computedVerticalMargin = Geometry::computedVerticalMargin(layoutBox, UsedHorizontalValues { containingBlockWidth });
 857     auto usedVerticalMargin = UsedVerticalMargin::NonCollapsedValues { computedVerticalMargin.before.valueOr(0), computedVerticalMargin.after.valueOr(0) };
 858     auto&amp; style = layoutBox.style();
 859     auto replaced = layoutBox.replaced();
 860 
 861     auto height = usedValues.height ? usedValues.height.value() : computedHeightValue(layoutState, layoutBox, HeightType::Normal);
 862     auto heightIsAuto = !usedValues.height &amp;&amp; isHeightAuto(layoutBox);
 863     auto widthIsAuto = style.logicalWidth().isAuto();
 864 
 865     if (heightIsAuto &amp;&amp; widthIsAuto &amp;&amp; replaced-&gt;hasIntrinsicHeight()) {
 866         // #2
 867         height = replaced-&gt;intrinsicHeight();
 868     } else if (heightIsAuto &amp;&amp; replaced-&gt;hasIntrinsicRatio()) {
 869         // #3
 870         auto usedWidth = layoutState.displayBoxForLayoutBox(layoutBox).width();
 871         height = usedWidth / replaced-&gt;intrinsicRatio();
 872     } else if (heightIsAuto &amp;&amp; replaced-&gt;hasIntrinsicHeight()) {
 873         // #4
 874         height = replaced-&gt;intrinsicHeight();
 875     } else if (heightIsAuto) {
 876         // #5
 877         height = { 150 };
 878     }
 879 
 880     ASSERT(height);
 881 
 882     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Height][Margin] -&gt; inflow replaced -&gt; height(&quot; &lt;&lt; *height &lt;&lt; &quot;px) margin(&quot; &lt;&lt; usedVerticalMargin.before &lt;&lt; &quot;px, &quot; &lt;&lt; usedVerticalMargin.after &lt;&lt; &quot;px) -&gt; layoutBox(&quot; &lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;);
 883     return { *height, usedVerticalMargin };
 884 }
 885 
 886 WidthAndMargin FormattingContext::Geometry::inlineReplacedWidthAndMargin(const LayoutState&amp; layoutState, const Box&amp; layoutBox, UsedHorizontalValues usedValues)
 887 {
 888     ASSERT((layoutBox.isOutOfFlowPositioned() || layoutBox.isFloatingPositioned() || layoutBox.isInFlow()) &amp;&amp; layoutBox.replaced());
 889 
 890     // 10.3.2 Inline, replaced elements
 891     //
 892     // A computed value of &#39;auto&#39; for &#39;margin-left&#39; or &#39;margin-right&#39; becomes a used value of &#39;0&#39;.
 893     //
 894     // 1. If &#39;height&#39; and &#39;width&#39; both have computed values of &#39;auto&#39; and the element also has an intrinsic width, then that intrinsic width is the used value of &#39;width&#39;.
 895     //
 896     // 2. If &#39;height&#39; and &#39;width&#39; both have computed values of &#39;auto&#39; and the element has no intrinsic width, but does have an intrinsic height and intrinsic ratio;
 897     //    or if &#39;width&#39; has a computed value of &#39;auto&#39;, &#39;height&#39; has some other computed value, and the element does have an intrinsic ratio;
 898     //    then the used value of &#39;width&#39; is: (used height) * (intrinsic ratio)
 899     //
 900     // 3. If &#39;height&#39; and &#39;width&#39; both have computed values of &#39;auto&#39; and the element has an intrinsic ratio but no intrinsic height or width,
 901     //    then the used value of &#39;width&#39; is undefined in CSS 2.2. However, it is suggested that, if the containing block&#39;s width does not itself depend on the replaced
 902     //    element&#39;s width, then the used value of &#39;width&#39; is calculated from the constraint equation used for block-level, non-replaced elements in normal flow.
 903     //
 904     // 4. Otherwise, if &#39;width&#39; has a computed value of &#39;auto&#39;, and the element has an intrinsic width, then that intrinsic width is the used value of &#39;width&#39;.
 905     //
 906     // 5. Otherwise, if &#39;width&#39; has a computed value of &#39;auto&#39;, but none of the conditions above are met, then the used value of &#39;width&#39; becomes 300px.
 907     //    If 300px is too wide to fit the device, UAs should use the width of the largest rectangle that has a 2:1 ratio and fits the device instead.
 908 
 909     auto&amp; style = layoutBox.style();
 910     auto containingBlockWidth = usedValues.containingBlockWidth.valueOr(0);
 911     auto computedHorizontalMargin = Geometry::computedHorizontalMargin(layoutBox, usedValues);
 912 
 913     auto usedMarginStart = [&amp;] {
 914         if (usedValues.margin)
 915             return usedValues.margin-&gt;start;
 916         return computedHorizontalMargin.start.valueOr(0_lu);
 917     };
 918 
 919     auto usedMarginEnd = [&amp;] {
 920         if (usedValues.margin)
 921             return usedValues.margin-&gt;end;
 922         return computedHorizontalMargin.end.valueOr(0_lu);
 923     };
 924 
 925     auto replaced = layoutBox.replaced();
 926     ASSERT(replaced);
 927 
 928     auto width = computedValueIfNotAuto(usedValues.width ? Length { usedValues.width.value(), Fixed } : style.logicalWidth(), containingBlockWidth);
 929     auto heightIsAuto = isHeightAuto(layoutBox);
 930     auto height = computedHeightValue(layoutState, layoutBox, HeightType::Normal);
 931 
 932     if (!width &amp;&amp; heightIsAuto &amp;&amp; replaced-&gt;hasIntrinsicWidth()) {
 933         // #1
 934         width = replaced-&gt;intrinsicWidth();
 935     } else if ((!width &amp;&amp; heightIsAuto &amp;&amp; !replaced-&gt;hasIntrinsicWidth() &amp;&amp; replaced-&gt;hasIntrinsicHeight() &amp;&amp; replaced-&gt;hasIntrinsicRatio())
 936         || (!width &amp;&amp; height &amp;&amp; replaced-&gt;hasIntrinsicRatio())) {
 937         // #2
 938         width = height.valueOr(replaced-&gt;hasIntrinsicHeight()) * replaced-&gt;intrinsicRatio();
 939     } else if (!width &amp;&amp; heightIsAuto &amp;&amp; replaced-&gt;hasIntrinsicRatio() &amp;&amp; !replaced-&gt;hasIntrinsicWidth() &amp;&amp; !replaced-&gt;hasIntrinsicHeight()) {
 940         // #3
 941         // FIXME: undefined but surely doable.
 942         ASSERT_NOT_IMPLEMENTED_YET();
 943     } else if (!width &amp;&amp; replaced-&gt;hasIntrinsicWidth()) {
 944         // #4
 945         width = replaced-&gt;intrinsicWidth();
 946     } else if (!width) {
 947         // #5
 948         width = { 300 };
 949     }
 950 
 951     ASSERT(width);
 952 
 953     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Width][Margin] -&gt; inflow replaced -&gt; width(&quot; &lt;&lt; *width &lt;&lt; &quot;px) margin(&quot; &lt;&lt; usedMarginStart() &lt;&lt; &quot;px, &quot; &lt;&lt; usedMarginEnd() &lt;&lt; &quot;px) -&gt; layoutBox(&quot; &lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;);
 954     return { *width, { usedMarginStart(), usedMarginEnd() }, computedHorizontalMargin };
 955 }
 956 
 957 LayoutSize FormattingContext::Geometry::inFlowPositionedPositionOffset(const LayoutState&amp; layoutState, const Box&amp; layoutBox)
 958 {
 959     ASSERT(layoutBox.isInFlowPositioned());
 960 
 961     // 9.4.3 Relative positioning
 962     //
 963     // The &#39;top&#39; and &#39;bottom&#39; properties move relatively positioned element(s) up or down without changing their size.
 964     // Top&#39; moves the boxes down, and &#39;bottom&#39; moves them up. Since boxes are not split or stretched as a result of &#39;top&#39; or &#39;bottom&#39;, the used values are always: top = -bottom.
 965     //
 966     // 1. If both are &#39;auto&#39;, their used values are both &#39;0&#39;.
 967     // 2. If one of them is &#39;auto&#39;, it becomes the negative of the other.
 968     // 3. If neither is &#39;auto&#39;, &#39;bottom&#39; is ignored (i.e., the used value of &#39;bottom&#39; will be minus the value of &#39;top&#39;).
 969 
 970     auto&amp; style = layoutBox.style();
 971     auto&amp; containingBlock = *layoutBox.containingBlock();
 972     auto containingBlockWidth = layoutState.displayBoxForLayoutBox(containingBlock).contentBoxWidth();
 973 
 974     auto top = computedValueIfNotAuto(style.logicalTop(), containingBlockWidth);
 975     auto bottom = computedValueIfNotAuto(style.logicalBottom(), containingBlockWidth);
 976 
 977     if (!top &amp;&amp; !bottom) {
 978         // #1
 979         top = bottom = { 0 };
 980     } else if (!top) {
 981         // #2
 982         top = -*bottom;
 983     } else if (!bottom) {
 984         // #3
 985         bottom = -*top;
 986     } else {
 987         // #4
 988         bottom = WTF::nullopt;
 989     }
 990 
 991     // For relatively positioned elements, &#39;left&#39; and &#39;right&#39; move the box(es) horizontally, without changing their size.
 992     // &#39;Left&#39; moves the boxes to the right, and &#39;right&#39; moves them to the left.
 993     // Since boxes are not split or stretched as a result of &#39;left&#39; or &#39;right&#39;, the used values are always: left = -right.
 994     //
 995     // 1. If both &#39;left&#39; and &#39;right&#39; are &#39;auto&#39; (their initial values), the used values are &#39;0&#39; (i.e., the boxes stay in their original position).
 996     // 2. If &#39;left&#39; is &#39;auto&#39;, its used value is minus the value of &#39;right&#39; (i.e., the boxes move to the left by the value of &#39;right&#39;).
 997     // 3. If &#39;right&#39; is specified as &#39;auto&#39;, its used value is minus the value of &#39;left&#39;.
 998     // 4. If neither &#39;left&#39; nor &#39;right&#39; is &#39;auto&#39;, the position is over-constrained, and one of them has to be ignored.
 999     //    If the &#39;direction&#39; property of the containing block is &#39;ltr&#39;, the value of &#39;left&#39; wins and &#39;right&#39; becomes -&#39;left&#39;.
1000     //    If &#39;direction&#39; of the containing block is &#39;rtl&#39;, &#39;right&#39; wins and &#39;left&#39; is ignored.
1001 
1002     auto left = computedValueIfNotAuto(style.logicalLeft(), containingBlockWidth);
1003     auto right = computedValueIfNotAuto(style.logicalRight(), containingBlockWidth);
1004 
1005     if (!left &amp;&amp; !right) {
1006         // #1
1007         left = right = { 0 };
1008     } else if (!left) {
1009         // #2
1010         left = -*right;
1011     } else if (!right) {
1012         // #3
1013         right = -*left;
1014     } else {
1015         // #4
1016         auto isLeftToRightDirection = containingBlock.style().isLeftToRightDirection();
1017         if (isLeftToRightDirection)
1018             right = -*left;
1019         else
1020             left = WTF::nullopt;
1021     }
1022 
1023     ASSERT(!bottom || *top == -*bottom);
1024     ASSERT(!left || *left == -*right);
1025 
1026     auto topPositionOffset = *top;
1027     auto leftPositionOffset = left.valueOr(-*right);
1028 
1029     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Position] -&gt; positioned inflow -&gt; top offset(&quot; &lt;&lt; topPositionOffset &lt;&lt; &quot;px) left offset(&quot; &lt;&lt; leftPositionOffset &lt;&lt; &quot;px) layoutBox(&quot; &lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;);
1030     return { leftPositionOffset, topPositionOffset };
1031 }
1032 
1033 Edges FormattingContext::Geometry::computedBorder(const Box&amp; layoutBox)
1034 {
1035     auto&amp; style = layoutBox.style();
1036     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Border] -&gt; layoutBox: &quot; &lt;&lt; &amp;layoutBox);
1037     return {
<a name="29" id="anc29"></a><span class="line-modified">1038         { LayoutUnit(style.borderLeft().boxModelWidth()), LayoutUnit(style.borderRight().boxModelWidth()) },</span>
<span class="line-modified">1039         { LayoutUnit(style.borderTop().boxModelWidth()), LayoutUnit(style.borderBottom().boxModelWidth()) }</span>
1040     };
1041 }
1042 
1043 Optional&lt;Edges&gt; FormattingContext::Geometry::computedPadding(const Box&amp; layoutBox, UsedHorizontalValues usedValues)
1044 {
1045     if (!layoutBox.isPaddingApplicable())
1046         return WTF::nullopt;
1047 
1048     auto&amp; style = layoutBox.style();
1049     auto containingBlockWidth = usedValues.containingBlockWidth.valueOr(0);
1050     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Padding] -&gt; layoutBox: &quot; &lt;&lt; &amp;layoutBox);
1051     return Edges {
1052         { valueForLength(style.paddingLeft(), containingBlockWidth), valueForLength(style.paddingRight(), containingBlockWidth) },
1053         { valueForLength(style.paddingTop(), containingBlockWidth), valueForLength(style.paddingBottom(), containingBlockWidth) }
1054     };
1055 }
1056 
1057 ComputedHorizontalMargin FormattingContext::Geometry::computedHorizontalMargin(const Box&amp; layoutBox, UsedHorizontalValues usedValues)
1058 {
1059     auto&amp; style = layoutBox.style();
1060     auto containingBlockWidth = usedValues.containingBlockWidth.valueOr(0);
1061     return { computedValueIfNotAuto(style.marginStart(), containingBlockWidth), computedValueIfNotAuto(style.marginEnd(), containingBlockWidth) };
1062 }
1063 
1064 ComputedVerticalMargin FormattingContext::Geometry::computedVerticalMargin(const Box&amp; layoutBox, UsedHorizontalValues usedValues)
1065 {
1066     auto&amp; style = layoutBox.style();
1067     auto containingBlockWidth = usedValues.containingBlockWidth.valueOr(0);
1068     return { computedValueIfNotAuto(style.marginBefore(), containingBlockWidth), computedValueIfNotAuto(style.marginAfter(), containingBlockWidth) };
1069 }
1070 
1071 FormattingContext::IntrinsicWidthConstraints FormattingContext::Geometry::constrainByMinMaxWidth(const Box&amp; layoutBox, IntrinsicWidthConstraints intrinsicWidth)
1072 {
1073     auto&amp; style = layoutBox.style();
1074     auto minWidth = fixedValue(style.logicalMinWidth());
1075     auto maxWidth = fixedValue(style.logicalMaxWidth());
1076     if (!minWidth &amp;&amp; !maxWidth)
1077         return intrinsicWidth;
1078 
1079     if (maxWidth) {
1080         intrinsicWidth.minimum = std::min(*maxWidth, intrinsicWidth.minimum);
1081         intrinsicWidth.maximum = std::min(*maxWidth, intrinsicWidth.maximum);
1082     }
1083 
1084     if (minWidth) {
1085         intrinsicWidth.minimum = std::max(*minWidth, intrinsicWidth.minimum);
1086         intrinsicWidth.maximum = std::max(*minWidth, intrinsicWidth.maximum);
1087     }
1088 
1089     ASSERT(intrinsicWidth.minimum &lt;= intrinsicWidth.maximum);
1090     return intrinsicWidth;
1091 }
1092 
1093 }
1094 }
1095 #endif
<a name="30" id="anc30"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="30" type="hidden" />
</body>
</html>