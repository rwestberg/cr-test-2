<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WebCore/html/canvas/CanvasRenderingContext2DBase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2004-2017 Apple Inc. All rights reserved.
   3  * Copyright (C) 2008, 2010 Nokia Corporation and/or its subsidiary(-ies)
   4  * Copyright (C) 2007 Alp Toker &lt;alp@atoker.com&gt;
   5  * Copyright (C) 2008 Eric Seidel &lt;eric@webkit.org&gt;
   6  * Copyright (C) 2008 Dirk Schulze &lt;krit@webkit.org&gt;
   7  * Copyright (C) 2010 Torch Mobile (Beijing) Co. Ltd. All rights reserved.
   8  * Copyright (C) 2012 Intel Corporation. All rights reserved.
   9  * Copyright (C) 2013, 2014 Adobe Systems Incorporated. All rights reserved.
  10  *
  11  * Redistribution and use in source and binary forms, with or without
  12  * modification, are permitted provided that the following conditions
  13  * are met:
  14  * 1. Redistributions of source code must retain the above copyright
  15  *    notice, this list of conditions and the following disclaimer.
  16  * 2. Redistributions in binary form must reproduce the above copyright
  17  *    notice, this list of conditions and the following disclaimer in the
  18  *    documentation and/or other materials provided with the distribution.
  19  *
  20  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  21  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  23  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  24  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  25  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  26  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  27  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  28  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  29  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  30  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  31  */
  32 
  33 #include &quot;config.h&quot;
  34 #include &quot;CanvasRenderingContext2DBase.h&quot;
  35 
  36 #include &quot;BitmapImage.h&quot;
  37 #include &quot;CSSFontSelector.h&quot;
  38 #include &quot;CSSParser.h&quot;
  39 #include &quot;CSSPropertyNames.h&quot;
  40 #include &quot;CachedImage.h&quot;
  41 #include &quot;CanvasGradient.h&quot;
  42 #include &quot;CanvasPattern.h&quot;
  43 #include &quot;DOMMatrix.h&quot;
  44 #include &quot;DOMMatrix2DInit.h&quot;
  45 #include &quot;DisplayListRecorder.h&quot;
  46 #include &quot;DisplayListReplayer.h&quot;
  47 #include &quot;FloatQuad.h&quot;
  48 #include &quot;HTMLImageElement.h&quot;
  49 #include &quot;HTMLVideoElement.h&quot;
  50 #include &quot;ImageBitmap.h&quot;
  51 #include &quot;ImageBuffer.h&quot;
  52 #include &quot;ImageData.h&quot;
  53 #include &quot;Path2D.h&quot;
  54 #include &quot;RenderElement.h&quot;
  55 #include &quot;RenderImage.h&quot;
  56 #include &quot;RenderLayer.h&quot;
  57 #include &quot;RenderTheme.h&quot;
  58 #include &quot;SecurityOrigin.h&quot;
  59 #include &quot;StrokeStyleApplier.h&quot;
  60 #include &quot;StyleProperties.h&quot;
  61 #include &quot;StyleResolver.h&quot;
  62 #include &quot;TextMetrics.h&quot;
  63 #include &quot;TextRun.h&quot;
  64 #include &quot;TypedOMCSSImageValue.h&quot;
  65 #include &lt;wtf/CheckedArithmetic.h&gt;
  66 #include &lt;wtf/MathExtras.h&gt;
  67 #include &lt;wtf/NeverDestroyed.h&gt;
  68 #include &lt;wtf/text/StringBuilder.h&gt;
  69 #include &lt;wtf/text/TextStream.h&gt;
  70 
  71 namespace WebCore {
  72 
  73 using namespace HTMLNames;
  74 
  75 #if USE(CG)
  76 const ImageSmoothingQuality defaultSmoothingQuality = ImageSmoothingQuality::Low;
  77 #else
  78 const ImageSmoothingQuality defaultSmoothingQuality = ImageSmoothingQuality::Medium;
  79 #endif
  80 
  81 const int CanvasRenderingContext2DBase::DefaultFontSize = 10;
  82 const char* const CanvasRenderingContext2DBase::DefaultFontFamily = &quot;sans-serif&quot;;
  83 const char* const CanvasRenderingContext2DBase::DefaultFont = &quot;10px sans-serif&quot;;
  84 
  85 struct DisplayListDrawingContext {
  86     WTF_MAKE_FAST_ALLOCATED;
  87 public:
  88     GraphicsContext context;
  89     DisplayList::DisplayList displayList;
  90 
  91     DisplayListDrawingContext(GraphicsContext&amp; context, const FloatRect&amp; clip)
  92         : DisplayListDrawingContext(context.state(), clip)
  93     {
  94     }
  95 
  96     DisplayListDrawingContext(const GraphicsContextState&amp; state, const FloatRect&amp; clip)
  97         : context([&amp;](GraphicsContext&amp; displayListContext) {
  98             return std::make_unique&lt;DisplayList::Recorder&gt;(displayListContext, displayList, state, clip, AffineTransform());
  99         })
 100     {
 101     }
 102 };
 103 
 104 typedef HashMap&lt;const CanvasRenderingContext2DBase*, std::unique_ptr&lt;DisplayList::DisplayList&gt;&gt; ContextDisplayListHashMap;
 105 
 106 static ContextDisplayListHashMap&amp; contextDisplayListMap()
 107 {
 108     static NeverDestroyed&lt;ContextDisplayListHashMap&gt; sharedHashMap;
 109     return sharedHashMap;
 110 }
 111 
 112 class CanvasStrokeStyleApplier : public StrokeStyleApplier {
 113 public:
 114     CanvasStrokeStyleApplier(CanvasRenderingContext2DBase* canvasContext)
 115         : m_canvasContext(canvasContext)
 116     {
 117     }
 118 
 119     void strokeStyle(GraphicsContext* c) override
 120     {
 121         c-&gt;setStrokeThickness(m_canvasContext-&gt;lineWidth());
 122         c-&gt;setLineCap(m_canvasContext-&gt;getLineCap());
 123         c-&gt;setLineJoin(m_canvasContext-&gt;getLineJoin());
 124         c-&gt;setMiterLimit(m_canvasContext-&gt;miterLimit());
 125         const Vector&lt;float&gt;&amp; lineDash = m_canvasContext-&gt;getLineDash();
 126         DashArray convertedLineDash(lineDash.size());
 127         for (size_t i = 0; i &lt; lineDash.size(); ++i)
 128             convertedLineDash[i] = static_cast&lt;DashArrayElement&gt;(lineDash[i]);
 129         c-&gt;setLineDash(convertedLineDash, m_canvasContext-&gt;lineDashOffset());
 130     }
 131 
 132 private:
 133     CanvasRenderingContext2DBase* m_canvasContext;
 134 };
 135 
 136 CanvasRenderingContext2DBase::CanvasRenderingContext2DBase(CanvasBase&amp; canvas, bool usesCSSCompatibilityParseMode, bool usesDashboardCompatibilityMode)
 137     : CanvasRenderingContext(canvas)
 138     , m_stateStack(1)
 139     , m_usesCSSCompatibilityParseMode(usesCSSCompatibilityParseMode)
 140 #if ENABLE(DASHBOARD_SUPPORT)
 141     , m_usesDashboardCompatibilityMode(usesDashboardCompatibilityMode)
 142 #endif
 143 {
 144 #if !ENABLE(DASHBOARD_SUPPORT)
 145     ASSERT_UNUSED(usesDashboardCompatibilityMode, !usesDashboardCompatibilityMode);
 146 #endif
 147 }
 148 
 149 void CanvasRenderingContext2DBase::unwindStateStack()
 150 {
 151     // Ensure that the state stack in the ImageBuffer&#39;s context
 152     // is cleared before destruction, to avoid assertions in the
 153     // GraphicsContext dtor.
 154     if (size_t stackSize = m_stateStack.size()) {
 155         if (auto* context = canvasBase().existingDrawingContext()) {
 156             while (--stackSize)
 157                 context-&gt;restore();
 158         }
 159     }
 160 }
 161 
 162 CanvasRenderingContext2DBase::~CanvasRenderingContext2DBase()
 163 {
 164 #if !ASSERT_DISABLED
 165     unwindStateStack();
 166 #endif
 167 
 168     if (UNLIKELY(tracksDisplayListReplay()))
 169         contextDisplayListMap().remove(this);
 170 }
 171 
 172 bool CanvasRenderingContext2DBase::isAccelerated() const
 173 {
 174 #if USE(IOSURFACE_CANVAS_BACKING_STORE) || ENABLE(ACCELERATED_2D_CANVAS)
 175     auto* context = canvasBase().existingDrawingContext();
 176     return context &amp;&amp; context-&gt;isAcceleratedContext();
 177 #else
 178     return false;
 179 #endif
 180 }
 181 
 182 void CanvasRenderingContext2DBase::reset()
 183 {
 184     unwindStateStack();
 185     m_stateStack.resize(1);
 186     m_stateStack.first() = State();
 187     m_path.clear();
 188     m_unrealizedSaveCount = 0;
 189 
 190     m_recordingContext = nullptr;
 191 }
 192 
 193 CanvasRenderingContext2DBase::State::State()
 194     : strokeStyle(Color::black)
 195     , fillStyle(Color::black)
 196     , lineWidth(1)
 197     , lineCap(ButtCap)
 198     , lineJoin(MiterJoin)
 199     , miterLimit(10)
 200     , shadowBlur(0)
 201     , shadowColor(Color::transparent)
 202     , globalAlpha(1)
 203     , globalComposite(CompositeSourceOver)
 204     , globalBlend(BlendMode::Normal)
 205     , hasInvertibleTransform(true)
 206     , lineDashOffset(0)
 207     , imageSmoothingEnabled(true)
 208     , imageSmoothingQuality(defaultSmoothingQuality)
 209     , textAlign(StartTextAlign)
 210     , textBaseline(AlphabeticTextBaseline)
 211     , direction(Direction::Inherit)
 212     , unparsedFont(DefaultFont)
 213 {
 214 }
 215 
 216 CanvasRenderingContext2DBase::State::State(const State&amp; other)
 217     : unparsedStrokeColor(other.unparsedStrokeColor)
 218     , unparsedFillColor(other.unparsedFillColor)
 219     , strokeStyle(other.strokeStyle)
 220     , fillStyle(other.fillStyle)
 221     , lineWidth(other.lineWidth)
 222     , lineCap(other.lineCap)
 223     , lineJoin(other.lineJoin)
 224     , miterLimit(other.miterLimit)
 225     , shadowOffset(other.shadowOffset)
 226     , shadowBlur(other.shadowBlur)
 227     , shadowColor(other.shadowColor)
 228     , globalAlpha(other.globalAlpha)
 229     , globalComposite(other.globalComposite)
 230     , globalBlend(other.globalBlend)
 231     , transform(other.transform)
 232     , hasInvertibleTransform(other.hasInvertibleTransform)
 233     , lineDashOffset(other.lineDashOffset)
 234     , imageSmoothingEnabled(other.imageSmoothingEnabled)
 235     , imageSmoothingQuality(other.imageSmoothingQuality)
 236     , textAlign(other.textAlign)
 237     , textBaseline(other.textBaseline)
 238     , direction(other.direction)
 239     , unparsedFont(other.unparsedFont)
 240     , font(other.font)
 241 {
 242 }
 243 
 244 CanvasRenderingContext2DBase::State&amp; CanvasRenderingContext2DBase::State::operator=(const State&amp; other)
 245 {
 246     if (this == &amp;other)
 247         return *this;
 248 
 249     unparsedStrokeColor = other.unparsedStrokeColor;
 250     unparsedFillColor = other.unparsedFillColor;
 251     strokeStyle = other.strokeStyle;
 252     fillStyle = other.fillStyle;
 253     lineWidth = other.lineWidth;
 254     lineCap = other.lineCap;
 255     lineJoin = other.lineJoin;
 256     miterLimit = other.miterLimit;
 257     shadowOffset = other.shadowOffset;
 258     shadowBlur = other.shadowBlur;
 259     shadowColor = other.shadowColor;
 260     globalAlpha = other.globalAlpha;
 261     globalComposite = other.globalComposite;
 262     globalBlend = other.globalBlend;
 263     transform = other.transform;
 264     hasInvertibleTransform = other.hasInvertibleTransform;
 265     imageSmoothingEnabled = other.imageSmoothingEnabled;
 266     imageSmoothingQuality = other.imageSmoothingQuality;
 267     textAlign = other.textAlign;
 268     textBaseline = other.textBaseline;
 269     direction = other.direction;
 270     unparsedFont = other.unparsedFont;
 271     font = other.font;
 272 
 273     return *this;
 274 }
 275 
 276 CanvasRenderingContext2DBase::FontProxy::~FontProxy()
 277 {
 278     if (realized())
 279         m_font.fontSelector()-&gt;unregisterForInvalidationCallbacks(*this);
 280 }
 281 
 282 CanvasRenderingContext2DBase::FontProxy::FontProxy(const FontProxy&amp; other)
 283     : m_font(other.m_font)
 284 {
 285     if (realized())
 286         m_font.fontSelector()-&gt;registerForInvalidationCallbacks(*this);
 287 }
 288 
 289 auto CanvasRenderingContext2DBase::FontProxy::operator=(const FontProxy&amp; other) -&gt; FontProxy&amp;
 290 {
 291     if (realized())
 292         m_font.fontSelector()-&gt;unregisterForInvalidationCallbacks(*this);
 293 
 294     m_font = other.m_font;
 295 
 296     if (realized())
 297         m_font.fontSelector()-&gt;registerForInvalidationCallbacks(*this);
 298 
 299     return *this;
 300 }
 301 
 302 inline void CanvasRenderingContext2DBase::FontProxy::update(FontSelector&amp; selector)
 303 {
 304     ASSERT(&amp;selector == m_font.fontSelector()); // This is an invariant. We should only ever be registered for callbacks on m_font.m_fonts.m_fontSelector.
 305     if (realized())
 306         m_font.fontSelector()-&gt;unregisterForInvalidationCallbacks(*this);
 307     m_font.update(&amp;selector);
 308     if (realized())
 309         m_font.fontSelector()-&gt;registerForInvalidationCallbacks(*this);
 310     ASSERT(&amp;selector == m_font.fontSelector());
 311 }
 312 
 313 void CanvasRenderingContext2DBase::FontProxy::fontsNeedUpdate(FontSelector&amp; selector)
 314 {
 315     ASSERT_ARG(selector, &amp;selector == m_font.fontSelector());
 316     ASSERT(realized());
 317 
 318     update(selector);
 319 }
 320 
 321 inline void CanvasRenderingContext2DBase::FontProxy::initialize(FontSelector&amp; fontSelector, const RenderStyle&amp; newStyle)
 322 {
 323     // Beware! m_font.fontSelector() might not point to document.fontSelector()!
 324     ASSERT(newStyle.fontCascade().fontSelector() == &amp;fontSelector);
 325     if (realized())
 326         m_font.fontSelector()-&gt;unregisterForInvalidationCallbacks(*this);
 327     m_font = newStyle.fontCascade();
 328     m_font.update(&amp;fontSelector);
 329     ASSERT(&amp;fontSelector == m_font.fontSelector());
 330     m_font.fontSelector()-&gt;registerForInvalidationCallbacks(*this);
 331 }
 332 
 333 inline const FontMetrics&amp; CanvasRenderingContext2DBase::FontProxy::fontMetrics() const
 334 {
 335     return m_font.fontMetrics();
 336 }
 337 
 338 inline const FontCascadeDescription&amp; CanvasRenderingContext2DBase::FontProxy::fontDescription() const
 339 {
 340     return m_font.fontDescription();
 341 }
 342 
 343 inline float CanvasRenderingContext2DBase::FontProxy::width(const TextRun&amp; textRun, GlyphOverflow* overflow) const
 344 {
 345     return m_font.width(textRun, 0, overflow);
 346 }
 347 
 348 inline void CanvasRenderingContext2DBase::FontProxy::drawBidiText(GraphicsContext&amp; context, const TextRun&amp; run, const FloatPoint&amp; point, FontCascade::CustomFontNotReadyAction action) const
 349 {
 350     context.drawBidiText(m_font, run, point, action);
 351 }
 352 
 353 void CanvasRenderingContext2DBase::realizeSaves()
 354 {
 355     if (m_unrealizedSaveCount)
 356         realizeSavesLoop();
 357 
 358     if (m_unrealizedSaveCount) {
 359         static NeverDestroyed&lt;String&gt; consoleMessage(MAKE_STATIC_STRING_IMPL(&quot;CanvasRenderingContext2D.save() has been called without a matching restore() too many times. Ignoring save().&quot;));
 360 
 361         canvasBase().scriptExecutionContext()-&gt;addConsoleMessage(MessageSource::Rendering, MessageLevel::Error, consoleMessage);
 362     }
 363 }
 364 
 365 void CanvasRenderingContext2DBase::realizeSavesLoop()
 366 {
 367     ASSERT(m_unrealizedSaveCount);
 368     ASSERT(m_stateStack.size() &gt;= 1);
 369     GraphicsContext* context = drawingContext();
 370     do {
 371         if (m_stateStack.size() &gt; MaxSaveCount)
 372             break;
 373         m_stateStack.append(state());
 374         if (context)
 375             context-&gt;save();
 376     } while (--m_unrealizedSaveCount);
 377 }
 378 
 379 void CanvasRenderingContext2DBase::restore()
 380 {
 381     if (m_unrealizedSaveCount) {
 382         --m_unrealizedSaveCount;
 383         return;
 384     }
 385     ASSERT(m_stateStack.size() &gt;= 1);
 386     if (m_stateStack.size() &lt;= 1)
 387         return;
 388     m_path.transform(state().transform);
 389     m_stateStack.removeLast();
 390     if (Optional&lt;AffineTransform&gt; inverse = state().transform.inverse())
 391         m_path.transform(inverse.value());
 392     GraphicsContext* c = drawingContext();
 393     if (!c)
 394         return;
 395     c-&gt;restore();
 396 }
 397 
 398 void CanvasRenderingContext2DBase::setStrokeStyle(CanvasStyle style)
 399 {
 400     if (!style.isValid())
 401         return;
 402 
 403     if (state().strokeStyle.isValid() &amp;&amp; state().strokeStyle.isEquivalentColor(style))
 404         return;
 405 
 406     if (style.isCurrentColor() &amp;&amp; is&lt;HTMLCanvasElement&gt;(canvasBase())) {
 407         auto&amp; canvas = downcast&lt;HTMLCanvasElement&gt;(canvasBase());
 408 
 409         if (style.hasOverrideAlpha()) {
 410             // FIXME: Should not use RGBA32 here.
 411             style = CanvasStyle(colorWithOverrideAlpha(currentColor(&amp;canvas).rgb(), style.overrideAlpha()));
 412         } else
 413             style = CanvasStyle(currentColor(&amp;canvas));
 414     } else
 415         checkOrigin(style.canvasPattern().get());
 416 
 417     realizeSaves();
 418     State&amp; state = modifiableState();
 419     state.strokeStyle = style;
 420     GraphicsContext* c = drawingContext();
 421     if (!c)
 422         return;
 423     state.strokeStyle.applyStrokeColor(*c);
 424     state.unparsedStrokeColor = String();
 425 }
 426 
 427 void CanvasRenderingContext2DBase::setFillStyle(CanvasStyle style)
 428 {
 429     if (!style.isValid())
 430         return;
 431 
 432     if (state().fillStyle.isValid() &amp;&amp; state().fillStyle.isEquivalentColor(style))
 433         return;
 434 
 435     if (style.isCurrentColor() &amp;&amp; is&lt;HTMLCanvasElement&gt;(canvasBase())) {
 436         auto&amp; canvas = downcast&lt;HTMLCanvasElement&gt;(canvasBase());
 437 
 438         if (style.hasOverrideAlpha()) {
 439             // FIXME: Should not use RGBA32 here.
 440             style = CanvasStyle(colorWithOverrideAlpha(currentColor(&amp;canvas).rgb(), style.overrideAlpha()));
 441         } else
 442             style = CanvasStyle(currentColor(&amp;canvas));
 443     } else
 444         checkOrigin(style.canvasPattern().get());
 445 
 446     realizeSaves();
 447     State&amp; state = modifiableState();
 448     state.fillStyle = style;
 449     GraphicsContext* c = drawingContext();
 450     if (!c)
 451         return;
 452     state.fillStyle.applyFillColor(*c);
 453     state.unparsedFillColor = String();
 454 }
 455 
 456 float CanvasRenderingContext2DBase::lineWidth() const
 457 {
 458     return state().lineWidth;
 459 }
 460 
 461 void CanvasRenderingContext2DBase::setLineWidth(float width)
 462 {
 463     if (!(std::isfinite(width) &amp;&amp; width &gt; 0))
 464         return;
 465     if (state().lineWidth == width)
 466         return;
 467     realizeSaves();
 468     modifiableState().lineWidth = width;
 469     GraphicsContext* c = drawingContext();
 470     if (!c)
 471         return;
 472     c-&gt;setStrokeThickness(width);
 473 }
 474 
 475 static CanvasLineCap toCanvasLineCap(LineCap lineCap)
 476 {
 477     switch (lineCap) {
 478     case ButtCap:
 479         return CanvasLineCap::Butt;
 480     case RoundCap:
 481         return CanvasLineCap::Round;
 482     case SquareCap:
 483         return CanvasLineCap::Square;
 484     }
 485 
 486     ASSERT_NOT_REACHED();
 487     return CanvasLineCap::Butt;
 488 }
 489 
 490 static LineCap fromCanvasLineCap(CanvasLineCap canvasLineCap)
 491 {
 492     switch (canvasLineCap) {
 493     case CanvasLineCap::Butt:
 494         return ButtCap;
 495     case CanvasLineCap::Round:
 496         return RoundCap;
 497     case CanvasLineCap::Square:
 498         return SquareCap;
 499     }
 500 
 501     ASSERT_NOT_REACHED();
 502     return ButtCap;
 503 }
 504 
 505 CanvasLineCap CanvasRenderingContext2DBase::lineCap() const
 506 {
 507     return toCanvasLineCap(state().lineCap);
 508 }
 509 
 510 void CanvasRenderingContext2DBase::setLineCap(CanvasLineCap canvasLineCap)
 511 {
 512     auto lineCap = fromCanvasLineCap(canvasLineCap);
 513     if (state().lineCap == lineCap)
 514         return;
 515     realizeSaves();
 516     modifiableState().lineCap = lineCap;
 517     GraphicsContext* c = drawingContext();
 518     if (!c)
 519         return;
 520     c-&gt;setLineCap(lineCap);
 521 }
 522 
 523 void CanvasRenderingContext2DBase::setLineCap(const String&amp; stringValue)
 524 {
 525     CanvasLineCap cap;
 526     if (stringValue == &quot;butt&quot;)
 527         cap = CanvasLineCap::Butt;
 528     else if (stringValue == &quot;round&quot;)
 529         cap = CanvasLineCap::Round;
 530     else if (stringValue == &quot;square&quot;)
 531         cap = CanvasLineCap::Square;
 532     else
 533         return;
 534 
 535     setLineCap(cap);
 536 }
 537 
 538 static CanvasLineJoin toCanvasLineJoin(LineJoin lineJoin)
 539 {
 540     switch (lineJoin) {
 541     case RoundJoin:
 542         return CanvasLineJoin::Round;
 543     case BevelJoin:
 544         return CanvasLineJoin::Bevel;
 545     case MiterJoin:
 546         return CanvasLineJoin::Miter;
 547     }
 548 
 549     ASSERT_NOT_REACHED();
 550     return CanvasLineJoin::Round;
 551 }
 552 
 553 static LineJoin fromCanvasLineJoin(CanvasLineJoin canvasLineJoin)
 554 {
 555     switch (canvasLineJoin) {
 556     case CanvasLineJoin::Round:
 557         return RoundJoin;
 558     case CanvasLineJoin::Bevel:
 559         return BevelJoin;
 560     case CanvasLineJoin::Miter:
 561         return MiterJoin;
 562     }
 563 
 564     ASSERT_NOT_REACHED();
 565     return RoundJoin;
 566 }
 567 
 568 CanvasLineJoin CanvasRenderingContext2DBase::lineJoin() const
 569 {
 570     return toCanvasLineJoin(state().lineJoin);
 571 }
 572 
 573 void CanvasRenderingContext2DBase::setLineJoin(CanvasLineJoin canvasLineJoin)
 574 {
 575     auto lineJoin = fromCanvasLineJoin(canvasLineJoin);
 576     if (state().lineJoin == lineJoin)
 577         return;
 578     realizeSaves();
 579     modifiableState().lineJoin = lineJoin;
 580     GraphicsContext* c = drawingContext();
 581     if (!c)
 582         return;
 583     c-&gt;setLineJoin(lineJoin);
 584 }
 585 
 586 void CanvasRenderingContext2DBase::setLineJoin(const String&amp; stringValue)
 587 {
 588     CanvasLineJoin join;
 589     if (stringValue == &quot;round&quot;)
 590         join = CanvasLineJoin::Round;
 591     else if (stringValue == &quot;bevel&quot;)
 592         join = CanvasLineJoin::Bevel;
 593     else if (stringValue == &quot;miter&quot;)
 594         join = CanvasLineJoin::Miter;
 595     else
 596         return;
 597 
 598     setLineJoin(join);
 599 }
 600 
 601 float CanvasRenderingContext2DBase::miterLimit() const
 602 {
 603     return state().miterLimit;
 604 }
 605 
 606 void CanvasRenderingContext2DBase::setMiterLimit(float limit)
 607 {
 608     if (!(std::isfinite(limit) &amp;&amp; limit &gt; 0))
 609         return;
 610     if (state().miterLimit == limit)
 611         return;
 612     realizeSaves();
 613     modifiableState().miterLimit = limit;
 614     GraphicsContext* c = drawingContext();
 615     if (!c)
 616         return;
 617     c-&gt;setMiterLimit(limit);
 618 }
 619 
 620 float CanvasRenderingContext2DBase::shadowOffsetX() const
 621 {
 622     return state().shadowOffset.width();
 623 }
 624 
 625 void CanvasRenderingContext2DBase::setShadowOffsetX(float x)
 626 {
 627     if (!std::isfinite(x))
 628         return;
 629     if (state().shadowOffset.width() == x)
 630         return;
 631     realizeSaves();
 632     modifiableState().shadowOffset.setWidth(x);
 633     applyShadow();
 634 }
 635 
 636 float CanvasRenderingContext2DBase::shadowOffsetY() const
 637 {
 638     return state().shadowOffset.height();
 639 }
 640 
 641 void CanvasRenderingContext2DBase::setShadowOffsetY(float y)
 642 {
 643     if (!std::isfinite(y))
 644         return;
 645     if (state().shadowOffset.height() == y)
 646         return;
 647     realizeSaves();
 648     modifiableState().shadowOffset.setHeight(y);
 649     applyShadow();
 650 }
 651 
 652 float CanvasRenderingContext2DBase::shadowBlur() const
 653 {
 654     return state().shadowBlur;
 655 }
 656 
 657 void CanvasRenderingContext2DBase::setShadowBlur(float blur)
 658 {
 659     if (!(std::isfinite(blur) &amp;&amp; blur &gt;= 0))
 660         return;
 661     if (state().shadowBlur == blur)
 662         return;
 663     realizeSaves();
 664     modifiableState().shadowBlur = blur;
 665     applyShadow();
 666 }
 667 
 668 String CanvasRenderingContext2DBase::shadowColor() const
 669 {
 670     return Color(state().shadowColor).serialized();
 671 }
 672 
 673 void CanvasRenderingContext2DBase::setShadowColor(const String&amp; colorString)
 674 {
 675     auto&amp; canvas = downcast&lt;HTMLCanvasElement&gt;(canvasBase());
 676     Color color = parseColorOrCurrentColor(colorString, &amp;canvas);
 677     if (!color.isValid())
 678         return;
 679     if (state().shadowColor == color)
 680         return;
 681     realizeSaves();
 682     modifiableState().shadowColor = color;
 683     applyShadow();
 684 }
 685 
 686 const Vector&lt;float&gt;&amp; CanvasRenderingContext2DBase::getLineDash() const
 687 {
 688     return state().lineDash;
 689 }
 690 
 691 static bool lineDashSequenceIsValid(const Vector&lt;float&gt;&amp; dash)
 692 {
 693     for (size_t i = 0; i &lt; dash.size(); i++) {
 694         if (!std::isfinite(dash[i]) || dash[i] &lt; 0)
 695             return false;
 696     }
 697     return true;
 698 }
 699 
 700 void CanvasRenderingContext2DBase::setLineDash(const Vector&lt;float&gt;&amp; dash)
 701 {
 702     if (!lineDashSequenceIsValid(dash))
 703         return;
 704 
 705     realizeSaves();
 706     modifiableState().lineDash = dash;
 707     // Spec requires the concatenation of two copies the dash list when the
 708     // number of elements is odd
 709     if (dash.size() % 2)
 710         modifiableState().lineDash.appendVector(dash);
 711 
 712     applyLineDash();
 713 }
 714 
 715 void CanvasRenderingContext2DBase::setWebkitLineDash(const Vector&lt;float&gt;&amp; dash)
 716 {
 717     if (!lineDashSequenceIsValid(dash))
 718         return;
 719 
 720     realizeSaves();
 721     modifiableState().lineDash = dash;
 722 
 723     applyLineDash();
 724 }
 725 
 726 float CanvasRenderingContext2DBase::lineDashOffset() const
 727 {
 728     return state().lineDashOffset;
 729 }
 730 
 731 void CanvasRenderingContext2DBase::setLineDashOffset(float offset)
 732 {
 733     if (!std::isfinite(offset) || state().lineDashOffset == offset)
 734         return;
 735 
 736     realizeSaves();
 737     modifiableState().lineDashOffset = offset;
 738     applyLineDash();
 739 }
 740 
 741 void CanvasRenderingContext2DBase::applyLineDash() const
 742 {
 743     GraphicsContext* c = drawingContext();
 744     if (!c)
 745         return;
 746     DashArray convertedLineDash(state().lineDash.size());
 747     for (size_t i = 0; i &lt; state().lineDash.size(); ++i)
 748         convertedLineDash[i] = static_cast&lt;DashArrayElement&gt;(state().lineDash[i]);
 749     c-&gt;setLineDash(convertedLineDash, state().lineDashOffset);
 750 }
 751 
 752 float CanvasRenderingContext2DBase::globalAlpha() const
 753 {
 754     return state().globalAlpha;
 755 }
 756 
 757 void CanvasRenderingContext2DBase::setGlobalAlpha(float alpha)
 758 {
 759     if (!(alpha &gt;= 0 &amp;&amp; alpha &lt;= 1))
 760         return;
 761     if (state().globalAlpha == alpha)
 762         return;
 763     realizeSaves();
 764     modifiableState().globalAlpha = alpha;
 765     GraphicsContext* c = drawingContext();
 766     if (!c)
 767         return;
 768     c-&gt;setAlpha(alpha);
 769 }
 770 
 771 String CanvasRenderingContext2DBase::globalCompositeOperation() const
 772 {
 773     return compositeOperatorName(state().globalComposite, state().globalBlend);
 774 }
 775 
 776 void CanvasRenderingContext2DBase::setGlobalCompositeOperation(const String&amp; operation)
 777 {
 778     CompositeOperator op = CompositeSourceOver;
 779     BlendMode blendMode = BlendMode::Normal;
 780     if (!parseCompositeAndBlendOperator(operation, op, blendMode))
 781         return;
 782     if ((state().globalComposite == op) &amp;&amp; (state().globalBlend == blendMode))
 783         return;
 784     realizeSaves();
 785     modifiableState().globalComposite = op;
 786     modifiableState().globalBlend = blendMode;
 787     GraphicsContext* c = drawingContext();
 788     if (!c)
 789         return;
 790     c-&gt;setCompositeOperation(op, blendMode);
 791 }
 792 
 793 void CanvasRenderingContext2DBase::scale(float sx, float sy)
 794 {
 795     GraphicsContext* c = drawingContext();
 796     if (!c)
 797         return;
 798     if (!state().hasInvertibleTransform)
 799         return;
 800 
 801     if (!std::isfinite(sx) || !std::isfinite(sy))
 802         return;
 803 
 804     AffineTransform newTransform = state().transform;
 805     newTransform.scaleNonUniform(sx, sy);
 806     if (state().transform == newTransform)
 807         return;
 808 
 809     realizeSaves();
 810 
 811     if (!sx || !sy) {
 812         modifiableState().hasInvertibleTransform = false;
 813         return;
 814     }
 815 
 816     modifiableState().transform = newTransform;
 817     c-&gt;scale(FloatSize(sx, sy));
 818     m_path.transform(AffineTransform().scaleNonUniform(1.0 / sx, 1.0 / sy));
 819 }
 820 
 821 void CanvasRenderingContext2DBase::rotate(float angleInRadians)
 822 {
 823     GraphicsContext* c = drawingContext();
 824     if (!c)
 825         return;
 826     if (!state().hasInvertibleTransform)
 827         return;
 828 
 829     if (!std::isfinite(angleInRadians))
 830         return;
 831 
 832     AffineTransform newTransform = state().transform;
 833     newTransform.rotate(angleInRadians / piDouble * 180.0);
 834     if (state().transform == newTransform)
 835         return;
 836 
 837     realizeSaves();
 838 
 839     modifiableState().transform = newTransform;
 840     c-&gt;rotate(angleInRadians);
 841     m_path.transform(AffineTransform().rotate(-angleInRadians / piDouble * 180.0));
 842 }
 843 
 844 void CanvasRenderingContext2DBase::translate(float tx, float ty)
 845 {
 846     GraphicsContext* c = drawingContext();
 847     if (!c)
 848         return;
 849     if (!state().hasInvertibleTransform)
 850         return;
 851 
 852     if (!std::isfinite(tx) | !std::isfinite(ty))
 853         return;
 854 
 855     AffineTransform newTransform = state().transform;
 856     newTransform.translate(tx, ty);
 857     if (state().transform == newTransform)
 858         return;
 859 
 860     realizeSaves();
 861 
 862     modifiableState().transform = newTransform;
 863     c-&gt;translate(tx, ty);
 864     m_path.transform(AffineTransform().translate(-tx, -ty));
 865 }
 866 
 867 void CanvasRenderingContext2DBase::transform(float m11, float m12, float m21, float m22, float dx, float dy)
 868 {
 869     GraphicsContext* c = drawingContext();
 870     if (!c)
 871         return;
 872     if (!state().hasInvertibleTransform)
 873         return;
 874 
 875     if (!std::isfinite(m11) | !std::isfinite(m21) | !std::isfinite(dx) | !std::isfinite(m12) | !std::isfinite(m22) | !std::isfinite(dy))
 876         return;
 877 
 878     AffineTransform transform(m11, m12, m21, m22, dx, dy);
 879     AffineTransform newTransform = state().transform * transform;
 880     if (state().transform == newTransform)
 881         return;
 882 
 883     realizeSaves();
 884 
 885     if (auto inverse = transform.inverse()) {
 886         modifiableState().transform = newTransform;
 887         c-&gt;concatCTM(transform);
 888         m_path.transform(inverse.value());
 889         return;
 890     }
 891     modifiableState().hasInvertibleTransform = false;
 892 }
 893 
 894 Ref&lt;DOMMatrix&gt; CanvasRenderingContext2DBase::getTransform() const
 895 {
 896     return DOMMatrix::create(state().transform.toTransformationMatrix(), DOMMatrixReadOnly::Is2D::Yes);
 897 }
 898 
 899 void CanvasRenderingContext2DBase::setTransform(float m11, float m12, float m21, float m22, float dx, float dy)
 900 {
 901     GraphicsContext* c = drawingContext();
 902     if (!c)
 903         return;
 904 
 905     if (!std::isfinite(m11) | !std::isfinite(m21) | !std::isfinite(dx) | !std::isfinite(m12) | !std::isfinite(m22) | !std::isfinite(dy))
 906         return;
 907 
 908     resetTransform();
 909     transform(m11, m12, m21, m22, dx, dy);
 910 }
 911 
 912 ExceptionOr&lt;void&gt; CanvasRenderingContext2DBase::setTransform(DOMMatrix2DInit&amp;&amp; matrixInit)
 913 {
 914     auto checkValid = DOMMatrixReadOnly::validateAndFixup(matrixInit);
 915     if (checkValid.hasException())
 916         return checkValid.releaseException();
 917 
 918     setTransform(matrixInit.a.valueOr(1), matrixInit.b.valueOr(0), matrixInit.c.valueOr(0), matrixInit.d.valueOr(1), matrixInit.e.valueOr(0), matrixInit.f.valueOr(0));
 919     return { };
 920 }
 921 
 922 void CanvasRenderingContext2DBase::resetTransform()
 923 {
 924     GraphicsContext* c = drawingContext();
 925     if (!c)
 926         return;
 927 
 928     AffineTransform ctm = state().transform;
 929     bool hasInvertibleTransform = state().hasInvertibleTransform;
 930 
 931     realizeSaves();
 932 
 933     c-&gt;setCTM(canvasBase().baseTransform());
 934     modifiableState().transform = AffineTransform();
 935 
 936     if (hasInvertibleTransform)
 937         m_path.transform(ctm);
 938 
 939     modifiableState().hasInvertibleTransform = true;
 940 }
 941 
 942 void CanvasRenderingContext2DBase::setStrokeColor(const String&amp; color, Optional&lt;float&gt; alpha)
 943 {
 944     if (alpha) {
 945         setStrokeStyle(CanvasStyle::createFromStringWithOverrideAlpha(color, alpha.value()));
 946         return;
 947     }
 948 
 949     if (color == state().unparsedStrokeColor)
 950         return;
 951 
 952     realizeSaves();
 953     setStrokeStyle(CanvasStyle::createFromString(color));
 954     modifiableState().unparsedStrokeColor = color;
 955 }
 956 
 957 void CanvasRenderingContext2DBase::setStrokeColor(float grayLevel, float alpha)
 958 {
 959     if (state().strokeStyle.isValid() &amp;&amp; state().strokeStyle.isEquivalentRGBA(grayLevel, grayLevel, grayLevel, alpha))
 960         return;
 961     setStrokeStyle(CanvasStyle(grayLevel, alpha));
 962 }
 963 
 964 void CanvasRenderingContext2DBase::setStrokeColor(float r, float g, float b, float a)
 965 {
 966     if (state().strokeStyle.isValid() &amp;&amp; state().strokeStyle.isEquivalentRGBA(r, g, b, a))
 967         return;
 968     setStrokeStyle(CanvasStyle(r, g, b, a));
 969 }
 970 
 971 void CanvasRenderingContext2DBase::setStrokeColor(float c, float m, float y, float k, float a)
 972 {
 973     if (state().strokeStyle.isValid() &amp;&amp; state().strokeStyle.isEquivalentCMYKA(c, m, y, k, a))
 974         return;
 975     setStrokeStyle(CanvasStyle(c, m, y, k, a));
 976 }
 977 
 978 void CanvasRenderingContext2DBase::setFillColor(const String&amp; color, Optional&lt;float&gt; alpha)
 979 {
 980     if (alpha) {
 981         setFillStyle(CanvasStyle::createFromStringWithOverrideAlpha(color, alpha.value()));
 982         return;
 983     }
 984 
 985     if (color == state().unparsedFillColor)
 986         return;
 987 
 988     realizeSaves();
 989     setFillStyle(CanvasStyle::createFromString(color));
 990     modifiableState().unparsedFillColor = color;
 991 }
 992 
 993 void CanvasRenderingContext2DBase::setFillColor(float grayLevel, float alpha)
 994 {
 995     if (state().fillStyle.isValid() &amp;&amp; state().fillStyle.isEquivalentRGBA(grayLevel, grayLevel, grayLevel, alpha))
 996         return;
 997     setFillStyle(CanvasStyle(grayLevel, alpha));
 998 }
 999 
1000 void CanvasRenderingContext2DBase::setFillColor(float r, float g, float b, float a)
1001 {
1002     if (state().fillStyle.isValid() &amp;&amp; state().fillStyle.isEquivalentRGBA(r, g, b, a))
1003         return;
1004     setFillStyle(CanvasStyle(r, g, b, a));
1005 }
1006 
1007 void CanvasRenderingContext2DBase::setFillColor(float c, float m, float y, float k, float a)
1008 {
1009     if (state().fillStyle.isValid() &amp;&amp; state().fillStyle.isEquivalentCMYKA(c, m, y, k, a))
1010         return;
1011     setFillStyle(CanvasStyle(c, m, y, k, a));
1012 }
1013 
1014 void CanvasRenderingContext2DBase::beginPath()
1015 {
1016     m_path.clear();
1017 }
1018 
1019 static bool validateRectForCanvas(float&amp; x, float&amp; y, float&amp; width, float&amp; height)
1020 {
1021     if (!std::isfinite(x) | !std::isfinite(y) | !std::isfinite(width) | !std::isfinite(height))
1022         return false;
1023 
1024     if (!width &amp;&amp; !height)
1025         return false;
1026 
1027     if (width &lt; 0) {
1028         width = -width;
1029         x -= width;
1030     }
1031 
1032     if (height &lt; 0) {
1033         height = -height;
1034         y -= height;
1035     }
1036 
1037     return true;
1038 }
1039 
1040 bool CanvasRenderingContext2DBase::isFullCanvasCompositeMode(CompositeOperator op)
1041 {
1042     // See 4.8.11.1.3 Compositing
1043     // CompositeSourceAtop and CompositeDestinationOut are not listed here as the platforms already
1044     // implement the specification&#39;s behavior.
1045     return op == CompositeSourceIn || op == CompositeSourceOut || op == CompositeDestinationIn || op == CompositeDestinationAtop;
1046 }
1047 
1048 static WindRule toWindRule(CanvasFillRule rule)
1049 {
1050     return rule == CanvasFillRule::Nonzero ? WindRule::NonZero : WindRule::EvenOdd;
1051 }
1052 
1053 void CanvasRenderingContext2DBase::fill(CanvasFillRule windingRule)
1054 {
1055     fillInternal(m_path, windingRule);
1056     clearPathForDashboardBackwardCompatibilityMode();
1057 }
1058 
1059 void CanvasRenderingContext2DBase::stroke()
1060 {
1061     strokeInternal(m_path);
1062     clearPathForDashboardBackwardCompatibilityMode();
1063 }
1064 
1065 void CanvasRenderingContext2DBase::clip(CanvasFillRule windingRule)
1066 {
1067     clipInternal(m_path, windingRule);
1068     clearPathForDashboardBackwardCompatibilityMode();
1069 }
1070 
1071 void CanvasRenderingContext2DBase::fill(Path2D&amp; path, CanvasFillRule windingRule)
1072 {
1073     fillInternal(path.path(), windingRule);
1074 }
1075 
1076 void CanvasRenderingContext2DBase::stroke(Path2D&amp; path)
1077 {
1078     strokeInternal(path.path());
1079 }
1080 
1081 void CanvasRenderingContext2DBase::clip(Path2D&amp; path, CanvasFillRule windingRule)
1082 {
1083     clipInternal(path.path(), windingRule);
1084 }
1085 
1086 void CanvasRenderingContext2DBase::fillInternal(const Path&amp; path, CanvasFillRule windingRule)
1087 {
1088     auto* c = drawingContext();
1089     if (!c)
1090         return;
1091     if (!state().hasInvertibleTransform)
1092         return;
1093 
1094     // If gradient size is zero, then paint nothing.
1095     auto gradient = c-&gt;fillGradient();
1096     if (gradient &amp;&amp; gradient-&gt;isZeroSize())
1097         return;
1098 
1099     if (!path.isEmpty()) {
1100         auto savedFillRule = c-&gt;fillRule();
1101         c-&gt;setFillRule(toWindRule(windingRule));
1102 
1103         if (isFullCanvasCompositeMode(state().globalComposite)) {
1104             beginCompositeLayer();
1105             c-&gt;fillPath(path);
1106             endCompositeLayer();
1107             didDrawEntireCanvas();
1108         } else if (state().globalComposite == CompositeCopy) {
1109             clearCanvas();
1110             c-&gt;fillPath(path);
1111             didDrawEntireCanvas();
1112         } else {
1113             c-&gt;fillPath(path);
1114             didDraw(path.fastBoundingRect());
1115         }
1116 
1117         c-&gt;setFillRule(savedFillRule);
1118     }
1119 }
1120 
1121 void CanvasRenderingContext2DBase::strokeInternal(const Path&amp; path)
1122 {
1123     auto* c = drawingContext();
1124     if (!c)
1125         return;
1126     if (!state().hasInvertibleTransform)
1127         return;
1128 
1129     // If gradient size is zero, then paint nothing.
1130     auto gradient = c-&gt;strokeGradient();
1131     if (gradient &amp;&amp; gradient-&gt;isZeroSize())
1132         return;
1133 
1134     if (!path.isEmpty()) {
1135         if (isFullCanvasCompositeMode(state().globalComposite)) {
1136             beginCompositeLayer();
1137             c-&gt;strokePath(path);
1138             endCompositeLayer();
1139             didDrawEntireCanvas();
1140         } else if (state().globalComposite == CompositeCopy) {
1141             clearCanvas();
1142             c-&gt;strokePath(path);
1143             didDrawEntireCanvas();
1144         } else {
1145             FloatRect dirtyRect = path.fastBoundingRect();
1146             inflateStrokeRect(dirtyRect);
1147             c-&gt;strokePath(path);
1148             didDraw(dirtyRect);
1149         }
1150     }
1151 }
1152 
1153 void CanvasRenderingContext2DBase::clipInternal(const Path&amp; path, CanvasFillRule windingRule)
1154 {
1155     auto* c = drawingContext();
1156     if (!c)
1157         return;
1158     if (!state().hasInvertibleTransform)
1159         return;
1160 
1161     realizeSaves();
1162     c-&gt;canvasClip(path, toWindRule(windingRule));
1163 }
1164 
1165 inline void CanvasRenderingContext2DBase::beginCompositeLayer()
1166 {
1167 #if !USE(CAIRO)
1168     drawingContext()-&gt;beginTransparencyLayer(1);
1169 #endif
1170 }
1171 
1172 inline void CanvasRenderingContext2DBase::endCompositeLayer()
1173 {
1174 #if !USE(CAIRO)
1175     drawingContext()-&gt;endTransparencyLayer();
1176 #endif
1177 }
1178 
1179 bool CanvasRenderingContext2DBase::isPointInPath(float x, float y, CanvasFillRule windingRule)
1180 {
1181     return isPointInPathInternal(m_path, x, y, windingRule);
1182 }
1183 
1184 bool CanvasRenderingContext2DBase::isPointInStroke(float x, float y)
1185 {
1186     return isPointInStrokeInternal(m_path, x, y);
1187 }
1188 
1189 bool CanvasRenderingContext2DBase::isPointInPath(Path2D&amp; path, float x, float y, CanvasFillRule windingRule)
1190 {
1191     return isPointInPathInternal(path.path(), x, y, windingRule);
1192 }
1193 
1194 bool CanvasRenderingContext2DBase::isPointInStroke(Path2D&amp; path, float x, float y)
1195 {
1196     return isPointInStrokeInternal(path.path(), x, y);
1197 }
1198 
1199 bool CanvasRenderingContext2DBase::isPointInPathInternal(const Path&amp; path, float x, float y, CanvasFillRule windingRule)
1200 {
1201     auto* c = drawingContext();
1202     if (!c)
1203         return false;
1204     if (!state().hasInvertibleTransform)
1205         return false;
1206 
1207     auto transformedPoint = state().transform.inverse().valueOr(AffineTransform()).mapPoint(FloatPoint(x, y));
1208 
1209     if (!std::isfinite(transformedPoint.x()) || !std::isfinite(transformedPoint.y()))
1210         return false;
1211 
1212     return path.contains(transformedPoint, toWindRule(windingRule));
1213 }
1214 
1215 bool CanvasRenderingContext2DBase::isPointInStrokeInternal(const Path&amp; path, float x, float y)
1216 {
1217     auto* c = drawingContext();
1218     if (!c)
1219         return false;
1220     if (!state().hasInvertibleTransform)
1221         return false;
1222 
1223     auto transformedPoint = state().transform.inverse().valueOr(AffineTransform()).mapPoint(FloatPoint(x, y));
1224     if (!std::isfinite(transformedPoint.x()) || !std::isfinite(transformedPoint.y()))
1225         return false;
1226 
1227     CanvasStrokeStyleApplier applier(this);
1228     return path.strokeContains(&amp;applier, transformedPoint);
1229 }
1230 
1231 void CanvasRenderingContext2DBase::clearRect(float x, float y, float width, float height)
1232 {
1233     if (!validateRectForCanvas(x, y, width, height))
1234         return;
1235     auto* context = drawingContext();
1236     if (!context)
1237         return;
1238     if (!state().hasInvertibleTransform)
1239         return;
1240     FloatRect rect(x, y, width, height);
1241 
1242     bool saved = false;
1243     if (shouldDrawShadows()) {
1244         context-&gt;save();
1245         saved = true;
1246         context-&gt;setLegacyShadow(FloatSize(), 0, Color::transparent);
1247     }
1248     if (state().globalAlpha != 1) {
1249         if (!saved) {
1250             context-&gt;save();
1251             saved = true;
1252         }
1253         context-&gt;setAlpha(1);
1254     }
1255     if (state().globalComposite != CompositeSourceOver) {
1256         if (!saved) {
1257             context-&gt;save();
1258             saved = true;
1259         }
1260         context-&gt;setCompositeOperation(CompositeSourceOver);
1261     }
1262     context-&gt;clearRect(rect);
1263     if (saved)
1264         context-&gt;restore();
1265     didDraw(rect);
1266 }
1267 
1268 void CanvasRenderingContext2DBase::fillRect(float x, float y, float width, float height)
1269 {
1270     if (!validateRectForCanvas(x, y, width, height))
1271         return;
1272 
1273     auto* c = drawingContext();
1274     if (!c)
1275         return;
1276     if (!state().hasInvertibleTransform)
1277         return;
1278 
1279     // from the HTML5 Canvas spec:
1280     // If x0 = x1 and y0 = y1, then the linear gradient must paint nothing
1281     // If x0 = x1 and y0 = y1 and r0 = r1, then the radial gradient must paint nothing
1282     auto gradient = c-&gt;fillGradient();
1283     if (gradient &amp;&amp; gradient-&gt;isZeroSize())
1284         return;
1285 
1286     FloatRect rect(x, y, width, height);
1287 
1288     if (rectContainsCanvas(rect)) {
1289         c-&gt;fillRect(rect);
1290         didDrawEntireCanvas();
1291     } else if (isFullCanvasCompositeMode(state().globalComposite)) {
1292         beginCompositeLayer();
1293         c-&gt;fillRect(rect);
1294         endCompositeLayer();
1295         didDrawEntireCanvas();
1296     } else if (state().globalComposite == CompositeCopy) {
1297         clearCanvas();
1298         c-&gt;fillRect(rect);
1299         didDrawEntireCanvas();
1300     } else {
1301         c-&gt;fillRect(rect);
1302         didDraw(rect);
1303     }
1304 }
1305 
1306 void CanvasRenderingContext2DBase::strokeRect(float x, float y, float width, float height)
1307 {
1308     if (!validateRectForCanvas(x, y, width, height))
1309         return;
1310 
1311     auto* c = drawingContext();
1312     if (!c)
1313         return;
1314     if (!state().hasInvertibleTransform)
1315         return;
1316     if (!(state().lineWidth &gt;= 0))
1317         return;
1318 
1319     // If gradient size is zero, then paint nothing.
1320     auto gradient = c-&gt;strokeGradient();
1321     if (gradient &amp;&amp; gradient-&gt;isZeroSize())
1322         return;
1323 
1324     FloatRect rect(x, y, width, height);
1325     if (isFullCanvasCompositeMode(state().globalComposite)) {
1326         beginCompositeLayer();
1327         c-&gt;strokeRect(rect, state().lineWidth);
1328         endCompositeLayer();
1329         didDrawEntireCanvas();
1330     } else if (state().globalComposite == CompositeCopy) {
1331         clearCanvas();
1332         c-&gt;strokeRect(rect, state().lineWidth);
1333         didDrawEntireCanvas();
1334     } else {
1335         FloatRect boundingRect = rect;
1336         boundingRect.inflate(state().lineWidth / 2);
1337         c-&gt;strokeRect(rect, state().lineWidth);
1338         didDraw(boundingRect);
1339     }
1340 }
1341 
1342 void CanvasRenderingContext2DBase::setShadow(float width, float height, float blur, const String&amp; colorString, Optional&lt;float&gt; alpha)
1343 {
1344     Color color = Color::transparent;
1345     if (!colorString.isNull()) {
1346         auto&amp; canvas = downcast&lt;HTMLCanvasElement&gt;(canvasBase());
1347         color = parseColorOrCurrentColor(colorString, &amp;canvas);
1348         if (!color.isValid())
1349             return;
1350     }
1351     // FIXME: Should not use RGBA32 here.
1352     setShadow(FloatSize(width, height), blur, colorWithOverrideAlpha(color.rgb(), alpha));
1353 }
1354 
1355 void CanvasRenderingContext2DBase::setShadow(float width, float height, float blur, float grayLevel, float alpha)
1356 {
1357     setShadow(FloatSize(width, height), blur, Color(grayLevel, grayLevel, grayLevel, alpha));
1358 }
1359 
1360 void CanvasRenderingContext2DBase::setShadow(float width, float height, float blur, float r, float g, float b, float a)
1361 {
1362     setShadow(FloatSize(width, height), blur, Color(r, g, b, a));
1363 }
1364 
1365 void CanvasRenderingContext2DBase::setShadow(float width, float height, float blur, float c, float m, float y, float k, float a)
1366 {
1367     setShadow(FloatSize(width, height), blur, Color(c, m, y, k, a));
1368 }
1369 
1370 void CanvasRenderingContext2DBase::clearShadow()
1371 {
1372     setShadow(FloatSize(), 0, Color::transparent);
1373 }
1374 
1375 void CanvasRenderingContext2DBase::setShadow(const FloatSize&amp; offset, float blur, const Color&amp; color)
1376 {
1377     if (state().shadowOffset == offset &amp;&amp; state().shadowBlur == blur &amp;&amp; state().shadowColor == color)
1378         return;
1379     bool wasDrawingShadows = shouldDrawShadows();
1380     realizeSaves();
1381     modifiableState().shadowOffset = offset;
1382     modifiableState().shadowBlur = blur;
1383     modifiableState().shadowColor = color;
1384     if (!wasDrawingShadows &amp;&amp; !shouldDrawShadows())
1385         return;
1386     applyShadow();
1387 }
1388 
1389 void CanvasRenderingContext2DBase::applyShadow()
1390 {
1391     auto* c = drawingContext();
1392     if (!c)
1393         return;
1394 
1395     if (shouldDrawShadows()) {
1396         float width = state().shadowOffset.width();
1397         float height = state().shadowOffset.height();
1398         c-&gt;setLegacyShadow(FloatSize(width, -height), state().shadowBlur, state().shadowColor);
1399     } else
1400         c-&gt;setLegacyShadow(FloatSize(), 0, Color::transparent);
1401 }
1402 
1403 bool CanvasRenderingContext2DBase::shouldDrawShadows() const
1404 {
1405     return state().shadowColor.isVisible() &amp;&amp; (state().shadowBlur || !state().shadowOffset.isZero());
1406 }
1407 
1408 enum class ImageSizeType { AfterDevicePixelRatio, BeforeDevicePixelRatio };
1409 static LayoutSize size(HTMLImageElement&amp; element, ImageSizeType sizeType = ImageSizeType::BeforeDevicePixelRatio)
1410 {
1411     LayoutSize size;
1412     if (auto* cachedImage = element.cachedImage()) {
1413         size = cachedImage-&gt;imageSizeForRenderer(element.renderer(), 1.0f); // FIXME: Not sure about this.
1414         if (sizeType == ImageSizeType::AfterDevicePixelRatio &amp;&amp; is&lt;RenderImage&gt;(element.renderer()) &amp;&amp; cachedImage-&gt;image() &amp;&amp; !cachedImage-&gt;image()-&gt;hasRelativeWidth())
1415             size.scale(downcast&lt;RenderImage&gt;(*element.renderer()).imageDevicePixelRatio());
1416     }
1417     return size;
1418 }
1419 
1420 static inline FloatSize size(HTMLCanvasElement&amp; canvasElement)
1421 {
1422     return canvasElement.size();
1423 }
1424 
1425 static inline FloatSize size(ImageBitmap&amp; imageBitmap)
1426 {
1427     return FloatSize { static_cast&lt;float&gt;(imageBitmap.width()), static_cast&lt;float&gt;(imageBitmap.height()) };
1428 }
1429 
1430 #if ENABLE(VIDEO)
1431 
1432 static inline FloatSize size(HTMLVideoElement&amp; video)
1433 {
1434     auto player = video.player();
1435     if (!player)
1436         return { };
1437     return player-&gt;naturalSize();
1438 }
1439 
1440 #endif
1441 
1442 #if ENABLE(CSS_TYPED_OM)
1443 static inline FloatSize size(TypedOMCSSImageValue&amp; image)
1444 {
1445     auto* cachedImage = image.image();
1446     if (!cachedImage)
1447         return FloatSize();
1448 
1449     return cachedImage-&gt;imageSizeForRenderer(nullptr, 1.0f);
1450 }
1451 #endif
1452 
1453 static inline FloatRect normalizeRect(const FloatRect&amp; rect)
1454 {
1455     return FloatRect(std::min(rect.x(), rect.maxX()),
1456         std::min(rect.y(), rect.maxY()),
1457         std::max(rect.width(), -rect.width()),
1458         std::max(rect.height(), -rect.height()));
1459 }
1460 
1461 ExceptionOr&lt;void&gt; CanvasRenderingContext2DBase::drawImage(CanvasImageSource&amp;&amp; image, float dx, float dy)
1462 {
1463     return WTF::switchOn(image,
1464         [&amp;] (RefPtr&lt;HTMLImageElement&gt;&amp; imageElement) -&gt; ExceptionOr&lt;void&gt; {
1465             LayoutSize destRectSize = size(*imageElement, ImageSizeType::AfterDevicePixelRatio);
1466             LayoutSize sourceRectSize = size(*imageElement, ImageSizeType::BeforeDevicePixelRatio);
1467             return this-&gt;drawImage(*imageElement, FloatRect { 0, 0, sourceRectSize.width(), sourceRectSize.height() }, FloatRect { dx, dy, destRectSize.width(), destRectSize.height() });
1468         },
1469         [&amp;] (auto&amp; element) -&gt; ExceptionOr&lt;void&gt; {
1470             FloatSize elementSize = size(*element);
1471             return this-&gt;drawImage(*element, FloatRect { 0, 0, elementSize.width(), elementSize.height() }, FloatRect { dx, dy, elementSize.width(), elementSize.height() });
1472         }
1473     );
1474 }
1475 
1476 ExceptionOr&lt;void&gt; CanvasRenderingContext2DBase::drawImage(CanvasImageSource&amp;&amp; image, float dx, float dy, float dw, float dh)
1477 {
1478     return WTF::switchOn(image,
1479         [&amp;] (auto&amp; element) -&gt; ExceptionOr&lt;void&gt; {
1480             FloatSize elementSize = size(*element);
1481             return this-&gt;drawImage(*element, FloatRect { 0, 0, elementSize.width(), elementSize.height() }, FloatRect { dx, dy, dw, dh });
1482         }
1483     );
1484 }
1485 
1486 ExceptionOr&lt;void&gt; CanvasRenderingContext2DBase::drawImage(CanvasImageSource&amp;&amp; image, float sx, float sy, float sw, float sh, float dx, float dy, float dw, float dh)
1487 {
1488     return WTF::switchOn(image,
1489         [&amp;] (auto&amp; element) -&gt; ExceptionOr&lt;void&gt; {
1490             return this-&gt;drawImage(*element, FloatRect { sx, sy, sw, sh }, FloatRect { dx, dy, dw, dh });
1491         }
1492     );
1493 }
1494 
1495 ExceptionOr&lt;void&gt; CanvasRenderingContext2DBase::drawImage(HTMLImageElement&amp; imageElement, const FloatRect&amp; srcRect, const FloatRect&amp; dstRect)
1496 {
1497     return drawImage(imageElement, srcRect, dstRect, state().globalComposite, state().globalBlend);
1498 }
1499 
1500 ExceptionOr&lt;void&gt; CanvasRenderingContext2DBase::drawImage(HTMLImageElement&amp; imageElement, const FloatRect&amp; srcRect, const FloatRect&amp; dstRect, const CompositeOperator&amp; op, const BlendMode&amp; blendMode)
1501 {
1502     if (!imageElement.complete())
1503         return { };
1504     FloatRect imageRect = FloatRect(FloatPoint(), size(imageElement, ImageSizeType::BeforeDevicePixelRatio));
1505 
1506     auto result = drawImage(imageElement.document(), imageElement.cachedImage(), imageElement.renderer(), imageRect, srcRect, dstRect, op, blendMode);
1507 
1508     if (!result.hasException())
1509         checkOrigin(&amp;imageElement);
1510     return result;
1511 }
1512 
1513 #if ENABLE(CSS_TYPED_OM)
1514 ExceptionOr&lt;void&gt; CanvasRenderingContext2DBase::drawImage(TypedOMCSSImageValue&amp; image, const FloatRect&amp; srcRect, const FloatRect&amp; dstRect)
1515 {
1516     auto* cachedImage = image.image();
1517     if (!cachedImage || !image.document())
1518         return { };
1519     FloatRect imageRect = FloatRect(FloatPoint(), size(image));
1520 
1521     auto result = drawImage(*image.document(), cachedImage, nullptr, imageRect, srcRect, dstRect, state().globalComposite, state().globalBlend);
1522 
1523     if (!result.hasException())
1524         checkOrigin(image);
1525     return result;
1526 }
1527 #endif
1528 
1529 ExceptionOr&lt;void&gt; CanvasRenderingContext2DBase::drawImage(Document&amp; document, CachedImage* cachedImage, const RenderObject* renderer, const FloatRect&amp; imageRect, const FloatRect&amp; srcRect, const FloatRect&amp; dstRect, const CompositeOperator&amp; op, const BlendMode&amp; blendMode)
1530 {
1531     if (!std::isfinite(dstRect.x()) || !std::isfinite(dstRect.y()) || !std::isfinite(dstRect.width()) || !std::isfinite(dstRect.height())
1532         || !std::isfinite(srcRect.x()) || !std::isfinite(srcRect.y()) || !std::isfinite(srcRect.width()) || !std::isfinite(srcRect.height()))
1533         return { };
1534 
1535     if (!dstRect.width() || !dstRect.height())
1536         return { };
1537 
1538     FloatRect normalizedSrcRect = normalizeRect(srcRect);
1539     FloatRect normalizedDstRect = normalizeRect(dstRect);
1540 
1541     if (!srcRect.width() || !srcRect.height())
1542         return Exception { IndexSizeError };
1543 
1544     // When the source rectangle is outside the source image, the source rectangle must be clipped
1545     // to the source image and the destination rectangle must be clipped in the same proportion.
1546     FloatRect originalNormalizedSrcRect = normalizedSrcRect;
1547     normalizedSrcRect.intersect(imageRect);
1548     if (normalizedSrcRect.isEmpty())
1549         return { };
1550 
1551     if (normalizedSrcRect != originalNormalizedSrcRect) {
1552         normalizedDstRect.setWidth(normalizedDstRect.width() * normalizedSrcRect.width() / originalNormalizedSrcRect.width());
1553         normalizedDstRect.setHeight(normalizedDstRect.height() * normalizedSrcRect.height() / originalNormalizedSrcRect.height());
1554         if (normalizedDstRect.isEmpty())
1555             return { };
1556     }
1557 
1558     GraphicsContext* c = drawingContext();
1559     if (!c)
1560         return { };
1561     if (!state().hasInvertibleTransform)
1562         return { };
1563 
1564     if (!cachedImage)
1565         return { };
1566 
1567     RefPtr&lt;Image&gt; image = cachedImage-&gt;imageForRenderer(renderer);
1568     if (!image)
1569         return { };
1570 
1571     ImageObserver* observer = image-&gt;imageObserver();
1572 
1573     if (image-&gt;isSVGImage()) {
1574         image-&gt;setImageObserver(nullptr);
1575         image-&gt;setContainerSize(imageRect.size());
1576     }
1577 
1578     if (image-&gt;isBitmapImage())
1579         downcast&lt;BitmapImage&gt;(*image).updateFromSettings(document.settings());
1580 
1581     if (rectContainsCanvas(normalizedDstRect)) {
1582         c-&gt;drawImage(*image, normalizedDstRect, normalizedSrcRect, ImagePaintingOptions(op, blendMode));
1583         didDrawEntireCanvas();
1584     } else if (isFullCanvasCompositeMode(op)) {
1585         fullCanvasCompositedDrawImage(*image, normalizedDstRect, normalizedSrcRect, op);
1586         didDrawEntireCanvas();
1587     } else if (op == CompositeCopy) {
1588         clearCanvas();
1589         c-&gt;drawImage(*image, normalizedDstRect, normalizedSrcRect, ImagePaintingOptions(op, blendMode));
1590         didDrawEntireCanvas();
1591     } else {
1592         c-&gt;drawImage(*image, normalizedDstRect, normalizedSrcRect, ImagePaintingOptions(op, blendMode));
1593         didDraw(normalizedDstRect);
1594     }
1595 
1596     if (image-&gt;isSVGImage())
1597         image-&gt;setImageObserver(observer);
1598 
1599     return { };
1600 }
1601 
1602 ExceptionOr&lt;void&gt; CanvasRenderingContext2DBase::drawImage(HTMLCanvasElement&amp; sourceCanvas, const FloatRect&amp; srcRect, const FloatRect&amp; dstRect)
1603 {
1604     FloatRect srcCanvasRect = FloatRect(FloatPoint(), sourceCanvas.size());
1605 
1606     if (!srcCanvasRect.width() || !srcCanvasRect.height())
1607         return Exception { InvalidStateError };
1608 
1609     if (!srcRect.width() || !srcRect.height())
1610         return Exception { IndexSizeError };
1611 
1612     if (!srcCanvasRect.contains(normalizeRect(srcRect)) || !dstRect.width() || !dstRect.height())
1613         return { };
1614 
1615     GraphicsContext* c = drawingContext();
1616     if (!c)
1617         return { };
1618     if (!state().hasInvertibleTransform)
1619         return { };
1620 
1621     // FIXME: Do this through platform-independent GraphicsContext API.
1622     ImageBuffer* buffer = sourceCanvas.buffer();
1623     if (!buffer)
1624         return { };
1625 
1626     checkOrigin(&amp;sourceCanvas);
1627 
1628 #if ENABLE(ACCELERATED_2D_CANVAS)
1629     // If we&#39;re drawing from one accelerated canvas 2d to another, avoid calling sourceCanvas.makeRenderingResultsAvailable()
1630     // as that will do a readback to software.
1631     RefPtr&lt;CanvasRenderingContext&gt; sourceContext = sourceCanvas.renderingContext();
1632     // FIXME: Implement an accelerated path for drawing from a WebGL canvas to a 2d canvas when possible.
1633     if (!isAccelerated() || !sourceContext || !sourceContext-&gt;isAccelerated() || !sourceContext-&gt;is2d())
1634         sourceCanvas.makeRenderingResultsAvailable();
1635 #else
1636     sourceCanvas.makeRenderingResultsAvailable();
1637 #endif
1638 
1639     if (rectContainsCanvas(dstRect)) {
1640         c-&gt;drawImageBuffer(*buffer, dstRect, srcRect, ImagePaintingOptions(state().globalComposite, state().globalBlend));
1641         didDrawEntireCanvas();
1642     } else if (isFullCanvasCompositeMode(state().globalComposite)) {
1643         fullCanvasCompositedDrawImage(*buffer, dstRect, srcRect, state().globalComposite);
1644         didDrawEntireCanvas();
1645     } else if (state().globalComposite == CompositeCopy) {
1646         if (&amp;sourceCanvas == &amp;canvasBase()) {
1647             if (auto copy = buffer-&gt;copyRectToBuffer(srcRect, ColorSpaceSRGB, *c)) {
1648                 clearCanvas();
1649                 c-&gt;drawImageBuffer(*copy, dstRect, { { }, srcRect.size() }, ImagePaintingOptions(state().globalComposite, state().globalBlend));
1650             }
1651         } else {
1652         clearCanvas();
1653         c-&gt;drawImageBuffer(*buffer, dstRect, srcRect, ImagePaintingOptions(state().globalComposite, state().globalBlend));
1654         }
1655         didDrawEntireCanvas();
1656     } else {
1657         c-&gt;drawImageBuffer(*buffer, dstRect, srcRect, ImagePaintingOptions(state().globalComposite, state().globalBlend));
1658         didDraw(dstRect);
1659     }
1660 
1661     return { };
1662 }
1663 
1664 #if ENABLE(VIDEO)
1665 
1666 ExceptionOr&lt;void&gt; CanvasRenderingContext2DBase::drawImage(HTMLVideoElement&amp; video, const FloatRect&amp; srcRect, const FloatRect&amp; dstRect)
1667 {
1668     if (video.readyState() == HTMLMediaElement::HAVE_NOTHING || video.readyState() == HTMLMediaElement::HAVE_METADATA)
1669         return { };
1670 
1671     FloatRect videoRect = FloatRect(FloatPoint(), size(video));
1672     if (!srcRect.width() || !srcRect.height())
1673         return Exception { IndexSizeError };
1674 
1675     if (!videoRect.contains(normalizeRect(srcRect)) || !dstRect.width() || !dstRect.height())
1676         return { };
1677 
1678     GraphicsContext* c = drawingContext();
1679     if (!c)
1680         return { };
1681     if (!state().hasInvertibleTransform)
1682         return { };
1683 
1684     checkOrigin(&amp;video);
1685 
1686 #if USE(CG) || (ENABLE(ACCELERATED_2D_CANVAS) &amp;&amp; USE(GSTREAMER_GL) &amp;&amp; USE(CAIRO))
1687     if (NativeImagePtr image = video.nativeImageForCurrentTime()) {
1688         c-&gt;drawNativeImage(image, FloatSize(video.videoWidth(), video.videoHeight()), dstRect, srcRect);
1689         if (rectContainsCanvas(dstRect))
1690             didDrawEntireCanvas();
1691         else
1692             didDraw(dstRect);
1693 
1694         return { };
1695     }
1696 #endif
1697 
1698     GraphicsContextStateSaver stateSaver(*c);
1699     c-&gt;clip(dstRect);
1700     c-&gt;translate(dstRect.location());
1701     c-&gt;scale(FloatSize(dstRect.width() / srcRect.width(), dstRect.height() / srcRect.height()));
1702     c-&gt;translate(-srcRect.location());
1703     video.paintCurrentFrameInContext(*c, FloatRect(FloatPoint(), size(video)));
1704     stateSaver.restore();
1705     didDraw(dstRect);
1706 
1707     return { };
1708 }
1709 
1710 #endif
1711 
1712 ExceptionOr&lt;void&gt; CanvasRenderingContext2DBase::drawImage(ImageBitmap&amp; imageBitmap, const FloatRect&amp; srcRect, const FloatRect&amp; dstRect)
1713 {
1714     if (!imageBitmap.width() || !imageBitmap.height())
1715         return Exception { InvalidStateError };
1716 
1717     if (!srcRect.width() || !srcRect.height())
1718         return Exception { IndexSizeError };
1719 
1720     FloatRect srcBitmapRect = FloatRect(FloatPoint(), FloatSize(imageBitmap.width(), imageBitmap.height()));
1721 
1722     if (!srcBitmapRect.contains(normalizeRect(srcRect)) || !dstRect.width() || !dstRect.height())
1723         return { };
1724 
1725     GraphicsContext* c = drawingContext();
1726     if (!c)
1727         return { };
1728     if (!state().hasInvertibleTransform)
1729         return { };
1730 
1731     ImageBuffer* buffer = imageBitmap.buffer();
1732     if (!buffer)
1733         return { };
1734 
1735     checkOrigin(&amp;imageBitmap);
1736 
1737     if (rectContainsCanvas(dstRect)) {
1738         c-&gt;drawImageBuffer(*buffer, dstRect, srcRect, ImagePaintingOptions(state().globalComposite, state().globalBlend));
1739         didDrawEntireCanvas();
1740     } else if (isFullCanvasCompositeMode(state().globalComposite)) {
1741         fullCanvasCompositedDrawImage(*buffer, dstRect, srcRect, state().globalComposite);
1742         didDrawEntireCanvas();
1743     } else if (state().globalComposite == CompositeCopy) {
1744         clearCanvas();
1745         c-&gt;drawImageBuffer(*buffer, dstRect, srcRect, ImagePaintingOptions(state().globalComposite, state().globalBlend));
1746         didDrawEntireCanvas();
1747     } else {
1748         c-&gt;drawImageBuffer(*buffer, dstRect, srcRect, ImagePaintingOptions(state().globalComposite, state().globalBlend));
1749         didDraw(dstRect);
1750     }
1751 
1752     return { };
1753 }
1754 
1755 void CanvasRenderingContext2DBase::drawImageFromRect(HTMLImageElement&amp; imageElement, float sx, float sy, float sw, float sh, float dx, float dy, float dw, float dh, const String&amp; compositeOperation)
1756 {
1757     CompositeOperator op;
1758     auto blendOp = BlendMode::Normal;
1759     if (!parseCompositeAndBlendOperator(compositeOperation, op, blendOp) || blendOp != BlendMode::Normal)
1760         op = CompositeSourceOver;
1761     drawImage(imageElement, FloatRect { sx, sy, sw, sh }, FloatRect { dx, dy, dw, dh }, op, BlendMode::Normal);
1762 }
1763 
1764 void CanvasRenderingContext2DBase::clearCanvas()
1765 {
1766     auto* c = drawingContext();
1767     if (!c)
1768         return;
1769 
1770     c-&gt;save();
1771     c-&gt;setCTM(canvasBase().baseTransform());
1772     c-&gt;clearRect(FloatRect(0, 0, canvasBase().width(), canvasBase().height()));
1773     c-&gt;restore();
1774 }
1775 
1776 Path CanvasRenderingContext2DBase::transformAreaToDevice(const Path&amp; path) const
1777 {
1778     Path transformed(path);
1779     transformed.transform(state().transform);
1780     transformed.transform(canvasBase().baseTransform());
1781     return transformed;
1782 }
1783 
1784 Path CanvasRenderingContext2DBase::transformAreaToDevice(const FloatRect&amp; rect) const
1785 {
1786     Path path;
1787     path.addRect(rect);
1788     return transformAreaToDevice(path);
1789 }
1790 
1791 bool CanvasRenderingContext2DBase::rectContainsCanvas(const FloatRect&amp; rect) const
1792 {
1793     FloatQuad quad(rect);
1794     FloatQuad canvasQuad(FloatRect(0, 0, canvasBase().width(), canvasBase().height()));
1795     return state().transform.mapQuad(quad).containsQuad(canvasQuad);
1796 }
1797 
1798 template&lt;class T&gt; IntRect CanvasRenderingContext2DBase::calculateCompositingBufferRect(const T&amp; area, IntSize* croppedOffset)
1799 {
1800     IntRect canvasRect(0, 0, canvasBase().width(), canvasBase().height());
1801     canvasRect = canvasBase().baseTransform().mapRect(canvasRect);
1802     Path path = transformAreaToDevice(area);
1803     IntRect bufferRect = enclosingIntRect(path.fastBoundingRect());
1804     IntPoint originalLocation = bufferRect.location();
1805     bufferRect.intersect(canvasRect);
1806     if (croppedOffset)
1807         *croppedOffset = originalLocation - bufferRect.location();
1808     return bufferRect;
1809 }
1810 
1811 std::unique_ptr&lt;ImageBuffer&gt; CanvasRenderingContext2DBase::createCompositingBuffer(const IntRect&amp; bufferRect)
1812 {
1813     return ImageBuffer::create(bufferRect.size(), isAccelerated() ? Accelerated : Unaccelerated);
1814 }
1815 
1816 void CanvasRenderingContext2DBase::compositeBuffer(ImageBuffer&amp; buffer, const IntRect&amp; bufferRect, CompositeOperator op)
1817 {
1818     IntRect canvasRect(0, 0, canvasBase().width(), canvasBase().height());
1819     canvasRect = canvasBase().baseTransform().mapRect(canvasRect);
1820 
1821     auto* c = drawingContext();
1822     if (!c)
1823         return;
1824 
1825     c-&gt;save();
1826     c-&gt;setCTM(AffineTransform());
1827     c-&gt;setCompositeOperation(op);
1828 
1829     c-&gt;save();
1830     c-&gt;clipOut(bufferRect);
1831     c-&gt;clearRect(canvasRect);
1832     c-&gt;restore();
1833     c-&gt;drawImageBuffer(buffer, bufferRect.location(), state().globalComposite);
1834     c-&gt;restore();
1835 }
1836 
1837 static void drawImageToContext(Image&amp; image, GraphicsContext&amp; context, const FloatRect&amp; dest, const FloatRect&amp; src, CompositeOperator op)
1838 {
1839     context.drawImage(image, dest, src, op);
1840 }
1841 
1842 static void drawImageToContext(ImageBuffer&amp; imageBuffer, GraphicsContext&amp; context, const FloatRect&amp; dest, const FloatRect&amp; src, CompositeOperator op)
1843 {
1844     context.drawImageBuffer(imageBuffer, dest, src, op);
1845 }
1846 
1847 template&lt;class T&gt; void CanvasRenderingContext2DBase::fullCanvasCompositedDrawImage(T&amp; image, const FloatRect&amp; dest, const FloatRect&amp; src, CompositeOperator op)
1848 {
1849     ASSERT(isFullCanvasCompositeMode(op));
1850 
1851     IntSize croppedOffset;
1852     auto bufferRect = calculateCompositingBufferRect(dest, &amp;croppedOffset);
1853     if (bufferRect.isEmpty()) {
1854         clearCanvas();
1855         return;
1856     }
1857 
1858     auto buffer = createCompositingBuffer(bufferRect);
1859     if (!buffer)
1860         return;
1861 
1862     auto* c = drawingContext();
1863     if (!c)
1864         return;
1865 
1866     FloatRect adjustedDest = dest;
1867     adjustedDest.setLocation(FloatPoint(0, 0));
1868     AffineTransform effectiveTransform = c-&gt;getCTM();
1869     IntRect transformedAdjustedRect = enclosingIntRect(effectiveTransform.mapRect(adjustedDest));
1870     buffer-&gt;context().translate(-transformedAdjustedRect.location());
1871     buffer-&gt;context().translate(croppedOffset);
1872     buffer-&gt;context().concatCTM(effectiveTransform);
1873     drawImageToContext(image, buffer-&gt;context(), adjustedDest, src, CompositeSourceOver);
1874 
1875     compositeBuffer(*buffer, bufferRect, op);
1876 }
1877 
1878 void CanvasRenderingContext2DBase::prepareGradientForDashboard(CanvasGradient&amp; gradient) const
1879 {
1880 #if ENABLE(DASHBOARD_SUPPORT)
1881     if (m_usesDashboardCompatibilityMode)
1882         gradient.setDashboardCompatibilityMode();
1883 #else
1884     UNUSED_PARAM(gradient);
1885 #endif
1886 }
1887 
1888 static CanvasRenderingContext2DBase::Style toStyle(const CanvasStyle&amp; style)
1889 {
1890     if (auto gradient = style.canvasGradient())
1891         return gradient;
1892     if (auto pattern = style.canvasPattern())
1893         return pattern;
1894     return style.color();
1895 }
1896 
1897 CanvasRenderingContext2DBase::Style CanvasRenderingContext2DBase::strokeStyle() const
1898 {
1899     return toStyle(state().strokeStyle);
1900 }
1901 
1902 void CanvasRenderingContext2DBase::setStrokeStyle(CanvasRenderingContext2DBase::Style&amp;&amp; style)
1903 {
1904     WTF::switchOn(style,
1905         [this] (const String&amp; string) { this-&gt;setStrokeColor(string); },
1906         [this] (const RefPtr&lt;CanvasGradient&gt;&amp; gradient) { this-&gt;setStrokeStyle(CanvasStyle(*gradient)); },
1907         [this] (const RefPtr&lt;CanvasPattern&gt;&amp; pattern) { this-&gt;setStrokeStyle(CanvasStyle(*pattern)); }
1908     );
1909 }
1910 
1911 CanvasRenderingContext2DBase::Style CanvasRenderingContext2DBase::fillStyle() const
1912 {
1913     return toStyle(state().fillStyle);
1914 }
1915 
1916 void CanvasRenderingContext2DBase::setFillStyle(CanvasRenderingContext2DBase::Style&amp;&amp; style)
1917 {
1918     WTF::switchOn(style,
1919         [this] (const String&amp; string) { this-&gt;setFillColor(string); },
1920         [this] (const RefPtr&lt;CanvasGradient&gt;&amp; gradient) { this-&gt;setFillStyle(CanvasStyle(*gradient)); },
1921         [this] (const RefPtr&lt;CanvasPattern&gt;&amp; pattern) { this-&gt;setFillStyle(CanvasStyle(*pattern)); }
1922     );
1923 }
1924 
1925 ExceptionOr&lt;Ref&lt;CanvasGradient&gt;&gt; CanvasRenderingContext2DBase::createLinearGradient(float x0, float y0, float x1, float y1)
1926 {
1927     if (!std::isfinite(x0) || !std::isfinite(y0) || !std::isfinite(x1) || !std::isfinite(y1))
1928         return Exception { NotSupportedError };
1929 
1930     auto gradient = CanvasGradient::create(FloatPoint(x0, y0), FloatPoint(x1, y1));
1931     prepareGradientForDashboard(gradient.get());
1932     return WTFMove(gradient);
1933 }
1934 
1935 ExceptionOr&lt;Ref&lt;CanvasGradient&gt;&gt; CanvasRenderingContext2DBase::createRadialGradient(float x0, float y0, float r0, float x1, float y1, float r1)
1936 {
1937     if (!std::isfinite(x0) || !std::isfinite(y0) || !std::isfinite(r0) || !std::isfinite(x1) || !std::isfinite(y1) || !std::isfinite(r1))
1938         return Exception { NotSupportedError };
1939 
1940     if (r0 &lt; 0 || r1 &lt; 0)
1941         return Exception { IndexSizeError };
1942 
1943     auto gradient = CanvasGradient::create(FloatPoint(x0, y0), r0, FloatPoint(x1, y1), r1);
1944     prepareGradientForDashboard(gradient.get());
1945     return WTFMove(gradient);
1946 }
1947 
1948 ExceptionOr&lt;RefPtr&lt;CanvasPattern&gt;&gt; CanvasRenderingContext2DBase::createPattern(CanvasImageSource&amp;&amp; image, const String&amp; repetition)
1949 {
1950     bool repeatX, repeatY;
1951     if (!CanvasPattern::parseRepetitionType(repetition, repeatX, repeatY))
1952         return Exception { SyntaxError };
1953 
1954     return WTF::switchOn(image,
1955         [&amp;] (auto&amp; element) -&gt; ExceptionOr&lt;RefPtr&lt;CanvasPattern&gt;&gt; { return this-&gt;createPattern(*element, repeatX, repeatY); }
1956     );
1957 }
1958 
1959 ExceptionOr&lt;RefPtr&lt;CanvasPattern&gt;&gt; CanvasRenderingContext2DBase::createPattern(HTMLImageElement&amp; imageElement, bool repeatX, bool repeatY)
1960 {
1961     auto* cachedImage = imageElement.cachedImage();
1962 
1963     // If the image loading hasn&#39;t started or the image is not complete, it is not fully decodable.
1964     if (!cachedImage || !imageElement.complete())
1965         return nullptr;
1966 
1967     if (cachedImage-&gt;status() == CachedResource::LoadError)
1968         return Exception { InvalidStateError };
1969 
1970     bool originClean = cachedImage-&gt;isOriginClean(canvasBase().securityOrigin());
1971 
1972     // FIXME: SVG images with animations can switch between clean and dirty (leaking cross-origin
1973     // data). We should either:
1974     //   1) Take a fixed snapshot of an SVG image when creating a pattern and determine then whether
1975     //      the origin is clean.
1976     //   2) Dynamically verify the origin checks at draw time, and dirty the canvas accordingly.
1977     // To be on the safe side, taint the origin for all patterns containing SVG images for now.
1978     if (cachedImage-&gt;image()-&gt;isSVGImage())
1979         originClean = false;
1980 
1981     return RefPtr&lt;CanvasPattern&gt; { CanvasPattern::create(*cachedImage-&gt;imageForRenderer(imageElement.renderer()), repeatX, repeatY, originClean) };
1982 }
1983 
1984 ExceptionOr&lt;RefPtr&lt;CanvasPattern&gt;&gt; CanvasRenderingContext2DBase::createPattern(CanvasBase&amp; canvas, bool repeatX, bool repeatY)
1985 {
1986     if (!canvas.width() || !canvas.height())
1987         return Exception { InvalidStateError };
1988     auto* copiedImage = canvas.copiedImage();
1989 
1990     if (!copiedImage)
1991         return Exception { InvalidStateError };
1992 
1993     return RefPtr&lt;CanvasPattern&gt; { CanvasPattern::create(*copiedImage, repeatX, repeatY, canvas.originClean()) };
1994 }
1995 
1996 #if ENABLE(VIDEO)
1997 
1998 ExceptionOr&lt;RefPtr&lt;CanvasPattern&gt;&gt; CanvasRenderingContext2DBase::createPattern(HTMLVideoElement&amp; videoElement, bool repeatX, bool repeatY)
1999 {
2000     if (videoElement.readyState() &lt; HTMLMediaElement::HAVE_CURRENT_DATA)
2001         return nullptr;
2002 
2003     checkOrigin(&amp;videoElement);
2004     bool originClean = canvasBase().originClean();
2005 
2006 #if USE(CG) || (ENABLE(ACCELERATED_2D_CANVAS) &amp;&amp; USE(GSTREAMER_GL) &amp;&amp; USE(CAIRO))
2007     if (auto nativeImage = videoElement.nativeImageForCurrentTime())
2008         return RefPtr&lt;CanvasPattern&gt; { CanvasPattern::create(BitmapImage::create(WTFMove(nativeImage)), repeatX, repeatY, originClean) };
2009 #endif
2010 
2011     auto imageBuffer = ImageBuffer::create(size(videoElement), drawingContext() ? drawingContext()-&gt;renderingMode() : Accelerated);
2012     if (!imageBuffer)
2013         return nullptr;
2014 
2015     videoElement.paintCurrentFrameInContext(imageBuffer-&gt;context(), FloatRect(FloatPoint(), size(videoElement)));
2016 
2017     return RefPtr&lt;CanvasPattern&gt; { CanvasPattern::create(ImageBuffer::sinkIntoImage(WTFMove(imageBuffer), PreserveResolution::Yes).releaseNonNull(), repeatX, repeatY, originClean) };
2018 }
2019 
2020 #endif
2021 
2022 ExceptionOr&lt;RefPtr&lt;CanvasPattern&gt;&gt; CanvasRenderingContext2DBase::createPattern(ImageBitmap&amp;, bool, bool)
2023 {
2024     // FIXME: Implement.
2025     return Exception { TypeError };
2026 }
2027 
2028 #if ENABLE(CSS_TYPED_OM)
2029 ExceptionOr&lt;RefPtr&lt;CanvasPattern&gt;&gt; CanvasRenderingContext2DBase::createPattern(TypedOMCSSImageValue&amp;, bool, bool)
2030 {
2031     // FIXME: Implement.
2032     return Exception { TypeError };
2033 }
2034 #endif
2035 
2036 void CanvasRenderingContext2DBase::didDrawEntireCanvas()
2037 {
2038     didDraw(FloatRect(FloatPoint::zero(), canvasBase().size()), CanvasDidDrawApplyClip);
2039 }
2040 
2041 void CanvasRenderingContext2DBase::didDraw(const FloatRect&amp; r, unsigned options)
2042 {
2043     auto* c = drawingContext();
2044     if (!c)
2045         return;
2046     if (!state().hasInvertibleTransform)
2047         return;
2048 
2049 #if ENABLE(ACCELERATED_2D_CANVAS)
2050     // If we are drawing to hardware and we have a composited layer, just call contentChanged().
2051     if (isAccelerated()) {
2052         auto&amp; canvas = downcast&lt;HTMLCanvasElement&gt;(canvasBase());
2053         RenderBox* renderBox = canvas.renderBox();
2054         if (renderBox &amp;&amp; renderBox-&gt;hasAcceleratedCompositing()) {
2055             renderBox-&gt;contentChanged(CanvasPixelsChanged);
2056             canvas.clearCopiedImage();
2057             canvas.notifyObserversCanvasChanged(r);
2058             return;
2059         }
2060     }
2061 #endif
2062 
2063     FloatRect dirtyRect = r;
2064     if (options &amp; CanvasDidDrawApplyTransform) {
2065         AffineTransform ctm = state().transform;
2066         dirtyRect = ctm.mapRect(r);
2067     }
2068 
2069     if (options &amp; CanvasDidDrawApplyShadow &amp;&amp; state().shadowColor.isVisible()) {
2070         // The shadow gets applied after transformation
2071         FloatRect shadowRect(dirtyRect);
2072         shadowRect.move(state().shadowOffset);
2073         shadowRect.inflate(state().shadowBlur);
2074         dirtyRect.unite(shadowRect);
2075     }
2076 
2077     if (options &amp; CanvasDidDrawApplyClip) {
2078         // FIXME: apply the current clip to the rectangle. Unfortunately we can&#39;t get the clip
2079         // back out of the GraphicsContext, so to take clip into account for incremental painting,
2080         // we&#39;d have to keep the clip path around.
2081     }
2082 
2083     canvasBase().didDraw(dirtyRect);
2084 }
2085 
2086 void CanvasRenderingContext2DBase::setTracksDisplayListReplay(bool tracksDisplayListReplay)
2087 {
2088     if (tracksDisplayListReplay == m_tracksDisplayListReplay)
2089         return;
2090 
2091     m_tracksDisplayListReplay = tracksDisplayListReplay;
2092     if (!m_tracksDisplayListReplay)
2093         contextDisplayListMap().remove(this);
2094 }
2095 
2096 String CanvasRenderingContext2DBase::displayListAsText(DisplayList::AsTextFlags flags) const
2097 {
2098     if (!m_recordingContext)
2099         return { };
2100     return m_recordingContext-&gt;displayList.asText(flags);
2101 }
2102 
2103 String CanvasRenderingContext2DBase::replayDisplayListAsText(DisplayList::AsTextFlags flags) const
2104 {
2105     auto* displayList = contextDisplayListMap().get(this);
2106     if (!displayList)
2107         return { };
2108     return displayList-&gt;asText(flags);
2109 }
2110 
2111 const Vector&lt;CanvasRenderingContext2DBase::State, 1&gt;&amp; CanvasRenderingContext2DBase::stateStack()
2112 {
2113     realizeSaves();
2114     return m_stateStack;
2115 }
2116 
2117 void CanvasRenderingContext2DBase::paintRenderingResultsToCanvas()
2118 {
2119     if (UNLIKELY(m_usesDisplayListDrawing)) {
2120         if (!m_recordingContext)
2121             return;
2122 
2123         FloatRect clip(FloatPoint::zero(), canvasBase().size());
2124         DisplayList::Replayer replayer(*canvasBase().drawingContext(), m_recordingContext-&gt;displayList);
2125 
2126         if (UNLIKELY(m_tracksDisplayListReplay)) {
2127             auto replayList = replayer.replay(clip, m_tracksDisplayListReplay);
2128             contextDisplayListMap().add(this, WTFMove(replayList));
2129         } else
2130             replayer.replay(clip);
2131 
2132         m_recordingContext-&gt;displayList.clear();
2133     }
2134 }
2135 
2136 GraphicsContext* CanvasRenderingContext2DBase::drawingContext() const
2137 {
2138     if (UNLIKELY(m_usesDisplayListDrawing)) {
2139         if (!m_recordingContext)
2140             m_recordingContext = std::make_unique&lt;DisplayListDrawingContext&gt;(GraphicsContextState(), FloatRect(FloatPoint::zero(), canvasBase().size()));
2141         return &amp;m_recordingContext-&gt;context;
2142     }
2143 
2144     return canvasBase().drawingContext();
2145 }
2146 
2147 static RefPtr&lt;ImageData&gt; createEmptyImageData(const IntSize&amp; size)
2148 {
2149     auto data = ImageData::create(size);
2150     if (data)
2151         data-&gt;data()-&gt;zeroFill();
2152     return data;
2153 }
2154 
2155 RefPtr&lt;ImageData&gt; CanvasRenderingContext2DBase::createImageData(ImageData&amp; imageData) const
2156 {
2157     return createEmptyImageData(imageData.size());
2158 }
2159 
2160 ExceptionOr&lt;RefPtr&lt;ImageData&gt;&gt; CanvasRenderingContext2DBase::createImageData(float sw, float sh) const
2161 {
2162     if (!sw || !sh)
2163         return Exception { IndexSizeError };
2164 
2165     FloatSize logicalSize(std::abs(sw), std::abs(sh));
2166     if (!logicalSize.isExpressibleAsIntSize())
2167         return nullptr;
2168 
2169     IntSize size = expandedIntSize(logicalSize);
2170     if (size.width() &lt; 1)
2171         size.setWidth(1);
2172     if (size.height() &lt; 1)
2173         size.setHeight(1);
2174 
2175     return createEmptyImageData(size);
2176 }
2177 
2178 ExceptionOr&lt;RefPtr&lt;ImageData&gt;&gt; CanvasRenderingContext2DBase::getImageData(float sx, float sy, float sw, float sh) const
2179 {
2180     return getImageData(ImageBuffer::LogicalCoordinateSystem, sx, sy, sw, sh);
2181 }
2182 
2183 ExceptionOr&lt;RefPtr&lt;ImageData&gt;&gt; CanvasRenderingContext2DBase::getImageData(ImageBuffer::CoordinateSystem coordinateSystem, float sx, float sy, float sw, float sh) const
2184 {
2185     if (!canvasBase().originClean()) {
2186         static NeverDestroyed&lt;String&gt; consoleMessage(MAKE_STATIC_STRING_IMPL(&quot;Unable to get image data from canvas because the canvas has been tainted by cross-origin data.&quot;));
2187         canvasBase().scriptExecutionContext()-&gt;addConsoleMessage(MessageSource::Security, MessageLevel::Error, consoleMessage);
2188         return Exception { SecurityError };
2189     }
2190 
2191     if (!sw || !sh)
2192         return Exception { IndexSizeError };
2193 
2194     if (sw &lt; 0) {
2195         sx += sw;
2196         sw = -sw;
2197     }
2198     if (sh &lt; 0) {
2199         sy += sh;
2200         sh = -sh;
2201     }
2202 
2203     FloatRect logicalRect(sx, sy, sw, sh);
2204     if (logicalRect.width() &lt; 1)
2205         logicalRect.setWidth(1);
2206     if (logicalRect.height() &lt; 1)
2207         logicalRect.setHeight(1);
2208     if (!logicalRect.isExpressibleAsIntRect())
2209         return nullptr;
2210 
2211     IntRect imageDataRect = enclosingIntRect(logicalRect);
2212     auto&amp; canvas = downcast&lt;HTMLCanvasElement&gt;(canvasBase());
2213 
2214     ImageBuffer* buffer = canvas.buffer();
2215     if (!buffer)
2216         return createEmptyImageData(imageDataRect.size());
2217 
2218     auto byteArray = buffer-&gt;getUnmultipliedImageData(imageDataRect, nullptr, coordinateSystem);
2219     if (!byteArray) {
2220         StringBuilder consoleMessage;
2221         consoleMessage.appendLiteral(&quot;Unable to get image data from canvas. Requested size was &quot;);
2222         consoleMessage.appendNumber(imageDataRect.width());
2223         consoleMessage.appendLiteral(&quot; x &quot;);
2224         consoleMessage.appendNumber(imageDataRect.height());
2225 
2226         canvasBase().scriptExecutionContext()-&gt;addConsoleMessage(MessageSource::Rendering, MessageLevel::Error, consoleMessage.toString());
2227         return Exception { InvalidStateError };
2228     }
2229 
2230     return ImageData::create(imageDataRect.size(), byteArray.releaseNonNull());
2231 }
2232 
2233 void CanvasRenderingContext2DBase::putImageData(ImageData&amp; data, float dx, float dy)
2234 {
2235     putImageData(data, dx, dy, 0, 0, data.width(), data.height());
2236 }
2237 
2238 void CanvasRenderingContext2DBase::putImageData(ImageData&amp; data, float dx, float dy, float dirtyX, float dirtyY, float dirtyWidth, float dirtyHeight)
2239 {
2240     putImageData(data, ImageBuffer::LogicalCoordinateSystem, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight);
2241 }
2242 
2243 void CanvasRenderingContext2DBase::putImageData(ImageData&amp; data, ImageBuffer::CoordinateSystem coordinateSystem, float dx, float dy, float dirtyX, float dirtyY, float dirtyWidth, float dirtyHeight)
2244 {
2245     auto&amp; canvas = downcast&lt;HTMLCanvasElement&gt;(canvasBase());
2246 
2247     ImageBuffer* buffer = canvas.buffer();
2248     if (!buffer)
2249         return;
2250 
2251     if (!data.data())
2252         return;
2253 
2254     if (dirtyWidth &lt; 0) {
2255         dirtyX += dirtyWidth;
2256         dirtyWidth = -dirtyWidth;
2257     }
2258 
2259     if (dirtyHeight &lt; 0) {
2260         dirtyY += dirtyHeight;
2261         dirtyHeight = -dirtyHeight;
2262     }
2263 
2264     FloatRect clipRect(dirtyX, dirtyY, dirtyWidth, dirtyHeight);
2265     clipRect.intersect(IntRect(0, 0, data.width(), data.height()));
2266     IntSize destOffset(static_cast&lt;int&gt;(dx), static_cast&lt;int&gt;(dy));
2267     IntRect destRect = enclosingIntRect(clipRect);
2268     destRect.move(destOffset);
2269     destRect.intersect(IntRect(IntPoint(), coordinateSystem == ImageBuffer::LogicalCoordinateSystem ? buffer-&gt;logicalSize() : buffer-&gt;internalSize()));
2270     if (destRect.isEmpty())
2271         return;
2272     IntRect sourceRect(destRect);
2273     sourceRect.move(-destOffset);
2274     sourceRect.intersect(IntRect(0, 0, data.width(), data.height()));
2275 
2276     if (!sourceRect.isEmpty())
2277         buffer-&gt;putByteArray(*data.data(), AlphaPremultiplication::Unpremultiplied, IntSize(data.width(), data.height()), sourceRect, IntPoint(destOffset), coordinateSystem);
2278 
2279     didDraw(destRect, CanvasDidDrawApplyNone); // ignore transform, shadow and clip
2280 }
2281 
2282 void CanvasRenderingContext2DBase::inflateStrokeRect(FloatRect&amp; rect) const
2283 {
2284     // Fast approximation of the stroke&#39;s bounding rect.
2285     // This yields a slightly oversized rect but is very fast
2286     // compared to Path::strokeBoundingRect().
2287     static const float root2 = sqrtf(2);
2288     float delta = state().lineWidth / 2;
2289     if (state().lineJoin == MiterJoin)
2290         delta *= state().miterLimit;
2291     else if (state().lineCap == SquareCap)
2292         delta *= root2;
2293     rect.inflate(delta);
2294 }
2295 
2296 #if ENABLE(ACCELERATED_2D_CANVAS)
2297 
2298 PlatformLayer* CanvasRenderingContext2DBase::platformLayer() const
2299 {
2300     auto&amp; canvas = downcast&lt;HTMLCanvasElement&gt;(canvasBase());
2301 
2302     return canvas.buffer() ? canvas.buffer()-&gt;platformLayer() : nullptr;
2303 }
2304 
2305 #endif
2306 
2307 static inline InterpolationQuality smoothingToInterpolationQuality(ImageSmoothingQuality quality)
2308 {
2309     switch (quality) {
2310     case ImageSmoothingQuality::Low:
2311         return InterpolationLow;
2312     case ImageSmoothingQuality::Medium:
2313         return InterpolationMedium;
2314     case ImageSmoothingQuality::High:
2315         return InterpolationHigh;
2316     }
2317 
2318     ASSERT_NOT_REACHED();
2319     return InterpolationLow;
2320 };
2321 
2322 auto CanvasRenderingContext2DBase::imageSmoothingQuality() const -&gt; ImageSmoothingQuality
2323 {
2324     return state().imageSmoothingQuality;
2325 }
2326 
2327 void CanvasRenderingContext2DBase::setImageSmoothingQuality(ImageSmoothingQuality quality)
2328 {
2329     if (quality == state().imageSmoothingQuality)
2330         return;
2331 
2332     realizeSaves();
2333     modifiableState().imageSmoothingQuality = quality;
2334 
2335     if (!state().imageSmoothingEnabled)
2336         return;
2337 
2338     if (auto* context = drawingContext())
2339         context-&gt;setImageInterpolationQuality(smoothingToInterpolationQuality(quality));
2340 }
2341 
2342 bool CanvasRenderingContext2DBase::imageSmoothingEnabled() const
2343 {
2344     return state().imageSmoothingEnabled;
2345 }
2346 
2347 void CanvasRenderingContext2DBase::setImageSmoothingEnabled(bool enabled)
2348 {
2349     if (enabled == state().imageSmoothingEnabled)
2350         return;
2351 
2352     realizeSaves();
2353     modifiableState().imageSmoothingEnabled = enabled;
2354     auto* c = drawingContext();
2355     if (c)
2356         c-&gt;setImageInterpolationQuality(enabled ? smoothingToInterpolationQuality(state().imageSmoothingQuality) : InterpolationNone);
2357 }
2358 
2359 void CanvasRenderingContext2DBase::setPath(Path2D&amp; path)
2360 {
2361     m_path = path.path();
2362 }
2363 
2364 Ref&lt;Path2D&gt; CanvasRenderingContext2DBase::getPath() const
2365 {
2366     return Path2D::create(m_path);
2367 }
2368 
2369 inline void CanvasRenderingContext2DBase::clearPathForDashboardBackwardCompatibilityMode()
2370 {
2371 #if ENABLE(DASHBOARD_SUPPORT)
2372     if (m_usesDashboardCompatibilityMode)
2373         m_path.clear();
2374 #endif
2375 }
2376 
2377 } // namespace WebCore
    </pre>
  </body>
</html>