<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WebCore/html/parser/HTMLConstructionSite.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2010 Google, Inc. All Rights Reserved.
  3  * Copyright (C) 2011-2017 Apple Inc. All rights reserved.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  * 1. Redistributions of source code must retain the above copyright
  9  *    notice, this list of conditions and the following disclaimer.
 10  * 2. Redistributions in binary form must reproduce the above copyright
 11  *    notice, this list of conditions and the following disclaimer in the
 12  *    documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY GOOGLE INC. ``AS IS&#39;&#39; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL GOOGLE INC. OR
 18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 #include &quot;config.h&quot;
 28 #include &quot;HTMLTreeBuilder.h&quot;
 29 
 30 #include &quot;Comment.h&quot;
 31 #include &quot;CustomElementRegistry.h&quot;
 32 #include &quot;DOMWindow.h&quot;
 33 #include &quot;DocumentFragment.h&quot;
 34 #include &quot;DocumentType.h&quot;
 35 #include &quot;Frame.h&quot;
 36 #include &quot;FrameLoader.h&quot;
 37 #include &quot;FrameLoaderClient.h&quot;
 38 #include &quot;HTMLElementFactory.h&quot;
 39 #include &quot;HTMLFormElement.h&quot;
 40 #include &quot;HTMLHtmlElement.h&quot;
 41 #include &quot;HTMLImageElement.h&quot;
 42 #include &quot;HTMLOptGroupElement.h&quot;
 43 #include &quot;HTMLOptionElement.h&quot;
 44 #include &quot;HTMLParserIdioms.h&quot;
 45 #include &quot;HTMLPictureElement.h&quot;
 46 #include &quot;HTMLScriptElement.h&quot;
 47 #include &quot;HTMLTemplateElement.h&quot;
 48 #include &quot;HTMLUnknownElement.h&quot;
 49 #include &quot;JSCustomElementInterface.h&quot;
 50 #include &quot;NotImplemented.h&quot;
 51 #include &quot;SVGElement.h&quot;
 52 #include &quot;Text.h&quot;
 53 
 54 namespace WebCore {
 55 
 56 using namespace HTMLNames;
 57 
 58 static inline void setAttributes(Element&amp; element, Vector&lt;Attribute&gt;&amp; attributes, ParserContentPolicy parserContentPolicy)
 59 {
 60     if (!scriptingContentIsAllowed(parserContentPolicy))
 61         element.stripScriptingAttributes(attributes);
 62     element.parserSetAttributes(attributes);
 63 }
 64 
 65 static inline void setAttributes(Element&amp; element, AtomicHTMLToken&amp; token, ParserContentPolicy parserContentPolicy)
 66 {
 67     setAttributes(element, token.attributes(), parserContentPolicy);
 68 }
 69 
 70 static bool hasImpliedEndTag(const HTMLStackItem&amp; item)
 71 {
 72     return item.hasTagName(ddTag)
 73         || item.hasTagName(dtTag)
 74         || item.hasTagName(liTag)
 75         || is&lt;HTMLOptionElement&gt;(item.node())
 76         || is&lt;HTMLOptGroupElement&gt;(item.node())
 77         || item.hasTagName(pTag)
 78         || item.hasTagName(rbTag)
 79         || item.hasTagName(rpTag)
 80         || item.hasTagName(rtTag)
 81         || item.hasTagName(rtcTag);
 82 }
 83 
 84 static bool shouldUseLengthLimit(const ContainerNode&amp; node)
 85 {
 86     return !node.hasTagName(scriptTag) &amp;&amp; !node.hasTagName(styleTag) &amp;&amp; !node.hasTagName(SVGNames::scriptTag);
 87 }
 88 
 89 static inline bool causesFosterParenting(const HTMLStackItem&amp; item)
 90 {
 91     return item.hasTagName(HTMLNames::tableTag)
 92         || item.hasTagName(HTMLNames::tbodyTag)
 93         || item.hasTagName(HTMLNames::tfootTag)
 94         || item.hasTagName(HTMLNames::theadTag)
 95         || item.hasTagName(HTMLNames::trTag);
 96 }
 97 
 98 static inline bool isAllWhitespace(const String&amp; string)
 99 {
100     return string.isAllSpecialCharacters&lt;isHTMLSpace&gt;();
101 }
102 
103 static inline void insert(HTMLConstructionSiteTask&amp; task)
104 {
105     if (is&lt;HTMLTemplateElement&gt;(*task.parent)) {
106         task.parent = &amp;downcast&lt;HTMLTemplateElement&gt;(*task.parent).content();
107         task.nextChild = nullptr;
108     }
109 
110     ASSERT(!task.child-&gt;parentNode());
111     if (task.nextChild)
112         task.parent-&gt;parserInsertBefore(*task.child, *task.nextChild);
113     else
114         task.parent-&gt;parserAppendChild(*task.child);
115 }
116 
117 static inline void executeInsertTask(HTMLConstructionSiteTask&amp; task)
118 {
119     ASSERT(task.operation == HTMLConstructionSiteTask::Insert);
120 
121     insert(task);
122 
123     task.child-&gt;beginParsingChildren();
124 
125     if (task.selfClosing)
126         task.child-&gt;finishParsingChildren();
127 }
128 
129 static inline void executeReparentTask(HTMLConstructionSiteTask&amp; task)
130 {
131     ASSERT(task.operation == HTMLConstructionSiteTask::Reparent);
132     ASSERT(!task.nextChild);
133 
134     if (auto parent = makeRefPtr(task.child-&gt;parentNode()))
135         parent-&gt;parserRemoveChild(*task.child);
136 
137     if (task.child-&gt;parentNode())
138         return;
139 
140     task.parent-&gt;parserAppendChild(*task.child);
141 }
142 
143 static inline void executeInsertAlreadyParsedChildTask(HTMLConstructionSiteTask&amp; task)
144 {
145     ASSERT(task.operation == HTMLConstructionSiteTask::InsertAlreadyParsedChild);
146 
147     if (RefPtr&lt;ContainerNode&gt; parent = task.child-&gt;parentNode())
148         parent-&gt;parserRemoveChild(*task.child);
149 
150     if (task.child-&gt;parentNode())
151         return;
152 
153     if (task.nextChild &amp;&amp; task.nextChild-&gt;parentNode() != task.parent)
154         return;
155 
156     insert(task);
157 }
158 
159 static inline void executeTakeAllChildrenAndReparentTask(HTMLConstructionSiteTask&amp; task)
160 {
161     ASSERT(task.operation == HTMLConstructionSiteTask::TakeAllChildrenAndReparent);
162     ASSERT(!task.nextChild);
163 
164     auto furthestBlock = makeRefPtr(task.oldParent());
165     task.parent-&gt;takeAllChildrenFrom(furthestBlock.get());
166 
167     RELEASE_ASSERT(!task.parent-&gt;parentNode());
168     furthestBlock-&gt;parserAppendChild(*task.parent);
169 }
170 
171 static inline void executeTask(HTMLConstructionSiteTask&amp; task)
172 {
173     switch (task.operation) {
174     case HTMLConstructionSiteTask::Insert:
175         executeInsertTask(task);
176         return;
177     // All the cases below this point are only used by the adoption agency.
178     case HTMLConstructionSiteTask::InsertAlreadyParsedChild:
179         executeInsertAlreadyParsedChildTask(task);
180         return;
181     case HTMLConstructionSiteTask::Reparent:
182         executeReparentTask(task);
183         return;
184     case HTMLConstructionSiteTask::TakeAllChildrenAndReparent:
185         executeTakeAllChildrenAndReparentTask(task);
186         return;
187     }
188     ASSERT_NOT_REACHED();
189 }
190 
191 void HTMLConstructionSite::attachLater(ContainerNode&amp; parent, Ref&lt;Node&gt;&amp;&amp; child, bool selfClosing)
192 {
193     ASSERT(scriptingContentIsAllowed(m_parserContentPolicy) || !is&lt;Element&gt;(child) || !isScriptElement(downcast&lt;Element&gt;(child.get())));
194     ASSERT(pluginContentIsAllowed(m_parserContentPolicy) || !child-&gt;isPluginElement());
195 
196     if (shouldFosterParent()) {
197         fosterParent(WTFMove(child));
198         return;
199     }
200 
201     HTMLConstructionSiteTask task(HTMLConstructionSiteTask::Insert);
202     task.parent = &amp;parent;
203     task.child = WTFMove(child);
204     task.selfClosing = selfClosing;
205 
206     // Add as a sibling of the parent if we have reached the maximum depth allowed.
207     if (m_openElements.stackDepth() &gt; m_maximumDOMTreeDepth &amp;&amp; task.parent-&gt;parentNode())
208         task.parent = task.parent-&gt;parentNode();
209 
210     ASSERT(task.parent);
211     m_taskQueue.append(WTFMove(task));
212 }
213 
214 void HTMLConstructionSite::executeQueuedTasks()
215 {
216     if (m_taskQueue.isEmpty())
217         return;
218 
219     // Copy the task queue into a local variable in case executeTask
220     // re-enters the parser.
221     TaskQueue queue = WTFMove(m_taskQueue);
222 
223     for (auto&amp; task : queue)
224         executeTask(task);
225 
226     // We might be detached now.
227 }
228 
229 HTMLConstructionSite::HTMLConstructionSite(Document&amp; document, ParserContentPolicy parserContentPolicy, unsigned maximumDOMTreeDepth)
230     : m_document(document)
231     , m_attachmentRoot(document)
232     , m_parserContentPolicy(parserContentPolicy)
233     , m_isParsingFragment(false)
234     , m_redirectAttachToFosterParent(false)
235     , m_maximumDOMTreeDepth(maximumDOMTreeDepth)
236     , m_inQuirksMode(document.inQuirksMode())
237 {
238     ASSERT(m_document.isHTMLDocument() || m_document.isXHTMLDocument());
239 }
240 
241 HTMLConstructionSite::HTMLConstructionSite(DocumentFragment&amp; fragment, ParserContentPolicy parserContentPolicy, unsigned maximumDOMTreeDepth)
242     : m_document(fragment.document())
243     , m_attachmentRoot(fragment)
244     , m_parserContentPolicy(parserContentPolicy)
245     , m_isParsingFragment(true)
246     , m_redirectAttachToFosterParent(false)
247     , m_maximumDOMTreeDepth(maximumDOMTreeDepth)
248     , m_inQuirksMode(fragment.document().inQuirksMode())
249 {
250     ASSERT(m_document.isHTMLDocument() || m_document.isXHTMLDocument());
251 }
252 
253 HTMLConstructionSite::~HTMLConstructionSite() = default;
254 
255 void HTMLConstructionSite::setForm(HTMLFormElement* form)
256 {
257     // This method should only be needed for HTMLTreeBuilder in the fragment case.
258     ASSERT(!m_form);
259     m_form = form;
260 }
261 
262 RefPtr&lt;HTMLFormElement&gt; HTMLConstructionSite::takeForm()
263 {
264     return WTFMove(m_form);
265 }
266 
267 void HTMLConstructionSite::dispatchDocumentElementAvailableIfNeeded()
268 {
269     if (m_isParsingFragment)
270         return;
271 
272     if (auto frame = makeRefPtr(m_document.frame()))
273         frame-&gt;injectUserScripts(InjectAtDocumentStart);
274 }
275 
276 void HTMLConstructionSite::insertHTMLHtmlStartTagBeforeHTML(AtomicHTMLToken&amp;&amp; token)
277 {
278     auto element = HTMLHtmlElement::create(m_document);
279     setAttributes(element, token, m_parserContentPolicy);
280     attachLater(m_attachmentRoot, element.copyRef());
281     m_openElements.pushHTMLHtmlElement(HTMLStackItem::create(element.copyRef(), WTFMove(token)));
282 
283     executeQueuedTasks();
284     element-&gt;insertedByParser();
285     dispatchDocumentElementAvailableIfNeeded();
286 }
287 
288 void HTMLConstructionSite::mergeAttributesFromTokenIntoElement(AtomicHTMLToken&amp;&amp; token, Element&amp; element)
289 {
290     if (token.attributes().isEmpty())
291         return;
292 
293     for (auto&amp; tokenAttribute : token.attributes()) {
294         if (!element.elementData() || !element.findAttributeByName(tokenAttribute.name()))
295             element.setAttribute(tokenAttribute.name(), tokenAttribute.value());
296     }
297 }
298 
299 void HTMLConstructionSite::insertHTMLHtmlStartTagInBody(AtomicHTMLToken&amp;&amp; token)
300 {
301     // Fragments do not have a root HTML element, so any additional HTML elements
302     // encountered during fragment parsing should be ignored.
303     if (m_isParsingFragment)
304         return;
305 
306     mergeAttributesFromTokenIntoElement(WTFMove(token), m_openElements.htmlElement());
307 }
308 
309 void HTMLConstructionSite::insertHTMLBodyStartTagInBody(AtomicHTMLToken&amp;&amp; token)
310 {
311     mergeAttributesFromTokenIntoElement(WTFMove(token), m_openElements.bodyElement());
312 }
313 
314 void HTMLConstructionSite::setDefaultCompatibilityMode()
315 {
316     if (m_isParsingFragment)
317         return;
318     if (m_document.isSrcdocDocument())
319         return;
320     setCompatibilityMode(DocumentCompatibilityMode::QuirksMode);
321 }
322 
323 void HTMLConstructionSite::setCompatibilityMode(DocumentCompatibilityMode mode)
324 {
325     m_inQuirksMode = (mode == DocumentCompatibilityMode::QuirksMode);
326     m_document.setCompatibilityMode(mode);
327 }
328 
329 void HTMLConstructionSite::setCompatibilityModeFromDoctype(const String&amp; name, const String&amp; publicId, const String&amp; systemId)
330 {
331     // There are three possible compatibility modes:
332     // Quirks - quirks mode emulates WinIE and NS4. CSS parsing is also relaxed in this mode, e.g., unit types can
333     // be omitted from numbers.
334     // Limited Quirks - This mode is identical to no-quirks mode except for its treatment of line-height in the inline box model.
335     // No Quirks - no quirks apply. Web pages will obey the specifications to the letter.
336 
337     // Check for Quirks Mode.
338     if (name != &quot;html&quot;
339         || startsWithLettersIgnoringASCIICase(publicId, &quot;+//silmaril//dtd html pro v0r11 19970101//&quot;)
340         || startsWithLettersIgnoringASCIICase(publicId, &quot;-//advasoft ltd//dtd html 3.0 aswedit + extensions//&quot;)
341         || startsWithLettersIgnoringASCIICase(publicId, &quot;-//as//dtd html 3.0 aswedit + extensions//&quot;)
342         || startsWithLettersIgnoringASCIICase(publicId, &quot;-//ietf//dtd html 2.0 level 1//&quot;)
343         || startsWithLettersIgnoringASCIICase(publicId, &quot;-//ietf//dtd html 2.0 level 2//&quot;)
344         || startsWithLettersIgnoringASCIICase(publicId, &quot;-//ietf//dtd html 2.0 strict level 1//&quot;)
345         || startsWithLettersIgnoringASCIICase(publicId, &quot;-//ietf//dtd html 2.0 strict level 2//&quot;)
346         || startsWithLettersIgnoringASCIICase(publicId, &quot;-//ietf//dtd html 2.0 strict//&quot;)
347         || startsWithLettersIgnoringASCIICase(publicId, &quot;-//ietf//dtd html 2.0//&quot;)
348         || startsWithLettersIgnoringASCIICase(publicId, &quot;-//ietf//dtd html 2.1e//&quot;)
349         || startsWithLettersIgnoringASCIICase(publicId, &quot;-//ietf//dtd html 3.0//&quot;)
350         || startsWithLettersIgnoringASCIICase(publicId, &quot;-//ietf//dtd html 3.2 final//&quot;)
351         || startsWithLettersIgnoringASCIICase(publicId, &quot;-//ietf//dtd html 3.2//&quot;)
352         || startsWithLettersIgnoringASCIICase(publicId, &quot;-//ietf//dtd html 3//&quot;)
353         || startsWithLettersIgnoringASCIICase(publicId, &quot;-//ietf//dtd html level 0//&quot;)
354         || startsWithLettersIgnoringASCIICase(publicId, &quot;-//ietf//dtd html level 1//&quot;)
355         || startsWithLettersIgnoringASCIICase(publicId, &quot;-//ietf//dtd html level 2//&quot;)
356         || startsWithLettersIgnoringASCIICase(publicId, &quot;-//ietf//dtd html level 3//&quot;)
357         || startsWithLettersIgnoringASCIICase(publicId, &quot;-//ietf//dtd html strict level 0//&quot;)
358         || startsWithLettersIgnoringASCIICase(publicId, &quot;-//ietf//dtd html strict level 1//&quot;)
359         || startsWithLettersIgnoringASCIICase(publicId, &quot;-//ietf//dtd html strict level 2//&quot;)
360         || startsWithLettersIgnoringASCIICase(publicId, &quot;-//ietf//dtd html strict level 3//&quot;)
361         || startsWithLettersIgnoringASCIICase(publicId, &quot;-//ietf//dtd html strict//&quot;)
362         || startsWithLettersIgnoringASCIICase(publicId, &quot;-//ietf//dtd html//&quot;)
363         || startsWithLettersIgnoringASCIICase(publicId, &quot;-//metrius//dtd metrius presentational//&quot;)
364         || startsWithLettersIgnoringASCIICase(publicId, &quot;-//microsoft//dtd internet explorer 2.0 html strict//&quot;)
365         || startsWithLettersIgnoringASCIICase(publicId, &quot;-//microsoft//dtd internet explorer 2.0 html//&quot;)
366         || startsWithLettersIgnoringASCIICase(publicId, &quot;-//microsoft//dtd internet explorer 2.0 tables//&quot;)
367         || startsWithLettersIgnoringASCIICase(publicId, &quot;-//microsoft//dtd internet explorer 3.0 html strict//&quot;)
368         || startsWithLettersIgnoringASCIICase(publicId, &quot;-//microsoft//dtd internet explorer 3.0 html//&quot;)
369         || startsWithLettersIgnoringASCIICase(publicId, &quot;-//microsoft//dtd internet explorer 3.0 tables//&quot;)
370         || startsWithLettersIgnoringASCIICase(publicId, &quot;-//netscape comm. corp.//dtd html//&quot;)
371         || startsWithLettersIgnoringASCIICase(publicId, &quot;-//netscape comm. corp.//dtd strict html//&quot;)
372         || startsWithLettersIgnoringASCIICase(publicId, &quot;-//o&#39;reilly and associates//dtd html 2.0//&quot;)
373         || startsWithLettersIgnoringASCIICase(publicId, &quot;-//o&#39;reilly and associates//dtd html extended 1.0//&quot;)
374         || startsWithLettersIgnoringASCIICase(publicId, &quot;-//o&#39;reilly and associates//dtd html extended relaxed 1.0//&quot;)
375         || startsWithLettersIgnoringASCIICase(publicId, &quot;-//softquad software//dtd hotmetal pro 6.0::19990601::extensions to html 4.0//&quot;)
376         || startsWithLettersIgnoringASCIICase(publicId, &quot;-//softquad//dtd hotmetal pro 4.0::19971010::extensions to html 4.0//&quot;)
377         || startsWithLettersIgnoringASCIICase(publicId, &quot;-//spyglass//dtd html 2.0 extended//&quot;)
378         || startsWithLettersIgnoringASCIICase(publicId, &quot;-//sq//dtd html 2.0 hotmetal + extensions//&quot;)
379         || startsWithLettersIgnoringASCIICase(publicId, &quot;-//sun microsystems corp.//dtd hotjava html//&quot;)
380         || startsWithLettersIgnoringASCIICase(publicId, &quot;-//sun microsystems corp.//dtd hotjava strict html//&quot;)
381         || startsWithLettersIgnoringASCIICase(publicId, &quot;-//w3c//dtd html 3 1995-03-24//&quot;)
382         || startsWithLettersIgnoringASCIICase(publicId, &quot;-//w3c//dtd html 3.2 draft//&quot;)
383         || startsWithLettersIgnoringASCIICase(publicId, &quot;-//w3c//dtd html 3.2 final//&quot;)
384         || startsWithLettersIgnoringASCIICase(publicId, &quot;-//w3c//dtd html 3.2//&quot;)
385         || startsWithLettersIgnoringASCIICase(publicId, &quot;-//w3c//dtd html 3.2s draft//&quot;)
386         || startsWithLettersIgnoringASCIICase(publicId, &quot;-//w3c//dtd html 4.0 frameset//&quot;)
387         || startsWithLettersIgnoringASCIICase(publicId, &quot;-//w3c//dtd html 4.0 transitional//&quot;)
388         || startsWithLettersIgnoringASCIICase(publicId, &quot;-//w3c//dtd html experimental 19960712//&quot;)
389         || startsWithLettersIgnoringASCIICase(publicId, &quot;-//w3c//dtd html experimental 970421//&quot;)
390         || startsWithLettersIgnoringASCIICase(publicId, &quot;-//w3c//dtd w3 html//&quot;)
391         || startsWithLettersIgnoringASCIICase(publicId, &quot;-//w3o//dtd w3 html 3.0//&quot;)
392         || equalLettersIgnoringASCIICase(publicId, &quot;-//w3o//dtd w3 html strict 3.0//en//&quot;)
393         || startsWithLettersIgnoringASCIICase(publicId, &quot;-//webtechs//dtd mozilla html 2.0//&quot;)
394         || startsWithLettersIgnoringASCIICase(publicId, &quot;-//webtechs//dtd mozilla html//&quot;)
395         || equalLettersIgnoringASCIICase(publicId, &quot;-/w3c/dtd html 4.0 transitional/en&quot;)
396         || equalLettersIgnoringASCIICase(publicId, &quot;html&quot;)
397         || equalLettersIgnoringASCIICase(systemId, &quot;http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd&quot;)
398         || (systemId.isEmpty() &amp;&amp; startsWithLettersIgnoringASCIICase(publicId, &quot;-//w3c//dtd html 4.01 frameset//&quot;))
399         || (systemId.isEmpty() &amp;&amp; startsWithLettersIgnoringASCIICase(publicId, &quot;-//w3c//dtd html 4.01 transitional//&quot;))) {
400         setCompatibilityMode(DocumentCompatibilityMode::QuirksMode);
401         return;
402     }
403 
404     // Check for Limited Quirks Mode.
405     if (startsWithLettersIgnoringASCIICase(publicId, &quot;-//w3c//dtd xhtml 1.0 frameset//&quot;)
406         || startsWithLettersIgnoringASCIICase(publicId, &quot;-//w3c//dtd xhtml 1.0 transitional//&quot;)
407         || (!systemId.isEmpty() &amp;&amp; startsWithLettersIgnoringASCIICase(publicId, &quot;-//w3c//dtd html 4.01 frameset//&quot;))
408         || (!systemId.isEmpty() &amp;&amp; startsWithLettersIgnoringASCIICase(publicId, &quot;-//w3c//dtd html 4.01 transitional//&quot;))) {
409         setCompatibilityMode(DocumentCompatibilityMode::LimitedQuirksMode);
410         return;
411     }
412 
413     // Otherwise we are No Quirks Mode.
414     setCompatibilityMode(DocumentCompatibilityMode::NoQuirksMode);
415 }
416 
417 void HTMLConstructionSite::finishedParsing()
418 {
419     m_document.finishedParsing();
420 }
421 
422 void HTMLConstructionSite::insertDoctype(AtomicHTMLToken&amp;&amp; token)
423 {
424     ASSERT(token.type() == HTMLToken::DOCTYPE);
425 
426     String publicId = token.publicIdentifier();
427     String systemId = token.systemIdentifier();
428 
429     attachLater(m_attachmentRoot, DocumentType::create(m_document, token.name(), publicId, systemId));
430 
431     // DOCTYPE nodes are only processed when parsing fragments w/o contextElements, which
432     // never occurs.  However, if we ever chose to support such, this code is subtly wrong,
433     // because context-less fragments can determine their own quirks mode, and thus change
434     // parsing rules (like &lt;p&gt; inside &lt;table&gt;).  For now we ASSERT that we never hit this code
435     // in a fragment, as changing the owning document&#39;s compatibility mode would be wrong.
436     ASSERT(!m_isParsingFragment);
437     if (m_isParsingFragment)
438         return;
439 
440     if (token.forceQuirks())
441         setCompatibilityMode(DocumentCompatibilityMode::QuirksMode);
442     else
443         setCompatibilityModeFromDoctype(token.name(), publicId, systemId);
444 }
445 
446 void HTMLConstructionSite::insertComment(AtomicHTMLToken&amp;&amp; token)
447 {
448     ASSERT(token.type() == HTMLToken::Comment);
449     attachLater(currentNode(), Comment::create(ownerDocumentForCurrentNode(), token.comment()));
450 }
451 
452 void HTMLConstructionSite::insertCommentOnDocument(AtomicHTMLToken&amp;&amp; token)
453 {
454     ASSERT(token.type() == HTMLToken::Comment);
455     attachLater(m_attachmentRoot, Comment::create(m_document, token.comment()));
456 }
457 
458 void HTMLConstructionSite::insertCommentOnHTMLHtmlElement(AtomicHTMLToken&amp;&amp; token)
459 {
460     ASSERT(token.type() == HTMLToken::Comment);
461     ContainerNode&amp; parent = m_openElements.rootNode();
462     attachLater(parent, Comment::create(parent.document(), token.comment()));
463 }
464 
465 void HTMLConstructionSite::insertHTMLHeadElement(AtomicHTMLToken&amp;&amp; token)
466 {
467     ASSERT(!shouldFosterParent());
468     m_head = HTMLStackItem::create(createHTMLElement(token), WTFMove(token));
469     attachLater(currentNode(), m_head-&gt;element());
470     m_openElements.pushHTMLHeadElement(*m_head);
471 }
472 
473 void HTMLConstructionSite::insertHTMLBodyElement(AtomicHTMLToken&amp;&amp; token)
474 {
475     ASSERT(!shouldFosterParent());
476     auto body = createHTMLElement(token);
477     attachLater(currentNode(), body.copyRef());
478     m_openElements.pushHTMLBodyElement(HTMLStackItem::create(WTFMove(body), WTFMove(token)));
479 }
480 
481 void HTMLConstructionSite::insertHTMLFormElement(AtomicHTMLToken&amp;&amp; token, bool isDemoted)
482 {
483     auto element = createHTMLElement(token);
484     auto&amp; formElement = downcast&lt;HTMLFormElement&gt;(element.get());
485     // If there is no template element on the stack of open elements, set the
486     // form element pointer to point to the element created.
487     if (!openElements().hasTemplateInHTMLScope())
488         m_form = &amp;formElement;
489     formElement.setDemoted(isDemoted);
490     attachLater(currentNode(), formElement);
491     m_openElements.push(HTMLStackItem::create(formElement, WTFMove(token)));
492 }
493 
494 void HTMLConstructionSite::insertHTMLElement(AtomicHTMLToken&amp;&amp; token)
495 {
496     auto element = createHTMLElement(token);
497     attachLater(currentNode(), element.copyRef());
498     m_openElements.push(HTMLStackItem::create(WTFMove(element), WTFMove(token)));
499 }
500 
501 std::unique_ptr&lt;CustomElementConstructionData&gt; HTMLConstructionSite::insertHTMLElementOrFindCustomElementInterface(AtomicHTMLToken&amp;&amp; token)
502 {
503     JSCustomElementInterface* elementInterface = nullptr;
504     RefPtr&lt;Element&gt; element = createHTMLElementOrFindCustomElementInterface(token, &amp;elementInterface);
505     if (UNLIKELY(elementInterface))
506         return std::make_unique&lt;CustomElementConstructionData&gt;(*elementInterface, token.name(), WTFMove(token.attributes()));
507     attachLater(currentNode(), *element);
508     m_openElements.push(HTMLStackItem::create(element.releaseNonNull(), WTFMove(token)));
509     return nullptr;
510 }
511 
512 void HTMLConstructionSite::insertCustomElement(Ref&lt;Element&gt;&amp;&amp; element, const AtomicString&amp; localName, Vector&lt;Attribute&gt;&amp;&amp; attributes)
513 {
514     setAttributes(element, attributes, m_parserContentPolicy);
515     attachLater(currentNode(), element.copyRef());
516     m_openElements.push(HTMLStackItem::create(WTFMove(element), localName, WTFMove(attributes)));
517     executeQueuedTasks();
518 }
519 
520 void HTMLConstructionSite::insertSelfClosingHTMLElement(AtomicHTMLToken&amp;&amp; token)
521 {
522     ASSERT(token.type() == HTMLToken::StartTag);
523     // Normally HTMLElementStack is responsible for calling finishParsingChildren,
524     // but self-closing elements are never in the element stack so the stack
525     // doesn&#39;t get a chance to tell them that we&#39;re done parsing their children.
526     attachLater(currentNode(), createHTMLElement(token), true);
527     // FIXME: Do we want to acknowledge the token&#39;s self-closing flag?
528     // http://www.whatwg.org/specs/web-apps/current-work/multipage/tokenization.html#acknowledge-self-closing-flag
529 }
530 
531 void HTMLConstructionSite::insertFormattingElement(AtomicHTMLToken&amp;&amp; token)
532 {
533     // http://www.whatwg.org/specs/web-apps/current-work/multipage/parsing.html#the-stack-of-open-elements
534     // Possible active formatting elements include:
535     // a, b, big, code, em, font, i, nobr, s, small, strike, strong, tt, and u.
536     ASSERT(isFormattingTag(token.name()));
537     insertHTMLElement(WTFMove(token));
538     m_activeFormattingElements.append(currentStackItem());
539 }
540 
541 void HTMLConstructionSite::insertScriptElement(AtomicHTMLToken&amp;&amp; token)
542 {
543     // http://www.whatwg.org/specs/web-apps/current-work/multipage/scripting-1.html#already-started
544     // http://html5.org/specs/dom-parsing.html#dom-range-createcontextualfragment
545     // For createContextualFragment, the specifications say to mark it parser-inserted and already-started and later unmark them.
546     // However, we short circuit that logic to avoid the subtree traversal to find script elements since scripts can never see
547     // those flags or effects thereof.
548     const bool parserInserted = m_parserContentPolicy != AllowScriptingContentAndDoNotMarkAlreadyStarted;
549     const bool alreadyStarted = m_isParsingFragment &amp;&amp; parserInserted;
550     auto element = HTMLScriptElement::create(scriptTag, ownerDocumentForCurrentNode(), parserInserted, alreadyStarted);
551     setAttributes(element, token, m_parserContentPolicy);
552     if (scriptingContentIsAllowed(m_parserContentPolicy))
553         attachLater(currentNode(), element.copyRef());
554     m_openElements.push(HTMLStackItem::create(WTFMove(element), WTFMove(token)));
555 }
556 
557 void HTMLConstructionSite::insertForeignElement(AtomicHTMLToken&amp;&amp; token, const AtomicString&amp; namespaceURI)
558 {
559     ASSERT(token.type() == HTMLToken::StartTag);
560     notImplemented(); // parseError when xmlns or xmlns:xlink are wrong.
561 
562     auto element = createElement(token, namespaceURI);
563     if (scriptingContentIsAllowed(m_parserContentPolicy) || !isScriptElement(element.get()))
564         attachLater(currentNode(), element.copyRef(), token.selfClosing());
565     if (!token.selfClosing())
566         m_openElements.push(HTMLStackItem::create(WTFMove(element), WTFMove(token), namespaceURI));
567 }
568 
569 void HTMLConstructionSite::insertTextNode(const String&amp; characters, WhitespaceMode whitespaceMode)
570 {
571     HTMLConstructionSiteTask task(HTMLConstructionSiteTask::Insert);
572     task.parent = &amp;currentNode();
573 
574     if (shouldFosterParent())
575         findFosterSite(task);
576 
577     // Strings composed entirely of whitespace are likely to be repeated.
578     // Turn them into AtomicString so we share a single string for each.
579     bool shouldUseAtomicString = whitespaceMode == AllWhitespace || (whitespaceMode == WhitespaceUnknown &amp;&amp; isAllWhitespace(characters));
580 
581     unsigned currentPosition = 0;
582     unsigned lengthLimit = shouldUseLengthLimit(*task.parent) ? Text::defaultLengthLimit : std::numeric_limits&lt;unsigned&gt;::max();
583 
584     // FIXME: Splitting text nodes into smaller chunks contradicts HTML5 spec, but is currently necessary
585     // for performance, see &lt;https://bugs.webkit.org/show_bug.cgi?id=55898&gt;.
586 
587     RefPtr&lt;Node&gt; previousChild = task.nextChild ? task.nextChild-&gt;previousSibling() : task.parent-&gt;lastChild();
588     if (is&lt;Text&gt;(previousChild)) {
589         // FIXME: We&#39;re only supposed to append to this text node if it
590         // was the last text node inserted by the parser.
591         currentPosition = downcast&lt;Text&gt;(*previousChild).parserAppendData(characters, 0, lengthLimit);
592     }
593 
594     while (currentPosition &lt; characters.length()) {
595         auto textNode = Text::createWithLengthLimit(task.parent-&gt;document(), shouldUseAtomicString ? AtomicString(characters).string() : characters, currentPosition, lengthLimit);
596         // If we have a whole string of unbreakable characters the above could lead to an infinite loop. Exceeding the length limit is the lesser evil.
597         if (!textNode-&gt;length()) {
598             String substring = characters.substring(currentPosition);
599             textNode = Text::create(task.parent-&gt;document(), shouldUseAtomicString ? AtomicString(substring).string() : substring);
600         }
601 
602         currentPosition += textNode-&gt;length();
603         ASSERT(currentPosition &lt;= characters.length());
604         task.child = WTFMove(textNode);
605 
606         executeTask(task);
607     }
608 }
609 
610 void HTMLConstructionSite::reparent(HTMLElementStack::ElementRecord&amp; newParent, HTMLElementStack::ElementRecord&amp; child)
611 {
612     HTMLConstructionSiteTask task(HTMLConstructionSiteTask::Reparent);
613     task.parent = &amp;newParent.node();
614     task.child = &amp;child.element();
615     m_taskQueue.append(WTFMove(task));
616 }
617 
618 void HTMLConstructionSite::insertAlreadyParsedChild(HTMLStackItem&amp; newParent, HTMLElementStack::ElementRecord&amp; child)
619 {
620     HTMLConstructionSiteTask task(HTMLConstructionSiteTask::InsertAlreadyParsedChild);
621     if (causesFosterParenting(newParent)) {
622         findFosterSite(task);
623         ASSERT(task.parent);
624     } else
625         task.parent = &amp;newParent.node();
626     task.child = &amp;child.element();
627     m_taskQueue.append(WTFMove(task));
628 }
629 
630 void HTMLConstructionSite::takeAllChildrenAndReparent(HTMLStackItem&amp; newParent, HTMLElementStack::ElementRecord&amp; oldParent)
631 {
632     HTMLConstructionSiteTask task(HTMLConstructionSiteTask::TakeAllChildrenAndReparent);
633     task.parent = &amp;newParent.node();
634     task.child = &amp;oldParent.node();
635     m_taskQueue.append(WTFMove(task));
636 }
637 
638 Ref&lt;Element&gt; HTMLConstructionSite::createElement(AtomicHTMLToken&amp; token, const AtomicString&amp; namespaceURI)
639 {
640     QualifiedName tagName(nullAtom(), token.name(), namespaceURI);
641     auto element = ownerDocumentForCurrentNode().createElement(tagName, true);
642     setAttributes(element, token, m_parserContentPolicy);
643     return element;
644 }
645 
646 inline Document&amp; HTMLConstructionSite::ownerDocumentForCurrentNode()
647 {
648     if (is&lt;HTMLTemplateElement&gt;(currentNode()))
649         return downcast&lt;HTMLTemplateElement&gt;(currentNode()).content().document();
650     return currentNode().document();
651 }
652 
653 static inline JSCustomElementInterface* findCustomElementInterface(Document&amp; ownerDocument, const AtomicString&amp; localName)
654 {
655     auto* window = ownerDocument.domWindow();
656     if (!window)
657         return nullptr;
658 
659     auto* registry = window-&gt;customElementRegistry();
660     if (LIKELY(!registry))
661         return nullptr;
662 
663     return registry-&gt;findInterface(localName);
664 }
665 
666 RefPtr&lt;Element&gt; HTMLConstructionSite::createHTMLElementOrFindCustomElementInterface(AtomicHTMLToken&amp; token, JSCustomElementInterface** customElementInterface)
667 {
668     auto&amp; localName = token.name();
669     // FIXME: This can&#39;t use HTMLConstructionSite::createElement because we
670     // have to pass the current form element.  We should rework form association
671     // to occur after construction to allow better code sharing here.
672     // http://www.whatwg.org/specs/web-apps/current-work/multipage/tree-construction.html#create-an-element-for-the-token
673     Document&amp; ownerDocument = ownerDocumentForCurrentNode();
674     bool insideTemplateElement = !ownerDocument.frame();
675     auto element = HTMLElementFactory::createKnownElement(localName, ownerDocument, insideTemplateElement ? nullptr : form(), true);
676     if (UNLIKELY(!element)) {
677         if (auto* elementInterface = findCustomElementInterface(ownerDocument, localName)) {
678             if (!m_isParsingFragment) {
679                 *customElementInterface = elementInterface;
680                 return nullptr;
681             }
682             element = HTMLElement::create(QualifiedName { nullAtom(), localName, xhtmlNamespaceURI }, ownerDocument);
683             element-&gt;setIsCustomElementUpgradeCandidate();
684             element-&gt;enqueueToUpgrade(*elementInterface);
685         } else {
686             QualifiedName qualifiedName { nullAtom(), localName, xhtmlNamespaceURI };
687             if (Document::validateCustomElementName(localName) == CustomElementNameValidationStatus::Valid) {
688                 element = HTMLElement::create(qualifiedName, ownerDocument);
689                 element-&gt;setIsCustomElementUpgradeCandidate();
690             } else
691                 element = HTMLUnknownElement::create(qualifiedName, ownerDocument);
692         }
693     }
694     ASSERT(element);
695 
696     // FIXME: This is a hack to connect images to pictures before the image has
697     // been inserted into the document. It can be removed once asynchronous image
698     // loading is working.
699     if (is&lt;HTMLPictureElement&gt;(currentNode()) &amp;&amp; is&lt;HTMLImageElement&gt;(*element))
700         downcast&lt;HTMLImageElement&gt;(*element).setPictureElement(&amp;downcast&lt;HTMLPictureElement&gt;(currentNode()));
701 
702     setAttributes(*element, token, m_parserContentPolicy);
703     ASSERT(element-&gt;isHTMLElement());
704     return element;
705 }
706 
707 Ref&lt;Element&gt; HTMLConstructionSite::createHTMLElement(AtomicHTMLToken&amp; token)
708 {
709     RefPtr&lt;Element&gt; element = createHTMLElementOrFindCustomElementInterface(token, nullptr);
710     ASSERT(element);
711     return element.releaseNonNull();
712 }
713 
714 Ref&lt;HTMLStackItem&gt; HTMLConstructionSite::createElementFromSavedToken(HTMLStackItem&amp; item)
715 {
716     // NOTE: Moving from item -&gt; token -&gt; item copies the Attribute vector twice!
717     AtomicHTMLToken fakeToken(HTMLToken::StartTag, item.localName(), Vector&lt;Attribute&gt;(item.attributes()));
718     ASSERT(item.namespaceURI() == HTMLNames::xhtmlNamespaceURI);
719     ASSERT(isFormattingTag(item.localName()));
720     return HTMLStackItem::create(createHTMLElement(fakeToken), WTFMove(fakeToken), item.namespaceURI());
721 }
722 
723 Optional&lt;unsigned&gt; HTMLConstructionSite::indexOfFirstUnopenFormattingElement() const
724 {
725     if (m_activeFormattingElements.isEmpty())
726         return WTF::nullopt;
727     unsigned index = m_activeFormattingElements.size();
728     do {
729         --index;
730         const auto&amp; entry = m_activeFormattingElements.at(index);
731         if (entry.isMarker() || m_openElements.contains(entry.element())) {
732             unsigned firstUnopenElementIndex = index + 1;
733             return firstUnopenElementIndex &lt; m_activeFormattingElements.size() ? firstUnopenElementIndex : Optional&lt;unsigned&gt;(WTF::nullopt);
734         }
735     } while (index);
736 
737     return index;
738 }
739 
740 void HTMLConstructionSite::reconstructTheActiveFormattingElements()
741 {
742     Optional&lt;unsigned&gt; firstUnopenElementIndex = indexOfFirstUnopenFormattingElement();
743     if (!firstUnopenElementIndex)
744         return;
745 
746     ASSERT(firstUnopenElementIndex.value() &lt; m_activeFormattingElements.size());
747     for (unsigned unopenEntryIndex = firstUnopenElementIndex.value(); unopenEntryIndex &lt; m_activeFormattingElements.size(); ++unopenEntryIndex) {
748         auto&amp; unopenedEntry = m_activeFormattingElements.at(unopenEntryIndex);
749         ASSERT(unopenedEntry.stackItem());
750         auto reconstructed = createElementFromSavedToken(*unopenedEntry.stackItem());
751         attachLater(currentNode(), reconstructed-&gt;node());
752         m_openElements.push(reconstructed.copyRef());
753         unopenedEntry.replaceElement(WTFMove(reconstructed));
754     }
755 }
756 
757 void HTMLConstructionSite::generateImpliedEndTagsWithExclusion(const AtomicString&amp; tagName)
758 {
759     while (hasImpliedEndTag(currentStackItem()) &amp;&amp; !currentStackItem().matchesHTMLTag(tagName))
760         m_openElements.pop();
761 }
762 
763 void HTMLConstructionSite::generateImpliedEndTags()
764 {
765     while (hasImpliedEndTag(currentStackItem()))
766         m_openElements.pop();
767 }
768 
769 void HTMLConstructionSite::findFosterSite(HTMLConstructionSiteTask&amp; task)
770 {
771     // When a node is to be foster parented, the last template element with no table element is below it in the stack of open elements is the foster parent element (NOT the template&#39;s parent!)
772     auto* lastTemplateElement = m_openElements.topmost(templateTag-&gt;localName());
773     if (lastTemplateElement &amp;&amp; !m_openElements.inTableScope(tableTag)) {
774         task.parent = &amp;lastTemplateElement-&gt;element();
775         return;
776     }
777 
778     if (auto* lastTableElementRecord = m_openElements.topmost(tableTag-&gt;localName())) {
779         auto&amp; lastTableElement = lastTableElementRecord-&gt;element();
780         auto parent = makeRefPtr(lastTableElement.parentNode());
781         // When parsing HTML fragments, we skip step 4.2 (&quot;Let root be a new html element with no attributes&quot;) for efficiency,
782         // and instead use the DocumentFragment as a root node. So we must treat the root node (DocumentFragment) as if it is a html element here.
783         bool parentCanBeFosterParent = parent &amp;&amp; (parent-&gt;isElementNode() || (m_isParsingFragment &amp;&amp; parent == &amp;m_openElements.rootNode()));
784         parentCanBeFosterParent = parentCanBeFosterParent || (is&lt;DocumentFragment&gt;(parent) &amp;&amp; downcast&lt;DocumentFragment&gt;(parent.get())-&gt;isTemplateContent());
785         if (parentCanBeFosterParent) {
786             task.parent = parent;
787             task.nextChild = &amp;lastTableElement;
788             return;
789         }
790         task.parent = &amp;lastTableElementRecord-&gt;next()-&gt;element();
791         return;
792     }
793     // Fragment case
794     task.parent = &amp;m_openElements.rootNode(); // DocumentFragment
795 }
796 
797 bool HTMLConstructionSite::shouldFosterParent() const
798 {
799     return m_redirectAttachToFosterParent &amp;&amp; causesFosterParenting(currentStackItem());
800 }
801 
802 void HTMLConstructionSite::fosterParent(Ref&lt;Node&gt;&amp;&amp; node)
803 {
804     HTMLConstructionSiteTask task(HTMLConstructionSiteTask::Insert);
805     findFosterSite(task);
806     task.child = WTFMove(node);
807     ASSERT(task.parent);
808 
809     m_taskQueue.append(WTFMove(task));
810 }
811 
812 }
    </pre>
  </body>
</html>