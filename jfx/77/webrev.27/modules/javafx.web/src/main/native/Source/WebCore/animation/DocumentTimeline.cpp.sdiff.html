<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/animation/DocumentTimeline.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DeclarativeAnimation.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DocumentTimeline.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/animation/DocumentTimeline.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;DocumentTimeline.h&quot;
 28 
 29 #include &quot;AnimationPlaybackEvent.h&quot;
 30 #include &quot;CSSAnimation.h&quot;
 31 #include &quot;CSSPropertyAnimation.h&quot;
 32 #include &quot;CSSTransition.h&quot;
 33 #include &quot;DOMWindow.h&quot;
 34 #include &quot;DeclarativeAnimation.h&quot;
 35 #include &quot;Document.h&quot;
<span class="line-removed"> 36 #include &quot;DocumentAnimationScheduler.h&quot;</span>
 37 #include &quot;GraphicsLayer.h&quot;
 38 #include &quot;KeyframeEffect.h&quot;
 39 #include &quot;Microtasks.h&quot;
 40 #include &quot;Node.h&quot;
 41 #include &quot;Page.h&quot;
 42 #include &quot;PseudoElement.h&quot;
 43 #include &quot;RenderElement.h&quot;
 44 #include &quot;RenderLayer.h&quot;
 45 #include &quot;RenderLayerBacking.h&quot;
 46 
 47 static const Seconds defaultAnimationInterval { 15_ms };
 48 static const Seconds throttledAnimationInterval { 30_ms };
 49 
 50 namespace WebCore {
 51 
 52 Ref&lt;DocumentTimeline&gt; DocumentTimeline::create(Document&amp; document)
 53 {
 54     return adoptRef(*new DocumentTimeline(document, 0_s));
 55 }
 56 
 57 Ref&lt;DocumentTimeline&gt; DocumentTimeline::create(Document&amp; document, DocumentTimelineOptions&amp;&amp; options)
 58 {
 59     return adoptRef(*new DocumentTimeline(document, Seconds::fromMilliseconds(options.originTime)));
 60 }
 61 
 62 DocumentTimeline::DocumentTimeline(Document&amp; document, Seconds originTime)
 63     : AnimationTimeline()
<span class="line-modified"> 64 #if !USE(REQUEST_ANIMATION_FRAME_DISPLAY_MONITOR)</span>
<span class="line-removed"> 65     , m_animationResolutionTimer(*this, &amp;DocumentTimeline::animationResolutionTimerFired)</span>
<span class="line-removed"> 66 #endif</span>
<span class="line-removed"> 67     , m_tickScheduleTimer(*this, &amp;DocumentTimeline::scheduleAnimationResolutionIfNeeded)</span>
 68     , m_document(&amp;document)
 69     , m_originTime(originTime)
 70 {
 71     if (m_document &amp;&amp; m_document-&gt;page() &amp;&amp; !m_document-&gt;page()-&gt;isVisible())
 72         suspendAnimations();
 73 }
 74 
 75 DocumentTimeline::~DocumentTimeline() = default;
 76 
 77 void DocumentTimeline::detachFromDocument()
 78 {
 79     m_currentTimeClearingTaskQueue.close();
 80     m_elementsWithRunningAcceleratedAnimations.clear();
 81 
 82     auto&amp; animationsToRemove = m_animations;
 83     while (!animationsToRemove.isEmpty())
 84         animationsToRemove.first()-&gt;remove();
 85 
 86     unscheduleAnimationResolution();
 87     m_document = nullptr;
</pre>
<hr />
<pre>
115     if (is&lt;PseudoElement&gt;(rhsOwningElement)) {
116         auto* rhsHostElement = downcast&lt;PseudoElement&gt;(rhsOwningElement)-&gt;hostElement();
117         if (lhsOwningElement == rhsHostElement)
118             return true;
119         rhsOwningElement = rhsHostElement;
120     }
121 
122     return lhsOwningElement-&gt;compareDocumentPosition(*rhsOwningElement) &amp; Node::DOCUMENT_POSITION_FOLLOWING;
123 }
124 
125 Vector&lt;RefPtr&lt;WebAnimation&gt;&gt; DocumentTimeline::getAnimations() const
126 {
127     ASSERT(m_document);
128 
129     Vector&lt;RefPtr&lt;WebAnimation&gt;&gt; cssTransitions;
130     Vector&lt;RefPtr&lt;WebAnimation&gt;&gt; cssAnimations;
131     Vector&lt;RefPtr&lt;WebAnimation&gt;&gt; webAnimations;
132 
133     // First, let&#39;s get all qualifying animations in their right group.
134     for (const auto&amp; animation : m_allAnimations) {
<span class="line-modified">135         if (!animation-&gt;isRelevant() || animation-&gt;timeline() != this || !is&lt;KeyframeEffect&gt;(animation-&gt;effect()))</span>
136             continue;
137 
138         auto* target = downcast&lt;KeyframeEffect&gt;(animation-&gt;effect())-&gt;target();
139         if (!target || !target-&gt;isDescendantOf(*m_document))
140             continue;
141 
<span class="line-modified">142         if (is&lt;CSSTransition&gt;(animation) &amp;&amp; downcast&lt;CSSTransition&gt;(animation)-&gt;owningElement())</span>
<span class="line-modified">143             cssTransitions.append(animation);</span>
<span class="line-modified">144         else if (is&lt;CSSAnimation&gt;(animation) &amp;&amp; downcast&lt;CSSAnimation&gt;(animation)-&gt;owningElement())</span>
<span class="line-modified">145             cssAnimations.append(animation);</span>
146         else
<span class="line-modified">147             webAnimations.append(animation);</span>
148     }
149 
150     // Now sort CSS Transitions by their composite order.
151     std::sort(cssTransitions.begin(), cssTransitions.end(), [](auto&amp; lhs, auto&amp; rhs) {
152         // https://drafts.csswg.org/css-transitions-2/#animation-composite-order
153         auto* lhsTransition = downcast&lt;CSSTransition&gt;(lhs.get());
154         auto* rhsTransition = downcast&lt;CSSTransition&gt;(rhs.get());
155 
156         auto* lhsOwningElement = lhsTransition-&gt;owningElement();
157         auto* rhsOwningElement = rhsTransition-&gt;owningElement();
158 
159         // If the owning element of A and B differs, sort A and B by tree order of their corresponding owning elements.
160         if (lhsOwningElement != rhsOwningElement)
161             return compareDeclarativeAnimationOwningElementPositionsInDocumentTreeOrder(lhsOwningElement, rhsOwningElement);
162 
163         // Otherwise, if A and B have different transition generation values, sort by their corresponding transition generation in ascending order.
164         if (lhsTransition-&gt;generationTime() != rhsTransition-&gt;generationTime())
165             return lhsTransition-&gt;generationTime() &lt; rhsTransition-&gt;generationTime();
166 
167         // Otherwise, sort A and B in ascending order by the Unicode codepoints that make up the expanded transition property name of each transition
</pre>
<hr />
<pre>
177 
178         // If the owning element of A and B differs, sort A and B by tree order of their corresponding owning elements.
179         if (lhsOwningElement != rhsOwningElement)
180             return compareDeclarativeAnimationOwningElementPositionsInDocumentTreeOrder(lhsOwningElement, rhsOwningElement);
181 
182         // Otherwise, sort A and B based on their position in the computed value of the animation-name property of the (common) owning element.
183         // In our case, this matches the time at which the animations were created and thus their relative position in m_allAnimations.
184         return false;
185     });
186 
187     // Finally, we can concatenate the sorted CSS Transitions, CSS Animations and Web Animations in their relative composite order.
188     Vector&lt;RefPtr&lt;WebAnimation&gt;&gt; animations;
189     animations.appendRange(cssTransitions.begin(), cssTransitions.end());
190     animations.appendRange(cssAnimations.begin(), cssAnimations.end());
191     animations.appendRange(webAnimations.begin(), webAnimations.end());
192     return animations;
193 }
194 
195 void DocumentTimeline::updateThrottlingState()
196 {
<span class="line-modified">197     scheduleAnimationResolutionIfNeeded();</span>
198 }
199 
200 Seconds DocumentTimeline::animationInterval() const
201 {
202     if (!m_document || !m_document-&gt;page())
203         return Seconds::infinity();
204     return m_document-&gt;page()-&gt;isLowPowerModeEnabled() ? throttledAnimationInterval : defaultAnimationInterval;
205 }
206 
207 void DocumentTimeline::suspendAnimations()
208 {
209     if (animationsAreSuspended())
210         return;
211 
212     if (!m_cachedCurrentTime)
<span class="line-modified">213         m_cachedCurrentTime = liveCurrentTime();</span>
214 
215     for (const auto&amp; animation : m_animations)
216         animation-&gt;setSuspended(true);
217 
218     m_isSuspended = true;
219 
220     applyPendingAcceleratedAnimations();
221 
222     unscheduleAnimationResolution();
223 }
224 
225 void DocumentTimeline::resumeAnimations()
226 {
227     if (!animationsAreSuspended())
228         return;
229 
230     m_cachedCurrentTime = WTF::nullopt;
231 
232     m_isSuspended = false;
233 
234     for (const auto&amp; animation : m_animations)
235         animation-&gt;setSuspended(false);
236 
<span class="line-modified">237     scheduleAnimationResolutionIfNeeded();</span>
238 }
239 
240 bool DocumentTimeline::animationsAreSuspended()
241 {
242     return m_isSuspended;
243 }
244 
245 unsigned DocumentTimeline::numberOfActiveAnimationsForTesting() const
246 {
247     unsigned count = 0;
248     for (const auto&amp; animation : m_animations) {
249         if (!animation-&gt;isSuspended())
250             ++count;
251     }
252     return count;
253 }
254 
<span class="line-modified">255 Seconds DocumentTimeline::liveCurrentTime() const</span>
256 {
<span class="line-modified">257 #if USE(REQUEST_ANIMATION_FRAME_DISPLAY_MONITOR)</span>
<span class="line-removed">258     return m_document-&gt;animationScheduler().lastTimestamp();</span>
<span class="line-removed">259 #else</span>
<span class="line-removed">260     return Seconds(m_document-&gt;domWindow()-&gt;nowTimestamp());</span>
<span class="line-removed">261 #endif</span>
262 }
263 
264 Optional&lt;Seconds&gt; DocumentTimeline::currentTime()
265 {
266     if (!m_document || !m_document-&gt;domWindow())
267         return AnimationTimeline::currentTime();
268 
<span class="line-modified">269     if (auto* mainDocumentTimeline = m_document-&gt;existingTimeline()) {</span>
<span class="line-modified">270         if (mainDocumentTimeline != this) {</span>
<span class="line-modified">271             if (auto mainDocumentTimelineCurrentTime = mainDocumentTimeline-&gt;currentTime())</span>
<span class="line-modified">272                 return mainDocumentTimelineCurrentTime.value() - m_originTime;</span>
<span class="line-modified">273             return WTF::nullopt;</span>
<span class="line-removed">274         }</span>
275     }
276 
<span class="line-modified">277     auto currentTime = liveCurrentTime();</span>
<span class="line-modified">278 </span>
<span class="line-modified">279 #if USE(REQUEST_ANIMATION_FRAME_DISPLAY_MONITOR)</span>
<span class="line-removed">280     // If we&#39;re in the middle of firing a frame, either due to a requestAnimationFrame callback</span>
<span class="line-removed">281     // or scheduling an animation update, we want to ensure we use the same time we&#39;re using as</span>
<span class="line-removed">282     // the timestamp for requestAnimationFrame() callbacks.</span>
<span class="line-removed">283     if (m_document-&gt;animationScheduler().isFiring())</span>
<span class="line-removed">284         cacheCurrentTime(currentTime);</span>
<span class="line-removed">285 #endif</span>
<span class="line-removed">286 </span>
<span class="line-removed">287     if (!m_cachedCurrentTime) {</span>
<span class="line-removed">288 #if USE(REQUEST_ANIMATION_FRAME_DISPLAY_MONITOR)</span>
<span class="line-removed">289         // If we&#39;re not in the middle of firing a frame, let&#39;s make our best guess at what the currentTime should</span>
<span class="line-removed">290         // be since the last time a frame fired by increment of our update interval. This way code using something</span>
<span class="line-removed">291         // like setTimeout() or handling events will get a time that&#39;s only updating at around 60fps, or less if</span>
<span class="line-removed">292         // we&#39;re throttled.</span>
<span class="line-removed">293         auto lastAnimationSchedulerTimestamp = currentTime;</span>
<span class="line-removed">294         auto delta = Seconds(m_document-&gt;domWindow()-&gt;nowTimestamp()) - lastAnimationSchedulerTimestamp;</span>
<span class="line-removed">295         int frames = std::floor(delta.seconds() / animationInterval().seconds());</span>
<span class="line-removed">296         cacheCurrentTime(lastAnimationSchedulerTimestamp + Seconds(frames * animationInterval().seconds()));</span>
<span class="line-removed">297 #else</span>
<span class="line-removed">298         cacheCurrentTime(currentTime);</span>
<span class="line-removed">299 #endif</span>
<span class="line-removed">300     }</span>
301     return m_cachedCurrentTime.value() - m_originTime;
302 }
303 
<span class="line-modified">304 void DocumentTimeline::cacheCurrentTime(Seconds newCurrentTime)</span>
305 {
<span class="line-modified">306     m_cachedCurrentTime = newCurrentTime;</span>
307     // We want to be sure to keep this time cached until we&#39;ve both finished running JS and finished updating
308     // animations, so we schedule the invalidation task and register a whenIdle callback on the VM, which will
309     // fire syncronously if no JS is running.
310     m_waitingOnVMIdle = true;
311     if (!m_currentTimeClearingTaskQueue.hasPendingTasks())
312         m_currentTimeClearingTaskQueue.enqueueTask(std::bind(&amp;DocumentTimeline::maybeClearCachedCurrentTime, this));
313     m_document-&gt;vm().whenIdle([this, protectedThis = makeRefPtr(this)]() {
314         m_waitingOnVMIdle = false;
315         maybeClearCachedCurrentTime();
316     });
317 }
318 
319 void DocumentTimeline::maybeClearCachedCurrentTime()
320 {
321     // We want to make sure we only clear the cached current time if we&#39;re not currently running
322     // JS or waiting on all current animation updating code to have completed. This is so that
323     // we&#39;re guaranteed to have a consistent current time reported for all work happening in a given
324     // JS frame or throughout updating animations in WebCore.
325     if (!m_isSuspended &amp;&amp; !m_waitingOnVMIdle &amp;&amp; !m_currentTimeClearingTaskQueue.hasPendingTasks())
326         m_cachedCurrentTime = WTF::nullopt;
327 }
328 
<span class="line-removed">329 void DocumentTimeline::scheduleAnimationResolutionIfNeeded()</span>
<span class="line-removed">330 {</span>
<span class="line-removed">331     if (!m_isUpdatingAnimations &amp;&amp; !m_isSuspended &amp;&amp; !m_animations.isEmpty())</span>
<span class="line-removed">332         scheduleAnimationResolution();</span>
<span class="line-removed">333 }</span>
<span class="line-removed">334 </span>
335 void DocumentTimeline::animationTimingDidChange(WebAnimation&amp; animation)
336 {
337     AnimationTimeline::animationTimingDidChange(animation);
<span class="line-modified">338     scheduleAnimationResolutionIfNeeded();</span>
339 }
340 
341 void DocumentTimeline::removeAnimation(WebAnimation&amp; animation)
342 {
343     AnimationTimeline::removeAnimation(animation);
344 
345     if (m_animations.isEmpty())
346         unscheduleAnimationResolution();
347 }
348 
349 void DocumentTimeline::scheduleAnimationResolution()
350 {
<span class="line-modified">351 #if USE(REQUEST_ANIMATION_FRAME_DISPLAY_MONITOR)</span>
<span class="line-modified">352     m_document-&gt;animationScheduler().scheduleWebAnimationsResolution();</span>
<span class="line-modified">353 #else</span>
<span class="line-modified">354     // FIXME: We need to use the same logic as ScriptedAnimationController here,</span>
<span class="line-modified">355     // which will be addressed by the refactor tracked by webkit.org/b/179293.</span>
<span class="line-modified">356     m_animationResolutionTimer.startOneShot(animationInterval());</span>
<span class="line-modified">357 #endif</span>

358 }
359 
360 void DocumentTimeline::unscheduleAnimationResolution()
361 {
362     m_tickScheduleTimer.stop();
<span class="line-modified">363 #if USE(REQUEST_ANIMATION_FRAME_DISPLAY_MONITOR)</span>
<span class="line-modified">364     m_document-&gt;animationScheduler().unscheduleWebAnimationsResolution();</span>
<span class="line-modified">365 #else</span>
<span class="line-modified">366     // FIXME: We need to use the same logic as ScriptedAnimationController here,</span>
<span class="line-modified">367     // which will be addressed by the refactor tracked by webkit.org/b/179293.</span>
<span class="line-modified">368     m_animationResolutionTimer.stop();</span>
<span class="line-modified">369 #endif</span>
<span class="line-modified">370 }</span>
<span class="line-modified">371 </span>
<span class="line-modified">372 #if USE(REQUEST_ANIMATION_FRAME_DISPLAY_MONITOR)</span>
<span class="line-modified">373 void DocumentTimeline::documentAnimationSchedulerDidFire()</span>
<span class="line-modified">374 #else</span>
<span class="line-modified">375 void DocumentTimeline::animationResolutionTimerFired()</span>
<span class="line-modified">376 #endif</span>
<span class="line-modified">377 {</span>
<span class="line-removed">378     updateAnimationsAndSendEvents();</span>
379     applyPendingAcceleratedAnimations();


380     scheduleNextTick();
381 }
382 
<span class="line-modified">383 void DocumentTimeline::updateAnimationsAndSendEvents()</span>
384 {
385     m_numberOfAnimationTimelineInvalidationsForTesting++;
386 
<span class="line-removed">387     m_isUpdatingAnimations = true;</span>
<span class="line-removed">388 </span>
389     // https://drafts.csswg.org/web-animations/#update-animations-and-send-events
390 
391     // 1. Update the current time of all timelines associated with doc passing now as the timestamp.
392 
393     Vector&lt;RefPtr&lt;WebAnimation&gt;&gt; animationsToRemove;
394     Vector&lt;RefPtr&lt;CSSTransition&gt;&gt; completedTransitions;
395 
396     for (auto&amp; animation : m_animations) {
397         if (animation-&gt;timeline() != this) {
398             ASSERT(!animation-&gt;timeline());
399             animationsToRemove.append(animation);
400             continue;
401         }
402 
403         // This will notify the animation that timing has changed and will call automatically
404         // schedule invalidation if required for this animation.
405         animation-&gt;tick();
406 
407         if (!animation-&gt;isRelevant() &amp;&amp; !animation-&gt;needsTick())
408             animationsToRemove.append(animation);
</pre>
<hr />
<pre>
431         if (!lhs-&gt;timelineTime() &amp;&amp; rhs-&gt;timelineTime())
432             return true;
433         if (!lhs-&gt;timelineTime() &amp;&amp; !rhs-&gt;timelineTime())
434             return true;
435         return lhs-&gt;timelineTime().value() &lt; rhs-&gt;timelineTime().value();
436     });
437 
438     // 6. Dispatch each of the events in events to dispatch at their corresponding target using the order established in the previous step.
439     for (auto&amp; pendingEvent : pendingAnimationEvents)
440         pendingEvent-&gt;target()-&gt;dispatchEvent(pendingEvent);
441 
442     // This will cancel any scheduled invalidation if we end up removing all animations.
443     for (auto&amp; animation : animationsToRemove)
444         removeAnimation(*animation);
445 
446     // Now that animations that needed removal have been removed, let&#39;s update the list of completed transitions.
447     // This needs to happen after dealing with the list of animations to remove as the animation may have been
448     // removed from the list of completed transitions otherwise.
449     for (auto&amp; completedTransition : completedTransitions)
450         transitionDidComplete(completedTransition);
<span class="line-removed">451 </span>
<span class="line-removed">452     m_isUpdatingAnimations = false;</span>
453 }
454 
455 void DocumentTimeline::transitionDidComplete(RefPtr&lt;CSSTransition&gt; transition)
456 {
457     ASSERT(transition);
458     removeAnimation(*transition);
459     if (is&lt;KeyframeEffect&gt;(transition-&gt;effect())) {
460         if (auto* target = downcast&lt;KeyframeEffect&gt;(transition-&gt;effect())-&gt;target()) {
461             m_elementToCompletedCSSTransitionByCSSPropertyID.ensure(target, [] {
462                 return HashMap&lt;CSSPropertyID, RefPtr&lt;CSSTransition&gt;&gt; { };
463             }).iterator-&gt;value.set(transition-&gt;property(), transition);
464         }
465     }
466 }
467 
468 void DocumentTimeline::scheduleNextTick()
469 {
470     // There is no tick to schedule if we don&#39;t have any relevant animations.
471     if (m_animations.isEmpty())
472         return;
473 
474     for (const auto&amp; animation : m_animations) {
475         if (!animation-&gt;isRunningAccelerated()) {
<span class="line-modified">476             scheduleAnimationResolutionIfNeeded();</span>
477             return;
478         }
479     }
480 
481     Seconds scheduleDelay = Seconds::infinity();
482 
483     for (const auto&amp; animation : m_animations) {
484         auto animationTimeToNextRequiredTick = animation-&gt;timeToNextTick();
485         if (animationTimeToNextRequiredTick &lt; animationInterval()) {
<span class="line-modified">486             scheduleAnimationResolutionIfNeeded();</span>
487             return;
488         }
489         scheduleDelay = std::min(scheduleDelay, animationTimeToNextRequiredTick);
490     }
491 
492     if (scheduleDelay &lt; Seconds::infinity())
493         m_tickScheduleTimer.startOneShot(scheduleDelay);
494 }
495 
496 bool DocumentTimeline::computeExtentOfAnimation(RenderElement&amp; renderer, LayoutRect&amp; bounds) const
497 {
498     if (!renderer.element())
499         return true;
500 
501     KeyframeEffect* matchingEffect = nullptr;
502     for (const auto&amp; animation : animationsForElement(*renderer.element())) {
503         auto* effect = animation-&gt;effect();
504         if (is&lt;KeyframeEffect&gt;(effect)) {
505             auto* keyframeEffect = downcast&lt;KeyframeEffect&gt;(effect);
506             if (keyframeEffect-&gt;animatedProperties().contains(CSSPropertyTransform))
</pre>
<hr />
<pre>
576 
577 void DocumentTimeline::animationWasRemovedFromElement(WebAnimation&amp; animation, Element&amp; element)
578 {
579     AnimationTimeline::animationWasRemovedFromElement(animation, element);
580     updateListOfElementsWithRunningAcceleratedAnimationsForElement(element);
581 }
582 
583 void DocumentTimeline::animationAcceleratedRunningStateDidChange(WebAnimation&amp; animation)
584 {
585     m_acceleratedAnimationsPendingRunningStateChange.add(&amp;animation);
586 
587     if (is&lt;KeyframeEffect&gt;(animation.effect())) {
588         if (auto* target = downcast&lt;KeyframeEffect&gt;(animation.effect())-&gt;target())
589             updateListOfElementsWithRunningAcceleratedAnimationsForElement(*target);
590     }
591 }
592 
593 void DocumentTimeline::updateListOfElementsWithRunningAcceleratedAnimationsForElement(Element&amp; element)
594 {
595     auto animations = animationsForElement(element);
<span class="line-modified">596     bool runningAnimationsForElementAreAllAccelerated = !animations.isEmpty();</span>





597     for (const auto&amp; animation : animations) {
598         if (!animation-&gt;isRunningAccelerated()) {
<span class="line-modified">599             runningAnimationsForElementAreAllAccelerated = false;</span>
<span class="line-modified">600             break;</span>
601         }
602     }
603 
<span class="line-modified">604     if (runningAnimationsForElementAreAllAccelerated)</span>
<span class="line-removed">605         m_elementsWithRunningAcceleratedAnimations.add(&amp;element);</span>
<span class="line-removed">606     else</span>
<span class="line-removed">607         m_elementsWithRunningAcceleratedAnimations.remove(&amp;element);</span>
608 }
609 
610 void DocumentTimeline::applyPendingAcceleratedAnimations()
611 {
612     auto acceleratedAnimationsPendingRunningStateChange = m_acceleratedAnimationsPendingRunningStateChange;
613     m_acceleratedAnimationsPendingRunningStateChange.clear();
614 
615     bool hasForcedLayout = false;
616     for (auto&amp; animation : acceleratedAnimationsPendingRunningStateChange) {
617         if (!hasForcedLayout) {
618             auto* effect = animation-&gt;effect();
619             if (is&lt;KeyframeEffect&gt;(effect))
620                 hasForcedLayout |= downcast&lt;KeyframeEffect&gt;(effect)-&gt;forceLayoutIfNeeded();
621         }
622         animation-&gt;applyPendingAcceleratedActions();
623     }
624 }
625 
626 bool DocumentTimeline::resolveAnimationsForElement(Element&amp; element, RenderStyle&amp; targetStyle)
627 {
<span class="line-modified">628     bool hasNonAcceleratedAnimations = false;</span>
<span class="line-modified">629     bool hasPendingAcceleratedAnimations = true;</span>
630     for (const auto&amp; animation : animationsForElement(element)) {
631         animation-&gt;resolve(targetStyle);
<span class="line-modified">632         if (!hasNonAcceleratedAnimations) {</span>
<span class="line-modified">633             if (auto* effect = animation-&gt;effect()) {</span>
<span class="line-modified">634                 if (is&lt;KeyframeEffect&gt;(effect)) {</span>
<span class="line-modified">635                     auto* keyframeEffect = downcast&lt;KeyframeEffect&gt;(effect);</span>
<span class="line-modified">636                     for (auto cssPropertyId : keyframeEffect-&gt;animatedProperties()) {</span>
<span class="line-modified">637                         if (!CSSPropertyAnimation::animationOfPropertyIsAccelerated(cssPropertyId)) {</span>
<span class="line-modified">638                             hasNonAcceleratedAnimations = true;</span>
<span class="line-modified">639                             continue;</span>
<span class="line-modified">640                         }</span>
<span class="line-modified">641                         if (!hasPendingAcceleratedAnimations)</span>
<span class="line-modified">642                             hasPendingAcceleratedAnimations = keyframeEffect-&gt;hasPendingAcceleratedAction();</span>
<span class="line-modified">643                     }</span>
<span class="line-modified">644                 }</span>
645             }
646         }
647     }
648 
<span class="line-modified">649     // If there are no non-accelerated animations and we&#39;ve encountered at least one pending</span>
<span class="line-removed">650     // accelerated animation, we should recomposite this element&#39;s layer for animation purposes.</span>
<span class="line-removed">651     return !hasNonAcceleratedAnimations &amp;&amp; hasPendingAcceleratedAnimations;</span>
652 }
653 
654 bool DocumentTimeline::runningAnimationsForElementAreAllAccelerated(Element&amp; element) const
655 {
656     return m_elementsWithRunningAcceleratedAnimations.contains(&amp;element);
657 }
658 
659 void DocumentTimeline::enqueueAnimationPlaybackEvent(AnimationPlaybackEvent&amp; event)
660 {
661     m_pendingAnimationEvents.append(event);
662 }
663 
664 Vector&lt;std::pair&lt;String, double&gt;&gt; DocumentTimeline::acceleratedAnimationsForElement(Element&amp; element) const
665 {
666     auto* renderer = element.renderer();
667     if (renderer &amp;&amp; renderer-&gt;isComposited()) {
668         auto* compositedRenderer = downcast&lt;RenderBoxModelObject&gt;(renderer);
669         if (auto* graphicsLayer = compositedRenderer-&gt;layer()-&gt;backing()-&gt;graphicsLayer())
670             return graphicsLayer-&gt;acceleratedAnimationsForTesting();
671     }
</pre>
</td>
<td>
<hr />
<pre>
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;DocumentTimeline.h&quot;
 28 
 29 #include &quot;AnimationPlaybackEvent.h&quot;
 30 #include &quot;CSSAnimation.h&quot;
 31 #include &quot;CSSPropertyAnimation.h&quot;
 32 #include &quot;CSSTransition.h&quot;
 33 #include &quot;DOMWindow.h&quot;
 34 #include &quot;DeclarativeAnimation.h&quot;
 35 #include &quot;Document.h&quot;

 36 #include &quot;GraphicsLayer.h&quot;
 37 #include &quot;KeyframeEffect.h&quot;
 38 #include &quot;Microtasks.h&quot;
 39 #include &quot;Node.h&quot;
 40 #include &quot;Page.h&quot;
 41 #include &quot;PseudoElement.h&quot;
 42 #include &quot;RenderElement.h&quot;
 43 #include &quot;RenderLayer.h&quot;
 44 #include &quot;RenderLayerBacking.h&quot;
 45 
 46 static const Seconds defaultAnimationInterval { 15_ms };
 47 static const Seconds throttledAnimationInterval { 30_ms };
 48 
 49 namespace WebCore {
 50 
 51 Ref&lt;DocumentTimeline&gt; DocumentTimeline::create(Document&amp; document)
 52 {
 53     return adoptRef(*new DocumentTimeline(document, 0_s));
 54 }
 55 
 56 Ref&lt;DocumentTimeline&gt; DocumentTimeline::create(Document&amp; document, DocumentTimelineOptions&amp;&amp; options)
 57 {
 58     return adoptRef(*new DocumentTimeline(document, Seconds::fromMilliseconds(options.originTime)));
 59 }
 60 
 61 DocumentTimeline::DocumentTimeline(Document&amp; document, Seconds originTime)
 62     : AnimationTimeline()
<span class="line-modified"> 63     , m_tickScheduleTimer(*this, &amp;DocumentTimeline::scheduleAnimationResolution)</span>



 64     , m_document(&amp;document)
 65     , m_originTime(originTime)
 66 {
 67     if (m_document &amp;&amp; m_document-&gt;page() &amp;&amp; !m_document-&gt;page()-&gt;isVisible())
 68         suspendAnimations();
 69 }
 70 
 71 DocumentTimeline::~DocumentTimeline() = default;
 72 
 73 void DocumentTimeline::detachFromDocument()
 74 {
 75     m_currentTimeClearingTaskQueue.close();
 76     m_elementsWithRunningAcceleratedAnimations.clear();
 77 
 78     auto&amp; animationsToRemove = m_animations;
 79     while (!animationsToRemove.isEmpty())
 80         animationsToRemove.first()-&gt;remove();
 81 
 82     unscheduleAnimationResolution();
 83     m_document = nullptr;
</pre>
<hr />
<pre>
111     if (is&lt;PseudoElement&gt;(rhsOwningElement)) {
112         auto* rhsHostElement = downcast&lt;PseudoElement&gt;(rhsOwningElement)-&gt;hostElement();
113         if (lhsOwningElement == rhsHostElement)
114             return true;
115         rhsOwningElement = rhsHostElement;
116     }
117 
118     return lhsOwningElement-&gt;compareDocumentPosition(*rhsOwningElement) &amp; Node::DOCUMENT_POSITION_FOLLOWING;
119 }
120 
121 Vector&lt;RefPtr&lt;WebAnimation&gt;&gt; DocumentTimeline::getAnimations() const
122 {
123     ASSERT(m_document);
124 
125     Vector&lt;RefPtr&lt;WebAnimation&gt;&gt; cssTransitions;
126     Vector&lt;RefPtr&lt;WebAnimation&gt;&gt; cssAnimations;
127     Vector&lt;RefPtr&lt;WebAnimation&gt;&gt; webAnimations;
128 
129     // First, let&#39;s get all qualifying animations in their right group.
130     for (const auto&amp; animation : m_allAnimations) {
<span class="line-modified">131         if (!animation || !animation-&gt;isRelevant() || animation-&gt;timeline() != this || !is&lt;KeyframeEffect&gt;(animation-&gt;effect()))</span>
132             continue;
133 
134         auto* target = downcast&lt;KeyframeEffect&gt;(animation-&gt;effect())-&gt;target();
135         if (!target || !target-&gt;isDescendantOf(*m_document))
136             continue;
137 
<span class="line-modified">138         if (is&lt;CSSTransition&gt;(animation.get()) &amp;&amp; downcast&lt;CSSTransition&gt;(animation.get())-&gt;owningElement())</span>
<span class="line-modified">139             cssTransitions.append(animation.get());</span>
<span class="line-modified">140         else if (is&lt;CSSAnimation&gt;(animation.get()) &amp;&amp; downcast&lt;CSSAnimation&gt;(animation.get())-&gt;owningElement())</span>
<span class="line-modified">141             cssAnimations.append(animation.get());</span>
142         else
<span class="line-modified">143             webAnimations.append(animation.get());</span>
144     }
145 
146     // Now sort CSS Transitions by their composite order.
147     std::sort(cssTransitions.begin(), cssTransitions.end(), [](auto&amp; lhs, auto&amp; rhs) {
148         // https://drafts.csswg.org/css-transitions-2/#animation-composite-order
149         auto* lhsTransition = downcast&lt;CSSTransition&gt;(lhs.get());
150         auto* rhsTransition = downcast&lt;CSSTransition&gt;(rhs.get());
151 
152         auto* lhsOwningElement = lhsTransition-&gt;owningElement();
153         auto* rhsOwningElement = rhsTransition-&gt;owningElement();
154 
155         // If the owning element of A and B differs, sort A and B by tree order of their corresponding owning elements.
156         if (lhsOwningElement != rhsOwningElement)
157             return compareDeclarativeAnimationOwningElementPositionsInDocumentTreeOrder(lhsOwningElement, rhsOwningElement);
158 
159         // Otherwise, if A and B have different transition generation values, sort by their corresponding transition generation in ascending order.
160         if (lhsTransition-&gt;generationTime() != rhsTransition-&gt;generationTime())
161             return lhsTransition-&gt;generationTime() &lt; rhsTransition-&gt;generationTime();
162 
163         // Otherwise, sort A and B in ascending order by the Unicode codepoints that make up the expanded transition property name of each transition
</pre>
<hr />
<pre>
173 
174         // If the owning element of A and B differs, sort A and B by tree order of their corresponding owning elements.
175         if (lhsOwningElement != rhsOwningElement)
176             return compareDeclarativeAnimationOwningElementPositionsInDocumentTreeOrder(lhsOwningElement, rhsOwningElement);
177 
178         // Otherwise, sort A and B based on their position in the computed value of the animation-name property of the (common) owning element.
179         // In our case, this matches the time at which the animations were created and thus their relative position in m_allAnimations.
180         return false;
181     });
182 
183     // Finally, we can concatenate the sorted CSS Transitions, CSS Animations and Web Animations in their relative composite order.
184     Vector&lt;RefPtr&lt;WebAnimation&gt;&gt; animations;
185     animations.appendRange(cssTransitions.begin(), cssTransitions.end());
186     animations.appendRange(cssAnimations.begin(), cssAnimations.end());
187     animations.appendRange(webAnimations.begin(), webAnimations.end());
188     return animations;
189 }
190 
191 void DocumentTimeline::updateThrottlingState()
192 {
<span class="line-modified">193     scheduleAnimationResolution();</span>
194 }
195 
196 Seconds DocumentTimeline::animationInterval() const
197 {
198     if (!m_document || !m_document-&gt;page())
199         return Seconds::infinity();
200     return m_document-&gt;page()-&gt;isLowPowerModeEnabled() ? throttledAnimationInterval : defaultAnimationInterval;
201 }
202 
203 void DocumentTimeline::suspendAnimations()
204 {
205     if (animationsAreSuspended())
206         return;
207 
208     if (!m_cachedCurrentTime)
<span class="line-modified">209         m_cachedCurrentTime = Seconds(liveCurrentTime());</span>
210 
211     for (const auto&amp; animation : m_animations)
212         animation-&gt;setSuspended(true);
213 
214     m_isSuspended = true;
215 
216     applyPendingAcceleratedAnimations();
217 
218     unscheduleAnimationResolution();
219 }
220 
221 void DocumentTimeline::resumeAnimations()
222 {
223     if (!animationsAreSuspended())
224         return;
225 
226     m_cachedCurrentTime = WTF::nullopt;
227 
228     m_isSuspended = false;
229 
230     for (const auto&amp; animation : m_animations)
231         animation-&gt;setSuspended(false);
232 
<span class="line-modified">233     scheduleAnimationResolution();</span>
234 }
235 
236 bool DocumentTimeline::animationsAreSuspended()
237 {
238     return m_isSuspended;
239 }
240 
241 unsigned DocumentTimeline::numberOfActiveAnimationsForTesting() const
242 {
243     unsigned count = 0;
244     for (const auto&amp; animation : m_animations) {
245         if (!animation-&gt;isSuspended())
246             ++count;
247     }
248     return count;
249 }
250 
<span class="line-modified">251 DOMHighResTimeStamp DocumentTimeline::liveCurrentTime() const</span>
252 {
<span class="line-modified">253     return m_document-&gt;domWindow()-&gt;nowTimestamp();</span>




254 }
255 
256 Optional&lt;Seconds&gt; DocumentTimeline::currentTime()
257 {
258     if (!m_document || !m_document-&gt;domWindow())
259         return AnimationTimeline::currentTime();
260 
<span class="line-modified">261     auto&amp; mainDocumentTimeline = m_document-&gt;timeline();</span>
<span class="line-modified">262     if (&amp;mainDocumentTimeline != this) {</span>
<span class="line-modified">263         if (auto mainDocumentTimelineCurrentTime = mainDocumentTimeline.currentTime())</span>
<span class="line-modified">264             return *mainDocumentTimelineCurrentTime - m_originTime;</span>
<span class="line-modified">265         return WTF::nullopt;</span>

266     }
267 
<span class="line-modified">268     if (!m_cachedCurrentTime)</span>
<span class="line-modified">269         cacheCurrentTime(liveCurrentTime());</span>
<span class="line-modified">270 </span>





















271     return m_cachedCurrentTime.value() - m_originTime;
272 }
273 
<span class="line-modified">274 void DocumentTimeline::cacheCurrentTime(DOMHighResTimeStamp newCurrentTime)</span>
275 {
<span class="line-modified">276     m_cachedCurrentTime = Seconds(newCurrentTime);</span>
277     // We want to be sure to keep this time cached until we&#39;ve both finished running JS and finished updating
278     // animations, so we schedule the invalidation task and register a whenIdle callback on the VM, which will
279     // fire syncronously if no JS is running.
280     m_waitingOnVMIdle = true;
281     if (!m_currentTimeClearingTaskQueue.hasPendingTasks())
282         m_currentTimeClearingTaskQueue.enqueueTask(std::bind(&amp;DocumentTimeline::maybeClearCachedCurrentTime, this));
283     m_document-&gt;vm().whenIdle([this, protectedThis = makeRefPtr(this)]() {
284         m_waitingOnVMIdle = false;
285         maybeClearCachedCurrentTime();
286     });
287 }
288 
289 void DocumentTimeline::maybeClearCachedCurrentTime()
290 {
291     // We want to make sure we only clear the cached current time if we&#39;re not currently running
292     // JS or waiting on all current animation updating code to have completed. This is so that
293     // we&#39;re guaranteed to have a consistent current time reported for all work happening in a given
294     // JS frame or throughout updating animations in WebCore.
295     if (!m_isSuspended &amp;&amp; !m_waitingOnVMIdle &amp;&amp; !m_currentTimeClearingTaskQueue.hasPendingTasks())
296         m_cachedCurrentTime = WTF::nullopt;
297 }
298 






299 void DocumentTimeline::animationTimingDidChange(WebAnimation&amp; animation)
300 {
301     AnimationTimeline::animationTimingDidChange(animation);
<span class="line-modified">302     scheduleAnimationResolution();</span>
303 }
304 
305 void DocumentTimeline::removeAnimation(WebAnimation&amp; animation)
306 {
307     AnimationTimeline::removeAnimation(animation);
308 
309     if (m_animations.isEmpty())
310         unscheduleAnimationResolution();
311 }
312 
313 void DocumentTimeline::scheduleAnimationResolution()
314 {
<span class="line-modified">315     if (m_isSuspended || m_animations.isEmpty() || m_animationResolutionScheduled)</span>
<span class="line-modified">316         return;</span>
<span class="line-modified">317 </span>
<span class="line-modified">318     if (!m_document || !m_document-&gt;page())</span>
<span class="line-modified">319         return;</span>
<span class="line-modified">320 </span>
<span class="line-modified">321     m_document-&gt;page()-&gt;renderingUpdateScheduler().scheduleTimedRenderingUpdate();</span>
<span class="line-added">322     m_animationResolutionScheduled = true;</span>
323 }
324 
325 void DocumentTimeline::unscheduleAnimationResolution()
326 {
327     m_tickScheduleTimer.stop();
<span class="line-modified">328     m_animationResolutionScheduled = false;</span>
<span class="line-modified">329 }</span>
<span class="line-modified">330 </span>
<span class="line-modified">331 void DocumentTimeline::updateAnimationsAndSendEvents(DOMHighResTimeStamp timestamp)</span>
<span class="line-modified">332 {</span>
<span class="line-modified">333     // We need to freeze the current time even if no animation is running.</span>
<span class="line-modified">334     // document.timeline.currentTime may be called from a rAF callback and</span>
<span class="line-modified">335     // it has to match the rAF timestamp.</span>
<span class="line-modified">336     if (!m_isSuspended)</span>
<span class="line-modified">337         cacheCurrentTime(timestamp);</span>
<span class="line-modified">338 </span>
<span class="line-modified">339     if (m_isSuspended || m_animations.isEmpty() || !m_animationResolutionScheduled)</span>
<span class="line-modified">340         return;</span>
<span class="line-modified">341 </span>
<span class="line-modified">342     internalUpdateAnimationsAndSendEvents();</span>

343     applyPendingAcceleratedAnimations();
<span class="line-added">344 </span>
<span class="line-added">345     m_animationResolutionScheduled = false;</span>
346     scheduleNextTick();
347 }
348 
<span class="line-modified">349 void DocumentTimeline::internalUpdateAnimationsAndSendEvents()</span>
350 {
351     m_numberOfAnimationTimelineInvalidationsForTesting++;
352 


353     // https://drafts.csswg.org/web-animations/#update-animations-and-send-events
354 
355     // 1. Update the current time of all timelines associated with doc passing now as the timestamp.
356 
357     Vector&lt;RefPtr&lt;WebAnimation&gt;&gt; animationsToRemove;
358     Vector&lt;RefPtr&lt;CSSTransition&gt;&gt; completedTransitions;
359 
360     for (auto&amp; animation : m_animations) {
361         if (animation-&gt;timeline() != this) {
362             ASSERT(!animation-&gt;timeline());
363             animationsToRemove.append(animation);
364             continue;
365         }
366 
367         // This will notify the animation that timing has changed and will call automatically
368         // schedule invalidation if required for this animation.
369         animation-&gt;tick();
370 
371         if (!animation-&gt;isRelevant() &amp;&amp; !animation-&gt;needsTick())
372             animationsToRemove.append(animation);
</pre>
<hr />
<pre>
395         if (!lhs-&gt;timelineTime() &amp;&amp; rhs-&gt;timelineTime())
396             return true;
397         if (!lhs-&gt;timelineTime() &amp;&amp; !rhs-&gt;timelineTime())
398             return true;
399         return lhs-&gt;timelineTime().value() &lt; rhs-&gt;timelineTime().value();
400     });
401 
402     // 6. Dispatch each of the events in events to dispatch at their corresponding target using the order established in the previous step.
403     for (auto&amp; pendingEvent : pendingAnimationEvents)
404         pendingEvent-&gt;target()-&gt;dispatchEvent(pendingEvent);
405 
406     // This will cancel any scheduled invalidation if we end up removing all animations.
407     for (auto&amp; animation : animationsToRemove)
408         removeAnimation(*animation);
409 
410     // Now that animations that needed removal have been removed, let&#39;s update the list of completed transitions.
411     // This needs to happen after dealing with the list of animations to remove as the animation may have been
412     // removed from the list of completed transitions otherwise.
413     for (auto&amp; completedTransition : completedTransitions)
414         transitionDidComplete(completedTransition);


415 }
416 
417 void DocumentTimeline::transitionDidComplete(RefPtr&lt;CSSTransition&gt; transition)
418 {
419     ASSERT(transition);
420     removeAnimation(*transition);
421     if (is&lt;KeyframeEffect&gt;(transition-&gt;effect())) {
422         if (auto* target = downcast&lt;KeyframeEffect&gt;(transition-&gt;effect())-&gt;target()) {
423             m_elementToCompletedCSSTransitionByCSSPropertyID.ensure(target, [] {
424                 return HashMap&lt;CSSPropertyID, RefPtr&lt;CSSTransition&gt;&gt; { };
425             }).iterator-&gt;value.set(transition-&gt;property(), transition);
426         }
427     }
428 }
429 
430 void DocumentTimeline::scheduleNextTick()
431 {
432     // There is no tick to schedule if we don&#39;t have any relevant animations.
433     if (m_animations.isEmpty())
434         return;
435 
436     for (const auto&amp; animation : m_animations) {
437         if (!animation-&gt;isRunningAccelerated()) {
<span class="line-modified">438             scheduleAnimationResolution();</span>
439             return;
440         }
441     }
442 
443     Seconds scheduleDelay = Seconds::infinity();
444 
445     for (const auto&amp; animation : m_animations) {
446         auto animationTimeToNextRequiredTick = animation-&gt;timeToNextTick();
447         if (animationTimeToNextRequiredTick &lt; animationInterval()) {
<span class="line-modified">448             scheduleAnimationResolution();</span>
449             return;
450         }
451         scheduleDelay = std::min(scheduleDelay, animationTimeToNextRequiredTick);
452     }
453 
454     if (scheduleDelay &lt; Seconds::infinity())
455         m_tickScheduleTimer.startOneShot(scheduleDelay);
456 }
457 
458 bool DocumentTimeline::computeExtentOfAnimation(RenderElement&amp; renderer, LayoutRect&amp; bounds) const
459 {
460     if (!renderer.element())
461         return true;
462 
463     KeyframeEffect* matchingEffect = nullptr;
464     for (const auto&amp; animation : animationsForElement(*renderer.element())) {
465         auto* effect = animation-&gt;effect();
466         if (is&lt;KeyframeEffect&gt;(effect)) {
467             auto* keyframeEffect = downcast&lt;KeyframeEffect&gt;(effect);
468             if (keyframeEffect-&gt;animatedProperties().contains(CSSPropertyTransform))
</pre>
<hr />
<pre>
538 
539 void DocumentTimeline::animationWasRemovedFromElement(WebAnimation&amp; animation, Element&amp; element)
540 {
541     AnimationTimeline::animationWasRemovedFromElement(animation, element);
542     updateListOfElementsWithRunningAcceleratedAnimationsForElement(element);
543 }
544 
545 void DocumentTimeline::animationAcceleratedRunningStateDidChange(WebAnimation&amp; animation)
546 {
547     m_acceleratedAnimationsPendingRunningStateChange.add(&amp;animation);
548 
549     if (is&lt;KeyframeEffect&gt;(animation.effect())) {
550         if (auto* target = downcast&lt;KeyframeEffect&gt;(animation.effect())-&gt;target())
551             updateListOfElementsWithRunningAcceleratedAnimationsForElement(*target);
552     }
553 }
554 
555 void DocumentTimeline::updateListOfElementsWithRunningAcceleratedAnimationsForElement(Element&amp; element)
556 {
557     auto animations = animationsForElement(element);
<span class="line-modified">558 </span>
<span class="line-added">559     if (animations.isEmpty()) {</span>
<span class="line-added">560         m_elementsWithRunningAcceleratedAnimations.remove(&amp;element);</span>
<span class="line-added">561         return;</span>
<span class="line-added">562     }</span>
<span class="line-added">563 </span>
564     for (const auto&amp; animation : animations) {
565         if (!animation-&gt;isRunningAccelerated()) {
<span class="line-modified">566             m_elementsWithRunningAcceleratedAnimations.remove(&amp;element);</span>
<span class="line-modified">567             return;</span>
568         }
569     }
570 
<span class="line-modified">571     m_elementsWithRunningAcceleratedAnimations.add(&amp;element);</span>



572 }
573 
574 void DocumentTimeline::applyPendingAcceleratedAnimations()
575 {
576     auto acceleratedAnimationsPendingRunningStateChange = m_acceleratedAnimationsPendingRunningStateChange;
577     m_acceleratedAnimationsPendingRunningStateChange.clear();
578 
579     bool hasForcedLayout = false;
580     for (auto&amp; animation : acceleratedAnimationsPendingRunningStateChange) {
581         if (!hasForcedLayout) {
582             auto* effect = animation-&gt;effect();
583             if (is&lt;KeyframeEffect&gt;(effect))
584                 hasForcedLayout |= downcast&lt;KeyframeEffect&gt;(effect)-&gt;forceLayoutIfNeeded();
585         }
586         animation-&gt;applyPendingAcceleratedActions();
587     }
588 }
589 
590 bool DocumentTimeline::resolveAnimationsForElement(Element&amp; element, RenderStyle&amp; targetStyle)
591 {
<span class="line-modified">592     bool hasNonAcceleratedAnimationProperty = false;</span>
<span class="line-modified">593 </span>
594     for (const auto&amp; animation : animationsForElement(element)) {
595         animation-&gt;resolve(targetStyle);
<span class="line-modified">596 </span>
<span class="line-modified">597         if (hasNonAcceleratedAnimationProperty)</span>
<span class="line-modified">598             continue;</span>
<span class="line-modified">599 </span>
<span class="line-modified">600         auto* effect = animation-&gt;effect();</span>
<span class="line-modified">601         if (!effect || !is&lt;KeyframeEffect&gt;(effect))</span>
<span class="line-modified">602             continue;</span>
<span class="line-modified">603 </span>
<span class="line-modified">604         auto* keyframeEffect = downcast&lt;KeyframeEffect&gt;(effect);</span>
<span class="line-modified">605         for (auto cssPropertyId : keyframeEffect-&gt;animatedProperties()) {</span>
<span class="line-modified">606             if (!CSSPropertyAnimation::animationOfPropertyIsAccelerated(cssPropertyId)) {</span>
<span class="line-modified">607                 hasNonAcceleratedAnimationProperty = true;</span>
<span class="line-modified">608                 break;</span>
609             }
610         }
611     }
612 
<span class="line-modified">613     return !hasNonAcceleratedAnimationProperty;</span>


614 }
615 
616 bool DocumentTimeline::runningAnimationsForElementAreAllAccelerated(Element&amp; element) const
617 {
618     return m_elementsWithRunningAcceleratedAnimations.contains(&amp;element);
619 }
620 
621 void DocumentTimeline::enqueueAnimationPlaybackEvent(AnimationPlaybackEvent&amp; event)
622 {
623     m_pendingAnimationEvents.append(event);
624 }
625 
626 Vector&lt;std::pair&lt;String, double&gt;&gt; DocumentTimeline::acceleratedAnimationsForElement(Element&amp; element) const
627 {
628     auto* renderer = element.renderer();
629     if (renderer &amp;&amp; renderer-&gt;isComposited()) {
630         auto* compositedRenderer = downcast&lt;RenderBoxModelObject&gt;(renderer);
631         if (auto* graphicsLayer = compositedRenderer-&gt;layer()-&gt;backing()-&gt;graphicsLayer())
632             return graphicsLayer-&gt;acceleratedAnimationsForTesting();
633     }
</pre>
</td>
</tr>
</table>
<center><a href="DeclarativeAnimation.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DocumentTimeline.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>