<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/GraphicsLayer.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2009 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 
  28 #include &quot;GraphicsLayer.h&quot;
  29 
  30 #include &quot;FloatPoint.h&quot;
  31 #include &quot;FloatRect.h&quot;
  32 #include &quot;GraphicsContext.h&quot;
  33 #include &quot;LayoutRect.h&quot;
  34 #include &quot;RotateTransformOperation.h&quot;
  35 #include &lt;wtf/HashMap.h&gt;
  36 #include &lt;wtf/NeverDestroyed.h&gt;
  37 #include &lt;wtf/text/CString.h&gt;
  38 #include &lt;wtf/text/StringBuilder.h&gt;
  39 #include &lt;wtf/text/TextStream.h&gt;
  40 #include &lt;wtf/text/WTFString.h&gt;
  41 
  42 #ifndef NDEBUG
  43 #include &lt;stdio.h&gt;
  44 #endif
  45 
  46 namespace WebCore {
  47 
  48 typedef HashMap&lt;const GraphicsLayer*, Vector&lt;FloatRect&gt;&gt; RepaintMap;
  49 static RepaintMap&amp; repaintRectMap()
  50 {
  51     static NeverDestroyed&lt;RepaintMap&gt; map;
  52     return map;
  53 }
  54 
  55 void KeyframeValueList::insert(std::unique_ptr&lt;const AnimationValue&gt; value)
  56 {
  57     for (size_t i = 0; i &lt; m_values.size(); ++i) {
  58         const AnimationValue* curValue = m_values[i].get();
  59         if (curValue-&gt;keyTime() == value-&gt;keyTime()) {
  60             ASSERT_NOT_REACHED();
  61             // insert after
  62             m_values.insert(i + 1, WTFMove(value));
  63             return;
  64         }
  65         if (curValue-&gt;keyTime() &gt; value-&gt;keyTime()) {
  66             // insert before
  67             m_values.insert(i, WTFMove(value));
  68             return;
  69         }
  70     }
  71 
  72     m_values.append(WTFMove(value));
  73 }
  74 
  75 #if !USE(CA)
  76 bool GraphicsLayer::supportsLayerType(Type type)
  77 {
  78     switch (type) {
  79     case Type::Normal:
  80     case Type::PageTiledBacking:
  81     case Type::ScrollContainer:
<a name="1" id="anc1"></a><span class="line-added">  82     case Type::ScrolledContents:</span>
  83         return true;
  84     case Type::Shape:
  85         return false;
  86     }
  87     ASSERT_NOT_REACHED();
  88     return false;
  89 }
  90 
  91 bool GraphicsLayer::supportsBackgroundColorContent()
  92 {
  93 #if USE(TEXTURE_MAPPER)
  94     return true;
  95 #else
  96     return false;
  97 #endif
  98 }
  99 
 100 bool GraphicsLayer::supportsSubpixelAntialiasedLayerText()
 101 {
 102     return false;
 103 }
 104 #endif
 105 
 106 #if !USE(COORDINATED_GRAPHICS)
 107 bool GraphicsLayer::supportsContentsTiling()
 108 {
 109     // FIXME: Enable the feature on different ports.
 110     return false;
 111 }
 112 #endif
 113 
 114 // Singleton client used for layers on which clearClient has been called.
<a name="2" id="anc2"></a><span class="line-modified"> 115 class EmptyGraphicsLayerClient final : public GraphicsLayerClient {</span>
 116     WTF_MAKE_FAST_ALLOCATED;
 117 public:
 118     static EmptyGraphicsLayerClient&amp; singleton();
 119 };
 120 
 121 EmptyGraphicsLayerClient&amp; EmptyGraphicsLayerClient::singleton()
 122 {
 123     static NeverDestroyed&lt;EmptyGraphicsLayerClient&gt; client;
 124     return client;
 125 }
 126 
 127 GraphicsLayer::GraphicsLayer(Type type, GraphicsLayerClient&amp; layerClient)
 128     : m_client(&amp;layerClient)
 129     , m_type(type)
 130     , m_beingDestroyed(false)
 131     , m_contentsOpaque(false)
 132     , m_supportsSubpixelAntialiasedText(false)
 133     , m_preserves3D(false)
 134     , m_backfaceVisibility(true)
 135     , m_masksToBounds(false)
 136     , m_drawsContent(false)
 137     , m_contentsVisible(true)
 138     , m_acceleratesDrawing(false)
 139     , m_usesDisplayListDrawing(false)
 140     , m_appliesPageScale(false)
 141     , m_showDebugBorder(false)
 142     , m_showRepaintCounter(false)
 143     , m_isMaskLayer(false)
 144     , m_isTrackingDisplayListReplay(false)
 145     , m_userInteractionEnabled(true)
 146     , m_canDetachBackingStore(true)
 147 {
 148 #ifndef NDEBUG
 149     client().verifyNotPainting();
 150 #endif
 151 }
 152 
 153 GraphicsLayer::~GraphicsLayer()
 154 {
 155     resetTrackedRepaints();
 156     ASSERT(!m_parent); // willBeDestroyed should have been called already.
 157 }
 158 
 159 void GraphicsLayer::unparentAndClear(RefPtr&lt;GraphicsLayer&gt;&amp; layer)
 160 {
 161     if (layer) {
 162         layer-&gt;removeFromParent();
 163         layer-&gt;clearClient();
 164         layer = nullptr;
 165     }
 166 }
 167 
 168 void GraphicsLayer::clear(RefPtr&lt;GraphicsLayer&gt;&amp; layer)
 169 {
 170     if (layer) {
 171         layer-&gt;clearClient();
 172         layer = nullptr;
 173     }
 174 }
 175 
 176 void GraphicsLayer::willBeDestroyed()
 177 {
 178     m_beingDestroyed = true;
 179 #ifndef NDEBUG
 180     client().verifyNotPainting();
 181 #endif
 182     if (m_replicaLayer)
 183         m_replicaLayer-&gt;setReplicatedLayer(nullptr);
 184 
 185     if (m_replicatedLayer)
 186         m_replicatedLayer-&gt;setReplicatedByLayer(nullptr);
 187 
 188     if (m_maskLayer) {
 189         m_maskLayer-&gt;setParent(nullptr);
 190         m_maskLayer-&gt;setIsMaskLayer(false);
 191     }
 192 
 193     removeAllChildren();
 194     removeFromParent();
 195 }
 196 
 197 void GraphicsLayer::clearClient()
 198 {
 199     m_client = &amp;EmptyGraphicsLayerClient::singleton();
 200 }
 201 
 202 void GraphicsLayer::setClient(GraphicsLayerClient&amp; client)
 203 {
 204     m_client = &amp;client;
 205 }
 206 
 207 void GraphicsLayer::setParent(GraphicsLayer* layer)
 208 {
 209     ASSERT(!layer || !layer-&gt;hasAncestor(this));
 210     m_parent = layer;
 211 }
 212 
 213 bool GraphicsLayer::hasAncestor(GraphicsLayer* ancestor) const
 214 {
 215     for (GraphicsLayer* curr = parent(); curr; curr = curr-&gt;parent()) {
 216         if (curr == ancestor)
 217             return true;
 218     }
 219 
 220     return false;
 221 }
 222 
 223 bool GraphicsLayer::setChildren(Vector&lt;Ref&lt;GraphicsLayer&gt;&gt;&amp;&amp; newChildren)
 224 {
 225     // If the contents of the arrays are the same, nothing to do.
 226     if (newChildren == m_children)
 227         return false;
 228 
 229     removeAllChildren();
 230 
 231     size_t listSize = newChildren.size();
 232     for (size_t i = 0; i &lt; listSize; ++i)
 233         addChild(WTFMove(newChildren[i]));
 234 
 235     return true;
 236 }
 237 
 238 void GraphicsLayer::addChild(Ref&lt;GraphicsLayer&gt;&amp;&amp; childLayer)
 239 {
 240     ASSERT(childLayer.ptr() != this);
 241 
 242     childLayer-&gt;removeFromParent();
 243     childLayer-&gt;setParent(this);
 244     m_children.append(WTFMove(childLayer));
 245 }
 246 
 247 void GraphicsLayer::addChildAtIndex(Ref&lt;GraphicsLayer&gt;&amp;&amp; childLayer, int index)
 248 {
 249     ASSERT(childLayer.ptr() != this);
 250 
 251     childLayer-&gt;removeFromParent();
 252     childLayer-&gt;setParent(this);
 253     m_children.insert(index, WTFMove(childLayer));
 254 }
 255 
 256 void GraphicsLayer::addChildBelow(Ref&lt;GraphicsLayer&gt;&amp;&amp; childLayer, GraphicsLayer* sibling)
 257 {
 258     ASSERT(childLayer.ptr() != this);
 259     childLayer-&gt;removeFromParent();
 260 
 261     childLayer-&gt;setParent(this);
 262 
 263     for (unsigned i = 0; i &lt; m_children.size(); i++) {
 264         if (sibling == m_children[i].ptr()) {
 265             m_children.insert(i, WTFMove(childLayer));
 266             return;
 267         }
 268     }
 269 
 270     m_children.append(WTFMove(childLayer));
 271 }
 272 
 273 void GraphicsLayer::addChildAbove(Ref&lt;GraphicsLayer&gt;&amp;&amp; childLayer, GraphicsLayer* sibling)
 274 {
 275     childLayer-&gt;removeFromParent();
 276     ASSERT(childLayer.ptr() != this);
 277 
 278     childLayer-&gt;setParent(this);
 279 
 280     for (unsigned i = 0; i &lt; m_children.size(); i++) {
 281         if (sibling == m_children[i].ptr()) {
 282             m_children.insert(i + 1, WTFMove(childLayer));
 283             return;
 284         }
 285     }
 286 
 287     m_children.append(WTFMove(childLayer));
 288 }
 289 
 290 bool GraphicsLayer::replaceChild(GraphicsLayer* oldChild, Ref&lt;GraphicsLayer&gt;&amp;&amp; newChild)
 291 {
 292     ASSERT(!newChild-&gt;parent());
 293 
 294     GraphicsLayer* rawNewChild = newChild.ptr();
 295 
 296     bool found = false;
 297     for (unsigned i = 0; i &lt; m_children.size(); i++) {
 298         if (oldChild == m_children[i].ptr()) {
 299             m_children[i] = WTFMove(newChild);
 300             found = true;
 301             break;
 302         }
 303     }
 304     if (found) {
 305         oldChild-&gt;setParent(nullptr);
 306 
 307         rawNewChild-&gt;removeFromParent();
 308         rawNewChild-&gt;setParent(this);
 309         return true;
 310     }
 311     return false;
 312 }
 313 
 314 void GraphicsLayer::removeAllChildren()
 315 {
 316     while (m_children.size()) {
 317         GraphicsLayer* curLayer = m_children[0].ptr();
 318         ASSERT(curLayer-&gt;parent());
 319         curLayer-&gt;removeFromParent();
 320         // curLayer may be destroyed here.
 321     }
 322 }
 323 
 324 void GraphicsLayer::removeFromParent()
 325 {
 326     if (m_parent) {
 327         GraphicsLayer* parent = m_parent;
 328         setParent(nullptr);
 329         parent-&gt;m_children.removeFirstMatching([this](auto&amp; layer) {
 330             return layer.ptr() == this;
 331         });
 332         // |this| may be destroyed here.
 333     }
 334 }
 335 
 336 const TransformationMatrix&amp; GraphicsLayer::transform() const
 337 {
 338     return m_transform ? *m_transform : TransformationMatrix::identity;
 339 }
 340 
 341 void GraphicsLayer::setTransform(const TransformationMatrix&amp; matrix)
 342 {
 343     if (m_transform)
 344         *m_transform = matrix;
 345     else
<a name="3" id="anc3"></a><span class="line-modified"> 346         m_transform = makeUnique&lt;TransformationMatrix&gt;(matrix);</span>
 347 }
 348 
 349 const TransformationMatrix&amp; GraphicsLayer::childrenTransform() const
 350 {
 351     return m_childrenTransform ? *m_childrenTransform : TransformationMatrix::identity;
 352 }
 353 
 354 void GraphicsLayer::setChildrenTransform(const TransformationMatrix&amp; matrix)
 355 {
 356     if (m_childrenTransform)
 357         *m_childrenTransform = matrix;
 358     else
<a name="4" id="anc4"></a><span class="line-modified"> 359         m_childrenTransform = makeUnique&lt;TransformationMatrix&gt;(matrix);</span>
 360 }
 361 
 362 void GraphicsLayer::setMaskLayer(RefPtr&lt;GraphicsLayer&gt;&amp;&amp; layer)
 363 {
 364     if (layer == m_maskLayer)
 365         return;
 366 
 367     if (layer) {
 368         layer-&gt;removeFromParent();
 369         layer-&gt;setParent(this);
 370         layer-&gt;setIsMaskLayer(true);
 371     } else if (m_maskLayer) {
 372         m_maskLayer-&gt;setParent(nullptr);
 373         m_maskLayer-&gt;setIsMaskLayer(false);
 374     }
 375 
 376     m_maskLayer = WTFMove(layer);
 377 }
 378 
 379 Path GraphicsLayer::shapeLayerPath() const
 380 {
 381 #if USE(CA)
 382     return m_shapeLayerPath;
 383 #else
 384     return Path();
 385 #endif
 386 }
 387 
 388 void GraphicsLayer::setShapeLayerPath(const Path&amp; path)
 389 {
 390 #if USE(CA)
 391     m_shapeLayerPath = path;
 392 #else
 393     UNUSED_PARAM(path);
 394 #endif
 395 }
 396 
 397 WindRule GraphicsLayer::shapeLayerWindRule() const
 398 {
 399 #if USE(CA)
 400     return m_shapeLayerWindRule;
 401 #else
 402     return WindRule::NonZero;
 403 #endif
 404 }
 405 
 406 void GraphicsLayer::setShapeLayerWindRule(WindRule windRule)
 407 {
 408 #if USE(CA)
 409     m_shapeLayerWindRule = windRule;
 410 #else
 411     UNUSED_PARAM(windRule);
 412 #endif
 413 }
 414 
<a name="5" id="anc5"></a><span class="line-added"> 415 void GraphicsLayer::setEventRegion(EventRegion&amp;&amp; eventRegion)</span>
<span class="line-added"> 416 {</span>
<span class="line-added"> 417     m_eventRegion = WTFMove(eventRegion);</span>
<span class="line-added"> 418 }</span>
<span class="line-added"> 419 </span>
 420 void GraphicsLayer::noteDeviceOrPageScaleFactorChangedIncludingDescendants()
 421 {
 422     deviceOrPageScaleFactorChanged();
 423 
 424     if (m_maskLayer)
 425         m_maskLayer-&gt;deviceOrPageScaleFactorChanged();
 426 
 427     if (m_replicaLayer)
 428         m_replicaLayer-&gt;noteDeviceOrPageScaleFactorChangedIncludingDescendants();
 429 
 430     for (auto&amp; layer : children())
 431         layer-&gt;noteDeviceOrPageScaleFactorChangedIncludingDescendants();
 432 }
 433 
 434 void GraphicsLayer::setIsInWindow(bool inWindow)
 435 {
 436     if (TiledBacking* tiledBacking = this-&gt;tiledBacking())
 437         tiledBacking-&gt;setIsInWindow(inWindow);
 438 }
 439 
 440 void GraphicsLayer::setReplicatedByLayer(RefPtr&lt;GraphicsLayer&gt;&amp;&amp; layer)
 441 {
 442     if (m_replicaLayer == layer)
 443         return;
 444 
 445     if (m_replicaLayer)
 446         m_replicaLayer-&gt;setReplicatedLayer(nullptr);
 447 
 448     if (layer)
 449         layer-&gt;setReplicatedLayer(this);
 450 
 451     m_replicaLayer = WTFMove(layer);
 452 }
 453 
 454 void GraphicsLayer::setOffsetFromRenderer(const FloatSize&amp; offset, ShouldSetNeedsDisplay shouldSetNeedsDisplay)
 455 {
 456     if (offset == m_offsetFromRenderer)
 457         return;
 458 
 459     m_offsetFromRenderer = offset;
 460 
 461     // If the compositing layer offset changes, we need to repaint.
 462     if (shouldSetNeedsDisplay == SetNeedsDisplay)
 463         setNeedsDisplay();
 464 }
 465 
 466 void GraphicsLayer::setScrollOffset(const ScrollOffset&amp; offset, ShouldSetNeedsDisplay shouldSetNeedsDisplay)
 467 {
 468     if (offset == m_scrollOffset)
 469         return;
 470 
 471     m_scrollOffset = offset;
 472 
 473     // If the compositing layer offset changes, we need to repaint.
 474     if (shouldSetNeedsDisplay == SetNeedsDisplay)
 475         setNeedsDisplay();
 476 }
 477 
 478 void GraphicsLayer::setSize(const FloatSize&amp; size)
 479 {
 480     if (size == m_size)
 481         return;
 482 
 483     m_size = size;
 484 
 485     if (shouldRepaintOnSizeChange())
 486         setNeedsDisplay();
 487 }
 488 
 489 void GraphicsLayer::setBackgroundColor(const Color&amp; color)
 490 {
 491     m_backgroundColor = color;
 492 }
 493 
<a name="6" id="anc6"></a><span class="line-added"> 494 void GraphicsLayer::setPaintingPhase(OptionSet&lt;GraphicsLayerPaintingPhase&gt; phase)</span>
<span class="line-added"> 495 {</span>
<span class="line-added"> 496     if (phase == m_paintingPhase)</span>
<span class="line-added"> 497         return;</span>
<span class="line-added"> 498 </span>
<span class="line-added"> 499     setNeedsDisplay();</span>
<span class="line-added"> 500     m_paintingPhase = phase;</span>
<span class="line-added"> 501 }</span>
<span class="line-added"> 502 </span>
 503 void GraphicsLayer::paintGraphicsLayerContents(GraphicsContext&amp; context, const FloatRect&amp; clip, GraphicsLayerPaintBehavior layerPaintBehavior)
 504 {
 505     FloatSize offset = offsetFromRenderer() - toFloatSize(scrollOffset());
 506     context.translate(-offset);
 507 
 508     FloatRect clipRect(clip);
 509     clipRect.move(offset);
 510 
 511     client().paintContents(this, context, m_paintingPhase, clipRect, layerPaintBehavior);
 512 }
 513 
<a name="7" id="anc7"></a><span class="line-added"> 514 FloatRect GraphicsLayer::adjustCoverageRectForMovement(const FloatRect&amp; coverageRect, const FloatRect&amp; previousVisibleRect, const FloatRect&amp; currentVisibleRect)</span>
<span class="line-added"> 515 {</span>
<span class="line-added"> 516     // If the old visible rect is empty, we have no information about how the visible area is changing</span>
<span class="line-added"> 517     // (maybe the layer was just created), so don&#39;t attempt to expand. Also don&#39;t attempt to expand if the rects don&#39;t overlap.</span>
<span class="line-added"> 518     if (previousVisibleRect.isEmpty() || !currentVisibleRect.intersects(previousVisibleRect))</span>
<span class="line-added"> 519         return unionRect(coverageRect, currentVisibleRect);</span>
<span class="line-added"> 520 </span>
<span class="line-added"> 521     const float paddingMultiplier = 2;</span>
<span class="line-added"> 522 </span>
<span class="line-added"> 523     float leftEdgeDelta = paddingMultiplier * (currentVisibleRect.x() - previousVisibleRect.x());</span>
<span class="line-added"> 524     float rightEdgeDelta = paddingMultiplier * (currentVisibleRect.maxX() - previousVisibleRect.maxX());</span>
<span class="line-added"> 525 </span>
<span class="line-added"> 526     float topEdgeDelta = paddingMultiplier * (currentVisibleRect.y() - previousVisibleRect.y());</span>
<span class="line-added"> 527     float bottomEdgeDelta = paddingMultiplier * (currentVisibleRect.maxY() - previousVisibleRect.maxY());</span>
<span class="line-added"> 528 </span>
<span class="line-added"> 529     FloatRect expandedRect = currentVisibleRect;</span>
<span class="line-added"> 530 </span>
<span class="line-added"> 531     // More exposed on left side.</span>
<span class="line-added"> 532     if (leftEdgeDelta &lt; 0) {</span>
<span class="line-added"> 533         float newLeft = expandedRect.x() + leftEdgeDelta;</span>
<span class="line-added"> 534         // Pad to the left, but don&#39;t reduce padding that&#39;s already in the backing store (since we&#39;re still exposing to the left).</span>
<span class="line-added"> 535         if (newLeft &lt; previousVisibleRect.x())</span>
<span class="line-added"> 536             expandedRect.shiftXEdgeTo(newLeft);</span>
<span class="line-added"> 537         else</span>
<span class="line-added"> 538             expandedRect.shiftXEdgeTo(previousVisibleRect.x());</span>
<span class="line-added"> 539     }</span>
<span class="line-added"> 540 </span>
<span class="line-added"> 541     // More exposed on right.</span>
<span class="line-added"> 542     if (rightEdgeDelta &gt; 0) {</span>
<span class="line-added"> 543         float newRight = expandedRect.maxX() + rightEdgeDelta;</span>
<span class="line-added"> 544         // Pad to the right, but don&#39;t reduce padding that&#39;s already in the backing store (since we&#39;re still exposing to the right).</span>
<span class="line-added"> 545         if (newRight &gt; previousVisibleRect.maxX())</span>
<span class="line-added"> 546             expandedRect.setWidth(newRight - expandedRect.x());</span>
<span class="line-added"> 547         else</span>
<span class="line-added"> 548             expandedRect.setWidth(previousVisibleRect.maxX() - expandedRect.x());</span>
<span class="line-added"> 549     }</span>
<span class="line-added"> 550 </span>
<span class="line-added"> 551     // More exposed at top.</span>
<span class="line-added"> 552     if (topEdgeDelta &lt; 0) {</span>
<span class="line-added"> 553         float newTop = expandedRect.y() + topEdgeDelta;</span>
<span class="line-added"> 554         if (newTop &lt; previousVisibleRect.y())</span>
<span class="line-added"> 555             expandedRect.shiftYEdgeTo(newTop);</span>
<span class="line-added"> 556         else</span>
<span class="line-added"> 557             expandedRect.shiftYEdgeTo(previousVisibleRect.y());</span>
<span class="line-added"> 558     }</span>
<span class="line-added"> 559 </span>
<span class="line-added"> 560     // More exposed on bottom.</span>
<span class="line-added"> 561     if (bottomEdgeDelta &gt; 0) {</span>
<span class="line-added"> 562         float newBottom = expandedRect.maxY() + bottomEdgeDelta;</span>
<span class="line-added"> 563         if (newBottom &gt; previousVisibleRect.maxY())</span>
<span class="line-added"> 564             expandedRect.setHeight(newBottom - expandedRect.y());</span>
<span class="line-added"> 565         else</span>
<span class="line-added"> 566             expandedRect.setHeight(previousVisibleRect.maxY() - expandedRect.y());</span>
<span class="line-added"> 567     }</span>
<span class="line-added"> 568 </span>
<span class="line-added"> 569     return unionRect(coverageRect, expandedRect);</span>
<span class="line-added"> 570 }</span>
<span class="line-added"> 571 </span>
 572 String GraphicsLayer::animationNameForTransition(AnimatedPropertyID property)
 573 {
 574     // | is not a valid identifier character in CSS, so this can never conflict with a keyframe identifier.
 575     StringBuilder id;
 576     id.appendLiteral(&quot;-|transition&quot;);
 577     id.appendNumber(static_cast&lt;int&gt;(property));
 578     id.append(&#39;-&#39;);
 579     return id.toString();
 580 }
 581 
 582 void GraphicsLayer::suspendAnimations(MonotonicTime)
 583 {
 584 }
 585 
 586 void GraphicsLayer::resumeAnimations()
 587 {
 588 }
 589 
 590 void GraphicsLayer::getDebugBorderInfo(Color&amp; color, float&amp; width) const
 591 {
 592     width = 2;
 593 
 594     if (needsBackdrop()) {
 595         color = Color(255, 0, 255, 128); // has backdrop: magenta
 596         width = 12;
 597         return;
 598     }
 599 
 600     if (drawsContent()) {
 601         if (tiledBacking()) {
 602             color = Color(255, 128, 0, 128); // tiled layer: orange
 603             return;
 604         }
 605 
 606         color = Color(0, 128, 32, 128); // normal layer: green
 607         return;
 608     }
 609 
 610     if (usesContentsLayer()) {
 611         color = Color(0, 64, 128, 150); // non-painting layer with contents: blue
 612         width = 8;
 613         return;
 614     }
 615 
 616     if (masksToBounds()) {
 617         color = Color(128, 255, 255, 48); // masking layer: pale blue
 618         width = 16;
 619         return;
 620     }
 621 
 622     color = Color(255, 255, 0, 192); // container: yellow
 623 }
 624 
 625 void GraphicsLayer::updateDebugIndicators()
 626 {
 627     if (!isShowingDebugBorder())
 628         return;
 629 
 630     Color borderColor;
 631     float width = 0;
 632     getDebugBorderInfo(borderColor, width);
 633     setDebugBorder(borderColor, width);
 634 }
 635 
 636 void GraphicsLayer::setZPosition(float position)
 637 {
 638     m_zPosition = position;
 639 }
 640 
 641 float GraphicsLayer::accumulatedOpacity() const
 642 {
 643     if (!preserves3D())
 644         return 1;
 645 
 646     return m_opacity * (parent() ? parent()-&gt;accumulatedOpacity() : 1);
 647 }
 648 
 649 void GraphicsLayer::distributeOpacity(float accumulatedOpacity)
 650 {
 651     // If this is a transform layer we need to distribute our opacity to all our children
 652 
 653     // Incoming accumulatedOpacity is the contribution from our parent(s). We mutiply this by our own
 654     // opacity to get the total contribution
 655     accumulatedOpacity *= m_opacity;
 656 
 657     setOpacityInternal(accumulatedOpacity);
 658 
 659     if (preserves3D()) {
 660         for (auto&amp; layer : children())
 661             layer-&gt;distributeOpacity(accumulatedOpacity);
 662     }
 663 }
 664 
 665 static inline const FilterOperations&amp; filterOperationsAt(const KeyframeValueList&amp; valueList, size_t index)
 666 {
 667     return static_cast&lt;const FilterAnimationValue&amp;&gt;(valueList.at(index)).value();
 668 }
 669 
 670 int GraphicsLayer::validateFilterOperations(const KeyframeValueList&amp; valueList)
 671 {
 672 #if ENABLE(FILTERS_LEVEL_2)
 673     ASSERT(valueList.property() == AnimatedPropertyFilter || valueList.property() == AnimatedPropertyWebkitBackdropFilter);
 674 #else
 675     ASSERT(valueList.property() == AnimatedPropertyFilter);
 676 #endif
 677 
 678     if (valueList.size() &lt; 2)
 679         return -1;
 680 
 681     // Empty filters match anything, so find the first non-empty entry as the reference
 682     size_t firstIndex = 0;
 683     for ( ; firstIndex &lt; valueList.size(); ++firstIndex) {
 684         if (!filterOperationsAt(valueList, firstIndex).operations().isEmpty())
 685             break;
 686     }
 687 
 688     if (firstIndex &gt;= valueList.size())
 689         return -1;
 690 
 691     const FilterOperations&amp; firstVal = filterOperationsAt(valueList, firstIndex);
 692 
 693     for (size_t i = firstIndex + 1; i &lt; valueList.size(); ++i) {
 694         const FilterOperations&amp; val = filterOperationsAt(valueList, i);
 695 
 696         // An emtpy filter list matches anything.
 697         if (val.operations().isEmpty())
 698             continue;
 699 
 700         if (!firstVal.operationsMatch(val))
 701             return -1;
 702     }
 703 
 704     return firstIndex;
 705 }
 706 
 707 // An &quot;invalid&quot; list is one whose functions don&#39;t match, and therefore has to be animated as a Matrix
 708 // The hasBigRotation flag will always return false if isValid is false. Otherwise hasBigRotation is
 709 // true if the rotation between any two keyframes is &gt;= 180 degrees.
 710 
 711 static inline const TransformOperations&amp; operationsAt(const KeyframeValueList&amp; valueList, size_t index)
 712 {
 713     return static_cast&lt;const TransformAnimationValue&amp;&gt;(valueList.at(index)).value();
 714 }
 715 
 716 int GraphicsLayer::validateTransformOperations(const KeyframeValueList&amp; valueList, bool&amp; hasBigRotation)
 717 {
 718     ASSERT(valueList.property() == AnimatedPropertyTransform);
 719 
 720     hasBigRotation = false;
 721 
 722     if (valueList.size() &lt; 2)
 723         return -1;
 724 
 725     // Empty transforms match anything, so find the first non-empty entry as the reference.
 726     size_t firstIndex = 0;
 727     for ( ; firstIndex &lt; valueList.size(); ++firstIndex) {
 728         if (!operationsAt(valueList, firstIndex).operations().isEmpty())
 729             break;
 730     }
 731 
 732     if (firstIndex &gt;= valueList.size())
 733         return -1;
 734 
 735     const TransformOperations&amp; firstVal = operationsAt(valueList, firstIndex);
 736 
 737     // See if the keyframes are valid.
 738     for (size_t i = firstIndex + 1; i &lt; valueList.size(); ++i) {
 739         const TransformOperations&amp; val = operationsAt(valueList, i);
 740 
 741         // An empty transform list matches anything.
 742         if (val.operations().isEmpty())
 743             continue;
 744 
 745         if (!firstVal.operationsMatch(val))
 746             return -1;
 747     }
 748 
 749     // Keyframes are valid, check for big rotations.
 750     double lastRotationAngle = 0.0;
 751     double maxRotationAngle = -1.0;
 752 
 753     for (size_t j = 0; j &lt; firstVal.operations().size(); ++j) {
 754         TransformOperation::OperationType type = firstVal.operations().at(j)-&gt;type();
 755 
 756         // if this is a rotation entry, we need to see if any angle differences are &gt;= 180 deg
 757         if (type == TransformOperation::ROTATE_X ||
 758             type == TransformOperation::ROTATE_Y ||
 759             type == TransformOperation::ROTATE_Z ||
 760             type == TransformOperation::ROTATE_3D) {
 761             lastRotationAngle = downcast&lt;RotateTransformOperation&gt;(*firstVal.operations().at(j)).angle();
 762 
 763             if (maxRotationAngle &lt; 0)
 764                 maxRotationAngle = fabs(lastRotationAngle);
 765 
 766             for (size_t i = firstIndex + 1; i &lt; valueList.size(); ++i) {
 767                 const TransformOperations&amp; val = operationsAt(valueList, i);
 768                 double rotationAngle = val.operations().isEmpty() ? 0 : downcast&lt;RotateTransformOperation&gt;(*val.operations().at(j)).angle();
 769                 double diffAngle = fabs(rotationAngle - lastRotationAngle);
 770                 if (diffAngle &gt; maxRotationAngle)
 771                     maxRotationAngle = diffAngle;
 772                 lastRotationAngle = rotationAngle;
 773             }
 774         }
 775     }
 776 
 777     hasBigRotation = maxRotationAngle &gt;= 180.0;
 778 
 779     return firstIndex;
 780 }
 781 
 782 double GraphicsLayer::backingStoreMemoryEstimate() const
 783 {
 784     if (!drawsContent())
 785         return 0;
 786 
 787     // Effects of page and device scale are ignored; subclasses should override to take these into account.
 788     return static_cast&lt;double&gt;(4 * size().width()) * size().height();
 789 }
 790 
 791 void GraphicsLayer::resetTrackedRepaints()
 792 {
 793     repaintRectMap().remove(this);
 794 }
 795 
 796 void GraphicsLayer::addRepaintRect(const FloatRect&amp; repaintRect)
 797 {
 798     if (!client().isTrackingRepaints())
 799         return;
 800 
 801     FloatRect largestRepaintRect(FloatPoint(), m_size);
 802     largestRepaintRect.intersect(repaintRect);
 803     RepaintMap::iterator repaintIt = repaintRectMap().find(this);
 804     if (repaintIt == repaintRectMap().end()) {
 805         Vector&lt;FloatRect&gt; repaintRects;
 806         repaintRects.append(largestRepaintRect);
 807         repaintRectMap().set(this, repaintRects);
 808     } else {
 809         Vector&lt;FloatRect&gt;&amp; repaintRects = repaintIt-&gt;value;
 810         repaintRects.append(largestRepaintRect);
 811     }
 812 }
 813 
 814 void GraphicsLayer::traverse(GraphicsLayer&amp; layer, const WTF::Function&lt;void (GraphicsLayer&amp;)&gt;&amp; traversalFunc)
 815 {
 816     traversalFunc(layer);
 817 
 818     for (auto&amp; childLayer : layer.children())
 819         traverse(childLayer.get(), traversalFunc);
 820 
 821     if (auto* replicaLayer = layer.replicaLayer())
 822         traverse(*replicaLayer, traversalFunc);
 823 
 824     if (auto* maskLayer = layer.maskLayer())
 825         traverse(*maskLayer, traversalFunc);
 826 }
 827 
 828 GraphicsLayer::EmbeddedViewID GraphicsLayer::nextEmbeddedViewID()
 829 {
 830     static GraphicsLayer::EmbeddedViewID nextEmbeddedViewID;
 831     return ++nextEmbeddedViewID;
 832 }
 833 
 834 void GraphicsLayer::dumpLayer(TextStream&amp; ts, LayerTreeAsTextBehavior behavior) const
 835 {
 836     ts &lt;&lt; indent &lt;&lt; &quot;(&quot; &lt;&lt; &quot;GraphicsLayer&quot;;
 837 
 838     if (behavior &amp; LayerTreeAsTextDebug) {
 839         ts &lt;&lt; &quot; &quot; &lt;&lt; static_cast&lt;void*&gt;(const_cast&lt;GraphicsLayer*&gt;(this));
 840         ts &lt;&lt; &quot; \&quot;&quot; &lt;&lt; m_name &lt;&lt; &quot;\&quot;&quot;;
 841     }
 842 
 843     ts &lt;&lt; &quot;\n&quot;;
 844     dumpProperties(ts, behavior);
 845     ts &lt;&lt; indent &lt;&lt; &quot;)\n&quot;;
 846 }
 847 
 848 static void dumpChildren(TextStream&amp; ts, const Vector&lt;Ref&lt;GraphicsLayer&gt;&gt;&amp; children, unsigned&amp; totalChildCount, LayerTreeAsTextBehavior behavior)
 849 {
 850     totalChildCount += children.size();
 851     for (auto&amp; child : children) {
 852         if ((behavior &amp; LayerTreeAsTextDebug) || !child-&gt;client().shouldSkipLayerInDump(child.ptr(), behavior)) {
 853             TextStream::IndentScope indentScope(ts);
 854             child-&gt;dumpLayer(ts, behavior);
 855             continue;
 856         }
 857 
 858         totalChildCount--;
 859         dumpChildren(ts, child-&gt;children(), totalChildCount, behavior);
 860     }
 861 }
 862 
 863 void GraphicsLayer::dumpProperties(TextStream&amp; ts, LayerTreeAsTextBehavior behavior) const
 864 {
 865     TextStream::IndentScope indentScope(ts);
 866     if (!m_offsetFromRenderer.isZero())
 867         ts &lt;&lt; indent &lt;&lt; &quot;(offsetFromRenderer &quot; &lt;&lt; m_offsetFromRenderer &lt;&lt; &quot;)\n&quot;;
 868 
 869     if (!m_scrollOffset.isZero())
 870         ts &lt;&lt; indent &lt;&lt; &quot;(scrollOffset &quot; &lt;&lt; m_scrollOffset &lt;&lt; &quot;)\n&quot;;
 871 
 872     if (m_position != FloatPoint())
 873         ts &lt;&lt; indent &lt;&lt; &quot;(position &quot; &lt;&lt; m_position.x() &lt;&lt; &quot; &quot; &lt;&lt; m_position.y() &lt;&lt; &quot;)\n&quot;;
 874 
 875     if (m_approximatePosition)
 876         ts &lt;&lt; indent &lt;&lt; &quot;(approximate position &quot; &lt;&lt; m_approximatePosition.value().x() &lt;&lt; &quot; &quot; &lt;&lt; m_approximatePosition.value().y() &lt;&lt; &quot;)\n&quot;;
 877 
 878     if (m_boundsOrigin != FloatPoint())
 879         ts &lt;&lt; indent &lt;&lt; &quot;(bounds origin &quot; &lt;&lt; m_boundsOrigin.x() &lt;&lt; &quot; &quot; &lt;&lt; m_boundsOrigin.y() &lt;&lt; &quot;)\n&quot;;
 880 
 881     if (m_anchorPoint != FloatPoint3D(0.5f, 0.5f, 0)) {
 882         ts &lt;&lt; indent &lt;&lt; &quot;(anchor &quot; &lt;&lt; m_anchorPoint.x() &lt;&lt; &quot; &quot; &lt;&lt; m_anchorPoint.y();
 883         if (m_anchorPoint.z())
 884             ts &lt;&lt; &quot; &quot; &lt;&lt; m_anchorPoint.z();
 885         ts &lt;&lt; &quot;)\n&quot;;
 886     }
 887 
 888     if (m_size != IntSize())
 889         ts &lt;&lt; indent &lt;&lt; &quot;(bounds &quot; &lt;&lt; m_size.width() &lt;&lt; &quot; &quot; &lt;&lt; m_size.height() &lt;&lt; &quot;)\n&quot;;
 890 
 891     if (m_opacity != 1)
 892         ts &lt;&lt; indent &lt;&lt; &quot;(opacity &quot; &lt;&lt; m_opacity &lt;&lt; &quot;)\n&quot;;
 893 
 894 #if ENABLE(CSS_COMPOSITING)
 895     if (m_blendMode != BlendMode::Normal)
 896         ts &lt;&lt; indent &lt;&lt; &quot;(blendMode &quot; &lt;&lt; compositeOperatorName(CompositeSourceOver, m_blendMode) &lt;&lt; &quot;)\n&quot;;
 897 #endif
 898 
 899     if (type() == Type::Normal &amp;&amp; tiledBacking())
 900         ts &lt;&lt; indent &lt;&lt; &quot;(usingTiledLayer 1)\n&quot;;
 901 
 902     bool needsIOSDumpRenderTreeMainFrameRenderViewLayerIsAlwaysOpaqueHack = client().needsIOSDumpRenderTreeMainFrameRenderViewLayerIsAlwaysOpaqueHack(*this);
 903     if (m_contentsOpaque || needsIOSDumpRenderTreeMainFrameRenderViewLayerIsAlwaysOpaqueHack)
 904         ts &lt;&lt; indent &lt;&lt; &quot;(contentsOpaque &quot; &lt;&lt; (m_contentsOpaque || needsIOSDumpRenderTreeMainFrameRenderViewLayerIsAlwaysOpaqueHack) &lt;&lt; &quot;)\n&quot;;
 905 
 906     if (m_supportsSubpixelAntialiasedText)
 907         ts &lt;&lt; indent &lt;&lt; &quot;(supports subpixel antialiased text &quot; &lt;&lt; m_supportsSubpixelAntialiasedText &lt;&lt; &quot;)\n&quot;;
 908 
<a name="8" id="anc8"></a><span class="line-added"> 909     if (m_masksToBounds &amp;&amp; behavior &amp; LayerTreeAsTextIncludeClipping)</span>
<span class="line-added"> 910         ts &lt;&lt; indent &lt;&lt; &quot;(clips &quot; &lt;&lt; m_masksToBounds &lt;&lt; &quot;)\n&quot;;</span>
<span class="line-added"> 911 </span>
 912     if (m_preserves3D)
 913         ts &lt;&lt; indent &lt;&lt; &quot;(preserves3D &quot; &lt;&lt; m_preserves3D &lt;&lt; &quot;)\n&quot;;
 914 
 915     if (m_drawsContent &amp;&amp; client().shouldDumpPropertyForLayer(this, &quot;drawsContent&quot;, behavior))
 916         ts &lt;&lt; indent &lt;&lt; &quot;(drawsContent &quot; &lt;&lt; m_drawsContent &lt;&lt; &quot;)\n&quot;;
 917 
 918     if (!m_contentsVisible)
 919         ts &lt;&lt; indent &lt;&lt; &quot;(contentsVisible &quot; &lt;&lt; m_contentsVisible &lt;&lt; &quot;)\n&quot;;
 920 
 921     if (!m_backfaceVisibility)
 922         ts &lt;&lt; indent &lt;&lt; &quot;(backfaceVisibility &quot; &lt;&lt; (m_backfaceVisibility ? &quot;visible&quot; : &quot;hidden&quot;) &lt;&lt; &quot;)\n&quot;;
 923 
<a name="9" id="anc9"></a><span class="line-modified"> 924     if (behavior &amp; LayerTreeAsTextDebug)</span>
 925         ts &lt;&lt; indent &lt;&lt; &quot;(primary-layer-id &quot; &lt;&lt; primaryLayerID() &lt;&lt; &quot;)\n&quot;;
<a name="10" id="anc10"></a>

 926 
 927     if (m_backgroundColor.isValid() &amp;&amp; client().shouldDumpPropertyForLayer(this, &quot;backgroundColor&quot;, behavior))
 928         ts &lt;&lt; indent &lt;&lt; &quot;(backgroundColor &quot; &lt;&lt; m_backgroundColor.nameForRenderTreeAsText() &lt;&lt; &quot;)\n&quot;;
 929 
 930     if (behavior &amp; LayerTreeAsTextIncludeAcceleratesDrawing &amp;&amp; m_acceleratesDrawing)
 931         ts &lt;&lt; indent &lt;&lt; &quot;(acceleratesDrawing &quot; &lt;&lt; m_acceleratesDrawing &lt;&lt; &quot;)\n&quot;;
 932 
 933     if (behavior &amp; LayerTreeAsTextIncludeBackingStoreAttached)
 934         ts &lt;&lt; indent &lt;&lt; &quot;(backingStoreAttached &quot; &lt;&lt; backingStoreAttachedForTesting() &lt;&lt; &quot;)\n&quot;;
 935 
 936     if (m_transform &amp;&amp; !m_transform-&gt;isIdentity()) {
 937         ts &lt;&lt; indent &lt;&lt; &quot;(transform &quot;;
 938         ts &lt;&lt; &quot;[&quot; &lt;&lt; m_transform-&gt;m11() &lt;&lt; &quot; &quot; &lt;&lt; m_transform-&gt;m12() &lt;&lt; &quot; &quot; &lt;&lt; m_transform-&gt;m13() &lt;&lt; &quot; &quot; &lt;&lt; m_transform-&gt;m14() &lt;&lt; &quot;] &quot;;
 939         ts &lt;&lt; &quot;[&quot; &lt;&lt; m_transform-&gt;m21() &lt;&lt; &quot; &quot; &lt;&lt; m_transform-&gt;m22() &lt;&lt; &quot; &quot; &lt;&lt; m_transform-&gt;m23() &lt;&lt; &quot; &quot; &lt;&lt; m_transform-&gt;m24() &lt;&lt; &quot;] &quot;;
 940         ts &lt;&lt; &quot;[&quot; &lt;&lt; m_transform-&gt;m31() &lt;&lt; &quot; &quot; &lt;&lt; m_transform-&gt;m32() &lt;&lt; &quot; &quot; &lt;&lt; m_transform-&gt;m33() &lt;&lt; &quot; &quot; &lt;&lt; m_transform-&gt;m34() &lt;&lt; &quot;] &quot;;
 941         ts &lt;&lt; &quot;[&quot; &lt;&lt; m_transform-&gt;m41() &lt;&lt; &quot; &quot; &lt;&lt; m_transform-&gt;m42() &lt;&lt; &quot; &quot; &lt;&lt; m_transform-&gt;m43() &lt;&lt; &quot; &quot; &lt;&lt; m_transform-&gt;m44() &lt;&lt; &quot;])\n&quot;;
 942     }
 943 
 944     // Avoid dumping the sublayer transform on the root layer, because it&#39;s used for geometry flipping, whose behavior
 945     // differs between platforms.
 946     if (parent() &amp;&amp; m_childrenTransform &amp;&amp; !m_childrenTransform-&gt;isIdentity()) {
 947         ts &lt;&lt; indent &lt;&lt; &quot;(childrenTransform &quot;;
 948         ts &lt;&lt; &quot;[&quot; &lt;&lt; m_childrenTransform-&gt;m11() &lt;&lt; &quot; &quot; &lt;&lt; m_childrenTransform-&gt;m12() &lt;&lt; &quot; &quot; &lt;&lt; m_childrenTransform-&gt;m13() &lt;&lt; &quot; &quot; &lt;&lt; m_childrenTransform-&gt;m14() &lt;&lt; &quot;] &quot;;
 949         ts &lt;&lt; &quot;[&quot; &lt;&lt; m_childrenTransform-&gt;m21() &lt;&lt; &quot; &quot; &lt;&lt; m_childrenTransform-&gt;m22() &lt;&lt; &quot; &quot; &lt;&lt; m_childrenTransform-&gt;m23() &lt;&lt; &quot; &quot; &lt;&lt; m_childrenTransform-&gt;m24() &lt;&lt; &quot;] &quot;;
 950         ts &lt;&lt; &quot;[&quot; &lt;&lt; m_childrenTransform-&gt;m31() &lt;&lt; &quot; &quot; &lt;&lt; m_childrenTransform-&gt;m32() &lt;&lt; &quot; &quot; &lt;&lt; m_childrenTransform-&gt;m33() &lt;&lt; &quot; &quot; &lt;&lt; m_childrenTransform-&gt;m34() &lt;&lt; &quot;] &quot;;
 951         ts &lt;&lt; &quot;[&quot; &lt;&lt; m_childrenTransform-&gt;m41() &lt;&lt; &quot; &quot; &lt;&lt; m_childrenTransform-&gt;m42() &lt;&lt; &quot; &quot; &lt;&lt; m_childrenTransform-&gt;m43() &lt;&lt; &quot; &quot; &lt;&lt; m_childrenTransform-&gt;m44() &lt;&lt; &quot;])\n&quot;;
 952     }
 953 
 954     if (m_maskLayer) {
 955         ts &lt;&lt; indent &lt;&lt; &quot;(mask layer&quot;;
 956         if (behavior &amp; LayerTreeAsTextDebug)
 957             ts &lt;&lt; &quot; &quot; &lt;&lt; m_maskLayer;
 958         ts &lt;&lt; &quot;)\n&quot;;
 959 
 960         TextStream::IndentScope indentScope(ts);
 961         m_maskLayer-&gt;dumpLayer(ts, behavior);
 962     }
 963 
 964     if (m_replicaLayer) {
 965         ts &lt;&lt; indent &lt;&lt; &quot;(replica layer&quot;;
 966         if (behavior &amp; LayerTreeAsTextDebug)
 967             ts &lt;&lt; &quot; &quot; &lt;&lt; m_replicaLayer;
 968         ts &lt;&lt; &quot;)\n&quot;;
 969 
 970         TextStream::IndentScope indentScope(ts);
 971         m_replicaLayer-&gt;dumpLayer(ts, behavior);
 972     }
 973 
 974     if (m_replicatedLayer) {
 975         ts &lt;&lt; indent &lt;&lt; &quot;(replicated layer&quot;;
 976         if (behavior &amp; LayerTreeAsTextDebug)
 977             ts &lt;&lt; &quot; &quot; &lt;&lt; m_replicatedLayer;
 978         ts &lt;&lt; &quot;)\n&quot;;
 979     }
 980 
 981     if (behavior &amp; LayerTreeAsTextIncludeRepaintRects &amp;&amp; repaintRectMap().contains(this) &amp;&amp; !repaintRectMap().get(this).isEmpty() &amp;&amp; client().shouldDumpPropertyForLayer(this, &quot;repaintRects&quot;, behavior)) {
 982         ts &lt;&lt; indent &lt;&lt; &quot;(repaint rects\n&quot;;
 983         for (size_t i = 0; i &lt; repaintRectMap().get(this).size(); ++i) {
 984             if (repaintRectMap().get(this)[i].isEmpty())
 985                 continue;
 986 
 987             TextStream::IndentScope indentScope(ts);
 988             ts &lt;&lt; indent &lt;&lt; &quot;(rect &quot;;
 989             ts &lt;&lt; repaintRectMap().get(this)[i].x() &lt;&lt; &quot; &quot;;
 990             ts &lt;&lt; repaintRectMap().get(this)[i].y() &lt;&lt; &quot; &quot;;
 991             ts &lt;&lt; repaintRectMap().get(this)[i].width() &lt;&lt; &quot; &quot;;
 992             ts &lt;&lt; repaintRectMap().get(this)[i].height();
 993             ts &lt;&lt; &quot;)\n&quot;;
 994         }
 995         ts &lt;&lt; indent &lt;&lt; &quot;)\n&quot;;
 996     }
 997 
<a name="11" id="anc11"></a><span class="line-modified"> 998     if (behavior &amp; LayerTreeAsTextIncludeEventRegion &amp;&amp; !m_eventRegion.isEmpty()) {</span>
<span class="line-modified"> 999         ts &lt;&lt; indent &lt;&lt; &quot;(event region&quot; &lt;&lt; m_eventRegion;</span>



















1000         ts &lt;&lt; indent &lt;&lt; &quot;)\n&quot;;
1001     }
1002 
<a name="12" id="anc12"></a><span class="line-added">1003     if (behavior &amp; LayerTreeAsTextIncludePaintingPhases &amp;&amp; paintingPhase())</span>
<span class="line-added">1004         ts &lt;&lt; indent &lt;&lt; &quot;(paintingPhases &quot; &lt;&lt; paintingPhase() &lt;&lt; &quot;)\n&quot;;</span>
<span class="line-added">1005 </span>
1006     dumpAdditionalProperties(ts, behavior);
1007 
1008     if (m_children.size()) {
1009         TextStream childrenStream;
1010 
1011         childrenStream.increaseIndent(ts.indent());
1012         unsigned totalChildCount = 0;
1013         dumpChildren(childrenStream, m_children, totalChildCount, behavior);
1014 
1015         if (totalChildCount) {
1016             ts &lt;&lt; indent &lt;&lt; &quot;(children &quot; &lt;&lt; totalChildCount &lt;&lt; &quot;\n&quot;;
1017             ts &lt;&lt; childrenStream.release();
1018             ts &lt;&lt; indent &lt;&lt; &quot;)\n&quot;;
1019         }
1020     }
1021 }
1022 
1023 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const Vector&lt;GraphicsLayer::PlatformLayerID&gt;&amp; layers)
1024 {
1025     for (size_t i = 0; i &lt; layers.size(); ++i) {
1026         if (i)
1027             ts &lt;&lt; &quot; &quot;;
1028         ts &lt;&lt; layers[i];
1029     }
1030 
1031     return ts;
1032 }
1033 
<a name="13" id="anc13"></a><span class="line-modified">1034 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, GraphicsLayerPaintingPhase phase)</span>
<span class="line-added">1035 {</span>
<span class="line-added">1036     switch (phase) {</span>
<span class="line-added">1037     case GraphicsLayerPaintingPhase::Background: ts &lt;&lt; &quot;background&quot;; break;</span>
<span class="line-added">1038     case GraphicsLayerPaintingPhase::Foreground: ts &lt;&lt; &quot;foreground&quot;; break;</span>
<span class="line-added">1039     case GraphicsLayerPaintingPhase::Mask: ts &lt;&lt; &quot;mask&quot;; break;</span>
<span class="line-added">1040     case GraphicsLayerPaintingPhase::ClipPath: ts &lt;&lt; &quot;clip-path&quot;; break;</span>
<span class="line-added">1041     case GraphicsLayerPaintingPhase::OverflowContents: ts &lt;&lt; &quot;overflow-contents&quot;; break;</span>
<span class="line-added">1042     case GraphicsLayerPaintingPhase::CompositedScroll: ts &lt;&lt; &quot;composited-scroll&quot;; break;</span>
<span class="line-added">1043     case GraphicsLayerPaintingPhase::ChildClippingMask: ts &lt;&lt; &quot;child-clipping-mask&quot;; break;</span>
<span class="line-added">1044     }</span>
<span class="line-added">1045 </span>
<span class="line-added">1046     return ts;</span>
<span class="line-added">1047 }</span>
<span class="line-added">1048 </span>
<span class="line-added">1049 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const GraphicsLayer::CustomAppearance&amp; customAppearance)</span>
1050 {
1051     switch (customAppearance) {
1052     case GraphicsLayer::CustomAppearance::None: ts &lt;&lt; &quot;none&quot;; break;
1053     case GraphicsLayer::CustomAppearance::ScrollingOverhang: ts &lt;&lt; &quot;scrolling-overhang&quot;; break;
1054     case GraphicsLayer::CustomAppearance::ScrollingShadow: ts &lt;&lt; &quot;scrolling-shadow&quot;; break;
1055     case GraphicsLayer::CustomAppearance::LightBackdrop: ts &lt;&lt; &quot;light-backdrop&quot;; break;
1056     case GraphicsLayer::CustomAppearance::DarkBackdrop: ts &lt;&lt; &quot;dark-backdrop&quot;; break;
1057     }
1058     return ts;
1059 }
1060 
1061 String GraphicsLayer::layerTreeAsText(LayerTreeAsTextBehavior behavior) const
1062 {
1063     TextStream ts(TextStream::LineMode::MultipleLine, TextStream::Formatting::SVGStyleRect);
1064 
1065     dumpLayer(ts, behavior);
1066     return ts.release();
1067 }
1068 
1069 } // namespace WebCore
1070 
1071 #if ENABLE(TREE_DEBUGGING)
1072 void showGraphicsLayerTree(const WebCore::GraphicsLayer* layer)
1073 {
1074     if (!layer)
1075         return;
1076 
1077     String output = layer-&gt;layerTreeAsText(WebCore::LayerTreeAsTextShowAll);
1078     WTFLogAlways(&quot;%s\n&quot;, output.utf8().data());
1079 }
1080 #endif
<a name="14" id="anc14"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="14" type="hidden" />
</body>
</html>